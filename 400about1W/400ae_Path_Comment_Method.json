[{
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockOperationSetFileTransfer.getMaximumFileLength",
	"Comment": "returns the maximum file length supported by the protocol in bytes.",
	"Method": "long getMaximumFileLength(){\r\n    return 2048 * 1024 * 1024;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.chatConferenceDescriptionSent",
	"Comment": "changes the chat conference dialog layout. this method is called when the local user publishes a conferencedescription instance.",
	"Method": "void chatConferenceDescriptionSent(ConferenceDescription conferenceDescription){\r\n    boolean available = conferenceDescription.isAvailable();\r\n    chatConferencesDialog.setCreatePanelEnabled(!available);\r\n    chatConferencesDialog.setEndConferenceButtonEnabled(available);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.SubscriptionMovedEvent.toString",
	"Comment": "returns a string representation of this contactpresencestatuschangeevent",
	"Method": "String toString(){\r\n    StringBuffer buff = new StringBuffer(\"SubscriptionMovedEvent-[ ContactID=\");\r\n    buff.append(getSourceContact().getAddress());\r\n    buff.append(\", OldParentGroup=\").append(getOldParentGroup().getGroupName());\r\n    buff.append(\", NewParentGroup=\").append(getNewParentGroup().getGroupName());\r\n    return buff.toString();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.globalproxyconfig.GlobalProxyPluginActivator.getConfigurationService",
	"Comment": "returns the configurationservice obtained from the bundlecontext.",
	"Method": "ConfigurationService getConfigurationService(){\r\n    if (configService == null) {\r\n        ServiceReference configReference = bundleContext.getServiceReference(ConfigurationService.class.getName());\r\n        configService = (ConfigurationService) bundleContext.getService(configReference);\r\n    }\r\n    return configService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.IcqTesterAgent.enterStatus",
	"Comment": "causes the tester agent to enter the specified icq status and returnsonly after receiving a notification from tha aim server that the newstatus has been successfully published.",
	"Method": "boolean enterStatus(long icqStatus){\r\n    BosEventNotifier bosEventNotifier = new BosEventNotifier();\r\n    conn.getBosService().addMainBosServiceListener(bosEventNotifier);\r\n    synchronized (bosEventNotifier.infoLock) {\r\n        conn.getBosService().getOscarConnection().sendSnac(new SetExtraInfoCmd(icqStatus));\r\n        try {\r\n            bosEventNotifier.infoLock.wait(10000);\r\n        } catch (InterruptedException ex) {\r\n            logger.debug(\"Strange!\");\r\n        }\r\n        conn.getBosService().removeMainBosServiceListener(bosEventNotifier);\r\n        if (bosEventNotifier.lastUserInfo == null) {\r\n            logger.debug(\"Status change was not confirmed by AIM server.\");\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.MainFrame.addPluginComponent",
	"Comment": "adds the given component with to the container corresponding to thegiven constraints.",
	"Method": "void addPluginComponent(Component c,Container container,Object constraints){\r\n    if (container.equals(Container.CONTAINER_MAIN_WINDOW)) {\r\n        if (constraints.equals(BorderLayout.NORTH)) {\r\n            pluginPanelNorth.add(c);\r\n            pluginPanelNorth.repaint();\r\n        } else if (constraints.equals(BorderLayout.SOUTH)) {\r\n            pluginPanelSouth.add(c);\r\n            pluginPanelSouth.repaint();\r\n        } else if (constraints.equals(BorderLayout.WEST)) {\r\n            pluginPanelWest.add(c);\r\n            pluginPanelWest.repaint();\r\n        } else if (constraints.equals(BorderLayout.EAST)) {\r\n            pluginPanelEast.add(c);\r\n            pluginPanelEast.repaint();\r\n        }\r\n    } else if (container.equals(Container.CONTAINER_STATUS_BAR)) {\r\n        statusBarPanel.add(c);\r\n    }\r\n    this.getContentPane().repaint();\r\n    this.getContentPane().validate();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.packetlogging.PacketLoggingConfigurationImpl.setRTPLoggingEnabled",
	"Comment": "change whether packet logging for rtp is enabledand save it in configuration.",
	"Method": "void setRTPLoggingEnabled(boolean enabled){\r\n    super.setRTPLoggingEnabled(enabled);\r\n    PacketLoggingActivator.getConfigurationService().setProperty(PACKET_LOGGING_RTP_ENABLED_PROPERTY_NAME, enabled);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.swingnotification.SwingNotificationActivator.getConfigurationService",
	"Comment": "returns the configurationservice obtained from the bundlecontext.",
	"Method": "ConfigurationService getConfigurationService(){\r\n    if (configService == null) {\r\n        ServiceReference configReference = bundleContext.getServiceReference(ConfigurationService.class.getName());\r\n        configService = (ConfigurationService) bundleContext.getService(configReference);\r\n    }\r\n    return configService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.CommandFactory.createCommand",
	"Comment": "create new command based on the provided key if available in the commandregistry.",
	"Method": "Command createCommand(String command){\r\n    if (command == null || command.isEmpty()) {\r\n        throw new IllegalArgumentException(\"command cannot be null or empty\");\r\n    }\r\n    final Class<? extends Command> type = COMMANDS.get(command);\r\n    if (type == null) {\r\n        throw new UnsupportedCommandException(command);\r\n    }\r\n    try {\r\n        Constructor<? extends Command> cmdCtor = type.getConstructor(ProtocolProviderServiceIrcImpl.class, IrcConnection.class);\r\n        return cmdCtor.newInstance(this.provider, this.connection);\r\n    } catch (NoSuchMethodException e) {\r\n        throw new BadCommandException(command, type, \"There is no compatible constructor for instantiating this \" + \"command.\", e);\r\n    } catch (InstantiationException e) {\r\n        throw new BadCommandException(command, type, \"Unable to instantiate this command class.\", e);\r\n    } catch (IllegalAccessException e) {\r\n        throw new BadCommandException(command, type, \"Unable to access the constructor of this command class.\", e);\r\n    } catch (InvocationTargetException e) {\r\n        throw new BadCommandException(command, type, \"An exception occurred while executing the constructor.\", e);\r\n    } catch (IllegalArgumentException e) {\r\n        throw new BadCommandException(command, type, \"Invalid arguments were passed to the \" + \"constructor. This may be a bug in the CommandFactory \" + \"implementation.\", e);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomJabberImpl.removePresenceExtension",
	"Comment": "removes given packetextension from the muc presence andpublishes it immediately.",
	"Method": "void removePresenceExtension(PacketExtension extension){\r\n    if (lastPresenceSent != null) {\r\n        setPacketExtension(lastPresenceSent, null, extension.getNamespace());\r\n        provider.getConnection().sendPacket(lastPresenceSent);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.IceTransportManagerSipImpl.wrapupCandidateHarvest",
	"Comment": "notifies the transport manager that it should conclude candidateharvesting as soon as possible and return the lists of candidatesgathered so far.",
	"Method": "List<Candidate<?>> wrapupCandidateHarvest(){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.jabber.JabberAccountID.isGmailNotificationEnabled",
	"Comment": "determines whether sip communicator should be querying gmail serversfor unread mail messages.",
	"Method": "boolean isGmailNotificationEnabled(){\r\n    return getAccountPropertyBoolean(GMAIL_NOTIFICATIONS_ENABLED, false);\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.AbstractSessionDataStoreTest.testGetExpiredPersistedAndExpired",
	"Comment": "test sessiondatastore.getexpired.tests the situationwhere the session candidates are also expired in thestore.",
	"Method": "void testGetExpiredPersistedAndExpired(){\r\n    ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);\r\n    context.setContextPath(\"/test\");\r\n    SessionDataStoreFactory factory = createSessionDataStoreFactory();\r\n    ((AbstractSessionDataStoreFactory) factory).setGracePeriodSec(GRACE_PERIOD_SEC);\r\n    SessionDataStore store = factory.getSessionDataStore(context.getSessionHandler());\r\n    SessionContext sessionContext = new SessionContext(\"foo\", context.getServletContext());\r\n    store.initialize(sessionContext);\r\n    SessionData data = store.newSessionData(\"1234\", 100, 101, 101, 10);\r\n    data.setLastNode(sessionContext.getWorkerName());\r\n    data.setExpiry(RECENT_TIMESTAMP);\r\n    persistSession(data);\r\n    SessionData data2 = store.newSessionData(\"5678\", 100, 100, 101, 30);\r\n    data2.setLastNode(sessionContext.getWorkerName());\r\n    data2.setExpiry(RECENT_TIMESTAMP);\r\n    persistSession(data2);\r\n    store.start();\r\n    Set<String> candidates = new HashSet(Arrays.asList(new String[] { \"1234\", \"5678\" }));\r\n    Set<String> expiredIds = store.getExpired(candidates);\r\n    assertThat(expiredIds, containsInAnyOrder(\"1234\", \"5678\"));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactImpl.getContact",
	"Comment": "returns a contact encapsulated by this meta contact, having the specifiedcontactaddress and coming from a provider with a mathingaccountid. the method returns null if no such contact exists.",
	"Method": "Contact getContact(String contactAddress,ProtocolProviderService ownerProvider,Contact getContact,String contactAddress,String accountID){\r\n    for (Contact contact : protoContacts) {\r\n        if (contact.getProtocolProvider().getAccountID().getAccountUniqueID().equals(accountID) && contact.getAddress().equals(contactAddress))\r\n            return contact;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.credentialsstorage.CredentialsStorageServiceImpl.start",
	"Comment": "initializes the credentials service by fetching the configuration servicereference from the bundle context. encrypts and moves all passwords tonew properties.",
	"Method": "void start(BundleContext bc){\r\n    configurationService = ServiceUtils.getService(bc, ConfigurationService.class);\r\n    if (!isUsingMasterPassword())\r\n        moveAllPasswordProperties();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.TrimTextField.getText",
	"Comment": "returns the trimmed value of the text contained in the field.",
	"Method": "String getText(){\r\n    String txt = super.getText();\r\n    if (txt != null)\r\n        return txt.trim();\r\n    else\r\n        return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactImpl.fireMetaContactModified",
	"Comment": "fires a new metacontactmodifiedevent which is to notify about amodification with a specific name of this metacontact which hascaused a property value change from a specific oldvalue to aspecific newvalue.",
	"Method": "void fireMetaContactModified(String modificationName,Object oldValue,Object newValue){\r\n    MetaContactGroupImpl parentGroup = getParentGroup();\r\n    if (parentGroup != null)\r\n        parentGroup.getMclServiceImpl().fireMetaContactEvent(new MetaContactModifiedEvent(this, modificationName, oldValue, newValue));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.AbstractCallPeerJabberGTalkImpl.retrieveDiscoveryInfo",
	"Comment": "retrieves the discoverinfo for a given peer identified by its uri.",
	"Method": "void retrieveDiscoveryInfo(String calleeURI){\r\n    try {\r\n        DiscoverInfo discoveryInfo = getProtocolProvider().getDiscoveryManager().discoverInfo(calleeURI);\r\n        if (discoveryInfo != null)\r\n            setDiscoveryInfo(discoveryInfo);\r\n    } catch (XMPPException xmppex) {\r\n        logger.warn(\"Could not retrieve info for \" + calleeURI, xmppex);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetPresenceSipImpl.createServerStoredContactGroup",
	"Comment": "creates a group with the specified name and parent in the serverstored contact list.",
	"Method": "void createServerStoredContactGroup(ContactGroup parentGroup,String groupName){\r\n    if (!(parentGroup instanceof ContactGroupSipImpl)) {\r\n        String errorMessage = String.format(\"Group %1s does not seem to belong to this protocol's \" + \"contact list\", parentGroup.getGroupName());\r\n        throw new IllegalArgumentException(errorMessage);\r\n    }\r\n    ContactGroupSipImpl sipGroup = (ContactGroupSipImpl) parentGroup;\r\n    ssContactList.createGroup(sipGroup, groupName, true);\r\n}"
}, {
	"Path": "io.lettuce.core.dynamic.support.ReflectionUtils.handleReflectionException",
	"Comment": "handle the given reflection exception. should only be called if no checked exception is expected to be thrown by thetarget method.throws the underlying runtimeexception or error in case of an invocationtargetexception with such a root cause. throws anillegalstateexception with an appropriate message or undeclaredthrowableexception otherwise.",
	"Method": "void handleReflectionException(Exception ex){\r\n    if (ex instanceof NoSuchMethodException) {\r\n        throw new IllegalStateException(\"Method not found: \" + ex.getMessage());\r\n    }\r\n    if (ex instanceof IllegalAccessException) {\r\n        throw new IllegalStateException(\"Could not access method: \" + ex.getMessage());\r\n    }\r\n    if (ex instanceof InvocationTargetException) {\r\n        handleInvocationTargetException((InvocationTargetException) ex);\r\n    }\r\n    if (ex instanceof RuntimeException) {\r\n        throw (RuntimeException) ex;\r\n    }\r\n    throw new UndeclaredThrowableException(ex);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomIrcImpl.setSubject",
	"Comment": "sets the subject of this chat room. if the user does not have the rightto change the room subject, or the protocol does not support this, or theoperation fails for some other reason, the method throws anoperationfailedexception with the corresponding code.",
	"Method": "void setSubject(String subject){\r\n    try {\r\n        final IrcConnection connection = this.parentProvider.getIrcStack().getConnection();\r\n        if (connection == null) {\r\n            throw new IllegalStateException(\"Connection is not available.\");\r\n        }\r\n        connection.getChannelManager().setSubject(this, subject);\r\n    } catch (RuntimeException e) {\r\n        if (e.getCause() instanceof IOException) {\r\n            throw new OperationFailedException(\"Failed to change subject.\", OperationFailedException.NETWORK_FAILURE, e.getCause());\r\n        }\r\n        throw new OperationFailedException(\"Failed to change subject.\", OperationFailedException.GENERAL_ERROR, e);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWritePanel.undoableEditHappened",
	"Comment": "handles the undoableeditevent, by adding the content edit tothe undomanager.",
	"Method": "void undoableEditHappened(UndoableEditEvent e){\r\n    this.undo.addEdit(e.getEdit());\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.contactlist.event.ProtoContactEvent.getOldParent",
	"Comment": "returns the metacontact that was parent of the source contactbefore the event occurred or null for a new contact or when irrelevant.",
	"Method": "MetaContact getOldParent(){\r\n    return (MetaContact) getOldValue();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockOperationSetBasicTelephony.createCall",
	"Comment": "creates a new call and invites a specific callpeergiven by her contact to it.",
	"Method": "Call createCall(String callee,CallConference conference,Call createCall,Contact callee,ContactResource calleeResource,CallConference conference){\r\n    return createCall(callee, conference);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaAwareCallPeer.setMediaHandler",
	"Comment": "sets a reference to the callpeermediahandler used by thispeer. the media handler class handles all media management for a singlecallpeer. this includes initializing and configuring streams,generating sdp, handling ice, etc. one instance of callpeeralways corresponds to exactly one instance ofcallpeermediahandler and both classes are only separated forreasons of readability.",
	"Method": "void setMediaHandler(U mediaHandler){\r\n    this.mediaHandler = mediaHandler;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWindow.openChat",
	"Comment": "opens the specified chatpanel and optionally brings it to thefront.",
	"Method": "void openChat(ChatPanel chatPanel,boolean setSelected){\r\n    boolean isWindowVisible = isVisible();\r\n    if (getExtendedState() != JFrame.ICONIFIED) {\r\n        if (ConfigurationUtils.isAutoPopupNewMessage() || setSelected) {\r\n            if (!isVisible())\r\n                setVisible(true);\r\n            toFront();\r\n        } else if (!isWindowVisible) {\r\n            setFocusableWindowState(false);\r\n            if (!OSUtils.IS_MAC) {\r\n                setState(Frame.ICONIFIED);\r\n            }\r\n            setVisible(true);\r\n            setFocusableWindowState(true);\r\n        }\r\n    } else {\r\n        if (setSelected) {\r\n            setExtendedState(JFrame.NORMAL);\r\n            toFront();\r\n        }\r\n        String chatWindowTitle = getTitle();\r\n        if (!chatWindowTitle.startsWith(\"*\"))\r\n            setTitle(\"*\" + chatWindowTitle);\r\n    }\r\n    if (setSelected || !isWindowVisible) {\r\n        setCurrentChat(chatPanel);\r\n    } else if (!getCurrentChat().equals(chatPanel) && getChatTabCount() > 0) {\r\n        highlightTab(chatPanel);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.MainFrame.createTopComponent",
	"Comment": "creates the toolbar panel for this chat window, depending on the currentoperating system.",
	"Method": "JComponent createTopComponent(){\r\n    JComponent topComponent = null;\r\n    if (OSUtils.IS_MAC) {\r\n        UnifiedToolBar macToolbarPanel = new UnifiedToolBar();\r\n        MacUtils.makeWindowLeopardStyle(getRootPane());\r\n        macToolbarPanel.getComponent().setLayout(new BorderLayout(5, 5));\r\n        macToolbarPanel.getComponent().setBorder(BorderFactory.createEmptyBorder(3, 5, 3, 5));\r\n        macToolbarPanel.disableBackgroundPainter();\r\n        macToolbarPanel.installWindowDraggerOnWindow(this);\r\n        centerPanel.setOpaque(true);\r\n        centerPanel.setBackground(new Color(GuiActivator.getResources().getColor(\"service.gui.MAC_PANEL_BACKGROUND\")));\r\n        topComponent = macToolbarPanel.getComponent();\r\n    } else {\r\n        JPanel panel = new TransparentPanel(new BorderLayout(5, 5));\r\n        panel.setBorder(BorderFactory.createEmptyBorder(3, 5, 3, 5));\r\n        topComponent = panel;\r\n    }\r\n    return topComponent;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractOperationSetPersistentPresence.addProviderPresenceStatusListener",
	"Comment": "adds a listener that would receive events upon changes of the providerpresence status.",
	"Method": "void addProviderPresenceStatusListener(ProviderPresenceStatusListener listener){\r\n    synchronized (providerPresenceStatusListeners) {\r\n        if (!providerPresenceStatusListeners.contains(listener))\r\n            providerPresenceStatusListeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.accountinfo.AccountInfoActivator.getGlobalDisplayDetailsService",
	"Comment": "returns the globaldisplaydetailsservice obtained from the bundlecontext.",
	"Method": "GlobalDisplayDetailsService getGlobalDisplayDetailsService(){\r\n    if (globalDisplayDetailsService == null) {\r\n        globalDisplayDetailsService = ServiceUtils.getService(bundleContext, GlobalDisplayDetailsService.class);\r\n    }\r\n    return globalDisplayDetailsService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.sysactivity.SystemActivityNotificationsServiceImpl.addIdleSystemChangeListener",
	"Comment": "registers a listener that would be notified for idle of the systemfor idletime.",
	"Method": "void addIdleSystemChangeListener(long idleTime,SystemActivityChangeListener listener){\r\n    synchronized (idleChangeListeners) {\r\n        if (idleTime > 0 && !idleChangeListeners.containsKey(listener))\r\n            idleChangeListeners.put(listener, idleTime);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.certificate.CertificateVerificationActivator.getResources",
	"Comment": "returns the resourcemanagementservice, through which we willaccess all resources.",
	"Method": "ResourceManagementService getResources(){\r\n    if (resourcesService == null) {\r\n        resourcesService = ServiceUtils.getService(bundleContext, ResourceManagementService.class);\r\n    }\r\n    return resourcesService;\r\n}"
}, {
	"Path": "io.lettuce.core.dynamic.DefaultRedisCommandsMetadata.isQueryMethodCandidate",
	"Comment": "checks whether the given method is a query method candidate.",
	"Method": "boolean isQueryMethodCandidate(Method method){\r\n    return !method.isBridge() && !method.isDefault();\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.fileaccess.TestFileAccessService.testCreateReadWriteFileInPersistentDirectory",
	"Comment": "tests if it is possible to create a persistent directory and a createfile and write and read data to this file.",
	"Method": "void testCreateReadWriteFileInPersistentDirectory(){\r\n    File privateDir = null;\r\n    try {\r\n        privateDir = this.fileAccessService.getPrivatePersistentDirectory(dirName, FileCategory.PROFILE);\r\n    } catch (IOException e) {\r\n        fail(\"Error creating the private directory: \" + e.getMessage());\r\n    }\r\n    File file = new File(privateDir, fileName);\r\n    if (file.exists()) {\r\n        assertTrue(\"Persistent file exists. Delete attempt failed. \" + \"Have you ran the tests with other user? \" + \"Is the file locked?\" + file.getAbsolutePath(), file.delete());\r\n    }\r\n    assertTrue(\"Error creating file in dir\" + file.getAbsolutePath(), file.createNewFile());\r\n    this.writeReadFile(file);\r\n    file.delete();\r\n    assertFalse(\"Could not clean up created file \" + file.getAbsolutePath(), file.exists());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.conference.ConferencePeerPanel.setPeerState",
	"Comment": "sets the state of the contained call peer by specifying thestate name.",
	"Method": "void setPeerState(CallPeerState oldState,CallPeerState newState,String stateString){\r\n    this.setParticipantState(stateString);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.ContactGibberishImpl.getProtocolProvider",
	"Comment": "returns a reference to the protocol provider that created the contact.",
	"Method": "ProtocolProviderService getProtocolProvider(){\r\n    return parentProvider;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler.addVideoListener",
	"Comment": "registers a specific videolistener with this instance so that itstarts receiving notifications from it about changes in the availabilityof visual components displaying video.",
	"Method": "void addVideoListener(VideoListener listener){\r\n    videoNotifierSupport.addVideoListener(listener);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.phonenumbercontactsource.PNContactSourceActivator.getResources",
	"Comment": "returns a reference to the resourcemanagementservice implementationcurrently registered in the bundle context or null if no suchimplementation was found.",
	"Method": "ResourceManagementService getResources(){\r\n    if (resources == null) {\r\n        resources = ServiceUtils.getService(bundleContext, ResourceManagementService.class);\r\n    }\r\n    return resources;\r\n}"
}, {
	"Path": "net.librec.recommender.cf.ranking.PNMFRecommender.predict",
	"Comment": "this is not fast if you call for each item from outsidecalculate factors first and then calculate with factors the prediction of each item",
	"Method": "double predict(SequentialSparseVector itemRatingsVector,int itemIdx,double predict,int userIdx,int itemIdx){\r\n    SequentialSparseVector itemRatingsVector = trainMatrix.row(userIdx);\r\n    return predict(itemRatingsVector, itemIdx);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallDialog.findClosestAncestorWithSetPreferredSize",
	"Comment": "finds a container which is an ancestor of a specificcomponent, has a set preferredsize and is closest tothe specified component up the ancestor hierarchy.",
	"Method": "Container findClosestAncestorWithSetPreferredSize(Component component){\r\n    if ((component instanceof Container) && component.isPreferredSizeSet())\r\n        return (Container) component;\r\n    else {\r\n        Container parent;\r\n        while ((parent = component.getParent()) != null) {\r\n            if (parent.isPreferredSizeSet())\r\n                return parent;\r\n            else\r\n                component = parent;\r\n        }\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.ConfigurationUtils.setIsMinimizeInsteadOfHide",
	"Comment": "sets whether the application should be minimized and not hidden whenclicking close on the main frame.",
	"Method": "void setIsMinimizeInsteadOfHide(boolean value){\r\n    minimizeInsteadOfHide = value;\r\n    configService.setProperty(\"net.java.sip.communicator.impl.gui.minimizeInsteadOfHide\", value);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.conference.BasicConferenceParticipantPanel.updateSoundBar",
	"Comment": "updates the sound level bar to reflect the new sound level value.",
	"Method": "void updateSoundBar(int soundLevel){\r\n    if (soundIndicator != null)\r\n        soundIndicator.updateSoundLevel(soundLevel);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.DesktopUtilActivator.getFileAccessService",
	"Comment": "returns the fileaccessservice obtained from the bundle context.",
	"Method": "FileAccessService getFileAccessService(){\r\n    if (fileAccessService == null) {\r\n        fileAccessService = ServiceUtils.getService(bundleContext, FileAccessService.class);\r\n    }\r\n    return fileAccessService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.caps.CapsPacketExtension.getExtensions",
	"Comment": "returns the value of the ext parameter as a string set ofname tokens specifying additional feature bundles. this attribute isdeprecated indicating the hashing algorithm used to generate theverification string.",
	"Method": "String getExtensions(){\r\n    return ext;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.dnsconfig.DnsConfigActivator.getConfigurationService",
	"Comment": "returns a reference to the configurationservice implementation currentlyregistered in the bundle context or null if no such implementation wasfound.",
	"Method": "ConfigurationService getConfigurationService(){\r\n    if (configurationService == null) {\r\n        configurationService = ServiceUtils.getService(bundleContext, ConfigurationService.class);\r\n    }\r\n    return configurationService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.neomedia.MediaConfigurationImpl.createEncodingControls",
	"Comment": "returns a component for encodings configuration for the givenmediatype",
	"Method": "Component createEncodingControls(int type,EncodingConfiguration encodingConfiguration,Component createEncodingControls,MediaType mediaType,EncodingConfiguration encodingConfiguration){\r\n    if (encodingConfiguration == null) {\r\n        encodingConfiguration = mediaService.getCurrentEncodingConfiguration();\r\n    }\r\n    int deviceConfigurationComboBoxModelType;\r\n    switch(mediaType) {\r\n        case AUDIO:\r\n            deviceConfigurationComboBoxModelType = DeviceConfigurationComboBoxModel.AUDIO;\r\n            break;\r\n        case VIDEO:\r\n            deviceConfigurationComboBoxModelType = DeviceConfigurationComboBoxModel.VIDEO;\r\n            break;\r\n        default:\r\n            throw new IllegalArgumentException(\"mediaType\");\r\n    }\r\n    return createEncodingControls(deviceConfigurationComboBoxModelType, encodingConfiguration);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapPersonFoundImpl.getOrganization",
	"Comment": "returns the organization found in the the directory for this person",
	"Method": "String getOrganization(){\r\n    return this.organization;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ContactGroupJabberImpl.hashCode",
	"Comment": "returns a hash code value for the object, which is actually the hashcodevalue of the groupname.",
	"Method": "int hashCode(){\r\n    return getGroupName().hashCode();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.MetaContactChatTransport.getResourceName",
	"Comment": "returns the resource name of this chat transport. this is for example thename of the user agent from which the contact is logged.",
	"Method": "String getResourceName(){\r\n    if (contactResource != null)\r\n        return contactResource.getResourceName();\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaAwareCall.getParentOperationSet",
	"Comment": "returns a reference to the operationsetbasictelephonyimplementation instance that created this call.",
	"Method": "U getParentOperationSet(){\r\n    return parentOpSet;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.aimaccregwizz.AimAccountRegistrationWizard.loadAccount",
	"Comment": "fills the uin and password fields in this panel with the data commingfrom the given protocolprovider.",
	"Method": "void loadAccount(ProtocolProviderService protocolProvider){\r\n    setModification(true);\r\n    this.protocolProvider = protocolProvider;\r\n    this.firstWizardPage.loadAccount(protocolProvider);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.ServerStoredGroupEvent.getSourceProvider",
	"Comment": "returns a reference to the provider under which the event is beinggenerated",
	"Method": "ProtocolProviderService getSourceProvider(){\r\n    return this.sourceProvider;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.configforms.ConfigFormList.valueChanged",
	"Comment": "called when user selects a component in the list of configuration forms.",
	"Method": "void valueChanged(ListSelectionEvent e){\r\n    if (!e.getValueIsAdjusting()) {\r\n        ConfigFormDescriptor configFormDescriptor = (ConfigFormDescriptor) this.getSelectedValue();\r\n        if (configFormDescriptor != null)\r\n            configFrame.showFormContent(configFormDescriptor);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockContactGroup.getParentContactGroup",
	"Comment": "returns the contact group that currently contains this group or null ifthis is the root contact group.",
	"Method": "ContactGroup getParentContactGroup(){\r\n    return this.parentGroup;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.connectioninfo.ConnectionInfoActivator.getProtocolProviderFactories",
	"Comment": "returns all protocolproviderfactorys obtained from the bundlecontext.",
	"Method": "Map<Object, ProtocolProviderFactory> getProtocolProviderFactories(){\r\n    Map<Object, ProtocolProviderFactory> providerFactoriesMap = new Hashtable<Object, ProtocolProviderFactory>();\r\n    ServiceReference[] serRefs = null;\r\n    try {\r\n        serRefs = bundleContext.getServiceReferences(ProtocolProviderFactory.class.getName(), null);\r\n    } catch (InvalidSyntaxException e) {\r\n        logger.error(\"LoginManager : \" + e);\r\n    }\r\n    for (int i = 0; i < serRefs.length; i++) {\r\n        ProtocolProviderFactory providerFactory = (ProtocolProviderFactory) bundleContext.getService(serRefs[i]);\r\n        providerFactoriesMap.put(serRefs[i].getProperty(ProtocolProviderFactory.PROTOCOL), providerFactory);\r\n    }\r\n    return providerFactoriesMap;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.NotificationMessage.getMessageGroup",
	"Comment": "returns the name of the group of messages to which thismessage belongs.",
	"Method": "String getMessageGroup(){\r\n    return messageGroup;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.sysactivity.SystemActivityNotificationsServiceImpl.getTimeSinceLastInput",
	"Comment": "the time since last user input. the time the system has been idle.",
	"Method": "long getTimeSinceLastInput(){\r\n    if (SystemActivityNotifications.isLoaded())\r\n        return SystemActivityNotifications.getLastInput();\r\n    else\r\n        return -1;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatManager.fireAdHocChatRoomListChangedEvent",
	"Comment": "notifies all interested listeners that a change in the chat room listmodel has occurred.",
	"Method": "void fireAdHocChatRoomListChangedEvent(AdHocChatRoomWrapper adHocChatRoomWrapper,int eventID){\r\n    AdHocChatRoomListChangeEvent evt = new AdHocChatRoomListChangeEvent(adHocChatRoomWrapper, eventID);\r\n    for (AdHocChatRoomListChangeListener l : adHoclistChangeListeners) {\r\n        l.contentChanged(evt);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.GraphicUtils.createRoundedClipShape",
	"Comment": "creates a rounded clipped shape with the given shapewidth,shapeheight, arc width and arc height.",
	"Method": "Shape createRoundedClipShape(int shapeWidth,int shapeHeight,int arcW,int arcH){\r\n    return new RoundRectangle2D.Float(0, 0, shapeWidth, shapeHeight, arcW, arcH);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.account.AccountList.accountListModelContentChanged",
	"Comment": "notifies accountlistmodel that the accounts ofa specific protocolproviderservice has changed.",
	"Method": "void accountListModelContentChanged(ProtocolProviderService protocolProvider){\r\n    Enumeration<?> accounts = accountListModel.elements();\r\n    while (accounts.hasMoreElements()) {\r\n        Account account = (Account) accounts.nextElement();\r\n        ProtocolProviderService accountProvider = account.getProtocolProvider();\r\n        if (accountProvider == protocolProvider)\r\n            accountListModel.contentChanged(account);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.conference.VideoConferenceCallPanel.createDefaultPhotoPanel",
	"Comment": "creates a new component which is to display a specificimageicon representing the photo of a participant in a call.",
	"Method": "Component createDefaultPhotoPanel(Call call,Component createDefaultPhotoPanel,CallPeer callPeer,Component createDefaultPhotoPanel,ConferenceMember conferenceMember,Component createDefaultPhotoPanel,ImageIcon photoLabelIcon){\r\n    JLabel photoLabel = new JLabel();\r\n    photoLabel.setIcon(photoLabelIcon);\r\n    @SuppressWarnings(\"serial\")\r\n    JPanel photoPanel = new TransparentPanel(new GridBagLayout()) {\r\n        @Override\r\n        public void paintComponent(Graphics g) {\r\n            super.paintComponent(g);\r\n            g = g.create();\r\n            try {\r\n                AntialiasingManager.activateAntialiasing(g);\r\n                g.setColor(Color.GRAY);\r\n                g.fillRoundRect(0, 0, this.getWidth(), this.getHeight(), 6, 6);\r\n            } finally {\r\n                g.dispose();\r\n            }\r\n        }\r\n    };\r\n    photoPanel.setPreferredSize(new Dimension(320, 240));\r\n    GridBagConstraints photoPanelConstraints = new GridBagConstraints();\r\n    photoPanelConstraints.anchor = GridBagConstraints.CENTER;\r\n    photoPanelConstraints.fill = GridBagConstraints.NONE;\r\n    photoPanel.add(photoLabel, photoPanelConstraints);\r\n    return photoPanel;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.conference.VideoConferenceCallPanel.createDefaultPhotoPanel",
	"Comment": "creates a new component which is to display a specificimageicon representing the photo of a participant in a call.",
	"Method": "Component createDefaultPhotoPanel(Call call,Component createDefaultPhotoPanel,CallPeer callPeer,Component createDefaultPhotoPanel,ConferenceMember conferenceMember,Component createDefaultPhotoPanel,ImageIcon photoLabelIcon){\r\n    super.paintComponent(g);\r\n    g = g.create();\r\n    try {\r\n        AntialiasingManager.activateAntialiasing(g);\r\n        g.setColor(Color.GRAY);\r\n        g.fillRoundRect(0, 0, this.getWidth(), this.getHeight(), 6, 6);\r\n    } finally {\r\n        g.dispose();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.utils.FileImageLabel.scaleFileIcon",
	"Comment": "returns a scaled instance of the given icon if it exceeds the givenbounds.",
	"Method": "ImageIcon scaleFileIcon(ImageIcon icon,int width,int height){\r\n    ImageIcon image = null;\r\n    if (icon.getIconWidth() <= width && icon.getIconHeight() <= height)\r\n        image = icon;\r\n    else\r\n        image = ImageUtils.getScaledRoundedIcon(icon.getImage(), width, height);\r\n    return image;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallManager.isLocalUser",
	"Comment": "indicates if the given conferencemember corresponds to the localuser.",
	"Method": "boolean isLocalUser(ConferenceMember conferenceMember){\r\n    String localUserAddress = conferenceMember.getConferenceFocusCallPeer().getProtocolProvider().getAccountID().getAccountAddress();\r\n    return CallManager.addressesAreEqual(conferenceMember.getAddress(), localUserAddress);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.authorization.AuthorizationHandlerImpl.createAuthorizationRequest",
	"Comment": "implements the authorizationhandler.createauthorizationrequestmethod.the method is called when the user has tried to add a contact to thecontact list and this contact requires authorization.",
	"Method": "AuthorizationRequest createAuthorizationRequest(Contact contact){\r\n    AuthorizationRequest request = new AuthorizationRequest();\r\n    RequestAuthorizationDialog dialog = null;\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        RequestAuthorizationRunnable runnable = new RequestAuthorizationRunnable(contact, request);\r\n        try {\r\n            SwingUtilities.invokeAndWait(runnable);\r\n        } catch (Throwable t) {\r\n            if (dialog == null) {\r\n                runnable.run();\r\n            }\r\n        }\r\n        dialog = runnable.getDialog();\r\n    } else {\r\n        dialog = createAndShowRequestAuthorizationDialog(contact, request);\r\n    }\r\n    int returnCode = dialog.getReturnCode();\r\n    if (returnCode == RequestAuthorizationDialog.OK_RETURN_CODE) {\r\n        request.setReason(dialog.getRequestReason());\r\n    } else {\r\n        request = null;\r\n    }\r\n    return request;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetServerStoredAccountInfoJabberImpl.getDetailsAndDescendants",
	"Comment": "returns an iterator over all details that are instances or descendants ofthe specified class. if for example an our account has a work addressand an address detail, a call to this method with addressdetail.classwould return both of them.",
	"Method": "Iterator<T> getDetailsAndDescendants(Class<T> detailClass){\r\n    assertConnected();\r\n    return infoRetreiver.getDetailsAndDescendants(uin, detailClass);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.WhiteboardObjectDeletedEvent.getTimestamp",
	"Comment": "a timestamp indicating the exact date when the event ocurred.",
	"Method": "Date getTimestamp(){\r\n    return timestamp;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatSession.getHistoryBeforeDate",
	"Comment": "returns a collection of the last n number of messages given by count.",
	"Method": "Collection<Object> getHistoryBeforeDate(Date date,int count){\r\n    final MetaHistoryService metaHistory = GuiActivator.getMetaHistoryService();\r\n    if (metaHistory == null)\r\n        return null;\r\n    return metaHistory.findLastMessagesBefore(chatHistoryFilter, chatRoomWrapper.getChatRoom(), date, count);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.IcqActivator.getIcqProtocolProviderFactory",
	"Comment": "retrurns a reference to the protocol provider factory that we haveregistered for icq accounts.",
	"Method": "ProtocolProviderFactoryIcqImpl getIcqProtocolProviderFactory(){\r\n    return icqProviderFactory;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.customcontrols.ExtendedTableModel.rowIndexOf",
	"Comment": "returns the index of the row, in which the given value is contained.",
	"Method": "int rowIndexOf(Object value){\r\n    Vector<Vector<Object>> dataVec = this.getDataVector();\r\n    for (int i = 0; i < dataVector.size(); i++) {\r\n        Vector<Object> rowVector = dataVec.get(i);\r\n        if (rowVector.contains(value)) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.plaf.SIPCommTreeUI.createLayoutCache",
	"Comment": "creates the object responsible for managing what is expanded, aswell as the size of nodes.",
	"Method": "AbstractLayoutCache createLayoutCache(){\r\n    layoutCache = new VariableLayoutCache();\r\n    return layoutCache;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.TreeContactList.startSelectedContactCall",
	"Comment": "starts a call with the currently selected contact in the contact list.",
	"Method": "void startSelectedContactCall(){\r\n    TreePath selectionPath = getSelectionPath();\r\n    if (selectionPath == null)\r\n        return;\r\n    ContactListTreeCellRenderer renderer = (ContactListTreeCellRenderer) getCellRenderer().getTreeCellRendererComponent(this, selectionPath.getLastPathComponent(), true, true, true, this.getRowForPath(selectionPath), true);\r\n    renderer.getCallButton().doClick();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.CryptoPacketExtension.toSrtpCryptoAttribute",
	"Comment": "returns a srtpcryptoattribute corresponding to thiscryptopacketextension.",
	"Method": "SrtpCryptoAttribute toSrtpCryptoAttribute(){\r\n    return SrtpCryptoAttribute.create(this.getTag(), this.getCryptoSuite(), this.getKeyParams(), this.getSessionParams());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.osdependent.systemtray.SystemTray.getSystemTray",
	"Comment": "gets or creates the supported systemtray implementations.",
	"Method": "SystemTray getSystemTray(){\r\n    if (systemTray == null) {\r\n        String mode = getSystemTrayMode();\r\n        logger.info(\"Tray for \" + mode + \" requested\");\r\n        switch(mode) {\r\n            case DISABLED_TRAY_MODE:\r\n                return null;\r\n            case \"native\":\r\n                if (java.awt.SystemTray.isSupported()) {\r\n                    systemTray = new AWTSystemTray();\r\n                }\r\n                break;\r\n            case \"appindicator\":\r\n                try {\r\n                    systemTray = new AppIndicatorTray(true);\r\n                } catch (Exception ex) {\r\n                    logger.error(\"AppIndicator tray not available\", ex);\r\n                }\r\n                break;\r\n            case \"appindicator_static\":\r\n                try {\r\n                    systemTray = new AppIndicatorTray(false);\r\n                } catch (Exception ex) {\r\n                    logger.error(\"AppIndicator tray not available\", ex);\r\n                }\r\n                break;\r\n        }\r\n        if (systemTray == null) {\r\n            OsDependentActivator.getConfigurationService().setProperty(SystrayService.PNMAE_TRAY_MODE, \"disabled\");\r\n        }\r\n    }\r\n    return systemTray;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.sysactivity.SystemActivityNotificationsServiceImpl.addSystemActivityChangeListener",
	"Comment": "registers a listener that would be notified of changes that have occurredin the underlying system.",
	"Method": "void addSystemActivityChangeListener(SystemActivityChangeListener listener){\r\n    eventDispatcher.addSystemActivityChangeListener(listener);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.sdp.SdpUtils.containsAttribute",
	"Comment": "returns whether description contains the specifiedattributename.",
	"Method": "boolean containsAttribute(MediaDescription description,String attributeName){\r\n    try {\r\n        Vector<Attribute> atts = description.getAttributes(false);\r\n        for (Attribute a : atts) {\r\n            if (a.getName().equals(attributeName))\r\n                return true;\r\n        }\r\n        return false;\r\n    } catch (SdpException e) {\r\n        String message = \"Invalid media type in a= line: \" + description;\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(message, e);\r\n        throw new IllegalArgumentException(message, e);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.WhiteboardInvitationRejectedEvent.getWhiteboardSession",
	"Comment": "returns the whiteboardsession for which the initial invitationwas.",
	"Method": "WhiteboardSession getWhiteboardSession(){\r\n    return whiteboardSession;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.gui.AbstractExportedWindow.getWindow",
	"Comment": "gets the window wrapped by this instance and to whichexportedwindow capabilities are provided.",
	"Method": "T getWindow(){\r\n    if (window == null)\r\n        window = createWindow();\r\n    return window;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatContact.hashCode",
	"Comment": "gets a hash code value for this object for the benefit of hashtables.",
	"Method": "int hashCode(){\r\n    return getDescriptor().hashCode();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AccountManager.serviceChanged",
	"Comment": "notifies this manager that an osgi service has changed. the currentimplementation tracks the registrations ofprotocolproviderfactory services in order to queue them forloading their stored accounts.",
	"Method": "void serviceChanged(ServiceEvent serviceEvent){\r\n    switch(serviceEvent.getType()) {\r\n        case ServiceEvent.REGISTERED:\r\n            Object service = bundleContext.getService(serviceEvent.getServiceReference());\r\n            if (service instanceof ProtocolProviderFactory) {\r\n                protocolProviderFactoryRegistered((ProtocolProviderFactory) service);\r\n            }\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.SearchFilter.isMatching",
	"Comment": "for all groups we return false. if some of the child contacts of thisgroup matches this filter the group would be automatically added whenthe contact is added in the list.",
	"Method": "boolean isMatching(UIContact uiContact,boolean isMatching,UIGroup uiGroup,boolean isMatching,String text){\r\n    if (filterPattern != null && filterPattern.matcher(text).find())\r\n        return true;\r\n    if (isSearchingPhoneNumber && this.filterString != null)\r\n        return GuiActivator.getPhoneNumberI18nService().phoneNumbersMatch(this.filterString, text);\r\n    return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.globaldisplaydetails.GlobalStatusServiceImpl.registrationStateChanged",
	"Comment": "waits for providers to register and then checks for its last statussaved if any and used it to restore its status.",
	"Method": "void registrationStateChanged(RegistrationStateChangeEvent evt){\r\n    if (!evt.getNewState().equals(RegistrationState.REGISTERED))\r\n        return;\r\n    handleProviderRegistered(evt.getProvider(), true);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.TransportManagerJabberImpl.cloneTransportAndCandidates",
	"Comment": "clones a specific iceudptransportpacketextension and itscandidates.",
	"Method": "IceUdpTransportPacketExtension cloneTransportAndCandidates(IceUdpTransportPacketExtension src){\r\n    try {\r\n        return IceUdpTransportPacketExtension.cloneTransportAndCandidates(src);\r\n    } catch (Exception e) {\r\n        ProtocolProviderServiceJabberImpl.throwOperationFailedException(\"Failed to close transport and candidates.\", OperationFailedException.GENERAL_ERROR, e, logger);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.GuiActivator.getContactListService",
	"Comment": "returns the metacontactlistservice obtained from the bundlecontext.",
	"Method": "MetaContactListService getContactListService(){\r\n    if (metaCListService == null) {\r\n        metaCListService = ServiceUtils.getService(bundleContext, MetaContactListService.class);\r\n    }\r\n    return metaCListService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.TestOperationSetBasicInstantMessaging.reportingSendFunMessages",
	"Comment": "a method that would simply send messages to a group of people so thatthey would get notified that tests are being run.",
	"Method": "void reportingSendFunMessages(){\r\n    String hostname = \"\";\r\n    try {\r\n        hostname = java.net.InetAddress.getLocalHost().getHostName() + \": \";\r\n    } catch (UnknownHostException ex) {\r\n    }\r\n    String message = hostname + \"Hello this is the SIP Communicator (version \" + System.getProperty(\"sip-communicator.version\") + \") build on: \" + new Date().toString() + \". Have a very nice day!\";\r\n    String list = System.getProperty(\"accounts.reporting.JABBER_REPORT_LIST\");\r\n    logger.debug(\"Will send message \" + message + \" to: \" + list);\r\n    if (list == null || list.trim().length() == 0)\r\n        return;\r\n    StringTokenizer tokenizer = new StringTokenizer(list, \" \");\r\n    while (tokenizer.hasMoreTokens()) {\r\n        String contactID = tokenizer.nextToken();\r\n        Contact contact = opSetPresence2.findContactByID(contactID);\r\n        if (contact == null) {\r\n            try {\r\n                opSetPresence2.subscribe(contactID);\r\n                Object o = new Object();\r\n                synchronized (o) {\r\n                    o.wait(2000);\r\n                }\r\n            } catch (Exception ex1) {\r\n                continue;\r\n            }\r\n        }\r\n        contact = opSetPresence2.findContactByID(contactID);\r\n        opSetBasicIM2.sendInstantMessage(contact, opSetBasicIM2.createMessage(message));\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetPersistentPresenceIcqImpl.createUnresolvedContactGroup",
	"Comment": "creates and returns a unresolved contact group from the specifiedaddress and persistentdata. the method will not tryto establish a network connection and resolve the newly createdcontactgroup against the server or the contact itself. theprotocol provider will later resolve the contact group. when this happensthe corresponding event would notify interested subscription listeners.",
	"Method": "ContactGroup createUnresolvedContactGroup(String groupUID,String persistentData,ContactGroup parentGroup){\r\n    return ssContactList.createUnresolvedContactGroup(groupUID);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetDesktopSharingServerSipImpl.createVideoCall",
	"Comment": "create a new video call and invite the specified callpeer to it.",
	"Method": "Call createVideoCall(String uri,MediaDevice device,Call createVideoCall,Contact callee,MediaDevice device){\r\n    CallSipImpl call = (CallSipImpl) super.createVideoCall(callee, device);\r\n    CallPeerSipImpl callPeer = call.getCallPeers().next();\r\n    callPeer.addMethodProcessorListener(this);\r\n    callPeer.addCallPeerListener(callPeerListener);\r\n    size = (((VideoMediaFormat) call.getDefaultDevice(MediaType.VIDEO).getFormat()).getSize());\r\n    origin = getOriginForMediaDevice(device);\r\n    return call;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommTabbedPane.fireMaxTabEvent",
	"Comment": "sends a mouseevent, whose source is this tabbedpane, toevery maxlistener. the method also updates theovertabindex of the tabbedpane with a value coming fromthe ui. this method method is called each time a mouseeventis received from the ui when the user clicks on the max icon of the tabwhich index is overtabindex.",
	"Method": "void fireMaxTabEvent(MouseEvent e,int overTabIndex){\r\n    this.overTabIndex = overTabIndex;\r\n    EventListener[] maxListeners = getListeners(MaxListener.class);\r\n    for (int i = 0; i < maxListeners.length; i++) {\r\n        ((MaxListener) maxListeners[i]).maxOperation(e);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl.initRegistrarConnection",
	"Comment": "initializes the sipregistrarconnection that this class will be using.",
	"Method": "void initRegistrarConnection(){\r\n    String registrarAddressStr = accountID.getAccountPropertyString(ProtocolProviderFactory.SERVER_ADDRESS);\r\n    if (registrarAddressStr == null) {\r\n        String userID = accountID.getAccountPropertyString(ProtocolProviderFactory.USER_ID);\r\n        int index = userID.indexOf('@');\r\n        if (index > -1)\r\n            registrarAddressStr = userID.substring(index + 1);\r\n    }\r\n    if (registrarAddressStr == null || registrarAddressStr.trim().length() == 0) {\r\n        initRegistrarlessConnection();\r\n        return;\r\n    }\r\n    int registrarPort = ListeningPoint.PORT_5060;\r\n    registrarPort = accountID.getAccountPropertyInt(ProtocolProviderFactory.SERVER_PORT, registrarPort);\r\n    if (registrarPort > NetworkUtils.MAX_PORT_NUMBER) {\r\n        throw new IllegalArgumentException(registrarPort + \" is larger than \" + NetworkUtils.MAX_PORT_NUMBER + \" and does not therefore represent a valid port number.\");\r\n    }\r\n    this.sipRegistrarConnection = new SipRegistrarConnection(registrarAddressStr, registrarPort, getRegistrarTransport(), this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.ConferenceDescription.compareConferenceDescription",
	"Comment": "checks if two conferencedescription instances have the same call id, uri and supported transports.",
	"Method": "boolean compareConferenceDescription(ConferenceDescription cd){\r\n    return (getCallId().equals(cd.getCallId()) && getUri().equals(cd.getUri()) && getSupportedTransports().equals(cd.getSupportedTransports()));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.RootContactGroupIcqImpl.subgroups",
	"Comment": "returns an iterator over the sub groups that thiscontactgroup contains.",
	"Method": "Iterator<ContactGroup> subgroups(){\r\n    return subGroups.iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.DialPanel.mouseReleased",
	"Comment": "handles the mouseevent triggered when user releases one of thedial buttons.",
	"Method": "void mouseReleased(MouseEvent ev){\r\n    dtmfHandler.stopSendingDtmfTone();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jitsimeet.MediaPresenceExtension.registerExtensions",
	"Comment": "registers packet jitsi meet media presence packet extensions in givenprovidermanager.",
	"Method": "void registerExtensions(ProviderManager providerManager){\r\n    providerManager.addExtensionProvider(MediaPresenceExtension.ELEMENT_NAME, MediaPresenceExtension.NAMESPACE, new DefaultPacketExtensionProvider<MediaPresenceExtension>(MediaPresenceExtension.class));\r\n    providerManager.addExtensionProvider(MediaPresenceExtension.Source.ELEMENT_NAME, MediaPresenceExtension.Source.NAMESPACE, new DefaultPacketExtensionProvider<Source>(Source.class));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.history.HistoryReaderImpl.findByStartDate",
	"Comment": "searches the history for all records with timestamp afterstartdate.",
	"Method": "QueryResultSet<HistoryRecord> findByStartDate(Date startDate){\r\n    return find(startDate, null, null, null, false);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.AuthenticationWindow.enableKeyActions",
	"Comment": "enables the actions when a key is pressed, for nowcloses the window when esc is pressed.",
	"Method": "void enableKeyActions(){\r\n    @SuppressWarnings(\"serial\")\r\n    UIAction act = new UIAction() {\r\n        public void actionPerformed(ActionEvent e) {\r\n            close(true);\r\n        }\r\n    };\r\n    getRootPane().getActionMap().put(\"close\", act);\r\n    InputMap imap = this.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);\r\n    imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), \"close\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.AuthenticationWindow.enableKeyActions",
	"Comment": "enables the actions when a key is pressed, for nowcloses the window when esc is pressed.",
	"Method": "void enableKeyActions(){\r\n    close(true);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetBasicInstantMessagingIcqImpl.assertConnected",
	"Comment": "utility method throwing an exception if the icq stack is not properlyinitialized.",
	"Method": "void assertConnected(){\r\n    if (icqProvider == null)\r\n        throw new IllegalStateException(\"The icq provider must be non-null and signed on the ICQ \" + \"service before being able to communicate.\");\r\n    if (!icqProvider.isRegistered())\r\n        throw new IllegalStateException(\"The icq provider must be signed on the ICQ service before \" + \"being able to communicate.\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.otr.ScOtrEngineImpl.isHistoryLoggingEnabled",
	"Comment": "checks whether history is enabled for the metacontact containingthe contact.",
	"Method": "boolean isHistoryLoggingEnabled(Contact contact){\r\n    MetaContact metaContact = OtrActivator.getContactListService().findMetaContactByContact(contact);\r\n    if (metaContact != null)\r\n        return OtrActivator.getMessageHistoryService().isHistoryLoggingEnabled(metaContact.getMetaUID());\r\n    else\r\n        return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.SubscriptionMovedEvent.getNewParentGroup",
	"Comment": "returns a reference to the contactgroup that currently contains thesource contact.",
	"Method": "ContactGroup getNewParentGroup(){\r\n    return newParent;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.WhiteboardSessionPresenceChangeEvent.getWhiteboardOpSet",
	"Comment": "returns the operationsetwhiteboarding, where this event hasoccurred.",
	"Method": "OperationSetWhiteboarding getWhiteboardOpSet(){\r\n    return (OperationSetWhiteboarding) getSource();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.whiteboard.WhiteboardSessionPacketExtension.setContactAddress",
	"Comment": "sets the address of the contact associated with this packet extension",
	"Method": "void setContactAddress(String contactAddress){\r\n    this.contactAddress = contactAddress;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.JabberAccountRegistrationWizard.getCreateAccountService",
	"Comment": "returns an instance of createaccountservice through which theuser could create an account. this method is meant to be implemented byspecific protocol provider wizards.",
	"Method": "JabberAccountCreationFormService getCreateAccountService(){\r\n    if (createAccountService == null)\r\n        createAccountService = new JabberAccountCreationForm();\r\n    return createAccountService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetUserSearchJabberImpl.removeUserSearchProviderListener",
	"Comment": "removes usersearchproviderlistener instance from the list oflisteners.",
	"Method": "void removeUserSearchProviderListener(UserSearchProviderListener l){\r\n    synchronized (listeners) {\r\n        listeners.remove(l);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.IceConfigPanel.addStunServer",
	"Comment": "adds the given stunserver to the list of additional stunservers.",
	"Method": "void addStunServer(StunServerDescriptor stunServer){\r\n    tableModel.addRow(new Object[] { stunServer, stunServer.isTurnSupported() });\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockOperationSetFileTransfer.fireFileTransferRequest",
	"Comment": "delivers the specified event to all registered file transfer listeners.",
	"Method": "void fireFileTransferRequest(FileTransferRequestEvent event){\r\n    Iterator<FileTransferListener> listeners = null;\r\n    synchronized (fileTransferListeners) {\r\n        listeners = new ArrayList<FileTransferListener>(fileTransferListeners).iterator();\r\n    }\r\n    while (listeners.hasNext()) {\r\n        FileTransferListener listener = listeners.next();\r\n        listener.fileTransferRequestReceived(event);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.AbstractOperationSetTelephonyConferencing.callPeerAdded",
	"Comment": "notifies this callchangelistener that a specificcallpeer has been added to a specific call.",
	"Method": "void callPeerAdded(CallPeerEvent event){\r\n    MediaAwareCallPeer<?, ?, ?> callPeer = (MediaAwareCallPeer<?, ?, ?>) event.getSourceCallPeer();\r\n    callPeer.addCallPeerListener(callPeerListener);\r\n    callPeer.getMediaHandler().addPropertyChangeListener(this);\r\n    callPeersChanged(event);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipRegistrarlessConnection.isRegistrarless",
	"Comment": "returns true if this is a fake connection that is not actually usinga registrar. this method should be overridden insipregistrarlessconnection and return true in there.",
	"Method": "boolean isRegistrarless(){\r\n    return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.EventPackageSupport.getSubscriptions",
	"Comment": "gets a new copy of the list of subscriptions managed by thisinstance.",
	"Method": "Subscription[] getSubscriptions(){\r\n    synchronized (this.subscriptions) {\r\n        Collection<Subscription> subscriptions = this.subscriptions.values();\r\n        return subscriptions.toArray(new Subscription[subscriptions.size()]);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MclStorageManager.protoContactModified",
	"Comment": "updates the data stored for the contact that caused this event.",
	"Method": "void protoContactModified(ProtoContactEvent evt){\r\n    Element metaContactNode = findMetaContactNode(evt.getParent().getMetaUID());\r\n    if (metaContactNode == null) {\r\n        logger.error(\"Save after proto contact modification failed. \" + \"Contact not found: \" + evt.getParent());\r\n        return;\r\n    }\r\n    updatePersistentDataForMetaContact(evt.getParent());\r\n    try {\r\n        scheduleContactListStorage();\r\n    } catch (IOException ex) {\r\n        logger.error(\"Writing CL failed after rename of \" + evt.getParent(), ex);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallTransferHandler.importData",
	"Comment": "handles transfers to the chat panel from the clip board or adnd drop operation. the transferable parameter contains thedata that needs to be imported.",
	"Method": "boolean importData(JComponent comp,Transferable t){\r\n    String callee = null;\r\n    ProtocolProviderService provider = null;\r\n    if (t.isDataFlavorSupported(uiContactDataFlavor)) {\r\n        Object o = null;\r\n        try {\r\n            o = t.getTransferData(uiContactDataFlavor);\r\n        } catch (UnsupportedFlavorException e) {\r\n            if (logger.isDebugEnabled())\r\n                logger.debug(\"Failed to drop meta contact.\", e);\r\n        } catch (IOException e) {\r\n            if (logger.isDebugEnabled())\r\n                logger.debug(\"Failed to drop meta contact.\", e);\r\n        }\r\n        if (o instanceof ContactNode) {\r\n            UIContact uiContact = ((ContactNode) o).getContactDescriptor();\r\n            Iterator<UIContactDetail> contactDetails = uiContact.getContactDetailsForOperationSet(OperationSetBasicTelephony.class).iterator();\r\n            while (contactDetails.hasNext()) {\r\n                UIContactDetail detail = contactDetails.next();\r\n                ProtocolProviderService detailProvider = detail.getPreferredProtocolProvider(OperationSetBasicTelephony.class);\r\n                if (detailProvider != null) {\r\n                    if (callConference.isJitsiVideobridge()) {\r\n                        for (Call call : callConference.getCalls()) {\r\n                            if (detailProvider == call.getProtocolProvider()) {\r\n                                callee = detail.getAddress();\r\n                                provider = detailProvider;\r\n                                break;\r\n                            }\r\n                        }\r\n                    } else {\r\n                        callee = detail.getAddress();\r\n                        provider = detailProvider;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (callee == null) {\r\n                ProtocolProviderService callProvider = callConference.getCalls().get(0).getProtocolProvider();\r\n                ResourceManagementService resources = GuiActivator.getResources();\r\n                AccountID accountID = callProvider.getAccountID();\r\n                new ErrorDialog(null, resources.getI18NString(\"service.gui.ERROR\"), resources.getI18NString(\"service.gui.CALL_NOT_SUPPORTING_PARTICIPANT\", new String[] { accountID.getService(), accountID.getUserID(), uiContact.getDisplayName() })).showDialog();\r\n            }\r\n        }\r\n    } else if (t.isDataFlavorSupported(DataFlavor.stringFlavor)) {\r\n        InputContext inputContext = comp.getInputContext();\r\n        if (inputContext != null)\r\n            inputContext.endComposition();\r\n        try {\r\n            BufferedReader reader = new BufferedReader(DataFlavor.stringFlavor.getReaderForText(t));\r\n            try {\r\n                String line;\r\n                StringBuilder calleeBuilder = new StringBuilder();\r\n                while ((line = reader.readLine()) != null) calleeBuilder.append(line);\r\n                callee = calleeBuilder.toString();\r\n            } finally {\r\n                reader.close();\r\n            }\r\n        } catch (UnsupportedFlavorException e) {\r\n            if (logger.isDebugEnabled())\r\n                logger.debug(\"Failed to drop string.\", e);\r\n        } catch (IOException e) {\r\n            if (logger.isDebugEnabled())\r\n                logger.debug(\"Failed to drop string.\", e);\r\n        }\r\n    }\r\n    if (callee == null)\r\n        return false;\r\n    else {\r\n        Map<ProtocolProviderService, List<String>> callees = new HashMap<ProtocolProviderService, List<String>>();\r\n        callees.put(provider, Arrays.asList(callee));\r\n        CallManager.inviteToConferenceCall(callees, callConference);\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatTransport.getProtocolProvider",
	"Comment": "returns the protocolproviderservice, corresponding to this chattransport.",
	"Method": "ProtocolProviderService getProtocolProvider(){\r\n    return chatRoom.getParentProvider();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ContactGroupJabberImpl.setNameCopy",
	"Comment": "sets the name copy field that we use as a means of detecting changes inthe group name.",
	"Method": "void setNameCopy(String newName){\r\n    this.nameCopy = newName;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chatroomslist.joinforms.SearchChatRoomPanel.setChatRoomName",
	"Comment": "sets the given chat room name to the text field, contained in this panel.",
	"Method": "void setChatRoomName(String chatRoomName){\r\n    namePanel.setChatRoomName(chatRoomName);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallManager.getPeerDisplayName",
	"Comment": "a informative text to show for the peer. if display name is missingreturn the address.",
	"Method": "String getPeerDisplayName(CallPeer peer,DetailsResolveListener listener){\r\n    String displayName = null;\r\n    UIContactImpl uiContact = CallManager.getCallUIContact(peer.getCall());\r\n    if (uiContact != null) {\r\n        if (uiContact.getDescriptor() instanceof SourceContact) {\r\n            Contact contact = getPeerCusaxContact(peer, (SourceContact) uiContact.getDescriptor());\r\n            if (contact != null)\r\n                displayName = contact.getDisplayName();\r\n        }\r\n        if (StringUtils.isNullOrEmpty(displayName, true))\r\n            displayName = uiContact.getDisplayName();\r\n    }\r\n    if (StringUtils.isNullOrEmpty(displayName, true) && peer.getContact() != null) {\r\n        displayName = peer.getContact().getDisplayName();\r\n    }\r\n    if (StringUtils.isNullOrEmpty(displayName, true)) {\r\n        String imppAddress = peer.getAlternativeIMPPAddress();\r\n        if (!StringUtils.isNullOrEmpty(imppAddress)) {\r\n            int protocolPartIndex = imppAddress.indexOf(\":\");\r\n            imppAddress = (protocolPartIndex >= 0) ? imppAddress.substring(protocolPartIndex + 1) : imppAddress;\r\n            Collection<ProtocolProviderService> cusaxProviders = AccountUtils.getRegisteredProviders(OperationSetCusaxUtils.class);\r\n            if (cusaxProviders != null && cusaxProviders.size() > 0) {\r\n                Iterator<ProtocolProviderService> iter = cusaxProviders.iterator();\r\n                while (iter.hasNext()) {\r\n                    Contact contact = getPeerContact(peer, iter.next(), imppAddress);\r\n                    displayName = (contact != null) ? contact.getDisplayName() : null;\r\n                    if (!StringUtils.isNullOrEmpty(displayName, true))\r\n                        break;\r\n                }\r\n            } else {\r\n                MetaContact metaContact = getPeerMetaContact(peer, imppAddress);\r\n                displayName = (metaContact != null) ? metaContact.getDisplayName() : null;\r\n            }\r\n        }\r\n    }\r\n    if (StringUtils.isNullOrEmpty(displayName, true)) {\r\n        displayName = (!StringUtils.isNullOrEmpty(peer.getDisplayName(), true)) ? peer.getDisplayName() : peer.getAddress();\r\n        String resolvedName = queryContactSource(displayName, listener);\r\n        if (resolvedName != null) {\r\n            displayName = resolvedName;\r\n        }\r\n    }\r\n    return displayName;\r\n}"
}, {
	"Path": "io.lettuce.core.cluster.AbstractNodeSelection.commands",
	"Comment": "this method is never called, the value is supplied by aop magic.",
	"Method": "CMD commands(API commands,int index){\r\n    return getApi(node(index)).join();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWritePanel.insertUpdate",
	"Comment": "updates write panel size and adjusts sms properties if the sms menuis visible.",
	"Method": "void insertUpdate(DocumentEvent event){\r\n    if (smsButton.isVisible()) {\r\n        updateSmsCounters(event.getDocument().getLength());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.jabber.JabberAccountID.setUseAnonymousAuth",
	"Comment": "enables anonymous authorization mode on this xmpp account.",
	"Method": "void setUseAnonymousAuth(boolean useAnonymousAuth){\r\n    putAccountProperty(ANONYMOUS_AUTH, useAnonymousAuth);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomJabberImpl.grantOwnership",
	"Comment": "grants ownership privileges to another user. room owners may grant ownership privileges. some room implementations will not allow to grant ownership privileges to other users. an owner is allowed to change defining room features as well as perform all administrative functions.",
	"Method": "void grantOwnership(String jid){\r\n    try {\r\n        multiUserChat.grantOwnership(jid);\r\n    } catch (XMPPException ex) {\r\n        logger.error(\"An error occurs granting ownership \" + \"privileges to a user\", ex);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.gui.AccountRegistrationWizard.setModification",
	"Comment": "sets the modification property to indicate if this wizard is opened fora modification.",
	"Method": "void setModification(boolean isModification){\r\n    this.isModification = isModification;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MclStorageManager.createProtoContactNode",
	"Comment": "creates a node element corresponding to protocontact. ifrequired data is missing returns null.",
	"Method": "Element createProtoContactNode(Contact protoContact){\r\n    Element protoContactElement = contactListDocument.createElement(PROTO_CONTACT_NODE_NAME);\r\n    protoContactElement.setAttribute(PROTO_CONTACT_ADDRESS_ATTR_NAME, protoContact.getAddress());\r\n    protoContactElement.setAttribute(ACCOUNT_ID_ATTR_NAME, protoContact.getProtocolProvider().getAccountID().getAccountUniqueID());\r\n    if (logger.isInfoEnabled() && protoContact.getParentContactGroup() == null) {\r\n        if (logger.isInfoEnabled())\r\n            logger.info(\"the following contact looks weird:\" + protoContact);\r\n        if (logger.isInfoEnabled())\r\n            logger.info(\"group:\" + protoContact.getParentContactGroup());\r\n    }\r\n    if (protoContact.getParentContactGroup() == null)\r\n        return null;\r\n    protoContactElement.setAttribute(PARENT_PROTO_GROUP_UID_ATTR_NAME, protoContact.getParentContactGroup().getUID());\r\n    String persistentData = protoContact.getPersistentData();\r\n    if ((persistentData != null) && (persistentData.length() != 0)) {\r\n        Element persDataNode = contactListDocument.createElement(PERSISTENT_DATA_NODE_NAME);\r\n        XMLUtils.setText(persDataNode, persistentData);\r\n        protoContactElement.appendChild(persDataNode);\r\n    }\r\n    return protoContactElement;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.osdependent.macosx.MacOSXDockIcon.addDockIconListener",
	"Comment": "adds a dock icon listener in order to show the application each time userclicks on the dock icon.",
	"Method": "void addDockIconListener(){\r\n    Application application = Application.getApplication();\r\n    if (application != null) {\r\n        application.addAppEventListener(new AppReOpenedListener() {\r\n            public void appReOpened(AppEvent.AppReOpenedEvent appReOpenedEvent) {\r\n                UIService uiService = OsDependentActivator.getUIService();\r\n                if (uiService != null && !uiService.isVisible())\r\n                    uiService.setVisible(true);\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.osdependent.macosx.MacOSXDockIcon.addDockIconListener",
	"Comment": "adds a dock icon listener in order to show the application each time userclicks on the dock icon.",
	"Method": "void addDockIconListener(){\r\n    UIService uiService = OsDependentActivator.getUIService();\r\n    if (uiService != null && !uiService.isVisible())\r\n        uiService.setVisible(true);\r\n}"
}, {
	"Path": "net.librec.math.structure.DenseMatrix.plus",
	"Comment": "return a new matrix containing the element by element sum of the recipient and the argument",
	"Method": "void plus(int row,int column,double value,DenseMatrix plus,double value,DenseMatrix plus,Matrix otherMatrix){\r\n    DenseMatrix denseMatrix = this.clone();\r\n    for (MatrixEntry matrixEntry : otherMatrix) {\r\n        denseMatrix.plus(matrixEntry.row(), matrixEntry.column(), matrixEntry.get());\r\n    }\r\n    return denseMatrix;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipMessageFactory.attachToTag",
	"Comment": "generates a totag and attaches it to the to header of response.",
	"Method": "void attachToTag(Response response,Dialog containingDialog){\r\n    ToHeader to = (ToHeader) response.getHeader(ToHeader.NAME);\r\n    if (to == null) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Strange ... no to To header in response:\" + response);\r\n        return;\r\n    }\r\n    if (containingDialog != null && containingDialog.getLocalTag() != null) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"We seem to already have a tag in this dialog. \" + \"Returning\");\r\n        return;\r\n    }\r\n    try {\r\n        if (to.getTag() == null || to.getTag().trim().length() == 0) {\r\n            String toTag = generateLocalTag();\r\n            if (logger.isDebugEnabled())\r\n                logger.debug(\"generated to tag: \" + toTag);\r\n            to.setTag(toTag);\r\n        }\r\n    } catch (ParseException ex) {\r\n        logger.error(\"Failed to attach a to tag to an outgoing response.\", ex);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.jabber.JabberAccountID.getBoshUrl",
	"Comment": "returns the bosh url which should be used to connect to the xmpp server.if the value is set then bosh transport instead of tcp will be used.",
	"Method": "String getBoshUrl(){\r\n    return getAccountPropertyString(BOSH_URL);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.UIServiceImpl.notificationCleared",
	"Comment": "counts the number of unread notifications and forwards the sum to thesystray service.",
	"Method": "void notificationCleared(UINotification notification){\r\n    forwardNotificationCount();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.ProtocolProviderFactory.removeStoredAccount",
	"Comment": "removes the account with accountid from the set of accountsthat are persistently stored inside the configuration service.",
	"Method": "boolean removeStoredAccount(AccountID accountID){\r\n    return getAccountManager().removeStoredAccount(this, accountID);\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.ConfigurationUtils.updateChatRoomStatus",
	"Comment": "updates the status of the chat room through theconfigurationservice.",
	"Method": "void updateChatRoomStatus(ProtocolProviderService protocolProvider,String chatRoomId,String chatRoomStatus){\r\n    String prefix = \"net.java.sip.communicator.impl.gui.accounts\";\r\n    List<String> accounts = configService.getPropertyNamesByPrefix(prefix, true);\r\n    for (String accountRootPropName : accounts) {\r\n        String accountUID = configService.getString(accountRootPropName);\r\n        if (accountUID.equals(protocolProvider.getAccountID().getAccountUniqueID())) {\r\n            List<String> chatRooms = configService.getPropertyNamesByPrefix(accountRootPropName + \".chatRooms\", true);\r\n            for (String chatRoomPropName : chatRooms) {\r\n                String chatRoomID = configService.getString(chatRoomPropName);\r\n                if (!chatRoomId.equals(chatRoomID))\r\n                    continue;\r\n                configService.setProperty(chatRoomPropName + \".lastChatRoomStatus\", chatRoomStatus);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.geolocation.GeolocationPacketExtension.getStreet",
	"Comment": "returns a string indicating a thoroughfare within a locality,or a crossing of two thoroughfares.",
	"Method": "String getStreet(){\r\n    return street;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.muc.MUCService.getChatRoomAutoOpenOption",
	"Comment": "returns the value of the chat room open automatically property",
	"Method": "String getChatRoomAutoOpenOption(ProtocolProviderService pps,String chatRoomId){\r\n    return ConfigurationUtils.getChatRoomProperty(pps, chatRoomId, AUTO_OPEN_CONFIG_KEY);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.contactlist.TestMetaContactListPersistence.testReloadMetaContactListBundle",
	"Comment": "uninstalls the meta contact list bundle so that it would be forced topersistently store its contents and load it again later.",
	"Method": "void testReloadMetaContactListBundle(){\r\n    Object o = new Object();\r\n    synchronized (o) {\r\n        o.wait(1000);\r\n    }\r\n    Bundle metaClBundle = findMetaClBundle();\r\n    assertNotNull(\"Couldn't find the bundle that exports the meta \" + \"contact list servce implementation that we're \" + \"currently testing\", metaClBundle);\r\n    metaClBundle.stop();\r\n    assertTrue(\"Couldn't stop the meta cl bundle. State was \" + metaClBundle.getState(), Bundle.ACTIVE != metaClBundle.getState() && Bundle.STOPPING != metaClBundle.getState());\r\n    metaClBundle.uninstall();\r\n    assertEquals(\"Couldn't stop the meta cl bundle.\", Bundle.UNINSTALLED, metaClBundle.getState());\r\n    MclSlickFixture.mockPrServiceRegistration.unregister();\r\n    MclSlickFixture.mockP1ServiceRegistration.unregister();\r\n    MclSlickFixture.mockP2ServiceRegistration.unregister();\r\n    MclSlickFixture.replacementMockPr = new MockProvider(MclSlickFixture.mockProvider.getAccountID().getUserID());\r\n    MclSlickFixture.replacementMockP1 = new MockProvider(MclSlickFixture.mockP1.getAccountID().getUserID());\r\n    MclSlickFixture.replacementMockP2 = new MockProvider(MclSlickFixture.mockP2.getAccountID().getUserID());\r\n    MclSlickFixture.mockPrServiceRegistration = MetaContactListServiceLick.registerMockProviderService(MclSlickFixture.replacementMockPr);\r\n    metaClBundle = MclSlickFixture.bundleContext.installBundle(metaClBundle.getLocation());\r\n    assertEquals(\"Couldn't re-install meta cl bundle.\", Bundle.INSTALLED, metaClBundle.getState());\r\n    metaClBundle.start();\r\n    assertEquals(\"Couldn't re-start meta cl bundle.\", Bundle.ACTIVE, metaClBundle.getState());\r\n    fixture.metaClService = (MetaContactListService) MclSlickFixture.bundleContext.getService(MclSlickFixture.bundleContext.getServiceReference(MetaContactListService.class.getName()));\r\n    assertNotNull(\"The meta contact list service was not re-registered \" + \"after reinstalling its bundle.\", fixture.metaClService);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.wizard.EncodingsPanel.loadAccount",
	"Comment": "loads encoding configuration from given encodingsreg object.",
	"Method": "void loadAccount(EncodingsRegistrationUtil encodingsReg){\r\n    overrideCheckBox.setSelected(encodingsReg.isOverrideEncodings());\r\n    encodingConfiguration = encodingsReg.createEncodingConfig(mediaConfiguration.getMediaService());\r\n    encodingConfiguration.storeProperties(encodingProperties);\r\n    resetTables();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.FramedImageWithMenu.getAvatar",
	"Comment": "returns the current image with no rounded corners. only return the userimage and not the default image.",
	"Method": "Image getAvatar(){\r\n    return (!this.isDefaultImage) ? this.currentImage : this.getImage();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaHandler.closeStream",
	"Comment": "closes the mediastream that this instance uses for a specificmediatype and prepares it for garbage collection.",
	"Method": "void closeStream(CallPeerMediaHandler<?> callPeerMediaHandler,MediaType mediaType){\r\n    int index = mediaType.ordinal();\r\n    int streamReferenceCount = streamReferenceCounts[index];\r\n    if (streamReferenceCount <= 0)\r\n        return;\r\n    streamReferenceCount--;\r\n    streamReferenceCounts[index] = streamReferenceCount;\r\n    if (streamReferenceCount > 0)\r\n        return;\r\n    switch(mediaType) {\r\n        case AUDIO:\r\n            setAudioStream(null);\r\n            break;\r\n        case VIDEO:\r\n            setVideoStream(null);\r\n            break;\r\n    }\r\n    callPeerMediaHandler.removeAndCleanupOtherSrtpControls(mediaType, null);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.AddContactDialog.windowGainedFocus",
	"Comment": "indicates that the window has gained the focus. requests the focus inthe text field.",
	"Method": "void windowGainedFocus(WindowEvent e){\r\n    if (!initialized)\r\n        init();\r\n    this.contactAddressField.requestFocus();\r\n}"
}, {
	"Path": "io.lettuce.core.RedisURI.getTimeout",
	"Comment": "returns the command timeout for synchronous command execution.",
	"Method": "Duration getTimeout(){\r\n    return timeout;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.galagonotification.GalagoPopupMessageHandler.getPreferenceIndex",
	"Comment": "returns the preference index of this popupmessagehandler whichindicates how many features it supports.",
	"Method": "int getPreferenceIndex(){\r\n    int preferenceIndex = 1;\r\n    if (iconStaticIsImplemented)\r\n        ++preferenceIndex;\r\n    return preferenceIndex;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.notificationwiring.NotificationManager.handleProviderRemoved",
	"Comment": "removes all listeners related to the given protocol provider.",
	"Method": "void handleProviderRemoved(ProtocolProviderService protocolProvider){\r\n    Map<String, OperationSet> supportedOperationSets = protocolProvider.getSupportedOperationSets();\r\n    String imOpSetClassName = OperationSetBasicInstantMessaging.class.getName();\r\n    if (supportedOperationSets.containsKey(imOpSetClassName)) {\r\n        OperationSetBasicInstantMessaging im = (OperationSetBasicInstantMessaging) supportedOperationSets.get(imOpSetClassName);\r\n        im.removeMessageListener(this);\r\n    }\r\n    String tnOpSetClassName = OperationSetTypingNotifications.class.getName();\r\n    if (supportedOperationSets.containsKey(tnOpSetClassName)) {\r\n        OperationSetTypingNotifications tn = (OperationSetTypingNotifications) supportedOperationSets.get(tnOpSetClassName);\r\n        tn.removeTypingNotificationsListener(this);\r\n    }\r\n    OperationSetFileTransfer fileTransferOpSet = protocolProvider.getOperationSet(OperationSetFileTransfer.class);\r\n    if (fileTransferOpSet != null) {\r\n        fileTransferOpSet.removeFileTransferListener(this);\r\n    }\r\n    OperationSetMultiUserChat multiChatOpSet = protocolProvider.getOperationSet(OperationSetMultiUserChat.class);\r\n    if (multiChatOpSet != null) {\r\n        multiChatOpSet.removePresenceListener(this);\r\n    }\r\n    OperationSetAdHocMultiUserChat multiAdHocChatOpSet = protocolProvider.getOperationSet(OperationSetAdHocMultiUserChat.class);\r\n    if (multiAdHocChatOpSet != null) {\r\n        multiAdHocChatOpSet.removePresenceListener(this);\r\n    }\r\n    OperationSetBasicTelephony<?> basicTelephonyOpSet = protocolProvider.getOperationSet(OperationSetBasicTelephony.class);\r\n    if (basicTelephonyOpSet != null) {\r\n        basicTelephonyOpSet.removeCallListener(this);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.OneToOneCallPanel.getCallPeerRenderer",
	"Comment": "returns the callpeerrenderer corresponding to the givencallpeer.",
	"Method": "SwingCallPeerRenderer getCallPeerRenderer(CallPeer callPeer){\r\n    return this.callPeer.equals(callPeer) ? peerPanel : null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.certconfig.CertConfigActivator.getUIService",
	"Comment": "returns a reference to a uiservice implementation currentlyregistered in the bundle context or null if no such implementation wasfound.",
	"Method": "UIService getUIService(){\r\n    return ServiceUtils.getService(bundleContext, UIService.class);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.AlertUIServiceImpl.dispose",
	"Comment": "releases the resources acquired by this instance throughout its lifetimeand removes the listeners.",
	"Method": "void dispose(){\r\n    SystrayService systray = GuiActivator.getSystrayService();\r\n    if (systray == null) {\r\n        logger.warn(\"SystrayService not available.\");\r\n        return;\r\n    }\r\n    systray.removePopupMessageListener(listener);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.configforms.ConfigFormDescriptor.getConfigFormTitle",
	"Comment": "returns the title of the corresponding configurationform.",
	"Method": "String getConfigFormTitle(){\r\n    return configFormTitle;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.ConfigurationUtils.getLastCallConferenceProvider",
	"Comment": "returns the call conference provider used for the last conference call.",
	"Method": "ProtocolProviderService getLastCallConferenceProvider(){\r\n    if (lastCallConferenceProvider != null)\r\n        return lastCallConferenceProvider;\r\n    return findProviderFromAccountId(configService.getString(\"net.java.sip.communicator.impl.gui.call.lastCallConferenceProvider\"));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.AccountStatusPanel.addAccount",
	"Comment": "adds the account given by protocolprovider in the containedstatus combo box.",
	"Method": "void addAccount(ProtocolProviderService protocolProvider){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                addAccount(protocolProvider);\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    statusComboBox.addAccount(protocolProvider);\r\n    protocolProvider.addRegistrationStateChangeListener(this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.AccountStatusPanel.addAccount",
	"Comment": "adds the account given by protocolprovider in the containedstatus combo box.",
	"Method": "void addAccount(ProtocolProviderService protocolProvider){\r\n    addAccount(protocolProvider);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatSession.getCurrentChatTransport",
	"Comment": "returns the currently used transport for all operation within this chatsession.",
	"Method": "ChatTransport getCurrentChatTransport(){\r\n    return currentChatTransport;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.icqaccregwizz.IcqAccRegWizzActivator.getBrowserLauncher",
	"Comment": "returns the browserlauncherservice obtained from the bundlecontext.",
	"Method": "BrowserLauncherService getBrowserLauncher(){\r\n    if (browserLauncherService == null) {\r\n        ServiceReference serviceReference = bundleContext.getServiceReference(BrowserLauncherService.class.getName());\r\n        browserLauncherService = (BrowserLauncherService) bundleContext.getService(serviceReference);\r\n    }\r\n    return browserLauncherService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomIrcImpl.revokeModerator",
	"Comment": "revokes the moderator role for the participant given by address.",
	"Method": "void revokeModerator(String address){\r\n    final IrcConnection connection = this.parentProvider.getIrcStack().getConnection();\r\n    if (connection == null) {\r\n        throw new IllegalStateException(\"Connection is not available.\");\r\n    }\r\n    connection.getChannelManager().revoke(this, address, Mode.HALFOP);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.InfoRetreiver.getDetailsAndDescendants",
	"Comment": "returns the user details from the specified class or its descendantsthe class is one from thenet.java.sip.communicator.service.protocol.serverstoreddetailsor implemented one in the operation set for the user info",
	"Method": "Iterator<T> getDetailsAndDescendants(String uin,Class<T> detailClass){\r\n    List<GenericDetail> details = getContactDetails(uin);\r\n    List<T> result = new LinkedList<T>();\r\n    for (GenericDetail item : details) if (detailClass.isInstance(item)) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        T t = (T) item;\r\n        result.add(t);\r\n    }\r\n    return result.iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetBasicTelephonyJabberImpl.putOffHold",
	"Comment": "resumes communication with a call peer previously put on hold.",
	"Method": "void putOffHold(CallPeer peer){\r\n    putOnHold(peer, false);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ClientConfigImpl.setResolveByProxy",
	"Comment": "set resolve by proxy value. indicates whether or not to use the proxy toresolve addresses.",
	"Method": "void setResolveByProxy(boolean resolveByProxy){\r\n    this.resolveByProxy = resolveByProxy;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactImpl.setDisplayName",
	"Comment": "sets a name that can be used when displaying this contact in userinterface components.",
	"Method": "void setDisplayName(String displayName){\r\n    synchronized (getParentGroupModLock()) {\r\n        if (parentGroup != null)\r\n            parentGroup.lightRemoveMetaContact(this);\r\n        this.displayName = (displayName == null) ? \"\" : displayName;\r\n        if (parentGroup != null)\r\n            parentGroup.lightAddMetaContact(this);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetBasicInstantMessagingSipImpl.sendMessageRequest",
	"Comment": "sends messagerequest to the specified destination and logsmessagecontent for later use.",
	"Method": "void sendMessageRequest(Request messageRequest,Contact to,Message messageContent){\r\n    ClientTransaction messageTransaction;\r\n    SipProvider jainSipProvider = this.sipProvider.getDefaultJainSipProvider();\r\n    messageTransaction = jainSipProvider.getNewClientTransaction(messageRequest);\r\n    messageTransaction.sendRequest();\r\n    String key = ((CallIdHeader) messageRequest.getHeader(CallIdHeader.NAME)).getCallId();\r\n    this.sentMsg.put(key, messageContent);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWindowManager.addChatListener",
	"Comment": "registers a newchatlistener to be informed when new chatsare created.",
	"Method": "void addChatListener(ChatListener listener){\r\n    synchronized (chatListeners) {\r\n        if (!chatListeners.contains(listener))\r\n            chatListeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ContactListModel.setShowOffline",
	"Comment": "sets the showoffline variable to indicate whether or not offline contactsshould be shown.",
	"Method": "void setShowOffline(boolean showOffline){\r\n    this.showOffline = showOffline;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetBasicInstantMessagingJabberImpl.sendMessage",
	"Comment": "helper function used to send a message to a contact, with the givenextensions attached.",
	"Method": "MessageDeliveredEvent sendMessage(Contact to,ContactResource toResource,Message message,PacketExtension[] extensions){\r\n    if (!(to instanceof ContactJabberImpl))\r\n        throw new IllegalArgumentException(\"The specified contact is not a Jabber contact.\" + to);\r\n    assertConnected();\r\n    org.jivesoftware.smack.packet.Message msg = new org.jivesoftware.smack.packet.Message();\r\n    String toJID = null;\r\n    if (toResource != null) {\r\n        if (toResource.equals(ContactResource.BASE_RESOURCE)) {\r\n            toJID = to.getAddress();\r\n        } else\r\n            toJID = ((ContactResourceJabberImpl) toResource).getFullJid();\r\n    }\r\n    if (toJID == null) {\r\n        toJID = to.getAddress();\r\n    }\r\n    msg.setPacketID(message.getMessageUID());\r\n    msg.setTo(toJID);\r\n    for (PacketExtension ext : extensions) {\r\n        msg.addExtension(ext);\r\n    }\r\n    if (logger.isTraceEnabled())\r\n        logger.trace(\"Will send a message to:\" + toJID + \" chat.jid=\" + toJID);\r\n    MessageDeliveredEvent msgDeliveryPendingEvt = new MessageDeliveredEvent(message, to, toResource);\r\n    MessageDeliveredEvent[] transformedEvents = messageDeliveryPendingTransform(msgDeliveryPendingEvt);\r\n    if (transformedEvents == null || transformedEvents.length == 0)\r\n        return null;\r\n    for (MessageDeliveredEvent event : transformedEvents) {\r\n        String content = event.getSourceMessage().getContent();\r\n        if (message.getContentType().equals(HTML_MIME_TYPE)) {\r\n            msg.setBody(Html2Text.extractText(content));\r\n            if (jabberProvider.isFeatureListSupported(toJID, HTML_NAMESPACE)) {\r\n                XHTMLManager.addBody(msg, OPEN_BODY_TAG + content + CLOSE_BODY_TAG);\r\n            }\r\n        } else {\r\n            msg.setBody(content);\r\n        }\r\n        if (event.isMessageEncrypted() && isCarbonEnabled) {\r\n            msg.addExtension(new CarbonPacketExtension.PrivateExtension());\r\n        }\r\n        MessageEventManager.addNotificationsRequests(msg, true, false, false, true);\r\n        String threadID = getThreadIDForAddress(toJID);\r\n        if (threadID == null)\r\n            threadID = nextThreadID();\r\n        msg.setThread(threadID);\r\n        msg.setType(org.jivesoftware.smack.packet.Message.Type.chat);\r\n        msg.setFrom(jabberProvider.getConnection().getUser());\r\n        jabberProvider.getConnection().sendPacket(msg);\r\n        putJidForAddress(toJID, threadID);\r\n    }\r\n    return new MessageDeliveredEvent(message, to, toResource);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipAccountIDImpl.getAccountPropertyString",
	"Comment": "returns the account property string corresponding to the given key.if property is xcap password obtain it from credential storage.",
	"Method": "String getAccountPropertyString(Object key){\r\n    if (key.equals(SipAccountID.OPT_CLIST_PASSWORD)) {\r\n        CredentialsStorageService credentialsStorage = ServiceUtils.getService(SipActivator.getBundleContext(), CredentialsStorageService.class);\r\n        return credentialsStorage.loadPassword(getAccountUniqueID() + \".xcap\");\r\n    } else\r\n        return super.getAccountPropertyString(key);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ServerStoredContactListJabberImpl.getRosterEntry",
	"Comment": "returns the roster entry associated with the given xmpp address ornull if the user is not an entry in the roster.",
	"Method": "RosterEntry getRosterEntry(String user){\r\n    if (roster == null)\r\n        return null;\r\n    else\r\n        return roster.getEntry(user);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.simpleaccreg.SimpleAccountRegistrationActivator.getResources",
	"Comment": "returns the resourcemanagementservice, through which we willaccess all resources.",
	"Method": "ResourceManagementService getResources(){\r\n    if (resourcesService == null) {\r\n        resourcesService = ServiceUtils.getService(bundleContext, ResourceManagementService.class);\r\n    }\r\n    return resourcesService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.OperationSetTypingNotificationsGibberishImpl.sendTypingNotification",
	"Comment": "sends a notification to notifiedcontatct that we have enteredtypingstate.",
	"Method": "void sendTypingNotification(Contact notifiedContact,int typingState){\r\n    if (!(notifiedContact instanceof ContactGibberishImpl))\r\n        throw new IllegalArgumentException(\"The specified contact is not a Gibberish contact.\" + notifiedContact);\r\n    String userID = notifiedContact.getAddress();\r\n    if (userID.equals(this.parentProvider.getAccountID().getUserID())) {\r\n        String sourceUserID = notifiedContact.getProtocolProvider().getAccountID().getUserID();\r\n        Contact from = opSetPersPresence.findContactByID(sourceUserID);\r\n        if (from == null) {\r\n            from = opSetPersPresence.createVolatileContact(sourceUserID);\r\n        }\r\n        fireTypingNotificationsEvent(from, typingState);\r\n    } else {\r\n        ProtocolProviderServiceGibberishImpl gibberishProvider = this.opSetPersPresence.findProviderForGibberishUserID(userID);\r\n        if (gibberishProvider != null) {\r\n            OperationSetTypingNotificationsGibberishImpl opSetTN = (OperationSetTypingNotificationsGibberishImpl) gibberishProvider.getOperationSet(OperationSetTypingNotifications.class);\r\n            opSetTN.sendTypingNotification(notifiedContact, typingState);\r\n        } else {\r\n            fireTypingNotificationsEvent(notifiedContact, typingState);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.plaf.SearchFieldUI.paintSafely",
	"Comment": "implements parent paintsafely method and enables antialiasing.",
	"Method": "void paintSafely(Graphics g){\r\n    customPaintBackground(g);\r\n    super.paintSafely(g);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.browserlauncher.BrowserLauncherImpl.openURL",
	"Comment": "tries to open the specified url in a browser. the attempt is asynchronouslyexecuted and does not wait for possible errors related to the launchingof the associated browser and the opening of the specified url in it i.e.the method returns immediately and does not report the success or thefailure of the opening.",
	"Method": "void openURL(String url){\r\n    Thread launchBrowserThread = new Thread(getClass().getName()) {\r\n        @Override\r\n        public void run() {\r\n            try {\r\n                launchBrowser(url);\r\n            } catch (Exception e) {\r\n                logger.error(\"Failed to launch browser\", e);\r\n            }\r\n        }\r\n    };\r\n    launchBrowserThread.start();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.browserlauncher.BrowserLauncherImpl.openURL",
	"Comment": "tries to open the specified url in a browser. the attempt is asynchronouslyexecuted and does not wait for possible errors related to the launchingof the associated browser and the opening of the specified url in it i.e.the method returns immediately and does not report the success or thefailure of the opening.",
	"Method": "void openURL(String url){\r\n    try {\r\n        launchBrowser(url);\r\n    } catch (Exception e) {\r\n        logger.error(\"Failed to launch browser\", e);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatTransport.removeSmsMessageListener",
	"Comment": "removes the given sms message listener from this chat transport.",
	"Method": "void removeSmsMessageListener(MessageListener l){\r\n    if (!allowsSmsMessage())\r\n        return;\r\n    OperationSetSmsMessaging smsOpSet = chatRoom.getParentProvider().getOperationSet(OperationSetSmsMessaging.class);\r\n    smsOpSet.removeMessageListener(l);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.notificationwiring.NotificationManager.getProtocolProviderFactories",
	"Comment": "returns all protocolproviderfactorys obtained from the bundlecontext.",
	"Method": "Map<Object, ProtocolProviderFactory> getProtocolProviderFactories(){\r\n    ServiceReference[] serRefs = null;\r\n    try {\r\n        serRefs = NotificationWiringActivator.bundleContext.getServiceReferences(ProtocolProviderFactory.class.getName(), null);\r\n    } catch (InvalidSyntaxException e) {\r\n        logger.error(\"NotificationManager : \" + e);\r\n    }\r\n    Map<Object, ProtocolProviderFactory> providerFactoriesMap = new Hashtable<Object, ProtocolProviderFactory>();\r\n    if (serRefs != null) {\r\n        for (ServiceReference serRef : serRefs) {\r\n            ProtocolProviderFactory providerFactory = (ProtocolProviderFactory) NotificationWiringActivator.bundleContext.getService(serRef);\r\n            providerFactoriesMap.put(serRef.getProperty(ProtocolProviderFactory.PROTOCOL), providerFactory);\r\n        }\r\n    }\r\n    return providerFactoriesMap;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.CallPeerMediaHandlerJabberImpl.processOffer",
	"Comment": "parses and handles the specified offer and returns a contentextension representing the current state of this media handler. thismethod must only be called when offer is the first sessiondescription that this mediahandler is seeing.",
	"Method": "void processOffer(List<ContentPacketExtension> offer){\r\n    List<ContentPacketExtension> answer = new ArrayList<ContentPacketExtension>(offer.size());\r\n    boolean atLeastOneValidDescription = false;\r\n    for (ContentPacketExtension content : offer) {\r\n        remoteContentMap.put(content.getName(), content);\r\n        RtpDescriptionPacketExtension description = JingleUtils.getRtpDescription(content);\r\n        MediaType mediaType = JingleUtils.getMediaType(content);\r\n        List<MediaFormat> remoteFormats = JingleUtils.extractFormats(description, getDynamicPayloadTypes());\r\n        MediaDevice dev = getDefaultDevice(mediaType);\r\n        MediaDirection devDirection = (dev == null) ? MediaDirection.INACTIVE : dev.getDirection();\r\n        devDirection = devDirection.and(getDirectionUserPreference(mediaType));\r\n        MediaDirection remoteDirection = JingleUtils.getDirection(content, getPeer().isInitiator());\r\n        MediaDirection direction = devDirection.getDirectionForAnswer(remoteDirection);\r\n        List<MediaFormat> mutuallySupportedFormats = intersectFormats(remoteFormats, getLocallySupportedFormats(dev));\r\n        List<RTPExtension> offeredRTPExtensions = JingleUtils.extractRTPExtensions(description, this.getRtpExtensionsRegistry());\r\n        List<RTPExtension> supportedExtensions = getExtensionsForType(mediaType);\r\n        List<RTPExtension> rtpExtensions = intersectRTPExtensions(offeredRTPExtensions, supportedExtensions);\r\n        IceUdpTransportPacketExtension transport = content.getFirstChildOfType(IceUdpTransportPacketExtension.class);\r\n        MediaStreamTarget target = null;\r\n        try {\r\n            target = JingleUtils.extractDefaultTarget(content);\r\n        } catch (IllegalArgumentException e) {\r\n            logger.warn(\"Fail to extract default target\", e);\r\n        }\r\n        int targetDataPort = (target == null && transport != null) ? -1 : (target != null) ? target.getDataAddress().getPort() : 0;\r\n        setTransportManager(transport.getNamespace());\r\n        if (mutuallySupportedFormats.isEmpty() || (devDirection == MediaDirection.INACTIVE) || (targetDataPort == 0)) {\r\n            closeStream(mediaType);\r\n            continue;\r\n        }\r\n        SendersEnum senders = JingleUtils.getSenders(direction, !getPeer().isInitiator());\r\n        ContentPacketExtension ourContent = JingleUtils.createDescription(content.getCreator(), content.getName(), senders, mutuallySupportedFormats, rtpExtensions, getDynamicPayloadTypes(), getRtpExtensionsRegistry());\r\n        setAndAddPreferredEncryptionProtocol(mediaType, ourContent, content);\r\n        if (content.getChildExtensionsOfType(InputEvtPacketExtension.class) != null) {\r\n            ourContent.addChildExtension(new InputEvtPacketExtension());\r\n        }\r\n        answer.add(ourContent);\r\n        localContentMap.put(content.getName(), ourContent);\r\n        atLeastOneValidDescription = true;\r\n    }\r\n    if (!atLeastOneValidDescription) {\r\n        ProtocolProviderServiceJabberImpl.throwOperationFailedException(\"Offer contained no media formats\" + \" or no valid media descriptions.\", OperationFailedException.ILLEGAL_ARGUMENT, null, logger);\r\n    }\r\n    harvestCandidates(offer, answer, new TransportInfoSender() {\r\n        public void sendTransportInfo(Iterable<ContentPacketExtension> contents) {\r\n            getPeer().sendTransportInfo(contents);\r\n        }\r\n    });\r\n    getTransportManager().startConnectivityEstablishment(offer);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.CallPeerMediaHandlerJabberImpl.processOffer",
	"Comment": "parses and handles the specified offer and returns a contentextension representing the current state of this media handler. thismethod must only be called when offer is the first sessiondescription that this mediahandler is seeing.",
	"Method": "void processOffer(List<ContentPacketExtension> offer){\r\n    getPeer().sendTransportInfo(contents);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.MetaContactListSource.isMatching",
	"Comment": "checks if the given metagroup is matching the current filter. agroup is matching the current filter only if it contains at least onechild metacontact, which is matching the current filter.",
	"Method": "boolean isMatching(Pattern filterPattern,MetaContact metaContact,boolean isMatching,Pattern filterPattern,MetaContactGroup metaGroup){\r\n    Iterator<MetaContact> contacts = metaGroup.getChildContacts();\r\n    while (contacts.hasNext()) {\r\n        MetaContact metaContact = contacts.next();\r\n        if (isMatching(filterPattern, metaContact))\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.JabberActivator.getGoogleService",
	"Comment": "returns a reference to the googlecontactsservice implementationcurrently registered in the bundle context or null if no suchimplementation was found.",
	"Method": "GoogleContactsService getGoogleService(){\r\n    if (googleService == null) {\r\n        googleService = ServiceUtils.getService(bundleContext, GoogleContactsService.class);\r\n    }\r\n    return googleService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetPersistentPresenceIcqImpl.getSupportedStatusSet",
	"Comment": "returns the set of presencestatus objects that a user of this servicemay request the provider to enter.",
	"Method": "Iterator<PresenceStatus> getSupportedStatusSet(){\r\n    if (supportedPresenceStatusSet.size() == 0) {\r\n        if (parentProvider.USING_ICQ) {\r\n            supportedPresenceStatusSet.add(IcqStatusEnum.ONLINE);\r\n            supportedPresenceStatusSet.add(IcqStatusEnum.DO_NOT_DISTURB);\r\n            supportedPresenceStatusSet.add(IcqStatusEnum.FREE_FOR_CHAT);\r\n            supportedPresenceStatusSet.add(IcqStatusEnum.NOT_AVAILABLE);\r\n            supportedPresenceStatusSet.add(IcqStatusEnum.OCCUPIED);\r\n            supportedPresenceStatusSet.add(IcqStatusEnum.AWAY);\r\n            supportedPresenceStatusSet.add(IcqStatusEnum.INVISIBLE);\r\n            supportedPresenceStatusSet.add(IcqStatusEnum.OFFLINE);\r\n        } else {\r\n            supportedPresenceStatusSet.add(AimStatusEnum.ONLINE);\r\n            supportedPresenceStatusSet.add(AimStatusEnum.AWAY);\r\n            supportedPresenceStatusSet.add(AimStatusEnum.INVISIBLE);\r\n            supportedPresenceStatusSet.add(AimStatusEnum.OFFLINE);\r\n        }\r\n    }\r\n    return supportedPresenceStatusSet.iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.filehistory.FileHistoryServiceImpl.getHistory",
	"Comment": "returns the history by specified local and remote contactif one of them is null the default is used",
	"Method": "History getHistory(Contact localContact,Contact remoteContact){\r\n    String localId = localContact == null ? \"default\" : localContact.getAddress();\r\n    String remoteId = remoteContact == null ? \"default\" : remoteContact.getAddress();\r\n    String account = \"unkown\";\r\n    if (remoteContact != null)\r\n        account = remoteContact.getProtocolProvider().getAccountID().getAccountUniqueID();\r\n    HistoryID historyId = HistoryID.createFromRawID(new String[] { \"filehistory\", localId, account, remoteId });\r\n    return this.historyService.createHistory(historyId, recordStructure);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.dnsconfig.ParallelDnsPanel.createIPFormatter",
	"Comment": "creates a formatter for the fallback ip textfield to validate whetherthe entered text is actually an ip address",
	"Method": "DefaultFormatter createIPFormatter(){\r\n    return new DefaultFormatter() {\r\n        @Override\r\n        public Object stringToValue(String string) throws ParseException {\r\n            if (isIPv4Address(string) || isIPv6Address(string))\r\n                return super.stringToValue(string);\r\n            throw new ParseException(\"Not a valid literal IP address\", 0);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.dnsconfig.ParallelDnsPanel.createIPFormatter",
	"Comment": "creates a formatter for the fallback ip textfield to validate whetherthe entered text is actually an ip address",
	"Method": "DefaultFormatter createIPFormatter(){\r\n    if (isIPv4Address(string) || isIPv6Address(string))\r\n        return super.stringToValue(string);\r\n    throw new ParseException(\"Not a valid literal IP address\", 0);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetBasicInstantMessagingJabberImpl.initAdditionalServices",
	"Comment": "initialize additional services, like gmail notifications and messagecarbons.",
	"Method": "void initAdditionalServices(){\r\n    boolean enableGmailNotifications = jabberProvider.getAccountID().getAccountPropertyBoolean(\"GMAIL_NOTIFICATIONS_ENABLED\", false);\r\n    if (enableGmailNotifications)\r\n        subscribeForGmailNotifications();\r\n    boolean enableCarbon = isCarbonSupported() && !jabberProvider.getAccountID().getAccountPropertyBoolean(ProtocolProviderFactory.IS_CARBON_DISABLED, false);\r\n    if (enableCarbon) {\r\n        enableDisableCarbon(true);\r\n    } else {\r\n        isCarbonEnabled = false;\r\n    }\r\n}"
}, {
	"Path": "io.lettuce.core.cluster.RedisClusterClient.shutdown",
	"Comment": "shutdown this client and close all open connections. the client should be discarded after calling shutdown.",
	"Method": "void shutdown(long quietPeriod,long timeout,TimeUnit timeUnit){\r\n    if (clusterTopologyRefreshActivated.compareAndSet(true, false)) {\r\n        ScheduledFuture<?> scheduledFuture = clusterTopologyRefreshFuture.get();\r\n        try {\r\n            scheduledFuture.cancel(false);\r\n            clusterTopologyRefreshFuture.set(null);\r\n        } catch (Exception e) {\r\n            logger.debug(\"Could not unschedule Cluster topology refresh\", e);\r\n        }\r\n    }\r\n    super.shutdown(quietPeriod, timeout, timeUnit);\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.ConfigurationUtils.isMinimizeInsteadOfHide",
	"Comment": "gets whether the application should be minimized and not hidden whenclicking close on the main frame.",
	"Method": "boolean isMinimizeInsteadOfHide(){\r\n    return minimizeInsteadOfHide;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.neomedia.AudioDeviceConfigurationListener.propertyChange",
	"Comment": "notifies this instance that a property related to the configuration ofdevices has had its value changed and thus signals that an audio devicemay have been plugged or unplugged.",
	"Method": "void propertyChange(PropertyChangeEvent ev){\r\n    String propertyName = ev.getPropertyName();\r\n    if (DeviceConfiguration.PROP_AUDIO_SYSTEM_DEVICES.equals(propertyName)) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        List<CaptureDeviceInfo> oldDevices = (List<CaptureDeviceInfo>) ev.getOldValue();\r\n        @SuppressWarnings(\"unchecked\")\r\n        List<CaptureDeviceInfo> newDevices = (List<CaptureDeviceInfo>) ev.getNewValue();\r\n        if (oldDevices.isEmpty())\r\n            oldDevices = null;\r\n        if (newDevices.isEmpty())\r\n            newDevices = null;\r\n        String title;\r\n        ResourceManagementService r = NeomediaActivator.getResources();\r\n        List<CaptureDeviceInfo> devices;\r\n        boolean removal;\r\n        if (newDevices != null) {\r\n            title = r.getI18NString(\"impl.media.configform.AUDIO_DEVICE_CONNECTED\");\r\n            devices = newDevices;\r\n            removal = false;\r\n        } else if (oldDevices != null) {\r\n            title = r.getI18NString(\"impl.media.configform.AUDIO_DEVICE_DISCONNECTED\");\r\n            devices = oldDevices;\r\n            removal = true;\r\n        } else {\r\n            capturePropertyChangeEvent = null;\r\n            notifyPropertyChangeEvent = null;\r\n            playbackPropertyChangeEvent = null;\r\n            return;\r\n        }\r\n        StringBuilder body = new StringBuilder();\r\n        for (CaptureDeviceInfo device : devices) body.append(device.getName()).append(\"\\r\\n\");\r\n        DeviceConfiguration devConf = (DeviceConfiguration) ev.getSource();\r\n        AudioSystem audioSystem = devConf.getAudioSystem();\r\n        boolean selectedHasChanged = false;\r\n        if (audioSystem != null) {\r\n            if (capturePropertyChangeEvent != null) {\r\n                CaptureDeviceInfo cdi = audioSystem.getSelectedDevice(AudioSystem.DataFlow.CAPTURE);\r\n                if ((cdi != null) && !cdi.equals(capturePropertyChangeEvent.getOldValue())) {\r\n                    body.append(\"\\r\\n\").append(r.getI18NString(\"impl.media.configform.AUDIO_DEVICE_SELECTED_AUDIO_IN\")).append(\"\\r\\n\\t\").append(cdi.getName());\r\n                    selectedHasChanged = true;\r\n                }\r\n            }\r\n            if (playbackPropertyChangeEvent != null) {\r\n                CaptureDeviceInfo cdi = audioSystem.getSelectedDevice(AudioSystem.DataFlow.PLAYBACK);\r\n                if ((cdi != null) && !cdi.equals(playbackPropertyChangeEvent.getOldValue())) {\r\n                    body.append(\"\\r\\n\").append(r.getI18NString(\"impl.media.configform.AUDIO_DEVICE_SELECTED_AUDIO_OUT\")).append(\"\\r\\n\\t\").append(cdi.getName());\r\n                    selectedHasChanged = true;\r\n                }\r\n            }\r\n            if (notifyPropertyChangeEvent != null) {\r\n                CaptureDeviceInfo cdi = audioSystem.getSelectedDevice(AudioSystem.DataFlow.NOTIFY);\r\n                if ((cdi != null) && !cdi.equals(notifyPropertyChangeEvent.getOldValue())) {\r\n                    body.append(\"\\r\\n\").append(r.getI18NString(\"impl.media.configform.AUDIO_DEVICE_SELECTED_AUDIO_NOTIFICATIONS\")).append(\"\\r\\n\\t\").append(cdi.getName());\r\n                    selectedHasChanged = true;\r\n                }\r\n            }\r\n        }\r\n        capturePropertyChangeEvent = null;\r\n        notifyPropertyChangeEvent = null;\r\n        playbackPropertyChangeEvent = null;\r\n        if (!removal || selectedHasChanged) {\r\n            showPopUpNotification(title, body.toString(), NeomediaActivator.DEVICE_CONFIGURATION_HAS_CHANGED);\r\n        }\r\n    } else if (CaptureDevices.PROP_DEVICE.equals(propertyName)) {\r\n        capturePropertyChangeEvent = ev;\r\n    } else if (NotifyDevices.PROP_DEVICE.equals(propertyName)) {\r\n        notifyPropertyChangeEvent = ev;\r\n    } else if (PlaybackDevices.PROP_DEVICE.equals(propertyName)) {\r\n        playbackPropertyChangeEvent = ev;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl.registerMethodProcessor",
	"Comment": "registers methodprocessor in the methorprocessors tableso that it would receives all messages in a transaction initiated by amethod request. if any previous processors exist for the samemethod, they will be replaced by this one.",
	"Method": "void registerMethodProcessor(String method,MethodProcessor methodProcessor){\r\n    List<MethodProcessor> processors = methodProcessors.get(method);\r\n    if (processors == null) {\r\n        processors = new LinkedList<MethodProcessor>();\r\n        methodProcessors.put(method, processors);\r\n    } else {\r\n        Iterator<MethodProcessor> processorIter = processors.iterator();\r\n        Class<? extends MethodProcessor> methodProcessorClass = methodProcessor.getClass();\r\n        String eventPackage = (methodProcessor instanceof EventPackageSupport) ? ((EventPackageSupport) methodProcessor).getEventPackage() : null;\r\n        while (processorIter.hasNext()) {\r\n            MethodProcessor processor = processorIter.next();\r\n            if (!processor.getClass().equals(methodProcessorClass))\r\n                continue;\r\n            if ((eventPackage != null) && (processor instanceof EventPackageSupport) && !eventPackage.equals(((EventPackageSupport) processor).getEventPackage()))\r\n                continue;\r\n            processorIter.remove();\r\n        }\r\n    }\r\n    processors.add(methodProcessor);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.contactlist.TestSupportForMultipleProviders.testMergingContactsFromDifferentProviders",
	"Comment": "merges contacts from the protocol providers added in the previous testand make sure the merge was successful. the metod aims to prepare thecontact list for the following tests on contact list persistence.",
	"Method": "void testMergingContactsFromDifferentProviders(){\r\n    MetaContact metaEmilP1 = fixture.metaClService.findMetaContactByContact(MclSlickFixture.emilP1);\r\n    assertNotNull(\"No meta contact found for \" + MclSlickFixture.emilP1.getDisplayName(), metaEmilP1);\r\n    fixture.metaClService.moveContact(MclSlickFixture.emilP2, metaEmilP1);\r\n    assertEquals(\"Contact \" + MclSlickFixture.emilP2.getDisplayName() + \" was not added to metacontact \" + metaEmilP1.getDisplayName(), 2, metaEmilP1.getContactCount());\r\n    ContactGroup newGrpP2 = MclSlickFixture.mockPresOpSetP2.getServerStoredContactListRoot().getGroup(MclSlickFixture.metaP1Grp1.getGroupName());\r\n    assertNotNull(\"Contact \" + MclSlickFixture.emilP2.getDisplayName() + \" was not moved to the proper group inside provider 2\", newGrpP2);\r\n    MetaContactGroup newGrpP2MetaWrapper = fixture.metaClService.findMetaContactGroupByContactGroup(newGrpP2);\r\n    assertNotNull(\"Strange Error\", newGrpP2MetaWrapper);\r\n    assertSame(\"Contact group \" + newGrpP2 + \" was not added to the right meta contact group\", MclSlickFixture.metaP1Grp1, newGrpP2MetaWrapper);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MclStorageManager.metaContactGroupModified",
	"Comment": "determines the exact type of the change and acts accordingly by eitherupdating group name or .",
	"Method": "void metaContactGroupModified(MetaContactGroupEvent evt){\r\n    MetaContactGroup mcGroup = evt.getSourceMetaContactGroup();\r\n    Element mcGroupNode = findMetaContactGroupNode(mcGroup.getMetaUID());\r\n    if (mcGroupNode == null) {\r\n        logger.error(\"Failed to find meta contact group: \" + mcGroup);\r\n        if (logger.isTraceEnabled())\r\n            logger.trace(\"The above error occurred with the following stack trace: \", new Exception());\r\n        return;\r\n    }\r\n    switch(evt.getEventID()) {\r\n        case MetaContactGroupEvent.CONTACT_GROUP_RENAMED_IN_META_GROUP:\r\n        case MetaContactGroupEvent.CONTACT_GROUP_REMOVED_FROM_META_GROUP:\r\n        case MetaContactGroupEvent.CONTACT_GROUP_ADDED_TO_META_GROUP:\r\n            Node parentNode = mcGroupNode.getParentNode();\r\n            parentNode.removeChild(mcGroupNode);\r\n            Element newGroupElement = createMetaContactGroupNode(mcGroup);\r\n            parentNode.appendChild(newGroupElement);\r\n            try {\r\n                scheduleContactListStorage();\r\n            } catch (IOException ex) {\r\n                logger.error(\"Writing CL failed after adding contact \" + mcGroup, ex);\r\n            }\r\n            break;\r\n        case MetaContactGroupEvent.META_CONTACT_GROUP_RENAMED:\r\n            mcGroupNode.setAttribute(GROUP_NAME_ATTR_NAME, mcGroup.getGroupName());\r\n            break;\r\n    }\r\n    try {\r\n        scheduleContactListStorage();\r\n    } catch (IOException ex) {\r\n        logger.error(\"Writing CL failed after removing proto group \" + mcGroup.getGroupName(), ex);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chatroomslist.joinforms.ChatRoomNamePanel.removeChatRoomNameListener",
	"Comment": "removess a documentlistener to the text field containing thechosen chat room.",
	"Method": "void removeChatRoomNameListener(DocumentListener l){\r\n    this.textField.getDocument().removeDocumentListener(l);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.netaddr.NetworkEventDispatcher.addNetworkConfigurationChangeListener",
	"Comment": "adds new networkconfigurationchangelistener which willbe informed for network configuration changes.",
	"Method": "void addNetworkConfigurationChangeListener(NetworkConfigurationChangeListener listener){\r\n    synchronized (listeners) {\r\n        if (!listeners.contains(listener)) {\r\n            listeners.add(listener);\r\n            if (dispatcherThread == null) {\r\n                dispatcherThread = new Thread(this);\r\n                dispatcherThread.start();\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockMultiUserChat.findRoom",
	"Comment": "returns a reference to a chatroom named roomname or null if nosuch room exists.",
	"Method": "ChatRoom findRoom(String roomName){\r\n    for (ChatRoom elem : existingChatRooms) if (elem.getName().equals(roomName))\r\n        return elem;\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.chatconfig.ChatConfigActivator.getConfigurationService",
	"Comment": "returns the configurationservice obtained from the bundlecontext.",
	"Method": "ConfigurationService getConfigurationService(){\r\n    if (configService == null) {\r\n        ServiceReference configReference = bundleContext.getServiceReference(ConfigurationService.class.getName());\r\n        configService = (ConfigurationService) bundleContext.getService(configReference);\r\n    }\r\n    return configService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.FirstWizardPage.getIdentifier",
	"Comment": "implements the wizardpage.getidentifier to return thispage identifier.",
	"Method": "Object getIdentifier(){\r\n    return FIRST_PAGE_IDENTIFIER;\r\n}"
}, {
	"Path": "net.librec.data.model.ArffDataModelTestCase.getTrainRatio",
	"Comment": "calculate the ratio of training set of a specified datamodel object",
	"Method": "double getTrainRatio(DataModel dataModel){\r\n    double trainSize = getTrainSize(dataModel);\r\n    double totalSize = getDataSize(dataModel);\r\n    return trainSize / totalSize;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipRegistrarConnection.getJainSipProvider",
	"Comment": "returns the jain sip provider that should be used for communication with our current registrar.",
	"Method": "SipProvider getJainSipProvider(){\r\n    return sipProvider.getJainSipProvider(getTransport());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallInfoFrame.videoSizeToString",
	"Comment": "converts a video size dimension into its string representation.",
	"Method": "String videoSizeToString(Dimension videoSize){\r\n    if (videoSize == null) {\r\n        return resources.getI18NString(\"service.gui.callinfo.NA\");\r\n    }\r\n    return ((int) videoSize.getWidth()) + \" x \" + ((int) videoSize.getHeight());\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaAwareCall.addLocalUserSoundLevelListener",
	"Comment": "adds a specific soundlevellistener to the list oflisteners interested in and notified about changes in local sound levelrelated information. when the first listener is being registered themethod also registers its single listener with the call peer mediahandlers so that it would receive level change events and delegate themto the listeners that have registered with us.",
	"Method": "void addLocalUserSoundLevelListener(SoundLevelListener l){\r\n    synchronized (localUserAudioLevelListenersSyncRoot) {\r\n        if ((localUserAudioLevelListeners == null) || localUserAudioLevelListeners.isEmpty()) {\r\n            Iterator<T> callPeerIter = getCallPeers();\r\n            while (callPeerIter.hasNext()) {\r\n                callPeerIter.next().getMediaHandler().setLocalUserAudioLevelListener(localAudioLevelDelegator);\r\n            }\r\n        }\r\n        localUserAudioLevelListeners = (localUserAudioLevelListeners == null) ? new ArrayList<SoundLevelListener>() : new ArrayList<SoundLevelListener>(localUserAudioLevelListeners);\r\n        localUserAudioLevelListeners.add(l);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.UIFilterQuery.removeQuery",
	"Comment": "removes the given query from this filter query, updates the related dataand notifies interested parties if this was the last query to process.",
	"Method": "void removeQuery(ContactQuery query){\r\n    if (!isSucceeded() && !query.getQueryResults().isEmpty())\r\n        setSucceeded(true);\r\n    runningQueries--;\r\n    query.removeContactQueryListener(this);\r\n    if (runningQueries == 0 && isClosed)\r\n        fireFilterQueryEvent();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaAwareCallPeer.setPeerID",
	"Comment": "sets the string that serves as a unique identifier of thiscallpeer.",
	"Method": "void setPeerID(String peerID){\r\n    this.peerID = peerID;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ContactListModel.getContactListSize",
	"Comment": "goes through all subgroups and contacts and determines the final size ofthe contact list.",
	"Method": "int getContactListSize(MetaContactGroup group){\r\n    int size = 0;\r\n    if (!isGroupClosed(group)) {\r\n        if (showOffline) {\r\n            size = group.countChildContacts();\r\n            if (!group.equals(rootGroup))\r\n                size++;\r\n        } else {\r\n            Iterator<MetaContact> i = group.getChildContacts();\r\n            while (i.hasNext()) {\r\n                MetaContact contact = i.next();\r\n                if (isContactOnline(contact))\r\n                    size++;\r\n            }\r\n            if (!group.equals(rootGroup) && size > 0)\r\n                size++;\r\n        }\r\n        Iterator<MetaContactGroup> subgroups = group.getSubgroups();\r\n        while (subgroups.hasNext()) {\r\n            MetaContactGroup subGroup = subgroups.next();\r\n            size += getContactListSize(subGroup);\r\n        }\r\n    } else {\r\n        if (showOffline) {\r\n            size++;\r\n        } else {\r\n            if (containsOnlineContacts(group))\r\n                size++;\r\n        }\r\n    }\r\n    return size;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.ircaccregwizz.IrcAccountRegistration.setAutoChangeNick",
	"Comment": "sets the property indicating if the nick should be changed automaticallyin case of nick collision.",
	"Method": "void setAutoChangeNick(boolean autoChangeNick){\r\n    this.autoChangeNick = autoChangeNick;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomIrcImpl.grantMembership",
	"Comment": "grants membership role to the participant given by address.",
	"Method": "void grantMembership(String address){\r\n    final IrcConnection connection = this.parentProvider.getIrcStack().getConnection();\r\n    if (connection == null) {\r\n        throw new IllegalStateException(\"Connection is not available.\");\r\n    }\r\n    connection.getChannelManager().grant(this, address, Mode.VOICE);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockChatRoom.revokeMembership",
	"Comment": "revokes the membership role for the participant given by address.",
	"Method": "void revokeMembership(String address){\r\n    throw new UnsupportedOperationException(\"Not supported yet.\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.TestOperationSetServerStoredInfo.testWriteInfo",
	"Comment": "testing changing of the details.changing the details from the account info operation setand checking the values retreived from testeragent",
	"Method": "void testWriteInfo(){\r\n    Object lock = new Object();\r\n    ServerStoredDetails.LastNameDetail lastNameDetail = null;\r\n    ServerStoredDetails.PhoneNumberDetail phoneNumberDetail = null;\r\n    ServerStoredDetails.CountryDetail homeCountryDetail = null;\r\n    Iterator<GenericDetail> iter = opSetServerStoredAccountInfo.getDetails(ServerStoredDetails.LastNameDetail.class);\r\n    if (iter.hasNext())\r\n        lastNameDetail = (ServerStoredDetails.LastNameDetail) iter.next();\r\n    iter = opSetServerStoredAccountInfo.getDetails(ServerStoredDetails.PhoneNumberDetail.class);\r\n    if (iter.hasNext())\r\n        phoneNumberDetail = (ServerStoredDetails.PhoneNumberDetail) iter.next();\r\n    iter = opSetServerStoredAccountInfo.getDetails(ServerStoredDetails.CountryDetail.class);\r\n    if (iter.hasNext())\r\n        homeCountryDetail = (ServerStoredDetails.CountryDetail) iter.next();\r\n    int suffix = (int) (Math.random() * 100);\r\n    String newLastName = \"TesterAgent\" + String.valueOf(suffix);\r\n    String newPhoneNumber = \"+3591234\" + suffix;\r\n    int countryRandom = 0 + (int) (Math.random() * 232);\r\n    int newCountryCode = ((Integer) countryIndexToLocaleString[countryRandom][0]).intValue();\r\n    String newCountryAbr = (String) countryIndexToLocaleString[countryRandom][1];\r\n    try {\r\n        if (lastNameDetail != null) {\r\n            assertTrue(\"Cannot set Detail LastName : \" + newLastName, opSetServerStoredAccountInfo.replaceDetail(lastNameDetail, new ServerStoredDetails.LastNameDetail(newLastName)));\r\n        } else {\r\n            opSetServerStoredAccountInfo.addDetail(new ServerStoredDetails.LastNameDetail(newLastName));\r\n        }\r\n        synchronized (lock) {\r\n            try {\r\n                lock.wait(5000);\r\n            } catch (InterruptedException ex) {\r\n            }\r\n        }\r\n        if (phoneNumberDetail != null) {\r\n            assertTrue(\"Cannot set Detail PhoneNumver : \" + newPhoneNumber, opSetServerStoredAccountInfo.replaceDetail(phoneNumberDetail, new ServerStoredDetails.PhoneNumberDetail(newPhoneNumber)));\r\n        } else {\r\n            opSetServerStoredAccountInfo.addDetail(new ServerStoredDetails.PhoneNumberDetail(newPhoneNumber));\r\n        }\r\n        synchronized (lock) {\r\n            try {\r\n                lock.wait(5000);\r\n            } catch (InterruptedException ex) {\r\n            }\r\n        }\r\n        if (homeCountryDetail != null) {\r\n            assertTrue(\"Cannot set Detail Country : \" + newCountryAbr, opSetServerStoredAccountInfo.replaceDetail(homeCountryDetail, new ServerStoredDetails.CountryDetail(new Locale(\"\", newCountryAbr))));\r\n            ;\r\n        } else {\r\n            opSetServerStoredAccountInfo.addDetail(new ServerStoredDetails.CountryDetail(new Locale(\"\", newCountryAbr)));\r\n        }\r\n        synchronized (lock) {\r\n            try {\r\n                lock.wait(5000);\r\n            } catch (InterruptedException ex) {\r\n            }\r\n        }\r\n        logger.trace(\"Finished Setting values!\");\r\n    } catch (ArrayIndexOutOfBoundsException ex) {\r\n        throw new RuntimeException(\"Error setting detail! Max detail instances is reached!\", ex);\r\n    } catch (IllegalArgumentException ex) {\r\n        throw new RuntimeException(\"Error setting detail! Detail max instances reached - cannot be set!\", ex);\r\n    } catch (OperationFailedException ex) {\r\n        logger.error(\"\", ex);\r\n        throw new RuntimeException(\"Error setting detail! Network Failure!\", ex);\r\n    } catch (ClassCastException ex) {\r\n        throw new RuntimeException(\"Error setting detail! \", ex);\r\n    }\r\n    logger.trace(\"Proceeding to Testing values!\");\r\n    Hashtable<String, Object> userInfo = IcqSlickFixture.testerAgent.getUserInfo(fixture.ourUserID);\r\n    assertEquals(\"The LastName we set is not set or not read properly\", newLastName, userInfo.get(FullUserInfoCmd.LAST_NAME));\r\n    assertEquals(\"The PhoneNumber we set is not set or not read properly\", newPhoneNumber, userInfo.get(FullUserInfoCmd.PHONE_NUMBER));\r\n    List<?> languageCodes = (ArrayList<?>) userInfo.get(FullUserInfoCmd.SPEAK_LANG);\r\n    ArrayList<Locale> languages = new ArrayList<Locale>();\r\n    Iterator<?> languageCodeIter = languageCodes.iterator();\r\n    while (languageCodeIter.hasNext()) {\r\n        languages.add(spokenLanguages[((Integer) languageCodeIter.next()).intValue()]);\r\n    }\r\n    assertEquals(\"The Country we set is not set or not read properly\", new Integer(newCountryCode), userInfo.get(FullUserInfoCmd.HOME_COUNTRY));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageHistoryServiceImpl.countRecords",
	"Comment": "total count of records for supplied history readers will read through",
	"Method": "int countRecords(Map<?, HistoryReader> readers){\r\n    int result = 0;\r\n    for (HistoryReader r : readers.values()) result += r.countRecords();\r\n    return result;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.GenericUIContactImpl.getScaledAvatar",
	"Comment": "gets the avatar of a specific uicontact in the form of animageicon value.",
	"Method": "ImageIcon getScaledAvatar(boolean isSelected,int width,int height){\r\n    if (avatarIcon != null && (avatarIcon.getIconWidth() > width || avatarIcon.getIconHeight() > height)) {\r\n        avatarIcon = ImageUtils.getScaledRoundedIcon(avatarIcon.getImage(), width, height);\r\n    }\r\n    return avatarIcon;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ContactGroupSipImpl.findContactByID",
	"Comment": "returns the contact with the specified id or null if no such contactexists.",
	"Method": "ContactSipImpl findContactByID(String id){\r\n    Iterator<Contact> contactsIter = contacts();\r\n    while (contactsIter.hasNext()) {\r\n        ContactSipImpl mContact = (ContactSipImpl) contactsIter.next();\r\n        if (mContact.getAddress().equals(id))\r\n            return mContact;\r\n    }\r\n    Iterator<ContactGroup> groupsIter = subgroups();\r\n    while (groupsIter.hasNext()) {\r\n        ContactGroupSipImpl mGroup = (ContactGroupSipImpl) groupsIter.next();\r\n        ContactSipImpl mContact = mGroup.findContactByID(id);\r\n        if (mContact != null)\r\n            return mContact;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.Call.getProtocolProvider",
	"Comment": "returns a reference to the protocolproviderservice instancethat created this call.",
	"Method": "ProtocolProviderService getProtocolProvider(){\r\n    return this.protocolProvider;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.ContactGibberishImpl.getAddress",
	"Comment": "returns a string that can be used for identifying the contact.",
	"Method": "String getAddress(){\r\n    return contactID;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomIrcImpl.assertConnected",
	"Comment": "utility method throwing an exception if the stack is not properlyinitialized.",
	"Method": "void assertConnected(){\r\n    if (parentProvider == null) {\r\n        throw new IllegalStateException(\"The provider must be non-null and signed on the \" + \"service before being able to communicate.\");\r\n    }\r\n    if (!parentProvider.isRegistered()) {\r\n        throw new IllegalStateException(\"The provider must be signed on the service before \" + \"being able to communicate.\");\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.sip.TestOperationSetBasicInstantMessaging.reportingSendFunMessages",
	"Comment": "a method that would simply send messages to a group of people so thatthey would get notified that tests are being run.",
	"Method": "void reportingSendFunMessages(){\r\n    String hostname = \"\";\r\n    try {\r\n        hostname = java.net.InetAddress.getLocalHost().getHostName() + \": \";\r\n    } catch (UnknownHostException ex) {\r\n    }\r\n    String message = hostname + \"Hello this is the SIP Communicator (version \" + System.getProperty(\"sip-communicator.version\") + \") build on: \" + new Date().toString() + \". Have a very nice day!\";\r\n    String list = System.getProperty(\"accounts.reporting.SIP_REPORT_LIST\");\r\n    logger.debug(\"Will send message \" + message + \" to: \" + list);\r\n    if (list == null || list.trim().length() == 0)\r\n        return;\r\n    StringTokenizer tokenizer = new StringTokenizer(list, \" \");\r\n    while (tokenizer.hasMoreTokens()) {\r\n        String contactID = tokenizer.nextToken();\r\n        Contact contact = opSetPresence2.findContactByID(contactID);\r\n        if (contact == null) {\r\n            try {\r\n                opSetPresence2.subscribe(contactID);\r\n                Object o = new Object();\r\n                synchronized (o) {\r\n                    o.wait(2000);\r\n                }\r\n            } catch (Exception ex1) {\r\n                continue;\r\n            }\r\n        }\r\n        contact = opSetPresence2.findContactByID(contactID);\r\n        opSetBasicIM2.sendInstantMessage(contact, opSetBasicIM2.createMessage(message));\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetBasicInstantMessagingJabberImpl.addMessageFilters",
	"Comment": "adds additional filters for incoming messages. to be able to skip somemessages.",
	"Method": "void addMessageFilters(PacketFilter filter){\r\n    this.packetFilters.add(filter);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.PresenceFilter.applyFilter",
	"Comment": "applies this filter. this filter is applied over themetacontactlistservice.",
	"Method": "void applyFilter(FilterQuery filterQuery){\r\n    MetaContactQuery query = new MetaContactQuery();\r\n    filterQuery.addContactQuery(query);\r\n    TreeContactList contactList = GuiActivator.getContactList();\r\n    Collection<UIContactSource> uiContactSourceCollection = contactList.getContactSources(ContactSourceService.CONTACT_LIST_TYPE);\r\n    Iterator<UIContactSource> filterSources = uiContactSourceCollection.iterator();\r\n    int maxIndex = 0;\r\n    while (filterSources.hasNext()) {\r\n        UIContactSource filterSource = filterSources.next();\r\n        int currIx = filterSource.getContactSourceService().getIndex();\r\n        if (maxIndex < currIx)\r\n            maxIndex = currIx;\r\n    }\r\n    contactList.getMetaContactListSource().setIndex(maxIndex + 1);\r\n    filterSources = uiContactSourceCollection.iterator();\r\n    while (filterSources.hasNext()) {\r\n        UIContactSource filterSource = filterSources.next();\r\n        filterSource.setContactSourceIndex(filterSource.getContactSourceService().getIndex());\r\n        ContactSourceService sourceService = filterSource.getContactSourceService();\r\n        ContactQuery contactQuery = sourceService.createContactQuery(null);\r\n        if (contactQuery == null)\r\n            continue;\r\n        filterQuery.addContactQuery(contactQuery);\r\n        contactQuery.addContactQueryListener(contactList);\r\n        contactQuery.start();\r\n    }\r\n    filterQuery.close();\r\n    query.addContactQueryListener(GuiActivator.getContactList());\r\n    int resultCount = 0;\r\n    addMatching(GuiActivator.getContactListService().getRoot(), query, resultCount);\r\n    query.fireQueryEvent(query.isCanceled() ? MetaContactQueryStatusEvent.QUERY_CANCELED : MetaContactQueryStatusEvent.QUERY_COMPLETED);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageSourceService.findRecentMessage",
	"Comment": "tries to match the event object to already existingcomparableevtobj in the supplied list.",
	"Method": "ComparableEvtObj findRecentMessage(EventObject obj,List<ComparableEvtObj> list){\r\n    Contact contact = null;\r\n    ChatRoom chatRoom = null;\r\n    if (obj instanceof MessageDeliveredEvent) {\r\n        contact = ((MessageDeliveredEvent) obj).getDestinationContact();\r\n    } else if (obj instanceof MessageReceivedEvent) {\r\n        contact = ((MessageReceivedEvent) obj).getSourceContact();\r\n    } else if (obj instanceof ChatRoomMessageDeliveredEvent) {\r\n        chatRoom = ((ChatRoomMessageDeliveredEvent) obj).getSourceChatRoom();\r\n    } else if (obj instanceof ChatRoomMessageReceivedEvent) {\r\n        chatRoom = ((ChatRoomMessageReceivedEvent) obj).getSourceChatRoom();\r\n    }\r\n    for (ComparableEvtObj evt : list) {\r\n        if ((contact != null && contact.equals(evt.getContact())) || (chatRoom != null && chatRoom.equals(evt.getRoom())))\r\n            return evt;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ServerStoredContactListJabberImpl.parseAddressString",
	"Comment": "completes the identifier with the server part if no server part waspreviously added.",
	"Method": "String parseAddressString(String id){\r\n    if (id.indexOf(\"@\") < 0) {\r\n        AccountID accountID = jabberProvider.getAccountID();\r\n        String serverPart;\r\n        String userID = accountID.getUserID();\r\n        int atIndex = userID.indexOf('@');\r\n        if (atIndex > 0)\r\n            serverPart = userID.substring(atIndex + 1);\r\n        else\r\n            serverPart = accountID.getService();\r\n        return id + \"@\" + serverPart;\r\n    }\r\n    return id;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.macosx.MacOSXAddrBookContactQuery.deleted",
	"Comment": "callback method when receiving notifications for deleted items.",
	"Method": "void deleted(String id){\r\n    SourceContact sourceContact = findSourceContactByID(id);\r\n    if (sourceContact != null)\r\n        fireContactRemoved(sourceContact);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.keybindingchooser.chooser.BindingChooser.setEditable",
	"Comment": "sets if the shortcut fields of entries can be selected to provide editingfunctionality or not. if false, any selected entry is deselected.",
	"Method": "void setEditable(boolean editable){\r\n    if (!editable && this.selectedEntry != null) {\r\n        setSelected(null);\r\n    }\r\n    this.isShortcutEditable = editable;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.ResizeVideoButton.countAvailableOptions",
	"Comment": "check the available options that will be shownwhen button is pressed.",
	"Method": "int countAvailableOptions(){\r\n    int count = 0;\r\n    if (loOptionPresent)\r\n        count++;\r\n    if (sdOptionPresent)\r\n        count++;\r\n    if (hdOptionPresent)\r\n        count++;\r\n    return count;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.TestOperationSetBasicInstantMessaging.firstTestReceiveMessage",
	"Comment": "send an instant message from the tested operation set and assertreception by the icq tester agent.",
	"Method": "void firstTestReceiveMessage(){\r\n    String body = \"This is an IM coming from the tester agent\" + \" on \" + new Date().toString();\r\n    ImEventCollector evtCollector = new ImEventCollector();\r\n    opSetBasicIM.addMessageListener(evtCollector);\r\n    IcqSlickFixture.testerAgent.sendMessage(fixture.ourUserID, body);\r\n    evtCollector.waitForEvent(10000);\r\n    opSetBasicIM.removeMessageListener(evtCollector);\r\n    assertTrue(\"No events delivered upon a received message\", evtCollector.collectedEvents.size() > 0);\r\n    assertTrue(\"Received evt was not an instance of \" + MessageReceivedEvent.class.getName(), evtCollector.collectedEvents.get(0) instanceof MessageReceivedEvent);\r\n    MessageReceivedEvent evt = (MessageReceivedEvent) evtCollector.collectedEvents.get(0);\r\n    assertEquals(\"message sender \", evt.getSourceContact().getAddress(), IcqSlickFixture.testerAgent.getIcqUIN());\r\n    assertEquals(\"message body\", body, evt.getSourceMessage().getContent());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.PresenceFilter.isContactOnline",
	"Comment": "returns true if the given meta contact is online, falseotherwise.",
	"Method": "boolean isContactOnline(MetaContact contact){\r\n    Contact defaultContact = contact.getDefaultContact();\r\n    if (defaultContact == null)\r\n        return false;\r\n    return defaultContact.getPresenceStatus().getStatus() >= PresenceStatus.ONLINE_THRESHOLD;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ProtocolProviderServiceIcqImpl.initialize",
	"Comment": "initialized the service implementation, and puts it in a sate where itcould interoperate with other services. it is strongly recomended thatproperties in this map be mapped to property names as specified byaccountproperties.",
	"Method": "void initialize(String screenname,AccountID accountID){\r\n    synchronized (initializationLock) {\r\n        this.accountID = accountID;\r\n        if (IcqAccountID.isAIM(accountID.getAccountProperties()))\r\n            USING_ICQ = false;\r\n        addSupportedOperationSet(OperationSetInstantMessageTransform.class, new OperationSetInstantMessageTransformImpl());\r\n        OperationSetPersistentPresence persistentPresence = new OperationSetPersistentPresenceIcqImpl(this, screenname);\r\n        addSupportedOperationSet(OperationSetPersistentPresence.class, persistentPresence);\r\n        addSupportedOperationSet(OperationSetPresence.class, persistentPresence);\r\n        addSupportedOperationSet(OperationSetBasicInstantMessaging.class, new OperationSetBasicInstantMessagingIcqImpl(this));\r\n        addSupportedOperationSet(OperationSetAdHocMultiUserChat.class, new OperationSetAdHocMultiUserChatIcqImpl(this));\r\n        addSupportedOperationSet(OperationSetTypingNotifications.class, new OperationSetTypingNotificationsIcqImpl(this));\r\n        if (USING_ICQ) {\r\n            this.infoRetreiver = new InfoRetreiver(this, screenname);\r\n            addSupportedOperationSet(OperationSetServerStoredContactInfo.class, new OperationSetServerStoredContactInfoIcqImpl(infoRetreiver, this));\r\n            OperationSetServerStoredAccountInfoIcqImpl serverStoredAccountInfoOpSet = new OperationSetServerStoredAccountInfoIcqImpl(infoRetreiver, screenname, this);\r\n            addSupportedOperationSet(OperationSetServerStoredAccountInfo.class, serverStoredAccountInfoOpSet);\r\n            addSupportedOperationSet(OperationSetWebAccountRegistration.class, new OperationSetWebAccountRegistrationIcqImpl());\r\n            addSupportedOperationSet(OperationSetWebContactInfo.class, new OperationSetWebContactInfoIcqImpl());\r\n            addSupportedOperationSet(OperationSetExtendedAuthorizations.class, new OperationSetExtendedAuthorizationsIcqImpl(this));\r\n        }\r\n        addSupportedOperationSet(OperationSetFileTransfer.class, new OperationSetFileTransferIcqImpl(this));\r\n        isInitialized = true;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.IncomingFileTransferRequestIcqImpl.getFileDescription",
	"Comment": "returns a string that represents the description of the file that isbeing received.if there is no description available, returns null.",
	"Method": "String getFileDescription(){\r\n    return incomingFileTransfer.getInvitationMessage().getMessage();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockChatRoom.addMemberRoleListener",
	"Comment": "adds a listener that will be notified of changes of a member role in theroom such as being granded operator.",
	"Method": "void addMemberRoleListener(ChatRoomMemberRoleListener listener){\r\n    if (!memberRoleListeners.contains(listener))\r\n        memberRoleListeners.add(listener);\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.Logger.isTraceEnabled",
	"Comment": "check if a message with a trace level would actually be logged by thislogger.",
	"Method": "boolean isTraceEnabled(){\r\n    return loggerDelegate.isLoggable(Level.FINER);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatSession.chatRoomPropertyChanged",
	"Comment": "updates the chat panel when a property of the chat room has been modified.",
	"Method": "void chatRoomPropertyChanged(ChatRoomPropertyChangeEvent evt){\r\n    if (evt.getPropertyName().equals(ChatRoomPropertyChangeEvent.CHAT_ROOM_SUBJECT)) {\r\n        sessionRenderer.setChatSubject((String) evt.getNewValue());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.thumbnail.ThumbnailElement.addXmlIntAttribute",
	"Comment": "creates the xml string corresponding to the specified attributeand value and adds them to the buff stringbuffer.",
	"Method": "StringBuffer addXmlIntAttribute(StringBuffer buff,String attrName,int attrValue){\r\n    return addXmlAttribute(buff, attrName, String.valueOf(attrValue));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.GuiActivator.getMUCService",
	"Comment": "returns a reference to a mucservice implementationcurrently registered in the bundle context or null if no suchimplementation was found.",
	"Method": "MUCService getMUCService(){\r\n    if (mucService == null) {\r\n        mucService = ServiceUtils.getService(bundleContext, MUCService.class);\r\n    }\r\n    return mucService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapDirectoryImpl.fetchPhotoForPerson",
	"Comment": "tries to fetch the photo of the person withthe given distinguished name in the directory",
	"Method": "byte[] fetchPhotoForPerson(String dn){\r\n    if (this.settings.isPhotoInline()) {\r\n        return null;\r\n    }\r\n    byte[] photo = null;\r\n    InitialDirContext dirContext = null;\r\n    final SearchControls searchCtl = new SearchControls();\r\n    searchCtl.setSearchScope(SearchControls.OBJECT_SCOPE);\r\n    searchCtl.setReturningAttributes(PHOTO_ATTRIBUTES);\r\n    logger.trace(\"starting photo retrieval...\");\r\n    try {\r\n        dirContext = connect();\r\n        String newBaseDN;\r\n        if (settings.getBaseDN().equals(\"\"))\r\n            newBaseDN = dn;\r\n        else\r\n            newBaseDN = dn + \",\" + this.settings.getBaseDN();\r\n        NamingEnumeration<?> result = dirContext.search(newBaseDN, \"(objectClass=*)\", searchCtl);\r\n        if (result.hasMore()) {\r\n            SearchResult searchResult = (SearchResult) result.next();\r\n            Attributes attributes = searchResult.getAttributes();\r\n            for (String a : PHOTO_ATTRIBUTES) {\r\n                Attribute attribute = attributes.get(a);\r\n                if (attribute != null) {\r\n                    NamingEnumeration<?> values = attribute.getAll();\r\n                    if (values.hasMore()) {\r\n                        photo = (byte[]) values.next();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } catch (NamingException e) {\r\n        logger.trace(\"error when performing photo retrieval\" + e);\r\n        e.printStackTrace();\r\n    } finally {\r\n        if (dirContext != null)\r\n            disconnect(dirContext);\r\n    }\r\n    return photo;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.AbstractPacketExtension.getAttributeAsInt",
	"Comment": "returns the int value of the attribute with the specifiedname.",
	"Method": "int getAttributeAsInt(String attribute,int getAttributeAsInt,String attribute,int defaultValue){\r\n    synchronized (attributes) {\r\n        String value = getAttributeAsString(attribute);\r\n        return (value == null) ? defaultValue : Integer.parseInt(value);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.AbstractOperationSetBasicTelephony.addCallListener",
	"Comment": "registers listener with this provider so that itcould be notified when incoming calls are received.",
	"Method": "void addCallListener(CallListener listener){\r\n    synchronized (callListeners) {\r\n        if (!callListeners.contains(listener))\r\n            callListeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.ProtocolProviderActivator.getResourceService",
	"Comment": "gets the resourcemanagementservice to be used by the classesin the bundle represented by protocolprovideractivator.",
	"Method": "ResourceManagementService getResourceService(){\r\n    if (resourceService == null) {\r\n        resourceService = (ResourceManagementService) bundleContext.getService(bundleContext.getServiceReference(ResourceManagementService.class.getName()));\r\n    }\r\n    return resourceService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.gui.event.ContactListEvent.getSourceGroup",
	"Comment": "returns the uigroupdescriptor for which this event occured.",
	"Method": "UIGroup getSourceGroup(){\r\n    if (getSource() instanceof UIGroup)\r\n        return (UIGroup) getSource();\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.RootContactGroupJabberImpl.getContact",
	"Comment": "returns the contact with the specified address oridentifier.",
	"Method": "Contact getContact(String id){\r\n    return findContact(id);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ServerStoredContactListJabberImpl.fireContactAdded",
	"Comment": "make the parent persistent presence operation set dispatch a contactadded event.",
	"Method": "void fireContactAdded(ContactGroup parentGroup,ContactJabberImpl contact){\r\n    if (parentOperationSet == null) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"No presence op. set available. Bailing out.\");\r\n        return;\r\n    }\r\n    if (roster != null) {\r\n        parentOperationSet.firePresenceStatusChanged(roster.getPresence(contact.getAddress()));\r\n    }\r\n    parentOperationSet.fireSubscriptionEvent(contact, parentGroup, SubscriptionEvent.SUBSCRIPTION_CREATED);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.WhiteboardSessionJabberImpl.fireWhiteboardParticipantEvent",
	"Comment": "creates a whiteboardparticipantevent withsourcewhiteboardparticipant and eventid and dispatchesit on all currently registered listeners.",
	"Method": "void fireWhiteboardParticipantEvent(WhiteboardParticipant sourceWhiteboardParticipant,int eventID){\r\n    WhiteboardParticipantEvent cpEvent = new WhiteboardParticipantEvent(this, sourceWhiteboardParticipant, eventID);\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Dispatching a WhiteboardParticipant event to \" + whiteboardListeners.size() + \" listeners. event is: \" + cpEvent.toString());\r\n    Iterable<WhiteboardChangeListener> listeners;\r\n    synchronized (whiteboardListeners) {\r\n        listeners = new ArrayList<WhiteboardChangeListener>(whiteboardListeners);\r\n    }\r\n    for (WhiteboardChangeListener listener : listeners) {\r\n        if (eventID == WhiteboardParticipantEvent.WHITEBOARD_PARTICIPANT_ADDED) {\r\n            listener.whiteboardParticipantAdded(cpEvent);\r\n        } else if (eventID == WhiteboardParticipantEvent.WHITEBOARD_PARTICIPANT_REMOVED) {\r\n            listener.whiteboardParticipantRemoved(cpEvent);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.BaseChatRoomSourceContact.getProvider",
	"Comment": "returns the provider of the chat room associated with the contact.",
	"Method": "ProtocolProviderService getProvider(){\r\n    return provider;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomIrcImpl.removeMemberRoleListener",
	"Comment": "removes a listener that was being notified of changes of a member role inthis chat room such as us being granded operator.",
	"Method": "void removeMemberRoleListener(ChatRoomMemberRoleListener listener){\r\n    synchronized (memberRoleListeners) {\r\n        if (memberRoleListeners.contains(listener)) {\r\n            memberRoleListeners.remove(listener);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactListServiceImpl.findMetaContactByContact",
	"Comment": "returns the metacontact containing a contact with an address equal tocontactaddress and with a source provider matchingaccountid, or null if no such metacontact was found. the methodcan be used when for example weneed to find the metacontact that is the author of an incoming messageand the corresponding protocolproviderservice has only provided acontact as its author.",
	"Method": "MetaContact findMetaContactByContact(Contact contact,MetaContact findMetaContactByContact,String contactAddress,String accountID){\r\n    return rootMetaGroup.findMetaContactByContact(contactAddress, accountID);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.notifsource.NotificationContactSource.isContactActionVisible",
	"Comment": "indicates if the given contactaction should be visible for thegiven notificationcontact.",
	"Method": "boolean isContactActionVisible(ContactAction<NotificationMessage> contactAction,NotificationContact notifContact){\r\n    if (contactAction.isVisible(notifContact.getNotificationMessage()))\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.UIServiceImpl.serviceChanged",
	"Comment": "notifies all plugin containers of a plugincomponentregistration.",
	"Method": "void serviceChanged(ServiceEvent event){\r\n    Object sService = GuiActivator.bundleContext.getService(event.getServiceReference());\r\n    if (!(sService instanceof PluginComponentFactory))\r\n        return;\r\n    PluginComponentFactory factory = (PluginComponentFactory) sService;\r\n    switch(event.getType()) {\r\n        case ServiceEvent.REGISTERED:\r\n            if (logger.isInfoEnabled())\r\n                logger.info(\"Handling registration of a new Plugin Component.\");\r\n            this.firePluginEvent(factory, PluginComponentEvent.PLUGIN_COMPONENT_ADDED);\r\n            break;\r\n        case ServiceEvent.UNREGISTERING:\r\n            this.firePluginEvent(factory, PluginComponentEvent.PLUGIN_COMPONENT_REMOVED);\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetPresenceSipImpl.getPidfPresenceStatus",
	"Comment": "converts the presencestatus of contact into a pidfdocument.",
	"Method": "byte[] getPidfPresenceStatus(ContactSipImpl contact){\r\n    Document doc = this.createDocument();\r\n    if (doc == null)\r\n        return null;\r\n    String contactUri = contact.getSipAddress().getURI().toString();\r\n    Element presence = doc.createElement(PRESENCE_ELEMENT);\r\n    presence.setAttribute(NS_ELEMENT, PIDF_NS_VALUE);\r\n    presence.setAttribute(RPID_NS_ELEMENT, RPID_NS_VALUE);\r\n    presence.setAttribute(DM_NS_ELEMENT, DM_NS_VALUE);\r\n    presence.setAttribute(ENTITY_ATTRIBUTE, contactUri);\r\n    doc.appendChild(presence);\r\n    Element person = doc.createElement(NS_PERSON_ELT);\r\n    person.setAttribute(ID_ATTRIBUTE, PERSON_ID);\r\n    presence.appendChild(person);\r\n    Element activities = doc.createElement(NS_ACTIVITY_ELT);\r\n    person.appendChild(activities);\r\n    URI imageUri = ssContactList.getImageUri();\r\n    if (imageUri != null) {\r\n        Element statusIcon = doc.createElement(NS_STATUS_ICON_ELT);\r\n        statusIcon.setTextContent(imageUri.toString());\r\n        person.appendChild(statusIcon);\r\n    }\r\n    if (contact.getPresenceStatus().equals(sipStatusEnum.getStatus(SipStatusEnum.AWAY))) {\r\n        Element away = doc.createElement(NS_AWAY_ELT);\r\n        activities.appendChild(away);\r\n    } else if (contact.getPresenceStatus().equals(sipStatusEnum.getStatus(SipStatusEnum.BUSY))) {\r\n        Element busy = doc.createElement(NS_BUSY_ELT);\r\n        activities.appendChild(busy);\r\n    } else if (contact.getPresenceStatus().equals(sipStatusEnum.getStatus(SipStatusEnum.ON_THE_PHONE))) {\r\n        Element otp = doc.createElement(NS_OTP_ELT);\r\n        activities.appendChild(otp);\r\n    }\r\n    Element tuple = doc.createElement(TUPLE_ELEMENT);\r\n    tuple.setAttribute(ID_ATTRIBUTE, TUPLE_ID);\r\n    presence.appendChild(tuple);\r\n    Element status = doc.createElement(STATUS_ELEMENT);\r\n    tuple.appendChild(status);\r\n    Element basic = doc.createElement(BASIC_ELEMENT);\r\n    if (contact.getPresenceStatus().equals(sipStatusEnum.getStatus(SipStatusEnum.OFFLINE))) {\r\n        basic.appendChild(doc.createTextNode(OFFLINE_STATUS));\r\n    } else {\r\n        basic.appendChild(doc.createTextNode(ONLINE_STATUS));\r\n    }\r\n    status.appendChild(basic);\r\n    Element contactUriEl = doc.createElement(CONTACT_ELEMENT);\r\n    Node cValue = doc.createTextNode(contactUri);\r\n    contactUriEl.appendChild(cValue);\r\n    tuple.appendChild(contactUriEl);\r\n    Element noteNodeEl = doc.createElement(NOTE_ELEMENT);\r\n    noteNodeEl.appendChild(doc.createTextNode(contact.getPresenceStatus().getStatusName()));\r\n    tuple.appendChild(noteNodeEl);\r\n    String res = convertDocument(doc);\r\n    if (res == null)\r\n        return null;\r\n    return res.getBytes();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.notificationconfiguration.NotificationEntry.setProgram",
	"Comment": "method which set a boolean to true if a program is executed for thenotification.",
	"Method": "void setProgram(boolean program){\r\n    this.program = program;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.ProtocolProviderFactory.createAccount",
	"Comment": "initializes and creates an account corresponding to the specifiedaccountproperties.",
	"Method": "AccountID createAccount(Map<String, String> accountProperties){\r\n    BundleContext bundleContext = getBundleContext();\r\n    if (bundleContext == null)\r\n        throw new NullPointerException(\"The specified BundleContext was null\");\r\n    if (accountProperties == null)\r\n        throw new NullPointerException(\"The specified property map was null\");\r\n    String userID = accountProperties.get(USER_ID);\r\n    if (userID == null)\r\n        throw new NullPointerException(\"The account properties contained no user id.\");\r\n    String protocolName = getProtocolName();\r\n    if (!accountProperties.containsKey(PROTOCOL))\r\n        accountProperties.put(PROTOCOL, protocolName);\r\n    return createAccountID(userID, accountProperties);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipStackSharing.getPreferredClearPort",
	"Comment": "fetches the preferred udp and tcp port for clear communications in theuser preferences or search is default value set in settings orfallback on a default value.",
	"Method": "int getPreferredClearPort(){\r\n    int preferredPort = SipActivator.getConfigurationService().getInt(PREFERRED_CLEAR_PORT_PROPERTY_NAME, -1);\r\n    if (preferredPort <= 1) {\r\n        preferredPort = SipActivator.getResources().getSettingsInt(PREFERRED_CLEAR_PORT_PROPERTY_NAME);\r\n    }\r\n    if (preferredPort <= 1)\r\n        return ListeningPoint.PORT_5060;\r\n    else\r\n        return preferredPort;\r\n}"
}, {
	"Path": "com.keybox.manage.db.SystemDB.getUserSystemSet",
	"Comment": "method to do order by based on the sorted set object for systems for user",
	"Method": "SortedSet getUserSystemSet(SortedSet sortedSet,Long userId){\r\n    List<HostSystem> hostSystemList = new ArrayList();\r\n    String orderBy = \"\";\r\n    if (sortedSet.getOrderByField() != null && !sortedSet.getOrderByField().trim().equals(\"\")) {\r\n        orderBy = \"order by \" + sortedSet.getOrderByField() + \" \" + sortedSet.getOrderByDirection();\r\n    }\r\n    String sql = \"select * from system where id in (select distinct system_id from  system_map m, user_map um where m.profile_id=um.profile_id and um.user_id=? \";\r\n    sql += StringUtils.isNotEmpty(sortedSet.getFilterMap().get(FILTER_BY_PROFILE_ID)) ? \" and um.profile_id=? \" : \"\";\r\n    sql += \") \" + orderBy;\r\n    Connection con = null;\r\n    try {\r\n        con = DBUtils.getConn();\r\n        PreparedStatement stmt = con.prepareStatement(sql);\r\n        stmt.setLong(1, userId);\r\n        if (StringUtils.isNotEmpty(sortedSet.getFilterMap().get(FILTER_BY_PROFILE_ID))) {\r\n            stmt.setLong(2, Long.parseLong(sortedSet.getFilterMap().get(FILTER_BY_PROFILE_ID)));\r\n        }\r\n        ResultSet rs = stmt.executeQuery();\r\n        while (rs.next()) {\r\n            HostSystem hostSystem = new HostSystem();\r\n            hostSystem.setId(rs.getLong(\"id\"));\r\n            hostSystem.setDisplayNm(rs.getString(DISPLAY_NM));\r\n            hostSystem.setUser(rs.getString(\"user\"));\r\n            hostSystem.setHost(rs.getString(\"host\"));\r\n            hostSystem.setPort(rs.getInt(\"port\"));\r\n            hostSystem.setAuthorizedKeys(rs.getString(AUTHORIZED_KEYS));\r\n            hostSystem.setStatusCd(rs.getString(STATUS_CD));\r\n            hostSystemList.add(hostSystem);\r\n        }\r\n        DBUtils.closeRs(rs);\r\n        DBUtils.closeStmt(stmt);\r\n    } catch (Exception e) {\r\n        log.error(e.toString(), e);\r\n    } finally {\r\n        DBUtils.closeConn(con);\r\n    }\r\n    sortedSet.setItemList(hostSystemList);\r\n    return sortedSet;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.notification.NotificationServiceImpl.saveNotification",
	"Comment": "saves the event notification given by these parameters through theconfigurationservice.",
	"Method": "void saveNotification(String eventType,NotificationAction action,boolean isActive,boolean isDefault){\r\n    String eventTypeNodeName = null;\r\n    String actionTypeNodeName = null;\r\n    List<String> eventTypes = configService.getPropertyNamesByPrefix(NOTIFICATIONS_PREFIX, true);\r\n    for (String eventTypeRootPropName : eventTypes) {\r\n        String eType = configService.getString(eventTypeRootPropName);\r\n        if (eType.equals(eventType))\r\n            eventTypeNodeName = eventTypeRootPropName;\r\n    }\r\n    if (eventTypeNodeName == null) {\r\n        eventTypeNodeName = NOTIFICATIONS_PREFIX + \".eventType\" + Long.toString(System.currentTimeMillis());\r\n        configService.setProperty(eventTypeNodeName, eventType);\r\n    }\r\n    if (action == null) {\r\n        configService.setProperty(eventTypeNodeName + \".active\", Boolean.toString(isActive));\r\n        return;\r\n    }\r\n    String actionPrefix = eventTypeNodeName + \".actions\";\r\n    List<String> actionTypes = configService.getPropertyNamesByPrefix(actionPrefix, true);\r\n    for (String actionTypeRootPropName : actionTypes) {\r\n        String aType = configService.getString(actionTypeRootPropName);\r\n        if (aType.equals(action.getActionType()))\r\n            actionTypeNodeName = actionTypeRootPropName;\r\n    }\r\n    Map<String, Object> configProperties = new HashMap<String, Object>();\r\n    if (actionTypeNodeName == null) {\r\n        actionTypeNodeName = actionPrefix + \".actionType\" + Long.toString(System.currentTimeMillis());\r\n        configProperties.put(actionTypeNodeName, action.getActionType());\r\n    }\r\n    if (action instanceof SoundNotificationAction) {\r\n        SoundNotificationAction soundAction = (SoundNotificationAction) action;\r\n        configProperties.put(actionTypeNodeName + \".soundFileDescriptor\", soundAction.getDescriptor());\r\n        configProperties.put(actionTypeNodeName + \".loopInterval\", soundAction.getLoopInterval());\r\n        configProperties.put(actionTypeNodeName + \".isSoundNotificationEnabled\", soundAction.isSoundNotificationEnabled());\r\n        configProperties.put(actionTypeNodeName + \".isSoundPlaybackEnabled\", soundAction.isSoundPlaybackEnabled());\r\n        configProperties.put(actionTypeNodeName + \".isSoundPCSpeakerEnabled\", soundAction.isSoundPCSpeakerEnabled());\r\n    } else if (action instanceof PopupMessageNotificationAction) {\r\n        PopupMessageNotificationAction messageAction = (PopupMessageNotificationAction) action;\r\n        configProperties.put(actionTypeNodeName + \".defaultMessage\", messageAction.getDefaultMessage());\r\n        configProperties.put(actionTypeNodeName + \".timeout\", messageAction.getTimeout());\r\n        configProperties.put(actionTypeNodeName + \".groupName\", messageAction.getGroupName());\r\n    } else if (action instanceof LogMessageNotificationAction) {\r\n        LogMessageNotificationAction logMessageAction = (LogMessageNotificationAction) action;\r\n        configProperties.put(actionTypeNodeName + \".logType\", logMessageAction.getLogType());\r\n    } else if (action instanceof CommandNotificationAction) {\r\n        CommandNotificationAction commandAction = (CommandNotificationAction) action;\r\n        configProperties.put(actionTypeNodeName + \".commandDescriptor\", commandAction.getDescriptor());\r\n    } else if (action instanceof VibrateNotificationAction) {\r\n        VibrateNotificationAction vibrateAction = (VibrateNotificationAction) action;\r\n        configProperties.put(actionTypeNodeName + \".descriptor\", vibrateAction.getDescriptor());\r\n        long[] pattern = vibrateAction.getPattern();\r\n        configProperties.put(actionTypeNodeName + \".patternLength\", pattern.length);\r\n        for (int pIdx = 0; pIdx < pattern.length; pIdx++) {\r\n            configProperties.put(actionTypeNodeName + \".patternItem\" + pIdx, pattern[pIdx]);\r\n        }\r\n        configProperties.put(actionTypeNodeName + \".repeat\", vibrateAction.getRepeat());\r\n    }\r\n    configProperties.put(actionTypeNodeName + \".enabled\", Boolean.toString(isActive));\r\n    configProperties.put(actionTypeNodeName + \".default\", Boolean.toString(isDefault));\r\n    configService.setProperties(configProperties);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ServerStoredContactList.createUnresolvedContactGroup",
	"Comment": "creates a non resolved contact group for the specified name. the newlycreated group would be added to the local contact list as any other groupbut when an event is received from the server concerning this group, thenit will be reused and only its isresolved field would be updated insteadof creating the whole group again.",
	"Method": "ContactGroupSipImpl createUnresolvedContactGroup(ContactGroupSipImpl parentGroup,String groupName){\r\n    if (parentGroup == null) {\r\n        throw new IllegalArgumentException(\"Parent group cannot be null\");\r\n    }\r\n    if (groupName == null || groupName.length() == 0) {\r\n        throw new IllegalArgumentException(\"Creating group name cannot be null or empry\");\r\n    }\r\n    if (logger.isTraceEnabled()) {\r\n        logger.trace(\"createUnresolvedContactGroup \" + groupName);\r\n    }\r\n    ContactGroupSipImpl existingGroup = findGroupByName(groupName);\r\n    if (existingGroup != null) {\r\n        return existingGroup;\r\n    }\r\n    ContactGroupSipImpl subGroup = new ContactGroupSipImpl(groupName, sipProvider);\r\n    subGroup.setResolved(false);\r\n    parentGroup.addSubgroup(subGroup);\r\n    fireGroupEvent(subGroup, ServerStoredGroupEvent.GROUP_CREATED_EVENT);\r\n    return subGroup;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.credentialsstorage.CredentialsStorageServiceImpl.getEncrypted",
	"Comment": "retrieves the encrypted account password using configuration service.",
	"Method": "String getEncrypted(String accountPrefix){\r\n    return configurationService.getString(accountPrefix + \".\" + ACCOUNT_ENCRYPTED_PASSWORD);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.keybindingchooser.chooser.BindingEntry.equals",
	"Comment": "checks if argument is an instance of this class with the same shortcutand associated action. it does not compare aspects of the displayelements.",
	"Method": "boolean equals(Object obj){\r\n    if (obj == this)\r\n        return true;\r\n    else if (!(obj instanceof BindingEntry))\r\n        return false;\r\n    BindingEntry entry = (BindingEntry) obj;\r\n    boolean equals = true;\r\n    String action = this.getAction();\r\n    if (action == null)\r\n        equals &= entry.getAction() == null;\r\n    else\r\n        equals &= action.equals(entry.getAction());\r\n    KeyStroke shortcut = this.getShortcut();\r\n    if (shortcut == null)\r\n        equals &= entry.getShortcut() == null;\r\n    else\r\n        equals &= shortcut.equals(entry.getShortcut());\r\n    return equals;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetServerStoredAccountInfoSipImpl.getMaxDetailInstances",
	"Comment": "the method returns the number of instances supported for a particulardetail type.",
	"Method": "int getMaxDetailInstances(Class<? extends GenericDetail> detailClass){\r\n    if (ImageDetail.class.isAssignableFrom(detailClass) && isImageDetailSupported()) {\r\n        return 1;\r\n    } else if (DisplayNameDetail.class.isAssignableFrom(detailClass)) {\r\n        return 1;\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.sdp.SdpUtils.setIceCredentials",
	"Comment": "sets the specified ice user fragment and password as attributes of thespecified session description.",
	"Method": "void setIceCredentials(SessionDescription sDes,String uFrag,String pwd){\r\n    IceSdpUtils.setIceCredentials(sDes, uFrag, pwd);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.FileTransferRequestEvent.getRequest",
	"Comment": "returns the incoming file transfer request that triggered this event.",
	"Method": "IncomingFileTransferRequest getRequest(){\r\n    return request;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommButton.paintComponent",
	"Comment": "overrides the paintcomponent method of jbutton topaint the button background and icon, and all additional effects of thisconfigurable button.",
	"Method": "void paintComponent(Graphics g){\r\n    g = g.create();\r\n    try {\r\n        internalPaintComponent(g);\r\n    } finally {\r\n        g.dispose();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.TestOperationSetMultiUserChat.testFindRoom",
	"Comment": "tries to find the test room we created previously and makes sure it looksas expected.",
	"Method": "void testFindRoom(){\r\n    ChatRoom testChatRoom = opSetMultiChat1.findRoom(fixture.chatRoomName);\r\n    assertNotNull(\"Could not find the test chat room on the server\", testChatRoom);\r\n    String roomName = testChatRoom.getName();\r\n    assertEquals(\"Name of the test chat room did not match the name of the \" + \"room we created\", fixture.chatRoomName, roomName);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaHandler.registerDynamicPTsWithStream",
	"Comment": "registers all dynamic payload mappings and any payload type overridesthat are known to this mediahandler with the specifiedmediastream.",
	"Method": "void registerDynamicPTsWithStream(CallPeerMediaHandler<?> callPeerMediaHandler,MediaStream stream){\r\n    DynamicPayloadTypeRegistry dynamicPayloadTypes = callPeerMediaHandler.getDynamicPayloadTypes();\r\n    StringBuffer dbgMessage = new StringBuffer(\"Dynamic PT map: \");\r\n    for (Map.Entry<MediaFormat, Byte> mapEntry : dynamicPayloadTypes.getMappings().entrySet()) {\r\n        byte pt = mapEntry.getValue();\r\n        MediaFormat fmt = mapEntry.getKey();\r\n        dbgMessage.append(pt).append(\"=\").append(fmt).append(\"; \");\r\n        stream.addDynamicRTPPayloadType(pt, fmt);\r\n    }\r\n    logger.info(dbgMessage);\r\n    dbgMessage = new StringBuffer(\"PT overrides [\");\r\n    for (Map.Entry<Byte, Byte> overrideEntry : dynamicPayloadTypes.getMappingOverrides().entrySet()) {\r\n        byte originalPt = overrideEntry.getKey();\r\n        byte overridePt = overrideEntry.getValue();\r\n        dbgMessage.append(originalPt).append(\"->\").append(overridePt).append(\" \");\r\n        stream.addDynamicRTPPayloadTypeOverride(originalPt, overridePt);\r\n    }\r\n    dbgMessage.append(\"]\");\r\n    logger.info(dbgMessage);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.IrcStack.connect",
	"Comment": "connect to specified host, port, optionally using a password.",
	"Method": "void connect(String host,int port,String password,boolean secureConnection,boolean autoNickChange,ClientConfig config){\r\n    final String plainPass = determinePlainPassword(password, config);\r\n    final IRCServer server = createServer(config, host, port, secureConnection, plainPass);\r\n    try {\r\n        synchronized (this.session) {\r\n            final IrcConnection current = this.session.get();\r\n            if (current != null && current.isConnected()) {\r\n                return;\r\n            }\r\n            this.params.setServer(server);\r\n            final IRCApi irc = new IRCApiImpl(true);\r\n            if (LOGGER.isTraceEnabled()) {\r\n                irc.addListener(new DebugListener());\r\n            }\r\n            this.session.set(new IrcConnection(this.context, config, irc, this.params, password, this));\r\n            this.provider.setCurrentRegistrationState(RegistrationState.REGISTERED, RegistrationStateChangeEvent.REASON_USER_REQUEST);\r\n        }\r\n    } catch (IOException e) {\r\n        if (isCausedByCertificateException(e)) {\r\n            LOGGER.info(\"Connection aborted due to server certificate.\");\r\n            this.provider.setCurrentRegistrationState(RegistrationState.UNREGISTERED, RegistrationStateChangeEvent.REASON_USER_REQUEST);\r\n            throw new OperationFailedException(\"Failed certificate verification.\", OperationFailedException.OPERATION_CANCELED);\r\n        } else {\r\n            this.provider.setCurrentRegistrationState(RegistrationState.CONNECTION_FAILED, RegistrationStateChangeEvent.REASON_NOT_SPECIFIED);\r\n            throw e;\r\n        }\r\n    } catch (InterruptedException e) {\r\n        this.provider.setCurrentRegistrationState(RegistrationState.UNREGISTERED, RegistrationStateChangeEvent.REASON_USER_REQUEST);\r\n        throw e;\r\n    } catch (NotYetConnectedException e) {\r\n        this.provider.setCurrentRegistrationState(RegistrationState.CONNECTION_FAILED, RegistrationStateChangeEvent.REASON_NOT_SPECIFIED);\r\n        throw e;\r\n    } catch (Exception e) {\r\n        LOGGER.error(\"Unanticipated exception occurred!\", e);\r\n        this.provider.setCurrentRegistrationState(RegistrationState.CONNECTION_FAILED, RegistrationStateChangeEvent.REASON_INTERNAL_ERROR);\r\n        throw e;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetIncomingDTMFSipImpl.removeDTMFListener",
	"Comment": "removes the specified listener from the list of dtmf listeners.",
	"Method": "void removeDTMFListener(DTMFListener listener){\r\n    this.opsetDTMFSip.getDtmfModeInfo().removeDTMFListener(listener);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomJabberImpl.addMemberRoleListener",
	"Comment": "adds a listener that will be notified of changes of a member role in theroom such as being granded operator.",
	"Method": "void addMemberRoleListener(ChatRoomMemberRoleListener listener){\r\n    synchronized (memberRoleListeners) {\r\n        if (!memberRoleListeners.contains(listener))\r\n            memberRoleListeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.systray.AbstractPopupMessageHandler.addPopupMessageListener",
	"Comment": "adds a systraypopupmessagelistener to this instance so that itreceives systraypopupmessageevents.",
	"Method": "void addPopupMessageListener(SystrayPopupMessageListener listener){\r\n    synchronized (popupMessageListeners) {\r\n        if (!popupMessageListeners.contains(listener))\r\n            popupMessageListeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.SecurityAccountRegistration.storeProperties",
	"Comment": "stores security properties held by this registration object into givenproperties map.",
	"Method": "void storeProperties(Map<String, String> propertiesMap){\r\n    propertiesMap.put(ProtocolProviderFactory.DEFAULT_ENCRYPTION, Boolean.toString(isDefaultEncryption()));\r\n    addEncryptionProtocolsToProperties(propertiesMap);\r\n    addEncryptionProtocolStatusToProperties(propertiesMap);\r\n    propertiesMap.put(ProtocolProviderFactory.DEFAULT_SIPZRTP_ATTRIBUTE, Boolean.toString(isSipZrtpAttribute()));\r\n    propertiesMap.put(ProtocolProviderFactory.SAVP_OPTION, Integer.toString(getSavpOption()));\r\n    propertiesMap.put(ProtocolProviderFactory.SDES_CIPHER_SUITES, getSDesCipherSuites());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl.answerCallPeer",
	"Comment": "indicates a user request to answer an incoming call from the specifiedcallpeer.sends an ok response to callpeer. make sure that the callpeer contains an sdp description when you call this method.",
	"Method": "void answerCallPeer(CallPeer peer){\r\n    ((CallPeerSipImpl) peer).answer();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.TreeContactList.isContactActive",
	"Comment": "returns true if the given metacontact has beenpreviously set to active, otherwise returns false.",
	"Method": "boolean isContactActive(UIContactImpl contact){\r\n    synchronized (contact) {\r\n        ContactNode contactNode = contact.getContactNode();\r\n        return (contactNode == null) ? false : contactNode.isActive();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.InfoRetreiver.getContactDetails",
	"Comment": "request the full info for the given uinwaits and return this details",
	"Method": "List<GenericDetail> getContactDetails(String uin){\r\n    List<GenericDetail> result = getCachedContactDetails(uin);\r\n    if (result == null) {\r\n        return retrieveDetails(uin);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatTransport.allowsMessageCorrections",
	"Comment": "returns true if this chat transport supports messagecorrections and false otherwise.",
	"Method": "boolean allowsMessageCorrections(){\r\n    return false;\r\n}"
}, {
	"Path": "net.librec.conf.Configuration.getStrings",
	"Comment": "get the comma delimited values of the name property as anarray of strings. if no such property is specified thennull is returned.",
	"Method": "String[] getStrings(String name){\r\n    String valueString = get(name);\r\n    return StringUtil.getStrings(valueString);\r\n}"
}, {
	"Path": "net.librec.eval.ranking.IdealDCGEvaluator.evaluate",
	"Comment": "evaluate on the test set with the the list of recommended items.",
	"Method": "double evaluate(RecommendedList groundTruthList,RecommendedList recommendedList){\r\n    double iDCG = 0.0;\r\n    int numContext = groundTruthList.size();\r\n    int nonZeroContext = 0;\r\n    for (int contextIdx = 0; contextIdx < numContext; ++contextIdx) {\r\n        double idcg = 0.0;\r\n        int sizeByContext = groundTruthList.getKeyValueListByContext(contextIdx).size();\r\n        if (sizeByContext > 0) {\r\n            for (int i = 0; i < sizeByContext; i++) {\r\n                idcg += 1 / Maths.log(i + 2.0, 2);\r\n            }\r\n            iDCG += idcg;\r\n            ++nonZeroContext;\r\n        }\r\n    }\r\n    return nonZeroContext > 0 ? iDCG / nonZeroContext : 0.0d;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipRegistrarlessConnection.unregister",
	"Comment": "simply sets the state of the connection to unregistered without doinganything else.",
	"Method": "void unregister(){\r\n    setRegistrationState(RegistrationState.UNREGISTERING, RegistrationStateChangeEvent.REASON_USER_REQUEST, \"\");\r\n    setRegistrationState(RegistrationState.UNREGISTERED, RegistrationStateChangeEvent.REASON_USER_REQUEST, null);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.ProtocolProviderServiceGibberishImpl.getRegistrationState",
	"Comment": "returns the state of the registration of this protocol provider withthe corresponding registration service.",
	"Method": "RegistrationState getRegistrationState(){\r\n    return currentRegistrationState;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ServerStoredContactListJabberImpl.initRoster",
	"Comment": "when the protocol is online this method is used to fill or resolvethe current contact list",
	"Method": "void initRoster(){\r\n    if (roster.getUnfiledEntryCount() > 0) {\r\n        for (RosterEntry item : roster.getUnfiledEntries()) {\r\n            ContactJabberImpl contact = findContactById(item.getUser());\r\n            if (!isEntryDisplayable(item)) {\r\n                if (contact != null) {\r\n                    ContactGroup parent = contact.getParentContactGroup();\r\n                    if (parent instanceof RootContactGroupJabberImpl)\r\n                        ((RootContactGroupJabberImpl) parent).removeContact(contact);\r\n                    else\r\n                        ((ContactGroupJabberImpl) parent).removeContact(contact);\r\n                    fireContactRemoved(parent, contact);\r\n                }\r\n                continue;\r\n            }\r\n            if (contact == null) {\r\n                contact = new ContactJabberImpl(item, this, true, true);\r\n                rootGroup.addContact(contact);\r\n                fireContactAdded(rootGroup, contact);\r\n            } else {\r\n                ContactGroup group = contact.getParentContactGroup();\r\n                if (!rootGroup.equals(group)) {\r\n                    contactMoved(group, rootGroup, contact);\r\n                }\r\n                contact.setResolved(item);\r\n                fireContactResolved(rootGroup, contact);\r\n            }\r\n            try {\r\n                parentOperationSet.firePresenceStatusChanged(roster.getPresence(item.getUser()));\r\n            } catch (Throwable t) {\r\n                logger.error(\"Error processing presence\", t);\r\n            }\r\n        }\r\n    }\r\n    Iterator<Contact> iter = rootGroup.contacts();\r\n    List<ContactJabberImpl> contactsToRemove = new ArrayList<ContactJabberImpl>();\r\n    while (iter.hasNext()) {\r\n        ContactJabberImpl contact = (ContactJabberImpl) iter.next();\r\n        if (!contact.isResolved()) {\r\n            contactsToRemove.add(contact);\r\n        }\r\n    }\r\n    for (ContactJabberImpl contact : contactsToRemove) {\r\n        rootGroup.removeContact(contact);\r\n        fireContactRemoved(rootGroup, contact);\r\n    }\r\n    contactsToRemove.clear();\r\n    for (RosterGroup item : roster.getGroups()) {\r\n        ContactGroupJabberImpl group = findContactGroup(item.getName());\r\n        if (group != null) {\r\n            group.setResolved(item);\r\n            fireGroupEvent(group, ServerStoredGroupEvent.GROUP_RESOLVED_EVENT);\r\n        }\r\n    }\r\n    Iterator<ContactGroup> iterGroups = rootGroup.subgroups();\r\n    List<ContactGroupJabberImpl> groupsToRemove = new ArrayList<ContactGroupJabberImpl>();\r\n    while (iterGroups.hasNext()) {\r\n        ContactGroupJabberImpl group = (ContactGroupJabberImpl) iterGroups.next();\r\n        if (!group.isPersistent())\r\n            continue;\r\n        if (!group.isResolved()) {\r\n            groupsToRemove.add(group);\r\n        }\r\n        Iterator<Contact> iterContacts = group.contacts();\r\n        while (iterContacts.hasNext()) {\r\n            ContactJabberImpl contact = (ContactJabberImpl) iterContacts.next();\r\n            if (!contact.isResolved()) {\r\n                contactsToRemove.add(contact);\r\n            }\r\n        }\r\n        for (ContactJabberImpl contact : contactsToRemove) {\r\n            group.removeContact(contact);\r\n            fireContactRemoved(group, contact);\r\n        }\r\n        contactsToRemove.clear();\r\n    }\r\n    for (ContactGroupJabberImpl group : groupsToRemove) {\r\n        rootGroup.removeSubGroup(group);\r\n        fireGroupEvent(group, ServerStoredGroupEvent.GROUP_REMOVED_EVENT);\r\n    }\r\n    for (RosterGroup item : roster.getGroups()) {\r\n        ContactGroupJabberImpl group = findContactGroup(item.getName());\r\n        if (group == null) {\r\n            ContactGroupJabberImpl newGroup = new ContactGroupJabberImpl(item, item.getEntries().iterator(), this, true);\r\n            rootGroup.addSubGroup(newGroup);\r\n            fireGroupEvent(newGroup, ServerStoredGroupEvent.GROUP_CREATED_EVENT);\r\n            if (roster != null) {\r\n                Iterator<Contact> cIter = newGroup.contacts();\r\n                while (cIter.hasNext()) {\r\n                    String address = cIter.next().getAddress();\r\n                    parentOperationSet.firePresenceStatusChanged(roster.getPresence(address));\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.github.ltsopensource.core.commons.concurrent.limiter.Stopwatch.toString",
	"Comment": "returns a string representation of the current elapsed time.",
	"Method": "String toString(){\r\n    long nanos = elapsedNanos();\r\n    TimeUnit unit = chooseUnit(nanos);\r\n    double value = (double) nanos / NANOSECONDS.convert(1, unit);\r\n    return String.format(Locale.ROOT, \"%.4g %s\", value, abbreviate(unit));\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.jabber.JabberAccountRegistration.addStunServer",
	"Comment": "adds the given stunserver to the list of additional stun servers.",
	"Method": "void addStunServer(StunServerDescriptor stunServer){\r\n    additionalStunServers.add(stunServer);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.JabberAccountRegistrationForm.setServerFieldAccordingToUIN",
	"Comment": "parse the server part from the jabber id and set it to server as defaultvalue. if advanced option is enabled do nothing.",
	"Method": "void setServerFieldAccordingToUIN(String userName){\r\n    if (!wizard.isModification() && !wizard.getRegistration().isServerOverridden()) {\r\n        connectionPanel.setServerAddress(getServerFromUserName(userName));\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chatroomslist.joinforms.JoinChatRoomWizardPage1.pageShowing",
	"Comment": "before the panel is displayed checks the selections and enables thenext button if a check box is already selected or disables it ifnothing is selected.",
	"Method": "void pageShowing(){\r\n    setNextButtonAccordingToRowSelection();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.globaldisplaydetails.GlobalDisplayDetailsActivator.getConfigurationService",
	"Comment": "returns the configurationservice obtained from the bundlecontext.",
	"Method": "ConfigurationService getConfigurationService(){\r\n    if (configService == null) {\r\n        configService = ServiceUtils.getService(bundleContext, ConfigurationService.class);\r\n    }\r\n    return configService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.AccountStatusPanel.globalDisplayNameChanged",
	"Comment": "called whenever a new avatar is defined for one of the protocols that wehave subscribed for.",
	"Method": "void globalDisplayNameChanged(GlobalDisplayNameChangeEvent event){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                globalDisplayNameChanged(event);\r\n                return;\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    String displayName = event.getNewDisplayName();\r\n    if (!StringUtils.isNullOrEmpty(displayName))\r\n        accountNameLabel.setText(displayName);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.AccountStatusPanel.globalDisplayNameChanged",
	"Comment": "called whenever a new avatar is defined for one of the protocols that wehave subscribed for.",
	"Method": "void globalDisplayNameChanged(GlobalDisplayNameChangeEvent event){\r\n    globalDisplayNameChanged(event);\r\n    return;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.UIServiceImpl.removePluginComponentListener",
	"Comment": "removes the given plugincomponentlistener from the list ofcomponent listeners registered in this uiservice implementation.",
	"Method": "void removePluginComponentListener(PluginComponentListener listener){\r\n    synchronized (pluginComponentListeners) {\r\n        Iterator<WeakReference<PluginComponentListener>> i = pluginComponentListeners.iterator();\r\n        while (i.hasNext()) {\r\n            PluginComponentListener l = i.next().get();\r\n            if ((l == null) || l.equals(listener))\r\n                i.remove();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.AdHocConferenceChatTransport.sendTypingNotification",
	"Comment": "sending typing notifications is not supported by this chat transportimplementation.",
	"Method": "int sendTypingNotification(int typingState){\r\n    return 0;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.msoutlook.calendar.CalendarServiceImpl.updateStateFromCurrentItems",
	"Comment": "calculates and changes the value of current status using the currentactive calendar items and their statuses.",
	"Method": "void updateStateFromCurrentItems(){\r\n    BusyStatusEnum tmpState = BusyStatusEnum.FREE;\r\n    synchronized (currentCalendarItems) {\r\n        for (CalendarItemTimerTask task : currentCalendarItems) {\r\n            if (tmpState.getPriority() < task.getStatus().getPriority()) {\r\n                tmpState = task.getStatus();\r\n            }\r\n        }\r\n    }\r\n    setCurrentState(tmpState);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetBasicInstantMessagingJabberImpl.createMessageWithUID",
	"Comment": "create a message instance with the specified uid, content typeand a default encoding.this method can be useful when message correction is required. one canconstruct the corrected message to have the same uid as the messagebefore correction.",
	"Method": "Message createMessageWithUID(String messageText,String contentType,String messageUID){\r\n    return new MessageJabberImpl(messageText, contentType, DEFAULT_MIME_ENCODING, null, messageUID);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.notifsource.NotificationGroup.messageWaitingNotify",
	"Comment": "creates all necessary notification contacts coming from the givenmessagewaitingevent.",
	"Method": "void messageWaitingNotify(MessageWaitingEvent event){\r\n    Iterator<NotificationMessage> messages = event.getMessages();\r\n    if (messages != null) {\r\n        Enumeration<String> contactIdentifiers = contacts.keys();\r\n        while (contactIdentifiers.hasMoreElements()) {\r\n            String identifier = contactIdentifiers.nextElement();\r\n            boolean toRemove = true;\r\n            messages = event.getMessages();\r\n            while (messages.hasNext()) {\r\n                NotificationMessage message = messages.next();\r\n                String messageIdentifier = message.getFromContact() + message.getMessageDetails();\r\n                if (identifier.equals(messageIdentifier)) {\r\n                    toRemove = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (toRemove) {\r\n                removeNotificationContact(contacts.get(identifier));\r\n                contacts.remove(identifier);\r\n            }\r\n        }\r\n        messages = event.getMessages();\r\n        while (messages.hasNext()) {\r\n            NotificationMessage message = messages.next();\r\n            if (message.getMessageGroup().equals(groupName)) {\r\n                String messageIdentifier = message.getFromContact() + message.getMessageDetails();\r\n                NotificationContact contact = contacts.get(messageIdentifier);\r\n                boolean isNew = false;\r\n                if (contact == null) {\r\n                    contact = new NotificationContact(this, event.getSourceProvider(), event.getMessageType(), message);\r\n                    contacts.put(messageIdentifier, contact);\r\n                    isNew = true;\r\n                }\r\n                contact.setMessageAccount(event.getAccount());\r\n                addNotificationContact(contact, isNew);\r\n            }\r\n        }\r\n    } else {\r\n        ProtocolProviderService protocolProvider = event.getSourceProvider();\r\n        NotificationContact contact = contacts.get(protocolProvider.toString());\r\n        boolean isNew = false;\r\n        if (contact == null) {\r\n            contact = new NotificationContact(this, protocolProvider, event.getMessageType(), null);\r\n            contacts.put(protocolProvider.toString(), contact);\r\n            isNew = true;\r\n        }\r\n        contact.setMessageAccount(event.getAccount());\r\n        contact.setUnreadUrgentMessageCount(event.getUnreadUrgentMessages());\r\n        contact.setUnreadMessageCount(event.getUnreadMessages());\r\n        contact.setReadMessageCount(event.getReadMessages());\r\n        addNotificationContact(contact, isNew);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.sipaccregwizz.SIPAccRegWizzActivator.getSIPProtocolProviderFactory",
	"Comment": "returns the protocolproviderfactory for the sip protocol.",
	"Method": "ProtocolProviderFactory getSIPProtocolProviderFactory(){\r\n    ServiceReference[] serRefs = null;\r\n    String osgiFilter = \"(\" + ProtocolProviderFactory.PROTOCOL + \"=\" + ProtocolNames.SIP + \")\";\r\n    try {\r\n        serRefs = bundleContext.getServiceReferences(ProtocolProviderFactory.class.getName(), osgiFilter);\r\n    } catch (InvalidSyntaxException ex) {\r\n        logger.error(\"SIPAccRegWizzActivator : \" + ex);\r\n        return null;\r\n    }\r\n    return (serRefs == null) ? null : (ProtocolProviderFactory) bundleContext.getService(serRefs[0]);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWindowManager.createChat",
	"Comment": "creates a chatpanel for the given adhocchatroom andsaves it in the list of created chatpanels.",
	"Method": "ChatPanel createChat(MetaContact metaContact,Contact protocolContact,ContactResource contactResource,String escapedMessageID,ChatPanel createChat,ChatRoomWrapper chatRoomWrapper,ChatPanel createChat,AdHocChatRoomWrapper chatRoomWrapper,ChatPanel createChat,ChatRoomWrapper chatRoomWrapper,String escapedMessageID,ChatPanel createChat,AdHocChatRoomWrapper chatRoomWrapper,String escapedMessageID){\r\n    ChatContainer chatContainer = getChatContainer();\r\n    ChatPanel chatPanel = new ChatPanel(chatContainer);\r\n    AdHocConferenceChatSession chatSession = new AdHocConferenceChatSession(chatPanel, chatRoomWrapper);\r\n    chatPanel.setChatSession(chatSession);\r\n    synchronized (chatPanels) {\r\n        this.chatPanels.add(chatPanel);\r\n    }\r\n    chatPanel.loadHistory(escapedMessageID);\r\n    fireChatCreated(chatPanel);\r\n    return chatPanel;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetPersistentPresenceIcqImpl.removeServerStoredContactGroup",
	"Comment": "removes the specified group from the server stored contact list.",
	"Method": "void removeServerStoredContactGroup(ContactGroup group){\r\n    assertConnected();\r\n    if (!(group instanceof ContactGroupIcqImpl))\r\n        throw new IllegalArgumentException(\"The specified group is not an icq contact group: \" + group);\r\n    ssContactList.removeGroup((ContactGroupIcqImpl) group);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.sdp.SdpUtils.findPayloadTypeSpecificAttribute",
	"Comment": "tries to find an attribute with the specified attibutenamepertaining to the specified payloadtype in themediaattributes list and returns it if it exists.",
	"Method": "Attribute findPayloadTypeSpecificAttribute(Vector<Attribute> mediaAttributes,String attributeName,String payloadType){\r\n    if (mediaAttributes == null || mediaAttributes.size() == 0)\r\n        return null;\r\n    for (Attribute attr : mediaAttributes) {\r\n        if (!attributeName.equals(attr.getName()))\r\n            continue;\r\n        String attrValue = attr.getValue();\r\n        if (attrValue == null)\r\n            continue;\r\n        attrValue = attrValue.trim();\r\n        if (!attrValue.startsWith(payloadType + \" \"))\r\n            continue;\r\n        return attr;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.menus.FileMenu.actionPerformed",
	"Comment": "handles the actionevent when one of the menu items is selected.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    JMenuItem menuItem = (JMenuItem) e.getSource();\r\n    String itemName = menuItem.getName();\r\n    if (itemName.equals(\"newAccount\")) {\r\n        NewAccountDialog.showNewAccountDialog();\r\n    } else if (itemName.equals(\"addContact\")) {\r\n        AddContactDialog dialog = new AddContactDialog(parentWindow);\r\n        dialog.setVisible(true);\r\n    } else if (itemName.equals(\"createGroup\")) {\r\n        CreateGroupDialog dialog = new CreateGroupDialog(parentWindow);\r\n        dialog.setVisible(true);\r\n    } else if (itemName.equals(\"close\")) {\r\n        closeActionPerformed();\r\n    } else if (itemName.equals(\"myChatRooms\")) {\r\n        ChatRoomTableDialog.showChatRoomTableDialog();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.OperationSetPersistentPresenceGibberishImpl.getNonPersistentGroup",
	"Comment": "returns the volatile group or null if this group has not yet beencreated.",
	"Method": "ContactGroupGibberishImpl getNonPersistentGroup(){\r\n    for (int i = 0; i < getServerStoredContactListRoot().countSubgroups(); i++) {\r\n        ContactGroupGibberishImpl gr = (ContactGroupGibberishImpl) getServerStoredContactListRoot().getGroup(i);\r\n        if (!gr.isPersistent())\r\n            return gr;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageHistoryServiceImpl.hasMessages",
	"Comment": "checks whether this historyid contains messages of certain type.",
	"Method": "boolean hasMessages(HistoryID historyID,String[] keywords,String field,boolean caseSensitive){\r\n    if (!this.historyService.isHistoryCreated(historyID))\r\n        return false;\r\n    History history = this.historyService.createHistory(historyID, recordStructure);\r\n    return history.getReader().findLast(1, keywords, field, caseSensitive).hasNext();\r\n}"
}, {
	"Path": "net.librec.data.splitter.LOOCVDataSplitter.getLOOByUser",
	"Comment": "split ratings into two parts where one rating per user is preserved asthe test set and the remaining data as the training set.",
	"Method": "void getLOOByUser(){\r\n    trainMatrix = new SequentialAccessSparseMatrix(preferenceMatrix);\r\n    Table<Integer, Integer, Double> dataTable = HashBasedTable.create();\r\n    for (int rowIndex = 0, rowSize = preferenceMatrix.rowSize(); rowIndex < rowSize; rowIndex++) {\r\n        int numColumnEntries = preferenceMatrix.row(rowIndex).getNumEntries();\r\n        if (numColumnEntries == 0) {\r\n            continue;\r\n        }\r\n        int randomRowPosition = (int) (numColumnEntries * Randoms.uniform());\r\n        this.preferenceMatrix = dataConvertor.getPreferenceMatrix();\r\n        trainMatrix.setAtColumnPosition(rowIndex, randomRowPosition, 0.0D);\r\n        dataTable.put(rowIndex, preferenceMatrix.row(rowIndex).getIndexAtPosition(randomRowPosition), preferenceMatrix.getAtColumnPosition(rowIndex, randomRowPosition));\r\n    }\r\n    trainMatrix.reshape();\r\n    testMatrix = new SequentialAccessSparseMatrix(preferenceMatrix.rowSize(), preferenceMatrix.columnSize(), dataTable);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.InfoRetreiver.readWorkUserInfo",
	"Comment": "method for parsing incoming dataread data in workuserinfo command",
	"Method": "void readWorkUserInfo(MetaWorkInfoCmd cmd){\r\n    List<GenericDetail> infoData = getInfoForRequest(cmd.getId());\r\n    String tmp = null;\r\n    if ((tmp = cmd.getWorkCity()) != null)\r\n        infoData.add(new ServerStoredDetails.WorkCityDetail(tmp));\r\n    if ((tmp = cmd.getWorkState()) != null)\r\n        infoData.add(new ServerStoredDetails.WorkProvinceDetail(tmp));\r\n    if ((tmp = cmd.getWorkPhone()) != null)\r\n        infoData.add(new ServerStoredDetails.WorkPhoneDetail(tmp));\r\n    if ((tmp = cmd.getWorkFax()) != null)\r\n        infoData.add(new OperationSetServerStoredAccountInfoIcqImpl.WorkFaxDetail(tmp));\r\n    if ((tmp = cmd.getWorkAddress()) != null)\r\n        infoData.add(new ServerStoredDetails.WorkAddressDetail(tmp));\r\n    if ((tmp = cmd.getWorkZipCode()) != null)\r\n        infoData.add(new ServerStoredDetails.WorkPostalCodeDetail(tmp));\r\n    Locale workCountry = OperationSetServerStoredAccountInfoIcqImpl.getCountry(cmd.getWorkCountryCode());\r\n    if (workCountry != null)\r\n        infoData.add(new ServerStoredDetails.WorkCountryDetail(workCountry));\r\n    if ((tmp = cmd.getWorkCompany()) != null)\r\n        infoData.add(new ServerStoredDetails.WorkOrganizationNameDetail(tmp));\r\n    if ((tmp = cmd.getWorkDepartment()) != null)\r\n        infoData.add(new OperationSetServerStoredAccountInfoIcqImpl.WorkDepartmentNameDetail(tmp));\r\n    if ((tmp = cmd.getWorkPosition()) != null)\r\n        infoData.add(new OperationSetServerStoredAccountInfoIcqImpl.WorkPositionNameDetail(tmp));\r\n    int workOccupationCode = cmd.getWorkOccupationCode();\r\n    if (workOccupationCode == 99)\r\n        infoData.add(new OperationSetServerStoredAccountInfoIcqImpl.WorkOcupationDetail(OperationSetServerStoredAccountInfoIcqImpl.occupations[OperationSetServerStoredAccountInfoIcqImpl.occupations.length - 1]));\r\n    else\r\n        infoData.add(new OperationSetServerStoredAccountInfoIcqImpl.WorkOcupationDetail(OperationSetServerStoredAccountInfoIcqImpl.occupations[workOccupationCode]));\r\n    try {\r\n        if ((tmp = cmd.getWorkWebPage()) != null)\r\n            infoData.add(new ServerStoredDetails.WorkPageDetail(new URL(tmp)));\r\n    } catch (MalformedURLException ex) {\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AccountInfoUtils.getBirthDate",
	"Comment": "returns the birth date of the account, to which the givenaccountinfoopset belongs.",
	"Method": "Calendar getBirthDate(OperationSetServerStoredAccountInfo accountInfoOpSet){\r\n    BirthDateDetail date = null;\r\n    Iterator<GenericDetail> dateDetails = accountInfoOpSet.getDetails(BirthDateDetail.class);\r\n    if (dateDetails.hasNext())\r\n        date = (BirthDateDetail) dateDetails.next();\r\n    if (date == null)\r\n        return null;\r\n    return date.getCalendar();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.reconnectplugin.ReconnectPluginActivator.configurationChanged",
	"Comment": "fired when a change has occurred in the computer network configuration.",
	"Method": "void configurationChanged(ChangeEvent event){\r\n    if (event.getType() == ChangeEvent.IFACE_UP) {\r\n        if (connectedInterfaces.isEmpty()) {\r\n            onNetworkUp();\r\n            Iterator<ProtocolProviderService> iter = needsReconnection.iterator();\r\n            while (iter.hasNext()) {\r\n                ProtocolProviderService pp = iter.next();\r\n                if (currentlyReconnecting.containsKey(pp)) {\r\n                    currentlyReconnecting.remove(pp).cancel();\r\n                }\r\n                reconnect(pp);\r\n            }\r\n            needsReconnection.clear();\r\n        }\r\n        connectedInterfaces.add((String) event.getSource());\r\n    } else if (event.getType() == ChangeEvent.IFACE_DOWN) {\r\n        String ifaceName = (String) event.getSource();\r\n        connectedInterfaces.remove(ifaceName);\r\n        if (connectedInterfaces.size() > 0) {\r\n            Iterator<Map.Entry<ProtocolProviderService, List<String>>> iter = autoReconnEnabledProviders.entrySet().iterator();\r\n            while (iter.hasNext()) {\r\n                Map.Entry<ProtocolProviderService, List<String>> entry = iter.next();\r\n                if (entry.getValue().contains(ifaceName)) {\r\n                    ProtocolProviderService pp = entry.getKey();\r\n                    if (currentlyReconnecting.containsKey(pp)) {\r\n                        currentlyReconnecting.remove(pp).cancel();\r\n                    }\r\n                    reconnect(pp);\r\n                }\r\n            }\r\n        } else {\r\n            needsReconnection.addAll(autoReconnEnabledProviders.keySet());\r\n            needsReconnection.addAll(currentlyReconnecting.keySet());\r\n            Iterator<ProtocolProviderService> iter = needsReconnection.iterator();\r\n            while (iter.hasNext()) {\r\n                ProtocolProviderService pp = iter.next();\r\n                if (currentlyReconnecting.containsKey(pp)) {\r\n                    currentlyReconnecting.remove(pp).cancel();\r\n                }\r\n                unregister(pp, false, null, null);\r\n            }\r\n            connectedInterfaces.clear();\r\n            onNetworkDown();\r\n        }\r\n    }\r\n    if (logger.isTraceEnabled()) {\r\n        logger.trace(\"Event received \" + event + \" src=\" + event.getSource());\r\n        traceCurrentPPState();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.iptelaccregwizz.IptelAccRegWizzActivator.getIptelProtocolProviderFactory",
	"Comment": "returns the protocolproviderfactory for the ip tel protocol.",
	"Method": "ProtocolProviderFactory getIptelProtocolProviderFactory(){\r\n    ServiceReference[] serRefs = null;\r\n    String osgiFilter = \"(\" + ProtocolProviderFactory.PROTOCOL + \"=\" + ProtocolNames.SIP + \")\";\r\n    try {\r\n        serRefs = bundleContext.getServiceReferences(ProtocolProviderFactory.class.getName(), osgiFilter);\r\n    } catch (InvalidSyntaxException ex) {\r\n        logger.error(\"IptelAccRegWizzActivator : \" + ex);\r\n    }\r\n    return (ProtocolProviderFactory) bundleContext.getService(serRefs[0]);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.TestOperationSetPresence.testQueryContactStatus",
	"Comment": "verifies that querying status works fine. the icq tester agent wouldchange status and the operation set would have to return the right statusafter every change.",
	"Method": "void testQueryContactStatus(){\r\n    logger.debug(\"Will Query an AWAY contact.\");\r\n    subtestQueryContactStatus(FullUserInfo.ICQSTATUS_AWAY, IcqStatusEnum.AWAY);\r\n    pauseBetweenStateChanges();\r\n    logger.debug(\"Will Query an NA contact.\");\r\n    subtestQueryContactStatus(FullUserInfo.ICQSTATUS_NA, IcqStatusEnum.NOT_AVAILABLE);\r\n    pauseBetweenStateChanges();\r\n    logger.debug(\"Will Query a DND contact.\");\r\n    subtestQueryContactStatus(FullUserInfo.ICQSTATUS_DND, IcqStatusEnum.DO_NOT_DISTURB);\r\n    pauseBetweenStateChanges();\r\n    logger.debug(\"Will Query a Free For Chat contact.\");\r\n    subtestQueryContactStatus(FullUserInfo.ICQSTATUS_FFC, IcqStatusEnum.FREE_FOR_CHAT);\r\n    pauseBetweenStateChanges();\r\n    logger.debug(\"Will Query an Invisible contact.\");\r\n    subtestQueryContactStatus(FullUserInfo.ICQSTATUS_INVISIBLE, IcqStatusEnum.INVISIBLE);\r\n    pauseBetweenStateChanges();\r\n    logger.debug(\"Will Query an Occupied contact.\");\r\n    subtestQueryContactStatus(FullUserInfo.ICQSTATUS_OCCUPIED, IcqStatusEnum.OCCUPIED);\r\n    pauseBetweenStateChanges();\r\n    logger.debug(\"Will Query an Online contact.\");\r\n    subtestQueryContactStatus(IcqTesterAgent.ICQ_ONLINE_MASK, IcqStatusEnum.ONLINE);\r\n    pauseBetweenStateChanges();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.presence.avatar.AvatarStackManager.popFirstImage",
	"Comment": "removes the oldest image and as its with lower index.moves all indexes. ant this way we free one index.",
	"Method": "void popFirstImage(int nbImages){\r\n    for (int i = nbImages - 1; i > 0; i--) moveImage(i, i - 1);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.msoutlook.RegistryHandler.unsetDefaultApp",
	"Comment": "unsets jitsi as default im application. overrides the registry valuewith setting communicator as default im application.",
	"Method": "void unsetDefaultApp(){\r\n    if (isDefaultIMApp(getApplicationName()))\r\n        setDefaultIMApp(REGISTRY_DEFAULT_IM_APPLICATION_COMMUNICATOR);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.googlecontacts.configform.GoogleContactsTableModel.getColumnClass",
	"Comment": "overrides a method that always returned object.classnow it will return boolean.class for the first method,letting the defaulttablecellrenderer create checkboxes.",
	"Method": "Class<?> getColumnClass(int columnIndex){\r\n    return getValueAt(0, columnIndex).getClass();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomJabberImpl.setMembersWhiteList",
	"Comment": "changes the list of users that has role member for this room.when the room is member only, this are the users allowed to join.",
	"Method": "void setMembersWhiteList(List<String> members){\r\n    try {\r\n        List<String> membersToRemove = getMembersWhiteList();\r\n        membersToRemove.removeAll(members);\r\n        if (membersToRemove.size() > 0)\r\n            multiUserChat.revokeMembership(membersToRemove);\r\n        if (members.size() > 0)\r\n            multiUserChat.grantMembership(members);\r\n    } catch (XMPPException e) {\r\n        logger.error(\"Cannot modify members list\", e);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockOperationSetFileTransfer.removeFileTransferListener",
	"Comment": "removes the given filetransferlistener that listens forfile transfer requests and created file transfers.",
	"Method": "void removeFileTransferListener(FileTransferListener listener){\r\n    synchronized (fileTransferListeners) {\r\n        this.fileTransferListeners.remove(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ServerStoredContactListIcqImpl.moveContact",
	"Comment": "moves the specified contact to the group indicated bynewparent.",
	"Method": "void moveContact(ContactIcqImpl contact,ContactGroupIcqImpl newParent){\r\n    if (contact.isPersistent()) {\r\n        List<Buddy> contactsToMove = new ArrayList<Buddy>();\r\n        contactsToMove.add(contact.getJoustSimBuddy());\r\n        buddyList.moveBuddies(contactsToMove, newParent.getJoustSimSourceGroup());\r\n    } else {\r\n        addContact(newParent, contact.getUIN());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.GuiActivator.getGlobalDisplayDetailsService",
	"Comment": "returns the globaldisplaydetailsservice obtained from the bundlecontext.",
	"Method": "GlobalDisplayDetailsService getGlobalDisplayDetailsService(){\r\n    if (globalDisplayDetailsService == null) {\r\n        globalDisplayDetailsService = ServiceUtils.getService(bundleContext, GlobalDisplayDetailsService.class);\r\n    }\r\n    return globalDisplayDetailsService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.sipaccregwizz.SIPAccountRegistrationWizard.getPageImage",
	"Comment": "implements the accountregistrationwizard.getpageimage method.returns the image used to decorate the wizard page",
	"Method": "byte[] getPageImage(){\r\n    return Resources.getImage(Resources.PAGE_IMAGE);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AccountID.getAccountUniqueID",
	"Comment": "returns a string uniquely identifying this account, guaranteed to remainthe same across multiple installations of the same account and to alwaysbe unique for differing accounts.",
	"Method": "String getAccountUniqueID(){\r\n    return accountUID;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.Utils.parseForegroundColor",
	"Comment": "parse foreground color and return corresponding color instance.",
	"Method": "Color parseForegroundColor(String text){\r\n    try {\r\n        int color = Integer.parseInt(\"\" + text.charAt(0) + text.charAt(1));\r\n        color = color % Color.values().length;\r\n        return Color.values()[color];\r\n    } catch (StringIndexOutOfBoundsException e) {\r\n        LOGGER.trace(\"ArrayIndexOutOfBounds during foreground \" + \"color control code parsing.\");\r\n        return null;\r\n    } catch (NumberFormatException e) {\r\n        LOGGER.trace(\"Invalid foreground color code encountered.\", e);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.simpleaccreg.SimpleAccountRegistrationActivator.hasRegisteredAccounts",
	"Comment": "returns all protocolproviderfactorys obtained from the bundlecontext.",
	"Method": "boolean hasRegisteredAccounts(){\r\n    ServiceReference[] serRefs = null;\r\n    try {\r\n        serRefs = bundleContext.getServiceReferences(ProtocolProviderFactory.class.getName(), null);\r\n    } catch (InvalidSyntaxException e) {\r\n        logger.error(\"Unable to obtain service references. \" + e);\r\n    }\r\n    boolean hasRegisteredAccounts = false;\r\n    if (serRefs != null) {\r\n        for (ServiceReference serRef : serRefs) {\r\n            ProtocolProviderFactory providerFactory = (ProtocolProviderFactory) bundleContext.getService(serRef);\r\n            for (Iterator<AccountID> registeredAccountIter = providerFactory.getRegisteredAccounts().iterator(); registeredAccountIter.hasNext(); ) {\r\n                AccountID accountID = registeredAccountIter.next();\r\n                if (!accountID.isHidden()) {\r\n                    hasRegisteredAccounts = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (hasRegisteredAccounts)\r\n                break;\r\n        }\r\n    }\r\n    return hasRegisteredAccounts;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ProtocolProviderServiceJabberImpl.initialize",
	"Comment": "initialized the service implementation, and puts it in a sate where itcould interoperate with other services. it is strongly recommended thatproperties in this map be mapped to property names as specified byaccountproperties.",
	"Method": "void initialize(String screenname,JabberAccountID accountID){\r\n    synchronized (initializationLock) {\r\n        this.accountID = accountID;\r\n        supportedFeatures.clear();\r\n        this.clearRegistrationStateChangeListener();\r\n        this.clearSupportedOperationSet();\r\n        String protocolIconPath = accountID.getAccountPropertyString(ProtocolProviderFactory.PROTOCOL_ICON_PATH);\r\n        if (protocolIconPath == null)\r\n            protocolIconPath = \"resources/images/protocol/jabber\";\r\n        jabberIcon = new ProtocolIconJabberImpl(protocolIconPath);\r\n        jabberStatusEnum = JabberStatusEnum.getJabberStatusEnum(protocolIconPath);\r\n        supportedFeatures.add(\"http://jabber.org/protocol/disco#info\");\r\n        String keepAliveStrValue = accountID.getAccountPropertyString(ProtocolProviderFactory.KEEP_ALIVE_METHOD);\r\n        InfoRetreiver infoRetreiver = new InfoRetreiver(this, screenname);\r\n        OperationSetPersistentPresenceJabberImpl persistentPresence = new OperationSetPersistentPresenceJabberImpl(this, infoRetreiver);\r\n        addSupportedOperationSet(OperationSetPersistentPresence.class, persistentPresence);\r\n        addSupportedOperationSet(OperationSetPresence.class, persistentPresence);\r\n        if (accountID.getAccountPropertyString(ProtocolProviderFactory.ACCOUNT_READ_ONLY_GROUPS) != null) {\r\n            addSupportedOperationSet(OperationSetPersistentPresencePermissions.class, new OperationSetPersistentPresencePermissionsJabberImpl(this));\r\n        }\r\n        OperationSetBasicInstantMessagingJabberImpl basicInstantMessaging = new OperationSetBasicInstantMessagingJabberImpl(this);\r\n        if (keepAliveStrValue == null || keepAliveStrValue.equalsIgnoreCase(\"XEP-0199\")) {\r\n            if (keepAliveManager == null)\r\n                keepAliveManager = new KeepAliveManager(this);\r\n        }\r\n        addSupportedOperationSet(OperationSetBasicInstantMessaging.class, basicInstantMessaging);\r\n        addSupportedOperationSet(OperationSetExtendedAuthorizations.class, new OperationSetExtendedAuthorizationsJabberImpl(this, persistentPresence));\r\n        addSupportedOperationSet(OperationSetWhiteboarding.class, new OperationSetWhiteboardingJabberImpl(this));\r\n        addSupportedOperationSet(OperationSetTypingNotifications.class, new OperationSetTypingNotificationsJabberImpl(this));\r\n        addSupportedOperationSet(OperationSetMultiUserChat.class, new OperationSetMultiUserChatJabberImpl(this));\r\n        addSupportedOperationSet(OperationSetJitsiMeetTools.class, new OperationSetJitsiMeetToolsJabberImpl(this));\r\n        addSupportedOperationSet(OperationSetServerStoredContactInfo.class, new OperationSetServerStoredContactInfoJabberImpl(infoRetreiver));\r\n        OperationSetServerStoredAccountInfo accountInfo = new OperationSetServerStoredAccountInfoJabberImpl(this, infoRetreiver, screenname);\r\n        addSupportedOperationSet(OperationSetServerStoredAccountInfo.class, accountInfo);\r\n        addSupportedOperationSet(OperationSetAvatar.class, new OperationSetAvatarJabberImpl(this, accountInfo));\r\n        addSupportedOperationSet(OperationSetFileTransfer.class, new OperationSetFileTransferJabberImpl(this));\r\n        addSupportedOperationSet(OperationSetInstantMessageTransform.class, new OperationSetInstantMessageTransformImpl());\r\n        supportedFeatures.add(\"urn:xmpp:thumbs:0\");\r\n        supportedFeatures.add(\"urn:xmpp:bob\");\r\n        addSupportedOperationSet(OperationSetThumbnailedFileFactory.class, new OperationSetThumbnailedFileFactoryImpl());\r\n        supportedFeatures.add(\"http://jabber.org/protocol/muc#rooms\");\r\n        supportedFeatures.add(\"http://jabber.org/protocol/muc#traffic\");\r\n        supportedFeatures.add(URN_XMPP_JINGLE_RTP_HDREXT);\r\n        ProviderManager providerManager = ProtocolProviderFactoryJabberImpl.providerManager;\r\n        providerManager.addIQProvider(JingleIQ.ELEMENT_NAME, JingleIQ.NAMESPACE, new JingleIQProvider());\r\n        providerManager.addIQProvider(InputEvtIQ.ELEMENT_NAME, InputEvtIQ.NAMESPACE, new InputEvtIQProvider());\r\n        providerManager.addIQProvider(CoinIQ.ELEMENT_NAME, CoinIQ.NAMESPACE, new CoinIQProvider());\r\n        supportedFeatures.add(URN_XMPP_JINGLE_COIN);\r\n        providerManager.addIQProvider(JingleInfoQueryIQ.ELEMENT_NAME, JingleInfoQueryIQ.NAMESPACE, new JingleInfoQueryIQProvider());\r\n        providerManager.addIQProvider(ColibriConferenceIQ.ELEMENT_NAME, ColibriConferenceIQ.NAMESPACE, new ColibriIQProvider());\r\n        providerManager.addIQProvider(JibriIq.ELEMENT_NAME, JibriIq.NAMESPACE, new JibriIqProvider());\r\n        providerManager.addExtensionProvider(ConferenceDescriptionPacketExtension.ELEMENT_NAME, ConferenceDescriptionPacketExtension.NAMESPACE, new ConferenceDescriptionPacketExtension.Provider());\r\n        providerManager.addExtensionProvider(CarbonPacketExtension.RECEIVED_ELEMENT_NAME, CarbonPacketExtension.NAMESPACE, new CarbonPacketExtension.Provider(CarbonPacketExtension.RECEIVED_ELEMENT_NAME));\r\n        providerManager.addExtensionProvider(CarbonPacketExtension.SENT_ELEMENT_NAME, CarbonPacketExtension.NAMESPACE, new CarbonPacketExtension.Provider(CarbonPacketExtension.SENT_ELEMENT_NAME));\r\n        providerManager.addExtensionProvider(Nick.ELEMENT_NAME, Nick.NAMESPACE, new Nick.Provider());\r\n        providerManager.addExtensionProvider(Email.ELEMENT_NAME, Email.NAMESPACE, new Email.Provider());\r\n        providerManager.addExtensionProvider(AvatarUrl.ELEMENT_NAME, AvatarUrl.NAMESPACE, new AvatarUrl.Provider());\r\n        boolean isCallingDisabled = JabberActivator.getConfigurationService().getBoolean(IS_CALLING_DISABLED, false);\r\n        boolean isCallingDisabledForAccount = accountID.getAccountPropertyBoolean(ProtocolProviderFactory.IS_CALLING_DISABLED_FOR_ACCOUNT, false);\r\n        if (!isCallingDisabled && !isCallingDisabledForAccount) {\r\n            OperationSetBasicTelephonyJabberImpl basicTelephony = new OperationSetBasicTelephonyJabberImpl(this);\r\n            addSupportedOperationSet(OperationSetAdvancedTelephony.class, basicTelephony);\r\n            addSupportedOperationSet(OperationSetBasicTelephony.class, basicTelephony);\r\n            addSupportedOperationSet(OperationSetSecureZrtpTelephony.class, basicTelephony);\r\n            addSupportedOperationSet(OperationSetSecureSDesTelephony.class, basicTelephony);\r\n            addSupportedOperationSet(OperationSetTelephonyConferencing.class, new OperationSetTelephonyConferencingJabberImpl(this));\r\n            addSupportedOperationSet(OperationSetBasicAutoAnswer.class, new OperationSetAutoAnswerJabberImpl(this));\r\n            addSupportedOperationSet(OperationSetResourceAwareTelephony.class, new OperationSetResAwareTelephonyJabberImpl(basicTelephony));\r\n            boolean isVideobridgeDisabled = JabberActivator.getConfigurationService().getBoolean(OperationSetVideoBridge.IS_VIDEO_BRIDGE_DISABLED, false);\r\n            if (!isVideobridgeDisabled) {\r\n                addSupportedOperationSet(OperationSetVideoBridge.class, new OperationSetVideoBridgeImpl(this));\r\n            }\r\n            OperationSetDTMFJabberImpl operationSetDTMF = new OperationSetDTMFJabberImpl(this);\r\n            addSupportedOperationSet(OperationSetDTMF.class, operationSetDTMF);\r\n            addSupportedOperationSet(OperationSetIncomingDTMF.class, new OperationSetIncomingDTMFJabberImpl());\r\n            addJingleFeatures();\r\n            boolean isVideoCallingDisabledForAccount = accountID.getAccountPropertyBoolean(ProtocolProviderFactory.IS_VIDEO_CALLING_DISABLED_FOR_ACCOUNT, false);\r\n            if (!isVideoCallingDisabledForAccount) {\r\n                supportedFeatures.add(URN_XMPP_JINGLE_RTP_VIDEO);\r\n                addSupportedOperationSet(OperationSetVideoTelephony.class, new OperationSetVideoTelephonyJabberImpl(basicTelephony));\r\n                boolean isDesktopStreamingDisabled = JabberActivator.getConfigurationService().getBoolean(IS_DESKTOP_STREAMING_DISABLED, false);\r\n                boolean isAccountDesktopStreamingDisabled = accountID.getAccountPropertyBoolean(ProtocolProviderFactory.IS_DESKTOP_STREAMING_DISABLED, false);\r\n                if (!isDesktopStreamingDisabled && !isAccountDesktopStreamingDisabled) {\r\n                    addSupportedOperationSet(OperationSetDesktopStreaming.class, new OperationSetDesktopStreamingJabberImpl(basicTelephony));\r\n                    if (!accountID.getAccountPropertyBoolean(ProtocolProviderFactory.IS_DESKTOP_REMOTE_CONTROL_DISABLED, false)) {\r\n                        addSupportedOperationSet(OperationSetDesktopSharingServer.class, new OperationSetDesktopSharingServerJabberImpl(basicTelephony));\r\n                        supportedFeatures.add(InputEvtIQ.NAMESPACE_SERVER);\r\n                        addSupportedOperationSet(OperationSetDesktopSharingClient.class, new OperationSetDesktopSharingClientJabberImpl(this));\r\n                        supportedFeatures.add(InputEvtIQ.NAMESPACE_CLIENT);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        opsetContactCapabilities = new OperationSetContactCapabilitiesJabberImpl(this);\r\n        if (discoveryManager != null)\r\n            opsetContactCapabilities.setDiscoveryManager(discoveryManager);\r\n        addSupportedOperationSet(OperationSetContactCapabilities.class, opsetContactCapabilities);\r\n        addSupportedOperationSet(OperationSetGenericNotifications.class, new OperationSetGenericNotificationsJabberImpl(this));\r\n        supportedFeatures.add(\"jabber:iq:version\");\r\n        if (versionManager == null)\r\n            versionManager = new VersionManager(this);\r\n        supportedFeatures.add(MessageCorrectionExtension.NAMESPACE);\r\n        addSupportedOperationSet(OperationSetMessageCorrection.class, basicInstantMessaging);\r\n        OperationSetChangePassword opsetChangePassword = new OperationSetChangePasswordJabberImpl(this);\r\n        addSupportedOperationSet(OperationSetChangePassword.class, opsetChangePassword);\r\n        OperationSetCusaxUtils opsetCusaxCusaxUtils = new OperationSetCusaxUtilsJabberImpl(this);\r\n        addSupportedOperationSet(OperationSetCusaxUtils.class, opsetCusaxCusaxUtils);\r\n        boolean isUserSearchEnabled = accountID.getAccountPropertyBoolean(IS_USER_SEARCH_ENABLED_PROPERTY, false);\r\n        if (isUserSearchEnabled) {\r\n            addSupportedOperationSet(OperationSetUserSearch.class, new OperationSetUserSearchJabberImpl(this));\r\n        }\r\n        OperationSetTLS opsetTLS = new OperationSetTLSJabberImpl(this);\r\n        addSupportedOperationSet(OperationSetTLS.class, opsetTLS);\r\n        OperationSetConnectionInfo opsetConnectionInfo = new OperationSetConnectionInfoJabberImpl();\r\n        addSupportedOperationSet(OperationSetConnectionInfo.class, opsetConnectionInfo);\r\n        isInitialized = true;\r\n    }\r\n}"
}, {
	"Path": "net.librec.recommender.cf.BHFreeTestCase.testRecommenderRanking",
	"Comment": "test the whole rating process of bhfree recommender in ranking",
	"Method": "void testRecommenderRanking(){\r\n    Configuration.Resource resource = new Configuration.Resource(\"rec/cf/bhfree-test.properties\");\r\n    conf.set(\"rec.recommender.isranking\", \"true\");\r\n    conf.addResource(resource);\r\n    RecommenderJob job = new RecommenderJob(conf);\r\n    job.runJob();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.presence.StatusMessageMenu.publishStatusMessage",
	"Comment": "publishes the new message in separate thread. if successfully endedthe message item is created and added to te list of current statusmessages and if needed the message is saved.",
	"Method": "void publishStatusMessage(String message,Object menuItem,boolean saveIfNewMessage){\r\n    new PublishStatusMessageThread(message, menuItem, saveIfNewMessage).start();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommButton.imageUpdate",
	"Comment": "this method is called internally by graphics.drawimage. this is necessary for properly updating the icon image of this sipcommbutton.",
	"Method": "boolean imageUpdate(Image img,int infoflags,int x,int y,int width,int height){\r\n    repaint();\r\n    return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetPersistentPresenceIcqImpl.setAuthorizationHandler",
	"Comment": "handler for incoming authorization requests. an authorization requestnotifies the user that someone is trying to add her to their contact listand requires her to approve or reject authorization for that action.",
	"Method": "void setAuthorizationHandler(AuthorizationHandler handler){\r\n    this.authorizationHandler = handler;\r\n    parentProvider.getAimConnection().getSsiService().addBuddyAuthorizationListener(authListener);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ChatConferenceCallsListModels.initConferences",
	"Comment": "initializes the list of the conferences that are already announced.",
	"Method": "void initConferences(){\r\n    Object descriptor = chatSession.getDescriptor();\r\n    if (descriptor instanceof ChatRoomWrapper) {\r\n        ChatRoom chatRoom = ((ChatRoomWrapper) descriptor).getChatRoom();\r\n        for (ConferenceDescription cd : chatRoom.getCachedConferenceDescriptions().values()) {\r\n            if (cd.isAvailable()) {\r\n                addElement(cd);\r\n            } else {\r\n                removeElement(cd);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.googlecontacts.GoogleContactsActivator.serviceChanged",
	"Comment": "implements the servicelistener method. verifies whether thepassed event concerns a protocolproviderservice and adds thecorresponding ui controls.",
	"Method": "void serviceChanged(ServiceEvent event){\r\n    ServiceReference<?> serviceRef = event.getServiceReference();\r\n    if (serviceRef.getBundle().getState() == Bundle.STOPPING) {\r\n        return;\r\n    }\r\n    Object service = bundleContext.getService(serviceRef);\r\n    if (!(service instanceof ProtocolProviderService)) {\r\n        return;\r\n    }\r\n    if (((ProtocolProviderService) service).getProtocolName() != ProtocolNames.JABBER) {\r\n        return;\r\n    }\r\n    switch(event.getType()) {\r\n        case ServiceEvent.REGISTERED:\r\n            this.handleProviderAdded((ProtocolProviderService) service);\r\n            break;\r\n        case ServiceEvent.UNREGISTERING:\r\n            this.handleProviderRemoved((ProtocolProviderService) service);\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetContactCapabilitiesJabberImpl.userCapsNodeChanged",
	"Comment": "notifies this listener that an entitycapsmanager has changed arecord for a specific user about the caps node the user has.",
	"Method": "void userCapsNodeChanged(String user,ArrayList<String> fullJids,String node,boolean online){\r\n    OperationSetPresence opsetPresence = parentProvider.getOperationSet(OperationSetPresence.class);\r\n    if (opsetPresence != null) {\r\n        if (JabberActivator.getConfigurationService().getBoolean(PROP_XMPP_USE_ALL_RESOURCES_FOR_CAPABILITIES, USE_ALL_RESOURCES_FOR_CAPABILITIES_DEFAULT) && !fullJids.isEmpty()) {\r\n            String bareJid = StringUtils.parseBareAddress(user);\r\n            Contact contact = opsetPresence.findContactByID(bareJid);\r\n            if (contact != null) {\r\n                fireContactCapabilitiesEvent(contact, ContactCapabilitiesEvent.SUPPORTED_OPERATION_SETS_CHANGED, getLargestSupportedOperationSet(fullJids));\r\n            }\r\n        } else {\r\n            String jid = StringUtils.parseBareAddress(user);\r\n            Contact contact = opsetPresence.findContactByID(jid);\r\n            if (contact != null) {\r\n                if (online) {\r\n                    fireContactCapabilitiesEvent(contact, ContactCapabilitiesEvent.SUPPORTED_OPERATION_SETS_CHANGED, getSupportedOperationSets(user, online));\r\n                } else {\r\n                    fireContactCapabilitiesEvent(contact, ContactCapabilitiesEvent.SUPPORTED_OPERATION_SETS_CHANGED, getSupportedOperationSets(contact));\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.callhistory.CallHistoryServiceImpl.getStates",
	"Comment": "get the delimited strings and converts them to callpeerstate",
	"Method": "List<CallPeerState> getStates(String str){\r\n    List<CallPeerState> result = new LinkedList<CallPeerState>();\r\n    Collection<String> stateStrs = getCSVs(str);\r\n    for (String item : stateStrs) {\r\n        result.add(convertStateStringToState(item));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.presence.avatar.SelectAvatarMenu.setNewImage",
	"Comment": "here is all the action. stores the selected image into protocols and ifneeded update it ina accountstatuspanel.",
	"Method": "void setNewImage(BufferedImage image){\r\n    new Thread() {\r\n        @Override\r\n        public void run() {\r\n            AccountManager accountManager = DesktopUtilActivator.getAccountManager();\r\n            for (AccountID accountID : accountManager.getStoredAccounts()) {\r\n                if (accountManager.isAccountLoaded(accountID)) {\r\n                    ProtocolProviderService protocolProvider = AccountUtils.getRegisteredProviderForAccount(accountID);\r\n                    if (protocolProvider != null && protocolProvider.isRegistered()) {\r\n                        if (SelectAvatarMenu.this.accountID != null) {\r\n                            if (accountID.equals(SelectAvatarMenu.this.accountID)) {\r\n                                OperationSetServerStoredAccountInfo opSet = protocolProvider.getOperationSet(OperationSetServerStoredAccountInfo.class);\r\n                                if (opSet != null) {\r\n                                    byte[] imageByte = null;\r\n                                    if (image != null) {\r\n                                        imageByte = ImageUtils.toByteArray(image);\r\n                                    }\r\n                                    avatarImage.setImageIcon(imageByte);\r\n                                    ImageDetail newDetail = new ImageDetail(\"avatar\", imageByte);\r\n                                    Iterator<GenericDetail> oldDetail = opSet.getDetails(ImageDetail.class);\r\n                                    try {\r\n                                        if (oldDetail.hasNext()) {\r\n                                            opSet.replaceDetail(oldDetail.next(), newDetail);\r\n                                        } else\r\n                                            opSet.addDetail(newDetail);\r\n                                    } catch (Throwable t) {\r\n                                        logger.error(\"Error setting image\", t);\r\n                                    }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            OperationSetAvatar opSetAvatar = protocolProvider.getOperationSet(OperationSetAvatar.class);\r\n                            if (opSetAvatar != null) {\r\n                                byte[] imageByte = null;\r\n                                if (image != null) {\r\n                                    imageByte = ImageUtils.toByteArray(image);\r\n                                }\r\n                                try {\r\n                                    opSetAvatar.setAvatar(imageByte);\r\n                                } catch (Throwable t) {\r\n                                    logger.error(\"Error setting image\", t);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }.start();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.presence.avatar.SelectAvatarMenu.setNewImage",
	"Comment": "here is all the action. stores the selected image into protocols and ifneeded update it ina accountstatuspanel.",
	"Method": "void setNewImage(BufferedImage image){\r\n    AccountManager accountManager = DesktopUtilActivator.getAccountManager();\r\n    for (AccountID accountID : accountManager.getStoredAccounts()) {\r\n        if (accountManager.isAccountLoaded(accountID)) {\r\n            ProtocolProviderService protocolProvider = AccountUtils.getRegisteredProviderForAccount(accountID);\r\n            if (protocolProvider != null && protocolProvider.isRegistered()) {\r\n                if (SelectAvatarMenu.this.accountID != null) {\r\n                    if (accountID.equals(SelectAvatarMenu.this.accountID)) {\r\n                        OperationSetServerStoredAccountInfo opSet = protocolProvider.getOperationSet(OperationSetServerStoredAccountInfo.class);\r\n                        if (opSet != null) {\r\n                            byte[] imageByte = null;\r\n                            if (image != null) {\r\n                                imageByte = ImageUtils.toByteArray(image);\r\n                            }\r\n                            avatarImage.setImageIcon(imageByte);\r\n                            ImageDetail newDetail = new ImageDetail(\"avatar\", imageByte);\r\n                            Iterator<GenericDetail> oldDetail = opSet.getDetails(ImageDetail.class);\r\n                            try {\r\n                                if (oldDetail.hasNext()) {\r\n                                    opSet.replaceDetail(oldDetail.next(), newDetail);\r\n                                } else\r\n                                    opSet.addDetail(newDetail);\r\n                            } catch (Throwable t) {\r\n                                logger.error(\"Error setting image\", t);\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    OperationSetAvatar opSetAvatar = protocolProvider.getOperationSet(OperationSetAvatar.class);\r\n                    if (opSetAvatar != null) {\r\n                        byte[] imageByte = null;\r\n                        if (image != null) {\r\n                            imageByte = ImageUtils.toByteArray(image);\r\n                        }\r\n                        try {\r\n                            opSetAvatar.setAvatar(imageByte);\r\n                        } catch (Throwable t) {\r\n                            logger.error(\"Error setting image\", t);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.JabberAccountIDImpl.getStunServers",
	"Comment": "returns the list of stun servers that this account is currentlyconfigured to use.",
	"Method": "List<StunServerDescriptor> getStunServers(){\r\n    Map<String, String> accountProperties = getAccountProperties();\r\n    List<StunServerDescriptor> serList = new ArrayList<StunServerDescriptor>();\r\n    for (int i = 0; i < StunServerDescriptor.MAX_STUN_SERVER_COUNT; i++) {\r\n        StunServerDescriptor stunServer = StunServerDescriptor.loadDescriptor(accountProperties, ProtocolProviderFactory.STUN_PREFIX + i);\r\n        if (stunServer == null)\r\n            break;\r\n        String password = this.loadStunPassword(ProtocolProviderFactory.STUN_PREFIX + i);\r\n        if (password != null)\r\n            stunServer.setPassword(password);\r\n        serList.add(stunServer);\r\n    }\r\n    return serList;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockPersistentPresenceOperationSet.findGroupParent",
	"Comment": "returns the group that is parent of the specified mockgroupor nullif no parent was found.",
	"Method": "MockContactGroup findGroupParent(MockContactGroup mockGroup){\r\n    return contactListRoot.findGroupParent(mockGroup);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.mailnotification.MailboxIQ.setTotalEstimate",
	"Comment": "specifies whether the total number of unread mail messages contained inthis object is an estimate or a precise count.",
	"Method": "void setTotalEstimate(boolean totalEstimate){\r\n    this.totalEstimate = totalEstimate;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.ProtocolProviderActivator.getCalendarService",
	"Comment": "gets the calendarservice to be used by the classesin the bundle represented by protocolprovideractivator.",
	"Method": "CalendarService getCalendarService(){\r\n    if (calendarService == null) {\r\n        ServiceReference serviceReference = bundleContext.getServiceReference(CalendarService.class.getName());\r\n        if (serviceReference == null)\r\n            return null;\r\n        calendarService = (CalendarService) bundleContext.getService(serviceReference);\r\n    }\r\n    return calendarService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.launchutils.ArgDelegator.handleUri",
	"Comment": "passes the uriarg to the uri delegation peer or, in case no peer is currently registered, stores it and keeps it until one appears.",
	"Method": "void handleUri(String uriArg){\r\n    synchronized (recordedArgs) {\r\n        if (uriDelegationPeer == null) {\r\n            recordedArgs.add(uriArg);\r\n            return;\r\n        }\r\n    }\r\n    uriDelegationPeer.handleUri(uriArg);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.ChatRoomMessageReceivedEvent.getTimestamp",
	"Comment": "a timestamp indicating the exact date when the event occurred.",
	"Method": "Date getTimestamp(){\r\n    return timestamp;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ContactJabberImpl.getParentContactGroup",
	"Comment": "returns a reference to the contact group that this contact is currentlya child of or null if the underlying protocol does not support persistentpresence.",
	"Method": "ContactGroup getParentContactGroup(){\r\n    return ssclCallback.findContactGroup(this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.sip.TestOperationSetServerStoredInfo.testRemoveInfo",
	"Comment": "tests deleting info. puts the image to the server by using sipcommunicator interfaces, deletes it and then gets it by using xcapclient.",
	"Method": "void testRemoveInfo(){\r\n    byte[] imageContent = TestOperationSetServerStoredInfoData.IMAGE_CONTENT_1;\r\n    ServerStoredDetails.ImageDetail imageDetail = new ServerStoredDetails.ImageDetail(null, imageContent);\r\n    opSetServerStoredAccountInfo.addDetail(imageDetail);\r\n    boolean removeResult = opSetServerStoredAccountInfo.removeDetail(imageDetail);\r\n    assertTrue(\"The result of remove operation cannot be false\", removeResult);\r\n    Iterator<ServerStoredDetails.GenericDetail> storedDetails = opSetServerStoredAccountInfo.getDetails(ServerStoredDetails.ImageDetail.class);\r\n    assertNotNull(\"Stored details cannot be null\", storedDetails);\r\n    assertFalse(\"Stored details cannot have ImageDetail\", storedDetails.hasNext());\r\n    ContentType presContent = xCapClient.getPresContent(ServerStoredContactListSipImpl.PRES_CONTENT_IMAGE_NAME);\r\n    assertNull(\"Pres-content cannot be not null\", presContent);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.whiteboard.WhiteboardObjectPolygonJabberImpl.setFill",
	"Comment": "sets the fill state of the whiteboardobject.true is filled, false is unfilled.",
	"Method": "void setFill(boolean fill){\r\n    this.fill = fill;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetPresenceSipImpl.getAddress",
	"Comment": "gets the identifying address of a specific contactsipimpl inthe form of a address value.",
	"Method": "Address getAddress(ContactSipImpl contact){\r\n    try {\r\n        return parentProvider.parseAddressString(contact.getAddress());\r\n    } catch (ParseException ex) {\r\n        ProtocolProviderServiceSipImpl.throwOperationFailedException(\"An unexpected error occurred while constructing the address\", OperationFailedException.INTERNAL_ERROR, ex, logger);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.sdp.SdpUtils.encodeFmtp",
	"Comment": "encodes in an sdp string all format specific codec parameters.",
	"Method": "String encodeFmtp(MediaFormat format){\r\n    Iterator<Map.Entry<String, String>> formatParamsIter = format.getFormatParameters().entrySet().iterator();\r\n    StringBuffer fmtpBuff = new StringBuffer();\r\n    while (formatParamsIter.hasNext()) {\r\n        Map.Entry<String, String> ntry = formatParamsIter.next();\r\n        fmtpBuff.append(ntry.getKey()).append(\"=\").append(ntry.getValue());\r\n        if (formatParamsIter.hasNext())\r\n            fmtpBuff.append(\";\");\r\n    }\r\n    return fmtpBuff.toString();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.AdHocConferenceChatTransport.allowsMessageCorrections",
	"Comment": "returns true if this chat transport supports messagecorrections and false otherwise.",
	"Method": "boolean allowsMessageCorrections(){\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.ChatRoomProviderWrapperImpl.countChatRooms",
	"Comment": "returns the number of chat rooms contained in this provider.",
	"Method": "int countChatRooms(){\r\n    return chatRoomsOrderedCopy.size();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChannelManager.parseISupportChanLimit",
	"Comment": "parse the raw isupport chanlimit value, extract its values into thedestination map.",
	"Method": "void parseISupportChanLimit(Map<Character, Integer> destination,IIRCState state){\r\n    final String rawChanLimitValue = state.getServerOptions().getKey(ISupport.CHANLIMIT.name());\r\n    ISupport.parseChanLimit(destination, rawChanLimitValue);\r\n    if (LOGGER.isDebugEnabled()) {\r\n        LOGGER.debug(\"Parsed ISUPPORT CHANLIMIT parameter: \" + rawChanLimitValue);\r\n        for (Entry<Character, Integer> e : destination.entrySet()) {\r\n            LOGGER.debug(e.getKey() + \":\" + e.getValue());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.configforms.ConfigurationFrame.showFormContent",
	"Comment": "shows on the right the configuration form given by the givenconfigformdescriptor.",
	"Method": "void showFormContent(ConfigFormDescriptor configFormDescriptor){\r\n    this.centerPanel.removeAll();\r\n    final JComponent configFormPanel = (JComponent) configFormDescriptor.getConfigFormPanel();\r\n    configFormPanel.setOpaque(false);\r\n    centerPanel.add(configFormPanel, BorderLayout.CENTER);\r\n    centerPanel.revalidate();\r\n    centerPanel.setPreferredSize(new Dimension(550, configFormPanel.getPreferredSize().height + 2 * BORDER_SIZE));\r\n    pack();\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.TestOperationSetPresence.testSupportedStatusSetForCompleteness",
	"Comment": "verifies that all necessary icq test states are supported by theimplementation.",
	"Method": "void testSupportedStatusSetForCompleteness(){\r\n    Iterator<PresenceStatus> supportedStatusSetIter = operationSetPresence.getSupportedStatusSet();\r\n    List<PresenceStatus> supportedStatusSet = new LinkedList<PresenceStatus>();\r\n    while (supportedStatusSetIter.hasNext()) {\r\n        supportedStatusSet.add(supportedStatusSetIter.next());\r\n    }\r\n    List<?> requiredStatusSetCopy = (List<?>) IcqStatusEnum.icqStatusSet.clone();\r\n    requiredStatusSetCopy.removeAll(supportedStatusSet);\r\n    int unsupported = requiredStatusSetCopy.size();\r\n    assertTrue(\"There are \" + unsupported + \" statuses as follows:\" + requiredStatusSetCopy, unsupported == 0);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.history.HistoryWriterImpl.insertRecord",
	"Comment": "inserts a record from the passed propertyvalues complying withthe current historyrecordstructure.first searches for the file to use to import the record, as files holdrecords with consecutive times and this fact is used for searching andfiltering records by date. this is why when inserting an old recordwe need to insert it on the correct position.",
	"Method": "void insertRecord(String[] propertyValues,Date timestamp,String timestampProperty){\r\n    SimpleDateFormat sdf = new SimpleDateFormat(DATE_FORMAT);\r\n    Iterator<String> fileIterator = HistoryReaderImpl.filterFilesByDate(this.historyImpl.getFileList(), timestamp, null).iterator();\r\n    String filename = null;\r\n    while (fileIterator.hasNext()) {\r\n        filename = fileIterator.next();\r\n        Document doc = this.historyImpl.getDocumentForFile(filename);\r\n        if (doc == null)\r\n            continue;\r\n        NodeList nodes = doc.getElementsByTagName(\"record\");\r\n        boolean changed = false;\r\n        Node node;\r\n        for (int i = 0; i < nodes.getLength(); i++) {\r\n            node = nodes.item(i);\r\n            Element idNode = XMLUtils.findChild((Element) node, timestampProperty);\r\n            if (idNode == null)\r\n                continue;\r\n            Node nestedNode = idNode.getFirstChild();\r\n            if (nestedNode == null)\r\n                continue;\r\n            String nodeValue = nestedNode.getNodeValue();\r\n            Date nodeTimeStamp;\r\n            try {\r\n                nodeTimeStamp = sdf.parse(nodeValue);\r\n            } catch (ParseException e) {\r\n                nodeTimeStamp = new Date(Long.parseLong(nodeValue));\r\n            }\r\n            if (nodeTimeStamp.before(timestamp))\r\n                continue;\r\n            Element newElem = createRecord(doc, structPropertyNames, propertyValues, timestamp);\r\n            doc.getFirstChild().insertBefore(newElem, node);\r\n            changed = true;\r\n            break;\r\n        }\r\n        if (changed) {\r\n            synchronized (this.docWriteLock) {\r\n                this.historyImpl.writeFile(filename, doc);\r\n            }\r\n            if (filename.equals(this.currentFile)) {\r\n                this.currentDoc = doc;\r\n            }\r\n            break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.credentialsstorage.CredentialsStorageServiceImpl.getUnencrypted",
	"Comment": "retrieves the unencrypted account password using configuration service.",
	"Method": "String getUnencrypted(String accountPrefix){\r\n    return configurationService.getString(accountPrefix + \".\" + ACCOUNT_UNENCRYPTED_PASSWORD);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.caps.CapsPacketExtension.toXML",
	"Comment": "returns the xml representation of the caps packet extension.",
	"Method": "String toXML(){\r\n    StringBuilder bldr = new StringBuilder(\"<c xmlns='\" + getNamespace() + \"' \");\r\n    if (getExtensions() != null)\r\n        bldr.append(\"ext='\" + getExtensions() + \"' \");\r\n    bldr.append(\"hash='\" + getHash() + \"' \");\r\n    bldr.append(\"node='\" + getNode() + \"' \");\r\n    bldr.append(\"ver='\" + getVersion() + \"'/>\");\r\n    return bldr.toString();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ServerStoredContactList.fireContactResolved",
	"Comment": "make the parent persistent presence operation set dispatch a contactresolved event.",
	"Method": "void fireContactResolved(ContactGroupSipImpl parentGroup,ContactSipImpl contact){\r\n    parentOperationSet.fireSubscriptionEvent(contact, parentGroup, SubscriptionEvent.SUBSCRIPTION_RESOLVED);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.TreeContactList.setTreeModel",
	"Comment": "sets the given treemodel as a model of this tree. specifiesalso some related properties.",
	"Method": "void setTreeModel(TreeModel treeModel){\r\n    setModel(treeModel);\r\n    setRowHeight(0);\r\n    setToggleClickCount(1);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.netaddr.NetaddrActivator.getConfigurationService",
	"Comment": "returns a reference to a configurationservice implementation currentlyregistered in the bundle context or null if no such implementation wasfound.",
	"Method": "ConfigurationService getConfigurationService(){\r\n    if (configurationService == null) {\r\n        configurationService = ServiceUtils.getService(bundleContext, ConfigurationService.class);\r\n    }\r\n    return configurationService;\r\n}"
}, {
	"Path": "com.github.ltsopensource.core.support.CronExpression.setTimeZone",
	"Comment": "sets the time zone for whichthis cronexpressionwill be resolved.",
	"Method": "void setTimeZone(TimeZone timeZone){\r\n    this.timeZone = timeZone;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.whiteboard.gui.InvitationReceivedDialog.actionPerformed",
	"Comment": "handles the actionevent triggered when one user clickson one of the buttons.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    JButton button = (JButton) e.getSource();\r\n    if (button.equals(acceptButton)) {\r\n        whiteboardManager.acceptInvitation(invitation);\r\n    } else if (button.equals(rejectButton)) {\r\n        whiteboardManager.rejectInvitation(whiteboardOpSet, invitation, reasonField.getText());\r\n    }\r\n    this.dispose();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.AdHocConferenceChatTransport.isDisplayResourceOnly",
	"Comment": "indicates if the display name should only show the resource.",
	"Method": "boolean isDisplayResourceOnly(){\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.account.EmptyAccountRegistrationWizardPage.getWizardForm",
	"Comment": "implements the wizardpage.getwizardform to return thispanel.",
	"Method": "Object getWizardForm(){\r\n    return this;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.launchutils.LaunchArgHandler.getVersion",
	"Comment": "returns the version of the sip communicator instance that we arecurrently running.",
	"Method": "String getVersion(){\r\n    String version = versionProperties.getProperty(PNAME_VERSION);\r\n    return version == null ? \"build.by.SVN\" : version;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.FTPUtils.getSize",
	"Comment": "sends ftp command for the size of the file and reads and parsesthe response from the the ftp server.",
	"Method": "int getSize(){\r\n    sendLine(\"SIZE \" + path);\r\n    String line = readLine();\r\n    if (!line.startsWith(\"213 \")) {\r\n        throw new Exception(\"Size Error.\");\r\n    }\r\n    String fileSizeStr = line.substring(4);\r\n    int fileSize = INVALID_FILE_SIZE;\r\n    try {\r\n        fileSize = Integer.parseInt(fileSizeStr);\r\n    } catch (NumberFormatException e) {\r\n        return INVALID_FILE_SIZE;\r\n    }\r\n    return fileSize;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetBasicInstantMessagingJabberImpl.isContentTypeSupported",
	"Comment": "determines whether the protocol supports the supplied content typefor the given contact.",
	"Method": "boolean isContentTypeSupported(String contentType,boolean isContentTypeSupported,String contentType,Contact contact){\r\n    if (contentType.equals(DEFAULT_MIME_TYPE))\r\n        return true;\r\n    else if (contentType.equals(HTML_MIME_TYPE)) {\r\n        String toJID = recentJIDForAddress.get(contact.getAddress());\r\n        if (toJID == null)\r\n            toJID = contact.getAddress();\r\n        return jabberProvider.isFeatureListSupported(toJID, HTML_NAMESPACE);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.contactinfo.ContactInfoActivator.getBrowserLauncher",
	"Comment": "returns the browserlauncherservice obtained from the bundlecontext.",
	"Method": "BrowserLauncherService getBrowserLauncher(){\r\n    if (browserLauncherService == null) {\r\n        ServiceReference serviceReference = bundleContext.getServiceReference(BrowserLauncherService.class.getName());\r\n        browserLauncherService = (BrowserLauncherService) bundleContext.getService(serviceReference);\r\n    }\r\n    return browserLauncherService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.GuiUtils.countOccurrences",
	"Comment": "counts occurrences of the needle character in the giventext.",
	"Method": "int countOccurrences(String text,char needle){\r\n    int count = 0;\r\n    for (char c : text.toCharArray()) {\r\n        if (c == needle)\r\n            ++count;\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.caps.CapsPacketExtension.getHash",
	"Comment": "returns the value of the hash parameter indicating the hashingalgorithm used to generate the verification string.",
	"Method": "String getHash(){\r\n    return hash;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.googlecontacts.configform.AccountSettingsForm.close",
	"Comment": "all functions implemented in this method will be invoked when userpresses the escape key.",
	"Method": "void close(boolean escaped){\r\n    cancelBtn.doClick();\r\n}"
}, {
	"Path": "net.librec.similarity.AbstractRecommenderSimilarity.buildSimilarityMatrix",
	"Comment": "build social similarity matrix with trainmatrix in datamodel.",
	"Method": "void buildSimilarityMatrix(DataModel dataModel){\r\n    conf = dataModel.getContext().getConf();\r\n    String similarityKey = conf.get(\"rec.recommender.similarity.key\", \"user\");\r\n    if (StringUtils.isNotBlank(similarityKey)) {\r\n        if (StringUtils.equals(similarityKey, \"social\")) {\r\n            buildSocialSimilarityMatrix(dataModel);\r\n        } else {\r\n            boolean isUser = StringUtils.equals(similarityKey, \"user\");\r\n            SequentialAccessSparseMatrix trainMatrix = dataModel.getDataSplitter().getTrainData();\r\n            int numUsers = trainMatrix.rowSize();\r\n            int numItems = trainMatrix.columnSize();\r\n            int count = isUser ? numUsers : numItems;\r\n            similarityMatrix = new SymmMatrix(count);\r\n            List<Integer> indexList = new ArrayList();\r\n            for (int index = 0; index < count; index++) {\r\n                indexList.add(index);\r\n            }\r\n            indexList.parallelStream().forEach((Integer thisIndex) -> {\r\n                SequentialSparseVector thisVector = isUser ? trainMatrix.row(thisIndex) : trainMatrix.column(thisIndex);\r\n                if (thisVector.getNumEntries() != 0) {\r\n                    for (int thatIndex = thisIndex + 1; thatIndex < count; thatIndex++) {\r\n                        SequentialSparseVector thatVector = isUser ? trainMatrix.row(thatIndex) : trainMatrix.column(thatIndex);\r\n                        if (thatVector.getNumEntries() == 0) {\r\n                            continue;\r\n                        }\r\n                        double sim = getCorrelation(thisVector, thatVector);\r\n                        if (!Double.isNaN(sim) && sim != 0.0) {\r\n                            similarityMatrix.set(thisIndex, thatIndex, sim);\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.JabberAccountRegistrationWizard.getProtocolDescription",
	"Comment": "implements the accountregistrationwizard.getprotocoldescription method. returns the description of the protocol for this wizard.",
	"Method": "String getProtocolDescription(){\r\n    return Resources.getString(\"plugin.jabberaccregwizz.PROTOCOL_DESCRIPTION\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.presence.AbstractStatusMessageMenu.removePropertyChangeListener",
	"Comment": "remove a propertychangelistener from the listener list.this removes a configurationchangelistener that was registeredfor all properties.",
	"Method": "void removePropertyChangeListener(PropertyChangeListener listener){\r\n    synchronized (propertyChangeListeners) {\r\n        propertyChangeListeners.remove(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.AdHocConferenceChatTransport.getDisplayName",
	"Comment": "returns the display name corresponding to this chat transport.",
	"Method": "String getDisplayName(){\r\n    return adHocChatRoom.getName();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.jabber.JabberAccountID.setGmailNotificationEnabled",
	"Comment": "specifies whether sip communicator should be querying gmail serversfor unread mail messages.",
	"Method": "void setGmailNotificationEnabled(boolean enabled){\r\n    putAccountProperty(GMAIL_NOTIFICATIONS_ENABLED, enabled);\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.PortTracker.tryRange",
	"Comment": "attempts to set the range specified by the min and max port stringparams. if the attempt fails, for reasons such as invalid porameters,this method will simply return without an exception and without an impacton the state of this class.",
	"Method": "void tryRange(String newMinPort,String newMaxPort){\r\n    try {\r\n        setRange(Integer.parseInt(newMinPort), Integer.parseInt(newMaxPort));\r\n    } catch (Exception e) {\r\n        logger.info(\"Ignoring invalid port range [\" + newMinPort + \", \" + newMaxPort + \"]\");\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Cause: \", e);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.ircaccregwizz.Resources.getString",
	"Comment": "returns an internationalized string corresponding to the given key.",
	"Method": "String getString(String key){\r\n    return getResources().getI18NString(key);\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.call.ContactPhoneUtil.getContactAdditionalPhones",
	"Comment": "searches for phones for the contact.return null if we have stopped searching and a listener is availableand will be used to inform for results.",
	"Method": "List<String> getContactAdditionalPhones(Contact contact,DetailsResponseListener listener,boolean onlyVideo,boolean localized){\r\n    OperationSetServerStoredContactInfo infoOpSet = contact.getProtocolProvider().getOperationSet(OperationSetServerStoredContactInfo.class);\r\n    Iterator<GenericDetail> details;\r\n    ArrayList<String> phonesList = new ArrayList<String>();\r\n    if (infoOpSet != null) {\r\n        try {\r\n            if (listener != null) {\r\n                details = infoOpSet.requestAllDetailsForContact(contact, listener);\r\n                if (details == null)\r\n                    return null;\r\n            } else {\r\n                details = infoOpSet.getAllDetailsForContact(contact);\r\n            }\r\n            ArrayList<String> phoneNumbers = new ArrayList<String>();\r\n            while (details.hasNext()) {\r\n                GenericDetail d = details.next();\r\n                if (d instanceof PhoneNumberDetail && !(d instanceof PagerDetail) && !(d instanceof FaxDetail)) {\r\n                    PhoneNumberDetail pnd = (PhoneNumberDetail) d;\r\n                    String number = pnd.getNumber();\r\n                    if (number != null && number.length() > 0) {\r\n                        if (!(d instanceof VideoDetail) && onlyVideo)\r\n                            continue;\r\n                        if (phoneNumbers.contains(number))\r\n                            continue;\r\n                        phoneNumbers.add(number);\r\n                        if (!localized) {\r\n                            phonesList.add(number);\r\n                            continue;\r\n                        }\r\n                        phonesList.add(number + \" (\" + getLocalizedPhoneNumber(d) + \")\");\r\n                    }\r\n                }\r\n            }\r\n        } catch (Throwable t) {\r\n            logger.error(\"Error obtaining server stored contact info\");\r\n        }\r\n    }\r\n    return phonesList;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.branding.Constants.loadSimpleStyle",
	"Comment": "temporary method to load the css style used in the chat window.",
	"Method": "void loadSimpleStyle(StyleSheet style){\r\n    InputStream is = BrandingActivator.getResources().getSettingsInputStream(\"service.gui.HTML_TEXT_STYLE\");\r\n    Reader r = new BufferedReader(new InputStreamReader(is));\r\n    try {\r\n        style.loadRules(r, null);\r\n        r.close();\r\n    } catch (IOException e) {\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractOperationSetBasicInstantMessaging.addMessageListener",
	"Comment": "registers a messagelistener with this operation set so that it getsnotifications of successful message delivery, failure or reception ofincoming messages..",
	"Method": "void addMessageListener(MessageListener listener){\r\n    synchronized (messageListeners) {\r\n        if (!messageListeners.contains(listener)) {\r\n            messageListeners.add(listener);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetAutoAnswerSipImpl.setCallForward",
	"Comment": "set to automatically forward all calls to the specifiednumber using the same provider.",
	"Method": "void setCallForward(String numberTo){\r\n    clearLocal();\r\n    this.callFwdTo = numberTo;\r\n    save();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.pluginmanager.PluginListCellRenderer.getTableCellRendererComponent",
	"Comment": "implements the listcellrenderer method.returns this panel that has been configured to display bundle name,version and description.",
	"Method": "Component getTableCellRendererComponent(JTable table,Object value,boolean isSelected,boolean hasFocus,int rowIndex,int vColIndex){\r\n    Bundle bundle = (Bundle) value;\r\n    Dictionary<?, ?> headers = bundle.getHeaders();\r\n    Object bundleName = headers.get(Constants.BUNDLE_NAME);\r\n    Object bundleVersion = headers.get(Constants.BUNDLE_VERSION);\r\n    Object bundleDescription = headers.get(Constants.BUNDLE_DESCRIPTION);\r\n    Icon stateIcon = getStateIcon(bundle.getState());\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(\"<html><nobr><b>\");\r\n    sb.append(bundleName != null ? bundleName.toString() : \"unknown\");\r\n    sb.append(\"<\/b> \");\r\n    sb.append(bundleVersion != null ? bundleVersion.toString() : \"\");\r\n    if (PluginManagerActivator.isSystemBundle(bundle)) {\r\n        sb.append(\" <b>(\");\r\n        sb.append(Resources.getString(\"plugin.pluginmanager.SYSTEM\"));\r\n        sb.append(\")<\/b>\");\r\n    }\r\n    sb.append(\"<\/nobr><\/html>\");\r\n    this.nameVersionLabel.setText(sb.toString());\r\n    if (bundleDescription != null)\r\n        this.descriptionLabel.setText(bundleDescription.toString());\r\n    else\r\n        this.descriptionLabel.setText(\"\");\r\n    if (stateIcon != null)\r\n        this.stateLabel.setIcon(stateIcon);\r\n    this.isSelected = isSelected;\r\n    return this;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.InfoRetreiver.getCachedContactDetails",
	"Comment": "request the full info for the given contactaddress if availablein cache.",
	"Method": "List<GenericDetail> getCachedContactDetails(String contactAddress){\r\n    return retreivedDetails.get(contactAddress);\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.ServiceUtils.getServiceReferences",
	"Comment": "gets an osgi service references registered in a specificbundlecontext by its class.",
	"Method": "Collection<ServiceReference<T>> getServiceReferences(BundleContext bundleContext,Class<T> serviceClass){\r\n    Collection<ServiceReference<T>> serviceReferences;\r\n    try {\r\n        serviceReferences = bundleContext.getServiceReferences(serviceClass, null);\r\n    } catch (InvalidSyntaxException ex) {\r\n        serviceReferences = null;\r\n    }\r\n    if (serviceReferences == null)\r\n        serviceReferences = Collections.emptyList();\r\n    return serviceReferences;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.credentialsstorage.CredentialsStorageServiceImpl.getEncryptedMasterPropValue",
	"Comment": "retrieves the property for the master password from the configurationservice.",
	"Method": "String getEncryptedMasterPropValue(){\r\n    return configurationService.getString(MASTER_PROP);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.gibberish.TestAccountInstallation.testInstallAccount",
	"Comment": "installs an account and verifies whether the installation has gone well.",
	"Method": "void testInstallAccount(){\r\n    ServiceReference[] serRefs = null;\r\n    String osgiFilter = \"(\" + ProtocolProviderFactory.PROTOCOL + \"=Gibberish)\";\r\n    try {\r\n        serRefs = GibberishSlickFixture.bc.getServiceReferences(ProtocolProviderFactory.class.getName(), osgiFilter);\r\n    } catch (InvalidSyntaxException ex) {\r\n        fail(osgiFilter + \" is not a valid osgi filter\");\r\n    }\r\n    assertTrue(\"Failed to find a provider factory service for protocol Gibberish\", serRefs != null && serRefs.length > 0);\r\n    ProtocolProviderFactory gibberishProviderFactory = (ProtocolProviderFactory) GibberishSlickFixture.bc.getService(serRefs[0]);\r\n    assertTrue(\"There was an account registered with the account mananger \" + \"before we've installed any\", gibberishProviderFactory.getRegisteredAccounts().size() == 0);\r\n    Hashtable<String, String> gibberishAccount1Properties = getAccountProperties(GibberishProtocolProviderServiceLick.ACCOUNT_1_PREFIX);\r\n    Hashtable<String, String> gibberishAccount2Properties = getAccountProperties(GibberishProtocolProviderServiceLick.ACCOUNT_2_PREFIX);\r\n    try {\r\n        gibberishProviderFactory.installAccount(null, gibberishAccount1Properties);\r\n        fail(\"installing an account with a null account id must result \" + \"in a NullPointerException\");\r\n    } catch (NullPointerException exc) {\r\n    }\r\n    gibberishProviderFactory.installAccount(gibberishAccount1Properties.get(ProtocolProviderFactory.USER_ID), gibberishAccount1Properties);\r\n    gibberishProviderFactory.installAccount(gibberishAccount2Properties.get(ProtocolProviderFactory.USER_ID), gibberishAccount2Properties);\r\n    try {\r\n        gibberishProviderFactory.installAccount(gibberishAccount1Properties.get(ProtocolProviderFactory.USER_ID), gibberishAccount1Properties);\r\n        fail(\"An IllegalStateException must be thrown when trying to \" + \"install a duplicate account\");\r\n    } catch (IllegalStateException exc) {\r\n    }\r\n    assertTrue(\"The newly installed account was not in the acc man's \" + \"registered accounts!\", gibberishProviderFactory.getRegisteredAccounts().size() == 2);\r\n    osgiFilter = \"(&(\" + ProtocolProviderFactory.PROTOCOL + \"=Gibberish)\" + \"(\" + ProtocolProviderFactory.USER_ID + \"=\" + gibberishAccount1Properties.get(ProtocolProviderFactory.USER_ID) + \"))\";\r\n    try {\r\n        serRefs = GibberishSlickFixture.bc.getServiceReferences(ProtocolProviderService.class.getName(), osgiFilter);\r\n    } catch (InvalidSyntaxException ex) {\r\n        fail(osgiFilter + \"is not a valid osgi filter\");\r\n    }\r\n    assertTrue(\"An protocol provider was apparently not installed as \" + \"requested.\", serRefs != null && serRefs.length > 0);\r\n    Object gibberishProtocolProvider = GibberishSlickFixture.bc.getService(serRefs[0]);\r\n    assertTrue(\"The installed protocol provider does not implement \" + \"the protocol provider service.\", gibberishProtocolProvider instanceof ProtocolProviderService);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockChatRoom.setSubject",
	"Comment": "sets the subject of this chat room. if the user does not have the rightto change the room subject, or the protocol does not support this, orthe operation fails for some other reason, the method throws anoperationfailedexception with the corresponding code.",
	"Method": "void setSubject(String subject){\r\n    this.subject = subject;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapDirectoryImpl.toString",
	"Comment": "turns ldapdirectoryimpl into a printable objectused for debugging purposes",
	"Method": "String toString(){\r\n    return this.settings.getName();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactGroupImpl.findMetaContactGroupByContactGroup",
	"Comment": "returns a meta contact group, encapsulated by this group or itssubgroups, that has the specified protocol specific contact. if no suchmeta contact group exists, the method would return null.",
	"Method": "MetaContactGroupImpl findMetaContactGroupByContactGroup(ContactGroup protoContactGroup){\r\n    if (protoGroups.contains(protoContactGroup))\r\n        return this;\r\n    Iterator<MetaContactGroup> groupsIter = getSubgroups();\r\n    while (groupsIter.hasNext()) {\r\n        MetaContactGroupImpl mGroup = (MetaContactGroupImpl) groupsIter.next();\r\n        MetaContactGroupImpl foundMetaContactGroup = mGroup.findMetaContactGroupByContactGroup(protoContactGroup);\r\n        if (foundMetaContactGroup != null)\r\n            return foundMetaContactGroup;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ContactGroupIcqImpl.getPersistentData",
	"Comment": "returns null as no persistent data is required and the contact address issufficient for restoring the contact.",
	"Method": "String getPersistentData(){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.notificationconfiguration.NotificationsTable.getColumnIconValue",
	"Comment": "returns the icon value of the given column if the the column supports anicon value, otherwise returns null.",
	"Method": "Icon getColumnIconValue(int column){\r\n    if (column == 1) {\r\n        return new ImageIcon(Resources.getImageInBytes(\"plugin.notificationconfig.PROG_ICON\"));\r\n    } else if (column == 2) {\r\n        return new ImageIcon(Resources.getImageInBytes(\"plugin.notificationconfig.POPUP_ICON\"));\r\n    } else if (column == 3) {\r\n        return new ImageIcon(Resources.getImageInBytes(\"plugin.notificationconfig.SOUND_ICON_NOTIFY\"));\r\n    } else if (column == 4) {\r\n        return new ImageIcon(Resources.getImageInBytes(\"plugin.notificationconfig.SOUND_ICON_PLAYBACK\"));\r\n    } else if (column == 5) {\r\n        return new ImageIcon(Resources.getImageInBytes(\"plugin.notificationconfig.SOUND_ICON\"));\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.notificationwiring.NotificationManager.callPeerAdded",
	"Comment": "implements the callchangelistener.callpeeradded method.",
	"Method": "void callPeerAdded(CallPeerEvent evt){\r\n    CallPeer peer = evt.getSourceCallPeer();\r\n    if (peer == null)\r\n        return;\r\n    peer.addCallPeerListener(this);\r\n    peer.addCallPeerSecurityListener(this);\r\n    peer.addCallPeerConferenceListener(this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallManager.mergeExistingCalls",
	"Comment": "merges specific existing calls into a specific telephonyconference.",
	"Method": "void mergeExistingCalls(CallConference conference,Collection<Call> calls){\r\n    new MergeExistingCalls(conference, calls).start();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.addIncomingEvents",
	"Comment": "adds all events accumulated in the incoming event buffer to thechat conversation panel.",
	"Method": "void addIncomingEvents(){\r\n    synchronized (incomingEventBuffer) {\r\n        Iterator<Object> eventBufferIter = incomingEventBuffer.iterator();\r\n        while (eventBufferIter.hasNext()) {\r\n            Object incomingEvent = eventBufferIter.next();\r\n            if (incomingEvent instanceof ChatMessage) {\r\n                this.displayChatMessage((ChatMessage) incomingEvent);\r\n            } else if (incomingEvent instanceof ChatConversationComponent) {\r\n                this.getChatConversationPanel().addComponent((ChatConversationComponent) incomingEvent);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallManager.inviteToJitsiVideobridgeConfCall",
	"Comment": "invites the given list of callees to the given conferencecall.",
	"Method": "void inviteToJitsiVideobridgeConfCall(String[] callees,Call call){\r\n    new InviteToConferenceBridgeThread(call.getProtocolProvider(), callees, call).start();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.RootContactGroupJabberImpl.contacts",
	"Comment": "returns an iterator over all contacts, member of thiscontactgroup.",
	"Method": "Iterator<Contact> contacts(){\r\n    return contacts.values().iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.CallConference.conferenceFocusChanged",
	"Comment": "notifies this callconference that the value of itsconferencefocus property has changed from a specific old valueto a specific new value.",
	"Method": "void conferenceFocusChanged(boolean oldValue,boolean newValue){\r\n    firePropertyChange(Call.CONFERENCE_FOCUS, oldValue, newValue);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.AdHocConferenceChatTransport.allowsSmsMessage",
	"Comment": "returns true if this chat transport supports smsmessaging, otherwise returns false.",
	"Method": "boolean allowsSmsMessage(){\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ServerStoredContactListXivoImpl.run",
	"Comment": "the logic that runs in separate thread. dispatching responses.",
	"Method": "void run(){\r\n    if (connection == null) {\r\n        logger.error(\"No connection.\");\r\n        return;\r\n    }\r\n    try {\r\n        connectionReader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\r\n        if (!connectionReader.readLine().contains(\"XiVO\")) {\r\n            logger.error(\"Error xivo with server!\");\r\n            destroy();\r\n            return;\r\n        }\r\n        String line;\r\n        while ((line = connectionReader.readLine()) != null || !stopped) {\r\n            try {\r\n                if (logger.isTraceEnabled())\r\n                    logger.trace(\"Read from server:\" + line);\r\n                handle((JSONObject) JSONValue.parseWithException(line));\r\n            } catch (Throwable ex) {\r\n                logger.error(\"Error parsing object:\" + line, ex);\r\n            }\r\n        }\r\n    } catch (IOException ex) {\r\n        destroy();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.dns.DnsUtilActivator.loadDNSProxyForward",
	"Comment": "checks settings and if needed load forwarding of dns to the serverthat is specified.",
	"Method": "boolean loadDNSProxyForward(){\r\n    if (getConfigurationService().getBoolean(ProxyInfo.CONNECTION_PROXY_FORWARD_DNS_PROPERTY_NAME, false)) {\r\n        try {\r\n            String serverAddress = (String) getConfigurationService().getProperty(ProxyInfo.CONNECTION_PROXY_FORWARD_DNS_ADDRESS_PROPERTY_NAME);\r\n            if (StringUtils.isNullOrEmpty(serverAddress, true))\r\n                return false;\r\n            int port = SimpleResolver.DEFAULT_PORT;\r\n            try {\r\n                port = getConfigurationService().getInt(ProxyInfo.CONNECTION_PROXY_FORWARD_DNS_PORT_PROPERTY_NAME, SimpleResolver.DEFAULT_PORT);\r\n            } catch (NumberFormatException ne) {\r\n                logger.error(\"Wrong port value\", ne);\r\n            }\r\n            SimpleResolver sResolver = new SimpleResolver(\"0\");\r\n            sResolver.setAddress(new InetSocketAddress(serverAddress, port));\r\n            Lookup.setDefaultResolver(sResolver);\r\n            return true;\r\n        } catch (Throwable t) {\r\n            logger.error(\"Creating simple forwarding resolver\", t);\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWritePanel.getEditorPane",
	"Comment": "returns the editor panel, contained in this chatwritepanel.",
	"Method": "JEditorPane getEditorPane(){\r\n    return editorPane;\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.server.WebSocketServerFactory.findDecoratedObjectFactory",
	"Comment": "attempt to find the decoratedobjectfactory that should be used.",
	"Method": "DecoratedObjectFactory findDecoratedObjectFactory(){\r\n    DecoratedObjectFactory objectFactory;\r\n    if (context != null) {\r\n        objectFactory = (DecoratedObjectFactory) context.getAttribute(DecoratedObjectFactory.ATTR);\r\n        if (objectFactory != null) {\r\n            return objectFactory;\r\n        }\r\n    }\r\n    objectFactory = new DecoratedObjectFactory();\r\n    objectFactory.addDecorator(new DeprecationWarning());\r\n    LOG.info(\"No DecoratedObjectFactory provided, using new {}\", objectFactory);\r\n    return objectFactory;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.update.UpdateActivator.getShutdownService",
	"Comment": "gets a reference to a shutdownservice implementationcurrently registered in the bundle context of the activeupdatecheckactivator instance.the returned reference to shutdownservice is not beingcached.",
	"Method": "ShutdownService getShutdownService(){\r\n    return ServiceUtils.getService(bundleContext, ShutdownService.class);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.icqaccregwizz.IcqAccountRegistration.setRememberPassword",
	"Comment": "sets the rememberpassword value of this icq account registration.",
	"Method": "void setRememberPassword(boolean rememberPassword){\r\n    this.rememberPassword = rememberPassword;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.AdHocChatRoomInvitationReceivedEvent.getInvitation",
	"Comment": "returns the adhocchatroominvitation that this event is for.",
	"Method": "AdHocChatRoomInvitation getInvitation(){\r\n    return invitation;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.conference.BasicConferenceParticipantPanel.getCallPanel",
	"Comment": "gets the callpanel which contains this instances and uses it todepict the associated conference participant.",
	"Method": "CallPanel getCallPanel(){\r\n    return getCallRenderer().getCallContainer();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.whiteboard.WhiteboardSessionManager.whiteboardObjectDeliveryFailed",
	"Comment": "called to indicate that delivery of a whiteboardobject sent earlierhas failed.reason code and phrase are contained by thewhiteboardobjectdeliveryfailedevent",
	"Method": "void whiteboardObjectDeliveryFailed(WhiteboardObjectDeliveryFailedEvent evt){\r\n    String errorMessage = null;\r\n    if (evt.getErrorCode() == WhiteboardObjectDeliveryFailedEvent.NETWORK_FAILURE) {\r\n        errorMessage = \"Network failure.\";\r\n    } else if (evt.getErrorCode() == WhiteboardObjectDeliveryFailedEvent.OFFLINE_MESSAGES_NOT_SUPPORTED) {\r\n        errorMessage = \"Offline messages aren't supported.\";\r\n    } else if (evt.getErrorCode() == WhiteboardObjectDeliveryFailedEvent.PROVIDER_NOT_REGISTERED) {\r\n        errorMessage = \"Protocol provider is not registered.\";\r\n    } else if (evt.getErrorCode() == WhiteboardObjectDeliveryFailedEvent.INTERNAL_ERROR) {\r\n        errorMessage = \"An internal error occured.\";\r\n    } else if (evt.getErrorCode() == WhiteboardObjectDeliveryFailedEvent.UNKNOWN_ERROR) {\r\n        errorMessage = \"An unknown error occured.\";\r\n    }\r\n    String debugErrorMessage = \"WBObjectDeliveryFailedEvent: The following object: \" + evt.getSourceWhiteboardObject() + \" has NOT been delivered to \" + evt.getDestinationContact().getDisplayName() + \" because of the following error: \" + errorMessage;\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(debugErrorMessage);\r\n    WhiteboardActivator.getUiService().getPopupDialog().showMessagePopupDialog(errorMessage, \"Error\", PopupDialog.ERROR_MESSAGE);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.provdisc.dhcp.ProvisioningDiscoveryServiceDHCPImpl.startDiscovery",
	"Comment": "launch a discovery for a provisioning url by sending a dhcp informwith parameter list option containing a custom option code.this method is asynchronous, the response will be notified to anyprovisioninglistener registered.",
	"Method": "void startDiscovery(){\r\n    if (discover != null) {\r\n        new Thread(discover).start();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.skinmanager.Resources.getResources",
	"Comment": "returns an instance of resourcemanagementservice registered inthe bundlecontext.",
	"Method": "ResourceManagementService getResources(){\r\n    if (resourcesService == null)\r\n        resourcesService = ResourceManagementServiceUtils.getService(SkinManagerActivator.bundleContext);\r\n    return resourcesService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.SourceUIContact.getRightButtonMenu",
	"Comment": "returns the jpopupmenu opened on a right button click over thissourceuicontact.",
	"Method": "JPopupMenu getRightButtonMenu(){\r\n    return new SourceContactRightButtonMenu(this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.IcqTesterAgent.getIcqUIN",
	"Comment": "returns a string representation of the uin used by the tester agent tosignon on the icq network.",
	"Method": "String getIcqUIN(){\r\n    return icqUIN.getFormatted();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.globaldisplaydetails.GlobalDisplayDetailsImpl.removeGlobalDisplayDetailsListener",
	"Comment": "removes the given globaldisplaydetailslistener listening forchange events concerning the global display details.",
	"Method": "void removeGlobalDisplayDetailsListener(GlobalDisplayDetailsListener l){\r\n    synchronized (displayDetailsListeners) {\r\n        if (displayDetailsListeners.contains(l))\r\n            displayDetailsListeners.remove(l);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.sip.TestOperationSetPersistentPresence.suite",
	"Comment": "creates a test suite containing all tests of this class followed bytest methods that we want executed in a specified order.",
	"Method": "Test suite(){\r\n    TestSuite suite = new TestSuite();\r\n    suite.addTest(new TestOperationSetPersistentPresence(\"postTestCreateGroup\"));\r\n    suite.addTest(new TestOperationSetPersistentPresence(\"postTestRenameGroup\"));\r\n    suite.addTest(new TestOperationSetPersistentPresence(\"postTestRemoveGroup\"));\r\n    suite.addTest(new TestOperationSetPersistentPresence(\"prepareContactList\"));\r\n    suite.addTestSuite(TestOperationSetPersistentPresence.class);\r\n    return suite;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.MainFrame.addSearchFieldListener",
	"Comment": "adds the given textfieldchangelistener to listen for any changesthat occur in the search field.",
	"Method": "void addSearchFieldListener(TextFieldChangeListener l){\r\n    searchField.addTextChangeListener(l);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.gui.LazyConfigurationForm.getResources",
	"Comment": "returns an instance of the resourcemanagementservice, whichcould be used to obtain any resources.",
	"Method": "ResourceManagementService getResources(){\r\n    if (resources == null)\r\n        resources = ResourceManagementServiceUtils.getService(GuiServiceActivator.getBundleContext());\r\n    return resources;\r\n}"
}, {
	"Path": "net.librec.recommender.FactorizationMachineRecommender.getUserItemIndex",
	"Comment": "getuseritemindexget the user index and item index from a sparse appender vector",
	"Method": "int[] getUserItemIndex(VectorBasedSequentialSparseVector x){\r\n    int[] inds = x.getIndices();\r\n    int userInd = inds[0];\r\n    int itemInd = inds[1] - numUsers;\r\n    return new int[] { userInd, itemInd };\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.account.AccountRegWizardContainerImpl.addAccountRegistrationWizard",
	"Comment": "adds the given accountregistrationwizard to the list ofcontaining wizards.",
	"Method": "void addAccountRegistrationWizard(String protocolName,AccountRegistrationWizard wizard){\r\n    synchronized (registeredWizards) {\r\n        registeredWizards.put(protocolName, wizard);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl.getJainSipProvider",
	"Comment": "returns the jain sip provider instance that is responsible for sendingand receiving requests and responses related to this call peer.",
	"Method": "SipProvider getJainSipProvider(){\r\n    return jainSipProvider;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.TransportManagerSipImpl.getICECandidateExtendedType",
	"Comment": "returns the extended type of the candidate selected if this transportmanager is using ice.",
	"Method": "String getICECandidateExtendedType(String streamName){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.UIServiceImpl.firePluginEvent",
	"Comment": "creates the corresponding plugincomponentevent and notifies allcontainerpluginlisteners that a plugin component is added orremoved from the container.",
	"Method": "void firePluginEvent(PluginComponentFactory factory,int eventID){\r\n    PluginComponentEvent evt = new PluginComponentEvent(factory, eventID);\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Will dispatch the following plugin component event: \" + evt);\r\n    synchronized (pluginComponentListeners) {\r\n        Iterator<WeakReference<PluginComponentListener>> i = pluginComponentListeners.iterator();\r\n        while (i.hasNext()) {\r\n            PluginComponentListener l = i.next().get();\r\n            if (l == null)\r\n                i.remove();\r\n            else {\r\n                switch(evt.getEventID()) {\r\n                    case PluginComponentEvent.PLUGIN_COMPONENT_ADDED:\r\n                        l.pluginComponentAdded(evt);\r\n                        break;\r\n                    case PluginComponentEvent.PLUGIN_COMPONENT_REMOVED:\r\n                        l.pluginComponentRemoved(evt);\r\n                        break;\r\n                    default:\r\n                        logger.error(\"Unknown event type \" + evt.getEventID());\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatSession.getHistoryAfterDate",
	"Comment": "returns a collection of the last n number of messages given by count.",
	"Method": "Collection<Object> getHistoryAfterDate(Date date,int count){\r\n    final MetaHistoryService metaHistory = GuiActivator.getMetaHistoryService();\r\n    if (metaHistory == null)\r\n        return null;\r\n    return metaHistory.findFirstMessagesAfter(chatHistoryFilter, chatRoomWrapper.getChatRoom(), date, ConfigurationUtils.getChatHistorySize());\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.MasterPasswordInputDialog.resetPassword",
	"Comment": "resets the password by clearing the input field and settingpassword to null. disables the ok button.",
	"Method": "void resetPassword(){\r\n    password = null;\r\n    currentPasswdField.setText(\"\");\r\n    currentPasswdField.requestFocusInWindow();\r\n    okButton.setEnabled(false);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.windowscleanshutdown.CleanShutdownActivator.serviceChanged",
	"Comment": "when new systemactivitynotificationsserviceis registered we add needed listeners.",
	"Method": "void serviceChanged(ServiceEvent serviceEvent){\r\n    ServiceReference serviceRef = serviceEvent.getServiceReference();\r\n    if (serviceRef.getBundle().getState() == Bundle.STOPPING) {\r\n        return;\r\n    }\r\n    Object sService = context.getService(serviceRef);\r\n    if (sService instanceof SystemActivityNotificationsService) {\r\n        switch(serviceEvent.getType()) {\r\n            case ServiceEvent.REGISTERED:\r\n                handleNewSystemActivityNotificationsService((SystemActivityNotificationsService) sService);\r\n                break;\r\n            case ServiceEvent.UNREGISTERING:\r\n                break;\r\n        }\r\n        return;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetUserSearchJabberImpl.search",
	"Comment": "performs user search for the searched string and returns the jids of thefound contacts.",
	"Method": "List<String> search(String searchedString){\r\n    ReportedData data = null;\r\n    try {\r\n        data = searchManager.searchForString(searchedString);\r\n    } catch (XMPPException e) {\r\n        logger.error(e);\r\n        return null;\r\n    }\r\n    if (data == null) {\r\n        logger.error(\"No data have been received from server.\");\r\n        return null;\r\n    }\r\n    Iterator<Column> columns = data.getColumns();\r\n    Iterator<Row> rows = data.getRows();\r\n    if (columns == null || rows == null) {\r\n        logger.error(\"The received data is corrupted.\");\r\n        return null;\r\n    }\r\n    Column jidColumn = null;\r\n    while (columns.hasNext()) {\r\n        Column tmpCollumn = columns.next();\r\n        if (tmpCollumn.getType().equals(FormField.TYPE_JID_SINGLE)) {\r\n            jidColumn = tmpCollumn;\r\n            break;\r\n        }\r\n    }\r\n    if (jidColumn == null) {\r\n        logger.error(\"No jid collumn provided by the server.\");\r\n        return null;\r\n    }\r\n    List<String> result = new ArrayList<String>();\r\n    while (rows.hasNext()) {\r\n        Row row = rows.next();\r\n        result.add((String) row.getValues(jidColumn.getVariable()).next());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ContactSipImpl.isLocal",
	"Comment": "determines whether or not this contact represents our own identity.",
	"Method": "boolean isLocal(){\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.AbstractPacketExtension.getAttributeNames",
	"Comment": "gets the names of the attributes which currently have associated valuesin this extension.",
	"Method": "List<String> getAttributeNames(){\r\n    synchronized (attributes) {\r\n        return new ArrayList<String>(attributes.keySet());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.JabberAccRegWizzActivator.getCredentialsService",
	"Comment": "returns the credentialsstorageservice obtained from the bundlecontext.",
	"Method": "CredentialsStorageService getCredentialsService(){\r\n    if (credentialsService == null) {\r\n        ServiceReference serviceReference = bundleContext.getServiceReference(CredentialsStorageService.class.getName());\r\n        credentialsService = (CredentialsStorageService) bundleContext.getService(serviceReference);\r\n    }\r\n    return credentialsService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaAwareCallPeer.toSessionType",
	"Comment": "converts a specific mediatype into a sessiontype valuein the terms of the callpeersecuritystatusevent class.",
	"Method": "int toSessionType(MediaType mediaType){\r\n    switch(mediaType) {\r\n        case AUDIO:\r\n            return CallPeerSecurityStatusEvent.AUDIO_SESSION;\r\n        case VIDEO:\r\n            return CallPeerSecurityStatusEvent.VIDEO_SESSION;\r\n        default:\r\n            throw new IllegalArgumentException(\"mediaType\");\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.neomedia.CallRecordingConfigForm.loadValues",
	"Comment": "loads values from the configuration and sets the ui components to thesevalues.",
	"Method": "void loadValues(){\r\n    ConfigurationService configuration = NeomediaActivator.getConfigurationService();\r\n    String format = configuration.getString(Recorder.FORMAT);\r\n    formatsComboBox.setSelectedItem((format == null) ? SoundFileUtils.DEFAULT_CALL_RECORDING_FORMAT : format);\r\n    savedCallsDir = configuration.getString(Recorder.SAVED_CALLS_PATH);\r\n    saveCallsToCheckBox.setSelected(savedCallsDir != null);\r\n    callDirTextField.setText(savedCallsDir);\r\n    callDirTextField.setEnabled(saveCallsToCheckBox.isSelected());\r\n    callDirTextField.getDocument().addDocumentListener(this);\r\n    callDirChooseButton.setEnabled(saveCallsToCheckBox.isSelected());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetTelephonyConferencingJabberImpl.accept",
	"Comment": "tests whether or not the specified packet should be handled by thisoperation set. this method is called by smack prior to packet deliveryand it would only accept coiniqs.",
	"Method": "boolean accept(Packet packet){\r\n    return (packet instanceof CoinIQ);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.AbstractQualityControlWrapper.getRemoteSendMaxPreset",
	"Comment": "the maximum preset that the remote party is sending and we are receiving.",
	"Method": "QualityPreset getRemoteSendMaxPreset(){\r\n    QualityControl qControls = getMediaQualityControl();\r\n    if (qControls == null)\r\n        return remoteSendMaxPreset;\r\n    QualityPreset qp = qControls.getRemoteSendMaxPreset();\r\n    if (qp != null && maxFrameRate > 0)\r\n        qp = new QualityPreset(qp.getResolution(), (int) maxFrameRate);\r\n    return qp;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.generic.AdHocMultiUserChatSlickFixture.tearDown",
	"Comment": "junit teardown method.unget service references used in here.",
	"Method": "void tearDown(){\r\n    bc.ungetService(provider1ServiceRef);\r\n    bc.ungetService(provider2ServiceRef);\r\n    bc.ungetService(provider3ServiceRef);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.gui.UIContactDetail.getLabels",
	"Comment": "returns an iterator over the collection of labels associated with thisdetail.",
	"Method": "Iterator<String> getLabels(){\r\n    if (labels != null)\r\n        return labels.iterator();\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.TreeContactList.setGroupClickConsumed",
	"Comment": "if set to true prevents all operations coming in response to a mouseclick.",
	"Method": "void setGroupClickConsumed(boolean isGroupClickConsumed){\r\n    this.isGroupClickConsumed = isGroupClickConsumed;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.argdelegation.ArgDelegationPeerImpl.handleUri",
	"Comment": "relays uirarg to the corresponding handler or shows an errormessage in case no handler has been registered for the correspondingprotocol.",
	"Method": "void handleUri(String uriArg){\r\n    if (logger.isTraceEnabled())\r\n        logger.trace(\"Handling URI: \" + uriArg);\r\n    int colonIndex = uriArg.indexOf(\":\");\r\n    if (colonIndex == -1) {\r\n        ArgDelegationActivator.getUIService().getPopupDialog().showMessagePopupDialog(\"Could not determine how to handle: \" + uriArg + \".\\nNo protocol scheme found.\", \"Error handling URI\", PopupDialog.ERROR_MESSAGE);\r\n        return;\r\n    }\r\n    String scheme = uriArg.substring(0, colonIndex);\r\n    UriHandler handler;\r\n    synchronized (uriHandlers) {\r\n        handler = uriHandlers.get(scheme);\r\n    }\r\n    if (handler == null) {\r\n        if (logger.isTraceEnabled())\r\n            logger.trace(\"Couldn't open \" + uriArg + \"No handler found for protocol\" + scheme);\r\n        ArgDelegationActivator.getUIService().getPopupDialog().showMessagePopupDialog(\"\\\"\" + scheme + \"\\\" URIs are currently not supported.\", \"Error handling URI\", PopupDialog.ERROR_MESSAGE);\r\n        return;\r\n    }\r\n    try {\r\n        handler.handleUri(uriArg);\r\n    } catch (Throwable thr) {\r\n        if (thr instanceof ThreadDeath)\r\n            throw (ThreadDeath) thr;\r\n        ArgDelegationActivator.getUIService().getPopupDialog().showMessagePopupDialog(\"Error handling \" + uriArg, \"Error handling URI\", PopupDialog.ERROR_MESSAGE);\r\n        logger.error(\"Failed to handle \\\"\" + uriArg + \"\\\"\", thr);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl.processRequest",
	"Comment": "processes a request received on a sipprovider upon which this siplisteneris registered.",
	"Method": "boolean processRequest(RequestEvent requestEvent){\r\n    ServerTransaction serverTransaction = requestEvent.getServerTransaction();\r\n    SipProvider jainSipProvider = (SipProvider) requestEvent.getSource();\r\n    Request request = requestEvent.getRequest();\r\n    String requestMethod = request.getMethod();\r\n    if (serverTransaction == null) {\r\n        try {\r\n            serverTransaction = SipStackSharing.getOrCreateServerTransaction(requestEvent);\r\n        } catch (TransactionAlreadyExistsException ex) {\r\n            logger.error(\"Failed to create a new server\" + \"transaction for an incoming request\\n\" + \"(Next message contains the request)\", ex);\r\n            return false;\r\n        } catch (TransactionUnavailableException ex) {\r\n            logger.error(\"Failed to create a new server\" + \"transaction for an incoming request\\n\" + \"(Next message contains the request)\", ex);\r\n            return false;\r\n        }\r\n    }\r\n    boolean processed = false;\r\n    if (requestMethod.equals(Request.INVITE)) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"received INVITE\");\r\n        DialogState dialogState = serverTransaction.getDialog().getState();\r\n        if ((dialogState == null) || dialogState.equals(DialogState.CONFIRMED)) {\r\n            if (logger.isDebugEnabled())\r\n                logger.debug(\"request is an INVITE. Dialog state=\" + dialogState);\r\n            processInvite(jainSipProvider, serverTransaction);\r\n            processed = true;\r\n        } else {\r\n            if (dialogState.equals(DialogState.TERMINATED)) {\r\n                processStrayInvite(serverTransaction);\r\n            } else {\r\n                logger.error(\"reINVITEs while the dialog is not \" + \"confirmed are not currently supported. \" + \"DialogState is: \" + dialogState);\r\n            }\r\n            processed = true;\r\n        }\r\n    } else if (requestMethod.equals(Request.ACK)) {\r\n        processAck(serverTransaction, request);\r\n        processed = true;\r\n    } else if (requestMethod.equals(Request.BYE)) {\r\n        processBye(serverTransaction, request);\r\n        processed = true;\r\n    } else if (requestMethod.equals(Request.CANCEL)) {\r\n        processCancel(serverTransaction, request);\r\n        processed = true;\r\n    } else if (requestMethod.equals(Request.REFER)) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"received REFER\");\r\n        processRefer(serverTransaction, request, jainSipProvider);\r\n        processed = true;\r\n    } else if (requestMethod.equals(Request.NOTIFY)) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"received NOTIFY\");\r\n        processed = processNotify(serverTransaction, request);\r\n    } else if (requestMethod.equals(Request.UPDATE)) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"received UPDATE\");\r\n        processed = processUpdate(serverTransaction, request);\r\n    }\r\n    return processed;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.defaultresourcepack.DefaultLanguagePackImpl.getResourceKeys",
	"Comment": "returns a set of the keys contained only in the resourcebundle forlocale.",
	"Method": "Set<String> getResourceKeys(Locale locale){\r\n    try {\r\n        Method handleKeySet = ResourceBundle.class.getDeclaredMethod(\"handleKeySet\");\r\n        handleKeySet.setAccessible(true);\r\n        return (Set<String>) handleKeySet.invoke(ResourceBundle.getBundle(DEFAULT_RESOURCE_PATH, locale));\r\n    } catch (Exception e) {\r\n    }\r\n    return new HashSet<String>();\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.ConfigurationUtils.acceptPhoneNumberWithAlphaChars",
	"Comment": "returns true if a string with a alphabetical character migthbe considered as a phone number.false otherwise.",
	"Method": "boolean acceptPhoneNumberWithAlphaChars(){\r\n    return acceptPhoneNumberWithAlphaChars;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.mailnotification.MailboxIQ.setDate",
	"Comment": "sets the date of the most recent unread mail content on the mail server,in milliseconds since the unix epoch.",
	"Method": "void setDate(long date){\r\n    this.date = date;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.spellcheck.SpellChecker.setPersonalWords",
	"Comment": "writes custom dictionary and updates spell checker to utilize newlisting.",
	"Method": "void setPersonalWords(List<String> words){\r\n    synchronized (this.personalDictLocation) {\r\n        try {\r\n            BufferedWriter writer = new BufferedWriter(new FileWriter(this.personalDictLocation));\r\n            for (String customWord : words) {\r\n                writer.append(customWord);\r\n                writer.newLine();\r\n            }\r\n            writer.flush();\r\n            writer.close();\r\n            synchronized (this.attachedChats) {\r\n                InputStream dictInput = new FileInputStream(this.dictLocation);\r\n                this.dict = new OpenOfficeSpellDictionary(dictInput, this.personalDictLocation);\r\n                for (ChatAttachments chat : this.attachedChats) chat.setDictionary(this.dict);\r\n            }\r\n        } catch (IOException exc) {\r\n            logger.error(\"Unable to access personal spelling dictionary\", exc);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MclStorageManager.createMetaContactNode",
	"Comment": "creates a meta contact node element corresponding to metacontact",
	"Method": "Element createMetaContactNode(MetaContact metaContact){\r\n    Element metaContactElement = this.contactListDocument.createElement(META_CONTACT_NODE_NAME);\r\n    metaContactElement.setAttribute(UID_ATTR_NAME, metaContact.getMetaUID());\r\n    Element displayNameNode = contactListDocument.createElement(META_CONTACT_DISPLAY_NAME_NODE_NAME);\r\n    displayNameNode.appendChild(contactListDocument.createTextNode(metaContact.getDisplayName()));\r\n    if (((MetaContactImpl) metaContact).isDisplayNameUserDefined())\r\n        displayNameNode.setAttribute(USER_DEFINED_DISPLAY_NAME_ATTR_NAME, Boolean.TRUE.toString());\r\n    metaContactElement.appendChild(displayNameNode);\r\n    Iterator<Contact> contacts = metaContact.getContacts();\r\n    while (contacts.hasNext()) {\r\n        Contact contact = contacts.next();\r\n        Element contactElement = createProtoContactNode(contact);\r\n        if (contactElement != null)\r\n            metaContactElement.appendChild(contactElement);\r\n    }\r\n    return metaContactElement;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.caps.CapsPacketExtension.setNode",
	"Comment": "specifies the value of the node uri. the node uri uniquelyidentifies a software application, typically a url at the web site ofthe project or company that produces the software.",
	"Method": "void setNode(String node){\r\n    this.node = node;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.msoutlook.RegistryHandler.isDefaultIMApp",
	"Comment": "checks whether given application is the default im application or not.",
	"Method": "boolean isDefaultIMApp(String appName){\r\n    return Advapi32Util.registryGetStringValue(WinReg.HKEY_CURRENT_USER, REGISTRY_DEFAULT_IM_APPLICATION_KEY, REGISTRY_DEFAULT_IM_APPLICATION_VALUE).equals(appName);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWindow.removePluginComponent",
	"Comment": "removes the given component from the container corresponding to the givenconstraints.",
	"Method": "void removePluginComponent(Component c,Container container,Object constraints){\r\n    if (container.equals(Container.CONTAINER_CHAT_WINDOW)) {\r\n        if (constraints.equals(BorderLayout.SOUTH))\r\n            pluginPanelSouth.remove(c);\r\n        else if (constraints.equals(BorderLayout.WEST))\r\n            pluginPanelWest.remove(c);\r\n        else if (constraints.equals(BorderLayout.EAST))\r\n            pluginPanelEast.remove(c);\r\n    } else if (container.equals(Container.CONTAINER_CHAT_STATUS_BAR)) {\r\n        this.statusBarPanel.remove(c);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.IceConfigPanel.removeAllStunServer",
	"Comment": "remove all stunservers to the list of additional stunservers.",
	"Method": "void removeAllStunServer(){\r\n    int i = tableModel.getRowCount();\r\n    while (i != 0) {\r\n        tableModel.removeRow(0);\r\n        i--;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.sip.TestProtocolProviderServiceSipImpl.testOperationSetTypes",
	"Comment": "verifies that all operation sets have the type they are declared tohave.",
	"Method": "void testOperationSetTypes(){\r\n    Map<String, OperationSet> supportedOperationSets = fixture.provider1.getSupportedOperationSets();\r\n    for (Map.Entry<String, OperationSet> entry : supportedOperationSets.entrySet()) {\r\n        String setName = entry.getKey();\r\n        Object opSet = entry.getValue();\r\n        assertTrue(opSet + \" was not an instance of \" + setName + \" as declared\", Class.forName(setName).isInstance(opSet));\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.border.ExtendedEtchedBorder.paintBorder",
	"Comment": "paints the border for the specified component with thespecified position and size.",
	"Method": "void paintBorder(Component c,Graphics g,int x,int y,int width,int height){\r\n    int w = width;\r\n    int h = height;\r\n    Graphics2D g2 = (Graphics2D) g;\r\n    g2.translate(x, y);\r\n    g2.setColor(etchType == LOWERED ? getShadowColor(c) : getHighlightColor(c));\r\n    if (top > 0) {\r\n        g2.setStroke(new BasicStroke(top));\r\n        g2.drawLine(0, 0, w - 2, 0);\r\n    }\r\n    if (left > 0) {\r\n        g2.setStroke(new BasicStroke(left));\r\n        g2.drawLine(0, 0, 0, h - 2);\r\n    }\r\n    if (bottom > 0) {\r\n        g2.setStroke(new BasicStroke(bottom));\r\n        g2.drawLine(0, h - 2, w - 2, h - 2);\r\n    }\r\n    if (right > 0) {\r\n        g2.setStroke(new BasicStroke(right));\r\n        g2.drawLine(w - 2, 0, w - 2, h - 2);\r\n    }\r\n    g2.setColor(etchType == LOWERED ? getHighlightColor(c) : getShadowColor(c));\r\n    if (top > 0)\r\n        g2.drawLine(1, 1, w - 3, 1);\r\n    if (left > 0)\r\n        g2.drawLine(1, h - 3, 1, 1);\r\n    if (right > 0)\r\n        g2.drawLine(0, h - 1, w - 1, h - 1);\r\n    if (bottom > 0)\r\n        g2.drawLine(w - 1, h - 1, w - 1, 0);\r\n    g2.translate(-x, -y);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatContact.isSelected",
	"Comment": "returns true if this is the currently selected contact inthe list of contacts for the chat, otherwise returns false.",
	"Method": "boolean isSelected(){\r\n    return selected;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.EventPackageSubscriber.getSubscription",
	"Comment": "gets the subscription from the list of subscriptions managed bythis instance which is associated with a specific callid.",
	"Method": "Subscription getSubscription(Address toAddress,String eventId,Subscription getSubscription,String callId){\r\n    return (Subscription) super.getSubscription(callId);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.googlecontacts.GoogleContactsSourceService.isGoogleTalk",
	"Comment": "returns whether or not the account has been created via googletalkwizard or via external google contacts.",
	"Method": "boolean isGoogleTalk(){\r\n    return googleTalk;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.OperationSetPersistentPresenceGibberishImpl.findProviderForGibberishUserID",
	"Comment": "looks for a gibberish protocol provider registered for a user id matchinggibberishuserid.",
	"Method": "ProtocolProviderServiceGibberishImpl findProviderForGibberishUserID(String gibberishUserID){\r\n    BundleContext bc = GibberishActivator.getBundleContext();\r\n    String osgiQuery = \"(&\" + \"(\" + ProtocolProviderFactory.PROTOCOL + \"=Gibberish)\" + \"(\" + ProtocolProviderFactory.USER_ID + \"=\" + gibberishUserID + \")\" + \")\";\r\n    ServiceReference[] refs = null;\r\n    try {\r\n        refs = bc.getServiceReferences(ProtocolProviderService.class.getName(), osgiQuery);\r\n    } catch (InvalidSyntaxException ex) {\r\n        logger.error(\"Failed to execute the following osgi query: \" + osgiQuery, ex);\r\n    }\r\n    if (refs != null && refs.length > 0) {\r\n        return (ProtocolProviderServiceGibberishImpl) bc.getService(refs[0]);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.notifsource.NotificationContact.getRightButtonMenu",
	"Comment": "returns null to indicate that no right button menu is provided for thiscontact.",
	"Method": "JPopupMenu getRightButtonMenu(){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.ExternalContactSource.isContactActionVisible",
	"Comment": "indicates if the given contactactionmenuitem should be visiblefor the given sourcecontact.",
	"Method": "boolean isContactActionVisible(ContactAction<SourceContact> contactAction,SourceContact contact,boolean isContactActionVisible,ContactActionMenuItem<ContactSourceService> contactAction,ContactSourceService contactSource,boolean isContactActionVisible,ContactActionMenuItem<SourceContact> contactAction,SourceContact contact){\r\n    if (contactAction.isVisible(contact))\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.MUCActivator.getAlertUIService",
	"Comment": "returns the alertuiservice obtained from the bundlecontext.",
	"Method": "AlertUIService getAlertUIService(){\r\n    if (alertUIService == null) {\r\n        alertUIService = ServiceUtils.getService(bundleContext, AlertUIService.class);\r\n    }\r\n    return alertUIService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.TestAccountUninstallation.testInstallationPersistency",
	"Comment": "stops and removes the tested bundle, verifies that it has unregisteredits provider, then reloads and restarts the bundle and verifies thatthe protocol provider is reregistered in the bundle context.",
	"Method": "void testInstallationPersistency(){\r\n    Bundle providerBundle = IcqSlickFixture.findProtocolProviderBundle(fixture.provider);\r\n    IcqSlickFixture.providerBundle = providerBundle;\r\n    assertNotNull(\"Couldn't find a bundle for the tested provider\", providerBundle);\r\n    providerBundle.stop();\r\n    assertTrue(\"Couldn't stop the protocol provider bundle. State was \" + providerBundle.getState(), Bundle.ACTIVE != providerBundle.getState() && Bundle.STOPPING != providerBundle.getState());\r\n    providerBundle.uninstall();\r\n    assertEquals(\"Couldn't stop the protocol provider bundle.\", Bundle.UNINSTALLED, providerBundle.getState());\r\n    ServiceReference[] icqProviderRefs = null;\r\n    try {\r\n        icqProviderRefs = IcqSlickFixture.bc.getServiceReferences(ProtocolProviderService.class.getName(), \"(&\" + \"(\" + ProtocolProviderFactory.PROTOCOL + \"=\" + ProtocolNames.ICQ + \")\" + \"(\" + ProtocolProviderFactory.USER_ID + \"=\" + IcqSlickFixture.icqAccountID.getUserID() + \")\" + \")\");\r\n    } catch (InvalidSyntaxException ex) {\r\n        fail(\"We apparently got our filter wrong: \" + ex.getMessage());\r\n    }\r\n    assertTrue(\"A Protocol Provider Service was still regged as an osgi service \" + \"for ICQ UIN:\" + IcqSlickFixture.icqAccountID + \"After it was explicitly uninstalled\", icqProviderRefs == null || icqProviderRefs.length == 0);\r\n    assertTrue(\"The ICQ provider factory kept a reference to the provider we just \" + \"uninstalled (accID=\" + IcqSlickFixture.icqAccountID + \")\", fixture.providerFactory.getRegisteredAccounts().isEmpty() && fixture.providerFactory.getProviderForAccount(IcqSlickFixture.icqAccountID) == null);\r\n    providerBundle = IcqSlickFixture.bc.installBundle(providerBundle.getLocation());\r\n    IcqSlickFixture.providerBundle = providerBundle;\r\n    assertEquals(\"Couldn't re-install protocol provider bundle.\", Bundle.INSTALLED, providerBundle.getState());\r\n    AccountManagerUtils.startBundleAndWaitStoredAccountsLoaded(IcqSlickFixture.bc, providerBundle, ProtocolNames.ICQ);\r\n    assertEquals(\"Couldn't re-start protocol provider bundle.\", Bundle.ACTIVE, providerBundle.getState());\r\n    try {\r\n        icqProviderRefs = IcqSlickFixture.bc.getServiceReferences(ProtocolProviderService.class.getName(), \"(&\" + \"(\" + ProtocolProviderFactory.PROTOCOL + \"=\" + ProtocolNames.ICQ + \")\" + \"(\" + ProtocolProviderFactory.USER_ID + \"=\" + IcqSlickFixture.icqAccountID.getUserID() + \")\" + \")\");\r\n    } catch (InvalidSyntaxException ex) {\r\n        fail(\"We apparently got our filter wrong: \" + ex.getMessage());\r\n    }\r\n    assertTrue(\"A Protocol Provider Service was not restored after being\" + \"reinstalled. ICQ UIN:\" + IcqSlickFixture.icqAccountID, icqProviderRefs != null && icqProviderRefs.length > 0);\r\n    ServiceReference[] icqFactoryRefs = null;\r\n    try {\r\n        icqFactoryRefs = IcqSlickFixture.bc.getServiceReferences(ProtocolProviderFactory.class.getName(), \"(\" + ProtocolProviderFactory.PROTOCOL + \"=\" + ProtocolNames.ICQ + \")\");\r\n    } catch (InvalidSyntaxException ex) {\r\n        fail(\"We apparently got our filter wrong: \" + ex.getMessage());\r\n    }\r\n    fixture.providerFactory = (ProtocolProviderFactory) IcqSlickFixture.bc.getService(icqFactoryRefs[0]);\r\n    fixture.provider = (ProtocolProviderService) IcqSlickFixture.bc.getService(icqProviderRefs[0]);\r\n    IcqSlickFixture.icqAccountID = fixture.provider.getAccountID();\r\n    assertTrue(\"The ICQ provider did not restore its own reference to the provider \" + \"that we just reinstalled (accID=\" + IcqSlickFixture.icqAccountID + \")\", !fixture.providerFactory.getRegisteredAccounts().isEmpty() && fixture.providerFactory.getProviderForAccount(IcqSlickFixture.icqAccountID) != null);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.osdependent.jdic.StatusSubMenu.init",
	"Comment": "we fill the protocolprovidertable with allrunning protocol providers at the start ofthe bundle.",
	"Method": "void init(){\r\n    OsDependentActivator.bundleContext.addServiceListener(new ProtocolProviderServiceListener());\r\n    for (ProtocolProviderService provider : getProtocolProviders()) {\r\n        if (!provider.getAccountID().isHidden())\r\n            this.addAccount(provider);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.MainFrame.getContactHandler",
	"Comment": "returns the contacteventhandler registered for this protocolprovider.",
	"Method": "ContactEventHandler getContactHandler(ProtocolProviderService protocolProvider){\r\n    return providerContactHandlers.get(protocolProvider);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.IceUdpTransportManager.getStreamConnector",
	"Comment": "gets the streamconnector to be used as the connector ofthe mediastream with a specific mediatype.",
	"Method": "StreamConnector getStreamConnector(MediaType mediaType){\r\n    StreamConnector streamConnector = super.getStreamConnector(mediaType);\r\n    if (streamConnector != null) {\r\n        DatagramSocket[] streamConnectorSockets = getStreamConnectorSockets(mediaType);\r\n        if ((streamConnectorSockets != null) && ((streamConnector.getDataSocket() != streamConnectorSockets[0]) || (streamConnector.getControlSocket() != streamConnectorSockets[1]))) {\r\n            closeStreamConnector(mediaType);\r\n            streamConnector = super.getStreamConnector(mediaType);\r\n        }\r\n    }\r\n    return streamConnector;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ContactListTransferHandler.createTransferable",
	"Comment": "creates a transferable for text pane components in order to enable dragand drop of text.",
	"Method": "Transferable createTransferable(JComponent component){\r\n    if (ConfigurationUtils.isAddContactDisabled() && (ConfigurationUtils.isContactMoveDisabled() || ConfigurationUtils.isCreateGroupDisabled()))\r\n        return null;\r\n    if (component instanceof JTree) {\r\n        JTree tree = (JTree) component;\r\n        TreePath selectionPath = tree.getSelectionPath();\r\n        transferredObject = selectionPath.getLastPathComponent();\r\n        return new ContactListTransferable(tree.getRowForPath(selectionPath), selectionPath.getLastPathComponent());\r\n    }\r\n    return super.createTransferable(component);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.MUCCustomContactActionService.getContactSourceClass",
	"Comment": "returns the template class that this service has been initialized with",
	"Method": "Class<SourceContact> getContactSourceClass(){\r\n    return SourceContact.class;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.IncomingFileTransferRequestIcqImpl.getFileName",
	"Comment": "returns a string that represents the name of the file that is beingreceived.if there is no name, returns null.",
	"Method": "String getFileName(){\r\n    return incomingFileTransfer.getRequestFileInfo().getFilename();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.sipaccregwizz.FirstWizardPage.getRegistrationForm",
	"Comment": "returns the sipaccountregistrationform used in this page.",
	"Method": "SIPAccountRegistrationForm getRegistrationForm(){\r\n    return registrationForm;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.notifsource.NotificationContact.getDefaultContactDetail",
	"Comment": "returns the default contactdetail to use for any operationsdepending to the given operationset class.",
	"Method": "UIContactDetail getDefaultContactDetail(Class<? extends OperationSet> opSetClass){\r\n    if (opSetClass.equals(OperationSetBasicTelephony.class))\r\n        return notificationDetail;\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.jabber.JabberAccountID.isAutoDiscoverJingleNodes",
	"Comment": "indicates if the jinglenodes relay server should be automaticallydiscovered.",
	"Method": "boolean isAutoDiscoverJingleNodes(){\r\n    return getAccountPropertyBoolean(ProtocolProviderFactory.AUTO_DISCOVER_JINGLE_NODES, true);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.SingleWindowContainer.addConversationTab",
	"Comment": "adds a given chatpanel to the jtabbedpane of thischat window.",
	"Method": "void addConversationTab(String name,Icon icon,Component conversation,boolean isSelected){\r\n    Component currentConversation = getCurrentConversation();\r\n    tabbedPane.addTab(name, icon, conversation);\r\n    tabbedPane.getParent().validate();\r\n    tabbedPane.setSelectedComponent((currentConversation != null && !isSelected) ? currentConversation : conversation);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractMessage.getContent",
	"Comment": "returns the content of this message if representable in text form or nullif this message does not contain text data.the implementation is final because it caches the raw data of thecontent.",
	"Method": "String getContent(){\r\n    return content;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ProtocolProviderServiceIrcImpl.unregister",
	"Comment": "ends the registration of this protocol provider with the currentregistration service.",
	"Method": "void unregister(){\r\n    if (this.ircstack == null) {\r\n        return;\r\n    }\r\n    this.ircstack.disconnect();\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.FullUserInfoCmd.readBasicUserInfo",
	"Comment": "method for parsing incoming dataread data in basicuserinfo command",
	"Method": "void readBasicUserInfo(ByteBlock block,int requestID){\r\n    Hashtable<String, Object> infoData = getInfoForRequest(requestID);\r\n    String[] bscInfo = new String[11];\r\n    int offset = readStrings(block, bscInfo, 1);\r\n    int homeCountryCode = getUShort(block, offset);\r\n    offset += 2;\r\n    infoData.put(HOME_COUNTRY, new Integer(homeCountryCode));\r\n    if (bscInfo[2] != null)\r\n        infoData.put(LAST_NAME, bscInfo[2]);\r\n    if (bscInfo[6] != null)\r\n        infoData.put(PHONE_NUMBER, bscInfo[6]);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.FileTransferStatusChangeEvent.getFileTransfer",
	"Comment": "returns the source filetransfer that triggered this event.",
	"Method": "FileTransfer getFileTransfer(){\r\n    return (FileTransfer) source;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.sip.TestOperationSetServerStoredInfo.testWriteInfo",
	"Comment": "tests writing info. puts the image to the server by using sipcommunicator interfaces and then gets it by using xcap client.",
	"Method": "void testWriteInfo(){\r\n    byte[] imageContent = TestOperationSetServerStoredInfoData.IMAGE_CONTENT_1;\r\n    ServerStoredDetails.ImageDetail imageDetail = new ServerStoredDetails.ImageDetail(null, imageContent);\r\n    opSetServerStoredAccountInfo.addDetail(imageDetail);\r\n    ContentType presContent = xCapClient.getPresContent(ServerStoredContactListSipImpl.PRES_CONTENT_IMAGE_NAME);\r\n    assertNotNull(\"Pres-content cannot be null\", presContent);\r\n    assertNotNull(\"Pres-content data cannot be null\", presContent.getData());\r\n    assertNotNull(\"Pres-content data value cannot be null\", presContent.getData().getValue());\r\n    byte[] serverContent = Base64.decode(presContent.getData().getValue());\r\n    assertEquals(\"The ImageDetail we set is not set or not read properly\", imageContent.length, serverContent.length);\r\n    for (int i = 0; i < imageContent.length; i++) {\r\n        assertSame(\"The ImageDetail we set has not the same content\", imageContent[i], serverContent[i]);\r\n    }\r\n    opSetServerStoredAccountInfo.removeDetail(imageDetail);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactGroupImpl.findMetaContactGroupByMetaUID",
	"Comment": "returns a meta contact group this group or some of its subgroups,that has the specified metauid. if no such meta contact group exists,the method would return null.",
	"Method": "MetaContactGroup findMetaContactGroupByMetaUID(String metaUID){\r\n    if (metaUID.equals(groupUID))\r\n        return this;\r\n    Iterator<MetaContactGroup> groupsIter = getSubgroups();\r\n    while (groupsIter.hasNext()) {\r\n        MetaContactGroupImpl mGroup = (MetaContactGroupImpl) groupsIter.next();\r\n        if (metaUID.equals(mGroup.getMetaUID()))\r\n            return mGroup;\r\n        else\r\n            mGroup.findMetaContactByMetaUID(metaUID);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.MoveSubcontactMessageDialog.setVisible",
	"Comment": "in addition to setvisible this method would also set the dialog locationto fit the main frame.",
	"Method": "void setVisible(boolean isVisible){\r\n    super.setVisible(isVisible);\r\n    this.setDialogLocation(mainFrame);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.exampleplugin.ExamplePluginMenuItem.setCurrentContact",
	"Comment": "sets the current metacontact. this in the case of the contactright button menu container would be the underlying contact in thecontact list.",
	"Method": "void setCurrentContact(MetaContact metaContact){\r\n    this.metaContact = metaContact;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SoundLevelIndicator.getSoundBarCount",
	"Comment": "returns the number of sound level bars that we could currently show inthis panel.",
	"Method": "int getSoundBarCount(int width){\r\n    int soundBarWidth = soundLevelActiveImageLeft.getIconWidth();\r\n    return width / soundBarWidth;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWindow.createToolBar",
	"Comment": "creates the toolbar panel for this chat window, depending on the currentoperating system.",
	"Method": "Component createToolBar(){\r\n    Component toolbarPanel = null;\r\n    mainToolBar = new MainToolBar(this);\r\n    boolean chatToolbarVisible = ConfigurationUtils.isChatToolbarVisible();\r\n    if (OSUtils.IS_MAC) {\r\n        UnifiedToolBar macToolbarPanel = new UnifiedToolBar();\r\n        MacUtils.makeWindowLeopardStyle(getRootPane());\r\n        macToolbarPanel.addComponentToLeft(mainToolBar);\r\n        macToolbarPanel.addComponentToRight(contactPhotoPanel);\r\n        macToolbarPanel.disableBackgroundPainter();\r\n        macToolbarPanel.installWindowDraggerOnWindow(this);\r\n        macToolbarPanel.getComponent().setBorder(BorderFactory.createEmptyBorder(3, 3, 3, 3));\r\n        macToolbarPanel.getComponent().setVisible(chatToolbarVisible);\r\n        toolbarPanel = macToolbarPanel.getComponent();\r\n    } else {\r\n        ToolbarPanel panel = new ToolbarPanel(new BorderLayout());\r\n        panel.setBorder(BorderFactory.createEmptyBorder(3, 0, 3, 0));\r\n        panel.add(mainToolBar, BorderLayout.CENTER);\r\n        panel.add(contactPhotoPanel, BorderLayout.EAST);\r\n        panel.setVisible(chatToolbarVisible);\r\n        toolbarPanel = panel;\r\n    }\r\n    return toolbarPanel;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.TestAccountInstallation.getAccountProperties",
	"Comment": "returns all properties necessary for the intialization of the accountwith accountprefix.",
	"Method": "Hashtable<String, String> getAccountProperties(String accountPrefix){\r\n    Hashtable<String, String> table = new Hashtable<String, String>();\r\n    String userID = System.getProperty(accountPrefix + ProtocolProviderFactory.USER_ID, null);\r\n    assertNotNull(\"The system property named \" + accountPrefix + ProtocolProviderFactory.USER_ID + \" has to tontain a valid Jabber address that could be used during \" + \"SIP Communicator's tests.\", userID);\r\n    table.put(ProtocolProviderFactory.USER_ID, userID);\r\n    String passwd = System.getProperty(accountPrefix + ProtocolProviderFactory.PASSWORD, null);\r\n    assertNotNull(\"The system property named \" + accountPrefix + ProtocolProviderFactory.PASSWORD + \" has to contain the password corresponding to the account \" + \"specified in \" + accountPrefix + ProtocolProviderFactory.USER_ID, passwd);\r\n    table.put(ProtocolProviderFactory.PASSWORD, passwd);\r\n    String serverAddress = System.getProperty(accountPrefix + ProtocolProviderFactory.SERVER_ADDRESS, null);\r\n    if (serverAddress != null)\r\n        table.put(ProtocolProviderFactory.SERVER_ADDRESS, serverAddress);\r\n    String serverPort = System.getProperty(accountPrefix + ProtocolProviderFactory.SERVER_PORT, null);\r\n    if (serverPort != null)\r\n        table.put(ProtocolProviderFactory.SERVER_PORT, serverPort);\r\n    return table;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl.throwOperationFailedException",
	"Comment": "logs a specific message and associated throwable cause as anerror using the current logger and then throws a newoperationfailedexception with the message, a specific error codeand the cause.",
	"Method": "void throwOperationFailedException(String message,int errorCode,Throwable cause,Logger logger){\r\n    logger.error(message, cause);\r\n    if (cause == null)\r\n        throw new OperationFailedException(message, errorCode);\r\n    else\r\n        throw new OperationFailedException(message, errorCode, cause);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.colibri.ColibriConferenceIQ.getContent",
	"Comment": "returns a content from the list of contents of thisconference iq which has a specific name. if no suchcontent exists, returns null.",
	"Method": "Content getContent(String contentName){\r\n    for (Content content : getContents()) {\r\n        if (contentName.equals(content.getName()))\r\n            return content;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.packetlogging.PacketLoggingConfigurationImpl.setIce4JLoggingEnabled",
	"Comment": "change whether packet logging for ice4j is enabledand save it in configuration.",
	"Method": "void setIce4JLoggingEnabled(boolean enabled){\r\n    super.setIce4JLoggingEnabled(enabled);\r\n    PacketLoggingActivator.getConfigurationService().setProperty(PACKET_LOGGING_ICE4J_ENABLED_PROPERTY_NAME, enabled);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.dns.ParallelResolverImpl.setTCP",
	"Comment": "sets whether tcp connections will be sent by default with the defaultresolver. backup servers would always be contacted the same way.",
	"Method": "void setTCP(boolean flag){\r\n    defaultResolver.setTCP(flag);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.CallPeerMediaHandlerJabberImpl.setSupportQualityControls",
	"Comment": "sometimes as initing a call with custom preset can set and we forcethat quality controls is supported.",
	"Method": "void setSupportQualityControls(boolean value){\r\n    this.supportQualityControls = value;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.history.HistoryQueryImpl.removeHistoryRecordsListener",
	"Comment": "removes the given historyquerylistener from the list oflisteners interested in query result changes.",
	"Method": "void removeHistoryRecordsListener(HistoryQueryListener l){\r\n    synchronized (queryListeners) {\r\n        queryListeners.remove(l);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.FailoverConnectionMonitor.isConnectedToPrimary",
	"Comment": "whether we are connected to primary server for supplied records.",
	"Method": "boolean isConnectedToPrimary(SRVRecord[] recs){\r\n    String primaryAddress = getPrimaryServerRecord(recs).getTarget();\r\n    if (primaryAddress != null && primaryAddress.equals(currentAddress))\r\n        return true;\r\n    else\r\n        return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallPanel.isCloseWaitAfterHangup",
	"Comment": "indicates if this call panel should be closed immediately after hang upor should wait some time so that the user can be notified of the laststate.",
	"Method": "boolean isCloseWaitAfterHangup(){\r\n    return isCloseWaitAfterHangup;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractCallPeer.fireCallPeerSecurityMessageEvent",
	"Comment": "constructs a callpeersecuritystatusevent using this call peer assource, setting it to be of type eventtype and the correspondingoldvalue and newvalue.",
	"Method": "void fireCallPeerSecurityMessageEvent(String messageType,String i18nMessage,int severity){\r\n    CallPeerSecurityMessageEvent evt = new CallPeerSecurityMessageEvent(this, messageType, i18nMessage, severity);\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Dispatching a CallPeerSecurityFailedEvent event to \" + callPeerSecurityListeners.size() + \" listeners. event is: \" + evt.toString());\r\n    Iterator<CallPeerSecurityListener> listeners = null;\r\n    synchronized (callPeerSecurityListeners) {\r\n        listeners = new ArrayList<CallPeerSecurityListener>(callPeerSecurityListeners).iterator();\r\n    }\r\n    while (listeners.hasNext()) {\r\n        CallPeerSecurityListener listener = listeners.next();\r\n        listener.securityMessageRecieved(evt);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.MUCServiceImpl.addChatRoomProviderWrapperListener",
	"Comment": "adds a chatroomproviderwrapperlistener to the listener list.",
	"Method": "void addChatRoomProviderWrapperListener(ChatRoomProviderWrapperListener listener){\r\n    chatRoomList.addChatRoomProviderWrapperListener(listener);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactGroupImpl.getContactGroups",
	"Comment": "returns an iterator over all the protocol specific groups that thiscontact group represents.in order to prevent problems with concurrency, the iteratorreturned by this method is not over the actual list of groups but over acopy of that list.",
	"Method": "Iterator<ContactGroup> getContactGroups(){\r\n    return new LinkedList<ContactGroup>(this.protoGroups).iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.customcontrols.wizard.WizardModel.getWizardPage",
	"Comment": "returns the wizardpage corresponding to the given identifier.",
	"Method": "WizardPage getWizardPage(Object id){\r\n    return panelHashmap.get(id);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.slickless.util.TestBase64.testEncodeDecode",
	"Comment": "encodes a sample string, decodes it and makes sure that the decodedstring has the same value as the original",
	"Method": "void testEncodeDecode(){\r\n    String data = \"string to encode\";\r\n    byte[] expectedReturn = data.getBytes();\r\n    byte[] encodedData = Base64.encode(data.getBytes());\r\n    byte[] actualReturn = Base64.decode(encodedData);\r\n    assertTrue(\"encode decode failed.\", Arrays.equals(expectedReturn, actualReturn));\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.sipaccregwizz.SIPAccountRegistrationForm.getCreateAccountService",
	"Comment": "returns an instance of createaccountservice through which theuser could create an account. this method is meant to be implemented byspecific protocol provider wizards.",
	"Method": "SIPAccountCreationFormService getCreateAccountService(){\r\n    return wizard.getCreateAccountService();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.globaldisplaydetails.GlobalDisplayDetailsActivator.getAlertUIService",
	"Comment": "returns the alertuiservice obtained from the bundlecontext.",
	"Method": "AlertUIService getAlertUIService(){\r\n    if (alertUIService == null) {\r\n        alertUIService = ServiceUtils.getService(bundleContext, AlertUIService.class);\r\n    }\r\n    return alertUIService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.jabber.JabberAccountRegistration.getAdditionalJingleNodes",
	"Comment": "returns the list of all additional stun servers entered by theuser. the list is guaranteed not to be null.",
	"Method": "List<JingleNodeDescriptor> getAdditionalJingleNodes(){\r\n    return additionalJingleNodes;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractContact.supportResources",
	"Comment": "indicates if this contact supports resources.this default implementation indicates no support for contact resources.",
	"Method": "boolean supportResources(){\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.provdisc.mdns.ProvisioningDiscoveryServiceMDNSImpl.getMethodName",
	"Comment": "get the name of the method name used to retrieve provisioning url.",
	"Method": "String getMethodName(){\r\n    return METHOD_NAME;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.sysactivity.event.SystemActivityEvent.toString",
	"Comment": "returns a string representation of this systemactivityevent object.",
	"Method": "String toString(){\r\n    return getClass().getName() + \"[eventID=\" + eventID + \"]\";\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ServerStoredContactListJabberImpl.getNonPersistentGroup",
	"Comment": "returns the volatile group that we use when creating volatile contacts.",
	"Method": "ContactGroupJabberImpl getNonPersistentGroup(){\r\n    String groupName = JabberActivator.getResources().getI18NString(\"service.gui.NOT_IN_CONTACT_LIST_GROUP_NAME\");\r\n    for (int i = 0; i < getRootGroup().countSubgroups(); i++) {\r\n        ContactGroupJabberImpl gr = (ContactGroupJabberImpl) getRootGroup().getGroup(i);\r\n        if (!gr.isPersistent() && gr.getGroupName().equals(groupName))\r\n            return gr;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ChatContactListModel.addElement",
	"Comment": "adds a specific chatcontact to this abstractlistmodelimplementation and preserves the sorting it applies.",
	"Method": "void addElement(ChatContact<?> chatContact){\r\n    if (chatContact == null)\r\n        throw new IllegalArgumentException(\"chatContact\");\r\n    int index = -1;\r\n    synchronized (chatContacts) {\r\n        int chatContactCount = chatContacts.size();\r\n        for (int i = 0; i < chatContactCount; i++) {\r\n            ChatContact<?> containedChatContact = chatContacts.get(i);\r\n            if (chatContact.equals(containedChatContact))\r\n                return;\r\n            if ((index == -1) && (sorter.compare(containedChatContact, chatContact) > 0)) {\r\n                index = i;\r\n            }\r\n        }\r\n        if (index == -1)\r\n            index = chatContactCount;\r\n        chatContacts.add(index, chatContact);\r\n    }\r\n    fireIntervalAdded(this, index, index);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.loggingutils.LoggingUtilsActivator.getResourceService",
	"Comment": "returns the resourcemanagementservice obtained from thebundle context.",
	"Method": "ResourceManagementService getResourceService(){\r\n    if (resourceService == null) {\r\n        ServiceReference resourceReference = bundleContext.getServiceReference(ResourceManagementService.class.getName());\r\n        resourceService = (ResourceManagementService) bundleContext.getService(resourceReference);\r\n    }\r\n    return resourceService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.replacement.metacafe.ReplacementServiceMetacafeImpl.getReplacement",
	"Comment": "replaces the metacafe video links with their corresponding thumbnails.",
	"Method": "String getReplacement(String sourceString){\r\n    final Pattern p = Pattern.compile(\"\\\\/watch\\\\/([a-zA-Z0-9_\\\\-]+)(\\\\/[a-zA-Z0-9_\\\\-\\\\/]+)*\", Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\r\n    Matcher m = p.matcher(sourceString);\r\n    String thumbUrl = sourceString;\r\n    while (m.find()) thumbUrl = \"http://www.metacafe.com/thumb/\" + m.group(1) + \".jpg\";\r\n    return thumbUrl;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.ContactGibberishImpl.setPresenceStatus",
	"Comment": "sets gibberishpresencestatus as the presencestatus that thiscontact is currently in.",
	"Method": "void setPresenceStatus(PresenceStatus gibberishPresenceStatus){\r\n    this.presenceStatus = gibberishPresenceStatus;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWindowManager.getChatContainer",
	"Comment": "gets a chatcontainer instance. if there is no existingchatcontainer or chats are configured to be displayed in theirown windows instead of arranged in tabs in a single window, creates anew chat container.",
	"Method": "ChatContainer getChatContainer(){\r\n    ChatContainer chatContainer = GuiActivator.getUIService().getSingleWindowContainer();\r\n    if (chatContainer != null)\r\n        return chatContainer;\r\n    if (ConfigurationUtils.isMultiChatWindowEnabled()) {\r\n        Iterator<ChatPanel> chatPanelsIter = chatPanels.iterator();\r\n        if (chatPanelsIter.hasNext())\r\n            chatContainer = chatPanelsIter.next().getChatContainer();\r\n        else {\r\n            chatContainer = new ChatWindow();\r\n            GuiActivator.getUIService().registerExportedWindow((ExportedWindow) chatContainer);\r\n        }\r\n    } else\r\n        chatContainer = new ChatWindow();\r\n    return chatContainer;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetFileTransferJabberImpl.parseJabberStatus",
	"Comment": "parses the given jabber status to a filetransfer interfacestatus.",
	"Method": "int parseJabberStatus(Status jabberStatus){\r\n    if (jabberStatus.equals(Status.complete))\r\n        return FileTransferStatusChangeEvent.COMPLETED;\r\n    else if (jabberStatus.equals(Status.cancelled))\r\n        return FileTransferStatusChangeEvent.CANCELED;\r\n    else if (jabberStatus.equals(Status.in_progress) || jabberStatus.equals(Status.negotiated))\r\n        return FileTransferStatusChangeEvent.IN_PROGRESS;\r\n    else if (jabberStatus.equals(Status.error))\r\n        return FileTransferStatusChangeEvent.FAILED;\r\n    else if (jabberStatus.equals(Status.refused))\r\n        return FileTransferStatusChangeEvent.REFUSED;\r\n    else if (jabberStatus.equals(Status.negotiating_transfer) || jabberStatus.equals(Status.negotiating_stream))\r\n        return FileTransferStatusChangeEvent.PREPARING;\r\n    else\r\n        return FileTransferStatusChangeEvent.WAITING;\r\n}"
}, {
	"Path": "net.librec.conf.Configuration.getTrimmedStrings",
	"Comment": "get the comma delimited values of the name property as anarray of strings, trimmed of the leading and trailingwhitespace. if no such property is specified then an empty array isreturned.",
	"Method": "String[] getTrimmedStrings(String name){\r\n    String valueString = get(name);\r\n    return StringUtil.getTrimmedStrings(valueString);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.ldap.configform.DirectorySettingsForm.close",
	"Comment": "all functions implemented in this method will be invoked when userpresses the escape key.",
	"Method": "void close(boolean escaped){\r\n    cancelBtn.doClick();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.conference.ConferencePeerPanel.getCall",
	"Comment": "gets the call associated with this instance. if this instancedepicts the local peer, it was initialized with a specific callwhich represents the local peer. if this instance depicts an actualcallpeer, its associated call is returned.",
	"Method": "Call getCall(){\r\n    return (callPeer == null) ? call : callPeer.getCall();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.gibberishaccregwizz.GibberishAccountRegistration.setRememberPassword",
	"Comment": "sets the rememberpassword value of this gibberish account registration.",
	"Method": "void setRememberPassword(boolean rememberPassword){\r\n    this.rememberPassword = rememberPassword;\r\n}"
}, {
	"Path": "net.librec.math.algorithm.Randoms.poisson",
	"Comment": "return an integer with a poisson distribution with mean lambda.",
	"Method": "int poisson(double lambda){\r\n    int k = 0;\r\n    double p = 1.0;\r\n    double L = Math.exp(-lambda);\r\n    do {\r\n        k++;\r\n        p *= uniform();\r\n    } while (p >= L);\r\n    return k - 1;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.account.Account.getEnableCheckBox",
	"Comment": "returns the enable check box corresponding to this account.",
	"Method": "JCheckBox getEnableCheckBox(){\r\n    return enableCheckBox;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractFileTransfer.addProgressListener",
	"Comment": "adds the given filetransferprogresslistener to listen forstatus changes on this file transfer.",
	"Method": "void addProgressListener(FileTransferProgressListener listener){\r\n    synchronized (progressListeners) {\r\n        if (!progressListeners.contains(listener)) {\r\n            this.progressListeners.add(listener);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.librec.eval.ranking.AveragePrecisionEvaluator.evaluate",
	"Comment": "evaluate on the test set with the the list of recommended items.",
	"Method": "double evaluate(RecommendedList groundTruthList,RecommendedList recommendedList){\r\n    double totalPrecision = 0.0;\r\n    int numContext = groundTruthList.size();\r\n    int nonZeroContext = 0;\r\n    for (int contextIdx = 0; contextIdx < numContext; ++contextIdx) {\r\n        Set<Integer> testSetByContext = groundTruthList.getKeySetByContext(contextIdx);\r\n        if (testSetByContext.size() > 0) {\r\n            List<KeyValue<Integer, Double>> recommendListByContext = recommendedList.getKeyValueListByContext(contextIdx);\r\n            int numHits = 0;\r\n            int topK = this.topN <= recommendListByContext.size() ? this.topN : recommendListByContext.size();\r\n            double tempPrecision = 0.0d;\r\n            for (int indexOfKey = 0; indexOfKey < topK; ++indexOfKey) {\r\n                int key = recommendListByContext.get(indexOfKey).getKey();\r\n                if (testSetByContext.contains(key)) {\r\n                    numHits++;\r\n                    tempPrecision += 1.0 * numHits / (indexOfKey + 1);\r\n                }\r\n            }\r\n            if (topK != 0) {\r\n                totalPrecision += tempPrecision / (testSetByContext.size() < topK ? testSetByContext.size() : topK);\r\n                nonZeroContext++;\r\n            }\r\n        }\r\n    }\r\n    return nonZeroContext > 0 ? totalPrecision / nonZeroContext : 0.0d;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SwingWorker.get",
	"Comment": "return the value created by the construct method.returns null if either the constructing thread or the currentthread was interrupted before a value was produced.",
	"Method": "Object get(){\r\n    Future<?> future;\r\n    synchronized (this) {\r\n        future = this.future;\r\n    }\r\n    Object value = null;\r\n    if (future != null) {\r\n        boolean interrupted = false;\r\n        do {\r\n            try {\r\n                value = future.get();\r\n                break;\r\n            } catch (CancellationException ce) {\r\n                break;\r\n            } catch (ExecutionException ee) {\r\n                break;\r\n            } catch (InterruptedException ie) {\r\n                interrupted = true;\r\n            }\r\n        } while (true);\r\n        if (interrupted)\r\n            Thread.currentThread().interrupt();\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.history.HistoryImpl.setHistoryRecordsStructure",
	"Comment": "sets the given structure to be the new history recordsstructure used in this history implementation.",
	"Method": "void setHistoryRecordsStructure(HistoryRecordStructure structure){\r\n    this.historyRecordStructure = structure;\r\n    try {\r\n        File dbDatFile = new File(directory, HistoryServiceImpl.DATA_FILE);\r\n        DBStructSerializer dbss = new DBStructSerializer(historyServiceImpl);\r\n        dbss.writeHistory(dbDatFile, this);\r\n    } catch (IOException e) {\r\n        log.debug(\"Could not create new history structure\");\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.RtpDescriptionPacketExtension.getBandwidth",
	"Comment": "returns an optional bandwidth element that specifies the allowable orpreferred bandwidth for use by this application type.",
	"Method": "BandwidthPacketExtension getBandwidth(){\r\n    return bandwidth;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.contactlist.TestMetaContactGroup.testGetGroupName",
	"Comment": "checks whether the name of the meta group has been properly initialized.",
	"Method": "void testGetGroupName(){\r\n    assertEquals(\"grp: \" + metaGroup + \" had the wrong name.\", MetaContactListServiceLick.topLevelGroupName, metaGroup.getGroupName());\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaAwareCallConference.addMediaServicePropertyChangeListener",
	"Comment": "adds a specific propertychangelistener to be notified aboutpropertychangeevents fired by the current mediaserviceimplementation. the implementation adds a weakreference to thespecified listener because mediaawarecallconferenceis unable to determine when the propertychangelistener is to beremoved.",
	"Method": "void addMediaServicePropertyChangeListener(PropertyChangeListener listener){\r\n    if (mediaServicePropertyChangeListener == null) {\r\n        final MediaService mediaService = ProtocolMediaActivator.getMediaService();\r\n        if (mediaService != null) {\r\n            mediaServicePropertyChangeListener = new WeakPropertyChangeListener() {\r\n                @Override\r\n                protected void addThisToNotifier() {\r\n                    mediaService.addPropertyChangeListener(this);\r\n                }\r\n                @Override\r\n                protected void removeThisFromNotifier() {\r\n                    mediaService.removePropertyChangeListener(this);\r\n                }\r\n            };\r\n        }\r\n    }\r\n    if (mediaServicePropertyChangeListener != null) {\r\n        mediaServicePropertyChangeListener.addPropertyChangeListener(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaAwareCallConference.addMediaServicePropertyChangeListener",
	"Comment": "adds a specific propertychangelistener to be notified aboutpropertychangeevents fired by the current mediaserviceimplementation. the implementation adds a weakreference to thespecified listener because mediaawarecallconferenceis unable to determine when the propertychangelistener is to beremoved.",
	"Method": "void addMediaServicePropertyChangeListener(PropertyChangeListener listener){\r\n    mediaService.addPropertyChangeListener(this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaAwareCallConference.addMediaServicePropertyChangeListener",
	"Comment": "adds a specific propertychangelistener to be notified aboutpropertychangeevents fired by the current mediaserviceimplementation. the implementation adds a weakreference to thespecified listener because mediaawarecallconferenceis unable to determine when the propertychangelistener is to beremoved.",
	"Method": "void addMediaServicePropertyChangeListener(PropertyChangeListener listener){\r\n    mediaService.removePropertyChangeListener(this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetServerStoredAccountInfoIcqImpl.isDetailClassEditable",
	"Comment": "determines whether the underlying implementation supports editionof this detail class.",
	"Method": "boolean isDetailClassEditable(Class<? extends GenericDetail> detailClass){\r\n    return isDetailClassSupported(detailClass) && ImageDetail.class.isAssignableFrom(detailClass);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomIrcImpl.removelocalUserRoleListener",
	"Comment": "removes a listener that was being notified of changes in our role in thischat room such as us being granted operator.",
	"Method": "void removelocalUserRoleListener(ChatRoomLocalUserRoleListener listener){\r\n    synchronized (localUserRoleListeners) {\r\n        if (localUserRoleListeners.contains(listener)) {\r\n            localUserRoleListeners.remove(listener);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.msoutlook.MsOutlookAddrBookSourceContact.setDetails",
	"Comment": "changes the details list with the supplied one. called when the outlookdatabase for this source contact has been updated.",
	"Method": "void setDetails(List<ContactDetail> details){\r\n    synchronized (this) {\r\n        contactDetails.clear();\r\n        contactDetails.addAll(details);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.gibberish.TestOperationSetPersistentPresence.postTestCreateGroup",
	"Comment": "creates a group in the server stored contact list, makes sure that thecorresponding event has been generated and verifies that the group isin the list.",
	"Method": "void postTestCreateGroup(){\r\n    fixture.clearProvidersLists();\r\n    Object o = new Object();\r\n    synchronized (o) {\r\n        o.wait(3000);\r\n    }\r\n    logger.trace(\"testing creation of server stored groups\");\r\n    GroupChangeCollector groupChangeCollector = new GroupChangeCollector();\r\n    opSetPersPresence1.addServerStoredGroupChangeListener(groupChangeCollector);\r\n    opSetPersPresence1.createServerStoredContactGroup(opSetPersPresence1.getServerStoredContactListRoot(), testGroupName);\r\n    groupChangeCollector.waitForEvent(10000);\r\n    opSetPersPresence1.removeServerStoredGroupChangeListener(groupChangeCollector);\r\n    assertEquals(\"Collected Group Change events: \", 1, groupChangeCollector.collectedEvents.size());\r\n    assertEquals(\"Group name.\", testGroupName, ((ServerStoredGroupEvent) groupChangeCollector.collectedEvents.get(0)).getSourceGroup().getGroupName());\r\n    ContactGroup group = opSetPersPresence1.getServerStoredContactListRoot().getGroup(testGroupName);\r\n    assertNotNull(\"A newly created group was not in the contact list.\", group);\r\n    assertEquals(\"New group name\", testGroupName, group.getGroupName());\r\n    try {\r\n        opSetPersPresence1.subscribe(group, fixture.userID2);\r\n        synchronized (o) {\r\n            o.wait(1500);\r\n        }\r\n    } catch (Exception ex) {\r\n        fail(\"error adding entry to group : \" + group.getGroupName() + \" \" + ex.getMessage());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.AbstractPacketExtension.removeAttribute",
	"Comment": "removes the attribute with the specified name from the list ofattributes registered with this packet extension.",
	"Method": "void removeAttribute(String name){\r\n    synchronized (attributes) {\r\n        attributes.remove(name);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomJabberImpl.sendMessage",
	"Comment": "sends the message to the destination indicated by theto contact.",
	"Method": "void sendMessage(Message message){\r\n    try {\r\n        assertConnected();\r\n        org.jivesoftware.smack.packet.Message msg = new org.jivesoftware.smack.packet.Message();\r\n        msg.setBody(message.getContent());\r\n        MessageEventManager.addNotificationsRequests(msg, true, false, false, true);\r\n        multiUserChat.sendMessage(message.getContent());\r\n    } catch (XMPPException ex) {\r\n        logger.error(\"Failed to send message \" + message, ex);\r\n        throw new OperationFailedException(\"Failed to send message \" + message, OperationFailedException.GENERAL_ERROR, ex);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetPersistentPresenceIcqImpl.getPresenceStatus",
	"Comment": "returns a presencestatus instance representing the state this provideris currently in.",
	"Method": "PresenceStatus getPresenceStatus(){\r\n    return statusLongToPresenceStatus(currentIcqStatus);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetTelephonyConferencingJabberImpl.unsubscribeForCoinPackets",
	"Comment": "unsubscribes us from notifications about incoming coin packets.",
	"Method": "void unsubscribeForCoinPackets(){\r\n    Connection connection = parentProvider.getConnection();\r\n    if (connection != null)\r\n        connection.removePacketListener(this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.UIServiceImpl.createCall",
	"Comment": "creates a new call with a specific set of participants.the current implementation provided by uiserviceimpl supports asingle participant at the time of this writing.",
	"Method": "void createCall(String[] participants){\r\n    if (participants.length == 1)\r\n        CallManager.createCall(participants[0], null);\r\n    else\r\n        throw new IllegalArgumentException(\"participants\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.phonenumbercontactsource.PNContactSourceActivator.getPhoneNumberProviders",
	"Comment": "returns a list of all currently registered server stored contact infoproviders.",
	"Method": "List<ProtocolProviderService> getPhoneNumberProviders(){\r\n    if (phoneProviders != null)\r\n        return phoneProviders;\r\n    phoneProviders = new LinkedList<ProtocolProviderService>();\r\n    ppRegListener = new ProtocolProviderRegistrationListener();\r\n    bundleContext.addServiceListener(new ProtocolProviderServiceRegListener());\r\n    ServiceReference[] serRefs = null;\r\n    try {\r\n        serRefs = bundleContext.getServiceReferences(ProtocolProviderFactory.class.getName(), null);\r\n    } catch (InvalidSyntaxException e) {\r\n        logger.error(\"LoginManager : \" + e);\r\n    }\r\n    if (serRefs != null) {\r\n        for (ServiceReference serRef : serRefs) {\r\n            ProtocolProviderFactory providerFactory = (ProtocolProviderFactory) bundleContext.getService(serRef);\r\n            ProtocolProviderService protocolProvider;\r\n            for (AccountID accountID : providerFactory.getRegisteredAccounts()) {\r\n                serRef = providerFactory.getProviderForAccount(accountID);\r\n                protocolProvider = (ProtocolProviderService) bundleContext.getService(serRef);\r\n                handleProviderAdded(protocolProvider);\r\n            }\r\n        }\r\n    }\r\n    return phoneProviders;\r\n}"
}, {
	"Path": "net.librec.math.structure.SequentialAccessSparseMatrix.constructMap",
	"Comment": "construct the index map between row matrix and column matrix",
	"Method": "void constructMap(){\r\n    Int2ObjectOpenHashMap<Int2IntOpenHashMap> rowPositionMap = new Int2ObjectOpenHashMap();\r\n    for (int rowIndex = 0; rowIndex < rowSize(); rowIndex++) {\r\n        SequentialSparseVector tempRowVector = row(rowIndex);\r\n        Int2IntOpenHashMap tempPositionMap = new Int2IntOpenHashMap();\r\n        for (Vector.VectorEntry vectorEntry : tempRowVector) {\r\n            tempPositionMap.put(vectorEntry.index(), vectorEntry.position());\r\n        }\r\n        rowPositionMap.put(rowIndex, tempPositionMap);\r\n    }\r\n    columnToRowPositionMap = new int[columnSize()][];\r\n    for (int columnIndex = 0; columnIndex < columnSize(); columnIndex++) {\r\n        SequentialSparseVector tempRowVector = column(columnIndex);\r\n        columnToRowPositionMap[columnIndex] = new int[tempRowVector.getNumEntries()];\r\n        for (Vector.VectorEntry vectorEntry : tempRowVector) {\r\n            columnToRowPositionMap[columnIndex][vectorEntry.position()] = rowPositionMap.get(vectorEntry.index()).get(columnIndex);\r\n        }\r\n    }\r\n    Int2ObjectOpenHashMap<Int2IntOpenHashMap> columnPositionMap = new Int2ObjectOpenHashMap();\r\n    for (int columnIndex = 0; columnIndex < columnSize(); columnIndex++) {\r\n        SequentialSparseVector tempColumnVector = column(columnIndex);\r\n        Int2IntOpenHashMap tempPositionMap = new Int2IntOpenHashMap();\r\n        for (Vector.VectorEntry vectorEntry : tempColumnVector) {\r\n            tempPositionMap.put(vectorEntry.index(), vectorEntry.position());\r\n        }\r\n        columnPositionMap.put(columnIndex, tempPositionMap);\r\n    }\r\n    rowToColumnPositionMap = new int[rowSize()][];\r\n    for (int rowIndex = 0; rowIndex < rowSize(); rowIndex++) {\r\n        SequentialSparseVector tempRowVector = row(rowIndex);\r\n        rowToColumnPositionMap[rowIndex] = new int[tempRowVector.getNumEntries()];\r\n        for (Vector.VectorEntry vectorEntry : tempRowVector) {\r\n            rowToColumnPositionMap[rowIndex][vectorEntry.position()] = columnPositionMap.get(vectorEntry.index()).get(rowIndex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ChatConferenceCallDialog.actionPerformed",
	"Comment": "handles the actionevent triggered when one user clickson one of the buttons.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    Object source = e.getSource();\r\n    if (source instanceof JButton) {\r\n        if (source.equals(okButton)) {\r\n            if (createConferenceButton.isSelected()) {\r\n                createConference();\r\n            } else {\r\n                joinConference();\r\n            }\r\n        } else if (source.equals(endConference)) {\r\n            chatRoom.publishConference(null, null);\r\n        }\r\n        this.setVisible(false);\r\n    } else if (source instanceof JRadioButton) {\r\n        if (source.equals(createConferenceButton) || source.equals(joinConferenceButton)) {\r\n            updateView();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.IcqActivator.getConfigurationService",
	"Comment": "returns a reference to a configurationservice implementation currentlyregistered in the bundle context or null if no such implementation wasfound.",
	"Method": "ConfigurationService getConfigurationService(){\r\n    if (configurationService == null) {\r\n        ServiceReference confReference = bundleContext.getServiceReference(ConfigurationService.class.getName());\r\n        configurationService = (ConfigurationService) bundleContext.getService(confReference);\r\n    }\r\n    return configurationService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.PayloadTypePacketExtension.getParameters",
	"Comment": "returns a reference to the the list of parameters currentlyregistered for this payload type.",
	"Method": "List<ParameterPacketExtension> getParameters(){\r\n    return getChildExtensionsOfType(ParameterPacketExtension.class);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.history.HistoryReaderImpl.filterFilesByDate",
	"Comment": "used to limit the files if any starting or ending date existso only few files to be searched.",
	"Method": "Vector<String> filterFilesByDate(Iterator<String> filelist,Date startDate,Date endDate,Vector<String> filterFilesByDate,Iterator<String> filelist,Date startDate,Date endDate,boolean reverseOrder){\r\n    if (startDate == null && endDate == null) {\r\n        Vector<String> result = new Vector<String>();\r\n        while (filelist.hasNext()) {\r\n            result.add(filelist.next());\r\n        }\r\n        Collections.sort(result, new Comparator<String>() {\r\n            public int compare(String o1, String o2) {\r\n                if (reverseOrder)\r\n                    return o2.compareTo(o1);\r\n                else\r\n                    return o1.compareTo(o2);\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n    TreeSet<Long> files = new TreeSet<Long>();\r\n    while (filelist.hasNext()) {\r\n        String filename = filelist.next();\r\n        files.add(Long.parseLong(filename.substring(0, filename.length() - 4)));\r\n    }\r\n    TreeSet<Long> resultAsLong = new TreeSet<Long>();\r\n    if (files.size() == 0) {\r\n        return new Vector<String>();\r\n    }\r\n    Long startLong;\r\n    Long endLong;\r\n    if (startDate == null)\r\n        startLong = Long.MIN_VALUE;\r\n    else\r\n        startLong = startDate.getTime();\r\n    if (endDate == null)\r\n        endLong = Long.MAX_VALUE;\r\n    else\r\n        endLong = endDate.getTime();\r\n    for (Long f : files) {\r\n        if (startLong <= f && f <= endLong) {\r\n            resultAsLong.add(f);\r\n        }\r\n    }\r\n    if (!files.isEmpty() && files.first() <= startLong) {\r\n        SortedSet<Long> setBeforeTheInterval = files.subSet(files.first(), true, startLong, true);\r\n        if (!setBeforeTheInterval.isEmpty())\r\n            resultAsLong.add(setBeforeTheInterval.last());\r\n    }\r\n    Vector<String> result = new Vector<String>();\r\n    Iterator<Long> iter = resultAsLong.iterator();\r\n    while (iter.hasNext()) {\r\n        Long item = iter.next();\r\n        result.add(item.toString() + \".xml\");\r\n    }\r\n    Collections.sort(result, new Comparator<String>() {\r\n        public int compare(String o1, String o2) {\r\n            if (reverseOrder)\r\n                return o2.compareTo(o1);\r\n            else\r\n                return o1.compareTo(o2);\r\n        }\r\n    });\r\n    return result;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.history.HistoryReaderImpl.filterFilesByDate",
	"Comment": "used to limit the files if any starting or ending date existso only few files to be searched.",
	"Method": "Vector<String> filterFilesByDate(Iterator<String> filelist,Date startDate,Date endDate,Vector<String> filterFilesByDate,Iterator<String> filelist,Date startDate,Date endDate,boolean reverseOrder){\r\n    if (reverseOrder)\r\n        return o2.compareTo(o1);\r\n    else\r\n        return o1.compareTo(o2);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.history.HistoryReaderImpl.filterFilesByDate",
	"Comment": "used to limit the files if any starting or ending date existso only few files to be searched.",
	"Method": "Vector<String> filterFilesByDate(Iterator<String> filelist,Date startDate,Date endDate,Vector<String> filterFilesByDate,Iterator<String> filelist,Date startDate,Date endDate,boolean reverseOrder){\r\n    if (reverseOrder)\r\n        return o2.compareTo(o1);\r\n    else\r\n        return o1.compareTo(o2);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockPersistentPresenceOperationSet.getCurrentStatusMessage",
	"Comment": "returns the status message that was last set throughsetcurrentstatusmessage.",
	"Method": "String getCurrentStatusMessage(){\r\n    return statusMessage;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.SearchField.filterQuerySucceeded",
	"Comment": "indicates that the given query has finished with success, i.e.the filter has returned results.",
	"Method": "void filterQuerySucceeded(FilterQuery query){\r\n    if (currentFilterQuery.equals(query))\r\n        filterQueryFinished(query, true);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.TestOperationSetPresence.testChangingStateToDnd",
	"Comment": "verify that changing state to dnd works as supposed to and that itgenerates the corresponding event.",
	"Method": "void testChangingStateToDnd(){\r\n    subtestStateTransition(IcqStatusEnum.DO_NOT_DISTURB);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatTransferHandler.canImport",
	"Comment": "indicates whether a component will accept an import of the givenset of data flavors prior to actually attempting to import it. we returntrue to indicate that the transfer with at least one of thegiven flavors would work and false to reject the transfer.",
	"Method": "boolean canImport(JComponent comp,DataFlavor flavor){\r\n    for (DataFlavor f : flavor) {\r\n        if (f.equals(uiContactDataFlavor) || f.equals(uriListFlavor))\r\n            return true;\r\n    }\r\n    return super.canImport(comp, flavor);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.DialPadFieldUI.paintSafely",
	"Comment": "implements parent paintsafely method and enables antialiasing.",
	"Method": "void paintSafely(Graphics g){\r\n    customPaintBackground(g);\r\n    super.paintSafely(g);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatSession.removeLocalUserRoleListener",
	"Comment": "removes the given chatroomlocaluserrolelistener from thecontained chat room role listeners.",
	"Method": "void removeLocalUserRoleListener(ChatRoomLocalUserRoleListener l){\r\n    chatRoomWrapper.getChatRoom().removelocalUserRoleListener(l);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageHistoryServiceImpl.addHistorySearchProgressListeners",
	"Comment": "add the registered messagehistorysearchprogresslistenersto the given historyreader",
	"Method": "void addHistorySearchProgressListeners(HistoryReader reader,int countRecords){\r\n    synchronized (progressListeners) {\r\n        Iterator<HistorySearchProgressListener> iter = progressListeners.values().iterator();\r\n        while (iter.hasNext()) {\r\n            SearchProgressWrapper l = (SearchProgressWrapper) iter.next();\r\n            l.setCurrentValues(reader, countRecords);\r\n            reader.addSearchProgressListener(l);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.otr.ScOtrKeyManagerImpl.getListeners",
	"Comment": "gets a copy of the list of scotrkeymanagerlisteners registeredwith this instance which may safely be iterated without the risk of aconcurrentmodificationexception.",
	"Method": "ScOtrKeyManagerListener[] getListeners(){\r\n    synchronized (listeners) {\r\n        return listeners.toArray(new ScOtrKeyManagerListener[listeners.size()]);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.TreeContactList.metaContactReceived",
	"Comment": "indicates that a metacontact has been received for a search inthe metacontactlistservice.",
	"Method": "void metaContactReceived(MetaContactQueryEvent event){\r\n    MetaContact metaContact = event.getMetaContact();\r\n    MetaContactGroup parentGroup = metaContact.getParentMetaContactGroup();\r\n    UIGroup uiGroup = null;\r\n    if (!MetaContactListSource.isRootGroup(parentGroup)) {\r\n        synchronized (parentGroup) {\r\n            uiGroup = MetaContactListSource.getUIGroup(parentGroup);\r\n            if (uiGroup == null)\r\n                uiGroup = MetaContactListSource.createUIGroup(parentGroup);\r\n        }\r\n    }\r\n    UIContactImpl newUIContact;\r\n    synchronized (metaContact) {\r\n        newUIContact = MetaContactListSource.getUIContact(metaContact);\r\n        if (newUIContact == null) {\r\n            newUIContact = MetaContactListSource.createUIContact(metaContact);\r\n        }\r\n    }\r\n    addContact(event.getQuerySource(), newUIContact, uiGroup, true);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ServerStoredContactListIcqImpl.createGroup",
	"Comment": "creates the specified group on the server stored contact list.",
	"Method": "void createGroup(String groupName){\r\n    if (logger.isTraceEnabled())\r\n        logger.trace(\"Creating group: \" + groupName);\r\n    buddyList.addGroup(groupName);\r\n    if (logger.isTraceEnabled())\r\n        logger.trace(\"Group \" + groupName + \" created.\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.ircaccregwizz.FirstWizardPage.getIdentifier",
	"Comment": "implements the wizardpage.getidentifier to returnthis page identifier.",
	"Method": "Object getIdentifier(){\r\n    return FIRST_PAGE_IDENTIFIER;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.WhiteboardSessionJabberImpl.getWhiteboardObjects",
	"Comment": "returns the whiteboardobjects in this whiteboard session.",
	"Method": "Vector<WhiteboardObject> getWhiteboardObjects(){\r\n    return whiteboardObjects;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.FailoverConnectionMonitor.getPrimaryServerRecord",
	"Comment": "returns the primary server record, the one with highest priority.",
	"Method": "SRVRecord getPrimaryServerRecord(SRVRecord[] recs){\r\n    if (recs.length >= 1) {\r\n        SRVRecord primary = recs[0];\r\n        for (SRVRecord srv : recs) {\r\n            if (srv.getPriority() < primary.getPriority()) {\r\n                primary = srv;\r\n            }\r\n        }\r\n        return primary;\r\n    } else\r\n        return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.JabberAccountCreationForm.createJabberAccount",
	"Comment": "connects to the chosen server and creates a new account with smack.",
	"Method": "boolean createJabberAccount(String server,int port,String username,String password){\r\n    try {\r\n        ConnectionConfiguration config = new ConnectionConfiguration(server, port);\r\n        xmppConnection = new XMPPConnection(config);\r\n        xmppConnection.connect();\r\n        accountManager = new AccountManager(xmppConnection);\r\n        accountManager.createAccount(username, password);\r\n        return true;\r\n    } catch (XMPPException exc) {\r\n        logger.error(exc);\r\n        if (exc.getXMPPError() != null && exc.getXMPPError().getCode() == 409) {\r\n            showErrorMessage(Resources.getString(\"plugin.jabberaccregwizz.USER_EXISTS_ERROR\"));\r\n            logger.error(\"Error when created a new Jabber account :\" + \" user already exist\");\r\n        } else {\r\n            showErrorMessage(Resources.getResources().getI18NString(\"plugin.jabberaccregwizz.UNKNOWN_XMPP_ERROR\", new String[] { exc.getMessage() }));\r\n        }\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetServerStoredAccountInfoIcqImpl.getLanguageCode",
	"Comment": "returns the index stored on the server corresponding the given locale",
	"Method": "int getLanguageCode(Locale locale){\r\n    for (int i = 1; i < spokenLanguages.length; i++) {\r\n        if (spokenLanguages[i].equals(locale))\r\n            return i;\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.FormattedTextBuilder.done",
	"Comment": "finish building the text string. close outstanding control charformatting and returns the result.",
	"Method": "String done(){\r\n    cancelAll();\r\n    return this.text.toString();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.dtmf.DTMFInfo.startSendingDTMF",
	"Comment": "saves the tone we need to send and its start time. with start time wecan compute the duration later when we need to send the dtmf.",
	"Method": "void startSendingDTMF(CallPeerSipImpl callPeer,DTMFTone tone){\r\n    if (currentlyTransmittingTones.contains(callPeer))\r\n        throw new IllegalStateException(\"Error starting dtmf tone, already started\");\r\n    currentlyTransmittingTones.put(callPeer, new Object[] { tone, System.currentTimeMillis() });\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.notifsource.NotificationContact.providerStatusChanged",
	"Comment": "refresh the notification contact corresponding the the attached providerin order to better reflect its status.",
	"Method": "void providerStatusChanged(ProviderPresenceStatusChangeEvent evt){\r\n    TreeContactList contactList = GuiActivator.getContactList();\r\n    contactList.refreshContact(this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ProtocolProviderServiceIrcImpl.setCurrentRegistrationState",
	"Comment": "sets the current registration state of this protocol provider.",
	"Method": "void setCurrentRegistrationState(RegistrationState regState,int reason){\r\n    final RegistrationState oldState = this.currentRegistrationState;\r\n    this.currentRegistrationState = regState;\r\n    fireRegistrationStateChanged(oldState, this.currentRegistrationState, reason, null);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.gibberishaccregwizz.FirstWizardPage.getIdentifier",
	"Comment": "implements the wizardpage.getidentifier to returnthis page identifier.",
	"Method": "Object getIdentifier(){\r\n    return FIRST_PAGE_IDENTIFIER;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.icqaccregwizz.IcqAccountRegistrationWizard.getProtocolName",
	"Comment": "returns the protocol name that will be shown in the list, where userwill choose the protocol to register to.",
	"Method": "String getProtocolName(){\r\n    return Resources.getString(\"plugin.icqaccregwizz.PROTOCOL_NAME\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.SecurityAccountRegistration.loadAccount",
	"Comment": "loads security properties from the account with the given identifier.",
	"Method": "void loadAccount(AccountID accountID){\r\n    setDefaultEncryption(accountID.getAccountPropertyBoolean(ProtocolProviderFactory.DEFAULT_ENCRYPTION, true));\r\n    encryptionProtocols = new HashMap<String, Integer>();\r\n    encryptionProtocolStatus = new HashMap<String, Boolean>();\r\n    Map<String, Integer> srcEncryptionProtocols = accountID.getIntegerPropertiesByPrefix(ProtocolProviderFactory.ENCRYPTION_PROTOCOL, true);\r\n    Map<String, Boolean> srcEncryptionProtocolStatus = accountID.getBooleanPropertiesByPrefix(ProtocolProviderFactory.ENCRYPTION_PROTOCOL_STATUS, true, false);\r\n    int prefixeLength = ProtocolProviderFactory.ENCRYPTION_PROTOCOL.length() + 1;\r\n    for (Map.Entry<String, Integer> e : srcEncryptionProtocols.entrySet()) {\r\n        String name = e.getKey().substring(prefixeLength);\r\n        if (isExistingEncryptionProtocol(name)) {\r\n            encryptionProtocols.put(name, e.getValue());\r\n            boolean enabled = srcEncryptionProtocolStatus.get(ProtocolProviderFactory.ENCRYPTION_PROTOCOL_STATUS + \".\" + name);\r\n            encryptionProtocolStatus.put(name, enabled);\r\n        }\r\n    }\r\n    setSipZrtpAttribute(accountID.getAccountPropertyBoolean(ProtocolProviderFactory.DEFAULT_SIPZRTP_ATTRIBUTE, true));\r\n    setSavpOption(accountID.getAccountPropertyInt(ProtocolProviderFactory.SAVP_OPTION, ProtocolProviderFactory.SAVP_OFF));\r\n    setSDesCipherSuites(accountID.getAccountPropertyString(ProtocolProviderFactory.SDES_CIPHER_SUITES));\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractConferenceMember.setVideoStatus",
	"Comment": "sets the status in both directions of the video rtp stream from the pointof view of this conferencemember.",
	"Method": "void setVideoStatus(MediaDirection status){\r\n    if (status == null)\r\n        status = MediaDirection.INACTIVE;\r\n    if (this.videoStatus != status) {\r\n        MediaDirection oldValue = this.videoStatus;\r\n        this.videoStatus = status;\r\n        firePropertyChange(VIDEO_STATUS_PROPERTY_NAME, oldValue, this.videoStatus);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetFileTransferJabberImpl.getMaximumFileLength",
	"Comment": "returns the maximum file length supported by the protocol in bytes.supports up to 2gb.",
	"Method": "long getMaximumFileLength(){\r\n    return 2147483648l;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl.getKnownEventsList",
	"Comment": "returns the list of all the registered events for this provider.",
	"Method": "List<String> getKnownEventsList(){\r\n    return this.registeredEvents;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ServerStoredContactListSipImpl.getContactType",
	"Comment": "access the contact type. if none specified null is returned.",
	"Method": "String getContactType(Contact contact){\r\n    if (!(contact instanceof ContactSipImpl)) {\r\n        String errorMessage = String.format(\"Contact %1s does not seem to belong to this protocol's \" + \"contact list\", contact.getAddress());\r\n        throw new IllegalArgumentException(errorMessage);\r\n    }\r\n    ContactSipImpl contactSip = (ContactSipImpl) contact;\r\n    List<Element> anyElements = contactSip.getAny();\r\n    for (Element e : anyElements) {\r\n        if (e.getNodeName().equals(CONTACT_TYPE_ELEMENT_NAME))\r\n            return XMLUtils.getText(e);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatTransport.allowsSmsMessage",
	"Comment": "returns true if this chat transport supports smsmessaging, otherwise returns false.",
	"Method": "boolean allowsSmsMessage(){\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.history.InteractiveHistoryReaderImpl.findByKeyword",
	"Comment": "searches the history for all records containing the keyword.",
	"Method": "HistoryQuery findByKeyword(String keyword,String field,int recordCount){\r\n    return findByKeywords(new String[] { keyword }, field, recordCount);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.DialPanel.paintComponent",
	"Comment": "paints the main background image to the background of this dial panel.",
	"Method": "void paintComponent(Graphics g){\r\n    super.paintComponent(g);\r\n    Graphics2D g2 = (Graphics2D) g;\r\n    BufferedImage bgImage = ImageLoader.getImage(ImageLoader.MAIN_WINDOW_BACKGROUND);\r\n    if (bgImage != null) {\r\n        ResourceManagementService r = GuiActivator.getResources();\r\n        boolean isTextureBackground = Boolean.parseBoolean(r.getSettingsString(\"impl.gui.IS_CONTACT_LIST_TEXTURE_BG_ENABLED\"));\r\n        int width = getWidth(), height = getHeight();\r\n        if (isTextureBackground) {\r\n            Rectangle rect = new Rectangle(0, 0, bgImage.getWidth(null), bgImage.getHeight(null));\r\n            TexturePaint texture = new TexturePaint(bgImage, rect);\r\n            g2.setPaint(texture);\r\n            g2.fillRect(0, 0, width, height);\r\n        } else {\r\n            g.setColor(new Color(r.getColor(\"contactListBackground\")));\r\n            g.fillRect(0, 0, width, height);\r\n            g2.drawImage(bgImage, width - bgImage.getWidth(), height - bgImage.getHeight(), this);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.windowscleanshutdown.CleanShutdownActivator.getSystemActivityNotificationsService",
	"Comment": "gets a reference to a systemactivitynotificationsserviceimplementation currently registered in the bundle context.the returned reference to systemactivitynotificationsserviceis not being cached.",
	"Method": "SystemActivityNotificationsService getSystemActivityNotificationsService(BundleContext context){\r\n    ServiceReference ref = context.getServiceReference(SystemActivityNotificationsService.class.getName());\r\n    if (ref == null)\r\n        return null;\r\n    else\r\n        return (SystemActivityNotificationsService) context.getService(ref);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.history.HistoryQueryImpl.setStatus",
	"Comment": "sets this query status to the given querystatus and notifiesall interested listeners of the change.",
	"Method": "void setStatus(int queryStatus){\r\n    fireQueryStatusEvent(queryStatus);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.whiteboard.WhiteboardObjectPolyLineJabberImpl.getPoints",
	"Comment": "returns a list of all the whiteboardpoint instances that thiswhiteboardobject is composed of.",
	"Method": "List<WhiteboardPoint> getPoints(){\r\n    return this.listPoints;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.spellcheck.DocUnderliner.getEndChecker",
	"Comment": "provides a listener that prompts the last word to be checked when thecursor moves away from it.",
	"Method": "CaretListener getEndChecker(){\r\n    return this.endChecker;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockPersistentPresenceOperationSet.getNonPersistentGroup",
	"Comment": "returns the volatile group that we use when creating volatile contacts.",
	"Method": "MockContactGroup getNonPersistentGroup(){\r\n    String groupName = \"Not-In-Contactlist\";\r\n    for (int i = 0; i < contactListRoot.countSubgroups(); i++) {\r\n        MockContactGroup gr = (MockContactGroup) contactListRoot.getGroup(i);\r\n        if (!gr.isPersistent() && gr.getGroupName().equals(groupName))\r\n            return gr;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.IrcStack.determinePlainPassword",
	"Comment": "determine the correct plain irc password for the provided ircconfiguration.",
	"Method": "String determinePlainPassword(String password,ClientConfig config){\r\n    final String plainPass;\r\n    if (config.isVersion3Allowed() && config.getSASL() != null) {\r\n        plainPass = null;\r\n    } else {\r\n        plainPass = password;\r\n    }\r\n    return plainPass;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactListServiceImpl.resolveProtoPath",
	"Comment": "makes sure that directories in the whole path from the root to thespecified group have corresponding directories in the protocol indicatedby protoprovider. the method does not return before creatingall groups has completed.",
	"Method": "ContactGroup resolveProtoPath(ProtocolProviderService protoProvider,MetaContactGroupImpl metaGroup){\r\n    Iterator<ContactGroup> contactGroupsForProv = metaGroup.getContactGroupsForProvider(protoProvider);\r\n    if (contactGroupsForProv.hasNext()) {\r\n        return contactGroupsForProv.next();\r\n    }\r\n    MetaContactGroupImpl parentMetaGroup = (MetaContactGroupImpl) findParentMetaContactGroup(metaGroup);\r\n    if (parentMetaGroup == null) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Resolve failed at group\" + metaGroup);\r\n        throw new NullPointerException(\"Internal Error. Orphan group.\");\r\n    }\r\n    OperationSetPersistentPresence opSetPersPresence = protoProvider.getOperationSet(OperationSetPersistentPresence.class);\r\n    if (opSetPersPresence == null) {\r\n        return null;\r\n    }\r\n    ContactGroup parentProtoGroup;\r\n    if (parentMetaGroup.getParentMetaContactGroup() == null) {\r\n        parentProtoGroup = opSetPersPresence.getServerStoredContactListRoot();\r\n    } else {\r\n        parentProtoGroup = resolveProtoPath(protoProvider, parentMetaGroup);\r\n    }\r\n    BlockingGroupEventRetriever evtRetriever = new BlockingGroupEventRetriever(metaGroup.getGroupName());\r\n    opSetPersPresence.addServerStoredGroupChangeListener(evtRetriever);\r\n    addGroupToEventIgnoreList(metaGroup.getGroupName(), protoProvider);\r\n    try {\r\n        opSetPersPresence.createServerStoredContactGroup(parentProtoGroup, metaGroup.getGroupName());\r\n        evtRetriever.waitForEvent(CONTACT_LIST_MODIFICATION_TIMEOUT);\r\n    } catch (Exception ex) {\r\n        throw new MetaContactListException(\"failed to create contact group \" + metaGroup.getGroupName(), ex, MetaContactListException.CODE_NETWORK_ERROR);\r\n    } finally {\r\n        removeGroupFromEventIgnoreList(metaGroup.getGroupName(), protoProvider);\r\n        opSetPersPresence.removeServerStoredGroupChangeListener(evtRetriever);\r\n    }\r\n    if (evtRetriever.evt == null) {\r\n        throw new MetaContactListException(\"Failed to create a proto group named: \" + metaGroup.getGroupName(), null, MetaContactListException.CODE_NETWORK_ERROR);\r\n    }\r\n    metaGroup.addProtoGroup(evtRetriever.evt.getSourceGroup());\r\n    fireMetaContactGroupEvent(metaGroup, evtRetriever.evt.getSourceProvider(), evtRetriever.evt.getSourceGroup(), MetaContactGroupEvent.CONTACT_GROUP_ADDED_TO_META_GROUP);\r\n    return evtRetriever.evt.getSourceGroup();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetFileTransferIcqImpl.getMaximumFileLength",
	"Comment": "returns the maximum file length supported by the protocol in bytes.supports up to 2gb.",
	"Method": "long getMaximumFileLength(){\r\n    return 2147483648l;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.gibberish.TestOperationSetPersistentPresence.prepareContactList",
	"Comment": "create the contact list. later will be test to be sure that creating is ok",
	"Method": "void prepareContactList(){\r\n    fixture.clearProvidersLists();\r\n    Object o = new Object();\r\n    synchronized (o) {\r\n        o.wait(3000);\r\n    }\r\n    String contactList = System.getProperty(GibberishProtocolProviderServiceLick.CONTACT_LIST_PROPERTY_NAME, null);\r\n    logger.debug(\"The \" + GibberishProtocolProviderServiceLick.CONTACT_LIST_PROPERTY_NAME + \" property is set to=\" + contactList);\r\n    if (contactList == null || contactList.trim().length() < 6)\r\n        throw new IllegalArgumentException(\"The \" + GibberishProtocolProviderServiceLick.CONTACT_LIST_PROPERTY_NAME + \" property did not contain a contact list.\");\r\n    StringTokenizer tokenizer = new StringTokenizer(contactList, \" \\n\\t\");\r\n    logger.debug(\"tokens contained by the CL tokenized=\" + tokenizer.countTokens());\r\n    Hashtable<String, List<String>> contactListToCreate = new Hashtable<String, List<String>>();\r\n    while (tokenizer.hasMoreTokens()) {\r\n        String groupUinToken = tokenizer.nextToken();\r\n        int dotIndex = groupUinToken.indexOf(\".\");\r\n        if (dotIndex == -1) {\r\n            throw new IllegalArgumentException(groupUinToken + \" is not a valid Group.UIN token\");\r\n        }\r\n        String groupName = groupUinToken.substring(0, dotIndex);\r\n        String uin = groupUinToken.substring(dotIndex + 1);\r\n        if (groupName.trim().length() < 1 || uin.trim().length() < 4) {\r\n            throw new IllegalArgumentException(groupName + \" or \" + uin + \" are not a valid group name or Gibberish user id.\");\r\n        }\r\n        List<String> uinInThisGroup = contactListToCreate.get(groupName);\r\n        if (uinInThisGroup == null) {\r\n            uinInThisGroup = new ArrayList<String>();\r\n            contactListToCreate.put(groupName, uinInThisGroup);\r\n        }\r\n        uinInThisGroup.add(uin);\r\n    }\r\n    Enumeration<String> newGroupsEnum = contactListToCreate.keys();\r\n    while (newGroupsEnum.hasMoreElements()) {\r\n        String groupName = newGroupsEnum.nextElement();\r\n        logger.debug(\"Will add group \" + groupName);\r\n        opSetPersPresence1.createServerStoredContactGroup(opSetPersPresence1.getServerStoredContactListRoot(), groupName);\r\n        ContactGroup newlyCreatedGroup = opSetPersPresence1.getServerStoredContactListRoot().getGroup(groupName);\r\n        Iterator<String> contactsToAddToThisGroup = contactListToCreate.get(groupName).iterator();\r\n        while (contactsToAddToThisGroup.hasNext()) {\r\n            String id = contactsToAddToThisGroup.next();\r\n            logger.debug(\"Will add buddy \" + id);\r\n            opSetPersPresence1.subscribe(newlyCreatedGroup, id);\r\n        }\r\n    }\r\n    GibberishSlickFixture.preInstalledBuddyList = contactListToCreate;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.launchutils.LaunchArgHandler.handleHelpArg",
	"Comment": "prints a help message containing usage instructions and descriptions ofall options currently supported by jitsi.",
	"Method": "void handleHelpArg(){\r\n    handleVersionArg();\r\n    System.out.println(\"Usage: \" + getPackageName() + \" [OPTIONS] [uri-to-call]\");\r\n    System.out.println(\"\");\r\n    System.out.println(\"  -c, --config=DIR  use DIR for config files\");\r\n    System.out.println(\"  -d, --debug       print debugging messages to stdout\");\r\n    System.out.println(\"  -h, --help        display this help message and exit\");\r\n    System.out.println(\"  -m, --multiple    do not ensure single instance\");\r\n    System.out.println(\"  -6, --ipv6        prefer IPv6 addresses where possible only\");\r\n    System.out.println(\"  -4, --ipv4        forces use of IPv4 only\");\r\n    System.out.println(\"  -v, --version     display the current version and exit\");\r\n    System.out.println(\"  -n, --notray      disable the tray icon and show the GUI\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.macosx.MacOSXAddrBookSourceContact.removeContactDetail",
	"Comment": "removes the given contactdetail from the list of details forthis sourcecontact.",
	"Method": "void removeContactDetail(ContactDetail detail){\r\n    synchronized (this) {\r\n        String id = (String) getData(SourceContact.DATA_ID);\r\n        if (id != null && detail instanceof MacOSXAddrBookContactDetail) {\r\n            if (MacOSXAddrBookContactDetail.isMultiline(detail.getCategory())) {\r\n                String subProperty = null;\r\n                if (detail instanceof MacOSXAddrBookContactDetail) {\r\n                    subProperty = ((MacOSXAddrBookContactDetail) detail).getSubPropertyLabel();\r\n                }\r\n                List<String> values = getValues(detail, ((MacOSXAddrBookContactDetail) detail).getProperty(), subProperty, false);\r\n                MacOSXAddrBookContactQuery.setProperty(id, MacOSXAddrBookContactQuery.ABPERSON_PROPERTIES[((MacOSXAddrBookContactDetail) detail).getProperty()], subProperty, values.toArray(new Object[values.size()]));\r\n            } else\r\n                MacOSXAddrBookContactQuery.removeProperty(id, MacOSXAddrBookContactQuery.ABPERSON_PROPERTIES[((MacOSXAddrBookContactDetail) detail).getProperty()]);\r\n        } else\r\n            logger.warn(\"No id or wrong ContactDetail \" + detail);\r\n        contactDetails.remove(detail);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ProtocolIconAimImpl.getImageInBytes",
	"Comment": "returns the byte representation of the image corresponding to the givenidentifier.",
	"Method": "byte[] getImageInBytes(String imageID){\r\n    InputStream in = getResources().getImageInputStream(imageID);\r\n    if (in == null)\r\n        return null;\r\n    byte[] image = null;\r\n    try {\r\n        image = new byte[in.available()];\r\n        in.read(image);\r\n    } catch (IOException e) {\r\n        logger.error(\"Failed to load image:\" + imageID, e);\r\n    }\r\n    return image;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.keybindings.KeybindingsActivator.getConfigService",
	"Comment": "returns a reference to a configurationservice implementation currentlyregistered in the bundle context or null if no such implementation wasfound.",
	"Method": "ConfigurationService getConfigService(){\r\n    if (configService == null) {\r\n        ServiceReference confReference = bundleContext.getServiceReference(ConfigurationService.class.getName());\r\n        configService = (ConfigurationService) bundleContext.getService(confReference);\r\n    }\r\n    return configService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.account.AccountRegSummaryPage.pageShowing",
	"Comment": "before the panel is displayed obtains the summary data from the currentwizard.",
	"Method": "void pageShowing(){\r\n    AccountRegistrationWizard wizard = this.wizardContainer.getCurrentWizard();\r\n    this.keysPanel.removeAll();\r\n    this.valuesPanel.removeAll();\r\n    this.init(wizard.getSummary());\r\n    if (protocolProviderService != null && protocolProviderService.getAccountID().isReadOnly()) {\r\n        wizardContainer.setNextFinishButtonEnabled(false);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.contactsource.GenericSourceContact.getContactSource",
	"Comment": "gets the contactsourceservice which has created thissourcecontact.",
	"Method": "ContactSourceService getContactSource(){\r\n    return contactSource;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.security.SipSecurityManager.getSecurityAuthority",
	"Comment": "returns the securityauthority instance that sipsecuritymanager uses toobtain user credentials.",
	"Method": "SecurityAuthority getSecurityAuthority(){\r\n    return this.securityAuthority;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.caps.EntityCapsManager.setBundleContext",
	"Comment": "sets osgi bundle context instance that will be used by this class.",
	"Method": "void setBundleContext(BundleContext bundleContext){\r\n    if (bundleContext == null) {\r\n        configService = null;\r\n    }\r\n    EntityCapsManager.bundleContext = bundleContext;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.icqaccregwizz.FirstWizardPage.getIdentifier",
	"Comment": "implements the wizardpage.getidentifier to return thispage identifier.",
	"Method": "Object getIdentifier(){\r\n    return FIRST_PAGE_IDENTIFIER;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.showLastMessageInWriteArea",
	"Comment": "shows the last sent message in the write area, either in order tocorrect it or to send it again.",
	"Method": "boolean showLastMessageInWriteArea(){\r\n    return showMessageInWriteArea(lastSentMessageUID);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaAwareCall.fireLocalUserAudioLevelChangeEvent",
	"Comment": "notified by its very majesty the media service about changes in theaudio level of the local user, this listener generates the correspondingevents and delivers them to the listeners that have registered here.",
	"Method": "void fireLocalUserAudioLevelChangeEvent(int newLevel){\r\n    List<SoundLevelListener> localUserAudioLevelListeners;\r\n    synchronized (localUserAudioLevelListenersSyncRoot) {\r\n        localUserAudioLevelListeners = this.localUserAudioLevelListeners;\r\n    }\r\n    if (localUserAudioLevelListeners != null) {\r\n        int localUserAudioLevelListenerCount = localUserAudioLevelListeners.size();\r\n        for (int i = 0; i < localUserAudioLevelListenerCount; i++) localUserAudioLevelListeners.get(i).soundLevelChanged(this, newLevel);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomMemberJabberImpl.getContact",
	"Comment": "returns the protocol contact corresponding to this member in our contactlist. the contact returned here could be used by the user interface tocheck if this member is contained in our contact list and in function ofthis to show additional information add additional functionality.",
	"Method": "Contact getContact(){\r\n    return contact;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.GenericUIContactImpl.getContactDetails",
	"Comment": "returns a list of all uicontactdetails within thisuicontact.",
	"Method": "List<UIContactDetail> getContactDetails(){\r\n    List<UIContactDetail> details = new ArrayList<UIContactDetail>();\r\n    Iterator<List<UIContactDetail>> listsIter = contactDetails.values().iterator();\r\n    while (listsIter.hasNext()) {\r\n        details.addAll(listsIter.next());\r\n    }\r\n    return details;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.sip.SIPAccountRegistration.isRememberPassword",
	"Comment": "returns true if password has to remembered, false otherwise.",
	"Method": "boolean isRememberPassword(){\r\n    return rememberPassword;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.CallPeerControlEvent.getTargetURI",
	"Comment": "returns the target uri if this is event is triggered by a transferrequest or null if not.",
	"Method": "String getTargetURI(){\r\n    return targetURI;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.AbstractQualityControlWrapper.setMaxFrameRate",
	"Comment": "changes local value of frame rate, the one we have received fromremote party.",
	"Method": "void setMaxFrameRate(float f){\r\n    this.maxFrameRate = f;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.dns.DnsUtilActivator.getResources",
	"Comment": "returns the service giving access to all application resources.",
	"Method": "ResourceManagementService getResources(){\r\n    if (resourceService == null) {\r\n        resourceService = ResourceManagementServiceUtils.getService(bundleContext);\r\n    }\r\n    return resourceService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactGroupImpl.contains",
	"Comment": "returns true if and only if group is a direct subgroup of thismetacontactgroup.",
	"Method": "boolean contains(MetaContact contact,boolean contains,MetaContactGroup group){\r\n    return this.subgroups.contains(group);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatConversationPanelTest.testHtmlSnippetsOnTextToReplacePattern",
	"Comment": "test for various better and worse pieces of html to test the resilienceof the pattern.",
	"Method": "void testHtmlSnippetsOnTextToReplacePattern(){\r\n    final HashMap<String, String[]> tests = new HashMap<String, String[]>();\r\n    tests.put(\"just a piece of text\", new String[] { \"just a piece of text\", \"\" });\r\n    tests.put(\">another piece of text\", new String[] { \">another piece of text\", \"\" });\r\n    tests.put(\"<another piece of text\", new String[] { \"\", \"\" });\r\n    tests.put(\"<another piece> of text\", new String[] { \"\", \" of text\", \"\" });\r\n    tests.put(\"<another attribute=\\\"piece\\\"> of text\", new String[] { \"\", \" of text\", \"\" });\r\n    tests.put(\"<another attribute=\\\"<\\\"> of text\", new String[] { \"\", \" of text\", \"\" });\r\n    tests.put(\"piece of text<tag>'nother piece<\/tag>stuff at the end\", new String[] { \"piece of text\", \"'nother piece\", \"stuff at the end\", \"\" });\r\n    tests.put(\"<br />\", new String[] { \"\", \"\" });\r\n    tests.put(\"<br />text\", new String[] { \"\", \"text\", \"\" });\r\n    tests.put(\"some<br />text\", new String[] { \"some\", \"text\", \"\" });\r\n    tests.put(\"<img src=\\\"blablabla.jpg\\\" />\", new String[] { \"\", \"\" });\r\n    tests.put(\"some<img src=\\\"blablabla.jpg\\\" />\", new String[] { \"some\", \"\" });\r\n    tests.put(\"some<img src=\\\"blablabla.jpg\\\" />foobar\", new String[] { \"some\", \"foobar\", \"\" });\r\n    tests.put(\">some text between cut-off tags<\", new String[] { \">some text between cut-off tags\", \"\" });\r\n    tests.put(\"<some text between pointy brackets>\", new String[] { \"\", \"\" });\r\n    tests.put(\"fake &lt;br/&gt; tag\", new String[] { \"fake &lt;br/&gt; tag\", \"\" });\r\n    tests.put(\"fake &lt;br/> tag\", new String[] { \"fake &lt;br/> tag\", \"\" });\r\n    tests.put(\"fake <br/&gt; tag\", new String[] { \"fake \", \"\" });\r\n    tests.put(\"a piece <b>of <u>formatted<\/u> text for <\/b>testing...\", new String[] { \"a piece \", \"of \", \"formatted\", \" text for \", \"testing...\", \"\" });\r\n    tests.put(\"a piece <a href=\\\"www.google.com?query=blabla#blabla\\\">\" + \"www.google.com<\/a> hyperlinked text\", new String[] { \"a piece \", \"www.google.com\", \" hyperlinked text\", \"\" });\r\n    tests.put(\"<another attribute=\\\">\\\"> of text\", new String[] { \"\", \" of text\", \"\" });\r\n    tests.put(\"<a name=\\\"Click here ><\\\" href=\\\"www.google.com\\\">\" + \"For a treat<\/a> or something ...\", new String[] { \"\", \"For a treat\", \" or something ...\", \"\" });\r\n    tests.put(\"and here is <a \\\"some weird syntax\\\"> to test\", new String[] { \"and here is \", \" to test\", \"\" });\r\n    tests.put(\"and here <option name=\\\"opt\\\" checked> checked option\", new String[] { \"and here \", \" checked option\", \"\" });\r\n    tests.put(\"incomplete <img href=\\\"www.goo\", new String[] { \"incomplete \", \"\" });\r\n    tests.put(\"incomplete <img href=\\\"www.goo     >  <a href=\\\">test\", new String[] { \"incomplete \", \"test\", \"\" });\r\n    tests.put(\"\\\"blablabla\\\">See if this text is ignored ...\", new String[] { \"\\\"blablabla\\\">See if this text is ignored ...\", \"\" });\r\n    tests.put(\"bla\\\">See if this<img src=\\\"test1\\\">test2<\/img>\", new String[] { \"bla\\\">See if this\", \"test2\", \"\" });\r\n    tests.put(\"<the-end\", new String[] { \"\", \"\" });\r\n    tests.put(\"&lt;this-is-not-a-tag>\", new String[] { \"&lt;this-is-not-a-tag>\", \"\" });\r\n    tests.put(\"<this-is-a-tag>\", new String[] { \"\", \"\" });\r\n    for (final Entry<String, String[]> entry : tests.entrySet()) {\r\n        final String input = entry.getKey();\r\n        int index = 0;\r\n        final Matcher matcher = ChatConversationPanel.TEXT_TO_REPLACE_PATTERN.matcher(input);\r\n        while (matcher.find()) {\r\n            final String piece = matcher.group(1);\r\n            Assert.assertEquals(\"INPUT [[\" + input + \"]]:\", entry.getValue()[index], piece);\r\n            index++;\r\n        }\r\n        Assert.assertEquals(entry.getValue().length, index);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.X509CertificatePanel.valueChangedPerformed",
	"Comment": "called when the selection changed in the tree.loads the selected certificate.",
	"Method": "void valueChangedPerformed(TreeSelectionEvent e){\r\n    Object o = e.getNewLeadSelectionPath().getLastPathComponent();\r\n    if (o instanceof DefaultMutableTreeNode) {\r\n        DefaultMutableTreeNode node = (DefaultMutableTreeNode) o;\r\n        infoTextPane.setText(toString(node.getUserObject()));\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaHandler.removeVideoListener",
	"Comment": "unregisters a specific videolistener from this instance so thatit stops receiving notifications from it about changes in theavailability of visual components displaying video.",
	"Method": "void removeVideoListener(VideoListener listener){\r\n    videoNotifierSupport.removeVideoListener(listener);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockContact.setPresenceStatus",
	"Comment": "sets mockpresencestatus as the presencestatus that this contactis currently in.",
	"Method": "void setPresenceStatus(MockStatusEnum mockPresenceStatus){\r\n    this.presenceStatus = mockPresenceStatus;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.TransportManager.createIceAgent",
	"Comment": "creates the ice agent that we would be using in this transport managerfor all negotiation.",
	"Method": "Agent createIceAgent(){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.notificationconfiguration.SoundFilter.getDescription",
	"Comment": "method which describes, in the file chooser, the text representing thepermit extension files.",
	"Method": "String getDescription(){\r\n    String desc = \"Sound File (\";\r\n    if (this.soundFormats != null) {\r\n        for (int i = 0; i < this.soundFormats.length; ++i) {\r\n            if (i != 0) {\r\n                desc += \", \";\r\n            }\r\n            desc += \"*.\" + this.soundFormats[i];\r\n        }\r\n    } else {\r\n        desc += \"*.au, *.mid, *.mod, *.mp2, *.mp3, *.ogg, *.ram, *.wav, \" + \"*.wma\";\r\n    }\r\n    desc += \")\";\r\n    return desc;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ServerStoredContactListXivoImpl.removeContact",
	"Comment": "removes a contact. if creation is successful event will be fired.",
	"Method": "void removeContact(ContactSipImpl contact){\r\n    throw new OperationFailedException(\"Modification not supported.\", OperationFailedException.NOT_SUPPORTED_OPERATION);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.GlobalStatusSelectorBox.getUIClassID",
	"Comment": "returns the name of the l&f class that renders this component.",
	"Method": "String getUIClassID(){\r\n    return uiClassID;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.CallGibberishImpl.addCallPeer",
	"Comment": "adds callpeer to the list of peers in this call.if the call peer is already included in the call, the method hasno effect.",
	"Method": "void addCallPeer(CallPeerGibberishImpl callPeer){\r\n    if (!doAddCallPeer(callPeer))\r\n        return;\r\n    callPeer.addCallPeerListener(this);\r\n    if (logger.isInfoEnabled())\r\n        logger.info(\"Will fire peer added\");\r\n    fireCallPeerEvent(callPeer, CallPeerEvent.CALL_PEER_ADDED);\r\n    callPeer.setState(CallPeerState.ALERTING_REMOTE_SIDE, \"no reason\");\r\n    Timer timer1 = new Timer(false);\r\n    timer1.schedule(new TimerTask() {\r\n        @Override\r\n        public void run() {\r\n            callPeer.setState(CallPeerState.CONNECTED, \"no reason\");\r\n        }\r\n    }, 1500);\r\n    final Random random = new Random();\r\n    Timer timer = new Timer(false);\r\n    timer.scheduleAtFixedRate(new TimerTask() {\r\n        @Override\r\n        public void run() {\r\n            callPeer.fireStreamSoundLevelEvent(random.nextInt(255));\r\n        }\r\n    }, 1800, 100);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.CallGibberishImpl.addCallPeer",
	"Comment": "adds callpeer to the list of peers in this call.if the call peer is already included in the call, the method hasno effect.",
	"Method": "void addCallPeer(CallPeerGibberishImpl callPeer){\r\n    callPeer.setState(CallPeerState.CONNECTED, \"no reason\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.CallGibberishImpl.addCallPeer",
	"Comment": "adds callpeer to the list of peers in this call.if the call peer is already included in the call, the method hasno effect.",
	"Method": "void addCallPeer(CallPeerGibberishImpl callPeer){\r\n    callPeer.fireStreamSoundLevelEvent(random.nextInt(255));\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.presence.avatar.imagepicker.ImageClipper.drawImageOverlay",
	"Comment": "draw an overlay over the parts of the imageswhich are not in the crop zone",
	"Method": "void drawImageOverlay(Graphics g){\r\n    int width, height;\r\n    g.setColor(IMAGE_OVERLAY_COLOR);\r\n    width = this.cropZoneRect.x - this.imageRect.x;\r\n    if (width > 0) {\r\n        g.fillRect(this.imageRect.x, this.imageRect.y, width, this.imageRect.height);\r\n    }\r\n    width = this.imageRect.x + this.imageRect.width - (this.cropZoneRect.x + this.cropZoneRect.width);\r\n    if (width > 0) {\r\n        g.fillRect(this.cropZoneRect.x + this.cropZoneRect.width, this.imageRect.y, width, this.imageRect.height);\r\n    }\r\n    height = this.cropZoneRect.y - this.imageRect.y;\r\n    if (height > 0) {\r\n        g.fillRect(this.cropZoneRect.x, this.imageRect.y, this.cropZoneRect.width, height);\r\n    }\r\n    height = (this.imageRect.y + this.imageRect.height) - (this.cropZoneRect.y + this.cropZoneRect.height);\r\n    if (height > 0) {\r\n        g.fillRect(this.cropZoneRect.x, this.cropZoneRect.y + this.cropZoneRect.height, this.cropZoneRect.width, height);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetAutoAnswerSipImpl.isAutoAnswerConditionSet",
	"Comment": "is the auto answer option set to conditionallyanswer all incoming calls.",
	"Method": "boolean isAutoAnswerConditionSet(){\r\n    return answerConditional;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.WhiteboardObjectDeliveredEvent.getTimestamp",
	"Comment": "a timestamp indicating the exact date when the event ocurred.",
	"Method": "Date getTimestamp(){\r\n    return timestamp;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetServerStoredContactInfoJabberImpl.getDetailsAndDescendants",
	"Comment": "returns the user details from the specified class or its descendantsthe class is one from thenet.java.sip.communicator.service.protocol.serverstoreddetailsor implemented one in the operation set for the user info",
	"Method": "Iterator<T> getDetailsAndDescendants(Contact contact,Class<T> detailClass){\r\n    if (isPrivateMessagingContact(contact))\r\n        return new LinkedList<T>().iterator();\r\n    List<GenericDetail> details = infoRetreiver.getContactDetails(contact.getAddress());\r\n    List<T> result = new LinkedList<T>();\r\n    if (details == null)\r\n        return result.iterator();\r\n    for (GenericDetail item : details) if (detailClass.isInstance(item)) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        T t = (T) item;\r\n        result.add(t);\r\n    }\r\n    return result.iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.IncomingFileTransferRequestIcqImpl.getID",
	"Comment": "unique id that is identifying the request and then the filetransferif the request has been accepted.",
	"Method": "String getID(){\r\n    return id;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.IncomingFileTransferJabberImpl.getTransferedBytes",
	"Comment": "returns the number of bytes already received from the recipient.",
	"Method": "long getTransferedBytes(){\r\n    return jabberTransfer.getAmountWritten();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ServerStoredContactListIcqImpl.fireContactMoved",
	"Comment": "make the parent persistent presence operation set dispatch a subscriptionmoved event.",
	"Method": "void fireContactMoved(ContactGroup oldParentGroup,ContactGroup newParentGroup,Contact contact,int index){\r\n    if (parentOperationSet == null) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"No presence op. set available. Bailing out.\");\r\n        return;\r\n    }\r\n    parentOperationSet.fireSubscriptionMovedEvent(contact, oldParentGroup, newParentGroup);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapServiceImpl.removeContactSource",
	"Comment": "removes the contact source corresponding to the given ldap directory.",
	"Method": "void removeContactSource(LdapDirectory ldapDir){\r\n    LdapActivator.unregisterContactSource(ldapDir);\r\n}"
}, {
	"Path": "io.lettuce.core.protocol.CommandHandler.discardReadBytesIfNecessary",
	"Comment": "try to discard read bytes when buffer usage reach a higher usage ratio.",
	"Method": "void discardReadBytesIfNecessary(ByteBuf buffer){\r\n    float usedRatio = (float) buffer.readerIndex() / buffer.capacity();\r\n    if (usedRatio >= discardReadBytesRatio && buffer.refCnt() != 0) {\r\n        buffer.discardReadBytes();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaAwareCallPeer.securityNegotiationStarted",
	"Comment": "indicates that the other party has timeouted replying to ouroffer to secure the connection.",
	"Method": "void securityNegotiationStarted(MediaType mediaType,SrtpControl sender){\r\n    fireCallPeerSecurityNegotiationStartedEvent(new CallPeerSecurityNegotiationStartedEvent(this, toSessionType(mediaType), sender));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetAutoAnswerSipImpl.getAutoAnswerHeaderValue",
	"Comment": "returns the value of the header for the conditional auto answer.",
	"Method": "String getAutoAnswerHeaderValue(){\r\n    return headerValue;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.AnimatedImage.setShowFirstImage",
	"Comment": "displays the first image of the animation after the last cycle has passedif set to false, the last image will remain set after the lastanimation cycle.",
	"Method": "void setShowFirstImage(boolean showFirstImage){\r\n    this.showFirstImage = showFirstImage;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.AdHocConferenceChatSession.getHistoryAfterDate",
	"Comment": "returns a collection of the last n number of messages given by count.",
	"Method": "Collection<Object> getHistoryAfterDate(Date date,int count){\r\n    final MetaHistoryService metaHistory = GuiActivator.getMetaHistoryService();\r\n    if (metaHistory == null)\r\n        return null;\r\n    return metaHistory.findFirstMessagesAfter(chatHistoryFilter, chatRoomWrapper.getAdHocChatRoom(), date, ConfigurationUtils.getChatHistorySize());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.OperationSetPersistentPresenceGibberishImpl.addGibberishGroup",
	"Comment": "a gibberish provider method to use for fast filling of a contact list.",
	"Method": "void addGibberishGroup(ContactGroupGibberishImpl contactGroup){\r\n    contactListRoot.addSubgroup(contactGroup);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactImpl.getContacts",
	"Comment": "returns a java.util.iterator over all protocol specificcontacts encapsulated by this metacontact.in order to prevent problems with concurrency, the iteratorreturned by this method is not over the actual list of contacts but overa copy of that list.",
	"Method": "Iterator<Contact> getContacts(){\r\n    return new LinkedList<Contact>(protoContacts).iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.TestOperationSetPersistentPresence.postTestRenameGroup",
	"Comment": "renames our test group and checks whether corresponding events aretriggered. verifies whether the group has really changed its name andwhether it is findable by its new name. also makes sure that it doesnot exist under its previous name any more.",
	"Method": "void postTestRenameGroup(){\r\n    logger.trace(\"Testing renaming groups.\");\r\n    ContactGroup group = opSetPersPresence1.getServerStoredContactListRoot().getGroup(testGroupName);\r\n    GroupChangeCollector groupChangeCollector = new GroupChangeCollector();\r\n    opSetPersPresence1.addServerStoredGroupChangeListener(groupChangeCollector);\r\n    opSetPersPresence1.renameServerStoredContactGroup(group, testGroupName2);\r\n    groupChangeCollector.waitForEvent(10000);\r\n    opSetPersPresence1.removeServerStoredGroupChangeListener(groupChangeCollector);\r\n    assertEquals(\"Collected Group Change event\", 1, groupChangeCollector.collectedEvents.size());\r\n    assertEquals(\"Group name.\", testGroupName2, ((ServerStoredGroupEvent) groupChangeCollector.collectedEvents.get(0)).getSourceGroup().getGroupName());\r\n    ContactGroup oldGroup = opSetPersPresence1.getServerStoredContactListRoot().getGroup(testGroupName);\r\n    assertNull(\"A group was still findable by its old name after renaming.\", oldGroup);\r\n    ContactGroup newGroup = opSetPersPresence1.getServerStoredContactListRoot().getGroup(testGroupName2);\r\n    assertNotNull(\"Could not find a renamed group by its new name.\", newGroup);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.simpleaccreg.SimpleAccountRegistrationActivator.getConfigService",
	"Comment": "returns a reference to a configurationservice implementation currentlyregistered in the bundle context or null if no such implementation wasfound.",
	"Method": "ConfigurationService getConfigService(){\r\n    return ServiceUtils.getService(bundleContext, ConfigurationService.class);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl.setDisconnectedState",
	"Comment": "causes this callpeer to enter either the disconnected or the failedstate.",
	"Method": "void setDisconnectedState(boolean failed,String reason){\r\n    if (failed)\r\n        setState(CallPeerState.FAILED, reason);\r\n    else\r\n        setState(CallPeerState.DISCONNECTED, reason);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.GlobalStatusSelectorBox.getStatusEntry",
	"Comment": "returns the statusentry corresponding to the givenprotocolprovider.",
	"Method": "StatusEntry getStatusEntry(ProtocolProviderService protocolProvider){\r\n    for (Component c : getPopupMenu().getComponents()) {\r\n        if (!(c instanceof StatusEntry))\r\n            continue;\r\n        StatusEntry menu = (StatusEntry) c;\r\n        if (menu.getProtocolProvider() != null && menu.getProtocolProvider().equals(protocolProvider))\r\n            return menu;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.GlobalStatusSelectorBox.updateGlobalStatus",
	"Comment": "updates the global status by picking the most connected protocol providerstatus.",
	"Method": "void updateGlobalStatus(){\r\n    if (GuiActivator.getGlobalStatusService() == null)\r\n        return;\r\n    PresenceStatus globalStatus = GuiActivator.getGlobalStatusService().getGlobalPresenceStatus();\r\n    JCheckBoxMenuItem item = getItemFromStatus(globalStatus);\r\n    item.setSelected(true);\r\n    setSelected(new SelectedObject(item.getText(), item.getIcon(), item));\r\n    fitSizeToText();\r\n    this.revalidate();\r\n    setSystrayIcon(globalStatus);\r\n    if (!globalStatus.isOnline()) {\r\n        changeTooltip(null);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockProvider.getProtocolIcon",
	"Comment": "mock implementation of the corresponding protocolproviderservice method.we have no icon corresponding to this protocol provider.",
	"Method": "ProtocolIcon getProtocolIcon(){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.osdependent.jdic.TrayMenuFactory.createTrayMenuItem",
	"Comment": "creates a tray menu with the given name, text given bytextid and icon given by iconid. the listeneris handling item events and the swing value indicates if weshould create a swing menu item or and an awt item.",
	"Method": "Object createTrayMenuItem(String name,String textID,String iconID,ActionListener listener,boolean swing){\r\n    String text = Resources.getString(textID);\r\n    Object trayMenuItem;\r\n    if (swing) {\r\n        JMenuItem menuItem = new JMenuItem(text, Resources.getImage(iconID));\r\n        menuItem.setName(name);\r\n        menuItem.addActionListener(listener);\r\n        trayMenuItem = menuItem;\r\n    } else {\r\n        MenuItem menuItem = new MenuItem(text);\r\n        menuItem.setName(name);\r\n        menuItem.addActionListener(listener);\r\n        trayMenuItem = menuItem;\r\n    }\r\n    return trayMenuItem;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.httputil.HttpUtilActivator.getConfigurationService",
	"Comment": "returns a reference to a configurationservice implementation currentlyregistered in the bundle context or null if no such implementation wasfound.",
	"Method": "ConfigurationService getConfigurationService(){\r\n    if (configurationService == null) {\r\n        configurationService = ServiceUtils.getService(bundleContext, ConfigurationService.class);\r\n    }\r\n    return configurationService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ProtocolProviderServiceIcqImpl.getAccountID",
	"Comment": "returns the accountid that uniquely identifies the account representedby this instance of the protocolproviderservice.",
	"Method": "AccountID getAccountID(){\r\n    return accountID;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.ConferenceInfoDocument.getState",
	"Comment": "returns the state corresponding to the state attributeof an element. default to state.full which is therfc4575 default.",
	"Method": "State getState(State getState,Element element,State getState,State getState){\r\n    State state = State.parseString(element.getAttribute(STATE_ATTR_NAME));\r\n    return state == null ? State.FULL : state;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetFileTransferIcqImpl.fireFileTransferRequest",
	"Comment": "delivers the specified event to all registered file transfer listeners.",
	"Method": "void fireFileTransferRequest(FileTransferRequestEvent event){\r\n    Iterator<FileTransferListener> listeners = null;\r\n    synchronized (fileTransferListeners) {\r\n        listeners = new ArrayList<FileTransferListener>(fileTransferListeners).iterator();\r\n    }\r\n    while (listeners.hasNext()) {\r\n        FileTransferListener listener = listeners.next();\r\n        listener.fileTransferRequestReceived(event);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.AbstractOperationSetTelephonyConferencing.mediasMatch",
	"Comment": "checks whether two conferenceinfodocument.media instancesmatch according to the needs of our implementation. can returntrue for endpoints which are not identical.",
	"Method": "boolean mediasMatch(ConferenceInfoDocument.Media a,ConferenceInfoDocument.Media b){\r\n    if (a == null && b == null)\r\n        return true;\r\n    else if (a == null || b == null)\r\n        return false;\r\n    else if (!stringsMatch(a.getId(), b.getId()))\r\n        return false;\r\n    else if (!stringsMatch(a.getSrcId(), b.getSrcId()))\r\n        return false;\r\n    else if (!stringsMatch(a.getType(), b.getType()))\r\n        return false;\r\n    else if (!stringsMatch(a.getStatus(), b.getStatus()))\r\n        return false;\r\n    return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallTitlePanel.paintComponent",
	"Comment": "customizes the background of this panel, by painting a round rectangle inthe background color previously set.",
	"Method": "void paintComponent(Graphics g){\r\n    super.paintComponent(g);\r\n    g = g.create();\r\n    try {\r\n        AntialiasingManager.activateAntialiasing(g);\r\n        g.setColor(backgroundColor);\r\n        g.fillRoundRect(0, 0, this.getWidth(), this.getHeight(), 10, 10);\r\n    } finally {\r\n        g.dispose();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.whiteboard.gui.whiteboardshapes.WhiteboardShapeImage.setBackgroundImage",
	"Comment": "specifies an image that should be displayed as the background of thisobject.",
	"Method": "void setBackgroundImage(byte[] background){\r\n    this.bytes = background;\r\n    ImageIcon ii = new ImageIcon(this.bytes);\r\n    this.image = ii.getImage();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.AdHocChatRoomMessageDeliveryFailedEvent.getErrorCode",
	"Comment": "returns an error code descibing the reason for the failure of the message delivery.",
	"Method": "int getErrorCode(){\r\n    return errorCode;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.ResolveAddressToDisplayNameContactQueryListener.isFoundImage",
	"Comment": "tells if the query has found a match to resolve the contact address.",
	"Method": "boolean isFoundImage(){\r\n    return resolvedImage != null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetPersistentPresenceJabberImpl.queryContactStatus",
	"Comment": "gets the presencestatus of a contact with a specificstring identifier.",
	"Method": "PresenceStatus queryContactStatus(String contactIdentifier){\r\n    assertConnected();\r\n    Connection xmppConnection = parentProvider.getConnection();\r\n    if (xmppConnection == null) {\r\n        throw new IllegalArgumentException(\"The provider/account must be signed on in order to\" + \" query the status of a contact in its roster\");\r\n    }\r\n    Presence presence = xmppConnection.getRoster().getPresence(contactIdentifier);\r\n    if (presence != null)\r\n        return jabberStatusToPresenceStatus(presence, parentProvider);\r\n    else {\r\n        return parentProvider.getJabberStatusEnum().getStatus(JabberStatusEnum.OFFLINE);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockContact.isLocal",
	"Comment": "determines whether or not this contact represents our own identity.",
	"Method": "boolean isLocal(){\r\n    return false;\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.common.test.UnitGenerator.generate",
	"Comment": "generate a single giant buffer of all provided frames not appropriate for production code, but useful for testing.",
	"Method": "ByteBuffer generate(Frame frame,ByteBuffer generate,Frame[] frames,ByteBuffer generate,List<WebSocketFrame> frames){\r\n    byte[] MASK = { 0x11, 0x22, 0x33, 0x44 };\r\n    Generator generator = new UnitGenerator();\r\n    int buflen = 0;\r\n    for (Frame f : frames) {\r\n        buflen += f.getPayloadLength() + Generator.MAX_HEADER_LENGTH;\r\n    }\r\n    ByteBuffer completeBuf = ByteBuffer.allocate(buflen);\r\n    BufferUtil.clearToFill(completeBuf);\r\n    for (WebSocketFrame f : frames) {\r\n        f.setMask(MASK);\r\n        BufferUtil.put(generator.generateHeaderBytes(f), completeBuf);\r\n        ByteBuffer window = f.getPayload();\r\n        if (BufferUtil.hasContent(window)) {\r\n            BufferUtil.put(window, completeBuf);\r\n        }\r\n    }\r\n    BufferUtil.flipToFlush(completeBuf, 0);\r\n    if (LOG.isDebugEnabled()) {\r\n        LOG.debug(\"generate({} frames) - {}\", frames.size(), BufferUtil.toDetailString(completeBuf));\r\n    }\r\n    return completeBuf;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.netaddr.NetaddrActivator.start",
	"Comment": "creates a networkaddressmanager, starts it, and registers it as anetworkaddressmanagerservice.",
	"Method": "void start(BundleContext bundleContext){\r\n    try {\r\n        logger.logEntry();\r\n        NetaddrActivator.bundleContext = bundleContext;\r\n        networkAMS = new NetworkAddressManagerServiceImpl();\r\n        networkAMS.start();\r\n        if (logger.isInfoEnabled())\r\n            logger.info(\"Network Address Manager         ...[  STARTED ]\");\r\n        bundleContext.registerService(NetworkAddressManagerService.class.getName(), networkAMS, null);\r\n        if (logger.isInfoEnabled())\r\n            logger.info(\"Network Address Manager Service ...[REGISTERED]\");\r\n    } finally {\r\n        logger.logExit();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ProtocolProviderFactoryIcqImpl.createAccount",
	"Comment": "initializes and creates an account corresponding to the specifiedaccountproperties.",
	"Method": "AccountID createAccount(Map<String, String> accountProperties){\r\n    boolean accountPropertiesIsAIM = IcqAccountID.isAIM(accountProperties);\r\n    if ((accountPropertiesIsAIM && !isAimFactory) || (!accountPropertiesIsAIM && isAimFactory)) {\r\n        return null;\r\n    }\r\n    return super.createAccount(accountProperties);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.ExtendedTransferHandler.exportAsDrag",
	"Comment": "overrides transferhandler.exportasdrag method in order to callour own swingdraggesturerecognizer, which takes care of thevisual representation icon.",
	"Method": "void exportAsDrag(JComponent comp,InputEvent e,int action){\r\n    int srcActions = getSourceActions(comp);\r\n    int dragAction = srcActions & action;\r\n    if (!(e instanceof MouseEvent))\r\n        action = NONE;\r\n    if (action != NONE && !GraphicsEnvironment.isHeadless()) {\r\n        if (recognizer == null) {\r\n            recognizer = new SwingDragGestureRecognizer(new DragHandler());\r\n        }\r\n        recognizer.gestured(comp, (MouseEvent) e, srcActions, dragAction);\r\n    } else {\r\n        exportDone(comp, null, NONE);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.jabber.JabberAccountRegistration.getServerFromUserName",
	"Comment": "parse the server part from the jabber id and set it to server as defaultvalue. if advanced option is enabled do nothing.",
	"Method": "String getServerFromUserName(String userName){\r\n    int delimIndex = userName.indexOf(\"@\");\r\n    if (delimIndex != -1) {\r\n        String newServerAddr = userName.substring(delimIndex + 1);\r\n        if (newServerAddr.equals(GOOGLE_USER_SUFFIX)) {\r\n            return GOOGLE_CONNECT_SRV;\r\n        } else {\r\n            return newServerAddr;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.AbstractAddrBookContactQuery.fireContactRemoved",
	"Comment": "notifies the contactquerylisteners registered with thiscontactquery that a sourcecontact has beenremoved.",
	"Method": "void fireContactRemoved(SourceContact contact){\r\n    synchronized (sourceContacts) {\r\n        sourceContacts.remove(contact);\r\n    }\r\n    super.fireContactRemoved(contact);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.VCardTempXUpdatePresenceExtension.interceptPacket",
	"Comment": "intercepts sent presence packets in order to add this extension.",
	"Method": "void interceptPacket(Packet packet){\r\n    packet.addExtension(this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.neomedia.NeomediaActivator.getNotificationService",
	"Comment": "returns the notificationservice obtained from the bundlecontext.",
	"Method": "NotificationService getNotificationService(){\r\n    if (notificationService == null) {\r\n        ServiceReference notifReference = bundleContext.getServiceReference(NotificationService.class.getName());\r\n        notificationService = (NotificationService) bundleContext.getService(notifReference);\r\n        if (notificationService != null) {\r\n            notificationService.registerDefaultNotificationForEvent(DEVICE_CONFIGURATION_HAS_CHANGED, net.java.sip.communicator.service.notification.NotificationAction.ACTION_POPUP_MESSAGE, \"Device configuration has changed\", null);\r\n            notificationService.registerDefaultNotificationForEvent(NEW_SELECTED_DEVICE, net.java.sip.communicator.service.notification.NotificationAction.ACTION_POPUP_MESSAGE, \"New selected device\", null);\r\n        }\r\n    }\r\n    return notificationService;\r\n}"
}, {
	"Path": "net.librec.similarity.AbstractRecommenderSimilarity.buildSocialSimilarityMatrix",
	"Comment": "build social similarity matrix with trainmatrixand socialmatrix in datamodel.",
	"Method": "void buildSocialSimilarityMatrix(DataModel dataModel){\r\n    SequentialAccessSparseMatrix trainMatrix = dataModel.getDataSplitter().getTrainData();\r\n    SequentialAccessSparseMatrix socialMatrix = ((SocialDataAppender) dataModel.getDataAppender()).getUserAppender();\r\n    int numUsers = trainMatrix.rowSize();\r\n    similarityMatrix = new SymmMatrix(numUsers);\r\n    for (int userIdx = 0; userIdx < numUsers; userIdx++) {\r\n        SequentialSparseVector userVector = trainMatrix.row(userIdx);\r\n        if (userVector.getNumEntries() == 0) {\r\n            continue;\r\n        }\r\n        SequentialSparseVector socialVector = socialMatrix.row(userIdx);\r\n        for (Vector.VectorEntry vectorEntry : socialVector) {\r\n            int socialUserIndex = vectorEntry.index();\r\n            SequentialSparseVector socialUserVector = trainMatrix.row(socialUserIndex);\r\n            if (socialUserVector.getNumEntries() == 0) {\r\n                continue;\r\n            }\r\n            double sim = getCorrelation(userVector, socialVector);\r\n            if (!Double.isNaN(sim)) {\r\n                similarityMatrix.set(userIdx, socialUserIndex, sim);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.lettuce.core.protocol.DefaultEndpoint.drainCommands",
	"Comment": "drain commands from a queue and return only active commands.",
	"Method": "List<RedisCommand<?, ?, ?>> drainCommands(List<RedisCommand<?, ?, ?>> drainCommands,Queue<? extends RedisCommand<?, ?, ?>> source){\r\n    List<RedisCommand<?, ?, ?>> target = new ArrayList(source.size());\r\n    RedisCommand<?, ?, ?> cmd;\r\n    while ((cmd = source.poll()) != null) {\r\n        if (!cmd.isDone()) {\r\n            target.add(cmd);\r\n        }\r\n    }\r\n    return target;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.msoutlook.MsOutlookAddrBookContactSourceService.initMAPI",
	"Comment": "initializes a new msoutlookaddrbookcontactsourceserviceinstance.",
	"Method": "void initMAPI(NotificationsDelegate notificationDelegate){\r\n    if (!isMAPIInitialized) {\r\n        boolean isOutlookDefaultMailClient = isOutlookDefaultMailClient();\r\n        boolean showWarning = AddrBookActivator.getConfigService().getBoolean(PNAME_OUTLOOK_ADDR_BOOK_SHOW_DEFAULTMAILCLIENT_WARNING, true);\r\n        if (!isOutlookDefaultMailClient && showWarning) {\r\n            DefaultMailClientMessageDialog dialog = new DefaultMailClientMessageDialog();\r\n            int result = dialog.showDialog();\r\n            if ((result & DefaultMailClientMessageDialog.DONT_ASK_SELECTED_MASK) != 0) {\r\n                AddrBookActivator.getConfigService().setProperty(PNAME_OUTLOOK_ADDR_BOOK_SHOW_DEFAULTMAILCLIENT_WARNING, false);\r\n            }\r\n            if ((result & DefaultMailClientMessageDialog.DEFAULT_MAIL_CLIENT_SELECTED_MASK) != 0) {\r\n                RegistryHandler.setOutlookAsDefaultMailClient();\r\n            }\r\n        }\r\n        if (isOutlookDefaultMailClient && !showWarning) {\r\n            AddrBookActivator.getConfigService().setProperty(PNAME_OUTLOOK_ADDR_BOOK_SHOW_DEFAULTMAILCLIENT_WARNING, true);\r\n        }\r\n        String logFileName = \"\";\r\n        String homeLocation = System.getProperty(\"net.java.sip.communicator.SC_LOG_DIR_LOCATION\");\r\n        String dirName = System.getProperty(\"net.java.sip.communicator.SC_HOME_DIR_NAME\");\r\n        if (homeLocation != null && dirName != null) {\r\n            logFileName = homeLocation + \"\\\\\" + dirName + \"\\\\log\\\\\";\r\n        }\r\n        int logLevel = NATIVE_LOGGER_LEVEL_INFO;\r\n        if (logger.isTraceEnabled()) {\r\n            logLevel = NATIVE_LOGGER_LEVEL_TRACE;\r\n        }\r\n        logger.info(\"Init mapi with log level \" + logLevel + \" and log file\" + \" path \" + logFileName);\r\n        MAPIInitialize(MAPI_INIT_VERSION, MAPI_MULTITHREAD_NOTIFICATIONS, notificationDelegate, logFileName, logLevel);\r\n        isMAPIInitialized = true;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.IceUdpTransportManager.startConnectivityEstablishment",
	"Comment": "starts the connectivity establishment of the associated iceagent.",
	"Method": "boolean startConnectivityEstablishment(Iterable<ContentPacketExtension> remote,boolean startConnectivityEstablishment,Map<String, IceUdpTransportPacketExtension> remote){\r\n    boolean iceAgentStateIsRunning = IceProcessingState.RUNNING.equals(iceAgent.getState());\r\n    if (iceAgentStateIsRunning && logger.isInfoEnabled())\r\n        logger.info(\"Update ICE remote candidates\");\r\n    int generation = iceAgent.getGeneration();\r\n    boolean startConnectivityEstablishment = false;\r\n    for (Map.Entry<String, IceUdpTransportPacketExtension> e : remote.entrySet()) {\r\n        IceUdpTransportPacketExtension transport = e.getValue();\r\n        List<CandidatePacketExtension> candidates = transport.getChildExtensionsOfType(CandidatePacketExtension.class);\r\n        if (iceAgentStateIsRunning && candidates.isEmpty()) {\r\n            logger.info(\"connectivity establishment has not been started \" + \"because candidate list is empty\");\r\n            return false;\r\n        }\r\n        String media = e.getKey();\r\n        IceMediaStream stream = iceAgent.getStream(media);\r\n        if (stream == null) {\r\n            logger.warn(\"No ICE media stream for media: \" + media + \" - ignored candidates.\");\r\n            continue;\r\n        }\r\n        Collections.sort(candidates);\r\n        String ufrag = transport.getUfrag();\r\n        if (ufrag != null)\r\n            stream.setRemoteUfrag(ufrag);\r\n        String password = transport.getPassword();\r\n        if (password != null)\r\n            stream.setRemotePassword(password);\r\n        for (CandidatePacketExtension candidate : candidates) {\r\n            if (candidate.getGeneration() != generation)\r\n                continue;\r\n            if (candidate.getIP() == null || \"\".equals(candidate.getIP())) {\r\n                logger.warn(\"Skipped ICE candidate with empty IP\");\r\n                continue;\r\n            }\r\n            Component component = stream.getComponent(candidate.getComponent());\r\n            String relAddr;\r\n            int relPort;\r\n            TransportAddress relatedAddress = null;\r\n            if (((relAddr = candidate.getRelAddr()) != null) && ((relPort = candidate.getRelPort()) != -1)) {\r\n                relatedAddress = new TransportAddress(relAddr, relPort, Transport.parse(candidate.getProtocol()));\r\n            }\r\n            RemoteCandidate relatedCandidate = component.findRemoteCandidate(relatedAddress);\r\n            RemoteCandidate remoteCandidate = new RemoteCandidate(new TransportAddress(candidate.getIP(), candidate.getPort(), Transport.parse(candidate.getProtocol())), component, org.ice4j.ice.CandidateType.parse(candidate.getType().toString()), candidate.getFoundation(), candidate.getPriority(), relatedCandidate);\r\n            if (iceAgentStateIsRunning) {\r\n                component.addUpdateRemoteCandidates(remoteCandidate);\r\n            } else {\r\n                component.addRemoteCandidate(remoteCandidate);\r\n                startConnectivityEstablishment = true;\r\n            }\r\n        }\r\n    }\r\n    if (iceAgentStateIsRunning) {\r\n        for (IceMediaStream stream : iceAgent.getStreams()) {\r\n            for (Component component : stream.getComponents()) component.updateRemoteCandidates();\r\n        }\r\n    } else if (startConnectivityEstablishment) {\r\n        for (IceMediaStream stream : iceAgent.getStreams()) {\r\n            for (Component component : stream.getComponents()) {\r\n                if (component.getRemoteCandidateCount() < 1) {\r\n                    startConnectivityEstablishment = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (!startConnectivityEstablishment)\r\n                break;\r\n        }\r\n        if (startConnectivityEstablishment) {\r\n            iceAgent.startConnectivityEstablishment();\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.icqaccregwizz.IcqAccountRegistrationWizard.getIcon",
	"Comment": "returns the protocol icon that will be shown on the left of the protocolname in the list, where user will choose the protocol to register to.",
	"Method": "byte[] getIcon(){\r\n    return Resources.getImage(Resources.ICQ_LOGO);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.OperationSetBasicTelephonyGibberishImpl.setMute",
	"Comment": "sets the mute state of the audio stream being sent to a specificcallpeer.the implementation sends silence through the audio stream.",
	"Method": "void setMute(CallPeer peer,boolean mute){\r\n    CallPeerGibberishImpl gibberishPeer = (CallPeerGibberishImpl) peer;\r\n    gibberishPeer.setMute(mute);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ProtocolIconIcqImpl.getConnectingIcon",
	"Comment": "returns the icon image used to represent the protocol connecting state.",
	"Method": "byte[] getConnectingIcon(){\r\n    return getImageInBytes(\"service.protocol.icq.CONNECTING\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.history.HistoryWindow.progressChanged",
	"Comment": "handles the progressevent triggered from the history when processinga query.",
	"Method": "void progressChanged(ProgressEvent evt){\r\n    int progress = evt.getProgress();\r\n    if ((lastProgress != progress) && evt.getStartDate() == null || evt.getStartDate() != ignoreProgressDate) {\r\n        this.progressBar.setValue(progress);\r\n        if (progressBar.getPercentComplete() == 1.0) {\r\n            Timer progressBarTimer = new Timer(1 * 1000, null);\r\n            progressBarTimer.setRepeats(false);\r\n            progressBarTimer.addActionListener(new ActionListener() {\r\n                public void actionPerformed(ActionEvent e) {\r\n                    mainPanel.remove(progressBar);\r\n                    mainPanel.add(readyLabel, BorderLayout.SOUTH);\r\n                    mainPanel.revalidate();\r\n                    mainPanel.repaint();\r\n                    progressBar.setValue(0);\r\n                }\r\n            });\r\n            progressBarTimer.start();\r\n        }\r\n        lastProgress = progress;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.history.HistoryWindow.progressChanged",
	"Comment": "handles the progressevent triggered from the history when processinga query.",
	"Method": "void progressChanged(ProgressEvent evt){\r\n    mainPanel.remove(progressBar);\r\n    mainPanel.add(readyLabel, BorderLayout.SOUTH);\r\n    mainPanel.revalidate();\r\n    mainPanel.repaint();\r\n    progressBar.setValue(0);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.PresenceStatusMenu.updateStatus",
	"Comment": "selects a specific presencestatus in this instance and theprotocolproviderservice it depicts.",
	"Method": "void updateStatus(PresenceStatus presenceStatus){\r\n    if (logger.isTraceEnabled())\r\n        logger.trace(\"Update status for provider: \" + protocolProvider.getAccountID().getAccountAddress() + \". The new status will be: \" + presenceStatus.getStatusName());\r\n    this.setSelectedStatus(presenceStatus);\r\n    for (int i = 0; i < getItemCount(); i++) {\r\n        JMenuItem item = getItem(i);\r\n        if (item instanceof JCheckBoxMenuItem) {\r\n            if (item.getName().equals(presenceStatus.getStatusName())) {\r\n                item.setSelected(true);\r\n            } else {\r\n                item.setText(item.getName());\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl.setTransferAuthority",
	"Comment": "transfer authority used for interacting with user for unknown calls and the requests for transfer.",
	"Method": "void setTransferAuthority(TransferAuthority authority){\r\n    this.transferAuthority = authority;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomMemberIrcImpl.getRole",
	"Comment": "returns the role of this chat room member in its containing room.",
	"Method": "ChatRoomMemberRole getRole(){\r\n    return this.roles.first();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ServerStoredContactList.fireContactMoved",
	"Comment": "make the parent persistent presence operation set dispatch a subscriptionmoved event.",
	"Method": "void fireContactMoved(ContactGroupSipImpl oldParentGroup,ContactGroupSipImpl newParentGroup,ContactSipImpl contact){\r\n    parentOperationSet.fireSubscriptionMovedEvent(contact, oldParentGroup, newParentGroup);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.update.UpdateActivator.start",
	"Comment": "the dependent service is available and the bundle will start.",
	"Method": "void start(Object dependentService){\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Update checker [STARTED]\");\r\n    ConfigurationService cfg = getConfiguration();\r\n    if (OSUtils.IS_WINDOWS) {\r\n        updateService = new UpdateServiceImpl();\r\n        bundleContext.registerService(UpdateService.class.getName(), updateService, null);\r\n        if (!cfg.getBoolean(CHECK_FOR_UPDATES_MENU_DISABLED_PROP, false)) {\r\n            Hashtable<String, String> toolsMenuFilter = new Hashtable<String, String>();\r\n            toolsMenuFilter.put(Container.CONTAINER_ID, Container.CONTAINER_HELP_MENU.getID());\r\n            bundleContext.registerService(PluginComponentFactory.class.getName(), new PluginComponentFactory(Container.CONTAINER_HELP_MENU) {\r\n                @Override\r\n                protected PluginComponent getPluginInstance() {\r\n                    return new CheckForUpdatesMenuItemComponent(getContainer(), this);\r\n                }\r\n            }, toolsMenuFilter);\r\n        }\r\n        if (cfg.getBoolean(UPDATE_ENABLED, true))\r\n            updateService.checkForUpdates(false);\r\n    }\r\n    if (cfg.getBoolean(CHECK_FOR_UPDATES_DAILY_ENABLED_PROP, false)) {\r\n        logger.info(\"Scheduled update checking enabled\");\r\n        int hoursToWait = calcHoursToWait();\r\n        Runnable updateRunnable = new Runnable() {\r\n            public void run() {\r\n                logger.debug(\"Performing scheduled update check\");\r\n                getUpdateService().checkForUpdates(false);\r\n            }\r\n        };\r\n        mUpdateExecutor = Executors.newSingleThreadScheduledExecutor();\r\n        mUpdateExecutor.scheduleAtFixedRate(updateRunnable, hoursToWait, 24 * 60 * 60, TimeUnit.SECONDS);\r\n    }\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Update checker [REGISTERED]\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.update.UpdateActivator.start",
	"Comment": "the dependent service is available and the bundle will start.",
	"Method": "void start(Object dependentService){\r\n    return new CheckForUpdatesMenuItemComponent(getContainer(), this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.update.UpdateActivator.start",
	"Comment": "the dependent service is available and the bundle will start.",
	"Method": "void start(Object dependentService){\r\n    logger.debug(\"Performing scheduled update check\");\r\n    getUpdateService().checkForUpdates(false);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageHistoryServiceImpl.findByKeywords",
	"Comment": "returns all the messages exchangedin the supplied chat room having the given keywords",
	"Method": "Collection<EventObject> findByKeywords(MetaContact contact,String[] keywords,Collection<EventObject> findByKeywords,MetaContact contact,String[] keywords,boolean caseSensitive,Collection<EventObject> findByKeywords,ChatRoom room,String[] keywords,Collection<EventObject> findByKeywords,ChatRoom room,String[] keywords,boolean caseSensitive){\r\n    HashSet<EventObject> result = new HashSet<EventObject>();\r\n    try {\r\n        HistoryReader reader = this.getHistoryForMultiChat(room).getReader();\r\n        addHistorySearchProgressListeners(reader, 1);\r\n        Iterator<HistoryRecord> recs = reader.findByKeywords(keywords, SEARCH_FIELD, caseSensitive);\r\n        while (recs.hasNext()) {\r\n            result.add(convertHistoryRecordToMessageEvent(recs.next(), room));\r\n        }\r\n        removeHistorySearchProgressListeners(reader);\r\n    } catch (IOException e) {\r\n        logger.error(\"Could not read history\", e);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetDesktopSharingClientJabberImpl.accept",
	"Comment": "tests whether or not the specified packet should be handled by thisoperation set. this method is called by smack prior to packet deliveryand it would only accept inputevtiqs.",
	"Method": "boolean accept(Packet packet){\r\n    return (packet instanceof InputEvtIQ);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.notificationwiring.NotificationManager.recorderStopped",
	"Comment": "notifies that a specific recorder hasstopped recording the media associated with it.",
	"Method": "void recorderStopped(Recorder recorder){\r\n    try {\r\n        ResourceManagementService resources = NotificationWiringActivator.getResources();\r\n        fireNotification(CALL_SAVED, resources.getI18NString(\"plugin.callrecordingconfig.CALL_SAVED\"), resources.getI18NString(\"plugin.callrecordingconfig.CALL_SAVED_TO\", new String[] { recorder.getFilename() }));\r\n    } catch (Throwable t) {\r\n        if (t instanceof ThreadDeath)\r\n            throw (ThreadDeath) t;\r\n        else {\r\n            logger.error(\"An error occurred while trying to notify that\" + \" the recording of a call has stopped.\", t);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.notifsource.NotificationContact.getContactDetailsForOperationSet",
	"Comment": "returns a list of uicontactdetails supporting the givenoperationset class.",
	"Method": "List<UIContactDetail> getContactDetailsForOperationSet(Class<? extends OperationSet> opSetClass){\r\n    List<UIContactDetail> resultList = new LinkedList<UIContactDetail>();\r\n    if (opSetClass.equals(OperationSetBasicTelephony.class))\r\n        resultList.add(notificationDetail);\r\n    return resultList;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.conference.ConferencePeerPanel.securityPending",
	"Comment": "indicates that the security status is pending confirmation.",
	"Method": "void securityPending(){\r\n    super.securityPending();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.ActiveCallsRepository.addCall",
	"Comment": "adds the specified call to the list of calls tracked by this repository.",
	"Method": "void addCall(T call){\r\n    activeCalls.put(call.getCallID(), call);\r\n    call.addCallChangeListener(this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.whiteboard.gui.WhiteboardFrame.releasedMove",
	"Comment": "when a shap is moved we send a message with the new position rather thandeleting the shape",
	"Method": "void releasedMove(){\r\n    if (moving) {\r\n        if (selectedShape == null)\r\n            return;\r\n        doneDrawing = true;\r\n        sendMoveShape(selectedShape);\r\n        selectedShape = null;\r\n        moving = false;\r\n        repaint();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomIrcImpl.getMembersWhiteList",
	"Comment": "returns the ids of the users that has the member role in the room. whenthe room is member only, this are the users allowed to join.",
	"Method": "List<String> getMembersWhiteList(){\r\n    return new ArrayList<String>();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetAdHocMultiUserChatIcqImpl.createLocalChatRoomInstance",
	"Comment": "creates an adhocchatroom from the specified roomnameand icq chatroomsession.",
	"Method": "AdHocChatRoom createLocalChatRoomInstance(ChatInvitation chatInvitation,AdHocChatRoom createLocalChatRoomInstance,String roomName,ChatRoomSession chatRoomSession){\r\n    synchronized (chatRoomCache) {\r\n        AdHocChatRoom newChatRoom = new AdHocChatRoomIcqImpl(roomName, chatRoomSession, icqProvider);\r\n        chatRoomCache.put(roomName, newChatRoom);\r\n        return newChatRoom;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.MetaContactChatSession.contactResourceAdded",
	"Comment": "called when a new contactresource has been added to the listof available contact resources.",
	"Method": "void contactResourceAdded(ContactResourceEvent event){\r\n    Contact contact = event.getContact();\r\n    if (metaContact.containsContact(contact)) {\r\n        updateChatTransports(contact);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ServerStoredContactListSipImpl.createContact",
	"Comment": "creates contact for the specified address and inside thespecified group . if creation is successfull event will be fired.",
	"Method": "ContactSipImpl createContact(ContactGroupSipImpl parentGroup,String contactId,String displayName,boolean persistent,String contactType){\r\n    if (parentGroup == null) {\r\n        throw new IllegalArgumentException(\"Parent group cannot be null\");\r\n    }\r\n    if (contactId == null || contactId.trim().length() == 0) {\r\n        throw new IllegalArgumentException(\"Contact identifier cannot be null or empty\");\r\n    }\r\n    if (logger.isTraceEnabled()) {\r\n        logger.trace(String.format(\"createContact %1s, %2s, %3s\", parentGroup.getGroupName(), contactId, persistent));\r\n    }\r\n    if (parentGroup.getContact(contactId) != null) {\r\n        throw new OperationFailedException(\"Contact \" + contactId + \" already exists.\", OperationFailedException.SUBSCRIPTION_ALREADY_EXISTS);\r\n    }\r\n    Address contactAddress;\r\n    try {\r\n        contactAddress = sipProvider.parseAddressString(contactId);\r\n    } catch (ParseException ex) {\r\n        throw new IllegalArgumentException(contactId + \" is not a valid string.\", ex);\r\n    }\r\n    ContactSipImpl newContact = parentOperationSet.resolveContactID(contactAddress.getURI().toString());\r\n    if (newContact != null && !newContact.isPersistent() && !newContact.getParentContactGroup().isPersistent()) {\r\n        ContactGroupSipImpl oldParentGroup = (ContactGroupSipImpl) newContact.getParentContactGroup();\r\n        oldParentGroup.removeContact(newContact);\r\n        fireContactRemoved(oldParentGroup, newContact);\r\n    }\r\n    newContact = new ContactSipImpl(contactAddress, sipProvider);\r\n    newContact.setPersistent(persistent);\r\n    if (displayName == null || displayName.length() <= 0)\r\n        displayName = ((SipURI) contactAddress.getURI()).getUser();\r\n    newContact.setDisplayName(displayName);\r\n    if (contactType != null) {\r\n        setContactType(newContact, contactType);\r\n    }\r\n    parentGroup.addContact(newContact);\r\n    if (newContact.isPersistent()) {\r\n        try {\r\n            updateResourceLists();\r\n        } catch (XCapException e) {\r\n            parentGroup.removeContact(newContact);\r\n            throw new OperationFailedException(\"Error while creating XCAP contact\", OperationFailedException.NETWORK_FAILURE, e);\r\n        }\r\n        newContact.setResolved(true);\r\n        if (xCapClient.isConnected() && xCapClient.isResourceListsSupported()) {\r\n            newContact.setXCapResolved(true);\r\n            try {\r\n                if (!isContactInWhiteRule(contactId)) {\r\n                    if (addContactToWhiteList(newContact))\r\n                        updatePresRules();\r\n                }\r\n            } catch (XCapException e) {\r\n                logger.error(\"Cannot add contact to white list while \" + \"creating it\", e);\r\n            }\r\n        }\r\n    }\r\n    fireContactAdded(parentGroup, newContact);\r\n    return newContact;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl.sayCancel",
	"Comment": "sends a cancel request to the peer represented by this instance.",
	"Method": "void sayCancel(){\r\n    if (getLatestInviteTransaction() instanceof ServerTransaction) {\r\n        logger.error(\"Cannot cancel a server transaction\");\r\n        throw new OperationFailedException(\"Cannot cancel a server transaction\", OperationFailedException.INTERNAL_ERROR);\r\n    }\r\n    ClientTransaction clientTransaction = (ClientTransaction) getLatestInviteTransaction();\r\n    try {\r\n        Request cancel = clientTransaction.createCancel();\r\n        ClientTransaction cancelTransaction = getJainSipProvider().getNewClientTransaction(cancel);\r\n        cancelTransaction.sendRequest();\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"sent request:\\n\" + cancel);\r\n    } catch (SipException ex) {\r\n        ProtocolProviderServiceSipImpl.throwOperationFailedException(\"Failed to send the CANCEL request\", OperationFailedException.NETWORK_FAILURE, ex, logger);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ProtocolProviderServiceJabberImpl.loadJabberServiceClasses",
	"Comment": "load jabber service class, their static context will registerwhat is needed. used in android as when using the other jarsthese services are loaded from the jar manifest.",
	"Method": "void loadJabberServiceClasses(){\r\n    if (!OSUtils.IS_ANDROID)\r\n        return;\r\n    try {\r\n        SmackConfiguration.getVersion();\r\n        Class.forName(ServiceDiscoveryManager.class.getName());\r\n        Class.forName(DelayInformation.class.getName());\r\n        Class.forName(org.jivesoftware.smackx.provider.DelayInformationProvider.class.getName());\r\n        Class.forName(org.jivesoftware.smackx.bytestreams.socks5.Socks5BytestreamManager.class.getName());\r\n        Class.forName(XHTMLManager.class.getName());\r\n        Class.forName(org.jivesoftware.smackx.bytestreams.ibb.InBandBytestreamManager.class.getName());\r\n    } catch (ClassNotFoundException e) {\r\n        logger.error(\"Error loading classes in smack\", e);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.AbstractOperationSetTelephonyConferencing.getBasicTelephony",
	"Comment": "gets the operationsetbasictelephony implementation which thisinstance uses to carry out tasks such as establishing calls.",
	"Method": "OperationSetBasicTelephonyT getBasicTelephony(){\r\n    return basicTelephony;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipStackSharing.filterByAddress",
	"Comment": "removes from the specified list of candidates providers connected to aregistrar that does not match the ip address that we are receiving arequest from.",
	"Method": "void filterByAddress(List<ProtocolProviderServiceSipImpl> candidates,Request request){\r\n    Iterator<ProtocolProviderServiceSipImpl> iterPP = candidates.iterator();\r\n    while (iterPP.hasNext()) {\r\n        ProtocolProviderServiceSipImpl candidate = iterPP.next();\r\n        boolean forceProxyBypass = candidate.getAccountID().getAccountPropertyBoolean(ProtocolProviderFactory.FORCE_PROXY_BYPASS, false);\r\n        if (forceProxyBypass) {\r\n            continue;\r\n        }\r\n        if (candidate.getRegistrarConnection() == null) {\r\n            continue;\r\n        }\r\n        if (!candidate.getRegistrarConnection().isRegistrarless() && !candidate.getRegistrarConnection().isRequestFromSameConnection(request)) {\r\n            iterPP.remove();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.propertieseditor.SearchField.getUIClassID",
	"Comment": "returns the name of the l&f class that renders this component.",
	"Method": "String getUIClassID(){\r\n    return uiClassID;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractOperationSetDesktopSharingClient.fireRemoteControlRevoked",
	"Comment": "fires a remotecontrolgrantedevent to all registered listeners.",
	"Method": "void fireRemoteControlRevoked(CallPeer peer){\r\n    RemoteControlListener listener = getListener(peer);\r\n    if (listener != null) {\r\n        listener.remoteControlRevoked(new RemoteControlRevokedEvent(peer));\r\n    }\r\n    this.removesNullAndRevokedControlPeer(peer.getPeerID());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetAdHocMultiUserChatIcqImpl.removePresenceListener",
	"Comment": "removes a listener that was being notified of changes in our status in aroom such as us being joined or dropped.",
	"Method": "void removePresenceListener(LocalUserAdHocChatRoomPresenceListener listener){\r\n    synchronized (presenceListeners) {\r\n        presenceListeners.remove(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.GroupNode.sortedAddContactGroup",
	"Comment": "creates a groupnode for the given uigroup,adds it to this group node and performs a sort at the end.",
	"Method": "GroupNode sortedAddContactGroup(UIGroupImpl uiGroup){\r\n    GroupNode groupNode;\r\n    synchronized (uiGroup) {\r\n        groupNode = new GroupNode(treeModel, uiGroup);\r\n        uiGroup.setGroupNode(groupNode);\r\n    }\r\n    if (children == null) {\r\n        add(groupNode);\r\n        fireNodeInserted(0);\r\n    } else {\r\n        int insertionPoint = Collections.binarySearch(children, groupNode, nodeComparator);\r\n        if (insertionPoint < 0) {\r\n            insertionPoint = (insertionPoint + 1) * -1;\r\n        } else {\r\n            ++insertionPoint;\r\n        }\r\n        insert(groupNode, insertionPoint);\r\n        fireNodeInserted(insertionPoint);\r\n    }\r\n    return groupNode;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapSearchSettingsImpl.setMaxResults",
	"Comment": "sets the maximum number of results to fetch from thedirectory when performing the search query.",
	"Method": "void setMaxResults(int maxResults){\r\n    if (maxResults < 1)\r\n        throw new IllegalArgumentException(\"number of max results should be > 0\");\r\n    this.maxResults = maxResults;\r\n    this.isMaxResultsSet = true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.QualityControlWrapper.setPreferredRemoteSendMaxPreset",
	"Comment": "changes the current video settings for the peer with the desiredquality settings and inform the peer to stream the videowith those settings.",
	"Method": "void setPreferredRemoteSendMaxPreset(QualityPreset preset){\r\n    QualityControl qControls = getMediaQualityControl();\r\n    if (qControls != null) {\r\n        qControls.setRemoteSendMaxPreset(preset);\r\n        try {\r\n            peer.sendReInvite();\r\n        } catch (Throwable cause) {\r\n            String message = \"Failed to re-invite for video quality change.\";\r\n            logger.error(message, cause);\r\n            throw new MediaException(message, MediaException.GENERAL_ERROR, cause);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.contactlist.TestMetaContactList.testContactListRetrieving",
	"Comment": "verifies that the contacts retrieved by the meta contact list service,matches the one that were in the mock provider.",
	"Method": "void testContactListRetrieving(){\r\n    MockContactGroup expectedRoot = (MockContactGroup) MclSlickFixture.mockPresOpSet.getServerStoredContactListRoot();\r\n    logger.info(\"============== Predefined contact List ==============\");\r\n    logger.info(\"rootGroup=\" + expectedRoot.getGroupName() + \" rootGroup.childContacts=\" + expectedRoot.countContacts() + \"rootGroup.childGroups=\" + expectedRoot.countSubgroups() + \" Printing rootGroupContents=\\n\" + expectedRoot.toString());\r\n    MetaContactGroup actualRoot = fixture.metaClService.getRoot();\r\n    logger.info(\"================ Meta Contact List =================\");\r\n    logger.info(\"rootGroup=\" + actualRoot.getGroupName() + \" rootGroup.childContacts=\" + actualRoot.countChildContacts() + \" rootGroup.childGroups=\" + actualRoot.countSubgroups() + \" Printing rootGroupContents=\\n\" + actualRoot.toString());\r\n    // there's no reason to have empty meta groups here so\r\n    MclSlickFixture.assertGroupEquals(// there's no reason to have empty meta groups here so\r\n    expectedRoot, actualRoot, false);\r\n}"
}, {
	"Path": "net.librec.math.structure.DataFrame.toSparseMatrix",
	"Comment": "get sparsematrix by the index columns and the value column of dataframe",
	"Method": "SequentialAccessSparseMatrix toSparseMatrix(Configuration conf,SequentialAccessSparseMatrix toSparseMatrix,SequentialAccessSparseMatrix toSparseMatrix,double binThold,SequentialAccessSparseMatrix toSparseMatrix,String[] headerIndices,SequentialAccessSparseMatrix toSparseMatrix,String[] headerIndics,double binThold,SequentialAccessSparseMatrix toSparseMatrix,String str,SequentialAccessSparseMatrix toSparseMatrix,int indexColumn1,int indexColumn2,int valueColumn,SequentialAccessSparseMatrix toSparseMatrix,int indexColumn1,int indexColumn2,int valueColumn,double binThold){\r\n    if ((data.size() == 0) || data.size() <= valueColumn) {\r\n        return null;\r\n    }\r\n    if (Objects.equals(attrType.get(valueColumn), \"NUMERIC\")) {\r\n        Table<Integer, Integer, Double> dataTable = HashBasedTable.create();\r\n        for (int i = getData().get(0).size() - 1; i >= 0; i--) {\r\n            int row = (int) getData().get(indexColumn1).get(i);\r\n            int col = (int) getData().get(indexColumn2).get(i);\r\n            Double rate;\r\n            rate = valueColumn == -1 ? 1.0 : (Double) getData().get(valueColumn).get(i);\r\n            if (binThold >= 0) {\r\n                rate = rate > binThold ? 1.0 : -1.0;\r\n            }\r\n            dataTable.put(row, col, rate);\r\n        }\r\n        flushCache(Arrays.asList(indexColumn1, indexColumn2));\r\n        SequentialAccessSparseMatrix matrix = new SequentialAccessSparseMatrix(featuresInnerMapping.get(header.get(indexColumn1)).size(), featuresInnerMapping.get(header.get(indexColumn2)).size(), dataTable);\r\n        return matrix;\r\n    } else if (Objects.equals(attrType.get(valueColumn), \"DATE\")) {\r\n        Table<Integer, Integer, Long> dataTable = HashBasedTable.create();\r\n        for (int i = getData().get(0).size() - 1; i >= 0; i--) {\r\n            int row = (int) getData().get(indexColumn1).get(i);\r\n            int col = (int) getData().get(indexColumn2).get(i);\r\n            Long mms = 0L;\r\n            mms = (Long) getData().get(valueColumn).get(i);\r\n            dataTable.put(row, col, mms);\r\n        }\r\n        flushCache(Arrays.asList(indexColumn1, indexColumn2));\r\n        SequentialAccessSparseMatrix matrix = new SequentialAccessSparseMatrix(featuresInnerMapping.get(header.get(indexColumn1)).size(), featuresInnerMapping.get(header.get(indexColumn2)).size(), dataTable);\r\n        return matrix;\r\n    } else {\r\n        LOG.info(\"fail to create sparseMatrix, please check attributes type\");\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactGroupImpl.getParentMetaContactGroup",
	"Comment": "returns the metacontactgroup currently containing this group or null ifthis is the root group",
	"Method": "MetaContactGroup getParentMetaContactGroup(){\r\n    return parentMetaContactGroup;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.systray.AbstractSystrayService.initHandlers",
	"Comment": "initializes popup handler by searching registered services for classpopupmessagehandler.",
	"Method": "void initHandlers(){\r\n    try {\r\n        bundleContext.addServiceListener(new ServiceListenerImpl(), \"(objectclass=\" + PopupMessageHandler.class.getName() + \")\");\r\n    } catch (Exception e) {\r\n        logger.warn(e);\r\n    }\r\n    Collection<ServiceReference<PopupMessageHandler>> handlerRefs = ServiceUtils.getServiceReferences(bundleContext, PopupMessageHandler.class);\r\n    if (!handlerRefs.isEmpty()) {\r\n        ConfigurationService config = ServiceUtils.getService(bundleContext, ConfigurationService.class);\r\n        String configuredHandler = config.getString(\"systray.POPUP_HANDLER\");\r\n        for (ServiceReference<PopupMessageHandler> handlerRef : handlerRefs) {\r\n            PopupMessageHandler handler = bundleContext.getService(handlerRef);\r\n            String handlerName = handler.getClass().getName();\r\n            if (!containsHandler(handlerName)) {\r\n                addPopupHandler(handler);\r\n                if (logger.isInfoEnabled()) {\r\n                    logger.info(\"added the following popup handler : \" + handler);\r\n                }\r\n                if ((configuredHandler != null) && configuredHandler.equals(handler.getClass().getName())) {\r\n                    setActivePopupMessageHandler(handler);\r\n                }\r\n            }\r\n        }\r\n        if (configuredHandler == null)\r\n            selectBestPopupMessageHandler();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.generalconfig.SilkConfigForm.restoreDefaults",
	"Comment": "restores the ui components and the configuration to their default state",
	"Method": "void restoreDefaults(){\r\n    fecCheckbox.setSelected(FEC_DEFAULT);\r\n    configurationService.setProperty(Constants.PROP_SILK_FEC, FEC_DEFAULT);\r\n    assumePLCheckbox.setSelected(FEC_FORCE_PL_DEFAULT);\r\n    configurationService.setProperty(Constants.PROP_SILK_ASSUME_PL, FEC_FORCE_PL_DEFAULT);\r\n    SATField.setText(FEC_SAT_DEFAULT);\r\n    configurationService.setProperty(Constants.PROP_SILK_FEC_SAT, FEC_SAT_DEFAULT);\r\n    advertiseFECCheckbox.setSelected(FEC_ADVERTISE_DEFAULT);\r\n    configurationService.setProperty(Constants.PROP_SILK_ADVERSISE_FEC, FEC_ADVERTISE_DEFAULT);\r\n}"
}, {
	"Path": "net.librec.math.algorithm.Randoms.gaussian",
	"Comment": "return a real number from a gaussian distribution with given mean and stddev.",
	"Method": "double gaussian(double mu,double sigma){\r\n    return mu + sigma * r.nextGaussian();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapServiceImpl.createContactSource",
	"Comment": "creates a contact source corresponding to the given ldap directory.",
	"Method": "ContactSourceService createContactSource(LdapDirectory ldapDir){\r\n    return LdapActivator.registerContactSource(ldapDir);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.login.DefaultSecurityAuthority.setUserNameEditable",
	"Comment": "sets the usernameeditable property, which indicates if the user namecould be changed by user or not.",
	"Method": "void setUserNameEditable(boolean isUserNameEditable){\r\n    this.isUserNameEditable = isUserNameEditable;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ChatInviteDialog.initContactListData",
	"Comment": "initializes the left contact list with the contacts that could be addedto the current chat session.",
	"Method": "void initContactListData(){\r\n    this.inviteChatTransport = chatPanel.findInviteChatTransport();\r\n    srcContactList.addContactSource(new ProtocolContactSourceServiceImpl(inviteChatTransport.getProtocolProvider(), OperationSetMultiUserChat.class));\r\n    srcContactList.setDefaultFilter(new ChatInviteContactListFilter(srcContactList));\r\n    srcContactList.applyDefaultFilter();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.accountinfo.AccountInfoPanel.getAccountsTable",
	"Comment": "returns mapping between registered accountids and their respectiveaccountdetailspanel that contains all the details for the account.",
	"Method": "Map<AccountID, AccountDetailsPanel> getAccountsTable(){\r\n    return accountsTable;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ShowPreviewDialog.close",
	"Comment": "all functions implemented in this method will be invoked when userpresses the escape key.",
	"Method": "void close(boolean escaped){\r\n    cancelButton.doClick();\r\n}"
}, {
	"Path": "net.librec.recommender.baseline.ItemAverageRecommender.predict",
	"Comment": "the item ratings average value as the predictive rating for user useridx on item itemidx.",
	"Method": "double predict(int userIdx,int itemIdx){\r\n    if (!itemMeans.containsKey(itemIdx)) {\r\n        SequentialSparseVector itemRatingsVector = trainMatrix.column(itemIdx);\r\n        double mean = itemRatingsVector.getNumEntries() > 0 ? itemRatingsVector.mean() : globalMean;\r\n        itemMeans.put(itemIdx, mean);\r\n    }\r\n    return itemMeans.get(itemIdx);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallDialog.getMinimumSize",
	"Comment": "overrides getminimumsize and checks the minimum size thatis needed to display buttons and use it for minimum size ifneeded.",
	"Method": "Dimension getMinimumSize(){\r\n    Dimension minSize = super.getMinimumSize();\r\n    if (callPanel != null) {\r\n        int minButtonWidth = callPanel.getMinimumButtonWidth();\r\n        if (minButtonWidth > minSize.getWidth())\r\n            minSize = new Dimension(minButtonWidth, 300);\r\n    }\r\n    return minSize;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.MetaContactRightButtonMenu.createContactStatusImage",
	"Comment": "obtains the status icon for the given protocol contact andadds to it the account index information.",
	"Method": "Image createContactStatusImage(Contact protoContact){\r\n    return ImageLoader.getIndexedProtocolImage(ImageUtils.getBytesInImage(protoContact.getPresenceStatus().getStatusIcon()), protoContact.getProtocolProvider());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallInfoFrame.createCallInfoWindow",
	"Comment": "creates different types of windows depending on the operating system.",
	"Method": "JDialog createCallInfoWindow(String title){\r\n    JDialog callInfoWindow = null;\r\n    if (OSUtils.IS_MAC) {\r\n        HudWindow window = new HudWindow();\r\n        JDialog dialog = window.getJDialog();\r\n        dialog.setTitle(title);\r\n        callInfoWindow = window.getJDialog();\r\n        callInfoWindow.setResizable(true);\r\n        fontColor = \"FFFFFF\";\r\n    } else {\r\n        SIPCommDialog dialog = new SIPCommDialog(false);\r\n        callInfoWindow = dialog;\r\n        callInfoWindow.setTitle(title);\r\n        fontColor = \"000000\";\r\n    }\r\n    return callInfoWindow;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.callhistory.CallHistoryServiceImpl.findByEndDate",
	"Comment": "returns all the calls made by all the contactsin the supplied metacontact before the given date",
	"Method": "Collection<CallRecord> findByEndDate(MetaContact contact,Date endDate,Collection<CallRecord> findByEndDate,Date endDate){\r\n    TreeSet<CallRecord> result = new TreeSet<CallRecord>(new CallRecordComparator());\r\n    try {\r\n        History history = this.getHistory(null, null);\r\n        historyReader = history.getReader();\r\n        addHistorySearchProgressListeners(historyReader, 1);\r\n        QueryResultSet<HistoryRecord> rs = historyReader.findByEndDate(endDate);\r\n        while (rs.hasNext()) {\r\n            HistoryRecord hr = rs.next();\r\n            result.add(convertHistoryRecordToCallRecord(hr));\r\n        }\r\n        removeHistorySearchProgressListeners(historyReader);\r\n    } catch (IOException ex) {\r\n        logger.error(\"Could not read history\", ex);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.sip.TestOperationSetPresence.testChangingState",
	"Comment": "verify that changing state to all supported statuses works as expected.",
	"Method": "void testChangingState(){\r\n    Iterator<PresenceStatus> supportedStatusSetIter = this.operationSetPresence1.getSupportedStatusSet();\r\n    while (supportedStatusSetIter.hasNext()) {\r\n        PresenceStatus supportedStatus = supportedStatusSetIter.next();\r\n        logger.trace(\"Will test a transition to \" + supportedStatus.getStatusName());\r\n        subtestStateTransition(supportedStatus);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.mailnotification.MailThreadInfo.senders",
	"Comment": "returns an iterator over a list of one or more sender instances, each ofwhich describes a participant in this thread.",
	"Method": "Iterator<Sender> senders(){\r\n    return senders.iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl.setDialog",
	"Comment": "sets the jain sip dialog that has been created by the application forcommunication with this call peer.",
	"Method": "void setDialog(Dialog dialog){\r\n    this.jainSipDialog = dialog;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.MainFrame.getContactHandlerForProvider",
	"Comment": "returns the contacteventhandler for contacts given by theprotocolprovider. the contacteventhandler is meant tobe used from other bundles in order to change the default behavior ofevents generated when clicking a contact.",
	"Method": "ContactEventHandler getContactHandlerForProvider(ProtocolProviderService protocolProvider){\r\n    Collection<ServiceReference<ContactEventHandler>> serRefs;\r\n    String osgiFilter = \"(\" + ProtocolProviderFactory.PROTOCOL + \"=\" + protocolProvider.getProtocolName() + \")\";\r\n    try {\r\n        serRefs = GuiActivator.bundleContext.getServiceReferences(ContactEventHandler.class, osgiFilter);\r\n    } catch (InvalidSyntaxException ex) {\r\n        serRefs = null;\r\n        logger.error(\"GuiActivator : \" + ex);\r\n    }\r\n    if ((serRefs == null) || serRefs.isEmpty())\r\n        return null;\r\n    return GuiActivator.bundleContext.getService(serRefs.iterator().next());\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.icqaccregwizz.Resources.getString",
	"Comment": "returns an internationalized string corresponding to the given key.",
	"Method": "String getString(String key){\r\n    return getResources().getI18NString(key);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.SingleWindowContainer.containsFocusOwner",
	"Comment": "indicates if one of the contained components is currently the owner ofthe keyboard focus.",
	"Method": "boolean containsFocusOwner(){\r\n    ChatPanel chat = getCurrentChat();\r\n    return (chat != null) && chat.getChatWritePanel().getEditorPane().isFocusOwner();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.ConferenceDescription.getSupportedTransports",
	"Comment": "returns the transports supported by this conferencedescription",
	"Method": "Set<String> getSupportedTransports(){\r\n    return new HashSet<String>(transports);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl.convertReasonCodeToSIPCode",
	"Comment": "converts the codes for hangup from operationsetbasictelephony oneto the sip codes.",
	"Method": "int convertReasonCodeToSIPCode(int reasonCode){\r\n    switch(reasonCode) {\r\n        case HANGUP_REASON_NORMAL_CLEARING:\r\n            return Response.ACCEPTED;\r\n        case HANGUP_REASON_ENCRYPTION_REQUIRED:\r\n            return Response.SESSION_NOT_ACCEPTABLE;\r\n        case HANGUP_REASON_TIMEOUT:\r\n            return Response.REQUEST_TIMEOUT;\r\n        case HANGUP_REASON_BUSY_HERE:\r\n            return Response.BUSY_HERE;\r\n        default:\r\n            return -1;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractOperationSetPersistentPresence.removeProviderPresenceStatusListener",
	"Comment": "unregisters the specified listener so that it does not receive furtherevents upon changes in local presence status.",
	"Method": "void removeProviderPresenceStatusListener(ProviderPresenceStatusListener listener){\r\n    synchronized (providerPresenceStatusListeners) {\r\n        providerPresenceStatusListeners.remove(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.sip.SipSlickFixture.setUp",
	"Comment": "initializes protocol provider references and whatever else there is toinitialize.",
	"Method": "void setUp(){\r\n    ServiceReference[] serRefs = null;\r\n    String osgiFilter = \"(\" + ProtocolProviderFactory.PROTOCOL + \"=\" + ProtocolNames.SIP + \")\";\r\n    try {\r\n        serRefs = bc.getServiceReferences(ProtocolProviderFactory.class.getName(), osgiFilter);\r\n    } catch (InvalidSyntaxException ex) {\r\n        fail(osgiFilter + \" is not a valid osgi filter\");\r\n    }\r\n    assertTrue(\"Failed to find a provider factory service for protocol SIP\", (serRefs != null) && (serRefs.length > 0));\r\n    providerFactory = (ProtocolProviderFactory) bc.getService(serRefs[0]);\r\n    userID1 = System.getProperty(SipProtocolProviderServiceLick.ACCOUNT_1_PREFIX + ProtocolProviderFactory.USER_ID);\r\n    userID2 = System.getProperty(SipProtocolProviderServiceLick.ACCOUNT_2_PREFIX + ProtocolProviderFactory.USER_ID);\r\n    ServiceReference[] sipProvider1Refs = bc.getServiceReferences(ProtocolProviderService.class.getName(), \"(&\" + \"(\" + ProtocolProviderFactory.PROTOCOL + \"=\" + ProtocolNames.SIP + \")\" + \"(\" + ProtocolProviderFactory.USER_ID + \"=\" + userID1 + \")\" + \")\");\r\n    assertNotNull(\"No Protocol Provider was found for SIP account1:\" + userID1, sipProvider1Refs);\r\n    assertTrue(\"No Protocol Provider was found for SIP account1:\" + userID1, sipProvider1Refs.length > 0);\r\n    ServiceReference[] sipProvider2Refs = bc.getServiceReferences(ProtocolProviderService.class.getName(), \"(&\" + \"(\" + ProtocolProviderFactory.PROTOCOL + \"=\" + ProtocolNames.SIP + \")\" + \"(\" + ProtocolProviderFactory.USER_ID + \"=\" + userID2 + \")\" + \")\");\r\n    assertNotNull(\"No Protocol Provider was found for SIP account2:\" + userID2, sipProvider2Refs);\r\n    assertTrue(\"No Protocol Provider was found for SIP account2:\" + userID2, sipProvider2Refs.length > 0);\r\n    provider1ServiceRef = sipProvider1Refs[0];\r\n    provider1 = (ProtocolProviderService) bc.getService(provider1ServiceRef);\r\n    provider2ServiceRef = sipProvider2Refs[0];\r\n    provider2 = (ProtocolProviderService) bc.getService(provider2ServiceRef);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ContactGroupSipImpl.getContact",
	"Comment": "returns the contact with the specified address or identifier.",
	"Method": "Contact getContact(String id){\r\n    Iterator<Contact> contactsIter = contacts();\r\n    while (contactsIter.hasNext()) {\r\n        ContactSipImpl contact = (ContactSipImpl) contactsIter.next();\r\n        if (contact.getUri().equals(id) || contact.getAddress().equals(id)) {\r\n            return contact;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.contactinfo.ContactInfoDetailsPanel.createUnsupportedPanel",
	"Comment": "creates the panel that indicates to the user that the currently selectedcontact does not support server stored contact info.",
	"Method": "JPanel createUnsupportedPanel(){\r\n    JTextArea unsupportedTextArea = new JTextArea(Resources.getString(\"service.gui.CONTACT_INFO_NOT_SUPPORTED\"));\r\n    unsupportedTextArea.setEditable(false);\r\n    unsupportedTextArea.setLineWrap(true);\r\n    JPanel unsupportedPanel = new TransparentPanel(new BorderLayout());\r\n    unsupportedPanel.add(unsupportedTextArea);\r\n    return unsupportedPanel;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.OperationSetBasicInstantMessagingGibberishImpl.isContentTypeSupported",
	"Comment": "determines wheter the protocol supports the supplied content type",
	"Method": "boolean isContentTypeSupported(String contentType){\r\n    if (contentType.equals(DEFAULT_MIME_TYPE))\r\n        return true;\r\n    else\r\n        return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.jabber.JabberAccountRegistration.loadAccount",
	"Comment": "fills this registration object with configuration properties from givenaccount.",
	"Method": "void loadAccount(AccountID account,BundleContext bundleContext){\r\n    mergeProperties(account.getAccountProperties(), accountProperties);\r\n    String password = ProtocolProviderFactory.getProtocolProviderFactory(bundleContext, ProtocolNames.JABBER).loadPassword(account);\r\n    setUserID(account.getUserID());\r\n    editedAccUID = account.getAccountUniqueID();\r\n    setPassword(password);\r\n    rememberPassword = password != null;\r\n    securityRegistration.loadAccount(account);\r\n    this.additionalStunServers.clear();\r\n    for (int i = 0; i < StunServerDescriptor.MAX_STUN_SERVER_COUNT; i++) {\r\n        StunServerDescriptor stunServer = StunServerDescriptor.loadDescriptor(accountProperties, ProtocolProviderFactory.STUN_PREFIX + i);\r\n        if (stunServer == null)\r\n            break;\r\n        String stunPassword = loadStunPassword(bundleContext, account, ProtocolProviderFactory.STUN_PREFIX + i);\r\n        if (stunPassword != null) {\r\n            stunServer.setPassword(stunPassword);\r\n        }\r\n        addStunServer(stunServer);\r\n    }\r\n    this.additionalJingleNodes.clear();\r\n    for (int i = 0; i < JingleNodeDescriptor.MAX_JN_RELAY_COUNT; i++) {\r\n        JingleNodeDescriptor jn = JingleNodeDescriptor.loadDescriptor(accountProperties, JingleNodeDescriptor.JN_PREFIX + i);\r\n        if (jn == null)\r\n            break;\r\n        addJingleNodes(jn);\r\n    }\r\n    encodingsRegistration.loadAccount(account, ServiceUtils.getService(bundleContext, MediaService.class));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.geolocation.GeolocationPacketExtension.getTimestamp",
	"Comment": "returns a string containing a utc timestamp specifying themoment when the reading was taken.",
	"Method": "String getTimestamp(){\r\n    return timestamp;\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.common.ParserTest.testParseCase6_2_3",
	"Comment": "similar to the server side 6.2.3 testcase. lots of small 1 byte utf8 text frames, representing 1 overall text message.",
	"Method": "void testParseCase6_2_3(){\r\n    String utf8 = \"Hello-?@?????-UTF-8!!\";\r\n    byte[] msg = StringUtil.getUtf8Bytes(utf8);\r\n    List<WebSocketFrame> send = new ArrayList();\r\n    int textCount = 0;\r\n    int continuationCount = 0;\r\n    int len = msg.length;\r\n    boolean continuation = false;\r\n    byte[] mini;\r\n    for (int i = 0; i < len; i++) {\r\n        DataFrame frame = null;\r\n        if (continuation) {\r\n            frame = new ContinuationFrame();\r\n            continuationCount++;\r\n        } else {\r\n            frame = new TextFrame();\r\n            textCount++;\r\n        }\r\n        mini = new byte[1];\r\n        mini[0] = msg[i];\r\n        frame.setPayload(ByteBuffer.wrap(mini));\r\n        boolean isLast = (i >= (len - 1));\r\n        frame.setFin(isLast);\r\n        send.add(frame);\r\n        continuation = true;\r\n    }\r\n    send.add(new CloseInfo(StatusCode.NORMAL).asFrame());\r\n    ByteBuffer completeBuf = UnitGenerator.generate(send);\r\n    UnitParser parser = new UnitParser();\r\n    IncomingFramesCapture capture = new IncomingFramesCapture();\r\n    parser.setIncomingFramesHandler(capture);\r\n    parser.parse(completeBuf);\r\n    capture.assertErrorCount(0);\r\n    capture.assertHasFrame(OpCode.TEXT, textCount);\r\n    capture.assertHasFrame(OpCode.CONTINUATION, continuationCount);\r\n    capture.assertHasFrame(OpCode.CLOSE, 1);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.WhiteboardObjectDeliveredEvent.getDestinationContact",
	"Comment": "returns a reference to the contact that the sourcewhiteboardobject was sent to.",
	"Method": "Contact getDestinationContact(){\r\n    return to;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.removeChatConferenceCall",
	"Comment": "removes the given conferencedescription from the list of chat conferences in this chat panel chat.",
	"Method": "void removeChatConferenceCall(ConferenceDescription conferenceDescription){\r\n    if (chatConferencesDialog != null) {\r\n        chatConferencesDialog.removeConference(conferenceDescription);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.GuiActivator.getDemuxContactSourceService",
	"Comment": "returns the demuxcontactsourceservice obtained from the bundlecontext.",
	"Method": "DemuxContactSourceService getDemuxContactSourceService(){\r\n    if (demuxContactSourceService == null) {\r\n        demuxContactSourceService = ServiceUtils.getService(bundleContext, DemuxContactSourceService.class);\r\n    }\r\n    return demuxContactSourceService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.JabberActivator.getPacketLogging",
	"Comment": "returns a reference to the packetloggingservice implementationcurrently registered in the bundle context or null if no suchimplementation was found.",
	"Method": "PacketLoggingService getPacketLogging(){\r\n    if (packetLoggingService == null) {\r\n        packetLoggingService = ServiceUtils.getService(bundleContext, PacketLoggingService.class);\r\n    }\r\n    return packetLoggingService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomInvitationIrcImpl.getReason",
	"Comment": "returns the reason of this invitation, or null if there is no reason.",
	"Method": "String getReason(){\r\n    return this.reason;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.CryptoPacketExtension.equalsCryptoSuite",
	"Comment": "returns if the current crypto suite equals the one given in parameter.",
	"Method": "boolean equalsCryptoSuite(String cryptoSuite){\r\n    String currentCryptoSuite = this.getCryptoSuite();\r\n    return CryptoPacketExtension.equalsStrings(currentCryptoSuite, cryptoSuite);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.callhistory.CallHistoryServiceImpl.fireCallHistoryRecordReceivedEvent",
	"Comment": "fires the given event to all callhistoryrecordlistener listeners",
	"Method": "void fireCallHistoryRecordReceivedEvent(CallHistoryPeerRecordEvent event){\r\n    List<CallHistoryPeerRecordListener> tmpListeners;\r\n    synchronized (callHistoryRecordlisteners) {\r\n        tmpListeners = new LinkedList<CallHistoryPeerRecordListener>(callHistoryRecordlisteners);\r\n    }\r\n    for (CallHistoryPeerRecordListener listener : tmpListeners) {\r\n        listener.callPeerRecordReceived(event);\r\n    }\r\n}"
}, {
	"Path": "net.librec.math.structure.DenseVector.minus",
	"Comment": "return a new vector containing the element by element difference of the recipient and the argument",
	"Method": "DenseVector minus(Vector vector){\r\n    DenseVector resultVector = new VectorBasedDenseVector(cardinality());\r\n    for (VectorEntry vectorEntry : vector) {\r\n        int index = vectorEntry.index();\r\n        resultVector.set(index, get(index) - vectorEntry.get());\r\n    }\r\n    return resultVector;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.googlecontacts.GoogleContactsSourceService.stopped",
	"Comment": "notifies this googlecontactssourceservice that a specificgooglecontactsquery has stopped.",
	"Method": "void stopped(GoogleContactsQuery query){\r\n    synchronized (queries) {\r\n        if (queries.remove(query))\r\n            queries.notify();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.keybindingchooser.KeybindingChooserActivator.getKeybindingsService",
	"Comment": "returns a reference to a keybindingsservice implementation currentlyregistered in the bundle context or null if no such implementation wasfound.",
	"Method": "KeybindingsService getKeybindingsService(){\r\n    if (keybindingService == null) {\r\n        ServiceReference keybindingReference = bundleContext.getServiceReference(KeybindingsService.class.getName());\r\n        keybindingService = (KeybindingsService) bundleContext.getService(keybindingReference);\r\n    }\r\n    return keybindingService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.update.UpdateActivator.getBrowserLauncher",
	"Comment": "returns the browserlauncherservice obtained from the bundlecontext.",
	"Method": "BrowserLauncherService getBrowserLauncher(){\r\n    if (browserLauncher == null) {\r\n        browserLauncher = ServiceUtils.getService(bundleContext, BrowserLauncherService.class);\r\n    }\r\n    return browserLauncher;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.gibberishaccregwizz.GibberishAccountRegistrationWizard.getFirstPageIdentifier",
	"Comment": "returns the identifier of the page to show first in the wizard.",
	"Method": "Object getFirstPageIdentifier(){\r\n    return firstWizardPage.getIdentifier();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactListServiceImpl.addGroupToEventIgnoreList",
	"Comment": "registers group to the event ignore list. this would make themethod that is normally handling events for newly created groups ignoreany events for that particular group and leave the responsibility to themethod that added the group to the ignore list.",
	"Method": "void addGroupToEventIgnoreList(String group,ProtocolProviderService ownerProvider){\r\n    if (isGroupInEventIgnoreList(group, ownerProvider)) {\r\n        return;\r\n    }\r\n    List<ProtocolProviderService> existingProvList = this.groupEventIgnoreList.get(group);\r\n    if (existingProvList == null) {\r\n        existingProvList = new LinkedList<ProtocolProviderService>();\r\n    }\r\n    existingProvList.add(ownerProvider);\r\n    groupEventIgnoreList.put(group, existingProvList);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.sipaccregwizz.SIPAccountRegistrationWizard.getProtocolDescription",
	"Comment": "implements the accountregistrationwizard.getprotocoldescription method. returns the description of the protocol for this wizard.",
	"Method": "String getProtocolDescription(){\r\n    return Resources.getString(\"plugin.sipaccregwizz.PROTOCOL_DESCRIPTION\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatTransport.sendFile",
	"Comment": "sending files through a chat room is not yet supported by this chattransport implementation.",
	"Method": "FileTransfer sendFile(File file){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.notifsource.NotificationGroup.getSourceIndex",
	"Comment": "returns the index of this group in its source. in other words this isthe descriptor index.",
	"Method": "int getSourceIndex(){\r\n    return 0;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetTelephonyConferencingSipImpl.responseProcessed",
	"Comment": "notifies this methodprocessorlistener that a specificcallpeer has processed a specific sip response and hasreplied to it with a specific sip request.",
	"Method": "void responseProcessed(CallPeerSipImpl sourceCallPeer,Response response,Request request){\r\n    if (Response.OK == response.getStatusCode()) {\r\n        CSeqHeader cseqHeader = (CSeqHeader) response.getHeader(CSeqHeader.NAME);\r\n        if ((cseqHeader != null) && Request.INVITE.equalsIgnoreCase(cseqHeader.getMethod()))\r\n            inviteCompleted(sourceCallPeer, response, request);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.colibri.ColibriConferenceIQ.getOrCreateContent",
	"Comment": "returns a content from the list of contents of thisconference iq which has a specific name. if no suchcontent exists at the time of the invocation of the method,initializes a new content instance with the specifiedcontentname and includes it into this conference iq.",
	"Method": "Content getOrCreateContent(String contentName){\r\n    Content content = getContent(contentName);\r\n    if (content == null) {\r\n        content = new Content(contentName);\r\n        addContent(content);\r\n    }\r\n    return content;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ContactSipImpl.toString",
	"Comment": "returns a string representation of this contact, containing most of itsrepresentative details.",
	"Method": "String toString(){\r\n    StringBuffer buff = new StringBuffer(\"ContactSipImpl[ DisplayName=\").append(getDisplayName()).append(\"]\");\r\n    return buff.toString();\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.gibberish.TestAccountUninstallation.testInstallationPersistency",
	"Comment": "stops and removes the tested bundle, verifies that it has unregisteredits provider, then reloads and restarts the bundle and verifies thatthe protocol provider is reregistered in the bundle context.",
	"Method": "void testInstallationPersistency(){\r\n    Bundle providerBundle = GibberishSlickFixture.findProtocolProviderBundle(fixture.provider1);\r\n    GibberishSlickFixture.providerBundle = providerBundle;\r\n    assertNotNull(\"Couldn't find a bundle for the tested provider\", providerBundle);\r\n    providerBundle.stop();\r\n    assertTrue(\"Couldn't stop the protocol provider bundle. State was \" + providerBundle.getState(), Bundle.ACTIVE != providerBundle.getState() && Bundle.STOPPING != providerBundle.getState());\r\n    providerBundle.uninstall();\r\n    assertEquals(\"Couldn't stop the protocol provider bundle.\", Bundle.UNINSTALLED, providerBundle.getState());\r\n    ServiceReference[] gibberishProviderRefs = null;\r\n    try {\r\n        gibberishProviderRefs = GibberishSlickFixture.bc.getServiceReferences(ProtocolProviderService.class.getName(), \"(&\" + \"(\" + ProtocolProviderFactory.PROTOCOL + \"=Gibberish)\" + \"(\" + ProtocolProviderFactory.USER_ID + \"=\" + fixture.userID1 + \")\" + \")\");\r\n    } catch (InvalidSyntaxException ex) {\r\n        fail(\"We apparently got our filter wrong: \" + ex.getMessage());\r\n    }\r\n    assertTrue(\"A Protocol Provider Service was still regged as an osgi service \" + \"for Gibberish URI:\" + fixture.userID1 + \"After it was explicitly uninstalled\", gibberishProviderRefs == null || gibberishProviderRefs.length == 0);\r\n    assertTrue(\"The Gibberish provider factory kept a reference to the provider we \" + \"just uninstalled (uri=\" + fixture.userID1 + \")\", fixture.providerFactory.getRegisteredAccounts().isEmpty() && fixture.providerFactory.getProviderForAccount(fixture.provider1.getAccountID()) == null);\r\n    providerBundle = GibberishSlickFixture.bc.installBundle(providerBundle.getLocation());\r\n    GibberishSlickFixture.providerBundle = providerBundle;\r\n    assertEquals(\"Couldn't re-install protocol provider bundle.\", Bundle.INSTALLED, providerBundle.getState());\r\n    AccountManagerUtils.startBundleAndWaitStoredAccountsLoaded(GibberishSlickFixture.bc, providerBundle, \"Gibberish\");\r\n    assertEquals(\"Couldn't re-start protocol provider bundle.\", Bundle.ACTIVE, providerBundle.getState());\r\n    try {\r\n        gibberishProviderRefs = GibberishSlickFixture.bc.getServiceReferences(ProtocolProviderService.class.getName(), \"(&\" + \"(\" + ProtocolProviderFactory.PROTOCOL + \"=Gibberish)\" + \"(\" + ProtocolProviderFactory.USER_ID + \"=\" + fixture.userID1 + \")\" + \")\");\r\n    } catch (InvalidSyntaxException ex) {\r\n        fail(\"We apparently got our filter wrong \" + ex.getMessage());\r\n    }\r\n    assertTrue(\"A Protocol Provider Service was not restored after being\" + \"reinstalled. Gibberish URI:\" + fixture.userID1, gibberishProviderRefs != null && gibberishProviderRefs.length > 0);\r\n    ServiceReference[] gibberishFactoryRefs = null;\r\n    try {\r\n        gibberishFactoryRefs = GibberishSlickFixture.bc.getServiceReferences(ProtocolProviderFactory.class.getName(), \"(\" + ProtocolProviderFactory.PROTOCOL + \"=Gibberish)\");\r\n    } catch (InvalidSyntaxException ex) {\r\n        fail(\"We apparently got our filter wrong \" + ex.getMessage());\r\n    }\r\n    fixture.providerFactory = (ProtocolProviderFactory) GibberishSlickFixture.bc.getService(gibberishFactoryRefs[0]);\r\n    fixture.provider1 = (ProtocolProviderService) GibberishSlickFixture.bc.getService(gibberishProviderRefs[0]);\r\n    assertTrue(\"The Gibberish provider did not restore its own reference to the \" + \"provider that we just reinstalled (URI=\" + fixture.userID1 + \")\", !fixture.providerFactory.getRegisteredAccounts().isEmpty() && fixture.providerFactory.getProviderForAccount(fixture.provider1.getAccountID()) != null);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.SingleCallInProgressPolicy.addOperationSetBasicTelephonyListener",
	"Comment": "registers a specific operationsetbasictelephony with this policyin order to have the rules of the latter apply to the callscreated by the former.",
	"Method": "void addOperationSetBasicTelephonyListener(OperationSetBasicTelephony<? extends ProtocolProviderService> telephony){\r\n    if (logger.isTraceEnabled()) {\r\n        logger.trace(\"Call listener added to provider.\");\r\n    }\r\n    telephony.addCallListener(listener);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.TreeContactList.getContactSources",
	"Comment": "returns the list of registered contact sources to search in.",
	"Method": "Collection<UIContactSource> getContactSources(List<UIContactSource> getContactSources,int type){\r\n    List<UIContactSource> sources = new ArrayList<UIContactSource>();\r\n    Iterator<UIContactSource> extSourcesIter = contactSources.iterator();\r\n    while (extSourcesIter.hasNext()) {\r\n        UIContactSource extSource = extSourcesIter.next();\r\n        if (extSource.getContactSourceService().getType() == type)\r\n            sources.add(extSource);\r\n    }\r\n    return sources;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.removeTypingNotification",
	"Comment": "removes the typing notification message from the conversation panel.",
	"Method": "void removeTypingNotification(){\r\n    addTypingNotification(\" \");\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.contactlist.event.MetaContactAvatarUpdateEvent.getOldAvatar",
	"Comment": "returns the previously active avatar of the source meta contact as it wasnow, before the change.",
	"Method": "byte[] getOldAvatar(){\r\n    return (byte[]) getOldValue();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.GeolocationEvent.toString",
	"Comment": "returns a string representation of this geolocationcontactchangeevent",
	"Method": "String toString(){\r\n    StringBuffer buff = new StringBuffer(\"ContactGeolocationPresenceChangeEvent-[ ContactID=\");\r\n    buff.append(getSourceContact().getAddress());\r\n    return buff.append(\", NewLocation=\").append(getNewLocation()).append(\"]\").toString();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ContactGroupJabberImpl.isPersistent",
	"Comment": "determines whether or not this contact group is being stored by theserver. non persistent contact groups exist for the sole purpose ofcontaining non persistent contacts.",
	"Method": "boolean isPersistent(){\r\n    return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactListServiceImpl.supportedOperationSetsChanged",
	"Comment": "notifies this listener that the list of the operationsetcapabilities of a contact has changed.",
	"Method": "void supportedOperationSetsChanged(ContactCapabilitiesEvent event){\r\n    MetaContactImpl metaContactImpl = (MetaContactImpl) findMetaContactByContact(event.getSourceContact());\r\n    if (metaContactImpl == null)\r\n        return;\r\n    Contact contact = event.getSourceContact();\r\n    metaContactImpl.updateCapabilities(contact, event.getOperationSets());\r\n    fireProtoContactEvent(contact, ProtoContactEvent.PROTO_CONTACT_MODIFIED, metaContactImpl, metaContactImpl);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.UIServiceImpl.minimize",
	"Comment": "implements minimize in the uiservice interface. minimizesthe main application window.",
	"Method": "void minimize(){\r\n    this.mainFrame.minimize();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ProtocolProviderFactorySipImpl.createService",
	"Comment": "initializes a new protocolproviderservicesipimpl instancewith a specific user id to represent a specific accountid.",
	"Method": "ProtocolProviderService createService(String userID,AccountID accountID){\r\n    ProtocolProviderServiceSipImpl service = new ProtocolProviderServiceSipImpl();\r\n    try {\r\n        service.initialize(userID, (SipAccountIDImpl) accountID);\r\n        storeAccount(accountID);\r\n    } catch (OperationFailedException ex) {\r\n        logger.error(\"Failed to initialize account\", ex);\r\n        throw new IllegalArgumentException(\"Failed to initialize account\" + ex.getMessage());\r\n    }\r\n    return service;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.AbstractOperationSetTelephonyConferencing.inviteCalleeToCall",
	"Comment": "invites the callee represented by the specified uri to an alreadyexisting call. the difference between this method and createconfcall isthat invitecalleetocall allows a user to transform an existing 1 to 1call into a conference call, or add new peers to an already establishedconference.",
	"Method": "CallPeer inviteCalleeToCall(String uri,Call call){\r\n    CalleeAddressT calleeAddress = parseAddressString(uri);\r\n    @SuppressWarnings(\"unchecked\")\r\n    MediaAwareCallT mediaAwareCallT = (MediaAwareCallT) call;\r\n    mediaAwareCallT.getConference().setConferenceFocus(true);\r\n    return doInviteCalleeToCall(calleeAddress, mediaAwareCallT);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.MetaUIGroup.getDisplayName",
	"Comment": "returns the display name of the underlying metacontactgroup.",
	"Method": "String getDisplayName(){\r\n    return metaGroup.getGroupName();\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.launchutils.SipCommunicatorLock.findLocalAddress",
	"Comment": "returns an inetaddress instance corresponding toaddressstr or null if no such address exists on thelocal interfaces.",
	"Method": "InetAddress findLocalAddress(String addressStr){\r\n    Enumeration<NetworkInterface> ifaces;\r\n    try {\r\n        ifaces = NetworkInterface.getNetworkInterfaces();\r\n    } catch (SocketException exc) {\r\n        logger.error(\"Could not extract the list of local intefcaces.\", exc);\r\n        return null;\r\n    }\r\n    while (ifaces.hasMoreElements()) {\r\n        NetworkInterface iface = ifaces.nextElement();\r\n        Enumeration<InetAddress> addreses = iface.getInetAddresses();\r\n        while (addreses.hasMoreElements()) {\r\n            InetAddress addr = addreses.nextElement();\r\n            if (addr.getHostAddress().equals(addressStr))\r\n                return addr;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.MetaContactChatSession.getHistoryBeforeDate",
	"Comment": "returns a collection of the last n number of messages given by count.",
	"Method": "Collection<Object> getHistoryBeforeDate(Date date,int count){\r\n    final MetaHistoryService metaHistory = GuiActivator.getMetaHistoryService();\r\n    if (metaHistory == null)\r\n        return null;\r\n    return metaHistory.findLastMessagesBefore(chatHistoryFilter, metaContact, date, ConfigurationUtils.getChatHistorySize());\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.busylampfield.BLFActivator.handleProviderRemoved",
	"Comment": "removes a protocol provider from the list when unregistered.",
	"Method": "void handleProviderRemoved(ProtocolProviderService protocolProvider){\r\n    OperationSetTelephonyBLF opset = protocolProvider.getOperationSet(OperationSetTelephonyBLF.class);\r\n    if (opset == null)\r\n        return;\r\n    opset.removeStatusListener(this);\r\n    for (OperationSetTelephonyBLF.Line line : opset.getCurrentlyMonitoredLines()) {\r\n        String groupName = line.getGroup();\r\n        if (groupName == null)\r\n            groupName = BLF_DEFAULT_GROUP_NAME;\r\n        ServiceRegistration<ContactSourceService> serviceReg = currentBLFGroups.remove(groupName);\r\n        if (serviceReg == null)\r\n            continue;\r\n        serviceReg.unregister();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.conference.ProtocolProviderSelectorBox.updateEnableStatus",
	"Comment": "sets the menu to enabled or disabled. the menu is enabled, as soon as itcontains one or more items. if it is empty, it is disabled.",
	"Method": "void updateEnableStatus(){\r\n    this.menu.setEnabled(this.menu.getItemCount() > 0);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractContact.fireContactResourceEvent",
	"Comment": "notifies all registered contactresourcelisteners that an eventhas occurred.",
	"Method": "void fireContactResourceEvent(ContactResourceEvent event){\r\n    if (resourceListeners == null)\r\n        return;\r\n    Collection<ContactResourceListener> listeners;\r\n    synchronized (resourceListeners) {\r\n        listeners = new ArrayList<ContactResourceListener>(resourceListeners);\r\n    }\r\n    Iterator<ContactResourceListener> listenersIter = listeners.iterator();\r\n    while (listenersIter.hasNext()) {\r\n        if (event.getEventType() == ContactResourceEvent.RESOURCE_ADDED)\r\n            listenersIter.next().contactResourceAdded(event);\r\n        else if (event.getEventType() == ContactResourceEvent.RESOURCE_REMOVED)\r\n            listenersIter.next().contactResourceRemoved(event);\r\n        else if (event.getEventType() == ContactResourceEvent.RESOURCE_MODIFIED)\r\n            listenersIter.next().contactResourceModified(event);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.skinresourcepack.SkinResourcePack.findResourcePaths",
	"Comment": "finds all properties files for the given path in this bundle.",
	"Method": "Iterator<String> findResourcePaths(String path,String pattern){\r\n    Iterator<String> bufferedResult = ressourcesFiles.get(path + \"/\" + pattern);\r\n    if (bufferedResult != null) {\r\n        return bufferedResult;\r\n    }\r\n    ArrayList<String> propertiesList = new ArrayList<String>();\r\n    @SuppressWarnings(\"unchecked\")\r\n    Enumeration<URL> propertiesUrls = bundleContext.getBundle().findEntries(path, pattern, false);\r\n    if (propertiesUrls != null) {\r\n        while (propertiesUrls.hasMoreElements()) {\r\n            URL propertyUrl = propertiesUrls.nextElement();\r\n            String propertyFilePath = propertyUrl.getPath().substring(1);\r\n            propertyFilePath = propertyFilePath.replaceAll(\"/\", \".\");\r\n            propertiesList.add(propertyFilePath);\r\n        }\r\n    }\r\n    Iterator<String> result = propertiesList.iterator();\r\n    ressourcesFiles.put(path + pattern, result);\r\n    return result;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetBasicTelephonyJabberImpl.processPacket",
	"Comment": "handles incoming jingle packets and passes them to the correspondingmethod based on their action.",
	"Method": "void processPacket(Packet packet){\r\n    IQ iq = (IQ) packet;\r\n    if (iq.getType() == IQ.Type.SET) {\r\n        IQ ack = IQ.createResultIQ(iq);\r\n        protocolProvider.getConnection().sendPacket(ack);\r\n    }\r\n    try {\r\n        if (iq instanceof JingleIQ)\r\n            processJingleIQ((JingleIQ) iq);\r\n    } catch (Throwable t) {\r\n        if (logger.isInfoEnabled()) {\r\n            String packetClass;\r\n            if (iq instanceof JingleIQ)\r\n                packetClass = \"Jingle\";\r\n            else\r\n                packetClass = packet.getClass().getSimpleName();\r\n            logger.info(\"Error while handling incoming \" + packetClass + \" packet: \", t);\r\n        }\r\n        if (t instanceof ThreadDeath)\r\n            throw (ThreadDeath) t;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatTransport.getMaximumFileLength",
	"Comment": "returns the maximum file length supported by the protocol in bytes.",
	"Method": "long getMaximumFileLength(){\r\n    return -1;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.whiteboard.gui.whiteboardshapes.WhiteboardShapePolygon.getPoints",
	"Comment": "returns a list of all the whiteboardpoint instances that thiswhiteboardobject is composed of.",
	"Method": "List<WhiteboardPoint> getPoints(){\r\n    return points;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockProvider.getProtocolName",
	"Comment": "mock implementation of the corresponding protocolproviderservice method.",
	"Method": "String getProtocolName(){\r\n    return PROTO_NAME;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.SearchField.getUIClassID",
	"Comment": "returns the name of the l&f class that renders this component.",
	"Method": "String getUIClassID(){\r\n    return uiClassID;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetServerStoredAccountInfoIcqImpl.removeDetail",
	"Comment": "removes the specified detail from the list of details stored onlinefor this account.",
	"Method": "boolean removeDetail(GenericDetail detail){\r\n    assertConnected();\r\n    boolean isFound = false;\r\n    List<GenericDetail> foundValues = new ArrayList<GenericDetail>();\r\n    Iterator<?> iter = infoRetreiver.getDetails(uin, detail.getClass());\r\n    while (iter.hasNext()) {\r\n        GenericDetail item = (GenericDetail) iter.next();\r\n        if (item.equals(detail)) {\r\n            isFound = true;\r\n            foundValues.add(detail);\r\n        } else\r\n            foundValues.add(item);\r\n    }\r\n    if (!isFound)\r\n        return false;\r\n    SuccessResponseListener responseListener = new SuccessResponseListener();\r\n    MetaFullInfoSetCmd cmd = new MetaFullInfoSetCmd(Integer.parseInt(uin), reqID++);\r\n    int typeOfDetail = supportedTypes.get(detail.getClass())[1];\r\n    try {\r\n        switch(typeOfDetail) {\r\n            case 0x01A4:\r\n                cmd.setCountry(-1);\r\n                break;\r\n            case 0x0154:\r\n                cmd.setNickName(null);\r\n                break;\r\n            case 0x0140:\r\n                cmd.setFirstName(null);\r\n                break;\r\n            case 0x014A:\r\n                cmd.setLastName(null);\r\n                break;\r\n            case 0x015E:\r\n                cmd.setEmail(null, false);\r\n                break;\r\n            case 0x0190:\r\n                cmd.setHomeCity(null);\r\n                break;\r\n            case 0x019A:\r\n                cmd.setHomeState(null);\r\n                break;\r\n            case 0x0276:\r\n                cmd.setHomePhone(null);\r\n                break;\r\n            case 0x0280:\r\n                cmd.setHomeFax(null);\r\n                break;\r\n            case 0x0262:\r\n                cmd.setAddress(null);\r\n                break;\r\n            case 0x028A:\r\n                cmd.setCellPhone(null);\r\n                break;\r\n            case 0x026C:\r\n                cmd.setHomeZip(null);\r\n                break;\r\n            case 0x017C:\r\n                cmd.setGender(0);\r\n                break;\r\n            case 0x0213:\r\n                cmd.setHomePage(null);\r\n                break;\r\n            case 0x023A:\r\n                cmd.setBirthDay(null);\r\n                break;\r\n            case 0x0186:\r\n                int[] langs = new int[3];\r\n                Arrays.fill(langs, -1);\r\n                cmd.setLanguages(langs[0], langs[1], langs[2]);\r\n                break;\r\n            case 0x0320:\r\n                cmd.setOriginCity(null);\r\n                break;\r\n            case 0x032A:\r\n                cmd.setOriginState(null);\r\n                break;\r\n            case 0x0334:\r\n                cmd.setOriginCountry(-1);\r\n                break;\r\n            case 0x029E:\r\n                cmd.setWorkCity(null);\r\n                break;\r\n            case 0x02A8:\r\n                cmd.setWorkState(null);\r\n                break;\r\n            case 0x02C6:\r\n                cmd.setWorkPhone(null);\r\n                break;\r\n            case 0x02D0:\r\n                cmd.setWorkFax(null);\r\n                break;\r\n            case 0x0294:\r\n                cmd.setWorkAddress(null);\r\n                break;\r\n            case 0x02BC:\r\n                cmd.setWorkZip(null);\r\n                break;\r\n            case 0x02B2:\r\n                cmd.setWorkCountry(-1);\r\n                break;\r\n            case 0x01AE:\r\n                cmd.setWorkCompany(null);\r\n                break;\r\n            case 0x01B8:\r\n                cmd.setWorkDepartment(null);\r\n                break;\r\n            case 0x01C2:\r\n                cmd.setWorkPosition(null);\r\n                break;\r\n            case 0x01CC:\r\n                cmd.setWorkOccupationCode(0);\r\n                break;\r\n            case 0x02DA:\r\n                cmd.setWorkWebPage(null);\r\n                break;\r\n            case 0x0258:\r\n                cmd.setNotes(null);\r\n                break;\r\n            case 0x01EA:\r\n                cmd.setInterests(new int[] { 0 }, new String[] { \"\" });\r\n                break;\r\n            case 0x0316:\r\n                cmd.setTimeZone(0);\r\n                break;\r\n        }\r\n    } catch (IOException ex) {\r\n        throw new OperationFailedException(\"Cannot add Detail!\", OperationFailedException.NETWORK_FAILURE);\r\n    }\r\n    icqProvider.getAimConnection().getInfoService().getOscarConnection().sendSnacRequest(cmd, responseListener);\r\n    responseListener.waitForEvent(5000);\r\n    if (!responseListener.success && responseListener.timeout)\r\n        throw new OperationFailedException(\"Replacing Detail Failed!\", OperationFailedException.NETWORK_FAILURE);\r\n    if (responseListener.success) {\r\n        infoRetreiver.detailsChanged(uin);\r\n        fireServerStoredDetailsChangeEvent(icqProvider, ServerStoredDetailsChangeEvent.DETAIL_REMOVED, detail, null);\r\n        return true;\r\n    } else\r\n        return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.gibberish.TestOperationSetPresence.getSampleStatus2",
	"Comment": "returns the online status with a lowest connectivity index.",
	"Method": "PresenceStatus getSampleStatus2(){\r\n    PresenceStatus leastConnectedPresenceStatus = null;\r\n    int leastConnectedPresenceStatusInt = Integer.MAX_VALUE;\r\n    Iterator<PresenceStatus> supportedStatusSetIter = operationSetPresence1.getSupportedStatusSet();\r\n    while (supportedStatusSetIter.hasNext()) {\r\n        PresenceStatus supportedStatus = supportedStatusSetIter.next();\r\n        if (supportedStatus.getStatus() < leastConnectedPresenceStatusInt && leastConnectedPresenceStatusInt >= PresenceStatus.ONLINE_THRESHOLD) {\r\n            leastConnectedPresenceStatus = supportedStatus;\r\n            leastConnectedPresenceStatusInt = supportedStatus.getStatus();\r\n        }\r\n    }\r\n    return leastConnectedPresenceStatus;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.DialPadFieldUI.getVisibleEditorRect",
	"Comment": "if we are in the case of disabled delete button, we simply call theparent implementation of this method, otherwise we recalculate the editorrectangle in order to leave place for the delete button.",
	"Method": "Rectangle getVisibleEditorRect(){\r\n    Rectangle rect = super.getVisibleEditorRect();\r\n    if ((rect.width > 0) && (rect.height > 0)) {\r\n        rect.x += 8;\r\n        rect.width -= 18;\r\n        return rect;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.gibberish.TestOperationSetPresence.getSampleStatus1",
	"Comment": "returns the online status with a highest connectivity index.",
	"Method": "PresenceStatus getSampleStatus1(){\r\n    PresenceStatus mostConnectedPresenceStatus = null;\r\n    int mostConnectedPresenceStatusInt = Integer.MIN_VALUE;\r\n    Iterator<PresenceStatus> supportedStatusSetIter = operationSetPresence1.getSupportedStatusSet();\r\n    while (supportedStatusSetIter.hasNext()) {\r\n        PresenceStatus supportedStatus = supportedStatusSetIter.next();\r\n        if (supportedStatus.getStatus() > mostConnectedPresenceStatusInt) {\r\n            mostConnectedPresenceStatusInt = supportedStatus.getStatus();\r\n            mostConnectedPresenceStatus = supportedStatus;\r\n        }\r\n    }\r\n    return mostConnectedPresenceStatus;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.AdHocChatRoomIcqImpl.findParticipantForNickName",
	"Comment": "finds the member of this chat room corresponding to the given nick name.",
	"Method": "Contact findParticipantForNickName(String nickName){\r\n    return participants.get(nickName);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.ConferenceDescriptionPacketExtension.toConferenceDescription",
	"Comment": "creates a conferencedescription corresponding to thisconferencedescriptionpacketextension",
	"Method": "ConferenceDescription toConferenceDescription(){\r\n    ConferenceDescription conferenceDescription = new ConferenceDescription(getUri(), getCallId(), getPassword());\r\n    conferenceDescription.setAvailable(isAvailable());\r\n    conferenceDescription.setDisplayName(getName());\r\n    for (TransportPacketExtension t : getChildExtensionsOfType(TransportPacketExtension.class)) {\r\n        conferenceDescription.addTransport(t.getNamespace());\r\n    }\r\n    return conferenceDescription;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.demuxcontactsource.DemuxContactSource.setPreferredProtocolProvider",
	"Comment": "sets the preferred protocol provider for this contact source.",
	"Method": "void setPreferredProtocolProvider(Class<? extends OperationSet> opSetClass,ProtocolProviderService protocolProvider){\r\n    if (preferredProtocolProviders == null)\r\n        preferredProtocolProviders = new HashMap<Class<? extends OperationSet>, ProtocolProviderService>();\r\n    preferredProtocolProviders.put(opSetClass, protocolProvider);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ServerStoredContactListJabberImpl.isPrivateMessagingContact",
	"Comment": "checks if the contact address is associated with private messagingcontact or not.",
	"Method": "boolean isPrivateMessagingContact(String contactAddress){\r\n    ContactGroupJabberImpl theVolatileGroup = getNonPersistentGroup();\r\n    if (theVolatileGroup == null)\r\n        return false;\r\n    ContactJabberImpl contact = theVolatileGroup.findContact(contactAddress);\r\n    if (contact == null || !(contact instanceof VolatileContactJabberImpl))\r\n        return false;\r\n    return ((VolatileContactJabberImpl) contact).isPrivateMessagingContact();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.whiteboard.gui.whiteboardshapes.WhiteboardShapeImage.recalculateSelectionPoints",
	"Comment": "recalculates the selection points coordinates and adds the new selectionpoints to the list of selection points.",
	"Method": "void recalculateSelectionPoints(){\r\n    selectionPoints.clear();\r\n    selectionPoints.add(new WhiteboardPoint(whiteboardPoint.getX(), whiteboardPoint.getY()));\r\n    selectionPoints.add(new WhiteboardPoint(whiteboardPoint.getX() + width, whiteboardPoint.getY()));\r\n    selectionPoints.add(new WhiteboardPoint(whiteboardPoint.getX(), whiteboardPoint.getY() + height));\r\n    selectionPoints.add(new WhiteboardPoint(whiteboardPoint.getX() + width, whiteboardPoint.getY() + height));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ServerStoredContactListSipImpl.createGroup",
	"Comment": "creates a group with the specified name and parent in the server storedcontact list.",
	"Method": "ContactGroupSipImpl createGroup(ContactGroupSipImpl parentGroup,String groupName,boolean persistent){\r\n    if (parentGroup == null) {\r\n        throw new IllegalArgumentException(\"Parent group cannot be null\");\r\n    }\r\n    if (groupName == null || groupName.length() == 0) {\r\n        throw new IllegalArgumentException(\"Creating group name cannot be null or empry\");\r\n    }\r\n    if (logger.isTraceEnabled()) {\r\n        logger.trace(\"createGroup \" + parentGroup.getGroupName() + \",\" + groupName + \",\" + persistent);\r\n    }\r\n    if (parentGroup.getGroup(groupName) != null) {\r\n        throw new OperationFailedException(String.format(\"Group %1s already exists.\", groupName), OperationFailedException.CONTACT_GROUP_ALREADY_EXISTS);\r\n    }\r\n    ContactGroupSipImpl subGroup = new ContactGroupSipImpl(groupName, sipProvider);\r\n    subGroup.setPersistent(persistent);\r\n    parentGroup.addSubgroup(subGroup);\r\n    if (subGroup.isPersistent()) {\r\n        try {\r\n            updateResourceLists();\r\n        } catch (XCapException e) {\r\n            parentGroup.removeSubGroup(subGroup);\r\n            throw new OperationFailedException(\"Error while creating XCAP group\", OperationFailedException.NETWORK_FAILURE, e);\r\n        }\r\n        subGroup.setResolved(true);\r\n    }\r\n    fireGroupEvent(subGroup, ServerStoredGroupEvent.GROUP_CREATED_EVENT);\r\n    return subGroup;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.aimaccregwizz.AimAccountRegistrationWizard.getProtocolName",
	"Comment": "returns the protocol name that will be shown in the list, where userwill choose the protocol to register to.",
	"Method": "String getProtocolName(){\r\n    return Resources.getString(\"plugin.aimaccregwizz.PROTOCOL_NAME\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.generic.TestOperationSetFileTransfer.testReceiverCancelsWhileTransfering",
	"Comment": "when the transfer starts waits for a while and the receivercancels the transfer while its in progress.",
	"Method": "void testReceiverCancelsWhileTransfering(){\r\n    if (!enableTestReceiverCancelsWhileTransfering())\r\n        return;\r\n    logger.trace(\"Start test : receiver will cancel \" + \"fileTransfer whil transfering.\");\r\n    File fileToTransfer = getTempFileToTransfer(12345678);\r\n    OperationSetFileTransfer ftOpSet1 = getOpSetFilTransfer1();\r\n    OperationSetFileTransfer ftOpSet2 = getOpSetFilTransfer2();\r\n    FileTransferStatusEventCollector senderStatusListener = new FileTransferStatusEventCollector(\"Sender\");\r\n    FileTransferEventCollector senderFTListerner = new FileTransferEventCollector(\"Sender\", senderStatusListener);\r\n    ftOpSet1.addFileTransferListener(senderFTListerner);\r\n    FileTransferStatusEventCollector receiverStatusListener = new FileTransferStatusEventCollector(\"Receiver\");\r\n    FileTransferEventCollector receiverFTListerner = new FileTransferEventCollector(\"Receiver\", receiverStatusListener);\r\n    ftOpSet2.addFileTransferListener(receiverFTListerner);\r\n    try {\r\n        ftOpSet1.sendFile(getContact1(), fileToTransfer);\r\n        senderFTListerner.waitForEvent(4000);\r\n        receiverFTListerner.waitForEvent(4000);\r\n        senderStatusListener.waitForEvent(4000);\r\n        assertEquals(\"A file transfer created must be received on send side\", 1, senderFTListerner.collectedEvents.size());\r\n        FileTransferCreatedEvent fileTransferCreatedEvent = (FileTransferCreatedEvent) senderFTListerner.collectedEvents.get(0);\r\n        assertEquals(\"FileTransfer file\", fileTransferCreatedEvent.getFileTransfer().getLocalFile(), fileToTransfer);\r\n        assertEquals(\"A file transfer status changed - \" + \"preparing received on send side\", 1, senderStatusListener.collectedEvents.size());\r\n        FileTransferStatusChangeEvent fileTransferStatusEvent = senderStatusListener.collectedEvents.get(0);\r\n        assertEquals(\"Event must be preparing\", FileTransferStatusChangeEvent.PREPARING, fileTransferStatusEvent.getNewStatus());\r\n        assertEquals(\"A file transfer request must be \" + \"received on the receiver side\", 1, receiverFTListerner.collectedEvents.size());\r\n        FileTransferRequestEvent fileTransferRequestEvent = (FileTransferRequestEvent) receiverFTListerner.collectedEvents.get(0);\r\n        IncomingFileTransferRequest req = fileTransferRequestEvent.getRequest();\r\n        assertEquals(\"FileTransfer file name must be the same\", req.getFileName(), fileToTransfer.getName());\r\n        assertEquals(\"FileTransfer file size must be the same\", req.getFileSize(), fileToTransfer.length());\r\n        senderFTListerner.clear();\r\n        receiverFTListerner.clear();\r\n        senderStatusListener.clear();\r\n        File receiveFile = getFileService().getTemporaryFile();\r\n        final FileTransfer ft2 = req.acceptFile(receiveFile);\r\n        receiverStatusListener.waitForEvent(16000, 1);\r\n        assertTrue(\"A file transfer status changed - \" + \"preparing or and inProgress received on receiver side\", receiverStatusListener.collectedEvents.size() >= 1);\r\n        FileTransferStatusChangeEvent stat1 = receiverStatusListener.collectedEvents.get(0);\r\n        assertEquals(\"Event must be preparing\", FileTransferStatusChangeEvent.PREPARING, stat1.getNewStatus());\r\n        receiverStatusListener.waitForEvent(14000);\r\n        senderStatusListener.waitForEvent(14000);\r\n        receiverStatusListener.collectedEvents.clear();\r\n        senderStatusListener.clear();\r\n        ft2.cancel();\r\n        receiverStatusListener.waitForEvent(14000);\r\n        FileTransferStatusChangeEvent stat3 = receiverStatusListener.collectedEvents.get(0);\r\n        assertEquals(\"Event must be canceled\", FileTransferStatusChangeEvent.CANCELED, stat3.getNewStatus());\r\n        receiverFTListerner.waitForEvent(14000);\r\n        assertEquals(\"A file transfer created must be \" + \"received on receiver side\", 1, receiverFTListerner.collectedEvents.size());\r\n        fileTransferCreatedEvent = (FileTransferCreatedEvent) receiverFTListerner.collectedEvents.get(0);\r\n        assertEquals(\"FileTransfer file\", fileTransferCreatedEvent.getFileTransfer().getLocalFile(), receiveFile);\r\n        senderStatusListener.waitForEvent(14000, 2);\r\n        assertTrue(\"Must contain canceled event\", senderStatusListener.contains(FileTransferStatusChangeEvent.CANCELED));\r\n    } finally {\r\n        ftOpSet1.removeFileTransferListener(senderFTListerner);\r\n        ftOpSet2.addFileTransferListener(receiverFTListerner);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.SourceUIContact.getDefaultContactDetail",
	"Comment": "returns the default contactdetail to use for any operationsdepending to the given operationset class.",
	"Method": "UIContactDetail getDefaultContactDetail(Class<? extends OperationSet> opSetClass){\r\n    List<UIContactDetail> details = getContactDetailsForOperationSet(opSetClass);\r\n    if (details != null && !details.isEmpty())\r\n        return details.get(0);\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.googlecontacts.GoogleContactsActivator.handleProviderRemoved",
	"Comment": "notifies this manager that a specificprotocolproviderservice has been unregistered as a service.",
	"Method": "void handleProviderRemoved(ProtocolProviderService provider){\r\n    disableContactSource(provider.getAccountID().getAccountAddress());\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.JabberAccRegWizzActivator.isAdvancedAccountConfigDisabled",
	"Comment": "indicates if the advanced account configuration is currently disabled.",
	"Method": "boolean isAdvancedAccountConfigDisabled(){\r\n    String advancedConfigDisabledDefaultProp = Resources.getSettingsString(\"impl.gui.main.account.ADVANCED_CONFIG_DISABLED\");\r\n    boolean isAdvancedConfigDisabled = false;\r\n    if (advancedConfigDisabledDefaultProp != null)\r\n        isAdvancedConfigDisabled = Boolean.parseBoolean(advancedConfigDisabledDefaultProp);\r\n    return getConfigurationService().getBoolean(\"net.java.sip.communicator.impl.gui.main.account.\" + \"ADVANCED_CONFIG_DISABLED\", isAdvancedConfigDisabled);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.whiteboard.WhiteboardSessionPacketExtension.getAction",
	"Comment": "returns the action associated with this session packet extension.",
	"Method": "String getAction(){\r\n    return action;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.colibri.ColibriConferenceIQ.getContents",
	"Comment": "returns a list of the contents included into thisconference iq.",
	"Method": "List<Content> getContents(){\r\n    return Collections.unmodifiableList(contents);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractConferenceMember.setAudioStatus",
	"Comment": "sets the status in both directions of the audio rtp stream from the pointof view of this conferencemember.",
	"Method": "void setAudioStatus(MediaDirection status){\r\n    if (status == null)\r\n        status = MediaDirection.INACTIVE;\r\n    if (this.audioStatus != status) {\r\n        MediaDirection oldValue = this.audioStatus;\r\n        this.audioStatus = status;\r\n        firePropertyChange(AUDIO_STATUS_PROPERTY_NAME, oldValue, this.audioStatus);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.IceConfigPanel.isAutoDiscoverStun",
	"Comment": "indicates if the stun server should be automatically discovered.",
	"Method": "boolean isAutoDiscoverStun(){\r\n    return autoDiscoverBox.isSelected();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.configforms.ConfigurationFrame.createTopComponent",
	"Comment": "creates the toolbar panel for this chat window, depending on the currentoperating system.",
	"Method": "JComponent createTopComponent(){\r\n    JComponent topComponent = null;\r\n    if (OSUtils.IS_MAC) {\r\n        UnifiedToolBar macToolbarPanel = new UnifiedToolBar();\r\n        MacUtils.makeWindowLeopardStyle(getRootPane());\r\n        macToolbarPanel.getComponent().setLayout(new BorderLayout());\r\n        macToolbarPanel.disableBackgroundPainter();\r\n        macToolbarPanel.installWindowDraggerOnWindow(this);\r\n        centerPanel.setOpaque(true);\r\n        centerPanel.setBackground(new Color(GuiActivator.getResources().getColor(\"service.gui.MAC_PANEL_BACKGROUND\")));\r\n        topComponent = macToolbarPanel.getComponent();\r\n    } else {\r\n        topComponent = new TransparentPanel(new BorderLayout());\r\n        topComponent.setBorder(new EmptyBorder(BORDER_SIZE / 2, BORDER_SIZE, 0, 0));\r\n    }\r\n    return topComponent;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.UserCredentials.getPassword",
	"Comment": "returns a password associated with this set of credentials.",
	"Method": "char[] getPassword(){\r\n    return password;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.netaddr.NetworkConfigurationWatcher.checkNetworkInterfaces",
	"Comment": "checks current interfaces configuration against the last savedactive interfaces.",
	"Method": "void checkNetworkInterfaces(boolean fireEvents,int waitBeforeFiringUpEvents,boolean printDebugInfo){\r\n    Enumeration<NetworkInterface> e = NetworkInterface.getNetworkInterfaces();\r\n    Map<String, List<InetAddress>> currentActiveInterfaces = new HashMap<String, List<InetAddress>>();\r\n    while (e.hasMoreElements()) {\r\n        NetworkInterface networkInterface = e.nextElement();\r\n        if (networkInterface.isLoopback())\r\n            continue;\r\n        if (networkInterface.isUp()) {\r\n            List<InetAddress> addresses = new ArrayList<InetAddress>();\r\n            Enumeration<InetAddress> as = networkInterface.getInetAddresses();\r\n            while (as.hasMoreElements()) {\r\n                InetAddress inetAddress = as.nextElement();\r\n                if (inetAddress.isLinkLocalAddress())\r\n                    continue;\r\n                addresses.add(inetAddress);\r\n            }\r\n            if (addresses.size() > 0)\r\n                currentActiveInterfaces.put(networkInterface.getName(), addresses);\r\n        }\r\n    }\r\n    if (logger.isInfoEnabled() && printDebugInfo) {\r\n        for (Map.Entry<String, List<InetAddress>> en : activeInterfaces.entrySet()) {\r\n            logger.info(\"Previously Active \" + en.getKey() + \":\" + en.getValue());\r\n        }\r\n        for (Map.Entry<String, List<InetAddress>> en : currentActiveInterfaces.entrySet()) {\r\n            logger.info(\"Currently Active \" + en.getKey() + \":\" + en.getValue());\r\n        }\r\n    }\r\n    List<String> inactiveActiveInterfaces = new ArrayList<String>(activeInterfaces.keySet());\r\n    List<String> currentActiveInterfacesSet = new ArrayList<String>(currentActiveInterfaces.keySet());\r\n    inactiveActiveInterfaces.removeAll(currentActiveInterfacesSet);\r\n    for (int i = 0; i < inactiveActiveInterfaces.size(); i++) {\r\n        String iface = inactiveActiveInterfaces.get(i);\r\n        if (!currentActiveInterfacesSet.contains(iface)) {\r\n            if (fireEvents)\r\n                eventDispatcher.fireChangeEvent(new ChangeEvent(iface, ChangeEvent.IFACE_DOWN));\r\n            activeInterfaces.remove(iface);\r\n        }\r\n    }\r\n    Iterator<Map.Entry<String, List<InetAddress>>> activeEntriesIter = activeInterfaces.entrySet().iterator();\r\n    while (activeEntriesIter.hasNext()) {\r\n        Map.Entry<String, List<InetAddress>> entry = activeEntriesIter.next();\r\n        Iterator<InetAddress> addrIter = entry.getValue().iterator();\r\n        while (addrIter.hasNext()) {\r\n            InetAddress addr = addrIter.next();\r\n            List<InetAddress> addresses = currentActiveInterfaces.get(entry.getKey());\r\n            if (addresses != null && !addresses.contains(addr)) {\r\n                if (fireEvents)\r\n                    eventDispatcher.fireChangeEvent(new ChangeEvent(entry.getKey(), ChangeEvent.ADDRESS_DOWN, addr));\r\n                addrIter.remove();\r\n            }\r\n        }\r\n    }\r\n    if (waitBeforeFiringUpEvents > 0 && currentActiveInterfaces.size() != 0) {\r\n        synchronized (this) {\r\n            try {\r\n                wait(waitBeforeFiringUpEvents);\r\n            } catch (InterruptedException ex) {\r\n            }\r\n        }\r\n    }\r\n    activeEntriesIter = currentActiveInterfaces.entrySet().iterator();\r\n    while (activeEntriesIter.hasNext()) {\r\n        Map.Entry<String, List<InetAddress>> entry = activeEntriesIter.next();\r\n        for (InetAddress addr : entry.getValue()) {\r\n            List<InetAddress> addresses = activeInterfaces.get(entry.getKey());\r\n            if (addresses != null && !addresses.contains(addr)) {\r\n                if (fireEvents)\r\n                    eventDispatcher.fireChangeEvent(new ChangeEvent(entry.getKey(), ChangeEvent.ADDRESS_UP, addr));\r\n                addresses.add(addr);\r\n            }\r\n        }\r\n    }\r\n    Iterator<String> ifaceIter = activeInterfaces.keySet().iterator();\r\n    while (ifaceIter.hasNext()) {\r\n        currentActiveInterfaces.remove(ifaceIter.next());\r\n    }\r\n    activeEntriesIter = currentActiveInterfaces.entrySet().iterator();\r\n    while (activeEntriesIter.hasNext()) {\r\n        final Map.Entry<String, List<InetAddress>> entry = activeEntriesIter.next();\r\n        for (InetAddress addr : entry.getValue()) {\r\n            if (fireEvents)\r\n                eventDispatcher.fireChangeEvent(new ChangeEvent(entry.getKey(), ChangeEvent.ADDRESS_UP, addr));\r\n        }\r\n        if (fireEvents) {\r\n            int wait = waitBeforeFiringUpEvents;\r\n            if (wait == 0) {\r\n                wait = 500;\r\n            }\r\n            eventDispatcher.fireChangeEvent(new ChangeEvent(entry.getKey(), ChangeEvent.IFACE_UP), wait);\r\n        }\r\n        activeInterfaces.put(entry.getKey(), entry.getValue());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.globalshortcut.CallShortcut.outgoingCallCreated",
	"Comment": "this method is called by a protocol provider upon initiation of anoutgoing call.",
	"Method": "void outgoingCallCreated(CallEvent event){\r\n    addCall(event.getSourceCall(), this.answeredCalls);\r\n}"
}, {
	"Path": "net.librec.recommender.ext.ExternalTestCase.testAssociationRuleRecommender",
	"Comment": "test the whole rating process of externalrecommender recommendation",
	"Method": "void testAssociationRuleRecommender(){\r\n    Resource resource = new Resource(\"rec/ext/external-test.properties\");\r\n    conf.addResource(resource);\r\n    RecommenderJob job = new RecommenderJob(conf);\r\n    job.runJob();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.ChatRoomInvitationReceivedEvent.getSourceOperationSet",
	"Comment": "returns the multi user chat operation set that dispatches this event.",
	"Method": "OperationSetMultiUserChat getSourceOperationSet(){\r\n    return (OperationSetMultiUserChat) getSource();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.MetaContactChatSession.isDescriptorPersistent",
	"Comment": "returns true if this contact is persistent, otherwisereturns false.",
	"Method": "boolean isDescriptorPersistent(){\r\n    if (metaContact == null)\r\n        return false;\r\n    Contact defaultContact = metaContact.getDefaultContact(OperationSetBasicInstantMessaging.class);\r\n    if (defaultContact == null)\r\n        return false;\r\n    ContactGroup parent = defaultContact.getParentContactGroup();\r\n    boolean isParentPersist = true;\r\n    boolean isParentResolved = true;\r\n    if (parent != null) {\r\n        isParentPersist = parent.isPersistent();\r\n        isParentResolved = parent.isResolved();\r\n    }\r\n    if (!defaultContact.isPersistent() && !defaultContact.isResolved() && !isParentPersist && !isParentResolved) {\r\n        return false;\r\n    } else {\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ContactJabberImpl.isLocal",
	"Comment": "determines whether or not this contact instance represents the user usedby this protocol provider to connect to the service.",
	"Method": "boolean isLocal(){\r\n    return isLocal;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.GuiActivator.getFileAccessService",
	"Comment": "returns the fileaccessservice obtained from the bundle context.",
	"Method": "FileAccessService getFileAccessService(){\r\n    if (fileAccessService == null) {\r\n        fileAccessService = ServiceUtils.getService(bundleContext, FileAccessService.class);\r\n    }\r\n    return fileAccessService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetFileTransferIcqImpl.fireFileTransferRequestRejected",
	"Comment": "delivers the specified event to all registered file transfer listeners.",
	"Method": "void fireFileTransferRequestRejected(FileTransferRequestEvent event){\r\n    Iterator<FileTransferListener> listeners = null;\r\n    synchronized (fileTransferListeners) {\r\n        listeners = new ArrayList<FileTransferListener>(fileTransferListeners).iterator();\r\n    }\r\n    while (listeners.hasNext()) {\r\n        FileTransferListener listener = listeners.next();\r\n        listener.fileTransferRequestRejected(event);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.VolatileContactGroupJabberImpl.isPersistent",
	"Comment": "determines whether or not this contact group is being stored by theserver. non persistent contact groups exist for the sole purpose ofcontaining non persistent contacts.",
	"Method": "boolean isPersistent(){\r\n    return false;\r\n}"
}, {
	"Path": "net.librec.recommender.ext.PRankDTestCase.testRecommender",
	"Comment": "test the whole process of prankdrecommender recommendation",
	"Method": "void testRecommender(){\r\n    Configuration.Resource resource = new Configuration.Resource(\"rec/ext/prankd-test.properties\");\r\n    conf.addResource(resource);\r\n    RecommenderJob job = new RecommenderJob(conf);\r\n    job.runJob();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.AdHocConferenceChatTransport.allowsTypingNotifications",
	"Comment": "returns true if this chat transport supports typingnotifications, otherwise returns false.",
	"Method": "boolean allowsTypingNotifications(){\r\n    Object tnOpSet = adHocChatRoom.getParentProvider().getOperationSet(OperationSetTypingNotifications.class);\r\n    if (tnOpSet != null)\r\n        return true;\r\n    else\r\n        return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.AntialiasingManager.activateAntialiasing",
	"Comment": "activates the antialiasing mechanism for the given graphicsobject.",
	"Method": "void activateAntialiasing(Graphics g){\r\n    ((Graphics2D) g).setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ServerStoredContactListJabberImpl.createGroup",
	"Comment": "creates the specified group on the server stored contact list.",
	"Method": "void createGroup(String groupName){\r\n    if (logger.isTraceEnabled())\r\n        logger.trace(\"Creating group: \" + groupName);\r\n    ContactGroupJabberImpl existingGroup = findContactGroup(groupName);\r\n    if (existingGroup != null && existingGroup.isPersistent()) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"ContactGroup \" + groupName + \" already exists.\");\r\n        throw new OperationFailedException(\"ContactGroup \" + groupName + \" already exists.\", OperationFailedException.CONTACT_GROUP_ALREADY_EXISTS);\r\n    }\r\n    RosterGroup newRosterGroup = roster.createGroup(groupName);\r\n    ContactGroupJabberImpl newGroup = new ContactGroupJabberImpl(newRosterGroup, new ArrayList<RosterEntry>().iterator(), this, true);\r\n    rootGroup.addSubGroup(newGroup);\r\n    fireGroupEvent(newGroup, ServerStoredGroupEvent.GROUP_CREATED_EVENT);\r\n    if (logger.isTraceEnabled())\r\n        logger.trace(\"Group \" + groupName + \" created.\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipStackSharing.getOrCreateServerTransaction",
	"Comment": "safely returns the transaction from the event if already exists.if not a new transaction is created.",
	"Method": "ServerTransaction getOrCreateServerTransaction(RequestEvent event){\r\n    ServerTransaction serverTransaction = event.getServerTransaction();\r\n    if (serverTransaction == null) {\r\n        SipProvider jainSipProvider = (SipProvider) event.getSource();\r\n        serverTransaction = jainSipProvider.getNewServerTransaction(event.getRequest());\r\n    }\r\n    return serverTransaction;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetFileTransferJabberImpl.fireFileTransferRequest",
	"Comment": "delivers the specified event to all registered file transfer listeners.",
	"Method": "void fireFileTransferRequest(FileTransferRequestEvent event){\r\n    Iterator<FileTransferListener> listeners = null;\r\n    synchronized (fileTransferListeners) {\r\n        listeners = new ArrayList<FileTransferListener>(fileTransferListeners).iterator();\r\n    }\r\n    while (listeners.hasNext()) {\r\n        FileTransferListener listener = listeners.next();\r\n        listener.fileTransferRequestReceived(event);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.spellcheck.SpellChecker.isDictionaryValid",
	"Comment": "determines if spell checker dictionary works. backend api often failswhen used so this tests that the current dictionary is able to processwords.",
	"Method": "boolean isDictionaryValid(SpellDictionary dict){\r\n    try {\r\n        dict.isCorrect(\"foo\");\r\n        return true;\r\n    } catch (Exception exc) {\r\n        logger.error(\"Dictionary validation failed\", exc);\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.netaddr.NetaddrActivator.getBundleContext",
	"Comment": "returns a reference to the bundle context that we were started with.",
	"Method": "BundleContext getBundleContext(){\r\n    return bundleContext;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockChatRoom.getBanList",
	"Comment": "returns an iterator over a set of ban masks for this chat room. the banmask defines a group of users that will be banned. the ban list is a listof all such ban masks defined for this chat room.",
	"Method": "Iterator<ChatRoomMember> getBanList(){\r\n    return new Vector<ChatRoomMember>().iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.accountinfo.AccountInfoMenuItemComponent.getPositionIndex",
	"Comment": "returns the position of this plugincomponent within itscontainer",
	"Method": "int getPositionIndex(){\r\n    return 0;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetFileTransferJabberImpl.fireFileTransferRequestRejected",
	"Comment": "delivers the specified event to all registered file transfer listeners.",
	"Method": "void fireFileTransferRequestRejected(FileTransferRequestEvent event){\r\n    Iterator<FileTransferListener> listeners = null;\r\n    synchronized (fileTransferListeners) {\r\n        listeners = new ArrayList<FileTransferListener>(fileTransferListeners).iterator();\r\n    }\r\n    while (listeners.hasNext()) {\r\n        FileTransferListener listener = listeners.next();\r\n        listener.fileTransferRequestRejected(event);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.keepalive.KeepAliveManager.registrationStateChanged",
	"Comment": "the method is called by a protocolprovider implementation whenevera change in the registration state of the corresponding provider hadoccurred.",
	"Method": "void registrationStateChanged(RegistrationStateChangeEvent evt){\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"The provider changed state from: \" + evt.getOldState() + \" to: \" + evt.getNewState());\r\n    if (evt.getNewState() == RegistrationState.REGISTERED) {\r\n        parentProvider.getConnection().removePacketListener(this);\r\n        parentProvider.getConnection().addPacketListener(this, null);\r\n        if (keepAliveSendTask != null) {\r\n            logger.error(\"Those task is not supposed to be available for \" + parentProvider.getAccountID().getDisplayName());\r\n            keepAliveSendTask.cancel();\r\n            keepAliveSendTask = null;\r\n        }\r\n        if (keepAliveTimer != null) {\r\n            logger.error(\"Those timer is not supposed to be available for \" + parentProvider.getAccountID().getDisplayName());\r\n            keepAliveTimer.cancel();\r\n            keepAliveTimer = null;\r\n        }\r\n        keepAliveSendTask = new KeepAliveSendTask();\r\n        waitingForPacketWithID = null;\r\n        keepAliveCheckInterval = SmackConfiguration.getKeepAliveInterval();\r\n        if (keepAliveCheckInterval == 0)\r\n            keepAliveCheckInterval = 30000;\r\n        keepAliveTimer = new Timer(\"Jabber keepalive timer for <\" + parentProvider.getAccountID() + \">\", true);\r\n        keepAliveTimer.scheduleAtFixedRate(keepAliveSendTask, keepAliveCheckInterval, keepAliveCheckInterval);\r\n    } else if (evt.getNewState() == RegistrationState.UNREGISTERED || evt.getNewState() == RegistrationState.CONNECTION_FAILED || evt.getNewState() == RegistrationState.AUTHENTICATION_FAILED) {\r\n        waitingForPacketWithID = null;\r\n        if (parentProvider.getConnection() != null)\r\n            parentProvider.getConnection().removePacketListener(this);\r\n        if (keepAliveSendTask != null) {\r\n            keepAliveSendTask.cancel();\r\n            keepAliveSendTask = null;\r\n        }\r\n        if (keepAliveTimer != null) {\r\n            keepAliveTimer.cancel();\r\n            keepAliveTimer = null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.SecurityAccountRegistration.getEncryptionProtocolStatus",
	"Comment": "returns the map between the encryption protocols and their status.",
	"Method": "Map<String, Boolean> getEncryptionProtocolStatus(){\r\n    return encryptionProtocolStatus;\r\n}"
}, {
	"Path": "com.keybox.manage.db.SystemStatusDB.insertSystemStatus",
	"Comment": "inserts into the status table to keep track of key placement status",
	"Method": "void insertSystemStatus(Connection con,HostSystem hostSystem,Long userId){\r\n    try {\r\n        PreparedStatement stmt = con.prepareStatement(\"insert into status (id, status_cd, user_id) values (?,?,?)\");\r\n        stmt.setLong(1, hostSystem.getId());\r\n        stmt.setString(2, hostSystem.getStatusCd());\r\n        stmt.setLong(3, userId);\r\n        stmt.execute();\r\n        DBUtils.closeStmt(stmt);\r\n    } catch (Exception e) {\r\n        log.error(e.toString(), e);\r\n    }\r\n}"
}, {
	"Path": "net.librec.similarity.CPCSimilarity.buildSimilarityMatrix",
	"Comment": "build social similarity matrix with trainmatrix in datamodel.",
	"Method": "void buildSimilarityMatrix(DataModel dataModel){\r\n    SequentialAccessSparseMatrix trainMatrix = dataModel.getDataSplitter().getTrainData();\r\n    double maximum = 0.0;\r\n    double minimum = 100.0;\r\n    for (MatrixEntry me : trainMatrix) {\r\n        if (me.get() > maximum) {\r\n            maximum = me.get();\r\n        }\r\n        if (me.get() < minimum) {\r\n            minimum = me.get();\r\n        }\r\n    }\r\n    median = (maximum + minimum) / 2;\r\n    super.buildSimilarityMatrix(dataModel);\r\n}"
}, {
	"Path": "net.librec.recommender.cf.UserKNNTestCase.test07SplitterRatioValid",
	"Comment": "test ratiodatasplitter with valid ratio, evaluating enabled.",
	"Method": "void test07SplitterRatioValid(){\r\n    Resource resource = new Resource(\"rec/cf/userknn-test.properties\");\r\n    conf.addResource(resource);\r\n    conf.set(\"rec.eval.enable\", \"true\");\r\n    conf.set(\"data.model.splitter\", \"ratio\");\r\n    conf.set(\"data.splitter.ratio\", \"valid\");\r\n    conf.set(\"data.splitter.trainset.ratio\", \"0.5\");\r\n    conf.set(\"data.splitter.validset.ratio\", \"0.2\");\r\n    RecommenderJob job = new RecommenderJob(conf);\r\n    job.runJob();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.OperationSetPersistentPresenceGibberishImpl.createServerStoredContactGroup",
	"Comment": "creates a group with the specified name and parent in the serverstored contact list.",
	"Method": "void createServerStoredContactGroup(ContactGroup parent,String groupName){\r\n    ContactGroupGibberishImpl newGroup = new ContactGroupGibberishImpl(groupName, parentProvider);\r\n    ((ContactGroupGibberishImpl) parent).addSubgroup(newGroup);\r\n    this.fireServerStoredGroupEvent(newGroup, ServerStoredGroupEvent.GROUP_CREATED_EVENT);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl.initRegistrarlessConnection",
	"Comment": "initializes the sipregistrarconnection that this class will be using.",
	"Method": "void initRegistrarlessConnection(){\r\n    String registrarTransport = getRegistrarTransport();\r\n    this.sipRegistrarConnection = new SipRegistrarlessConnection(this, registrarTransport);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler.addAdvertisedEncryptionMethod",
	"Comment": "adds encryption method to the list of advertised secure methods.",
	"Method": "void addAdvertisedEncryptionMethod(SrtpControlType encryptionMethod){\r\n    if (!advertisedEncryptionMethods.contains(encryptionMethod))\r\n        advertisedEncryptionMethods.add(encryptionMethod);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockProvider.getAccountID",
	"Comment": "returns the accountid that uniquely identifies the account represented bythis instance of the protocolproviderservice.",
	"Method": "AccountID getAccountID(){\r\n    return accountID;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.contactlist.MclSlickFixture.setUp",
	"Comment": "find a reference of the meta contact list service and set thecorresponding field.",
	"Method": "void setUp(){\r\n    ServiceReference ref = bundleContext.getServiceReference(MetaContactListService.class.getName());\r\n    metaClService = (MetaContactListService) bundleContext.getService(ref);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetTypingNotificationsJabberImpl.sendTypingNotification",
	"Comment": "sends a notification to notifiedcontatct that we have enteredtypingstate.",
	"Method": "void sendTypingNotification(Contact notifiedContact,int typingState){\r\n    assertConnected();\r\n    if (!(notifiedContact instanceof ContactJabberImpl))\r\n        throw new IllegalArgumentException(\"The specified contact is not a Jabber contact.\" + notifiedContact);\r\n    sendXep85ChatState(notifiedContact, typingState);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipActivator.getResources",
	"Comment": "returns a reference to the resourcemanagementservice implementationcurrently registered in the bundle context or null if no suchimplementation was found.",
	"Method": "ResourceManagementService getResources(){\r\n    if (resources == null) {\r\n        resources = ServiceUtils.getService(bundleContext, ResourceManagementService.class);\r\n    }\r\n    return resources;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.FTPUtils.checkConnectionGreetings",
	"Comment": "reads the connection greetings messages from the ftp serverchecks the response code.",
	"Method": "void checkConnectionGreetings(){\r\n    String code = getResponseCode();\r\n    if (!code.equals(\"220\")) {\r\n        throw new Exception(\"Connection Error.\");\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.metahistory.MetaHistoryServiceImpl.findFirstMessagesAfter",
	"Comment": "returns the supplied number of recent records after the given date",
	"Method": "Collection<Object> findFirstMessagesAfter(String[] services,Object descriptor,Date date,int count){\r\n    MessageProgressWrapper listenWrapper = new MessageProgressWrapper(services.length);\r\n    TreeSet<Object> result = new TreeSet<Object>(new RecordsComparator());\r\n    for (int i = 0; i < services.length; i++) {\r\n        String name = services[i];\r\n        Object serv = getService(name);\r\n        if (serv instanceof MessageHistoryService) {\r\n            MessageHistoryService mhs = (MessageHistoryService) serv;\r\n            listenWrapper.setIx(i);\r\n            mhs.addSearchProgressListener(listenWrapper);\r\n            if (descriptor instanceof MetaContact) {\r\n                result.addAll(mhs.findFirstMessagesAfter((MetaContact) descriptor, date, count));\r\n            } else if (descriptor instanceof ChatRoom) {\r\n                result.addAll(mhs.findFirstMessagesAfter((ChatRoom) descriptor, date, count));\r\n            }\r\n            mhs.removeSearchProgressListener(listenWrapper);\r\n        } else if (serv instanceof FileHistoryService && descriptor instanceof MetaContact) {\r\n            result.addAll(((FileHistoryService) serv).findFirstRecordsAfter((MetaContact) descriptor, date, count));\r\n        } else if (serv instanceof CallHistoryService) {\r\n            CallHistoryService chs = (CallHistoryService) serv;\r\n            listenWrapper.setIx(i);\r\n            chs.addSearchProgressListener(listenWrapper);\r\n            Collection<CallRecord> col = chs.findByStartDate(date);\r\n            if (col.size() > count) {\r\n                List<CallRecord> l = new LinkedList<CallRecord>(col);\r\n                Collections.sort(l, new RecordsComparator());\r\n                result.addAll(l.subList(0, count));\r\n            } else\r\n                result.addAll(col);\r\n            chs.removeSearchProgressListener(listenWrapper);\r\n        }\r\n    }\r\n    listenWrapper.fireLastProgress(date, null, null);\r\n    LinkedList<Object> resultAsList = new LinkedList<Object>(result);\r\n    int toIndex = count;\r\n    if (toIndex > resultAsList.size())\r\n        toIndex = resultAsList.size();\r\n    return resultAsList.subList(0, toIndex);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.GlobalStatusSelectorBox.fitSizeToText",
	"Comment": "computes the width of the text in pixels in order to position the arrowduring its painting.",
	"Method": "void fitSizeToText(){\r\n    String text = getText();\r\n    textWidth = (text == null) ? 0 : ComponentUtils.getStringWidth(this, text);\r\n    this.setPreferredSize(new Dimension(textWidth + 2 * IMAGE_INDENT + arrowImage.getWidth(null) + 5, 20));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.GuiActivator.getCredentialsStorageService",
	"Comment": "returns a reference to a credentialsstorageservice implementationcurrently registered in the bundle context or null if no suchimplementation was found.",
	"Method": "CredentialsStorageService getCredentialsStorageService(){\r\n    if (credentialsService == null) {\r\n        credentialsService = ServiceUtils.getService(bundleContext, CredentialsStorageService.class);\r\n    }\r\n    return credentialsService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.MessageReceivedEvent.getCorrectedMessageUID",
	"Comment": "returns the correctedmessageuid the id of the message being corrected,or null if this is a new message and not a correction.",
	"Method": "String getCorrectedMessageUID(){\r\n    return correctedMessageUID;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWindow.setToolbarVisible",
	"Comment": "shows or hides the toolbar depending on the value of parameter b.",
	"Method": "void setToolbarVisible(boolean b){\r\n    toolbarPanel.setVisible(b);\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.ConfigurationUtils.isHideAccountSelectionWhenPossibleEnabled",
	"Comment": "whether allow user to select account when only a singleaccount is available.",
	"Method": "boolean isHideAccountSelectionWhenPossibleEnabled(){\r\n    return hideAccountSelectionWhenPossible;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.ldap.configform.LdapTableModel.getColumnClass",
	"Comment": "overrides a method that always returned object.classnow it will return boolean.class for the first method,letting the defaulttablecellrenderer create checkboxes.",
	"Method": "Class<?> getColumnClass(int columnIndex){\r\n    Object o = getValueAt(0, columnIndex);\r\n    if (o == null)\r\n        return String.class;\r\n    return o.getClass();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.GeneralDialPanel.mouseReleased",
	"Comment": "handles the mouseevent triggered when user releases one of thedial buttons.",
	"Method": "void mouseReleased(MouseEvent e){\r\n    dtmfHandler.stopSendingDtmfTone();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.AnimatedImage.getRemainingCycles",
	"Comment": "get the remaining cycles to complete before the animation stops.",
	"Method": "int getRemainingCycles(){\r\n    return cycles;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.ComponentUtils.getStringSize",
	"Comment": "returns the size of the given text computed towards to the givencomponent.",
	"Method": "Dimension getStringSize(Component c,String text){\r\n    FontMetrics metrics = c.getFontMetrics(c.getFont());\r\n    int hgt = metrics.getHeight();\r\n    int adv = metrics.stringWidth(text);\r\n    return new Dimension(adv + 2, hgt + 2);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ContactSipImpl.getProtocolProvider",
	"Comment": "returns a reference to the protocol provider that created the contact.",
	"Method": "ProtocolProviderService getProtocolProvider(){\r\n    return parentProvider;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.ChatRoomProviderWrapperImpl.findChatRoomWrapperForChatRoomID",
	"Comment": "returns the chat room wrapper contained in this provider that correspondsto the chat room with the given id.",
	"Method": "ChatRoomWrapper findChatRoomWrapperForChatRoomID(String chatRoomID){\r\n    for (ChatRoomWrapper chatRoomWrapper : chatRoomsOrderedCopy) {\r\n        if (chatRoomWrapper.getChatRoomID().equals(chatRoomID)) {\r\n            return chatRoomWrapper;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.UINotificationManager.fireClearedEvent",
	"Comment": "notifies interested uinotificationlistener that anotification has been cleared.",
	"Method": "void fireClearedEvent(UINotification notification){\r\n    synchronized (notificationListeners) {\r\n        Iterator<UINotificationListener> listeners = notificationListeners.iterator();\r\n        while (listeners.hasNext()) listeners.next().notificationCleared(notification);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetDesktopSharingServerJabberImpl.enableRemoteControl",
	"Comment": "enable desktop remote control. local desktop can now regenerates keyboardand mouse events received from peer.",
	"Method": "void enableRemoteControl(CallPeer callPeer){\r\n    callPeer.addCallPeerListener(callPeerListener);\r\n    size = (((VideoMediaFormat) ((CallJabberImpl) callPeer.getCall()).getDefaultDevice(MediaType.VIDEO).getFormat()).getSize());\r\n    this.modifyRemoteControl(callPeer, true);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ActiveCallsRepositorySipImpl.fireCallEvent",
	"Comment": "creates and dispatches a callevent notifying registeredlisteners that an event with id eventid has occurred onsourcecall.",
	"Method": "void fireCallEvent(int eventID,Call sourceCall,CallChangeEvent cause){\r\n    parentOperationSet.fireCallEvent(eventID, sourceCall);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomJabberImpl.firePropertyChangeEvent",
	"Comment": "delivers the specified event to all registered property change listeners.",
	"Method": "void firePropertyChangeEvent(PropertyChangeEvent evt){\r\n    Iterable<ChatRoomPropertyChangeListener> listeners;\r\n    synchronized (propertyChangeListeners) {\r\n        listeners = new ArrayList<ChatRoomPropertyChangeListener>(propertyChangeListeners);\r\n    }\r\n    for (ChatRoomPropertyChangeListener listener : listeners) {\r\n        if (evt instanceof ChatRoomPropertyChangeEvent) {\r\n            listener.chatRoomPropertyChanged((ChatRoomPropertyChangeEvent) evt);\r\n        } else if (evt instanceof ChatRoomPropertyChangeFailedEvent) {\r\n            listener.chatRoomPropertyChangeFailed((ChatRoomPropertyChangeFailedEvent) evt);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.ParameterPacketExtension.setName",
	"Comment": "sets the name of the format parameter we are representing here.",
	"Method": "void setName(String name){\r\n    super.setAttribute(NAME_ATTR_NAME, name);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.PasswordChangeDialog.createIconComponent",
	"Comment": "creates the icon component to show on the left of this dialog.",
	"Method": "Component createIconComponent(){\r\n    JPanel wrapIconPanel = new JPanel(new BorderLayout());\r\n    JLabel iconLabel = new JLabel();\r\n    iconLabel.setIcon(DesktopUtilActivator.getResources().getImage(\"service.gui.icons.AUTHORIZATION_ICON\"));\r\n    wrapIconPanel.add(iconLabel, BorderLayout.NORTH);\r\n    return wrapIconPanel;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.RootContactGroupJabberImpl.countSubgroups",
	"Comment": "returns the number of subgroups contained by thisrootcontactgroupimpl.",
	"Method": "int countSubgroups(){\r\n    return subGroups.size();\r\n}"
}, {
	"Path": "io.lettuce.core.cluster.event.ClusterTopologyChangedEvent.after",
	"Comment": "returns the cluster topology view after the topology changed.",
	"Method": "List<RedisClusterNode> after(){\r\n    return after;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.OperationSetPersistentPresenceGibberishImpl.getLocalContact",
	"Comment": "returns the protocol specific contact instance representing the localuser.",
	"Method": "Contact getLocalContact(){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.ircaccregwizz.IrcAccountRegistrationWizard.loadAccount",
	"Comment": "fills the userid and password fields in this panel with the data comingfrom the given protocolprovider.",
	"Method": "void loadAccount(ProtocolProviderService protocolProvider){\r\n    setModification(true);\r\n    this.protocolProvider = protocolProvider;\r\n    this.registration = new IrcAccountRegistration();\r\n    this.firstWizardPage.loadAccount(protocolProvider);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactImpl.queryProtoContactAvatar",
	"Comment": "queries a specific protocol contact for its avatar. beware thatthis method could cause multiple network operations. use with caution.",
	"Method": "byte[] queryProtoContactAvatar(Contact contact){\r\n    try {\r\n        byte[] contactImage = contact.getImage();\r\n        if ((contactImage != null) && (contactImage.length > 0))\r\n            return contactImage;\r\n    } catch (Exception ex) {\r\n        logger.error(\"Failed to get the photo of contact \" + contact, ex);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OutgoingFileTransferJabberImpl.getLocalFile",
	"Comment": "returns the local file that is being transferred or to which we transfer.",
	"Method": "File getLocalFile(){\r\n    return file;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactImpl.getContactsForOperationSet",
	"Comment": "returns all protocol specific contacts, encapsulated by this metacontactand supporting the given opsetclass. if none of thecontacts encapsulated by this metacontact is supporting the specifiedoperationset class then an empty iterator is returned.",
	"Method": "List<Contact> getContactsForOperationSet(Class<? extends OperationSet> opSetClass){\r\n    LinkedList<Contact> opSetContacts = new LinkedList<Contact>();\r\n    for (Contact contact : protoContacts) {\r\n        ProtocolProviderService contactProvider = contact.getProtocolProvider();\r\n        OperationSetContactCapabilities capOpSet = contactProvider.getOperationSet(OperationSetContactCapabilities.class);\r\n        if (capOpSet != null) {\r\n            List<Contact> capContacts = capabilities.get(opSetClass.getName());\r\n            if ((capContacts != null) && capContacts.contains(contact))\r\n                opSetContacts.add(contact);\r\n        } else if (contactProvider.getOperationSet(opSetClass) != null)\r\n            opSetContacts.add(contact);\r\n    }\r\n    return opSetContacts;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.FileUtils.createTempFileOutputStream",
	"Comment": "tries to create a new fileoutputstream for a temporary file intowhich a remote file is to be downloaded. because temporary filesgenerally have random characters in their names and the name of the filemay be shown to the user, first tries to use the name of the url to bedownloaded because it likely is prettier.",
	"Method": "FileOutputStream createTempFileOutputStream(URL url,String extension,boolean dryRun,File[] tempFile,String preferredFileName,String preferredExtension){\r\n    String path = url.getPath();\r\n    File tf = null;\r\n    FileOutputStream tfos = null;\r\n    if ((path != null) && (path.length() != 0)) {\r\n        int nameBeginIndex = path.lastIndexOf('/');\r\n        String name;\r\n        if (nameBeginIndex > 0) {\r\n            name = path.substring(nameBeginIndex + 1);\r\n            nameBeginIndex = name.lastIndexOf('\\\\');\r\n            if (nameBeginIndex > 0)\r\n                name = name.substring(nameBeginIndex + 1);\r\n        } else\r\n            name = path;\r\n        int nameLength = name.length();\r\n        if (nameLength != 0) {\r\n            int baseNameEnd = name.lastIndexOf('.');\r\n            if (extension == null)\r\n                extension = preferredExtension;\r\n            if (baseNameEnd == -1)\r\n                name += extension;\r\n            else if (baseNameEnd == 0) {\r\n                if (!extension.equalsIgnoreCase(name))\r\n                    name += extension;\r\n            } else\r\n                name = name.substring(0, baseNameEnd) + extension;\r\n            try {\r\n                String tempDir = System.getProperty(\"java.io.tmpdir\");\r\n                if ((tempDir != null) && (tempDir.length() != 0)) {\r\n                    tf = new File(tempDir, name);\r\n                    if (!dryRun)\r\n                        tfos = new FileOutputStream(tf);\r\n                }\r\n            } catch (FileNotFoundException fnfe) {\r\n            } catch (SecurityException se) {\r\n            }\r\n        }\r\n    }\r\n    if ((tfos == null) && !dryRun) {\r\n        tf = File.createTempFile(preferredFileName, preferredExtension);\r\n        tfos = new FileOutputStream(tf);\r\n    }\r\n    tempFile[0] = tf;\r\n    return tfos;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ServerStoredContactListJabberImpl.renameGroup",
	"Comment": "renames the specified group according to the specified new name..",
	"Method": "void renameGroup(ContactGroupJabberImpl groupToRename,String newName){\r\n    groupToRename.getSourceGroup().setName(newName);\r\n    groupToRename.setNameCopy(newName);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.notifsource.NotificationContactSource.getNotificationGroups",
	"Comment": "returns an iterator over a list of all notification groupscontained in this source.",
	"Method": "Iterator<? extends UIGroup> getNotificationGroups(){\r\n    return groups.values().iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.addActiveFileTransfer",
	"Comment": "adds the given file transfer id to the list of active filetransfers.",
	"Method": "void addActiveFileTransfer(String id,Object descriptor){\r\n    synchronized (activeFileTransfers) {\r\n        activeFileTransfers.put(id, descriptor);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallManager.isVideoStreaming",
	"Comment": "indicates if we have video streams to show in this interface.",
	"Method": "boolean isVideoStreaming(Call call,boolean isVideoStreaming,CallConference conference){\r\n    for (Call call : conference.getCalls()) {\r\n        OperationSetVideoTelephony videoTelephony = call.getProtocolProvider().getOperationSet(OperationSetVideoTelephony.class);\r\n        if (videoTelephony == null)\r\n            continue;\r\n        if (videoTelephony.isLocalVideoStreaming(call))\r\n            return true;\r\n        Iterator<? extends CallPeer> callPeers = call.getCallPeers();\r\n        while (callPeers.hasNext()) {\r\n            List<Component> remoteVideos = videoTelephony.getVisualComponents(callPeers.next());\r\n            if ((remoteVideos != null) && (remoteVideos.size() > 0))\r\n                return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomIrcImpl.removeChatRoomMember",
	"Comment": "removes a chatroommember from the list of members of this chatroom.",
	"Method": "void removeChatRoomMember(String memberID){\r\n    chatRoomMembers.remove(memberID);\r\n}"
}, {
	"Path": "io.lettuce.core.dynamic.batch.CommandBatching.flush",
	"Comment": "flush the command batch queue after adding a command to the batch queue.",
	"Method": "CommandBatching flush(){\r\n    return FlushCommands.instance();\r\n}"
}, {
	"Path": "io.lettuce.core.protocol.Command.encode",
	"Comment": "encode and write this command to the supplied buffer using the new unifiedrequest protocol.",
	"Method": "void encode(ByteBuf buf){\r\n    buf.writeByte('*');\r\n    CommandArgs.IntegerArgument.writeInteger(buf, 1 + (args != null ? args.count() : 0));\r\n    buf.writeBytes(CommandArgs.CRLF);\r\n    CommandArgs.BytesArgument.writeBytes(buf, type.getBytes());\r\n    if (args != null) {\r\n        args.encode(buf);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.GuiActivator.getSecurityAuthority",
	"Comment": "returns the securityauthority implementation registered tohandle security authority events.",
	"Method": "SecurityAuthority getSecurityAuthority(SecurityAuthority getSecurityAuthority,String protocolName){\r\n    String osgiFilter = \"(\" + ProtocolProviderFactory.PROTOCOL + \"=\" + protocolName + \")\";\r\n    SecurityAuthority securityAuthority = null;\r\n    try {\r\n        Collection<ServiceReference<SecurityAuthority>> serRefs = bundleContext.getServiceReferences(SecurityAuthority.class, osgiFilter);\r\n        if (!serRefs.isEmpty()) {\r\n            ServiceReference<SecurityAuthority> serRef = serRefs.iterator().next();\r\n            securityAuthority = bundleContext.getService(serRef);\r\n        }\r\n    } catch (InvalidSyntaxException ex) {\r\n        logger.error(\"GuiActivator : \" + ex);\r\n    }\r\n    return securityAuthority;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.UIServiceImpl.maybeShowMasterPasswordMissingWarningDialog",
	"Comment": "schedules a dialog to be shown to user after some time to warn him thatmaster password is not enabled.",
	"Method": "void maybeShowMasterPasswordMissingWarningDialog(){\r\n    if (GuiActivator.getCredentialsStorageService().isUsingMasterPassword() || !ConfigurationUtils.showMasterPasswordWarning()) {\r\n        return;\r\n    }\r\n    new Timer().schedule(new TimerTask() {\r\n        @Override\r\n        public void run() {\r\n            if (!SwingUtilities.isEventDispatchThread()) {\r\n                SwingUtilities.invokeLater(this);\r\n                return;\r\n            }\r\n            ResourceManagementService i18n = GuiActivator.getResources();\r\n            MessageDialog dialog = new MessageDialog(mainFrame, i18n.getI18NString(\"plugin.securityconfig.masterpassword\" + \".USE_MASTER_PASSWORD\"), i18n.getI18NString(\"plugin.securityconfig.masterpassword\" + \".NO_MP_WARNING\"), null, true);\r\n            switch(dialog.showDialog()) {\r\n                case MessageDialog.OK_DONT_ASK_CODE:\r\n                    ConfigurationUtils.setShowMasterPasswordWarning(false);\r\n                case MessageDialog.OK_RETURN_CODE:\r\n                    ConfigurationContainer configContainer = getConfigurationContainer();\r\n                    ConfigurationForm configForm = ConfigFormUtils.getConfigForm(ConfigurationForm.GENERAL_TYPE, \"net.java.sip.communicator.plugin.securityconfig\" + \".SecurityConfigurationPanel\");\r\n                    if (configForm != null) {\r\n                        configContainer.setSelected(configForm);\r\n                        configContainer.setVisible(true);\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n    }, 10000);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.UIServiceImpl.maybeShowMasterPasswordMissingWarningDialog",
	"Comment": "schedules a dialog to be shown to user after some time to warn him thatmaster password is not enabled.",
	"Method": "void maybeShowMasterPasswordMissingWarningDialog(){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(this);\r\n        return;\r\n    }\r\n    ResourceManagementService i18n = GuiActivator.getResources();\r\n    MessageDialog dialog = new MessageDialog(mainFrame, i18n.getI18NString(\"plugin.securityconfig.masterpassword\" + \".USE_MASTER_PASSWORD\"), i18n.getI18NString(\"plugin.securityconfig.masterpassword\" + \".NO_MP_WARNING\"), null, true);\r\n    switch(dialog.showDialog()) {\r\n        case MessageDialog.OK_DONT_ASK_CODE:\r\n            ConfigurationUtils.setShowMasterPasswordWarning(false);\r\n        case MessageDialog.OK_RETURN_CODE:\r\n            ConfigurationContainer configContainer = getConfigurationContainer();\r\n            ConfigurationForm configForm = ConfigFormUtils.getConfigForm(ConfigurationForm.GENERAL_TYPE, \"net.java.sip.communicator.plugin.securityconfig\" + \".SecurityConfigurationPanel\");\r\n            if (configForm != null) {\r\n                configContainer.setSelected(configForm);\r\n                configContainer.setVisible(true);\r\n            }\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.ExtendedTooltip.getUIClassID",
	"Comment": "returns the name of the l&f class that renders this component.",
	"Method": "String getUIClassID(){\r\n    return uiClassID;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.DesktopSharingButton.createDesktopSharingMenu",
	"Comment": "creates the menu responsible for desktop sharing when a single desktopsharing contact is available.",
	"Method": "JPopupMenu createDesktopSharingMenu(){\r\n    final JPopupMenu popupMenu = new JPopupMenu(GuiActivator.getResources().getI18NString(\"service.gui.SHARE_DESKTOP\"));\r\n    popupMenu.setInvoker(this);\r\n    popupMenu.setFocusable(true);\r\n    JMenuItem shareFullScreen = new JMenuItem(GuiActivator.getResources().getI18NString(\"service.gui.SHARE_FULL_SCREEN\"), new ImageIcon(ImageLoader.getImage(ImageLoader.DESKTOP_SHARING)));\r\n    JMenuItem shareRegion = new JMenuItem(GuiActivator.getResources().getI18NString(\"service.gui.SHARE_REGION\"), new ImageIcon(ImageLoader.getImage(ImageLoader.REGION_DESKTOP_SHARING)));\r\n    popupMenu.add(shareFullScreen);\r\n    popupMenu.add(shareRegion);\r\n    shareFullScreen.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent e) {\r\n            popupMenu.setVisible(false);\r\n            CallManager.enableDesktopSharing(call, true);\r\n        }\r\n    });\r\n    shareRegion.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent e) {\r\n            popupMenu.setVisible(false);\r\n            CallManager.enableRegionDesktopSharing(call, true);\r\n        }\r\n    });\r\n    return popupMenu;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.DesktopSharingButton.createDesktopSharingMenu",
	"Comment": "creates the menu responsible for desktop sharing when a single desktopsharing contact is available.",
	"Method": "JPopupMenu createDesktopSharingMenu(){\r\n    popupMenu.setVisible(false);\r\n    CallManager.enableDesktopSharing(call, true);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.DesktopSharingButton.createDesktopSharingMenu",
	"Comment": "creates the menu responsible for desktop sharing when a single desktopsharing contact is available.",
	"Method": "JPopupMenu createDesktopSharingMenu(){\r\n    popupMenu.setVisible(false);\r\n    CallManager.enableRegionDesktopSharing(call, true);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommFrame.addKeybindingAction",
	"Comment": "bindings the string representation for a keybinding to the action thatwill be executed.",
	"Method": "void addKeybindingAction(String binding,Action action){\r\n    amap.put(binding, action);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AccountInfoUtils.getFirstName",
	"Comment": "returns the first name of the account, to which the givenaccountinfoopset belongs.",
	"Method": "String getFirstName(OperationSetServerStoredAccountInfo accountInfoOpSet){\r\n    Iterator<GenericDetail> firstNameDetails = accountInfoOpSet.getDetails(FirstNameDetail.class);\r\n    if (firstNameDetails.hasNext()) {\r\n        FirstNameDetail firstName = (FirstNameDetail) firstNameDetails.next();\r\n        if (firstName != null)\r\n            return firstName.toString();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.IceTransportManagerSipImpl.startConnectivityEstablishment",
	"Comment": "starts the connectivity establishment of thistransportmanagerjabberimpl i.e. checks the connectivity betweenthe local and the remote peers given the remote counterpart of thenegotiation between them.",
	"Method": "boolean startConnectivityEstablishment(Iterable<RemoteCandidate> remote){\r\n    return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.WhiteboardSessionJabberImpl.moveWhiteboardObject",
	"Comment": "sends a whiteboardobject to modifyand modifies the local whiteboardobject",
	"Method": "void moveWhiteboardObject(WhiteboardObject obj){\r\n    WhiteboardObject wbObj = updateWhiteboardObjects(obj);\r\n    if (wbObj != null)\r\n        sendWhiteboardObject(wbObj);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.busylampfield.BLFActivator.initProviders",
	"Comment": "initializes all currently registered protocol providers that containthe desired operation set.",
	"Method": "void initProviders(){\r\n    for (ServiceReference<ProtocolProviderService> serRef : ServiceUtils.getServiceReferences(bundleContext, ProtocolProviderService.class)) {\r\n        handleProviderAdded(bundleContext.getService(serRef));\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AccountManager.queueLoadStoredAccounts",
	"Comment": "queues a specific protocolproviderfactory to have its storedaccounts loaded as soon as possible.",
	"Method": "void queueLoadStoredAccounts(ProtocolProviderFactory factory){\r\n    synchronized (loadStoredAccountsQueue) {\r\n        loadStoredAccountsQueue.add(factory);\r\n        loadStoredAccountsQueue.notifyAll();\r\n        if (loadStoredAccountsThread == null) {\r\n            loadStoredAccountsThread = new Thread() {\r\n                @Override\r\n                public void run() {\r\n                    runInLoadStoredAccountsThread();\r\n                }\r\n            };\r\n            loadStoredAccountsThread.setDaemon(true);\r\n            loadStoredAccountsThread.setName(\"AccountManager.loadStoredAccounts\");\r\n            loadStoredAccountsThread.start();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AccountManager.queueLoadStoredAccounts",
	"Comment": "queues a specific protocolproviderfactory to have its storedaccounts loaded as soon as possible.",
	"Method": "void queueLoadStoredAccounts(ProtocolProviderFactory factory){\r\n    runInLoadStoredAccountsThread();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.sysactivity.SysActivityActivator.getBundleContext",
	"Comment": "returns a reference to the bundle context that we were started with.",
	"Method": "BundleContext getBundleContext(){\r\n    return bundleContext;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.caps.EntityCapsManager.calculateEntityCapsVersion",
	"Comment": "calculates the ver string for the specified discoverinfo,identity type, name features, and extendedinfo.",
	"Method": "void calculateEntityCapsVersion(DiscoverInfo discoverInfo){\r\n    setCurrentCapsVersion(discoverInfo, capsToHash(CapsPacketExtension.HASH_METHOD, calculateEntityCapsString(discoverInfo)));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.JingleNodesCandidateDatagramSocket.send",
	"Comment": "sends a datagram packet from this socket. the datagrampacketincludes information indicating the data to be sent, its length, the ipaddress of the remote host, and the port number on the remote host.",
	"Method": "void send(DatagramPacket p){\r\n    byte[] data = p.getData();\r\n    int dataLen = p.getLength();\r\n    int dataOffset = p.getOffset();\r\n    DatagramPacket packet = new DatagramPacket(data, dataOffset, dataLen, new InetSocketAddress(localEndPoint.getAddress(), localEndPoint.getPort()));\r\n    super.send(packet);\r\n    if (logPacket(++nbSentRtpPackets)) {\r\n        StunStack.logPacketToPcap(packet, true, super.getLocalAddress(), super.getLocalPort());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.MetaContactChatSession.getCurrentChatTransport",
	"Comment": "returns the currently used transport for all operation within this chatsession.",
	"Method": "ChatTransport getCurrentChatTransport(){\r\n    return currentChatTransport;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.UINotification.getUnreadObjects",
	"Comment": "returns the number of unread objects for this notification.",
	"Method": "int getUnreadObjects(){\r\n    return unreadObjects;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.whiteboard.WhiteboardSessionPacketExtension.setAction",
	"Comment": "sets the action associated with this session packet extension.",
	"Method": "void setAction(String action){\r\n    this.action = action;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.NetworkUtils.getARecord",
	"Comment": "returns array of hosts from the a record of the specified domain.the records are ordered against the a record priority",
	"Method": "InetSocketAddress getARecord(String domain,int port){\r\n    byte[] address;\r\n    if ((address = strToIPv4(domain)) != null) {\r\n        try {\r\n            return new InetSocketAddress(InetAddress.getByAddress(domain, address), port);\r\n        } catch (UnknownHostException e) {\r\n            logger.error(\"Unable to create InetAddress for <\" + domain + \">\", e);\r\n            return null;\r\n        }\r\n    }\r\n    Record[] records;\r\n    try {\r\n        Lookup lookup = createLookup(domain, Type.A);\r\n        records = lookup.run();\r\n    } catch (TextParseException tpe) {\r\n        logger.error(\"Failed to parse domain=\" + domain, tpe);\r\n        throw new ParseException(tpe.getMessage(), 0);\r\n    } catch (DnssecRuntimeException e) {\r\n        throw new DnssecException(e);\r\n    }\r\n    if (records != null && records.length > 0) {\r\n        if (logger.isTraceEnabled())\r\n            logger.trace(\"A record for \" + domain + \"=\" + ((ARecord) records[0]).getAddress());\r\n        try {\r\n            return new InetSocketAddress(InetAddress.getByAddress(domain, ((ARecord) records[0]).getAddress().getAddress()), port);\r\n        } catch (UnknownHostException e) {\r\n            return null;\r\n        }\r\n    } else {\r\n        if (logger.isTraceEnabled())\r\n            logger.trace(\"No A record found for \" + domain);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.AbstractCallPeerJabberGTalkImpl.getDiscoveryInfo",
	"Comment": "returns the service discovery information that we have for this peer.",
	"Method": "DiscoverInfo getDiscoveryInfo(){\r\n    return discoverInfo;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ContactNode.isActive",
	"Comment": "returns true if this contact node has unread received messageswaiting, otherwise returns false.",
	"Method": "boolean isActive(){\r\n    return isActive;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractCall.getProtocolProvider",
	"Comment": "returns a reference to the protocolproviderservice instancethat created this call.",
	"Method": "U getProtocolProvider(){\r\n    return (U) super.getProtocolProvider();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.history.HistoryWindow.initDates",
	"Comment": "initializes the history with a list of all dates, for which a historywith the given contact is available.",
	"Method": "void initDates(){\r\n    this.initProgressBar(null);\r\n    new DatesLoader().start();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.ContactGibberishImpl.getDisplayName",
	"Comment": "returns a string that could be used by any user interacting modulesfor referring to this contact.",
	"Method": "String getDisplayName(){\r\n    return contactID;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.slickless.util.xml.TestXMLUtils.testFindChild",
	"Comment": "tests the find child method over a few nodes of the sample xml string.",
	"Method": "void testFindChild(){\r\n    Element parent = (Element) rootNode;\r\n    String tagName = \"parent\";\r\n    Element actualReturn = XMLUtils.findChild(parent, tagName);\r\n    assertEquals(\"parent\", actualReturn.getTagName());\r\n    parent = actualReturn;\r\n    tagName = \"innerprops\";\r\n    actualReturn = XMLUtils.findChild(parent, tagName);\r\n    assertEquals(\"innerprops\", actualReturn.getTagName());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.netaddr.NetworkAddressManagerServiceImpl.createIceStream",
	"Comment": "creates an icemediastrean and adds to it an rtp and and rtcp component, which also implies running the currently installed harvesters so that they would.",
	"Method": "IceMediaStream createIceStream(int rtpPort,String streamName,Agent agent,IceMediaStream createIceStream,int numComponents,int portBase,String streamName,Agent agent){\r\n    if (numComponents < 1 || numComponents > 2)\r\n        throw new IllegalArgumentException(\"Invalid numComponents value: \" + numComponents);\r\n    IceMediaStream stream = agent.createMediaStream(streamName);\r\n    agent.createComponent(stream, Transport.UDP, portBase, portBase, portBase + 100);\r\n    if (numComponents > 1) {\r\n        agent.createComponent(stream, Transport.UDP, portBase + 1, portBase + 1, portBase + 101);\r\n    }\r\n    return stream;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.IceConfigPanel.getAdditionalJingleNodes",
	"Comment": "returns the list of additional jingle nodes entered by the user.",
	"Method": "List<JingleNodeDescriptor> getAdditionalJingleNodes(){\r\n    LinkedList<JingleNodeDescriptor> serversList = new LinkedList<JingleNodeDescriptor>();\r\n    Vector<Vector<JingleNodeDescriptor>> serverRows = jnTableModel.getDataVector();\r\n    for (Vector<JingleNodeDescriptor> row : serverRows) serversList.add(row.elementAt(0));\r\n    return serversList;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.notificationconfiguration.NotificationEntry.setPopup",
	"Comment": "method which set a boolean to true if a systray popup is executed for thenotification.",
	"Method": "void setPopup(boolean popup){\r\n    this.popup = popup;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapContactQuery.stopped",
	"Comment": "notifies this ldapcontactquery that it has stopped performingin the associated background thread.",
	"Method": "void stopped(boolean completed){\r\n    try {\r\n        super.stopped(completed);\r\n    } finally {\r\n        getContactSource().stopped(this);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.keybindingchooser.KeybindingChooserActivator.getGlobalShortcutService",
	"Comment": "returns a reference to a globalshortcutservice implementation currentlyregistered in the bundle context or null if no such implementation wasfound.",
	"Method": "GlobalShortcutService getGlobalShortcutService(){\r\n    if (globalShortcutService == null) {\r\n        ServiceReference globalShortcutReference = bundleContext.getServiceReference(GlobalShortcutService.class.getName());\r\n        globalShortcutService = (GlobalShortcutService) bundleContext.getService(globalShortcutReference);\r\n    }\r\n    return globalShortcutService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.generalconfig.autoaway.AutoAwayWatcher.removeProviderFromLastStates",
	"Comment": "remove provider from list with last statuses.if this is the last provider stop listening for idle events.",
	"Method": "void removeProviderFromLastStates(ProtocolProviderService provider){\r\n    lastStates.remove(provider);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.account.AccountList.registrationStateChanged",
	"Comment": "refreshes the account status icon, when the status has changed.",
	"Method": "void registrationStateChanged(RegistrationStateChangeEvent evt){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                registrationStateChanged(evt);\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    accountListModelContentChanged(evt.getProvider());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.account.AccountList.registrationStateChanged",
	"Comment": "refreshes the account status icon, when the status has changed.",
	"Method": "void registrationStateChanged(RegistrationStateChangeEvent evt){\r\n    registrationStateChanged(evt);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chatroomslist.joinforms.JoinChatRoomWizardPage1.setNextButtonAccordingToRowSelection",
	"Comment": "enables the next button when the user makes a choice and disables itif nothing is selected.",
	"Method": "void setNextButtonAccordingToRowSelection(){\r\n    if (selectAccountPanel.isRowSelected())\r\n        this.wizard.setNextFinishButtonEnabled(true);\r\n    else\r\n        this.wizard.setNextFinishButtonEnabled(false);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockChatRoom.revokeAdmin",
	"Comment": "revokes the admin role for the participant given by address.",
	"Method": "void revokeAdmin(String address){\r\n    throw new UnsupportedOperationException(\"Not supported yet.\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.MainFrame.enterKeyTyped",
	"Comment": "called when the enter key was typed when this window was the focusedwindow. performs the appropriate actions depending on the current stateof the contact list.",
	"Method": "void enterKeyTyped(){\r\n    if (unknownContactPanel != null && unknownContactPanel.isVisible()) {\r\n        unknownContactPanel.addUnknownContact();\r\n    } else if (contactListPanel.isVisible()) {\r\n        GuiActivator.getContactList().startSelectedContactChat();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.sipaccregwizz.SIPAccountRegistrationWizard.getUserNameExample",
	"Comment": "returns an example string, which should indicate to the user how theuser name should look like.",
	"Method": "String getUserNameExample(){\r\n    return \"Ex: john@voiphone.net or simply \\\"john\\\" for no server\";\r\n}"
}, {
	"Path": "net.librec.ensemble.tools.LeastSquare.compute",
	"Comment": "this method is used to calculate each elements of augmented matrix.",
	"Method": "void compute(){\r\n    if (x == null || y == null || x.length <= 1 || x.length != y.length || x.length < n || n < 2) {\r\n        return;\r\n    }\r\n    double[] s = new double[(n - 1) * 2 + 1];\r\n    for (int i = 0; i < s.length; i++) {\r\n        for (int j = 0; j < x.length; j++) {\r\n            s[i] += Math.pow(x[j], i) * weight[j];\r\n        }\r\n    }\r\n    double[] b = new double[n];\r\n    for (int i = 0; i < b.length; i++) {\r\n        for (int j = 0; j < x.length; j++) {\r\n            b[i] += Math.pow(x[j], i) * y[j] * weight[j];\r\n        }\r\n    }\r\n    double[][] a = new double[n][n];\r\n    for (int i = 0; i < n; i++) {\r\n        for (int j = 0; j < n; j++) {\r\n            a[i][j] = s[i + j];\r\n        }\r\n    }\r\n    coefficient = calcLinearEquation(a, b);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomJabberImpl.smackRoleToScRole",
	"Comment": "returns that chatroomjabberrole instance corresponding to thesmackrole string.",
	"Method": "ChatRoomMemberRole smackRoleToScRole(String smackRole,String affiliation){\r\n    if (affiliation != null) {\r\n        if (affiliation.equals(\"admin\")) {\r\n            return ChatRoomMemberRole.ADMINISTRATOR;\r\n        } else if (affiliation.equals(\"owner\")) {\r\n            return ChatRoomMemberRole.OWNER;\r\n        }\r\n    }\r\n    if (smackRole != null) {\r\n        if (smackRole.equalsIgnoreCase(\"moderator\")) {\r\n            return ChatRoomMemberRole.MODERATOR;\r\n        } else if (smackRole.equalsIgnoreCase(\"participant\")) {\r\n            return ChatRoomMemberRole.MEMBER;\r\n        }\r\n    }\r\n    return ChatRoomMemberRole.GUEST;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.notifsource.NotificationGroup.getGroupNode",
	"Comment": "returns the groupnode corresponding to this uigroup.the is the actual node used in the contact list component data model.",
	"Method": "GroupNode getGroupNode(){\r\n    return groupNode;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.googlecontacts.OAuth2TokenStore.createCredential",
	"Comment": "create credential instance suitable for use in google contacts api.",
	"Method": "Credential createCredential(AtomicReference<Credential> store,TokenData data){\r\n    final Credential.Builder builder = new Credential.Builder(BearerToken.authorizationHeaderAccessMethod());\r\n    builder.setTokenServerUrl(GOOGLE_OAUTH2_TOKEN_SERVER);\r\n    builder.setTransport(new NetHttpTransport());\r\n    builder.setJsonFactory(new JacksonFactory());\r\n    builder.setClientAuthentication(new HttpExecuteInterceptor() {\r\n        @Override\r\n        public void intercept(HttpRequest request) throws IOException {\r\n            final Object data = ((UrlEncodedContent) request.getContent()).getData();\r\n            if (data instanceof RefreshTokenRequest) {\r\n                final RefreshTokenRequest content = (RefreshTokenRequest) data;\r\n                content.put(\"client_id\", GOOGLE_API_CLIENT_ID);\r\n                content.put(\"client_secret\", GOOGLE_API_CLIENT_SECRET);\r\n                LOGGER.info(\"Inserting client authentication data into \" + \"refresh token request.\");\r\n                if (LOGGER.isDebugEnabled()) {\r\n                    LOGGER.debug(\"Request: \" + content.toString());\r\n                }\r\n            } else {\r\n                LOGGER.debug(\"Unexpected type of request found.\");\r\n            }\r\n        }\r\n    });\r\n    builder.addRefreshListener(new CredentialRefreshListener() {\r\n        @Override\r\n        public void onTokenResponse(Credential credential, TokenResponse tokenResponse) throws IOException {\r\n            LOGGER.debug(\"Successful token refresh response: \" + tokenResponse.toPrettyString());\r\n            store.set(credential);\r\n        }\r\n        @Override\r\n        public void onTokenErrorResponse(Credential credential, TokenErrorResponse tokenErrorResponse) throws IOException {\r\n            if (LOGGER.isDebugEnabled()) {\r\n                LOGGER.debug(\"Failed token refresh response: \" + tokenErrorResponse.toPrettyString());\r\n            }\r\n            LOGGER.error(\"Failed to refresh OAuth2 token: \" + tokenErrorResponse.getError() + \": \" + tokenErrorResponse.getErrorDescription());\r\n        }\r\n    });\r\n    final Credential credential = builder.build();\r\n    credential.setAccessToken(data.accessToken);\r\n    credential.setRefreshToken(data.refreshToken);\r\n    credential.setExpiresInSeconds(data.expiration);\r\n    return credential;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.googlecontacts.OAuth2TokenStore.createCredential",
	"Comment": "create credential instance suitable for use in google contacts api.",
	"Method": "Credential createCredential(AtomicReference<Credential> store,TokenData data){\r\n    final Object data = ((UrlEncodedContent) request.getContent()).getData();\r\n    if (data instanceof RefreshTokenRequest) {\r\n        final RefreshTokenRequest content = (RefreshTokenRequest) data;\r\n        content.put(\"client_id\", GOOGLE_API_CLIENT_ID);\r\n        content.put(\"client_secret\", GOOGLE_API_CLIENT_SECRET);\r\n        LOGGER.info(\"Inserting client authentication data into \" + \"refresh token request.\");\r\n        if (LOGGER.isDebugEnabled()) {\r\n            LOGGER.debug(\"Request: \" + content.toString());\r\n        }\r\n    } else {\r\n        LOGGER.debug(\"Unexpected type of request found.\");\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.googlecontacts.OAuth2TokenStore.createCredential",
	"Comment": "create credential instance suitable for use in google contacts api.",
	"Method": "Credential createCredential(AtomicReference<Credential> store,TokenData data){\r\n    LOGGER.debug(\"Successful token refresh response: \" + tokenResponse.toPrettyString());\r\n    store.set(credential);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.googlecontacts.OAuth2TokenStore.createCredential",
	"Comment": "create credential instance suitable for use in google contacts api.",
	"Method": "Credential createCredential(AtomicReference<Credential> store,TokenData data){\r\n    if (LOGGER.isDebugEnabled()) {\r\n        LOGGER.debug(\"Failed token refresh response: \" + tokenErrorResponse.toPrettyString());\r\n    }\r\n    LOGGER.error(\"Failed to refresh OAuth2 token: \" + tokenErrorResponse.getError() + \": \" + tokenErrorResponse.getErrorDescription());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ContactGroupIcqImpl.getParentContactGroup",
	"Comment": "returns a reference to the root icq group which in icq is the parent ofany other group since the protocol does not support subgroups.",
	"Method": "ContactGroup getParentContactGroup(){\r\n    return ssclCallback.getRootGroup();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWritePanel.updateChatTransportStatus",
	"Comment": "updates the status of the given chat transport in the send via selectorbox and notifies the user for the status change.",
	"Method": "void updateChatTransportStatus(ChatTransport chatTransport){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                updateChatTransportStatus(chatTransport);\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    if (transportSelectorBox != null)\r\n        transportSelectorBox.updateTransportStatus(chatTransport);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWritePanel.updateChatTransportStatus",
	"Comment": "updates the status of the given chat transport in the send via selectorbox and notifies the user for the status change.",
	"Method": "void updateChatTransportStatus(ChatTransport chatTransport){\r\n    updateChatTransportStatus(chatTransport);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.SearchFilter.setFilterString",
	"Comment": "creates the searchfilter by specifying the string used forfiltering.",
	"Method": "void setFilterString(String filter){\r\n    this.filterString = filter;\r\n    this.filterPattern = Pattern.compile(Pattern.quote(filterString), Pattern.MULTILINE | Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);\r\n    this.isSearchingPhoneNumber = GuiActivator.getPhoneNumberI18nService().isPhoneNumber(filter);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.MuteSessionInfoPacketExtension.getName",
	"Comment": "returns the name of the session that this extension is pertaining to ornull if it is referring to all active sessions.",
	"Method": "String getName(){\r\n    return getAttributeAsString(NAME_ATTR_VALUE);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.OperationSetBasicInstantMessagingGibberishImpl.sendInstantMessage",
	"Comment": "sends the message to the destination indicated by theto contact.",
	"Method": "void sendInstantMessage(Contact to,Message message){\r\n    if (!(to instanceof ContactGibberishImpl))\r\n        throw new IllegalArgumentException(\"The specified contact is not a Gibberish contact.\" + to);\r\n    fireMessageDelivered(message, to);\r\n    deliverMessage(message, (ContactGibberishImpl) to);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.accountinfo.AccountDetailsPanel.loadDetails",
	"Comment": "loads all serverstoreddetails which are currently supported bythis plugin. note that some operationsetserverstoredaccountinfoimplementations may support details that are not supported by this plugin.in this case they will not be loaded.",
	"Method": "void loadDetails(){\r\n    if (accountInfoOpSet != null) {\r\n        new DetailsLoadWorker().start();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.GuiActivator.getResources",
	"Comment": "returns the resourcemanagementservice, through which we willaccess all resources.",
	"Method": "ResourceManagementService getResources(){\r\n    if (resourcesService == null) {\r\n        resourcesService = ServiceUtils.getService(bundleContext, ResourceManagementService.class);\r\n    }\r\n    return resourcesService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.history.HistoryReaderImpl.findLast",
	"Comment": "returns the supplied number of recent messagescontaining all keywords.",
	"Method": "QueryResultSet<HistoryRecord> findLast(int count,QueryResultSet<HistoryRecord> findLast,int count,String[] keywords,String field,boolean caseSensitive){\r\n    Vector<String> filelist = filterFilesByDate(this.historyImpl.getFileList(), null, null);\r\n    TreeSet<HistoryRecord> result = new TreeSet<HistoryRecord>(new HistoryRecordComparator());\r\n    int leftCount = count;\r\n    int currentFile = filelist.size() - 1;\r\n    SimpleDateFormat sdf = new SimpleDateFormat(DATE_FORMAT);\r\n    while (leftCount > 0 && currentFile >= 0) {\r\n        Document doc = this.historyImpl.getDocumentForFile(filelist.get(currentFile));\r\n        if (doc == null) {\r\n            currentFile--;\r\n            continue;\r\n        }\r\n        List<Node> nodes = new ArrayList<Node>();\r\n        NodeList nodesList = doc.getElementsByTagName(\"record\");\r\n        for (int i = 0; i < nodesList.getLength(); i++) {\r\n            nodes.add(nodesList.item(i));\r\n        }\r\n        List<Node> lNodes = null;\r\n        if (nodes.size() > leftCount) {\r\n            lNodes = nodes.subList(nodes.size() - leftCount, nodes.size());\r\n            leftCount = 0;\r\n        } else {\r\n            lNodes = nodes;\r\n            leftCount -= nodes.size();\r\n        }\r\n        Iterator<Node> i = lNodes.iterator();\r\n        while (i.hasNext()) {\r\n            Node node = i.next();\r\n            NodeList propertyNodes = node.getChildNodes();\r\n            Date timestamp;\r\n            String ts = node.getAttributes().getNamedItem(\"timestamp\").getNodeValue();\r\n            try {\r\n                timestamp = sdf.parse(ts);\r\n            } catch (ParseException e) {\r\n                timestamp = new Date(Long.parseLong(ts));\r\n            }\r\n            HistoryRecord record = filterByKeyword(propertyNodes, timestamp, keywords, field, caseSensitive);\r\n            if (record != null) {\r\n                result.add(record);\r\n            }\r\n        }\r\n        currentFile--;\r\n    }\r\n    return new OrderedQueryResultSet<HistoryRecord>(result);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.DesktopUtilActivator.getGlobalDisplayDetailsService",
	"Comment": "returns the globaldisplaydetailsservice obtained from the bundlecontext.",
	"Method": "GlobalDisplayDetailsService getGlobalDisplayDetailsService(){\r\n    if (globalDisplayDetailsService == null) {\r\n        globalDisplayDetailsService = ServiceUtils.getService(bundleContext, GlobalDisplayDetailsService.class);\r\n    }\r\n    return globalDisplayDetailsService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.gui.UIContactDetail.getPrefix",
	"Comment": "returns the prefix to be used when calling this contact detail.",
	"Method": "String getPrefix(){\r\n    return prefix;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.contactlist.event.MetaContactRenamedEvent.getNewDisplayName",
	"Comment": "returns the display name of the source meta contact as it is now, afterthe change.",
	"Method": "String getNewDisplayName(){\r\n    return (String) getNewValue();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomIrcImpl.removeMemberPropertyChangeListener",
	"Comment": "removes the given listener from the list of listeners currentlyregistered for chat room member property change events.",
	"Method": "void removeMemberPropertyChangeListener(ChatRoomMemberPropertyChangeListener listener){\r\n    synchronized (memberPropChangeListeners) {\r\n        memberPropChangeListeners.remove(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler.intersectRTPExtensions",
	"Comment": "compares a list of rtpextensions offered by a remote partyto the list of locally supported rtpextensions as returnedby one of our local mediadevices and returns a thirdlist that contains their intersection. the returnedlist contains extensions supported by both the remote party andthe local device that we are dealing with. direction attributes of bothlists are also intersected and the returned rtpextensions havedirections valid from a local perspective. in other words, ifremoteextensions contains an extension that the remote partysupports in a sendonly mode, and we support that extension in asendrecv mode, the corresponding entry in the returned list willhave a recvonly direction.",
	"Method": "List<RTPExtension> intersectRTPExtensions(List<RTPExtension> remoteExtensions,List<RTPExtension> supportedExtensions){\r\n    if (remoteExtensions == null || supportedExtensions == null)\r\n        return new ArrayList<RTPExtension>();\r\n    List<RTPExtension> intersection = new ArrayList<RTPExtension>(Math.min(remoteExtensions.size(), supportedExtensions.size()));\r\n    for (RTPExtension remoteExtension : remoteExtensions) {\r\n        RTPExtension localExtension = findExtension(supportedExtensions, remoteExtension.getURI().toString());\r\n        if (localExtension == null)\r\n            continue;\r\n        MediaDirection localDir = localExtension.getDirection();\r\n        MediaDirection remoteDir = remoteExtension.getDirection();\r\n        RTPExtension intersected = new RTPExtension(localExtension.getURI(), localDir.getDirectionForAnswer(remoteDir), remoteExtension.getExtensionAttributes());\r\n        intersection.add(intersected);\r\n    }\r\n    return intersection;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.sysactivity.SystemActivityNotificationsServiceImpl.isSupported",
	"Comment": "can check whether an event id is supported oncurrent operation system.simple return what is implemented in native, and checksare made when possible, for example linux cannot connectto nm through dbus.",
	"Method": "boolean isSupported(int eventID){\r\n    if (OSUtils.IS_WINDOWS) {\r\n        switch(eventID) {\r\n            case SystemActivityEvent.EVENT_SLEEP:\r\n            case SystemActivityEvent.EVENT_WAKE:\r\n            case SystemActivityEvent.EVENT_NETWORK_CHANGE:\r\n            case SystemActivityEvent.EVENT_SYSTEM_IDLE:\r\n            case SystemActivityEvent.EVENT_SYSTEM_IDLE_END:\r\n                return SystemActivityNotifications.isLoaded();\r\n            default:\r\n                return false;\r\n        }\r\n    } else if (OSUtils.IS_MAC) {\r\n        return SystemActivityNotifications.isLoaded();\r\n    } else if (OSUtils.IS_LINUX) {\r\n        switch(eventID) {\r\n            case SystemActivityEvent.EVENT_SLEEP:\r\n            case SystemActivityEvent.EVENT_NETWORK_CHANGE:\r\n                {\r\n                    SystemActivityManager currentRunningManager = getCurrentRunningManager();\r\n                    return (currentRunningManager == null) ? false : currentRunningManager.isConnected();\r\n                }\r\n            case SystemActivityEvent.EVENT_SYSTEM_IDLE:\r\n            case SystemActivityEvent.EVENT_SYSTEM_IDLE_END:\r\n                return SystemActivityNotifications.isLoaded();\r\n            default:\r\n                return false;\r\n        }\r\n    } else if (OSUtils.IS_ANDROID) {\r\n        return (eventID == SystemActivityEvent.EVENT_NETWORK_CHANGE);\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.gibberish.TestOperationSetPresence.subtestQueryContactStatus",
	"Comment": "used by functions testing the querycontactstatus method of thepresence operation set.",
	"Method": "void subtestQueryContactStatus(PresenceStatus status){\r\n    operationSetPresence2.publishPresenceStatus(status, \"status message\");\r\n    pauseAfterStateChanges();\r\n    PresenceStatus actualReturn = operationSetPresence1.queryContactStatus(fixture.userID2);\r\n    assertEquals(\"Querying a \" + status.getStatusName() + \" state did not return as expected\", status, actualReturn);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.resources.AbstractResourcesService.getDefaultResourcePack",
	"Comment": "searches for the resourcepack corresponding to the givenclassname and .",
	"Method": "T getDefaultResourcePack(Class<T> clazz,String typeName){\r\n    Collection<ServiceReference<T>> serRefs;\r\n    String osgiFilter = \"(\" + ResourcePack.RESOURCE_NAME + \"=\" + typeName + \")\";\r\n    try {\r\n        serRefs = bundleContext.getServiceReferences(clazz, osgiFilter);\r\n    } catch (InvalidSyntaxException ex) {\r\n        serRefs = null;\r\n        logger.error(\"Could not obtain resource packs reference.\", ex);\r\n    }\r\n    if ((serRefs != null) && !serRefs.isEmpty()) {\r\n        return bundleContext.getService(serRefs.iterator().next());\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.caps.EntityCapsManager.calculateEntityCapsString",
	"Comment": "calculates the string for a specific discoverinfo whichis to be hashed in order to compute the ver string for thatdiscoverinfo.",
	"Method": "String calculateEntityCapsString(DiscoverInfo discoverInfo){\r\n    StringBuilder bldr = new StringBuilder();\r\n    {\r\n        Iterator<DiscoverInfo.Identity> identities = discoverInfo.getIdentities();\r\n        SortedSet<DiscoverInfo.Identity> is = new TreeSet<DiscoverInfo.Identity>(new Comparator<DiscoverInfo.Identity>() {\r\n            public int compare(DiscoverInfo.Identity i1, DiscoverInfo.Identity i2) {\r\n                int category = i1.getCategory().compareTo(i2.getCategory());\r\n                if (category != 0)\r\n                    return category;\r\n                int type = i1.getType().compareTo(i2.getType());\r\n                if (type != 0)\r\n                    return type;\r\n                return type;\r\n            }\r\n        });\r\n        if (identities != null)\r\n            while (identities.hasNext()) is.add(identities.next());\r\n        for (DiscoverInfo.Identity i : is) {\r\n            bldr.append(i.getCategory()).append('/').append(i.getType()).append(\"//\").append(i.getName()).append('<');\r\n        }\r\n    }\r\n    {\r\n        Iterator<DiscoverInfo.Feature> features = getDiscoverInfoFeatures(discoverInfo);\r\n        SortedSet<String> fs = new TreeSet<String>();\r\n        if (features != null)\r\n            while (features.hasNext()) fs.add(features.next().getVar());\r\n        for (String f : fs) bldr.append(f).append('<');\r\n    }\r\n    DataForm extendedInfo = (DataForm) discoverInfo.getExtension(\"x\", \"jabber:x:data\");\r\n    if (extendedInfo != null) {\r\n        synchronized (extendedInfo) {\r\n            SortedSet<FormField> fs = new TreeSet<FormField>(new Comparator<FormField>() {\r\n                public int compare(FormField f1, FormField f2) {\r\n                    return f1.getVariable().compareTo(f2.getVariable());\r\n                }\r\n            });\r\n            FormField formType = null;\r\n            for (Iterator<FormField> fieldsIter = extendedInfo.getFields(); fieldsIter.hasNext(); ) {\r\n                FormField f = fieldsIter.next();\r\n                if (!f.getVariable().equals(\"FORM_TYPE\"))\r\n                    fs.add(f);\r\n                else\r\n                    formType = f;\r\n            }\r\n            if (formType != null)\r\n                formFieldValuesToCaps(formType.getValues(), bldr);\r\n            for (FormField f : fs) {\r\n                bldr.append(f.getVariable()).append('<');\r\n                formFieldValuesToCaps(f.getValues(), bldr);\r\n            }\r\n        }\r\n    }\r\n    return bldr.toString();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.caps.EntityCapsManager.calculateEntityCapsString",
	"Comment": "calculates the string for a specific discoverinfo whichis to be hashed in order to compute the ver string for thatdiscoverinfo.",
	"Method": "String calculateEntityCapsString(DiscoverInfo discoverInfo){\r\n    int category = i1.getCategory().compareTo(i2.getCategory());\r\n    if (category != 0)\r\n        return category;\r\n    int type = i1.getType().compareTo(i2.getType());\r\n    if (type != 0)\r\n        return type;\r\n    return type;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.caps.EntityCapsManager.calculateEntityCapsString",
	"Comment": "calculates the string for a specific discoverinfo whichis to be hashed in order to compute the ver string for thatdiscoverinfo.",
	"Method": "String calculateEntityCapsString(DiscoverInfo discoverInfo){\r\n    return f1.getVariable().compareTo(f2.getVariable());\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.gui.event.MetaContactQuery.addContactQueryListener",
	"Comment": "adds the given metacontactquerylistener to the list ofregistered listeners. the metacontactquerylistener would benotified each time a new metacontactquery result has beenreceived or if the query has been completed or has been canceled by useror for any other reason.",
	"Method": "void addContactQueryListener(MetaContactQueryListener l){\r\n    synchronized (queryListeners) {\r\n        queryListeners.add(l);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.ChatRoomListImpl.removeChatRoomProviderWrapperListener",
	"Comment": "removes a chatroomproviderwrapperlistener from the listener list.",
	"Method": "void removeChatRoomProviderWrapperListener(ChatRoomProviderWrapperListener listener){\r\n    providerChangeListeners.remove(listener);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.MainFrame.getWebContactInfoOpSet",
	"Comment": "returns the web contact info operation set for the givenprotocol provider.",
	"Method": "OperationSetWebContactInfo getWebContactInfoOpSet(ProtocolProviderService protocolProvider){\r\n    OperationSet opSet = protocolProvider.getOperationSet(OperationSetWebContactInfo.class);\r\n    return (opSet instanceof OperationSetWebContactInfo) ? (OperationSetWebContactInfo) opSet : null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.ServerStoredGroupEvent.getSourceOperationSet",
	"Comment": "returns a reference to the operation set that generated the event",
	"Method": "OperationSetPersistentPresence getSourceOperationSet(){\r\n    return this.parentOperationSet;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.DynamicPayloadTypeRegistry.obtainPayloadTypeNumber",
	"Comment": "returns the dynamic payload type that has been allocated forformat. a mapping for the specified format would becreated even if it did not previously exist. the method is meant for useprimarily during generation of sdp descriptions.",
	"Method": "byte obtainPayloadTypeNumber(MediaFormat format){\r\n    Byte payloadType = getPayloadType(format);\r\n    if (payloadType == null) {\r\n        Byte preferredPT = getPreferredDynamicPayloadType(format);\r\n        if (preferredPT != null && findFormat(preferredPT) == null) {\r\n            payloadType = preferredPT;\r\n        } else {\r\n            payloadType = nextPayloadTypeNumber();\r\n        }\r\n        payloadTypeMappings.put(format, payloadType);\r\n    }\r\n    return payloadType;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.SecurityAccountRegistration.getEncryptionProtocols",
	"Comment": "returns the map between the encryption protocols and their priorityorder.",
	"Method": "Map<String, Integer> getEncryptionProtocols(){\r\n    return encryptionProtocols;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.AdHocConferenceChatTransport.removeSmsMessageListener",
	"Comment": "removes the given sms message listener from this chat transport.",
	"Method": "void removeSmsMessageListener(MessageListener l){\r\n    if (!allowsSmsMessage())\r\n        return;\r\n    OperationSetSmsMessaging smsOpSet = adHocChatRoom.getParentProvider().getOperationSet(OperationSetSmsMessaging.class);\r\n    smsOpSet.removeMessageListener(l);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetPersistentPresenceJabberImpl.removeResource",
	"Comment": "removes the resource indicated by the fulljid from the list withresources for the contact.",
	"Method": "boolean removeResource(ContactJabberImpl contact,String fullJid){\r\n    Map<String, ContactResourceJabberImpl> resources = contact.getResourcesMap();\r\n    if (resources.containsKey(fullJid)) {\r\n        ContactResource removedResource = resources.remove(fullJid);\r\n        contact.fireContactResourceEvent(new ContactResourceEvent(contact, removedResource, ContactResourceEvent.RESOURCE_REMOVED));\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.xcap.BaseHttpXCapClient.assertConnected",
	"Comment": "utility method throwing an exception if the user is not connected.",
	"Method": "void assertConnected(){\r\n    if (!connected) {\r\n        throw new IllegalStateException(\"User is not connected to the server\");\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl.processReInvite",
	"Comment": "reinitializes the media session of the callpeer that thisinvite request is destined to.",
	"Method": "void processReInvite(ServerTransaction serverTransaction){\r\n    Request invite = serverTransaction.getRequest();\r\n    setLatestInviteTransaction(serverTransaction);\r\n    String sdpOffer = null;\r\n    ContentLengthHeader cl = invite.getContentLength();\r\n    if (cl != null && cl.getContentLength() > 0)\r\n        sdpOffer = SdpUtils.getContentAsString(invite);\r\n    Response response = null;\r\n    try {\r\n        response = messageFactory.createResponse(Response.OK, invite);\r\n        processExtraHeaders(response);\r\n        String sdpAnswer;\r\n        if (sdpOffer != null)\r\n            sdpAnswer = getMediaHandler().processOffer(sdpOffer);\r\n        else\r\n            sdpAnswer = getMediaHandler().createOffer();\r\n        response.setContent(sdpAnswer, getProtocolProvider().getHeaderFactory().createContentTypeHeader(\"application\", \"sdp\"));\r\n        if (logger.isTraceEnabled())\r\n            logger.trace(\"will send an OK response: \" + response);\r\n        serverTransaction.sendResponse(response);\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"OK response sent\");\r\n    } catch (Exception ex) {\r\n        logger.error(\"Error while trying to send a response\", ex);\r\n        setState(CallPeerState.FAILED, \"Internal Error: \" + ex.getMessage());\r\n        getProtocolProvider().sayErrorSilently(serverTransaction, Response.SERVER_INTERNAL_ERROR);\r\n        return;\r\n    }\r\n    reevalRemoteHoldStatus();\r\n    fireRequestProcessed(invite, response);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.IceConfigPanel.getStunServer",
	"Comment": "indicates if a stun server with the given address andport already exists in the additional stun servers table.",
	"Method": "StunServerDescriptor getStunServer(String address,int port){\r\n    for (int i = 0; i < tableModel.getRowCount(); i++) {\r\n        StunServerDescriptor stunServer = (StunServerDescriptor) tableModel.getValueAt(i, 0);\r\n        if (stunServer.getAddress().equalsIgnoreCase(address) && stunServer.getPort() == port)\r\n            return stunServer;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.TransportManager.getICECandidateExtendedType",
	"Comment": "returns the ice candidate extended type selected by the given agent.",
	"Method": "String getICECandidateExtendedType(String streamName,String getICECandidateExtendedType,Agent iceAgent,String streamName){\r\n    if (iceAgent != null) {\r\n        LocalCandidate localCandidate = iceAgent.getSelectedLocalCandidate(streamName);\r\n        if (localCandidate != null)\r\n            return localCandidate.getExtendedType().toString();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWritePanel.getRightButtonMenu",
	"Comment": "returns the writepanelrightbuttonmenu opened in this panel.used by the chatwindow, when the esc button is pressed, tocheck if there is an open menu, which should be closed.",
	"Method": "WritePanelRightButtonMenu getRightButtonMenu(){\r\n    return rightButtonMenu;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.netaddr.NetaddrActivator.getPacketLogging",
	"Comment": "returns a reference to the packetloggingservice implementationcurrently registered in the bundle context or null if no suchimplementation was found.",
	"Method": "PacketLoggingService getPacketLogging(){\r\n    if (packetLoggingService == null) {\r\n        packetLoggingService = ServiceUtils.getService(bundleContext, PacketLoggingService.class);\r\n    }\r\n    return packetLoggingService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.ExternalContactSource.createUIContact",
	"Comment": "returns the uicontact corresponding to the givensourcecontact.",
	"Method": "UIContact createUIContact(SourceContact sourceContact){\r\n    SourceUIContact descriptor = new SourceUIContact(sourceContact, sourceUIGroup);\r\n    sourceContact.setData(UI_CONTACT_DATA_KEY, descriptor);\r\n    return descriptor;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.WhiteboardObjectModifiedEvent.getTimestamp",
	"Comment": "a timestamp indicating the exact date when the event ocurred.",
	"Method": "Date getTimestamp(){\r\n    return timestamp;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.ProtocolProviderActivator.start",
	"Comment": "registers a new accountmanagerimpl instance as anaccountmanager service and starts a newsinglecallinprogresspolicy instance to ensure that only oneof the calls accessible in the bundlecontextin which this activator is to execute will be in progress and the otherswill automatically be put on hold.",
	"Method": "void start(BundleContext bundleContext){\r\n    ProtocolProviderActivator.bundleContext = bundleContext;\r\n    accountManager = new AccountManager(bundleContext);\r\n    accountManagerServiceRegistration = bundleContext.registerService(AccountManager.class.getName(), accountManager, null);\r\n    if (logger.isTraceEnabled()) {\r\n        logger.trace(\"ProtocolProviderActivator will create \" + \"SingleCallInProgressPolicy instance.\");\r\n    }\r\n    singleCallInProgressPolicy = new SingleCallInProgressPolicy(bundleContext);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.FileTransferProgressEvent.getFileTransfer",
	"Comment": "returns the source filetransfer that triggered this event.",
	"Method": "FileTransfer getFileTransfer(){\r\n    return (FileTransfer) source;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatTransport.getResourceName",
	"Comment": "returns the resource name of this chat transport. this is for example thename of the user agent from which the contact is logged.",
	"Method": "String getResourceName(){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ServerStoredContactListJabberImpl.searchForCustomAvatar",
	"Comment": "query custom avatar services and returns the first found avtar.",
	"Method": "byte[] searchForCustomAvatar(String address){\r\n    try {\r\n        ServiceReference[] refs = JabberActivator.bundleContext.getServiceReferences(CustomAvatarService.class.getName(), null);\r\n        if (refs == null)\r\n            return null;\r\n        for (ServiceReference r : refs) {\r\n            CustomAvatarService avatarService = (CustomAvatarService) JabberActivator.bundleContext.getService(r);\r\n            byte[] res = avatarService.getAvatar(address);\r\n            if (res != null)\r\n                return res;\r\n        }\r\n    } catch (Throwable t) {\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetBasicInstantMessagingSipImpl.addMessageProcessor",
	"Comment": "registers a sipmessageprocessor with this operation set so that it getsnotifications of successful message delivery, failure or reception ofincoming messages..",
	"Method": "void addMessageProcessor(SipMessageProcessor processor){\r\n    synchronized (this.messageProcessors) {\r\n        if (!this.messageProcessors.contains(processor)) {\r\n            this.messageProcessors.add(processor);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.AbstractOperationSetTelephonyConferencing.usersMatch",
	"Comment": "checks whether two conferenceinfodocument.user instancesmatch according to the needs of our implementation. can returntrue for users which are not identical.",
	"Method": "boolean usersMatch(ConferenceInfoDocument.User a,ConferenceInfoDocument.User b){\r\n    if (a == null && b == null)\r\n        return true;\r\n    else if (a == null || b == null)\r\n        return false;\r\n    else if (!stringsMatch(a.getEntity(), b.getEntity()))\r\n        return false;\r\n    else if (!stringsMatch(a.getDisplayText(), b.getDisplayText()))\r\n        return false;\r\n    else if (a.getEndpoints().size() != b.getEndpoints().size())\r\n        return false;\r\n    for (ConferenceInfoDocument.Endpoint aEndpoint : a.getEndpoints()) {\r\n        if (!endpointsMatch(aEndpoint, b.getEndpoint(aEndpoint.getEntity())))\r\n            return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatTransport.allowsInstantMessage",
	"Comment": "returns true if this chat transport supports instantmessaging, otherwise returns false.",
	"Method": "boolean allowsInstantMessage(){\r\n    return chatRoom.isJoined();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AccountManager.hasStoredAccount",
	"Comment": "checks whether a stored account with userid is storedin configuration.",
	"Method": "boolean hasStoredAccount(String protocolName,boolean includeHidden,String userID){\r\n    Collection<ServiceReference<ProtocolProviderFactory>> factoryRefs = ServiceUtils.getServiceReferences(bundleContext, ProtocolProviderFactory.class);\r\n    boolean hasStoredAccounts = false;\r\n    if (!factoryRefs.isEmpty()) {\r\n        ConfigurationService configService = ProtocolProviderActivator.getConfigurationService();\r\n        for (ServiceReference<ProtocolProviderFactory> factoryRef : factoryRefs) {\r\n            ProtocolProviderFactory factory = bundleContext.getService(factoryRef);\r\n            if ((protocolName != null) && !protocolName.equals(factory.getProtocolName())) {\r\n                continue;\r\n            }\r\n            String factoryPackage = getFactoryImplPackageName(factory);\r\n            List<String> storedAccounts = configService.getPropertyNamesByPrefix(factoryPackage + \".acc\", false);\r\n            for (Iterator<String> storedAccountIter = storedAccounts.iterator(); storedAccountIter.hasNext(); ) {\r\n                String storedAccount = storedAccountIter.next();\r\n                List<String> storedAccountProperties = configService.getPropertyNamesByPrefix(storedAccount, true);\r\n                boolean hidden = false;\r\n                String accountUserID = null;\r\n                if (!includeHidden || userID != null) {\r\n                    for (Iterator<String> storedAccountPropertyIter = storedAccountProperties.iterator(); storedAccountPropertyIter.hasNext(); ) {\r\n                        String property = storedAccountPropertyIter.next();\r\n                        String value = configService.getString(property);\r\n                        property = stripPackagePrefix(property);\r\n                        if (ProtocolProviderFactory.IS_PROTOCOL_HIDDEN.equals(property)) {\r\n                            hidden = (value != null);\r\n                        } else if (ProtocolProviderFactory.USER_ID.equals(property)) {\r\n                            accountUserID = value;\r\n                        }\r\n                    }\r\n                }\r\n                if (includeHidden || !hidden) {\r\n                    if (accountUserID != null && userID != null && userID.equals(accountUserID)) {\r\n                        hasStoredAccounts = true;\r\n                        break;\r\n                    } else if (userID == null) {\r\n                        hasStoredAccounts = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (hasStoredAccounts || (protocolName != null)) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return hasStoredAccounts;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.neomedia.AbstractDeviceConfigurationListener.popupMessageClicked",
	"Comment": "indicates that user has clicked on the systray popup message.",
	"Method": "void popupMessageClicked(SystrayPopupMessageEvent ev){\r\n    if (ev.getTag() == this) {\r\n        UIService uiService = ServiceUtils.getService(NeomediaActivator.getBundleContext(), UIService.class);\r\n        if (uiService != null) {\r\n            ConfigurationContainer configurationContainer = uiService.getConfigurationContainer();\r\n            configurationContainer.setSelected(configurationForm);\r\n            configurationContainer.setVisible(true);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.configuration.TestConfigurationServicePersistency.testLoadConfiguration",
	"Comment": "tests whether the load method has properly loaded our conf file duringsetup.",
	"Method": "void testLoadConfiguration(){\r\n    Object returnedValueObj = configurationService.getProperty(property1Path + property1);\r\n    assertNotNull(\"configuration not properly loaded\", returnedValueObj);\r\n    assertTrue(\"returned prop is not a String\", returnedValueObj instanceof String);\r\n    String returnedValue = returnedValueObj.toString();\r\n    assertEquals(\"configuration not properly loaded\", property1Value, returnedValue);\r\n    returnedValueObj = configurationService.getProperty(systemPropertyPath + systemProperty);\r\n    assertNotNull(\"configuration not properly loaded\", returnedValueObj);\r\n    assertTrue(\"returned prop is not a String\", returnedValueObj instanceof String);\r\n    returnedValue = System.getProperty(systemPropertyPath + systemProperty);\r\n    assertNotNull(\"A system property was not resolved\", returnedValue);\r\n    assertEquals(\"A system property was not resolved\", systemPropertyValue, returnedValue);\r\n    returnedValue = returnedValueObj.toString();\r\n    assertEquals(\"configuration not properly loaded\", systemPropertyValue, returnedValue);\r\n    returnedValueObj = configurationService.getProperty(innerPropertyPath + innerProperty).toString();\r\n    assertNotNull(\"configuration not properly loaded\", returnedValueObj);\r\n    assertTrue(\"returned prop is not a String\", returnedValueObj instanceof String);\r\n    returnedValue = returnedValueObj.toString();\r\n    assertEquals(\"configuration not properly loaded\", innerPropertyValue, returnedValue);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.account.AccountRightButtonMenu.actionPerformed",
	"Comment": "handles the actionevent. determines which menu item wasselected and performs the appropriate operations.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    JMenuItem menuItem = (JMenuItem) e.getSource();\r\n    if (menuItem.equals(editItem)) {\r\n        if (account == null)\r\n            return;\r\n        AccountRegWizardContainerImpl wizard = (AccountRegWizardContainerImpl) GuiActivator.getUIService().getAccountRegWizardContainer();\r\n        AccountRegistrationWizard protocolWizard = wizard.getProtocolWizard(account.getProtocolProvider());\r\n        ResourceManagementService resources = GuiActivator.getResources();\r\n        if (protocolWizard != null) {\r\n            wizard.setTitle(resources.getI18NString(\"service.gui.ACCOUNT_REGISTRATION_WIZARD\"));\r\n            wizard.modifyAccount(account.getProtocolProvider());\r\n            wizard.showDialog(false);\r\n        } else {\r\n            String title = resources.getI18NString(\"service.gui.ERROR\");\r\n            String message = resources.getI18NString(\"service.gui.EDIT_NOT_SUPPORTED\");\r\n            ErrorDialog dialog = new ErrorDialog(null, title, message);\r\n            dialog.setVisible(true);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.usersearch.UserSearchActivator.handleProviderAdded",
	"Comment": "handles the registration of a new protocolproviderservice. addsthe given protocolprovider to the list of queried providers.",
	"Method": "void handleProviderAdded(ProtocolProviderService protocolProvider){\r\n    if (protocolProvider.getOperationSet(OperationSetServerStoredContactInfo.class) != null && !userSearchProviders.contains(protocolProvider)) {\r\n        OperationSetUserSearch opSet = protocolProvider.getOperationSet(OperationSetUserSearch.class);\r\n        if (opSet == null)\r\n            return;\r\n        if (userSeachListener == null)\r\n            userSeachListener = new UserSearchProviderStateListener();\r\n        opSet.addUserSearchProviderListener(userSeachListener);\r\n        if (opSet.isEnabled())\r\n            addSupportedProvider(protocolProvider);\r\n        userSearchProviders.add(protocolProvider);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.PresenceFilter.addMatching",
	"Comment": "adds all contacts contained in the given metacontactgroupmatching the current filter and not contained in the contact list.",
	"Method": "void addMatching(MetaContactGroup metaGroup,MetaContactQuery query,int resultCount){\r\n    Iterator<MetaContact> childContacts = metaGroup.getChildContacts();\r\n    while (childContacts.hasNext() && !query.isCanceled()) {\r\n        MetaContact metaContact = childContacts.next();\r\n        if (isMatching(metaContact)) {\r\n            resultCount++;\r\n            if (resultCount <= INITIAL_CONTACT_COUNT) {\r\n                UIGroup uiGroup = null;\r\n                if (!MetaContactListSource.isRootGroup(metaGroup)) {\r\n                    synchronized (metaGroup) {\r\n                        uiGroup = MetaContactListSource.getUIGroup(metaGroup);\r\n                        if (uiGroup == null)\r\n                            uiGroup = MetaContactListSource.createUIGroup(metaGroup);\r\n                    }\r\n                }\r\n                if (logger.isDebugEnabled())\r\n                    logger.debug(\"Presence filter contact added: \" + metaContact.getDisplayName());\r\n                UIContactImpl newUIContact;\r\n                synchronized (metaContact) {\r\n                    newUIContact = MetaContactListSource.getUIContact(metaContact);\r\n                    if (newUIContact == null) {\r\n                        newUIContact = MetaContactListSource.createUIContact(metaContact);\r\n                    }\r\n                }\r\n                GuiActivator.getContactList().addContact(newUIContact, uiGroup, true, true);\r\n                query.setInitialResultCount(resultCount);\r\n            } else {\r\n                query.fireQueryEvent(metaContact);\r\n            }\r\n        }\r\n    }\r\n    if (query.isCanceled())\r\n        return;\r\n    Iterator<MetaContactGroup> subgroups = metaGroup.getSubgroups();\r\n    while (subgroups.hasNext() && !query.isCanceled()) {\r\n        MetaContactGroup subgroup = subgroups.next();\r\n        if (isMatching(subgroup)) {\r\n            UIGroup uiGroup;\r\n            synchronized (subgroup) {\r\n                uiGroup = MetaContactListSource.getUIGroup(subgroup);\r\n                if (uiGroup == null)\r\n                    uiGroup = MetaContactListSource.createUIGroup(subgroup);\r\n            }\r\n            GuiActivator.getContactList().addGroup(uiGroup, true);\r\n            addMatching(subgroup, query, resultCount);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.ActiveCallsRepository.getActiveCallCount",
	"Comment": "returns the number of calls currently tracked by this repository.",
	"Method": "int getActiveCallCount(){\r\n    synchronized (activeCalls) {\r\n        return activeCalls.size();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetUserSearchJabberImpl.addUserSearchProviderListener",
	"Comment": "adds usersearchproviderlistener instance to the list oflisteners.",
	"Method": "void addUserSearchProviderListener(UserSearchProviderListener l){\r\n    synchronized (listeners) {\r\n        if (!listeners.contains(l))\r\n            listeners.add(l);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.msoutlook.calendar.CalendarServiceImpl.insert",
	"Comment": "gets the property values of given calendar item and createscalendaritemtimertask instance for it.",
	"Method": "void insert(String id){\r\n    Object[] props = null;\r\n    props = IMAPIProp_GetProps(id, MAPICalendarProperties.getALLPropertyIDs(), MAPI_UNICODE);\r\n    addCalendarItem(props, id);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageHistoryServiceImpl.findFirstMessagesAfter",
	"Comment": "returns the supplied number of recent messages after the given dateexchanged in the supplied chat room",
	"Method": "Collection<EventObject> findFirstMessagesAfter(MetaContact contact,Date date,int count,Collection<EventObject> findFirstMessagesAfter,ChatRoom room,Date date,int count){\r\n    LinkedList<EventObject> result = new LinkedList<EventObject>();\r\n    try {\r\n        HistoryReader reader = this.getHistoryForMultiChat(room).getReader();\r\n        Iterator<HistoryRecord> recs = reader.findFirstRecordsAfter(date, count);\r\n        while (recs.hasNext()) {\r\n            result.add(convertHistoryRecordToMessageEvent(recs.next(), room));\r\n        }\r\n    } catch (IOException e) {\r\n        logger.error(\"Could not read history\", e);\r\n    }\r\n    Collections.sort(result, new ChatRoomMessageEventComparator<EventObject>());\r\n    int toIndex = count;\r\n    if (toIndex > result.size())\r\n        toIndex = result.size();\r\n    return result.subList(0, toIndex);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.AddressResolverImpl.resolveAddress",
	"Comment": "implements the actual resolving. this is where we do the dns queries.",
	"Method": "Hop resolveAddress(Hop inputAddress){\r\n    try {\r\n        String transport = inputAddress.getTransport();\r\n        String hostAddress = inputAddress.getHost();\r\n        if (transport == null)\r\n            transport = ListeningPoint.UDP;\r\n        String host = null;\r\n        int port = 0;\r\n        if (NetworkUtils.isValidIPAddress(hostAddress)) {\r\n            InetSocketAddress hostSocketAddress = new InetSocketAddress(NetworkUtils.getInetAddress(hostAddress), inputAddress.getPort());\r\n            return new HopImpl(hostSocketAddress.getHostName(), inputAddress.getPort(), transport);\r\n        } else if (transport.equalsIgnoreCase(ListeningPoint.TLS)) {\r\n            SRVRecord srvRecord = NetworkUtils.getSRVRecord(\"sips\", ListeningPoint.TCP, hostAddress);\r\n            if (srvRecord != null) {\r\n                host = srvRecord.getTarget();\r\n                port = srvRecord.getPort();\r\n            }\r\n        } else {\r\n            SRVRecord srvRecord = NetworkUtils.getSRVRecord(\"sip\", transport, hostAddress);\r\n            if (srvRecord != null) {\r\n                host = srvRecord.getTarget();\r\n                port = srvRecord.getPort();\r\n            }\r\n        }\r\n        if (host != null) {\r\n            if (logger.isTraceEnabled())\r\n                logger.trace(\"Returning hop as follows\" + \" host= \" + host + \" port= \" + port + \" transport= \" + transport);\r\n            return new HopImpl(host, port, transport);\r\n        }\r\n    } catch (Exception ex) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Domain \" + inputAddress + \" could not be resolved \" + ex.getMessage());\r\n        if (logger.isTraceEnabled())\r\n            logger.trace(\"Printing SRV resolution stack trace\", ex);\r\n    }\r\n    Hop returnHop;\r\n    if (inputAddress.getPort() != -1) {\r\n        returnHop = inputAddress;\r\n    } else {\r\n        String transport = inputAddress.getTransport();\r\n        returnHop = new HopImpl(inputAddress.getHost(), MessageProcessor.getDefaultPort(transport), transport);\r\n    }\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Returning hop: \" + returnHop);\r\n    return returnHop;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.TransferActiveCallsMenu.addCallPeerItem",
	"Comment": "adds the given callpeer to the list of availablecall peers for call transfer.",
	"Method": "void addCallPeerItem(CallPeer callPeer){\r\n    final CallPeerMenuItem peerItem = new CallPeerMenuItem(callPeer);\r\n    peerItem.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent e) {\r\n            CallManager.transferCall(initialPeer, callPeer);\r\n        }\r\n    });\r\n    this.add(peerItem);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.TransferActiveCallsMenu.addCallPeerItem",
	"Comment": "adds the given callpeer to the list of availablecall peers for call transfer.",
	"Method": "void addCallPeerItem(CallPeer callPeer){\r\n    CallManager.transferCall(initialPeer, callPeer);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetPersistentPresenceIcqImpl.statusLongToPresenceStatus",
	"Comment": "converts the specified icqstatus to one of the status fields of theicqstatusenum class.",
	"Method": "PresenceStatus statusLongToPresenceStatus(long icqStatus){\r\n    if (parentProvider.USING_ICQ) {\r\n        if (icqStatus == -1) {\r\n            return IcqStatusEnum.OFFLINE;\r\n        } else if ((icqStatus & FullUserInfo.ICQSTATUS_INVISIBLE) != 0) {\r\n            return IcqStatusEnum.INVISIBLE;\r\n        } else if ((icqStatus & FullUserInfo.ICQSTATUS_DND) != 0) {\r\n            return IcqStatusEnum.DO_NOT_DISTURB;\r\n        } else if ((icqStatus & FullUserInfo.ICQSTATUS_OCCUPIED) != 0) {\r\n            return IcqStatusEnum.OCCUPIED;\r\n        } else if ((icqStatus & FullUserInfo.ICQSTATUS_NA) != 0) {\r\n            return IcqStatusEnum.NOT_AVAILABLE;\r\n        } else if ((icqStatus & FullUserInfo.ICQSTATUS_AWAY) != 0) {\r\n            return IcqStatusEnum.AWAY;\r\n        } else if ((icqStatus & FullUserInfo.ICQSTATUS_FFC) != 0) {\r\n            return IcqStatusEnum.FREE_FOR_CHAT;\r\n        }\r\n        return IcqStatusEnum.ONLINE;\r\n    } else {\r\n        if (icqStatus == -1) {\r\n            return AimStatusEnum.OFFLINE;\r\n        } else if ((icqStatus & FullUserInfo.ICQSTATUS_INVISIBLE) != 0) {\r\n            return AimStatusEnum.INVISIBLE;\r\n        } else if ((icqStatus & FullUserInfo.ICQSTATUS_AWAY) != 0) {\r\n            return AimStatusEnum.AWAY;\r\n        }\r\n        return AimStatusEnum.ONLINE;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapPersonFoundImpl.setOrganization",
	"Comment": "sets the organization found in the the directory for this person",
	"Method": "void setOrganization(String organization){\r\n    this.organization = organization;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.BandwidthPacketExtension.getType",
	"Comment": "returns the value of the optional type argument in thebandwidth element.",
	"Method": "String getType(){\r\n    return getAttributeAsString(TYPE_ATTR_NAME);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomIrcImpl.setSystem",
	"Comment": "sets whether or not this chat room is corresponding to a serverchannel.",
	"Method": "void setSystem(boolean isSystem){\r\n    this.isSystem = isSystem;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.history.HistoryWindow.initPanels",
	"Comment": "constructs the window, by adding all components and panels.",
	"Method": "void initPanels(){\r\n    this.mainPanel.setBorder(BorderFactory.createEmptyBorder(SPACING, SPACING, SPACING, SPACING));\r\n    this.mainPanel.setPreferredSize(new Dimension(500, 400));\r\n    this.mainPanel.add(new SearchPanel(this), BorderLayout.NORTH);\r\n    this.mainPanel.add(chatConvPanel, BorderLayout.CENTER);\r\n    this.mainPanel.add(datesPanel, BorderLayout.WEST);\r\n    this.getContentPane().add(mainPanel);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.PresenceManager.parseISupportMonitor",
	"Comment": "parse the isupport parameter for monitor command support and list size.",
	"Method": "Integer parseISupportMonitor(IIRCState state){\r\n    final String value = state.getServerOptions().getKey(ISupport.MONITOR.name());\r\n    if (value == null) {\r\n        LOGGER.trace(\"No ISUPPORT parameter \" + ISupport.MONITOR.name() + \" available.\");\r\n        return null;\r\n    }\r\n    if (LOGGER.isDebugEnabled()) {\r\n        LOGGER.debug(\"Setting ISUPPORT parameter \" + ISupport.MONITOR.name() + \" to \" + value);\r\n    }\r\n    try {\r\n        return new Integer(value);\r\n    } catch (RuntimeException e) {\r\n        LOGGER.warn(\"Failed to parse MONITOR value.\", e);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetPersistentPresenceJabberImpl.createServerStoredContactGroup",
	"Comment": "creates a group with the specified name and parent in the serverstored contact list.",
	"Method": "void createServerStoredContactGroup(ContactGroup parent,String groupName){\r\n    assertConnected();\r\n    if (!parent.canContainSubgroups())\r\n        throw new IllegalArgumentException(\"The specified contact group cannot contain child groups. Group:\" + parent);\r\n    ssContactList.createGroup(groupName);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatTransportSelectorBox.allowsInstantMessage",
	"Comment": "returns true if this contains a chat transport thatsupports instant messaging, otherwise returns false.",
	"Method": "boolean allowsInstantMessage(){\r\n    for (ChatTransport tr : transportMenuItems.keySet()) {\r\n        if (tr.allowsInstantMessage()) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.keybox.manage.util.SSHUtil.getNextInstanceId",
	"Comment": "return the next instance id based on ids defined in the session map",
	"Method": "int getNextInstanceId(Long sessionId,Map<Long, UserSchSessions> userSessionMap){\r\n    Integer instanceId = 1;\r\n    if (userSessionMap.get(sessionId) != null) {\r\n        for (Integer id : userSessionMap.get(sessionId).getSchSessionMap().keySet()) {\r\n            if (!id.equals(instanceId) && userSessionMap.get(sessionId).getSchSessionMap().get(instanceId) == null) {\r\n                return instanceId;\r\n            }\r\n            instanceId = instanceId + 1;\r\n        }\r\n    }\r\n    return instanceId;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.IceUdpTransportManager.createIceAgent",
	"Comment": "creates the ice agent that we would be using in this transport managerfor all negotiation.",
	"Method": "Agent createIceAgent(){\r\n    long startGatheringHarvesterTime = System.currentTimeMillis();\r\n    CallPeerJabberImpl peer = getCallPeer();\r\n    ProtocolProviderServiceJabberImpl provider = peer.getProtocolProvider();\r\n    NetworkAddressManagerService namSer = getNetAddrMgr();\r\n    boolean atLeastOneStunServer = false;\r\n    Agent agent = namSer.createIceAgent();\r\n    agent.setControlling(!peer.isInitiator());\r\n    JabberAccountIDImpl accID = (JabberAccountIDImpl) provider.getAccountID();\r\n    if (accID.isStunServerDiscoveryEnabled()) {\r\n        String username = org.jivesoftware.smack.util.StringUtils.parseName(provider.getOurJID());\r\n        String password = JabberActivator.getProtocolProviderFactory().loadPassword(accID);\r\n        UserCredentials credentials = provider.getUserCredentials();\r\n        if (credentials != null)\r\n            password = credentials.getPasswordAsString();\r\n        if (password == null) {\r\n            credentials = new UserCredentials();\r\n            credentials.setUserName(accID.getUserID());\r\n            credentials = provider.getAuthority().obtainCredentials(accID.getDisplayName(), credentials, SecurityAuthority.AUTHENTICATION_REQUIRED);\r\n            if (credentials == null) {\r\n                logger.info(\"Credentials were null. User has most likely canceled the login operation\");\r\n                return null;\r\n            }\r\n            char[] pass = credentials.getPassword();\r\n            if (pass == null) {\r\n                logger.info(\"Password was null. User has most likely canceled the login operation\");\r\n                return null;\r\n            }\r\n            password = new String(pass);\r\n            if (credentials.isPasswordPersistent()) {\r\n                JabberActivator.getProtocolProviderFactory().storePassword(accID, password);\r\n            }\r\n        }\r\n        StunCandidateHarvester autoHarvester = namSer.discoverStunServer(accID.getService(), StringUtils.getUTF8Bytes(username), StringUtils.getUTF8Bytes(password));\r\n        if (logger.isInfoEnabled())\r\n            logger.info(\"Auto discovered harvester is \" + autoHarvester);\r\n        if (autoHarvester != null) {\r\n            atLeastOneStunServer = true;\r\n            agent.addCandidateHarvester(autoHarvester);\r\n        }\r\n    }\r\n    for (StunServerDescriptor desc : accID.getStunServers()) {\r\n        TransportAddress addr = new TransportAddress(desc.getAddress(), desc.getPort(), Transport.UDP);\r\n        if (addr.getAddress() == null) {\r\n            logger.info(\"Unresolved address for \" + addr);\r\n            continue;\r\n        }\r\n        StunCandidateHarvester harvester;\r\n        if (desc.isTurnSupported()) {\r\n            harvester = new TurnCandidateHarvester(addr, new LongTermCredential(desc.getUsername(), desc.getPassword()));\r\n        } else {\r\n            harvester = new StunCandidateHarvester(addr);\r\n        }\r\n        if (logger.isInfoEnabled())\r\n            logger.info(\"Adding pre-configured harvester \" + harvester);\r\n        atLeastOneStunServer = true;\r\n        agent.addCandidateHarvester(harvester);\r\n    }\r\n    if (!atLeastOneStunServer && accID.isUseDefaultStunServer()) {\r\n        TransportAddress addr = new TransportAddress(DEFAULT_STUN_SERVER_ADDRESS, DEFAULT_STUN_SERVER_PORT, Transport.UDP);\r\n        agent.addCandidateHarvester(new StunCandidateHarvester(addr));\r\n    }\r\n    if (accID.isJingleNodesRelayEnabled()) {\r\n        SmackServiceNode serviceNode = provider.getJingleNodesServiceNode();\r\n        if (serviceNode != null) {\r\n            agent.addCandidateHarvester(new JingleNodesHarvester(serviceNode));\r\n        }\r\n    }\r\n    if (accID.isUPNPEnabled())\r\n        agent.addCandidateHarvester(new UPNPHarvester());\r\n    long stopGatheringHarvesterTime = System.currentTimeMillis();\r\n    if (logger.isInfoEnabled()) {\r\n        long gatheringHarvesterTime = stopGatheringHarvesterTime - startGatheringHarvesterTime;\r\n        logger.info(\"End gathering harvester within \" + gatheringHarvesterTime + \" ms\");\r\n    }\r\n    return agent;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetServerStoredAccountInfoIcqImpl.getDetailsAndDescendants",
	"Comment": "returns an iterator over all details that are instances or descendantsof the specified class.",
	"Method": "Iterator<T> getDetailsAndDescendants(Class<T> detailClass){\r\n    assertConnected();\r\n    if (ImageDetail.class.isAssignableFrom(detailClass)) {\r\n        List<ImageDetail> res = new Vector<ImageDetail>();\r\n        res.add(getImage());\r\n        @SuppressWarnings(\"unchecked\")\r\n        Iterator<T> tIt = (Iterator<T>) res.iterator();\r\n        return tIt;\r\n    }\r\n    return infoRetreiver.getDetailsAndDescendants(uin, detailClass);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.customcontrols.wizard.Wizard.stopCommittingPage",
	"Comment": "changes cursor and status label, informing user we finished the processof connecting.",
	"Method": "void stopCommittingPage(){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                stopCommittingPage();\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    isCurrentlySigningIn = false;\r\n    statusLabel.setText(\"\");\r\n    setCursor(new Cursor(Cursor.DEFAULT_CURSOR));\r\n    setBackButtonEnabled(true);\r\n    setCancelButtonEnabled(true);\r\n    setNextFinishButtonEnabled(true);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.customcontrols.wizard.Wizard.stopCommittingPage",
	"Comment": "changes cursor and status label, informing user we finished the processof connecting.",
	"Method": "void stopCommittingPage(){\r\n    stopCommittingPage();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetPersistentPresenceJabberImpl.createUnresolvedContactGroup",
	"Comment": "creates and returns a unresolved contact group from the specifiedaddress and persistentdata.",
	"Method": "ContactGroup createUnresolvedContactGroup(String groupUID,String persistentData,ContactGroup parentGroup){\r\n    return ssContactList.createUnresolvedContactGroup(groupUID);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.sip.TestOperationSetPersistentPresence.postTestCreateGroup",
	"Comment": "creates a group in the server stored contact list, makes sure that thecorresponding event has been generated and verifies that the group isin the list.",
	"Method": "void postTestCreateGroup(){\r\n    this.fixture.clearProvidersLists();\r\n    Object o = new Object();\r\n    synchronized (o) {\r\n        o.wait(3000);\r\n    }\r\n    logger.trace(\"testing creation of server stored groups\");\r\n    GroupChangeCollector groupChangeCollector = new GroupChangeCollector();\r\n    this.opSetPersPresence1.addServerStoredGroupChangeListener(groupChangeCollector);\r\n    this.opSetPersPresence1.createServerStoredContactGroup(this.opSetPersPresence1.getServerStoredContactListRoot(), testGroupName);\r\n    groupChangeCollector.waitForEvent(10000);\r\n    this.opSetPersPresence1.removeServerStoredGroupChangeListener(groupChangeCollector);\r\n    assertEquals(\"Collected Group Change events: \", 1, groupChangeCollector.collectedEvents.size());\r\n    assertEquals(\"Group name.\", testGroupName, ((ServerStoredGroupEvent) groupChangeCollector.collectedEvents.get(0)).getSourceGroup().getGroupName());\r\n    ContactGroup group = this.opSetPersPresence1.getServerStoredContactListRoot().getGroup(testGroupName);\r\n    assertNotNull(\"A newly created group was not in the contact list.\", group);\r\n    assertEquals(\"New group name\", testGroupName, group.getGroupName());\r\n    try {\r\n        this.opSetPersPresence1.subscribe(group, this.fixture.userID2);\r\n        synchronized (o) {\r\n            o.wait(1500);\r\n        }\r\n    } catch (Exception ex) {\r\n        fail(\"error adding entry to group : \" + group.getGroupName() + \" \" + ex.getMessage());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl.processRequest",
	"Comment": "processes a request received on a sipprovider upon which this siplisteneris registered.",
	"Method": "void processRequest(RequestEvent requestEvent){\r\n    Request request = requestEvent.getRequest();\r\n    if (sipRegistrarConnection != null && !sipRegistrarConnection.isRegistrarless() && !sipRegistrarConnection.isRequestFromSameConnection(request) && !forceLooseRouting) {\r\n        logger.warn(\"Received request not from our proxy, ignoring it! \" + \"Request:\" + request);\r\n        if (requestEvent.getServerTransaction() != null) {\r\n            try {\r\n                requestEvent.getServerTransaction().terminate();\r\n            } catch (Throwable e) {\r\n                logger.warn(\"Failed to properly terminate transaction for \" + \"a rogue request. Well ... so be it \" + \"Request:\" + request);\r\n            }\r\n        }\r\n        return;\r\n    }\r\n    earlyProcessMessage(requestEvent);\r\n    EventHeader eventHeader = (EventHeader) request.getHeader(EventHeader.NAME);\r\n    if (eventHeader != null) {\r\n        boolean eventKnown;\r\n        synchronized (this.registeredEvents) {\r\n            eventKnown = this.registeredEvents.contains(eventHeader.getEventType());\r\n        }\r\n        if (!eventKnown) {\r\n            ServerTransaction serverTransaction = requestEvent.getServerTransaction();\r\n            if (serverTransaction == null) {\r\n                try {\r\n                    serverTransaction = SipStackSharing.getOrCreateServerTransaction(requestEvent);\r\n                } catch (TransactionAlreadyExistsException ex) {\r\n                    logger.error(\"Failed to create a new server\" + \"transaction for an incoming request\\n\" + \"(Next message contains the request)\", ex);\r\n                    return;\r\n                } catch (TransactionUnavailableException ex) {\r\n                    logger.error(\"Failed to create a new server\" + \"transaction for an incoming request\\n\" + \"(Next message contains the request)\", ex);\r\n                    return;\r\n                }\r\n            }\r\n            Response response = null;\r\n            try {\r\n                response = this.getMessageFactory().createResponse(Response.BAD_EVENT, request);\r\n            } catch (ParseException e) {\r\n                logger.error(\"failed to create the 489 response\", e);\r\n                return;\r\n            }\r\n            try {\r\n                serverTransaction.sendResponse(response);\r\n                return;\r\n            } catch (SipException e) {\r\n                logger.error(\"failed to send the response\", e);\r\n            } catch (InvalidArgumentException e) {\r\n                logger.error(\"invalid argument provided while trying\" + \" to send the response\", e);\r\n            }\r\n        }\r\n    }\r\n    String method = request.getMethod();\r\n    List<MethodProcessor> processors = methodProcessors.get(method);\r\n    boolean processedAtLeastOnce = false;\r\n    if (processors != null) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Found \" + processors.size() + \" processor(s) for method \" + method);\r\n        for (MethodProcessor processor : processors) {\r\n            if (processor.processRequest(requestEvent)) {\r\n                processedAtLeastOnce = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (!processedAtLeastOnce) {\r\n        ServerTransaction serverTransaction;\r\n        try {\r\n            serverTransaction = SipStackSharing.getOrCreateServerTransaction(requestEvent);\r\n            if (serverTransaction == null) {\r\n                logger.warn(\"Could not create a transaction for a \" + \"non-supported method \" + request.getMethod());\r\n                return;\r\n            }\r\n            TransactionState state = serverTransaction.getState();\r\n            if (TransactionState.TRYING.equals(state)) {\r\n                Response response = this.getMessageFactory().createResponse(Response.NOT_IMPLEMENTED, request);\r\n                serverTransaction.sendResponse(response);\r\n            }\r\n        } catch (Throwable exc) {\r\n            logger.warn(\"Could not respond to a non-supported method \" + request.getMethod(), exc);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.MasterPasswordInputDialog.actionPerformed",
	"Comment": "ok button click event handler. retrieves the password and hides thedialog.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    JButton sourceButton = (JButton) e.getSource();\r\n    if (sourceButton.equals(okButton)) {\r\n        password = new String(currentPasswdField.getPassword());\r\n    }\r\n    dialog.dispose();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.DynamicPayloadTypeRegistry.getMappingOverrides",
	"Comment": "returns a copy of all mapping overridescurrently registered in thisregistry.",
	"Method": "Map<Byte, Byte> getMappingOverrides(){\r\n    return new HashMap<Byte, Byte>(payloadTypeOverrides);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.colibri.ColibriConferenceIQ.isGracefulShutdown",
	"Comment": "returns true if graceful shutdown status info is indicated inthis colibriconferenceiq instance.",
	"Method": "boolean isGracefulShutdown(){\r\n    return gracefulShutdown;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.geolocation.event.LocalPositionChangeEvent.toString",
	"Comment": "returns a string representation of this localpositionchangeevent",
	"Method": "String toString(){\r\n    StringBuffer buff = new StringBuffer(\"LocalPositionChangeEvent-[\");\r\n    return buff.append(\"OldPosition=\").append(getOldGeolocation()).append(\", NewPosition=\").append(getNewGeolocation()).append(\"]\").toString();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactListServiceImpl.serviceChanged",
	"Comment": "implements the servicelistener method. verifies whether thepassed event concerns a protocolproviderservice and modifiesthe list of registered protocol providers accordingly.",
	"Method": "void serviceChanged(ServiceEvent event){\r\n    Object sService = bundleContext.getService(event.getServiceReference());\r\n    if (logger.isTraceEnabled())\r\n        logger.trace(\"Received a service event for: \" + sService.getClass().getName());\r\n    if (!(sService instanceof ProtocolProviderService)) {\r\n        return;\r\n    }\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Service is a protocol provider.\");\r\n    ProtocolProviderService provider = (ProtocolProviderService) sService;\r\n    ProtocolProviderFactory sourceFactory = null;\r\n    ServiceReference<?>[] allBundleServices = event.getServiceReference().getBundle().getRegisteredServices();\r\n    for (ServiceReference<?> bundleServiceRef : allBundleServices) {\r\n        Object service = bundleContext.getService(bundleServiceRef);\r\n        if (service instanceof ProtocolProviderFactory) {\r\n            sourceFactory = (ProtocolProviderFactory) service;\r\n            break;\r\n        }\r\n    }\r\n    if (event.getType() == ServiceEvent.REGISTERED) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Handling registration of a new Protocol Provider.\");\r\n        String providerMask = System.getProperty(MetaContactListService.PROVIDER_MASK_PROPERTY);\r\n        if (providerMask != null && providerMask.trim().length() > 0) {\r\n            String servRefMask = (String) event.getServiceReference().getProperty(MetaContactListService.PROVIDER_MASK_PROPERTY);\r\n            if (servRefMask == null || !servRefMask.equals(providerMask)) {\r\n                if (logger.isDebugEnabled())\r\n                    logger.debug(\"Ignoing masked provider: \" + provider.getAccountID());\r\n                return;\r\n            }\r\n        }\r\n        if (sourceFactory != null && currentlyInstalledProviders.containsKey(provider.getAccountID().getAccountUniqueID())) {\r\n            if (logger.isDebugEnabled())\r\n                logger.debug(\"An already installed account: \" + provider.getAccountID() + \". Modifying it.\");\r\n        }\r\n        this.handleProviderAdded((ProtocolProviderService) sService);\r\n    } else if (event.getType() == ServiceEvent.UNREGISTERING) {\r\n        if (sourceFactory == null) {\r\n            return;\r\n        }\r\n        AccountID accountID = provider.getAccountID();\r\n        if (ContactlistActivator.getAccountManager().getStoredAccounts().contains(accountID)) {\r\n            synchronized (this) {\r\n                this.removeMetaContactListListener(storageManager);\r\n                this.handleProviderRemoved((ProtocolProviderService) sService);\r\n                this.addMetaContactListListener(storageManager);\r\n            }\r\n            return;\r\n        }\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Account uninstalled. acc.id=\" + provider.getAccountID() + \". Removing from meta \" + \"contact list.\");\r\n        this.handleProviderRemoved((ProtocolProviderService) sService);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.pluginmanager.NewBundleDialog.close",
	"Comment": "presses programatically the cancel button, when esc key is pressed.",
	"Method": "void close(boolean isEscaped){\r\n    cancelButton.doClick();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaAwareCallPeer.getMediaHandler",
	"Comment": "returns a reference to the callpeermediahandler used by thispeer. the media handler class handles all media management for a singlecallpeer. this includes initializing and configuring streams,generating sdp, handling ice, etc. one instance of callpeeralways corresponds to exactly one instance ofcallpeermediahandler and both classes are only separated forreasons of readability.",
	"Method": "U getMediaHandler(){\r\n    return mediaHandler;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.ippiaccregwizz.IppiAccountRegistrationWizard.getCreateAccountService",
	"Comment": "returns an instance of createaccountservice through which theuser could create an account. this method is meant to be implemented byspecific protocol provider wizards.",
	"Method": "SIPAccountCreationFormService getCreateAccountService(){\r\n    return createAccountForm;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.IceUdpTransportManager.propertyChange",
	"Comment": "retransmit state change events from the agent to the media handler.",
	"Method": "void propertyChange(PropertyChangeEvent evt){\r\n    getCallPeer().getMediaHandler().firePropertyChange(evt.getPropertyName(), evt.getOldValue(), evt.getNewValue());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ContactSipImpl.setPresenceStatus",
	"Comment": "sets sippresencestatus as the presencestatus that thiscontact is currently in.",
	"Method": "void setPresenceStatus(PresenceStatus sipPresenceStatus){\r\n    this.presenceStatus = sipPresenceStatus;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler.setCsrcAudioLevelListener",
	"Comment": "sets csrcaudiolevellistener as the listener that will bereceiving notifications for changes in the audio levels of the remoteparticipants that our peer is mixing.",
	"Method": "void setCsrcAudioLevelListener(CsrcAudioLevelListener listener){\r\n    synchronized (csrcAudioLevelListenerLock) {\r\n        if (this.csrcAudioLevelListener != listener) {\r\n            MediaHandler mediaHandler = getMediaHandler();\r\n            if ((mediaHandler != null) && (this.csrcAudioLevelListener != null)) {\r\n                mediaHandler.removeCsrcAudioLevelListener(this.csrcAudioLevelListener);\r\n            }\r\n            this.csrcAudioLevelListener = listener;\r\n            if ((mediaHandler != null) && (this.csrcAudioLevelListener != null)) {\r\n                mediaHandler.addCsrcAudioLevelListener(this.csrcAudioLevelListener);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.librec.data.model.ArffDataModelTestCase.getDataSize",
	"Comment": "returns the size of preference matrix of a specified datamodel object",
	"Method": "int getDataSize(DataModel dataModel){\r\n    int sum = 0;\r\n    int train = getTrainSize(dataModel);\r\n    int test = getTestSize(dataModel);\r\n    if (null != dataModel.getDataSplitter().getValidData()) {\r\n        int valid = getValidSize(dataModel);\r\n        sum += valid;\r\n    }\r\n    sum = sum + train + test;\r\n    return sum;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.AnimatedImage.getImagesCount",
	"Comment": "returns the number of images that are contained in the animation",
	"Method": "int getImagesCount(){\r\n    return images.size();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.PayloadTypePacketExtension.setChannels",
	"Comment": "sets the number of channels in this payload type. if omitted, it will beassumed to contain one channel.",
	"Method": "void setChannels(int channels){\r\n    super.setAttribute(CHANNELS_ATTR_NAME, channels);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ChooseUIContactDetailPopupMenu.addContactDetailItem",
	"Comment": "adds the given telephonycontact to the list of availabletelephony contact.",
	"Method": "void addContactDetailItem(UIContactDetailImpl contactDetail,UIContactDetailAction contactDetailAction){\r\n    final ContactMenuItem contactItem = new ContactMenuItem(contactDetail);\r\n    contactItem.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent e) {\r\n            contactDetailAction.actionPerformed(contactDetail, getX(), getY());\r\n            ChooseUIContactDetailPopupMenu.this.setVisible(false);\r\n        }\r\n    });\r\n    add(contactItem);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ChooseUIContactDetailPopupMenu.addContactDetailItem",
	"Comment": "adds the given telephonycontact to the list of availabletelephony contact.",
	"Method": "void addContactDetailItem(UIContactDetailImpl contactDetail,UIContactDetailAction contactDetailAction){\r\n    contactDetailAction.actionPerformed(contactDetail, getX(), getY());\r\n    ChooseUIContactDetailPopupMenu.this.setVisible(false);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.MetaContactChatTransport.allowsFileTransfer",
	"Comment": "returns true if this chat transport supports file transfer,otherwise returns false.",
	"Method": "boolean allowsFileTransfer(){\r\n    Object ftOpSet = contact.getProtocolProvider().getOperationSet(OperationSetFileTransfer.class);\r\n    if (ftOpSet != null)\r\n        return true;\r\n    else\r\n        return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.sipaccregwizz.FirstWizardPage.loadAccount",
	"Comment": "fills the uin and password fields in this panel with the data coming fromthe given protocolprovider.",
	"Method": "void loadAccount(ProtocolProviderService protocolProvider){\r\n    registrationForm.setModification(wizard.isModification());\r\n    registrationForm.loadAccount(wizard.getRegistration());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.utils.InviteContactTransferHandler.canImport",
	"Comment": "indicates whether a component will accept an import of the givenset of data flavors prior to actually attempting to import it. we returntrue to indicate that the transfer with at least one of thegiven flavors would work and false to reject the transfer.",
	"Method": "boolean canImport(JComponent comp,DataFlavor flavor){\r\n    if (type != DEST_TRANSFER_HANDLER)\r\n        return false;\r\n    for (int i = 0, n = flavor.length; i < n; i++) {\r\n        if (flavor[i].equals(uiContactDataFlavor)) {\r\n            if (comp instanceof ContactList) {\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.googlecontacts.GoogleContactsActivator.getGoogleContactsService",
	"Comment": "returns a reference to a googlecontactsservice implementation currentlyregistered in the bundle context or null if no such implementation wasfound.",
	"Method": "GoogleContactsServiceImpl getGoogleContactsService(){\r\n    return googleContactsService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetVideoTelephonySipImpl.answerVideoCallPeer",
	"Comment": "indicates a user request to answer an incoming call with video enabledfrom the specified callpeer.",
	"Method": "void answerVideoCallPeer(CallPeer peer){\r\n    CallPeerSipImpl callPeer = (CallPeerSipImpl) peer;\r\n    callPeer.getCall().setLocalVideoAllowed(true, getMediaUseCase());\r\n    callPeer.answer();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.UIServiceImpl.getAccountRegWizardContainer",
	"Comment": "implements the uiservice.getaccountregwizardcontainermethod. returns the current implementation of theaccountregistrationwizardcontainer.",
	"Method": "WizardContainer getAccountRegWizardContainer(){\r\n    return this.wizardContainer;\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.common.io.FrameFlusherTest.testLargeSmallText",
	"Comment": "ensure that frameflusher honors the correct order of websocket frames.",
	"Method": "void testLargeSmallText(){\r\n    WebSocketPolicy policy = WebSocketPolicy.newServerPolicy();\r\n    Generator generator = new Generator(policy, bufferPool);\r\n    SaneFrameOrderingEndPoint endPoint = new SaneFrameOrderingEndPoint(WebSocketPolicy.newClientPolicy(), bufferPool);\r\n    int bufferSize = policy.getMaxBinaryMessageBufferSize();\r\n    int maxGather = 8;\r\n    FrameFlusher frameFlusher = new FrameFlusher(bufferPool, generator, endPoint, bufferSize, maxGather);\r\n    int largeMessageSize = 60000;\r\n    byte[] buf = new byte[largeMessageSize];\r\n    Arrays.fill(buf, (byte) 'x');\r\n    String largeMessage = new String(buf, UTF_8);\r\n    int messageCount = 10000;\r\n    BatchMode batchMode = BatchMode.OFF;\r\n    CompletableFuture<Void> serverTask = new CompletableFuture();\r\n    CompletableFuture.runAsync(() -> {\r\n        try {\r\n            for (int i = 0; i < messageCount; i++) {\r\n                FutureWriteCallback callback = new FutureWriteCallback();\r\n                WebSocketFrame frame;\r\n                if (i % 2 == 0)\r\n                    frame = new TextFrame().setPayload(largeMessage);\r\n                else\r\n                    frame = new TextFrame().setPayload(\"Short Message: \" + i);\r\n                frameFlusher.enqueue(frame, callback, batchMode);\r\n                callback.get();\r\n            }\r\n        } catch (Throwable t) {\r\n            serverTask.completeExceptionally(t);\r\n        }\r\n        serverTask.complete(null);\r\n    });\r\n    serverTask.get();\r\n    System.out.printf(\"Received: %,d frames / %,d errors%n\", endPoint.incomingFrames, endPoint.incomingErrors);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.plaf.SearchFieldUI.mouseEntered",
	"Comment": "updates the call button when the mouse is enters the component area.",
	"Method": "void mouseEntered(MouseEvent e){\r\n    super.mouseEntered(e);\r\n    if (isCallButtonEnabled || isSMSButtonEnabled)\r\n        updateIcon(e);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.MainFrame.initPluginComponents",
	"Comment": "initialize plugin components already registered for this container.",
	"Method": "void initPluginComponents(){\r\n    pluginPanelSouth.setLayout(new BoxLayout(pluginPanelSouth, BoxLayout.Y_AXIS));\r\n    pluginPanelNorth.setLayout(new BoxLayout(pluginPanelNorth, BoxLayout.Y_AXIS));\r\n    pluginPanelEast.setLayout(new BoxLayout(pluginPanelEast, BoxLayout.Y_AXIS));\r\n    pluginPanelWest.setLayout(new BoxLayout(pluginPanelWest, BoxLayout.Y_AXIS));\r\n    java.awt.Container contentPane = getContentPane();\r\n    contentPane.add(pluginPanelNorth, BorderLayout.NORTH);\r\n    contentPane.add(pluginPanelEast, BorderLayout.EAST);\r\n    contentPane.add(pluginPanelWest, BorderLayout.WEST);\r\n    this.mainPanel.add(pluginPanelSouth, BorderLayout.SOUTH);\r\n    Collection<ServiceReference<PluginComponentFactory>> serRefs;\r\n    try {\r\n        serRefs = GuiActivator.bundleContext.getServiceReferences(PluginComponentFactory.class, \"(|(\" + Container.CONTAINER_ID + \"=\" + Container.CONTAINER_MAIN_WINDOW.getID() + \")(\" + Container.CONTAINER_ID + \"=\" + Container.CONTAINER_STATUS_BAR.getID() + \"))\");\r\n    } catch (InvalidSyntaxException exc) {\r\n        serRefs = null;\r\n        logger.error(\"Could not obtain plugin reference.\", exc);\r\n    }\r\n    if ((serRefs != null) && !serRefs.isEmpty()) {\r\n        for (ServiceReference<PluginComponentFactory> serRef : serRefs) {\r\n            PluginComponentFactory factory = GuiActivator.bundleContext.getService(serRef);\r\n            if (factory.isNativeComponent())\r\n                nativePluginsTable.add(factory);\r\n            else {\r\n                String pluginConstraints = factory.getConstraints();\r\n                Object constraints;\r\n                if (pluginConstraints != null)\r\n                    constraints = UIServiceImpl.getBorderLayoutConstraintsFromContainer(pluginConstraints);\r\n                else\r\n                    constraints = BorderLayout.SOUTH;\r\n                this.addPluginComponent((Component) factory.getPluginComponentInstance(this).getComponent(), factory.getContainer(), constraints);\r\n            }\r\n        }\r\n    }\r\n    GuiActivator.getUIService().addPluginComponentListener(this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.ExtendedTransferHandler.getSelectedTextFromComponent",
	"Comment": "gets the selected text and if the text is html replaces the images withthe content in alt attribute.",
	"Method": "String getSelectedTextFromComponent(JTextComponent textComponent){\r\n    String srcData = null;\r\n    int startIndex = textComponent.getSelectionStart();\r\n    int endIndex = textComponent.getSelectionEnd();\r\n    if (startIndex != endIndex) {\r\n        Document doc = textComponent.getDocument();\r\n        int selectionLength = endIndex - startIndex;\r\n        try {\r\n            if (textComponent instanceof JTextPane) {\r\n                JTextPane textPaneComponent = (JTextPane) textComponent;\r\n                StringWriter stringWriter = new StringWriter();\r\n                textPaneComponent.getEditorKit().write(stringWriter, doc, startIndex, selectionLength);\r\n                String data = stringWriter.toString();\r\n                String smileyHtmlPattern = \"<\\\\s*[iI][mM][gG](.*?)\" + \"[aA][lL][tT]\\\\s*=\\\\s*[\\\\\\\"']([^\\\\\\\"]*)\" + \"[\\\\\\\"'](.*?)>\";\r\n                Pattern p = Pattern.compile(smileyHtmlPattern, Pattern.DOTALL);\r\n                Matcher m = p.matcher(data);\r\n                boolean hasImg = m.find();\r\n                Pattern pMsgHeader = Pattern.compile(\"<\\\\s*h\\\\d.*?id=['\\\"]messageHeader['\\\"]\", Pattern.DOTALL | Pattern.CASE_INSENSITIVE);\r\n                Matcher mMsgHeader = pMsgHeader.matcher(data);\r\n                boolean hasMsgHeader = mMsgHeader.find();\r\n                if (hasImg || hasMsgHeader) {\r\n                    String tempData = \"\";\r\n                    if (hasImg) {\r\n                        int start = 0;\r\n                        do {\r\n                            tempData += data.substring(start, m.start()) + GuiUtils.escapeHTMLChars(m.group(2));\r\n                            start = m.end();\r\n                        } while (m.find());\r\n                        tempData += data.substring(start);\r\n                    } else {\r\n                        tempData = data;\r\n                    }\r\n                    tempData = tempData.replaceAll(\"<[/]*PLAINTEXT>.*<[/]*PLAINTEXT>\", \"\");\r\n                    tempData = tempData.replaceAll(\"<\\\\s*[bB][rR][^>]*>\", \"<a><\/a>\");\r\n                    if (hasMsgHeader) {\r\n                        tempData = tempData.replaceAll(\"<[/]*\\\\s*([tT][aA][bB][lL][eE]|[tT][rR]\" + \"|[tT][dD]|[hH]\\\\d)[^>]*?>\", \"\");\r\n                    }\r\n                    htmlDoc.remove(0, htmlDoc.getLength());\r\n                    htmlKit.read(new StringReader(tempData), htmlDoc, 0);\r\n                    srcData = htmlDoc.getText(0, htmlDoc.getLength());\r\n                }\r\n            }\r\n            if (srcData == null) {\r\n                srcData = doc.getText(startIndex, selectionLength);\r\n            }\r\n        } catch (BadLocationException ble) {\r\n        } catch (IOException ioe) {\r\n        }\r\n    }\r\n    return srcData;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetBasicInstantMessagingIcqImpl.sendInstantMessage",
	"Comment": "sends the message to the destination indicated by theto contact.",
	"Method": "void sendInstantMessage(Contact to,Message message){\r\n    assertConnected();\r\n    if (!(to instanceof ContactIcqImpl))\r\n        throw new IllegalArgumentException(\"The specified contact is not a Icq contact.\" + to);\r\n    ImConversation imConversation = icqProvider.getAimConnection().getIcbmService().getImConversation(new Screenname(to.getAddress()));\r\n    String messageContent;\r\n    if (message.getContentType().equals(HTML_MIME_TYPE) && !message.getContent().startsWith(HTML_START_TAG))\r\n        messageContent = HTML_START_TAG + message.getContent() + HTML_END_TAG;\r\n    else\r\n        messageContent = message.getContent();\r\n    MessageDeliveredEvent msgDeliveryPendingEvt = new MessageDeliveredEvent(message, to);\r\n    MessageDeliveredEvent[] msgDeliveryPendingEvts = this.messageDeliveryPendingTransform(msgDeliveryPendingEvt);\r\n    if (msgDeliveryPendingEvts == null || msgDeliveryPendingEvts.length == 0)\r\n        return;\r\n    for (MessageDeliveredEvent pendingEvt : msgDeliveryPendingEvts) {\r\n        String transformedContent = pendingEvt.getSourceMessage().getContent();\r\n        if (to.getPresenceStatus().isOnline()) {\r\n            imConversation.sendMessage(new SimpleMessage(transformedContent));\r\n        } else\r\n            imConversation.sendMessage(new SimpleMessage(transformedContent), true);\r\n        MessageDeliveredEvent msgDeliveredEvt = new MessageDeliveredEvent(message, to);\r\n        if (msgDeliveredEvt != null)\r\n            fireMessageEvent(msgDeliveredEvt);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ServerStoredContactListJabberImpl.init",
	"Comment": "sets a reference to the currently active and valid instance ofroster that this list is to use for retrievingserver stored information",
	"Method": "void init(OperationSetPersistentPresenceJabberImpl.ContactChangesListener presenceChangeListener){\r\n    this.roster = jabberProvider.getConnection().getRoster();\r\n    presenceChangeListener.storeEvents();\r\n    this.roster.addRosterListener(presenceChangeListener);\r\n    this.roster.setSubscriptionMode(Roster.SubscriptionMode.manual);\r\n    initRoster();\r\n    synchronized (rosterInitLock) {\r\n        this.isRosterInitialized = true;\r\n    }\r\n    sendInitialStatus();\r\n    presenceChangeListener.processStoredEvents();\r\n    rosterChangeListener = new ChangeListener();\r\n    this.roster.addRosterListener(rosterChangeListener);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl.createOffer",
	"Comment": "creates a session description string representing themediastreams that this mediahandler is prepared toexchange. the offer takes into account user preferences such as whetheror not local user would be transmitting video, whether any or all streamsare put on hold, etc. the method is also taking into account any previousoffers that this handler may have previously issues hence making thenewly generated string an session creation or a session updateoffer accordingly.",
	"Method": "String createOffer(){\r\n    SessionDescription offer = (localSess == null) ? createFirstOffer() : createUpdateOffer(localSess);\r\n    if (getConfigurationService().getBoolean(ProtocolProviderServiceSipImpl.USE_SESSION_LEVEL_DIRECTION_IN_SDP, false)) {\r\n        SdpUtils.setSessionDirection(offer);\r\n    }\r\n    return offer.toString();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.GenericUIContactImpl.getSearchStrings",
	"Comment": "returns an iterator over a list of the search strings of thiscontact.",
	"Method": "Iterator<String> getSearchStrings(){\r\n    return searchStrings.iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.netaddr.NetworkEventDispatcher.stop",
	"Comment": "interrupts this dispatcher so that it would no longer disptach events.",
	"Method": "void stop(){\r\n    synchronized (eventsToDispatch) {\r\n        stopped = true;\r\n        eventsToDispatch.notifyAll();\r\n        dispatcherThread = null;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.FileTransferImpl.getID",
	"Comment": "uniquie id that is identifying the filetransferif the request has been accepted.",
	"Method": "String getID(){\r\n    return id;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactListServiceImpl.synchronizeOpSetWithLocalContactList",
	"Comment": "goes through the server stored contactlist of the specified operationset, retrieves all protocol specific contacts it contains and makes surethey are all present in the local contact list.",
	"Method": "void synchronizeOpSetWithLocalContactList(OperationSetPersistentPresence presenceOpSet){\r\n    ContactGroup rootProtoGroup = presenceOpSet.getServerStoredContactListRoot();\r\n    if (rootProtoGroup != null) {\r\n        if (logger.isTraceEnabled())\r\n            logger.trace(\"subgroups: \" + rootProtoGroup.countSubgroups());\r\n        if (logger.isTraceEnabled())\r\n            logger.trace(\"child contacts: \" + rootProtoGroup.countContacts());\r\n        addContactGroupToMetaGroup(rootProtoGroup, rootMetaGroup, true);\r\n    }\r\n    presenceOpSet.addSubscriptionListener(clSubscriptionEventHandler);\r\n    presenceOpSet.addServerStoredGroupChangeListener(clGroupEventHandler);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.ProtocolIconGibberishImpl.getImageInBytes",
	"Comment": "returns the byte representation of the image corresponding to the givenidentifier.",
	"Method": "byte[] getImageInBytes(String imageID){\r\n    InputStream in = getResources().getImageInputStream(imageID);\r\n    if (in == null)\r\n        return null;\r\n    byte[] image = null;\r\n    try {\r\n        image = new byte[in.available()];\r\n        in.read(image);\r\n    } catch (IOException e) {\r\n        logger.error(\"Failed to load image:\" + imageID, e);\r\n    }\r\n    return image;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.account.LoginManager.addAccountsForProtocolProviderFactory",
	"Comment": "handles stored accounts for a protocol provider factory and add themto the ui and register them if needed.",
	"Method": "void addAccountsForProtocolProviderFactory(ProtocolProviderFactory providerFactory){\r\n    for (AccountID accountID : providerFactory.getRegisteredAccounts()) {\r\n        ServiceReference<ProtocolProviderService> serRef = providerFactory.getProviderForAccount(accountID);\r\n        ProtocolProviderService protocolProvider = UtilActivator.bundleContext.getService(serRef);\r\n        handleProviderAdded(protocolProvider);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.JabberActivator.getHIDService",
	"Comment": "returns a reference to hidservice implementation currentlyregistered in the bundle context or null if no such implementation wasfound",
	"Method": "HIDService getHIDService(){\r\n    if (hidService == null) {\r\n        ServiceReference hidReference = bundleContext.getServiceReference(HIDService.class.getName());\r\n        if (hidReference == null)\r\n            return null;\r\n        hidService = (HIDService) bundleContext.getService(hidReference);\r\n    }\r\n    return hidService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.UIServiceImpl.getExportedWindow",
	"Comment": "implements the getexportedwindow in the uiserviceinterface. returns the window corresponding to the givenwindowid.",
	"Method": "ExportedWindow getExportedWindow(WindowID windowID,Object[] params,ExportedWindow getExportedWindow,WindowID windowID){\r\n    return getExportedWindow(windowID, null);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.WhiteboardSessionJabberImpl.getProtocolProvider",
	"Comment": "returns a reference to the protocolproviderservice instancethat created this whiteboard.",
	"Method": "ProtocolProviderService getProtocolProvider(){\r\n    return this.jabberProvider;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.CallPeerMediaHandlerJabberImpl.firePropertyChange",
	"Comment": "overrides to give access to the transport manager to send eventsabout ice state changes.",
	"Method": "void firePropertyChange(String property,Object oldValue,Object newValue){\r\n    super.firePropertyChange(property, oldValue, newValue);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.SmackV3InteroperabilityLayer.getExtensionProvider",
	"Comment": "get the packetextensionprovider for given element name and xml namespace",
	"Method": "PacketExtensionProvider getExtensionProvider(String elementName,String namespace){\r\n    return (PacketExtensionProvider) providerManager.getExtensionProvider(elementName, namespace);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.TreeContactList.setAutoSectionAllowed",
	"Comment": "sets the value of auto selection flag. if true when contact isreceived the first contact in the contact list will be automaticallyselected.",
	"Method": "void setAutoSectionAllowed(boolean value){\r\n    synchronized (setAutoSelectionAllowed) {\r\n        setAutoSelectionAllowed = value;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.IrcStatusEnum.getImageInBytes",
	"Comment": "returns the byte representation of the image corresponding to the givenidentifier.",
	"Method": "byte[] getImageInBytes(String imageID){\r\n    return ProtocolIconIrcImpl.getImageInBytes(imageID);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.GuiActivator.getBrowserLauncher",
	"Comment": "returns the browserlauncherservice obtained from the bundlecontext.",
	"Method": "BrowserLauncherService getBrowserLauncher(){\r\n    if (browserLauncherService == null) {\r\n        browserLauncherService = ServiceUtils.getService(bundleContext, BrowserLauncherService.class);\r\n    }\r\n    return browserLauncherService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ServerStoredContactListJabberImpl.createUnresolvedContact",
	"Comment": "creates a non resolved contact for the specified address and inside thespecified group. the newly created contact would be added to the localcontact list as a standard contact but when an event is received from theserver concerning this contact, then it will be reused and only itsisresolved field would be updated instead of creating the whole contactagain.",
	"Method": "ContactJabberImpl createUnresolvedContact(ContactGroup parentGroup,String id){\r\n    String completeID = parseAddressString(id);\r\n    ContactJabberImpl existingContact = findContactById(completeID);\r\n    if (existingContact != null) {\r\n        return existingContact;\r\n    }\r\n    ContactJabberImpl newUnresolvedContact = new ContactJabberImpl(id, this, true);\r\n    if (parentGroup instanceof ContactGroupJabberImpl)\r\n        ((ContactGroupJabberImpl) parentGroup).addContact(newUnresolvedContact);\r\n    else if (parentGroup instanceof RootContactGroupJabberImpl)\r\n        ((RootContactGroupJabberImpl) parentGroup).addContact(newUnresolvedContact);\r\n    fireContactAdded(parentGroup, newUnresolvedContact);\r\n    return newUnresolvedContact;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.FTPUtils.parseUrl",
	"Comment": "parses the url to host, port, user, password and path to the file parts.",
	"Method": "void parseUrl(String urlString){\r\n    URL url = new URL(urlString);\r\n    host = url.getHost();\r\n    port = url.getPort();\r\n    if (port == -1) {\r\n        port = DEFAULT_PORT;\r\n    }\r\n    String tmpUserInfo = url.getUserInfo();\r\n    if (tmpUserInfo != null) {\r\n        int separatorIdx = tmpUserInfo.lastIndexOf(':');\r\n        if (separatorIdx != -1) {\r\n            pass = tmpUserInfo.substring(separatorIdx + 1);\r\n            user = tmpUserInfo.substring(0, separatorIdx);\r\n        }\r\n    }\r\n    if (user == null) {\r\n        user = \"anonymus\";\r\n    }\r\n    if (pass == null) {\r\n        pass = \"anonymus\";\r\n    }\r\n    path = url.getPath();\r\n    if (path == \"\") {\r\n        throw new Exception(\"Not available path.\");\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MclStorageManager.protoContactMoved",
	"Comment": "indicates that a protocol specific contact instance has beenmoved from within one metacontact to another.",
	"Method": "void protoContactMoved(ProtoContactEvent evt){\r\n    Element newMcNode = findMetaContactNode(evt.getNewParent().getMetaUID());\r\n    Element oldMcNode = findMetaContactNode(evt.getOldParent().getMetaUID());\r\n    if (oldMcNode == null) {\r\n        logger.error(\"Failed to find meta contact (old parent): \" + oldMcNode);\r\n        return;\r\n    }\r\n    if (newMcNode == null) {\r\n        logger.error(\"Failed to find meta contact (old parent): \" + newMcNode);\r\n        return;\r\n    }\r\n    Element protoNode = XMLUtils.locateElement(oldMcNode, PROTO_CONTACT_NODE_NAME, PROTO_CONTACT_ADDRESS_ATTR_NAME, evt.getProtoContact().getAddress());\r\n    protoNode.getParentNode().removeChild(protoNode);\r\n    protoNode.setAttribute(PARENT_PROTO_GROUP_UID_ATTR_NAME, evt.getProtoContact().getParentContactGroup().getUID());\r\n    newMcNode.appendChild(protoNode);\r\n    try {\r\n        scheduleContactListStorage();\r\n    } catch (IOException ex) {\r\n        logger.error(\"Writing CL failed after moving proto contact \" + evt.getProtoContact(), ex);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.DesktopSharingMouseAndKeyboardListener.setVideoComponent",
	"Comment": "sets the video displaying component for the streamed remote desktop.",
	"Method": "void setVideoComponent(Component videoComponent){\r\n    if (desktopSharingClient == null)\r\n        return;\r\n    synchronized (videoComponentMutex) {\r\n        if (this.videoComponent == null) {\r\n            if (videoComponent != null)\r\n                desktopSharingClient.addRemoteControlListener(this);\r\n        } else {\r\n            if (videoComponent == null) {\r\n                desktopSharingClient.removeRemoteControlListener(this);\r\n            }\r\n        }\r\n        this.videoComponent = videoComponent;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl.processUpdateOffer",
	"Comment": "parses, handles newoffer, and produces an update answerrepresenting the current state of this mediahandler.",
	"Method": "SessionDescription processUpdateOffer(SessionDescription newOffer,SessionDescription previousAnswer){\r\n    List<MediaDescription> answerDescriptions = createMediaDescriptionsForAnswer(newOffer);\r\n    SessionDescription newAnswer = SdpUtils.createSessionUpdateDescription(previousAnswer, getTransportManager().getLastUsedLocalHost(), answerDescriptions);\r\n    this.localSess = newAnswer;\r\n    return localSess;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.version.VersionImpl.getPreReleaseID",
	"Comment": "returns the version prerelease id of the current jitsi versionand null if this version is not a prerelease.",
	"Method": "String getPreReleaseID(){\r\n    if (!isPreRelease())\r\n        return null;\r\n    return PRE_RELEASE_ID;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.UriHandlerJabberImpl.promptForRegistration",
	"Comment": "informs the user that they need to be registered before chatting andasks them whether they would like us to do it for them.",
	"Method": "void promptForRegistration(String uri,ProtocolProviderService provider){\r\n    int answer = JabberActivator.getUIService().getPopupDialog().showConfirmPopupDialog(\"You need to be online in order to chat and\" + \" your account is currently offline. Do\" + \" you want to connect now?\", \"Account is currently offline\", PopupDialog.YES_NO_OPTION);\r\n    if (answer == PopupDialog.YES_OPTION)\r\n        new ProtocolRegistrationThread(uri, provider).start();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.whiteboard.gui.whiteboardshapes.WhiteboardShapePolygon.setPoints",
	"Comment": "sets the list of whiteboardpoint instances that thiswhiteboardobject is composed of.",
	"Method": "void setPoints(List<WhiteboardPoint> points){\r\n    this.points = new ArrayList<WhiteboardPoint>(points);\r\n}"
}, {
	"Path": "design.RandomizedCollection.insert",
	"Comment": "inserts a value to the collection. returns true if the collection did not already contain the specified element.",
	"Method": "boolean insert(int val){\r\n    boolean status = map.containsKey(val);\r\n    Set<Integer> set = map.get(val);\r\n    if (set == null) {\r\n        set = new HashSet();\r\n        map.put(val, set);\r\n    }\r\n    list.add(val);\r\n    set.add(list.size() - 1);\r\n    return !status;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.whiteboard.WhiteboardActivator.getWhiteboardOperationSets",
	"Comment": "returns all operationsetwhiteboardings obtained from the bundlecontext.",
	"Method": "List<OperationSetWhiteboarding> getWhiteboardOperationSets(){\r\n    List<OperationSetWhiteboarding> whiteboardOpSets = new ArrayList<OperationSetWhiteboarding>();\r\n    ServiceReference[] serRefs = null;\r\n    try {\r\n        serRefs = bundleContext.getServiceReferences(ProtocolProviderService.class.getName(), null);\r\n    } catch (InvalidSyntaxException e) {\r\n        logger.error(\"Failed to obtain protocol provider service refs: \" + e);\r\n    }\r\n    if (serRefs == null)\r\n        return null;\r\n    for (ServiceReference serRef : serRefs) {\r\n        ProtocolProviderService protocolProvider = (ProtocolProviderService) bundleContext.getService(serRef);\r\n        OperationSetWhiteboarding opSet = protocolProvider.getOperationSet(OperationSetWhiteboarding.class);\r\n        if (opSet != null)\r\n            whiteboardOpSets.add(opSet);\r\n    }\r\n    return whiteboardOpSets;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.MUCServiceImpl.removeChatRoomProviderWrapperListener",
	"Comment": "removes the chatroomproviderwrapperlistener to the listener list.",
	"Method": "void removeChatRoomProviderWrapperListener(ChatRoomProviderWrapperListener listener){\r\n    chatRoomList.removeChatRoomProviderWrapperListener(listener);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.RootContactGroupIcqImpl.getContact",
	"Comment": "returns the contact with the specified address oridentifier.",
	"Method": "Contact getContact(String id){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.event.PluginComponentEvent.getPluginComponentFactory",
	"Comment": "returns the plugincomponentfactory associated with this event.",
	"Method": "PluginComponentFactory getPluginComponentFactory(){\r\n    return (PluginComponentFactory) getSource();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.AccountStatusPanel.stopConnecting",
	"Comment": "stops connecting user interface for the given protocolprovider.",
	"Method": "void stopConnecting(ProtocolProviderService protocolProvider){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                stopConnecting(protocolProvider);\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    statusComboBox.stopConnecting(protocolProvider);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.AccountStatusPanel.stopConnecting",
	"Comment": "stops connecting user interface for the given protocolprovider.",
	"Method": "void stopConnecting(ProtocolProviderService protocolProvider){\r\n    stopConnecting(protocolProvider);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.GenericUIContactImpl.getContactDetailsForOperationSet",
	"Comment": "returns a list of all uicontactdetails corresponding to thegiven operationset class.",
	"Method": "List<UIContactDetail> getContactDetailsForOperationSet(Class<? extends OperationSet> opSetClass){\r\n    return contactDetails.get(opSetClass);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockContactGroup.contacts",
	"Comment": "returns an iterator over all contacts, member of thiscontactgroup.",
	"Method": "Iterator<Contact> contacts(){\r\n    return contacts.iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.AdHocConferenceChatTransport.allowsInstantMessage",
	"Comment": "returns true if this chat transport supports instantmessaging, otherwise returns false.",
	"Method": "boolean allowsInstantMessage(){\r\n    return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.CallJabberImpl.createColibriStreamConnector",
	"Comment": "initializes a colibristreamconnector on behalf of a specificcallpeer to be used in association with a specificcolibriconferenceiq.channel of a specific mediatype.",
	"Method": "ColibriStreamConnector createColibriStreamConnector(CallPeerJabberImpl peer,MediaType mediaType,ColibriConferenceIQ.Channel channel,StreamConnectorFactory factory){\r\n    String channelID = channel.getID();\r\n    if (channelID == null)\r\n        throw new IllegalArgumentException(\"channel\");\r\n    if (colibri == null)\r\n        throw new IllegalStateException(\"colibri\");\r\n    ColibriConferenceIQ.Content content = colibri.getContent(mediaType.toString());\r\n    if (content == null)\r\n        throw new IllegalArgumentException(\"mediaType\");\r\n    if ((content.getChannelCount() < 1) || !channelID.equals((channel = content.getChannel(0)).getID()))\r\n        throw new IllegalArgumentException(\"channel\");\r\n    ColibriStreamConnector colibriStreamConnector;\r\n    synchronized (colibriStreamConnectors) {\r\n        int index = mediaType.ordinal();\r\n        WeakReference<ColibriStreamConnector> weakReference = colibriStreamConnectors.get(index);\r\n        colibriStreamConnector = (weakReference == null) ? null : weakReference.get();\r\n        if (colibriStreamConnector == null) {\r\n            StreamConnector streamConnector = factory.createStreamConnector();\r\n            if (streamConnector != null) {\r\n                colibriStreamConnector = new ColibriStreamConnector(streamConnector);\r\n                colibriStreamConnectors.set(index, new WeakReference<ColibriStreamConnector>(colibriStreamConnector));\r\n            }\r\n        }\r\n    }\r\n    return colibriStreamConnector;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.Resources.getPropertyInputStream",
	"Comment": "returns the resource for the given key. this could be any resource storedin the resources.properties file of this bundle.",
	"Method": "InputStream getPropertyInputStream(String key){\r\n    return getResources().getSettingsInputStream(key, JabberAccRegWizzActivator.class);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.wizard.SecurityPanel.loadEncryptionProtocols",
	"Comment": "loads the list of enabled and disabled encryption protocols with theirpriority.",
	"Method": "void loadEncryptionProtocols(Map<String, Integer> encryptionProtocols,Map<String, Boolean> encryptionProtocolStatus){\r\n    Object[] result = SecurityAccountRegistration.loadEncryptionProtocols(encryptionProtocols, encryptionProtocolStatus);\r\n    String[] encryptions = (String[]) result[0];\r\n    boolean[] selectedEncryptions = (boolean[]) result[1];\r\n    this.encryptionConfigurationTableModel.init(encryptions, selectedEncryptions);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.ParameterPacketExtension.getName",
	"Comment": "returns the name of the format parameter we are representing here.",
	"Method": "String getName(){\r\n    return super.getAttributeAsString(NAME_ATTR_NAME);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.googlecontacts.GoogleContactsActivator.handleProviderAdded",
	"Comment": "notifies this manager that a specificprotocolproviderservice has been registered as a service.",
	"Method": "void handleProviderAdded(ProtocolProviderService provider){\r\n    new Thread(new Runnable() {\r\n        public void run() {\r\n            String className = provider.getClass().getName();\r\n            className = className.substring(0, className.lastIndexOf('.'));\r\n            String acc = ProtocolProviderFactory.findAccountPrefix(bundleContext, provider.getAccountID(), className);\r\n            if (configService.getBoolean(acc + \".GOOGLE_CONTACTS_ENABLED\", true)) {\r\n                enableContactSource(provider.getAccountID().getAccountAddress(), provider.getProtocolDisplayName().equals(\"Google Talk\"));\r\n            }\r\n        }\r\n    }).start();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.googlecontacts.GoogleContactsActivator.handleProviderAdded",
	"Comment": "notifies this manager that a specificprotocolproviderservice has been registered as a service.",
	"Method": "void handleProviderAdded(ProtocolProviderService provider){\r\n    String className = provider.getClass().getName();\r\n    className = className.substring(0, className.lastIndexOf('.'));\r\n    String acc = ProtocolProviderFactory.findAccountPrefix(bundleContext, provider.getAccountID(), className);\r\n    if (configService.getBoolean(acc + \".GOOGLE_CONTACTS_ENABLED\", true)) {\r\n        enableContactSource(provider.getAccountID().getAccountAddress(), provider.getProtocolDisplayName().equals(\"Google Talk\"));\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.googletalkaccregwizz.GoogleTalkAccountRegistrationWizard.getProtocolName",
	"Comment": "implements the accountregistrationwizard.getprotocolnamemethod. returns the protocol name for this wizard.",
	"Method": "String getProtocolName(){\r\n    return GoogleTalkAccRegWizzActivator.getResources().getI18NString(\"plugin.googletalkaccregwizz.PROTOCOL_NAME\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.conference.BasicConferenceCallPanel.addPeerViewlListener",
	"Comment": "adds new conferencepeerviewlistener listener if the listeneris not already added.",
	"Method": "void addPeerViewlListener(ConferencePeerViewListener listener){\r\n    if (!peerViewListeners.contains(listener))\r\n        peerViewListeners.add(listener);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ContactGroupJabberImpl.findContact",
	"Comment": "returns the contact encapsulating with the spcieified name ornull if no such contact was found.",
	"Method": "ContactJabberImpl findContact(String id){\r\n    if (id == null)\r\n        return null;\r\n    return (ContactJabberImpl) buddies.get(id.toLowerCase());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.MetaContactChatTransport.askForSMSNumber",
	"Comment": "whether a dialog need to be opened so the user can enter the destinationnumber.",
	"Method": "boolean askForSMSNumber(){\r\n    if (!allowsSmsMessage())\r\n        return false;\r\n    OperationSetSmsMessaging smsOpSet = contact.getProtocolProvider().getOperationSet(OperationSetSmsMessaging.class);\r\n    return smsOpSet.askForNumber(contact);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.netaddr.NetworkConfigurationWatcher.handleNewSystemActivityNotificationsService",
	"Comment": "saves the reference for the service andadd a listener if the desired events are supported. or startthe checking thread otherwise.",
	"Method": "void handleNewSystemActivityNotificationsService(SystemActivityNotificationsService newService){\r\n    if (newService == null)\r\n        return;\r\n    this.systemActivityNotificationsService = newService;\r\n    if (this.systemActivityNotificationsService.isSupported(SystemActivityEvent.EVENT_NETWORK_CHANGE)) {\r\n        this.systemActivityNotificationsService.addSystemActivityChangeListener(this);\r\n    } else {\r\n        if (!isRunning) {\r\n            isRunning = true;\r\n            Thread th = new Thread(this);\r\n            th.setPriority(Thread.MAX_PRIORITY);\r\n            th.start();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ConversationTabbedPane.setSelectedIndex",
	"Comment": "overrides setselectedindex in sipcommtabbedpane in order to remove theindicator of number of unread messages previously set.",
	"Method": "void setSelectedIndex(int tabIndex){\r\n    if (tabIndex < 0)\r\n        return;\r\n    Component c = this.getComponentAt(tabIndex);\r\n    if (c instanceof ChatPanel) {\r\n        ChatPanel chatPanel = (ChatPanel) c;\r\n        int unreadMessageNumber = chatPanel.unreadMessageNumber;\r\n        if (unreadMessageNumber > 0) {\r\n            String tabTitle = chatPanel.getChatSession().getChatName();\r\n            this.setTitleAt(tabIndex, tabTitle);\r\n        }\r\n        chatPanel.unreadMessageNumber = 0;\r\n    }\r\n    super.setSelectedIndex(tabIndex);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetBasicTelephonyJabberImpl.isSecure",
	"Comment": "gets the secure state of the call session in which a specific peeris involved",
	"Method": "boolean isSecure(CallPeer peer){\r\n    return ((MediaAwareCallPeer<?, ?, ?>) peer).getMediaHandler().isSecure();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.certificate.CertificateVerificationActivator.getCertificateDialogService",
	"Comment": "returns the verifycertificatedialogservice, through which wewill use to create dialogs.",
	"Method": "VerifyCertificateDialogService getCertificateDialogService(){\r\n    if (certificateDialogService == null) {\r\n        certificateDialogService = ServiceUtils.getService(bundleContext, VerifyCertificateDialogService.class);\r\n    }\r\n    return certificateDialogService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.TestOperationSetTypingNotifications.thenTestSendTypingNotification",
	"Comment": "sends a typing notification through the tested implementation andverifies whether it is properly received by the tester agent.",
	"Method": "void thenTestSendTypingNotification(){\r\n    JoustSimTypingEventCollector evtCollector = new JoustSimTypingEventCollector();\r\n    Contact contactToNotify = opSetPresence.findContactByID(IcqSlickFixture.testerAgent.getIcqUIN());\r\n    IcqSlickFixture.testerAgent.addTypingStateInfoListenerForBuddy(contactToNotify.getAddress(), evtCollector);\r\n    opSetTypingNotifs.sendTypingNotification(contactToNotify, OperationSetTypingNotifications.STATE_TYPING);\r\n    IcqSlickFixture.testerAgent.removeTypingStateInfoListenerForBuddy(contactToNotify.getAddress(), evtCollector);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.IrcStatusEnum.supportedStatusSet",
	"Comment": "returns an iterator over all status instances supported by the ircprovider.",
	"Method": "Iterator<IrcStatusEnum> supportedStatusSet(){\r\n    return SUPPORTED_STATUS_SET.iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.resources.ResourceManagementServiceImpl.getSoundURL",
	"Comment": "returns the url of the sound corresponding to the givenproperty key.",
	"Method": "URL getSoundURL(String urlKey){\r\n    String path = getSoundPath(urlKey);\r\n    if (path == null || path.length() == 0) {\r\n        logger.warn(\"Missing resource for key: \" + urlKey);\r\n        return null;\r\n    }\r\n    return getSoundURLForPath(path);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.whiteboard.WhiteboardSessionManager.moveWhiteboardObject",
	"Comment": "moves a whiteboardshape from from one point to another on theboard.",
	"Method": "void moveWhiteboardObject(WhiteboardSession wbSession,WhiteboardShape ws){\r\n    try {\r\n        wbSession.moveWhiteboardObject(ws);\r\n    } catch (OperationFailedException ex) {\r\n        ex.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.wizard.EncryptionConfigurationTableModel.getEncryptionProtocols",
	"Comment": "returns the map between encryption protocol names and their priorityorder.",
	"Method": "Map<String, Integer> getEncryptionProtocols(){\r\n    Map<String, Integer> encryptionProtocolMap = new HashMap<String, Integer>(this.encryptionProtocols.length);\r\n    for (int i = 0; i < this.encryptionProtocols.length; ++i) {\r\n        encryptionProtocolMap.put(this.encryptionProtocols[i], new Integer(i));\r\n    }\r\n    return encryptionProtocolMap;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactListServiceImpl.findParentMetaContactGroup",
	"Comment": "returns the meta contact group that is a direct parent of the specifiedchild.",
	"Method": "MetaContactGroup findParentMetaContactGroup(MetaContactGroup child,MetaContactGroup findParentMetaContactGroup,MetaContactGroupImpl root,MetaContactGroup child,MetaContactGroup findParentMetaContactGroup,MetaContact child){\r\n    if (!(child instanceof MetaContactImpl)) {\r\n        throw new IllegalArgumentException(child + \" is not a MetaContactImpl instance.\");\r\n    }\r\n    return ((MetaContactImpl) child).getParentGroup();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.SourceUIContact.getDisplayDetails",
	"Comment": "returns the display details for the underlying sourcecontact.",
	"Method": "String getDisplayDetails(){\r\n    return sourceContact.getDisplayDetails();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.aimaccregwizz.AimAccountRegistrationWizard.getFirstPageIdentifier",
	"Comment": "returns the identifier of the page to show first in the wizard.",
	"Method": "Object getFirstPageIdentifier(){\r\n    return firstWizardPage.getIdentifier();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.OperationSetPersistentPresenceGibberishImpl.unsubscribe",
	"Comment": "removes a subscription for the presence status of the specifiedcontact.",
	"Method": "void unsubscribe(Contact contact){\r\n    ContactGroupGibberishImpl parentGroup = (ContactGroupGibberishImpl) contact.getParentContactGroup();\r\n    parentGroup.removeContact((ContactGibberishImpl) contact);\r\n    fireSubscriptionEvent(contact, contact.getParentContactGroup(), SubscriptionEvent.SUBSCRIPTION_REMOVED);\r\n}"
}, {
	"Path": "net.librec.util.ReflectionUtil.newInstance",
	"Comment": "create an object for the given class and initialize it from conf",
	"Method": "T newInstance(Class<T> theClass,Class<?> paramClass,Object paramValue,T newInstance,Class<T> theClass,Configuration conf,T newInstance,Class<T> theClass){\r\n    T result;\r\n    try {\r\n        Constructor<T> meth = (Constructor<T>) CONSTRUCTOR_CACHE.get(theClass);\r\n        if (meth == null) {\r\n            meth = theClass.getDeclaredConstructor(EMPTY_ARRAY);\r\n            meth.setAccessible(true);\r\n            CONSTRUCTOR_CACHE.put(theClass, meth);\r\n        }\r\n        result = meth.newInstance();\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.MetaContactChatTransport.allowsSmsMessage",
	"Comment": "returns true if this chat transport supports smsmessaging, otherwise returns false.",
	"Method": "boolean allowsSmsMessage(){\r\n    OperationSetContactCapabilities capOpSet = getProtocolProvider().getOperationSet(OperationSetContactCapabilities.class);\r\n    if (capOpSet != null) {\r\n        if (capOpSet.getOperationSet(contact, OperationSetSmsMessaging.class) != null) {\r\n            return true;\r\n        }\r\n    } else if (contact.getProtocolProvider().getOperationSet(OperationSetSmsMessaging.class) != null)\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.AbstractIrcMessageListener.localUser",
	"Comment": "test if local user is disconnecting or it is some arbitrary other ircuser.",
	"Method": "boolean localUser(String nick){\r\n    return nick != null && nick.equals(this.connectionState.getNickname());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.AimStatusEnum.getImageInBytes",
	"Comment": "returns the byte representation of the image corresponding to the givenidentifier.",
	"Method": "byte[] getImageInBytes(String imageID){\r\n    InputStream in = IcqActivator.getResources().getImageInputStream(imageID);\r\n    if (in == null)\r\n        return null;\r\n    byte[] image = null;\r\n    try {\r\n        image = new byte[in.available()];\r\n        in.read(image);\r\n    } catch (IOException e) {\r\n        logger.error(\"Failed to load image:\" + imageID, e);\r\n    }\r\n    return image;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.notifsource.NotificationContact.getUrgentUnreadMessageCount",
	"Comment": "returns the number of urgent unread messages, this notification isabout.",
	"Method": "int getUrgentUnreadMessageCount(){\r\n    return unreadUrgentMessageCount;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.RenameGroupDialog.actionPerformed",
	"Comment": "handles the actionevent. in order to rename the group invokesthe renamemetacontactgroup method of the currentmetacontactlistservice.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    JButton button = (JButton) e.getSource();\r\n    String name = button.getName();\r\n    if (name.equals(\"rename\")) {\r\n        if (metaGroup != null) {\r\n            new Thread() {\r\n                @Override\r\n                public void run() {\r\n                    clist.renameMetaContactGroup(metaGroup, renameGroupPanel.getNewName());\r\n                }\r\n            }.start();\r\n        }\r\n        this.dispose();\r\n    } else\r\n        this.dispose();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.RenameGroupDialog.actionPerformed",
	"Comment": "handles the actionevent. in order to rename the group invokesthe renamemetacontactgroup method of the currentmetacontactlistservice.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    clist.renameMetaContactGroup(metaGroup, renameGroupPanel.getNewName());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.login.DefaultSecurityAuthority.isUserNameEditable",
	"Comment": "indicates if the user name is currently editable, i.e. could be changedby user or not.",
	"Method": "boolean isUserNameEditable(){\r\n    return isUserNameEditable;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.IceConfigPanel.createAdditionalJingleNodesComponent",
	"Comment": "creates the list of additional jinglenodes that are added by the user.",
	"Method": "Component createAdditionalJingleNodesComponent(){\r\n    jnTable.setPreferredScrollableViewportSize(new Dimension(450, 60));\r\n    jnTableModel.addColumn(Resources.getString(\"plugin.jabberaccregwizz.JID_ADDRESS\"));\r\n    jnTableModel.addColumn(Resources.getString(\"plugin.jabberaccregwizz.RELAY_SUPPORT\"));\r\n    jnTable.setDefaultRenderer(JingleNodeDescriptor.class, new ServerCellRenderer());\r\n    JScrollPane scrollPane = new JScrollPane(jnTable);\r\n    final JButton addButton = new JButton(Resources.getString(\"service.gui.ADD\"));\r\n    addButton.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent e) {\r\n            JNConfigDialog jnDialog = new JNConfigDialog(false);\r\n            jnDialog.setModal(true);\r\n            jnDialog.setVisible(true);\r\n        }\r\n    });\r\n    final JButton editButton = new JButton(Resources.getString(\"service.gui.EDIT\"));\r\n    editButton.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent e) {\r\n            if (jnTable.getSelectedRow() < 0)\r\n                return;\r\n            JingleNodeDescriptor jn = (JingleNodeDescriptor) jnTableModel.getValueAt(jnTable.getSelectedRow(), 0);\r\n            if (jn != null) {\r\n                JNConfigDialog dialog = new JNConfigDialog(jn.getJID(), jn.isRelaySupported());\r\n                dialog.setModal(true);\r\n                dialog.setVisible(true);\r\n            }\r\n        }\r\n    });\r\n    final JButton deleteButton = new JButton(Resources.getString(\"service.gui.DELETE\"));\r\n    deleteButton.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent e) {\r\n            jnTableModel.removeRow(jnTable.getSelectedRow());\r\n        }\r\n    });\r\n    TransparentPanel buttonsPanel = new TransparentPanel(new FlowLayout(FlowLayout.RIGHT));\r\n    buttonsPanel.add(addButton);\r\n    buttonsPanel.add(editButton);\r\n    buttonsPanel.add(deleteButton);\r\n    TransparentPanel mainPanel = new TransparentPanel(new BorderLayout());\r\n    mainPanel.setBorder(BorderFactory.createTitledBorder(Resources.getString(\"plugin.jabberaccregwizz.ADDITIONAL_JINGLE_NODES\")));\r\n    mainPanel.add(scrollPane);\r\n    mainPanel.add(buttonsPanel, BorderLayout.SOUTH);\r\n    jnTable.addMouseListener(new MouseAdapter() {\r\n        @Override\r\n        public void mouseClicked(MouseEvent evt) {\r\n            if (evt.getComponent().isEnabled() && evt.getButton() == MouseEvent.BUTTON1 && evt.getClickCount() == 2) {\r\n                editButton.doClick();\r\n            }\r\n        }\r\n    });\r\n    return mainPanel;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.IceConfigPanel.createAdditionalJingleNodesComponent",
	"Comment": "creates the list of additional jinglenodes that are added by the user.",
	"Method": "Component createAdditionalJingleNodesComponent(){\r\n    JNConfigDialog jnDialog = new JNConfigDialog(false);\r\n    jnDialog.setModal(true);\r\n    jnDialog.setVisible(true);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.IceConfigPanel.createAdditionalJingleNodesComponent",
	"Comment": "creates the list of additional jinglenodes that are added by the user.",
	"Method": "Component createAdditionalJingleNodesComponent(){\r\n    if (jnTable.getSelectedRow() < 0)\r\n        return;\r\n    JingleNodeDescriptor jn = (JingleNodeDescriptor) jnTableModel.getValueAt(jnTable.getSelectedRow(), 0);\r\n    if (jn != null) {\r\n        JNConfigDialog dialog = new JNConfigDialog(jn.getJID(), jn.isRelaySupported());\r\n        dialog.setModal(true);\r\n        dialog.setVisible(true);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.IceConfigPanel.createAdditionalJingleNodesComponent",
	"Comment": "creates the list of additional jinglenodes that are added by the user.",
	"Method": "Component createAdditionalJingleNodesComponent(){\r\n    jnTableModel.removeRow(jnTable.getSelectedRow());\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.IceConfigPanel.createAdditionalJingleNodesComponent",
	"Comment": "creates the list of additional jinglenodes that are added by the user.",
	"Method": "Component createAdditionalJingleNodesComponent(){\r\n    if (evt.getComponent().isEnabled() && evt.getButton() == MouseEvent.BUTTON1 && evt.getClickCount() == 2) {\r\n        editButton.doClick();\r\n    }\r\n}"
}, {
	"Path": "net.librec.data.model.TextDataModelTestCase.getDataSize",
	"Comment": "returns the size of preference matrix of a specified datamodel object",
	"Method": "int getDataSize(DataModel dataModel){\r\n    int sum = 0;\r\n    int train = getTrainSize(dataModel);\r\n    int test = getTestSize(dataModel);\r\n    if (null != dataModel.getDataSplitter().getValidData()) {\r\n        int valid = getValidSize(dataModel);\r\n        sum += valid;\r\n    }\r\n    sum = sum + train + test;\r\n    return sum;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.presence.AbstractStatusMessageMenu.propertyChange",
	"Comment": "listens for changes in the custom status messages and update.compares what is saved in the configuration and update according to that.",
	"Method": "void propertyChange(PropertyChangeEvent evt){\r\n    if (evt.getPropertyName().equals(CUSTOM_STATUS_MESSAGES_UPDATED_PROP)) {\r\n        java.util.List<String> customMessagesProps = DesktopUtilActivator.getConfigurationService().getPropertyNamesByPrefix(CUSTOM_MESSAGES_PREFIX, false);\r\n        if (customMessagesProps.isEmpty()) {\r\n            removeAllCustomStatusMessages();\r\n            return;\r\n        }\r\n        java.util.List<String> customMessages = new ArrayList<String>();\r\n        for (String p : customMessagesProps) {\r\n            customMessages.add(DesktopUtilActivator.getConfigurationService().getString(p));\r\n        }\r\n        for (Object o : getMenuComponents()) {\r\n            if (o instanceof CustomMessageItems) {\r\n                customMessages.remove(((CustomMessageItems) o).getName());\r\n            }\r\n        }\r\n        for (String message : customMessages) {\r\n            int ix = getLastCustomMessageIndex();\r\n            if (ix == -1) {\r\n                this.addSeparator();\r\n                createsCustomMessageItem(message, -1, false);\r\n            } else {\r\n                createsCustomMessageItem(message, ix + 1, false);\r\n            }\r\n        }\r\n    } else if (evt.getPropertyName().equals(STATUS_MESSAGE_UPDATED_PROP)) {\r\n        if (!evt.getSource().equals(getDescriptor()))\r\n            return;\r\n        clearSelectedItems();\r\n        for (Object o : getMenuComponents()) {\r\n            if (o instanceof JCheckBoxMenuItem) {\r\n                JCheckBoxMenuItem item = (JCheckBoxMenuItem) o;\r\n                if (!item.isSelected() && item.getName().equals(evt.getNewValue())) {\r\n                    item.setSelected(true);\r\n                }\r\n            } else if (o instanceof CheckboxMenuItem) {\r\n                CheckboxMenuItem item = (CheckboxMenuItem) o;\r\n                if (!item.getState() && item.getName().equals(evt.getNewValue())) {\r\n                    item.setState(true);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.net.SslNetworkLayer.createSSLSocket",
	"Comment": "creates a stream ssl socket and connects it to the specified port numberat the specified ip address.",
	"Method": "SSLSocket createSSLSocket(InetAddress address,int port,SSLSocket createSSLSocket,InetAddress address,int port,InetAddress myAddress){\r\n    SSLSocket sock = (SSLSocket) getSSLSocketFactory(address).createSocket(address, port, myAddress, 0);\r\n    setTrafficClass(sock);\r\n    return sock;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.GroupNode.removeContact",
	"Comment": "removes the node corresponding to the given uicontact from thisgroup.",
	"Method": "void removeContact(UIContactImpl uiContact){\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Group node remove contact: \" + uiContact.getDisplayName());\r\n    final ContactNode contactNode;\r\n    int index;\r\n    synchronized (uiContact) {\r\n        contactNode = uiContact.getContactNode();\r\n        if (contactNode == null)\r\n            return;\r\n        index = getIndex(contactNode);\r\n    }\r\n    if (index == -1)\r\n        return;\r\n    int selectedIndex = getLeadSelectionRow();\r\n    children.removeElementAt(index);\r\n    contactNode.setParent(null);\r\n    synchronized (uiContact) {\r\n        uiContact.setContactNode(null);\r\n        uiContact = null;\r\n    }\r\n    fireNodeRemoved(contactNode, index);\r\n    refreshSelection(selectedIndex, getLeadSelectionRow());\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.history.HistoryID.createFromRawID",
	"Comment": "create a historyid from a raw id. you can pass any kind of strings andthey will be safely converted to valid ids.",
	"Method": "HistoryID createFromRawID(String[] rawid){\r\n    String[] id = new String[rawid.length];\r\n    for (int i = 0; i < rawid.length; i++) {\r\n        id[i] = HistoryID.readableHash(rawid[i]);\r\n    }\r\n    return new HistoryID(id);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ContactResourceJabberImpl.setMobile",
	"Comment": "changed whether contact is mobile one. logged in only from mobile device.",
	"Method": "void setMobile(boolean isMobile){\r\n    this.mobile = isMobile;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.SecurityPanel.create",
	"Comment": "creates the security panel depending on the concrete implementation ofthe passed security controller.",
	"Method": "SecurityPanel<?> create(SwingCallPeerRenderer peerRenderer,CallPeer callPeer,SrtpControl srtpControl){\r\n    if (srtpControl instanceof ZrtpControl) {\r\n        return new ZrtpSecurityPanel(peerRenderer, callPeer, (ZrtpControl) srtpControl);\r\n    } else {\r\n        return new SecurityPanel<SrtpControl>(srtpControl) {\r\n            public void loadSkin() {\r\n            }\r\n            @Override\r\n            public void securityOn(CallPeerSecurityOnEvent evt) {\r\n            }\r\n            @Override\r\n            public void securityOff(CallPeerSecurityOffEvent evt) {\r\n            }\r\n            @Override\r\n            public void securityTimeout(CallPeerSecurityTimeoutEvent evt) {\r\n            }\r\n        };\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.SecurityPanel.create",
	"Comment": "creates the security panel depending on the concrete implementation ofthe passed security controller.",
	"Method": "SecurityPanel<?> create(SwingCallPeerRenderer peerRenderer,CallPeer callPeer,SrtpControl srtpControl){\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.SecurityPanel.create",
	"Comment": "creates the security panel depending on the concrete implementation ofthe passed security controller.",
	"Method": "SecurityPanel<?> create(SwingCallPeerRenderer peerRenderer,CallPeer callPeer,SrtpControl srtpControl){\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.SecurityPanel.create",
	"Comment": "creates the security panel depending on the concrete implementation ofthe passed security controller.",
	"Method": "SecurityPanel<?> create(SwingCallPeerRenderer peerRenderer,CallPeer callPeer,SrtpControl srtpControl){\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.SecurityPanel.create",
	"Comment": "creates the security panel depending on the concrete implementation ofthe passed security controller.",
	"Method": "SecurityPanel<?> create(SwingCallPeerRenderer peerRenderer,CallPeer callPeer,SrtpControl srtpControl){\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetServerStoredAccountInfoIcqImpl.getCountry",
	"Comment": "returns the locale corresponding the index coming from icq server",
	"Method": "Locale getCountry(int code){\r\n    if (code == 0 || code == 9999)\r\n        return null;\r\n    String cryStr = countryIndexToLocaleString.get(code);\r\n    return (cryStr == null) ? null : new Locale(\"\", cryStr);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ServerStoredContactListJabberImpl.moveContact",
	"Comment": "moves the specified contact to the group indicated bynewparent.",
	"Method": "void moveContact(ContactJabberImpl contact,AbstractContactGroupJabberImpl newParent){\r\n    if (!contact.isPersistent()) {\r\n        String contactAddress = null;\r\n        if (contact instanceof VolatileContactJabberImpl && ((VolatileContactJabberImpl) contact).isPrivateMessagingContact()) {\r\n            contactAddress = contact.getPersistableAddress();\r\n        } else {\r\n            contactAddress = contact.getAddress();\r\n        }\r\n        try {\r\n            addContact(newParent, contactAddress);\r\n            return;\r\n        } catch (OperationFailedException ex) {\r\n            logger.error(\"Cannot move contact! \", ex);\r\n            throw new OperationFailedException(ex.getMessage(), OperationFailedException.GENERAL_ERROR, ex);\r\n        }\r\n    }\r\n    try {\r\n        SmackConfiguration.setPacketReplyTimeout(ProtocolProviderServiceJabberImpl.SMACK_PACKET_REPLY_TIMEOUT);\r\n        roster.createEntry(contact.getSourceEntry().getUser(), contact.getDisplayName(), new String[] { newParent.getGroupName() });\r\n        SmackConfiguration.setPacketReplyTimeout(5000);\r\n        newParent.addContact(contact);\r\n    } catch (XMPPException ex) {\r\n        logger.error(\"Cannot move contact! \", ex);\r\n        throw new OperationFailedException(ex.getMessage(), OperationFailedException.GENERAL_ERROR, ex);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.sipaccregwizz.SIPAccRegWizzActivator.getCertificateService",
	"Comment": "returns the certificateservice obtained from the bundlecontext.",
	"Method": "CertificateService getCertificateService(){\r\n    if (certService == null) {\r\n        ServiceReference serviceReference = bundleContext.getServiceReference(CertificateService.class.getName());\r\n        certService = (CertificateService) bundleContext.getService(serviceReference);\r\n    }\r\n    return certService;\r\n}"
}, {
	"Path": "net.librec.math.algorithm.Stats.median",
	"Comment": "calculate the median value of a data collection,note that the values of doulbe.nan will be ignored silently",
	"Method": "double median(double[] data,double median,Collection<? extends Number> data){\r\n    return median(toArray(data));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.TreeContactList.startSelectedContactDesktopSharing",
	"Comment": "starts a desktop sharing session with the currently selected contact inthe contact list.",
	"Method": "void startSelectedContactDesktopSharing(){\r\n    TreePath selectionPath = getSelectionPath();\r\n    if (selectionPath == null)\r\n        return;\r\n    ContactListTreeCellRenderer renderer = (ContactListTreeCellRenderer) getCellRenderer().getTreeCellRendererComponent(this, selectionPath.getLastPathComponent(), true, true, true, this.getRowForPath(selectionPath), true);\r\n    renderer.getDesktopSharingButton().doClick();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetPersistentPresenceIcqImpl.presenceStatusToStatusLong",
	"Comment": "converts the specified icqstatusenum member to the corresponding icqflag.",
	"Method": "long presenceStatusToStatusLong(PresenceStatus status){\r\n    if (parentProvider.USING_ICQ)\r\n        return scToIcqStatusMappings.get(status).longValue();\r\n    else\r\n        return scToAimStatusMappings.get(status).longValue();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactListServiceImpl.contactPresenceStatusChanged",
	"Comment": "upon each status notification this method finds the corresponding metacontact and updates the ordering in its parent group.",
	"Method": "void contactPresenceStatusChanged(ContactPresenceStatusChangeEvent evt){\r\n    MetaContactImpl metaContactImpl = (MetaContactImpl) findMetaContactByContact(evt.getSourceContact());\r\n    if (metaContactImpl == null)\r\n        return;\r\n    int oldContactIndex = metaContactImpl.getParentGroup().indexOf(metaContactImpl);\r\n    int newContactIndex = metaContactImpl.reevalContact();\r\n    if (oldContactIndex != newContactIndex) {\r\n        fireMetaContactGroupEvent(findParentMetaContactGroup(metaContactImpl), evt.getSourceProvider(), null, MetaContactGroupEvent.CHILD_CONTACTS_REORDERED);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.keybindingchooser.globalchooser.Resources.getString",
	"Comment": "returns an internationalized string corresponding to the given key.",
	"Method": "String getString(String key,String getString,String key,String[] params){\r\n    return KeybindingChooserActivator.getResources().getI18NString(key, params);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.notification.NotificationAction.setEnabled",
	"Comment": "enables or disables this notification handler. while the notificationhandler for the sound action type is disabled no sounds will be playedwhen the firenotification method is called.",
	"Method": "void setEnabled(boolean isEnabled){\r\n    this.isEnabled = isEnabled;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.ConfigurationUtils.isSmsNotifyTextDisabled",
	"Comment": "whether to display or not the text notifying that a message isa incoming or outgoing sms message.",
	"Method": "boolean isSmsNotifyTextDisabled(){\r\n    return isSmsNotifyTextDisabled;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.Logger.isDebugEnabled",
	"Comment": "check if a message with a debug level would actually be logged by thislogger.",
	"Method": "boolean isDebugEnabled(){\r\n    return loggerDelegate.isLoggable(Level.FINE);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AccountManager.removeStoredAccount",
	"Comment": "removes the account with accountid from the set of accountsthat are persistently stored inside the configuration service.",
	"Method": "boolean removeStoredAccount(ProtocolProviderFactory factory,AccountID accountID){\r\n    synchronized (storedAccounts) {\r\n        if (storedAccounts.contains(accountID))\r\n            storedAccounts.remove(accountID);\r\n    }\r\n    if (factory == null) {\r\n        factory = ProtocolProviderActivator.getProtocolProviderFactory(accountID.getProtocolName());\r\n    }\r\n    String factoryPackage = getFactoryImplPackageName(factory);\r\n    CredentialsStorageService credentialsStorage = ServiceUtils.getService(bundleContext, CredentialsStorageService.class);\r\n    String accountPrefix = ProtocolProviderFactory.findAccountPrefix(bundleContext, accountID, factoryPackage);\r\n    credentialsStorage.removePassword(accountPrefix);\r\n    ConfigurationService configurationService = ServiceUtils.getService(bundleContext, ConfigurationService.class);\r\n    List<String> storedAccounts = configurationService.getPropertyNamesByPrefix(factoryPackage, true);\r\n    for (String accountRootPropertyName : storedAccounts) {\r\n        String accountUID = // node id\r\n        configurationService.getString(accountRootPropertyName + \".\" + ProtocolProviderFactory.ACCOUNT_UID);\r\n        if (accountID.getAccountUniqueID().equals(accountUID)) {\r\n            List<String> accountPropertyNames = configurationService.getPropertyNamesByPrefix(accountRootPropertyName, false);\r\n            for (String propName : accountPropertyNames) configurationService.setProperty(propName, null);\r\n            configurationService.setProperty(accountRootPropertyName, null);\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipRegistrarConnection.getTransport",
	"Comment": "returns the transport that this connection is currently using to communicate with the registrar.",
	"Method": "String getTransport(){\r\n    return this.registrationTransport;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.UIPhoneUtil.getAdditionalNumbers",
	"Comment": "searches for additional phone numbers found in contact information",
	"Method": "List<UIContactDetail> getAdditionalNumbers(List<UIContactDetail> getAdditionalNumbers,boolean onlyMobile){\r\n    List<UIContactDetail> telephonyContacts = new ArrayList<UIContactDetail>();\r\n    Iterator<Contact> contacts = getMetaContact().getContacts();\r\n    while (contacts.hasNext()) {\r\n        Contact contact = contacts.next();\r\n        OperationSetServerStoredContactInfo infoOpSet = contact.getProtocolProvider().getOperationSet(OperationSetServerStoredContactInfo.class);\r\n        Iterator<GenericDetail> details;\r\n        ArrayList<String> phones = new ArrayList<String>();\r\n        if (infoOpSet != null) {\r\n            details = infoOpSet.getAllDetailsForContact(contact);\r\n            while (details.hasNext()) {\r\n                GenericDetail d = details.next();\r\n                boolean process = false;\r\n                if (onlyMobile) {\r\n                    if (d instanceof MobilePhoneDetail)\r\n                        process = true;\r\n                } else if (d instanceof PhoneNumberDetail && !(d instanceof PagerDetail) && !(d instanceof FaxDetail)) {\r\n                    process = true;\r\n                }\r\n                if (process) {\r\n                    PhoneNumberDetail pnd = (PhoneNumberDetail) d;\r\n                    if (pnd.getNumber() != null && pnd.getNumber().length() > 0) {\r\n                        if (phones.contains(pnd.getNumber()))\r\n                            continue;\r\n                        phones.add(pnd.getNumber());\r\n                        UIContactDetail cd = new UIContactDetailImpl(pnd.getNumber(), pnd.getNumber() + \" (\" + getLocalizedPhoneNumber(d) + \")\", null, new ArrayList<String>(), DesktopUtilActivator.getResources().getImage(\"service.gui.icons.EXTERNAL_PHONE\"), null, null, pnd) {\r\n                            @Override\r\n                            public PresenceStatus getPresenceStatus() {\r\n                                return null;\r\n                            }\r\n                        };\r\n                        telephonyContacts.add(cd);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return telephonyContacts;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.UIPhoneUtil.getAdditionalNumbers",
	"Comment": "searches for additional phone numbers found in contact information",
	"Method": "List<UIContactDetail> getAdditionalNumbers(List<UIContactDetail> getAdditionalNumbers,boolean onlyMobile){\r\n    return null;\r\n}"
}, {
	"Path": "net.librec.recommender.cf.UserKNNTestCase.test22SplitterRatioUserFixed",
	"Comment": "test ratiodatasplitter with user fixed ratio, filter enabled.",
	"Method": "void test22SplitterRatioUserFixed(){\r\n    Resource resource = new Resource(\"rec/cf/userknn-test.properties\");\r\n    conf.addResource(resource);\r\n    conf.set(\"rec.eval.enable\", \"false\");\r\n    conf.set(\"rec.filter.class\", \"generic\");\r\n    conf.set(\"data.model.splitter\", \"ratio\");\r\n    conf.set(\"data.splitter.ratio\", \"userfixed\");\r\n    RecommenderJob job = new RecommenderJob(conf);\r\n    job.runJob();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.AbstractQualityControlWrapper.getRemoteReceivePreset",
	"Comment": "the currently used quality preset announced as receive by remote party.",
	"Method": "QualityPreset getRemoteReceivePreset(){\r\n    QualityControl qc = getMediaQualityControl();\r\n    return (qc == null) ? null : qc.getRemoteReceivePreset();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.TransportManagerJabberImpl.closeStreamConnector",
	"Comment": "closes a specific streamconnector associated with a specificmediatype. if this transportmanager has a reference tothe specified streamconnector, it remains.also expires the colibriconferenceiq.channel associated withthe closed streamconnector.",
	"Method": "void closeStreamConnector(MediaType mediaType,StreamConnector streamConnector){\r\n    try {\r\n        boolean superCloseStreamConnector = true;\r\n        if (streamConnector instanceof ColibriStreamConnector) {\r\n            CallPeerJabberImpl peer = getCallPeer();\r\n            if (peer != null) {\r\n                CallJabberImpl call = peer.getCall();\r\n                if (call != null) {\r\n                    superCloseStreamConnector = false;\r\n                    call.closeColibriStreamConnector(peer, mediaType, (ColibriStreamConnector) streamConnector);\r\n                }\r\n            }\r\n        }\r\n        if (superCloseStreamConnector)\r\n            super.closeStreamConnector(mediaType, streamConnector);\r\n    } finally {\r\n        if (colibri != null) {\r\n            ColibriConferenceIQ.Content content = colibri.getContent(mediaType.toString());\r\n            if (content != null) {\r\n                List<ColibriConferenceIQ.Channel> channels = content.getChannels();\r\n                if (channels.size() == 2) {\r\n                    ColibriConferenceIQ requestConferenceIQ = new ColibriConferenceIQ();\r\n                    requestConferenceIQ.setID(colibri.getID());\r\n                    ColibriConferenceIQ.Content requestContent = requestConferenceIQ.getOrCreateContent(content.getName());\r\n                    requestContent.addChannel(channels.get(1));\r\n                    colibri.removeContent(content);\r\n                    CallPeerJabberImpl peer = getCallPeer();\r\n                    if (peer != null) {\r\n                        CallJabberImpl call = peer.getCall();\r\n                        if (call != null) {\r\n                            call.expireColibriChannels(peer, requestConferenceIQ);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetPresenceSipImpl.createPublish",
	"Comment": "create a valid publish request corresponding to the current presencestate. the request is forged to be send to the current distant presenceagent.",
	"Method": "Request createPublish(int expires,boolean insertPresDoc){\r\n    CallIdHeader callIdHeader = this.parentProvider.getDefaultJainSipProvider().getNewCallId();\r\n    String localTag = SipMessageFactory.generateLocalTag();\r\n    FromHeader fromHeader = null;\r\n    ToHeader toHeader = null;\r\n    try {\r\n        Address ourAOR = parentProvider.getRegistrarConnection().getAddressOfRecord();\r\n        fromHeader = this.parentProvider.getHeaderFactory().createFromHeader(ourAOR, localTag);\r\n        toHeader = this.parentProvider.getHeaderFactory().createToHeader(ourAOR, null);\r\n    } catch (ParseException ex) {\r\n        logger.error(\"An unexpected error occurred while\" + \"constructing the FromHeader or ToHeader\", ex);\r\n        throw new OperationFailedException(\"An unexpected error occurred while\" + \"constructing the FromHeader or ToHeader\", OperationFailedException.INTERNAL_ERROR, ex);\r\n    }\r\n    ArrayList<ViaHeader> viaHeaders = parentProvider.getLocalViaHeaders(toHeader.getAddress());\r\n    MaxForwardsHeader maxForwards = this.parentProvider.getMaxForwardsHeader();\r\n    byte[] doc = null;\r\n    if (insertPresDoc) {\r\n        doc = getPidfPresenceStatus(getLocalContactForDst(toHeader.getAddress()));\r\n    } else {\r\n        doc = new byte[0];\r\n    }\r\n    ContentTypeHeader contTypeHeader;\r\n    try {\r\n        contTypeHeader = this.parentProvider.getHeaderFactory().createContentTypeHeader(\"application\", PIDF_XML);\r\n    } catch (ParseException ex) {\r\n        logger.error(\"An unexpected error occurred while\" + \"constructing the content headers\", ex);\r\n        throw new OperationFailedException(\"An unexpected error occurred while\" + \"constructing the content headers\", OperationFailedException.INTERNAL_ERROR, ex);\r\n    }\r\n    SIPIfMatchHeader ifmHeader = null;\r\n    try {\r\n        if (this.distantPAET != null) {\r\n            ifmHeader = this.parentProvider.getHeaderFactory().createSIPIfMatchHeader(this.distantPAET);\r\n        }\r\n    } catch (ParseException e) {\r\n        logger.error(\"An unexpected error occurred while\" + \"constructing the SIPIfMatch header\", e);\r\n        throw new OperationFailedException(\"An unexpected error occurred while\" + \"constructing the SIPIfMatch header\", OperationFailedException.INTERNAL_ERROR, e);\r\n    }\r\n    CSeqHeader cSeqHeader = null;\r\n    try {\r\n        cSeqHeader = this.parentProvider.getHeaderFactory().createCSeqHeader(publish_cseq++, Request.PUBLISH);\r\n    } catch (InvalidArgumentException ex) {\r\n        logger.error(\"An unexpected error occurred while\" + \"constructing the CSeqHeader\", ex);\r\n        throw new OperationFailedException(\"An unexpected error occurred while\" + \"constructing the CSeqHeader\", OperationFailedException.INTERNAL_ERROR, ex);\r\n    } catch (ParseException ex) {\r\n        logger.error(\"An unexpected error occurred while\" + \"constructing the CSeqHeader\", ex);\r\n        throw new OperationFailedException(\"An unexpected error occurred while\" + \"constructing the CSeqHeader\", OperationFailedException.INTERNAL_ERROR, ex);\r\n    }\r\n    ExpiresHeader expHeader = null;\r\n    try {\r\n        expHeader = this.parentProvider.getHeaderFactory().createExpiresHeader(expires);\r\n    } catch (InvalidArgumentException e) {\r\n        logger.error(\"An unexpected error occurred while\" + \"constructing the Expires header\", e);\r\n        throw new OperationFailedException(\"An unexpected error occurred while\" + \"constructing the Expires header\", OperationFailedException.INTERNAL_ERROR, e);\r\n    }\r\n    EventHeader evtHeader = null;\r\n    try {\r\n        evtHeader = this.parentProvider.getHeaderFactory().createEventHeader(\"presence\");\r\n    } catch (ParseException e) {\r\n        logger.error(\"An unexpected error occurred while\" + \"constructing the Event header\", e);\r\n        throw new OperationFailedException(\"An unexpected error occurred while\" + \"constructing the Event header\", OperationFailedException.INTERNAL_ERROR, e);\r\n    }\r\n    Request req = null;\r\n    try {\r\n        req = this.parentProvider.getMessageFactory().createRequest(toHeader.getAddress().getURI(), Request.PUBLISH, callIdHeader, cSeqHeader, fromHeader, toHeader, viaHeaders, maxForwards, contTypeHeader, doc);\r\n    } catch (ParseException ex) {\r\n        logger.error(\"Failed to create message Request!\", ex);\r\n        throw new OperationFailedException(\"Failed to create message Request!\", OperationFailedException.INTERNAL_ERROR, ex);\r\n    }\r\n    req.setHeader(expHeader);\r\n    req.setHeader(evtHeader);\r\n    if (ifmHeader != null) {\r\n        req.setHeader(ifmHeader);\r\n    }\r\n    return req;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaAwareCallPeer.getLastConferenceInfoSent",
	"Comment": "returns the last conferenceinfodocument sent by us to thiscallpeer. it is a document with state full",
	"Method": "ConferenceInfoDocument getLastConferenceInfoSent(){\r\n    return lastConferenceInfoSent;\r\n}"
}, {
	"Path": "com.github.ltsopensource.core.commons.concurrent.limiter.Stopwatch.reset",
	"Comment": "sets the elapsed time for this stopwatch to zero,and places it in a stopped state.",
	"Method": "Stopwatch reset(){\r\n    elapsedNanos = 0;\r\n    isRunning = false;\r\n    return this;\r\n}"
}, {
	"Path": "net.librec.recommender.baseline.GlobalAverageRecommender.predict",
	"Comment": "the global average value as the predictive rating for user useridx on item itemidx.",
	"Method": "double predict(int userIdx,int itemIdx){\r\n    return globalMean;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ProtocolProviderFactorySipImpl.createAccountID",
	"Comment": "creates a new sipaccountidimpl instance with a specific userid to represent a given set of account properties.",
	"Method": "AccountID createAccountID(String userID,Map<String, String> accountProperties){\r\n    String serverAddress = accountProperties.get(SERVER_ADDRESS);\r\n    return new SipAccountIDImpl(userID, accountProperties, serverAddress);\r\n}"
}, {
	"Path": "net.librec.util.StringUtil.getTrimmedStrings",
	"Comment": "splits a comma separated value string, trimming leading and trailing whitespace on each value.",
	"Method": "String[] getTrimmedStrings(String str){\r\n    if (null == str || str.trim().isEmpty()) {\r\n        return emptyStringArray;\r\n    }\r\n    return str.trim().split(\"\\\\s*,\\\\s*\");\r\n}"
}, {
	"Path": "io.lettuce.core.masterslave.SentinelTopologyRefresh.potentiallyConnectSentinels",
	"Comment": "inspect whether additional sentinel connections are required based on the which sentinels are currently connected.",
	"Method": "List<ConnectionFuture<StatefulRedisPubSubConnection<String, String>>> potentiallyConnectSentinels(){\r\n    List<ConnectionFuture<StatefulRedisPubSubConnection<String, String>>> connectionFutures = new ArrayList();\r\n    for (RedisURI sentinel : sentinels) {\r\n        if (pubSubConnections.containsKey(sentinel)) {\r\n            continue;\r\n        }\r\n        ConnectionFuture<StatefulRedisPubSubConnection<String, String>> future = redisClient.connectPubSubAsync(CODEC, sentinel);\r\n        pubSubConnections.put(sentinel, future);\r\n        future.whenComplete((connection, throwable) -> {\r\n            if (throwable != null || closed) {\r\n                pubSubConnections.remove(sentinel);\r\n            }\r\n            if (closed) {\r\n                connection.closeAsync();\r\n            }\r\n        });\r\n        connectionFutures.add(future);\r\n    }\r\n    return connectionFutures;\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.server.ab.TestABCase5.testCase5_19",
	"Comment": "send text message fragmented in 5 frames, with 2 pings and wait between.",
	"Method": "void testCase5_19(){\r\n    List<WebSocketFrame> send1 = new ArrayList();\r\n    send1.add(new TextFrame().setPayload(\"f1\").setFin(false));\r\n    send1.add(new ContinuationFrame().setPayload(\",f2\").setFin(false));\r\n    send1.add(new PingFrame().setPayload(\"pong-1\"));\r\n    List<WebSocketFrame> expect1 = new ArrayList();\r\n    expect1.add(new PongFrame().setPayload(\"pong-1\"));\r\n    List<WebSocketFrame> send2 = new ArrayList();\r\n    send2.add(new ContinuationFrame().setPayload(\",f3\").setFin(false));\r\n    send2.add(new ContinuationFrame().setPayload(\",f4\").setFin(false));\r\n    send2.add(new PingFrame().setPayload(\"pong-2\"));\r\n    send2.add(new ContinuationFrame().setPayload(\",f5\").setFin(true));\r\n    send2.add(new CloseInfo(StatusCode.NORMAL).asFrame());\r\n    List<WebSocketFrame> expect2 = new ArrayList();\r\n    expect2.add(new PongFrame().setPayload(\"pong-2\"));\r\n    expect2.add(new TextFrame().setPayload(\"f1,f2,f3,f4,f5\"));\r\n    expect2.add(new CloseInfo(StatusCode.NORMAL).asFrame());\r\n    try (Fuzzer fuzzer = new Fuzzer(this);\r\n        StacklessLogging suppress = new StacklessLogging(Parser.class)) {\r\n        fuzzer.connect();\r\n        fuzzer.setSendMode(Fuzzer.SendMode.BULK);\r\n        fuzzer.send(send1);\r\n        fuzzer.expect(expect1);\r\n        TimeUnit.SECONDS.sleep(1);\r\n        fuzzer.send(send2);\r\n        fuzzer.expect(expect2);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomIrcImpl.getMembers",
	"Comment": "returns a list of chatroommemberss corresponding to allmembers currently participating in this room.",
	"Method": "List<ChatRoomMember> getMembers(){\r\n    return new ArrayList<ChatRoomMember>(chatRoomMembers.values());\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.server.ab.TestABCase5.testCase5_15",
	"Comment": "send text fragmented properly in 2 frames, then continuation!fin, then text unfragmented.",
	"Method": "void testCase5_15(){\r\n    List<WebSocketFrame> send = new ArrayList();\r\n    send.add(new TextFrame().setPayload(\"fragment1\").setFin(false));\r\n    send.add(new ContinuationFrame().setPayload(\"fragment2\").setFin(true));\r\n    send.add(new ContinuationFrame().setPayload(\"fragment3\").setFin(false));\r\n    send.add(new TextFrame().setPayload(\"fragment4\").setFin(true));\r\n    send.add(new CloseInfo(StatusCode.NORMAL).asFrame());\r\n    List<WebSocketFrame> expect = new ArrayList();\r\n    expect.add(new TextFrame().setPayload(\"fragment1fragment2\"));\r\n    expect.add(new CloseInfo(StatusCode.PROTOCOL).asFrame());\r\n    try (Fuzzer fuzzer = new Fuzzer(this);\r\n        StacklessLogging suppress = new StacklessLogging(Parser.class)) {\r\n        fuzzer.connect();\r\n        fuzzer.setSendMode(Fuzzer.SendMode.BULK);\r\n        fuzzer.send(send);\r\n        fuzzer.expect(expect);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.MetaContactListSource.protoContactModified",
	"Comment": "notifies the ui representation of the parent metacontact thatthis contact has been modified.",
	"Method": "void protoContactModified(ProtoContactEvent evt){\r\n    MetaContact metaContact = evt.getNewParent();\r\n    UIContactImpl uiContact;\r\n    synchronized (metaContact) {\r\n        uiContact = MetaContactListSource.getUIContact(metaContact);\r\n        if (uiContact == null)\r\n            return;\r\n    }\r\n    synchronized (uiContact) {\r\n        ContactNode contactNode = uiContact.getContactNode();\r\n        if (contactNode != null)\r\n            GuiActivator.getContactList().nodeChanged(contactNode);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetPresenceSipImpl.getPidfChilds",
	"Comment": "gets the list of the descendant of an element in the pidf namespace. if the list is empty, we try to get this list in any namespace. this method is useful for being able to read pidf document without any namespace or with a wrong namespace.",
	"Method": "NodeList getPidfChilds(Element element,String childName){\r\n    NodeList res;\r\n    res = element.getElementsByTagNameNS(PIDF_NS_VALUE, childName);\r\n    if (res.getLength() == 0) {\r\n        res = element.getElementsByTagNameNS(ANY_NS, childName);\r\n    }\r\n    return res;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ServerStoredContactListJabberImpl.addContactForImageUpdate",
	"Comment": "when there is no image for contact we must retrieve itadd contacts for image update",
	"Method": "void addContactForImageUpdate(ContactJabberImpl contact){\r\n    if (contact instanceof VolatileContactJabberImpl && ((VolatileContactJabberImpl) contact).isPrivateMessagingContact())\r\n        return;\r\n    if (imageRetriever == null) {\r\n        imageRetriever = new ImageRetriever();\r\n        imageRetriever.start();\r\n    }\r\n    imageRetriever.addContact(contact);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomJabberImpl.addConferenceCall",
	"Comment": "adds a calljabberimpl instance to the list of conference callsassociated with the room.",
	"Method": "void addConferenceCall(CallJabberImpl call){\r\n    if (!chatRoomConferenceCalls.contains(call))\r\n        chatRoomConferenceCalls.add(call);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallSipImpl.getProtocolProvider",
	"Comment": "returns a reference to the protocolproviderservicesipimplinstance that created this call.",
	"Method": "ProtocolProviderServiceSipImpl getProtocolProvider(){\r\n    return super.getProtocolProvider();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.AdHocConferenceChatTransport.removeInstantMessageListener",
	"Comment": "removes the instant message listener from this chat transport.",
	"Method": "void removeInstantMessageListener(MessageListener l){\r\n    if (!allowsInstantMessage())\r\n        return;\r\n    OperationSetBasicInstantMessaging imOpSet = adHocChatRoom.getParentProvider().getOperationSet(OperationSetBasicInstantMessaging.class);\r\n    imOpSet.removeMessageListener(l);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetPersistentPresenceJabberImpl.unsubscribe",
	"Comment": "removes a subscription for the presence status of the specifiedcontact.",
	"Method": "void unsubscribe(Contact contact){\r\n    assertConnected();\r\n    if (!(contact instanceof ContactJabberImpl))\r\n        throw new IllegalArgumentException(\"Argument is not an jabber contact (contact=\" + contact + \")\");\r\n    ssContactList.removeContact((ContactJabberImpl) contact);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.simpleaccreg.Resources.getApplicationProperty",
	"Comment": "returns the application property corresponding to the given key.",
	"Method": "String getApplicationProperty(String key){\r\n    return getResources().getSettingsString(key);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.callhistory.CallHistoryServiceImpl.handleProviderAdded",
	"Comment": "used to attach the call history service to existing orjust registered protocol provider. checks if the provider hasimplementation of operationsetbasictelephony",
	"Method": "void handleProviderAdded(ProtocolProviderService provider){\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Adding protocol provider \" + provider.getProtocolName());\r\n    OperationSetBasicTelephony<?> opSetTelephony = provider.getOperationSet(OperationSetBasicTelephony.class);\r\n    if (opSetTelephony != null) {\r\n        opSetTelephony.addCallListener(this);\r\n    } else {\r\n        if (logger.isTraceEnabled())\r\n            logger.trace(\"Service did not have a basic telephony op. set.\");\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.AnimatedImage.calculateImageDimensions",
	"Comment": "calculate the width and height of the image based on the maximumwidth and height of any individual image.",
	"Method": "void calculateImageDimensions(){\r\n    imageWidth = 0;\r\n    imageHeight = 0;\r\n    for (Image image : images) {\r\n        imageWidth = Math.max(imageWidth, image.getWidth(null));\r\n        imageHeight = Math.max(imageHeight, image.getHeight(null));\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.MetaUIContact.getScaledAvatar",
	"Comment": "gets the avatar of a specific metacontact in the form of animageicon value.",
	"Method": "ImageIcon getScaledAvatar(boolean isSelected,int width,int height){\r\n    byte[] avatarBytes = metaContact.getAvatar(true);\r\n    if ((avatarBytes == null) || (avatarBytes.length <= 0)) {\r\n        if (!subscribed) {\r\n            return ImageUtils.getScaledRoundedIcon(ImageLoader.getImage(ImageLoader.UNAUTHORIZED_CONTACT_PHOTO), width, height);\r\n        }\r\n        return null;\r\n    }\r\n    if (isSelected)\r\n        return ImageUtils.getScaledRoundedIcon(avatarBytes, width, height);\r\n    Object[] avatarCache = (Object[]) metaContact.getData(AVATAR_DATA_KEY);\r\n    ImageIcon avatar = null;\r\n    if ((avatarCache != null) && (avatarCache[0] == avatarBytes))\r\n        avatar = (ImageIcon) avatarCache[1];\r\n    if (avatar == null) {\r\n        avatar = ImageUtils.getScaledRoundedIcon(avatarBytes, width, height);\r\n    }\r\n    if (avatarCache == null) {\r\n        if (avatar != null)\r\n            metaContact.setData(AVATAR_DATA_KEY, new Object[] { avatarBytes, avatar });\r\n    } else {\r\n        avatarCache[0] = avatarBytes;\r\n        avatarCache[1] = avatar;\r\n    }\r\n    return avatar;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.conference.ConferenceFocusPanel.securityPending",
	"Comment": "indicates that the security status is pending confirmation.",
	"Method": "void securityPending(){\r\n    focusPeerPanel.securityPending();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomIrcImpl.addChatRoomMember",
	"Comment": "adds a chatroommember to the list of members of this chat room.",
	"Method": "void addChatRoomMember(String memberID,ChatRoomMember member){\r\n    chatRoomMembers.put(memberID, member);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.AuthenticationWindow.close",
	"Comment": "automatically clicks the cancel button, when this window is closed.",
	"Method": "void close(boolean isEscaped){\r\n    this.cancelButton.doClick();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ProtocolProviderServiceJabberImpl.getRegistrationState",
	"Comment": "returns the state of the registration of this protocol provider",
	"Method": "RegistrationState getRegistrationState(){\r\n    if (connection == null) {\r\n        if (inConnectAndLogin) {\r\n            return RegistrationState.REGISTERING;\r\n        }\r\n        return RegistrationState.UNREGISTERED;\r\n    } else if (connection.isConnected() && connection.isAuthenticated()) {\r\n        return RegistrationState.REGISTERED;\r\n    } else {\r\n        return RegistrationState.REGISTERING;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetThumbnailedFileFactoryImpl.createFileWithThumbnail",
	"Comment": "creates a file, by attaching the thumbnail, given by the details, to it.",
	"Method": "File createFileWithThumbnail(File file,int thumbnailWidth,int thumbnailHeight,String thumbnailMimeType,byte[] thumbnail){\r\n    return new ThumbnailedFile(file, thumbnailWidth, thumbnailHeight, thumbnailMimeType, thumbnail);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractFileTransfer.addStatusListener",
	"Comment": "adds the given filetransferstatuslistener to listen forstatus changes on this file transfer.",
	"Method": "void addStatusListener(FileTransferStatusListener listener){\r\n    synchronized (statusListeners) {\r\n        if (!statusListeners.contains(listener)) {\r\n            this.statusListeners.add(listener);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.MessageWaitingEvent.getAccount",
	"Comment": "the uri we can use to reach messages from provider that is firingthe event.",
	"Method": "String getAccount(){\r\n    return account;\r\n}"
}, {
	"Path": "net.librec.recommender.ext.AssociationRuleTestCase.testAssociationRuleRecommender",
	"Comment": "test the whole rating process of associationrulerecommender\trecommendation",
	"Method": "void testAssociationRuleRecommender(){\r\n    Resource resource = new Resource(\"rec/ext/associationrule-test.properties\");\r\n    conf.addResource(resource);\r\n    RecommenderJob job = new RecommenderJob(conf);\r\n    job.runJob();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.GuiActivator.getSystrayService",
	"Comment": "returns the systrayservice obtained from the bundle context.",
	"Method": "SystrayService getSystrayService(){\r\n    if (systrayService == null) {\r\n        systrayService = ServiceUtils.getService(bundleContext, SystrayService.class);\r\n    }\r\n    return systrayService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ContactGroupJabberImpl.subgroups",
	"Comment": "returns an empty iterator. subgroups may only be present in the rootgroup.",
	"Method": "Iterator<ContactGroup> subgroups(){\r\n    return dummyGroupsList.iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatMessage.getCorrectedMessageUID",
	"Comment": "returns the uid of the message that this message replaces, ornull if this is a new message.",
	"Method": "String getCorrectedMessageUID(){\r\n    return correctedMessageUID;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.PresenceFilter.isShowOffline",
	"Comment": "returns true if offline contacts are shown, otherwise returnsfalse.",
	"Method": "boolean isShowOffline(){\r\n    return isShowOffline;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.notificationwiring.NotificationWiringActivator.getResources",
	"Comment": "returns the resourcemanagementservice, through which we willaccess all resources.",
	"Method": "ResourceManagementService getResources(){\r\n    if (resourcesService == null) {\r\n        resourcesService = ServiceUtils.getService(bundleContext, ResourceManagementService.class);\r\n    }\r\n    return resourcesService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chatroomslist.ChatRoomTableDialog.setChatRoomField",
	"Comment": "sets the value of chat room name field in the currentchatroomtabledialog instance.",
	"Method": "void setChatRoomField(String chatRoom){\r\n    if (chatRoomTableDialog != null) {\r\n        chatRoomTableDialog.setChatRoomNameField(chatRoom);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.sip.TestOperationSetBasicInstantMessaging.thenTestSendMessage",
	"Comment": "send an instant message from the tester agent and assert reception bythe tested implementation",
	"Method": "void thenTestSendMessage(){\r\n    String body = \"This is an IM coming from the tested implementation\" + \" on \" + new Date().toString();\r\n    net.java.sip.communicator.service.protocol.Message msg = opSetBasicIM1.createMessage(body);\r\n    ImEventCollector imEvtCollector1 = new ImEventCollector();\r\n    opSetBasicIM1.addMessageListener(imEvtCollector1);\r\n    ImEventCollector imEvtCollector2 = new ImEventCollector();\r\n    opSetBasicIM2.addMessageListener(imEvtCollector2);\r\n    Contact testerAgentContact = opSetPresence1.findContactByID(fixture.userID2);\r\n    logger.debug(\"Will send message \" + body + \" to: \" + testerAgentContact.getAddress());\r\n    opSetBasicIM1.sendInstantMessage(testerAgentContact, msg);\r\n    imEvtCollector1.waitForEvent(10000);\r\n    imEvtCollector2.waitForEvent(10000);\r\n    opSetBasicIM1.removeMessageListener(imEvtCollector1);\r\n    opSetBasicIM2.removeMessageListener(imEvtCollector2);\r\n    assertTrue(\"No events delivered when sending a message\", imEvtCollector1.collectedEvents.size() > 0);\r\n    assertTrue(\"Received evt was not an instance of \" + MessageDeliveredEvent.class.getName(), imEvtCollector1.collectedEvents.get(0) instanceof MessageDeliveredEvent);\r\n    MessageDeliveredEvent evt = (MessageDeliveredEvent) imEvtCollector1.collectedEvents.get(0);\r\n    assertEquals(\"message destination \", evt.getDestinationContact().getAddress(), fixture.userID2);\r\n    assertSame(\"source message\", msg, evt.getSourceMessage());\r\n    assertTrue(\"No messages received by the tester agent\", imEvtCollector2.collectedEvents.size() > 0);\r\n    String receivedBody = ((MessageReceivedEvent) imEvtCollector2.collectedEvents.get(0)).getSourceMessage().getContent();\r\n    assertEquals(\"received message body\", msg.getContent(), receivedBody);\r\n    try {\r\n        synchronized (this) {\r\n            wait(5000);\r\n        }\r\n    } catch (InterruptedException e) {\r\n        logger.debug(\"the second test's wait has been interrupted, the \" + \"following test may fail\", e);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.otr.authdialog.OTRv3OutgoingSessionSwitcher.updateEnableStatus",
	"Comment": "sets the menu visibility. the menu is visible as soon as itcontains two or more items. if it is empty, it is invisible.",
	"Method": "void updateEnableStatus(){\r\n    this.menu.setEnabled(this.menu.getItemCount() > 1);\r\n    this.menu.setVisible(true);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.neomedia.NeomediaActivator.getFileAccessService",
	"Comment": "returns a reference to a fileaccessservice implementationcurrently registered in the bundle context or null if no suchimplementation was found.",
	"Method": "FileAccessService getFileAccessService(){\r\n    if (fileAccessService == null) {\r\n        fileAccessService = ServiceUtils.getService(bundleContext, FileAccessService.class);\r\n    }\r\n    return fileAccessService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.caps.EntityCapsManager.capsToHash",
	"Comment": "computes and returns the hash of the specified capsstring usingthe specified hashalgorithm.",
	"Method": "String capsToHash(String hashAlgorithm,String capsString){\r\n    try {\r\n        MessageDigest md = MessageDigest.getInstance(hashAlgorithm);\r\n        byte[] digest = md.digest(capsString.getBytes());\r\n        return Base64.encodeBytes(digest);\r\n    } catch (NoSuchAlgorithmException nsae) {\r\n        logger.error(\"Unsupported XEP-0115: Entity Capabilities hash algorithm: \" + hashAlgorithm);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageSourceContact.getContactDetails",
	"Comment": "returns a list of all contactdetails corresponding to the givencategory.",
	"Method": "List<ContactDetail> getContactDetails(List<ContactDetail> getContactDetails,Class<? extends OperationSet> operationSet,List<ContactDetail> getContactDetails,ContactDetail.Category category){\r\n    throw new OperationNotSupportedException(\"Categories are not supported for message source contact history.\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractOperationSetTypingNotifications.fireTypingNotificationsEvent",
	"Comment": "delivers a typingnotificationevent to all registered listeners.",
	"Method": "void fireTypingNotificationsEvent(Contact sourceContact,int evtCode){\r\n    TypingNotificationsListener[] listeners;\r\n    synchronized (typingNotificationsListeners) {\r\n        listeners = typingNotificationsListeners.toArray(new TypingNotificationsListener[typingNotificationsListeners.size()]);\r\n    }\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Dispatching a TypingNotificationEvent to \" + listeners.length + \" listeners. Contact \" + sourceContact.getAddress() + \" has now a typing status of \" + evtCode);\r\n    TypingNotificationEvent evt = new TypingNotificationEvent(sourceContact, evtCode);\r\n    for (TypingNotificationsListener listener : listeners) listener.typingNotificationReceived(evt);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.MetaContactListSource.isContactActionVisible",
	"Comment": "indicates if the given contactaction should be visible for thegiven metacontact.",
	"Method": "boolean isContactActionVisible(ContactAction<Contact> contactAction,MetaContact metaContact){\r\n    Iterator<Contact> contactDetails = metaContact.getContacts();\r\n    while (contactDetails.hasNext()) {\r\n        if (contactAction.isVisible(contactDetails.next()))\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.ProtocolIconGibberishImpl.getConnectingIcon",
	"Comment": "returns the icon image used to represent the protocol connecting state.",
	"Method": "byte[] getConnectingIcon(){\r\n    return getImageInBytes(\"gibberishOnlineIcon\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ContactGroupJabberImpl.getParentContactGroup",
	"Comment": "returns a reference to the root group which in jabber is the parent ofany other group since the protocol does not support subgroups.",
	"Method": "ContactGroup getParentContactGroup(){\r\n    return ssclCallback.getRootGroup();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ContactIcqImpl.getImage",
	"Comment": "checks if an avatar or an image already exists for this contact andreturns it. this method does not perform any network operations.",
	"Method": "byte[] getImage(){\r\n    return image;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.RootContactGroupIcqImpl.reorderSubGroups",
	"Comment": "removes all contact sub groups and reinsterts them as specifiedby the neworder param. contact groups not contained in theneworder list are left at the end of this group.",
	"Method": "void reorderSubGroups(List<ContactGroupIcqImpl> newOrder){\r\n    subGroups.removeAll(newOrder);\r\n    subGroups.addAll(0, newOrder);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.CallPeerGibberishImpl.removeConferenceMembersSoundLevelListener",
	"Comment": "removes a specific soundlevellistener of thelist of listeners interested in and notified about changes in conferencemembers sound level.",
	"Method": "void removeConferenceMembersSoundLevelListener(ConferenceMembersSoundLevelListener listener){\r\n    synchronized (confMemebrSoundLevelListeners) {\r\n        confMemebrSoundLevelListeners.remove(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.dnsconfig.ParallelDnsPanel.updateDnssecState",
	"Comment": "update the ui based on whether dnssec is enabled. if dnssec is enabled,the parallel resolver is automatically disabled.",
	"Method": "void updateDnssecState(){\r\n    boolean isDnssec = configService.getBoolean(CustomResolver.PNAME_DNSSEC_RESOLVER_ENABLED, CustomResolver.PDEFAULT_DNSSEC_RESOLVER_ENABLED);\r\n    if (isDnssec)\r\n        chkBackupDnsEnabled.setSelected(false);\r\n    chkBackupDnsEnabled.setEnabled(!isDnssec);\r\n    updateButtonsState();\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.TestOperationSetPresence.testChangingStateToOnline",
	"Comment": "verify that changing state to online works as supposed to and that itgenerates the corresponding event.",
	"Method": "void testChangingStateToOnline(){\r\n    subtestStateTransition(JabberStatusEnum.AVAILABLE);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.UIContactImpl.getAvatar",
	"Comment": "gets the avatar of a specific uicontact in the form of animageicon value.",
	"Method": "byte[] getAvatar(){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallSipImpl.processExtraHeaders",
	"Comment": "a place where we can handle any headers we need for requestsand responses.",
	"Method": "void processExtraHeaders(javax.sip.message.Message message){\r\n    int extraHeaderIx = 1;\r\n    Object name = getData(EXTRA_HEADER_NAME + \".\" + extraHeaderIx);\r\n    while (name != null) {\r\n        Object value = getData(EXTRA_HEADER_VALUE + \".\" + extraHeaderIx);\r\n        Header header = getProtocolProvider().getHeaderFactory().createHeader((String) name, (String) value);\r\n        message.setHeader(header);\r\n        extraHeaderIx++;\r\n        name = getData(EXTRA_HEADER_NAME + \".\" + extraHeaderIx);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.callhistory.CallHistorySourceContact.getPreferredContactDetail",
	"Comment": "returns the preferred contactdetail for a givenoperationset class.",
	"Method": "ContactDetail getPreferredContactDetail(Class<? extends OperationSet> operationSet){\r\n    if (!(operationSet.equals(OperationSetBasicTelephony.class) || operationSet.equals(OperationSetPersistentPresence.class)))\r\n        return null;\r\n    return contactDetails.get(0);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.certconfig.CertConfigActivator.getCertService",
	"Comment": "returns a reference to a certificateservice implementation currentlyregistered in the bundle context or null if no such implementation wasfound.",
	"Method": "CertificateService getCertService(){\r\n    return ServiceUtils.getService(bundleContext, CertificateService.class);\r\n}"
}, {
	"Path": "design.RandomizedSet.remove",
	"Comment": "removes a value from the set. returns true if the set contained the specified element.",
	"Method": "boolean remove(int val){\r\n    if (map.containsKey(val)) {\r\n        int size = list.size();\r\n        int posVal = map.get(val);\r\n        if (posVal < (size - 1)) {\r\n            int last = list.get(size - 1);\r\n            map.put(last, posVal);\r\n            list.set(posVal, last);\r\n        }\r\n        map.remove(val);\r\n        list.remove(size - 1);\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.getFirstHistoryMsgTimestamp",
	"Comment": "returns the date of the first message in history for this chat.",
	"Method": "Date getFirstHistoryMsgTimestamp(){\r\n    return firstHistoryMsgTimestamp;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.sdp.SdpUtils.getContentAsString",
	"Comment": "gets the content of the specified sip message in the form of astring value.",
	"Method": "String getContentAsString(javax.sip.message.Message message){\r\n    byte[] rawContent = message.getRawContent();\r\n    ContentTypeHeader contentTypeHeader = (ContentTypeHeader) message.getHeader(ContentTypeHeader.NAME);\r\n    String charset = null;\r\n    if (contentTypeHeader != null)\r\n        charset = contentTypeHeader.getParameter(\"charset\");\r\n    if (charset == null)\r\n        charset = \"UTF-8\";\r\n    try {\r\n        return new String(rawContent, charset);\r\n    } catch (UnsupportedEncodingException uee) {\r\n        logger.warn(\"SIP message with unsupported charset of its content\", uee);\r\n        return new String(rawContent);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.TestOperationSetPersistentPresence.suite",
	"Comment": "creates a test suite containing all tests of this class followed bytest methods that we want executed in a specified order.",
	"Method": "Test suite(){\r\n    TestSuite suite = new TestSuite(TestOperationSetPersistentPresence.class);\r\n    suite.addTest(new TestOperationSetPersistentPresence(\"postTestCreateGroup\"));\r\n    suite.addTest(new TestOperationSetPersistentPresence(\"postTestRenameGroup\"));\r\n    suite.addTest(new TestOperationSetPersistentPresence(\"postTestRemoveGroup\"));\r\n    return suite;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.whiteboard.gui.whiteboardshapes.WhiteboardShape.getID",
	"Comment": "returns a string uniquely identifying this whiteboardshape.",
	"Method": "String getID(){\r\n    return this.id;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.notificationwiring.NotificationManager.typingNotificationReceived",
	"Comment": "informs the user what is the typing state of his chat contacts.",
	"Method": "void typingNotificationReceived(TypingNotificationEvent ev){\r\n    try {\r\n        Contact contact = ev.getSourceContact();\r\n        if (ev.getTypingState() != OperationSetTypingNotifications.STATE_TYPING) {\r\n            return;\r\n        }\r\n        UIService uiService = NotificationWiringActivator.getUIService();\r\n        if (uiService != null) {\r\n            Chat chat = uiService.getCurrentChat();\r\n            if (chat != null) {\r\n                MetaContact metaContact = uiService.getChatContact(chat);\r\n                if ((metaContact != null) && metaContact.containsContact(contact) && chat.isChatFocused()) {\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        long currentTime = System.currentTimeMillis();\r\n        if (proactiveTimer.size() > 0) {\r\n            Iterator<Map.Entry<Contact, Long>> entries = proactiveTimer.entrySet().iterator();\r\n            while (entries.hasNext()) {\r\n                Map.Entry<Contact, Long> entry = entries.next();\r\n                Long lastNotificationDate = entry.getValue();\r\n                if (lastNotificationDate.longValue() + 30000 < currentTime) {\r\n                    entries.remove();\r\n                }\r\n            }\r\n            if (proactiveTimer.containsKey(contact)) {\r\n                return;\r\n            }\r\n        }\r\n        proactiveTimer.put(contact, currentTime);\r\n        fireChatNotification(contact, PROACTIVE_NOTIFICATION, contact.getDisplayName(), NotificationWiringActivator.getResources().getI18NString(\"service.gui.PROACTIVE_NOTIFICATION\"), null);\r\n    } catch (Throwable t) {\r\n        if (t instanceof ThreadDeath)\r\n            throw (ThreadDeath) t;\r\n        else {\r\n            logger.error(\"An error occurred while handling\" + \" a typing notification.\", t);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetServerStoredAccountInfoIcqImpl.getDetails",
	"Comment": "returns an iterator over all details that are instances of exactly thesame class as the one specified.",
	"Method": "Iterator<GenericDetail> getDetails(Class<? extends GenericDetail> detailClass){\r\n    assertConnected();\r\n    if (detailClass.equals(ImageDetail.class)) {\r\n        List<GenericDetail> res = new Vector<GenericDetail>();\r\n        res.add(getImage());\r\n        return res.iterator();\r\n    }\r\n    return infoRetreiver.getDetails(uin, detailClass);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.RootContactGroupJabberImpl.toString",
	"Comment": "returns a string representation of the root contact group that containsall subgroups and subcontacts of this group.",
	"Method": "String toString(){\r\n    StringBuffer buff = new StringBuffer(getGroupName());\r\n    buff.append(\".subGroups=\" + countSubgroups() + \":\\n\");\r\n    Iterator<ContactGroup> subGroups = subgroups();\r\n    while (subGroups.hasNext()) {\r\n        ContactGroup group = subGroups.next();\r\n        buff.append(group.toString());\r\n        if (subGroups.hasNext())\r\n            buff.append(\"\\n\");\r\n    }\r\n    buff.append(\".rootContacts=\" + countContacts() + \":\\n\");\r\n    Iterator<Contact> contactsIter = contacts();\r\n    while (contactsIter.hasNext()) {\r\n        buff.append(contactsIter.next());\r\n        if (contactsIter.hasNext())\r\n            buff.append(\"\\n\");\r\n    }\r\n    return buff.toString();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommTextField.insertUpdate",
	"Comment": "handles the change when a char has been inserted in the field.",
	"Method": "void insertUpdate(DocumentEvent e){\r\n    if (!super.getText().equals(defaultText))\r\n        fireTextFieldChangeListener(0);\r\n    else\r\n        isDefaultTextVisible = true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler.start",
	"Comment": "starts this callpeermediahandler. if it has already beenstarted, does nothing.",
	"Method": "void start(){\r\n    if (logger.isInfoEnabled())\r\n        logger.info(\"Starting\");\r\n    MediaStream stream;\r\n    stream = getStream(MediaType.AUDIO);\r\n    if ((stream != null) && !stream.isStarted() && isLocalAudioTransmissionEnabled()) {\r\n        getTransportManager().setTrafficClass(stream.getTarget(), MediaType.AUDIO);\r\n        stream.start();\r\n        sendHolePunchPacket(stream, MediaType.AUDIO);\r\n    }\r\n    stream = getStream(MediaType.VIDEO);\r\n    if (stream != null) {\r\n        firePropertyChange(OperationSetVideoTelephony.LOCAL_VIDEO_STREAMING, null, videoDirectionUserPreference);\r\n        if (!stream.isStarted()) {\r\n            getTransportManager().setTrafficClass(stream.getTarget(), MediaType.VIDEO);\r\n            stream.start();\r\n            sendHolePunchPacket(stream, MediaType.VIDEO);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.AvatarCacheUtils.getLocallyStoredAvatar",
	"Comment": "returns the avatar image corresponding to the given avatar path.",
	"Method": "byte[] getLocallyStoredAvatar(String avatarPath){\r\n    try {\r\n        File avatarFile = UtilActivator.getFileAccessService().getPrivatePersistentFile(avatarPath, FileCategory.CACHE);\r\n        if (avatarFile.exists()) {\r\n            FileInputStream avatarInputStream = new FileInputStream(avatarFile);\r\n            byte[] bs = null;\r\n            try {\r\n                int available = avatarInputStream.available();\r\n                if (available > 0) {\r\n                    bs = new byte[available];\r\n                    avatarInputStream.read(bs);\r\n                }\r\n            } finally {\r\n                avatarInputStream.close();\r\n            }\r\n            if (bs != null)\r\n                return bs;\r\n        }\r\n    } catch (Exception ex) {\r\n        logger.error(\"Could not read avatar image from file \" + avatarPath, ex);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.notifsource.NotificationGroup.getDisplayName",
	"Comment": "the display name of the group. the display name is the name to be shownin the contact list group row.",
	"Method": "String getDisplayName(){\r\n    return groupName;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.security.CredentialsCache.getRealms",
	"Comment": "returns the list of realms that branchid has been used toauthenticate against.",
	"Method": "List<String> getRealms(String branchID){\r\n    List<String> realms = new LinkedList<String>();\r\n    Iterator<Entry<String, CredentialsCacheEntry>> credentials = authenticatedRealms.entrySet().iterator();\r\n    while (credentials.hasNext()) {\r\n        Entry<String, CredentialsCacheEntry> entry = credentials.next();\r\n        if (entry.getValue().containsBranchID(branchID))\r\n            realms.add(entry.getKey());\r\n    }\r\n    return realms;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AccountID.isEncryptionProtocolEnabled",
	"Comment": "returns if the encryption protocol given in parameter is enabled.",
	"Method": "boolean isEncryptionProtocolEnabled(SrtpControlType type){\r\n    boolean defaultValue = type == SrtpControlType.ZRTP;\r\n    return getAccountPropertyBoolean(ProtocolProviderFactory.ENCRYPTION_PROTOCOL_STATUS + \".\" + type.toString(), defaultValue);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.version.VersionImpl.customVersion",
	"Comment": "returns the versionimpl instance describing the version with theparameters supplied.",
	"Method": "VersionImpl customVersion(int majorVersion,int minorVersion,String nightlyBuildID){\r\n    return new VersionImpl(majorVersion, minorVersion, nightlyBuildID);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.icqaccregwizz.IcqAccountRegistrationWizard.getProtocolDescription",
	"Comment": "returns a short description of the protocol that will be shown on theright of the protocol name in the list, where user will choose theprotocol to register to.",
	"Method": "String getProtocolDescription(){\r\n    return Resources.getString(\"plugin.icqaccregwizz.PROTOCOL_DESCRIPTION\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractContact.isMobile",
	"Comment": "whether contact is mobile one. logged in only from mobile device.",
	"Method": "boolean isMobile(){\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.ChooseCallAccountPopupMenu.getI18NKeyCallVia",
	"Comment": "returns the key to use for choose contact string. can be overriddenby extenders.",
	"Method": "String getI18NKeyCallVia(){\r\n    return \"service.gui.CALL_VIA\";\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.ExtendedTransferHandler.createTransferable",
	"Comment": "creates a transferable for text pane components in order to enable dragand drop of text.",
	"Method": "Transferable createTransferable(JComponent component){\r\n    if ((component instanceof JTextPane || component instanceof JTextField)) {\r\n        return new SelectedTextTransferable((JTextComponent) component);\r\n    }\r\n    return super.createTransferable(component);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.GroupRightButtonMenu.pluginComponentAdded",
	"Comment": "indicates that a new plugin component has been added. adds it to thiscontainer if it belongs to it.",
	"Method": "void pluginComponentAdded(PluginComponentEvent event){\r\n    PluginComponentFactory factory = event.getPluginComponentFactory();\r\n    if (!factory.getContainer().equals(Container.CONTAINER_GROUP_RIGHT_BUTTON_MENU))\r\n        return;\r\n    PluginComponent c = factory.getPluginComponentInstance(this);\r\n    this.add((Component) c.getComponent());\r\n    c.setCurrentContactGroup(group);\r\n    this.repaint();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ProtocolProviderServiceJabberImpl.getTrustManager",
	"Comment": "gets the trustmanager that should be used for the specified service",
	"Method": "X509ExtendedTrustManager getTrustManager(CertificateService cvs,String serviceName){\r\n    return new HostTrustManager(cvs.getTrustManager(Arrays.asList(new String[] { serviceName, \"_xmpp-client.\" + serviceName })));\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.chatalerter.ChatAlerterActivator.handleProviderRemoved",
	"Comment": "removes the specified provider from the list of currently known providersand ignores all the messages exchanged by it",
	"Method": "void handleProviderRemoved(ProtocolProviderService provider){\r\n    OperationSetBasicInstantMessaging opSetIm = provider.getOperationSet(OperationSetBasicInstantMessaging.class);\r\n    if (opSetIm != null) {\r\n        opSetIm.removeMessageListener(this);\r\n    }\r\n    OperationSetSmsMessaging opSetSms = provider.getOperationSet(OperationSetSmsMessaging.class);\r\n    if (opSetSms != null) {\r\n        opSetSms.removeMessageListener(this);\r\n    }\r\n    OperationSetMultiUserChat opSetMultiUChat = provider.getOperationSet(OperationSetMultiUserChat.class);\r\n    if (opSetMultiUChat != null) {\r\n        for (ChatRoom room : opSetMultiUChat.getCurrentlyJoinedChatRooms()) room.removeMessageListener(this);\r\n    }\r\n    OperationSetBasicTelephony<?> basicTelephonyOpSet = provider.getOperationSet(OperationSetBasicTelephony.class);\r\n    if (basicTelephonyOpSet != null) {\r\n        basicTelephonyOpSet.removeCallListener(this);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.MessageDialog.actionPerformed",
	"Comment": "handles the actionevent. depending on the user choice setsthe return code to the appropriate value.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    JButton button = (JButton) e.getSource();\r\n    if (button.equals(okButton)) {\r\n        if (doNotAskAgain.isSelected()) {\r\n            this.returnCode = OK_DONT_ASK_CODE;\r\n        } else {\r\n            this.returnCode = OK_RETURN_CODE;\r\n        }\r\n    } else {\r\n        this.returnCode = CANCEL_RETURN_CODE;\r\n    }\r\n    this.dispose();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.notificationconfiguration.NotificationEntry.getSoundNotification",
	"Comment": "method which returns if one sound is to be played on notification device.",
	"Method": "boolean getSoundNotification(){\r\n    return this.soundNotification;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.version.VersionActivator.getConfigurationService",
	"Comment": "gets a configurationservice implementation currentlyregistered in the bundlecontext in which this bundle has beenstarted or null if no such implementation was found.",
	"Method": "ConfigurationService getConfigurationService(){\r\n    return ServiceUtils.getService(bundleContext, ConfigurationService.class);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.InfoRetreiver.getContactDetails",
	"Comment": "request the full info for the given contactaddresswaits and return this details",
	"Method": "List<GenericDetail> getContactDetails(String contactAddress){\r\n    List<GenericDetail> result = getCachedContactDetails(contactAddress);\r\n    if (result == null) {\r\n        return retrieveDetails(contactAddress);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.toolBars.MainToolBar.setCallButtonsName",
	"Comment": "sets the names of the call buttons depending on the chat session type.",
	"Method": "void setCallButtonsName(){\r\n    if (chatSession instanceof ConferenceChatSession) {\r\n        callButton.setName(\"createConference\");\r\n        callVideoButton.setName(\"createConference\");\r\n        this.callButton.setToolTipText(GuiActivator.getResources().getI18NString(\"service.gui.CREATE_JOIN_VIDEO_CONFERENCE\"));\r\n        this.callVideoButton.setToolTipText(GuiActivator.getResources().getI18NString(\"service.gui.CREATE_JOIN_VIDEO_CONFERENCE\"));\r\n    } else {\r\n        callButton.setName(\"call\");\r\n        callVideoButton.setName(\"callVideo\");\r\n        this.callButton.setToolTipText(GuiActivator.getResources().getI18NString(\"service.gui.CALL_CONTACT\"));\r\n        this.callVideoButton.setToolTipText(GuiActivator.getResources().getI18NString(\"service.gui.CALL_CONTACT\"));\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ContactProtocolButton.getProtocolContact",
	"Comment": "returns the specific protocol contact corresponding to this button.",
	"Method": "Contact getProtocolContact(){\r\n    return protocolContact;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.TreeContactList.getContacts",
	"Comment": "returns a collection of all direct child uicontacts of the givenuigroup.",
	"Method": "Collection<UIContact> getContacts(UIGroup group){\r\n    if (group != null && !(group instanceof UIGroupImpl))\r\n        return null;\r\n    GroupNode groupNode;\r\n    if (group == null)\r\n        groupNode = treeModel.getRoot();\r\n    else {\r\n        synchronized (group) {\r\n            groupNode = ((UIGroupImpl) group).getGroupNode();\r\n        }\r\n    }\r\n    if (groupNode == null)\r\n        return null;\r\n    Collection<ContactNode> contactNodes = groupNode.getContacts();\r\n    if (contactNodes == null)\r\n        return null;\r\n    Collection<UIContact> childContacts = new ArrayList<UIContact>();\r\n    Iterator<ContactNode> contactNodesIter = contactNodes.iterator();\r\n    while (contactNodesIter.hasNext()) {\r\n        childContacts.add(contactNodesIter.next().getContactDescriptor());\r\n    }\r\n    return childContacts;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.replacement.directimage.DirectImageActivator.getConfigService",
	"Comment": "returns a reference to a configurationservice implementation currently registered in the bundle context or null if no such implementation was found.",
	"Method": "ConfigurationService getConfigService(){\r\n    if (confService == null) {\r\n        ServiceReference confReference = bundleContext.getServiceReference(ConfigurationService.class.getName());\r\n        confService = (ConfigurationService) bundleContext.getService(confReference);\r\n    }\r\n    return confService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.update.UpdateActivator.getConfiguration",
	"Comment": "returns the configurationservice obtained from the bundlecontext.",
	"Method": "ConfigurationService getConfiguration(){\r\n    if (configuration == null) {\r\n        configuration = ServiceUtils.getService(bundleContext, ConfigurationService.class);\r\n    }\r\n    return configuration;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.MetaUIGroup.getSourceIndex",
	"Comment": "returns the index of the underlying metacontactgroup in itsmetacontactlistservice parent group.",
	"Method": "int getSourceIndex(){\r\n    MetaContactGroup parentGroup = metaGroup.getParentMetaContactGroup();\r\n    return GuiActivator.getContactList().getMetaContactListSource().getIndex() * MAX_GROUPS + ((parentGroup == null) ? 0 : (parentGroup.indexOf(metaGroup) + 1)) * MAX_CONTACTS;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallPanel.contactPresenceStatusChanged",
	"Comment": "listens for contact status changes and updates the image of thechat message button.",
	"Method": "void contactPresenceStatusChanged(ContactPresenceStatusChangeEvent evt){\r\n    Contact contact = getIMCapableCallPeers(1).get(0);\r\n    if (contact != null && contact.equals(evt.getSourceContact())) {\r\n        chatButton.setIconImage(Constants.getMessageStatusIcon(contact.getPresenceStatus()));\r\n        chatButton.repaint();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatTransport.getName",
	"Comment": "returns the contact address corresponding to this chat transport.",
	"Method": "String getName(){\r\n    return chatRoom.getName();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetExtendedAuthorizationsIcqImpl.assertConnected",
	"Comment": "utility method throwing an exception if the icq stack is not properlyinitialized.",
	"Method": "void assertConnected(){\r\n    if (icqProvider == null)\r\n        throw new IllegalStateException(\"The icq provider must be non-null and signed on the ICQ \" + \"service before being able to communicate.\");\r\n    if (!icqProvider.isRegistered())\r\n        throw new IllegalStateException(\"The icq provider must be signed on the ICQ service before \" + \"being able to communicate.\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl.validateContactAddress",
	"Comment": "validates the contact identifier and returns an error message ifapplicable and a suggested correction",
	"Method": "boolean validateContactAddress(String contactId,List<String> result){\r\n    if (result == null) {\r\n        throw new IllegalArgumentException(\"result must be an empty list\");\r\n    }\r\n    result.clear();\r\n    try {\r\n        Address address = parseAddressString(contactId);\r\n        if (address.toString().equals(contactId)) {\r\n            return true;\r\n        } else if (((SipUri) address.getURI()).getUser().equals(contactId)) {\r\n            return true;\r\n        } else if (address.toString().equals(address.getURI().getScheme() + \":\" + contactId)) {\r\n            return true;\r\n        } else {\r\n            result.add(SipActivator.getResources().getI18NString(\"impl.protocol.sip.INVALID_ADDRESS\", new String[] { contactId }));\r\n            result.add(((SipUri) address.getURI()).getUser());\r\n        }\r\n    } catch (Exception ex) {\r\n        logger.error(\"Validating SIP address failed for \" + contactId, ex);\r\n        result.add(SipActivator.getResources().getI18NString(\"impl.protocol.sip.INVALID_ADDRESS\", new String[] { contactId }));\r\n        String user = contactId;\r\n        String remainder = \"\";\r\n        int at = contactId.indexOf('@');\r\n        if (at > -1) {\r\n            user = contactId.substring(0, at);\r\n            remainder = contactId.substring(at);\r\n        }\r\n        String banned = \"([^a-z0-9-_.!~*'()&=+$,;?/])+\";\r\n        result.add(user.replaceAll(banned, \"\") + remainder);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.ContactPropertyChangeEvent.getSourceContact",
	"Comment": "returns a reference to the contact whose property has changed.",
	"Method": "Contact getSourceContact(){\r\n    return (Contact) getSource();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.CallPeerJabberImpl.processColibriConferenceIQ",
	"Comment": "notifies this instance that a specific colibriconferenceiq hasbeen received. this callpeerjabberimpl uses the part of theinformation provided in the specified conferenceiq whichconcerns it only.",
	"Method": "void processColibriConferenceIQ(ColibriConferenceIQ conferenceIQ){\r\n    getMediaHandler().processColibriConferenceIQ(conferenceIQ);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.contactlist.event.MetaContactAvatarUpdateEvent.getNewAvatar",
	"Comment": "returns the updated avatar of the source meta contact as it is now, afterthe change.",
	"Method": "byte[] getNewAvatar(){\r\n    return (byte[]) getNewValue();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipActivator.getNetworkAddressManagerService",
	"Comment": "returns a reference to a networkaddressmanagerservice implementationcurrently registered in the bundle context or null if no suchimplementation was found.",
	"Method": "NetworkAddressManagerService getNetworkAddressManagerService(){\r\n    if (networkAddressManagerService == null) {\r\n        ServiceReference confReference = bundleContext.getServiceReference(NetworkAddressManagerService.class.getName());\r\n        networkAddressManagerService = (NetworkAddressManagerService) bundleContext.getService(confReference);\r\n    }\r\n    return networkAddressManagerService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.ircaccregwizz.IrcAccRegWizzActivator.getIrcProtocolProviderFactory",
	"Comment": "returns the protocolproviderfactory for the irc protocol.",
	"Method": "ProtocolProviderFactory getIrcProtocolProviderFactory(){\r\n    ServiceReference<?>[] serRefs = null;\r\n    String osgiFilter = \"(\" + ProtocolProviderFactory.PROTOCOL + \"=IRC)\";\r\n    try {\r\n        serRefs = bundleContext.getServiceReferences(ProtocolProviderFactory.class.getName(), osgiFilter);\r\n    } catch (InvalidSyntaxException ex) {\r\n        logger.error(ex);\r\n    }\r\n    return (ProtocolProviderFactory) bundleContext.getService(serRefs[0]);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.connectioninfo.ConnectionInfoPanel.serviceChanged",
	"Comment": "handles registration and unregistration ofprotocolproviderservice",
	"Method": "void serviceChanged(ServiceEvent event){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                serviceChanged(event);\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    Object service = ConnectionInfoActivator.bundleContext.getService(event.getServiceReference());\r\n    if (!(service instanceof ProtocolProviderService))\r\n        return;\r\n    ProtocolProviderService protocolProvider = (ProtocolProviderService) service;\r\n    if (event.getType() == ServiceEvent.REGISTERED) {\r\n        if (accountsTable.get(protocolProvider.getAccountID()) == null) {\r\n            ConnectionDetailsPanel panel = new ConnectionDetailsPanel(dialog, protocolProvider);\r\n            accountsTable.put(protocolProvider.getAccountID(), panel);\r\n            accountsComboBox.addItem(panel);\r\n            protocolProvider.addRegistrationStateChangeListener(this);\r\n        }\r\n    } else if (event.getType() == ServiceEvent.UNREGISTERING) {\r\n        ConnectionDetailsPanel panel = accountsTable.get(protocolProvider.getAccountID());\r\n        if (panel != null) {\r\n            accountsTable.remove(protocolProvider.getAccountID());\r\n            accountsComboBox.removeItem(panel);\r\n            if (currentDetailsPanel == panel) {\r\n                currentDetailsPanel = null;\r\n                centerPanel.removeAll();\r\n                centerPanel.revalidate();\r\n                centerPanel.repaint();\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.connectioninfo.ConnectionInfoPanel.serviceChanged",
	"Comment": "handles registration and unregistration ofprotocolproviderservice",
	"Method": "void serviceChanged(ServiceEvent event){\r\n    serviceChanged(event);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.history.HistoryReaderImpl.findByKeywords",
	"Comment": "searches the history for all records containing all keywords.",
	"Method": "QueryResultSet<HistoryRecord> findByKeywords(String[] keywords,String field,QueryResultSet<HistoryRecord> findByKeywords,String[] keywords,String field,boolean caseSensitive){\r\n    return find(null, null, keywords, field, caseSensitive);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.contactlist.TestMetaContactListPersistence.testCompleteContactListRestauration",
	"Comment": "register the remaining protocol providers and make sure that they too areproperly loaded inside the contact list. we also need to verify thatproto contacts that have been merged in a single meta contact are stillmerged.",
	"Method": "void testCompleteContactListRestauration(){\r\n    MclSlickFixture.mockP1ServiceRegistration = MetaContactListServiceLick.registerMockProviderService(MclSlickFixture.replacementMockP1);\r\n    MclSlickFixture.mockP2ServiceRegistration = MetaContactListServiceLick.registerMockProviderService(MclSlickFixture.replacementMockP2);\r\n    ContactGroup oldProtoMockP1Root = MclSlickFixture.mockP1.getOperationSet(OperationSetPersistentPresence.class).getServerStoredContactListRoot();\r\n    ContactGroup oldProtoMockP2Root = MclSlickFixture.mockP2.getOperationSet(OperationSetPersistentPresence.class).getServerStoredContactListRoot();\r\n    ContactGroup newProtoMockP1Root = MclSlickFixture.replacementMockP1.getOperationSet(OperationSetPersistentPresence.class).getServerStoredContactListRoot();\r\n    assertEquals(\"Newly loaded provider does not match the old one.\", oldProtoMockP1Root, newProtoMockP1Root);\r\n    ContactGroup newProtoMockP2Root = MclSlickFixture.replacementMockP2.getOperationSet(OperationSetPersistentPresence.class).getServerStoredContactListRoot();\r\n    assertEquals(\"Newly loaded provider does not match the old one.\", oldProtoMockP2Root, newProtoMockP2Root);\r\n    Iterator<ContactGroup> subgroups = newProtoMockP1Root.subgroups();\r\n    while (subgroups.hasNext()) {\r\n        assertUnresolvedContents(subgroups.next());\r\n    }\r\n    subgroups = newProtoMockP2Root.subgroups();\r\n    while (subgroups.hasNext()) {\r\n        assertUnresolvedContents(subgroups.next());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.OneToOneCallPanel.addDesktopSharingComponents",
	"Comment": "adds all desktop sharing related components to this container.",
	"Method": "void addDesktopSharingComponents(){\r\n    OperationSetDesktopSharingServer opSetDesktopSharingServer = callPeer.getProtocolProvider().getOperationSet(OperationSetDesktopSharingServer.class);\r\n    if (opSetDesktopSharingServer != null && opSetDesktopSharingServer.isRemoteControlAvailable(callPeer)) {\r\n        if (logger.isTraceEnabled())\r\n            logger.trace(\"Add desktop sharing related components.\");\r\n        if (enableDesktopRemoteControl == null) {\r\n            enableDesktopRemoteControl = new JCheckBox(GuiActivator.getResources().getI18NString(\"service.gui.ENABLE_DESKTOP_REMOTE_CONTROL\"));\r\n            southPanel = new TransparentPanel(new FlowLayout(FlowLayout.CENTER));\r\n            southPanel.add(enableDesktopRemoteControl);\r\n            enableDesktopRemoteControl.setAlignmentX(CENTER_ALIGNMENT);\r\n            enableDesktopRemoteControl.setOpaque(false);\r\n            enableDesktopRemoteControl.addItemListener(new ItemListener() {\r\n                public void itemStateChanged(ItemEvent e) {\r\n                    CallManager.enableDesktopRemoteControl(callPeer, e.getStateChange() == ItemEvent.SELECTED);\r\n                }\r\n            });\r\n        }\r\n        if (OSUtils.IS_MAC) {\r\n            southPanel.setOpaque(true);\r\n            southPanel.setBackground(new Color(GuiActivator.getResources().getColor(\"service.gui.MAC_PANEL_BACKGROUND\")));\r\n        }\r\n        add(southPanel, BorderLayout.SOUTH);\r\n    }\r\n    revalidate();\r\n    repaint();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.OneToOneCallPanel.addDesktopSharingComponents",
	"Comment": "adds all desktop sharing related components to this container.",
	"Method": "void addDesktopSharingComponents(){\r\n    CallManager.enableDesktopRemoteControl(callPeer, e.getStateChange() == ItemEvent.SELECTED);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.utils.Constants.loadSimpleStyle",
	"Comment": "temporary method to load the css style used in the chat window.",
	"Method": "void loadSimpleStyle(StyleSheet styleSheet,Font defaultFont){\r\n    Reader r = new BufferedReader(new InputStreamReader(GuiActivator.getResources().getSettingsInputStream(\"service.gui.HTML_TEXT_STYLE\")));\r\n    if (defaultFont != null)\r\n        styleSheet.addRule(\"body, div, h1, h2, h3, h4, h5, h6, h7, p, td, th { \" + \"font-family: \" + defaultFont.getName() + \"; font-size: \" + defaultFont.getSize() + \"pt; }\");\r\n    try {\r\n        styleSheet.loadRules(r, null);\r\n    } catch (IOException ex) {\r\n        logger.error(\"Failed to load CSS stream.\", ex);\r\n    } finally {\r\n        try {\r\n            r.close();\r\n        } catch (IOException ex) {\r\n            logger.error(\"Failed to close CSS stream.\", ex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallManager.getCallUIContact",
	"Comment": "returns the metacontact, to which the given callwas initially created.",
	"Method": "UIContactImpl getCallUIContact(Call call){\r\n    if (uiContactCalls != null)\r\n        return uiContactCalls.get(call);\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.getRoleDescription",
	"Comment": "returns the corresponding role description to the given role index.",
	"Method": "String getRoleDescription(ChatRoomMemberRole role){\r\n    String roleDescription = null;\r\n    switch(role) {\r\n        case OWNER:\r\n            roleDescription = GuiActivator.getResources().getI18NString(\"service.gui.OWNER\");\r\n            break;\r\n        case ADMINISTRATOR:\r\n            roleDescription = GuiActivator.getResources().getI18NString(\"service.gui.ADMINISTRATOR\");\r\n            break;\r\n        case MODERATOR:\r\n            roleDescription = GuiActivator.getResources().getI18NString(\"service.gui.MODERATOR\");\r\n            break;\r\n        case MEMBER:\r\n            roleDescription = GuiActivator.getResources().getI18NString(\"service.gui.MEMBER\");\r\n            break;\r\n        case GUEST:\r\n            roleDescription = GuiActivator.getResources().getI18NString(\"service.gui.GUEST\");\r\n            break;\r\n        case SILENT_MEMBER:\r\n            roleDescription = GuiActivator.getResources().getI18NString(\"service.gui.SILENT_MEMBER\");\r\n            break;\r\n        case OUTCAST:\r\n            roleDescription = GuiActivator.getResources().getI18NString(\"service.gui.BANNED\");\r\n            break;\r\n        default:\r\n            ;\r\n    }\r\n    return roleDescription;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetCusaxUtilsSipImpl.doesDetailBelong",
	"Comment": "checks if the given detailaddress exists in the givencontact details.",
	"Method": "boolean doesDetailBelong(Contact contact,String detailAddress){\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.whiteboard.gui.whiteboardshapes.WhiteboardShapeCircle.recalculateSelectionPoints",
	"Comment": "recalculates the selection points coordinates and adds the new selectionpoints to the list of selection points.",
	"Method": "void recalculateSelectionPoints(){\r\n    selectionPoints.clear();\r\n    selectionPoints.add(new WhiteboardPoint(whiteboardPoint.getX() - radius, whiteboardPoint.getY()));\r\n    selectionPoints.add(new WhiteboardPoint(whiteboardPoint.getX(), whiteboardPoint.getY() - radius));\r\n    selectionPoints.add(new WhiteboardPoint(whiteboardPoint.getX() + radius, whiteboardPoint.getY()));\r\n    selectionPoints.add(new WhiteboardPoint(whiteboardPoint.getX(), whiteboardPoint.getY() + radius));\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.SessionListenerTest.testListenerWithInvalidation",
	"Comment": "test that listeners are called when a session is deliberately invalidated.",
	"Method": "void testListenerWithInvalidation(){\r\n    String contextPath = \"\";\r\n    String servletMapping = \"/server\";\r\n    int inactivePeriod = 6;\r\n    int scavengePeriod = -1;\r\n    DefaultSessionCacheFactory cacheFactory = new DefaultSessionCacheFactory();\r\n    cacheFactory.setEvictionPolicy(SessionCache.NEVER_EVICT);\r\n    SessionDataStoreFactory storeFactory = new TestSessionDataStoreFactory();\r\n    ((AbstractSessionDataStoreFactory) storeFactory).setGracePeriodSec(scavengePeriod);\r\n    TestServer server = new TestServer(0, inactivePeriod, scavengePeriod, cacheFactory, storeFactory);\r\n    ServletContextHandler context = server.addContext(contextPath);\r\n    TestHttpSessionListener listener = new TestHttpSessionListener(true);\r\n    context.getSessionHandler().addEventListener(listener);\r\n    TestServlet servlet = new TestServlet();\r\n    ServletHolder holder = new ServletHolder(servlet);\r\n    context.addServlet(holder, servletMapping);\r\n    try {\r\n        server.start();\r\n        int port1 = server.getPort();\r\n        HttpClient client = new HttpClient();\r\n        client.start();\r\n        try {\r\n            String url = \"http://localhost:\" + port1 + contextPath + servletMapping;\r\n            ContentResponse response1 = client.GET(url + \"?action=init\");\r\n            assertEquals(HttpServletResponse.SC_OK, response1.getStatus());\r\n            String sessionCookie = response1.getHeaders().get(\"Set-Cookie\");\r\n            assertTrue(sessionCookie != null);\r\n            assertTrue(TestServlet.bindingListener.bound);\r\n            String sessionId = TestServer.extractSessionId(sessionCookie);\r\n            assertThat(sessionId, isIn(listener.createdSessions));\r\n            Request request2 = client.newRequest(url + \"?action=test\");\r\n            ContentResponse response2 = request2.send();\r\n            assertEquals(HttpServletResponse.SC_OK, response2.getStatus());\r\n            assertTrue(TestServlet.bindingListener.unbound);\r\n            assertTrue(listener.destroyedSessions.contains(sessionId));\r\n        } finally {\r\n            client.stop();\r\n        }\r\n    } finally {\r\n        server.stop();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.keybindingchooser.chooser.BindingChooser.setIndentStyle",
	"Comment": "sets content display in the indent field of entries. this will prompt anonupdate on all entries unless setting the style to none.",
	"Method": "void setIndentStyle(IndentStyle style){\r\n    this.indentStyle = style;\r\n    if (style == IndentStyle.NONE)\r\n        return;\r\n    ArrayList<BindingEntry> bindings = getBindings();\r\n    for (int i = 0; i < bindings.size(); ++i) {\r\n        onUpdate(i, bindings.get(i), false);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.SwingCallListener.onCallEventInEventDispatchThread",
	"Comment": "notifies this calllistener about a specific callevent.swingcalllistener invokes the method in the awt eventdispatching thread.",
	"Method": "void onCallEventInEventDispatchThread(CallEvent ev){\r\n    switch(ev.getEventID()) {\r\n        case CallEvent.CALL_ENDED:\r\n            callEndedInEventDispatchThread(ev);\r\n            break;\r\n        case CallEvent.CALL_INITIATED:\r\n            outgoingCallCreatedInEventDispatchThread(ev);\r\n            break;\r\n        case CallEvent.CALL_RECEIVED:\r\n            incomingCallReceivedInEventDispatchThread(ev);\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "io.lettuce.core.KqueueProvider.checkForKqueueLibrary",
	"Comment": "check whether the kqueue library is available on the class path.",
	"Method": "void checkForKqueueLibrary(){\r\n    LettuceAssert.assertState(KQUEUE_ENABLED, String.format(\"kqueue use is disabled via System properties (%s)\", KQUEUE_ENABLED_KEY));\r\n    LettuceAssert.assertState(isAvailable(), \"netty-transport-native-kqueue is not available. Make sure netty-transport-native-kqueue library on the class path and supported by your operating system.\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.removeChatContact",
	"Comment": "removes the given chatcontact from the list of chat contactsparticipating in the corresponding to this chat panel chat.",
	"Method": "void removeChatContact(ChatContact<?> chatContact){\r\n    if (chatContactListPanel != null)\r\n        chatContactListPanel.removeContact(chatContact);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.DesktopUtilActivator.getResources",
	"Comment": "returns the service giving access to all application resources.",
	"Method": "ResourceManagementService getResources(){\r\n    if (resourceService == null) {\r\n        resourceService = ResourceManagementServiceUtils.getService(bundleContext);\r\n    }\r\n    return resourceService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.globaldisplaydetails.GlobalStatusServiceImpl.getLastStatusString",
	"Comment": "returns the last contact status saved in the configuration.",
	"Method": "String getLastStatusString(ProtocolProviderService protocolProvider){\r\n    String lastStatus = null;\r\n    ConfigurationService configService = GlobalDisplayDetailsActivator.getConfigurationService();\r\n    String prefix = \"net.java.sip.communicator.impl.gui.accounts\";\r\n    List<String> accounts = configService.getPropertyNamesByPrefix(prefix, true);\r\n    String protocolProviderAccountUID = protocolProvider.getAccountID().getAccountUniqueID();\r\n    for (String accountRootPropName : accounts) {\r\n        String accountUID = configService.getString(accountRootPropName);\r\n        if (accountUID.equals(protocolProviderAccountUID)) {\r\n            lastStatus = configService.getString(accountRootPropName + \".lastAccountStatus\");\r\n            if (lastStatus != null)\r\n                break;\r\n        }\r\n    }\r\n    return lastStatus;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.BandwidthPacketExtension.setType",
	"Comment": "sets the value of the optional type argument in thebandwidth element.",
	"Method": "void setType(String type){\r\n    setAttribute(TYPE_ATTR_NAME, type);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.SourceUIContact.getStatusIcon",
	"Comment": "returns null to indicate unknown status of the underlyingsourcecontact.",
	"Method": "ImageIcon getStatusIcon(){\r\n    PresenceStatus status = sourceContact.getPresenceStatus();\r\n    if (status != null)\r\n        return new ImageIcon(Constants.getStatusIcon(status));\r\n    return new ImageIcon(GlobalStatusEnum.OFFLINE.getStatusIcon());\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.WhiteboardParticipantChangeEvent.toString",
	"Comment": "returns a string representation of this whiteboardparticipantchangeevent.",
	"Method": "String toString(){\r\n    return \"WhiteboardParticipantChangeEvent: type=\" + getEventType() + \" oldV=\" + getOldValue() + \" newV=\" + getNewValue() + \" for participant=\" + getSourceWhiteboardParticipant();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.JabberAccountRegistrationWizard.getIcon",
	"Comment": "implements the accountregistrationwizard.geticon method.returns the icon to be used for this wizard.",
	"Method": "byte[] getIcon(){\r\n    return Resources.getImage(Resources.PROTOCOL_ICON);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaAwareCall.propertyChange",
	"Comment": "notifies this instance about a change of the value of a specific propertyfrom a specific old value to a specific new value.",
	"Method": "void propertyChange(PropertyChangeEvent ev){\r\n    if (ev.getSource() instanceof CallConference) {\r\n        String propertyName = ev.getPropertyName();\r\n        if (CONFERENCE_FOCUS.equals(propertyName)) {\r\n            conferenceFocusChanged((Boolean) ev.getOldValue(), (Boolean) ev.getNewValue());\r\n        } else if (DEFAULT_DEVICE.equals(propertyName)) {\r\n            firePropertyChange(DEFAULT_DEVICE, ev.getOldValue(), ev.getNewValue());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.common.extensions.FragmentExtensionTest.testLargeSmallTextAlternating",
	"Comment": "ensure that fragmentextension honors the correct order of websocket frames.",
	"Method": "void testLargeSmallTextAlternating(){\r\n    final int largeMessageSize = 60000;\r\n    byte[] buf = new byte[largeMessageSize];\r\n    Arrays.fill(buf, (byte) 'x');\r\n    String largeMessage = new String(buf, UTF_8);\r\n    final int fragmentCount = 10;\r\n    final int fragmentLength = largeMessageSize / fragmentCount;\r\n    final int messageCount = 10000;\r\n    FragmentExtension ext = new FragmentExtension();\r\n    ext.setBufferPool(bufferPool);\r\n    ext.setPolicy(WebSocketPolicy.newServerPolicy());\r\n    ExtensionConfig config = ExtensionConfig.parse(\"fragment;maxLength=\" + fragmentLength);\r\n    ext.setConfig(config);\r\n    SaneFrameOrderingAssertion saneFrameOrderingAssertion = new SaneFrameOrderingAssertion();\r\n    ext.setNextOutgoingFrames(saneFrameOrderingAssertion);\r\n    CompletableFuture<Integer> enqueuedFrameCountFut = new CompletableFuture();\r\n    CompletableFuture.runAsync(() -> {\r\n        int frameCount = 0;\r\n        BatchMode batchMode = BatchMode.OFF;\r\n        try {\r\n            for (int i = 0; i < messageCount; i++) {\r\n                int messageId = i;\r\n                FutureWriteCallback callback = new FutureWriteCallback();\r\n                WebSocketFrame frame;\r\n                if (i % 2 == 0) {\r\n                    frame = new TextFrame().setPayload(largeMessage);\r\n                    frameCount += fragmentCount;\r\n                } else {\r\n                    frame = new TextFrame().setPayload(\"Short Message: \" + i);\r\n                    frameCount++;\r\n                }\r\n                ext.outgoingFrame(frame, callback, batchMode);\r\n                callback.get();\r\n            }\r\n            enqueuedFrameCountFut.complete(frameCount);\r\n        } catch (Throwable t) {\r\n            enqueuedFrameCountFut.completeExceptionally(t);\r\n        }\r\n    });\r\n    int enqueuedFrameCount = enqueuedFrameCountFut.get(5, SECONDS);\r\n    int expectedFrameCount = (messageCount / 2) * fragmentCount;\r\n    expectedFrameCount += (messageCount / 2);\r\n    assertThat(\"Saw expected frame count\", saneFrameOrderingAssertion.frameCount, is(expectedFrameCount));\r\n    assertThat(\"Enqueued expected frame count\", enqueuedFrameCount, is(expectedFrameCount));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetExtendedAuthorizationsIcqImpl.getSubscriptionStatus",
	"Comment": "returns the subscription status for the contact orif not available returns null.",
	"Method": "SubscriptionStatus getSubscriptionStatus(Contact contact){\r\n    if (contact == null || !(contact instanceof ContactIcqImpl))\r\n        throw new IllegalArgumentException(\"Argument is not an icq contact (contact=\" + contact + \")\");\r\n    if (((ContactIcqImpl) contact).getJoustSimBuddy().isAwaitingAuthorization()) {\r\n        return SubscriptionStatus.SubscriptionPending;\r\n    } else {\r\n        return SubscriptionStatus.Subscribed;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.UINotificationGroup.getGroupName",
	"Comment": "returns the name of the group, to which this notification belongs.",
	"Method": "String getGroupName(){\r\n    return groupName;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.account.LoginManager.handleAccountManagerEvent",
	"Comment": "notifies that the loading of the stored accounts of aspecific protocolproviderfactory has finished.",
	"Method": "void handleAccountManagerEvent(AccountManagerEvent event){\r\n    if (event.getType() == AccountManagerEvent.STORED_ACCOUNTS_LOADED) {\r\n        addAccountsForProtocolProviderFactory(event.getFactory());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.MetaContactListSource.getUIGroup",
	"Comment": "returns the uigroup corresponding to the givenmetacontactgroup.",
	"Method": "UIGroupImpl getUIGroup(MetaContactGroup metaGroup){\r\n    return (UIGroupImpl) metaGroup.getData(UI_GROUP_DATA_KEY);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.sdp.SdpUtils.createSessionUpdateDescription",
	"Comment": "creates and returns a new sessiondescription that is supposed toupdate our previous desctoupdate and advertise the brand newnewmediadescriptions. the method also respects other 3264policies like reusing the origin field and augmenting its version number,for example.",
	"Method": "SessionDescription createSessionUpdateDescription(SessionDescription descToUpdate,InetAddress newConnectionAddress,List<MediaDescription> newMediaDescriptions){\r\n    SessionDescription update = createSessionDescription(newConnectionAddress, null, newMediaDescriptions);\r\n    try {\r\n        Origin o = (Origin) descToUpdate.getOrigin().clone();\r\n        long version = o.getSessionVersion();\r\n        o.setSessionVersion(version + 1);\r\n        update.setOrigin(o);\r\n    } catch (Exception e) {\r\n        if (logger.isInfoEnabled())\r\n            logger.info(\"Something very odd just happened.\", e);\r\n    }\r\n    Vector<MediaDescription> prevMedias = extractMediaDescriptions(descToUpdate);\r\n    Vector<MediaDescription> completeMediaDescList = new Vector<MediaDescription>();\r\n    newMediaDescriptions = new Vector<MediaDescription>(newMediaDescriptions);\r\n    for (MediaDescription medToUpdate : prevMedias) {\r\n        MediaDescription desc = null;\r\n        try {\r\n            MediaType type = getMediaType(medToUpdate);\r\n            desc = removeMediaDesc(newMediaDescriptions, type);\r\n        } catch (IllegalArgumentException e) {\r\n        }\r\n        if (desc == null) {\r\n            desc = createDisablingAnswer(medToUpdate);\r\n        }\r\n        completeMediaDescList.add(desc);\r\n    }\r\n    for (MediaDescription medToAdd : newMediaDescriptions) {\r\n        completeMediaDescList.add(medToAdd);\r\n    }\r\n    try {\r\n        update.setMediaDescriptions(completeMediaDescList);\r\n    } catch (SdpException e) {\r\n        if (logger.isInfoEnabled())\r\n            logger.info(\"A crazy thing just happened.\", e);\r\n    }\r\n    return update;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractProtocolProviderService.clearSupportedOperationSet",
	"Comment": "removes all operationset implementation from the set ofsupported operationsets for this instance.",
	"Method": "void clearSupportedOperationSet(){\r\n    supportedOperationSets.clear();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl.getProtocolProvider",
	"Comment": "returns the protocol provider that this operation set belongs to.",
	"Method": "ProtocolProviderServiceSipImpl getProtocolProvider(){\r\n    return protocolProvider;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.AccountStatusPanel.getUIClassID",
	"Comment": "returns the name of the l&f class that renders this component.",
	"Method": "String getUIClassID(){\r\n    if (ConfigurationUtils.isTransparentWindowEnabled())\r\n        return uiClassID;\r\n    else\r\n        return super.getUIClassID();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.reconnectplugin.ReconnectPluginActivator.getConfigurationService",
	"Comment": "returns a reference to a configurationservice implementation currentlyregistered in the bundle context or null if no such implementation wasfound.",
	"Method": "ConfigurationService getConfigurationService(){\r\n    if (configurationService == null) {\r\n        ServiceReference confReference = bundleContext.getServiceReference(ConfigurationService.class.getName());\r\n        configurationService = (ConfigurationService) bundleContext.getService(confReference);\r\n    }\r\n    return configurationService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.collection.DynamicDifferenceSet.calculate",
	"Comment": "calculate the difference set based on the current state of the data.",
	"Method": "Set<E> calculate(){\r\n    final TreeSet<E> current;\r\n    synchronized (source) {\r\n        current = new TreeSet<E>(source);\r\n    }\r\n    synchronized (removals) {\r\n        current.removeAll(removals);\r\n    }\r\n    return current;\r\n}"
}, {
	"Path": "net.librec.recommender.cf.UserKNNTestCase.test08SplitterRatioRatingDate",
	"Comment": "test ratiodatasplitter with rating date ratio, evaluating enabled.",
	"Method": "void test08SplitterRatioRatingDate(){\r\n    Resource resource = new Resource(\"rec/cf/userknn-test.properties\");\r\n    conf.addResource(resource);\r\n    conf.set(\"rec.eval.enable\", \"true\");\r\n    conf.set(\"data.model.splitter\", \"ratio\");\r\n    conf.set(\"data.input.path\", \"test/datamodeltest/ratings-date.txt\");\r\n    conf.set(\"data.column.format\", \"UIRT\");\r\n    conf.set(\"data.splitter.ratio\", \"ratingdate\");\r\n    RecommenderJob job = new RecommenderJob(conf);\r\n    job.runJob();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.googlecontacts.GoogleContactsConnectionImpl.query",
	"Comment": "query for contacts using provided contactquery.executes query. in case of failure, refresh oauth2 token and retry query.if query fails again, throws failedcontactqueryexception.",
	"Method": "ContactFeed query(ContactQuery query){\r\n    try {\r\n        return this.googleService.query(query, ContactFeed.class);\r\n    } catch (NullPointerException e) {\r\n        logger.info(\"Executing query failed with NPE. \" + \"Refreshing access token and trying again.\");\r\n        this.store.refresh();\r\n    } catch (Exception e) {\r\n        logger.warn(\"Query failed with unexpected exception. Going to try \" + \"refreshing token anyways ...\", e);\r\n        this.store.refresh();\r\n    }\r\n    try {\r\n        return this.googleService.query(query, ContactFeed.class);\r\n    } catch (Exception e) {\r\n        throw new FailedContactQueryException(e);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetPersistentPresenceJabberImpl.publishPresenceStatus",
	"Comment": "requests the provider to enter into a status corresponding to thespecified parameters.",
	"Method": "void publishPresenceStatus(PresenceStatus status,String statusMessage){\r\n    assertConnected();\r\n    JabberStatusEnum jabberStatusEnum = parentProvider.getJabberStatusEnum();\r\n    boolean isValidStatus = false;\r\n    for (Iterator<PresenceStatus> supportedStatusIter = jabberStatusEnum.getSupportedStatusSet(); supportedStatusIter.hasNext(); ) {\r\n        if (supportedStatusIter.next().equals(status)) {\r\n            isValidStatus = true;\r\n            break;\r\n        }\r\n    }\r\n    if (!isValidStatus)\r\n        throw new IllegalArgumentException(status + \" is not a valid Jabber status\");\r\n    synchronized (ssContactList.getRosterInitLock()) {\r\n        if (!ssContactList.isRosterInitialized()) {\r\n            ssContactList.setInitialStatus(status);\r\n            ssContactList.setInitialStatusMessage(statusMessage);\r\n            return;\r\n        }\r\n    }\r\n    if (status.equals(jabberStatusEnum.getStatus(JabberStatusEnum.OFFLINE))) {\r\n        parentProvider.unregister();\r\n        clearLocalContactResources();\r\n    } else {\r\n        Presence presence = new Presence(Presence.Type.available);\r\n        currentPresence = presence;\r\n        presence.setMode(presenceStatusToJabberMode(status));\r\n        presence.setPriority(getPriorityForPresenceStatus(status.getStatusName()));\r\n        if (status.equals(jabberStatusEnum.getStatus(JabberStatusEnum.ON_THE_PHONE))) {\r\n            presence.setStatus(JabberStatusEnum.ON_THE_PHONE);\r\n        } else if (status.equals(jabberStatusEnum.getStatus(JabberStatusEnum.IN_A_MEETING))) {\r\n            presence.setStatus(JabberStatusEnum.IN_A_MEETING);\r\n        } else\r\n            presence.setStatus(statusMessage);\r\n        parentProvider.getConnection().sendPacket(presence);\r\n        if (localContact != null)\r\n            updateResource(localContact, parentProvider.getOurJID(), presence);\r\n    }\r\n    fireProviderStatusChangeEvent(currentStatus, status);\r\n    String oldStatusMessage = getCurrentStatusMessage();\r\n    if (!org.jitsi.util.StringUtils.isEquals(oldStatusMessage, statusMessage)) {\r\n        currentStatusMessage = statusMessage;\r\n        fireProviderStatusMessageChangeEvent(oldStatusMessage, getCurrentStatusMessage());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.globalshortcut.GlobalShortcutActivator.handleProviderRemoved",
	"Comment": "notifies this manager that a specificprotocolproviderservice has been unregistered as a service.",
	"Method": "void handleProviderRemoved(ProtocolProviderService provider){\r\n    OperationSetBasicTelephony<?> opSet = provider.getOperationSet(OperationSetBasicTelephony.class);\r\n    if (opSet != null)\r\n        opSet.removeCallListener(globalShortcutService.getCallShortcut());\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.chat.ChatOperationReasonDialog.updateOKButtonState",
	"Comment": "enables the ok button if reason field is not empty and disables it if thereason field is empty.",
	"Method": "void updateOKButtonState(){\r\n    okButton.setEnabled(!reasonField.getText().trim().equals(\"\"));\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.gui.event.MetaContactQuery.setInitialResultCount",
	"Comment": "sets the result count of this query. this method is meant to be used toset the initial result count which is before firing any events. theresult count would be then augmented each time the firequeryevent iscalled.",
	"Method": "void setInitialResultCount(int resultCount){\r\n    this.resultCount = resultCount;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.defaultresourcepack.DefaultResourcePackActivator.findResourcePaths",
	"Comment": "finds all properties files for the given path in this bundle.",
	"Method": "Iterator<String> findResourcePaths(String path,String pattern){\r\n    Iterator<String> bufferedResult = ressourcesFiles.get(path + pattern);\r\n    if (bufferedResult != null) {\r\n        return bufferedResult;\r\n    }\r\n    ArrayList<String> propertiesList = new ArrayList<String>();\r\n    @SuppressWarnings(\"unchecked\")\r\n    Enumeration<URL> propertiesUrls = bundleContext.getBundle().findEntries(path, pattern, false);\r\n    if (propertiesUrls != null) {\r\n        while (propertiesUrls.hasMoreElements()) {\r\n            URL propertyUrl = propertiesUrls.nextElement();\r\n            String propertyFilePath = propertyUrl.getPath().substring(1);\r\n            propertyFilePath = propertyFilePath.replaceAll(\"/\", \".\");\r\n            propertiesList.add(propertyFilePath);\r\n        }\r\n    }\r\n    Iterator<String> result = propertiesList.iterator();\r\n    ressourcesFiles.put(path + pattern, result);\r\n    return result;\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.common.extensions.FragmentExtensionTest.testIncomingFrames",
	"Comment": "verify that incoming frames are passed thru without modification",
	"Method": "void testIncomingFrames(){\r\n    IncomingFramesCapture capture = new IncomingFramesCapture();\r\n    FragmentExtension ext = new FragmentExtension();\r\n    ext.setBufferPool(bufferPool);\r\n    ext.setPolicy(WebSocketPolicy.newClientPolicy());\r\n    ExtensionConfig config = ExtensionConfig.parse(\"fragment;maxLength=4\");\r\n    ext.setConfig(config);\r\n    ext.setNextIncomingFrames(capture);\r\n    List<String> quote = new ArrayList();\r\n    quote.add(\"No amount of experimentation can ever prove me right;\");\r\n    quote.add(\"a single experiment can prove me wrong.\");\r\n    quote.add(\"-- Albert Einstein\");\r\n    for (String q : quote) {\r\n        Frame frame = new TextFrame().setPayload(q);\r\n        ext.incomingFrame(frame);\r\n    }\r\n    int len = quote.size();\r\n    capture.assertFrameCount(len);\r\n    capture.assertHasFrame(OpCode.TEXT, len);\r\n    String prefix;\r\n    int i = 0;\r\n    for (WebSocketFrame actual : capture.getFrames()) {\r\n        prefix = \"Frame[\" + i + \"]\";\r\n        assertThat(prefix + \".opcode\", actual.getOpCode(), is(OpCode.TEXT));\r\n        assertThat(prefix + \".fin\", actual.isFin(), is(true));\r\n        assertThat(prefix + \".rsv1\", actual.isRsv1(), is(false));\r\n        assertThat(prefix + \".rsv2\", actual.isRsv2(), is(false));\r\n        assertThat(prefix + \".rsv3\", actual.isRsv3(), is(false));\r\n        ByteBuffer expected = BufferUtil.toBuffer(quote.get(i), StandardCharsets.UTF_8);\r\n        assertThat(prefix + \".payloadLength\", actual.getPayloadLength(), is(expected.remaining()));\r\n        ByteBufferAssert.assertEquals(prefix + \".payload\", expected, actual.getPayload().slice());\r\n        i++;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.ZrtpHashPacketExtension.getVersion",
	"Comment": "returns the zrtp version used by the implementation that created thehash.",
	"Method": "String getVersion(){\r\n    return getAttributeAsString(VERSION_ATTR_NAME);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.TransportManagerJabberImpl.startConnectivityEstablishment",
	"Comment": "starts the connectivity establishment of thistransportmanagerjabberimpl i.e. checks the connectivity betweenthe local and the remote peers given the remote counterpart of thenegotiation between them.",
	"Method": "boolean startConnectivityEstablishment(Iterable<ContentPacketExtension> remote,boolean startConnectivityEstablishment,Map<String, IceUdpTransportPacketExtension> remote){\r\n    return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.GeolocationEvent.getSourceGeolocationOperationSet",
	"Comment": "returns the geolocationoperationset instance that is the sourceof this event.",
	"Method": "OperationSetGeolocation getSourceGeolocationOperationSet(){\r\n    return (OperationSetGeolocation) getSource();\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.gibberish.TestOperationSetPersistentPresence.postTestRemoveGroup",
	"Comment": "removes the group created in the server stored contact list by the creategroup test, makes sure that the corresponding event has been generatedand verifies that the group is not in the list any more.",
	"Method": "void postTestRemoveGroup(){\r\n    logger.trace(\"testing removal of server stored groups\");\r\n    GroupChangeCollector groupChangeCollector = new GroupChangeCollector();\r\n    opSetPersPresence1.addServerStoredGroupChangeListener(groupChangeCollector);\r\n    try {\r\n        opSetPersPresence1.removeServerStoredContactGroup(opSetPersPresence1.getServerStoredContactListRoot().getGroup(testGroupName2));\r\n    } catch (OperationFailedException ex) {\r\n        logger.error(\"error removing group\", ex);\r\n    }\r\n    groupChangeCollector.waitForEvent(10000);\r\n    opSetPersPresence1.removeServerStoredGroupChangeListener(groupChangeCollector);\r\n    assertEquals(\"Collected Group Change event\", 1, groupChangeCollector.collectedEvents.size());\r\n    assertEquals(\"Group name.\", testGroupName2, ((ServerStoredGroupEvent) groupChangeCollector.collectedEvents.get(0)).getSourceGroup().getGroupName());\r\n    ContactGroup group = opSetPersPresence1.getServerStoredContactListRoot().getGroup(testGroupName2);\r\n    assertNull(\"A freshly removed group was still on the contact list.\", group);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractProtocolProviderService.removeSupportedOperationSet",
	"Comment": "removes an operationset implementation from the set ofsupported operationsets for this instance.",
	"Method": "void removeSupportedOperationSet(Class<T> opsetClass){\r\n    supportedOperationSets.remove(opsetClass.getName());\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractCallPeer.fireCallPeerSecurityNegotiationStartedEvent",
	"Comment": "constructs a callpeersecuritystatusevent using this call peer assource, setting it to be of type eventtype and the correspondingoldvalue and newvalue.",
	"Method": "void fireCallPeerSecurityNegotiationStartedEvent(CallPeerSecurityNegotiationStartedEvent evt){\r\n    lastSecurityEvent = evt;\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Dispatching a CallPeerSecurityStatusEvent event to \" + callPeerSecurityListeners.size() + \" listeners. event is: \" + evt.toString());\r\n    List<CallPeerSecurityListener> listeners = null;\r\n    synchronized (callPeerSecurityListeners) {\r\n        listeners = new ArrayList<CallPeerSecurityListener>(callPeerSecurityListeners);\r\n    }\r\n    for (CallPeerSecurityListener listener : listeners) {\r\n        listener.securityNegotiationStarted(evt);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.ContactGibberishImpl.setParentGroup",
	"Comment": "this method is only called when the contact is added to a newcontactgroupgibberishimpl by thecontactgroupgibberishimpl itself.",
	"Method": "void setParentGroup(ContactGroupGibberishImpl newParentGroup){\r\n    this.parentGroup = newParentGroup;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.CallConference.getCalls",
	"Comment": "gets the list of call participating in this telephonyconference.",
	"Method": "List<Call> getCalls(Call call,List<Call> getCalls){\r\n    synchronized (callsSyncRoot) {\r\n        return immutableCalls;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.JabberActivator.getBundleContext",
	"Comment": "returns a reference to the bundle context that we were started with.",
	"Method": "BundleContext getBundleContext(){\r\n    return bundleContext;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.LocalUserChatRoomPresenceChangeEvent.getReason",
	"Comment": "a reason string indicating a human readable reason for this event.",
	"Method": "String getReason(){\r\n    return reason;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.TypingNotificationEvent.getTypingState",
	"Comment": "returns the typing state that this typingnotificationevent iscarrying.",
	"Method": "int getTypingState(){\r\n    return typingState;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.PresenceFilter.isMatching",
	"Comment": "returns true if offline contacts are shown or if the givenmetacontactgroup contains online contacts.",
	"Method": "boolean isMatching(UIContact uiContact,boolean isMatching,UIGroup uiGroup,boolean isMatching,MetaContact metaContact,boolean isMatching,SourceContact contact,boolean isMatching,MetaContactGroup metaGroup){\r\n    return isShowOffline || (metaGroup.countOnlineChildContacts() > 0) || MetaContactListSource.isNewGroup(metaGroup);\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.ServiceUtils.getService",
	"Comment": "gets an osgi service registered in a specific bundlecontext byits class",
	"Method": "T getService(BundleContext bundleContext,Class<T> serviceClass){\r\n    ServiceReference<T> serviceReference = bundleContext.getServiceReference(serviceClass);\r\n    return (serviceReference == null) ? null : bundleContext.getService(serviceReference);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.replacement.hulu.ReplacementServiceHuluImpl.getReplacement",
	"Comment": "replaces the hulu video links with their corresponding thumbnails.",
	"Method": "String getReplacement(String sourceString){\r\n    try {\r\n        String url = \"http://api.embed.ly/1/oembed?url=\" + sourceString + \"&key=cff57b37766440a6a8aa45df88097efe\";\r\n        URL sourceURL = new URL(url);\r\n        URLConnection conn = sourceURL.openConnection();\r\n        BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\r\n        String inputLine, holder = \"\";\r\n        while ((inputLine = in.readLine()) != null) holder = inputLine;\r\n        in.close();\r\n        JSONObject wrapper = (JSONObject) JSONValue.parseWithException(holder);\r\n        String thumbUrl = (String) wrapper.get(\"thumbnail_url\");\r\n        if (thumbUrl != null) {\r\n            return thumbUrl;\r\n        }\r\n    } catch (Throwable e) {\r\n        logger.error(\"Error parsing\", e);\r\n    }\r\n    return sourceString;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.net.AndroidNetworkLayer.createSSLServerSocket",
	"Comment": "creates an ssl server with the specified port, listen backlog, and localip address to bind to.",
	"Method": "SSLServerSocket createSSLServerSocket(int port,int backlog,InetAddress bindAddress){\r\n    if (bindAddress.getHostAddress().equals(IN6_ADDR_ANY)) {\r\n        return (SSLServerSocket) getSSLServerSocketFactory().createServerSocket(port, backlog);\r\n    } else {\r\n        return super.createSSLServerSocket(port, backlog, bindAddress);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.osdependent.jdic.StatusSubMenu.addAccount",
	"Comment": "adds the account corresponding to the given protocol provider to thismenu.",
	"Method": "void addAccount(ProtocolProviderService protocolProvider){\r\n    if (protocolProvider.getAccountID().isStatusMenuHidden())\r\n        return;\r\n    OperationSetPresence presence = protocolProvider.getOperationSet(OperationSetPresence.class);\r\n    boolean swing = (menu instanceof JComponent);\r\n    if (presence == null) {\r\n        StatusSimpleSelector simpleSelector = new StatusSimpleSelector(protocolProvider, swing);\r\n        this.accountSelectors.put(protocolProvider.getAccountID(), simpleSelector);\r\n        if (!hideAccountStatusSelectors)\r\n            addMenuItem(menu, simpleSelector.getMenu());\r\n        protocolProvider.addRegistrationStateChangeListener(this);\r\n    } else {\r\n        StatusSelector statusSelector = new StatusSelector(protocolProvider, presence, swing);\r\n        this.accountSelectors.put(protocolProvider.getAccountID(), statusSelector);\r\n        if (!hideAccountStatusSelectors)\r\n            addMenuItem(menu, statusSelector.getMenu());\r\n        presence.addProviderPresenceStatusListener(this);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.AdHocChatRoomIcqImpl.addMessageListener",
	"Comment": "registers listener so that it would receive events every time anew message is received on this chat room.",
	"Method": "void addMessageListener(AdHocChatRoomMessageListener listener){\r\n    synchronized (messageListeners) {\r\n        if (!messageListeners.contains(listener))\r\n            messageListeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.TreeContactList.showAddContactDialog",
	"Comment": "creates and shows an addcontactdialog with a predefinedcontactaddress and protocolprovider.",
	"Method": "void showAddContactDialog(ContactDetail contactDetail,String displayName){\r\n    AddContactDialog dialog = new AddContactDialog(GuiActivator.getUIService().getMainFrame());\r\n    ProtocolProviderService preferredProvider = null;\r\n    List<Class<? extends OperationSet>> opSetClasses = contactDetail.getSupportedOperationSets();\r\n    if (opSetClasses != null && opSetClasses.size() > 0) {\r\n        preferredProvider = contactDetail.getPreferredProtocolProvider(opSetClasses.get(0));\r\n    }\r\n    if (preferredProvider != null)\r\n        dialog.setSelectedAccount(preferredProvider);\r\n    String contactAddress = contactDetail.getDetail();\r\n    dialog.setContactAddress(contactAddress);\r\n    if (displayName != null && !displayName.equalsIgnoreCase(contactAddress)) {\r\n        dialog.setDisplayName(displayName);\r\n    }\r\n    dialog.setVisible(true);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.securityconfig.SecurityConfigActivator.getCredentialsStorageService",
	"Comment": "returns the credentialsstorageservice obtained from the bundlecontext.",
	"Method": "CredentialsStorageService getCredentialsStorageService(){\r\n    if (credentialsStorageService == null) {\r\n        credentialsStorageService = ServiceUtils.getService(bundleContext, CredentialsStorageService.class);\r\n    }\r\n    return credentialsStorageService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.ConfigurationUtils.getChatRoomProperty",
	"Comment": "returns the chat room property, saved through theconfigurationservice.",
	"Method": "String getChatRoomProperty(ProtocolProviderService protocolProvider,String chatRoomId,String property){\r\n    String prefix = \"net.java.sip.communicator.impl.gui.accounts\";\r\n    List<String> accounts = configService.getPropertyNamesByPrefix(prefix, true);\r\n    for (String accountRootPropName : accounts) {\r\n        String accountUID = configService.getString(accountRootPropName);\r\n        if (accountUID.equals(protocolProvider.getAccountID().getAccountUniqueID())) {\r\n            List<String> chatRooms = configService.getPropertyNamesByPrefix(accountRootPropName + \".chatRooms\", true);\r\n            for (String chatRoomPropName : chatRooms) {\r\n                String chatRoomID = configService.getString(chatRoomPropName);\r\n                if (!chatRoomId.equals(chatRoomID))\r\n                    continue;\r\n                return configService.getString(chatRoomPropName + \".\" + property);\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.globaldisplaydetails.GlobalDisplayDetailsImpl.fireGlobalDisplayNameEvent",
	"Comment": "notifies all interested listeners of a global display details change.",
	"Method": "void fireGlobalDisplayNameEvent(String displayName){\r\n    List<GlobalDisplayDetailsListener> listeners;\r\n    synchronized (displayDetailsListeners) {\r\n        listeners = Collections.unmodifiableList(displayDetailsListeners);\r\n    }\r\n    Iterator<GlobalDisplayDetailsListener> listIter = listeners.iterator();\r\n    while (listIter.hasNext()) {\r\n        listIter.next().globalDisplayNameChanged(new GlobalDisplayNameChangeEvent(this, displayName));\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.MoveSubcontactMessageDialog.close",
	"Comment": "automatically clicks the cancel button when the dialog is closed.",
	"Method": "void close(boolean isEscaped){\r\n    this.cancelButton.doClick();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.dnsconfig.DnssecPanel.loadData",
	"Comment": "reads the configured properties or their defaults into the ui controls.",
	"Method": "void loadData(){\r\n    cboDefault.setSelectedItem(Enum.valueOf(SecureResolveMode.class, config.getString(ConfigurableDnssecResolver.PNAME_DNSSEC_VALIDATION_MODE, SecureResolveMode.WarnIfBogus.name())));\r\n    chkEnabled.setSelected(config.getBoolean(CustomResolver.PNAME_DNSSEC_RESOLVER_ENABLED, CustomResolver.PDEFAULT_DNSSEC_RESOLVER_ENABLED));\r\n    chkAbsolute.setSelected(config.getBoolean(NetworkUtils.PNAME_DNS_ALWAYS_ABSOLUTE, NetworkUtils.PDEFAULT_DNS_ALWAYS_ABSOLUTE));\r\n    txtNameservers.setText(config.getString(DnsUtilActivator.PNAME_DNSSEC_NAMESERVERS));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatTransport.isDisplayResourceOnly",
	"Comment": "indicates if the display name should only show the resource.",
	"Method": "boolean isDisplayResourceOnly(){\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.notifsource.NotificationContact.setParentGroup",
	"Comment": "sets the given uigroup to be the parent group of thisuicontact.",
	"Method": "void setParentGroup(UIGroup parentGroup){\r\n    if (!(parentGroup instanceof NotificationGroup))\r\n        return;\r\n    this.parentGroup = (NotificationGroup) parentGroup;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.contactinfo.Resources.getString",
	"Comment": "returns an internationalized string corresponding to the given key.",
	"Method": "String getString(String key){\r\n    return getResources().getI18NString(key);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockPersistentPresenceOperationSet.addMockGroup",
	"Comment": "a mock provider method to use for fast filling of a contact list.",
	"Method": "void addMockGroup(MockContactGroup contactGroup){\r\n    contactListRoot.addSubgroup(contactGroup);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ServerStoredContactListJabberImpl.findContactGroupByNameCopy",
	"Comment": "find a group with the specified copy of name. used to track whena group name has changed",
	"Method": "ContactGroupJabberImpl findContactGroupByNameCopy(String name){\r\n    Iterator<ContactGroup> contactGroups = rootGroup.subgroups();\r\n    name = name.trim();\r\n    while (contactGroups.hasNext()) {\r\n        ContactGroupJabberImpl contactGroup = (ContactGroupJabberImpl) contactGroups.next();\r\n        if (contactGroup.getNameCopy() != null && contactGroup.getNameCopy().trim().equals(name))\r\n            return contactGroup;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.InfoRetreiver.readInterestsUserInfo",
	"Comment": "method for parsing incoming dataread data in interestsuserinfo command",
	"Method": "void readInterestsUserInfo(MetaInterestsInfoCmd cmd){\r\n    List<GenericDetail> infoData = getInfoForRequest(cmd.getId());\r\n    int[] categories = cmd.getCategories();\r\n    String[] interests = cmd.getInterests();\r\n    for (int i = 0; i < interests.length; i++) {\r\n        int category = categories[i];\r\n        if (category != 0) {\r\n            category = category - 99;\r\n        }\r\n        if (category <= interests.length) {\r\n            infoData.add(new OperationSetServerStoredAccountInfoIcqImpl.InterestDetail(interests[i], OperationSetServerStoredAccountInfoIcqImpl.interestsCategories[category]));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ContactSipImpl.setParentGroup",
	"Comment": "this method is only called when the contact is added to a newcontactgroupsipimpl by thecontactgroupsipimpl itself.",
	"Method": "void setParentGroup(ContactGroupSipImpl newParentGroup){\r\n    this.parentGroup = newParentGroup;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageSourceContactQuery.updateContactStatus",
	"Comment": "notifies the contactquerylisteners registered with thiscontactquery that a sourcecontact has beenchanged.note that object may not be messagesourcecontact, but itsequals method can return true for message source contact instances.",
	"Method": "void updateContactStatus(Object srcObj,PresenceStatus status){\r\n    for (SourceContact msc : getQueryResults()) {\r\n        if (srcObj.equals(msc) && msc instanceof MessageSourceContact) {\r\n            ((MessageSourceContact) msc).setStatus(status);\r\n            super.fireContactChanged(msc);\r\n            break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.JabberActivator.getNetworkAddressManagerService",
	"Comment": "returns a reference to a networkaddressmanagerservice implementationcurrently registered in the bundle context or null if no suchimplementation was found.",
	"Method": "NetworkAddressManagerService getNetworkAddressManagerService(){\r\n    if (networkAddressManagerService == null) {\r\n        ServiceReference confReference = bundleContext.getServiceReference(NetworkAddressManagerService.class.getName());\r\n        networkAddressManagerService = (NetworkAddressManagerService) bundleContext.getService(confReference);\r\n    }\r\n    return networkAddressManagerService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.keybindingchooser.globalchooser.GlobalShortcutTableModel.getColumnClass",
	"Comment": "overrides a method that always returned object.classnow it will return boolean.class for the first method,letting the defaulttablecellrenderer create checkboxes.",
	"Method": "Class<?> getColumnClass(int columnIndex){\r\n    Object o = getValueAt(0, columnIndex);\r\n    if (o == null)\r\n        return String.class;\r\n    return o.getClass();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.osdependent.Resources.getString",
	"Comment": "returns an internationalized string corresponding to the given key.",
	"Method": "String getString(String key){\r\n    return getResources().getI18NString(key);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.msoutlook.MsOutlookAddrBookContactQuery.inserted",
	"Comment": "callback method when receiving notifications for inserted items.",
	"Method": "void inserted(String id){\r\n    synchronized (MsOutlookAddrBookContactQuery.class) {\r\n        insertedOrUpdated(id, 0);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.caps.CapsPacketExtension.setHash",
	"Comment": "sets the value of the hash parameter indicating the hashingalgorithm used to generate the verification string.",
	"Method": "void setHash(String hash){\r\n    this.hash = hash;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl.getJainSipProvider",
	"Comment": "returns the default jain sip provider that we use for communication overtransport.",
	"Method": "SipProvider getJainSipProvider(String transport){\r\n    return sipStackSharing.getJainSipProvider(transport);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.AbstractOperationSetTelephonyConferencing.propertyChange",
	"Comment": "notifies this propertychangelistener that the value of aspecific property of the notifier it is registered with has changed.",
	"Method": "void propertyChange(PropertyChangeEvent ev){\r\n    String propertyName = ev.getPropertyName();\r\n    if (CallPeerMediaHandler.AUDIO_LOCAL_SSRC.equals(propertyName) || CallPeerMediaHandler.AUDIO_REMOTE_SSRC.equals(propertyName) || CallPeerMediaHandler.VIDEO_LOCAL_SSRC.equals(propertyName) || CallPeerMediaHandler.VIDEO_REMOTE_SSRC.equals(propertyName)) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        CallPeerMediaHandler<MediaAwareCallPeerT> mediaHandler = (CallPeerMediaHandler<MediaAwareCallPeerT>) ev.getSource();\r\n        Call call = mediaHandler.getPeer().getCall();\r\n        if (call != null)\r\n            notifyAll(call);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommDialog.dispose",
	"Comment": "overwrites the dispose method in order to save the size and the positionof this window before closing it.",
	"Method": "void dispose(){\r\n    if (isSaveSizeAndLocation)\r\n        this.saveSizeAndLocation();\r\n    super.dispose();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.history.HistoryWindow.appendMessageToDocument",
	"Comment": "appends the given string at the end of the given html document.",
	"Method": "void appendMessageToDocument(HTMLDocument doc,String chatString){\r\n    Element root = doc.getDefaultRootElement();\r\n    try {\r\n        doc.insertAfterEnd(root.getElement(root.getElementCount() - 1), chatString);\r\n    } catch (BadLocationException e) {\r\n        logger.error(\"Insert in the HTMLDocument failed.\", e);\r\n    } catch (IOException e) {\r\n        logger.error(\"Insert in the HTMLDocument failed.\", e);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.NetworkUtils.sortSrvRecordByWeight",
	"Comment": "sorts each priority of the srv record list. each priority is sorted withthe probabilty given by the weight attribute.",
	"Method": "void sortSrvRecordByWeight(SRVRecord[] srvRecords){\r\n    int currentPriority = srvRecords[0].getPriority();\r\n    int startIndex = 0;\r\n    for (int i = 0; i < srvRecords.length; ++i) {\r\n        if (currentPriority != srvRecords[i].getPriority()) {\r\n            sortSrvRecordPriorityByWeight(srvRecords, startIndex, i);\r\n            startIndex = i;\r\n            currentPriority = srvRecords[i].getPriority();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.EncodingsRegistrationUtil.loadAccount",
	"Comment": "loads encoding properties from given accountid into thisencodings registration object.",
	"Method": "void loadAccount(AccountID accountID,MediaService mediaService){\r\n    String overrideEncodings = accountID.getAccountPropertyString(ProtocolProviderFactory.OVERRIDE_ENCODINGS);\r\n    boolean isOverrideEncodings = Boolean.parseBoolean(overrideEncodings);\r\n    setOverrideEncodings(isOverrideEncodings);\r\n    Map<String, String> encodingProperties = new HashMap<String, String>();\r\n    EncodingConfiguration encodingConfiguration = mediaService.createEmptyEncodingConfiguration();\r\n    encodingConfiguration.loadProperties(accountID.getAccountProperties(), ProtocolProviderFactory.ENCODING_PROP_PREFIX);\r\n    encodingConfiguration.storeProperties(encodingProperties, ProtocolProviderFactory.ENCODING_PROP_PREFIX + \".\");\r\n    setEncodingProperties(encodingProperties);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.GuiActivator.getCallHistoryService",
	"Comment": "returns the callhistoryservice obtained from the bundlecontext.",
	"Method": "CallHistoryService getCallHistoryService(){\r\n    if (callHistoryService == null) {\r\n        callHistoryService = ServiceUtils.getService(bundleContext, CallHistoryService.class);\r\n    }\r\n    return callHistoryService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.ircaccregwizz.IrcAccountRegistrationWizard.getFirstPageIdentifier",
	"Comment": "returns the identifier of the page to show first in the wizard.",
	"Method": "Object getFirstPageIdentifier(){\r\n    return firstWizardPage.getIdentifier();\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.common.events.JettyAnnotatedScannerTest.testAnnotatedBadSignature_Static",
	"Comment": "test case for bad declaration a method with a public static method",
	"Method": "void testAnnotatedBadSignature_Static(){\r\n    JettyAnnotatedScanner impl = new JettyAnnotatedScanner();\r\n    InvalidWebSocketException e = assertThrows(InvalidWebSocketException.class, () -> {\r\n        impl.scan(BadTextSignatureSocket.class);\r\n    });\r\n    assertThat(e.getMessage(), containsString(\"may not be static\"));\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.FullUserInfoCmd.writeOutByte",
	"Comment": "writes byte data to the icqdataoutwhich is send to the server",
	"Method": "void writeOutByte(int dataType,int value){\r\n    try {\r\n        writeUShort(icqDataOut, dataType);\r\n        writeUShort(icqDataOut, 1);\r\n        writeUByte(icqDataOut, value);\r\n    } catch (IOException ex) {\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetDesktopSharingServerJabberImpl.setLocalVideoAllowed",
	"Comment": "sets the indicator which determines whether the streaming of local videoin a specific call is allowed. the setting does not reflectthe availability of actual video capture devices, it just expresses thedesire of the user to have the local video streamed in the case thesystem is actually able to do so.",
	"Method": "void setLocalVideoAllowed(Call call,MediaDevice mediaDevice,boolean allowed){\r\n    ((AbstractCallJabberGTalkImpl<?>) call).setLocalInputEvtAware(allowed);\r\n    super.setLocalVideoAllowed(call, mediaDevice, allowed);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.thumbnail.ThumbnailElement.parseExtension",
	"Comment": "creates a thumbnailelement by using the given xml pull parser.",
	"Method": "ThumbnailElement parseExtension(XmlPullParser parser){\r\n    try {\r\n        if (parser.getName().equals(ELEMENT_NAME)) {\r\n            return new ThumbnailElement(parser.getAttributeValue(\"\", CID), parser.getAttributeValue(\"\", MIME_TYPE), Integer.parseInt(parser.getAttributeValue(\"\", WIDTH)), Integer.parseInt(parser.getAttributeValue(\"\", HEIGHT)));\r\n        } else if (logger.isDebugEnabled())\r\n            logger.debug(\"Element name unknown!\");\r\n    } catch (Exception ex) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Problem parsing Thumbnail Element : \" + parser.getText(), ex);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatHtmlUtils.createAdvancedMessageHeaderTag",
	"Comment": "creates a message table tag, representing the message header.",
	"Method": "String createAdvancedMessageHeaderTag(String nameHeader,Date date){\r\n    StringBuilder messageHeader = new StringBuilder();\r\n    messageHeader.append(\"<table width=\\\"100%\\\">\");\r\n    messageHeader.append(\"<tr>\");\r\n    messageHeader.append(\"<td nowrap=\\\"nowrap\\\">\");\r\n    messageHeader.append(nameHeader);\r\n    messageHeader.append(\"<\/td>\");\r\n    messageHeader.append(\"<td nowrap=\\\"nowrap\\\" \").append(OutgoingMessageStyle.createDateStyle()).append(\">\");\r\n    messageHeader.append(getDateString(date));\r\n    messageHeader.append(GuiUtils.formatTime(date));\r\n    messageHeader.append(\"<\/td>\");\r\n    messageHeader.append(\"<\/tr>\");\r\n    messageHeader.append(\"<\/table>\");\r\n    return messageHeader.toString();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.DynamicPayloadTypeRegistry.getPayloadTypeFromMap",
	"Comment": "iterates through formatmap and returns the payload type that itmaps to format or null if there is currently no suchpayload type.",
	"Method": "Byte getPayloadTypeFromMap(Map<MediaFormat, Byte> formatMap,MediaFormat format){\r\n    for (Map.Entry<MediaFormat, Byte> mapping : formatMap.entrySet()) {\r\n        if (mapping.getKey().matches(format)) {\r\n            return mapping.getValue();\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.utils.InviteDialog.getReason",
	"Comment": "returns the reason of this invite, if the user has specified one.",
	"Method": "String getReason(){\r\n    return reasonArea.getText();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.update.UpdateServiceImpl.showGenericNewVersionAvailableDialog",
	"Comment": "shows dialog informing about the availability of a new version with adownload button which launches the system web browser.",
	"Method": "void showGenericNewVersionAvailableDialog(){\r\n    final boolean[] exitCheckForUpdates = new boolean[] { false };\r\n    final JDialog dialog = new SIPCommDialog() {\r\n        private static final long serialVersionUID = 0L;\r\n        @Override\r\n        protected void close(boolean escaped) {\r\n            synchronized (exitCheckForUpdates) {\r\n                if (exitCheckForUpdates[0])\r\n                    exitCheckForUpdates(this);\r\n            }\r\n        }\r\n    };\r\n    ResourceManagementService resources = Resources.getResources();\r\n    dialog.setTitle(resources.getI18NString(\"plugin.updatechecker.DIALOG_TITLE\"));\r\n    JEditorPane contentMessage = new JEditorPane();\r\n    contentMessage.setContentType(\"text/html\");\r\n    contentMessage.setOpaque(false);\r\n    contentMessage.setEditable(false);\r\n    String dialogMsg = resources.getI18NString(\"plugin.updatechecker.DIALOG_MESSAGE\", new String[] { resources.getSettingsString(\"service.gui.APPLICATION_NAME\") });\r\n    if (latestVersion != null)\r\n        dialogMsg += resources.getI18NString(\"plugin.updatechecker.DIALOG_MESSAGE_2\", new String[] { resources.getSettingsString(\"service.gui.APPLICATION_NAME\"), latestVersion });\r\n    contentMessage.setText(dialogMsg);\r\n    JPanel contentPane = new TransparentPanel(new BorderLayout(5, 5));\r\n    contentPane.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\r\n    contentPane.add(contentMessage, BorderLayout.CENTER);\r\n    JPanel buttonPanel = new TransparentPanel(new FlowLayout(FlowLayout.CENTER, 10, 10));\r\n    final JButton closeButton = new JButton(resources.getI18NString(\"plugin.updatechecker.BUTTON_CLOSE\"));\r\n    closeButton.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent e) {\r\n            dialog.dispose();\r\n            if (exitCheckForUpdates[0])\r\n                exitCheckForUpdates(dialog);\r\n        }\r\n    });\r\n    if (downloadLink != null) {\r\n        JButton downloadButton = new JButton(resources.getI18NString(\"plugin.updatechecker.BUTTON_DOWNLOAD\"));\r\n        downloadButton.addActionListener(new ActionListener() {\r\n            public void actionPerformed(ActionEvent e) {\r\n                UpdateActivator.getBrowserLauncher().openURL(downloadLink);\r\n                closeButton.doClick();\r\n            }\r\n        });\r\n        buttonPanel.add(downloadButton);\r\n    }\r\n    buttonPanel.add(closeButton);\r\n    contentPane.add(buttonPanel, BorderLayout.SOUTH);\r\n    dialog.setContentPane(contentPane);\r\n    dialog.pack();\r\n    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\r\n    dialog.setLocation(screenSize.width / 2 - dialog.getWidth() / 2, screenSize.height / 2 - dialog.getHeight() / 2);\r\n    synchronized (exitCheckForUpdates) {\r\n        enterCheckForUpdates(dialog);\r\n        exitCheckForUpdates[0] = true;\r\n    }\r\n    try {\r\n        dialog.setVisible(true);\r\n    } finally {\r\n        synchronized (exitCheckForUpdates) {\r\n            if (exitCheckForUpdates[0] && dialog.isModal())\r\n                exitCheckForUpdates(dialog);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.update.UpdateServiceImpl.showGenericNewVersionAvailableDialog",
	"Comment": "shows dialog informing about the availability of a new version with adownload button which launches the system web browser.",
	"Method": "void showGenericNewVersionAvailableDialog(){\r\n    synchronized (exitCheckForUpdates) {\r\n        if (exitCheckForUpdates[0])\r\n            exitCheckForUpdates(this);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.update.UpdateServiceImpl.showGenericNewVersionAvailableDialog",
	"Comment": "shows dialog informing about the availability of a new version with adownload button which launches the system web browser.",
	"Method": "void showGenericNewVersionAvailableDialog(){\r\n    dialog.dispose();\r\n    if (exitCheckForUpdates[0])\r\n        exitCheckForUpdates(dialog);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.update.UpdateServiceImpl.showGenericNewVersionAvailableDialog",
	"Comment": "shows dialog informing about the availability of a new version with adownload button which launches the system web browser.",
	"Method": "void showGenericNewVersionAvailableDialog(){\r\n    UpdateActivator.getBrowserLauncher().openURL(downloadLink);\r\n    closeButton.doClick();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.MobileIndicator.resourcesUpdated",
	"Comment": "called when resources have been updated for a contact, onpresence changed.",
	"Method": "void resourcesUpdated(ContactJabberImpl contact){\r\n    if (isCapsMobileIndicator) {\r\n        updateMobileIndicatorUsingCaps(contact.getAddress());\r\n        return;\r\n    }\r\n    int highestPriority = Integer.MIN_VALUE;\r\n    List<ContactResource> highestPriorityResources = new ArrayList<ContactResource>();\r\n    Collection<ContactResource> resources = contact.getResources();\r\n    if (resources == null)\r\n        return;\r\n    for (ContactResource res : resources) {\r\n        if (!res.getPresenceStatus().isOnline())\r\n            continue;\r\n        int prio = res.getPriority();\r\n        if (prio >= highestPriority) {\r\n            if (highestPriority != prio)\r\n                highestPriorityResources.clear();\r\n            highestPriority = prio;\r\n            highestPriorityResources.add(res);\r\n        }\r\n    }\r\n    boolean allMobile = false;\r\n    for (ContactResource res : highestPriorityResources) {\r\n        if (res.isMobile())\r\n            allMobile = true;\r\n        else {\r\n            allMobile = false;\r\n            break;\r\n        }\r\n    }\r\n    if (highestPriorityResources.size() > 0)\r\n        contact.setMobile(allMobile);\r\n    else\r\n        contact.setMobile(false);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.notifsource.NotificationContactSource.messageWaitingNotify",
	"Comment": "adds the received waiting message to the corresponding group and contact.also adds it the uinotificationmanager that would take care ofnotifying the user.",
	"Method": "void messageWaitingNotify(MessageWaitingEvent evt){\r\n    MessageType type = evt.getMessageType();\r\n    NotificationGroup group = groups.get(type.toString());\r\n    if (group == null) {\r\n        String displayName;\r\n        if (type.equals(MessageType.VOICE))\r\n            displayName = GuiActivator.getResources().getI18NString(\"service.gui.VOICEMAIL_TITLE\");\r\n        else\r\n            displayName = type.toString();\r\n        group = new NotificationGroup(displayName);\r\n        groups.put(type.toString(), group);\r\n    }\r\n    group.messageWaitingNotify(new MessageWaitingEvent(evt.getSourceProvider(), evt.getMessageType(), evt.getAccount(), evt.getUnreadMessages(), evt.getReadMessages(), evt.getUnreadUrgentMessages(), evt.getReadUrgentMessages()));\r\n    Iterator<NotificationMessage> messages = evt.getMessages();\r\n    if (messages != null) {\r\n        while (messages.hasNext()) {\r\n            NotificationMessage message = messages.next();\r\n            String messageGroupName = message.getMessageGroup();\r\n            NotificationGroup messageGroup = groups.get(messageGroupName);\r\n            if (messageGroup == null) {\r\n                messageGroup = new NotificationGroup(messageGroupName);\r\n                groups.put(messageGroupName, messageGroup);\r\n            }\r\n            messageGroup.messageWaitingNotify(evt);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetBasicInstantMessagingSipImpl.isContentTypeSupported",
	"Comment": "determines whether the protocol supports the supplied content type",
	"Method": "boolean isContentTypeSupported(String contentType){\r\n    if (contentType.equals(DEFAULT_MIME_TYPE) || contentType.equals(HTML_MIME_TYPE))\r\n        return true;\r\n    else\r\n        return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.DesktopSharingMouseAndKeyboardListener.mouseDragged",
	"Comment": "invoked when a mouse button is pressed on acomponent and then dragged.",
	"Method": "void mouseDragged(MouseEvent e){\r\n    if (desktopSharingClient != null) {\r\n        desktopSharingClient.sendMouseEvent(callPeer, e, videoComponent.getSize());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockCall.addCallPeer",
	"Comment": "adds callpeer to the list of peers in this call.if the call peer is already included in the call, the method hasno effect.",
	"Method": "void addCallPeer(MockCallPeer callPeer){\r\n    if (!doAddCallPeer(callPeer))\r\n        return;\r\n    callPeer.addCallPeerListener(this);\r\n    if (logger.isInfoEnabled())\r\n        logger.info(\"Will fire peer added\");\r\n    fireCallPeerEvent(callPeer, CallPeerEvent.CALL_PEER_ADDED);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockOperationSetBasicTelephony.getProtocolProvider",
	"Comment": "returns the protocol provider that this operation set belongs to.",
	"Method": "MockProvider getProtocolProvider(){\r\n    return protocolProvider;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.callhistory.CallHistoryServiceImpl.getCSVs",
	"Comment": "returns list of string items contained in the supplied stringseparated by delim",
	"Method": "List<String> getCSVs(String str){\r\n    List<String> result = new LinkedList<String>();\r\n    if (str == null)\r\n        return result;\r\n    StreamTokenizer stt = new StreamTokenizer(new StringReader(str));\r\n    stt.resetSyntax();\r\n    stt.wordChars('', '?');\r\n    stt.eolIsSignificant(false);\r\n    stt.quoteChar('\"');\r\n    stt.whitespaceChars(DELIM, DELIM);\r\n    try {\r\n        while (stt.nextToken() != StreamTokenizer.TT_EOF) {\r\n            if (stt.sval != null) {\r\n                result.add(stt.sval.trim());\r\n            }\r\n        }\r\n    } catch (IOException e) {\r\n        logger.error(\"failed to parse \" + str, e);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetCusaxUtilsSipImpl.getLinkedCusaxProvider",
	"Comment": "returns the linked cusax provider for this protocol provider.",
	"Method": "ProtocolProviderService getLinkedCusaxProvider(){\r\n    String cusaxProviderID = provider.getAccountID().getAccountPropertyString(ProtocolProviderFactory.CUSAX_PROVIDER_ACCOUNT_PROP);\r\n    if (cusaxProviderID == null)\r\n        return null;\r\n    AccountID acc = ProtocolProviderActivator.getAccountManager().findAccountID(cusaxProviderID);\r\n    if (acc == null) {\r\n        logger.warn(\"No connected cusax account found for \" + cusaxProviderID);\r\n        return null;\r\n    } else {\r\n        for (ProtocolProviderService pProvider : ProtocolProviderActivator.getProtocolProviders()) {\r\n            if (pProvider.getAccountID().equals(acc)) {\r\n                return pProvider;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "io.lettuce.core.dynamic.support.MethodParameter.getParameterAnnotation",
	"Comment": "return the parameter annotation of the given type, if available.",
	"Method": "T getParameterAnnotation(Class<T> annotationType){\r\n    Annotation[] anns = getParameterAnnotations();\r\n    for (Annotation ann : anns) {\r\n        if (annotationType.isInstance(ann)) {\r\n            return (T) ann;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.aimaccregwizz.AimAccountRegistrationWizard.getUserNameExample",
	"Comment": "returns an example string, which should indicate to the user how theuser name should look like.",
	"Method": "String getUserNameExample(){\r\n    return FirstWizardPage.USER_NAME_EXAMPLE;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommTextButton.paintComponent",
	"Comment": "overrides the paintcomponent method of jbutton topaint the button background and icon, and all additional effects of thisconfigurable button.",
	"Method": "void paintComponent(Graphics g){\r\n    Graphics2D g1 = (Graphics2D) g.create();\r\n    try {\r\n        internalPaintComponent(g1);\r\n    } finally {\r\n        g1.dispose();\r\n    }\r\n    super.paintComponent(g);\r\n}"
}, {
	"Path": "net.librec.data.splitter.RatioDataSplitterTestCase.calValidRatio",
	"Comment": "calculate the ratio of validation set of a specified ratiodatasplitter object and its convertor",
	"Method": "double calValidRatio(RatioDataSplitter splitter,TextDataConvertor convertor){\r\n    double validSize = splitter.getValidData().size();\r\n    double totalSize = convertor.getMatrix().toSparseMatrix().size();\r\n    return validSize / totalSize;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetPersistentPresenceIcqImpl.moveContactToGroup",
	"Comment": "removes the specified contact from its current parent and places itunder newparent.",
	"Method": "void moveContactToGroup(Contact contactToMove,ContactGroup newParent){\r\n    assertConnected();\r\n    if (!(contactToMove instanceof ContactIcqImpl))\r\n        throw new IllegalArgumentException(\"The specified contact is not an icq contact.\" + contactToMove);\r\n    if (!(newParent instanceof ContactGroupIcqImpl))\r\n        throw new IllegalArgumentException(\"The specified group is not an icq contact group.\" + newParent);\r\n    ssContactList.moveContact((ContactIcqImpl) contactToMove, (ContactGroupIcqImpl) newParent);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.osdependent.windows.TaskBarList3.getInstance",
	"Comment": "gets the itaskbarlist3 interface and initializes it with hrinit",
	"Method": "TaskBarList3 getInstance(){\r\n    if (instance == null && OSUtils.IS_WINDOWS) {\r\n        Ole32.INSTANCE.CoInitializeEx(Pointer.NULL, 0);\r\n        PointerByReference p = new PointerByReference();\r\n        WinNT.HRESULT hr = Ole32.INSTANCE.CoCreateInstance(CLSID_TaskbarList, Pointer.NULL, ObjBase.CLSCTX_ALL, IID_ITaskbarList3, p);\r\n        COMUtils.checkRC(hr);\r\n        instance = new TaskBarList3(p.getValue());\r\n    }\r\n    return instance;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallManager.isLocalVideoEnabled",
	"Comment": "indicates if the desktop sharing is currently enabled for the givencall.",
	"Method": "boolean isLocalVideoEnabled(Call call){\r\n    OperationSetVideoTelephony telephony = call.getProtocolProvider().getOperationSet(OperationSetVideoTelephony.class);\r\n    return (telephony != null) && telephony.isLocalVideoAllowed(call);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallPanel.removeCallTitleListener",
	"Comment": "removes the given calltitlelistener to the list of listeners,notified for call title changes.",
	"Method": "void removeCallTitleListener(CallTitleListener l){\r\n    synchronized (titleListeners) {\r\n        titleListeners.remove(l);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.BaseChatRoomSourceContact.getIndex",
	"Comment": "returns the index of this source contact in its parent group.",
	"Method": "int getIndex(){\r\n    if (parentQuery instanceof ServerChatRoomQuery)\r\n        return ((ServerChatRoomQuery) parentQuery).indexOf(this);\r\n    return -1;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.netaddr.NetworkConfigurationWatcher.serviceChanged",
	"Comment": "when new protocol provider is registered we add needed listeners.",
	"Method": "void serviceChanged(ServiceEvent serviceEvent){\r\n    ServiceReference serviceRef = serviceEvent.getServiceReference();\r\n    if (serviceRef.getBundle().getState() == Bundle.STOPPING) {\r\n        return;\r\n    }\r\n    Object sService = NetaddrActivator.getBundleContext().getService(serviceRef);\r\n    if (sService instanceof SystemActivityNotificationsService) {\r\n        switch(serviceEvent.getType()) {\r\n            case ServiceEvent.REGISTERED:\r\n                if (this.systemActivityNotificationsService != null)\r\n                    break;\r\n                handleNewSystemActivityNotificationsService((SystemActivityNotificationsService) sService);\r\n                break;\r\n            case ServiceEvent.UNREGISTERING:\r\n                ((SystemActivityNotificationsService) sService).removeSystemActivityChangeListener(this);\r\n                break;\r\n        }\r\n        return;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.generalconfig.OpusConfigForm.restoreDefaults",
	"Comment": "restores the ui components to the default values and writes the defaultvalues to the configuration.",
	"Method": "void restoreDefaults(){\r\n    bandwidthCombobox.setSelectedIndex(getBandwidthIndex(BANDWIDTH_DEFAULT));\r\n    bitrateField.setText(((Integer) BITRATE_DEFAULT).toString());\r\n    configurationService.setProperty(Constants.PROP_OPUS_BITRATE, BITRATE_DEFAULT);\r\n    dtxCheckbox.setSelected(DTX_DEFAULT);\r\n    configurationService.setProperty(Constants.PROP_OPUS_DTX, DTX_DEFAULT);\r\n    fecCheckbox.setSelected(FEC_DEFAULT);\r\n    configurationService.setProperty(Constants.PROP_OPUS_FEC, FEC_DEFAULT);\r\n    minExpectedPLField.setText(((Integer) MIN_EXPECTED_PL_DEFAULT).toString());\r\n    configurationService.setProperty(Constants.PROP_OPUS_MIN_EXPECTED_PACKET_LOSS, MIN_EXPECTED_PL_DEFAULT);\r\n    complexityCombobox.setSelectedIndex(COMPLEXITY_DEFAULT_INDEX);\r\n    configurationService.removeProperty(Constants.PROP_OPUS_COMPLEXITY);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.ChatRoomQuery.addQueryToProviderPresenceListeners",
	"Comment": "adds the query as presence listener to protocol provider service.",
	"Method": "void addQueryToProviderPresenceListeners(ProtocolProviderService pps){\r\n    OperationSetMultiUserChat opSetMUC = pps.getOperationSet(OperationSetMultiUserChat.class);\r\n    if (opSetMUC != null) {\r\n        opSetMUC.addPresenceListener(this);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.MUCActivator.getConfigurationService",
	"Comment": "returns the configurationservice obtained from the bundlecontext.",
	"Method": "ConfigurationService getConfigurationService(){\r\n    if (configService == null) {\r\n        configService = ServiceUtils.getService(bundleContext, ConfigurationService.class);\r\n    }\r\n    return configService;\r\n}"
}, {
	"Path": "net.librec.eval.AbstractRecommenderEvaluator.evaluate",
	"Comment": "evaluate on the test set with the the list of recommended items.",
	"Method": "double evaluate(RecommenderContext context,RecommendedList groundTruthList,RecommendedList recommendedList,double evaluate,EvalContext evalContext,double evaluate,RecommendedList groundTruthList,RecommendedList recommendedList){\r\n    conf = evalContext.getConf();\r\n    if (evalContext.getSimilarityMatrix() != null) {\r\n        similarityMatrix = evalContext.getSimilarityMatrix();\r\n    }\r\n    if (evalContext.getSimilarities() != null) {\r\n        similarities = evalContext.getSimilarities();\r\n    }\r\n    return evaluate(evalContext.getGroundTruthList(), evalContext.getRecommendedList());\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.ChatRoomInvitationRejectedEvent.getSourceOperationSet",
	"Comment": "returns the multi user chat operation set that dispatches this event.",
	"Method": "OperationSetMultiUserChat getSourceOperationSet(){\r\n    return (OperationSetMultiUserChat) getSource();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.AbstractOperationSetVideoTelephony.addVideoListener",
	"Comment": "delegates to the callpeermediahandler of the specifiedcallpeer because the video is provided by it. because otheroperationsetvideotelephony implementations may not provide theirvideo through the callpeermediahandler, this implementationpromotes itself as the provider of the video by replacing thecallpeermediahandler in the videoevents it fires.",
	"Method": "void addVideoListener(CallPeer peer,VideoListener listener){\r\n    if (listener == null)\r\n        throw new NullPointerException(\"listener\");\r\n    ((W) peer).getMediaHandler().addVideoListener(listener);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.filehistory.FileHistoryServiceImpl.handleProviderRemoved",
	"Comment": "removes the specified provider from the list of currently known providers",
	"Method": "void handleProviderRemoved(ProtocolProviderService provider){\r\n    OperationSetFileTransfer opSetFileTransfer = provider.getOperationSet(OperationSetFileTransfer.class);\r\n    if (opSetFileTransfer != null) {\r\n        opSetFileTransfer.addFileTransferListener(this);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl.notifyConnectionFailed",
	"Comment": "if somewhere we got for example timeout of receiving answer to ourrequests we consider problem with network and notify the provider.",
	"Method": "void notifyConnectionFailed(){\r\n    if (sipRegistrarConnection.isRegistrarless()) {\r\n        return;\r\n    }\r\n    if (getRegistrationState().equals(RegistrationState.REGISTERED) && sipRegistrarConnection != null)\r\n        sipRegistrarConnection.setRegistrationState(RegistrationState.CONNECTION_FAILED, RegistrationStateChangeEvent.REASON_NOT_SPECIFIED, \"A timeout occurred while trying to connect to the server.\");\r\n    if (registerUsingNextAddress())\r\n        return;\r\n    if (!getRegistrationState().equals(RegistrationState.UNREGISTERED)) {\r\n        sipRegistrarConnection.setRegistrationState(RegistrationState.CONNECTION_FAILED, RegistrationStateChangeEvent.REASON_NOT_SPECIFIED, \"A timeout occurred while trying to connect to the server.\");\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.TestOperationSetMultiUserChat2.testLeave",
	"Comment": "in testjoinleave, we join a room then leave it and see if thereported chatroom members are reflecting our actions.",
	"Method": "void testLeave(){\r\n    String testRoomName = testRoomBaseName + roomID++;\r\n    ChatRoom opSet1Room = opSetMUC1.createChatRoom(testRoomName, null);\r\n    opSet1Room.join();\r\n    ChatRoom opSet2Room = opSetMUC2.findRoom(testRoomName);\r\n    if (opSet2Room.isJoined())\r\n        opSet2Room.leave();\r\n    assertFalse(\"user is in a room he left or didnt joined\", opSet2Room.isJoined());\r\n    MUCEventCollector opSet1RoomCollector = new MUCEventCollector(opSet1Room, MUCEventCollector.EVENT_PRESENCE);\r\n    MUCEventCollector opSet2RoomCollector = new MUCEventCollector(opSet2Room, MUCEventCollector.EVENT_PRESENCE);\r\n    opSet2Room.join();\r\n    opSet2RoomCollector.waitForEvent(10000);\r\n    opSet1RoomCollector.waitForEvent(10000);\r\n    assertEquals(\"a room member has not been notified that someone else \" + \"joined the room\", 1, opSet1RoomCollector.collectedEvents.size());\r\n    assertTrue(\"user failed to join a room\", opSet2Room.isJoined());\r\n    assertTrue(\"user nickname not found in the room after join \", nameIsOnMemberList(opSet2Room.getUserNickname(), opSet2Room.getMembers()));\r\n    assertTrue(\"user nickname not found in the room after join, \" + \"from peer side\", nameIsOnMemberList(opSet2Room.getUserNickname(), opSet1Room.getMembers()));\r\n    opSet1RoomCollector.collectedEvents.clear();\r\n    opSet2Room.leave();\r\n    opSet1RoomCollector.waitForEvent(10000);\r\n    assertFalse(\"an user is reported present in a room he left\", opSet2Room.isJoined());\r\n    assertFalse(\"user nickname is still on the room list after he left\", nameIsOnMemberList(opSet2Room.getUserNickname(), opSet2Room.getMembers()));\r\n    assertEquals(\"an user joined and left and a room member missed events \", 1, opSet1RoomCollector.collectedEvents.size());\r\n    ChatRoomMemberPresenceChangeEvent memberEvent = (ChatRoomMemberPresenceChangeEvent) opSet1RoomCollector.collectedEvents.get(0);\r\n    assertEquals(\"user received an event of the wrong type \", ChatRoomMemberPresenceChangeEvent.MEMBER_LEFT, memberEvent.getEventType());\r\n    assertEquals(\"the user who left is not the expected one\", fixture.userID2, memberEvent.getChatRoomMember().getContactAddress());\r\n    assertFalse(\"user nickname is still on the room list after he left, \" + \"from the peer side\", nameIsOnMemberList(opSet2Room.getUserNickname(), opSet1Room.getMembers()));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetPersistentPresenceJabberImpl.renameServerStoredContactGroup",
	"Comment": "renames the specified group from the server stored contact list.",
	"Method": "void renameServerStoredContactGroup(ContactGroup group,String newName){\r\n    assertConnected();\r\n    if (!(group instanceof ContactGroupJabberImpl))\r\n        throw new IllegalArgumentException(\"The specified group is not an jabber contact group: \" + group);\r\n    ssContactList.renameGroup((ContactGroupJabberImpl) group, newName);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetServerStoredAccountInfoJabberImpl.isDetailClassEditable",
	"Comment": "determines whether the underlying implementation supports editionof this detail class.",
	"Method": "boolean isDetailClassEditable(Class<? extends GenericDetail> detailClass){\r\n    if (isDetailClassSupported(detailClass)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.gibberishaccregwizz.GibberishAccountRegistrationWizard.loadAccount",
	"Comment": "fills the userid and password fields in this panel with the data commingfrom the given protocolprovider.",
	"Method": "void loadAccount(ProtocolProviderService protocolProvider){\r\n    setModification(true);\r\n    this.protocolProvider = protocolProvider;\r\n    this.registration = new GibberishAccountRegistration();\r\n    this.firstWizardPage.loadAccount(protocolProvider);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.advancedconfig.AdvancedConfigurationPanel.showFormContent",
	"Comment": "shows on the right the configuration form given by the givenconfigformdescriptor.",
	"Method": "void showFormContent(ConfigurationForm configForm){\r\n    this.centerPanel.removeAll();\r\n    JComponent configFormPanel = (JComponent) configForm.getForm();\r\n    configFormPanel.setOpaque(false);\r\n    this.centerPanel.add(configFormPanel, BorderLayout.CENTER);\r\n    this.centerPanel.revalidate();\r\n    this.centerPanel.repaint();\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.TestOperationSetPresence.testChangingStateToAway",
	"Comment": "verify that changing state to away works as supposed to and that itgenerates the corresponding event.",
	"Method": "void testChangingStateToAway(){\r\n    subtestStateTransition(IcqStatusEnum.AWAY);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetPersistentPresenceIcqImpl.renameServerStoredContactGroup",
	"Comment": "renames the specified group from the server stored contact list. thismethod would return before the group has actually been renamed. aserverstoredgroupevent would be dispatched once new namehas been acknowledged by the server.",
	"Method": "void renameServerStoredContactGroup(ContactGroup group,String newName){\r\n    assertConnected();\r\n    if (!(group instanceof ContactGroupIcqImpl))\r\n        throw new IllegalArgumentException(\"The specified group is not an icq contact group: \" + group);\r\n    ssContactList.renameGroup((ContactGroupIcqImpl) group, newName);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetVideoTelephonySipImpl.createVideoCall",
	"Comment": "create a new video call and invite the specified callpeer to it.",
	"Method": "Call createVideoCall(String uri,Call createVideoCall,Contact callee,Call createVideoCall,String uri,QualityPreset qualityPreferences,Call createVideoCall,Address toAddress,QualityPreset qualityPreferences,Call createVideoCall,Contact callee,QualityPreset qualityPreferences){\r\n    Address toAddress;\r\n    try {\r\n        toAddress = parentProvider.parseAddressString(callee.getAddress());\r\n    } catch (ParseException ex) {\r\n        logger.error(ex.getMessage(), ex);\r\n        throw new IllegalArgumentException(ex.getMessage());\r\n    }\r\n    return createVideoCall(toAddress, qualityPreferences);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.jinglesdp.JingleUtils.getFirstCandidate",
	"Comment": "returns the first candidate for the specified componentid ornull if no such component exists.",
	"Method": "CandidatePacketExtension getFirstCandidate(ContentPacketExtension content,int componentID,CandidatePacketExtension getFirstCandidate,IceUdpTransportPacketExtension transport,int componentID){\r\n    for (CandidatePacketExtension cand : transport.getCandidateList()) {\r\n        if (!(cand instanceof RemoteCandidatePacketExtension) && (cand.getComponent() == componentID)) {\r\n            return cand;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.ContactGroupGibberishImpl.contacts",
	"Comment": "returns an iterator over all contacts, member of thiscontactgroup.",
	"Method": "Iterator<Contact> contacts(){\r\n    return this.contacts.iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AccountID.hashCode",
	"Comment": "returns a hash code value for the object. this method issupported for the benefit of hashtables such as those provided byjava.util.hashtable.",
	"Method": "int hashCode(){\r\n    return (accountUID == null) ? 0 : accountUID.hashCode();\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.PortTracker.getPort",
	"Comment": "returns the next port that the using class is supposed to try allocating.",
	"Method": "int getPort(){\r\n    return port;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ContactListTreeModel.clear",
	"Comment": "removes all nodes except the root node and clears all dependencies.",
	"Method": "void clear(){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        try {\r\n            SwingUtilities.invokeAndWait(new Runnable() {\r\n                public void run() {\r\n                    clear();\r\n                }\r\n            });\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        } catch (InvocationTargetException e) {\r\n            e.printStackTrace();\r\n        }\r\n        return;\r\n    }\r\n    int childCount = rootGroupNode.getChildCount();\r\n    int[] removedIndexs = new int[childCount];\r\n    Object[] removedNodes = new Object[childCount];\r\n    for (int i = 0; i < childCount; i++) {\r\n        removedIndexs[i] = i;\r\n        removedNodes[i] = rootGroupNode.getChildAt(i);\r\n    }\r\n    rootGroupNode.clear();\r\n    nodesWereRemoved(rootGroupNode, removedIndexs, removedNodes);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ContactListTreeModel.clear",
	"Comment": "removes all nodes except the root node and clears all dependencies.",
	"Method": "void clear(){\r\n    clear();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ProtocolProviderServiceJabberImpl.isFeatureListSupported",
	"Comment": "determines if the given list of features is supported by thespecified jabber id.",
	"Method": "boolean isFeatureListSupported(String jid,String features){\r\n    try {\r\n        if (discoveryManager == null)\r\n            return false;\r\n        DiscoverInfo featureInfo = discoveryManager.discoverInfoNonBlocking(jid);\r\n        if (featureInfo == null)\r\n            return false;\r\n        for (String feature : features) {\r\n            if (!featureInfo.containsFeature(feature)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    } catch (XMPPException e) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Failed to retrive discovery info.\", e);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.slickless.SlicklessTests.start",
	"Comment": "start the configuration sevice implementation compatibility kit.",
	"Method": "void start(BundleContext bundleContext){\r\n    bc = bundleContext;\r\n    setName(\"SlicklessTests\");\r\n    Hashtable<String, String> properties = new Hashtable<String, String>();\r\n    properties.put(\"service.pid\", getName());\r\n    addTest(createSuite());\r\n    bundleContext.registerService(getClass().getName(), this, properties);\r\n    logger.debug(\"Successfully registered \" + getClass().getName());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.RootContactGroupJabberImpl.findContact",
	"Comment": "returns the contact encapsulating with the spcieified name ornull if no such contact was found.",
	"Method": "ContactJabberImpl findContact(String id){\r\n    if (id == null)\r\n        return null;\r\n    return (ContactJabberImpl) contacts.get(id.toLowerCase());\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.ProtocolProviderFactory.getProtocolProviderFactory",
	"Comment": "finds registered protocolproviderfactory for givenprotocolname.",
	"Method": "ProtocolProviderFactory getProtocolProviderFactory(BundleContext bundleContext,String protocolName){\r\n    Collection<ServiceReference<ProtocolProviderFactory>> serRefs;\r\n    String osgiFilter = \"(\" + ProtocolProviderFactory.PROTOCOL + \"=\" + protocolName + \")\";\r\n    try {\r\n        serRefs = bundleContext.getServiceReferences(ProtocolProviderFactory.class, osgiFilter);\r\n    } catch (InvalidSyntaxException ex) {\r\n        serRefs = null;\r\n        logger.error(ex);\r\n    }\r\n    if ((serRefs == null) || serRefs.isEmpty())\r\n        return null;\r\n    else\r\n        return bundleContext.getService(serRefs.iterator().next());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactListServiceImpl.handleProviderAdded",
	"Comment": "adds the specified provider to the list of currently known providers. incase the provider supports persistent presence the method would alsoextract all contacts and synchronize them with the local contact list.otherwise it would start a process where local contacts would be added onthe server.",
	"Method": "void handleProviderAdded(ProtocolProviderService provider){\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Adding protocol provider \" + provider.getAccountID().getAccountUniqueID());\r\n    OperationSetPersistentPresence opSetPersPresence = provider.getOperationSet(OperationSetPersistentPresence.class);\r\n    this.currentlyInstalledProviders.put(provider.getAccountID().getAccountUniqueID(), provider);\r\n    if (opSetPersPresence != null) {\r\n        try {\r\n            storageManager.extractContactsForAccount(provider.getAccountID().getAccountUniqueID());\r\n            if (logger.isDebugEnabled())\r\n                logger.debug(\"All contacts loaded for account \" + provider.getAccountID().getAccountUniqueID());\r\n        } catch (XMLException exc) {\r\n            logger.error(\"Failed to load contacts for account \" + provider.getAccountID().getAccountUniqueID(), exc);\r\n        }\r\n        synchronizeOpSetWithLocalContactList(opSetPersPresence);\r\n    } else {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Service did not have a pers. pres. op. set.\");\r\n    }\r\n    if (opSetPersPresence != null)\r\n        opSetPersPresence.addContactPresenceStatusListener(this);\r\n    OperationSetContactCapabilities capOpSet = provider.getOperationSet(OperationSetContactCapabilities.class);\r\n    if (capOpSet != null) {\r\n        capOpSet.addContactCapabilitiesListener(this);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.fileaccess.TestFileAccessService.testCreateReadWritePersistentFile",
	"Comment": "tests if it is possible for a file to be created if it does not exist",
	"Method": "void testCreateReadWritePersistentFile(){\r\n    try {\r\n        File file = this.fileAccessService.getPrivatePersistentFile(fileName, FileCategory.PROFILE);\r\n        if (!file.exists()) {\r\n            assertTrue(file.createNewFile());\r\n        }\r\n        writeReadFile(file);\r\n    } catch (Exception e) {\r\n        fail(e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.globalshortcut.CallShortcut.incomingCallReceived",
	"Comment": "this method is called by a protocol provider whenever an incoming call isreceived.",
	"Method": "void incomingCallReceived(CallEvent event){\r\n    addCall(event.getSourceCall(), this.incomingCalls);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.CallConference.addCall",
	"Comment": "adds a specific call to the list of calls participatingin this telephony conference.",
	"Method": "boolean addCall(Call call){\r\n    if (call == null)\r\n        throw new NullPointerException(\"call\");\r\n    synchronized (callsSyncRoot) {\r\n        if (mutableCalls.contains(call))\r\n            return false;\r\n        List<Call> newMutableCalls = new ArrayList<Call>(mutableCalls);\r\n        if (newMutableCalls.add(call)) {\r\n            mutableCalls = newMutableCalls;\r\n            immutableCalls = Collections.unmodifiableList(mutableCalls);\r\n        } else\r\n            return false;\r\n    }\r\n    callAdded(call);\r\n    return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.OneToOneCallPeerPanel.createCenter",
	"Comment": "creates the component hierarchy of the central area of thiscallpeerpanel which displays the photo of the callpeeror the video if any.",
	"Method": "VideoContainer createCenter(){\r\n    sizePhotoLabel();\r\n    return createVideoContainer(photoLabel);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.sysactivity.SystemActivityEventDispatcher.fireSystemActivityEventCurrentThread",
	"Comment": "delivers the specified event to all registered listeners. withoutusing the thread, but delivering them in the calling thread.",
	"Method": "void fireSystemActivityEventCurrentThread(SystemActivityEvent evt){\r\n    List<SystemActivityChangeListener> listenersCopy = new ArrayList<SystemActivityChangeListener>(listeners);\r\n    for (int i = 0; i < listenersCopy.size(); i++) {\r\n        fireSystemActivityEvent(evt, listenersCopy.get(i));\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.setContactName",
	"Comment": "renames all occurrences of the given chatcontact in this chatpanel.",
	"Method": "void setContactName(ChatContact<?> chatContact,String name){\r\n    if (chatContactListPanel != null) {\r\n        chatContactListPanel.renameContact(chatContact);\r\n    }\r\n    ChatContainer chatContainer = getChatContainer();\r\n    chatContainer.setChatTitle(this, name);\r\n    if (chatContainer.getCurrentChat() == this) {\r\n        chatContainer.setTitle(name);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.notification.NotificationServiceImpl.fireNotification",
	"Comment": "if there is a registered event notification of the giveneventtype and the event notification is currently activated, thelist of registered actions is executed.",
	"Method": "void fireNotification(NotificationData data,NotificationData fireNotification,String eventType,NotificationData fireNotification,String eventType,String title,String message,byte[] icon,NotificationData fireNotification,String eventType,String title,String message,byte[] icon,Map<String, Object> extras){\r\n    Notification notification = notifications.get(eventType);\r\n    if ((notification == null) || !notification.isActive())\r\n        return null;\r\n    NotificationData data = new NotificationData(eventType, title, message, icon, extras);\r\n    if (notificationCache != null)\r\n        notificationCache.add(data);\r\n    else\r\n        fireNotification(data);\r\n    return data;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.ParameterPacketExtension.setValue",
	"Comment": "sets that value of the format parameter we are representing here.",
	"Method": "void setValue(String value){\r\n    super.setAttribute(VALUE_ATTR_NAME, value);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.MUCServiceImpl.findChatRoomWrapperFromChatRoomID",
	"Comment": "finds the chatroomwrapper instance associated with thechat room.",
	"Method": "ChatRoomWrapper findChatRoomWrapperFromChatRoomID(String chatRoomID,ProtocolProviderService pps){\r\n    return chatRoomList.findChatRoomWrapperFromChatRoomID(chatRoomID, pps);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.TreeContactList.createAddContactMenu",
	"Comment": "create an the add contact menu, taking into account the number of contactdetails available in the given sourcecontact.",
	"Method": "JMenuItem createAddContactMenu(SourceContact sourceContact){\r\n    JMenuItem addContactComponentTmp = null;\r\n    List<ContactDetail> details = sourceContact.getContactDetails(OperationSetPersistentPresence.class);\r\n    final String displayName = sourceContact.getDisplayName();\r\n    if (details.size() == 0) {\r\n        return null;\r\n    }\r\n    if (details.size() == 1) {\r\n        addContactComponentTmp = new JMenuItem(GuiActivator.getResources().getI18NString(\"service.gui.ADD_CONTACT\"), new ImageIcon(ImageLoader.getImage(ImageLoader.ADD_CONTACT_16x16_ICON)));\r\n        final ContactDetail detail = details.get(0);\r\n        addContactComponentTmp.addActionListener(new ActionListener() {\r\n            public void actionPerformed(ActionEvent e) {\r\n                showAddContactDialog(detail, displayName);\r\n            }\r\n        });\r\n    } else if (details.size() > 1) {\r\n        addContactComponentTmp = new JMenu(GuiActivator.getResources().getI18NString(\"service.gui.ADD_CONTACT\"));\r\n        Iterator<ContactDetail> detailsIter = details.iterator();\r\n        while (detailsIter.hasNext()) {\r\n            final ContactDetail detail = detailsIter.next();\r\n            JMenuItem addMenuItem = new JMenuItem(detail.getDetail());\r\n            ((JMenu) addContactComponentTmp).add(addMenuItem);\r\n            addMenuItem.addActionListener(new ActionListener() {\r\n                public void actionPerformed(ActionEvent e) {\r\n                    showAddContactDialog(detail, displayName);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    return addContactComponentTmp;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.TreeContactList.createAddContactMenu",
	"Comment": "create an the add contact menu, taking into account the number of contactdetails available in the given sourcecontact.",
	"Method": "JMenuItem createAddContactMenu(SourceContact sourceContact){\r\n    showAddContactDialog(detail, displayName);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.TreeContactList.createAddContactMenu",
	"Comment": "create an the add contact menu, taking into account the number of contactdetails available in the given sourcecontact.",
	"Method": "JMenuItem createAddContactMenu(SourceContact sourceContact){\r\n    showAddContactDialog(detail, displayName);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.OperationSetPersistentPresenceGibberishImpl.getSupportedStatusSet",
	"Comment": "returns the set of presencestatus objects that a user of this servicemay request the provider to enter.",
	"Method": "Iterator<PresenceStatus> getSupportedStatusSet(){\r\n    return GibberishStatusEnum.supportedStatusSet();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractOperationSetPersistentPresence.fireProviderStatusMessageChangeEvent",
	"Comment": "notify all provider presence listeners that a new status message has beenset.",
	"Method": "void fireProviderStatusMessageChangeEvent(String oldStatusMessage,String newStatusMessage){\r\n    PropertyChangeEvent evt = new PropertyChangeEvent(parentProvider, ProviderPresenceStatusListener.STATUS_MESSAGE, oldStatusMessage, newStatusMessage);\r\n    Collection<ProviderPresenceStatusListener> listeners;\r\n    synchronized (providerPresenceStatusListeners) {\r\n        listeners = new ArrayList<ProviderPresenceStatusListener>(providerPresenceStatusListeners);\r\n    }\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Dispatching  stat. msg change. Listeners=\" + listeners.size() + \" evt=\" + evt);\r\n    for (ProviderPresenceStatusListener listener : listeners) listener.providerStatusMessageChanged(evt);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AccountManager.doLoadStoredAccounts",
	"Comment": "loads the accounts stored for a specificprotocolproviderfactory.",
	"Method": "void doLoadStoredAccounts(ProtocolProviderFactory factory){\r\n    ConfigurationService configService = ProtocolProviderActivator.getConfigurationService();\r\n    String factoryPackage = getFactoryImplPackageName(factory);\r\n    List<String> accounts = configService.getPropertyNamesByPrefix(factoryPackage, true);\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Discovered \" + accounts.size() + \" stored \" + factoryPackage + \" accounts\");\r\n    for (Iterator<String> storedAccountIter = accounts.iterator(); storedAccountIter.hasNext(); ) {\r\n        String storedAccount = storedAccountIter.next();\r\n        int dotIndex = storedAccount.lastIndexOf(\".\");\r\n        if (!storedAccount.substring(dotIndex + 1).startsWith(ACCOUNT_UID_PREFIX))\r\n            continue;\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Loading account \" + storedAccount);\r\n        List<String> storedAccountProperties = configService.getPropertyNamesByPrefix(storedAccount, false);\r\n        Map<String, String> accountProperties = new Hashtable<String, String>();\r\n        boolean disabled = false;\r\n        CredentialsStorageService credentialsStorage = ServiceUtils.getService(bundleContext, CredentialsStorageService.class);\r\n        int prefLen = storedAccount.length() + 1;\r\n        for (Iterator<String> storedAccountPropertyIter = storedAccountProperties.iterator(); storedAccountPropertyIter.hasNext(); ) {\r\n            String property = storedAccountPropertyIter.next();\r\n            String value = configService.getString(property);\r\n            if (prefLen > property.length())\r\n                continue;\r\n            property = property.substring(prefLen);\r\n            if (ProtocolProviderFactory.IS_ACCOUNT_DISABLED.equals(property))\r\n                disabled = Boolean.parseBoolean(value);\r\n            else if (ProtocolProviderFactory.PASSWORD.equals(property) && !credentialsStorage.isStoredEncrypted(storedAccount)) {\r\n                if ((value != null) && value.length() != 0) {\r\n                    value = new String(Base64.decode(value));\r\n                }\r\n            }\r\n            if (value != null)\r\n                accountProperties.put(property, value);\r\n        }\r\n        try {\r\n            AccountID accountID = factory.createAccount(accountProperties);\r\n            if (accountID == null)\r\n                continue;\r\n            synchronized (storedAccounts) {\r\n                storedAccounts.add(accountID);\r\n            }\r\n            if (!disabled)\r\n                factory.loadAccount(accountID);\r\n        } catch (Exception ex) {\r\n            logger.error(\"Failed to load account \" + accountProperties, ex);\r\n        } catch (ExceptionInInitializerError ex) {\r\n            logger.error(\"Failed to create account service instance for account \" + accountProperties, ex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.gui.event.ContactListEvent.getSourceContact",
	"Comment": "returns the uicontactdescriptor for which this event occured.",
	"Method": "UIContact getSourceContact(){\r\n    if (getSource() instanceof UIContact)\r\n        return (UIContact) getSource();\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockChatRoom.getConfigurationForm",
	"Comment": "returns the chatroomconfigurationform containing allconfiguration properties for this chat room. not implemented for mockchat rooms.",
	"Method": "ChatRoomConfigurationForm getConfigurationForm(){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.AbstractOperationSetVideoTelephony.getConferenceMember",
	"Comment": "returns the conferencemember corresponding to the givenvisualcomponent.",
	"Method": "ConferenceMember getConferenceMember(CallPeer peer,Component visualComponent){\r\n    @SuppressWarnings(\"unchecked\")\r\n    W w = (W) peer;\r\n    VideoMediaStream videoStream = (VideoMediaStream) w.getMediaHandler().getStream(MediaType.VIDEO);\r\n    if (videoStream != null) {\r\n        for (ConferenceMember member : peer.getConferenceMembers()) {\r\n            Component memberComponent = videoStream.getVisualComponent(member.getVideoSsrc());\r\n            if (visualComponent.equals(memberComponent))\r\n                return member;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.UserCredentials.getUserName",
	"Comment": "returns the name of the user that these credentials relate to.",
	"Method": "String getUserName(){\r\n    return this.userName;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ChatRoomConfigurationWindow.computeLabelWidth",
	"Comment": "computes the maximum width of a label in the configuration form.",
	"Method": "int computeLabelWidth(ChatRoomConfigurationForm configForm){\r\n    int labelWidth = 0;\r\n    Iterator<ChatRoomConfigurationFormField> configurationSet = configForm.getConfigurationSet();\r\n    while (configurationSet.hasNext()) {\r\n        ChatRoomConfigurationFormField formField = configurationSet.next();\r\n        if (formField.getLabel() == null)\r\n            continue;\r\n        JLabel label = new JLabel(formField.getLabel());\r\n        int newLabelWidth = SwingUtilities.computeStringWidth(label.getFontMetrics(label.getFont()), formField.getLabel());\r\n        if (newLabelWidth > labelWidth)\r\n            labelWidth = newLabelWidth;\r\n    }\r\n    return labelWidth + 10;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.MetaContactChatSession.getHistoryAfterDate",
	"Comment": "returns a collection of the last n number of messages given by count.",
	"Method": "Collection<Object> getHistoryAfterDate(Date date,int count){\r\n    final MetaHistoryService metaHistory = GuiActivator.getMetaHistoryService();\r\n    if (metaHistory == null)\r\n        return null;\r\n    return metaHistory.findFirstMessagesAfter(chatHistoryFilter, metaContact, date, ConfigurationUtils.getChatHistorySize());\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.notification.PopupMessageNotificationAction.setGroupName",
	"Comment": "sets the name of the group that will be used for merging popups.",
	"Method": "void setGroupName(String groupName){\r\n    this.groupName = groupName;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.ConfigurationUtils.getChatHistorySize",
	"Comment": "returns the number of messages from chat history that would be shown inthe chat window.",
	"Method": "int getChatHistorySize(){\r\n    return chatHistorySize;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.MainFrame.requestFocusInContactList",
	"Comment": "requests the focus in the center panel, which contains either thecontact list or the unknown contact panel.",
	"Method": "void requestFocusInContactList(){\r\n    centerPanel.requestFocusInWindow();\r\n    GuiActivator.getContactList().requestFocus();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatSession.getChatTransports",
	"Comment": "returns all available chat transports for this chat session. each chattransport is corresponding to a protocol provider.",
	"Method": "Iterator<ChatTransport> getChatTransports(){\r\n    return chatTransports.iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.FileTransferRequestEvent.getTimestamp",
	"Comment": "a timestamp indicating the exact date when the event occurred.",
	"Method": "Date getTimestamp(){\r\n    return timestamp;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomMemberJabberImpl.getAvatar",
	"Comment": "returns the avatar of this member, that can be used when including it inuser interface.",
	"Method": "byte[] getAvatar(){\r\n    return avatar;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.InfoRetreiver.getDetails",
	"Comment": "returns the user details from the specified classexactly that class not its descendants",
	"Method": "Iterator<GenericDetail> getDetails(String uin,Class<? extends GenericDetail> detailClass){\r\n    List<GenericDetail> details = getContactDetails(uin);\r\n    List<GenericDetail> result = new LinkedList<GenericDetail>();\r\n    for (GenericDetail item : details) if (detailClass.equals(item.getClass()))\r\n        result.add(item);\r\n    return result.iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetWhiteboardingJabberImpl.removePresenceListener",
	"Comment": "removes a listener that was being notified of changes in our status ina room such as us being kicked, banned or dropped.",
	"Method": "void removePresenceListener(WhiteboardSessionPresenceListener listener){\r\n    synchronized (presenceListeners) {\r\n        presenceListeners.remove(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.callhistory.CallRecord.getProtocolProvider",
	"Comment": "returns the protocol provider used for the call. could be null if therecord has not saved the provider.",
	"Method": "ProtocolProviderService getProtocolProvider(){\r\n    return protocolProvider;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.DesktopSharingMouseAndKeyboardListener.mouseReleased",
	"Comment": "invoked when a mouse button has been released on a component.",
	"Method": "void mouseReleased(MouseEvent e){\r\n    if (desktopSharingClient != null) {\r\n        desktopSharingClient.sendMouseEvent(callPeer, e, videoComponent.getSize());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.MasterPasswordInputDialog.createIconComponent",
	"Comment": "creates the icon component to show on the left of this dialog.",
	"Method": "Component createIconComponent(){\r\n    JPanel wrapIconPanel = new TransparentPanel(new BorderLayout());\r\n    JLabel iconLabel = new JLabel();\r\n    iconLabel.setIcon(DesktopUtilActivator.getResources().getImage(\"service.gui.icons.AUTHORIZATION_ICON\"));\r\n    wrapIconPanel.add(iconLabel, BorderLayout.NORTH);\r\n    return wrapIconPanel;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.CallConference.removeCall",
	"Comment": "removes a specific call from the list of callsparticipating in this telephony conference.",
	"Method": "boolean removeCall(Call call){\r\n    if (call == null)\r\n        return false;\r\n    synchronized (callsSyncRoot) {\r\n        if (!mutableCalls.contains(call))\r\n            return false;\r\n        List<Call> newMutableCalls = new ArrayList<Call>(mutableCalls);\r\n        if (newMutableCalls.remove(call)) {\r\n            mutableCalls = newMutableCalls;\r\n            immutableCalls = Collections.unmodifiableList(mutableCalls);\r\n        } else\r\n            return false;\r\n    }\r\n    callRemoved(call);\r\n    return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractOperationSetDesktopSharingClient.getListeners",
	"Comment": "gets a list of remotecontrollisteners to be notified of remotecontrol access changes.",
	"Method": "List<RemoteControlListener> getListeners(){\r\n    List<RemoteControlListener> listeners;\r\n    synchronized (this.listeners) {\r\n        Iterator<WeakReference<RemoteControlListener>> i = this.listeners.iterator();\r\n        listeners = new ArrayList<RemoteControlListener>(this.listeners.size());\r\n        while (i.hasNext()) {\r\n            RemoteControlListener l = i.next().get();\r\n            if (l == null)\r\n                i.remove();\r\n            else\r\n                listeners.add(l);\r\n        }\r\n    }\r\n    return listeners;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ContactListTransferHandler.importData",
	"Comment": "handles transfers to the contact list from the clip board or adnd drop operation. the transferable parameter contains thedata that needs to be imported.",
	"Method": "boolean importData(JComponent comp,Transferable t){\r\n    if (t.isDataFlavorSupported(DataFlavor.javaFileListFlavor)) {\r\n        Object o = null;\r\n        try {\r\n            o = t.getTransferData(DataFlavor.javaFileListFlavor);\r\n        } catch (UnsupportedFlavorException e) {\r\n            if (logger.isDebugEnabled())\r\n                logger.debug(\"Failed to drop files.\", e);\r\n        } catch (IOException e) {\r\n            if (logger.isDebugEnabled())\r\n                logger.debug(\"Failed to drop files.\", e);\r\n        }\r\n        if (o instanceof Collection) {\r\n            ChatPanel chatPanel = getChatPanel();\r\n            if (chatPanel != null) {\r\n                Collection<File> files = (Collection<File>) o;\r\n                for (File file : files) {\r\n                    chatPanel.sendFile(file);\r\n                    GuiActivator.getUIService().getChatWindowManager().openChat(chatPanel, false);\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n    } else if (t.isDataFlavorSupported(uiContactDataFlavor)) {\r\n        Object o = null;\r\n        try {\r\n            o = t.getTransferData(uiContactDataFlavor);\r\n        } catch (UnsupportedFlavorException e) {\r\n            if (logger.isDebugEnabled())\r\n                logger.debug(\"Failed to drop meta contact.\", e);\r\n        } catch (IOException e) {\r\n            if (logger.isDebugEnabled())\r\n                logger.debug(\"Failed to drop meta contact.\", e);\r\n        }\r\n        if (o instanceof ContactNode && comp instanceof TreeContactList) {\r\n            UIContact transferredContact = ((ContactNode) o).getContactDescriptor();\r\n            if (!(transferredContact instanceof MetaUIContact))\r\n                return false;\r\n            TreeContactList list = (TreeContactList) comp;\r\n            Object dest = list.getSelectedValue();\r\n            if (transferredContact == null)\r\n                return false;\r\n            if (transferredContact.getDescriptor() instanceof MetaContact) {\r\n                MetaContact metaContact = (MetaContact) transferredContact.getDescriptor();\r\n                boolean onlyReadonlyContacts = true;\r\n                Iterator<Contact> iter = metaContact.getContacts();\r\n                while (iter.hasNext()) {\r\n                    Contact c = iter.next();\r\n                    ProtocolProviderService pp = c.getProtocolProvider();\r\n                    OperationSetPersistentPresencePermissions opsetPermissions = pp.getOperationSet(OperationSetPersistentPresencePermissions.class);\r\n                    if (opsetPermissions == null || !opsetPermissions.isReadOnly(c)) {\r\n                        onlyReadonlyContacts = false;\r\n                        break;\r\n                    }\r\n                }\r\n                if (onlyReadonlyContacts)\r\n                    return false;\r\n            }\r\n            if (dest instanceof ContactNode) {\r\n                UIContact destContact = ((ContactNode) dest).getContactDescriptor();\r\n                if (!(destContact instanceof MetaUIContact))\r\n                    return false;\r\n                if (transferredContact != destContact) {\r\n                    String mergeEnabledStr = GuiActivator.getResources().getSettingsString(\"impl.gui.dnd.MERGE_ENABLED\");\r\n                    if (mergeEnabledStr != null && !Boolean.parseBoolean(mergeEnabledStr)) {\r\n                        UIGroup destGroup = destContact.getParentGroup();\r\n                        if (destGroup == null || !(destGroup instanceof MetaUIGroup) || (ConfigurationUtils.isContactMoveDisabled() || ConfigurationUtils.isCreateGroupDisabled()))\r\n                            return false;\r\n                        MetaContactListManager.moveMetaContactToGroup((MetaContact) transferredContact.getDescriptor(), (MetaContactGroup) destGroup.getDescriptor());\r\n                    } else {\r\n                        if (!ConfigurationUtils.isAddContactDisabled()) {\r\n                            MetaContactListManager.moveMetaContactToMetaContact((MetaContact) transferredContact.getDescriptor(), (MetaContact) destContact.getDescriptor());\r\n                        }\r\n                    }\r\n                }\r\n                return true;\r\n            } else if (dest instanceof GroupNode) {\r\n                UIGroup destGroup = ((GroupNode) dest).getGroupDescriptor();\r\n                if (!(destGroup instanceof MetaUIGroup) && !destGroup.equals(list.getRootUIGroup())) {\r\n                    return false;\r\n                }\r\n                if (destGroup instanceof MetaUIGroup && !transferredContact.getParentGroup().equals(destGroup) && !(ConfigurationUtils.isContactMoveDisabled() && ConfigurationUtils.isCreateGroupDisabled())) {\r\n                    MetaContactListManager.moveMetaContactToGroup((MetaContact) transferredContact.getDescriptor(), (MetaContactGroup) destGroup.getDescriptor());\r\n                } else if (destGroup.equals(list.getRootUIGroup())) {\r\n                    MetaContactListManager.moveMetaContactToGroup((MetaContact) transferredContact.getDescriptor(), GuiActivator.getContactListService().getRoot());\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ContactGroupIcqImpl.getNameCopy",
	"Comment": "returns the name of the group as it was at the last call of initnamecopy.",
	"Method": "String getNameCopy(){\r\n    return this.nameCopy;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.utils.ImageLoader.getAccountStatusImage",
	"Comment": "obtains the indexed status image for the given protocol provider.",
	"Method": "ImageIcon getAccountStatusImage(ProtocolProviderService pps){\r\n    OperationSetPresence presence = pps.getOperationSet(OperationSetPresence.class);\r\n    byte[] protocolStatusIcon = (presence == null) ? null : presence.getPresenceStatus().getStatusIcon();\r\n    Image statusImage;\r\n    if (presence != null && protocolStatusIcon != null) {\r\n        statusImage = ImageUtils.getBytesInImage(protocolStatusIcon);\r\n    } else {\r\n        byte[] bytes = pps.getProtocolIcon().getIcon(ProtocolIcon.ICON_SIZE_16x16);\r\n        statusImage = (bytes == null) ? null : ImageUtils.getBytesInImage(bytes);\r\n        if (!pps.isRegistered() && (statusImage != null)) {\r\n            statusImage = LightGrayFilter.createDisabledImage(statusImage);\r\n        }\r\n    }\r\n    return (statusImage == null) ? null : new ImageIcon(getIndexedProtocolImage(statusImage, pps));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageSourceService.updateRecentMessages",
	"Comment": "updates the contact sources in the recent query if any.done here in order to sync with recentmessages instance, and tocheck for already existing instances of contact sources.normally called from the query.",
	"Method": "void updateRecentMessages(){\r\n    if (recentQuery == null)\r\n        return;\r\n    synchronized (recentMessages) {\r\n        List<SourceContact> currentContactsInQuery = recentQuery.getQueryResults();\r\n        for (ComparableEvtObj evtObj : recentMessages) {\r\n            if (!currentContactsInQuery.contains(evtObj)) {\r\n                MessageSourceContact newSourceContact = new MessageSourceContact(evtObj.getEventObject(), MessageSourceService.this);\r\n                newSourceContact.initDetails(evtObj.getEventObject());\r\n                recentQuery.addQueryResult(newSourceContact);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.ServerChatRoomQuery.indexOf",
	"Comment": "returns the index of the contact in the contact results list.",
	"Method": "int indexOf(BaseChatRoomSourceContact contact){\r\n    Iterator<BaseChatRoomSourceContact> it = contactResults.iterator();\r\n    int i = 0;\r\n    while (it.hasNext()) {\r\n        if (contact.equals(it.next())) {\r\n            return i;\r\n        }\r\n        i++;\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "net.librec.recommender.cf.rating.RFRecRecommender.isAvgRating",
	"Comment": "returns 1 if the rating is similar to the rounded average value",
	"Method": "int isAvgRating(double avg,int rating){\r\n    return Math.round(avg) == rating ? 1 : 0;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl.getCallInfoURL",
	"Comment": "returns a url pointing to a location with call control information forthis peer or null if no such url is available for thiscall peer.",
	"Method": "URL getCallInfoURL(){\r\n    return getMediaHandler().getCallInfoURL();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.LocalUserAdHocChatRoomPresenceChangeEvent.getReason",
	"Comment": "a reason string indicating a human readable reason for this event.",
	"Method": "String getReason(){\r\n    return this.reason;\r\n}"
}, {
	"Path": "net.librec.recommender.cf.rating.LLORMAUpdater.run",
	"Comment": "learn this local model based on similar users to the anchor userand similar items to the anchor item.implemented with gradient descent.",
	"Method": "void run(){\r\n    for (int userIdx = 0; userIdx < numUsers; userIdx++) {\r\n        for (int factorIdx = 0; factorIdx < numFactors; factorIdx++) {\r\n            double rdm = Randoms.gaussian(0.0, 0.01);\r\n            localUserFactors.set(userIdx, factorIdx, rdm);\r\n        }\r\n    }\r\n    for (int itemIdx = 0; itemIdx < numItems; itemIdx++) {\r\n        for (int factorIdx = 0; factorIdx < numFactors; factorIdx++) {\r\n            double rdm = Randoms.gaussian(0.0, 0.01);\r\n            localItemFactors.set(itemIdx, factorIdx, rdm);\r\n        }\r\n    }\r\n    for (int iter = 0; iter < localIteration; iter++) {\r\n        for (MatrixEntry matrixEntry : trainMatrix) {\r\n            int userIdx = matrixEntry.row();\r\n            int itemIdx = matrixEntry.column();\r\n            double rating = matrixEntry.get();\r\n            double predictRating = predict(userIdx, itemIdx);\r\n            double error = rating - predictRating;\r\n            double weight = userWeights.get(userIdx) * itemWeights.get(itemIdx);\r\n            for (int factorIdx = 0; factorIdx < numFactors; factorIdx++) {\r\n                double userFactorValue = localUserFactors.get(userIdx, factorIdx);\r\n                double itemFactorValue = localItemFactors.get(itemIdx, factorIdx);\r\n                localUserFactors.plus(userIdx, factorIdx, learnRate * (error * itemFactorValue * weight - localRegUser * userFactorValue));\r\n                localItemFactors.plus(itemIdx, factorIdx, learnRate * (error * userFactorValue * weight - localRegItem * itemFactorValue));\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.argdelegation.ArgDelegationPeerImpl.serviceChanged",
	"Comment": "listens for urihandlers that are registered in the bundlecontext after we had started so that we could add them to the listof currently known handlers.",
	"Method": "void serviceChanged(ServiceEvent event){\r\n    BundleContext bc = event.getServiceReference().getBundle().getBundleContext();\r\n    if (bc == null)\r\n        return;\r\n    Object service = bc.getService(event.getServiceReference());\r\n    if (!(service instanceof UriHandler))\r\n        return;\r\n    UriHandler uriHandler = (UriHandler) service;\r\n    synchronized (uriHandlers) {\r\n        switch(event.getType()) {\r\n            case ServiceEvent.MODIFIED:\r\n            case ServiceEvent.REGISTERED:\r\n                for (String protocol : uriHandler.getProtocol()) {\r\n                    uriHandlers.put(protocol, uriHandler);\r\n                }\r\n                break;\r\n            case ServiceEvent.UNREGISTERING:\r\n                for (String protocol : uriHandler.getProtocol()) {\r\n                    if (uriHandlers.get(protocol) == uriHandler)\r\n                        uriHandlers.remove(protocol);\r\n                }\r\n                break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetDesktopStreamingSipImpl.createVideoCall",
	"Comment": "create a new video call and invite the specified callpeer to it.",
	"Method": "Call createVideoCall(String uri,MediaDevice mediaDevice,Call createVideoCall,Contact callee,MediaDevice mediaDevice,Call createVideoCall,Address toAddress,MediaDevice mediaDevice,Call createVideoCall,String uri,Call createVideoCall,Contact callee){\r\n    CallSipImpl call = (CallSipImpl) super.createVideoCall(callee);\r\n    MediaDevice device = call.getDefaultDevice(MediaType.VIDEO);\r\n    size = (((VideoMediaFormat) device.getFormat()).getSize());\r\n    origin = getOriginForMediaDevice(device);\r\n    return call;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipRegistrarConnection.setTransport",
	"Comment": "changes transport of registrar connection and recreatesregistrar uri.",
	"Method": "void setTransport(String newRegistrationTransport){\r\n    if (newRegistrationTransport.equals(registrationTransport))\r\n        return;\r\n    this.registrationTransport = newRegistrationTransport;\r\n    if (!registrationTransport.equals(ListeningPoint.UDP))\r\n        registrarURI = null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.chatconfig.ChatConfigActivator.getResources",
	"Comment": "gets the service giving access to all application resources.",
	"Method": "ResourceManagementService getResources(){\r\n    if (resourceService == null)\r\n        resourceService = ResourceManagementServiceUtils.getService(bundleContext);\r\n    return resourceService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.getLastSentMessageUID",
	"Comment": "returns the id of the last message sent in this chat, or nullif no messages have been sent yet.",
	"Method": "String getLastSentMessageUID(){\r\n    return lastSentMessageUID;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MclStorageManager.launchStorageThread",
	"Comment": "launches a separate thread that waits on the contact list rw lock andwhen notified stores the contact list in case there have beenmodifications since last time it saved.",
	"Method": "void launchStorageThread(){\r\n    new Thread() {\r\n        @Override\r\n        public void run() {\r\n            try {\r\n                synchronized (contactListRWLock) {\r\n                    while (isStarted()) {\r\n                        contactListRWLock.wait(5000);\r\n                        if (isModified) {\r\n                            storeContactList0();\r\n                            isModified = false;\r\n                        }\r\n                    }\r\n                }\r\n            } catch (IOException ex) {\r\n                logger.error(\"Storing contact list failed\", ex);\r\n                started = false;\r\n            } catch (InterruptedException ex) {\r\n                logger.error(\"Storing contact list failed\", ex);\r\n                started = false;\r\n            }\r\n        }\r\n    }.start();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MclStorageManager.launchStorageThread",
	"Comment": "launches a separate thread that waits on the contact list rw lock andwhen notified stores the contact list in case there have beenmodifications since last time it saved.",
	"Method": "void launchStorageThread(){\r\n    try {\r\n        synchronized (contactListRWLock) {\r\n            while (isStarted()) {\r\n                contactListRWLock.wait(5000);\r\n                if (isModified) {\r\n                    storeContactList0();\r\n                    isModified = false;\r\n                }\r\n            }\r\n        }\r\n    } catch (IOException ex) {\r\n        logger.error(\"Storing contact list failed\", ex);\r\n        started = false;\r\n    } catch (InterruptedException ex) {\r\n        logger.error(\"Storing contact list failed\", ex);\r\n        started = false;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.SendSmsDialog.sendSmsMessage",
	"Comment": "sends the given message to the given phonenumber, using the currentsms operation set.",
	"Method": "void sendSmsMessage(String phoneNumber,String message){\r\n    if (phoneNumber != null)\r\n        chatTransport.getParentChatSession().setDefaultSmsNumber(phoneNumber);\r\n    SMSManager.sendSMS(phoneNumber, message, chatTransport, chatPanel);\r\n    this.dispose();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.UIFilterQuery.fireFilterQueryEvent",
	"Comment": "notifies the filterquerylistener of the result status ofthis query.",
	"Method": "void fireFilterQueryEvent(){\r\n    isRunning = false;\r\n    if (filterQueryListener == null)\r\n        return;\r\n    if (isSucceeded)\r\n        filterQueryListener.filterQuerySucceeded(this);\r\n    else\r\n        filterQueryListener.filterQueryFailed(this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl.getSupportedMethods",
	"Comment": "returns a list of strings corresponding to all methods that we have aprocessor for.",
	"Method": "List<String> getSupportedMethods(){\r\n    return new ArrayList<String>(methodProcessors.keySet());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.OneToOneCallPanel.updateHoldButtonState",
	"Comment": "updates the state of the general hold button. the hold button is selectedonly if all call peers are locally or mutually on hold at the same time.in all other cases the hold button is unselected.",
	"Method": "void updateHoldButtonState(){\r\n    callContainer.updateHoldButtonState();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.conference.ConferencePeerPanel.setErrorReason",
	"Comment": "sets the reason of a call failure if one occurs. the renderer shoulddisplay this reason to the user.",
	"Method": "void setErrorReason(String reason){\r\n    super.setErrorReason(reason);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractOperationSetDesktopSharingClient.addRemoteControlListener",
	"Comment": "adds a remotecontrollistener to be notified when the remote peeraccepts to give us full control of their desktop.the default implementation ofabstractoperationsetdesktopsharingclient adds aweakreference to the specified remotecontrollistener inorder to avoid memory leaks because of code which callsaddremotecontrollistener and never callsremoveremotecontrollistener.",
	"Method": "void addRemoteControlListener(RemoteControlListener listener){\r\n    synchronized (listeners) {\r\n        Iterator<WeakReference<RemoteControlListener>> i = listeners.iterator();\r\n        boolean contains = false;\r\n        while (i.hasNext()) {\r\n            RemoteControlListener l = i.next().get();\r\n            if (l == null)\r\n                i.remove();\r\n            else if (l.equals(listener))\r\n                contains = true;\r\n        }\r\n        if (!contains) {\r\n            listeners.add(new WeakReference<RemoteControlListener>(listener));\r\n            listener.getCallPeer().addCallPeerListener(callPeerListener);\r\n        }\r\n    }\r\n    CallPeer peer = listener.getCallPeer();\r\n    if (this.removesNullAndRevokedControlPeer(peer.getPeerID()) != -1)\r\n        listener.remoteControlGranted(new RemoteControlGrantedEvent(peer));\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.aimaccregwizz.FirstWizardPage.loadAccount",
	"Comment": "fills the uin and password fields in this panel with the data comingfrom the given protocolprovider.",
	"Method": "void loadAccount(ProtocolProviderService protocolProvider){\r\n    AccountID accountID = protocolProvider.getAccountID();\r\n    String password = AimAccRegWizzActivator.getAimProtocolProviderFactory().loadPassword(accountID);\r\n    this.uinField.setEnabled(false);\r\n    this.uinField.setText(accountID.getUserID());\r\n    if (password != null) {\r\n        this.passField.setText(password);\r\n        this.rememberPassBox.setSelected(wizard.getRegistration().isRememberPassword());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.TreeContactList.initContactSources",
	"Comment": "initializes the list of available contact sources for this contact list.",
	"Method": "void initContactSources(){\r\n    for (ContactSourceService contactSource : GuiActivator.getContactSources()) {\r\n        if (!(contactSource instanceof AsyncContactSourceService) || ((AsyncContactSourceService) contactSource).canBeUsedToSearchContacts()) {\r\n            ExternalContactSource extContactSource = new ExternalContactSource(contactSource, this);\r\n            int sourceIndex = contactSource.getIndex();\r\n            if (sourceIndex >= 0 && contactSources.size() >= sourceIndex)\r\n                contactSources.add(sourceIndex, extContactSource);\r\n            else\r\n                contactSources.add(extContactSource);\r\n        }\r\n    }\r\n    GuiActivator.bundleContext.addServiceListener(new ContactSourceServiceListener());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chatroomslist.createforms.CreateChatRoomWizardPage1.editingCanceled",
	"Comment": "when user canceled editing the next button is enabled or disableddepending on if the user has selected a check box or not.",
	"Method": "void editingCanceled(ChangeEvent e){\r\n    setNextButtonAccordingToCheckBox();\r\n}"
}, {
	"Path": "net.librec.recommender.MatrixRecommender.predict",
	"Comment": "predict a specific rating for user useridx on item itemidx. it is useful for evalution which requires predictions arebounded.",
	"Method": "double predict(int userIdx,int itemIdx,double predict,int userIdx,int itemIdx,boolean bound){\r\n    double predictRating = predict(userIdx, itemIdx);\r\n    if (bound) {\r\n        if (predictRating > maxRate) {\r\n            predictRating = maxRate;\r\n        } else if (predictRating < minRate) {\r\n            predictRating = minRate;\r\n        }\r\n    }\r\n    return predictRating;\r\n}"
}, {
	"Path": "com.acme.ChatServlet.doGet",
	"Comment": "this should be static content and should use real js libraries.",
	"Method": "void doGet(HttpServletRequest request,HttpServletResponse response){\r\n    if (request.getParameter(\"action\") != null)\r\n        doPost(request, response);\r\n    else\r\n        getServletContext().getNamedDispatcher(\"default\").forward(request, response);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.EventPackageUtils.removeSubscriptionThenIsDialogAlive",
	"Comment": "dissociates a specific subscription with a given dialog inorder to no longer allow it to keep the dialog in question alive evenafter a bye request, deletes the dialog if there are no othersubscriptions associated with it and a bye request has already beenreceived and returns an indicator which determines whether the specifieddialog is still alive after the dissociation of the given subscription.",
	"Method": "boolean removeSubscriptionThenIsDialogAlive(Dialog dialog,Object subscription){\r\n    synchronized (dialog) {\r\n        DialogApplicationData applicationData = (DialogApplicationData) SipApplicationData.getApplicationData(dialog, SipApplicationData.KEY_SUBSCRIPTIONS);\r\n        if ((applicationData != null) && applicationData.removeSubscription(subscription) && (applicationData.getSubscriptionCount() <= 0) && applicationData.isByeProcessed()) {\r\n            dialog.delete();\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.globaldisplaydetails.GlobalDisplayDetailsImpl.addGlobalDisplayDetailsListener",
	"Comment": "adds the given globaldisplaydetailslistener to listen for changeevents concerning the global display details.",
	"Method": "void addGlobalDisplayDetailsListener(GlobalDisplayDetailsListener l){\r\n    synchronized (displayDetailsListeners) {\r\n        if (!displayDetailsListeners.contains(l))\r\n            displayDetailsListeners.add(l);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatSession.addMemberRoleListener",
	"Comment": "adds the given chatroommemberrolelistener to the containedchat room role listeners.",
	"Method": "void addMemberRoleListener(ChatRoomMemberRoleListener l){\r\n    chatRoomWrapper.getChatRoom().addMemberRoleListener(l);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.utils.PluginContainer.addPluginComponent",
	"Comment": "adds the component of a specific plugincomponent to theassociated container.",
	"Method": "void addPluginComponent(PluginComponentFactory factory){\r\n    PluginComponent c = factory.getPluginComponentInstance(PluginContainer.this);\r\n    if (logger.isInfoEnabled())\r\n        logger.info(\"Will add plugin component: \" + c);\r\n    int cIndex = factory.getPositionIndex();\r\n    int index = -1;\r\n    int i = 0;\r\n    for (PluginComponent pluginComponent : pluginComponents) {\r\n        if (pluginComponent.equals(c))\r\n            return;\r\n        if (-1 == index) {\r\n            int pluginComponentIndex = factory.getPositionIndex();\r\n            if ((0 == cIndex) || (-1 == cIndex)) {\r\n                if ((0 != pluginComponentIndex) && (cIndex != pluginComponentIndex))\r\n                    index = i;\r\n            } else if (cIndex < pluginComponentIndex)\r\n                index = i;\r\n        }\r\n        i++;\r\n    }\r\n    int pluginComponentCount = pluginComponents.size();\r\n    if (-1 == index)\r\n        index = pluginComponents.size();\r\n    int containerComponentCount = getComponentCount(container);\r\n    addComponentToContainer((Component) c.getComponent(), container, (containerComponentCount > pluginComponentCount) ? (index + (containerComponentCount - pluginComponentCount)) : index);\r\n    pluginComponents.add(index, c);\r\n    container.revalidate();\r\n    container.repaint();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.TreeContactList.mousePressed",
	"Comment": "when the right mouse button is clicked on a contact cell, the cell isselected and the contactrightbuttonmenu is opened.when the right mouse button is clicked on a group cell, the cell isselected and the grouprightbuttonmenu is opened.when the middle mouse button is clicked on a cell, the cell is selected.",
	"Method": "void mousePressed(MouseEvent e){\r\n    if (!isGroupClickConsumed) {\r\n        for (MouseListener listener : originalMouseListeners) listener.mousePressed(e);\r\n    }\r\n    TreePath path = this.getPathForLocation(e.getX(), e.getY());\r\n    if (path == null)\r\n        return;\r\n    Object lastComponent = path.getLastPathComponent();\r\n    if (!(lastComponent instanceof TreeNode))\r\n        return;\r\n    boolean isSelected = path.equals(getSelectionPath());\r\n    if (!isSelected && (e.getModifiers() & InputEvent.BUTTON2_MASK) != 0 || (e.getModifiers() & InputEvent.BUTTON3_MASK) != 0 || (e.isControlDown() && !e.isMetaDown())) {\r\n        this.setSelectionPath(path);\r\n    }\r\n    if (isRightButtonMenuEnabled) {\r\n        if (lastComponent instanceof ContactNode) {\r\n            UIContact uiContact = ((ContactNode) lastComponent).getContactDescriptor();\r\n            if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0 || (e.isControlDown() && !e.isMetaDown())) {\r\n                rightButtonMenu = uiContact.getRightButtonMenu();\r\n                openRightButtonMenu(e.getPoint());\r\n            }\r\n        } else if (lastComponent instanceof GroupNode) {\r\n            UIGroup uiGroup = ((GroupNode) lastComponent).getGroupDescriptor();\r\n            if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0 || (e.isControlDown() && !e.isMetaDown())) {\r\n                rightButtonMenu = uiGroup.getRightButtonMenu();\r\n                openRightButtonMenu(e.getPoint());\r\n            }\r\n        }\r\n    }\r\n    if (isSelected && e.getClickCount() < 2)\r\n        dispatchEventToButtons(e);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ContactListTreeCellRenderer.getDesktopSharingButton",
	"Comment": "returns the desktop sharing button contained in the current cell.",
	"Method": "JButton getDesktopSharingButton(){\r\n    return desktopSharingButton;\r\n}"
}, {
	"Path": "org.eclipse.jetty.xml.XmlConfiguration.getIdMap",
	"Comment": "get the map of id string to objects that is used to holdand lookup any objects by id.a new, get or call xml element may have anid attribute which will cause the resulting object to be placed intothis map.a ref xml element will lookup an object from this map.when chaining configuration files, it is good practise to copy the id entries from the id map to the map of the next configuration, sothat they may share an id space",
	"Method": "Map<String, Object> getIdMap(){\r\n    return _idMap;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommTextField.mousePressed",
	"Comment": "indicates that the mouse button was pressed on this component. hidesthe default text when user clicks on the text field.",
	"Method": "void mousePressed(MouseEvent e){\r\n    if (getText() == null) {\r\n        clearDefaultText();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl.processTransactionTerminated",
	"Comment": "process an asynchronously reported transactionterminatedevent.when a transaction transitions to the terminated state, the stackkeeps no further records of the transaction. this notification can be used byapplications to clean up any auxiliary data that is being maintainedfor the given transaction.",
	"Method": "void processTransactionTerminated(TransactionTerminatedEvent transactionTerminatedEvent){\r\n    Transaction transaction;\r\n    if (transactionTerminatedEvent.isServerTransaction())\r\n        transaction = transactionTerminatedEvent.getServerTransaction();\r\n    else\r\n        transaction = transactionTerminatedEvent.getClientTransaction();\r\n    if (transaction == null) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"ignoring a transactionless transaction terminated event\");\r\n        return;\r\n    }\r\n    Request request = transaction.getRequest();\r\n    String method = request.getMethod();\r\n    List<MethodProcessor> processors = methodProcessors.get(method);\r\n    if (processors != null) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Found \" + processors.size() + \" processor(s) for method \" + method);\r\n        for (MethodProcessor processor : processors) {\r\n            if (processor.processTransactionTerminated(transactionTerminatedEvent)) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipApplicationData.getApplicationData",
	"Comment": "retrieves a value associated to the a key string in thecontainer. currently sipmessage, transactionand dialog are supported as container.",
	"Method": "Object getApplicationData(Object container,String key){\r\n    if (container == null) {\r\n        logger.debug(\"container is null\");\r\n        return null;\r\n    }\r\n    if (key == null) {\r\n        logger.warn(\"key is null\");\r\n        return null;\r\n    }\r\n    SipApplicationData appData = getSipApplicationData(container);\r\n    if (appData == null)\r\n        return null;\r\n    return appData.get(key);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.contactlist.MetaContactListServiceLick.fillMockContactList",
	"Comment": "creates a number of dummy contacts and fills the specified provider withthem.",
	"Method": "void fillMockContactList(MockProvider provider){\r\n    MockPersistentPresenceOperationSet mockOpSet = (MockPersistentPresenceOperationSet) provider.getOperationSet(OperationSetPersistentPresence.class);\r\n    MockContactGroup root = (MockContactGroup) mockOpSet.getServerStoredContactListRoot();\r\n    root.addContact(new MockContact(\"Ivan Ivanov\", provider));\r\n    root.addContact(new MockContact(\"Martin Dupont\", provider));\r\n    root.addContact(new MockContact(\"Joe Bloggs\", provider));\r\n    MockContact someOfflineContact = new MockContact(\"I am offline\", provider);\r\n    someOfflineContact.setPresenceStatus(MockStatusEnum.MOCK_STATUS_00);\r\n    root.addContact(someOfflineContact);\r\n    mockContactToRename = new MockContact(\"Jane Doe\", provider);\r\n    root.addContact(mockContactToRename);\r\n    mockContactToReorder = new MockContact(\"ZI'llChangeMyStatus\", provider);\r\n    mockContactToReorder.setPresenceStatus(MockStatusEnum.MOCK_STATUS_00);\r\n    root.addContact(mockContactToReorder);\r\n    topLevelMockGroup = new MockContactGroup(topLevelGroupName, provider);\r\n    subLevelContact = new MockContact(subLevelContactName, provider);\r\n    topLevelMockGroup.addContact(subLevelContact);\r\n    topLevelMockGroup.addContact(new MockContact(\"Pencho\", provider));\r\n    topLevelMockGroup.addContact(new MockContact(\"Toto\", provider));\r\n    subLevelGroup = new MockContactGroup(\"SubSubGroup\", provider);\r\n    subsubContact = new MockContact(\"SContact1\", provider);\r\n    subLevelGroup.addContact(subsubContact);\r\n    subLevelGroup.addContact(new MockContact(\"SContact2\", provider));\r\n    subLevelGroup.addContact(new MockContact(\"SContact3\", provider));\r\n    subLevelGroup.addContact(new MockContact(\"SContact4\", provider));\r\n    topLevelMockGroup.addSubgroup(subLevelGroup);\r\n    root.addSubgroup(topLevelMockGroup);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.MetaContactListSource.initCustomActionButtons",
	"Comment": "initializes custom action buttons for this contact source.",
	"Method": "void initCustomActionButtons(){\r\n    customActionButtons = new LinkedHashMap<ContactAction<Contact>, SIPCommButton>();\r\n    for (CustomContactActionsService<Contact> ccas : getContactActionsServices()) {\r\n        Iterator<ContactAction<Contact>> actionIterator = ccas.getCustomContactActions();\r\n        while (actionIterator != null && actionIterator.hasNext()) {\r\n            final ContactAction<Contact> ca = actionIterator.next();\r\n            SIPCommButton actionButton = customActionButtons.get(ca);\r\n            if (actionButton == null) {\r\n                actionButton = new SIPCommButton();\r\n                actionButton.setToolTipText(ca.getToolTipText());\r\n                actionButton.setIconImage(new ImageIcon(ca.getIcon()).getImage());\r\n                actionButton.setRolloverIcon(new ImageIcon(ca.getRolloverIcon()).getImage());\r\n                actionButton.setPressedIcon(new ImageIcon(ca.getPressedIcon()).getImage());\r\n                actionButton.addActionListener(new ActionListener() {\r\n                    public void actionPerformed(ActionEvent e) {\r\n                        List<UIContactDetail> contactDetails = customActionContact.getContactDetails();\r\n                        UIContactDetailCustomAction contactAction = new UIContactDetailCustomAction(ca);\r\n                        if (contactDetails.size() > 1) {\r\n                            ChooseUIContactDetailPopupMenu detailsPopupMenu = new ChooseUIContactDetailPopupMenu((JButton) e.getSource(), customActionContact.getContactDetails(), contactAction);\r\n                            detailsPopupMenu.showPopupMenu();\r\n                        } else if (contactDetails.size() == 1) {\r\n                            JButton button = (JButton) e.getSource();\r\n                            Point location = new Point(button.getX(), button.getY() + button.getHeight());\r\n                            SwingUtilities.convertPointToScreen(location, GuiActivator.getContactList());\r\n                            location.y = location.y + GuiActivator.getContactList().getPathBounds(GuiActivator.getContactList().getSelectionPath()).y;\r\n                            contactAction.actionPerformed(contactDetails.get(0), location.x, location.y);\r\n                        }\r\n                    }\r\n                });\r\n                customActionButtons.put(ca, actionButton);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.MetaContactListSource.initCustomActionButtons",
	"Comment": "initializes custom action buttons for this contact source.",
	"Method": "void initCustomActionButtons(){\r\n    List<UIContactDetail> contactDetails = customActionContact.getContactDetails();\r\n    UIContactDetailCustomAction contactAction = new UIContactDetailCustomAction(ca);\r\n    if (contactDetails.size() > 1) {\r\n        ChooseUIContactDetailPopupMenu detailsPopupMenu = new ChooseUIContactDetailPopupMenu((JButton) e.getSource(), customActionContact.getContactDetails(), contactAction);\r\n        detailsPopupMenu.showPopupMenu();\r\n    } else if (contactDetails.size() == 1) {\r\n        JButton button = (JButton) e.getSource();\r\n        Point location = new Point(button.getX(), button.getY() + button.getHeight());\r\n        SwingUtilities.convertPointToScreen(location, GuiActivator.getContactList());\r\n        location.y = location.y + GuiActivator.getContactList().getPathBounds(GuiActivator.getContactList().getSelectionPath()).y;\r\n        contactAction.actionPerformed(contactDetails.get(0), location.x, location.y);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.loggingutils.LogsCollector.collectJavaCrashLogs",
	"Comment": "searches for java crash logs belonging to us and add them tothe log archive.",
	"Method": "void collectJavaCrashLogs(ZipOutputStream out){\r\n    addCrashFilesToArchive(new File(\".\").listFiles(), JAVA_ERROR_LOG_PREFIX, out);\r\n    String homeDir = System.getProperty(\"user.home\");\r\n    if (OSUtils.IS_WINDOWS) {\r\n        File[] desktopFiles = new File(homeDir + File.separator + \"Desktop\").listFiles();\r\n        addCrashFilesToArchive(desktopFiles, JAVA_ERROR_LOG_PREFIX, out);\r\n    }\r\n    if (OSUtils.IS_MAC) {\r\n        String logDir = \"/Library/Logs/\";\r\n        String[] locations = { logDir + \"CrashReporter\", homeDir + logDir + \"CrashReporter\", homeDir + logDir + \"DiagnosticReports\" };\r\n        for (String location : locations) {\r\n            File[] crashLogs = new File(location).listFiles();\r\n            addCrashFilesToArchive(crashLogs, null, out);\r\n        }\r\n    } else {\r\n        File[] tempFiles = new File(System.getProperty(\"java.io.tmpdir\")).listFiles();\r\n        addCrashFilesToArchive(tempFiles, JAVA_ERROR_LOG_PREFIX, out);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.filetransfer.FileTransferConversationComponent.showErrorMessage",
	"Comment": "shows the given error message in the error area of this component.",
	"Method": "void showErrorMessage(String message){\r\n    errorArea.setText(message);\r\n    errorIconLabel.setVisible(true);\r\n    errorArea.setVisible(true);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.PresenceManager.away",
	"Comment": "set away status and message. disable away status by providingnull message.",
	"Method": "void away(boolean isAway,String awayMessage){\r\n    if (awayMessage != null) {\r\n        this.submittedMessage = verifyMessage(awayMessage);\r\n    }\r\n    if (isAway && (!this.away || awayMessage != null)) {\r\n        this.irc.rawMessage(\"AWAY :\" + this.submittedMessage);\r\n    } else if (isAway != this.away) {\r\n        this.irc.rawMessage(\"AWAY\");\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapContactSourceService.stop",
	"Comment": "stops this contactsourceservice implementation and prepares itfor garbage collection.",
	"Method": "void stop(){\r\n    boolean interrupted = false;\r\n    synchronized (queries) {\r\n        while (!queries.isEmpty()) {\r\n            queries.get(0).cancel();\r\n            try {\r\n                queries.wait();\r\n            } catch (InterruptedException iex) {\r\n                interrupted = true;\r\n            }\r\n        }\r\n    }\r\n    if (interrupted)\r\n        Thread.currentThread().interrupt();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.notification.NotificationServiceImpl.removeActionHandler",
	"Comment": "removes an object that executes the actual action of notification action.",
	"Method": "void removeActionHandler(String actionType){\r\n    if (actionType == null)\r\n        throw new IllegalArgumentException(\"actionType cannot be null\");\r\n    synchronized (handlers) {\r\n        handlers.remove(actionType);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.security.SipSecurityManager.removeBranchID",
	"Comment": "removes all via headers from request and replaces them with anew one, equal to the one that was top most.",
	"Method": "void removeBranchID(Request request){\r\n    ViaHeader viaHeader = (ViaHeader) request.getHeader(ViaHeader.NAME);\r\n    request.removeHeader(ViaHeader.NAME);\r\n    ViaHeader newViaHeader;\r\n    try {\r\n        newViaHeader = headerFactory.createViaHeader(viaHeader.getHost(), viaHeader.getPort(), viaHeader.getTransport(), null);\r\n        request.setHeader(newViaHeader);\r\n    } catch (Exception exc) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"failed to reset a Via header\");\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetBasicTelephonyJabberImpl.subscribeForJinglePackets",
	"Comment": "subscribes us to notifications about incoming jingle packets.",
	"Method": "void subscribeForJinglePackets(){\r\n    protocolProvider.getConnection().addPacketListener(this, this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MclStorageManager.metaContactGroupAdded",
	"Comment": "creates xml nodes for the source metacontact group, its child metacontacts and associated protogroups and adds them to the xml contactlist.",
	"Method": "void metaContactGroupAdded(MetaContactGroupEvent evt){\r\n    if (evt.getSourceProtoGroup() != null && !evt.getSourceProtoGroup().isPersistent())\r\n        return;\r\n    MetaContactGroup parentGroup = evt.getSourceMetaContactGroup().getParentMetaContactGroup();\r\n    Element parentGroupNode = findMetaContactGroupNode(parentGroup.getMetaUID());\r\n    if (parentGroupNode == null) {\r\n        logger.error(\"Couldn't find parent of a newly added group: \" + parentGroup);\r\n        return;\r\n    }\r\n    Element newGroupElement = createMetaContactGroupNode(evt.getSourceMetaContactGroup());\r\n    Element subgroupsNode = XMLUtils.findChild(parentGroupNode, SUBGROUPS_NODE_NAME);\r\n    subgroupsNode.appendChild(newGroupElement);\r\n    try {\r\n        scheduleContactListStorage();\r\n    } catch (IOException ex) {\r\n        logger.error(\"Writing CL failed after adding contact \" + evt.getSourceMetaContactGroup(), ex);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.globaldisplaydetails.GlobalDisplayDetailsActivator.getResources",
	"Comment": "returns the resourcemanagementservice, through which we willaccess all resources.",
	"Method": "ResourceManagementService getResources(){\r\n    if (resourcesService == null) {\r\n        resourcesService = ServiceUtils.getService(bundleContext, ResourceManagementService.class);\r\n    }\r\n    return resourcesService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.resources.AbstractResourcesService.getI18NString",
	"Comment": "returns an internationalized string corresponding to the given key.",
	"Method": "String getI18NString(String key,String getI18NString,String key,String[] params,String getI18NString,String key,Locale locale,String getI18NString,String key,String[] params,Locale locale){\r\n    String resourceString = doGetI18String(key, locale);\r\n    if (resourceString == null) {\r\n        logger.warn(\"Missing resource for key: \" + key);\r\n        return '!' + key + '!';\r\n    }\r\n    if (params != null) {\r\n        resourceString = MessageFormat.format(resourceString, (Object[]) params);\r\n    }\r\n    return processI18NString(resourceString);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.notificationconfiguration.NotificationConfigurationActivator.getAudioNotifierService",
	"Comment": "returns the audioservice obtained from the bundlecontext.",
	"Method": "AudioNotifierService getAudioNotifierService(){\r\n    if (audioService == null) {\r\n        audioService = ServiceUtils.getService(bundleContext, AudioNotifierService.class);\r\n    }\r\n    return audioService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockChatRoom.removeMemberPresenceListener",
	"Comment": "removes a listener that was being notified of changes in theparticipation of other chat room participants such as users being kicked,join, left.",
	"Method": "void removeMemberPresenceListener(ChatRoomMemberPresenceListener listener){\r\n    memberPresenceListeners.remove(listener);\r\n}"
}, {
	"Path": "io.lettuce.core.dynamic.intercept.InvocationProxyFactory.addInterface",
	"Comment": "add a interface type that should be implemented by the resulting invocation proxy.",
	"Method": "void addInterface(Class<?> ifc){\r\n    LettuceAssert.notNull(ifc, \"Interface type must not be null\");\r\n    LettuceAssert.isTrue(ifc.isInterface(), \"Type must be an interface\");\r\n    this.interfaces.add(ifc);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.replacement.bliptv.ReplacementServiceBliptvImpl.getReplacement",
	"Comment": "replaces the blip.tv video links with their corresponding thumbnails.",
	"Method": "String getReplacement(String sourceString){\r\n    try {\r\n        String url = \"http://api.embed.ly/1/oembed?url=\" + sourceString + \"&key=cff57b37766440a6a8aa45df88097efe\";\r\n        URL sourceURL = new URL(url);\r\n        URLConnection conn = sourceURL.openConnection();\r\n        BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\r\n        String inputLine, holder = \"\";\r\n        while ((inputLine = in.readLine()) != null) holder += inputLine;\r\n        in.close();\r\n        JSONObject wrapper = (JSONObject) JSONValue.parseWithException(holder);\r\n        String thumbUrl = (String) wrapper.get(\"thumbnail_url\");\r\n        if (thumbUrl != null) {\r\n            return thumbUrl;\r\n        }\r\n    } catch (Throwable e) {\r\n        logger.error(\"Error parsing\", e);\r\n    }\r\n    return sourceString;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.AbstractQualityControlWrapper.getRemoteSendMinPreset",
	"Comment": "the minimum preset that the remote party is sending and we are receiving.not used.",
	"Method": "QualityPreset getRemoteSendMinPreset(){\r\n    QualityControl qc = getMediaQualityControl();\r\n    return (qc == null) ? null : qc.getRemoteSendMinPreset();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapContactSourceService.stopped",
	"Comment": "notifies this ldapcontactsourceservice that a specificldapcontactquery has stopped.",
	"Method": "void stopped(LdapContactQuery query){\r\n    synchronized (queries) {\r\n        if (queries.remove(query))\r\n            queries.notify();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommTextField.addTextChangeListener",
	"Comment": "adds the given textfieldchangelistener to the list of listenersnotified on changes of the text contained in this field.",
	"Method": "void addTextChangeListener(TextFieldChangeListener l){\r\n    synchronized (changeListeners) {\r\n        changeListeners.add(l);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallManager.answerCallInFirstExistingCall",
	"Comment": "answers the given call in an existing call. it will end up with aconference call.",
	"Method": "void answerCallInFirstExistingCall(Call call){\r\n    Iterator<Call> existingCallIter = getInProgressCalls().iterator();\r\n    Call existingCall = existingCallIter.hasNext() ? existingCallIter.next() : null;\r\n    answerCall(call, existingCall, false);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.DesktopUtilActivator.getAccountManager",
	"Comment": "returns the accountmanager obtained from the bundle context.",
	"Method": "AccountManager getAccountManager(){\r\n    if (accountManager == null) {\r\n        accountManager = ServiceUtils.getService(bundleContext, AccountManager.class);\r\n    }\r\n    return accountManager;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.DTMFHandler.removeParent",
	"Comment": "removes a window on which key presses and releases are to nolonger be monitored for the purposes of this dtmfhandler.",
	"Method": "void removeParent(Window parent){\r\n    synchronized (parents) {\r\n        if (parents.remove(parent) && parents.isEmpty() && (keyboardFocusManager != null)) {\r\n            keyboardFocusManager.removeKeyEventDispatcher(this);\r\n            keyboardFocusManager = null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.lettuce.core.cluster.topology.TopologyComparators.isChanged",
	"Comment": "check if properties changed which are essential for cluster operations.",
	"Method": "boolean isChanged(Partitions o1,Partitions o2){\r\n    if (o1.size() != o2.size()) {\r\n        return true;\r\n    }\r\n    for (RedisClusterNode base : o2) {\r\n        if (!essentiallyEqualsTo(base, o1.getPartitionByNodeId(base.getNodeId()))) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractOperationSetBasicAutoAnswer.autoAnswer",
	"Comment": "makes a check after creating call locally, should we answer it.",
	"Method": "boolean autoAnswer(Call call,boolean isVideoCall){\r\n    if (answerUnconditional || satisfyAutoAnswerConditions(call)) {\r\n        this.answerCall(call, isVideoCall);\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.sysactivity.SystemActivityNotificationsServiceImpl.notifyNetworkChange",
	"Comment": "callback method when receiving special network notifications.",
	"Method": "void notifyNetworkChange(int family,long luidIndex,String name,long type,boolean connected){\r\n    long current = System.currentTimeMillis();\r\n    if (current - lastNetworkChange <= NETWORK_EVENT_SILENT_TIME && (networkIsConnected != null && networkIsConnected.equals(connected))) {\r\n        networkIsConnected = connected;\r\n        return;\r\n    }\r\n    lastNetworkChange = current;\r\n    networkIsConnected = connected;\r\n    SystemActivityEvent evt = new SystemActivityEvent(this, SystemActivityEvent.EVENT_NETWORK_CHANGE);\r\n    fireSystemActivityEvent(evt);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.refreshWriteArea",
	"Comment": "refreshes write area editor pane. deletes all existing textcontent.",
	"Method": "void refreshWriteArea(){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                refreshWriteArea();\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    this.writeMessagePanel.clearWriteArea();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.refreshWriteArea",
	"Comment": "refreshes write area editor pane. deletes all existing textcontent.",
	"Method": "void refreshWriteArea(){\r\n    refreshWriteArea();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactImpl.getContactsForContactGroup",
	"Comment": "returns contacts, encapsulated by this metacontact and belonging tothe specified protocol contactgroup.in order to prevent problems with concurrency, the iteratorreturned by this method is not be over the actual list of contacts butover a copy of that list.",
	"Method": "Iterator<Contact> getContactsForContactGroup(ContactGroup parentProtoGroup){\r\n    List<Contact> providerContacts = new LinkedList<Contact>();\r\n    for (Contact contact : protoContacts) {\r\n        if (contact.getParentContactGroup() == parentProtoGroup)\r\n            providerContacts.add(contact);\r\n    }\r\n    return providerContacts.iterator();\r\n}"
}, {
	"Path": "io.lettuce.core.ZAddArgs.xx",
	"Comment": "only update elements that already exist. never add elements.",
	"Method": "ZAddArgs xx(ZAddArgs xx){\r\n    this.xx = true;\r\n    return this;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.ImageUtils.getScaledEllipticalIcon",
	"Comment": "returns a scaled elliptical icon from the given image, scaledwithin the given width and height.",
	"Method": "ImageIcon getScaledEllipticalIcon(Image image,int width,int height,ImageIcon getScaledEllipticalIcon,byte[] imageBytes,int width,int height){\r\n    return getScaledIcon(imageBytes, Shape.ELLIPSE, width, height);\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.SRVRecord.toString",
	"Comment": "returns the tostring of the org.xbill.dns.srvrecord that was passed tothe constructor.",
	"Method": "String toString(){\r\n    return record.toString();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.notifsource.NotificationContact.getContactCustomActionButtons",
	"Comment": "returns all custom action buttons for this notification contact.",
	"Method": "Collection<SIPCommButton> getContactCustomActionButtons(){\r\n    if (notificationMessage != null)\r\n        return NotificationContactSource.getContactCustomActionButtons(this);\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ChatConferenceCallsListModels.getElementAt",
	"Comment": "returns conferencedescription instance at the specified index ofthe conferences list.",
	"Method": "ConferenceDescription getElementAt(int index){\r\n    synchronized (chatConferenceCalls) {\r\n        return chatConferenceCalls.get(index);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.slickless.util.xml.TestXMLUtils.setUp",
	"Comment": "create a xml document that will be used as a fixture in later testing.",
	"Method": "void setUp(){\r\n    factory = DocumentBuilderFactory.newInstance();\r\n    DocumentBuilder builder = factory.newDocumentBuilder();\r\n    InputStream in = new java.io.ByteArrayInputStream(xmlString.getBytes());\r\n    document = builder.parse(in);\r\n    rootNode = document.getFirstChild();\r\n    super.setUp();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.UriHandlerSipImpl.registerHandlerService",
	"Comment": "registers this urihandler with the bundle context so that it could starthandling uris",
	"Method": "void registerHandlerService(){\r\n    synchronized (registrationLock) {\r\n        if (ourServiceRegistration != null) {\r\n            return;\r\n        }\r\n        Hashtable<String, String> registrationProperties = new Hashtable<String, String>();\r\n        for (String protocol : getProtocol()) {\r\n            registrationProperties.put(UriHandler.PROTOCOL_PROPERTY, protocol);\r\n        }\r\n        ourServiceRegistration = SipActivator.bundleContext.registerService(UriHandler.class.getName(), this, registrationProperties);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.PasswordChangeDialog.keyReleased",
	"Comment": "when a key is pressed we do 2 things. the first is to compare the twopassword input fields and enable ok button if they are equal. the secondis to measure the password quality of the password from the first inputfield.",
	"Method": "void keyReleased(KeyEvent event){\r\n    JPasswordField source = (JPasswordField) event.getSource();\r\n    if (newPasswordField.equals(source) || newAgainPasswordField.equals(source)) {\r\n        String password1 = new String(newPasswordField.getPassword());\r\n        String password2 = new String(newAgainPasswordField.getPassword());\r\n        passwordQualityBar.setValue(passwordMeter.assessPassword(password1));\r\n        boolean eq = (password1.length() != 0) && password1.equals(password2);\r\n        okButton.setEnabled(eq);\r\n        password1 = null;\r\n        password2 = null;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactImpl.getDefaultContact",
	"Comment": "currently simply returns the most connected protocol contact. we shouldadd the possibility to choose it also according to preconfiguredpreferences.",
	"Method": "Contact getDefaultContact(Contact getDefaultContact,Class<? extends OperationSet> operationSet){\r\n    Contact defaultOpSetContact = null;\r\n    Contact defaultContact = getDefaultContact();\r\n    if (defaultContact != null) {\r\n        ProtocolProviderService contactProvider = defaultContact.getProtocolProvider();\r\n        OperationSetContactCapabilities capOpSet = contactProvider.getOperationSet(OperationSetContactCapabilities.class);\r\n        if (capOpSet != null) {\r\n            List<Contact> capContacts = capabilities.get(operationSet.getName());\r\n            if (capContacts != null && capContacts.contains(defaultContact)) {\r\n                defaultOpSetContact = defaultContact;\r\n            }\r\n        } else if (contactProvider.getOperationSet(operationSet) != null)\r\n            defaultOpSetContact = defaultContact;\r\n    }\r\n    if (defaultOpSetContact == null) {\r\n        PresenceStatus currentStatus = null;\r\n        for (Contact protoContact : protoContacts) {\r\n            ProtocolProviderService contactProvider = protoContact.getProtocolProvider();\r\n            OperationSetContactCapabilities capOpSet = contactProvider.getOperationSet(OperationSetContactCapabilities.class);\r\n            if (capOpSet != null) {\r\n                List<Contact> capContacts = capabilities.get(operationSet.getName());\r\n                if (capContacts == null || !capContacts.contains(protoContact)) {\r\n                    continue;\r\n                }\r\n            } else if (contactProvider.getOperationSet(operationSet) == null)\r\n                continue;\r\n            PresenceStatus contactStatus = protoContact.getPresenceStatus();\r\n            if (currentStatus != null) {\r\n                if (currentStatus.getStatus() < contactStatus.getStatus()) {\r\n                    currentStatus = contactStatus;\r\n                    defaultOpSetContact = protoContact;\r\n                }\r\n            } else {\r\n                currentStatus = contactStatus;\r\n                defaultOpSetContact = protoContact;\r\n            }\r\n        }\r\n    }\r\n    return defaultOpSetContact;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageHistoryActivator.getMessageHistoryService",
	"Comment": "returns the messagehistoryservice registered to the bundlecontext.",
	"Method": "MessageHistoryServiceImpl getMessageHistoryService(){\r\n    return msgHistoryService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ContactListPane.typingNotificationDeliveryFailed",
	"Comment": "called to indicate that sending typing notification has failed.",
	"Method": "void typingNotificationDeliveryFailed(TypingNotificationEvent evt){\r\n    if (typingTimer.isRunning())\r\n        typingTimer.stop();\r\n    String notificationMsg = \"\";\r\n    MetaContact metaContact = GuiActivator.getContactListService().findMetaContactByContact(evt.getSourceContact());\r\n    String contactName = metaContact.getDisplayName();\r\n    if (contactName.equals(\"\")) {\r\n        contactName = GuiActivator.getResources().getI18NString(\"service.gui.UNKNOWN\") + \" \";\r\n    }\r\n    ChatPanel chatPanel = chatWindowManager.getContactChat(metaContact, false);\r\n    notificationMsg = GuiActivator.getResources().getI18NString(\"service.gui.CONTACT_TYPING_SEND_FAILED\", new String[] { contactName });\r\n    if (!chatWindowManager.isChatOpenedFor(metaContact)) {\r\n        return;\r\n    }\r\n    if (chatPanel != null)\r\n        chatPanel.addErrorSendingTypingNotification(notificationMsg);\r\n    typingTimer.setMetaContact(metaContact);\r\n    typingTimer.start();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.sipaccregwizz.FirstWizardPage.getWizardForm",
	"Comment": "implements the wizardpage.getwizardform to return thispanel.",
	"Method": "Object getWizardForm(){\r\n    registrationForm.init();\r\n    return this;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.TestAccountUninstallation.testInstallationPersistency",
	"Comment": "stops and removes the tested bundle, verifies that it has unregisteredits provider, then reloads and restarts the bundle and verifies thatthe protocol provider is reregistered in the bundle context.",
	"Method": "void testInstallationPersistency(){\r\n    Bundle providerBundle = fixture.findProtocolProviderBundle(fixture.provider1);\r\n    JabberSlickFixture.providerBundle = providerBundle;\r\n    assertNotNull(\"Couldn't find a bundle for the tested provider\", providerBundle);\r\n    providerBundle.stop();\r\n    assertTrue(\"Couldn't stop the protocol provider bundle. State was \" + providerBundle.getState(), Bundle.ACTIVE != providerBundle.getState() && Bundle.STOPPING != providerBundle.getState());\r\n    providerBundle.uninstall();\r\n    assertEquals(\"Couldn't stop the protocol provider bundle.\", Bundle.UNINSTALLED, providerBundle.getState());\r\n    ServiceReference[] jabberProviderRefs = null;\r\n    try {\r\n        jabberProviderRefs = JabberSlickFixture.bc.getServiceReferences(ProtocolProviderService.class.getName(), \"(&\" + \"(\" + ProtocolProviderFactory.PROTOCOL + \"=\" + ProtocolNames.JABBER + \")\" + \"(\" + ProtocolProviderFactory.USER_ID + \"=\" + fixture.userID1 + \")\" + \")\");\r\n    } catch (InvalidSyntaxException ex) {\r\n        fail(\"We apparently got our filter wrong: \" + ex.getMessage());\r\n    }\r\n    assertTrue(\"A Protocol Provider Service was still regged as an osgi service \" + \"for Jabber URI:\" + fixture.userID1 + \"After it was explicitly uninstalled\", jabberProviderRefs == null || jabberProviderRefs.length == 0);\r\n    assertTrue(\"The Jabber provider factory kept a reference to the provider we just \" + \"uninstalled (uri=\" + fixture.userID1 + \")\", fixture.providerFactory.getRegisteredAccounts().isEmpty() && fixture.providerFactory.getProviderForAccount(fixture.provider1.getAccountID()) == null);\r\n    providerBundle = JabberSlickFixture.bc.installBundle(providerBundle.getLocation());\r\n    JabberSlickFixture.providerBundle = providerBundle;\r\n    assertEquals(\"Couldn't re-install protocol provider bundle.\", Bundle.INSTALLED, providerBundle.getState());\r\n    AccountManagerUtils.startBundleAndWaitStoredAccountsLoaded(JabberSlickFixture.bc, providerBundle, ProtocolNames.JABBER);\r\n    assertEquals(\"Couldn't re-start protocol provider bundle.\", Bundle.ACTIVE, providerBundle.getState());\r\n    try {\r\n        jabberProviderRefs = JabberSlickFixture.bc.getServiceReferences(ProtocolProviderService.class.getName(), \"(&\" + \"(\" + ProtocolProviderFactory.PROTOCOL + \"=\" + ProtocolNames.JABBER + \")\" + \"(\" + ProtocolProviderFactory.USER_ID + \"=\" + fixture.userID1 + \")\" + \")\");\r\n    } catch (InvalidSyntaxException ex) {\r\n        fail(\"We apparently got our filter wrong \" + ex.getMessage());\r\n    }\r\n    assertTrue(\"A Protocol Provider Service was not restored after being\" + \"reinstalled. Jabber URI:\" + fixture.userID1, jabberProviderRefs != null && jabberProviderRefs.length > 0);\r\n    ServiceReference[] jabberFactoryRefs = null;\r\n    try {\r\n        jabberFactoryRefs = JabberSlickFixture.bc.getServiceReferences(ProtocolProviderFactory.class.getName(), \"(\" + ProtocolProviderFactory.PROTOCOL + \"=\" + ProtocolNames.JABBER + \")\");\r\n    } catch (InvalidSyntaxException ex) {\r\n        fail(\"We apparently got our filter wrong \" + ex.getMessage());\r\n    }\r\n    fixture.providerFactory = (ProtocolProviderFactory) JabberSlickFixture.bc.getService(jabberFactoryRefs[0]);\r\n    fixture.provider1 = (ProtocolProviderService) JabberSlickFixture.bc.getService(jabberProviderRefs[0]);\r\n    assertTrue(\"The Jabber provider did not restore its own reference to the provider \" + \"that we just reinstalled (URI=\" + fixture.userID1 + \")\", !fixture.providerFactory.getRegisteredAccounts().isEmpty() && fixture.providerFactory.getProviderForAccount(fixture.provider1.getAccountID()) != null);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ProtocolIconSipImpl.getConnectingIcon",
	"Comment": "returns the icon image used to represent the protocol connecting state.",
	"Method": "byte[] getConnectingIcon(){\r\n    return loadIcon(iconPath + \"/sip-connecting.gif\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.SingleWindowContainer.setCurrentChat",
	"Comment": "selects the chat tab which corresponds to the given metacontact.",
	"Method": "void setCurrentChat(ChatPanel chatPanel){\r\n    ChatSession chatSession = chatPanel.getChatSession();\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Set current chat panel to: \" + chatSession.getChatName());\r\n    if (tabbedPane.getTabCount() > 0)\r\n        this.tabbedPane.setSelectedComponent(chatPanel);\r\n    this.setTitle(chatSession.getChatName());\r\n    this.contactPhotoPanel.setChatSession(chatSession);\r\n    chatPanel.requestFocusInWriteArea();\r\n    for (ChatChangeListener l : this.chatChangeListeners) {\r\n        l.chatChanged(chatPanel);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.security.CredentialsCacheEntry.containsBranchID",
	"Comment": "determines whether these credentials have been used for the specifiedtransaction.",
	"Method": "boolean containsBranchID(String branchID){\r\n    return transactionHistory.contains(branchID);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.MetaContactChatSession.setCurrentChatTransport",
	"Comment": "sets the transport that will be used for all operations within this chatsession.",
	"Method": "void setCurrentChatTransport(ChatTransport chatTransport){\r\n    this.currentChatTransport = chatTransport;\r\n    fireCurrentChatTransportChange();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.packetlogging.PacketLoggingServiceImpl.rotateFiles",
	"Comment": "rotates any existing files and use the newly created first onefor writing.",
	"Method": "void rotateFiles(){\r\n    if (outputStream != null) {\r\n        outputStream.flush();\r\n        outputStream.close();\r\n    }\r\n    for (int i = getConfiguration().getLogfileCount() - 2; i >= 0; i--) {\r\n        File f1 = files[i];\r\n        File f2 = files[i + 1];\r\n        if (f1.exists()) {\r\n            if (f2.exists())\r\n                f2.delete();\r\n            f1.renameTo(f2);\r\n        }\r\n    }\r\n    outputStream = new FileOutputStream(files[0]);\r\n    written = 0;\r\n    createGlobalHeader();\r\n}"
}, {
	"Path": "net.librec.recommender.cf.UserKNNTestCase.test04SplitterRatioUser",
	"Comment": "test ratiodatasplitter with user ratio, evaluating enabled.",
	"Method": "void test04SplitterRatioUser(){\r\n    Resource resource = new Resource(\"rec/cf/userknn-test.properties\");\r\n    conf.addResource(resource);\r\n    conf.set(\"rec.eval.enable\", \"true\");\r\n    conf.set(\"data.model.splitter\", \"ratio\");\r\n    conf.set(\"data.splitter.ratio\", \"user\");\r\n    RecommenderJob job = new RecommenderJob(conf);\r\n    job.runJob();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.WhiteboardInvitationReceivedEvent.getSourceOperationSet",
	"Comment": "returns the whiteboarding operation set that dispatches this event.",
	"Method": "OperationSetWhiteboarding getSourceOperationSet(){\r\n    return (OperationSetWhiteboarding) getSource();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetServerStoredContactInfoIcqImpl.getAllDetailsForContact",
	"Comment": "request the full info for the given uinwaits and return this details",
	"Method": "Iterator<GenericDetail> getAllDetailsForContact(Contact contact){\r\n    assertConnected();\r\n    List<GenericDetail> res = infoRetreiver.getContactDetails(contact.getAddress());\r\n    if (contact.getImage() != null) {\r\n        res.add(new ServerStoredDetails.ImageDetail(\"Image\", contact.getImage()));\r\n    }\r\n    return res.iterator();\r\n}"
}, {
	"Path": "com.github.ltsopensource.core.commons.concurrent.limiter.Stopwatch.stop",
	"Comment": "stops the stopwatch. future reads will return the fixed duration that hadelapsed up to this point.",
	"Method": "Stopwatch stop(){\r\n    long tick = ticker.read();\r\n    Assert.isTrue(isRunning, \"This stopwatch is already stopped.\");\r\n    isRunning = false;\r\n    elapsedNanos += tick - startTick;\r\n    return this;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractCallPeer.fireCallPeerSecurityOnEvent",
	"Comment": "constructs a callpeersecuritystatusevent using this call peer assource, setting it to be of type eventtype and the correspondingoldvalue and newvalue.",
	"Method": "void fireCallPeerSecurityOnEvent(CallPeerSecurityOnEvent evt){\r\n    lastSecurityEvent = evt;\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Dispatching a CallPeerSecurityStatusEvent event to \" + callPeerSecurityListeners.size() + \" listeners. event is: \" + evt.toString());\r\n    List<CallPeerSecurityListener> listeners = null;\r\n    synchronized (callPeerSecurityListeners) {\r\n        listeners = new ArrayList<CallPeerSecurityListener>(callPeerSecurityListeners);\r\n    }\r\n    for (CallPeerSecurityListener listener : listeners) {\r\n        listener.securityOn(evt);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.generic.TestOperationSetAdHocMultiUserChat.testSendIM",
	"Comment": "send an instant message to the room and check that second user in theroom receives it.",
	"Method": "void testSendIM(){\r\n    assertEquals(\"There are any rooms to retrieve on user 1 side's\", 1, opSetAHMUC1.getAdHocChatRooms().size());\r\n    assertEquals(\"There are any rooms to retrieve on user 2 side's\", 1, opSetAHMUC2.getAdHocChatRooms().size());\r\n    assertEquals(\"There are any rooms to retrieve on user 3 side's\", 1, opSetAHMUC3.getAdHocChatRooms().size());\r\n    AdHocChatRoom roomUser1 = opSetAHMUC1.getAdHocChatRooms().get(0);\r\n    AdHocChatRoom roomUser2 = opSetAHMUC2.getAdHocChatRooms().get(0);\r\n    AdHocChatRoom roomUser3 = opSetAHMUC3.getAdHocChatRooms().get(0);\r\n    assertNotNull(\"The room can NOT been retrieved on user's 1 side.\", roomUser1);\r\n    assertNotNull(\"The room can NOT been retrieved on user's 2 side.\", roomUser2);\r\n    assertNotNull(\"The room can NOT been retrieved on user's 3 side.\", roomUser3);\r\n    AHMUCEventCollector collectorUser1 = new AHMUCEventCollector(roomUser1, AHMUCEventCollector.MESSAGE_EVENT);\r\n    AHMUCEventCollector collectorUser2 = new AHMUCEventCollector(roomUser2, AHMUCEventCollector.MESSAGE_EVENT);\r\n    AHMUCEventCollector collectorUser3 = new AHMUCEventCollector(roomUser3, AHMUCEventCollector.MESSAGE_EVENT);\r\n    Message message = roomUser1.createMessage(\"Quick brown fox jumps over the lazy dog\");\r\n    roomUser1.sendMessage(message);\r\n    try {\r\n        Thread.sleep(10000);\r\n    } catch (InterruptedException e) {\r\n        e.printStackTrace();\r\n    }\r\n    assertEquals(\"User 1 did NOT receive a message delivered event. Wrong\" + \" event collected number\", 1, collectorUser1.events.size());\r\n    assertEquals(\"User 2 did NOT receive a message received event. Wrong \" + \"event collected number\", 1, collectorUser2.events.size());\r\n    assertEquals(\"User 3 did NOT receive a message received event. Wrong \" + \"event collected number\", 1, collectorUser3.events.size());\r\n    AdHocChatRoomMessageDeliveredEvent deliveredMessage = (AdHocChatRoomMessageDeliveredEvent) collectorUser1.events.get(0);\r\n    assertEquals(\"Message delivered to an unexpected room\", roomUser1.getName(), deliveredMessage.getSourceAdHocChatRoom().getName());\r\n    assertEquals(\"Wrong message type\", AdHocChatRoomMessageDeliveredEvent.CONVERSATION_MESSAGE_DELIVERED, deliveredMessage.getEventType());\r\n    assertEquals(\"Message's content does NOT match\", message.getContent(), deliveredMessage.getMessage().getContent());\r\n    AdHocChatRoomMessageReceivedEvent receivedMessage = (AdHocChatRoomMessageReceivedEvent) collectorUser2.events.get(0);\r\n    assertEquals(\"Message does NOT belong to this room\", roomUser2.getName(), receivedMessage.getSourceChatRoom().getName());\r\n    assertEquals(\"Wrong message type\", AdHocChatRoomMessageReceivedEvent.CONVERSATION_MESSAGE_RECEIVED, receivedMessage.getEventType());\r\n    assertEquals(\"Message's content does NOT match\", message.getContent(), receivedMessage.getMessage().getContent());\r\n    receivedMessage = (AdHocChatRoomMessageReceivedEvent) collectorUser3.events.get(0);\r\n    assertEquals(\"Message does NOT belong to this room\", roomUser3.getName(), receivedMessage.getSourceChatRoom().getName());\r\n    assertEquals(\"Wrong message type\", AdHocChatRoomMessageReceivedEvent.CONVERSATION_MESSAGE_RECEIVED, receivedMessage.getEventType());\r\n    assertEquals(\"Message's content does NOT match\", message.getContent(), receivedMessage.getMessage().getContent());\r\n}"
}, {
	"Path": "net.librec.eval.ranking.DiversityEvaluator.evaluate",
	"Comment": "evaluate on the test set with the the list of recommended items.",
	"Method": "double evaluate(RecommendedList groundTruthList,RecommendedList recommendedList){\r\n    double totalDiversity = 0.0;\r\n    int numContext = groundTruthList.size();\r\n    int nonZeroContext = 0;\r\n    if (similarities.containsKey(\"item\")) {\r\n        SymmMatrix itemSimilarity = similarities.get(\"item\").getSimilarityMatrix();\r\n        for (int contextIdx = 0; contextIdx < numContext; ++contextIdx) {\r\n            List<KeyValue<Integer, Double>> recommendArrayListByContext = recommendedList.getKeyValueListByContext(contextIdx);\r\n            if (recommendArrayListByContext.size() > 1) {\r\n                double totalDisSimilarityPerContext = 0.0;\r\n                int topK = this.topN <= recommendArrayListByContext.size() ? this.topN : recommendArrayListByContext.size();\r\n                for (int indexOut = 0; indexOut < topK; ++indexOut) {\r\n                    for (int indexIn = 0; indexIn < topK; ++indexIn) {\r\n                        if (indexOut == indexIn) {\r\n                            continue;\r\n                        }\r\n                        int keyOut = recommendArrayListByContext.get(indexOut).getKey();\r\n                        int keyIn = recommendArrayListByContext.get(indexIn).getKey();\r\n                        totalDisSimilarityPerContext += 1.0 - itemSimilarity.get(keyOut, keyIn);\r\n                    }\r\n                }\r\n                totalDiversity += totalDisSimilarityPerContext / (topK * (topK - 1));\r\n                nonZeroContext++;\r\n            }\r\n        }\r\n    }\r\n    return nonZeroContext > 0 ? totalDiversity / nonZeroContext : 0.0d;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.spellcheck.SpellChecker.chatCreated",
	"Comment": "notifies this instance that a new chat has been created.attaches listeners to the new chat.",
	"Method": "void chatCreated(Chat chat){\r\n    synchronized (attachedChats) {\r\n        if (getChatAttachments(chat) == null && this.dict != null) {\r\n            ChatAttachments wrapper = new ChatAttachments(chat, this.dict);\r\n            if (attachedChats.contains(wrapper))\r\n                return;\r\n            wrapper.setEnabled(enabled);\r\n            wrapper.attachListeners();\r\n            attachedChats.add(wrapper);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.contactlist.TestMetaContact.testGetMetaUID",
	"Comment": "very light test of the existance and the uniqueness of meta uids",
	"Method": "void testGetMetaUID(){\r\n    String metaUID = metaContact.getMetaUID();\r\n    assertNotNull(\"getMetaUID() did not seem to return a valid UID\", metaUID);\r\n    assertTrue(\"getMetaUID() did not seem to return a valid UID\", metaUID.trim().length() > 0);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.OperationSetMultiUserChatIrcImpl.createLocalChatRoomInstance",
	"Comment": "creates a chatroom from the specified chat room name.must be used in synchronized context.",
	"Method": "ChatRoomIrcImpl createLocalChatRoomInstance(String chatRoomName){\r\n    ChatRoomIrcImpl chatRoom = new ChatRoomIrcImpl(chatRoomName, ircProvider);\r\n    this.chatRoomCache.put(chatRoom.getName(), chatRoom);\r\n    return chatRoom;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractOperationSetBasicAutoAnswer.isAutoAnswerUnconditionalSet",
	"Comment": "is the auto answer option set to unconditionallyanswer all incoming calls.",
	"Method": "boolean isAutoAnswerUnconditionalSet(){\r\n    return answerUnconditional;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.TestOperationSetPresence.testQueryContactStatus",
	"Comment": "verifies that querying status works fine. the tester agent wouldchange status and the operation set would have to return the right statusafter every change.",
	"Method": "void testQueryContactStatus(){\r\n    logger.debug(\"Will Query an AWAY contact.\");\r\n    subtestQueryContactStatus(JabberStatusEnum.AWAY, JabberStatusEnum.AWAY);\r\n    logger.debug(\"Will Query a DND contact.\");\r\n    subtestQueryContactStatus(JabberStatusEnum.DO_NOT_DISTURB, JabberStatusEnum.DO_NOT_DISTURB);\r\n    logger.debug(\"Will Query a Free For Chat contact.\");\r\n    subtestQueryContactStatus(JabberStatusEnum.FREE_FOR_CHAT, JabberStatusEnum.FREE_FOR_CHAT);\r\n    logger.debug(\"Will Query an Online contact.\");\r\n    subtestQueryContactStatus(JabberStatusEnum.AVAILABLE, JabberStatusEnum.AVAILABLE);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.UriHandlerSipImpl.serviceChanged",
	"Comment": "the point of implementing a service listener here is so that we wouldonly register our own uri handling service and thus only handle uriswhile the factory is available as an osgi service. we remove ourselveswhen our factory unregisters its service reference.",
	"Method": "void serviceChanged(ServiceEvent event){\r\n    Object sourceService = SipActivator.bundleContext.getService(event.getServiceReference());\r\n    if (sourceService != protoFactory) {\r\n        return;\r\n    }\r\n    switch(event.getType()) {\r\n        case ServiceEvent.REGISTERED:\r\n            registerHandlerService();\r\n            break;\r\n        case ServiceEvent.UNREGISTERING:\r\n            unregisterHandlerService();\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.showMessageInWriteArea",
	"Comment": "shows the message with the specified id in the write area, eitherin order to correct it or to send it again.",
	"Method": "boolean showMessageInWriteArea(String messageUID){\r\n    String messageContents = conversationPanel.getMessageContents(messageUID);\r\n    if (messageContents == null) {\r\n        return false;\r\n    }\r\n    this.refreshWriteArea();\r\n    this.setMessage(messageContents);\r\n    return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.account.AccountStatusUtils.getProtocolProviderLastStatus",
	"Comment": "if the protocol provider supports presence operation set searches thelast status which was selected, otherwise returns null.",
	"Method": "Object getProtocolProviderLastStatus(ProtocolProviderService protocolProvider){\r\n    if (getProtocolPresenceOpSet(protocolProvider) != null)\r\n        return getLastPresenceStatus(protocolProvider);\r\n    else\r\n        return getGlobalStatusService().getLastStatusString(protocolProvider);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.TestOperationSetMultiUserChat2.prepareContactList",
	"Comment": "create the list to be sure that contacts exchanging messagesexists in each other lists",
	"Method": "void prepareContactList(){\r\n    fixture.clearProvidersLists();\r\n    Object o = new Object();\r\n    synchronized (o) {\r\n        o.wait(2000);\r\n    }\r\n    try {\r\n        opSetPresence1.subscribe(fixture.userID2);\r\n    } catch (OperationFailedException ex) {\r\n    }\r\n    try {\r\n        opSetPresence1.subscribe(fixture.userID3);\r\n    } catch (OperationFailedException ex) {\r\n    }\r\n    try {\r\n        opSetPresence2.subscribe(fixture.userID1);\r\n    } catch (OperationFailedException ex1) {\r\n    }\r\n    try {\r\n        opSetPresence2.subscribe(fixture.userID3);\r\n    } catch (OperationFailedException ex1) {\r\n    }\r\n    try {\r\n        opSetPresence3.subscribe(fixture.userID1);\r\n    } catch (OperationFailedException ex1) {\r\n    }\r\n    try {\r\n        opSetPresence3.subscribe(fixture.userID2);\r\n    } catch (OperationFailedException ex1) {\r\n    }\r\n    logger.info(\"will wait till the list prepare is completed\");\r\n    synchronized (o) {\r\n        o.wait(4000);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWritePanel.removeUpdate",
	"Comment": "updates write panel size and adjusts sms properties if the sms menuis visible.",
	"Method": "void removeUpdate(DocumentEvent event){\r\n    if (smsButton.isVisible()) {\r\n        updateSmsCounters(event.getDocument().getLength());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.JabberAccRegWizzActivator.getBrowserLauncher",
	"Comment": "returns the browserlauncherservice obtained from the bundlecontext.",
	"Method": "BrowserLauncherService getBrowserLauncher(){\r\n    if (browserLauncherService == null) {\r\n        ServiceReference serviceReference = bundleContext.getServiceReference(BrowserLauncherService.class.getName());\r\n        browserLauncherService = (BrowserLauncherService) bundleContext.getService(serviceReference);\r\n    }\r\n    return browserLauncherService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipApplicationData.setApplicationData",
	"Comment": "stores a value associated to the a key string in thecontainer. currently sipmessage, transactionand dialog are supported as container.",
	"Method": "void setApplicationData(Object container,String key,Object value){\r\n    if (container == null) {\r\n        logger.warn(\"container is null\");\r\n        return;\r\n    }\r\n    if (key == null) {\r\n        logger.warn(\"key is null\");\r\n        return;\r\n    }\r\n    SipApplicationData appData = getSipApplicationData(container);\r\n    if (appData == null) {\r\n        appData = new SipApplicationData();\r\n        if (container instanceof SIPMessage)\r\n            ((SIPMessage) container).setApplicationData(appData);\r\n        else if (container instanceof Transaction)\r\n            ((Transaction) container).setApplicationData(appData);\r\n        else if (container instanceof Dialog)\r\n            ((Dialog) container).setApplicationData(appData);\r\n        else\r\n            logger.error(\"container should be of type \" + \"SIPMessage, Transaction or Dialog\");\r\n    }\r\n    appData.put(key, value);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl.processBye",
	"Comment": "sets the state of the corresponding call peer to disconnected andsends an ok response.",
	"Method": "void processBye(ServerTransaction byeTran){\r\n    Request byeRequest = byeTran.getRequest();\r\n    Response ok = null;\r\n    try {\r\n        ok = messageFactory.createResponse(Response.OK, byeRequest);\r\n    } catch (ParseException ex) {\r\n        logger.error(\"Error while trying to send a response to a bye\", ex);\r\n    }\r\n    if (ok != null)\r\n        try {\r\n            byeTran.sendResponse(ok);\r\n            if (logger.isDebugEnabled())\r\n                logger.debug(\"sent response \" + ok);\r\n        } catch (Exception ex) {\r\n            logger.error(\"Failed to send an OK response to BYE request,\" + \"exception was:\\n\", ex);\r\n        }\r\n    boolean dialogIsAlive;\r\n    try {\r\n        dialogIsAlive = EventPackageUtils.processByeThenIsDialogAlive(byeTran.getDialog());\r\n    } catch (SipException ex) {\r\n        dialogIsAlive = false;\r\n        logger.error(\"Failed to determine whether the dialog should stay alive.\", ex);\r\n    }\r\n    if (dialogIsAlive) {\r\n        getMediaHandler().close();\r\n    } else {\r\n        ReasonHeader reasonHeader = (ReasonHeader) byeRequest.getHeader(ReasonHeader.NAME);\r\n        if (reasonHeader != null) {\r\n            setState(CallPeerState.DISCONNECTED, reasonHeader.getText(), reasonHeader.getCause());\r\n        } else\r\n            setState(CallPeerState.DISCONNECTED);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.sip.SIPAccountRegistration.setRememberPassword",
	"Comment": "sets the rememberpassword value of this jabber account registration.",
	"Method": "void setRememberPassword(boolean rememberPassword){\r\n    this.rememberPassword = rememberPassword;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaAwareCallPeer.setLastConferenceInfoReceived",
	"Comment": "gets the last conferenceinfodocument sent to us by thiscallpeer.",
	"Method": "void setLastConferenceInfoReceived(ConferenceInfoDocument confInfo){\r\n    lastConferenceInfoReceived = confInfo;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler.getDirectionUserPreference",
	"Comment": "gets the mediadirection value which represents the preference ofthe user with respect to streaming media of the specifiedmediatype.",
	"Method": "MediaDirection getDirectionUserPreference(MediaType mediaType){\r\n    switch(mediaType) {\r\n        case AUDIO:\r\n            return audioDirectionUserPreference;\r\n        case VIDEO:\r\n            return videoDirectionUserPreference;\r\n        default:\r\n            return MediaDirection.INACTIVE;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.RecordButton.getRecorder",
	"Comment": "gets the recorder represented by this recordbuttoncreating it first if it does not exist.",
	"Method": "Recorder getRecorder(){\r\n    if (recorder == null) {\r\n        OperationSetBasicTelephony<?> telephony = call.getProtocolProvider().getOperationSet(OperationSetBasicTelephony.class);\r\n        recorder = telephony.createRecorder(call);\r\n    }\r\n    return recorder;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.OperationSetBasicInstantMessagingGibberishImpl.deliverMessage",
	"Comment": "in case the to the to contact corresponds to another gibberishprotocol provider registered with sip communicator, we deliverthe message to them, in case the to contact represents us, wefire a messagereceivedevent, and if to is simplya contact in our contact list, then we simply echo the message.",
	"Method": "void deliverMessage(Message message,ContactGibberishImpl to){\r\n    String userID = to.getAddress();\r\n    if (userID.equals(this.parentProvider.getAccountID().getUserID())) {\r\n        String sourceUserID = to.getProtocolProvider().getAccountID().getUserID();\r\n        Contact from = opSetPersPresence.findContactByID(sourceUserID);\r\n        if (from == null) {\r\n            from = opSetPersPresence.createVolatileContact(sourceUserID);\r\n        }\r\n        fireMessageReceived(message, from);\r\n    } else {\r\n        ProtocolProviderServiceGibberishImpl gibberishProvider = this.opSetPersPresence.findProviderForGibberishUserID(userID);\r\n        if (gibberishProvider != null) {\r\n            OperationSetBasicInstantMessagingGibberishImpl opSetIM = (OperationSetBasicInstantMessagingGibberishImpl) gibberishProvider.getOperationSet(OperationSetBasicInstantMessaging.class);\r\n            opSetIM.deliverMessage(message, to);\r\n        } else {\r\n            fireMessageReceived(message, to);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetTelephonyConferencingSipImpl.notifyAll",
	"Comment": "notifies all subscriptions associated with and established in aspecific call about a specific subscription state and the reasonfor that subscription state.",
	"Method": "void notifyAll(String subscriptionState,String reason,Call call){\r\n    EventPackageNotifier.SubscriptionFilter subscriptionFilter = new EventPackageNotifier.SubscriptionFilter() {\r\n        public boolean accept(EventPackageNotifier.Subscription subscription) {\r\n            return (subscription instanceof ConferenceNotifierSubscription) && call.equals(((ConferenceNotifierSubscription) subscription).getCall());\r\n        }\r\n    };\r\n    try {\r\n        notifier.notifyAll(subscriptionState, reason, subscriptionFilter);\r\n    } catch (OperationFailedException ofe) {\r\n        logger.error(\"Failed to notify the conference subscriptions of \" + call, ofe);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetTelephonyConferencingSipImpl.notifyAll",
	"Comment": "notifies all subscriptions associated with and established in aspecific call about a specific subscription state and the reasonfor that subscription state.",
	"Method": "void notifyAll(String subscriptionState,String reason,Call call){\r\n    return (subscription instanceof ConferenceNotifierSubscription) && call.equals(((ConferenceNotifierSubscription) subscription).getCall());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.UIServiceImpl.closeChatRoomWindow",
	"Comment": "closes the chat room window for the given chatroomwrapper instance.",
	"Method": "void closeChatRoomWindow(ChatRoomWrapper chatRoom){\r\n    ChatWindowManager chatWindowManager = getChatWindowManager();\r\n    ChatPanel chatPanel = chatWindowManager.getMultiChat(chatRoom, false);\r\n    if (chatPanel != null)\r\n        chatWindowManager.closeChat(chatPanel);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractCallPeer.isConferenceFocus",
	"Comment": "determines whether this call peer is currently a conference focus.",
	"Method": "boolean isConferenceFocus(){\r\n    return conferenceFocus;\r\n}"
}, {
	"Path": "com.keybox.manage.db.ProfileDB.getProfileSet",
	"Comment": "method to do order by based on the sorted set object for profiles",
	"Method": "SortedSet getProfileSet(SortedSet sortedSet){\r\n    ArrayList<Profile> profileList = new ArrayList();\r\n    String orderBy = \"\";\r\n    if (sortedSet.getOrderByField() != null && !sortedSet.getOrderByField().trim().equals(\"\")) {\r\n        orderBy = \" order by \" + sortedSet.getOrderByField() + \" \" + sortedSet.getOrderByDirection();\r\n    }\r\n    String sql = \"select distinct p.* from  profiles p \";\r\n    if (StringUtils.isNotEmpty(sortedSet.getFilterMap().get(FILTER_BY_SYSTEM))) {\r\n        sql = sql + \", system_map m, system s where m.profile_id = p.id and m.system_id = s.id\" + \" and (lower(s.display_nm) like ? or lower(s.host) like ?)\";\r\n    } else if (StringUtils.isNotEmpty(sortedSet.getFilterMap().get(FILTER_BY_USER))) {\r\n        sql = sql + \", user_map m, users u where m.profile_id = p.id and m.user_id = u.id\" + \" and (lower(u.first_nm) like ? or lower(u.last_nm) like ?\" + \" or lower(u.email) like ? or lower(u.username) like ?)\";\r\n    }\r\n    sql = sql + orderBy;\r\n    Connection con = null;\r\n    try {\r\n        con = DBUtils.getConn();\r\n        PreparedStatement stmt = con.prepareStatement(sql);\r\n        if (StringUtils.isNotEmpty(sortedSet.getFilterMap().get(FILTER_BY_SYSTEM))) {\r\n            stmt.setString(1, \"%\" + sortedSet.getFilterMap().get(FILTER_BY_SYSTEM).toLowerCase() + \"%\");\r\n            stmt.setString(2, \"%\" + sortedSet.getFilterMap().get(FILTER_BY_SYSTEM).toLowerCase() + \"%\");\r\n        } else if (StringUtils.isNotEmpty(sortedSet.getFilterMap().get(FILTER_BY_USER))) {\r\n            stmt.setString(1, \"%\" + sortedSet.getFilterMap().get(FILTER_BY_USER).toLowerCase() + \"%\");\r\n            stmt.setString(2, \"%\" + sortedSet.getFilterMap().get(FILTER_BY_USER).toLowerCase() + \"%\");\r\n            stmt.setString(3, \"%\" + sortedSet.getFilterMap().get(FILTER_BY_USER).toLowerCase() + \"%\");\r\n            stmt.setString(4, \"%\" + sortedSet.getFilterMap().get(FILTER_BY_USER).toLowerCase() + \"%\");\r\n        }\r\n        ResultSet rs = stmt.executeQuery();\r\n        while (rs.next()) {\r\n            Profile profile = new Profile();\r\n            profile.setId(rs.getLong(\"id\"));\r\n            profile.setNm(rs.getString(\"nm\"));\r\n            profile.setDesc(rs.getString(\"desc\"));\r\n            profileList.add(profile);\r\n        }\r\n        DBUtils.closeRs(rs);\r\n        DBUtils.closeStmt(stmt);\r\n    } catch (Exception e) {\r\n        log.error(e.toString(), e);\r\n    } finally {\r\n        DBUtils.closeConn(con);\r\n    }\r\n    sortedSet.setItemList(profileList);\r\n    return sortedSet;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.FTPUtils.login",
	"Comment": "executes the login sequence of ftp commands based on rfc 959.",
	"Method": "void login(){\r\n    sendLine(\"USER \" + user);\r\n    String code = getResponseCode();\r\n    if (code.equals(\"331\") || code.equals(\"332\")) {\r\n        sendLine(\"PASS \" + pass);\r\n        code = getResponseCode();\r\n        if (!code.equals(\"230\")) {\r\n            throw new Exception(\"Login error.\");\r\n        }\r\n    } else if (!code.equals(\"230\")) {\r\n        throw new Exception(\"Login error.\");\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.ConfigFormUtils.getConfigForm",
	"Comment": "returns the first available configuration form with the providedclass name.",
	"Method": "ConfigurationForm getConfigForm(String formType,String className){\r\n    BundleContext bundleContext = DesktopUtilActivator.bundleContext;\r\n    String osgiFilter = \"(\" + ConfigurationForm.FORM_TYPE + \"=\" + formType + \")\";\r\n    ServiceReference[] confFormsRefs = null;\r\n    try {\r\n        confFormsRefs = bundleContext.getServiceReferences(ConfigurationForm.class.getName(), osgiFilter);\r\n    } catch (InvalidSyntaxException ex) {\r\n    }\r\n    if (confFormsRefs != null) {\r\n        for (int i = 0; i < confFormsRefs.length; i++) {\r\n            ConfigurationForm form = (ConfigurationForm) bundleContext.getService(confFormsRefs[i]);\r\n            if (form instanceof LazyConfigurationForm) {\r\n                LazyConfigurationForm lazyConfigForm = (LazyConfigurationForm) form;\r\n                if (lazyConfigForm.getFormClassName().equals(className)) {\r\n                    return form;\r\n                }\r\n            } else if (form.getClass().getName().equals(className)) {\r\n                return form;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.contactlist.TestMetaContact.testGetDisplayName",
	"Comment": "checks whether the display name matches the one in th mock contact.",
	"Method": "void testGetDisplayName(){\r\n    assertEquals(\"getDisplayName()\", mockContact.getDisplayName(), metaContact.getDisplayName());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chatroomslist.joinforms.JoinChatRoomWizardPage2.getBackPageIdentifier",
	"Comment": "implements the wizardpaneldescriptor method to return theidentifier of the previous wizard page.",
	"Method": "Object getBackPageIdentifier(){\r\n    return JoinChatRoomWizardPage1.IDENTIFIER;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.gui.AccountRegistrationWizard.isModification",
	"Comment": "indicates if this wizard is modifying an existing account or is creatinga new one.",
	"Method": "boolean isModification(){\r\n    return isModification;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl.processFirstOffer",
	"Comment": "parses and handles the specified sessiondescription offer andreturns and sdp answer representing the current state of this mediahandler. this method must only be called when offer is thefirst session description that this mediahandler is seeing.",
	"Method": "SessionDescription processFirstOffer(SessionDescription offer){\r\n    Vector<MediaDescription> answerDescriptions = createMediaDescriptionsForAnswer(offer);\r\n    SessionDescription answer = SdpUtils.createSessionDescription(getTransportManager().getLastUsedLocalHost(), getUserName(), answerDescriptions);\r\n    this.localSess = answer;\r\n    return localSess;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.WhiteboardSessionJabberImpl.deleteWhiteboardObject",
	"Comment": "sends a whiteboardobject to deleteand delete the local whiteboardobject",
	"Method": "void deleteWhiteboardObject(WhiteboardObject obj){\r\n    Iterator<WhiteboardParticipant> participants = getWhiteboardParticipants();\r\n    if (!participants.hasNext())\r\n        return;\r\n    WhiteboardParticipantJabberImpl participant = (WhiteboardParticipantJabberImpl) participants.next();\r\n    Contact contact = participant.getContact();\r\n    try {\r\n        assertConnected();\r\n        org.jivesoftware.smack.packet.Message msg = new org.jivesoftware.smack.packet.Message();\r\n        WhiteboardObjectPacketExtension messageJI = new WhiteboardObjectPacketExtension(obj.getID(), WhiteboardObjectPacketExtension.ACTION_DELETE);\r\n        msg.addExtension(messageJI);\r\n        MessageEventManager.addNotificationsRequests(msg, true, false, false, true);\r\n        smackChat.sendMessage(msg);\r\n        WhiteboardObjectDeliveredEvent msgDeliveredEvt = new WhiteboardObjectDeliveredEvent(this, obj, contact, new Date());\r\n        fireMessageEvent(msgDeliveredEvt);\r\n        int i = 0;\r\n        while (i < whiteboardObjects.size()) {\r\n            WhiteboardObjectJabberImpl wbObj = (WhiteboardObjectJabberImpl) whiteboardObjects.get(i);\r\n            if (wbObj.getID().equals(obj.getID()))\r\n                whiteboardObjects.remove(i);\r\n            else\r\n                i++;\r\n        }\r\n    } catch (XMPPException ex) {\r\n        ex.printStackTrace();\r\n        logger.error(\"message not send\", ex);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl.processDialogTerminated",
	"Comment": "process an asynchronously reported dialogterminatedevent.",
	"Method": "boolean processDialogTerminated(DialogTerminatedEvent dialogTerminatedEvent){\r\n    CallPeerSipImpl callPeer = activeCallsRepository.findCallPeer(dialogTerminatedEvent.getDialog());\r\n    if (callPeer == null) {\r\n        return false;\r\n    }\r\n    callPeer.setState(CallPeerState.DISCONNECTED);\r\n    return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.menus.ViewMenu.pluginComponentAdded",
	"Comment": "adds the plugin component contained in the event to this container.",
	"Method": "void pluginComponentAdded(PluginComponentEvent event){\r\n    PluginComponentFactory c = event.getPluginComponentFactory();\r\n    if (c.getContainer().equals(Container.CONTAINER_VIEW_MENU)) {\r\n        this.add((Component) c.getPluginComponentInstance(ViewMenu.this).getComponent());\r\n        this.revalidate();\r\n        this.repaint();\r\n    }\r\n}"
}, {
	"Path": "io.lettuce.core.protocol.AsyncCommand.await",
	"Comment": "wait up to the specified time for the command output to become available.",
	"Method": "boolean await(long timeout,TimeUnit unit){\r\n    try {\r\n        get(timeout, unit);\r\n        return true;\r\n    } catch (InterruptedException e) {\r\n        Thread.currentThread().interrupt();\r\n        throw new RedisCommandInterruptedException(e);\r\n    } catch (ExecutionException e) {\r\n        return true;\r\n    } catch (TimeoutException e) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "net.librec.data.splitter.LOOCVDataSplitter.getLOOByItems",
	"Comment": "split ratings into two parts where one rating per item is preserved asthe test set and the remaining data as the training set.",
	"Method": "void getLOOByItems(){\r\n    trainMatrix = new SequentialAccessSparseMatrix(preferenceMatrix);\r\n    Table<Integer, Integer, Double> dataTable = HashBasedTable.create();\r\n    for (int columnIndex = 0, columnSize = preferenceMatrix.columnSize(); columnIndex < columnSize; columnIndex++) {\r\n        int numRowEntries = preferenceMatrix.column(columnIndex).getNumEntries();\r\n        if (numRowEntries == 0) {\r\n            continue;\r\n        }\r\n        int randomRowPosition = (int) (numRowEntries * Randoms.uniform());\r\n        trainMatrix.setAtRowPosition(randomRowPosition, columnIndex, 0.0D);\r\n        dataTable.put(preferenceMatrix.column(columnIndex).getIndexAtPosition(randomRowPosition), columnIndex, preferenceMatrix.getAtRowPosition(randomRowPosition, columnIndex));\r\n    }\r\n    trainMatrix.reshape();\r\n    testMatrix = new SequentialAccessSparseMatrix(preferenceMatrix.rowSize(), preferenceMatrix.columnSize(), dataTable);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetDesktopSharingServerSipImpl.enableRemoteControl",
	"Comment": "enable desktop remote control. local desktop can now regenerates keyboardand mouse events received from peer.",
	"Method": "void enableRemoteControl(CallPeer callPeer){\r\n    RemoteControlSubscriberSubscription subscription = new RemoteControlSubscriberSubscription((CallPeerSipImpl) callPeer);\r\n    try {\r\n        subscriber.subscribe(subscription);\r\n    } catch (OperationFailedException ofe) {\r\n        logger.error(\"Failed to create or send a remote-control subscription\", ofe);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.notificationconfiguration.NotificationEntry.setSoundPlayback",
	"Comment": "method which set a boolean to true a sound is playing for theplayback.",
	"Method": "void setSoundPlayback(boolean sound){\r\n    this.soundPlayback = sound;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.ConfigurationUtils.getFactoryImplPackageName",
	"Comment": "returns the package name under which we would store information for thegiven factory.",
	"Method": "String getFactoryImplPackageName(ProtocolProviderFactory factory){\r\n    String className = factory.getClass().getName();\r\n    return className.substring(0, className.lastIndexOf('.'));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chatroomslist.joinforms.JoinChatRoomWizardPage2.pageHiding",
	"Comment": "before finishing the wizard sets the identifier entered by the userto the newchatroom object.",
	"Method": "void pageHiding(){\r\n    joinChatRoom.setChatRoomName(searchChatRoomPanel.getChatRoomName());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl.getLocalViaHeaders",
	"Comment": "initializes and returns an arraylist with a single viaheadercontaining a localhost address usable with the specifiedsdestination. this arraylist may be used when sendingrequests to that destination.",
	"Method": "ArrayList<ViaHeader> getLocalViaHeaders(Address intendedDestination,ArrayList<ViaHeader> getLocalViaHeaders,SipURI intendedDestination){\r\n    ArrayList<ViaHeader> viaHeaders = new ArrayList<ViaHeader>();\r\n    ListeningPoint srcListeningPoint = getListeningPoint(intendedDestination.getTransportParam());\r\n    try {\r\n        InetSocketAddress targetAddress = getIntendedDestination(intendedDestination);\r\n        InetAddress localAddress = SipActivator.getNetworkAddressManagerService().getLocalHost(targetAddress.getAddress());\r\n        int localPort = srcListeningPoint.getPort();\r\n        String transport = srcListeningPoint.getTransport();\r\n        if (ListeningPoint.TCP.equalsIgnoreCase(transport) || ListeningPoint.TLS.equalsIgnoreCase(transport)) {\r\n            InetSocketAddress localSockAddr = sipStackSharing.getLocalAddressForDestination(targetAddress.getAddress(), targetAddress.getPort(), localAddress, transport);\r\n            localPort = localSockAddr.getPort();\r\n        }\r\n        ViaHeader viaHeader = headerFactory.createViaHeader(localAddress.getHostAddress(), localPort, transport, null);\r\n        viaHeaders.add(viaHeader);\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"generated via headers:\" + viaHeader);\r\n        return viaHeaders;\r\n    } catch (ParseException ex) {\r\n        logger.error(\"A ParseException occurred while creating Via Headers!\", ex);\r\n        throw new OperationFailedException(\"A ParseException occurred while creating Via Headers!\", OperationFailedException.INTERNAL_ERROR, ex);\r\n    } catch (InvalidArgumentException ex) {\r\n        logger.error(\"Unable to create a via header for port \" + sipStackSharing.getLP(ListeningPoint.UDP).getPort(), ex);\r\n        throw new OperationFailedException(\"Unable to create a via header for port \" + sipStackSharing.getLP(ListeningPoint.UDP).getPort(), OperationFailedException.INTERNAL_ERROR, ex);\r\n    } catch (java.io.IOException ex) {\r\n        logger.error(\"Unable to create a via header for port \" + sipStackSharing.getLP(ListeningPoint.UDP).getPort(), ex);\r\n        throw new OperationFailedException(\"Unable to create a via header for port \" + sipStackSharing.getLP(ListeningPoint.UDP).getPort(), OperationFailedException.NETWORK_FAILURE, ex);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.WhiteboardParticipantJabberImpl.getParticipantID",
	"Comment": "returns a unique identifier representing this participant.",
	"Method": "String getParticipantID(){\r\n    return participantID;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.net.SslNetworkLayer.createSocket",
	"Comment": "creates a stream socket and connects it to the specified port number atthe specified ip address.",
	"Method": "Socket createSocket(InetAddress address,int port,Socket createSocket,InetAddress address,int port,InetAddress myAddress,Socket createSocket,InetAddress address,int port,InetAddress myAddress,int myPort){\r\n    Socket sock = null;\r\n    if (myAddress != null) {\r\n        sock = new Socket(address, port, myAddress, myPort);\r\n    } else if (port != 0) {\r\n        sock = new Socket();\r\n        sock.bind(new InetSocketAddress(port));\r\n        sock.connect(new InetSocketAddress(address, port));\r\n    } else {\r\n        sock = new Socket(address, port);\r\n    }\r\n    setTrafficClass(sock);\r\n    return sock;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.ChatRoomQuery.indexOf",
	"Comment": "returns the index of the contact in the contact results list.",
	"Method": "int indexOf(ChatRoomSourceContact contact){\r\n    Iterator<ChatRoomSourceContact> it = contactResults.iterator();\r\n    int i = 0;\r\n    while (it.hasNext()) {\r\n        if (contact.equals(it.next())) {\r\n            return i;\r\n        }\r\n        i++;\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "com.keybox.manage.db.SystemDB.getSystemSet",
	"Comment": "method to do order by based on the sorted set object for systems",
	"Method": "SortedSet getSystemSet(SortedSet sortedSet,Long profileId,SortedSet getSystemSet,SortedSet sortedSet){\r\n    List<HostSystem> hostSystemList = new ArrayList();\r\n    String orderBy = \"\";\r\n    if (sortedSet.getOrderByField() != null && !sortedSet.getOrderByField().trim().equals(\"\")) {\r\n        orderBy = \"order by \" + sortedSet.getOrderByField() + \" \" + sortedSet.getOrderByDirection();\r\n    }\r\n    String sql = \"select * from  system s \";\r\n    sql += StringUtils.isNotEmpty(sortedSet.getFilterMap().get(FILTER_BY_PROFILE_ID)) ? \",system_map m where s.id=m.system_id and m.profile_id=? \" : \"\";\r\n    sql += orderBy;\r\n    Connection con = null;\r\n    try {\r\n        con = DBUtils.getConn();\r\n        PreparedStatement stmt = con.prepareStatement(sql);\r\n        if (StringUtils.isNotEmpty(sortedSet.getFilterMap().get(FILTER_BY_PROFILE_ID))) {\r\n            stmt.setLong(1, Long.parseLong(sortedSet.getFilterMap().get(FILTER_BY_PROFILE_ID)));\r\n        }\r\n        ResultSet rs = stmt.executeQuery();\r\n        while (rs.next()) {\r\n            HostSystem hostSystem = new HostSystem();\r\n            hostSystem.setId(rs.getLong(\"id\"));\r\n            hostSystem.setDisplayNm(rs.getString(DISPLAY_NM));\r\n            hostSystem.setUser(rs.getString(\"user\"));\r\n            hostSystem.setHost(rs.getString(\"host\"));\r\n            hostSystem.setPort(rs.getInt(\"port\"));\r\n            hostSystem.setAuthorizedKeys(rs.getString(AUTHORIZED_KEYS));\r\n            hostSystem.setStatusCd(rs.getString(STATUS_CD));\r\n            hostSystemList.add(hostSystem);\r\n        }\r\n        DBUtils.closeRs(rs);\r\n        DBUtils.closeStmt(stmt);\r\n    } catch (Exception e) {\r\n        log.error(e.toString(), e);\r\n    } finally {\r\n        DBUtils.closeConn(con);\r\n    }\r\n    sortedSet.setItemList(hostSystemList);\r\n    return sortedSet;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetBasicTelephonyJabberImpl.createCall",
	"Comment": "creates a new call and invites a specific callpeer toit given by her string uri.",
	"Method": "Call createCall(String callee,CallConference conference,CallJabberImpl createCall,ConferenceDescription cd,ChatRoom chatRoom){\r\n    final CallJabberImpl call = new CallJabberImpl(this);\r\n    ((ChatRoomJabberImpl) chatRoom).addConferenceCall(call);\r\n    call.addCallChangeListener(new CallChangeListener() {\r\n        @Override\r\n        public void callPeerAdded(CallPeerEvent ev) {\r\n        }\r\n        @Override\r\n        public void callPeerRemoved(CallPeerEvent ev) {\r\n        }\r\n        @Override\r\n        public void callStateChanged(CallChangeEvent ev) {\r\n            if (CallState.CALL_ENDED.equals(ev.getNewValue())) {\r\n                ((ChatRoomJabberImpl) chatRoom).removeConferenceCall(call);\r\n            }\r\n        }\r\n    });\r\n    String remoteJid = cd.getUri();\r\n    if (remoteJid.startsWith(\"xmpp:\"))\r\n        remoteJid = remoteJid.substring(5, remoteJid.length());\r\n    List<PacketExtension> sessionInitiateExtensions = new ArrayList<PacketExtension>(2);\r\n    String callid = cd.getCallId();\r\n    if (callid != null) {\r\n        sessionInitiateExtensions.add(new CallIdPacketExtension(callid));\r\n    }\r\n    call.initiateSession(remoteJid, null, sessionInitiateExtensions, cd.getSupportedTransports());\r\n    return call;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetBasicTelephonyJabberImpl.createCall",
	"Comment": "creates a new call and invites a specific callpeer toit given by her string uri.",
	"Method": "Call createCall(String callee,CallConference conference,CallJabberImpl createCall,ConferenceDescription cd,ChatRoom chatRoom){\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetBasicTelephonyJabberImpl.createCall",
	"Comment": "creates a new call and invites a specific callpeer toit given by her string uri.",
	"Method": "Call createCall(String callee,CallConference conference,CallJabberImpl createCall,ConferenceDescription cd,ChatRoom chatRoom){\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetBasicTelephonyJabberImpl.createCall",
	"Comment": "creates a new call and invites a specific callpeer toit given by her string uri.",
	"Method": "Call createCall(String callee,CallConference conference,CallJabberImpl createCall,ConferenceDescription cd,ChatRoom chatRoom){\r\n    if (CallState.CALL_ENDED.equals(ev.getNewValue())) {\r\n        ((ChatRoomJabberImpl) chatRoom).removeConferenceCall(call);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetPersistentPresenceJabberImpl.addServerStoredGroupChangeListener",
	"Comment": "registers a listener that would receive events upon changes in serverstored groups.",
	"Method": "void addServerStoredGroupChangeListener(ServerStoredGroupListener listener){\r\n    ssContactList.addGroupListener(listener);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetPersistentPresenceJabberImpl.initializePriorities",
	"Comment": "initializes the map with priorities and statuses which we will use whenchanging statuses.",
	"Method": "void initializePriorities(){\r\n    try {\r\n        this.resourcePriorityAvailable = Integer.parseInt(parentProvider.getAccountID().getAccountPropertyString(ProtocolProviderFactory.RESOURCE_PRIORITY));\r\n    } catch (NumberFormatException ex) {\r\n        logger.error(\"Wrong value for resource priority\", ex);\r\n    }\r\n    addDefaultValue(JabberStatusEnum.AWAY, -5);\r\n    addDefaultValue(JabberStatusEnum.EXTENDED_AWAY, -10);\r\n    addDefaultValue(JabberStatusEnum.ON_THE_PHONE, -15);\r\n    addDefaultValue(JabberStatusEnum.IN_A_MEETING, -16);\r\n    addDefaultValue(JabberStatusEnum.DO_NOT_DISTURB, -20);\r\n    addDefaultValue(JabberStatusEnum.FREE_FOR_CHAT, +5);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.propertieseditor.PropertiesEditorActivator.getResourceManagementService",
	"Comment": "returns the resourcemanagementservice obtained from thebundlecontext.",
	"Method": "ResourceManagementService getResourceManagementService(){\r\n    if (resourceManagementService == null) {\r\n        resourceManagementService = ServiceUtils.getService(bundleContext, ResourceManagementService.class);\r\n    }\r\n    return resourceManagementService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.aimaccregwizz.AimAccountRegistration.setRememberPassword",
	"Comment": "sets the rememberpassword value of this aim account registration.",
	"Method": "void setRememberPassword(boolean rememberPassword){\r\n    this.rememberPassword = rememberPassword;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatSession.setCurrentChatTransport",
	"Comment": "sets the transport that will be used for all operations within this chatsession.",
	"Method": "void setCurrentChatTransport(ChatTransport chatTransport){\r\n    this.currentChatTransport = chatTransport;\r\n    fireCurrentChatTransportChange();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.GuiActivator.getAccountManager",
	"Comment": "returns the accountmanager obtained from the bundle context.",
	"Method": "AccountManager getAccountManager(){\r\n    if (accountManager == null) {\r\n        accountManager = ServiceUtils.getService(bundleContext, AccountManager.class);\r\n    }\r\n    return accountManager;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactImpl.getAvatar",
	"Comment": "returns an avatar that can be used when presenting thismetacontact in user interface. the method would also make surethat we try the network for new versions of avatars.",
	"Method": "byte[] getAvatar(boolean isLazy,byte[] getAvatar){\r\n    return getAvatar(false);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.toolBars.HistorySelectorBox.actionPerformed",
	"Comment": "writes the symbol corresponding to a chosen smiley icon to the writemessage area at the end of the current text.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    String menuItemName = ((JMenuItem) e.getSource()).getName();\r\n    ChatPanel chatPanel = chatContainer.getCurrentChat();\r\n    if (menuItemName.equals(\"history\")) {\r\n        HistoryWindow history;\r\n        HistoryWindowManager historyWindowManager = GuiActivator.getUIService().getHistoryWindowManager();\r\n        ChatSession chatSession = chatPanel.getChatSession();\r\n        if (historyWindowManager.containsHistoryWindowForContact(chatSession.getDescriptor())) {\r\n            history = historyWindowManager.getHistoryWindowForContact(chatSession.getDescriptor());\r\n            if (history.getState() == JFrame.ICONIFIED)\r\n                history.setState(JFrame.NORMAL);\r\n            history.toFront();\r\n        } else {\r\n            history = new HistoryWindow(chatPanel.getChatSession().getDescriptor());\r\n            history.setVisible(true);\r\n            historyWindowManager.addHistoryWindowForContact(chatSession.getDescriptor(), history);\r\n        }\r\n    } else if (menuItemName.equals(\"toggleAllHistory\")) {\r\n        boolean isHistoryEnabled = GuiActivator.getMessageHistoryService().isHistoryLoggingEnabled();\r\n        GuiActivator.getMessageHistoryService().setHistoryLoggingEnabled(!isHistoryEnabled);\r\n    } else if (menuItemName.equals(\"toggleHistoryPerContact\")) {\r\n        Object desc = chatPanel.getChatSession().getDescriptor();\r\n        if (desc instanceof MetaContact) {\r\n            MetaContact currentContact = (MetaContact) desc;\r\n            boolean isHistoryEnabled = GuiActivator.getMessageHistoryService().isHistoryLoggingEnabled(currentContact.getMetaUID());\r\n            GuiActivator.getMessageHistoryService().setHistoryLoggingEnabled(!isHistoryEnabled, currentContact.getMetaUID());\r\n        } else if (desc instanceof ChatRoomWrapper) {\r\n            ChatRoom currentChatRoom = ((ChatRoomWrapper) desc).getChatRoom();\r\n            boolean isHistoryEnabled = GuiActivator.getMessageHistoryService().isHistoryLoggingEnabled(currentChatRoom.getIdentifier());\r\n            GuiActivator.getMessageHistoryService().setHistoryLoggingEnabled(!isHistoryEnabled, currentChatRoom.getIdentifier());\r\n        }\r\n    } else if (menuItemName.equals(\"eraseHistoryPerContact\")) {\r\n        Object desc = chatPanel.getChatSession().getDescriptor();\r\n        String destination;\r\n        if (desc instanceof MetaContact)\r\n            destination = ((MetaContact) desc).getDisplayName();\r\n        else if (desc instanceof ChatRoomWrapper)\r\n            destination = ((ChatRoomWrapper) desc).getChatRoomName();\r\n        else\r\n            return;\r\n        MessageDialog dialog = new MessageDialog(null, GuiActivator.getResources().getI18NString(\"service.gui.WARNING\"), GuiActivator.getResources().getI18NString(\"service.gui.HISTORY_REMOVE_PER_CONTACT_WARNING\", new String[] { destination }), GuiActivator.getResources().getI18NString(\"service.gui.OK\"), false);\r\n        if (dialog.showDialog() == MessageDialog.OK_RETURN_CODE) {\r\n            try {\r\n                if (desc instanceof MetaContact) {\r\n                    ServiceUtils.getService(GuiActivator.bundleContext, MessageHistoryService.class).eraseLocallyStoredHistory((MetaContact) desc);\r\n                    ServiceUtils.getService(GuiActivator.bundleContext, FileHistoryService.class).eraseLocallyStoredHistory((MetaContact) desc);\r\n                } else if (desc instanceof ChatRoomWrapper) {\r\n                    ServiceUtils.getService(GuiActivator.bundleContext, MessageHistoryService.class).eraseLocallyStoredHistory(((ChatRoomWrapper) desc).getChatRoom());\r\n                }\r\n            } catch (IOException ex) {\r\n                logger.error(\"Error removing history\", ex);\r\n                chatPanel.addErrorMessage(destination, GuiActivator.getResources().getI18NString(\"service.gui.HISTORY_REMOVE_ERROR\"), ex.getLocalizedMessage());\r\n            }\r\n        }\r\n    } else if (menuItemName.equals(\"eraseAllHistory\")) {\r\n        MessageDialog dialog = new MessageDialog(null, GuiActivator.getResources().getI18NString(\"service.gui.WARNING\"), GuiActivator.getResources().getI18NString(\"service.gui.HISTORY_REMOVE_ALL_WARNING\"), GuiActivator.getResources().getI18NString(\"service.gui.OK\"), false);\r\n        if (dialog.showDialog() == MessageDialog.OK_RETURN_CODE) {\r\n            try {\r\n                ServiceUtils.getService(GuiActivator.bundleContext, MessageHistoryService.class).eraseLocallyStoredHistory();\r\n                ServiceUtils.getService(GuiActivator.bundleContext, FileHistoryService.class).eraseLocallyStoredHistory();\r\n            } catch (IOException ex) {\r\n                logger.error(\"Error removing history\", ex);\r\n                chatPanel.addErrorMessage(\"all\", GuiActivator.getResources().getI18NString(\"service.gui.HISTORY_REMOVE_ERROR\"), ex.getLocalizedMessage());\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactGroupImpl.getMetaContact",
	"Comment": "returns the meta contact encapsulating a contact belonging to thespecified provider with the specified identifier.",
	"Method": "MetaContact getMetaContact(String metaContactID,MetaContact getMetaContact,ProtocolProviderService provider,String contactID,MetaContact getMetaContact,int index){\r\n    return this.childContactsOrderedCopy.get(index);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.ImageUtils.scaleImageWithinBounds",
	"Comment": "returns a scaled image fitting within the given bounds while keeping theaspect ratio.",
	"Method": "Image scaleImageWithinBounds(Image image,int width,int height,ImageIcon scaleImageWithinBounds,byte[] imageBytes,int width,int height){\r\n    if (imageBytes == null || !(imageBytes.length > 0))\r\n        return null;\r\n    Image imageIcon = null;\r\n    try {\r\n        Image image;\r\n        try {\r\n            image = ImageIO.read(new ByteArrayInputStream(imageBytes));\r\n        } catch (Exception e) {\r\n            try {\r\n                image = Toolkit.getDefaultToolkit().createImage(imageBytes);\r\n            } catch (Exception e1) {\r\n                throw e;\r\n            }\r\n        }\r\n        if (image != null)\r\n            imageIcon = scaleImageWithinBounds(image, width, height);\r\n        else if (logger.isTraceEnabled())\r\n            logger.trace(\"Unknown image format or error reading image\");\r\n    } catch (Exception e) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Could not create image.\", e);\r\n    }\r\n    if (imageIcon != null)\r\n        return new ImageIcon(imageIcon);\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.reconnectplugin.ReconnectPluginActivator.handleProviderRemoved",
	"Comment": "stop listening for events as the provider is removed.providers are removed this way only when there are modifiedin the configuration. so as the provider is modified we will eraseevery instance we got.",
	"Method": "void handleProviderRemoved(ProtocolProviderService provider){\r\n    if (logger.isTraceEnabled())\r\n        logger.trace(\"Provider modified forget every instance of it\");\r\n    if (hasAtLeastOneSuccessfulConnection(provider)) {\r\n        setAtLeastOneSuccessfulConnection(provider, false);\r\n    }\r\n    provider.removeRegistrationStateChangeListener(this);\r\n    autoReconnEnabledProviders.remove(provider);\r\n    needsReconnection.remove(provider);\r\n    if (currentlyReconnecting.containsKey(provider)) {\r\n        currentlyReconnecting.remove(provider).cancel();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.metahistory.MetaHistoryServiceLick.start",
	"Comment": "start the file history sevice implementation compatibility kit.",
	"Method": "void start(BundleContext bundleContext){\r\n    MetaHistoryServiceLick.bc = bundleContext;\r\n    setName(\"MetaHistoryServiceSLick\");\r\n    Hashtable<String, String> properties = new Hashtable<String, String>();\r\n    properties.put(\"service.pid\", getName());\r\n    addTest(TestMetaHistoryService.suite());\r\n    bundleContext.registerService(getClass().getName(), this, properties);\r\n    logger.debug(\"Successfully registered \" + getClass().getName());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetServerStoredAccountInfoSipImpl.getAccountImage",
	"Comment": "gets the user avatar from the server or returns cached value.",
	"Method": "ImageDetail getAccountImage(){\r\n    if (isAccountImageLoaded) {\r\n        return accountImage;\r\n    }\r\n    isAccountImageLoaded = true;\r\n    try {\r\n        accountImage = getImageDetail();\r\n    } catch (OperationFailedException e) {\r\n        if (logger.isInfoEnabled()) {\r\n            logger.info(\"Avatar image cannot be loaded\", e);\r\n        }\r\n    }\r\n    return accountImage;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.notification.NotificationServiceImpl.fireNotificationActionTypeEvent",
	"Comment": "notifies all registered notificationchangelisteners that anotificationactiontypeevent has occurred.",
	"Method": "void fireNotificationActionTypeEvent(String eventType,String sourceEventType,NotificationAction action){\r\n    NotificationActionTypeEvent event = new NotificationActionTypeEvent(this, eventType, sourceEventType, action);\r\n    for (NotificationChangeListener listener : changeListeners) {\r\n        if (eventType.equals(ACTION_ADDED)) {\r\n            listener.actionAdded(event);\r\n        } else if (eventType.equals(ACTION_REMOVED)) {\r\n            listener.actionRemoved(event);\r\n        } else if (eventType.equals(ACTION_CHANGED)) {\r\n            listener.actionChanged(event);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.account.EmptyAccountRegistrationWizard.getProtocolName",
	"Comment": "returns the name of a dummy protocol which is actually a prompt to selecta network.",
	"Method": "String getProtocolName(){\r\n    return GuiActivator.getResources().getI18NString(\"impl.gui.main.account.DUMMY_PROTOCOL_NAME\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetExtendedAuthorizationsJabberImpl.reRequestAuthorization",
	"Comment": "send an authorization request, requesting contact to add themto our contact list?",
	"Method": "void reRequestAuthorization(AuthorizationRequest request,Contact contact){\r\n    opSetPersPresence.assertConnected();\r\n    if (!(contact instanceof ContactJabberImpl))\r\n        throw new IllegalArgumentException(\"The specified contact is not an jabber contact.\" + contact);\r\n    Presence responsePacket = new Presence(Presence.Type.subscribe);\r\n    responsePacket.setTo(contact.getAddress());\r\n    parentProvider.getConnection().sendPacket(responsePacket);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatSession.getChatSessionRenderer",
	"Comment": "returns the chatsessionrenderer that provides the connectionbetween this chat session and its ui.",
	"Method": "ChatSessionRenderer getChatSessionRenderer(){\r\n    return sessionRenderer;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockChatRoom.revokeOwnership",
	"Comment": "revokes the ownership role for the participant given by address.",
	"Method": "void revokeOwnership(String address){\r\n    throw new UnsupportedOperationException(\"Not supported yet.\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.caps.EntityCapsManager.removeUserCapsNodeListener",
	"Comment": "removes a specific usercapsnodelistener from the list ofusercapsnodelisteners interested in events notifying aboutchanges in the list of user caps nodes of thisentitycapsmanager.",
	"Method": "void removeUserCapsNodeListener(UserCapsNodeListener listener){\r\n    if (listener != null) {\r\n        synchronized (userCapsNodeListeners) {\r\n            userCapsNodeListeners.remove(listener);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.librec.util.DateUtil.toString",
	"Comment": "parse the milliseconds date to string with specified pattern.",
	"Method": "String toString(long mms,String pattern,String toString,long mms){\r\n    return sdf.format(new java.sql.Date(mms));\r\n}"
}, {
	"Path": "net.librec.data.model.TextDataModelTestCase.getValidRatio",
	"Comment": "calculate the ratio of validation set of a specified datamodel object",
	"Method": "double getValidRatio(DataModel dataModel){\r\n    double validSize = getValidSize(dataModel);\r\n    double totalSize = getDataSize(dataModel);\r\n    return validSize / totalSize;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.googlecontacts.GoogleContactsActivator.getResourceManagementService",
	"Comment": "returns a reference to a resourcemanagementservice implementationcurrently registered in the bundle context or null if no suchimplementation was found.",
	"Method": "ResourceManagementService getResourceManagementService(){\r\n    if (resourceService == null) {\r\n        resourceService = ResourceManagementServiceUtils.getService(bundleContext);\r\n    }\r\n    return resourceService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.whiteboard.gui.whiteboardshapes.WhiteboardShapePolyLine.setPoints",
	"Comment": "sets the list of whiteboardpoint instances that thiswhiteboardobject is composed of.",
	"Method": "void setPoints(List<WhiteboardPoint> points){\r\n    this.points = new ArrayList<WhiteboardPoint>(points);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.callhistory.event.CallHistoryPeerRecordEvent.getProvider",
	"Comment": "returns the protocol provider service associated with the event.",
	"Method": "ProtocolProviderService getProvider(){\r\n    return provider;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.MessageReceivedEvent.getPrivateMessagingContactRoom",
	"Comment": "returns the chat room of the private messaging contact associated with the event and null if the contact is not private messaging contact.",
	"Method": "ChatRoom getPrivateMessagingContactRoom(){\r\n    return privateMessagingContactRoom;\r\n}"
}, {
	"Path": "net.librec.recommender.cf.UserKNNTestCase.test10SplitterRatioItemDate",
	"Comment": "test ratiodatasplitter with item date ratio, evaluating enabled.",
	"Method": "void test10SplitterRatioItemDate(){\r\n    Resource resource = new Resource(\"rec/cf/userknn-test.properties\");\r\n    conf.addResource(resource);\r\n    conf.set(\"rec.eval.enable\", \"true\");\r\n    conf.set(\"data.model.splitter\", \"ratio\");\r\n    conf.set(\"data.input.path\", \"test/datamodeltest/ratings-date.txt\");\r\n    conf.set(\"data.column.format\", \"UIRT\");\r\n    conf.set(\"data.splitter.ratio\", \"itemdate\");\r\n    RecommenderJob job = new RecommenderJob(conf);\r\n    job.runJob();\r\n}"
}, {
	"Path": "io.lettuce.core.dynamic.support.ParentTypeAwareTypeInformation.mergeMaps",
	"Comment": "merges the type variable maps of the given parent with the new map.",
	"Method": "Map<TypeVariable<?>, Type> mergeMaps(TypeDiscoverer<?> parent,Map<TypeVariable<?>, Type> map){\r\n    Map<TypeVariable<?>, Type> typeVariableMap = new HashMap<TypeVariable<?>, Type>();\r\n    typeVariableMap.putAll(map);\r\n    typeVariableMap.putAll(parent.getTypeVariableMap());\r\n    return typeVariableMap;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipMessageFactory.stripReplacesHeader",
	"Comment": "returns the replacesheader contained, if any, in theuri of a specific address after removing itfrom there.",
	"Method": "Header stripReplacesHeader(Address address){\r\n    javax.sip.address.URI uri = address.getURI();\r\n    Header replacesHeader = null;\r\n    if (uri.isSipURI()) {\r\n        SipURI sipURI = (SipURI) uri;\r\n        String replacesHeaderValue = sipURI.getHeader(ReplacesHeader.NAME);\r\n        if (replacesHeaderValue != null) {\r\n            for (Iterator<?> headerNameIter = sipURI.getHeaderNames(); headerNameIter.hasNext(); ) {\r\n                if (ReplacesHeader.NAME.equals(headerNameIter.next())) {\r\n                    headerNameIter.remove();\r\n                    break;\r\n                }\r\n            }\r\n            try {\r\n                replacesHeader = protocolProvider.getHeaderFactory().createHeader(ReplacesHeader.NAME, URLDecoder.decode(replacesHeaderValue, \"UTF-8\"));\r\n            } catch (Exception ex) {\r\n                throw new OperationFailedException(\"Failed to create ReplacesHeader from \" + replacesHeaderValue, OperationFailedException.INTERNAL_ERROR, ex);\r\n            }\r\n        }\r\n    }\r\n    return replacesHeader;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipMessageFactory.createUnRegisterRequest",
	"Comment": "creates a request that would end a registration established withregisterrequest",
	"Method": "Request createUnRegisterRequest(Request registerRequest,long cSeqValue){\r\n    Request unregisterRequest = (Request) registerRequest.clone();\r\n    unregisterRequest.getExpires().setExpires(0);\r\n    CSeqHeader cSeqHeader = (CSeqHeader) unregisterRequest.getHeader(CSeqHeader.NAME);\r\n    cSeqHeader.setSeqNumber(cSeqValue);\r\n    ViaHeader via = (ViaHeader) unregisterRequest.getHeader(ViaHeader.NAME);\r\n    if (via != null)\r\n        via.removeParameter(\"branch\");\r\n    ContactHeader contact = (ContactHeader) unregisterRequest.getHeader(ContactHeader.NAME);\r\n    contact.setExpires(0);\r\n    attachScSpecifics(unregisterRequest);\r\n    return unregisterRequest;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetMessageWaitingSipImpl.getSubscribeAddress",
	"Comment": "returns the subscribe address for current account mailbox, defaultor configured.",
	"Method": "Address getSubscribeAddress(){\r\n    String vmAddressURI = provider.getAccountID().getAccountPropertyString(ProtocolProviderFactory.VOICEMAIL_URI);\r\n    if (StringUtils.isNullOrEmpty(vmAddressURI))\r\n        return provider.getRegistrarConnection().getAddressOfRecord();\r\n    else\r\n        return provider.parseAddressString(vmAddressURI);\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.TestFileSessions.testLoadOnlyMostRecentFiles",
	"Comment": "tests that only the most recent file will beloaded into the cache, even if it is alreadyexpired. other recently expired files forsame session should be deleted.",
	"Method": "void testLoadOnlyMostRecentFiles(){\r\n    ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);\r\n    context.setContextPath(\"/test\");\r\n    SessionDataStoreFactory factory = createSessionDataStoreFactory();\r\n    ((AbstractSessionDataStoreFactory) factory).setGracePeriodSec(100);\r\n    SessionDataStore store = factory.getSessionDataStore(context.getSessionHandler());\r\n    SessionContext sessionContext = new SessionContext(\"foo\", context.getServletContext());\r\n    store.initialize(sessionContext);\r\n    long now = System.currentTimeMillis();\r\n    long exp = now - 5000L;\r\n    String name1 = Long.toString(exp) + \"__test_0.0.0.0_abc\";\r\n    FileTestHelper.createFile(name1);\r\n    exp = now - 4000L;\r\n    String name2 = Long.toString(exp) + \"__test_0.0.0.0_abc\";\r\n    FileTestHelper.createFile(name2);\r\n    exp = now - 3000L;\r\n    String name3 = Long.toString(exp) + \"__test_0.0.0.0_abc\";\r\n    FileTestHelper.createFile(name3);\r\n    store.start();\r\n    FileTestHelper.assertFileExists(name1, false);\r\n    FileTestHelper.assertFileExists(name2, false);\r\n    FileTestHelper.assertFileExists(name3, true);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.UIServiceImpl.getPopupDialog",
	"Comment": "implements getpopupdialog in the uiservice interface.returns a popupdialog that could be used to show simplemessages, warnings, errors, etc.",
	"Method": "PopupDialog getPopupDialog(){\r\n    return this.popupDialog;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl.removeMethodProcessorListener",
	"Comment": "unregisters a specific methodprocessorlistener from thiscallpeer so that it no longer gets notified by this instanceabout the processing of sip signaling. if the specified listeneris not registered with this instance, does nothing.",
	"Method": "void removeMethodProcessorListener(MethodProcessorListener listener){\r\n    if (listener != null)\r\n        synchronized (methodProcessorListeners) {\r\n            methodProcessorListeners.remove(listener);\r\n        }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl.processUpdate",
	"Comment": "processes a specific request.update request for the purposes oftelephony.",
	"Method": "boolean processUpdate(ServerTransaction serverTransaction,Request updateRequest){\r\n    ContentLengthHeader cl = updateRequest.getContentLength();\r\n    if (cl != null && cl.getContentLength() > 0)\r\n        return false;\r\n    Response ok;\r\n    try {\r\n        ok = messageFactory.createResponse(Response.OK, updateRequest);\r\n        serverTransaction.sendResponse(ok);\r\n    } catch (ParseException ex) {\r\n        String message = \"Failed to create OK response to UPDATE.\";\r\n        logger.error(message, ex);\r\n        return false;\r\n    } catch (Exception ex) {\r\n        String message = \"Failed to send OK response to UPDATE request.\";\r\n        logger.error(message, ex);\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.muc.ChatRoomListChangeEvent.toString",
	"Comment": "returns a string representation of this guichatroomevent.",
	"Method": "String toString(){\r\n    StringBuffer buff = new StringBuffer(\"GuiChatRoomEvent-[ ChatRoomID=\");\r\n    buff.append(getSourceChatRoom().getChatRoomName());\r\n    buff.append(\", eventID=\").append(getEventID());\r\n    buff.append(\", ProtocolProvider=\");\r\n    return buff.toString();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.callhistory.CallHistoryServiceImpl.getProtocolProvider",
	"Comment": "returns the protocolproviderservice corresponding to the givenaccount identifier.",
	"Method": "ProtocolProviderService getProtocolProvider(String accountUID){\r\n    for (ProtocolProviderFactory providerFactory : CallHistoryActivator.getProtocolProviderFactories().values()) {\r\n        for (AccountID accountID : providerFactory.getRegisteredAccounts()) {\r\n            if (accountID.getAccountUniqueID().equals(accountUID)) {\r\n                ServiceReference<ProtocolProviderService> serRef = providerFactory.getProviderForAccount(accountID);\r\n                return CallHistoryActivator.bundleContext.getService(serRef);\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.iptelaccregwizz.IptelAccountRegistrationWizard.getPageImage",
	"Comment": "implements the accountregistrationwizard.getpageimage method.returns the image used to decorate the wizard page",
	"Method": "byte[] getPageImage(){\r\n    return IptelAccRegWizzActivator.getResources().getImageInBytes(PAGE_IMAGE);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatManager.addAdHocChatRoomListChangeListener",
	"Comment": "adds the given adhocchatroomlistchangelistener that will listenfor all changes of the chat room list data model.",
	"Method": "void addAdHocChatRoomListChangeListener(AdHocChatRoomListChangeListener l){\r\n    synchronized (adHoclistChangeListeners) {\r\n        adHoclistChangeListeners.add(l);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomIrcImpl.setLocalUser",
	"Comment": "method for setting chat room member instance representing the user.",
	"Method": "void setLocalUser(ChatRoomMemberIrcImpl user){\r\n    if (user == null) {\r\n        throw new IllegalArgumentException(\"user cannot be null\");\r\n    }\r\n    this.user = user;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ServerStoredContactListJabberImpl.removeContact",
	"Comment": "removes a contact from the serverside listevent will come for successful operation",
	"Method": "void removeContact(ContactJabberImpl contactToRemove){\r\n    if (contactToRemove instanceof VolatileContactJabberImpl) {\r\n        contactDeleted(contactToRemove);\r\n        return;\r\n    }\r\n    try {\r\n        RosterEntry entry = contactToRemove.getSourceEntry();\r\n        if (entry != null)\r\n            this.roster.removeEntry(entry);\r\n    } catch (XMPPException ex) {\r\n        String errTxt = \"Error removing contact\";\r\n        logger.error(errTxt, ex);\r\n        int errorCode = OperationFailedException.INTERNAL_ERROR;\r\n        XMPPError err = ex.getXMPPError();\r\n        if (err != null) {\r\n            if (err.getCode() > 400 && err.getCode() < 500)\r\n                errorCode = OperationFailedException.FORBIDDEN;\r\n            else if (err.getCode() > 500)\r\n                errorCode = OperationFailedException.INTERNAL_SERVER_ERROR;\r\n            errTxt = err.getCondition();\r\n        }\r\n        throw new OperationFailedException(errTxt, errorCode, ex);\r\n    }\r\n}"
}, {
	"Path": "net.librec.recommender.baseline.ConstantGuessRecommender.predict",
	"Comment": "constant value as the predictive rating for user useridx on item itemidx.",
	"Method": "double predict(int userIdx,int itemIdx){\r\n    return constant;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetPresenceSipImpl.getNonPersistentGroup",
	"Comment": "returns the volatile group or null if this group has not yet beencreated.",
	"Method": "ContactGroupSipImpl getNonPersistentGroup(){\r\n    for (int i = 0; i < getServerStoredContactListRoot().countSubgroups(); i++) {\r\n        ContactGroupSipImpl gr = (ContactGroupSipImpl) getServerStoredContactListRoot().getGroup(i);\r\n        if (!gr.isPersistent()) {\r\n            return gr;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.exampleplugin.PluginDialog.initStyles",
	"Comment": "initializes needed layouts, alignments, borders and different text areastyle constants.",
	"Method": "void initStyles(){\r\n    this.mainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.Y_AXIS));\r\n    this.mainPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\r\n    this.infoTextArea.setEditable(false);\r\n    this.infoTextArea.setOpaque(false);\r\n    this.infoTextArea.setWrapStyleWord(true);\r\n    this.infoTextArea.setLineWrap(true);\r\n    this.infoTextArea.setFont(infoTextArea.getFont().deriveFont(Font.BOLD));\r\n    this.infoTextArea.setAlignmentX(JTextArea.CENTER_ALIGNMENT);\r\n    this.nameLabel.setAlignmentX(JLabel.CENTER_ALIGNMENT);\r\n    this.contactLabel.setAlignmentX(JLabel.CENTER_ALIGNMENT);\r\n    this.contactLabel.setAlignmentY(JLabel.TOP_ALIGNMENT);\r\n    this.contactLabel.setFont(contactLabel.getFont().deriveFont(Font.BOLD));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chatroomslist.joinforms.JoinChatRoomWindow.getChatRoomList",
	"Comment": "updates the chat rooms list when a key change is performed in the searchfield. the new chat rooms list will contain all the chat rooms whose namestart with search fields text value.",
	"Method": "Vector<String> getChatRoomList(String match){\r\n    Vector<String> rooms = new Vector<String>();\r\n    if (serverRooms != null)\r\n        for (String room : serverRooms) if (room.startsWith(match))\r\n            rooms.add(room);\r\n    Collections.sort(rooms);\r\n    return rooms;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chatroomslist.joinforms.SelectAccountPanel.addListSelectionListener",
	"Comment": "adds a listselectionlistener to the list of accounts, which willlisten for events triggered by user clicks on the rows in the table.",
	"Method": "void addListSelectionListener(ListSelectionListener listener){\r\n    accountsTable.getSelectionModel().addListSelectionListener(listener);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.macosx.MacOSXAddrBookSourceContact.lock",
	"Comment": "locks this object before adding or removing several contact details.",
	"Method": "void lock(){\r\n    synchronized (this) {\r\n        locked = Boolean.TRUE;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.geolocation.GeolocationPacketExtension.setLocality",
	"Comment": "sets a locality within the administrative region, such as a town orcity.",
	"Method": "void setLocality(String locality){\r\n    this.locality = locality;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.MobileIndicator.containsStrings",
	"Comment": "checks whether value containsone of the checkstrs strings.",
	"Method": "boolean containsStrings(String value,String[] checkStrs){\r\n    for (String str : checkStrs) {\r\n        if (str.length() > 0 && value.contains(str))\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomConfigurationFormFieldJabberImpl.getName",
	"Comment": "returns the variable name of the corresponding smack property.",
	"Method": "String getName(){\r\n    return smackFormField.getVariable();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl.throwOperationFailedException",
	"Comment": "lets the underlying implementation take note of this error and onlythen throws it to the using bundles.",
	"Method": "void throwOperationFailedException(String message,int errorCode,Throwable cause){\r\n    ProtocolProviderServiceSipImpl.throwOperationFailedException(message, errorCode, cause, logger);\r\n}"
}, {
	"Path": "io.lettuce.core.codec.CompressionCodec.copy",
	"Comment": "copies all bytes from the input stream to the output stream. does not close or flush either stream.",
	"Method": "long copy(InputStream from,OutputStream to){\r\n    LettuceAssert.notNull(from, \"From must not be null\");\r\n    LettuceAssert.notNull(to, \"From must not be null\");\r\n    byte[] buf = new byte[4096];\r\n    long total = 0;\r\n    while (true) {\r\n        int r = from.read(buf);\r\n        if (r == -1) {\r\n            break;\r\n        }\r\n        to.write(buf, 0, r);\r\n        total += r;\r\n    }\r\n    return total;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.osdependent.jdic.StatusSimpleSelector.actionPerformed",
	"Comment": "change the status of the protocol according tothe menu item selected",
	"Method": "void actionPerformed(ActionEvent evt){\r\n    changeStatus(evt.getSource());\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.ContactResource.isMobile",
	"Comment": "whether contact is mobile one. logged in only from mobile device.",
	"Method": "boolean isMobile(){\r\n    return mobile;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaAwareCall.setCallState",
	"Comment": "sets the state of this call and fires a newcallchangeevent notifying the registeredcallchangelisteners about the change of the state.",
	"Method": "void setCallState(CallState newState,CallPeerChangeEvent cause){\r\n    try {\r\n        super.setCallState(newState, cause);\r\n    } finally {\r\n        if (CallState.CALL_ENDED.equals(getCallState()))\r\n            ProtocolMediaActivator.getMediaService().removePropertyChangeListener(this);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.neomedia.NeomediaActivator.getBundleContext",
	"Comment": "returns the context in which the one and only neomediaactivatorinstance has started executing.",
	"Method": "BundleContext getBundleContext(){\r\n    return bundleContext;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.UIServiceImpl.getSupportedContainers",
	"Comment": "implements uisercie.getsupportedcontainers. returns thelist of supported containers by this implementation .",
	"Method": "Iterator<Container> getSupportedContainers(){\r\n    return Collections.unmodifiableList(supportedContainers).iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.msoutlook.MsOutlookAddrBookContactQuery.deleted",
	"Comment": "callback method when receiving notifications for deleted items.",
	"Method": "void deleted(String id){\r\n    if (id != null) {\r\n        synchronized (MsOutlookAddrBookContactQuery.class) {\r\n            SourceContact sourceContact = findSourceContactByID(id, 1);\r\n            if (sourceContact != null) {\r\n                fireContactRemoved(sourceContact);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.librec.util.FileUtil.getReader",
	"Comment": "return the bufferedreader list of files in a specified directory.",
	"Method": "List<BufferedReader> getReader(String path,BufferedReader getReader,File file){\r\n    return new BufferedReader(new FileReader(file));\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaAwareCall.isConferenceFocus",
	"Comment": "gets the indicator which determines whether the local peer represented bythis call is acting as a conference focus and thus may need tosend the corresponding parameters in its outgoing signaling.",
	"Method": "boolean isConferenceFocus(){\r\n    return getConference().isConferenceFocus();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockStatusEnum.supportedStatusSet",
	"Comment": "returns an iterator over all status instances supproted by the mockprovider.",
	"Method": "Iterator<PresenceStatus> supportedStatusSet(){\r\n    return supportedStatusSet.iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler.getLocalVisualComponent",
	"Comment": "gets the visual component, if any, depicting the video streamedfrom the local peer to the remote peer.",
	"Method": "Component getLocalVisualComponent(){\r\n    MediaStream videoStream = getStream(MediaType.VIDEO);\r\n    return ((videoStream == null) || !isLocalVideoTransmissionEnabled()) ? null : ((VideoMediaStream) videoStream).getLocalVisualComponent();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.CallHistoryFilter.applyFilter",
	"Comment": "applies this filter and stores the result in the given treemodel.",
	"Method": "void applyFilter(FilterQuery filterQuery){\r\n    NotificationContactSource notificationSource = TreeContactList.getNotificationContactSource();\r\n    if (notificationSource != null)\r\n        addMatching(notificationSource);\r\n    Collection<UIContactSource> contactSources = GuiActivator.getContactList().getContactSources(ContactSourceService.HISTORY_TYPE);\r\n    TreeContactList contactList = GuiActivator.getContactList();\r\n    for (UIContactSource contactSource : contactSources) {\r\n        ContactQuery query = contactSource.getContactSourceService().createContactQuery(\"\", 50);\r\n        if (query == null)\r\n            continue;\r\n        query.addContactQueryListener(contactList);\r\n        filterQuery.addContactQuery(query);\r\n        query.start();\r\n    }\r\n    filterQuery.close();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.notification.CommandNotificationHandlerImpl.execute",
	"Comment": "executes the command, given by the descriptor of a specificcommandnotificationaction.",
	"Method": "void execute(CommandNotificationAction action,Map<String, String> cmdargs){\r\n    String actionDescriptor = action.getDescriptor();\r\n    if (StringUtils.isNullOrEmpty(actionDescriptor, true))\r\n        return;\r\n    if (cmdargs != null) {\r\n        for (Map.Entry<String, String> cmdarg : cmdargs.entrySet()) {\r\n            actionDescriptor = actionDescriptor.replace(\"${\" + cmdarg.getKey() + \"}\", cmdarg.getValue());\r\n        }\r\n    }\r\n    try {\r\n        Runtime.getRuntime().exec(actionDescriptor);\r\n    } catch (IOException ioe) {\r\n        logger.error(\"Failed to execute the following command: \" + action.getDescriptor(), ioe);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.gibberishaccregwizz.GibberishAccountRegistrationWizard.getSummary",
	"Comment": "returns the set of data that user has entered through this wizard.",
	"Method": "Iterator<Map.Entry<String, String>> getSummary(){\r\n    Map<String, String> summaryTable = new Hashtable<String, String>();\r\n    summaryTable.put(\"User ID\", registration.getUserID());\r\n    return summaryTable.entrySet().iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ChatContactListModel.removeElement",
	"Comment": "removes a specific chatcontact from thisabstractlistmodel implementation.",
	"Method": "void removeElement(ChatContact<?> chatContact){\r\n    synchronized (chatContacts) {\r\n        int index = chatContacts.indexOf(chatContact);\r\n        if ((index >= 0) && chatContacts.remove(chatContact))\r\n            fireIntervalRemoved(this, index, index);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatManager.addHistoryWindowForChatRoom",
	"Comment": "adds a history window for a given chat room in the table of openedhistory windows.",
	"Method": "void addHistoryWindowForChatRoom(ChatRoomWrapper chatRoomWrapper,HistoryWindow historyWindow){\r\n    chatRoomHistory.put(chatRoomWrapper, historyWindow);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapPersonFoundImpl.setFirstName",
	"Comment": "sets the first name found in the the directory for this person",
	"Method": "void setFirstName(String firstName){\r\n    this.firstName = firstName;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.call.MetaContactPhoneUtil.hasContactCapabilities",
	"Comment": "returns true if contact supports the specifiedoperationset, false otherwise.",
	"Method": "boolean hasContactCapabilities(Contact contact,Class<? extends OperationSet> opSet){\r\n    OperationSetContactCapabilities capOpSet = contact.getProtocolProvider().getOperationSet(OperationSetContactCapabilities.class);\r\n    if (capOpSet == null) {\r\n        return true;\r\n    } else {\r\n        if (capOpSet.getOperationSet(contact, opSet) != null) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetAutoAnswerSipImpl.doesRequestContainsActiveVideoMediaType",
	"Comment": "detects if the incoming call is a video call. parses the sdp from the siprequest to determine if the video is active.",
	"Method": "boolean doesRequestContainsActiveVideoMediaType(Call call){\r\n    Iterator<? extends CallPeer> peers = call.getCallPeers();\r\n    while (peers.hasNext()) {\r\n        Transaction transaction = ((CallPeerSipImpl) peers.next()).getLatestInviteTransaction();\r\n        if (transaction != null) {\r\n            Request inviteReq = transaction.getRequest();\r\n            if (inviteReq != null && inviteReq.getRawContent() != null) {\r\n                String sdpStr = SdpUtils.getContentAsString(inviteReq);\r\n                SessionDescription sesDescr = SdpUtils.parseSdpString(sdpStr);\r\n                List<MediaDescription> remoteDescriptions = SdpUtils.extractMediaDescriptions(sesDescr);\r\n                for (MediaDescription mediaDescription : remoteDescriptions) {\r\n                    if (SdpUtils.getMediaType(mediaDescription) == MediaType.VIDEO) {\r\n                        if (SdpUtils.getDirection(mediaDescription) == MediaDirection.SENDRECV) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler.closeStream",
	"Comment": "closes the mediastream that this instance uses for a specificmediatype and prepares it for garbage collection.",
	"Method": "void closeStream(MediaType mediaType){\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Closing \" + mediaType + \" stream for \" + getPeer());\r\n    boolean mediaHandlerCloseStream = false;\r\n    switch(mediaType) {\r\n        case AUDIO:\r\n            if (audioStream != null) {\r\n                audioStream = null;\r\n                mediaHandlerCloseStream = true;\r\n            }\r\n            break;\r\n        case VIDEO:\r\n            if (videoStream != null) {\r\n                videoStream = null;\r\n                mediaHandlerCloseStream = true;\r\n            }\r\n            break;\r\n    }\r\n    if (mediaHandlerCloseStream)\r\n        mediaHandler.closeStream(this, mediaType);\r\n    TransportManager<?> transportManager = queryTransportManager();\r\n    if (transportManager != null)\r\n        transportManager.closeStreamConnector(mediaType);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.systray.AbstractSystrayService.getActivePopupMessageHandler",
	"Comment": "get the handler currently used by this implementation to popup message",
	"Method": "PopupMessageHandler getActivePopupMessageHandler(){\r\n    return activePopupHandler;\r\n}"
}, {
	"Path": "net.librec.recommender.cf.UserKNNTestCase.test13SplitterGivenNUserDate",
	"Comment": "test givenndatasplitter with userdate, evaluating enabled.",
	"Method": "void test13SplitterGivenNUserDate(){\r\n    Resource resource = new Resource(\"rec/cf/userknn-test.properties\");\r\n    conf.addResource(resource);\r\n    conf.set(\"rec.eval.enable\", \"true\");\r\n    conf.set(\"data.model.splitter\", \"givenn\");\r\n    conf.set(\"data.splitter.givenn.n\", \"5\");\r\n    conf.set(\"data.input.path\", \"test/datamodeltest/ratings-date.txt\");\r\n    conf.set(\"data.column.format\", \"UIRT\");\r\n    conf.set(\"data.splitter.givenn\", \"userdate\");\r\n    RecommenderJob job = new RecommenderJob(conf);\r\n    job.runJob();\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.NetworkUtils.getProtocolFromNAPTRRecords",
	"Comment": "returns the mapping from rfc3263 between service and the protocols.",
	"Method": "String getProtocolFromNAPTRRecords(String service){\r\n    if (service.equalsIgnoreCase(\"SIP+D2U\"))\r\n        return \"UDP\";\r\n    else if (service.equalsIgnoreCase(\"SIP+D2T\"))\r\n        return \"TCP\";\r\n    else if (service.equalsIgnoreCase(\"SIPS+D2T\"))\r\n        return \"TLS\";\r\n    else\r\n        return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ContactListModel.countContactsAndSubgroups",
	"Comment": "returns the number of all children of the given metacontactgroup. countsin depth all subgroups and child contacts.",
	"Method": "int countContactsAndSubgroups(MetaContactGroup parentGroup){\r\n    int count = 0;\r\n    if (parentGroup != null && !this.isGroupClosed(parentGroup)) {\r\n        if (showOffline) {\r\n            count = parentGroup.countChildContacts();\r\n        } else {\r\n            Iterator<MetaContact> i = parentGroup.getChildContacts();\r\n            while (i.hasNext()) {\r\n                MetaContact contact = i.next();\r\n                if (isContactOnline(contact))\r\n                    count++;\r\n            }\r\n        }\r\n        Iterator<MetaContactGroup> subgroups = parentGroup.getSubgroups();\r\n        while (subgroups.hasNext()) {\r\n            MetaContactGroup subgroup = subgroups.next();\r\n            count += countContactsAndSubgroups(subgroup);\r\n        }\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.colibri.ColibriBuilder.assertRequestType",
	"Comment": "makes sure that we do not modify the request type after construction hasbeen started.",
	"Method": "void assertRequestType(RequestType currentReqType){\r\n    if (requestType == RequestType.UNDEFINED) {\r\n        requestType = currentReqType;\r\n    }\r\n    if (requestType != currentReqType) {\r\n        throw new IllegalStateException(\"Current request type\");\r\n    }\r\n}"
}, {
	"Path": "net.librec.eval.AbstractRecommenderEvaluator.evaluateIndependently",
	"Comment": "evaluate independently on the test set with the the list of recommended items.",
	"Method": "double evaluateIndependently(Configuration conf,RecommendedList groundTruthList,RecommendedList recommendedList){\r\n    this.conf = conf;\r\n    this.topN = conf != null ? conf.getInt(\"rec.recommender.ranking.topn\", -1) : -1;\r\n    RecommendedList[] lists = groundTruthList.joinTransform(recommendedList, topN);\r\n    return evaluate(lists[0], lists[1]);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.LoginByClientCertificateStrategy.isTlsRequired",
	"Comment": "always true as the authentication occurs with the tls clientcertificate.",
	"Method": "boolean isTlsRequired(){\r\n    return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.aimaccregwizz.AimAccountRegistrationWizard.getIcon",
	"Comment": "returns the protocol icon that will be shown on the left of the protocolname in the list, where user will choose the protocol to register to.",
	"Method": "byte[] getIcon(){\r\n    return Resources.getImage(Resources.AIM_LOGO);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactListServiceImpl.findMetaContactByMetaUID",
	"Comment": "returns the metacontact that corresponds to the specified metacontactid.",
	"Method": "MetaContact findMetaContactByMetaUID(String metaContactID){\r\n    return rootMetaGroup.findMetaContactByMetaUID(metaContactID);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.msghistory.TestMsgHistoryService.insertRecords",
	"Comment": "inserts a message between the control dates and queries to checkof the expected number of messages.",
	"Method": "void insertRecords(){\r\n    if (!(msgHistoryService instanceof MessageHistoryAdvancedService))\r\n        return;\r\n    ((MessageHistoryAdvancedService) msgHistoryService).insertMessage(\"out\", null, testContact, messagesToSend[1], new Date(controlDate1.getTime() + 50), false);\r\n    Collection<EventObject> rs = msgHistoryService.findByPeriod(testMetaContact, controlDate1, controlDate2);\r\n    List<String> msgs = getMessages(rs);\r\n    assertEquals(\"Messages must be found\", 3, msgs.size());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.SearchField.filterQueryFailed",
	"Comment": "indicates that the given query has finished with failure, i.e.no results for the filter were found.",
	"Method": "void filterQueryFailed(FilterQuery query){\r\n    if (currentFilterQuery.equals(query))\r\n        filterQueryFinished(query, false);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallManager.assertIsEventDispatchingThread",
	"Comment": "throws a runtimeexception if the current thread is not the awtevent dispatching thread.",
	"Method": "void assertIsEventDispatchingThread(){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        throw new RuntimeException(\"The methon can be called only on the AWT event dispatching\" + \" thread.\");\r\n    }\r\n}"
}, {
	"Path": "net.librec.data.model.ArffDataModelTestCase.getTestSize",
	"Comment": "returns the size of test matrix of a specified datamodel object",
	"Method": "int getTestSize(DataModel dataModel){\r\n    return dataModel.getDataSplitter().getTestData().size();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.WhiteboardParticipantJabberImpl.getState",
	"Comment": "returns an object representing the current state of that participant.whiteboardparticipantstate may vary among connecting, busy, connected...",
	"Method": "WhiteboardParticipantState getState(){\r\n    return whiteboardParticipantState;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockBasicInstantMessaging.sendInstantMessage",
	"Comment": "sends the message to the destination indicated by theto contact.",
	"Method": "void sendInstantMessage(Contact to,Message message){\r\n    fireMessageEvent(new MessageDeliveredEvent(message, to, new Date()));\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.whiteboard.gui.WhiteboardFrame.releasedModif",
	"Comment": "when a shap is modified we send a message with the new position ratherthan deleting the shape",
	"Method": "void releasedModif(){\r\n    if (moving) {\r\n        if (selectedShape == null)\r\n            return;\r\n        doneDrawing = true;\r\n        sendMoveShape(selectedShape);\r\n        selectedShape = null;\r\n        moving = false;\r\n        repaint();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapServiceImpl.loadPersistentConfig",
	"Comment": "loads configuration form the user preferences in the serverset",
	"Method": "void loadPersistentConfig(){\r\n    String name;\r\n    LdapDirectorySettings settings = getFactory().createServerSettings();\r\n    LdapDirectory server;\r\n    List<String> list = getConfigService().getPropertyNamesByPrefix(\"net.java.sip.communicator.impl.ldap.directories\", true);\r\n    for (Object configEntry : list) {\r\n        name = getConfigService().getString(configEntry.toString());\r\n        if (name != null) {\r\n            settings.persistentLoad(name);\r\n            server = this.getFactory().createServer(settings);\r\n            this.serverSet.addServer(server);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.configforms.ConfigFormList.findDescriptor",
	"Comment": "finds the list descriptor corresponding the givenconfigurationform.",
	"Method": "ConfigFormDescriptor findDescriptor(ConfigurationForm configForm){\r\n    for (int i = 0; i < listModel.getSize(); i++) {\r\n        ConfigFormDescriptor descriptor = (ConfigFormDescriptor) listModel.getElementAt(i);\r\n        if (descriptor.getConfigForm().equals(configForm)) {\r\n            return descriptor;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.ReadonlyStatusItem.paintComponent",
	"Comment": "paints this component. if the state of this menu is connecting, paintsthe connecting icon.",
	"Method": "void paintComponent(Graphics g){\r\n    AntialiasingManager.activateAntialiasing(g);\r\n    super.paintComponent(g);\r\n    if (isConnecting)\r\n        g.drawImage(getConnectingIcon(), 0, 3, this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.osdependent.jdic.StatusSubMenu.getProtocolProviders",
	"Comment": "obtains all currently registered protocolproviderservices.",
	"Method": "List<ProtocolProviderService> getProtocolProviders(){\r\n    BundleContext bundleContext = OsDependentActivator.bundleContext;\r\n    Collection<ServiceReference<ProtocolProviderService>> ppsRefs = ServiceUtils.getServiceReferences(bundleContext, ProtocolProviderService.class);\r\n    List<ProtocolProviderService> protocolProviders = new ArrayList<ProtocolProviderService>();\r\n    if ((ppsRefs != null) && !ppsRefs.isEmpty()) {\r\n        for (ServiceReference<ProtocolProviderService> ppsRef : ppsRefs) protocolProviders.add(bundleContext.getService(ppsRef));\r\n    }\r\n    return protocolProviders;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.lookandfeel.SIPCommSplitPaneDivider.createRightOneTouchButton",
	"Comment": "creates and return an instance of jbutton that can be used to collapse the right component in the metal split pane.",
	"Method": "JButton createRightOneTouchButton(){\r\n    JButton b = new JButton() {\r\n        int[][] buffer = { { 2, 2, 2, 2, 2, 2, 2, 2 }, { 0, 1, 1, 1, 1, 1, 1, 3 }, { 0, 0, 1, 1, 1, 1, 3, 0 }, { 0, 0, 0, 1, 1, 3, 0, 0 }, { 0, 0, 0, 0, 3, 0, 0, 0 } };\r\n        @Override\r\n        public void setBorder(Border border) {\r\n        }\r\n        @Override\r\n        public void paint(Graphics g) {\r\n            JSplitPane splitPane = getSplitPaneFromSuper();\r\n            if (splitPane != null) {\r\n                int oneTouchSize = getOneTouchSizeFromSuper();\r\n                int orientation = getOrientationFromSuper();\r\n                int blockSize = Math.min(getDividerSize(), oneTouchSize);\r\n                Color[] colors = { this.getBackground(), MetalLookAndFeel.getPrimaryControlDarkShadow(), MetalLookAndFeel.getPrimaryControlInfo(), MetalLookAndFeel.getPrimaryControlHighlight() };\r\n                g.setColor(this.getBackground());\r\n                g.fillRect(0, 0, this.getWidth(), this.getHeight());\r\n                if (getModel().isPressed()) {\r\n                    colors[1] = colors[2];\r\n                }\r\n                if (orientation == JSplitPane.VERTICAL_SPLIT) {\r\n                    for (int i = 1; i <= buffer[0].length; i++) {\r\n                        for (int j = 1; j < blockSize; j++) {\r\n                            if (buffer[j - 1][i - 1] == 0) {\r\n                                continue;\r\n                            } else {\r\n                                g.setColor(colors[buffer[j - 1][i - 1]]);\r\n                            }\r\n                            g.drawLine(i, j, i, j);\r\n                        }\r\n                    }\r\n                } else {\r\n                    for (int i = 1; i <= buffer[0].length; i++) {\r\n                        for (int j = 1; j < blockSize; j++) {\r\n                            if (buffer[j - 1][i - 1] == 0) {\r\n                                continue;\r\n                            } else {\r\n                                g.setColor(colors[buffer[j - 1][i - 1]]);\r\n                            }\r\n                            g.drawLine(j, i, j, i);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    b.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));\r\n    b.setFocusPainted(false);\r\n    b.setBorderPainted(false);\r\n    b.setRequestFocusEnabled(false);\r\n    return b;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.lookandfeel.SIPCommSplitPaneDivider.createRightOneTouchButton",
	"Comment": "creates and return an instance of jbutton that can be used to collapse the right component in the metal split pane.",
	"Method": "JButton createRightOneTouchButton(){\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.lookandfeel.SIPCommSplitPaneDivider.createRightOneTouchButton",
	"Comment": "creates and return an instance of jbutton that can be used to collapse the right component in the metal split pane.",
	"Method": "JButton createRightOneTouchButton(){\r\n    JSplitPane splitPane = getSplitPaneFromSuper();\r\n    if (splitPane != null) {\r\n        int oneTouchSize = getOneTouchSizeFromSuper();\r\n        int orientation = getOrientationFromSuper();\r\n        int blockSize = Math.min(getDividerSize(), oneTouchSize);\r\n        Color[] colors = { this.getBackground(), MetalLookAndFeel.getPrimaryControlDarkShadow(), MetalLookAndFeel.getPrimaryControlInfo(), MetalLookAndFeel.getPrimaryControlHighlight() };\r\n        g.setColor(this.getBackground());\r\n        g.fillRect(0, 0, this.getWidth(), this.getHeight());\r\n        if (getModel().isPressed()) {\r\n            colors[1] = colors[2];\r\n        }\r\n        if (orientation == JSplitPane.VERTICAL_SPLIT) {\r\n            for (int i = 1; i <= buffer[0].length; i++) {\r\n                for (int j = 1; j < blockSize; j++) {\r\n                    if (buffer[j - 1][i - 1] == 0) {\r\n                        continue;\r\n                    } else {\r\n                        g.setColor(colors[buffer[j - 1][i - 1]]);\r\n                    }\r\n                    g.drawLine(i, j, i, j);\r\n                }\r\n            }\r\n        } else {\r\n            for (int i = 1; i <= buffer[0].length; i++) {\r\n                for (int j = 1; j < blockSize; j++) {\r\n                    if (buffer[j - 1][i - 1] == 0) {\r\n                        continue;\r\n                    } else {\r\n                        g.setColor(colors[buffer[j - 1][i - 1]]);\r\n                    }\r\n                    g.drawLine(j, i, j, i);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.MetaContactListSource.metaContactRenamed",
	"Comment": "refreshes the corresponding node, when a metacontact has beenrenamed in the metacontactlistservice.",
	"Method": "void metaContactRenamed(MetaContactRenamedEvent evt){\r\n    MetaContact metaContact = evt.getSourceMetaContact();\r\n    UIContactImpl uiContact;\r\n    synchronized (metaContact) {\r\n        uiContact = MetaContactListSource.getUIContact(metaContact);\r\n        if (uiContact == null)\r\n            return;\r\n    }\r\n    synchronized (uiContact) {\r\n        ContactNode contactNode = uiContact.getContactNode();\r\n        if (contactNode != null)\r\n            GuiActivator.getContactList().nodeChanged(contactNode);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ProtocolProviderServiceJabberImpl.isAuthenticationFailed",
	"Comment": "determines whether a specific xmppexception signals thatattempted authentication has failed.",
	"Method": "boolean isAuthenticationFailed(XMPPException ex){\r\n    String exMsg = ex.getMessage().toLowerCase();\r\n    return ((exMsg.indexOf(\"sasl authentication\") != -1) && (exMsg.indexOf(\"failed\") != -1)) || (exMsg.indexOf(\"does not support compatible authentication mechanism\") != -1) || (exMsg.indexOf(\"unable to determine password\") != -1);\r\n}"
}, {
	"Path": "net.librec.math.structure.OrderedIntDoubleMapping.setIndexAt",
	"Comment": "set the mapping index at the given position of the indices array",
	"Method": "void setIndexAt(int position,int index){\r\n    indices[position] = index;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.macosx.MacOSXAddrBookContactSourceService.getType",
	"Comment": "gets a string which uniquely identifies the instances of themacosxaddrbookcontactsourceservice implementation.",
	"Method": "int getType(){\r\n    return SEARCH_TYPE;\r\n}"
}, {
	"Path": "io.lettuce.core.cluster.RedisClusterClient.getPartitions",
	"Comment": "retrieve the cluster view. partitions are shared amongst all connections opened by this client instance.",
	"Method": "Partitions getPartitions(){\r\n    if (partitions == null) {\r\n        initializePartitions();\r\n    }\r\n    return partitions;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.WhiteboardInvitationRejectedEvent.getReason",
	"Comment": "returns the reason for which the chatroominvitation is rejected.",
	"Method": "String getReason(){\r\n    return reason;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.call.MetaContactPhoneUtil.checkMetaContactPhones",
	"Comment": "checking all contacts for the metacontact.return false if there are listeners added for a contactand we need to stop executions cause listener will be used to be informedfor result.",
	"Method": "boolean checkMetaContactPhones(boolean checkMetaContactPhones,DetailsResponseListener l){\r\n    Iterator<Contact> contactIterator = metaContact.getContacts();\r\n    while (contactIterator.hasNext()) {\r\n        Contact contact = contactIterator.next();\r\n        if (phones.containsKey(contact))\r\n            continue;\r\n        List<String> phones = getPhones(contact, l, false);\r\n        if (phones == null)\r\n            return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.globalshortcut.GlobalShortcutActivator.registerListenerWithProtocolProviderService",
	"Comment": "get all registered protocolproviderservice and set our listener.",
	"Method": "void registerListenerWithProtocolProviderService(){\r\n    Collection<ServiceReference<ProtocolProviderService>> ppsRefs = ServiceUtils.getServiceReferences(bundleContext, ProtocolProviderService.class);\r\n    if (!ppsRefs.isEmpty()) {\r\n        for (ServiceReference<ProtocolProviderService> ppsRef : ppsRefs) {\r\n            ProtocolProviderService pps = bundleContext.getService(ppsRef);\r\n            OperationSetBasicTelephony<?> opSet = pps.getOperationSet(OperationSetBasicTelephony.class);\r\n            if (opSet != null) {\r\n                opSet.addCallListener(globalShortcutService.getCallShortcut());\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.JabberSlickFixture.clearProvider",
	"Comment": "clears the given provider. it means delete existing contacts,existing groups.",
	"Method": "void clearProvider(ProtocolProviderService provider){\r\n    Map<String, OperationSet> supportedOperationSets = provider.getSupportedOperationSets();\r\n    if (supportedOperationSets == null || supportedOperationSets.size() < 1)\r\n        throw new NullPointerException(\"No OperationSet implementations are supported by \" + \"this Jabber implementation. \");\r\n    OperationSetPersistentPresence opSetPersPresence = (OperationSetPersistentPresence) supportedOperationSets.get(OperationSetPersistentPresence.class.getName());\r\n    if (opSetPersPresence == null)\r\n        throw new NullPointerException(\"An implementation of the Jabber service must provide an \" + \"implementation of at least the one of the Presence \" + \"Operation Sets\");\r\n    deleteGroups(opSetPersPresence);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomJabberImpl.fireMessageEvent",
	"Comment": "delivers the specified event to all registered message listeners.",
	"Method": "void fireMessageEvent(EventObject evt){\r\n    Iterable<ChatRoomMessageListener> listeners;\r\n    synchronized (messageListeners) {\r\n        listeners = new ArrayList<ChatRoomMessageListener>(messageListeners);\r\n    }\r\n    for (ChatRoomMessageListener listener : listeners) {\r\n        try {\r\n            if (evt instanceof ChatRoomMessageDeliveredEvent) {\r\n                listener.messageDelivered((ChatRoomMessageDeliveredEvent) evt);\r\n            } else if (evt instanceof ChatRoomMessageReceivedEvent) {\r\n                listener.messageReceived((ChatRoomMessageReceivedEvent) evt);\r\n            } else if (evt instanceof ChatRoomMessageDeliveryFailedEvent) {\r\n                listener.messageDeliveryFailed((ChatRoomMessageDeliveryFailedEvent) evt);\r\n            }\r\n        } catch (Throwable e) {\r\n            logger.error(\"Error delivering multi chat message for \" + listener, e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.CallEvent.isDesktopStreaming",
	"Comment": "returns whether the current event is for video call and desktop streamingone.",
	"Method": "boolean isDesktopStreaming(){\r\n    return isDesktopStreaming;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapServiceImpl.getConfigService",
	"Comment": "returns a reference to a configurationservice implementation currentlyregistered in the bundle context or null if no such implementation wasfound.",
	"Method": "ConfigurationService getConfigService(){\r\n    if (configService == null) {\r\n        ServiceReference confReference = bundleContext.getServiceReference(ConfigurationService.class.getName());\r\n        configService = (ConfigurationService) bundleContext.getService(confReference);\r\n    }\r\n    return configService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.GroupNode.fireNodeInserted",
	"Comment": "notifies all interested listeners that a node has been inserted at thegiven index.",
	"Method": "void fireNodeInserted(int index){\r\n    treeModel.nodesWereInserted(this, new int[] { index });\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.sip.TestOperationSetPersistentPresence.prepareContactList",
	"Comment": "create the contact list. later will be test to be sure that creating is ok",
	"Method": "void prepareContactList(){\r\n    this.fixture.clearProvidersLists();\r\n    Object o = new Object();\r\n    synchronized (o) {\r\n        o.wait(3000);\r\n    }\r\n    String contactList = System.getProperty(SipProtocolProviderServiceLick.CONTACT_LIST_PROPERTY_NAME, null);\r\n    logger.debug(\"The \" + SipProtocolProviderServiceLick.CONTACT_LIST_PROPERTY_NAME + \" property is set to=\" + contactList);\r\n    if (contactList == null || contactList.trim().length() < 6)\r\n        throw new IllegalArgumentException(\"The \" + SipProtocolProviderServiceLick.CONTACT_LIST_PROPERTY_NAME + \" property did not contain a contact list.\");\r\n    StringTokenizer tokenizer = new StringTokenizer(contactList, \" \\n\\t\");\r\n    logger.debug(\"tokens contained by the CL tokenized=\" + tokenizer.countTokens());\r\n    Hashtable<String, List<String>> contactListToCreate = new Hashtable<String, List<String>>();\r\n    while (tokenizer.hasMoreTokens()) {\r\n        String groupUinToken = tokenizer.nextToken();\r\n        int dotIndex = groupUinToken.indexOf(\".\");\r\n        if (dotIndex == -1) {\r\n            throw new IllegalArgumentException(groupUinToken + \" is not a valid Group.UIN token\");\r\n        }\r\n        String groupName = groupUinToken.substring(0, dotIndex);\r\n        String uin = groupUinToken.substring(dotIndex + 1);\r\n        if (groupName.trim().length() < 1 || uin.trim().length() < 4) {\r\n            throw new IllegalArgumentException(groupName + \" or \" + uin + \" are not a valid group name or Gibberish user id.\");\r\n        }\r\n        List<String> uinInThisGroup = contactListToCreate.get(groupName);\r\n        if (uinInThisGroup == null) {\r\n            uinInThisGroup = new ArrayList<String>();\r\n            contactListToCreate.put(groupName, uinInThisGroup);\r\n        }\r\n        uinInThisGroup.add(uin);\r\n    }\r\n    Enumeration<String> newGroupsEnum = contactListToCreate.keys();\r\n    while (newGroupsEnum.hasMoreElements()) {\r\n        String groupName = newGroupsEnum.nextElement();\r\n        logger.debug(\"Will add group \" + groupName);\r\n        this.opSetPersPresence1.createServerStoredContactGroup(opSetPersPresence1.getServerStoredContactListRoot(), groupName);\r\n        ContactGroup newlyCreatedGroup = this.opSetPersPresence1.getServerStoredContactListRoot().getGroup(groupName);\r\n        Iterator<String> contactsToAddToThisGroup = contactListToCreate.get(groupName).iterator();\r\n        while (contactsToAddToThisGroup.hasNext()) {\r\n            String id = contactsToAddToThisGroup.next();\r\n            logger.debug(\"Will add buddy \" + id);\r\n            this.opSetPersPresence1.subscribe(newlyCreatedGroup, id);\r\n        }\r\n    }\r\n    SipSlickFixture.preInstalledBuddyList = contactListToCreate;\r\n}"
}, {
	"Path": "io.lettuce.core.cluster.RedisClusterClient.setPartitions",
	"Comment": "sets the new cluster topology. the partitions are not applied to existing connections.",
	"Method": "void setPartitions(Partitions partitions){\r\n    this.partitions = partitions;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.launchutils.ArgDelegator.handleConcurrentInvocationRequest",
	"Comment": "called when the user has tried to launch a second instance ofsip communicator while a first one was already running. this methodsimply calls its peer method from the argdelegationpeer anddoes nothing if no peer is currently registered.",
	"Method": "void handleConcurrentInvocationRequest(){\r\n    synchronized (recordedArgs) {\r\n        if (uriDelegationPeer != null)\r\n            uriDelegationPeer.handleConcurrentInvocationRequest();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.UINotificationManager.addNotificationListener",
	"Comment": "adds the given uinotificationlistener to the list of listenersthat would be notified on any changes in missed calls count.",
	"Method": "void addNotificationListener(UINotificationListener l){\r\n    synchronized (l) {\r\n        notificationListeners.add(l);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.IrcAccountID.equals",
	"Comment": "equality extended with checking irc server host and port, since differentirc networks can have users with similar names.",
	"Method": "boolean equals(Object obj){\r\n    return super.equals(obj) && this.host.equals(((IrcAccountID) obj).host) && this.port == ((IrcAccountID) obj).port;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.version.VersionImpl.isNightly",
	"Comment": "indicates if this jitsi version corresponds to a nightly buildof a repository snapshot or to an official jitsi release.",
	"Method": "boolean isNightly(){\r\n    return IS_NIGHTLY_BUILD;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.GuiActivator.getMediaService",
	"Comment": "returns an instance of the mediaservice obtained from thebundle context.",
	"Method": "MediaService getMediaService(){\r\n    if (mediaService == null) {\r\n        mediaService = ServiceUtils.getService(bundleContext, MediaService.class);\r\n    }\r\n    return mediaService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.GeneralDialPanel.paintComponent",
	"Comment": "paints the main background image to the background of this dial panel.",
	"Method": "void paintComponent(Graphics g){\r\n    super.paintComponent(g);\r\n    Graphics2D g2 = (Graphics2D) g;\r\n    BufferedImage bgImage = ImageLoader.getImage(ImageLoader.MAIN_WINDOW_BACKGROUND);\r\n    if (bgImage != null) {\r\n        ResourceManagementService r = GuiActivator.getResources();\r\n        boolean isTextureBackground = Boolean.parseBoolean(r.getSettingsString(\"impl.gui.IS_CONTACT_LIST_TEXTURE_BG_ENABLED\"));\r\n        int width = getWidth();\r\n        int height = getHeight();\r\n        if (isTextureBackground) {\r\n            Rectangle rect = new Rectangle(0, 0, bgImage.getWidth(null), bgImage.getHeight(null));\r\n            TexturePaint texture = new TexturePaint(bgImage, rect);\r\n            g2.setPaint(texture);\r\n            g2.fillRect(0, 0, width, height);\r\n        } else {\r\n            g.setColor(new Color(r.getColor(\"contactListBackground\")));\r\n            g.fillRect(0, 0, width, height);\r\n            g2.drawImage(bgImage, width - bgImage.getWidth(), height - bgImage.getHeight(), this);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetDesktopSharingServerJabberImpl.createVideoCall",
	"Comment": "create a new video call and invite the specified callpeer to it.",
	"Method": "Call createVideoCall(String uri,MediaDevice device,Call createVideoCall,Contact callee,MediaDevice device){\r\n    MediaAwareCall<?, ?, ?> call = (MediaAwareCall<?, ?, ?>) super.createVideoCall(callee, device);\r\n    size = ((VideoMediaFormat) call.getDefaultDevice(MediaType.VIDEO).getFormat()).getSize();\r\n    origin = getOriginForMediaDevice(device);\r\n    return call;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.addTypingNotification",
	"Comment": "adds a typing notification message to the conversation panel.",
	"Method": "void addTypingNotification(String typingNotification){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                addTypingNotification(typingNotification);\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    typingNotificationLabel.setText(typingNotification);\r\n    if (typingNotification != null && !typingNotification.equals(\" \"))\r\n        typingNotificationLabel.setIcon(typingIcon);\r\n    else\r\n        typingNotificationLabel.setIcon(null);\r\n    revalidate();\r\n    repaint();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.addTypingNotification",
	"Comment": "adds a typing notification message to the conversation panel.",
	"Method": "void addTypingNotification(String typingNotification){\r\n    addTypingNotification(typingNotification);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.ScreenInformation.isTitleOnScreen",
	"Comment": "checks whether the top edge of the rectangle is contained in any of theavailable screens.",
	"Method": "boolean isTitleOnScreen(Rectangle window){\r\n    final GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();\r\n    boolean leftInside = false;\r\n    boolean rightInside = false;\r\n    Point topLeft = new Point(window.x, window.y);\r\n    Point topRight = new Point(window.x + window.width, window.y);\r\n    for (GraphicsDevice gd : ge.getScreenDevices()) {\r\n        GraphicsConfiguration gc = gd.getDefaultConfiguration();\r\n        if (gc.getBounds().contains(topLeft))\r\n            leftInside = true;\r\n        if (gc.getBounds().contains(topRight))\r\n            rightInside = true;\r\n        if (leftInside && rightInside)\r\n            return true;\r\n    }\r\n    return leftInside && rightInside;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.menus.WritePanelRightButtonMenu.actionPerformed",
	"Comment": "handles the actionevent when one of the menu items is selected.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    JMenuItem menuItem = (JMenuItem) e.getSource();\r\n    String itemText = menuItem.getName();\r\n    if (itemText.equalsIgnoreCase(\"cut\")) {\r\n        this.chatContainer.getCurrentChat().cut();\r\n    } else if (itemText.equalsIgnoreCase(\"copy\")) {\r\n        this.chatContainer.getCurrentChat().copyWriteArea();\r\n    } else if (itemText.equalsIgnoreCase(\"paste\")) {\r\n        this.chatContainer.getCurrentChat().paste();\r\n    } else if (itemText.equalsIgnoreCase(\"service.gui.CLOSE\")) {\r\n        this.chatContainer.getFrame().setVisible(false);\r\n        this.chatContainer.getFrame().dispose();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ContactGroupIcqImpl.setResolved",
	"Comment": "specifies whether or not this contact group is to be considered resolvedagainst the server. note that no actions are to be undertaken againstgroup buddies in this method.",
	"Method": "void setResolved(boolean resolved){\r\n    this.isResolved = resolved;\r\n    this.isPersistent = true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.Logger.reset",
	"Comment": "reinitialize the logging properties and reread the logging configuration.the same rules are used for locating the configuration propertiesas are used at startup. so if the properties containing the log dirlocations have changed, we would read the new configuration.",
	"Method": "void reset(){\r\n    try {\r\n        FileHandler.pattern = null;\r\n        LogManager.getLogManager().reset();\r\n        LogManager.getLogManager().readConfiguration();\r\n    } catch (Exception e) {\r\n        loggerDelegate.log(Level.INFO, \"Failed to reinit logger.\", e);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.UIServiceImpl.setVisible",
	"Comment": "implements setvisible in the uiservice interface. shows orhides the main application window depending on the parametervisible.",
	"Method": "void setVisible(boolean isVisible){\r\n    this.mainFrame.setFrameVisible(isVisible);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.SmileysSelectorBox.mouseExited",
	"Comment": "clears all mouse over effects when the mouse has exited the smiley area.",
	"Method": "void mouseExited(MouseEvent e){\r\n    SmileyMenuItem smileyItem = (SmileyMenuItem) e.getSource();\r\n    this.clearMouseOverEffects(smileyItem);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ProtocolProviderServiceIcqImpl.getRegistrationState",
	"Comment": "returns the state of the registration of this protocol provider",
	"Method": "RegistrationState getRegistrationState(){\r\n    if (getAimConnection() == null || lastRegistrationState == null)\r\n        return RegistrationState.UNREGISTERED;\r\n    return lastRegistrationState;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.AbstractAddrBookContactQuery.fireContactReceived",
	"Comment": "notifies the contactquerylisteners registered with thiscontactquery that a new sourcecontact has beenreceived.",
	"Method": "void fireContactReceived(SourceContact contact){\r\n    synchronized (sourceContacts) {\r\n        sourceContacts.add(contact);\r\n    }\r\n    super.fireContactReceived(contact);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.setPrivateMessagingChat",
	"Comment": "sets the property which identifies whether the chat is private messaging chat or not.",
	"Method": "void setPrivateMessagingChat(boolean isPrivateMessagingChat){\r\n    this.isPrivateMessagingChat = isPrivateMessagingChat;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.SingleCallInProgressPolicy.removeOperationSetBasicTelephonyListener",
	"Comment": "unregisters a specific operationsetbasictelephony from thispolicy in order to have the rules of the latter no longer apply to thecalls created by the former.",
	"Method": "void removeOperationSetBasicTelephonyListener(OperationSetBasicTelephony<? extends ProtocolProviderService> telephony){\r\n    telephony.removeCallListener(listener);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.macosx.MacOSXAddrBookContactQuery.inserted",
	"Comment": "callback method when receiving notifications for inserted items.",
	"Method": "void inserted(long person){\r\n    onPerson(person);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockContact.hashCode",
	"Comment": "returns a hash code value for this instance supported for the benefit ofhashtables.",
	"Method": "int hashCode(){\r\n    return getAddress().hashCode();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.provdisc.dhcp.DHCPProvisioningDiscover.addDiscoveryListener",
	"Comment": "add a listener that will be notified when thediscoverprovisioningurl has finished.",
	"Method": "void addDiscoveryListener(DiscoveryListener listener){\r\n    if (!listeners.contains(listener)) {\r\n        listeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "io.lettuce.core.dynamic.support.ResolvableType.isUnresolvableTypeVariable",
	"Comment": "determine whether the underlying type is a type variable that cannot be resolved through the associated variableresolver.",
	"Method": "boolean isUnresolvableTypeVariable(){\r\n    if (this.type instanceof TypeVariable) {\r\n        if (this.variableResolver == null) {\r\n            return true;\r\n        }\r\n        TypeVariable<?> variable = (TypeVariable<?>) this.type;\r\n        ResolvableType resolved = this.variableResolver.resolveVariable(variable);\r\n        if (resolved == null || resolved.isUnresolvableTypeVariable()) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.simpleaccreg.InitialAccountRegistrationFrame.addAccountRegistrationForm",
	"Comment": "adds a simple account registration form corresponding to the givenaccountregistrationwizard.",
	"Method": "void addAccountRegistrationForm(AccountRegistrationWizard wizard){\r\n    if (!wizard.isSimpleFormEnabled())\r\n        return;\r\n    String preferredWizardName = Resources.getLoginProperty(\"impl.gui.PREFERRED_ACCOUNT_WIZARD\");\r\n    AccountRegistrationPanel accountPanel;\r\n    if (preferredWizardName != null && preferredWizardName.equals(wizard.getClass().getName())) {\r\n        accountPanel = new AccountRegistrationPanel(wizard, true);\r\n        mainAccountsPanel.add(accountPanel, BorderLayout.NORTH);\r\n        mainAccountsPanel.validate();\r\n    } else {\r\n        accountPanel = new AccountRegistrationPanel(wizard, false);\r\n        accountsPanel.add(accountPanel);\r\n        accountsPanel.validate();\r\n    }\r\n    this.registrationForms.add(accountPanel);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatConversationPanel.hyperlinkUpdate",
	"Comment": "opens a link in the default browser when clicked and shows link url in apopup on mouseover.",
	"Method": "void hyperlinkUpdate(HyperlinkEvent e){\r\n    if (e.getEventType() == HyperlinkEvent.EventType.ENTERED) {\r\n        String href = e.getDescription();\r\n        this.isCurrentHrefImg = e.getSourceElement().getName().equals(\"img\");\r\n        this.currentHref = href;\r\n    } else if (e.getEventType() == HyperlinkEvent.EventType.EXITED) {\r\n        this.currentHref = \"\";\r\n        this.isCurrentHrefImg = false;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ServerStoredContactListIcqImpl.createUnresolvedContactGroup",
	"Comment": "creates a non resolved contact group for the specified name. the newlycreated group would be added to the local contact list as any other groupbut when an event is received from the server concerning this group, thenit will be reused and only its isresolved field would be updated insteadof creating the whole group again.",
	"Method": "ContactGroupIcqImpl createUnresolvedContactGroup(String groupName){\r\n    ContactGroupIcqImpl existingGroup = findContactGroup(groupName);\r\n    if (existingGroup != null) {\r\n        return existingGroup;\r\n    }\r\n    List<Buddy> emptyBuddies = new LinkedList<Buddy>();\r\n    ContactGroupIcqImpl newUnresolvedGroup = new ContactGroupIcqImpl(new VolatileGroup(groupName), emptyBuddies, this, false, true);\r\n    this.rootGroup.addSubGroup(newUnresolvedGroup);\r\n    fireGroupEvent(newUnresolvedGroup, ServerStoredGroupEvent.GROUP_CREATED_EVENT);\r\n    return newUnresolvedGroup;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.callhistory.CallHistoryActivator.getResources",
	"Comment": "returns the resourcemanagementservice, through which we willaccess all resources.",
	"Method": "ResourceManagementService getResources(){\r\n    if (resourcesService == null) {\r\n        resourcesService = ServiceUtils.getService(bundleContext, ResourceManagementService.class);\r\n    }\r\n    return resourcesService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.windowscleanshutdown.CleanShutdownActivator.handleNewSystemActivityNotificationsService",
	"Comment": "saves the reference for the service andadd a listener if the desired events are supported. or startthe checking thread otherwise.",
	"Method": "void handleNewSystemActivityNotificationsService(SystemActivityNotificationsService newService){\r\n    sysActivityService = newService;\r\n    if (newService != null)\r\n        newService.addSystemActivityChangeListener(new SystemActivityChangeListener() {\r\n            public void activityChanged(SystemActivityEvent event) {\r\n                if (event.getEventID() == SystemActivityEvent.EVENT_QUERY_ENDSESSION) {\r\n                    System.setProperty(\"org.jitsi.shutdown.SHUTDOWN_TIMEOUT\", \"3000\");\r\n                    getShutdownService().beginShutdown();\r\n                    try {\r\n                        synchronized (this) {\r\n                            synchShutdown.await(1500, TimeUnit.MILLISECONDS);\r\n                        }\r\n                    } catch (Throwable t) {\r\n                    }\r\n                } else if (event.getEventID() == SystemActivityEvent.EVENT_ENDSESSION) {\r\n                    try {\r\n                        synchShutdown.await();\r\n                    } catch (Throwable t) {\r\n                    }\r\n                }\r\n            }\r\n        });\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.windowscleanshutdown.CleanShutdownActivator.handleNewSystemActivityNotificationsService",
	"Comment": "saves the reference for the service andadd a listener if the desired events are supported. or startthe checking thread otherwise.",
	"Method": "void handleNewSystemActivityNotificationsService(SystemActivityNotificationsService newService){\r\n    if (event.getEventID() == SystemActivityEvent.EVENT_QUERY_ENDSESSION) {\r\n        System.setProperty(\"org.jitsi.shutdown.SHUTDOWN_TIMEOUT\", \"3000\");\r\n        getShutdownService().beginShutdown();\r\n        try {\r\n            synchronized (this) {\r\n                synchShutdown.await(1500, TimeUnit.MILLISECONDS);\r\n            }\r\n        } catch (Throwable t) {\r\n        }\r\n    } else if (event.getEventID() == SystemActivityEvent.EVENT_ENDSESSION) {\r\n        try {\r\n            synchShutdown.await();\r\n        } catch (Throwable t) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.IdentityManager.getIdentityString",
	"Comment": "get the current identity string, based on nick, user and host of localuser.",
	"Method": "String getIdentityString(){\r\n    final String currentNick = this.connectionState.getNickname();\r\n    return this.identity.getString(currentNick);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ContactListTreeCellRenderer.paintIcon",
	"Comment": "draw the icon at the specified location. paints this component as anicon.",
	"Method": "void paintIcon(Component c,Graphics g,int x,int y){\r\n    g = g.create();\r\n    try {\r\n        Graphics2D g2 = (Graphics2D) g;\r\n        AntialiasingManager.activateAntialiasing(g2);\r\n        g2.setColor(Color.WHITE);\r\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.8f));\r\n        g2.fillRoundRect(x, y, getIconWidth() - 1, getIconHeight() - 1, 10, 10);\r\n        g2.setColor(Color.DARK_GRAY);\r\n        g2.drawRoundRect(x, y, getIconWidth() - 1, getIconHeight() - 1, 10, 10);\r\n        g2.translate(x + 5, y + 5);\r\n        super.paint(g2);\r\n        g2.translate(x, y);\r\n    } finally {\r\n        g.dispose();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.systray.PopupMessage.setTimeout",
	"Comment": "sets suggested timeout for hiding the popup if not clicked by the user.",
	"Method": "void setTimeout(long timeout){\r\n    this.timeout = timeout;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.InvitationReceivedDialog.actionPerformed",
	"Comment": "handles the actionevent triggered when one user clickson one of the buttons.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    JButton button = (JButton) e.getSource();\r\n    if (button.equals(acceptButton)) {\r\n        if (invitationAdHoc == null)\r\n            GuiActivator.getMUCService().acceptInvitation(invitation);\r\n        else\r\n            try {\r\n                multiUserChatManager.acceptInvitation(invitationAdHoc, multiUserChatAdHocOpSet);\r\n            } catch (OperationFailedException e1) {\r\n                e1.printStackTrace();\r\n            }\r\n    } else if (button.equals(rejectButton)) {\r\n        if (multiUserChatAdHocOpSet == null && invitationAdHoc == null)\r\n            GuiActivator.getMUCService().rejectInvitation(multiUserChatOpSet, invitation, reasonField.getText());\r\n        else\r\n            multiUserChatManager.rejectInvitation(multiUserChatAdHocOpSet, invitationAdHoc, reasonField.getText());\r\n    }\r\n    this.dispose();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.lookandfeel.SIPCommComboBoxUI.paint",
	"Comment": "paints the ui for the given component through the given graphics object.",
	"Method": "void paint(Graphics g,JComponent c){\r\n    AntialiasingManager.activateAntialiasing(g);\r\n    super.paint(g, c);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.chat.ChatRoomDestroyReasonDialog.getDestroyOptions",
	"Comment": "opens a dialog with a fields for the reason and alternate address and returns them.",
	"Method": "String[] getDestroyOptions(){\r\n    final ChatRoomDestroyReasonDialog[] res = new ChatRoomDestroyReasonDialog[1];\r\n    try {\r\n        SwingUtilities.invokeAndWait(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                ResourceManagementService R = DesktopUtilActivator.getResources();\r\n                res[0] = new ChatRoomDestroyReasonDialog(R.getI18NString(\"service.gui.DESTROY_CHATROOM\"), R.getI18NString(\"service.gui.DESTROY_MESSAGE\"));\r\n            }\r\n        });\r\n    } catch (Throwable t) {\r\n        logger.error(\"Error creating dialog\", t);\r\n        return null;\r\n    }\r\n    ChatRoomDestroyReasonDialog reasonDialog = res[0];\r\n    int result = reasonDialog.showDialog();\r\n    String[] destroyOptions = new String[2];\r\n    if (result == MessageDialog.OK_RETURN_CODE) {\r\n        destroyOptions[0] = proccessFieldValues(reasonDialog.getReason());\r\n        destroyOptions[1] = proccessFieldValues(reasonDialog.getAlternateAddress());\r\n    } else {\r\n        destroyOptions = null;\r\n    }\r\n    return destroyOptions;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.chat.ChatRoomDestroyReasonDialog.getDestroyOptions",
	"Comment": "opens a dialog with a fields for the reason and alternate address and returns them.",
	"Method": "String[] getDestroyOptions(){\r\n    ResourceManagementService R = DesktopUtilActivator.getResources();\r\n    res[0] = new ChatRoomDestroyReasonDialog(R.getI18NString(\"service.gui.DESTROY_CHATROOM\"), R.getI18NString(\"service.gui.DESTROY_MESSAGE\"));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.MUCActivator.getResources",
	"Comment": "returns a reference to the resourcemanagementservice implementationcurrently registered in the bundle context or null if no suchimplementation was found.",
	"Method": "ResourceManagementService getResources(){\r\n    if (resources == null) {\r\n        resources = ServiceUtils.getService(bundleContext, ResourceManagementService.class);\r\n    }\r\n    return resources;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.geolocation.GeolocationPacketExtension.setArea",
	"Comment": "sets the value of a named area such as a campus or neighborhood.",
	"Method": "void setArea(String area){\r\n    this.area = area;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.UserSearchManager.getAvailableServiceNames",
	"Comment": "returns a list with the available user search service names for a givenprovider.",
	"Method": "List<String> getAvailableServiceNames(ProtocolProviderServiceJabberImpl provider){\r\n    final List<String> searchServices = new ArrayList<String>();\r\n    ScServiceDiscoveryManager discoManager = provider.getDiscoveryManager();\r\n    DiscoverItems items;\r\n    try {\r\n        items = discoManager.discoverItems(provider.getConnection().getServiceName());\r\n    } catch (XMPPException e) {\r\n        return searchServices;\r\n    }\r\n    Iterator<DiscoverItems.Item> iter = items.getItems();\r\n    while (iter.hasNext()) {\r\n        DiscoverItems.Item item = iter.next();\r\n        try {\r\n            DiscoverInfo info;\r\n            info = discoManager.discoverInfo(item.getEntityID());\r\n            if (info.containsFeature(\"jabber:iq:search\") && !info.containsFeature(\"http://jabber.org/protocol/muc\")) {\r\n                searchServices.add(item.getEntityID());\r\n            }\r\n        } catch (Exception e) {\r\n            continue;\r\n        }\r\n    }\r\n    return searchServices;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.account.LoginManager.handleProviderRemoved",
	"Comment": "removes all ui components related to the given protocol provider.",
	"Method": "void handleProviderRemoved(ProtocolProviderService protocolProvider){\r\n    loginRenderer.removeProtocolProviderUI(protocolProvider);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.SmileysSelectorBox.mouseEntered",
	"Comment": "changes the static image of the underlying smiley with a dynamic one.also shows the description and smiley string in the description area.",
	"Method": "void mouseEntered(MouseEvent e){\r\n    SmileyMenuItem smileyItem = (SmileyMenuItem) e.getSource();\r\n    Smiley smiley = smileyItem.smiley;\r\n    ImageIcon imageIcon = GuiActivator.getResources().getImage(smiley.getImageID());\r\n    smileyItem.setIcon(imageIcon);\r\n    smileyDescriptionLabel.setText(smiley.getDescription());\r\n    smileyTextLabel.setText(\"<html>\" + smiley.getDefaultString() + \"<\/html>\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.callhistory.CallHistoryContactSource.getType",
	"Comment": "returns default type to indicate that this contact source can be queriedby default filters.",
	"Method": "int getType(){\r\n    return HISTORY_TYPE;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.VCardTempXUpdatePresenceExtension.updateImage",
	"Comment": "updates the avatar image manged by this presence extension.",
	"Method": "boolean updateImage(byte[] imageBytes){\r\n    boolean isImageUpdated = false;\r\n    String tmpImageSha1 = VCardTempXUpdatePresenceExtension.getImageSha1(imageBytes);\r\n    if (tmpImageSha1 != imageSha1) {\r\n        imageSha1 = tmpImageSha1;\r\n        this.computeXML();\r\n        isImageUpdated = true;\r\n    }\r\n    return isImageUpdated;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetWhiteboardingJabberImpl.fireWhiteboardSessionPresenceEvent",
	"Comment": "delivers a whiteboardsessionpresencechangeevent to allregistered whiteboardsessionpresencechangeevents.",
	"Method": "void fireWhiteboardSessionPresenceEvent(WhiteboardSession session,String eventType,String reason){\r\n    WhiteboardSessionPresenceChangeEvent evt = new WhiteboardSessionPresenceChangeEvent(this, session, eventType, reason);\r\n    Iterable<WhiteboardSessionPresenceListener> listeners;\r\n    synchronized (presenceListeners) {\r\n        listeners = new ArrayList<WhiteboardSessionPresenceListener>(presenceListeners);\r\n    }\r\n    for (WhiteboardSessionPresenceListener listener : listeners) listener.whiteboardSessionPresenceChanged(evt);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.TransportManager.getStreamConnector",
	"Comment": "returns the streamconnector instance that this media handlershould use for streams of the specified mediatype. the methodwould also create a new streamconnector if no connector hasbeen initialized for this mediatype yet or in case oneof its underlying sockets has been closed.",
	"Method": "StreamConnector getStreamConnector(MediaType mediaType){\r\n    int streamConnectorIndex = mediaType.ordinal();\r\n    StreamConnector streamConnector = streamConnectors[streamConnectorIndex];\r\n    if ((streamConnector == null) || (streamConnector.getProtocol() == StreamConnector.Protocol.UDP)) {\r\n        DatagramSocket controlSocket;\r\n        if ((streamConnector == null) || streamConnector.getDataSocket().isClosed() || (((controlSocket = streamConnector.getControlSocket()) != null) && controlSocket.isClosed())) {\r\n            streamConnectors[streamConnectorIndex] = streamConnector = createStreamConnector(mediaType);\r\n        }\r\n    } else if (streamConnector.getProtocol() == StreamConnector.Protocol.TCP) {\r\n        Socket controlTCPSocket;\r\n        if (streamConnector.getDataTCPSocket().isClosed() || (((controlTCPSocket = streamConnector.getControlTCPSocket()) != null) && controlTCPSocket.isClosed())) {\r\n            streamConnectors[streamConnectorIndex] = streamConnector = createStreamConnector(mediaType);\r\n        }\r\n    }\r\n    return streamConnector;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.SourceUIContact.getInternationalizedLabels",
	"Comment": "returns a collection of internationalized string corresponding to thegiven subcategories.",
	"Method": "Collection<String> getInternationalizedLabels(Iterator<ContactDetail.SubCategory> subCategories){\r\n    Collection<String> labels = new LinkedList<String>();\r\n    while (subCategories.hasNext()) {\r\n        labels.add(getInternationalizedLabel(subCategories.next()));\r\n    }\r\n    return labels;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetMultiUserChatJabberImpl.getXmppConnection",
	"Comment": "almost all multiuserchat methods require an xmpp connectionparam so i added this method only for the sake of utility.",
	"Method": "Connection getXmppConnection(){\r\n    return (jabberProvider == null) ? null : jabberProvider.getConnection();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.MetaContactRightButtonMenu.getContactFromMetaContact",
	"Comment": "obtains the contact corresponding to the given addressidentifier.",
	"Method": "Contact getContactFromMetaContact(String itemID){\r\n    Iterator<Contact> i = metaContact.getContacts();\r\n    while (i.hasNext()) {\r\n        Contact contact = i.next();\r\n        String id = contact.getAddress() + contact.getProtocolProvider().getProtocolName();\r\n        if (itemID.equals(id)) {\r\n            return contact;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ModeParser.parse",
	"Comment": "parse a complete mode string and extract individual mode entries.",
	"Method": "void parse(String modestring){\r\n    Boolean addition = null;\r\n    for (char c : modestring.toCharArray()) {\r\n        switch(c) {\r\n            case '+':\r\n                addition = true;\r\n                break;\r\n            case '-':\r\n                addition = false;\r\n                break;\r\n            default:\r\n                if (addition == null) {\r\n                    throw new IllegalStateException(\"expect modifier (+ or -) first\");\r\n                }\r\n                try {\r\n                    ModeEntry entry = process(addition, c);\r\n                    modes.add(entry);\r\n                } catch (ArrayIndexOutOfBoundsException e) {\r\n                    throw new IllegalArgumentException(\"invalid mode string \" + \"provided: parameter missing\", e);\r\n                }\r\n                break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.GlobalStatusSelectorBox.actionPerformed",
	"Comment": "handles the actionevent triggered when one of the itemsin the list is selected.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    JMenuItem menuItem = (JMenuItem) e.getSource();\r\n    String itemName = menuItem.getName();\r\n    if (GuiActivator.getGlobalStatusService() != null) {\r\n        GuiActivator.getGlobalStatusService().publishStatus(GlobalStatusEnum.getStatusByName(itemName));\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.macosx.MacOSXAddrBookContactQuery.parseMultiDetails",
	"Comment": "parses the multi value data resulting it in contact details.",
	"Method": "void parseMultiDetails(List<ContactDetail> contactDetails,Object[] multiValue,int property,String label,String id){\r\n    if (multiValue == null)\r\n        return;\r\n    for (int multiValueIndex = 0; multiValueIndex < multiValue.length; multiValueIndex += 2) {\r\n        Object subValue = multiValue[multiValueIndex];\r\n        if (subValue instanceof String) {\r\n            String stringSubValue = (String) subValue;\r\n            if (stringSubValue.length() != 0) {\r\n                if (kABPhoneProperty == property) {\r\n                    stringSubValue = AddrBookActivator.getPhoneNumberI18nService().normalize(stringSubValue);\r\n                }\r\n                Object l = multiValue[multiValueIndex + 1];\r\n                contactDetails.add(setCapabilities(createContactDetail(property, stringSubValue, l, label, id), property));\r\n            }\r\n        } else if (subValue instanceof Object[]) {\r\n            String l = null;\r\n            Object lObject = multiValue[multiValueIndex + 1];\r\n            if (lObject instanceof String)\r\n                l = (String) lObject;\r\n            parseMultiDetails(contactDetails, (Object[]) subValue, property, l, id);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.gibberish.GibberishSlickFixture.setUp",
	"Comment": "initializes protocol provider references and whatever else there is toinitialize.",
	"Method": "void setUp(){\r\n    ServiceReference[] serRefs = null;\r\n    String osgiFilter = \"(\" + ProtocolProviderFactory.PROTOCOL + \"=Gibberish)\";\r\n    try {\r\n        serRefs = bc.getServiceReferences(ProtocolProviderFactory.class.getName(), osgiFilter);\r\n    } catch (InvalidSyntaxException ex) {\r\n        fail(osgiFilter + \" is not a valid osgi filter\");\r\n    }\r\n    assertTrue(\"Failed to find a provider factory service for protocol Gibberish\", (serRefs != null) && (serRefs.length > 0));\r\n    providerFactory = (ProtocolProviderFactory) bc.getService(serRefs[0]);\r\n    userID1 = System.getProperty(GibberishProtocolProviderServiceLick.ACCOUNT_1_PREFIX + ProtocolProviderFactory.USER_ID);\r\n    userID2 = System.getProperty(GibberishProtocolProviderServiceLick.ACCOUNT_2_PREFIX + ProtocolProviderFactory.USER_ID);\r\n    ServiceReference[] gibberishProvider1Refs = bc.getServiceReferences(ProtocolProviderService.class.getName(), \"(&\" + \"(\" + ProtocolProviderFactory.PROTOCOL + \"=Gibberish)\" + \"(\" + ProtocolProviderFactory.USER_ID + \"=\" + userID1 + \")\" + \")\");\r\n    assertNotNull(\"No Protocol Provider was found for Gibberish account1:\" + userID1, gibberishProvider1Refs);\r\n    assertTrue(\"No Protocol Provider was found for Gibberish account1:\" + userID1, gibberishProvider1Refs.length > 0);\r\n    ServiceReference[] gibberishProvider2Refs = bc.getServiceReferences(ProtocolProviderService.class.getName(), \"(&\" + \"(\" + ProtocolProviderFactory.PROTOCOL + \"=Gibberish)\" + \"(\" + ProtocolProviderFactory.USER_ID + \"=\" + userID2 + \")\" + \")\");\r\n    assertNotNull(\"No Protocol Provider was found for Gibberish account2:\" + userID2, gibberishProvider2Refs);\r\n    assertTrue(\"No Protocol Provider was found for Gibberish account2:\" + userID2, gibberishProvider2Refs.length > 0);\r\n    provider1ServiceRef = gibberishProvider1Refs[0];\r\n    provider1 = (ProtocolProviderService) bc.getService(provider1ServiceRef);\r\n    provider2ServiceRef = gibberishProvider2Refs[0];\r\n    provider2 = (ProtocolProviderService) bc.getService(provider2ServiceRef);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.globaldisplaydetails.GlobalDisplayDetailsImpl.fireGlobalAvatarEvent",
	"Comment": "notifies all interested listeners of a global display details change.",
	"Method": "void fireGlobalAvatarEvent(byte[] avatar){\r\n    List<GlobalDisplayDetailsListener> listeners;\r\n    synchronized (displayDetailsListeners) {\r\n        listeners = Collections.unmodifiableList(displayDetailsListeners);\r\n    }\r\n    Iterator<GlobalDisplayDetailsListener> listIter = listeners.iterator();\r\n    while (listIter.hasNext()) {\r\n        listIter.next().globalDisplayAvatarChanged(new GlobalAvatarChangeEvent(this, avatar));\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.systray.PopupMessage.getTimeout",
	"Comment": "returns suggested timeout value in ms for hiding the popup if not clickedby the user.",
	"Method": "long getTimeout(){\r\n    return timeout;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetPresenceSipImpl.unsubscribeToAllEventSubscribers",
	"Comment": "unsubscribe to every event we have subscribes, as it is done normallyon exit or logout do it silently if it fails.",
	"Method": "void unsubscribeToAllEventSubscribers(){\r\n    if (this.watcherInfoSubscriber != null) {\r\n        try {\r\n            watcherInfoSubscriber.unsubscribe(parentProvider.getRegistrarConnection().getAddressOfRecord(), false);\r\n        } catch (Throwable ex) {\r\n            logger.error(\"Failed to send the unsubscription \" + \"for watcher info.\", ex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.AbstractCallPeerJabberGTalkImpl.getContact",
	"Comment": "returns the contact corresponding to this peer or null if noparticular contact has been associated.",
	"Method": "Contact getContact(){\r\n    OperationSetPresence presence = getProtocolProvider().getOperationSet(OperationSetPresence.class);\r\n    return (presence == null) ? null : presence.findContactByID(getAddress());\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.loggingutils.LoggingConfigForm.collectLogs",
	"Comment": "asks user for a location to save logs by poping up a file chooser.and archiving logs and saving them on the specified location.",
	"Method": "void collectLogs(){\r\n    ResourceManagementService resources = LoggingUtilsActivator.getResourceService();\r\n    SipCommFileChooser fileChooser = GenericFileDialog.create(null, resources.getI18NString(\"plugin.loggingutils.ARCHIVE_FILECHOOSE_TITLE\"), SipCommFileChooser.SAVE_FILE_OPERATION);\r\n    fileChooser.setSelectionMode(SipCommFileChooser.SAVE_FILE_OPERATION);\r\n    String defaultDir = \"\";\r\n    try {\r\n        defaultDir = LoggingUtilsActivator.getFileAccessService().getDefaultDownloadDirectory().getAbsolutePath() + File.separator;\r\n    } catch (IOException ex) {\r\n    }\r\n    fileChooser.setStartPath(defaultDir + LogsCollector.getDefaultFileName());\r\n    File dest = fileChooser.getFileFromDialog();\r\n    if (dest == null)\r\n        return;\r\n    dest = LogsCollector.collectLogs(dest, null);\r\n    NotificationService notificationService = LoggingUtilsActivator.getNotificationService();\r\n    if (notificationService != null) {\r\n        String bodyMsgKey = (dest == null) ? \"plugin.loggingutils.ARCHIVE_MESSAGE_NOTOK\" : \"plugin.loggingutils.ARCHIVE_MESSAGE_OK\";\r\n        notificationService.fireNotification(LOGFILES_ARCHIVED, resources.getI18NString(\"plugin.loggingutils.ARCHIVE_BUTTON\"), resources.getI18NString(bodyMsgKey, new String[] { dest.getAbsolutePath() }), null);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapPersonFoundImpl.getDepartment",
	"Comment": "returns the department found in the the directory for this person",
	"Method": "String getDepartment(){\r\n    return this.department;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.callhistory.CallHistoryQueryImpl.addQueryListener",
	"Comment": "adds the given callhistoryquerylistener to the list oflisteners interested in query result changes.",
	"Method": "void addQueryListener(CallHistoryQueryListener l){\r\n    synchronized (queryListeners) {\r\n        queryListeners.add(l);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ChatRoomConferenceCallsListPanel.getSelectedValue",
	"Comment": "returns the conferencedescription of the selected conference in the list.",
	"Method": "ConferenceDescription getSelectedValue(){\r\n    return (ConferenceDescription) conferenceCallList.getSelectedValue();\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.account.AccountUtils.getProtocolProviderFactory",
	"Comment": "returns a protocolproviderfactory for a given protocolprovider.",
	"Method": "ProtocolProviderFactory getProtocolProviderFactory(ProtocolProviderService protocolProvider,ProtocolProviderFactory getProtocolProviderFactory,String protocolName){\r\n    String osgiFilter = \"(\" + ProtocolProviderFactory.PROTOCOL + \"=\" + protocolName + \")\";\r\n    ProtocolProviderFactory protocolProviderFactory = null;\r\n    try {\r\n        Collection<ServiceReference<ProtocolProviderFactory>> refs = UtilActivator.bundleContext.getServiceReferences(ProtocolProviderFactory.class, osgiFilter);\r\n        if ((refs != null) && !refs.isEmpty()) {\r\n            protocolProviderFactory = UtilActivator.bundleContext.getService(refs.iterator().next());\r\n        }\r\n    } catch (InvalidSyntaxException ex) {\r\n        logger.error(\"AccountUtils : \" + ex);\r\n    }\r\n    return protocolProviderFactory;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.GenericUIContactImpl.getContactNode",
	"Comment": "returns the corresponding contactnode from the contact listcomponent.",
	"Method": "ContactNode getContactNode(){\r\n    return contactNode;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.ChatRoomSourceContact.getChatRoomStateByName",
	"Comment": "checks if the chat room associated with the contact is joined or not andreturns it presence status.",
	"Method": "PresenceStatus getChatRoomStateByName(){\r\n    for (ChatRoom room : getProvider().getOperationSet(OperationSetMultiUserChat.class).getCurrentlyJoinedChatRooms()) {\r\n        if (room.getName().equals(getChatRoomName())) {\r\n            return ChatRoomPresenceStatus.CHAT_ROOM_ONLINE;\r\n        }\r\n    }\r\n    return ChatRoomPresenceStatus.CHAT_ROOM_OFFLINE;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.ChatRoomProviderWrapperImpl.getProtocolProvider",
	"Comment": "returns the protocol provider service corresponding to this serverwrapper.",
	"Method": "ProtocolProviderService getProtocolProvider(){\r\n    return protocolProvider;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.presence.AbstractStatusMessageMenu.getLastCustomMessageIndex",
	"Comment": "checks for the index of the last component of custommessageitems class.",
	"Method": "int getLastCustomMessageIndex(){\r\n    int ix = -1;\r\n    for (int i = 0; i < getMenuComponentCount(); i++) {\r\n        Object c = getMenuComponent(i);\r\n        if (c instanceof CustomMessageItems) {\r\n            if (i > ix)\r\n                ix = i;\r\n        }\r\n    }\r\n    return ix;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.AbstractOperationSetTelephonyConferencing.callBegun",
	"Comment": "notifies this calllistener that a specific call hasbeen established.",
	"Method": "void callBegun(CallEvent event){\r\n    Call call = event.getSourceCall();\r\n    call.addCallChangeListener(this);\r\n    Iterator<? extends CallPeer> callPeerIter = call.getCallPeers();\r\n    while (callPeerIter.hasNext()) {\r\n        callPeerAdded(new CallPeerEvent(callPeerIter.next(), call, CallPeerEvent.CALL_PEER_ADDED));\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapPersonFoundImpl.setDepartment",
	"Comment": "sets the department found in the the directory for this person",
	"Method": "void setDepartment(String department){\r\n    this.department = department;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.IcqActivator.getBundleContext",
	"Comment": "returns a reference to the bundle context that we were started with.",
	"Method": "BundleContext getBundleContext(){\r\n    return bundleContext;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.sip.SipSlickFixture.clearProvidersLists",
	"Comment": "removes all contact groups and contacts currently recorded by thepresence operation set of the sip providers we are using.",
	"Method": "void clearProvidersLists(){\r\n    Map<String, OperationSet> supportedOperationSets1 = provider1.getSupportedOperationSets();\r\n    if (supportedOperationSets1 == null || supportedOperationSets1.size() < 1)\r\n        throw new NullPointerException(\"No OperationSet implementations are supported by \" + \"this Sip implementation. \");\r\n    OperationSetPersistentPresence opSetPersPresence1 = (OperationSetPersistentPresence) supportedOperationSets1.get(OperationSetPersistentPresence.class.getName());\r\n    if (opSetPersPresence1 == null)\r\n        throw new NullPointerException(\"An implementation of the Sip service must provide an \" + \"implementation of at least the one of the Presence \" + \"Operation Sets\");\r\n    Map<String, OperationSet> supportedOperationSets2 = provider2.getSupportedOperationSets();\r\n    if (supportedOperationSets2 == null || supportedOperationSets2.size() < 1)\r\n        throw new NullPointerException(\"No OperationSet implementations are supported by \" + \"this Jabber implementation. \");\r\n    OperationSetPersistentPresence opSetPersPresence2 = (OperationSetPersistentPresence) supportedOperationSets2.get(OperationSetPersistentPresence.class.getName());\r\n    if (opSetPersPresence2 == null)\r\n        throw new NullPointerException(\"An implementation of the Sip service must provide an \" + \"implementation of at least the one of the Presence \" + \"Operation Sets\");\r\n    ContactGroup rootGroup1 = opSetPersPresence1.getServerStoredContactListRoot();\r\n    Object lock = new Object();\r\n    Iterator<ContactGroup> cgiter = rootGroup1.subgroups();\r\n    while (cgiter.hasNext()) {\r\n        ContactGroup item = cgiter.next();\r\n        opSetPersPresence1.removeServerStoredContactGroup(item);\r\n        synchronized (lock) {\r\n            lock.wait(1000);\r\n        }\r\n        cgiter = rootGroup1.subgroups();\r\n    }\r\n    Iterator<Contact> citer = rootGroup1.contacts();\r\n    while (citer.hasNext()) {\r\n        opSetPersPresence1.unsubscribe(citer.next());\r\n        synchronized (lock) {\r\n            lock.wait(1000);\r\n        }\r\n        citer = rootGroup1.contacts();\r\n    }\r\n    ContactGroup rootGroup2 = opSetPersPresence2.getServerStoredContactListRoot();\r\n    cgiter = rootGroup2.subgroups();\r\n    while (cgiter.hasNext()) {\r\n        ContactGroup item = cgiter.next();\r\n        synchronized (lock) {\r\n            lock.wait(1000);\r\n        }\r\n        opSetPersPresence2.removeServerStoredContactGroup(item);\r\n    }\r\n    citer = rootGroup2.contacts();\r\n    while (citer.hasNext()) {\r\n        opSetPersPresence2.unsubscribe(citer.next());\r\n        synchronized (lock) {\r\n            lock.wait(1000);\r\n        }\r\n        citer = rootGroup2.contacts();\r\n    }\r\n    synchronized (lock) {\r\n        lock.wait(5000);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.common.test.BlockheadConnection.setInitialBuffer",
	"Comment": "extra bytes from the initial http upgrade that need tobe processed by the websocket parser before startingto read bytes from the connection",
	"Method": "void setInitialBuffer(ByteBuffer prefilled){\r\n    if (LOG.isDebugEnabled()) {\r\n        LOG.debug(\"set Initial Buffer - {}\", BufferUtil.toDetailString(prefilled));\r\n    }\r\n    if ((prefilled != null) && (prefilled.hasRemaining())) {\r\n        networkBuffer = bufferPool.acquire(prefilled.remaining(), true);\r\n        BufferUtil.clearToFill(networkBuffer);\r\n        BufferUtil.put(prefilled, networkBuffer);\r\n        BufferUtil.flipToFlush(networkBuffer, 0);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetPresenceSipImpl.getLocalContactForDst",
	"Comment": "returns the protocol specific contact instance representing the localuser.",
	"Method": "ContactSipImpl getLocalContactForDst(ContactSipImpl destination,ContactSipImpl getLocalContactForDst,Address destination){\r\n    Address sipAddress = parentProvider.getOurSipAddress(destination);\r\n    ContactSipImpl res = new ContactSipImpl(sipAddress, this.parentProvider);\r\n    res.setPresenceStatus(this.presenceStatus);\r\n    return res;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ContactListModel.isContactOnline",
	"Comment": "returns true if the given meta contact is online, false otherwise.",
	"Method": "boolean isContactOnline(MetaContact contact){\r\n    Contact defaultContact = contact.getDefaultContact();\r\n    if (defaultContact == null)\r\n        return false;\r\n    return defaultContact.getPresenceStatus().getStatus() >= PresenceStatus.ONLINE_THRESHOLD;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetPersistentPresenceJabberImpl.assertConnected",
	"Comment": "utility method throwing an exception if the stack is not properlyinitialized.",
	"Method": "void assertConnected(){\r\n    if (parentProvider == null) {\r\n        throw new IllegalStateException(\"The provider must be non-null and signed on the\" + \" Jabber service before being able to\" + \" communicate.\");\r\n    }\r\n    if (!parentProvider.isRegistered()) {\r\n        if ((currentStatus != null) && currentStatus.isOnline()) {\r\n            fireProviderStatusChangeEvent(currentStatus, parentProvider.getJabberStatusEnum().getStatus(JabberStatusEnum.OFFLINE));\r\n        }\r\n        throw new IllegalStateException(\"The provider must be signed on the Jabber service\" + \" before being able to communicate.\");\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.ChatRoomListImpl.addChatRoomProviderWrapperListener",
	"Comment": "adds a chatroomproviderwrapperlistener to the listener list.",
	"Method": "void addChatRoomProviderWrapperListener(ChatRoomProviderWrapperListener listener){\r\n    providerChangeListeners.add(listener);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.colibri.ColibriConferenceIQ.setGracefulShutdown",
	"Comment": "sets whether this iq should contain the information about gracefulshutdown in progress status.",
	"Method": "void setGracefulShutdown(boolean isGracefulShutdown){\r\n    this.gracefulShutdown = isGracefulShutdown;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.GenericEvent.getSourceProvider",
	"Comment": "returns the protocolproviderservice which originated this event.",
	"Method": "ProtocolProviderService getSourceProvider(){\r\n    return (ProtocolProviderService) getSource();\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.FTPUtils.getResponseCode",
	"Comment": "reads the response messages from the ftp server andreturns the response code.",
	"Method": "String getResponseCode(){\r\n    String line;\r\n    while ((line = readLine()).charAt(3) != ' ') ;\r\n    return line.substring(0, 3);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.systray.AbstractPopupMessageHandler.removePopupMessageListener",
	"Comment": "removes a systraypopupmessagelistener from this instance so thatit no longer receives systraypopupmessageevents.",
	"Method": "void removePopupMessageListener(SystrayPopupMessageListener listener){\r\n    synchronized (popupMessageListeners) {\r\n        popupMessageListeners.remove(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MclStorageManager.updatePersistentDataForMetaContact",
	"Comment": "update persistent data in the dom object model for the given metacontactand its contacts",
	"Method": "void updatePersistentDataForMetaContact(MetaContact metaContact){\r\n    Element metaContactNode = findMetaContactNode(metaContact.getMetaUID());\r\n    Iterator<Contact> iter = metaContact.getContacts();\r\n    while (iter.hasNext()) {\r\n        Contact item = iter.next();\r\n        String persistentData = item.getPersistentData();\r\n        if (persistentData != null) {\r\n            Element currentNode = XMLUtils.locateElement(metaContactNode, PROTO_CONTACT_NODE_NAME, PROTO_CONTACT_ADDRESS_ATTR_NAME, item.getAddress());\r\n            Element persistentDataNode = XMLUtils.findChild(currentNode, PERSISTENT_DATA_NODE_NAME);\r\n            if (persistentDataNode == null) {\r\n                persistentDataNode = contactListDocument.createElement(PERSISTENT_DATA_NODE_NAME);\r\n                currentNode.appendChild(persistentDataNode);\r\n            }\r\n            XMLUtils.setText(persistentDataNode, persistentData);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.ContactResourceEvent.getContactResource",
	"Comment": "returns the contactresource that is concerned by the change.",
	"Method": "ContactResource getContactResource(){\r\n    return contactResource;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.chatalerter.ChatAlerterActivator.handleProviderAdded",
	"Comment": "used to attach the alerter plugin to existing orjust registered protocol provider. checks if the provider has implementationof operationsetbasicinstantmessaging",
	"Method": "void handleProviderAdded(ProtocolProviderService provider){\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Adding protocol provider \" + provider.getProtocolName());\r\n    OperationSetBasicInstantMessaging opSetIm = provider.getOperationSet(OperationSetBasicInstantMessaging.class);\r\n    if (opSetIm != null) {\r\n        opSetIm.addMessageListener(this);\r\n    } else {\r\n        if (logger.isTraceEnabled())\r\n            logger.trace(\"Service did not have a im op. set.\");\r\n    }\r\n    OperationSetSmsMessaging opSetSms = provider.getOperationSet(OperationSetSmsMessaging.class);\r\n    if (opSetSms != null) {\r\n        opSetSms.addMessageListener(this);\r\n    } else {\r\n        if (logger.isTraceEnabled())\r\n            logger.trace(\"Service did not have a sms op. set.\");\r\n    }\r\n    OperationSetMultiUserChat opSetMultiUChat = provider.getOperationSet(OperationSetMultiUserChat.class);\r\n    if (opSetMultiUChat != null) {\r\n        for (ChatRoom room : opSetMultiUChat.getCurrentlyJoinedChatRooms()) room.addMessageListener(this);\r\n        opSetMultiUChat.addPresenceListener(this);\r\n    } else {\r\n        if (logger.isTraceEnabled())\r\n            logger.trace(\"Service did not have a multi im op. set.\");\r\n    }\r\n    OperationSetBasicTelephony<?> basicTelephonyOpSet = provider.getOperationSet(OperationSetBasicTelephony.class);\r\n    if (basicTelephonyOpSet != null) {\r\n        basicTelephonyOpSet.addCallListener(this);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetPersistentPresenceIcqImpl.publishPresenceStatus",
	"Comment": "requests the provider to enter into a status corresponding to thespecified paramters. note that calling this method does not necessarilyimply that the requested status would be entered. this method wouldreturn right after being called and the caller should add itself asa listener to this class in order to get notified when the state hasactually changed.",
	"Method": "void publishPresenceStatus(PresenceStatus status,String statusMessage){\r\n    assertConnected();\r\n    if (!(status instanceof IcqStatusEnum || status instanceof AimStatusEnum))\r\n        throw new IllegalArgumentException(status + \" is not a valid ICQ/AIM status\");\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Will set status: \" + status);\r\n    MainBosService bosService = parentProvider.getAimConnection().getBosService();\r\n    if (!parentProvider.USING_ICQ) {\r\n        if (status.equals(AimStatusEnum.AWAY)) {\r\n            if (getPresenceStatus().equals(AimStatusEnum.INVISIBLE))\r\n                bosService.setVisibleStatus(true);\r\n            bosService.getOscarConnection().sendSnac(new SetInfoCmd(new InfoData(null, \"I'm away!\", null, null)));\r\n        } else if (status.equals(AimStatusEnum.INVISIBLE)) {\r\n            if (getPresenceStatus().equals(AimStatusEnum.AWAY))\r\n                bosService.getOscarConnection().sendSnac(new SetInfoCmd(new InfoData(null, InfoData.NOT_AWAY, null, null)));\r\n            bosService.setVisibleStatus(false);\r\n        } else if (status.equals(AimStatusEnum.ONLINE)) {\r\n            if (getPresenceStatus().equals(AimStatusEnum.INVISIBLE))\r\n                bosService.setVisibleStatus(true);\r\n            else if (getPresenceStatus().equals(AimStatusEnum.AWAY)) {\r\n                bosService.getOscarConnection().sendSnac(new SetInfoCmd(new InfoData(null, InfoData.NOT_AWAY, null, null)));\r\n            }\r\n        }\r\n    } else {\r\n        long icqStatus = presenceStatusToStatusLong(status);\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Will set status: \" + status + \" long=\" + icqStatus);\r\n        bosService.getOscarConnection().sendSnac(new SetExtraInfoCmd(icqStatus));\r\n        if (status.equals(IcqStatusEnum.AWAY))\r\n            parentProvider.getAimConnection().getInfoService().setAwayMessage(statusMessage);\r\n        else\r\n            bosService.setStatusMessage(statusMessage);\r\n    }\r\n    queryContactStatus(parentProvider.getAimConnection().getScreenname().getFormatted());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.sdp.SdpUtils.extractFormats",
	"Comment": "extracts and returns the list of mediaformats advertised inmediadesc preserving their oder and registering dynamic payloadtype numbers in the specified ptregistry. note that this methodwould only include in the result list mediaformat instances thatare currently supported by our mediaservice implementation andenabled in its configuration. this means that the method could return anempty list even if there were actually some formats in themediadesc if we support none of them or if all these we supportare not enabled in the mediaservice configuration form.",
	"Method": "List<MediaFormat> extractFormats(MediaDescription mediaDesc,DynamicPayloadTypeRegistry ptRegistry){\r\n    List<MediaFormat> mediaFmts = new ArrayList<MediaFormat>();\r\n    Vector<String> formatStrings;\r\n    try {\r\n        formatStrings = mediaDesc.getMedia().getMediaFormats(true);\r\n    } catch (SdpParseException exc) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"A funny thing just happened ...\", exc);\r\n        return mediaFmts;\r\n    }\r\n    float frameRate = -1;\r\n    try {\r\n        String frStr = mediaDesc.getAttribute(\"framerate\");\r\n        if (frStr != null)\r\n            frameRate = Float.parseFloat(frStr);\r\n    } catch (SdpParseException e) {\r\n    }\r\n    for (String ptStr : formatStrings) {\r\n        byte pt;\r\n        try {\r\n            pt = Byte.parseByte(ptStr);\r\n        } catch (NumberFormatException e) {\r\n            if (logger.isDebugEnabled())\r\n                logger.debug(ptStr + \" is not a valid payload type\", e);\r\n            continue;\r\n        }\r\n        Attribute rtpmap = null;\r\n        try {\r\n            rtpmap = findPayloadTypeSpecificAttribute(mediaDesc.getAttributes(false), SdpConstants.RTPMAP, Byte.toString(pt));\r\n        } catch (SdpException e) {\r\n            if (logger.isDebugEnabled()) {\r\n                logger.debug(rtpmap + \" does not seem like a valid rtpmap:\" + \" attribute\", e);\r\n            }\r\n        }\r\n        Attribute fmtp = null;\r\n        try {\r\n            fmtp = findPayloadTypeSpecificAttribute(mediaDesc.getAttributes(false), \"fmtp\", ptStr);\r\n        } catch (SdpException e) {\r\n            if (logger.isDebugEnabled()) {\r\n                logger.debug(fmtp + \" does not seem like a valid fmtp: attribute\", e);\r\n            }\r\n        }\r\n        List<Attribute> advp = null;\r\n        try {\r\n            advp = findAdvancedAttributes(mediaDesc.getAttributes(false), ptStr);\r\n        } catch (SdpException e) {\r\n            if (logger.isDebugEnabled())\r\n                logger.debug(\"Problem parsing advanced attributes\", e);\r\n        }\r\n        MediaFormat mediaFormat = null;\r\n        try {\r\n            mediaFormat = createFormat(pt, rtpmap, fmtp, frameRate, advp, ptRegistry);\r\n        } catch (SdpException e) {\r\n            if (logger.isDebugEnabled())\r\n                logger.debug(\"A funny thing just happened ...\", e);\r\n            continue;\r\n        }\r\n        if (mediaFormat != null) {\r\n            mediaFmts.add(mediaFormat);\r\n        }\r\n    }\r\n    return mediaFmts;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatTransport.isContentTypeSupported",
	"Comment": "determines whether this chat transport supports the supplied content type",
	"Method": "boolean isContentTypeSupported(String contentType){\r\n    return OperationSetBasicInstantMessaging.DEFAULT_MIME_TYPE.equals(contentType);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.ChatRoomQuery.removeQueryFromProviderPresenceListeners",
	"Comment": "removes the query from protocol provider service presence listeners.",
	"Method": "void removeQueryFromProviderPresenceListeners(ProtocolProviderService pps){\r\n    OperationSetMultiUserChat opSetMUC = pps.getOperationSet(OperationSetMultiUserChat.class);\r\n    if (opSetMUC != null) {\r\n        opSetMUC.removePresenceListener(this);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.WhiteboardParticipantEvent.getSourceWhiteboardParticipant",
	"Comment": "returns the whiteboard participant that this event is about.",
	"Method": "WhiteboardParticipant getSourceWhiteboardParticipant(){\r\n    return sourceWhiteboardParticipant;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.UINotificationManager.addNotification",
	"Comment": "adds the given notification to the list of unread notifications andnotifies interested listeners.",
	"Method": "void addNotification(UINotification notification){\r\n    UINotificationGroup group = notification.getGroup();\r\n    if (!notificationGroups.contains(group))\r\n        notificationGroups.add(group);\r\n    group.addNotification(notification);\r\n    fireNotificationEvent(notification);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chatroomslist.joinforms.NewChatRoom.getChatRoomProvider",
	"Comment": "returns the chat room provider corresponding to the chosen account.",
	"Method": "ChatRoomProviderWrapper getChatRoomProvider(){\r\n    return chatRoomProvider;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.MetaUIContact.getSearchStrings",
	"Comment": "returns an iterator over a list of strings, which can be usedto find this contact.",
	"Method": "Iterator<String> getSearchStrings(){\r\n    return searchStrings.iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetTelephonyConferencingSipImpl.requestProcessed",
	"Comment": "notifies this methodprocessorlistener that a specificcallpeer has processed a specific sip request and hasreplied to it with a specific sip response.",
	"Method": "void requestProcessed(CallPeerSipImpl sourceCallPeer,Request request,Response response){\r\n    if (Request.INVITE.equalsIgnoreCase(request.getMethod()) && (response != null) && (Response.OK == response.getStatusCode()))\r\n        inviteCompleted(sourceCallPeer, request, response);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.history.HistoryServiceImpl.escapeCharacters",
	"Comment": "replacing the characters that we must escapeused for the created filename.",
	"Method": "void escapeCharacters(String[] ids){\r\n    for (int i = 0; i < ids.length; i++) {\r\n        String currId = ids[i];\r\n        for (int j = 0; j < ESCAPE_SEQUENCES.length; j++) {\r\n            currId = currId.replaceAll(ESCAPE_SEQUENCES[j][0], ESCAPE_SEQUENCES[j][1]);\r\n        }\r\n        ids[i] = currId;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ContactNode.setActive",
	"Comment": "sets this contact node as active, which indicates it has unread receivedmessages waiting.",
	"Method": "void setActive(boolean isActive){\r\n    this.isActive = isActive;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.utils.ImageLoader.getImage",
	"Comment": "returns the given protocol image with an index allowing to distinguishdifferent accounts from the same protocol.",
	"Method": "BufferedImage getImage(ImageID imageID,Image getImage,Image bgImage,Image topImage,int x,int y,Image getImage,Image bgImage,String text,Component c){\r\n    BufferedImage buffImage = new BufferedImage(bgImage.getWidth(c), bgImage.getHeight(c), BufferedImage.TYPE_INT_ARGB);\r\n    Graphics2D g = (Graphics2D) buffImage.getGraphics();\r\n    AntialiasingManager.activateAntialiasing(g);\r\n    g.setColor(Color.WHITE);\r\n    g.setFont(c.getFont().deriveFont(Font.BOLD, 9));\r\n    g.drawImage(bgImage, 0, 0, null);\r\n    FontMetrics fontMetrics = g.getFontMetrics();\r\n    int fontHeight = fontMetrics.getHeight();\r\n    int textWidth = fontMetrics.stringWidth(text);\r\n    g.drawString(text, (bgImage.getWidth(null) - textWidth) / 2 + 1, (bgImage.getHeight(null) - fontHeight) / 2 + fontHeight - 3);\r\n    return buffImage;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl.createFirstOffer",
	"Comment": "allocates ports, retrieves supported formats and creates asessiondescription.",
	"Method": "SessionDescription createFirstOffer(){\r\n    List<MediaDescription> mediaDescs = createMediaDescriptions();\r\n    String userName = getPeer().getProtocolProvider().getAccountID().getUserID();\r\n    SessionDescription sDes = SdpUtils.createSessionDescription(getTransportManager().getLastUsedLocalHost(), userName, mediaDescs);\r\n    this.localSess = sDes;\r\n    return localSess;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractOperationSetContactCapabilities.removeContactCapabilitiesListener",
	"Comment": "unregisters a specific contactcapabilitieslistener to no longerbe notified about changes in the list of operationsetcapabilities of contacts. if the specified listener hasalready been unregistered or has never been registered, removing it hasno effect.",
	"Method": "void removeContactCapabilitiesListener(ContactCapabilitiesListener listener){\r\n    if (listener != null) {\r\n        synchronized (contactCapabilitiesListeners) {\r\n            contactCapabilitiesListeners.remove(listener);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.EncryptionPacketExtension.getCryptoList",
	"Comment": "returns a reference to the list of crypto elements thatwe have registered with this encryption element so far.",
	"Method": "List<CryptoPacketExtension> getCryptoList(){\r\n    return cryptoList;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.netaddr.NetworkConfigurationWatcher.addNetworkConfigurationChangeListener",
	"Comment": "adds new networkconfigurationchangelistener which willbe informed for network configuration changes.",
	"Method": "void addNetworkConfigurationChangeListener(NetworkConfigurationChangeListener listener){\r\n    eventDispatcher.addNetworkConfigurationChangeListener(listener);\r\n    initialFireEvents(listener);\r\n    NetaddrActivator.getBundleContext().addServiceListener(this);\r\n    if (this.systemActivityNotificationsService == null) {\r\n        SystemActivityNotificationsService systActService = ServiceUtils.getService(NetaddrActivator.getBundleContext(), SystemActivityNotificationsService.class);\r\n        handleNewSystemActivityNotificationsService(systActService);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.AccountManagerEvent.getFactory",
	"Comment": "gets the protocolproviderfactory being worked on at the timethis event has been fired.",
	"Method": "ProtocolProviderFactory getFactory(){\r\n    return factory;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWindowManager.getMultiChat",
	"Comment": "gets the chatpanel corresponding to the specifiedadhocchatroom and optionally creates it if it does not exist.must be executed on the event dispatch thread.",
	"Method": "ChatPanel getMultiChat(ChatRoomWrapper chatRoomWrapper,boolean create,ChatPanel getMultiChat,AdHocChatRoomWrapper chatRoomWrapper,boolean create,ChatPanel getMultiChat,AdHocChatRoom adHocChatRoom,boolean create,ChatPanel getMultiChat,ChatRoom chatRoom,boolean create,ChatPanel getMultiChat,ChatRoom chatRoom,boolean create,String escapedMessageID,ChatPanel getMultiChat,AdHocChatRoom adHocChatRoom,boolean create,String escapedMessageID){\r\n    if (!create)\r\n        return getMultiChatInternal(adHocChatRoom, false, escapedMessageID);\r\n    else\r\n        return new CreateAdHocChatRoomRunner(adHocChatRoom, escapedMessageID).getChatPanel();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ServerStoredContactListXivoImpl.createGroup",
	"Comment": "creates a group with the specified name and parent in the server storedcontact list.",
	"Method": "ContactGroupSipImpl createGroup(ContactGroupSipImpl parentGroup,String groupName,boolean persistent){\r\n    throw new OperationFailedException(\"Modification not supported.\", OperationFailedException.NOT_SUPPORTED_OPERATION);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.TestAccountUninstallationPersistence.testAccountUninstallationPersistency",
	"Comment": "retrieves a reference to the icq bundle, stops it and uninstalls it andthen reinstalls it in order to make sure that accounts are not reloadedonce removed.",
	"Method": "void testAccountUninstallationPersistency(){\r\n    Bundle providerBundle = IcqSlickFixture.providerBundle;\r\n    providerBundle.stop();\r\n    assertTrue(\"Couldn't stop the protocol provider bundle. State was \" + providerBundle.getState(), Bundle.ACTIVE != providerBundle.getState() && Bundle.STOPPING != providerBundle.getState());\r\n    providerBundle.uninstall();\r\n    assertEquals(\"Couldn't stop the protocol provider bundle.\", Bundle.UNINSTALLED, providerBundle.getState());\r\n    providerBundle = IcqSlickFixture.bc.installBundle(providerBundle.getLocation());\r\n    assertEquals(\"Couldn't re-install protocol provider bundle.\", Bundle.INSTALLED, providerBundle.getState());\r\n    AccountManagerUtils.startBundleAndWaitStoredAccountsLoaded(IcqSlickFixture.bc, providerBundle, ProtocolNames.ICQ);\r\n    assertEquals(\"Couldn't re-start protocol provider bundle.\", Bundle.ACTIVE, providerBundle.getState());\r\n    ServiceReference[] icqProviderRefs = null;\r\n    try {\r\n        icqProviderRefs = IcqSlickFixture.bc.getServiceReferences(ProtocolProviderService.class.getName(), \"(\" + ProtocolProviderFactory.PROTOCOL + \"=\" + ProtocolNames.ICQ + \")\");\r\n    } catch (InvalidSyntaxException ex) {\r\n        fail(\"We apparently got our filter wrong \" + ex.getMessage());\r\n    }\r\n    assertTrue(\"A Protocol Provider Service was still regged as an osgi service \" + \"for ICQ UIN:\" + IcqSlickFixture.icqAccountID + \"After it was explicitly uninstalled\", icqProviderRefs == null || icqProviderRefs.length == 0);\r\n    ServiceReference confReference = IcqSlickFixture.bc.getServiceReference(ConfigurationService.class.getName());\r\n    ConfigurationService configurationService = (ConfigurationService) IcqSlickFixture.bc.getService(confReference);\r\n    configurationService.purgeStoredConfiguration();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockContactGroup.findContactByID",
	"Comment": "returns the contact with the specified id or null if no such contactexists.",
	"Method": "MockContact findContactByID(String id){\r\n    Iterator<Contact> contactsIter = contacts();\r\n    while (contactsIter.hasNext()) {\r\n        MockContact mContact = (MockContact) contactsIter.next();\r\n        if (mContact.getAddress().equals(id))\r\n            return mContact;\r\n    }\r\n    Iterator<ContactGroup> groupsIter = subgroups();\r\n    while (groupsIter.hasNext()) {\r\n        MockContactGroup mGroup = (MockContactGroup) groupsIter.next();\r\n        MockContact mContact = mGroup.findContactByID(id);\r\n        if (mContact != null)\r\n            return mContact;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.contactlist.TestSupportForMultipleProviders.suite",
	"Comment": "returns tests in this class in the order that they are supposed to beexecuted.",
	"Method": "Test suite(){\r\n    TestSuite suite = new TestSuite();\r\n    suite.addTest(new TestSupportForMultipleProviders(\"testAddProviders\"));\r\n    suite.addTest(new TestSupportForMultipleProviders(\"testMergingContactsFromDifferentProviders\"));\r\n    return suite;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.skinmanager.SkinManagerActivator.getConfigService",
	"Comment": "returns a reference to a configurationservice implementation currentlyregistered in the bundle context or null if no such implementation wasfound.",
	"Method": "ConfigurationService getConfigService(){\r\n    return ServiceUtils.getService(bundleContext, ConfigurationService.class);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.ZrtpHashPacketExtension.setVersion",
	"Comment": "sets the zrtp version used by the implementation that created thehash.",
	"Method": "void setVersion(String version){\r\n    setAttribute(VERSION_ATTR_NAME, version);\r\n}"
}, {
	"Path": "net.librec.recommender.baseline.MostPopularRecommender.predict",
	"Comment": "the rated count as the predictive ranking score for user useridx on item itemidx.",
	"Method": "double predict(int userIdx,int itemIdx){\r\n    if (!itemPops.containsKey(itemIdx))\r\n        itemPops.put(itemIdx, trainMatrix.column(itemIdx).size());\r\n    return itemPops.get(itemIdx);\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.account.AccountUtils.getAccountForID",
	"Comment": "return the accountid corresponding to the given string accountidentifier.",
	"Method": "AccountID getAccountForID(String accountID){\r\n    Collection<AccountID> allAccounts = getStoredAccounts();\r\n    for (AccountID account : allAccounts) {\r\n        if (account.getAccountUniqueID().equals(accountID))\r\n            return account;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaHandler.requestKeyFrame",
	"Comment": "requests a key frame from the remote peer of the associatedvideomediastream of this mediahandler.",
	"Method": "boolean requestKeyFrame(){\r\n    KeyFrameControl.KeyFrameRequester[] keyFrameRequesters;\r\n    synchronized (this.keyFrameRequesters) {\r\n        keyFrameRequesters = this.keyFrameRequesters.toArray(new KeyFrameControl.KeyFrameRequester[this.keyFrameRequesters.size()]);\r\n    }\r\n    for (KeyFrameControl.KeyFrameRequester keyFrameRequester : keyFrameRequesters) {\r\n        if (keyFrameRequester.requestKeyFrame())\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.server.WebSocketOverSSLTest.testServerSessionRequestURI",
	"Comment": "test that server session.upgraderequest.requesturi reports correctly",
	"Method": "void testServerSessionRequestURI(){\r\n    assertThat(\"server scheme\", server.getServerUri().getScheme(), is(\"wss\"));\r\n    WebSocketClient client = new WebSocketClient(server.getSslContextFactory(), null, bufferPool);\r\n    try {\r\n        client.setConnectTimeout(CONNECT_TIMEOUT);\r\n        client.start();\r\n        CaptureSocket clientSocket = new CaptureSocket();\r\n        URI requestUri = server.getServerUri().resolve(\"/deep?a=b\");\r\n        System.err.printf(\"Request URI: %s%n\", requestUri.toASCIIString());\r\n        Future<Session> fut = client.connect(clientSocket, requestUri);\r\n        Session session = fut.get(FUTURE_TIMEOUT_SEC, TimeUnit.SECONDS);\r\n        RemoteEndpoint remote = session.getRemote();\r\n        remote.sendString(\"session.upgradeRequest.requestURI\");\r\n        if (remote.getBatchMode() == BatchMode.ON)\r\n            remote.flush();\r\n        LinkedBlockingQueue<String> captured = clientSocket.messages;\r\n        String expected = String.format(\"session.upgradeRequest.requestURI=%s\", requestUri.toASCIIString());\r\n        assertThat(\"session.upgradeRequest.requestURI\", captured.poll(Timeouts.POLL_EVENT, Timeouts.POLL_EVENT_UNIT), is(expected));\r\n        clientSocket.close();\r\n    } finally {\r\n        client.stop();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.addChatConferenceCall",
	"Comment": "adds the given conferencedescription to the list of chat conferences in this chat panel chat.",
	"Method": "void addChatConferenceCall(ConferenceDescription conferenceDescription){\r\n    if (chatConferencesDialog != null) {\r\n        chatConferencesDialog.addConference(conferenceDescription);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.notification.NotificationServiceImpl.removeEventNotification",
	"Comment": "removes the eventnotification corresponding to the giveneventtype from the table of registered event notifications.",
	"Method": "void removeEventNotification(String eventType){\r\n    notifications.remove(eventType);\r\n    this.fireNotificationEventTypeEvent(EVENT_TYPE_REMOVED, eventType);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.ZrtpSecurityPanel.initSasLabels",
	"Comment": "initializes security authentication string labels depending on thesecurity verification status.",
	"Method": "void initSasLabels(){\r\n    String statusLabel = \"zrtp\";\r\n    String longNamelabel = GuiActivator.getResources().getI18NString(\"service.gui.ZID_NAME_NOT_SET\");\r\n    if (!sasVerified) {\r\n        compareLabel.setText(GuiActivator.getResources().getI18NString(\"service.gui.security.COMPARE_WITH_PARTNER_SHORT\"));\r\n        confirmButton.setText(GuiActivator.getResources().getI18NString(\"service.gui.CONFIRM\"));\r\n        zidNameValue = null;\r\n        zidAorValue = null;\r\n        configService.setProperty(zidNameKey, zidNameValue);\r\n        configService.setProperty(zidAorKey, zidAorValue);\r\n    } else {\r\n        compareLabel.setText(GuiActivator.getResources().getI18NString(\"service.gui.security.STRING_COMPARED\"));\r\n        confirmButton.setText(GuiActivator.getResources().getI18NString(\"service.gui.CLEAR\"));\r\n        if (zidNameValue != null) {\r\n            String label = zidNameValue;\r\n            if (zidNameValue.length() > 6) {\r\n                label = zidNameValue.substring(0, 6) + \"...\";\r\n            }\r\n            statusLabel = \"zrtp - \" + label;\r\n            longNamelabel = GuiActivator.getResources().getI18NString(\"service.gui.ZID_NAME_SET\") + \" '\" + zidNameValue + \"'\";\r\n        }\r\n    }\r\n    if (securityStatusLabel != null) {\r\n        securityStatusLabel.setText(statusLabel);\r\n        securityStatusLabel.setToolTipText(longNamelabel);\r\n    }\r\n    if (compareLabel.isVisible()) {\r\n        compareLabel.revalidate();\r\n        compareLabel.repaint();\r\n        confirmButton.revalidate();\r\n        confirmButton.repaint();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.mailnotification.MailboxIQ.getDate",
	"Comment": "returns the date of the most recent unread mail content on the mailserver, in milliseconds since the unix epoch.",
	"Method": "long getDate(){\r\n    return this.date;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.contactsourceconfig.ContactSourceConfigActivator.getUIService",
	"Comment": "gets the uiservice instance registered in thebundlecontext of the securityconfigactivator.",
	"Method": "UIService getUIService(){\r\n    if (uiService == null)\r\n        uiService = ServiceUtils.getService(bundleContext, UIService.class);\r\n    return uiService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.TestOperationSetBasicInstantMessaging.thenTestSendMessage",
	"Comment": "send an instant message from the tester agent and assert reception bythe tested implementation",
	"Method": "void thenTestSendMessage(){\r\n    String body = \"This is an IM coming from the tested implementation\" + \" on \" + new Date().toString();\r\n    net.java.sip.communicator.service.protocol.Message msg = opSetBasicIM.createMessage(body);\r\n    ImEventCollector imEvtCollector = new ImEventCollector();\r\n    opSetBasicIM.addMessageListener(imEvtCollector);\r\n    JoustSimMessageEventCollector jsEvtCollector = new JoustSimMessageEventCollector();\r\n    IcqSlickFixture.testerAgent.addConversationListener(fixture.ourUserID, jsEvtCollector);\r\n    Contact testerAgentContact = opSetPresence.findContactByID(IcqSlickFixture.testerAgent.getIcqUIN());\r\n    opSetBasicIM.sendInstantMessage(testerAgentContact, msg);\r\n    imEvtCollector.waitForEvent(10000);\r\n    jsEvtCollector.waitForEvent(10000);\r\n    IcqSlickFixture.testerAgent.removeConversationListener(fixture.ourUserID, jsEvtCollector);\r\n    opSetBasicIM.removeMessageListener(imEvtCollector);\r\n    assertTrue(\"No events delivered when sending a message\", imEvtCollector.collectedEvents.size() > 0);\r\n    assertTrue(\"Received evt was not an instance of \" + MessageDeliveredEvent.class.getName(), imEvtCollector.collectedEvents.get(0) instanceof MessageDeliveredEvent);\r\n    MessageDeliveredEvent evt = (MessageDeliveredEvent) imEvtCollector.collectedEvents.get(0);\r\n    assertEquals(\"message destination \", evt.getDestinationContact().getAddress(), IcqSlickFixture.testerAgent.getIcqUIN());\r\n    assertSame(\"source message\", msg, evt.getSourceMessage());\r\n    assertTrue(\"No messages received by the tester agent\", jsEvtCollector.collectedMessageInfo.size() > 0);\r\n    String receivedBody = jsEvtCollector.collectedMessageInfo.get(0).getMessage().getMessageBody();\r\n    assertEquals(\"received message body\", msg.getContent(), receivedBody);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.keybindings.KeybindingsActivator.getResourceService",
	"Comment": "returns the resourcemanagementservice obtained from thebundle context.",
	"Method": "ResourceManagementService getResourceService(){\r\n    if (resourceService == null) {\r\n        ServiceReference resourceReference = bundleContext.getServiceReference(ResourceManagementService.class.getName());\r\n        resourceService = (ResourceManagementService) bundleContext.getService(resourceReference);\r\n    }\r\n    return resourceService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipRegistrarlessConnection.register",
	"Comment": "simply sets the state of the connection to registered without doinganything else.",
	"Method": "void register(){\r\n    setRegistrationState(RegistrationState.REGISTERED, RegistrationStateChangeEvent.REASON_USER_REQUEST, null);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaAwareCall.isLocalVideoStreaming",
	"Comment": "determines whether we are currently streaming video toward at least oneof the peers in this call.",
	"Method": "boolean isLocalVideoStreaming(){\r\n    Iterator<T> peers = getCallPeers();\r\n    while (peers.hasNext()) {\r\n        if (peers.next().isLocalVideoStreaming())\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AccountManager.getAccountNodeName",
	"Comment": "gets account node name under which account configuration properties arestored.",
	"Method": "String getAccountNodeName(ProtocolProviderFactory factory,String accountUID){\r\n    ConfigurationService configurationService = ProtocolProviderActivator.getConfigurationService();\r\n    String factoryPackage = getFactoryImplPackageName(factory);\r\n    List<String> storedAccounts = configurationService.getPropertyNamesByPrefix(factoryPackage, true);\r\n    String accountNodeName = null;\r\n    for (Iterator<String> storedAccountIter = storedAccounts.iterator(); storedAccountIter.hasNext(); ) {\r\n        String storedAccount = storedAccountIter.next();\r\n        int dotIndex = storedAccount.lastIndexOf(\".\");\r\n        if (!storedAccount.substring(dotIndex + 1).startsWith(ACCOUNT_UID_PREFIX))\r\n            continue;\r\n        String storedAccountUID = configurationService.getString(storedAccount + \".\" + ProtocolProviderFactory.ACCOUNT_UID);\r\n        if (storedAccountUID == null)\r\n            continue;\r\n        if (storedAccountUID.equals(accountUID))\r\n            accountNodeName = configurationService.getString(storedAccount);\r\n    }\r\n    return accountNodeName;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.whiteboard.WhiteboardObjectPathJabberImpl.setPoints",
	"Comment": "sets the list of whiteboardpoint instances that thiswhiteboardobject is composed of.",
	"Method": "void setPoints(List<WhiteboardPoint> points){\r\n    this.listPoints = new LinkedList<WhiteboardPoint>(points);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ContactListTreeCellRenderer.getCallVideoButton",
	"Comment": "returns the call video button contained in the current cell.",
	"Method": "JButton getCallVideoButton(){\r\n    return callVideoButton;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.IcqTesterAgent.sendTypingNotification",
	"Comment": "sends to buddy a notification that our typing state has nowchanged to indicated by notif.",
	"Method": "void sendTypingNotification(String buddy,TypingState state){\r\n    conn.getIcbmService().getImConversation(new Screenname(buddy)).setTypingState(state);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.TestOperationSetPersistentPresence.testRetrievingServerStoredContactList",
	"Comment": "retrieves a server stored contact list and checks whether it containsall contacts that have been added there during the initializationphase by the icqtesteragent.",
	"Method": "void testRetrievingServerStoredContactList(){\r\n    ContactGroup rootGroup = opSetPersPresence.getServerStoredContactListRoot();\r\n    logger.debug(\"=========== Server Stored Contact List =================\");\r\n    logger.debug(\"rootGroup=\" + rootGroup.getGroupName() + \" rootGroup.childContacts=\" + rootGroup.countContacts() + \"rootGroup.childGroups=\" + rootGroup.countSubgroups() + \"Printing rootGroupContents=\\n\" + rootGroup.toString());\r\n    Hashtable<String, List<String>> expectedContactList = IcqSlickFixture.preInstalledBuddyList;\r\n    logger.debug(\"============== Expected Contact List ===================\");\r\n    logger.debug(expectedContactList);\r\n    Iterator<ContactGroup> groups = rootGroup.subgroups();\r\n    while (groups.hasNext()) {\r\n        ContactGroup group = groups.next();\r\n        List<String> expectedContactsInGroup = expectedContactList.get(group.getGroupName());\r\n        if (group.isPersistent()) {\r\n            assertNotNull(\"Group \" + group.getGroupName() + \" was returned by \" + \"the server but was not in the expected contact list.\", expectedContactsInGroup);\r\n            Iterator<Contact> contactsIter = group.contacts();\r\n            while (contactsIter.hasNext()) {\r\n                String contactID = contactsIter.next().getAddress();\r\n                expectedContactsInGroup.remove(contactID);\r\n            }\r\n            if (expectedContactsInGroup.size() == 0)\r\n                expectedContactList.remove(group.getGroupName());\r\n        }\r\n    }\r\n    assertTrue(\"The following contacts were on the server sidec contact \" + \"list, but were not returned by the pers. pres. op. set\" + expectedContactList.toString(), expectedContactList.isEmpty());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.IceUdpTransportManager.wrapupConnectivityEstablishment",
	"Comment": "waits for the associated ice agent to finish any startedconnectivity checks.",
	"Method": "void wrapupConnectivityEstablishment(){\r\n    TransportManagerJabberImpl delegate = findTransportManagerEstablishingConnectivityWithJitsiVideobridge();\r\n    if ((delegate == null) || (delegate == this)) {\r\n        final Object iceProcessingStateSyncRoot = new Object();\r\n        PropertyChangeListener stateChangeListener = new PropertyChangeListener() {\r\n            public void propertyChange(PropertyChangeEvent evt) {\r\n                Object newValue = evt.getNewValue();\r\n                if (IceProcessingState.COMPLETED.equals(newValue) || IceProcessingState.FAILED.equals(newValue) || IceProcessingState.TERMINATED.equals(newValue)) {\r\n                    if (logger.isTraceEnabled())\r\n                        logger.trace(\"ICE \" + newValue);\r\n                    Agent iceAgent = (Agent) evt.getSource();\r\n                    iceAgent.removeStateChangeListener(this);\r\n                    if (iceAgent == IceUdpTransportManager.this.iceAgent) {\r\n                        synchronized (iceProcessingStateSyncRoot) {\r\n                            iceProcessingStateSyncRoot.notify();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        iceAgent.addStateChangeListener(stateChangeListener);\r\n        boolean interrupted = false;\r\n        synchronized (iceProcessingStateSyncRoot) {\r\n            while (IceProcessingState.RUNNING.equals(iceAgent.getState())) {\r\n                try {\r\n                    iceProcessingStateSyncRoot.wait();\r\n                } catch (InterruptedException ie) {\r\n                    interrupted = true;\r\n                }\r\n            }\r\n        }\r\n        if (interrupted)\r\n            Thread.currentThread().interrupt();\r\n        iceAgent.removeStateChangeListener(stateChangeListener);\r\n        if (IceProcessingState.FAILED.equals(iceAgent.getState())) {\r\n            String msg = JabberActivator.getResources().getI18NString(\"service.protocol.ICE_FAILED\");\r\n            throw new OperationFailedException(msg, OperationFailedException.GENERAL_ERROR);\r\n        }\r\n    } else {\r\n        delegate.wrapupConnectivityEstablishment();\r\n    }\r\n    if (cpeList != null) {\r\n        for (ContentPacketExtension content : cpeList) {\r\n            IceUdpTransportPacketExtension transport = content.getFirstChildOfType(IceUdpTransportPacketExtension.class);\r\n            if (transport != null) {\r\n                for (CandidatePacketExtension candidate : transport.getCandidateList()) transport.removeCandidate(candidate);\r\n                Collection<?> childExtensions = transport.getChildExtensionsOfType(CandidatePacketExtension.class);\r\n                if ((childExtensions == null) || childExtensions.isEmpty()) {\r\n                    transport.removeAttribute(IceUdpTransportPacketExtension.UFRAG_ATTR_NAME);\r\n                    transport.removeAttribute(IceUdpTransportPacketExtension.PWD_ATTR_NAME);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.IceUdpTransportManager.wrapupConnectivityEstablishment",
	"Comment": "waits for the associated ice agent to finish any startedconnectivity checks.",
	"Method": "void wrapupConnectivityEstablishment(){\r\n    Object newValue = evt.getNewValue();\r\n    if (IceProcessingState.COMPLETED.equals(newValue) || IceProcessingState.FAILED.equals(newValue) || IceProcessingState.TERMINATED.equals(newValue)) {\r\n        if (logger.isTraceEnabled())\r\n            logger.trace(\"ICE \" + newValue);\r\n        Agent iceAgent = (Agent) evt.getSource();\r\n        iceAgent.removeStateChangeListener(this);\r\n        if (iceAgent == IceUdpTransportManager.this.iceAgent) {\r\n            synchronized (iceProcessingStateSyncRoot) {\r\n                iceProcessingStateSyncRoot.notify();\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.menus.ToolsMenu.serviceChanged",
	"Comment": "implements the servicelistener method. verifies whether thepassed event concerns a protocolproviderservice and adds thecorresponding ui controls in the menu.",
	"Method": "void serviceChanged(ServiceEvent event){\r\n    ServiceReference serviceRef = event.getServiceReference();\r\n    if (serviceRef.getBundle().getState() == Bundle.STOPPING) {\r\n        return;\r\n    }\r\n    Object service = GuiActivator.bundleContext.getService(serviceRef);\r\n    if (!(service instanceof ProtocolProviderService)) {\r\n        return;\r\n    }\r\n    switch(event.getType()) {\r\n        case ServiceEvent.REGISTERED:\r\n        case ServiceEvent.UNREGISTERING:\r\n            initVideoBridgeMenu();\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.AbstractOperationSetTelephonyConferencing.registrationStateChanged",
	"Comment": "notifies this registrationstatechangelistener that theprotocolproviderserivce it is registered with has changed itsregistration state.",
	"Method": "void registrationStateChanged(RegistrationStateChangeEvent event){\r\n    RegistrationState newState = event.getNewState();\r\n    if (RegistrationState.REGISTERED.equals(newState)) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        OperationSetBasicTelephonyT basicTelephony = (OperationSetBasicTelephonyT) parentProvider.getOperationSet(OperationSetBasicTelephony.class);\r\n        if (this.basicTelephony != basicTelephony) {\r\n            OperationSetBasicTelephonyT oldValue = this.basicTelephony;\r\n            this.basicTelephony = basicTelephony;\r\n            basicTelephonyChanged(oldValue, this.basicTelephony);\r\n        }\r\n    } else if (RegistrationState.UNREGISTERED.equals(newState)) {\r\n        if (basicTelephony != null) {\r\n            OperationSetBasicTelephonyT oldValue = basicTelephony;\r\n            basicTelephony = null;\r\n            basicTelephonyChanged(oldValue, null);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.TestOperationSetPresence.subtestQueryContactStatus",
	"Comment": "used by functions testing the querycontactstatus method of thepresence operation set.",
	"Method": "void subtestQueryContactStatus(long taStatusLong,PresenceStatus expectedReturn){\r\n    if (!IcqSlickFixture.testerAgent.enterStatus(taStatusLong)) {\r\n        throw new RuntimeException(\"Tester UserAgent Failed to switch to the \" + expectedReturn.getStatusName() + \" state.\");\r\n    }\r\n    PresenceStatus actualReturn = operationSetPresence.queryContactStatus(IcqSlickFixture.testerAgent.getIcqUIN());\r\n    assertEquals(\"Querying a \" + expectedReturn.getStatusName() + \" state did not return as expected\", expectedReturn, actualReturn);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.conference.BasicConferenceCallPanel.updateViewFromModelInEventDispatchThread",
	"Comment": "updates this view i.e. basicconferencecallpanel so that itdepicts the current state of its model i.e. callconference. theupdate is performed on the awt event dispatching thread.",
	"Method": "void updateViewFromModelInEventDispatchThread(){\r\n    if (disposed)\r\n        return;\r\n    updateViewFromModel(null);\r\n    List<CallPeer> callPeers = callConference.getCallPeers();\r\n    for (Iterator<Map.Entry<CallPeer, ConferenceCallPeerRenderer>> entryIter = callPeerPanels.entrySet().iterator(); entryIter.hasNext(); ) {\r\n        Map.Entry<CallPeer, ConferenceCallPeerRenderer> entry = entryIter.next();\r\n        CallPeer callPeer = entry.getKey();\r\n        if ((callPeer != null) && !callPeers.contains(callPeer) && !delayedCallPeers.containsKey(callPeer)) {\r\n            ConferenceCallPeerRenderer callPeerPanel = entry.getValue();\r\n            entryIter.remove();\r\n            fireConferencePeerViewEvent(ConferencePeerViewEvent.CONFERENCE_PEER_VIEW_REMOVED, callPeer, callPeerPanel);\r\n            try {\r\n                viewForModelRemoved(callPeerPanel, callPeer);\r\n            } finally {\r\n                callPeerPanel.dispose();\r\n            }\r\n        }\r\n    }\r\n    for (CallPeer callPeer : callPeers) updateViewFromModel(callPeer);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.ParameterPacketExtension.getValue",
	"Comment": "returns the value of the format parameter we are representing here.",
	"Method": "String getValue(){\r\n    return super.getAttributeAsString(VALUE_ATTR_NAME);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.ippiaccregwizz.IppiAccountRegistrationWizard.getUserNameExample",
	"Comment": "returns an example string, which should indicate to the user how theuser name should look like.",
	"Method": "String getUserNameExample(){\r\n    return \"Ex: myusername or myusername@ippi.fr\";\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.ExternalContactSource.getGroupCustomActionMenuItems",
	"Comment": "returns all custom action menu items for the contact source.",
	"Method": "Collection<JMenuItem> getGroupCustomActionMenuItems(boolean initActions){\r\n    if (initActions || (customGroupActionMenuItems == null))\r\n        initCustomGroupActionMenuItems();\r\n    Iterator<ContactActionMenuItem<ContactSourceService>> customActionsIter = customGroupActionMenuItems.keySet().iterator();\r\n    Collection<JMenuItem> availableCustomActionMenuItems = new LinkedList<JMenuItem>();\r\n    while (customActionsIter.hasNext()) {\r\n        ContactActionMenuItem<ContactSourceService> contactAction = customActionsIter.next();\r\n        JMenuItem actionMenuItem = customGroupActionMenuItems.get(contactAction);\r\n        if (isContactActionVisible(contactAction, contactSource)) {\r\n            availableCustomActionMenuItems.add(actionMenuItem);\r\n        }\r\n    }\r\n    return availableCustomActionMenuItems;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.credentialsstorage.CredentialsStorageServiceImpl.changeMasterPassword",
	"Comment": "changes the master password from the old to the new one.decrypts all encrypted password properties from the configurationwith the oldpassword and encrypts them again with newpassword.",
	"Method": "boolean changeMasterPassword(String oldPassword,String newPassword){\r\n    List<String> encryptedAccountProps = configurationService.getPropertyNamesBySuffix(ACCOUNT_ENCRYPTED_PASSWORD);\r\n    Map<String, String> passwords = new HashMap<String, String>();\r\n    try {\r\n        setMasterPassword(oldPassword);\r\n        for (String propName : encryptedAccountProps) {\r\n            String propValue = configurationService.getString(propName);\r\n            if (propValue != null) {\r\n                String decrypted = crypto.decrypt(propValue);\r\n                passwords.put(propName, decrypted);\r\n            }\r\n        }\r\n        setMasterPassword(newPassword);\r\n        for (Map.Entry<String, String> entry : passwords.entrySet()) {\r\n            String encrypted = crypto.encrypt(entry.getValue());\r\n            configurationService.setProperty(entry.getKey(), encrypted);\r\n        }\r\n        writeVerificationValue(newPassword == null);\r\n    } catch (CryptoException ce) {\r\n        logger.debug(ce);\r\n        crypto = null;\r\n        passwords = null;\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactImpl.getParentGroup",
	"Comment": "returns the group that is currently holding this meta contact.",
	"Method": "MetaContactGroupImpl getParentGroup(){\r\n    return parentGroup;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapDirectorySettingsImpl.setGlobalPhonePrefix",
	"Comment": "sets the global prefix to be used when calling phones from this ldapsource.",
	"Method": "void setGlobalPhonePrefix(String prefix){\r\n    this.globalPhonePrefix = prefix;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.CallPeerMediaHandlerJabberImpl.getColibriChannel",
	"Comment": "if jitsi videobridge is in use, returns thecolibriconferenceiq.channel that thiscallpeermediahandler uses for media of type mediatype.otherwise, returns null",
	"Method": "ColibriConferenceIQ.Channel getColibriChannel(MediaType mediaType){\r\n    ColibriConferenceIQ.Channel channel = null;\r\n    if (getPeer().isJitsiVideobridge()) {\r\n        TransportManagerJabberImpl transportManager = this.transportManager;\r\n        if (transportManager != null) {\r\n            channel = transportManager.getColibriChannel(mediaType, false);\r\n        }\r\n    }\r\n    return channel;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommTabbedPane.fireCloseTabEvent",
	"Comment": "sends a mouseevent, whose source is this tabbedpane, toevery closelistener. the method also updates theovertabindex of the tabbedpane with a value coming fromthe ui. this method method is called each time a mouseeventis received from the ui when the user clicks on the close icon of the tabwhich index is overtabindex.",
	"Method": "void fireCloseTabEvent(MouseEvent e,int overTabIndex){\r\n    this.overTabIndex = overTabIndex;\r\n    EventListener[] closeListeners = getListeners(CloseListener.class);\r\n    for (int i = 0; i < closeListeners.length; i++) {\r\n        ((CloseListener) closeListeners[i]).closeOperation(e);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.UtilActivator.getAlertUIService",
	"Comment": "returns the metacontactlistservice obtained from the bundlecontext.",
	"Method": "AlertUIService getAlertUIService(){\r\n    if (alertUIService == null) {\r\n        alertUIService = ServiceUtils.getService(bundleContext, AlertUIService.class);\r\n    }\r\n    return alertUIService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.AccountPanel.setPassword",
	"Comment": "sets the password to display in the password field of this panel.",
	"Method": "void setPassword(String password){\r\n    passField.setText(password);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.UIServiceImpl.openChatRoomWindow",
	"Comment": "opens a chat room window for the given chatroomwrapper instance.",
	"Method": "void openChatRoomWindow(ChatRoomWrapper chatRoom){\r\n    ChatWindowManager chatWindowManager = getChatWindowManager();\r\n    ChatPanel chatPanel = chatWindowManager.getMultiChat(chatRoom, true);\r\n    chatWindowManager.openChat(chatPanel, true);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.history.HistoryWindow.close",
	"Comment": "implements the sipcommframe close method, which is invoked whenuser presses the esc key. checks if the popup menu is visible and ifthis is the case hides it, otherwise saves the current history windowsize and location and disposes the window.",
	"Method": "void close(boolean isEscaped){\r\n    history.removeSearchProgressListener(this);\r\n    if (basicInstantMessagings != null) {\r\n        for (OperationSetBasicInstantMessaging basicInstantMessaging : basicInstantMessagings) basicInstantMessaging.removeMessageListener(this);\r\n        basicInstantMessagings = null;\r\n    }\r\n    if (chatRoom != null) {\r\n        chatRoom.removeMessageListener(this);\r\n        chatRoom = null;\r\n    }\r\n    if (chatConvPanel != null && chatConvPanel.getRightButtonMenu() != null && chatConvPanel.getRightButtonMenu().isVisible()) {\r\n        chatConvPanel.getRightButtonMenu().setVisible(false);\r\n    } else if (historyMenu != null && historyMenu.isPopupMenuVisible()) {\r\n        MenuSelectionManager.defaultManager().clearSelectedPath();\r\n    } else {\r\n        GuiActivator.getUIService().getHistoryWindowManager().removeHistoryWindowForContact(historyContact);\r\n        if (datesPanel != null)\r\n            datesPanel.dispose();\r\n        if (chatConvPanel != null)\r\n            chatConvPanel.dispose();\r\n        this.dispose();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.RootContactGroupIcqImpl.contacts",
	"Comment": "returns an iterator over all contacts, member of thiscontactgroup.",
	"Method": "Iterator<Contact> contacts(){\r\n    return dummyContacts.iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipRegistrarConnection.cancelPendingRegistrations",
	"Comment": "cancels all pending reregistrations. the method is useful when shutting down.",
	"Method": "void cancelPendingRegistrations(){\r\n    reRegisterTimer.cancel();\r\n    reRegisterTimer = null;\r\n    reRegisterTimer = new Timer();\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.sip.TestOperationSetPersistentPresence.testRetrievingServerStoredContactList",
	"Comment": "retrieves a server stored contact list and checks whether it containsall contacts that have been added there during the initializationphase by the testeragent.",
	"Method": "void testRetrievingServerStoredContactList(){\r\n    ContactGroup rootGroup = this.opSetPersPresence1.getServerStoredContactListRoot();\r\n    logger.debug(\"=========== Server Stored Contact List =================\");\r\n    logger.debug(\"rootGroup=\" + rootGroup.getGroupName() + \" rootGroup.childContacts=\" + rootGroup.countContacts() + \"rootGroup.childGroups=\" + rootGroup.countSubgroups() + \"Printing rootGroupContents=\\n\" + rootGroup.toString());\r\n    Hashtable<String, List<String>> expectedContactList = SipSlickFixture.preInstalledBuddyList;\r\n    logger.debug(\"============== Expected Contact List ===================\");\r\n    logger.debug(expectedContactList);\r\n    Iterator<ContactGroup> groups = rootGroup.subgroups();\r\n    while (groups.hasNext()) {\r\n        ContactGroup group = groups.next();\r\n        List<String> expectedContactsInGroup = expectedContactList.get(group.getGroupName());\r\n        if (!group.getGroupName().equals(\"NotInContactList\")) {\r\n            assertNotNull(\"Group \" + group.getGroupName() + \" was returned by \" + \"the server but was not in the expected contact list.\", expectedContactsInGroup);\r\n            Iterator<Contact> contactsIter = group.contacts();\r\n            while (contactsIter.hasNext()) {\r\n                String contactID = contactsIter.next().getAddress();\r\n                expectedContactsInGroup.remove(contactID);\r\n            }\r\n            if (expectedContactsInGroup.size() == 0)\r\n                expectedContactList.remove(group.getGroupName());\r\n        }\r\n    }\r\n    assertTrue(\"The following contacts were on the server sidec contact \" + \"list, but were not returned by the pers. pres. op. set\" + expectedContactList.toString(), expectedContactList.isEmpty());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ServerStoredContactList.fireContactAdded",
	"Comment": "make the parent persistent presence operation set dispatch a contactadded event.",
	"Method": "void fireContactAdded(ContactGroupSipImpl parentGroup,ContactSipImpl contact){\r\n    parentOperationSet.fireSubscriptionEvent(contact, parentGroup, SubscriptionEvent.SUBSCRIPTION_CREATED);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.chat.ChatOperationReasonDialog.addToReasonFieldPannel",
	"Comment": "adds component to panel which contains the reason text field.",
	"Method": "void addToReasonFieldPannel(Component comp){\r\n    reasonFieldPanel.add(comp, BorderLayout.CENTER);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallPanel.addCallTitleListener",
	"Comment": "adds the given calltitlelistener to the list of listeners,notified for call title changes.",
	"Method": "void addCallTitleListener(CallTitleListener l){\r\n    synchronized (titleListeners) {\r\n        titleListeners.add(l);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomJabberImpl.addMemberPropertyChangeListener",
	"Comment": "adds the given listener to the list of listeners registered toreceive events upon modification of chat room member properties such asits nickname being changed for example.",
	"Method": "void addMemberPropertyChangeListener(ChatRoomMemberPropertyChangeListener listener){\r\n    synchronized (memberPropChangeListeners) {\r\n        if (!memberPropChangeListeners.contains(listener))\r\n            memberPropChangeListeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.pluginmanager.PluginListCellRenderer.paintComponent",
	"Comment": "paint a background for all groups and a round blue border and backgroundwhen a cell is selected.",
	"Method": "void paintComponent(Graphics g){\r\n    super.paintComponent(g);\r\n    g = g.create();\r\n    try {\r\n        internalPaintComponent(g);\r\n    } finally {\r\n        g.dispose();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.CallHistoryFilter.addMatching",
	"Comment": "adds matching notification contacts to the result tree model.",
	"Method": "void addMatching(NotificationContactSource notifSource){\r\n    Iterator<? extends UIGroup> notifGroups = notifSource.getNotificationGroups();\r\n    while (notifGroups.hasNext()) {\r\n        UIGroup uiGroup = notifGroups.next();\r\n        Iterator<? extends UIContact> notfications = notifSource.getNotifications(uiGroup);\r\n        while (notfications.hasNext()) {\r\n            GuiActivator.getContactList().addContact(notfications.next(), uiGroup, false, true);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.librec.recommender.cf.UserKNNTestCase.test03SplitterRatioRating",
	"Comment": "test ratiodatasplitter with rating ratio, evaluating enabled.",
	"Method": "void test03SplitterRatioRating(){\r\n    Resource resource = new Resource(\"rec/cf/userknn-test.properties\");\r\n    conf.addResource(resource);\r\n    conf.set(\"rec.eval.enable\", \"true\");\r\n    conf.set(\"data.model.splitter\", \"ratio\");\r\n    conf.set(\"data.splitter.ratio\", \"rating\");\r\n    RecommenderJob job = new RecommenderJob(conf);\r\n    job.runJob();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetCusaxUtilsJabberImpl.getLinkedCusaxProvider",
	"Comment": "returns the linked cusax provider for this protocol provider.",
	"Method": "ProtocolProviderService getLinkedCusaxProvider(){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageHistoryServiceImpl.handleProviderAdded",
	"Comment": "used to attach the message history service to existing orjust registered protocol provider. checks if the provider has implementationof operationsetbasicinstantmessaging",
	"Method": "void handleProviderAdded(ProtocolProviderService provider){\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Adding protocol provider \" + provider.getProtocolDisplayName());\r\n    OperationSetBasicInstantMessaging opSetIm = provider.getOperationSet(OperationSetBasicInstantMessaging.class);\r\n    if (opSetIm != null) {\r\n        opSetIm.addMessageListener(this);\r\n        if (this.messageSourceService != null)\r\n            opSetIm.addMessageListener(messageSourceService);\r\n    } else {\r\n        if (logger.isTraceEnabled())\r\n            logger.trace(\"Service did not have a im op. set.\");\r\n    }\r\n    OperationSetSmsMessaging opSetSMS = provider.getOperationSet(OperationSetSmsMessaging.class);\r\n    if (opSetSMS != null) {\r\n        opSetSMS.addMessageListener(this);\r\n        if (this.messageSourceService != null)\r\n            opSetSMS.addMessageListener(messageSourceService);\r\n    } else {\r\n        if (logger.isTraceEnabled())\r\n            logger.trace(\"Service did not have a sms op. set.\");\r\n    }\r\n    OperationSetMultiUserChat opSetMultiUChat = provider.getOperationSet(OperationSetMultiUserChat.class);\r\n    if (opSetMultiUChat != null) {\r\n        Iterator<ChatRoom> iter = opSetMultiUChat.getCurrentlyJoinedChatRooms().iterator();\r\n        while (iter.hasNext()) {\r\n            ChatRoom room = iter.next();\r\n            room.addMessageListener(this);\r\n        }\r\n        opSetMultiUChat.addPresenceListener(this);\r\n        if (messageSourceService != null)\r\n            opSetMultiUChat.addPresenceListener(messageSourceService);\r\n    } else {\r\n        if (logger.isTraceEnabled())\r\n            logger.trace(\"Service did not have a multi im op. set.\");\r\n    }\r\n    if (messageSourceService != null) {\r\n        OperationSetPresence opSetPresence = provider.getOperationSet(OperationSetPresence.class);\r\n        if (opSetPresence != null) {\r\n            opSetPresence.addContactPresenceStatusListener(messageSourceService);\r\n            opSetPresence.addProviderPresenceStatusListener(messageSourceService);\r\n            opSetPresence.addSubscriptionListener(messageSourceService);\r\n        }\r\n        messageSourceService.handleProviderAdded(provider, false);\r\n        OperationSetContactCapabilities capOpSet = provider.getOperationSet(OperationSetContactCapabilities.class);\r\n        if (capOpSet != null) {\r\n            capOpSet.addContactCapabilitiesListener(messageSourceService);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.contactsource.AbstractContactQuery.fireQueryStatusChanged",
	"Comment": "notifies the contactquerylisteners registered with thiscontactquery that its state has changed.",
	"Method": "void fireQueryStatusChanged(int eventType){\r\n    ContactQueryListener[] ls;\r\n    synchronized (listeners) {\r\n        ls = listeners.toArray(new ContactQueryListener[listeners.size()]);\r\n    }\r\n    ContactQueryStatusEvent ev = new ContactQueryStatusEvent(this, eventType);\r\n    for (ContactQueryListener l : ls) l.queryStatusChanged(ev);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockChatRoom.sendMessage",
	"Comment": "sends the message to the destination indicated by theto contact.",
	"Method": "void sendMessage(Message message){\r\n    ChatRoomMessageDeliveredEvent evt = new ChatRoomMessageDeliveredEvent(this, new Date(), message, ChatRoomMessageDeliveredEvent.CONVERSATION_MESSAGE_DELIVERED);\r\n    for (ChatRoomMessageListener elem : messageListeners) elem.messageDelivered(evt);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.ircaccregwizz.IrcAccountRegistrationWizard.getProtocolName",
	"Comment": "implements the accountregistrationwizard.getprotocolnamemethod. returns the protocol name for this wizard.",
	"Method": "String getProtocolName(){\r\n    return Resources.getString(\"plugin.ircaccregwizz.PROTOCOL_NAME\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetPersistentPresenceIcqImpl.assertConnected",
	"Comment": "utility method throwing an exception if the icq stack is not properlyinitialized.",
	"Method": "void assertConnected(){\r\n    if (parentProvider == null)\r\n        throw new IllegalStateException(\"The icq provider must be non-null and signed on the ICQ \" + \"service before being able to communicate.\");\r\n    if (!parentProvider.isRegistered())\r\n        throw new IllegalStateException(\"The icq provider must be signed on the ICQ service before \" + \"being able to communicate.\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.IceTransportManagerSipImpl.close",
	"Comment": "releases the resources acquired by this transportmanager andprepares it for garbage collection.",
	"Method": "void close(){\r\n    for (MediaType mediaType : MediaType.values()) closeStreamConnector(mediaType);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MclStorageManager.metaContactMoved",
	"Comment": "moves the corresponding node from its old parent to the nodecorresponding to the new parent meta group.",
	"Method": "void metaContactMoved(MetaContactMovedEvent evt){\r\n    Element metaContactNode = findMetaContactNode(evt.getSourceMetaContact().getMetaUID());\r\n    Element newParentNode = findMetaContactGroupNode(evt.getNewParent().getMetaUID());\r\n    if (newParentNode == null) {\r\n        logger.error(\"Save after metacontact moved. new parent not found: \" + evt.getNewParent());\r\n        if (logger.isTraceEnabled())\r\n            logger.error(\"The above exception has occurred with the \" + \"following stack trace\", new Exception());\r\n        return;\r\n    }\r\n    if (metaContactNode == null) {\r\n        metaContactNode = createMetaContactNode(evt.getSourceMetaContact());\r\n    } else {\r\n        metaContactNode.getParentNode().removeChild(metaContactNode);\r\n    }\r\n    updateParentsForMetaContactNode(metaContactNode, evt.getNewParent());\r\n    Element childContacts = XMLUtils.findChild(newParentNode, CHILD_CONTACTS_NODE_NAME);\r\n    childContacts.appendChild(metaContactNode);\r\n    try {\r\n        scheduleContactListStorage();\r\n    } catch (IOException ex) {\r\n        logger.error(\"Writing CL failed after moving \" + evt.getSourceMetaContact(), ex);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.menus.ToolsMenu.pluginComponentAdded",
	"Comment": "adds the plugin component contained in the event to this container.",
	"Method": "void pluginComponentAdded(PluginComponentEvent event){\r\n    final PluginComponentFactory c = event.getPluginComponentFactory();\r\n    if (c.getContainer().equals(Container.CONTAINER_TOOLS_MENU)) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                PluginComponent pluginComponent = c.getPluginComponentInstance(ToolsMenu.this);\r\n                insertInSection((JMenuItem) pluginComponent.getComponent(), pluginComponent.getPositionIndex());\r\n            }\r\n        });\r\n        this.revalidate();\r\n        this.repaint();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.menus.ToolsMenu.pluginComponentAdded",
	"Comment": "adds the plugin component contained in the event to this container.",
	"Method": "void pluginComponentAdded(PluginComponentEvent event){\r\n    PluginComponent pluginComponent = c.getPluginComponentInstance(ToolsMenu.this);\r\n    insertInSection((JMenuItem) pluginComponent.getComponent(), pluginComponent.getPositionIndex());\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.PresenceStatus.compareTo",
	"Comment": "compares this instance with the specified object for order. returns anegative integer, zero, or a positive integer as this status instance isconsidered to represent less, as much, or more availability than the onespecified by the parameter.",
	"Method": "int compareTo(PresenceStatus target){\r\n    return (getStatus() - target.getStatus());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.configforms.ConfigFormListCellRenderer.getListCellRendererComponent",
	"Comment": "implements the listcellrenderer method.returns this panel that has been configured to display the meta contactand meta contact group cells.",
	"Method": "Component getListCellRendererComponent(JList list,Object value,int index,boolean isSelected,boolean cellHasFocus){\r\n    ConfigFormDescriptor cfDescriptor = (ConfigFormDescriptor) value;\r\n    ImageIcon icon = cfDescriptor.getConfigFormIcon();\r\n    if (icon != null)\r\n        iconLabel.setIcon(icon);\r\n    String title = cfDescriptor.getConfigFormTitle();\r\n    if (title != null)\r\n        textLabel.setText(title);\r\n    this.isSelected = isSelected;\r\n    return this;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.login.LoginRendererSwingImpl.getSecurityAuthorityImpl",
	"Comment": "returns the securityauthority implementation related to thislogin renderer.",
	"Method": "SecurityAuthority getSecurityAuthorityImpl(ProtocolProviderService protocolProvider){\r\n    return GuiActivator.getUIService().getDefaultSecurityAuthority(protocolProvider);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.ippiaccregwizz.CreateIppiAccountForm.getForm",
	"Comment": "returns the form, which would be used by the user to create a newaccount.",
	"Method": "Component getForm(){\r\n    return this;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.ircaccregwizz.FirstWizardPage.actionPerformed",
	"Comment": "indicates when the default port check box and the passwordnotrequiredcheck box are selected.",
	"Method": "void actionPerformed(ActionEvent event){\r\n    if (defaultPort.isSelected()) {\r\n        portField.setText(useSecureConnection.isSelected() ? DEFAULT_SECURE_PORT : DEFAULT_PLAINTEXT_PORT);\r\n        portField.setEnabled(false);\r\n    } else {\r\n        portField.setEnabled(true);\r\n    }\r\n    boolean passwordRequired = !this.passwordNotRequired.isSelected();\r\n    if (passwordRequired) {\r\n        passField.setEnabled(true);\r\n        rememberPassBox.setEnabled(true);\r\n        this.saslEnabled.setEnabled(true);\r\n    } else {\r\n        passField.setText(\"\");\r\n        passField.setEnabled(false);\r\n        rememberPassBox.setEnabled(false);\r\n        this.saslEnabled.setEnabled(false);\r\n    }\r\n    boolean enableSaslControls = passwordRequired && this.saslEnabled.isSelected();\r\n    saslUserIdField.setEnabled(enableSaslControls);\r\n    saslRoleField.setEnabled(enableSaslControls);\r\n    setNextButtonAccordingToUserID();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.geolocation.GeolocationJabberUtils.convertExtensionToMap",
	"Comment": "convert geolocation from geolocationextension format to map format",
	"Method": "Map<String, String> convertExtensionToMap(GeolocationPacketExtension geolocExt){\r\n    Map<String, String> geolocMap = new Hashtable<String, String>();\r\n    addFloatToMap(geolocMap, OperationSetGeolocation.ALT, geolocExt.getAlt());\r\n    addStringToMap(geolocMap, OperationSetGeolocation.AREA, geolocExt.getArea());\r\n    addFloatToMap(geolocMap, OperationSetGeolocation.BEARING, geolocExt.getBearing());\r\n    addStringToMap(geolocMap, OperationSetGeolocation.BUILDING, geolocExt.getBuilding());\r\n    addStringToMap(geolocMap, OperationSetGeolocation.COUNTRY, geolocExt.getCountry());\r\n    addStringToMap(geolocMap, OperationSetGeolocation.DATUM, geolocExt.getDatum());\r\n    addStringToMap(geolocMap, OperationSetGeolocation.DESCRIPTION, geolocExt.getDescription());\r\n    addFloatToMap(geolocMap, OperationSetGeolocation.ERROR, geolocExt.getError());\r\n    addStringToMap(geolocMap, OperationSetGeolocation.FLOOR, geolocExt.getFloor());\r\n    addFloatToMap(geolocMap, OperationSetGeolocation.LAT, geolocExt.getLat());\r\n    addStringToMap(geolocMap, OperationSetGeolocation.LOCALITY, geolocExt.getLocality());\r\n    addFloatToMap(geolocMap, OperationSetGeolocation.LON, geolocExt.getLon());\r\n    addStringToMap(geolocMap, OperationSetGeolocation.POSTALCODE, geolocExt.getPostalCode());\r\n    addStringToMap(geolocMap, OperationSetGeolocation.REGION, geolocExt.getRegion());\r\n    addStringToMap(geolocMap, OperationSetGeolocation.ROOM, geolocExt.getRoom());\r\n    addStringToMap(geolocMap, OperationSetGeolocation.STREET, geolocExt.getStreet());\r\n    addStringToMap(geolocMap, OperationSetGeolocation.TEXT, geolocExt.getText());\r\n    addStringToMap(geolocMap, OperationSetGeolocation.TIMESTAMP, geolocExt.getTimestamp());\r\n    return geolocMap;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageSourceService.handleProviderAdded",
	"Comment": "when a provider is added, do not block and start executing in new thread.",
	"Method": "void handleProviderAdded(ProtocolProviderService provider,boolean isStatusChanged){\r\n    new Thread(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            handleProviderAddedInSeparateThread(provider, isStatusChanged);\r\n        }\r\n    }).start();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageSourceService.handleProviderAdded",
	"Comment": "when a provider is added, do not block and start executing in new thread.",
	"Method": "void handleProviderAdded(ProtocolProviderService provider,boolean isStatusChanged){\r\n    handleProviderAddedInSeparateThread(provider, isStatusChanged);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.gui.PluginComponentFactory.getPluginComponentInstance",
	"Comment": "returns the component that should be added. this method should return avalid awt, swt or swing object in order to appear properly in the userinterface.",
	"Method": "PluginComponent getPluginComponentInstance(Object parent){\r\n    WeakReference<PluginComponent> ref = pluginInstances.get(parent);\r\n    PluginComponent pluginComponent = (ref == null) ? null : ref.get();\r\n    if (pluginComponent == null) {\r\n        pluginComponent = getPluginInstance();\r\n        if (pluginComponent != null) {\r\n            ref = new WeakReference<PluginComponent>(pluginComponent);\r\n            pluginInstances.put(parent, ref);\r\n        }\r\n    }\r\n    return pluginComponent;\r\n}"
}, {
	"Path": "net.librec.math.algorithm.Maths.isNumberWith2Decimals",
	"Comment": "check if given string is number with dot separator and two decimals.",
	"Method": "boolean isNumberWith2Decimals(String string){\r\n    return string.matches(\"^\\\\d+\\\\.\\\\d{2}$\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.SmileysSelectorBox.calculateGridDimensions",
	"Comment": "in order to have a popup which is at the form closest to square.",
	"Method": "Dimension calculateGridDimensions(int itemsCount){\r\n    int gridColCount = (int) Math.ceil(Math.sqrt(itemsCount));\r\n    int gridRowCount = itemsCount / gridColCount;\r\n    if (itemsCount > gridRowCount * gridColCount)\r\n        gridColCount++;\r\n    return new Dimension(gridColCount, gridRowCount);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.history.InteractiveHistoryReaderImpl.findByKeywords",
	"Comment": "searches the history for all records containing all keywords.",
	"Method": "HistoryQuery findByKeywords(String[] keywords,String field,int recordCount){\r\n    return find(null, null, keywords, field, false, recordCount);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.jabber.AbstractSmackInteroperabilityLayer.setImplementationClass",
	"Comment": "set the smack interoperation layerimplementation class to be used within this jitsi application",
	"Method": "void setImplementationClass(Class implementationClass){\r\n    AbstractSmackInteroperabilityLayer.implementationClass = implementationClass;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommTextArea.keyPressed",
	"Comment": "clears the default text when a key pressed event is received.",
	"Method": "void keyPressed(KeyEvent e){\r\n    clearDefaultText();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.reconnectplugin.ReconnectPluginActivator.setAtLeastOneSuccessfulConnection",
	"Comment": "changes the property about at least one successful connection.",
	"Method": "void setAtLeastOneSuccessfulConnection(ProtocolProviderService pp,boolean value){\r\n    getConfigurationService().setProperty(ATLEAST_ONE_CONNECTION_PROP + \".\" + pp.getAccountID().getAccountUniqueID(), Boolean.valueOf(value).toString());\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.generic.SecurityAuthorityImpl.obtainCredentials",
	"Comment": "returns a credentials object associated with the specified realm.",
	"Method": "UserCredentials obtainCredentials(String realm,UserCredentials defaultValues,UserCredentials obtainCredentials,String realm,UserCredentials defaultValues,int reasonCode){\r\n    return obtainCredentials(realm, defaultValues);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.utils.Constants.getStatusIcon",
	"Comment": "returns the image corresponding to the given presence status.",
	"Method": "BufferedImage getStatusIcon(PresenceStatus status){\r\n    if (status != null) {\r\n        int connectivity = status.getStatus();\r\n        if (connectivity < PresenceStatus.ONLINE_THRESHOLD) {\r\n            return ImageLoader.getImage(ImageLoader.USER_OFFLINE_ICON);\r\n        } else if (connectivity < PresenceStatus.EXTENDED_AWAY_THRESHOLD) {\r\n            return ImageLoader.getImage(ImageLoader.USER_DND_ICON);\r\n        } else if (connectivity < PresenceStatus.AWAY_THRESHOLD) {\r\n            String statusName = \"\";\r\n            if (status.getStatusName() != null)\r\n                statusName = Pattern.compile(\"\\\\p{Space}\").matcher(status.getStatusName()).replaceAll(\"\");\r\n            if (statusName.equalsIgnoreCase(\"OnThePhone\"))\r\n                return ImageLoader.getImage(ImageLoader.USER_USER_ON_THE_PHONE_ICON);\r\n            else if (statusName.equalsIgnoreCase(\"InAMeeting\"))\r\n                return ImageLoader.getImage(ImageLoader.USER_USER_IN_A_MEETING_ICON);\r\n            else\r\n                return ImageLoader.getImage(ImageLoader.USER_EXTENDED_AWAY_ICON);\r\n        } else if (connectivity < PresenceStatus.AVAILABLE_THRESHOLD) {\r\n            return ImageLoader.getImage(ImageLoader.USER_AWAY_ICON);\r\n        } else if (connectivity < PresenceStatus.EAGER_TO_COMMUNICATE_THRESHOLD) {\r\n            return ImageLoader.getImage(ImageLoader.USER_ONLINE_ICON);\r\n        } else if (connectivity < ChatRoomPresenceStatus.CHAT_ROOM_ONLINE_THRESHOLD) {\r\n            return ImageLoader.getImage(ImageLoader.USER_FFC_ICON);\r\n        } else if (connectivity < ChatRoomPresenceStatus.CHAT_ROOM_OFFLINE_THRESHOLD) {\r\n            return ImageLoader.getImage(ImageLoader.CHAT_ROOM_ONLINE_ICON);\r\n        } else if (connectivity == MessageSourceContactPresenceStatus.MSG_SRC_CONTACT_ONLINE_THRESHOLD) {\r\n            return ImageLoader.getImage(ImageLoader.MSG_SRC_CONTACT_ONLINE_ICON);\r\n        } else if (connectivity < PresenceStatus.MAX_STATUS_VALUE) {\r\n            return ImageLoader.getImage(ImageLoader.CHAT_ROOM_OFFLINE_ICON);\r\n        } else {\r\n            return ImageLoader.getImage(ImageLoader.USER_OFFLINE_ICON);\r\n        }\r\n    } else {\r\n        return ImageLoader.getImage(ImageLoader.USER_OFFLINE_ICON);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.notification.NotificationActivator.getSystray",
	"Comment": "returns the systrayservice obtained from the bundle context.",
	"Method": "SystrayService getSystray(){\r\n    if (systrayService == null) {\r\n        systrayService = ServiceUtils.getService(bundleContext, SystrayService.class);\r\n    }\r\n    return systrayService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.whiteboard.WhiteboardObjectJabberImpl.getID",
	"Comment": "returns a string uniquely identifying this whiteboardobject.",
	"Method": "String getID(){\r\n    return this.ID;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.packetlogging.PacketLoggingConfigurationImpl.setJabberLoggingEnabled",
	"Comment": "change whether packet logging for jabber protocol is enabledand save it in configuration.",
	"Method": "void setJabberLoggingEnabled(boolean enabled){\r\n    super.setJabberLoggingEnabled(enabled);\r\n    PacketLoggingActivator.getConfigurationService().setProperty(PACKET_LOGGING_JABBER_ENABLED_PROPERTY_NAME, enabled);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomMemberJabberImpl.getCurrentRole",
	"Comment": "returns the current role without trying to query it in the stack.mostly used for event creating on member role change.",
	"Method": "ChatRoomMemberRole getCurrentRole(){\r\n    return this.role;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.sipaccregwizz.PresencePanel.isClistOptionUseSipCredentials",
	"Comment": "indicates if contact list has to use sip account credentials.",
	"Method": "boolean isClistOptionUseSipCredentials(){\r\n    return clistOptionUseSipCredentialsBox.isSelected();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ContactGroupIcqImpl.isPersistent",
	"Comment": "determines whether or not this contact group is being stored by theserver. non persistent contact groups exist for the sole purpose ofcontaining non persistent contacts.",
	"Method": "boolean isPersistent(){\r\n    return isPersistent;\r\n}"
}, {
	"Path": "net.librec.math.structure.DenseMatrix.times",
	"Comment": "return a new matrix containing the product of the recipient and the argument",
	"Method": "DenseMatrix times(double value,DenseMatrix times,Matrix otherMatrix,DenseVector times,Vector vector){\r\n    if (columnSize() != vector.cardinality()) {\r\n        throw new CardinalityException(columnSize(), vector.cardinality());\r\n    }\r\n    DenseVector resultVector = new VectorBasedDenseVector(rowSize());\r\n    for (int rowIndex = 0; rowIndex < rowSize(); rowIndex++) {\r\n        resultVector.set(rowIndex, row(rowIndex).dot(vector));\r\n    }\r\n    return resultVector;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.DesktopSharingCallSipImpl.getDesktopSharingSessionID",
	"Comment": "the value of the received or generated header for matching notifyand subscribe requests to the call.",
	"Method": "String getDesktopSharingSessionID(){\r\n    return desktopSharingSessionID;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.removeChatHistoryListener",
	"Comment": "removes the given chathistorylistener from the list of listenersnotified when a change occurs in the history shown in this chat panel.",
	"Method": "void removeChatHistoryListener(ChatHistoryListener l){\r\n    synchronized (historyListeners) {\r\n        historyListeners.remove(l);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapDirectorySettingsImpl.getUserName",
	"Comment": "returns the user name associated with the corresponding ldap directory.",
	"Method": "String getUserName(){\r\n    if (bindDN == null)\r\n        return null;\r\n    String userName = null;\r\n    int uidIndex = bindDN.indexOf(\"uid=\");\r\n    if (uidIndex > -1) {\r\n        int commaIndex = bindDN.indexOf(\",\", uidIndex + 5);\r\n        if (commaIndex > -1)\r\n            userName = bindDN.substring(uidIndex + 4, commaIndex);\r\n        else\r\n            userName = bindDN.substring(uidIndex + 4);\r\n    }\r\n    return userName;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl.processDialogTerminated",
	"Comment": "process an asynchronously reported dialogterminatedevent.when a dialog transitions to the terminated state, the stackkeeps no further records of the dialog. this notification can be used byapplications to clean up any auxiliary data that is being maintainedfor the given dialog.",
	"Method": "void processDialogTerminated(DialogTerminatedEvent dialogTerminatedEvent){\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Dialog terminated for req=\" + dialogTerminatedEvent.getDialog());\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.TransportManager.getDSCP",
	"Comment": "gets the sip traffic class associated with a specific mediatypefrom the configuration.",
	"Method": "int getDSCP(MediaType type){\r\n    String dscpPropertyName;\r\n    switch(type) {\r\n        case AUDIO:\r\n            dscpPropertyName = RTP_AUDIO_DSCP_PROPERTY;\r\n            break;\r\n        case VIDEO:\r\n            dscpPropertyName = RTP_VIDEO_DSCP_PROPERTY;\r\n            break;\r\n        default:\r\n            dscpPropertyName = null;\r\n            break;\r\n    }\r\n    return (dscpPropertyName == null) ? 0 : (ProtocolMediaActivator.getConfigurationService().getInt(dscpPropertyName, 0) << 2);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatConversationPanel.clear",
	"Comment": "creates new document and all the messages that will be processed in thefuture will be appended in it.",
	"Method": "void clear(){\r\n    this.document = (HTMLDocument) editorKit.createDefaultDocument();\r\n    Constants.loadSimpleStyle(document.getStyleSheet(), chatTextPane.getFont());\r\n    this.isSimpleTheme = ConfigurationUtils.isChatSimpleThemeEnabled();\r\n}"
}, {
	"Path": "com.github.ltsopensource.admin.web.support.DateEditor.setAsText",
	"Comment": "parse the date from the given text, using the specified dateformat.",
	"Method": "void setAsText(String text){\r\n    if (this.allowEmpty && !StringUtils.hasText(text)) {\r\n        setValue(null);\r\n    } else {\r\n        try {\r\n            if (this.dateFormat != null)\r\n                setValue(this.dateFormat.parse(text));\r\n            else {\r\n                setValue(DateUtils.parse(text));\r\n            }\r\n        } catch (ParseException ex) {\r\n            throw new IllegalArgumentException(\"Could not parse date: \" + ex.getMessage(), ex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.AbstractSessionDataStoreTest.testSavePeriodDirtySession",
	"Comment": "check that a session whose attributes have changed will always be saved despite the saveperiod",
	"Method": "void testSavePeriodDirtySession(){\r\n    ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);\r\n    context.setContextPath(\"/test\");\r\n    SessionDataStoreFactory factory = createSessionDataStoreFactory();\r\n    ((AbstractSessionDataStoreFactory) factory).setGracePeriodSec(GRACE_PERIOD_SEC);\r\n    ((AbstractSessionDataStoreFactory) factory).setSavePeriodSec(20);\r\n    SessionDataStore store = factory.getSessionDataStore(context.getSessionHandler());\r\n    SessionContext sessionContext = new SessionContext(\"foo\", context.getServletContext());\r\n    store.initialize(sessionContext);\r\n    store.start();\r\n    long now = System.currentTimeMillis();\r\n    SessionData data = store.newSessionData(\"1234\", 100, now - 10, now - 20, TimeUnit.MINUTES.toMillis(60));\r\n    data.setLastNode(sessionContext.getWorkerName());\r\n    data.setLastSaved(now - 100);\r\n    data.setAttribute(\"wibble\", \"wobble\");\r\n    persistSession(data);\r\n    data.setAttribute(\"wibble\", \"bobble\");\r\n    data.setLastAccessed(now - 5);\r\n    data.setAccessed(now - 1);\r\n    store.store(\"1234\", data);\r\n    checkSessionPersisted(data);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.conference.ConferenceInviteDialog.initContactListData",
	"Comment": "initializes the left contact list with the contacts that could be addedto the current chat session.",
	"Method": "void initContactListData(ProtocolProviderService protocolProvider){\r\n    this.setCurrentProvider(protocolProvider);\r\n    Iterator<UIContactSource> sourcesIter = new ArrayList<UIContactSource>(srcContactList.getContactSources()).iterator();\r\n    while (sourcesIter.hasNext()) {\r\n        ContactSourceService contactSource = sourcesIter.next().getContactSourceService();\r\n        if (contactSource instanceof ProtocolAwareContactSourceService) {\r\n            ((ProtocolAwareContactSourceService) contactSource).setPreferredProtocolProvider(OperationSetBasicTelephony.class, protocolProvider);\r\n        }\r\n    }\r\n    srcContactList.removeContactSource(currentProviderContactSource);\r\n    srcContactList.removeContactSource(currentStringContactSource);\r\n    currentProviderContactSource = new ProtocolContactSourceServiceImpl(protocolProvider, OperationSetBasicTelephony.class);\r\n    currentStringContactSource = new StringContactSourceServiceImpl(protocolProvider, OperationSetBasicTelephony.class);\r\n    srcContactList.addContactSource(currentProviderContactSource);\r\n    srcContactList.addContactSource(currentStringContactSource);\r\n    srcContactList.applyDefaultFilter();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.login.LoginRendererSwingImpl.containsProtocolProviderUI",
	"Comment": "indicates if the given protocolprovider related user interfaceis already rendered.",
	"Method": "boolean containsProtocolProviderUI(ProtocolProviderService protocolProvider){\r\n    return mainFrame.hasProtocolProvider(protocolProvider);\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.ConfigurationUtils.isAutoAnswerDisableSubmenu",
	"Comment": "whether creation of separate submenu for auto answer is disabled.",
	"Method": "boolean isAutoAnswerDisableSubmenu(){\r\n    return autoAnswerDisableSubmenu;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.ConferenceMembersSoundLevelEvent.getLevels",
	"Comment": "returns the mapping of conferencemembers to sound levels. it ispresumed that all conferencemembers not contained in the map hasa 0 sound level.",
	"Method": "Map<ConferenceMember, Integer> getLevels(){\r\n    return levels;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetBasicInstantMessagingJabberImpl.assertConnected",
	"Comment": "utility method throwing an exception if the stack is not properlyinitialized.",
	"Method": "void assertConnected(){\r\n    if (opSetPersPresence == null) {\r\n        throw new IllegalStateException(\"The provider must be signed on the service before\" + \" being able to communicate.\");\r\n    } else\r\n        opSetPersPresence.assertConnected();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl.toString",
	"Comment": "returns a string representation of this operationsetbasictelephonyinstance including information that would permit to distinguish it amongother instances when reading a log file.",
	"Method": "String toString(){\r\n    return getClass().getSimpleName() + \"-[dn=\" + protocolProvider.getOurDisplayName() + (protocolProvider.getRegistrarConnection() != null ? \" addr=[\" + protocolProvider.getRegistrarConnection().getAddressOfRecord() + \"]\" : \"]\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.net.ProxyConnection.create",
	"Comment": "factory method to create a proxy connection based on the account settingsof the protocol provider.",
	"Method": "ProxyConnection create(ProtocolProviderServiceSipImpl pps){\r\n    if (pps.getAccountID().getAccountPropertyBoolean(PROXY_AUTO_CONFIG, true))\r\n        return new AutoProxyConnection((SipAccountIDImpl) pps.getAccountID(), pps.getDefaultTransport());\r\n    else\r\n        return new ManualProxyConnection((SipAccountIDImpl) pps.getAccountID());\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.call.MetaContactPhoneUtil.checkContactPhones",
	"Comment": "checking contact for phones.return false if there are listeners added for the contactand we need to stop executions cause listener will be used to be informedfor result.",
	"Method": "boolean checkContactPhones(Contact contact){\r\n    if (!phones.containsKey(contact)) {\r\n        List<String> phones = getPhones(contact);\r\n        if (phones == null)\r\n            return false;\r\n        isVideoCallEnabled(contact);\r\n        isDesktopSharingEnabled(contact);\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ChatRoomMemberListPanel.removeContact",
	"Comment": "removes the given chatcontact from the list of chat contacts.",
	"Method": "void removeContact(ChatContact<?> chatContact){\r\n    memberListModel.removeElement(chatContact);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.JabberSlickFixture.deleteGroups",
	"Comment": "delete all groups and contacts for the given persistent presence op. set.",
	"Method": "void deleteGroups(OperationSetPersistentPresence opSetPersPresence){\r\n    ContactGroup rootGroup = opSetPersPresence.getServerStoredContactListRoot();\r\n    Vector<ContactGroup> groupsToRemove = new Vector<ContactGroup>();\r\n    Iterator<ContactGroup> iter = rootGroup.subgroups();\r\n    while (iter.hasNext()) {\r\n        groupsToRemove.add(iter.next());\r\n    }\r\n    iter = groupsToRemove.iterator();\r\n    while (iter.hasNext()) {\r\n        ContactGroup item = iter.next();\r\n        opSetPersPresence.removeServerStoredContactGroup(item);\r\n    }\r\n    Vector<Contact> contactsToRemove = new Vector<Contact>();\r\n    Iterator<Contact> iter2 = rootGroup.contacts();\r\n    while (iter2.hasNext()) {\r\n        contactsToRemove.add(iter2.next());\r\n    }\r\n    iter2 = contactsToRemove.iterator();\r\n    while (iter2.hasNext()) {\r\n        opSetPersPresence.unsubscribe(iter2.next());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl.setLatestInviteTransaction",
	"Comment": "sets the transaction instance that contains the invite which startedthis call.",
	"Method": "void setLatestInviteTransaction(Transaction transaction){\r\n    this.latestInviteTransaction = transaction;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetMultiUserChatJabberImpl.getExistingChatRooms",
	"Comment": "returns the list of strings indicating chat roomscurrently available on the server that this protocol provider isconnected to.",
	"Method": "List<String> getExistingChatRooms(){\r\n    assertSupportedAndConnected();\r\n    List<String> list = new LinkedList<String>();\r\n    Iterator<String> serviceNames = null;\r\n    try {\r\n        serviceNames = MultiUserChat.getServiceNames(getXmppConnection()).iterator();\r\n    } catch (XMPPException ex) {\r\n        throw new OperationFailedException(\"Failed to retrieve Jabber conference service names\", OperationFailedException.GENERAL_ERROR, ex);\r\n    }\r\n    while (serviceNames.hasNext()) {\r\n        String serviceName = serviceNames.next();\r\n        List<HostedRoom> roomsOnThisService = new LinkedList<HostedRoom>();\r\n        try {\r\n            roomsOnThisService.addAll(MultiUserChat.getHostedRooms(getXmppConnection(), serviceName));\r\n        } catch (XMPPException ex) {\r\n            logger.error(\"Failed to retrieve rooms for serviceName=\" + serviceName, ex);\r\n            continue;\r\n        }\r\n        Iterator<HostedRoom> serviceRoomsIter = roomsOnThisService.iterator();\r\n        while (serviceRoomsIter.hasNext()) list.add(serviceRoomsIter.next().getJid());\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.spellcheck.Resources.getResources",
	"Comment": "returns the resourcemanagementservice through which we obtainresources like images and localized texts.",
	"Method": "ResourceManagementService getResources(){\r\n    if (resourceService != null)\r\n        return resourceService;\r\n    ServiceReference configServiceRef = SpellCheckActivator.bundleContext.getServiceReference(ResourceManagementService.class.getName());\r\n    resourceService = (ResourceManagementService) SpellCheckActivator.bundleContext.getService(configServiceRef);\r\n    return resourceService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.DesktopSharingMouseAndKeyboardListener.mouseMoved",
	"Comment": "invoked when the mouse cursor has been movedonto a component but no buttons have been pushed.",
	"Method": "void mouseMoved(MouseEvent e){\r\n    if (desktopSharingClient != null) {\r\n        desktopSharingClient.sendMouseEvent(callPeer, e, videoComponent.getSize());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageSourceContactQuery.fireContactRemoved",
	"Comment": "notifies the contactquerylisteners registered with thiscontactquery that a sourcecontact has beenremoved.note that object may not be messagesourcecontact, but itsequals method can return true for message source contact instances.",
	"Method": "void fireContactRemoved(Object srcObj){\r\n    for (SourceContact msc : getQueryResults()) {\r\n        if (srcObj.equals(msc)) {\r\n            super.fireContactRemoved(msc);\r\n            break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractChatRoom.getCachedConferenceDescriptionSize",
	"Comment": "returns the number of cached conferencedescription instances.",
	"Method": "int getCachedConferenceDescriptionSize(){\r\n    return cachedConferenceDescriptions.size();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetServerStoredAccountInfoSipImpl.getDetails",
	"Comment": "returns an iterator over all details that are instances of exactly thesame class as the one specified.",
	"Method": "Iterator<GenericDetail> getDetails(Class<? extends GenericDetail> detailClass){\r\n    List<GenericDetail> result = new ArrayList<GenericDetail>();\r\n    if (ImageDetail.class.isAssignableFrom(detailClass) && isImageDetailSupported()) {\r\n        ImageDetail imageDetail = getAccountImage();\r\n        if (imageDetail != null) {\r\n            result.add(getAccountImage());\r\n        }\r\n    } else if (DisplayNameDetail.class.isAssignableFrom(detailClass) && displayNameDetail != null) {\r\n        result.add(displayNameDetail);\r\n    }\r\n    return result.iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipRegistrarConnection.isRegistrarless",
	"Comment": "returns true if this is a fake connection that is not actually using a registrar. this method should be overridden in sipregistrarlessconnection and return true in there.",
	"Method": "boolean isRegistrarless(){\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.ChatRoomMemberRoleChangeEvent.getPreviousRole",
	"Comment": "returns the previous role the member that this event is about had.",
	"Method": "ChatRoomMemberRole getPreviousRole(){\r\n    return previousRole;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.mailnotification.MailThreadInfo.getUnreadSenderCount",
	"Comment": "returns the number of people that have been posting in this thread andthat we have unread messages from.",
	"Method": "int getUnreadSenderCount(){\r\n    Iterator<Sender> senders = senders();\r\n    int count = 0;\r\n    while (senders.hasNext()) {\r\n        if (senders.next().unread)\r\n            count++;\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommTabbedPane.detachTab",
	"Comment": "detaches the index tab in a separate frame. when the frameis closed, the tab is automatically reinserted into the tabbedpane.",
	"Method": "void detachTab(int index){\r\n    if (index < 0 || index >= getTabCount())\r\n        return;\r\n    final int tabIndex = index;\r\n    final JComponent c = (JComponent) getComponentAt(tabIndex);\r\n    final Icon icon = getIconAt(tabIndex);\r\n    final String title = getTitleAt(tabIndex);\r\n    final String toolTip = getToolTipTextAt(tabIndex);\r\n    final Border border = c.getBorder();\r\n    final JFrame frame = new SIPCommFrame() {\r\n        private static final long serialVersionUID = 0L;\r\n        @Override\r\n        protected void close(boolean isEscaped) {\r\n            if (isEscaped)\r\n                return;\r\n            dispose();\r\n            insertTab(title, icon, c, toolTip, Math.min(tabIndex, getTabCount()));\r\n            c.setBorder(border);\r\n            setSelectedComponent(c);\r\n        }\r\n    };\r\n    Window parentWindow = SwingUtilities.windowForComponent(this);\r\n    removeTabAt(index);\r\n    c.setPreferredSize(c.getSize());\r\n    frame.setTitle(title);\r\n    frame.getContentPane().add(c);\r\n    frame.setLocation(parentWindow.getLocation());\r\n    frame.pack();\r\n    WindowFocusListener windowFocusListener = new WindowFocusListener() {\r\n        long start;\r\n        long end;\r\n        public void windowGainedFocus(WindowEvent e) {\r\n            start = System.currentTimeMillis();\r\n        }\r\n        public void windowLostFocus(WindowEvent e) {\r\n            end = System.currentTimeMillis();\r\n            long elapsed = end - start;\r\n            if (elapsed < 100)\r\n                frame.toFront();\r\n            frame.removeWindowFocusListener(this);\r\n        }\r\n    };\r\n    frame.addWindowFocusListener(windowFocusListener);\r\n    frame.setVisible(true);\r\n    frame.toFront();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommTabbedPane.detachTab",
	"Comment": "detaches the index tab in a separate frame. when the frameis closed, the tab is automatically reinserted into the tabbedpane.",
	"Method": "void detachTab(int index){\r\n    if (isEscaped)\r\n        return;\r\n    dispose();\r\n    insertTab(title, icon, c, toolTip, Math.min(tabIndex, getTabCount()));\r\n    c.setBorder(border);\r\n    setSelectedComponent(c);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommTabbedPane.detachTab",
	"Comment": "detaches the index tab in a separate frame. when the frameis closed, the tab is automatically reinserted into the tabbedpane.",
	"Method": "void detachTab(int index){\r\n    start = System.currentTimeMillis();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommTabbedPane.detachTab",
	"Comment": "detaches the index tab in a separate frame. when the frameis closed, the tab is automatically reinserted into the tabbedpane.",
	"Method": "void detachTab(int index){\r\n    end = System.currentTimeMillis();\r\n    long elapsed = end - start;\r\n    if (elapsed < 100)\r\n        frame.toFront();\r\n    frame.removeWindowFocusListener(this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.TestAccountUninstallationPersistence.testAccountUninstallationPersistence",
	"Comment": "retrieves a reference to the jabber bundle, stops it and uninstalls it andthen reinstalls it in order to make sure that accounts are not reloadedonce removed.",
	"Method": "void testAccountUninstallationPersistence(){\r\n    Bundle providerBundle = JabberSlickFixture.providerBundle;\r\n    providerBundle.stop();\r\n    assertTrue(\"Couldn't stop the protocol provider bundle. State was \" + providerBundle.getState(), Bundle.ACTIVE != providerBundle.getState() && Bundle.STOPPING != providerBundle.getState());\r\n    providerBundle.uninstall();\r\n    assertEquals(\"Couldn't stop the protocol provider bundle.\", Bundle.UNINSTALLED, providerBundle.getState());\r\n    providerBundle = JabberSlickFixture.bc.installBundle(providerBundle.getLocation());\r\n    assertEquals(\"Couldn't re-install protocol provider bundle.\", Bundle.INSTALLED, providerBundle.getState());\r\n    AccountManagerUtils.startBundleAndWaitStoredAccountsLoaded(JabberSlickFixture.bc, providerBundle, ProtocolNames.JABBER);\r\n    assertEquals(\"Couldn't re-start protocol provider bundle.\", Bundle.ACTIVE, providerBundle.getState());\r\n    ServiceReference[] jabberProviderRefs = null;\r\n    try {\r\n        jabberProviderRefs = JabberSlickFixture.bc.getServiceReferences(ProtocolProviderService.class.getName(), \"(\" + ProtocolProviderFactory.PROTOCOL + \"=\" + ProtocolNames.JABBER + \")\");\r\n    } catch (InvalidSyntaxException ex) {\r\n        fail(\"We apparently got our filter wrong \" + ex.getMessage());\r\n    }\r\n    assertTrue(\"A Jabber Protocol Provider Service was still regged as an \" + \"osgi service after it was explicitly uninstalled\", jabberProviderRefs == null || jabberProviderRefs.length == 0);\r\n    ServiceReference confReference = JabberSlickFixture.bc.getServiceReference(ConfigurationService.class.getName());\r\n    ConfigurationService configurationService = (ConfigurationService) JabberSlickFixture.bc.getService(confReference);\r\n    configurationService.purgeStoredConfiguration();\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.sip.TestOperationSetServerStoredInfo.testReplaceInfo",
	"Comment": "tests replacing info. puts the image to the server by using sipcommunicator interfaces, replace it and then gets it by using xcapclient.",
	"Method": "void testReplaceInfo(){\r\n    byte[] imageContent1 = TestOperationSetServerStoredInfoData.IMAGE_CONTENT_1;\r\n    byte[] imageContent2 = TestOperationSetServerStoredInfoData.IMAGE_CONTENT_2;\r\n    ServerStoredDetails.ImageDetail imageDetail1 = new ServerStoredDetails.ImageDetail(null, imageContent1);\r\n    ServerStoredDetails.ImageDetail imageDetail2 = new ServerStoredDetails.ImageDetail(null, imageContent2);\r\n    opSetServerStoredAccountInfo.addDetail(imageDetail1);\r\n    boolean replaceResult = opSetServerStoredAccountInfo.replaceDetail(imageDetail1, imageDetail2);\r\n    assertTrue(\"The result of replace operation cannot be false\", replaceResult);\r\n    Iterator<ServerStoredDetails.GenericDetail> storedDetails = opSetServerStoredAccountInfo.getDetails(ServerStoredDetails.ImageDetail.class);\r\n    assertNotNull(\"Stored details cannot be null\", storedDetails);\r\n    assertTrue(\"Stored details doesn't have ImageDetail\", storedDetails.hasNext());\r\n    ServerStoredDetails.GenericDetail imageDetail = storedDetails.next();\r\n    assertTrue(\"Stored details is not ImageDetail\", imageDetail instanceof ServerStoredDetails.ImageDetail);\r\n    byte[] savedContent = ((ServerStoredDetails.ImageDetail) imageDetail).getBytes();\r\n    assertEquals(\"The ImageDetail we set is not set or not read properly\", imageContent2.length, savedContent.length);\r\n    for (int i = 0; i < imageContent2.length; i++) {\r\n        assertSame(\"The ImageDetail we set has not the same content\", imageContent2[i], savedContent[i]);\r\n    }\r\n    ContentType presContent = xCapClient.getPresContent(ServerStoredContactListSipImpl.PRES_CONTENT_IMAGE_NAME);\r\n    assertNotNull(\"Pres-content cannot be null\", presContent);\r\n    assertNotNull(\"Pres-content data cannot be null\", presContent.getData());\r\n    assertNotNull(\"Pres-content data value cannot be null\", presContent.getData().getValue());\r\n    byte[] serverContent = Base64.decode(presContent.getData().getValue());\r\n    assertEquals(\"The ImageDetail we set is not set or not read properly\", imageContent2.length, serverContent.length);\r\n    for (int i = 0; i < imageContent2.length; i++) {\r\n        assertSame(\"The ImageDetail we set has not the same content\", imageContent2[i], serverContent[i]);\r\n    }\r\n    opSetServerStoredAccountInfo.removeDetail(imageDetail2);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.MainFrame.addProviderContactHandler",
	"Comment": "adds the given contacthandler to handle contact events for thegiven protocolprovider.",
	"Method": "void addProviderContactHandler(ProtocolProviderService protocolProvider,ContactEventHandler contactHandler){\r\n    providerContactHandlers.put(protocolProvider, contactHandler);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.thunderbird.ThunderbirdContactQuery.readEntry",
	"Comment": "processes a database row by matching it against the query and adding itto the result set if it matched.",
	"Method": "void readEntry(Row r){\r\n    boolean hadMatch = false;\r\n    for (Alias value : r.getAliases().values()) {\r\n        if (value != null && (super.query.matcher(value.getValue()).find() || super.phoneNumberMatches(value.getValue()))) {\r\n            hadMatch = true;\r\n            break;\r\n        }\r\n    }\r\n    if (!hadMatch) {\r\n        return;\r\n    }\r\n    List<ContactDetail> details = new LinkedList<ContactDetail>();\r\n    for (String email : getPropertySet(r, \"PrimaryEmail\", \"SecondEmail\", \"DefaultEmail\")) {\r\n        ContactDetail detail = new ContactDetail(email, Category.Email);\r\n        detail.addSupportedOpSet(OperationSetPersistentPresence.class);\r\n        details.add(detail);\r\n    }\r\n    this.addPhoneDetail(details, r, \"HomePhone\", SubCategory.Home);\r\n    this.addPhoneDetail(details, r, \"WorkPhone\", SubCategory.Work);\r\n    this.addPhoneDetail(details, r, \"CellularNumber\", SubCategory.Mobile);\r\n    String displayName = r.getValue(\"DisplayName\");\r\n    if (StringUtils.isNullOrEmpty(displayName, true)) {\r\n        displayName = r.getValue(\"LastName\");\r\n        if (displayName != null) {\r\n            displayName = displayName.trim();\r\n        }\r\n        String firstName = r.getValue(\"FirstName\");\r\n        if (!StringUtils.isNullOrEmpty(firstName, true)) {\r\n            displayName = firstName + \" \" + displayName;\r\n        }\r\n    }\r\n    GenericSourceContact sc = new GenericSourceContact(super.getContactSource(), displayName, details);\r\n    addQueryResult(sc);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.contactinfo.ContactInfoActivator.getConfigService",
	"Comment": "returns a reference to a configurationservice implementation currentlyregistered in the bundle context or null if no such implementation wasfound.",
	"Method": "ConfigurationService getConfigService(){\r\n    return ServiceUtils.getService(bundleContext, ConfigurationService.class);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractOperationSetBasicInstantMessaging.messageTransform",
	"Comment": "transform provided source event by processing transform layers insequence.",
	"Method": "EventObject[] messageTransform(EventObject evt,MessageEventType eventType){\r\n    if (evt == null) {\r\n        return new EventObject[0];\r\n    }\r\n    ProtocolProviderService protocolProvider;\r\n    switch(eventType) {\r\n        case MessageDelivered:\r\n            protocolProvider = ((MessageDeliveredEvent) evt).getDestinationContact().getProtocolProvider();\r\n            break;\r\n        case MessageDeliveryFailed:\r\n            protocolProvider = ((MessageDeliveryFailedEvent) evt).getDestinationContact().getProtocolProvider();\r\n            break;\r\n        case MessageDeliveryPending:\r\n            protocolProvider = ((MessageDeliveredEvent) evt).getDestinationContact().getProtocolProvider();\r\n            break;\r\n        case MessageReceived:\r\n            protocolProvider = ((MessageReceivedEvent) evt).getSourceContact().getProtocolProvider();\r\n            break;\r\n        default:\r\n            return new EventObject[] { evt };\r\n    }\r\n    OperationSetInstantMessageTransformImpl opSetMessageTransform = (OperationSetInstantMessageTransformImpl) protocolProvider.getOperationSet(OperationSetInstantMessageTransform.class);\r\n    if (opSetMessageTransform == null)\r\n        return new EventObject[] { evt };\r\n    final LinkedList<EventObject> current = new LinkedList<EventObject>();\r\n    current.add(evt);\r\n    final LinkedList<EventObject> next = new LinkedList<EventObject>();\r\n    for (Map.Entry<Integer, Vector<TransformLayer>> entry : opSetMessageTransform.transformLayers.entrySet()) {\r\n        for (TransformLayer transformLayer : entry.getValue()) {\r\n            next.clear();\r\n            while (!current.isEmpty()) {\r\n                final EventObject event = current.remove();\r\n                switch(eventType) {\r\n                    case MessageDelivered:\r\n                        MessageDeliveredEvent transformedDelivered = transformLayer.messageDelivered((MessageDeliveredEvent) event);\r\n                        if (transformedDelivered != null) {\r\n                            next.add(transformedDelivered);\r\n                        }\r\n                        break;\r\n                    case MessageDeliveryPending:\r\n                        MessageDeliveredEvent[] evts = transformLayer.messageDeliveryPending((MessageDeliveredEvent) event);\r\n                        for (MessageDeliveredEvent mde : evts) {\r\n                            if (mde != null) {\r\n                                next.add(mde);\r\n                            }\r\n                        }\r\n                        break;\r\n                    case MessageDeliveryFailed:\r\n                        MessageDeliveryFailedEvent transformedDeliveryFailed = transformLayer.messageDeliveryFailed((MessageDeliveryFailedEvent) event);\r\n                        if (transformedDeliveryFailed != null) {\r\n                            next.add(transformedDeliveryFailed);\r\n                        }\r\n                        break;\r\n                    case MessageReceived:\r\n                        MessageReceivedEvent transformedReceived = transformLayer.messageReceived((MessageReceivedEvent) event);\r\n                        if (transformedReceived != null) {\r\n                            next.add(transformedReceived);\r\n                        }\r\n                        break;\r\n                    default:\r\n                        next.add(event);\r\n                        break;\r\n                }\r\n            }\r\n            current.addAll(next);\r\n        }\r\n    }\r\n    return current.toArray(new EventObject[current.size()]);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ContactListModel.contentChanged",
	"Comment": "informs interested listeners that the content has changed of the cellsgiven by the range from startindex to endindex.",
	"Method": "void contentChanged(int startIndex,int endIndex){\r\n    fireContentsChanged(this, startIndex, endIndex);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.GenericUIContactImpl.getContactCustomActionButtons",
	"Comment": "returns all custom action buttons for this notification contact.",
	"Method": "Collection<SIPCommButton> getContactCustomActionButtons(){\r\n    return customActionButtons;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.MetaUIContact.getAvatar",
	"Comment": "gets the avatar of a specific uicontact in the form of animageicon value.",
	"Method": "byte[] getAvatar(){\r\n    return metaContact.getAvatar();\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.call.MetaContactPhoneUtil.checkMetaContactVideoPhones",
	"Comment": "checking all contacts for the metacontact.return false if there are listeners added for a contactand we need to stop executions cause listener will be used to be informedfor result.",
	"Method": "boolean checkMetaContactVideoPhones(DetailsResponseListener l){\r\n    Iterator<Contact> contactIterator = metaContact.getContacts();\r\n    while (contactIterator.hasNext()) {\r\n        Contact contact = contactIterator.next();\r\n        if (videoPhones.containsKey(contact))\r\n            continue;\r\n        List<String> phones = getVideoPhones(contact, l);\r\n        if (phones == null)\r\n            return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.AbstractPacketExtension.getAttributeAsString",
	"Comment": "returns the string value of the attribute with the specifiedname.",
	"Method": "String getAttributeAsString(String attribute){\r\n    synchronized (attributes) {\r\n        Object attributeVal = attributes.get(attribute);\r\n        return attributeVal == null ? null : attributeVal.toString();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockContact.getPersistentData",
	"Comment": "returns null as no persistent data is required and the contact address issufficient for restoring the contact.",
	"Method": "String getPersistentData(){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetBasicInstantMessagingIcqImpl.isContentTypeSupported",
	"Comment": "determines wheter the protocol supports the supplied content type",
	"Method": "boolean isContentTypeSupported(String contentType){\r\n    if (contentType.equals(DEFAULT_MIME_TYPE) || (contentType.equals(HTML_MIME_TYPE)))\r\n        return true;\r\n    else\r\n        return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.neomedia.AbstractDeviceConfigurationListener.dispose",
	"Comment": "releases the resources acquired by this instance throughout its lifetime,uninstalls the listeners it has installed and, generally, prepares it forgarbage collection.",
	"Method": "void dispose(){\r\n    addOrRemovePopupMessageListener(false);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ContactGroupSipImpl.addSubgroup",
	"Comment": "adds the specified contact group to the contained by this group.",
	"Method": "void addSubgroup(ContactGroupSipImpl subgroup){\r\n    this.subGroups.add(subgroup);\r\n    subgroup.setParentGroup(this);\r\n    if (subgroup.isPersistent()) {\r\n        this.list.getLists().add(subgroup.getList());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatConversationPanel.getContactAvatar",
	"Comment": "returns the avatar corresponding to the account of the given protocolprovider.",
	"Method": "String getContactAvatar(ProtocolProviderService protocolProvider,String contactAddress,String getContactAvatar,ProtocolProviderService protocolProvider){\r\n    String avatarPath = AvatarCacheUtils.getCachedAvatarPath(protocolProvider);\r\n    File avatarFile;\r\n    try {\r\n        avatarFile = GuiActivator.getFileAccessService().getPrivatePersistentFile(avatarPath, FileCategory.CACHE);\r\n    } catch (Exception e) {\r\n        return null;\r\n    }\r\n    if (avatarFile.exists() && avatarFile.length() > 0)\r\n        return \"file:\" + avatarFile.getAbsolutePath();\r\n    else\r\n        return GuiActivator.getResources().getImageURL(\"service.gui.DEFAULT_USER_PHOTO_SMALL\").toString();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.msoutlook.MsOutlookAddrBookContactQuery.getContactDetails",
	"Comment": "gets the contactdetails to be set on a sourcecontactwhich is to represent an abperson.",
	"Method": "List<ContactDetail> getContactDetails(Object[] values){\r\n    List<Class<? extends OperationSet>> supportedOpSets = new ArrayList<Class<? extends OperationSet>>(2);\r\n    supportedOpSets.add(OperationSetBasicTelephony.class);\r\n    supportedOpSets.add(OperationSetPersistentPresence.class);\r\n    List<ContactDetail> contactDetails = new LinkedList<ContactDetail>();\r\n    for (int i = 0; i < CONTACT_DETAIL_PROP_INDEXES.length; i++) {\r\n        int property = CONTACT_DETAIL_PROP_INDEXES[i];\r\n        Object value = values[property];\r\n        if (value instanceof String) {\r\n            String stringValue = (String) value;\r\n            if (stringValue.length() != 0) {\r\n                if (isPhoneNumber(property))\r\n                    stringValue = AddrBookActivator.getPhoneNumberI18nService().normalize(stringValue);\r\n                MsOutlookAddrBookContactDetail contactDetail = new MsOutlookAddrBookContactDetail(stringValue, getCategory(property), getSubCategories(property), MAPI_MAILUSER_PROP_IDS[property]);\r\n                for (int j = 0; j < CONTACT_OPERATION_SET_ABLE_PROP_INDEXES.length; ++j) {\r\n                    if (property == CONTACT_OPERATION_SET_ABLE_PROP_INDEXES[j]) {\r\n                        contactDetail.setSupportedOpSets(supportedOpSets);\r\n                        j = CONTACT_OPERATION_SET_ABLE_PROP_INDEXES.length;\r\n                    }\r\n                }\r\n                contactDetails.add(contactDetail);\r\n            }\r\n        }\r\n    }\r\n    return contactDetails;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.AbstractOperationSetTelephonyConferencing.callStateChanged",
	"Comment": "notifies this callchangelistener that a specific callhas changed its state. does nothing.",
	"Method": "void callStateChanged(CallChangeEvent event){\r\n    if (CallChangeEvent.CALL_PARTICIPANTS_CHANGE.equals(event.getPropertyName())) {\r\n        notifyAll(event.getSourceCall());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.AbstractOperationSetVideoTelephony.createVideoCall",
	"Comment": "create a new video call and invite the specified callpeer to it withinitial video setting.",
	"Method": "Call createVideoCall(String uri,QualityPreset qualityPreferences,Call createVideoCall,Contact callee,QualityPreset qualityPreferences){\r\n    return createVideoCall(callee);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.TransportManagerJabberImpl.removeContent",
	"Comment": "removes a content with a specific name from a specific collection ofcontents and closes any associated streamconnector.",
	"Method": "void removeContent(String name,ContentPacketExtension removeContent,Iterable<ContentPacketExtension> contents,String name){\r\n    for (Iterator<ContentPacketExtension> contentIter = contents.iterator(); contentIter.hasNext(); ) {\r\n        ContentPacketExtension content = contentIter.next();\r\n        if (name.equals(content.getName())) {\r\n            contentIter.remove();\r\n            MediaType mediaType = JingleUtils.getMediaType(content);\r\n            if (mediaType != null) {\r\n                closeStreamConnector(mediaType);\r\n            }\r\n            return content;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.UINotificationManager.removeNotificationListener",
	"Comment": "removes the given uinotificationlistener from the list oflisteners that are notified on any changes in missed calls count.",
	"Method": "void removeNotificationListener(UINotificationListener l){\r\n    synchronized (l) {\r\n        notificationListeners.remove(l);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.RtpDescriptionPacketExtension.addChildExtension",
	"Comment": "casts childextension to one of the extensions allowed here andsets the corresponding field.",
	"Method": "void addChildExtension(PacketExtension childExtension){\r\n    if (childExtension instanceof PayloadTypePacketExtension)\r\n        this.addPayloadType((PayloadTypePacketExtension) childExtension);\r\n    else if (childExtension instanceof EncryptionPacketExtension)\r\n        this.setEncryption((EncryptionPacketExtension) childExtension);\r\n    else if (childExtension instanceof BandwidthPacketExtension)\r\n        this.setBandwidth((BandwidthPacketExtension) childExtension);\r\n    else if (childExtension instanceof RTPHdrExtPacketExtension)\r\n        this.addExtmap((RTPHdrExtPacketExtension) childExtension);\r\n    else\r\n        super.addChildExtension(childExtension);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.messagecorrection.MessageCorrectionExtensionProvider.parseExtension",
	"Comment": "creates a new correction extension by parsing an xml element.",
	"Method": "PacketExtension parseExtension(XmlPullParser parser){\r\n    MessageCorrectionExtension res = new MessageCorrectionExtension(null);\r\n    do {\r\n        if (parser.getEventType() == XmlPullParser.START_TAG) {\r\n            res.setCorrectedMessageUID(parser.getAttributeValue(null, MessageCorrectionExtension.ID_ATTRIBUTE_NAME));\r\n        }\r\n    } while (parser.next() != XmlPullParser.END_TAG);\r\n    return res;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MclStorageManager.createMetaContactGroupNode",
	"Comment": "creates a meta contact group node element corresponding tometagroup.",
	"Method": "Element createMetaContactGroupNode(MetaContactGroup metaGroup){\r\n    Element metaGroupElement = this.contactListDocument.createElement(GROUP_NODE_NAME);\r\n    metaGroupElement.setAttribute(GROUP_NAME_ATTR_NAME, metaGroup.getGroupName());\r\n    metaGroupElement.setAttribute(UID_ATTR_NAME, metaGroup.getMetaUID());\r\n    Element protoGroupsElement = this.contactListDocument.createElement(PROTO_GROUPS_NODE_NAME);\r\n    metaGroupElement.appendChild(protoGroupsElement);\r\n    Iterator<ContactGroup> protoGroups = metaGroup.getContactGroups();\r\n    while (protoGroups.hasNext()) {\r\n        ContactGroup group = protoGroups.next();\r\n        if (!group.isPersistent())\r\n            continue;\r\n        Element protoGroupEl = createProtoContactGroupNode(group);\r\n        protoGroupsElement.appendChild(protoGroupEl);\r\n    }\r\n    Element subgroupsElement = this.contactListDocument.createElement(SUBGROUPS_NODE_NAME);\r\n    metaGroupElement.appendChild(subgroupsElement);\r\n    Iterator<MetaContactGroup> subgroups = metaGroup.getSubgroups();\r\n    while (subgroups.hasNext()) {\r\n        MetaContactGroup subgroup = subgroups.next();\r\n        Element subgroupEl = createMetaContactGroupNode(subgroup);\r\n        subgroupsElement.appendChild(subgroupEl);\r\n    }\r\n    Element childContactsElement = this.contactListDocument.createElement(CHILD_CONTACTS_NODE_NAME);\r\n    metaGroupElement.appendChild(childContactsElement);\r\n    Iterator<MetaContact> childContacts = metaGroup.getChildContacts();\r\n    while (childContacts.hasNext()) {\r\n        MetaContact metaContact = childContacts.next();\r\n        Element metaContactEl = createMetaContactNode(metaContact);\r\n        childContactsElement.appendChild(metaContactEl);\r\n    }\r\n    return metaGroupElement;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.call.CallPeerAdapter.dispose",
	"Comment": "removes the listeners implemented by this instance from the associatedcallpeer and prepares it for garbage collection.",
	"Method": "void dispose(){\r\n    peer.removeCallPeerListener(this);\r\n    peer.removeCallPeerSecurityListener(this);\r\n    peer.removePropertyChangeListener(this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageHistoryServiceImpl.findByKeyword",
	"Comment": "returns all the messages exchangedin the supplied chat room having the given keyword",
	"Method": "Collection<EventObject> findByKeyword(MetaContact contact,String keyword,Collection<EventObject> findByKeyword,MetaContact contact,String keyword,boolean caseSensitive,Collection<EventObject> findByKeyword,ChatRoom room,String keyword,Collection<EventObject> findByKeyword,ChatRoom room,String keyword,boolean caseSensitive){\r\n    HashSet<EventObject> result = new HashSet<EventObject>();\r\n    try {\r\n        HistoryReader reader = this.getHistoryForMultiChat(room).getReader();\r\n        addHistorySearchProgressListeners(reader, 1);\r\n        Iterator<HistoryRecord> recs = reader.findByKeyword(keyword, SEARCH_FIELD, caseSensitive);\r\n        while (recs.hasNext()) {\r\n            result.add(convertHistoryRecordToMessageEvent(recs.next(), room));\r\n        }\r\n        removeHistorySearchProgressListeners(reader);\r\n    } catch (IOException e) {\r\n        logger.error(\"Could not read history\", e);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetServerStoredAccountInfoIcqImpl.getAllAvailableDetails",
	"Comment": "returns all details currently available and set for our account.",
	"Method": "Iterator<GenericDetail> getAllAvailableDetails(){\r\n    assertConnected();\r\n    List<GenericDetail> ds = infoRetreiver.getContactDetails(uin);\r\n    GenericDetail img = getImage();\r\n    if (img != null)\r\n        ds.add(img);\r\n    return ds.iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.colibri.ColibriBuilder.getColibriChannel",
	"Comment": "finds the first channel in localchannels info for givencontentname.",
	"Method": "ColibriConferenceIQ.ChannelCommon getColibriChannel(ColibriConferenceIQ localChannels,String contentName){\r\n    ColibriConferenceIQ.Content content = localChannels.getContent(contentName);\r\n    if (content == null) {\r\n        return null;\r\n    }\r\n    if (content.getChannelCount() > 0) {\r\n        return content.getChannel(0);\r\n    }\r\n    if (content.getSctpConnections().size() > 0) {\r\n        return content.getSctpConnections().get(0);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.ircaccregwizz.IrcAccountRegistrationWizard.getIcon",
	"Comment": "implements the accountregistrationwizard.geticon method.returns the icon to be used for this wizard.",
	"Method": "byte[] getIcon(){\r\n    return Resources.getImage(Resources.IRC_LOGO);\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.launchutils.LaunchArgHandler.getApplicationName",
	"Comment": "returns the name of the application. that should be jitsimost of the time but who knows ..",
	"Method": "String getApplicationName(){\r\n    String name = versionProperties.getProperty(PNAME_APPLICATION_NAME);\r\n    return name == null ? \"Jitsi\" : name;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler.removeAndCleanupOtherSrtpControls",
	"Comment": "removes from this instance and cleans up the srtpcontrol whichare not of a specific srtpcontroltype.",
	"Method": "void removeAndCleanupOtherSrtpControls(MediaType mediaType,SrtpControlType srtpControlType){\r\n    SrtpControls srtpControls = getSrtpControls();\r\n    for (SrtpControlType i : SrtpControlType.values()) {\r\n        if (!i.equals(srtpControlType)) {\r\n            SrtpControl e = srtpControls.remove(mediaType, i);\r\n            if (e != null)\r\n                e.cleanup(null);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.pluginmanager.PluginManagerPanel.initSystemBundleCheckBox",
	"Comment": "initializes the check box used to show or hide system bundles from thelist.",
	"Method": "void initSystemBundleCheckBox(){\r\n    String showSystemBundlesProp = PluginManagerActivator.getConfigurationService().getString(\"net.java.sip.communicator.plugin.pluginManager.showSystemBundles\");\r\n    if (showSystemBundlesProp != null) {\r\n        boolean isShowSystemBundles = new Boolean(showSystemBundlesProp).booleanValue();\r\n        this.showSysBundlesCheckBox.setSelected(isShowSystemBundles);\r\n        ((PluginTableModel) pluginTable.getModel()).setShowSystemBundles(isShowSystemBundles);\r\n    }\r\n    this.showSysBundlesCheckBox.addChangeListener(new ShowSystemBundlesChangeListener());\r\n    JPanel checkBoxPanel = new TransparentPanel(new FlowLayout(FlowLayout.LEFT));\r\n    checkBoxPanel.add(showSysBundlesCheckBox);\r\n    this.add(checkBoxPanel, BorderLayout.SOUTH);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.notifsource.NotificationContact.getNotificationMessage",
	"Comment": "returns the notification message corresponding to this notificationcontact.",
	"Method": "NotificationMessage getNotificationMessage(){\r\n    return notificationMessage;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.UtilActivator.getSystrayService",
	"Comment": "gets the systrayservice instance registered in thebundlecontext of the utilactivator.",
	"Method": "SystrayService getSystrayService(){\r\n    if (systrayService == null)\r\n        systrayService = ServiceUtils.getService(bundleContext, SystrayService.class);\r\n    return systrayService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ContactJabberImpl.isMobile",
	"Comment": "whether contact is mobile one. logged in from mobile device.",
	"Method": "boolean isMobile(){\r\n    if (!getPresenceStatus().isOnline())\r\n        return false;\r\n    return mobile;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.CallPeerGibberishImpl.removeStreamSoundLevelListener",
	"Comment": "removes a specific soundlevellistener of the list oflisteners interested in and notified about changes in stream sound levelrelated information.",
	"Method": "void removeStreamSoundLevelListener(SoundLevelListener listener){\r\n    synchronized (soundLevelListeners) {\r\n        soundLevelListeners.remove(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.EventPackageUtils.processByeThenIsDialogAlive",
	"Comment": "processes a bye request in a specific dialog for thepurposes of subscription associations and returns an indicator whichdetermines whether the specified dialog should still be considered aliveafter the processing of the bye request.",
	"Method": "boolean processByeThenIsDialogAlive(Dialog dialog){\r\n    synchronized (dialog) {\r\n        DialogApplicationData applicationData = (DialogApplicationData) SipApplicationData.getApplicationData(dialog, SipApplicationData.KEY_SUBSCRIPTIONS);\r\n        if (applicationData != null) {\r\n            applicationData.setByeProcessed(true);\r\n            if (applicationData.getSubscriptionCount() > 0) {\r\n                dialog.terminateOnBye(false);\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.conference.BasicConferenceParticipantPanel.setErrorReason",
	"Comment": "sets the reason of a call failure if one occurs. the renderer shoulddisplay this reason to the user.",
	"Method": "void setErrorReason(String reason){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                setErrorReason(reason);\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    if (errorMessageComponent == null) {\r\n        errorMessageComponent = new JTextPane();\r\n        JTextPane textPane = (JTextPane) errorMessageComponent;\r\n        textPane.setEditable(false);\r\n        textPane.setOpaque(false);\r\n        StyledDocument doc = textPane.getStyledDocument();\r\n        MutableAttributeSet standard = new SimpleAttributeSet();\r\n        StyleConstants.setFontFamily(standard, textPane.getFont().getFamily());\r\n        StyleConstants.setFontSize(standard, 12);\r\n        doc.setParagraphAttributes(0, 0, standard, true);\r\n        addToCenter(errorMessageComponent);\r\n        this.revalidate();\r\n    }\r\n    errorMessageComponent.setText(reason);\r\n    if (isVisible()) {\r\n        Window parentWindow = SwingUtilities.getWindowAncestor(errorMessageComponent);\r\n        if (parentWindow != null)\r\n            parentWindow.pack();\r\n        errorMessageComponent.repaint();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.conference.BasicConferenceParticipantPanel.setErrorReason",
	"Comment": "sets the reason of a call failure if one occurs. the renderer shoulddisplay this reason to the user.",
	"Method": "void setErrorReason(String reason){\r\n    setErrorReason(reason);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactGroupImpl.getContactGroup",
	"Comment": "returns a contact group encapsulated by this meta contact group, havingthe specified groupname and coming from the indicated ownerprovider.",
	"Method": "ContactGroup getContactGroup(String grpName,ProtocolProviderService ownerProvider){\r\n    Iterator<ContactGroup> encapsulatedGroups = getContactGroups();\r\n    while (encapsulatedGroups.hasNext()) {\r\n        ContactGroup group = encapsulatedGroups.next();\r\n        if (group.getGroupName().equals(grpName) && group.getProtocolProvider() == ownerProvider) {\r\n            return group;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.SessionRenewTest.testSessionRenewalNullCache",
	"Comment": "tests renewing a session id when sessions are not being cached.",
	"Method": "void testSessionRenewalNullCache(){\r\n    SessionCacheFactory cacheFactory = new NullSessionCacheFactory();\r\n    SessionDataStoreFactory storeFactory = new TestSessionDataStoreFactory();\r\n    _server = new TestServer(0, -1, -1, cacheFactory, storeFactory);\r\n    doTest(new RenewalVerifier());\r\n}"
}, {
	"Path": "io.lettuce.core.dynamic.support.MethodParameter.forMethodOrConstructor",
	"Comment": "create a new methodparameter for the given method or constructor.this is a convenience constructor for scenarios where a method or constructor reference is treated in a generic fashion.",
	"Method": "MethodParameter forMethodOrConstructor(Object methodOrConstructor,int parameterIndex){\r\n    if (methodOrConstructor instanceof Method) {\r\n        return new MethodParameter((Method) methodOrConstructor, parameterIndex);\r\n    } else if (methodOrConstructor instanceof Constructor) {\r\n        return new MethodParameter((Constructor<?>) methodOrConstructor, parameterIndex);\r\n    } else {\r\n        throw new IllegalArgumentException(\"Given object [\" + methodOrConstructor + \"] is neither a Method nor a Constructor\");\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactListServiceImpl.handleProviderRemoved",
	"Comment": "removes the specified provider from the list of currently known providersand ignores all the contacts that it has registered locally.",
	"Method": "void handleProviderRemoved(ProtocolProviderService provider){\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Removing protocol provider \" + provider);\r\n    this.currentlyInstalledProviders.remove(provider.getAccountID().getAccountUniqueID());\r\n    OperationSetPersistentPresence persPresOpSet = provider.getOperationSet(OperationSetPersistentPresence.class);\r\n    if (persPresOpSet != null) {\r\n        persPresOpSet.removeContactPresenceStatusListener(this);\r\n        persPresOpSet.removeSubscriptionListener(clSubscriptionEventHandler);\r\n        persPresOpSet.removeServerStoredGroupChangeListener(clGroupEventHandler);\r\n        ContactGroup rootGroup = persPresOpSet.getServerStoredContactListRoot();\r\n        Iterator<ContactGroup> subgroups = rootGroup.subgroups();\r\n        while (subgroups.hasNext()) {\r\n            ContactGroup group = subgroups.next();\r\n            this.removeContactGroupFromMetaContactGroup((MetaContactGroupImpl) findMetaContactGroupByContactGroup(group), group, provider);\r\n        }\r\n        this.removeContactGroupFromMetaContactGroup(this.rootMetaGroup, rootGroup, provider);\r\n    }\r\n    OperationSetContactCapabilities capOpSet = provider.getOperationSet(OperationSetContactCapabilities.class);\r\n    if (capOpSet != null)\r\n        capOpSet.removeContactCapabilitiesListener(this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.usersearch.UserSearchActivator.getResources",
	"Comment": "returns a reference to the resourcemanagementservice implementationcurrently registered in the bundle context or null if no suchimplementation was found.",
	"Method": "ResourceManagementService getResources(){\r\n    if (resources == null) {\r\n        resources = ServiceUtils.getService(bundleContext, ResourceManagementService.class);\r\n    }\r\n    return resources;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.googlecontacts.GoogleContactsActivator.getCredentialsService",
	"Comment": "returns a reference to a credentialsstorageconfigurationserviceimplementation currently registered in the bundle context or null if nosuch implementation was found.",
	"Method": "CredentialsStorageService getCredentialsService(){\r\n    if (credentialsService == null) {\r\n        credentialsService = ServiceUtils.getService(bundleContext, CredentialsStorageService.class);\r\n    }\r\n    return credentialsService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.CallPeerMediaHandlerJabberImpl.processContent",
	"Comment": "process a contentpacketextension and initialize itscorresponding mediastream.",
	"Method": "void processContent(ContentPacketExtension content,boolean modify,boolean masterStream){\r\n    RtpDescriptionPacketExtension description = JingleUtils.getRtpDescription(content);\r\n    MediaType mediaType = JingleUtils.getMediaType(content);\r\n    TransportManagerJabberImpl transportManager = getTransportManager();\r\n    MediaStreamTarget target = transportManager.getStreamTarget(mediaType);\r\n    if (target == null)\r\n        target = JingleUtils.extractDefaultTarget(content);\r\n    if ((target == null) || (target.getDataAddress().getPort() == 0)) {\r\n        closeStream(mediaType);\r\n        return;\r\n    }\r\n    List<MediaFormat> supportedFormats = JingleUtils.extractFormats(description, getDynamicPayloadTypes());\r\n    MediaDevice dev = getDefaultDevice(mediaType);\r\n    if (!isDeviceActive(dev)) {\r\n        closeStream(mediaType);\r\n        return;\r\n    }\r\n    MediaDirection devDirection = (dev == null) ? MediaDirection.INACTIVE : dev.getDirection();\r\n    devDirection = devDirection.and(getDirectionUserPreference(mediaType));\r\n    if (supportedFormats.isEmpty()) {\r\n        ProtocolProviderServiceJabberImpl.throwOperationFailedException(\"Remote party sent an invalid Jingle answer.\", OperationFailedException.ILLEGAL_ARGUMENT, null, logger);\r\n    }\r\n    CallJabberImpl call = getPeer().getCall();\r\n    CallConference conference = (call == null) ? null : call.getConference();\r\n    if ((conference == null) || !conference.isJitsiVideobridge()) {\r\n        addZrtpAdvertisedEncryptions(true, description, mediaType);\r\n        addSDesAdvertisedEncryptions(true, description, mediaType);\r\n    }\r\n    addDtlsAdvertisedEncryptions(true, content, mediaType);\r\n    StreamConnector connector = transportManager.getStreamConnector(mediaType);\r\n    MediaDirection remoteDirection = JingleUtils.getDirection(content, getPeer().isInitiator());\r\n    if ((conference != null) && conference.isConferenceFocus()) {\r\n        for (CallPeerJabberImpl peer : call.getCallPeerList()) {\r\n            SendersEnum senders = peer.getSenders(mediaType);\r\n            boolean initiator = peer.isInitiator();\r\n            if ((senders == null) || (SendersEnum.both == senders) || (initiator && SendersEnum.initiator == senders) || (!initiator && SendersEnum.responder == senders)) {\r\n                remoteDirection = remoteDirection.or(MediaDirection.SENDONLY);\r\n            }\r\n        }\r\n    }\r\n    MediaDirection direction = devDirection.getDirectionForAnswer(remoteDirection);\r\n    List<RTPExtension> remoteRTPExtensions = JingleUtils.extractRTPExtensions(description, getRtpExtensionsRegistry());\r\n    List<RTPExtension> supportedExtensions = getExtensionsForType(mediaType);\r\n    List<RTPExtension> rtpExtensions = intersectRTPExtensions(remoteRTPExtensions, supportedExtensions);\r\n    Map<String, String> adv = supportedFormats.get(0).getAdvancedAttributes();\r\n    if (adv != null) {\r\n        for (Map.Entry<String, String> f : adv.entrySet()) {\r\n            if (f.getKey().equals(\"imageattr\"))\r\n                supportQualityControls = true;\r\n        }\r\n    }\r\n    if (mediaType.equals(MediaType.VIDEO) && modify) {\r\n        MediaStream stream = getStream(MediaType.VIDEO);\r\n        if (stream != null && dev != null) {\r\n            List<MediaFormat> fmts = supportedFormats;\r\n            if (!fmts.isEmpty()) {\r\n                MediaFormat fmt = fmts.get(0);\r\n                ((VideoMediaStream) stream).updateQualityControl(fmt.getAdvancedAttributes());\r\n            }\r\n        }\r\n        if (qualityControls != null) {\r\n            QualityPreset receiveQualityPreset = qualityControls.getRemoteReceivePreset();\r\n            QualityPreset sendQualityPreset = qualityControls.getRemoteSendMaxPreset();\r\n            supportedFormats = (dev == null) ? null : intersectFormats(supportedFormats, getLocallySupportedFormats(dev, sendQualityPreset, receiveQualityPreset));\r\n        }\r\n    }\r\n    initStream(content.getName(), connector, dev, supportedFormats.get(0), target, direction, rtpExtensions, masterStream);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.ErrorDialog.create",
	"Comment": "initializes a new errordialog with a specific ownerframe, title and message to be displayed.",
	"Method": "ErrorDialog create(Dialog owner,String title,String message){\r\n    return new ErrorDialog(owner, title, message);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.msofficecomm.MessengerContact.isSelf",
	"Comment": "gets the indicator which determines whether thismessengercontact is the same user as the current client user.",
	"Method": "boolean isSelf(){\r\n    return Messenger.isSelf(this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ProtocolProviderServiceJabberImpl.isSignalingTransportSecure",
	"Comment": "indicates if the xmpp transport channel is using a tls secured socket.",
	"Method": "boolean isSignalingTransportSecure(){\r\n    return connection.isSecureConnection();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomJabberImpl.removeMemberPropertyChangeListener",
	"Comment": "removes the given listener from the list of listeners currentlyregistered for chat room member property change events.",
	"Method": "void removeMemberPropertyChangeListener(ChatRoomMemberPropertyChangeListener listener){\r\n    synchronized (memberPropChangeListeners) {\r\n        memberPropChangeListeners.remove(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ServerStoredContactListSipImpl.init",
	"Comment": "initializes the server stored list. synchronize server stored groups andcontacts with the local groups and contacts.",
	"Method": "void init(){\r\n    try {\r\n        SipAccountIDImpl accountID = (SipAccountIDImpl) sipProvider.getAccountID();\r\n        if (!accountID.isXCapEnable())\r\n            return;\r\n        String serverUri = accountID.getClistOptionServerUri();\r\n        String username = accountID.getAccountPropertyString(ProtocolProviderFactory.USER_ID);\r\n        Address userAddress = sipProvider.parseAddressString(username);\r\n        String password;\r\n        if (accountID.isClistOptionUseSipCredentials()) {\r\n            username = ((SipUri) userAddress.getURI()).getUser();\r\n            password = SipActivator.getProtocolProviderFactory().loadPassword(accountID);\r\n        } else {\r\n            username = accountID.getClistOptionUser();\r\n            password = accountID.getClistOptionPassword();\r\n        }\r\n        if (serverUri != null) {\r\n            URI uri = new URI(serverUri.trim());\r\n            if (uri.getHost() != null && uri.getPath() != null) {\r\n                xCapClient.connect(uri, userAddress, username, password);\r\n            }\r\n        }\r\n    } catch (Throwable ex) {\r\n        logger.error(\"Error while connecting to XCAP server. \" + \"Contact list won't be saved\", ex);\r\n    }\r\n    try {\r\n        if (!xCapClient.isConnected() || !xCapClient.isResourceListsSupported()) {\r\n            return;\r\n        }\r\n        ResourceListsType resourceLists = xCapClient.getResourceLists();\r\n        ListType serverRootList = new ListType();\r\n        for (ListType list : resourceLists.getList()) {\r\n            if (list.getName().equals(ROOT_GROUP_NAME)) {\r\n                serverRootList.setName(ROOT_GROUP_NAME);\r\n                serverRootList.setDisplayName(list.getDisplayName());\r\n                serverRootList.getEntries().addAll(list.getEntries());\r\n                serverRootList.getEntryRefs().addAll(list.getEntryRefs());\r\n                serverRootList.getExternals().addAll(list.getExternals());\r\n                serverRootList.setAny(list.getAny());\r\n                serverRootList.setAnyAttributes(list.getAnyAttributes());\r\n            } else {\r\n                serverRootList.getLists().add(list);\r\n            }\r\n        }\r\n        boolean updateResourceLists = false;\r\n        resolveContactGroup(rootGroup, serverRootList, false);\r\n        for (ContactSipImpl contact : getAllContacts(rootGroup)) {\r\n            if (!contact.isResolved() && contact.isPersistent()) {\r\n                contact.setResolved(true);\r\n                ContactGroupSipImpl parentGroup = ((ContactGroupSipImpl) contact.getParentContactGroup());\r\n                if (contact.isXCapResolved()) {\r\n                    parentGroup.removeContact(contact);\r\n                    fireContactRemoved(parentGroup, contact);\r\n                } else {\r\n                    updateResourceLists = true;\r\n                    String oldValue = contact.getPersistentData();\r\n                    contact.setXCapResolved(true);\r\n                    fireContactResolved(parentGroup, contact);\r\n                    parentOperationSet.fireContactPropertyChangeEvent(ContactPropertyChangeEvent.PROPERTY_PERSISTENT_DATA, contact, oldValue, contact.getPersistentData());\r\n                }\r\n            }\r\n        }\r\n        for (ContactGroupSipImpl group : getAllGroups(rootGroup)) {\r\n            if (!group.isResolved() && group.isPersistent()) {\r\n                updateResourceLists = true;\r\n                group.setResolved(true);\r\n                fireGroupEvent(group, ServerStoredGroupEvent.GROUP_RESOLVED_EVENT);\r\n            }\r\n        }\r\n        if (updateResourceLists) {\r\n            updateResourceLists();\r\n        }\r\n        if (xCapClient.isPresRulesSupported()) {\r\n            RuleType whiteRule = getRule(SubHandlingType.Allow);\r\n            boolean updateRules = false;\r\n            if (whiteRule == null) {\r\n                whiteRule = createWhiteRule();\r\n                presRules.getRules().add(whiteRule);\r\n            }\r\n            List<ContactSipImpl> uniqueContacts = getUniqueContacts(rootGroup);\r\n            for (ContactSipImpl contact : uniqueContacts) {\r\n                if (contact.isPersistent() && !isContactInRule(whiteRule, contact.getUri())) {\r\n                    addContactToRule(whiteRule, contact);\r\n                    updateRules = true;\r\n                }\r\n            }\r\n            if (updateRules)\r\n                updatePresRules();\r\n        }\r\n    } catch (XCapException e) {\r\n        logger.error(\"Error initializing serverside list!\", e);\r\n        xCapClient.disconnect();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.update.UpdateServiceImpl.getVersionService",
	"Comment": "returns the currently registered instance of version service.",
	"Method": "VersionService getVersionService(){\r\n    return ServiceUtils.getService(UpdateActivator.bundleContext, VersionService.class);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapDirectorySettingsImpl.isEnabled",
	"Comment": "simple getter for enabled. required by ldapdirectorysettings interface.",
	"Method": "boolean isEnabled(){\r\n    return this.enabled;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.argdelegation.ArgDelegationActivator.getUIService",
	"Comment": "returns a reference to an uiservice implementation currently registeredin the bundle context or null if no such implementation was found.",
	"Method": "UIService getUIService(){\r\n    if (uiService == null)\r\n        uiService = ServiceUtils.getService(bundleContext, UIService.class);\r\n    return uiService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommFrame.update",
	"Comment": "listens for changes in binding sets so they can be reflected in the inputmap.",
	"Method": "void update(Observable obs,Object arg){\r\n    if (obs instanceof KeybindingSet) {\r\n        KeybindingSet changedBindings = (KeybindingSet) obs;\r\n        resetInputMap();\r\n        for (Map.Entry<KeyStroke, String> key2action : changedBindings.getBindings().entrySet()) {\r\n            imap.put(key2action.getKey(), key2action.getValue());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockPersistentPresenceOperationSet.findContactParent",
	"Comment": "returns the group that is parent of the specified mockcontactor nullif no parent was found.",
	"Method": "MockContactGroup findContactParent(MockContact mockContact){\r\n    return (MockContactGroup) mockContact.getParentContactGroup();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.sdp.SdpUtils.parseSdpString",
	"Comment": "parses the specified sdp string into asessiondescription.",
	"Method": "SessionDescription parseSdpString(String sdp){\r\n    try {\r\n        return sdpFactory.createSessionDescription(sdp);\r\n    } catch (SdpParseException ex) {\r\n        throw new IllegalArgumentException(\"Failed to parse the SDP description of the peer.\", ex);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallManager.getPeerMetaContact",
	"Comment": "returns the image for the given alternativepeeraddress bychecking the if the callpeer exists as a detail in one of thecontacts in our contact list.",
	"Method": "MetaContact getPeerMetaContact(CallPeer peer,MetaContact getPeerMetaContact,CallPeer callPeer,String alternativePeerAddress){\r\n    Iterator<MetaContact> metaContacts = GuiActivator.getContactListService().findAllMetaContactsForAddress(alternativePeerAddress);\r\n    while (metaContacts.hasNext()) {\r\n        MetaContact metaContact = metaContacts.next();\r\n        UIPhoneUtil phoneUtil = UIPhoneUtil.getPhoneUtil(metaContact);\r\n        List<UIContactDetail> additionalNumbers = phoneUtil.getAdditionalNumbers();\r\n        if (additionalNumbers == null || additionalNumbers.size() > 0)\r\n            continue;\r\n        Iterator<UIContactDetail> numbersIter = additionalNumbers.iterator();\r\n        while (numbersIter.hasNext()) {\r\n            if (numbersIter.next().getAddress().equals(callPeer.getAddress()))\r\n                return metaContact;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.EventPackageNotifier.getSubscription",
	"Comment": "gets the subscription from the list of subscriptions managed bythis instance which is associated with a specific callid.",
	"Method": "Subscription getSubscription(Address fromAddress,String eventId,Subscription getSubscription,String callId){\r\n    return (Subscription) super.getSubscription(callId);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.JabberAccountRegistrationWizard.getLastPageIdentifier",
	"Comment": "returns the identifier of the page to show last in the wizard.",
	"Method": "Object getLastPageIdentifier(){\r\n    return firstWizardPage.getIdentifier();\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.GraphicUtils.paintBorderGlow",
	"Comment": "paints border glow over the given clipshape with the givenglow high and low colors and the given glowwidth.",
	"Method": "void paintBorderGlow(Graphics2D g2,int glowWidth,Shape clipShape,Color glowOuterHigh,Color glowOuterLow){\r\n    int gw = glowWidth * 2;\r\n    for (int i = gw; i >= 2; i -= 2) {\r\n        float pct = (float) (gw - i) / (gw - 1);\r\n        Color mixHi = getMixedColor(glowOuterHigh, pct, new Color(255, 255, 255, 200), 1.0f - pct);\r\n        Color mixLo = getMixedColor(glowOuterLow, pct, new Color(255, 255, 255, 200), 1.0f - pct);\r\n        g2.setPaint(new GradientPaint(0, clipShape.getBounds().height * 0.25f, mixHi, 0, clipShape.getBounds().height, mixLo));\r\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_ATOP, pct));\r\n        g2.setStroke(new BasicStroke(i));\r\n        g2.draw(clipShape);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaHandler.addVideoListener",
	"Comment": "registers a specific videolistener with this instance so that itstarts receiving notifications from it about changes in the availabilityof visual components displaying video.",
	"Method": "void addVideoListener(VideoListener listener){\r\n    videoNotifierSupport.addVideoListener(listener);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.callhistory.CallHistorySourceContact.getContactSource",
	"Comment": "returns the parent contactsourceservice from which this contactcame from.",
	"Method": "ContactSourceService getContactSource(){\r\n    return contactSource;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.ImageUtils.getBufferedImage",
	"Comment": "returns the buffered image corresponding to the given image",
	"Method": "BufferedImage getBufferedImage(URL imagePath,BufferedImage getBufferedImage,Image source){\r\n    if (source == null) {\r\n        return null;\r\n    } else if (source instanceof BufferedImage) {\r\n        return (BufferedImage) source;\r\n    }\r\n    int width = source.getWidth(null);\r\n    int height = source.getHeight(null);\r\n    BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\r\n    Graphics graphics = image.createGraphics();\r\n    graphics.drawImage(source, 0, 0, null);\r\n    graphics.dispose();\r\n    return image;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.ContactGroupGibberishImpl.addSubgroup",
	"Comment": "adds the specified contact group to the contained by this group.",
	"Method": "void addSubgroup(ContactGroupGibberishImpl subgroup){\r\n    this.subGroups.add(subgroup);\r\n    subgroup.setParentGroup(this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetAdHocMultiUserChatIcqImpl.removeInvitationRejectionListener",
	"Comment": "removes listener from the list of invitation listenersregistered to receive invitation rejection events.",
	"Method": "void removeInvitationRejectionListener(AdHocChatRoomInvitationRejectionListener listener){\r\n    synchronized (invitationRejectionListeners) {\r\n        invitationRejectionListeners.remove(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.configforms.ConfigurationFrame.addConfigurationForm",
	"Comment": "implements the configurationmanager.addconfigurationformmethod. checks if the form contained in the configurationformis an instance of java.awt.component and if so adds the form in thisdialog, otherwise throws a classcastexception.",
	"Method": "void addConfigurationForm(ConfigurationForm configForm){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                addConfigurationForm(configForm);\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    configList.addConfigForm(configForm);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.configforms.ConfigurationFrame.addConfigurationForm",
	"Comment": "implements the configurationmanager.addconfigurationformmethod. checks if the form contained in the configurationformis an instance of java.awt.component and if so adds the form in thisdialog, otherwise throws a classcastexception.",
	"Method": "void addConfigurationForm(ConfigurationForm configForm){\r\n    addConfigurationForm(configForm);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.sendInstantMessage",
	"Comment": "implements the chatpanel.sendmessage method. obtains theappropriate operation set and sends the message, contained in the writearea, through it.",
	"Method": "void sendInstantMessage(){\r\n    String htmlText;\r\n    String plainText;\r\n    synchronized (writeMessagePanel) {\r\n        if (isWriteAreaEmpty())\r\n            return;\r\n        htmlText = getTextFromWriteArea(OperationSetBasicInstantMessaging.HTML_MIME_TYPE).trim();\r\n        plainText = getTextFromWriteArea(OperationSetBasicInstantMessaging.DEFAULT_MIME_TYPE).trim();\r\n        this.refreshWriteArea();\r\n    }\r\n    String messageText;\r\n    String mimeType;\r\n    if (chatSession.getCurrentChatTransport().isContentTypeSupported(OperationSetBasicInstantMessaging.HTML_MIME_TYPE) && (htmlText.indexOf(\"<b\") > -1 || htmlText.indexOf(\"<i\") > -1 || htmlText.indexOf(\"<u\") > -1 || htmlText.indexOf(\"<font\") > -1)) {\r\n        messageText = htmlText;\r\n        mimeType = OperationSetBasicInstantMessaging.HTML_MIME_TYPE;\r\n    } else {\r\n        messageText = plainText;\r\n        mimeType = OperationSetBasicInstantMessaging.DEFAULT_MIME_TYPE;\r\n    }\r\n    try {\r\n        if (isMessageCorrectionActive() && chatSession.getCurrentChatTransport().allowsMessageCorrections()) {\r\n            chatSession.getCurrentChatTransport().correctInstantMessage(messageText, mimeType, correctedMessageUID);\r\n        } else {\r\n            chatSession.getCurrentChatTransport().sendInstantMessage(messageText, mimeType);\r\n        }\r\n        stopMessageCorrection();\r\n    } catch (IllegalStateException ex) {\r\n        logger.error(\"Failed to send message.\", ex);\r\n        this.addMessage(chatSession.getCurrentChatTransport().getName(), new Date(), Chat.OUTGOING_MESSAGE, messageText, mimeType);\r\n        String protocolError = \"\";\r\n        if (ex.getMessage() != null)\r\n            protocolError = \" \" + GuiActivator.getResources().getI18NString(\"service.gui.ERROR_WAS\", new String[] { ex.getMessage() });\r\n        this.addErrorMessage(chatSession.getCurrentChatTransport().getName(), GuiActivator.getResources().getI18NString(\"service.gui.MSG_SEND_CONNECTION_PROBLEM\") + protocolError);\r\n    } catch (Exception ex) {\r\n        logger.error(\"Failed to send message.\", ex);\r\n        this.refreshWriteArea();\r\n        this.addMessage(chatSession.getCurrentChatTransport().getName(), new Date(), Chat.OUTGOING_MESSAGE, messageText, mimeType);\r\n        String protocolError = \"\";\r\n        if (ex.getMessage() != null)\r\n            protocolError = \" \" + GuiActivator.getResources().getI18NString(\"service.gui.ERROR_WAS\", new String[] { ex.getMessage() });\r\n        this.addErrorMessage(chatSession.getCurrentChatTransport().getName(), GuiActivator.getResources().getI18NString(\"service.gui.MSG_DELIVERY_ERROR\", new String[] { protocolError }));\r\n    }\r\n    if (chatSession.getCurrentChatTransport().allowsTypingNotifications()) {\r\n        getChatWritePanel().stopTypingTimer();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.filehistory.FileHistoryServiceImpl.getHistoryReaders",
	"Comment": "gets all the history readers for the contacts in the given metacontact",
	"Method": "Map<Contact, HistoryReader> getHistoryReaders(MetaContact contact){\r\n    Map<Contact, HistoryReader> readers = new Hashtable<Contact, HistoryReader>();\r\n    Iterator<Contact> iter = contact.getContacts();\r\n    while (iter.hasNext()) {\r\n        Contact item = iter.next();\r\n        try {\r\n            History history = this.getHistory(null, item);\r\n            readers.put(item, history.getReader());\r\n        } catch (IOException e) {\r\n            logger.error(\"Could not read history\", e);\r\n        }\r\n    }\r\n    return readers;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OutgoingFileTransferJabberImpl.interceptPacket",
	"Comment": "listens for all streaminitiation packets and adds a thumbnailto them if a thumbnailed file is supported.",
	"Method": "void interceptPacket(Packet packet){\r\n    if (!(packet instanceof StreamInitiation))\r\n        return;\r\n    if (!(file instanceof ThumbnailedFile))\r\n        return;\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"File transfer packet intercepted\" + \" in order to add thumbnail.\");\r\n    StreamInitiation fileTransferPacket = (StreamInitiation) packet;\r\n    ThumbnailedFile thumbnailedFile = (ThumbnailedFile) file;\r\n    if (jabberTransfer.getStreamID().equals(fileTransferPacket.getSessionID())) {\r\n        StreamInitiation.File file = fileTransferPacket.getFile();\r\n        thumbnailElement = new ThumbnailElement(StringUtils.parseServer(fileTransferPacket.getTo()), thumbnailedFile.getThumbnailData(), thumbnailedFile.getThumbnailMimeType(), thumbnailedFile.getThumbnailWidth(), thumbnailedFile.getThumbnailHeight());\r\n        FileElement fileElement = new FileElement(file, thumbnailElement);\r\n        fileTransferPacket.setFile(fileElement);\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"The file transfer packet with thumbnail: \" + fileTransferPacket.toXML());\r\n        if (protocolProvider.getConnection() != null) {\r\n            protocolProvider.getConnection().addPacketListener(thumbnailRequestListener, new AndFilter(new PacketTypeFilter(IQ.class), new IQTypeFilter(IQ.Type.GET)));\r\n        }\r\n    }\r\n    protocolProvider.getConnection().removePacketInterceptor(this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chatroomslist.createforms.SelectAccountPanel.isRadioSelected",
	"Comment": "checks whether there is a selected radio button in the table.",
	"Method": "boolean isRadioSelected(){\r\n    TableModel model = accountsTable.getModel();\r\n    for (int i = 0; i < accountsTable.getRowCount(); i++) {\r\n        Object value = model.getValueAt(i, 0);\r\n        if (value instanceof JRadioButton) {\r\n            JRadioButton radioButton = (JRadioButton) value;\r\n            if (radioButton.isSelected())\r\n                return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.CommonRightButtonMenu.actionPerformed",
	"Comment": "handles the actionevent. the chosen menu item should correspondto an account, where the new contact will be added. we obtain here theprotocol provider corresponding to the chosen account and show thedialog, where the user could add the contact.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    JMenuItem item = (JMenuItem) e.getSource();\r\n    if (item.equals(createGroupItem)) {\r\n        CreateGroupDialog dialog = new CreateGroupDialog(mainFrame);\r\n        dialog.setVisible(true);\r\n    } else if (item.equals(addContactItem)) {\r\n        AddContactDialog dialog = new AddContactDialog(mainFrame);\r\n        dialog.setVisible(true);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.ResolveAddressToDisplayNameContactQueryListener.isFoundName",
	"Comment": "tells if the query has found a match to resolve the contact address.",
	"Method": "boolean isFoundName(){\r\n    return !StringUtils.isNullOrEmpty(resolvedName);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetIncomingDTMFSipImpl.addDTMFListener",
	"Comment": "registers the specified dtmflistener with this provider so that it couldbe notified when incoming dtmf tone is received.",
	"Method": "void addDTMFListener(DTMFListener listener){\r\n    this.opsetDTMFSip.getDtmfModeInfo().addDTMFListener(listener);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageSourceService.addNewRecentMessages",
	"Comment": "add the comparableevtobj, newly added will fire new,for existing fire update and when trimming the list to desired lengthfire remove for those that were removed",
	"Method": "void addNewRecentMessages(List<ComparableEvtObj> contactsToAdd){\r\n    List<ComparableEvtObj> duplicates = new ArrayList<ComparableEvtObj>();\r\n    for (ComparableEvtObj msgToAdd : contactsToAdd) {\r\n        if (recentMessages.contains(msgToAdd)) {\r\n            duplicates.add(msgToAdd);\r\n            updateRecentMessageToHistory(msgToAdd);\r\n        }\r\n    }\r\n    recentMessages.removeAll(duplicates);\r\n    boolean changed = recentMessages.addAll(contactsToAdd);\r\n    if (changed) {\r\n        Collections.sort(recentMessages);\r\n        if (recentQuery != null) {\r\n            for (ComparableEvtObj obj : duplicates) recentQuery.updateContact(obj, obj.getEventObject());\r\n        }\r\n    }\r\n    if (!recentMessages.isEmpty())\r\n        oldestRecentMessage = recentMessages.get(recentMessages.size() - 1).getTimestamp();\r\n    List<ComparableEvtObj> removedItems = null;\r\n    if (recentMessages.size() > numberOfMessages) {\r\n        removedItems = new ArrayList<ComparableEvtObj>(recentMessages.subList(numberOfMessages, recentMessages.size()));\r\n        recentMessages.removeAll(removedItems);\r\n    }\r\n    if (recentQuery != null) {\r\n        if (removedItems != null) {\r\n            for (ComparableEvtObj msc : removedItems) {\r\n                if (!contactsToAdd.contains(msc))\r\n                    recentQuery.fireContactRemoved(msc);\r\n            }\r\n        }\r\n        for (ComparableEvtObj msc : contactsToAdd) {\r\n            if ((removedItems == null || !removedItems.contains(msc)) && !duplicates.contains(msc)) {\r\n                MessageSourceContact newSourceContact = new MessageSourceContact(msc.getEventObject(), MessageSourceService.this);\r\n                newSourceContact.initDetails(msc.getEventObject());\r\n                recentQuery.addQueryResult(newSourceContact);\r\n            }\r\n        }\r\n        if (changed)\r\n            recentQuery.fireContactChanged(recentMessages.get(recentMessages.size() - 1));\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.plaf.SIPCommTextFieldUI.getVisibleEditorRect",
	"Comment": "if we are in the case of disabled delete button, we simply call theparent implementation of this method, otherwise we recalculate the editorrectangle in order to leave place for the delete button.",
	"Method": "Rectangle getVisibleEditorRect(){\r\n    if (!isDeleteIconVisible) {\r\n        return super.getVisibleEditorRect();\r\n    }\r\n    JTextComponent c = getComponent();\r\n    if (c == null)\r\n        return null;\r\n    Rectangle alloc = c.getBounds();\r\n    if ((alloc.width > 0) && (alloc.height > 0)) {\r\n        alloc.x = alloc.y = 0;\r\n        Insets insets = c.getInsets();\r\n        alloc.x += insets.left;\r\n        alloc.y += insets.top;\r\n        alloc.width -= insets.left + insets.right + getDeleteButtonRect().getWidth();\r\n        alloc.height -= insets.top + insets.bottom;\r\n        return alloc;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.keybox.manage.db.SystemStatusDB.getNextPendingSystem",
	"Comment": "returns the first system that authorized keys has not been tried",
	"Method": "HostSystem getNextPendingSystem(Long userId){\r\n    HostSystem hostSystem = null;\r\n    Connection con = null;\r\n    try {\r\n        con = DBUtils.getConn();\r\n        PreparedStatement stmt = con.prepareStatement(\"select * from status where (status_cd like ? or status_cd like ? or status_cd like ?) and user_id=? order by id asc\");\r\n        stmt.setString(1, HostSystem.INITIAL_STATUS);\r\n        stmt.setString(2, HostSystem.AUTH_FAIL_STATUS);\r\n        stmt.setString(3, HostSystem.PUBLIC_KEY_FAIL_STATUS);\r\n        stmt.setLong(4, userId);\r\n        ResultSet rs = stmt.executeQuery();\r\n        if (rs.next()) {\r\n            hostSystem = SystemDB.getSystem(con, rs.getLong(\"id\"));\r\n            hostSystem.setStatusCd(rs.getString(STATUS_CD));\r\n        }\r\n        DBUtils.closeRs(rs);\r\n        DBUtils.closeStmt(stmt);\r\n    } catch (Exception e) {\r\n        log.error(e.toString(), e);\r\n    } finally {\r\n        DBUtils.closeConn(con);\r\n    }\r\n    return hostSystem;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.IcqTesterAgent.findBuddyInBuddyList",
	"Comment": "tries to find the buddy with screenname screenname in the given buddylist",
	"Method": "Buddy findBuddyInBuddyList(BuddyList list,String screenname){\r\n    Iterator<? extends Group> groups = list.getGroups().iterator();\r\n    while (groups.hasNext()) {\r\n        Group group = groups.next();\r\n        for (Buddy buddy : group.getBuddiesCopy()) {\r\n            if (buddy.getScreenname().getFormatted().equals(screenname))\r\n                return buddy;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ContactListTreeCellRenderer.getTreeCellRendererComponent",
	"Comment": "returns this panel that has been configured to display the meta contactand meta contact group cells.",
	"Method": "Component getTreeCellRendererComponent(JTree tree,Object value,boolean selected,boolean expanded,boolean leaf,int row,boolean hasFocus){\r\n    this.treeContactList = (TreeContactList) tree;\r\n    this.row = row;\r\n    this.isSelected = selected;\r\n    this.treeNode = (TreeNode) value;\r\n    rightLabel.setIcon(null);\r\n    DefaultTreeContactList contactList = (DefaultTreeContactList) tree;\r\n    setBorder();\r\n    addLabels(1);\r\n    if (contactList instanceof TreeContactList) {\r\n        ContactListFilter filter = ((TreeContactList) contactList).getCurrentFilter();\r\n        if (filter != null && filter.equals(TreeContactList.historyFilter) && value instanceof ContactNode && row % 2 == 0) {\r\n            setBackground(Constants.CALL_HISTORY_EVEN_ROW_COLOR);\r\n        } else {\r\n            setBackground(Color.WHITE);\r\n        }\r\n    }\r\n    nameLabel.setIcon(null);\r\n    nameLabel.setText(value.toString());\r\n    if (value instanceof ContactNode) {\r\n        UIContactImpl contact = ((ContactNode) value).getContactDescriptor();\r\n        MUCService mucService;\r\n        if ((contact.getDescriptor() instanceof SourceContact) && (mucService = GuiActivator.getMUCService()) != null && mucService.isMUCSourceContact((SourceContact) contact.getDescriptor())) {\r\n            setBackground(Constants.CHAT_ROOM_ROW_COLOR);\r\n        }\r\n        String displayName = contact.getDisplayName();\r\n        if ((displayName == null || displayName.trim().length() < 1) && !(contact instanceof ShowMoreContact)) {\r\n            displayName = GuiActivator.getResources().getI18NString(\"service.gui.UNKNOWN\");\r\n        }\r\n        nameLabel.setText(displayName);\r\n        if (statusIcon != null && contactList.isContactActive(contact) && statusIcon instanceof ImageIcon)\r\n            ((ImageIcon) statusIcon).setImage(msgReceivedImage);\r\n        else\r\n            statusIcon = contact.getStatusIcon();\r\n        statusLabel.setIcon(statusIcon);\r\n        Font nameLabelFont = nameLabel.getFont();\r\n        nameLabel.setFont(nameLabelFont.deriveFont(Font.PLAIN, Math.max(nameLabelFont.getSize2D(), OSUtils.IS_WINDOWS ? 0F : 13F)));\r\n        if (contactForegroundColor != null)\r\n            nameLabel.setForeground(contactForegroundColor);\r\n        initDisplayDetails(contact.getDisplayDetails());\r\n        if (contact.getDescriptor() instanceof MetaContact && isMobile((MetaContact) contact.getDescriptor())) {\r\n            nameLabel.setIcon(new ImageIcon(ImageLoader.getImage(ImageLoader.CONTACT_LIST_MOBILE_INDICATOR)));\r\n            nameLabel.setHorizontalTextPosition(SwingConstants.LEFT);\r\n        }\r\n        if (treeContactList.isContactButtonsVisible())\r\n            initButtonsPanel(contact);\r\n        int avatarWidth, avatarHeight;\r\n        if (isSelected && treeContactList.isContactButtonsVisible()) {\r\n            avatarWidth = EXTENDED_AVATAR_WIDTH;\r\n            avatarHeight = EXTENDED_AVATAR_HEIGHT;\r\n        } else {\r\n            avatarWidth = AVATAR_WIDTH;\r\n            avatarHeight = AVATAR_HEIGHT;\r\n        }\r\n        Icon avatar = contact.getScaledAvatar(isSelected, avatarWidth, avatarHeight);\r\n        if (avatar != null)\r\n            rightLabel.setIcon(avatar);\r\n        if (contact instanceof ShowMoreContact) {\r\n            rightLabel.setFont(rightLabel.getFont().deriveFont(12f));\r\n            rightLabel.setForeground(Color.GRAY);\r\n            rightLabel.setText((String) contact.getDescriptor());\r\n        } else {\r\n            rightLabel.setFont(rightLabel.getFont().deriveFont(9f));\r\n            rightLabel.setText(\"\");\r\n        }\r\n        setToolTipText(contact.getDescriptor().toString());\r\n        if (preferredNotSelectedContactNodeHeight == null) {\r\n            preferredNotSelectedContactNodeHeight = ComponentUtils.getStringHeight(nameLabel) + V_GAP * 2 + ComponentUtils.getStringHeight(displayDetailsLabel);\r\n            preferredSelectedContactNodeHeight = preferredNotSelectedContactNodeHeight + V_GAP * 2 + BUTTON_HEIGHT;\r\n        }\r\n    } else if (value instanceof GroupNode) {\r\n        UIGroupImpl groupItem = ((GroupNode) value).getGroupDescriptor();\r\n        Font nameLabelFont = nameLabel.getFont();\r\n        nameLabel.setFont(nameLabelFont.deriveFont(Font.BOLD, Math.max(nameLabelFont.getSize2D(), OSUtils.IS_WINDOWS ? 0F : 13F)));\r\n        nameLabel.setText(groupItem.getDisplayName());\r\n        if (groupForegroundColor != null)\r\n            nameLabel.setForeground(groupForegroundColor);\r\n        remove(displayDetailsLabel);\r\n        remove(callButton);\r\n        remove(callVideoButton);\r\n        remove(desktopSharingButton);\r\n        remove(chatButton);\r\n        remove(addContactButton);\r\n        remove(webButton);\r\n        clearCustomActionButtons();\r\n        statusIcon = expanded ? openedGroupIcon : closedGroupIcon;\r\n        if (groupItem != treeContactList.getRootUIGroup()) {\r\n            statusLabel.setIcon(expanded ? openedGroupIcon : closedGroupIcon);\r\n        } else {\r\n            statusLabel.setIcon(null);\r\n        }\r\n        rightLabel.setIcon(null);\r\n        rightLabel.setText(\"\");\r\n        int groupItemCountChildContacts = groupItem.countChildContacts();\r\n        if (groupItemCountChildContacts >= 0) {\r\n            rightLabel.setFont(rightLabel.getFont().deriveFont(9f));\r\n            rightLabel.setForeground(Color.BLACK);\r\n            rightLabel.setText(groupItem.countOnlineChildContacts() + \"/\" + groupItemCountChildContacts);\r\n        }\r\n        initDisplayDetails(groupItem.getDisplayDetails());\r\n        initButtonsPanel(groupItem);\r\n        Object groupItemDescriptor = groupItem.getDescriptor();\r\n        setToolTipText((groupItemDescriptor != null) ? groupItemDescriptor.toString() : groupItem.getDisplayName());\r\n        if (preferredGroupNodeHeight == null) {\r\n            preferredGroupNodeHeight = ComponentUtils.getStringHeight(nameLabel);\r\n        }\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommTextButton.getUIClassID",
	"Comment": "returns the name of the l&f class that renders this component.",
	"Method": "String getUIClassID(){\r\n    return UIClassID;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ProtocolProviderServiceJabberImpl.isFeatureSupported",
	"Comment": "determines if the given list of features is supported by thespecified jabber id.",
	"Method": "boolean isFeatureSupported(String jid,String feature){\r\n    return isFeatureListSupported(jid, feature);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.IncomingMessageStyle.createIndicatorStyle",
	"Comment": "creates the style of the indicator pointing to the avatar image.",
	"Method": "String createIndicatorStyle(){\r\n    return \"style =\\\"\" + \"width:9px;\" + \" height:19px;\" + \" background-image: url('\" + INCOMING_MESSAGE_INDICATOR_PATH + \"');\" + \" background-repeat: no-repeat;\" + \" background-position: top right;\" + \"\\\"\";\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl.processAck",
	"Comment": "updates the session description and sends the state of the correspondingcall peer to connected.",
	"Method": "void processAck(ServerTransaction serverTransaction,Request ack){\r\n    ContentLengthHeader contentLength = ack.getContentLength();\r\n    if ((contentLength != null) && (contentLength.getContentLength() > 0)) {\r\n        try {\r\n            getMediaHandler().processAnswer(SdpUtils.getContentAsString(ack));\r\n        } catch (Exception exc) {\r\n            logAndFail(\"There was an error parsing the SDP description of \" + getDisplayName() + \"(\" + getAddress() + \")\", exc);\r\n            return;\r\n        }\r\n    }\r\n    CallPeerState peerState = getState();\r\n    if (!CallPeerState.isOnHold(peerState)) {\r\n        setState(CallPeerState.CONNECTED);\r\n        getMediaHandler().start();\r\n        if (this.getCall() != null && isMute() != this.getCall().isMute())\r\n            setMute(this.getCall().isMute());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.ProtocolMediaActivator.getConfigurationService",
	"Comment": "returns a reference to a configurationservice implementation currentlyregistered in the bundle context or null if no such implementation wasfound.",
	"Method": "ConfigurationService getConfigurationService(){\r\n    if (configurationService == null) {\r\n        configurationService = ServiceUtils.getService(bundleContext, ConfigurationService.class);\r\n    }\r\n    return configurationService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomConfigurationFormFieldJabberImpl.isRequired",
	"Comment": "returns the isrequired property of the corresponding smack property.",
	"Method": "boolean isRequired(){\r\n    return smackFormField.isRequired();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.ExternalContactSource.initCustomServiceActionButtons",
	"Comment": "initializes custom action buttons for this source service.",
	"Method": "void initCustomServiceActionButtons(){\r\n    customServiceActionButtons = new LinkedHashMap<ContactAction<ContactSourceService>, SIPCommButton>();\r\n    for (CustomContactActionsService<ContactSourceService> ccas : getCustomActionsContactServices()) {\r\n        Iterator<ContactAction<ContactSourceService>> actionIterator = ccas.getCustomContactActions();\r\n        while (actionIterator != null && actionIterator.hasNext()) {\r\n            final ContactAction<ContactSourceService> ca = actionIterator.next();\r\n            initActionButton(ca, ContactSourceService.class);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.version.VersionManager.registrationStateChanged",
	"Comment": "the method is called by a protocolprovider implementation whenevera change in the registration state of the corresponding provider hadoccurred.",
	"Method": "void registrationStateChanged(RegistrationStateChangeEvent evt){\r\n    if (evt.getNewState() == RegistrationState.REGISTERED) {\r\n        parentProvider.getConnection().removePacketListener(this);\r\n        parentProvider.getConnection().addPacketListener(this, new AndFilter(new IQTypeFilter(IQ.Type.GET), new PacketTypeFilter(org.jivesoftware.smackx.packet.Version.class)));\r\n    } else if (evt.getNewState() == RegistrationState.UNREGISTERED || evt.getNewState() == RegistrationState.CONNECTION_FAILED || evt.getNewState() == RegistrationState.AUTHENTICATION_FAILED) {\r\n        if (parentProvider.getConnection() != null)\r\n            parentProvider.getConnection().removePacketListener(this);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.update.UpdateServiceImpl.isLatestVersion",
	"Comment": "determines whether we are currently running the latest version.",
	"Method": "boolean isLatestVersion(){\r\n    try {\r\n        String updateLink = UpdateActivator.getConfiguration().getString(PROP_UPDATE_LINK);\r\n        if (updateLink == null) {\r\n            updateLink = Resources.getUpdateConfigurationString(\"update_link\");\r\n        }\r\n        if (updateLink == null) {\r\n            if (logger.isDebugEnabled())\r\n                logger.debug(\"Updates are disabled, faking latest version.\");\r\n        } else {\r\n            HttpUtils.HTTPResponseResult res = HttpUtils.openURLConnection(updateLink);\r\n            if (res != null) {\r\n                InputStream in = null;\r\n                Properties props = new Properties();\r\n                try {\r\n                    in = res.getContent();\r\n                    props.load(in);\r\n                } finally {\r\n                    in.close();\r\n                }\r\n                latestVersion = props.getProperty(\"last_version\");\r\n                downloadLink = props.getProperty(\"download_link\");\r\n                if (downloadLink != null) {\r\n                    if (OSUtils.IS_LINUX32) {\r\n                        downloadLink = downloadLink.replace(\"amd64\", \"i386\");\r\n                    } else if (OSUtils.IS_LINUX64) {\r\n                        downloadLink = downloadLink.replace(\"i386\", \"amd64\");\r\n                    } else if (OSUtils.IS_WINDOWS32) {\r\n                        downloadLink = downloadLink.replace(\"x64\", \"x86\");\r\n                    } else if (OSUtils.IS_WINDOWS64) {\r\n                        downloadLink = downloadLink.replace(\"x86\", \"x64\");\r\n                    }\r\n                }\r\n                changesLink = updateLink.substring(0, updateLink.lastIndexOf(\"/\") + 1) + props.getProperty(\"changes_html\");\r\n                try {\r\n                    VersionService versionService = getVersionService();\r\n                    Version latestVersionObj = versionService.parseVersionString(latestVersion);\r\n                    if (latestVersionObj != null)\r\n                        return latestVersionObj.compareTo(getCurrentVersion()) <= 0;\r\n                    else\r\n                        logger.error(\"Version obj not parsed(\" + latestVersion + \")\");\r\n                } catch (Throwable t) {\r\n                    logger.error(\"Error parsing version string\", t);\r\n                }\r\n                return latestVersion.compareTo(getCurrentVersion().toString()) <= 0;\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n        logger.warn(\"Could not retrieve latest version or compare it to current\" + \" version\", e);\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "net.librec.data.model.ArffDataModelTestCase.getValidRatio",
	"Comment": "calculate the ratio of validation set of a specified datamodel object",
	"Method": "double getValidRatio(DataModel dataModel){\r\n    double validSize = getValidSize(dataModel);\r\n    double totalSize = getDataSize(dataModel);\r\n    return validSize / totalSize;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.AdHocConferenceChatSession.loadChatRoom",
	"Comment": "loads the given chat room in the this chat conference panel. loads allmembers and adds all corresponding listeners.",
	"Method": "void loadChatRoom(AdHocChatRoom chatRoom){\r\n    for (Contact contact : chatRoom.getParticipants()) sessionRenderer.addChatContact(new AdHocConferenceChatContact(contact));\r\n    chatRoom.addParticipantPresenceListener(this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ScServiceDiscoveryManager.addDiscoverInfoTo",
	"Comment": "populates a specific discoverinfo with the identity and featuresof the current entity caps node.",
	"Method": "void addDiscoverInfoTo(DiscoverInfo response){\r\n    DiscoverInfo.Identity identity = new DiscoverInfo.Identity(\"client\", ServiceDiscoveryManager.getIdentityName());\r\n    identity.setType(ServiceDiscoveryManager.getIdentityType());\r\n    response.addIdentity(identity);\r\n    if (!response.containsFeature(CapsPacketExtension.NAMESPACE))\r\n        response.addFeature(CapsPacketExtension.NAMESPACE);\r\n    Iterable<String> features = getFeatures();\r\n    synchronized (features) {\r\n        for (String feature : features) if (!response.containsFeature(feature))\r\n            response.addFeature(feature);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomIrcImpl.getPrivateContactByNickname",
	"Comment": "find the contact instance corresponding to the specified chat roommember. since every chat room member is also a private contact, we willcreate an instance if it cannot be found.",
	"Method": "Contact getPrivateContactByNickname(String name){\r\n    if (LOGGER.isDebugEnabled()) {\r\n        LOGGER.debug(\"Getting private contact for nick name '\" + name + \"'.\");\r\n    }\r\n    return this.parentProvider.getPersistentPresence().findOrCreateContactByID(name);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.packetlogging.PacketLoggingConfigurationImpl.setGlobalLoggingEnabled",
	"Comment": "change whether packet logging is enabled and save it in configuration.",
	"Method": "void setGlobalLoggingEnabled(boolean enabled){\r\n    super.setGlobalLoggingEnabled(enabled);\r\n    PacketLoggingActivator.getConfigurationService().setProperty(PACKET_LOGGING_ENABLED_PROPERTY_NAME, enabled);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.MetaContactChatSession.findChatTransportForResource",
	"Comment": "finds the chattransport corresponding to the given contactresource.",
	"Method": "ChatTransport findChatTransportForResource(ContactResource resource){\r\n    List<ChatTransport> transports;\r\n    synchronized (chatTransports) {\r\n        transports = new ArrayList<ChatTransport>(chatTransports);\r\n    }\r\n    Iterator<ChatTransport> transportsIter = transports.iterator();\r\n    while (transportsIter.hasNext()) {\r\n        ChatTransport chatTransport = transportsIter.next();\r\n        if (chatTransport.getDescriptor().equals(resource.getContact()) && chatTransport.getResourceName() != null && chatTransport.getResourceName().equals(resource.getResourceName()))\r\n            return chatTransport;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.GibberishStatusEnum.getImageInBytes",
	"Comment": "returns the byte representation of the image corresponding to the givenidentifier.",
	"Method": "byte[] getImageInBytes(String imageID){\r\n    InputStream in = GibberishActivator.getResources().getImageInputStream(imageID);\r\n    if (in == null)\r\n        return null;\r\n    byte[] image = null;\r\n    try {\r\n        image = new byte[in.available()];\r\n        in.read(image);\r\n    } catch (IOException e) {\r\n        logger.error(\"Failed to load image:\" + imageID, e);\r\n    }\r\n    return image;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.contactsource.AbstractContactQuery.getContactSource",
	"Comment": "gets the contactsourceservice which is performing thiscontactquery.",
	"Method": "T getContactSource(){\r\n    return contactSource;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.GroupRightButtonMenu.actionPerformed",
	"Comment": "handles the actionevent. the chosen menu item should correspondto an account, where the new contact will be added. we obtain here theprotocol provider corresponding to the chosen account and show thedialog, where the user could add the contact.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    JMenuItem item = (JMenuItem) e.getSource();\r\n    if (item.equals(removeGroupItem)) {\r\n        if (group != null)\r\n            MetaContactListManager.removeMetaContactGroup(group);\r\n    } else if (item.equals(renameGroupItem)) {\r\n        RenameGroupDialog dialog = new RenameGroupDialog(mainFrame, group);\r\n        dialog.setLocation(Toolkit.getDefaultToolkit().getScreenSize().width / 2 - 200, Toolkit.getDefaultToolkit().getScreenSize().height / 2 - 50);\r\n        dialog.setVisible(true);\r\n        dialog.requestFocusInFiled();\r\n    } else if (item.equals(addContactItem)) {\r\n        AddContactDialog dialog = new AddContactDialog(mainFrame);\r\n        dialog.setSelectedGroup(group);\r\n        dialog.setVisible(true);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.globalshortcut.CallShortcut.closeAnsweredCalls",
	"Comment": "closes only active calls, or all answered calls depending on thecloseonlyactivecalls parameter.",
	"Method": "boolean closeAnsweredCalls(boolean closeOnlyActiveCalls){\r\n    boolean isAtLeastOneCallClosed = false;\r\n    synchronized (answeredCalls) {\r\n        int i = answeredCalls.size();\r\n        while (i != 0) {\r\n            --i;\r\n            Call call = answeredCalls.get(i);\r\n            if (!closeOnlyActiveCalls || CallShortcut.isActiveCall(call)) {\r\n                CallShortcut.doCallAction(call, CallAction.HANGUP);\r\n                answeredCalls.remove(i);\r\n                isAtLeastOneCallClosed = true;\r\n            }\r\n        }\r\n    }\r\n    return isAtLeastOneCallClosed;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.customcontrols.wizard.WizardModel.setCurrentPanel",
	"Comment": "sets the current panel to that identified by the object passed in.",
	"Method": "boolean setCurrentPanel(Object id){\r\n    WizardPage nextPanel = panelHashmap.get(id);\r\n    if (nextPanel == null)\r\n        throw new WizardPanelNotFoundException();\r\n    WizardPage oldPanel = currentPanel;\r\n    currentPanel = nextPanel;\r\n    if (oldPanel != currentPanel) {\r\n        firePropertyChange(CURRENT_PAGE_PROPERTY, oldPanel, currentPanel);\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.skinmanager.SkinManagerActivator.start",
	"Comment": "starts this bundle and adds theskinmanagerconfigform contained in it to the configurationwindow obtained from the uiservice.",
	"Method": "void start(BundleContext bc){\r\n    bundleContext = bc;\r\n    if (getConfigService().getBoolean(ENABLED_PROP, false)) {\r\n        Dictionary<String, String> properties = new Hashtable<String, String>();\r\n        properties.put(ConfigurationForm.FORM_TYPE, ConfigurationForm.ADVANCED_TYPE);\r\n        bundleContext.registerService(ConfigurationForm.class.getName(), new LazyConfigurationForm(\"net.java.sip.communicator.plugin.skinmanager.SkinManagerPanel\", getClass().getClassLoader(), \"plugin.skinmanager.PLUGIN_ICON\", \"plugin.skinmanager.SKINS\", 1001, true), properties);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.MainFrame.createAccountIndex",
	"Comment": "creates and calculates the account index for the given protocolprovider.",
	"Method": "int createAccountIndex(ProtocolProviderService protocolProvider,String accountRootPropName){\r\n    ConfigurationService configService = GuiActivator.getConfigurationService();\r\n    int accountIndex = -1;\r\n    for (ProtocolProviderService pps : protocolProviders.keySet()) {\r\n        if (pps.getProtocolDisplayName().equals(protocolProvider.getProtocolDisplayName()) && !pps.equals(protocolProvider)) {\r\n            int index = protocolProviders.get(pps);\r\n            if (accountIndex < index)\r\n                accountIndex = index;\r\n        }\r\n    }\r\n    accountIndex++;\r\n    configService.setProperty(accountRootPropName + \".accountIndex\", accountIndex);\r\n    return accountIndex;\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.AbstractSessionDataStoreTest.testStoreObjectAttributes",
	"Comment": "test that the store can persist a session that contains serializable objects in the attributes.",
	"Method": "void testStoreObjectAttributes(){\r\n    ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);\r\n    context.setContextPath(\"/test\");\r\n    SessionDataStoreFactory factory = createSessionDataStoreFactory();\r\n    ((AbstractSessionDataStoreFactory) factory).setGracePeriodSec(GRACE_PERIOD_SEC);\r\n    SessionDataStore store = factory.getSessionDataStore(context.getSessionHandler());\r\n    SessionContext sessionContext = new SessionContext(\"foo\", context.getServletContext());\r\n    store.initialize(sessionContext);\r\n    store.start();\r\n    SessionData data = store.newSessionData(\"1234\", 100, 200, 199, -1);\r\n    TestFoo testFoo = new TestFoo();\r\n    testFoo.setInt(33);\r\n    FooInvocationHandler handler = new FooInvocationHandler(testFoo);\r\n    Foo foo = (Foo) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class[] { Foo.class }, handler);\r\n    data.setAttribute(\"foo\", foo);\r\n    data.setLastNode(sessionContext.getWorkerName());\r\n    store.store(\"1234\", data);\r\n    checkSessionPersisted(data);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractOperationSetTypingNotifications.addTypingNotificationsListener",
	"Comment": "adds listener to the list of listeners registered for receivingtypingnotificationevents.",
	"Method": "void addTypingNotificationsListener(TypingNotificationsListener listener){\r\n    synchronized (typingNotificationsListeners) {\r\n        if (!typingNotificationsListeners.contains(listener))\r\n            typingNotificationsListeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.common.ParserTest.testParseCase5_6",
	"Comment": "similar to the server side 5.6 testcase. pong, then text, then close frames.",
	"Method": "void testParseCase5_6(){\r\n    List<WebSocketFrame> send = new ArrayList();\r\n    send.add(new PongFrame().setPayload(\"ping\"));\r\n    send.add(new TextFrame().setPayload(\"hello, world\"));\r\n    send.add(new CloseInfo(StatusCode.NORMAL).asFrame());\r\n    ByteBuffer completeBuf = UnitGenerator.generate(send);\r\n    UnitParser parser = new UnitParser();\r\n    IncomingFramesCapture capture = new IncomingFramesCapture();\r\n    parser.setIncomingFramesHandler(capture);\r\n    parser.parse(completeBuf);\r\n    capture.assertErrorCount(0);\r\n    capture.assertHasFrame(OpCode.TEXT, 1);\r\n    capture.assertHasFrame(OpCode.CLOSE, 1);\r\n    capture.assertHasFrame(OpCode.PONG, 1);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.generalconfig.GeneralConfigPluginActivator.getResources",
	"Comment": "gets the service giving access to all application resources.",
	"Method": "ResourceManagementService getResources(){\r\n    if (resourceService == null)\r\n        resourceService = ResourceManagementServiceUtils.getService(bundleContext);\r\n    return resourceService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.googletalkaccregwizz.GoogleTalkAccountRegistrationWizard.getIcon",
	"Comment": "implements the accountregistrationwizard.geticon method.returns the icon to be used for this wizard.",
	"Method": "byte[] getIcon(){\r\n    return GoogleTalkAccRegWizzActivator.getResources().getImageInBytes(PROTOCOL_ICON);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.AdHocChatRoomIcqImpl.sendMessage",
	"Comment": "sends the message to the destination indicated by theto contact.",
	"Method": "void sendMessage(Message message){\r\n    assertConnected();\r\n    try {\r\n        chatRoomSession.sendMessage(message.getContent());\r\n        AdHocChatRoomMessageDeliveredEvent msgDeliveredEvt = new AdHocChatRoomMessageDeliveredEvent(this, new Date(), message, AdHocChatRoomMessageDeliveredEvent.CONVERSATION_MESSAGE_DELIVERED);\r\n        fireMessageEvent(msgDeliveredEvt);\r\n    } catch (Exception e) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Failed to send a conference message.\");\r\n        throw new OperationFailedException(\"Failed to send a conference message.\", OperationFailedException.GENERAL_ERROR);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractOperationSetBasicInstantMessaging.isContentTypeSupported",
	"Comment": "determines whether the protocol supports the supplied content typefor the given contact.",
	"Method": "boolean isContentTypeSupported(String contentType,Contact contact){\r\n    if (contentType.equals(DEFAULT_MIME_TYPE))\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl.getDialog",
	"Comment": "returns the jain sip dialog that has been created by the application forcommunication with this call peer.",
	"Method": "Dialog getDialog(){\r\n    return jainSipDialog;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.menus.AutoAnswerMenu.isAutoAnswerEnabled",
	"Comment": "check whether any auto answer option is enabled for a protocol.",
	"Method": "boolean isAutoAnswerEnabled(ProtocolProviderService providerService){\r\n    OperationSetBasicAutoAnswer opset = providerService.getOperationSet(OperationSetBasicAutoAnswer.class);\r\n    OperationSetAdvancedAutoAnswer opSetAdvanced = providerService.getOperationSet(OperationSetAdvancedAutoAnswer.class);\r\n    if (opset == null)\r\n        return false;\r\n    if (opSetAdvanced != null) {\r\n        if (opSetAdvanced.isAutoAnswerConditionSet()) {\r\n            return true;\r\n        }\r\n        if (!StringUtils.isNullOrEmpty(opSetAdvanced.getCallForward())) {\r\n            return true;\r\n        }\r\n    }\r\n    return opset.isAutoAnswerWithVideoSet() || opset.isAutoAnswerUnconditionalSet();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.removeChatTransport",
	"Comment": "removes the given chat status state from the send via selector box.",
	"Method": "void removeChatTransport(ChatTransport chatTransport){\r\n    writeMessagePanel.removeChatTransport(chatTransport);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.TestOperationSetServerStoredInfo.testReadInfo",
	"Comment": "test reading info. changing info of the testeragen and checkingit through the contactinfo operation set",
	"Method": "void testReadInfo(){\r\n    Object lock = new Object();\r\n    int suffix = (int) (Math.random() * 100);\r\n    String lastName = \"TesterAgent\" + String.valueOf(suffix);\r\n    IcqSlickFixture.testerAgent.setUserInfoLastName(lastName);\r\n    synchronized (lock) {\r\n        try {\r\n            lock.wait(4000);\r\n        } catch (InterruptedException ex) {\r\n        }\r\n    }\r\n    String phoneNumber = \"+3591234\" + suffix;\r\n    IcqSlickFixture.testerAgent.setUserInfoPhoneNumber(phoneNumber);\r\n    synchronized (lock) {\r\n        try {\r\n            lock.wait(4000);\r\n        } catch (InterruptedException ex) {\r\n        }\r\n    }\r\n    int lang1 = 1 + (int) (Math.random() * 72);\r\n    int lang2 = 1 + (int) (Math.random() * 72);\r\n    int lang3 = 1 + (int) (Math.random() * 72);\r\n    IcqSlickFixture.testerAgent.setUserInfoLanguage(lang1, lang2, lang3);\r\n    synchronized (lock) {\r\n        try {\r\n            lock.wait(4000);\r\n        } catch (InterruptedException ex) {\r\n        }\r\n    }\r\n    int countryRandom = 0 + (int) (Math.random() * 232);\r\n    int countryCode = ((Integer) countryIndexToLocaleString[countryRandom][0]).intValue();\r\n    String countryAbr = (String) countryIndexToLocaleString[countryRandom][1];\r\n    IcqSlickFixture.testerAgent.setUserInfoHomeCountry(countryCode);\r\n    synchronized (lock) {\r\n        try {\r\n            lock.wait(4000);\r\n        } catch (InterruptedException ex) {\r\n        }\r\n    }\r\n    Contact testerAgentContact = opSetPresence.findContactByID(IcqSlickFixture.testerAgent.getIcqUIN());\r\n    Iterator<GenericDetail> iter = opSetServerStoredContactInfo.getDetails(testerAgentContact, ServerStoredDetails.LastNameDetail.class);\r\n    while (iter.hasNext()) {\r\n        ServerStoredDetails.LastNameDetail item = (ServerStoredDetails.LastNameDetail) iter.next();\r\n        assertEquals(\"The LastName we set is not set or not read properly\", item.getName(), lastName);\r\n        break;\r\n    }\r\n    iter = opSetServerStoredContactInfo.getDetails(testerAgentContact, ServerStoredDetails.PhoneNumberDetail.class);\r\n    while (iter.hasNext()) {\r\n        ServerStoredDetails.PhoneNumberDetail item = (ServerStoredDetails.PhoneNumberDetail) iter.next();\r\n        assertEquals(\"The PhoneNumber we set is not set or not read properly\", item.getNumber(), phoneNumber);\r\n        break;\r\n    }\r\n    iter = opSetServerStoredContactInfo.getDetails(testerAgentContact, ServerStoredDetails.SpokenLanguageDetail.class);\r\n    List<Locale> spokenLanguagesServer = new ArrayList<Locale>();\r\n    while (iter.hasNext()) {\r\n        ServerStoredDetails.SpokenLanguageDetail item = (ServerStoredDetails.SpokenLanguageDetail) iter.next();\r\n        spokenLanguagesServer.add(item.getLocale());\r\n    }\r\n    assertEquals(\"spoken languages must be 3 \", 3, spokenLanguagesServer.size());\r\n    assertTrue(\"Must contain langiage \" + spokenLanguages[lang1], spokenLanguagesServer.contains(spokenLanguages[lang1]));\r\n    assertTrue(\"Must contain langiage \" + spokenLanguages[lang2], spokenLanguagesServer.contains(spokenLanguages[lang2]));\r\n    assertTrue(\"Must contain langiage \" + spokenLanguages[lang3], spokenLanguagesServer.contains(spokenLanguages[lang3]));\r\n    iter = opSetServerStoredContactInfo.getDetails(testerAgentContact, ServerStoredDetails.CountryDetail.class);\r\n    while (iter.hasNext()) {\r\n        ServerStoredDetails.CountryDetail item = (ServerStoredDetails.CountryDetail) iter.next();\r\n        logger.info(\"read item value: \" + item.getLocale().getDisplayCountry());\r\n        assertEquals(\"The Country we set is not set or not read properly\", item.getLocale(), new Locale(\"\", countryAbr));\r\n        break;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetPersistentPresenceJabberImpl.getPresenceStatus",
	"Comment": "returns a presencestatus instance representing the state this provideris currently in.",
	"Method": "PresenceStatus getPresenceStatus(){\r\n    return currentStatus;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomJabberImpl.addLocalUserRoleListener",
	"Comment": "adds a listener that will be notified of changes in our role in the roomsuch as us being granded operator.",
	"Method": "void addLocalUserRoleListener(ChatRoomLocalUserRoleListener listener){\r\n    synchronized (localUserRoleListeners) {\r\n        if (!localUserRoleListeners.contains(listener))\r\n            localUserRoleListeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.conference.ConferenceFocusPanel.removeConferenceMemberPanel",
	"Comment": "removes the conferencememberpanel depicting a specificconferencemember.",
	"Method": "void removeConferenceMemberPanel(ConferenceMember conferenceMember){\r\n    ConferenceMemberPanel conferenceMemberPanel = conferenceMemberPanels.remove(conferenceMember);\r\n    if (conferenceMemberPanel != null) {\r\n        remove(conferenceMemberPanel);\r\n        conferenceMemberPanel.dispose();\r\n        packWindow();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.sip.SIPAccountRegistration.storeProperties",
	"Comment": "stores configuration properties held by this object into givenaccountproperties map.",
	"Method": "void storeProperties(String userName,String passwd,String protocolIconPath,String accountIconPath,Boolean isModification,Map<String, String> accountProperties){\r\n    if (rememberPassword)\r\n        setPassword(passwd);\r\n    else\r\n        setPassword(null);\r\n    String serverAddress = null;\r\n    String serverFromUsername = getServerFromUserName(userName);\r\n    if (getServerAddress() != null)\r\n        serverAddress = getServerAddress();\r\n    if (serverFromUsername == null && getDefaultDomain() != null) {\r\n        userName = userName + \"@\" + getDefaultDomain();\r\n        if (serverAddress == null)\r\n            serverAddress = getDefaultDomain();\r\n    } else if (serverAddress == null && serverFromUsername != null) {\r\n        serverAddress = serverFromUsername;\r\n    }\r\n    if (serverAddress != null) {\r\n        accountProperties.put(ProtocolProviderFactory.SERVER_ADDRESS, serverAddress);\r\n        if (userName.indexOf(serverAddress) < 0)\r\n            accountProperties.put(ProtocolProviderFactory.IS_SERVER_OVERRIDDEN, Boolean.toString(true));\r\n    }\r\n    if (isProxyAutoConfigure()) {\r\n        removeAccountProperty(ProtocolProviderFactory.PROXY_ADDRESS);\r\n        removeAccountProperty(ProtocolProviderFactory.PROXY_PORT);\r\n        removeAccountProperty(ProtocolProviderFactory.PREFERRED_TRANSPORT);\r\n    }\r\n    if (serverAddress == null) {\r\n        setForceP2PMode(true);\r\n    }\r\n    securityAccountRegistration.storeProperties(this.accountProperties);\r\n    encodingsRegistration.storeProperties(this.accountProperties);\r\n    if (isMessageWaitingIndicationsEnabled()) {\r\n        if (!StringUtils.isNullOrEmpty(getVoicemailURI(), true))\r\n            accountProperties.put(ProtocolProviderFactory.VOICEMAIL_URI, getVoicemailURI());\r\n        else if (isModification)\r\n            accountProperties.put(ProtocolProviderFactory.VOICEMAIL_URI, \"\");\r\n        if (!StringUtils.isNullOrEmpty(getVoicemailCheckURI(), true))\r\n            accountProperties.put(ProtocolProviderFactory.VOICEMAIL_CHECK_URI, getVoicemailCheckURI());\r\n        else if (isModification)\r\n            accountProperties.put(ProtocolProviderFactory.VOICEMAIL_CHECK_URI, \"\");\r\n        if (isModification) {\r\n            accountProperties.put(ProtocolProviderFactory.VOICEMAIL_ENABLED, null);\r\n        }\r\n    } else if (isModification) {\r\n        accountProperties.put(ProtocolProviderFactory.VOICEMAIL_ENABLED, Boolean.FALSE.toString());\r\n    }\r\n    super.storeProperties(protocolIconPath, accountIconPath, accountProperties);\r\n}"
}, {
	"Path": "org.joor.Reflect.match",
	"Comment": "check whether two arrays of types match, converting primitive types totheir corresponding wrappers.",
	"Method": "boolean match(Class<?>[] declaredTypes,Class<?>[] actualTypes){\r\n    if (declaredTypes.length == actualTypes.length) {\r\n        for (int i = 0; i < actualTypes.length; i++) {\r\n            if (actualTypes[i] == NULL.class)\r\n                continue;\r\n            if (wrapper(declaredTypes[i]).isAssignableFrom(wrapper(actualTypes[i])))\r\n                continue;\r\n            return false;\r\n        }\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.TestOperationSetPresence.testSupportedStatusSetForCompleteness",
	"Comment": "verifies that all necessary jabber test states are supported by theimplementation.",
	"Method": "void testSupportedStatusSetForCompleteness(){\r\n    Iterator<PresenceStatus> supportedStatusSetIter = operationSetPresence1.getSupportedStatusSet();\r\n    List<String> supportedStatusNames = new LinkedList<String>();\r\n    while (supportedStatusSetIter.hasNext()) {\r\n        supportedStatusNames.add(supportedStatusSetIter.next().getStatusName());\r\n    }\r\n    List<String> requiredStatusNames = Arrays.asList(JabberStatusEnum.getStatusNames());\r\n    requiredStatusNames.removeAll(supportedStatusNames);\r\n    int unsupported = requiredStatusNames.size();\r\n    assertTrue(\"There are \" + unsupported + \" statuses as follows:\" + requiredStatusNames, unsupported == 0);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.MetaContactChatTransport.allowsTypingNotifications",
	"Comment": "returns true if this chat transport supports typingnotifications, otherwise returns false.",
	"Method": "boolean allowsTypingNotifications(){\r\n    Object tnOpSet = contact.getProtocolProvider().getOperationSet(OperationSetTypingNotifications.class);\r\n    if (tnOpSet != null)\r\n        return true;\r\n    else\r\n        return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.MainFrame.isFrameVisible",
	"Comment": "implements isvisible in the uiservice interface. checks ifthe main application window is visible.",
	"Method": "boolean isFrameVisible(){\r\n    return super.isVisible() && (super.getExtendedState() != JFrame.ICONIFIED);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MclStorageManager.processGroupXmlNode",
	"Comment": "parses groupnode and all of its subnodes, creating correspondinginstances through mclserviceimpl as children ofparentgroup",
	"Method": "void processGroupXmlNode(MetaContactListServiceImpl mclServImpl,String accountID,Element groupNode,MetaContactGroupImpl parentGroup,Map<String, ContactGroup> parentProtoGroups){\r\n    MetaContactGroupImpl currentMetaGroup = null;\r\n    Map<String, ContactGroup> protoGroupsMap = new Hashtable<String, ContactGroup>();\r\n    if (parentGroup == null) {\r\n        currentMetaGroup = mclServImpl.rootMetaGroup;\r\n    } else {\r\n        String groupMetaUID = XMLUtils.getAttribute(groupNode, GROUP_UID_ATTR_NAME);\r\n        String groupDisplayName = XMLUtils.getAttribute(groupNode, GROUP_NAME_ATTR_NAME);\r\n        if (!multiTenantMode) {\r\n            currentMetaGroup = mclServImpl.loadStoredMetaContactGroup(parentGroup, groupMetaUID, groupDisplayName);\r\n        }\r\n        Node protoGroupsNode = XMLUtils.findChild(groupNode, PROTO_GROUPS_NODE_NAME);\r\n        NodeList protoGroups = protoGroupsNode.getChildNodes();\r\n        for (int i = 0; i < protoGroups.getLength(); i++) {\r\n            Node currentProtoGroupNode = protoGroups.item(i);\r\n            if (currentProtoGroupNode.getNodeType() != Node.ELEMENT_NODE)\r\n                continue;\r\n            String groupAccountID = XMLUtils.getAttribute(currentProtoGroupNode, ACCOUNT_ID_ATTR_NAME);\r\n            if (!accountID.equals(groupAccountID))\r\n                continue;\r\n            String protoGroupUID = XMLUtils.getAttribute(currentProtoGroupNode, UID_ATTR_NAME);\r\n            String parentProtoGroupUID = XMLUtils.getAttribute(currentProtoGroupNode, PARENT_PROTO_GROUP_UID_ATTR_NAME);\r\n            Element persistentDataNode = XMLUtils.findChild((Element) currentProtoGroupNode, PERSISTENT_DATA_NODE_NAME);\r\n            String persistentData = \"\";\r\n            if (persistentDataNode != null) {\r\n                persistentData = XMLUtils.getText(persistentDataNode);\r\n            }\r\n            ContactGroup parentProtoGroup = null;\r\n            if (parentProtoGroups != null && parentProtoGroups.size() > 0)\r\n                parentProtoGroup = parentProtoGroups.get(parentProtoGroupUID);\r\n            if (multiTenantMode && currentMetaGroup == null) {\r\n                currentMetaGroup = mclServImpl.loadStoredMetaContactGroup(parentGroup, groupMetaUID, groupDisplayName);\r\n            }\r\n            ContactGroup newProtoGroup = mclServImpl.loadStoredContactGroup(currentMetaGroup, protoGroupUID, parentProtoGroup, persistentData, accountID);\r\n            protoGroupsMap.put(protoGroupUID, newProtoGroup);\r\n        }\r\n        if (protoGroupsMap.size() == 0)\r\n            return;\r\n    }\r\n    Node childContactsNode = XMLUtils.findChild(groupNode, CHILD_CONTACTS_NODE_NAME);\r\n    NodeList childContacts = (childContactsNode == null) ? null : childContactsNode.getChildNodes();\r\n    for (int i = 0; childContacts != null && i < childContacts.getLength(); i++) {\r\n        Node currentMetaContactNode = childContacts.item(i);\r\n        if (currentMetaContactNode.getNodeType() != Node.ELEMENT_NODE)\r\n            continue;\r\n        try {\r\n            String uid = XMLUtils.getAttribute(currentMetaContactNode, UID_ATTR_NAME);\r\n            Element displayNameNode = XMLUtils.findChild((Element) currentMetaContactNode, META_CONTACT_DISPLAY_NAME_NODE_NAME);\r\n            String displayName = XMLUtils.getText(displayNameNode);\r\n            boolean isDisplayNameUserDefined = Boolean.valueOf(displayNameNode.getAttribute(USER_DEFINED_DISPLAY_NAME_ATTR_NAME));\r\n            List<MclStorageManager.StoredProtoContactDescriptor> protoContacts = extractProtoContacts((Element) currentMetaContactNode, accountID, protoGroupsMap);\r\n            if (protoContacts.size() < 1)\r\n                continue;\r\n            Map<String, List<String>> details = null;\r\n            try {\r\n                List<Element> detailsNodes = XMLUtils.findChildren((Element) currentMetaContactNode, META_CONTACT_DETAIL_NAME_NODE_NAME);\r\n                if (detailsNodes.size() > 0) {\r\n                    details = new Hashtable<String, List<String>>();\r\n                    for (Element e : detailsNodes) {\r\n                        String name = e.getAttribute(DETAIL_NAME_ATTR_NAME);\r\n                        String value = e.getAttribute(DETAIL_VALUE_ATTR_NAME);\r\n                        List<String> detailsObj = details.get(name);\r\n                        if (detailsObj == null) {\r\n                            List<String> ds = new ArrayList<String>();\r\n                            ds.add(value);\r\n                            details.put(name, ds);\r\n                        } else\r\n                            detailsObj.add(value);\r\n                    }\r\n                }\r\n            } catch (Exception ex) {\r\n                logger.error(\"Cannot load details for contact node \" + currentMetaContactNode, ex);\r\n            }\r\n            MetaContactImpl mc = mclServImpl.loadStoredMetaContact(currentMetaGroup, uid, displayName, details, protoContacts, accountID);\r\n            if (isDisplayNameUserDefined)\r\n                mc.setDisplayNameUserDefined(true);\r\n        } catch (Throwable thr) {\r\n            logger.warn(\"Failed to parse meta contact \" + currentMetaContactNode + \". Will remove and continue with other contacts\", thr);\r\n            if (currentMetaContactNode.getParentNode() != null) {\r\n                try {\r\n                    currentMetaContactNode.getParentNode().removeChild(currentMetaContactNode);\r\n                } catch (Throwable throwable) {\r\n                    logger.error(\"Failed to remove meta contact node \" + currentMetaContactNode, throwable);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    Node subgroupsNode = XMLUtils.findChild(groupNode, SUBGROUPS_NODE_NAME);\r\n    if (subgroupsNode == null)\r\n        return;\r\n    NodeList subgroups = subgroupsNode.getChildNodes();\r\n    for (int i = 0; i < subgroups.getLength(); i++) {\r\n        Node currentGroupNode = subgroups.item(i);\r\n        if (currentGroupNode.getNodeType() != Node.ELEMENT_NODE || !currentGroupNode.getNodeName().equals(GROUP_NODE_NAME))\r\n            continue;\r\n        try {\r\n            processGroupXmlNode(mclServImpl, accountID, (Element) currentGroupNode, currentMetaGroup, protoGroupsMap);\r\n        } catch (Throwable throwable) {\r\n            logger.error(\"Failed to process group node \" + currentGroupNode + \". Removing.\", throwable);\r\n            if (currentGroupNode.getParentNode() != null) {\r\n                try {\r\n                    currentGroupNode.getParentNode().removeChild(currentGroupNode);\r\n                } catch (Throwable thr) {\r\n                    logger.error(\"Failed to remove group node \" + currentGroupNode, thr);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockProvider.isRegistered",
	"Comment": "mock implementation of the corresponding protocolproviderservice method.",
	"Method": "boolean isRegistered(){\r\n    return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetMultiUserChatJabberImpl.createChatRoom",
	"Comment": "creates a room with the named roomname and according to thespecified roomproperties on the server that this protocolprovider is currently connected to.",
	"Method": "ChatRoom createChatRoom(String roomName,Map<String, Object> roomProperties){\r\n    assertSupportedAndConnected();\r\n    ChatRoom room = null;\r\n    if (roomName == null)\r\n        roomName = \"chatroom-\" + StringUtils.randomString(4);\r\n    else\r\n        room = findRoom(roomName);\r\n    if (room == null) {\r\n        if (logger.isInfoEnabled())\r\n            logger.info(\"Find room returns null.\");\r\n        if (getXmppConnection().getHost().toLowerCase().contains(\"google\")) {\r\n            roomName = \"private-chat-\" + UUID.randomUUID().toString() + \"@groupchat.google.com\";\r\n        }\r\n        MultiUserChat muc = null;\r\n        try {\r\n            muc = new MultiUserChat(getXmppConnection(), getCanonicalRoomName(roomName));\r\n            muc.create(JabberActivator.getGlobalDisplayDetailsService().getDisplayName(jabberProvider));\r\n        } catch (XMPPException ex) {\r\n            logger.error(\"Failed to create chat room.\", ex);\r\n            throw new OperationFailedException(\"Failed to create chat room\", ex.getXMPPError().getCode(), ex.getCause());\r\n        }\r\n        boolean isPrivate = false;\r\n        if (roomProperties != null) {\r\n            Object isPrivateObject = roomProperties.get(\"isPrivate\");\r\n            if (isPrivateObject != null) {\r\n                isPrivate = isPrivateObject.equals(true);\r\n            }\r\n        }\r\n        try {\r\n            Form form;\r\n            if (isPrivate) {\r\n                Form initForm = muc.getConfigurationForm();\r\n                form = initForm.createAnswerForm();\r\n                Iterator<FormField> fieldIterator = initForm.getFields();\r\n                while (fieldIterator.hasNext()) {\r\n                    FormField initField = fieldIterator.next();\r\n                    if (initField == null || initField.getVariable() == null || initField.getType() == FormField.TYPE_FIXED || initField.getType() == FormField.TYPE_HIDDEN)\r\n                        continue;\r\n                    FormField submitField = form.getField(initField.getVariable());\r\n                    if (submitField == null)\r\n                        continue;\r\n                    Iterator<String> value = initField.getValues();\r\n                    while (value.hasNext()) submitField.addValue(value.next());\r\n                }\r\n                String[] fields = { \"muc#roomconfig_membersonly\", \"muc#roomconfig_allowinvites\", \"muc#roomconfig_publicroom\" };\r\n                Boolean[] values = { true, true, false };\r\n                for (int i = 0; i < fields.length; i++) {\r\n                    FormField field = new FormField(fields[i]);\r\n                    field.setType(\"boolean\");\r\n                    form.addField(field);\r\n                    form.setAnswer(fields[i], values[i]);\r\n                }\r\n            } else {\r\n                form = new Form(Form.TYPE_SUBMIT);\r\n            }\r\n            muc.sendConfigurationForm(form);\r\n        } catch (XMPPException e) {\r\n            logger.error(\"Failed to send config form.\", e);\r\n        }\r\n        room = createLocalChatRoomInstance(muc);\r\n        room.setLocalUserRole(ChatRoomMemberRole.OWNER);\r\n    }\r\n    return room;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapDirectorySettingsImpl.hashCode",
	"Comment": "returns the hash code for this instance.it has to be consistent with equals.",
	"Method": "int hashCode(){\r\n    int hash = 7;\r\n    hash = 31 * hash + (null == this.getName() ? 0 : this.getName().hashCode());\r\n    hash = 31 * hash + (null == this.getHostname() ? 0 : this.getHostname().hashCode());\r\n    hash = 31 * hash + (null == this.getEncryption() ? 0 : this.getEncryption().hashCode());\r\n    hash = 31 * hash + this.getPort();\r\n    hash = 31 * hash + (null == this.getAuth() ? 0 : this.getAuth().hashCode());\r\n    hash = 31 * hash + (null == this.getBindDN() ? 0 : this.getBindDN().hashCode());\r\n    hash = 31 * hash + (null == this.getPassword() ? 0 : this.getPassword().hashCode());\r\n    hash = 31 * hash + (null == this.getScope() ? 0 : this.getScope().hashCode());\r\n    hash = 31 * hash + (null == this.getBaseDN() ? 0 : this.getBaseDN().hashCode());\r\n    hash = 31 * hash + (null == this.getGlobalPhonePrefix() ? 0 : this.getGlobalPhonePrefix().hashCode());\r\n    hash = 31 * hash + (null == this.getCustomQuery() ? 0 : this.getCustomQuery().hashCode());\r\n    hash = 32 * hash + (null == this.getQueryMode() ? 0 : this.getQueryMode().hashCode());\r\n    hash = 33 * hash + (this.isMangleQuery() ? 1 : 0);\r\n    hash = 34 * hash + (this.isPhotoInline() ? 1 : 0);\r\n    return hash;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.launchutils.SipCommunicatorLock.getRandomPortNumber",
	"Comment": "returns a random port number that we can use to bind a socket on.",
	"Method": "int getRandomPortNumber(){\r\n    return (int) (Math.random() * 64509) + 1025;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.geolocation.GeolocationPacketExtension.getRoom",
	"Comment": "returns a string indicating a particular room in a building.",
	"Method": "String getRoom(){\r\n    return room;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.MetaContactChatTransport.getMaximumFileLength",
	"Comment": "returns the maximum file length supported by the protocol in bytes.",
	"Method": "long getMaximumFileLength(){\r\n    OperationSetFileTransfer ftOpSet = contact.getProtocolProvider().getOperationSet(OperationSetFileTransfer.class);\r\n    return ftOpSet.getMaximumFileLength();\r\n}"
}, {
	"Path": "net.librec.recommender.cf.rating.LLORMARecommender.getUserSimilarity",
	"Comment": "calculate similarity between two users, based on the global base svd.",
	"Method": "double getUserSimilarity(int userIdx1,int userIdx2){\r\n    double sim;\r\n    DenseVector userVector1 = globalUserFactors.row(userIdx1);\r\n    DenseVector userVector2 = globalUserFactors.row(userIdx2);\r\n    sim = 1 - 2.0 / Math.PI * Math.acos(userVector1.dot(userVector2) / (Math.sqrt(userVector1.dot(userVector1)) * Math.sqrt(userVector2.dot(userVector2))));\r\n    if (Double.isNaN(sim)) {\r\n        sim = 0.0;\r\n    }\r\n    return sim;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageHistoryServiceImpl.findByPeriod",
	"Comment": "returns all the messages exchangedin the supplied chat room between the given dates and having the givenkeywords",
	"Method": "Collection<EventObject> findByPeriod(MetaContact contact,Date startDate,Date endDate,Collection<EventObject> findByPeriod,MetaContact contact,Date startDate,Date endDate,String[] keywords,Collection<EventObject> findByPeriod,MetaContact contact,Date startDate,Date endDate,String[] keywords,boolean caseSensitive,Collection<EventObject> findByPeriod,ChatRoom room,Date startDate,Date endDate,Collection<EventObject> findByPeriod,ChatRoom room,Date startDate,Date endDate,String[] keywords,Collection<EventObject> findByPeriod,ChatRoom room,Date startDate,Date endDate,String[] keywords,boolean caseSensitive){\r\n    HashSet<EventObject> result = new HashSet<EventObject>();\r\n    try {\r\n        HistoryReader reader = this.getHistoryForMultiChat(room).getReader();\r\n        addHistorySearchProgressListeners(reader, 1);\r\n        Iterator<HistoryRecord> recs = reader.findByPeriod(startDate, endDate, keywords, SEARCH_FIELD, caseSensitive);\r\n        while (recs.hasNext()) {\r\n            result.add(convertHistoryRecordToMessageEvent(recs.next(), room));\r\n        }\r\n        removeHistorySearchProgressListeners(reader);\r\n    } catch (IOException e) {\r\n        logger.error(\"Could not read history\", e);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactGroupImpl.countOnlineChildContacts",
	"Comment": "returns the number of online metacontacts that this groupcontains.",
	"Method": "int countOnlineChildContacts(){\r\n    int onlineContactsNumber = 0;\r\n    try {\r\n        Iterator<MetaContact> itr = getChildContacts();\r\n        while (itr.hasNext()) {\r\n            Contact contact = itr.next().getDefaultContact();\r\n            if (contact == null)\r\n                continue;\r\n            if (contact.getPresenceStatus().isOnline()) {\r\n                onlineContactsNumber++;\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Failed to count online contacts.\", e);\r\n    }\r\n    return onlineContactsNumber;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.sip.TestOperationSetPersistentPresence.postTestRenameGroup",
	"Comment": "renames our test group and checks whether corresponding events aretriggered. verifies whether the group has really changed its name andwhether it is findable by its new name. also makes sure that it doesnot exist under its previous name any more.",
	"Method": "void postTestRenameGroup(){\r\n    logger.trace(\"Testing renaming groups.\");\r\n    ContactGroup group = this.opSetPersPresence1.getServerStoredContactListRoot().getGroup(testGroupName);\r\n    GroupChangeCollector groupChangeCollector = new GroupChangeCollector();\r\n    this.opSetPersPresence1.addServerStoredGroupChangeListener(groupChangeCollector);\r\n    this.opSetPersPresence1.renameServerStoredContactGroup(group, testGroupName2);\r\n    groupChangeCollector.waitForEvent(10000);\r\n    this.opSetPersPresence1.removeServerStoredGroupChangeListener(groupChangeCollector);\r\n    assertEquals(\"Collected Group Change event\", 1, groupChangeCollector.collectedEvents.size());\r\n    assertEquals(\"Group name.\", testGroupName2, ((ServerStoredGroupEvent) groupChangeCollector.collectedEvents.get(0)).getSourceGroup().getGroupName());\r\n    ContactGroup oldGroup = this.opSetPersPresence1.getServerStoredContactListRoot().getGroup(testGroupName);\r\n    assertNull(\"A group was still findable by its old name after renaming.\", oldGroup);\r\n    ContactGroup newGroup = this.opSetPersPresence1.getServerStoredContactListRoot().getGroup(testGroupName2);\r\n    assertNotNull(\"Could not find a renamed group by its new name.\", newGroup);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.provdisc.dhcp.ProvisioningDiscoveryServiceDHCPImpl.getMethodName",
	"Comment": "get the name of the method name used to retrieve provisioning url.",
	"Method": "String getMethodName(){\r\n    return METHOD_NAME;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractProtocolProviderService.getProtocolDisplayName",
	"Comment": "returns the protocol display name. this is the name that would be usedby the gui to display the protocol name.",
	"Method": "String getProtocolDisplayName(){\r\n    String displayName = getAccountID().getAccountPropertyString(ProtocolProviderFactory.PROTOCOL);\r\n    return (displayName == null) ? getProtocolName() : displayName;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ProtocolProviderServiceJabberImpl.getAccountID",
	"Comment": "returns the accountid that uniquely identifies the account representedby this instance of the protocolproviderservice.",
	"Method": "AccountID getAccountID(){\r\n    return accountID;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactGroupImpl.getMetaContactSubgroupByUID",
	"Comment": "returns the metacontactgroup with the specified groupuid.",
	"Method": "MetaContactGroup getMetaContactSubgroupByUID(String grpUID){\r\n    Iterator<MetaContactGroup> groupsIter = getSubgroups();\r\n    while (groupsIter.hasNext()) {\r\n        MetaContactGroup mcGroup = groupsIter.next();\r\n        if (mcGroup.getMetaUID().equals(grpUID))\r\n            return mcGroup;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.netaddr.NetworkAddressManagerServiceImpl.getLocalHost",
	"Comment": "returns an inetaddress instance that represents the localhost, and thata socket can bind upon or distribute to peers as a contact address.",
	"Method": "InetAddress getLocalHost(InetAddress intendedDestination){\r\n    InetAddress localHost = null;\r\n    if (logger.isTraceEnabled()) {\r\n        logger.trace(\"Querying for a localhost address\" + \" for intended destination '\" + intendedDestination + \"'\");\r\n    }\r\n    String osVersion;\r\n    if (OSUtils.IS_WINDOWS && !(osVersion = System.getProperty(\"os.version\")).startsWith(\"4\") && !osVersion.startsWith(\"5.0\")) {\r\n        byte[] src = Win32LocalhostRetriever.getSourceForDestination(intendedDestination.getAddress());\r\n        if (src == null) {\r\n            logger.warn(\"Failed to get localhost \");\r\n        } else {\r\n            try {\r\n                localHost = InetAddress.getByAddress(src);\r\n            } catch (UnknownHostException uhe) {\r\n                logger.warn(\"Failed to get localhost\", uhe);\r\n            }\r\n        }\r\n    } else if (OSUtils.IS_MAC) {\r\n        try {\r\n            localHost = BsdLocalhostRetriever.getLocalSocketAddress(new InetSocketAddress(intendedDestination, RANDOM_ADDR_DISC_PORT));\r\n        } catch (IOException e) {\r\n            logger.warn(\"Failed to get localhost\", e);\r\n        }\r\n    } else {\r\n        localHostFinderSocket.connect(intendedDestination, RANDOM_ADDR_DISC_PORT);\r\n        localHost = localHostFinderSocket.getLocalAddress();\r\n        localHostFinderSocket.disconnect();\r\n    }\r\n    if (localHost == null) {\r\n        try {\r\n            localHost = InetAddress.getLocalHost();\r\n        } catch (UnknownHostException e) {\r\n            logger.warn(\"Failed to get localhost \", e);\r\n        }\r\n    }\r\n    if (localHost.isAnyLocalAddress()) {\r\n        if (logger.isTraceEnabled()) {\r\n            logger.trace(\"Socket returned the ANY local address.\" + \" Trying a workaround.\");\r\n        }\r\n        try {\r\n            if (intendedDestination instanceof Inet6Address) {\r\n                boolean done = false;\r\n                Enumeration<NetworkInterface> ifaces = NetworkInterface.getNetworkInterfaces();\r\n                while (!done && ifaces.hasMoreElements()) {\r\n                    Enumeration<InetAddress> addresses = ifaces.nextElement().getInetAddresses();\r\n                    while (addresses.hasMoreElements()) {\r\n                        InetAddress address = addresses.nextElement();\r\n                        if ((address instanceof Inet6Address) && !address.isAnyLocalAddress() && !address.isLinkLocalAddress() && !address.isLoopbackAddress() && !address.isSiteLocalAddress()) {\r\n                            localHost = address;\r\n                            done = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                if (intendedDestination instanceof Inet4Address) {\r\n                    boolean done = false;\r\n                    Enumeration<NetworkInterface> ifaces = NetworkInterface.getNetworkInterfaces();\r\n                    while (!done && ifaces.hasMoreElements()) {\r\n                        Enumeration<InetAddress> addresses = ifaces.nextElement().getInetAddresses();\r\n                        while (addresses.hasMoreElements()) {\r\n                            InetAddress address = addresses.nextElement();\r\n                            if ((address instanceof Inet4Address) && !address.isLoopbackAddress()) {\r\n                                localHost = address;\r\n                                done = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } catch (Exception e) {\r\n            logger.warn(\"Failed to get localhost\", e);\r\n        }\r\n    }\r\n    if (logger.isTraceEnabled())\r\n        logger.trace(\"Returning the localhost address '\" + localHost + \"'\");\r\n    return localHost;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetChangePasswordJabberImpl.changePassword",
	"Comment": "changes the jabber account password of protocolprovider to newpass.",
	"Method": "void changePassword(String newPass){\r\n    org.jivesoftware.smack.AccountManager accountManager = new org.jivesoftware.smack.AccountManager(protocolProvider.getConnection());\r\n    try {\r\n        accountManager.changePassword(newPass);\r\n    } catch (XMPPException e) {\r\n        if (logger.isInfoEnabled()) {\r\n            logger.info(\"Tried to change jabber password, but the server \" + \"does not support inband password changes\", e);\r\n        }\r\n        throw new OperationFailedException(\"In-band password changes not\" + \" supported\", OperationFailedException.NOT_SUPPORTED_OPERATION, e);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.account.LoginManager.serviceChanged",
	"Comment": "implements the servicelistener method. verifies whether thepassed event concerns a protocolproviderservice and adds thecorresponding ui controls.",
	"Method": "void serviceChanged(ServiceEvent event){\r\n    ServiceReference<?> serviceRef = event.getServiceReference();\r\n    if (serviceRef.getBundle().getState() == Bundle.STOPPING)\r\n        return;\r\n    Object service = UtilActivator.bundleContext.getService(serviceRef);\r\n    if (!(service instanceof ProtocolProviderService))\r\n        return;\r\n    switch(event.getType()) {\r\n        case ServiceEvent.REGISTERED:\r\n            handleProviderAdded((ProtocolProviderService) service);\r\n            break;\r\n        case ServiceEvent.UNREGISTERING:\r\n            handleProviderRemoved((ProtocolProviderService) service);\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatManager.serviceChanged",
	"Comment": "handles serviceevents triggered by adding or removing aprotocolproviderservice. updates the list of available chat rooms andchat room servers.",
	"Method": "void serviceChanged(ServiceEvent event){\r\n    if (event.getServiceReference().getBundle().getState() == Bundle.STOPPING)\r\n        return;\r\n    Object service = GuiActivator.bundleContext.getService(event.getServiceReference());\r\n    if (!(service instanceof ProtocolProviderService))\r\n        return;\r\n    ProtocolProviderService protocolProvider = (ProtocolProviderService) service;\r\n    Object multiUserChatAdHocOpSet = protocolProvider.getOperationSet(OperationSetAdHocMultiUserChat.class);\r\n    if (multiUserChatAdHocOpSet != null) {\r\n        if (event.getType() == ServiceEvent.REGISTERED) {\r\n            adHocChatRoomList.addChatProvider(protocolProvider);\r\n        } else if (event.getType() == ServiceEvent.UNREGISTERING) {\r\n            adHocChatRoomList.removeChatProvider(protocolProvider);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.TestFileSessions.testDeleteUnrestorableFiles",
	"Comment": "if deleteunrestorablefiles option is true, a damaged or unrestorablefile should be deleted.",
	"Method": "void testDeleteUnrestorableFiles(){\r\n    ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);\r\n    context.setContextPath(\"/test\");\r\n    SessionDataStoreFactory factory = createSessionDataStoreFactory();\r\n    ((AbstractSessionDataStoreFactory) factory).setGracePeriodSec(10);\r\n    SessionDataStore store = factory.getSessionDataStore(context.getSessionHandler());\r\n    SessionContext sessionContext = new SessionContext(\"foo\", context.getServletContext());\r\n    ((FileSessionDataStore) store).setDeleteUnrestorableFiles(true);\r\n    store.initialize(sessionContext);\r\n    String expectedFilename = (System.currentTimeMillis() + 10000) + \"__test_0.0.0.0_validFile123\";\r\n    FileTestHelper.createFile(expectedFilename);\r\n    FileTestHelper.assertFileExists(expectedFilename, true);\r\n    store.start();\r\n    try {\r\n        store.load(\"validFile123\");\r\n        fail(\"Load should fail\");\r\n    } catch (Exception e) {\r\n    }\r\n    FileTestHelper.assertFileExists(expectedFilename, false);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.AccountStatusPanel.removeAccount",
	"Comment": "removes the account given by protocolprovider from the containedstatus combo box.",
	"Method": "void removeAccount(ProtocolProviderService protocolProvider){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                removeAccount(protocolProvider);\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    if (containsAccount(protocolProvider)) {\r\n        statusComboBox.removeAccount(protocolProvider);\r\n        protocolProvider.removeRegistrationStateChangeListener(this);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.AccountStatusPanel.removeAccount",
	"Comment": "removes the account given by protocolprovider from the containedstatus combo box.",
	"Method": "void removeAccount(ProtocolProviderService protocolProvider){\r\n    removeAccount(protocolProvider);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractCallPeer.getCurrentSecuritySettings",
	"Comment": "returns the currently used security settings of this callpeer.",
	"Method": "CallPeerSecurityStatusEvent getCurrentSecuritySettings(){\r\n    return lastSecurityEvent;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomIrcImpl.addPropertyChangeListener",
	"Comment": "adds listener to the list of listeners registered to receiveevents upon modification of chat room properties such as its subject forexample.",
	"Method": "void addPropertyChangeListener(ChatRoomPropertyChangeListener listener){\r\n    synchronized (propertyChangeListeners) {\r\n        if (!propertyChangeListeners.contains(listener)) {\r\n            propertyChangeListeners.add(listener);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AccountInfoUtils.getLastName",
	"Comment": "returns the last name of the account, to which the givenaccountinfoopset belongs.",
	"Method": "String getLastName(OperationSetServerStoredAccountInfo accountInfoOpSet){\r\n    LastNameDetail lastName = null;\r\n    Iterator<GenericDetail> lastNameDetails = accountInfoOpSet.getDetails(LastNameDetail.class);\r\n    if (lastNameDetails.hasNext())\r\n        lastName = (LastNameDetail) lastNameDetails.next();\r\n    if (lastName == null)\r\n        return null;\r\n    return lastName.getString();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AccountManager.isAccountLoaded",
	"Comment": "checks if the account corresponding to the given accountid isloaded. an account is loaded if its protocolproviderservice isregistered in the bundle context. by default all accounts are loaded.however the user could manually unload an account, which would beunregistered from the bundle context, but would remain in theconfiguration file.",
	"Method": "boolean isAccountLoaded(AccountID accountID){\r\n    return storedAccounts.contains(accountID) && accountID.isEnabled();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetVideoTelephonyJabberImpl.createVideoCall",
	"Comment": "create a new video call and invite the specified callpeer to it.",
	"Method": "Call createVideoCall(String uri,Call createVideoCall,Contact callee){\r\n    return createOutgoingVideoCall(callee.getAddress());\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.FileUtils.getIcon",
	"Comment": "returns the native icon of the given file if one exists, otherwisereturns null.",
	"Method": "Icon getIcon(File file){\r\n    Icon fileIcon = null;\r\n    try {\r\n        fileIcon = FileSystemView.getFileSystemView().getSystemIcon(file);\r\n    } catch (Exception e) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Failed to obtain file icon from ShellFolder.\", e);\r\n        try {\r\n            fileIcon = new JFileChooser().getIcon(file);\r\n        } catch (Exception e1) {\r\n            if (logger.isDebugEnabled())\r\n                logger.debug(\"Failed to obtain file icon from JFileChooser.\", e1);\r\n        }\r\n    }\r\n    return fileIcon;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.caps.EntityCapsManager.formFieldValuesToCaps",
	"Comment": "converts the form field values in the ffvaluesiter into acaps string.",
	"Method": "void formFieldValuesToCaps(Iterator<String> ffValuesIter,StringBuilder capsBldr){\r\n    SortedSet<String> fvs = new TreeSet<String>();\r\n    while (ffValuesIter.hasNext()) fvs.add(ffValuesIter.next());\r\n    for (String fv : fvs) capsBldr.append(fv).append('<');\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.contactsource.AsyncContactSourceService.createContactQuery",
	"Comment": "creates query that searches for sourcecontactswhich match a specific query string.",
	"Method": "ContactQuery createContactQuery(String query,ContactQuery createContactQuery,String query,int contactCount){\r\n    return createContactQuery(Pattern.compile(query, Pattern.CASE_INSENSITIVE | Pattern.LITERAL));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ScServiceDiscoveryManager.interceptPacket",
	"Comment": "intercepts outgoing presence packets and adds entity capabilities attheir ends.",
	"Method": "void interceptPacket(Packet packet){\r\n    if ((packet instanceof Presence) && (capsManager != null)) {\r\n        String ver = getEntityCapsVersion();\r\n        CapsPacketExtension caps = new CapsPacketExtension(getExtFeatures(), capsManager.getNode(), CapsPacketExtension.HASH_METHOD, ver);\r\n        discoveryManager.setNodeInformationProvider(caps.getNode() + \"#\" + caps.getVersion(), this);\r\n        PacketExtension oldCaps = packet.getExtension(CapsPacketExtension.ELEMENT_NAME, CapsPacketExtension.NAMESPACE);\r\n        if (oldCaps != null) {\r\n            packet.removeExtension(oldCaps);\r\n        }\r\n        packet.addExtension(caps);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.ChatRoomQuery.contentChanged",
	"Comment": "indicates that a change has occurred in the chat room data list.",
	"Method": "void contentChanged(ChatRoomListChangeEvent evt){\r\n    ChatRoomWrapper chatRoom = evt.getSourceChatRoom();\r\n    switch(evt.getEventID()) {\r\n        case ChatRoomListChangeEvent.CHAT_ROOM_ADDED:\r\n            addChatRoom(chatRoom.getChatRoom(), false, chatRoom.isAutojoin());\r\n            break;\r\n        case ChatRoomListChangeEvent.CHAT_ROOM_REMOVED:\r\n            LinkedList<ChatRoomSourceContact> tmpContactResults;\r\n            synchronized (contactResults) {\r\n                tmpContactResults = new LinkedList<ChatRoomSourceContact>(contactResults);\r\n                for (ChatRoomSourceContact contact : tmpContactResults) {\r\n                    if (contactEqualsChatRoom(contact, chatRoom)) {\r\n                        contactResults.remove(contact);\r\n                        fireContactRemoved(contact);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n        case ChatRoomListChangeEvent.CHAT_ROOM_CHANGED:\r\n            synchronized (contactResults) {\r\n                for (ChatRoomSourceContact contact : contactResults) {\r\n                    if (contactEqualsChatRoom(contact, chatRoom.getChatRoom())) {\r\n                        if (chatRoom.isAutojoin() != contact.isAutoJoin()) {\r\n                            contact.setAutoJoin(chatRoom.isAutojoin());\r\n                            fireContactChanged(contact);\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.VolumeControlSlider.addNotify",
	"Comment": "makes this component displayable by connecting it to a native screenresource. starts the thread loop to change volume.",
	"Method": "void addNotify(){\r\n    super.addNotify();\r\n    volumeChange(new VolumeChangeEvent(volumeControl, volumeControl.getVolume(), volumeControl.getMute()));\r\n    if (!setVolumeThread.isAlive()) {\r\n        setVolumeThread = new SetVolumeThread(volumeControl);\r\n        setVolumeThread.start();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.menus.ChatToolsMenu.actionPerformed",
	"Comment": "handles the actionevent when one of the menu items isselected.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    super.actionPerformed(e);\r\n    String action = e.getActionCommand();\r\n    if (action.equals(ACTCMD_VIEW_TOOLBAR)) {\r\n        this.chatWindow.setToolbarVisible(viewToolBar.isSelected());\r\n        ConfigurationUtils.setChatToolbarVisible(viewToolBar.isSelected());\r\n    } else if (action.equals(ACTCMD_VIEW_SMILEYS)) {\r\n        ConfigurationUtils.setShowSmileys(viewSmileys.isSelected());\r\n    } else if (action.equals(ACTCMD_VIEW_SIMPLE_THEME)) {\r\n        ConfigurationUtils.setChatSimpleThemeEnabled(chatSimpleTheme.isSelected());\r\n        List<ChatPanel> currentChats = chatWindow.getChats();\r\n        if (currentChats != null) {\r\n            Iterator<ChatPanel> chatsIter = currentChats.iterator();\r\n            while (chatsIter.hasNext()) {\r\n                chatsIter.next().loadSkin();\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.generalconfig.autoaway.AutoAwayWatcher.serviceChanged",
	"Comment": "when new protocol provider is registered we add ourregistration change listener.if unregistered remove reference to the provider and theregistration change listener.",
	"Method": "void serviceChanged(ServiceEvent serviceEvent){\r\n    Object service = GeneralConfigPluginActivator.bundleContext.getService(serviceEvent.getServiceReference());\r\n    if (service instanceof ProtocolProviderService) {\r\n        int serviceEventType = serviceEvent.getType();\r\n        if (serviceEventType == ServiceEvent.REGISTERED)\r\n            handleProviderAdded((ProtocolProviderService) service);\r\n        else if (serviceEventType == ServiceEvent.UNREGISTERING)\r\n            handleProviderRemoved((ProtocolProviderService) service);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.MetaContactListSource.metaContactGroupRemoved",
	"Comment": "removes the corresponding group node in the contact list, when ametacontactgroup has been removed from themetacontactlistservice.",
	"Method": "void metaContactGroupRemoved(MetaContactGroupEvent evt){\r\n    MetaContactGroup metaGroup = evt.getSourceMetaContactGroup();\r\n    UIGroup uiGroup;\r\n    synchronized (metaGroup) {\r\n        uiGroup = MetaContactListSource.getUIGroup(metaGroup);\r\n    }\r\n    if (uiGroup != null)\r\n        GuiActivator.getContactList().removeGroup(uiGroup);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.otr.OtrConfigurator.appendProperty",
	"Comment": "appends value to the old value of the property with thespecified name. the two values will be comma separated.",
	"Method": "void appendProperty(String id,Object value){\r\n    Object oldValue = OtrActivator.configService.getProperty(getID(id));\r\n    String newValue = oldValue == null ? value.toString() : oldValue + \",\" + value;\r\n    setProperty(id, newValue);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.fileaccess.TestFileAccessService.testDeletePersistentFile",
	"Comment": "this test will always pass, because it is not guaranteed that it ispossible for the supplied file to be deleted. it is used in conjunctionwith the other tests",
	"Method": "void testDeletePersistentFile(){\r\n    try {\r\n        File file = this.fileAccessService.getPrivatePersistentFile(fileName, FileCategory.PROFILE);\r\n        if (file.exists()) {\r\n            file.delete();\r\n        }\r\n    } catch (Exception e) {\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaAwareCallPeer.getCall",
	"Comment": "returns a reference to the call that this peer belongs to. callsare created by underlying telephony protocol implementations.",
	"Method": "T getCall(){\r\n    return call;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.msoutlook.MsOutlookMAPIHResultException.getHresultString",
	"Comment": "returns the string representation for the current hresult code.",
	"Method": "String getHresultString(){\r\n    return MsOutlookMAPIHResultException.toString(this.getHResult());\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.thunderbird.ThunderbirdConfigForm.updateStates",
	"Comment": "enables or disables the controls enabled state based on the enabledcheckbox.",
	"Method": "void updateStates(){\r\n    txtFilename.setEnabled(chkEnabled.isSelected());\r\n    txtPrefix.setEnabled(chkEnabled.isSelected());\r\n    cmdBrowse.setEnabled(chkEnabled.isSelected());\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaAwareCallPeer.isLocalVideoStreaming",
	"Comment": "determines whether we are currently streaming video toward whoever thismediaawarecallpeer represents.",
	"Method": "boolean isLocalVideoStreaming(){\r\n    return getMediaHandler().isLocalVideoTransmissionEnabled();\r\n}"
}, {
	"Path": "net.librec.eval.ranking.AUCEvaluator.evaluate",
	"Comment": "evaluate on the test set with the the list of recommended items.",
	"Method": "double evaluate(RecommendedList groundTruthList,RecommendedList recommendedList){\r\n    double auc = 0.0d;\r\n    int numContext = groundTruthList.size();\r\n    int nonZeroContext = 0;\r\n    int[] numDroppedArray = getConf().getInts(\"rec.eval.auc.dropped.num\");\r\n    if (numDroppedArray == null || numDroppedArray.length != numContext) {\r\n        throw new LibrecRuntimeException(\"please set rec.eval.auc.dropped.num arrays, length of numDroppedArray must be cardinality of groundTruthList.\");\r\n    }\r\n    for (int contextIdx = 0; contextIdx < numContext; ++contextIdx) {\r\n        Set<Integer> groudTruthSetByContext = groundTruthList.getKeySetByContext(contextIdx);\r\n        if (groudTruthSetByContext.size() > 0) {\r\n            nonZeroContext++;\r\n            List<KeyValue<Integer, Double>> recommendListByContext = recommendedList.getKeyValueListByContext(contextIdx);\r\n            int topK = this.topN <= recommendListByContext.size() ? this.topN : recommendListByContext.size();\r\n            int numDroppedItems = numDroppedArray[contextIdx] - topK;\r\n            Set<Integer> recommendSetByContext = new HashSet();\r\n            for (int indexOfKey = 0; indexOfKey < topK; ++indexOfKey) {\r\n                recommendSetByContext.add(recommendListByContext.get(indexOfKey).getKey());\r\n            }\r\n            int numRelevantKeys = 0, numMissKeys = 0;\r\n            for (Integer testKey : recommendSetByContext) {\r\n                if (groudTruthSetByContext.contains(testKey)) {\r\n                    numRelevantKeys++;\r\n                } else {\r\n                    numMissKeys++;\r\n                }\r\n            }\r\n            int numEvaluatingItems = numDroppedItems + topK;\r\n            int numEvaluatingPairs = (numEvaluatingItems - numRelevantKeys) * numRelevantKeys;\r\n            if (numEvaluatingPairs < 0) {\r\n                throw new IndexOutOfBoundsException(\"numEvaluatingPairs cannot be less than 0.\");\r\n            }\r\n            if (numEvaluatingPairs == 0) {\r\n                auc += 0.5;\r\n                continue;\r\n            }\r\n            int numCorrectPairs = 0;\r\n            int hits = 0;\r\n            for (Integer itemIdx : groudTruthSetByContext) {\r\n                if (!recommendSetByContext.contains(itemIdx)) {\r\n                    numCorrectPairs += hits;\r\n                } else {\r\n                    hits++;\r\n                }\r\n            }\r\n            numCorrectPairs += hits * (numDroppedItems - numMissKeys);\r\n            auc += (numCorrectPairs + 0.0) / numEvaluatingPairs;\r\n        }\r\n    }\r\n    return nonZeroContext > 0 ? auc / nonZeroContext : 0.0d;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.sip.TestOperationSetBasicInstantMessaging.prepareContactList",
	"Comment": "create the list to be sure that contacts exchanging messagesexists in each other lists",
	"Method": "void prepareContactList(){\r\n    fixture.clearProvidersLists();\r\n    Object o = new Object();\r\n    synchronized (o) {\r\n        o.wait(2000);\r\n    }\r\n    try {\r\n        opSetPresence1.subscribe(fixture.userID2);\r\n    } catch (OperationFailedException ex) {\r\n        if (ex.getErrorCode() != OperationFailedException.SUBSCRIPTION_ALREADY_EXISTS) {\r\n            throw ex;\r\n        } else {\r\n        }\r\n    }\r\n    try {\r\n        opSetPresence2.subscribe(fixture.userID1);\r\n    } catch (OperationFailedException ex) {\r\n        if (ex.getErrorCode() != OperationFailedException.SUBSCRIPTION_ALREADY_EXISTS) {\r\n            throw ex;\r\n        } else {\r\n        }\r\n    }\r\n    Iterator<PresenceStatus> iter = opSetPresence1.getSupportedStatusSet();\r\n    while (iter.hasNext()) {\r\n        PresenceStatus stat = iter.next();\r\n        if (stat.isOnline()) {\r\n            opSetPresence1.publishPresenceStatus(stat, \"online for testing purpose\");\r\n            break;\r\n        }\r\n    }\r\n    iter = opSetPresence2.getSupportedStatusSet();\r\n    while (iter.hasNext()) {\r\n        PresenceStatus stat = iter.next();\r\n        if (stat.isOnline()) {\r\n            opSetPresence2.publishPresenceStatus(stat, \"online for testing purpose\");\r\n            break;\r\n        }\r\n    }\r\n    logger.info(\"will wait till the list prepare is completed\");\r\n    synchronized (o) {\r\n        o.wait(4000);\r\n    }\r\n}"
}, {
	"Path": "net.librec.eval.ranking.NormalizedDCGEvaluator.evaluate",
	"Comment": "evaluate on the test set with the the list of recommended items.",
	"Method": "double evaluate(RecommendedList groundTruthList,RecommendedList recommendedList){\r\n    double nDCG = 0.0;\r\n    int numContext = groundTruthList.size();\r\n    int nonZeroContext = 0;\r\n    for (int contextIdx = 0; contextIdx < numContext; ++contextIdx) {\r\n        Set<Integer> testSetByContext = groundTruthList.getKeySetByContext(contextIdx);\r\n        if (testSetByContext.size() > 0) {\r\n            List<KeyValue<Integer, Double>> groundTruthTestSetByContext = groundTruthList.getKeyValueListByContext(contextIdx);\r\n            List<KeyValue<Integer, Double>> recommendListByContext = recommendedList.getKeyValueListByContext(contextIdx);\r\n            boolean hasdcgsValue = false;\r\n            List<RankRate> groundTruthTestSet = new ArrayList();\r\n            for (int i = 0; i < groundTruthTestSetByContext.size(); i++) {\r\n                groundTruthTestSet.add(new RankRate(groundTruthTestSetByContext.get(i).getKey(), groundTruthTestSetByContext.get(i).getValue()));\r\n            }\r\n            double dcg = 0.0;\r\n            int topK = this.topN <= recommendListByContext.size() ? this.topN : recommendListByContext.size();\r\n            for (int indexOfKey = 0; indexOfKey < topK; ++indexOfKey) {\r\n                int itemID = recommendListByContext.get(indexOfKey).getKey();\r\n                if (!testSetByContext.contains(itemID)) {\r\n                    continue;\r\n                }\r\n                double rankvalue = getValueByKey(groundTruthTestSet, itemID);\r\n                hasdcgsValue = true;\r\n                dcg += rankvalue / Maths.log(indexOfKey + 2, 2);\r\n            }\r\n            if (!hasdcgsValue || dcg == 0) {\r\n                ++nonZeroContext;\r\n                continue;\r\n            }\r\n            double idcg = 0.0d;\r\n            ArrayList idcgsValue = new ArrayList();\r\n            for (int i = 0; i < groundTruthTestSet.size(); i++) {\r\n                if (groundTruthTestSet.get(i).getIndexId() == -1) {\r\n                    idcgsValue.add(groundTruthTestSet.get(i).getValue());\r\n                }\r\n            }\r\n            Collections.sort(idcgsValue, Collections.reverseOrder());\r\n            for (int i = 0; i < idcgsValue.size(); i++) {\r\n                idcg += (double) idcgsValue.get(i) / Maths.log(i + 2, 2);\r\n            }\r\n            if (idcg == 0) {\r\n                ++nonZeroContext;\r\n                continue;\r\n            }\r\n            nDCG += dcg / idcg;\r\n            ++nonZeroContext;\r\n        }\r\n    }\r\n    return nonZeroContext > 0 ? nDCG / nonZeroContext : 0.0d;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.geolocation.GeolocationPacketExtension.getBuilding",
	"Comment": "returns the name of a specific building on a street or in an area.",
	"Method": "String getBuilding(){\r\n    return building;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.runner.ScTestRunner.getLoader",
	"Comment": "always use the standardtestsuiteloader. overridden frombasetestrunner.",
	"Method": "TestSuiteLoader getLoader(){\r\n    return new StandardTestSuiteLoader();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatConversationComponent.setWarningStyle",
	"Comment": "updates the background color to catch user attention if anythingunexpected has happened.",
	"Method": "void setWarningStyle(boolean isWarningStyle){\r\n    if (isWarningStyle)\r\n        backgroundColor = warningColor;\r\n    else\r\n        backgroundColor = defaultColor;\r\n    this.repaint();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetGeolocationJabberImpl.addGeolocationListener",
	"Comment": "registers a listener that would get notifications any time a contactrefreshed its geolocation via presence.",
	"Method": "void addGeolocationListener(GeolocationListener listener){\r\n    synchronized (geolocationContactsListeners) {\r\n        geolocationContactsListeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ContactGroupIcqImpl.contacts",
	"Comment": "returns an iterator over all contacts, member of thiscontactgroup.",
	"Method": "Iterator<Contact> contacts(){\r\n    return buddies.values().iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.neomedia.ZrtpConfigureTableModel.saveConfig",
	"Comment": "saves the zrtpconfigure data for this algorithm to configure file",
	"Method": "void saveConfig(){\r\n    StringBuffer algoStr = new StringBuffer();\r\n    for (T sh : active.algos(algorithm)) {\r\n        algoStr.append(sh.name());\r\n        algoStr.append(';');\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.CallPeerMediaHandlerJabberImpl.setTransportManager",
	"Comment": "sets the transportmanager implementation to handle our addressmanagement by jingle transport xml namespace.",
	"Method": "void setTransportManager(String xmlns){\r\n    if ((transportManager != null) && transportManager.getXmlNamespace().equals(xmlns)) {\r\n        return;\r\n    }\r\n    CallPeerJabberImpl peer = getPeer();\r\n    if (!peer.getProtocolProvider().getDiscoveryManager().includesFeature(xmlns)) {\r\n        throw new IllegalArgumentException(\"Unsupported Jingle transport \" + xmlns);\r\n    }\r\n    switch(xmlns) {\r\n        case ProtocolProviderServiceJabberImpl.URN_XMPP_JINGLE_ICE_UDP_1:\r\n            transportManager = new IceUdpTransportManager(peer);\r\n            break;\r\n        case ProtocolProviderServiceJabberImpl.URN_XMPP_JINGLE_RAW_UDP_0:\r\n            transportManager = new RawUdpTransportManager(peer);\r\n            break;\r\n        default:\r\n            throw new IllegalArgumentException(\"Unsupported Jingle \" + \"transport \" + xmlns);\r\n    }\r\n    synchronized (transportManagerSyncRoot) {\r\n        transportManagerSyncRoot.notify();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.gibberishaccregwizz.GibberishAccountRegistrationWizard.getIcon",
	"Comment": "implements the accountregistrationwizard.geticon method.returns the icon to be used for this wizard.",
	"Method": "byte[] getIcon(){\r\n    return Resources.getImage(Resources.GIBBERISH_LOGO);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.MetaUIContact.getDefaultContactDetail",
	"Comment": "returns the default contactdetail to use for any operationsdepending to the given operationset class.",
	"Method": "UIContactDetail getDefaultContactDetail(Class<? extends OperationSet> opSetClass){\r\n    List<UIContactDetail> details = getContactDetailsForOperationSet(opSetClass);\r\n    return (details != null && !details.isEmpty()) ? details.get(0) : null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.MetaContactListSource.metaContactAvatarUpdated",
	"Comment": "notifies the tree model, when the metacontact avatar has beenmodified in the metacontactlistservice.",
	"Method": "void metaContactAvatarUpdated(MetaContactAvatarUpdateEvent evt){\r\n    MetaContact metaContact = evt.getSourceMetaContact();\r\n    UIContactImpl uiContact;\r\n    synchronized (metaContact) {\r\n        uiContact = MetaContactListSource.getUIContact(metaContact);\r\n    }\r\n    if (uiContact != null) {\r\n        synchronized (uiContact) {\r\n            ContactNode contactNode = uiContact.getContactNode();\r\n            if (contactNode != null)\r\n                GuiActivator.getContactList().nodeChanged(contactNode);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.presence.avatar.imagepicker.ImagePickerDialog.initDialog",
	"Comment": "initialize the dialog with the already created components.",
	"Method": "void initDialog(){\r\n    this.setTitle(DesktopUtilActivator.getResources().getI18NString(\"service.gui.avatar.imagepicker.IMAGE_PICKER\"));\r\n    this.setModal(true);\r\n    this.setResizable(true);\r\n    this.setLayout(new BorderLayout());\r\n    TransparentPanel editButtonsPanel = new TransparentPanel();\r\n    editButtonsPanel.setLayout(new FlowLayout(FlowLayout.LEFT));\r\n    editButtonsPanel.add(this.selectFileButton);\r\n    editButtonsPanel.add(this.webcamButton);\r\n    TransparentPanel okCancelPanel = new TransparentPanel();\r\n    okCancelPanel.setLayout(new FlowLayout(FlowLayout.RIGHT));\r\n    okCancelPanel.add(cancelButton);\r\n    okCancelPanel.add(okButton);\r\n    TransparentPanel buttonsPanel = new TransparentPanel();\r\n    buttonsPanel.setLayout(new BorderLayout());\r\n    buttonsPanel.add(editButtonsPanel, BorderLayout.WEST);\r\n    buttonsPanel.add(okCancelPanel, BorderLayout.CENTER);\r\n    this.add(this.editPanel, BorderLayout.CENTER);\r\n    this.add(buttonsPanel, BorderLayout.SOUTH);\r\n    this.pack();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.CallConference.containsCall",
	"Comment": "determines whether a specific call is participating in thistelephony conference.",
	"Method": "boolean containsCall(Call call){\r\n    synchronized (callsSyncRoot) {\r\n        return mutableCalls.contains(call);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.whiteboard.gui.WhiteboardFrame.id",
	"Comment": "returns a string uniquely identifying this whiteboardframe",
	"Method": "String id(){\r\n    return String.valueOf(System.currentTimeMillis()) + String.valueOf(super.hashCode());\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaHandler.registerRTPExtensionsWithStream",
	"Comment": "registers with the specified mediastream all rtp extensionsnegotiated by this mediahandler.",
	"Method": "void registerRTPExtensionsWithStream(CallPeerMediaHandler<?> callPeerMediaHandler,List<RTPExtension> rtpExtensions,MediaStream stream){\r\n    DynamicRTPExtensionsRegistry rtpExtensionsRegistry = callPeerMediaHandler.getRtpExtensionsRegistry();\r\n    for (RTPExtension rtpExtension : rtpExtensions) {\r\n        byte extensionID = rtpExtensionsRegistry.getExtensionMapping(rtpExtension);\r\n        stream.addRTPExtension(extensionID, rtpExtension);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.googlecontacts.OAuth2TokenStore.requestAuthenticationToken",
	"Comment": "request an authentication token using the approval code received from theuser.",
	"Method": "TokenData requestAuthenticationToken(String approvalCode){\r\n    final HttpClient client = new DefaultHttpClient();\r\n    final HttpPost post = new HttpPost(GOOGLE_OAUTH2_TOKEN_SERVER.toURI());\r\n    final UrlEncodedFormEntity entity = new UrlEncodedFormEntity(Arrays.asList(new BasicNameValuePair(\"code\", approvalCode), new BasicNameValuePair(\"client_id\", GOOGLE_API_CLIENT_ID), new BasicNameValuePair(\"client_secret\", GOOGLE_API_CLIENT_SECRET), new BasicNameValuePair(\"redirect_uri\", GOOGLE_API_OAUTH2_REDIRECT_URI), new BasicNameValuePair(\"grant_type\", GOOGLE_API_GRANT_TYPE)));\r\n    post.setEntity(entity);\r\n    final HttpResponse httpResponse = client.execute(post);\r\n    final String responseJson = EntityUtils.toString(httpResponse.getEntity(), StandardCharsets.UTF_8);\r\n    if (httpResponse.getStatusLine().getStatusCode() != 200) {\r\n        JsonElement element = new JsonParser().parse(responseJson);\r\n        if (element.isJsonObject()) {\r\n            JsonElement description = element.getAsJsonObject().get(\"error_description\");\r\n            if (description != null) {\r\n                throw new IOException(description.getAsString());\r\n            }\r\n        }\r\n        throw new IOException(httpResponse.getStatusLine().getReasonPhrase());\r\n    }\r\n    return GSON.fromJson(responseJson, TokenData.class);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.RootContactGroupIcqImpl.countSubgroups",
	"Comment": "returns the number of subgroups contained by thisrootcontactgroupicqimpl.",
	"Method": "int countSubgroups(){\r\n    return subGroups.size();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.UIServiceImpl.restore",
	"Comment": "implements restore in the uiservice interface. restoresthe main application window.",
	"Method": "void restore(){\r\n    if (mainFrame.isFrameVisible()) {\r\n        if (mainFrame.getState() == JFrame.ICONIFIED)\r\n            mainFrame.setState(JFrame.NORMAL);\r\n        mainFrame.toFront();\r\n    } else\r\n        mainFrame.setFrameVisible(true);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.notification.NotificationActivator.getConfigurationService",
	"Comment": "returns a reference to a configurationservice implementation currentlyregistered in the bundle context or null if no such implementation wasfound.",
	"Method": "ConfigurationService getConfigurationService(){\r\n    if (configurationService == null) {\r\n        configurationService = ServiceUtils.getService(bundleContext, ConfigurationService.class);\r\n    }\r\n    return configurationService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.callhistory.CallHistoryQueryImpl.fireQueryStatusEvent",
	"Comment": "notifies all registered historyquerylisteners that a new recordhas been received.",
	"Method": "void fireQueryStatusEvent(int newStatus){\r\n    CallHistoryQueryStatusEvent event = new CallHistoryQueryStatusEvent(this, newStatus);\r\n    synchronized (queryListeners) {\r\n        for (CallHistoryQueryListener l : queryListeners) l.queryStatusChanged(event);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AccountManager.unloadAccount",
	"Comment": "unloads the account corresponding to the given accountid. anaccount is unloaded when its protocolproviderservice isunregistered in the bundle context. this method is meant to unload theaccount through the corresponding protocolproviderfactory.",
	"Method": "void unloadAccount(AccountID accountID){\r\n    if (!isAccountLoaded(accountID))\r\n        return;\r\n    ProtocolProviderFactory providerFactory = ProtocolProviderActivator.getProtocolProviderFactory(accountID.getProtocolName());\r\n    ServiceReference<ProtocolProviderService> serRef = providerFactory.getProviderForAccount(accountID);\r\n    if (serRef == null)\r\n        return;\r\n    ProtocolProviderService protocolProvider = bundleContext.getService(serRef);\r\n    String iconPathProperty = accountID.getAccountPropertyString(ProtocolProviderFactory.ACCOUNT_ICON_PATH);\r\n    if (iconPathProperty == null) {\r\n        accountID.putAccountProperty(ProtocolProviderFactory.ACCOUNT_ICON_PATH, protocolProvider.getProtocolIcon().getIconPath(ProtocolIcon.ICON_SIZE_32x32));\r\n    }\r\n    accountID.putAccountProperty(ProtocolProviderFactory.IS_ACCOUNT_DISABLED, String.valueOf(true));\r\n    if (!providerFactory.unloadAccount(accountID)) {\r\n        accountID.putAccountProperty(ProtocolProviderFactory.IS_ACCOUNT_DISABLED, String.valueOf(false));\r\n    }\r\n    storeAccount(providerFactory, accountID);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.accountinfo.AccountDetailsPanel.initUnsupportedPanel",
	"Comment": "creates the panel that indicates to the user that the currently selectedcontact does not support server stored contact info.",
	"Method": "void initUnsupportedPanel(){\r\n    JTextArea unsupportedTextArea = new JTextArea(Resources.getString(\"plugin.accountinfo.NOT_SUPPORTED\"));\r\n    unsupportedTextArea.setEditable(false);\r\n    unsupportedTextArea.setOpaque(false);\r\n    JPanel unsupportedPanel = new TransparentPanel();\r\n    unsupportedPanel.setBorder(BorderFactory.createEmptyBorder(50, 20, 50, 20));\r\n    unsupportedPanel.add(unsupportedTextArea);\r\n    this.add(unsupportedPanel, BorderLayout.NORTH);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.account.AccountList.mousePressed",
	"Comment": "dispatches the mouse event to the contained renderer check box.",
	"Method": "void mousePressed(MouseEvent e){\r\n    dispatchEventToCheckBox(e);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.thumbnail.FileElement.parseIQ",
	"Comment": "parses the given parser in order to create afileelement from it.",
	"Method": "IQ parseIQ(XmlPullParser parser){\r\n    boolean done = false;\r\n    String id = parser.getAttributeValue(\"\", \"id\");\r\n    String mimeType = parser.getAttributeValue(\"\", \"mime-type\");\r\n    StreamInitiation initiation = new StreamInitiation();\r\n    String name = null;\r\n    String size = null;\r\n    String hash = null;\r\n    String date = null;\r\n    String desc = null;\r\n    ThumbnailElement thumbnail = null;\r\n    boolean isRanged = false;\r\n    DataForm form = null;\r\n    DataFormProvider dataFormProvider = new DataFormProvider();\r\n    int eventType;\r\n    String elementName;\r\n    String namespace;\r\n    while (!done) {\r\n        eventType = parser.next();\r\n        elementName = parser.getName();\r\n        namespace = parser.getNamespace();\r\n        if (eventType == XmlPullParser.START_TAG) {\r\n            if (elementName.equals(\"file\")) {\r\n                name = parser.getAttributeValue(\"\", \"name\");\r\n                size = parser.getAttributeValue(\"\", \"size\");\r\n                hash = parser.getAttributeValue(\"\", \"hash\");\r\n                date = parser.getAttributeValue(\"\", \"date\");\r\n            } else if (elementName.equals(\"desc\")) {\r\n                desc = parser.nextText();\r\n            } else if (elementName.equals(\"range\")) {\r\n                isRanged = true;\r\n            } else if (elementName.equals(\"x\") && namespace.equals(\"jabber:x:data\")) {\r\n                form = (DataForm) dataFormProvider.parseExtension(parser);\r\n            } else if (elementName.equals(\"thumbnail\")) {\r\n                thumbnail = ThumbnailElement.parseExtension(parser);\r\n            }\r\n        } else if (eventType == XmlPullParser.END_TAG) {\r\n            if (elementName.equals(\"si\")) {\r\n                done = true;\r\n            } else if (elementName.equals(\"file\") && name != null) {\r\n                long fileSize = 0;\r\n                if (size != null && size.trim().length() != 0) {\r\n                    try {\r\n                        fileSize = Long.parseLong(size);\r\n                    } catch (NumberFormatException e) {\r\n                        logger.warn(\"Received an invalid file size,\" + \" continuing with fileSize set to 0\", e);\r\n                    }\r\n                }\r\n                FileElement file = new FileElement(name, fileSize);\r\n                file.setHash(hash);\r\n                if (date != null) {\r\n                    boolean found = false;\r\n                    if (date.matches(\".*?T\\\\d+:\\\\d+:\\\\d+(\\\\.\\\\d+)?(\\\\+|-)\\\\d+:\\\\d+\")) {\r\n                        int timeZoneColon = date.lastIndexOf(\":\");\r\n                        date = date.substring(0, timeZoneColon) + date.substring(timeZoneColon + 1, date.length());\r\n                    }\r\n                    for (DateFormat fmt : DATE_FORMATS) {\r\n                        try {\r\n                            file.setDate(fmt.parse(date));\r\n                            found = true;\r\n                            break;\r\n                        } catch (ParseException ex) {\r\n                        }\r\n                    }\r\n                    if (!found) {\r\n                        logger.warn(\"Unknown dateformat on incoming file transfer: \" + date);\r\n                    }\r\n                }\r\n                if (thumbnail != null)\r\n                    file.setThumbnailElement(thumbnail);\r\n                file.setDesc(desc);\r\n                file.setRanged(isRanged);\r\n                initiation.setFile(file);\r\n            }\r\n        }\r\n    }\r\n    initiation.setSesssionID(id);\r\n    initiation.setMimeType(mimeType);\r\n    initiation.setFeatureNegotiationForm(form);\r\n    return initiation;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatMessage.getContactDisplayName",
	"Comment": "returns the display name of the contact sending the message.",
	"Method": "String getContactDisplayName(){\r\n    return contactDisplayName;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.menus.ChatFileMenu.actionPerformed",
	"Comment": "handles the actionevent when one of the menu items is selected.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    JMenuItem menuItem = (JMenuItem) e.getSource();\r\n    String itemText = menuItem.getName();\r\n    if (itemText.equalsIgnoreCase(\"close\")) {\r\n        this.chatWindow.setVisible(false);\r\n        this.chatWindow.dispose();\r\n        return;\r\n    }\r\n    super.actionPerformed(e);\r\n    if (itemText.equalsIgnoreCase(\"myChatRooms\")) {\r\n        ChatRoomTableDialog.showChatRoomTableDialog();\r\n    } else if (itemText.equals(\"history\")) {\r\n        HistoryWindow history;\r\n        HistoryWindowManager historyWindowManager = GuiActivator.getUIService().getHistoryWindowManager();\r\n        ChatPanel chatPanel = this.chatWindow.getCurrentChat();\r\n        ChatSession chatSession = chatPanel.getChatSession();\r\n        if (historyWindowManager.containsHistoryWindowForContact(chatSession.getDescriptor())) {\r\n            history = historyWindowManager.getHistoryWindowForContact(chatSession.getDescriptor());\r\n            if (history.getState() == JFrame.ICONIFIED)\r\n                history.setState(JFrame.NORMAL);\r\n            history.toFront();\r\n        } else {\r\n            history = new HistoryWindow(chatPanel.getChatSession().getDescriptor());\r\n            history.setVisible(true);\r\n            historyWindowManager.addHistoryWindowForContact(chatSession.getDescriptor(), history);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactGroupImpl.removeSubgroup",
	"Comment": "removes the specified group from the list of groups in this list.",
	"Method": "MetaContactGroupImpl removeSubgroup(int index,boolean removeSubgroup,MetaContactGroup group){\r\n    if (subgroups.contains(group)) {\r\n        removeSubgroup(subgroupsOrderedCopy.indexOf(group));\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.chatRoomPropertyChanged",
	"Comment": "notifies the user if any member of the chatroom changes nickname.",
	"Method": "void chatRoomPropertyChanged(ChatRoomMemberPropertyChangeEvent event){\r\n    if (ChatRoomMemberPropertyChangeEvent.MEMBER_NICKNAME.equals(event.getPropertyName())) {\r\n        String message = GuiActivator.getResources().getI18NString(\"service.gui.CHAT_NICKNAME_CHANGE\", new String[] { (String) event.getOldValue(), (String) event.getNewValue() });\r\n        this.conversationPanel.appendMessageToEnd(\"<DIV identifier=\\\"message\\\" style=\\\"color:#707070;\\\">\" + StringEscapeUtils.escapeHtml4(message) + \"<\/DIV>\", ChatHtmlUtils.HTML_CONTENT_TYPE);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.ircaccregwizz.IrcAccountRegistrationWizard.getUserNameExample",
	"Comment": "returns an example string, which should indicate to the user how theuser name should look like.",
	"Method": "String getUserNameExample(){\r\n    return FirstWizardPage.USER_NAME_EXAMPLE;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetTelephonyConferencingJabberImpl.processPacket",
	"Comment": "handles incoming jingle packets and passes them to the correspondingmethod based on their action.",
	"Method": "void processPacket(Packet packet){\r\n    CoinIQ coinIQ = (CoinIQ) packet;\r\n    String errorMessage = null;\r\n    IQ.Type type = coinIQ.getType();\r\n    if (type == IQ.Type.SET) {\r\n        IQ ack = IQ.createResultIQ(coinIQ);\r\n        parentProvider.getConnection().sendPacket(ack);\r\n    } else if (type == IQ.Type.ERROR) {\r\n        XMPPError error = coinIQ.getError();\r\n        if (error != null) {\r\n            String msg = error.getMessage();\r\n            errorMessage = ((msg != null) ? (msg + \" \") : \"\") + \"Error code: \" + error.getCode();\r\n        }\r\n        logger.error(\"Received error in COIN packet. \" + errorMessage);\r\n    }\r\n    String sid = coinIQ.getSID();\r\n    if (sid != null) {\r\n        CallPeerJabberImpl callPeer = getBasicTelephony().getActiveCallsRepository().findCallPeer(sid);\r\n        if (callPeer != null) {\r\n            if (type == IQ.Type.ERROR) {\r\n                callPeer.fireConferenceMemberErrorEvent(errorMessage);\r\n                return;\r\n            }\r\n            if (logger.isDebugEnabled())\r\n                logger.debug(\"Processing COIN from \" + coinIQ.getFrom() + \" (version=\" + coinIQ.getVersion() + \")\");\r\n            handleCoin(callPeer, coinIQ);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.ScLogFormatter.inferCaller",
	"Comment": "try to extract the name of the class and method that called the currentlog statement.",
	"Method": "int inferCaller(LogRecord record){\r\n    StackTraceElement[] stack = (new Throwable()).getStackTrace();\r\n    int lineNumber = -1;\r\n    int ix = 0;\r\n    while (ix < stack.length) {\r\n        StackTraceElement frame = stack[ix];\r\n        String cname = frame.getClassName();\r\n        if (cname.equals(\"net.java.sip.communicator.util.Logger\")) {\r\n            break;\r\n        }\r\n        ix++;\r\n    }\r\n    while (ix < stack.length) {\r\n        StackTraceElement frame = stack[ix];\r\n        lineNumber = stack[ix].getLineNumber();\r\n        String cname = frame.getClassName();\r\n        if (!cname.equals(\"net.java.sip.communicator.util.Logger\")) {\r\n            record.setSourceClassName(cname);\r\n            record.setSourceMethodName(frame.getMethodName());\r\n            break;\r\n        }\r\n        ix++;\r\n    }\r\n    return lineNumber;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockContactGroup.findContactParent",
	"Comment": "returns the group that is parent of the specified mockcontact or nullif no parent was found.",
	"Method": "MockContactGroup findContactParent(MockContact mockContact){\r\n    if (contacts.contains(mockContact))\r\n        return this;\r\n    Iterator<ContactGroup> subGroupsIter = subgroups();\r\n    while (subGroupsIter.hasNext()) {\r\n        MockContactGroup subgroup = (MockContactGroup) subGroupsIter.next();\r\n        MockContactGroup parent = subgroup.findContactParent(mockContact);\r\n        if (parent != null)\r\n            return parent;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.swingnotification.PopupMessageHandlerSwingImpl.getPopupMessageAreaHeight",
	"Comment": "returns the appropriate popup message height, according to the currentlyused font and the size of the message.",
	"Method": "int getPopupMessageAreaHeight(Component c,String message){\r\n    int stringWidth = ComponentUtils.getStringWidth(c, message);\r\n    int numberOfRows = 0;\r\n    if (stringWidth / 230 > 5)\r\n        numberOfRows = 5;\r\n    else\r\n        numberOfRows = stringWidth / 230 + 1;\r\n    FontMetrics fontMetrics = c.getFontMetrics(c.getFont());\r\n    return fontMetrics.getHeight() * Math.max(numberOfRows, 3) + 5;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetServerStoredAccountInfoIcqImpl.getCountryCode",
	"Comment": "returns the index stored on the server corresponding the given locale",
	"Method": "int getCountryCode(Locale cLocale){\r\n    if (cLocale == null)\r\n        return 0;\r\n    for (Map.Entry<Integer, String> entry : countryIndexToLocaleString.entrySet()) {\r\n        Integer key = entry.getKey();\r\n        String countryString = entry.getValue().toUpperCase();\r\n        if (countryString.equals(cLocale.getCountry()))\r\n            return key.intValue();\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.RtpDescriptionPacketExtension.addExtmap",
	"Comment": "adds an optional extmap element that allows negotiation rtpextension headers as per rfc 5282.",
	"Method": "void addExtmap(RTPHdrExtPacketExtension extmap){\r\n    this.extmapList.add(extmap);\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.ConfigurationUtils.setLastCallConferenceProvider",
	"Comment": "sets the call conference provider used for the last conference call.",
	"Method": "void setLastCallConferenceProvider(ProtocolProviderService protocolProvider){\r\n    lastCallConferenceProvider = protocolProvider;\r\n    configService.setProperty(\"net.java.sip.communicator.impl.gui.call.lastCallConferenceProvider\", protocolProvider.getAccountID().getAccountUniqueID());\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.loggingutils.LoggingUtilsActivator.getNotificationService",
	"Comment": "returns the notificationservice obtained from the bundle context.",
	"Method": "NotificationService getNotificationService(){\r\n    if (notificationService == null) {\r\n        notificationService = ServiceUtils.getService(bundleContext, NotificationService.class);\r\n    }\r\n    return notificationService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.iptelaccregwizz.IptelAccountRegistrationWizard.getIcon",
	"Comment": "implements the accountregistrationwizard.geticon method.returns the icon to be used for this wizard.",
	"Method": "byte[] getIcon(){\r\n    return IptelAccRegWizzActivator.getResources().getImageInBytes(PROTOCOL_ICON);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.InfoRetreiver.readMoreUserInfo",
	"Comment": "method for parsing incoming dataread data in moreuserinfo command",
	"Method": "void readMoreUserInfo(MetaMoreInfoCmd cmd){\r\n    List<GenericDetail> infoData = getInfoForRequest(cmd.getId());\r\n    ServerStoredDetails.GenderDetail gender = OperationSetServerStoredAccountInfoIcqImpl.genders[cmd.getGender()];\r\n    if (gender != null)\r\n        infoData.add(gender);\r\n    String tmp = null;\r\n    try {\r\n        if ((tmp = cmd.getHomepage()) != null)\r\n            infoData.add(new ServerStoredDetails.WebPageDetail(new URL(tmp)));\r\n    } catch (MalformedURLException ex) {\r\n    }\r\n    Calendar birthDate = Calendar.getInstance();\r\n    birthDate.setTime(cmd.getBirthDate());\r\n    infoData.add(new ServerStoredDetails.BirthDateDetail(birthDate));\r\n    Locale spokenLanguage1 = OperationSetServerStoredAccountInfoIcqImpl.getSpokenLanguage(cmd.getSpeakingLanguages()[0]);\r\n    if (spokenLanguage1 != null)\r\n        infoData.add(new ServerStoredDetails.SpokenLanguageDetail(spokenLanguage1));\r\n    Locale spokenLanguage2 = OperationSetServerStoredAccountInfoIcqImpl.getSpokenLanguage(cmd.getSpeakingLanguages()[1]);\r\n    if (spokenLanguage2 != null)\r\n        infoData.add(new ServerStoredDetails.SpokenLanguageDetail(spokenLanguage2));\r\n    Locale spokenLanguage3 = OperationSetServerStoredAccountInfoIcqImpl.getSpokenLanguage(cmd.getSpeakingLanguages()[2]);\r\n    if (spokenLanguage3 != null)\r\n        infoData.add(new ServerStoredDetails.SpokenLanguageDetail(spokenLanguage3));\r\n    if ((tmp = cmd.getOriginalCity()) != null)\r\n        infoData.add(new OperationSetServerStoredAccountInfoIcqImpl.OriginCityDetail(tmp));\r\n    if ((tmp = cmd.getOriginalState()) != null)\r\n        infoData.add(new OperationSetServerStoredAccountInfoIcqImpl.OriginProvinceDetail(tmp));\r\n    Locale originCountryLocale = OperationSetServerStoredAccountInfoIcqImpl.getCountry(cmd.getOriginalCountryCode());\r\n    if (originCountryLocale != null)\r\n        infoData.add(new OperationSetServerStoredAccountInfoIcqImpl.OriginCountryDetail(originCountryLocale));\r\n    int userGMTOffset = cmd.getTimeZone();\r\n    TimeZone userTimeZone = null;\r\n    if (userGMTOffset >= 0)\r\n        userTimeZone = TimeZone.getTimeZone(\"GMT+\" + userGMTOffset);\r\n    else\r\n        userTimeZone = TimeZone.getTimeZone(\"GMT\" + userGMTOffset);\r\n    infoData.add(new ServerStoredDetails.TimeZoneDetail(\"GMT Offest\", userTimeZone));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactImpl.reevalContact",
	"Comment": "called by metacontactlistserviceimpl after a contact has changed itsstatus, so that ordering in the parent group is updated. the method alsoelects the most connected contact as default contact.",
	"Method": "int reevalContact(){\r\n    synchronized (getParentGroupModLock()) {\r\n        if (parentGroup != null) {\r\n            parentGroup.lightRemoveMetaContact(this);\r\n        }\r\n        this.contactsOnline = 0;\r\n        int maxContactStatus = 0;\r\n        for (Contact contact : protoContacts) {\r\n            int contactStatus = contact.getPresenceStatus().getStatus();\r\n            if (maxContactStatus < contactStatus) {\r\n                maxContactStatus = contactStatus;\r\n                this.defaultContact = contact;\r\n            }\r\n            if (contact.getPresenceStatus().isOnline())\r\n                contactsOnline++;\r\n        }\r\n        if (parentGroup != null) {\r\n            return parentGroup.lightAddMetaContact(this);\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.ContactPresenceStatusChangeEvent.getOldStatus",
	"Comment": "returns the status of the provider before this event took place.",
	"Method": "PresenceStatus getOldStatus(){\r\n    return (PresenceStatus) super.getOldValue();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractProtocolProviderService.removeRegistrationStateChangeListener",
	"Comment": "removes the specified registration state change listener so that it doesnot receive any further notifications upon changes of theregistrationstate of this provider.",
	"Method": "void removeRegistrationStateChangeListener(RegistrationStateChangeListener listener){\r\n    synchronized (registrationListeners) {\r\n        registrationListeners.remove(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.MetaContactChatTransport.removeInstantMessageListener",
	"Comment": "removes the instant message listener from this chat transport.",
	"Method": "void removeInstantMessageListener(MessageListener l){\r\n    if (!allowsInstantMessage())\r\n        return;\r\n    OperationSetBasicInstantMessaging imOpSet = contact.getProtocolProvider().getOperationSet(OperationSetBasicInstantMessaging.class);\r\n    imOpSet.removeMessageListener(l);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.provdisc.AbstractProvisioningDiscoveryService.addDiscoveryListener",
	"Comment": "add a listener that will be notified when thediscoverprovisioningurl has finished.",
	"Method": "void addDiscoveryListener(DiscoveryListener listener){\r\n    if (!listeners.contains(listener)) {\r\n        listeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.mailnotification.MailboxIQ.addThread",
	"Comment": "adds a thread info element to the list of threads that thismailboxiq is referring to.",
	"Method": "void addThread(MailThreadInfo threadInfo){\r\n    if (threads == null)\r\n        threads = new LinkedList<MailThreadInfo>();\r\n    threads.add(threadInfo);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.replacement.directimage.ReplacementServiceDirectImageImpl.isDirectImage",
	"Comment": "returns true if the content type of the resourcepointed by sourcestring is an image.",
	"Method": "boolean isDirectImage(String sourceString){\r\n    boolean isDirectImage = false;\r\n    try {\r\n        URL url = new URL(sourceString);\r\n        String protocol = url.getProtocol();\r\n        if (protocol.equals(\"http\") || protocol.equals(\"https\")) {\r\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\r\n            isDirectImage = connection.getContentType().contains(\"image\");\r\n            connection.disconnect();\r\n        } else if (protocol.equals(\"ftp\")) {\r\n            if (sourceString.endsWith(\".png\") || sourceString.endsWith(\".jpg\") || sourceString.endsWith(\".gif\")) {\r\n                isDirectImage = true;\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n        logger.debug(\"Failed to retrieve content type information for\" + sourceString, e);\r\n    }\r\n    return isDirectImage;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.phonenumbercontactsource.PhoneNumberContactQuery.contactPresenceStatusChanged",
	"Comment": "listens for contact status changes and updates it and inform for thechange.",
	"Method": "void contactPresenceStatusChanged(ContactPresenceStatusChangeEvent evt){\r\n    for (SourceContact sc : getQueryResults()) {\r\n        if (!(sc instanceof PhoneNumberSourceContact))\r\n            continue;\r\n        Contact contact = ((PhoneNumberSourceContact) sc).getContact();\r\n        if (contact.equals(evt.getSource())) {\r\n            ((PhoneNumberSourceContact) sc).setPresenceStatus(evt.getNewStatus());\r\n            fireContactChanged(sc);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetBasicInstantMessagingJabberImpl.putJidForAddress",
	"Comment": "maps the specified address to jid. the point of thismethod is to allow us to send all messages destined to the contact withthe specified address to the jid that they lastcontacted us from.",
	"Method": "void putJidForAddress(String jid,String threadID){\r\n    synchronized (jids) {\r\n        purgeOldJids();\r\n        StoredThreadID ta = jids.get(jid);\r\n        if (ta == null) {\r\n            ta = new StoredThreadID();\r\n            jids.put(jid, ta);\r\n        }\r\n        recentJIDForAddress.put(StringUtils.parseBareAddress(jid), jid);\r\n        ta.lastUpdatedTime = System.currentTimeMillis();\r\n        ta.threadID = threadID;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.configuration.ConfigurationActivator.fixPermissions",
	"Comment": "makes home folder and the configuration file readable and writable onlyto the owner.",
	"Method": "void fixPermissions(ConfigurationService cs){\r\n    if (!OSUtils.IS_LINUX && !OSUtils.IS_MAC)\r\n        return;\r\n    try {\r\n        File homeFolder = new File(cs.getScHomeDirLocation(), cs.getScHomeDirName());\r\n        Set<PosixFilePermission> perms = new HashSet<PosixFilePermission>() {\r\n            {\r\n                add(PosixFilePermission.OWNER_READ);\r\n                add(PosixFilePermission.OWNER_WRITE);\r\n                add(PosixFilePermission.OWNER_EXECUTE);\r\n            }\r\n        };\r\n        Files.setPosixFilePermissions(Paths.get(homeFolder.getAbsolutePath()), perms);\r\n        String fileName = cs.getConfigurationFilename();\r\n        if (fileName != null) {\r\n            File cf = new File(homeFolder, fileName);\r\n            if (cf.exists()) {\r\n                perms = new HashSet<PosixFilePermission>() {\r\n                    {\r\n                        add(PosixFilePermission.OWNER_READ);\r\n                        add(PosixFilePermission.OWNER_WRITE);\r\n                    }\r\n                };\r\n                Files.setPosixFilePermissions(Paths.get(cf.getAbsolutePath()), perms);\r\n            }\r\n        }\r\n    } catch (Throwable t) {\r\n        logger.error(\"Error creating c lib instance for fixing file permissions\", t);\r\n        if (t instanceof InterruptedException)\r\n            Thread.currentThread().interrupt();\r\n        else if (t instanceof ThreadDeath)\r\n            throw (ThreadDeath) t;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.TestOperationSetBasicTelephonyJabberImpl.aTestCreateAnswerHangupCall",
	"Comment": "creates a call from provider1 to provider2, makes provider2 answer itand then reject it.",
	"Method": "void aTestCreateAnswerHangupCall(){\r\n    OperationSetBasicTelephony<?> basicTelephonyP1 = fixture.provider1.getOperationSet(OperationSetBasicTelephony.class);\r\n    OperationSetBasicTelephony<?> basicTelephonyP2 = fixture.provider2.getOperationSet(OperationSetBasicTelephony.class);\r\n    CallEventCollector call1Listener = new CallEventCollector(basicTelephonyP1);\r\n    CallEventCollector call2Listener = new CallEventCollector(basicTelephonyP2);\r\n    String provider2Address = fixture.provider2.getAccountID().getAccountAddress();\r\n    Call callAtP1 = basicTelephonyP1.createCall(provider2Address);\r\n    call1Listener.waitForEvent(10000);\r\n    call2Listener.waitForEvent(10000);\r\n    assertEquals(\"The provider that created the call did not dispatch \" + \"an event that it has done so.\", 1, call1Listener.collectedEvents.size());\r\n    CallEvent callCreatedEvent = (CallEvent) call1Listener.collectedEvents.get(0);\r\n    assertEquals(\"CallEvent.getEventID()\", CallEvent.CALL_INITIATED, callCreatedEvent.getEventID());\r\n    assertSame(\"CallEvent.getSource()\", callAtP1, callCreatedEvent.getSource());\r\n    assertTrue(\"The callee provider did not receive a call or did \" + \"not issue an event.\", call2Listener.collectedEvents.size() > 0);\r\n    CallEvent callReceivedEvent = (CallEvent) call2Listener.collectedEvents.get(0);\r\n    Call callAtP2 = callReceivedEvent.getSourceCall();\r\n    assertEquals(\"CallEvent.getEventID()\", CallEvent.CALL_RECEIVED, callReceivedEvent.getEventID());\r\n    assertNotNull(\"CallEvent.getSource()\", callAtP2);\r\n    assertEquals(\"callAtP1.getCallPeerCount()\", 1, callAtP1.getCallPeerCount());\r\n    assertEquals(\"callAtP2.getCallPeerCount()\", 1, callAtP2.getCallPeerCount());\r\n    CallPeer peerAtP1 = callAtP1.getCallPeers().next();\r\n    CallPeer peerAtP2 = callAtP2.getCallPeers().next();\r\n    CallPeerStateEventCollector stateCollectorForPp1 = new CallPeerStateEventCollector(peerAtP1, CallPeerState.ALERTING_REMOTE_SIDE);\r\n    CallPeerStateEventCollector stateCollectorForPp2 = new CallPeerStateEventCollector(peerAtP2, CallPeerState.INCOMING_CALL);\r\n    stateCollectorForPp1.waitForEvent(10000, true);\r\n    stateCollectorForPp2.waitForEvent(10000, true);\r\n    assertSame(\"peerAtP1.getCall\", peerAtP1.getCall(), callAtP1);\r\n    assertSame(\"peerAtP2.getCall\", peerAtP2.getCall(), callAtP2);\r\n    assertEquals(\"The peer at provider one was not in the \" + \"right state.\", CallPeerState.ALERTING_REMOTE_SIDE, peerAtP1.getState());\r\n    assertEquals(\"The peer at provider two was not in the \" + \"right state.\", CallPeerState.INCOMING_CALL, peerAtP2.getState());\r\n    if (Boolean.getBoolean(\"accounts.jabber.PRESERVE_PEER_INFO\")) {\r\n        String expectedPeer1Address = fixture.provider2.getAccountID().getAccountAddress();\r\n        String expectedPeer1DisplayName = System.getProperty(JabberProtocolProviderServiceLick.ACCOUNT_2_PREFIX + ProtocolProviderFactory.DISPLAY_NAME);\r\n        assertTrue(\"Provider 2 did not advertise their \" + \"accountID.getAccoutAddress() address.\", expectedPeer1Address.indexOf(peerAtP1.getAddress()) != -1 || peerAtP1.getAddress().indexOf(expectedPeer1Address) != -1);\r\n        assertEquals(\"Provider 2 did not properly advertise their \" + \"display name.\", expectedPeer1DisplayName, peerAtP1.getDisplayName());\r\n        String expectedPeer2Address = fixture.provider1.getAccountID().getAccountAddress();\r\n        String expectedPeer2DisplayName = System.getProperty(JabberProtocolProviderServiceLick.ACCOUNT_1_PREFIX + ProtocolProviderFactory.DISPLAY_NAME);\r\n        assertTrue(\"Provider 1 did not advertise their \" + \"accountID.getAccoutAddress() address.\", expectedPeer2Address.indexOf(peerAtP2.getAddress()) != -1 || peerAtP2.getAddress().indexOf(expectedPeer2Address) != -1);\r\n        assertEquals(\"Provider 1 did not properly advertise their \" + \"display name.\", expectedPeer2DisplayName, peerAtP2.getDisplayName());\r\n    }\r\n    stateCollectorForPp1 = new CallPeerStateEventCollector(peerAtP1, CallPeerState.CONNECTED);\r\n    stateCollectorForPp2 = new CallPeerStateEventCollector(peerAtP2, CallPeerState.CONNECTED);\r\n    basicTelephonyP2.answerCallPeer(peerAtP2);\r\n    stateCollectorForPp1.waitForEvent(10000);\r\n    stateCollectorForPp2.waitForEvent(10000);\r\n    assertEquals(\"The peer at provider one was not in the \" + \"right state.\", CallPeerState.CONNECTED, peerAtP1.getState());\r\n    assertEquals(\"The peer at provider two was not in the \" + \"right state.\", CallPeerState.CONNECTED, peerAtP2.getState());\r\n    assertEquals(\"No event was dispatched when a call peer changed \" + \"its state.\", 1, stateCollectorForPp1.collectedEvents.size());\r\n    assertEquals(\"No event was dispatched when a call peer changed \" + \"its state.\", 1, stateCollectorForPp2.collectedEvents.size());\r\n    stateCollectorForPp1 = new CallPeerStateEventCollector(peerAtP1, CallPeerState.DISCONNECTED);\r\n    stateCollectorForPp2 = new CallPeerStateEventCollector(peerAtP2, CallPeerState.DISCONNECTED);\r\n    basicTelephonyP2.hangupCallPeer(peerAtP2);\r\n    stateCollectorForPp1.waitForEvent(10000);\r\n    stateCollectorForPp2.waitForEvent(10000);\r\n    assertEquals(\"The peer at provider one was not in the \" + \"right state.\", CallPeerState.DISCONNECTED, peerAtP1.getState());\r\n    assertEquals(\"The peer at provider two was not in the \" + \"right state.\", CallPeerState.DISCONNECTED, peerAtP2.getState());\r\n    assertEquals(\"a provider did not distribute an event when a call \" + \"peer changed states.\", 1, stateCollectorForPp1.collectedEvents.size());\r\n    assertEquals(\"a provider did not distribute an event when a call \" + \"peer changed states.\", 1, stateCollectorForPp2.collectedEvents.size());\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.gibberishaccregwizz.GibberishAccountRegistrationWizard.getRegistration",
	"Comment": "returns the registration object, which will store all the data throughthe wizard.",
	"Method": "GibberishAccountRegistration getRegistration(){\r\n    return registration;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.JabberAccountRegistrationWizard.getRegistration",
	"Comment": "returns the registration object, which will store all the data throughthe wizard.",
	"Method": "JabberAccountRegistration getRegistration(){\r\n    if (registration == null)\r\n        registration = new JabberAccountRegistration();\r\n    return registration;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.sip.TestAccountUninstallation.testUninstallAccount",
	"Comment": "uinstalls our test account and makes sure it really has been removed.",
	"Method": "void testUninstallAccount(){\r\n    assertFalse(\"No installed accounts found\", fixture.providerFactory.getRegisteredAccounts().isEmpty());\r\n    assertNotNull(\"Found no provider corresponding to URI \" + fixture.userID1, fixture.providerFactory.getProviderForAccount(fixture.provider1.getAccountID()));\r\n    assertTrue(\"Failed to remove a provider corresponding to URI \" + fixture.userID1, fixture.providerFactory.uninstallAccount(fixture.provider1.getAccountID()));\r\n    assertTrue(\"Failed to remove a provider corresponding to URI \" + fixture.userID1, fixture.providerFactory.uninstallAccount(fixture.provider2.getAccountID()));\r\n    ServiceReference[] sipProviderRefs = null;\r\n    try {\r\n        sipProviderRefs = SipSlickFixture.bc.getServiceReferences(ProtocolProviderService.class.getName(), \"(\" + ProtocolProviderFactory.PROTOCOL + \"=\" + ProtocolNames.SIP + \")\");\r\n    } catch (InvalidSyntaxException ex) {\r\n        fail(\"We apparently got our filter wrong \" + ex.getMessage());\r\n    }\r\n    assertTrue(\"A Protocol Provider Service was still regged as an osgi \" + \"service for SIP URI:\" + fixture.userID1 + \"After it was explicitly uninstalled\", sipProviderRefs == null || sipProviderRefs.length == 0);\r\n    assertTrue(\"The SIP provider factory kept a reference to the provider we just \" + \"uninstalled (uri=\" + fixture.userID1 + \")\", fixture.providerFactory.getRegisteredAccounts().isEmpty() && fixture.providerFactory.getProviderForAccount(fixture.provider1.getAccountID()) == null);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.account.AccountRegSummaryPage.setModification",
	"Comment": "sets the modification property to indicate if this wizard is opened fora modification.",
	"Method": "void setModification(ProtocolProviderService protocolProvider){\r\n    this.protocolProviderService = protocolProvider;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.OperationSetBasicTelephonyGibberishImpl.answerCallPeer",
	"Comment": "indicates a user request to answer an incoming call from the specifiedcallpeer.",
	"Method": "void answerCallPeer(CallPeer peer){\r\n    CallPeerGibberishImpl callPeer = (CallPeerGibberishImpl) peer;\r\n    if (peer.getState().equals(CallPeerState.CONNECTED)) {\r\n        if (logger.isInfoEnabled())\r\n            logger.info(\"Ignoring user request to answer a CallPeer \" + \"that is already connected. CP:\" + peer);\r\n        return;\r\n    }\r\n    callPeer.setState(CallPeerState.CONNECTED, null);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.TestOperationSetMultiUserChat2.nameIsOnMemberList",
	"Comment": "utiliy method to know if a given nickname is on achatroommember list",
	"Method": "boolean nameIsOnMemberList(String name,List<ChatRoomMember> memberList){\r\n    for (ChatRoomMember member : memberList) {\r\n        if (member.getName().equals(name)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ContactIcqImpl.getParentContactGroup",
	"Comment": "returns a reference to the contact group that this contact is currentlya child of or null if the underlying protocol does not suppord persistentpresence.",
	"Method": "ContactGroup getParentContactGroup(){\r\n    return ssclCallback.findContactGroup(this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ContactGroupIcqImpl.hashCode",
	"Comment": "returns a hash code value for the object, which is actually the hashcodevalue of the groupname.",
	"Method": "int hashCode(){\r\n    return getGroupName().hashCode();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.VolatileContactJabberImpl.isPersistent",
	"Comment": "determines whether or not this contact group is being stored by theserver. non persistent contact groups exist for the sole purpose ofcontaining non persistent contacts.",
	"Method": "boolean isPersistent(){\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.connectioninfo.ConnectionInfoMenuItemComponent.getPositionIndex",
	"Comment": "returns the position of this plugincomponent within itscontainer",
	"Method": "int getPositionIndex(){\r\n    return 0;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.AdHocConferenceChatSession.getCurrentChatTransport",
	"Comment": "returns the currently used transport for all operation within this chatsession.",
	"Method": "ChatTransport getCurrentChatTransport(){\r\n    return currentChatTransport;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.exampleplugin.ExamplePluginMenuItem.actionPerformed",
	"Comment": "listens for events triggered by user clicks on this menu item. opensthe plugindialog.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    PluginDialog pluginDialog = new PluginDialog(metaContact);\r\n    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\r\n    pluginDialog.setLocation(screenSize.width / 2 - pluginDialog.getWidth() / 2, screenSize.height / 2 - pluginDialog.getHeight() / 2);\r\n    pluginDialog.setVisible(true);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.geolocation.GeolocationPacketExtension.setRoom",
	"Comment": "sets the name or number indicating a particular room in a building.",
	"Method": "void setRoom(String room){\r\n    this.room = room;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetDesktopStreamingSipImpl.addDesktopShareHeader",
	"Comment": "a place where we can handle any headers we need for requestsand responses.",
	"Method": "void addDesktopShareHeader(javax.sip.message.Message message){\r\n    Header customDesktopShareHeader = parentProvider.getHeaderFactory().createHeader(CallSipImpl.DS_SHARING_HEADER, \"true\");\r\n    message.setHeader(customDesktopShareHeader);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.UIServiceImpl.notificationReceived",
	"Comment": "counts the number of unread notifications and forwards the sum to thesystray service.",
	"Method": "void notificationReceived(UINotification notification){\r\n    forwardNotificationCount();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.CallPeerJabberImpl.getDirectionForJingle",
	"Comment": "returns the mediadirection that should be set for the contentof type mediatype in the jingle session for thiscallpeer.if we are the focus of a conference and are doing rtp translation,takes into account the other callpeers in the call.",
	"Method": "MediaDirection getDirectionForJingle(MediaType mediaType){\r\n    MediaDirection direction = MediaDirection.INACTIVE;\r\n    CallPeerMediaHandlerJabberImpl mediaHandler = getMediaHandler();\r\n    if ((MediaType.AUDIO == mediaType && mediaHandler.isLocalAudioTransmissionEnabled()) || (MediaType.VIDEO == mediaType && isLocalVideoStreaming()))\r\n        direction = direction.or(MediaDirection.SENDONLY);\r\n    SendersEnum senders = getSenders(mediaType);\r\n    if (senders == null || senders == SendersEnum.both || (isInitiator() && senders == SendersEnum.initiator) || (!isInitiator() && senders == SendersEnum.responder))\r\n        direction = direction.or(MediaDirection.RECVONLY);\r\n    CallJabberImpl call = getCall();\r\n    if (call != null && call.isConferenceFocus()) {\r\n        for (CallPeerJabberImpl peer : call.getCallPeerList()) {\r\n            if (peer != this) {\r\n                senders = peer.getSenders(mediaType);\r\n                if (senders == null || senders == SendersEnum.both || (peer.isInitiator() && senders == SendersEnum.initiator) || (!peer.isInitiator() && senders == SendersEnum.responder)) {\r\n                    direction = direction.or(MediaDirection.SENDONLY);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return direction;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactImpl.getParentMetaContactGroup",
	"Comment": "returns the metacontactgroup currently containing this meta contact",
	"Method": "MetaContactGroup getParentMetaContactGroup(){\r\n    return getParentGroup();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.AddContactDialog.updateGroupItems",
	"Comment": "update the group items in the combo supplied, by checkingand the edit permissions",
	"Method": "void updateGroupItems(JComboBox groupCombo,ProtocolProviderService provider){\r\n    OperationSetPersistentPresencePermissions opsetPermissions = null;\r\n    OperationSetPersistentPresence opsetPresence;\r\n    boolean isRootReadOnly = false;\r\n    Object selectedItem = groupCombo.getSelectedItem();\r\n    if (provider != null) {\r\n        groupCombo.removeAllItems();\r\n        opsetPermissions = provider.getOperationSet(OperationSetPersistentPresencePermissions.class);\r\n        opsetPresence = provider.getOperationSet(OperationSetPersistentPresence.class);\r\n        if (opsetPermissions != null && opsetPresence != null)\r\n            isRootReadOnly = opsetPermissions.isReadOnly(opsetPresence.getServerStoredContactListRoot());\r\n    }\r\n    if (!isRootReadOnly) {\r\n        groupCombo.addItem(GuiActivator.getContactListService().getRoot());\r\n    }\r\n    Iterator<MetaContactGroup> groupList = GuiActivator.getContactListService().getRoot().getSubgroups();\r\n    while (groupList.hasNext()) {\r\n        MetaContactGroup group = groupList.next();\r\n        if (!group.isPersistent())\r\n            continue;\r\n        if (provider != null && opsetPermissions != null) {\r\n            Iterator<ContactGroup> protoGroupsIter = group.getContactGroupsForProvider(provider);\r\n            boolean foundWritableGroup = false;\r\n            while (protoGroupsIter.hasNext()) {\r\n                ContactGroup gr = protoGroupsIter.next();\r\n                if (!opsetPermissions.isReadOnly(gr)) {\r\n                    foundWritableGroup = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!foundWritableGroup)\r\n                continue;\r\n        }\r\n        groupCombo.addItem(group);\r\n    }\r\n    final String newGroupString = GuiActivator.getResources().getI18NString(\"service.gui.CREATE_GROUP\");\r\n    if (!ConfigurationUtils.isCreateGroupDisabled() && !isRootReadOnly) {\r\n        groupCombo.addItem(newGroupString);\r\n    }\r\n    if (selectedItem != null)\r\n        groupCombo.setSelectedItem(selectedItem);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.GuiActivator.getConfigurationService",
	"Comment": "returns the configurationservice obtained from the bundlecontext.",
	"Method": "ConfigurationService getConfigurationService(){\r\n    if (configService == null) {\r\n        configService = ServiceUtils.getService(bundleContext, ConfigurationService.class);\r\n    }\r\n    return configService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.getLastHistoryMsgTimestamp",
	"Comment": "returns the date of the last message in history for this chat.",
	"Method": "Date getLastHistoryMsgTimestamp(){\r\n    return lastHistoryMsgTimestamp;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.loggingutils.LoggingUtilsActivator.getConfigurationService",
	"Comment": "returns a reference to a configurationservice implementation currentlyregistered in the bundle context or null if no such implementation wasfound.",
	"Method": "ConfigurationService getConfigurationService(){\r\n    if (configurationService == null) {\r\n        ServiceReference confReference = bundleContext.getServiceReference(ConfigurationService.class.getName());\r\n        configurationService = (ConfigurationService) bundleContext.getService(confReference);\r\n    }\r\n    return configurationService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.ReasonPacketExtension.getReason",
	"Comment": "returns the reason string that this packet extension is transporting.",
	"Method": "Reason getReason(){\r\n    return reason;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.ChatRoomMemberPropertyChangeEvent.getMemberChatRoom",
	"Comment": "returns the chat room, to which the corresponding member belongs.",
	"Method": "ChatRoom getMemberChatRoom(){\r\n    return memberChatRoom;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.resources.ResourceManagementServiceImpl.serviceChanged",
	"Comment": "gets a reference to the uiservice when this one is registered.",
	"Method": "void serviceChanged(ServiceEvent event){\r\n    super.serviceChanged(event);\r\n    Object sService = ResourceManagementActivator.bundleContext.getService(event.getServiceReference());\r\n    if (sService instanceof UIService && uiService == null && event.getType() == ServiceEvent.REGISTERED) {\r\n        uiService = (UIService) sService;\r\n        uiService.repaintUI();\r\n    } else if (sService instanceof UIService && event.getType() == ServiceEvent.UNREGISTERING) {\r\n        if (uiService != null && uiService.equals(sService)) {\r\n            uiService = null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractOperationSetDesktopSharingClient.removesNullAndRevokedControlPeer",
	"Comment": "removes null and the peer corresponding to the revokedpeerid from thegranted control peer list.",
	"Method": "int removesNullAndRevokedControlPeer(String revokedPeerID){\r\n    int index = -1;\r\n    synchronized (this.grantedRemoteControlPeers) {\r\n        CallPeer peer;\r\n        for (int i = 0; i < this.grantedRemoteControlPeers.size(); ++i) {\r\n            peer = this.grantedRemoteControlPeers.get(i);\r\n            if (peer == null || peer.getPeerID().equals(revokedPeerID)) {\r\n                this.grantedRemoteControlPeers.remove(i);\r\n                index = i;\r\n                --i;\r\n            }\r\n        }\r\n    }\r\n    return index;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.plaf.SIPCommTextFieldUI.mouseEntered",
	"Comment": "updates the delete icon when the mouse is enters the component area.",
	"Method": "void mouseEntered(MouseEvent e){\r\n    updateDeleteIcon(e);\r\n    updateCursor(e);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.contactlist.event.MetaContactGroupEvent.toString",
	"Comment": "returns a string representation of this metacontactgroupevent",
	"Method": "String toString(){\r\n    StringBuffer buff = new StringBuffer(\"MetaContactGroupEvent-[ GroupName=\");\r\n    buff.append(getSourceMetaContactGroup().getGroupName());\r\n    buff.append(\", eventID=\").append(getEventID());\r\n    return buff.toString();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ServerStoredContactListJabberImpl.fireContactMoved",
	"Comment": "make the parent persistent presence operation set dispatch a subscriptionmoved event.",
	"Method": "void fireContactMoved(ContactGroup oldParentGroup,ContactGroup newParentGroup,ContactJabberImpl contact){\r\n    if (parentOperationSet == null) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"No presence op. set available. Bailing out.\");\r\n        return;\r\n    }\r\n    parentOperationSet.fireSubscriptionMovedEvent(contact, oldParentGroup, newParentGroup);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.TreeContactList.nodeChanged",
	"Comment": "indicates that a node has been changed. transfers the event to thedefault tree model.",
	"Method": "void nodeChanged(TreeNode node){\r\n    treeModel.nodeChanged(node);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.utils.OneChoiceInviteDialog.getSelectedContact",
	"Comment": "returns an enumeration of the list of selected metacontacts.",
	"Method": "UIContact getSelectedContact(){\r\n    return contactList.getSelectedContact();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetWhiteboardingJabberImpl.removeInvitationRejectionListener",
	"Comment": "removes listener from the list of invitation listenersregistered to receive invitation rejection events.",
	"Method": "void removeInvitationRejectionListener(WhiteboardInvitationRejectionListener listener){\r\n    synchronized (invitationRejectionListeners) {\r\n        invitationRejectionListeners.remove(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockChatRoomMember.getProtocolProvider",
	"Comment": "returns the protocol provider instance that this member has originatedin.",
	"Method": "ProtocolProviderService getProtocolProvider(){\r\n    return chatRoom.getParentProvider();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.ContactGroupGibberishImpl.findContactParent",
	"Comment": "returns the group that is parent of the specified gibberishcontact ornull if no parent was found.",
	"Method": "ContactGroupGibberishImpl findContactParent(ContactGibberishImpl gibberishContact){\r\n    if (contacts.contains(gibberishContact))\r\n        return this;\r\n    Iterator<ContactGroup> subGroupsIter = subgroups();\r\n    while (subGroupsIter.hasNext()) {\r\n        ContactGroupGibberishImpl subgroup = (ContactGroupGibberishImpl) subGroupsIter.next();\r\n        ContactGroupGibberishImpl parent = subgroup.findContactParent(gibberishContact);\r\n        if (parent != null)\r\n            return parent;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.hid.HIDActivator.start",
	"Comment": "starts the execution of the hid bundle in the specified context.",
	"Method": "void start(BundleContext bundleContext){\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Started.\");\r\n    serviceRegistration = bundleContext.registerService(HIDService.class.getName(), new HIDServiceImpl(), null);\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"HID Service ... [REGISTERED]\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetBasicTelephonyJabberImpl.discoverFullJid",
	"Comment": "discovers the resource for calleeaddress with the highestpriority which supports either jingle or gtalk. returns the full jid.",
	"Method": "String discoverFullJid(String calleeAddress){\r\n    String fullCalleeURI = null;\r\n    DiscoverInfo discoverInfo = null;\r\n    int bestPriority = -1;\r\n    PresenceStatus jabberStatus = null;\r\n    String calleeURI = null;\r\n    Iterator<Presence> it = getProtocolProvider().getConnection().getRoster().getPresences(calleeAddress);\r\n    while (it.hasNext()) {\r\n        Presence presence = it.next();\r\n        int priority = (presence.getPriority() == Integer.MIN_VALUE) ? 0 : presence.getPriority();\r\n        calleeURI = presence.getFrom();\r\n        try {\r\n            discoverInfo = protocolProvider.getDiscoveryManager().discoverInfo(calleeURI);\r\n        } catch (XMPPException ex) {\r\n            logger.warn(\"could not retrieve info for \" + fullCalleeURI, ex);\r\n        }\r\n        if (discoverInfo != null && discoverInfo.containsFeature(ProtocolProviderServiceJabberImpl.URN_XMPP_JINGLE)) {\r\n            if (priority > bestPriority) {\r\n                bestPriority = priority;\r\n                fullCalleeURI = calleeURI;\r\n                jabberStatus = OperationSetPersistentPresenceJabberImpl.jabberStatusToPresenceStatus(presence, protocolProvider);\r\n            } else if (priority == bestPriority && jabberStatus != null) {\r\n                PresenceStatus tempStatus = OperationSetPersistentPresenceJabberImpl.jabberStatusToPresenceStatus(presence, protocolProvider);\r\n                if (tempStatus.compareTo(jabberStatus) > 0) {\r\n                    fullCalleeURI = calleeURI;\r\n                    jabberStatus = tempStatus;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (logger.isInfoEnabled())\r\n        logger.info(\"Full JID for outgoing call: \" + fullCalleeURI + \", priority \" + bestPriority);\r\n    return fullCalleeURI;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.icqaccregwizz.IcqAccountRegistrationWizard.getPageImage",
	"Comment": "implements the accountregistrationwizard.getpageimagemethod. returns the image used to decorate the wizard page",
	"Method": "byte[] getPageImage(){\r\n    return Resources.getImage(Resources.PAGE_IMAGE);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.AdHocChatRoomProviderWrapper.getProtocolProvider",
	"Comment": "returns the protocol provider service corresponding to this serverwrapper.",
	"Method": "ProtocolProviderService getProtocolProvider(){\r\n    return protocolProvider;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.gui.PluginComponentFactory.isNativeComponent",
	"Comment": "returns true to indicate that this component is a nativecomponent and false otherwise. this method is meant to beused by containers if a special treatment is needed for native components.",
	"Method": "boolean isNativeComponent(){\r\n    return nativeComponent;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler.setLocalVideoTransmissionEnabled",
	"Comment": "specifies whether this media handler should be allowed to transmitlocal video.",
	"Method": "void setLocalVideoTransmissionEnabled(boolean enabled){\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Setting local video transmission enabled: \" + enabled);\r\n    MediaDirection oldValue = videoDirectionUserPreference;\r\n    videoDirectionUserPreference = enabled ? MediaDirection.SENDRECV : MediaDirection.RECVONLY;\r\n    MediaDirection newValue = videoDirectionUserPreference;\r\n    if (!enabled) {\r\n        firePropertyChange(OperationSetVideoTelephony.LOCAL_VIDEO_STREAMING, oldValue, newValue);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageHistoryServiceImpl.loadMessageHistoryService",
	"Comment": "loads the history and messagehistoryservice. registers the service in thebundle context.",
	"Method": "void loadMessageHistoryService(){\r\n    configService.addPropertyChangeListener(MessageHistoryService.PNAME_IS_RECENT_MESSAGES_DISABLED, msgHistoryPropListener);\r\n    boolean isRecentMessagesDisabled = configService.getBoolean(MessageHistoryService.PNAME_IS_RECENT_MESSAGES_DISABLED, false);\r\n    if (!isRecentMessagesDisabled)\r\n        loadRecentMessages();\r\n    bundleContext.addServiceListener(this);\r\n    for (ProtocolProviderService pps : getCurrentlyAvailableProviders()) {\r\n        this.handleProviderAdded(pps);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.WhiteboardSessionJabberImpl.removeWhiteboardParticipant",
	"Comment": "removes whiteboardparticipant from the list of participants inthis whiteboard. the method has no effect if there was nosuch participant in the whiteboard.",
	"Method": "void removeWhiteboardParticipant(WhiteboardParticipant wbParticipant){\r\n    if (!wbParticipants.containsKey(wbParticipant.getContactAddress()))\r\n        return;\r\n    this.wbParticipants.remove(wbParticipant.getContactAddress());\r\n    if (wbParticipant instanceof WhiteboardParticipantJabberImpl)\r\n        ((WhiteboardParticipantJabberImpl) wbParticipant).setWhiteboardSession(null);\r\n    wbParticipant.removeWhiteboardParticipantListener(this);\r\n    fireWhiteboardParticipantEvent(wbParticipant, WhiteboardParticipantEvent.WHITEBOARD_PARTICIPANT_REMOVED);\r\n    if (wbParticipants.isEmpty())\r\n        setWhiteboardSessionState(WhiteboardSessionState.WHITEBOARD_ENDED);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.account.AccountRegWizardContainerImpl.getProtocolWizard",
	"Comment": "returns the wizard corresponding to the given protocol provider.",
	"Method": "AccountRegistrationWizard getProtocolWizard(ProtocolProviderService protocolProvider){\r\n    AccountRegistrationWizard res = registeredWizards.get(protocolProvider.getProtocolDisplayName());\r\n    if (res == null) {\r\n        Iterator<AccountRegistrationWizard> iter = registeredWizards.values().iterator();\r\n        while (iter.hasNext()) {\r\n            AccountRegistrationWizard wizard = iter.next();\r\n            if (wizard.getProtocolName().equals(protocolProvider.getProtocolName())) {\r\n                res = wizard;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return res;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetServerStoredAccountInfoJabberImpl.getAllAvailableDetails",
	"Comment": "returns all details currently available and set for our account.",
	"Method": "Iterator<GenericDetail> getAllAvailableDetails(){\r\n    assertConnected();\r\n    return infoRetreiver.getContactDetails(uin).iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ScServiceDiscoveryManager.getFeatures",
	"Comment": "returns a reference to our local copy of the feature list supported bythis implementation.",
	"Method": "List<String> getFeatures(){\r\n    return unmodifiableFeatures;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetFileTransferJabberImpl.removeFileTransferListener",
	"Comment": "removes the given filetransferlistener that listens forfile transfer requests and created file transfers.",
	"Method": "void removeFileTransferListener(FileTransferListener listener){\r\n    synchronized (fileTransferListeners) {\r\n        this.fileTransferListeners.remove(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetResAwareTelephonyJabberImpl.createCall",
	"Comment": "creates a new call and invites a specific callpeer toit given by her string uri.",
	"Method": "Call createCall(Contact callee,ContactResource calleeResource,Call createCall,String callee,String calleeResource,Call createCall,Contact callee,ContactResource calleeResource,CallConference conference,Call createCall,String uri,String calleeResource,CallConference conference){\r\n    CallJabberImpl call = new CallJabberImpl(jabberTelephony);\r\n    if (conference != null)\r\n        call.setConference(conference);\r\n    String fullCalleeUri = StringUtils.isNullOrEmpty(calleeResource) ? uri : uri + \"/\" + calleeResource;\r\n    CallPeer callPeer = jabberTelephony.createOutgoingCall(call, uri, fullCalleeUri, null);\r\n    if (callPeer == null) {\r\n        throw new OperationFailedException(\"Failed to create outgoing call\" + \" because no peer was created\", OperationFailedException.INTERNAL_ERROR);\r\n    }\r\n    Call callOfCallPeer = callPeer.getCall();\r\n    if ((callOfCallPeer != call) && (conference != null))\r\n        callOfCallPeer.setConference(conference);\r\n    return callOfCallPeer;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.ldap.configform.Resources.getString",
	"Comment": "returns an internationalized string corresponding to the given key.",
	"Method": "String getString(String key,String getString,String key,String[] params){\r\n    return LdapActivator.getResourceManagementService().getI18NString(key, params);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.conference.ConferenceFocusPanel.printDTMFTone",
	"Comment": "prints the given dtmg character through this callpeerrenderer.",
	"Method": "void printDTMFTone(char dtmfChar){\r\n    focusPeerPanel.printDTMFTone(dtmfChar);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SoundLevelIndicator.updateSoundLevel",
	"Comment": "update the sound level indicator component to fit the given values.",
	"Method": "void updateSoundLevel(int soundLevel){\r\n    levelUpdate.setSoundLevel(soundLevel);\r\n    Runnable levelUpdateScheduler;\r\n    synchronized (this) {\r\n        if (this.levelUpdateScheduler == null) {\r\n            this.levelUpdateScheduler = LowPriorityEventQueue.createRepetitiveInvokeLater(levelUpdate);\r\n        }\r\n        levelUpdateScheduler = this.levelUpdateScheduler;\r\n    }\r\n    levelUpdateScheduler.run();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomIrcImpl.removeMemberPresenceListener",
	"Comment": "removes a listener that was being notified of changes in the status ofother chat room participants such as users being kicked, banned, orgranted admin permissions.",
	"Method": "void removeMemberPresenceListener(ChatRoomMemberPresenceListener listener){\r\n    synchronized (memberListeners) {\r\n        memberListeners.remove(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.CandidatePacketExtension.setNetwork",
	"Comment": "the network index indicating the interface that the candidate belongs to.the network id is used for diagnostic purposes only in cases where thecalling hardware has more than one network interface card.",
	"Method": "void setNetwork(int network){\r\n    super.setAttribute(NETWORK_ATTR_NAME, network);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.toolBars.HistorySelectorBox.updateMenus",
	"Comment": "changes currently used icon on or off, depending on the current settings.updates selected menu items, depends on current configuration.updates the text depending on the current chat session, is it chat roomor a metacontact.",
	"Method": "void updateMenus(){\r\n    toggleAllHistory.setSelected(false);\r\n    toggleHistoryPerContact.setSelected(false);\r\n    MessageHistoryService mhs = GuiActivator.getMessageHistoryService();\r\n    if (!mhs.isHistoryLoggingEnabled())\r\n        toggleAllHistory.setSelected(true);\r\n    if (chatContainer.getCurrentChat() != null) {\r\n        ResourceManagementService R = GuiActivator.getResources();\r\n        Object desc = chatContainer.getCurrentChat().getChatSession().getDescriptor();\r\n        if (desc instanceof MetaContact) {\r\n            MetaContact contact = (MetaContact) desc;\r\n            if (!mhs.isHistoryLoggingEnabled(contact.getMetaUID())) {\r\n                toggleHistoryPerContact.setSelected(true);\r\n            }\r\n            toggleHistoryPerContact.setText(R.getI18NString(\"service.gui.HISTORY_TOGGLE_PER_CONTACT\"));\r\n            eraseHistoryPerContact.setText(R.getI18NString(\"service.gui.HISTORY_ERASE_PER_CONTACT\"));\r\n        } else if (desc instanceof ChatRoomWrapper) {\r\n            if (!mhs.isHistoryLoggingEnabled(((ChatRoomWrapper) desc).getChatRoom().getIdentifier())) {\r\n                toggleHistoryPerContact.setSelected(true);\r\n            }\r\n            toggleHistoryPerContact.setText(R.getI18NString(\"service.gui.HISTORY_TOGGLE_PER_CHATROOM\"));\r\n            eraseHistoryPerContact.setText(R.getI18NString(\"service.gui.HISTORY_ERASE_PER_CHATROOM\"));\r\n        }\r\n    }\r\n    if (toggleAllHistory.isSelected() || toggleHistoryPerContact.isSelected()) {\r\n        this.setIcon(new ImageIcon(ImageLoader.getImage(ImageLoader.HISTORY_ICON_OFF)));\r\n    } else\r\n        this.setIcon(new ImageIcon(ImageLoader.getImage(ImageLoader.HISTORY_ICON_ON)));\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.gui.internal.GuiServiceActivator.getResources",
	"Comment": "returns the resourcemanagementservice, through which we willaccess all resources.",
	"Method": "ResourceManagementService getResources(){\r\n    if (resourceService == null) {\r\n        resourceService = ServiceUtils.getService(bundleContext, ResourceManagementService.class);\r\n    }\r\n    return resourceService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.RegistrationStateChangeEvent.getOldState",
	"Comment": "returns the status of the provider before this event took place.",
	"Method": "RegistrationState getOldState(){\r\n    return (RegistrationState) super.getOldValue();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.ExtendedTooltip.ancestorRemoved",
	"Comment": "when the tooltip window is disposed elements are removed from itand this is the time to clear resources.",
	"Method": "void ancestorRemoved(AncestorEvent event){\r\n    if (this.parentWindow != null) {\r\n        this.parentWindow.removeWindowFocusListener(this);\r\n        this.parentWindow = null;\r\n    }\r\n    this.removeAncestorListener(this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.lookandfeel.SIPCommSplitPaneDivider.createLeftOneTouchButton",
	"Comment": "creates and returns an instance of jbutton that can be used to collapse the left component in the metal split pane.",
	"Method": "JButton createLeftOneTouchButton(){\r\n    JButton b = new JButton() {\r\n        int[][] buffer = { { 0, 0, 0, 2, 2, 0, 0, 0, 0 }, { 0, 0, 2, 1, 1, 1, 0, 0, 0 }, { 0, 2, 1, 1, 1, 1, 1, 0, 0 }, { 2, 1, 1, 1, 1, 1, 1, 1, 0 }, { 0, 3, 3, 3, 3, 3, 3, 3, 3 } };\r\n        @Override\r\n        public void setBorder(Border b) {\r\n        }\r\n        @Override\r\n        public void paint(Graphics g) {\r\n            JSplitPane splitPane = getSplitPaneFromSuper();\r\n            if (splitPane != null) {\r\n                int oneTouchSize = getOneTouchSizeFromSuper();\r\n                int orientation = getOrientationFromSuper();\r\n                int blockSize = Math.min(getDividerSize(), oneTouchSize);\r\n                Color[] colors = { this.getBackground(), MetalLookAndFeel.getPrimaryControlDarkShadow(), MetalLookAndFeel.getPrimaryControlInfo(), MetalLookAndFeel.getPrimaryControlHighlight() };\r\n                g.setColor(this.getBackground());\r\n                g.fillRect(0, 0, this.getWidth(), this.getHeight());\r\n                if (getModel().isPressed()) {\r\n                    colors[1] = colors[2];\r\n                }\r\n                if (orientation == JSplitPane.VERTICAL_SPLIT) {\r\n                    for (int i = 1; i <= buffer[0].length; i++) {\r\n                        for (int j = 1; j < blockSize; j++) {\r\n                            if (buffer[j - 1][i - 1] == 0)\r\n                                continue;\r\n                            else {\r\n                                g.setColor(colors[buffer[j - 1][i - 1]]);\r\n                            }\r\n                            g.drawLine(i, j, i, j);\r\n                        }\r\n                    }\r\n                } else {\r\n                    for (int i = 1; i <= buffer[0].length; i++) {\r\n                        for (int j = 1; j < blockSize; j++) {\r\n                            if (buffer[j - 1][i - 1] == 0) {\r\n                                continue;\r\n                            } else {\r\n                                g.setColor(colors[buffer[j - 1][i - 1]]);\r\n                            }\r\n                            g.drawLine(j, i, j, i);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    b.setRequestFocusEnabled(false);\r\n    b.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));\r\n    b.setFocusPainted(false);\r\n    b.setBorderPainted(false);\r\n    return b;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.lookandfeel.SIPCommSplitPaneDivider.createLeftOneTouchButton",
	"Comment": "creates and returns an instance of jbutton that can be used to collapse the left component in the metal split pane.",
	"Method": "JButton createLeftOneTouchButton(){\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.lookandfeel.SIPCommSplitPaneDivider.createLeftOneTouchButton",
	"Comment": "creates and returns an instance of jbutton that can be used to collapse the left component in the metal split pane.",
	"Method": "JButton createLeftOneTouchButton(){\r\n    JSplitPane splitPane = getSplitPaneFromSuper();\r\n    if (splitPane != null) {\r\n        int oneTouchSize = getOneTouchSizeFromSuper();\r\n        int orientation = getOrientationFromSuper();\r\n        int blockSize = Math.min(getDividerSize(), oneTouchSize);\r\n        Color[] colors = { this.getBackground(), MetalLookAndFeel.getPrimaryControlDarkShadow(), MetalLookAndFeel.getPrimaryControlInfo(), MetalLookAndFeel.getPrimaryControlHighlight() };\r\n        g.setColor(this.getBackground());\r\n        g.fillRect(0, 0, this.getWidth(), this.getHeight());\r\n        if (getModel().isPressed()) {\r\n            colors[1] = colors[2];\r\n        }\r\n        if (orientation == JSplitPane.VERTICAL_SPLIT) {\r\n            for (int i = 1; i <= buffer[0].length; i++) {\r\n                for (int j = 1; j < blockSize; j++) {\r\n                    if (buffer[j - 1][i - 1] == 0)\r\n                        continue;\r\n                    else {\r\n                        g.setColor(colors[buffer[j - 1][i - 1]]);\r\n                    }\r\n                    g.drawLine(i, j, i, j);\r\n                }\r\n            }\r\n        } else {\r\n            for (int i = 1; i <= buffer[0].length; i++) {\r\n                for (int j = 1; j < blockSize; j++) {\r\n                    if (buffer[j - 1][i - 1] == 0) {\r\n                        continue;\r\n                    } else {\r\n                        g.setColor(colors[buffer[j - 1][i - 1]]);\r\n                    }\r\n                    g.drawLine(j, i, j, i);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.MessageDeliveredEvent.getContactResource",
	"Comment": "returns a reference to the contactresource that has sent themessage whose reception this event represents.",
	"Method": "ContactResource getContactResource(){\r\n    return toResource;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.CallPeerMediaHandlerJabberImpl.wrapupConnectivityEstablishment",
	"Comment": "notifies the associated transportmanagerjabberimpl that itshould conclude any connectivity establishment, waits for it to actuallydo so and sets the connectors and targets of themediastreams managed by this callpeermediahandler.",
	"Method": "void wrapupConnectivityEstablishment(){\r\n    TransportManagerJabberImpl transportManager = getTransportManager();\r\n    transportManager.wrapupConnectivityEstablishment();\r\n    for (MediaType mediaType : MediaType.values()) {\r\n        MediaStream stream = getStream(mediaType);\r\n        if (stream != null) {\r\n            stream.setConnector(transportManager.getStreamConnector(mediaType));\r\n            stream.setTarget(transportManager.getStreamTarget(mediaType));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetTelephonyConferencingJabberImpl.createOutgoingCall",
	"Comment": "creates a new outgoing call into which conference callees are tobe invited by this operationsettelephonyconferencing.",
	"Method": "CallJabberImpl createOutgoingCall(){\r\n    return new CallJabberImpl(getBasicTelephony());\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaHandler.getSrtpControls",
	"Comment": "gets the srtpcontrols of the mediastreams of thisinstance.",
	"Method": "SrtpControls getSrtpControls(CallPeerMediaHandler<?> callPeerMediaHandler){\r\n    return srtpControls;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.growlnotification.GrowlNotificationActivator.start",
	"Comment": "initializes and starts a new growlnotificationserviceimplementation on mac os x.",
	"Method": "void start(BundleContext bundleContext){\r\n    if (!OSUtils.IS_MAC)\r\n        return;\r\n    if (logger.isInfoEnabled())\r\n        logger.info(\"Growl Notification... [Starting]\");\r\n    GrowlNotificationActivator.bundleContext = bundleContext;\r\n    handler = new GrowlNotificationServiceImpl();\r\n    handler.start(bundleContext);\r\n    bundleContext.registerService(PopupMessageHandler.class.getName(), handler, null);\r\n    if (logger.isInfoEnabled())\r\n        logger.info(\"Growl Notification... [Started]\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.MainFrame.pluginComponentRemoved",
	"Comment": "removes the associated with this plugincomponentevent componentfrom this container.",
	"Method": "void pluginComponentRemoved(PluginComponentEvent event){\r\n    final PluginComponentFactory factory = event.getPluginComponentFactory();\r\n    final Container containerID = factory.getContainer();\r\n    if (containerID.equals(Container.CONTAINER_MAIN_WINDOW)) {\r\n        Object constraints = UIServiceImpl.getBorderLayoutConstraintsFromContainer(factory.getConstraints());\r\n        if (constraints == null)\r\n            constraints = BorderLayout.SOUTH;\r\n        if (factory.isNativeComponent()) {\r\n            if (nativePluginsTable.contains(factory)) {\r\n                final Object finalConstraints = constraints;\r\n                SwingUtilities.invokeLater(new Runnable() {\r\n                    public void run() {\r\n                        removePluginComponent((Component) factory.getPluginComponentInstance(MainFrame.this).getComponent(), containerID, finalConstraints);\r\n                        getContentPane().repaint();\r\n                    }\r\n                });\r\n            }\r\n        } else {\r\n            this.removePluginComponent((Component) factory.getPluginComponentInstance(MainFrame.this).getComponent(), containerID, constraints);\r\n        }\r\n        nativePluginsTable.remove(factory);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.MainFrame.pluginComponentRemoved",
	"Comment": "removes the associated with this plugincomponentevent componentfrom this container.",
	"Method": "void pluginComponentRemoved(PluginComponentEvent event){\r\n    removePluginComponent((Component) factory.getPluginComponentInstance(MainFrame.this).getComponent(), containerID, finalConstraints);\r\n    getContentPane().repaint();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.RtpDescriptionPacketExtension.getChildExtensions",
	"Comment": "returns all child elements that we currently have in this packet.",
	"Method": "List<? extends PacketExtension> getChildExtensions(){\r\n    if (children == null)\r\n        children = new ArrayList<PacketExtension>();\r\n    else\r\n        children.clear();\r\n    children.addAll(payloadTypes);\r\n    if (encryption != null)\r\n        children.add(encryption);\r\n    if (bandwidth != null)\r\n        children.add(bandwidth);\r\n    if (extmapList != null)\r\n        children.addAll(extmapList);\r\n    children.addAll(super.getChildExtensions());\r\n    return children;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.macosx.MacOSXAddrBookContactSourceService.getPhoneNumberPrefix",
	"Comment": "returns the global phone number prefix to be used when calling contactsfrom this contact source.",
	"Method": "String getPhoneNumberPrefix(){\r\n    return AddrBookActivator.getConfigService().getString(MACOSX_ADDR_BOOK_PREFIX);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.googletalkaccregwizz.GoogleTalkAccRegWizzActivator.getBrowserLauncher",
	"Comment": "returns the browserlauncherservice obtained from the bundlecontext.",
	"Method": "BrowserLauncherService getBrowserLauncher(){\r\n    if (browserLauncherService == null) {\r\n        browserLauncherService = (BrowserLauncherService) bundleContext.getService(bundleContext.getServiceReference(BrowserLauncherService.class.getName()));\r\n    }\r\n    return browserLauncherService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ContactGroupIcqImpl.getContact",
	"Comment": "returns the contact with the specified address oridentifier.",
	"Method": "Contact getContact(String id){\r\n    return this.findContact(id);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomJabberImpl.addMessageListener",
	"Comment": "registers listener so that it would receive events every timea new message is received on this chat room.",
	"Method": "void addMessageListener(ChatRoomMessageListener listener){\r\n    synchronized (messageListeners) {\r\n        if (!messageListeners.contains(listener))\r\n            messageListeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl.updateSrtpControlsForDtls",
	"Comment": "updates the srtpcontrols of this instance in accord with aspecific mediadescription presented by a remote peer.",
	"Method": "void updateSrtpControlsForDtls(MediaType mediaType,MediaDescription localMd,MediaDescription remoteMd){\r\n    SrtpControls srtpControls = getSrtpControls();\r\n    DtlsControl dtlsControl = (DtlsControl) srtpControls.get(mediaType, SrtpControlType.DTLS_SRTP);\r\n    if (dtlsControl == null)\r\n        return;\r\n    boolean dtls = isDtlsMediaDescription(remoteMd);\r\n    if (dtls) {\r\n        if (localMd == null) {\r\n            String setup;\r\n            try {\r\n                setup = remoteMd.getAttribute(DTLS_SRTP_SETUP_ATTR);\r\n            } catch (SdpParseException spe) {\r\n                setup = null;\r\n            }\r\n            if (DtlsControl.Setup.PASSIVE.toString().equals(setup))\r\n                dtlsControl.setSetup(DtlsControl.Setup.ACTIVE);\r\n        }\r\n        @SuppressWarnings(\"unchecked\")\r\n        Vector<Attribute> attrs = remoteMd.getAttributes(false);\r\n        Map<String, String> remoteFingerprints = new LinkedHashMap<String, String>();\r\n        if (attrs != null) {\r\n            for (Attribute attr : attrs) {\r\n                String fingerprint;\r\n                try {\r\n                    if (DTLS_SRTP_FINGERPRINT_ATTR.equals(attr.getName())) {\r\n                        fingerprint = attr.getValue();\r\n                        if (fingerprint == null)\r\n                            continue;\r\n                        else\r\n                            fingerprint = fingerprint.trim();\r\n                    } else {\r\n                        continue;\r\n                    }\r\n                } catch (SdpParseException spe) {\r\n                    continue;\r\n                }\r\n                int spIndex = fingerprint.indexOf(' ');\r\n                if ((spIndex > 0) && (spIndex < fingerprint.length() - 1)) {\r\n                    String hashFunction = fingerprint.substring(0, spIndex);\r\n                    fingerprint = fingerprint.substring(spIndex + 1);\r\n                    remoteFingerprints.put(hashFunction, fingerprint);\r\n                }\r\n            }\r\n        }\r\n        dtlsControl.setRemoteFingerprints(remoteFingerprints);\r\n        removeAndCleanupOtherSrtpControls(mediaType, SrtpControlType.DTLS_SRTP);\r\n    } else {\r\n        srtpControls.remove(mediaType, SrtpControlType.DTLS_SRTP);\r\n        dtlsControl.cleanup(null);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.account.AccountRegSummaryPage.getBackPageIdentifier",
	"Comment": "implements the wizardpage.getbackpageidentifier method.",
	"Method": "Object getBackPageIdentifier(){\r\n    return wizardContainer.getCurrentWizard().getLastPageIdentifier();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.generalconfig.autoaway.AutoAwayWatcher.startListeningForNewProviders",
	"Comment": "start listening for new providers and their registration states.",
	"Method": "void startListeningForNewProviders(){\r\n    GeneralConfigPluginActivator.bundleContext.addServiceListener(this);\r\n    ServiceReference[] protocolProviderRefs = null;\r\n    try {\r\n        protocolProviderRefs = GeneralConfigPluginActivator.bundleContext.getServiceReferences(ProtocolProviderService.class.getName(), null);\r\n    } catch (InvalidSyntaxException ex) {\r\n        logger.error(\"Error while retrieving service refs\", ex);\r\n        return;\r\n    }\r\n    if (protocolProviderRefs != null) {\r\n        for (int i = 0; i < protocolProviderRefs.length; i++) {\r\n            ProtocolProviderService provider = (ProtocolProviderService) GeneralConfigPluginActivator.bundleContext.getService(protocolProviderRefs[i]);\r\n            this.handleProviderAdded(provider);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.TestOperationSetBasicTelephonyJabberImpl.testCreateCancelCall",
	"Comment": "creates a call from provider1 to provider2 then cancels it withoutwaiting for provider1 to answer.",
	"Method": "void testCreateCancelCall(){\r\n    OperationSetBasicTelephony<?> basicTelephonyP1 = fixture.provider1.getOperationSet(OperationSetBasicTelephony.class);\r\n    OperationSetBasicTelephony<?> basicTelephonyP2 = fixture.provider2.getOperationSet(OperationSetBasicTelephony.class);\r\n    CallEventCollector call1Listener = new CallEventCollector(basicTelephonyP1);\r\n    CallEventCollector call2Listener = new CallEventCollector(basicTelephonyP2);\r\n    String provider2Address = fixture.provider2.getAccountID().getAccountAddress();\r\n    Call callAtP1 = basicTelephonyP1.createCall(provider2Address);\r\n    call1Listener.waitForEvent(10000);\r\n    call2Listener.waitForEvent(10000);\r\n    assertEquals(\"The provider that created the call did not dispatch \" + \"an event that it has done so.\", 1, call1Listener.collectedEvents.size());\r\n    CallEvent callCreatedEvent = (CallEvent) call1Listener.collectedEvents.get(0);\r\n    assertEquals(\"CallEvent.getEventID()\", CallEvent.CALL_INITIATED, callCreatedEvent.getEventID());\r\n    assertSame(\"CallEvent.getSource()\", callAtP1, callCreatedEvent.getSource());\r\n    assertTrue(\"The callee provider did not receive a call or did \" + \"not issue an event.\", call2Listener.collectedEvents.size() > 0);\r\n    CallEvent callReceivedEvent = (CallEvent) call2Listener.collectedEvents.get(0);\r\n    Call callAtP2 = callReceivedEvent.getSourceCall();\r\n    assertEquals(\"CallEvent.getEventID()\", CallEvent.CALL_RECEIVED, callReceivedEvent.getEventID());\r\n    assertNotNull(\"CallEvent.getSource()\", callAtP2);\r\n    assertEquals(\"callAtP1.getCallPeerCount()\", 1, callAtP1.getCallPeerCount());\r\n    assertEquals(\"callAtP2.getCallPeerCount()\", 1, callAtP2.getCallPeerCount());\r\n    CallPeer peerAtP1 = callAtP1.getCallPeers().next();\r\n    CallPeer peerAtP2 = callAtP2.getCallPeers().next();\r\n    CallPeerStateEventCollector stateCollectorForPp1 = new CallPeerStateEventCollector(peerAtP1, CallPeerState.ALERTING_REMOTE_SIDE);\r\n    CallPeerStateEventCollector stateCollectorForPp2 = new CallPeerStateEventCollector(peerAtP2, CallPeerState.INCOMING_CALL);\r\n    stateCollectorForPp1.waitForEvent(10000, true);\r\n    stateCollectorForPp2.waitForEvent(10000, true);\r\n    assertSame(\"peerAtP1.getCall\", peerAtP1.getCall(), callAtP1);\r\n    assertSame(\"peerAtP2.getCall\", peerAtP2.getCall(), callAtP2);\r\n    assertEquals(\"The peer at provider one was not in the \" + \"right state.\", CallPeerState.ALERTING_REMOTE_SIDE, peerAtP1.getState());\r\n    assertEquals(\"The peer at provider two was not in the \" + \"right state.\", CallPeerState.INCOMING_CALL, peerAtP2.getState());\r\n    if (Boolean.getBoolean(\"accounts.jabber.PRESERVE_PEER_INFO\")) {\r\n        String expectedPeer1Address = fixture.provider2.getAccountID().getAccountAddress();\r\n        String expectedPeer1DisplayName = System.getProperty(JabberProtocolProviderServiceLick.ACCOUNT_2_PREFIX + ProtocolProviderFactory.DISPLAY_NAME);\r\n        assertTrue(\"Provider 2 did not advertise their \" + \"accountID.getAccoutAddress() address.\", expectedPeer1Address.indexOf(peerAtP1.getAddress()) != -1 || peerAtP1.getAddress().indexOf(expectedPeer1Address) != -1);\r\n        assertEquals(\"Provider 2 did not properly advertise their \" + \"display name.\", expectedPeer1DisplayName, peerAtP1.getDisplayName());\r\n        String expectedPeer2Address = fixture.provider1.getAccountID().getAccountAddress();\r\n        String expectedPeer2DisplayName = System.getProperty(JabberProtocolProviderServiceLick.ACCOUNT_1_PREFIX + ProtocolProviderFactory.DISPLAY_NAME);\r\n        assertTrue(\"Provider 1 did not advertise their \" + \"accountID.getAccoutAddress() address.\", expectedPeer2Address.indexOf(peerAtP2.getAddress()) != -1 || peerAtP2.getAddress().indexOf(expectedPeer2Address) != -1);\r\n        assertEquals(\"Provider 1 did not properly advertise their \" + \"display name.\", expectedPeer2DisplayName, peerAtP2.getDisplayName());\r\n    }\r\n    stateCollectorForPp1 = new CallPeerStateEventCollector(peerAtP1, CallPeerState.DISCONNECTED);\r\n    stateCollectorForPp2 = new CallPeerStateEventCollector(peerAtP2, CallPeerState.DISCONNECTED);\r\n    call1Listener = new CallEventCollector(basicTelephonyP1);\r\n    call2Listener = new CallEventCollector(basicTelephonyP2);\r\n    CallStateEventCollector call1StateCollector = new CallStateEventCollector(callAtP1, CallState.CALL_ENDED);\r\n    CallStateEventCollector call2StateCollector = new CallStateEventCollector(callAtP2, CallState.CALL_ENDED);\r\n    basicTelephonyP1.hangupCallPeer(peerAtP1);\r\n    call1Listener.waitForEvent(10000);\r\n    call2Listener.waitForEvent(10000);\r\n    stateCollectorForPp1.waitForEvent(10000);\r\n    stateCollectorForPp2.waitForEvent(10000);\r\n    call1StateCollector.waitForEvent(10000);\r\n    call2StateCollector.waitForEvent(10000);\r\n    assertEquals(\"The peer at provider one was not in the \" + \"right state.\", CallPeerState.DISCONNECTED, peerAtP1.getState());\r\n    assertEquals(\"The basic telephony operation set did not distribute \" + \"an event to notify us that a call has been ended.\", 1, call1Listener.collectedEvents.size());\r\n    CallEvent collectedEvent = (CallEvent) call1Listener.collectedEvents.get(0);\r\n    assertEquals(\"The basic telephony operation set did not distribute \" + \"an event to notify us that a call has been ended.\", CallEvent.CALL_ENDED, collectedEvent.getEventID());\r\n    assertEquals(\"The peer at provider one was not in the \" + \"right state.\", CallPeerState.DISCONNECTED, peerAtP2.getState());\r\n    assertEquals(\"The basic telephony operation set did not distribute \" + \"an event to notify us that a call has been ended.\", 1, call2Listener.collectedEvents.size());\r\n    collectedEvent = (CallEvent) call2Listener.collectedEvents.get(0);\r\n    assertEquals(\"The basic telephony operation set did not distribute \" + \"an event to notify us that a call has been ended.\", CallEvent.CALL_ENDED, collectedEvent.getEventID());\r\n    assertEquals(\"A call did not change its state to CallState.CALL_ENDED \" + \"when it ended.\", CallState.CALL_ENDED, callAtP1.getCallState());\r\n    assertEquals(\"A call did not change its state to CallState.CALL_ENDED \" + \"when it ended.\", CallState.CALL_ENDED, callAtP2.getCallState());\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.AbstractOperationSetDTMF.getDTMFMethod",
	"Comment": "returns the corresponding dtmf method used for this account.",
	"Method": "DTMFMethod getDTMFMethod(ProtocolProviderService pps){\r\n    AccountID accountID = pps.getAccountID();\r\n    String dtmfString = accountID.getAccountPropertyString(\"DTMF_METHOD\");\r\n    if (dtmfString == null || (!dtmfString.equals(\"AUTO_DTMF\") && !dtmfString.equals(\"RTP_DTMF\") && !dtmfString.equals(\"SIP_INFO_DTMF\") && !dtmfString.equals(\"INBAND_DTMF\"))) {\r\n        dtmfString = \"AUTO_DTMF\";\r\n        accountID.putAccountProperty(\"DTMF_METHOD\", dtmfString);\r\n    }\r\n    if (dtmfString.equals(\"AUTO_DTMF\")) {\r\n        return DTMFMethod.AUTO_DTMF;\r\n    } else if (dtmfString.equals(\"RTP_DTMF\")) {\r\n        return DTMFMethod.RTP_DTMF;\r\n    } else if (dtmfString.equals(\"SIP_INFO_DTMF\")) {\r\n        return DTMFMethod.SIP_INFO_DTMF;\r\n    } else {\r\n        return DTMFMethod.INBAND_DTMF;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.wizard.EncodingsPanel.resetTables",
	"Comment": "recreates the audio and video controls. necessary whenour encodingconfiguration reference has changed.",
	"Method": "void resetTables(){\r\n    audioPanel.remove(audioControls);\r\n    videoPanel.remove(videoControls);\r\n    audioControls = mediaConfiguration.createEncodingControls(MediaType.AUDIO, encodingConfiguration);\r\n    videoControls = mediaConfiguration.createEncodingControls(MediaType.VIDEO, encodingConfiguration);\r\n    audioPanel.add(audioControls);\r\n    videoPanel.add(videoControls);\r\n    updateTableState();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ContactGroupSipImpl.subgroups",
	"Comment": "returns an iterator over the sub groups that thiscontactgroup contains.",
	"Method": "Iterator<ContactGroup> subgroups(){\r\n    return subGroups.iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.notification.event.NotificationActionTypeEvent.getActionHandler",
	"Comment": "returns the notificationactionhandler that handles the action,for which this event is about.",
	"Method": "NotificationAction getActionHandler(){\r\n    return actionHandler;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.GroupNode.fireNodeRemoved",
	"Comment": "notifies all interested listeners that node has been removedfrom the given index.",
	"Method": "void fireNodeRemoved(ContactListNode node,int index){\r\n    treeModel.nodesWereRemoved(this, new int[] { index }, new Object[] { node });\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.GuiActivator.getMetaHistoryService",
	"Comment": "returns the metahistoryservice obtained from the bundlecontext.",
	"Method": "MetaHistoryService getMetaHistoryService(){\r\n    if (metaHistoryService == null) {\r\n        metaHistoryService = ServiceUtils.getService(bundleContext, MetaHistoryService.class);\r\n    }\r\n    return metaHistoryService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ContactListTransferHandler.getChatPanel",
	"Comment": "returns the chatpanel corresponding to the currently selectedcontact.",
	"Method": "ChatPanel getChatPanel(){\r\n    ChatPanel chatPanel = null;\r\n    Object selectedObject = contactList.getSelectedValue();\r\n    if (selectedObject instanceof MetaContact) {\r\n        MetaContact metaContact = (MetaContact) selectedObject;\r\n        chatPanel = GuiActivator.getUIService().getChatWindowManager().getContactChat(metaContact, true);\r\n    }\r\n    return chatPanel;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.galagonotification.GalagoPopupMessageHandler.showPopupMessage",
	"Comment": "shows the title and the message of the specified popupmessage.",
	"Method": "void showPopupMessage(PopupMessage popupMessage){\r\n    try {\r\n        GalagoNotification.notify(GalagoNotificationActivator.dbusConnection, null, 0, iconStaticIsImplemented ? getIcon(popupMessage) : null, popupMessage.getMessageTitle(), popupMessage.getMessage(), -1);\r\n    } catch (DBusException dbe) {\r\n        logger.error(\"Failed to show PopupMessage \" + popupMessage, dbe);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.IncomingFileTransferRequestIcqImpl.getFileSize",
	"Comment": "returns a long that represents the size of the file that is beingreceived.if there is no file size available, returns null.",
	"Method": "long getFileSize(){\r\n    return incomingFileTransfer.getRequestFileInfo().getTotalFileSize();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockChatRoom.addPropertyChangeListener",
	"Comment": "adds a listener that will be notified of changes in the property of theroom such as the subject being change or the room state being changed.",
	"Method": "void addPropertyChangeListener(ChatRoomPropertyChangeListener listener){\r\n    if (!propertyChangeListeners.contains(listener))\r\n        propertyChangeListeners.add(listener);\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.ServiceObserver.stop",
	"Comment": "this method should be called on bundle shutdown to properly releasethe resources.",
	"Method": "void stop(BundleContext ctx){\r\n    ctx.removeServiceListener(this);\r\n    services.clear();\r\n    this.context = null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.AdHocConferenceChatTransport.getProtocolProvider",
	"Comment": "returns the protocolproviderservice, corresponding to this chattransport.",
	"Method": "ProtocolProviderService getProtocolProvider(){\r\n    return adHocChatRoom.getParentProvider();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.EventPackageSupport.getOrCreateServerTransaction",
	"Comment": "safely returns the servertransaction associated with aspecific requestevent or creates a new one if the specifiedrequestevent is not associated with one. does not throwtransactionalreadyexistsexception andtransactionunavailableexception but rather logs theseexceptions if they occur and returns null.",
	"Method": "ServerTransaction getOrCreateServerTransaction(RequestEvent requestEvent){\r\n    ServerTransaction serverTransaction = null;\r\n    try {\r\n        serverTransaction = SipStackSharing.getOrCreateServerTransaction(requestEvent);\r\n    } catch (TransactionAlreadyExistsException ex) {\r\n        logger.error(\"Failed to create a new server\" + \"transaction for an incoming request\\n\" + \"(Next message contains the request)\", ex);\r\n    } catch (TransactionUnavailableException ex) {\r\n        logger.error(\"Failed to create a new server\" + \"transaction for an incoming request\\n\" + \"(Next message contains the request)\", ex);\r\n    }\r\n    return serverTransaction;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.plaf.SIPCommTabbedPaneUI.uninstallComponents",
	"Comment": "removes any installed subcomponents from the jtabbedpane. invoked byuninstallui.",
	"Method": "void uninstallComponents(){\r\n    tabPane.remove(tabScroller.viewport);\r\n    tabPane.remove(tabScroller.scrollForwardButton);\r\n    tabPane.remove(tabScroller.scrollBackwardButton);\r\n    tabScroller = null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ContactGroupSipImpl.findGroupParent",
	"Comment": "returns the group that is parent of the specified sipgroup or nullif no parent was found.",
	"Method": "ContactGroupSipImpl findGroupParent(ContactGroupSipImpl sipGroup){\r\n    if (subGroups.contains(sipGroup))\r\n        return this;\r\n    Iterator<ContactGroup> subGroupsIter = subgroups();\r\n    while (subGroupsIter.hasNext()) {\r\n        ContactGroupSipImpl subgroup = (ContactGroupSipImpl) subGroupsIter.next();\r\n        ContactGroupSipImpl parent = subgroup.findGroupParent(sipGroup);\r\n        if (parent != null)\r\n            return parent;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.aimaccregwizz.AimAccRegWizzActivator.getBrowserLauncher",
	"Comment": "returns the browserlauncherservice obtained from the bundlecontext.",
	"Method": "BrowserLauncherService getBrowserLauncher(){\r\n    if (browserLauncherService == null) {\r\n        ServiceReference serviceReference = bundleContext.getServiceReference(BrowserLauncherService.class.getName());\r\n        browserLauncherService = (BrowserLauncherService) bundleContext.getService(serviceReference);\r\n    }\r\n    return browserLauncherService;\r\n}"
}, {
	"Path": "net.librec.recommender.cf.UserKNNTestCase.test20SplitterRatioRating",
	"Comment": "test ratiodatasplitter with rating ratio, filter enabled.",
	"Method": "void test20SplitterRatioRating(){\r\n    Resource resource = new Resource(\"rec/cf/userknn-test.properties\");\r\n    conf.addResource(resource);\r\n    conf.set(\"rec.eval.enable\", \"false\");\r\n    conf.set(\"rec.filter.class\", \"generic\");\r\n    conf.set(\"data.model.splitter\", \"ratio\");\r\n    conf.set(\"data.splitter.ratio\", \"rating\");\r\n    RecommenderJob job = new RecommenderJob(conf);\r\n    job.runJob();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.utils.OneChoiceInviteDialog.enterKeyTyped",
	"Comment": "called when the enter key was typed when this container was the focusedcontainer. performs the appropriate actions depending on the currentstate of the contained contact list.",
	"Method": "void enterKeyTyped(){\r\n    UIContact selectedContact = contactList.getSelectedContact();\r\n    if (selectedContact != null) {\r\n        okButton.doClick();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWindow.windowGainedFocus",
	"Comment": "handles windowevents triggered when the window has gained focus.",
	"Method": "void windowGainedFocus(WindowEvent evt){\r\n    ChatPanel currentChat = getCurrentChat();\r\n    if (currentChat != null)\r\n        GuiActivator.getUIService().getChatWindowManager().removeNonReadChatState(currentChat);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.CryptoPacketExtension.equalsTag",
	"Comment": "returns if the current tag equals the one given in parameter.",
	"Method": "boolean equalsTag(String tag){\r\n    String currentTag = this.getTag();\r\n    return CryptoPacketExtension.equalsStrings(currentTag, tag);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.RenameGroupDialog.init",
	"Comment": "initializes the renamegroupdialog by adding the buttons,fields, etc.",
	"Method": "void init(){\r\n    this.setTitle(GuiActivator.getResources().getI18NString(\"service.gui.RENAME_GROUP\"));\r\n    this.getRootPane().setDefaultButton(renameButton);\r\n    this.renameButton.setName(\"rename\");\r\n    this.cancelButton.setName(\"cancel\");\r\n    this.renameButton.setMnemonic(GuiActivator.getResources().getI18nMnemonic(\"service.gui.RENAME\"));\r\n    this.cancelButton.setMnemonic(GuiActivator.getResources().getI18nMnemonic(\"service.gui.CANCEL\"));\r\n    this.renameButton.addActionListener(this);\r\n    this.cancelButton.addActionListener(this);\r\n    this.buttonsPanel.add(renameButton);\r\n    this.buttonsPanel.add(cancelButton);\r\n    this.mainPanel.setBorder(BorderFactory.createEmptyBorder(5, 10, 0, 10));\r\n    this.mainPanel.add(renameGroupPanel, BorderLayout.NORTH);\r\n    this.mainPanel.add(buttonsPanel, BorderLayout.SOUTH);\r\n    this.getContentPane().add(mainPanel);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.AdHocChatRoomInvitationRejectedEvent.getTimestamp",
	"Comment": "a timestamp indicating the exact date when the event occurred.",
	"Method": "Date getTimestamp(){\r\n    return timestamp;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.CallJabberImpl.setChannelDirection",
	"Comment": "sends a colibriconferenceiq to the videobridge used by thiscalljabberimpl, in order to request the the direction ofthe channel with id channelid be set todirection",
	"Method": "void setChannelDirection(String channelID,MediaType mediaType,MediaDirection direction){\r\n    if ((colibri != null) && (channelID != null)) {\r\n        ColibriConferenceIQ.Content content = colibri.getContent(mediaType.toString());\r\n        if (content != null) {\r\n            ColibriConferenceIQ.Channel channel = content.getChannel(channelID);\r\n            if (channel != null) {\r\n                ColibriConferenceIQ.Channel requestChannel = new ColibriConferenceIQ.Channel();\r\n                requestChannel.setID(channelID);\r\n                requestChannel.setDirection(direction);\r\n                ColibriConferenceIQ.Content requestContent = new ColibriConferenceIQ.Content();\r\n                requestContent.setName(mediaType.toString());\r\n                requestContent.addChannel(requestChannel);\r\n                ColibriConferenceIQ conferenceRequest = new ColibriConferenceIQ();\r\n                conferenceRequest.setID(colibri.getID());\r\n                conferenceRequest.setTo(colibri.getFrom());\r\n                conferenceRequest.setType(IQ.Type.SET);\r\n                conferenceRequest.addContent(requestContent);\r\n                getProtocolProvider().getConnection().sendPacket(conferenceRequest);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.menus.ChatRightButtonMenu.actionPerformed",
	"Comment": "handles the actionevent when one of the menu items is selected.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    JMenuItem menuItem = (JMenuItem) e.getSource();\r\n    String itemText = menuItem.getName();\r\n    if (itemText.equalsIgnoreCase(\"copy\")) {\r\n        this.chatConvPanel.copyConversation();\r\n    } else if (itemText.equalsIgnoreCase(\"save\")) {\r\n    } else if (itemText.equalsIgnoreCase(\"print\")) {\r\n    } else if (itemText.equalsIgnoreCase(\"service.gui.CLOSE\")) {\r\n        Window window = this.chatConvPanel.getChatContainer().getConversationContainerWindow();\r\n        window.setVisible(false);\r\n        window.dispose();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetPresenceSipImpl.finalizeSubscription",
	"Comment": "finalize the subscription of a contact and transform the pending contactinto a real contact.",
	"Method": "void finalizeSubscription(ContactSipImpl contact){\r\n    if (contact == null)\r\n        throw new NullPointerException(\"contact\");\r\n    contact.setResolved(true);\r\n    this.fireSubscriptionEvent(contact, contact.getParentContactGroup(), SubscriptionEvent.SUBSCRIPTION_RESOLVED);\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"contact \" + contact + \" resolved\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactListServiceImpl.createMetaContact",
	"Comment": "first makes the specified protocol provider create a contactcorresponding to the specified contactid, then creates a newmetacontact which will encapsulate the newly created protocol specificcontact.",
	"Method": "MetaContact createMetaContact(ProtocolProviderService provider,MetaContactGroup metaContactGroup,String contactID){\r\n    if (!(metaContactGroup instanceof MetaContactGroupImpl)) {\r\n        throw new IllegalArgumentException(metaContactGroup + \" is not an instance of MetaContactGroupImpl\");\r\n    }\r\n    MetaContactImpl newMetaContact = new MetaContactImpl();\r\n    this.addNewContactToMetaContact(provider, metaContactGroup, newMetaContact, contactID, false);\r\n    fireMetaContactEvent(newMetaContact, findParentMetaContactGroup(newMetaContact), MetaContactEvent.META_CONTACT_ADDED);\r\n    return newMetaContact;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.JabberServerChooserDialog.fillTable",
	"Comment": "fill the servers array variable with data from the remote servers.xml",
	"Method": "void fillTable(){\r\n    BundleContext bc = JabberAccRegWizzActivator.bundleContext;\r\n    ServiceReference faServiceReference = bc.getServiceReference(FileAccessService.class.getName());\r\n    faService = (FileAccessService) bc.getService(faServiceReference);\r\n    File localServersListFile = null;\r\n    try {\r\n        localServersListFile = faService.getTemporaryFile();\r\n        URL file = new URL(\"https://xmpp.net/services.php\");\r\n        InputStream stream = file.openStream();\r\n        try {\r\n            byte[] buf = new byte[2048];\r\n            int len;\r\n            if (stream.available() > 0) {\r\n                FileOutputStream fos = new FileOutputStream(localServersListFile);\r\n                while ((len = stream.read(buf)) > 0) {\r\n                    fos.write(buf, 0, len);\r\n                }\r\n                fos.close();\r\n            }\r\n        } finally {\r\n            stream.close();\r\n        }\r\n        FileInputStream fis = new FileInputStream(localServersListFile);\r\n        DocumentBuilder constructor = XMLUtils.newDocumentBuilderFactory().newDocumentBuilder();\r\n        Document document = constructor.parse(fis);\r\n        Element root = document.getDocumentElement();\r\n        NodeList list = root.getElementsByTagName(\"item\");\r\n        for (int i = 0; i < list.getLength(); i++) {\r\n            Element e = (Element) list.item(i);\r\n            servers.add(new String(e.getAttribute(\"jid\")));\r\n        }\r\n        fis.close();\r\n    } catch (Exception e) {\r\n        logger.error(\"Failed to get a reference to the Jabber servers list file.\", e);\r\n    } finally {\r\n        if (localServersListFile != null) {\r\n            localServersListFile.delete();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.fireChatHistoryChange",
	"Comment": "notifies all registered chathistorylisteners that a change hasoccurred in the history of this chat.",
	"Method": "void fireChatHistoryChange(){\r\n    Iterator<ChatHistoryListener> listeners = historyListeners.iterator();\r\n    while (listeners.hasNext()) {\r\n        listeners.next().chatHistoryChanged(this);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.slickless.SlicklessTests.createSuite",
	"Comment": "collect all the slickless tests for running, either under felixor simply under junit",
	"Method": "Test createSuite(){\r\n    String tests = System.getProperty(TEST_LIST_PROPERTY_NAME);\r\n    if (tests == null || tests.trim().length() == 0) {\r\n        tests = \"\";\r\n    }\r\n    logger.debug(\"specfied test list is: \" + tests);\r\n    StringTokenizer st = new StringTokenizer(tests);\r\n    String[] ids = new String[st.countTokens()];\r\n    int n = 0;\r\n    while (st.hasMoreTokens()) {\r\n        ids[n++] = st.nextToken().trim();\r\n    }\r\n    TestSuite suite = new TestSuite();\r\n    for (int i = 0; i < n; i++) {\r\n        String testName = ids[i];\r\n        if (testName != null && testName.trim().length() > 0) {\r\n            try {\r\n                Class<?> testClass = Class.forName(testName);\r\n                if ((bc == null) && BundleActivator.class.isAssignableFrom(testClass)) {\r\n                    logger.error(\"test \" + testName + \" skipped - it must run under felix\");\r\n                } else {\r\n                    suite.addTest(new TestSuite(testClass));\r\n                }\r\n            } catch (ClassNotFoundException e) {\r\n                logger.error(\"Failed to load standalone test \" + testName);\r\n            }\r\n        }\r\n    }\r\n    return suite;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.customcontrols.wizard.Wizard.showDialog",
	"Comment": "convenience method that displays a modal wizard dialog and blocks untilthe dialog has completed.",
	"Method": "void showDialog(boolean modal){\r\n    if (modal)\r\n        this.setModal(true);\r\n    this.pack();\r\n    super.setVisible(true);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.notificationconfiguration.Resources.getString",
	"Comment": "returns an internationalized string corresponding to the given key.",
	"Method": "String getString(String key){\r\n    try {\r\n        return getResources().getI18NString(key);\r\n    } catch (MissingResourceException e) {\r\n        return '!' + key + '!';\r\n    }\r\n}"
}, {
	"Path": "io.lettuce.core.models.role.RoleParser.parse",
	"Comment": "parse the output of the redis role command and convert to a redisinstance.",
	"Method": "RedisInstance parse(List<?> roleOutput){\r\n    LettuceAssert.isTrue(roleOutput != null && !roleOutput.isEmpty(), \"Empty role output\");\r\n    LettuceAssert.isTrue(roleOutput.get(0) instanceof String && ROLE_MAPPING.containsKey(roleOutput.get(0)), \"First role element must be a string (any of \" + ROLE_MAPPING.keySet() + \")\");\r\n    RedisInstance.Role role = ROLE_MAPPING.get(roleOutput.get(0));\r\n    switch(role) {\r\n        case MASTER:\r\n            return parseMaster(roleOutput);\r\n        case SLAVE:\r\n            return parseSlave(roleOutput);\r\n        case SENTINEL:\r\n            return parseSentinel(roleOutput);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.ippiaccregwizz.IppiAccRegWizzActivator.getBrowserLauncher",
	"Comment": "returns the browserlauncherservice obtained from the bundlecontext.",
	"Method": "BrowserLauncherService getBrowserLauncher(){\r\n    if (browserLauncherService == null) {\r\n        browserLauncherService = (BrowserLauncherService) bundleContext.getService(bundleContext.getServiceReference(BrowserLauncherService.class.getName()));\r\n    }\r\n    return browserLauncherService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapDirectorySettingsImpl.setPhotoInline",
	"Comment": "sets whether photos are retrieved along with the other attributes.",
	"Method": "void setPhotoInline(boolean inline){\r\n    this.photoInline = inline;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommTabbedPane.getOverTabIndex",
	"Comment": "returns the index of the last tab on which the mouse did an action.",
	"Method": "int getOverTabIndex(){\r\n    return overTabIndex;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.history.HistoryServiceImpl.getDirForHistory",
	"Comment": "returns the folder for the given history without creating it.",
	"Method": "File getDirForHistory(HistoryID id){\r\n    String[] dirNames = id.getID();\r\n    StringBuffer dirName = new StringBuffer();\r\n    for (int i = 0; i < dirNames.length; i++) {\r\n        if (i > 0)\r\n            dirName.append(File.separatorChar);\r\n        dirName.append(dirNames[i]);\r\n    }\r\n    File histDir = null;\r\n    try {\r\n        String userSetDataDirectory = System.getProperty(\"HistoryServiceDirectory\");\r\n        histDir = getFileAccessService().getPrivatePersistentDirectory((userSetDataDirectory == null) ? DATA_DIRECTORY : userSetDataDirectory, FileCategory.PROFILE);\r\n    } catch (Exception e) {\r\n        logger.error(\"Error opening directory\", e);\r\n    }\r\n    return new File(histDir, dirName.toString());\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractOperationSetTypingNotifications.removeTypingNotificationsListener",
	"Comment": "removes listener from the list of listeners registered forreceiving typingnotificationevents.",
	"Method": "void removeTypingNotificationsListener(TypingNotificationsListener listener){\r\n    synchronized (typingNotificationsListeners) {\r\n        typingNotificationsListeners.remove(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.MUCActivator.getAccountManager",
	"Comment": "returns the accountmanager obtained from the bundle context.",
	"Method": "AccountManager getAccountManager(){\r\n    if (accountManager == null) {\r\n        accountManager = ServiceUtils.getService(bundleContext, AccountManager.class);\r\n    }\r\n    return accountManager;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.jabber.JabberAccountRegistration.storeProperties",
	"Comment": "stores jabber account configuration held by this registration object intogivenaccountproperties map.",
	"Method": "void storeProperties(String userName,String passwd,String protocolIconPath,String accountIconPath,Map<String, String> accountProperties){\r\n    if (rememberPassword)\r\n        setPassword(passwd);\r\n    else\r\n        setPassword(null);\r\n    String serverName = null;\r\n    if (getServerAddress() != null && getServerAddress().length() > 0) {\r\n        serverName = getServerAddress();\r\n    } else {\r\n        serverName = getServerFromUserName(userName);\r\n    }\r\n    if (serverName == null || serverName.length() <= 0)\r\n        throw new OperationFailedException(\"Should specify a server for user name \" + userName + \".\", OperationFailedException.SERVER_NOT_SPECIFIED);\r\n    BundleContext bContext = ProtocolProviderActivator.getBundleContext();\r\n    ProtocolProviderFactory jbfFactory = ProtocolProviderFactory.getProtocolProviderFactory(bContext, ProtocolNames.JABBER);\r\n    AccountManager accManager = ProtocolProviderActivator.getAccountManager();\r\n    String accountNodeName = accManager.getAccountNodeName(jbfFactory, editedAccUID);\r\n    if (accountNodeName != null) {\r\n        ConfigurationService configSrvc = ProtocolProviderActivator.getConfigurationService();\r\n        String factoryPackage = accManager.getFactoryImplPackageName(jbfFactory);\r\n        String accountPrefix = factoryPackage + \".\" + accountNodeName;\r\n        List<String> allProperties = configSrvc.getAllPropertyNames();\r\n        String stunPrefix = accountPrefix + \".\" + ProtocolProviderFactory.STUN_PREFIX;\r\n        String jinglePrefix = accountPrefix + \".\" + JingleNodeDescriptor.JN_PREFIX;\r\n        for (String property : allProperties) {\r\n            if (property.startsWith(stunPrefix) || property.startsWith(jinglePrefix)) {\r\n                configSrvc.removeProperty(property);\r\n            }\r\n        }\r\n        String[] accKeys = this.accountProperties.keySet().toArray(new String[accountProperties.size()]);\r\n        for (String property : accKeys) {\r\n            if (property.startsWith(ProtocolProviderFactory.STUN_PREFIX) || property.startsWith(JingleNodeDescriptor.JN_PREFIX)) {\r\n                this.accountProperties.remove(property);\r\n            }\r\n        }\r\n    }\r\n    List<StunServerDescriptor> stunServers = getAdditionalStunServers();\r\n    int serverIndex = -1;\r\n    for (StunServerDescriptor stunServer : stunServers) {\r\n        serverIndex++;\r\n        stunServer.storeDescriptor(this.accountProperties, ProtocolProviderFactory.STUN_PREFIX + serverIndex);\r\n    }\r\n    List<JingleNodeDescriptor> jnRelays = getAdditionalJingleNodes();\r\n    serverIndex = -1;\r\n    for (JingleNodeDescriptor jnRelay : jnRelays) {\r\n        serverIndex++;\r\n        jnRelay.storeDescriptor(this.accountProperties, JingleNodeDescriptor.JN_PREFIX + serverIndex);\r\n    }\r\n    securityRegistration.storeProperties(this.accountProperties);\r\n    encodingsRegistration.storeProperties(this.accountProperties);\r\n    super.storeProperties(protocolIconPath, accountIconPath, accountProperties);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.CallConference.callRemoved",
	"Comment": "notifies this callconference that a specific call hasbeen removed from the list of calls participating in thistelephony conference.",
	"Method": "void callRemoved(Call call){\r\n    call.removeCallChangeListener(callChangeListener);\r\n    removeCallPeerConferenceListener(call);\r\n    boolean conferenceFocus = isConferenceFocus(getCalls());\r\n    if (!conferenceFocus)\r\n        setConferenceFocus(conferenceFocus);\r\n    firePropertyChange(CALLS, call, null);\r\n}"
}, {
	"Path": "net.librec.math.algorithm.Randoms.wishart",
	"Comment": "randomly sample a matrix from wishart distribution with the given parameters.",
	"Method": "DenseMatrix wishart(DenseMatrix scale,double df){\r\n    DenseMatrix A = scale.cholesky();\r\n    if (A == null)\r\n        return null;\r\n    int p = scale.rowSize();\r\n    DenseMatrix z = new DenseMatrix(p, p);\r\n    for (int i = 0; i < p; i++) {\r\n        for (int j = 0; j < p; j++) {\r\n            z.set(i, j, Randoms.gaussian(0, 1));\r\n        }\r\n    }\r\n    DenseVector y = new VectorBasedDenseVector(p);\r\n    for (int i = 0; i < p; i++) y.set(i, Randoms.gamma((df - (i + 1)) / 2, 2));\r\n    DenseMatrix B = new DenseMatrix(p, p);\r\n    B.set(0, 0, y.get(0));\r\n    if (p > 1) {\r\n        for (int j = 1; j < p; j++) {\r\n            double tmpValue = 0.0D;\r\n            for (int k = 0; k < j; k++) tmpValue += z.get(k, j) * z.get(k, j);\r\n            B.set(j, j, y.get(j) + tmpValue);\r\n        }\r\n        for (int j = 1; j < p; j++) {\r\n            B.set(0, j, z.get(0, j) * Math.sqrt(y.get(0)));\r\n            B.set(j, 0, B.get(0, j));\r\n        }\r\n    }\r\n    if (p > 2) {\r\n        for (int j = 2; j < p; j++) {\r\n            for (int i = 1; i <= j - 1; i++) {\r\n                double tempValue = 0.0D;\r\n                for (int k = 0; k <= i - 1; k++) {\r\n                    tempValue += z.get(k, i) * z.get(k, j);\r\n                }\r\n                B.set(i, j, z.get(i, j) * Math.sqrt(y.get(i)) + tempValue);\r\n                B.set(j, i, B.get(i, j));\r\n            }\r\n        }\r\n    }\r\n    return A.transpose().times(B).times(A);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.CryptoPacketExtension.initialize",
	"Comment": "initialises it with the parameters contained by the cryptoattribute.",
	"Method": "void initialize(SrtpCryptoAttribute cryptoAttribute){\r\n    this.setTag(Integer.toString(cryptoAttribute.getTag()));\r\n    this.setCryptoSuite(cryptoAttribute.getCryptoSuite().encode());\r\n    this.setKeyParams(cryptoAttribute.getKeyParamsString());\r\n    String sessionParamsString = cryptoAttribute.getSessionParamsString();\r\n    if (sessionParamsString != null) {\r\n        this.setSessionParams(sessionParamsString);\r\n    }\r\n}"
}, {
	"Path": "net.librec.recommender.cf.ranking.NMFItemItemRecommender.predict",
	"Comment": "this is not fast if you call for each item from outsidecalculate factors first and then calculate with factors the prediction of each item",
	"Method": "double predict(SequentialSparseVector itemRatingsVector,int itemIdx,double predict,int userIdx,int itemIdx){\r\n    SequentialSparseVector itemRatingsVector = trainMatrix.row(userIdx);\r\n    return predict(itemRatingsVector, itemIdx);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.DefaultTreeContactList.getUIClassID",
	"Comment": "returns the name of the l&f class that renders this component.",
	"Method": "String getUIClassID(){\r\n    return uiClassID;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.configuration.TestConfigurationService.testRemoveProperty",
	"Comment": "tests whether removing and getting properties works correctly.",
	"Method": "void testRemoveProperty(){\r\n    String propertyName = \"my.test.property.acc1234\";\r\n    Object property = new String(\"my.test.property's value\");\r\n    configurationService.setProperty(propertyName, property);\r\n    Object actualReturn = configurationService.getProperty(propertyName);\r\n    assertEquals(\"a property was not properly stored\", property, actualReturn);\r\n    configurationService.removeProperty(propertyName);\r\n    Object actualReturn2 = configurationService.getProperty(propertyName);\r\n    assertNull(\"a property was not properly removed\", actualReturn2);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.notificationwiring.NotificationWiringActivator.getNotificationService",
	"Comment": "returns the notificationservice obtained from the bundle context.",
	"Method": "NotificationService getNotificationService(){\r\n    return notificationService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.TransferCallDialog.initContactListData",
	"Comment": "initializes the left contact list with the contacts that could be addedto the current chat session.",
	"Method": "void initContactListData(ProtocolProviderService protocolProvider){\r\n    initContactSources();\r\n    contactList.addContactSource(new ProtocolContactSourceServiceImpl(protocolProvider, OperationSetBasicTelephony.class));\r\n    contactList.addContactSource(new StringContactSourceServiceImpl(protocolProvider, OperationSetBasicTelephony.class));\r\n    contactList.applyDefaultFilter();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.netaddr.NetworkAddressManagerServiceImpl.createIceAgent",
	"Comment": "creates and returns an ice agent that a protocol could use for the negotiation of media transport addresses. one ice agent should only be used for a single session negotiation.",
	"Method": "Agent createIceAgent(){\r\n    return new Agent();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl.getCallInfoURL",
	"Comment": "returns a url pointing ta a location with call controlinformation for this peer or null if no such url isavailable for the callpeer associated with this handler..",
	"Method": "URL getCallInfoURL(){\r\n    return callInfoURL;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.OperationSetPersistentPresenceIrcImpl.unsubscribe",
	"Comment": "unsubscribe for presence change events for specified contact.",
	"Method": "void unsubscribe(Contact contact){\r\n    if (!(contact instanceof ContactIrcImpl)) {\r\n        throw new IllegalArgumentException(\"contact must be instance of ContactIrcImpl\");\r\n    }\r\n    final ContactIrcImpl ircContact = (ContactIrcImpl) contact;\r\n    final ContactGroupIrcImpl parentGroup = (ContactGroupIrcImpl) ircContact.getParentContactGroup();\r\n    try {\r\n        final IrcConnection connection = this.parentProvider.getIrcStack().getConnection();\r\n        if (connection != null) {\r\n            connection.getPresenceManager().removeNickWatch(contact.getAddress());\r\n        }\r\n        parentGroup.removeContact(ircContact);\r\n        fireSubscriptionEvent(ircContact, parentGroup, SubscriptionEvent.SUBSCRIPTION_REMOVED);\r\n    } catch (RuntimeException e) {\r\n        LOGGER.debug(\"Failed to unsubscribe from contact.\", e);\r\n        fireSubscriptionEvent(ircContact, parentGroup, SubscriptionEvent.SUBSCRIPTION_FAILED);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.OperationSetPersistentPresenceGibberishImpl.addGibberishGroupAndFireEvent",
	"Comment": "a gibberish provider method to use for fast filling of a contact list.this method would add both the group and fire an event.",
	"Method": "void addGibberishGroupAndFireEvent(ContactGroupGibberishImpl parent,ContactGroupGibberishImpl contactGroup){\r\n    parent.addSubgroup(contactGroup);\r\n    this.fireServerStoredGroupEvent(contactGroup, ServerStoredGroupEvent.GROUP_CREATED_EVENT);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ProtocolProviderServiceJabberImpl.loadProxy",
	"Comment": "sets the global proxy information based on the configuration",
	"Method": "void loadProxy(){\r\n    String globalProxyType = JabberActivator.getConfigurationService().getString(ProxyInfo.CONNECTION_PROXY_TYPE_PROPERTY_NAME);\r\n    if (globalProxyType == null || globalProxyType.equals(ProxyInfo.ProxyType.NONE.name())) {\r\n        proxy = org.jivesoftware.smack.proxy.ProxyInfo.forNoProxy();\r\n    } else {\r\n        String globalProxyAddress = JabberActivator.getConfigurationService().getString(ProxyInfo.CONNECTION_PROXY_ADDRESS_PROPERTY_NAME);\r\n        String globalProxyPortStr = JabberActivator.getConfigurationService().getString(ProxyInfo.CONNECTION_PROXY_PORT_PROPERTY_NAME);\r\n        int globalProxyPort;\r\n        try {\r\n            globalProxyPort = Integer.parseInt(globalProxyPortStr);\r\n        } catch (NumberFormatException ex) {\r\n            throw new OperationFailedException(\"Wrong proxy port, \" + globalProxyPortStr + \" does not represent an integer\", OperationFailedException.INVALID_ACCOUNT_PROPERTIES, ex);\r\n        }\r\n        String globalProxyUsername = JabberActivator.getConfigurationService().getString(ProxyInfo.CONNECTION_PROXY_USERNAME_PROPERTY_NAME);\r\n        String globalProxyPassword = JabberActivator.getConfigurationService().getString(ProxyInfo.CONNECTION_PROXY_PASSWORD_PROPERTY_NAME);\r\n        if (globalProxyAddress == null || globalProxyAddress.length() <= 0) {\r\n            throw new OperationFailedException(\"Missing Proxy Address\", OperationFailedException.INVALID_ACCOUNT_PROPERTIES);\r\n        }\r\n        try {\r\n            proxy = new org.jivesoftware.smack.proxy.ProxyInfo(Enum.valueOf(org.jivesoftware.smack.proxy.ProxyInfo.ProxyType.class, globalProxyType), globalProxyAddress, globalProxyPort, globalProxyUsername, globalProxyPassword);\r\n        } catch (IllegalArgumentException e) {\r\n            logger.error(\"Invalid value for smack proxy enum\", e);\r\n            proxy = null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetPresenceSipImpl.publishPresenceStatus",
	"Comment": "requests the provider to enter into a status corresponding to thespecified parameters.",
	"Method": "void publishPresenceStatus(PresenceStatus status,String statusMsg){\r\n    PresenceStatus oldStatus = this.presenceStatus;\r\n    this.presenceStatus = status;\r\n    String oldMessage = this.statusMessage;\r\n    this.statusMessage = statusMsg;\r\n    if (this.presenceEnabled == false || parentProvider.getRegistrarConnection() instanceof SipRegistrarlessConnection) {\r\n        this.fireProviderStatusChangeEvent(oldStatus);\r\n        this.fireProviderMsgStatusChangeEvent(oldMessage);\r\n        return;\r\n    }\r\n    if (!status.equals(sipStatusEnum.getStatus(SipStatusEnum.OFFLINE)))\r\n        assertConnected();\r\n    if (this.useDistantPA) {\r\n        Request req = null;\r\n        if (status.equals(sipStatusEnum.getStatus(SipStatusEnum.OFFLINE))) {\r\n            req = createPublish(0, false);\r\n            synchronized (this.waitedCallIds) {\r\n                this.waitedCallIds.add(((CallIdHeader) req.getHeader(CallIdHeader.NAME)).getCallId());\r\n            }\r\n        } else {\r\n            req = createPublish(this.subscriptionDuration, true);\r\n        }\r\n        ClientTransaction transac = null;\r\n        try {\r\n            transac = this.parentProvider.getDefaultJainSipProvider().getNewClientTransaction(req);\r\n        } catch (TransactionUnavailableException e) {\r\n            logger.error(\"can't create the client transaction\", e);\r\n            throw new OperationFailedException(\"can't create the client transaction\", OperationFailedException.NETWORK_FAILURE);\r\n        }\r\n        try {\r\n            transac.sendRequest();\r\n        } catch (SipException e) {\r\n            logger.error(\"can't send the PUBLISH request\", e);\r\n            throw new OperationFailedException(\"can't send the PUBLISH request\", OperationFailedException.NETWORK_FAILURE);\r\n        }\r\n    } else {\r\n        String subscriptionState;\r\n        String reason;\r\n        if (status.equals(sipStatusEnum.getStatus(SipStatusEnum.OFFLINE))) {\r\n            subscriptionState = SubscriptionStateHeader.TERMINATED;\r\n            reason = SubscriptionStateHeader.PROBATION;\r\n        } else {\r\n            subscriptionState = SubscriptionStateHeader.ACTIVE;\r\n            reason = null;\r\n        }\r\n        notifier.notifyAll(subscriptionState, reason);\r\n    }\r\n    if (status.equals(sipStatusEnum.getStatus(SipStatusEnum.OFFLINE))) {\r\n        unsubscribeToAllEventSubscribers();\r\n        unsubscribeToAllContact();\r\n    }\r\n    this.fireProviderStatusChangeEvent(oldStatus);\r\n    this.fireProviderMsgStatusChangeEvent(oldMessage);\r\n}"
}, {
	"Path": "net.librec.eval.ranking.RecallEvaluator.evaluate",
	"Comment": "evaluate on the test set with the the list of recommended items.",
	"Method": "double evaluate(RecommendedList groundTruthList,RecommendedList recommendedList){\r\n    double totalRecall = 0.0;\r\n    int numContext = groundTruthList.size();\r\n    int nonZeroContext = 0;\r\n    for (int contextIdx = 0; contextIdx < numContext; ++contextIdx) {\r\n        Set<Integer> testSetByContext = groundTruthList.getKeySetByContext(contextIdx);\r\n        if (testSetByContext.size() > 0) {\r\n            List<KeyValue<Integer, Double>> recommendListByContext = recommendedList.getKeyValueListByContext(contextIdx);\r\n            int numHits = 0;\r\n            int topK = this.topN <= recommendListByContext.size() ? this.topN : recommendListByContext.size();\r\n            for (int indexOfKey = 0; indexOfKey < topK; indexOfKey++) {\r\n                int key = recommendListByContext.get(indexOfKey).getKey();\r\n                if (testSetByContext.contains(key)) {\r\n                    numHits++;\r\n                }\r\n            }\r\n            totalRecall += numHits / (testSetByContext.size() + 0.0);\r\n            nonZeroContext++;\r\n        }\r\n    }\r\n    return nonZeroContext > 0 ? totalRecall / nonZeroContext : 0.0d;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SipCommFileDialogImpl.setStartPath",
	"Comment": "sets the default path to be considered for browsing among files.",
	"Method": "void setStartPath(String path){\r\n    if (path == null)\r\n        return;\r\n    try {\r\n        URL url = new URL(path);\r\n        path = url.getPath();\r\n    } catch (MalformedURLException e) {\r\n    }\r\n    File file = new File(path);\r\n    if ((file != null) && !file.isDirectory()) {\r\n        setDirectory(file.getParent());\r\n        setFile(file.getName());\r\n    } else {\r\n        setDirectory(path);\r\n        setFile(null);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.TransportManager.createStreamConnector",
	"Comment": "creates a media streamconnector for a stream of a specificmediatype. the minimum and maximum of the media port boundariesare taken into account.",
	"Method": "StreamConnector createStreamConnector(MediaType mediaType){\r\n    NetworkAddressManagerService nam = ProtocolMediaActivator.getNetworkAddressManagerService();\r\n    InetAddress intendedDestination = getIntendedDestination(getCallPeer());\r\n    InetAddress localHostForPeer = nam.getLocalHost(intendedDestination);\r\n    PortTracker portTracker = getPortTracker(mediaType);\r\n    DatagramSocket rtpSocket = null;\r\n    try {\r\n        rtpSocket = nam.createDatagramSocket(localHostForPeer, portTracker.getPort(), portTracker.getMinPort(), portTracker.getMaxPort());\r\n    } catch (Exception exc) {\r\n        throw new OperationFailedException(\"Failed to allocate the network ports necessary for the call.\", OperationFailedException.INTERNAL_ERROR, exc);\r\n    }\r\n    portTracker.setNextPort(rtpSocket.getLocalPort() + 1, false);\r\n    DatagramSocket rtcpSocket = null;\r\n    try {\r\n        rtcpSocket = nam.createDatagramSocket(localHostForPeer, portTracker.getPort(), portTracker.getMinPort(), portTracker.getMaxPort());\r\n    } catch (Exception exc) {\r\n        throw new OperationFailedException(\"Failed to allocate the network ports necessary for the call.\", OperationFailedException.INTERNAL_ERROR, exc);\r\n    }\r\n    portTracker.setNextPort(rtcpSocket.getLocalPort() + 1);\r\n    return new DefaultStreamConnector(rtpSocket, rtcpSocket);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.IcqTesterAgent.addConversationListener",
	"Comment": "registers listener as an imconversationlistener so that it wouldreceive messages coming from buddy.",
	"Method": "void addConversationListener(String buddy,ConversationListener listener){\r\n    conn.getIcbmService().getImConversation(new Screenname(buddy)).addConversationListener(listener);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.WhiteboardSessionJabberImpl.findWhiteboardParticipantFromContactAddress",
	"Comment": "searches all participants contained in this white board and returns theone that corresponds to the given contact address.",
	"Method": "WhiteboardParticipant findWhiteboardParticipantFromContactAddress(String contactAddress){\r\n    for (WhiteboardParticipant participant : wbParticipants.values()) if (participant.getContactAddress().equals(contactAddress))\r\n        return participant;\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.contactlist.TestMetaContactList.testCreateMoveRemoveMetaContact",
	"Comment": "tests methods for creating moving and removing meta contacts.",
	"Method": "void testCreateMoveRemoveMetaContact(){\r\n    String newContactID = \"testCreateMoveRemoveMetaContact.ContactID\";\r\n    MetaContactGroup parentMetaGroup = fixture.metaClService.getRoot().getMetaContactSubgroup(MetaContactListServiceLick.topLevelGroupName);\r\n    MclEventCollector evtCollector = new MclEventCollector();\r\n    fixture.metaClService.addMetaContactListListener(evtCollector);\r\n    fixture.metaClService.createMetaContact(MclSlickFixture.mockProvider, parentMetaGroup, newContactID);\r\n    fixture.metaClService.removeMetaContactListListener(evtCollector);\r\n    MetaContact newMetaContact = parentMetaGroup.getMetaContact(MclSlickFixture.mockProvider, newContactID);\r\n    assertNotNull(\"create failed. couldn't find the new contact.\", newMetaContact);\r\n    assertEquals(\"create() created a meta contact with the wrong name.\", newContactID, newMetaContact.getDisplayName());\r\n    assertEquals(\"Events delivered while creating a new meta contact\", 1, evtCollector.collectedMetaContactEvents.size());\r\n    MetaContactEvent event = (MetaContactEvent) evtCollector.collectedMetaContactEvents.remove(0);\r\n    assertSame(\"Source contact in MetaContactEvent gen. upon create.\", newMetaContact, event.getSourceMetaContact());\r\n    assertEquals(\"Event ID in MetaContactEvent gen. upon create.\", MetaContactEvent.META_CONTACT_ADDED, event.getEventID());\r\n    fixture.metaClService.addMetaContactListListener(evtCollector);\r\n    fixture.metaClService.moveMetaContact(newMetaContact, fixture.metaClService.getRoot());\r\n    fixture.metaClService.removeMetaContactListListener(evtCollector);\r\n    assertNull(newMetaContact.getDisplayName() + \" was still in its old location after moving it.\", parentMetaGroup.getMetaContact(newMetaContact.getMetaUID()));\r\n    assertNotNull(newMetaContact.getDisplayName() + \" was not in the new location after moving it.\", fixture.metaClService.getRoot().getMetaContact(newMetaContact.getMetaUID()));\r\n    assertNull(\"The mock contact corresponding to: \" + newMetaContact.getDisplayName() + \" was still in its old location after its \" + \"encapsulating meta contact was moved\", MetaContactListServiceLick.topLevelMockGroup.getContact(newContactID));\r\n    assertNotNull(\"The mock contact corresponding to: \" + newMetaContact.getDisplayName() + \" was not moved to its new location after its \" + \"encapsulating meta contact was.\", MclSlickFixture.mockPresOpSet.getServerStoredContactListRoot().getContact(newContactID));\r\n    assertEquals(\"Events delivered while moving a meta contact\", 1, evtCollector.collectedMetaContactEvents.size());\r\n    MetaContactMovedEvent movedEvent = (MetaContactMovedEvent) evtCollector.collectedMetaContactEvents.remove(0);\r\n    assertSame(\"Source contact in MetaContactEvent gen. upon move.\", newMetaContact, movedEvent.getSourceMetaContact());\r\n    assertEquals(\"Event Property Name in MetaContactEvent gen. upon move.\", MetaContactPropertyChangeEvent.META_CONTACT_MOVED, movedEvent.getPropertyName());\r\n    assertEquals(\"Old Parent in MetaContactEvent gen. upon move.\", parentMetaGroup, movedEvent.getOldParent());\r\n    assertEquals(\"Old Parent in MetaContactEvent gen. upon move.\", fixture.metaClService.getRoot(), movedEvent.getNewParent());\r\n    fixture.metaClService.addMetaContactListListener(evtCollector);\r\n    fixture.metaClService.removeMetaContact(newMetaContact);\r\n    fixture.metaClService.removeMetaContactListListener(evtCollector);\r\n    assertNull(newMetaContact.getDisplayName() + \" was still in its old location after it was removed.\", fixture.metaClService.getRoot().getMetaContact(newMetaContact.getMetaUID()));\r\n    assertNull(\"The mock contact corresponding to: \" + newMetaContact.getDisplayName() + \" was not removed after its encapsulating meta contact was.\", MclSlickFixture.mockPresOpSet.getServerStoredContactListRoot().getContact(newContactID));\r\n    assertEquals(\"Events delivered while removing a meta contact\", 1, evtCollector.collectedMetaContactEvents.size());\r\n    event = (MetaContactEvent) evtCollector.collectedMetaContactEvents.remove(0);\r\n    assertSame(\"Source contact in MetaContactEvent gen. upon remove.\", newMetaContact, event.getSourceMetaContact());\r\n    assertEquals(\"Event ID in MetaContactEvent gen. upon remove.\", MetaContactEvent.META_CONTACT_REMOVED, event.getEventID());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ContactGroupSipImpl.contacts",
	"Comment": "returns an iterator over all contacts, member of thiscontactgroup.",
	"Method": "Iterator<Contact> contacts(){\r\n    return contacts.iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.MasterPasswordInputDialog.showInput",
	"Comment": "shows an input dialog to the user to obtain the master password.",
	"Method": "String showInput(boolean prevSuccess){\r\n    try {\r\n        if (!SwingUtilities.isEventDispatchThread()) {\r\n            SwingUtilities.invokeAndWait(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    showInput(prevSuccess);\r\n                }\r\n            });\r\n        } else {\r\n            if (dialog == null)\r\n                dialog = new MasterPasswordInputDialog();\r\n            dialog.rebuildMainPanel(!prevSuccess);\r\n            dialog.resetPassword();\r\n            dialog.setVisible(true);\r\n        }\r\n    } catch (Throwable t) {\r\n        logger.error(\"Error showing dialog\", t);\r\n    }\r\n    return dialog.password;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.MasterPasswordInputDialog.showInput",
	"Comment": "shows an input dialog to the user to obtain the master password.",
	"Method": "String showInput(boolean prevSuccess){\r\n    showInput(prevSuccess);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.AccountPanel.isCreateAccount",
	"Comment": "indicates if the account information provided by this form is for newaccount or an existing one.",
	"Method": "boolean isCreateAccount(){\r\n    return createAccountButton.isSelected();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockMultiUserChat.rejectInvitation",
	"Comment": "informs the sender of an invitation that we decline their invitation.",
	"Method": "void rejectInvitation(ChatRoomInvitation invitation,String reason){\r\n    fireInvitationRejectedEvent(invitation.getTargetChatRoom(), provider.getAccountID().getUserID(), invitation.getReason());\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.notificationconfiguration.NotificationEntry.getSoundPCSpeaker",
	"Comment": "method which returns if one sound is to be played on pc speaker device.",
	"Method": "boolean getSoundPCSpeaker(){\r\n    return this.soundPCSpeaker;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.CallPeerJabberImpl.getSenders",
	"Comment": "gets the current value of the senders field of the content withname mediatype in the jingle session with thiscallpeer.",
	"Method": "SendersEnum getSenders(MediaType mediaType){\r\n    switch(mediaType) {\r\n        case AUDIO:\r\n            return audioSenders;\r\n        case VIDEO:\r\n            return videoSenders;\r\n        default:\r\n            return SendersEnum.none;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.WhiteboardParticipantJabberImpl.getDisplayName",
	"Comment": "returns a human readable name representing this participant.",
	"Method": "String getDisplayName(){\r\n    String displayName = participant.getDisplayName();\r\n    return (displayName == null) ? \"\" : displayName;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.ChatRoomQuery.contactEqualsChatRoom",
	"Comment": "test equality of contact to chat room wrapper. this method does not relyon a chat room instance, since that may not be available in case ofremoval.",
	"Method": "boolean contactEqualsChatRoom(ChatRoomSourceContact contact,ChatRoom chatRoom,boolean contactEqualsChatRoom,ChatRoomSourceContact contact,ChatRoomWrapper chatRoomWrapper){\r\n    return contact.getProvider() == chatRoomWrapper.getParentProvider().getProtocolProvider() && contact.getContactAddress().equals(chatRoomWrapper.getChatRoomID());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetPresenceSipImpl.addServerStoredGroupChangeListener",
	"Comment": "registers a listener that would receive events upong changes in serverstored groups.",
	"Method": "void addServerStoredGroupChangeListener(ServerStoredGroupListener listener){\r\n    ssContactList.addGroupListener(listener);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetMessageWaitingSipImpl.addMessageWaitingNotificationListener",
	"Comment": "registers a messagewaitinglistener with thisoperation set so that it gets notifications of new and oldmessages waiting.",
	"Method": "void addMessageWaitingNotificationListener(MessageType type,MessageWaitingListener listener){\r\n    synchronized (messageWaitingNotificationListeners) {\r\n        List<MessageWaitingListener> l = this.messageWaitingNotificationListeners.get(type);\r\n        if (l == null) {\r\n            l = new ArrayList<MessageWaitingListener>();\r\n            this.messageWaitingNotificationListeners.put(type, l);\r\n        }\r\n        if (!l.contains(listener))\r\n            l.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.osdependent.PopupMessageHandlerTrayIconImpl.getPreferenceIndex",
	"Comment": "implements getpreferenceindex from popupmessagehandler.this handler is able to detect clicks, thus the index is 1.",
	"Method": "int getPreferenceIndex(){\r\n    return 1;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.chat.ChatRoomJoinOptionsDialog.getJoinOptions",
	"Comment": "opens a dialog with a fields for the nickname and the subject of the roomand returns them.",
	"Method": "String[] getJoinOptions(ProtocolProviderService pps,String chatRoomId,String defaultNickname,String[] getJoinOptions,boolean dontDisplaySubjectFields,ProtocolProviderService pps,String chatRoomId,String defaultNickname){\r\n    String nickName = null;\r\n    ChatRoomJoinOptionsDialog reasonDialog = new ChatRoomJoinOptionsDialog(DesktopUtilActivator.getResources().getI18NString(\"service.gui.CHANGE_NICKNAME\"), DesktopUtilActivator.getResources().getI18NString(\"service.gui.CHANGE_NICKNAME_LABEL\"), false, true, dontDisplaySubjectFields);\r\n    reasonDialog.setIcon(new ImageIcon(DesktopUtilActivator.getImage(\"service.gui.icons.CHANGE_NICKNAME_16x16\")));\r\n    if (defaultNickname != null)\r\n        reasonDialog.setReasonFieldText(defaultNickname);\r\n    int result = reasonDialog.showDialog();\r\n    if (result == MessageDialog.OK_RETURN_CODE) {\r\n        nickName = reasonDialog.getReason().trim();\r\n        ConfigurationUtils.updateChatRoomProperty(pps, chatRoomId, \"userNickName\", nickName);\r\n    }\r\n    String[] joinOptions = { nickName, reasonDialog.getSubject() };\r\n    return joinOptions;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ServerStoredContactListIcqImpl.findContactGroup",
	"Comment": "returns the contactgroup containing the specified contact or nullif no such group or contact exist.",
	"Method": "ContactGroupIcqImpl findContactGroup(String name,ContactGroupIcqImpl findContactGroup,Group joustSimGroup,ContactGroupIcqImpl findContactGroup,ContactIcqImpl child){\r\n    Iterator<ContactGroup> contactGroups = rootGroup.subgroups();\r\n    while (contactGroups.hasNext()) {\r\n        ContactGroupIcqImpl contactGroup = (ContactGroupIcqImpl) contactGroups.next();\r\n        if (contactGroup.findContact(child.getJoustSimBuddy()) != null)\r\n            return contactGroup;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.CallChangeEvent.getCause",
	"Comment": "the event which was the cause for current event, like last peerremoved from call will hangup current call, if any, otherwise is null.",
	"Method": "CallPeerChangeEvent getCause(){\r\n    return cause;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.MessageReceivedEvent.getTimestamp",
	"Comment": "a timestamp indicating the exact date when the event occurred.",
	"Method": "Date getTimestamp(){\r\n    return timestamp;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.PayloadTypePacketExtension.getClockrate",
	"Comment": "returns the sampling frequency in hertz used by this encoding.",
	"Method": "int getClockrate(){\r\n    return getAttributeAsInt(CLOCKRATE_ATTR_NAME);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ServerStoredContactListSipImpl.removeGroup",
	"Comment": "removes the specified group from the server stored contact list.",
	"Method": "void removeGroup(ContactGroupSipImpl group){\r\n    if (group == null) {\r\n        throw new IllegalArgumentException(\"Removing group cannot be null\");\r\n    }\r\n    if (rootGroup.equals(group)) {\r\n        throw new IllegalArgumentException(\"Root group cannot be deleted\");\r\n    }\r\n    if (logger.isTraceEnabled()) {\r\n        logger.trace(\"removeGroup \" + group.getGroupName());\r\n    }\r\n    ContactGroupSipImpl parentGroup = (ContactGroupSipImpl) group.getParentContactGroup();\r\n    parentGroup.removeSubGroup(group);\r\n    if (group.isPersistent()) {\r\n        try {\r\n            updateResourceLists();\r\n            Iterator<Contact> iter = group.contacts();\r\n            boolean updateRules = false;\r\n            while (iter.hasNext()) {\r\n                ContactSipImpl c = (ContactSipImpl) iter.next();\r\n                updateRules = removeContactFromWhiteList(c) || updateRules;\r\n                updateRules = removeContactFromBlockList(c) || updateRules;\r\n                updateRules = removeContactFromPoliteBlockList(c) || updateRules;\r\n            }\r\n            if (updateRules)\r\n                updatePresRules();\r\n        } catch (XCapException e) {\r\n            parentGroup.addSubgroup(group);\r\n            throw new IllegalStateException(\"Error while removing XCAP group\", e);\r\n        }\r\n    }\r\n    fireGroupEvent(group, ServerStoredGroupEvent.GROUP_REMOVED_EVENT);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.MetaUIContact.getDisplayDetails",
	"Comment": "returns the display details for the underlying metacontact.",
	"Method": "String getDisplayDetails(){\r\n    String displayDetails = null;\r\n    Iterator<Contact> protoContacts = metaContact.getContacts();\r\n    String subscriptionDetails = null;\r\n    while (protoContacts.hasNext()) {\r\n        Contact protoContact = protoContacts.next();\r\n        OperationSetExtendedAuthorizations authOpSet = protoContact.getProtocolProvider().getOperationSet(OperationSetExtendedAuthorizations.class);\r\n        if (authOpSet != null && authOpSet.getSubscriptionStatus(protoContact) != null && !authOpSet.getSubscriptionStatus(protoContact).equals(SubscriptionStatus.Subscribed)) {\r\n            SubscriptionStatus status = authOpSet.getSubscriptionStatus(protoContact);\r\n            if (status.equals(SubscriptionStatus.SubscriptionPending))\r\n                subscriptionDetails = GuiActivator.getResources().getI18NString(\"service.gui.WAITING_AUTHORIZATION\");\r\n            else if (status.equals(SubscriptionStatus.NotSubscribed))\r\n                subscriptionDetails = GuiActivator.getResources().getI18NString(\"service.gui.NOT_AUTHORIZED\");\r\n        } else if (protoContact.getStatusMessage() != null && protoContact.getStatusMessage().length() > 0) {\r\n            subscribed = true;\r\n            displayDetails = protoContact.getStatusMessage();\r\n            break;\r\n        } else {\r\n            subscribed = true;\r\n        }\r\n    }\r\n    if ((displayDetails == null || displayDetails.length() <= 0) && !subscribed && subscriptionDetails != null && subscriptionDetails.length() > 0)\r\n        displayDetails = subscriptionDetails;\r\n    return displayDetails;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ContactIcqImpl.isLocal",
	"Comment": "determines whether or not this contact instance represents the user usedby this protocol provider to connect to the service.",
	"Method": "boolean isLocal(){\r\n    return isLocal;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.sipaccregwizz.SIPAccRegWizzActivator.getBrowserLauncher",
	"Comment": "returns the browserlauncherservice obtained from the bundlecontext.",
	"Method": "BrowserLauncherService getBrowserLauncher(){\r\n    if (browserLauncherService == null) {\r\n        ServiceReference serviceReference = bundleContext.getServiceReference(BrowserLauncherService.class.getName());\r\n        browserLauncherService = (BrowserLauncherService) bundleContext.getService(serviceReference);\r\n    }\r\n    return browserLauncherService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.sipaccregwizz.SIPAccountRegistrationWizard.getCreateAccountService",
	"Comment": "returns an instance of createaccountservice through which theuser could create an account. this method is meant to be implemented byspecific protocol provider wizards.",
	"Method": "SIPAccountCreationFormService getCreateAccountService(){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.JabberAccountRegistrationWizard.loadAccount",
	"Comment": "fills the user id and password fields in this panel with the data comingfrom the given protocolprovider.",
	"Method": "void loadAccount(ProtocolProviderService protocolProvider){\r\n    setModification(true);\r\n    this.protocolProvider = protocolProvider;\r\n    this.registration = new JabberAccountRegistration();\r\n    this.firstWizardPage.loadAccount(protocolProvider);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.busylampfield.BLFActivator.blfStatusChanged",
	"Comment": "called whenever a change occurs in the blfstatus of one of themonitored lines that we have subscribed for.",
	"Method": "void blfStatusChanged(BLFStatusEvent event){\r\n    if (!(event.getSource() instanceof OperationSetTelephonyBLF.Line))\r\n        return;\r\n    OperationSetTelephonyBLF.Line line = (OperationSetTelephonyBLF.Line) event.getSource();\r\n    String gr = line.getGroup();\r\n    if (gr == null)\r\n        gr = BLF_DEFAULT_GROUP_NAME;\r\n    ServiceRegistration<ContactSourceService> serviceReg = currentBLFGroups.get(gr);\r\n    if (serviceReg == null)\r\n        return;\r\n    BLFContactSourceService css = (BLFContactSourceService) bundleContext.getService(serviceReg.getReference());\r\n    css.updateLineStatus(line, event.getType());\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.spellcheck.SpellChecker.removeLocale",
	"Comment": "removes the dictionary from the system, and sets the default localedictionary as the current dictionary",
	"Method": "void removeLocale(Parameters.Locale locale){\r\n    synchronized (this.locale) {\r\n        String path = locale.getDictUrl().getFile();\r\n        int filenameStart = path.lastIndexOf('/') + 1;\r\n        String filename = path.substring(filenameStart);\r\n        File dictLocation = SpellCheckActivator.getFileAccessService().getPrivatePersistentFile(DICT_DIR + filename, FileCategory.CACHE);\r\n        if (dictLocation.exists())\r\n            dictLocation.delete();\r\n        String localeIso = Parameters.getDefault(Parameters.Default.LOCALE);\r\n        Parameters.Locale loc = Parameters.getLocale(localeIso);\r\n        setLocale(loc);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetMultiUserChatJabberImpl.addSmackInvitationRejectionListener",
	"Comment": "add smackinvitationrejectionlistener to multiuserchat instancewhich will dispatch all rejection events.",
	"Method": "void addSmackInvitationRejectionListener(MultiUserChat muc,ChatRoom chatRoom){\r\n    muc.addInvitationRejectionListener(new SmackInvitationRejectionListener(chatRoom));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ContactGroupIcqImpl.findContact",
	"Comment": "returns the icq contact encapsulating with the specified screen name ornull if no such contact was found.",
	"Method": "ContactIcqImpl findContact(Buddy joustSimBuddy,ContactIcqImpl findContact,String screenName){\r\n    if (screenName == null)\r\n        return null;\r\n    String lcScreenName = screenName.toLowerCase();\r\n    return (ContactIcqImpl) buddies.get(lcScreenName);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractOperationSetTypingNotifications.fireTypingNotificationsDeliveryFailedEvent",
	"Comment": "delivers a typingnotificationevent to all registered listenersfor delivery failed event.",
	"Method": "void fireTypingNotificationsDeliveryFailedEvent(Contact sourceContact,int evtCode){\r\n    TypingNotificationsListener[] listeners;\r\n    synchronized (typingNotificationsListeners) {\r\n        listeners = typingNotificationsListeners.toArray(new TypingNotificationsListener[typingNotificationsListeners.size()]);\r\n    }\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Dispatching a TypingNotificationEvent to \" + listeners.length + \" listeners for typingNotificationDeliveryFailed. Contact \" + sourceContact.getAddress() + \" has now a typing status of \" + evtCode);\r\n    TypingNotificationEvent evt = new TypingNotificationEvent(sourceContact, evtCode);\r\n    for (TypingNotificationsListener listener : listeners) listener.typingNotificationDeliveryFailed(evt);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.JingleNodesHarvester.createJingleNodesCandidate",
	"Comment": "creates a new jinglenodesrelayedcandidate instance which is torepresent a specific transportaddress.",
	"Method": "JingleNodesCandidate createJingleNodesCandidate(TransportAddress transportAddress,Component component,TransportAddress localEndPoint){\r\n    JingleNodesCandidate cand = null;\r\n    try {\r\n        cand = new JingleNodesCandidate(transportAddress, component, localEndPoint);\r\n        IceSocketWrapper stunSocket = cand.getStunSocket(null);\r\n        cand.getStunStack().addSocket(stunSocket);\r\n        component.getComponentSocket().add(cand.getCandidateIceSocketWrapper());\r\n    } catch (Throwable e) {\r\n        logger.debug(\"Exception occurred when creating JingleNodesCandidate: \" + e);\r\n    }\r\n    return cand;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapDirectoryImpl.isEnabled",
	"Comment": "returns the state of the enabled marker.required by ldapdirectory interface.",
	"Method": "boolean isEnabled(){\r\n    return this.settings.isEnabled();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.sdp.SdpUtils.extractRTPExtensions",
	"Comment": "extracts and returns the list of rtpextensions advertised inmediadesc and registers newly encountered ones into thespecified extmap. the method returns an empty list in case therewere no extmap advertisements in mediadesc.",
	"Method": "List<RTPExtension> extractRTPExtensions(MediaDescription mediaDesc,DynamicRTPExtensionsRegistry extMap){\r\n    List<RTPExtension> extensionsList = new ArrayList<RTPExtension>();\r\n    Vector<Attribute> mediaAttributes = mediaDesc.getAttributes(false);\r\n    if (mediaAttributes == null || mediaAttributes.size() == 0)\r\n        return null;\r\n    for (Attribute attr : mediaAttributes) {\r\n        String attrValue;\r\n        try {\r\n            if (!EXTMAP_ATTR.equals(attr.getName()))\r\n                continue;\r\n            attrValue = attr.getValue();\r\n        } catch (SdpException e) {\r\n            if (logger.isDebugEnabled())\r\n                logger.debug(\"A funny thing just happened ...\", e);\r\n            continue;\r\n        }\r\n        if (attrValue == null)\r\n            continue;\r\n        attrValue = attrValue.trim();\r\n        RTPExtension rtpExtension = parseRTPExtensionAttribute(attrValue, extMap);\r\n        if (rtpExtension != null)\r\n            extensionsList.add(rtpExtension);\r\n    }\r\n    return extensionsList;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactListServiceImpl.addContactToEventIgnoreList",
	"Comment": "registers contact to the event ignore list. this would make themethod that is normally handling events for newly created contacts ignoreany events for that particular contact and leave the responsibility tothe method that added the contact to the ignore list.",
	"Method": "void addContactToEventIgnoreList(String contact,ProtocolProviderService ownerProvider){\r\n    if (isContactInEventIgnoreList(contact, ownerProvider)) {\r\n        return;\r\n    }\r\n    List<ProtocolProviderService> existingProvList = this.contactEventIgnoreList.get(contact);\r\n    if (existingProvList == null) {\r\n        existingProvList = new LinkedList<ProtocolProviderService>();\r\n    }\r\n    existingProvList.add(ownerProvider);\r\n    contactEventIgnoreList.put(contact, existingProvList);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageHistoryServiceImpl.getHistory",
	"Comment": "returns the history by specified local and remote contactif one of them is null the default is used",
	"Method": "History getHistory(Contact localContact,Contact remoteContact){\r\n    String localId = localContact == null ? \"default\" : localContact.getAddress();\r\n    String remoteId = remoteContact == null ? \"default\" : remoteContact.getAddress();\r\n    String account = \"unkown\";\r\n    if (remoteContact != null)\r\n        account = remoteContact.getProtocolProvider().getAccountID().getAccountUniqueID();\r\n    HistoryID historyId = HistoryID.createFromRawID(new String[] { \"messages\", localId, account, remoteId });\r\n    if (!this.historyService.isHistoryCreated(historyId)) {\r\n        HistoryID historyId_old = HistoryID.createFromRawID(new String[] { \"messages\", localId, remoteId });\r\n        if (this.historyService.isHistoryCreated(historyId_old)) {\r\n            try {\r\n                this.historyService.moveHistory(historyId_old, historyId);\r\n            } catch (IOException iOException) {\r\n                historyId = historyId_old;\r\n            }\r\n        }\r\n    }\r\n    return this.historyService.createHistory(historyId, recordStructure);\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.ConfigurationUtils.getWindowTransparency",
	"Comment": "returns the transparency value for all transparent windows.",
	"Method": "int getWindowTransparency(){\r\n    return windowTransparency;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.GlobalStatusSelectorBox.addAvailableStatuses",
	"Comment": "adds the available global statuses. all the statuses except online andoffline, those that will be inserted between them.check first whether the statuses are not already inserted.",
	"Method": "void addAvailableStatuses(){\r\n    if (hasAvailableStatuses())\r\n        return;\r\n    int index = firstStatusIndex;\r\n    for (GlobalStatusEnum status : GlobalStatusEnum.globalStatusSet) {\r\n        if (status.equals(GlobalStatusEnum.OFFLINE) || status.equals(GlobalStatusEnum.ONLINE))\r\n            continue;\r\n        group.add(createMenuItem(status, index++));\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.ContactGibberishImpl.toString",
	"Comment": "returns a string representation of this contact, containing most of itsrepresentative details.",
	"Method": "String toString(){\r\n    StringBuffer buff = new StringBuffer(\"ContactGibberishImpl[ DisplayName=\").append(getDisplayName()).append(\"]\");\r\n    return buff.toString();\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.TestOperationSetMultiUserChat2.testInitialParticipantsRoles",
	"Comment": "tests participant roles when the room just has been created.the member who has created the room should have owner role.others participants who are invited to the room should be member.",
	"Method": "void testInitialParticipantsRoles(){\r\n    String roomName = testRoomBaseName + roomID;\r\n    logger.info(\"--- Start testInitialParticipantsRoles room:\" + roomName);\r\n    ChatRoom roomUser1 = opSetMUC1.createChatRoom(roomName, null);\r\n    roomUser1.join();\r\n    MUCEventCollector roomUser1Collector = new MUCEventCollector(roomUser1, MUCEventCollector.EVENT_PRESENCE);\r\n    roomUser1Collector.waitForEvent(10000);\r\n    assertEquals(\"Unexpected role for user1\", roomUser1.getUserRole(), ChatRoomMemberRole.OWNER);\r\n    assertEquals(\"Unexpected role for user1\", roomUser1.getUserRole(), getRole(fixture.userID1, roomUser1.getMembers(), roomUser1.getName(), true));\r\n    ChatRoom roomUser2 = opSetMUC2.findRoom(roomName);\r\n    assertNotNull(\"Room can't be retrieved on user2's side\", roomUser2);\r\n    roomUser2.join();\r\n    roomUser1Collector.waitForEvent(10000);\r\n    ChatRoom roomUser3 = opSetMUC3.findRoom(roomName);\r\n    assertNotNull(\"Room can't be retrieved on user3's side\", roomUser2);\r\n    roomUser3.join();\r\n    roomUser1Collector.waitForEvent(10000);\r\n    assertTrue(\"User2 not on member list after having join the room\", nameIsOnMemberList(fixture.userID2, roomUser1.getMembers()));\r\n    assertTrue(\"User3 not on member list after having join the room\", nameIsOnMemberList(fixture.userID3, roomUser1.getMembers()));\r\n    List<ChatRoomMember> members = roomUser1.getMembers();\r\n    assertEquals(\"Unexpected members count\", 3, members.size());\r\n    assertEquals(\"The current implementation requires that room's new \" + \"comers must have MEMBER role\", ChatRoomMemberRole.MEMBER, getRole(fixture.userID2, members, roomName, true));\r\n    assertEquals(\"The current implementation requires that room's new \" + \"comers must have the MEMBER role\", ChatRoomMemberRole.MEMBER, getRole(fixture.userID3, members, roomName, true));\r\n    logger.info(\"--- End testInitialParticipantsRoles room:\" + roomName);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.macosx.MacOSXAddrBookContactQuery.createContactDetail",
	"Comment": "initializes a new contactdetail instance which is to reperesenta specific contact address that is the value of a specificabperson property and, optionally, has a specific label.",
	"Method": "ContactDetail createContactDetail(int property,String contactAddress,Object label,String additionalProperty,String id){\r\n    Category c;\r\n    SubCategory sc = null;\r\n    switch(property) {\r\n        case kABEmailProperty:\r\n            c = Category.Email;\r\n            break;\r\n        case kABPhoneProperty:\r\n            c = Category.Phone;\r\n            break;\r\n        case kABAIMInstantProperty:\r\n            sc = SubCategory.AIM;\r\n            c = Category.InstantMessaging;\r\n            break;\r\n        case kABICQInstantProperty:\r\n            sc = SubCategory.ICQ;\r\n            c = Category.InstantMessaging;\r\n            break;\r\n        case kABJabberInstantProperty:\r\n            sc = SubCategory.Jabber;\r\n            c = Category.InstantMessaging;\r\n            break;\r\n        case kABMSNInstantProperty:\r\n            sc = SubCategory.Skype;\r\n            c = Category.InstantMessaging;\r\n            break;\r\n        case kABYahooInstantProperty:\r\n            sc = SubCategory.Yahoo;\r\n            c = Category.InstantMessaging;\r\n            break;\r\n        case kABMaidenNameProperty:\r\n        case kABFirstNameProperty:\r\n            sc = SubCategory.Name;\r\n            c = Category.Personal;\r\n            break;\r\n        case kABFirstNamePhoneticProperty:\r\n            sc = SubCategory.Name;\r\n            c = Category.Personal;\r\n            break;\r\n        case kABLastNameProperty:\r\n            sc = SubCategory.LastName;\r\n            c = Category.Personal;\r\n            break;\r\n        case kABLastNamePhoneticProperty:\r\n            sc = SubCategory.LastName;\r\n            c = Category.Personal;\r\n            break;\r\n        case kABMiddleNameProperty:\r\n        case kABMiddleNamePhoneticProperty:\r\n        case kABNicknameProperty:\r\n            sc = SubCategory.Nickname;\r\n            c = Category.Personal;\r\n            break;\r\n        case kABBirthdayProperty:\r\n        case kABURLsProperty:\r\n        case kABHomePageProperty:\r\n            sc = SubCategory.HomePage;\r\n            c = Category.Personal;\r\n            break;\r\n        case kABOtherDatesProperty:\r\n        case kABRelatedNamesProperty:\r\n        case kABNoteProperty:\r\n        case kABTitleProperty:\r\n        case kABSuffixProperty:\r\n            c = Category.Personal;\r\n            break;\r\n        case kABOrganizationProperty:\r\n        case kABJobTitleProperty:\r\n            sc = SubCategory.JobTitle;\r\n            c = Category.Organization;\r\n            break;\r\n        case kABDepartmentProperty:\r\n            c = Category.Organization;\r\n            sc = SubCategory.Name;\r\n            break;\r\n        case kABAddressProperty:\r\n            c = Category.Address;\r\n            break;\r\n        default:\r\n            c = null;\r\n            break;\r\n    }\r\n    if (sc == null) {\r\n        if (label == null)\r\n            sc = null;\r\n        else {\r\n            sc = getSubCategoryFromLabel(label);\r\n        }\r\n    }\r\n    SubCategory[] subCategories;\r\n    SubCategory additionalSubCategory = null;\r\n    if (additionalProperty != null)\r\n        additionalSubCategory = getSubCategoryFromLabel(additionalProperty);\r\n    if (additionalSubCategory != null)\r\n        subCategories = new SubCategory[] { sc, additionalSubCategory };\r\n    else\r\n        subCategories = new SubCategory[] { sc };\r\n    return new MacOSXAddrBookContactDetail(property, contactAddress, c, subCategories, additionalProperty, id);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetPersistentPresenceIcqImpl.createServerStoredContactGroup",
	"Comment": "creates a group with the specified name and parent in the server storedcontact list.",
	"Method": "void createServerStoredContactGroup(ContactGroup parent,String groupName){\r\n    assertConnected();\r\n    if (!parent.canContainSubgroups())\r\n        throw new IllegalArgumentException(\"The specified contact group cannot contain child groups. Group:\" + parent);\r\n    ssContactList.createGroup(groupName);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractFileTransfer.getStatus",
	"Comment": "returns the current status of the transfer. this information could beused from the user interface to show a progress bar indicating thefile transfer status.",
	"Method": "int getStatus(){\r\n    return status;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.launchutils.SipCommunicatorLock.writeLockFile",
	"Comment": "records our lockaddress into lockfile using thestandard properties format.",
	"Method": "int writeLockFile(File lockFile,InetSocketAddress lockAddress){\r\n    Properties lockProperties = new Properties();\r\n    lockProperties.setProperty(PNAME_LOCK_ADDRESS, lockAddress.getAddress().getHostAddress());\r\n    lockProperties.setProperty(PNAME_LOCK_PORT, Integer.toString(lockAddress.getPort()));\r\n    try {\r\n        lockProperties.store(new FileOutputStream(lockFile), \"Jitsi lock file. This file will be automatically removed\" + \" when execution of Jitsi terminates.\");\r\n    } catch (FileNotFoundException e) {\r\n        e.printStackTrace();\r\n    } catch (IOException e) {\r\n        logger.error(\"Failed to create lock file.\", e);\r\n        return LOCK_ERROR;\r\n    }\r\n    return SUCCESS;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.MetaContactChatTransport.checkImCaps",
	"Comment": "if sending im is supported check it for supporting html messagesif a font is set.as it can be slow make sure its not on our way",
	"Method": "void checkImCaps(){\r\n    if (ConfigurationUtils.getChatDefaultFontFamily() != null && ConfigurationUtils.getChatDefaultFontSize() > 0) {\r\n        OperationSetBasicInstantMessaging imOpSet = contact.getProtocolProvider().getOperationSet(OperationSetBasicInstantMessaging.class);\r\n        if (imOpSet != null)\r\n            imOpSet.isContentTypeSupported(OperationSetBasicInstantMessaging.HTML_MIME_TYPE, contact);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.DefaultTreeContactList.getToolTipText",
	"Comment": "gets the string to be used as the tool tip text for the mouselocation given by a specific mouseevent.defaulttreecontactlist only overrides in order to return adifferent string each time in order to maketooltipmanager change the tool tip over the different nodes ofthis jtree.",
	"Method": "String getToolTipText(MouseEvent event){\r\n    TreePath path = getClosestPathForLocation(event.getX(), event.getY());\r\n    if (path != null) {\r\n        Object element = path.getLastPathComponent();\r\n        String buttonString = \"\";\r\n        Component mouseComponent = findTreeCellComponent(event.getPoint());\r\n        if (mouseComponent instanceof SIPCommButton)\r\n            buttonString = Integer.toString(mouseComponent.hashCode());\r\n        String uniqueToolTipString = \"className= \" + element.getClass().getName() + \", hashCode= \" + element.hashCode() + \", toString= \" + element.toString();\r\n        return (buttonString.length() > 0) ? uniqueToolTipString + \", onButton=\" + buttonString : uniqueToolTipString;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractCallPeer.findConferenceMember",
	"Comment": "finds the first conferencemember whose audiossrc isequals to a specific value. the method is meant for very frequent use soit iterates over the list of conferencemembers withoutcreating an iterator.",
	"Method": "ConferenceMember findConferenceMember(long ssrc){\r\n    List<ConferenceMember> members = getConferenceMembers();\r\n    for (int i = 0, memberCount = members.size(); i < memberCount; i++) {\r\n        ConferenceMember member = members.get(i);\r\n        if (member.getAudioSsrc() == ssrc)\r\n            return member;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.librec.similarity.AbstractRecommenderSimilarity.getCorrelationIndependently",
	"Comment": "find the common rated items by this user and that user, or the commonusers have rated this item or that item. and then return the similarity.",
	"Method": "double getCorrelationIndependently(Configuration conf,SequentialSparseVector thisVector,SequentialSparseVector thatVector){\r\n    this.conf = conf;\r\n    return getCorrelation(thisVector, thatVector);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageHistoryServiceImpl.handleProviderRemoved",
	"Comment": "removes the specified provider from the list of currently known providersand ignores all the messages exchanged by it",
	"Method": "void handleProviderRemoved(ProtocolProviderService provider){\r\n    OperationSetBasicInstantMessaging opSetIm = provider.getOperationSet(OperationSetBasicInstantMessaging.class);\r\n    if (opSetIm != null) {\r\n        opSetIm.removeMessageListener(this);\r\n        if (this.messageSourceService != null)\r\n            opSetIm.removeMessageListener(messageSourceService);\r\n    }\r\n    OperationSetSmsMessaging opSetSMS = provider.getOperationSet(OperationSetSmsMessaging.class);\r\n    if (opSetSMS != null) {\r\n        opSetSMS.removeMessageListener(this);\r\n        if (this.messageSourceService != null)\r\n            opSetSMS.removeMessageListener(messageSourceService);\r\n    }\r\n    OperationSetMultiUserChat opSetMultiUChat = provider.getOperationSet(OperationSetMultiUserChat.class);\r\n    if (opSetMultiUChat != null) {\r\n        Iterator<ChatRoom> iter = opSetMultiUChat.getCurrentlyJoinedChatRooms().iterator();\r\n        while (iter.hasNext()) {\r\n            ChatRoom room = iter.next();\r\n            room.removeMessageListener(this);\r\n        }\r\n        opSetMultiUChat.removePresenceListener(this);\r\n        if (messageSourceService != null)\r\n            opSetMultiUChat.removePresenceListener(messageSourceService);\r\n    }\r\n    if (messageSourceService != null) {\r\n        OperationSetPresence opSetPresence = provider.getOperationSet(OperationSetPresence.class);\r\n        if (opSetPresence != null) {\r\n            opSetPresence.removeContactPresenceStatusListener(messageSourceService);\r\n            opSetPresence.removeProviderPresenceStatusListener(messageSourceService);\r\n            opSetPresence.removeSubscriptionListener(messageSourceService);\r\n        }\r\n        messageSourceService.handleProviderRemoved(provider);\r\n        OperationSetContactCapabilities capOpSet = provider.getOperationSet(OperationSetContactCapabilities.class);\r\n        if (capOpSet != null) {\r\n            capOpSet.removeContactCapabilitiesListener(messageSourceService);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.ChatRoomInvitationRejectedEvent.getReason",
	"Comment": "returns the reason for which the chatroominvitation is rejected.",
	"Method": "String getReason(){\r\n    return reason;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.addgroup.CreateGroupDialog.getNewMetaGroup",
	"Comment": "returns the newly created metacontactgroup if everything isgone well, otherwise returns null.",
	"Method": "MetaContactGroup getNewMetaGroup(){\r\n    return newMetaGroup;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.googletalkaccregwizz.GoogleTalkAccountRegistrationWizard.getCreateAccountService",
	"Comment": "returns an instance of createaccountservice through which theuser could create an account. this method is meant to be implemented byspecific protocol provider wizards.",
	"Method": "JabberAccountCreationFormService getCreateAccountService(){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageSourceContactQuery.fireContactChanged",
	"Comment": "notifies the contactquerylisteners registered with thiscontactquery that a sourcecontact has beenchanged.note that object may not be messagesourcecontact, but itsequals method can return true for message source contact instances.",
	"Method": "void fireContactChanged(Object srcObj){\r\n    for (SourceContact msc : getQueryResults()) {\r\n        if (srcObj.equals(msc) && msc instanceof MessageSourceContact) {\r\n            super.fireContactChanged(msc);\r\n            break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.growlnotification.GrowlNotificationActivator.getResources",
	"Comment": "returns the resourcemanagementservice obtained from the bundlecontext.",
	"Method": "ResourceManagementService getResources(){\r\n    if (resourcesService == null) {\r\n        resourcesService = ResourceManagementServiceUtils.getService(bundleContext);\r\n    }\r\n    return resourcesService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.contactlist.event.ProtoContactEvent.getNewParent",
	"Comment": "returns the metacontact that is parent of the source contactafter the event occurred or null for a removed contact or when irrelevant.",
	"Method": "MetaContact getNewParent(){\r\n    return (MetaContact) getNewValue();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactListServiceImpl.removeContactGroupFromMetaContactGroup",
	"Comment": "removes the protocol specific group from the specified meta contact groupand removes from meta contacts all proto contacts that belong to thesame provider as the group which is being removed.",
	"Method": "void removeContactGroupFromMetaContactGroup(MetaContactGroupImpl metaContainer,ContactGroup groupToRemove,ProtocolProviderService sourceProvider){\r\n    if (metaContainer == null) {\r\n        logger.warn(\"No meta container found, when trying to remove group: \" + groupToRemove);\r\n        return;\r\n    }\r\n    locallyRemoveAllContactsForProvider(metaContainer, groupToRemove);\r\n    fireMetaContactGroupEvent(metaContainer, sourceProvider, groupToRemove, MetaContactGroupEvent.CONTACT_GROUP_REMOVED_FROM_META_GROUP);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.RenameGroupDialog.requestFocusInFiled",
	"Comment": "requests the focus in the text field contained in thisdialog.",
	"Method": "void requestFocusInFiled(){\r\n    this.renameGroupPanel.requestFocusInField();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl.updateMediaDescriptionForSDes",
	"Comment": "updates the supplied media description with sdes attributes if necessary.",
	"Method": "boolean updateMediaDescriptionForSDes(MediaType mediaType,MediaDescription localMd,MediaDescription remoteMd){\r\n    AccountID accountID = getPeer().getProtocolProvider().getAccountID();\r\n    if (!accountID.getAccountPropertyBoolean(ProtocolProviderFactory.DEFAULT_ENCRYPTION, true) || !accountID.isEncryptionProtocolEnabled(SrtpControlType.SDES)) {\r\n        return false;\r\n    }\r\n    SrtpControls srtpControls = getSrtpControls();\r\n    SDesControl sdesControl = (SDesControl) srtpControls.getOrCreate(mediaType, SrtpControlType.SDES);\r\n    String ciphers = accountID.getAccountPropertyString(ProtocolProviderFactory.SDES_CIPHER_SUITES);\r\n    if (ciphers == null) {\r\n        ciphers = SipActivator.getResources().getSettingsString(SDesControl.SDES_CIPHER_SUITES);\r\n    }\r\n    sdesControl.setEnabledCiphers(Arrays.asList(ciphers.split(\",\")));\r\n    if (remoteMd == null) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        Vector<Attribute> atts = localMd.getAttributes(true);\r\n        for (SrtpCryptoAttribute ca : sdesControl.getInitiatorCryptoAttributes()) {\r\n            atts.add(SdpUtils.createAttribute(\"crypto\", ca.encode()));\r\n        }\r\n        return true;\r\n    } else {\r\n        SrtpCryptoAttribute localAttr = selectSdesCryptoSuite(false, sdesControl, remoteMd);\r\n        if (localAttr != null) {\r\n            try {\r\n                localMd.setAttribute(\"crypto\", localAttr.encode());\r\n                return true;\r\n            } catch (SdpException e) {\r\n                logger.error(\"unable to add crypto to answer\", e);\r\n            }\r\n        } else {\r\n            sdesControl.cleanup(null);\r\n            srtpControls.remove(mediaType, SrtpControlType.SDES);\r\n            logger.warn(\"Received unsupported sdes crypto attribute.\");\r\n        }\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.SaveOptimizeTest.testChangeMaxInactiveWithSaveOptimisation",
	"Comment": "test changing the maxinactive on a session that is subject to saveoptimizations, and check that the session is saved, even if it isnot otherwise dirty.",
	"Method": "void testChangeMaxInactiveWithSaveOptimisation(){\r\n    String contextPath = \"\";\r\n    String servletMapping = \"/server\";\r\n    int inactivePeriod = -1;\r\n    int scavengePeriod = -1;\r\n    int savePeriod = 40;\r\n    DefaultSessionCacheFactory cacheFactory = new DefaultSessionCacheFactory();\r\n    cacheFactory.setSaveOnCreate(true);\r\n    TestSessionDataStoreFactory storeFactory = new TestSessionDataStoreFactory();\r\n    storeFactory.setSavePeriodSec(savePeriod);\r\n    _server1 = new TestServer(0, inactivePeriod, scavengePeriod, cacheFactory, storeFactory);\r\n    _servlet = new TestServlet();\r\n    ServletHolder holder = new ServletHolder(_servlet);\r\n    ServletContextHandler contextHandler = _server1.addContext(contextPath);\r\n    TestContextScopeListener scopeListener = new TestContextScopeListener();\r\n    contextHandler.addEventListener(scopeListener);\r\n    contextHandler.addServlet(holder, servletMapping);\r\n    _servlet.setStore(contextHandler.getSessionHandler().getSessionCache().getSessionDataStore());\r\n    _server1.start();\r\n    int port1 = _server1.getPort();\r\n    try (StacklessLogging stackless = new StacklessLogging(Log.getLogger(\"org.eclipse.jetty.server.session\"))) {\r\n        HttpClient client = new HttpClient();\r\n        try {\r\n            client.start();\r\n            String url = \"http://localhost:\" + port1 + contextPath + servletMapping + \"?action=create&check=true\";\r\n            int numSavesBefore = getNumSaves();\r\n            CountDownLatch latch = new CountDownLatch(1);\r\n            scopeListener.setExitSynchronizer(latch);\r\n            ContentResponse response = client.GET(url);\r\n            assertEquals(HttpServletResponse.SC_OK, response.getStatus());\r\n            String sessionCookie = response.getHeaders().get(\"Set-Cookie\");\r\n            assertNotNull(sessionCookie);\r\n            String sessionId = TestServer.extractSessionId(sessionCookie);\r\n            assertTrue(latch.await(5, TimeUnit.SECONDS));\r\n            assertThat(getNumSaves(), greaterThan(numSavesBefore));\r\n            numSavesBefore = getNumSaves();\r\n            latch = new CountDownLatch(1);\r\n            scopeListener.setExitSynchronizer(latch);\r\n            client.newRequest(\"http://localhost:\" + port1 + contextPath + servletMapping + \"?action=max&value=60\").send();\r\n            assertTrue(latch.await(5, TimeUnit.SECONDS));\r\n            assertThat(getNumSaves(), greaterThan(numSavesBefore));\r\n            SessionData d = contextHandler.getSessionHandler().getSessionCache().getSessionDataStore().load(sessionId);\r\n            assertNotNull(d);\r\n            assertEquals(60000, d.getMaxInactiveMs());\r\n        } finally {\r\n            client.stop();\r\n        }\r\n    } finally {\r\n        _server1.stop();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetVideoBridgeImpl.createConfCall",
	"Comment": "creates a conference call with the specified callees as call peers via avideo bridge provided by the parent jabber provider.",
	"Method": "Call createConfCall(String[] callees){\r\n    return protocolProvider.getOperationSet(OperationSetTelephonyConferencing.class).createConfCall(callees, new MediaAwareCallConference(true));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ContactGroupSipImpl.isPersistent",
	"Comment": "determines whether or not this contact group is being stored by theserver. non persistent contact groups exist for the sole purpose ofcontaining non persistent contacts.",
	"Method": "boolean isPersistent(){\r\n    return isPersistent;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.icqaccregwizz.IcqAccountRegistrationWizard.getLastPageIdentifier",
	"Comment": "returns the identifier of the page to show last in the wizard.",
	"Method": "Object getLastPageIdentifier(){\r\n    return firstWizardPage.getIdentifier();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.RootContactGroupIcqImpl.countContacts",
	"Comment": "returns the number, which is always 0, of contact membersof this contactgroup",
	"Method": "int countContacts(){\r\n    return 0;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactListServiceImpl.findMetaContactGroupByContactGroup",
	"Comment": "returns the metacontactgroup corresponding to the specified contactgroupor null if no such metacontactgroup was found.",
	"Method": "MetaContactGroup findMetaContactGroupByContactGroup(ContactGroup contactGroup){\r\n    return rootMetaGroup.findMetaContactGroupByContactGroup(contactGroup);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.UINotificationGroup.addNotification",
	"Comment": "adds the given notification to the list of unread notifications andnotifies interested listeners.",
	"Method": "void addNotification(UINotification notification){\r\n    synchronized (unreadNotifications) {\r\n        unreadNotifications.remove(notification);\r\n        unreadNotifications.add(notification);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.plaf.SIPCommTextFieldUI.mouseExited",
	"Comment": "updates the delete icon when the mouse exits the component area.",
	"Method": "void mouseExited(MouseEvent e){\r\n    updateDeleteIcon(e);\r\n    updateCursor(e);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.callhistory.CallHistoryQueryImpl.removeQueryListener",
	"Comment": "removes the given callhistoryquerylistener from the list oflisteners interested in query result changes.",
	"Method": "void removeQueryListener(CallHistoryQueryListener l){\r\n    synchronized (queryListeners) {\r\n        queryListeners.remove(l);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.loggingutils.LoggingConfigForm.insertUpdate",
	"Comment": "gives notification that there was an insert into the document.therange given by the documentevent bounds the freshly inserted region.",
	"Method": "void insertUpdate(DocumentEvent e){\r\n    documentChanged(e);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chatroomslist.joinforms.NewChatRoom.setChatRoomProvider",
	"Comment": "sets the chat room provider corresponding to the chosen account.",
	"Method": "void setChatRoomProvider(ChatRoomProviderWrapper provider){\r\n    this.chatRoomProvider = provider;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.browserlauncher.BrowserLauncherActivator.getConfigurationService",
	"Comment": "returns the configurationservice obtained from thethe bundlecontext",
	"Method": "ConfigurationService getConfigurationService(){\r\n    if (configService == null && bundleContext != null) {\r\n        configService = ServiceUtils.getService(bundleContext, ConfigurationService.class);\r\n    }\r\n    return configService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.sip.TestAccountInstallation.getAccountProperties",
	"Comment": "returns all properties necessary for the intialization of the accountwith accountprefix.",
	"Method": "Hashtable<String, String> getAccountProperties(String accountPrefix){\r\n    Hashtable<String, String> table = new Hashtable<String, String>();\r\n    String userID = System.getProperty(accountPrefix + ProtocolProviderFactory.USER_ID, null);\r\n    assertNotNull(\"The system property named \" + accountPrefix + ProtocolProviderFactory.USER_ID + \" has to tontain a valid SIP address that could be used during \" + \"SIP Communicator's tests.\", userID);\r\n    table.put(ProtocolProviderFactory.USER_ID, userID);\r\n    String displayName = System.getProperty(accountPrefix + ProtocolProviderFactory.DISPLAY_NAME, null);\r\n    assertNotNull(\"The system property named \" + accountPrefix + ProtocolProviderFactory.DISPLAY_NAME + \" has to contain a valid name string that could be used during \" + \"SIP Communicator's tests.\", displayName);\r\n    table.put(ProtocolProviderFactory.DISPLAY_NAME, displayName);\r\n    String passwd = System.getProperty(accountPrefix + ProtocolProviderFactory.PASSWORD, null);\r\n    assertNotNull(\"The system property named \" + accountPrefix + ProtocolProviderFactory.PASSWORD + \" has to contain the password corresponding to the account \" + \"specified in \" + accountPrefix + ProtocolProviderFactory.USER_ID, passwd);\r\n    table.put(ProtocolProviderFactory.PASSWORD, passwd);\r\n    String serverAddress = System.getProperty(accountPrefix + ProtocolProviderFactory.SERVER_ADDRESS, null);\r\n    assertNotNull(\"The system property named \" + accountPrefix + ProtocolProviderFactory.SERVER_ADDRESS + \" has to contain a valid server address to use for testing.\", serverAddress);\r\n    table.put(ProtocolProviderFactory.SERVER_ADDRESS, serverAddress);\r\n    String serverPort = System.getProperty(accountPrefix + ProtocolProviderFactory.SERVER_PORT, null);\r\n    if (serverPort != null) {\r\n        table.put(ProtocolProviderFactory.SERVER_PORT, serverPort);\r\n    }\r\n    String proxyAddress = System.getProperty(accountPrefix + ProtocolProviderFactory.PROXY_ADDRESS, null);\r\n    if (serverPort != null) {\r\n        table.put(ProtocolProviderFactory.PROXY_ADDRESS, proxyAddress);\r\n        String proxyPort = System.getProperty(accountPrefix + ProtocolProviderFactory.PROXY_PORT, null);\r\n        if (proxyPort != null) {\r\n            table.put(ProtocolProviderFactory.PROXY_PORT, proxyPort);\r\n        }\r\n    }\r\n    String xCapServerUri = System.getProperty(accountPrefix + SipProtocolProviderServiceLick.XCAP_SERVER_PROPERTY_NAME, null);\r\n    if (xCapServerUri != null) {\r\n        table.put(SipAccountID.XCAP_ENABLE, Boolean.TRUE.toString());\r\n        table.put(SipAccountID.OPT_CLIST_USE_SIP_CREDETIALS, Boolean.TRUE.toString());\r\n        table.put(SipAccountID.OPT_CLIST_USER, Boolean.TRUE.toString());\r\n        table.put(SipAccountID.OPT_CLIST_SERVER_URI, xCapServerUri);\r\n    }\r\n    table.put(ProtocolProviderFactory.FORCE_P2P_MODE, Boolean.FALSE.toString());\r\n    return table;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.presence.NewStatusMessageDialog.actionPerformed",
	"Comment": "handles the actionevent. in order to change the status messagewith the new one calls the publishstatusmessagethread.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    JButton button = (JButton) e.getSource();\r\n    String name = button.getName();\r\n    if (name.equals(\"ok\")) {\r\n        parentMenu.setCurrentMessage(messageTextField.getText(), parentMenu.getNewMessageItem(), saveNewMessage.isSelected());\r\n        parentMenu.publishStatusMessage(messageTextField.getText(), parentMenu.getNewMessageItem(), saveNewMessage.isSelected());\r\n    }\r\n    this.dispose();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.history.HistoryQueryImpl.addHistoryRecordsListener",
	"Comment": "adds the given historyquerylistener to the list oflisteners interested in query result changes.",
	"Method": "void addHistoryRecordsListener(HistoryQueryListener l){\r\n    synchronized (queryListeners) {\r\n        queryListeners.add(l);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.CryptoPacketExtension.equals",
	"Comment": "returns if the current cryptopacketextension equals the one given inparameter.",
	"Method": "boolean equals(Object obj){\r\n    if (obj instanceof CryptoPacketExtension) {\r\n        CryptoPacketExtension crypto = (CryptoPacketExtension) obj;\r\n        return (crypto.equalsCryptoSuite(this.getCryptoSuite()) && crypto.equalsKeyParams(this.getKeyParams()) && crypto.equalsSessionParams(this.getSessionParams()) && crypto.equalsTag(this.getTag()));\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.PayloadTypePacketExtension.addParameter",
	"Comment": "adds an sdp parameter to the list that we already have registered for thispayload type.",
	"Method": "void addParameter(ParameterPacketExtension parameter){\r\n    addChildExtension(parameter);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.MUCServiceImpl.findChatRoomWrapperFromSourceContact",
	"Comment": "finds the chatroomwrapper instance associated with thesource contact.",
	"Method": "ChatRoomWrapper findChatRoomWrapperFromSourceContact(SourceContact contact){\r\n    if (!(contact instanceof ChatRoomSourceContact))\r\n        return null;\r\n    ChatRoomSourceContact chatRoomContact = (ChatRoomSourceContact) contact;\r\n    return chatRoomList.findChatRoomWrapperFromChatRoomID(chatRoomContact.getChatRoomID(), chatRoomContact.getProvider());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetVideoBridgeImpl.processColibriConferenceIQ",
	"Comment": "notifies this instance that a specific colibriconferenceiq hasbeen received.",
	"Method": "void processColibriConferenceIQ(ColibriConferenceIQ conferenceIQ){\r\n    if (IQ.Type.SET.equals(conferenceIQ.getType()) && conferenceIQ.getID() != null) {\r\n        OperationSetBasicTelephony<?> basicTelephony = protocolProvider.getOperationSet(OperationSetBasicTelephony.class);\r\n        if (basicTelephony != null) {\r\n            Iterator<? extends Call> i = basicTelephony.getActiveCalls();\r\n            while (i.hasNext()) {\r\n                Call call = i.next();\r\n                if (call instanceof CallJabberImpl) {\r\n                    CallJabberImpl callJabberImpl = (CallJabberImpl) call;\r\n                    MediaAwareCallConference conference = callJabberImpl.getConference();\r\n                    if ((conference != null) && conference.isJitsiVideobridge()) {\r\n                        if (callJabberImpl.processColibriConferenceIQ(conferenceIQ))\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.DynamicPayloadTypeRegistry.getPayloadType",
	"Comment": "returns the payload type that is currently mapped to format ornull if there is currently no such payload type.",
	"Method": "Byte getPayloadType(MediaFormat format){\r\n    return getPayloadTypeFromMap(payloadTypeMappings, format);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.authorization.AuthorizationHandlerImpl.processAuthorisationRequest",
	"Comment": "implements the authorizationhandler.processauthorisationrequestmethod.called by the protocol provider whenever someone would like to add us totheir contact list.",
	"Method": "AuthorizationResponse processAuthorisationRequest(AuthorizationRequest req,Contact sourceContact){\r\n    AuthorizationResponse response = null;\r\n    AuthorizationRequestedDialog dialog = null;\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        ProcessAuthorizationRequestRunnable runnable = new ProcessAuthorizationRequestRunnable(sourceContact, req);\r\n        try {\r\n            SwingUtilities.invokeAndWait(runnable);\r\n        } catch (Throwable t) {\r\n            if (dialog == null) {\r\n                runnable.run();\r\n            }\r\n        }\r\n        dialog = runnable.getDialog();\r\n    } else {\r\n        dialog = createAndShowAuthorizationRequestDialog(sourceContact, req);\r\n    }\r\n    int result = dialog.getReturnCode();\r\n    if (result == AuthorizationRequestedDialog.ACCEPT_CODE) {\r\n        response = new AuthorizationResponse(AuthorizationResponse.ACCEPT, null);\r\n        if (dialog.isAddContact()) {\r\n            if (!sourceContact.getAddress().equals(sourceContact.getDisplayName()))\r\n                addRenameListener(sourceContact.getProtocolProvider(), sourceContact.getAddress(), sourceContact.getDisplayName());\r\n            ContactListUtils.addContact(sourceContact.getProtocolProvider(), dialog.getSelectedMetaContactGroup(), sourceContact.getAddress());\r\n        }\r\n    } else if (result == AuthorizationRequestedDialog.REJECT_CODE) {\r\n        response = new AuthorizationResponse(AuthorizationResponse.REJECT, null);\r\n    } else if (result == AuthorizationRequestedDialog.IGNORE_CODE) {\r\n        response = new AuthorizationResponse(AuthorizationResponse.IGNORE, null);\r\n    }\r\n    return response;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.MobileIndicator.registrationStateChanged",
	"Comment": "the method is called by a protocolprovider implementation whenevera change in the registration state of the corresponding provider hadoccurred.",
	"Method": "void registrationStateChanged(RegistrationStateChangeEvent evt){\r\n    if (evt.getNewState() == RegistrationState.REGISTERED) {\r\n        this.parentProvider.getDiscoveryManager().getCapsManager().addUserCapsNodeListener(this);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jibri.SipCallState.setError",
	"Comment": "sets xmpperror on this sipcallstate. doing this onlymakes sense for failed state. otherwise the value will probably beignored.",
	"Method": "void setError(XMPPError error){\r\n    if (error != null) {\r\n        XMPPErrorPE errorPe = getErrorPE();\r\n        if (errorPe == null) {\r\n            errorPe = new XMPPErrorPE(error);\r\n            addChildExtension(errorPe);\r\n        }\r\n        errorPe.setError(error);\r\n    } else {\r\n        getChildExtensions().remove(getErrorPE());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetFileTransferIcqImpl.sendFile",
	"Comment": "sends a file transfer request to the given tocontact byspecifying the local and remote file path and the fromcontact,sending the file.",
	"Method": "FileTransfer sendFile(Contact toContact,File file,FileTransfer sendFile,Contact toContact,Contact fromContact,String remotePath,String localPath){\r\n    return this.sendFile(toContact, new File(localPath));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.thumbnail.FileElement.getThumbnailElement",
	"Comment": "returns the thumbnailelement contained in thisfileelement.",
	"Method": "ThumbnailElement getThumbnailElement(){\r\n    return thumbnail;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractCallPeer.setAlternativeIMPPAddress",
	"Comment": "returns an alternative impp address corresponding to thiscallpeer.",
	"Method": "void setAlternativeIMPPAddress(String address){\r\n    alternativeIMPPAddress = address;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.TreeContactList.startSelectedContactVideoCall",
	"Comment": "starts a video call with the currently selected contact in the contactlist.",
	"Method": "void startSelectedContactVideoCall(){\r\n    TreePath selectionPath = getSelectionPath();\r\n    if (selectionPath == null)\r\n        return;\r\n    ContactListTreeCellRenderer renderer = (ContactListTreeCellRenderer) getCellRenderer().getTreeCellRendererComponent(this, selectionPath.getLastPathComponent(), true, true, true, this.getRowForPath(selectionPath), true);\r\n    renderer.getCallVideoButton().doClick();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ProtocolProviderFactoryIrcImpl.installAccount",
	"Comment": "initialized and creates an account corresponding to the specifiedaccountproperties and registers the resulting protocolprovider in thecontext bundlecontext parameter.",
	"Method": "AccountID installAccount(String userIDStr,Map<String, String> accountProperties){\r\n    BundleContext context = IrcActivator.getBundleContext();\r\n    if (context == null) {\r\n        throw new NullPointerException(\"The specified BundleContext was null\");\r\n    }\r\n    if (userIDStr == null) {\r\n        throw new NullPointerException(\"The specified AccountID was null\");\r\n    }\r\n    if (accountProperties == null) {\r\n        throw new NullPointerException(\"The specified property map was null\");\r\n    }\r\n    accountProperties.put(USER_ID, userIDStr);\r\n    final String host = accountProperties.get(ProtocolProviderFactory.SERVER_ADDRESS);\r\n    final String port = accountProperties.get(ProtocolProviderFactory.SERVER_PORT);\r\n    AccountID accountID = new IrcAccountID(userIDStr, host, port, accountProperties);\r\n    if (registeredAccounts.containsKey(accountID)) {\r\n        throw new IllegalStateException(\"An account for id \" + userIDStr + \" was already installed!\");\r\n    }\r\n    this.storeAccount(accountID, false);\r\n    accountID = loadAccount(accountProperties);\r\n    return accountID;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetTelephonyConferencingSipImpl.callPeerAdded",
	"Comment": "notifies this callchangelistener that a specificcallpeer has been added to a specific call.",
	"Method": "void callPeerAdded(CallPeerEvent event){\r\n    super.callPeerAdded(event);\r\n    CallPeer callPeer = event.getSourceCallPeer();\r\n    if (callPeer instanceof CallPeerSipImpl)\r\n        ((CallPeerSipImpl) callPeer).addMethodProcessorListener(this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.reconnectplugin.ReconnectPluginActivator.hasAtLeastOneSuccessfulConnection",
	"Comment": "check does the supplied protocol has the property set for at leastone successful connection.",
	"Method": "boolean hasAtLeastOneSuccessfulConnection(ProtocolProviderService pp){\r\n    String value = (String) getConfigurationService().getProperty(ATLEAST_ONE_CONNECTION_PROP + \".\" + pp.getAccountID().getAccountUniqueID());\r\n    if (value == null || !value.equals(Boolean.TRUE.toString()))\r\n        return false;\r\n    else\r\n        return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.configuration.ConfigurationActivator.stop",
	"Comment": "causes the configuration service to store the properties object andunregisters the configuration service.",
	"Method": "void stop(BundleContext bundleContext){\r\n    this.cs.storeConfiguration();\r\n    this.cs = null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.MetaContactChatTransport.getProtocolProvider",
	"Comment": "returns the protocolproviderservice, corresponding to this chattransport.",
	"Method": "ProtocolProviderService getProtocolProvider(){\r\n    return contact.getProtocolProvider();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.aimaccregwizz.FirstWizardPage.getBackPageIdentifier",
	"Comment": "implements the wizardpage.getbackpageidentifier to returnthe back identifier, which is null as this is the first wizard page.",
	"Method": "Object getBackPageIdentifier(){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.configforms.ConfigFormListCellRenderer.paintComponent",
	"Comment": "overrides the paintcomponent method of jpanelto provide a custom look for this panel. a gradient background ispainted when the panel is selected and when the mouse is over it.",
	"Method": "void paintComponent(Graphics g){\r\n    super.paintComponent(g);\r\n    AntialiasingManager.activateAntialiasing(g);\r\n    Graphics2D g2 = (Graphics2D) g;\r\n    if (isSelected) {\r\n        g2.setPaint(new Color(100, 100, 100, 100));\r\n        g2.fillRoundRect(0, 0, this.getWidth(), this.getHeight(), 10, 10);\r\n        g2.setColor(Color.GRAY);\r\n        g2.drawRoundRect(0, 0, this.getWidth() - 1, this.getHeight() - 1, 10, 10);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.UriHandlerJabberImpl.handleUri",
	"Comment": "parses the specified uri and creates a chat with the currently activeim operation set.",
	"Method": "void handleUri(String uri){\r\n    synchronized (storedAccountsAreLoaded) {\r\n        if (!storedAccountsAreLoaded[0]) {\r\n            if (uris == null) {\r\n                uris = new LinkedList<String>();\r\n            }\r\n            uris.add(uri);\r\n            return;\r\n        }\r\n    }\r\n    ProtocolProviderService provider;\r\n    try {\r\n        provider = selectHandlingProvider(uri);\r\n    } catch (OperationFailedException exc) {\r\n        if (logger.isTraceEnabled())\r\n            logger.trace(\"User canceled handling of uri \" + uri);\r\n        return;\r\n    }\r\n    if (provider == null) {\r\n        showErrorMessage(\"You need to configure at least one XMPP account \\n\" + \"to be able to call \" + uri, null);\r\n        return;\r\n    }\r\n    if (!uri.contains(\"?\")) {\r\n        OperationSetPersistentPresence presenceOpSet = provider.getOperationSet(OperationSetPersistentPresence.class);\r\n        String contactId = uri.substring(uri.indexOf(':') + 1);\r\n        Pattern p = Pattern.compile(\".+@.+\");\r\n        if (!p.matcher(contactId).matches()) {\r\n            showErrorMessage(\"Wrong contact id : \" + uri, null);\r\n            return;\r\n        }\r\n        Contact contact = presenceOpSet.findContactByID(contactId);\r\n        if (contact == null) {\r\n            Object result = JabberActivator.getUIService().getPopupDialog().showConfirmPopupDialog(\"Do you want to add the contact : \" + contactId + \" ?\", \"Add contact\", PopupDialog.YES_NO_OPTION);\r\n            if (result.equals(PopupDialog.YES_OPTION)) {\r\n                ExportedWindow ex = JabberActivator.getUIService().getExportedWindow(ExportedWindow.ADD_CONTACT_WINDOW, new String[] { contactId });\r\n                ex.setVisible(true);\r\n            }\r\n            return;\r\n        }\r\n        JabberActivator.getUIService().getChat(contact).setChatVisible(true);\r\n    } else {\r\n        String croom = uri.replaceFirst(getProtocol() + \":\", \"\");\r\n        int ix = croom.indexOf(\"?\");\r\n        String param = croom.substring(ix + 1, croom.length());\r\n        croom = croom.substring(0, ix);\r\n        if (param.equalsIgnoreCase(\"join\")) {\r\n            OperationSetMultiUserChat mchatOpSet = provider.getOperationSet(OperationSetMultiUserChat.class);\r\n            try {\r\n                ChatRoom room = mchatOpSet.findRoom(croom);\r\n                if (room != null) {\r\n                    room.join();\r\n                }\r\n            } catch (OperationFailedException exc) {\r\n                if ((exc.getErrorCode() == OperationFailedException.NETWORK_FAILURE) && !networkFailReceived) {\r\n                    networkFailReceived = true;\r\n                    OperationSetPresence presenceOpSet = provider.getOperationSet(OperationSetPresence.class);\r\n                    presenceOpSet.addProviderPresenceStatusListener(new ProviderStatusListener(uri, presenceOpSet));\r\n                } else\r\n                    showErrorMessage(\"Error joining to  \" + croom, exc);\r\n            } catch (OperationNotSupportedException exc) {\r\n                showErrorMessage(\"Join to \" + croom + \", not supported!\", exc);\r\n            }\r\n        } else\r\n            showErrorMessage(\"Unknown param : \" + param, null);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatSession.getHistory",
	"Comment": "returns a collection of the last n number of messages given by count.",
	"Method": "Collection<Object> getHistory(int count){\r\n    final MetaHistoryService metaHistory = GuiActivator.getMetaHistoryService();\r\n    if (metaHistory == null)\r\n        return null;\r\n    return metaHistory.findLast(chatHistoryFilter, chatRoomWrapper.getChatRoom(), ConfigurationUtils.getChatHistorySize());\r\n}"
}, {
	"Path": "io.lettuce.core.AbstractRedisClient.shutdownAsync",
	"Comment": "shutdown this client and close all open connections asynchronously. the client should be discarded after callingshutdown.",
	"Method": "CompletableFuture<Void> shutdownAsync(CompletableFuture<Void> shutdownAsync,long quietPeriod,long timeout,TimeUnit timeUnit){\r\n    if (shutdown.compareAndSet(false, true)) {\r\n        logger.debug(\"Initiate shutdown ({}, {}, {})\", quietPeriod, timeout, timeUnit);\r\n        List<CompletableFuture<Void>> closeFutures = new ArrayList();\r\n        while (!closeableResources.isEmpty()) {\r\n            Closeable closeableResource = closeableResources.iterator().next();\r\n            if (closeableResource instanceof AsyncCloseable) {\r\n                closeFutures.add(((AsyncCloseable) closeableResource).closeAsync());\r\n            } else {\r\n                try {\r\n                    closeableResource.close();\r\n                } catch (Exception e) {\r\n                    logger.debug(\"Exception on Close: \" + e.getMessage(), e);\r\n                }\r\n            }\r\n            closeableResources.remove(closeableResource);\r\n        }\r\n        for (Channel c : channels) {\r\n            ChannelPipeline pipeline = c.pipeline();\r\n            ConnectionWatchdog commandHandler = pipeline.get(ConnectionWatchdog.class);\r\n            if (commandHandler != null) {\r\n                commandHandler.setListenOnChannelInactive(false);\r\n            }\r\n        }\r\n        try {\r\n            closeFutures.add(toCompletableFuture(channels.close()));\r\n        } catch (Exception e) {\r\n            logger.debug(\"Cannot close channels\", e);\r\n        }\r\n        if (!sharedResources) {\r\n            Future<?> groupCloseFuture = clientResources.shutdown(quietPeriod, timeout, timeUnit);\r\n            closeFutures.add(toCompletableFuture(groupCloseFuture));\r\n        } else {\r\n            for (EventLoopGroup eventExecutors : eventLoopGroups.values()) {\r\n                Future<?> groupCloseFuture = clientResources.eventLoopGroupProvider().release(eventExecutors, quietPeriod, timeout, timeUnit);\r\n                closeFutures.add(toCompletableFuture(groupCloseFuture));\r\n            }\r\n        }\r\n        return Futures.allOf(closeFutures);\r\n    }\r\n    return completedFuture(null);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatTransport.getParentChatSession",
	"Comment": "returns the parent session of this chat transport. a chatsessioncould contain more than one transports.",
	"Method": "ChatSession getParentChatSession(){\r\n    return chatSession;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.JingleIQ.getContentByName",
	"Comment": "finds contentpacketextension that matches givencontentname.",
	"Method": "ContentPacketExtension getContentByName(String contentName){\r\n    synchronized (contentList) {\r\n        for (ContentPacketExtension content : contentList) {\r\n            if (contentName.equals(content.getName())) {\r\n                return content;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallPanel.getCallTitle",
	"Comment": "returns the initial call title. the call title could be then changed bycall setcalltitle.",
	"Method": "String getCallTitle(){\r\n    return title;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.ChooseCallAccountPopupMenu.addTelephonyContactItem",
	"Comment": "adds the given telephonycontact to the list of availabletelephony contact.",
	"Method": "void addTelephonyContactItem(UIContactDetailImpl telephonyContact,Class<? extends OperationSet> opSetClass){\r\n    final ContactMenuItem contactItem = new ContactMenuItem(telephonyContact);\r\n    contactItem.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent e) {\r\n            List<ProtocolProviderService> providers = AccountUtils.getOpSetRegisteredProviders(opSetClass, telephonyContact.getPreferredProtocolProvider(opSetClass), telephonyContact.getPreferredProtocol(opSetClass));\r\n            if (providers == null || providers.size() <= 0) {\r\n                new ErrorDialog(null, GuiActivator.getResources().getI18NString(\"service.gui.CALL_FAILED\"), GuiActivator.getResources().getI18NString(\"service.gui.NO_ONLINE_TELEPHONY_ACCOUNT\")).showDialog();\r\n                return;\r\n            } else if (providers.size() > 1) {\r\n                itemSelected(opSetClass, providers, telephonyContact.getAddress());\r\n            } else {\r\n                ProtocolProviderService provider = providers.get(0);\r\n                String contactAddress = telephonyContact.getAddress();\r\n                if (uiContact != null)\r\n                    itemSelected(opSetClass, provider, contactAddress, uiContact);\r\n                else\r\n                    itemSelected(opSetClass, provider, contactAddress);\r\n            }\r\n            ChooseCallAccountPopupMenu.this.setVisible(false);\r\n        }\r\n    });\r\n    String category = telephonyContact.getCategory();\r\n    if (category != null && category.equals(ContactDetail.Category.Phone)) {\r\n        int index = findPhoneItemIndex();\r\n        if (index < 0)\r\n            add(contactItem);\r\n        else\r\n            insert(contactItem, findPhoneItemIndex());\r\n    } else {\r\n        Component lastComp = getComponent(getComponentCount() - 1);\r\n        if (lastComp instanceof ContactMenuItem)\r\n            category = ((ContactMenuItem) lastComp).getCategory();\r\n        if (category != null && category.equals(ContactDetail.Category.Phone))\r\n            addSeparator();\r\n        add(contactItem);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.ChooseCallAccountPopupMenu.addTelephonyContactItem",
	"Comment": "adds the given telephonycontact to the list of availabletelephony contact.",
	"Method": "void addTelephonyContactItem(UIContactDetailImpl telephonyContact,Class<? extends OperationSet> opSetClass){\r\n    List<ProtocolProviderService> providers = AccountUtils.getOpSetRegisteredProviders(opSetClass, telephonyContact.getPreferredProtocolProvider(opSetClass), telephonyContact.getPreferredProtocol(opSetClass));\r\n    if (providers == null || providers.size() <= 0) {\r\n        new ErrorDialog(null, GuiActivator.getResources().getI18NString(\"service.gui.CALL_FAILED\"), GuiActivator.getResources().getI18NString(\"service.gui.NO_ONLINE_TELEPHONY_ACCOUNT\")).showDialog();\r\n        return;\r\n    } else if (providers.size() > 1) {\r\n        itemSelected(opSetClass, providers, telephonyContact.getAddress());\r\n    } else {\r\n        ProtocolProviderService provider = providers.get(0);\r\n        String contactAddress = telephonyContact.getAddress();\r\n        if (uiContact != null)\r\n            itemSelected(opSetClass, provider, contactAddress, uiContact);\r\n        else\r\n            itemSelected(opSetClass, provider, contactAddress);\r\n    }\r\n    ChooseCallAccountPopupMenu.this.setVisible(false);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ChatRoomContactList.isGroupClosed",
	"Comment": "checks whether the group is closed.dummy method used and overridden from classes extending thisfunctionality such as contactlist.",
	"Method": "boolean isGroupClosed(MetaContactGroup group){\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ConfigHeaders.processParams",
	"Comment": "checks for certain params existence in the value, and replace themwith real values obtained from request.",
	"Method": "String processParams(String value,Request request){\r\n    if (value.indexOf(\"${from.address}\") != -1) {\r\n        FromHeader fromHeader = (FromHeader) request.getHeader(FromHeader.NAME);\r\n        if (fromHeader != null) {\r\n            value = value.replace(\"${from.address}\", fromHeader.getAddress().getURI().toString());\r\n        }\r\n    }\r\n    if (value.indexOf(\"${from.userID}\") != -1) {\r\n        FromHeader fromHeader = (FromHeader) request.getHeader(FromHeader.NAME);\r\n        if (fromHeader != null) {\r\n            URI fromURI = fromHeader.getAddress().getURI();\r\n            String fromAddr = fromURI.toString();\r\n            if (fromURI.isSipURI()) {\r\n                fromAddr = fromAddr.replaceFirst(fromURI.getScheme() + \":\", \"\");\r\n            }\r\n            int index = fromAddr.indexOf('@');\r\n            if (index > -1)\r\n                fromAddr = fromAddr.substring(0, index);\r\n            value = value.replace(\"${from.userID}\", fromAddr);\r\n        }\r\n    }\r\n    if (value.indexOf(\"${to.address}\") != -1) {\r\n        ToHeader toHeader = (ToHeader) request.getHeader(ToHeader.NAME);\r\n        if (toHeader != null) {\r\n            value = value.replace(\"${to.address}\", toHeader.getAddress().getURI().toString());\r\n        }\r\n    }\r\n    if (value.indexOf(\"${to.userID}\") != -1) {\r\n        ToHeader toHeader = (ToHeader) request.getHeader(ToHeader.NAME);\r\n        if (toHeader != null) {\r\n            URI toURI = toHeader.getAddress().getURI();\r\n            String toAddr = toURI.toString();\r\n            if (toURI.isSipURI()) {\r\n                toAddr = toAddr.replaceFirst(toURI.getScheme() + \":\", \"\");\r\n            }\r\n            int index = toAddr.indexOf('@');\r\n            if (index > -1)\r\n                toAddr = toAddr.substring(0, index);\r\n            value = value.replace(\"${to.userID}\", toAddr);\r\n        }\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.MessageReceivedEvent.getSourceContact",
	"Comment": "returns a reference to the contact that has sent themessage whose reception this event represents.",
	"Method": "Contact getSourceContact(){\r\n    return from;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.ErrorDialog.hyperlinkUpdate",
	"Comment": "update the errordialog when the user clicks on the hyperlink.",
	"Method": "void hyperlinkUpdate(HyperlinkEvent e){\r\n    if (e.getEventType() == HyperlinkEvent.EventType.ACTIVATED)\r\n        showOrHideDetails();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.WhiteboardObjectReceivedEvent.getSourceContact",
	"Comment": "returns a reference to the contact that has sent thewhiteboardobject whose reception this event represents.",
	"Method": "Contact getSourceContact(){\r\n    return from;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ProxyRouter.getRouterFor",
	"Comment": "retrieves a defaultrouter whose default route is the outbound proxy ofthe account which sent the request, or a default one.",
	"Method": "Router getRouterFor(Request request){\r\n    Object service = SipApplicationData.getApplicationData(request, SipApplicationData.KEY_SERVICE);\r\n    if (service instanceof ProtocolProviderServiceSipImpl) {\r\n        ProtocolProviderServiceSipImpl sipProvider = ((ProtocolProviderServiceSipImpl) service);\r\n        final ProxyConnection connection = sipProvider.getConnection();\r\n        final String proxy = connection.getOutboundProxyString();\r\n        logger.trace(\"Router for proxy: \" + proxy);\r\n        boolean forceLooseRouting = sipProvider.getAccountID().getAccountPropertyBoolean(ProtocolProviderFactory.FORCE_PROXY_BYPASS, false);\r\n        if (proxy == null || forceLooseRouting) {\r\n            logger.info(\"Returning default SIP router, P2P/loose routing\");\r\n            return this.getDefaultRouter();\r\n        }\r\n        Router router = routerCache.get(proxy);\r\n        if (router == null) {\r\n            router = new DefaultRouter(stack, proxy) {\r\n                @Override\r\n                public Hop getNextHop(Request request) throws SipException {\r\n                    logger.debug(\"Outbound proxy mode, using proxy \" + proxy + \" as hop instead of an address resolved\" + \" by the SIP router\");\r\n                    InetSocketAddress sa = connection.getAddress();\r\n                    return new HopImpl(sa.getAddress().getHostAddress(), sa.getPort(), connection.getTransport());\r\n                }\r\n            };\r\n            routerCache.put(proxy, router);\r\n        }\r\n        return router;\r\n    }\r\n    ToHeader to = (ToHeader) request.getHeader(ToHeader.NAME);\r\n    if (to.getTag() == null)\r\n        logger.error(\"unable to identify the service which created this \" + \"out-of-dialog request\");\r\n    logger.info(\"Returning default router\");\r\n    return this.getDefaultRouter();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ProxyRouter.getRouterFor",
	"Comment": "retrieves a defaultrouter whose default route is the outbound proxy ofthe account which sent the request, or a default one.",
	"Method": "Router getRouterFor(Request request){\r\n    logger.debug(\"Outbound proxy mode, using proxy \" + proxy + \" as hop instead of an address resolved\" + \" by the SIP router\");\r\n    InetSocketAddress sa = connection.getAddress();\r\n    return new HopImpl(sa.getAddress().getHostAddress(), sa.getPort(), connection.getTransport());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipRegistrarConnection.register",
	"Comment": "sends the register request to the server specified in the constructor.",
	"Method": "void register(){\r\n    if (getRegistrationState() != RegistrationState.REGISTERED)\r\n        setRegistrationState(RegistrationState.REGISTERING, RegistrationStateChangeEvent.REASON_NOT_SPECIFIED, null);\r\n    Request request;\r\n    try {\r\n        if (callIdHeader == null)\r\n            callIdHeader = this.getJainSipProvider().getNewCallId();\r\n        request = sipProvider.getMessageFactory().createRegisterRequest(getAddressOfRecord(), registrationsExpiration, callIdHeader, getNextCSeqValue());\r\n    } catch (Exception exc) {\r\n        if (exc.getCause() instanceof SocketException || exc.getCause() instanceof IOException || exc.getCause() instanceof SSLHandshakeException) {\r\n            if (exc.getCause().getCause() instanceof CertificateException || exc.getCause().getMessage().startsWith(\"Received fatal alert\")) {\r\n                setRegistrationState(RegistrationState.UNREGISTERED, RegistrationStateChangeEvent.REASON_USER_REQUEST, exc.getMessage());\r\n                return;\r\n            }\r\n            if (sipProvider.registerUsingNextAddress())\r\n                return;\r\n        }\r\n        logger.error(\"Failed to create a Register request.\", exc);\r\n        setRegistrationState(RegistrationState.CONNECTION_FAILED, RegistrationStateChangeEvent.REASON_INTERNAL_ERROR, exc.getMessage());\r\n        if (exc instanceof OperationFailedException)\r\n            throw (OperationFailedException) exc;\r\n        else\r\n            throw new OperationFailedException(\"Failed to generate a from header for our register request.\", OperationFailedException.INTERNAL_ERROR, exc);\r\n    }\r\n    try {\r\n        regTrans = getJainSipProvider().getNewClientTransaction(request);\r\n    } catch (TransactionUnavailableException ex) {\r\n        logger.error(\"Could not create a register transaction!\\n\" + \"Check that the Registrar address is correct!\", ex);\r\n        setRegistrationState(RegistrationState.CONNECTION_FAILED, RegistrationStateChangeEvent.REASON_INTERNAL_ERROR, ex.getMessage());\r\n        throw new OperationFailedException(\"Could not create a register transaction!\\n\" + \"Check that the Registrar address is correct!\", OperationFailedException.NETWORK_FAILURE, ex);\r\n    }\r\n    try {\r\n        regTrans.sendRequest();\r\n    } catch (Exception ex) {\r\n        if (ex.getCause() instanceof SocketException || ex.getCause() instanceof IOException) {\r\n            if (sipProvider.registerUsingNextAddress())\r\n                return;\r\n        }\r\n        logger.error(\"Could not send out the register request!\", ex);\r\n        setRegistrationState(RegistrationState.CONNECTION_FAILED, RegistrationStateChangeEvent.REASON_INTERNAL_ERROR, ex.getMessage());\r\n        throw new OperationFailedException(\"Could not send out the register request!\", OperationFailedException.NETWORK_FAILURE, ex);\r\n    }\r\n    this.registerRequest = request;\r\n}"
}, {
	"Path": "com.keybox.manage.db.PublicKeyDB.deleteUnassignedKeysByUser",
	"Comment": "deletes all ssh keys for users that are not assigned in a profile",
	"Method": "void deleteUnassignedKeysByUser(Connection con,Long userId){\r\n    try {\r\n        PreparedStatement stmt = con.prepareStatement(\"delete from public_keys where (profile_id is null or profile_id not in (select profile_id from user_map where user_id=?)) and user_id=?\");\r\n        stmt.setLong(1, userId);\r\n        stmt.setLong(2, userId);\r\n        stmt.execute();\r\n        DBUtils.closeStmt(stmt);\r\n    } catch (Exception e) {\r\n        log.error(e.toString(), e);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.GuiActivator.getReplacementSources",
	"Comment": "returns all replacementservices obtained from the bundlecontext.",
	"Method": "Map<String, ReplacementService> getReplacementSources(){\r\n    Collection<ServiceReference<ReplacementService>> serRefs = ServiceUtils.getServiceReferences(bundleContext, ReplacementService.class);\r\n    if (!serRefs.isEmpty()) {\r\n        for (ServiceReference<ReplacementService> serRef : serRefs) {\r\n            ReplacementService replacementSources = bundleContext.getService(serRef);\r\n            replacementSourcesMap.put((String) serRef.getProperty(ReplacementService.SOURCE_NAME), replacementSources);\r\n        }\r\n    }\r\n    return replacementSourcesMap;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.configuration.ConfigurationServiceLick.start",
	"Comment": "start the configuration sevice implementation compatibility kit.",
	"Method": "void start(BundleContext bundleContext){\r\n    ConfigurationServiceLick.bc = bundleContext;\r\n    setName(\"ConfigurationServiceLick\");\r\n    Hashtable<String, String> properties = new Hashtable<String, String>();\r\n    properties.put(\"service.pid\", getName());\r\n    addTestSuite(TestConfigurationService.class);\r\n    addTestSuite(TestConfigurationSlickFinalizer.class);\r\n    bundleContext.registerService(getClass().getName(), this, properties);\r\n    logger.debug(\"Successfully registered \" + getClass().getName());\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.notification.NotificationServiceImpl.fireNotificationEventTypeEvent",
	"Comment": "notifies all registered notificationchangelisteners that anotificationeventtypeevent has occurred.",
	"Method": "void fireNotificationEventTypeEvent(String eventType,String sourceEventType){\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Dispatching NotificationEventType Change. Listeners=\" + changeListeners.size() + \" evt=\" + eventType);\r\n    NotificationEventTypeEvent event = new NotificationEventTypeEvent(this, eventType, sourceEventType);\r\n    for (NotificationChangeListener listener : changeListeners) {\r\n        if (eventType.equals(EVENT_TYPE_ADDED)) {\r\n            listener.eventTypeAdded(event);\r\n        } else if (eventType.equals(EVENT_TYPE_REMOVED)) {\r\n            listener.eventTypeRemoved(event);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chatroomslist.joinforms.SearchChatRoomPanel.addChatRoomNameListener",
	"Comment": "adds a documentlistener to the text field containing the chosenchat room.",
	"Method": "void addChatRoomNameListener(DocumentListener l){\r\n    namePanel.addChatRoomNameListener(l);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockBasicInstantMessaging.isContentTypeSupported",
	"Comment": "determines whether the protocol supports the supplied content type",
	"Method": "boolean isContentTypeSupported(String contentType){\r\n    return contentType.equals(DEFAULT_MIME_TYPE);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.notification.NotificationActivator.getUIService",
	"Comment": "returns a reference to an uiservice implementation currently registeredin the bundle context or null if no such implementation was found.",
	"Method": "UIService getUIService(){\r\n    if (uiService == null)\r\n        uiService = ServiceUtils.getService(bundleContext, UIService.class);\r\n    return uiService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.OperationSetPersistentPresenceIrcImpl.getCurrentStatusMessage",
	"Comment": "irc will return the away message if away status is active, or an emptystring if user is not away.",
	"Method": "String getCurrentStatusMessage(){\r\n    final IrcConnection connection = this.parentProvider.getIrcStack().getConnection();\r\n    if (connection == null) {\r\n        throw new IllegalStateException(\"Connection is not available.\");\r\n    }\r\n    return connection.getPresenceManager().isAway() ? connection.getPresenceManager().getMessage() : \"\";\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.IrcActivator.getProtocolProviderFactory",
	"Comment": "returns a reference to the protocol provider factory that we haveregistered.",
	"Method": "ProtocolProviderFactoryIrcImpl getProtocolProviderFactory(){\r\n    return ircProviderFactory;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.EventPackageUtils.addSubscription",
	"Comment": "associates a specific subscription with the a given dialogin order to allow it to keep the dialog in question alive even after abye request.",
	"Method": "boolean addSubscription(Dialog dialog,Object subscription,boolean addSubscription,Object subscription){\r\n    synchronized (dialog) {\r\n        DialogApplicationData appData = (DialogApplicationData) SipApplicationData.getApplicationData(dialog, SipApplicationData.KEY_SUBSCRIPTIONS);\r\n        if (appData == null) {\r\n            appData = new DialogApplicationData();\r\n            SipApplicationData.setApplicationData(dialog, SipApplicationData.KEY_SUBSCRIPTIONS, appData);\r\n        }\r\n        if (appData.addSubscription(subscription)) {\r\n            try {\r\n                dialog.terminateOnBye(false);\r\n                return true;\r\n            } catch (SipException ex) {\r\n                appData.removeSubscription(subscription);\r\n                throw ex;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.account.AccountRegWizardContainerImpl.removeAccountRegistrationWizard",
	"Comment": "removes the given accountregistrationwizard from the list ofcontaining wizards.",
	"Method": "void removeAccountRegistrationWizard(String protocolName,AccountRegistrationWizard wizard){\r\n    synchronized (registeredWizards) {\r\n        registeredWizards.remove(protocolName);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockContactGroup.countSubgroups",
	"Comment": "returns the number of subgroups contained by thiscontactgroup.",
	"Method": "int countSubgroups(){\r\n    return subGroups.size();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.contactsource.ContactDetail.getPreferredProtocolProvider",
	"Comment": "returns the preferred protocolproviderservice when using thegiven opsetclass.",
	"Method": "ProtocolProviderService getPreferredProtocolProvider(Class<? extends OperationSet> opSetClass){\r\n    if (preferredProviders != null && preferredProviders.size() > 0)\r\n        return preferredProviders.get(opSetClass);\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.contactsource.GenericSourceContact.getPresenceStatus",
	"Comment": "returns the status of the source contact. and null if such informationis not available.",
	"Method": "PresenceStatus getPresenceStatus(){\r\n    return presenceStatus;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatManager.localUserAdHocPresenceChanged",
	"Comment": "implements thelocaluseradhocchatroompresencelistener.localuserpresencechangedmethod",
	"Method": "void localUserAdHocPresenceChanged(LocalUserAdHocChatRoomPresenceChangeEvent evt){\r\n    AdHocChatRoom sourceAdHocChatRoom = evt.getAdHocChatRoom();\r\n    AdHocChatRoomWrapper adHocChatRoomWrapper = adHocChatRoomList.findChatRoomWrapperFromAdHocChatRoom(sourceAdHocChatRoom);\r\n    String eventType = evt.getEventType();\r\n    if (LocalUserAdHocChatRoomPresenceChangeEvent.LOCAL_USER_JOINED.equals(eventType)) {\r\n        if (adHocChatRoomWrapper != null) {\r\n            this.fireAdHocChatRoomListChangedEvent(adHocChatRoomWrapper, AdHocChatRoomListChangeEvent.AD_HOC_CHAT_ROOM_CHANGED);\r\n            ChatWindowManager chatWindowManager = GuiActivator.getUIService().getChatWindowManager();\r\n            ChatPanel chatPanel = chatWindowManager.getMultiChat(adHocChatRoomWrapper, true);\r\n            if (chatPanel.isShown())\r\n                ((AdHocConferenceChatSession) chatPanel.getChatSession()).loadChatRoom(sourceAdHocChatRoom);\r\n            else\r\n                chatWindowManager.openChat(chatPanel, true);\r\n        }\r\n        sourceAdHocChatRoom.addMessageListener(this);\r\n    } else if (evt.getEventType().equals(LocalUserAdHocChatRoomPresenceChangeEvent.LOCAL_USER_JOIN_FAILED)) {\r\n        GuiActivator.getAlertUIService().showAlertPopup(GuiActivator.getResources().getI18NString(\"service.gui.ERROR\"), GuiActivator.getResources().getI18NString(\"service.gui.FAILED_TO_JOIN_CHAT_ROOM\", new String[] { sourceAdHocChatRoom.getName() }) + evt.getReason());\r\n    } else if (LocalUserAdHocChatRoomPresenceChangeEvent.LOCAL_USER_LEFT.equals(eventType) || LocalUserAdHocChatRoomPresenceChangeEvent.LOCAL_USER_DROPPED.equals(eventType)) {\r\n        this.closeAdHocChatRoom(adHocChatRoomWrapper);\r\n        fireAdHocChatRoomListChangedEvent(adHocChatRoomWrapper, AdHocChatRoomListChangeEvent.AD_HOC_CHAT_ROOM_CHANGED);\r\n        sourceAdHocChatRoom.removeMessageListener(this);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ChatRoomContactListTransferHandler.importData",
	"Comment": "handles transfers to the contact list from the clip board or adnd drop operation. the transferable parameter contains thedata that needs to be imported.",
	"Method": "boolean importData(JComponent comp,Transferable t){\r\n    if (t.isDataFlavorSupported(metaContactDataFlavor)) {\r\n        Object o = null;\r\n        try {\r\n            o = t.getTransferData(metaContactDataFlavor);\r\n        } catch (UnsupportedFlavorException e) {\r\n            if (logger.isDebugEnabled())\r\n                logger.debug(\"Failed to drop meta contact.\", e);\r\n        } catch (IOException e) {\r\n            if (logger.isDebugEnabled())\r\n                logger.debug(\"Failed to drop meta contact.\", e);\r\n        }\r\n        if (o instanceof ChatContact && comp instanceof ChatRoomContactList) {\r\n            ChatContact<? extends Contact> chatContact = (ChatContact<? extends Contact>) o;\r\n            Contact transferredContact = chatContact.getDescriptor();\r\n            ChatRoomContactList list = (ChatRoomContactList) comp;\r\n            Object dest = list.getSelectedValue();\r\n            if (transferredContact != null) {\r\n                if (dest instanceof MetaContact) {\r\n                    MetaContact destContact = (MetaContact) dest;\r\n                    if (transferredContact != destContact) {\r\n                        MetaContactListManager.moveContactToMetaContact(transferredContact, destContact);\r\n                    }\r\n                    return true;\r\n                } else if (dest instanceof MetaContactGroup) {\r\n                    MetaContactGroup destGroup = (MetaContactGroup) dest;\r\n                    MetaContactListManager.moveContactToGroup(transferredContact, destGroup);\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockPersistentPresenceOperationSet.createServerStoredContactGroup",
	"Comment": "creates a group with the specified name and parent in the serverstored contact list.",
	"Method": "void createServerStoredContactGroup(ContactGroup parent,String groupName){\r\n    MockContactGroup newGroup = new MockContactGroup(groupName, parentProvider);\r\n    ((MockContactGroup) parent).addSubgroup(newGroup);\r\n    this.fireServerStoredGroupEvent(newGroup, ServerStoredGroupEvent.GROUP_CREATED_EVENT);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapSSLSocketFactoryDelegate.createSocket",
	"Comment": "creates a socket for the specified destination host and port.",
	"Method": "Socket createSocket(String host,int port){\r\n    try {\r\n        return LdapServiceImpl.getCertificateService().getSSLContext(LdapServiceImpl.getCertificateService().getTrustManager(host)).getSocketFactory().createSocket(host, port);\r\n    } catch (GeneralSecurityException e) {\r\n        logger.error(\"unable to create socket through the certificate service\", e);\r\n        throw new IOException(e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ContactJabberImpl.toString",
	"Comment": "returns a string representation of this contact, containing most of itsrepresentative details.",
	"Method": "String toString(){\r\n    StringBuffer buff = new StringBuffer(\"JabberContact[ id=\");\r\n    buff.append(getAddress()).append(\", isPersistent=\").append(isPersistent).append(\", isResolved=\").append(isResolved).append(\"]\");\r\n    return buff.toString();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.whiteboard.gui.whiteboardshapes.WhiteboardShapePolygon.createPoly",
	"Comment": "creates a generalpath with all the whiteboardpoint.this generalpath is used for display.",
	"Method": "GeneralPath createPoly(AffineTransform w2v){\r\n    GeneralPath polygon = new GeneralPath(GeneralPath.WIND_EVEN_ODD, points.size());\r\n    if (points.size() <= 0)\r\n        return polygon;\r\n    WhiteboardPoint start = points.get(0);\r\n    Point2D w = new Point2D.Double(start.getX(), start.getY());\r\n    Point2D v = w2v.transform(w, null);\r\n    polygon.moveTo((int) v.getX(), (int) v.getY());\r\n    WhiteboardPoint p;\r\n    for (int i = 0; i < points.size(); i++) {\r\n        p = points.get(i);\r\n        w = new Point2D.Double(p.getX(), p.getY());\r\n        v = w2v.transform(w, null);\r\n        polygon.lineTo((int) v.getX(), (int) v.getY());\r\n    }\r\n    polygon.closePath();\r\n    return polygon;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipRegistrarConnection.processResponse",
	"Comment": "analyzes the incoming responseevent and then forwards it to the proper event handler.",
	"Method": "boolean processResponse(ResponseEvent responseEvent){\r\n    ClientTransaction clientTransaction = responseEvent.getClientTransaction();\r\n    Response response = responseEvent.getResponse();\r\n    SipProvider sourceProvider = (SipProvider) responseEvent.getSource();\r\n    boolean processed = false;\r\n    if (response.getStatusCode() == Response.OK) {\r\n        processOK(clientTransaction, response);\r\n        processed = true;\r\n    } else if (response.getStatusCode() == Response.NOT_IMPLEMENTED) {\r\n        processNotImplemented(clientTransaction, response);\r\n        processed = true;\r\n    } else if (response.getStatusCode() == Response.TRYING) {\r\n    } else if (response.getStatusCode() == Response.UNAUTHORIZED || response.getStatusCode() == Response.PROXY_AUTHENTICATION_REQUIRED || response.getStatusCode() == Response.FORBIDDEN) {\r\n        processAuthenticationChallenge(clientTransaction, response, sourceProvider);\r\n        processed = true;\r\n    } else if (response.getStatusCode() == Response.INTERVAL_TOO_BRIEF) {\r\n        processIntervalTooBrief(response);\r\n        processed = true;\r\n    } else if (response.getStatusCode() >= 400) {\r\n        logger.error(\"Received an error response (\" + response.getStatusCode() + \")\");\r\n        int registrationStateReason = RegistrationStateChangeEvent.REASON_NOT_SPECIFIED;\r\n        if (response.getStatusCode() == Response.NOT_FOUND)\r\n            registrationStateReason = RegistrationStateChangeEvent.REASON_NON_EXISTING_USER_ID;\r\n        this.setRegistrationState(RegistrationState.CONNECTION_FAILED, registrationStateReason, \"Received an error while trying to register. \" + \"Server returned error:\" + response.getReasonPhrase());\r\n        processed = true;\r\n    }\r\n    return processed;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.globaldisplaydetails.GlobalDisplayDetailsImpl.getDisplayName",
	"Comment": "returns default display name for the given provider or the global displayname.",
	"Method": "String getDisplayName(ProtocolProviderService pps){\r\n    final OperationSetServerStoredAccountInfo accountInfoOpSet = pps.getOperationSet(OperationSetServerStoredAccountInfo.class);\r\n    String displayName = \"\";\r\n    if (accountInfoOpSet != null) {\r\n        displayName = AccountInfoUtils.getDisplayName(accountInfoOpSet);\r\n    }\r\n    if (displayName == null || displayName.length() == 0) {\r\n        displayName = getGlobalDisplayName();\r\n        if (displayName == null || displayName.length() == 0) {\r\n            displayName = pps.getAccountID().getUserID();\r\n            if (displayName != null) {\r\n                int atIndex = displayName.lastIndexOf(\"@\");\r\n                if (atIndex > 0)\r\n                    displayName = displayName.substring(0, atIndex);\r\n            }\r\n        }\r\n    }\r\n    return displayName;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.removeActiveFileTransfer",
	"Comment": "removes the given file transfer id from the list of activefile transfers.",
	"Method": "void removeActiveFileTransfer(String id){\r\n    synchronized (activeFileTransfers) {\r\n        activeFileTransfers.remove(id);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.galagonotification.GalagoPopupMessageHandler.getIcon",
	"Comment": "gets the icon of the specified popupmessage as abufferedimage instance so that it can be sent to thefreedesktop.org desktop notifications server for display.",
	"Method": "BufferedImage getIcon(PopupMessage popupMessage){\r\n    byte[] iconBytes = popupMessage.getIcon();\r\n    BufferedImage icon = null;\r\n    if ((iconBytes != null) && (iconBytes.length > 0))\r\n        try {\r\n            icon = ImageIO.read(new ByteArrayInputStream(iconBytes));\r\n        } catch (IOException ioe) {\r\n            logger.error(\"Failed to create BufferedImage from byte[].\", ioe);\r\n        }\r\n    return icon;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.security.CredentialsCache.getCachedAuthorizationHeader",
	"Comment": "returns an authorization header cached for the specified call id and nullif no authorization header has been previously cached for this call.",
	"Method": "AuthorizationHeader getCachedAuthorizationHeader(String callid){\r\n    return this.authenticatedCalls.get(callid);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.OneToOneCallPanel.createTopComponent",
	"Comment": "creates the toolbar panel for this chat window, depending on the currentoperating system.",
	"Method": "JComponent createTopComponent(){\r\n    JComponent topComponent = null;\r\n    if (OSUtils.IS_MAC) {\r\n        Color macPanelBackground = new Color(GuiActivator.getResources().getColor(\"service.gui.MAC_PANEL_BACKGROUND\"));\r\n        if (callContainer.getCallWindow() instanceof Window) {\r\n            UnifiedToolBar macToolbarPanel = new UnifiedToolBar();\r\n            MacUtils.makeWindowLeopardStyle(callContainer.getCallWindow().getFrame().getRootPane());\r\n            macToolbarPanel.getComponent().setLayout(new BorderLayout());\r\n            macToolbarPanel.disableBackgroundPainter();\r\n            macToolbarPanel.installWindowDraggerOnWindow(callContainer.getCallWindow().getFrame());\r\n            topComponent = macToolbarPanel.getComponent();\r\n        } else {\r\n            topComponent = new TransparentPanel(new BorderLayout());\r\n            topComponent.setOpaque(true);\r\n            topComponent.setBackground(macPanelBackground);\r\n        }\r\n        peerPanel.setOpaque(!isFullScreen());\r\n        peerPanel.setBackground(macPanelBackground);\r\n    } else {\r\n        JPanel panel = new TransparentPanel(new BorderLayout());\r\n        panel.setBorder(BorderFactory.createEmptyBorder(3, 3, 3, 3));\r\n        topComponent = panel;\r\n    }\r\n    return topComponent;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockChatRoom.getMembers",
	"Comment": "returns a list of chatroommembers corresponding to allmembers currently participating in this room.",
	"Method": "List<ChatRoomMember> getMembers(){\r\n    return members;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockPersistentPresenceOperationSet.getPresenceStatus",
	"Comment": "returns a presencestatus instance representing the state this provideris currently in.",
	"Method": "PresenceStatus getPresenceStatus(){\r\n    return presenceStatus;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ContactJabberImpl.getServerDisplayName",
	"Comment": "returns the display name used when the contact was resolved.used to detect renames.",
	"Method": "String getServerDisplayName(){\r\n    return serverDisplayName;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipRegistrarConnection.unregisterInternal",
	"Comment": "sends a unregistered request to the registrar thus ending our registration.",
	"Method": "void unregisterInternal(boolean sendUnregister,boolean userRequest){\r\n    if (getRegistrationState() == RegistrationState.UNREGISTERED) {\r\n        if (logger.isTraceEnabled())\r\n            logger.trace(\"Trying to unregister when already unresgistered\");\r\n        return;\r\n    }\r\n    cancelPendingRegistrations();\r\n    if (this.registerRequest == null) {\r\n        logger.error(\"Couldn't find the initial register request\");\r\n        setRegistrationState(RegistrationState.CONNECTION_FAILED, RegistrationStateChangeEvent.REASON_INTERNAL_ERROR, \"Could not find the initial regiest request.\");\r\n        throw new OperationFailedException(\"Could not find the initial register request.\", OperationFailedException.INTERNAL_ERROR);\r\n    }\r\n    setRegistrationState(RegistrationState.UNREGISTERING, RegistrationStateChangeEvent.REASON_USER_REQUEST, \"\");\r\n    if (!sendUnregister)\r\n        return;\r\n    Request unregisterRequest;\r\n    try {\r\n        unregisterRequest = sipProvider.getMessageFactory().createUnRegisterRequest(registerRequest, getNextCSeqValue());\r\n    } catch (InvalidArgumentException ex) {\r\n        logger.error(\"Unable to create an unREGISTER request.\", ex);\r\n        setRegistrationState(RegistrationState.CONNECTION_FAILED, RegistrationStateChangeEvent.REASON_INTERNAL_ERROR, \"Unable to set Expires Header\");\r\n        throw new OperationFailedException(\"Unable to set Expires Header\", OperationFailedException.INTERNAL_ERROR, ex);\r\n    }\r\n    if (userRequest) {\r\n        SipApplicationData.setApplicationData(unregisterRequest, SipApplicationData.KEY_USER_REQUEST, userRequest);\r\n    }\r\n    ClientTransaction unregisterTransaction = null;\r\n    try {\r\n        unregisterTransaction = getJainSipProvider().getNewClientTransaction(unregisterRequest);\r\n    } catch (TransactionUnavailableException ex) {\r\n        logger.error(\"Unable to create a unregister transaction\", ex);\r\n        setRegistrationState(RegistrationState.CONNECTION_FAILED, RegistrationStateChangeEvent.REASON_INTERNAL_ERROR, \"Unable to create a unregister transaction\");\r\n        throw new OperationFailedException(\"Unable to create a unregister transaction\", OperationFailedException.INTERNAL_ERROR, ex);\r\n    }\r\n    try {\r\n        callIdHeader = null;\r\n        unregisterTransaction.sendRequest();\r\n        if (!(getRegistrationState().equals(RegistrationState.REGISTERED) || getRegistrationState().equals(RegistrationState.UNREGISTERING))) {\r\n            if (logger.isInfoEnabled())\r\n                logger.info(\"Setting state to UNREGISTERED.\");\r\n            setRegistrationState(RegistrationState.UNREGISTERED, RegistrationStateChangeEvent.REASON_USER_REQUEST, null);\r\n            if (regTrans != null && regTrans.getState().getValue() <= TransactionState.PROCEEDING.getValue()) {\r\n                if (logger.isTraceEnabled())\r\n                    logger.trace(\"Will try to terminate reg tran ...\");\r\n                regTrans.terminate();\r\n                if (logger.isTraceEnabled())\r\n                    logger.trace(\"Transaction terminated!\");\r\n            }\r\n        }\r\n    } catch (SipException ex) {\r\n        logger.error(\"Failed to send unregister request\", ex);\r\n        setRegistrationState(RegistrationState.CONNECTION_FAILED, RegistrationStateChangeEvent.REASON_INTERNAL_ERROR, \"Unable to create a unregister transaction\");\r\n        throw new OperationFailedException(\"Failed to send unregister request\", OperationFailedException.INTERNAL_ERROR, ex);\r\n    }\r\n}"
}, {
	"Path": "io.lettuce.core.ZStoreArgs.min",
	"Comment": "aggregate scores of elements existing across multiple sets by using the lowest score.",
	"Method": "ZStoreArgs min(ZStoreArgs min){\r\n    this.aggregate = Aggregate.MIN;\r\n    return this;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetBasicInstantMessagingJabberImpl.subscribeForGmailNotifications",
	"Comment": "subscribes this provider as interested in receiving notifications fornew mail messages from google mail services such as gmail or google apps.",
	"Method": "void subscribeForGmailNotifications(){\r\n    String accountIDService = jabberProvider.getAccountID().getService();\r\n    boolean notificationsAreSupported = jabberProvider.isFeatureSupported(accountIDService, NewMailNotificationIQ.NAMESPACE);\r\n    if (!notificationsAreSupported) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(accountIDService + \" does not seem to provide a Gmail notification \" + \" service so we won't be trying to subscribe for it\");\r\n        return;\r\n    }\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(accountIDService + \" seems to provide a Gmail notification \" + \" service so we will try to subscribe for it\");\r\n    ProviderManager providerManager = ProviderManager.getInstance();\r\n    providerManager.addIQProvider(MailboxIQ.ELEMENT_NAME, MailboxIQ.NAMESPACE, new MailboxIQProvider());\r\n    providerManager.addIQProvider(NewMailNotificationIQ.ELEMENT_NAME, NewMailNotificationIQ.NAMESPACE, new NewMailNotificationProvider());\r\n    Connection connection = jabberProvider.getConnection();\r\n    connection.addPacketListener(new MailboxIQListener(), new PacketTypeFilter(MailboxIQ.class));\r\n    connection.addPacketListener(new NewMailNotificationListener(), new PacketTypeFilter(NewMailNotificationIQ.class));\r\n    if (opSetPersPresence.getCurrentStatusMessage().equals(JabberStatusEnum.OFFLINE))\r\n        return;\r\n    MailboxQueryIQ mailboxQuery = new MailboxQueryIQ();\r\n    if (logger.isTraceEnabled())\r\n        logger.trace(\"sending mailNotification for acc: \" + jabberProvider.getAccountID().getAccountUniqueID());\r\n    jabberProvider.getConnection().sendPacket(mailboxQuery);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.callhistory.CallHistorySourceContact.getDisplayDetails",
	"Comment": "returns the display details of this search contact. this could be anyimportant information that should be shown to the user.",
	"Method": "String getDisplayDetails(){\r\n    return displayDetails;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatConversationPanel.getMessageContents",
	"Comment": "retrieves the contents of the sent message with the given id.",
	"Method": "String getMessageContents(String messageUID){\r\n    Element root = document.getDefaultRootElement();\r\n    Element e = document.getElement(root, Attribute.ID, ChatHtmlUtils.MESSAGE_TEXT_ID + messageUID);\r\n    if (e == null) {\r\n        logger.warn(\"Could not find message with ID \" + messageUID);\r\n        return null;\r\n    }\r\n    Object original_message = e.getAttributes().getAttribute(ChatHtmlUtils.ORIGINAL_MESSAGE_ATTRIBUTE);\r\n    if (original_message == null) {\r\n        logger.warn(\"Message with ID \" + messageUID + \" does not have original_message attribute\");\r\n        return null;\r\n    }\r\n    String res = StringEscapeUtils.unescapeXml(original_message.toString());\r\n    res = res.replace(\"&#10;\", \"\");\r\n    return res;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl.createCall",
	"Comment": "creates a new call and invites a specific callpeer toit given by her string uri.",
	"Method": "Call createCall(String callee,CallConference conference){\r\n    Address toAddress = protocolProvider.parseAddressString(callee);\r\n    return createOutgoingCall(toAddress, null, conference);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.demuxcontactsource.DemuxContactSource.isPreferredContactDetail",
	"Comment": "indicates if the given contact detail has a pair of operationset andprotocolproviderservice that matches the preferred pairs indicated forthis contact source.",
	"Method": "boolean isPreferredContactDetail(ContactDetail c){\r\n    Iterator<Class<? extends OperationSet>> preferredProviderOpSets = preferredProtocolProviders.keySet().iterator();\r\n    while (preferredProviderOpSets.hasNext()) {\r\n        Class<? extends OperationSet> opSetClass = preferredProviderOpSets.next();\r\n        ProtocolProviderService preferredProvider = c.getPreferredProtocolProvider(opSetClass);\r\n        if (preferredProvider != null && preferredProvider.equals(preferredProtocolProviders.get(opSetClass)) || (preferredProvider == null && c.getSupportedOperationSets() != null && c.getSupportedOperationSets().contains(opSetClass))) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ProtocolIconAimImpl.getConnectingIcon",
	"Comment": "returns the icon image used to represent the protocol connecting state.",
	"Method": "byte[] getConnectingIcon(){\r\n    return getImageInBytes(\"aimConnectingIcon\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.notifsource.NotificationGroup.getNotifications",
	"Comment": "returns an iterator over a list of all notification contactscontained in this group.",
	"Method": "Iterator<? extends UIContact> getNotifications(){\r\n    return contacts.values().iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.CallPeerJabberImpl.setSenders",
	"Comment": "set the current value of the senders field of the content withname mediatype in the jingle session with this callpeer",
	"Method": "void setSenders(MediaType mediaType,SendersEnum senders){\r\n    switch(mediaType) {\r\n        case AUDIO:\r\n            this.audioSenders = senders;\r\n            break;\r\n        case VIDEO:\r\n            this.videoSenders = senders;\r\n            break;\r\n        default:\r\n            throw new IllegalArgumentException(\"mediaType\");\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.whiteboard.gui.whiteboardshapes.WhiteboardShapePolyLine.createPoly",
	"Comment": "creates a generalpath with all the whiteboardpoint.this generalpath is used for display.",
	"Method": "GeneralPath createPoly(AffineTransform w2v){\r\n    GeneralPath polyline = new GeneralPath(GeneralPath.WIND_EVEN_ODD, points.size());\r\n    if (points.size() <= 0)\r\n        return polyline;\r\n    WhiteboardPoint start = points.get(0);\r\n    Point2D w = new Point2D.Double(start.getX(), start.getY());\r\n    Point2D v = w2v.transform(w, null);\r\n    polyline.moveTo((int) v.getX(), (int) v.getY());\r\n    WhiteboardPoint p;\r\n    for (int i = 0; i < points.size(); i++) {\r\n        p = points.get(i);\r\n        w = new Point2D.Double(p.getX(), p.getY());\r\n        v = w2v.transform(w, null);\r\n        polyline.lineTo((int) v.getX(), (int) v.getY());\r\n    }\r\n    return polyline;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.VolatileContactJabberImpl.toString",
	"Comment": "returns a string representation of this contact, containing most of itsrepresentative details.",
	"Method": "String toString(){\r\n    StringBuffer buff = new StringBuffer(\"VolatileJabberContact[ id=\");\r\n    buff.append(getAddress()).append(\"]\");\r\n    return buff.toString();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.httputil.HttpUtilActivator.getResources",
	"Comment": "returns the service giving access to all application resources.",
	"Method": "ResourceManagementService getResources(){\r\n    if (resourceService == null) {\r\n        resourceService = ResourceManagementServiceUtils.getService(bundleContext);\r\n    }\r\n    return resourceService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ScServiceDiscoveryManager.getNodeFeatures",
	"Comment": "returns a list of the features defined in the node. forexample, the entity caps protocol specifies that an xmpp clientshould answer with each feature supported by the client versionor extension.",
	"Method": "List<String> getNodeFeatures(){\r\n    return getFeatures();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.ProtocolProviderActivator.getConfigurationService",
	"Comment": "gets the configurationservice to be used by the classes inthe bundle represented by protocolprovideractivator.",
	"Method": "ConfigurationService getConfigurationService(){\r\n    if (configurationService == null) {\r\n        configurationService = (ConfigurationService) bundleContext.getService(bundleContext.getServiceReference(ConfigurationService.class.getName()));\r\n    }\r\n    return configurationService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.callhistory.CallHistoryServiceImpl.removeHistorySearchProgressListeners",
	"Comment": "removes the registered callhistorysearchprogresslisteners from the givenhistoryreader",
	"Method": "void removeHistorySearchProgressListeners(HistoryReader reader){\r\n    synchronized (progressListeners) {\r\n        for (SearchProgressWrapper l : progressListeners.values()) {\r\n            l.clear();\r\n            reader.removeSearchProgressListener(l);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ChatRoomConferenceCallsListPanel.removeConference",
	"Comment": "removes the given conferencedescription from the list of chat conferences.",
	"Method": "void removeConference(ConferenceDescription chatConference){\r\n    conferenceCallsListModel.removeElement(chatConference);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ConversationTabbedPane.highlightTab",
	"Comment": "when a tab is highlighted sets an indicator of the number of unreadmessages in this tab.",
	"Method": "void highlightTab(int tabIndex,int unreadMessageNumber){\r\n    Component c = this.getComponentAt(tabIndex);\r\n    String tabTitle = \"\";\r\n    if (c instanceof ChatPanel)\r\n        tabTitle = ((ChatPanel) c).getChatSession().getChatName();\r\n    else if (c instanceof CallPanel)\r\n        tabTitle = ((CallPanel) c).getCallTitle();\r\n    if (unreadMessageNumber > 0)\r\n        tabTitle = \"(\" + unreadMessageNumber + \") \" + tabTitle;\r\n    this.setTitleAt(tabIndex, tabTitle);\r\n    super.highlightTab(tabIndex);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.gibberishaccregwizz.Resources.getString",
	"Comment": "returns an internationalized string corresponding to the given key.",
	"Method": "String getString(String key){\r\n    return getResources().getI18NString(key);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.ChatRoomListImpl.registrationStateChanged",
	"Comment": "listens for changes of providers registration state, so we can use onlyregistered providers.",
	"Method": "void registrationStateChanged(RegistrationStateChangeEvent evt){\r\n    ProtocolProviderService pps = evt.getProvider();\r\n    if (evt.getNewState() == RegistrationState.REGISTERED) {\r\n    } else if (evt.getNewState() == RegistrationState.UNREGISTERED || evt.getNewState() == RegistrationState.AUTHENTICATION_FAILED || evt.getNewState() == RegistrationState.CONNECTION_FAILED) {\r\n        ChatRoomProviderWrapper wrapper = findServerWrapperFromProvider(pps);\r\n        if (wrapper != null) {\r\n            removeChatProvider(wrapper, false);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetBasicTelephonyJabberImpl.accept",
	"Comment": "tests whether or not the specified packet should be handled by thisoperation set. this method is called by smack prior to packet deliveryand it would only accept jingleiqs that are either sessioninitiations with rtp content or belong to sessions that are alreadyhandled by this operation set.",
	"Method": "boolean accept(Packet packet){\r\n    if (!(packet instanceof JingleIQ)) {\r\n        String packetID = packet.getPacketID();\r\n        AbstractCallPeer<?, ?> callPeer = activeCallsRepository.findCallPeerBySessInitPacketID(packetID);\r\n        if (callPeer != null) {\r\n            XMPPError error = packet.getError();\r\n            if (error != null) {\r\n                String errorMessage = error.getMessage();\r\n                logger.error(\"Received an error: code=\" + error.getCode() + \" message=\" + errorMessage);\r\n                String message;\r\n                if (errorMessage == null) {\r\n                    Roster roster = getProtocolProvider().getConnection().getRoster();\r\n                    String packetFrom = packet.getFrom();\r\n                    message = \"Service unavailable\";\r\n                    if (!roster.contains(packetFrom)) {\r\n                        message += \": try adding the contact \" + packetFrom + \" to your contact list first.\";\r\n                    }\r\n                } else\r\n                    message = errorMessage;\r\n                callPeer.setState(CallPeerState.FAILED, message);\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    if (packet instanceof JingleIQ) {\r\n        JingleIQ jingleIQ = (JingleIQ) packet;\r\n        if (jingleIQ.getAction() == JingleAction.SESSION_INITIATE) {\r\n            return jingleIQ.containsContentChildOfType(RtpDescriptionPacketExtension.class);\r\n        }\r\n        String sid = jingleIQ.getSID();\r\n        return (activeCallsRepository.findSID(sid) != null);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetMultiUserChatJabberImpl.fireInvitationEvent",
	"Comment": "delivers a chatroominvitationreceivedevent to allregistered chatroominvitationlisteners.",
	"Method": "void fireInvitationEvent(ChatRoom targetChatRoom,String inviter,String reason,byte[] password){\r\n    ChatRoomInvitationJabberImpl invitation = new ChatRoomInvitationJabberImpl(targetChatRoom, inviter, reason, password);\r\n    fireInvitationReceived(invitation);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.growlnotification.GrowlNotificationServiceImpl.start",
	"Comment": "starts the service. creates a growl notifier, and check the currentregistered protocol providers which supports basicim and adds messagelistener to them.",
	"Method": "void start(BundleContext bc){\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Starting the Growl Notification implementation.\");\r\n    ResourceManagementService resources = GrowlNotificationActivator.getResources();\r\n    byte[] sipIcon = resources.getImageInBytes(\"service.gui.SIP_COMMUNICATOR_LOGO_45x45\");\r\n    String[] dict = { SHOW_POPUP_MESSAGE_TYPE };\r\n    growl = new Growl(resources.getSettingsString(\"service.gui.APPLICATION_NAME\"), \"net.sip-communicator\", sipIcon, dict, dict);\r\n    growl.addClickedNotificationsListener(this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ChatConferenceCallsListModels.findConferenceDescription",
	"Comment": "finds conferencedescription instance from the list of conferences that matches specific conferencedescription instance.",
	"Method": "int findConferenceDescription(ConferenceDescription cd){\r\n    for (int i = 0; i < chatConferenceCalls.size(); i++) {\r\n        if (cd.compareConferenceDescription(chatConferenceCalls.get(i))) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.ProtocolProviderActivator.getProtocolProviderFactory",
	"Comment": "returns a protocolproviderfactory for a given protocolprovider.",
	"Method": "ProtocolProviderFactory getProtocolProviderFactory(String protocolName){\r\n    String osgiFilter = \"(\" + ProtocolProviderFactory.PROTOCOL + \"=\" + protocolName + \")\";\r\n    ProtocolProviderFactory protocolProviderFactory = null;\r\n    try {\r\n        ServiceReference[] serRefs = bundleContext.getServiceReferences(ProtocolProviderFactory.class.getName(), osgiFilter);\r\n        if ((serRefs != null) && (serRefs.length != 0)) {\r\n            protocolProviderFactory = (ProtocolProviderFactory) bundleContext.getService(serRefs[0]);\r\n        }\r\n    } catch (InvalidSyntaxException ex) {\r\n        if (logger.isInfoEnabled())\r\n            logger.info(\"ProtocolProviderActivator : \" + ex);\r\n    }\r\n    return protocolProviderFactory;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.icqaccregwizz.IcqAccountRegistrationWizard.getUserNameExample",
	"Comment": "returns an example string, which should indicate to the user how theuser name should look like.",
	"Method": "String getUserNameExample(){\r\n    return FirstWizardPage.USER_NAME_EXAMPLE;\r\n}"
}, {
	"Path": "net.librec.similarity.JaccardSimilarity.getCorrelation",
	"Comment": "find the common rated items by this user and that user, or the commonusers have rated this item or that item. and then return the similarity.",
	"Method": "double getCorrelation(VectorBasedSequentialSparseVector thisVector,VectorBasedSequentialSparseVector thatVector){\r\n    Set<Integer> elements = new HashSet();\r\n    for (Vector.VectorEntry vectorEntry : thisVector) {\r\n        elements.add(vectorEntry.index());\r\n    }\r\n    for (Vector.VectorEntry vectorEntry : thatVector) {\r\n        elements.add(vectorEntry.index());\r\n    }\r\n    int numAllElements = elements.size();\r\n    int numCommonElements = thisVector.getNumEntries() + thatVector.getNumEntries() - numAllElements;\r\n    return (numCommonElements + 0.0) / numAllElements;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatContact.getAvatar",
	"Comment": "returns the avatar image corresponding to the source contact. in the caseof multi user chat contact returns null.",
	"Method": "ImageIcon getAvatar(){\r\n    byte[] avatarBytes = getAvatarBytes();\r\n    if (this.avatarBytes != avatarBytes) {\r\n        this.avatarBytes = avatarBytes;\r\n        this.avatar = null;\r\n    }\r\n    if ((this.avatar == null) && (this.avatarBytes != null) && (this.avatarBytes.length > 0))\r\n        this.avatar = ImageUtils.getScaledRoundedIcon(this.avatarBytes, AVATAR_ICON_WIDTH, AVATAR_ICON_HEIGHT);\r\n    return this.avatar;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommMenuBar.getUIClassID",
	"Comment": "returns the name of the l&f class that renders this component.",
	"Method": "String getUIClassID(){\r\n    return UIClassID;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.contactsource.EditableContactDetail.getSourceContact",
	"Comment": "returns the source contact that contains this contact detail.",
	"Method": "EditableSourceContact getSourceContact(){\r\n    return this.sourceContact;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactImpl.unsetParentGroup",
	"Comment": "if parentgroup was the parent of this meta contact then itsets it to null. call this method when removing this contact from ameta contact group.",
	"Method": "void unsetParentGroup(MetaContactGroupImpl parentGrp){\r\n    synchronized (getParentGroupModLock()) {\r\n        if (parentGroup == parentGrp)\r\n            parentGroup = null;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.accountinfo.AccountInfoActivator.getProtocolProviderFactories",
	"Comment": "returns all protocolproviderfactorys obtained from the bundlecontext.",
	"Method": "Map<Object, ProtocolProviderFactory> getProtocolProviderFactories(){\r\n    Map<Object, ProtocolProviderFactory> providerFactoriesMap = new Hashtable<Object, ProtocolProviderFactory>();\r\n    ServiceReference[] serRefs = null;\r\n    try {\r\n        serRefs = bundleContext.getServiceReferences(ProtocolProviderFactory.class.getName(), null);\r\n    } catch (InvalidSyntaxException e) {\r\n        logger.error(\"LoginManager : \" + e);\r\n    }\r\n    for (int i = 0; i < serRefs.length; i++) {\r\n        ProtocolProviderFactory providerFactory = (ProtocolProviderFactory) bundleContext.getService(serRefs[i]);\r\n        providerFactoriesMap.put(serRefs[i].getProperty(ProtocolProviderFactory.PROTOCOL), providerFactory);\r\n    }\r\n    return providerFactoriesMap;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.LocalUserAdHocChatRoomPresenceChangeEvent.getAdHocMultiUserChatOpSet",
	"Comment": "returns the operationsetadhocmultiuserchat, where this event hasoccurred.",
	"Method": "OperationSetAdHocMultiUserChat getAdHocMultiUserChatOpSet(){\r\n    return (OperationSetAdHocMultiUserChat) getSource();\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.launchutils.LaunchArgHandler.getInstance",
	"Comment": "creates a singleton instance of the launcherarghandler if necessary andreturns a reference to it.",
	"Method": "LaunchArgHandler getInstance(){\r\n    if (argHandler == null) {\r\n        argHandler = new LaunchArgHandler();\r\n    }\r\n    return argHandler;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.account.AccountListCellRenderer.getListCellRendererComponent",
	"Comment": "returns the renderer component for the cell given by all the parameters.",
	"Method": "Component getListCellRendererComponent(JList list,Object value,int index,boolean isSelected,boolean cellHasFocus){\r\n    this.account = (Account) value;\r\n    Icon accountIcon = account.getIcon();\r\n    if (accountIcon != null)\r\n        accountLabel.setIcon(accountIcon);\r\n    accountLabel.setText(account.getName());\r\n    Icon statusIcon = account.getStatusIcon();\r\n    if (statusIcon != null)\r\n        statusLabel.setIcon(statusIcon);\r\n    String statusName = account.getStatusName();\r\n    if (statusName != null)\r\n        statusLabel.setText(statusName);\r\n    setEnabled(list.isEnabled());\r\n    setFont(list.getFont());\r\n    if (!account.isEnabled()) {\r\n        accountLabel.setForeground(Color.GRAY);\r\n        statusLabel.setForeground(Color.GRAY);\r\n    } else {\r\n        accountLabel.setForeground(Color.BLACK);\r\n        statusLabel.setForeground(Color.BLACK);\r\n    }\r\n    this.index = index;\r\n    this.isSelected = isSelected;\r\n    this.setBounds(0, 0, list.getWidth(), getPreferredSize().height);\r\n    this.addCheckBox(account);\r\n    return this;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ProtocolIconIrcImpl.getConnectingIcon",
	"Comment": "returns the icon image used to represent the protocol connecting state.",
	"Method": "byte[] getConnectingIcon(){\r\n    return getImageInBytes(\"ircConnectingIcon\");\r\n}"
}, {
	"Path": "com.keybox.manage.db.PublicKeyDB.deleteUnassignedKeysByProfile",
	"Comment": "deletes all ssh keys for users that are not assigned in a profile",
	"Method": "void deleteUnassignedKeysByProfile(Connection con,Long profileId){\r\n    try {\r\n        PreparedStatement stmt = con.prepareStatement(\"delete from public_keys where profile_id=? and user_id not in (select user_id from user_map where profile_id=?)\");\r\n        stmt.setLong(1, profileId);\r\n        stmt.setLong(2, profileId);\r\n        stmt.execute();\r\n        DBUtils.closeStmt(stmt);\r\n    } catch (Exception e) {\r\n        log.error(e.toString(), e);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.TransportManagerJabberImpl.incrementGeneration",
	"Comment": "increments the generation that we are assigning candidates.",
	"Method": "void incrementGeneration(){\r\n    currentGeneration++;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.GibberishActivator.getBundleContext",
	"Comment": "returns a reference to the bundle context that we were started with.",
	"Method": "BundleContext getBundleContext(){\r\n    return bundleContext;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomMemberJabberImpl.getRole",
	"Comment": "returns the role of this chat room member in its containing room.",
	"Method": "ChatRoomMemberRole getRole(){\r\n    if (role == null) {\r\n        Occupant o = containingRoom.getMultiUserChat().getOccupant(containingRoom.getIdentifier() + \"/\" + nickName);\r\n        if (o == null) {\r\n            return ChatRoomMemberRole.GUEST;\r\n        } else\r\n            role = ChatRoomJabberImpl.smackRoleToScRole(o.getRole(), o.getAffiliation());\r\n    }\r\n    return role;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl.isRegistrationRequiredForCalling",
	"Comment": "indicates whether or not this provider must registeredwhen placing outgoing calls.",
	"Method": "boolean isRegistrationRequiredForCalling(){\r\n    return getAccountID().getAccountPropertyBoolean(ProtocolProviderFactory.MUST_REGISTER_TO_CALL, true);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.PresenceManager.parseISupportWatch",
	"Comment": "parse the isupport parameter for watch command support and list size.",
	"Method": "Integer parseISupportWatch(IIRCState state){\r\n    final String value = state.getServerOptions().getKey(ISupport.WATCH.name());\r\n    if (value == null) {\r\n        LOGGER.trace(\"No ISUPPORT parameter \" + ISupport.WATCH.name() + \" available.\");\r\n        return null;\r\n    }\r\n    if (LOGGER.isDebugEnabled()) {\r\n        LOGGER.debug(\"Setting ISUPPORT parameter \" + ISupport.WATCH.name() + \" to \" + value);\r\n    }\r\n    try {\r\n        return new Integer(value);\r\n    } catch (RuntimeException e) {\r\n        LOGGER.warn(\"Failed to parse WATCH value.\", e);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ClientCapabilities.processRequest",
	"Comment": "receives options requests and replies with an ok response containingmethods that we support.",
	"Method": "boolean processRequest(RequestEvent requestEvent){\r\n    Response optionsOK = null;\r\n    try {\r\n        optionsOK = provider.getMessageFactory().createResponse(Response.OK, requestEvent.getRequest());\r\n        for (String method : provider.getSupportedMethods()) {\r\n            if (!method.equals(Request.REGISTER))\r\n                optionsOK.addHeader(provider.getHeaderFactory().createAllowHeader(method));\r\n        }\r\n        addAllowEventsHeader(optionsOK);\r\n    } catch (ParseException ex) {\r\n        logger.warn(\"Failed to create an incoming OPTIONS request\", ex);\r\n        return false;\r\n    }\r\n    try {\r\n        SipStackSharing.getOrCreateServerTransaction(requestEvent).sendResponse(optionsOK);\r\n    } catch (TransactionUnavailableException ex) {\r\n        if (logger.isInfoEnabled())\r\n            logger.info(\"Failed to respond to an incoming \" + \"transactionless OPTIONS request\");\r\n        if (logger.isTraceEnabled())\r\n            logger.trace(\"Exception was:\", ex);\r\n        return false;\r\n    } catch (InvalidArgumentException ex) {\r\n        logger.warn(\"Failed to send an incoming OPTIONS request\", ex);\r\n        return false;\r\n    } catch (SipException ex) {\r\n        logger.warn(\"Failed to send an incoming OPTIONS request\", ex);\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.UnknownContactPanel.addUnknownContact",
	"Comment": "clicks the add contact button in order to add the unknown contactto the contact list.",
	"Method": "void addUnknownContact(){\r\n    addButton.doClick();\r\n}"
}, {
	"Path": "io.lettuce.core.ZStoreArgs.max",
	"Comment": "aggregate scores of elements existing across multiple sets by using the highest score.",
	"Method": "ZStoreArgs max(ZStoreArgs max){\r\n    this.aggregate = Aggregate.MAX;\r\n    return this;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ContactListModel.contentAdded",
	"Comment": "informs interested listeners that new cells are added from startindex toendindex.",
	"Method": "void contentAdded(int startIndex,int endIndex){\r\n    fireIntervalAdded(this, startIndex, endIndex);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaHandler.setKeyFrameControlFromVideoStream",
	"Comment": "sets the keyframecontrol currently known to thismediahandler made available by a specificvideomediastream.",
	"Method": "void setKeyFrameControlFromVideoStream(VideoMediaStream videoStream){\r\n    KeyFrameControl keyFrameControl = (videoStream == null) ? null : videoStream.getKeyFrameControl();\r\n    if (this.keyFrameControl != keyFrameControl) {\r\n        if (this.keyFrameControl != null)\r\n            this.keyFrameControl.removeKeyFrameRequester(keyFrameRequester);\r\n        this.keyFrameControl = keyFrameControl;\r\n        if (this.keyFrameControl != null)\r\n            this.keyFrameControl.addKeyFrameRequester(-1, keyFrameRequester);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.osdependent.OsDependentActivator.getShutdownService",
	"Comment": "gets a reference to a shutdownservice implementation currentlyregistered in the bundlecontext of the activeosdependentactivator instance.the returned reference to shutdownservice is not cached.",
	"Method": "ShutdownService getShutdownService(){\r\n    return ServiceUtils.getService(bundleContext, ShutdownService.class);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.JabberAccountRegistrationForm.isModification",
	"Comment": "indicates if this wizard is modifying an existing account or is creatinga new one.",
	"Method": "boolean isModification(){\r\n    return isModification;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.history.HistoryReaderImpl.addSearchProgressListener",
	"Comment": "adding progress listener for monitoring progress of search process",
	"Method": "void addSearchProgressListener(HistorySearchProgressListener listener){\r\n    synchronized (progressListeners) {\r\n        progressListeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.resources.ResourceManagementServiceImpl.getSoundURLForPath",
	"Comment": "returns the url of the sound corresponding to the given path.",
	"Method": "URL getSoundURLForPath(String path){\r\n    return getSoundPack().getClass().getClassLoader().getResource(path);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.AdHocConferenceChatTransport.getParentChatSession",
	"Comment": "returns the parent session of this chat transport. a chatsessioncould contain more than one transports.",
	"Method": "ChatSession getParentChatSession(){\r\n    return chatSession;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.RootContactGroupJabberImpl.subgroups",
	"Comment": "returns an iterator over the sub groups that thiscontactgroup contains.",
	"Method": "Iterator<ContactGroup> subgroups(){\r\n    return new ArrayList<ContactGroup>(subGroups).iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.JingleNodesCandidateDatagramSocket.logPacket",
	"Comment": "determines whether a packet should be logged, given the number of sentor received packets.",
	"Method": "boolean logPacket(long numOfPacket){\r\n    return (numOfPacket == 1) || (numOfPacket == 300) || (numOfPacket == 500) || (numOfPacket == 1000) || ((numOfPacket % 5000) == 0);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetPersistentPresenceJabberImpl.createUnresolvedContact",
	"Comment": "creates and returns a unresolved contact from the specifiedaddress and persistentdata.",
	"Method": "Contact createUnresolvedContact(String address,String persistentData,ContactGroup parentGroup,Contact createUnresolvedContact,String address,String persistentData){\r\n    return createUnresolvedContact(address, persistentData, getServerStoredContactListRoot());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.MainFrame.removeSearchFieldListener",
	"Comment": "removes the given textfieldchangelistener that listens for anychanges that occur in the search field.",
	"Method": "void removeSearchFieldListener(TextFieldChangeListener l){\r\n    searchField.addTextChangeListener(l);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AccountInfoUtils.getAddress",
	"Comment": "returns the address of the account, to which the givenaccountinfoopset belongs.",
	"Method": "String getAddress(OperationSetServerStoredAccountInfo accountInfoOpSet){\r\n    AddressDetail address = null;\r\n    Iterator<GenericDetail> addressDetails = accountInfoOpSet.getDetails(AddressDetail.class);\r\n    if (addressDetails.hasNext())\r\n        address = (AddressDetail) addressDetails.next();\r\n    if (address == null)\r\n        return null;\r\n    return address.getAddress();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.conference.ConferenceFocusPanel.addConferenceMemberPanel",
	"Comment": "adds a conferencememberpanel to depict a specificconferencemember if there is not one yet.",
	"Method": "void addConferenceMemberPanel(ConferenceMember conferenceMember){\r\n    if (CallManager.isLocalUser(conferenceMember))\r\n        return;\r\n    if (CallManager.addressesAreEqual(conferenceMember.getAddress(), focusPeer.getAddress()))\r\n        return;\r\n    if (conferenceMemberPanels.containsKey(conferenceMember))\r\n        return;\r\n    ConferenceMemberPanel conferenceMemberPanel = new ConferenceMemberPanel(callRenderer, conferenceMember, false);\r\n    conferenceMemberPanels.put(conferenceMember, conferenceMemberPanel);\r\n    add(conferenceMemberPanel, cnstrnts);\r\n    cnstrnts.gridy++;\r\n    initSecuritySettings();\r\n    packWindow();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipRegistrarConnection.scheduleReRegistration",
	"Comment": "schedules a reregistration for after almost expires seconds. the method leaves a margin for all intervals, scheduling the registration for slightly earlier by reducing with 10% the number of seconds specified in the expires param.",
	"Method": "void scheduleReRegistration(int expires){\r\n    ReRegisterTask reRegisterTask = new ReRegisterTask();\r\n    reRegisterTimer.schedule(reRegisterTask, expires * 900);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.configuration.TestConfigurationService.testGetString",
	"Comment": "tests whether getstring properly returns string values and that itcorrectly handles corner cases.",
	"Method": "void testGetString(){\r\n    String propertyName = \"my.test.property\";\r\n    Object property = new String(\"my.test.property's value\");\r\n    configurationService.setProperty(propertyName, property);\r\n    String actualReturn = configurationService.getString(propertyName);\r\n    assertEquals(\"getString failed to retrieve a property\", property.toString(), actualReturn);\r\n    property = new Integer(7121979);\r\n    configurationService.setProperty(propertyName, property);\r\n    actualReturn = configurationService.getString(propertyName);\r\n    assertEquals(\"getString failed to retrieve a property\", property.toString(), actualReturn);\r\n    property = new String(\"\\t\\n \");\r\n    configurationService.setProperty(propertyName, property);\r\n    actualReturn = configurationService.getString(propertyName);\r\n    assertNull(\"getString did not trim a white space only string\", actualReturn);\r\n}"
}, {
	"Path": "net.librec.recommender.cf.ranking.LDARecommender.readoutParams",
	"Comment": "add to the statistics the values of theta and phi for the current state.",
	"Method": "void readoutParams(){\r\n    double sumAlpha = alpha.sum();\r\n    double sumBeta = beta.sum();\r\n    double val;\r\n    for (int userIdx = 0; userIdx < numUsers; userIdx++) {\r\n        for (int factorIdx = 0; factorIdx < numTopics; factorIdx++) {\r\n            val = (userTopicNumbers.get(userIdx, factorIdx) + alpha.get(factorIdx)) / (userTokenNumbers.get(userIdx) + sumAlpha);\r\n            userTopicProbsSum.plus(userIdx, factorIdx, val);\r\n        }\r\n    }\r\n    for (int factorIdx = 0; factorIdx < numTopics; factorIdx++) {\r\n        for (int itemIdx = 0; itemIdx < numItems; itemIdx++) {\r\n            val = (topicItemNumbers.get(factorIdx, itemIdx) + beta.get(itemIdx)) / (topicTokenNumbers.get(factorIdx) + sumBeta);\r\n            topicItemProbsSum.plus(factorIdx, itemIdx, val);\r\n        }\r\n    }\r\n    numStats++;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.macosx.MacOSXAddrBookSourceContact.waitUnlock",
	"Comment": "waits to be unlocked. this object must be synchronized before callingthis function.",
	"Method": "void waitUnlock(){\r\n    boolean continueToWait = this.locked;\r\n    while (continueToWait) {\r\n        try {\r\n            wait();\r\n            continueToWait = false;\r\n        } catch (InterruptedException ie) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.chatconfig.ChatConfigActivator.getReplacementSources",
	"Comment": "returns all replacementservices obtained from the bundlecontext.",
	"Method": "Map<String, ReplacementService> getReplacementSources(){\r\n    ServiceReference[] serRefs = null;\r\n    try {\r\n        serRefs = bundleContext.getServiceReferences(ReplacementService.class.getName(), null);\r\n    } catch (InvalidSyntaxException e) {\r\n        logger.error(\"Error : \" + e);\r\n    }\r\n    if (serRefs != null) {\r\n        for (int i = 0; i < serRefs.length; i++) {\r\n            ReplacementService replacementSources = (ReplacementService) bundleContext.getService(serRefs[i]);\r\n            replacementSourcesMap.put((String) serRefs[i].getProperty(ReplacementService.SOURCE_NAME), replacementSources);\r\n        }\r\n    }\r\n    return replacementSourcesMap;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.keybindingchooser.chooser.BindingChooser.makeAdaptor",
	"Comment": "provides a key adaptor that can provide editing functionality for theselected entry.",
	"Method": "BindingAdaptor makeAdaptor(){\r\n    return new BindingAdaptor(this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.spellcheck.LanguageMenuBar.setFaded",
	"Comment": "removes all color from an image and makes it partly translucent. originalgrayscale method written by marty stepp.",
	"Method": "void setFaded(BufferedImage image){\r\n    int width = image.getWidth();\r\n    int height = image.getHeight();\r\n    for (int row = 0; row < width; ++row) {\r\n        for (int col = 0; col < height; ++col) {\r\n            int c = image.getRGB(row, col);\r\n            int r = (((c >> 16) & 0xff) + ((c >> 8) & 0xff) + (c & 0xff)) / 3;\r\n            int newRgb = (0xff << 24) | (r << 16) | (r << 8) | r;\r\n            newRgb &= (1 << 24) - 1;\r\n            newRgb |= 128 << 24;\r\n            image.setRGB(row, col, newRgb);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.conference.ConferencePeerPanel.initStatusBar",
	"Comment": "initializes the status bar component for the given callpeer.",
	"Method": "void initStatusBar(CallPeer callPeer){\r\n    initSecurityStatusLabel();\r\n    this.setParticipantState(callPeer.getState().getLocalizedStateString());\r\n    this.addToStatusBar(holdStatusLabel);\r\n    this.addToStatusBar(muteStatusLabel);\r\n    this.addToStatusBar(dtmfLabel);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.otr.authdialog.OTRv3OutgoingSessionSwitcher.buildMenu",
	"Comment": "builds the jmenu used for switching between outgoing otrv3 sessions incase the remote party is logged in multiple locations",
	"Method": "void buildMenu(OtrContact otrContact){\r\n    if (otrContact == null || !this.contact.equals(otrContact)) {\r\n        return;\r\n    }\r\n    menu.removeAll();\r\n    java.util.List<Session> multipleInstances = OtrActivator.scOtrEngine.getSessionInstances(otrContact);\r\n    Session outgoingSession = OtrActivator.scOtrEngine.getOutgoingSession(otrContact);\r\n    int index = 0;\r\n    for (Session session : multipleInstances) {\r\n        index++;\r\n        if (!outgoingSessions.containsKey(session)) {\r\n            JMenuItem menuItem = new JRadioButtonMenuItem();\r\n            outgoingSessions.put(session, menuItem);\r\n            menuItem.addActionListener(this);\r\n        }\r\n        JMenuItem menuItem = outgoingSessions.get(session);\r\n        menuItem.setText(\"Session \" + index);\r\n        ImageIcon imageIcon = null;\r\n        switch(session.getSessionStatus(session.getReceiverInstanceTag())) {\r\n            case ENCRYPTED:\r\n                PublicKey pubKey = session.getRemotePublicKey(session.getReceiverInstanceTag());\r\n                String fingerprint = OtrActivator.scOtrKeyManager.getFingerprintFromPublicKey(pubKey);\r\n                imageIcon = OtrActivator.scOtrKeyManager.isVerified(otrContact.contact, fingerprint) ? verifiedLockedPadlockImage : unverifiedLockedPadlockImage;\r\n                break;\r\n            case FINISHED:\r\n                imageIcon = finishedPadlockImage;\r\n                break;\r\n            case PLAINTEXT:\r\n                imageIcon = unlockedPadlockImage;\r\n                break;\r\n        }\r\n        menuItem.setIcon(imageIcon);\r\n        menu.add(menuItem);\r\n        SelectedObject selectedObject = new SelectedObject(imageIcon, session);\r\n        buttonGroup.add(menuItem);\r\n        menuItem.repaint();\r\n        if (session == outgoingSession) {\r\n            this.menu.setSelected(selectedObject);\r\n            setSelected(menu.getItem(index - 1));\r\n        }\r\n    }\r\n    updateEnableStatus();\r\n    menu.repaint();\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.FullUserInfoCmd.getUShort",
	"Comment": "extracts short from the given byte blockstarting from the specified position",
	"Method": "int getUShort(ByteBlock data,int pos){\r\n    if (data.getLength() - pos < 2) {\r\n        return -1;\r\n    }\r\n    return ((data.get(pos + 1) & 0xff) << 8) | (data.get(pos) & 0xff);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.TestOperationSetPersistentPresence.postTestCreateGroup",
	"Comment": "creates a group in the server stored contact list, makes sure that thecorresponding event has been generated and verifies that the group isin the list.",
	"Method": "void postTestCreateGroup(){\r\n    logger.trace(\"testing creation of server stored groups\");\r\n    GroupChangeCollector groupChangeCollector = new GroupChangeCollector();\r\n    opSetPersPresence.addServerStoredGroupChangeListener(groupChangeCollector);\r\n    try {\r\n        opSetPersPresence.createServerStoredContactGroup(opSetPersPresence.getServerStoredContactListRoot(), testGroupName);\r\n    } catch (OperationFailedException ex) {\r\n        fail(\"Cannot create group \" + ex.getMessage());\r\n    }\r\n    groupChangeCollector.waitForEvent(10000);\r\n    opSetPersPresence.removeServerStoredGroupChangeListener(groupChangeCollector);\r\n    assertEquals(\"Collected Group Change events: \", 1, groupChangeCollector.collectedEvents.size());\r\n    assertEquals(\"Group name.\", testGroupName, ((ServerStoredGroupEvent) groupChangeCollector.collectedEvents.get(0)).getSourceGroup().getGroupName());\r\n    ContactGroup group = opSetPersPresence.getServerStoredContactListRoot().getGroup(testGroupName);\r\n    assertNotNull(\"A newly created group was not in the contact list.\", group);\r\n    assertEquals(\"New group name\", testGroupName, group.getGroupName());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomIrcImpl.fireMemberPresenceEvent",
	"Comment": "creates the corresponding chatroommemberpresencechangeevent and notifiesall chatroommemberpresencelisteners that a chatroommember hasjoined or left this chatroom.",
	"Method": "void fireMemberPresenceEvent(ChatRoomMember member,ChatRoomMember actorMember,String eventID,String eventReason){\r\n    if (eventID == ChatRoomMemberPresenceChangeEvent.MEMBER_JOINED) {\r\n        addChatRoomMember(member.getContactAddress(), member);\r\n    } else {\r\n        removeChatRoomMember(member.getContactAddress());\r\n    }\r\n    ChatRoomMemberPresenceChangeEvent evt;\r\n    if (actorMember != null) {\r\n        evt = new ChatRoomMemberPresenceChangeEvent(this, member, actorMember, eventID, eventReason);\r\n    } else {\r\n        evt = new ChatRoomMemberPresenceChangeEvent(this, member, eventID, eventReason);\r\n    }\r\n    if (LOGGER.isTraceEnabled()) {\r\n        LOGGER.trace(\"Will dispatch the following ChatRoom event: \" + evt);\r\n    }\r\n    Iterable<ChatRoomMemberPresenceListener> listeners;\r\n    synchronized (memberListeners) {\r\n        listeners = new ArrayList<ChatRoomMemberPresenceListener>(memberListeners);\r\n    }\r\n    for (ChatRoomMemberPresenceListener listener : listeners) {\r\n        listener.memberPresenceChanged(evt);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ContactGroupSipImpl.countSubgroups",
	"Comment": "returns the number of subgroups contained by thiscontactgroup.",
	"Method": "int countSubgroups(){\r\n    return subGroups.size();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.phonenumbers.PhoneNumberI18nServiceImpl.formatForDisplay",
	"Comment": "tries to format the passed phone number into the international format. ifparsing fails or the string is not recognized as a valid phone number,the input is returned as is.",
	"Method": "String formatForDisplay(String phoneNumber){\r\n    try {\r\n        PhoneNumber pn = PhoneNumberUtil.getInstance().parse(phoneNumber, System.getProperty(\"user.country\"));\r\n        if (PhoneNumberUtil.getInstance().isPossibleNumber(pn)) {\r\n            return PhoneNumberUtil.getInstance().format(pn, PhoneNumberFormat.INTERNATIONAL);\r\n        }\r\n    } catch (NumberParseException e) {\r\n    }\r\n    return phoneNumber;\r\n}"
}, {
	"Path": "net.librec.similarity.KRCCSimilarity.getCorrelation",
	"Comment": "find the common rated items by this user and that user, or the commonusers have rated this item or that item. and then return the similarity.",
	"Method": "double getCorrelation(VectorBasedSequentialSparseVector thisVector,VectorBasedSequentialSparseVector thatVector){\r\n    if (thisVector == null || thatVector == null || thisVector.size() != thatVector.size()) {\r\n        return Double.NaN;\r\n    }\r\n    List<Double> thisList = new ArrayList();\r\n    List<Double> thatList = new ArrayList();\r\n    Iterator<Vector.VectorEntry> thisIterator = thisVector.iterator();\r\n    Iterator<Vector.VectorEntry> thatIterator = thatVector.iterator();\r\n    while (thatIterator.hasNext()) {\r\n        Vector.VectorEntry thatVectorEntry = thatIterator.next();\r\n        int thatIndex = thatVectorEntry.index();\r\n        thatList.add(thatVectorEntry.get());\r\n        if (thisIterator.hasNext()) {\r\n            while (thisIterator.hasNext()) {\r\n                Vector.VectorEntry thisVectorEntry = thatIterator.next();\r\n                int thisIndex = thisVectorEntry.index();\r\n                if (thisIndex == thatIndex) {\r\n                    thisList.add(thisVectorEntry.get());\r\n                    break;\r\n                } else if (thisIndex > thatIndex) {\r\n                    thisList.add(0.0D);\r\n                    break;\r\n                }\r\n            }\r\n        } else {\r\n            thisList.add(0.0D);\r\n        }\r\n    }\r\n    return getSimilarity(thisList, thatList);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommTextArea.removeTextChangeListener",
	"Comment": "removes the given textfieldchangelistener from the list oflisteners notified on changes of the text contained in this field.",
	"Method": "void removeTextChangeListener(TextFieldChangeListener l){\r\n    synchronized (changeListeners) {\r\n        changeListeners.remove(l);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.ProviderPresenceStatusChangeEvent.getOldStatus",
	"Comment": "returns the status of the provider before this event took place.",
	"Method": "PresenceStatus getOldStatus(){\r\n    return (PresenceStatus) super.getOldValue();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.jabber.JabberAccountRegistration.getAdditionalStunServers",
	"Comment": "returns the list of all additional stun servers entered by theuser. the list is guaranteed not to be null.",
	"Method": "List<StunServerDescriptor> getAdditionalStunServers(){\r\n    return additionalStunServers;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.dns.ParallelResolverImpl.sendAsync",
	"Comment": "supposed to asynchronously send messages but not currently implemented.",
	"Method": "Object sendAsync(Message query,ResolverListener listener){\r\n    throw new UnsupportedOperationException(\"Not implemented\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.TreeContactList.getContactSource",
	"Comment": "returns the externalcontactsource corresponding to the givencontactsourceservice.",
	"Method": "UIContactSource getContactSource(ContactSourceService contactSource){\r\n    Iterator<UIContactSource> extSourcesIter = contactSources.iterator();\r\n    while (extSourcesIter.hasNext()) {\r\n        UIContactSource extSource = extSourcesIter.next();\r\n        if (extSource.getContactSourceService().equals(contactSource))\r\n            return extSource;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.plaf.SIPCommTextFieldUI.updateDeleteIcon",
	"Comment": "updates the delete icon, changes the cursor and deletes the content ofthe associated text component when the mouse is pressed over the deleteicon.",
	"Method": "void updateDeleteIcon(MouseEvent evt){\r\n    if (getComponent() == null)\r\n        return;\r\n    int x = evt.getX();\r\n    int y = evt.getY();\r\n    if (!isDeleteButtonEnabled)\r\n        return;\r\n    Rectangle deleteRect = getDeleteButtonRect();\r\n    if (isDeleteIconVisible && deleteRect.contains(x, y)) {\r\n        if (evt.getID() == MouseEvent.MOUSE_PRESSED) {\r\n            isDeleteMouseOver = false;\r\n            isDeleteMousePressed = true;\r\n        } else {\r\n            isDeleteMouseOver = true;\r\n            isDeleteMousePressed = false;\r\n        }\r\n        getComponent().setCursor(Cursor.getDefaultCursor());\r\n        if (evt.getID() == MouseEvent.MOUSE_CLICKED)\r\n            getComponent().setText(\"\");\r\n    } else {\r\n        isDeleteMouseOver = false;\r\n        isDeleteMousePressed = false;\r\n    }\r\n    getComponent().repaint();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallPanel.isRecordingStarted",
	"Comment": "checks whether recording is currently enabled or not, state retrievedfrom call record button state.",
	"Method": "boolean isRecordingStarted(){\r\n    if (recordButton == null)\r\n        return false;\r\n    return recordButton.isSelected();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.netaddr.NetworkAddressManagerServiceImpl.start",
	"Comment": "initializes this network address manager service implementation.",
	"Method": "void start(){\r\n    this.localHostFinderSocket = initRandomPortSocket();\r\n    StunStack.setPacketLogger(new Ice4jPacketLogger());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.JabberActivator.getUIService",
	"Comment": "returns a reference to the uiservice implementation currently registeredin the bundle context or null if no such implementation was found.",
	"Method": "UIService getUIService(){\r\n    if (uiService == null) {\r\n        ServiceReference uiServiceReference = bundleContext.getServiceReference(UIService.class.getName());\r\n        uiService = (UIService) bundleContext.getService(uiServiceReference);\r\n    }\r\n    return uiService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallInfoFrame.getLineString",
	"Comment": "returns an html string corresponding to the given labeltext and infotext,that could be easily added to the information text pane.",
	"Method": "String getLineString(String labelText,String infoText){\r\n    return \"<b>\" + labelText + \"<\/b> : \" + infoText + \"<br/>\";\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.AdHocConferenceChatSession.getChatConfigurationForm",
	"Comment": "returns the configuration form corresponding to the chat room.",
	"Method": "ChatRoomConfigurationForm getChatConfigurationForm(){\r\n    return null;\r\n}"
}, {
	"Path": "io.lettuce.core.ZAddArgs.ch",
	"Comment": "modify the return value from the number of new elements added, to the total number of elements changed.",
	"Method": "ZAddArgs ch(ZAddArgs ch){\r\n    this.ch = true;\r\n    return this;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.certificate.CertificateVerificationActivator.getCredService",
	"Comment": "returns the credentialsstorageservice, through which we willaccess all passwords.",
	"Method": "CredentialsStorageService getCredService(){\r\n    if (credService == null) {\r\n        credService = ServiceUtils.getService(bundleContext, CredentialsStorageService.class);\r\n    }\r\n    return credService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.TestAccountUninstallation.testUninstallAccount",
	"Comment": "uinstalls our test account and makes sure it really has been removed.",
	"Method": "void testUninstallAccount(){\r\n    assertFalse(\"No installed accounts found\", fixture.providerFactory.getRegisteredAccounts().isEmpty());\r\n    assertNotNull(\"Found no provider corresponding to URI \" + fixture.userID1, fixture.providerFactory.getProviderForAccount(fixture.provider1.getAccountID()));\r\n    assertTrue(\"Failed to remove a provider corresponding to URI \" + fixture.userID1, fixture.providerFactory.uninstallAccount(fixture.provider1.getAccountID()));\r\n    assertTrue(\"Failed to remove a provider corresponding to URI \" + fixture.userID2, fixture.providerFactory.uninstallAccount(fixture.provider2.getAccountID()));\r\n    assertTrue(\"Failed to remove a provider corresponding to URI \" + fixture.userID3, fixture.providerFactory.uninstallAccount(fixture.provider3.getAccountID()));\r\n    ServiceReference[] jabberProviderRefs = null;\r\n    try {\r\n        jabberProviderRefs = JabberSlickFixture.bc.getServiceReferences(ProtocolProviderService.class.getName(), \"(\" + ProtocolProviderFactory.PROTOCOL + \"=\" + ProtocolNames.JABBER + \")\");\r\n    } catch (InvalidSyntaxException ex) {\r\n        fail(\"We apparently got our filter wrong \" + ex.getMessage());\r\n    }\r\n    assertTrue(\"A Protocol Provider Service was still regged as an osgi \" + \"service for Jabber URI:\" + fixture.userID1 + \"After it was explicitly uninstalled\", jabberProviderRefs == null || jabberProviderRefs.length == 0);\r\n    assertTrue(\"The Jabber provider factory kept a reference to the provider we just \" + \"uninstalled (uri=\" + fixture.userID1 + \")\", fixture.providerFactory.getRegisteredAccounts().isEmpty() && fixture.providerFactory.getProviderForAccount(fixture.provider1.getAccountID()) == null);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.ldap.configform.DirectorySettingsForm.saveData",
	"Comment": "saves the information in the ldapdirectorysettings instancefrom the ui",
	"Method": "void saveData(LdapDirectorySettings settings){\r\n    settings.setName(this.nameField.getText());\r\n    settings.setHostname(hostnameField.getText());\r\n    if (encryptionBox.isSelected()) {\r\n        settings.setEncryption(Encryption.SSL);\r\n    } else {\r\n        settings.setEncryption(Encryption.CLEAR);\r\n    }\r\n    switch(authList.getSelectedIndex()) {\r\n        case 0:\r\n            settings.setAuth(Auth.NONE);\r\n            break;\r\n        case 1:\r\n            settings.setAuth(Auth.SIMPLE);\r\n            break;\r\n    }\r\n    settings.setPort(((Integer) this.portSpinner.getValue()).intValue());\r\n    settings.setBindDN(this.bindDNField.getText());\r\n    settings.setPassword(new String(this.passwordField.getPassword()));\r\n    settings.setBaseDN(this.baseDNField.getText());\r\n    switch(scopeList.getSelectedIndex()) {\r\n        case 0:\r\n            settings.setScope(Scope.SUB);\r\n            break;\r\n        case 1:\r\n            settings.setScope(Scope.ONE);\r\n            break;\r\n    }\r\n    settings.setMailSearchFields(mergeString(mailField.getText()));\r\n    settings.setMailSuffix(mailSuffixField.getText());\r\n    settings.setWorkPhoneSearchFields(mergeString(workPhoneField.getText()));\r\n    settings.setMobilePhoneSearchFields(mergeString(mobilePhoneField.getText()));\r\n    settings.setHomePhoneSearchFields(mergeString(homePhoneField.getText()));\r\n    settings.setGlobalPhonePrefix(prefixField.getText());\r\n    settings.setQueryMode(rdoCustomQuery.isSelected() ? \"custom\" : null);\r\n    settings.setCustomQuery(txtCustomQuery.getText());\r\n    settings.setMangleQuery(chkMangleQuery.isSelected());\r\n    settings.setPhotoInline(chkPhotoInline.isSelected());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetGenericNotificationsJabberImpl.addGenericEventListener",
	"Comment": "registers a genericeventlistener with thisoperation set so that it gets notifications for newevent notifications.",
	"Method": "void addGenericEventListener(String eventName,GenericEventListener listener){\r\n    synchronized (genericEventListeners) {\r\n        List<GenericEventListener> l = this.genericEventListeners.get(eventName);\r\n        if (l == null) {\r\n            l = new ArrayList<GenericEventListener>();\r\n            this.genericEventListeners.put(eventName, l);\r\n        }\r\n        if (!l.contains(listener))\r\n            l.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.GenericBuffer.addValue",
	"Comment": "adds a value to the buffer. if the buffer is full, the oldest value inthe buffer will be overwritten by this new value.",
	"Method": "void addValue(T value,String context){\r\n    assert value != null && context != null;\r\n    GenericBufferPair storage = buffer.get(context);\r\n    if (storage == null) {\r\n        storage = new GenericBufferPair();\r\n    } else {\r\n        return;\r\n    }\r\n    if (buffer.size() == maxCapacity) {\r\n        for (Map.Entry<String, GenericBufferPair> e : buffer.entrySet()) {\r\n            if (e.getValue().age == minAge) {\r\n                buffer.remove(e.getKey());\r\n                minAge++;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    storage.age = curAge++;\r\n    storage.value = value;\r\n    buffer.put(context, storage);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ChatContactCellRenderer.internalPaintComponent",
	"Comment": "paint a background for all groups and a round blue border and backgroundwhen a cell is selected.",
	"Method": "void internalPaintComponent(Graphics g){\r\n    AntialiasingManager.activateAntialiasing(g);\r\n    Graphics2D g2 = (Graphics2D) g;\r\n    if (!this.isLeaf) {\r\n        final int width = getWidth();\r\n        GradientPaint p = new GradientPaint(0, 0, Constants.CONTACT_LIST_GROUP_BG_COLOR, width - 5, 0, Constants.CONTACT_LIST_GROUP_BG_GRADIENT_COLOR);\r\n        g2.setPaint(p);\r\n        g2.fillRoundRect(1, 1, width - 2, this.getHeight() - 1, 10, 10);\r\n    }\r\n    if (this.isSelected) {\r\n        g2.setColor(Constants.SELECTED_COLOR);\r\n        g2.fillRoundRect(1, 1, this.getWidth() - 2, this.getHeight() - 1, 10, 10);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.generic.SecurityAuthorityImpl.isUserNameEditable",
	"Comment": "indicates if the user name is currently editable, i.e. could be changedby user or not.",
	"Method": "boolean isUserNameEditable(){\r\n    return isUserNameEditable;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.notification.PopupMessageNotificationAction.getTimeout",
	"Comment": "returns suggested timeout value in ms for hiding the popup if not clickedby the user.",
	"Method": "long getTimeout(){\r\n    return timeout;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.addChatContact",
	"Comment": "adds the given chatcontact to the list of chat contactsparticipating in the corresponding to this chat panel chat.",
	"Method": "void addChatContact(ChatContact<?> chatContact){\r\n    if (chatContactListPanel != null)\r\n        chatContactListPanel.addContact(chatContact);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.neomedia.NeomediaActivator.stop",
	"Comment": "stops the execution of the neomedia bundle in the specified context.",
	"Method": "void stop(BundleContext bundleContext){\r\n    try {\r\n        if (audioDeviceConfigurationPropertyChangeListener != null) {\r\n            mediaServiceImpl.getDeviceConfiguration().removePropertyChangeListener(audioDeviceConfigurationPropertyChangeListener);\r\n            audioDeviceConfigurationPropertyChangeListener.dispose();\r\n            audioDeviceConfigurationPropertyChangeListener = null;\r\n        }\r\n    } finally {\r\n        configurationService = null;\r\n        fileAccessService = null;\r\n        mediaServiceImpl = null;\r\n        resources = null;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetWhiteboardingJabberImpl.addPresenceListener",
	"Comment": "adds a listener that will be notified of changes in our status in a chatroom such as us being kicked, banned or dropped.",
	"Method": "void addPresenceListener(WhiteboardSessionPresenceListener listener){\r\n    synchronized (presenceListeners) {\r\n        if (!presenceListeners.contains(listener))\r\n            presenceListeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ClientCapabilities.disconnect",
	"Comment": "fire event that connection has failed and we had to unregisterthe protocol provider.",
	"Method": "void disconnect(){\r\n    if (provider.getRegistrationState().equals(RegistrationState.UNREGISTERED)) {\r\n        return;\r\n    }\r\n    provider.getRegistrarConnection().setRegistrationState(RegistrationState.CONNECTION_FAILED, RegistrationStateChangeEvent.REASON_NOT_SPECIFIED, \"A timeout occurred while trying to connect to the server.\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.plaf.SIPCommTabbedPaneUI.getClosestTab",
	"Comment": "returns the index of the tab closest to the passed in location, note thatthe returned tab may not contain the location x,y.",
	"Method": "int getClosestTab(int x,int y){\r\n    int min = 0;\r\n    int tabCount = Math.min(rects.length, tabPane.getTabCount());\r\n    int max = tabCount;\r\n    int tabPlacement = tabPane.getTabPlacement();\r\n    boolean useX = (tabPlacement == TOP || tabPlacement == BOTTOM);\r\n    int want = (useX) ? x : y;\r\n    while (min != max) {\r\n        int current = (max + min) / 2;\r\n        int minLoc;\r\n        int maxLoc;\r\n        if (useX) {\r\n            minLoc = rects[current].x;\r\n            maxLoc = minLoc + rects[current].width;\r\n        } else {\r\n            minLoc = rects[current].y;\r\n            maxLoc = minLoc + rects[current].height;\r\n        }\r\n        if (want < minLoc) {\r\n            max = current;\r\n            if (min == max) {\r\n                return Math.max(0, current - 1);\r\n            }\r\n        } else if (want >= maxLoc) {\r\n            min = current;\r\n            if (max - min <= 1) {\r\n                return Math.max(current + 1, tabCount - 1);\r\n            }\r\n        } else {\r\n            return current;\r\n        }\r\n    }\r\n    return min;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.ChatRoomConferencePublishedEvent.getMember",
	"Comment": "returns the chatroommember who published a conferencedescription",
	"Method": "ChatRoomMember getMember(){\r\n    return member;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.gibberish.TestOperationSetBasicInstantMessaging.thenTestSendMessage",
	"Comment": "send an instant message from the tester agent and assert reception bythe tested implementation",
	"Method": "void thenTestSendMessage(){\r\n    logger.debug(\"Printing Server Stored list to see if message fails are contacts in each other lists\");\r\n    ContactGroup rootGroup1 = ((OperationSetPersistentPresence) opSetPresence1).getServerStoredContactListRoot();\r\n    logger.debug(\"=========== Server Stored Contact List 1 =================\");\r\n    logger.debug(\"rootGroup=\" + rootGroup1.getGroupName() + \" rootGroup.childContacts=\" + rootGroup1.countContacts() + \"rootGroup.childGroups=\" + rootGroup1.countSubgroups() + \"Printing rootGroupContents=\\n\" + rootGroup1.toString());\r\n    ContactGroup rootGroup2 = ((OperationSetPersistentPresence) opSetPresence2).getServerStoredContactListRoot();\r\n    logger.debug(\"=========== Server Stored Contact List 2 =================\");\r\n    logger.debug(\"rootGroup=\" + rootGroup2.getGroupName() + \" rootGroup.childContacts=\" + rootGroup2.countContacts() + \"rootGroup.childGroups=\" + rootGroup2.countSubgroups() + \"Printing rootGroupContents=\\n\" + rootGroup2.toString());\r\n    String body = \"This is an IM coming from the tested implementation\" + \" on \" + new Date().toString();\r\n    net.java.sip.communicator.service.protocol.Message msg = opSetBasicIM1.createMessage(body);\r\n    ImEventCollector imEvtCollector1 = new ImEventCollector();\r\n    opSetBasicIM1.addMessageListener(imEvtCollector1);\r\n    ImEventCollector imEvtCollector2 = new ImEventCollector();\r\n    opSetBasicIM2.addMessageListener(imEvtCollector2);\r\n    Contact testerAgentContact = opSetPresence1.findContactByID(fixture.userID2);\r\n    opSetBasicIM1.sendInstantMessage(testerAgentContact, msg);\r\n    imEvtCollector1.waitForEvent(10000);\r\n    imEvtCollector2.waitForEvent(10000);\r\n    opSetBasicIM1.removeMessageListener(imEvtCollector1);\r\n    opSetBasicIM2.removeMessageListener(imEvtCollector2);\r\n    assertTrue(\"No events delivered when sending a message\", imEvtCollector1.collectedEvents.size() > 0);\r\n    assertTrue(\"Received evt was not an instance of \" + MessageDeliveredEvent.class.getName(), imEvtCollector1.collectedEvents.get(0) instanceof MessageDeliveredEvent);\r\n    MessageDeliveredEvent evt = (MessageDeliveredEvent) imEvtCollector1.collectedEvents.get(0);\r\n    assertEquals(\"message destination \", evt.getDestinationContact().getAddress(), fixture.userID2);\r\n    assertSame(\"source message\", msg, evt.getSourceMessage());\r\n    assertTrue(\"No messages received by the tester agent\", imEvtCollector2.collectedEvents.size() > 0);\r\n    assertFalse(\"Message was unable to deliver !\", imEvtCollector2.collectedEvents.get(0) instanceof MessageDeliveryFailedEvent);\r\n    String receivedBody = ((MessageReceivedEvent) imEvtCollector2.collectedEvents.get(0)).getSourceMessage().getContent();\r\n    assertEquals(\"received message body\", msg.getContent(), receivedBody);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.pluginmanager.PluginManagerActivator.getConfigurationService",
	"Comment": "returns the configurationservice obtained from the bundlecontext.",
	"Method": "ConfigurationService getConfigurationService(){\r\n    if (configService == null) {\r\n        ServiceReference configReference = bundleContext.getServiceReference(ConfigurationService.class.getName());\r\n        configService = (ConfigurationService) bundleContext.getService(configReference);\r\n    }\r\n    return configService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AccountID.isPreferredProvider",
	"Comment": "returns the first protocolproviderservice implementationcorresponding to the preferred protocol",
	"Method": "boolean isPreferredProvider(){\r\n    String preferredProtocolProp = getAccountPropertyString(ProtocolProviderFactory.IS_PREFERRED_PROTOCOL);\r\n    if (preferredProtocolProp != null && preferredProtocolProp.length() > 0 && Boolean.parseBoolean(preferredProtocolProp)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.jabber.JabberAccountRegistration.getSecurityRegistration",
	"Comment": "returns securityaccountregistration object which stores securitysettings.",
	"Method": "SecurityAccountRegistration getSecurityRegistration(){\r\n    return securityRegistration;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.googletalkaccregwizz.GoogleTalkAccountRegistrationWizard.getUserNameExample",
	"Comment": "returns an example string, which should indicate to the user how theuser name should look like.",
	"Method": "String getUserNameExample(){\r\n    return \"Ex: johnsmith@gmail.com or johnsmith\";\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.JabberActivator.getCredentialsStorageService",
	"Comment": "returns a reference to a credentialsstorageservice implementationcurrently registered in the bundle context or null if no suchimplementation was found.",
	"Method": "CredentialsStorageService getCredentialsStorageService(){\r\n    if (credentialsService == null) {\r\n        ServiceReference confReference = bundleContext.getServiceReference(CredentialsStorageService.class.getName());\r\n        credentialsService = (CredentialsStorageService) bundleContext.getService(confReference);\r\n    }\r\n    return credentialsService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetTelephonyConferencingJabberImpl.subscribeForCoinPackets",
	"Comment": "subscribes us to notifications about incoming coin packets.",
	"Method": "void subscribeForCoinPackets(){\r\n    parentProvider.getConnection().addPacketListener(this, this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockPersistentPresenceOperationSet.unsubscribe",
	"Comment": "removes a subscription for the presence status of the specifiedcontact.",
	"Method": "void unsubscribe(Contact contact){\r\n    MockContactGroup parentGroup = (MockContactGroup) contact.getParentContactGroup();\r\n    parentGroup.removeContact((MockContact) contact);\r\n    fireSubscriptionEvent(contact, contact.getParentContactGroup(), SubscriptionEvent.SUBSCRIPTION_REMOVED);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWindowManager.openChat",
	"Comment": "opens the specified chatpanel and optionally brings it to thefront.",
	"Method": "void openChat(ChatPanel chatPanel,boolean setSelected){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                openChat(chatPanel, setSelected);\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    synchronized (chatSyncRoot) {\r\n        ChatContainer chatContainer = chatPanel.getChatContainer();\r\n        if (!chatPanel.isShown())\r\n            chatContainer.addChat(chatPanel);\r\n        chatContainer.openChat(chatPanel, setSelected);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWindowManager.openChat",
	"Comment": "opens the specified chatpanel and optionally brings it to thefront.",
	"Method": "void openChat(ChatPanel chatPanel,boolean setSelected){\r\n    openChat(chatPanel, setSelected);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.conference.ConferenceMemberPanel.propertyChange",
	"Comment": "updates the display name and the state of the conferencememberdepicted by this instance whenever the values of the respectiveproperties change.",
	"Method": "void propertyChange(PropertyChangeEvent ev){\r\n    String propertyName = ev.getPropertyName();\r\n    if (propertyName.equals(ConferenceMember.DISPLAY_NAME_PROPERTY_NAME)) {\r\n        String displayName = (String) ev.getNewValue();\r\n        setParticipantName(displayName);\r\n        revalidate();\r\n        repaint();\r\n    } else if (propertyName.equals(ConferenceMember.STATE_PROPERTY_NAME)) {\r\n        ConferenceMemberState state = (ConferenceMemberState) ev.getNewValue();\r\n        setParticipantState(state.toString());\r\n        revalidate();\r\n        repaint();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.sip.TestAccountUninstallation.testProviderUnregister",
	"Comment": "unregisters both providers and verifies whether they have changed stateaccordingly.",
	"Method": "void testProviderUnregister(){\r\n    assertEquals(fixture.provider1.getRegistrationState(), RegistrationState.REGISTERED);\r\n    assertEquals(fixture.provider2.getRegistrationState(), RegistrationState.REGISTERED);\r\n    UnregistrationEventCollector collector1 = new UnregistrationEventCollector();\r\n    UnregistrationEventCollector collector2 = new UnregistrationEventCollector();\r\n    fixture.provider1.addRegistrationStateChangeListener(collector1);\r\n    fixture.provider2.addRegistrationStateChangeListener(collector2);\r\n    fixture.provider1.unregister();\r\n    fixture.provider2.unregister();\r\n    collector1.waitForEvent(10000);\r\n    collector2.waitForEvent(10000);\r\n    assertTrue(\"Provider did not distribute unregister events\", 2 <= collector1.collectedNewStates.size());\r\n    assertTrue(\"Provider did not distribute unregister events\", 2 <= collector2.collectedNewStates.size());\r\n    assertEquals(\"Provider state after calling unregister().\", RegistrationState.UNREGISTERED, fixture.provider1.getRegistrationState());\r\n    assertEquals(\"Provider state after calling unregister().\", RegistrationState.UNREGISTERED, fixture.provider2.getRegistrationState());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.InfoRetreiver.readEmailUserInfo",
	"Comment": "method for parsing incoming dataread data in emailuserinfo command",
	"Method": "void readEmailUserInfo(MetaEmailInfoCmd cmd){\r\n    List<GenericDetail> infoData = getInfoForRequest(cmd.getId());\r\n    String[] emails = cmd.getEmails();\r\n    if (emails == null)\r\n        return;\r\n    for (String email : emails) {\r\n        infoData.add(new ServerStoredDetails.EmailAddressDetail(email));\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.DynamicRTPExtensionsRegistry.findExtension",
	"Comment": "returns a reference to the rtpextension with the specifiedmapping or null if the number specified by extidhas not been allocated yet.",
	"Method": "RTPExtension findExtension(byte extID){\r\n    for (Map.Entry<RTPExtension, Byte> entry : extMap.entrySet()) {\r\n        byte currentExtensionID = entry.getValue();\r\n        if (currentExtensionID == extID)\r\n            return entry.getKey();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.swingnotification.SwingNotificationActivator.getResources",
	"Comment": "returns the resourcemanagementservice obtained from the bundlecontext.",
	"Method": "ResourceManagementService getResources(){\r\n    if (resourcesService == null)\r\n        resourcesService = ResourceManagementServiceUtils.getService(bundleContext);\r\n    return resourcesService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.gibberish.TestOperationSetPresence.suite",
	"Comment": "creates a test suite containing all tests of this class followed bytest methods that we want executed in a specified order.",
	"Method": "Test suite(){\r\n    if (GibberishSlickFixture.onlineTestingDisabled) {\r\n        TestSuite suite = new TestSuite();\r\n        suite.addTest(new TestOperationSetPresence(\"testSupportedStatusSetForCompleteness\"));\r\n        return suite;\r\n    }\r\n    TestSuite suite = new TestSuite();\r\n    suite.addTest(new TestOperationSetPresence(\"clearLists\"));\r\n    suite.addTest(new TestOperationSetPresence(\"postTestSubscribe\"));\r\n    suite.addTest(new TestOperationSetPresence(\"postTestUnsubscribe\"));\r\n    return suite;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetAdHocMultiUserChatIcqImpl.createAdHocChatRoom",
	"Comment": "creates a room with the named roomname and according to thespecified roomproperties on the server that this protocolprovider is currently connected to.",
	"Method": "AdHocChatRoom createAdHocChatRoom(String roomName,Map<String, Object> roomProperties,AdHocChatRoom createAdHocChatRoom,String adHocRoomName,List<String> contacts,String reason){\r\n    AdHocChatRoom adHocChatRoom = createAdHocChatRoom(\"chat\" + new Date().getTime(), new Hashtable<String, Object>());\r\n    if (adHocChatRoom != null && contacts != null) {\r\n        for (String address : contacts) {\r\n            adHocChatRoom.invite(address, reason);\r\n        }\r\n    }\r\n    return adHocChatRoom;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.GlobalStatusSelectorBox.startConnecting",
	"Comment": "starts connecting user interface for the given protocolprovider.",
	"Method": "void startConnecting(ProtocolProviderService protocolProvider){\r\n    StatusEntry menu = getStatusEntry(protocolProvider);\r\n    if (menu != null)\r\n        menu.startConnecting();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.sipaccregwizz.Resources.getString",
	"Comment": "returns an internationalized string corresponding to the given key.",
	"Method": "String getString(String key){\r\n    return getResources().getI18NString(key);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.certificate.CertificateVerificationActivator.getConfigurationService",
	"Comment": "returns the configurationservice obtained from the bundlecontext.",
	"Method": "ConfigurationService getConfigurationService(){\r\n    if (configService == null) {\r\n        configService = ServiceUtils.getService(bundleContext, ConfigurationService.class);\r\n    }\r\n    return configService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockContact.setParentGroup",
	"Comment": "this method is only called when the contact is added to a newmockcontactgroup by the mockcontactgroup itself.",
	"Method": "void setParentGroup(MockContactGroup newParentGroup){\r\n    this.parentGroup = newParentGroup;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipMessageFactory.createRegisterRequest",
	"Comment": "creates a register request as per the specified parameters.",
	"Method": "Request createRegisterRequest(Address addressOfRecord,int registrationsExpiration,CallIdHeader callIdHeader,long cSeqValue){\r\n    FromHeader fromHeader = protocolProvider.getHeaderFactory().createFromHeader(addressOfRecord, SipMessageFactory.generateLocalTag());\r\n    CSeqHeader cSeqHeader = protocolProvider.getHeaderFactory().createCSeqHeader(cSeqValue, Request.REGISTER);\r\n    ToHeader toHeader = protocolProvider.getHeaderFactory().createToHeader(addressOfRecord, null);\r\n    MaxForwardsHeader maxForwardsHeader = protocolProvider.getMaxForwardsHeader();\r\n    SipURI requestURI = protocolProvider.getRegistrarConnection().getRegistrarURI();\r\n    ArrayList<ViaHeader> viaHeaders = protocolProvider.getLocalViaHeaders(requestURI);\r\n    Request request = createRequest(requestURI, Request.REGISTER, callIdHeader, cSeqHeader, fromHeader, toHeader, viaHeaders, maxForwardsHeader);\r\n    ExpiresHeader expHeader = null;\r\n    for (int retry = 0; retry < 2; retry++) {\r\n        try {\r\n            expHeader = protocolProvider.getHeaderFactory().createExpiresHeader(registrationsExpiration);\r\n        } catch (InvalidArgumentException ex) {\r\n            if (retry == 0) {\r\n                registrationsExpiration = 3600;\r\n                continue;\r\n            }\r\n            throw new IllegalArgumentException(\"Invalid registrations expiration parameter - \" + registrationsExpiration, ex);\r\n        }\r\n    }\r\n    request.addHeader(expHeader);\r\n    ContactHeader contactHeader = (ContactHeader) request.getHeader(ContactHeader.NAME);\r\n    contactHeader.setExpires(registrationsExpiration);\r\n    request.setHeader(contactHeader);\r\n    return request;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.UIServiceImpl.getChatContact",
	"Comment": "get the metacontact corresponding to the chat.the chat must correspond to a one on one conversation, otherwise thismethod will return null.",
	"Method": "MetaContact getChatContact(Chat chat){\r\n    Object contact = ((ChatPanel) chat).getChatSession().getDescriptor();\r\n    if (contact instanceof MetaContact)\r\n        return (MetaContact) contact;\r\n    else\r\n        return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler.isRTPTranslationEnabled",
	"Comment": "determines whether rtp translation is enabled for the callpeerrepresented by this callpeermediahandler and for a specificmediatype.",
	"Method": "boolean isRTPTranslationEnabled(MediaType mediaType){\r\n    T peer = getPeer();\r\n    MediaAwareCall<?, ?, ?> call = peer.getCall();\r\n    if ((call != null) && call.isConferenceFocus() && !call.isLocalVideoStreaming()) {\r\n        Iterator<?> callPeerIt = call.getCallPeers();\r\n        while (callPeerIt.hasNext()) {\r\n            MediaAwareCallPeer<?, ?, ?> callPeer = (MediaAwareCallPeer<?, ?, ?>) callPeerIt.next();\r\n            MediaStream stream = callPeer.getMediaHandler().getStream(mediaType);\r\n            if (stream != null)\r\n                return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.inputevt.RemoteControlExtension.getEvent",
	"Comment": "get componentevent that represents ourinputextensionitem.",
	"Method": "ComponentEvent getEvent(){\r\n    return event;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.plaf.SIPCommTabbedPaneUI.createLayoutManager",
	"Comment": "invoked by installui to create a layout manager object tomanage the jtabbedpane.",
	"Method": "LayoutManager createLayoutManager(){\r\n    return new TabbedPaneScrollLayout();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactImpl.getContactCount",
	"Comment": "returns the number of protocol specific contacts that thismetacontact contains.",
	"Method": "int getContactCount(){\r\n    return protoContacts.size();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.AbstractOperationSetTelephonyConferencing.callPeersChanged",
	"Comment": "notifies this callchangelistener that the callpeer listof a specific call has been modified by adding or removing aspecific callpeer.",
	"Method": "void callPeersChanged(CallPeerEvent event){\r\n    notifyAll(event.getSourceCall());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.conference.VideoConferenceCallPanel.isConferenceMemberCallPeer",
	"Comment": "determines whether a specific conferencemember represents thesame conference participant as a specific callpeer. if thespecified conferencemember is null, returnstrue. otherwise, determines whether the addresses of thespecified conferencemember and the specified callpeeridentify one and the same entity.",
	"Method": "boolean isConferenceMemberCallPeer(ConferenceMember conferenceMember,CallPeer callPeer){\r\n    return (conferenceMember == null) ? true : CallManager.addressesAreEqual(conferenceMember.getAddress(), callPeer.getAddress());\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.spellcheck.Resources.getString",
	"Comment": "returns an internationalized string corresponding to the given key.",
	"Method": "String getString(String key){\r\n    return getResources().getI18NString(key);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.JabberActivator.getVersionService",
	"Comment": "returns a reference to a versionservice implementation currentlyregistered in the bundle context or null if no such implementationwas found.",
	"Method": "VersionService getVersionService(){\r\n    if (versionService == null) {\r\n        ServiceReference versionServiceReference = bundleContext.getServiceReference(VersionService.class.getName());\r\n        versionService = (VersionService) bundleContext.getService(versionServiceReference);\r\n    }\r\n    return versionService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.SmackV3InteroperabilityLayer.addExtensionProvider",
	"Comment": "add packetextensionprovider to the list of knownproviders",
	"Method": "void addExtensionProvider(String elementName,String namespace,Object provider){\r\n    providerManager.addExtensionProvider(elementName, namespace, provider);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWritePanel.getText",
	"Comment": "returns the write area text as a plain text without any formatting.",
	"Method": "String getText(){\r\n    try {\r\n        Document doc = editorPane.getDocument();\r\n        return doc.getText(0, doc.getLength());\r\n    } catch (BadLocationException e) {\r\n        logger.error(\"Could not obtain write area text.\", e);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.CallPeerMediaHandlerJabberImpl.start",
	"Comment": "waits for the associated transportmanagerjabberimpl to concludeany started connectivity establishment and then starts thiscallpeermediahandler.",
	"Method": "void start(){\r\n    try {\r\n        wrapupConnectivityEstablishment();\r\n    } catch (OperationFailedException ofe) {\r\n        throw new UndeclaredThrowableException(ofe);\r\n    }\r\n    super.start();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractFileTransfer.fireProgressChangeEvent",
	"Comment": "notifies all status listeners that a newfiletransferprogressevent occured.",
	"Method": "void fireProgressChangeEvent(long timestamp,long progress){\r\n    Collection<FileTransferProgressListener> listeners = null;\r\n    synchronized (progressListeners) {\r\n        listeners = new ArrayList<FileTransferProgressListener>(progressListeners);\r\n    }\r\n    FileTransferProgressEvent progressEvent = new FileTransferProgressEvent(this, timestamp, progress);\r\n    Iterator<FileTransferProgressListener> listenersIter = listeners.iterator();\r\n    while (listenersIter.hasNext()) {\r\n        FileTransferProgressListener statusListener = listenersIter.next();\r\n        statusListener.progressChanged(progressEvent);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.sip.TestAccountUninstallationPersistence.testAccountUninstallationPersistence",
	"Comment": "retrieves a reference to the sip bundle, stops it and uninstalls it andthen reinstalls it in order to make sure that accounts are not reloadedonce removed.",
	"Method": "void testAccountUninstallationPersistence(){\r\n    Bundle providerBundle = SipSlickFixture.providerBundle;\r\n    providerBundle.stop();\r\n    assertTrue(\"Couldn't stop the protocol provider bundle. State was \" + providerBundle.getState(), Bundle.ACTIVE != providerBundle.getState() && Bundle.STOPPING != providerBundle.getState());\r\n    providerBundle.uninstall();\r\n    assertEquals(\"Couldn't stop the protocol provider bundle.\", Bundle.UNINSTALLED, providerBundle.getState());\r\n    providerBundle = SipSlickFixture.bc.installBundle(providerBundle.getLocation());\r\n    assertEquals(\"Couldn't re-install protocol provider bundle.\", Bundle.INSTALLED, providerBundle.getState());\r\n    AccountManagerUtils.startBundleAndWaitStoredAccountsLoaded(SipSlickFixture.bc, providerBundle, ProtocolNames.SIP);\r\n    assertEquals(\"Couldn't re-start protocol provider bundle.\", Bundle.ACTIVE, providerBundle.getState());\r\n    ServiceReference[] sipProviderRefs = null;\r\n    try {\r\n        sipProviderRefs = SipSlickFixture.bc.getServiceReferences(ProtocolProviderService.class.getName(), \"(\" + ProtocolProviderFactory.PROTOCOL + \"=\" + ProtocolNames.SIP + \")\");\r\n    } catch (InvalidSyntaxException ex) {\r\n        fail(\"We apparently got our filter wrong \" + ex.getMessage());\r\n    }\r\n    assertTrue(\"A SIP Protocol Provider Service was still regged as an \" + \"osgi service after it was explicitly uninstalled\", sipProviderRefs == null || sipProviderRefs.length == 0);\r\n    ServiceReference confReference = SipSlickFixture.bc.getServiceReference(ConfigurationService.class.getName());\r\n    ConfigurationService configurationService = (ConfigurationService) SipSlickFixture.bc.getService(confReference);\r\n    configurationService.purgeStoredConfiguration();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractOperationSetMultiUserChat.fireInvitationReceived",
	"Comment": "fires a new chatroominvitationreceivedevent to all currentlyregistered chatroominvitationlisteners to notify about thereceipt of a specific chatroominvitation.",
	"Method": "void fireInvitationReceived(ChatRoomInvitation invitation){\r\n    ChatRoomInvitationReceivedEvent evt = new ChatRoomInvitationReceivedEvent(this, invitation, new Date(System.currentTimeMillis()));\r\n    ChatRoomInvitationListener[] listeners;\r\n    synchronized (invitationListeners) {\r\n        listeners = invitationListeners.toArray(new ChatRoomInvitationListener[invitationListeners.size()]);\r\n    }\r\n    for (ChatRoomInvitationListener listener : listeners) listener.invitationReceived(evt);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.presence.avatar.imagepicker.WebcamDialog.grabSnapshot",
	"Comment": "grab the current image of the webcam through the mediaservice",
	"Method": "void grabSnapshot(){\r\n    try {\r\n        Robot robot = new Robot();\r\n        Point location = videoContainer.getLocationOnScreen();\r\n        BufferedImage bi = robot.createScreenCapture(new Rectangle(location.x, location.y, videoContainer.getWidth(), videoContainer.getHeight()));\r\n        this.grabbedImage = ImageUtils.toByteArray(bi);\r\n    } catch (Throwable e) {\r\n        logger.error(\"Cannot create snapshot!\", e);\r\n    }\r\n    close(false);\r\n    this.setVisible(false);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl.processResponse",
	"Comment": "processes a response received on a sipprovider upon which thissiplistener is registered.",
	"Method": "void processResponse(ResponseEvent responseEvent){\r\n    ClientTransaction clientTransaction = responseEvent.getClientTransaction();\r\n    if (clientTransaction == null) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"ignoring a transactionless response\");\r\n        return;\r\n    }\r\n    Response response = responseEvent.getResponse();\r\n    earlyProcessMessage(responseEvent);\r\n    String method = ((CSeqHeader) response.getHeader(CSeqHeader.NAME)).getMethod();\r\n    List<MethodProcessor> processors = methodProcessors.get(method);\r\n    if (processors != null) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Found \" + processors.size() + \" processor(s) for method \" + method);\r\n        for (MethodProcessor processor : processors) if (processor.processResponse(responseEvent))\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ContactGroupIcqImpl.getJoustSimSourceGroup",
	"Comment": "returns the joustsim group that this class is encapsulating.",
	"Method": "MutableGroup getJoustSimSourceGroup(){\r\n    return joustSimSourceGroup;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ContactGroupSipImpl.getPersistentData",
	"Comment": "returns null as no persistent data is required and the contact address issufficient for restoring the contact.",
	"Method": "String getPersistentData(){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetTelephonyConferencingSipImpl.callPeerRemoved",
	"Comment": "notifies this callchangelistener that a specificcallpeer has been remove from a specific call.",
	"Method": "void callPeerRemoved(CallPeerEvent event){\r\n    CallPeer callPeer = event.getSourceCallPeer();\r\n    if (callPeer instanceof CallPeerSipImpl)\r\n        ((CallPeerSipImpl) callPeer).removeMethodProcessorListener(this);\r\n    super.callPeerRemoved(event);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AuthorizationResponse.getResponseCode",
	"Comment": "returns the response code that unambiguously represents the sense of thisresponse.",
	"Method": "AuthorizationResponseCode getResponseCode(){\r\n    return responseCode;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.FullUserInfoCmd.getUByte",
	"Comment": "extracts byte from the given byte blockstarting from the specified position",
	"Method": "short getUByte(ByteBlock data,int pos){\r\n    if (data.getLength() - pos < 1) {\r\n        return -1;\r\n    }\r\n    return (short) (data.get(pos) & 0xff);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.securityconfig.SecurityConfigActivator.getUIService",
	"Comment": "gets the uiservice instance registered in thebundlecontext of the securityconfigactivator.",
	"Method": "UIService getUIService(){\r\n    if (uiService == null)\r\n        uiService = ServiceUtils.getService(bundleContext, UIService.class);\r\n    return uiService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatTransport.getDisplayName",
	"Comment": "returns the display name corresponding to this chat transport.",
	"Method": "String getDisplayName(){\r\n    return chatRoom.getName();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ContactIcqImpl.updatePresenceStatus",
	"Comment": "sets the status that this contact is currently in. the method is toonly be called as a result of a status update received from the aimserver.",
	"Method": "void updatePresenceStatus(PresenceStatus status){\r\n    this.icqStatus = status;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.certconfig.CertConfigActivator.getCredService",
	"Comment": "returns a reference to a credentialsstorageservice implementationcurrently registered in the bundle context or null if no suchimplementation was found.",
	"Method": "CredentialsStorageService getCredService(){\r\n    return ServiceUtils.getService(bundleContext, CredentialsStorageService.class);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.MetaContactRightButtonMenu.groupClicked",
	"Comment": "indicates that a group has been selected during a move operation. movesthe selected contact to the selected group.",
	"Method": "void groupClicked(ContactListEvent evt){\r\n    this.moveDialog.dispose();\r\n    UIGroup sourceGroup = evt.getSourceGroup();\r\n    if (!(sourceGroup instanceof MetaUIGroup))\r\n        return;\r\n    MetaContactGroup metaGroup = (MetaContactGroup) sourceGroup.getDescriptor();\r\n    contactList.removeContactListListener(this);\r\n    if (moveAllContacts) {\r\n        MetaContactListManager.moveMetaContactToGroup(metaContact, metaGroup);\r\n    } else if (contactToMove != null) {\r\n        MetaContactListManager.moveContactToGroup(contactToMove, metaGroup);\r\n    }\r\n    contactList.setGroupClickConsumed(false);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.WhiteboardChangeEvent.toString",
	"Comment": "returns a string representation of this whiteboardchangeevent.",
	"Method": "String toString(){\r\n    return \"WhiteboardChangeEvent: type=\" + getEventType() + \" oldV=\" + getOldValue() + \" newV=\" + getNewValue();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.RecordButton.generateCallFilename",
	"Comment": "generates a file name for the call based on the current date andthe names of the peers in the call.",
	"Method": "String generateCallFilename(String ext){\r\n    String filename = FORMAT.format(new Date()) + \"-call\";\r\n    int maxLength = MAX_FILENAME_LENGTH - 2 - filename.length() - ext.length();\r\n    String peerName = getCallPeerName(maxLength);\r\n    filename += ((!peerName.equals(\"\")) ? \"-\" : \"\") + peerName + \".\" + ext;\r\n    return filename;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.UIServiceImpl.getSupportedExportedWindows",
	"Comment": "implements getsupportedexportedwindows in the uiserviceinterface. returns an iterator over a set of all windows exported bythis implementation.",
	"Method": "Iterator<WindowID> getSupportedExportedWindows(){\r\n    return Collections.unmodifiableMap(exportedWindows).keySet().iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.gibberish.TestOperationSetTypingNotifications.prepareContactList",
	"Comment": "create the list to be sure that contacts exchanging messagesexists in each other lists",
	"Method": "void prepareContactList(){\r\n    try {\r\n        opSetPresence1.subscribe(fixture.userID2);\r\n    } catch (OperationFailedException ex) {\r\n    }\r\n    try {\r\n        opSetPresence2.subscribe(fixture.userID1);\r\n    } catch (OperationFailedException ex1) {\r\n    }\r\n    Object o = new Object();\r\n    synchronized (o) {\r\n        o.wait(2000);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AccountID.getStunServers",
	"Comment": "returns the list of stun servers that this account is currentlyconfigured to use.",
	"Method": "List<StunServerDescriptor> getStunServers(BundleContext bundleContext){\r\n    Map<String, String> accountProperties = getAccountProperties();\r\n    List<StunServerDescriptor> stunServerList = new ArrayList<StunServerDescriptor>();\r\n    for (int i = 0; i < StunServerDescriptor.MAX_STUN_SERVER_COUNT; i++) {\r\n        StunServerDescriptor stunServer = StunServerDescriptor.loadDescriptor(accountProperties, ProtocolProviderFactory.STUN_PREFIX + i);\r\n        if (stunServer == null)\r\n            break;\r\n        String password = loadStunPassword(bundleContext, this, ProtocolProviderFactory.STUN_PREFIX + i);\r\n        if (password != null)\r\n            stunServer.setPassword(password);\r\n        stunServerList.add(stunServer);\r\n    }\r\n    return stunServerList;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.spellcheck.SpellChecker.copyDictionary",
	"Comment": "copies dictionary to appropriate location, closing the stream afterward",
	"Method": "void copyDictionary(InputStream input,File dest){\r\n    byte[] buf = new byte[1024];\r\n    FileOutputStream output = new FileOutputStream(dest);\r\n    int len;\r\n    while ((len = input.read(buf)) > 0) output.write(buf, 0, len);\r\n    input.close();\r\n    output.close();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MclStorageManager.findMetaContactGroupNode",
	"Comment": "returns the node corresponding to the meta contact with the specified uidor null if no such node was found.",
	"Method": "Element findMetaContactGroupNode(String metaContactGroupUID){\r\n    Element root = (Element) contactListDocument.getFirstChild();\r\n    return XMLUtils.locateElement(root, GROUP_NODE_NAME, UID_ATTR_NAME, metaContactGroupUID);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.filetransfer.FileTransferConversationComponent.progressChanged",
	"Comment": "updates progress bar progress line every time a progress event has beenreceived.",
	"Method": "void progressChanged(FileTransferProgressEvent event){\r\n    progressBar.setValue((int) event.getProgress());\r\n    long transferredBytes = event.getFileTransfer().getTransferedBytes();\r\n    long progressTimestamp = event.getTimestamp();\r\n    String bytesString = ByteFormat.format(transferredBytes);\r\n    if ((progressTimestamp - lastSpeedTimestamp) >= SPEED_CALCULATE_DELAY) {\r\n        lastProgressSpeed = Math.round(calculateProgressSpeed(transferredBytes));\r\n        this.lastSpeedTimestamp = progressTimestamp;\r\n        this.lastTransferredBytes = transferredBytes;\r\n    }\r\n    if ((progressTimestamp - lastEstimatedTimeTimestamp) >= SPEED_CALCULATE_DELAY && lastProgressSpeed > 0) {\r\n        lastEstimatedTime = Math.round(calculateEstimatedTransferTime(lastProgressSpeed, transferredFileSize - transferredBytes));\r\n        lastEstimatedTimeTimestamp = progressTimestamp;\r\n    }\r\n    progressBar.setString(getProgressLabel(bytesString));\r\n    if (lastProgressSpeed > 0) {\r\n        progressSpeedLabel.setText(resources.getI18NString(\"service.gui.SPEED\") + ByteFormat.format(lastProgressSpeed) + \"/sec\");\r\n        progressSpeedLabel.setVisible(true);\r\n    }\r\n    if (lastEstimatedTime > 0) {\r\n        estimatedTimeLabel.setText(resources.getI18NString(\"service.gui.ESTIMATED_TIME\") + GuiUtils.formatSeconds(lastEstimatedTime * 1000));\r\n        estimatedTimeLabel.setVisible(true);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetPersistentPresenceJabberImpl.getCurrentStatusMessage",
	"Comment": "returns the status message that was confirmed by the serfver",
	"Method": "String getCurrentStatusMessage(){\r\n    return currentStatusMessage;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.sipaccregwizz.SIPAccRegWizzActivator.isAdvancedAccountConfigDisabled",
	"Comment": "indicates if the advanced account configuration is currently disabled.",
	"Method": "boolean isAdvancedAccountConfigDisabled(){\r\n    String advancedConfigDisabledDefaultProp = Resources.getResources().getSettingsString(\"impl.gui.main.account.ADVANCED_CONFIG_DISABLED\");\r\n    boolean isAdvancedConfigDisabled = false;\r\n    if (advancedConfigDisabledDefaultProp != null)\r\n        isAdvancedConfigDisabled = Boolean.parseBoolean(advancedConfigDisabledDefaultProp);\r\n    return getConfigurationService().getBoolean(\"net.java.sip.communicator.impl.gui.main.account.\" + \"ADVANCED_CONFIG_DISABLED\", isAdvancedConfigDisabled);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl.setJainSipProvider",
	"Comment": "sets the jain sip provider instance that is responsible for sending andreceiving requests and responses related to this call peer.",
	"Method": "void setJainSipProvider(SipProvider jainSipProvider){\r\n    this.jainSipProvider = jainSipProvider;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.provisioning.ProvisioningServiceImpl.checkEnforcePrefix",
	"Comment": "walk through all properties and make sure all properties keys matcha specific set of prefixes defined in configuration.",
	"Method": "void checkEnforcePrefix(String enforcePrefix){\r\n    ConfigurationService config = ProvisioningActivator.getConfigurationService();\r\n    String[] prefixes = null;\r\n    if (enforcePrefix == null) {\r\n        return;\r\n    }\r\n    prefixes = enforcePrefix.split(\"\\\\|\");\r\n    for (String key : config.getAllPropertyNames()) {\r\n        boolean isValid = false;\r\n        for (String k : prefixes) {\r\n            if (key.startsWith(k)) {\r\n                isValid = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!isValid) {\r\n            config.removeProperty(key);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.conference.BasicConferenceCallPanel.isCallTimerStarted",
	"Comment": "returns true if the call timer has been started, otherwisereturns false.",
	"Method": "boolean isCallTimerStarted(){\r\n    return callPanel.isCallTimerStarted();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.history.HistoryID.createFromRawStrings",
	"Comment": "create a historyid from a raw strings. you can pass any kind of stringsand they will be checked and converted to valid ids.",
	"Method": "HistoryID createFromRawStrings(String[] rawStrings){\r\n    String[] id = new String[rawStrings.length];\r\n    for (int i = 0; i < rawStrings.length; i++) {\r\n        id[i] = HistoryID.decodeReadableHash(rawStrings[i]);\r\n    }\r\n    return new HistoryID(id);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetTypingNotificationsJabberImpl.sendXep85ChatState",
	"Comment": "converts state into the corresponding smack chatstateand sends it to contact.",
	"Method": "void sendXep85ChatState(Contact contact,int state){\r\n    if (opSetBasicIM == null || parentProvider.getConnection() == null)\r\n        return;\r\n    String toJID = opSetBasicIM.getRecentJIDForAddress(contact.getAddress());\r\n    if (toJID == null)\r\n        return;\r\n    if (logger.isTraceEnabled())\r\n        logger.trace(\"Sending XEP-0085 chat state=\" + state + \" to \" + toJID);\r\n    ChatState chatState;\r\n    if (state == STATE_TYPING) {\r\n        chatState = ChatState.composing;\r\n    } else if (state == STATE_STOPPED) {\r\n        chatState = ChatState.inactive;\r\n    } else if (state == STATE_PAUSED) {\r\n        chatState = ChatState.paused;\r\n    } else {\r\n        chatState = ChatState.gone;\r\n    }\r\n    setCurrentState(chatState, toJID);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.jabber.JabberAccountID.isAnonymousAuthUsed",
	"Comment": "indicates whether anonymous authorization method is used by this account.",
	"Method": "boolean isAnonymousAuthUsed(){\r\n    return getAccountPropertyBoolean(ANONYMOUS_AUTH, false);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chatroomslist.joinforms.JoinChatRoomWindow.handleChange",
	"Comment": "performs changes in the room name combo box when its editor content haschanged.",
	"Method": "void handleChange(){\r\n    final String match = editor.getText();\r\n    SwingUtilities.invokeLater(new Runnable() {\r\n        public void run() {\r\n            for (int i = 0; i < jcb_roomName.getItemCount(); i++) jcb_roomName.removeItemAt(i);\r\n            for (String room : getChatRoomList(match)) jcb_roomName.addItem(room);\r\n            editor.setText(match);\r\n            jcb_roomName.showPopup();\r\n        }\r\n    });\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chatroomslist.joinforms.JoinChatRoomWindow.handleChange",
	"Comment": "performs changes in the room name combo box when its editor content haschanged.",
	"Method": "void handleChange(){\r\n    for (int i = 0; i < jcb_roomName.getItemCount(); i++) jcb_roomName.removeItemAt(i);\r\n    for (String room : getChatRoomList(match)) jcb_roomName.addItem(room);\r\n    editor.setText(match);\r\n    jcb_roomName.showPopup();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.notification.NotificationServiceImpl.getEventNotificationAction",
	"Comment": "returns the notification action corresponding to the giveneventtype and actiontype.",
	"Method": "NotificationAction getEventNotificationAction(String eventType,String actionType){\r\n    Notification notification = notifications.get(eventType);\r\n    return (notification == null) ? null : notification.getAction(actionType);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.hid.HIDActivator.stop",
	"Comment": "stops the execution of the hid bundle in the specified context.",
	"Method": "void stop(BundleContext bundleContext){\r\n    if (serviceRegistration != null) {\r\n        serviceRegistration.unregister();\r\n        serviceRegistration = null;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWritePanel.pluginComponentAdded",
	"Comment": "indicates that a new plugin component has been added. adds it to thiscontainer if it belongs to it.",
	"Method": "void pluginComponentAdded(PluginComponentEvent event){\r\n    PluginComponentFactory factory = event.getPluginComponentFactory();\r\n    if (!factory.getContainer().equals(net.java.sip.communicator.service.gui.Container.CONTAINER_CHAT_WRITE_PANEL))\r\n        return;\r\n    PluginComponent component = factory.getPluginComponentInstance(this);\r\n    this.pluginComponents.add(component);\r\n    ChatSession chatSession = chatPanel.getChatSession();\r\n    if (chatSession != null) {\r\n        ChatTransport currentTransport = chatSession.getCurrentChatTransport();\r\n        Object currentDescriptor = currentTransport.getDescriptor();\r\n        if (currentDescriptor instanceof Contact) {\r\n            Contact contact = (Contact) currentDescriptor;\r\n            component.setCurrentContact(contact, currentTransport.getResourceName());\r\n        }\r\n    }\r\n    GridBagConstraints constraints = new GridBagConstraints();\r\n    constraints.anchor = GridBagConstraints.NORTHEAST;\r\n    constraints.fill = GridBagConstraints.NONE;\r\n    constraints.gridy = 0;\r\n    constraints.gridheight = 1;\r\n    constraints.weightx = 0f;\r\n    constraints.weighty = 0f;\r\n    constraints.insets = new Insets(0, 3, 0, 0);\r\n    centerPanel.add((Component) component.getComponent(), constraints);\r\n    this.centerPanel.repaint();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.whiteboard.WhiteboardSessionManager.whiteboardObjectReceived",
	"Comment": "called when a new incoming whiteboardobject has been received.",
	"Method": "void whiteboardObjectReceived(WhiteboardObjectReceivedEvent evt){\r\n    WhiteboardFrame wbFrame = getWhiteboardFrame(evt.getSourceWhiteboardSession());\r\n    if (wbFrame == null) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"New WBParticipant\" + evt.getSourceContact().getDisplayName());\r\n        wbFrame = new WhiteboardFrame(this, evt.getSourceWhiteboardSession());\r\n        wbFrames.add(wbFrame);\r\n    }\r\n    wbFrame.setVisible(true);\r\n    WhiteboardObject wbObject = evt.getSourceWhiteboardObject();\r\n    wbFrame.receiveWhiteboardObject(wbObject);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomJabberImpl.addMemberPresenceListener",
	"Comment": "adds a listener that will be notified of changes in our status in theroom such as us being kicked, banned, or granted admin permissions.",
	"Method": "void addMemberPresenceListener(ChatRoomMemberPresenceListener listener){\r\n    synchronized (memberListeners) {\r\n        if (!memberListeners.contains(listener))\r\n            memberListeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.GlobalStatusSelectorBox.hasSelectedMenus",
	"Comment": "returns true if there are selected status selector boxes,otherwise returns false.",
	"Method": "boolean hasSelectedMenus(){\r\n    for (Component c : getComponents()) {\r\n        if (!(c instanceof StatusEntry))\r\n            continue;\r\n        StatusEntry menu = (StatusEntry) c;\r\n        if (menu.isSelected())\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomIrcImpl.destroy",
	"Comment": "irc chat rooms cannot be destroyed. that is the way irc works and thereis no need to cause a panic, so just return true.",
	"Method": "boolean destroy(String reason,String alternateAddress){\r\n    return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.gibberish.TestAccountInstallation.getAccountProperties",
	"Comment": "returns all properties necessary for the intialization of the accountwith accountprefix.",
	"Method": "Hashtable<String, String> getAccountProperties(String accountPrefix){\r\n    Hashtable<String, String> table = new Hashtable<String, String>();\r\n    String userID = System.getProperty(accountPrefix + ProtocolProviderFactory.USER_ID, null);\r\n    assertNotNull(\"The system property named \" + accountPrefix + ProtocolProviderFactory.USER_ID + \" has to tontain a valid gibberish address that could be used \" + \"during SIP Communicator's tests.\", userID);\r\n    table.put(ProtocolProviderFactory.USER_ID, userID);\r\n    String passwd = System.getProperty(accountPrefix + ProtocolProviderFactory.PASSWORD, null);\r\n    assertNotNull(\"The system property named \" + accountPrefix + ProtocolProviderFactory.PASSWORD + \" has to contain the password corresponding to the account \" + \"specified in \" + accountPrefix + ProtocolProviderFactory.USER_ID, passwd);\r\n    table.put(ProtocolProviderFactory.PASSWORD, passwd);\r\n    String serverAddress = System.getProperty(accountPrefix + ProtocolProviderFactory.SERVER_ADDRESS, null);\r\n    if (serverAddress != null)\r\n        table.put(ProtocolProviderFactory.SERVER_ADDRESS, serverAddress);\r\n    String serverPort = System.getProperty(accountPrefix + ProtocolProviderFactory.SERVER_PORT, null);\r\n    if (serverPort != null)\r\n        table.put(ProtocolProviderFactory.SERVER_PORT, serverPort);\r\n    return table;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.SecurityAccountRegistration.addEncryptionProtocolStatusToProperties",
	"Comment": "adds the encryption protocol status to the property list given inparameter.",
	"Method": "void addEncryptionProtocolStatusToProperties(Map<String, String> properties){\r\n    for (Map.Entry<String, Boolean> e : getEncryptionProtocolStatus().entrySet()) {\r\n        properties.put(ProtocolProviderFactory.ENCRYPTION_PROTOCOL_STATUS + \".\" + e.getKey(), e.getValue().toString());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.mailnotification.MailThreadInfo.setURL",
	"Comment": "sets an url linking to this thread. it is important to distinguishbetween this url and the one returned by the mailboxiq whichpoints to the whole mailbox.",
	"Method": "void setURL(String url){\r\n    this.url = url;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.caps.CapsPacketExtension.setExtensions",
	"Comment": "sets the value of the ext parameter as a string set ofname tokens specifying additional feature bundles. this attribute isdeprecated indicating the hashing algorithm used to generate theverification string.",
	"Method": "void setExtensions(String extensions){\r\n    this.ext = extensions;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.sysactivity.SystemActivityEventDispatcher.addSystemActivityChangeListener",
	"Comment": "registers a listener that would be notified of changes that have occurredin the underlying system.",
	"Method": "void addSystemActivityChangeListener(SystemActivityChangeListener listener){\r\n    synchronized (listeners) {\r\n        if (!listeners.contains(listener)) {\r\n            listeners.add(listener);\r\n            if (dispatcherThread == null) {\r\n                dispatcherThread = new Thread(this);\r\n                dispatcherThread.start();\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.lettuce.core.dynamic.RedisCommandFactory.getCommands",
	"Comment": "returns a redis commands interface instance for the given interface.",
	"Method": "List<CommandDetail> getCommands(StatefulConnection<?, ?> connection,T getCommands,Class<T> commandInterface){\r\n    LettuceAssert.notNull(commandInterface, \"Redis Command Interface must not be null\");\r\n    RedisCommandsMetadata metadata = new DefaultRedisCommandsMetadata(commandInterface);\r\n    InvocationProxyFactory factory = new InvocationProxyFactory();\r\n    factory.addInterface(commandInterface);\r\n    BatchAwareCommandLookupStrategy lookupStrategy = new BatchAwareCommandLookupStrategy(new CompositeCommandLookupStrategy(), metadata);\r\n    factory.addInterceptor(new DefaultMethodInvokingInterceptor());\r\n    factory.addInterceptor(new CommandFactoryExecutorMethodInterceptor(metadata, lookupStrategy));\r\n    return factory.createProxy(commandInterface.getClassLoader());\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.CallConference.getCallCount",
	"Comment": "gets the number of calls that are participating in thistelephony conference.",
	"Method": "int getCallCount(){\r\n    synchronized (callsSyncRoot) {\r\n        return mutableCalls.size();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.generalconfig.GeneralConfigPluginActivator.getConfigurationService",
	"Comment": "returns the configurationservice obtained from the bundlecontext.",
	"Method": "ConfigurationService getConfigurationService(){\r\n    if (configService == null) {\r\n        ServiceReference configReference = bundleContext.getServiceReference(ConfigurationService.class.getName());\r\n        configService = (ConfigurationService) bundleContext.getService(configReference);\r\n    }\r\n    return configService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.dns.DnsUtilActivator.getNotificationService",
	"Comment": "returns the notificationservice obtained from the bundle context.",
	"Method": "NotificationService getNotificationService(){\r\n    if (notificationService == null) {\r\n        notificationService = ServiceUtils.getService(bundleContext, NotificationService.class);\r\n    }\r\n    return notificationService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.sysactivity.SystemActivityEventDispatcher.stop",
	"Comment": "interrupts this dispatcher so that it would no longer disptach events.",
	"Method": "void stop(){\r\n    synchronized (eventsToDispatch) {\r\n        stopped = true;\r\n        eventsToDispatch.notifyAll();\r\n        dispatcherThread = null;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageHistoryServiceImpl.getContactOrRoomByID",
	"Comment": "founds the contact or chat room corresponding this historyid. checks theaccount and then searches for the contact or chat room.will skip hidden and disabled accounts.",
	"Method": "Object getContactOrRoomByID(String accountID,String id,HistoryID historyID,boolean isSMSEnabled){\r\n    AccountID account = null;\r\n    for (AccountID acc : AccountUtils.getStoredAccounts()) {\r\n        if (!acc.isHidden() && acc.isEnabled() && accountID.startsWith(acc.getAccountUniqueID())) {\r\n            account = acc;\r\n            break;\r\n        }\r\n    }\r\n    if (account == null)\r\n        return null;\r\n    ProtocolProviderService pps = AccountUtils.getRegisteredProviderForAccount(account);\r\n    if (pps == null)\r\n        return null;\r\n    OperationSetPersistentPresence opSetPresence = pps.getOperationSet(OperationSetPersistentPresence.class);\r\n    if (opSetPresence == null)\r\n        return null;\r\n    Contact contact = opSetPresence.findContactByID(id);\r\n    if (isSMSEnabled) {\r\n        if (contact != null && hasMessages(historyID, new String[] { MessageHistoryServiceImpl.MSG_SUBTYPE_SMS }, MessageHistoryServiceImpl.STRUCTURE_NAMES[7], true)) {\r\n            return contact;\r\n        }\r\n        OperationSetSmsMessaging opSetSMS = pps.getOperationSet(OperationSetSmsMessaging.class);\r\n        if (opSetSMS == null || !hasMessages(historyID, new String[] { MessageHistoryServiceImpl.MSG_SUBTYPE_SMS }, MessageHistoryServiceImpl.STRUCTURE_NAMES[7], true)) {\r\n            return null;\r\n        }\r\n        return opSetSMS.getContact(id);\r\n    }\r\n    if (contact != null)\r\n        return contact;\r\n    OperationSetMultiUserChat opSetMuc = pps.getOperationSet(OperationSetMultiUserChat.class);\r\n    if (opSetMuc == null)\r\n        return null;\r\n    try {\r\n        id = id.substring(0, id.lastIndexOf('@'));\r\n        return opSetMuc.findRoom(id);\r\n    } catch (Exception e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.ircaccregwizz.FirstWizardPage.getWizardForm",
	"Comment": "implements the wizardpage.getwizardform to returnthis panel.",
	"Method": "Object getWizardForm(){\r\n    return this;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.thumbnail.ThumbnailIQ.parseIQ",
	"Comment": "parses the given xmlpullparser into a thumbnailiq packet andreturns it.",
	"Method": "IQ parseIQ(XmlPullParser parser){\r\n    String elementName = parser.getName();\r\n    String namespace = parser.getNamespace();\r\n    if (elementName.equals(ELEMENT_NAME) && namespace.equals(NAMESPACE)) {\r\n        this.cid = parser.getAttributeValue(\"\", CID);\r\n        this.mimeType = parser.getAttributeValue(\"\", TYPE);\r\n    }\r\n    int eventType = parser.next();\r\n    if (eventType == XmlPullParser.TEXT) {\r\n        this.data = Base64.decode(parser.getText());\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "net.librec.recommender.content.HFTRecommender.updateArray",
	"Comment": "update function for thetas and phiks, check if softmax comes in to nanand update the parameters.",
	"Method": "double[] updateArray(double[] oldValues,double[] newValues){\r\n    boolean containNan = false;\r\n    double[] newDoubles = Maths.softmax(newValues);\r\n    for (double doubleValue : newDoubles) {\r\n        if (Double.isNaN(doubleValue)) {\r\n            containNan = true;\r\n            break;\r\n        }\r\n    }\r\n    if (!containNan) {\r\n        return newValues;\r\n    } else {\r\n        return oldValues;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetPresenceSipImpl.assertConnected",
	"Comment": "utility method throwing an exception if the stack is not properlyinitialized.",
	"Method": "void assertConnected(){\r\n    if (this.parentProvider == null)\r\n        throw new IllegalStateException(\"The provider must be non-null and signed on the \" + \"service before being able to communicate.\");\r\n    if (!this.parentProvider.isRegistered())\r\n        throw new IllegalStateException(\"The provider must be signed on the service before \" + \"being able to communicate.\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.loadPreviousPageFromHistory",
	"Comment": "implements chatpanel.loadpreviousfromhistory.loads previous page from history.",
	"Method": "void loadPreviousPageFromHistory(){\r\n    final MetaHistoryService chatHistory = GuiActivator.getMetaHistoryService();\r\n    if (chatHistory == null)\r\n        return;\r\n    SwingWorker worker = new SwingWorker() {\r\n        @Override\r\n        public Object construct() throws Exception {\r\n            ChatConversationPanel conversationPanel = getChatConversationPanel();\r\n            Date firstMsgDate = conversationPanel.getPageFirstMsgTimestamp();\r\n            Collection<Object> c = null;\r\n            if (firstMsgDate != null) {\r\n                c = chatSession.getHistoryBeforeDate(firstMsgDate, MESSAGES_PER_PAGE);\r\n            }\r\n            if (c != null && c.size() > 0) {\r\n                SwingUtilities.invokeLater(new HistoryMessagesLoader(c));\r\n            }\r\n            return \"\";\r\n        }\r\n        @Override\r\n        public void finished() {\r\n            getChatContainer().updateHistoryButtonState(ChatPanel.this);\r\n        }\r\n    };\r\n    worker.start();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.loadPreviousPageFromHistory",
	"Comment": "implements chatpanel.loadpreviousfromhistory.loads previous page from history.",
	"Method": "void loadPreviousPageFromHistory(){\r\n    ChatConversationPanel conversationPanel = getChatConversationPanel();\r\n    Date firstMsgDate = conversationPanel.getPageFirstMsgTimestamp();\r\n    Collection<Object> c = null;\r\n    if (firstMsgDate != null) {\r\n        c = chatSession.getHistoryBeforeDate(firstMsgDate, MESSAGES_PER_PAGE);\r\n    }\r\n    if (c != null && c.size() > 0) {\r\n        SwingUtilities.invokeLater(new HistoryMessagesLoader(c));\r\n    }\r\n    return \"\";\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.loadPreviousPageFromHistory",
	"Comment": "implements chatpanel.loadpreviousfromhistory.loads previous page from history.",
	"Method": "void loadPreviousPageFromHistory(){\r\n    getChatContainer().updateHistoryButtonState(ChatPanel.this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ProtocolProviderServiceIrcImpl.getCurrentRegistrationState",
	"Comment": "returns the current registration state of this protocol provider.",
	"Method": "RegistrationState getCurrentRegistrationState(){\r\n    return currentRegistrationState;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.InviteUIContact.getContactDetailsForOperationSet",
	"Comment": "returns a list of uicontactdetails supporting the givenoperationset class.",
	"Method": "List<UIContactDetail> getContactDetailsForOperationSet(Class<? extends OperationSet> opSetClass){\r\n    List<UIContactDetail> contactDetails = sourceUIContact.getContactDetailsForOperationSet(opSetClass);\r\n    if (contactDetails == null)\r\n        return null;\r\n    if (backupProvider == null)\r\n        return contactDetails;\r\n    Iterator<UIContactDetail> contactDetailsIter = contactDetails.iterator();\r\n    while (contactDetailsIter.hasNext()) {\r\n        UIContactDetail contactDetail = contactDetailsIter.next();\r\n        if (contactDetail.getPreferredProtocolProvider(opSetClass) == null) {\r\n            contactDetail.addPreferredProtocolProvider(opSetClass, backupProvider);\r\n        }\r\n        if (contactDetail.getPreferredProtocol(opSetClass) == null) {\r\n            contactDetail.addPreferredProtocol(opSetClass, backupProvider.getProtocolName());\r\n        }\r\n    }\r\n    return contactDetails;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactImpl.removeProtoContact",
	"Comment": "removes the specified protocol specific contact from the contactsencapsulated in this metacontact. the method also updatesthe total status field accordingly. and updates its ordered positionin its parent group. if the display name of this metacontactwas the one of the removed contact, we update it.",
	"Method": "void removeProtoContact(Contact contact){\r\n    synchronized (getParentGroupModLock()) {\r\n        if (parentGroup != null)\r\n            parentGroup.lightRemoveMetaContact(this);\r\n        contactsOnline -= contact.getPresenceStatus().isOnline() ? 1 : 0;\r\n        this.protoContacts.remove(contact);\r\n        if (defaultContact == contact)\r\n            defaultContact = null;\r\n        if ((protoContacts.size() > 0) && displayName.equals(contact.getDisplayName())) {\r\n            displayName = getDefaultContact().getDisplayName();\r\n        }\r\n        if (parentGroup != null)\r\n            parentGroup.lightAddMetaContact(this);\r\n        ProtocolProviderService contactProvider = contact.getProtocolProvider();\r\n        OperationSetContactCapabilities capOpSet = contactProvider.getOperationSet(OperationSetContactCapabilities.class);\r\n        if (capOpSet != null) {\r\n            removeCapabilities(contact, capOpSet.getSupportedOperationSets(contact));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.contactsource.ContactDetail.setPreferredProviders",
	"Comment": "sets a mapping of preferred protocolproviderservices fora specific operationset.",
	"Method": "void setPreferredProviders(Map<Class<? extends OperationSet>, ProtocolProviderService> preferredProviders){\r\n    this.preferredProviders = preferredProviders;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWindow.initPluginComponents",
	"Comment": "initialize plugin components already registered for this container.",
	"Method": "void initPluginComponents(){\r\n    GuiActivator.getUIService().addPluginComponentListener(this);\r\n    pluginPanelEast.setLayout(new BoxLayout(pluginPanelEast, BoxLayout.Y_AXIS));\r\n    pluginPanelSouth.setLayout(new BoxLayout(pluginPanelSouth, BoxLayout.Y_AXIS));\r\n    pluginPanelWest.setLayout(new BoxLayout(pluginPanelWest, BoxLayout.Y_AXIS));\r\n    this.getContentPane().add(pluginPanelEast, BorderLayout.EAST);\r\n    this.getContentPane().add(pluginPanelWest, BorderLayout.WEST);\r\n    this.mainPanel.add(pluginPanelSouth, BorderLayout.SOUTH);\r\n    Collection<ServiceReference<PluginComponentFactory>> serRefs;\r\n    String osgiFilter = \"(|(\" + Container.CONTAINER_ID + \"=\" + Container.CONTAINER_CHAT_WINDOW.getID() + \")(\" + Container.CONTAINER_ID + \"=\" + Container.CONTAINER_CHAT_STATUS_BAR.getID() + \"))\";\r\n    try {\r\n        serRefs = GuiActivator.bundleContext.getServiceReferences(PluginComponentFactory.class, osgiFilter);\r\n    } catch (InvalidSyntaxException ex) {\r\n        serRefs = null;\r\n        logger.error(\"Could not obtain plugin component reference.\", ex);\r\n    }\r\n    if ((serRefs != null) && !serRefs.isEmpty()) {\r\n        for (ServiceReference<PluginComponentFactory> serRef : serRefs) {\r\n            PluginComponentFactory factory = GuiActivator.bundleContext.getService(serRef);\r\n            Component comp = (Component) factory.getPluginComponentInstance(ChatWindow.this).getComponent();\r\n            if (comp.getParent() != null)\r\n                return;\r\n            Object borderLayoutConstraints = UIServiceImpl.getBorderLayoutConstraintsFromContainer(factory.getConstraints());\r\n            addPluginComponent(comp, factory.getContainer(), borderLayoutConstraints);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.callhistory.CallHistoryServiceImpl.start",
	"Comment": "starts the service. check the current registerd protocol providerswhich supports basictelephony and adds calls listener to them",
	"Method": "void start(BundleContext bc){\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Starting the call history implementation.\");\r\n    this.bundleContext = bc;\r\n    bc.addServiceListener(this);\r\n    Collection<ServiceReference<ProtocolProviderService>> ppsRefs = ServiceUtils.getServiceReferences(bc, ProtocolProviderService.class);\r\n    if (!ppsRefs.isEmpty()) {\r\n        if (logger.isDebugEnabled()) {\r\n            logger.debug(\"Found \" + ppsRefs.size() + \" already installed providers.\");\r\n        }\r\n        for (ServiceReference<ProtocolProviderService> ppsRef : ppsRefs) {\r\n            ProtocolProviderService pps = bc.getService(ppsRef);\r\n            handleProviderAdded(pps);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.MetaUIContact.getSourceIndex",
	"Comment": "returns the index of the underlying metacontact in itsmetacontactlistservice parent group.",
	"Method": "int getSourceIndex(){\r\n    MetaContactGroup parentMetaContactGroup = metaContact.getParentMetaContactGroup();\r\n    int groupSourceIndex = 0;\r\n    if (parentMetaContactGroup == null)\r\n        return -1;\r\n    MetaContactGroup parentGroup = parentMetaContactGroup.getParentMetaContactGroup();\r\n    if (parentGroup != null)\r\n        groupSourceIndex = parentGroup.indexOf(parentMetaContactGroup) * UIGroup.MAX_CONTACTS;\r\n    return GuiActivator.getContactList().getMetaContactListSource().getIndex() * UIGroup.MAX_GROUPS + groupSourceIndex + parentMetaContactGroup.indexOf(metaContact) + 1;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetPresenceSipImpl.resolveContactID",
	"Comment": "tries to find a contactsipimpl which is identified either bya specific contactid or by a derivation of it.",
	"Method": "ContactSipImpl resolveContactID(String contactID){\r\n    ContactSipImpl res = findContactByID(contactID);\r\n    if (res == null) {\r\n        if (contactID.startsWith(\"sip:\"))\r\n            res = findContactByID(contactID.substring(4));\r\n        if (res == null) {\r\n            int domainBeginIndex = contactID.indexOf('@');\r\n            if (domainBeginIndex > -1) {\r\n                res = findContactByID(contactID.substring(0, domainBeginIndex));\r\n                if ((res == null) && contactID.startsWith(\"sip:\"))\r\n                    res = findContactByID(contactID.substring(4, domainBeginIndex));\r\n            }\r\n            if (res == null) {\r\n                int domainEndIndex = contactID.indexOf(\":\", 4);\r\n                if (domainEndIndex < 0)\r\n                    domainEndIndex = contactID.indexOf(\";\", 4);\r\n                if (domainEndIndex > -1)\r\n                    res = findContactByID(contactID.substring(4, domainEndIndex));\r\n            }\r\n        }\r\n    }\r\n    return res;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaHandler.configureStream",
	"Comment": "configures stream to use the specified device,format, target, direction, etc.",
	"Method": "MediaStream configureStream(CallPeerMediaHandler<?> callPeerMediaHandler,MediaDevice device,MediaFormat format,MediaStreamTarget target,MediaDirection direction,List<RTPExtension> rtpExtensions,MediaStream stream,boolean masterStream){\r\n    registerDynamicPTsWithStream(callPeerMediaHandler, stream);\r\n    registerRTPExtensionsWithStream(callPeerMediaHandler, rtpExtensions, stream);\r\n    stream.setDevice(device);\r\n    stream.setTarget(target);\r\n    stream.setDirection(direction);\r\n    stream.setFormat(format);\r\n    MediaAwareCall<?, ?, ?> call = callPeerMediaHandler.getPeer().getCall();\r\n    MediaType mediaType = (stream instanceof AudioMediaStream) ? MediaType.AUDIO : MediaType.VIDEO;\r\n    stream.setRTPTranslator(call.getRTPTranslator(mediaType));\r\n    switch(mediaType) {\r\n        case AUDIO:\r\n            AudioMediaStream audioStream = (AudioMediaStream) stream;\r\n            setOutputVolumeControl(audioStream, call);\r\n            setAudioStream(audioStream);\r\n            break;\r\n        case VIDEO:\r\n            setVideoStream((VideoMediaStream) stream);\r\n            break;\r\n    }\r\n    if (call.isDefaultEncrypted()) {\r\n        SrtpControl srtpControl = stream.getSrtpControl();\r\n        srtpControl.setMasterSession(masterStream);\r\n        srtpControl.setSrtpListener(srtpListener);\r\n        srtpControl.start(mediaType);\r\n    }\r\n    if (stream != callPeerMediaHandler.getStream(mediaType))\r\n        streamReferenceCounts[mediaType.ordinal()]++;\r\n    return stream;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetBasicInstantMessagingJabberImpl.correctMessage",
	"Comment": "replaces the message with id correctedmessageuid sent tothe contact to with the message message",
	"Method": "void correctMessage(Contact to,ContactResource resource,Message message,String correctedMessageUID){\r\n    PacketExtension[] exts = new PacketExtension[1];\r\n    exts[0] = new MessageCorrectionExtension(correctedMessageUID);\r\n    MessageDeliveredEvent msgDelivered = sendMessage(to, resource, message, exts);\r\n    msgDelivered.setCorrectedMessageUID(correctedMessageUID);\r\n    fireMessageEvent(msgDelivered);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.jabber.JabberAccountID.setSendKeepAlive",
	"Comment": "specifies whether sip communicator should send send keep alive packetsto keep this account registered.",
	"Method": "void setSendKeepAlive(boolean sendKeepAlive){\r\n    putAccountProperty(SEND_KEEP_ALIVE, sendKeepAlive);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.GlobalStatusSelectorBox.stopConnecting",
	"Comment": "stops connecting user interface for the given protocolprovider.",
	"Method": "void stopConnecting(ProtocolProviderService protocolProvider){\r\n    StatusEntry menu = getStatusEntry(protocolProvider);\r\n    if (menu != null)\r\n        menu.stopConnecting();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.RenameContactDialog.init",
	"Comment": "initializes the renamecontactdialog by adding the buttons,fields, etc.",
	"Method": "void init(){\r\n    this.setTitle(GuiActivator.getResources().getI18NString(\"service.gui.RENAME_CONTACT\"));\r\n    this.getRootPane().setDefaultButton(renameButton);\r\n    this.renameButton.setName(\"rename\");\r\n    this.cancelButton.setName(\"cancel\");\r\n    this.clearButton.setName(\"clear\");\r\n    this.renameButton.setMnemonic(GuiActivator.getResources().getI18nMnemonic(\"service.gui.RENAME\"));\r\n    this.cancelButton.setMnemonic(GuiActivator.getResources().getI18nMnemonic(\"service.gui.CANCEL\"));\r\n    this.renameButton.addActionListener(this);\r\n    this.cancelButton.addActionListener(this);\r\n    this.clearButton.addActionListener(this);\r\n    this.buttonsPanel.add(renameButton);\r\n    this.buttonsPanel.add(cancelButton);\r\n    TransparentPanel allButtonsPanel = new TransparentPanel(new BorderLayout());\r\n    TransparentPanel firstButonPanel = new TransparentPanel(new FlowLayout(FlowLayout.LEFT));\r\n    firstButonPanel.add(clearButton);\r\n    if (metaContact.getContactCount() == 1)\r\n        allButtonsPanel.add(firstButonPanel, BorderLayout.WEST);\r\n    allButtonsPanel.add(buttonsPanel, BorderLayout.CENTER);\r\n    this.mainPanel.setBorder(BorderFactory.createEmptyBorder(5, 10, 0, 10));\r\n    this.mainPanel.add(renameContactPanel, BorderLayout.NORTH);\r\n    this.mainPanel.add(allButtonsPanel, BorderLayout.SOUTH);\r\n    this.getContentPane().add(mainPanel);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.TestOperationSetPresence.suite",
	"Comment": "creates a test suite containing all tests of this class followed bytest methods that we want executed in a specified order.",
	"Method": "Test suite(){\r\n    if (IcqSlickFixture.onlineTestingDisabled) {\r\n        TestSuite suite = new TestSuite();\r\n        suite.addTest(new TestOperationSetPresence(\"testSupportedStatusSetForCompleteness\"));\r\n        return suite;\r\n    }\r\n    TestSuite suite = new TestSuite(TestOperationSetPresence.class);\r\n    suite.addTest(new TestOperationSetPresence(\"postTestSubscribe\"));\r\n    suite.addTest(new TestOperationSetPresence(\"postTestUnsubscribe\"));\r\n    suite.addTest(new TestOperationSetPresence(\"postTestReceiveAuthorizatinonRequest\"));\r\n    return suite;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl.processInviteOK",
	"Comment": "sets to connected that state of the corresponding call peer andsends an ack.",
	"Method": "void processInviteOK(ClientTransaction clientTransaction,Response ok){\r\n    Dialog dialog = clientTransaction.getDialog();\r\n    CallPeerSipImpl callPeer = activeCallsRepository.findCallPeer(dialog);\r\n    if (callPeer == null) {\r\n        callPeer = activeCallsRepository.findCallPeer(clientTransaction.getBranchId(), ok.getHeader(CallIdHeader.NAME));\r\n        if (callPeer == null) {\r\n            if (logger.isDebugEnabled())\r\n                logger.debug(\"Received a stray ok response.\");\r\n            return;\r\n        }\r\n        callPeer.setDialog(dialog);\r\n    }\r\n    callPeer.processInviteOK(clientTransaction, ok);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.menus.ToolsMenu.initVideoBridgeMenu",
	"Comment": "initializes the appropriate video bridge menu depending on how manyregistered providers do we have that support theoperationsetvideobridge.",
	"Method": "void initVideoBridgeMenu(){\r\n    if (GuiActivator.getConfigurationService().getBoolean(OperationSetVideoBridge.IS_VIDEO_BRIDGE_DISABLED, false)) {\r\n        return;\r\n    }\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                initVideoBridgeMenu();\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    if (videoBridgeMenuItem == null) {\r\n        videoBridgeMenuItem = new VideoBridgeProviderMenuItem(GuiActivator.getResources().getI18NString(\"service.gui.CREATE_VIDEO_BRIDGE\"), null);\r\n        videoBridgeMenuItem.setEnabled(false);\r\n        insert(videoBridgeMenuItem, 1);\r\n    }\r\n    if (videoBridgeMenuListener == null) {\r\n        videoBridgeMenuListener = new VideoBridgeMenuListener();\r\n        addMenuListener(videoBridgeMenuListener);\r\n    }\r\n    if (initVideoBridgeMenuWorker == null)\r\n        initVideoBridgeMenuWorker = (OSUtils.IS_MAC) ? new InitVideoBridgeMenuWorkerMacOSX() : new InitVideoBridgeMenuWorker();\r\n    else\r\n        initVideoBridgeMenuWorker.interrupt();\r\n    initVideoBridgeMenuWorker.start();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.menus.ToolsMenu.initVideoBridgeMenu",
	"Comment": "initializes the appropriate video bridge menu depending on how manyregistered providers do we have that support theoperationsetvideobridge.",
	"Method": "void initVideoBridgeMenu(){\r\n    initVideoBridgeMenu();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.ImageUtils.getComposedImage",
	"Comment": "creates a composed image from two images. if one of the imagesis missing will add an empty space on its place.",
	"Method": "Image getComposedImage(Image leftImage,Image rightImage,ImageObserver imageObserver){\r\n    int height;\r\n    int leftWidth;\r\n    int width;\r\n    if (leftImage == null) {\r\n        if (rightImage == null) {\r\n            return null;\r\n        } else {\r\n            height = rightImage.getHeight(imageObserver);\r\n            leftWidth = rightImage.getWidth(imageObserver);\r\n            width = leftWidth * 2;\r\n        }\r\n    } else if (rightImage == null) {\r\n        height = leftImage.getHeight(imageObserver);\r\n        leftWidth = leftImage.getWidth(imageObserver);\r\n        width = leftWidth * 2;\r\n    } else {\r\n        height = Math.max(leftImage.getHeight(imageObserver), rightImage.getHeight(imageObserver));\r\n        leftWidth = leftImage.getWidth(imageObserver);\r\n        width = leftWidth + rightImage.getWidth(imageObserver);\r\n    }\r\n    BufferedImage buffImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\r\n    Graphics2D g = (Graphics2D) buffImage.getGraphics();\r\n    AntialiasingManager.activateAntialiasing(g);\r\n    g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER));\r\n    if (leftImage != null)\r\n        g.drawImage(leftImage, 0, 0, null);\r\n    if (rightImage != null)\r\n        g.drawImage(rightImage, leftWidth + 1, 0, null);\r\n    return buffImage;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.whiteboard.WhiteboardSessionManager.acceptInvitation",
	"Comment": "called to accept an incoming invitation. adds the invitation chat roomto the list of chat rooms and joins it.",
	"Method": "void acceptInvitation(WhiteboardInvitation invitation){\r\n    WhiteboardSession whiteboard = invitation.getTargetWhiteboard();\r\n    byte[] password = invitation.getWhiteboardPassword();\r\n    try {\r\n        if (password == null)\r\n            whiteboard.join();\r\n        else\r\n            whiteboard.join(password);\r\n    } catch (OperationFailedException e) {\r\n        WhiteboardActivator.getUiService().getPopupDialog().showMessagePopupDialog(Resources.getString(\"failedToJoinWhiteboard\", new String[] { whiteboard.getWhiteboardID() }), Resources.getString(\"service.gui.ERROR\"), PopupDialog.ERROR_MESSAGE);\r\n        logger.error(\"Failed to join whiteboard: \" + whiteboard.getWhiteboardID(), e);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.InviteUIContact.getDefaultContactDetail",
	"Comment": "returns the default contactdetail to use for any operationsdepending to the given operationset class.",
	"Method": "UIContactDetail getDefaultContactDetail(Class<? extends OperationSet> opSetClass){\r\n    return sourceUIContact.getDefaultContactDetail(opSetClass);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler.setStreamAudioLevelListener",
	"Comment": "if the local audiomediastream has already been created, setslistener as the simpleaudiolevellistener that it shouldnotify for stream user level events. otherwise stores a reference tolistener so that we could add it once we create the stream.",
	"Method": "void setStreamAudioLevelListener(SimpleAudioLevelListener listener){\r\n    synchronized (streamAudioLevelListenerLock) {\r\n        if (this.streamAudioLevelListener != listener) {\r\n            MediaHandler mediaHandler = getMediaHandler();\r\n            if ((mediaHandler != null) && (this.streamAudioLevelListener != null)) {\r\n                mediaHandler.removeStreamAudioLevelListener(this.streamAudioLevelListener);\r\n            }\r\n            this.streamAudioLevelListener = listener;\r\n            if ((mediaHandler != null) && (this.streamAudioLevelListener != null)) {\r\n                mediaHandler.addStreamAudioLevelListener(this.streamAudioLevelListener);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.AdHocChatRoomIcqImpl.addParticipantPresenceListener",
	"Comment": "adds a listener that will be notified of changes in our status in theroom such as us being kicked, banned, or granted admin permissions.",
	"Method": "void addParticipantPresenceListener(AdHocChatRoomParticipantPresenceListener listener){\r\n    synchronized (memberListeners) {\r\n        if (!memberListeners.contains(listener))\r\n            memberListeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.TreeContactList.addContactSource",
	"Comment": "adds the given contact source to the list of available contact sources.",
	"Method": "void addContactSource(ContactSourceService contactSource){\r\n    if (!(contactSource instanceof AsyncContactSourceService) || ((AsyncContactSourceService) contactSource).canBeUsedToSearchContacts()) {\r\n        contactSources.add(new ExternalContactSource(contactSource, this));\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.sipaccregwizz.SIPAccountRegistrationWizard.getSummary",
	"Comment": "returns the set of data that user has entered through this wizard.",
	"Method": "Iterator<Map.Entry<String, String>> getSummary(){\r\n    LinkedHashMap<String, String> summaryTable = new LinkedHashMap<String, String>();\r\n    boolean rememberPswd = registration.isRememberPassword();\r\n    String rememberPswdString = Resources.getString(rememberPswd ? \"service.gui.YES\" : \"service.gui.NO\");\r\n    String displayName = registration.getAccountPropertyString(ProtocolProviderFactory.DISPLAY_NAME);\r\n    if (displayName != null && displayName.length() > 0)\r\n        summaryTable.put(Resources.getString(\"plugin.sipaccregwizz.DISPLAY_NAME\"), displayName);\r\n    summaryTable.put(Resources.getString(\"plugin.sipaccregwizz.USERNAME\"), registration.getId());\r\n    summaryTable.put(Resources.getString(\"service.gui.REMEMBER_PASSWORD\"), rememberPswdString);\r\n    summaryTable.put(Resources.getString(\"plugin.sipaccregwizz.REGISTRAR\"), registration.getServerAddress());\r\n    String authName = registration.getAuthorizationName();\r\n    if (authName != null)\r\n        summaryTable.put(Resources.getString(\"plugin.sipaccregwizz.AUTH_NAME\"), authName);\r\n    String serverPort = registration.getServerPort();\r\n    if (serverPort != null && serverPort.length() > 0)\r\n        summaryTable.put(Resources.getString(\"plugin.sipaccregwizz.SERVER_PORT\"), serverPort);\r\n    if (registration.isProxyAutoConfigure()) {\r\n        summaryTable.put(Resources.getString(\"plugin.sipaccregwizz.PROXY_AUTO\"), Resources.getString(\"service.gui.YES\"));\r\n    } else {\r\n        String proxy = registration.getProxy();\r\n        if (proxy != null && proxy.length() > 0)\r\n            summaryTable.put(Resources.getString(\"plugin.sipaccregwizz.PROXY\"), proxy);\r\n        String proxyPort = registration.getProxyPort();\r\n        if (proxyPort != null && proxyPort.length() > 0)\r\n            summaryTable.put(Resources.getString(\"plugin.sipaccregwizz.PROXY_PORT\"), proxyPort);\r\n        summaryTable.put(Resources.getString(\"plugin.sipaccregwizz.PREFERRED_TRANSPORT\"), registration.getPreferredTransport());\r\n    }\r\n    if (registration.isEnablePresence()) {\r\n        summaryTable.put(Resources.getString(\"plugin.sipaccregwizz.ENABLE_PRESENCE\"), Resources.getString(\"service.gui.YES\"));\r\n    } else {\r\n        summaryTable.put(Resources.getString(\"plugin.sipaccregwizz.ENABLE_PRESENCE\"), Resources.getString(\"service.gui.NO\"));\r\n    }\r\n    if (registration.isForceP2PMode()) {\r\n        summaryTable.put(Resources.getString(\"plugin.sipaccregwizz.FORCE_P2P_PRESENCE\"), Resources.getString(\"service.gui.YES\"));\r\n    } else {\r\n        summaryTable.put(Resources.getString(\"plugin.sipaccregwizz.FORCE_P2P_PRESENCE\"), Resources.getString(\"service.gui.NO\"));\r\n    }\r\n    SecurityAccountRegistration securityReg = registration.getSecurityRegistration();\r\n    if (securityReg.isDefaultEncryption()) {\r\n        summaryTable.put(Resources.getString(\"plugin.sipaccregwizz.ENABLE_DEFAULT_ENCRYPTION\"), Resources.getString(\"service.gui.YES\"));\r\n    } else {\r\n        summaryTable.put(Resources.getString(\"plugin.sipaccregwizz.ENABLE_DEFAULT_ENCRYPTION\"), Resources.getString(\"service.gui.NO\"));\r\n    }\r\n    if (securityReg.isSipZrtpAttribute()) {\r\n        summaryTable.put(Resources.getString(\"plugin.sipaccregwizz.ENABLE_SIPZRTP_ATTRIBUTE\"), Resources.getString(\"service.gui.YES\"));\r\n    } else {\r\n        summaryTable.put(Resources.getString(\"plugin.sipaccregwizz.ENABLE_SIPZRTP_ATTRIBUTE\"), Resources.getString(\"service.gui.NO\"));\r\n    }\r\n    summaryTable.put(Resources.getString(\"plugin.sipaccregwizz.OFFLINE_CONTACT_POLLING_PERIOD\"), registration.getPollingPeriod());\r\n    summaryTable.put(Resources.getString(\"plugin.sipaccregwizz.SUBSCRIPTION_EXPIRATION\"), registration.getSubscriptionExpiration());\r\n    summaryTable.put(Resources.getString(\"plugin.sipaccregwizz.KEEP_ALIVE_METHOD\"), registration.getKeepAliveMethod());\r\n    summaryTable.put(Resources.getString(\"plugin.sipaccregwizz.KEEP_ALIVE_INTERVAL\"), registration.getKeepAliveInterval());\r\n    summaryTable.put(Resources.getString(\"plugin.sipaccregwizz.DTMF_METHOD\"), registration.getDTMFMethod());\r\n    summaryTable.put(Resources.getString(\"plugin.sipaccregwizz.DTMF_MINIMAL_TONE_DURATION\"), registration.getDtmfMinimalToneDuration());\r\n    if (registration.isXCapEnable() || registration.isXiVOEnable()) {\r\n        summaryTable.put(\"XCAP \" + Resources.getString(\"plugin.sipaccregwizz.XCAP_SERVER_URI\"), registration.getClistOptionServerUri());\r\n        if (registration.isClistOptionUseSipCredentials()) {\r\n            summaryTable.put(\"XCAP \" + Resources.getString(\"plugin.sipaccregwizz.XCAP_USE_SIP_CREDENTIALS\"), Resources.getString(\"service.gui.YES\"));\r\n        } else {\r\n            summaryTable.put(\"XCAP \" + Resources.getString(\"plugin.sipaccregwizz.XCAP_USER\"), registration.getClistOptionUser());\r\n        }\r\n    }\r\n    if (registration.isMessageWaitingIndicationsEnabled()) {\r\n        if (!StringUtils.isNullOrEmpty(registration.getVoicemailURI(), true))\r\n            summaryTable.put(Resources.getString(\"plugin.sipaccregwizz.VOICEMAIL_URI\"), registration.getVoicemailURI());\r\n        if (!StringUtils.isNullOrEmpty(registration.getVoicemailCheckURI(), true))\r\n            summaryTable.put(Resources.getString(\"plugin.sipaccregwizz.VOICEMAIL_CHECK_URI\"), registration.getVoicemailURI());\r\n    }\r\n    return summaryTable.entrySet().iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.busylampfield.BLFActivator.handleProviderAdded",
	"Comment": "adds a protocol provider, when such provider is registered.",
	"Method": "void handleProviderAdded(ProtocolProviderService protocolProvider){\r\n    OperationSetTelephonyBLF opset = protocolProvider.getOperationSet(OperationSetTelephonyBLF.class);\r\n    if (opset == null)\r\n        return;\r\n    opset.addStatusListener(this);\r\n    for (OperationSetTelephonyBLF.Line line : opset.getCurrentlyMonitoredLines()) {\r\n        String groupName = line.getGroup();\r\n        if (groupName == null)\r\n            groupName = BLF_DEFAULT_GROUP_NAME;\r\n        ServiceRegistration<ContactSourceService> serviceReg = currentBLFGroups.get(groupName);\r\n        if (serviceReg != null) {\r\n            BLFContactSourceService css = (BLFContactSourceService) bundleContext.getService(serviceReg.getReference());\r\n            css.addLine(line);\r\n            continue;\r\n        } else {\r\n            BLFContactSourceService css = new BLFContactSourceService(groupName, currentBLFGroups.size() + 1);\r\n            serviceReg = bundleContext.registerService(ContactSourceService.class, css, null);\r\n            currentBLFGroups.put(groupName, serviceReg);\r\n            css.addLine(line);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.filehistory.FileHistoryServiceImpl.handleProviderAdded",
	"Comment": "used to attach the file history service to existing orjust registered protocol provider. checks if the provider has implementationof operationsetfiletransfer",
	"Method": "void handleProviderAdded(ProtocolProviderService provider){\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Adding protocol provider \" + provider.getProtocolName());\r\n    OperationSetFileTransfer opSetFileTransfer = provider.getOperationSet(OperationSetFileTransfer.class);\r\n    if (opSetFileTransfer != null) {\r\n        opSetFileTransfer.addFileTransferListener(this);\r\n    } else {\r\n        if (logger.isTraceEnabled())\r\n            logger.trace(\"Service did not have a file transfer op. set.\");\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommDialog.setVisible",
	"Comment": "overwrites the setvisible method in order to set the size and theposition of this window before showing it.",
	"Method": "void setVisible(boolean isVisible){\r\n    if (isVisible) {\r\n        this.pack();\r\n        if (isSaveSizeAndLocation)\r\n            this.setSizeAndLocation();\r\n        else {\r\n            this.pack();\r\n            this.setCenterLocation();\r\n        }\r\n        ensureOnScreenLocationAndSize();\r\n        JButton button = this.getRootPane().getDefaultButton();\r\n        if (button != null)\r\n            button.requestFocus();\r\n    }\r\n    super.setVisible(isVisible);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.sdp.SdpUtils.createFormat",
	"Comment": "creates and returns mediaformat instance corresponding to thespecified payloadtype and the parameters in the rtpmapand fmtp attributes. the method would only returnmediaformat instances for formats known to our media serviceimplementation and returns null otherwise.",
	"Method": "MediaFormat createFormat(byte payloadType,Attribute rtpmap,Attribute fmtp,float frameRate,List<Attribute> advp,DynamicPayloadTypeRegistry ptRegistry){\r\n    String encoding = null;\r\n    double clockRate = -1;\r\n    int numChannels = 1;\r\n    if (rtpmap != null) {\r\n        String rtpmapValue = rtpmap.getValue();\r\n        StringTokenizer tokenizer = new StringTokenizer(rtpmapValue, \" /\", false);\r\n        if (tokenizer.hasMoreTokens()) {\r\n            tokenizer.nextToken();\r\n        }\r\n        if (tokenizer.hasMoreTokens()) {\r\n            encoding = tokenizer.nextToken();\r\n        }\r\n        if (tokenizer.hasMoreTokens()) {\r\n            clockRate = Double.parseDouble(tokenizer.nextToken());\r\n        }\r\n        if (tokenizer.hasMoreTokens()) {\r\n            String nChansStr = tokenizer.nextToken();\r\n            try {\r\n                numChannels = Integer.parseInt(nChansStr);\r\n            } catch (NumberFormatException exc) {\r\n                if (logger.isDebugEnabled())\r\n                    logger.debug(nChansStr + \" is not a valid number of channels.\", exc);\r\n            }\r\n        }\r\n    } else {\r\n        MediaFormat fmt = ptRegistry.findFormat(payloadType);\r\n        if (fmt != null)\r\n            return fmt;\r\n    }\r\n    Map<String, String> fmtParamsMap = null;\r\n    Map<String, String> advancedAttrMap = null;\r\n    if (fmtp != null)\r\n        fmtParamsMap = parseFmtpAttribute(fmtp);\r\n    if (advp != null)\r\n        advancedAttrMap = parseAdvancedAttributes(advp);\r\n    if (\"opus\".equals(encoding))\r\n        numChannels = 2;\r\n    MediaFormat format = SipActivator.getMediaService().getFormatFactory().createMediaFormat(payloadType, encoding, clockRate, numChannels, frameRate, fmtParamsMap, advancedAttrMap);\r\n    if ((payloadType >= MediaFormat.MIN_DYNAMIC_PAYLOAD_TYPE) && (payloadType <= MediaFormat.MAX_DYNAMIC_PAYLOAD_TYPE) && (format != null)) {\r\n        ptRegistry.addMapping(format, payloadType);\r\n    }\r\n    return format;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.generalconfig.GeneralConfigPluginActivator.getSystrayService",
	"Comment": "returns the systrayservice obtained from the bundlecontext.",
	"Method": "SystrayService getSystrayService(){\r\n    if (systrayService == null) {\r\n        ServiceReference configReference = bundleContext.getServiceReference(SystrayService.class.getName());\r\n        systrayService = (SystrayService) bundleContext.getService(configReference);\r\n    }\r\n    return systrayService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockFileTransferImpl.fireStatusChangeEvent",
	"Comment": "notifies all status listeners that a newfiletransferstatuschangeevent occured.",
	"Method": "void fireStatusChangeEvent(int newStatus){\r\n    super.fireStatusChangeEvent(newStatus);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWindow.addPluginComponent",
	"Comment": "adds the given component with to the container corresponding to thegiven constraints.",
	"Method": "void addPluginComponent(Component c,Container container,Object constraints){\r\n    if (container.equals(Container.CONTAINER_CHAT_WINDOW)) {\r\n        if (constraints.equals(BorderLayout.SOUTH)) {\r\n            pluginPanelSouth.add(c);\r\n            pluginPanelSouth.repaint();\r\n        } else if (constraints.equals(BorderLayout.WEST)) {\r\n            pluginPanelWest.add(c);\r\n            pluginPanelSouth.repaint();\r\n        } else if (constraints.equals(BorderLayout.EAST)) {\r\n            pluginPanelEast.add(c);\r\n            pluginPanelSouth.repaint();\r\n        }\r\n    } else if (container.equals(Container.CONTAINER_CHAT_STATUS_BAR)) {\r\n        statusBarPanel.add(c);\r\n    }\r\n    this.getContentPane().repaint();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.history.HistoryServiceImpl.getExistingFiles",
	"Comment": "get existing files in res and their corresponding historyids.",
	"Method": "void getExistingFiles(File sourceFolder,List<String> rawID,Map<File, HistoryID> res){\r\n    for (File f : sourceFolder.listFiles()) {\r\n        if (f.isDirectory()) {\r\n            List<String> newRawID = new ArrayList<String>(rawID);\r\n            newRawID.add(f.getName());\r\n            getExistingFiles(f, newRawID, res);\r\n        } else {\r\n            if (f.getName().equals(DATA_FILE))\r\n                continue;\r\n            res.put(f, HistoryID.createFromRawStrings(rawID.toArray(new String[rawID.size()])));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.icqaccregwizz.FirstWizardPage.loadAccount",
	"Comment": "fills the uin and password fields in this panel with the data commingfrom the given protocolprovider.",
	"Method": "void loadAccount(ProtocolProviderService protocolProvider){\r\n    AccountID accountID = protocolProvider.getAccountID();\r\n    String password = IcqAccRegWizzActivator.getIcqProtocolProviderFactory().loadPassword(accountID);\r\n    this.uinField.setText(accountID.getUserID());\r\n    this.uinField.setEnabled(false);\r\n    if (password != null) {\r\n        this.passField.setText(password);\r\n        this.rememberPassBox.setSelected(true);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.IcqActivator.getAimProtocolProviderFactory",
	"Comment": "retrurns a reference to the protocol provider factory that we haveregistered for aim accounts.",
	"Method": "ProtocolProviderFactoryIcqImpl getAimProtocolProviderFactory(){\r\n    return aimProviderFactory;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockContactGroup.getContact",
	"Comment": "returns the contact with the specified address or identifier.",
	"Method": "Contact getContact(String id){\r\n    Iterator<Contact> contactsIter = contacts();\r\n    while (contactsIter.hasNext()) {\r\n        Contact contact = contactsIter.next();\r\n        if (contact.getAddress().equals(id))\r\n            return contact;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetWebContactInfoIcqImpl.getWebContactInfo",
	"Comment": "returns the url of a page containing information on the contact withthe specified contactaddress.",
	"Method": "URL getWebContactInfo(Contact contact,URL getWebContactInfo,String contactAddress){\r\n    try {\r\n        return new URL(\"http://www.icq.com/people/about_me.php?uin=\" + contactAddress);\r\n    } catch (MalformedURLException ex) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chatroomslist.createforms.CreateChatRoomWizardPage2.getIdentifier",
	"Comment": "implements the wizardpaneldescriptor method to return theidentifier of this page.",
	"Method": "Object getIdentifier(){\r\n    return IDENTIFIER;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ServerStoredContactListJabberImpl.fireGroupEvent",
	"Comment": "creates the corresponding event and notifies allserverstoredgrouplisteners that the source group has beenremoved, changed, renamed or whatever happened to it.",
	"Method": "void fireGroupEvent(ContactGroupJabberImpl group,int eventID){\r\n    if (parentOperationSet == null) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"No presence op. set available. Bailing out.\");\r\n        return;\r\n    }\r\n    ServerStoredGroupEvent evt = new ServerStoredGroupEvent(group, eventID, parentOperationSet.getServerStoredContactListRoot(), jabberProvider, parentOperationSet);\r\n    if (logger.isTraceEnabled())\r\n        logger.trace(\"Will dispatch the following grp event: \" + evt);\r\n    Iterable<ServerStoredGroupListener> listeners;\r\n    synchronized (serverStoredGroupListeners) {\r\n        listeners = new ArrayList<ServerStoredGroupListener>(serverStoredGroupListeners);\r\n    }\r\n    if (eventID == ServerStoredGroupEvent.GROUP_CREATED_EVENT) {\r\n        Iterator<Contact> iter = group.contacts();\r\n        while (iter.hasNext()) {\r\n            ContactJabberImpl c = (ContactJabberImpl) iter.next();\r\n            if (roster != null) {\r\n                parentOperationSet.firePresenceStatusChanged(roster.getPresence(c.getAddress()));\r\n            }\r\n        }\r\n    }\r\n    for (ServerStoredGroupListener listener : listeners) {\r\n        if (eventID == ServerStoredGroupEvent.GROUP_REMOVED_EVENT)\r\n            listener.groupRemoved(evt);\r\n        else if (eventID == ServerStoredGroupEvent.GROUP_RENAMED_EVENT)\r\n            listener.groupNameChanged(evt);\r\n        else if (eventID == ServerStoredGroupEvent.GROUP_CREATED_EVENT)\r\n            listener.groupCreated(evt);\r\n        else if (eventID == ServerStoredGroupEvent.GROUP_RESOLVED_EVENT)\r\n            listener.groupResolved(evt);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl.processBusyHere",
	"Comment": "sets corresponding state to the call peer associated with thistransaction.",
	"Method": "void processBusyHere(ClientTransaction clientTransaction,Response busyHere){\r\n    Dialog dialog = clientTransaction.getDialog();\r\n    CallPeerSipImpl callPeer = activeCallsRepository.findCallPeer(dialog);\r\n    if (callPeer == null) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Received a stray busyHere response.\");\r\n        return;\r\n    }\r\n    callPeer.setState(CallPeerState.BUSY);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.contactlist.TestMetaContactList.testAddMoveRemoveContactToMetaContact",
	"Comment": "perform manipulations of moving protocol contacts in and outside of ameta contact and verify that they complete properly.",
	"Method": "void testAddMoveRemoveContactToMetaContact(){\r\n    String newContactID = \"TestyPesty\";\r\n    MetaContact metaContact = fixture.metaClService.getRoot().getMetaContact(0);\r\n    MetaContact dstMetaContact = fixture.metaClService.getRoot().getMetaContact(1);\r\n    MclEventCollector evtCollector = new MclEventCollector();\r\n    fixture.metaClService.addMetaContactListListener(evtCollector);\r\n    fixture.metaClService.addNewContactToMetaContact(MclSlickFixture.mockProvider, metaContact, newContactID);\r\n    fixture.metaClService.removeMetaContactListListener(evtCollector);\r\n    assertEquals(\"Dest. meta Contact did not seem to contain an \" + \"extra proto contact.\", 2, metaContact.getContactCount());\r\n    MockContact newContact = (MockContact) metaContact.getContact(newContactID, MclSlickFixture.mockProvider);\r\n    assertNotNull(\"newContact\", newContact);\r\n    assertSame(\"Proto specific contact in mock contact list.\", newContact, MclSlickFixture.mockPresOpSet.getServerStoredContactListRoot().getContact(newContactID));\r\n    assertEquals(\"Events delivered while adding a new contact to a \" + \"meta contact\", 1, evtCollector.collectedMetaContactEvents.size());\r\n    ProtoContactEvent event = (ProtoContactEvent) evtCollector.collectedMetaContactEvents.remove(0);\r\n    assertSame(\"Source contact in ProtoContactEvent gen. upon add.\", newContact, event.getProtoContact());\r\n    assertSame(\"Source provider in ProtoContactEvent gen. upon add.\", MclSlickFixture.mockProvider, event.getProtoContact().getProtocolProvider());\r\n    assertEquals(\"Event ID in MetaContactEvent gen. upon add.\", ProtoContactEvent.PROTO_CONTACT_ADDED, event.getPropertyName());\r\n    fixture.metaClService.addMetaContactListListener(evtCollector);\r\n    fixture.metaClService.moveContact(newContact, dstMetaContact);\r\n    fixture.metaClService.removeMetaContactListListener(evtCollector);\r\n    assertEquals(\"Orig. Meta Contact did not seem restored after removing \" + \"the newly added contact.\", 1, metaContact.getContactCount());\r\n    assertEquals(\"A Meta Contact did not seem updated after moving a \" + \"contact inside it.\", 2, dstMetaContact.getContactCount());\r\n    newContact = (MockContact) dstMetaContact.getContact(newContactID, MclSlickFixture.mockProvider);\r\n    assertNotNull(\"newContact\", newContact);\r\n    assertEquals(\"Events delivered while adding a moving a proto contact. \", 1, evtCollector.collectedMetaContactEvents.size());\r\n    event = (ProtoContactEvent) evtCollector.collectedMetaContactEvents.remove(0);\r\n    assertSame(\"Source contact in ProtoContactEvent gen. upon move.\", newContact, event.getProtoContact());\r\n    assertSame(\"Parent meta contact in ProtoContactEvent gen. upon move.\", dstMetaContact, event.getParent());\r\n    assertSame(\"Source provider in ProtoContactEvent gen. upon move.\", MclSlickFixture.mockProvider, event.getProtoContact().getProtocolProvider());\r\n    assertEquals(\"Event ID in ProtoContactEvent gen. upon add.\", ProtoContactEvent.PROTO_CONTACT_MOVED, event.getPropertyName());\r\n    fixture.metaClService.addMetaContactListListener(evtCollector);\r\n    fixture.metaClService.removeContact(newContact);\r\n    fixture.metaClService.removeMetaContactListListener(evtCollector);\r\n    assertEquals(\"Dest. Meta Contact did not seem restored after removing \" + \"the newly added contact.\", 1, dstMetaContact.getContactCount());\r\n    assertNull(\"The MetaContactList did not remove a contact from the \" + \"MockList on del.\", MclSlickFixture.mockPresOpSet.getServerStoredContactListRoot().getContact(newContactID));\r\n    assertEquals(\"Events delivered while adding a new contact to a \" + \"meta contact\", 1, evtCollector.collectedMetaContactEvents.size());\r\n    event = (ProtoContactEvent) evtCollector.collectedMetaContactEvents.remove(0);\r\n    assertSame(\"Source contact in ProtoContactEvent gen. upon remove.\", newContact, event.getProtoContact());\r\n    assertSame(\"Parent meta contact in ProtoContactEvent gen. upon remove.\", dstMetaContact, event.getParent());\r\n    assertSame(\"Source provider in ProtoContactEvent gen. upon remove.\", MclSlickFixture.mockProvider, event.getProtoContact().getProtocolProvider());\r\n    assertEquals(\"Event ID in ProtoContactEvent gen. upon remove.\", ProtoContactEvent.PROTO_CONTACT_REMOVED, event.getPropertyName());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.AdHocConferenceChatSession.getChatSessionRenderer",
	"Comment": "returns the chatsessionrenderer that provides the connectionbetween this chat session and its ui.",
	"Method": "ChatSessionRenderer getChatSessionRenderer(){\r\n    return sessionRenderer;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetPresenceSipImpl.processResponse",
	"Comment": "analyzes the incoming responseevent and then forwards it to theproper event handler.",
	"Method": "boolean processResponse(ResponseEvent responseEvent){\r\n    if (this.presenceEnabled == false)\r\n        return false;\r\n    ClientTransaction clientTransaction = responseEvent.getClientTransaction();\r\n    Response response = responseEvent.getResponse();\r\n    CSeqHeader cseq = (CSeqHeader) response.getHeader(CSeqHeader.NAME);\r\n    if (cseq == null) {\r\n        logger.error(\"An incoming response did not contain a CSeq header\");\r\n        return false;\r\n    }\r\n    String method = cseq.getMethod();\r\n    boolean processed = false;\r\n    if (method.equals(Request.PUBLISH)) {\r\n        if (response.getStatusCode() != Response.UNAUTHORIZED && response.getStatusCode() != Response.PROXY_AUTHENTICATION_REQUIRED && response.getStatusCode() != Response.INTERVAL_TOO_BRIEF) {\r\n            synchronized (this.waitedCallIds) {\r\n                this.waitedCallIds.remove(((CallIdHeader) response.getHeader(CallIdHeader.NAME)).getCallId());\r\n            }\r\n        }\r\n        if (response.getStatusCode() == Response.OK) {\r\n            SIPETagHeader etHeader = (SIPETagHeader) response.getHeader(SIPETagHeader.NAME);\r\n            if (etHeader == null) {\r\n                if (logger.isDebugEnabled())\r\n                    logger.debug(\"can't find the ETag header\");\r\n                return false;\r\n            }\r\n            this.distantPAET = etHeader.getETag();\r\n            ExpiresHeader expires = (ExpiresHeader) response.getHeader(ExpiresHeader.NAME);\r\n            if (expires == null) {\r\n                logger.error(\"no Expires header in the response\");\r\n                return false;\r\n            }\r\n            if (expires.getExpires() == 0) {\r\n                this.distantPAET = null;\r\n                return true;\r\n            }\r\n            if (this.republishTask != null)\r\n                this.republishTask.cancel();\r\n            this.republishTask = new RePublishTask();\r\n            int republishDelay = expires.getExpires();\r\n            if (republishDelay >= (2 * REFRESH_MARGIN))\r\n                republishDelay -= REFRESH_MARGIN;\r\n            timer.schedule(this.republishTask, republishDelay * 1000);\r\n        } else if (response.getStatusCode() == Response.UNAUTHORIZED || response.getStatusCode() == Response.PROXY_AUTHENTICATION_REQUIRED) {\r\n            try {\r\n                processAuthenticationChallenge(clientTransaction, response, (SipProvider) responseEvent.getSource());\r\n            } catch (OperationFailedException e) {\r\n                logger.error(\"can't handle the challenge\", e);\r\n                return false;\r\n            }\r\n        } else if (response.getStatusCode() == Response.INTERVAL_TOO_BRIEF) {\r\n            MinExpiresHeader min = (MinExpiresHeader) response.getHeader(MinExpiresHeader.NAME);\r\n            if (min == null) {\r\n                logger.error(\"can't find a min expires header in the 423\" + \" error message\");\r\n                return false;\r\n            }\r\n            Request req = null;\r\n            try {\r\n                req = createPublish(min.getExpires(), true);\r\n            } catch (OperationFailedException e) {\r\n                logger.error(\"can't create the new publish request\", e);\r\n                return false;\r\n            }\r\n            ClientTransaction transac = null;\r\n            try {\r\n                transac = this.parentProvider.getDefaultJainSipProvider().getNewClientTransaction(req);\r\n            } catch (TransactionUnavailableException e) {\r\n                logger.error(\"can't create the client transaction\", e);\r\n                return false;\r\n            }\r\n            try {\r\n                transac.sendRequest();\r\n            } catch (SipException e) {\r\n                logger.error(\"can't send the PUBLISH request\", e);\r\n                return false;\r\n            }\r\n        } else if (response.getStatusCode() == Response.CONDITIONAL_REQUEST_FAILED) {\r\n            this.distantPAET = null;\r\n            Request req = null;\r\n            try {\r\n                req = createPublish(this.subscriptionDuration, true);\r\n            } catch (OperationFailedException e) {\r\n                logger.error(\"can't create the new publish request\", e);\r\n                return false;\r\n            }\r\n            ClientTransaction transac = null;\r\n            try {\r\n                transac = this.parentProvider.getDefaultJainSipProvider().getNewClientTransaction(req);\r\n            } catch (TransactionUnavailableException e) {\r\n                logger.error(\"can't create the client transaction\", e);\r\n                return false;\r\n            }\r\n            try {\r\n                transac.sendRequest();\r\n            } catch (SipException e) {\r\n                logger.error(\"can't send the PUBLISH request\", e);\r\n                return false;\r\n            }\r\n        } else if (response.getStatusCode() >= 100 && response.getStatusCode() < 200) {\r\n        } else {\r\n            if (logger.isDebugEnabled())\r\n                logger.debug(\"error received from the network\" + response);\r\n            this.distantPAET = null;\r\n            if (this.useDistantPA) {\r\n                if (logger.isDebugEnabled())\r\n                    logger.debug(\"we enter into the peer-to-peer mode\" + \" as the distant PA mode fails\");\r\n                setUseDistantPA(false);\r\n            }\r\n        }\r\n        processed = true;\r\n    }\r\n    return processed;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.plaf.SIPCommTabbedPaneUI.installComponents",
	"Comment": "creates and installs any required subcomponents for the jtabbedpane.invoked by installui.",
	"Method": "void installComponents(){\r\n    if (tabScroller == null) {\r\n        tabScroller = new ScrollableTabSupport(tabPane.getTabPlacement());\r\n        tabPane.add(tabScroller.viewport);\r\n        tabPane.add(tabScroller.scrollForwardButton);\r\n        tabPane.add(tabScroller.scrollBackwardButton);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.OperationSetPersistentPresenceIrcImpl.moveContactToGroup",
	"Comment": "moving contacts to a different group is currently not implemented.",
	"Method": "void moveContactToGroup(Contact contactToMove,ContactGroup newParent){\r\n    LOGGER.trace(\"moveContactToGroup called\");\r\n    if (!(contactToMove instanceof ContactIrcImpl)) {\r\n        throw new IllegalArgumentException(\"contactToMove must be an instance of ContactIrcImpl\");\r\n    }\r\n    final ContactIrcImpl contact = (ContactIrcImpl) contactToMove;\r\n    ((ContactGroupIrcImpl) contact.getParentContactGroup()).removeContact(contact);\r\n    final ContactGroupIrcImpl newGroup = (ContactGroupIrcImpl) newParent;\r\n    newGroup.addContact(contact);\r\n    contact.setParentContactGroup(newGroup);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaHandler.initStream",
	"Comment": "creates if necessary, and configures the stream that thismediahandler is using for the mediatype matching theone of the mediadevice.",
	"Method": "MediaStream initStream(CallPeerMediaHandler<?> callPeerMediaHandler,StreamConnector connector,MediaDevice device,MediaFormat format,MediaStreamTarget target,MediaDirection direction,List<RTPExtension> rtpExtensions,boolean masterStream){\r\n    MediaType mediaType = device.getMediaType();\r\n    MediaStream stream = getStream(callPeerMediaHandler, mediaType);\r\n    if (stream == null) {\r\n        if (logger.isTraceEnabled() && (mediaType != format.getMediaType()))\r\n            logger.trace(\"The media types of device and format differ.\");\r\n        MediaService mediaService = ProtocolMediaActivator.getMediaService();\r\n        SrtpControl srtpControl = srtpControls.findFirst(mediaType);\r\n        if (srtpControl == null) {\r\n            stream = mediaService.createMediaStream(connector, device);\r\n            srtpControl = stream.getSrtpControl();\r\n            if (srtpControl != null)\r\n                srtpControls.set(mediaType, srtpControl);\r\n        } else {\r\n            stream = mediaService.createMediaStream(connector, device, srtpControl);\r\n        }\r\n    } else {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Reinitializing stream: \" + stream);\r\n    }\r\n    return configureStream(callPeerMediaHandler, device, format, target, direction, rtpExtensions, stream, masterStream);\r\n}"
}, {
	"Path": "net.librec.recommender.cf.UserKNNTestCase.test26SplitterRatioUserDate",
	"Comment": "test ratiodatasplitter with user date ratio, filter enabled.",
	"Method": "void test26SplitterRatioUserDate(){\r\n    Resource resource = new Resource(\"rec/cf/userknn-test.properties\");\r\n    conf.addResource(resource);\r\n    conf.set(\"rec.eval.enable\", \"false\");\r\n    conf.set(\"rec.filter.class\", \"generic\");\r\n    conf.set(\"data.model.splitter\", \"ratio\");\r\n    conf.set(\"data.input.path\", \"test/datamodeltest/ratings-date.txt\");\r\n    conf.set(\"data.column.format\", \"UIRT\");\r\n    conf.set(\"data.splitter.ratio\", \"userdate\");\r\n    RecommenderJob job = new RecommenderJob(conf);\r\n    job.runJob();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.sdp.SdpUtils.createSessionDescription",
	"Comment": "creates an empty instance of a sessiondescription withpreinitialized s, v, c, o andt parameters.",
	"Method": "SessionDescription createSessionDescription(InetAddress localAddress,SessionDescription createSessionDescription,InetAddress localAddress,String userName,List<MediaDescription> mediaDescriptions){\r\n    SessionDescription sessDescr = null;\r\n    try {\r\n        sessDescr = sdpFactory.createSessionDescription();\r\n        Version v = sdpFactory.createVersion(0);\r\n        sessDescr.setVersion(v);\r\n        sessDescr.setSessionName(sdpFactory.createSessionName(\"-\"));\r\n        TimeDescription t = sdpFactory.createTimeDescription();\r\n        Vector<TimeDescription> timeDescs = new Vector<TimeDescription>();\r\n        timeDescs.add(t);\r\n        sessDescr.setTimeDescriptions(timeDescs);\r\n        String addrType = localAddress instanceof Inet6Address ? Connection.IP6 : Connection.IP4;\r\n        if (StringUtils.isNullOrEmpty(userName))\r\n            userName = \"jitsi.org\";\r\n        else\r\n            userName += \"-jitsi.org\";\r\n        Origin o = sdpFactory.createOrigin(userName, 0, 0, \"IN\", addrType, localAddress.getHostAddress());\r\n        sessDescr.setOrigin(o);\r\n        Connection c = sdpFactory.createConnection(\"IN\", addrType, localAddress.getHostAddress());\r\n        sessDescr.setConnection(c);\r\n        if (mediaDescriptions != null) {\r\n            sessDescr.setMediaDescriptions(new Vector(mediaDescriptions));\r\n        }\r\n        return sessDescr;\r\n    } catch (SdpException exc) {\r\n        ProtocolProviderServiceSipImpl.throwOperationFailedException(\"An error occurred while creating session description\", OperationFailedException.INTERNAL_ERROR, exc, logger);\r\n    }\r\n    return sessDescr;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl.getLatestInviteTransaction",
	"Comment": "returns the transaction instance that contains the invite which startedthis call.",
	"Method": "Transaction getLatestInviteTransaction(){\r\n    return latestInviteTransaction;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.MUCServiceImpl.getExistingChatRooms",
	"Comment": "returns existing chat rooms for the given chatroomprovider.",
	"Method": "List<String> getExistingChatRooms(ChatRoomProviderWrapper chatRoomProvider){\r\n    if (chatRoomProvider == null)\r\n        return null;\r\n    ProtocolProviderService protocolProvider = chatRoomProvider.getProtocolProvider();\r\n    if (protocolProvider == null)\r\n        return null;\r\n    OperationSetMultiUserChat groupChatOpSet = protocolProvider.getOperationSet(OperationSetMultiUserChat.class);\r\n    if (groupChatOpSet == null)\r\n        return null;\r\n    List<String> chatRooms = null;\r\n    try {\r\n        chatRooms = groupChatOpSet.getExistingChatRooms();\r\n    } catch (OperationFailedException e) {\r\n        if (logger.isTraceEnabled())\r\n            logger.trace(\"Failed to obtain existing chat rooms for server: \" + protocolProvider.getAccountID().getService(), e);\r\n    } catch (OperationNotSupportedException e) {\r\n        if (logger.isTraceEnabled())\r\n            logger.trace(\"Failed to obtain existing chat rooms for server: \" + protocolProvider.getAccountID().getService(), e);\r\n    }\r\n    return chatRooms;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.generalconfig.Resources.getSettingsString",
	"Comment": "returns an application property string corresponding to the given key.",
	"Method": "String getSettingsString(String key){\r\n    return getResources().getSettingsString(key);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.msoutlook.DefaultMailClientMessageDialog.actionPerformed",
	"Comment": "handles the actionevent. depending on the user choice setsthe return code to the appropriate value.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    JButton button = (JButton) e.getSource();\r\n    if (!button.equals(okButton))\r\n        return;\r\n    this.returnCode = 0;\r\n    if (doNotAskAgain.isSelected()) {\r\n        this.returnCode = this.returnCode | DONT_ASK_SELECTED_MASK;\r\n    }\r\n    if (defaultMailClientCheckBox.isSelected()) {\r\n        this.returnCode = this.returnCode | DEFAULT_MAIL_CLIENT_SELECTED_MASK;\r\n    }\r\n    this.dispose();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.WhiteboardSessionJabberImpl.fireMessageEvent",
	"Comment": "delivers the specified event to all registered message listeners.",
	"Method": "void fireMessageEvent(EventObject evt){\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Dispatching a WhiteboardMessageEvent event to \" + messageListeners.size() + \" listeners. event is: \" + evt.toString());\r\n    Iterable<WhiteboardObjectListener> listeners;\r\n    synchronized (messageListeners) {\r\n        listeners = new ArrayList<WhiteboardObjectListener>(messageListeners);\r\n    }\r\n    for (WhiteboardObjectListener listener : listeners) {\r\n        if (evt instanceof WhiteboardObjectDeliveredEvent) {\r\n            listener.whiteboardObjectDelivered((WhiteboardObjectDeliveredEvent) evt);\r\n        } else if (evt instanceof WhiteboardObjectReceivedEvent) {\r\n            WhiteboardObjectJabberImpl wbObj = (WhiteboardObjectJabberImpl) ((WhiteboardObjectReceivedEvent) evt).getSourceWhiteboardObject();\r\n            listener.whiteboardObjectReceived((WhiteboardObjectReceivedEvent) evt);\r\n            whiteboardObjects.add(wbObj);\r\n        } else if (evt instanceof WhiteboardObjectDeletedEvent) {\r\n            String wbObjID = ((WhiteboardObjectDeletedEvent) evt).getId();\r\n            listener.whiteboardObjectDeleted((WhiteboardObjectDeletedEvent) evt);\r\n            int i = 0;\r\n            while (i < whiteboardObjects.size()) {\r\n                WhiteboardObjectJabberImpl wbObj = (WhiteboardObjectJabberImpl) whiteboardObjects.get(i);\r\n                if (wbObj.getID().equals(wbObjID))\r\n                    whiteboardObjects.remove(i);\r\n                else\r\n                    i++;\r\n            }\r\n        } else if (evt instanceof WhiteboardObjectModifiedEvent) {\r\n            WhiteboardObjectModifiedEvent womevt = (WhiteboardObjectModifiedEvent) evt;\r\n            WhiteboardObjectJabberImpl wbObj = (WhiteboardObjectJabberImpl) womevt.getSourceWhiteboardObject();\r\n            listener.whiteboardObjecModified(womevt);\r\n            whiteboardObjects.remove(wbObj);\r\n            whiteboardObjects.add(wbObj);\r\n        } else if (evt instanceof WhiteboardObjectDeliveryFailedEvent) {\r\n            listener.whiteboardObjectDeliveryFailed((WhiteboardObjectDeliveryFailedEvent) evt);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.SourceUIContact.getContactDetailsForOperationSet",
	"Comment": "returns a list of uicontactdetails supporting the givenoperationset class.",
	"Method": "List<UIContactDetail> getContactDetailsForOperationSet(Class<? extends OperationSet> opSetClass){\r\n    List<UIContactDetail> resultList = new LinkedList<UIContactDetail>();\r\n    Iterator<ContactDetail> details = sourceContact.getContactDetails().iterator();\r\n    PhoneNumberI18nService phoneNumberService = GuiActivator.getPhoneNumberI18nService();\r\n    boolean filterToNumbers = GuiActivator.getConfigurationService().getBoolean(FILTER_CALL_DETAILS_TO_NUMBERS_PROP, false);\r\n    while (details.hasNext()) {\r\n        ContactDetail detail = details.next();\r\n        List<Class<? extends OperationSet>> supportedOperationSets = detail.getSupportedOperationSets();\r\n        if ((supportedOperationSets != null) && supportedOperationSets.contains(opSetClass)) {\r\n            if (filterToNumbers && opSetClass.equals(OperationSetBasicTelephony.class) && !phoneNumberService.isPhoneNumber(detail.getDetail())) {\r\n                continue;\r\n            }\r\n            resultList.add(new SourceContactDetail(detail, getInternationalizedLabel(detail.getCategory()), getInternationalizedLabels(detail.getSubCategories().iterator()), opSetClass, sourceContact));\r\n        }\r\n    }\r\n    return resultList;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler.getVisualComponents",
	"Comment": "gets the visual components in which videos from the remote peerare currently being rendered.",
	"Method": "List<Component> getVisualComponents(){\r\n    MediaStream videoStream = getStream(MediaType.VIDEO);\r\n    List<Component> visualComponents;\r\n    if (videoStream == null)\r\n        visualComponents = Collections.emptyList();\r\n    else {\r\n        visualComponents = ((VideoMediaStream) videoStream).getVisualComponents();\r\n    }\r\n    return visualComponents;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.security.MessageDigestAlgorithm.calculateResponse",
	"Comment": "calculates an http authentication response in accordance with rfc2617.",
	"Method": "String calculateResponse(String algorithm,String username_value,String realm_value,String passwd,String nonce_value,String nc_value,String cnonce_value,String method,String digest_uri_value,String entity_body,String qop_value){\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"trying to authenticate using : \" + algorithm + \", \" + username_value + \", \" + realm_value + \", \" + (passwd != null && passwd.trim().length() > 0) + \", \" + nonce_value + \", \" + nc_value + \", \" + cnonce_value + \", \" + method + \", \" + digest_uri_value + \", \" + entity_body + \", \" + qop_value);\r\n    if (username_value == null || realm_value == null || passwd == null || method == null || digest_uri_value == null || nonce_value == null)\r\n        throw new NullPointerException(\"Null parameter to MessageDigestAlgorithm.calculateResponse()\");\r\n    String A1 = null;\r\n    if (algorithm == null || algorithm.trim().length() == 0 || algorithm.trim().equalsIgnoreCase(\"MD5\")) {\r\n        A1 = username_value + \":\" + realm_value + \":\" + passwd;\r\n    } else {\r\n        if (cnonce_value == null || cnonce_value.length() == 0)\r\n            throw new NullPointerException(\"cnonce_value may not be absent for MD5-Sess algorithm.\");\r\n        A1 = H(username_value + \":\" + realm_value + \":\" + passwd) + \":\" + nonce_value + \":\" + cnonce_value;\r\n    }\r\n    String A2 = null;\r\n    if (qop_value == null || qop_value.trim().length() == 0 || qop_value.trim().equalsIgnoreCase(\"auth\")) {\r\n        A2 = method + \":\" + digest_uri_value;\r\n    } else {\r\n        if (entity_body == null)\r\n            entity_body = \"\";\r\n        A2 = method + \":\" + digest_uri_value + \":\" + H(entity_body);\r\n    }\r\n    String request_digest = null;\r\n    if (cnonce_value != null && qop_value != null && nc_value != null && (qop_value.equalsIgnoreCase(\"auth\") || qop_value.equalsIgnoreCase(\"auth-int\"))) {\r\n        request_digest = KD(H(A1), nonce_value + \":\" + nc_value + \":\" + cnonce_value + \":\" + qop_value + \":\" + H(A2));\r\n    } else {\r\n        request_digest = KD(H(A1), nonce_value + \":\" + H(A2));\r\n    }\r\n    return request_digest;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageHistoryActivator.getConfigurationService",
	"Comment": "returns the configurationservice obtained from the bundlecontext.",
	"Method": "ConfigurationService getConfigurationService(){\r\n    if (configService == null) {\r\n        configService = ServiceUtils.getService(bundleContext, ConfigurationService.class);\r\n    }\r\n    return configService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.history.HistoryReaderImpl.findFirstRecordsAfter",
	"Comment": "returns the supplied number of recent messages after the given date",
	"Method": "QueryResultSet<HistoryRecord> findFirstRecordsAfter(Date date,int count){\r\n    TreeSet<HistoryRecord> result = new TreeSet<HistoryRecord>(new HistoryRecordComparator());\r\n    Vector<String> filelist = filterFilesByDate(this.historyImpl.getFileList(), date, null);\r\n    int leftCount = count;\r\n    int currentFile = 0;\r\n    SimpleDateFormat sdf = new SimpleDateFormat(DATE_FORMAT);\r\n    while (leftCount > 0 && currentFile < filelist.size()) {\r\n        Document doc = this.historyImpl.getDocumentForFile(filelist.get(currentFile));\r\n        if (doc == null) {\r\n            currentFile++;\r\n            continue;\r\n        }\r\n        NodeList nodes = doc.getElementsByTagName(\"record\");\r\n        Node node;\r\n        for (int i = 0; i < nodes.getLength() && leftCount > 0; i++) {\r\n            node = nodes.item(i);\r\n            NodeList propertyNodes = node.getChildNodes();\r\n            Date timestamp;\r\n            String ts = node.getAttributes().getNamedItem(\"timestamp\").getNodeValue();\r\n            try {\r\n                timestamp = sdf.parse(ts);\r\n            } catch (ParseException e) {\r\n                timestamp = new Date(Long.parseLong(ts));\r\n            }\r\n            if (!isInPeriod(timestamp, date, null))\r\n                continue;\r\n            ArrayList<String> nameVals = new ArrayList<String>();\r\n            boolean isRecordOK = true;\r\n            int len = propertyNodes.getLength();\r\n            for (int j = 0; j < len; j++) {\r\n                Node propertyNode = propertyNodes.item(j);\r\n                if (propertyNode.getNodeType() == Node.ELEMENT_NODE) {\r\n                    Node nodeValue = propertyNode.getFirstChild();\r\n                    if (nodeValue != null) {\r\n                        nameVals.add(propertyNode.getNodeName());\r\n                        nameVals.add(nodeValue.getNodeValue());\r\n                    } else\r\n                        isRecordOK = false;\r\n                }\r\n            }\r\n            if (!isRecordOK)\r\n                continue;\r\n            String[] propertyNames = new String[nameVals.size() / 2];\r\n            String[] propertyValues = new String[propertyNames.length];\r\n            for (int j = 0; j < propertyNames.length; j++) {\r\n                propertyNames[j] = nameVals.get(j * 2);\r\n                propertyValues[j] = nameVals.get(j * 2 + 1);\r\n            }\r\n            HistoryRecord record = new HistoryRecord(propertyNames, propertyValues, timestamp);\r\n            result.add(record);\r\n            leftCount--;\r\n        }\r\n        currentFile++;\r\n    }\r\n    return new OrderedQueryResultSet<HistoryRecord>(result);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.MUCServiceImpl.acceptInvitation",
	"Comment": "called to accept an incoming invitation. adds the invitation chat roomto the list of chat rooms and joins it.",
	"Method": "void acceptInvitation(ChatRoomInvitation invitation){\r\n    ChatRoom chatRoom = invitation.getTargetChatRoom();\r\n    byte[] password = invitation.getChatRoomPassword();\r\n    String nickName = ConfigurationUtils.getChatRoomProperty(chatRoom.getParentProvider(), chatRoom.getIdentifier(), \"userNickName\");\r\n    if (nickName == null) {\r\n        String[] joinOptions = ChatRoomJoinOptionsDialog.getJoinOptions(true, chatRoom.getParentProvider(), chatRoom.getIdentifier(), MUCActivator.getGlobalDisplayDetailsService().getDisplayName(chatRoom.getParentProvider()));\r\n        nickName = joinOptions[0];\r\n    }\r\n    joinChatRoom(chatRoom, nickName, password);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.MessageDeliveredEvent.getCorrectedMessageUID",
	"Comment": "returns the id of the message being corrected, or null if this was anew message and not a message correction.",
	"Method": "String getCorrectedMessageUID(){\r\n    return correctedMessageUID;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.AdHocChatRoomIcqImpl.updateMemberList",
	"Comment": "updates the member list, if the given boolean is true given members willbe added, if it is false the given members will be removed.",
	"Method": "void updateMemberList(Set<ChatRoomUser> chatRoomUserSet,boolean removeMember){\r\n    Iterator<ChatRoomUser> it = chatRoomUserSet.iterator();\r\n    while (it.hasNext()) {\r\n        ChatRoomUser user = it.next();\r\n        String uid = user.getScreenname().getFormatted();\r\n        if (!removeMember && !participants.containsKey(uid) && !uid.equals(provider.getAccountID().getUserID())) {\r\n            OperationSetPersistentPresenceIcqImpl presenceOpSet = (OperationSetPersistentPresenceIcqImpl) getParentProvider().getOperationSet(OperationSetPersistentPresence.class);\r\n            Contact participant = presenceOpSet.getServerStoredContactList().findContactByScreenName(uid);\r\n            participants.put(uid, participant);\r\n            fireParticipantPresenceEvent(participant, AdHocChatRoomParticipantPresenceChangeEvent.CONTACT_JOINED, null);\r\n        }\r\n        if (removeMember && participants.containsKey(uid)) {\r\n            Contact participant = participants.get(uid);\r\n            participants.remove(uid);\r\n            fireParticipantPresenceEvent(participant, AdHocChatRoomParticipantPresenceChangeEvent.CONTACT_LEFT, null);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.globalproxyconfig.Resources.getApplicationString",
	"Comment": "returns an application property string corresponding to the given key.",
	"Method": "String getApplicationString(String key){\r\n    return getResources().getSettingsString(key);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.AbstractOperationSetTelephonyConferencing.basicTelephonyChanged",
	"Comment": "notifies this operationsettelephonyconferencing that itsbasictelephony property has changed its value from a specificoldvalue to a specific newvalue",
	"Method": "void basicTelephonyChanged(OperationSetBasicTelephonyT oldValue,OperationSetBasicTelephonyT newValue){\r\n    if (oldValue != null)\r\n        oldValue.removeCallListener(this);\r\n    if (newValue != null)\r\n        newValue.addCallListener(this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.CallPeerGibberishImpl.getContact",
	"Comment": "returns the contact corresponding to this peer or null if noparticular contact has been associated.",
	"Method": "Contact getContact(){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.keybindings.KeybindingSetImpl.isWritable",
	"Comment": "provides if the keybindings can be written when changed or not.",
	"Method": "boolean isWritable(){\r\n    return !this.isInvalidated && this.customFile != null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.whiteboard.WhiteboardObjectRectJabberImpl.setFill",
	"Comment": "sets the fill state of the whiteboardshaperect.true is filled, false is unfilled.",
	"Method": "void setFill(boolean fill){\r\n    this.fill = fill;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.neomedia.NeomediaActivator.getConfigurationService",
	"Comment": "returns a reference to a configurationservice implementation currentlyregistered in the bundle context or null if no such implementation wasfound.",
	"Method": "ConfigurationService getConfigurationService(){\r\n    if (configurationService == null) {\r\n        configurationService = ServiceUtils.getService(bundleContext, ConfigurationService.class);\r\n    }\r\n    return configurationService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.CandidatePacketExtension.getNetwork",
	"Comment": "returns the network index indicating the interface that the candidatebelongs to. the network id is used for diagnostic purposes only in caseswhere the calling hardware has more than one network interface card.",
	"Method": "int getNetwork(){\r\n    return super.getAttributeAsInt(NETWORK_ATTR_NAME);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.dnsconfig.ParallelDnsPanel.loadData",
	"Comment": "reads the configured properties or their defaults into the ui controls.",
	"Method": "void loadData(){\r\n    chkBackupDnsEnabled.setSelected(configService.getBoolean(PNAME_BACKUP_RESOLVER_ENABLED, PDEFAULT_BACKUP_RESOLVER_ENABLED));\r\n    txtBackupResolver.setText(configService.getString(PNAME_BACKUP_RESOLVER, DEFAULT_BACKUP_RESOLVER));\r\n    txtBackupResolverFallbackIP.setValue(configService.getString(PNAME_BACKUP_RESOLVER_FALLBACK_IP, R.getSettingsString(PNAME_BACKUP_RESOLVER_FALLBACK_IP)));\r\n    spnBackupResolverPort.setValue(configService.getInt(PNAME_BACKUP_RESOLVER_PORT, SimpleResolver.DEFAULT_PORT));\r\n    spnDnsTimeout.setValue(configService.getInt(PNAME_DNS_PATIENCE, DNS_PATIENCE));\r\n    spnDnsRedemption.setValue(configService.getInt(PNAME_DNS_REDEMPTION, DNS_REDEMPTION));\r\n    updateButtonsState();\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.launchutils.SipCommunicatorLock.startLockServer",
	"Comment": "creates and binds a socket on lockaddress and then starts alockserver instance so that we would start interacting withother instances of jitsi that are trying to start.",
	"Method": "int startLockServer(InetSocketAddress localAddress){\r\n    try {\r\n        instanceServerSocket = new ServerSocket();\r\n    } catch (IOException exc) {\r\n        logger.error(\"Couldn't create server socket\", exc);\r\n        return LOCK_ERROR;\r\n    }\r\n    try {\r\n        instanceServerSocket.bind(localAddress, 16);\r\n    } catch (IOException exc) {\r\n        logger.error(\"Couldn't create server socket\", exc);\r\n        return LOCK_ERROR;\r\n    }\r\n    LockServer lockServ = new LockServer(instanceServerSocket);\r\n    lockServ.start();\r\n    return SUCCESS;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetFileTransferIcqImpl.assertConnected",
	"Comment": "utility method throwing an exception if the stack is not properlyinitialized.",
	"Method": "void assertConnected(){\r\n    if (icqProvider == null)\r\n        throw new IllegalStateException(\"The provider must be non-null and signed on the \" + \"service before being able to send a file.\");\r\n    else if (!icqProvider.isRegistered())\r\n        throw new IllegalStateException(\"The provider must be signed on the service before \" + \"being able to send a file.\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.MainFrame.hasOperationSet",
	"Comment": "checks whether we have the operation set in already loadedprotocol providers.",
	"Method": "boolean hasOperationSet(Class<? extends OperationSet> opSet){\r\n    synchronized (this.protocolProviders) {\r\n        Iterator<ProtocolProviderService> iter = this.protocolProviders.keySet().iterator();\r\n        while (iter.hasNext()) {\r\n            ProtocolProviderService pp = iter.next();\r\n            if (pp.getOperationSet(opSet) != null) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.notificationwiring.NotificationManager.localUserPresenceChanged",
	"Comment": "implements thelocaluserchatroompresencelistener.localuserpresencechangedmethod.",
	"Method": "void localUserPresenceChanged(LocalUserChatRoomPresenceChangeEvent evt){\r\n    ChatRoom sourceChatRoom = evt.getChatRoom();\r\n    String eventType = evt.getEventType();\r\n    if (LocalUserChatRoomPresenceChangeEvent.LOCAL_USER_JOINED.equals(eventType)) {\r\n        sourceChatRoom.addMessageListener(this);\r\n    } else if (LocalUserChatRoomPresenceChangeEvent.LOCAL_USER_LEFT.equals(eventType) || LocalUserChatRoomPresenceChangeEvent.LOCAL_USER_KICKED.equals(eventType) || LocalUserChatRoomPresenceChangeEvent.LOCAL_USER_DROPPED.equals(eventType)) {\r\n        sourceChatRoom.removeMessageListener(this);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.StunServerDescriptor.isOldTurn",
	"Comment": "returns true if the turn protocol supported is not the rfc5766 ones.",
	"Method": "boolean isOldTurn(){\r\n    return isOldTurn;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.filehistory.FileHistoryServiceImpl.fileTransferRequestRejected",
	"Comment": "called when a new incomingfiletransferrequest has been rejected.",
	"Method": "void fileTransferRequestRejected(FileTransferRequestEvent event){\r\n    try {\r\n        IncomingFileTransferRequest req = event.getRequest();\r\n        History history = getHistory(null, req.getSender());\r\n        HistoryWriter historyWriter = history.getWriter();\r\n        historyWriter.updateRecord(STRUCTURE_NAMES[4], req.getID(), STRUCTURE_NAMES[3], FileRecord.REFUSED);\r\n    } catch (IOException e) {\r\n        logger.error(\"Could not add file transfer log to history\", e);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipActivator.getPacketLogging",
	"Comment": "returns a reference to the packetloggingservice implementationcurrently registered in the bundle context or null if no suchimplementation was found.",
	"Method": "PacketLoggingService getPacketLogging(){\r\n    if (packetLoggingService == null) {\r\n        packetLoggingService = ServiceUtils.getService(bundleContext, PacketLoggingService.class);\r\n    }\r\n    return packetLoggingService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.SourceUIContact.getContactNode",
	"Comment": "returns the corresponding contactnode from the contact listcomponent.",
	"Method": "ContactNode getContactNode(){\r\n    return contactNode;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler.getNbHarvesting",
	"Comment": "returns the number of harvesting time for the harvester given inparameter.",
	"Method": "int getNbHarvesting(int getNbHarvesting,String harvesterName){\r\n    TransportManager<?> transportManager = queryTransportManager();\r\n    return (transportManager == null) ? 0 : transportManager.getNbHarvesting(harvesterName);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.TestOperationSetMultiUserChat2.testMemberBan",
	"Comment": "in testmemberban, a member joins, then he is bannedand try to join again",
	"Method": "void testMemberBan(){\r\n    try {\r\n        Thread.sleep(2000);\r\n    } catch (InterruptedException ex) {\r\n    }\r\n    String testRoomName = testRoomBaseName + roomID++;\r\n    logger.info(\"--- Start testMemberBan room:\" + testRoomName);\r\n    ChatRoom opSet1Room = opSetMUC1.createChatRoom(testRoomName, null);\r\n    opSet1Room.join();\r\n    MUCEventCollector opSet1RoomCollector = new MUCEventCollector(opSet1Room, MUCEventCollector.EVENT_PRESENCE);\r\n    ChatRoom opSet2Room = opSetMUC2.findRoom(testRoomName);\r\n    opSet2Room.join();\r\n    opSet1RoomCollector.waitForEvent(10000);\r\n    assertTrue(\"user2 not on member list after join\", nameIsOnMemberList(fixture.userID2, opSet1Room.getMembers()));\r\n    List<ChatRoomMember> members = opSet1Room.getMembers();\r\n    ChatRoomMember memberToBan = null;\r\n    for (ChatRoomMember member : members) if (member.getContactAddress().equals(fixture.userID2)) {\r\n        memberToBan = member;\r\n        break;\r\n    }\r\n    if (memberToBan == null)\r\n        throw new IllegalStateException(\"member to ban not found\");\r\n    opSet1RoomCollector = new MUCEventCollector(opSet1Room, MUCEventCollector.EVENT_ROLE);\r\n    assertTrue(\"user2 not in a room he joined \", opSet2Room.isJoined());\r\n    MUCEventCollector opSet2RoomCollector = new MUCEventCollector(opSet2Room, MUCEventCollector.EVENT_PRESENCE);\r\n    opSet1Room.banParticipant(memberToBan, \"testMemberBan\");\r\n    opSet2RoomCollector.waitForEvent(2000);\r\n    assertFalse(\"user2 still in a room after been banned\", opSet2Room.isJoined());\r\n    opSet1RoomCollector.waitForEvent(10000);\r\n    assertEquals(\"user1 didnt received an event for user2 ban\", 1, opSet1RoomCollector.collectedEvents.size());\r\n    assertFalse(\"user2 still on member list after ban\", nameIsOnMemberList(fixture.userID2, opSet1Room.getMembers()));\r\n    try {\r\n        opSet2Room.join();\r\n    } catch (Exception ex) {\r\n    }\r\n    assertFalse(\"user2 just joined a room where he is banned\", opSet2Room.isJoined());\r\n    logger.info(\"--- End testMemberBan room:\" + testRoomName);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.generalconfig.autoaway.AutoAwayWatcher.changeProtocolsToAway",
	"Comment": "change protocol to away saving status so it can be set again whenout of idle state.",
	"Method": "void changeProtocolsToAway(){\r\n    for (ProtocolProviderService protocolProvider : GeneralConfigPluginActivator.getProtocolProviders()) {\r\n        OperationSetPresence presence = protocolProvider.getOperationSet(OperationSetPresence.class);\r\n        if (presence == null)\r\n            continue;\r\n        PresenceStatus status = presence.getPresenceStatus();\r\n        if (status.getStatus() < PresenceStatus.AVAILABLE_THRESHOLD) {\r\n            continue;\r\n        }\r\n        PresenceStatus newStatus = StatusUpdateThread.findAwayStatus(presence);\r\n        try {\r\n            if (newStatus != null && !status.equals(newStatus)) {\r\n                addProviderToLastStates(protocolProvider, status);\r\n                presence.publishPresenceStatus(newStatus, newStatus.getStatusName());\r\n            }\r\n        } catch (IllegalArgumentException e) {\r\n        } catch (IllegalStateException e) {\r\n        } catch (OperationFailedException e) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetVideoBridgeImpl.inviteCalleeToCall",
	"Comment": "invites the callee represented by the specified uri to an alreadyexisting call using a video bridge provided by the parent jabber provider.the difference between this method and createconfcall is thatinvitecalleetocall allows a user to add new peers to an alreadyestablished conference.",
	"Method": "CallPeer inviteCalleeToCall(String uri,Call call){\r\n    return protocolProvider.getOperationSet(OperationSetTelephonyConferencing.class).inviteCalleeToCall(uri, call);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatConversationPanel.correctMessage",
	"Comment": "replaces the contents of the message with id of the corrected messagespecified in chatmessage, with this message.",
	"Method": "void correctMessage(ChatMessage chatMessage){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                correctMessage(chatMessage);\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    String correctedUID = chatMessage.getCorrectedMessageUID();\r\n    if (correctedUID != null && correctedUID.equals(lastMessageUID)) {\r\n        lastMessageUID = chatMessage.getMessageUID();\r\n    }\r\n    Element root = document.getDefaultRootElement();\r\n    Element correctedMsgElement = document.getElement(root, Attribute.ID, ChatHtmlUtils.MESSAGE_TEXT_ID + correctedUID);\r\n    if (correctedMsgElement == null) {\r\n        logger.warn(\"Could not find message with ID \" + correctedUID);\r\n        return;\r\n    }\r\n    String contactAddress = (String) correctedMsgElement.getAttributes().getAttribute(Attribute.NAME);\r\n    boolean isHistory = (chatMessage.getMessageType().equals(Chat.HISTORY_INCOMING_MESSAGE) || chatMessage.getMessageType().equals(Chat.HISTORY_OUTGOING_MESSAGE)) ? true : false;\r\n    String newMessage = ChatHtmlUtils.createMessageTag(chatMessage.getMessageUID(), contactAddress, formatMessageAsHTML(chatMessage.getMessage(), chatMessage.getContentType(), \"\"), ChatHtmlUtils.HTML_CONTENT_TYPE, chatMessage.getDate(), true, isHistory, isSimpleTheme);\r\n    synchronized (scrollToBottomRunnable) {\r\n        try {\r\n            document.setOuterHTML(correctedMsgElement, newMessage);\r\n            SwingUtilities.invokeLater(scrollToBottomRunnable);\r\n        } catch (BadLocationException ex) {\r\n            logger.error(\"Could not replace chat message\", ex);\r\n        } catch (IOException ex) {\r\n            logger.error(\"Could not replace chat message\", ex);\r\n        }\r\n    }\r\n    finishMessageAdd(newMessage);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatConversationPanel.correctMessage",
	"Comment": "replaces the contents of the message with id of the corrected messagespecified in chatmessage, with this message.",
	"Method": "void correctMessage(ChatMessage chatMessage){\r\n    correctMessage(chatMessage);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.MetaContactChatTransport.isContentTypeSupported",
	"Comment": "determines whether this chat transport supports the supplied content type",
	"Method": "boolean isContentTypeSupported(String contentType){\r\n    OperationSetBasicInstantMessaging imOpSet = contact.getProtocolProvider().getOperationSet(OperationSetBasicInstantMessaging.class);\r\n    if (imOpSet != null)\r\n        return imOpSet.isContentTypeSupported(contentType);\r\n    else\r\n        return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallManager.isVideoQualityPresetSupported",
	"Comment": "checks whether the callpeer supports setting videoquality presets. if quality controls is null, its not supported.",
	"Method": "boolean isVideoQualityPresetSupported(CallPeer callPeer){\r\n    ProtocolProviderService provider = callPeer.getProtocolProvider();\r\n    OperationSetVideoTelephony videoOpSet = provider.getOperationSet(OperationSetVideoTelephony.class);\r\n    if (videoOpSet == null)\r\n        return false;\r\n    return videoOpSet.getQualityControl(callPeer) != null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.MetaUIGroup.countOnlineChildContacts",
	"Comment": "returns the count of online child contacts of the underlyingmetacontactgroup.",
	"Method": "int countOnlineChildContacts(){\r\n    return metaGroup.countOnlineChildContacts();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ServerStoredContactListJabberImpl.findContactById",
	"Comment": "returns the contact with the specified id or null ifno such id was found.",
	"Method": "ContactJabberImpl findContactById(String id){\r\n    Iterator<ContactGroup> contactGroups = rootGroup.subgroups();\r\n    ContactJabberImpl result = null;\r\n    String userId = StringUtils.parseBareAddress(id);\r\n    while (contactGroups.hasNext()) {\r\n        ContactGroupJabberImpl contactGroup = (ContactGroupJabberImpl) contactGroups.next();\r\n        result = contactGroup.findContact(userId);\r\n        if (result != null)\r\n            return result;\r\n    }\r\n    ContactGroupJabberImpl volatileGroup = getNonPersistentGroup();\r\n    if (volatileGroup != null) {\r\n        result = volatileGroup.findContact(id);\r\n        if (result != null)\r\n            return result;\r\n    }\r\n    return rootGroup.findContact(userId);\r\n}"
}, {
	"Path": "io.lettuce.core.dynamic.support.GenericTypeResolver.resolveTypeArguments",
	"Comment": "resolve the type arguments of the given generic interface against the given target class which is assumed to implementthe generic interface and possibly declare concrete types for its type variables.",
	"Method": "Class<?>[] resolveTypeArguments(Class<?> clazz,Class<?> genericIfc){\r\n    ResolvableType type = ResolvableType.forClass(clazz).as(genericIfc);\r\n    if (!type.hasGenerics() || type.isEntirelyUnresolvable()) {\r\n        return null;\r\n    }\r\n    return type.resolveGenerics(Object.class);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.whiteboard.WhiteboardSessionPacketExtension.getContactAddress",
	"Comment": "returns the address of the contact associated with this packet extension",
	"Method": "String getContactAddress(){\r\n    return contactAddress;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.utils.ImageLoader.getIndexedProtocolImage",
	"Comment": "returns the given protocol image with an index allowing to distinguishdifferent accounts from the same protocol.",
	"Method": "Image getIndexedProtocolImage(Image image,ProtocolProviderService pps){\r\n    int index = GuiActivator.getUIService().getMainFrame().getProviderIndex(pps);\r\n    Image badged;\r\n    if (index > 0) {\r\n        BufferedImage buffImage = new BufferedImage(22, 16, BufferedImage.TYPE_INT_ARGB);\r\n        Graphics2D g = (Graphics2D) buffImage.getGraphics();\r\n        AntialiasingManager.activateAntialiasing(g);\r\n        g.setColor(Color.DARK_GRAY);\r\n        g.setFont(Constants.FONT.deriveFont(Font.BOLD, 9));\r\n        g.drawImage(image, 0, 0, null);\r\n        g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER));\r\n        g.drawString(Integer.toString(index + 1), 14, 8);\r\n        badged = buffImage;\r\n    } else\r\n        badged = image;\r\n    return badged;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetTelephonyConferencingJabberImpl.parseAddressString",
	"Comment": "parses a string value which represents a callee addressspecified by the user into an object which is to actually represent thecallee during the invitation to a conference call.",
	"Method": "String parseAddressString(String calleeAddressString){\r\n    return getBasicTelephony().getFullCalleeURI(calleeAddressString);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ChatContactCellRenderer.paintIcon",
	"Comment": "draw the icon at the specified location. paints this component as anicon.",
	"Method": "void paintIcon(Component c,Graphics g,int x,int y){\r\n    Graphics2D g2 = (Graphics2D) g.create();\r\n    try {\r\n        AntialiasingManager.activateAntialiasing(g2);\r\n        g2.setColor(Color.WHITE);\r\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.8f));\r\n        g2.fillRoundRect(x, y, getIconWidth() - 1, getIconHeight() - 1, 10, 10);\r\n        g2.setColor(Color.DARK_GRAY);\r\n        g2.drawRoundRect(x, y, getIconWidth() - 1, getIconHeight() - 1, 10, 10);\r\n        g2.translate(x + 5, y + 5);\r\n        super.paint(g2);\r\n        g2.translate(x, y);\r\n    } finally {\r\n        g.dispose();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomJabberImpl.removeMemberPresenceListener",
	"Comment": "removes a listener that was being notified of changes in the status ofother chat room participants such as users being kicked, banned, orgranted admin permissions.",
	"Method": "void removeMemberPresenceListener(ChatRoomMemberPresenceListener listener){\r\n    synchronized (memberListeners) {\r\n        memberListeners.remove(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.OperationSetPersistentPresenceGibberishImpl.createUnresolvedContactGroup",
	"Comment": "creates and returns a unresolved contact group from the specifiedaddress and persistentdata. the method will not tryto establish a network connection and resolve the newly createdcontactgroup against the server or the contact itself. theprotocol provider will later resolve the contact group. when this happensthe corresponding event would notify interested subscription listeners.",
	"Method": "ContactGroup createUnresolvedContactGroup(String groupUID,String persistentData,ContactGroup parentGroup){\r\n    ContactGroupGibberishImpl newGroup = new ContactGroupGibberishImpl(ContactGroupGibberishImpl.createNameFromUID(groupUID), parentProvider);\r\n    newGroup.setResolved(false);\r\n    if (parentGroup == null)\r\n        parentGroup = getServerStoredContactListRoot();\r\n    ((ContactGroupGibberishImpl) parentGroup).addSubgroup(newGroup);\r\n    this.fireServerStoredGroupEvent(newGroup, ServerStoredGroupEvent.GROUP_CREATED_EVENT);\r\n    return newGroup;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.history.HistoryWriterImpl.removeFirstRecord",
	"Comment": "finds the oldest node by timestamp in current root and deletes it.",
	"Method": "void removeFirstRecord(Node root){\r\n    SimpleDateFormat sdf = new SimpleDateFormat(DATE_FORMAT);\r\n    NodeList nodes = ((Element) root).getElementsByTagName(\"record\");\r\n    Node oldestNode = null;\r\n    Date oldestTimeStamp = null;\r\n    Node node;\r\n    for (int i = 0; i < nodes.getLength(); i++) {\r\n        node = nodes.item(i);\r\n        Date timestamp;\r\n        String ts = node.getAttributes().getNamedItem(\"timestamp\").getNodeValue();\r\n        try {\r\n            timestamp = sdf.parse(ts);\r\n        } catch (ParseException e) {\r\n            timestamp = new Date(Long.parseLong(ts));\r\n        }\r\n        if (oldestNode == null || (oldestTimeStamp.after(timestamp))) {\r\n            oldestNode = node;\r\n            oldestTimeStamp = timestamp;\r\n            continue;\r\n        }\r\n    }\r\n    if (oldestNode != null)\r\n        root.removeChild(oldestNode);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractCallPeer.addCallPeerListener",
	"Comment": "registers the listener to the list of listeners that would bereceiving callpeerevents.",
	"Method": "void addCallPeerListener(CallPeerListener listener){\r\n    if (listener == null)\r\n        return;\r\n    synchronized (callPeerListeners) {\r\n        if (!callPeerListeners.contains(listener))\r\n            callPeerListeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl.processAck",
	"Comment": "updates the session description and sends the state of the correspondingcall peer to connected.",
	"Method": "void processAck(ServerTransaction serverTransaction,Request ackRequest){\r\n    CallPeerSipImpl peer = activeCallsRepository.findCallPeer(serverTransaction.getDialog());\r\n    if (peer == null) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"didn't find an ack's call, returning\");\r\n        return;\r\n    }\r\n    peer.processAck(serverTransaction, ackRequest);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.sdp.SdpUtils.removeMediaDesc",
	"Comment": "iterates through the descs vector looking for amediadescription of the specified media type and thenremoves and return the first one it finds. returns null if thedescs vector contains no mediadescription withthe specified mediatype.",
	"Method": "MediaDescription removeMediaDesc(List<MediaDescription> descs,MediaType type){\r\n    for (Iterator<MediaDescription> i = descs.iterator(); i.hasNext(); ) {\r\n        MediaDescription mDesc = i.next();\r\n        if (getMediaType(mDesc) == type) {\r\n            i.remove();\r\n            return mDesc;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetDesktopSharingClientJabberImpl.getListenerCallPeer",
	"Comment": "returns the callpeer corresponding to the given callpeeraddress given inparameter, if this callpeer exists in the listener list.",
	"Method": "CallPeer getListenerCallPeer(String callPeerAddress){\r\n    CallPeerJabberImpl callPeer;\r\n    List<RemoteControlListener> listeners = getListeners();\r\n    for (int i = 0; i < listeners.size(); ++i) {\r\n        callPeer = (CallPeerJabberImpl) listeners.get(i).getCallPeer();\r\n        if (callPeer.getAddress().equals(callPeerAddress)) {\r\n            return callPeer;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl.getListeningPoint",
	"Comment": "returns the default listening point that we should use to contact theintended destination.",
	"Method": "ListeningPoint getListeningPoint(String transport,ListeningPoint getListeningPoint,SipURI intendedDestination){\r\n    return getListeningPoint(intendedDestination.getTransportParam());\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommFrame.setKeybindingInput",
	"Comment": "sets the input map to utilize a given category of keybindings. the frameis updated to reflect the new bindings when they change. this replacesany previous bindings that have been added.",
	"Method": "void setKeybindingInput(KeybindingSet.Category category){\r\n    if (bindings != null) {\r\n        bindings.deleteObserver(this);\r\n        resetInputMap();\r\n    }\r\n    bindings = DesktopUtilActivator.getKeybindingsService().getBindings(category);\r\n    if (bindings != null) {\r\n        for (Map.Entry<KeyStroke, String> key2action : bindings.getBindings().entrySet()) imap.put(key2action.getKey(), key2action.getValue());\r\n        bindings.addObserver(this);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.globalshortcut.GlobalShortcutActivator.stop",
	"Comment": "stops the execution of this service bundle in the specified context.",
	"Method": "void stop(BundleContext bundleContext){\r\n    globalShortcutService.stop();\r\n    GlobalShortcutActivator.bundleContext = null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.muc.MUCService.getMultiUserChatOpSet",
	"Comment": "returns the multi user chat operation set for the given protocol provider.",
	"Method": "OperationSetMultiUserChat getMultiUserChatOpSet(ProtocolProviderService protocolProvider){\r\n    OperationSet opSet = protocolProvider.getOperationSet(OperationSetMultiUserChat.class);\r\n    return (opSet instanceof OperationSetMultiUserChat) ? (OperationSetMultiUserChat) opSet : null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.callhistory.CallRecordImpl.setEndTime",
	"Comment": "set the time when the call finishesif some peer has no end time set we set it also",
	"Method": "void setEndTime(Date endTime){\r\n    this.endTime = endTime;\r\n    for (CallPeerRecord item : peerRecords) {\r\n        CallPeerRecordImpl itemImpl = (CallPeerRecordImpl) item;\r\n        if (item.getEndTime() == null)\r\n            itemImpl.setEndTime(endTime);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.securityconfig.SecurityConfigActivator.getResources",
	"Comment": "returns a reference to the resourcemanagementservice implementationcurrently registered in the bundle context or null if no suchimplementation was found.",
	"Method": "ResourceManagementService getResources(){\r\n    if (resources == null) {\r\n        resources = ResourceManagementServiceUtils.getService(bundleContext);\r\n    }\r\n    return resources;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.AccountStatusPanel.hasSelectedMenus",
	"Comment": "returns true if there are selected status selector boxes,otherwise returns false.",
	"Method": "boolean hasSelectedMenus(){\r\n    return statusComboBox.hasSelectedMenus();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.UIServiceImpl.registerExportedWindow",
	"Comment": "registers the given exportedwindow to the list of windows thatcould be accessed from other bundles.",
	"Method": "void registerExportedWindow(ExportedWindow window){\r\n    exportedWindows.put(window.getIdentifier(), window);\r\n}"
}, {
	"Path": "net.librec.math.structure.OrderedIntDoubleMapping.indexAt",
	"Comment": "return the mapping data index at the given position of indices array",
	"Method": "int indexAt(int position){\r\n    return indices[position];\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.FullUserInfoCmd.readStrings",
	"Comment": "extracts string from the given byte blockstarting from the specified position",
	"Method": "int readStrings(ByteBlock block,String[] result,int offset){\r\n    for (int i = 0; i < result.length; i++) {\r\n        final int textlen = getUShort(block, offset) - 1;\r\n        offset += 2;\r\n        if (textlen > 0) {\r\n            ByteBlock field = block.subBlock(offset, textlen);\r\n            result[i] = OscarTools.getString(field, \"US-ASCII\");\r\n            offset += textlen;\r\n        }\r\n        offset++;\r\n    }\r\n    return offset;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.osdependent.Resources.getApplicationString",
	"Comment": "returns the application property string corresponding to the given key.",
	"Method": "String getApplicationString(String key){\r\n    return getResources().getSettingsString(key);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetExtendedAuthorizationsIcqImpl.explicitAuthorize",
	"Comment": "send a positive authorization to contact thus allowing them toadd us to their contact list without needing to first request anauthorization.",
	"Method": "void explicitAuthorize(Contact contact){\r\n    assertConnected();\r\n    if (!(contact instanceof ContactIcqImpl))\r\n        throw new IllegalArgumentException(\"Argument is not an icq contact (contact=\" + contact + \")\");\r\n    icqProvider.getAimConnection().getSsiService().sendFutureBuddyAuthorization(new Screenname(contact.getAddress()), \"\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.reconnectplugin.ReconnectPluginActivator.serviceChanged",
	"Comment": "when new protocol provider is registered we add needed listeners.",
	"Method": "void serviceChanged(ServiceEvent serviceEvent){\r\n    ServiceReference serviceRef = serviceEvent.getServiceReference();\r\n    if (serviceRef.getBundle().getState() == Bundle.STOPPING) {\r\n        return;\r\n    }\r\n    Object sService = bundleContext.getService(serviceRef);\r\n    if (sService instanceof NetworkAddressManagerService) {\r\n        switch(serviceEvent.getType()) {\r\n            case ServiceEvent.REGISTERED:\r\n                if (this.networkAddressManagerService != null)\r\n                    break;\r\n                this.networkAddressManagerService = (NetworkAddressManagerService) sService;\r\n                networkAddressManagerService.addNetworkConfigurationChangeListener(this);\r\n                break;\r\n            case ServiceEvent.UNREGISTERING:\r\n                ((NetworkAddressManagerService) sService).removeNetworkConfigurationChangeListener(this);\r\n                break;\r\n        }\r\n        return;\r\n    }\r\n    if (!(sService instanceof ProtocolProviderService))\r\n        return;\r\n    switch(serviceEvent.getType()) {\r\n        case ServiceEvent.REGISTERED:\r\n            this.handleProviderAdded((ProtocolProviderService) sService);\r\n            break;\r\n        case ServiceEvent.UNREGISTERING:\r\n            this.handleProviderRemoved((ProtocolProviderService) sService);\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.TestOperationSetServerStoredInfo.setUp",
	"Comment": "get a reference to the contact and account info operation sets.",
	"Method": "void setUp(){\r\n    super.setUp();\r\n    fixture.setUp();\r\n    Map<String, OperationSet> supportedOperationSets = fixture.provider.getSupportedOperationSets();\r\n    if (supportedOperationSets == null || supportedOperationSets.size() < 1)\r\n        throw new NullPointerException(\"No OperationSet implementations are supported by \" + \"this ICQ implementation. \");\r\n    opSetServerStoredAccountInfo = (OperationSetServerStoredAccountInfo) supportedOperationSets.get(OperationSetServerStoredAccountInfo.class.getName());\r\n    opSetServerStoredContactInfo = (OperationSetServerStoredContactInfo) supportedOperationSets.get(OperationSetServerStoredContactInfo.class.getName());\r\n    if (opSetServerStoredAccountInfo == null) {\r\n        throw new NullPointerException(\"No implementation for Account Info was found\");\r\n    }\r\n    if (opSetServerStoredContactInfo == null) {\r\n        throw new NullPointerException(\"No implementation for Contact Info was found\");\r\n    }\r\n    opSetPresence = (OperationSetPresence) supportedOperationSets.get(OperationSetPresence.class.getName());\r\n    if (opSetPresence == null) {\r\n        throw new NullPointerException(\"An implementation of the ICQ service must provide an \" + \"implementation of at least one of the PresenceOperationSets\");\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetFileTransferIcqImpl.addFileTransferListener",
	"Comment": "adds the given filetransferlistener that would listen forfile transfer requests and created file transfers.",
	"Method": "void addFileTransferListener(FileTransferListener listener){\r\n    synchronized (fileTransferListeners) {\r\n        if (!fileTransferListeners.contains(listener)) {\r\n            this.fileTransferListeners.add(listener);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.ServiceObserver.start",
	"Comment": "this method must be called when osgi i s starting to initialize theobserver.",
	"Method": "void start(BundleContext ctx){\r\n    this.context = ctx;\r\n    ctx.addServiceListener(this);\r\n    Collection<ServiceReference<T>> refs = ServiceUtils.getServiceReferences(ctx, clazz);\r\n    for (ServiceReference<T> ref : refs) services.add(ctx.getService(ref));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl.setCallInfoURL",
	"Comment": "specifies a url pointing to a location with call controlinformation for this peer.",
	"Method": "void setCallInfoURL(URL callInfolURL){\r\n    this.callInfoURL = callInfolURL;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetAdHocMultiUserChatIcqImpl.rejectInvitation",
	"Comment": "informs the sender of an invitation that we decline their invitation.",
	"Method": "void rejectInvitation(AdHocChatRoomInvitation invitation,String rejectReason){\r\n    ChatInvitation inv = invitations.get(invitation.getTargetAdHocChatRoom());\r\n    if (inv != null) {\r\n        inv.reject();\r\n    }\r\n    invitations.remove(invitation.getTargetAdHocChatRoom());\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AccountManager.storeAccount",
	"Comment": "stores an account represented in the form of an accountidcreated by a specific protocolproviderfactory.",
	"Method": "void storeAccount(ProtocolProviderFactory factory,AccountID accountID){\r\n    synchronized (storedAccounts) {\r\n        if (!storedAccounts.contains(accountID))\r\n            storedAccounts.add(accountID);\r\n    }\r\n    ConfigurationService configurationService = ProtocolProviderActivator.getConfigurationService();\r\n    String factoryPackage = getFactoryImplPackageName(factory);\r\n    String accountNodeName = getAccountNodeName(factory, accountID.getAccountUniqueID());\r\n    Map<String, Object> configurationProperties = new HashMap<String, Object>();\r\n    if (accountNodeName == null) {\r\n        accountNodeName = ACCOUNT_UID_PREFIX + Long.toString(System.currentTimeMillis());\r\n        configurationProperties.put(factoryPackage + \".\" + accountNodeName, accountNodeName);\r\n        // prefix\r\n        configurationProperties.put(factoryPackage + \".\" + accountNodeName + \".\" + ProtocolProviderFactory.ACCOUNT_UID, accountID.getAccountUniqueID());\r\n    }\r\n    Map<String, String> accountProperties = accountID.getAccountProperties();\r\n    for (Map.Entry<String, String> entry : accountProperties.entrySet()) {\r\n        String property = entry.getKey();\r\n        String value = entry.getValue();\r\n        String secureStorePrefix = null;\r\n        if (property.equals(ProtocolProviderFactory.PASSWORD)) {\r\n            String accountPrefix = factoryPackage + \".\" + accountNodeName;\r\n            secureStorePrefix = accountPrefix;\r\n        } else if (property.endsWith(\".\" + ProtocolProviderFactory.PASSWORD)) {\r\n            secureStorePrefix = factoryPackage + \".\" + accountNodeName + \".\" + property.substring(0, property.lastIndexOf(\".\"));\r\n        }\r\n        if (secureStorePrefix != null) {\r\n            CredentialsStorageService credentialsStorage = ServiceUtils.getService(bundleContext, CredentialsStorageService.class);\r\n            if ((value != null) && (value.length() != 0) && !credentialsStorage.storePassword(secureStorePrefix, value)) {\r\n                throw new OperationFailedException(\"CredentialsStorageService failed to\" + \" storePassword\", OperationFailedException.GENERAL_ERROR);\r\n            }\r\n        } else {\r\n            // prefix\r\n            configurationProperties.put(factoryPackage + \".\" + accountNodeName + \".\" + property, value);\r\n        }\r\n    }\r\n    if (!accountProperties.containsKey(ProtocolProviderFactory.PASSWORD) && !configurationProperties.containsKey(factoryPackage + \".\" + accountNodeName + \".ENCRYPTED_PASSWORD\")) {\r\n        CredentialsStorageService credentialsStorage = ServiceUtils.getService(bundleContext, CredentialsStorageService.class);\r\n        credentialsStorage.removePassword(factoryPackage + \".\" + accountNodeName);\r\n    }\r\n    if (configurationProperties.size() > 0)\r\n        configurationService.setProperties(configurationProperties);\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Stored account for id \" + accountID.getAccountUniqueID() + \" for package \" + factoryPackage);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ContactGroupIcqImpl.updateGroup",
	"Comment": "sets this group and contacts corresponding to buddies in theserverbuddies list as resolved.",
	"Method": "void updateGroup(MutableGroup joustSimGroup,List<? extends Buddy> serverBuddies,List<Contact> newContacts,List<ContactIcqImpl> removedContacts){\r\n    setResolved(true);\r\n    this.joustSimSourceGroup = joustSimGroup;\r\n    for (Buddy buddy : serverBuddies) {\r\n        ContactIcqImpl contact = findContact(buddy.getScreenname().getFormatted());\r\n        if (contact == null) {\r\n            contact = new ContactIcqImpl(buddy, this.ssclCallback, true, true);\r\n            newContacts.add(contact);\r\n            addContact(contact);\r\n        } else {\r\n            contact.setJoustSimBuddy(buddy);\r\n            contact.setResolved(true);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockProvider.getProtocolDisplayName",
	"Comment": "mock implementation of the corresponding protocolproviderservice method.",
	"Method": "String getProtocolDisplayName(){\r\n    return PROTO_NAME;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetServerStoredAccountInfoIcqImpl.getSpokenLanguage",
	"Comment": "returns the locale corresponding the index coming from icq server",
	"Method": "Locale getSpokenLanguage(int code){\r\n    if (code == 0 || code == 255)\r\n        return null;\r\n    return spokenLanguages[code];\r\n}"
}, {
	"Path": "io.lettuce.core.KillArgs.skipme",
	"Comment": "by default this option is enabled, that is, the client calling the command will not get killed, however setting thisoption to no will have the effect of also killing the client calling the command.",
	"Method": "KillArgs skipme(KillArgs skipme,KillArgs skipme,boolean state){\r\n    this.skipme = state;\r\n    return this;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetGeolocationJabberImpl.publishGeolocation",
	"Comment": "broadcast our current geolocation trough this provider using a jabberpresence message.",
	"Method": "void publishGeolocation(Map<String, String> geolocation){\r\n    GeolocationPresence myGeolocPrez = new GeolocationPresence(opsetprez);\r\n    GeolocationPacketExtension geolocExt = GeolocationJabberUtils.convertMapToExtension(geolocation);\r\n    myGeolocPrez.setGeolocationExtention(geolocExt);\r\n    this.jabberProvider.getConnection().sendPacket(myGeolocPrez.getGeolocPresence());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.account.Account.getAccountStatus",
	"Comment": "returns the current presence status of the given protocol provider.",
	"Method": "String getAccountStatus(ProtocolProviderService protocolProvider){\r\n    String status;\r\n    if (protocolProvider == null)\r\n        return GuiActivator.getResources().getI18NString(\"service.gui.OFFLINE\");\r\n    OperationSetPresence presence = protocolProvider.getOperationSet(OperationSetPresence.class);\r\n    if (presence != null) {\r\n        status = presence.getPresenceStatus().getStatusName();\r\n    } else {\r\n        status = GuiActivator.getResources().getI18NString(protocolProvider.isRegistered() ? \"service.gui.ONLINE\" : \"service.gui.OFFLINE\");\r\n    }\r\n    return status;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetPresenceSipImpl.removeServerStoredContactGroup",
	"Comment": "removes the specified group from the server stored contact list.",
	"Method": "void removeServerStoredContactGroup(ContactGroup group){\r\n    if (!(group instanceof ContactGroupSipImpl)) {\r\n        String errorMessage = String.format(\"Group %1s does not seem to belong to this protocol's \" + \"contact list\", group.getGroupName());\r\n        throw new IllegalArgumentException(errorMessage);\r\n    }\r\n    ContactGroupSipImpl sipGroup = (ContactGroupSipImpl) group;\r\n    ssContactList.removeGroup(sipGroup);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.provdisc.dhcp.DHCPProvisioningDiscover.run",
	"Comment": "thread entry point. it runs discoverprovisioningurl in aseparate thread.",
	"Method": "void run(){\r\n    String url = discoverProvisioningURL();\r\n    if (url != null) {\r\n        DiscoveryEvent evt = new DiscoveryEvent(this, url);\r\n        for (DiscoveryListener listener : listeners) {\r\n            listener.notifyProvisioningURL(evt);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetTelephonyConferencingSipImpl.createOutgoingCall",
	"Comment": "creates a new outgoing call into which conference callees are tobe invited by this operationsettelephonyconferencing.",
	"Method": "CallSipImpl createOutgoingCall(){\r\n    return getBasicTelephony().createOutgoingCall();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatManager.acceptInvitation",
	"Comment": "called to accept an incoming invitation. adds the invitation chat roomto the list of chat rooms and joins it.",
	"Method": "void acceptInvitation(AdHocChatRoomInvitation invitation,OperationSetAdHocMultiUserChat multiUserChatOpSet){\r\n    AdHocChatRoom chatRoom = invitation.getTargetAdHocChatRoom();\r\n    chatRoom.join();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.colibri.ColibriBuilder.getAudioPacketDelay",
	"Comment": "returns an integer which stands for the audio packet delaythat will be set on all created audio channels or null ifthe builder should leave not include the xml attribute at all.",
	"Method": "Integer getAudioPacketDelay(){\r\n    return audioPacketDelay;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.GuiActivator.getSmiliesReplacementSource",
	"Comment": "returns the smiliesreplacementservice obtained from the bundlecontext.",
	"Method": "SmiliesReplacementService getSmiliesReplacementSource(){\r\n    if (smiliesService == null) {\r\n        smiliesService = ServiceUtils.getService(bundleContext, SmiliesReplacementService.class);\r\n    }\r\n    return smiliesService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ProtocolProviderServiceIrcImpl.getRegistrationState",
	"Comment": "returns the state of the registration of this protocol provider withthe corresponding registration service.",
	"Method": "RegistrationState getRegistrationState(){\r\n    return currentRegistrationState;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler.getVisualComponent",
	"Comment": "gets the visual component in which video from the remote peer iscurrently being rendered or null if there is currently no videostreaming from the remote peer.",
	"Method": "Component getVisualComponent(){\r\n    List<Component> visualComponents = getVisualComponents();\r\n    return visualComponents.isEmpty() ? null : visualComponents.get(0);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.notification.PopupMessageNotificationHandlerImpl.removePopupMessageListener",
	"Comment": "removes a listener previously added withaddpopupmessagelistener.",
	"Method": "void removePopupMessageListener(SystrayPopupMessageListener listener){\r\n    SystrayService systray = NotificationActivator.getSystray();\r\n    if (systray == null)\r\n        return;\r\n    systray.removePopupMessageListener(listener);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.ServerStoredGroupEvent.getSourceGroup",
	"Comment": "returns a reference to the contactgroup that this event ispertaining to.",
	"Method": "ContactGroup getSourceGroup(){\r\n    return (ContactGroup) getSource();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageHistoryServiceImpl.localUserPresenceChanged",
	"Comment": "called to notify interested parties that a change in our presence ina chat room has occured. changes may include us being kicked, join,left.",
	"Method": "void localUserPresenceChanged(LocalUserChatRoomPresenceChangeEvent evt){\r\n    if (evt.getEventType() == LocalUserChatRoomPresenceChangeEvent.LOCAL_USER_JOINED) {\r\n        if (!evt.getChatRoom().isSystem()) {\r\n            evt.getChatRoom().addMessageListener(this);\r\n            if (this.messageSourceService != null)\r\n                evt.getChatRoom().addMessageListener(messageSourceService);\r\n        }\r\n    } else {\r\n        evt.getChatRoom().removeMessageListener(this);\r\n        if (this.messageSourceService != null)\r\n            evt.getChatRoom().removeMessageListener(messageSourceService);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.WhiteboardSessionJabberImpl.equals",
	"Comment": "compares the specified object with this whiteboard and returns true if itthe specified object is an instance of a whiteboard object and if theextending telephony protocol considers the whiteboards represented byboth objects to be the same.",
	"Method": "boolean equals(Object obj){\r\n    if (obj == null || !(obj instanceof WhiteboardSession))\r\n        return false;\r\n    if (obj == this || ((WhiteboardSession) obj).getWhiteboardID().equals(getWhiteboardID()))\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockProvider.getSupportedOperationSets",
	"Comment": "returns an array containing all operation sets supported by thecurrent implementation.",
	"Method": "Map<String, OperationSet> getSupportedOperationSets(){\r\n    return this.supportedOperationSets;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.pluginmanager.ManageButtonsPanel.actionPerformed",
	"Comment": "performs corresponding operations when a button is pressed.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    JButton sourceButton = (JButton) e.getSource();\r\n    if (sourceButton.equals(newButton)) {\r\n        NewBundleDialog dialog = new NewBundleDialog();\r\n        dialog.pack();\r\n        dialog.setLocation(Toolkit.getDefaultToolkit().getScreenSize().width / 2 - dialog.getWidth() / 2, Toolkit.getDefaultToolkit().getScreenSize().height / 2 - dialog.getHeight() / 2);\r\n        dialog.setVisible(true);\r\n    } else if (sourceButton.equals(activateButton)) {\r\n        int[] selectedRows = pluginTable.getSelectedRows();\r\n        for (int i = 0; i < selectedRows.length; i++) {\r\n            try {\r\n                ((Bundle) pluginTable.getModel().getValueAt(selectedRows[i], 0)).start();\r\n            } catch (BundleException ex) {\r\n                logger.error(\"Failed to activate bundle.\", ex);\r\n                PluginManagerActivator.getUIService().getPopupDialog().showMessagePopupDialog(ex.getMessage(), \"Error\", PopupDialog.ERROR_MESSAGE);\r\n            }\r\n        }\r\n        defaultButtonState();\r\n    } else if (sourceButton.equals(deactivateButton)) {\r\n        int[] selectedRows = pluginTable.getSelectedRows();\r\n        for (int i = 0; i < selectedRows.length; i++) {\r\n            try {\r\n                ((Bundle) pluginTable.getModel().getValueAt(selectedRows[i], 0)).stop();\r\n            } catch (BundleException ex) {\r\n                logger.error(\"Failed to desactivate bundle.\", ex);\r\n                PluginManagerActivator.getUIService().getPopupDialog().showMessagePopupDialog(ex.getMessage(), \"Error\", PopupDialog.ERROR_MESSAGE);\r\n            }\r\n        }\r\n        defaultButtonState();\r\n    } else if (sourceButton.equals(uninstallButton)) {\r\n        int[] selectedRows = pluginTable.getSelectedRows();\r\n        for (int i = selectedRows.length - 1; i >= 0; i--) {\r\n            try {\r\n                ((Bundle) pluginTable.getModel().getValueAt(selectedRows[i], 0)).uninstall();\r\n            } catch (BundleException ex) {\r\n                logger.error(\"Failed to uninstall bundle.\", ex);\r\n                PluginManagerActivator.getUIService().getPopupDialog().showMessagePopupDialog(ex.getMessage(), \"Error\", PopupDialog.ERROR_MESSAGE);\r\n            }\r\n        }\r\n        defaultButtonState();\r\n    } else if (sourceButton.equals(updateButton)) {\r\n        int[] selectedRows = pluginTable.getSelectedRows();\r\n        for (int i = 0; i < selectedRows.length; i++) {\r\n            try {\r\n                ((Bundle) pluginTable.getModel().getValueAt(selectedRows[i], 0)).update();\r\n            } catch (BundleException ex) {\r\n                logger.error(\"Failed to update bundle.\", ex);\r\n                PluginManagerActivator.getUIService().getPopupDialog().showMessagePopupDialog(ex.getMessage(), \"Error\", PopupDialog.ERROR_MESSAGE);\r\n            }\r\n        }\r\n        defaultButtonState();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.call.MetaContactPhoneUtil.isVideoCallEnabled",
	"Comment": "is video called is enabled for metacontact. if any of the childcontacts has video enabled.",
	"Method": "boolean isVideoCallEnabled(DetailsResponseListener listener,boolean isVideoCallEnabled,boolean isVideoCallEnabled,Contact contact){\r\n    if (!this.metaContact.containsContact(contact))\r\n        return false;\r\n    if (!checkContactPhones(contact))\r\n        return false;\r\n    routingForVideoEnabled = ConfigurationUtils.isRouteVideoAndDesktopUsingPhoneNumberEnabled() && phones.containsKey(contact) && phones.get(contact).size() > 0 && AccountUtils.getOpSetRegisteredProviders(OperationSetVideoTelephony.class, null, null).size() > 0;\r\n    return contact.getProtocolProvider().getOperationSet(OperationSetVideoTelephony.class) != null && hasContactCapabilities(contact, OperationSetVideoTelephony.class) || routingForVideoEnabled;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.UINotificationGroup.getGroupDisplayName",
	"Comment": "returns the display name of the group, to which this notificationbelongs.",
	"Method": "String getGroupDisplayName(){\r\n    return groupDisplayName;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomJabberImpl.banParticipant",
	"Comment": "bans a user from the room. an admin or owner of the room can ban usersfrom a room.",
	"Method": "void banParticipant(ChatRoomMember chatRoomMember,String reason){\r\n    try {\r\n        multiUserChat.banUser(((ChatRoomMemberJabberImpl) chatRoomMember).getJabberID(), reason);\r\n    } catch (XMPPException e) {\r\n        logger.error(\"Failed to ban participant.\", e);\r\n        if (e.getXMPPError().getCode() == 405) {\r\n            throw new OperationFailedException(\"Kicking an admin user or a chat room owner is a forbidden \" + \"operation.\", OperationFailedException.FORBIDDEN);\r\n        } else {\r\n            throw new OperationFailedException(\"An error occured while trying to kick the participant.\", OperationFailedException.GENERAL_ERROR);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.propertieseditor.PropertiesEditorActivator.getConfigurationService",
	"Comment": "returns the configurationservice obtained from thebundlecontext.",
	"Method": "ConfigurationService getConfigurationService(){\r\n    if (configService == null) {\r\n        configService = ServiceUtils.getService(bundleContext, ConfigurationService.class);\r\n    }\r\n    return configService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.contactlist.TestMetaContactList.testContactsOrder",
	"Comment": "verifies whether contacts are properly ordered according to theircurrent status and name checks whether reordered events are issuedonce a contact inside this group changes its status or is addedremoved a contact.",
	"Method": "void testContactsOrder(){\r\n    assertContactsOrder(fixture.metaClService.getRoot());\r\n    MclEventCollector evtCollector = new MclEventCollector();\r\n    fixture.metaClService.addMetaContactListListener(evtCollector);\r\n    MclSlickFixture.mockPresOpSet.changePresenceStatusForContact(MetaContactListServiceLick.mockContactToReorder, MockStatusEnum.MOCK_STATUS_100);\r\n    fixture.metaClService.removeMetaContactListListener(evtCollector);\r\n    assertEquals(\"Number of evts dispatched after a contact changed its status\", 1, evtCollector.collectedMetaContactGroupEvents.size());\r\n    MetaContactGroupEvent evt = (MetaContactGroupEvent) evtCollector.collectedMetaContactGroupEvents.remove(0);\r\n    assertEquals(\"ID of the generated event\", MetaContactGroupEvent.CHILD_CONTACTS_REORDERED, evt.getEventID());\r\n    assertEquals(\"Source meta contact.\", fixture.metaClService.getRoot(), evt.getSourceMetaContactGroup());\r\n    assertContactsOrder(fixture.metaClService.getRoot());\r\n    MclSlickFixture.mockPresOpSet.changePresenceStatusForContact(MetaContactListServiceLick.mockContactToReorder, MockStatusEnum.MOCK_STATUS_00);\r\n    fixture.metaClService.addMetaContactListListener(evtCollector);\r\n    MetaContact theReorderedContact = fixture.metaClService.findMetaContactByContact(MetaContactListServiceLick.mockContactToReorder);\r\n    fixture.metaClService.renameMetaContact(theReorderedContact, \"zzzzzz\");\r\n    fixture.metaClService.removeMetaContactListListener(evtCollector);\r\n    assertEquals(\"Number of evts dispatched after a contact changed its \" + \"display name\", 1, evtCollector.collectedMetaContactGroupEvents.size());\r\n    evt = (MetaContactGroupEvent) evtCollector.collectedMetaContactGroupEvents.remove(0);\r\n    assertEquals(\"ID of the generated event\", MetaContactGroupEvent.CHILD_CONTACTS_REORDERED, evt.getEventID());\r\n    assertEquals(\"Source meta contact.\", fixture.metaClService.getRoot(), evt.getSourceMetaContactGroup());\r\n    assertSame(MetaContactListServiceLick.mockContactToReorder + \" was not moved to the bottom of the list after being \" + \"assigned 00 status and a heavy name.\", theReorderedContact, fixture.metaClService.getRoot().getMetaContact(fixture.metaClService.getRoot().countChildContacts() - 1));\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractOperationSetBasicInstantMessaging.fireMessageReceived",
	"Comment": "notifies all registered message listeners that a message has beenreceived.",
	"Method": "void fireMessageReceived(Message message,Contact from){\r\n    fireMessageEvent(new MessageReceivedEvent(message, from, new Date()));\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler.setLocalAudioTransmissionEnabled",
	"Comment": "specifies whether this media handler should be allowed to transmitlocal audio.",
	"Method": "void setLocalAudioTransmissionEnabled(boolean enabled){\r\n    audioDirectionUserPreference = enabled ? MediaDirection.SENDRECV : MediaDirection.RECVONLY;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.AddContactDialog.setSelectedAccount",
	"Comment": "selects the given protocol provider in the account combo box.",
	"Method": "void setSelectedAccount(ProtocolProviderService protocolProvider){\r\n    if (!initialized)\r\n        init();\r\n    accountCombo.setSelectedItem(protocolProvider);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipApplicationData.put",
	"Comment": "stores a value associated to the a key string in thesipapplicationdata.",
	"Method": "void put(String key,Object value){\r\n    this.storage_.put(key, value);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetPersistentPresenceJabberImpl.isPrivateMessagingContact",
	"Comment": "checks if the contact address is associated with private messagingcontact or not.",
	"Method": "boolean isPrivateMessagingContact(String contactAddress){\r\n    return ssContactList.isPrivateMessagingContact(contactAddress);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetPersistentPresenceJabberImpl.getSupportedStatusSet",
	"Comment": "returns the set of presencestatus objects that a user of this servicemay request the provider to enter.",
	"Method": "Iterator<PresenceStatus> getSupportedStatusSet(){\r\n    return parentProvider.getJabberStatusEnum().getSupportedStatusSet();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.galagonotification.GalagoNotificationActivator.start",
	"Comment": "starts the galagonotification bundle. registers itspopupmessagehandler implementation if it is supported by thecurrent operating system.",
	"Method": "void start(BundleContext bundleContext){\r\n    long dbusConnection = GalagoNotification.dbus_bus_get_session();\r\n    if (dbusConnection != 0) {\r\n        String[] capabilities = GalagoNotification.getCapabilities(dbusConnection);\r\n        if (capabilities != null) {\r\n            if (logger.isDebugEnabled()) {\r\n                logger.debug(\"org.freedesktop.Notifications.GetCapabilities:\");\r\n                for (String capability : capabilities) if (logger.isDebugEnabled())\r\n                    logger.debug(\"\\t\" + capability);\r\n            }\r\n            boolean bodyIsImplemented = false;\r\n            boolean iconStaticIsImplemented = false;\r\n            for (String capability : capabilities) if (\"body\".equals(capability)) {\r\n                bodyIsImplemented = true;\r\n                if (iconStaticIsImplemented)\r\n                    break;\r\n            } else if (\"icon-static\".equals(capability)) {\r\n                iconStaticIsImplemented = true;\r\n                if (bodyIsImplemented)\r\n                    break;\r\n            }\r\n            if (bodyIsImplemented) {\r\n                GalagoNotificationActivator.bundleContext = bundleContext;\r\n                GalagoNotificationActivator.dbusConnection = dbusConnection;\r\n                bundleContext.registerService(PopupMessageHandler.class.getName(), new GalagoPopupMessageHandler(iconStaticIsImplemented), null);\r\n            } else\r\n                GalagoNotification.dbus_connection_unref(dbusConnection);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.PresenceStatus.getStatus",
	"Comment": "returns an integer representing the presence status on a scale from 0 to100.",
	"Method": "int getStatus(){\r\n    return status;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ContactListTreeCellRenderer.addContact",
	"Comment": "shows the appropriate user interface that would allow the user to addthe given sourceuicontact to their contact list.",
	"Method": "void addContact(SourceUIContact contact){\r\n    SourceContact sourceContact = (SourceContact) contact.getDescriptor();\r\n    List<ContactDetail> details = sourceContact.getContactDetails(OperationSetPersistentPresence.class);\r\n    int detailsCount = details.size();\r\n    if (detailsCount > 1) {\r\n        JMenuItem addContactMenu = TreeContactList.createAddContactMenu((SourceContact) contact.getDescriptor());\r\n        JPopupMenu popupMenu = ((JMenu) addContactMenu).getPopupMenu();\r\n        JLabel infoLabel = new JLabel();\r\n        infoLabel.setText(\"<html><b>\" + GuiActivator.getResources().getI18NString(\"service.gui.ADD_CONTACT\") + \"<\/b><\/html>\");\r\n        popupMenu.insert(infoLabel, 0);\r\n        popupMenu.insert(new Separator(), 1);\r\n        popupMenu.setFocusable(true);\r\n        popupMenu.setInvoker(treeContactList);\r\n        Point location = new Point(addContactButton.getX(), addContactButton.getY() + addContactButton.getHeight());\r\n        SwingUtilities.convertPointToScreen(location, treeContactList);\r\n        location.y = location.y + treeContactList.getPathBounds(treeContactList.getSelectionPath()).y;\r\n        popupMenu.setLocation(location.x + 8, location.y - 8);\r\n        popupMenu.setVisible(true);\r\n    } else if (details.size() == 1) {\r\n        TreeContactList.showAddContactDialog(details.get(0), sourceContact.getDisplayName());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetAutoAnswerSipImpl.forwardCall",
	"Comment": "makes a check before locally creating call, should we just forward it.",
	"Method": "boolean forwardCall(Request invite,ServerTransaction serverTransaction){\r\n    if (StringUtils.isNullOrEmpty(callFwdTo))\r\n        return false;\r\n    Response response;\r\n    try {\r\n        if (logger.isTraceEnabled())\r\n            logger.trace(\"will send moved temporally response: \");\r\n        response = ((ProtocolProviderServiceSipImpl) protocolProvider).getMessageFactory().createResponse(Response.MOVED_TEMPORARILY, invite);\r\n        ContactHeader contactHeader = (ContactHeader) response.getHeader(ContactHeader.NAME);\r\n        AddressFactory addressFactory = ((ProtocolProviderServiceSipImpl) protocolProvider).getAddressFactory();\r\n        String destination = getCallForward();\r\n        if (!destination.startsWith(\"sip\"))\r\n            destination = \"sip:\" + destination;\r\n        contactHeader.setAddress(addressFactory.createAddress(addressFactory.createURI(destination)));\r\n        serverTransaction.sendResponse(response);\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"sent a moved temporally response: \" + response);\r\n    } catch (Throwable ex) {\r\n        logger.error(\"Error while trying to send a request\", ex);\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.notifsource.NotificationGroup.getDescriptor",
	"Comment": "returns the descriptor of the group. this would be the underlying objectthat should provide all other necessary information for the group.",
	"Method": "Object getDescriptor(){\r\n    return groupName;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler.initStream",
	"Comment": "creates if necessary, and configures the stream that thismediahandler is using for the mediatype matching theone of the mediadevice.",
	"Method": "MediaStream initStream(StreamConnector connector,MediaDevice device,MediaFormat format,MediaStreamTarget target,MediaDirection direction,List<RTPExtension> rtpExtensions,boolean masterStream){\r\n    MediaType mediaType = device.getMediaType();\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Initializing \" + mediaType + \" stream for \" + getPeer());\r\n    direction = direction.and(getDirectionUserPreference(mediaType));\r\n    direction = direction.and(device.getDirection());\r\n    MediaStream stream = mediaHandler.initStream(this, connector, device, format, target, direction, rtpExtensions, masterStream);\r\n    switch(mediaType) {\r\n        case AUDIO:\r\n            audioStream = (AudioMediaStream) stream;\r\n            break;\r\n        case VIDEO:\r\n            videoStream = (VideoMediaStream) stream;\r\n            break;\r\n    }\r\n    return stream;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.neomedia.NeomediaActivator.getAudioNotifierService",
	"Comment": "returns the audioservice obtained from the bundlecontext.",
	"Method": "AudioNotifierService getAudioNotifierService(){\r\n    if (audioNotifierService == null) {\r\n        audioNotifierService = ServiceUtils.getService(bundleContext, AudioNotifierService.class);\r\n    }\r\n    return audioNotifierService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.call.MetaContactPhoneUtil.isDesktopSharingEnabled",
	"Comment": "is desktop sharing enabled for metacontact. if any of the childcontacts has desktop sharing enabled.",
	"Method": "boolean isDesktopSharingEnabled(DetailsResponseListener listener,boolean isDesktopSharingEnabled,boolean isDesktopSharingEnabled,Contact contact){\r\n    if (!this.metaContact.containsContact(contact))\r\n        return false;\r\n    if (!checkContactPhones(contact))\r\n        return false;\r\n    routingForDesktopEnabled = ConfigurationUtils.isRouteVideoAndDesktopUsingPhoneNumberEnabled() && phones.containsKey(contact) && phones.get(contact).size() > 0 && AccountUtils.getOpSetRegisteredProviders(OperationSetDesktopSharingServer.class, null, null).size() > 0;\r\n    return contact.getProtocolProvider().getOperationSet(OperationSetDesktopSharingServer.class) != null && hasContactCapabilities(contact, OperationSetDesktopSharingServer.class) || routingForDesktopEnabled;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.OperationSetPersistentPresenceIrcImpl.getServerStoredContactListRoot",
	"Comment": "get group of contacts that have been discovered while using irc.",
	"Method": "ContactGroup getServerStoredContactListRoot(){\r\n    return this.rootGroup;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaAwareCallPeer.audioLevelChanged",
	"Comment": "notified by its very majesty the media service about changes in the audiolevel of the stream coming from this peer, the method generates thecorresponding events and delivers them to the listeners that haveregistered here.",
	"Method": "void audioLevelChanged(int newLevel){\r\n    int conferenceMemberCount = getConferenceMemberCount();\r\n    if ((conferenceMemberCount > 0) && (conferenceMemberCount < 3)) {\r\n        long audioRemoteSSRC = getMediaHandler().getRemoteSSRC(MediaType.AUDIO);\r\n        if (audioRemoteSSRC != CallPeerMediaHandler.SSRC_UNKNOWN) {\r\n            audioLevelsReceived(new long[] { audioRemoteSSRC, newLevel });\r\n            return;\r\n        }\r\n    }\r\n    fireStreamSoundLevelChanged(newLevel);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ServerStoredContactListIcqImpl.addContactForUpdate",
	"Comment": "when there is no alias for contact we must retreive its nickname from serverbut when the contact list is loaded the client is not yet registered toserver we wait this and then retreive the nicknames",
	"Method": "void addContactForUpdate(ContactIcqImpl c){\r\n    if (icqProvider.USING_ICQ)\r\n        nickRetriever.addContact(c);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.EventPackageNotifier.removeSubscription",
	"Comment": "removes a subscription from the list of subscriptions managed bythis instance identified by the response to our notify request.if the specified response cannot identify such asubscription, does nothing.",
	"Method": "void removeSubscription(Response response,String eventId,ClientTransaction clientTransaction){\r\n    CallIdHeader callIdHeader = (CallIdHeader) response.getHeader(CallIdHeader.NAME);\r\n    String callId = callIdHeader.getCallId();\r\n    Subscription subscription = getSubscription(callId);\r\n    if (subscription != null) {\r\n        synchronized (subscription) {\r\n            if (subscription.getDialog().equals(clientTransaction.getDialog()))\r\n                removeSubscription(callId, subscription);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.MainFrame.getAdHocMultiUserChatOpSet",
	"Comment": "returns the multi user chat operation set for the given protocol provider.",
	"Method": "OperationSetAdHocMultiUserChat getAdHocMultiUserChatOpSet(ProtocolProviderService protocolProvider){\r\n    OperationSet opSet = protocolProvider.getOperationSet(OperationSetAdHocMultiUserChat.class);\r\n    return (opSet instanceof OperationSetAdHocMultiUserChat) ? (OperationSetAdHocMultiUserChat) opSet : null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.whiteboard.gui.WhiteboardFrame.reInitMouse",
	"Comment": "set drawing variables to the current position of the cursor. height andwidth varibles are zeroed off.",
	"Method": "void reInitMouse(MouseEvent e){\r\n    int x = snapToX(e.getX());\r\n    int y = snapToY(e.getY());\r\n    mouseX = x;\r\n    mouseY = y;\r\n    previousMouseX = x;\r\n    previousMouseY = y;\r\n    originX = x;\r\n    originY = y;\r\n    drawX = x;\r\n    drawY = y;\r\n    originWidth = 0;\r\n    originHeight = 0;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockOperationSetBasicTelephony.answerCallPeer",
	"Comment": "indicates a user request to answer an incoming call from the specifiedcallpeer.",
	"Method": "void answerCallPeer(CallPeer peer){\r\n    MockCallPeer callPeer = (MockCallPeer) peer;\r\n    if (peer.getState().equals(CallPeerState.CONNECTED)) {\r\n        if (logger.isInfoEnabled())\r\n            logger.info(\"Ignoring user request to answer a CallPeer \" + \"that is already connected. CP:\" + peer);\r\n        return;\r\n    }\r\n    callPeer.setState(CallPeerState.CONNECTED, null);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.SecurityAccountRegistration.addEncryptionProtocolsToProperties",
	"Comment": "adds the ordered encryption protocol names to the property list given inparameter.",
	"Method": "void addEncryptionProtocolsToProperties(Map<String, String> properties){\r\n    for (Map.Entry<String, Integer> e : getEncryptionProtocols().entrySet()) {\r\n        properties.put(ProtocolProviderFactory.ENCRYPTION_PROTOCOL + \".\" + e.getKey(), e.getValue().toString());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ServerStoredContactListIcqImpl.createUnresolvedContact",
	"Comment": "creates a non resolved contact for the specified address and inside thespecified group. the newly created contact would be added to the localcontact list as a standard contact but when an event is received from theserver concerning this contact, then it will be reused and only itsisresolved field would be updated instead of creating the whole contactagain.",
	"Method": "ContactIcqImpl createUnresolvedContact(ContactGroupIcqImpl parentGroup,Screenname screenname){\r\n    if (logger.isTraceEnabled())\r\n        logger.trace(\"createUnresolvedContact \" + screenname);\r\n    ContactIcqImpl existingContact = findContactByScreenName(screenname.getFormatted());\r\n    if (existingContact != null) {\r\n        return existingContact;\r\n    }\r\n    Buddy volatileBuddy = new VolatileBuddy(screenname);\r\n    ContactIcqImpl newUnresolvedContact = new ContactIcqImpl(volatileBuddy, this, true, false);\r\n    parentGroup.addContact(newUnresolvedContact);\r\n    fireContactAdded(parentGroup, newUnresolvedContact);\r\n    return newUnresolvedContact;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.osdependent.jdic.StatusSelector.actionPerformed",
	"Comment": "change the status of the protocol according to the menu item selected",
	"Method": "void actionPerformed(ActionEvent evt){\r\n    Object source = evt.getSource();\r\n    String menuItemText;\r\n    if (source instanceof AbstractButton)\r\n        menuItemText = ((AbstractButton) source).getText();\r\n    else\r\n        menuItemText = ((MenuItem) source).getLabel();\r\n    changeStatus(menuItemText);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.copy",
	"Comment": "copies either the selected write area content or the selectedconversation panel content to the clipboard.",
	"Method": "void copy(){\r\n    JTextComponent textPane = this.conversationPanel.getChatTextPane();\r\n    if (textPane.getSelectedText() == null)\r\n        textPane = this.writeMessagePanel.getEditorPane();\r\n    textPane.copy();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.ContactGibberishImpl.isLocal",
	"Comment": "determines whether or not this contact represents our own identity.",
	"Method": "boolean isLocal(){\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.macosx.MacOSXAddrBookContactQuery.updated",
	"Comment": "callback method when receiving notifications for updated items.",
	"Method": "void updated(long person){\r\n    SourceContact sourceContact = findSourceContactByID(ABRecord_uniqueId(person));\r\n    if (sourceContact != null && sourceContact instanceof MacOSXAddrBookSourceContact) {\r\n        Object[] values = ABRecord_valuesForProperties(person, ABPERSON_PROPERTIES);\r\n        String displayName = getDisplayName(values);\r\n        final String id = ABRecord_uniqueId(person);\r\n        MacOSXAddrBookSourceContact editableSourceContact = (MacOSXAddrBookSourceContact) sourceContact;\r\n        editableSourceContact.setDisplayName(displayName);\r\n        editableSourceContact.setDisplayDetails(getOrganization(values));\r\n        List<ContactDetail> contactDetails = getContactDetails(values, id);\r\n        editableSourceContact.setDetails(contactDetails);\r\n        fireContactChanged(sourceContact);\r\n    }\r\n}"
}, {
	"Path": "net.librec.util.URLReader.read",
	"Comment": "read from the given url, with specified proxyhost and proxyport",
	"Method": "String read(String url,String read,String url,String proxyHost,int proxyPort,String read,String url,Proxy proxy){\r\n    URL link = new URL(url);\r\n    URLConnection conn = link.openConnection(proxy);\r\n    conn.setConnectTimeout(10 * 1000);\r\n    StringBuilder sb = new StringBuilder();\r\n    BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream()));\r\n    String line = null;\r\n    while ((line = br.readLine()) != null) {\r\n        sb.append(line);\r\n        sb.append(\"\\r\\n\");\r\n    }\r\n    br.close();\r\n    return sb.toString();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.aimaccregwizz.AimAccountRegistrationWizard.getLastPageIdentifier",
	"Comment": "returns the identifier of the page to show last in the wizard.",
	"Method": "Object getLastPageIdentifier(){\r\n    return firstWizardPage.getIdentifier();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.utils.ImageLoader.getIndexedProtocolIcon",
	"Comment": "returns an icon for the given protocol image with an index allowing todistinguish different accounts from the same protocol.",
	"Method": "ImageIcon getIndexedProtocolIcon(Image image,ProtocolProviderService pps){\r\n    return new ImageIcon(getIndexedProtocolImage(image, pps));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.OneToOneCallPeerPanel.printDTMFTone",
	"Comment": "prints the given dtmg character through this callpeerrenderer.",
	"Method": "void printDTMFTone(char dtmfChar){\r\n    dtmfLabel.setText(dtmfLabel.getText() + dtmfChar);\r\n    if (dtmfLabel.getBorder() == null)\r\n        dtmfLabel.setBorder(BorderFactory.createEmptyBorder(2, 1, 2, 5));\r\n}"
}, {
	"Path": "com.keybox.manage.control.SecureShellKtrl.createTerms",
	"Comment": "creates composite terminals if there are errors or authentication issues.",
	"Method": "String createTerms(){\r\n    Long userId = AuthUtil.getUserId(getRequest().getSession());\r\n    Long sessionId = AuthUtil.getSessionId(getRequest().getSession());\r\n    if (pendingSystemStatus != null && pendingSystemStatus.getId() != null) {\r\n        currentSystemStatus = SystemStatusDB.getSystemStatus(pendingSystemStatus.getId(), userId);\r\n        if (currentSystemStatus != null && (HostSystem.INITIAL_STATUS.equals(currentSystemStatus.getStatusCd()) || HostSystem.AUTH_FAIL_STATUS.equals(currentSystemStatus.getStatusCd()) || HostSystem.PUBLIC_KEY_FAIL_STATUS.equals(currentSystemStatus.getStatusCd()))) {\r\n            currentSystemStatus = SSHUtil.openSSHTermOnSystem(passphrase, password, userId, sessionId, currentSystemStatus, userSchSessionMap);\r\n        }\r\n        if (currentSystemStatus != null && (HostSystem.AUTH_FAIL_STATUS.equals(currentSystemStatus.getStatusCd()) || HostSystem.PUBLIC_KEY_FAIL_STATUS.equals(currentSystemStatus.getStatusCd()))) {\r\n            pendingSystemStatus = currentSystemStatus;\r\n        } else {\r\n            pendingSystemStatus = SystemStatusDB.getNextPendingSystem(userId);\r\n            while (pendingSystemStatus != null && currentSystemStatus != null && HostSystem.SUCCESS_STATUS.equals(currentSystemStatus.getStatusCd())) {\r\n                currentSystemStatus = SSHUtil.openSSHTermOnSystem(passphrase, password, userId, sessionId, pendingSystemStatus, userSchSessionMap);\r\n                pendingSystemStatus = SystemStatusDB.getNextPendingSystem(userId);\r\n            }\r\n        }\r\n    }\r\n    if (SystemStatusDB.getNextPendingSystem(userId) == null) {\r\n        setSystemList(userId, sessionId);\r\n        SortedSet sortedSet = new SortedSet();\r\n        sortedSet.setOrderByField(SystemDB.SORT_BY_NAME);\r\n        if (Auth.MANAGER.equals(AuthUtil.getUserType(getRequest().getSession()))) {\r\n            sortedSet = SystemDB.getSystemSet(sortedSet);\r\n        } else {\r\n            sortedSet = SystemDB.getUserSystemSet(sortedSet, userId);\r\n        }\r\n        if (sortedSet != null && sortedSet.getItemList() != null) {\r\n            allocatedSystemList = (List<HostSystem>) sortedSet.getItemList();\r\n        }\r\n        this.userSettings = UserThemeDB.getTheme(userId);\r\n    }\r\n    return \"/admin/secure_shell.html\";\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ChatRoomSubjectPanel.updateConfigButtons",
	"Comment": "updates the config button state add or remove depending on theuser role.",
	"Method": "void updateConfigButtons(){\r\n    ChatRoom room = ((ChatRoomWrapper) chatSession.getDescriptor()).getChatRoom();\r\n    ChatRoomMemberRole role = room.getUserRole();\r\n    if (!ConfigurationUtils.isChatRoomConfigDisabled() && (role.equals(ChatRoomMemberRole.ADMINISTRATOR) || role.equals(ChatRoomMemberRole.OWNER))) {\r\n        if (membersListButton == null) {\r\n            membersListButton = new JButton(new ImageIcon(ImageLoader.getImage(ImageLoader.CHAT_ROOM_MEMBERS_LIST_CONFIG)));\r\n            membersListButton.setToolTipText(GuiActivator.getResources().getI18NString(\"service.gui.CHAT_ROOM_CONFIGURATION_MEMBERS_EDIT_TITLE\"));\r\n            membersListButton.setPreferredSize(new Dimension(26, 26));\r\n            membersListButton.addActionListener(new MembersListButtonActionListener());\r\n            configButtonsPanel.add(membersListButton);\r\n            revalidate();\r\n            repaint();\r\n        }\r\n    } else if (membersListButton != null) {\r\n        remove(membersListButton);\r\n        membersListButton = null;\r\n        revalidate();\r\n        repaint();\r\n    }\r\n    if (!ConfigurationUtils.isChatRoomConfigDisabled() && role.equals(ChatRoomMemberRole.OWNER)) {\r\n        if (configButton == null) {\r\n            configButton = new JButton(new ImageIcon(ImageLoader.getImage(ImageLoader.CHAT_ROOM_CONFIG)));\r\n            configButton.setToolTipText(GuiActivator.getResources().getI18NString(\"service.gui.CHAT_ROOM_OPTIONS\"));\r\n            configButton.setPreferredSize(new Dimension(26, 26));\r\n            configButton.addActionListener(new ConfigButtonActionListener());\r\n            configButtonsPanel.add(configButton);\r\n            revalidate();\r\n            repaint();\r\n        }\r\n    } else if (configButton != null) {\r\n        remove(configButton);\r\n        configButton = null;\r\n        revalidate();\r\n        repaint();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.notifsource.NotificationContact.getStatusIcon",
	"Comment": "returns the status icon of this contact or null if no status isavailable.",
	"Method": "ImageIcon getStatusIcon(){\r\n    OperationSetPresence presence = protocolProvider.getOperationSet(OperationSetPresence.class);\r\n    if (presence != null) {\r\n        return new ImageIcon(Constants.getStatusIcon(presence.getPresenceStatus()));\r\n    } else if (protocolProvider.isRegistered()) {\r\n        return new ImageIcon(GlobalStatusEnum.ONLINE.getStatusIcon());\r\n    }\r\n    return new ImageIcon(GlobalStatusEnum.OFFLINE.getStatusIcon());\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.WhiteboardParticipantChangeEvent.getSourceWhiteboardParticipant",
	"Comment": "returns the whiteboardparticipant that this event is about.",
	"Method": "WhiteboardParticipant getSourceWhiteboardParticipant(){\r\n    return (WhiteboardParticipant) getSource();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.customcontrols.SIPCommToolBar.addSeparator",
	"Comment": "adds a separator to this toolbar. the separator is added afterthe last component in the toolbar.",
	"Method": "void addSeparator(){\r\n    JToolBar.Separator s = new JToolBar.Separator(new Dimension(8, 22));\r\n    if (getOrientation() == VERTICAL) {\r\n        s.setOrientation(JSeparator.HORIZONTAL);\r\n    } else {\r\n        s.setOrientation(JSeparator.VERTICAL);\r\n    }\r\n    add(s);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ChatRoomConferenceCallsListPanel.addConference",
	"Comment": "adds a conferencedescription to the list of conferences contained in the chat.",
	"Method": "void addConference(ConferenceDescription chatConference){\r\n    conferenceCallsListModel.addElement(chatConference);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.ChatRoomListImpl.addChatProvider",
	"Comment": "adds a listener to wait for provider to be registered or unregistered.",
	"Method": "void addChatProvider(ProtocolProviderService pps){\r\n    if (pps.isRegistered())\r\n        addRegisteredChatProvider(pps);\r\n    else\r\n        pps.addRegistrationStateChangeListener(this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomJabberImpl.addPropertyChangeListener",
	"Comment": "adds listener to the list of listeners registered to receiveevents upon modification of chat room properties such as its subjectfor example.",
	"Method": "void addPropertyChangeListener(ChatRoomPropertyChangeListener listener){\r\n    synchronized (propertyChangeListeners) {\r\n        if (!propertyChangeListeners.contains(listener))\r\n            propertyChangeListeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.DynamicRTPExtensionsRegistry.addMapping",
	"Comment": "adds the specified extension to extid mapping tothe list of mappings known to this registry. the method is meant foruse primarily when handling incoming media descriptions, methodsgenerating local sdp should use the obtainextensionmappinginstead.",
	"Method": "void addMapping(RTPExtension extension,byte extID){\r\n    RTPExtension alreadyMappedExt = findExtension(extID);\r\n    if (alreadyMappedExt != null) {\r\n        throw new IllegalArgumentException(extID + \" has already been allocated to \" + alreadyMappedExt);\r\n    }\r\n    if (extID < MIN_HEADER_ID) {\r\n        throw new IllegalArgumentException(extID + \" is not a valid RTP extensino header ID.\" + \" (must be between \" + MIN_HEADER_ID + \" and \" + MAX_TWO_BYTE_HEADER_ID);\r\n    }\r\n    extMap.put(extension, Byte.valueOf(extID));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.neomedia.codec.video.h264.OpenH264Retriever.checkForUpdateAndDownload",
	"Comment": "checks whether current version matches the one that is already installed,and shows a dialog to inform user to download the new version.",
	"Method": "void checkForUpdateAndDownload(){\r\n    ConfigurationService cfg = NeomediaActivator.getConfigurationService();\r\n    String installedVersion = cfg.getString(OPENH264_INSTALLED_VERSION_PROP);\r\n    if (installedVersion == null || installedVersion.equals(OPENH264_CURRENT_VERSION)) {\r\n        return;\r\n    }\r\n    final JDialog dialog = new SIPCommDialog();\r\n    ResourceManagementService r = NeomediaActivator.getResources();\r\n    dialog.setTitle(r.getI18NString(\"impl.neomedia.configform.video.OPENH264_DIALOG_TITLE\"));\r\n    JEditorPane contentMessage = new JEditorPane();\r\n    contentMessage.setContentType(\"text/html\");\r\n    contentMessage.setOpaque(false);\r\n    contentMessage.setEditable(false);\r\n    contentMessage.putClientProperty(JEditorPane.HONOR_DISPLAY_PROPERTIES, Boolean.TRUE);\r\n    String dialogMsg = r.getI18NString(installedVersion != null ? \"impl.neomedia.configform.video.OPENH264_UPDATE_AVAILABLE\" : \"impl.neomedia.configform.video.OPENH264_WILL_BE_DOWNLOADED\");\r\n    contentMessage.setText(dialogMsg);\r\n    JPanel contentPane = new SIPCommFrame.MainContentPane();\r\n    contentMessage.setBorder(BorderFactory.createEmptyBorder(10, 10, 0, 10));\r\n    contentPane.add(contentMessage, BorderLayout.NORTH);\r\n    JPanel buttonPanel = new TransparentPanel(new FlowLayout(FlowLayout.CENTER, 10, 10));\r\n    final JButton closeButton = new JButton(r.getI18NString(\"plugin.updatechecker.BUTTON_CLOSE\"));\r\n    closeButton.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent e) {\r\n            dialog.dispose();\r\n        }\r\n    });\r\n    JButton downloadButton = new JButton(r.getI18NString(\"plugin.updatechecker.BUTTON_DOWNLOAD\"));\r\n    downloadButton.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent e) {\r\n            try {\r\n                closeButton.doClick();\r\n            } finally {\r\n                downloadInNewThread();\r\n            }\r\n        }\r\n    });\r\n    buttonPanel.add(downloadButton);\r\n    buttonPanel.add(closeButton);\r\n    contentPane.add(buttonPanel, BorderLayout.SOUTH);\r\n    dialog.setContentPane(contentPane);\r\n    dialog.setMinimumSize(new Dimension(500, 100));\r\n    dialog.pack();\r\n    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\r\n    dialog.setLocation(screenSize.width / 2 - dialog.getWidth() / 2, screenSize.height / 2 - dialog.getHeight() / 2);\r\n    dialog.setVisible(true);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.neomedia.codec.video.h264.OpenH264Retriever.checkForUpdateAndDownload",
	"Comment": "checks whether current version matches the one that is already installed,and shows a dialog to inform user to download the new version.",
	"Method": "void checkForUpdateAndDownload(){\r\n    dialog.dispose();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.neomedia.codec.video.h264.OpenH264Retriever.checkForUpdateAndDownload",
	"Comment": "checks whether current version matches the one that is already installed,and shows a dialog to inform user to download the new version.",
	"Method": "void checkForUpdateAndDownload(){\r\n    try {\r\n        closeButton.doClick();\r\n    } finally {\r\n        downloadInNewThread();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatTransportSelectorBox.createTransportStatusImage",
	"Comment": "obtains the status icon for the given chat transport andadds to it the account index information.",
	"Method": "Image createTransportStatusImage(ChatTransport chatTransport){\r\n    return ImageLoader.getIndexedProtocolImage(ImageUtils.getBytesInImage(chatTransport.getStatus().getStatusIcon()), chatTransport.getProtocolProvider());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetTypingNotificationsIcqImpl.sendTypingNotification",
	"Comment": "sends a notification to notifiedcontatct that we have enteredtypingstate.",
	"Method": "void sendTypingNotification(Contact notifiedContact,int typingState){\r\n    assertConnected();\r\n    if (!(notifiedContact instanceof ContactIcqImpl))\r\n        throw new IllegalArgumentException(\"The specified contact is not an ICQ contact.\" + notifiedContact);\r\n    parentProvider.getAimConnection().getIcbmService().getImConversation(new Screenname(notifiedContact.getAddress())).setTypingState(intToTypingState(typingState));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ScServiceDiscoveryManager.getCapsManager",
	"Comment": "gets the entitycapsmanager which handles the entity capabilitiesfor this scservicediscoverymanager.",
	"Method": "EntityCapsManager getCapsManager(){\r\n    return capsManager;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.generic.ImEventCollector.messageDelivered",
	"Comment": "called when the underlying implementation has received an indication thata message, sent earlier has been successfully received by thedestination.",
	"Method": "void messageDelivered(MessageDeliveredEvent evt){\r\n    logger.debug(\"Received a MessageDeliveredEvent: \" + evt);\r\n    synchronized (this) {\r\n        collectedEvents.add(evt);\r\n        notifyAll();\r\n    }\r\n}"
}, {
	"Path": "io.lettuce.core.Value.getValueOrElseThrow",
	"Comment": "return the contained value, if present, otherwise throw an exception to be created by the provided supplier.",
	"Method": "V getValueOrElseThrow(Supplier<? extends X> exceptionSupplier){\r\n    LettuceAssert.notNull(exceptionSupplier, \"Supplier function must not be null\");\r\n    if (hasValue()) {\r\n        return value;\r\n    }\r\n    throw exceptionSupplier.get();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.WhiteboardSessionJabberImpl.setWhiteboardSessionState",
	"Comment": "sets the state of this whiteboard and fires a whiteboard change eventnotifying registered listeners for the change.",
	"Method": "void setWhiteboardSessionState(WhiteboardSessionState newState){\r\n    WhiteboardSessionState oldState = getWhiteboardSessionState();\r\n    if (oldState == newState)\r\n        return;\r\n    this.whiteboardState = newState;\r\n    fireWhiteboardChangeEvent(WhiteboardChangeEvent.WHITEBOARD_STATE_CHANGE, oldState, newState);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.globaldisplaydetails.GlobalDisplayDetailsImpl.serverStoredDetailsChanged",
	"Comment": "registers a serverstoreddetailschangelistener with the operation setsof the providers, if a provider change its name we use it in the ui.",
	"Method": "void serverStoredDetailsChanged(ServerStoredDetailsChangeEvent evt){\r\n    if (!StringUtils.isNullOrEmpty(provisionedDisplayName))\r\n        return;\r\n    if (evt.getNewValue() instanceof ServerStoredDetails.DisplayNameDetail && (evt.getEventID() == ServerStoredDetailsChangeEvent.DETAIL_ADDED || evt.getEventID() == ServerStoredDetailsChangeEvent.DETAIL_REPLACED)) {\r\n        ProtocolProviderService protocolProvider = evt.getProvider();\r\n        OperationSetServerStoredAccountInfo accountInfoOpSet = protocolProvider.getOperationSet(OperationSetServerStoredAccountInfo.class);\r\n        new UpdateAccountInfo(evt.getProvider(), accountInfoOpSet, true).start();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.UIServiceImpl.removeWindowListener",
	"Comment": "removes the given windowlistener from the main applicationwindow.",
	"Method": "void removeWindowListener(WindowListener l){\r\n    mainFrame.removeWindowListener(l);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.AbstractOperationSetTelephonyConferencing.getEndpointStatus",
	"Comment": "gets the endpointstatustype to use when describingcallpeer in a conference information document.",
	"Method": "String getEndpointStatus(Node endpoint,ConferenceInfoDocument.EndpointStatusType getEndpointStatus,CallPeer callPeer){\r\n    CallPeerState callPeerState = callPeer.getState();\r\n    if (CallPeerState.ALERTING_REMOTE_SIDE.equals(callPeerState))\r\n        return ConferenceInfoDocument.EndpointStatusType.alerting;\r\n    if (CallPeerState.CONNECTING.equals(callPeerState) || CallPeerState.CONNECTING_WITH_EARLY_MEDIA.equals(callPeerState))\r\n        return ConferenceInfoDocument.EndpointStatusType.pending;\r\n    if (CallPeerState.DISCONNECTED.equals(callPeerState))\r\n        return ConferenceInfoDocument.EndpointStatusType.disconnected;\r\n    if (CallPeerState.INCOMING_CALL.equals(callPeerState))\r\n        return ConferenceInfoDocument.EndpointStatusType.dialing_in;\r\n    if (CallPeerState.INITIATING_CALL.equals(callPeerState))\r\n        return ConferenceInfoDocument.EndpointStatusType.dialing_out;\r\n    if (CallPeerState.ON_HOLD_REMOTELY.equals(callPeerState))\r\n        return ConferenceInfoDocument.EndpointStatusType.on_hold;\r\n    if (CallPeerState.ON_HOLD_LOCALLY.equals(callPeerState) || CallPeerState.ON_HOLD_MUTUALLY.equals(callPeerState))\r\n        return ConferenceInfoDocument.EndpointStatusType.on_hold;\r\n    if (CallPeerState.CONNECTED.equals(callPeerState))\r\n        return ConferenceInfoDocument.EndpointStatusType.connected;\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl.setSupportQualityControls",
	"Comment": "sometimes as initing a call with custom preset can set and we forcethat quality controls is supported.",
	"Method": "void setSupportQualityControls(boolean value){\r\n    this.supportQualityControls = value;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.UIServiceImpl.addChatListener",
	"Comment": "registers a newchatlistener to be informed when newchats are created.",
	"Method": "void addChatListener(ChatListener listener){\r\n    getChatWindowManager().addChatListener(listener);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.utils.PluginContainer.initPluginComponents",
	"Comment": "adds the components of the plugincomponents registeredin the osgi bundlecontext in the associated container.",
	"Method": "void initPluginComponents(){\r\n    GuiActivator.getUIService().addPluginComponentListener(this);\r\n    ServiceReference[] serRefs = null;\r\n    try {\r\n        serRefs = GuiActivator.bundleContext.getServiceReferences(PluginComponentFactory.class.getName(), \"(\" + Container.CONTAINER_ID + \"=\" + containerId.getID() + \")\");\r\n    } catch (InvalidSyntaxException exc) {\r\n        logger.error(\"Could not obtain plugin reference.\", exc);\r\n    }\r\n    if (serRefs != null) {\r\n        for (ServiceReference serRef : serRefs) {\r\n            PluginComponentFactory factory = (PluginComponentFactory) GuiActivator.bundleContext.getService(serRef);\r\n            addPluginComponent(factory);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapActivator.getResourceService",
	"Comment": "returns a reference to a resourcemanagementservice implementationcurrently registered in the bundle context or null if no suchimplementation was found.",
	"Method": "ResourceManagementService getResourceService(){\r\n    if (resourceService == null) {\r\n        ServiceReference confReference = bundleContext.getServiceReference(ResourceManagementService.class.getName());\r\n        resourceService = (ResourceManagementService) bundleContext.getService(confReference);\r\n    }\r\n    return resourceService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.FileTransferImpl.cancel",
	"Comment": "cancels this file transfer. when this method is called transfer shouldbe interrupted.",
	"Method": "void cancel(){\r\n    fileTransfer.close();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWindowManager.fireChatCreated",
	"Comment": "notifies the chatlisteners registered with this instance thata specific chat has been created.",
	"Method": "void fireChatCreated(Chat chat){\r\n    List<ChatListener> listeners;\r\n    synchronized (chatListeners) {\r\n        listeners = new ArrayList<ChatListener>(chatListeners);\r\n    }\r\n    for (ChatListener listener : listeners) listener.chatCreated(chat);\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.Entities.entityValue",
	"Comment": "returns the value of the entity identified by the specified name.",
	"Method": "int entityValue(String name){\r\n    return map.value(name);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallManager.getPeerContact",
	"Comment": "returns the peer contact for the given alternativepeeraddress bychecking the if the callpeer exists as a detail in the givencusaxprovider.",
	"Method": "Contact getPeerContact(CallPeer callPeer,ProtocolProviderService cusaxProvider,String alternativePeerAddress){\r\n    OperationSetPresence presenceOpSet = cusaxProvider.getOperationSet(OperationSetPresence.class);\r\n    if (presenceOpSet == null)\r\n        return null;\r\n    Contact contact = presenceOpSet.findContactByID(alternativePeerAddress);\r\n    if (contact == null)\r\n        return null;\r\n    OperationSetCusaxUtils cusaxOpSet = cusaxProvider.getOperationSet(OperationSetCusaxUtils.class);\r\n    if (cusaxOpSet != null && cusaxOpSet.doesDetailBelong(contact, callPeer.getAddress()))\r\n        return contact;\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.Entities.createStringWriter",
	"Comment": "make the stringwriter 10% larger than the source string to avoid growing the writer",
	"Method": "StringWriter createStringWriter(String str){\r\n    return new StringWriter((int) (str.length() + (str.length() * 0.1)));\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractOperationSetBasicInstantMessaging.fireMessageDelivered",
	"Comment": "notifies all registered message listeners that a message has beendelivered successfully to its addressee..",
	"Method": "void fireMessageDelivered(Message message,Contact to){\r\n    fireMessageEvent(new MessageDeliveredEvent(message, to, new Date()));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.netaddr.NetworkAddressManagerServiceImpl.discoverStunServer",
	"Comment": "tries to discover a turn or a stun server for the specified domainname. the method would first try to discover a turn server and then fall back to stun only. in both cases we would only care about a udp transport.",
	"Method": "StunCandidateHarvester discoverStunServer(String domainName,byte[] userName,byte[] password){\r\n    String srvrAddress = null;\r\n    int port = 0;\r\n    try {\r\n        SRVRecord srvRecord = NetworkUtils.getSRVRecord(TURN_SRV_NAME, Transport.UDP.toString(), domainName);\r\n        if (srvRecord != null) {\r\n            srvrAddress = srvRecord.getTarget();\r\n        }\r\n        if (srvrAddress != null) {\r\n            return new TurnCandidateHarvester(new TransportAddress(srvrAddress, srvRecord.getPort(), Transport.UDP), new LongTermCredential(userName, password));\r\n        }\r\n        srvRecord = NetworkUtils.getSRVRecord(STUN_SRV_NAME, Transport.UDP.toString(), domainName);\r\n        if (srvRecord != null) {\r\n            srvrAddress = srvRecord.getTarget();\r\n            port = srvRecord.getPort();\r\n        }\r\n    } catch (ParseException e) {\r\n        logger.info(domainName + \" seems to be causing parse problems\", e);\r\n        srvrAddress = null;\r\n    } catch (DnssecException e) {\r\n        logger.warn(\"DNSSEC validation for \" + domainName + \" STUN/TURN failed.\", e);\r\n    }\r\n    if (srvrAddress != null) {\r\n        return new StunCandidateHarvester(new TransportAddress(srvrAddress, port, Transport.UDP));\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.customcontrols.SIPCommToolBar.getUIClassID",
	"Comment": "returns the name of the l&f class that renders this component.",
	"Method": "String getUIClassID(){\r\n    return uiClassID;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.provdisc.dhcp.ProvisioningDiscoveryDHCPActivator.getNetworkAddressManagerService",
	"Comment": "returns a reference to a networkaddressmanagerservice implementationcurrently registered in the bundle context or null if no suchimplementation was found.",
	"Method": "NetworkAddressManagerService getNetworkAddressManagerService(){\r\n    if (networkAddressManagerService == null) {\r\n        ServiceReference confReference = bundleContext.getServiceReference(NetworkAddressManagerService.class.getName());\r\n        networkAddressManagerService = (NetworkAddressManagerService) bundleContext.getService(confReference);\r\n    }\r\n    return networkAddressManagerService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.ProtocolMediaActivator.getNetworkAddressManagerService",
	"Comment": "returns a reference to a networkaddressmanagerservice implementationcurrently registered in the bundle context or null if no suchimplementation was found.",
	"Method": "NetworkAddressManagerService getNetworkAddressManagerService(){\r\n    if (networkAddressManagerService == null) {\r\n        networkAddressManagerService = ServiceUtils.getService(bundleContext, NetworkAddressManagerService.class);\r\n    }\r\n    return networkAddressManagerService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.TestOperationSetPresence.suite",
	"Comment": "creates a test suite containing all tests of this class followed bytest methods that we want executed in a specified order.",
	"Method": "Test suite(){\r\n    if (JabberSlickFixture.onlineTestingDisabled) {\r\n        TestSuite suite = new TestSuite();\r\n        suite.addTest(new TestOperationSetPresence(\"testSupportedStatusSetForCompleteness\"));\r\n        return suite;\r\n    }\r\n    TestSuite suite = new TestSuite();\r\n    suite.addTest(new TestOperationSetPresence(\"clearLists\"));\r\n    suite.addTest(new TestOperationSetPresence(\"postTestSubscribe\"));\r\n    suite.addTest(new TestOperationSetPresence(\"postTestUnsubscribe\"));\r\n    return suite;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.netaddr.BsdLocalhostRetriever.getLocalSocketAddress",
	"Comment": "gets the local address of a udp socket that connects to the givenaddress.",
	"Method": "InetAddress getLocalSocketAddress(InetSocketAddress dest){\r\n    sockaddr addr = sockaddr.create(dest);\r\n    int fd = LibC.INSTANCE.socket(addr.getFamily(), LibC.SOCK_DGRAM, 0);\r\n    if (fd == -1) {\r\n        throw new LibC.CException();\r\n    }\r\n    try {\r\n        int err = LibC.INSTANCE.connect(fd, addr, addr.getSize());\r\n        if (err != 0) {\r\n            throw new LibC.CException();\r\n        }\r\n        sockaddr local = addr.createEmpty();\r\n        IntByReference size = new IntByReference(local.getSize());\r\n        err = LibC.INSTANCE.getsockname(fd, local, size);\r\n        if (err != 0) {\r\n            throw new LibC.CException();\r\n        }\r\n        return local.getAddress();\r\n    } finally {\r\n        LibC.INSTANCE.close(fd);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.whiteboard.WhiteboardObjectPolygonJabberImpl.setPoints",
	"Comment": "sets the list of whiteboardpoint instances that thiswhiteboardobject is composed of.",
	"Method": "void setPoints(List<WhiteboardPoint> points){\r\n    this.listPoints = new LinkedList<WhiteboardPoint>(points);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.AdHocChatRoomMessageReceivedEvent.getSourceChatRoomParticipant",
	"Comment": "returns a reference to the contact that has send themessage whose reception this event represents.",
	"Method": "Contact getSourceChatRoomParticipant(){\r\n    return from;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.provisioning.ProvisioningServiceImpl.updateConfiguration",
	"Comment": "update configuration with properties retrieved from provisioning url.",
	"Method": "void updateConfiguration(InputStream data){\r\n    Properties fileProps = new OrderedProperties();\r\n    InputStream in = null;\r\n    try {\r\n        in = new BufferedInputStream(data);\r\n        fileProps.load(in);\r\n        Iterator<Map.Entry<Object, Object>> it = fileProps.entrySet().iterator();\r\n        while (it.hasNext()) {\r\n            Map.Entry<Object, Object> entry = it.next();\r\n            String key = (String) entry.getKey();\r\n            Object value = entry.getValue();\r\n            if (key.trim().length() == 0)\r\n                continue;\r\n            if (key.equals(PROVISIONING_ALLOW_PREFIX_PROP)) {\r\n                String[] prefixes = ((String) value).split(\"\\\\|\");\r\n                for (String s : prefixes) {\r\n                    allowedPrefixes.add(s);\r\n                }\r\n                continue;\r\n            } else if (key.equals(PROVISIONING_ENFORCE_PREFIX_PROP)) {\r\n                checkEnforcePrefix((String) value);\r\n                continue;\r\n            }\r\n            if (!isPrefixAllowed(key)) {\r\n                continue;\r\n            }\r\n            processProperty(key, value);\r\n        }\r\n        try {\r\n            ProvisioningActivator.getConfigurationService().storeConfiguration();\r\n            ProvisioningActivator.getConfigurationService().reloadConfiguration();\r\n        } catch (Exception e) {\r\n            logger.error(\"Cannot reload configuration\");\r\n        }\r\n    } catch (IOException e) {\r\n        logger.warn(\"Error during load of provisioning file\");\r\n    } finally {\r\n        try {\r\n            in.close();\r\n        } catch (IOException e) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.OperationSetPersistentPresenceGibberishImpl.publishPresenceStatus",
	"Comment": "requests the provider to enter into a status corresponding to thespecified paramters.",
	"Method": "void publishPresenceStatus(PresenceStatus status,String statusMessage){\r\n    PresenceStatus oldPresenceStatus = this.presenceStatus;\r\n    this.presenceStatus = status;\r\n    this.statusMessage = statusMessage;\r\n    this.fireProviderStatusChangeEvent(oldPresenceStatus);\r\n    changePresenceStatusForAllContacts(getServerStoredContactListRoot(), getPresenceStatus());\r\n    List<Contact> contacts = findContactsPointingToUs();\r\n    Iterator<Contact> contactsIter = contacts.iterator();\r\n    while (contactsIter.hasNext()) {\r\n        ContactGibberishImpl contact = (ContactGibberishImpl) contactsIter.next();\r\n        PresenceStatus oldStatus = contact.getPresenceStatus();\r\n        contact.setPresenceStatus(status);\r\n        contact.getParentPresenceOperationSet().fireContactPresenceStatusChangeEvent(contact, contact.getParentContactGroup(), oldStatus);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.ProtocolProviderFactory.findAccountPrefix",
	"Comment": "returns the prefix for all persistently stored properties of the accountwith the specified id.",
	"Method": "String findAccountPrefix(BundleContext bundleContext,AccountID accountID,String sourcePackageName){\r\n    ServiceReference<ConfigurationService> confReference = bundleContext.getServiceReference(ConfigurationService.class);\r\n    ConfigurationService configurationService = bundleContext.getService(confReference);\r\n    List<String> storedAccounts = configurationService.getPropertyNamesByPrefix(sourcePackageName, true);\r\n    for (String accountRootPropertyName : storedAccounts) {\r\n        String accountUID = // node id\r\n        configurationService.getString(accountRootPropertyName + \".\" + ACCOUNT_UID);\r\n        if (accountID.getAccountUniqueID().equals(accountUID)) {\r\n            return accountRootPropertyName;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.globalshortcut.GlobalShortcutActivator.start",
	"Comment": "starts the execution of this service bundle in the specified context.",
	"Method": "void start(BundleContext bundleContext){\r\n    GlobalShortcutActivator.bundleContext = bundleContext;\r\n    globalShortcutService = new GlobalShortcutServiceImpl();\r\n    globalShortcutService.start();\r\n    bundleContext.registerService(GlobalShortcutService.class, globalShortcutService, null);\r\n    globalShortcutService.reloadGlobalShortcuts();\r\n    registerListenerWithProtocolProviderService();\r\n    bundleContext.addServiceListener(new ServiceListener() {\r\n        public void serviceChanged(ServiceEvent serviceEvent) {\r\n            GlobalShortcutActivator.this.serviceChanged(serviceEvent);\r\n        }\r\n    });\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"GlobalShortcut Service ... [REGISTERED]\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.globalshortcut.GlobalShortcutActivator.start",
	"Comment": "starts the execution of this service bundle in the specified context.",
	"Method": "void start(BundleContext bundleContext){\r\n    GlobalShortcutActivator.this.serviceChanged(serviceEvent);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.accountinfo.AccountDetailsPanel.loadDetail",
	"Comment": "loads a single genericdetail obtained from theoperationsetserverstoredaccountinfo into this plugin.",
	"Method": "void loadDetail(GenericDetail detail){\r\n    if (detail.getClass().equals(AboutMeDetail.class)) {\r\n        aboutMeDetail = (AboutMeDetail) detail;\r\n        aboutMeArea.setText((String) detail.getDetailValue());\r\n        return;\r\n    }\r\n    if (detail instanceof BirthDateDetail) {\r\n        birthDateDetail = (BirthDateDetail) detail;\r\n        Calendar calendarDetail = (Calendar) birthDateDetail.getDetailValue();\r\n        birthDayCalendar.setCalendar(calendarDetail);\r\n        return;\r\n    }\r\n    JTextField field = detailToTextField.get(detail.getClass());\r\n    if (field != null) {\r\n        if (detail instanceof ImageDetail) {\r\n            localIcon.setSelected(true);\r\n            avatarDetail = (ImageDetail) detail;\r\n            byte[] avatarImage = avatarDetail.getBytes();\r\n            imageWithMenu.setImageIcon(avatarImage);\r\n        } else if (detail instanceof URLDetail) {\r\n            urlDetail = (URLDetail) detail;\r\n            urlField.setText(urlDetail.getURL().toString());\r\n        } else {\r\n            Object obj = detail.getDetailValue();\r\n            if (obj instanceof String)\r\n                field.setText((String) obj);\r\n            else if (obj != null)\r\n                field.setText(obj.toString());\r\n            if (detail.getClass().equals(DisplayNameDetail.class))\r\n                displayNameDetail = (DisplayNameDetail) detail;\r\n            else if (detail.getClass().equals(FirstNameDetail.class))\r\n                firstNameDetail = (FirstNameDetail) detail;\r\n            else if (detail.getClass().equals(MiddleNameDetail.class))\r\n                middleNameDetail = (MiddleNameDetail) detail;\r\n            else if (detail.getClass().equals(LastNameDetail.class))\r\n                lastNameDetail = (LastNameDetail) detail;\r\n            else if (detail.getClass().equals(NicknameDetail.class))\r\n                nicknameDetail = (NicknameDetail) detail;\r\n            else if (detail.getClass().equals(URLDetail.class))\r\n                urlDetail = (URLDetail) detail;\r\n            else if (detail.getClass().equals(GenderDetail.class))\r\n                genderDetail = (GenderDetail) detail;\r\n            else if (detail.getClass().equals(AddressDetail.class))\r\n                streetAddressDetail = (AddressDetail) detail;\r\n            else if (detail.getClass().equals(CityDetail.class))\r\n                cityDetail = (CityDetail) detail;\r\n            else if (detail.getClass().equals(ProvinceDetail.class))\r\n                regionDetail = (ProvinceDetail) detail;\r\n            else if (detail.getClass().equals(PostalCodeDetail.class))\r\n                postalCodeDetail = (PostalCodeDetail) detail;\r\n            else if (detail.getClass().equals(CountryDetail.class))\r\n                countryDetail = (CountryDetail) detail;\r\n            else if (detail.getClass().equals(PhoneNumberDetail.class))\r\n                phoneDetail = (PhoneNumberDetail) detail;\r\n            else if (detail.getClass().equals(WorkPhoneDetail.class))\r\n                workPhoneDetail = (WorkPhoneDetail) detail;\r\n            else if (detail.getClass().equals(MobilePhoneDetail.class))\r\n                mobilePhoneDetail = (MobilePhoneDetail) detail;\r\n            else if (detail.getClass().equals(EmailAddressDetail.class))\r\n                emailDetail = (EmailAddressDetail) detail;\r\n            else if (detail.getClass().equals(WorkEmailAddressDetail.class))\r\n                workEmailDetail = (WorkEmailAddressDetail) detail;\r\n            else if (detail.getClass().equals(WorkOrganizationNameDetail.class))\r\n                organizationDetail = (WorkOrganizationNameDetail) detail;\r\n            else if (detail.getClass().equals(JobTitleDetail.class))\r\n                jobTitleDetail = (JobTitleDetail) detail;\r\n            else if (detail.getClass().equals(AboutMeDetail.class))\r\n                aboutMeDetail = (AboutMeDetail) detail;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chatroomslist.ChatRoomTableDialog.dispose",
	"Comment": "releases the resources allocated by this instance throughout itslifetime.",
	"Method": "void dispose(){\r\n    if (chatRoomTableDialog == this)\r\n        chatRoomTableDialog = null;\r\n    GuiActivator.getMUCService().removeChatRoomProviderWrapperListener(chatRoomProviderWrapperListener);\r\n    if (serverChatRoomsChoiceDialog != null) {\r\n        serverChatRoomsChoiceDialog.dispose();\r\n        serverChatRoomsChoiceDialog = null;\r\n    }\r\n    super.dispose();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.menus.ToolsMenu.addSeparator",
	"Comment": "when a new separator is added to this container its positionwill be saved in separatorindices.",
	"Method": "void addSeparator(){\r\n    super.addSeparator();\r\n    separatorIndices.add(this.getMenuComponentCount() - 1);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.net.ProxyConnection.getOutboundProxyString",
	"Comment": "in case we are using an outbound proxy this method returnsa suitable string for use with router.the method returns null otherwise.",
	"Method": "String getOutboundProxyString(){\r\n    if (socketAddress == null)\r\n        return null;\r\n    InetAddress proxyAddress = socketAddress.getAddress();\r\n    StringBuilder proxyStringBuffer = new StringBuilder(proxyAddress.getHostAddress());\r\n    if (proxyAddress instanceof Inet6Address) {\r\n        proxyStringBuffer.insert(0, '[');\r\n        proxyStringBuffer.append(']');\r\n    }\r\n    proxyStringBuffer.append(':');\r\n    proxyStringBuffer.append(socketAddress.getPort());\r\n    proxyStringBuffer.append('/');\r\n    proxyStringBuffer.append(transport);\r\n    return proxyStringBuffer.toString();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetPresenceSipImpl.setStatusForContacts",
	"Comment": "associate the provided presence state to the contacts considering the current presence states and priorities.",
	"Method": "List<Object[]> setStatusForContacts(PresenceStatus presenceState,Iterable<Object[]> contacts,List<Object[]> curStatus){\r\n    if (presenceState == null || contacts == null || curStatus == null)\r\n        return null;\r\n    for (Object[] tab : contacts) {\r\n        Contact contact = (Contact) tab[0];\r\n        float priority = ((Float) tab[1]).floatValue();\r\n        int pos = 0;\r\n        boolean skip = false;\r\n        for (int i = 0; i < curStatus.size(); i++) {\r\n            Object[] tab2 = curStatus.get(i);\r\n            Contact curContact = (Contact) tab2[0];\r\n            float curPriority = ((Float) tab2[1]).floatValue();\r\n            if (pos == 0 && curPriority <= priority) {\r\n                pos = i;\r\n            }\r\n            if (curContact.equals(contact)) {\r\n                if (curPriority > priority) {\r\n                    skip = true;\r\n                    break;\r\n                } else if (curPriority < priority) {\r\n                    curStatus.remove(i);\r\n                } else {\r\n                    PresenceStatus curPresence = (PresenceStatus) tab2[2];\r\n                    if (curPresence.getStatus() >= presenceState.getStatus()) {\r\n                        skip = true;\r\n                        break;\r\n                    }\r\n                    curStatus.remove(i);\r\n                }\r\n                i--;\r\n            }\r\n        }\r\n        if (skip)\r\n            continue;\r\n        curStatus.add(pos, new Object[] { contact, new Float(priority), presenceState });\r\n    }\r\n    return curStatus;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler.isLocalVideoTransmissionEnabled",
	"Comment": "determines whether this media handler is currently set to transmit localvideo.",
	"Method": "boolean isLocalVideoTransmissionEnabled(){\r\n    return videoDirectionUserPreference.allowsSending();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AccountInfoUtils.getWorkAddress",
	"Comment": "returns the work address of the account, to which the givenaccountinfoopset belongs.",
	"Method": "String getWorkAddress(OperationSetServerStoredAccountInfo accountInfoOpSet){\r\n    WorkAddressDetail address = null;\r\n    Iterator<GenericDetail> addressDetails = accountInfoOpSet.getDetails(WorkAddressDetail.class);\r\n    if (addressDetails.hasNext())\r\n        address = (WorkAddressDetail) addressDetails.next();\r\n    if (address == null)\r\n        return null;\r\n    return address.getAddress();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.ReceivedCallDialog.getPeerDisplayAddress",
	"Comment": "a informative text to show for the peer. if display name andaddress are the same return null.",
	"Method": "String getPeerDisplayAddress(CallPeer peer){\r\n    String peerAddress = peer.getAddress();\r\n    if (StringUtils.isNullOrEmpty(peerAddress, true))\r\n        return null;\r\n    else {\r\n        return peerAddress.equalsIgnoreCase(peer.getDisplayName()) ? null : peerAddress;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.addErrorSendingTypingNotification",
	"Comment": "adds a typing notification message to the conversation panel,saying that typin notifications has not been delivered.",
	"Method": "void addErrorSendingTypingNotification(String typingNotification){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                addErrorSendingTypingNotification(typingNotification);\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    typingNotificationLabel.setText(typingNotification);\r\n    if (typingNotification != null && !typingNotification.equals(\" \"))\r\n        typingNotificationLabel.setIcon(typingIcon);\r\n    else\r\n        typingNotificationLabel.setIcon(null);\r\n    revalidate();\r\n    repaint();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.addErrorSendingTypingNotification",
	"Comment": "adds a typing notification message to the conversation panel,saying that typin notifications has not been delivered.",
	"Method": "void addErrorSendingTypingNotification(String typingNotification){\r\n    addErrorSendingTypingNotification(typingNotification);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.packetlogging.PacketLoggingServiceImpl.start",
	"Comment": "starting the packet logger. generating the files we can use,rotate any previous files and open the current file for writing.",
	"Method": "void start(){\r\n    saverThread.start();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler.isSecure",
	"Comment": "returns the secure state of the call. if both audio and video is secured.",
	"Method": "boolean isSecure(){\r\n    for (MediaType mediaType : MediaType.values()) {\r\n        MediaStream stream = getStream(mediaType);\r\n        if ((stream != null) && !stream.getSrtpControl().getSecureCommunicationStatus())\r\n            return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactListServiceImpl.addMetaContactListListener",
	"Comment": "adds a listener for metacontactlistchangeevents posted afterthe tree changes.",
	"Method": "void addMetaContactListListener(MetaContactListListener listener){\r\n    synchronized (metaContactListListeners) {\r\n        if (!metaContactListListeners.contains(listener))\r\n            metaContactListListeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomJabberImpl.removeConferenceCall",
	"Comment": "removes a calljabberimpl instance from the list of conferencecalls associated with the room.",
	"Method": "void removeConferenceCall(CallJabberImpl call){\r\n    if (chatRoomConferenceCalls.contains(call))\r\n        chatRoomConferenceCalls.remove(call);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.ChatRoomMessageReceivedEvent.setHistoryMessage",
	"Comment": "changes property, whether this event is for a history message.",
	"Method": "void setHistoryMessage(boolean historyMessage){\r\n    this.historyMessage = historyMessage;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chatroomslist.createforms.SelectAccountPanel.setSelectedAccount",
	"Comment": "set the selected account, which will be used in the rest of the wizard.",
	"Method": "void setSelectedAccount(){\r\n    TableModel model = accountsTable.getModel();\r\n    for (int i = 0; i < accountsTable.getRowCount(); i++) {\r\n        Object value = model.getValueAt(i, 0);\r\n        if (value instanceof JRadioButton) {\r\n            JRadioButton radioButton = (JRadioButton) value;\r\n            if (radioButton.isSelected()) {\r\n                newChatRoom.setProtocolProvider((ProtocolProviderService) model.getValueAt(i, 1));\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.ContactlistActivator.getFileAccessService",
	"Comment": "returns the fileaccessservice obtained from the bundle context.",
	"Method": "FileAccessService getFileAccessService(){\r\n    if (fileAccessService == null) {\r\n        fileAccessService = ServiceUtils.getService(bundleContext, FileAccessService.class);\r\n    }\r\n    return fileAccessService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ProtocolProviderServiceJabberImpl.isInitialized",
	"Comment": "returns true if the provider service implementation is initialized andready for use by other services, and false otherwise.",
	"Method": "boolean isInitialized(){\r\n    return isInitialized;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.UIServiceImpl.getConfigurationContainer",
	"Comment": "returns the configurationcontainer associated with thisuiservice.",
	"Method": "ConfigurationContainer getConfigurationContainer(){\r\n    if (configurationFrame == null) {\r\n        if (!SwingUtilities.isEventDispatchThread()) {\r\n            try {\r\n                SwingUtilities.invokeAndWait(new Runnable() {\r\n                    public void run() {\r\n                        getConfigurationContainer();\r\n                    }\r\n                });\r\n            } catch (Throwable e) {\r\n                logger.error(\"Error creating config frame in swing thread\");\r\n                if (configurationFrame == null)\r\n                    configurationFrame = new ConfigurationFrame(mainFrame);\r\n            }\r\n            return configurationFrame;\r\n        }\r\n        configurationFrame = new ConfigurationFrame(mainFrame);\r\n    }\r\n    return configurationFrame;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.UIServiceImpl.getConfigurationContainer",
	"Comment": "returns the configurationcontainer associated with thisuiservice.",
	"Method": "ConfigurationContainer getConfigurationContainer(){\r\n    getConfigurationContainer();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetMultiUserChatJabberImpl.updateChatRoomMembers",
	"Comment": "finds all chat room members, which name corresponds to the name of the given contact and updates their contact references.",
	"Method": "void updateChatRoomMembers(Contact contact){\r\n    Enumeration<ChatRoom> chatRooms = chatRoomCache.elements();\r\n    while (chatRooms.hasMoreElements()) {\r\n        ChatRoomJabberImpl chatRoom = (ChatRoomJabberImpl) chatRooms.nextElement();\r\n        ChatRoomMemberJabberImpl member = chatRoom.findMemberForNickName(contact.getAddress());\r\n        if (member != null) {\r\n            member.setContact(contact);\r\n            member.setAvatar(contact.getImage());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetWhiteboardingJabberImpl.fireInvitationEvent",
	"Comment": "delivers a whiteboardinvitationevent to allregistered whiteboardinvitationlisteners.",
	"Method": "void fireInvitationEvent(WhiteboardSession targetWhiteboard,WhiteboardObject whiteboardObject,String inviter,String reason,byte[] password){\r\n    WhiteboardInvitationJabberImpl invitation = new WhiteboardInvitationJabberImpl(targetWhiteboard, whiteboardObject, inviter, reason, password);\r\n    WhiteboardInvitationReceivedEvent evt = new WhiteboardInvitationReceivedEvent(this, invitation, new Date(System.currentTimeMillis()));\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Dispatching a WhiteboardInvitation event to \" + invitationListeners.size() + \" listeners. event is: \" + evt.toString());\r\n    Iterable<WhiteboardInvitationListener> listeners;\r\n    synchronized (invitationListeners) {\r\n        listeners = new ArrayList<WhiteboardInvitationListener>(invitationListeners);\r\n    }\r\n    for (WhiteboardInvitationListener listener : listeners) listener.invitationReceived(evt);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommTextField.fireTextFieldChangeListener",
	"Comment": "notifies all registered textfieldchangelisteners that a changehas occurred in the text contained in this field.",
	"Method": "void fireTextFieldChangeListener(int eventType){\r\n    for (TextFieldChangeListener l : changeListeners) switch(eventType) {\r\n        case 0:\r\n            l.textInserted();\r\n            break;\r\n        case 1:\r\n            l.textRemoved();\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.reconnectplugin.ReconnectPluginActivator.traceCurrentPPState",
	"Comment": "trace prints of current status of the lists with protocol providers,that are currently in interest of the reconnect plugin.",
	"Method": "void traceCurrentPPState(){\r\n    logger.trace(\"connectedInterfaces: \" + connectedInterfaces);\r\n    logger.trace(\"autoReconnEnabledProviders: \" + autoReconnEnabledProviders.keySet());\r\n    logger.trace(\"currentlyReconnecting: \" + currentlyReconnecting.keySet());\r\n    logger.trace(\"needsReconnection: \" + needsReconnection);\r\n    logger.trace(\"unregisteringProviders: \" + unregisteringProviders);\r\n    logger.trace(\"----\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.callhistory.CallHistoryActivator.getProtocolProviderFactories",
	"Comment": "returns all protocolproviderfactorys obtained from the bundlecontext.",
	"Method": "Map<Object, ProtocolProviderFactory> getProtocolProviderFactories(){\r\n    Collection<ServiceReference<ProtocolProviderFactory>> serRefs = ServiceUtils.getServiceReferences(bundleContext, ProtocolProviderFactory.class);\r\n    if (!serRefs.isEmpty()) {\r\n        for (ServiceReference<ProtocolProviderFactory> serRef : serRefs) {\r\n            ProtocolProviderFactory providerFactory = bundleContext.getService(serRef);\r\n            providerFactoriesMap.put(serRef.getProperty(ProtocolProviderFactory.PROTOCOL), providerFactory);\r\n        }\r\n    }\r\n    return providerFactoriesMap;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.demuxcontactsource.DemuxContactSourceServiceImpl.createDemuxContactSource",
	"Comment": "creates a demultiplexed copy of the given contactsourceservice,where each contact detail like telephone number or protocol contactaddress is represented as a single entry in the query result set.",
	"Method": "ContactSourceService createDemuxContactSource(ContactSourceService contactSourceService){\r\n    return new DemuxContactSource(contactSourceService);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageHistoryServiceImpl.findByEndDate",
	"Comment": "returns all the messages exchangedin the supplied chat room before the given date",
	"Method": "Collection<EventObject> findByEndDate(MetaContact contact,Date endDate,Collection<EventObject> findByEndDate,ChatRoom room,Date endDate){\r\n    HashSet<EventObject> result = new HashSet<EventObject>();\r\n    try {\r\n        HistoryReader reader = this.getHistoryForMultiChat(room).getReader();\r\n        addHistorySearchProgressListeners(reader, 1);\r\n        Iterator<HistoryRecord> recs = reader.findByEndDate(endDate);\r\n        while (recs.hasNext()) {\r\n            result.add(convertHistoryRecordToMessageEvent(recs.next(), room));\r\n        }\r\n        removeHistorySearchProgressListeners(reader);\r\n    } catch (IOException e) {\r\n        logger.error(\"Could not read history\", e);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.callhistory.CallHistorySourceContact.getContactDetails",
	"Comment": "returns a list of all contactdetails corresponding to the givencategory.",
	"Method": "List<ContactDetail> getContactDetails(List<ContactDetail> getContactDetails,Class<? extends OperationSet> operationSet,List<ContactDetail> getContactDetails,ContactDetail.Category category){\r\n    throw new OperationNotSupportedException(\"Categories are not supported for call history records.\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetServerStoredAccountInfoSipImpl.getDetailsAndDescendants",
	"Comment": "returns an iterator over all details of the specified class.",
	"Method": "Iterator<T> getDetailsAndDescendants(Class<T> detailClass){\r\n    List<T> result = new Vector<T>();\r\n    if (ImageDetail.class.isAssignableFrom(detailClass) && isImageDetailSupported()) {\r\n        ImageDetail imageDetail = getAccountImage();\r\n        if (imageDetail != null) {\r\n            @SuppressWarnings(\"unchecked\")\r\n            T t = (T) getAccountImage();\r\n            result.add(t);\r\n        }\r\n    } else if (DisplayNameDetail.class.isAssignableFrom(detailClass) && displayNameDetail != null) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        T t = (T) displayNameDetail;\r\n        result.add(t);\r\n    }\r\n    return result.iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.ircaccregwizz.IrcAccountRegistrationWizard.getSummary",
	"Comment": "returns the set of data that user has entered through this wizard.",
	"Method": "Iterator<Map.Entry<String, String>> getSummary(){\r\n    LinkedHashMap<String, String> summaryTable = new LinkedHashMap<String, String>();\r\n    String pass = new String();\r\n    String port = new String();\r\n    if (registration.isRequiredPassword()) {\r\n        pass = \"required\";\r\n    } else {\r\n        pass = \"not required\";\r\n    }\r\n    port = registration.getPort();\r\n    if (!port.equals(\"\")) {\r\n        port = \":\" + port;\r\n    }\r\n    final String yes = Resources.getString(\"service.gui.YES\");\r\n    final String no = Resources.getString(\"service.gui.NO\");\r\n    summaryTable.put(Resources.getString(\"plugin.ircaccregwizz.USERNAME\"), registration.getUserID());\r\n    summaryTable.put(Resources.getString(\"service.gui.PASSWORD\"), pass);\r\n    summaryTable.put(Resources.getString(\"plugin.ircaccregwizz.IRC_SERVER\"), registration.getServer() + port);\r\n    summaryTable.put(Resources.getString(\"plugin.ircaccregwizz.USE_SECURE_CONNECTION\"), registration.isSecureConnection() ? yes : no);\r\n    summaryTable.put(Resources.getString(\"plugin.ircaccregwizz.RESOLVE_DNS_THROUGH_PROXY\"), registration.isResolveDnsThroughProxy() ? yes : no);\r\n    summaryTable.put(Resources.getString(\"plugin.ircaccregwizz.ENABLE_CONTACT_PRESENCE\"), registration.isContactPresenceTaskEnabled() ? yes : no);\r\n    summaryTable.put(Resources.getString(\"plugin.ircaccregwizz.ENABLE_CHAT_ROOM_PRESENCE\"), registration.isChatRoomPresenceTaskEnabled() ? yes : no);\r\n    summaryTable.put(Resources.getString(\"plugin.ircaccregwizz.ENABLE_SASL_AUTHENTICATION\"), registration.isSaslEnabled() ? yes : no);\r\n    summaryTable.put(\"SASL \" + Resources.getString(\"plugin.ircaccregwizz.USERNAME\"), registration.getSaslUser());\r\n    summaryTable.put(\"SASL \" + Resources.getString(\"plugin.ircaccregwizz.SASL_AUTHZ_ROLE\"), registration.getSaslRole());\r\n    return summaryTable.entrySet().iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommFrame.ensureOnScreenLocationAndSize",
	"Comment": "checks whether the current component will exceeds the screen size and ifit do will set a default size",
	"Method": "void ensureOnScreenLocationAndSize(){\r\n    ConfigurationService config = DesktopUtilActivator.getConfigurationService();\r\n    if (!config.getBoolean(SIPCommFrame.PNAME_CALCULATED_POSITIONING, true))\r\n        return;\r\n    int x = this.getX();\r\n    int y = this.getY();\r\n    int width = this.getWidth();\r\n    int height = this.getHeight();\r\n    Rectangle virtualBounds = ScreenInformation.getScreenBounds();\r\n    final int borderDistance = 10;\r\n    if (!(virtualBounds.contains(x, y))) {\r\n        if (x < virtualBounds.x) {\r\n            x = virtualBounds.x + borderDistance;\r\n        } else if (x > virtualBounds.x) {\r\n            x = virtualBounds.x + virtualBounds.width - width - borderDistance;\r\n            if (x < virtualBounds.x + borderDistance) {\r\n                x = virtualBounds.x + borderDistance;\r\n            }\r\n        }\r\n        if (y < virtualBounds.y) {\r\n            y = virtualBounds.y + borderDistance;\r\n        } else if (y > virtualBounds.y) {\r\n            y = virtualBounds.y + virtualBounds.height - height - borderDistance;\r\n            if (y < virtualBounds.y + borderDistance) {\r\n                y = virtualBounds.y + borderDistance;\r\n            }\r\n        }\r\n        this.setLocation(x, y);\r\n    }\r\n    if (!(virtualBounds.contains(x + width, y + height))) {\r\n        if (x + width > virtualBounds.x + virtualBounds.width) {\r\n            x = virtualBounds.x + virtualBounds.width - width - borderDistance;\r\n            if (x < virtualBounds.x + borderDistance) {\r\n                x = virtualBounds.x + borderDistance;\r\n                width = virtualBounds.width - 2 * borderDistance;\r\n            }\r\n        }\r\n        if (y + height > virtualBounds.y + virtualBounds.height) {\r\n            y = virtualBounds.y + virtualBounds.height - height - borderDistance;\r\n            if (y < virtualBounds.y + borderDistance) {\r\n                y = virtualBounds.y + borderDistance;\r\n                height = virtualBounds.height - 2 * borderDistance;\r\n            }\r\n        }\r\n        this.setPreferredSize(new Dimension(width, height));\r\n        this.setSize(width, height);\r\n        this.setLocation(x, y);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageSourceContact.updateMessageContent",
	"Comment": "make sure the content of the message is not too long,as it will fill up tooltips and ui components.",
	"Method": "void updateMessageContent(){\r\n    if (isToday(timestamp)) {\r\n        this.messageContent = new SimpleDateFormat(TODAY_DATE_FORMAT).format(timestamp) + this.messageContent;\r\n    } else {\r\n        this.messageContent = new SimpleDateFormat(PAST_DATE_FORMAT).format(timestamp) + this.messageContent;\r\n    }\r\n    if (this.messageContent != null && this.messageContent.length() > 60) {\r\n        this.messageContent = this.messageContent.substring(0, 60);\r\n        this.messageContent += \"...\";\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractOperationSetDesktopSharingClient.getListener",
	"Comment": "returns the remotecontrollistener corresponding to the givencallpeer, if it exists.",
	"Method": "RemoteControlListener getListener(CallPeer callPeer){\r\n    String peerID = callPeer.getPeerID();\r\n    synchronized (listeners) {\r\n        Iterator<WeakReference<RemoteControlListener>> i = listeners.iterator();\r\n        while (i.hasNext()) {\r\n            RemoteControlListener l = i.next().get();\r\n            if (l == null)\r\n                i.remove();\r\n            else if (peerID.equals(l.getCallPeer().getPeerID()))\r\n                return l;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.Resources.getSettingsString",
	"Comment": "returns an internationalized string corresponding to the given key.",
	"Method": "String getSettingsString(String key){\r\n    return getResources().getSettingsString(key);\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.SaveOptimizeTest.testDirtySession",
	"Comment": "test that a dirty session will always be saved regardless ofsave optimisation.",
	"Method": "void testDirtySession(){\r\n    String contextPath = \"\";\r\n    String servletMapping = \"/server\";\r\n    int inactivePeriod = 600;\r\n    int scavengePeriod = 30;\r\n    int savePeriod = 5;\r\n    DefaultSessionCacheFactory cacheFactory = new DefaultSessionCacheFactory();\r\n    cacheFactory.setEvictionPolicy(SessionCache.NEVER_EVICT);\r\n    cacheFactory.setSaveOnCreate(true);\r\n    TestSessionDataStoreFactory storeFactory = new TestSessionDataStoreFactory();\r\n    storeFactory.setSavePeriodSec(savePeriod);\r\n    _server1 = new TestServer(0, inactivePeriod, scavengePeriod, cacheFactory, storeFactory);\r\n    _servlet = new TestServlet();\r\n    ServletHolder holder = new ServletHolder(_servlet);\r\n    ServletContextHandler contextHandler = _server1.addContext(contextPath);\r\n    contextHandler.addServlet(holder, servletMapping);\r\n    _servlet.setStore(contextHandler.getSessionHandler().getSessionCache().getSessionDataStore());\r\n    _server1.start();\r\n    int port1 = _server1.getPort();\r\n    try (StacklessLogging stackless = new StacklessLogging(Log.getLogger(\"org.eclipse.jetty.server.session\"))) {\r\n        HttpClient client = new HttpClient();\r\n        try {\r\n            client.start();\r\n            String url = \"http://localhost:\" + port1 + contextPath + servletMapping + \"?action=create&check=true\";\r\n            ContentResponse response = client.GET(url);\r\n            assertEquals(HttpServletResponse.SC_OK, response.getStatus());\r\n            String sessionCookie = response.getHeaders().get(\"Set-Cookie\");\r\n            assertNotNull(sessionCookie);\r\n            String sessionId = TestServer.extractSessionId(sessionCookie);\r\n            SessionData data = contextHandler.getSessionHandler().getSessionCache().getSessionDataStore().load(sessionId);\r\n            assertNotNull(data);\r\n            int numSavesBefore = getNumSaves();\r\n            client.newRequest(\"http://localhost:\" + port1 + contextPath + servletMapping + \"?action=noop\").send();\r\n            SessionData d = contextHandler.getSessionHandler().getSessionCache().getSessionDataStore().load(sessionId);\r\n            assertNotNull(d);\r\n            assertThat(getNumSaves(), equalTo(numSavesBefore));\r\n            numSavesBefore = getNumSaves();\r\n            client.newRequest(\"http://localhost:\" + port1 + contextPath + servletMapping + \"?action=mutate\").send();\r\n            d = contextHandler.getSessionHandler().getSessionCache().getSessionDataStore().load(sessionId);\r\n            assertNotNull(d);\r\n            assertThat(getNumSaves(), greaterThan(numSavesBefore));\r\n        } finally {\r\n            client.stop();\r\n        }\r\n    } finally {\r\n        _server1.stop();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.contactlist.TestMetaContactListPersistence.testPurgeLocalContactListCopy",
	"Comment": "removes the locally stored contact list copy. the purpose of this is toleave the local list empty for a next round of testing.",
	"Method": "void testPurgeLocalContactListCopy(){\r\n    fixture.metaClService.purgeLocallyStoredContactListCopy();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactListServiceImpl.findMetaContactGroupByMetaUID",
	"Comment": "returns the metacontactgroup that corresponds to the specifiedmetagroupid.",
	"Method": "MetaContactGroup findMetaContactGroupByMetaUID(String metaGroupID){\r\n    return rootMetaGroup.findMetaContactGroupByMetaUID(metaGroupID);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapActivator.unregisterContactSource",
	"Comment": "disable contact source service with specified ldap directory.",
	"Method": "void unregisterContactSource(LdapDirectory ldapDir){\r\n    LdapContactSourceService found = null;\r\n    for (Map.Entry<LdapContactSourceService, ServiceRegistration> entry : cssList.entrySet()) {\r\n        String cssName = entry.getKey().getLdapDirectory().getSettings().getName();\r\n        String name = ldapDir.getSettings().getName();\r\n        if (cssName.equals(name)) {\r\n            try {\r\n                entry.getValue().unregister();\r\n            } finally {\r\n                entry.getKey().stop();\r\n            }\r\n            found = entry.getKey();\r\n            break;\r\n        }\r\n    }\r\n    if (found != null) {\r\n        cssList.remove(found);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.DesktopUtilActivator.getBrowserLauncher",
	"Comment": "returns the browserlauncherservice obtained from the bundlecontext.",
	"Method": "BrowserLauncherService getBrowserLauncher(){\r\n    if (browserLauncherService == null) {\r\n        browserLauncherService = ServiceUtils.getService(bundleContext, BrowserLauncherService.class);\r\n    }\r\n    return browserLauncherService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.history.HistoryWindow.createHistory",
	"Comment": "shows the history given by the collection into a chatconversationpanel.",
	"Method": "HTMLDocument createHistory(Collection<Object> historyRecords){\r\n    if ((historyRecords != null) && (historyRecords.size() > 0)) {\r\n        Iterator<Object> i = historyRecords.iterator();\r\n        String processedMessage = \"\";\r\n        while (i.hasNext()) {\r\n            Object o = i.next();\r\n            ChatMessage chatMessage = null;\r\n            ProtocolProviderService protocolProvider = null;\r\n            if (o instanceof MessageDeliveredEvent) {\r\n                MessageDeliveredEvent evt = (MessageDeliveredEvent) o;\r\n                protocolProvider = evt.getDestinationContact().getProtocolProvider();\r\n                chatMessage = new ChatMessage(GuiActivator.getUIService().getMainFrame().getAccountAddress(protocolProvider), GuiActivator.getUIService().getMainFrame().getAccountDisplayName(protocolProvider), evt.getTimestamp(), Chat.OUTGOING_MESSAGE, null, evt.getSourceMessage().getContent(), evt.getSourceMessage().getContentType(), evt.getSourceMessage().getMessageUID(), null);\r\n            } else if (o instanceof MessageReceivedEvent) {\r\n                MessageReceivedEvent evt = (MessageReceivedEvent) o;\r\n                protocolProvider = evt.getSourceContact().getProtocolProvider();\r\n                chatMessage = new ChatMessage(evt.getSourceContact().getAddress(), evt.getSourceContact().getDisplayName(), evt.getTimestamp(), Chat.INCOMING_MESSAGE, null, evt.getSourceMessage().getContent(), evt.getSourceMessage().getContentType(), evt.getSourceMessage().getMessageUID(), null);\r\n            } else if (o instanceof ChatRoomMessageReceivedEvent) {\r\n                ChatRoomMessageReceivedEvent evt = (ChatRoomMessageReceivedEvent) o;\r\n                protocolProvider = evt.getSourceChatRoom().getParentProvider();\r\n                chatMessage = new ChatMessage(evt.getSourceChatRoomMember().getName(), evt.getTimestamp(), Chat.INCOMING_MESSAGE, evt.getMessage().getContent(), evt.getMessage().getContentType());\r\n            } else if (o instanceof ChatRoomMessageDeliveredEvent) {\r\n                ChatRoomMessageDeliveredEvent evt = (ChatRoomMessageDeliveredEvent) o;\r\n                protocolProvider = evt.getSourceChatRoom().getParentProvider();\r\n                chatMessage = new ChatMessage(evt.getSourceChatRoom().getParentProvider().getAccountID().getUserID(), evt.getTimestamp(), Chat.INCOMING_MESSAGE, evt.getMessage().getContent(), evt.getMessage().getContentType());\r\n            } else if (o instanceof FileRecord) {\r\n                FileRecord fileRecord = (FileRecord) o;\r\n                protocolProvider = fileRecord.getContact().getProtocolProvider();\r\n                FileHistoryConversationComponent component = new FileHistoryConversationComponent(fileRecord);\r\n                chatConvPanel.addComponent(component);\r\n            }\r\n            if (chatMessage != null) {\r\n                processedMessage = chatConvPanel.processMessage(chatMessage, searchKeyword, protocolProvider, chatMessage.getContactName());\r\n                chatConvPanel.appendMessageToEnd(processedMessage, ChatHtmlUtils.HTML_CONTENT_TYPE);\r\n            }\r\n        }\r\n    }\r\n    this.chatConvPanel.setDefaultContent();\r\n    return this.chatConvPanel.getContent();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.RootContactGroupIcqImpl.isPersistent",
	"Comment": "determines whether or not this contact group is being stored by theserver. non persistent contact groups exist for the sole purpose ofcontaining non persistent contacts.",
	"Method": "boolean isPersistent(){\r\n    return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.TestOperationSetTypingNotifications.testTypingNotificationsEventDelivery",
	"Comment": "sends a typing notification and verifieswhether it is properly received by the tested implementation",
	"Method": "void testTypingNotificationsEventDelivery(){\r\n    TypingEventCollector evtCollector = new TypingEventCollector();\r\n    Contact notifingContact = opSetPresence1.findContactByID(fixture.userID2);\r\n    opSetBasicIM1.sendInstantMessage(notifingContact, opSetBasicIM1.createMessage(\"ping\"));\r\n    opSetTypingNotifs1.addTypingNotificationsListener(evtCollector);\r\n    Contact contactToNotify = opSetPresence2.findContactByID(fixture.userID1);\r\n    opSetTypingNotifs2.sendTypingNotification(contactToNotify, OperationSetTypingNotifications.STATE_TYPING);\r\n    evtCollector.waitForEvent(10000);\r\n    opSetTypingNotifs1.removeTypingNotificationsListener(evtCollector);\r\n    assertTrue(\"Number of typing events received was zero.\", evtCollector.collectedEvents.size() > 0);\r\n    TypingNotificationEvent evt = (TypingNotificationEvent) evtCollector.collectedEvents.get(0);\r\n    assertEquals(\"Source of the typing notification event\", fixture.userID2, evt.getSourceContact().getAddress());\r\n    assertEquals(\"Source of the typing notification event\", OperationSetTypingNotifications.STATE_TYPING, evt.getTypingState());\r\n    evtCollector.collectedEvents.clear();\r\n    opSetTypingNotifs1.addTypingNotificationsListener(evtCollector);\r\n    opSetTypingNotifs2.sendTypingNotification(contactToNotify, OperationSetTypingNotifications.STATE_STOPPED);\r\n    evtCollector.waitForEvent(10000);\r\n    opSetTypingNotifs1.removeTypingNotificationsListener(evtCollector);\r\n    assertTrue(\"Number of typing events received was zero.\", evtCollector.collectedEvents.size() > 0);\r\n    logger.trace(\"We have collected \" + evtCollector.collectedEvents.size() + \" typing notifications.\");\r\n    logger.trace(\"Notifications: \" + evtCollector.collectedEvents);\r\n    evt = (TypingNotificationEvent) evtCollector.collectedEvents.get(0);\r\n    assertEquals(\"Source of the typing notification event\", fixture.userID2, evt.getSourceContact().getAddress());\r\n    assertEquals(\"Source of the typing notification event\", OperationSetTypingNotifications.STATE_STOPPED, evt.getTypingState());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.metahistory.MetaHistoryServiceImpl.findByStartDate",
	"Comment": "returns all the records for the descriptor after the given date.",
	"Method": "Collection<Object> findByStartDate(String[] services,Object descriptor,Date startDate){\r\n    MessageProgressWrapper listenWrapper = new MessageProgressWrapper(services.length);\r\n    TreeSet<Object> result = new TreeSet<Object>(new RecordsComparator());\r\n    for (int i = 0; i < services.length; i++) {\r\n        String name = services[i];\r\n        Object serv = getService(name);\r\n        if (serv instanceof MessageHistoryService) {\r\n            MessageHistoryService mhs = (MessageHistoryService) serv;\r\n            listenWrapper.setIx(i);\r\n            mhs.addSearchProgressListener(listenWrapper);\r\n            if (descriptor instanceof MetaContact) {\r\n                result.addAll(mhs.findByStartDate((MetaContact) descriptor, startDate));\r\n            } else if (descriptor instanceof ChatRoom) {\r\n                result.addAll(mhs.findByStartDate((ChatRoom) descriptor, startDate));\r\n            }\r\n            mhs.removeSearchProgressListener(listenWrapper);\r\n        } else if (serv instanceof FileHistoryService && descriptor instanceof MetaContact) {\r\n            result.addAll(((FileHistoryService) serv).findByStartDate((MetaContact) descriptor, startDate));\r\n        } else if (serv instanceof CallHistoryService) {\r\n            CallHistoryService chs = (CallHistoryService) serv;\r\n            listenWrapper.setIx(i);\r\n            chs.addSearchProgressListener(listenWrapper);\r\n            result.addAll(chs.findByStartDate(startDate));\r\n            chs.removeSearchProgressListener(listenWrapper);\r\n        }\r\n    }\r\n    listenWrapper.fireLastProgress(startDate, null, null);\r\n    return result;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageHistoryServiceImpl.findRecentMessagesPerContact",
	"Comment": "returns the messages for the recently contacted count contacts.",
	"Method": "Collection<EventObject> findRecentMessagesPerContact(int count,String providerToFilter,String contactToFilter,boolean isSMSEnabled){\r\n    HashSet<EventObject> result = new HashSet<EventObject>();\r\n    List<HistoryID> historyIDs = this.historyService.getExistingHistories(new String[] { \"messages\", \"default\" });\r\n    String providerFilterStr = null;\r\n    if (providerToFilter != null)\r\n        providerFilterStr = HistoryID.readableHash(providerToFilter);\r\n    for (HistoryID id : historyIDs) {\r\n        if (result.size() >= count)\r\n            break;\r\n        try {\r\n            if (id.getID().length != 4)\r\n                continue;\r\n            if (providerFilterStr != null && !id.getID()[2].startsWith(providerFilterStr)) {\r\n                continue;\r\n            }\r\n            if (contactToFilter != null && !id.getID()[3].startsWith(contactToFilter)) {\r\n                continue;\r\n            }\r\n            Object descriptor = getContactOrRoomByID(providerToFilter, id.getID()[3], id, isSMSEnabled);\r\n            if (descriptor == null)\r\n                continue;\r\n            History history = this.historyService.createHistory(id, recordStructure);\r\n            HistoryReader reader = history.getReader();\r\n            Iterator<HistoryRecord> recs;\r\n            if (isSMSEnabled) {\r\n                recs = reader.findLast(1, new String[] { MessageHistoryServiceImpl.MSG_SUBTYPE_SMS }, MessageHistoryServiceImpl.STRUCTURE_NAMES[7], true);\r\n            } else {\r\n                recs = reader.findLast(1);\r\n            }\r\n            while (recs.hasNext()) {\r\n                if (descriptor instanceof Contact) {\r\n                    EventObject o = convertHistoryRecordToMessageEvent(recs.next(), (Contact) descriptor);\r\n                    result.add(o);\r\n                }\r\n                if (descriptor instanceof ChatRoom) {\r\n                    EventObject o = convertHistoryRecordToMessageEvent(recs.next(), (ChatRoom) descriptor);\r\n                    result.add(o);\r\n                }\r\n                break;\r\n            }\r\n        } catch (IOException ex) {\r\n            logger.error(\"Could not read history\", ex);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetWhiteboardingJabberImpl.createWhiteboardSession",
	"Comment": "creates a whiteboardsession. for now the session is createdlocally and neither the sessionname, nor the sessionproperties areused.",
	"Method": "WhiteboardSession createWhiteboardSession(String sessionName,Hashtable<Object, Object> sessionProperties){\r\n    WhiteboardSessionJabberImpl session = new WhiteboardSessionJabberImpl(jabberProvider, this);\r\n    whiteboardSessions.add(session);\r\n    return session;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.TestOperationSetMultiUserChat2.testFindRoom",
	"Comment": "testfindroom will looks for an unexisting room and an existingone to see if results are what we expect.",
	"Method": "void testFindRoom(){\r\n    String testRoomName = testRoomBaseName + roomID++;\r\n    ChatRoom opSet1Room = opSetMUC1.createChatRoom(testRoomName, null);\r\n    opSet1Room.join();\r\n    ChatRoom foundRoom = null;\r\n    try {\r\n        foundRoom = opSetMUC2.findRoom(testRoomName);\r\n    } catch (Exception ex) {\r\n        logger.warn(ex);\r\n    }\r\n    assertNotNull(\"failed to find an existing room on server\", foundRoom);\r\n    assertEquals(\"the room found is not exactly the one we were looking for\", opSet1Room.getName(), foundRoom.getName());\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.connectioninfo.ConnectionInfoPanel.getAccountsTable",
	"Comment": "returns mapping between registered accountids and their respectiveaccountdetailspanel that contains all the details for the account.",
	"Method": "Map<AccountID, ConnectionDetailsPanel> getAccountsTable(){\r\n    return accountsTable;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.contactsource.ContactDetail.getDisplayName",
	"Comment": "returns the display name of this detail. by default returns the detailvalue.",
	"Method": "String getDisplayName(){\r\n    return detailDisplayName;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipStackSharing.logApplicationException",
	"Comment": "logs exceptions that have occurred in the application while processingevents originating from the stack.",
	"Method": "void logApplicationException(Class<DialogTerminatedEvent> eventClass,Throwable exc){\r\n    String message = \"An error occurred while processing event of type: \" + eventClass.getName();\r\n    logger.error(message, exc);\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(message, exc);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.globaldisplaydetails.GlobalStatusServiceImpl.getLastPresenceStatus",
	"Comment": "returns the last status that was stored in the configuration for thegiven protocol provider.",
	"Method": "PresenceStatus getLastPresenceStatus(ProtocolProviderService protocolProvider){\r\n    String lastStatus = getLastStatusString(protocolProvider);\r\n    PresenceStatus status = null;\r\n    if (lastStatus != null) {\r\n        OperationSetPresence presence = protocolProvider.getOperationSet(OperationSetPresence.class);\r\n        if (presence == null)\r\n            return null;\r\n        Iterator<PresenceStatus> i = presence.getSupportedStatusSet();\r\n        while (i.hasNext()) {\r\n            PresenceStatus nextStatus = i.next();\r\n            if (nextStatus.getStatusName().equals(lastStatus))\r\n                status = nextStatus;\r\n        }\r\n        if (status == null) {\r\n            if (lastStatus.equals(GlobalStatusEnum.ONLINE_STATUS)) {\r\n                status = getPresenceStatus(protocolProvider, PresenceStatus.AVAILABLE_THRESHOLD, PresenceStatus.EAGER_TO_COMMUNICATE_THRESHOLD);\r\n            } else if (lastStatus.equals(GlobalStatusEnum.AWAY_STATUS)) {\r\n                status = getPresenceStatus(protocolProvider, PresenceStatus.AWAY_THRESHOLD, PresenceStatus.AVAILABLE_THRESHOLD);\r\n            } else if (lastStatus.equals(GlobalStatusEnum.EXTENDED_AWAY_STATUS)) {\r\n                status = getPresenceStatus(protocolProvider, PresenceStatus.EXTENDED_AWAY_THRESHOLD, PresenceStatus.AWAY_THRESHOLD);\r\n            } else if (lastStatus.equals(GlobalStatusEnum.DO_NOT_DISTURB_STATUS)) {\r\n                status = getPresenceStatus(protocolProvider, PresenceStatus.ONLINE_THRESHOLD, PresenceStatus.EXTENDED_AWAY_THRESHOLD);\r\n            } else if (lastStatus.equals(GlobalStatusEnum.FREE_FOR_CHAT_STATUS)) {\r\n                status = getPresenceStatus(protocolProvider, PresenceStatus.AVAILABLE_THRESHOLD, PresenceStatus.MAX_STATUS_VALUE);\r\n            } else if (lastStatus.equals(GlobalStatusEnum.OFFLINE_STATUS)) {\r\n                status = getPresenceStatus(protocolProvider, 0, GlobalStatusEnum.ONLINE_THRESHOLD);\r\n            }\r\n        }\r\n    }\r\n    return status;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.filehistory.FileHistoryServiceImpl.start",
	"Comment": "starts the service. check the current registered protocol providerswhich supports filetransfer and adds a listener to them.",
	"Method": "void start(BundleContext bc){\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Starting the file history implementation.\");\r\n    this.bundleContext = bc;\r\n    bc.addServiceListener(this);\r\n    Collection<ServiceReference<ProtocolProviderService>> ppsRefs = ServiceUtils.getServiceReferences(bc, ProtocolProviderService.class);\r\n    if (!ppsRefs.isEmpty()) {\r\n        if (logger.isDebugEnabled()) {\r\n            logger.debug(\"Found \" + ppsRefs.size() + \" already installed providers.\");\r\n        }\r\n        for (ServiceReference<ProtocolProviderService> ppsRef : ppsRefs) {\r\n            ProtocolProviderService pps = bc.getService(ppsRef);\r\n            handleProviderAdded(pps);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.jinglesdp.JingleUtils.extractFormats",
	"Comment": "extracts and returns the list of mediaformats advertised indescription preserving their oder and registering dynamic payloadtype numbers in the specified ptregistry. note that this methodwould only include in the result list mediaformat instancesthat are currently supported by our mediaservice implementationand enabled in its configuration. this means that the method couldreturn an empty list even if there were actually some formats in themediadesc if we support none of them or if all these we supportare not enabled in the mediaservice configuration form.",
	"Method": "List<MediaFormat> extractFormats(RtpDescriptionPacketExtension description,DynamicPayloadTypeRegistry ptRegistry){\r\n    List<MediaFormat> mediaFmts = new ArrayList<MediaFormat>();\r\n    if (description == null) {\r\n        return mediaFmts;\r\n    }\r\n    List<PayloadTypePacketExtension> payloadTypes = description.getPayloadTypes();\r\n    for (PayloadTypePacketExtension ptExt : payloadTypes) {\r\n        MediaFormat format = payloadTypeToMediaFormat(ptExt, ptRegistry);\r\n        if (format == null) {\r\n            if (logger.isTraceEnabled())\r\n                logger.trace(\"Unsupported remote format: \" + ptExt.toXML());\r\n        } else\r\n            mediaFmts.add(format);\r\n    }\r\n    return mediaFmts;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.MobileIndicator.updateMobileIndicatorUsingCaps",
	"Comment": "update mobile indicator for contact, searching in contact caps.",
	"Method": "void updateMobileIndicatorUsingCaps(String user){\r\n    ContactJabberImpl contact = ssclCallback.findContactById(StringUtils.parseBareAddress(user));\r\n    if (contact == null)\r\n        return;\r\n    int currentMostConnectedStatus = 0;\r\n    List<ContactResource> mostAvailableResources = new ArrayList<ContactResource>();\r\n    for (Map.Entry<String, ContactResourceJabberImpl> resEntry : contact.getResourcesMap().entrySet()) {\r\n        ContactResourceJabberImpl res = resEntry.getValue();\r\n        if (!res.getPresenceStatus().isOnline())\r\n            continue;\r\n        boolean oldIndicator = res.isMobile();\r\n        res.setMobile(isMobileResource(res.getResourceName(), res.getFullJid()));\r\n        if (oldIndicator != res.isMobile()) {\r\n            contact.fireContactResourceEvent(new ContactResourceEvent(contact, res, ContactResourceEvent.RESOURCE_MODIFIED));\r\n        }\r\n        int status = res.getPresenceStatus().getStatus();\r\n        if (status > currentMostConnectedStatus) {\r\n            if (currentMostConnectedStatus != status)\r\n                mostAvailableResources.clear();\r\n            currentMostConnectedStatus = status;\r\n            mostAvailableResources.add(res);\r\n        }\r\n    }\r\n    boolean allMobile = false;\r\n    for (ContactResource res : mostAvailableResources) {\r\n        if (res.isMobile())\r\n            allMobile = true;\r\n        else {\r\n            allMobile = false;\r\n            break;\r\n        }\r\n    }\r\n    if (mostAvailableResources.size() > 0)\r\n        contact.setMobile(allMobile);\r\n    else\r\n        contact.setMobile(false);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockMultiUserChat.getCurrentlyJoinedChatRooms",
	"Comment": "returns a list of the chat rooms that chatroommember has joinedand is currently active in.",
	"Method": "List<ChatRoom> getCurrentlyJoinedChatRooms(List<String> getCurrentlyJoinedChatRooms,ChatRoomMember chatRoomMember){\r\n    List<String> result = new Vector<String>();\r\n    for (ChatRoom elem : joinedChatRooms) if (elem.getMembers().contains(chatRoomMember))\r\n        result.add(elem.getName());\r\n    return result;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.gibberishaccregwizz.GibberishAccountRegistration.getPassword",
	"Comment": "returns the password of the gibberish registration account.",
	"Method": "String getPassword(){\r\n    return password;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWindowManager.isChatOpenedFor",
	"Comment": "returns true if there is an opened chatpanel for thegiven metacontact.",
	"Method": "boolean isChatOpenedFor(MetaContact metaContact){\r\n    return isChatOpenedForDescriptor(metaContact);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.AdHocConferenceChatSession.setCurrentChatTransport",
	"Comment": "sets the transport that will be used for all operations within this chatsession.",
	"Method": "void setCurrentChatTransport(ChatTransport chatTransport){\r\n    this.currentChatTransport = chatTransport;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatSession.removeMemberRoleListener",
	"Comment": "removes the given chatroommemberrolelistener from the containedchat room role listeners.",
	"Method": "void removeMemberRoleListener(ChatRoomMemberRoleListener l){\r\n    chatRoomWrapper.getChatRoom().removeMemberRoleListener(l);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.ErrorDialog.close",
	"Comment": "close the errordialog. this function is invoked when userpresses the escape key.",
	"Method": "void close(boolean isEscaped){\r\n    this.okButton.doClick();\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.NetworkUtils.getSRVRecord",
	"Comment": "returns an inetsocketaddress representing the first srvrecord available for the specified domain or null if there arenot srv records for domain.",
	"Method": "SRVRecord getSRVRecord(String service,String proto,String domain){\r\n    SRVRecord[] records = getSRVRecords(\"_\" + service + \"._\" + proto + \".\" + domain, true);\r\n    if (records == null || records.length == 0)\r\n        return null;\r\n    return records[0];\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.generic.ImEventCollector.messageDeliveryFailed",
	"Comment": "called to indicated that delivery of a message sent earlier has failed.reason code and phrase are contained by the messagefailedevent",
	"Method": "void messageDeliveryFailed(MessageDeliveryFailedEvent evt){\r\n    logger.debug(\"Received a MessageDeliveryFailedEvent: \" + evt);\r\n    synchronized (this) {\r\n        collectedEvents.add(evt);\r\n        notifyAll();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.GuiActivator.getGlobalStatusService",
	"Comment": "returns the globalstatusservice obtained from the bundlecontext.",
	"Method": "GlobalStatusService getGlobalStatusService(){\r\n    if (globalStatusService == null) {\r\n        globalStatusService = ServiceUtils.getService(bundleContext, GlobalStatusService.class);\r\n    }\r\n    return globalStatusService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.thunderbird.ThunderbirdContactSourceService.getFilename",
	"Comment": "gets the filename to the address book database processed by thiscontactsource.",
	"Method": "String getFilename(){\r\n    return this.fileName;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.whiteboard.WhiteboardObjectPolygonJabberImpl.getPoints",
	"Comment": "returns a list of all the whiteboardpoint instances that thiswhiteboardobject is composed of.",
	"Method": "List<WhiteboardPoint> getPoints(){\r\n    return this.listPoints;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.googlecontacts.GoogleContactsActivator.enableContactSource",
	"Comment": "enable contact source service with specifiedgooglecontactsconnection.",
	"Method": "GoogleContactsSourceService enableContactSource(String login,boolean googleTalk,GoogleContactsSourceService enableContactSource,GoogleContactsConnection cnx,boolean googleTalk){\r\n    GoogleContactsSourceService css = new GoogleContactsSourceService(cnx);\r\n    ServiceRegistration<?> cssServiceRegistration = null;\r\n    css.setGoogleTalk(googleTalk);\r\n    try {\r\n        cssServiceRegistration = bundleContext.registerService(ContactSourceService.class.getName(), css, null);\r\n    } finally {\r\n        if (cssServiceRegistration == null) {\r\n            css.stop();\r\n            css = null;\r\n        } else {\r\n            cssList.put(css, cssServiceRegistration);\r\n        }\r\n    }\r\n    return css;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetPresenceSipImpl.registrationStateChanged",
	"Comment": "the method is called by a protocolprovider implementation whenevera change in the registration state of the corresponding provider hadoccurred. the method is particularly interested in events statingthat the sip provider has unregistered so that it would firestatus change events for all contacts in our buddy list.",
	"Method": "void registrationStateChanged(RegistrationStateChangeEvent evt){\r\n    if (evt.getNewState().equals(RegistrationState.UNREGISTERING)) {\r\n        if (logger.isDebugEnabled()) {\r\n            logger.debug(\"Enter unregistering state\");\r\n        }\r\n        cancelTimer();\r\n        ssContactList.destroy();\r\n        try {\r\n            publishPresenceStatus(sipStatusEnum.getStatus(SipStatusEnum.OFFLINE), \"\");\r\n        } catch (OperationFailedException e) {\r\n            logger.error(\"can't set the offline mode\", e);\r\n        }\r\n        stopEvents();\r\n    } else if (evt.getNewState().equals(RegistrationState.REGISTERED)) {\r\n        if (logger.isDebugEnabled()) {\r\n            logger.debug(\"enter registered state\");\r\n        }\r\n        ssContactList.init();\r\n        if ((!presenceEnabled) || (pollingTask != null)) {\r\n            return;\r\n        }\r\n        for (ContactSipImpl contact : ssContactList.getAllContacts(ssContactList.getRootGroup())) {\r\n            forcePollContact(contact);\r\n        }\r\n        pollingTask = new PollOfflineContactsTask();\r\n        timer.schedule(pollingTask, pollingTaskPeriod, pollingTaskPeriod);\r\n        if (this.useDistantPA) {\r\n            try {\r\n                watcherInfoSubscriber.subscribe(new WatcherInfoSubscriberSubscription(parentProvider.getRegistrarConnection().getAddressOfRecord()));\r\n            } catch (OperationFailedException ex) {\r\n                logger.error(\"Failed to create and send the subcription \" + \"for watcher info.\", ex);\r\n            }\r\n        }\r\n    } else if (evt.getNewState().equals(RegistrationState.CONNECTION_FAILED) || evt.getNewState().equals(RegistrationState.AUTHENTICATION_FAILED)) {\r\n        if (logger.isDebugEnabled()) {\r\n            logger.debug(\"Enter connction failed state\");\r\n        }\r\n        ssContactList.destroy();\r\n        for (ContactSipImpl contact : ssContactList.getAllContacts(ssContactList.getRootGroup())) {\r\n            PresenceStatus oldContactStatus = contact.getPresenceStatus();\r\n            if (subscriber != null) {\r\n                try {\r\n                    subscriber.removeSubscription(getAddress(contact));\r\n                } catch (OperationFailedException ex) {\r\n                    if (logger.isDebugEnabled()) {\r\n                        logger.debug(\"Failed to remove subscription to contact \" + contact);\r\n                    }\r\n                }\r\n            }\r\n            if (!oldContactStatus.isOnline()) {\r\n                continue;\r\n            }\r\n            contact.setPresenceStatus(sipStatusEnum.getStatus(SipStatusEnum.OFFLINE));\r\n            fireContactPresenceStatusChangeEvent(contact, contact.getParentContactGroup(), oldContactStatus);\r\n        }\r\n        if (this.useDistantPA) {\r\n            try {\r\n                watcherInfoSubscriber.removeSubscription(parentProvider.getRegistrarConnection().getAddressOfRecord());\r\n            } catch (Throwable ex) {\r\n                logger.error(\"Failed to remove subscription \" + \"for watcher info.\", ex);\r\n            }\r\n        }\r\n        cancelTimer();\r\n        waitedCallIds.clear();\r\n        PresenceStatus oldStatus = this.presenceStatus;\r\n        this.presenceStatus = sipStatusEnum.getStatus(SipStatusEnum.OFFLINE);\r\n        this.fireProviderStatusChangeEvent(oldStatus);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.OperationSetPersistentPresenceIrcImpl.publishPresenceStatus",
	"Comment": "set a new presence status corresponding to the provided arguments.",
	"Method": "void publishPresenceStatus(PresenceStatus status,String statusMessage){\r\n    final IrcConnection connection = this.parentProvider.getIrcStack().getConnection();\r\n    String message = statusMessage;\r\n    if (connection == null) {\r\n        throw new IllegalStateException(\"Connection is not available.\");\r\n    }\r\n    if (message != null && message.isEmpty()) {\r\n        message = null;\r\n    }\r\n    if (status.getStatus() >= IrcStatusEnum.AVAILABLE_THRESHOLD) {\r\n        connection.getPresenceManager().away(false, message);\r\n    } else if (status.getStatus() >= IrcStatusEnum.AWAY_THRESHOLD) {\r\n        connection.getPresenceManager().away(true, message);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.UIServiceImpl.getMainFrame",
	"Comment": "returns the mainframe. this is the class defining the mainapplication window.",
	"Method": "MainFrame getMainFrame(){\r\n    return mainFrame;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatTransferHandler.importData",
	"Comment": "handles transfers to the chat panel from the clip board or adnd drop operation. the transferable parameter contains thedata that needs to be imported.",
	"Method": "boolean importData(JComponent comp,Transferable t){\r\n    if (t.isDataFlavorSupported(DataFlavor.javaFileListFlavor)) {\r\n        try {\r\n            Object o = t.getTransferData(DataFlavor.javaFileListFlavor);\r\n            if (o instanceof java.util.Collection) {\r\n                Collection<File> files = (Collection<File>) o;\r\n                for (File file : files) chatPanel.sendFile(file);\r\n                return true;\r\n            }\r\n        } catch (UnsupportedFlavorException e) {\r\n            if (logger.isDebugEnabled())\r\n                logger.debug(\"Failed to drop files.\", e);\r\n        } catch (IOException e) {\r\n            if (logger.isDebugEnabled())\r\n                logger.debug(\"Failed to drop files.\", e);\r\n        }\r\n    }\r\n    if (t.isDataFlavorSupported(uriListFlavor) && OSUtils.IS_LINUX) {\r\n        try {\r\n            Object o = t.getTransferData(uriListFlavor);\r\n            boolean dataProcessed = false;\r\n            StringTokenizer tokens = new StringTokenizer((String) o);\r\n            while (tokens.hasMoreTokens()) {\r\n                String urlString = tokens.nextToken();\r\n                URL url = new URL(urlString);\r\n                File file = new File(URLDecoder.decode(url.getFile(), \"UTF-8\"));\r\n                chatPanel.sendFile(file);\r\n                dataProcessed = true;\r\n            }\r\n            return dataProcessed;\r\n        } catch (UnsupportedFlavorException e) {\r\n            if (logger.isDebugEnabled())\r\n                logger.debug(\"Failed to drop files.\", e);\r\n        } catch (IOException e) {\r\n            if (logger.isDebugEnabled())\r\n                logger.debug(\"Failed to drop files.\", e);\r\n        }\r\n    }\r\n    if (t.isDataFlavorSupported(uiContactDataFlavor)) {\r\n        Object o = null;\r\n        try {\r\n            o = t.getTransferData(uiContactDataFlavor);\r\n        } catch (UnsupportedFlavorException e) {\r\n            if (logger.isDebugEnabled())\r\n                logger.debug(\"Failed to drop meta contact.\", e);\r\n        } catch (IOException e) {\r\n            if (logger.isDebugEnabled())\r\n                logger.debug(\"Failed to drop meta contact.\", e);\r\n        }\r\n        if (o instanceof ContactNode) {\r\n            UIContact uiContact = ((ContactNode) o).getContactDescriptor();\r\n            if (!(uiContact instanceof MetaUIContact))\r\n                return false;\r\n            ChatTransport currentChatTransport = chatPanel.getChatSession().getCurrentChatTransport();\r\n            Iterator<Contact> contacts = ((MetaContact) uiContact.getDescriptor()).getContactsForProvider(currentChatTransport.getProtocolProvider());\r\n            String contact = null;\r\n            if (contacts.hasNext())\r\n                contact = contacts.next().getAddress();\r\n            if (contact != null) {\r\n                List<String> inviteList = new ArrayList<String>();\r\n                inviteList.add(contact);\r\n                chatPanel.inviteContacts(currentChatTransport, inviteList, null);\r\n                return true;\r\n            } else\r\n                new ErrorDialog(null, GuiActivator.getResources().getI18NString(\"service.gui.ERROR\"), GuiActivator.getResources().getI18NString(\"service.gui.CONTACT_NOT_SUPPORTING_CHAT_CONF\", new String[] { uiContact.getDisplayName() })).showDialog();\r\n        }\r\n    }\r\n    if (t.isDataFlavorSupported(DataFlavor.stringFlavor)) {\r\n        InputContext inputContext = comp.getInputContext();\r\n        if (inputContext != null) {\r\n            inputContext.endComposition();\r\n        }\r\n        try {\r\n            BufferedReader reader = new BufferedReader(DataFlavor.stringFlavor.getReaderForText(t));\r\n            StringBuilder buffToPaste = new StringBuilder();\r\n            String line = reader.readLine();\r\n            while (line != null) {\r\n                buffToPaste.append(line);\r\n                line = reader.readLine();\r\n                if (line != null)\r\n                    buffToPaste.append(\"\\n\");\r\n            }\r\n            ((JTextComponent) comp).replaceSelection(buffToPaste.toString());\r\n            return true;\r\n        } catch (UnsupportedFlavorException ufe) {\r\n            if (logger.isDebugEnabled())\r\n                logger.debug(\"Failed to drop string.\", ufe);\r\n        } catch (IOException ioe) {\r\n            if (logger.isDebugEnabled())\r\n                logger.debug(\"Failed to drop string.\", ioe);\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.geolocation.GeolocationJabberUtils.convertMapToExtension",
	"Comment": "convert a geolocation details map to a geolocationpacketextension format",
	"Method": "GeolocationPacketExtension convertMapToExtension(Map<String, String> geolocation){\r\n    GeolocationPacketExtension geolocExt = new GeolocationPacketExtension();\r\n    Set<Entry<String, String>> entries = geolocation.entrySet();\r\n    Iterator<Entry<String, String>> itLine = entries.iterator();\r\n    while (itLine.hasNext()) {\r\n        Entry<String, String> line = itLine.next();\r\n        String curParam = line.getKey();\r\n        String curValue = line.getValue();\r\n        String prototype = Character.toUpperCase(curParam.charAt(0)) + curParam.substring(1);\r\n        String setterFunction = \"set\" + prototype;\r\n        try {\r\n            Method toCall = GeolocationPacketExtension.class.getMethod(setterFunction, String.class);\r\n            Object[] arguments = new Object[] { curValue };\r\n            try {\r\n                toCall.invoke(geolocExt, arguments);\r\n            } catch (IllegalArgumentException exc) {\r\n                logger.error(exc);\r\n            } catch (IllegalAccessException exc) {\r\n                logger.error(exc);\r\n            } catch (InvocationTargetException exc) {\r\n                logger.error(exc);\r\n            }\r\n        } catch (SecurityException exc) {\r\n            logger.error(exc);\r\n        } catch (NoSuchMethodException exc) {\r\n            logger.error(exc);\r\n        }\r\n    }\r\n    return geolocExt;\r\n}"
}, {
	"Path": "net.librec.recommender.context.rating.SoRegRecommender.predict",
	"Comment": "predict a specific rating for user useridx on item itemidx. it is useful for evalution which requires predictions arebounded.",
	"Method": "double predict(int userIdx,int itemIdx,boolean bound){\r\n    double predictRating = predict(userIdx, itemIdx);\r\n    if (bound) {\r\n        if (predictRating > maxRate) {\r\n            predictRating = maxRate;\r\n        } else if (predictRating < minRate) {\r\n            predictRating = minRate;\r\n        }\r\n    }\r\n    return predictRating;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.WhiteboardObjectDeletedEvent.getId",
	"Comment": "returns the identification of the deleted whiteboardobjectthat triggered this event",
	"Method": "String getId(){\r\n    return id;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.gui.event.MetaContactQuery.isCanceled",
	"Comment": "returns true if this query has been canceled, otherwise returnsfalse.",
	"Method": "boolean isCanceled(){\r\n    return isCanceled;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.account.EmptyAccountRegistrationWizardPage.getIdentifier",
	"Comment": "implements the wizardpage.getidentifier to return thispage identifier.",
	"Method": "Object getIdentifier(){\r\n    return FIRST_PAGE_IDENTIFIER;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.AbstractOperationSetVideoTelephony.isLocalVideoAllowed",
	"Comment": "determines whether the streaming of local video in a specificcall is currently allowed. the setting does not reflectthe availability of actual video capture devices, it just expresses thedesire of the user to have the local video streamed in the case thesystem is actually able to do so.",
	"Method": "boolean isLocalVideoAllowed(Call call){\r\n    return ((V) call).isLocalVideoAllowed(MediaUseCase.CALL);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.notification.NotificationAction.isEnabled",
	"Comment": "returns true if this notification action handler is enabled and falseotherwise. while the notification handler for the sound action type isdisabled no sounds will be played when the firenotificationmethod is called.",
	"Method": "boolean isEnabled(){\r\n    return isEnabled;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.AdHocConferenceChatSession.getHistoryBeforeDate",
	"Comment": "returns a collection of the last n number of messages given by count.",
	"Method": "Collection<Object> getHistoryBeforeDate(Date date,int count){\r\n    final MetaHistoryService metaHistory = GuiActivator.getMetaHistoryService();\r\n    if (metaHistory == null)\r\n        return null;\r\n    return metaHistory.findLastMessagesBefore(chatHistoryFilter, chatRoomWrapper.getAdHocChatRoom(), date, ConfigurationUtils.getChatHistorySize());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.IceUdpTransportManager.getICECandidateExtendedType",
	"Comment": "returns the extended type of the candidate selected if this transportmanager is using ice.",
	"Method": "String getICECandidateExtendedType(String streamName){\r\n    return TransportManager.getICECandidateExtendedType(iceAgent, streamName);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetTelephonyConferencingSipImpl.parseAddressString",
	"Comment": "parses a string value which represents a sip address into a sipaddress value.",
	"Method": "Address parseAddressString(String calleeAddressString){\r\n    try {\r\n        return parentProvider.parseAddressString(calleeAddressString);\r\n    } catch (ParseException pe) {\r\n        ProtocolProviderServiceSipImpl.throwOperationFailedException(\"Failed to parse callee address \" + calleeAddressString, OperationFailedException.ILLEGAL_ARGUMENT, pe, logger);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallManager.setVideoQualityPreset",
	"Comment": "sets the given quality preset for the video of the given call peer.",
	"Method": "void setVideoQualityPreset(CallPeer callPeer,QualityPreset qualityPreset){\r\n    ProtocolProviderService provider = callPeer.getProtocolProvider();\r\n    final OperationSetVideoTelephony videoOpSet = provider.getOperationSet(OperationSetVideoTelephony.class);\r\n    if (videoOpSet == null)\r\n        return;\r\n    final QualityControl qualityControl = videoOpSet.getQualityControl(callPeer);\r\n    if (qualityControl != null) {\r\n        new Thread(new Runnable() {\r\n            public void run() {\r\n                try {\r\n                    qualityControl.setPreferredRemoteSendMaxPreset(qualityPreset);\r\n                } catch (Exception e) {\r\n                    logger.info(\"Unable to change video quality.\", e);\r\n                    ResourceManagementService resources = GuiActivator.getResources();\r\n                    new ErrorDialog(null, resources.getI18NString(\"service.gui.WARNING\"), resources.getI18NString(\"service.gui.UNABLE_TO_CHANGE_VIDEO_QUALITY\"), e).showDialog();\r\n                }\r\n            }\r\n        }).start();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallManager.setVideoQualityPreset",
	"Comment": "sets the given quality preset for the video of the given call peer.",
	"Method": "void setVideoQualityPreset(CallPeer callPeer,QualityPreset qualityPreset){\r\n    try {\r\n        qualityControl.setPreferredRemoteSendMaxPreset(qualityPreset);\r\n    } catch (Exception e) {\r\n        logger.info(\"Unable to change video quality.\", e);\r\n        ResourceManagementService resources = GuiActivator.getResources();\r\n        new ErrorDialog(null, resources.getI18NString(\"service.gui.WARNING\"), resources.getI18NString(\"service.gui.UNABLE_TO_CHANGE_VIDEO_QUALITY\"), e).showDialog();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.JabberAccountRegistrationForm.addValidatingPanel",
	"Comment": "adds panel to the list of panels with values which need validation.",
	"Method": "void addValidatingPanel(ValidatingPanel panel){\r\n    validatingPanels.add(panel);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl.createMediaDescriptionsForAnswer",
	"Comment": "creates a number of mediadescriptions answering the descriptionsoffered by the specified offer and reflecting the state of thismediahandler.",
	"Method": "Vector<MediaDescription> createMediaDescriptionsForAnswer(SessionDescription offer){\r\n    List<MediaDescription> remoteDescriptions = SdpUtils.extractMediaDescriptions(offer);\r\n    Vector<MediaDescription> answerDescriptions = new Vector<MediaDescription>(remoteDescriptions.size());\r\n    this.setCallInfoURL(SdpUtils.getCallInfoURL(offer));\r\n    boolean atLeastOneValidDescription = false;\r\n    boolean rejectedAvpOfferDueToSavpMandatory = false;\r\n    AccountID accountID = getPeer().getProtocolProvider().getAccountID();\r\n    boolean useDefaultEncryption = accountID.getAccountPropertyBoolean(ProtocolProviderFactory.DEFAULT_ENCRYPTION, true);\r\n    int savpOption = useDefaultEncryption ? accountID.getAccountPropertyInt(ProtocolProviderFactory.SAVP_OPTION, ProtocolProviderFactory.SAVP_OFF) : ProtocolProviderFactory.SAVP_OFF;\r\n    boolean masterStreamSet = false;\r\n    List<MediaType> seenMediaTypes = new ArrayList<MediaType>();\r\n    for (MediaDescription mediaDescription : remoteDescriptions) {\r\n        String proto;\r\n        try {\r\n            proto = mediaDescription.getMedia().getProtocol();\r\n        } catch (SdpParseException e) {\r\n            throw new OperationFailedException(\"Unable to create the media description\", OperationFailedException.ILLEGAL_ARGUMENT, e);\r\n        }\r\n        if ((savpOption == ProtocolProviderFactory.SAVP_MANDATORY) && !(proto.endsWith(SrtpControl.RTP_SAVP) || proto.endsWith(SrtpControl.RTP_SAVPF))) {\r\n            rejectedAvpOfferDueToSavpMandatory = true;\r\n            answerDescriptions.add(SdpUtils.createDisablingAnswer(mediaDescription));\r\n            continue;\r\n        }\r\n        MediaType mediaType = null;\r\n        try {\r\n            mediaType = SdpUtils.getMediaType(mediaDescription);\r\n            if (seenMediaTypes.contains(mediaType))\r\n                continue;\r\n            seenMediaTypes.add(mediaType);\r\n        } catch (IllegalArgumentException iae) {\r\n            answerDescriptions.add(SdpUtils.createDisablingAnswer(mediaDescription));\r\n            continue;\r\n        }\r\n        List<MediaFormat> remoteFormats = SdpUtils.extractFormats(mediaDescription, getDynamicPayloadTypes());\r\n        MediaDevice dev = getDefaultDevice(mediaType);\r\n        MediaDirection devDirection = (dev == null) ? MediaDirection.INACTIVE : dev.getDirection();\r\n        devDirection = devDirection.and(getDirectionUserPreference(mediaType));\r\n        MediaDirection remoteDirection = SdpUtils.getDirection(mediaDescription);\r\n        MediaDirection direction = devDirection.getDirectionForAnswer(remoteDirection);\r\n        List<MediaFormat> mutuallySupportedFormats;\r\n        if (dev == null) {\r\n            mutuallySupportedFormats = null;\r\n        } else if (MediaType.VIDEO.equals(mediaType) && (qualityControls != null)) {\r\n            QualityPreset sendQualityPreset = direction.allowsSending() ? qualityControls.getRemoteReceivePreset() : null;\r\n            QualityPreset receiveQualityPreset = qualityControls.getRemoteSendMaxPreset();\r\n            mutuallySupportedFormats = intersectFormats(remoteFormats, getLocallySupportedFormats(dev, sendQualityPreset, receiveQualityPreset));\r\n        } else {\r\n            mutuallySupportedFormats = intersectFormats(remoteFormats, getLocallySupportedFormats(dev));\r\n        }\r\n        MediaStreamTarget target = SdpUtils.extractDefaultTarget(mediaDescription, offer);\r\n        int targetDataPort = target.getDataAddress().getPort();\r\n        if ((devDirection == MediaDirection.INACTIVE) || (mutuallySupportedFormats == null) || mutuallySupportedFormats.isEmpty() || (targetDataPort == 0)) {\r\n            answerDescriptions.add(SdpUtils.createDisablingAnswer(mediaDescription));\r\n            closeStream(mediaType);\r\n            continue;\r\n        }\r\n        List<RTPExtension> offeredRTPExtensions = SdpUtils.extractRTPExtensions(mediaDescription, this.getRtpExtensionsRegistry());\r\n        List<RTPExtension> supportedExtensions = getExtensionsForType(mediaType);\r\n        List<RTPExtension> rtpExtensions = intersectRTPExtensions(offeredRTPExtensions, supportedExtensions);\r\n        StreamConnector connector = getTransportManager().getStreamConnector(mediaType);\r\n        if (MediaType.VIDEO.equals(mediaType)) {\r\n            MediaStream stream = getStream(MediaType.VIDEO);\r\n            if (stream != null) {\r\n                List<MediaFormat> fmts = intersectFormats(getLocallySupportedFormats(dev), remoteFormats);\r\n                if (!fmts.isEmpty()) {\r\n                    MediaFormat fmt = fmts.get(0);\r\n                    ((VideoMediaStream) stream).updateQualityControl(fmt.getAdvancedAttributes());\r\n                }\r\n            }\r\n            supportQualityControls = SdpUtils.containsAttribute(mediaDescription, \"imageattr\");\r\n            float frameRate = -1;\r\n            try {\r\n                String frStr = mediaDescription.getAttribute(\"framerate\");\r\n                if (frStr != null)\r\n                    frameRate = Integer.parseInt(frStr);\r\n            } catch (SdpParseException e) {\r\n            }\r\n            if (frameRate > 0)\r\n                qualityControls.setMaxFrameRate(frameRate);\r\n        }\r\n        MediaDescription md = createMediaDescription(proto, mutuallySupportedFormats, connector, direction, rtpExtensions);\r\n        setAndAddPreferredEncryptionProtocol(mediaType, md, mediaDescription);\r\n        String rtcpxr;\r\n        try {\r\n            rtcpxr = mediaDescription.getAttribute(RTCPExtendedReport.SDP_ATTRIBUTE);\r\n            if (rtcpxr != null) {\r\n                if (rtcpxr.contains(RTCPExtendedReport.VoIPMetricsReportBlock.SDP_PARAMETER)) {\r\n                    rtcpxr = RTCPExtendedReport.VoIPMetricsReportBlock.SDP_PARAMETER;\r\n                } else {\r\n                    rtcpxr = \"\";\r\n                }\r\n                md.setAttribute(RTCPExtendedReport.SDP_ATTRIBUTE, rtcpxr);\r\n            }\r\n        } catch (SdpException se) {\r\n            rtcpxr = null;\r\n        }\r\n        MediaFormat fmt = findMediaFormat(remoteFormats, mutuallySupportedFormats.get(0));\r\n        boolean masterStream = false;\r\n        if (!masterStreamSet) {\r\n            if (remoteDescriptions.size() > 1) {\r\n                if (MediaType.AUDIO.equals(mediaType)) {\r\n                    masterStream = true;\r\n                    masterStreamSet = true;\r\n                }\r\n            } else {\r\n                masterStream = true;\r\n                masterStreamSet = true;\r\n            }\r\n        }\r\n        MediaStream stream = initStream(connector, dev, fmt, target, direction, rtpExtensions, masterStream);\r\n        if (stream != null)\r\n            stream.setProperty(RTCPExtendedReport.SDP_ATTRIBUTE, rtcpxr);\r\n        answerDescriptions.add(md);\r\n        atLeastOneValidDescription = true;\r\n    }\r\n    if (!atLeastOneValidDescription) {\r\n        if (rejectedAvpOfferDueToSavpMandatory) {\r\n            throw new OperationFailedException(\"Offer contained no valid media descriptions. Insecure\" + \" media was rejected (only RTP/AVP instead of\" + \" RTP/SAVP).\", OperationFailedException.ILLEGAL_ARGUMENT);\r\n        } else {\r\n            throw new OperationFailedException(\"Offer contained no valid media descriptions.\", OperationFailedException.ILLEGAL_ARGUMENT);\r\n        }\r\n    }\r\n    return answerDescriptions;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.login.LoginRendererSwingImpl.addProtocolProviderUI",
	"Comment": "adds the user interface related to the given protocol provider.",
	"Method": "void addProtocolProviderUI(ProtocolProviderService protocolProvider){\r\n    GuiActivator.getUIService().getMainFrame().addProtocolProvider(protocolProvider);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.busylampfield.CustomActionsBLFSourceContact.getContactSourceClass",
	"Comment": "returns the template class that this service has been initialized with",
	"Method": "Class<SourceContact> getContactSourceClass(){\r\n    return SourceContact.class;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.FileHandler.getLimit",
	"Comment": "returns the limit size for one log file or default 0, whichis unlimited.",
	"Method": "int getLimit(){\r\n    if (limit == -1) {\r\n        String limitStr = LogManager.getLogManager().getProperty(FileHandler.class.getName() + \".limit\");\r\n        limit = 0;\r\n        try {\r\n            limit = Integer.parseInt(limitStr);\r\n        } catch (Exception ex) {\r\n        }\r\n    }\r\n    return limit;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.conference.ConferenceFocusPanel.isLocalVideoVisible",
	"Comment": "indicates if the local video component is currently visible.",
	"Method": "boolean isLocalVideoVisible(){\r\n    return focusPeerPanel.isLocalVideoVisible();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractOperationSetBasicAutoAnswer.setAutoAnswerUnconditional",
	"Comment": "sets the auto answer option to unconditionally answer all incoming calls.",
	"Method": "void setAutoAnswerUnconditional(){\r\n    clearLocal();\r\n    this.answerUnconditional = true;\r\n    save();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.OperationSetPersistentPresenceGibberishImpl.findContactsPointingToUs",
	"Comment": "looks for gibberish protocol providers that have added us to theircontact list and returns list of all contacts representing us in theseproviders.",
	"Method": "List<Contact> findContactsPointingToUs(){\r\n    List<Contact> contacts = new LinkedList<Contact>();\r\n    BundleContext bc = GibberishActivator.getBundleContext();\r\n    String osgiQuery = \"(\" + ProtocolProviderFactory.PROTOCOL + \"=Gibberish)\";\r\n    ServiceReference[] refs = null;\r\n    try {\r\n        refs = bc.getServiceReferences(ProtocolProviderService.class.getName(), osgiQuery);\r\n    } catch (InvalidSyntaxException ex) {\r\n        logger.error(\"Failed to execute the following osgi query: \" + osgiQuery, ex);\r\n    }\r\n    for (int i = 0; refs != null && i < refs.length; i++) {\r\n        ProtocolProviderServiceGibberishImpl gibProvider = (ProtocolProviderServiceGibberishImpl) bc.getService(refs[i]);\r\n        OperationSetPersistentPresenceGibberishImpl opSetPersPresence = (OperationSetPersistentPresenceGibberishImpl) gibProvider.getOperationSet(OperationSetPersistentPresence.class);\r\n        Contact contact = opSetPersPresence.findContactByID(parentProvider.getAccountID().getUserID());\r\n        if (contact != null)\r\n            contacts.add(contact);\r\n    }\r\n    return contacts;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactListServiceImpl.getMetaContactListListeners",
	"Comment": "gets a copy of the list of current metacontactlistlistenerinterested in events fired by this instance.",
	"Method": "MetaContactListListener[] getMetaContactListListeners(){\r\n    MetaContactListListener[] listeners;\r\n    synchronized (metaContactListListeners) {\r\n        listeners = metaContactListListeners.toArray(new MetaContactListListener[metaContactListListeners.size()]);\r\n    }\r\n    return listeners;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.processHistoryMessage",
	"Comment": "passes the message to the contained chatconversationpanelfor processing.",
	"Method": "String processHistoryMessage(String contactName,String contactDisplayName,Date date,String messageType,String message,String contentType,String messageId){\r\n    ChatMessage chatMessage = new ChatMessage(contactName, contactDisplayName, date, messageType, null, message, contentType, messageId, null);\r\n    String processedMessage = this.conversationPanel.processMessage(chatMessage, chatSession.getCurrentChatTransport().getProtocolProvider(), chatSession.getCurrentChatTransport().getName());\r\n    if (chatSession instanceof ConferenceChatSession) {\r\n        String tempMessage = conversationPanel.processMeCommand(chatMessage);\r\n        if (tempMessage.length() > 0)\r\n            processedMessage = tempMessage;\r\n    }\r\n    return processedMessage;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.sipaccregwizz.ConnectionPanel.setServerFieldAccordingToUIN",
	"Comment": "parse the server part from the sip id and set it to server as defaultvalue. if advanced option is enabled do nothing.",
	"Method": "void setServerFieldAccordingToUIN(String serverAddress){\r\n    if (!regform.isModification() || !isServerOverridden) {\r\n        serverField.setText(serverAddress);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomMemberIrcImpl.getProtocolProvider",
	"Comment": "returns the protocol provider instance that this member has originatedin.",
	"Method": "ProtocolProviderService getProtocolProvider(){\r\n    return this.parentProvider;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.presence.GlobalStatusMessageMenu.publishStatusMessage",
	"Comment": "publishes the new message in separate thread. if successfully endedthe message item is created and added to te list of current statusmessages and if needed the message is saved.",
	"Method": "void publishStatusMessage(String message,Object menuItem,boolean saveIfNewMessage){\r\n    new PublishStatusMessageThread(message, menuItem, saveIfNewMessage).start();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.ContactCapabilitiesEvent.getEventID",
	"Comment": "gets the id of this event which indicates the specifics of the change inthe list of operationset capabilities of the associatedsourcecontact and the details it carries.",
	"Method": "int getEventID(){\r\n    return eventID;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetPersistentPresenceJabberImpl.addDefaultValue",
	"Comment": "checks for account property that can override this status.if missing use the shift value to create the priority to use, make sureit is not zero or less than it.",
	"Method": "void addDefaultValue(String statusName,int availableShift){\r\n    String resourcePriority = getAccountPriorityForStatus(statusName);\r\n    if (resourcePriority != null) {\r\n        try {\r\n            addPresenceToPriorityMapping(statusName, Integer.parseInt(resourcePriority));\r\n        } catch (NumberFormatException ex) {\r\n            logger.error(\"Wrong value for resource priority for status: \" + statusName, ex);\r\n        }\r\n    } else {\r\n        int priority = resourcePriorityAvailable + availableShift;\r\n        if (priority <= 0)\r\n            priority = resourcePriorityAvailable;\r\n        addPresenceToPriorityMapping(statusName, priority);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.UINotificationManager.fireNotificationEvent",
	"Comment": "notifies interested uinotificationlistener that a newnotification has been received.",
	"Method": "void fireNotificationEvent(UINotification notification){\r\n    synchronized (notificationListeners) {\r\n        Iterator<UINotificationListener> listeners = notificationListeners.iterator();\r\n        while (listeners.hasNext()) listeners.next().notificationReceived(notification);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.ExtendedTransferHandler.canImport",
	"Comment": "indicates whether a component will accept an import of the givenset of data flavors prior to actually attempting to import it. we returntrue to indicate that the transfer with at least one of thegiven flavors would work and false to reject the transfer.",
	"Method": "boolean canImport(JComponent comp,DataFlavor flavor){\r\n    for (int i = 0, n = flavor.length; i < n; i++) {\r\n        if (flavor[i].equals(DataFlavor.javaFileListFlavor)) {\r\n            return true;\r\n        } else if (flavor[i].equals(DataFlavor.stringFlavor)) {\r\n            if (comp instanceof JTextComponent) {\r\n                JTextComponent c = (JTextComponent) comp;\r\n                if (c.isEditable() && c.isEnabled()) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatConversationPanel.copyConversation",
	"Comment": "copies the selected conversation panel content to the clipboard.",
	"Method": "void copyConversation(){\r\n    this.chatTextPane.copy();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.ChatRoomListImpl.fireChatRoomListChangedEvent",
	"Comment": "notifies all interested listeners that a change in the chat room listmodel has occurred.",
	"Method": "void fireChatRoomListChangedEvent(ChatRoomWrapper chatRoomWrapper,int eventID){\r\n    ChatRoomListChangeEvent evt = new ChatRoomListChangeEvent(chatRoomWrapper, eventID);\r\n    for (ChatRoomListChangeListener l : listChangeListeners) {\r\n        l.contentChanged(evt);\r\n    }\r\n}"
}, {
	"Path": "net.librec.recommender.cf.rating.LLORMARecommender.getItemSimilarity",
	"Comment": "calculate similarity between two items, based on the global base svd.",
	"Method": "double getItemSimilarity(int itemIdx1,int itemIdx2){\r\n    double sim;\r\n    DenseVector itemVector1 = globalItemFactors.row(itemIdx1);\r\n    DenseVector itemVector2 = globalItemFactors.row(itemIdx2);\r\n    sim = 1 - 2.0 / Math.PI * Math.acos(itemVector1.dot(itemVector2) / (Math.sqrt(itemVector1.dot(itemVector1)) * Math.sqrt(itemVector2.dot(itemVector2))));\r\n    if (Double.isNaN(sim)) {\r\n        sim = 0.0;\r\n    }\r\n    return sim;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.IceConfigPanel.isAutoDiscoverJingleNodes",
	"Comment": "indicates if the jingle nodes relays should be automatically discovered.",
	"Method": "boolean isAutoDiscoverJingleNodes(){\r\n    return jnAutoDiscoverBox.isSelected();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.CallConference.removeCallChangeListener",
	"Comment": "removes a callchangelistener from the callsparticipating in this telephony conference.",
	"Method": "void removeCallChangeListener(CallChangeListener listener){\r\n    if (listener != null) {\r\n        synchronized (callChangeListeners) {\r\n            callChangeListeners.remove(listener);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.UtilActivator.getFileAccessService",
	"Comment": "returns the fileaccessservice obtained from the bundle context.",
	"Method": "FileAccessService getFileAccessService(){\r\n    if (fileAccessService == null) {\r\n        fileAccessService = ServiceUtils.getService(bundleContext, FileAccessService.class);\r\n    }\r\n    return fileAccessService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallPanel.getDialpadDialog",
	"Comment": "returns the dialpaddialog corresponding to this calldialog.",
	"Method": "DialpadDialog getDialpadDialog(){\r\n    return new DialpadDialog(dtmfHandler);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.contactlist.TestMetaContactGroup.testCountSubgroups",
	"Comment": "verifies whehter the returned number of subgroups corresponds to thesubgroups of the corresponding mock contact group.",
	"Method": "void testCountSubgroups(){\r\n    assertEquals(\"MetaContactGroup.countChildContacts failed\", metaGroup.countSubgroups(), mockGroup.countSubgroups());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.DefaultTreeContactList.isContactActive",
	"Comment": "checks if the given contact is currently active.dummy method used and overridden from classes extending thisfunctionality such as contactlist.",
	"Method": "boolean isContactActive(UIContact contact,boolean isContactActive,MetaContact metaContact){\r\n    UIContact uiContact;\r\n    synchronized (metaContact) {\r\n        uiContact = MetaContactListSource.getUIContact(metaContact);\r\n    }\r\n    if (uiContact != null)\r\n        return isContactActive(uiContact);\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomConfigurationFormFieldJabberImpl.getDescription",
	"Comment": "returns the description of the corresponding smack property.",
	"Method": "String getDescription(){\r\n    return smackFormField.getDescription();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatConversationPanel.setDefaultContent",
	"Comment": "sets the default document contained in this panel, created on init orwhen clear is invoked.",
	"Method": "void setDefaultContent(){\r\n    setContent(document);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.ProtocolProviderFactoryGibberishImpl.installAccount",
	"Comment": "initialized and creates an account corresponding to the specifiedaccountproperties and registers the resulting protocolprovider in thecontext bundlecontext parameter.",
	"Method": "AccountID installAccount(String userIDStr,Map<String, String> accountProperties){\r\n    BundleContext context = GibberishActivator.getBundleContext();\r\n    if (context == null)\r\n        throw new NullPointerException(\"The specified BundleContext was null\");\r\n    if (userIDStr == null)\r\n        throw new NullPointerException(\"The specified AccountID was null\");\r\n    if (accountProperties == null)\r\n        throw new NullPointerException(\"The specified property map was null\");\r\n    accountProperties.put(USER_ID, userIDStr);\r\n    AccountID accountID = new GibberishAccountID(userIDStr, accountProperties);\r\n    if (registeredAccounts.containsKey(accountID))\r\n        throw new IllegalStateException(\"An account for id \" + userIDStr + \" was already installed!\");\r\n    this.storeAccount(accountID, false);\r\n    accountID = loadAccount(accountProperties);\r\n    return accountID;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.configuration.TestConfigurationService.testMulticastEventNotificationToVetoableListeners",
	"Comment": "test event dispatch to vetoable listeners registered for the wholeconfiguration.",
	"Method": "void testMulticastEventNotificationToVetoableListeners(){\r\n    String propertyValue = \"19200\";\r\n    String propertyNewValue = \"19201\";\r\n    propertyChangeEvent = null;\r\n    configurationService.addVetoableChangeListener(gentleVetoListener);\r\n    try {\r\n        configurationService.setProperty(propertyName, propertyValue);\r\n    } catch (ConfigPropertyVetoException ex) {\r\n        fail(\"A PropertyVetoException came from nowhere. Exc=\" + ex.getMessage());\r\n    }\r\n    assertNotNull(\"No PropertyChangeEvent was delivered \" + \"to VetoableListeners upon setProperty\", propertyChangeEvent);\r\n    assertNull(\"oldValue must be null\", propertyChangeEvent.getOldValue());\r\n    assertEquals(\"newValue is not the value we just set!\", propertyValue, propertyChangeEvent.getNewValue());\r\n    assertEquals(\"propertyName is not the value we just set!\", propertyName, propertyChangeEvent.getPropertyName());\r\n    propertyChangeEvent = null;\r\n    try {\r\n        configurationService.setProperty(propertyName, propertyNewValue);\r\n    } catch (ConfigPropertyVetoException ex) {\r\n        fail(\"A PropertyVetoException came from nowhere. Exc=\" + ex.getMessage());\r\n    }\r\n    assertNotNull(\"No PropertyChangeEvent was delivered to veto listener \" + \"upon setProperty\", propertyChangeEvent);\r\n    assertEquals(\"incorrect oldValue\", propertyValue, propertyChangeEvent.getOldValue());\r\n    assertEquals(\"newValue is not the value we just set!\", propertyNewValue, propertyChangeEvent.getNewValue());\r\n    propertyChangeEvent = null;\r\n    configurationService.removeVetoableChangeListener(gentleVetoListener);\r\n    try {\r\n        configurationService.setProperty(propertyName, propertyValue);\r\n    } catch (ConfigPropertyVetoException ex) {\r\n        fail(\"A PropertyVetoException came from nowhere. Exc=\" + ex.getMessage());\r\n    }\r\n    assertNull(\"A PropertyChangeEvent after unregistering a listener.\", propertyChangeEvent);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ContactListPane.typingNotificationReceived",
	"Comment": "informs the user what is the typing state of his chat contacts.",
	"Method": "void typingNotificationReceived(TypingNotificationEvent evt){\r\n    if (typingTimer.isRunning())\r\n        typingTimer.stop();\r\n    String notificationMsg = \"\";\r\n    MetaContact metaContact = GuiActivator.getContactListService().findMetaContactByContact(evt.getSourceContact());\r\n    String contactName = metaContact.getDisplayName() + \" \";\r\n    if (contactName.equals(\"\")) {\r\n        contactName = GuiActivator.getResources().getI18NString(\"service.gui.UNKNOWN\") + \" \";\r\n    }\r\n    int typingState = evt.getTypingState();\r\n    ChatPanel chatPanel = chatWindowManager.getContactChat(metaContact, false);\r\n    if (typingState == OperationSetTypingNotifications.STATE_TYPING) {\r\n        notificationMsg = GuiActivator.getResources().getI18NString(\"service.gui.CONTACT_TYPING\", new String[] { contactName });\r\n        if (!chatWindowManager.isChatOpenedFor(metaContact)) {\r\n            return;\r\n        }\r\n        if (chatPanel != null)\r\n            chatPanel.addTypingNotification(notificationMsg);\r\n        typingTimer.setMetaContact(metaContact);\r\n        typingTimer.start();\r\n    } else if (typingState == OperationSetTypingNotifications.STATE_PAUSED) {\r\n        notificationMsg = GuiActivator.getResources().getI18NString(\"service.gui.CONTACT_PAUSED_TYPING\", new String[] { contactName });\r\n        if (chatPanel != null)\r\n            chatPanel.addTypingNotification(notificationMsg);\r\n        typingTimer.setMetaContact(metaContact);\r\n        typingTimer.start();\r\n    } else {\r\n        if (chatPanel != null)\r\n            chatPanel.removeTypingNotification();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetDesktopSharingClientJabberImpl.processPacket",
	"Comment": "handles incoming inputevt packets and passes them to the correspondingmethod based on their action.",
	"Method": "void processPacket(Packet packet){\r\n    InputEvtIQ inputIQ = (InputEvtIQ) packet;\r\n    if (inputIQ.getType() == IQ.Type.SET && inputIQ.getAction() != InputEvtAction.NOTIFY) {\r\n        IQ ack = IQ.createResultIQ(inputIQ);\r\n        parentProvider.getConnection().sendPacket(ack);\r\n        String callPeerID = inputIQ.getFrom();\r\n        if (callPeerID != null) {\r\n            CallPeer callPeer = getListenerCallPeer(callPeerID);\r\n            if (callPeer != null) {\r\n                if (inputIQ.getAction() == InputEvtAction.START) {\r\n                    fireRemoteControlGranted(callPeer);\r\n                } else if (inputIQ.getAction() == InputEvtAction.STOP) {\r\n                    fireRemoteControlRevoked(callPeer);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.InputVolumeControlButton.buttonPressed",
	"Comment": "notifies this abstractcalltogglebutton that its associatedaction has been performed and that it should execute its very logic.",
	"Method": "void buttonPressed(){\r\n    if (!sliderMenuIsVisible)\r\n        toggleMute();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.MessageIrcImpl.newMessageFromIRC",
	"Comment": "create a message instance from a piece of text directly from irc. thistext might contain control characters for formatting as well as htmlentities that have yet to be escaped.the irc message is parsed, control codes replaced with html tags and htmlentities in the original message are escaped.",
	"Method": "MessageIrcImpl newMessageFromIRC(String message){\r\n    String text = Utils.parseIrcMessage(message);\r\n    text = Utils.styleAsMessage(text);\r\n    return new MessageIrcImpl(text, HTML_MIME_TYPE, DEFAULT_MIME_ENCODING, null);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SoundLevelIndicator.updateSoundLevelInternal",
	"Comment": "update the sound level indicator component to fit the given values.",
	"Method": "void updateSoundLevelInternal(int soundLevel){\r\n    int range = 1;\r\n    if ((minSoundLevel > -1) && (maxSoundLevel > -1) && (minSoundLevel < maxSoundLevel)) {\r\n        range = maxSoundLevel - minSoundLevel;\r\n        if (soundLevel < 40)\r\n            soundLevel = minSoundLevel;\r\n        else if (soundLevel > 85)\r\n            soundLevel = maxSoundLevel;\r\n        else {\r\n            soundLevel = (int) (((soundLevel - 40.0) / 45.0) * range);\r\n            if (soundLevel < minSoundLevel)\r\n                soundLevel = minSoundLevel;\r\n            else if (soundLevel > maxSoundLevel)\r\n                soundLevel = maxSoundLevel;\r\n        }\r\n    }\r\n    this.soundLevel = (int) (this.soundLevel * 0.8 + soundLevel * 0.2);\r\n    int activeSoundBarCount = Math.round(this.soundLevel * soundBarCount / (float) range);\r\n    Component[] components = getComponents();\r\n    for (int i = 0; i < components.length; i++) {\r\n        Component c = getComponent(i);\r\n        if (c instanceof JLabel) {\r\n            Icon activeIcon = null;\r\n            Icon inactiveIcon = null;\r\n            if (i == 0) {\r\n                if (activeSoundBarCount == 1)\r\n                    activeIcon = soundLevelActiveImageLeftGradient;\r\n                else {\r\n                    activeIcon = soundLevelActiveImageLeft;\r\n                    inactiveIcon = soundLevelInactiveImageLeft;\r\n                }\r\n            } else if (i == activeSoundBarCount - 1) {\r\n                if (i == components.length - 1)\r\n                    activeIcon = soundLevelActiveImageRight;\r\n                else\r\n                    activeIcon = soundLevelActiveImageRightGradient;\r\n            } else if (i == components.length - 1) {\r\n                inactiveIcon = soundLevelInactiveImageRight;\r\n            } else {\r\n                activeIcon = soundLevelActiveImageMiddle;\r\n                inactiveIcon = soundLevelInactiveImageMiddle;\r\n            }\r\n            ((JLabel) c).setIcon((i < activeSoundBarCount) ? activeIcon : inactiveIcon);\r\n        }\r\n    }\r\n    repaint();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.SubscriptionMovedEvent.getOldParentGroup",
	"Comment": "returns a reference to the contactgroup that contained the source contactbefore it was moved.",
	"Method": "ContactGroup getOldParentGroup(){\r\n    return oldParent;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.AdHocChatRoomInvitationReceivedEvent.getTimestamp",
	"Comment": "a timestamp indicating the exact date when the event ocurred.",
	"Method": "Date getTimestamp(){\r\n    return timestamp;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactListServiceImpl.isContactInEventIgnoreList",
	"Comment": "verifies whether the specified contact is in the contact event ignorelist.",
	"Method": "boolean isContactInEventIgnoreList(String contact,ProtocolProviderService ownerProvider,boolean isContactInEventIgnoreList,Contact contact,ProtocolProviderService ownerProvider){\r\n    for (Map.Entry<String, List<ProtocolProviderService>> contactEventIgnoreEntry : contactEventIgnoreList.entrySet()) {\r\n        String contactAddress = contactEventIgnoreEntry.getKey();\r\n        if (contact.getAddress().equals(contactAddress) || contact.equals(contactAddress)) {\r\n            List<ProtocolProviderService> existingProvList = contactEventIgnoreEntry.getValue();\r\n            return existingProvList != null && existingProvList.contains(ownerProvider);\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.globaldisplaydetails.GlobalDisplayDetailsImpl.registrationStateChanged",
	"Comment": "updates account information when a protocol provider is registered.",
	"Method": "void registrationStateChanged(RegistrationStateChangeEvent evt){\r\n    ProtocolProviderService protocolProvider = evt.getProvider();\r\n    if (evt.getNewState().equals(RegistrationState.REGISTERED)) {\r\n        OperationSetServerStoredAccountInfo accountInfoOpSet = protocolProvider.getOperationSet(OperationSetServerStoredAccountInfo.class);\r\n        if (accountInfoOpSet != null) {\r\n            new UpdateAccountInfo(protocolProvider, accountInfoOpSet, false).start();\r\n        }\r\n        OperationSetAvatar avatarOpSet = protocolProvider.getOperationSet(OperationSetAvatar.class);\r\n        if (avatarOpSet != null)\r\n            avatarOpSet.addAvatarListener(this);\r\n        OperationSetServerStoredAccountInfo serverStoredAccountInfo = protocolProvider.getOperationSet(OperationSetServerStoredAccountInfo.class);\r\n        if (serverStoredAccountInfo != null)\r\n            serverStoredAccountInfo.addServerStoredDetailsChangeListener(this);\r\n    } else if (evt.getNewState().equals(RegistrationState.UNREGISTERING) || evt.getNewState().equals(RegistrationState.CONNECTION_FAILED)) {\r\n        OperationSetAvatar avatarOpSet = protocolProvider.getOperationSet(OperationSetAvatar.class);\r\n        if (avatarOpSet != null)\r\n            avatarOpSet.removeAvatarListener(this);\r\n        OperationSetServerStoredAccountInfo serverStoredAccountInfo = protocolProvider.getOperationSet(OperationSetServerStoredAccountInfo.class);\r\n        if (serverStoredAccountInfo != null)\r\n            serverStoredAccountInfo.removeServerStoredDetailsChangeListener(this);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.ConferenceInfoDocument.addNewUser",
	"Comment": "creates a new user instance, adds it to the document andreturns it.",
	"Method": "User addNewUser(String entity){\r\n    Element userElement = document.createElement(USER_ELEMENT_NAME);\r\n    User user = new User(userElement);\r\n    user.setEntity(entity);\r\n    users.appendChild(userElement);\r\n    usersList.add(user);\r\n    return user;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ServerStoredContactListXivoImpl.createContact",
	"Comment": "creates contact for the specified address and inside thespecified group . if creation is successful event will be fired.",
	"Method": "ContactSipImpl createContact(ContactGroupSipImpl parentGroup,String contactId,String displayName,boolean persistent,String contactType){\r\n    throw new OperationFailedException(\"Modification not supported.\", OperationFailedException.NOT_SUPPORTED_OPERATION);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.DialPanel.mousePressed",
	"Comment": "handles the mouseevent triggered when user presses one of thedial buttons.",
	"Method": "void mousePressed(MouseEvent ev){\r\n    dtmfHandler.startSendingDtmfTone(ev.getComponent().getName());\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.UtilActivator.getProtocolProviderFactories",
	"Comment": "returns all protocolproviderfactorys obtained from the bundlecontext.",
	"Method": "Map<Object, ProtocolProviderFactory> getProtocolProviderFactories(){\r\n    Collection<ServiceReference<ProtocolProviderFactory>> serRefs;\r\n    Map<Object, ProtocolProviderFactory> providerFactoriesMap = new Hashtable<Object, ProtocolProviderFactory>();\r\n    try {\r\n        serRefs = bundleContext.getServiceReferences(ProtocolProviderFactory.class, null);\r\n    } catch (InvalidSyntaxException ex) {\r\n        serRefs = null;\r\n        logger.error(\"LoginManager : \" + ex);\r\n    }\r\n    if ((serRefs != null) && !serRefs.isEmpty()) {\r\n        for (ServiceReference<ProtocolProviderFactory> serRef : serRefs) {\r\n            ProtocolProviderFactory providerFactory = bundleContext.getService(serRef);\r\n            providerFactoriesMap.put(serRef.getProperty(ProtocolProviderFactory.PROTOCOL), providerFactory);\r\n        }\r\n    }\r\n    return providerFactoriesMap;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.loggingutils.LoggingConfigForm.getUploadLocation",
	"Comment": "checks the property in configuration service and if missing there get itfrom default settings.",
	"Method": "String getUploadLocation(){\r\n    String uploadLocation = LoggingUtilsActivator.getConfigurationService().getString(UPLOAD_LOCATION_PROPETY);\r\n    if (uploadLocation == null || uploadLocation.length() == 0) {\r\n        uploadLocation = LoggingUtilsActivator.getResourceService().getSettingsString(UPLOAD_LOCATION_PROPETY);\r\n    }\r\n    return uploadLocation;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockPersistentPresenceOperationSet.createUnresolvedContactGroup",
	"Comment": "creates and returns a unresolved contact group from the specifiedaddress and persistentdata. the method will not tryto establish a network connection and resolve the newly createdcontactgroup against the server or the contact itself. theprotocol provider will later resolve the contact group. when this happensthe corresponding event would notify interested subscription listeners.",
	"Method": "ContactGroup createUnresolvedContactGroup(String groupUID,String persistentData,ContactGroup parentGroup){\r\n    MockContactGroup newGroup = new MockContactGroup(MockContactGroup.createNameFromUID(groupUID), parentProvider);\r\n    newGroup.setResolved(false);\r\n    if (parentGroup == null)\r\n        parentGroup = getServerStoredContactListRoot();\r\n    ((MockContactGroup) parentGroup).addSubgroup(newGroup);\r\n    this.fireServerStoredGroupEvent(newGroup, ServerStoredGroupEvent.GROUP_CREATED_EVENT);\r\n    return newGroup;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWritePanel.appendText",
	"Comment": "appends the given text to the end of the contained html document. thismethod is used to insert smileys when user selects a smiley from themenu.",
	"Method": "void appendText(String text){\r\n    HTMLDocument doc = (HTMLDocument) editorPane.getDocument();\r\n    Element currentElement = doc.getCharacterElement(editorPane.getCaretPosition());\r\n    try {\r\n        doc.insertAfterEnd(currentElement, text);\r\n    } catch (BadLocationException e) {\r\n        logger.error(\"Insert in the HTMLDocument failed.\", e);\r\n    } catch (IOException e) {\r\n        logger.error(\"Insert in the HTMLDocument failed.\", e);\r\n    }\r\n    this.editorPane.setCaretPosition(doc.getLength());\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.MessageDeliveryFailedEvent.getErrorCode",
	"Comment": "returns an error code descibing the reason for the failure of the message delivery.",
	"Method": "int getErrorCode(){\r\n    return errorCode;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.phonenumbers.PhoneNumberI18nServiceImpl.convertAlphaCharactersInNumber",
	"Comment": "changes all alphabetical characters into numbers, following phone dialpad disposition.",
	"Method": "String convertAlphaCharactersInNumber(String phoneNumber){\r\n    phoneNumber = charactersFordialPadNumber2.matcher(phoneNumber).replaceAll(\"2\");\r\n    phoneNumber = charactersFordialPadNumber3.matcher(phoneNumber).replaceAll(\"3\");\r\n    phoneNumber = charactersFordialPadNumber4.matcher(phoneNumber).replaceAll(\"4\");\r\n    phoneNumber = charactersFordialPadNumber5.matcher(phoneNumber).replaceAll(\"5\");\r\n    phoneNumber = charactersFordialPadNumber6.matcher(phoneNumber).replaceAll(\"6\");\r\n    phoneNumber = charactersFordialPadNumber7.matcher(phoneNumber).replaceAll(\"7\");\r\n    phoneNumber = charactersFordialPadNumber8.matcher(phoneNumber).replaceAll(\"8\");\r\n    return charactersFordialPadNumber9.matcher(phoneNumber).replaceAll(\"9\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetMultiUserChatJabberImpl.createLocalChatRoomInstance",
	"Comment": "creates a chatroom from the specified smackmultiuserchat.",
	"Method": "ChatRoom createLocalChatRoomInstance(MultiUserChat muc){\r\n    synchronized (chatRoomCache) {\r\n        ChatRoomJabberImpl chatRoom = new ChatRoomJabberImpl(muc, jabberProvider);\r\n        cacheChatRoom(chatRoom);\r\n        addSmackInvitationRejectionListener(muc, chatRoom);\r\n        return chatRoom;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.xcap.XCapResourceId.create",
	"Comment": "creates xcap resource identifier object from single string.",
	"Method": "XCapResourceId create(String resourceId){\r\n    if (resourceId == null || resourceId.trim().length() == 0) {\r\n        throw new IllegalArgumentException(\"Resource identifier cannot be null or empty\");\r\n    }\r\n    int index = resourceId.indexOf(DELIMETER);\r\n    if (index == -1) {\r\n        throw new IllegalArgumentException(\"Resource identifier has invalid format\");\r\n    }\r\n    String document = resourceId.substring(0, index);\r\n    String node = resourceId.substring(index + DELIMETER.length());\r\n    return new XCapResourceId(document, node);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.OneToOneCallPeerPanel.initSecurityStatusLabel",
	"Comment": "initializes the security status label, shown in the call status bar.",
	"Method": "void initSecurityStatusLabel(){\r\n    securityStatusLabel.setBorder(BorderFactory.createEmptyBorder(2, 5, 2, 5));\r\n    securityStatusLabel.addMouseListener(new MouseAdapter() {\r\n        @Override\r\n        public void mousePressed(MouseEvent e) {\r\n            SrtpControl ctrl = securityPanel.getSecurityControl();\r\n            if (ctrl instanceof ZrtpControl && ctrl.getSecureCommunicationStatus()) {\r\n                setSecurityPanelVisible(!callRenderer.getCallContainer().getCallWindow().getFrame().getGlassPane().isVisible());\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.OneToOneCallPeerPanel.initSecurityStatusLabel",
	"Comment": "initializes the security status label, shown in the call status bar.",
	"Method": "void initSecurityStatusLabel(){\r\n    SrtpControl ctrl = securityPanel.getSecurityControl();\r\n    if (ctrl instanceof ZrtpControl && ctrl.getSecureCommunicationStatus()) {\r\n        setSecurityPanelVisible(!callRenderer.getCallContainer().getCallWindow().getFrame().getGlassPane().isVisible());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.jabber.JabberAccountRegistration.getEncodingsRegistration",
	"Comment": "returns encodingsregistrationutil object which stores encodingsconfiguration.",
	"Method": "EncodingsRegistrationUtil getEncodingsRegistration(){\r\n    return encodingsRegistration;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.history.HistoryImpl.getInteractiveReader",
	"Comment": "returns an object that can be used to read and query this history. theinteractivehistoryreader differs from the historyreaderin the way it manages query results. it allows to cancel a search atany time and to track history results through ahistoryquerylistener.",
	"Method": "InteractiveHistoryReader getInteractiveReader(){\r\n    if (interactiveReader == null)\r\n        interactiveReader = new InteractiveHistoryReaderImpl(this);\r\n    return interactiveReader;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.presence.avatar.imagepicker.ImageClipper.paintComponent",
	"Comment": "paint the component with the image we have and the settingswe have for it.",
	"Method": "void paintComponent(Graphics g){\r\n    super.paintComponent(g);\r\n    g = g.create();\r\n    AntialiasingManager.activateAntialiasing(g);\r\n    updateImagePoints();\r\n    g.drawImage(this.image, this.imageRect.x, this.imageRect.y, this.imageRect.width, this.imageRect.height, this);\r\n    updateCropZone();\r\n    g.setColor(Color.BLACK);\r\n    g.drawRect(this.cropZoneRect.x, this.cropZoneRect.y, this.cropZoneRect.width, this.cropZoneRect.height);\r\n    drawImageOverlay(g);\r\n    g.setColor(IMAGE_BORDER_COLOR);\r\n    g.drawRoundRect(this.imageRect.x - 2, this.imageRect.y - 2, this.imageRect.width + 3, this.imageRect.height + 3, 2, 2);\r\n    g.drawRoundRect(this.imageRect.x - 1, this.imageRect.y - 1, this.imageRect.width + 1, this.imageRect.height + 1, 2, 2);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.sipaccregwizz.AccountPanel.isCreateAccount",
	"Comment": "indicates if the account information provided by this form is for newaccount or an existing one.",
	"Method": "boolean isCreateAccount(){\r\n    return createAccountButton.isSelected();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.GroupNode.addContactGroup",
	"Comment": "creates a groupnode for the given uigroup andadds it to this group.",
	"Method": "GroupNode addContactGroup(UIGroupImpl uiGroup){\r\n    int selectedIndex = getLeadSelectionRow();\r\n    GroupNode groupNode;\r\n    synchronized (uiGroup) {\r\n        groupNode = new GroupNode(treeModel, uiGroup);\r\n        uiGroup.setGroupNode(groupNode);\r\n    }\r\n    add(groupNode);\r\n    fireNodeInserted(children.size() - 1);\r\n    refreshSelection(selectedIndex, getLeadSelectionRow());\r\n    return groupNode;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.Html2Text.extractText",
	"Comment": "a utility method that allows to extract the text content of an html pagestripped from all formatting tags. method is synchronized to avoidconcurrent access to the underlying htmleditorkit.",
	"Method": "String extractText(String html){\r\n    if (html == null)\r\n        return null;\r\n    if (parser == null)\r\n        parser = new HTMLParserCallback();\r\n    try {\r\n        StringReader in = new StringReader(html);\r\n        try {\r\n            return parser.parse(in);\r\n        } finally {\r\n            in.close();\r\n        }\r\n    } catch (Exception ex) {\r\n        if (logger.isInfoEnabled())\r\n            logger.info(\"Failed to extract plain text from html=\" + html, ex);\r\n        return html;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.WhiteboardObjectReceivedEvent.getTimestamp",
	"Comment": "a timestamp indicating the exact date when the event ocurred.",
	"Method": "Date getTimestamp(){\r\n    return timestamp;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.ProtocolProviderServiceGibberishImpl.unregister",
	"Comment": "ends the registration of this protocol provider with the currentregistration service.",
	"Method": "void unregister(){\r\n    RegistrationState oldState = currentRegistrationState;\r\n    currentRegistrationState = RegistrationState.UNREGISTERED;\r\n    fireRegistrationStateChanged(oldState, currentRegistrationState, RegistrationStateChangeEvent.REASON_USER_REQUEST, null);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.provisioning.ProvisioningServiceImpl.setProvisioningMethod",
	"Comment": "enables the provisioning with the given method. if the provisioningmethod is null disables the provisioning.",
	"Method": "void setProvisioningMethod(String provisioningMethod){\r\n    ProvisioningActivator.getConfigurationService().setProperty(PROVISIONING_METHOD_PROP, provisioningMethod);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.wizard.EncodingsPanel.updateTableState",
	"Comment": "enables or disables the encodings tables based on the override checkbox.",
	"Method": "void updateTableState(){\r\n    audioControls.setEnabled(overrideCheckBox.isSelected());\r\n    videoControls.setEnabled(overrideCheckBox.isSelected());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl.processExtraHeaders",
	"Comment": "a place where we can handle any headers we need for requestsand responses. such a case is reflecting the focus state in contactheader.",
	"Method": "void processExtraHeaders(javax.sip.message.Message message){\r\n    reflectConferenceFocus(message);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl.processOffer",
	"Comment": "parses offerstring, creates the mediastreams that itdescribes and constructs a response representing the state of thismediahandler. the method takes into account the presence orabsence of previous negotiations and interprets the offerstringas an initial offer or a session update accordingly.",
	"Method": "String processOffer(String offerString){\r\n    SessionDescription offer = SdpUtils.parseSdpString(offerString);\r\n    synchronized (offerAnswerLock) {\r\n        SessionDescription answer = (localSess == null) ? processFirstOffer(offer) : processUpdateOffer(offer, localSess);\r\n        if (getConfigurationService().getBoolean(ProtocolProviderServiceSipImpl.USE_SESSION_LEVEL_DIRECTION_IN_SDP, false)) {\r\n            SdpUtils.setSessionDirection(answer);\r\n        }\r\n        return answer.toString();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.dns.DnsJavaLogger.logInternal",
	"Comment": "logs the dns packet, checking its prefix message to distinguishincoming and outgoing messages and the transport used tcp or udp.",
	"Method": "void logInternal(SocketAddress local,SocketAddress remote,String prefix,byte[] data){\r\n    if (getPacketLoggingService() == null || !(local instanceof InetSocketAddress && remote instanceof InetSocketAddress)) {\r\n        return;\r\n    }\r\n    InetSocketAddress localAddress = (InetSocketAddress) local;\r\n    InetSocketAddress remoteAddress = (InetSocketAddress) remote;\r\n    PacketLoggingService.TransportName transportName = PacketLoggingService.TransportName.UDP;\r\n    if (prefix.contains(\"TCP\"))\r\n        transportName = PacketLoggingService.TransportName.TCP;\r\n    boolean isSender = true;\r\n    if (prefix.contains(\"read\"))\r\n        isSender = false;\r\n    byte[] srcAddr;\r\n    int srcPort;\r\n    byte[] dstAddr;\r\n    int dstPort;\r\n    if (isSender) {\r\n        srcAddr = localAddress.getAddress().getAddress();\r\n        srcPort = localAddress.getPort();\r\n        dstAddr = remoteAddress.getAddress().getAddress();\r\n        dstPort = remoteAddress.getPort();\r\n    } else {\r\n        dstAddr = localAddress.getAddress().getAddress();\r\n        dstPort = localAddress.getPort();\r\n        srcAddr = remoteAddress.getAddress().getAddress();\r\n        srcPort = remoteAddress.getPort();\r\n    }\r\n    getPacketLoggingService().logPacket(PacketLoggingService.ProtocolName.DNS, srcAddr, srcPort, dstAddr, dstPort, transportName, isSender, data, 0, data.length);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.sip.TestOperationSetPersistentPresence.postTestRemoveGroup",
	"Comment": "removes the group created in the server stored contact list by the creategroup test, makes sure that the corresponding event has been generatedand verifies that the group is not in the list any more.",
	"Method": "void postTestRemoveGroup(){\r\n    logger.trace(\"testing removal of server stored groups\");\r\n    GroupChangeCollector groupChangeCollector = new GroupChangeCollector();\r\n    this.opSetPersPresence1.addServerStoredGroupChangeListener(groupChangeCollector);\r\n    try {\r\n        this.opSetPersPresence1.removeServerStoredContactGroup(this.opSetPersPresence1.getServerStoredContactListRoot().getGroup(testGroupName2));\r\n    } catch (OperationFailedException ex) {\r\n        logger.error(\"error removing group\", ex);\r\n    }\r\n    groupChangeCollector.waitForEvent(10000);\r\n    this.opSetPersPresence1.removeServerStoredGroupChangeListener(groupChangeCollector);\r\n    assertEquals(\"Collected Group Change event\", 1, groupChangeCollector.collectedEvents.size());\r\n    assertEquals(\"Group name.\", testGroupName2, ((ServerStoredGroupEvent) groupChangeCollector.collectedEvents.get(0)).getSourceGroup().getGroupName());\r\n    ContactGroup group = this.opSetPersPresence1.getServerStoredContactListRoot().getGroup(testGroupName2);\r\n    assertNull(\"A freshly removed group was still on the contact list.\", group);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.accountinfo.AccountDetailsPanel.initSummaryPanel",
	"Comment": "initialized the main panel that contains all serverstoreddetails",
	"Method": "void initSummaryPanel(){\r\n    JPanel summaryPanel = new TransparentPanel(new BorderLayout(10, 10));\r\n    summaryPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));\r\n    JPanel leftPanel = new TransparentPanel(new BorderLayout());\r\n    JPanel avatarPanel = new TransparentPanel(new BorderLayout());\r\n    JPanel radioButtonPanel = new TransparentPanel(new GridLayout(2, 1));\r\n    globalIcon = new JRadioButton(Resources.getString(\"plugin.accountinfo.GLOBAL_ICON\"));\r\n    globalIcon.setSelected(true);\r\n    globalIcon.setOpaque(false);\r\n    globalIcon.setEnabled(false);\r\n    localIcon = new JRadioButton(Resources.getString(\"plugin.accountinfo.LOCAL_ICON\"));\r\n    localIcon.setOpaque(false);\r\n    localIcon.setEnabled(false);\r\n    ButtonGroup group = new ButtonGroup();\r\n    group.add(globalIcon);\r\n    group.add(localIcon);\r\n    radioButtonPanel.add(globalIcon);\r\n    radioButtonPanel.add(localIcon);\r\n    avatarPanel.add(radioButtonPanel, BorderLayout.NORTH);\r\n    leftPanel.add(avatarPanel, BorderLayout.NORTH);\r\n    summaryPanel.add(leftPanel, BorderLayout.WEST);\r\n    detailToTextField.put(ImageDetail.class, new JTextField());\r\n    imageWithMenu = new FramedImageWithMenu(Resources.getImage(\"service.gui.DEFAULT_USER_PHOTO\"), Resources.getImage(\"service.gui.DEFAULT_USER_PHOTO\").getIconWidth(), Resources.getImage(\"service.gui.DEFAULT_USER_PHOTO\").getIconHeight());\r\n    SelectAvatarMenu selectAvatarMenu = new SelectAvatarMenu(imageWithMenu);\r\n    selectAvatarMenu.setAccountID(protocolProvider.getAccountID());\r\n    imageWithMenu.setPopupMenu(selectAvatarMenu);\r\n    avatarPanel.add(imageWithMenu, BorderLayout.SOUTH);\r\n    globalIcon.addActionListener(new ActionListener() {\r\n        @Override\r\n        public void actionPerformed(ActionEvent e) {\r\n            imageWithMenu.setEnabled(false);\r\n        }\r\n    });\r\n    localIcon.addActionListener(new ActionListener() {\r\n        @Override\r\n        public void actionPerformed(ActionEvent e) {\r\n            imageWithMenu.setEnabled(true);\r\n        }\r\n    });\r\n    imageWithMenu.setEnabled(false);\r\n    valuesPanel = new TransparentPanel(new GridBagLayout());\r\n    valuesPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));\r\n    GridBagConstraints first = new GridBagConstraints();\r\n    first.gridx = 0;\r\n    first.gridy = 0;\r\n    first.weightx = 0;\r\n    first.anchor = GridBagConstraints.LINE_START;\r\n    first.gridwidth = 1;\r\n    first.insets = new Insets(4, 4, 4, 4);\r\n    first.fill = GridBagConstraints.HORIZONTAL;\r\n    GridBagConstraints second = new GridBagConstraints();\r\n    second.gridx = 1;\r\n    second.gridy = 0;\r\n    second.weightx = 2;\r\n    second.anchor = GridBagConstraints.LINE_START;\r\n    second.gridwidth = 1;\r\n    second.insets = first.insets;\r\n    second.fill = GridBagConstraints.HORIZONTAL;\r\n    if (accountInfoOpSet.isDetailClassSupported(DisplayNameDetail.class)) {\r\n        displayNameField = new JTextField();\r\n        valuesPanel.add(new JLabel(Resources.getString(\"plugin.accountinfo.DISPLAY_NAME\")), first);\r\n        valuesPanel.add(displayNameField, second);\r\n        first.gridy = ++second.gridy;\r\n        detailToTextField.put(DisplayNameDetail.class, displayNameField);\r\n    }\r\n    firstNameField = new JTextField();\r\n    valuesPanel.add(new JLabel(Resources.getString(\"plugin.accountinfo.FIRST_NAME\")), first);\r\n    valuesPanel.add(firstNameField, second);\r\n    first.gridy = ++second.gridy;\r\n    detailToTextField.put(FirstNameDetail.class, firstNameField);\r\n    middleNameField = new JTextField();\r\n    valuesPanel.add(new JLabel(Resources.getString(\"plugin.accountinfo.MIDDLE_NAME\")), first);\r\n    valuesPanel.add(middleNameField, second);\r\n    first.gridy = ++second.gridy;\r\n    detailToTextField.put(MiddleNameDetail.class, middleNameField);\r\n    lastNameField = new JTextField();\r\n    valuesPanel.add(new JLabel(Resources.getString(\"plugin.accountinfo.LAST_NAME\")), first);\r\n    valuesPanel.add(lastNameField, second);\r\n    first.gridy = ++second.gridy;\r\n    detailToTextField.put(LastNameDetail.class, lastNameField);\r\n    if (accountInfoOpSet.isDetailClassSupported(NicknameDetail.class)) {\r\n        nicknameField = new JTextField();\r\n        valuesPanel.add(new JLabel(Resources.getString(\"plugin.accountinfo.NICKNAME\")), first);\r\n        valuesPanel.add(nicknameField, second);\r\n        first.gridy = ++second.gridy;\r\n        detailToTextField.put(NicknameDetail.class, nicknameField);\r\n    }\r\n    if (accountInfoOpSet.isDetailClassSupported(URLDetail.class)) {\r\n        urlField = new JTextField();\r\n        valuesPanel.add(new JLabel(Resources.getString(\"plugin.accountinfo.URL\")), first);\r\n        valuesPanel.add(urlField, second);\r\n        first.gridy = ++second.gridy;\r\n        detailToTextField.put(URLDetail.class, urlField);\r\n    }\r\n    if (accountInfoOpSet.isDetailClassSupported(GenderDetail.class)) {\r\n        genderField = new JTextField();\r\n        valuesPanel.add(new JLabel(Resources.getString(\"plugin.accountinfo.GENDER\")), first);\r\n        valuesPanel.add(genderField, second);\r\n        first.gridy = ++second.gridy;\r\n        detailToTextField.put(GenderDetail.class, genderField);\r\n    }\r\n    birthDayCalendar = new JDateChooser();\r\n    valuesPanel.add(new JLabel(Resources.getString(\"plugin.accountinfo.BDAY\")), first);\r\n    valuesPanel.add(birthDayCalendar, second);\r\n    birthDayCalendar.setDateFormatString(Resources.getString(\"plugin.accountinfo.BDAY_FORMAT\"));\r\n    birthDayCalendar.addPropertyChangeListener(new PropertyChangeListener() {\r\n        @Override\r\n        public void propertyChange(PropertyChangeEvent evt) {\r\n            if (evt.getPropertyName().equals(\"date\")) {\r\n                Date date = (Date) evt.getNewValue();\r\n                if (date != null) {\r\n                    Calendar currentDate = Calendar.getInstance();\r\n                    Calendar c = Calendar.getInstance();\r\n                    c.setTime(date);\r\n                    int age = currentDate.get(Calendar.YEAR) - c.get(Calendar.YEAR);\r\n                    if (currentDate.get(Calendar.MONTH) < c.get(Calendar.MONTH))\r\n                        age--;\r\n                    if ((currentDate.get(Calendar.MONTH) == c.get(Calendar.MONTH)) && (currentDate.get(Calendar.DAY_OF_MONTH) < c.get(Calendar.DAY_OF_MONTH)))\r\n                        age--;\r\n                    String ageDetail = Integer.toString(age).trim();\r\n                    ageField.setText(ageDetail);\r\n                }\r\n            }\r\n        }\r\n    });\r\n    first.gridy = ++second.gridy;\r\n    ageField = new JTextField();\r\n    valuesPanel.add(new JLabel(Resources.getString(\"plugin.accountinfo.AGE\")), first);\r\n    valuesPanel.add(ageField, second);\r\n    first.gridy = ++second.gridy;\r\n    ageField.setEditable(false);\r\n    detailToTextField.put(BirthDateDetail.class, new JTextField());\r\n    if (accountInfoOpSet.isDetailClassSupported(AddressDetail.class)) {\r\n        streetAddressField = new JTextField();\r\n        valuesPanel.add(new JLabel(Resources.getString(\"plugin.accountinfo.STREET\")), first);\r\n        valuesPanel.add(streetAddressField, second);\r\n        first.gridy = ++second.gridy;\r\n        detailToTextField.put(AddressDetail.class, streetAddressField);\r\n    }\r\n    if (accountInfoOpSet.isDetailClassSupported(CityDetail.class)) {\r\n        cityField = new JTextField();\r\n        valuesPanel.add(new JLabel(Resources.getString(\"plugin.accountinfo.CITY\")), first);\r\n        valuesPanel.add(cityField, second);\r\n        first.gridy = ++second.gridy;\r\n        detailToTextField.put(CityDetail.class, cityField);\r\n    }\r\n    if (accountInfoOpSet.isDetailClassSupported(ProvinceDetail.class)) {\r\n        regionField = new JTextField();\r\n        valuesPanel.add(new JLabel(Resources.getString(\"plugin.accountinfo.REGION\")), first);\r\n        valuesPanel.add(regionField, second);\r\n        first.gridy = ++second.gridy;\r\n        detailToTextField.put(ProvinceDetail.class, regionField);\r\n    }\r\n    if (accountInfoOpSet.isDetailClassSupported(PostalCodeDetail.class)) {\r\n        postalCodeField = new JTextField();\r\n        valuesPanel.add(new JLabel(Resources.getString(\"plugin.accountinfo.POST\")), first);\r\n        valuesPanel.add(postalCodeField, second);\r\n        first.gridy = ++second.gridy;\r\n        detailToTextField.put(PostalCodeDetail.class, postalCodeField);\r\n    }\r\n    if (accountInfoOpSet.isDetailClassSupported(CountryDetail.class)) {\r\n        countryField = new JTextField();\r\n        valuesPanel.add(new JLabel(Resources.getString(\"plugin.accountinfo.COUNTRY\")), first);\r\n        valuesPanel.add(countryField, second);\r\n        first.gridy = ++second.gridy;\r\n        detailToTextField.put(CountryDetail.class, countryField);\r\n    }\r\n    emailField = new JTextField();\r\n    valuesPanel.add(new JLabel(Resources.getString(\"plugin.accountinfo.EMAIL\")), first);\r\n    valuesPanel.add(emailField, second);\r\n    first.gridy = ++second.gridy;\r\n    detailToTextField.put(EmailAddressDetail.class, emailField);\r\n    if (accountInfoOpSet.isDetailClassSupported(WorkEmailAddressDetail.class)) {\r\n        workEmailField = new JTextField();\r\n        valuesPanel.add(new JLabel(Resources.getString(\"plugin.accountinfo.WORK_EMAIL\")), first);\r\n        valuesPanel.add(workEmailField, second);\r\n        first.gridy = ++second.gridy;\r\n        detailToTextField.put(WorkEmailAddressDetail.class, workEmailField);\r\n    }\r\n    phoneField = new JTextField();\r\n    valuesPanel.add(new JLabel(Resources.getString(\"plugin.accountinfo.PHONE\")), first);\r\n    valuesPanel.add(phoneField, second);\r\n    first.gridy = ++second.gridy;\r\n    detailToTextField.put(PhoneNumberDetail.class, phoneField);\r\n    if (accountInfoOpSet.isDetailClassSupported(WorkPhoneDetail.class)) {\r\n        workPhoneField = new JTextField();\r\n        valuesPanel.add(new JLabel(Resources.getString(\"plugin.accountinfo.WORK_PHONE\")), first);\r\n        valuesPanel.add(workPhoneField, second);\r\n        first.gridy = ++second.gridy;\r\n        detailToTextField.put(WorkPhoneDetail.class, workPhoneField);\r\n    }\r\n    if (accountInfoOpSet.isDetailClassSupported(MobilePhoneDetail.class)) {\r\n        mobilePhoneField = new JTextField();\r\n        valuesPanel.add(new JLabel(Resources.getString(\"plugin.accountinfo.MOBILE_PHONE\")), first);\r\n        valuesPanel.add(mobilePhoneField, second);\r\n        first.gridy = ++second.gridy;\r\n        detailToTextField.put(MobilePhoneDetail.class, mobilePhoneField);\r\n    }\r\n    if (accountInfoOpSet.isDetailClassSupported(WorkOrganizationNameDetail.class)) {\r\n        organizationField = new JTextField();\r\n        valuesPanel.add(new JLabel(Resources.getString(\"plugin.accountinfo.ORGANIZATION\")), first);\r\n        valuesPanel.add(organizationField, second);\r\n        first.gridy = ++second.gridy;\r\n        detailToTextField.put(WorkOrganizationNameDetail.class, organizationField);\r\n    }\r\n    if (accountInfoOpSet.isDetailClassSupported(JobTitleDetail.class)) {\r\n        jobTitleField = new JTextField();\r\n        valuesPanel.add(new JLabel(Resources.getString(\"plugin.accountinfo.JOB_TITLE\")), first);\r\n        valuesPanel.add(jobTitleField, second);\r\n        first.gridy = ++second.gridy;\r\n        detailToTextField.put(JobTitleDetail.class, jobTitleField);\r\n    }\r\n    if (accountInfoOpSet.isDetailClassSupported(AboutMeDetail.class)) {\r\n        aboutMeArea = new JTextArea(3, 0);\r\n        valuesPanel.add(new JLabel(Resources.getString(\"plugin.accountinfo.ABOUT_ME\")), first);\r\n        second.gridheight = 3;\r\n        JScrollPane areaScrollPane = new JScrollPane(aboutMeArea);\r\n        areaScrollPane.setOpaque(false);\r\n        areaScrollPane.setBorder(BorderFactory.createEmptyBorder());\r\n        areaScrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);\r\n        valuesPanel.add(areaScrollPane, second);\r\n        first.gridy = ++second.gridy;\r\n        DefaultStyledDocument doc = new DefaultStyledDocument();\r\n        doc.setDocumentFilter(new DocumentFilter() {\r\n            private final int MAX_CHARACTERS = Integer.valueOf(Resources.getString(\"plugin.accountinfo.ABOUT_ME_MAX_CHARACTERS\"));\r\n            public void insertString(FilterBypass fb, int offs, String str, AttributeSet a) throws BadLocationException {\r\n                if ((fb.getDocument().getLength() + str.length()) <= MAX_CHARACTERS)\r\n                    super.insertString(fb, offs, str, a);\r\n                else\r\n                    Toolkit.getDefaultToolkit().beep();\r\n            }\r\n            public void replace(FilterBypass fb, int offs, int length, String str, AttributeSet a) throws BadLocationException {\r\n                if ((fb.getDocument().getLength() + str.length() - length) <= MAX_CHARACTERS)\r\n                    super.replace(fb, offs, length, str, a);\r\n                else\r\n                    Toolkit.getDefaultToolkit().beep();\r\n            }\r\n        });\r\n        aboutMeArea.setDocument(doc);\r\n        aboutMeArea.setBorder(firstNameField.getBorder());\r\n        aboutMeArea.setLineWrap(true);\r\n        aboutMeArea.setWrapStyleWord(true);\r\n        aboutMeArea.setPreferredSize(new Dimension(50, 100));\r\n        aboutMeArea.setMinimumSize(new Dimension(50, 100));\r\n        detailToTextField.put(AboutMeDetail.class, new JTextField());\r\n    }\r\n    mainScrollPane = new JScrollPane(summaryPanel, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\r\n    mainScrollPane.getViewport().setOpaque(false);\r\n    mainScrollPane.setOpaque(false);\r\n    mainScrollPane.setBorder(BorderFactory.createEmptyBorder());\r\n    summaryPanel.add(valuesPanel, BorderLayout.CENTER);\r\n    this.add(mainScrollPane);\r\n    this.applyButton.addActionListener(new SubmitActionListener());\r\n    JButton cancelButton = new JButton(Resources.getString(\"service.gui.CANCEL\"));\r\n    cancelButton.addActionListener(new ActionListener() {\r\n        @Override\r\n        public void actionPerformed(ActionEvent evt) {\r\n            dialog.close(false);\r\n            mainScrollPane.getVerticalScrollBar().setValue(0);\r\n        }\r\n    });\r\n    this.buttonPanel.add(applyButton);\r\n    this.buttonPanel.add(cancelButton);\r\n    this.add(buttonPanel);\r\n    for (Component component : valuesPanel.getComponents()) component.setEnabled(false);\r\n    if (aboutMeArea != null)\r\n        aboutMeArea.setEnabled(false);\r\n    applyButton.setEnabled(false);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.accountinfo.AccountDetailsPanel.initSummaryPanel",
	"Comment": "initialized the main panel that contains all serverstoreddetails",
	"Method": "void initSummaryPanel(){\r\n    imageWithMenu.setEnabled(false);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.accountinfo.AccountDetailsPanel.initSummaryPanel",
	"Comment": "initialized the main panel that contains all serverstoreddetails",
	"Method": "void initSummaryPanel(){\r\n    imageWithMenu.setEnabled(true);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.accountinfo.AccountDetailsPanel.initSummaryPanel",
	"Comment": "initialized the main panel that contains all serverstoreddetails",
	"Method": "void initSummaryPanel(){\r\n    if (evt.getPropertyName().equals(\"date\")) {\r\n        Date date = (Date) evt.getNewValue();\r\n        if (date != null) {\r\n            Calendar currentDate = Calendar.getInstance();\r\n            Calendar c = Calendar.getInstance();\r\n            c.setTime(date);\r\n            int age = currentDate.get(Calendar.YEAR) - c.get(Calendar.YEAR);\r\n            if (currentDate.get(Calendar.MONTH) < c.get(Calendar.MONTH))\r\n                age--;\r\n            if ((currentDate.get(Calendar.MONTH) == c.get(Calendar.MONTH)) && (currentDate.get(Calendar.DAY_OF_MONTH) < c.get(Calendar.DAY_OF_MONTH)))\r\n                age--;\r\n            String ageDetail = Integer.toString(age).trim();\r\n            ageField.setText(ageDetail);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.accountinfo.AccountDetailsPanel.initSummaryPanel",
	"Comment": "initialized the main panel that contains all serverstoreddetails",
	"Method": "void initSummaryPanel(){\r\n    if ((fb.getDocument().getLength() + str.length()) <= MAX_CHARACTERS)\r\n        super.insertString(fb, offs, str, a);\r\n    else\r\n        Toolkit.getDefaultToolkit().beep();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.accountinfo.AccountDetailsPanel.initSummaryPanel",
	"Comment": "initialized the main panel that contains all serverstoreddetails",
	"Method": "void initSummaryPanel(){\r\n    if ((fb.getDocument().getLength() + str.length() - length) <= MAX_CHARACTERS)\r\n        super.replace(fb, offs, length, str, a);\r\n    else\r\n        Toolkit.getDefaultToolkit().beep();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.accountinfo.AccountDetailsPanel.initSummaryPanel",
	"Comment": "initialized the main panel that contains all serverstoreddetails",
	"Method": "void initSummaryPanel(){\r\n    dialog.close(false);\r\n    mainScrollPane.getVerticalScrollBar().setValue(0);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.FullUserInfoCmd.writeOutShort",
	"Comment": "writes short data to the icqdataoutwhich is send to the server",
	"Method": "void writeOutShort(int dataType,int value){\r\n    try {\r\n        writeUShort(icqDataOut, dataType);\r\n        writeUShort(icqDataOut, 2);\r\n        writeUShort(icqDataOut, value);\r\n    } catch (IOException ex) {\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.JingleNodesHarvester.harvest",
	"Comment": "gathers jingle nodes candidates for all host candidates that arealready present in the specified component. this method relieson the specified component to already contain all its hostcandidates so that it would resolve them.",
	"Method": "Collection<LocalCandidate> harvest(Component component){\r\n    logger.info(\"harvest Jingle Nodes\");\r\n    Collection<LocalCandidate> candidates = new HashSet<LocalCandidate>();\r\n    String ip = null;\r\n    int port = -1;\r\n    if (localAddressSecond != null && relayedAddressSecond != null) {\r\n        LocalCandidate candidate = createJingleNodesCandidate(relayedAddressSecond, component, localAddressSecond);\r\n        if (component.addLocalCandidate(candidate)) {\r\n            candidates.add(candidate);\r\n        }\r\n        localAddressSecond = null;\r\n        relayedAddressSecond = null;\r\n        return candidates;\r\n    }\r\n    XMPPConnection conn = serviceNode.getConnection();\r\n    JingleChannelIQ ciq = null;\r\n    if (serviceNode != null) {\r\n        final TrackerEntry preferred = serviceNode.getPreferedRelay();\r\n        if (preferred != null) {\r\n            ciq = SmackServiceNode.getChannel(conn, preferred.getJid());\r\n        }\r\n    }\r\n    if (ciq != null) {\r\n        ip = ciq.getHost();\r\n        port = ciq.getRemoteport();\r\n        if (logger.isInfoEnabled()) {\r\n            logger.info(\"JN relay: \" + ip + \" remote port:\" + port + \" local port: \" + ciq.getLocalport());\r\n        }\r\n        if (ip == null || ciq.getRemoteport() == 0) {\r\n            logger.warn(\"JN relay ignored because ip was null or port 0\");\r\n            return candidates;\r\n        }\r\n        int scopeIndex = ip.indexOf('%');\r\n        if (scopeIndex > 0) {\r\n            logger.warn(\"Dropping scope from assumed IPv6 address \" + ip);\r\n            ip = ip.substring(0, scopeIndex);\r\n        }\r\n        TransportAddress relayedAddress = new TransportAddress(ip, port, Transport.UDP);\r\n        TransportAddress localAddress = new TransportAddress(ip, ciq.getLocalport(), Transport.UDP);\r\n        LocalCandidate local = createJingleNodesCandidate(relayedAddress, component, localAddress);\r\n        relayedAddressSecond = new TransportAddress(ip, port + 1, Transport.UDP);\r\n        localAddressSecond = new TransportAddress(ip, ciq.getLocalport() + 1, Transport.UDP);\r\n        if (component.addLocalCandidate(local)) {\r\n            candidates.add(local);\r\n        }\r\n    }\r\n    return candidates;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.history.HistoryServiceImpl.isCacheEnabled",
	"Comment": "returns whether caching of readed documents is enabled or desibled.",
	"Method": "boolean isCacheEnabled(){\r\n    return cacheEnabled;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.AbstractCallPeerJabberGTalkImpl.isInitiator",
	"Comment": "determines whether this peer initiated the session. note that if thispeer is the initiator of the session, then we are the responder!",
	"Method": "boolean isInitiator(){\r\n    return initiator;\r\n}"
}, {
	"Path": "net.librec.data.splitter.LOOCVDataSplitter.getLooByItemsDate",
	"Comment": "split ratings into two parts where the last item according to date ispreserved as the test set and the remaining data as the training set.",
	"Method": "void getLooByItemsDate(){\r\n    trainMatrix = new SequentialAccessSparseMatrix(preferenceMatrix);\r\n    Table<Integer, Integer, Double> dataTable = HashBasedTable.create();\r\n    for (int columnIndex = 0, columnSize = preferenceMatrix.columnSize(); columnIndex < columnSize; columnIndex++) {\r\n        SequentialSparseVector userRatingVector = preferenceMatrix.column(columnIndex);\r\n        if (userRatingVector.getNumEntries() == 0) {\r\n            continue;\r\n        }\r\n        List<RatingContext> ratingContexts = new ArrayList();\r\n        for (Vector.VectorEntry vectorEntry : userRatingVector) {\r\n            ratingContexts.add(new RatingContext(vectorEntry.position(), columnIndex, (long) datetimeMatrix.getAtRowPosition(vectorEntry.position(), columnIndex)));\r\n        }\r\n        Collections.sort(ratingContexts);\r\n        int rowPosition = ratingContexts.get(ratingContexts.size() - 1).getUser();\r\n        trainMatrix.setAtRowPosition(rowPosition, columnIndex, 0.0D);\r\n        dataTable.put(preferenceMatrix.column(columnIndex).getIndexAtPosition(rowPosition), columnIndex, preferenceMatrix.getAtRowPosition(rowPosition, columnIndex));\r\n    }\r\n    trainMatrix.reshape();\r\n    testMatrix = new SequentialAccessSparseMatrix(preferenceMatrix.rowSize(), preferenceMatrix.columnSize(), dataTable);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.JabberAccRegWizzActivator.getCertificateService",
	"Comment": "returns the certificateservice obtained from the bundlecontext.",
	"Method": "CertificateService getCertificateService(){\r\n    if (certService == null) {\r\n        ServiceReference serviceReference = bundleContext.getServiceReference(CertificateService.class.getName());\r\n        certService = (CertificateService) bundleContext.getService(serviceReference);\r\n    }\r\n    return certService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractMessage.getEncoding",
	"Comment": "returns the mime content encoding of this message.the implementation is final because of the presumption it can set theencoding.",
	"Method": "String getEncoding(){\r\n    return encoding;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.ConfigurationUtils.getSendFileLastDir",
	"Comment": "returns the last opened directory of the send file file chooser.",
	"Method": "String getSendFileLastDir(){\r\n    return sendFileLastDir;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomConfigurationFormJabberImpl.getConfigurationSet",
	"Comment": "returns an iterator over a list ofchatroomconfigurationformfields.",
	"Method": "Iterator<ChatRoomConfigurationFormField> getConfigurationSet(){\r\n    Vector<ChatRoomConfigurationFormField> configFormFields = new Vector<ChatRoomConfigurationFormField>();\r\n    Iterator<FormField> smackFormFields = smackConfigForm.getFields();\r\n    while (smackFormFields.hasNext()) {\r\n        FormField smackFormField = smackFormFields.next();\r\n        if (smackFormField == null || smackFormField.getType().equals(FormField.TYPE_HIDDEN))\r\n            continue;\r\n        ChatRoomConfigurationFormFieldJabberImpl jabberConfigField = new ChatRoomConfigurationFormFieldJabberImpl(smackFormField, smackSubmitForm);\r\n        configFormFields.add(jabberConfigField);\r\n    }\r\n    return Collections.unmodifiableList(configFormFields).iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.TestOperationSetTypingNotifications.firstTestTypingNotificationsEventDelivery",
	"Comment": "sends a typing notification through the icq tester agent and verifieswhether it is properly received by the tested implementation",
	"Method": "void firstTestTypingNotificationsEventDelivery(){\r\n    TypingEventCollector evtCollector = new TypingEventCollector();\r\n    opSetTypingNotifs.addTypingNotificationsListener(evtCollector);\r\n    IcqSlickFixture.testerAgent.sendTypingNotification(fixture.ourUserID, TypingState.TYPING);\r\n    evtCollector.waitForEvent(10000);\r\n    opSetTypingNotifs.removeTypingNotificationsListener(evtCollector);\r\n    assertTrue(\"Number of typing events received was zero.\", evtCollector.collectedEvents.size() > 0);\r\n    TypingNotificationEvent evt = (TypingNotificationEvent) evtCollector.collectedEvents.get(0);\r\n    assertEquals(\"Source of the typing notification event\", IcqSlickFixture.testerAgent.getIcqUIN(), evt.getSourceContact().getAddress());\r\n    assertEquals(\"Source of the typing notification event\", OperationSetTypingNotifications.STATE_TYPING, evt.getTypingState());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.osdependent.jdic.StatusSubMenu.updateGlobalStatus",
	"Comment": "updates the global status by picking the most connected protocol providerstatus.",
	"Method": "void updateGlobalStatus(){\r\n    int status = 0;\r\n    boolean hasAvailableProvider = false;\r\n    for (ProtocolProviderService protocolProvider : getProtocolProviders()) {\r\n        if (protocolProvider.getAccountID().isHidden())\r\n            continue;\r\n        if (!protocolProvider.isRegistered())\r\n            continue;\r\n        OperationSetPresence presence = protocolProvider.getOperationSet(OperationSetPresence.class);\r\n        if (presence == null) {\r\n            hasAvailableProvider = true;\r\n            continue;\r\n        }\r\n        int presenceStatus = (presence == null) ? PresenceStatus.AVAILABLE_THRESHOLD : presence.getPresenceStatus().getStatus();\r\n        if (status < presenceStatus)\r\n            status = presenceStatus;\r\n    }\r\n    if (status == 0 && hasAvailableProvider)\r\n        status = PresenceStatus.AVAILABLE_THRESHOLD;\r\n    selectItemFromStatus(status);\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.Entities.fillWithHtml40Entities",
	"Comment": "fills the specified entities instance with html 40 entities.",
	"Method": "void fillWithHtml40Entities(Entities entities){\r\n    entities.addEntities(BASIC_ARRAY);\r\n    entities.addEntities(ISO8859_1_ARRAY);\r\n    entities.addEntities(HTML40_ARRAY);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.aimaccregwizz.AimAccountRegistration.isRememberPassword",
	"Comment": "returns true if password has to remembered, falseotherwise.",
	"Method": "boolean isRememberPassword(){\r\n    return rememberPassword;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.plaf.SearchFieldUI.getVisibleEditorRect",
	"Comment": "if we are in the case of disabled delete button, we simply call theparent implementation of this method, otherwise we recalculate the editorrectangle in order to leave place for the delete button.",
	"Method": "Rectangle getVisibleEditorRect(){\r\n    Rectangle rect = super.getVisibleEditorRect();\r\n    if (rect == null)\r\n        return null;\r\n    if ((rect.width > 0) && (rect.height > 0)) {\r\n        rect.x += searchIcon.getIconWidth() + 5;\r\n        rect.width -= (searchIcon.getIconWidth() + 5);\r\n        if (isSMSIconVisible)\r\n            rect.width -= (smsRolloverIcon.getWidth(null) + 12);\r\n        if (isCallIconVisible)\r\n            rect.width -= (callRolloverIcon.getWidth(null) + 12);\r\n        else\r\n            rect.width -= 8;\r\n        return rect;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.otr.OtrActivator.getContactListService",
	"Comment": "returns the metacontactlistservice obtained from the bundlecontext.",
	"Method": "MetaContactListService getContactListService(){\r\n    if (metaCListService == null) {\r\n        metaCListService = ServiceUtils.getService(bundleContext, MetaContactListService.class);\r\n    }\r\n    return metaCListService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.replacement.twitpic.ReplacementServiceTwitpicImpl.getReplacement",
	"Comment": "replaces the twitpic image links with their corresponding thumbnails.",
	"Method": "String getReplacement(String sourceString){\r\n    final Pattern p = Pattern.compile(\"\\\\.com\\\\/([^\\\\/<]*)\", Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\r\n    Matcher m = p.matcher(sourceString);\r\n    String thumbUrl = sourceString;\r\n    while (m.find()) {\r\n        thumbUrl = \"http://twitpic.com/show/thumb/\" + m.group(1);\r\n    }\r\n    try {\r\n        HttpURLConnection con = (HttpURLConnection) (new URL(thumbUrl).openConnection());\r\n        con.setInstanceFollowRedirects(false);\r\n        con.connect();\r\n        int responseCode = con.getResponseCode();\r\n        if (responseCode == HttpURLConnection.HTTP_MOVED_TEMP || responseCode == HttpURLConnection.HTTP_MOVED_PERM) {\r\n            return con.getHeaderField(\"Location\");\r\n        }\r\n    } catch (Throwable t) {\r\n    }\r\n    return thumbUrl;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chatroomslist.createforms.CreateChatRoomWizardPage1.setNextButtonAccordingToCheckBox",
	"Comment": "enables the next button when the user makes a choise and disables itif nothing is selected.",
	"Method": "void setNextButtonAccordingToCheckBox(){\r\n    if (selectAccountPanel.isRadioSelected())\r\n        this.wizard.setNextFinishButtonEnabled(true);\r\n    else\r\n        this.wizard.setNextFinishButtonEnabled(false);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.contactlist.event.MetaContactPropertyChangeEvent.getSourceMetaContact",
	"Comment": "returns a reference to the metacontact that this event is about",
	"Method": "MetaContact getSourceMetaContact(){\r\n    return (MetaContact) getSource();\r\n}"
}, {
	"Path": "net.librec.data.model.TextDataModelTestCase.getValidSize",
	"Comment": "returns the size of validation matrix of a specified datamodel object",
	"Method": "int getValidSize(DataModel dataModel){\r\n    return dataModel.getDataSplitter().getValidData().size();\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.call.MetaContactPhoneUtil.getVideoPhones",
	"Comment": "returns list of video phones for contact, localized.return null if we have stopped searching and a listener is availableand will be used to inform for results.",
	"Method": "List<String> getVideoPhones(Contact contact,DetailsResponseListener listener){\r\n    if (!this.metaContact.containsContact(contact)) {\r\n        return new ArrayList<String>();\r\n    }\r\n    if (videoPhones.containsKey(contact)) {\r\n        return videoPhones.get(contact);\r\n    }\r\n    List<String> phonesList = ContactPhoneUtil.getContactAdditionalPhones(contact, listener, true, true);\r\n    if (phonesList == null)\r\n        return null;\r\n    else if (phonesList.size() > 0)\r\n        hasVideoDetail = true;\r\n    videoPhones.put(contact, phonesList);\r\n    isVideoCallEnabled(contact);\r\n    isDesktopSharingEnabled(contact);\r\n    return phonesList;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ProtocolProviderFactoryJabberImpl.installAccount",
	"Comment": "initializes and creates an account corresponding to the specifiedaccountproperties and registers the resulting protocolprovider in thecontext bundlecontext parameter. this method has a persistenteffect. once created the resulting account will remain installed untilremoved through the uninstall account method.",
	"Method": "AccountID installAccount(String userIDStr,Map<String, String> accountProperties){\r\n    BundleContext context = JabberActivator.getBundleContext();\r\n    if (context == null)\r\n        throw new NullPointerException(\"The specified BundleContext was null\");\r\n    if (userIDStr == null)\r\n        throw new NullPointerException(\"The specified AccountID was null\");\r\n    if (accountProperties == null)\r\n        throw new NullPointerException(\"The specified property map was null\");\r\n    accountProperties.put(USER_ID, userIDStr);\r\n    if (accountProperties.get(SERVER_ADDRESS) == null) {\r\n        String serverAddress = StringUtils.parseServer(userIDStr);\r\n        if (serverAddress != null)\r\n            accountProperties.put(SERVER_ADDRESS, StringUtils.parseServer(userIDStr));\r\n        else\r\n            throw new IllegalArgumentException(\"Should specify a server for user name \" + userIDStr + \".\");\r\n    }\r\n    if (accountProperties.get(SERVER_PORT) == null) {\r\n        accountProperties.put(SERVER_PORT, \"5222\");\r\n    }\r\n    AccountID accountID = new JabberAccountIDImpl(userIDStr, accountProperties);\r\n    if (registeredAccounts.containsKey(accountID))\r\n        throw new IllegalStateException(\"An account for id \" + userIDStr + \" was already installed!\");\r\n    this.storeAccount(accountID, false);\r\n    accountID = loadAccount(accountProperties);\r\n    return accountID;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.TestOperationSetPresence.testChangingStateToOnline",
	"Comment": "verify that changing state to online works as supposed to and that itgenerates the corresponding event.",
	"Method": "void testChangingStateToOnline(){\r\n    subtestStateTransition(IcqStatusEnum.ONLINE);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ServerStoredContactList.createContact",
	"Comment": "creates contact for the specified address and inside thespecified group . if creation is successfull event will be fired.",
	"Method": "ContactSipImpl createContact(ContactGroupSipImpl parentGroup,String contactId,boolean persistent,String contactType,ContactSipImpl createContact,ContactGroupSipImpl parentGroup,String contactId,String displayName,boolean persistent,String contactType){\r\n    return createContact(parentGroup, contactId, null, persistent, contactType);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.UIPhoneUtil.getAdditionalMobileNumbers",
	"Comment": "searches for additional phone numbers found in contact information",
	"Method": "List<UIContactDetail> getAdditionalMobileNumbers(){\r\n    return getAdditionalNumbers(true);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommDialog.saveSizeAndLocation",
	"Comment": "saves the size and the location of this dialog through theconfigurationservice.",
	"Method": "void saveSizeAndLocation(){\r\n    try {\r\n        SIPCommFrame.saveSizeAndLocation(this, true, true);\r\n    } catch (ConfigPropertyVetoException e1) {\r\n        logger.error(\"The proposed property change \" + \"represents an unacceptable value\");\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactListServiceImpl.removeGroupFromEventIgnoreList",
	"Comment": "removes the group from the group event ignore list so thatevents concerning this group get treated.",
	"Method": "void removeGroupFromEventIgnoreList(String group,ProtocolProviderService ownerProvider){\r\n    if (!isGroupInEventIgnoreList(group, ownerProvider)) {\r\n        return;\r\n    }\r\n    List<ProtocolProviderService> existingProvList = this.groupEventIgnoreList.get(group);\r\n    if (existingProvList.size() < 1) {\r\n        groupEventIgnoreList.remove(group);\r\n    } else {\r\n        existingProvList.remove(ownerProvider);\r\n    }\r\n}"
}, {
	"Path": "net.librec.recommender.cf.BUCMTestCase.testRecommenderRanking",
	"Comment": "test the whole rating process of bucm recommender in ranking",
	"Method": "void testRecommenderRanking(){\r\n    Configuration.Resource resource = new Configuration.Resource(\"rec/cf/bucm-test.properties\");\r\n    conf.set(\"rec.recommender.isranking\", \"true\");\r\n    conf.addResource(resource);\r\n    RecommenderJob job = new RecommenderJob(conf);\r\n    job.runJob();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.argdelegation.ArgDelegationActivator.stop",
	"Comment": "unsets the delegation peer instance that we set when we start thisbundle.",
	"Method": "void stop(BundleContext bc){\r\n    uiService = null;\r\n    bc.removeServiceListener(delegationPeer);\r\n    delegationPeer = null;\r\n    LaunchArgHandler.getInstance().setDelegationPeer(null);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.neomedia.ZrtpConfigureTableModel.setStandardConfig",
	"Comment": "sets the zrtpconfigure data for this algorithm to a predefined set.the caller prepared active zrtpconfigureto contain a standard set ofalgorithms. get the names and construct a string, then call initializeto setup the inactive zrtpconfigure data.",
	"Method": "void setStandardConfig(){\r\n    StringBuffer algoStr = new StringBuffer();\r\n    for (T sh : active.algos(algorithm)) {\r\n        algoStr.append(sh.name());\r\n        algoStr.append(';');\r\n    }\r\n    initialize(algoStr.toString());\r\n    fireTableRowsUpdated(0, getRowCount());\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.contactsource.ContactReceivedEvent.isShowMoreEnabled",
	"Comment": "returns true if show more label should be shown and false if not.",
	"Method": "boolean isShowMoreEnabled(){\r\n    return showMoreEnabled;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.ConfigurationUtils.getChatRoomStatus",
	"Comment": "returns the last chat room status, saved through theconfigurationservice.",
	"Method": "String getChatRoomStatus(ProtocolProviderService protocolProvider,String chatRoomId){\r\n    String prefix = \"net.java.sip.communicator.impl.gui.accounts\";\r\n    List<String> accounts = configService.getPropertyNamesByPrefix(prefix, true);\r\n    for (String accountRootPropName : accounts) {\r\n        String accountUID = configService.getString(accountRootPropName);\r\n        if (accountUID.equals(protocolProvider.getAccountID().getAccountUniqueID())) {\r\n            List<String> chatRooms = configService.getPropertyNamesByPrefix(accountRootPropName + \".chatRooms\", true);\r\n            for (String chatRoomPropName : chatRooms) {\r\n                String chatRoomID = configService.getString(chatRoomPropName);\r\n                if (!chatRoomId.equals(chatRoomID))\r\n                    continue;\r\n                return configService.getString(chatRoomPropName + \".lastChatRoomStatus\");\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.AdHocChatRoomIcqImpl.getParticipantsCount",
	"Comment": "returns the number of participants that are currently in this chat room.",
	"Method": "int getParticipantsCount(){\r\n    return participants.size();\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.sip.TestAccountUninstallation.testInstallationPersistency",
	"Comment": "stops and removes the tested bundle, verifies that it has unregisteredits provider, then reloads and restarts the bundle and verifies thatthe protocol provider is reregistered in the bundle context.",
	"Method": "void testInstallationPersistency(){\r\n    Bundle providerBundle = SipSlickFixture.findProtocolProviderBundle(fixture.provider1);\r\n    SipSlickFixture.providerBundle = providerBundle;\r\n    assertNotNull(\"Couldn't find a bundle for the tested provider\", providerBundle);\r\n    providerBundle.stop();\r\n    assertTrue(\"Couldn't stop the protocol provider bundle. State was \" + providerBundle.getState(), Bundle.ACTIVE != providerBundle.getState() && Bundle.STOPPING != providerBundle.getState());\r\n    providerBundle.uninstall();\r\n    assertEquals(\"Couldn't stop the protocol provider bundle.\", Bundle.UNINSTALLED, providerBundle.getState());\r\n    ServiceReference[] sipProviderRefs = null;\r\n    try {\r\n        sipProviderRefs = SipSlickFixture.bc.getServiceReferences(ProtocolProviderService.class.getName(), \"(&\" + \"(\" + ProtocolProviderFactory.PROTOCOL + \"=\" + ProtocolNames.SIP + \")\" + \"(\" + ProtocolProviderFactory.USER_ID + \"=\" + fixture.userID1 + \")\" + \")\");\r\n    } catch (InvalidSyntaxException ex) {\r\n        fail(\"We apparently got our filter wrong: \" + ex.getMessage());\r\n    }\r\n    assertTrue(\"A Protocol Provider Service was still regged as an osgi service \" + \"for SIP URI:\" + fixture.userID1 + \"After it was explicitly uninstalled\", sipProviderRefs == null || sipProviderRefs.length == 0);\r\n    assertTrue(\"The SIP provider factory kept a reference to the provider we just \" + \"uninstalled (uri=\" + fixture.userID1 + \")\", fixture.providerFactory.getRegisteredAccounts().isEmpty() && fixture.providerFactory.getProviderForAccount(fixture.provider1.getAccountID()) == null);\r\n    providerBundle = SipSlickFixture.bc.installBundle(providerBundle.getLocation());\r\n    SipSlickFixture.providerBundle = providerBundle;\r\n    assertEquals(\"Couldn't re-install protocol provider bundle.\", Bundle.INSTALLED, providerBundle.getState());\r\n    AccountManagerUtils.startBundleAndWaitStoredAccountsLoaded(SipSlickFixture.bc, providerBundle, ProtocolNames.SIP);\r\n    assertEquals(\"Couldn't re-start protocol provider bundle.\", Bundle.ACTIVE, providerBundle.getState());\r\n    try {\r\n        sipProviderRefs = SipSlickFixture.bc.getServiceReferences(ProtocolProviderService.class.getName(), \"(&\" + \"(\" + ProtocolProviderFactory.PROTOCOL + \"=\" + ProtocolNames.SIP + \")\" + \"(\" + ProtocolProviderFactory.USER_ID + \"=\" + fixture.userID1 + \")\" + \")\");\r\n    } catch (InvalidSyntaxException ex) {\r\n        fail(\"We apparently got our filter wrong \" + ex.getMessage());\r\n    }\r\n    assertTrue(\"A Protocol Provider Service was not restored after being\" + \"reinstalled. SIP URI:\" + fixture.userID1, sipProviderRefs != null && sipProviderRefs.length > 0);\r\n    ServiceReference[] sipFactoryRefs = null;\r\n    try {\r\n        sipFactoryRefs = SipSlickFixture.bc.getServiceReferences(ProtocolProviderFactory.class.getName(), \"(\" + ProtocolProviderFactory.PROTOCOL + \"=\" + ProtocolNames.SIP + \")\");\r\n    } catch (InvalidSyntaxException ex) {\r\n        fail(\"We apparently got our filter wrong \" + ex.getMessage());\r\n    }\r\n    fixture.providerFactory = (ProtocolProviderFactory) SipSlickFixture.bc.getService(sipFactoryRefs[0]);\r\n    fixture.provider1 = (ProtocolProviderService) SipSlickFixture.bc.getService(sipProviderRefs[0]);\r\n    assertTrue(\"The SIP provider did not restore its own reference to the provider \" + \"that we just reinstalled (URI=\" + fixture.userID1 + \")\", !fixture.providerFactory.getRegisteredAccounts().isEmpty() && fixture.providerFactory.getProviderForAccount(fixture.provider1.getAccountID()) != null);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.OneToOneCallPeerPanel.securityPending",
	"Comment": "indicates that the security status is pending confirmation.",
	"Method": "void securityPending(){\r\n    securityStatusLabel.setSecurityPending();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.MetaUIContact.getContactNode",
	"Comment": "returns the corresponding contactnode in the contact listcomponent data model.",
	"Method": "ContactNode getContactNode(){\r\n    return contactNode;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.TestOperationSetPresence.testChangingStateToOccupied",
	"Comment": "verify that changing state to occupied works as supposed to and that itgenerates the corresponding event.",
	"Method": "void testChangingStateToOccupied(){\r\n    subtestStateTransition(IcqStatusEnum.OCCUPIED);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.LowPriorityEventQueue.invokeLater",
	"Comment": "causes runnable to have its run method called in theevent dispatch thread with low priority.",
	"Method": "void invokeLater(Runnable runnable){\r\n    Toolkit defaultToolkit = Toolkit.getDefaultToolkit();\r\n    defaultToolkit.getSystemEventQueue().postEvent(new LowPriorityInvocationEvent(defaultToolkit, runnable));\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.accountinfo.Resources.getString",
	"Comment": "returns an internationalized string corresponding to the given key.",
	"Method": "String getString(String key){\r\n    return getResources().getI18NString(key);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.globalproxyconfig.GlobalProxyConfigForm.saveValues",
	"Comment": "function which save values onto configuration file after save button isclicked",
	"Method": "void saveValues(){\r\n    ConfigurationService configService = GlobalProxyPluginActivator.getConfigurationService();\r\n    if (typeCombo.getSelectedItem().equals(ProxyInfo.ProxyType.NONE)) {\r\n        configService.setProperty(ProxyInfo.CONNECTION_PROXY_TYPE_PROPERTY_NAME, ProxyInfo.ProxyType.NONE.name());\r\n        configService.removeProperty(ProxyInfo.CONNECTION_PROXY_ADDRESS_PROPERTY_NAME);\r\n        configService.removeProperty(ProxyInfo.CONNECTION_PROXY_PORT_PROPERTY_NAME);\r\n        configService.removeProperty(ProxyInfo.CONNECTION_PROXY_USERNAME_PROPERTY_NAME);\r\n        configService.removeProperty(ProxyInfo.CONNECTION_PROXY_PASSWORD_PROPERTY_NAME);\r\n    } else {\r\n        String serverAddress = serverAddressField.getText();\r\n        String port = portField.getText();\r\n        if (serverAddress == null || serverAddress.length() == 0 || port == null || port.length() == 0) {\r\n            return;\r\n        }\r\n        configService.setProperty(ProxyInfo.CONNECTION_PROXY_TYPE_PROPERTY_NAME, ((ProxyInfo.ProxyType) typeCombo.getSelectedItem()).name());\r\n        if (serverAddress != null && serverAddress.length() > 0)\r\n            configService.setProperty(ProxyInfo.CONNECTION_PROXY_ADDRESS_PROPERTY_NAME, serverAddress);\r\n        if (port != null && port.length() > 0)\r\n            configService.setProperty(ProxyInfo.CONNECTION_PROXY_PORT_PROPERTY_NAME, port);\r\n        String username = usernameField.getText();\r\n        if (username != null && username.length() > 0) {\r\n            configService.setProperty(ProxyInfo.CONNECTION_PROXY_USERNAME_PROPERTY_NAME, username);\r\n        } else {\r\n            configService.removeProperty(ProxyInfo.CONNECTION_PROXY_USERNAME_PROPERTY_NAME);\r\n        }\r\n        char[] password = passwordField.getPassword();\r\n        if (password.length > 0) {\r\n            configService.setProperty(ProxyInfo.CONNECTION_PROXY_PASSWORD_PROPERTY_NAME, new String(password));\r\n        } else {\r\n            configService.removeProperty(ProxyInfo.CONNECTION_PROXY_PASSWORD_PROPERTY_NAME);\r\n        }\r\n    }\r\n    if (dnsForwardCheck.isSelected()) {\r\n        configService.setProperty(ProxyInfo.CONNECTION_PROXY_FORWARD_DNS_PROPERTY_NAME, Boolean.TRUE);\r\n        configService.setProperty(ProxyInfo.CONNECTION_PROXY_FORWARD_DNS_ADDRESS_PROPERTY_NAME, dnsForwardServerAddressField.getText().trim());\r\n        configService.setProperty(ProxyInfo.CONNECTION_PROXY_FORWARD_DNS_PORT_PROPERTY_NAME, dnsForwardPortField.getText().trim());\r\n    } else {\r\n        configService.removeProperty(ProxyInfo.CONNECTION_PROXY_FORWARD_DNS_PROPERTY_NAME);\r\n        configService.removeProperty(ProxyInfo.CONNECTION_PROXY_FORWARD_DNS_ADDRESS_PROPERTY_NAME);\r\n        configService.removeProperty(ProxyInfo.CONNECTION_PROXY_FORWARD_DNS_PORT_PROPERTY_NAME);\r\n    }\r\n    GlobalProxyPluginActivator.initProperties();\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.sip.TestOperationSetPresence.suite",
	"Comment": "creates a test suite containing all tests of this class followed bytest methods that we want executed in a specified order.",
	"Method": "Test suite(){\r\n    if (SipSlickFixture.onlineTestingDisabled) {\r\n        TestSuite suite = new TestSuite();\r\n        return suite;\r\n    }\r\n    TestSuite suite = new TestSuite();\r\n    suite.addTest(new TestOperationSetPresence(\"clearLists\"));\r\n    suite.addTest(new TestOperationSetPresence(\"postTestSubscribe\"));\r\n    suite.addTestSuite(TestOperationSetPresence.class);\r\n    suite.addTest(new TestOperationSetPresence(\"postTestUnsubscribe\"));\r\n    return suite;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ChatRoomContactListTransferHandler.canImport",
	"Comment": "indicates whether a component will accept an import of the givenset of data flavors prior to actually attempting to import it. we returntrue to indicate that the transfer with at least one of thegiven flavors would work and false to reject the transfer.",
	"Method": "boolean canImport(JComponent comp,DataFlavor flavor){\r\n    for (int i = 0, n = flavor.length; i < n; i++) {\r\n        if (flavor[i].equals(metaContactDataFlavor)) {\r\n            return true;\r\n        }\r\n    }\r\n    return super.canImport(comp, flavor);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.conference.ConferencePeerPanel.isLocalVideoVisible",
	"Comment": "indicates if the local video component is currently visible.",
	"Method": "boolean isLocalVideoVisible(){\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.contactlist.TestMetaContactGroup.testIndexOf1",
	"Comment": "goes over the contacts in one of the groups and verifies that indexofreturns properly for every one of them.",
	"Method": "void testIndexOf1(){\r\n    MetaContactGroup metaContactGroup = fixture.metaClService.findMetaContactGroupByContactGroup(MetaContactListServiceLick.topLevelMockGroup);\r\n    for (int i = 0; i < metaContactGroup.countChildContacts(); i++) {\r\n        MetaContact currentMetaContact = metaContactGroup.getMetaContact(i);\r\n        assertEquals(\"indexOf failed for \" + currentMetaContact, i, metaContactGroup.indexOf(currentMetaContact));\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.contactlist.TestMetaContactGroup.testIndexOf2",
	"Comment": "goes over the subgroups in one the root group and verifies that indexofreturns properly for every one of them",
	"Method": "void testIndexOf2(){\r\n    MetaContactGroup metaContactGroup = fixture.metaClService.getRoot();\r\n    for (int i = 0; i < metaContactGroup.countSubgroups(); i++) {\r\n        MetaContactGroup currentMetaContactGroup = metaContactGroup.getMetaContactSubgroup(i);\r\n        assertEquals(\"indexOf failed for \" + currentMetaContactGroup, i, metaContactGroup.indexOf(currentMetaContactGroup));\r\n    }\r\n}"
}, {
	"Path": "design.RandomizedCollection.remove",
	"Comment": "removes a value from the collection. returns true if the collection contained the specified element.",
	"Method": "boolean remove(int val){\r\n    if (map.containsKey(val)) {\r\n        Set<Integer> set = map.get(val);\r\n        int valIndex = set.iterator().next();\r\n        set.remove(valIndex);\r\n        if (set.isEmpty()) {\r\n            map.remove(val);\r\n        }\r\n        if (valIndex == list.size() - 1) {\r\n            list.remove(list.size() - 1);\r\n        } else {\r\n            int lastEle = list.get(list.size() - 1);\r\n            map.get(lastEle).remove(list.size() - 1);\r\n            map.get(lastEle).add(valIndex);\r\n            list.set(valIndex, lastEle);\r\n            list.remove(list.size() - 1);\r\n        }\r\n        return true;\r\n    } else\r\n        return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetPresenceSipImpl.cancelTimer",
	"Comment": "cancels the timer which handles all scheduled tasks and disposes of the currently existing tasks scheduled with it.",
	"Method": "void cancelTimer(){\r\n    if (republishTask != null)\r\n        republishTask = null;\r\n    if (pollingTask != null)\r\n        pollingTask = null;\r\n    timer.cancel();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.ProtocolProviderFactory.getProviderForAccount",
	"Comment": "returns the servicereference for the protocol provider corresponding tothe specified accountid or null if the accountid is unknown.",
	"Method": "ServiceReference<ProtocolProviderService> getProviderForAccount(AccountID accountID){\r\n    ServiceRegistration<ProtocolProviderService> registration;\r\n    synchronized (registeredAccounts) {\r\n        registration = registeredAccounts.get(accountID);\r\n    }\r\n    try {\r\n        if (registration != null)\r\n            return registration.getReference();\r\n    } catch (IllegalStateException ise) {\r\n        synchronized (registeredAccounts) {\r\n            registeredAccounts.remove(accountID);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.AbstractCallPeerJabberGTalkImpl.setAddress",
	"Comment": "specifies the address, phone number, or other protocol specificidentifier that represents this call peer. this method is to beused by service users and must not be called by the implementation.",
	"Method": "void setAddress(String address){\r\n    if (!peerJID.equals(address)) {\r\n        String oldAddress = getAddress();\r\n        peerJID = address;\r\n        fireCallPeerChangeEvent(CallPeerChangeEvent.CALL_PEER_ADDRESS_CHANGE, oldAddress, address);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockChatRoom.addMessageListener",
	"Comment": "registers listener so that it would receive events every time anew message is received on this chat room.",
	"Method": "void addMessageListener(ChatRoomMessageListener listener){\r\n    if (!messageListeners.contains(listener))\r\n        messageListeners.add(listener);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.gibberishaccregwizz.GibberishAccountRegistration.isRememberPassword",
	"Comment": "returns true if password has to remembered, falseotherwise.",
	"Method": "boolean isRememberPassword(){\r\n    return rememberPassword;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.addIncomingFileTransferRequest",
	"Comment": "adds the given incomingfiletransferrequest to the conversationpanel in order to notify the user of the incoming file.",
	"Method": "void addIncomingFileTransferRequest(OperationSetFileTransfer fileTransferOpSet,IncomingFileTransferRequest request,Date date){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                addIncomingFileTransferRequest(fileTransferOpSet, request, date);\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    this.addActiveFileTransfer(request.getID(), request);\r\n    ReceiveFileConversationComponent component = new ReceiveFileConversationComponent(this, fileTransferOpSet, request, date);\r\n    if (ConfigurationUtils.isHistoryShown() && !isHistoryLoaded) {\r\n        synchronized (incomingEventBuffer) {\r\n            incomingEventBuffer.add(component);\r\n        }\r\n    } else\r\n        this.getChatConversationPanel().addComponent(component);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.addIncomingFileTransferRequest",
	"Comment": "adds the given incomingfiletransferrequest to the conversationpanel in order to notify the user of the incoming file.",
	"Method": "void addIncomingFileTransferRequest(OperationSetFileTransfer fileTransferOpSet,IncomingFileTransferRequest request,Date date){\r\n    addIncomingFileTransferRequest(fileTransferOpSet, request, date);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.BaseChatRoomSourceContact.generateDefaultContactDetails",
	"Comment": "generates the default contact details forbasechatroomsourcecontact instances.",
	"Method": "List<ContactDetail> generateDefaultContactDetails(String chatRoomName){\r\n    ContactDetail contactDetail = new ContactDetail(chatRoomName);\r\n    List<Class<? extends OperationSet>> supportedOpSets = new ArrayList<Class<? extends OperationSet>>();\r\n    supportedOpSets.add(OperationSetMultiUserChat.class);\r\n    contactDetail.setSupportedOpSets(supportedOpSets);\r\n    List<ContactDetail> contactDetails = new ArrayList<ContactDetail>();\r\n    contactDetails.add(contactDetail);\r\n    return contactDetails;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetBasicTelephonyJabberImpl.getProtocolProvider",
	"Comment": "returns the protocol provider that this operation set belongs to.",
	"Method": "ProtocolProviderServiceJabberImpl getProtocolProvider(){\r\n    return protocolProvider;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ProtocolProviderServiceJabberImpl.throwOperationFailedException",
	"Comment": "logs a specific message and associated throwable cause as anerror using the current logger and then throws a newoperationfailedexception with the message, a specific error codeand the cause.",
	"Method": "void throwOperationFailedException(String message,int errorCode,Throwable cause,Logger logger){\r\n    logger.error(message, cause);\r\n    if (cause == null)\r\n        throw new OperationFailedException(message, errorCode);\r\n    else\r\n        throw new OperationFailedException(message, errorCode, cause);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.usersearch.UserSearchIQ.getFields",
	"Comment": "returns the names of the fields that are not included in the data form.",
	"Method": "Set<String> getFields(){\r\n    return simpleFieldsNames.keySet();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetMultiUserChatJabberImpl.assertSupportedAndConnected",
	"Comment": "makes sure that we are properly connected and that the server supportsmulti user chats.",
	"Method": "void assertSupportedAndConnected(){\r\n    if (!jabberProvider.isRegistered() || !getXmppConnection().isConnected()) {\r\n        throw new OperationFailedException(\"Provider not connected to jabber server\", OperationFailedException.NETWORK_FAILURE);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.TransportManagerJabberImpl.close",
	"Comment": "releases the resources acquired by this transportmanager andprepares it for garbage collection.",
	"Method": "void close(){\r\n    for (MediaType mediaType : MediaType.values()) closeStreamConnector(mediaType);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.AdHocChatRoomInvitationRejectedEvent.getInvitee",
	"Comment": "returns the name of the invitee that rejected the invitation.",
	"Method": "String getInvitee(){\r\n    return invitee;\r\n}"
}, {
	"Path": "com.keybox.manage.db.SessionAuditDB.deleteAuditHistory",
	"Comment": "deletes audit history for users if after time set in properties file",
	"Method": "void deleteAuditHistory(Connection con){\r\n    try {\r\n        Calendar cal = Calendar.getInstance();\r\n        cal.add(Calendar.DATE, (-1 * Integer.parseInt(AppConfig.getProperty(\"deleteAuditLogAfter\"))));\r\n        java.sql.Date date = new java.sql.Date(cal.getTimeInMillis());\r\n        PreparedStatement stmt = con.prepareStatement(\"delete from session_log where session_tm < ?\");\r\n        stmt.setDate(1, date);\r\n        stmt.execute();\r\n        DBUtils.closeStmt(stmt);\r\n    } catch (Exception e) {\r\n        log.error(e.toString(), e);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.filehistory.FileHistoryServiceImpl.findByKeywords",
	"Comment": "returns all the file transfershaving the given keywords in the filename",
	"Method": "Collection<FileRecord> findByKeywords(MetaContact contact,String[] keywords,Collection<FileRecord> findByKeywords,MetaContact contact,String[] keywords,boolean caseSensitive){\r\n    TreeSet<FileRecord> result = new TreeSet<FileRecord>(new FileRecordComparator());\r\n    Map<Contact, HistoryReader> readers = getHistoryReaders(contact);\r\n    for (Map.Entry<Contact, HistoryReader> readerEntry : readers.entrySet()) {\r\n        Contact c = readerEntry.getKey();\r\n        HistoryReader reader = readerEntry.getValue();\r\n        Iterator<HistoryRecord> recs = reader.findByKeywords(keywords, SEARCH_FIELD, caseSensitive);\r\n        while (recs.hasNext()) {\r\n            result.add(createFileRecordFromHistoryRecord(recs.next(), c));\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.JingleIQ.getContentForType",
	"Comment": "determines if this packet contains a content with a childmatching the specified contenttype and returns it. returnsnull otherwise. the method is meant to allow to easily extractspecific iq elements like an rtp description for example.",
	"Method": "ContentPacketExtension getContentForType(Class<? extends PacketExtension> contentType){\r\n    synchronized (contentList) {\r\n        for (ContentPacketExtension content : contentList) {\r\n            PacketExtension child = content.getFirstChildOfType(contentType);\r\n            if (child != null)\r\n                return content;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallManager.hangupCalls",
	"Comment": "asynchronously hangs up the calls participating in a specificcallconference.",
	"Method": "void hangupCalls(CallConference conference){\r\n    new HangupCallThread(conference).start();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.callhistory.CallHistorySourceContact.getPresenceStatus",
	"Comment": "returns the status of the source contact. and null if such informationis not available.",
	"Method": "PresenceStatus getPresenceStatus(){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.AbstractOperationSetTelephonyConferencing.createConfCall",
	"Comment": "creates a conference call with the specified callees ascallpeers.",
	"Method": "Call createConfCall(String[] callees,Call createConfCall,String[] callees,CallConference conference){\r\n    List<CalleeAddressT> calleeAddresses = new ArrayList<CalleeAddressT>(callees.length);\r\n    for (String callee : callees) calleeAddresses.add(parseAddressString(callee));\r\n    MediaAwareCallT call = createOutgoingCall();\r\n    if (conference == null)\r\n        conference = call.getConference();\r\n    else\r\n        call.setConference(conference);\r\n    conference.setConferenceFocus(true);\r\n    for (CalleeAddressT calleeAddress : calleeAddresses) doInviteCalleeToCall(calleeAddress, call);\r\n    return call;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.MUCActivator.getCredentialsStorageService",
	"Comment": "returns a reference to a credentialsstorageservice implementationcurrently registered in the bundle context or null if no suchimplementation was found.",
	"Method": "CredentialsStorageService getCredentialsStorageService(){\r\n    if (credentialsService == null) {\r\n        credentialsService = ServiceUtils.getService(bundleContext, CredentialsStorageService.class);\r\n    }\r\n    return credentialsService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.notifsource.NotificationContact.setUnreadMessageCount",
	"Comment": "sets the number of unread messages, this notification is about.",
	"Method": "void setUnreadMessageCount(int count){\r\n    this.unreadMessageCount = count;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.ircaccregwizz.IrcAccountRegistrationWizard.getPageImage",
	"Comment": "implements the accountregistrationwizard.getpageimagemethod. returns the image used to decorate the wizard page",
	"Method": "byte[] getPageImage(){\r\n    return Resources.getImage(Resources.PAGE_IMAGE);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.RtpDescriptionPacketExtension.setBandwidth",
	"Comment": "sets an optional bandwidth element that specifies the allowable orpreferred bandwidth for use by this application type.",
	"Method": "void setBandwidth(BandwidthPacketExtension bandwidth){\r\n    this.bandwidth = bandwidth;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomJabberImpl.fireMemberRoleEvent",
	"Comment": "creates the corresponding chatroommemberrolechangeevent and notifiesall chatroommemberrolelisteners that a chatroommember haschanged its role in this chatroom.",
	"Method": "void fireMemberRoleEvent(ChatRoomMember member,ChatRoomMemberRole previousRole,ChatRoomMemberRole newRole){\r\n    member.setRole(newRole);\r\n    ChatRoomMemberRoleChangeEvent evt = new ChatRoomMemberRoleChangeEvent(this, member, previousRole, newRole);\r\n    if (logger.isTraceEnabled())\r\n        logger.trace(\"Will dispatch the following ChatRoom event: \" + evt);\r\n    Iterable<ChatRoomMemberRoleListener> listeners;\r\n    synchronized (memberRoleListeners) {\r\n        listeners = new ArrayList<ChatRoomMemberRoleListener>(memberRoleListeners);\r\n    }\r\n    for (ChatRoomMemberRoleListener listener : listeners) listener.memberRoleChanged(evt);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.growlnotification.GrowlNotificationServiceImpl.growlNotificationTimedOut",
	"Comment": "this method is called by growl when the growl notification is not clicked",
	"Method": "void growlNotificationTimedOut(Object context){\r\n    if (logger.isTraceEnabled())\r\n        logger.trace(\"Growl notification timed out: \" + context);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.TreeContactList.startSelectedContactChat",
	"Comment": "starts a chat with the currently selected contact if any, otherwisenothing happens. a chat is started with only metacontacts fornow.",
	"Method": "void startSelectedContactChat(){\r\n    TreePath selectionPath = getSelectionPath();\r\n    if (selectionPath != null && selectionPath.getLastPathComponent() instanceof ContactNode) {\r\n        UIContact uiContact = ((ContactNode) selectionPath.getLastPathComponent()).getContactDescriptor();\r\n        if (uiContact instanceof MetaUIContact) {\r\n            GuiActivator.getUIService().getChatWindowManager().startChat((MetaContact) uiContact.getDescriptor());\r\n        } else if (uiContact.getDescriptor() instanceof SourceContact) {\r\n            SourceContact contact = (SourceContact) uiContact.getDescriptor();\r\n            List<ContactDetail> imDetails = contact.getContactDetails(OperationSetBasicInstantMessaging.class);\r\n            List<ContactDetail> mucDetails = contact.getContactDetails(OperationSetMultiUserChat.class);\r\n            if (imDetails != null && imDetails.size() > 0) {\r\n                ProtocolProviderService pps = imDetails.get(0).getPreferredProtocolProvider(OperationSetBasicInstantMessaging.class);\r\n                if (pps != null)\r\n                    GuiActivator.getUIService().getChatWindowManager().startChat(contact.getContactAddress(), pps);\r\n                else\r\n                    GuiActivator.getUIService().getChatWindowManager().startChat(contact.getContactAddress());\r\n            } else if (mucDetails != null && mucDetails.size() > 0) {\r\n                ChatRoomWrapper room = GuiActivator.getMUCService().findChatRoomWrapperFromSourceContact(contact);\r\n                if (room == null) {\r\n                    ProtocolProviderService pps = mucDetails.get(0).getPreferredProtocolProvider(OperationSetMultiUserChat.class);\r\n                    room = GuiActivator.getMUCService().findChatRoomWrapperFromChatRoomID(contact.getContactAddress(), pps);\r\n                    if (room == null) {\r\n                        GuiActivator.getMUCService().createChatRoom(contact.getContactAddress(), pps, new ArrayList<String>(), \"\", false, false, false);\r\n                    }\r\n                }\r\n                if (room != null)\r\n                    GuiActivator.getMUCService().openChatRoom(room);\r\n            } else {\r\n                List<ContactDetail> smsDetails = contact.getContactDetails(OperationSetSmsMessaging.class);\r\n                if (smsDetails != null && smsDetails.size() > 0) {\r\n                    GuiActivator.getUIService().getChatWindowManager().startChat(contact.getContactAddress(), true);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.msoutlook.calendar.CalendarItemTimerTask.getPattern",
	"Comment": "returns the recurringpattern instance associated with the calendar item.",
	"Method": "RecurringPattern getPattern(){\r\n    return pattern;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.SelectScreenDialog.close",
	"Comment": "automatically press the cancel button when this dialog has been escaped.",
	"Method": "void close(boolean escaped){\r\n    if (escaped)\r\n        cancelButton.doClick();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.security.SipSecurityManager.createCcEntryWithNewCredentials",
	"Comment": "obtains user credentials from the security authority for the specifiedrealm and creates a new credentialscacheentry with them.",
	"Method": "CredentialsCacheEntry createCcEntryWithNewCredentials(String realm,int reasonCode){\r\n    CredentialsCacheEntry ccEntry = new CredentialsCacheEntry();\r\n    UserCredentials defaultCredentials = new UserCredentials();\r\n    String authName = accountID.getAccountPropertyString(ProtocolProviderFactory.AUTHORIZATION_NAME);\r\n    if (authName != null && authName.length() > 0)\r\n        defaultCredentials.setUserName(authName);\r\n    else\r\n        defaultCredentials.setUserName(accountID.getUserID());\r\n    UserCredentials newCredentials = getSecurityAuthority().obtainCredentials(accountID.getDisplayName(), defaultCredentials, reasonCode);\r\n    if (newCredentials == null)\r\n        return null;\r\n    if (newCredentials.getPassword() == null)\r\n        return null;\r\n    ccEntry.userCredentials = newCredentials;\r\n    if (ccEntry.userCredentials != null && ccEntry.userCredentials.isPasswordPersistent())\r\n        SipActivator.getProtocolProviderFactory().storePassword(accountID, ccEntry.userCredentials.getPasswordAsString());\r\n    return ccEntry;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.contactlist.TestMetaContactListPersistence.suite",
	"Comment": "returns tests in this class in the order that they are supposed to beexecuted.",
	"Method": "Test suite(){\r\n    TestSuite suite = new TestSuite();\r\n    suite.addTest(new TestMetaContactListPersistence(\"testCreateAndMoveMetaContact\"));\r\n    suite.addTest(new TestMetaContactListPersistence(\"testReloadMetaContactListBundle\"));\r\n    suite.addTest(new TestMetaContactListPersistence(\"testPartialContactListRestauration\"));\r\n    suite.addTest(new TestMetaContactListPersistence(\"testCompleteContactListRestauration\"));\r\n    suite.addTest(new TestMetaContactListPersistence(\"testPurgeLocalContactListCopy\"));\r\n    return suite;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.keybindings.KeybindingsServiceImpl.getGlobalShortcutFromConfiguration",
	"Comment": "returns list of global shortcuts from the configuration file.",
	"Method": "Map<String, List<AWTKeyStroke>> getGlobalShortcutFromConfiguration(){\r\n    Map<String, List<AWTKeyStroke>> gBindings = new LinkedHashMap<String, List<AWTKeyStroke>>();\r\n    ConfigurationService configService = KeybindingsActivator.getConfigService();\r\n    String shortcut = null;\r\n    String shortcut2 = null;\r\n    String propName = null;\r\n    String propName2 = null;\r\n    String[] names = new String[] { \"answer\", \"hangup\", \"answer_hangup\", \"contactlist\", \"mute\", \"push_to_talk\" };\r\n    Object configured = configService.getProperty(\"net.java.sip.communicator.impl.keybinding.global.configured\");\r\n    if (configured == null) {\r\n        for (String name : names) {\r\n            List<AWTKeyStroke> kss = new ArrayList<AWTKeyStroke>();\r\n            propName = DEFAULTS_VALUES_PATH + \".\" + name + \".1\";\r\n            shortcut = propName != null ? KeybindingsActivator.getResourceService().getSettingsString(propName) : null;\r\n            if (shortcut != null) {\r\n                kss.add(AWTKeyStroke.getAWTKeyStroke(shortcut));\r\n            }\r\n            gBindings.put(name, kss);\r\n        }\r\n        configService.setProperty(\"net.java.sip.communicator.impl.keybinding.global.configured\", \"true\");\r\n        return gBindings;\r\n    }\r\n    for (String name : names) {\r\n        List<AWTKeyStroke> kss = new ArrayList<AWTKeyStroke>();\r\n        propName = CONFIGURATION_PATH + \".\" + name + \".1\";\r\n        propName2 = CONFIGURATION_PATH + \".\" + name + \".2\";\r\n        shortcut = propName != null ? (String) configService.getProperty(propName) : null;\r\n        shortcut2 = propName2 != null ? (String) configService.getProperty(propName2) : null;\r\n        if (shortcut != null) {\r\n            kss.add(AWTKeyStroke.getAWTKeyStroke(shortcut));\r\n        }\r\n        if (shortcut2 != null) {\r\n            int nb = Integer.parseInt(shortcut2);\r\n            kss.add(AWTKeyStroke.getAWTKeyStroke(nb, 16367));\r\n        }\r\n        gBindings.put(name, kss);\r\n    }\r\n    return gBindings;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapDirectoryImpl.hashCode",
	"Comment": "we override the equals method so we also do forhashcode to keep consistent behavior",
	"Method": "int hashCode(){\r\n    return this.settings.getName().hashCode();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.SearchField.filterQueryFinished",
	"Comment": "performs all needed updates when a filter query has finished.",
	"Method": "void filterQueryFinished(FilterQuery query,boolean hasResults){\r\n    enableUnknownContactView(!hasResults);\r\n    query.setQueryListener(null);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.branding.AboutWindow.showAboutWindow",
	"Comment": "shows a aboutwindow creating it first if necessary. theshown instance is shared in order to prevent displaying multipleinstances of one and the same aboutwindow.",
	"Method": "void showAboutWindow(){\r\n    if (aboutWindow == null) {\r\n        aboutWindow = new AboutWindow(null);\r\n        aboutWindow.addWindowListener(new WindowAdapter() {\r\n            @Override\r\n            public void windowClosed(WindowEvent e) {\r\n                if (aboutWindow == e.getWindow())\r\n                    aboutWindow = null;\r\n            }\r\n        });\r\n    }\r\n    aboutWindow.setVisible(true);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.branding.AboutWindow.showAboutWindow",
	"Comment": "shows a aboutwindow creating it first if necessary. theshown instance is shared in order to prevent displaying multipleinstances of one and the same aboutwindow.",
	"Method": "void showAboutWindow(){\r\n    if (aboutWindow == e.getWindow())\r\n        aboutWindow = null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.TransportManagerJabberImpl.getCurrentGeneration",
	"Comment": "returns the generation that our current candidates belong to.",
	"Method": "int getCurrentGeneration(){\r\n    return currentGeneration;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.colibri.ColibriConferenceIQ.getChannelBundles",
	"Comment": "returns a list of the channelbundles included into thisconference iq.",
	"Method": "List<ChannelBundle> getChannelBundles(){\r\n    return Collections.unmodifiableList(channelBundles);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl.isRemoteControlNotification",
	"Comment": "indicates if the given request is a desktop sharing relatedrequest.",
	"Method": "boolean isRemoteControlNotification(Request request){\r\n    if (!request.getMethod().equals(Request.NOTIFY))\r\n        return false;\r\n    byte[] raw = request.getRawContent();\r\n    String content = new String(raw);\r\n    return content.startsWith(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\r\\n\" + \"<remote-control>\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.ErrorDialog.actionPerformed",
	"Comment": "handles the actionevent. depending on the user choice setsthe return code to the appropriate value.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    JButton button = (JButton) e.getSource();\r\n    if (button.equals(okButton))\r\n        this.dispose();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.UriHandlerJabberImpl.serviceChanged",
	"Comment": "the point of implementing a service listener here is so that we wouldonly register our own uri handling service and thus only handle uriswhile the factory is available as an osgi service. we remove ourselveswhen our factory unregisters its service reference.",
	"Method": "void serviceChanged(ServiceEvent event){\r\n    Object sourceService = JabberActivator.bundleContext.getService(event.getServiceReference());\r\n    if (sourceService != protoFactory) {\r\n        return;\r\n    }\r\n    switch(event.getType()) {\r\n        case ServiceEvent.REGISTERED:\r\n            registerHandlerService();\r\n            break;\r\n        case ServiceEvent.UNREGISTERING:\r\n            unregisterHandlerService();\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapFactoryImpl.createQuery",
	"Comment": "required by ldapfactory interface.returns an ldap query, ready to be sent to an ldapdirectory",
	"Method": "LdapQuery createQuery(String query){\r\n    return new LdapQueryImpl(query);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.TreeContactList.dispatchEventToButtons",
	"Comment": "dispatches the given mouse event to the underlying buttons.",
	"Method": "void dispatchEventToButtons(MouseEvent event){\r\n    TreePath mousePath = getPathForLocation(event.getX(), event.getY());\r\n    if (mousePath == null)\r\n        return;\r\n    ContactListTreeCellRenderer renderer = (ContactListTreeCellRenderer) getCellRenderer().getTreeCellRendererComponent(this, mousePath.getLastPathComponent(), getLastSelectedPathComponent() == mousePath.getLastPathComponent(), true, true, getRowForPath(mousePath), true);\r\n    if (!mousePath.equals(getSelectionPath())) {\r\n        renderer.resetRolloverState();\r\n        this.repaint();\r\n        return;\r\n    }\r\n    Rectangle r = this.getPathBounds(mousePath);\r\n    int translatedX = event.getX() - r.x;\r\n    int translatedY = event.getY() - r.y;\r\n    Component mouseComponent = renderer.findComponentAt(translatedX, translatedY);\r\n    if (logger.isDebugEnabled() && mouseComponent != null)\r\n        logger.debug(\"DISPATCH MOUSE EVENT TO COMPONENT: \" + mouseComponent.getClass().getName() + \" with bounds: \" + mouseComponent.getBounds() + \" for x: \" + translatedX + \" and y: \" + translatedY);\r\n    if (mouseComponent instanceof SIPCommButton) {\r\n        MouseEvent evt = new // we're in the button for sure\r\n        MouseEvent(// we're in the button for sure\r\n        mouseComponent, // we're in the button for sure\r\n        event.getID(), // we're in the button for sure\r\n        event.getWhen(), event.getModifiers(), 5, 5, event.getClickCount(), event.isPopupTrigger());\r\n        ((SIPCommButton) mouseComponent).getModel().setRollover(event.getID() == MouseEvent.MOUSE_MOVED);\r\n        if (event.getID() == MouseEvent.MOUSE_RELEASED && event.getClickCount() < 2 && previouslySelectedNode instanceof GroupNode) {\r\n            previouslySelectedNode = null;\r\n        }\r\n        renderer.resetRolloverState(mouseComponent);\r\n        mouseComponent.dispatchEvent(evt);\r\n    } else {\r\n        renderer.resetRolloverState();\r\n    }\r\n    this.repaint();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.JabberActivator.getGlobalDisplayDetailsService",
	"Comment": "returns the globaldisplaydetailsservice obtained from the bundlecontext.",
	"Method": "GlobalDisplayDetailsService getGlobalDisplayDetailsService(){\r\n    if (globalDisplayDetailsService == null) {\r\n        globalDisplayDetailsService = ServiceUtils.getService(bundleContext, GlobalDisplayDetailsService.class);\r\n    }\r\n    return globalDisplayDetailsService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.sipaccregwizz.SIPAccountRegistrationWizard.getRegistration",
	"Comment": "returns the registration object, which will store all the data throughthe wizard.",
	"Method": "SIPAccountRegistration getRegistration(){\r\n    return registration;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.OneToOneCallPeerPanel.isComponentEnabled",
	"Comment": "tests a provided boolean property name, returning false if it should behidden.",
	"Method": "boolean isComponentEnabled(String componentHidePropertyName){\r\n    return !GuiActivator.getConfigurationService().getBoolean(componentHidePropertyName, false);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.MetaContactListSource.metaContactGroupModified",
	"Comment": "notifies the tree model, when a metacontactgroup has beenmodified in the metacontactlistservice.",
	"Method": "void metaContactGroupModified(MetaContactGroupEvent evt){\r\n    final MetaContactGroup metaGroup = evt.getSourceMetaContactGroup();\r\n    UIGroupImpl uiGroup;\r\n    synchronized (metaGroup) {\r\n        uiGroup = MetaContactListSource.getUIGroup(metaGroup);\r\n    }\r\n    if (uiGroup != null) {\r\n        synchronized (uiGroup) {\r\n            GroupNode groupNode = uiGroup.getGroupNode();\r\n            if (groupNode != null)\r\n                GuiActivator.getContactList().getTreeModel().nodeChanged(groupNode);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.credentialsstorage.CredentialsStorageServiceImpl.movePasswordProperty",
	"Comment": "asks for master password if needed, encrypts the password, saves it tothe new property and removes the old property.",
	"Method": "boolean movePasswordProperty(String accountPrefix,String password){\r\n    if (createCrypto()) {\r\n        try {\r\n            setEncrypted(accountPrefix, crypto.encrypt(password));\r\n            setUnencrypted(accountPrefix, null);\r\n            return true;\r\n        } catch (CryptoException cex) {\r\n            logger.debug(\"Encryption failed\", cex);\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapActivator.registerContactSource",
	"Comment": "enable contact source service with specified ldap directory.",
	"Method": "ContactSourceService registerContactSource(LdapDirectory ldapDir){\r\n    LdapContactSourceService css = new LdapContactSourceService(ldapDir);\r\n    ServiceRegistration cssServiceRegistration = null;\r\n    try {\r\n        cssServiceRegistration = bundleContext.registerService(ContactSourceService.class.getName(), css, null);\r\n    } finally {\r\n        if (cssServiceRegistration == null) {\r\n            css.stop();\r\n            css = null;\r\n        } else {\r\n            cssList.put(css, cssServiceRegistration);\r\n        }\r\n    }\r\n    return css;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.globalshortcut.GlobalShortcutServiceImpl.getSpecialKey",
	"Comment": "get special keystroke or null if not supported or user cancels. if nospecial key is detected for 5 seconds, it returns null",
	"Method": "AWTKeyStroke getSpecialKey(){\r\n    AWTKeyStroke ret = null;\r\n    specialKeyDetected = null;\r\n    keyboardHook.detectSpecialKeyPress(true);\r\n    if (OSUtils.IS_WINDOWS) {\r\n        synchronized (specialKeySyncRoot) {\r\n            try {\r\n                specialKeySyncRoot.wait(5000);\r\n            } catch (InterruptedException e) {\r\n            }\r\n        }\r\n        ret = specialKeyDetected;\r\n        specialKeyDetected = null;\r\n    }\r\n    keyboardHook.detectSpecialKeyPress(false);\r\n    return ret;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.conference.VideoConferenceCallPanel.updateConferenceMemberContainers",
	"Comment": "updates the conferenceparticipantcontainers which depict theconferencemembers of the callpeer depicted by aspecific conferenceparticipantcontainer.",
	"Method": "void updateConferenceMemberContainers(ConferenceParticipantContainer cpc,List<Component> videos,OperationSetVideoTelephony videoTelephony){\r\n    CallPeer callPeer = (CallPeer) cpc.getParticipant();\r\n    List<ConferenceParticipantContainer> cmcs = cpc.conferenceMemberContainers;\r\n    if (cmcs != null) {\r\n        for (ConferenceParticipantContainer cmc : cmcs) cmc.toBeRemoved = true;\r\n    }\r\n    if (videos != null) {\r\n        Component video = cpc.getVideo();\r\n        for (Component conferenceMemberVideo : videos) {\r\n            if (conferenceMemberVideo == video)\r\n                continue;\r\n            boolean addNewConferenceParticipantContainer = true;\r\n            ConferenceMember conferenceMember = videoTelephony.getConferenceMember(callPeer, conferenceMemberVideo);\r\n            if (cmcs == null) {\r\n                cmcs = new LinkedList<ConferenceParticipantContainer>();\r\n                cpc.conferenceMemberContainers = cmcs;\r\n            } else {\r\n                for (ConferenceParticipantContainer cmc : cmcs) {\r\n                    Object cmcParticipant = cmc.getParticipant();\r\n                    if (conferenceMember == null) {\r\n                        if (cmcParticipant == callPeer) {\r\n                            Component cmcVideo = cmc.getVideo();\r\n                            if (cmcVideo == null) {\r\n                                cmc.setVideo(conferenceMemberVideo);\r\n                                cmc.toBeRemoved = false;\r\n                                addNewConferenceParticipantContainer = false;\r\n                                break;\r\n                            } else if (cmcVideo == conferenceMemberVideo) {\r\n                                cmc.toBeRemoved = false;\r\n                                addNewConferenceParticipantContainer = false;\r\n                                break;\r\n                            }\r\n                        }\r\n                    } else if (cmcParticipant == conferenceMember) {\r\n                        cmc.setVideo(conferenceMemberVideo);\r\n                        cmc.toBeRemoved = false;\r\n                        addNewConferenceParticipantContainer = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (addNewConferenceParticipantContainer) {\r\n                ConferenceParticipantContainer cmc = (conferenceMember == null) ? new ConferenceParticipantContainer(callPeer, conferenceMemberVideo) : new ConferenceParticipantContainer(conferenceMember, conferenceMemberVideo);\r\n                cmcs.add(cmc);\r\n            }\r\n        }\r\n    }\r\n    List<ConferenceMember> conferenceMembers = callPeer.getConferenceMembers();\r\n    if (!conferenceMembers.isEmpty()) {\r\n        if (cmcs == null) {\r\n            cmcs = new LinkedList<ConferenceParticipantContainer>();\r\n            cpc.conferenceMemberContainers = cmcs;\r\n        }\r\n        for (ConferenceMember conferenceMember : conferenceMembers) {\r\n            if (isConferenceMemberCallPeer(conferenceMember, callPeer))\r\n                continue;\r\n            if (isConferenceMemberLocalUser(conferenceMember))\r\n                continue;\r\n            boolean addNewConferenceParticipantContainer = true;\r\n            for (ConferenceParticipantContainer cmc : cmcs) {\r\n                if (cmc.getParticipant() == conferenceMember) {\r\n                    if (cmc.toBeRemoved && !conferenceMember.getVideoStatus().allowsSending()) {\r\n                        cmc.setVideo(null);\r\n                        cmc.toBeRemoved = false;\r\n                    }\r\n                    addNewConferenceParticipantContainer = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (addNewConferenceParticipantContainer) {\r\n                ConferenceParticipantContainer cmc = new ConferenceParticipantContainer(conferenceMember, null);\r\n                cmcs.add(cmc);\r\n            }\r\n        }\r\n    }\r\n    if ((cmcs != null) && !cmcs.isEmpty()) {\r\n        removeConferenceMemberContainers(cpc, false);\r\n        if (UIVideoHandler2.isAncestor(this, cpc.getComponent()))\r\n            addConferenceMemberContainers(cpc);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.IcqTesterAgent.getPresneceStatus",
	"Comment": "queries the aim server for our own status and returns accordingly.",
	"Method": "IcqStatusEnum getPresneceStatus(){\r\n    return getBuddyStatus(getIcqUIN());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.lookandfeel.SIPCommToggleButtonUI.installDefaults",
	"Comment": "installs default configurations for the given abstractbutton.",
	"Method": "void installDefaults(AbstractButton b){\r\n    super.installDefaults(b);\r\n    b.setOpaque(false);\r\n    b.setBorderPainted(false);\r\n    b.setFocusPainted(true);\r\n}"
}, {
	"Path": "io.lettuce.core.protocol.ConnectionWatchdog.setReconnectSuspended",
	"Comment": "suspend reconnection temporarily. reconnect suspension will interrupt reconnection attempts.",
	"Method": "void setReconnectSuspended(boolean reconnectSuspended){\r\n    reconnectionHandler.setReconnectSuspended(reconnectSuspended);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetTelephonyConferencingSipImpl.inviteCompleted",
	"Comment": "notifies this methodprocessorlistener that the procedure forhandling an invite or reinvite sip request has completed and itis appropriate to determine whether the remote callpeer is aconference focus.",
	"Method": "void inviteCompleted(CallPeerSipImpl sourceCallPeer,Message remoteMessage,Message localMessage){\r\n    ContactHeader contactHeader = (ContactHeader) remoteMessage.getHeader(ContactHeader.NAME);\r\n    boolean conferenceFocus = false;\r\n    if (contactHeader != null) {\r\n        Iterator<?> parameterNameIter = contactHeader.getParameterNames();\r\n        while (parameterNameIter.hasNext()) if (\"isfocus\".equalsIgnoreCase(parameterNameIter.next().toString())) {\r\n            conferenceFocus = true;\r\n            break;\r\n        }\r\n    }\r\n    sourceCallPeer.addCallPeerListener(callPeerStateListener);\r\n    sourceCallPeer.setConferenceFocus(conferenceFocus);\r\n    if (sourceCallPeer.isConferenceFocus() && sourceCallPeer.getState() == CallPeerState.CONNECTED) {\r\n        ConferenceSubscriberSubscription subscription = new ConferenceSubscriberSubscription(sourceCallPeer);\r\n        try {\r\n            subscriber.subscribe(subscription);\r\n        } catch (OperationFailedException ofe) {\r\n            logger.error(\"Failed to create or send a conference subscription to \" + sourceCallPeer, ofe);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.lettuce.core.cluster.models.partitions.Partitions.updateCache",
	"Comment": "update the partition cache. updates are necessary after the partition details have changed.",
	"Method": "void updateCache(){\r\n    synchronized (partitions) {\r\n        if (partitions.isEmpty()) {\r\n            this.slotCache = EMPTY;\r\n            this.nodeReadView = Collections.emptyList();\r\n            return;\r\n        }\r\n        RedisClusterNode[] slotCache = new RedisClusterNode[SlotHash.SLOT_COUNT];\r\n        List<RedisClusterNode> readView = new ArrayList(partitions.size());\r\n        for (RedisClusterNode partition : partitions) {\r\n            readView.add(partition);\r\n            for (Integer integer : partition.getSlots()) {\r\n                slotCache[integer.intValue()] = partition;\r\n            }\r\n        }\r\n        this.slotCache = slotCache;\r\n        this.nodeReadView = Collections.unmodifiableCollection(readView);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.AbstractCallJabberGTalkImpl.containsSID",
	"Comment": "determines if this call contains a peer whose corresponding session hasthe specified sid.",
	"Method": "boolean containsSID(String sid){\r\n    return (getPeer(sid) != null);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.login.LoginRendererSwingImpl.stopConnectingUI",
	"Comment": "stops the connecting user interface for the given protocol provider.",
	"Method": "void stopConnectingUI(ProtocolProviderService protocolProvider){\r\n    mainFrame.getAccountStatusPanel().stopConnecting(protocolProvider);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.filetransfer.SendFileConversationComponent.statusChanged",
	"Comment": "handles file transfer status changes. updates the interface to reflectthe changes.",
	"Method": "void statusChanged(FileTransferStatusChangeEvent event){\r\n    FileTransfer fileTransfer = event.getFileTransfer();\r\n    int status = event.getNewStatus();\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                statusChanged(event);\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    if (status == FileTransferStatusChangeEvent.COMPLETED || status == FileTransferStatusChangeEvent.CANCELED || status == FileTransferStatusChangeEvent.FAILED || status == FileTransferStatusChangeEvent.REFUSED) {\r\n        parentChatPanel.removeActiveFileTransfer(fileTransfer.getID());\r\n        fileTransfer.removeStatusListener(this);\r\n    }\r\n    if (status == FileTransferStatusChangeEvent.PREPARING) {\r\n        hideProgressRelatedComponents();\r\n        titleLabel.setText(dateString + resources.getI18NString(\"service.gui.FILE_TRANSFER_PREPARING\", new String[] { toContactName }));\r\n        cancelButton.setVisible(true);\r\n        retryButton.setVisible(false);\r\n    } else if (status == FileTransferStatusChangeEvent.FAILED) {\r\n        setFailed();\r\n        retryButton.setVisible(true);\r\n    } else if (status == FileTransferStatusChangeEvent.IN_PROGRESS) {\r\n        titleLabel.setText(dateString + resources.getI18NString(\"service.gui.FILE_SENDING_TO\", new String[] { toContactName }));\r\n        setWarningStyle(false);\r\n        if (!progressBar.isVisible()) {\r\n            progressBar.setVisible(true);\r\n        }\r\n        cancelButton.setVisible(true);\r\n        retryButton.setVisible(false);\r\n    } else if (status == FileTransferStatusChangeEvent.COMPLETED) {\r\n        hideProgressRelatedComponents();\r\n        titleLabel.setText(dateString + resources.getI18NString(\"service.gui.FILE_SEND_COMPLETED\", new String[] { toContactName }));\r\n        cancelButton.setVisible(false);\r\n        retryButton.setVisible(false);\r\n        openFileButton.setVisible(true);\r\n        openFolderButton.setVisible(true);\r\n    } else if (status == FileTransferStatusChangeEvent.CANCELED) {\r\n        hideProgressRelatedComponents();\r\n        titleLabel.setText(dateString + resources.getI18NString(\"service.gui.FILE_TRANSFER_CANCELED\"));\r\n        cancelButton.setVisible(false);\r\n        retryButton.setVisible(true);\r\n        setWarningStyle(true);\r\n    } else if (status == FileTransferStatusChangeEvent.REFUSED) {\r\n        hideProgressRelatedComponents();\r\n        titleLabel.setText(dateString + resources.getI18NString(\"service.gui.FILE_SEND_REFUSED\", new String[] { toContactName }));\r\n        cancelButton.setVisible(false);\r\n        retryButton.setVisible(true);\r\n        setWarningStyle(true);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.filetransfer.SendFileConversationComponent.statusChanged",
	"Comment": "handles file transfer status changes. updates the interface to reflectthe changes.",
	"Method": "void statusChanged(FileTransferStatusChangeEvent event){\r\n    statusChanged(event);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetFileTransferIcqImpl.fireFileTransferRequestCanceled",
	"Comment": "delivers the specified event to all registered file transfer listeners.",
	"Method": "void fireFileTransferRequestCanceled(FileTransferRequestEvent event){\r\n    Iterator<FileTransferListener> listeners = null;\r\n    synchronized (fileTransferListeners) {\r\n        listeners = new ArrayList<FileTransferListener>(fileTransferListeners).iterator();\r\n    }\r\n    while (listeners.hasNext()) {\r\n        FileTransferListener listener = listeners.next();\r\n        listener.fileTransferRequestCanceled(event);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.MainFrame.getAccountDisplayName",
	"Comment": "returns the account user display name for the given protocol provider.",
	"Method": "String getAccountDisplayName(ProtocolProviderService protocolProvider){\r\n    final OperationSetServerStoredAccountInfo accountInfoOpSet = protocolProvider.getOperationSet(OperationSetServerStoredAccountInfo.class);\r\n    try {\r\n        if (accountInfoOpSet != null) {\r\n            String displayName = AccountInfoUtils.getDisplayName(accountInfoOpSet);\r\n            if (displayName != null && displayName.length() > 0)\r\n                return displayName;\r\n        }\r\n    } catch (Throwable e) {\r\n        logger.error(\"Cannot obtain display name through OPSet\");\r\n    }\r\n    return protocolProvider.getAccountID().getDisplayName();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.DesktopUtilActivator.getUIService",
	"Comment": "gets the uiservice instance registered in thebundlecontext of the utilactivator.",
	"Method": "UIService getUIService(){\r\n    if (uiService == null)\r\n        uiService = ServiceUtils.getService(bundleContext, UIService.class);\r\n    return uiService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWritePanel.mouseClicked",
	"Comment": "opens the writepanelrightbuttonmenu when user clicks with theright mouse button on the editor area.",
	"Method": "void mouseClicked(MouseEvent e){\r\n    if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0 || (e.isControlDown() && !e.isMetaDown())) {\r\n        Point p = e.getPoint();\r\n        SwingUtilities.convertPointToScreen(p, e.getComponent());\r\n        ArrayList<JMenuItem> contributedMenuEntries = new ArrayList<JMenuItem>();\r\n        for (ChatMenuListener listener : this.menuListeners) {\r\n            contributedMenuEntries.addAll(listener.getMenuElements(this.chatPanel, e));\r\n        }\r\n        for (JMenuItem item : contributedMenuEntries) {\r\n            rightButtonMenu.add(item);\r\n        }\r\n        JPopupMenu rightMenu = rightButtonMenu.makeMenu(contributedMenuEntries);\r\n        rightMenu.setInvoker(editorPane);\r\n        rightMenu.setLocation(p.x, p.y);\r\n        rightMenu.setVisible(true);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ServerStoredContactListIcqImpl.fireContactAdded",
	"Comment": "make the parent persistent presence operation set dispatch a contactadded event.",
	"Method": "void fireContactAdded(ContactGroup parentGroup,Contact contact){\r\n    if (parentOperationSet == null) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"No presence op. set available. Bailing out.\");\r\n        return;\r\n    }\r\n    parentOperationSet.fireSubscriptionEvent(contact, parentGroup, SubscriptionEvent.SUBSCRIPTION_CREATED);\r\n}"
}, {
	"Path": "net.librec.recommender.ext.PersonalityDiagnosisTestCase.testRecommender",
	"Comment": "test the whole process of personality diagnosis recommendation",
	"Method": "void testRecommender(){\r\n    Configuration.Resource resource = new Configuration.Resource(\"rec/ext/personalitydiagnosis-test.properties\");\r\n    conf.addResource(resource);\r\n    RecommenderJob job = new RecommenderJob(conf);\r\n    job.runJob();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.SecurityAccountRegistration.loadEncryptionProtocols",
	"Comment": "loads the list of enabled and disabled encryption protocols with theirpriority into array of string and array of boolean.the protocols are positioned in the array by the priority and theboolean array holds the enabled flag on the corresponding index.",
	"Method": "Object[] loadEncryptionProtocols(Map<String, Integer> encryptionProtocols,Map<String, Boolean> encryptionProtocolStatus){\r\n    int nbEncryptionProtocols = ENCRYPTION_PROTOCOLS.size();\r\n    String[] encryptions = new String[nbEncryptionProtocols];\r\n    boolean[] selectedEncryptions = new boolean[nbEncryptionProtocols];\r\n    for (Map.Entry<String, Integer> e : encryptionProtocols.entrySet()) {\r\n        int index = e.getValue();\r\n        if (index != -1) {\r\n            String name = e.getKey();\r\n            if (isExistingEncryptionProtocol(name)) {\r\n                encryptions[index] = name;\r\n                selectedEncryptions[index] = encryptionProtocolStatus.get(name);\r\n            }\r\n        }\r\n    }\r\n    int j = 0;\r\n    for (String encryptionProtocol : ENCRYPTION_PROTOCOLS) {\r\n        if (!encryptionProtocols.containsKey(encryptionProtocol)) {\r\n            boolean set = false;\r\n            while (j < encryptions.length && !set) {\r\n                if (encryptions[j] == null) {\r\n                    encryptions[j] = encryptionProtocol;\r\n                    selectedEncryptions[j] = encryptionProtocol.equals(\"ZRTP\");\r\n                    set = true;\r\n                }\r\n                ++j;\r\n            }\r\n        }\r\n    }\r\n    return new Object[] { encryptions, selectedEncryptions };\r\n}"
}, {
	"Path": "net.librec.eval.ranking.HitRateEvaluator.evaluate",
	"Comment": "evaluate on the test set with the the list of recommended items.",
	"Method": "double evaluate(RecommendedList groundTruthList,RecommendedList recommendedList){\r\n    if (groundTruthList.size() == 0) {\r\n        return 0.0;\r\n    }\r\n    int totalHits = 0;\r\n    int numContext = groundTruthList.size();\r\n    int nonZeroContext = 0;\r\n    for (int contextIdx = 0; contextIdx < numContext; ++contextIdx) {\r\n        List<KeyValue<Integer, Double>> testListByContext = groundTruthList.getKeyValueListByContext(contextIdx);\r\n        if (testListByContext.size() == 1) {\r\n            int keyTest = testListByContext.get(0).getKey();\r\n            List<KeyValue<Integer, Double>> recommendListByContext = recommendedList.getKeyValueListByContext(contextIdx);\r\n            int topK = this.topN <= recommendListByContext.size() ? this.topN : recommendListByContext.size();\r\n            for (int indexOfKey = 0; indexOfKey < topK; ++indexOfKey) {\r\n                int keyRec = recommendListByContext.get(indexOfKey).getKey();\r\n                if (keyRec == keyTest) {\r\n                    totalHits++;\r\n                    break;\r\n                }\r\n            }\r\n            ++nonZeroContext;\r\n        } else if (testListByContext.size() > 1) {\r\n            throw new IndexOutOfBoundsException(\"It is not a leave-one-out validation method! Please use leave-one-out validation method\");\r\n        }\r\n    }\r\n    return nonZeroContext > 0 ? 1.0 * totalHits / nonZeroContext : 0.0d;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.notification.NotificationServiceImpl.removeEventNotificationAction",
	"Comment": "removes the given actiontype from the list of actions registered for thegiven eventtype.",
	"Method": "void removeEventNotificationAction(String eventType,String actionType){\r\n    Notification notification = notifications.get(eventType);\r\n    if (notification == null)\r\n        return;\r\n    NotificationAction action = notification.getAction(actionType);\r\n    if (action == null)\r\n        return;\r\n    notification.removeAction(actionType);\r\n    saveNotification(eventType, action, false, false);\r\n    fireNotificationActionTypeEvent(ACTION_REMOVED, eventType, action);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.notification.NotificationServiceImpl.stopNotification",
	"Comment": "stops a notification if notification is continuous, like playing soundsin loop. do nothing if there are no such events currently processing.",
	"Method": "void stopNotification(NotificationData data){\r\n    Iterable<NotificationHandler> soundHandlers = getActionHandlers(NotificationAction.ACTION_SOUND);\r\n    if (soundHandlers != null) {\r\n        for (NotificationHandler handler : soundHandlers) {\r\n            if (handler instanceof SoundNotificationHandler)\r\n                ((SoundNotificationHandler) handler).stop(data);\r\n        }\r\n    }\r\n    Iterable<NotificationHandler> vibrateHandlers = getActionHandlers(NotificationAction.ACTION_VIBRATE);\r\n    if (vibrateHandlers != null) {\r\n        for (NotificationHandler handler : vibrateHandlers) {\r\n            ((VibrateNotificationHandler) handler).cancel();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomJabberImpl.removePropertyChangeListener",
	"Comment": "removes listener from the list of listeneres currentregistered for chat room modification events.",
	"Method": "void removePropertyChangeListener(ChatRoomPropertyChangeListener listener){\r\n    synchronized (propertyChangeListeners) {\r\n        propertyChangeListeners.remove(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.osdependent.OsDependentActivator.getGlobalStatusService",
	"Comment": "returns the globalstatusservice obtained from the bundlecontext.",
	"Method": "GlobalStatusService getGlobalStatusService(){\r\n    if (globalStatusService == null) {\r\n        globalStatusService = ServiceUtils.getService(bundleContext, GlobalStatusService.class);\r\n    }\r\n    return globalStatusService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapDirectorySettingsImpl.isPhotoInline",
	"Comment": "gets whether photos are retrieved along with the other attributes.",
	"Method": "boolean isPhotoInline(){\r\n    return this.photoInline;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MclStorageManager.isStarted",
	"Comment": "determines whether the storage manager has been properly started or inother words that it has successfully found and read the xml contact listfile.",
	"Method": "boolean isStarted(){\r\n    return started;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.AdHocConferenceChatTransport.getResourceName",
	"Comment": "returns the resource name of this chat transport. this is for example thename of the user agent from which the contact is logged.",
	"Method": "String getResourceName(){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.ircaccregwizz.FirstWizardPage.loadAccount",
	"Comment": "fills the userid and password fields in this panel with the data comingfrom the given protocolprovider.",
	"Method": "void loadAccount(ProtocolProviderService protocolProvider){\r\n    AccountID accountID = protocolProvider.getAccountID();\r\n    String password = IrcAccRegWizzActivator.getIrcProtocolProviderFactory().loadPassword(accountID);\r\n    String server = accountID.getAccountPropertyString(ProtocolProviderFactory.SERVER_ADDRESS);\r\n    String port = accountID.getAccountPropertyString(ProtocolProviderFactory.SERVER_PORT);\r\n    String autoNickChange = accountID.getAccountPropertyString(ProtocolProviderFactory.AUTO_CHANGE_USER_NAME);\r\n    String noPasswordRequired = accountID.getAccountPropertyString(ProtocolProviderFactory.NO_PASSWORD_REQUIRED);\r\n    boolean useSecureConnection = accountID.getAccountPropertyBoolean(ProtocolProviderFactory.DEFAULT_ENCRYPTION, true);\r\n    boolean resolveDnsThroughProxy = accountID.getAccountPropertyBoolean(IrcAccountRegistrationWizard.RESOLVE_DNS_THROUGH_PROXY, true);\r\n    boolean contactPresenceTaskEnabled = accountID.getAccountPropertyBoolean(IrcAccountRegistrationWizard.CONTACT_PRESENCE_TASK, true);\r\n    boolean chatRoomPresenceTaskEnabled = accountID.getAccountPropertyBoolean(IrcAccountRegistrationWizard.CHAT_ROOM_PRESENCE_TASK, true);\r\n    final boolean enableSaslAuthentication = accountID.getAccountPropertyBoolean(IrcAccountRegistrationWizard.SASL_ENABLED, false);\r\n    final String saslUser = accountID.getAccountPropertyString(IrcAccountRegistrationWizard.SASL_USERNAME, \"\");\r\n    final String saslRole = accountID.getAccountPropertyString(IrcAccountRegistrationWizard.SASL_ROLE, \"\");\r\n    this.userIDField.setEnabled(false);\r\n    this.userIDField.setText(accountID.getUserID());\r\n    this.serverField.setText(server);\r\n    if (password != null) {\r\n        this.passField.setText(password);\r\n        this.rememberPassBox.setSelected(true);\r\n    }\r\n    if (port != null) {\r\n        this.portField.setText(port);\r\n        boolean defaultPort = (useSecureConnection && DEFAULT_SECURE_PORT.equals(port)) || DEFAULT_PLAINTEXT_PORT.equals(port);\r\n        this.portField.setEnabled(!defaultPort);\r\n        this.defaultPort.setSelected(defaultPort);\r\n    }\r\n    if (autoNickChange != null) {\r\n        this.autoNickChange.setSelected(new Boolean(autoNickChange).booleanValue());\r\n    }\r\n    this.resolveDnsThroughProxy.setSelected(resolveDnsThroughProxy);\r\n    if (noPasswordRequired != null) {\r\n        boolean isPassRequired = !Boolean.valueOf(noPasswordRequired);\r\n        this.passwordNotRequired.setSelected(!isPassRequired);\r\n        this.rememberPassBox.setEnabled(isPassRequired);\r\n        passField.setEnabled(isPassRequired);\r\n    }\r\n    this.useSecureConnection.setSelected(useSecureConnection);\r\n    this.enableContactPresenceTask.setSelected(contactPresenceTaskEnabled);\r\n    this.enableChatRoomPresenceTask.setSelected(chatRoomPresenceTaskEnabled);\r\n    this.saslEnabled.setSelected(enableSaslAuthentication);\r\n    this.saslUserIdField.setText(saslUser);\r\n    this.saslRoleField.setText(saslRole);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.MetaContactListManager.getGroupByID",
	"Comment": "returns the meta contact group corresponding to the given metauid.",
	"Method": "MetaContactGroup getGroupByID(String metaUID){\r\n    return GuiActivator.getContactListService().findMetaContactGroupByMetaUID(metaUID);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ContactGroupSipImpl.findContactParent",
	"Comment": "returns the group that is parent of the specified sipcontact ornull if no parent was found.",
	"Method": "ContactGroupSipImpl findContactParent(ContactSipImpl sipContact){\r\n    if (contacts.contains(sipContact)) {\r\n        return this;\r\n    }\r\n    Iterator<ContactGroup> subGroupsIter = subgroups();\r\n    while (subGroupsIter.hasNext()) {\r\n        ContactGroupSipImpl subgroup = (ContactGroupSipImpl) subGroupsIter.next();\r\n        ContactGroupSipImpl parent = subgroup.findContactParent(sipContact);\r\n        if (parent != null)\r\n            return parent;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.MainFrame.initiateProviderIndex",
	"Comment": "checks in the configuration xml if there is already stored index forthis provider and if yes, returns it, otherwise creates a new accountindex and stores it.",
	"Method": "int initiateProviderIndex(ProtocolProviderService protocolProvider){\r\n    ConfigurationService configService = GuiActivator.getConfigurationService();\r\n    String prefix = \"net.java.sip.communicator.impl.gui.accounts\";\r\n    List<String> accounts = configService.getPropertyNamesByPrefix(prefix, true);\r\n    for (String accountRootPropName : accounts) {\r\n        String accountUID = configService.getString(accountRootPropName);\r\n        if (accountUID.equals(protocolProvider.getAccountID().getAccountUniqueID())) {\r\n            String index = configService.getString(accountRootPropName + \".accountIndex\");\r\n            if (index != null) {\r\n                return Integer.parseInt(index);\r\n            } else {\r\n                return createAccountIndex(protocolProvider, accountRootPropName);\r\n            }\r\n        }\r\n    }\r\n    String accNodeName = \"acc\" + Long.toString(System.currentTimeMillis());\r\n    String accountPackage = \"net.java.sip.communicator.impl.gui.accounts.\" + accNodeName;\r\n    configService.setProperty(accountPackage, protocolProvider.getAccountID().getAccountUniqueID());\r\n    return createAccountIndex(protocolProvider, accountPackage);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.notification.NotificationServiceImpl.isActive",
	"Comment": "finds the eventnotification corresponding to the giveneventtype and returns its isactive status.",
	"Method": "boolean isActive(String eventType){\r\n    Notification eventNotification = notifications.get(eventType);\r\n    if (eventNotification == null)\r\n        return false;\r\n    return eventNotification.isActive();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.PayloadTypePacketExtension.addRtcpFeedbackType",
	"Comment": "adds an rtcp feedback type to the list that we already have registeredfor this payload type.",
	"Method": "void addRtcpFeedbackType(RtcpFbPacketExtension rtcpFbPacketExtension){\r\n    addChildExtension(rtcpFbPacketExtension);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.neomedia.CallRecordingConfigForm.insertUpdate",
	"Comment": "gives notification that there was an insert into the document. therange given by the documentevent bounds the freshly inserted region.",
	"Method": "void insertUpdate(DocumentEvent e){\r\n    File insertedFile = new File(callDirTextField.getText());\r\n    if (insertedFile.exists())\r\n        changeCallsDir(insertedFile, false);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.OperationSetPersistentPresenceGibberishImpl.moveContactToGroup",
	"Comment": "removes the specified contact from its current parent and places itunder newparent.",
	"Method": "void moveContactToGroup(Contact contactToMove,ContactGroup newParent){\r\n    ContactGibberishImpl gibberishContact = (ContactGibberishImpl) contactToMove;\r\n    ContactGroupGibberishImpl parentGibberishGroup = findContactParent(gibberishContact);\r\n    parentGibberishGroup.removeContact(gibberishContact);\r\n    if (!gibberishContact.isPersistent()) {\r\n        fireSubscriptionEvent(gibberishContact, parentGibberishGroup, SubscriptionEvent.SUBSCRIPTION_REMOVED);\r\n        try {\r\n            this.subscribe(newParent, contactToMove.getAddress());\r\n            fireSubscriptionEvent(gibberishContact, newParent, SubscriptionEvent.SUBSCRIPTION_CREATED);\r\n        } catch (Exception ex) {\r\n            logger.error(\"Failed to move contact \" + gibberishContact.getAddress(), ex);\r\n        }\r\n    } else {\r\n        ((ContactGroupGibberishImpl) newParent).addContact(gibberishContact);\r\n        fireSubscriptionMovedEvent(contactToMove, parentGibberishGroup, newParent);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.ChatRoomMessageReceivedEvent.getSourceChatRoomMember",
	"Comment": "returns a reference to the chatroommember that has send themessage whose reception this event represents.",
	"Method": "ChatRoomMember getSourceChatRoomMember(){\r\n    return from;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallPanel.getMinimumButtonWidth",
	"Comment": "returns the minimum width needed to show buttons.used to calculate the minimum size of the call dialog.",
	"Method": "int getMinimumButtonWidth(){\r\n    int numberOfButtons = countButtons(settingsPanel.getComponents());\r\n    if (numberOfButtons > 0) {\r\n        return (numberOfButtons + 1) * 32;\r\n    } else\r\n        return -1;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ContactListTreeCellRenderer.isMobile",
	"Comment": "checks whether metacontact has mobile indicator.needs all of the contacts to have it to indicate it.",
	"Method": "boolean isMobile(MetaContact metaContact){\r\n    boolean hasConnectedStatus = false;\r\n    Iterator<Contact> iter = metaContact.getContacts();\r\n    while (iter.hasNext()) {\r\n        Contact contact = iter.next();\r\n        boolean isConnected = contact.getPresenceStatus().isOnline();\r\n        if (isConnected)\r\n            hasConnectedStatus = true;\r\n        if (isConnected && !contact.isMobile())\r\n            return false;\r\n    }\r\n    if (!hasConnectedStatus)\r\n        return false;\r\n    else\r\n        return metaContact.getContactCount() > 0 ? true : false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.RtcpFbPacketExtension.getFeedbackSubtype",
	"Comment": "returns rtcp feedback subtype attribute value if already setor null otherwise.",
	"Method": "String getFeedbackSubtype(){\r\n    return getAttributeAsString(SUBTYPE_ATTR_NAME);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.icqaccregwizz.IcqAccountRegistrationWizard.loadAccount",
	"Comment": "fills the uin and password fields in this panel with the data comingfrom the given protocolprovider.",
	"Method": "void loadAccount(ProtocolProviderService protocolProvider){\r\n    setModification(true);\r\n    this.protocolProvider = protocolProvider;\r\n    this.registration = new IcqAccountRegistration();\r\n    this.firstWizardPage.loadAccount(protocolProvider);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockPersistentPresenceOperationSet.moveContactToGroup",
	"Comment": "removes the specified contact from its current parent and places itunder newparent.",
	"Method": "void moveContactToGroup(Contact contactToMove,ContactGroup newParent){\r\n    MockContact mockContact = (MockContact) contactToMove;\r\n    MockContactGroup parentMockGroup = findContactParent(mockContact);\r\n    parentMockGroup.removeContact(mockContact);\r\n    ((MockContactGroup) newParent).addContact(mockContact);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ProtocolProviderFactoryIcqImpl.loadAccount",
	"Comment": "creates a protocol provider for the given accountid andregisters it in the bundle context. this method has a persistenteffect. once created the resulting account will remain installed untilremoved through the uninstallaccount method.",
	"Method": "AccountID loadAccount(Map<String, String> accountProperties,boolean loadAccount,AccountID accountID){\r\n    boolean accountPropertiesIsAIM = IcqAccountID.isAIM(accountID.getAccountProperties());\r\n    if ((accountPropertiesIsAIM && !isAimFactory) || (!accountPropertiesIsAIM && isAimFactory)) {\r\n        return false;\r\n    }\r\n    return super.loadAccount(accountID);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.AnimatedImage.restart",
	"Comment": "restarts the animation from where the animation was paused. or, if theanimation has finished, it will be restarted from the beginning.",
	"Method": "void restart(){\r\n    if (!timer.isRunning()) {\r\n        if (animationFinished)\r\n            start();\r\n        else\r\n            timer.restart();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaAwareCallPeer.removeConferenceMembersSoundLevelListener",
	"Comment": "removes a specific conferencememberssoundlevellistener of thelist of listeners interested in and notified about changes in conferencemembers sound level.",
	"Method": "void removeConferenceMembersSoundLevelListener(ConferenceMembersSoundLevelListener listener){\r\n    synchronized (conferenceMembersSoundLevelListeners) {\r\n        if (conferenceMembersSoundLevelListeners.remove(listener) && (conferenceMembersSoundLevelListeners.size() == 0)) {\r\n            getMediaHandler().setCsrcAudioLevelListener(null);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.contactlist.TestSupportForMultipleProviders.testAddProviders",
	"Comment": "registers mock providers with the osgi framework and verifies that theyhave been properly configured.",
	"Method": "void testAddProviders(){\r\n    MclSlickFixture.mockP1ServiceRegistration = MetaContactListServiceLick.registerMockProviderService(MclSlickFixture.mockP1);\r\n    MclSlickFixture.mockP2ServiceRegistration = MetaContactListServiceLick.registerMockProviderService(MclSlickFixture.mockP2);\r\n    MclSlickFixture.metaP1Grp1 = fixture.metaClService.findMetaContactGroupByContactGroup(MclSlickFixture.mockP1Grp1);\r\n    assertNotNull(\"The MCL impl ignored a newly added proto provider.\", MclSlickFixture.metaP1Grp1);\r\n    // there's no reason to have empty meta groups here so\r\n    MclSlickFixture.assertGroupEquals(// there's no reason to have empty meta groups here so\r\n    MclSlickFixture.mockP1Grp1, MclSlickFixture.metaP1Grp1, false);\r\n    MclSlickFixture.metaP2Grp1 = fixture.metaClService.findMetaContactGroupByContactGroup(MclSlickFixture.mockP2Grp1);\r\n    assertNotNull(\"The MCL impl ignored a newly added proto provider.\", MclSlickFixture.metaP2Grp1);\r\n    // there's no reason to have empty meta groups here so\r\n    MclSlickFixture.assertGroupEquals(// there's no reason to have empty meta groups here so\r\n    MclSlickFixture.mockP2Grp1, MclSlickFixture.metaP2Grp1, false);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl.createMediaDescription",
	"Comment": "generates an sdp mediadescription for mediadevicetaking account the local streaming preference for the correspondingmedia type.",
	"Method": "MediaDescription createMediaDescription(String transport,List<MediaFormat> formats,StreamConnector connector,MediaDirection direction,List<RTPExtension> extensions){\r\n    return SdpUtils.createMediaDescription(transport, formats, connector, direction, extensions, getDynamicPayloadTypes(), getRtpExtensionsRegistry());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.SingleWindowContainer.setTabIcon",
	"Comment": "sets the given icon to the tab opened for the given chat panel.",
	"Method": "void setTabIcon(ChatPanel chatPanel,Icon icon){\r\n    int index = this.tabbedPane.indexOfComponent(chatPanel);\r\n    this.tabbedPane.setIconAt(index, icon);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.TransportManagerJabberImpl.getNextID",
	"Comment": "returns the id that we will be assigning to the next candidate we create.",
	"Method": "String getNextID(){\r\n    int nextID;\r\n    synchronized (TransportManagerJabberImpl.class) {\r\n        nextID = TransportManagerJabberImpl.nextID++;\r\n    }\r\n    return Integer.toString(nextID);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.CallPeerJabberImpl.getSID",
	"Comment": "returns the session id of the jingle session associated with this call.",
	"Method": "String getSID(){\r\n    return sessionInitIQ != null ? sessionInitIQ.getSID() : null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.DialPadFieldUI.installListeners",
	"Comment": "adds the custom mouse listeners defined in this class to the installedlisteners.",
	"Method": "void installListeners(){\r\n    super.installListeners();\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.UtilActivator.loadLoggingConfig",
	"Comment": "loads logging config if any. need to be loaded in order to activatelogging and need to be activated after bundle context is initialized.",
	"Method": "void loadLoggingConfig(){\r\n    try {\r\n        Class.forName(\"net.java.sip.communicator.util.JavaUtilLoggingConfig\").newInstance();\r\n    } catch (Throwable t) {\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.InfoRetreiver.readHomePageUserInfo",
	"Comment": "method for parsing incoming dataread data in homepageuserinfo command",
	"Method": "void readHomePageUserInfo(MetaHomepageCategoryInfoCmd cmd){\r\n    List<GenericDetail> infoData = getInfoForRequest(cmd.getId());\r\n    String tmp = null;\r\n    try {\r\n        if ((tmp = cmd.getKeywords()) != null)\r\n            infoData.add(new ServerStoredDetails.WebPageDetail(new URL(tmp)));\r\n    } catch (MalformedURLException ex) {\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallManager.isDesktopSharingEnabled",
	"Comment": "indicates if the desktop sharing is currently enabled for the givencall.",
	"Method": "boolean isDesktopSharingEnabled(Call call){\r\n    OperationSetDesktopStreaming desktopOpSet = call.getProtocolProvider().getOperationSet(OperationSetDesktopStreaming.class);\r\n    if (desktopOpSet != null && desktopOpSet.isLocalVideoAllowed(call))\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.TestOperationSetMultiUserChat2.testNickName",
	"Comment": "in testnickname, user nicknames will be changedand we will check if changes are well reflected on both usersides.",
	"Method": "void testNickName(){\r\n    String testRoomName = testRoomBaseName + roomID++;\r\n    ChatRoom opSet1Room = opSetMUC1.createChatRoom(testRoomName, null);\r\n    opSet1Room.join();\r\n    String user1FirstNick = opSet1Room.getUserNickname();\r\n    String user1SecondNick = \"user1nickchange\";\r\n    ChatRoom opSet2Room = opSetMUC2.findRoom(testRoomName);\r\n    opSet2Room.join();\r\n    assertTrue(\"user nickname not found by peer \", nameIsOnMemberList(user1FirstNick, opSet2Room.getMembers()));\r\n    MUCEventCollector opSet2RoomCollector = new MUCEventCollector(opSet2Room, MUCEventCollector.EVENT_PROPERTY);\r\n    opSet1Room.setUserNickname(user1SecondNick);\r\n    assertEquals(\"failed to change user nickname\", user1SecondNick, opSet1Room.getUserNickname());\r\n    assertTrue(\"user nickname not found on member list after modification\", nameIsOnMemberList(user1SecondNick, opSet1Room.getMembers()));\r\n    opSet2RoomCollector.waitForEvent(10000);\r\n    assertEquals(\"no event received since a member changed his nick\", 1, opSet2RoomCollector.collectedEvents.size());\r\n    ChatRoomMemberPropertyChangeEvent changeEvent = (ChatRoomMemberPropertyChangeEvent) opSet2RoomCollector.collectedEvents.get(0);\r\n    assertEquals(\"the change event doesnt comes from the expected member\", fixture.userID1, changeEvent.getSourceChatRoomMember().getContactAddress());\r\n    assertTrue(\"user nickname not found on member list after modification, \" + \"from peer side\", nameIsOnMemberList(user1SecondNick, opSet2Room.getMembers()));\r\n    assertFalse(\"both old and new nick are listed in a room after nick change\", nameIsOnMemberList(user1FirstNick, opSet1Room.getMembers()));\r\n    assertFalse(\"both old and new nick are listed in a room after nick change, \" + \"from the peer side\", nameIsOnMemberList(user1FirstNick, opSet2Room.getMembers()));\r\n    try {\r\n        opSet2Room.setUserNickname(user1SecondNick);\r\n    } catch (OperationFailedException ex) {\r\n    }\r\n    if (opSet1Room.getUserNickname().equals(opSet2Room.getUserNickname())) {\r\n        fail(\"different users are holding the same nick in the same room\");\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.neomedia.CallRecordingConfigForm.actionPerformed",
	"Comment": "indicates that one of the contained in this panel components hasperformed an action.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    Object source = e.getSource();\r\n    if (source == saveCallsToCheckBox) {\r\n        boolean selected = saveCallsToCheckBox.isSelected();\r\n        callDirTextField.setEnabled(selected);\r\n        callDirChooseButton.setEnabled(selected);\r\n        if (selected) {\r\n            try {\r\n                changeCallsDir(NeomediaActivator.getFileAccessService().getDefaultDownloadDirectory(), true);\r\n            } catch (IOException ioex) {\r\n            }\r\n        } else {\r\n            NeomediaActivator.getConfigurationService().setProperty(Recorder.SAVED_CALLS_PATH, null);\r\n            callDirTextField.setText(null);\r\n        }\r\n    } else if (source == callDirChooseButton) {\r\n        File newDir = dirChooser.getFileFromDialog();\r\n        changeCallsDir(newDir, true);\r\n    } else if (source == callDirTextField) {\r\n        File newDir = new File(callDirTextField.getText());\r\n        changeCallsDir(newDir, true);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.resources.ResourceManagementServiceImpl.getImageURLForPath",
	"Comment": "returns the url of the image corresponding to the given path.",
	"Method": "URL getImageURLForPath(String path){\r\n    SkinPack skinPack = getSkinPack();\r\n    if (skinPack != null) {\r\n        if (skinPack.getClass().getClassLoader().getResource(path) != null) {\r\n            return skinPack.getClass().getClassLoader().getResource(path);\r\n        }\r\n    }\r\n    ImagePack imagePack = getImagePack();\r\n    return imagePack.getClass().getClassLoader().getResource(path);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.AbstractOperationSetVideoTelephony.removeVideoListener",
	"Comment": "delegates to the callpeermediahandler of the specifiedcallpeer because the video is provided by it.",
	"Method": "void removeVideoListener(CallPeer peer,VideoListener listener){\r\n    if (listener != null)\r\n        ((W) peer).getMediaHandler().removeVideoListener(listener);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.metahistory.MetaHistoryServiceImpl.findByPeriod",
	"Comment": "returns all the records between the given dates and having the givenkeywords",
	"Method": "Collection<Object> findByPeriod(String[] services,Object descriptor,Date startDate,Date endDate,Collection<Object> findByPeriod,String[] services,Object descriptor,Date startDate,Date endDate,String[] keywords,Collection<Object> findByPeriod,String[] services,Object descriptor,Date startDate,Date endDate,String[] keywords,boolean caseSensitive){\r\n    MessageProgressWrapper listenWrapper = new MessageProgressWrapper(services.length);\r\n    TreeSet<Object> result = new TreeSet<Object>(new RecordsComparator());\r\n    for (int i = 0; i < services.length; i++) {\r\n        String name = services[i];\r\n        Object serv = getService(name);\r\n        if (serv instanceof MessageHistoryService) {\r\n            MessageHistoryService mhs = (MessageHistoryService) serv;\r\n            listenWrapper.setIx(i);\r\n            mhs.addSearchProgressListener(listenWrapper);\r\n            if (descriptor instanceof MetaContact) {\r\n                result.addAll(mhs.findByPeriod((MetaContact) descriptor, startDate, endDate, keywords, caseSensitive));\r\n            } else if (descriptor instanceof ChatRoom) {\r\n                result.addAll(mhs.findByPeriod((ChatRoom) descriptor, startDate, endDate, keywords, caseSensitive));\r\n            }\r\n            mhs.removeSearchProgressListener(listenWrapper);\r\n        } else if (serv instanceof FileHistoryService && descriptor instanceof MetaContact) {\r\n            result.addAll(((FileHistoryService) serv).findByPeriod((MetaContact) descriptor, startDate, endDate, keywords, caseSensitive));\r\n        } else if (serv instanceof CallHistoryService) {\r\n            CallHistoryService chs = (CallHistoryService) serv;\r\n            listenWrapper.setIx(i);\r\n            chs.addSearchProgressListener(listenWrapper);\r\n            Collection<CallRecord> cs = chs.findByPeriod(startDate, endDate);\r\n            Iterator<CallRecord> iter = cs.iterator();\r\n            while (iter.hasNext()) {\r\n                CallRecord callRecord = iter.next();\r\n                if (matchCallPeer(callRecord.getPeerRecords(), keywords, caseSensitive))\r\n                    result.add(callRecord);\r\n            }\r\n            chs.removeSearchProgressListener(listenWrapper);\r\n        }\r\n    }\r\n    listenWrapper.fireLastProgress(startDate, endDate, keywords);\r\n    return result;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.systray.AbstractSystrayService.selectBestPopupMessageHandler",
	"Comment": "sets activepopuphandler to be the one with the highest preference index.",
	"Method": "void selectBestPopupMessageHandler(){\r\n    PopupMessageHandler preferredHandler = null;\r\n    int highestPrefIndex = 0;\r\n    if (!popupHandlerSet.isEmpty()) {\r\n        Enumeration<String> keys = popupHandlerSet.keys();\r\n        while (keys.hasMoreElements()) {\r\n            String handlerName = keys.nextElement();\r\n            PopupMessageHandler h = popupHandlerSet.get(handlerName);\r\n            if (h.getPreferenceIndex() > highestPrefIndex) {\r\n                highestPrefIndex = h.getPreferenceIndex();\r\n                preferredHandler = h;\r\n            }\r\n        }\r\n        setActivePopupMessageHandler(preferredHandler);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.GenericUIContactImpl.setAvatar",
	"Comment": "sets the avatar of this uicontact in the form of animageicon value.",
	"Method": "void setAvatar(ImageIcon avatarIcon){\r\n    this.avatarIcon = avatarIcon;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.SearchField.textRemoved",
	"Comment": "handles the change when a char has been removed from the field.",
	"Method": "void textRemoved(){\r\n    updateContactListView();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.net.SslNetworkLayer.createSSLServerSocket",
	"Comment": "creates an ssl server with the specified port, listen backlog, and localip address to bind to.",
	"Method": "SSLServerSocket createSSLServerSocket(int port,int backlog,InetAddress bindAddress){\r\n    SSLServerSocket sock = (SSLServerSocket) getSSLServerSocketFactory().createServerSocket(port, backlog, bindAddress);\r\n    return sock;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.notifsource.NotificationContact.registrationStateChanged",
	"Comment": "refresh the notification contact corresponding the the attached providerin order to better reflect its state.",
	"Method": "void registrationStateChanged(RegistrationStateChangeEvent evt){\r\n    RegistrationState newState = evt.getNewState();\r\n    if (newState.equals(RegistrationState.UNREGISTERED) || newState.equals(RegistrationState.REGISTERED)) {\r\n        TreeContactList contactList = GuiActivator.getContactList();\r\n        contactList.refreshContact(this);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl.earlyProcessMessage",
	"Comment": "early process an incoming message from interested listeners.",
	"Method": "void earlyProcessMessage(EventObject message){\r\n    synchronized (earlyProcessors) {\r\n        for (SipMessageProcessor listener : earlyProcessors) {\r\n            try {\r\n                if (message instanceof RequestEvent)\r\n                    listener.processMessage((RequestEvent) message);\r\n                else if (message instanceof ResponseEvent)\r\n                    listener.processResponse((ResponseEvent) message, null);\r\n                else if (message instanceof TimeoutEvent)\r\n                    listener.processTimeout((TimeoutEvent) message, null);\r\n            } catch (Throwable t) {\r\n                logger.error(\"Error pre-processing message\", t);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.sipaccregwizz.SIPAccountRegistrationWizard.setRegistration",
	"Comment": "sets the registration object, which will store all the data throughthe wizard.",
	"Method": "void setRegistration(SIPAccountRegistration registration){\r\n    this.registration = registration;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.utils.InviteContactTransferHandler.createTransferable",
	"Comment": "creates a transferable for text pane components in order to enable dragand drop of text.",
	"Method": "Transferable createTransferable(JComponent component){\r\n    if (type != SOURCE_TRANSFER_HANDLER)\r\n        return null;\r\n    if (component instanceof ContactList) {\r\n        List<UIContact> c = ((ContactList) component).getSelectedContacts();\r\n        if (c != null)\r\n            return new UIContactTransferable(c);\r\n    }\r\n    return super.createTransferable(component);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.GroupNode.fireNodesChanged",
	"Comment": "notifies all interested listeners that all nodes have changed.",
	"Method": "void fireNodesChanged(){\r\n    int childCount = getChildCount();\r\n    int[] changedIndexes = new int[childCount];\r\n    for (int i = 0; i < childCount; i++) changedIndexes[i] = i;\r\n    treeModel.nodesChanged(this, changedIndexes);\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.Logger.isInfoEnabled",
	"Comment": "check if a message with an info level would actually be logged by thislogger.",
	"Method": "boolean isInfoEnabled(){\r\n    return loggerDelegate.isLoggable(Level.INFO);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.OneToOneCallPanel.removeDesktopSharingComponents",
	"Comment": "removes all desktop sharing related components from this container.",
	"Method": "void removeDesktopSharingComponents(){\r\n    if (southPanel != null) {\r\n        remove(southPanel);\r\n        enableDesktopRemoteControl.setSelected(false);\r\n    }\r\n    revalidate();\r\n    repaint();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageSourceContact.getPreferredContactDetail",
	"Comment": "returns the preferred contactdetail for a givenoperationset class.",
	"Method": "ContactDetail getPreferredContactDetail(Class<? extends OperationSet> operationSet){\r\n    return contactDetails.get(0);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ScServiceDiscoveryManager.removeFeature",
	"Comment": "removes the specified feature from the supported features by theencapsulated servicediscoverymanager.since no packet is actually sent to the server it is safe to performthis operation before logging to the server.",
	"Method": "void removeFeature(String feature){\r\n    synchronized (features) {\r\n        features.remove(feature);\r\n        discoveryManager.removeFeature(feature);\r\n    }\r\n    updateEntityCapsVersion();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.CallPeerMediaHandlerJabberImpl.processAnswer",
	"Comment": "handles the specified answer by creating and initializing thecorresponding mediastreams.",
	"Method": "void processAnswer(List<ContentPacketExtension> answer){\r\n    processTransportInfo(answer);\r\n    boolean masterStreamSet = false;\r\n    for (ContentPacketExtension content : answer) {\r\n        remoteContentMap.put(content.getName(), content);\r\n        boolean masterStream = false;\r\n        if (!masterStreamSet) {\r\n            if (answer.size() > 1) {\r\n                RtpDescriptionPacketExtension description = JingleUtils.getRtpDescription(content);\r\n                if (MediaType.AUDIO.toString().equals(description.getMedia())) {\r\n                    masterStream = true;\r\n                    masterStreamSet = true;\r\n                }\r\n            } else {\r\n                masterStream = true;\r\n                masterStreamSet = true;\r\n            }\r\n        }\r\n        processContent(content, false, masterStream);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.LoginByClientCertificateStrategy.login",
	"Comment": "performs the login on the xmpp connection using the sasl externalmechanism.",
	"Method": "boolean login(Connection connection,String userName,String resource){\r\n    SASLAuthentication.supportSASLMechanism(\"EXTERNAL\", 0);\r\n    try {\r\n        connection.login(\"\", \"\", resource);\r\n        return true;\r\n    } catch (XMPPException ex) {\r\n        if (ex.getMessage().contains(\"EXTERNAL failed: not-authorized\")) {\r\n            logger.error(\"Certificate login failed\", ex);\r\n            return false;\r\n        }\r\n        throw ex;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactListServiceImpl.loadStoredMetaContact",
	"Comment": "the method is called from the storage manager whenever a new contacthas been parsed and it has to be created.",
	"Method": "MetaContactImpl loadStoredMetaContact(MetaContactGroupImpl parentGroup,String metaUID,String displayName,Map<String, List<String>> details,List<MclStorageManager.StoredProtoContactDescriptor> protoContacts,String accountID){\r\n    MetaContactImpl newMetaContact = (MetaContactImpl) findMetaContactByMetaUID(metaUID);\r\n    if (newMetaContact == null) {\r\n        newMetaContact = new MetaContactImpl(metaUID, details);\r\n        newMetaContact.setDisplayName(displayName);\r\n    }\r\n    ProtocolProviderService sourceProvider = currentlyInstalledProviders.get(accountID);\r\n    OperationSetPersistentPresence presenceOpSet = sourceProvider.getOperationSet(OperationSetPersistentPresence.class);\r\n    for (MclStorageManager.StoredProtoContactDescriptor contactDescriptor : protoContacts) {\r\n        MetaContact mc = findMetaContactByContact(contactDescriptor.contactAddress, accountID);\r\n        if (mc != null) {\r\n            logger.warn(\"Ignoring duplicate proto contact \" + contactDescriptor + \" accountID=\" + accountID + \". The contact was also present in the \" + \"folloing meta contact:\" + mc);\r\n            continue;\r\n        }\r\n        Contact protoContact = presenceOpSet.createUnresolvedContact(contactDescriptor.contactAddress, contactDescriptor.persistentData, (contactDescriptor.parentProtoGroup == null) ? presenceOpSet.getServerStoredContactListRoot() : contactDescriptor.parentProtoGroup);\r\n        newMetaContact.addProtoContact(protoContact);\r\n    }\r\n    if (newMetaContact.getContactCount() == 0) {\r\n        logger.error(\"Found an empty meta contact. Throwing an exception \" + \"so that the storage manager would remove it.\");\r\n        throw new IllegalArgumentException(\"MetaContact[\" + newMetaContact + \"] contains no non-duplicating child contacts.\");\r\n    }\r\n    parentGroup.addMetaContact(newMetaContact);\r\n    fireMetaContactEvent(newMetaContact, parentGroup, MetaContactEvent.META_CONTACT_ADDED);\r\n    if (logger.isTraceEnabled())\r\n        logger.trace(\"Created meta contact: \" + newMetaContact);\r\n    return newMetaContact;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.growlnotification.GrowlNotificationServiceImpl.growlNotificationWasClicked",
	"Comment": "this method is called by growl when the growl notification is clicked",
	"Method": "void growlNotificationWasClicked(Object context){\r\n    new Thread(new Runnable() {\r\n        public void run() {\r\n            firePopupMessageClicked(new SystrayPopupMessageEvent(this, context));\r\n            if (logger.isTraceEnabled())\r\n                logger.trace(\"Growl notification clicked: \" + context);\r\n        }\r\n    }).start();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.growlnotification.GrowlNotificationServiceImpl.growlNotificationWasClicked",
	"Comment": "this method is called by growl when the growl notification is clicked",
	"Method": "void growlNotificationWasClicked(Object context){\r\n    firePopupMessageClicked(new SystrayPopupMessageEvent(this, context));\r\n    if (logger.isTraceEnabled())\r\n        logger.trace(\"Growl notification clicked: \" + context);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.account.AccountList.mouseClicked",
	"Comment": "listens for double mouse click events in order to open the edit form.",
	"Method": "void mouseClicked(MouseEvent e){\r\n    if (e.getClickCount() > 1) {\r\n        editButton.doClick();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ChatRoomContactListTransferHandler.createTransferable",
	"Comment": "creates a transferable for text pane components in order to enable dragand drop of text.",
	"Method": "Transferable createTransferable(JComponent component){\r\n    if (component instanceof JList) {\r\n        JList list = (JList) component;\r\n        return new ContactListTransferable(list.getSelectedIndex(), list.getSelectedValue());\r\n    }\r\n    return super.createTransferable(component);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallPanel.updateViewFromModelInEventDispatchThread",
	"Comment": "updates this view i.e. callpanel so that it depicts the currentstate of its model i.e. callconference. the update is performedin the awt event dispatching thread.",
	"Method": "void updateViewFromModelInEventDispatchThread(){\r\n    if (disposed)\r\n        return;\r\n    Dimension oldPrefSize = getPreferredSize();\r\n    doUpdateViewFromModelInEventDispatchThread();\r\n    Dimension newPrefSize = getPreferredSize();\r\n    if ((newPrefSize != null) && ((newPrefSize.height > getHeight()) || (newPrefSize.width > getWidth()))) {\r\n        int oldPrefHeight, oldPrefWidth;\r\n        if (oldPrefSize == null) {\r\n            oldPrefHeight = 0;\r\n            oldPrefWidth = 0;\r\n        } else {\r\n            oldPrefHeight = oldPrefSize.height;\r\n            oldPrefWidth = oldPrefSize.width;\r\n        }\r\n        if ((newPrefSize.height != oldPrefHeight) || (newPrefSize.width != oldPrefWidth)) {\r\n            ensureSize(this, newPrefSize.width, newPrefSize.height);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetPresenceSipImpl.createUnresolvedContactGroup",
	"Comment": "creates and returns a unresolved contact group from the specifiedaddress and persistentdata. the method will not tryto establish a network connection and resolve the newly createdcontactgroup against the server or the contact itself. theprotocol provider will later resolve the contact group. when this happensthe corresponding event would notify interested subscription listeners.",
	"Method": "ContactGroup createUnresolvedContactGroup(String groupUID,String persistentData,ContactGroup parentGroup){\r\n    if (parentGroup == null) {\r\n        parentGroup = getServerStoredContactListRoot();\r\n    }\r\n    String groupName = ContactGroupSipImpl.createNameFromUID(groupUID);\r\n    return ssContactList.createUnresolvedContactGroup((ContactGroupSipImpl) parentGroup, groupName);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.WhiteboardParticipantState.getStateString",
	"Comment": "returns a string representation of tha whiteboardparticipantste.",
	"Method": "String getStateString(){\r\n    return whiteboardStateStr;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaHandler.setVideoStream",
	"Comment": "sets the videomediastream which this instance is to use to sendand receive video.",
	"Method": "void setVideoStream(VideoMediaStream videoStream){\r\n    if (this.videoStream != videoStream) {\r\n        List<Component> oldVisualComponents = null;\r\n        if (this.videoStream != null) {\r\n            this.videoStream.removePropertyChangeListener(streamPropertyChangeListener);\r\n            this.videoStream.removeVideoListener(videoStreamVideoListener);\r\n            oldVisualComponents = this.videoStream.getVisualComponents();\r\n            setKeyFrameControlFromVideoStream(null);\r\n            this.videoStream.close();\r\n        }\r\n        this.videoStream = videoStream;\r\n        setKeyFrameControlFromVideoStream(this.videoStream);\r\n        long videoLocalSSRC;\r\n        long videoRemoteSSRC;\r\n        List<Component> newVisualComponents = null;\r\n        if (this.videoStream != null) {\r\n            this.videoStream.addPropertyChangeListener(streamPropertyChangeListener);\r\n            videoLocalSSRC = this.videoStream.getLocalSourceID();\r\n            videoRemoteSSRC = this.videoStream.getRemoteSourceID();\r\n            this.videoStream.addVideoListener(videoStreamVideoListener);\r\n            newVisualComponents = this.videoStream.getVisualComponents();\r\n        } else {\r\n            videoLocalSSRC = videoRemoteSSRC = CallPeerMediaHandler.SSRC_UNKNOWN;\r\n        }\r\n        setLocalSSRC(MediaType.VIDEO, videoLocalSSRC);\r\n        setRemoteSSRC(MediaType.VIDEO, videoRemoteSSRC);\r\n        if ((oldVisualComponents != null) && !oldVisualComponents.isEmpty()) {\r\n            if (newVisualComponents == null)\r\n                newVisualComponents = Collections.emptyList();\r\n            for (Component oldVisualComponent : oldVisualComponents) {\r\n                if (!newVisualComponents.remove(oldVisualComponent)) {\r\n                    fireVideoEvent(VideoEvent.VIDEO_REMOVED, oldVisualComponent, VideoEvent.REMOTE);\r\n                }\r\n            }\r\n        }\r\n        if ((newVisualComponents != null) && !newVisualComponents.isEmpty()) {\r\n            for (Component newVisualComponent : newVisualComponents) {\r\n                fireVideoEvent(VideoEvent.VIDEO_ADDED, newVisualComponent, VideoEvent.REMOTE);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallSipImpl.fireCallEvent",
	"Comment": "creates and dispatches a callevent notifying registeredlisteners that an event with id eventid has occurred onsourcecall.",
	"Method": "void fireCallEvent(int eventID,Call sourceCall,Map<MediaType, MediaDirection> mediaDirections){\r\n    CallEvent callEvent = new CallEvent(sourceCall, eventID, mediaDirections);\r\n    if (sourceCall.getCallPeerCount() == 1) {\r\n        CallSipImpl callSip = (CallSipImpl) sourceCall;\r\n        CallPeerSipImpl callPeer = callSip.getCallPeers().next();\r\n        Request request = callPeer.getLatestInviteTransaction().getRequest();\r\n        Header dsHeader = request.getHeader(DS_SHARING_HEADER);\r\n        if (dsHeader != null) {\r\n            callEvent.setDesktopStreaming(true);\r\n        }\r\n    }\r\n    getParentOperationSet().fireCallEvent(callEvent);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.WhiteboardSessionJabberImpl.getSupportedWhiteboardObjects",
	"Comment": "returns all the type of whiteboardobject that this whiteboard support.",
	"Method": "String[] getSupportedWhiteboardObjects(){\r\n    String[] type = new String[8];\r\n    type[0] = WhiteboardObjectPath.NAME;\r\n    type[1] = WhiteboardObjectPolyLine.NAME;\r\n    type[2] = WhiteboardObjectPolygon.NAME;\r\n    type[3] = WhiteboardObjectLine.NAME;\r\n    type[4] = WhiteboardObjectRect.NAME;\r\n    type[5] = WhiteboardObjectCircle.NAME;\r\n    type[6] = WhiteboardObjectText.NAME;\r\n    type[7] = WhiteboardObjectImage.NAME;\r\n    return type;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.propertieseditor.NewPropertyDialog.close",
	"Comment": "presses programmatically the cancel button, when esc key is pressed.",
	"Method": "void close(boolean isEscaped){\r\n    cancelButton.doClick();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.GlobalStatusSelectorBox.addAccount",
	"Comment": "adds a status menu for the account given by protocolprovider.",
	"Method": "void addAccount(ProtocolProviderService protocolProvider){\r\n    if (protocolProvider.getAccountID().isHidden())\r\n        return;\r\n    OperationSetPersistentPresence presenceOpSet = (OperationSetPersistentPresence) protocolProvider.getOperationSet(OperationSetPresence.class);\r\n    JMenuItem itemToAdd;\r\n    if (protocolProvider.getAccountID().isStatusMenuHidden()) {\r\n        itemToAdd = new ReadonlyStatusItem(protocolProvider);\r\n    } else {\r\n        itemToAdd = (presenceOpSet != null) ? new PresenceStatusMenu(protocolProvider) : new SimpleStatusMenu(protocolProvider);\r\n    }\r\n    if (ConfigurationUtils.isHideAccountStatusSelectorsEnabled())\r\n        itemToAdd.setVisible(false);\r\n    if (isFirstAccount) {\r\n        add(itemToAdd);\r\n        isFirstAccount = false;\r\n        if (presenceOpSet != null)\r\n            addAvailableStatuses();\r\n        return;\r\n    }\r\n    boolean isMenuAdded = false;\r\n    AccountID accountId = protocolProvider.getAccountID();\r\n    for (Component c : getPopupMenu().getComponents()) {\r\n        if (!(c instanceof StatusEntry))\r\n            continue;\r\n        StatusEntry menu = (StatusEntry) c;\r\n        int menuIndex = getPopupMenu().getComponentIndex(menu.getEntryComponent());\r\n        AccountID menuAccountID = menu.getProtocolProvider().getAccountID();\r\n        int protocolCompare = accountId.getProtocolDisplayName().compareTo(menuAccountID.getProtocolDisplayName());\r\n        if (protocolCompare < 0) {\r\n            insert(itemToAdd, menuIndex);\r\n            isMenuAdded = true;\r\n            break;\r\n        } else if (protocolCompare == 0) {\r\n            if (accountId.getDisplayName().compareTo(menuAccountID.getDisplayName()) < 0) {\r\n                insert(itemToAdd, menuIndex);\r\n                isMenuAdded = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (!isMenuAdded)\r\n        add(itemToAdd);\r\n    if (presenceOpSet != null)\r\n        addAvailableStatuses();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.presence.AbstractStatusMessageMenu.addPropertyChangeListener",
	"Comment": "add a propertychangelistener to the listener list.the listener is registered for all properties.",
	"Method": "void addPropertyChangeListener(PropertyChangeListener listener){\r\n    synchronized (propertyChangeListeners) {\r\n        if (!propertyChangeListeners.contains(listener))\r\n            propertyChangeListeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.ldap.configform.DirectorySettingsForm.mergeStrings",
	"Comment": "merge string elements from a list to a single string separated by space.",
	"Method": "String mergeStrings(List<String> lst){\r\n    StringBuilder bld = new StringBuilder();\r\n    for (String s : lst) {\r\n        bld.append(s).append(\" \");\r\n    }\r\n    return bld.toString();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.callhistory.CallHistoryServiceImpl.findByPeriod",
	"Comment": "returns all the calls made by all the contactsin the supplied metacontact between the given dates",
	"Method": "Collection<CallRecord> findByPeriod(MetaContact contact,Date startDate,Date endDate,Collection<CallRecord> findByPeriod,Date startDate,Date endDate){\r\n    TreeSet<CallRecord> result = new TreeSet<CallRecord>(new CallRecordComparator());\r\n    try {\r\n        History history = this.getHistory(null, null);\r\n        historyReader = history.getReader();\r\n        addHistorySearchProgressListeners(historyReader, 1);\r\n        QueryResultSet<HistoryRecord> rs = historyReader.findByPeriod(startDate, endDate);\r\n        while (rs.hasNext()) {\r\n            HistoryRecord hr = rs.next();\r\n            result.add(convertHistoryRecordToCallRecord(hr));\r\n        }\r\n        removeHistorySearchProgressListeners(historyReader);\r\n    } catch (IOException ex) {\r\n        logger.error(\"Could not read history\", ex);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.RtpDescriptionPacketExtension.getExtmapList",
	"Comment": "returns a list of the optional extmap elements thatallow negotiating rtp extension headers as per rfc 5282.",
	"Method": "List<RTPHdrExtPacketExtension> getExtmapList(){\r\n    return extmapList;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.EventPackageSupport.getSubscription",
	"Comment": "gets the subscription from the list of subscriptions managed bythis instance which is associated with a specific callid.",
	"Method": "Subscription getSubscription(Address toAddress,String eventId,Subscription getSubscription,String callId){\r\n    synchronized (subscriptions) {\r\n        return subscriptions.get(callId);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ServerStoredContactListJabberImpl.findContactGroup",
	"Comment": "returns the contactgroup containing the specified contact or nullif no such group or contact exist.",
	"Method": "ContactGroupJabberImpl findContactGroup(String name,ContactGroup findContactGroup,ContactJabberImpl child){\r\n    Iterator<ContactGroup> contactGroups = rootGroup.subgroups();\r\n    String contactAddress = child.getAddress();\r\n    while (contactGroups.hasNext()) {\r\n        ContactGroupJabberImpl contactGroup = (ContactGroupJabberImpl) contactGroups.next();\r\n        if (contactGroup.findContact(contactAddress) != null)\r\n            return contactGroup;\r\n    }\r\n    if (rootGroup.findContact(contactAddress) != null)\r\n        return rootGroup;\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.FadeInBalloonPanel.paintComponent",
	"Comment": "overrides the paintcomponent method of jbutton topaint the button background and icon, and all additional effects of thisconfigurable button.",
	"Method": "void paintComponent(Graphics g){\r\n    g = g.create();\r\n    try {\r\n        internalPaintComponent((Graphics2D) g);\r\n    } finally {\r\n        g.dispose();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.ContactlistActivator.getResources",
	"Comment": "returns the resourcemanagementservice, through which we willaccess all resources.",
	"Method": "ResourceManagementService getResources(){\r\n    if (resourcesService == null) {\r\n        resourcesService = ServiceUtils.getService(bundleContext, ResourceManagementService.class);\r\n    }\r\n    return resourcesService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.ConfigurationUtils.isNormalizePhoneNumber",
	"Comment": "returns true if phone numbers should be normalized,false otherwise.",
	"Method": "boolean isNormalizePhoneNumber(){\r\n    return isNormalizePhoneNumber;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.JingleNodesServiceDiscovery.searchServicesWithPrefix",
	"Comment": "searches for services as the prefix list has priority. if it is setreturn after first found service.",
	"Method": "SmackServiceNode.MappedNodes searchServicesWithPrefix(SmackServiceNode service,XMPPConnection xmppConnection,int maxEntries,int maxDepth,int maxSearchNodes,String protocol,boolean searchBuddies,boolean autoDiscover,String prefix){\r\n    if (xmppConnection == null || !xmppConnection.isConnected()) {\r\n        return null;\r\n    }\r\n    SmackServiceNode.MappedNodes mappedNodes = new SmackServiceNode.MappedNodes();\r\n    ConcurrentHashMap<String, String> visited = new ConcurrentHashMap<String, String>();\r\n    for (Map.Entry<String, TrackerEntry> entry : service.getTrackerEntries().entrySet()) {\r\n        SmackServiceNode.deepSearch(xmppConnection, maxEntries, entry.getValue().getJid(), mappedNodes, maxDepth - 1, maxSearchNodes, protocol, visited);\r\n    }\r\n    if (autoDiscover) {\r\n        boolean continueSearch = searchDiscoItems(service, xmppConnection, maxEntries, xmppConnection.getServiceName(), mappedNodes, maxDepth - 1, maxSearchNodes, protocol, visited, prefix);\r\n        if (!continueSearch)\r\n            return mappedNodes;\r\n        SmackServiceNode.deepSearch(xmppConnection, maxEntries, xmppConnection.getHost(), mappedNodes, maxDepth - 1, maxSearchNodes, protocol, visited);\r\n        if (xmppConnection.getRoster() != null && searchBuddies) {\r\n            for (final RosterEntry re : xmppConnection.getRoster().getEntries()) {\r\n                for (final Iterator<Presence> i = xmppConnection.getRoster().getPresences(re.getUser()); i.hasNext(); ) {\r\n                    final Presence presence = i.next();\r\n                    if (presence.isAvailable()) {\r\n                        SmackServiceNode.deepSearch(xmppConnection, maxEntries, presence.getFrom(), mappedNodes, maxDepth - 1, maxSearchNodes, protocol, visited);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.galagonotification.GalagoNotificationActivator.getResources",
	"Comment": "gets the resources such as internationalized and localized text andimages used by the galagonotification bundle.",
	"Method": "ResourceManagementService getResources(){\r\n    if (resources == null)\r\n        resources = ResourceManagementServiceUtils.getService(bundleContext);\r\n    return resources;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.icqaccregwizz.FirstWizardPage.getWizardForm",
	"Comment": "implements the wizardpage.getwizardform to return thispanel.",
	"Method": "Object getWizardForm(){\r\n    return this;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.ippiaccregwizz.IppiAccountRegistrationWizard.setPredefinedProperties",
	"Comment": "sets all predefined properties specific for this account wizard.",
	"Method": "void setPredefinedProperties(SIPAccountRegistration reg){\r\n    reg.setServerAddress(\"ippi.fr\");\r\n    reg.setServerPort(\"5060\");\r\n    reg.setProxyAutoConfigure(false);\r\n    reg.setProxy(\"ippi.fr\");\r\n    reg.setProxyPort(\"5060\");\r\n    reg.setPreferredTransport(\"TCP\");\r\n    reg.setDefaultDomain(\"ippi.fr\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.MUCServiceImpl.createChatRoom",
	"Comment": "creates a chat room, by specifying the chat room name, the parentprotocol provider and eventually, the contacts invited to participate inthis chat room.",
	"Method": "ChatRoomWrapper createChatRoom(String roomName,ProtocolProviderService protocolProvider,Collection<String> contacts,String reason,boolean persistent,boolean isPrivate,ChatRoomWrapper createChatRoom,String roomName,ProtocolProviderService protocolProvider,Collection<String> contacts,String reason,boolean persistent,ChatRoomWrapper createChatRoom,String roomName,ProtocolProviderService protocolProvider,Collection<String> contacts,String reason,boolean join,boolean persistent,boolean isPrivate){\r\n    ChatRoomWrapper chatRoomWrapper = null;\r\n    OperationSetMultiUserChat groupChatOpSet = protocolProvider.getOperationSet(OperationSetMultiUserChat.class);\r\n    if (groupChatOpSet == null)\r\n        return null;\r\n    ChatRoom chatRoom = null;\r\n    try {\r\n        HashMap<String, Object> roomProperties = new HashMap<String, Object>();\r\n        roomProperties.put(\"isPrivate\", isPrivate);\r\n        chatRoom = groupChatOpSet.createChatRoom(roomName, roomProperties);\r\n        if (join) {\r\n            chatRoom.join();\r\n            for (String contact : contacts) chatRoom.invite(contact, reason);\r\n        }\r\n    } catch (OperationFailedException ex) {\r\n        logger.error(\"Failed to create chat room.\", ex);\r\n        MUCActivator.getAlertUIService().showAlertDialog(MUCActivator.getResources().getI18NString(\"service.gui.ERROR\"), MUCActivator.getResources().getI18NString(\"service.gui.CREATE_CHAT_ROOM_ERROR\", new String[] { protocolProvider.getProtocolDisplayName() }), ex);\r\n    } catch (OperationNotSupportedException ex) {\r\n        logger.error(\"Failed to create chat room.\", ex);\r\n        MUCActivator.getAlertUIService().showAlertDialog(MUCActivator.getResources().getI18NString(\"service.gui.ERROR\"), MUCActivator.getResources().getI18NString(\"service.gui.CREATE_CHAT_ROOM_ERROR\", new String[] { protocolProvider.getProtocolDisplayName() }), ex);\r\n    }\r\n    if (chatRoom != null) {\r\n        ChatRoomProviderWrapper parentProvider = chatRoomList.findServerWrapperFromProvider(protocolProvider);\r\n        chatRoomWrapper = chatRoomList.findChatRoomWrapperFromChatRoom(chatRoom);\r\n        if (chatRoomWrapper == null) {\r\n            chatRoomWrapper = new ChatRoomWrapperImpl(parentProvider, chatRoom);\r\n            chatRoomWrapper.setPersistent(persistent);\r\n            chatRoomList.addChatRoom(chatRoomWrapper);\r\n        }\r\n    }\r\n    return chatRoomWrapper;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.notification.PopupMessageNotificationAction.getDefaultMessage",
	"Comment": "return the default message to use if no message is specified.",
	"Method": "String getDefaultMessage(){\r\n    return defaultMessage;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.gibberishaccregwizz.FirstWizardPage.getWizardForm",
	"Comment": "implements the wizardpage.getwizardform to returnthis panel.",
	"Method": "Object getWizardForm(){\r\n    return this;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.ippiaccregwizz.IppiAccountRegistrationWizard.getProtocolName",
	"Comment": "implements the accountregistrationwizard.getprotocolnamemethod. returns the protocol name for this wizard.",
	"Method": "String getProtocolName(){\r\n    return Resources.getString(\"plugin.ippiaccregwizz.PROTOCOL_NAME\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetPersistentPresenceJabberImpl.createResource",
	"Comment": "creates contactresource from the presence, full jid and contact.",
	"Method": "ContactResourceJabberImpl createResource(Presence presence,String fullJid,Contact contact){\r\n    String resource = StringUtils.parseResource(fullJid);\r\n    return new ContactResourceJabberImpl(fullJid, contact, resource, jabberStatusToPresenceStatus(presence, parentProvider), presence.getPriority(), mobileIndicator.isMobileResource(resource, fullJid));\r\n}"
}, {
	"Path": "net.librec.eval.ranking.PrecisionEvaluator.evaluate",
	"Comment": "evaluate on the test set with the the list of recommended items.",
	"Method": "double evaluate(RecommendedList groundTruthList,RecommendedList recommendedList){\r\n    double totalPrecision = 0.0;\r\n    int numContext = groundTruthList.size();\r\n    int nonZeroContext = 0;\r\n    for (int contextIdx = 0; contextIdx < numContext; ++contextIdx) {\r\n        Set<Integer> testSetByContext = groundTruthList.getKeySetByContext(contextIdx);\r\n        if (testSetByContext.size() > 0) {\r\n            List<KeyValue<Integer, Double>> recommendListByContext = recommendedList.getKeyValueListByContext(contextIdx);\r\n            int numHits = 0;\r\n            int topK = this.topN <= recommendListByContext.size() ? this.topN : recommendListByContext.size();\r\n            for (int indexOfKey = 0; indexOfKey < topK; ++indexOfKey) {\r\n                int key = recommendListByContext.get(indexOfKey).getKey();\r\n                if (testSetByContext.contains(key)) {\r\n                    numHits++;\r\n                }\r\n            }\r\n            totalPrecision += numHits / (this.topN + 0.0);\r\n            nonZeroContext++;\r\n        }\r\n    }\r\n    return nonZeroContext > 0 ? totalPrecision / nonZeroContext : 0.0d;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockPersistentPresenceOperationSet.publishPresenceStatus",
	"Comment": "requests the provider to enter into a status corresponding to thespecified paramters.",
	"Method": "void publishPresenceStatus(PresenceStatus status,String statusMessage){\r\n    PresenceStatus oldPresenceStatus = this.presenceStatus;\r\n    this.presenceStatus = status;\r\n    this.statusMessage = statusMessage;\r\n    this.fireProviderStatusChangeEvent(oldPresenceStatus);\r\n}"
}, {
	"Path": "com.github.ltsopensource.core.commons.concurrent.limiter.RateLimiter.reserveAndGetWaitLength",
	"Comment": "reserves next ticket and returns the wait time that the caller must wait for.",
	"Method": "long reserveAndGetWaitLength(int permits,long nowMicros){\r\n    long momentAvailable = reserveEarliestAvailable(permits, nowMicros);\r\n    return max(momentAvailable - nowMicros, 0);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.toolBars.MainToolBar.setCallButtonsIcons",
	"Comment": "sets the icons of the call buttons depending on the chat session type.",
	"Method": "void setCallButtonsIcons(){\r\n    if (chatSession instanceof ConferenceChatSession) {\r\n        callButton.setIconImage(ImageLoader.getImage(ImageLoader.CHAT_ROOM_CALL));\r\n        callVideoButton.setIconImage(ImageLoader.getImage(ImageLoader.CHAT_ROOM_VIDEO_CALL));\r\n        callButton.setPreferredSize(new Dimension(29, 25));\r\n        callVideoButton.setPreferredSize(new Dimension(29, 25));\r\n    } else {\r\n        callButton.setIconImage(ImageLoader.getImage(ImageLoader.CHAT_CALL));\r\n        callVideoButton.setIconImage(ImageLoader.getImage(ImageLoader.CHAT_VIDEO_CALL));\r\n        callButton.setPreferredSize(new Dimension(25, 25));\r\n        callVideoButton.setPreferredSize(new Dimension(25, 25));\r\n    }\r\n    callButton.repaint();\r\n    callVideoButton.repaint();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockContact.getAddress",
	"Comment": "returns a string that can be used for identifying the contact.",
	"Method": "String getAddress(){\r\n    return contactID;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.removeChatFocusListener",
	"Comment": "implements chat.removechatfocuslistener method. removes the givenchatfocuslistener from the list of listeners.",
	"Method": "void removeChatFocusListener(ChatFocusListener listener){\r\n    synchronized (focusListeners) {\r\n        focusListeners.remove(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomIrcImpl.revokeAdmin",
	"Comment": "revokes the admin role for the participant given by address.",
	"Method": "void revokeAdmin(String address){\r\n    final IrcConnection connection = this.parentProvider.getIrcStack().getConnection();\r\n    if (connection == null) {\r\n        throw new IllegalStateException(\"Connection is not available.\");\r\n    }\r\n    connection.getChannelManager().revoke(this, address, Mode.OPERATOR);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.credentialsstorage.CredentialsStorageServiceImpl.removePassword",
	"Comment": "removes the password for the account that starts with the given prefix bysetting its value in the configuration to null.",
	"Method": "boolean removePassword(String accountPrefix){\r\n    setEncrypted(accountPrefix, null);\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Password for '\" + accountPrefix + \"' removed\");\r\n    return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetTypingNotificationsJabberImpl.assertConnected",
	"Comment": "utility method throwing an exception if the stack is not properlyinitialized.",
	"Method": "void assertConnected(){\r\n    if (parentProvider != null && !parentProvider.isRegistered() && opSetPersPresence.getPresenceStatus().isOnline()) {\r\n        opSetPersPresence.fireProviderStatusChangeEvent(opSetPersPresence.getPresenceStatus(), parentProvider.getJabberStatusEnum().getStatus(JabberStatusEnum.OFFLINE));\r\n    }\r\n    super.assertConnected();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomJabberImpl.setUserNickname",
	"Comment": "changes the local user nickname. if the new nickname already exist in thechat room throws an operationfailedexception.",
	"Method": "void setUserNickname(String nickname){\r\n    try {\r\n        multiUserChat.changeNickname(nickname);\r\n        int atIndex = nickname.lastIndexOf(\"@\");\r\n        if (atIndex <= 0)\r\n            this.nickname = nickname;\r\n        else\r\n            this.nickname = nickname.substring(0, atIndex);\r\n    } catch (XMPPException e) {\r\n        logger.error(\"Failed to change nickname for chat room: \" + getName());\r\n        throw new OperationFailedException(\"The \" + nickname + \"already exists in this chat room.\", OperationFailedException.IDENTIFICATION_CONFLICT);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.spellcheck.Word.getWord",
	"Comment": "provides the word before or after a given index. no bounds checking isperformed.",
	"Method": "Word getWord(String text,int index,boolean before){\r\n    int start, end;\r\n    WORD_ITR.setText(text);\r\n    if (before) {\r\n        start = WORD_ITR.preceding(index);\r\n        end = WORD_ITR.next();\r\n        if (start == BreakIterator.DONE)\r\n            start = 0;\r\n    } else {\r\n        end = WORD_ITR.following(index);\r\n        start = WORD_ITR.previous();\r\n        if (end == BreakIterator.DONE)\r\n            end = text.length() - 1;\r\n    }\r\n    return new Word(start, end, text.substring(start, end));\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.plaf.SearchFieldUI.mouseExited",
	"Comment": "updates the call button when the mouse exits the component area.",
	"Method": "void mouseExited(MouseEvent e){\r\n    super.mouseExited(e);\r\n    if (isCallButtonEnabled || isSMSButtonEnabled)\r\n        updateIcon(e);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.InfoRetreiver.detailsChanged",
	"Comment": "when detail is changed we remove it from the cache,from retreiveddetails so the next time we want the detailswe are shure they are get from the server and are actual",
	"Method": "void detailsChanged(String uin){\r\n    retreivedDetails.remove(uin);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.connectioninfo.Resources.getString",
	"Comment": "returns an internationalized string corresponding to the given key.",
	"Method": "String getString(String key){\r\n    return getResources().getI18NString(key);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.contactsource.AsyncContactQuery.removeQueryResult",
	"Comment": "removes a specific sourcecontact from the list ofsourcecontacts.",
	"Method": "boolean removeQueryResult(SourceContact sourceContact){\r\n    boolean changed;\r\n    synchronized (queryResults) {\r\n        changed = queryResults.remove(sourceContact);\r\n    }\r\n    if (changed)\r\n        fireContactRemoved(sourceContact);\r\n    return changed;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ChatRoomContactList.isMetaContactActive",
	"Comment": "checks if the given contact is currently active.dummy method used and overridden from classes extending thisfunctionality such as contactlist.",
	"Method": "boolean isMetaContactActive(MetaContact metaContact){\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.TestAccountInstallation.testInstallAccount",
	"Comment": "installs an account and verifies whether the installation has gone well.",
	"Method": "void testInstallAccount(){\r\n    ServiceReference[] serRefs = null;\r\n    String osgiFilter = \"(\" + ProtocolProviderFactory.PROTOCOL + \"=\" + ProtocolNames.ICQ + \")\";\r\n    try {\r\n        serRefs = IcqSlickFixture.bc.getServiceReferences(ProtocolProviderFactory.class.getName(), osgiFilter);\r\n    } catch (InvalidSyntaxException ex) {\r\n        fail(osgiFilter + \" is not a valid osgi filter\");\r\n    }\r\n    assertTrue(\"Failed to find a provider factory service for protocol ICQ\", (serRefs != null) && (serRefs.length > 0));\r\n    icqProviderFactory = (ProtocolProviderFactory) IcqSlickFixture.bc.getService(serRefs[0]);\r\n    assertTrue(\"There was an account registered with the account mananger \" + \"before we've installed any\", icqProviderFactory.getRegisteredAccounts().size() == 0);\r\n    String passwd = System.getProperty(IcqProtocolProviderSlick.TESTED_IMPL_PWD_PROP_NAME, null);\r\n    String uin = System.getProperty(IcqProtocolProviderSlick.TESTED_IMPL_USER_ID_PROP_NAME, null);\r\n    assertNotNull(\"In the \" + IcqProtocolProviderSlick.TESTED_IMPL_USER_ID_PROP_NAME + \" system property, you need to provide a valid icq UIN for the \" + \" slick to use when signing on icq. It's passwd must be set in \" + IcqProtocolProviderSlick.TESTED_IMPL_PWD_PROP_NAME, uin);\r\n    assertNotNull(\"In the \" + IcqProtocolProviderSlick.TESTED_IMPL_PWD_PROP_NAME + \" system property, you need to provide a password for the \" + uin + \" account.\", passwd);\r\n    Hashtable<String, String> icqAccountProperties = new Hashtable<String, String>();\r\n    icqAccountProperties.put(ProtocolProviderFactory.PASSWORD, passwd);\r\n    try {\r\n        icqProviderFactory.installAccount(null, icqAccountProperties);\r\n        fail(\"installing an account with a null account id must result \" + \"in a NullPointerException\");\r\n    } catch (NullPointerException exc) {\r\n    }\r\n    IcqSlickFixture.icqAccountID = icqProviderFactory.installAccount(uin, icqAccountProperties);\r\n    try {\r\n        IcqSlickFixture.icqAccountID = icqProviderFactory.installAccount(uin, icqAccountProperties);\r\n        fail(\"An IllegalStateException must be thrown when trying to \" + \"install a duplicate account\");\r\n    } catch (IllegalStateException exc) {\r\n    }\r\n    assertTrue(\"The newly installed account was not in the acc man's \" + \"registered accounts!\", icqProviderFactory.getRegisteredAccounts().size() == 1);\r\n    osgiFilter = \"(&(\" + ProtocolProviderFactory.PROTOCOL + \"=\" + ProtocolNames.ICQ + \")\" + \"(\" + ProtocolProviderFactory.USER_ID + \"=\" + IcqSlickFixture.icqAccountID.getUserID() + \"))\";\r\n    try {\r\n        serRefs = IcqSlickFixture.bc.getServiceReferences(ProtocolProviderService.class.getName(), osgiFilter);\r\n    } catch (InvalidSyntaxException ex) {\r\n        fail(osgiFilter + \"is not a valid osgi filter\");\r\n    }\r\n    assertTrue(\"An ICQ protocol provider was apparently not installed as \" + \"requested.\", serRefs != null && serRefs.length > 0);\r\n    Object icqProtocolProvider = IcqSlickFixture.bc.getService(serRefs[0]);\r\n    assertTrue(\"The installed protocol provider does not implement \" + \"the protocol provider service.\", icqProtocolProvider instanceof ProtocolProviderService);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageSourceContactQuery.updateContact",
	"Comment": "notifies the contactquerylisteners registered with thiscontactquery that a sourcecontact has beenchanged.note that object may not be messagesourcecontact, but itsequals method can return true for message source contact instances.",
	"Method": "void updateContact(Object srcObj,EventObject eventObject){\r\n    for (SourceContact msc : getQueryResults()) {\r\n        if (srcObj.equals(msc) && msc instanceof MessageSourceContact) {\r\n            ((MessageSourceContact) msc).update(eventObject);\r\n            super.fireContactChanged(msc);\r\n            break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.configuration.TestConfigurationService.testSystemPoperties",
	"Comment": "tests whether setting and getting works alright for properties declaredas system and whether resolving and retrieving from the system propertyset are done right.",
	"Method": "void testSystemPoperties(){\r\n    String propertyName = \"my.test.system.property\";\r\n    Object property = new String(\"sys.value.1\");\r\n    configurationService.setProperty(propertyName, property, true);\r\n    Object actualReturn = configurationService.getProperty(propertyName);\r\n    assertEquals(\"a sys property was not properly stored\", property, actualReturn);\r\n    actualReturn = System.getProperty(propertyName);\r\n    assertEquals(\"a property was not properly stored\", property, actualReturn);\r\n    property = new String(\"second.sys.value\");\r\n    System.setProperty(propertyName, property.toString());\r\n    actualReturn = configurationService.getProperty(propertyName);\r\n    assertEquals(\"a property was not properly stored\", property, actualReturn);\r\n    property = new String(\"third.sys.value\");\r\n    configurationService.setProperty(propertyName, property.toString());\r\n    actualReturn = System.getProperty(propertyName);\r\n    assertEquals(\"a property was not properly stored\", property, actualReturn);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactGroupImpl.canContainSubgroups",
	"Comment": "determines whether or not this group can contain subgroups.",
	"Method": "boolean canContainSubgroups(){\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.sip.TestOperationSetPresence.disabled_testQueryContactStatus",
	"Comment": "verifies that querying status works fine. the tester agent wouldchange status and the operation set would have to return the right statusafter every change.",
	"Method": "void disabled_testQueryContactStatus(){\r\n    Iterator<PresenceStatus> supportedStatusSetIter = operationSetPresence1.getSupportedStatusSet();\r\n    while (supportedStatusSetIter.hasNext()) {\r\n        PresenceStatus supportedStatus = supportedStatusSetIter.next();\r\n        logger.trace(\"Will test a transition to \" + supportedStatus.getStatusName());\r\n        subtestQueryContactStatus(supportedStatus);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.findInviteChatTransport",
	"Comment": "returns the first chat transport for the current chat session thatsupports group chat.",
	"Method": "ChatTransport findInviteChatTransport(){\r\n    ChatTransport currentChatTransport = chatSession.getCurrentChatTransport();\r\n    ProtocolProviderService protocolProvider = currentChatTransport.getProtocolProvider();\r\n    if (protocolProvider.getOperationSet(OperationSetMultiUserChat.class) != null || protocolProvider.getOperationSet(OperationSetAdHocMultiUserChat.class) != null) {\r\n        return chatSession.getCurrentChatTransport();\r\n    } else {\r\n        Iterator<ChatTransport> chatTransportsIter = chatSession.getChatTransports();\r\n        while (chatTransportsIter.hasNext()) {\r\n            ChatTransport chatTransport = chatTransportsIter.next();\r\n            Object groupChatOpSet = chatTransport.getProtocolProvider().getOperationSet(OperationSetMultiUserChat.class);\r\n            if (groupChatOpSet != null)\r\n                return chatTransport;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomIrcImpl.getChatRoomMember",
	"Comment": "returns the chatroommember corresponding to the given member id.if no member is found for the given id, returns null.",
	"Method": "ChatRoomMember getChatRoomMember(String memberID){\r\n    return chatRoomMembers.get(memberID);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.sip.SIPAccountRegistration.getEncodingsRegistration",
	"Comment": "returns encoding registration object holding encodings configuration.",
	"Method": "EncodingsRegistrationUtil getEncodingsRegistration(){\r\n    return encodingsRegistration;\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.AbstractSessionDataStoreTest.testSavePeriodOnCreate",
	"Comment": "check that a session that has never previously been saved will be saved despite the saveperiod setting.",
	"Method": "void testSavePeriodOnCreate(){\r\n    ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);\r\n    context.setContextPath(\"/test\");\r\n    SessionDataStoreFactory factory = createSessionDataStoreFactory();\r\n    ((AbstractSessionDataStoreFactory) factory).setGracePeriodSec(GRACE_PERIOD_SEC);\r\n    ((AbstractSessionDataStoreFactory) factory).setSavePeriodSec(20);\r\n    SessionDataStore store = factory.getSessionDataStore(context.getSessionHandler());\r\n    SessionContext sessionContext = new SessionContext(\"foo\", context.getServletContext());\r\n    store.initialize(sessionContext);\r\n    store.start();\r\n    long now = System.currentTimeMillis();\r\n    SessionData data = store.newSessionData(\"1234\", 100, now - 10, now - 20, TimeUnit.MINUTES.toMillis(60));\r\n    data.setLastNode(sessionContext.getWorkerName());\r\n    store.store(\"1234\", data);\r\n    checkSessionPersisted(data);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.stopMessageCorrection",
	"Comment": "exits editing mode, clears the write panel and the background.",
	"Method": "void stopMessageCorrection(){\r\n    this.correctedMessageUID = null;\r\n    this.writeMessagePanel.setEditorPaneBackground(Color.WHITE);\r\n    this.refreshWriteArea();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.AnimatedImage.setCurrentImageIndex",
	"Comment": "set the index of the image to be displayed and then repaint the image.",
	"Method": "void setCurrentImageIndex(int index){\r\n    currentImageIndex = index;\r\n    AlphaComposite ac = AlphaComposite.getInstance(AlphaComposite.SRC);\r\n    g2d.setComposite(ac);\r\n    g2d.drawImage(getImage(currentImageIndex), 0, 0, component);\r\n    component.repaint();\r\n}"
}, {
	"Path": "net.librec.conf.Configuration.addDefaultResource",
	"Comment": "add a default resource. resources are loaded in the order of theresources added.",
	"Method": "void addDefaultResource(String name){\r\n    synchronized (Configuration.class) {\r\n        if (defaultResources.contains(name)) {\r\n            return;\r\n        }\r\n        defaultResources.add(name);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.AdHocChatRoomInvitationRejectedEvent.getReason",
	"Comment": "returns the reason for which the adhocchatroominvitation isrejected.",
	"Method": "String getReason(){\r\n    return reason;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.ProtocolProviderFactory.unloadAccount",
	"Comment": "unloads the account corresponding to the given accountid.unregisters the corresponding protocol provider, but keeps the account incontrast to the uninstallaccount method.",
	"Method": "boolean unloadAccount(AccountID accountID){\r\n    ServiceReference<ProtocolProviderService> serRef = getProviderForAccount(accountID);\r\n    if (serRef == null) {\r\n        return false;\r\n    }\r\n    BundleContext bundleContext = getBundleContext();\r\n    ProtocolProviderService protocolProvider = bundleContext.getService(serRef);\r\n    try {\r\n        protocolProvider.unregister();\r\n    } catch (OperationFailedException ex) {\r\n        logger.error(\"Failed to unregister protocol provider for account: \" + accountID + \" caused by: \" + ex);\r\n    }\r\n    ServiceRegistration<ProtocolProviderService> registration;\r\n    synchronized (registeredAccounts) {\r\n        registration = registeredAccounts.remove(accountID);\r\n    }\r\n    if (registration == null) {\r\n        return false;\r\n    }\r\n    registration.unregister();\r\n    return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetServerStoredAccountInfoSipImpl.getAllAvailableDetails",
	"Comment": "returns all details currently available and set for our account.",
	"Method": "Iterator<GenericDetail> getAllAvailableDetails(){\r\n    List<GenericDetail> details = new ArrayList<GenericDetail>();\r\n    if (isImageDetailSupported()) {\r\n        ImageDetail imageDetail = getAccountImage();\r\n        if (imageDetail != null) {\r\n            details.add(getAccountImage());\r\n        }\r\n    }\r\n    if (displayNameDetail != null) {\r\n        details.add(displayNameDetail);\r\n    }\r\n    return details.iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.DataObject.getData",
	"Comment": "gets the user dataassociated with this instance and a specific key.",
	"Method": "Object getData(Object key){\r\n    if (key == null)\r\n        throw new NullPointerException(\"key\");\r\n    int index = dataIndexOf(key);\r\n    return (index == -1) ? null : data[index + 1];\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ShowPreviewDialog.getMsgIDToChatString",
	"Comment": "returns mapping between messageid and the string representation ofthe chat message.",
	"Method": "Map<String, String> getMsgIDToChatString(){\r\n    return msgIDToChatString;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetServerStoredAccountInfoIcqImpl.isDetailClassSupported",
	"Comment": "determines whether a detail class represents a detail supported by theunderlying implementation or not.",
	"Method": "boolean isDetailClassSupported(Class<? extends GenericDetail> detailClass){\r\n    return supportedTypes.get(detailClass) != null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ServerStoredContactListJabberImpl.fireContactResolved",
	"Comment": "make the parent persistent presence operation set dispatch a contactresolved event.",
	"Method": "void fireContactResolved(ContactGroup parentGroup,ContactJabberImpl contact){\r\n    if (parentOperationSet == null) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"No presence op. set available. Bailing out.\");\r\n        return;\r\n    }\r\n    if (roster != null) {\r\n        parentOperationSet.firePresenceStatusChanged(roster.getPresence(contact.getAddress()));\r\n    }\r\n    parentOperationSet.fireSubscriptionEvent(contact, parentGroup, SubscriptionEvent.SUBSCRIPTION_RESOLVED);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetPresenceSipImpl.createUnresolvedContact",
	"Comment": "creates and returns a unresolved contact from the specified address and persistentdata. the method will not try to establish a network connection and resolve the newly created contact against the server. the protocol provider may will later try and resolve the contact. when this happens the corresponding event would notify interested subscription listeners.",
	"Method": "Contact createUnresolvedContact(String address,String persistentData,Contact createUnresolvedContact,String contactId,String persistentData,ContactGroup parent){\r\n    return ssContactList.createUnresolvedContact((ContactGroupSipImpl) parent, contactId, persistentData);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.loggingutils.LogsCollector.collectLogs",
	"Comment": "save the log files in archived file. if destination is a folderwe generate filename with current date and time. if the destinationis null we do nothing and if its a file we use at, as we checkdoes it end with zip extension, is missing we add it.",
	"Method": "File collectLogs(File destination,File optional){\r\n    if (destination == null)\r\n        return null;\r\n    if (!destination.isDirectory()) {\r\n        if (!destination.getName().endsWith(\"zip\"))\r\n            destination = new File(destination.getParentFile(), destination.getName() + \".zip\");\r\n    } else {\r\n        destination = new File(destination, getDefaultFileName());\r\n    }\r\n    try {\r\n        ZipOutputStream out = new ZipOutputStream(new FileOutputStream(destination));\r\n        collectHomeFolderLogs(out);\r\n        collectJavaCrashLogs(out);\r\n        if (optional != null) {\r\n            addFileToZip(optional, out);\r\n        }\r\n        out.close();\r\n        return destination;\r\n    } catch (FileNotFoundException ex) {\r\n        logger.error(\"Error creating logs file archive\", ex);\r\n    } catch (IOException ex) {\r\n        logger.error(\"Error closing archive file\", ex);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockCallPeer.getContact",
	"Comment": "returns the contact corresponding to this peer or null if noparticular contact has been associated.",
	"Method": "Contact getContact(){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommTextArea.getDefaultTextColor",
	"Comment": "gets the foreground color of the default text shown in this text field.",
	"Method": "Color getDefaultTextColor(){\r\n    return defaultTextColor;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.WhiteboardSessionJabberImpl.addWhiteboardChangeListener",
	"Comment": "adds a whiteboard change listener to this whiteboard so that it couldreceive events on new whiteboard participants, theme changes and others.",
	"Method": "void addWhiteboardChangeListener(WhiteboardChangeListener listener){\r\n    synchronized (whiteboardListeners) {\r\n        if (!whiteboardListeners.contains(listener))\r\n            this.whiteboardListeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl.sendInDialogRequest",
	"Comment": "sends a specific request through a givensipprovider as part of the conversation associated with aspecific dialog.",
	"Method": "void sendInDialogRequest(SipProvider sipProvider,Request request,Dialog dialog){\r\n    ClientTransaction clientTransaction = null;\r\n    try {\r\n        clientTransaction = sipProvider.getNewClientTransaction(request);\r\n    } catch (TransactionUnavailableException ex) {\r\n        ProtocolProviderServiceSipImpl.throwOperationFailedException(\"Failed to create a client transaction for request:\\n\" + request, OperationFailedException.INTERNAL_ERROR, ex, logger);\r\n    }\r\n    try {\r\n        dialog.sendRequest(clientTransaction);\r\n    } catch (SipException ex) {\r\n        ProtocolProviderServiceSipImpl.throwOperationFailedException(\"Failed to send request:\\n\" + request, OperationFailedException.NETWORK_FAILURE, ex, logger);\r\n    }\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Sent request:\\n\" + request);\r\n}"
}, {
	"Path": "io.lettuce.core.dynamic.DefaultRedisCommandsMetadata.isOverridable",
	"Comment": "determine whether the given method is overridable in the given target class.",
	"Method": "boolean isOverridable(Method method,Class<?> targetClass){\r\n    if (Modifier.isPrivate(method.getModifiers())) {\r\n        return false;\r\n    }\r\n    if (Modifier.isPublic(method.getModifiers()) || Modifier.isProtected(method.getModifiers())) {\r\n        return true;\r\n    }\r\n    return getPackageName(method.getDeclaringClass()).equals(getPackageName(targetClass));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.IrcStack.isCausedByCertificateException",
	"Comment": "check to see if a certificate exception is the root cause for theexception.",
	"Method": "boolean isCausedByCertificateException(Exception e){\r\n    Throwable cause = e;\r\n    while (cause != null) {\r\n        if (cause instanceof CertificateException) {\r\n            return true;\r\n        }\r\n        cause = cause.getCause();\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockChatRoom.addMemberPresenceListener",
	"Comment": "adds a listener that will be notified of changes in our participation inthe room such as us being kicked, join, left...",
	"Method": "void addMemberPresenceListener(ChatRoomMemberPresenceListener listener){\r\n    if (!memberPresenceListeners.contains(listener))\r\n        memberPresenceListeners.add(listener);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.osdependent.Desktop.getDefaultDesktop",
	"Comment": "returns the default desktop instance depending on the operatingsystem and java version availability.",
	"Method": "Desktop getDefaultDesktop(){\r\n    if (defaultDesktop != null)\r\n        return defaultDesktop;\r\n    Class<?> awtDesktopClass = null;\r\n    try {\r\n        awtDesktopClass = Class.forName(\"java.awt.Desktop\");\r\n    } catch (ClassNotFoundException ex) {\r\n    }\r\n    DesktopPeer peer = null;\r\n    if (awtDesktopClass != null)\r\n        try {\r\n            peer = new AWTDesktopPeer(awtDesktopClass);\r\n        } catch (Exception ex) {\r\n            logger.error(\"Failed to initialize the java.awt.SystemTray implementation.\", ex);\r\n        }\r\n    if (peer == null) {\r\n        logger.error(\"Failed to initialize the desktop.tray implementation.\");\r\n        throw new UnsupportedOperationException(\"Failed to initialize the desktop.tray implementation.\");\r\n    }\r\n    return (defaultDesktop = new Desktop(peer));\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.loggingutils.LoggingUtilsActivator.getPacketLoggingService",
	"Comment": "returns a reference to a packetloggingservice implementation currentlyregistered in the bundle context or null if no such implementation wasfound.",
	"Method": "PacketLoggingService getPacketLoggingService(){\r\n    if (packetLoggingService == null) {\r\n        ServiceReference confReference = bundleContext.getServiceReference(PacketLoggingService.class.getName());\r\n        packetLoggingService = (PacketLoggingService) bundleContext.getService(confReference);\r\n    }\r\n    return packetLoggingService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomIrcImpl.fireMessageDeliveredEvent",
	"Comment": "notifies all interested listeners that achatroommessagedeliveredevent has been fired.",
	"Method": "void fireMessageDeliveredEvent(Message message){\r\n    int eventType = ChatRoomMessageDeliveredEvent.CONVERSATION_MESSAGE_DELIVERED;\r\n    MessageIrcImpl msg = (MessageIrcImpl) message;\r\n    if (msg.isAction()) {\r\n        eventType = ChatRoomMessageDeliveredEvent.ACTION_MESSAGE_DELIVERED;\r\n        if (msg.getContent().indexOf(' ') != -1) {\r\n            msg.setContent(msg.getContent().substring(message.getContent().indexOf(' ')));\r\n        }\r\n    }\r\n    ChatRoomMessageDeliveredEvent msgDeliveredEvt = new ChatRoomMessageDeliveredEvent(this, new Date(), msg, eventType);\r\n    Iterable<ChatRoomMessageListener> listeners;\r\n    synchronized (messageListeners) {\r\n        listeners = new ArrayList<ChatRoomMessageListener>(messageListeners);\r\n    }\r\n    for (ChatRoomMessageListener listener : listeners) {\r\n        try {\r\n            listener.messageDelivered(msgDeliveredEvt);\r\n        } catch (RuntimeException e) {\r\n            LOGGER.error(String.format(\"Listener '%s' threw a runtime exception during execution.\" + \" This is probably due to a bug in the listener's \" + \"implementation.\", listener.getClass().getCanonicalName()), e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.ConfigurationUtils.isFontSupportEnabled",
	"Comment": "checks whether font support is disabled, checking in defaultsettings for the default value.",
	"Method": "boolean isFontSupportEnabled(){\r\n    String fontDisabledProp = \"net.java.sip.communicator.impl.gui.FONT_SUPPORT_ENABLED\";\r\n    boolean defaultValue = false;\r\n    String defaultSettingStr = UtilActivator.getResources().getSettingsString(fontDisabledProp);\r\n    if (defaultSettingStr != null)\r\n        defaultValue = Boolean.parseBoolean(defaultSettingStr);\r\n    return configService.getBoolean(fontDisabledProp, defaultValue);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatSession.conferencePublished",
	"Comment": "acts upon a chatroomconferencepublishedevent, dispatched whena member of a chat room publishes a conferencedescription.",
	"Method": "void conferencePublished(ChatRoomConferencePublishedEvent evt){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                conferencePublished(evt);\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    ChatRoom room = evt.getChatRoom();\r\n    if (!room.equals(chatRoomWrapper.getChatRoom()))\r\n        return;\r\n    ConferenceDescription cd = evt.getConferenceDescription();\r\n    if (evt.getType() == ChatRoomConferencePublishedEvent.CONFERENCE_DESCRIPTION_SENT) {\r\n        sessionRenderer.chatConferenceDescriptionSent(cd);\r\n    } else if (evt.getType() == ChatRoomConferencePublishedEvent.CONFERENCE_DESCRIPTION_RECEIVED) {\r\n        updateChatConferences(room, evt.getMember(), cd, room.getCachedConferenceDescriptionSize());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatSession.conferencePublished",
	"Comment": "acts upon a chatroomconferencepublishedevent, dispatched whena member of a chat room publishes a conferencedescription.",
	"Method": "void conferencePublished(ChatRoomConferencePublishedEvent evt){\r\n    conferencePublished(evt);\r\n}"
}, {
	"Path": "net.librec.recommender.cf.UserKNNTestCase.test25SplitterRatioRatingDate",
	"Comment": "test ratiodatasplitter with rating date ratio, filter enabled.",
	"Method": "void test25SplitterRatioRatingDate(){\r\n    Resource resource = new Resource(\"rec/cf/userknn-test.properties\");\r\n    conf.addResource(resource);\r\n    conf.set(\"rec.eval.enable\", \"false\");\r\n    conf.set(\"rec.filter.class\", \"generic\");\r\n    conf.set(\"data.model.splitter\", \"ratio\");\r\n    conf.set(\"data.input.path\", \"test/datamodeltest/ratings-date.txt\");\r\n    conf.set(\"data.column.format\", \"UIRT\");\r\n    conf.set(\"data.splitter.ratio\", \"ratingdate\");\r\n    RecommenderJob job = new RecommenderJob(conf);\r\n    job.runJob();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.usersearch.UserSearchActivator.addSupportedProvider",
	"Comment": "adds provider to the list of providers that support user search.",
	"Method": "void addSupportedProvider(ProtocolProviderService provider){\r\n    if (!supportedProviders.contains(provider)) {\r\n        supportedProviders.add(provider);\r\n        LinkedList<UserSearchSupportedProviderListener> tmpListeners;\r\n        synchronized (listeners) {\r\n            tmpListeners = new LinkedList<UserSearchSupportedProviderListener>(listeners);\r\n        }\r\n        for (UserSearchSupportedProviderListener l : tmpListeners) {\r\n            l.providerAdded(provider);\r\n        }\r\n        if (supportedProviders.size() == 1) {\r\n            if (userSearchContactSource == null)\r\n                userSearchContactSource = new UserSearchContactSource();\r\n            contactSourceRegistration = bundleContext.registerService(ContactSourceService.class.getName(), userSearchContactSource, null);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.PresenceStatus.hashCode",
	"Comment": "returns a hash code value for the object. this method is supported forthe benefit of hashtables such as those provided byjava.util.hashtable.",
	"Method": "int hashCode(){\r\n    return getStatusName().hashCode();\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.account.AccountStatusUtils.getLastStatusString",
	"Comment": "returns the last contact status saved in the configuration.",
	"Method": "String getLastStatusString(ProtocolProviderService protocolProvider){\r\n    return getGlobalStatusService().getLastStatusString(protocolProvider);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl.putOnHold",
	"Comment": "puts the callpeer represented by this instance on or off hold.",
	"Method": "void putOnHold(boolean onHold){\r\n    CallPeerMediaHandlerSipImpl mediaHandler = getMediaHandler();\r\n    mediaHandler.setLocallyOnHold(onHold);\r\n    try {\r\n        sendReInvite(mediaHandler.createOffer());\r\n    } catch (Exception ex) {\r\n        ProtocolProviderServiceSipImpl.throwOperationFailedException(\"Failed to create SDP offer to hold.\", OperationFailedException.INTERNAL_ERROR, ex, logger);\r\n    }\r\n    reevalLocalHoldStatus();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.ChatRoomSourceContact.getIndex",
	"Comment": "returns the index of this source contact in its parent group.",
	"Method": "int getIndex(){\r\n    return ((ChatRoomQuery) parentQuery).indexOf(this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.filetransfer.FileTransferConversationComponent.getFileLabel",
	"Comment": "returns the string, showing information for the given file.",
	"Method": "String getFileLabel(File file,String getFileLabel,String fileName,long fileSize){\r\n    String text = ByteFormat.format(fileSize);\r\n    return fileName + \" (\" + text + \")\";\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AccountManager.protocolProviderFactoryRegistered",
	"Comment": "notifies this manager that a specificprotocolproviderfactory has been registered as a service.the current implementation queues the specified factory tohave its stored accounts as soon as possible.",
	"Method": "void protocolProviderFactoryRegistered(ProtocolProviderFactory factory){\r\n    queueLoadStoredAccounts(factory);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ProtocolProviderServiceJabberImpl.createLoginStrategy",
	"Comment": "creates the jabberloginstrategy to use for the current account.",
	"Method": "JabberLoginStrategy createLoginStrategy(){\r\n    if (((JabberAccountIDImpl) getAccountID()).isAnonymousAuthUsed()) {\r\n        return new AnonymousLoginStrategy(getAccountID().getAuthorizationName());\r\n    }\r\n    String clientCertId = getAccountID().getAccountPropertyString(ProtocolProviderFactory.CLIENT_TLS_CERTIFICATE);\r\n    if (clientCertId != null) {\r\n        return new LoginByClientCertificateStrategy(getAccountID());\r\n    } else {\r\n        return new LoginByPasswordStrategy(this, getAccountID());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.EventPackageNotifier.notify",
	"Comment": "notifies a specific target identified by its subscription abouta specific subscription state and a specific reason for that subscriptionstate via a notify request.",
	"Method": "void notify(Subscription subscription,String subscriptionState,String reason){\r\n    Dialog dialog = subscription.getDialog();\r\n    String callId;\r\n    synchronized (dialog) {\r\n        ClientTransaction transac = createNotify(dialog, subscription, subscriptionState, reason);\r\n        callId = dialog.getCallId().getCallId();\r\n        try {\r\n            dialog.sendRequest(transac);\r\n        } catch (SipException sex) {\r\n            logger.error(\"Failed to send NOTIFY request.\", sex);\r\n            throw new OperationFailedException(\"Failed to send NOTIFY request.\", OperationFailedException.NETWORK_FAILURE, sex);\r\n        }\r\n    }\r\n    if (SubscriptionState.TERMINATED.equals(subscriptionState))\r\n        removeSubscription(callId, subscription);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ProtocolProviderFactoryJabberImpl.storeAccount",
	"Comment": "ovverides the original in order give access to protocol implementation.",
	"Method": "void storeAccount(AccountID accountID){\r\n    super.storeAccount(accountID);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl.createOutgoingCall",
	"Comment": "initializes and establishes a new outgoing call to a callee witha specific address.",
	"Method": "CallSipImpl createOutgoingCall(CallSipImpl createOutgoingCall,Address calleeAddress,javax.sip.message.Message cause,CallConference conference){\r\n    CallSipImpl call = createOutgoingCall();\r\n    if (logger.isInfoEnabled())\r\n        logger.info(\"Creating outgoing call to \" + calleeAddress);\r\n    if (conference != null)\r\n        call.setConference(conference);\r\n    call.invite(calleeAddress, cause);\r\n    return call;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.UIServiceImpl.getCurrentPhoneNumber",
	"Comment": "returns the phone number currently entered in the phone number field.",
	"Method": "String getCurrentPhoneNumber(){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWritePanel.removeChatTransport",
	"Comment": "removes the given chat status state from the send via selector box.",
	"Method": "void removeChatTransport(ChatTransport chatTransport){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                removeChatTransport(chatTransport);\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    if (transportSelectorBox != null)\r\n        transportSelectorBox.removeChatTransport(chatTransport);\r\n    if (transportSelectorBox != null && transportSelectorBox.getMenu().getItemCount() == 1 && ConfigurationUtils.isHideAccountSelectionWhenPossibleEnabled()) {\r\n        transportSelectorBox.setVisible(false);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWritePanel.removeChatTransport",
	"Comment": "removes the given chat status state from the send via selector box.",
	"Method": "void removeChatTransport(ChatTransport chatTransport){\r\n    removeChatTransport(chatTransport);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.TestProtocolProviderServiceIcqImpl.testOperationSetTypes",
	"Comment": "verifies that all operation sets have the type they are declarded tohave.",
	"Method": "void testOperationSetTypes(){\r\n    Map<String, OperationSet> supportedOperationSets = fixture.provider.getSupportedOperationSets();\r\n    for (Map.Entry<String, OperationSet> entry : supportedOperationSets.entrySet()) {\r\n        String setName = entry.getKey();\r\n        Object opSet = entry.getValue();\r\n        assertTrue(opSet + \" was not an instance of \" + setName + \" as declared\", Class.forName(setName).isInstance(opSet));\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetMultiUserChatJabberImpl.rejectInvitation",
	"Comment": "informs the sender of an invitation that we decline their invitation.",
	"Method": "void rejectInvitation(ChatRoomInvitation invitation,String rejectReason){\r\n    MultiUserChat.decline(jabberProvider.getConnection(), invitation.getTargetChatRoom().getName(), invitation.getInviter(), rejectReason);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.DesktopSharingCallSipImpl.processExtraHeaders",
	"Comment": "a place where we can handle any headers we need for requestsand responses.",
	"Method": "void processExtraHeaders(javax.sip.message.Message message){\r\n    if (message instanceof Request) {\r\n        if (desktopSharingSessionID == null) {\r\n            desktopSharingSessionID = UUID.randomUUID().toString();\r\n            setData(DSSID_HEADER, desktopSharingSessionID);\r\n        }\r\n        Header dssidHeader = getProtocolProvider().getHeaderFactory().createHeader(DSSID_HEADER, desktopSharingSessionID);\r\n        message.setHeader(dssidHeader);\r\n    } else if (message instanceof Response) {\r\n        if (desktopSharingSessionID != null) {\r\n            Header dssidHeader = getProtocolProvider().getHeaderFactory().createHeader(DSSID_HEADER, desktopSharingSessionID);\r\n            message.setHeader(dssidHeader);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractOperationSetPersistentPresence.addServerStoredGroupChangeListener",
	"Comment": "registers a listener that would receive events upon changes in serverstored groups.",
	"Method": "void addServerStoredGroupChangeListener(ServerStoredGroupListener listener){\r\n    synchronized (serverStoredGroupListeners) {\r\n        if (!serverStoredGroupListeners.contains(listener))\r\n            serverStoredGroupListeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ContactGroupJabberImpl.getNameCopy",
	"Comment": "returns the name of the group as it was at the last call of initnamecopy.",
	"Method": "String getNameCopy(){\r\n    return this.nameCopy;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.launchutils.SipCommunicatorLock.readLockFile",
	"Comment": "parses the lockfile into a standard properties object andverifies it for completeness. the method also tries to validate thecontents of lockfile and asserts presence of all propertiesmandated by this version.",
	"Method": "InetSocketAddress readLockFile(File lockFile){\r\n    Properties lockProperties = new Properties();\r\n    try {\r\n        lockProperties.load(new FileInputStream(lockFile));\r\n    } catch (Exception exc) {\r\n        logger.error(\"Failed to read lock properties.\", exc);\r\n        return null;\r\n    }\r\n    String lockAddressStr = lockProperties.getProperty(PNAME_LOCK_ADDRESS);\r\n    if (lockAddressStr == null) {\r\n        logger.error(\"Lock file contains no lock address.\");\r\n        return null;\r\n    }\r\n    String lockPort = lockProperties.getProperty(PNAME_LOCK_PORT);\r\n    if (lockPort == null) {\r\n        logger.error(\"Lock file contains no lock port.\");\r\n        return null;\r\n    }\r\n    InetAddress lockAddress = findLocalAddress(lockAddressStr);\r\n    if (lockAddress == null) {\r\n        logger.error(lockAddressStr + \" is not a valid local address.\");\r\n        return null;\r\n    }\r\n    int port;\r\n    try {\r\n        port = Integer.parseInt(lockPort);\r\n    } catch (NumberFormatException exc) {\r\n        logger.error(lockPort + \" is not a valid port number.\", exc);\r\n        return null;\r\n    }\r\n    InetSocketAddress lockSocketAddress = new InetSocketAddress(lockAddress, port);\r\n    return lockSocketAddress;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.notificationwiring.NotificationManager.localUserAdHocPresenceChanged",
	"Comment": "implements thelocaluseradhocchatroompresencelistener.localuserpresencechangedmethod",
	"Method": "void localUserAdHocPresenceChanged(LocalUserAdHocChatRoomPresenceChangeEvent evt){\r\n    String eventType = evt.getEventType();\r\n    if (LocalUserAdHocChatRoomPresenceChangeEvent.LOCAL_USER_JOINED.equals(eventType)) {\r\n        evt.getAdHocChatRoom().addMessageListener(this);\r\n    } else if (LocalUserAdHocChatRoomPresenceChangeEvent.LOCAL_USER_LEFT.equals(eventType) || LocalUserAdHocChatRoomPresenceChangeEvent.LOCAL_USER_DROPPED.equals(eventType)) {\r\n        evt.getAdHocChatRoom().removeMessageListener(this);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.resources.ResourceManagementActivator.getConfigService",
	"Comment": "returns the configurationservice obtained from the bundlecontext.",
	"Method": "ConfigurationService getConfigService(){\r\n    if (configService == null) {\r\n        configService = ServiceUtils.getService(bundleContext, ConfigurationService.class);\r\n    }\r\n    return configService;\r\n}"
}, {
	"Path": "design.RandomizedSet.insert",
	"Comment": "inserts a value to the set. returns true if the set did not already contain the specified element.",
	"Method": "boolean insert(int val){\r\n    if (!map.keySet().contains(val)) {\r\n        int pos = list.size();\r\n        map.put(val, pos);\r\n        list.add(val);\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.AdHocConferenceChatSession.getHistory",
	"Comment": "returns a collection of the last n number of messages given by count.",
	"Method": "Collection<Object> getHistory(int count){\r\n    final MetaHistoryService metaHistory = GuiActivator.getMetaHistoryService();\r\n    if (metaHistory == null)\r\n        return null;\r\n    return metaHistory.findLast(chatHistoryFilter, chatRoomWrapper.getAdHocChatRoom(), ConfigurationUtils.getChatHistorySize());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.notifsource.NotificationContact.setUnreadUrgentMessageCount",
	"Comment": "sets the number of urgent unread messages, this notification is about.",
	"Method": "void setUnreadUrgentMessageCount(int count){\r\n    this.unreadUrgentMessageCount = count;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.globalshortcut.GlobalShortcutActivator.getKeybindingsService",
	"Comment": "returns the keybindingsservice obtained from the bundle context.",
	"Method": "KeybindingsService getKeybindingsService(){\r\n    if (keybindingsService == null) {\r\n        keybindingsService = ServiceUtils.getService(bundleContext, KeybindingsService.class);\r\n    }\r\n    return keybindingsService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.account.EmptyAccountRegistrationForm.getProtocolName",
	"Comment": "returns the name of a dummy protocol which is actually a prompt to selecta network.",
	"Method": "String getProtocolName(){\r\n    return GuiActivator.getResources().getI18NString(\"impl.gui.main.account.DUMMY_PROTOCOL_NAME\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.PresenceStatusMenu.propertyChange",
	"Comment": "listens for change in the status message coming from statusmessagemenu.",
	"Method": "void propertyChange(PropertyChangeEvent evt){\r\n    if (evt.getPropertyName().equals(StatusMessageMenu.STATUS_MESSAGE_UPDATED_PROP)) {\r\n        updateTitleArea();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.gibberishaccregwizz.FirstWizardPage.loadAccount",
	"Comment": "fills the userid and password fields in this panel with the data commingfrom the given protocolprovider.",
	"Method": "void loadAccount(ProtocolProviderService protocolProvider){\r\n    AccountID accountID = protocolProvider.getAccountID();\r\n    String password = GibberishAccRegWizzActivator.getGibberishProtocolProviderFactory().loadPassword(accountID);\r\n    this.userIDField.setEnabled(false);\r\n    this.userIDField.setText(accountID.getUserID());\r\n    if (password != null) {\r\n        this.passField.setText(password);\r\n        this.rememberPassBox.setSelected(true);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.sip.SIPAccountRegistration.getSecurityRegistration",
	"Comment": "returns security registration object holding security configuration.",
	"Method": "SecurityAccountRegistration getSecurityRegistration(){\r\n    return securityAccountRegistration;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.connectioninfo.ConnectionInfoActivator.getGlobalDisplayDetailsService",
	"Comment": "returns the globaldisplaydetailsservice obtained from the bundlecontext.",
	"Method": "GlobalDisplayDetailsService getGlobalDisplayDetailsService(){\r\n    if (globalDisplayDetailsService == null) {\r\n        globalDisplayDetailsService = ServiceUtils.getService(bundleContext, GlobalDisplayDetailsService.class);\r\n    }\r\n    return globalDisplayDetailsService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactGroupImpl.countSubgroups",
	"Comment": "returns the number of subgroups that this metacontactgroupcontains.",
	"Method": "int countSubgroups(){\r\n    return subgroups.size();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl.addMethodProcessorListener",
	"Comment": "registers a specific methodprocessorlistener with thiscallpeer so that it gets notified by this instance about theprocessing of sip signaling. if the specified listener isalready registered with this instance, does nothing",
	"Method": "void addMethodProcessorListener(MethodProcessorListener listener){\r\n    if (listener == null)\r\n        throw new NullPointerException(\"listener\");\r\n    synchronized (methodProcessorListeners) {\r\n        if (!methodProcessorListeners.contains(listener))\r\n            methodProcessorListeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetFileTransferJabberImpl.sendFile",
	"Comment": "sends a file transfer request to the given tocontact byspecifying the local and remote file path and the fromcontact,sending the file.",
	"Method": "FileTransfer sendFile(Contact toContact,File file,FileTransfer sendFile,Contact toContact,File file,String gw,FileTransfer sendFile,Contact toContact,Contact fromContact,String remotePath,String localPath){\r\n    return this.sendFile(toContact, new File(localPath));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.MetaUIGroup.getId",
	"Comment": "returns the identifier of the underlying metacontactgroup.",
	"Method": "String getId(){\r\n    return metaGroup.getMetaUID();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.customcontrols.TransparentBackground.updateBackground",
	"Comment": "updates the background. makes a new screen capture at the givencoordiantes.",
	"Method": "void updateBackground(int x,int y){\r\n    this.background = robot.createScreenCapture(new Rectangle(x, y, x + this.window.getWidth(), y + this.window.getHeight()));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.version.VersionActivator.getBundleContext",
	"Comment": "gets the bundlecontext instance within which this bundle hasbeen started.",
	"Method": "BundleContext getBundleContext(){\r\n    return bundleContext;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.TestOperationSetPersistentPresence.testRetrievingServerStoredContactList",
	"Comment": "retrieves a server stored contact list and checks whether it containsall contacts that have been added there during the initializationphase by the testeragent.",
	"Method": "void testRetrievingServerStoredContactList(){\r\n    ContactGroup rootGroup = opSetPersPresence1.getServerStoredContactListRoot();\r\n    logger.debug(\"=========== Server Stored Contact List =================\");\r\n    logger.debug(\"rootGroup=\" + rootGroup.getGroupName() + \" rootGroup.childContacts=\" + rootGroup.countContacts() + \"rootGroup.childGroups=\" + rootGroup.countSubgroups() + \"Printing rootGroupContents=\\n\" + rootGroup.toString());\r\n    Hashtable<String, List<String>> expectedContactList = JabberSlickFixture.preInstalledBuddyList;\r\n    logger.debug(\"============== Expected Contact List ===================\");\r\n    logger.debug(expectedContactList);\r\n    Iterator<ContactGroup> groups = rootGroup.subgroups();\r\n    while (groups.hasNext()) {\r\n        ContactGroup group = groups.next();\r\n        List<String> expectedContactsInGroup = expectedContactList.get(group.getGroupName());\r\n        if (!group.getGroupName().equals(\"NotInContactList\")) {\r\n            assertNotNull(\"Group \" + group.getGroupName() + \" was returned by \" + \"the server but was not in the expected contact list.\", expectedContactsInGroup);\r\n            Iterator<Contact> contactsIter = group.contacts();\r\n            while (contactsIter.hasNext()) {\r\n                String contactID = contactsIter.next().getAddress();\r\n                expectedContactsInGroup.remove(contactID);\r\n            }\r\n            if (expectedContactsInGroup.size() == 0)\r\n                expectedContactList.remove(group.getGroupName());\r\n        }\r\n    }\r\n    assertTrue(\"The following contacts were on the server sidec contact \" + \"list, but were not returned by the pers. pres. op. set\" + expectedContactList.toString(), expectedContactList.isEmpty());\r\n}"
}, {
	"Path": "net.librec.conf.Configuration.setStrings",
	"Comment": "set the array of string values for the name property as ascomma delimited values.",
	"Method": "void setStrings(String name,String values){\r\n    set(name, StringUtil.arrayToString(values));\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.TestOperationSetFileTransferImpl.enableTestReceiverCancelsWhileTransfering",
	"Comment": "it deleivers failed event to receiver but it must delivercanceled.",
	"Method": "boolean enableTestReceiverCancelsWhileTransfering(){\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.icqaccregwizz.IcqAccountRegistrationWizard.getFirstPageIdentifier",
	"Comment": "returns the identifier of the page to show first in the wizard.",
	"Method": "Object getFirstPageIdentifier(){\r\n    return firstWizardPage.getIdentifier();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ServerStoredContactListIcqImpl.renameGroup",
	"Comment": "renames the specified group according to the specified new name..",
	"Method": "void renameGroup(ContactGroupIcqImpl groupToRename,String newName){\r\n    groupToRename.getJoustSimSourceGroup().rename(newName);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.provisioning.ProvisioningActivator.getResourceService",
	"Comment": "returns the resourcemanagementservice obtained from thebundle context.",
	"Method": "ResourceManagementService getResourceService(){\r\n    if (resourceService == null) {\r\n        ServiceReference resourceReference = bundleContext.getServiceReference(ResourceManagementService.class.getName());\r\n        resourceService = (ResourceManagementService) bundleContext.getService(resourceReference);\r\n    }\r\n    return resourceService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.ContactGroupGibberishImpl.countSubgroups",
	"Comment": "returns the number of subgroups contained by thiscontactgroup.",
	"Method": "int countSubgroups(){\r\n    return subGroups.size();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.notification.Notification.addAction",
	"Comment": "adds the given actiontype to the list of actions for this eventnotifications.",
	"Method": "Object addAction(NotificationAction action){\r\n    return actionsTable.put(action.getActionType(), action);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractCallPeer.getState",
	"Comment": "returns an object representing the current state of that peer.",
	"Method": "CallPeerState getState(){\r\n    return state;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallSipImpl.processReplacingInvite",
	"Comment": "processes an incoming invite that is meant to replace an existingcallpeersipimpl that is participating in this call. typicallythis would happen as a result of an attended transfer.",
	"Method": "void processReplacingInvite(SipProvider jainSipProvider,ServerTransaction serverTransaction,CallPeerSipImpl callPeerToReplace){\r\n    CallPeerSipImpl newCallPeer = createCallPeerFor(serverTransaction, jainSipProvider);\r\n    try {\r\n        newCallPeer.answer();\r\n    } catch (OperationFailedException ex) {\r\n        logger.error(\"Failed to auto-answer the referred call peer \" + newCallPeer, ex);\r\n        return;\r\n    }\r\n    try {\r\n        callPeerToReplace.hangup();\r\n    } catch (OperationFailedException ex) {\r\n        logger.error(\"Failed to hangup the referer \" + callPeerToReplace, ex);\r\n        callPeerToReplace.setState(CallPeerState.FAILED, \"Internal Error: \" + ex);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageHistoryServiceImpl.addSearchProgressListener",
	"Comment": "adding progress listener for monitoring progress of search process",
	"Method": "void addSearchProgressListener(MessageHistorySearchProgressListener listener){\r\n    synchronized (progressListeners) {\r\n        HistorySearchProgressListener wrapperListener = new SearchProgressWrapper(listener);\r\n        progressListeners.put(listener, wrapperListener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.JabberAccRegWizzActivator.getJabberProtocolProviderFactory",
	"Comment": "returns the protocolproviderfactory for the jabber protocol.",
	"Method": "ProtocolProviderFactory getJabberProtocolProviderFactory(){\r\n    ServiceReference[] serRefs = null;\r\n    String osgiFilter = \"(\" + ProtocolProviderFactory.PROTOCOL + \"=\" + ProtocolNames.JABBER + \")\";\r\n    try {\r\n        serRefs = bundleContext.getServiceReferences(ProtocolProviderFactory.class.getName(), osgiFilter);\r\n    } catch (InvalidSyntaxException ex) {\r\n        logger.error(\"JabberAccRegWizzActivator : \" + ex);\r\n    }\r\n    return (ProtocolProviderFactory) bundleContext.getService(serRefs[0]);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.AddContactDialog.addPrompt",
	"Comment": "adds a faint gray prompt to the provided text field thatwill vanish as soon as text is entered into the field.",
	"Method": "void addPrompt(JTextField field,String text){\r\n    final JLabel prompt = new JLabel(text);\r\n    final Color fg = field.getForeground();\r\n    final Color color = new Color(fg.getRed(), fg.getGreen(), fg.getBlue(), 128);\r\n    prompt.setFont(field.getFont());\r\n    prompt.setForeground(color);\r\n    prompt.setBorder(new EmptyBorder(field.getInsets()));\r\n    prompt.setHorizontalAlignment(JLabel.LEADING);\r\n    final Document doc = field.getDocument();\r\n    doc.addDocumentListener(new DocumentListener() {\r\n        public void insertUpdate(DocumentEvent e) {\r\n            prompt.setVisible(doc.getLength() == 0);\r\n        }\r\n        public void removeUpdate(DocumentEvent e) {\r\n            prompt.setVisible(doc.getLength() == 0);\r\n        }\r\n        public void changedUpdate(DocumentEvent e) {\r\n        }\r\n    });\r\n    field.setLayout(new BorderLayout());\r\n    field.add(prompt);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.AddContactDialog.addPrompt",
	"Comment": "adds a faint gray prompt to the provided text field thatwill vanish as soon as text is entered into the field.",
	"Method": "void addPrompt(JTextField field,String text){\r\n    prompt.setVisible(doc.getLength() == 0);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.AddContactDialog.addPrompt",
	"Comment": "adds a faint gray prompt to the provided text field thatwill vanish as soon as text is entered into the field.",
	"Method": "void addPrompt(JTextField field,String text){\r\n    prompt.setVisible(doc.getLength() == 0);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.AddContactDialog.addPrompt",
	"Comment": "adds a faint gray prompt to the provided text field thatwill vanish as soon as text is entered into the field.",
	"Method": "void addPrompt(JTextField field,String text){\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapSearchSettingsImpl.getMaxResults",
	"Comment": "returns the maximum number of results to fetch from thedirectory when performing the search query.",
	"Method": "int getMaxResults(){\r\n    return this.maxResults;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.sparkle.SparkleActivator.getConfigurationService",
	"Comment": "returns a reference to a configurationservice implementation currentlyregistered in the bundle context or null if no such implementation wasfound.",
	"Method": "ConfigurationService getConfigurationService(){\r\n    if (configurationService == null) {\r\n        ServiceReference confReference = bundleContext.getServiceReference(ConfigurationService.class.getName());\r\n        configurationService = (ConfigurationService) bundleContext.getService(confReference);\r\n    }\r\n    return configurationService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.configforms.ConfigurationFrame.addDefaultForms",
	"Comment": "some configuration forms constructed from the ui implementation itselfare added here in the configuration dialog.",
	"Method": "void addDefaultForms(){\r\n    if (ConfigurationUtils.isShowAccountConfig())\r\n        addConfigurationForm(new LazyConfigurationForm(\"net.java.sip.communicator.impl.gui.main.\" + \"account.AccountsConfigurationPanel\", getClass().getClassLoader(), \"service.gui.icons.ACCOUNT_ICON\", \"service.gui.ACCOUNTS\", 0));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.RawUdpTransportManager.removeRemoteContent",
	"Comment": "removes a content with a specific name from the remote counterpart of thenegotiation between the local and the remote peers.",
	"Method": "void removeRemoteContent(String name){\r\n    for (Iterator<Iterable<ContentPacketExtension>> remoteIter = remotes.iterator(); remoteIter.hasNext(); ) {\r\n        Iterable<ContentPacketExtension> remote = remoteIter.next();\r\n        if ((removeContent(remote, name) != null) && !remote.iterator().hasNext()) {\r\n            remoteIter.remove();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageHistoryServiceImpl.findLastMessagesBefore",
	"Comment": "returns the supplied number of recent messages before the given dateexchanged in the supplied chat room",
	"Method": "Collection<EventObject> findLastMessagesBefore(MetaContact contact,Date date,int count,Collection<EventObject> findLastMessagesBefore,ChatRoom room,Date date,int count){\r\n    LinkedList<EventObject> result = new LinkedList<EventObject>();\r\n    try {\r\n        HistoryReader reader = this.getHistoryForMultiChat(room).getReader();\r\n        Iterator<HistoryRecord> recs = reader.findLastRecordsBefore(date, count);\r\n        while (recs.hasNext()) {\r\n            result.add(convertHistoryRecordToMessageEvent(recs.next(), room));\r\n        }\r\n    } catch (IOException e) {\r\n        logger.error(\"Could not read history\", e);\r\n    }\r\n    Collections.sort(result, new ChatRoomMessageEventComparator<EventObject>());\r\n    int startIndex = result.size() - count;\r\n    if (startIndex < 0)\r\n        startIndex = 0;\r\n    return result.subList(startIndex, result.size());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.notifsource.NotificationContact.setContactNode",
	"Comment": "sets the given contactnode. the contactnodeis the real node that is stored in the contact list component data model.",
	"Method": "void setContactNode(ContactNode contactNode){\r\n    this.contactNode = contactNode;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.history.HistoryReaderImpl.findLastRecordsBefore",
	"Comment": "returns the supplied number of recent messages before the given date",
	"Method": "QueryResultSet<HistoryRecord> findLastRecordsBefore(Date date,int count){\r\n    Vector<String> filelist = filterFilesByDate(this.historyImpl.getFileList(), null, date);\r\n    TreeSet<HistoryRecord> result = new TreeSet<HistoryRecord>(new HistoryRecordComparator());\r\n    int leftCount = count;\r\n    int currentFile = filelist.size() - 1;\r\n    SimpleDateFormat sdf = new SimpleDateFormat(DATE_FORMAT);\r\n    while (leftCount > 0 && currentFile >= 0) {\r\n        Document doc = this.historyImpl.getDocumentForFile(filelist.get(currentFile));\r\n        if (doc == null) {\r\n            currentFile--;\r\n            continue;\r\n        }\r\n        NodeList nodes = doc.getElementsByTagName(\"record\");\r\n        Node node;\r\n        for (int i = nodes.getLength() - 1; i >= 0 && leftCount > 0; i--) {\r\n            node = nodes.item(i);\r\n            NodeList propertyNodes = node.getChildNodes();\r\n            Date timestamp;\r\n            String ts = node.getAttributes().getNamedItem(\"timestamp\").getNodeValue();\r\n            try {\r\n                timestamp = sdf.parse(ts);\r\n            } catch (ParseException e) {\r\n                timestamp = new Date(Long.parseLong(ts));\r\n            }\r\n            if (!isInPeriod(timestamp, null, date))\r\n                continue;\r\n            ArrayList<String> nameVals = new ArrayList<String>();\r\n            boolean isRecordOK = true;\r\n            int len = propertyNodes.getLength();\r\n            for (int j = 0; j < len; j++) {\r\n                Node propertyNode = propertyNodes.item(j);\r\n                if (propertyNode.getNodeType() == Node.ELEMENT_NODE) {\r\n                    Node nodeValue = propertyNode.getFirstChild();\r\n                    if (nodeValue != null) {\r\n                        nameVals.add(propertyNode.getNodeName());\r\n                        nameVals.add(nodeValue.getNodeValue());\r\n                    } else\r\n                        isRecordOK = false;\r\n                }\r\n            }\r\n            if (!isRecordOK)\r\n                continue;\r\n            String[] propertyNames = new String[nameVals.size() / 2];\r\n            String[] propertyValues = new String[propertyNames.length];\r\n            for (int j = 0; j < propertyNames.length; j++) {\r\n                propertyNames[j] = nameVals.get(j * 2);\r\n                propertyValues[j] = nameVals.get(j * 2 + 1);\r\n            }\r\n            HistoryRecord record = new HistoryRecord(propertyNames, propertyValues, timestamp);\r\n            result.add(record);\r\n            leftCount--;\r\n        }\r\n        currentFile--;\r\n    }\r\n    return new OrderedQueryResultSet<HistoryRecord>(result);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.globaldisplaydetails.GlobalDisplayDetailsImpl.getGlobalDisplayName",
	"Comment": "returns the global display name to be used to identify the local user.",
	"Method": "String getGlobalDisplayName(){\r\n    if (!StringUtils.isNullOrEmpty(provisionedDisplayName))\r\n        return provisionedDisplayName;\r\n    return globalDisplayName;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler.isLocalAudioTransmissionEnabled",
	"Comment": "determines whether this media handler is currently set to transmit localaudio.",
	"Method": "boolean isLocalAudioTransmissionEnabled(){\r\n    return audioDirectionUserPreference.allowsSending();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.systray.AbstractSystrayService.removePopupMessageListener",
	"Comment": "implements the systrayservice.removepopupmessagelistener method.",
	"Method": "void removePopupMessageListener(SystrayPopupMessageListener listener){\r\n    if (activePopupHandler != null)\r\n        activePopupHandler.removePopupMessageListener(listener);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.geolocation.event.LocalPositionChangeEvent.getOldGeolocation",
	"Comment": "returns the geolocation of the provider before this event took place.",
	"Method": "Map getOldGeolocation(){\r\n    return (Map) super.getOldValue();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatTransportSelectorBox.updateEnableStatus",
	"Comment": "sets the menu to enabled or disabled. the menu is enabled, as soon as itcontains one or more items. if it is empty, it is disabled.",
	"Method": "void updateEnableStatus(){\r\n    this.menu.setEnabled(this.menu.getItemCount() > 0);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.osdependent.jdic.StatusSubMenu.selectItemFromStatus",
	"Comment": "selects the menu item corresponding to the given status.for status constants we use here the values defined in thepresencestatus, but this is only for convenience.",
	"Method": "void selectItemFromStatus(int status){\r\n    String nameToSelect;\r\n    if (status < PresenceStatus.ONLINE_THRESHOLD) {\r\n        nameToSelect = GlobalStatusEnum.OFFLINE_STATUS;\r\n    } else if (status < PresenceStatus.EXTENDED_AWAY_THRESHOLD) {\r\n        nameToSelect = GlobalStatusEnum.DO_NOT_DISTURB_STATUS;\r\n    } else if (status < PresenceStatus.AWAY_THRESHOLD) {\r\n        nameToSelect = GlobalStatusEnum.EXTENDED_AWAY_STATUS;\r\n    } else if (status < PresenceStatus.AVAILABLE_THRESHOLD) {\r\n        nameToSelect = GlobalStatusEnum.AWAY_STATUS;\r\n    } else if (status < PresenceStatus.EAGER_TO_COMMUNICATE_THRESHOLD) {\r\n        nameToSelect = GlobalStatusEnum.ONLINE_STATUS;\r\n    } else if (status < PresenceStatus.MAX_STATUS_VALUE) {\r\n        nameToSelect = GlobalStatusEnum.FREE_FOR_CHAT_STATUS;\r\n    } else {\r\n        nameToSelect = GlobalStatusEnum.OFFLINE_STATUS;\r\n    }\r\n    if (menu instanceof Menu) {\r\n        Menu theMenu = (Menu) menu;\r\n        for (int i = 0; i < theMenu.getItemCount(); i++) {\r\n            MenuItem item = theMenu.getItem(i);\r\n            if (item instanceof CheckboxMenuItem) {\r\n                if (item.getName().equals(nameToSelect)) {\r\n                    ((CheckboxMenuItem) item).setState(true);\r\n                } else {\r\n                    ((CheckboxMenuItem) item).setState(false);\r\n                }\r\n            }\r\n        }\r\n    } else if (menu instanceof JMenu) {\r\n        JMenu theMenu = (JMenu) menu;\r\n        for (int i = 0; i < theMenu.getItemCount(); i++) {\r\n            JMenuItem item = theMenu.getItem(i);\r\n            if (item instanceof JCheckBoxMenuItem) {\r\n                if (item.getName().equals(nameToSelect))\r\n                    item.setSelected(true);\r\n                else\r\n                    item.setSelected(false);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.MetaContactChatTransport.removeSmsMessageListener",
	"Comment": "removes the given sms message listener from this chat transport.",
	"Method": "void removeSmsMessageListener(MessageListener l){\r\n    if (!allowsSmsMessage())\r\n        return;\r\n    OperationSetSmsMessaging smsOpSet = contact.getProtocolProvider().getOperationSet(OperationSetSmsMessaging.class);\r\n    smsOpSet.removeMessageListener(l);\r\n}"
}, {
	"Path": "net.librec.recommender.cf.ranking.SLIMRecommender.predict",
	"Comment": "predict a specific ranking score for user useridx on item itemidx.",
	"Method": "double predict(int userIdx,int itemIdx,int excludedItemIdx,double predict,int userIdx,int itemIdx){\r\n    if (!(null != itemNNs && itemNNs.length > 0)) {\r\n        createItemNNs();\r\n    }\r\n    return predict(userIdx, itemIdx, -1);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.getChatConversationPanel",
	"Comment": "returns the conversation panel, contained in this chat panel.",
	"Method": "ChatConversationPanel getChatConversationPanel(){\r\n    return this.conversationPanel;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ContactListTreeCellRenderer.setButtonBg",
	"Comment": "sets the background of the button depending on its position in the buttonbar.",
	"Method": "void setButtonBg(SIPCommButton button,int gridX,boolean isLast){\r\n    if (!isLast) {\r\n        if (gridX == 1)\r\n            button.setBackgroundImage(ImageLoader.getImage(ImageLoader.CONTACT_LIST_BUTTON_BG_LEFT));\r\n        else if (gridX > 1)\r\n            button.setBackgroundImage(ImageLoader.getImage(ImageLoader.CONTACT_LIST_BUTTON_BG_MIDDLE));\r\n    } else {\r\n        if (gridX == 1)\r\n            button.setBackgroundImage(ImageLoader.getImage(ImageLoader.CONTACT_LIST_ONE_BUTTON_BG));\r\n        else\r\n            button.setBackgroundImage(ImageLoader.getImage(ImageLoader.CONTACT_LIST_BUTTON_BG_RIGHT));\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.MetaContactChatTransport.allowsInstantMessage",
	"Comment": "returns true if this chat transport supports instantmessaging, otherwise returns false.",
	"Method": "boolean allowsInstantMessage(){\r\n    OperationSetContactCapabilities capOpSet = getProtocolProvider().getOperationSet(OperationSetContactCapabilities.class);\r\n    if (capOpSet != null) {\r\n        if (capOpSet.getOperationSet(contact, OperationSetBasicInstantMessaging.class) != null) {\r\n            return true;\r\n        }\r\n    } else if (contact.getProtocolProvider().getOperationSet(OperationSetBasicInstantMessaging.class) != null)\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.DesktopSharingProtocolSipImpl.parse",
	"Comment": "parses an xml element and returns a list of all mouseeventand keyevent found.",
	"Method": "List<ComponentEvent> parse(Element root,Dimension size,Point origin){\r\n    List<ComponentEvent> events = new ArrayList<ComponentEvent>();\r\n    NodeList nl = null;\r\n    int originX = origin != null ? origin.x : 0;\r\n    int originY = origin != null ? origin.y : 0;\r\n    nl = root.getElementsByTagName(ELEMENT_MOUSE_PRESS);\r\n    if (nl != null) {\r\n        for (int i = 0; i < nl.getLength(); i++) {\r\n            Element el = (Element) nl.item(i);\r\n            if (el.hasAttribute(\"btns\")) {\r\n                MouseEvent me = new MouseEvent(component, MouseEvent.MOUSE_PRESSED, System.currentTimeMillis(), Integer.parseInt(el.getAttribute(\"btns\")), 0, 0, 0, false, 0);\r\n                events.add(me);\r\n            }\r\n        }\r\n    }\r\n    nl = root.getElementsByTagName(ELEMENT_MOUSE_RELEASE);\r\n    if (nl != null) {\r\n        for (int i = 0; i < nl.getLength(); i++) {\r\n            Element el = (Element) nl.item(i);\r\n            if (el.hasAttribute(\"btns\")) {\r\n                MouseEvent me = new MouseEvent(component, MouseEvent.MOUSE_RELEASED, System.currentTimeMillis(), Integer.parseInt(el.getAttribute(\"btns\")), 0, 0, 0, false, 0);\r\n                events.add(me);\r\n            }\r\n        }\r\n    }\r\n    nl = root.getElementsByTagName(ELEMENT_MOUSE_MOVE);\r\n    if (nl != null) {\r\n        int x = -1;\r\n        int y = -1;\r\n        for (int i = 0; i < nl.getLength(); i++) {\r\n            Element el = (Element) nl.item(i);\r\n            if (el.hasAttribute(\"x\")) {\r\n                x = (int) (Double.parseDouble(el.getAttribute(\"x\")) * size.width + originX);\r\n            }\r\n            if (el.hasAttribute(\"y\")) {\r\n                y = (int) (Double.parseDouble(el.getAttribute(\"y\")) * size.height + originY);\r\n            }\r\n            {\r\n                MouseEvent me = new MouseEvent(component, MouseEvent.MOUSE_MOVED, System.currentTimeMillis(), 0, x, y, 0, false, 0);\r\n                events.add(me);\r\n            }\r\n        }\r\n    }\r\n    nl = root.getElementsByTagName(ELEMENT_MOUSE_WHEEL);\r\n    if (nl != null) {\r\n        for (int i = 0; i < nl.getLength(); i++) {\r\n            Element el = (Element) nl.item(i);\r\n            if (el.hasAttribute(\"notch\")) {\r\n                MouseWheelEvent me = new MouseWheelEvent(component, MouseEvent.MOUSE_WHEEL, System.currentTimeMillis(), 0, 0, 0, 0, false, 0, 0, Integer.parseInt(el.getAttribute(\"notch\")));\r\n                events.add(me);\r\n            }\r\n        }\r\n    }\r\n    nl = root.getElementsByTagName(ELEMENT_KEY_PRESS);\r\n    if (nl != null) {\r\n        for (int i = 0; i < nl.getLength(); i++) {\r\n            Element el = (Element) nl.item(i);\r\n            if (el.hasAttribute(\"keycode\")) {\r\n                KeyEvent ke = new KeyEvent(component, KeyEvent.KEY_PRESSED, System.currentTimeMillis(), 0, Integer.parseInt(el.getAttribute(\"keycode\")), (char) 0);\r\n                events.add(ke);\r\n            }\r\n        }\r\n    }\r\n    nl = root.getElementsByTagName(ELEMENT_KEY_RELEASE);\r\n    if (nl != null) {\r\n        for (int i = 0; i < nl.getLength(); i++) {\r\n            Element el = (Element) nl.item(i);\r\n            if (el.hasAttribute(\"keycode\")) {\r\n                KeyEvent ke = new KeyEvent(component, KeyEvent.KEY_RELEASED, System.currentTimeMillis(), 0, Integer.parseInt(el.getAttribute(\"keycode\")), (char) 0);\r\n                events.add(ke);\r\n            }\r\n        }\r\n    }\r\n    nl = root.getElementsByTagName(ELEMENT_KEY_TYPE);\r\n    if (nl != null) {\r\n        for (int i = 0; i < nl.getLength(); i++) {\r\n            Element el = (Element) nl.item(i);\r\n            if (el.hasAttribute(\"keychar\")) {\r\n                KeyEvent ke = new KeyEvent(component, KeyEvent.KEY_TYPED, System.currentTimeMillis(), 0, 0, (char) Integer.parseInt(el.getAttribute(\"keychar\")));\r\n                events.add(ke);\r\n            }\r\n        }\r\n    }\r\n    return events;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.MetaContactChatSession.contactResourceRemoved",
	"Comment": "called when a contactresource has been removed to the listof available contact resources.",
	"Method": "void contactResourceRemoved(ContactResourceEvent event){\r\n    Contact contact = event.getContact();\r\n    if (metaContact.containsContact(contact)) {\r\n        updateChatTransports(contact);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipLogger.logPacket",
	"Comment": "logs the specified message and details to the packet logging serviceif enabled.",
	"Method": "void logPacket(SIPMessage message,boolean sender){\r\n    try {\r\n        PacketLoggingService packetLogging = SipActivator.getPacketLogging();\r\n        if (packetLogging == null || !packetLogging.isLoggingEnabled(PacketLoggingService.ProtocolName.SIP) || message.getTopmostVia() == null)\r\n            return;\r\n        String transport = message.getTopmostVia().getTransport();\r\n        boolean isTransportUDP = transport.equalsIgnoreCase(\"UDP\");\r\n        byte[] srcAddr;\r\n        int srcPort;\r\n        byte[] dstAddr;\r\n        int dstPort;\r\n        if (sender) {\r\n            if (!isTransportUDP) {\r\n                InetSocketAddress localAddress = getLocalAddressForDestination(message.getRemoteAddress(), message.getRemotePort(), message.getLocalAddress(), transport);\r\n                if (localAddress != null) {\r\n                    srcPort = localAddress.getPort();\r\n                    srcAddr = localAddress.getAddress().getAddress();\r\n                } else {\r\n                    logger.warn(\"Could not obtain source address for \" + \" packet. Writing source as 0.0.0.0:0\");\r\n                    srcPort = 0;\r\n                    srcAddr = new byte[] { 0, 0, 0, 0 };\r\n                }\r\n            } else {\r\n                srcPort = message.getLocalPort();\r\n                if (message.getLocalAddress() != null)\r\n                    srcAddr = message.getLocalAddress().getAddress();\r\n                else if (message.getRemoteAddress() != null)\r\n                    srcAddr = new byte[message.getRemoteAddress().getAddress().length];\r\n                else\r\n                    srcAddr = new byte[4];\r\n            }\r\n            dstPort = message.getRemotePort();\r\n            if (message.getRemoteAddress() != null)\r\n                dstAddr = message.getRemoteAddress().getAddress();\r\n            else\r\n                dstAddr = new byte[srcAddr.length];\r\n        } else {\r\n            if (!isTransportUDP) {\r\n                InetSocketAddress dstAddress = getLocalAddressForDestination(message.getRemoteAddress(), message.getRemotePort(), message.getLocalAddress(), transport);\r\n                dstPort = dstAddress.getPort();\r\n                dstAddr = dstAddress.getAddress().getAddress();\r\n            } else {\r\n                dstPort = message.getLocalPort();\r\n                if (message.getLocalAddress() != null)\r\n                    dstAddr = message.getLocalAddress().getAddress();\r\n                else if (message.getRemoteAddress() != null)\r\n                    dstAddr = new byte[message.getRemoteAddress().getAddress().length];\r\n                else\r\n                    dstAddr = new byte[4];\r\n            }\r\n            srcPort = message.getRemotePort();\r\n            if (message.getRemoteAddress() != null)\r\n                srcAddr = message.getRemoteAddress().getAddress();\r\n            else\r\n                srcAddr = new byte[dstAddr.length];\r\n        }\r\n        byte[] msg = null;\r\n        if (message instanceof SIPRequest) {\r\n            SIPRequest req = (SIPRequest) message;\r\n            if (req.getMethod().equals(SIPRequest.MESSAGE) && message.getContentTypeHeader() != null && message.getContentTypeHeader().getContentType().equalsIgnoreCase(\"text\")) {\r\n                int len = req.getContentLength().getContentLength();\r\n                if (len > 0) {\r\n                    SIPRequest newReq = (SIPRequest) req.clone();\r\n                    byte[] newContent = new byte[len];\r\n                    Arrays.fill(newContent, (byte) '.');\r\n                    newReq.setMessageContent(newContent);\r\n                    msg = newReq.toString().getBytes(\"UTF-8\");\r\n                }\r\n            }\r\n        }\r\n        if (msg == null) {\r\n            msg = message.toString().getBytes(\"UTF-8\");\r\n        }\r\n        packetLogging.logPacket(PacketLoggingService.ProtocolName.SIP, srcAddr, srcPort, dstAddr, dstPort, isTransportUDP ? PacketLoggingService.TransportName.UDP : PacketLoggingService.TransportName.TCP, sender, msg);\r\n    } catch (Throwable e) {\r\n        logger.error(\"Cannot obtain message body\", e);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chatroomslist.ChatRoomTableDialog.initMoreFields",
	"Comment": "constructs the more label and the fields related to the label and returnsthem.",
	"Method": "Component initMoreFields(){\r\n    JPanel morePanel = new TransparentPanel(new BorderLayout());\r\n    morePanel.setOpaque(false);\r\n    morePanel.setBorder(BorderFactory.createEmptyBorder(0, 15, 5, 15));\r\n    moreFieldsPannel.setBorder(BorderFactory.createEmptyBorder(10, 30, 0, 0));\r\n    moreFieldsPannel.setOpaque(false);\r\n    moreFieldsPannel.setVisible(false);\r\n    JPanel subjectPanel = new TransparentPanel(new BorderLayout());\r\n    subject.setFont(getFont().deriveFont(12f));\r\n    subjectPanel.add(subject, BorderLayout.NORTH);\r\n    moreFieldsPannel.add(subjectPanel, BorderLayout.CENTER);\r\n    JPanel nicknamePanel = new TransparentPanel(new BorderLayout(5, 5));\r\n    setNickname((ChatRoomProviderWrapper) providersCombo.getSelectedItem());\r\n    nicknamePanel.add(nicknameField, BorderLayout.CENTER);\r\n    nicknamePanel.add(new JLabel(GuiActivator.getResources().getI18NString(\"service.gui.NICKNAME\")), BorderLayout.WEST);\r\n    moreFieldsPannel.add(nicknamePanel, BorderLayout.NORTH);\r\n    cmdExpandMoreFields = new JLabel();\r\n    cmdExpandMoreFields.setBorder(new EmptyBorder(0, 5, 0, 0));\r\n    cmdExpandMoreFields.setIcon(DesktopUtilActivator.getResources().getImage(\"service.gui.icons.RIGHT_ARROW_ICON\"));\r\n    cmdExpandMoreFields.setText(DesktopUtilActivator.getResources().getI18NString(\"service.gui.MORE_LABEL\"));\r\n    cmdExpandMoreFields.addMouseListener(new MouseAdapter() {\r\n        @Override\r\n        public void mouseClicked(MouseEvent e) {\r\n            cmdExpandMoreFields.setIcon(GuiActivator.getResources().getImage(moreFieldsPannel.isVisible() ? \"service.gui.icons.RIGHT_ARROW_ICON\" : \"service.gui.icons.DOWN_ARROW_ICON\"));\r\n            moreFieldsPannel.setVisible(!moreFieldsPannel.isVisible());\r\n            pack();\r\n        }\r\n    });\r\n    morePanel.add(cmdExpandMoreFields, BorderLayout.NORTH);\r\n    morePanel.add(moreFieldsPannel, BorderLayout.CENTER);\r\n    return morePanel;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chatroomslist.ChatRoomTableDialog.initMoreFields",
	"Comment": "constructs the more label and the fields related to the label and returnsthem.",
	"Method": "Component initMoreFields(){\r\n    cmdExpandMoreFields.setIcon(GuiActivator.getResources().getImage(moreFieldsPannel.isVisible() ? \"service.gui.icons.RIGHT_ARROW_ICON\" : \"service.gui.icons.DOWN_ARROW_ICON\"));\r\n    moreFieldsPannel.setVisible(!moreFieldsPannel.isVisible());\r\n    pack();\r\n}"
}, {
	"Path": "net.librec.data.model.TextDataModelTestCase.getTrainSize",
	"Comment": "returns the size of training matrix of a specified datamodel object",
	"Method": "int getTrainSize(DataModel dataModel){\r\n    return dataModel.getDataSplitter().getTrainData().size();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.WhiteboardParticipantJabberImpl.getContactAddress",
	"Comment": "returns the contact identifier representing this contact.",
	"Method": "String getContactAddress(){\r\n    return this.participant.getAddress();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.ReasonPacketExtension.setOtherExtension",
	"Comment": "sets the extra extension containing further info about this action ornull if no such extension has been specified.",
	"Method": "void setOtherExtension(PacketExtension otherExtension){\r\n    this.otherExtension = otherExtension;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockChatRoom.addLocalUserRoleListener",
	"Comment": "adds a listener that will be notified of changes in our role in the roomsuch as us being granded operator.",
	"Method": "void addLocalUserRoleListener(ChatRoomLocalUserRoleListener listener){\r\n    if (!localUserRoleListeners.contains(listener))\r\n        localUserRoleListeners.add(listener);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.jabber.JabberAccountID.isGoogleContactsEnabled",
	"Comment": "determines whether sip communicator should use google contacts ascontactsource",
	"Method": "boolean isGoogleContactsEnabled(){\r\n    return getAccountPropertyBoolean(GOOGLE_CONTACTS_ENABLED, true);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.OperationSetPersistentPresenceGibberishImpl.getCurrentStatusMessage",
	"Comment": "returns the status message that was last set throughsetcurrentstatusmessage.",
	"Method": "String getCurrentStatusMessage(){\r\n    return statusMessage;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactListServiceImpl.removeContactFromEventIgnoreList",
	"Comment": "removes the contact from the group event ignore list so thatevents concerning this group get treated.",
	"Method": "void removeContactFromEventIgnoreList(String contact,ProtocolProviderService ownerProvider){\r\n    if (!isContactInEventIgnoreList(contact, ownerProvider)) {\r\n        return;\r\n    }\r\n    List<ProtocolProviderService> existingProvList = this.contactEventIgnoreList.get(contact);\r\n    if (existingProvList.size() < 1) {\r\n        groupEventIgnoreList.remove(contact);\r\n    } else {\r\n        existingProvList.remove(ownerProvider);\r\n    }\r\n}"
}, {
	"Path": "net.librec.math.structure.DenseVector.times",
	"Comment": "return a new vector containing the product of each value of the recipient and the argument",
	"Method": "DenseVector times(double value,DenseVector times,DenseVector vector){\r\n    DenseVector resultVector = new VectorBasedDenseVector(cardinality());\r\n    resultVector.assign((index, tempValue) -> get(index) * vector.get(index));\r\n    return resultVector;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.sipaccregwizz.SIPAccountRegistrationWizard.loadAccount",
	"Comment": "fills the id and password fields in this panel with the data comingfrom the given protocolprovider.",
	"Method": "void loadAccount(ProtocolProviderService protocolProvider){\r\n    setModification(true);\r\n    this.protocolProvider = protocolProvider;\r\n    setRegistration(new SIPAccountRegistration());\r\n    AccountID currentAccountID = protocolProvider.getAccountID();\r\n    String password = SIPAccRegWizzActivator.getSIPProtocolProviderFactory().loadPassword(currentAccountID);\r\n    registration.loadAccount(protocolProvider.getAccountID(), password, SIPAccRegWizzActivator.bundleContext);\r\n    this.firstWizardPage.loadAccount(protocolProvider);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.iptelaccregwizz.IptelAccountRegistrationWizard.getProtocolName",
	"Comment": "implements the accountregistrationwizard.getprotocolnamemethod. returns the protocol name for this wizard.",
	"Method": "String getProtocolName(){\r\n    return Resources.getString(\"plugin.iptelaccregwizz.PROTOCOL_NAME\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.msoutlook.MsOutlookAddrBookSourceContact.setDisplayPostalAddress",
	"Comment": "generates and stores the string representation of the home and workpostall addresses.",
	"Method": "void setDisplayPostalAddress(){\r\n    synchronized (this) {\r\n        MsOutlookAddrBookContactDetail detail;\r\n        boolean firstLineCR = false;\r\n        boolean secondLineCR = false;\r\n        String workAddress = \"\";\r\n        detail = findDetail(MsOutlookAddrBookContactQuery.MAPI_MAILUSER_PROP_IDS[MsOutlookAddrBookContactQuery.PR_BUSINESS_ADDRESS_STREET]);\r\n        if (detail != null) {\r\n            workAddress += detail.getDetail();\r\n            firstLineCR = true;\r\n        }\r\n        detail = findDetail(MsOutlookAddrBookContactQuery.MAPI_MAILUSER_PROP_IDS[MsOutlookAddrBookContactQuery.PR_BUSINESS_ADDRESS_CITY]);\r\n        if (detail != null) {\r\n            if (firstLineCR) {\r\n                workAddress += \"\\r\";\r\n                firstLineCR = false;\r\n            }\r\n            workAddress += detail.getDetail();\r\n            workAddress += \" \";\r\n            secondLineCR = true;\r\n        }\r\n        detail = findDetail(MsOutlookAddrBookContactQuery.MAPI_MAILUSER_PROP_IDS[MsOutlookAddrBookContactQuery.PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE]);\r\n        if (detail != null) {\r\n            if (firstLineCR) {\r\n                workAddress += \"\\r\";\r\n                firstLineCR = false;\r\n            }\r\n            workAddress += detail.getDetail();\r\n            secondLineCR = true;\r\n        }\r\n        detail = findDetail(MsOutlookAddrBookContactQuery.MAPI_MAILUSER_PROP_IDS[MsOutlookAddrBookContactQuery.PR_BUSINESS_ADDRESS_POSTAL_CODE]);\r\n        if (detail != null) {\r\n            if (firstLineCR) {\r\n                workAddress += \"\\r\";\r\n                firstLineCR = false;\r\n            }\r\n            workAddress += detail.getDetail();\r\n            workAddress += \" \";\r\n            secondLineCR = true;\r\n        }\r\n        detail = findDetail(MsOutlookAddrBookContactQuery.MAPI_MAILUSER_PROP_IDS[MsOutlookAddrBookContactQuery.PR_BUSINESS_ADDRESS_COUNTRY]);\r\n        if (detail != null) {\r\n            if (secondLineCR) {\r\n                workAddress += \"\\r\";\r\n                secondLineCR = false;\r\n            }\r\n            workAddress += detail.getDetail();\r\n        }\r\n        detail = findDetail(MsOutlookAddrBookContactQuery.MAPI_MAILUSER_PROP_IDS[MsOutlookAddrBookContactQuery.dispidWorkAddress]);\r\n        if (detail != null) {\r\n            detail.setDetail(workAddress);\r\n        } else if (workAddress.length() > 0) {\r\n            detail = new MsOutlookAddrBookContactDetail(workAddress, MsOutlookAddrBookContactQuery.getCategory(MsOutlookAddrBookContactQuery.dispidWorkAddress), MsOutlookAddrBookContactQuery.getSubCategories(MsOutlookAddrBookContactQuery.dispidWorkAddress), MsOutlookAddrBookContactQuery.MAPI_MAILUSER_PROP_IDS[MsOutlookAddrBookContactQuery.dispidWorkAddress]);\r\n            this.contactDetails.add(detail);\r\n        }\r\n        firstLineCR = false;\r\n        secondLineCR = false;\r\n        String homeAddress = \"\";\r\n        detail = findDetail(MsOutlookAddrBookContactQuery.MAPI_MAILUSER_PROP_IDS[MsOutlookAddrBookContactQuery.PR_HOME_ADDRESS_STREET]);\r\n        if (detail != null) {\r\n            homeAddress += detail.getDetail();\r\n            firstLineCR = true;\r\n        }\r\n        detail = findDetail(MsOutlookAddrBookContactQuery.MAPI_MAILUSER_PROP_IDS[MsOutlookAddrBookContactQuery.PR_HOME_ADDRESS_CITY]);\r\n        if (detail != null) {\r\n            if (firstLineCR) {\r\n                homeAddress += \"\\r\";\r\n                firstLineCR = false;\r\n            }\r\n            homeAddress += detail.getDetail();\r\n            homeAddress += \" \";\r\n            secondLineCR = true;\r\n        }\r\n        detail = findDetail(MsOutlookAddrBookContactQuery.MAPI_MAILUSER_PROP_IDS[MsOutlookAddrBookContactQuery.PR_HOME_ADDRESS_STATE_OR_PROVINCE]);\r\n        if (detail != null) {\r\n            if (firstLineCR) {\r\n                homeAddress += \"\\r\";\r\n                firstLineCR = false;\r\n            }\r\n            homeAddress += detail.getDetail();\r\n            secondLineCR = true;\r\n        }\r\n        detail = findDetail(MsOutlookAddrBookContactQuery.MAPI_MAILUSER_PROP_IDS[MsOutlookAddrBookContactQuery.PR_HOME_ADDRESS_POSTAL_CODE]);\r\n        if (detail != null) {\r\n            if (firstLineCR) {\r\n                homeAddress += \"\\r\";\r\n                firstLineCR = false;\r\n            }\r\n            homeAddress += detail.getDetail();\r\n            homeAddress += \" \";\r\n            secondLineCR = true;\r\n        }\r\n        detail = findDetail(MsOutlookAddrBookContactQuery.MAPI_MAILUSER_PROP_IDS[MsOutlookAddrBookContactQuery.PR_HOME_ADDRESS_COUNTRY]);\r\n        if (detail != null) {\r\n            if (secondLineCR) {\r\n                homeAddress += \"\\r\";\r\n                secondLineCR = false;\r\n            }\r\n            homeAddress += detail.getDetail();\r\n        }\r\n        detail = findDetail(MsOutlookAddrBookContactQuery.MAPI_MAILUSER_PROP_IDS[MsOutlookAddrBookContactQuery.dispidHomeAddress]);\r\n        if (detail != null) {\r\n            detail.setDetail(homeAddress);\r\n        } else if (homeAddress.length() > 0) {\r\n            detail = new MsOutlookAddrBookContactDetail(homeAddress, MsOutlookAddrBookContactQuery.getCategory(MsOutlookAddrBookContactQuery.dispidHomeAddress), MsOutlookAddrBookContactQuery.getSubCategories(MsOutlookAddrBookContactQuery.dispidHomeAddress), MsOutlookAddrBookContactQuery.MAPI_MAILUSER_PROP_IDS[MsOutlookAddrBookContactQuery.dispidHomeAddress]);\r\n            this.contactDetails.add(detail);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.credentialsstorage.CredentialsStorageServiceImpl.setEncrypted",
	"Comment": "saves the encrypted account password using configuration service.",
	"Method": "void setEncrypted(String accountPrefix,String value){\r\n    configurationService.setProperty(accountPrefix + \".\" + ACCOUNT_ENCRYPTED_PASSWORD, value);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaAwareCallPeer.getLastConferenceInfoReceived",
	"Comment": "gets the last conferenceinfodocument sent to us by thiscallpeer.",
	"Method": "ConferenceInfoDocument getLastConferenceInfoReceived(){\r\n    return lastConferenceInfoReceived;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.findFileTransferChatTransport",
	"Comment": "returns the first chat transport for the current chat session thatsupports file transfer.",
	"Method": "ChatTransport findFileTransferChatTransport(){\r\n    if (chatSession instanceof ConferenceChatSession)\r\n        return null;\r\n    ChatTransport currentChatTransport = chatSession.getCurrentChatTransport();\r\n    if (currentChatTransport.getProtocolProvider().getOperationSet(OperationSetFileTransfer.class) != null) {\r\n        return currentChatTransport;\r\n    } else {\r\n        Iterator<ChatTransport> chatTransportsIter = chatSession.getChatTransports();\r\n        while (chatTransportsIter.hasNext()) {\r\n            ChatTransport chatTransport = chatTransportsIter.next();\r\n            Object fileTransferOpSet = chatTransport.getProtocolProvider().getOperationSet(OperationSetFileTransfer.class);\r\n            if (fileTransferOpSet != null)\r\n                return chatTransport;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.AbstractCallToggleButton.hierarchyChanged",
	"Comment": "notifies this instance that the ui hierarchy that it belongs to has beenchanged.",
	"Method": "void hierarchyChanged(HierarchyEvent ev){\r\n    CallPanel callPanel = null;\r\n    for (Container parent = getParent(); parent != null; parent = parent.getParent()) {\r\n        if (parent instanceof CallPanel) {\r\n            callPanel = (CallPanel) parent;\r\n            break;\r\n        }\r\n    }\r\n    if (this.callPanel != callPanel) {\r\n        if (this.callPanel != null) {\r\n            this.callPanel.removePropertyChangeListener(CallContainer.PROP_FULL_SCREEN, callPanelPropertyChangeListener);\r\n        }\r\n        this.callPanel = callPanel;\r\n        if (this.callPanel != null) {\r\n            this.callPanel.addPropertyChangeListener(CallContainer.PROP_FULL_SCREEN, callPanelPropertyChangeListener);\r\n        }\r\n        callPanelPropertyChange(null);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.NetworkUtils.mappedIPv4ToRealIPv4",
	"Comment": "returns an ipv4 address matching the one mapped in the ipv6addr. both input and returned value are in network order.",
	"Method": "byte[] mappedIPv4ToRealIPv4(byte[] addr){\r\n    if (isMappedIPv4Addr(addr)) {\r\n        byte[] newAddr = new byte[IN4_ADDR_SIZE];\r\n        System.arraycopy(addr, 12, newAddr, 0, IN6_ADDR_SIZE);\r\n        return newAddr;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.GroupNode.removeContactGroup",
	"Comment": "removes the node corresponding to the given uigroup from thisgroup node.",
	"Method": "void removeContactGroup(UIGroupImpl uiGroup){\r\n    GroupNode groupNode;\r\n    synchronized (uiGroup) {\r\n        groupNode = uiGroup.getGroupNode();\r\n        if (groupNode == null)\r\n            return;\r\n    }\r\n    int index = getIndex(groupNode);\r\n    if (index == -1)\r\n        return;\r\n    int selectedIndex = getLeadSelectionRow();\r\n    children.removeElementAt(index);\r\n    groupNode.setParent(null);\r\n    synchronized (uiGroup) {\r\n        uiGroup.setGroupNode(null);\r\n    }\r\n    fireNodeRemoved(groupNode, index);\r\n    refreshSelection(selectedIndex, getLeadSelectionRow());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.OperationSetMultiUserChatIrcImpl.getCurrentlyJoinedChatRooms",
	"Comment": "returns a list of the chat rooms that chatroommember has joinedand is currently active in.",
	"Method": "List<ChatRoom> getCurrentlyJoinedChatRooms(List<String> getCurrentlyJoinedChatRooms,ChatRoomMember chatRoomMember){\r\n    return Collections.emptyList();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.accountinfo.AccountInfoPanel.serviceChanged",
	"Comment": "handles registration and unregistration ofprotocolproviderservice",
	"Method": "void serviceChanged(ServiceEvent event){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                serviceChanged(event);\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    Object service = AccountInfoActivator.bundleContext.getService(event.getServiceReference());\r\n    if (!(service instanceof ProtocolProviderService))\r\n        return;\r\n    ProtocolProviderService protocolProvider = (ProtocolProviderService) service;\r\n    if (event.getType() == ServiceEvent.REGISTERED) {\r\n        if (accountsTable.get(protocolProvider.getAccountID()) == null) {\r\n            AccountDetailsPanel panel = new AccountDetailsPanel(dialog, protocolProvider);\r\n            accountsTable.put(protocolProvider.getAccountID(), panel);\r\n            accountsComboBox.addItem(panel);\r\n            protocolProvider.addRegistrationStateChangeListener(this);\r\n        }\r\n    } else if (event.getType() == ServiceEvent.UNREGISTERING) {\r\n        AccountDetailsPanel panel = accountsTable.get(protocolProvider.getAccountID());\r\n        if (panel != null) {\r\n            accountsTable.remove(protocolProvider.getAccountID());\r\n            accountsComboBox.removeItem(panel);\r\n            if (currentDetailsPanel == panel) {\r\n                currentDetailsPanel = null;\r\n                centerPanel.removeAll();\r\n                centerPanel.revalidate();\r\n                centerPanel.repaint();\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.accountinfo.AccountInfoPanel.serviceChanged",
	"Comment": "handles registration and unregistration ofprotocolproviderservice",
	"Method": "void serviceChanged(ServiceEvent event){\r\n    serviceChanged(event);\r\n}"
}, {
	"Path": "net.librec.recommender.context.ranking.DLambdaFMRecommender.ChooseNeg",
	"Comment": "randomly select 100 sample then score then rank then exp distribution",
	"Method": "int ChooseNeg(int size,int u,SequentialSparseVector pu){\r\n    Set<Integer> u_items = Arrays.stream(pu.getIndices()).boxed().collect(Collectors.toSet());\r\n    if (size > numItems) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    final double[] RankingPro;\r\n    RankingPro = new double[numItems];\r\n    Arrays.fill(RankingPro, -100.0);\r\n    RandomAccessSparseVector x_j;\r\n    for (int i = 0; i < size; i++) {\r\n        int j = 0;\r\n        do {\r\n            j = Randoms.uniform(numItems);\r\n        } while (u_items.contains(j));\r\n        int feature_j = itemFeatureMapping.get(j);\r\n        int[] featureKeys = new int[] { u, j, feature_j };\r\n        RankingPro[j] = predict(featureKeys);\r\n    }\r\n    Integer[] iidRank = new Integer[numItems];\r\n    for (int i = 0; i < numItems; i++) iidRank[i] = i;\r\n    Arrays.sort(iidRank, new Comparator<Integer>() {\r\n        @Override\r\n        public int compare(Integer o1, Integer o2) {\r\n            return (RankingPro[o1] > RankingPro[o2] ? -1 : (RankingPro[o1] < RankingPro[o2] ? 1 : 0));\r\n        }\r\n    });\r\n    double sum = 0.0;\r\n    double[] iidRelativeRank = new double[numItems];\r\n    for (int i = 0; i < size; ++i) {\r\n        int iid = iidRank[i];\r\n        iidRelativeRank[iid] = Math.exp(-(i + 1) / (size * rho));\r\n        sum += iidRelativeRank[iid];\r\n    }\r\n    Map<Integer, Integer> map = new HashMap<Integer, Integer>();\r\n    double[] iidRelativeRank_small = new double[size];\r\n    int k = 0;\r\n    for (int i = 0; i < iidRelativeRank.length; i++) {\r\n        if (iidRelativeRank[i] != 0) {\r\n            iidRelativeRank[i] = iidRelativeRank[i] / sum;\r\n            iidRelativeRank_small[k] = iidRelativeRank[i];\r\n            map.put(k, i);\r\n            k++;\r\n        }\r\n    }\r\n    int index = Randoms.discrete(iidRelativeRank_small);\r\n    return map.get(index);\r\n}"
}, {
	"Path": "net.librec.recommender.context.ranking.DLambdaFMRecommender.ChooseNeg",
	"Comment": "randomly select 100 sample then score then rank then exp distribution",
	"Method": "int ChooseNeg(int size,int u,SequentialSparseVector pu){\r\n    return (RankingPro[o1] > RankingPro[o2] ? -1 : (RankingPro[o1] < RankingPro[o2] ? 1 : 0));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.geolocation.GeolocationPacketExtension.addFloatXmlElement",
	"Comment": "creates the xml string corresponding to the specified elementand its float value and adds them to the bufstringbuffer.",
	"Method": "StringBuffer addFloatXmlElement(StringBuffer buff,String element,float value){\r\n    if (value != -1) {\r\n        buff.append(\"<\").append(element).append(\">\").append(value).append(\"<\/\").append(element).append(\">\");\r\n    }\r\n    return buff;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomIrcImpl.addMemberPresenceListener",
	"Comment": "adds a listener that will be notified of changes in our status in theroom such as us being kicked, banned, or granted admin permissions.",
	"Method": "void addMemberPresenceListener(ChatRoomMemberPresenceListener listener){\r\n    synchronized (memberListeners) {\r\n        if (!memberListeners.contains(listener)) {\r\n            memberListeners.add(listener);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.packetlogging.PacketLoggingActivator.getFileAccessService",
	"Comment": "returns the fileaccessservice obtained from the bundle context.",
	"Method": "FileAccessService getFileAccessService(){\r\n    return fileAccessService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MclStorageManager.createProtoContactGroupNode",
	"Comment": "creates a new xml element corresponding toprotogroup or null if protogroup is noteligible for serialization in its current state.",
	"Method": "Element createProtoContactGroupNode(ContactGroup protoGroup){\r\n    Element protoGroupElement = contactListDocument.createElement(PROTO_GROUP_NODE_NAME);\r\n    protoGroupElement.setAttribute(UID_ATTR_NAME, protoGroup.getUID());\r\n    protoGroupElement.setAttribute(ACCOUNT_ID_ATTR_NAME, protoGroup.getProtocolProvider().getAccountID().getAccountUniqueID());\r\n    ContactGroup parentContactGroup = protoGroup.getParentContactGroup();\r\n    if (parentContactGroup != null)\r\n        protoGroupElement.setAttribute(PARENT_PROTO_GROUP_UID_ATTR_NAME, parentContactGroup.getUID());\r\n    String persistentData = protoGroup.getPersistentData();\r\n    if ((persistentData != null) && (persistentData.length() != 0)) {\r\n        Element persDataNode = contactListDocument.createElement(PERSISTENT_DATA_NODE_NAME);\r\n        XMLUtils.setText(persDataNode, persistentData);\r\n        protoGroupElement.appendChild(persDataNode);\r\n    }\r\n    return protoGroupElement;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.NetworkUtils.isMappedIPv4Addr",
	"Comment": "utility method to check if the specified address is an ipv4mapped ipv6 address.",
	"Method": "boolean isMappedIPv4Addr(byte[] address){\r\n    if (address.length < IN6_ADDR_SIZE) {\r\n        return false;\r\n    }\r\n    if ((address[0] == 0x00) && (address[1] == 0x00) && (address[2] == 0x00) && (address[3] == 0x00) && (address[4] == 0x00) && (address[5] == 0x00) && (address[6] == 0x00) && (address[7] == 0x00) && (address[8] == 0x00) && (address[9] == 0x00) && (address[10] == (byte) 0xff) && (address[11] == (byte) 0xff)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.otr.ScOtrEngineImpl.getListeners",
	"Comment": "gets a copy of the list of scotrenginelisteners registered withthis instance which may safely be iterated without the risk of aconcurrentmodificationexception.",
	"Method": "ScOtrEngineListener[] getListeners(){\r\n    synchronized (listeners) {\r\n        return listeners.toArray(new ScOtrEngineListener[listeners.size()]);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.FailoverConnectionMonitor.getInstance",
	"Comment": "returns instance of the monitor for provider, if missing create it.",
	"Method": "FailoverConnectionMonitor getInstance(ProtocolProviderServiceJabberImpl provider){\r\n    FailoverConnectionMonitor fov;\r\n    synchronized (providerFilovers) {\r\n        fov = providerFilovers.get(provider);\r\n        if (fov == null) {\r\n            fov = new FailoverConnectionMonitor(provider);\r\n            providerFilovers.put(provider, fov);\r\n        }\r\n    }\r\n    return fov;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.notification.NotificationData.getIcon",
	"Comment": "gets the icon to show in the notification if and where appropriate.",
	"Method": "byte[] getIcon(){\r\n    return icon;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.wizard.EncryptionConfigurationTableModel.getEncryptionProtocolStatus",
	"Comment": "returns the map between encryption protocol names and their status.",
	"Method": "Map<String, Boolean> getEncryptionProtocolStatus(){\r\n    Map<String, Boolean> encryptionProtocolStatusMap = new HashMap<String, Boolean>(this.encryptionProtocolStatus.length);\r\n    for (int i = 0; i < this.encryptionProtocolStatus.length; ++i) {\r\n        encryptionProtocolStatusMap.put(encryptionProtocols[i], new Boolean(encryptionProtocolStatus[i]));\r\n    }\r\n    return encryptionProtocolStatusMap;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactImpl.toString",
	"Comment": "returns a string representation of this contact, containing most of itsrepresentative details.",
	"Method": "String toString(){\r\n    StringBuffer buff = new StringBuffer(\"MetaContact[ DisplayName=\").append(getDisplayName()).append(\"]\");\r\n    return buff.toString();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.CallPeerMediaHandlerJabberImpl.throwOperationFailedException",
	"Comment": "lets the underlying implementation take note of this error and onlythen throws it to the using bundles.",
	"Method": "void throwOperationFailedException(String message,int errorCode,Throwable cause){\r\n    ProtocolProviderServiceJabberImpl.throwOperationFailedException(message, errorCode, cause, logger);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.colibri.ColibriConferenceIQ.createGracefulShutdownErrorResponse",
	"Comment": "returns an error response for given iq that is returned bythe videobridge after it has entered graceful shutdown mode and newconferences can no longer be created.",
	"Method": "IQ createGracefulShutdownErrorResponse(IQ request){\r\n    final XMPPError error = new XMPPError(XMPPError.Condition.service_unavailable);\r\n    error.addExtension(new GracefulShutdown());\r\n    final IQ result = IQ.createErrorResponse(request, error);\r\n    result.setType(Type.ERROR);\r\n    result.setPacketID(request.getPacketID());\r\n    result.setFrom(request.getTo());\r\n    result.setTo(request.getFrom());\r\n    result.setError(error);\r\n    return result;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.ChatRoomMessageDeliveredEvent.setHistoryMessage",
	"Comment": "changes property, whether this event is for a history message.",
	"Method": "void setHistoryMessage(boolean historyMessage){\r\n    this.historyMessage = historyMessage;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.net.ProxyConnection.getNextAddress",
	"Comment": "retrieves the next address to use from dns. duplicate results aresuppressed.",
	"Method": "boolean getNextAddress(){\r\n    boolean result;\r\n    String key = null;\r\n    do {\r\n        result = getNextAddressFromDns();\r\n        if (result && socketAddress != null) {\r\n            key = getOutboundProxyString();\r\n            if (!returnedAddresses.contains(key)) {\r\n                returnedAddresses.add(key);\r\n                break;\r\n            }\r\n        }\r\n    } while (result && returnedAddresses.contains(key));\r\n    return result;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.neomedia.MediaConfigurationImpl.createAudioSystemControls",
	"Comment": "creates the ui controls which are to control the details of a specificaudiosystem.",
	"Method": "void createAudioSystemControls(AudioSystem audioSystem,JComponent container){\r\n    GridBagConstraints cnstrnts = new GridBagConstraints();\r\n    cnstrnts.anchor = GridBagConstraints.NORTHWEST;\r\n    cnstrnts.fill = GridBagConstraints.HORIZONTAL;\r\n    cnstrnts.weighty = 0;\r\n    int audioSystemFeatures = audioSystem.getFeatures();\r\n    boolean featureNotifyAndPlaybackDevices = ((audioSystemFeatures & AudioSystem.FEATURE_NOTIFY_AND_PLAYBACK_DEVICES) != 0);\r\n    cnstrnts.gridx = 0;\r\n    cnstrnts.insets = new Insets(3, 0, 3, 3);\r\n    cnstrnts.weightx = 0;\r\n    cnstrnts.gridy = 0;\r\n    container.add(new JLabel(getLabelText(DeviceConfigurationComboBoxModel.AUDIO_CAPTURE)), cnstrnts);\r\n    if (featureNotifyAndPlaybackDevices) {\r\n        cnstrnts.gridy = 2;\r\n        container.add(new JLabel(getLabelText(DeviceConfigurationComboBoxModel.AUDIO_PLAYBACK)), cnstrnts);\r\n        cnstrnts.gridy = 3;\r\n        container.add(new JLabel(getLabelText(DeviceConfigurationComboBoxModel.AUDIO_NOTIFY)), cnstrnts);\r\n    }\r\n    cnstrnts.gridx = 1;\r\n    cnstrnts.insets = new Insets(3, 3, 3, 0);\r\n    cnstrnts.weightx = 1;\r\n    JComboBox captureCombo = null;\r\n    if (featureNotifyAndPlaybackDevices) {\r\n        captureCombo = new JComboBox();\r\n        captureCombo.setEditable(false);\r\n        captureCombo.setModel(new DeviceConfigurationComboBoxModel(mediaService.getDeviceConfiguration(), DeviceConfigurationComboBoxModel.AUDIO_CAPTURE));\r\n        cnstrnts.gridy = 0;\r\n        container.add(captureCombo, cnstrnts);\r\n    }\r\n    int anchor = cnstrnts.anchor;\r\n    SoundLevelIndicator capturePreview = new SoundLevelIndicator(SimpleAudioLevelListener.MIN_LEVEL, SimpleAudioLevelListener.MAX_LEVEL);\r\n    cnstrnts.anchor = GridBagConstraints.CENTER;\r\n    cnstrnts.gridy = (captureCombo == null) ? 0 : 1;\r\n    container.add(capturePreview, cnstrnts);\r\n    cnstrnts.anchor = anchor;\r\n    cnstrnts.gridy = GridBagConstraints.RELATIVE;\r\n    if (featureNotifyAndPlaybackDevices) {\r\n        playbackCombo = new JComboBox();\r\n        playbackCombo.setEditable(false);\r\n        playbackCombo.setModel(new DeviceConfigurationComboBoxModel(mediaService.getDeviceConfiguration(), DeviceConfigurationComboBoxModel.AUDIO_PLAYBACK));\r\n        playbackCombo.addActionListener(this);\r\n        container.add(playbackCombo, cnstrnts);\r\n        notifyCombo = new JComboBox();\r\n        notifyCombo.setEditable(false);\r\n        notifyCombo.setModel(new DeviceConfigurationComboBoxModel(mediaService.getDeviceConfiguration(), DeviceConfigurationComboBoxModel.AUDIO_NOTIFY));\r\n        notifyCombo.addActionListener(this);\r\n        container.add(notifyCombo, cnstrnts);\r\n    }\r\n    int[] checkBoxAudioSystemFeatures = new int[] { AudioSystem.FEATURE_ECHO_CANCELLATION, AudioSystem.FEATURE_DENOISE, AudioSystem.FEATURE_AGC };\r\n    for (int i = 0; i < checkBoxAudioSystemFeatures.length; i++) {\r\n        final int f = checkBoxAudioSystemFeatures[i];\r\n        if ((f & audioSystemFeatures) != 0) {\r\n            String textKey;\r\n            boolean selected;\r\n            switch(f) {\r\n                case AudioSystem.FEATURE_AGC:\r\n                    textKey = \"impl.media.configform.AUTOMATICGAINCONTROL\";\r\n                    selected = audioSystem.isAutomaticGainControl();\r\n                    break;\r\n                case AudioSystem.FEATURE_DENOISE:\r\n                    textKey = \"impl.media.configform.DENOISE\";\r\n                    selected = audioSystem.isDenoise();\r\n                    break;\r\n                case AudioSystem.FEATURE_ECHO_CANCELLATION:\r\n                    textKey = \"impl.media.configform.ECHOCANCEL\";\r\n                    selected = audioSystem.isEchoCancel();\r\n                    break;\r\n                default:\r\n                    continue;\r\n            }\r\n            final SIPCommCheckBox checkBox = new SIPCommCheckBox(NeomediaActivator.getResources().getI18NString(textKey));\r\n            checkBox.setSelected(selected);\r\n            checkBox.addItemListener(new ItemListener() {\r\n                public void itemStateChanged(ItemEvent e) {\r\n                    boolean b = checkBox.isSelected();\r\n                    switch(f) {\r\n                        case AudioSystem.FEATURE_AGC:\r\n                            audioSystem.setAutomaticGainControl(b);\r\n                            break;\r\n                        case AudioSystem.FEATURE_DENOISE:\r\n                            audioSystem.setDenoise(b);\r\n                            break;\r\n                        case AudioSystem.FEATURE_ECHO_CANCELLATION:\r\n                            audioSystem.setEchoCancel(b);\r\n                            break;\r\n                    }\r\n                }\r\n            });\r\n            container.add(checkBox, cnstrnts);\r\n        }\r\n    }\r\n    cnstrnts.gridx = 2;\r\n    cnstrnts.insets = new Insets(3, 3, 3, 0);\r\n    cnstrnts.weightx = 0;\r\n    if (featureNotifyAndPlaybackDevices) {\r\n        cnstrnts.gridy = 2;\r\n        playbackPlaySoundButton = new JButton(new ImageIcon(NeomediaActivator.getResources().getImageInBytes(\"plugin.notificationconfig.PLAY_ICON\")));\r\n        playbackPlaySoundButton.setMinimumSize(new Dimension(30, 30));\r\n        playbackPlaySoundButton.setPreferredSize(new Dimension(30, 30));\r\n        if (((DeviceConfigurationComboBoxModel.CaptureDevice) playbackCombo.getSelectedItem()).info == null) {\r\n            playbackPlaySoundButton.setEnabled(false);\r\n        }\r\n        playbackPlaySoundButton.setOpaque(false);\r\n        playbackPlaySoundButton.addActionListener(this);\r\n        container.add(playbackPlaySoundButton, cnstrnts);\r\n        cnstrnts.gridy = 3;\r\n        notificationPlaySoundButton = new JButton(new ImageIcon(NeomediaActivator.getResources().getImageInBytes(\"plugin.notificationconfig.PLAY_ICON\")));\r\n        notificationPlaySoundButton.setMinimumSize(new Dimension(30, 30));\r\n        notificationPlaySoundButton.setPreferredSize(new Dimension(30, 30));\r\n        if (((DeviceConfigurationComboBoxModel.CaptureDevice) notifyCombo.getSelectedItem()).info == null) {\r\n            notificationPlaySoundButton.setEnabled(false);\r\n        }\r\n        notificationPlaySoundButton.setOpaque(false);\r\n        notificationPlaySoundButton.addActionListener(this);\r\n        container.add(notificationPlaySoundButton, cnstrnts);\r\n    }\r\n    if (audioLevelListenerThread == null) {\r\n        audioLevelListenerThread = new AudioLevelListenerThread(audioSystem, captureCombo, capturePreview);\r\n    } else {\r\n        audioLevelListenerThread.init(audioSystem, captureCombo, capturePreview);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.neomedia.MediaConfigurationImpl.createAudioSystemControls",
	"Comment": "creates the ui controls which are to control the details of a specificaudiosystem.",
	"Method": "void createAudioSystemControls(AudioSystem audioSystem,JComponent container){\r\n    boolean b = checkBox.isSelected();\r\n    switch(f) {\r\n        case AudioSystem.FEATURE_AGC:\r\n            audioSystem.setAutomaticGainControl(b);\r\n            break;\r\n        case AudioSystem.FEATURE_DENOISE:\r\n            audioSystem.setDenoise(b);\r\n            break;\r\n        case AudioSystem.FEATURE_ECHO_CANCELLATION:\r\n            audioSystem.setEchoCancel(b);\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.reconnectplugin.ReconnectPluginActivator.registrationStateChanged",
	"Comment": "the method is called by a protocolproviderserviceimplementation whenever a change in the registration state of thecorresponding provider had occurred.",
	"Method": "void registrationStateChanged(RegistrationStateChangeEvent evt){\r\n    if (!(evt.getSource() instanceof ProtocolProviderService) || !(evt.getNewState().equals(RegistrationState.REGISTERED) || evt.getNewState().equals(RegistrationState.UNREGISTERED) || evt.getNewState().equals(RegistrationState.CONNECTION_FAILED)))\r\n        return;\r\n    synchronized (this) {\r\n        try {\r\n            ProtocolProviderService pp = (ProtocolProviderService) evt.getSource();\r\n            boolean isServerReturnedErroneousInputEvent = evt.getNewState().equals(RegistrationState.CONNECTION_FAILED) && evt.getReasonCode() == RegistrationStateChangeEvent.REASON_SERVER_RETURNED_ERRONEOUS_INPUT;\r\n            if (evt.getNewState().equals(RegistrationState.CONNECTION_FAILED) && !isServerReturnedErroneousInputEvent) {\r\n                if (!hasAtLeastOneSuccessfulConnection(pp)) {\r\n                    if (evt.getReasonCode() == RegistrationStateChangeEvent.REASON_NON_EXISTING_USER_ID) {\r\n                        notify(getResources().getI18NString(\"service.gui.ERROR\"), \"service.gui.NON_EXISTING_USER_ID\", new String[] { pp.getAccountID().getService() }, pp.getAccountID());\r\n                    } else {\r\n                        notify(getResources().getI18NString(\"service.gui.ERROR\"), \"plugin.reconnectplugin.CONNECTION_FAILED_MSG\", new String[] { pp.getAccountID().getUserID(), pp.getAccountID().getService() }, pp.getAccountID());\r\n                    }\r\n                    return;\r\n                }\r\n                if (needsReconnection.contains(pp))\r\n                    return;\r\n                if (connectedInterfaces.isEmpty()) {\r\n                    needsReconnection.add(pp);\r\n                    if (currentlyReconnecting.containsKey(pp))\r\n                        currentlyReconnecting.remove(pp).cancel();\r\n                } else {\r\n                    reconnect(pp);\r\n                }\r\n                unregisteringProviders.remove(pp);\r\n                if (logger.isTraceEnabled()) {\r\n                    logger.trace(\"Got Connection Failed for \" + pp, new Exception(\"tracing exception\"));\r\n                    traceCurrentPPState();\r\n                }\r\n            } else if (evt.getNewState().equals(RegistrationState.REGISTERED)) {\r\n                if (!hasAtLeastOneSuccessfulConnection(pp)) {\r\n                    setAtLeastOneSuccessfulConnection(pp, true);\r\n                }\r\n                autoReconnEnabledProviders.put(pp, new ArrayList<String>(connectedInterfaces));\r\n                if (currentlyReconnecting.containsKey(pp))\r\n                    currentlyReconnecting.remove(pp).cancel();\r\n                unregisteringProviders.remove(pp);\r\n                if (logger.isTraceEnabled()) {\r\n                    logger.trace(\"Got Registered for \" + pp);\r\n                    traceCurrentPPState();\r\n                }\r\n            } else if (evt.getNewState().equals(RegistrationState.UNREGISTERED) || isServerReturnedErroneousInputEvent) {\r\n                if (evt.isUserRequest() || isServerReturnedErroneousInputEvent)\r\n                    autoReconnEnabledProviders.remove(pp);\r\n                if (!unregisteringProviders.contains(pp) && currentlyReconnecting.containsKey(pp)) {\r\n                    currentlyReconnecting.remove(pp).cancel();\r\n                }\r\n                unregisteringProviders.remove(pp);\r\n                if (logger.isTraceEnabled()) {\r\n                    logger.trace(\"Got Unregistered for \" + pp);\r\n                    if (!currentlyReconnecting.containsKey(pp) && !needsReconnection.contains(pp) && logger.isTraceEnabled()) {\r\n                        logger.trace(\"Provider is unregistered and will not \" + \"be reconnected (maybe on user request): \" + pp + \" / reason:\" + evt.getReason() + \" / reasonCode:\" + evt.getReasonCode() + \" / oldState:\" + evt.getOldState(), new Exception(\"Trace exception.\"));\r\n                    }\r\n                    traceCurrentPPState();\r\n                }\r\n            }\r\n        } catch (Throwable ex) {\r\n            logger.error(\"Error dispatching protocol registration change\", ex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.whiteboard.gui.WhiteboardPanel.formMousePressed",
	"Comment": "invoked when a mouse button has been pressed on the whiteboardpanel.",
	"Method": "void formMousePressed(java.awt.event.MouseEvent evt){\r\n    checkPopupEvent(evt);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.ShowMoreContact.getStatusIcon",
	"Comment": "returns null to indicate that this contact has no status icon.",
	"Method": "ImageIcon getStatusIcon(){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.notificationconfiguration.NotificationEntry.getSoundPlayback",
	"Comment": "method which returns if one sound is to be played on playback device.",
	"Method": "boolean getSoundPlayback(){\r\n    return this.soundPlayback;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.DynamicPayloadTypeRegistry.addMapping",
	"Comment": "adds the specified format to payloadtype mapping tothe list of mappings known to this registry. if the mapping alreadyexists in the registry then we will use the new value to create anoverriding mapping. this basically means that we will expect packets tobe streamed to us with the original pt but we will be streaming withthe method is meant foruse primarily when handling incoming media descriptions, methodsgenerating local sdp should use the obtainpayloadtypenumberinstead.",
	"Method": "void addMapping(MediaFormat format,byte payloadType){\r\n    MediaFormat alreadyMappedFmt = findFormat(payloadType);\r\n    if (alreadyMappedFmt != null) {\r\n        if (alreadyMappedFmt.matches(format)) {\r\n            payloadTypeOverrides.remove(payloadType);\r\n            return;\r\n        }\r\n        byte newlyObtainedPT = obtainPayloadTypeNumber(format);\r\n        logger.warn(\"Remote party is trying to remap payload type \" + payloadType + \" and reassign it from \" + alreadyMappedFmt + \" to \" + format + \". We'll go along but there might be issues because\" + \" of this. We'll also expect to receive \" + format + \" with PT=\" + newlyObtainedPT);\r\n    }\r\n    if (payloadType < MediaFormat.MIN_DYNAMIC_PAYLOAD_TYPE) {\r\n        throw new IllegalArgumentException(payloadType + \" is not a valid dynamic payload type number.\" + \" (must be between \" + MediaFormat.MIN_DYNAMIC_PAYLOAD_TYPE + \" and \" + MediaFormat.MAX_DYNAMIC_PAYLOAD_TYPE);\r\n    }\r\n    Byte originalPayloadType = getPayloadType(format);\r\n    if (originalPayloadType != null && originalPayloadType != payloadType) {\r\n        payloadTypeOverrides.put(originalPayloadType, payloadType);\r\n    } else {\r\n        payloadTypeMappings.put(format, Byte.valueOf(payloadType));\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetMultiUserChatJabberImpl.getCurrentlyJoinedChatRooms",
	"Comment": "returns the list of currently joined chat rooms forchatroommember.",
	"Method": "List<ChatRoom> getCurrentlyJoinedChatRooms(List<String> getCurrentlyJoinedChatRooms,ChatRoomMember chatRoomMember){\r\n    assertSupportedAndConnected();\r\n    Iterator<String> joinedRoomsIter = MultiUserChat.getJoinedRooms(getXmppConnection(), chatRoomMember.getContactAddress());\r\n    List<String> joinedRooms = new ArrayList<String>();\r\n    while (joinedRoomsIter.hasNext()) joinedRooms.add(joinedRoomsIter.next());\r\n    return joinedRooms;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageHistoryServiceImpl.serviceChanged",
	"Comment": "when new protocol provider is registered we checkdoes it supports basicim and if so add a listener to it",
	"Method": "void serviceChanged(ServiceEvent serviceEvent){\r\n    Object sService = bundleContext.getService(serviceEvent.getServiceReference());\r\n    if (logger.isTraceEnabled())\r\n        logger.trace(\"Received a service event for: \" + sService.getClass().getName());\r\n    if (!(sService instanceof ProtocolProviderService)) {\r\n        return;\r\n    }\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Service is a protocol provider.\");\r\n    if (serviceEvent.getType() == ServiceEvent.REGISTERED) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Handling registration of a new Protocol Provider.\");\r\n        this.handleProviderAdded((ProtocolProviderService) sService);\r\n    } else if (serviceEvent.getType() == ServiceEvent.UNREGISTERING) {\r\n        this.handleProviderRemoved((ProtocolProviderService) sService);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomJabberImpl.fireMemberPropertyChangeEvent",
	"Comment": "delivers the specified event to all registered property change listeners.",
	"Method": "void fireMemberPropertyChangeEvent(ChatRoomMemberPropertyChangeEvent evt){\r\n    Iterable<ChatRoomMemberPropertyChangeListener> listeners;\r\n    synchronized (memberPropChangeListeners) {\r\n        listeners = new ArrayList<ChatRoomMemberPropertyChangeListener>(memberPropChangeListeners);\r\n    }\r\n    for (ChatRoomMemberPropertyChangeListener listener : listeners) listener.chatRoomPropertyChanged(evt);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.GuiActivator.getProtocolProviderFactories",
	"Comment": "returns all protocolproviderfactorys obtained from the bundlecontext.",
	"Method": "Map<Object, ProtocolProviderFactory> getProtocolProviderFactories(){\r\n    Collection<ServiceReference<ProtocolProviderFactory>> serRefs = ServiceUtils.getServiceReferences(bundleContext, ProtocolProviderFactory.class);\r\n    if (!serRefs.isEmpty()) {\r\n        for (ServiceReference<ProtocolProviderFactory> serRef : serRefs) {\r\n            ProtocolProviderFactory providerFactory = bundleContext.getService(serRef);\r\n            providerFactoriesMap.put(serRef.getProperty(ProtocolProviderFactory.PROTOCOL), providerFactory);\r\n        }\r\n    }\r\n    return providerFactoriesMap;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.UIFilterQuery.containsQuery",
	"Comment": "verifies if the given query is contained in this filter query.",
	"Method": "boolean containsQuery(Object query){\r\n    return filterQueries.containsKey(query);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.FullUserInfoCmd.readMoreUserInfo",
	"Comment": "method for parsing incoming dataread data in moreuserinfo command",
	"Method": "void readMoreUserInfo(ByteBlock block,int requestID){\r\n    Hashtable<String, Object> infoData = getInfoForRequest(requestID);\r\n    int offset = 1;\r\n    String[] tmp = new String[1];\r\n    offset += 2;\r\n    offset += 1;\r\n    offset = readStrings(block, tmp, offset);\r\n    offset += 2;\r\n    offset += 1;\r\n    offset += 1;\r\n    ArrayList<Integer> langs = new ArrayList<Integer>();\r\n    short speakingLanguage1 = getUByte(block, offset);\r\n    offset += 1;\r\n    if (speakingLanguage1 != 0 && speakingLanguage1 != 255) {\r\n        langs.add(new Integer(speakingLanguage1));\r\n    }\r\n    short speakingLanguage2 = getUByte(block, offset);\r\n    offset += 1;\r\n    if (speakingLanguage2 != 0 && speakingLanguage2 != 255) {\r\n        langs.add(new Integer(speakingLanguage2));\r\n    }\r\n    short speakingLanguage3 = getUByte(block, offset);\r\n    offset += 1;\r\n    if (speakingLanguage3 != 0 && speakingLanguage3 != 255) {\r\n        langs.add(new Integer(speakingLanguage3));\r\n    }\r\n    infoData.put(SPEAK_LANG, langs);\r\n}"
}, {
	"Path": "design.Trie.startsWith",
	"Comment": "returns if there is any word in the trie that starts with the given prefix.",
	"Method": "boolean startsWith(String prefix,boolean startsWith,int i,String prefix,int length){\r\n    if (i < length) {\r\n        char c = prefix.charAt(i);\r\n        Trie subTrie = map.get(c);\r\n        if (subTrie == null)\r\n            return false;\r\n        return subTrie.startsWith(i + 1, prefix, length);\r\n    } else\r\n        return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.launchutils.SipCommunicatorLock.readLockFileRetrying",
	"Comment": "calls reading of the lock file, retrying if there is nothing written init.",
	"Method": "InetSocketAddress readLockFileRetrying(File lockFile){\r\n    int retries = LOCK_FILE_READ_RETRY;\r\n    InetSocketAddress res = null;\r\n    while (res == null && retries > 0) {\r\n        res = readLockFile(lockFile);\r\n        if (res == null) {\r\n            try {\r\n                Thread.sleep(LOCK_FILE_READ_WAIT);\r\n            } catch (InterruptedException e) {\r\n            }\r\n        }\r\n        retries--;\r\n    }\r\n    return res;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ChatContactCellRenderer.getAvatar",
	"Comment": "gets the avatar of a specific metacontact in the form of animageicon value.",
	"Method": "ImageIcon getAvatar(MetaContact metaContact){\r\n    byte[] avatarBytes = metaContact.getAvatar(true);\r\n    ImageIcon avatar = null;\r\n    Object[] avatarCache = (Object[]) metaContact.getData(AVATAR_DATA_KEY);\r\n    if ((avatarCache != null) && (avatarCache[0] == avatarBytes))\r\n        avatar = (ImageIcon) avatarCache[1];\r\n    if ((avatar == null) && (avatarBytes != null) && (avatarBytes.length > 0))\r\n        avatar = ImageUtils.getScaledRoundedIcon(avatarBytes, AVATAR_WIDTH, AVATAR_HEIGHT);\r\n    if (avatarCache == null) {\r\n        if (avatar != null)\r\n            metaContact.setData(AVATAR_DATA_KEY, new Object[] { avatarBytes, avatar });\r\n    } else {\r\n        avatarCache[0] = avatarBytes;\r\n        avatarCache[1] = avatar;\r\n    }\r\n    return avatar;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.msoutlook.MsOutlookAddrBookContactDetail.getOutlookPropId",
	"Comment": "returns the list of outlook properties corresponding to this contactdetail.",
	"Method": "Vector<Long> getOutlookPropId(){\r\n    return this.outlookPropId;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.containsActiveFileTransfers",
	"Comment": "returns true if there are active file transfers, otherwisereturns false.",
	"Method": "boolean containsActiveFileTransfers(){\r\n    return !activeFileTransfers.isEmpty();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.lookandfeel.SIPCommButtonUI.uninstallDefaults",
	"Comment": "uninstalls default configurations for the given abstractbutton.",
	"Method": "void uninstallDefaults(AbstractButton b){\r\n    super.uninstallDefaults(b);\r\n    b.setBorderPainted(true);\r\n    b.setFocusPainted(false);\r\n    b.setOpaque(true);\r\n    b.setRolloverEnabled(false);\r\n}"
}, {
	"Path": "stack.MaximalRectangle.getMaxRectangle",
	"Comment": "get max rectangle algorithm similar to max rectangle in histogram",
	"Method": "int getMaxRectangle(int[] heights){\r\n    int maxArea = Integer.MIN_VALUE;\r\n    Stack<Integer> stack = new Stack();\r\n    int i = 0;\r\n    for (; i < heights.length; i++) {\r\n        while (!stack.isEmpty() && heights[stack.peek()] >= heights[i]) {\r\n            int top = stack.pop();\r\n            int base = stack.isEmpty() ? i : i - stack.peek() - 1;\r\n            maxArea = Math.max(maxArea, base * heights[top]);\r\n        }\r\n        stack.push(i);\r\n    }\r\n    while (!stack.isEmpty()) {\r\n        int top = stack.pop();\r\n        int base = stack.isEmpty() ? i : i - stack.peek() - 1;\r\n        maxArea = Math.max(maxArea, base * heights[top]);\r\n    }\r\n    return maxArea;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.DesktopSharingCallSipImpl.processInvite",
	"Comment": "creates a new call and sends a ringing response. reuses superimplementation.",
	"Method": "CallPeerSipImpl processInvite(SipProvider jainSipProvider,ServerTransaction serverTran){\r\n    Request invite = serverTran.getRequest();\r\n    Header dssidHeader = invite.getHeader(DSSID_HEADER);\r\n    if (dssidHeader != null) {\r\n        String dssid = dssidHeader.toString().replaceAll(dssidHeader.getName() + \":\", \"\").trim();\r\n        desktopSharingSessionID = dssid;\r\n        setData(DSSID_HEADER, desktopSharingSessionID);\r\n    }\r\n    return super.processInvite(jainSipProvider, serverTran);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockCall.removeCallPeer",
	"Comment": "removes callpeer from the list of peers in thiscall. the method has no effect if there was no such peer in thecall.",
	"Method": "void removeCallPeer(MockCallPeer callPeer){\r\n    if (!doRemoveCallPeer(callPeer))\r\n        return;\r\n    callPeer.removeCallPeerListener(this);\r\n    fireCallPeerEvent(callPeer, CallPeerEvent.CALL_PEER_REMOVED);\r\n    if (getCallPeerCount() == 0)\r\n        setCallState(CallState.CALL_ENDED);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.accountinfo.AccountInfoPanel.getAccountsComboBox",
	"Comment": "returns the combo box that switches between account detail panels.",
	"Method": "JComboBox getAccountsComboBox(){\r\n    return accountsComboBox;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.presence.NewStatusMessageDialog.requestFocusInField",
	"Comment": "requests the focus in the text field contained in thisdialog.",
	"Method": "void requestFocusInField(){\r\n    this.messageTextField.requestFocus();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.MembersListDialog.initContactListData",
	"Comment": "initializes the left contact list with the contacts that could be addedto the right.",
	"Method": "void initContactListData(ProtocolProviderService protocolProvider){\r\n    this.setCurrentProvider(protocolProvider);\r\n    srcContactList.removeAllContactSources();\r\n    ContactSourceService currentProviderContactSource = new ProtocolContactSourceServiceImpl(protocolProvider, OperationSetMultiUserChat.class);\r\n    currentStringContactSource = new StringContactSourceServiceImpl(protocolProvider, OperationSetMultiUserChat.class);\r\n    currentStringContactSource.setDisableDisplayDetails(false);\r\n    srcContactList.addContactSource(currentProviderContactSource);\r\n    srcContactList.addContactSource(currentStringContactSource);\r\n    srcContactList.applyDefaultFilter();\r\n    new Thread(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            List<String> membersWhiteList = MembersListDialog.this.chatRoomWrapper.getChatRoom().getMembersWhiteList();\r\n            UIContactSource uiContactSource = srcContactList.getContactSource(currentStringContactSource);\r\n            for (String member : membersWhiteList) {\r\n                SourceContact newSourceContact = currentStringContactSource.createSourceContact(member);\r\n                destContactList.addContact(new InviteUIContact(uiContactSource.createUIContact(newSourceContact), protocolProvider), null, false, false);\r\n            }\r\n        }\r\n    }).start();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.MembersListDialog.initContactListData",
	"Comment": "initializes the left contact list with the contacts that could be addedto the right.",
	"Method": "void initContactListData(ProtocolProviderService protocolProvider){\r\n    List<String> membersWhiteList = MembersListDialog.this.chatRoomWrapper.getChatRoom().getMembersWhiteList();\r\n    UIContactSource uiContactSource = srcContactList.getContactSource(currentStringContactSource);\r\n    for (String member : membersWhiteList) {\r\n        SourceContact newSourceContact = currentStringContactSource.createSourceContact(member);\r\n        destContactList.addContact(new InviteUIContact(uiContactSource.createUIContact(newSourceContact), protocolProvider), null, false, false);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.notificationwiring.NotificationManager.init",
	"Comment": "initialize, register default notifications and start listening fornew protocols or removed one and find any that are already registered.",
	"Method": "void init(){\r\n    registerDefaultNotifications();\r\n    NotificationWiringActivator.bundleContext.addServiceListener(this);\r\n    for (ProtocolProviderService pp : getProtocolProviders()) {\r\n        handleProviderAdded(pp);\r\n    }\r\n    NotificationWiringActivator.getMediaService().addRecorderListener(this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipRegistrarlessConnection.setRegistrationState",
	"Comment": "sets our registration state to newstate and dispatches an eventthrough the protocol provider service impl.",
	"Method": "void setRegistrationState(RegistrationState newState,int reasonCode,String reason){\r\n    if (currentRegistrationState.equals(newState)) {\r\n        return;\r\n    }\r\n    RegistrationState oldState = currentRegistrationState;\r\n    this.currentRegistrationState = newState;\r\n    sipProvider.fireRegistrationStateChanged(oldState, newState, reasonCode, reason);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.MUCServiceImpl.createPrivateChatRoom",
	"Comment": "creates a private chat room, by specifying the parentprotocol provider and eventually, the contacts invited to participate inthis chat room.",
	"Method": "ChatRoomWrapper createPrivateChatRoom(ProtocolProviderService protocolProvider,Collection<String> contacts,String reason,boolean persistent){\r\n    return this.createChatRoom(null, protocolProvider, contacts, reason, persistent, true);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomConfigurationFormJabberImpl.submit",
	"Comment": "sends the ready smack configuration form to the multi user chat.",
	"Method": "void submit(){\r\n    if (logger.isTraceEnabled())\r\n        logger.trace(\"Sends chat room configuration form to the server.\");\r\n    try {\r\n        smackMultiUserChat.sendConfigurationForm(smackSubmitForm);\r\n    } catch (XMPPException e) {\r\n        logger.error(\"Failed to submit the configuration form.\", e);\r\n        throw new OperationFailedException(\"Failed to submit the configuration form.\", OperationFailedException.GENERAL_ERROR);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockPersistentPresenceOperationSet.renameServerStoredContactGroup",
	"Comment": "renames the specified group from the server stored contact list.",
	"Method": "void renameServerStoredContactGroup(ContactGroup group,String newName){\r\n    ((MockContactGroup) group).setGroupName(newName);\r\n    this.fireServerStoredGroupEvent(group, ServerStoredGroupEvent.GROUP_RENAMED_EVENT);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ServerStoredContactListSipImpl.renameGroup",
	"Comment": "renames the specified group from the server stored contact list.",
	"Method": "void renameGroup(ContactGroupSipImpl group,String newName){\r\n    if (group == null) {\r\n        throw new IllegalArgumentException(\"Renaming group cannot be null\");\r\n    }\r\n    if (rootGroup.equals(group)) {\r\n        throw new IllegalArgumentException(\"Root group cannot be renamed\");\r\n    }\r\n    String oldName = group.getGroupName();\r\n    if (oldName.equals(newName)) {\r\n        return;\r\n    }\r\n    ContactGroupSipImpl parentGroup = (ContactGroupSipImpl) group.getParentContactGroup();\r\n    if (parentGroup.getGroup(newName) != null) {\r\n        throw new IllegalStateException(String.format(\"Group with name %1s already exists\", newName));\r\n    }\r\n    group.setName(newName);\r\n    if (group.isPersistent()) {\r\n        try {\r\n            updateResourceLists();\r\n        } catch (XCapException e) {\r\n            group.setName(oldName);\r\n            throw new IllegalStateException(\"Error while renaming XCAP group\", e);\r\n        }\r\n    }\r\n    fireGroupEvent(group, ServerStoredGroupEvent.GROUP_RENAMED_EVENT);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.AdHocConferenceChatSession.isDescriptorPersistent",
	"Comment": "returns true if this contact is persistent, otherwisereturns false.",
	"Method": "boolean isDescriptorPersistent(){\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ChatRoomAutoOpenConfigDialog.showChatRoomAutoOpenConfigDialog",
	"Comment": "creates if necessary a newchatroomautoopenconfigdialog instance and displays it.",
	"Method": "void showChatRoomAutoOpenConfigDialog(ProtocolProviderService pps,String chatRoomId){\r\n    if (dialog == null) {\r\n        dialog = new ChatRoomAutoOpenConfigDialog(pps, chatRoomId);\r\n    } else {\r\n        dialog.clearListeners();\r\n        dialog.setProvider(pps);\r\n        dialog.setChatRoomId(chatRoomId);\r\n        dialog.refreshValue();\r\n        if (dialog.isVisible()) {\r\n            dialog.toFront();\r\n        } else {\r\n            dialog.setVisible(true);\r\n        }\r\n        dialog.pack();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.MetaContactRightButtonMenu.actionPerformed",
	"Comment": "handles the actionevent. determines which menu item wasselected and performs the appropriate operations.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    JMenuItem menuItem = (JMenuItem) e.getSource();\r\n    String itemName = menuItem.getName();\r\n    Contact contact;\r\n    if (itemName.equals(addContactItem.getName())) {\r\n        AddContactDialog dialog = new AddContactDialog(mainFrame, metaContact);\r\n        ProtocolProviderService protocolProvider = GuiActivator.getPreferredAccount();\r\n        if (protocolProvider != null)\r\n            dialog.setSelectedAccount(protocolProvider);\r\n        dialog.setVisible(true);\r\n    } else if (itemName.equalsIgnoreCase(\"sendMessage\")) {\r\n        GuiActivator.getUIService().getChatWindowManager().startChat(metaContact);\r\n    } else if (itemName.equalsIgnoreCase(\"sendSms\")) {\r\n        Contact defaultSmsContact = metaContact.getDefaultContact(OperationSetSmsMessaging.class);\r\n        GuiActivator.getUIService().getChatWindowManager().startChat(metaContact, defaultSmsContact, true);\r\n    } else if (itemName.equals(\"call\")) {\r\n        call(false, false, false, null);\r\n    } else if (itemName.equals(\"videoCall\")) {\r\n        call(true, false, false, null);\r\n    } else if (itemName.equals(\"shareFullScreen\")) {\r\n        call(true, true, false, null);\r\n    } else if (itemName.equals(\"shareRegion\")) {\r\n        call(true, true, true, null);\r\n    } else if (itemName.equals(\"sendFile\")) {\r\n        SipCommFileChooser scfc = GenericFileDialog.create(null, \"Send file...\", SipCommFileChooser.LOAD_FILE_OPERATION, ConfigurationUtils.getSendFileLastDir());\r\n        File selectedFile = scfc.getFileFromDialog();\r\n        if (selectedFile != null) {\r\n            ConfigurationUtils.setSendFileLastDir(selectedFile.getParent());\r\n            ChatPanel chatPanel = GuiActivator.getUIService().getChatWindowManager().getContactChat(metaContact, true);\r\n            chatPanel.sendFile(selectedFile);\r\n            GuiActivator.getUIService().getChatWindowManager().openChat(chatPanel, true);\r\n        }\r\n        GuiActivator.getUIService().getChatWindowManager().startChat(metaContact);\r\n    } else if (itemName.equals(\"renameContact\")) {\r\n        RenameContactDialog dialog = new RenameContactDialog(mainFrame, metaContact);\r\n        dialog.setVisible(true);\r\n        dialog.requestFocusInFiled();\r\n    } else if (itemName.equals(\"viewHistory\")) {\r\n        HistoryWindow history;\r\n        HistoryWindowManager historyWindowManager = GuiActivator.getUIService().getHistoryWindowManager();\r\n        if (historyWindowManager.containsHistoryWindowForContact(metaContact)) {\r\n            history = historyWindowManager.getHistoryWindowForContact(metaContact);\r\n            if (history.getState() == JFrame.ICONIFIED)\r\n                history.setState(JFrame.NORMAL);\r\n            history.toFront();\r\n        } else {\r\n            history = new HistoryWindow(this.metaContact);\r\n            historyWindowManager.addHistoryWindowForContact(metaContact, history);\r\n            history.setVisible(true);\r\n        }\r\n    } else if (itemName.equals(\"requestAuth\")) {\r\n        if (firstUnsubscribedContact != null)\r\n            contact = firstUnsubscribedContact;\r\n        else\r\n            contact = metaContact.getDefaultContact();\r\n        requestAuthorization(contact);\r\n    } else if (itemName.startsWith(moveToPrefix)) {\r\n        MetaContactListManager.moveMetaContactToGroup(metaContact, itemName.substring(moveToPrefix.length()));\r\n    } else if (itemName.startsWith(removeContactPrefix)) {\r\n        if (menuItem instanceof ContactMenuItem) {\r\n            MetaContactListManager.removeContact(((ContactMenuItem) menuItem).getContact());\r\n        } else {\r\n            MetaContactListManager.removeMetaContact(metaContact);\r\n        }\r\n    } else if (itemName.startsWith(moveSubcontactPrefix)) {\r\n        contactList.addContactListListener(this);\r\n        contactList.setGroupClickConsumed(true);\r\n        this.moveDialog = new MoveSubcontactMessageDialog(mainFrame, this);\r\n        this.moveDialog.addWindowListener(new WindowAdapter() {\r\n            @Override\r\n            public void windowClosed(WindowEvent e) {\r\n                contactList.setGroupClickConsumed(false);\r\n            }\r\n        });\r\n        this.moveDialog.setVisible(true);\r\n        if (menuItem instanceof ContactMenuItem) {\r\n            this.contactToMove = ((ContactMenuItem) menuItem).getContact();\r\n        } else {\r\n            this.moveAllContacts = true;\r\n        }\r\n    } else if (itemName.startsWith(callContactPrefix)) {\r\n        if (menuItem instanceof ContactMenuItem) {\r\n            ContactMenuItem contactItem = (ContactMenuItem) menuItem;\r\n            call(false, false, false, contactItem.getContact(), contactItem.getContactResource());\r\n        } else\r\n            call(false, false, false, itemName.substring(callContactPrefix.length()));\r\n    } else if (itemName.startsWith(videoCallPrefix)) {\r\n        if (menuItem instanceof ContactMenuItem) {\r\n            ContactMenuItem contactItem = (ContactMenuItem) menuItem;\r\n            call(true, false, false, contactItem.getContact(), contactItem.getContactResource());\r\n        } else\r\n            call(true, false, false, itemName.substring(videoCallPrefix.length()));\r\n    } else if (itemName.startsWith(fullDesktopSharingPrefix)) {\r\n        if (menuItem instanceof ContactMenuItem) {\r\n            ContactMenuItem contactItem = (ContactMenuItem) menuItem;\r\n            call(true, true, false, contactItem.getContact(), contactItem.getContactResource());\r\n        } else\r\n            call(true, true, false, itemName.substring(fullDesktopSharingPrefix.length()));\r\n    } else if (itemName.startsWith(regionDesktopSharingPrefix)) {\r\n        if (menuItem instanceof ContactMenuItem) {\r\n            ContactMenuItem contactItem = (ContactMenuItem) menuItem;\r\n            call(true, true, true, contactItem.getContact(), contactItem.getContactResource());\r\n        } else\r\n            call(true, true, true, itemName.substring(regionDesktopSharingPrefix.length()));\r\n    } else if (itemName.startsWith(requestAuthPrefix)) {\r\n        if (menuItem instanceof ContactMenuItem) {\r\n            contact = ((ContactMenuItem) menuItem).getContact();\r\n        } else\r\n            contact = getContactFromMetaContact(itemName.substring(requestAuthPrefix.length()));\r\n        requestAuthorization(contact);\r\n    } else if (itemName.startsWith(callPhonePrefix)) {\r\n        String phone = itemName.substring(callPhonePrefix.length());\r\n        call(false, false, false, phone);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.MetaContactRightButtonMenu.actionPerformed",
	"Comment": "handles the actionevent. determines which menu item wasselected and performs the appropriate operations.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    contactList.setGroupClickConsumed(false);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.FileTransferImpl.getLocalFile",
	"Comment": "returns the local file that is being transferred or to which we transfer.",
	"Method": "File getLocalFile(){\r\n    return file;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.account.AccountsConfigurationPanel.updateButtons",
	"Comment": "updates enabled states of the buttons of thisaccountsconfigurationpanel to reflect their applicability to thecurrent selection in accountlist.",
	"Method": "void updateButtons(){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                updateButtons();\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    Account account = accountList.getSelectedAccount();\r\n    boolean enabled = (account != null);\r\n    editButton.setEnabled(enabled && account.isEnabled());\r\n    removeButton.setEnabled(enabled);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.account.AccountsConfigurationPanel.updateButtons",
	"Comment": "updates enabled states of the buttons of thisaccountsconfigurationpanel to reflect their applicability to thecurrent selection in accountlist.",
	"Method": "void updateButtons(){\r\n    updateButtons();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.notification.SoundNotificationHandlerImpl.play",
	"Comment": "plays the sound given by the containing soundfiledescriptor. thesound is played in loop if the loopinterval is defined.",
	"Method": "void play(SoundNotificationAction action,NotificationData data,SCAudioClipDevice device){\r\n    AudioNotifierService audioNotifService = NotificationActivator.getAudioNotifier();\r\n    if ((audioNotifService == null) || StringUtils.isNullOrEmpty(action.getDescriptor(), true))\r\n        return;\r\n    ConfigurationService cfg = NotificationActivator.getConfigurationService();\r\n    if (cfg != null && cfg.getBoolean(PROP_DISABLE_NOTIFICATION_DURING_CALL, false) && SCAudioClipDevice.PLAYBACK.equals(device)) {\r\n        UIService uiService = NotificationActivator.getUIService();\r\n        if (!uiService.getInProgressCalls().isEmpty())\r\n            return;\r\n    }\r\n    SCAudioClip audio = null;\r\n    switch(device) {\r\n        case NOTIFICATION:\r\n        case PLAYBACK:\r\n            audio = audioNotifService.createAudio(action.getDescriptor(), SCAudioClipDevice.PLAYBACK.equals(device));\r\n            break;\r\n        case PC_SPEAKER:\r\n            if (!OSUtils.IS_ANDROID)\r\n                audio = new PCSpeakerClip();\r\n            break;\r\n    }\r\n    if (audio == null)\r\n        return;\r\n    synchronized (playedClips) {\r\n        playedClips.put(audio, data);\r\n    }\r\n    boolean played = false;\r\n    try {\r\n        @SuppressWarnings(\"unchecked\")\r\n        Callable<Boolean> loopCondition = (Callable<Boolean>) data.getExtra(NotificationData.SOUND_NOTIFICATION_HANDLER_LOOP_CONDITION_EXTRA);\r\n        audio.play(action.getLoopInterval(), loopCondition);\r\n        played = true;\r\n    } finally {\r\n        synchronized (playedClips) {\r\n            if (!played)\r\n                playedClips.remove(audio);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.loggingutils.LoggingUtilsActivator.getFileAccessService",
	"Comment": "returns the fileaccessservice obtained from the bundle context.",
	"Method": "FileAccessService getFileAccessService(){\r\n    if (fileAccessService == null) {\r\n        fileAccessService = ServiceUtils.getService(bundleContext, FileAccessService.class);\r\n    }\r\n    return fileAccessService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractOperationSetBasicAutoAnswer.isAutoAnswerWithVideoSet",
	"Comment": "returns if the auto answer with video to video calls is activated.",
	"Method": "boolean isAutoAnswerWithVideoSet(){\r\n    return this.answerWithVideo;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.GenericUIContactImpl.setDisplayDetails",
	"Comment": "sets the display details of this contact. these would be shownwhenever the contact is selected.",
	"Method": "void setDisplayDetails(String displayDetails){\r\n    this.displayDetails = displayDetails;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.WhiteboardParticipantJabberImpl.setParticipantID",
	"Comment": "sets the string that serves as a unique identifier of thiswhiteboardparticipant.",
	"Method": "void setParticipantID(String participantID){\r\n    this.participantID = participantID;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.history.DatesPanel.containsDate",
	"Comment": "checks whether the given date is contained in the listof history dates.",
	"Method": "boolean containsDate(Date date){\r\n    synchronized (listModel) {\r\n        return listModel.contains(date);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetPresenceSipImpl.findContactByID",
	"Comment": "returns a contactsipimpl with a specific id in case we havea subscription for it and null otherwise.",
	"Method": "ContactSipImpl findContactByID(String contactID){\r\n    return this.ssContactList.getRootGroup().findContactByID(contactID);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.conference.BasicConferenceParticipantPanel.getParticipant",
	"Comment": "gets the conference participant depicted by this instance.",
	"Method": "T getParticipant(){\r\n    return participant;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.resources.util.SkinJarBuilder.test",
	"Comment": "tests if the content of a folder has the same structure as the skincontent.",
	"Method": "boolean test(File tmpDir){\r\n    boolean colors = false;\r\n    boolean images = false;\r\n    boolean styles = false;\r\n    File[] list = tmpDir.listFiles();\r\n    if (list == null) {\r\n        return false;\r\n    }\r\n    for (File f : list) {\r\n        if (f.getName().equals(\"info.properties\")) {\r\n            if (!f.isFile()) {\r\n                return false;\r\n            }\r\n        } else if (f.getName().equals(\"colors\")) {\r\n            if (f.isFile()) {\r\n                return false;\r\n            }\r\n            File[] ff = f.listFiles();\r\n            if (ff == null) {\r\n                return false;\r\n            }\r\n            for (File x : ff) {\r\n                if (x.getName().equals(\"colors.properties\")) {\r\n                    colors = true;\r\n                }\r\n            }\r\n        } else if (f.getName().equals(\"images\")) {\r\n            if (f.isFile()) {\r\n                return false;\r\n            }\r\n            File[] ff = f.listFiles();\r\n            if (ff == null) {\r\n                return false;\r\n            }\r\n            for (File x : ff) {\r\n                if (x.getName().equals(\"images.properties\")) {\r\n                    images = true;\r\n                }\r\n            }\r\n        } else if (f.getName().equals(\"styles\")) {\r\n            if (f.isFile()) {\r\n                return false;\r\n            }\r\n            File[] ff = f.listFiles();\r\n            if (ff == null) {\r\n                return false;\r\n            }\r\n            for (File x : ff) {\r\n                if (x.getName().equals(\"styles.properties\")) {\r\n                    styles = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return styles || (colors || images);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.LocalUserChatRoomPresenceChangeEvent.getMultiUserChatOpSet",
	"Comment": "returns the operationsetmultiuserchat, where this event hasoccurred.",
	"Method": "OperationSetMultiUserChat getMultiUserChatOpSet(){\r\n    return (OperationSetMultiUserChat) getSource();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetServerStoredContactInfoIcqImpl.getDetailsAndDescendants",
	"Comment": "returns the user details from the specified class or its descendantsthe class is one from thenet.java.sip.communicator.service.protocol.serverstoreddetailsor implemented one in the operation set for the user info",
	"Method": "Iterator<T> getDetailsAndDescendants(Contact contact,Class<T> detailClass){\r\n    assertConnected();\r\n    if (detailClass.equals(ImageDetail.class) && (contact.getImage() != null)) {\r\n        List<ImageDetail> res = new Vector<ImageDetail>();\r\n        res.add(new ImageDetail(\"Image\", contact.getImage()));\r\n        @SuppressWarnings(\"unchecked\")\r\n        Iterator<T> tIt = (Iterator<T>) res.iterator();\r\n        return tIt;\r\n    }\r\n    return infoRetreiver.getDetailsAndDescendants(contact.getAddress(), detailClass);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ProtocolProviderServiceIcqImpl.isInitialized",
	"Comment": "returns true if the provider service implementation is initialized andready for use by other services, and false otherwise.",
	"Method": "boolean isInitialized(){\r\n    return isInitialized;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.credentialsstorage.TestCredentialsStorageService.testIsStoredEncrypted",
	"Comment": "test that the service is aware that the account password is stored in anencrypted form.",
	"Method": "void testIsStoredEncrypted(){\r\n    boolean storedEncrypted = credentialsService.isStoredEncrypted(accountPrefix);\r\n    assertTrue(\"Account password is not stored encrypted\", storedEncrypted);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.neomedia.codec.video.h264.OpenH264Retriever.chooseOpenH264URL",
	"Comment": "chooses correct download url based on the current running os.",
	"Method": "String chooseOpenH264URL(){\r\n    if (OSUtils.IS_MAC) {\r\n        return OPENH264_CURRENT_VERSION_URL_MAC;\r\n    } else if (OSUtils.IS_WINDOWS32) {\r\n        return OPENH264_CURRENT_VERSION_URL_WINDOWS_32;\r\n    } else if (OSUtils.IS_WINDOWS64) {\r\n        return OPENH264_CURRENT_VERSION_URL_WINDOWS_64;\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.FirstWizardPage.getWizardForm",
	"Comment": "implements the wizardpage.getwizardform to return thispanel.",
	"Method": "Object getWizardForm(){\r\n    registrationForm.init();\r\n    return this;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.ContactGroupGibberishImpl.getParentContactGroup",
	"Comment": "returns the contact group that currently contains this group or null ifthis is the root contact group.",
	"Method": "ContactGroup getParentContactGroup(){\r\n    return this.parentGroup;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipActivator.getProtocolProviderFactory",
	"Comment": "retrurns a reference to the protocol provider factory that we haveregistered.",
	"Method": "ProtocolProviderFactorySipImpl getProtocolProviderFactory(){\r\n    return sipProviderFactory;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.ZrtpSecurityPanel.setAudioSecurityOn",
	"Comment": "updates audio security related components, depending on the given audiosecurity state.",
	"Method": "void setAudioSecurityOn(boolean isAudioSecurityOn){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                setAudioSecurityOn(isAudioSecurityOn);\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    Icon statusIcon;\r\n    String statusText;\r\n    this.isAudioSecurityOn = isAudioSecurityOn;\r\n    if (isAudioSecurityOn) {\r\n        statusIcon = audioSecuredIcon;\r\n        statusText = GuiActivator.getResources().getI18NString(\"service.gui.security.SECURE_AUDIO\");\r\n    } else {\r\n        statusIcon = audioNotSecuredIcon;\r\n        statusText = GuiActivator.getResources().getI18NString(\"service.gui.security.AUDIO_NOT_SECURED\");\r\n    }\r\n    audioSecurityLabel.setIcon(statusIcon);\r\n    audioSecurityLabel.setText(statusText);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.ZrtpSecurityPanel.setAudioSecurityOn",
	"Comment": "updates audio security related components, depending on the given audiosecurity state.",
	"Method": "void setAudioSecurityOn(boolean isAudioSecurityOn){\r\n    setAudioSecurityOn(isAudioSecurityOn);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.GeneralDialPanel.mousePressed",
	"Comment": "handles the mouseevent triggered when user presses one of thedial buttons.",
	"Method": "void mousePressed(MouseEvent e){\r\n    JButton button = (JButton) e.getSource();\r\n    dialPadDialog.dialButtonPressed(button.getName());\r\n    dtmfHandler.startSendingDtmfTone(button.getName());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.RootContactGroupJabberImpl.countContacts",
	"Comment": "returns the number, which is always 0, of contact membersof this contactgroup",
	"Method": "int countContacts(){\r\n    return contacts.size();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.ResolveAddressToDisplayNameContactQueryListener.getResolvedName",
	"Comment": "returns the display name corresponding to the contact address.",
	"Method": "String getResolvedName(){\r\n    return this.resolvedName;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetExtendedAuthorizationsJabberImpl.explicitAuthorize",
	"Comment": "send a positive authorization to contact thus allowing them toadd us to their contact list without needing to first request anauthorization.",
	"Method": "void explicitAuthorize(Contact contact){\r\n    opSetPersPresence.assertConnected();\r\n    if (!(contact instanceof ContactJabberImpl))\r\n        throw new IllegalArgumentException(\"The specified contact is not an jabber contact.\" + contact);\r\n    Presence responsePacket = new Presence(Presence.Type.subscribed);\r\n    responsePacket.setTo(contact.getAddress());\r\n    parentProvider.getConnection().sendPacket(responsePacket);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.gibberish.TestOperationSetTypingNotifications.testTypingNotificationsEventDelivery",
	"Comment": "sends a typing notification and verifieswhether it is properly received by the tested implementation",
	"Method": "void testTypingNotificationsEventDelivery(){\r\n    TypingEventCollector evtCollector = new TypingEventCollector();\r\n    Contact notifingContact = opSetPresence1.findContactByID(fixture.userID2);\r\n    opSetBasicIM1.sendInstantMessage(notifingContact, opSetBasicIM1.createMessage(\"ping\"));\r\n    opSetTypingNotifs1.addTypingNotificationsListener(evtCollector);\r\n    Contact contactToNotify = opSetPresence2.findContactByID(fixture.userID1);\r\n    opSetTypingNotifs2.sendTypingNotification(contactToNotify, OperationSetTypingNotifications.STATE_TYPING);\r\n    evtCollector.waitForEvent(10000);\r\n    opSetTypingNotifs1.removeTypingNotificationsListener(evtCollector);\r\n    assertTrue(\"Number of typing events received was zero.\", evtCollector.collectedEvents.size() > 0);\r\n    TypingNotificationEvent evt = (TypingNotificationEvent) evtCollector.collectedEvents.get(0);\r\n    assertEquals(\"Source of the typing notification event\", fixture.userID2, evt.getSourceContact().getAddress());\r\n    assertEquals(\"Source of the typing notification event\", OperationSetTypingNotifications.STATE_TYPING, evt.getTypingState());\r\n    evtCollector.collectedEvents.clear();\r\n    opSetTypingNotifs1.addTypingNotificationsListener(evtCollector);\r\n    opSetTypingNotifs2.sendTypingNotification(contactToNotify, OperationSetTypingNotifications.STATE_STOPPED);\r\n    evtCollector.waitForEvent(10000);\r\n    opSetTypingNotifs1.removeTypingNotificationsListener(evtCollector);\r\n    assertTrue(\"Number of typing events received was zero.\", evtCollector.collectedEvents.size() > 0);\r\n    evt = (TypingNotificationEvent) evtCollector.collectedEvents.get(0);\r\n    assertEquals(\"Source of the typing notification event\", fixture.userID2, evt.getSourceContact().getAddress());\r\n    assertEquals(\"Source of the typing notification event\", OperationSetTypingNotifications.STATE_STOPPED, evt.getTypingState());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.OneToOneCallPeerPanel.setPeerState",
	"Comment": "sets the state of the contained call peer by specifying thestate name.",
	"Method": "void setPeerState(CallPeerState oldState,CallPeerState newState,String stateString){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                setPeerState(oldState, newState, stateString);\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    this.callStatusLabel.setText(stateString);\r\n    if (newState == CallPeerState.CONNECTED && !CallPeerState.isOnHold(oldState) && !securityStatusLabel.isSecurityStatusSet()) {\r\n        securityStatusLabel.setSecurityOff();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.OneToOneCallPeerPanel.setPeerState",
	"Comment": "sets the state of the contained call peer by specifying thestate name.",
	"Method": "void setPeerState(CallPeerState oldState,CallPeerState newState,String stateString){\r\n    setPeerState(oldState, newState, stateString);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ChatContactCellRenderer.getListCellRendererComponent",
	"Comment": "implements the listcellrenderer method. returns this panel thathas been configured to display a chat contact.",
	"Method": "Component getListCellRendererComponent(JList<? extends ChatContact<?>> list,ChatContact<?> chatContact,int index,boolean isSelected,boolean cellHasFocus){\r\n    this.index = index;\r\n    this.rightLabel.setIcon(null);\r\n    if (chatContact == null)\r\n        return this;\r\n    ChatRoomMember member = null;\r\n    if (chatContact.getDescriptor() instanceof ChatRoomMember)\r\n        member = (ChatRoomMember) chatContact.getDescriptor();\r\n    this.setPreferredSize(new Dimension(20, 30));\r\n    String displayName;\r\n    displayName = chatContact.getName();\r\n    if (displayName == null || displayName.length() < 1) {\r\n        displayName = GuiActivator.getResources().getI18NString(\"service.gui.UNKNOWN\");\r\n    }\r\n    this.nameLabel.setFont(this.getFont().deriveFont(Font.PLAIN));\r\n    this.nameLabel.setText(displayName);\r\n    if (member != null) {\r\n        ChatRoomMemberRole memberRole = member.getRole();\r\n        if (memberRole != null)\r\n            this.nameLabel.setIcon(ChatContactRoleIcon.getRoleIcon(memberRole));\r\n        final int presenceStatus = member.getPresenceStatus().getStatus();\r\n        if (presenceStatus >= PresenceStatus.AVAILABLE_THRESHOLD) {\r\n            this.nameLabel.setForeground(COLOR_AVAILABILITY_THRESHOLD);\r\n        } else if (presenceStatus >= PresenceStatus.AWAY_THRESHOLD) {\r\n            this.nameLabel.setForeground(COLOR_AWAY_THRESHOLD);\r\n        }\r\n    } else if (contactForegroundColor != null)\r\n        this.nameLabel.setForeground(contactForegroundColor);\r\n    this.setBorder(BorderFactory.createEmptyBorder(1, 5, 1, 1));\r\n    ImageIcon avatar = chatContact.getAvatar();\r\n    if (avatar != null)\r\n        this.rightLabel.setIcon(avatar);\r\n    else if (member != null) {\r\n        ChatRoom memberChatRoom = member.getChatRoom();\r\n        ProtocolProviderService protocolProvider = memberChatRoom.getParentProvider();\r\n        if (chatContact.getName().equals(memberChatRoom.getUserNickname())) {\r\n            OperationSetServerStoredAccountInfo opSet = protocolProvider.getOperationSet(OperationSetServerStoredAccountInfo.class);\r\n            if (opSet != null) {\r\n                Iterator<ServerStoredDetails.GenericDetail> itr;\r\n                try {\r\n                    itr = opSet.getAllAvailableDetails();\r\n                } catch (IllegalStateException isex) {\r\n                    itr = null;\r\n                }\r\n                if (itr != null)\r\n                    while (itr.hasNext()) {\r\n                        ServerStoredDetails.GenericDetail detail = itr.next();\r\n                        if (detail instanceof ServerStoredDetails.BinaryDetail) {\r\n                            ServerStoredDetails.BinaryDetail bin = (ServerStoredDetails.BinaryDetail) detail;\r\n                            byte[] binBytes = bin.getBytes();\r\n                            if (binBytes != null)\r\n                                this.rightLabel.setIcon(ImageUtils.getScaledRoundedIcon(binBytes, 25, 25));\r\n                            break;\r\n                        }\r\n                    }\r\n            }\r\n            ChatRoomMemberRole role;\r\n            try {\r\n                role = memberChatRoom.getUserRole();\r\n            } catch (UnsupportedOperationException uoex) {\r\n                role = member.getRole();\r\n            }\r\n            if (role != null)\r\n                this.nameLabel.setIcon(ChatContactRoleIcon.getRoleIcon(role));\r\n        } else {\r\n            OperationSetPersistentPresence opSet = protocolProvider.getOperationSet(OperationSetPersistentPresence.class);\r\n            if (opSet != null) {\r\n                Contact c = opSet.findContactByID(member.getContactAddress());\r\n                if (c != null) {\r\n                    byte[] cImage = c.getImage();\r\n                    if (cImage != null)\r\n                        this.rightLabel.setIcon(ImageUtils.getScaledRoundedIcon(cImage, 25, 25));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    int listWidth = list.getWidth();\r\n    this.setBounds(0, 0, listWidth - 2, 30);\r\n    this.nameLabel.setBounds(0, 0, listWidth - 28, 17);\r\n    this.rightLabel.setBounds(listWidth - 28, 0, 25, 30);\r\n    this.isLeaf = true;\r\n    this.isSelected = isSelected;\r\n    return this;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapDirectorySetImpl.removeServerWithName",
	"Comment": "tries to remove an ldapdirectory from the ldapdirectorysetusing the name given by the getname method.",
	"Method": "LdapDirectory removeServerWithName(String name){\r\n    LdapDirectory removed = this.serverMap.remove(name);\r\n    if (configService != null)\r\n        removed.getSettings().persistentRemove();\r\n    return removed;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.whiteboard.WhiteboardObjectImageJabberImpl.setBackgroundImage",
	"Comment": "specifies an image that should be displayed as the background of thisobject.",
	"Method": "void setBackgroundImage(byte[] background){\r\n    this.background = background;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.notificationwiring.NotificationManager.conferenceMemberAdded",
	"Comment": "indicates that the given conference member has been added to the givenpeer.",
	"Method": "void conferenceMemberAdded(CallPeerConferenceEvent conferenceEvent){\r\n    try {\r\n        CallPeer peer = conferenceEvent.getConferenceMember().getConferenceFocusCallPeer();\r\n        if (peer.getConferenceMemberCount() > 0) {\r\n            CallPeerSecurityStatusEvent securityEvent = peer.getCurrentSecuritySettings();\r\n            if (securityEvent instanceof CallPeerSecurityOnEvent)\r\n                fireNotification(CALL_SECURITY_ON);\r\n        }\r\n    } catch (Throwable t) {\r\n        if (t instanceof ThreadDeath)\r\n            throw (ThreadDeath) t;\r\n        else\r\n            logger.error(\"Error notifying for secured call member\", t);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.WhiteboardInvitationRejectedEvent.getSourceOperationSet",
	"Comment": "returns the whiteboarding operation set that dispatches this event.",
	"Method": "OperationSetWhiteboarding getSourceOperationSet(){\r\n    return (OperationSetWhiteboarding) getSource();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageHistoryActivator.getContactListService",
	"Comment": "returns the metacontactlistservice obtained from the bundlecontext.",
	"Method": "MetaContactListService getContactListService(){\r\n    if (metaCListService == null) {\r\n        metaCListService = ServiceUtils.getService(bundleContext, MetaContactListService.class);\r\n    }\r\n    return metaCListService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.msoutlook.MsOutlookAddrBookContactQuery.getProperty",
	"Comment": "find the outlook property tag from category and subcategories.",
	"Method": "long getProperty(ContactDetail.Category category,Collection<ContactDetail.SubCategory> subCategories){\r\n    int i = -1;\r\n    switch(category) {\r\n        case Personal:\r\n            if (subCategories.contains(ContactDetail.SubCategory.Name))\r\n                i = PR_GIVEN_NAME;\r\n            else if (subCategories.contains(ContactDetail.SubCategory.LastName))\r\n                i = PR_SURNAME;\r\n            else if (subCategories.contains(ContactDetail.SubCategory.Nickname))\r\n                i = PR_NICKNAME;\r\n            else if (subCategories.contains(ContactDetail.SubCategory.HomePage))\r\n                i = PR_PERSONAL_HOME_PAGE;\r\n            else\r\n                i = PR_DISPLAY_NAME_PREFIX;\r\n            break;\r\n        case Organization:\r\n            if (subCategories.contains(ContactDetail.SubCategory.Name))\r\n                i = PR_COMPANY_NAME;\r\n            else if (subCategories.contains(ContactDetail.SubCategory.JobTitle))\r\n                i = PR_TITLE;\r\n            else\r\n                i = PR_BUSINESS_HOME_PAGE;\r\n            break;\r\n        case Email:\r\n            if (subCategories.contains(ContactDetail.SubCategory.Work))\r\n                i = dispidEmail2EmailAddress;\r\n            else if (subCategories.contains(ContactDetail.SubCategory.Home))\r\n                i = dispidEmail1EmailAddress;\r\n            else if (subCategories.contains(ContactDetail.SubCategory.Other))\r\n                i = dispidEmail3EmailAddress;\r\n            break;\r\n        case Phone:\r\n            if (subCategories.contains(ContactDetail.SubCategory.Fax))\r\n                i = dispidFax1EmailAddress;\r\n            else if (subCategories.contains(ContactDetail.SubCategory.Work))\r\n                i = PR_BUSINESS_TELEPHONE_NUMBER;\r\n            else if (subCategories.contains(ContactDetail.SubCategory.Home))\r\n                i = PR_HOME_TELEPHONE_NUMBER;\r\n            else if (subCategories.contains(ContactDetail.SubCategory.Mobile))\r\n                i = PR_MOBILE_TELEPHONE_NUMBER;\r\n            else if (subCategories.contains(ContactDetail.SubCategory.Other))\r\n                i = PR_OTHER_TELEPHONE_NUMBER;\r\n            break;\r\n        case InstantMessaging:\r\n            i = dispidInstMsg;\r\n            break;\r\n        case Address:\r\n            if (subCategories.contains(ContactDetail.SubCategory.Work)) {\r\n                if (subCategories.contains(ContactDetail.SubCategory.City))\r\n                    i = PR_BUSINESS_ADDRESS_CITY;\r\n                else if (subCategories.contains(ContactDetail.SubCategory.Country))\r\n                    i = PR_BUSINESS_ADDRESS_COUNTRY;\r\n                else if (subCategories.contains(ContactDetail.SubCategory.PostalCode))\r\n                    i = PR_BUSINESS_ADDRESS_POSTAL_CODE;\r\n                else if (subCategories.contains(ContactDetail.SubCategory.State))\r\n                    i = PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE;\r\n                else if (subCategories.contains(ContactDetail.SubCategory.Street))\r\n                    i = PR_BUSINESS_ADDRESS_STREET;\r\n                else\r\n                    i = dispidWorkAddress;\r\n            } else if (subCategories.contains(ContactDetail.SubCategory.Home)) {\r\n                if (subCategories.contains(ContactDetail.SubCategory.City))\r\n                    i = PR_HOME_ADDRESS_CITY;\r\n                else if (subCategories.contains(ContactDetail.SubCategory.Country))\r\n                    i = PR_HOME_ADDRESS_COUNTRY;\r\n                else if (subCategories.contains(ContactDetail.SubCategory.PostalCode))\r\n                    i = PR_HOME_ADDRESS_POSTAL_CODE;\r\n                else if (subCategories.contains(ContactDetail.SubCategory.State))\r\n                    i = PR_HOME_ADDRESS_STATE_OR_PROVINCE;\r\n                else if (subCategories.contains(ContactDetail.SubCategory.Street))\r\n                    i = PR_HOME_ADDRESS_STREET;\r\n                else\r\n                    i = dispidHomeAddress;\r\n            }\r\n            break;\r\n        case Web:\r\n        default:\r\n            break;\r\n    }\r\n    return (i >= 0) ? MAPI_MAILUSER_PROP_IDS[i] : -1;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.AccountStatusPanel.startConnecting",
	"Comment": "starts connecting user interface for the given protocolprovider.",
	"Method": "void startConnecting(ProtocolProviderService protocolProvider){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                startConnecting(protocolProvider);\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    statusComboBox.startConnecting(protocolProvider);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.AccountStatusPanel.startConnecting",
	"Comment": "starts connecting user interface for the given protocolprovider.",
	"Method": "void startConnecting(ProtocolProviderService protocolProvider){\r\n    startConnecting(protocolProvider);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatContact.equals",
	"Comment": "determines whether a specific object represents the same valueas this chatcontact.",
	"Method": "boolean equals(Object obj){\r\n    if (this == obj)\r\n        return true;\r\n    if (!getClass().isInstance(obj))\r\n        return false;\r\n    @SuppressWarnings(\"unchecked\")\r\n    ChatContact<T> chatContact = (ChatContact<T>) obj;\r\n    return getDescriptor().equals(chatContact.getDescriptor());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.MUCActivator.handleProviderAdded",
	"Comment": "handles the registration of a new protocolproviderservice. addsthe given protocolprovider to the list of queried providers.",
	"Method": "void handleProviderAdded(ProtocolProviderService protocolProvider){\r\n    if (protocolProvider.getOperationSet(OperationSetMultiUserChat.class) != null && !chatRoomProviders.contains(protocolProvider)) {\r\n        chatRoomProviders.add(protocolProvider);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.windowscleanshutdown.CleanShutdownActivator.getShutdownService",
	"Comment": "gets a reference to a shutdownservice implementationcurrently registered in the bundle context of the activeosdependentactivator instance.the returned reference to shutdownservice is not beingcached.",
	"Method": "ShutdownService getShutdownService(){\r\n    return (ShutdownService) context.getService(context.getServiceReference(ShutdownService.class.getName()));\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.ProtocolProviderFactory.getRegisteredAccounts",
	"Comment": "returns a copy of the list containing the accountids of allaccounts currently registered in this protocol provider.",
	"Method": "ArrayList<AccountID> getRegisteredAccounts(){\r\n    synchronized (registeredAccounts) {\r\n        return new ArrayList<AccountID>(registeredAccounts.keySet());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapDirectoryImpl.getSettings",
	"Comment": "returns an ldapdirectorysettings object containinga copy of the settings of this server",
	"Method": "LdapDirectorySettings getSettings(){\r\n    return this.settings.clone();\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.sip.TestOperationSetBasicTelephonySipImpl.testCreateCancelCall",
	"Comment": "creates a call from provider1 to provider2 then cancels it withoutwaiting for provider1 to answer.",
	"Method": "void testCreateCancelCall(){\r\n    OperationSetBasicTelephony<?> basicTelephonyP1 = fixture.provider1.getOperationSet(OperationSetBasicTelephony.class);\r\n    OperationSetBasicTelephony<?> basicTelephonyP2 = fixture.provider2.getOperationSet(OperationSetBasicTelephony.class);\r\n    CallEventCollector call1Listener = new CallEventCollector(basicTelephonyP1);\r\n    CallEventCollector call2Listener = new CallEventCollector(basicTelephonyP2);\r\n    String provider2Address = fixture.provider2.getAccountID().getAccountAddress();\r\n    Call callAtP1 = basicTelephonyP1.createCall(provider2Address);\r\n    call1Listener.waitForEvent(10000);\r\n    call2Listener.waitForEvent(10000);\r\n    assertEquals(\"The provider that created the call did not dispatch \" + \"an event that it has done so.\", 1, call1Listener.collectedEvents.size());\r\n    CallEvent callCreatedEvent = (CallEvent) call1Listener.collectedEvents.get(0);\r\n    assertEquals(\"CallEvent.getEventID()\", CallEvent.CALL_INITIATED, callCreatedEvent.getEventID());\r\n    assertSame(\"CallEvent.getSource()\", callAtP1, callCreatedEvent.getSource());\r\n    assertTrue(\"The callee provider did not receive a call or did \" + \"not issue an event.\", call2Listener.collectedEvents.size() > 0);\r\n    CallEvent callReceivedEvent = (CallEvent) call2Listener.collectedEvents.get(0);\r\n    Call callAtP2 = callReceivedEvent.getSourceCall();\r\n    assertEquals(\"CallEvent.getEventID()\", CallEvent.CALL_RECEIVED, callReceivedEvent.getEventID());\r\n    assertNotNull(\"CallEvent.getSource()\", callAtP2);\r\n    assertEquals(\"callAtP1.getCallPeerCount()\", 1, callAtP1.getCallPeerCount());\r\n    assertEquals(\"callAtP2.getCallPeerCount()\", 1, callAtP2.getCallPeerCount());\r\n    CallPeer peerAtP1 = callAtP1.getCallPeers().next();\r\n    CallPeer peerAtP2 = callAtP2.getCallPeers().next();\r\n    CallPeerStateEventCollector stateCollectorForPp1 = new CallPeerStateEventCollector(peerAtP1, CallPeerState.ALERTING_REMOTE_SIDE);\r\n    CallPeerStateEventCollector stateCollectorForPp2 = new CallPeerStateEventCollector(peerAtP2, CallPeerState.INCOMING_CALL);\r\n    stateCollectorForPp1.waitForEvent(10000, true);\r\n    stateCollectorForPp2.waitForEvent(10000, true);\r\n    assertSame(\"peerAtP1.getCall\", peerAtP1.getCall(), callAtP1);\r\n    assertSame(\"peerAtP2.getCall\", peerAtP2.getCall(), callAtP2);\r\n    assertEquals(\"The peer at provider one was not in the \" + \"right state.\", CallPeerState.ALERTING_REMOTE_SIDE, peerAtP1.getState());\r\n    assertEquals(\"The peer at provider two was not in the \" + \"right state.\", CallPeerState.INCOMING_CALL, peerAtP2.getState());\r\n    if (Boolean.getBoolean(\"accounts.sip.PRESERVE_PEER_INFO\")) {\r\n        String expectedPeer1Address = fixture.provider2.getAccountID().getAccountAddress();\r\n        String expectedPeer1DisplayName = System.getProperty(SipProtocolProviderServiceLick.ACCOUNT_2_PREFIX + ProtocolProviderFactory.DISPLAY_NAME);\r\n        assertTrue(\"Provider 2 did not advertise their \" + \"accountID.getAccoutAddress() address.\", expectedPeer1Address.indexOf(peerAtP1.getAddress()) != -1 || peerAtP1.getAddress().indexOf(expectedPeer1Address) != -1);\r\n        assertEquals(\"Provider 2 did not properly advertise their \" + \"display name.\", expectedPeer1DisplayName, peerAtP1.getDisplayName());\r\n        String expectedPeer2Address = fixture.provider1.getAccountID().getAccountAddress();\r\n        String expectedPeer2DisplayName = System.getProperty(SipProtocolProviderServiceLick.ACCOUNT_1_PREFIX + ProtocolProviderFactory.DISPLAY_NAME);\r\n        assertTrue(\"Provider 1 did not advertise their \" + \"accountID.getAccoutAddress() address.\", expectedPeer2Address.indexOf(peerAtP2.getAddress()) != -1 || peerAtP2.getAddress().indexOf(expectedPeer2Address) != -1);\r\n        assertEquals(\"Provider 1 did not properly advertise their \" + \"display name.\", expectedPeer2DisplayName, peerAtP2.getDisplayName());\r\n    }\r\n    stateCollectorForPp1 = new CallPeerStateEventCollector(peerAtP1, CallPeerState.DISCONNECTED);\r\n    stateCollectorForPp2 = new CallPeerStateEventCollector(peerAtP2, CallPeerState.DISCONNECTED);\r\n    call1Listener = new CallEventCollector(basicTelephonyP1);\r\n    call2Listener = new CallEventCollector(basicTelephonyP2);\r\n    CallStateEventCollector call1StateCollector = new CallStateEventCollector(callAtP1, CallState.CALL_ENDED);\r\n    CallStateEventCollector call2StateCollector = new CallStateEventCollector(callAtP2, CallState.CALL_ENDED);\r\n    basicTelephonyP1.hangupCallPeer(peerAtP1);\r\n    call1Listener.waitForEvent(10000);\r\n    call2Listener.waitForEvent(10000);\r\n    stateCollectorForPp1.waitForEvent(10000);\r\n    stateCollectorForPp2.waitForEvent(10000);\r\n    call1StateCollector.waitForEvent(10000);\r\n    call2StateCollector.waitForEvent(10000);\r\n    assertEquals(\"The peer at provider one was not in the \" + \"right state.\", CallPeerState.DISCONNECTED, peerAtP1.getState());\r\n    assertEquals(\"The basic telephony operation set did not distribute \" + \"an event to notify us that a call has been ended.\", 1, call1Listener.collectedEvents.size());\r\n    CallEvent collectedEvent = (CallEvent) call1Listener.collectedEvents.get(0);\r\n    assertEquals(\"The basic telephony operation set did not distribute \" + \"an event to notify us that a call has been ended.\", CallEvent.CALL_ENDED, collectedEvent.getEventID());\r\n    assertEquals(\"The peer at provider one was not in the \" + \"right state.\", CallPeerState.DISCONNECTED, peerAtP2.getState());\r\n    assertEquals(\"The basic telephony operation set did not distribute \" + \"an event to notify us that a call has been ended.\", 1, call2Listener.collectedEvents.size());\r\n    collectedEvent = (CallEvent) call2Listener.collectedEvents.get(0);\r\n    assertEquals(\"The basic telephony operation set did not distribute \" + \"an event to notify us that a call has been ended.\", CallEvent.CALL_ENDED, collectedEvent.getEventID());\r\n    assertEquals(\"A call did not change its state to CallState.CALL_ENDED \" + \"when it ended.\", CallState.CALL_ENDED, callAtP1.getCallState());\r\n    assertEquals(\"A call did not change its state to CallState.CALL_ENDED \" + \"when it ended.\", CallState.CALL_ENDED, callAtP2.getCallState());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatSession.getPersistableAddress",
	"Comment": "returns the persistable address of the contact from the session.",
	"Method": "String getPersistableAddress(){\r\n    return persistableAddress;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.MetaContactListSource.getUIContact",
	"Comment": "returns the uicontact corresponding to the givenmetacontact.",
	"Method": "UIContactImpl getUIContact(MetaContact metaContact){\r\n    return (UIContactImpl) metaContact.getData(UI_CONTACT_DATA_KEY);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.ProtocolProviderFactory.uninstallAccount",
	"Comment": "removes the specified account from the list of accounts that thisprovider factory is handling. if the specified accountid is unknown tothe protocolproviderfactory, the call has no effect and false isreturned. this method is persistent in nature and once called the accountcorresponding to the specified id will not be loaded during future runsof the project.",
	"Method": "boolean uninstallAccount(AccountID accountID){\r\n    ServiceReference<ProtocolProviderService> serRef = getProviderForAccount(accountID);\r\n    boolean wasAccountExisting = false;\r\n    if (serRef != null) {\r\n        BundleContext bundleContext = getBundleContext();\r\n        ProtocolProviderService protocolProvider = bundleContext.getService(serRef);\r\n        try {\r\n            protocolProvider.unregister();\r\n        } catch (OperationFailedException ex) {\r\n            logger.error(\"Failed to unregister protocol provider for account: \" + accountID + \" caused by: \" + ex);\r\n        }\r\n    }\r\n    ServiceRegistration<ProtocolProviderService> registration;\r\n    synchronized (registeredAccounts) {\r\n        registration = registeredAccounts.remove(accountID);\r\n    }\r\n    wasAccountExisting = removeStoredAccount(accountID);\r\n    if (registration != null) {\r\n        registration.unregister();\r\n    }\r\n    return wasAccountExisting;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.notification.SoundNotificationAction.setLoopInterval",
	"Comment": "changes the loop interval. this is the interval of milliseconds to waitbefore repeating the sound, when playing a sound in loop.",
	"Method": "void setLoopInterval(int loopInterval){\r\n    this.loopInterval = loopInterval;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.ProtocolProviderServiceGibberishImpl.initialize",
	"Comment": "initializes the service implementation, and puts it in a sate where itcould interoperate with other services. it is strongly recomended thatproperties in this map be mapped to property names as specified byaccountproperties.",
	"Method": "void initialize(String userID,AccountID accountID){\r\n    synchronized (initializationLock) {\r\n        this.accountID = accountID;\r\n        OperationSetPersistentPresenceGibberishImpl persistentPresence = new OperationSetPersistentPresenceGibberishImpl(this);\r\n        addSupportedOperationSet(OperationSetPersistentPresence.class, persistentPresence);\r\n        addSupportedOperationSet(OperationSetPresence.class, persistentPresence);\r\n        addSupportedOperationSet(OperationSetBasicInstantMessaging.class, new OperationSetBasicInstantMessagingGibberishImpl(this, persistentPresence));\r\n        addSupportedOperationSet(OperationSetTypingNotifications.class, new OperationSetTypingNotificationsGibberishImpl(this, persistentPresence));\r\n        OperationSetBasicTelephonyGibberishImpl telphonyOpSet = new OperationSetBasicTelephonyGibberishImpl(this);\r\n        addSupportedOperationSet(OperationSetBasicTelephony.class, telphonyOpSet);\r\n        OperationSetTelephonyConferencing conferenceOpSet = new OperationSetTelephonyConferencingGibberishImpl(this, telphonyOpSet);\r\n        addSupportedOperationSet(OperationSetTelephonyConferencing.class, conferenceOpSet);\r\n        isInitialized = true;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.neomedia.NeomediaActivator.getMediaServiceImpl",
	"Comment": "gets the mediaservice implementation instance registered by theneomedia bundle.",
	"Method": "MediaServiceImpl getMediaServiceImpl(){\r\n    return mediaServiceImpl;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MclStorageManager.start",
	"Comment": "initializes the storage manager and makes it do initial load and parsingof the contact list file.",
	"Method": "void start(BundleContext bc,MetaContactListServiceImpl mclServImpl){\r\n    bundleContext = bc;\r\n    faService = ServiceUtils.getService(bundleContext, FileAccessService.class);\r\n    ConfigurationService configurationService = ServiceUtils.getService(bundleContext, ConfigurationService.class);\r\n    String fileName = configurationService.getString(FILE_NAME_PROPERTY);\r\n    if (fileName == null) {\r\n        fileName = System.getProperty(FILE_NAME_PROPERTY);\r\n        if (fileName == null)\r\n            fileName = DEFAULT_FILE_NAME;\r\n    }\r\n    try {\r\n        contactlistFile = faService.getPrivatePersistentFile(fileName, FileCategory.PROFILE);\r\n        if (!contactlistFile.exists() && !contactlistFile.createNewFile()) {\r\n            throw new IOException(\"Failed to create file\" + contactlistFile.getAbsolutePath());\r\n        }\r\n    } catch (Exception ex) {\r\n        logger.error(\"Failed to get a reference to the contact list file.\", ex);\r\n        throw new IOException(\"Failed to get a reference to the contact \" + \"list file=\" + fileName + \". error was:\" + ex.getMessage());\r\n    }\r\n    multiTenantMode = configurationService.getBoolean(MULTI_TENANT_MODE_PROP, multiTenantMode);\r\n    try {\r\n        contactlistTrans = faService.createFailSafeTransaction(this.contactlistFile);\r\n        contactlistTrans.restoreFile();\r\n    } catch (NullPointerException e) {\r\n        logger.error(\"the contactlist file is null\", e);\r\n    } catch (IllegalStateException e) {\r\n        logger.error(\"The contactlist file can't be found\", e);\r\n    }\r\n    try {\r\n        DocumentBuilder builder = XMLUtils.newDocumentBuilderFactory().newDocumentBuilder();\r\n        if (contactlistFile.length() == 0) {\r\n            contactListDocument = builder.newDocument();\r\n            initVirginDocument(mclServImpl, contactListDocument);\r\n            storeContactList0();\r\n        } else {\r\n            try {\r\n                contactListDocument = builder.parse(contactlistFile);\r\n            } catch (Throwable ex) {\r\n                logger.error(\"Error parsing configuration file\", ex);\r\n                logger.error(\"Creating replacement file\");\r\n                contactlistFile.delete();\r\n                contactlistFile.createNewFile();\r\n                contactListDocument = builder.newDocument();\r\n                initVirginDocument(mclServImpl, contactListDocument);\r\n                storeContactList0();\r\n            }\r\n        }\r\n    } catch (ParserConfigurationException ex) {\r\n        logger.error(\"Error finding configuration for default parsers\", ex);\r\n    }\r\n    mclServImpl.addMetaContactListListener(this);\r\n    this.mclServiceImpl = mclServImpl;\r\n    started = true;\r\n    this.launchStorageThread();\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.NetworkUtils.getSRVRecords",
	"Comment": "returns an inetsocketaddress representing the first srvrecord available for the specified domain or null if there arenot srv records for domain.",
	"Method": "SRVRecord[] getSRVRecords(String domain,SRVRecord[] getSRVRecords,String domain,boolean useDNSCache,SRVRecord[] getSRVRecords,String service,String proto,String domain,SRVRecord[] getSRVRecords,String service,String proto,String domain,boolean useDNSCache){\r\n    SRVRecord[] records = getSRVRecords(\"_\" + service + \"._\" + proto + \".\" + domain, useDNSCache);\r\n    if (records == null || records.length == 0)\r\n        return null;\r\n    return records;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.JabberSlickFixture.setUp",
	"Comment": "initializes protocol provider references and whatever else there is toinitialize.",
	"Method": "void setUp(){\r\n    ServiceReference[] serRefs = null;\r\n    String osgiFilter = \"(\" + ProtocolProviderFactory.PROTOCOL + \"=\" + ProtocolNames.JABBER + \")\";\r\n    try {\r\n        serRefs = bc.getServiceReferences(ProtocolProviderFactory.class.getName(), osgiFilter);\r\n    } catch (InvalidSyntaxException ex) {\r\n        fail(osgiFilter + \" is not a valid osgi filter\");\r\n    }\r\n    assertTrue(\"Failed to find a provider factory service for protocol Jabber\", (serRefs != null) && (serRefs.length > 0));\r\n    providerFactory = (ProtocolProviderFactory) bc.getService(serRefs[0]);\r\n    userID1 = System.getProperty(JabberProtocolProviderServiceLick.ACCOUNT_1_PREFIX + ProtocolProviderFactory.USER_ID);\r\n    userID2 = System.getProperty(JabberProtocolProviderServiceLick.ACCOUNT_2_PREFIX + ProtocolProviderFactory.USER_ID);\r\n    userID3 = System.getProperty(JabberProtocolProviderServiceLick.ACCOUNT_3_PREFIX + ProtocolProviderFactory.USER_ID);\r\n    chatRoomName = System.getProperty(JabberProtocolProviderServiceLick.CHAT_ROOM_NAME);\r\n    ServiceReference[] jabberProvider1Refs = bc.getServiceReferences(ProtocolProviderService.class.getName(), \"(&\" + \"(\" + ProtocolProviderFactory.PROTOCOL + \"=\" + ProtocolNames.JABBER + \")\" + \"(\" + ProtocolProviderFactory.USER_ID + \"=\" + userID1 + \")\" + \")\");\r\n    assertNotNull(\"No Protocol Provider was found for Jabber account1:\" + userID1, jabberProvider1Refs);\r\n    assertTrue(\"No Protocol Provider was found for Jabber account1:\" + userID1, jabberProvider1Refs.length > 0);\r\n    ServiceReference[] jabberProvider2Refs = bc.getServiceReferences(ProtocolProviderService.class.getName(), \"(&\" + \"(\" + ProtocolProviderFactory.PROTOCOL + \"=\" + ProtocolNames.JABBER + \")\" + \"(\" + ProtocolProviderFactory.USER_ID + \"=\" + userID2 + \")\" + \")\");\r\n    assertNotNull(\"No Protocol Provider was found for Jabber account2:\" + userID2, jabberProvider2Refs);\r\n    assertTrue(\"No Protocol Provider was found for Jabber account2:\" + userID2, jabberProvider2Refs.length > 0);\r\n    ServiceReference[] jabberProvider3Refs = bc.getServiceReferences(ProtocolProviderService.class.getName(), \"(&\" + \"(\" + ProtocolProviderFactory.PROTOCOL + \"=\" + ProtocolNames.JABBER + \")\" + \"(\" + ProtocolProviderFactory.USER_ID + \"=\" + userID3 + \")\" + \")\");\r\n    assertNotNull(\"No Protocol Provider was found for Jabber account3:\" + userID3, jabberProvider3Refs);\r\n    assertTrue(\"No Protocol Provider was found for Jabber account3:\" + userID3, jabberProvider3Refs.length > 0);\r\n    provider1ServiceRef = jabberProvider1Refs[0];\r\n    provider1 = (ProtocolProviderService) bc.getService(provider1ServiceRef);\r\n    provider2ServiceRef = jabberProvider2Refs[0];\r\n    provider2 = (ProtocolProviderService) bc.getService(provider2ServiceRef);\r\n    provider3ServiceRef = jabberProvider3Refs[0];\r\n    provider3 = (ProtocolProviderService) bc.getService(provider3ServiceRef);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.gui.event.MetaContactQuery.removeContactQueryListener",
	"Comment": "removes the given metacontactquerylistener to the list ofregistered listeners. the metacontactquerylistener would benotified each time a new metacontactquery result has beenreceived or if the query has been completed or has been canceled by useror for any other reason.",
	"Method": "void removeContactQueryListener(MetaContactQueryListener l){\r\n    synchronized (queryListeners) {\r\n        queryListeners.remove(l);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chatroomslist.joinforms.SelectAccountPanel.initSelectedAccount",
	"Comment": "determine the selected account, which will be used in the rest of thewizard.",
	"Method": "void initSelectedAccount(){\r\n    TableModel model = accountsTable.getModel();\r\n    int selectedRow = accountsTable.getSelectedRow();\r\n    if (selectedRow != -1) {\r\n        joinChatRoom.setChatRoomProvider((ChatRoomProviderWrapper) model.getValueAt(selectedRow, ACCOUNT_COLUMN_INDEX));\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockOperationSetFileTransfer.addFileTransferListener",
	"Comment": "adds the given filetransferlistener that would listen forfile transfer requests and created file transfers.",
	"Method": "void addFileTransferListener(FileTransferListener listener){\r\n    synchronized (fileTransferListeners) {\r\n        if (!fileTransferListeners.contains(listener)) {\r\n            this.fileTransferListeners.add(listener);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.sipaccregwizz.SIPAccountRegistrationForm.isModification",
	"Comment": "indicates if this wizard is modifying an existing account or is creatinga new one.",
	"Method": "boolean isModification(){\r\n    return isModification;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ContactIcqImpl.toString",
	"Comment": "returns a string representation of this contact, containing most of itsrepresentative details.",
	"Method": "String toString(){\r\n    StringBuffer buff = new StringBuffer(\"IcqContact[ uin=\");\r\n    buff.append(getAddress()).append(\", alias=\").append(getJoustSimBuddy().getAlias()).append(\"]\");\r\n    return buff.toString();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatSession.isDescriptorPersistent",
	"Comment": "returns true if this contact is persistent, otherwisereturns false.",
	"Method": "boolean isDescriptorPersistent(){\r\n    return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ProtocolProviderFactorySipImpl.installAccount",
	"Comment": "initializes and creates an account corresponding to the specifiedaccountproperties and registers the resulting protocolprovider in thecontext bundlecontext parameter.",
	"Method": "AccountID installAccount(String userIDStr,Map<String, String> accountProperties){\r\n    BundleContext context = SipActivator.getBundleContext();\r\n    if (context == null)\r\n        throw new NullPointerException(\"The specified BundleContext was null\");\r\n    if (userIDStr == null)\r\n        throw new NullPointerException(\"The specified AccountID was null\");\r\n    if (accountProperties == null)\r\n        throw new NullPointerException(\"The specified property map was null\");\r\n    accountProperties.put(USER_ID, userIDStr);\r\n    if (!accountProperties.containsKey(PROTOCOL))\r\n        accountProperties.put(PROTOCOL, ProtocolNames.SIP);\r\n    AccountID accountID = createAccountID(userIDStr, accountProperties);\r\n    if (registeredAccounts.containsKey(accountID))\r\n        throw new IllegalStateException(\"An account for id \" + userIDStr + \" was already installed!\");\r\n    this.storeAccount(accountID, false);\r\n    try {\r\n        accountID = loadAccount(accountProperties);\r\n    } catch (RuntimeException exc) {\r\n        this.removeStoredAccount(accountID);\r\n        throw exc;\r\n    }\r\n    return accountID;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.notification.NotificationServiceImpl.restoreDefaults",
	"Comment": "deletes all registered events and actionsand registers and saves the default events as current.",
	"Method": "void restoreDefaults(){\r\n    for (String eventType : new Vector<String>(notifications.keySet())) {\r\n        Notification notification = notifications.get(eventType);\r\n        for (String actionType : new Vector<String>(notification.getActions().keySet())) removeEventNotificationAction(eventType, actionType);\r\n        removeEventNotification(eventType);\r\n    }\r\n    for (Map.Entry<String, Notification> entry : defaultNotifications.entrySet()) {\r\n        String eventType = entry.getKey();\r\n        Notification notification = entry.getValue();\r\n        for (NotificationAction action : notification.getActions().values()) registerNotificationForEvent(eventType, action);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ContactIcqImpl.getJoustSimBuddy",
	"Comment": "returns the joust sim buddy that this contact is encapsulating.",
	"Method": "Buddy getJoustSimBuddy(){\r\n    return joustSimBuddy;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ServerStoredContactList.createUnresolvedContact",
	"Comment": "creates a non resolved contact for the specified address and inside thespecified group. the newly created contact would be added to the localcontact list as a standard contact but when an event is received from theserver concerning this contact, then it will be reused and only itsisresolved field would be updated instead of creating the whole contactagain. if creation is successfull event will be fired.",
	"Method": "ContactSipImpl createUnresolvedContact(ContactGroupSipImpl parentGroup,String contactId,String persistentData){\r\n    if (parentGroup == null) {\r\n        throw new IllegalArgumentException(\"Parent group cannot be null\");\r\n    }\r\n    if (contactId == null || contactId.length() == 0) {\r\n        throw new IllegalArgumentException(\"Creating contact id name cannot be null or empty\");\r\n    }\r\n    ContactSipImpl existingContact = parentOperationSet.resolveContactID(contactId);\r\n    if (existingContact != null) {\r\n        return existingContact;\r\n    }\r\n    Address contactAddress;\r\n    try {\r\n        contactAddress = sipProvider.parseAddressString(contactId);\r\n    } catch (ParseException ex) {\r\n        throw new IllegalArgumentException(String.format(\"%1s is no a valid SIP identifier\", contactId), ex);\r\n    }\r\n    if (logger.isTraceEnabled())\r\n        logger.trace(\"createUnresolvedContact \" + contactId);\r\n    ContactSipImpl newUnresolvedContact = new ContactSipImpl(contactAddress, sipProvider);\r\n    newUnresolvedContact.setPersistent(true);\r\n    parentGroup.addContact(newUnresolvedContact);\r\n    newUnresolvedContact.setPersistentData(persistentData);\r\n    fireContactAdded(parentGroup, newUnresolvedContact);\r\n    return newUnresolvedContact;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.notifsource.NotificationContactSource.getContactCustomActionButtons",
	"Comment": "returns all custom action buttons for this notification contact.",
	"Method": "Collection<SIPCommButton> getContactCustomActionButtons(NotificationContact notificationContact){\r\n    customActionContact = notificationContact;\r\n    if (customActionButtons == null)\r\n        initCustomActionButtons();\r\n    Iterator<ContactAction<NotificationMessage>> customActionsIter = customActionButtons.keySet().iterator();\r\n    Collection<SIPCommButton> availableCustomActionButtons = new LinkedList<SIPCommButton>();\r\n    while (customActionsIter.hasNext()) {\r\n        ContactAction<NotificationMessage> contactAction = customActionsIter.next();\r\n        SIPCommButton actionButton = customActionButtons.get(contactAction);\r\n        if (isContactActionVisible(contactAction, notificationContact)) {\r\n            availableCustomActionButtons.add(actionButton);\r\n        }\r\n    }\r\n    return availableCustomActionButtons;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ContactJabberImpl.getProtocolProvider",
	"Comment": "returns a reference to the protocol provider that created the contact.",
	"Method": "ProtocolProviderService getProtocolProvider(){\r\n    return ssclCallback.getParentProvider();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chatroomslist.joinforms.JoinChatRoomDialog.close",
	"Comment": "when escape is pressed clicks the cancel button programatically.",
	"Method": "void close(boolean escaped){\r\n    this.cancelButton.doClick();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.packetlogging.PacketLoggingServiceImpl.isLoggingEnabled",
	"Comment": "checks is logging globally enabled for and is it currently available forthe given service.",
	"Method": "boolean isLoggingEnabled(boolean isLoggingEnabled,ProtocolName protocol){\r\n    PacketLoggingConfiguration cfg = getConfiguration();\r\n    if (cfg.isGlobalLoggingEnabled()) {\r\n        switch(protocol) {\r\n            case SIP:\r\n                return cfg.isSipLoggingEnabled();\r\n            case JABBER:\r\n                return cfg.isJabberLoggingEnabled();\r\n            case RTP:\r\n                return cfg.isRTPLoggingEnabled();\r\n            case ICE4J:\r\n                return cfg.isIce4JLoggingEnabled();\r\n            case ARBITRARY:\r\n                return cfg.isArbitraryLoggingEnabled();\r\n            default:\r\n                return false;\r\n        }\r\n    } else\r\n        return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetExtendedAuthorizationsJabberImpl.getSubscriptionStatus",
	"Comment": "returns the subscription status for the contact orif not available returns null.",
	"Method": "SubscriptionStatus getSubscriptionStatus(Contact contact){\r\n    if (!(contact instanceof ContactJabberImpl))\r\n        throw new IllegalArgumentException(\"The specified contact is not an jabber contact.\" + contact);\r\n    RosterEntry entry = ((ContactJabberImpl) contact).getSourceEntry();\r\n    if (entry != null) {\r\n        if ((entry.getType() == RosterPacket.ItemType.none || entry.getType() == RosterPacket.ItemType.from) && RosterPacket.ItemStatus.SUBSCRIPTION_PENDING == entry.getStatus()) {\r\n            return SubscriptionStatus.SubscriptionPending;\r\n        } else if (entry.getType() == RosterPacket.ItemType.to || entry.getType() == RosterPacket.ItemType.both)\r\n            return SubscriptionStatus.Subscribed;\r\n        else\r\n            return SubscriptionStatus.NotSubscribed;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatBuffer.recalculateBuffer",
	"Comment": "removes the first buffer element when the buffer limit isreached.",
	"Method": "void recalculateBuffer(){\r\n    if (this.size() >= Chat.CHAT_BUFFER_SIZE) {\r\n        this.remove(0);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaAwareCallPeer.setState",
	"Comment": "overrides the parent set state method in order to make sure that weclose our media handler whenever we enter a disconnected state.",
	"Method": "void setState(CallPeerState newState,String reason,int reasonCode){\r\n    CallPeerMediaHandler<?> mediaHandler = getMediaHandler();\r\n    synchronized (mediaHandler) {\r\n        try {\r\n            super.setState(newState, reason, reasonCode);\r\n        } finally {\r\n            if (CallPeerState.DISCONNECTED.equals(newState) || CallPeerState.FAILED.equals(newState))\r\n                mediaHandler.close();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ContactListModel.contentRemoved",
	"Comment": "informs interested listeners that a range of cells is removed.",
	"Method": "void contentRemoved(int startIndex,int endIndex){\r\n    fireIntervalRemoved(this, startIndex, endIndex);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.notificationconfiguration.NotificationEntry.setSoundFile",
	"Comment": "method which assigns the sound file name for the notification.",
	"Method": "void setSoundFile(String soundFile){\r\n    this.soundFile = soundFile;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetPersistentPresenceIcqImpl.fireProviderPresenceStatusChangeEvent",
	"Comment": "notify all provider presence listeners of the corresponding event change",
	"Method": "void fireProviderPresenceStatusChangeEvent(long oldStatusL,long newStatusL){\r\n    PresenceStatus oldStatus = statusLongToPresenceStatus(oldStatusL);\r\n    PresenceStatus newStatus = statusLongToPresenceStatus(newStatusL);\r\n    if (oldStatus.equals(newStatus))\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Ignored prov stat. change evt. old==new = \" + oldStatus);\r\n        else\r\n            fireProviderStatusChangeEvent(oldStatus, newStatus);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.OperationSetPersistentPresenceGibberishImpl.findGroupParent",
	"Comment": "returns the group that is parent of the specified gibberishgroupor nullif no parent was found.",
	"Method": "ContactGroupGibberishImpl findGroupParent(ContactGroupGibberishImpl gibberishGroup){\r\n    return contactListRoot.findGroupParent(gibberishGroup);\r\n}"
}, {
	"Path": "io.lettuce.core.RedisURI.setTimeout",
	"Comment": "sets the command timeout for synchronous command execution.",
	"Method": "void setTimeout(Duration timeout){\r\n    LettuceAssert.notNull(timeout, \"Timeout must not be null\");\r\n    LettuceAssert.isTrue(!timeout.isNegative(), \"Timeout must be greater or equal 0\");\r\n    this.timeout = timeout;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.OutputVolumeControlButton.createSliderComponent",
	"Comment": "creates the slider component for the full screen interface.",
	"Method": "Component createSliderComponent(){\r\n    ResourceManagementService r = GuiActivator.getResources();\r\n    final Color bgColor = new Color(r.getColor(\"service.gui.CALL_TOOL_BAR_SOUND_BG\"));\r\n    @SuppressWarnings(\"serial\")\r\n    TransparentPanel soundPanel = new TransparentPanel(new FlowLayout(FlowLayout.LEFT, 0, 0)) {\r\n        @Override\r\n        public void paintComponent(Graphics g) {\r\n            super.paintComponent(g);\r\n            g = g.create();\r\n            try {\r\n                AntialiasingManager.activateAntialiasing(g);\r\n                g.setColor(bgColor);\r\n                g.fillRoundRect(0, 0, getWidth() - 1, getHeight() - 1, 8, 8);\r\n            } finally {\r\n                g.dispose();\r\n            }\r\n        }\r\n    };\r\n    soundPanel.setBorder(BorderFactory.createEmptyBorder(3, 3, 3, 3));\r\n    VolumeControl volumeControl = getOutputVolumeControl();\r\n    VolumeControlSlider slider = new VolumeControlSlider(volumeControl, JSlider.HORIZONTAL);\r\n    soundPanel.add(new JLabel(r.getImage(\"service.gui.icons.NO_SOUND_ICON\")));\r\n    soundPanel.add(slider);\r\n    soundPanel.add(new JLabel(r.getImage(\"service.gui.icons.SOUND_MENU_ICON\")));\r\n    return soundPanel;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.OutputVolumeControlButton.createSliderComponent",
	"Comment": "creates the slider component for the full screen interface.",
	"Method": "Component createSliderComponent(){\r\n    super.paintComponent(g);\r\n    g = g.create();\r\n    try {\r\n        AntialiasingManager.activateAntialiasing(g);\r\n        g.setColor(bgColor);\r\n        g.fillRoundRect(0, 0, getWidth() - 1, getHeight() - 1, 8, 8);\r\n    } finally {\r\n        g.dispose();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.googlecontacts.GoogleContactsQuery.stopped",
	"Comment": "notifies this googlecontactsquery that it has stopped performingin the associated background thread.",
	"Method": "void stopped(boolean completed){\r\n    try {\r\n        super.stopped(completed);\r\n    } finally {\r\n        getContactSource().stopped(this);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.callhistory.CallHistoryServiceImpl.serviceChanged",
	"Comment": "when new protocol provider is registered we checkdoes it supports basictelephony and if so add a listener to it",
	"Method": "void serviceChanged(ServiceEvent serviceEvent){\r\n    Object sService = bundleContext.getService(serviceEvent.getServiceReference());\r\n    if (logger.isTraceEnabled())\r\n        logger.trace(\"Received a service event for: \" + sService.getClass().getName());\r\n    if (!(sService instanceof ProtocolProviderService)) {\r\n        return;\r\n    }\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Service is a protocol provider.\");\r\n    if (serviceEvent.getType() == ServiceEvent.REGISTERED) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Handling registration of a new Protocol Provider.\");\r\n        this.handleProviderAdded((ProtocolProviderService) sService);\r\n    } else if (serviceEvent.getType() == ServiceEvent.UNREGISTERING) {\r\n        this.handleProviderRemoved((ProtocolProviderService) sService);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.AdHocChatRoomIcqImpl.getParticipants",
	"Comment": "returns a list of contacts corresponding to allparticipants currently participating in this room.",
	"Method": "List<Contact> getParticipants(){\r\n    return new LinkedList<Contact>(participants.values());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ContactListPane.messageDeliveryFailed",
	"Comment": "shows a warning message to the user when message delivery has failed.",
	"Method": "void messageDeliveryFailed(MessageDeliveryFailedEvent evt){\r\n    logger.error(evt.getReason());\r\n    String errorMsg = null;\r\n    Message sourceMessage = (Message) evt.getSource();\r\n    Contact sourceContact = evt.getDestinationContact();\r\n    MetaContact metaContact = GuiActivator.getContactListService().findMetaContactByContact(sourceContact);\r\n    if (evt.getErrorCode() == MessageDeliveryFailedEvent.OFFLINE_MESSAGES_NOT_SUPPORTED) {\r\n        errorMsg = GuiActivator.getResources().getI18NString(\"service.gui.MSG_DELIVERY_NOT_SUPPORTED\", new String[] { sourceContact.getDisplayName() });\r\n    } else if (evt.getErrorCode() == MessageDeliveryFailedEvent.NETWORK_FAILURE) {\r\n        errorMsg = GuiActivator.getResources().getI18NString(\"service.gui.MSG_NOT_DELIVERED\");\r\n    } else if (evt.getErrorCode() == MessageDeliveryFailedEvent.PROVIDER_NOT_REGISTERED) {\r\n        errorMsg = GuiActivator.getResources().getI18NString(\"service.gui.MSG_SEND_CONNECTION_PROBLEM\");\r\n    } else if (evt.getErrorCode() == MessageDeliveryFailedEvent.INTERNAL_ERROR) {\r\n        errorMsg = GuiActivator.getResources().getI18NString(\"service.gui.MSG_DELIVERY_INTERNAL_ERROR\");\r\n    } else if (evt.getErrorCode() == MessageDeliveryFailedEvent.UNSUPPORTED_OPERATION) {\r\n        errorMsg = GuiActivator.getResources().getI18NString(\"service.gui.MSG_DELIVERY_UNSUPPORTED_OPERATION\");\r\n    } else {\r\n        errorMsg = GuiActivator.getResources().getI18NString(\"service.gui.MSG_DELIVERY_ERROR\");\r\n    }\r\n    String reason = evt.getReason();\r\n    if (reason != null)\r\n        errorMsg += \" \" + GuiActivator.getResources().getI18NString(\"service.gui.ERROR_WAS\", new String[] { reason });\r\n    ChatPanel chatPanel = chatWindowManager.getContactChat(metaContact, sourceContact);\r\n    chatPanel.addMessage(sourceContact.getAddress(), metaContact.getDisplayName(), new Date(), Chat.OUTGOING_MESSAGE, sourceMessage.getContent(), sourceMessage.getContentType(), sourceMessage.getMessageUID(), evt.getCorrectedMessageUID());\r\n    chatPanel.addErrorMessage(metaContact.getDisplayName(), errorMsg);\r\n    chatWindowManager.openChat(chatPanel, false);\r\n}"
}, {
	"Path": "io.lettuce.core.dynamic.support.MethodParameter.hasParameterAnnotations",
	"Comment": "return true if the parameter has at least one annotation, false if it has none.",
	"Method": "boolean hasParameterAnnotations(){\r\n    return (getParameterAnnotations().length != 0);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler.getSrtpControls",
	"Comment": "gets the srtpcontrols of the mediastreams of thisinstance.",
	"Method": "SrtpControls getSrtpControls(){\r\n    return mediaHandler.getSrtpControls(this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.sip.TestOperationSetPresence.getSampleStatus2",
	"Comment": "returns the online status with the second highest connectivity index.",
	"Method": "PresenceStatus getSampleStatus2(){\r\n    int mostConnectedPresenceStatusInt = Integer.MIN_VALUE;\r\n    PresenceStatus secondMostConnectedPresenceStatus = null;\r\n    int secondMostConnectedPresenceStatusInt = Integer.MIN_VALUE;\r\n    Iterator<PresenceStatus> supportedStatusSetIter = this.operationSetPresence1.getSupportedStatusSet();\r\n    while (supportedStatusSetIter.hasNext()) {\r\n        PresenceStatus supportedStatus = supportedStatusSetIter.next();\r\n        if (supportedStatus.getStatus() > mostConnectedPresenceStatusInt) {\r\n            mostConnectedPresenceStatusInt = supportedStatus.getStatus();\r\n        } else if (supportedStatus.getStatus() > secondMostConnectedPresenceStatusInt) {\r\n            secondMostConnectedPresenceStatus = supportedStatus;\r\n            secondMostConnectedPresenceStatusInt = supportedStatus.getStatus();\r\n        }\r\n    }\r\n    return secondMostConnectedPresenceStatus;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.sip.TestOperationSetPresence.getSampleStatus1",
	"Comment": "returns the online status with a highest connectivity index.",
	"Method": "PresenceStatus getSampleStatus1(){\r\n    PresenceStatus mostConnectedPresenceStatus = null;\r\n    int mostConnectedPresenceStatusInt = Integer.MIN_VALUE;\r\n    Iterator<PresenceStatus> supportedStatusSetIter = this.operationSetPresence1.getSupportedStatusSet();\r\n    while (supportedStatusSetIter.hasNext()) {\r\n        PresenceStatus supportedStatus = supportedStatusSetIter.next();\r\n        if (supportedStatus.getStatus() > mostConnectedPresenceStatusInt) {\r\n            mostConnectedPresenceStatusInt = supportedStatus.getStatus();\r\n            mostConnectedPresenceStatus = supportedStatus;\r\n        }\r\n    }\r\n    return mostConnectedPresenceStatus;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.ProtocolProviderServiceGibberishImpl.getAccountID",
	"Comment": "returns the accountid that uniquely identifies the account representedby this instance of the protocolproviderservice.",
	"Method": "AccountID getAccountID(){\r\n    return accountID;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ContactSipImpl.getParentPresenceOperationSet",
	"Comment": "returns the presence operation set that this contact belongsto.",
	"Method": "OperationSetPresenceSipImpl getParentPresenceOperationSet(){\r\n    return (OperationSetPresenceSipImpl) parentProvider.getOperationSet(OperationSetPresence.class);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.thunderbird.ThunderbirdActivator.remove",
	"Comment": "stops an address book service and deletes the corresponding configurationdata.",
	"Method": "void remove(ThunderbirdContactSourceService service){\r\n    registrations.get(service).unregister();\r\n    registrations.remove(service);\r\n    ConfigurationService config = getConfigService();\r\n    config.removeProperty(service.getBaseConfigProperty());\r\n    for (String prop : config.getPropertyNamesByPrefix(service.getBaseConfigProperty(), false)) {\r\n        config.removeProperty(prop);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipActivator.getUIService",
	"Comment": "returns a reference to the uiservice implementation currently registeredin the bundle context or null if no such implementation was found.",
	"Method": "UIService getUIService(){\r\n    if (uiService == null) {\r\n        ServiceReference uiServiceReference = bundleContext.getServiceReference(UIService.class.getName());\r\n        uiService = (UIService) bundleContext.getService(uiServiceReference);\r\n    }\r\n    return uiService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.resources.ResourceManagementServiceImpl.getImageInputStream",
	"Comment": "returns the inputstream of the image corresponding to the givenkey.",
	"Method": "InputStream getImageInputStream(String streamKey){\r\n    String path = getImagePath(streamKey);\r\n    if (path == null || path.length() == 0) {\r\n        logger.warn(\"Missing resource for key: \" + streamKey);\r\n        return null;\r\n    }\r\n    return getImageInputStreamForPath(path);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomMemberJabberImpl.getProtocolProvider",
	"Comment": "returns the protocol provider instance that this member has originatedin.",
	"Method": "ProtocolProviderService getProtocolProvider(){\r\n    return containingRoom.getParentProvider();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.contactlist.event.MetaContactEvent.getParentGroup",
	"Comment": "returns the metacontactgroup that the metacontact belongs to.",
	"Method": "MetaContactGroup getParentGroup(){\r\n    return parentGroup;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetDesktopSharingServerJabberImpl.disableRemoteControl",
	"Comment": "disable desktop remote control. local desktop stops regenerate keyboardand mouse events received from peer.",
	"Method": "void disableRemoteControl(CallPeer callPeer){\r\n    this.modifyRemoteControl(callPeer, false);\r\n    callPeer.removeCallPeerListener(callPeerListener);\r\n    origin = null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ProtocolIconIcqImpl.getImageInBytes",
	"Comment": "returns the byte representation of the image corresponding to the givenidentifier.",
	"Method": "byte[] getImageInBytes(String imageID){\r\n    InputStream in = getResources().getImageInputStream(imageID);\r\n    if (in == null)\r\n        return null;\r\n    byte[] image = null;\r\n    try {\r\n        image = new byte[in.available()];\r\n        in.read(image);\r\n    } catch (IOException e) {\r\n        logger.error(\"Failed to load image:\" + imageID, e);\r\n    }\r\n    return image;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AccountID.getAccountPropertyString",
	"Comment": "returns the account property string corresponding to the given key.",
	"Method": "String getAccountPropertyString(Object key,String getAccountPropertyString,Object key,String defValue){\r\n    String value = accountProperties.get(key);\r\n    if (value == null)\r\n        value = getDefaultString(key.toString());\r\n    return (value == null) ? defValue : value;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.ircaccregwizz.IrcAccountRegistration.isResolveDnsThroughProxy",
	"Comment": "get property for resolving dns names through configured proxy server.true to resolve dns names through configured proxy server, orfalse to resolve using own dns server.",
	"Method": "boolean isResolveDnsThroughProxy(){\r\n    return this.resolveDnsThroughProxy;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler.isDeviceActive",
	"Comment": "checks whether dev can be used for a call, usingsendpreset and reveicepreset",
	"Method": "boolean isDeviceActive(MediaDevice dev,boolean isDeviceActive,MediaDevice dev,QualityPreset sendPreset,QualityPreset receivePreset){\r\n    return (dev != null) && !getLocallySupportedFormats(dev, sendPreset, receivePreset).isEmpty();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.ZrtpSecurityPanel.setVideoSecurityOn",
	"Comment": "updates video security related components, depending on the given videosecurity state.",
	"Method": "void setVideoSecurityOn(boolean isVideoSecurityOn){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                setVideoSecurityOn(isVideoSecurityOn);\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    this.isVideoSecurityOn = isVideoSecurityOn;\r\n    Icon icon = null;\r\n    String text = null;\r\n    boolean visible = false;\r\n    OperationSetVideoTelephony videoTelephony = callPeer.getProtocolProvider().getOperationSet(OperationSetVideoTelephony.class);\r\n    if (videoTelephony != null) {\r\n        visible = ((MediaAwareCallPeer<?, ?, ?>) callPeer).isLocalVideoStreaming();\r\n        if (!visible) {\r\n            List<Component> videos = videoTelephony.getVisualComponents(callPeer);\r\n            visible = ((videos != null) && (videos.size() != 0));\r\n        }\r\n        if (visible) {\r\n            ResourceManagementService r = GuiActivator.getResources();\r\n            if (isVideoSecurityOn) {\r\n                icon = videoSecuredIcon;\r\n                text = r.getI18NString(\"service.gui.security.SECURE_VIDEO\");\r\n            } else {\r\n                icon = videoNotSecuredIcon;\r\n                text = r.getI18NString(\"service.gui.security.VIDEO_NOT_SECURED\");\r\n            }\r\n        }\r\n    }\r\n    if ((icon != null) && (text != null)) {\r\n        videoSecurityLabel.setIcon(icon);\r\n        videoSecurityLabel.setText(text);\r\n        if (!videoSecurityLabel.isVisible())\r\n            videoSecurityLabel.setVisible(true);\r\n    } else\r\n        videoSecurityLabel.setVisible(visible);\r\n    revalidate();\r\n    repaint();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.ZrtpSecurityPanel.setVideoSecurityOn",
	"Comment": "updates video security related components, depending on the given videosecurity state.",
	"Method": "void setVideoSecurityOn(boolean isVideoSecurityOn){\r\n    setVideoSecurityOn(isVideoSecurityOn);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetUserSearchJabberImpl.setUserSearchEnabled",
	"Comment": "sets the usersearchenabled property and firesusersearchproviderevent event.",
	"Method": "void setUserSearchEnabled(boolean isEnabled){\r\n    userSearchEnabled = isEnabled;\r\n    int type = (isEnabled ? UserSearchProviderEvent.PROVIDER_ADDED : UserSearchProviderEvent.PROVIDER_REMOVED);\r\n    fireUserSearchProviderEvent(new UserSearchProviderEvent(provider, type));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl.processBye",
	"Comment": "sets the state of the corresponding call peer to disconnected andsends an ok response.",
	"Method": "void processBye(ServerTransaction serverTransaction,Request byeRequest){\r\n    Dialog dialog = serverTransaction.getDialog();\r\n    CallPeerSipImpl callPeer = activeCallsRepository.findCallPeer(dialog);\r\n    if (callPeer == null) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Received a stray bye request.\");\r\n        return;\r\n    }\r\n    callPeer.processBye(serverTransaction);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ServerStoredContactListSipImpl.removeContact",
	"Comment": "removes a contact. if creation is successfull event will be fired.",
	"Method": "void removeContact(ContactSipImpl contact){\r\n    if (contact == null) {\r\n        throw new IllegalArgumentException(\"Removing contact cannot be null\");\r\n    }\r\n    if (logger.isTraceEnabled())\r\n        logger.trace(\"removeContact \" + contact.getUri());\r\n    ContactGroupSipImpl parentGroup = (ContactGroupSipImpl) contact.getParentContactGroup();\r\n    parentGroup.removeContact(contact);\r\n    if (contact.isPersistent()) {\r\n        try {\r\n            boolean updateRules = removeContactFromWhiteList(contact);\r\n            updateRules = removeContactFromBlockList(contact) || updateRules;\r\n            updateRules = removeContactFromPoliteBlockList(contact) || updateRules;\r\n            if (updateRules)\r\n                updatePresRules();\r\n        } catch (XCapException e) {\r\n            logger.error(\"Error while removing XCAP contact\", e);\r\n        }\r\n        try {\r\n            updateResourceLists();\r\n        } catch (XCapException e) {\r\n            parentGroup.removeContact(contact);\r\n            throw new OperationFailedException(\"Error while removing XCAP contact\", OperationFailedException.NETWORK_FAILURE, e);\r\n        }\r\n    }\r\n    fireContactRemoved(parentGroup, contact);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.MetaContactListSource.metaContactGroupAdded",
	"Comment": "adds a group node in the contact list, when a metacontactgrouphas been added in the metacontactlistservice.",
	"Method": "void metaContactGroupAdded(MetaContactGroupEvent evt){\r\n    final MetaContactGroup metaGroup = evt.getSourceMetaContactGroup();\r\n    UIGroup uiGroup;\r\n    synchronized (metaGroup) {\r\n        uiGroup = MetaContactListSource.getUIGroup(metaGroup);\r\n        if (uiGroup != null)\r\n            return;\r\n        uiGroup = MetaContactListSource.createUIGroup(metaGroup);\r\n    }\r\n    if (metaGroup.countChildContacts() == 0) {\r\n        metaGroup.setData(GROUP_IS_NEW_KEY, Boolean.TRUE);\r\n    }\r\n    ContactListFilter currentFilter = GuiActivator.getContactList().getCurrentFilter();\r\n    if (currentFilter.isMatching(uiGroup))\r\n        GuiActivator.getContactList().addGroup(uiGroup, true);\r\n    else\r\n        MetaContactListSource.removeUIGroup(metaGroup);\r\n    Iterator<MetaContact> iterContacts = metaGroup.getChildContacts();\r\n    while (iterContacts.hasNext()) {\r\n        metaContactAdded(iterContacts.next(), metaGroup);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractProtocolProviderService.isRegistrationRequiredForCalling",
	"Comment": "indicates whether or not this provider must registeredwhen placing outgoing calls.",
	"Method": "boolean isRegistrationRequiredForCalling(){\r\n    return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.neomedia.codec.video.h264.ConfigurationPanel.createLineWrapLabel",
	"Comment": "initializes a new component instance which is to display aspecific text in the fashion of jlabel and with line wrapping.",
	"Method": "Component createLineWrapLabel(String text){\r\n    JTextArea textArea = new JTextArea();\r\n    textArea.setEditable(false);\r\n    textArea.setFocusable(false);\r\n    textArea.setLineWrap(true);\r\n    textArea.setOpaque(false);\r\n    textArea.setWrapStyleWord(true);\r\n    textArea.setText(text);\r\n    return textArea;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.AbstractOperationSetVideoTelephony.getQualityControl",
	"Comment": "returns the quality control for video calls if any.return null so protocols who supports it to override it.",
	"Method": "QualityControl getQualityControl(CallPeer peer){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.dtmf.DTMFInfo.removeDTMFListener",
	"Comment": "removes the specified listener from the list of dtmf listeners.",
	"Method": "void removeDTMFListener(DTMFListener listener){\r\n    synchronized (dtmfListeners) {\r\n        dtmfListeners.remove(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.history.HistoryServiceLick.start",
	"Comment": "start the history sevice implementation compatibility kit.",
	"Method": "void start(BundleContext bundleContext){\r\n    HistoryServiceLick.bc = bundleContext;\r\n    setName(\"HistoryServiceLick\");\r\n    Hashtable<String, String> properties = new Hashtable<String, String>();\r\n    properties.put(\"service.pid\", getName());\r\n    addTest(TestHistoryService.suite());\r\n    bundleContext.registerService(getClass().getName(), this, properties);\r\n    logger.debug(\"Successfully registered \" + getClass().getName());\r\n}"
}, {
	"Path": "com.github.ltsopensource.core.support.CronExpression.getTimeZone",
	"Comment": "returns the time zone for which this cronexpressionwill be resolved.",
	"Method": "TimeZone getTimeZone(){\r\n    if (timeZone == null) {\r\n        timeZone = TimeZone.getDefault();\r\n    }\r\n    return timeZone;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.spellcheck.Parameters.getLocales",
	"Comment": "provides locales in which dictionary resources are available.",
	"Method": "ArrayList<Locale> getLocales(){\r\n    return new ArrayList<Locale>(LOCALES);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler.setLocalUserAudioLevelListener",
	"Comment": "if the local audiomediastream has already been created, setslistener as the simpleaudiolevellistener that it shouldnotify for local user level events. otherwise stores a reference tolistener so that we could add it once we create the stream.",
	"Method": "void setLocalUserAudioLevelListener(SimpleAudioLevelListener listener){\r\n    synchronized (localUserAudioLevelListenerLock) {\r\n        if (this.localUserAudioLevelListener != listener) {\r\n            MediaHandler mediaHandler = getMediaHandler();\r\n            if ((mediaHandler != null) && (this.localUserAudioLevelListener != null)) {\r\n                mediaHandler.removeLocalUserAudioLevelListener(this.localUserAudioLevelListener);\r\n            }\r\n            this.localUserAudioLevelListener = listener;\r\n            if ((mediaHandler != null) && (this.localUserAudioLevelListener != null)) {\r\n                mediaHandler.addLocalUserAudioLevelListener(this.localUserAudioLevelListener);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.AbstractCallPeerMediaHandlerJabberGTalkImpl.addSDesAdvertisedEncryptions",
	"Comment": "detects and adds sdes available encryption method present in thedescription given in parameter.",
	"Method": "void addSDesAdvertisedEncryptions(boolean isInitiator,RtpDescriptionPacketExtension description,MediaType mediaType){\r\n    CallPeer peer = getPeer();\r\n    if (peer.getCall().getConference().isJitsiVideobridge())\r\n        return;\r\n    EncryptionPacketExtension encryptionPacketExtension = description.getFirstChildOfType(EncryptionPacketExtension.class);\r\n    if (encryptionPacketExtension != null) {\r\n        AccountID accountID = peer.getProtocolProvider().getAccountID();\r\n        if (accountID.getAccountPropertyBoolean(ProtocolProviderFactory.DEFAULT_ENCRYPTION, true) && accountID.isEncryptionProtocolEnabled(SrtpControlType.SDES)) {\r\n            SrtpControls srtpControls = getSrtpControls();\r\n            SDesControl sdesControl = (SDesControl) srtpControls.getOrCreate(mediaType, SrtpControlType.SDES);\r\n            SrtpCryptoAttribute selectedSdes = selectSdesCryptoSuite(isInitiator, sdesControl, encryptionPacketExtension);\r\n            if (selectedSdes != null) {\r\n                removeAndCleanupOtherSrtpControls(mediaType, SrtpControlType.SDES);\r\n                addAdvertisedEncryptionMethod(SrtpControlType.SDES);\r\n            } else {\r\n                sdesControl.cleanup(null);\r\n                srtpControls.remove(mediaType, SrtpControlType.SDES);\r\n            }\r\n        }\r\n    } else if (isInitiator) {\r\n        SrtpControl sdesControl = getSrtpControls().remove(mediaType, SrtpControlType.SDES);\r\n        if (sdesControl != null)\r\n            sdesControl.cleanup(null);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.GlobalStatusSelectorBox.getItemFromStatus",
	"Comment": "returns the jcheckboxmenuitem corresponding to the given status.for status constants we use here the values defined in thepresencestatus, but this is only for convenience.",
	"Method": "JCheckBoxMenuItem getItemFromStatus(PresenceStatus globalStatus){\r\n    for (Component c : getMenuComponents()) {\r\n        if (c instanceof JCheckBoxMenuItem && globalStatus.getStatusName().equals(c.getName())) {\r\n            return (JCheckBoxMenuItem) c;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.ChatRoomInvitationRejectedEvent.getInvitee",
	"Comment": "returns the name of the invitee that rejected the invitation.",
	"Method": "String getInvitee(){\r\n    return invitee;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.msoutlook.MsOutlookAddrBookContactQuery.updated",
	"Comment": "callback method when receiving notifications for updated items.",
	"Method": "void updated(String id){\r\n    synchronized (MsOutlookAddrBookContactQuery.class) {\r\n        insertedOrUpdated(id, 1);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.notificationconfiguration.NotificationConfigurationActivator.start",
	"Comment": "starts this bundle and adds the audioconfigurationconfigformcontained in it to the configuration window obtained from theuiservice.",
	"Method": "void start(BundleContext bc){\r\n    bundleContext = bc;\r\n    if (getConfigurationService().getBoolean(DISABLED_PROP, false))\r\n        return;\r\n    Dictionary<String, String> properties = new Hashtable<String, String>();\r\n    properties.put(ConfigurationForm.FORM_TYPE, ConfigurationForm.GENERAL_TYPE);\r\n    bundleContext.registerService(ConfigurationForm.class.getName(), new LazyConfigurationForm(\"net.java.sip.communicator.plugin.notificationconfiguration.NotificationConfigurationPanel\", getClass().getClassLoader(), \"plugin.notificationconfig.PLUGIN_ICON\", \"service.gui.EVENTS\", 30), properties);\r\n    if (logger.isTraceEnabled())\r\n        logger.trace(\"Notification Configuration: [ STARTED ]\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.sipaccregwizz.FirstWizardPage.getIdentifier",
	"Comment": "implements the wizardpage.getidentifier to return thispage identifier.",
	"Method": "Object getIdentifier(){\r\n    return FIRST_PAGE_IDENTIFIER;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ContactResourceJabberImpl.getFullJid",
	"Comment": "returns the full jid corresponding to this contact resource.",
	"Method": "String getFullJid(){\r\n    return fullJid;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.MetaContactListSource.queryMetaContactSource",
	"Comment": "filters the children in the given metacontactgroup to match thegiven filterpattern and stores the result in the giventreemodel.",
	"Method": "void queryMetaContactSource(Pattern filterPattern,MetaContactGroup parentGroup,MetaContactQuery query,int resultCount){\r\n    Iterator<MetaContact> childContacts = parentGroup.getChildContacts();\r\n    while (childContacts.hasNext() && !query.isCanceled()) {\r\n        MetaContact metaContact = childContacts.next();\r\n        if (isMatching(filterPattern, metaContact)) {\r\n            resultCount++;\r\n            if (resultCount <= INITIAL_CONTACT_COUNT) {\r\n                UIGroup uiGroup = null;\r\n                if (!MetaContactListSource.isRootGroup(parentGroup)) {\r\n                    synchronized (parentGroup) {\r\n                        uiGroup = MetaContactListSource.getUIGroup(parentGroup);\r\n                        if (uiGroup == null)\r\n                            uiGroup = MetaContactListSource.createUIGroup(parentGroup);\r\n                    }\r\n                }\r\n                UIContact newUIContact;\r\n                synchronized (metaContact) {\r\n                    newUIContact = MetaContactListSource.getUIContact(metaContact);\r\n                    if (newUIContact == null) {\r\n                        newUIContact = MetaContactListSource.createUIContact(metaContact);\r\n                    }\r\n                    GuiActivator.getContactList().addContact(newUIContact, uiGroup, true, true);\r\n                }\r\n                query.setInitialResultCount(resultCount);\r\n            } else {\r\n                query.fireQueryEvent(metaContact);\r\n            }\r\n        }\r\n    }\r\n    if (query.isCanceled())\r\n        return;\r\n    Iterator<MetaContactGroup> subgroups = parentGroup.getSubgroups();\r\n    while (subgroups.hasNext() && !query.isCanceled()) {\r\n        MetaContactGroup subgroup = subgroups.next();\r\n        queryMetaContactSource(filterPattern, subgroup, query, resultCount);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ServerStoredContactListIcqImpl.findContactGroupIndex",
	"Comment": "returns the index of the contactgroup containing the specified joust simgroup.",
	"Method": "int findContactGroupIndex(Group joustSimGroup){\r\n    Iterator<ContactGroup> contactGroups = rootGroup.subgroups();\r\n    int index = 0;\r\n    for (; contactGroups.hasNext(); index++) {\r\n        ContactGroupIcqImpl contactGroup = (ContactGroupIcqImpl) contactGroups.next();\r\n        if (joustSimGroup == contactGroup.getJoustSimSourceGroup())\r\n            return index;\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "io.lettuce.core.protocol.ConnectionFailureIntegrationTests.pingBeforeConnectFails",
	"Comment": "expect to run into invalid first byte exception instead of timeout.",
	"Method": "void pingBeforeConnectFails(){\r\n    client.setOptions(ClientOptions.builder().pingBeforeActivateConnection(true).build());\r\n    RandomResponseServer ts = getRandomResponseServer();\r\n    RedisURI redisUri = RedisURI.Builder.redis(TestSettings.host(), TestSettings.nonexistentPort()).withTimeout(10, TimeUnit.MINUTES).build();\r\n    try {\r\n        client.connect(redisUri);\r\n    } catch (Exception e) {\r\n        assertThat(e).isExactlyInstanceOf(RedisConnectionException.class);\r\n        assertThat(e.getCause()).hasMessageContaining(\"Invalid first byte:\");\r\n    } finally {\r\n        ts.shutdown();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chatroomslist.createforms.CreateChatRoomWizardPage2.getBackPageIdentifier",
	"Comment": "implements the wizardpaneldescriptor method to return theidentifier of the previous wizard page.",
	"Method": "Object getBackPageIdentifier(){\r\n    return CreateChatRoomWizardPage1.IDENTIFIER;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomIrcImpl.removePropertyChangeListener",
	"Comment": "removes listener from the list of listeners currentregistered for chat room modification events.",
	"Method": "void removePropertyChangeListener(ChatRoomPropertyChangeListener listener){\r\n    synchronized (propertyChangeListeners) {\r\n        propertyChangeListeners.remove(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.metahistory.TestMetaHistoryService.testPurgeLocalContactListCopy",
	"Comment": "removes the locally stored contact list copy. the purpose of this is toleave the local list empty for a next round of testing.",
	"Method": "void testPurgeLocalContactListCopy(){\r\n    metaClService.purgeLocallyStoredContactListCopy();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.LoginByClientCertificateStrategy.createSslContext",
	"Comment": "creates the sslcontext for the xmpp connection configured with acustomized trustmanager and a keymanager based on the selected clientcertificate.",
	"Method": "SSLContext createSslContext(CertificateService cs,X509ExtendedTrustManager trustManager){\r\n    String certConfigName = accountID.getAccountPropertyString(ProtocolProviderFactory.CLIENT_TLS_CERTIFICATE);\r\n    return cs.getSSLContext(certConfigName, trustManager);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.ProviderStatusChangeEvent.getOldStatusValue",
	"Comment": "returns the status of the provider before this event took place.",
	"Method": "PresenceStatus getOldStatusValue(){\r\n    return (PresenceStatus) super.getOldValue();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.ippiaccregwizz.IppiAccountRegistrationWizard.getProtocolDescription",
	"Comment": "implements the accountregistrationwizard.getprotocoldescription method. returns the description of the protocol for this wizard.",
	"Method": "String getProtocolDescription(){\r\n    return Resources.getString(\"plugin.ippiaccregwizz.PROTOCOL_DESCRIPTION\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaHandler.setAudioStream",
	"Comment": "sets the audiomediastream which this instance is to use to sendand receive audio.",
	"Method": "void setAudioStream(AudioMediaStream audioStream){\r\n    if (this.audioStream != audioStream) {\r\n        if (this.audioStream != null) {\r\n            synchronized (csrcAudioLevelListenerLock) {\r\n                if (!csrcAudioLevelListeners.isEmpty())\r\n                    this.audioStream.setCsrcAudioLevelListener(null);\r\n            }\r\n            synchronized (localUserAudioLevelListenerLock) {\r\n                if (!localUserAudioLevelListeners.isEmpty())\r\n                    this.audioStream.setLocalUserAudioLevelListener(null);\r\n            }\r\n            synchronized (streamAudioLevelListenerLock) {\r\n                if (!streamAudioLevelListeners.isEmpty())\r\n                    this.audioStream.setStreamAudioLevelListener(null);\r\n            }\r\n            this.audioStream.removePropertyChangeListener(streamPropertyChangeListener);\r\n            this.audioStream.removeDTMFListener(dtmfListener);\r\n            this.audioStream.close();\r\n        }\r\n        this.audioStream = audioStream;\r\n        long audioLocalSSRC;\r\n        long audioRemoteSSRC;\r\n        if (this.audioStream != null) {\r\n            this.audioStream.addPropertyChangeListener(streamPropertyChangeListener);\r\n            audioLocalSSRC = this.audioStream.getLocalSourceID();\r\n            audioRemoteSSRC = this.audioStream.getRemoteSourceID();\r\n            synchronized (csrcAudioLevelListenerLock) {\r\n                if (!csrcAudioLevelListeners.isEmpty()) {\r\n                    this.audioStream.setCsrcAudioLevelListener(csrcAudioLevelListener);\r\n                }\r\n            }\r\n            synchronized (localUserAudioLevelListenerLock) {\r\n                if (!localUserAudioLevelListeners.isEmpty()) {\r\n                    this.audioStream.setLocalUserAudioLevelListener(localUserAudioLevelListener);\r\n                }\r\n            }\r\n            synchronized (streamAudioLevelListenerLock) {\r\n                if (!streamAudioLevelListeners.isEmpty()) {\r\n                    this.audioStream.setStreamAudioLevelListener(streamAudioLevelListener);\r\n                }\r\n            }\r\n            this.audioStream.addDTMFListener(dtmfListener);\r\n        } else {\r\n            audioLocalSSRC = audioRemoteSSRC = CallPeerMediaHandler.SSRC_UNKNOWN;\r\n        }\r\n        setLocalSSRC(MediaType.AUDIO, audioLocalSSRC);\r\n        setRemoteSSRC(MediaType.AUDIO, audioRemoteSSRC);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.MainFrame.removePluginComponent",
	"Comment": "removes the given component from the container corresponding to the givenconstraints.",
	"Method": "void removePluginComponent(Component c,Container container,Object constraints){\r\n    if (container.equals(Container.CONTAINER_MAIN_WINDOW)) {\r\n        if (constraints.equals(BorderLayout.NORTH))\r\n            pluginPanelNorth.remove(c);\r\n        else if (constraints.equals(BorderLayout.SOUTH))\r\n            pluginPanelSouth.remove(c);\r\n        else if (constraints.equals(BorderLayout.WEST))\r\n            pluginPanelWest.remove(c);\r\n        else if (constraints.equals(BorderLayout.EAST))\r\n            pluginPanelEast.remove(c);\r\n    } else if (container.equals(Container.CONTAINER_STATUS_BAR)) {\r\n        this.statusBarPanel.remove(c);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.provisioning.ProvisioningActivator.getConfigurationService",
	"Comment": "returns a reference to a configurationservice implementation currentlyregistered in the bundle context or null if no such implementation wasfound.",
	"Method": "ConfigurationService getConfigurationService(){\r\n    if (configurationService == null) {\r\n        ServiceReference confReference = bundleContext.getServiceReference(ConfigurationService.class.getName());\r\n        configurationService = (ConfigurationService) bundleContext.getService(confReference);\r\n    }\r\n    return configurationService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommTextArea.addTextChangeListener",
	"Comment": "adds the given textfieldchangelistener to the list of listenersnotified on changes of the text contained in this field.",
	"Method": "void addTextChangeListener(TextFieldChangeListener l){\r\n    synchronized (changeListeners) {\r\n        changeListeners.add(l);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.ContactPresenceStatusChangeEvent.isResourceChanged",
	"Comment": "when the event fired is change in the resource of the contact willreturn true.",
	"Method": "boolean isResourceChanged(){\r\n    return resourceChanged;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.IceConfigPanel.addJingleNodes",
	"Comment": "adds the given jinglenode to the list of additional jinglenodes",
	"Method": "void addJingleNodes(JingleNodeDescriptor jingleNode){\r\n    jnTableModel.addRow(new Object[] { jingleNode, jingleNode.isRelaySupported() });\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.SessionListenerTest.testExpiredSession",
	"Comment": "check that a session that is expired cannot be reused, and expiry listeners are called for it",
	"Method": "void testExpiredSession(){\r\n    String contextPath = \"/\";\r\n    String servletMapping = \"/server\";\r\n    int inactivePeriod = 4;\r\n    int scavengePeriod = 1;\r\n    DefaultSessionCacheFactory cacheFactory = new DefaultSessionCacheFactory();\r\n    cacheFactory.setEvictionPolicy(SessionCache.NEVER_EVICT);\r\n    SessionDataStoreFactory storeFactory = new TestSessionDataStoreFactory();\r\n    ((AbstractSessionDataStoreFactory) storeFactory).setGracePeriodSec(scavengePeriod);\r\n    TestServer server1 = new TestServer(0, inactivePeriod, scavengePeriod, cacheFactory, storeFactory);\r\n    SimpleTestServlet servlet = new SimpleTestServlet();\r\n    ServletHolder holder = new ServletHolder(servlet);\r\n    ServletContextHandler context = server1.addContext(contextPath);\r\n    context.addServlet(holder, servletMapping);\r\n    TestHttpSessionListener listener = new TestHttpSessionListener();\r\n    context.getSessionHandler().addEventListener(listener);\r\n    server1.start();\r\n    int port1 = server1.getPort();\r\n    try {\r\n        long now = System.currentTimeMillis();\r\n        SessionData data = context.getSessionHandler().getSessionCache().getSessionDataStore().newSessionData(\"1234\", now - 10, now - 5, now - 10, 30000);\r\n        data.setExpiry(100);\r\n        context.getSessionHandler().getSessionCache().getSessionDataStore().store(\"1234\", data);\r\n        HttpClient client = new HttpClient();\r\n        client.start();\r\n        port1 = server1.getPort();\r\n        String url = \"http://localhost:\" + port1 + contextPath + servletMapping.substring(1);\r\n        Request request = client.newRequest(url + \"?action=test\");\r\n        request.cookie(new HttpCookie(\"JSESSIONID\", \"1234\"));\r\n        ContentResponse response = request.send();\r\n        assertEquals(HttpServletResponse.SC_OK, response.getStatus());\r\n        String cookie2 = response.getHeaders().get(\"Set-Cookie\");\r\n        assertNotEquals(\"1234\", TestServer.extractSessionId(cookie2));\r\n        assertTrue(listener.destroyedSessions.contains(\"1234\"));\r\n        assertNull(listener.ex);\r\n    } finally {\r\n        server1.stop();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.spellcheck.Parameters.getDefault",
	"Comment": "provides the value of a particular default field, null if undefined.",
	"Method": "String getDefault(Default field){\r\n    return DEFAULTS.get(field);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractOperationSetMultiUserChat.fireInvitationRejectedEvent",
	"Comment": "delivers a chatroominvitationrejectedevent to allregistered chatroominvitationrejectionlisteners.",
	"Method": "void fireInvitationRejectedEvent(ChatRoom sourceChatRoom,String invitee,String reason){\r\n    ChatRoomInvitationRejectedEvent evt = new ChatRoomInvitationRejectedEvent(this, sourceChatRoom, invitee, reason, new Date(System.currentTimeMillis()));\r\n    ChatRoomInvitationRejectionListener[] listeners;\r\n    synchronized (invitationRejectionListeners) {\r\n        listeners = invitationRejectionListeners.toArray(new ChatRoomInvitationRejectionListener[invitationRejectionListeners.size()]);\r\n    }\r\n    for (ChatRoomInvitationRejectionListener listener : listeners) listener.invitationRejected(evt);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.ldap.LdapActivator.getResourceManagementService",
	"Comment": "returns a reference to a resourcemanagementservice implementationcurrently registered in the bundle context or null if no suchimplementation was found.",
	"Method": "ResourceManagementService getResourceManagementService(){\r\n    if (resourceService == null) {\r\n        ServiceReference confReference = bundleContext.getServiceReference(ResourceManagementService.class.getName());\r\n        resourceService = (ResourceManagementService) bundleContext.getService(confReference);\r\n    }\r\n    return resourceService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.ConfigurationUtils.updateChatRoomProperty",
	"Comment": "updates the value of a chat room property through theconfigurationservice.",
	"Method": "void updateChatRoomProperty(ProtocolProviderService protocolProvider,String chatRoomId,String property,String value){\r\n    String prefix = \"net.java.sip.communicator.impl.gui.accounts\";\r\n    List<String> accounts = configService.getPropertyNamesByPrefix(prefix, true);\r\n    for (String accountRootPropName : accounts) {\r\n        String accountUID = configService.getString(accountRootPropName);\r\n        if (accountUID.equals(protocolProvider.getAccountID().getAccountUniqueID())) {\r\n            List<String> chatRooms = configService.getPropertyNamesByPrefix(accountRootPropName + \".chatRooms\", true);\r\n            for (String chatRoomPropName : chatRooms) {\r\n                String chatRoomID = configService.getString(chatRoomPropName);\r\n                if (!chatRoomId.equals(chatRoomID))\r\n                    continue;\r\n                if (value != null)\r\n                    configService.setProperty(chatRoomPropName + \".\" + property, value);\r\n                else\r\n                    configService.removeProperty(chatRoomPropName + \".\" + property);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.SourceUIContact.getAvatar",
	"Comment": "gets the avatar of a specific uicontact in the form of animageicon value.",
	"Method": "byte[] getAvatar(){\r\n    return sourceContact.getImage();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.msoutlook.calendar.CalendarServiceImpl.removeFromCurrentItems",
	"Comment": "removes calendaritemtimertask from the list of current tasks.",
	"Method": "void removeFromCurrentItems(CalendarItemTimerTask task){\r\n    synchronized (currentCalendarItems) {\r\n        currentCalendarItems.remove(task);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.keybindings.KeybindingSetImpl.invalidate",
	"Comment": "invalidates reference to custom output, preventing further writes.",
	"Method": "void invalidate(){\r\n    this.isInvalidated = true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactGroupImpl.getContactGroupsForProvider",
	"Comment": "returns all protocol specific contactgroups, encapsulated by thismetacontactgroup and coming from the indicated protocolproviderservice.if none of the contacts encapsulated by this metacontact is originatingfrom the specified provider then an empty iterator is returned.",
	"Method": "Iterator<ContactGroup> getContactGroupsForProvider(ProtocolProviderService provider){\r\n    Iterator<ContactGroup> encapsulatedGroups = getContactGroups();\r\n    LinkedList<ContactGroup> protGroups = new LinkedList<ContactGroup>();\r\n    while (encapsulatedGroups.hasNext()) {\r\n        ContactGroup group = encapsulatedGroups.next();\r\n        if (group.getProtocolProvider() == provider) {\r\n            protGroups.add(group);\r\n        }\r\n    }\r\n    return protGroups.iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.account.AccountStatusUtils.getProtocolPresenceOpSet",
	"Comment": "returns the presence operation set for the given protocol provider.",
	"Method": "OperationSetPresence getProtocolPresenceOpSet(ProtocolProviderService protocolProvider){\r\n    OperationSet opSet = protocolProvider.getOperationSet(OperationSetPresence.class);\r\n    return (opSet instanceof OperationSetPresence) ? (OperationSetPresence) opSet : null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.pluginmanager.PluginManagerActivator.start",
	"Comment": "starts this bundle and adds thepluginmanagerconfigform contained in it to the configurationwindow obtained from the uiservice.",
	"Method": "void start(BundleContext bc){\r\n    bundleContext = bc;\r\n    if (!getConfigurationService().getBoolean(DISABLED_PROP, false)) {\r\n        Dictionary<String, String> properties = new Hashtable<String, String>();\r\n        properties.put(ConfigurationForm.FORM_TYPE, ConfigurationForm.ADVANCED_TYPE);\r\n        bundleContext.registerService(ConfigurationForm.class.getName(), new LazyConfigurationForm(PluginManagerPanel.class.getName(), getClass().getClassLoader(), \"plugin.pluginmanager.PLUGIN_ICON\", \"plugin.pluginmanager.PLUGINS\", 1000, true), properties);\r\n    }\r\n    systemBundleNames = Arrays.asList(getConfigurationService().getString(SYSTEM_BUNDLES_PROP).split(\"\\\\s*,\\\\s*\"));\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.TestOperationSetPersistentPresence.postTestCreateGroup",
	"Comment": "creates a group in the server stored contact list, makes sure that thecorresponding event has been generated and verifies that the group isin the list.",
	"Method": "void postTestCreateGroup(){\r\n    fixture.clearProvidersLists();\r\n    Object o = new Object();\r\n    synchronized (o) {\r\n        o.wait(3000);\r\n    }\r\n    logger.trace(\"testing creation of server stored groups\");\r\n    GroupChangeCollector groupChangeCollector = new GroupChangeCollector();\r\n    opSetPersPresence1.addServerStoredGroupChangeListener(groupChangeCollector);\r\n    opSetPersPresence1.createServerStoredContactGroup(opSetPersPresence1.getServerStoredContactListRoot(), testGroupName);\r\n    groupChangeCollector.waitForEvent(10000);\r\n    opSetPersPresence1.removeServerStoredGroupChangeListener(groupChangeCollector);\r\n    assertEquals(\"Collected Group Change events: \", 1, groupChangeCollector.collectedEvents.size());\r\n    assertEquals(\"Group name.\", testGroupName, ((ServerStoredGroupEvent) groupChangeCollector.collectedEvents.get(0)).getSourceGroup().getGroupName());\r\n    ContactGroup group = opSetPersPresence1.getServerStoredContactListRoot().getGroup(testGroupName);\r\n    assertNotNull(\"A newly created group was not in the contact list.\", group);\r\n    assertEquals(\"New group name\", testGroupName, group.getGroupName());\r\n    try {\r\n        opSetPersPresence1.subscribe(group, fixture.userID2);\r\n        synchronized (o) {\r\n            o.wait(1500);\r\n        }\r\n    } catch (Exception ex) {\r\n        fail(\"error adding entry to group : \" + group.getGroupName() + \" \" + ex.getMessage());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.account.AccountList.serviceChanged",
	"Comment": "implements the servicelistener method. verifies whether thepassed event concerns a protocolproviderservice and adds thecorresponding ui controls.",
	"Method": "void serviceChanged(ServiceEvent event){\r\n    if (event.getServiceReference().getBundle().getState() == Bundle.STOPPING) {\r\n        return;\r\n    }\r\n    Object sourceService = GuiActivator.bundleContext.getService(event.getServiceReference());\r\n    if (!(sourceService instanceof ProtocolProviderService)) {\r\n        return;\r\n    }\r\n    ProtocolProviderService protocolProvider = (ProtocolProviderService) sourceService;\r\n    if (protocolProvider.getAccountID().isHidden() && protocolProvider.getAccountID().isConfigHidden())\r\n        return;\r\n    if (event.getType() == ServiceEvent.REGISTERED) {\r\n        OperationSetPresence presence = protocolProvider.getOperationSet(OperationSetPresence.class);\r\n        if (presence != null) {\r\n            presence.addProviderPresenceStatusListener(this);\r\n        }\r\n        addAccount(protocolProvider);\r\n    } else if (event.getType() == ServiceEvent.UNREGISTERING) {\r\n        removeAccount(protocolProvider);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.gibberish.TestOperationSetPresence.testQueryContactStatus",
	"Comment": "verifies that querying status works fine. the tester agent wouldchange status and the operation set would have to return the right statusafter every change.",
	"Method": "void testQueryContactStatus(){\r\n    Iterator<PresenceStatus> supportedStatusSetIter = operationSetPresence1.getSupportedStatusSet();\r\n    while (supportedStatusSetIter.hasNext()) {\r\n        PresenceStatus supportedStatus = supportedStatusSetIter.next();\r\n        logger.trace(\"Will test a transition to \" + supportedStatus.getStatusName());\r\n        subtestQueryContactStatus(supportedStatus);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.ConfigurationUtils.isTransparentWindowEnabled",
	"Comment": "returns true if transparent windows are enabled,false otherwise.",
	"Method": "boolean isTransparentWindowEnabled(){\r\n    return isTransparentWindowEnabled;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.SingleWindowContainer.setTabTitle",
	"Comment": "sets the given title to the tab opened for the given chat panel.",
	"Method": "void setTabTitle(ChatPanel chatPanel,String title){\r\n    int index = this.tabbedPane.indexOfComponent(chatPanel);\r\n    if (index > -1)\r\n        this.tabbedPane.setTitleAt(index, title);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.loggingutils.LogsCollector.collectHomeFolderLogs",
	"Comment": "collects all files from log folder except the lock file.and put them in the zip file as zip entries.",
	"Method": "void collectHomeFolderLogs(ZipOutputStream out){\r\n    try {\r\n        File[] fs = LoggingUtilsActivator.getFileAccessService().getPrivatePersistentDirectory(LOGGING_DIR_NAME, FileCategory.LOG).listFiles();\r\n        for (File f : fs) {\r\n            if (f.getName().endsWith(\".lck\"))\r\n                continue;\r\n            addFileToZip(f, out);\r\n        }\r\n    } catch (Exception e) {\r\n        logger.error(\"Error obtaining logs folder\", e);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetWhiteboardingJabberImpl.removeInvitationListener",
	"Comment": "removes listener from the list of invitation listenersregistered to receive invitation events.",
	"Method": "void removeInvitationListener(WhiteboardInvitationListener listener){\r\n    synchronized (invitationListeners) {\r\n        invitationListeners.remove(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockPersistentPresenceOperationSet.createUnresolvedContact",
	"Comment": "creates and returns a unresolved contact from the specifiedaddress and persistentdata. the method will not tryto establish a network connection and resolve the newly created contactagainst the server. the protocol provider may will later try and resolvethe contact. when this happens the corresponding event would notifyinterested subscription listeners.",
	"Method": "Contact createUnresolvedContact(String address,String persistentData,Contact createUnresolvedContact,String address,String persistentData,ContactGroup parent){\r\n    MockContact contact = new MockContact(address, parentProvider);\r\n    contact.setResolved(false);\r\n    ((MockContactGroup) parent).addContact(contact);\r\n    fireSubscriptionEvent(contact, parent, SubscriptionEvent.SUBSCRIPTION_CREATED);\r\n    return contact;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.IdentityManager.queryIdentity",
	"Comment": "issue whois query to discover identity as seen by the server.",
	"Method": "void queryIdentity(IRCApi irc,IIRCState state,WhoisListener listener){\r\n    new Thread() {\r\n        public void run() {\r\n            try {\r\n                irc.addListener(listener);\r\n                irc.rawMessage(\"WHOIS \" + state.getNickname());\r\n            } catch (final RuntimeException e) {\r\n                LOGGER.error(\"Failed to deliver WHOIS message.\", e);\r\n            }\r\n        }\r\n    }.start();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.IdentityManager.queryIdentity",
	"Comment": "issue whois query to discover identity as seen by the server.",
	"Method": "void queryIdentity(IRCApi irc,IIRCState state,WhoisListener listener){\r\n    try {\r\n        irc.addListener(listener);\r\n        irc.rawMessage(\"WHOIS \" + state.getNickname());\r\n    } catch (final RuntimeException e) {\r\n        LOGGER.error(\"Failed to deliver WHOIS message.\", e);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.LocalUserChatRoomPresenceChangeEvent.getAlternateAddress",
	"Comment": "an optional string indicating new address for the room, normallysend when room is destroyed.",
	"Method": "String getAlternateAddress(){\r\n    return alternateAddress;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ContactIcqImpl.getProtocolProvider",
	"Comment": "returns a reference to the protocol provider that created the contact.",
	"Method": "ProtocolProviderService getProtocolProvider(){\r\n    return ssclCallback.getParentProvider();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ContactListPane.messageDelivered",
	"Comment": "when a sent message is delivered shows it in the chat conversation panel.",
	"Method": "void messageDelivered(MessageDeliveredEvent evt){\r\n    Contact contact = evt.getDestinationContact();\r\n    MetaContact metaContact = GuiActivator.getContactListService().findMetaContactByContact(contact);\r\n    if (logger.isTraceEnabled())\r\n        logger.trace(\"MESSAGE DELIVERED to contact: \" + contact.getAddress());\r\n    ChatPanel chatPanel = chatWindowManager.getContactChat(metaContact, false);\r\n    if (chatPanel != null) {\r\n        Message msg = evt.getSourceMessage();\r\n        ProtocolProviderService protocolProvider = contact.getProtocolProvider();\r\n        if (logger.isTraceEnabled())\r\n            logger.trace(\"MESSAGE DELIVERED: process message to chat for contact: \" + contact.getAddress() + \" MESSAGE: \" + msg.getContent());\r\n        chatPanel.addMessage(this.mainFrame.getAccountAddress(protocolProvider), this.mainFrame.getAccountDisplayName(protocolProvider), evt.getTimestamp(), Chat.OUTGOING_MESSAGE, msg.getContent(), msg.getContentType(), msg.getMessageUID(), evt.getCorrectedMessageUID());\r\n        if (evt.isSmsMessage() && !ConfigurationUtils.isSmsNotifyTextDisabled()) {\r\n            chatPanel.addMessage(contact.getDisplayName(), new Date(), Chat.ACTION_MESSAGE, GuiActivator.getResources().getI18NString(\"service.gui.SMS_SUCCESSFULLY_SENT\"), \"text\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.sdp.SdpUtils.createDisablingAnswer",
	"Comment": "creates and returns a mediadescription in answer of thespecified offer that disables the corresponding stream bysetting a 0 port and keeping the original list of formats andeliminating all attributes.",
	"Method": "MediaDescription createDisablingAnswer(MediaDescription offer){\r\n    try {\r\n        String mediaType = offer.getMedia().getMediaType();\r\n        Vector<String> formatsVec = offer.getMedia().getMediaFormats(true);\r\n        if (formatsVec == null) {\r\n            formatsVec = new Vector<String>();\r\n            formatsVec.add(Integer.toString(0));\r\n        }\r\n        String[] formatsArray = new String[formatsVec.size()];\r\n        return sdpFactory.createMediaDescription(mediaType, 0, 1, offer.getMedia().getProtocol(), formatsVec.toArray(formatsArray));\r\n    } catch (Exception e) {\r\n        throw new IllegalArgumentException(\"Could not create a disabling answer\", e);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.IcqProtocolProviderSlick.start",
	"Comment": "start the icq sevice leveraging implementation compatibility kit.",
	"Method": "void start(BundleContext bundleContext){\r\n    setName(\"IcqProtocolProviderSlick\");\r\n    Hashtable<String, String> properties = new Hashtable<String, String>();\r\n    properties.put(\"service.pid\", getName());\r\n    IcqSlickFixture.bc = bundleContext;\r\n    String offlineMode = System.getProperty(DISABLE_ONLINE_TESTS_PROPERTY_NAME, null);\r\n    if (offlineMode != null && offlineMode.equalsIgnoreCase(\"true\"))\r\n        IcqSlickFixture.onlineTestingDisabled = true;\r\n    String icqTestAgentName = System.getProperty(TESTING_IMPL_USER_ID_PROP_NAME, null);\r\n    if (icqTestAgentName != null) {\r\n        IcqSlickFixture.testerAgent = new IcqTesterAgent(icqTestAgentName);\r\n        String icqTestAgentPwd = System.getProperty(TESTING_IMPL_PWD_PROP_NAME, null);\r\n        if (IcqSlickFixture.testerAgent.register(icqTestAgentPwd)) {\r\n            if (!IcqSlickFixture.onlineTestingDisabled) {\r\n                IcqSlickFixture.testerAgent.setAuthorizationRequired();\r\n                try {\r\n                    initializeTestedContactList();\r\n                } catch (Exception ex) {\r\n                    logger.error(\"Error initing of tester agent list\", ex);\r\n                }\r\n                String offlineMsgBody = \"This is a Test Message. \" + \"Supposed to be delivered as offline message!\";\r\n                IcqSlickFixture.offlineMsgCollector = new IcqSlickFixture.OfflineMsgCollector();\r\n                IcqSlickFixture.offlineMsgCollector.setMessageText(offlineMsgBody);\r\n                IcqSlickFixture.testerAgent.sendOfflineMessage(System.getProperty(TESTED_IMPL_USER_ID_PROP_NAME, null), offlineMsgBody);\r\n            }\r\n            addTest(TestAccountInstallation.suite());\r\n            addTest(TestProtocolProviderServiceIcqImpl.suite());\r\n            addTest(TestOperationSetPresence.suite());\r\n            if (!IcqSlickFixture.onlineTestingDisabled) {\r\n                addTest(TestOperationSetPersistentPresence.suite());\r\n                addTest(TestOperationSetBasicInstantMessaging.suite());\r\n                addTest(TestOperationSetTypingNotifications.suite());\r\n                addTest(TestOperationSetFileTransferImpl.suite());\r\n            }\r\n            addTest(TestAccountUninstallation.suite());\r\n            addTestSuite(TestAccountUninstallationPersistence.class);\r\n        } else {\r\n            addTest(new TestAccountInvalidNotification(\"failIcqTesterAgentRegisterRejected\"));\r\n        }\r\n    } else {\r\n        addTest(new TestAccountInvalidNotification(\"failIcqTesterAgentMissing\"));\r\n    }\r\n    bundleContext.registerService(getClass().getName(), this, properties);\r\n    logger.debug(\"Successfully registered \" + getClass().getName());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWritePanel.setEditorPaneBackground",
	"Comment": "sets the background of the write area to the specified color.",
	"Method": "void setEditorPaneBackground(Color color){\r\n    this.centerPanel.setBackground(color);\r\n    this.editorPane.setBackground(color);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.notificationconfiguration.NotificationEntry.setSoundPCSpeaker",
	"Comment": "method which set a boolean to true a sound is playing for thepc speaker.",
	"Method": "void setSoundPCSpeaker(boolean sound){\r\n    this.soundPCSpeaker = sound;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.account.AccountRegWizardContainerImpl.setDisabled",
	"Comment": "disables all editable components. used to enable readonly accountsto only show their values and forbid the user to edit.",
	"Method": "void setDisabled(Component[] components){\r\n    for (Component c : components) {\r\n        if (c instanceof JTextComponent)\r\n            ((JTextComponent) c).setEditable(false);\r\n        else if (c instanceof JComboBox || c instanceof AbstractButton)\r\n            c.setEnabled(false);\r\n        if (c instanceof Container)\r\n            setDisabled(((Container) c).getComponents());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.pluginmanager.TitlePanel.paintComponent",
	"Comment": "overrides the paintcomponent method of jpanelto paint a gradient background of this panel.",
	"Method": "void paintComponent(Graphics g){\r\n    super.paintComponent(g);\r\n    Graphics2D g2 = (Graphics2D) g;\r\n    GradientPaint p = new GradientPaint(this.getWidth() / 2, 0, GRADIENT_DARK_COLOR, this.getWidth() / 2, GRADIENT_SIZE, GRADIENT_LIGHT_COLOR);\r\n    GradientPaint p1 = new GradientPaint(this.getWidth() / 2, this.getHeight() - GRADIENT_SIZE, GRADIENT_LIGHT_COLOR, this.getWidth() / 2, this.getHeight(), GRADIENT_DARK_COLOR);\r\n    g2.setPaint(p);\r\n    g2.fillRect(0, 0, this.getWidth(), GRADIENT_SIZE);\r\n    g2.setColor(GRADIENT_LIGHT_COLOR);\r\n    g2.fillRect(0, GRADIENT_SIZE, this.getWidth(), this.getHeight() - GRADIENT_SIZE);\r\n    g2.setPaint(p1);\r\n    g2.fillRect(0, this.getHeight() - GRADIENT_SIZE - 1, this.getWidth(), this.getHeight() - 1);\r\n    g2.setColor(BORDER_COLOR);\r\n    g2.drawRoundRect(0, 0, this.getWidth() - 1, this.getHeight() - 1, 5, 5);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockContact.toString",
	"Comment": "returns a string representation of this contact, containing most of itsrepresentative details.",
	"Method": "String toString(){\r\n    StringBuffer buff = new StringBuffer(\"MockContact[ DisplayName=\").append(getDisplayName()).append(\"]\");\r\n    return buff.toString();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetTypingNotificationsIcqImpl.intToTypingState",
	"Comment": "converts the typingstate variable to its corresponding joustsimtypingstate instance",
	"Method": "TypingState intToTypingState(int typingState){\r\n    switch(typingState) {\r\n        case STATE_PAUSED:\r\n            return TypingState.PAUSED;\r\n        case STATE_TYPING:\r\n            return TypingState.TYPING;\r\n        case STATE_STOPPED:\r\n            return TypingState.NO_TEXT;\r\n    }\r\n    return TypingState.NO_TEXT;\r\n}"
}, {
	"Path": "com.keybox.manage.util.SSHUtil.distributePubKeysToUser",
	"Comment": "distributes public keys to all systems under all user profiles",
	"Method": "void distributePubKeysToUser(Long userId){\r\n    if (keyManagementEnabled) {\r\n        for (Profile profile : UserProfileDB.getProfilesByUser(userId)) {\r\n            List<HostSystem> hostSystemList = ProfileSystemsDB.getSystemsByProfile(profile.getId());\r\n            for (HostSystem hostSystem : hostSystemList) {\r\n                hostSystem = SSHUtil.authAndAddPubKey(hostSystem, null, null);\r\n                SystemDB.updateSystem(hostSystem);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomIrcImpl.revokeOwnership",
	"Comment": "revokes the ownership role for the participant given by address.",
	"Method": "void revokeOwnership(String address){\r\n    final IrcConnection connection = this.parentProvider.getIrcStack().getConnection();\r\n    if (connection == null) {\r\n        throw new IllegalStateException(\"Connection is not available.\");\r\n    }\r\n    connection.getChannelManager().revoke(this, address, Mode.OWNER);\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.AvatarCacheUtils.getCachedAvatar",
	"Comment": "returns the bytes of the avatar image stored for the accountcorresponding to the given protocol provider.",
	"Method": "byte[] getCachedAvatar(ProtocolProviderService protocolProvider,byte[] getCachedAvatar,Contact protocolContact){\r\n    String avatarPath = getCachedAvatarPath(protocolContact);\r\n    byte[] cachedAvatar = getLocallyStoredAvatar(avatarPath);\r\n    if ((cachedAvatar != null) && (cachedAvatar.length > 0))\r\n        return cachedAvatar;\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomJabberImpl.setPacketExtension",
	"Comment": "sets ext as the only packetextension that belongs togiven namespace of the packet.",
	"Method": "void setPacketExtension(Packet packet,PacketExtension extension,String namespace){\r\n    if (org.jitsi.util.StringUtils.isNullOrEmpty(namespace)) {\r\n        return;\r\n    }\r\n    PacketExtension pe;\r\n    while (null != (pe = packet.getExtension(namespace))) {\r\n        packet.removeExtension(pe);\r\n    }\r\n    if (extension != null) {\r\n        packet.addExtension(extension);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.FullUserInfoCmd.getUInt",
	"Comment": "extracts int from the given byte blockstarting from the specified position",
	"Method": "long getUInt(ByteBlock data,int pos){\r\n    if (data.getLength() - pos < 4) {\r\n        return -1;\r\n    }\r\n    return ((data.get(pos + 3) & 0xffL) << 24) | ((data.get(pos + 2) & 0xffL) << 16) | ((data.get(pos + 1) & 0xffL) << 8) | (data.get(pos) & 0xffL);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockChatRoom.removelocalUserRoleListener",
	"Comment": "removes a listener that was being notified of changes in our role in thischat room such as us being granded operator.",
	"Method": "void removelocalUserRoleListener(ChatRoomLocalUserRoleListener listener){\r\n    localUserRoleListeners.remove(listener);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.notificationwiring.NotificationManager.fireChatNotification",
	"Comment": "fires a chat message notification for the given event type through thenotificationservice.",
	"Method": "void fireChatNotification(Object chatContact,String eventType,String messageTitle,String message,String messageUID){\r\n    NotificationService notificationService = NotificationWiringActivator.getNotificationService();\r\n    if (notificationService == null)\r\n        return;\r\n    NotificationAction popupActionHandler = null;\r\n    UIService uiService = NotificationWiringActivator.getUIService();\r\n    Chat chatPanel = null;\r\n    byte[] contactIcon = null;\r\n    if (chatContact instanceof Contact) {\r\n        Contact contact = (Contact) chatContact;\r\n        if (uiService != null)\r\n            chatPanel = uiService.getChat(contact, messageUID);\r\n        contactIcon = contact.getImage();\r\n        if (contactIcon == null) {\r\n            contactIcon = NotificationWiringActivator.getImageLoaderService().getImageBytes(DEFAULT_USER_PHOTO);\r\n        }\r\n    } else if (chatContact instanceof ChatRoom) {\r\n        ChatRoom chatRoom = (ChatRoom) chatContact;\r\n        if (chatRoom.isSystem())\r\n            return;\r\n        if (uiService != null)\r\n            chatPanel = uiService.getChat(chatRoom);\r\n    }\r\n    if (chatPanel != null) {\r\n        if (eventType.equals(INCOMING_MESSAGE) && chatPanel.isChatFocused()) {\r\n            popupActionHandler = notificationService.getEventNotificationAction(eventType, NotificationAction.ACTION_POPUP_MESSAGE);\r\n            popupActionHandler.setEnabled(false);\r\n        }\r\n    }\r\n    Map<String, Object> extras = new HashMap<String, Object>();\r\n    extras.put(NotificationData.POPUP_MESSAGE_HANDLER_TAG_EXTRA, chatContact);\r\n    notificationService.fireNotification(eventType, messageTitle, message, contactIcon, extras);\r\n    if (popupActionHandler != null)\r\n        popupActionHandler.setEnabled(true);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chatroomslist.createforms.CreateChatRoomWizardPage2.pageHiding",
	"Comment": "before finishing the wizard sets the identifier entered by the userto the newchatroom object.",
	"Method": "void pageHiding(){\r\n    newChatRoom.setChatRoomName(namePanel.getChatRoomName());\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.contactlist.MetaContactListServiceLick.registerMockProviderService",
	"Comment": "registers the specified mock provider as an implementation of theprotocolproviderservice in the currently valid bundle context.",
	"Method": "ServiceRegistration registerMockProviderService(MockProvider provider){\r\n    System.setProperty(MetaContactListService.PROVIDER_MASK_PROPERTY, \"1\");\r\n    Hashtable<String, String> mockProvProperties = new Hashtable<String, String>();\r\n    mockProvProperties.put(MetaContactListService.PROVIDER_MASK_PROPERTY, \"1\");\r\n    ServiceRegistration osgiRegistration = MclSlickFixture.bundleContext.registerService(ProtocolProviderService.class.getName(), provider, mockProvProperties);\r\n    logger.debug(\"Registered a mock protocol provider!\");\r\n    return osgiRegistration;\r\n}"
}, {
	"Path": "org.eclipse.jetty.nosql.mongodb.MongoSessionDataStoreTest.testReadLegacySession",
	"Comment": "test that a session stored in the legacy attributeformat can be read.",
	"Method": "void testReadLegacySession(){\r\n    ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);\r\n    context.setContextPath(\"/legacy\");\r\n    SessionDataStoreFactory factory = createSessionDataStoreFactory();\r\n    ((AbstractSessionDataStoreFactory) factory).setGracePeriodSec(GRACE_PERIOD_SEC);\r\n    SessionDataStore store = factory.getSessionDataStore(context.getSessionHandler());\r\n    SessionContext sessionContext = new SessionContext(\"foo\", context.getServletContext());\r\n    store.initialize(sessionContext);\r\n    Map<String, Object> attributes = new HashMap();\r\n    attributes.put(\"attribute1\", \"attribute1value\");\r\n    attributes.put(\"attribute2\", new ArrayList<String>(Arrays.asList(\"1\", \"2\", \"3\")));\r\n    MongoTestHelper.createLegacySession(\"1234\", sessionContext.getCanonicalContextPath(), sessionContext.getVhost(), \"foo\", 1000L, System.currentTimeMillis() - 1000L, System.currentTimeMillis() - 2000L, -1, -1, attributes);\r\n    store.start();\r\n    SessionData loaded = store.load(\"1234\");\r\n    assertNotNull(loaded);\r\n    assertEquals(\"1234\", loaded.getId());\r\n    assertEquals(1000L, loaded.getCreated());\r\n    assertEquals(\"attribute1value\", loaded.getAttribute(\"attribute1\"));\r\n    assertNotNull(loaded.getAttribute(\"attribute2\"));\r\n    store.store(\"1234\", loaded);\r\n    MongoTestHelper.checkSessionPersisted(loaded);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.aimaccregwizz.AimAccountRegistrationWizard.getProtocolDescription",
	"Comment": "returns a short description of the protocol that will be shown on theright of the protocol name in the list, where user will choose theprotocol to register to.",
	"Method": "String getProtocolDescription(){\r\n    return Resources.getString(\"plugin.aimaccregwizz.PROTOCOL_DESCRIPTION\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chatroomslist.AdHocChatRoomListChangeEvent.toString",
	"Comment": "returns a string representation of this guiadhocchatroomevent.",
	"Method": "String toString(){\r\n    StringBuffer buff = new StringBuffer(\"GuiAdHocChatRoomEvent-[ AdHocChatRoomID=\");\r\n    buff.append(getSourceAdHocChatRoom().getAdHocChatRoomName());\r\n    buff.append(\", eventID=\").append(getEventID());\r\n    buff.append(\", ProtocolProvider=\");\r\n    return buff.toString();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.mailnotification.MailboxIQ.isTotalEstimate",
	"Comment": "determines whether the total of unread mail messages is an estimate ornot.",
	"Method": "boolean isTotalEstimate(){\r\n    return totalEstimate;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.authorization.AuthorizationHandlerImpl.processAuthorizationResponse",
	"Comment": "implements the authorizationhandler.processauthorizationresponsemethod.the method will be called any whenever someone acts upone an authorizationrequest that we have previously sent.",
	"Method": "void processAuthorizationResponse(AuthorizationResponse response,Contact sourceContact){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                processAuthorizationResponse(response, sourceContact);\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    AuthorizationResponseDialog dialog = new AuthorizationResponseDialog(mainFrame, sourceContact, response);\r\n    dialog.setVisible(true);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.authorization.AuthorizationHandlerImpl.processAuthorizationResponse",
	"Comment": "implements the authorizationhandler.processauthorizationresponsemethod.the method will be called any whenever someone acts upone an authorizationrequest that we have previously sent.",
	"Method": "void processAuthorizationResponse(AuthorizationResponse response,Contact sourceContact){\r\n    processAuthorizationResponse(response, sourceContact);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.StatusSelectorMenu.getProtocolProvider",
	"Comment": "returns the protocol provider associated with this status menu.",
	"Method": "ProtocolProviderService getProtocolProvider(){\r\n    return protocolProvider;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.history.HistoryServiceImpl.moveHistory",
	"Comment": "moves the content of oldid history to the content of the newid.moves the content from the oldid folder to the newid folder.old folder must exist.",
	"Method": "void moveHistory(HistoryID oldId,HistoryID newId){\r\n    if (!isHistoryCreated(oldId))\r\n        return;\r\n    File oldDir = this.createHistoryDirectories(oldId);\r\n    File newDir = getDirForHistory(newId);\r\n    newDir.getParentFile().mkdirs();\r\n    if (!oldDir.renameTo(newDir)) {\r\n        if (logger.isInfoEnabled())\r\n            logger.info(\"Cannot move history!\");\r\n        throw new IOException(\"Cannot move history!\");\r\n    }\r\n    histories.remove(oldId);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.PresenceStatusMenu.updateTitleArea",
	"Comment": "updates the current title area with the account display nameand its status.",
	"Method": "void updateTitleArea(){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                updateTitleArea();\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    titleArea.setText(protocolProvider.getAccountID().getDisplayName());\r\n    final String statusMessage = statusMessageMenu.getCurrentMessage();\r\n    if (StringUtils.isNullOrEmpty(statusMessage)) {\r\n        this.messageArea.setText(\"\");\r\n        this.messageArea.setVisible(false);\r\n    } else {\r\n        this.messageArea.setText(statusMessage);\r\n        this.messageArea.setVisible(true);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.PresenceStatusMenu.updateTitleArea",
	"Comment": "updates the current title area with the account display nameand its status.",
	"Method": "void updateTitleArea(){\r\n    updateTitleArea();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.customcontrols.wizard.WizardController.actionPerformed",
	"Comment": "calling method for the action listener interface. this class listens foractions performed by the buttons in the wizard class, and calls methodsbelow to determine the correct course of action.",
	"Method": "void actionPerformed(java.awt.event.ActionEvent evt){\r\n    if (evt.getActionCommand().equals(Wizard.CANCEL_BUTTON_ACTION_COMMAND))\r\n        cancelButtonPressed();\r\n    else if (evt.getActionCommand().equals(Wizard.BACK_BUTTON_ACTION_COMMAND))\r\n        backButtonPressed();\r\n    else if (evt.getActionCommand().equals(Wizard.NEXT_BUTTON_ACTION_COMMAND))\r\n        nextButtonPressed();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetServerStoredAccountInfoSipImpl.isDetailClassEditable",
	"Comment": "determines whether the underlying implementation supports the editionof this detail class.",
	"Method": "boolean isDetailClassEditable(Class<? extends GenericDetail> detailClass){\r\n    return isDetailClassSupported(detailClass) && ImageDetail.class.isAssignableFrom(detailClass);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.certconfig.CertConfigEntryDialog.loadAliases",
	"Comment": "load the certificate entry aliases from the chosen keystore.",
	"Method": "void loadAliases(){\r\n    String currentDisplayName = txtDisplayName.getText();\r\n    String currentAlias = cboAlias.getSelectedItem() == null ? null : cboAlias.getSelectedItem().toString();\r\n    try {\r\n        cboAlias.removeAllItems();\r\n        Enumeration<String> e = keyStore.aliases();\r\n        while (e.hasMoreElements()) {\r\n            cboAlias.addItem(e.nextElement());\r\n        }\r\n        if ((StringUtils.isNullOrEmpty(currentDisplayName) || (currentDisplayName != null && currentDisplayName.equals(currentAlias))) && cboAlias.getSelectedItem() != null) {\r\n            txtDisplayName.setText(cboAlias.getSelectedItem().toString());\r\n        }\r\n    } catch (KeyStoreException e) {\r\n        cboAlias.removeAllItems();\r\n        logger.error(\"Unable to obtain aliases from keystore\", e);\r\n        showGenericError(\"plugin.certconfig.ALIAS_LOAD_EXCEPTION\", e);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.SubscriptionEvent.toString",
	"Comment": "returns a string representation of this contactpresencestatuschangeevent",
	"Method": "String toString(){\r\n    StringBuffer buff = new StringBuffer(\"SubscriptionEvent-[ ContactID=\");\r\n    buff.append(getSourceContact().getAddress());\r\n    buff.append(\", eventID=\").append(getEventID());\r\n    if (getParentGroup() != null)\r\n        buff.append(\", ParentGroup=\").append(getParentGroup().getGroupName());\r\n    return buff.toString();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.netaddr.NetworkEventDispatcher.isRunning",
	"Comment": "returns true if this dispatcher is currently running anddelivering events when available and falseotherwise.",
	"Method": "boolean isRunning(){\r\n    return !stopped;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.RecordButton.isSupportedFormat",
	"Comment": "determines whether a specific format is supported by therecorder represented by this recordbutton.",
	"Method": "boolean isSupportedFormat(File file,boolean isSupportedFormat,String format){\r\n    Recorder recorder;\r\n    try {\r\n        recorder = getRecorder();\r\n    } catch (OperationFailedException ofex) {\r\n        logger.error(\"Failed to get Recorder\", ofex);\r\n        return false;\r\n    }\r\n    List<String> supportedFormats = recorder.getSupportedFormats();\r\n    return (supportedFormats != null) && supportedFormats.contains(format);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.gibberish.TestOperationSetPersistentPresence.postTestRenameGroup",
	"Comment": "renames our test group and checks whether corresponding events aretriggered. verifies whether the group has really changed its name andwhether it is findable by its new name. also makes sure that it doesnot exist under its previous name any more.",
	"Method": "void postTestRenameGroup(){\r\n    logger.trace(\"Testing renaming groups.\");\r\n    ContactGroup group = opSetPersPresence1.getServerStoredContactListRoot().getGroup(testGroupName);\r\n    GroupChangeCollector groupChangeCollector = new GroupChangeCollector();\r\n    opSetPersPresence1.addServerStoredGroupChangeListener(groupChangeCollector);\r\n    opSetPersPresence1.renameServerStoredContactGroup(group, testGroupName2);\r\n    groupChangeCollector.waitForEvent(10000);\r\n    opSetPersPresence1.removeServerStoredGroupChangeListener(groupChangeCollector);\r\n    assertEquals(\"Collected Group Change event\", 1, groupChangeCollector.collectedEvents.size());\r\n    assertEquals(\"Group name.\", testGroupName2, ((ServerStoredGroupEvent) groupChangeCollector.collectedEvents.get(0)).getSourceGroup().getGroupName());\r\n    ContactGroup oldGroup = opSetPersPresence1.getServerStoredContactListRoot().getGroup(testGroupName);\r\n    assertNull(\"A group was still findable by its old name after renaming.\", oldGroup);\r\n    ContactGroup newGroup = opSetPersPresence1.getServerStoredContactListRoot().getGroup(testGroupName2);\r\n    assertNotNull(\"Could not find a renamed group by its new name.\", newGroup);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipActivator.getVersionService",
	"Comment": "returns a reference to a versionservice implementation currently registeredin the bundle context or null if no such implementation was found.",
	"Method": "VersionService getVersionService(){\r\n    if (versionService == null) {\r\n        ServiceReference versionServiceReference = bundleContext.getServiceReference(VersionService.class.getName());\r\n        versionService = (VersionService) bundleContext.getService(versionServiceReference);\r\n    }\r\n    return versionService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.contactlist.event.MetaContactRenamedEvent.getOldDisplayName",
	"Comment": "returns the display name of the source meta contact as it was now, beforethe change.",
	"Method": "String getOldDisplayName(){\r\n    return (String) getOldValue();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatConversationPanel.findFirstElement",
	"Comment": "finds the first element with name among the child elements ofelement.",
	"Method": "Element findFirstElement(String name,Element findFirstElement,Element element,HTML.Attribute attrName,String[] matchStrings,Element findFirstElement,Element element,String name){\r\n    if (element.getName().equalsIgnoreCase(name))\r\n        return element;\r\n    Element resultElement = null;\r\n    for (int i = 0; i < element.getElementCount(); i++) {\r\n        resultElement = findFirstElement(element.getElement(i), name);\r\n        if (resultElement != null)\r\n            return resultElement;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomIrcImpl.updateChatRoomMemberName",
	"Comment": "update the chatroommember instance. when the nick changes, the chat roommember is still stored under the old nick. find the instance under itsold nick and reinsert it into the map according to the current nick name.",
	"Method": "void updateChatRoomMemberName(String oldName){\r\n    synchronized (this.chatRoomMembers) {\r\n        ChatRoomMember member = this.chatRoomMembers.remove(oldName);\r\n        if (member != null) {\r\n            this.chatRoomMembers.put(member.getContactAddress(), member);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.update.UpdateActivator.getUIService",
	"Comment": "returns a reference to the uiservice implementation currently registeredin the bundle context or null if no such implementation was found.",
	"Method": "UIService getUIService(){\r\n    if (uiService == null)\r\n        uiService = ServiceUtils.getService(bundleContext, UIService.class);\r\n    return uiService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.whiteboard.WhiteboardSessionManager.whiteboardObjectDelivered",
	"Comment": "called when the underlying implementation has received an indicationthat a whiteboardobject, sent earlier has been successfullyreceived by the destination.",
	"Method": "void whiteboardObjectDelivered(WhiteboardObjectDeliveredEvent evt){\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"WBObjectDeliveredEvent: The following object: \" + evt.getSourceWhiteboardObject() + \" has been delivered to \" + evt.getDestinationContact().getDisplayName());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.globaldisplaydetails.GlobalStatusServiceImpl.getPresenceStatus",
	"Comment": "returns the jcheckboxmenuitem corresponding to the given status.for status constants we use here the values defined in thepresencestatus, but this is only for convenience.",
	"Method": "PresenceStatus getPresenceStatus(int status,PresenceStatus getPresenceStatus,ProtocolProviderService protocolProvider,int floorStatusValue,int ceilStatusValue){\r\n    OperationSetPresence presence = protocolProvider.getOperationSet(OperationSetPresence.class);\r\n    if (presence == null)\r\n        return null;\r\n    Iterator<PresenceStatus> statusSet = presence.getSupportedStatusSet();\r\n    PresenceStatus status = null;\r\n    while (statusSet.hasNext()) {\r\n        PresenceStatus currentStatus = statusSet.next();\r\n        if (status == null && currentStatus.getStatus() < ceilStatusValue && currentStatus.getStatus() >= floorStatusValue) {\r\n            status = currentStatus;\r\n        }\r\n        if (status != null) {\r\n            if (currentStatus.getStatus() < ceilStatusValue && currentStatus.getStatus() >= floorStatusValue && currentStatus.getStatus() > status.getStatus()) {\r\n                status = currentStatus;\r\n            }\r\n        }\r\n    }\r\n    return status;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.AbstractOperationSetBasicTelephony.setMute",
	"Comment": "sets the mute state of the call.muting audio streams sent from the call is implementation specificand one of the possible approaches to it is sending silence.",
	"Method": "void setMute(Call call,boolean mute){\r\n    if (call instanceof MediaAwareCall)\r\n        ((MediaAwareCall<?, ?, ?>) call).setMute(mute);\r\n    else {\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.login.LoginRendererSwingImpl.protocolProviderConnected",
	"Comment": "indicates that the given protocol provider is now connected.",
	"Method": "void protocolProviderConnected(ProtocolProviderService protocolProvider,long date){\r\n    OperationSetPresence presence = AccountStatusUtils.getProtocolPresenceOpSet(protocolProvider);\r\n    OperationSetMultiUserChat multiUserChat = MUCService.getMultiUserChatOpSet(protocolProvider);\r\n    if (presence != null) {\r\n        presence.setAuthorizationHandler(new AuthorizationHandlerImpl(mainFrame));\r\n    }\r\n    MUCService mucService;\r\n    if (multiUserChat != null && (mucService = GuiActivator.getMUCService()) != null) {\r\n        mucService.synchronizeOpSetWithLocalContactList(protocolProvider, multiUserChat);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommTextField.keyPressed",
	"Comment": "clears the default text when a key pressed event is received.",
	"Method": "void keyPressed(KeyEvent e){\r\n    clearDefaultText();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageHistoryServiceImpl.getCurrentlyAvailableProviders",
	"Comment": "returns currently registered in osgi protocolproviderservices.",
	"Method": "List<ProtocolProviderService> getCurrentlyAvailableProviders(){\r\n    List<ProtocolProviderService> res = new ArrayList<ProtocolProviderService>();\r\n    ServiceReference[] protocolProviderRefs = null;\r\n    try {\r\n        protocolProviderRefs = bundleContext.getServiceReferences(ProtocolProviderService.class.getName(), null);\r\n    } catch (InvalidSyntaxException ex) {\r\n        logger.error(\"Error while retrieving service refs\", ex);\r\n        return res;\r\n    }\r\n    if (protocolProviderRefs != null) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Found \" + protocolProviderRefs.length + \" already installed providers.\");\r\n        for (int i = 0; i < protocolProviderRefs.length; i++) {\r\n            ProtocolProviderService provider = (ProtocolProviderService) bundleContext.getService(protocolProviderRefs[i]);\r\n            res.add(provider);\r\n        }\r\n    }\r\n    return res;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWindow.isFrameActive",
	"Comment": "indicates if the parent frame is currently the active window.",
	"Method": "boolean isFrameActive(){\r\n    return isActive();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.whiteboard.gui.whiteboardshapes.WhiteboardShapePath.setPoints",
	"Comment": "sets the list of whiteboardpoint instances that thiswhiteboardobject is composed of.",
	"Method": "void setPoints(List<WhiteboardPoint> points){\r\n    this.points = new ArrayList<WhiteboardPoint>(points);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ClientConfigImpl.setProxy",
	"Comment": "set a new proxy instance.the proxy may be null signaling that a proxy connection is notnecessary.",
	"Method": "void setProxy(Proxy proxy){\r\n    this.proxy = proxy;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.spellcheck.SpellChecker.getLocale",
	"Comment": "provides the locale of the dictionary currently being used by the spellchecker.",
	"Method": "Parameters.Locale getLocale(){\r\n    synchronized (this.locale) {\r\n        return this.locale;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.isGreyHistoryStyleDisabled",
	"Comment": "indicates if the history of a hidden protocol should be shown to theuser in the default grey history style or it should be shown asa normal message.",
	"Method": "boolean isGreyHistoryStyleDisabled(ProtocolProviderService protocolProvider){\r\n    boolean isProtocolHidden = protocolProvider.getAccountID().isHidden();\r\n    boolean isGreyHistoryDisabled = false;\r\n    String greyHistoryProperty = GuiActivator.getResources().getSettingsString(\"impl.gui.GREY_HISTORY_ENABLED\");\r\n    if (greyHistoryProperty != null)\r\n        isGreyHistoryDisabled = Boolean.parseBoolean(greyHistoryProperty);\r\n    return isProtocolHidden && isGreyHistoryDisabled;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.UIServiceImpl.getLocation",
	"Comment": "returns the current location of the main application window. the returnedpoint is the top left corner of the window.",
	"Method": "Point getLocation(){\r\n    return mainFrame.getLocation();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.ContactGibberishImpl.getParentPresenceOperationSet",
	"Comment": "returns the persistent presence operation set that this contact belongsto.",
	"Method": "OperationSetPersistentPresenceGibberishImpl getParentPresenceOperationSet(){\r\n    return (OperationSetPersistentPresenceGibberishImpl) parentProvider.getOperationSet(OperationSetPersistentPresence.class);\r\n}"
}, {
	"Path": "io.lettuce.core.cluster.event.ClusterTopologyChangedEvent.before",
	"Comment": "returns the cluster topology view before the topology changed.",
	"Method": "List<RedisClusterNode> before(){\r\n    return before;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageSourceContactQuery.updateContactDisplayName",
	"Comment": "notifies the contactquerylisteners registered with thiscontactquery that a sourcecontact has beenchanged.note that object may not be messagesourcecontact, but itsequals method can return true for message source contact instances.",
	"Method": "void updateContactDisplayName(Object srcObj,String newName){\r\n    for (SourceContact msc : getQueryResults()) {\r\n        if (srcObj.equals(msc) && msc instanceof MessageSourceContact) {\r\n            ((MessageSourceContact) msc).setDisplayName(newName);\r\n            super.fireContactChanged(msc);\r\n            break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.BaseChatRoomSourceContact.initContactProperties",
	"Comment": "sets the given presence status and the name of the chat room associatedwith the contact.",
	"Method": "void initContactProperties(PresenceStatus status){\r\n    setPresenceStatus(status);\r\n    setContactAddress(chatRoomName);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.sysactivity.NetworkManagerListenerImpl.isConnected",
	"Comment": "whether we are connected to the network manager through dbus.",
	"Method": "boolean isConnected(){\r\n    return dbusConn != null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.history.HistoryReaderImpl.findByPeriod",
	"Comment": "searches for all history records containing all keywords,with timestamp between startdate and enddate.",
	"Method": "QueryResultSet<HistoryRecord> findByPeriod(Date startDate,Date endDate,QueryResultSet<HistoryRecord> findByPeriod,Date startDate,Date endDate,String[] keywords,String field,QueryResultSet<HistoryRecord> findByPeriod,Date startDate,Date endDate,String[] keywords,String field,boolean caseSensitive){\r\n    return find(startDate, endDate, keywords, field, caseSensitive);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.conference.ConferenceFocusPanel.setErrorReason",
	"Comment": "sets the reason of a call failure if one occurs. the renderer shoulddisplay this reason to the user.",
	"Method": "void setErrorReason(String reason){\r\n    focusPeerPanel.setErrorReason(reason);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.ConnectionPanel.initCertificateAliases",
	"Comment": "initializes the certificate combo box with certificate names",
	"Method": "void initCertificateAliases(String id){\r\n    certificate.removeAllItems();\r\n    certificate.insertItemAt(Resources.getString(\"plugin.sipaccregwizz.NO_CERTIFICATE\"), 0);\r\n    certificate.setSelectedIndex(0);\r\n    for (CertificateConfigEntry e : JabberAccRegWizzActivator.getCertificateService().getClientAuthCertificateConfigs()) {\r\n        certificate.addItem(e);\r\n        if (e.getId().equals(id))\r\n            certificate.setSelectedItem(e);\r\n    }\r\n}"
}, {
	"Path": "net.librec.recommender.ext.SlopeOneTestCase.testRecommender",
	"Comment": "test the whole process of prankdrecommender recommendation",
	"Method": "void testRecommender(){\r\n    Configuration.Resource resource = new Configuration.Resource(\"rec/ext/slopeone-test.properties\");\r\n    conf.addResource(resource);\r\n    RecommenderJob job = new RecommenderJob(conf);\r\n    job.runJob();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.generalconfig.autoaway.AutoAwayWatcher.stopListeningForNewProviders",
	"Comment": "stop listening for new providers and their registration states.",
	"Method": "void stopListeningForNewProviders(){\r\n    GeneralConfigPluginActivator.bundleContext.removeServiceListener(this);\r\n    ServiceReference[] protocolProviderRefs = null;\r\n    try {\r\n        protocolProviderRefs = GeneralConfigPluginActivator.bundleContext.getServiceReferences(ProtocolProviderService.class.getName(), null);\r\n    } catch (InvalidSyntaxException ex) {\r\n        logger.error(\"Error while retrieving service refs\", ex);\r\n        return;\r\n    }\r\n    if (protocolProviderRefs != null) {\r\n        for (int i = 0; i < protocolProviderRefs.length; i++) {\r\n            ProtocolProviderService provider = (ProtocolProviderService) GeneralConfigPluginActivator.bundleContext.getService(protocolProviderRefs[i]);\r\n            this.handleProviderRemoved(provider);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl.getSipSecurityManager",
	"Comment": "reurns the currently valid sip security manager that everyone shoulduse to authenticate sip requests.",
	"Method": "SipSecurityManager getSipSecurityManager(){\r\n    return sipSecurityManager;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.GroupNode.sortedAddContact",
	"Comment": "creates a contactnode for the given uicontact,adds it to this group and performs a sort at the end.",
	"Method": "ContactNode sortedAddContact(UIContactImpl uiContact){\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Group node sorted add contact: \" + uiContact.getDisplayName());\r\n    ContactNode contactNode = new ContactNode(uiContact);\r\n    uiContact.setContactNode(contactNode);\r\n    if (children == null) {\r\n        add(contactNode);\r\n        fireNodeInserted(0);\r\n    } else {\r\n        final int insertionPoint = Collections.binarySearch(children, contactNode, nodeComparator);\r\n        if (insertionPoint < 0) {\r\n            final int index = (insertionPoint + 1) * -1;\r\n            insert(contactNode, index);\r\n            fireNodeInserted(index);\r\n        }\r\n    }\r\n    return contactNode;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomJabberImpl.getMembers",
	"Comment": "returns a list of members corresponding to allmembers currently participating in this room.",
	"Method": "List<ChatRoomMember> getMembers(){\r\n    synchronized (members) {\r\n        return new LinkedList<ChatRoomMember>(members.values());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.Resources.getMnemonic",
	"Comment": "returns an internationalized string corresponding to the given key.",
	"Method": "char getMnemonic(String key){\r\n    return getResources().getI18nMnemonic(key);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.ShowMoreContact.getContactDetailsForOperationSet",
	"Comment": "returns null to indicate that this contact has no contact details.",
	"Method": "List<UIContactDetail> getContactDetailsForOperationSet(Class<? extends OperationSet> opSetClass){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ServerChannelLister.createCleanUpJob",
	"Comment": "create a clean up job that checks the container after the cache hasexpired. if the container is still populated, then remove it. this cleanup makes sure that there are no references left to an otherwise uselessoutdated list of channels.",
	"Method": "void createCleanUpJob(Container<List<String>> channellist){\r\n    final Timer cleanUpJob = new Timer();\r\n    final long timestamp = channellist.getTimestamp();\r\n    cleanUpJob.schedule(new ChannelListCacheCleanUpTask(channellist, timestamp), CHAT_ROOM_LIST_CACHE_EXPIRATION / RATIO_MILLISECONDS_TO_NANOSECONDS + CACHE_CLEAN_UP_DELAY);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactImpl.removeContactsForProvider",
	"Comment": "removes all proto contacts that belong to the specified provider.",
	"Method": "boolean removeContactsForProvider(ProtocolProviderService provider){\r\n    boolean modified = false;\r\n    Iterator<Contact> contactsIter = protoContacts.iterator();\r\n    while (contactsIter.hasNext()) {\r\n        Contact contact = contactsIter.next();\r\n        if (contact.getProtocolProvider() == provider) {\r\n            contactsIter.remove();\r\n            modified = true;\r\n        }\r\n    }\r\n    if (modified && !protoContacts.contains(defaultContact)) {\r\n        defaultContact = null;\r\n    }\r\n    return modified;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.credentialsstorage.TestCredentialsStorageService.testLoadPassword",
	"Comment": "tests whether the loaded password is the same as the stored one.",
	"Method": "void testLoadPassword(){\r\n    String loadedPassword = credentialsService.loadPassword(accountPrefix);\r\n    assertEquals(\"Loaded and stored passwords do not match\", accountPassword, loadedPassword);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.EventPackageSupport.addSubscription",
	"Comment": "adds a specific subscription associated with a specific callidto the list of subscriptions managed by this instance.",
	"Method": "void addSubscription(String callId,Subscription subscription){\r\n    synchronized (subscriptions) {\r\n        Subscription existingSubscription = subscriptions.get(callId);\r\n        if (existingSubscription != null)\r\n            removeSubscription(callId, existingSubscription);\r\n        subscriptions.put(callId, subscription);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl.processResponse",
	"Comment": "analyzes the incoming responseevent and then forwards it to theproper event handler.",
	"Method": "boolean processResponse(ResponseEvent responseEvent){\r\n    ClientTransaction clientTransaction = responseEvent.getClientTransaction();\r\n    Response response = responseEvent.getResponse();\r\n    CSeqHeader cseq = ((CSeqHeader) response.getHeader(CSeqHeader.NAME));\r\n    if (cseq == null) {\r\n        logger.error(\"An incoming response did not contain a CSeq header\");\r\n        return false;\r\n    }\r\n    String method = cseq.getMethod();\r\n    SipProvider sourceProvider = (SipProvider) responseEvent.getSource();\r\n    int responseStatusCode = response.getStatusCode();\r\n    boolean processed = false;\r\n    switch(responseStatusCode) {\r\n        case Response.OK:\r\n            if (method.equals(Request.INVITE)) {\r\n                processInviteOK(clientTransaction, response);\r\n                processed = true;\r\n            }\r\n            break;\r\n        case Response.RINGING:\r\n            processRinging(clientTransaction, response);\r\n            processed = true;\r\n            break;\r\n        case Response.SESSION_PROGRESS:\r\n            processSessionProgress(clientTransaction, response);\r\n            processed = true;\r\n            break;\r\n        case Response.TRYING:\r\n            processTrying(clientTransaction, response);\r\n            processed = true;\r\n            break;\r\n        case Response.BUSY_HERE:\r\n        case Response.BUSY_EVERYWHERE:\r\n        case Response.DECLINE:\r\n            processBusyHere(clientTransaction, response);\r\n            processed = true;\r\n            break;\r\n        case Response.ACCEPTED:\r\n            if (Request.REFER.equals(method)) {\r\n                processReferAccepted(clientTransaction, response);\r\n                processed = true;\r\n            }\r\n            break;\r\n        case Response.UNAUTHORIZED:\r\n        case Response.PROXY_AUTHENTICATION_REQUIRED:\r\n            processAuthenticationChallenge(clientTransaction, response, sourceProvider);\r\n            processed = true;\r\n            break;\r\n        case Response.REQUEST_TERMINATED:\r\n            {\r\n                CallPeerSipImpl callPeer = activeCallsRepository.findCallPeer(clientTransaction.getDialog());\r\n                if (callPeer != null) {\r\n                    String reasonPhrase = response.getReasonPhrase();\r\n                    if (reasonPhrase == null || reasonPhrase.trim().length() == 0)\r\n                        reasonPhrase = \"Request terminated by server!\";\r\n                    callPeer.setState(CallPeerState.FAILED, reasonPhrase);\r\n                }\r\n                processed = true;\r\n            }\r\n            break;\r\n        case Response.MOVED_TEMPORARILY:\r\n        case Response.MOVED_PERMANENTLY:\r\n            {\r\n                CallPeerSipImpl callPeer = activeCallsRepository.findCallPeer(clientTransaction.getDialog());\r\n                if (callPeer == null) {\r\n                    logger.error(\"Failed to find a forwarded call peer.\");\r\n                    return true;\r\n                }\r\n                ContactHeader contactHeader = (ContactHeader) response.getHeader(ContactHeader.NAME);\r\n                if (contactHeader == null) {\r\n                    logger.error(\"Received a forward with no Contact \" + \"destination: \" + response.getStatusCode() + \" \" + response.getReasonPhrase());\r\n                    callPeer.setState(CallPeerState.FAILED, response.getReasonPhrase());\r\n                    return true;\r\n                }\r\n                Address redirectAddress = contactHeader.getAddress();\r\n                if (callPeer.getPeerAddress().getURI().equals(redirectAddress.getURI())) {\r\n                    logger.error(\"Redirect loop detected for: \" + callPeer.getPeerAddress().getURI());\r\n                    callPeer.setState(CallPeerState.FAILED, \"Redirect loop detected for: \" + callPeer.getPeerAddress().getURI());\r\n                    return true;\r\n                }\r\n                CallSipImpl call = callPeer.getCall();\r\n                try {\r\n                    call.invite(redirectAddress, null);\r\n                } catch (OperationFailedException exc) {\r\n                    logger.error(\"Call forward failed for address \" + contactHeader.getAddress(), exc);\r\n                    callPeer.setState(CallPeerState.DISCONNECTED, \"Call forwarded failed. \" + exc.getMessage());\r\n                }\r\n                callPeer.setState(CallPeerState.DISCONNECTED, \"Call forwarded. \" + response.getReasonPhrase());\r\n                processed = true;\r\n            }\r\n            break;\r\n        default:\r\n            int responseStatusCodeRange = responseStatusCode / 100;\r\n            Request request = responseEvent.getClientTransaction().getRequest();\r\n            if (responseStatusCode == 500 && isRemoteControlNotification(request)) {\r\n                return true;\r\n            }\r\n            CallPeerSipImpl callPeer = activeCallsRepository.findCallPeer(clientTransaction.getDialog());\r\n            if ((responseStatusCodeRange == 4) || (responseStatusCodeRange == 5) || (responseStatusCodeRange == 6)) {\r\n                String reason = response.getReasonPhrase();\r\n                WarningHeader warningHeader = (WarningHeader) response.getHeader(WarningHeader.NAME);\r\n                if (warningHeader != null) {\r\n                    reason = warningHeader.getText();\r\n                    logger.error(\"Received error: \" + response.getStatusCode() + \" \" + response.getReasonPhrase() + \" \" + warningHeader.getText() + \"-\" + warningHeader.getAgent() + \"-\" + warningHeader.getName());\r\n                } else {\r\n                    logger.error(\"Received error: \" + response.getStatusCode() + \" \" + response.getReasonPhrase());\r\n                }\r\n                if (callPeer != null)\r\n                    callPeer.setState(CallPeerState.FAILED, reason);\r\n                processed = true;\r\n            } else if ((responseStatusCodeRange == 2) || (responseStatusCodeRange == 3)) {\r\n                logger.error(\"Received an non-supported final response: \" + response.getStatusCode() + \" \" + response.getReasonPhrase());\r\n                if (callPeer != null)\r\n                    callPeer.setState(CallPeerState.FAILED, response.getReasonPhrase());\r\n                processed = true;\r\n            }\r\n            break;\r\n    }\r\n    return processed;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.appendChatMessage",
	"Comment": "passes the message to the contained chatconversationpanelfor processing and appends it at the end of the conversationpaneldocument.",
	"Method": "void appendChatMessage(ChatMessage chatMessage){\r\n    String keyword = null;\r\n    if (chatSession instanceof ConferenceChatSession && Chat.INCOMING_MESSAGE.equals(chatMessage.getMessageType())) {\r\n        keyword = ((ChatRoomWrapper) chatSession.getDescriptor()).getChatRoom().getUserNickname();\r\n    }\r\n    String processedMessage = this.conversationPanel.processMessage(chatMessage, keyword, chatSession.getCurrentChatTransport().getProtocolProvider(), chatSession.getCurrentChatTransport().getName());\r\n    if (chatSession instanceof ConferenceChatSession) {\r\n        String meCommandMsg = this.conversationPanel.processMeCommand(chatMessage);\r\n        if (meCommandMsg.length() > 0)\r\n            processedMessage = meCommandMsg;\r\n    }\r\n    this.conversationPanel.appendMessageToEnd(processedMessage, ChatHtmlUtils.HTML_CONTENT_TYPE);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.notificationconfiguration.NotificationEntry.setProgramFile",
	"Comment": "method which assigns the program filename for the notification.",
	"Method": "void setProgramFile(String programFile){\r\n    this.programFile = programFile;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommTextArea.mousePressed",
	"Comment": "indicates that the mouse button was pressed on this component. hidesthe default text when user clicks on the text field.",
	"Method": "void mousePressed(MouseEvent e){\r\n    if (getText() == null) {\r\n        clearDefaultText();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.MetaContactChatTransport.sendFile",
	"Comment": "sends the given file through this chat transport file transfer operationset.",
	"Method": "FileTransfer sendFile(File file,FileTransfer sendFile,File file,boolean isMultimediaMessage){\r\n    if (!allowsFileTransfer())\r\n        return null;\r\n    if (FileUtils.isImage(file.getName())) {\r\n        OperationSetThumbnailedFileFactory tfOpSet = contact.getProtocolProvider().getOperationSet(OperationSetThumbnailedFileFactory.class);\r\n        if (tfOpSet != null) {\r\n            byte[] thumbnail = getFileThumbnail(file);\r\n            if (thumbnail != null && thumbnail.length > 0) {\r\n                file = tfOpSet.createFileWithThumbnail(file, THUMBNAIL_WIDTH, THUMBNAIL_HEIGHT, \"image/png\", thumbnail);\r\n            }\r\n        }\r\n    }\r\n    if (isMultimediaMessage) {\r\n        OperationSetSmsMessaging smsOpSet = contact.getProtocolProvider().getOperationSet(OperationSetSmsMessaging.class);\r\n        if (smsOpSet == null)\r\n            return null;\r\n        return smsOpSet.sendMultimediaFile(contact, file);\r\n    } else {\r\n        OperationSetFileTransfer ftOpSet = contact.getProtocolProvider().getOperationSet(OperationSetFileTransfer.class);\r\n        return ftOpSet.sendFile(contact, file);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.SmileysSelectorBox.isMenuSelected",
	"Comment": "returns true if the selector box is opened, otherwise returns false.",
	"Method": "boolean isMenuSelected(){\r\n    return isPopupMenuVisible();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.netaddr.NetworkAddressManagerServiceImpl.initRandomPortSocket",
	"Comment": "initializes and binds a socket that on a random port number. the methodwould try to bind on a random port and retry 5 times until a free portis found.",
	"Method": "DatagramSocket initRandomPortSocket(){\r\n    DatagramSocket resultSocket = null;\r\n    String bindRetriesStr = NetaddrActivator.getConfigurationService().getString(BIND_RETRIES_PROPERTY_NAME);\r\n    int bindRetries = 5;\r\n    if (bindRetriesStr != null) {\r\n        try {\r\n            bindRetries = Integer.parseInt(bindRetriesStr);\r\n        } catch (NumberFormatException ex) {\r\n            logger.error(bindRetriesStr + \" does not appear to be an integer. \" + \"Defaulting port bind retries to \" + bindRetries, ex);\r\n        }\r\n    }\r\n    int currentlyTriedPort = NetworkUtils.getRandomPortNumber();\r\n    for (int i = 0; i < bindRetries; i++) {\r\n        try {\r\n            resultSocket = new DatagramSocket(currentlyTriedPort);\r\n            break;\r\n        } catch (SocketException exc) {\r\n            if (exc.getMessage().indexOf(\"Address already in use\") == -1) {\r\n                logger.fatal(\"An exception occurred while trying to create\" + \"a local host discovery socket.\", exc);\r\n                return null;\r\n            }\r\n            if (logger.isDebugEnabled())\r\n                logger.debug(\"Port \" + currentlyTriedPort + \" seems in use.\");\r\n            currentlyTriedPort = NetworkUtils.getRandomPortNumber();\r\n            if (logger.isDebugEnabled())\r\n                logger.debug(\"Retrying bind on port \" + currentlyTriedPort);\r\n        }\r\n    }\r\n    return resultSocket;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.authorization.AuthorizationResponseDialog.actionPerformed",
	"Comment": "handles the actionevent triggered when one user clickson one of the buttons.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    this.dispose();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.ExternalContactSource.initCustomGroupActionMenuItems",
	"Comment": "initializes custom action menu items for this contact source.",
	"Method": "void initCustomGroupActionMenuItems(){\r\n    customGroupActionMenuItems = new LinkedHashMap<ContactActionMenuItem<ContactSourceService>, JMenuItem>();\r\n    for (CustomContactActionsService<ContactSourceService> ccas : getGroupActionsServices()) {\r\n        Iterator<ContactActionMenuItem<ContactSourceService>> actionIterator = ccas.getCustomContactActionsMenuItems();\r\n        if (actionIterator != null) {\r\n            while (actionIterator.hasNext()) {\r\n                final ContactActionMenuItem<ContactSourceService> ca = actionIterator.next();\r\n                initGroupActionMenuItem(ca);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.globaldisplaydetails.GlobalDisplayDetailsImpl.avatarChanged",
	"Comment": "called whenever a new avatar is defined for one of the protocols that wehave subscribed for.",
	"Method": "void avatarChanged(AvatarEvent event){\r\n    globalAvatar = event.getNewAvatar();\r\n    if (globalAvatar == null) {\r\n        globalAvatar = GlobalDisplayDetailsActivator.getResources().getImageInBytes(\"service.gui.DEFAULT_USER_PHOTO\");\r\n    }\r\n    AvatarCacheUtils.cacheAvatar(event.getSourceProvider(), globalAvatar);\r\n    fireGlobalAvatarEvent(globalAvatar);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.whiteboard.gui.WhiteboardPanel.formMouseReleased",
	"Comment": "invoked when a mouse button has been released on the whiteboardpanel.",
	"Method": "void formMouseReleased(java.awt.event.MouseEvent evt){\r\n    checkPopupEvent(evt);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.configforms.ConfigurationFrame.removeConfigurationForm",
	"Comment": "implements configurationmanager.removeconfigurationformmethod. removes the given configurationform from this dialog.",
	"Method": "void removeConfigurationForm(ConfigurationForm configForm){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                removeConfigurationForm(configForm);\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    configList.removeConfigForm(configForm);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.configforms.ConfigurationFrame.removeConfigurationForm",
	"Comment": "implements configurationmanager.removeconfigurationformmethod. removes the given configurationform from this dialog.",
	"Method": "void removeConfigurationForm(ConfigurationForm configForm){\r\n    removeConfigurationForm(configForm);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.notificationwiring.NotificationWiringActivator.getMediaService",
	"Comment": "returns an instance of the mediaservice obtained from thebundle context.",
	"Method": "MediaService getMediaService(){\r\n    if (mediaService == null) {\r\n        mediaService = ServiceUtils.getService(bundleContext, MediaService.class);\r\n    }\r\n    return mediaService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.otr.OtrConfigurator.getID",
	"Comment": "puts a given property id under the otr namespace and makes sure it is xmltag friendly.",
	"Method": "String getID(String id){\r\n    return \"net.java.sip.communicator.plugin.otr.\" + getXmlFriendlyString(id);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl.answer",
	"Comment": "indicates a user request to answer an incoming call from thiscallpeer.sends an ok response to callpeer. make sure that the callpeer contains an sdp description when you call this method.",
	"Method": "void answer(){\r\n    Transaction transaction = getLatestInviteTransaction();\r\n    if (transaction == null || !(transaction instanceof ServerTransaction)) {\r\n        setState(CallPeerState.DISCONNECTED);\r\n        throw new OperationFailedException(\"Failed to extract a ServerTransaction \" + \"from the call's associated dialog!\", OperationFailedException.INTERNAL_ERROR);\r\n    }\r\n    CallPeerState peerState = getState();\r\n    if (peerState.equals(CallPeerState.CONNECTED) || CallPeerState.isOnHold(peerState)) {\r\n        if (logger.isInfoEnabled())\r\n            logger.info(\"Ignoring user request to answer a CallPeer \" + \"that is already connected. CP:\");\r\n        return;\r\n    }\r\n    ServerTransaction serverTransaction = (ServerTransaction) transaction;\r\n    Request invite = serverTransaction.getRequest();\r\n    Response ok = null;\r\n    try {\r\n        ok = messageFactory.createResponse(Response.OK, invite);\r\n        processExtraHeaders(ok);\r\n    } catch (ParseException ex) {\r\n        setState(CallPeerState.DISCONNECTED);\r\n        ProtocolProviderServiceSipImpl.throwOperationFailedException(\"Failed to construct an OK response to an INVITE request\", OperationFailedException.INTERNAL_ERROR, ex, logger);\r\n    }\r\n    ContentTypeHeader contentTypeHeader = null;\r\n    try {\r\n        contentTypeHeader = getProtocolProvider().getHeaderFactory().createContentTypeHeader(\"application\", \"sdp\");\r\n    } catch (ParseException ex) {\r\n        setState(CallPeerState.DISCONNECTED);\r\n        ProtocolProviderServiceSipImpl.throwOperationFailedException(\"Failed to create a content type header for the OK response\", OperationFailedException.INTERNAL_ERROR, ex, logger);\r\n    }\r\n    String sdpOffer = null;\r\n    try {\r\n        ContentLengthHeader cl = invite.getContentLength();\r\n        if (cl != null && cl.getContentLength() > 0) {\r\n            sdpOffer = SdpUtils.getContentAsString(invite);\r\n        }\r\n        String sdp;\r\n        if ((sdpOffer != null) && (sdpOffer.length() > 0)) {\r\n            sdp = getMediaHandler().processOffer(sdpOffer);\r\n        } else {\r\n            sdp = getMediaHandler().createOffer();\r\n        }\r\n        ok.setContent(sdp, contentTypeHeader);\r\n    } catch (Exception ex) {\r\n        logger.error(\"Failed to create an SDP description for an OK response \" + \"to an INVITE request!\", ex);\r\n        getProtocolProvider().sayError(serverTransaction, Response.NOT_ACCEPTABLE_HERE);\r\n        setState(CallPeerState.FAILED, ex.getMessage());\r\n        return;\r\n    }\r\n    try {\r\n        serverTransaction.sendResponse(ok);\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"sent response\\n\" + ok);\r\n    } catch (Exception ex) {\r\n        setState(CallPeerState.DISCONNECTED);\r\n        ProtocolProviderServiceSipImpl.throwOperationFailedException(\"Failed to send an OK response to an INVITE request\", OperationFailedException.NETWORK_FAILURE, ex, logger);\r\n    }\r\n    fireRequestProcessed(invite, ok);\r\n    if (CallPeerState.INCOMING_CALL.equals(getState())) {\r\n        if (sdpOffer != null && sdpOffer.length() > 0)\r\n            setState(CallPeerState.CONNECTING_INCOMING_CALL_WITH_MEDIA);\r\n        else\r\n            setState(CallPeerState.CONNECTING_INCOMING_CALL);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.keybindings.KeybindingsServiceImpl.getBindings",
	"Comment": "provides the bindings associated with a given category. this may be nullif the default bindings failed to be loaded.",
	"Method": "KeybindingSet getBindings(KeybindingSet.Category category){\r\n    if (!this.isRunning)\r\n        throw new UnsupportedOperationException();\r\n    assert this.bindings.containsKey(category);\r\n    return this.bindings.get(category);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomJabberImpl.getMembersWhiteList",
	"Comment": "returns the ids of the users that has the member role in the room.when the room is member only, this are the users allowed to join.",
	"Method": "List<String> getMembersWhiteList(){\r\n    List<String> res = new ArrayList<String>();\r\n    try {\r\n        for (Affiliate a : multiUserChat.getMembers()) {\r\n            res.add(a.getJid());\r\n        }\r\n    } catch (XMPPException e) {\r\n        logger.error(\"Cannot obtain members list\", e);\r\n    }\r\n    return res;\r\n}"
}, {
	"Path": "net.librec.math.structure.VectorBasedSequentialSparseVector.copySortedRandomAccessSparseVector",
	"Comment": "sorts a randomaccesssparsevectors elements before adding them to this",
	"Method": "void copySortedRandomAccessSparseVector(Vector other){\r\n    int entryCount = other.getNumEntries();\r\n    OrderedVectorElement[] sortableEntries = new OrderedVectorElement[entryCount];\r\n    int elementIndex = 0;\r\n    for (VectorEntry vectorEntry : other) {\r\n        sortableEntries[elementIndex++] = new OrderedVectorElement(vectorEntry.index(), vectorEntry.get());\r\n    }\r\n    if (!other.isSequentialAccess()) {\r\n        Arrays.sort(sortableEntries);\r\n    }\r\n    for (int sortIndex = 0; sortIndex < sortableEntries.length; sortIndex++) {\r\n        values.setIndexAt(sortIndex, sortableEntries[sortIndex].getIndex());\r\n        values.setValueAt(sortIndex, sortableEntries[sortIndex].getValue());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.dnsconfig.DnssecPanel.updateState",
	"Comment": "updates the form behavior when the resolver is enabled or disabled.",
	"Method": "void updateState(){\r\n    cboDefault.setEnabled(chkEnabled.isSelected());\r\n    txtNameservers.setEnabled(chkEnabled.isSelected());\r\n    tblDomains.setEnabled(chkEnabled.isSelected());\r\n    parallelDnsPanel.updateDnssecState();\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.msghistory.MsgHistoryServiceLick.start",
	"Comment": "start the history sevice implementation compatibility kit.",
	"Method": "void start(BundleContext bundleContext){\r\n    MsgHistoryServiceLick.bc = bundleContext;\r\n    setName(\"MsgHistoryServiceLick\");\r\n    Hashtable<String, String> properties = new Hashtable<String, String>();\r\n    properties.put(\"service.pid\", getName());\r\n    addTest(TestMsgHistoryService.suite());\r\n    addTest(TestMsgHistoryServiceMultiChat.suite());\r\n    bundleContext.registerService(getClass().getName(), this, properties);\r\n    logger.debug(\"Successfully registered \" + getClass().getName());\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.gui.UIContactDetail.getPreferredProtocolProvider",
	"Comment": "returns the protocol provider preferred for contacting this detail forthe given operationset class.",
	"Method": "ProtocolProviderService getPreferredProtocolProvider(Class<? extends OperationSet> opSetClass){\r\n    if (preferredProviders != null)\r\n        return preferredProviders.get(opSetClass);\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.history.HistoryImpl.getFixedDocument",
	"Comment": "returns the fixed document as xml documentif file cannot be fixed return null",
	"Method": "Document getFixedDocument(File file){\r\n    log.info(\"Will try to fix file : \" + file);\r\n    StringBuffer resultDocStr = new StringBuffer(\"<history>\");\r\n    try {\r\n        BufferedReader inReader = new BufferedReader(new FileReader(file));\r\n        String line = null;\r\n        while ((line = inReader.readLine()) != null) {\r\n            if (line.indexOf(\"<record\") == -1) {\r\n                continue;\r\n            }\r\n            String record = getRecordNodeString(line, inReader).toString();\r\n            if (record != null && isValidXML(record)) {\r\n                resultDocStr.append(record);\r\n            }\r\n        }\r\n    } catch (Exception ex1) {\r\n        log.error(\"File cannot be fixed. Erro reading! \" + ex1.getLocalizedMessage());\r\n    }\r\n    resultDocStr.append(\"<\/history>\");\r\n    try {\r\n        Document result = this.historyServiceImpl.parse(new ByteArrayInputStream(resultDocStr.toString().getBytes(\"UTF-8\")));\r\n        log.trace(\"File fixed will write to disk!\");\r\n        XMLUtils.writeXML(result, file);\r\n        return result;\r\n    } catch (Exception ex) {\r\n        System.out.println(\"again cannot parse \" + ex.getMessage());\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.WhiteboardInvitationRejectedEvent.getInvitee",
	"Comment": "returns the name of the invitee that rejected the invitation.",
	"Method": "String getInvitee(){\r\n    return invitee;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.UIPhoneUtil.getPhoneUtil",
	"Comment": "obtains an instance of this utility class for the givenmetacontact.",
	"Method": "UIPhoneUtil getPhoneUtil(MetaContact metaContact){\r\n    return new UIPhoneUtil(metaContact);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageSourceService.getIndex",
	"Comment": "returns the index of the source contact, in the list of recent messages.",
	"Method": "int getIndex(int getIndex,MessageSourceContact messageSourceContact){\r\n    synchronized (recentMessages) {\r\n        for (int i = 0; i < recentMessages.size(); i++) if (recentMessages.get(i).equals(messageSourceContact))\r\n            return i;\r\n        return -1;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.ChooseCallAccountPopupMenu.getI18NKeyChooseContact",
	"Comment": "returns the key to use for choose contact string. can be overriddenby extenders.",
	"Method": "String getI18NKeyChooseContact(){\r\n    return \"service.gui.CHOOSE_CONTACT\";\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.UIContactImpl.filterAddressDisplay",
	"Comment": "filter address display if enabled will remove domain part of theaddresses to show.",
	"Method": "String filterAddressDisplay(String addressToDisplay){\r\n    if (!GuiActivator.getConfigurationService().getBoolean(FILTER_DOMAIN_IN_TIP_ADDRESSES, false))\r\n        return addressToDisplay;\r\n    int ix = addressToDisplay.indexOf(\"@\");\r\n    int typeIx = addressToDisplay.indexOf(\"(\");\r\n    if (ix != -1) {\r\n        if (typeIx != -1)\r\n            addressToDisplay = addressToDisplay.substring(0, ix) + \" \" + addressToDisplay.substring(typeIx, addressToDisplay.length());\r\n        else\r\n            addressToDisplay = addressToDisplay.substring(0, ix);\r\n    }\r\n    return addressToDisplay;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.ReadonlyStatusItem.getProtocolProvider",
	"Comment": "returns the protocol provider associated with this status menu.",
	"Method": "ProtocolProviderService getProtocolProvider(){\r\n    return protocolProvider;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.RootContactGroupJabberImpl.canContainSubgroups",
	"Comment": "the contactlistroot is the only group that can contain subgroups.",
	"Method": "boolean canContainSubgroups(){\r\n    return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.TestOperationSetMultiUserChat2.testMemberKick",
	"Comment": "in testmemberkick, a member joins, then he is bannedand try to join again",
	"Method": "void testMemberKick(){\r\n    try {\r\n        Thread.sleep(2000);\r\n    } catch (InterruptedException ex) {\r\n    }\r\n    String testRoomName = testRoomBaseName + roomID++;\r\n    logger.info(\"--- Start testMemberKick room:\" + testRoomName);\r\n    ChatRoom opSet1Room = opSetMUC1.createChatRoom(testRoomName, null);\r\n    opSet1Room.join();\r\n    MUCEventCollector opSet1RoomCollector = new MUCEventCollector(opSet1Room, MUCEventCollector.EVENT_PRESENCE);\r\n    ChatRoom opSet2Room = opSetMUC2.findRoom(testRoomName);\r\n    opSet2Room.join();\r\n    opSet1RoomCollector.waitForEvent(10000);\r\n    assertTrue(\"user2 not on member list after join\", nameIsOnMemberList(fixture.userID2, opSet1Room.getMembers()));\r\n    List<ChatRoomMember> members = opSet1Room.getMembers();\r\n    ChatRoomMember memberToKick = null;\r\n    for (ChatRoomMember member : members) if (member.getContactAddress().equals(fixture.userID2)) {\r\n        memberToKick = member;\r\n        break;\r\n    }\r\n    if (memberToKick == null)\r\n        throw new IllegalStateException(\"member to kick not found\");\r\n    opSet1RoomCollector = new MUCEventCollector(opSet1Room, MUCEventCollector.EVENT_PRESENCE);\r\n    assertTrue(\"user2 not in a room he joined \", opSet2Room.isJoined());\r\n    MUCEventCollector opSet2RoomCollector = new MUCEventCollector(opSet2Room, MUCEventCollector.EVENT_PRESENCE);\r\n    opSet1Room.kickParticipant(memberToKick, \"testMemberKick\");\r\n    opSet2RoomCollector.waitForEvent(2000);\r\n    assertFalse(\"user2 still in a room after been kicked\", opSet2Room.isJoined());\r\n    opSet1RoomCollector.waitForEvent(10000);\r\n    assertEquals(\"user1 didnt received an event for user2 kick\", 1, opSet1RoomCollector.collectedEvents.size());\r\n    ChatRoomMemberPresenceChangeEvent changeEvent = (ChatRoomMemberPresenceChangeEvent) opSet1RoomCollector.collectedEvents.get(0);\r\n    assertEquals(\"the event received by user1 is not \", ChatRoomMemberPresenceChangeEvent.MEMBER_KICKED, changeEvent.getEventType());\r\n    assertEquals(\"the kicked member is not the one expected\", memberToKick.getContactAddress(), changeEvent.getChatRoomMember().getContactAddress());\r\n    assertFalse(\"user2 still on member list after kick\", nameIsOnMemberList(fixture.userID2, opSet1Room.getMembers()));\r\n    opSet2Room.join();\r\n    assertTrue(\"user2 can't join after been kicked \", opSet2Room.isJoined());\r\n    opSet1RoomCollector.waitForEvent(10000);\r\n    assertTrue(\"user2 not on list when joining after a kick\", nameIsOnMemberList(fixture.userID2, opSet1Room.getMembers()));\r\n    logger.info(\"--- End testMemberKick room:\" + testRoomName);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.WhiteboardSessionJabberImpl.assertConnected",
	"Comment": "utility method throwing an exception if the stack is not properlyinitialized.",
	"Method": "void assertConnected(){\r\n    if (jabberProvider == null)\r\n        throw new IllegalStateException(\"The provider must be non-null and signed on the \" + \"service before being able to communicate.\");\r\n    if (!jabberProvider.isRegistered())\r\n        throw new IllegalStateException(\"The provider must be signed on the service before \" + \"being able to communicate.\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactListServiceImpl.purgeLocallyStoredContactListCopy",
	"Comment": "removes local resources storing copies of the meta contact list. thismethod is meant primarily to aid automated testing which may depend onbeginning the tests with an empty local contact list.",
	"Method": "void purgeLocallyStoredContactListCopy(){\r\n    this.storageManager.storeContactListAndStopStorageManager();\r\n    this.storageManager.removeContactListFile();\r\n    if (logger.isTraceEnabled())\r\n        logger.trace(\"Removed meta contact list storage file.\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractCallPeer.addCallPeerSecurityListener",
	"Comment": "registers the listener to the list of listeners that would bereceiving callpeersecurityevents.",
	"Method": "void addCallPeerSecurityListener(CallPeerSecurityListener listener){\r\n    if (listener == null)\r\n        return;\r\n    synchronized (callPeerSecurityListeners) {\r\n        if (!callPeerSecurityListeners.contains(listener))\r\n            callPeerSecurityListeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommButton.setTooltip",
	"Comment": "changes the custom tooltip for this button. by default no custom tip.",
	"Method": "void setTooltip(ExtendedTooltip extendedTooltip){\r\n    this.extendedTooltip = extendedTooltip;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.FileTransferProgressEvent.getProgress",
	"Comment": "returns the progress of the file transfer in transferred bytes.",
	"Method": "long getProgress(){\r\n    return progress;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.callhistory.CallHistoryServiceImpl.convertHistoryRecordToCallRecord",
	"Comment": "used to convert historyrecord in callreord and callpeerrecordwhich are returned by the finder methods",
	"Method": "CallRecord convertHistoryRecordToCallRecord(HistoryRecord hr){\r\n    CallRecordImpl result = new CallRecordImpl();\r\n    List<String> callPeerIDs = null;\r\n    List<String> callPeerNames = null;\r\n    List<String> callPeerStart = null;\r\n    List<String> callPeerEnd = null;\r\n    List<CallPeerState> callPeerStates = null;\r\n    List<String> callPeerSecondaryIDs = null;\r\n    SimpleDateFormat sdf = new SimpleDateFormat(HistoryService.DATE_FORMAT);\r\n    for (int i = 0; i < hr.getPropertyNames().length; i++) {\r\n        String propName = hr.getPropertyNames()[i];\r\n        String value = hr.getPropertyValues()[i];\r\n        if (propName.equals(STRUCTURE_NAMES[0]))\r\n            result.setProtocolProvider(getProtocolProvider(value));\r\n        else if (propName.equals(STRUCTURE_NAMES[1]))\r\n            try {\r\n                result.setStartTime(sdf.parse(value));\r\n            } catch (ParseException e) {\r\n                result.setStartTime(new Date(Long.parseLong(value)));\r\n            }\r\n        else if (propName.equals(STRUCTURE_NAMES[2]))\r\n            try {\r\n                result.setEndTime(sdf.parse(value));\r\n            } catch (ParseException e) {\r\n                result.setEndTime(new Date(Long.parseLong(value)));\r\n            }\r\n        else if (propName.equals(STRUCTURE_NAMES[3]))\r\n            result.setDirection(value);\r\n        else if (propName.equals(STRUCTURE_NAMES[4]))\r\n            callPeerIDs = getCSVs(value);\r\n        else if (propName.equals(STRUCTURE_NAMES[5]))\r\n            callPeerStart = getCSVs(value);\r\n        else if (propName.equals(STRUCTURE_NAMES[6]))\r\n            callPeerEnd = getCSVs(value);\r\n        else if (propName.equals(STRUCTURE_NAMES[7]))\r\n            callPeerStates = getStates(value);\r\n        else if (propName.equals(STRUCTURE_NAMES[8]))\r\n            result.setEndReason(Integer.parseInt(value));\r\n        else if (propName.equals(STRUCTURE_NAMES[9]))\r\n            callPeerNames = getCSVs(value);\r\n        else if (propName.equals(STRUCTURE_NAMES[10]))\r\n            callPeerSecondaryIDs = getCSVs(value);\r\n    }\r\n    final int callPeerCount = callPeerIDs == null ? 0 : callPeerIDs.size();\r\n    for (int i = 0; i < callPeerCount; i++) {\r\n        Date callPeerStartValue = null;\r\n        Date callPeerEndValue = null;\r\n        if (i < callPeerStart.size()) {\r\n            try {\r\n                callPeerStartValue = sdf.parse(callPeerStart.get(i));\r\n            } catch (ParseException e) {\r\n                callPeerStartValue = new Date(Long.parseLong(callPeerStart.get(i)));\r\n            }\r\n        } else {\r\n            callPeerStartValue = result.getStartTime();\r\n            if (logger.isInfoEnabled())\r\n                logger.info(\"Call history start time list different from ids list: \" + hr.toString());\r\n        }\r\n        if (i < callPeerEnd.size()) {\r\n            try {\r\n                callPeerEndValue = sdf.parse(callPeerEnd.get(i));\r\n            } catch (ParseException e) {\r\n                callPeerEndValue = new Date(Long.parseLong(callPeerEnd.get(i)));\r\n            }\r\n        } else {\r\n            callPeerEndValue = result.getEndTime();\r\n            if (logger.isInfoEnabled())\r\n                logger.info(\"Call history end time list different from ids list: \" + hr.toString());\r\n        }\r\n        CallPeerRecordImpl cpr = new CallPeerRecordImpl(callPeerIDs.get(i), callPeerStartValue, callPeerEndValue);\r\n        String callPeerSecondaryID = null;\r\n        if (callPeerSecondaryIDs != null && !callPeerSecondaryIDs.isEmpty())\r\n            callPeerSecondaryID = callPeerSecondaryIDs.get(i);\r\n        if (callPeerSecondaryID != null && !callPeerSecondaryID.equals(\"\")) {\r\n            cpr.setPeerSecondaryAddress(callPeerSecondaryID);\r\n        }\r\n        if (callPeerStates != null && i < callPeerStates.size())\r\n            cpr.setState(callPeerStates.get(i));\r\n        else if (logger.isInfoEnabled())\r\n            logger.info(\"Call history state list different from ids list: \" + hr.toString());\r\n        result.getPeerRecords().add(cpr);\r\n        if (callPeerNames != null && i < callPeerNames.size())\r\n            cpr.setDisplayName(callPeerNames.get(i));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ScServiceDiscoveryManager.discoverInfoNonBlocking",
	"Comment": "returns the discovered information of a given xmpp entity addressed byits jid if locally cached, otherwise schedules for retrieval.",
	"Method": "DiscoverInfo discoverInfoNonBlocking(String entityID){\r\n    DiscoverInfo discoverInfo = capsManager.getDiscoverInfoByUser(entityID);\r\n    if (discoverInfo != null)\r\n        return discoverInfo;\r\n    EntityCapsManager.Caps caps = capsManager.getCapsByUser(entityID);\r\n    if (cacheNonCaps && (caps == null || !caps.isValid(discoverInfo))) {\r\n        discoverInfo = nonCapsCache.get(entityID);\r\n        if (discoverInfo != null)\r\n            return discoverInfo;\r\n    }\r\n    retriever.addEntityForRetrieve(entityID, caps);\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.OneToOneCallPanel.isCallTimerStarted",
	"Comment": "returns true if the call timer has been started, otherwisereturns false.",
	"Method": "boolean isCallTimerStarted(){\r\n    return callContainer.isCallTimerStarted();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetPersistentPresenceJabberImpl.updateContactStatus",
	"Comment": "updates contact status and its resources, fires presencestatuschangeevents.",
	"Method": "void updateContactStatus(ContactJabberImpl contact,PresenceStatus newStatus){\r\n    boolean oldMobileIndicator = contact.isMobile();\r\n    boolean resourceUpdated = updateResources(contact, true);\r\n    mobileIndicator.resourcesUpdated(contact);\r\n    PresenceStatus oldStatus = contact.getPresenceStatus();\r\n    if (oldStatus.equals(newStatus) && oldMobileIndicator == contact.isMobile()) {\r\n        return;\r\n    }\r\n    contact.updatePresenceStatus(newStatus);\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Will Dispatch the contact status event.\");\r\n    fireContactPresenceStatusChangeEvent(contact, contact.getParentContactGroup(), oldStatus, newStatus, resourceUpdated);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.ippiaccregwizz.IppiAccountRegistrationWizard.getIcon",
	"Comment": "implements the accountregistrationwizard.geticon method.returns the icon to be used for this wizard.",
	"Method": "byte[] getIcon(){\r\n    return IppiAccRegWizzActivator.getResources().getImageInBytes(PROTOCOL_ICON);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.WhiteboardPoint.equals",
	"Comment": "determines whether or not two points are equal. two instances ofwhiteboardpoint are equal if the values of theirx and y member fields, representingtheir position in the coordinate space, are the same.",
	"Method": "boolean equals(Object obj){\r\n    if (obj instanceof WhiteboardPoint) {\r\n        WhiteboardPoint pt = (WhiteboardPoint) obj;\r\n        return (x == pt.x) && (y == pt.y);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.keybindings.KeybindingsServiceImpl.stop",
	"Comment": "invalidates references to custom bindings, preventing further writes.",
	"Method": "void stop(){\r\n    if (!this.isRunning)\r\n        return;\r\n    for (KeybindingSetImpl bindingSet : this.bindings.values()) {\r\n        bindingSet.invalidate();\r\n    }\r\n    this.bindings.clear();\r\n    this.saveGlobalShortcutFromConfiguration();\r\n    this.isRunning = false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.CallPeerJabberImpl.processSessionInfo",
	"Comment": "handles the specified session info packet according to itscontent.",
	"Method": "void processSessionInfo(SessionInfoPacketExtension info){\r\n    switch(info.getType()) {\r\n        case ringing:\r\n            setState(CallPeerState.ALERTING_REMOTE_SIDE);\r\n            break;\r\n        case hold:\r\n            getMediaHandler().setRemotelyOnHold(true);\r\n            reevalRemoteHoldStatus();\r\n            break;\r\n        case unhold:\r\n        case active:\r\n            getMediaHandler().setRemotelyOnHold(false);\r\n            reevalRemoteHoldStatus();\r\n            break;\r\n        default:\r\n            logger.warn(\"Received SessionInfoPacketExtension of unknown type\");\r\n    }\r\n}"
}, {
	"Path": "net.librec.data.splitter.LOOCVDataSplitter.getLOOByUserDate",
	"Comment": "split ratings into two parts where the last user according to date ispreserved as the test set and the remaining data as the training set.",
	"Method": "void getLOOByUserDate(){\r\n    trainMatrix = new SequentialAccessSparseMatrix(preferenceMatrix);\r\n    Table<Integer, Integer, Double> dataTable = HashBasedTable.create();\r\n    for (int rowIndex = 0, rowSize = preferenceMatrix.rowSize(); rowIndex < rowSize; rowIndex++) {\r\n        SequentialSparseVector itemRatingVector = preferenceMatrix.row(rowIndex);\r\n        if (itemRatingVector.getNumEntries() == 0) {\r\n            continue;\r\n        }\r\n        List<RatingContext> ratingContexts = new ArrayList(itemRatingVector.getNumEntries());\r\n        for (Vector.VectorEntry vectorEntry : itemRatingVector) {\r\n            ratingContexts.add(new RatingContext(rowIndex, vectorEntry.position(), (long) datetimeMatrix.getAtColumnPosition(rowIndex, vectorEntry.position())));\r\n        }\r\n        Collections.sort(ratingContexts);\r\n        int columnPosition = ratingContexts.get(ratingContexts.size() - 1).getItem();\r\n        trainMatrix.setAtColumnPosition(rowIndex, columnPosition, 0.0D);\r\n        dataTable.put(rowIndex, preferenceMatrix.row(rowIndex).getIndexAtPosition(columnPosition), preferenceMatrix.getAtColumnPosition(rowIndex, columnPosition));\r\n    }\r\n    trainMatrix.reshape();\r\n    testMatrix = new SequentialAccessSparseMatrix(preferenceMatrix.rowSize(), preferenceMatrix.columnSize(), dataTable);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWritePanel.openChatTransportSelectorBox",
	"Comment": "opens the selector box containing the protocol contact icons.this is the menu, where user could select the protocol specificcontact to communicate through.",
	"Method": "void openChatTransportSelectorBox(){\r\n    transportSelectorBox.getMenu().doClick();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.history.HistoryQueryImpl.addHistoryRecord",
	"Comment": "adds the given historyrecord to the result list of this queryand notifies all interested listeners that a new record is received.",
	"Method": "void addHistoryRecord(HistoryRecord record){\r\n    historyRecords.add(record);\r\n    fireQueryEvent(record);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.CallPeerGibberishImpl.fireConferenceMembersSoundLevelEvent",
	"Comment": "fires a streamsoundlevelevent and notifies all registeredlisteners.",
	"Method": "void fireConferenceMembersSoundLevelEvent(Map<ConferenceMember, Integer> levels){\r\n    ConferenceMembersSoundLevelEvent event = new ConferenceMembersSoundLevelEvent(this, levels);\r\n    ConferenceMembersSoundLevelListener[] ls;\r\n    synchronized (confMemebrSoundLevelListeners) {\r\n        ls = confMemebrSoundLevelListeners.toArray(new ConferenceMembersSoundLevelListener[confMemebrSoundLevelListeners.size()]);\r\n    }\r\n    for (ConferenceMembersSoundLevelListener listener : ls) {\r\n        listener.soundLevelChanged(event);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.UIServiceImpl.addWindowListener",
	"Comment": "adds the given windowlistener to the main application window.",
	"Method": "void addWindowListener(WindowListener l){\r\n    mainFrame.addWindowListener(l);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommTextArea.removeUpdate",
	"Comment": "handles the change when a char has been removed from the field.",
	"Method": "void removeUpdate(DocumentEvent e){\r\n    if (!isDefaultTextVisible)\r\n        fireTextFieldChangeListener(1);\r\n    else\r\n        isDefaultTextVisible = false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetContactCapabilitiesJabberImpl.userCapsNodeRemoved",
	"Comment": "notifies this listener that an entitycapsmanager has removed arecord for a specific user about the caps node the user has.",
	"Method": "void userCapsNodeRemoved(String user,ArrayList<String> fullJids,String node,boolean online){\r\n    userCapsNodeChanged(user, fullJids, node, online);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipActivator.getHIDService",
	"Comment": "returns a reference to hidservice implementation currentlyregistered in the bundle context or null if no such implementation wasfound",
	"Method": "HIDService getHIDService(){\r\n    if (hidService == null) {\r\n        ServiceReference hidReference = bundleContext.getServiceReference(HIDService.class.getName());\r\n        if (hidReference == null)\r\n            return null;\r\n        hidService = (HIDService) bundleContext.getService(hidReference);\r\n    }\r\n    return hidService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ContactGroupJabberImpl.getContact",
	"Comment": "returns the contact with the specified address oridentifier.",
	"Method": "Contact getContact(String id){\r\n    return this.findContact(id);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.customcontrols.BoxPopupMenu.calculateGridDimensions",
	"Comment": "in order to have a popup which is at the form closest to sqware.",
	"Method": "void calculateGridDimensions(){\r\n    this.gridRowCount = (int) Math.round(Math.sqrt(this.itemsCount));\r\n    this.gridColCount = itemsCount / gridRowCount;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.CallPeerJabberImpl.putOnHold",
	"Comment": "puts the callpeer represented by this instance on or off hold.",
	"Method": "void putOnHold(boolean onHold){\r\n    CallPeerMediaHandlerJabberImpl mediaHandler = getMediaHandler();\r\n    mediaHandler.setLocallyOnHold(onHold);\r\n    SessionInfoType type;\r\n    if (onHold)\r\n        type = SessionInfoType.hold;\r\n    else {\r\n        type = SessionInfoType.unhold;\r\n        getMediaHandler().reinitAllContents();\r\n    }\r\n    reevalLocalHoldStatus();\r\n    JingleIQ onHoldIQ = JinglePacketFactory.createSessionInfo(getProtocolProvider().getOurJID(), peerJID, getSID(), type);\r\n    getProtocolProvider().getConnection().sendPacket(onHoldIQ);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.metahistory.MetaHistoryServiceImpl.findLastMessagesBefore",
	"Comment": "returns the supplied number of recent records before the given date",
	"Method": "Collection<Object> findLastMessagesBefore(String[] services,Object descriptor,Date date,int count){\r\n    MessageProgressWrapper listenWrapper = new MessageProgressWrapper(services.length);\r\n    TreeSet<Object> result = new TreeSet<Object>(new RecordsComparator());\r\n    for (int i = 0; i < services.length; i++) {\r\n        String name = services[i];\r\n        Object serv = getService(name);\r\n        if (serv instanceof MessageHistoryService) {\r\n            MessageHistoryService mhs = (MessageHistoryService) serv;\r\n            listenWrapper.setIx(i);\r\n            mhs.addSearchProgressListener(listenWrapper);\r\n            if (descriptor instanceof MetaContact) {\r\n                result.addAll(mhs.findLastMessagesBefore((MetaContact) descriptor, date, count));\r\n            } else if (descriptor instanceof ChatRoom) {\r\n                result.addAll(mhs.findLastMessagesBefore((ChatRoom) descriptor, date, count));\r\n            }\r\n            mhs.removeSearchProgressListener(listenWrapper);\r\n        } else if (serv instanceof FileHistoryService && descriptor instanceof MetaContact) {\r\n            result.addAll(((FileHistoryService) serv).findLastRecordsBefore((MetaContact) descriptor, date, count));\r\n        } else if (serv instanceof CallHistoryService) {\r\n            CallHistoryService chs = (CallHistoryService) serv;\r\n            listenWrapper.setIx(i);\r\n            chs.addSearchProgressListener(listenWrapper);\r\n            Collection<CallRecord> col = chs.findByEndDate(date);\r\n            if (col.size() > count) {\r\n                List<CallRecord> l = new LinkedList<CallRecord>(col);\r\n                result.addAll(l.subList(l.size() - count, l.size()));\r\n            } else\r\n                result.addAll(col);\r\n            chs.removeSearchProgressListener(listenWrapper);\r\n        }\r\n    }\r\n    listenWrapper.fireLastProgress(date, null, null);\r\n    LinkedList<Object> resultAsList = new LinkedList<Object>(result);\r\n    int startIndex = resultAsList.size() - count;\r\n    if (startIndex < 0)\r\n        startIndex = 0;\r\n    return resultAsList.subList(startIndex, resultAsList.size());\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AccountInfoUtils.getImage",
	"Comment": "returns the image of the account, to which the given accountinfoopsetbelongs.",
	"Method": "byte[] getImage(OperationSetServerStoredAccountInfo accountInfoOpSet){\r\n    ImageDetail image = null;\r\n    Iterator<GenericDetail> imageDetails = accountInfoOpSet.getDetails(ImageDetail.class);\r\n    if (imageDetails.hasNext())\r\n        image = (ImageDetail) imageDetails.next();\r\n    return (image != null) ? image.getBytes() : null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ChatConferenceCallDialog.initConferences",
	"Comment": "initializes the list of the conferences that are already announced. the list is displayed in the join panel.",
	"Method": "void initConferences(){\r\n    chatConferenceListPanel.initConferences();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockChatRoomMember.getRole",
	"Comment": "returns the role of this chat room member in its containing room.",
	"Method": "ChatRoomMemberRole getRole(){\r\n    return role;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallManager.queryContactSource",
	"Comment": "tries to resolves a peer address into a display name, by reqesting thecontactsourceservices. this function returns only thefirst match.",
	"Method": "String queryContactSource(String peerAddress,DetailsResolveListener listener){\r\n    String displayName = null;\r\n    if (!StringUtils.isNullOrEmpty(peerAddress)) {\r\n        ContactSourceSearcher searcher = new ContactSourceSearcher(peerAddress, listener);\r\n        if (listener == null) {\r\n            searcher.run();\r\n            displayName = searcher.displayName;\r\n        } else\r\n            new Thread(searcher, searcher.getClass().getName()).start();\r\n    }\r\n    return displayName;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.googlecontacts.configform.Resources.getString",
	"Comment": "returns an internationalized string corresponding to the given key.",
	"Method": "String getString(String key,String getString,String key,String[] params){\r\n    return GoogleContactsActivator.getResourceManagementService().getI18NString(key, params);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractOperationSetServerStoredAccountInfo.fireServerStoredDetailsChangeEvent",
	"Comment": "notify all listeners of the corresponding account detailchange event.",
	"Method": "void fireServerStoredDetailsChangeEvent(ProtocolProviderService source,int eventID,Object oldValue,Object newValue){\r\n    ServerStoredDetailsChangeEvent evt = new ServerStoredDetailsChangeEvent(source, eventID, oldValue, newValue);\r\n    Collection<ServerStoredDetailsChangeListener> listeners;\r\n    synchronized (serverStoredDetailsListeners) {\r\n        listeners = new ArrayList<ServerStoredDetailsChangeListener>(serverStoredDetailsListeners);\r\n    }\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Dispatching a Contact Property Change Event to\" + listeners.size() + \" listeners. Evt=\" + evt);\r\n    for (ServerStoredDetailsChangeListener listener : listeners) listener.serverStoredDetailsChanged(evt);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.menus.HelpMenu.initPluginComponents",
	"Comment": "initialize plugin components already registered for this container.",
	"Method": "void initPluginComponents(){\r\n    Collection<ServiceReference<PluginComponentFactory>> serRefs;\r\n    String osgiFilter = \"(\" + Container.CONTAINER_ID + \"=\" + Container.CONTAINER_CHAT_HELP_MENU.getID() + \")\";\r\n    try {\r\n        serRefs = GuiActivator.bundleContext.getServiceReferences(PluginComponentFactory.class, osgiFilter);\r\n    } catch (InvalidSyntaxException ex) {\r\n        serRefs = null;\r\n        logger.error(\"Could not obtain plugin reference.\", ex);\r\n    }\r\n    if ((serRefs != null) && !serRefs.isEmpty()) {\r\n        for (ServiceReference<PluginComponentFactory> serRef : serRefs) {\r\n            PluginComponentFactory factory = GuiActivator.bundleContext.getService(serRef);\r\n            PluginComponent component = factory.getPluginComponentInstance(HelpMenu.this);\r\n            add((Component) component.getComponent());\r\n        }\r\n    }\r\n    GuiActivator.getUIService().addPluginComponentListener(this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.customcontrols.SIPCommToolBar.paintBorder",
	"Comment": "overrides the paintborder method of jtoolbarto paint the drag icon in the beginning of the toolbar.",
	"Method": "void paintBorder(Graphics g){\r\n    Graphics2D g2 = (Graphics2D) g;\r\n    BufferedImage dragImage = ImageLoader.getImage(ImageLoader.TOOLBAR_DRAG_ICON);\r\n    g2.drawImage(dragImage, 0, (this.getHeight() - dragImage.getHeight(null)) / 2 - 2, null);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl.isValidTransport",
	"Comment": "determines whether the supplied transport is a known sip transport method",
	"Method": "boolean isValidTransport(String transport){\r\n    return ListeningPoint.UDP.equalsIgnoreCase(transport) || ListeningPoint.TLS.equalsIgnoreCase(transport) || ListeningPoint.TCP.equalsIgnoreCase(transport);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.notificationwiring.NotificationManager.outgoingCallCreated",
	"Comment": "do nothing. implements calllistener.outgoingcallcreated.",
	"Method": "void outgoingCallCreated(CallEvent event){\r\n    Call call = event.getSourceCall();\r\n    call.addCallChangeListener(this);\r\n    if (call.getCallPeers().hasNext()) {\r\n        CallPeer peer = call.getCallPeers().next();\r\n        peer.addCallPeerListener(this);\r\n        peer.addCallPeerSecurityListener(this);\r\n        peer.addCallPeerConferenceListener(this);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.toolBars.MainToolBar.actionPerformed",
	"Comment": "handles the actionevent, when one of the tool bar buttons isclicked.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    AbstractButton button = (AbstractButton) e.getSource();\r\n    String buttonText = button.getName();\r\n    ChatPanel chatPanel = chatContainer.getCurrentChat();\r\n    if (buttonText.equals(\"previous\")) {\r\n        chatPanel.loadPreviousPageFromHistory();\r\n    } else if (buttonText.equals(\"next\")) {\r\n        chatPanel.loadNextPageFromHistory();\r\n    } else if (buttonText.equals(\"sendFile\")) {\r\n        SipCommFileChooser scfc = GenericFileDialog.create(null, \"Send file...\", SipCommFileChooser.LOAD_FILE_OPERATION, ConfigurationUtils.getSendFileLastDir());\r\n        File selectedFile = scfc.getFileFromDialog();\r\n        if (selectedFile != null) {\r\n            ConfigurationUtils.setSendFileLastDir(selectedFile.getParent());\r\n            chatContainer.getCurrentChat().sendFile(selectedFile);\r\n        }\r\n    } else if (buttonText.equals(\"invite\")) {\r\n        ChatInviteDialog inviteDialog = new ChatInviteDialog(chatPanel);\r\n        inviteDialog.setVisible(true);\r\n    } else if (buttonText.equals(\"leave\")) {\r\n        ChatRoomWrapper chatRoomWrapper = (ChatRoomWrapper) chatPanel.getChatSession().getDescriptor();\r\n        ChatRoomWrapper leavedRoomWrapped = GuiActivator.getMUCService().leaveChatRoom(chatRoomWrapper);\r\n    } else if (buttonText.equals(\"call\")) {\r\n        call(false, false);\r\n    } else if (buttonText.equals(\"callVideo\")) {\r\n        call(true, false);\r\n    } else if (buttonText.equals(\"desktop\")) {\r\n        call(true, true);\r\n    } else if (buttonText.equals(\"options\")) {\r\n        GuiActivator.getUIService().getConfigurationContainer().setVisible(true);\r\n    } else if (buttonText.equals(\"font\"))\r\n        chatPanel.showFontChooserDialog();\r\n    else if (buttonText.equals(\"createConference\")) {\r\n        chatPanel.showChatConferenceDialog();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.replacement.ReplacementProperty.getPropertyName",
	"Comment": "returns the property name of individual replacement sources",
	"Method": "String getPropertyName(String source){\r\n    return \"net.java.sip.communicator.service.replacement.\" + source + \".enable\";\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.gibberishaccregwizz.GibberishAccountRegistrationWizard.getProtocolDescription",
	"Comment": "implements the accountregistrationwizard.getprotocoldescription method. returns the description of the protocol for this wizard.",
	"Method": "String getProtocolDescription(){\r\n    return Resources.getString(\"plugin.gibberishaccregwizz.PROTOCOL_DESCRIPTION\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl.getHeaderFactory",
	"Comment": "returns the headerfactory used to create sip message headers.",
	"Method": "HeaderFactory getHeaderFactory(){\r\n    return headerFactory;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactGroupImpl.countChildContacts",
	"Comment": "returns the number of metacontacts that this group contains.",
	"Method": "int countChildContacts(){\r\n    return childContacts.size();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler.removeVideoListener",
	"Comment": "unregisters a specific videolistener from this instance so thatit stops receiving notifications from it about changes in theavailability of visual components displaying video.",
	"Method": "void removeVideoListener(VideoListener listener){\r\n    videoNotifierSupport.removeVideoListener(listener);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactImpl.removeContactsForGroup",
	"Comment": "removes all proto contacts that belong to the specified protocol group.",
	"Method": "boolean removeContactsForGroup(ContactGroup protoGroup){\r\n    boolean modified = false;\r\n    Iterator<Contact> contactsIter = protoContacts.iterator();\r\n    while (contactsIter.hasNext()) {\r\n        Contact contact = contactsIter.next();\r\n        if (contact.getParentContactGroup() == protoGroup) {\r\n            contactsIter.remove();\r\n            modified = true;\r\n        }\r\n    }\r\n    if (modified && !protoContacts.contains(defaultContact)) {\r\n        defaultContact = null;\r\n    }\r\n    return modified;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.utils.PluginContainer.addComponentToContainer",
	"Comment": "adds a specific component to a specific jcomponentcontainer. allows extenders to apply custom logic to the exact placementof the specified component in the specified container.",
	"Method": "void addComponentToContainer(Component component,JComponent container,int preferredIndex){\r\n    if ((0 <= preferredIndex) && (preferredIndex < getComponentCount(container)))\r\n        container.add(component, preferredIndex);\r\n    else\r\n        container.add(component);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.filehistory.FileHistoryServiceImpl.getStatus",
	"Comment": "maps only the statuses we are interested in, otherwise returns null.",
	"Method": "String getStatus(int status){\r\n    switch(status) {\r\n        case FileTransferStatusChangeEvent.CANCELED:\r\n            return FileRecord.CANCELED;\r\n        case FileTransferStatusChangeEvent.COMPLETED:\r\n            return FileRecord.COMPLETED;\r\n        case FileTransferStatusChangeEvent.FAILED:\r\n            return FileRecord.FAILED;\r\n        case FileTransferStatusChangeEvent.REFUSED:\r\n            return FileRecord.REFUSED;\r\n        default:\r\n            return null;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWindowManager.getMultiChatInternal",
	"Comment": "gets the chatpanel corresponding to the specifiedadhocchatroom and optionally creates it if it does not exist.must be executed on the event dispatch thread.",
	"Method": "ChatPanel getMultiChatInternal(ChatRoomWrapper chatRoomWrapper,boolean create,ChatPanel getMultiChatInternal,AdHocChatRoomWrapper chatRoomWrapper,boolean create,ChatPanel getMultiChatInternal,ChatRoom chatRoom,boolean create,String escapedMessageID,ChatPanel getMultiChatInternal,AdHocChatRoom adHocChatRoom,boolean create,String escapedMessageID){\r\n    synchronized (chatSyncRoot) {\r\n        AdHocChatRoomList chatRoomList = GuiActivator.getUIService().getConferenceChatManager().getAdHocChatRoomList();\r\n        AdHocChatRoomWrapper chatRoomWrapper = chatRoomList.findChatRoomWrapperFromAdHocChatRoom(adHocChatRoom);\r\n        if ((chatRoomWrapper == null) && create) {\r\n            AdHocChatRoomProviderWrapper parentProvider = chatRoomList.findServerWrapperFromProvider(adHocChatRoom.getParentProvider());\r\n            chatRoomWrapper = new AdHocChatRoomWrapper(parentProvider, adHocChatRoom);\r\n            chatRoomList.addAdHocChatRoom(chatRoomWrapper);\r\n        }\r\n        ChatPanel chatPanel = null;\r\n        if (chatRoomWrapper != null) {\r\n            chatPanel = findChatPanelForDescriptor(chatRoomWrapper);\r\n            if ((chatPanel == null) && create)\r\n                chatPanel = createChat(chatRoomWrapper, escapedMessageID);\r\n        }\r\n        return chatPanel;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.DesktopSharingProtocolSipImpl.append",
	"Comment": "appends a specific array of strings to a specificstringbuffer.",
	"Method": "void append(StringBuffer stringBuffer,String strings){\r\n    for (String str : strings) stringBuffer.append(str);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetDesktopSharingServerSipImpl.responseProcessed",
	"Comment": "notifies this methodprocessorlistener that a specificcallpeer has processed a specific sip response and hasreplied to it with a specific sip request.",
	"Method": "void responseProcessed(CallPeerSipImpl sourceCallPeer,Response response,Request request){\r\n    if (Response.OK == response.getStatusCode()) {\r\n        CSeqHeader cseqHeader = (CSeqHeader) response.getHeader(CSeqHeader.NAME);\r\n        if ((cseqHeader != null) && Request.INVITE.equalsIgnoreCase(cseqHeader.getMethod())) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.net.ProxyConnection.isSameInetAddress",
	"Comment": "compares an inetaddress against the active outbound proxy. the comparisonis by reference, not equals.",
	"Method": "boolean isSameInetAddress(InetAddress addressToTest){\r\n    if (socketAddress == null)\r\n        return false;\r\n    return addressToTest == socketAddress.getAddress();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.ScreenInformation.getScreenBounds",
	"Comment": "calculates the bounding box of all available screens. this method ishighly inaccurate when screens of different sizes are used or not evenlyaligned. a correct implementation should generate a polygon.",
	"Method": "Rectangle getScreenBounds(){\r\n    final GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();\r\n    Rectangle bounds = new Rectangle();\r\n    for (GraphicsDevice gd : ge.getScreenDevices()) {\r\n        GraphicsConfiguration gc = gd.getDefaultConfiguration();\r\n        bounds = bounds.union(gc.getBounds());\r\n    }\r\n    return bounds;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ContactListModel.countChildContacts",
	"Comment": "counts group child contacts depending on the showoffline option.",
	"Method": "int countChildContacts(MetaContactGroup group){\r\n    if (showOffline)\r\n        return group.countChildContacts();\r\n    else {\r\n        int count = 0;\r\n        Iterator<MetaContact> i = group.getChildContacts();\r\n        while (i.hasNext() && isContactOnline(i.next())) count++;\r\n        return count;\r\n    }\r\n}"
}, {
	"Path": "net.librec.data.splitter.RatioDataSplitterTestCase.calTrainRatio",
	"Comment": "calculate the ratio of training set of a specified ratiodatasplitter object and its convertor",
	"Method": "double calTrainRatio(RatioDataSplitter splitter,TextDataConvertor convertor){\r\n    double trainSize = splitter.getTrainData().size();\r\n    double totalSize = convertor.getPreferenceMatrix().size();\r\n    return trainSize / totalSize;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.ircaccregwizz.IrcAccountRegistrationWizard.getLastPageIdentifier",
	"Comment": "returns the identifier of the page to show last in the wizard.",
	"Method": "Object getLastPageIdentifier(){\r\n    return firstWizardPage.getIdentifier();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.phonenumbercontactsource.PhoneNumberContactQuery.addAdditionalNumbers",
	"Comment": "returns all additional phone numbers corresponding to the givencontact.",
	"Method": "void addAdditionalNumbers(Contact contact){\r\n    OperationSetServerStoredContactInfo infoOpSet = contact.getProtocolProvider().getOperationSet(OperationSetServerStoredContactInfo.class);\r\n    Iterator<GenericDetail> details;\r\n    if (infoOpSet != null) {\r\n        details = infoOpSet.getAllDetailsForContact(contact);\r\n        while (details.hasNext()) {\r\n            if (contactCount > 0 && getQueryResultCount() > contactCount)\r\n                break;\r\n            GenericDetail d = details.next();\r\n            if (d instanceof PhoneNumberDetail && !(d instanceof PagerDetail) && !(d instanceof FaxDetail)) {\r\n                PhoneNumberDetail pnd = (PhoneNumberDetail) d;\r\n                if (pnd.getNumber() != null && pnd.getNumber().length() > 0) {\r\n                    String localizedType = null;\r\n                    if (d instanceof WorkPhoneDetail) {\r\n                        localizedType = PNContactSourceActivator.getResources().getI18NString(\"service.gui.WORK_PHONE\");\r\n                    } else if (d instanceof MobilePhoneDetail) {\r\n                        localizedType = PNContactSourceActivator.getResources().getI18NString(\"service.gui.MOBILE_PHONE\");\r\n                    } else if (d instanceof VideoDetail) {\r\n                        localizedType = PNContactSourceActivator.getResources().getI18NString(\"service.gui.VIDEO_PHONE\");\r\n                    } else {\r\n                        localizedType = PNContactSourceActivator.getResources().getI18NString(\"service.gui.HOME\");\r\n                    }\r\n                    String contactName = contact.getDisplayName();\r\n                    String contactAddress = contact.getAddress();\r\n                    String numberString = pnd.getNumber();\r\n                    if (StringUtils.isNullOrEmpty(queryString) || query.matcher(numberString).find() || query.matcher(contactName).find() || query.matcher(contactAddress).find() || (isQueryPhoneNumber && PNContactSourceActivator.getPhoneNumberI18nService().phoneNumbersMatch(queryString, numberString))) {\r\n                        ArrayList<ContactDetail> contactDetails = new ArrayList<ContactDetail>();\r\n                        String detailDisplayName = pnd.getNumber() + \"(\" + localizedType + \")\";\r\n                        ContactDetail detail = new ContactDetail(pnd.getNumber(), detailDisplayName);\r\n                        ArrayList<Class<? extends OperationSet>> supportedOpSets = new ArrayList<Class<? extends OperationSet>>();\r\n                        supportedOpSets.add(OperationSetBasicTelephony.class);\r\n                        detail.setSupportedOpSets(supportedOpSets);\r\n                        contactDetails.add(detail);\r\n                        PhoneNumberSourceContact numberSourceContact = new PhoneNumberSourceContact(this, getContactSource(), contact, contactDetails, detailDisplayName);\r\n                        addQueryResult(numberSourceContact);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.Base64.decode",
	"Comment": "decode the base 64 encoded string data writing it to the given output stream,whitespace characters will be ignored.",
	"Method": "byte[] decode(byte[] data,byte[] decode,String data,int decode,String data,OutputStream out,int decode,byte[] data,int off,int length,OutputStream out,int decode,String data,OutputStream out){\r\n    return encoder.decode(data, out);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipAccountIDImpl.stripServerNameFromUserID",
	"Comment": "removes the server part from a sip user id if there is one. used whencalling the super constructor to ensure that we will be consistent aboutthe value of the user id.",
	"Method": "String stripServerNameFromUserID(String userID){\r\n    int index = userID.indexOf(\"@\");\r\n    return (index > -1) ? userID.substring(0, index) : userID;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.credentialsstorage.CredentialsStorageServiceImpl.isUsingMasterPassword",
	"Comment": "checks if master password is used to encrypt saved account passwords.",
	"Method": "boolean isUsingMasterPassword(){\r\n    return null != configurationService.getString(MASTER_PROP);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.PresenceStatusMenu.actionPerformed",
	"Comment": "handles the actionevent triggered when one of the items in thelist is selected.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    if (e.getSource() instanceof JMenuItem) {\r\n        String menuItemText = ((JMenuItem) e.getSource()).getText();\r\n        Iterator<PresenceStatus> statusSet = presence.getSupportedStatusSet();\r\n        while (statusSet.hasNext()) {\r\n            PresenceStatus status = statusSet.next();\r\n            if (status.getStatusName().equals(menuItemText)) {\r\n                if (GuiActivator.getGlobalStatusService() != null) {\r\n                    GuiActivator.getGlobalStatusService().publishStatus(protocolProvider, status);\r\n                }\r\n                setSelectedStatus(status);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageHistoryServiceImpl.getHistoryReaders",
	"Comment": "gets all the history readers for the contacts in the given metacontact",
	"Method": "Map<Contact, HistoryReader> getHistoryReaders(MetaContact contact){\r\n    Map<Contact, HistoryReader> readers = new Hashtable<Contact, HistoryReader>();\r\n    Iterator<Contact> iter = contact.getContacts();\r\n    while (iter.hasNext()) {\r\n        Contact item = iter.next();\r\n        try {\r\n            History history = this.getHistory(null, item);\r\n            readers.put(item, history.getReader());\r\n        } catch (IOException e) {\r\n            logger.error(\"Could not read history\", e);\r\n        }\r\n    }\r\n    return readers;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.account.AccountListModel.getAccount",
	"Comment": "returns true if an account with the given accountuidis contained in the model, otherwise returns false.",
	"Method": "Account getAccount(AccountID accountID){\r\n    Enumeration<?> accounts = elements();\r\n    while (accounts.hasMoreElements()) {\r\n        Account account = (Account) accounts.nextElement();\r\n        if (account.getAccountID().equals(accountID))\r\n            return account;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.ContactlistActivator.getAccountManager",
	"Comment": "returns the accountmanager obtained from the bundle context.",
	"Method": "AccountManager getAccountManager(){\r\n    if (accountManager == null) {\r\n        accountManager = ServiceUtils.getService(bundleContext, AccountManager.class);\r\n    }\r\n    return accountManager;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.iptelaccregwizz.IptelAccRegWizzActivator.getBrowserLauncher",
	"Comment": "returns the browserlauncherservice obtained from the bundlecontext.",
	"Method": "BrowserLauncherService getBrowserLauncher(){\r\n    if (browserLauncherService == null) {\r\n        browserLauncherService = (BrowserLauncherService) bundleContext.getService(bundleContext.getServiceReference(BrowserLauncherService.class.getName()));\r\n    }\r\n    return browserLauncherService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.CryptoPacketExtension.equalsKeyParams",
	"Comment": "returns if the current key params equals the one given in parameter.",
	"Method": "boolean equalsKeyParams(String keyParams){\r\n    String currentKeyParams = this.getKeyParams();\r\n    return CryptoPacketExtension.equalsStrings(currentKeyParams, keyParams);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.MainFrame.removeProviderContactHandler",
	"Comment": "removes the contacteventhandler corresponding to the givenprotocolprovider.",
	"Method": "void removeProviderContactHandler(ProtocolProviderService protocolProvider){\r\n    providerContactHandlers.remove(protocolProvider);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.provdisc.mdns.MDNSProvisioningDiscover.run",
	"Comment": "thread entry point. it runs discoverprovisioningurl in aseparate thread.",
	"Method": "void run(){\r\n    String url = discoverProvisioningURL();\r\n    if (url != null) {\r\n        DiscoveryEvent evt = new DiscoveryEvent(this, url);\r\n        for (DiscoveryListener listener : listeners) {\r\n            listener.notifyProvisioningURL(evt);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MclStorageManager.protoContactAdded",
	"Comment": "indicates that a protocol specific contact instance has beenadded to the list of protocol specific buddies in thismetacontact",
	"Method": "void protoContactAdded(ProtoContactEvent evt){\r\n    Element mcNode = findMetaContactNode(evt.getParent().getMetaUID());\r\n    if (mcNode == null) {\r\n        logger.error(\"Failed to find meta contact: \" + evt.getParent());\r\n        return;\r\n    }\r\n    Element protoNode = createProtoContactNode(evt.getProtoContact());\r\n    if (protoNode == null) {\r\n        logger.error(\"Failed to create proto contact node for: \" + evt.getProtoContact());\r\n        return;\r\n    }\r\n    mcNode.appendChild(protoNode);\r\n    try {\r\n        scheduleContactListStorage();\r\n    } catch (IOException ex) {\r\n        logger.error(\"Writing CL failed after adding proto contact \" + evt.getProtoContact(), ex);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.WatchPresenceWatcher.setUpWatch",
	"Comment": "set up monitor based on the nick watch list in its current state.created a static method as not to interfere too much with a state that isstill being initialized.",
	"Method": "void setUpWatch(IRCApi irc,Collection<String> nickWatchList,int maxListSize){\r\n    List<String> current;\r\n    synchronized (nickWatchList) {\r\n        current = new LinkedList<String>(nickWatchList);\r\n    }\r\n    if (current.size() > maxListSize) {\r\n        current = current.subList(0, maxListSize);\r\n    }\r\n    final int maxLength = 510 - WATCH_ADD_CMD_STATIC_OVERHEAD;\r\n    final StringBuilder query = new StringBuilder();\r\n    for (String nick : current) {\r\n        if (query.length() + nick.length() + 2 > maxLength) {\r\n            irc.rawMessage(\"WATCH \" + query);\r\n            query.delete(0, query.length());\r\n        } else if (query.length() > 0) {\r\n            query.append(\" \");\r\n        }\r\n        query.append('+').append(nick);\r\n    }\r\n    if (query.length() > 0) {\r\n        irc.rawMessage(\"WATCH \" + query);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.WhiteboardSessionPresenceChangeEvent.getReason",
	"Comment": "a reason string indicating a human readable reason for this event.",
	"Method": "String getReason(){\r\n    return reason;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chatroomslist.joinforms.JoinChatRoomWizardPage2.getIdentifier",
	"Comment": "implements the wizardpaneldescriptor method to return theidentifier of this page.",
	"Method": "Object getIdentifier(){\r\n    return IDENTIFIER;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaAwareCall.removeLocalUserSoundLevelListener",
	"Comment": "removes a specific soundlevellistener from the list of listenersinterested in and notified about changes in local sound level relatedinformation. if l is the last listener that we had here we arealso going to unregister our own level event delegate in order to stoplevel calculations.",
	"Method": "void removeLocalUserSoundLevelListener(SoundLevelListener l){\r\n    synchronized (localUserAudioLevelListenersSyncRoot) {\r\n        if (localUserAudioLevelListeners != null) {\r\n            localUserAudioLevelListeners = new ArrayList<SoundLevelListener>(localUserAudioLevelListeners);\r\n            if (localUserAudioLevelListeners.remove(l) && localUserAudioLevelListeners.isEmpty())\r\n                localUserAudioLevelListeners = null;\r\n        }\r\n        if ((localUserAudioLevelListeners == null) || localUserAudioLevelListeners.isEmpty()) {\r\n            Iterator<T> callPeerIter = getCallPeers();\r\n            while (callPeerIter.hasNext()) {\r\n                callPeerIter.next().getMediaHandler().setLocalUserAudioLevelListener(null);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.AbstractCallPeerMediaHandlerJabberGTalkImpl.setZrtpEncryptionOnDescription",
	"Comment": "sets zrtp element to the encryption element of the description for agiven media.",
	"Method": "boolean setZrtpEncryptionOnDescription(MediaType mediaType,RtpDescriptionPacketExtension description,RtpDescriptionPacketExtension remoteDescription){\r\n    CallPeer peer = getPeer();\r\n    Call call = peer.getCall();\r\n    if (call.getConference().isJitsiVideobridge())\r\n        return false;\r\n    boolean isRemoteZrtpCapable;\r\n    if (remoteDescription == null)\r\n        isRemoteZrtpCapable = true;\r\n    else {\r\n        EncryptionPacketExtension remoteEncryption = remoteDescription.getFirstChildOfType(EncryptionPacketExtension.class);\r\n        isRemoteZrtpCapable = (remoteEncryption != null) && isRemoteZrtpCapable(remoteEncryption);\r\n    }\r\n    boolean zrtpHashSet = false;\r\n    if (isRemoteZrtpCapable) {\r\n        AccountID accountID = peer.getProtocolProvider().getAccountID();\r\n        if (accountID.getAccountPropertyBoolean(ProtocolProviderFactory.DEFAULT_ENCRYPTION, true) && accountID.isEncryptionProtocolEnabled(SrtpControlType.ZRTP) && call.isSipZrtpAttribute()) {\r\n            ZrtpControl zrtpControl = (ZrtpControl) getSrtpControls().getOrCreate(mediaType, SrtpControlType.ZRTP);\r\n            int numberSupportedVersions = zrtpControl.getNumberSupportedVersions();\r\n            for (int i = 0; i < numberSupportedVersions; i++) {\r\n                String[] helloHash = zrtpControl.getHelloHashSep(i);\r\n                if ((helloHash != null) && (helloHash[1].length() > 0)) {\r\n                    ZrtpHashPacketExtension hash = new ZrtpHashPacketExtension();\r\n                    hash.setVersion(helloHash[0]);\r\n                    hash.setValue(helloHash[1]);\r\n                    EncryptionPacketExtension encryption = description.getFirstChildOfType(EncryptionPacketExtension.class);\r\n                    if (encryption == null) {\r\n                        encryption = new EncryptionPacketExtension();\r\n                        description.addChildExtension(encryption);\r\n                    }\r\n                    encryption.addChildExtension(hash);\r\n                    zrtpHashSet = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return zrtpHashSet;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.ChatRoomPropertyChangeFailedEvent.getReasonCode",
	"Comment": "returns the code of the failure. one of the static constants declared inthis class.",
	"Method": "int getReasonCode(){\r\n    return reasonCode;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.plaf.SearchFieldUI.updateIcon",
	"Comment": "updates the delete icon, changes the cursor and deletes the content ofthe associated text component when the mouse is pressed over the deleteicon.",
	"Method": "void updateIcon(MouseEvent evt){\r\n    int x = evt.getX();\r\n    int y = evt.getY();\r\n    boolean outsideButtons = true;\r\n    if (isCallIconVisible && getCallButtonRect().contains(x, y)) {\r\n        JTextComponent c = getComponent();\r\n        String searchText = c.getText();\r\n        if (searchText == null)\r\n            return;\r\n        outsideButtons = false;\r\n        getComponent().setToolTipText(callString + \" \" + searchText);\r\n        ToolTipManager.sharedInstance().mouseEntered(new // X-Y of the mouse for the tool tip\r\n        MouseEvent(// X-Y of the mouse for the tool tip\r\n        c, // X-Y of the mouse for the tool tip\r\n        0, // X-Y of the mouse for the tool tip\r\n        x, y, x, y, 0, false));\r\n        if (evt.getID() == MouseEvent.MOUSE_PRESSED) {\r\n            isCallMouseOver = false;\r\n            isCallMousePressed = true;\r\n        } else {\r\n            isCallMouseOver = true;\r\n            isCallMousePressed = false;\r\n        }\r\n        getComponent().setCursor(Cursor.getDefaultCursor());\r\n    }\r\n    if (isSMSIconVisible && getSMSButtonRect().contains(x, y)) {\r\n        JTextComponent c = getComponent();\r\n        String searchText = c.getText();\r\n        if (searchText == null)\r\n            return;\r\n        outsideButtons = false;\r\n        getComponent().setToolTipText(smsString + \" \" + searchText);\r\n        ToolTipManager.sharedInstance().mouseEntered(new // X-Y of the mouse for the tool tip\r\n        MouseEvent(// X-Y of the mouse for the tool tip\r\n        c, // X-Y of the mouse for the tool tip\r\n        0, // X-Y of the mouse for the tool tip\r\n        x, y, x, y, 0, false));\r\n        if (evt.getID() == MouseEvent.MOUSE_PRESSED) {\r\n            isSMSMouseOver = false;\r\n            isSMSMousePressed = true;\r\n        } else {\r\n            isSMSMouseOver = true;\r\n            isSMSMousePressed = false;\r\n        }\r\n        getComponent().setCursor(Cursor.getDefaultCursor());\r\n    }\r\n    if (outsideButtons) {\r\n        getComponent().setToolTipText(\"\");\r\n        ToolTipManager.sharedInstance().mouseExited(new // X-Y of the mouse for the tool tip\r\n        MouseEvent(// X-Y of the mouse for the tool tip\r\n        getComponent(), // X-Y of the mouse for the tool tip\r\n        0, // X-Y of the mouse for the tool tip\r\n        x, y, x, y, 0, false));\r\n        isCallMouseOver = false;\r\n        isCallMousePressed = false;\r\n        isSMSMouseOver = false;\r\n        isSMSMousePressed = false;\r\n    }\r\n    getComponent().repaint();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallPanel.updateViewFromModel",
	"Comment": "updates this view i.e. callpanel so that it depicts the currentstate of its model i.e. callconference.",
	"Method": "void updateViewFromModel(){\r\n    if (!disposed) {\r\n        if (SwingUtilities.isEventDispatchThread())\r\n            updateViewFromModelInEventDispatchThread();\r\n        else {\r\n            SwingUtilities.invokeLater(updateViewFromModelInEventDispatchThread);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.UIFilterQuery.contactReceived",
	"Comment": "indicates that a contact has been received as a result of a query.",
	"Method": "void contactReceived(ContactReceivedEvent event){\r\n    ContactQuery query = event.getQuerySource();\r\n    SourceContact contact = event.getContact();\r\n    if (!isSucceeded() && !query.getQueryResults().isEmpty())\r\n        setSucceeded(true);\r\n    fireFilterQueryEvent();\r\n    List<SourceContact> queryResults = filterQueries.get(query);\r\n    queryResults.add(contact);\r\n    if (getMaxResultShown() > -1 && event.isShowMoreEnabled() && queryResults.size() == getMaxResultShown()) {\r\n        query.removeContactQueryListener(contactList);\r\n        ShowMoreContact moreInfoContact = new ShowMoreContact(query, queryResults, getMaxResultShown());\r\n        showMoreContactMap.put(query, moreInfoContact);\r\n        ContactSourceService contactSource = query.getContactSource();\r\n        contactList.addContact(query, moreInfoContact, contactList.getContactSource(contactSource).getUIGroup(), false);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.AccountStatusPanel.registrationStateChanged",
	"Comment": "updates account information when a protocol provider is registered.",
	"Method": "void registrationStateChanged(RegistrationStateChangeEvent evt){\r\n    ProtocolProviderService protocolProvider = evt.getProvider();\r\n    if (evt.getNewState().equals(RegistrationState.REGISTERING)) {\r\n        startConnecting(protocolProvider);\r\n    } else\r\n        this.updateStatus(protocolProvider);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapServiceImpl.getCredentialsService",
	"Comment": "returns a reference to a credentialsstorageconfigurationserviceimplementation currently registered in the bundle context or null if nosuch implementation was found.",
	"Method": "CredentialsStorageService getCredentialsService(){\r\n    if (credentialsService == null) {\r\n        ServiceReference confReference = bundleContext.getServiceReference(CredentialsStorageService.class.getName());\r\n        credentialsService = (CredentialsStorageService) bundleContext.getService(confReference);\r\n    }\r\n    return credentialsService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AccountInfoUtils.getGender",
	"Comment": "returns the gender of the account, to which the givenaccountinfoopset belongs.",
	"Method": "String getGender(OperationSetServerStoredAccountInfo accountInfoOpSet){\r\n    GenderDetail gender = null;\r\n    Iterator<GenericDetail> genderDetails = accountInfoOpSet.getDetails(GenderDetail.class);\r\n    if (genderDetails.hasNext())\r\n        gender = (GenderDetail) genderDetails.next();\r\n    if (gender == null)\r\n        return null;\r\n    return gender.getGender();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetPersistentPresenceJabberImpl.removeServerStoredContactGroup",
	"Comment": "removes the specified group from the server stored contact list.",
	"Method": "void removeServerStoredContactGroup(ContactGroup group){\r\n    assertConnected();\r\n    if (!(group instanceof ContactGroupJabberImpl))\r\n        throw new IllegalArgumentException(\"The specified group is not an jabber contact group: \" + group);\r\n    ssContactList.removeGroup(((ContactGroupJabberImpl) group));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.PayloadTypePacketExtension.getRtcpFeedbackTypeList",
	"Comment": "returns the list of rtcp feedback types currently registered for thispayload type.",
	"Method": "List<RtcpFbPacketExtension> getRtcpFeedbackTypeList(){\r\n    return getChildExtensionsOfType(RtcpFbPacketExtension.class);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommDialog.ensureOnScreenLocationAndSize",
	"Comment": "checks whether the current component willexceeds the screen size and if it do will set a default size",
	"Method": "void ensureOnScreenLocationAndSize(){\r\n    ConfigurationService config = DesktopUtilActivator.getConfigurationService();\r\n    if (!config.getBoolean(SIPCommFrame.PNAME_CALCULATED_POSITIONING, true))\r\n        return;\r\n    int x = this.getX();\r\n    int y = this.getY();\r\n    int width = this.getWidth();\r\n    int height = this.getHeight();\r\n    Rectangle virtualBounds = ScreenInformation.getScreenBounds();\r\n    final int borderDistance = 10;\r\n    if (!(virtualBounds.contains(x, y))) {\r\n        if (x < virtualBounds.x) {\r\n            x = virtualBounds.x + borderDistance;\r\n        } else if (x > virtualBounds.x) {\r\n            x = virtualBounds.x + virtualBounds.width - width - borderDistance;\r\n            if (x < virtualBounds.x + borderDistance) {\r\n                x = virtualBounds.x + borderDistance;\r\n            }\r\n        }\r\n        if (y < virtualBounds.y) {\r\n            y = virtualBounds.y + borderDistance;\r\n        } else if (y > virtualBounds.y) {\r\n            y = virtualBounds.y + virtualBounds.height - height - borderDistance;\r\n            if (y < virtualBounds.y + borderDistance) {\r\n                y = virtualBounds.y + borderDistance;\r\n            }\r\n        }\r\n        this.setLocation(x, y);\r\n    }\r\n    if (!(virtualBounds.contains(x, y, width, height))) {\r\n        if (x + width > virtualBounds.x + virtualBounds.width) {\r\n            x = virtualBounds.x + virtualBounds.width - width - borderDistance;\r\n            if (x < virtualBounds.x + borderDistance) {\r\n                x = virtualBounds.x + borderDistance;\r\n                width = virtualBounds.width - 2 * borderDistance;\r\n            }\r\n        }\r\n        if (y + height > virtualBounds.y + virtualBounds.height) {\r\n            y = virtualBounds.y + virtualBounds.height - height - borderDistance;\r\n            if (y < virtualBounds.y + borderDistance) {\r\n                y = virtualBounds.y + borderDistance;\r\n                height = virtualBounds.height - 2 * borderDistance;\r\n            }\r\n        }\r\n        this.setPreferredSize(new Dimension(width, height));\r\n        this.setSize(width, height);\r\n        this.setLocation(x, y);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockChatRoom.grantMembership",
	"Comment": "grants membership role to the participant given by address.",
	"Method": "void grantMembership(String address){\r\n    throw new UnsupportedOperationException(\"Not supported yet.\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.PasswordQualityMeter.countMatches",
	"Comment": "counts the number of matches of a given pattern in a given string.",
	"Method": "int countMatches(String str,String pattern){\r\n    Pattern p = Pattern.compile(pattern);\r\n    Matcher matcher = p.matcher(str);\r\n    int found = 0;\r\n    while (matcher.find()) found++;\r\n    return found;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.osdependent.jdic.StatusSubMenu.removeAccount",
	"Comment": "removes the account corresponding to the given protocol provider fromthis menu.",
	"Method": "void removeAccount(ProtocolProviderService protocolProvider){\r\n    Object selector = this.accountSelectors.get(protocolProvider.getAccountID());\r\n    if (selector == null)\r\n        return;\r\n    Object selectorMenu;\r\n    if (selector instanceof StatusSimpleSelector)\r\n        selectorMenu = ((StatusSimpleSelector) selector).getMenu();\r\n    else\r\n        selectorMenu = ((StatusSelector) selector).getMenu();\r\n    if (menu instanceof Container)\r\n        ((Container) menu).remove((Component) selectorMenu);\r\n    else\r\n        ((MenuContainer) menu).remove((MenuComponent) selectorMenu);\r\n    OperationSetPresence presence = protocolProvider.getOperationSet(OperationSetPresence.class);\r\n    if (presence != null)\r\n        presence.removeProviderPresenceStatusListener(this);\r\n    else\r\n        protocolProvider.removeRegistrationStateChangeListener(this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.customcontrols.wizard.Wizard.getDialog",
	"Comment": "returns an instance of the jdialog that this class created.this is usefulin the event that you want to change any of the jdialog parametersmanually.",
	"Method": "JDialog getDialog(){\r\n    return this;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetDesktopSharingServerJabberImpl.processPacket",
	"Comment": "handles incoming inputevt packets and passes them to the correspondingmethod based on their action.",
	"Method": "void processPacket(Packet packet){\r\n    InputEvtIQ inputIQ = (InputEvtIQ) packet;\r\n    if (inputIQ.getType() == IQ.Type.SET && inputIQ.getAction() == InputEvtAction.NOTIFY) {\r\n        IQ ack = IQ.createResultIQ(inputIQ);\r\n        parentProvider.getConnection().sendPacket(ack);\r\n        if (callPeers.contains(inputIQ.getFrom())) {\r\n            for (RemoteControlExtension p : inputIQ.getRemoteControls()) {\r\n                ComponentEvent evt = p.getEvent();\r\n                processComponentEvent(evt);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.AccountStatusPanel.globalDisplayAvatarChanged",
	"Comment": "called whenever a new avatar is defined for one of the protocols that wehave subscribed for.",
	"Method": "void globalDisplayAvatarChanged(GlobalAvatarChangeEvent event){\r\n    if (!SwingUtilities.isEventDispatchThread())\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                globalDisplayAvatarChanged(event);\r\n                return;\r\n            }\r\n        });\r\n    byte[] avatarImage = event.getNewAvatar();\r\n    if (avatarImage != null) {\r\n        accountImageLabel.setImageIcon(avatarImage);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.AccountStatusPanel.globalDisplayAvatarChanged",
	"Comment": "called whenever a new avatar is defined for one of the protocols that wehave subscribed for.",
	"Method": "void globalDisplayAvatarChanged(GlobalAvatarChangeEvent event){\r\n    globalDisplayAvatarChanged(event);\r\n    return;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ServerStoredContactList.fireGroupEvent",
	"Comment": "creates the corresponding event and notifies allserverstoredgrouplisteners that the source group has beenremoved, changed, renamed or whatever happened to it.",
	"Method": "void fireGroupEvent(ContactGroup group,int eventID){\r\n    ServerStoredGroupEvent event = new ServerStoredGroupEvent(group, eventID, parentOperationSet.getServerStoredContactListRoot(), sipProvider, parentOperationSet);\r\n    if (logger.isTraceEnabled()) {\r\n        logger.trace(\"Will dispatch the following group event: \" + event);\r\n    }\r\n    Iterable<ServerStoredGroupListener> listeners;\r\n    synchronized (serverStoredGroupListeners) {\r\n        listeners = new ArrayList<ServerStoredGroupListener>(serverStoredGroupListeners);\r\n    }\r\n    for (ServerStoredGroupListener listener : listeners) {\r\n        if (eventID == ServerStoredGroupEvent.GROUP_REMOVED_EVENT) {\r\n            listener.groupRemoved(event);\r\n        } else if (eventID == ServerStoredGroupEvent.GROUP_RENAMED_EVENT) {\r\n            listener.groupNameChanged(event);\r\n        } else if (eventID == ServerStoredGroupEvent.GROUP_CREATED_EVENT) {\r\n            listener.groupCreated(event);\r\n        } else if (eventID == ServerStoredGroupEvent.GROUP_RESOLVED_EVENT) {\r\n            listener.groupResolved(event);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.VerifyCertificateDialogImpl.isAlwaysTrustSelected",
	"Comment": "whether the user has selected to note the certificate so we alwaystrust it.",
	"Method": "boolean isAlwaysTrustSelected(){\r\n    return this.alwaysTrustCheckBox.isSelected();\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.TestOperationSetFileTransferImpl.prepareContactList",
	"Comment": "create the list to be sure that contacts exchanging messagesexists in each other lists",
	"Method": "void prepareContactList(){\r\n    if (getContact1() == null) {\r\n        Object o = new Object();\r\n        synchronized (o) {\r\n            o.wait(2000);\r\n        }\r\n        try {\r\n            opSetPresence1.setAuthorizationHandler(new AuthHandler());\r\n            opSetPresence1.subscribe(IcqSlickFixture.testerAgent.getIcqUIN());\r\n        } catch (OperationFailedException ex) {\r\n        }\r\n    }\r\n    if (getContact2() == null) {\r\n        try {\r\n            opSetPresence2.setAuthorizationHandler(new AuthHandler());\r\n            opSetPresence2.subscribe(fixture.ourUserID);\r\n        } catch (OperationFailedException ex1) {\r\n        }\r\n        logger.info(\"will wait till the list prepare is completed\");\r\n        Object o = new Object();\r\n        synchronized (o) {\r\n            o.wait(4000);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.DesktopUtilActivator.getAudioNotifier",
	"Comment": "returns the audionotifierservice obtained from the bundlecontext.",
	"Method": "AudioNotifierService getAudioNotifier(){\r\n    if (audioNotifierService == null) {\r\n        audioNotifierService = ServiceUtils.getService(bundleContext, AudioNotifierService.class);\r\n    }\r\n    return audioNotifierService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.keybindingchooser.chooser.BindingAdaptor.isBindingDisablingEnabled",
	"Comment": "provides if bindings are currently disableable via generated key adaptorsor not.",
	"Method": "boolean isBindingDisablingEnabled(){\r\n    return this.isDisablingEnabled;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.generalconfig.WindowsStartup.getModuleFilename",
	"Comment": "returns the currently running process executable name with path.",
	"Method": "String getModuleFilename(){\r\n    byte[] exePathName = new byte[512];\r\n    WinNT.HANDLE process = Kernel32.INSTANCE.GetCurrentProcess();\r\n    int result = PSAPI.INSTANCE.GetModuleFileNameExA(process, new Pointer(0), exePathName, exePathName.length);\r\n    return Native.toString(exePathName).substring(0, result);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetServerStoredContactInfoIcqImpl.assertConnected",
	"Comment": "utility method throwing an exception if the icq stack is not properlyinitialized.",
	"Method": "void assertConnected(){\r\n    if (icqProvider == null)\r\n        throw new IllegalStateException(\"The icq provider must be non-null and signed on the ICQ \" + \"service before being able to communicate.\");\r\n    if (!icqProvider.isRegistered())\r\n        throw new IllegalStateException(\"The icq provider must be signed on the ICQ service before \" + \"being able to communicate.\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.credentialsstorage.CredentialsStorageServiceImpl.showPasswordPrompt",
	"Comment": "displays a password prompt to the user in a loop until it is correct orthe user presses the cancel button.",
	"Method": "String showPasswordPrompt(){\r\n    String master;\r\n    boolean correct = true;\r\n    MasterPasswordInputService masterPasswordInputService = CredentialsStorageActivator.getMasterPasswordInputService();\r\n    if (masterPasswordInputService == null) {\r\n        logger.error(\"Missing MasterPasswordInputService to show input dialog\");\r\n        return null;\r\n    }\r\n    do {\r\n        master = masterPasswordInputService.showInputDialog(correct);\r\n        if (master == null)\r\n            return null;\r\n        correct = ((master.length() != 0) && verifyMasterPassword(master));\r\n    } while (!correct);\r\n    return master;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.OneToOneCallPeerPanel.setErrorReason",
	"Comment": "sets the reason of a call failure if one occurs. the renderer shoulddisplay this reason to the user.",
	"Method": "void setErrorReason(String reason){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                setErrorReason(reason);\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    if (errorMessageComponent == null) {\r\n        errorMessageComponent = new JTextPane();\r\n        JTextPane textPane = (JTextPane) errorMessageComponent;\r\n        textPane.setEditable(false);\r\n        textPane.setOpaque(false);\r\n        StyledDocument doc = textPane.getStyledDocument();\r\n        MutableAttributeSet standard = new SimpleAttributeSet();\r\n        StyleConstants.setAlignment(standard, StyleConstants.ALIGN_CENTER);\r\n        StyleConstants.setFontFamily(standard, textPane.getFont().getFamily());\r\n        StyleConstants.setFontSize(standard, 12);\r\n        doc.setParagraphAttributes(0, 0, standard, true);\r\n        GridBagConstraints constraints = new GridBagConstraints();\r\n        constraints.fill = GridBagConstraints.HORIZONTAL;\r\n        constraints.gridx = 0;\r\n        constraints.gridy = 4;\r\n        constraints.weightx = 1;\r\n        constraints.weighty = 0;\r\n        constraints.insets = new Insets(5, 0, 0, 0);\r\n        add(errorMessageComponent, constraints);\r\n        this.revalidate();\r\n    }\r\n    errorMessageComponent.setText(reason);\r\n    if (isVisible())\r\n        errorMessageComponent.repaint();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.OneToOneCallPeerPanel.setErrorReason",
	"Comment": "sets the reason of a call failure if one occurs. the renderer shoulddisplay this reason to the user.",
	"Method": "void setErrorReason(String reason){\r\n    setErrorReason(reason);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapDirectorySettingsImpl.getGlobalPhonePrefix",
	"Comment": "returns the global prefix to be used when calling phones from this ldapsource.",
	"Method": "String getGlobalPhonePrefix(){\r\n    return globalPhonePrefix;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallManager.getTelephonyProviders",
	"Comment": "returns a list of all currently registered telephony providers.",
	"Method": "List<ProtocolProviderService> getTelephonyProviders(){\r\n    return AccountUtils.getRegisteredProviders(OperationSetBasicTelephony.class);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.provdisc.AbstractProvisioningDiscoveryService.removeDiscoveryListener",
	"Comment": "add a listener that will be notified when thediscoverprovisioningurl has finished.",
	"Method": "void removeDiscoveryListener(DiscoveryListener listener){\r\n    if (listeners.contains(listener)) {\r\n        listeners.remove(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.DynamicPayloadTypeRegistry.findFormat",
	"Comment": "return s a reference to the mediaformat with the specifiedmapping or null if the number specified by payloadtypehas not been allocated yet.",
	"Method": "MediaFormat findFormat(byte payloadType){\r\n    for (Map.Entry<MediaFormat, Byte> entry : payloadTypeMappings.entrySet()) {\r\n        byte fmtPayloadType = entry.getValue();\r\n        if (fmtPayloadType == payloadType)\r\n            return entry.getKey();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.UriHandlerSipImpl.promptForRegistration",
	"Comment": "informs the user that they need to be registered before placing calls andasks them whether they would like us to do it for them.",
	"Method": "boolean promptForRegistration(String uri,ProtocolProviderService provider){\r\n    int answer = SipActivator.getUIService().getPopupDialog().showConfirmPopupDialog(\"You need to be online in order to make a call and your \" + \"account is currently offline. Do want to connect now?\", \"Account is currently offline\", PopupDialog.YES_NO_OPTION);\r\n    if (answer == PopupDialog.YES_OPTION) {\r\n        new ProtocolRegistrationThread(uri, provider).start();\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "io.lettuce.core.dynamic.support.MethodParameter.getDeclaringClass",
	"Comment": "return the class that declares the underlying method or constructor.",
	"Method": "Class<?> getDeclaringClass(){\r\n    return getMember().getDeclaringClass();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.GibberishStatusEnum.supportedStatusSet",
	"Comment": "returns an iterator over all status instances supproted by the gibberishprovider.",
	"Method": "Iterator<PresenceStatus> supportedStatusSet(){\r\n    return supportedStatusSet.iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.AbstractCallPeerMediaHandlerJabberGTalkImpl.addZrtpAdvertisedEncryptions",
	"Comment": "detects and adds zrtp available encryption method present in thedescription given in parameter.",
	"Method": "void addZrtpAdvertisedEncryptions(boolean isInitiator,RtpDescriptionPacketExtension description,MediaType mediaType){\r\n    CallPeer peer = getPeer();\r\n    Call call = peer.getCall();\r\n    if (call.getConference().isJitsiVideobridge())\r\n        return;\r\n    EncryptionPacketExtension encryptionPacketExtension = description.getFirstChildOfType(EncryptionPacketExtension.class);\r\n    if (encryptionPacketExtension != null) {\r\n        AccountID accountID = peer.getProtocolProvider().getAccountID();\r\n        if (accountID.getAccountPropertyBoolean(ProtocolProviderFactory.DEFAULT_ENCRYPTION, true) && accountID.isEncryptionProtocolEnabled(SrtpControlType.ZRTP) && call.isSipZrtpAttribute()) {\r\n            ZrtpHashPacketExtension zrtpHashPacketExtension = encryptionPacketExtension.getFirstChildOfType(ZrtpHashPacketExtension.class);\r\n            if ((zrtpHashPacketExtension != null) && (zrtpHashPacketExtension.getValue() != null)) {\r\n                addAdvertisedEncryptionMethod(SrtpControlType.ZRTP);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.ChatRoomMemberPresenceChangeEvent.getReason",
	"Comment": "a reason string indicating a human readable reason for this event.",
	"Method": "String getReason(){\r\n    return reason;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.SourceUIContact.getDescriptor",
	"Comment": "returns the underlying sourcecontact this abstraction is about.",
	"Method": "Object getDescriptor(){\r\n    return sourceContact;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.MUCServiceImpl.getServerChatRoomsContactSourceForProvider",
	"Comment": "returns instance of the serverchatroomcontactsourceservicecontact source.",
	"Method": "ContactSourceService getServerChatRoomsContactSourceForProvider(ChatRoomProviderWrapper pps){\r\n    return new ServerChatRoomContactSourceService(pps);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.jinglesdp.JingleUtils.extractRTPExtensions",
	"Comment": "extracts and returns the list of rtpextensions advertised indesc and registers newly encountered ones into the specifiedextmap. the method returns an empty list in case there were noextmap advertisements in desc.",
	"Method": "List<RTPExtension> extractRTPExtensions(RtpDescriptionPacketExtension desc,DynamicRTPExtensionsRegistry extMap){\r\n    List<RTPExtension> extensionsList = new ArrayList<RTPExtension>();\r\n    if (desc == null) {\r\n        return extensionsList;\r\n    }\r\n    List<RTPHdrExtPacketExtension> extmapList = desc.getExtmapList();\r\n    for (RTPHdrExtPacketExtension extmap : extmapList) {\r\n        RTPExtension rtpExtension = new RTPExtension(extmap.getURI(), getDirection(extmap.getSenders(), false), extmap.getAttributes());\r\n        extensionsList.add(rtpExtension);\r\n    }\r\n    return extensionsList;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.MetaContactChatTransport.allowsMessageCorrections",
	"Comment": "returns true if this chat transport supports messagecorrections and false otherwise.",
	"Method": "boolean allowsMessageCorrections(){\r\n    OperationSetContactCapabilities capOpSet = getProtocolProvider().getOperationSet(OperationSetContactCapabilities.class);\r\n    if (capOpSet != null) {\r\n        return capOpSet.getOperationSet(contact, OperationSetMessageCorrection.class) != null;\r\n    } else {\r\n        return contact.getProtocolProvider().getOperationSet(OperationSetMessageCorrection.class) != null;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ContactJabberImpl.updatePresenceStatus",
	"Comment": "sets the status that this contact is currently in. the method is toonly be called as a result of a status update received from the server.",
	"Method": "void updatePresenceStatus(PresenceStatus status){\r\n    this.status = status;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.LoginByPasswordStrategy.loginPreparationSuccessful",
	"Comment": "determines whether the strategy is ready to perform the login.",
	"Method": "boolean loginPreparationSuccessful(){\r\n    return password != null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageHistoryServiceImpl.insertMessage",
	"Comment": "inserts message to the history. allows to update the laready savedhistory.",
	"Method": "void insertMessage(String direction,Contact source,Contact destination,Message message,Date messageTimestamp,boolean isSmsSubtype){\r\n    try {\r\n        MetaContact metaContact = MessageHistoryActivator.getContactListService().findMetaContactByContact(destination);\r\n        if (metaContact != null && !isHistoryLoggingEnabled(metaContact.getMetaUID())) {\r\n            return;\r\n        }\r\n        History history = this.getHistory(source, destination);\r\n        HistoryWriter historyWriter = history.getWriter();\r\n        SimpleDateFormat sdf = new SimpleDateFormat(HistoryService.DATE_FORMAT);\r\n        historyWriter.insertRecord(new String[] { direction, message.getContent(), message.getContentType(), message.getEncoding(), message.getMessageUID(), message.getSubject(), sdf.format(messageTimestamp), isSmsSubtype ? MSG_SUBTYPE_SMS : null }, messageTimestamp, STRUCTURE_NAMES[6]);\r\n    } catch (IOException e) {\r\n        logger.error(\"Could not add message to history\", e);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.history.HistoryReaderImpl.countRecords",
	"Comment": "count the number of messages that a search will returnactually only the last file is parsed and its nodes are counted.we accept that the other files are full with max records,this way we escape parsing all files which will significantlyslow the process and for one search will parse the files twice.",
	"Method": "int countRecords(){\r\n    int result = 0;\r\n    String lastFile = null;\r\n    Iterator<String> filelistIter = this.historyImpl.getFileList();\r\n    while (filelistIter.hasNext()) {\r\n        lastFile = filelistIter.next();\r\n        result += HistoryWriterImpl.MAX_RECORDS_PER_FILE;\r\n    }\r\n    if (lastFile == null)\r\n        return result;\r\n    Document doc = this.historyImpl.getDocumentForFile(lastFile);\r\n    if (doc == null)\r\n        return result;\r\n    NodeList nodes = doc.getElementsByTagName(\"record\");\r\n    result += nodes.getLength();\r\n    return result;\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.server.WebSocketServletRFCTest.testBinaryAggregate",
	"Comment": "test that aggregation of binary frames into a single message occurs",
	"Method": "void testBinaryAggregate(){\r\n    BlockheadClientRequest request = client.newWsRequest(server.getServerUri());\r\n    Future<BlockheadConnection> connFut = request.sendAsync();\r\n    try (BlockheadConnection clientConn = connFut.get(Timeouts.CONNECT, Timeouts.CONNECT_UNIT)) {\r\n        byte[] buf1 = new byte[128];\r\n        byte[] buf2 = new byte[128];\r\n        byte[] buf3 = new byte[128];\r\n        Arrays.fill(buf1, (byte) 0xAA);\r\n        Arrays.fill(buf2, (byte) 0xBB);\r\n        Arrays.fill(buf3, (byte) 0xCC);\r\n        WebSocketFrame bin;\r\n        bin = new BinaryFrame().setPayload(buf1).setFin(false);\r\n        clientConn.write(bin);\r\n        bin = new ContinuationFrame().setPayload(buf2).setFin(false);\r\n        clientConn.write(bin);\r\n        bin = new ContinuationFrame().setPayload(buf3).setFin(true);\r\n        clientConn.write(bin);\r\n        LinkedBlockingQueue<WebSocketFrame> frames = clientConn.getFrameQueue();\r\n        Frame binmsg = frames.poll(Timeouts.POLL_EVENT, Timeouts.POLL_EVENT_UNIT);\r\n        int expectedSize = buf1.length + buf2.length + buf3.length;\r\n        assertThat(\"BinaryFrame.payloadLength\", binmsg.getPayloadLength(), is(expectedSize));\r\n        int aaCount = 0;\r\n        int bbCount = 0;\r\n        int ccCount = 0;\r\n        ByteBuffer echod = binmsg.getPayload();\r\n        while (echod.remaining() >= 1) {\r\n            byte b = echod.get();\r\n            switch(b) {\r\n                case (byte) 0xAA:\r\n                    aaCount++;\r\n                    break;\r\n                case (byte) 0xBB:\r\n                    bbCount++;\r\n                    break;\r\n                case (byte) 0xCC:\r\n                    ccCount++;\r\n                    break;\r\n                default:\r\n                    fail(String.format(\"Encountered invalid byte 0xX\", (byte) (0xFF & b)));\r\n            }\r\n        }\r\n        assertThat(\"Echoed data count for 0xAA\", aaCount, is(buf1.length));\r\n        assertThat(\"Echoed data count for 0xBB\", bbCount, is(buf2.length));\r\n        assertThat(\"Echoed data count for 0xCC\", ccCount, is(buf3.length));\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.MetaContactChatSession.contactResourceModified",
	"Comment": "called when a contactresource in the list of availablecontact resources has been modified.",
	"Method": "void contactResourceModified(ContactResourceEvent event){\r\n    Contact contact = event.getContact();\r\n    if (metaContact.containsContact(contact)) {\r\n        ChatTransport transport = findChatTransportForResource(event.getContactResource());\r\n        if (transport != null)\r\n            sessionRenderer.updateChatTransportStatus(transport);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.CallConference.getCallPeerCount",
	"Comment": "gets the number of callpeers associated with the callsparticipating in this telephony conference.",
	"Method": "int getCallPeerCount(Call call,int getCallPeerCount){\r\n    int callPeerCount = 0;\r\n    for (Call call : getCalls()) callPeerCount += call.getCallPeerCount();\r\n    return callPeerCount;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.propertieseditor.PropertiesEditorActivator.start",
	"Comment": "starts this bundle and adds the propertieseditorpanel containedin it to the configuration window obtained from the uiservice.",
	"Method": "void start(BundleContext bc){\r\n    bundleContext = bc;\r\n    Dictionary<String, String> properties = new Hashtable<String, String>();\r\n    properties.put(ConfigurationForm.FORM_TYPE, ConfigurationForm.ADVANCED_TYPE);\r\n    bundleContext.registerService(ConfigurationForm.class.getName(), new LazyConfigurationForm(StartingPanel.class.getName(), getClass().getClassLoader(), \"\", \"plugin.propertieseditor.TITLE\", 1002, true), properties);\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.ConfigurationUtils.isChatRoomConfigDisabled",
	"Comment": "indicates if the chat room user configuration functionality is disabled.",
	"Method": "boolean isChatRoomConfigDisabled(){\r\n    return isChatRoomConfigDisabled;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.neomedia.NeomediaActivator.getPacketLogging",
	"Comment": "returns a reference to the packetloggingservice implementationcurrently registered in the bundle context or null if no suchimplementation was found.",
	"Method": "PacketLoggingService getPacketLogging(){\r\n    if (packetLoggingService == null) {\r\n        packetLoggingService = ServiceUtils.getService(bundleContext, PacketLoggingService.class);\r\n    }\r\n    return packetLoggingService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.lookandfeel.SIPCommToggleButtonUI.uninstallDefaults",
	"Comment": "uninstalls default configurations for the given abstractbutton.",
	"Method": "void uninstallDefaults(AbstractButton b){\r\n    super.uninstallDefaults(b);\r\n    b.setBorderPainted(true);\r\n    b.setFocusPainted(false);\r\n    b.setOpaque(true);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.sipaccregwizz.SIPAccRegWizzActivator.getConfigurationService",
	"Comment": "returns the configurationservice obtained from the bundlecontext.",
	"Method": "ConfigurationService getConfigurationService(){\r\n    if (configService == null) {\r\n        ServiceReference serviceReference = bundleContext.getServiceReference(ConfigurationService.class.getName());\r\n        configService = (ConfigurationService) bundleContext.getService(serviceReference);\r\n    }\r\n    return configService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.iptelaccregwizz.IptelAccountRegistrationWizard.getProtocolDescription",
	"Comment": "implements the accountregistrationwizard.getprotocoldescription method. returns the description of the protocol for this wizard.",
	"Method": "String getProtocolDescription(){\r\n    return Resources.getString(\"plugin.iptelaccregwizz.PROTOCOL_DESCRIPTION\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.history.HistoryServiceImpl.parse",
	"Comment": "parse documents. synchronized to avoid exceptionwhen concurrently parsing with same documentbuilder",
	"Method": "Document parse(File file,Document parse,ByteArrayInputStream in){\r\n    return builder.parse(in);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.ldap.configform.DirectorySettingsForm.loadData",
	"Comment": "loads the information from the ldapdirectorysettings instanceinto the ui.",
	"Method": "void loadData(LdapDirectorySettings settings){\r\n    this.nameField.setText(settings.getName());\r\n    this.hostnameField.setText(settings.getHostname());\r\n    this.encryptionBox.setSelected(settings.getEncryption() == Encryption.SSL);\r\n    if (settings.getPort() != 0) {\r\n        this.portModel.setValue(new Integer(settings.getPort()));\r\n    } else {\r\n        this.portModel.setValue(new Integer(settings.getEncryption().defaultPort()));\r\n    }\r\n    this.bindDNField.setText(settings.getBindDN());\r\n    this.passwordField.setText(settings.getPassword());\r\n    this.baseDNField.setText(settings.getBaseDN());\r\n    this.scopeList.setSelectedIndex(settings.getScope().ordinal());\r\n    this.authList.setSelectedIndex(settings.getAuth().ordinal());\r\n    this.bindDNField.setEnabled(settings.getAuth() == Auth.SIMPLE);\r\n    this.passwordField.setEnabled(settings.getAuth() == Auth.SIMPLE);\r\n    this.mailField.setText(mergeStrings(settings.getMailSearchFields()));\r\n    this.mailSuffixField.setText(settings.getMailSuffix());\r\n    this.workPhoneField.setText(mergeStrings(settings.getWorkPhoneSearchFields()));\r\n    this.mobilePhoneField.setText(mergeStrings(settings.getMobilePhoneSearchFields()));\r\n    this.homePhoneField.setText(mergeStrings(settings.getHomePhoneSearchFields()));\r\n    this.prefixField.setText(settings.getGlobalPhonePrefix());\r\n    this.rdoDefaultQuery.setSelected(!\"custom\".equals(settings.getQueryMode()));\r\n    this.rdoCustomQuery.setSelected(\"custom\".equals(settings.getQueryMode()));\r\n    this.txtCustomQuery.setText(settings.getCustomQuery());\r\n    this.chkMangleQuery.setSelected(settings.isMangleQuery());\r\n    this.chkPhotoInline.setSelected(settings.isPhotoInline());\r\n    txtCustomQuery.setEditable(rdoCustomQuery.isSelected());\r\n    txtCustomQuery.setEnabled(rdoCustomQuery.isSelected());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.ContactGroupGibberishImpl.findContactByID",
	"Comment": "returns the contact with the specified id or null if no such contactexists.",
	"Method": "ContactGibberishImpl findContactByID(String id){\r\n    Iterator<Contact> contactsIter = contacts();\r\n    while (contactsIter.hasNext()) {\r\n        ContactGibberishImpl mContact = (ContactGibberishImpl) contactsIter.next();\r\n        if (mContact.getAddress().equals(id))\r\n            return mContact;\r\n    }\r\n    Iterator<ContactGroup> groupsIter = subgroups();\r\n    while (groupsIter.hasNext()) {\r\n        ContactGroupGibberishImpl mGroup = (ContactGroupGibberishImpl) groupsIter.next();\r\n        ContactGibberishImpl mContact = mGroup.findContactByID(id);\r\n        if (mContact != null)\r\n            return mContact;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapPersonFoundImpl.getSurname",
	"Comment": "returns the surname found in the the directory for this person",
	"Method": "String getSurname(){\r\n    return this.surname;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.osdependent.jdic.StatusSubMenu.providerStatusChanged",
	"Comment": "fired when an account has changed its status. we update the iconin the menu.",
	"Method": "void providerStatusChanged(ProviderPresenceStatusChangeEvent evt){\r\n    ProtocolProviderService pps = evt.getProvider();\r\n    StatusSelector selectorBox = (StatusSelector) accountSelectors.get(pps.getAccountID());\r\n    if (selectorBox != null)\r\n        selectorBox.updateStatus(evt.getNewStatus());\r\n    this.updateGlobalStatus();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomIrcImpl.addMessageListener",
	"Comment": "registers listener so that it would receive events every timea new message is received on this chat room.",
	"Method": "void addMessageListener(ChatRoomMessageListener listener){\r\n    synchronized (messageListeners) {\r\n        if (!messageListeners.contains(listener)) {\r\n            messageListeners.add(listener);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.update.UpdateServiceImpl.showWindowsNewVersionAvailableDialog",
	"Comment": "shows dialog informing about new version with button installwhich triggers the update process.",
	"Method": "void showWindowsNewVersionAvailableDialog(){\r\n    final boolean[] exitCheckForUpdates = new boolean[] { false };\r\n    @SuppressWarnings(\"serial\")\r\n    final JDialog dialog = new SIPCommDialog() {\r\n        @Override\r\n        protected void close(boolean escaped) {\r\n            synchronized (exitCheckForUpdates) {\r\n                if (exitCheckForUpdates[0])\r\n                    exitCheckForUpdates(this);\r\n            }\r\n        }\r\n    };\r\n    ResourceManagementService r = Resources.getResources();\r\n    dialog.setTitle(r.getI18NString(\"plugin.updatechecker.DIALOG_TITLE\"));\r\n    JEditorPane contentMessage = new JEditorPane();\r\n    contentMessage.setContentType(\"text/html\");\r\n    contentMessage.setOpaque(false);\r\n    contentMessage.setEditable(false);\r\n    contentMessage.putClientProperty(JEditorPane.HONOR_DISPLAY_PROPERTIES, Boolean.TRUE);\r\n    String dialogMsg = r.getI18NString(\"plugin.updatechecker.DIALOG_MESSAGE\", new String[] { r.getSettingsString(\"service.gui.APPLICATION_NAME\") });\r\n    if (latestVersion != null) {\r\n        dialogMsg += r.getI18NString(\"plugin.updatechecker.DIALOG_MESSAGE_2\", new String[] { r.getSettingsString(\"service.gui.APPLICATION_NAME\"), latestVersion });\r\n    }\r\n    contentMessage.setText(dialogMsg);\r\n    JPanel contentPane = new SIPCommFrame.MainContentPane();\r\n    contentMessage.setBorder(BorderFactory.createEmptyBorder(10, 0, 20, 0));\r\n    contentPane.setBorder(BorderFactory.createEmptyBorder(0, 10, 0, 10));\r\n    contentPane.add(contentMessage, BorderLayout.NORTH);\r\n    Component browser = createBrowser(changesLink);\r\n    if (browser != null) {\r\n        browser.setPreferredSize(new Dimension(550, 200));\r\n        contentPane.add(browser, BorderLayout.CENTER);\r\n    }\r\n    JPanel buttonPanel = new TransparentPanel(new FlowLayout(FlowLayout.CENTER, 10, 10));\r\n    final JButton closeButton = new JButton(r.getI18NString(\"plugin.updatechecker.BUTTON_CLOSE\"));\r\n    closeButton.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent e) {\r\n            dialog.dispose();\r\n            if (exitCheckForUpdates[0])\r\n                exitCheckForUpdates(dialog);\r\n        }\r\n    });\r\n    if (downloadLink != null) {\r\n        JButton installButton = new JButton(r.getI18NString(\"plugin.updatechecker.BUTTON_INSTALL\"));\r\n        installButton.addActionListener(new ActionListener() {\r\n            public void actionPerformed(ActionEvent e) {\r\n                enterCheckForUpdates(null);\r\n                try {\r\n                    closeButton.doClick();\r\n                } finally {\r\n                    boolean windowsUpdateThreadHasStarted = false;\r\n                    try {\r\n                        new Thread() {\r\n                            @Override\r\n                            public void run() {\r\n                                try {\r\n                                    windowsUpdate();\r\n                                } finally {\r\n                                    exitCheckForUpdates(null);\r\n                                }\r\n                            }\r\n                        }.start();\r\n                        windowsUpdateThreadHasStarted = true;\r\n                    } finally {\r\n                        if (!windowsUpdateThreadHasStarted)\r\n                            exitCheckForUpdates(null);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        buttonPanel.add(installButton);\r\n    }\r\n    buttonPanel.add(closeButton);\r\n    contentPane.add(buttonPanel, BorderLayout.SOUTH);\r\n    dialog.setContentPane(contentPane);\r\n    dialog.pack();\r\n    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\r\n    dialog.setLocation(screenSize.width / 2 - dialog.getWidth() / 2, screenSize.height / 2 - dialog.getHeight() / 2);\r\n    synchronized (exitCheckForUpdates) {\r\n        enterCheckForUpdates(dialog);\r\n        exitCheckForUpdates[0] = true;\r\n    }\r\n    try {\r\n        dialog.setVisible(true);\r\n    } finally {\r\n        synchronized (exitCheckForUpdates) {\r\n            if (exitCheckForUpdates[0] && dialog.isModal())\r\n                exitCheckForUpdates(dialog);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.update.UpdateServiceImpl.showWindowsNewVersionAvailableDialog",
	"Comment": "shows dialog informing about new version with button installwhich triggers the update process.",
	"Method": "void showWindowsNewVersionAvailableDialog(){\r\n    synchronized (exitCheckForUpdates) {\r\n        if (exitCheckForUpdates[0])\r\n            exitCheckForUpdates(this);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.update.UpdateServiceImpl.showWindowsNewVersionAvailableDialog",
	"Comment": "shows dialog informing about new version with button installwhich triggers the update process.",
	"Method": "void showWindowsNewVersionAvailableDialog(){\r\n    dialog.dispose();\r\n    if (exitCheckForUpdates[0])\r\n        exitCheckForUpdates(dialog);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.update.UpdateServiceImpl.showWindowsNewVersionAvailableDialog",
	"Comment": "shows dialog informing about new version with button installwhich triggers the update process.",
	"Method": "void showWindowsNewVersionAvailableDialog(){\r\n    enterCheckForUpdates(null);\r\n    try {\r\n        closeButton.doClick();\r\n    } finally {\r\n        boolean windowsUpdateThreadHasStarted = false;\r\n        try {\r\n            new Thread() {\r\n                @Override\r\n                public void run() {\r\n                    try {\r\n                        windowsUpdate();\r\n                    } finally {\r\n                        exitCheckForUpdates(null);\r\n                    }\r\n                }\r\n            }.start();\r\n            windowsUpdateThreadHasStarted = true;\r\n        } finally {\r\n            if (!windowsUpdateThreadHasStarted)\r\n                exitCheckForUpdates(null);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.update.UpdateServiceImpl.showWindowsNewVersionAvailableDialog",
	"Comment": "shows dialog informing about new version with button installwhich triggers the update process.",
	"Method": "void showWindowsNewVersionAvailableDialog(){\r\n    try {\r\n        windowsUpdate();\r\n    } finally {\r\n        exitCheckForUpdates(null);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.neomedia.NeomediaActivator.getResources",
	"Comment": "gets the resourcemanagementservice instance which represents theresources such as internationalized and localized text and images used bythe neomedia bundle.",
	"Method": "ResourceManagementService getResources(){\r\n    if (resources == null) {\r\n        resources = ResourceManagementServiceUtils.getService(bundleContext);\r\n    }\r\n    return resources;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.conference.ConferenceFocusPanel.setPeerState",
	"Comment": "sets the state of the contained call peer by specifying thestate name.",
	"Method": "void setPeerState(CallPeerState oldState,CallPeerState newState,String stateString){\r\n    focusPeerPanel.setPeerState(oldState, newState, stateString);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.FileTransferImpl.getTransferedBytes",
	"Comment": "returns the number of bytes already transfered through this file transfer.",
	"Method": "long getTransferedBytes(){\r\n    return transferedBytes;\r\n}"
}, {
	"Path": "net.librec.util.IOUtil.contentEquals",
	"Comment": "compare the contents of two readers to determine if they are equal ornot.this method buffers the input internally usingbufferedreader if they are not already buffered.",
	"Method": "boolean contentEquals(InputStream input1,InputStream input2,boolean contentEquals,Reader input1,Reader input2){\r\n    if (!(input1 instanceof BufferedReader)) {\r\n        input1 = new BufferedReader(input1);\r\n    }\r\n    if (!(input2 instanceof BufferedReader)) {\r\n        input2 = new BufferedReader(input2);\r\n    }\r\n    int ch = input1.read();\r\n    while (-1 != ch) {\r\n        int ch2 = input2.read();\r\n        if (ch != ch2) {\r\n            return false;\r\n        }\r\n        ch = input1.read();\r\n    }\r\n    int ch2 = input2.read();\r\n    return (ch2 == -1);\r\n}"
}, {
	"Path": "io.lettuce.core.protocol.CommandArgs.add",
	"Comment": "add a string argument. the argument is represented as bulk string.",
	"Method": "CommandArgs<K, V> add(Map<K, V> map,CommandArgs<K, V> add,String s,CommandArgs<K, V> add,char[] cs,CommandArgs<K, V> add,long n,CommandArgs<K, V> add,double n,CommandArgs<K, V> add,byte[] value,CommandArgs<K, V> add,CommandKeyword keyword,CommandArgs<K, V> add,CommandType type,CommandArgs<K, V> add,ProtocolKeyword keyword){\r\n    LettuceAssert.notNull(keyword, \"CommandKeyword must not be null\");\r\n    singularArguments.add(ProtocolKeywordArgument.of(keyword));\r\n    return this;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.osdependent.jdic.TrayMenuFactory.isVisible",
	"Comment": "returns true if the given traymenu is visible,otherwise returns false.",
	"Method": "boolean isVisible(Object trayMenu){\r\n    if (trayMenu instanceof JPopupMenu)\r\n        return ((JPopupMenu) trayMenu).isVisible();\r\n    return false;\r\n}"
}, {
	"Path": "net.librec.job.RecommenderJob.printCVAverageResult",
	"Comment": "print the average evaluate results when using cross validation.",
	"Method": "void printCVAverageResult(){\r\n    DataSplitter splitter = dataModel.getDataSplitter();\r\n    if (splitter != null && (splitter instanceof KCVDataSplitter || splitter instanceof LOOCVDataSplitter)) {\r\n        LOG.info(\"Average Evaluation Result of Cross Validation:\");\r\n        for (Map.Entry<String, List<Double>> entry : cvEvalResults.entrySet()) {\r\n            String evalName = entry.getKey();\r\n            List<Double> evalList = entry.getValue();\r\n            double sum = 0.0;\r\n            for (double value : evalList) {\r\n                sum += value;\r\n            }\r\n            double avgEvalResult = sum / evalList.size();\r\n            LOG.info(\"Evaluator value:\" + evalName + \" is \" + avgEvalResult);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.TestOperationSetBasicInstantMessaging.testReceiveOfflineMessages",
	"Comment": "tests whether there is a offline message receivedand whether is the one we have send",
	"Method": "void testReceiveOfflineMessages(){\r\n    String messageText = IcqSlickFixture.offlineMsgCollector.getMessageText();\r\n    Message receiveMessage = IcqSlickFixture.offlineMsgCollector.getReceivedMessage();\r\n    assertNotNull(\"No Offline messages have been received\", receiveMessage);\r\n    assertEquals(\"message body\", messageText, receiveMessage.getContent());\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.gibberish.TestOperationSetPresence.testChangingState",
	"Comment": "verify that changing state to all supported statuses works as expected.",
	"Method": "void testChangingState(){\r\n    Iterator<PresenceStatus> supportedStatusSetIter = operationSetPresence1.getSupportedStatusSet();\r\n    while (supportedStatusSetIter.hasNext()) {\r\n        PresenceStatus supportedStatus = supportedStatusSetIter.next();\r\n        logger.trace(\"Will test a transition to \" + supportedStatus.getStatusName());\r\n        subtestStateTransition(supportedStatus);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactGroupImpl.findMetaContactByContact",
	"Comment": "returns a meta contact, a child of this group or its subgroups, withaddress equald to contactaddress and a source protocol providerwith the matching accountid. if no such meta contact exists,the method would return null.",
	"Method": "MetaContact findMetaContactByContact(Contact protoContact,MetaContact findMetaContactByContact,String contactAddress,String accountID){\r\n    Iterator<MetaContact> contactsIter = getChildContacts();\r\n    while (contactsIter.hasNext()) {\r\n        MetaContactImpl mContact = (MetaContactImpl) contactsIter.next();\r\n        Contact storedProtoContact = mContact.getContact(contactAddress, accountID);\r\n        if (storedProtoContact != null)\r\n            return mContact;\r\n    }\r\n    Iterator<MetaContactGroup> groupsIter = getSubgroups();\r\n    while (groupsIter.hasNext()) {\r\n        MetaContactGroupImpl mGroup = (MetaContactGroupImpl) groupsIter.next();\r\n        MetaContact mContact = mGroup.findMetaContactByContact(contactAddress, accountID);\r\n        if (mContact != null)\r\n            return mContact;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomIrcImpl.fireMessageReceivedEvent",
	"Comment": "notifies all interested listeners that achatroommessagereceivedevent has been fired.",
	"Method": "void fireMessageReceivedEvent(Message message,ChatRoomMember fromMember,Date date,int eventType){\r\n    ChatRoomMessageReceivedEvent event = new ChatRoomMessageReceivedEvent(this, fromMember, date, message, eventType);\r\n    Iterable<ChatRoomMessageListener> listeners;\r\n    synchronized (messageListeners) {\r\n        listeners = new ArrayList<ChatRoomMessageListener>(messageListeners);\r\n    }\r\n    for (ChatRoomMessageListener listener : listeners) {\r\n        try {\r\n            listener.messageReceived(event);\r\n        } catch (RuntimeException e) {\r\n            LOGGER.error(String.format(\"Listener '%s' threw a runtime exception during execution.\" + \" This is probably due to a bug in the listener's \" + \"implementation.\", listener.getClass().getCanonicalName()), e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.JabberAccountRegistrationWizard.getFirstPageIdentifier",
	"Comment": "returns the identifier of the page to show first in the wizard.",
	"Method": "Object getFirstPageIdentifier(){\r\n    return firstWizardPage.getIdentifier();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.AddContactDialog.setVisible",
	"Comment": "overwrites the setvisible method in order to init window before openingit.",
	"Method": "void setVisible(boolean isVisible){\r\n    if (!initialized)\r\n        init();\r\n    super.setVisible(isVisible);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallManager.getInProgressCalls",
	"Comment": "returns a collection of all currently in progress calls. a call is activeif it is in progress so the method merely delegates to",
	"Method": "Collection<Call> getInProgressCalls(){\r\n    return getActiveCalls();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageSourceService.contactModified",
	"Comment": "if a contact is renamed update the locally stored message if any.",
	"Method": "void contactModified(ContactPropertyChangeEvent evt){\r\n    if (!evt.getPropertyName().equals(ContactPropertyChangeEvent.PROPERTY_DISPLAY_NAME))\r\n        return;\r\n    Contact contact = evt.getSourceContact();\r\n    if (contact == null)\r\n        return;\r\n    for (ComparableEvtObj msc : recentMessages) {\r\n        if (contact.equals(msc.getContact())) {\r\n            if (recentQuery != null)\r\n                recentQuery.updateContactDisplayName(msc, contact.getDisplayName());\r\n            return;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.credentialsstorage.CredentialsStorageServiceImpl.setUnencrypted",
	"Comment": "saves the unencrypted account password using configuration service.",
	"Method": "void setUnencrypted(String accountPrefix,String value){\r\n    configurationService.setProperty(accountPrefix + \".\" + ACCOUNT_UNENCRYPTED_PASSWORD, value);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.globalshortcut.GlobalShortcutActivator.serviceChanged",
	"Comment": "implements the servicelistener method. verifies whether thepassed event concerns a protocolproviderservice and adds thecorresponding ui controls.",
	"Method": "void serviceChanged(ServiceEvent event){\r\n    ServiceReference<?> serviceRef = event.getServiceReference();\r\n    if (serviceRef.getBundle().getState() == Bundle.STOPPING) {\r\n        return;\r\n    }\r\n    Object service = bundleContext.getService(serviceRef);\r\n    if (!(service instanceof ProtocolProviderService)) {\r\n        return;\r\n    }\r\n    switch(event.getType()) {\r\n        case ServiceEvent.REGISTERED:\r\n            this.handleProviderAdded((ProtocolProviderService) service);\r\n            break;\r\n        case ServiceEvent.UNREGISTERING:\r\n            this.handleProviderRemoved((ProtocolProviderService) service);\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.resources.AbstractResourcesService.serviceChanged",
	"Comment": "handles all serviceevents corresponding to resourcepackbeing registered or unregistered.",
	"Method": "void serviceChanged(ServiceEvent event){\r\n    Object sService = bundleContext.getService(event.getServiceReference());\r\n    if (!(sService instanceof ResourcePack)) {\r\n        return;\r\n    }\r\n    ResourcePack resourcePack = (ResourcePack) sService;\r\n    if (event.getType() == ServiceEvent.REGISTERED) {\r\n        if (logger.isInfoEnabled())\r\n            logger.info(\"Resource registered \" + resourcePack);\r\n        Map<String, String> resources = getResources(resourcePack);\r\n        if (resourcePack instanceof ColorPack && colorPack == null) {\r\n            colorPack = resourcePack;\r\n            colorResources = resources;\r\n        } else if (resourcePack instanceof ImagePack && imagePack == null) {\r\n            imagePack = (ImagePack) resourcePack;\r\n            imageResources = resources;\r\n        } else if (resourcePack instanceof LanguagePack && languagePack == null) {\r\n            languagePack = (LanguagePack) resourcePack;\r\n            languageLocale = Locale.getDefault();\r\n            languageResources = resources;\r\n        } else if (resourcePack instanceof SettingsPack && settingsPack == null) {\r\n            settingsPack = resourcePack;\r\n            settingsResources = resources;\r\n        } else if (resourcePack instanceof SoundPack && soundPack == null) {\r\n            soundPack = resourcePack;\r\n            soundResources = resources;\r\n        } else if (resourcePack instanceof SkinPack && skinPack == null) {\r\n            skinPack = (SkinPack) resourcePack;\r\n            if (imagePack != null)\r\n                imageResources = getResources(imagePack);\r\n            if (colorPack != null)\r\n                colorResources = getResources(colorPack);\r\n            if (settingsPack != null)\r\n                settingsResources = getResources(settingsPack);\r\n            if (imageResources != null)\r\n                imageResources.putAll(skinPack.getImageResources());\r\n            colorResources.putAll(skinPack.getColorResources());\r\n            settingsResources.putAll(skinPack.getSettingsResources());\r\n            onSkinPackChanged();\r\n        }\r\n    } else if (event.getType() == ServiceEvent.UNREGISTERING) {\r\n        if (resourcePack instanceof ColorPack && colorPack.equals(resourcePack)) {\r\n            colorPack = getDefaultResourcePack(ColorPack.class, ColorPack.RESOURCE_NAME_DEFAULT_VALUE);\r\n            if (colorPack != null)\r\n                colorResources = getResources(colorPack);\r\n        } else if (resourcePack instanceof ImagePack && imagePack.equals(resourcePack)) {\r\n            imagePack = getDefaultResourcePack(ImagePack.class, ImagePack.RESOURCE_NAME_DEFAULT_VALUE);\r\n            if (imagePack != null)\r\n                imageResources = getResources(imagePack);\r\n        } else if (resourcePack instanceof LanguagePack && languagePack.equals(resourcePack)) {\r\n            languagePack = getDefaultResourcePack(LanguagePack.class, LanguagePack.RESOURCE_NAME_DEFAULT_VALUE);\r\n        } else if (resourcePack instanceof SettingsPack && settingsPack.equals(resourcePack)) {\r\n            settingsPack = getDefaultResourcePack(SettingsPack.class, SettingsPack.RESOURCE_NAME_DEFAULT_VALUE);\r\n            if (settingsPack != null)\r\n                settingsResources = getResources(settingsPack);\r\n        } else if (resourcePack instanceof SoundPack && soundPack.equals(resourcePack)) {\r\n            soundPack = getDefaultResourcePack(SoundPack.class, SoundPack.RESOURCE_NAME_DEFAULT_VALUE);\r\n            if (soundPack != null)\r\n                soundResources = getResources(soundPack);\r\n        } else if (resourcePack instanceof SkinPack && skinPack.equals(resourcePack)) {\r\n            if (imagePack != null) {\r\n                imageResources = getResources(imagePack);\r\n            }\r\n            if (colorPack != null) {\r\n                colorResources = getResources(colorPack);\r\n            }\r\n            if (settingsPack != null) {\r\n                settingsResources = getResources(settingsPack);\r\n            }\r\n            skinPack = getDefaultResourcePack(SkinPack.class, SkinPack.RESOURCE_NAME_DEFAULT_VALUE);\r\n            if (skinPack != null) {\r\n                imageResources.putAll(skinPack.getImageResources());\r\n                colorResources.putAll(skinPack.getColorResources());\r\n                settingsResources.putAll(skinPack.getSettingsResources());\r\n            }\r\n            onSkinPackChanged();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetVideoTelephonyJabberImpl.getQualityControl",
	"Comment": "returns the quality control for video calls if any.return null so protocols who supports it to override it.",
	"Method": "QualityControl getQualityControl(CallPeer peer){\r\n    if (peer instanceof CallPeerJabberImpl)\r\n        return ((CallPeerJabberImpl) peer).getMediaHandler().getQualityControl();\r\n    else\r\n        return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.contactsourceconfig.ContactSourceConfigActivator.getResources",
	"Comment": "returns a reference to the resourcemanagementservice implementationcurrently registered in the bundle context or null if no suchimplementation was found.",
	"Method": "ResourceManagementService getResources(){\r\n    if (resources == null) {\r\n        resources = ResourceManagementServiceUtils.getService(bundleContext);\r\n    }\r\n    return resources;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.PresenceManager.verifyMessage",
	"Comment": "set new prepared away message for later moment when irc connection is setto away.",
	"Method": "String verifyMessage(String message){\r\n    if (message == null || message.isEmpty()) {\r\n        throw new IllegalArgumentException(\"away message must be non-null and non-empty\");\r\n    }\r\n    if (this.isupportAwayLen != null && message.length() > this.isupportAwayLen.intValue()) {\r\n        throw new IllegalArgumentException(\"the away message must not be longer than \" + this.isupportAwayLen.intValue() + \" characters according to server's parameters.\");\r\n    }\r\n    return message;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.advancedconfig.AdvancedConfigActivator.getConfigurationService",
	"Comment": "returns a reference to the configurationservice implementation currentlyregistered in the bundle context or null if no such implementation wasfound.",
	"Method": "ConfigurationService getConfigurationService(){\r\n    if (configurationService == null) {\r\n        configurationService = ServiceUtils.getService(bundleContext, ConfigurationService.class);\r\n    }\r\n    return configurationService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.ReceivedCallDialog.mergeCallButtonPressed",
	"Comment": "answers the call in an existing call when the existing callbutton has been pressed.",
	"Method": "void mergeCallButtonPressed(){\r\n    CallManager.answerCallInFirstExistingCall(incomingCall);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.GuiActivator.getAudioNotifier",
	"Comment": "returns the audionotifierservice obtained from the bundlecontext.",
	"Method": "AudioNotifierService getAudioNotifier(){\r\n    if (audioNotifierService == null) {\r\n        audioNotifierService = ServiceUtils.getService(bundleContext, AudioNotifierService.class);\r\n    }\r\n    return audioNotifierService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWindow.setTabIcon",
	"Comment": "sets the given icon to the tab opened for the given chat panel.",
	"Method": "void setTabIcon(ChatPanel chatPanel,Icon icon){\r\n    int index = this.chatTabbedPane.indexOfComponent(chatPanel);\r\n    if (index > -1)\r\n        this.chatTabbedPane.setIconAt(index, icon);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.PreCallDialog.actionPerformed",
	"Comment": "handles actionevents triggered by pressing the call or thehangup buttons.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    JButton button = (JButton) e.getSource();\r\n    String buttonName = button.getName();\r\n    if (buttonName.equals(CALL_BUTTON)) {\r\n        callButtonPressed();\r\n    } else if (buttonName.equals(CONF_CALL_BUTTON)) {\r\n        mergeCallButtonPressed();\r\n    } else if (buttonName.equals(VIDEO_CALL_BUTTON)) {\r\n        videoCallButtonPressed();\r\n    } else if (buttonName.equals(HANGUP_BUTTON)) {\r\n        hangupButtonPressed();\r\n    }\r\n    dispose();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.notifsource.NotificationGroup.isGroupCollapsed",
	"Comment": "returns false to indicate that this group is never collapsed.",
	"Method": "boolean isGroupCollapsed(){\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomJabberImpl.getMUCUserExtension",
	"Comment": "returns the mucuser packet extension included in the packet or null if none.",
	"Method": "MUCUser getMUCUserExtension(Packet packet){\r\n    if (packet != null) {\r\n        return (MUCUser) packet.getExtension(\"x\", \"http://jabber.org/protocol/muc#user\");\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.whiteboard.Resources.getString",
	"Comment": "returns an internationalized string corresponding to the given key.",
	"Method": "String getString(String key,String getString,String key,String[] params){\r\n    return getResources().getI18NString(key, params);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockOperationSetFileTransfer.sendFile",
	"Comment": "sends a file transfer request to the given tocontact byspecifying the local and remote file path and the fromcontact,sending the file.",
	"Method": "FileTransfer sendFile(Contact toContact,File file,FileTransfer sendFile,Contact toContact,Contact fromContact,String remotePath,String localPath){\r\n    return this.sendFile(toContact, new File(localPath));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.MetaUIContact.getContactDetails",
	"Comment": "returns a list of all uicontactdetails within thisuicontact.",
	"Method": "List<UIContactDetail> getContactDetails(){\r\n    List<UIContactDetail> resultList = new LinkedList<UIContactDetail>();\r\n    Iterator<Contact> contacts = metaContact.getContacts();\r\n    while (contacts.hasNext()) {\r\n        resultList.add(new MetaContactDetail(contacts.next()));\r\n    }\r\n    return resultList;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl.getAccountID",
	"Comment": "returns the accountid that uniquely identifies the account represented bythis instance of the protocolproviderservice.",
	"Method": "AccountID getAccountID(){\r\n    return accountID;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.msoutlook.calendar.CalendarItemTimerTask.start",
	"Comment": "this method is executed in the beginning of the calendar item.",
	"Method": "void start(){\r\n    calendarService.addToCurrentItems(this);\r\n    calendarService.updateStateFromCurrentItems();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.mailnotification.MailboxIQ.getThreadCount",
	"Comment": "returns the number of threads that are currently in thismailboxiq.",
	"Method": "int getThreadCount(){\r\n    return threads.size();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.dtmf.DTMFInfo.sayInfo",
	"Comment": "this is just a copy of the bye method from the opsetbasictelephony,which was enhanced with a body in order to send the dtmf tone",
	"Method": "void sayInfo(CallPeerSipImpl callPeer,DTMFTone dtmftone,long duration){\r\n    Request info = pps.getMessageFactory().createRequest(callPeer.getDialog(), Request.INFO);\r\n    ContentType ct = new ContentType(CONTENT_TYPE, CONTENT_SUB_TYPE);\r\n    String content = \"Signal=\" + dtmftone.getValue() + \"\\r\\nDuration=\" + duration + \"\\r\\n\";\r\n    ContentLength cl = new ContentLength(content.length());\r\n    info.setContentLength(cl);\r\n    try {\r\n        info.setContent(content.getBytes(), ct);\r\n    } catch (ParseException ex) {\r\n        logger.error(\"Failed to construct the INFO request\", ex);\r\n        throw new OperationFailedException(\"Failed to construct a client the INFO request\", OperationFailedException.INTERNAL_ERROR, ex);\r\n    }\r\n    ClientTransaction clientTransaction = null;\r\n    try {\r\n        clientTransaction = callPeer.getJainSipProvider().getNewClientTransaction(info);\r\n    } catch (TransactionUnavailableException ex) {\r\n        logger.error(\"Failed to construct a client transaction from the INFO request\", ex);\r\n        throw new OperationFailedException(\"Failed to construct a client transaction from the INFO request\", OperationFailedException.INTERNAL_ERROR, ex);\r\n    }\r\n    try {\r\n        if (callPeer.getDialog().getState() == DialogState.TERMINATED) {\r\n            logger.warn(\"Trying to send a dtmf tone inside a \" + \"TERMINATED dialog.\");\r\n            return;\r\n        }\r\n        callPeer.getDialog().sendRequest(clientTransaction);\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"sent request:\\n\" + info);\r\n    } catch (SipException ex) {\r\n        throw new OperationFailedException(\"Failed to send the INFO request\", OperationFailedException.NETWORK_FAILURE, ex);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractCallPeer.getAlternativeIMPPAddress",
	"Comment": "returns an alternative impp address corresponding to thiscallpeer.",
	"Method": "String getAlternativeIMPPAddress(){\r\n    return alternativeIMPPAddress;\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.SaveOptimizeTest.testNoCacheWithSaveOptimization",
	"Comment": "test that if we turn off caching of the session, then if a saveperiodis set, the session is still not saved unless the saveperiod expires.",
	"Method": "void testNoCacheWithSaveOptimization(){\r\n    String contextPath = \"\";\r\n    String servletMapping = \"/server\";\r\n    int inactivePeriod = -1;\r\n    int scavengePeriod = -1;\r\n    int savePeriod = 10;\r\n    NullSessionCacheFactory cacheFactory = new NullSessionCacheFactory();\r\n    cacheFactory.setSaveOnCreate(true);\r\n    TestSessionDataStoreFactory storeFactory = new TestSessionDataStoreFactory();\r\n    storeFactory.setSavePeriodSec(savePeriod);\r\n    _server1 = new TestServer(0, inactivePeriod, scavengePeriod, cacheFactory, storeFactory);\r\n    _servlet = new TestServlet();\r\n    ServletHolder holder = new ServletHolder(_servlet);\r\n    ServletContextHandler contextHandler = _server1.addContext(contextPath);\r\n    contextHandler.addServlet(holder, servletMapping);\r\n    _servlet.setStore(contextHandler.getSessionHandler().getSessionCache().getSessionDataStore());\r\n    _server1.start();\r\n    int port1 = _server1.getPort();\r\n    try (StacklessLogging stackless = new StacklessLogging(Log.getLogger(\"org.eclipse.jetty.server.session\"))) {\r\n        HttpClient client = new HttpClient();\r\n        try {\r\n            client.start();\r\n            String url = \"http://localhost:\" + port1 + contextPath + servletMapping + \"?action=create&check=true\";\r\n            ContentResponse response = client.GET(url);\r\n            assertEquals(HttpServletResponse.SC_OK, response.getStatus());\r\n            String sessionCookie = response.getHeaders().get(\"Set-Cookie\");\r\n            assertNotNull(sessionCookie);\r\n            String sessionId = TestServer.extractSessionId(sessionCookie);\r\n            SessionData data = contextHandler.getSessionHandler().getSessionCache().getSessionDataStore().load(sessionId);\r\n            assertNotNull(data);\r\n            long lastSaved = data.getLastSaved();\r\n            assertTrue(lastSaved > 0);\r\n            client.newRequest(\"http://localhost:\" + port1 + contextPath + servletMapping + \"?action=noop&check=diff\").send();\r\n            SessionData d = contextHandler.getSessionHandler().getSessionCache().getSessionDataStore().load(sessionId);\r\n            assertNotNull(d);\r\n            assertEquals(lastSaved, d.getLastSaved());\r\n        } finally {\r\n            client.stop();\r\n        }\r\n    } finally {\r\n        _server1.stop();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.history.HistoryServiceImpl.isHistoryCreated",
	"Comment": "checks whether a history is created and stored.exists in the file system.",
	"Method": "boolean isHistoryCreated(HistoryID id){\r\n    return getDirForHistory(id).exists();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.generalconfig.WindowsStartup.setAutostart",
	"Comment": "creates or deletes registry key for application autostart.",
	"Method": "void setAutostart(String appName,String workingDirectory,boolean isAutoStart){\r\n    if (isAutoStart) {\r\n        String executableFileName = null;\r\n        String filePath = getModuleFilename();\r\n        if (filePath != null && filePath.length() > 0) {\r\n            int ix = filePath.lastIndexOf(File.separatorChar);\r\n            if (ix > 0)\r\n                executableFileName = filePath.substring(ix + 1);\r\n        }\r\n        if (executableFileName == null) {\r\n            logger.warn(\"Missing information for process, \" + \"shortcut will be created any way using defaults.\");\r\n            executableFileName = appName.replaceAll(\" \", \"\").replaceAll(\"_\", \"\").replaceAll(\"-\", \"\") + \".exe\";\r\n        }\r\n        Advapi32Util.registrySetStringValue(WinReg.HKEY_CURRENT_USER, REGISTRY_STARTUP_KEY, appName, workingDirectory + File.separator + executableFileName);\r\n    } else {\r\n        try {\r\n            Advapi32Util.registryDeleteValue(WinReg.HKEY_CURRENT_USER, REGISTRY_STARTUP_KEY, appName);\r\n        } catch (Throwable t) {\r\n            logger.warn(\"Cannot remove startup key or don't exist\", t);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.WhiteboardSessionJabberImpl.addWhiteboardObjectListener",
	"Comment": "registers listener so that it would receive events every time anew whiteboardobject is received on this whiteboard.",
	"Method": "void addWhiteboardObjectListener(WhiteboardObjectListener listener){\r\n    synchronized (messageListeners) {\r\n        if (!messageListeners.contains(listener)) {\r\n            this.messageListeners.add(listener);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.whiteboard.WhiteboardObjectPathJabberImpl.getPoints",
	"Comment": "returns a list of all the whiteboardpoint instances that thiswhiteboardobject is composed of.",
	"Method": "List<WhiteboardPoint> getPoints(){\r\n    return this.listPoints;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.CallConference.callStateChanged",
	"Comment": "notifies this telephony conference that the callstate of acall has changed.",
	"Method": "void callStateChanged(CallChangeEvent ev){\r\n    Call call = ev.getSourceCall();\r\n    if (containsCall(call)) {\r\n        try {\r\n            for (CallChangeListener l : getCallChangeListeners()) l.callStateChanged(ev);\r\n        } finally {\r\n            if (CallChangeEvent.CALL_STATE_CHANGE.equals(ev.getPropertyName()) && CallState.CALL_ENDED.equals(ev.getNewValue())) {\r\n                removeCall(call);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.neomedia.codec.video.h264.ConfigurationPanel.addActionListener",
	"Comment": "adds an actionlistener to a specific jcomboboxpopulated with namevaluepairs which sets the value of a specificconfigurationservice property to the value of theselected namevaluepair of the combobox.",
	"Method": "void addActionListener(JComboBox comboBox,String property){\r\n    comboBox.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent e) {\r\n            NameValuePair nameValuePair = (NameValuePair) comboBox.getSelectedItem();\r\n            if (nameValuePair != null) {\r\n                NeomediaActivator.getConfigurationService().setProperty(property, nameValuePair.value);\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.neomedia.codec.video.h264.ConfigurationPanel.addActionListener",
	"Comment": "adds an actionlistener to a specific jcomboboxpopulated with namevaluepairs which sets the value of a specificconfigurationservice property to the value of theselected namevaluepair of the combobox.",
	"Method": "void addActionListener(JComboBox comboBox,String property){\r\n    NameValuePair nameValuePair = (NameValuePair) comboBox.getSelectedItem();\r\n    if (nameValuePair != null) {\r\n        NeomediaActivator.getConfigurationService().setProperty(property, nameValuePair.value);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.FileUtils.download",
	"Comment": "downloads a remote file specified by its url into a local file.",
	"Method": "File download(String url,String preferredFileName,String preferredExtension){\r\n    final File[] tempFile = new File[1];\r\n    FileOutputStream tempFileOutputStream = null;\r\n    boolean deleteTempFile = true;\r\n    tempFileOutputStream = createTempFileOutputStream(new URL(url), null, false, tempFile, preferredFileName, preferredExtension);\r\n    try {\r\n        HttpUtils.HTTPResponseResult res = HttpUtils.openURLConnection(url);\r\n        if (res != null) {\r\n            InputStream content = res.getContent();\r\n            ProgressMonitorInputStream input = new ProgressMonitorInputStream(null, url, content);\r\n            input.getProgressMonitor().setMaximum((int) res.getContentLength());\r\n            try {\r\n                final BufferedOutputStream output = new BufferedOutputStream(tempFileOutputStream);\r\n                try {\r\n                    int read = -1;\r\n                    byte[] buff = new byte[1024];\r\n                    while ((read = input.read(buff)) != -1) output.write(buff, 0, read);\r\n                } finally {\r\n                    output.close();\r\n                    tempFileOutputStream = null;\r\n                }\r\n                deleteTempFile = false;\r\n            } finally {\r\n                try {\r\n                    input.close();\r\n                } catch (IOException ioe) {\r\n                }\r\n            }\r\n        }\r\n    } finally {\r\n        try {\r\n            if (tempFileOutputStream != null)\r\n                tempFileOutputStream.close();\r\n        } finally {\r\n            if (deleteTempFile && (tempFile[0] != null)) {\r\n                tempFile[0].delete();\r\n                tempFile[0] = null;\r\n            }\r\n        }\r\n    }\r\n    return tempFile[0];\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.statusChanged",
	"Comment": "handles file transfer status changed in order to remove completed filetransfers from the list of active transfers.",
	"Method": "void statusChanged(FileTransferStatusChangeEvent event){\r\n    FileTransfer fileTransfer = event.getFileTransfer();\r\n    int newStatus = event.getNewStatus();\r\n    if (newStatus == FileTransferStatusChangeEvent.COMPLETED || newStatus == FileTransferStatusChangeEvent.CANCELED || newStatus == FileTransferStatusChangeEvent.FAILED || newStatus == FileTransferStatusChangeEvent.REFUSED) {\r\n        removeActiveFileTransfer(fileTransfer.getID());\r\n        fileTransfer.removeStatusListener(this);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactListServiceImpl.clearUserDefinedDisplayName",
	"Comment": "resets display name of the metacontact to show the value fromthe underlying contacts.",
	"Method": "void clearUserDefinedDisplayName(MetaContact metaContact){\r\n    if (!(metaContact instanceof MetaContactImpl)) {\r\n        throw new IllegalArgumentException(metaContact + \" is not a MetaContactImpl instance.\");\r\n    }\r\n    ((MetaContactImpl) metaContact).setDisplayNameUserDefined(false);\r\n    if (metaContact.getContactCount() == 1) {\r\n        renameMetaContact(metaContact, metaContact.getDefaultContact().getDisplayName(), false);\r\n    } else {\r\n        fireMetaContactEvent(new MetaContactRenamedEvent(metaContact, metaContact.getDisplayName(), metaContact.getDisplayName()));\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockChatRoom.removeMemberRoleListener",
	"Comment": "removes a listener that was being notified of changes of a member role inthis chat room such as us being granded operator.",
	"Method": "void removeMemberRoleListener(ChatRoomMemberRoleListener listener){\r\n    memberRoleListeners.remove(listener);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.credentialsstorage.CredentialsStorageServiceImpl.writeVerificationValue",
	"Comment": "writes the verification value to the configuration for later use orremoves it completely depending on the remove flag argument.",
	"Method": "void writeVerificationValue(boolean remove){\r\n    if (remove)\r\n        configurationService.removeProperty(MASTER_PROP);\r\n    else {\r\n        try {\r\n            configurationService.setProperty(MASTER_PROP, crypto.encrypt(MASTER_PROP_VALUE));\r\n        } catch (CryptoException cex) {\r\n            logger.error(\"Failed to encrypt and write verification value\", cex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetServerStoredAccountInfoIcqImpl.getMaxDetailInstances",
	"Comment": "the method returns the number of instances supported for a particulardetail type.",
	"Method": "int getMaxDetailInstances(Class<? extends GenericDetail> detailClass){\r\n    return supportedTypes.get(detailClass)[0];\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.presence.NewStatusMessageDialog.close",
	"Comment": "artificially clicks the cancel button when this panel is escaped.",
	"Method": "void close(boolean isEscaped){\r\n    if (isEscaped)\r\n        cancelButton.doClick();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.metahistory.MetaHistoryServiceImpl.addSearchProgressListener",
	"Comment": "adding progress listener for monitoring progress of search process",
	"Method": "void addSearchProgressListener(HistorySearchProgressListener listener){\r\n    synchronized (progressListeners) {\r\n        if (!progressListeners.contains(listener))\r\n            progressListeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.UtilActivator.getResources",
	"Comment": "returns the service giving access to all application resources.",
	"Method": "ResourceManagementService getResources(){\r\n    if (resourceService == null) {\r\n        resourceService = ResourceManagementServiceUtils.getService(bundleContext);\r\n    }\r\n    return resourceService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.usersearch.UserSearchActivator.initUserSearchProviders",
	"Comment": "initializes a list of all currently providers and a list with theproviders that support user search.",
	"Method": "void initUserSearchProviders(){\r\n    if (userSearchProviders != null)\r\n        return;\r\n    userSearchProviders = new LinkedList<ProtocolProviderService>();\r\n    bundleContext.addServiceListener(new ProtocolProviderRegListener());\r\n    ServiceReference[] serRefs = null;\r\n    try {\r\n        serRefs = bundleContext.getServiceReferences(ProtocolProviderFactory.class.getName(), null);\r\n    } catch (InvalidSyntaxException e) {\r\n        logger.error(\"LoginManager : \" + e);\r\n    }\r\n    if (serRefs != null) {\r\n        for (ServiceReference serRef : serRefs) {\r\n            ProtocolProviderFactory providerFactory = (ProtocolProviderFactory) bundleContext.getService(serRef);\r\n            ProtocolProviderService protocolProvider;\r\n            for (AccountID accountID : providerFactory.getRegisteredAccounts()) {\r\n                serRef = providerFactory.getProviderForAccount(accountID);\r\n                protocolProvider = (ProtocolProviderService) bundleContext.getService(serRef);\r\n                handleProviderAdded(protocolProvider);\r\n            }\r\n        }\r\n    }\r\n    return;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomJabberImpl.smackParticipantToScMember",
	"Comment": "returns the chatroommember corresponding to the given smackparticipant.",
	"Method": "ChatRoomMemberJabberImpl smackParticipantToScMember(String participant){\r\n    String participantName = StringUtils.parseResource(participant);\r\n    synchronized (members) {\r\n        Iterator<ChatRoomMemberJabberImpl> chatRoomMembers = this.members.values().iterator();\r\n        while (chatRoomMembers.hasNext()) {\r\n            ChatRoomMemberJabberImpl member = chatRoomMembers.next();\r\n            if (participantName.equals(member.getName()) || participant.equals(member.getContactAddress()) || participantName.equals(member.getContactAddress()))\r\n                return member;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ChatContactCellRenderer.getStatusMessage",
	"Comment": "returns the first found status message for the givenmetacontact.",
	"Method": "String getStatusMessage(MetaContact metaContact){\r\n    Iterator<Contact> protoContacts = metaContact.getContacts();\r\n    while (protoContacts.hasNext()) {\r\n        Contact protoContact = protoContacts.next();\r\n        String statusMessage = protoContact.getStatusMessage();\r\n        if (statusMessage != null && statusMessage.length() > 0)\r\n            return statusMessage;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.call.MetaContactPhoneUtil.getPhones",
	"Comment": "list of phones for contact, localized if localized istrue, and not otherwise.return null if we have stopped searching and a listener is availableand will be used to inform for results.",
	"Method": "List<String> getPhones(Contact contact,List<String> getPhones,Contact contact,DetailsResponseListener listener,boolean localized){\r\n    if (!this.metaContact.containsContact(contact)) {\r\n        return new ArrayList<String>();\r\n    }\r\n    if (phones.containsKey(contact)) {\r\n        return phones.get(contact);\r\n    }\r\n    List<String> phonesList = ContactPhoneUtil.getContactAdditionalPhones(contact, listener, false, localized);\r\n    if (phonesList == null)\r\n        return null;\r\n    else if (phonesList.size() > 0)\r\n        hasPhones = true;\r\n    phones.put(contact, phonesList);\r\n    return phonesList;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.aimaccregwizz.AimAccountRegistrationWizard.getRegistration",
	"Comment": "returns the registration object, which will store all the data throughthe wizard.",
	"Method": "AimAccountRegistration getRegistration(){\r\n    return registration;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.TreeContactList.setActiveContact",
	"Comment": "updates the active state of the contact node corresponding to the givenmetacontact.",
	"Method": "void setActiveContact(MetaContact metaContact,boolean isActive){\r\n    UIContactImpl uiContact;\r\n    synchronized (metaContact) {\r\n        uiContact = MetaContactListSource.getUIContact(metaContact);\r\n        if (uiContact == null)\r\n            return;\r\n    }\r\n    ContactNode contactNode;\r\n    synchronized (uiContact) {\r\n        contactNode = uiContact.getContactNode();\r\n        if (contactNode == null)\r\n            return;\r\n    }\r\n    contactNode.setActive(isActive);\r\n    if (isActive) {\r\n        activeContacts.add(contactNode);\r\n    } else\r\n        activeContacts.remove(contactNode);\r\n    treeModel.nodeChanged(contactNode);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.MetaContactListSource.metaContactModified",
	"Comment": "notifies the tree model, when a metacontact has beenmodified in the metacontactlistservice.",
	"Method": "void metaContactModified(MetaContactModifiedEvent evt){\r\n    MetaContact metaContact = evt.getSourceMetaContact();\r\n    UIContactImpl uiContact;\r\n    synchronized (metaContact) {\r\n        uiContact = MetaContactListSource.getUIContact(metaContact);\r\n        if (uiContact == null)\r\n            return;\r\n    }\r\n    synchronized (uiContact) {\r\n        ContactNode contactNode = uiContact.getContactNode();\r\n        if (contactNode != null)\r\n            GuiActivator.getContactList().nodeChanged(contactNode);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.utils.OneChoiceInviteDialog.setInfoText",
	"Comment": "sets the information text explaining how to use the containing form.",
	"Method": "void setInfoText(String text){\r\n    infoTextArea.setText(text);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatContactRightButtonMenu.actionPerformed",
	"Comment": "handles the actionevent. determines which menu item wasselected and makes the appropriate operations.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    String menuItemName = ((JMenuItem) e.getSource()).getName();\r\n    if (menuItemName.equals(\"kickItem\")) {\r\n        ChatOperationReasonDialog reasonDialog = new ChatOperationReasonDialog();\r\n        int result = new ChatOperationReasonDialog().showDialog();\r\n        if (result == MessageDialog.OK_RETURN_CODE)\r\n            new KickParticipantThread(room, reasonDialog.getReason()).start();\r\n    } else if (menuItemName.equals(\"banItem\")) {\r\n        ChatOperationReasonDialog reasonDialog = new ChatOperationReasonDialog();\r\n        int result = reasonDialog.showDialog();\r\n        if (result == MessageDialog.OK_RETURN_CODE)\r\n            new BanParticipantThread(room, reasonDialog.getReason()).start();\r\n    } else if (menuItemName.equals(\"changeRoomSubjectItem\")) {\r\n        ChatOperationReasonDialog reasonDialog = new ChatOperationReasonDialog(chatPanel.getChatContainer().getFrame(), GuiActivator.getResources().getI18NString(\"service.gui.CHANGE_ROOM_SUBJECT\"), GuiActivator.getResources().getI18NString(\"service.gui.CHANGE_ROOM_SUBJECT_LABEL\"), \"Ok\", false);\r\n        reasonDialog.setReasonFieldText(room.getSubject());\r\n        int result = reasonDialog.showDialog();\r\n        if (result == MessageDialog.OK_RETURN_CODE) {\r\n            try {\r\n                room.setSubject(reasonDialog.getReason().trim());\r\n            } catch (OperationFailedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n        }\r\n    } else if (menuItemName.equals(\"changeNicknameItem\")) {\r\n        ChatOperationReasonDialog reasonDialog = new ChatOperationReasonDialog(chatPanel.getChatContainer().getFrame(), GuiActivator.getResources().getI18NString(\"service.gui.CHANGE_NICKNAME\"), GuiActivator.getResources().getI18NString(\"service.gui.CHANGE_NICKNAME_LABEL\"), \"Ok\", false, true);\r\n        reasonDialog.setIconImage(ImageLoader.getImage(ImageLoader.CHANGE_NICKNAME_ICON));\r\n        reasonDialog.setReasonFieldText(chatContact.getName());\r\n        int result = reasonDialog.showDialog();\r\n        if (result == MessageDialog.OK_RETURN_CODE) {\r\n            String nickname = reasonDialog.getReason().trim();\r\n            try {\r\n                room.setUserNickname(nickname);\r\n                ConfigurationUtils.updateChatRoomProperty(room.getParentProvider(), room.getIdentifier(), \"userNickName\", nickname);\r\n            } catch (OperationFailedException ex) {\r\n                String errorMessage = null;\r\n                if (ex.getErrorCode() == OperationFailedException.IDENTIFICATION_CONFLICT) {\r\n                    errorMessage = GuiActivator.getResources().getI18NString(\"service.gui.CHANGE_NICKNAME_CONFLICT_ERROR\");\r\n                } else {\r\n                    errorMessage = ex.getLocalizedMessage();\r\n                }\r\n                chatPanel.addErrorMessage(nickname, GuiActivator.getResources().getI18NString(\"service.gui.CHANGE_NICKNAME_ERROR\"), errorMessage);\r\n            }\r\n        }\r\n    } else if (menuItemName.equals(\"grantVoiceItem\")) {\r\n        room.grantVoice(chatContact.getName());\r\n        ((ChatRoomMember) chatContact.getDescriptor()).setRole(ChatRoomMemberRole.MEMBER);\r\n    } else if (menuItemName.equals(\"grantMembershipItem\")) {\r\n        room.grantMembership(((ChatRoomMember) chatContact.getDescriptor()).getContactAddress());\r\n        ((ChatRoomMember) chatContact.getDescriptor()).setRole(ChatRoomMemberRole.MEMBER);\r\n    } else if (menuItemName.equals(\"grantModeratorItem\")) {\r\n        room.grantModerator(chatContact.getName());\r\n        ((ChatRoomMember) chatContact.getDescriptor()).setRole(ChatRoomMemberRole.MODERATOR);\r\n    } else if (menuItemName.equals(\"grantAdminItem\")) {\r\n        room.grantAdmin(((ChatRoomMember) chatContact.getDescriptor()).getContactAddress());\r\n        ((ChatRoomMember) chatContact.getDescriptor()).setRole(ChatRoomMemberRole.ADMINISTRATOR);\r\n    } else if (menuItemName.equals(\"grantOwnershipItem\")) {\r\n        room.grantOwnership(((ChatRoomMember) chatContact.getDescriptor()).getContactAddress());\r\n        ((ChatRoomMember) chatContact.getDescriptor()).setRole(ChatRoomMemberRole.OWNER);\r\n    } else if (menuItemName.equals(\"revokeOwnershipItem\")) {\r\n        room.revokeOwnership(((ChatRoomMember) chatContact.getDescriptor()).getContactAddress());\r\n        ((ChatRoomMember) chatContact.getDescriptor()).setRole(ChatRoomMemberRole.ADMINISTRATOR);\r\n    } else if (menuItemName.equals(\"revokeAdminItem\")) {\r\n        room.revokeAdmin(((ChatRoomMember) chatContact.getDescriptor()).getContactAddress());\r\n        ((ChatRoomMember) chatContact.getDescriptor()).setRole(ChatRoomMemberRole.MEMBER);\r\n    } else if (menuItemName.equals(\"revokeModeratorItem\")) {\r\n        room.revokeModerator(chatContact.getName());\r\n        ((ChatRoomMember) chatContact.getDescriptor()).setRole(ChatRoomMemberRole.MEMBER);\r\n    } else if (menuItemName.equals(\"revokeMembershipItem\")) {\r\n        room.revokeMembership(((ChatRoomMember) chatContact.getDescriptor()).getContactAddress());\r\n        ((ChatRoomMember) chatContact.getDescriptor()).setRole(ChatRoomMemberRole.GUEST);\r\n    } else if (menuItemName.equals(\"revokeVoiceItem\")) {\r\n        room.revokeVoice(chatContact.getName());\r\n        ((ChatRoomMember) chatContact.getDescriptor()).setRole(ChatRoomMemberRole.SILENT_MEMBER);\r\n    } else if (menuItemName.equals(\"sendPrivateMessageItem\")) {\r\n        ChatWindowManager chatWindowManager = GuiActivator.getUIService().getChatWindowManager();\r\n        chatWindowManager.openPrivateChatForChatRoomMember(room, chatContact.getName());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.WhiteboardParticipantJabberImpl.addWhiteboardParticipantListener",
	"Comment": "allows the user interface to register a listener interested in changes",
	"Method": "void addWhiteboardParticipantListener(WhiteboardParticipantListener listener){\r\n    synchronized (whiteboardParticipantListeners) {\r\n        if (!whiteboardParticipantListeners.contains(listener))\r\n            this.whiteboardParticipantListeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.ContactGroupGibberishImpl.getContact",
	"Comment": "returns the contact with the specified address or identifier.",
	"Method": "Contact getContact(String id){\r\n    Iterator<Contact> contactsIter = contacts();\r\n    while (contactsIter.hasNext()) {\r\n        Contact contact = contactsIter.next();\r\n        if (contact.getAddress().equals(id))\r\n            return contact;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.InfoRetreiver.retrieveDetails",
	"Comment": "retrieve details and return them or if missing return an empty list.",
	"Method": "List<GenericDetail> retrieveDetails(String contactAddress){\r\n    List<GenericDetail> result = new LinkedList<GenericDetail>();\r\n    try {\r\n        Connection connection = jabberProvider.getConnection();\r\n        if (connection == null || !connection.isAuthenticated())\r\n            return null;\r\n        VCard card = new VCard();\r\n        if (vcardTimeoutReply == -1 || vcardTimeoutReply == SmackConfiguration.getPacketReplyTimeout())\r\n            card.load(connection, contactAddress);\r\n        else\r\n            load(card, connection, contactAddress, vcardTimeoutReply);\r\n        String tmp;\r\n        tmp = checkForFullName(card);\r\n        if (tmp != null)\r\n            result.add(new DisplayNameDetail(StringEscapeUtils.unescapeXml(tmp)));\r\n        tmp = card.getFirstName();\r\n        if (tmp != null)\r\n            result.add(new FirstNameDetail(StringEscapeUtils.unescapeXml(tmp)));\r\n        tmp = card.getMiddleName();\r\n        if (tmp != null)\r\n            result.add(new MiddleNameDetail(StringEscapeUtils.unescapeXml(tmp)));\r\n        tmp = card.getLastName();\r\n        if (tmp != null)\r\n            result.add(new LastNameDetail(StringEscapeUtils.unescapeXml(tmp)));\r\n        tmp = card.getNickName();\r\n        if (tmp != null)\r\n            result.add(new NicknameDetail(StringEscapeUtils.unescapeXml(tmp)));\r\n        tmp = card.getField(\"BDAY\");\r\n        if (tmp != null) {\r\n            try {\r\n                Calendar birthDateCalendar = Calendar.getInstance();\r\n                DateFormat dateFormat = new SimpleDateFormat(JabberActivator.getResources().getI18NString(\"plugin.accountinfo.BDAY_FORMAT\"));\r\n                Date birthDate = dateFormat.parse(tmp);\r\n                birthDateCalendar.setTime(birthDate);\r\n                BirthDateDetail bd = new BirthDateDetail(birthDateCalendar);\r\n                result.add(bd);\r\n            } catch (ParseException e) {\r\n            }\r\n        }\r\n        tmp = card.getAddressFieldHome(\"STREET\");\r\n        if (tmp != null)\r\n            result.add(new AddressDetail(tmp));\r\n        tmp = card.getAddressFieldHome(\"LOCALITY\");\r\n        if (tmp != null)\r\n            result.add(new CityDetail(tmp));\r\n        tmp = card.getAddressFieldHome(\"REGION\");\r\n        if (tmp != null)\r\n            result.add(new ProvinceDetail(tmp));\r\n        tmp = card.getAddressFieldHome(\"PCODE\");\r\n        if (tmp != null)\r\n            result.add(new PostalCodeDetail(tmp));\r\n        tmp = card.getAddressFieldHome(\"CTRY\");\r\n        if (tmp != null)\r\n            result.add(new CountryDetail(tmp));\r\n        tmp = card.getPhoneHome(\"VOICE\");\r\n        if (tmp != null)\r\n            result.add(new PhoneNumberDetail(tmp));\r\n        tmp = card.getPhoneHome(\"VIDEO\");\r\n        if (tmp != null)\r\n            result.add(new VideoDetail(tmp));\r\n        tmp = card.getPhoneHome(\"FAX\");\r\n        if (tmp != null)\r\n            result.add(new FaxDetail(tmp));\r\n        tmp = card.getPhoneHome(\"PAGER\");\r\n        if (tmp != null)\r\n            result.add(new PagerDetail(tmp));\r\n        tmp = card.getPhoneHome(\"CELL\");\r\n        if (tmp != null)\r\n            result.add(new MobilePhoneDetail(tmp));\r\n        tmp = card.getPhoneHome(\"TEXT\");\r\n        if (tmp != null)\r\n            result.add(new MobilePhoneDetail(tmp));\r\n        tmp = card.getEmailHome();\r\n        if (tmp != null)\r\n            result.add(new EmailAddressDetail(tmp));\r\n        tmp = card.getAddressFieldWork(\"STREET\");\r\n        if (tmp != null)\r\n            result.add(new WorkAddressDetail(tmp));\r\n        tmp = card.getAddressFieldWork(\"LOCALITY\");\r\n        if (tmp != null)\r\n            result.add(new WorkCityDetail(tmp));\r\n        tmp = card.getAddressFieldWork(\"REGION\");\r\n        if (tmp != null)\r\n            result.add(new WorkProvinceDetail(tmp));\r\n        tmp = card.getAddressFieldWork(\"PCODE\");\r\n        if (tmp != null)\r\n            result.add(new WorkPostalCodeDetail(tmp));\r\n        tmp = card.getPhoneWork(\"VOICE\");\r\n        if (tmp != null)\r\n            result.add(new WorkPhoneDetail(tmp));\r\n        tmp = card.getPhoneWork(\"VIDEO\");\r\n        if (tmp != null)\r\n            result.add(new WorkVideoDetail(tmp));\r\n        tmp = card.getPhoneWork(\"FAX\");\r\n        if (tmp != null)\r\n            result.add(new WorkFaxDetail(tmp));\r\n        tmp = card.getPhoneWork(\"PAGER\");\r\n        if (tmp != null)\r\n            result.add(new WorkPagerDetail(tmp));\r\n        tmp = card.getPhoneWork(\"CELL\");\r\n        if (tmp != null)\r\n            result.add(new WorkMobilePhoneDetail(tmp));\r\n        tmp = card.getPhoneWork(\"TEXT\");\r\n        if (tmp != null)\r\n            result.add(new WorkMobilePhoneDetail(tmp));\r\n        tmp = card.getEmailWork();\r\n        if (tmp != null)\r\n            result.add(new WorkEmailAddressDetail(tmp));\r\n        tmp = card.getOrganization();\r\n        if (tmp != null)\r\n            result.add(new WorkOrganizationNameDetail(tmp));\r\n        tmp = card.getOrganizationUnit();\r\n        if (tmp != null)\r\n            result.add(new WorkDepartmentNameDetail(tmp));\r\n        tmp = card.getField(\"TITLE\");\r\n        if (tmp != null)\r\n            result.add(new JobTitleDetail(tmp));\r\n        tmp = card.getField(\"ABOUTME\");\r\n        if (tmp != null)\r\n            result.add(new AboutMeDetail(tmp));\r\n        byte[] imageBytes = card.getAvatar();\r\n        if (imageBytes != null && imageBytes.length > 0) {\r\n            result.add(new ImageDetail(\"Image\", imageBytes));\r\n        }\r\n        try {\r\n            tmp = card.getField(\"URL\");\r\n            if (tmp != null)\r\n                result.add(new URLDetail(\"URL\", new URL(tmp)));\r\n        } catch (MalformedURLException e) {\r\n        }\r\n    } catch (Throwable exc) {\r\n        String msg = \"Cannot load details for contact \" + contactAddress + \" : \" + exc.getMessage();\r\n        if (logger.isTraceEnabled())\r\n            logger.error(msg, exc);\r\n        else\r\n            logger.error(msg);\r\n    }\r\n    retreivedDetails.put(contactAddress, result);\r\n    return result;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.CallJabberImpl.processColibriConferenceIQ",
	"Comment": "notifies this instance that a specific colibriconferenceiq hasbeen received.",
	"Method": "boolean processColibriConferenceIQ(ColibriConferenceIQ conferenceIQ){\r\n    if (colibri == null) {\r\n        return false;\r\n    } else if (conferenceIQ.getID().equals(colibri.getID())) {\r\n        for (MediaType mediaType : MediaType.values()) {\r\n            String contentName = mediaType.toString();\r\n            ColibriConferenceIQ.Content content = conferenceIQ.getContent(contentName);\r\n            if (content != null) {\r\n                ColibriConferenceIQ.Content thisContent = colibri.getContent(contentName);\r\n                if ((thisContent != null) && (thisContent.getChannelCount() > 0)) {\r\n                    ColibriConferenceIQ.Channel thisChannel = thisContent.getChannel(0);\r\n                    ColibriConferenceIQ.Channel channel = content.getChannel(thisChannel.getID());\r\n                    if (channel != null)\r\n                        content.removeChannel(channel);\r\n                }\r\n            }\r\n        }\r\n        for (CallPeerJabberImpl callPeer : getCallPeerList()) callPeer.processColibriConferenceIQ(conferenceIQ);\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AccountID.loadStunPassword",
	"Comment": "returns the password for the stun server with the specified prefix.",
	"Method": "String loadStunPassword(BundleContext bundleContext,AccountID accountID,String namePrefix){\r\n    ProtocolProviderFactory providerFactory = ProtocolProviderFactory.getProtocolProviderFactory(bundleContext, accountID.getSystemProtocolName());\r\n    String password = null;\r\n    String className = providerFactory.getClass().getName();\r\n    String packageSourceName = className.substring(0, className.lastIndexOf('.'));\r\n    String accountPrefix = ProtocolProviderFactory.findAccountPrefix(bundleContext, accountID, packageSourceName);\r\n    CredentialsStorageService credentialsService = ServiceUtils.getService(bundleContext, CredentialsStorageService.class);\r\n    try {\r\n        password = credentialsService.loadPassword(accountPrefix + \".\" + namePrefix);\r\n    } catch (Exception e) {\r\n        return null;\r\n    }\r\n    return password;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatSession.getChatConfigurationForm",
	"Comment": "returns the configuration form corresponding to the chat room.",
	"Method": "ChatRoomConfigurationForm getChatConfigurationForm(){\r\n    return chatRoomWrapper.getChatRoom().getConfigurationForm();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.branding.BrandingActivator.start",
	"Comment": "the dependent service is available and the bundle will start.",
	"Method": "void start(Object dependentService){\r\n    registerMenuEntry((UIService) dependentService);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.colibri.ColibriIQProvider.throwAway",
	"Comment": "parses using a specific xmlpullparser and ignores xml contentpresuming that the specified parser is currently at the starttag of an element with a specific name and throwing away until the endtag with the specified name is encountered.",
	"Method": "void throwAway(XmlPullParser parser,String name){\r\n    while ((XmlPullParser.END_TAG != parser.next()) || !name.equals(parser.getName())) ;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockChatRoomMember.getAvatar",
	"Comment": "returns the avatar of this member, that can be used when including it inuser interface.",
	"Method": "byte[] getAvatar(){\r\n    return avatar;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl.initialize",
	"Comment": "initializes the service implementation, and puts it in a state where itcould interoperate with other services.",
	"Method": "void initialize(String sipAddress,SipAccountIDImpl accountID){\r\n    synchronized (initializationLock) {\r\n        this.accountID = accountID;\r\n        String protocolIconPath = accountID.getAccountPropertyString(ProtocolProviderFactory.PROTOCOL_ICON_PATH);\r\n        if (protocolIconPath == null)\r\n            protocolIconPath = \"resources/images/protocol/sip\";\r\n        this.protocolIcon = new ProtocolIconSipImpl(protocolIconPath);\r\n        this.sipStatusEnum = new SipStatusEnum(protocolIconPath);\r\n        if (sipStackSharing == null)\r\n            sipStackSharing = new SipStackSharing();\r\n        boolean enablePresence = accountID.getAccountPropertyBoolean(ProtocolProviderFactory.IS_PRESENCE_ENABLED, true);\r\n        boolean forceP2P = accountID.getAccountPropertyBoolean(ProtocolProviderFactory.FORCE_P2P_MODE, true);\r\n        int pollingValue = accountID.getAccountPropertyInt(ProtocolProviderFactory.POLLING_PERIOD, 30);\r\n        int subscriptionExpiration = accountID.getAccountPropertyInt(ProtocolProviderFactory.SUBSCRIPTION_EXPIRATION, 3600);\r\n        headerFactory = new HeaderFactoryImpl();\r\n        addressFactory = new AddressFactoryImpl();\r\n        ourDisplayName = accountID.getAccountPropertyString(ProtocolProviderFactory.DISPLAY_NAME);\r\n        if (ourDisplayName == null || ourDisplayName.trim().length() == 0) {\r\n            ourDisplayName = accountID.getUserID();\r\n        }\r\n        OperationSetBasicTelephonySipImpl opSetBasicTelephonySipImpl = new OperationSetBasicTelephonySipImpl(this);\r\n        boolean isCallingDisabled = SipActivator.getConfigurationService().getBoolean(IS_CALLING_DISABLED, false);\r\n        boolean isCallingDisabledForAccount = accountID.getAccountPropertyBoolean(ProtocolProviderFactory.IS_CALLING_DISABLED_FOR_ACCOUNT, false);\r\n        if (!isCallingDisabled && !isCallingDisabledForAccount) {\r\n            addSupportedOperationSet(OperationSetBasicTelephony.class, opSetBasicTelephonySipImpl);\r\n            addSupportedOperationSet(OperationSetAdvancedTelephony.class, opSetBasicTelephonySipImpl);\r\n            OperationSetAutoAnswerSipImpl autoAnswerOpSet = new OperationSetAutoAnswerSipImpl(this);\r\n            addSupportedOperationSet(OperationSetBasicAutoAnswer.class, autoAnswerOpSet);\r\n            addSupportedOperationSet(OperationSetAdvancedAutoAnswer.class, autoAnswerOpSet);\r\n            addSupportedOperationSet(OperationSetSecureZrtpTelephony.class, opSetBasicTelephonySipImpl);\r\n            addSupportedOperationSet(OperationSetSecureSDesTelephony.class, opSetBasicTelephonySipImpl);\r\n            addSupportedOperationSet(OperationSetVideoTelephony.class, new OperationSetVideoTelephonySipImpl(opSetBasicTelephonySipImpl));\r\n            addSupportedOperationSet(OperationSetTelephonyConferencing.class, new OperationSetTelephonyConferencingSipImpl(this));\r\n            OperationSetDTMFSipImpl operationSetDTMFSip = new OperationSetDTMFSipImpl(this);\r\n            addSupportedOperationSet(OperationSetDTMF.class, operationSetDTMFSip);\r\n            addSupportedOperationSet(OperationSetIncomingDTMF.class, new OperationSetIncomingDTMFSipImpl(this, operationSetDTMFSip));\r\n            boolean isDesktopStreamingDisabled = SipActivator.getConfigurationService().getBoolean(IS_DESKTOP_STREAMING_DISABLED, false);\r\n            boolean isAccountDesktopStreamingDisabled = accountID.getAccountPropertyBoolean(ProtocolProviderFactory.IS_DESKTOP_STREAMING_DISABLED, false);\r\n            if (!isDesktopStreamingDisabled && !isAccountDesktopStreamingDisabled) {\r\n                addSupportedOperationSet(OperationSetDesktopStreaming.class, new OperationSetDesktopStreamingSipImpl(opSetBasicTelephonySipImpl));\r\n                if (!accountID.getAccountPropertyBoolean(ProtocolProviderFactory.IS_DESKTOP_REMOTE_CONTROL_DISABLED, false)) {\r\n                    addSupportedOperationSet(OperationSetDesktopSharingServer.class, new OperationSetDesktopSharingServerSipImpl(opSetBasicTelephonySipImpl));\r\n                    addSupportedOperationSet(OperationSetDesktopSharingClient.class, new OperationSetDesktopSharingClientSipImpl(this));\r\n                }\r\n            }\r\n            addSupportedOperationSet(OperationSetJitsiMeetTools.class, new OperationSetJitsiMeetToolsSipImpl(this));\r\n            boolean isParkingEnabled = accountID.getAccountPropertyBoolean(OperationSetTelephonyPark.IS_CALL_PARK_ENABLED, false);\r\n            if (isParkingEnabled) {\r\n                addSupportedOperationSet(OperationSetTelephonyPark.class, new OperationSetTelephonyParkSipImpl(this));\r\n            }\r\n        }\r\n        if (enablePresence) {\r\n            this.opSetPersPresence = new OperationSetPresenceSipImpl(this, enablePresence, forceP2P, pollingValue, subscriptionExpiration);\r\n            addSupportedOperationSet(OperationSetPersistentPresence.class, opSetPersPresence);\r\n            addSupportedOperationSet(OperationSetPresence.class, opSetPersPresence);\r\n        }\r\n        boolean isMessagingDisabled = SipActivator.getConfigurationService().getBoolean(IS_MESSAGING_DISABLED, false);\r\n        if (!isMessagingDisabled) {\r\n            this.opSetBasicIM = new OperationSetBasicInstantMessagingSipImpl(this);\r\n            addSupportedOperationSet(OperationSetBasicInstantMessaging.class, opSetBasicIM);\r\n            this.opSetTypingNotif = new OperationSetTypingNotificationsSipImpl(this, opSetBasicIM);\r\n            addSupportedOperationSet(OperationSetTypingNotifications.class, opSetTypingNotif);\r\n            addSupportedOperationSet(OperationSetInstantMessageTransform.class, new OperationSetInstantMessageTransformImpl());\r\n        }\r\n        this.opSetSSAccountInfo = new OperationSetServerStoredAccountInfoSipImpl(this);\r\n        opSetSSAccountInfo.setOurDisplayName(ourDisplayName);\r\n        addSupportedOperationSet(OperationSetServerStoredAccountInfo.class, opSetSSAccountInfo);\r\n        addSupportedOperationSet(OperationSetAvatar.class, new OperationSetAvatarSipImpl(this, opSetSSAccountInfo));\r\n        if (accountID.getAccountPropertyBoolean(ProtocolProviderFactory.VOICEMAIL_ENABLED, true)) {\r\n            this.opSetMWI = new OperationSetMessageWaitingSipImpl(this);\r\n            addSupportedOperationSet(OperationSetMessageWaiting.class, opSetMWI);\r\n        }\r\n        if (getAccountID().getAccountPropertyString(ProtocolProviderFactory.CUSAX_PROVIDER_ACCOUNT_PROP) != null) {\r\n            addSupportedOperationSet(OperationSetCusaxUtils.class, new OperationSetCusaxUtilsSipImpl(this));\r\n        }\r\n        if (accountID.getAccountPropertyBoolean(OperationSetTelephonyBLFSipImpl.BLF_ENABLED_ACC_PROP, false)) {\r\n            addSupportedOperationSet(OperationSetTelephonyBLF.class, new OperationSetTelephonyBLFSipImpl(this));\r\n        }\r\n        this.capabilities = new ClientCapabilities(this);\r\n        this.sipSecurityManager = new SipSecurityManager(accountID, this);\r\n        sipSecurityManager.setHeaderFactory(headerFactory);\r\n        ProtocolProviderExtensions.registerCustomOperationSets(this);\r\n        isInitialized = true;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.InfoRetreiver.readBasicUserInfo",
	"Comment": "method for parsing incoming data read data in metabasicinfocmd command",
	"Method": "void readBasicUserInfo(MetaBasicInfoCmd cmd){\r\n    List<GenericDetail> infoData = getInfoForRequest(cmd.getId());\r\n    Locale countryCodeLocale = OperationSetServerStoredAccountInfoIcqImpl.getCountry(cmd.getCountryCode());\r\n    if (countryCodeLocale != null)\r\n        infoData.add(new ServerStoredDetails.CountryDetail(countryCodeLocale));\r\n    String tmp = null;\r\n    if ((tmp = cmd.getNickname()) != null)\r\n        infoData.add(new ServerStoredDetails.NicknameDetail(tmp));\r\n    if ((tmp = cmd.getFirstName()) != null)\r\n        infoData.add(new ServerStoredDetails.FirstNameDetail(tmp));\r\n    if ((tmp = cmd.getLastName()) != null)\r\n        infoData.add(new ServerStoredDetails.LastNameDetail(tmp));\r\n    if ((tmp = cmd.getEmail()) != null)\r\n        infoData.add(new ServerStoredDetails.EmailAddressDetail(tmp));\r\n    if ((tmp = cmd.getHomeCity()) != null)\r\n        infoData.add(new ServerStoredDetails.CityDetail(tmp));\r\n    if ((tmp = cmd.getHomeState()) != null)\r\n        infoData.add(new ServerStoredDetails.ProvinceDetail(tmp));\r\n    if ((tmp = cmd.getHomePhone()) != null)\r\n        infoData.add(new ServerStoredDetails.PhoneNumberDetail(tmp));\r\n    if ((tmp = cmd.getHomeFax()) != null)\r\n        infoData.add(new ServerStoredDetails.FaxDetail(tmp));\r\n    if ((tmp = cmd.getHomeAddress()) != null)\r\n        infoData.add(new ServerStoredDetails.AddressDetail(tmp));\r\n    if ((tmp = cmd.getCellPhone()) != null)\r\n        infoData.add(new ServerStoredDetails.MobilePhoneDetail(tmp));\r\n    if ((tmp = cmd.getHomeZip()) != null)\r\n        infoData.add(new ServerStoredDetails.PostalCodeDetail(tmp));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapDirectorySettingsImpl.equals",
	"Comment": "checks if both ldapdirectorysettings instance have the same content",
	"Method": "boolean equals(LdapDirectorySettings other){\r\n    return this.getName().equals(other.getName()) && this.getHostname().equals(other.getHostname()) && this.getEncryption().equals(other.getEncryption()) && this.getPort() == other.getPort() && this.getAuth().equals(other.getAuth()) && this.getBindDN().equals(other.getBindDN()) && this.getPassword().equals(other.getPassword()) && this.getBaseDN().equals(other.getBaseDN()) && this.getScope().equals(other.getScope()) && this.getGlobalPhonePrefix().equals(other.getGlobalPhonePrefix()) && this.getCustomQuery().equals(other.getCustomQuery()) && this.getQueryMode().equals(other.getQueryMode()) && this.isMangleQuery() == other.isMangleQuery() && this.isPhotoInline() == other.isPhotoInline();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.OperationSetPersistentPresenceGibberishImpl.removeServerStoredContactGroup",
	"Comment": "removes the specified group from the server stored contact list.",
	"Method": "void removeServerStoredContactGroup(ContactGroup group){\r\n    ContactGroupGibberishImpl gibberishGroup = (ContactGroupGibberishImpl) group;\r\n    ContactGroupGibberishImpl parent = findGroupParent(gibberishGroup);\r\n    if (parent == null) {\r\n        throw new IllegalArgumentException(\"group \" + group + \" does not seem to belong to this protocol's contact list.\");\r\n    }\r\n    parent.removeSubGroup(gibberishGroup);\r\n    this.fireServerStoredGroupEvent(gibberishGroup, ServerStoredGroupEvent.GROUP_REMOVED_EVENT);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.AdHocChatRoomMessageReceivedEvent.getTimestamp",
	"Comment": "a timestamp indicating the exact date when the event occurred.",
	"Method": "Date getTimestamp(){\r\n    return timestamp;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.WhiteboardObjectModifiedEvent.getSourceContact",
	"Comment": "returns a reference to the contact that has send thewhiteboardobject whose reception this event represents.",
	"Method": "Contact getSourceContact(){\r\n    return from;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.MainFrame.updateProvidersIndexes",
	"Comment": "updates the indexes in the configuration xml, when a provider has beenremoved.",
	"Method": "void updateProvidersIndexes(ProtocolProviderService removedProvider){\r\n    ConfigurationService configService = GuiActivator.getConfigurationService();\r\n    String prefix = \"net.java.sip.communicator.impl.gui.accounts\";\r\n    ProtocolProviderService currentProvider = null;\r\n    int sameProtocolProvidersCount = 0;\r\n    for (ProtocolProviderService pps : protocolProviders.keySet()) {\r\n        if (pps.getProtocolDisplayName().equals(removedProvider.getProtocolDisplayName())) {\r\n            sameProtocolProvidersCount++;\r\n            if (sameProtocolProvidersCount > 1) {\r\n                break;\r\n            }\r\n            currentProvider = pps;\r\n        }\r\n    }\r\n    if (sameProtocolProvidersCount < 2 && currentProvider != null) {\r\n        protocolProviders.put(currentProvider, 0);\r\n        List<String> accounts = configService.getPropertyNamesByPrefix(prefix, true);\r\n        for (String rootPropName : accounts) {\r\n            String accountUID = configService.getString(rootPropName);\r\n            if (accountUID.equals(currentProvider.getAccountID().getAccountUniqueID())) {\r\n                configService.setProperty(rootPropName + \".accountIndex\", 0);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetPersistentPresenceJabberImpl.updateResource",
	"Comment": "update the resources for the contact for the received presence.",
	"Method": "boolean updateResource(ContactJabberImpl contact,String fullJid,Presence presence){\r\n    if (fullJid == null)\r\n        fullJid = presence.getFrom();\r\n    String resource = StringUtils.parseResource(fullJid);\r\n    if (resource != null && resource.length() > 0) {\r\n        Map<String, ContactResourceJabberImpl> resources = contact.getResourcesMap();\r\n        ContactResourceJabberImpl contactResource = resources.get(fullJid);\r\n        PresenceStatus newPresenceStatus = OperationSetPersistentPresenceJabberImpl.jabberStatusToPresenceStatus(presence, parentProvider);\r\n        if (contactResource == null) {\r\n            contactResource = createResource(presence, fullJid, contact);\r\n            resources.put(fullJid, contactResource);\r\n            contact.fireContactResourceEvent(new ContactResourceEvent(contact, contactResource, ContactResourceEvent.RESOURCE_ADDED));\r\n            return true;\r\n        } else {\r\n            boolean oldIndicator = contactResource.isMobile();\r\n            boolean newIndicator = mobileIndicator.isMobileResource(resource, fullJid);\r\n            int oldPriority = contactResource.getPriority();\r\n            contactResource.setMobile(newIndicator);\r\n            contactResource.setPriority(presence.getPriority());\r\n            if (oldPriority != contactResource.getPriority()) {\r\n                mobileIndicator.resourcesUpdated(contact);\r\n            }\r\n            if (contactResource.getPresenceStatus().getStatus() != newPresenceStatus.getStatus() || (oldIndicator != newIndicator) || (oldPriority != contactResource.getPriority())) {\r\n                contactResource.setPresenceStatus(newPresenceStatus);\r\n                contact.fireContactResourceEvent(new ContactResourceEvent(contact, contactResource, ContactResourceEvent.RESOURCE_MODIFIED));\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.NetworkUtils.moveSelectedSRVRecord",
	"Comment": "moves the selected srv record in top of the unsorted items for thispriority.",
	"Method": "void moveSelectedSRVRecord(SRVRecord[] srvRecords,int startIndex,int endIndex,int selectedWeight){\r\n    SRVRecord tmpSrvRecord;\r\n    int totalPriorityWeight = 0;\r\n    for (int i = startIndex; i < endIndex; ++i) {\r\n        totalPriorityWeight += srvRecords[i].getWeight();\r\n        if (totalPriorityWeight >= selectedWeight) {\r\n            tmpSrvRecord = srvRecords[startIndex];\r\n            srvRecords[startIndex] = srvRecords[i];\r\n            srvRecords[i] = tmpSrvRecord;\r\n            return;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ProtocolProviderServiceJabberImpl.validateContactAddress",
	"Comment": "validates the node part of a jid and returns an error message ifapplicable and a suggested correction.",
	"Method": "boolean validateContactAddress(String contactId,List<String> result){\r\n    if (result == null) {\r\n        throw new IllegalArgumentException(\"result must be an empty list\");\r\n    }\r\n    result.clear();\r\n    try {\r\n        contactId = contactId.trim();\r\n        if (contactId.length() == 0) {\r\n            result.add(JabberActivator.getResources().getI18NString(\"impl.protocol.jabber.INVALID_ADDRESS\", new String[] { contactId }));\r\n            return false;\r\n        }\r\n        String user = contactId;\r\n        String remainder = \"\";\r\n        int at = contactId.indexOf('@');\r\n        if (at > -1) {\r\n            user = contactId.substring(0, at);\r\n            remainder = contactId.substring(at);\r\n        }\r\n        boolean valid = true;\r\n        String suggestion = \"\";\r\n        for (char c : user.toCharArray()) {\r\n            if (!(c == 0x21 || (c >= 0x23 && c <= 0x25) || (c >= 0x28 && c <= 0x2e) || (c >= 0x30 && c <= 0x39) || c == 0x3b || c == 0x3d || c == 0x3f || (c >= 0x41 && c <= 0x7e) || (c >= 0x80 && c <= 0xd7ff) || (c >= 0xe000 && c <= 0xfffd))) {\r\n                valid = false;\r\n            } else {\r\n                suggestion += c;\r\n            }\r\n        }\r\n        if (!valid) {\r\n            result.add(JabberActivator.getResources().getI18NString(\"impl.protocol.jabber.INVALID_ADDRESS\", new String[] { contactId }));\r\n            result.add(suggestion + remainder);\r\n            return false;\r\n        }\r\n        return true;\r\n    } catch (Exception ex) {\r\n        result.add(JabberActivator.getResources().getI18NString(\"impl.protocol.jabber.INVALID_ADDRESS\", new String[] { contactId }));\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.security.SipSecurityManager.setSecurityAuthority",
	"Comment": "sets the securityauthority instance that should be queried for usercredentials.",
	"Method": "void setSecurityAuthority(SecurityAuthority authority){\r\n    this.securityAuthority = authority;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.MetaContactChatTransport.getDisplayName",
	"Comment": "returns the display name corresponding to this chat transport.",
	"Method": "String getDisplayName(){\r\n    return contact.getDisplayName();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.swingnotification.PopupMessageHandlerSwingImpl.getPreferenceIndex",
	"Comment": "implements getpreferenceindex from popupmessagehandler.this handler is able to show images, detect clicks, match a click to amessage, thus the preference index is 3.",
	"Method": "int getPreferenceIndex(){\r\n    return 3;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.FileTransferRequestEvent.getFileTransferOperationSet",
	"Comment": "returns the operationsetfiletransfer, where this event initiallyoccurred.",
	"Method": "OperationSetFileTransfer getFileTransferOperationSet(){\r\n    return (OperationSetFileTransfer) getSource();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.callhistory.CallHistoryServiceImpl.addSearchProgressListener",
	"Comment": "adding progress listener for monitoring progress of search process",
	"Method": "void addSearchProgressListener(CallHistorySearchProgressListener listener){\r\n    synchronized (progressListeners) {\r\n        progressListeners.put(listener, new SearchProgressWrapper(listener));\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetMessageWaitingSipImpl.registrationStateChanged",
	"Comment": "the method is called by a protocolproviderserviceimplementation whenever a change in the registration state of thecorresponding provider had occurred.",
	"Method": "void registrationStateChanged(RegistrationStateChangeEvent evt){\r\n    if (evt.getNewState().equals(RegistrationState.REGISTERED)) {\r\n        Address subscribeAddress = null;\r\n        try {\r\n            subscribeAddress = getSubscribeAddress();\r\n            if (subscribeAddress == null) {\r\n                return;\r\n            }\r\n        } catch (ParseException e) {\r\n            logger.error(\"Failed to parse mailbox subscribe address.\", e);\r\n        }\r\n        final MessageSummarySubscriber defaultSubscriber = new MessageSummarySubscriber(subscribeAddress);\r\n        messageWaitingSubscriber = new EventPackageSubscriber(provider, EVENT_PACKAGE, SUBSCRIPTION_DURATION, CONTENT_SUB_TYPE, timer, REFRESH_MARGIN) {\r\n            @Override\r\n            protected Subscription getSubscription(String callId) {\r\n                Subscription resultSub = super.getSubscription(callId);\r\n                if (resultSub != null)\r\n                    return resultSub;\r\n                Object[] subs = getSubscriptions();\r\n                for (Object s : subs) if (s instanceof MessageSummarySubscriber)\r\n                    return (MessageSummarySubscriber) s;\r\n                return defaultSubscriber;\r\n            }\r\n        };\r\n        if (subscribeAddress != null) {\r\n            try {\r\n                messageWaitingSubscriber.subscribe(defaultSubscriber);\r\n            } catch (Throwable e) {\r\n                logger.error(\"Error subscribing for mailbox\", e);\r\n            }\r\n        }\r\n    } else if (evt.getNewState().equals(RegistrationState.UNREGISTERING)) {\r\n        if (messageWaitingSubscriber != null) {\r\n            try {\r\n                messageWaitingSubscriber.unsubscribe(getSubscribeAddress(), false);\r\n            } catch (Throwable t) {\r\n                logger.error(\"Error unsubscribing mailbox\", t);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetMessageWaitingSipImpl.registrationStateChanged",
	"Comment": "the method is called by a protocolproviderserviceimplementation whenever a change in the registration state of thecorresponding provider had occurred.",
	"Method": "void registrationStateChanged(RegistrationStateChangeEvent evt){\r\n    Subscription resultSub = super.getSubscription(callId);\r\n    if (resultSub != null)\r\n        return resultSub;\r\n    Object[] subs = getSubscriptions();\r\n    for (Object s : subs) if (s instanceof MessageSummarySubscriber)\r\n        return (MessageSummarySubscriber) s;\r\n    return defaultSubscriber;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.jabber.JabberAccountID.isAutoDiscoverStun",
	"Comment": "indicates if the stun server should be automatically discovered.",
	"Method": "boolean isAutoDiscoverStun(){\r\n    return getAccountPropertyBoolean(ProtocolProviderFactory.AUTO_DISCOVER_STUN, true);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.gui.event.MetaContactQuery.getResultCount",
	"Comment": "returns the current number of results received for this query.",
	"Method": "int getResultCount(){\r\n    return resultCount;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.dns.ParallelResolverImpl.reset",
	"Comment": "resets resolver configuration and populate our default resolverwith the newly configured servers.",
	"Method": "void reset(){\r\n    Lookup.refreshDefault();\r\n    try {\r\n        Lookup.setDefaultResolver(this);\r\n        ExtendedResolver temp = new ExtendedResolver();\r\n        temp.setTimeout(10);\r\n        defaultResolver = temp;\r\n    } catch (UnknownHostException e) {\r\n        throw new RuntimeException(\"Failed to initialize resolver\");\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.UIServiceImpl.maximize",
	"Comment": "implements maximize in the uiservice interface. maximizesthe main application window.",
	"Method": "void maximize(){\r\n    this.mainFrame.maximize();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.phonenumbers.PhoneNumberI18nServiceImpl.normalize",
	"Comment": "normalizes a string which may be a phone number or a identifierby removing useless characters and, if necessary, replacing the alpahecharacters in corresponding dial pad numbers.",
	"Method": "String normalize(String possibleNumber){\r\n    String normalizedNumber;\r\n    if (isPhoneNumber(possibleNumber)) {\r\n        normalizedNumber = normalizePhoneNumber(possibleNumber);\r\n    } else {\r\n        normalizedNumber = normalizeIdentifier(possibleNumber);\r\n    }\r\n    return normalizedNumber;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.applyMessageCorrection",
	"Comment": "passes the message to the contained chatconversationpanelfor processing and replaces the specified message with this one.",
	"Method": "void applyMessageCorrection(ChatMessage message){\r\n    conversationPanel.correctMessage(message);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetVideoTelephonyJabberImpl.answerVideoCallPeer",
	"Comment": "indicates a user request to answer an incoming call with video enabledfrom the specified callpeer.",
	"Method": "void answerVideoCallPeer(CallPeer peer){\r\n    CallPeerJabberImpl callPeer = (CallPeerJabberImpl) peer;\r\n    callPeer.getCall().setLocalVideoAllowed(true, getMediaUseCase());\r\n    callPeer.answer();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.generalconfig.GeneralConfigurationPanel.createAcceptPhoneNumberWithAlphaCharCheckBox",
	"Comment": "creates the accept phone number with alphabetical character check box.",
	"Method": "Component createAcceptPhoneNumberWithAlphaCharCheckBox(){\r\n    JPanel checkBoxPanel = new TransparentPanel();\r\n    checkBoxPanel.setLayout(new BoxLayout(checkBoxPanel, BoxLayout.Y_AXIS));\r\n    SIPCommCheckBox alphaCharNumbers = new SIPCommCheckBox(GeneralConfigPluginActivator.getResources().getI18NString(\"plugin.generalconfig.ACCEPT_PHONE_NUMBER_WITH_ALPHA_CHARS\"), ConfigurationUtils.acceptPhoneNumberWithAlphaChars());\r\n    alphaCharNumbers.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent e) {\r\n            ConfigurationUtils.setAcceptPhoneNumberWithAlphaChars(((JCheckBox) e.getSource()).isSelected());\r\n        }\r\n    });\r\n    String label = \"* \" + Resources.getString(\"plugin.generalconfig.ACCEPT_PHONE_NUMBER_WITH_ALPHA_CHARS_EXAMPLE\");\r\n    JLabel exampleLabel = new JLabel(label);\r\n    exampleLabel.setToolTipText(label);\r\n    exampleLabel.setForeground(Color.GRAY);\r\n    exampleLabel.setFont(exampleLabel.getFont().deriveFont(8));\r\n    exampleLabel.setBorder(BorderFactory.createEmptyBorder(0, 0, 8, 0));\r\n    exampleLabel.setHorizontalAlignment(JLabel.LEFT);\r\n    checkBoxPanel.add(alphaCharNumbers);\r\n    checkBoxPanel.add(exampleLabel);\r\n    return checkBoxPanel;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.generalconfig.GeneralConfigurationPanel.createAcceptPhoneNumberWithAlphaCharCheckBox",
	"Comment": "creates the accept phone number with alphabetical character check box.",
	"Method": "Component createAcceptPhoneNumberWithAlphaCharCheckBox(){\r\n    ConfigurationUtils.setAcceptPhoneNumberWithAlphaChars(((JCheckBox) e.getSource()).isSelected());\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.account.AccountUtils.getRegisteredProviderForAccount",
	"Comment": "returns the protocolproviderservice corresponding to the givenaccount identifier that is registered in the given factory",
	"Method": "ProtocolProviderService getRegisteredProviderForAccount(AccountID accountID){\r\n    for (ProtocolProviderFactory factory : UtilActivator.getProtocolProviderFactories().values()) {\r\n        if (factory.getRegisteredAccounts().contains(accountID)) {\r\n            ServiceReference<ProtocolProviderService> ref = factory.getProviderForAccount(accountID);\r\n            if (ref != null) {\r\n                return UtilActivator.bundleContext.getService(ref);\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatTransport.allowsTypingNotifications",
	"Comment": "returns true if this chat transport supports typingnotifications, otherwise returns false.",
	"Method": "boolean allowsTypingNotifications(){\r\n    Object tnOpSet = chatRoom.getParentProvider().getOperationSet(OperationSetTypingNotifications.class);\r\n    if (tnOpSet != null)\r\n        return true;\r\n    else\r\n        return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.replacement.smiley.ReplacementServiceSmileyImpl.getSmileyPattern",
	"Comment": "gets a regex string which matches the smiley strings of the specifiedcollection of smileys.",
	"Method": "String getSmileyPattern(Collection<Smiley> smileys){\r\n    synchronized (smileyStrings) {\r\n        boolean smileyStringsIsEqual;\r\n        if (smileyRegex == null)\r\n            smileyStringsIsEqual = false;\r\n        else {\r\n            smileyStringsIsEqual = true;\r\n            int smileyStringIndex = 0;\r\n            int smileyStringCount = smileyStrings.size();\r\n            smileyLoop: for (Smiley smiley : smileys) for (String smileyString : smiley.getSmileyStrings()) if ((smileyStringIndex < smileyStringCount) && smileyString.equals(smileyStrings.get(smileyStringIndex)))\r\n                smileyStringIndex++;\r\n            else {\r\n                smileyStringsIsEqual = false;\r\n                break smileyLoop;\r\n            }\r\n            if (smileyStringsIsEqual && (smileyStringIndex != smileyStringCount))\r\n                smileyStringsIsEqual = false;\r\n        }\r\n        if (!smileyStringsIsEqual) {\r\n            smileyStrings.clear();\r\n            StringBuffer regex = new StringBuffer();\r\n            regex.append(\"(?<!(alt='|alt=\\\"))(\");\r\n            for (Smiley smiley : smileys) for (String smileyString : smiley.getSmileyStrings()) {\r\n                smileyStrings.add(smileyString);\r\n                regex.append(GuiUtils.replaceSpecialRegExpChars(smileyString)).append(\"|\");\r\n            }\r\n            regex = regex.deleteCharAt(regex.length() - 1);\r\n            regex.append(')');\r\n            smileyRegex = regex.toString();\r\n        }\r\n        return smileyRegex;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl.reflectConferenceFocus",
	"Comment": "reflects the value of the conferencefocus property of thecall of this callpeer in the specified sipmessage.",
	"Method": "void reflectConferenceFocus(javax.sip.message.Message message){\r\n    ContactHeader contactHeader = (ContactHeader) message.getHeader(ContactHeader.NAME);\r\n    if (contactHeader != null) {\r\n        if (getCall().isConferenceFocus())\r\n            contactHeader.setParameter(\"isfocus\", null);\r\n        else\r\n            contactHeader.removeParameter(\"isfocus\");\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.AuthenticationWindow.getUserName",
	"Comment": "returns the user name entered by the user or previously set if theuser name is not editable.",
	"Method": "String getUserName(){\r\n    return userName;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.GenericBuffer.getValue",
	"Comment": "retrieves the value in the buffer corresponding to the context if itexists.",
	"Method": "T getValue(String context){\r\n    assert context != null;\r\n    GenericBufferPair res = buffer.get(context);\r\n    if (res == null) {\r\n        return null;\r\n    }\r\n    return res.value;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chatroomslist.createforms.CreateChatRoomWizardPage1.pageShowing",
	"Comment": "before the panel is displayed checks the selections and enables thenext button if a checkbox is already selected or disables it ifnothing is selected.",
	"Method": "void pageShowing(){\r\n    setNextButtonAccordingToCheckBox();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockProvider.getOperationSet",
	"Comment": "returns the operation set corresponding to the specified class or nullif this operation set is not supported by the provider implementation.",
	"Method": "T getOperationSet(Class<T> opsetClass){\r\n    return (T) getSupportedOperationSets().get(opsetClass.getName());\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.whiteboard.gui.WhiteboardFileFilter.accept",
	"Comment": "tests the specified file,returning true if the file is accepted, false otherwise.true is returned if the extension matches one ofthe file name extensions of this filefilter,or the file is a directory.",
	"Method": "boolean accept(File f){\r\n    if (f != null) {\r\n        if (f.isDirectory()) {\r\n            return true;\r\n        }\r\n        String e = getExtension(f);\r\n        if (e != null && e.equals(ext)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.lookandfeel.SIPCommLookAndFeel.getDisabledIcon",
	"Comment": "returns the disabled icon for the given component, based on thegiven icon.",
	"Method": "Icon getDisabledIcon(JComponent component,Icon icon){\r\n    if (icon instanceof ImageIcon) {\r\n        return new IconUIResource(new ImageIcon(LightGrayFilter.createDisabledImage(((ImageIcon) icon).getImage())));\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetServerStoredAccountInfoJabberImpl.getMaxDetailInstances",
	"Comment": "the method returns the number of instances supported for a particulardetail type. some protocols offer storing multiple values for aparticular detail type. spoken languages are a good example.",
	"Method": "int getMaxDetailInstances(Class<? extends GenericDetail> detailClass){\r\n    return 1;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.propertieseditor.PropsTableModel.isCellEditable",
	"Comment": "returns true if the given cell is editable. editable cells in this modelare cells with column index 1.",
	"Method": "boolean isCellEditable(int rowIndex,int columnIndex){\r\n    return columnIndex == 1;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatSession.getParticipants",
	"Comment": "returns an iterator to the list of all participants contained in thischat session.",
	"Method": "Iterator<ChatContact<?>> getParticipants(){\r\n    return chatParticipants.iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.GuiUtils.compareDates",
	"Comment": "compares the two dates. the comparison is based only on the day, monthand year values. returns 0 if the two dates are equals, a value0 if the first date is afterthe second one.",
	"Method": "int compareDates(Date date1,Date date2,int compareDates,long date1,long date2){\r\n    return (date1 < date2 ? -1 : (date1 == date2 ? 0 : 1));\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.notification.NotificationServiceActivator.getConfigurationService",
	"Comment": "returns the configurationservice obtained from the bundlecontext.",
	"Method": "ConfigurationService getConfigurationService(){\r\n    if (configService == null) {\r\n        ServiceReference configReference = bundleContext.getServiceReference(ConfigurationService.class.getName());\r\n        configService = (ConfigurationService) bundleContext.getService(configReference);\r\n    }\r\n    return configService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.AdHocChatRoomIcqImpl.assertConnected",
	"Comment": "utility method throwing an exception if the stack is not properlyinitialized.",
	"Method": "void assertConnected(){\r\n    if (provider == null)\r\n        throw new IllegalStateException(\"The provider must be non-null and signed on the \" + \"service before being able to communicate.\");\r\n    if (!provider.isRegistered())\r\n        throw new IllegalStateException(\"The provider must be signed on the service before \" + \"being able to communicate.\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.TestOperationSetPersistentPresence.postTestRenameGroup",
	"Comment": "renames our test group and checks whether corresponding events aretriggered. verifies whether the group has really changed its name andwhether it is findable by its new name. also makes sure that it doesnot exist under its previous name any more.",
	"Method": "void postTestRenameGroup(){\r\n    logger.trace(\"Testing renaming groups.\");\r\n    ContactGroup group = opSetPersPresence.getServerStoredContactListRoot().getGroup(testGroupName);\r\n    GroupChangeCollector groupChangeCollector = new GroupChangeCollector();\r\n    opSetPersPresence.addServerStoredGroupChangeListener(groupChangeCollector);\r\n    opSetPersPresence.renameServerStoredContactGroup(group, testGroupName2);\r\n    groupChangeCollector.waitForEvent(10000);\r\n    opSetPersPresence.removeServerStoredGroupChangeListener(groupChangeCollector);\r\n    assertEquals(\"Collected Group Change event\", 1, groupChangeCollector.collectedEvents.size());\r\n    assertEquals(\"Group name.\", testGroupName2, ((ServerStoredGroupEvent) groupChangeCollector.collectedEvents.get(0)).getSourceGroup().getGroupName());\r\n    ContactGroup oldGroup = opSetPersPresence.getServerStoredContactListRoot().getGroup(testGroupName);\r\n    assertNull(\"A group was still findable by its old name after renaming.\", oldGroup);\r\n    ContactGroup newGroup = opSetPersPresence.getServerStoredContactListRoot().getGroup(testGroupName2);\r\n    assertNotNull(\"Could not find a renamed group by its new name.\", newGroup);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.notificationwiring.NotificationManager.serviceChanged",
	"Comment": "implements the servicelistener method. verifies whether thepassed event concerns a protocolproviderservice and adds thecorresponding listeners.",
	"Method": "void serviceChanged(ServiceEvent event){\r\n    ServiceReference serviceRef = event.getServiceReference();\r\n    if (serviceRef.getBundle().getState() == Bundle.STOPPING)\r\n        return;\r\n    Object service = NotificationWiringActivator.bundleContext.getService(serviceRef);\r\n    if (service instanceof ProtocolProviderService) {\r\n        switch(event.getType()) {\r\n            case ServiceEvent.REGISTERED:\r\n                handleProviderAdded((ProtocolProviderService) service);\r\n                break;\r\n            case ServiceEvent.UNREGISTERING:\r\n                handleProviderRemoved((ProtocolProviderService) service);\r\n                break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactImpl.isDisplayNameUserDefined",
	"Comment": "determines if display name was changed forthis metacontact in user interface.",
	"Method": "boolean isDisplayNameUserDefined(){\r\n    return isDisplayNameUserDefined;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.caps.CapsPacketExtension.getNode",
	"Comment": "returns the node uri. the node uri uniquely identifies asoftware application, typically a url at the web site of the project orcompany that produces the software.",
	"Method": "String getNode(){\r\n    return node;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.callhistory.CallHistoryServiceImpl.findLast",
	"Comment": "returns the supplied number of calls by all the contactsin the supplied metacontact",
	"Method": "Collection<CallRecord> findLast(MetaContact contact,int count,Collection<CallRecord> findLast,int count){\r\n    TreeSet<CallRecord> result = new TreeSet<CallRecord>(new CallRecordComparator());\r\n    try {\r\n        History history = this.getHistory(null, null);\r\n        historyReader = history.getReader();\r\n        QueryResultSet<HistoryRecord> rs = historyReader.findLast(count);\r\n        while (rs.hasNext()) {\r\n            HistoryRecord hr = rs.next();\r\n            result.add(convertHistoryRecordToCallRecord(hr));\r\n        }\r\n    } catch (IOException ex) {\r\n        logger.error(\"Could not read history\", ex);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.aimaccregwizz.AimAccRegWizzActivator.getAimProtocolProviderFactory",
	"Comment": "returns the protocolproviderfactory for the aim protocol.",
	"Method": "ProtocolProviderFactory getAimProtocolProviderFactory(){\r\n    ServiceReference[] serRefs = null;\r\n    String osgiFilter = \"(\" + ProtocolProviderFactory.PROTOCOL + \"=\" + ProtocolNames.AIM + \")\";\r\n    try {\r\n        serRefs = bundleContext.getServiceReferences(ProtocolProviderFactory.class.getName(), osgiFilter);\r\n    } catch (InvalidSyntaxException ex) {\r\n        logger.error(\"AimAccRegWizzActivator : \" + ex);\r\n    }\r\n    return (ProtocolProviderFactory) bundleContext.getService(serRefs[0]);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.netaddr.NetworkAddressManagerServiceImpl.addNetworkConfigurationChangeListener",
	"Comment": "adds new networkconfigurationchangelistener which will be informed for network configuration changes.",
	"Method": "void addNetworkConfigurationChangeListener(NetworkConfigurationChangeListener listener){\r\n    if (networkConfigurationWatcher == null)\r\n        networkConfigurationWatcher = new NetworkConfigurationWatcher();\r\n    networkConfigurationWatcher.addNetworkConfigurationChangeListener(listener);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactListServiceImpl.removeMetaContact",
	"Comment": "removes the specified metacontact as well as all of itsunderlying contacts.",
	"Method": "void removeMetaContact(MetaContact metaContact){\r\n    Iterator<Contact> protoContactsIter = metaContact.getContacts();\r\n    while (protoContactsIter.hasNext()) {\r\n        removeContact(protoContactsIter.next());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.login.LoginRendererSwingImpl.removeProtocolProviderUI",
	"Comment": "removes the user interface related to the given protocol provider.",
	"Method": "void removeProtocolProviderUI(ProtocolProviderService protocolProvider){\r\n    this.mainFrame.removeProtocolProvider(protocolProvider);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.spellcheck.SpellChecker.getChatAttachments",
	"Comment": "gets the chatattachments instance associated with a specificchat.",
	"Method": "ChatAttachments getChatAttachments(Chat chat){\r\n    synchronized (attachedChats) {\r\n        for (ChatAttachments chatAttachments : attachedChats) if (chatAttachments.chat.equals(chat))\r\n            return chatAttachments;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.account.LoginManager.registrationStateChanged",
	"Comment": "the method is called by a protocolprovider implementation whenever achange in the registration state of the corresponding provider hadoccurred.",
	"Method": "void registrationStateChanged(RegistrationStateChangeEvent evt){\r\n    RegistrationState newState = evt.getNewState();\r\n    ProtocolProviderService protocolProvider = evt.getProvider();\r\n    AccountID accountID = protocolProvider.getAccountID();\r\n    if (logger.isTraceEnabled())\r\n        logger.trace(\"Protocol provider: \" + protocolProvider + \" changed its state to: \" + evt.getNewState().getStateName());\r\n    if (newState.equals(RegistrationState.REGISTERED) || newState.equals(RegistrationState.UNREGISTERED) || newState.equals(RegistrationState.EXPIRED) || newState.equals(RegistrationState.AUTHENTICATION_FAILED) || newState.equals(RegistrationState.CONNECTION_FAILED) || newState.equals(RegistrationState.CHALLENGED_FOR_AUTHENTICATION) || newState.equals(RegistrationState.REGISTERED)) {\r\n        loginRenderer.stopConnectingUI(protocolProvider);\r\n    }\r\n    if (newState.equals(RegistrationState.REGISTERED)) {\r\n        loginRenderer.protocolProviderConnected(protocolProvider, System.currentTimeMillis());\r\n    } else {\r\n        String msgText;\r\n        if (newState.equals(RegistrationState.AUTHENTICATION_FAILED)) {\r\n            switch(evt.getReasonCode()) {\r\n                case RegistrationStateChangeEvent.REASON_RECONNECTION_RATE_LIMIT_EXCEEDED:\r\n                    msgText = UtilActivator.getResources().getI18NString(\"service.gui.RECONNECTION_LIMIT_EXCEEDED\", new String[] { accountID.getUserID(), accountID.getService() });\r\n                    UtilActivator.getAlertUIService().showAlertDialog(UtilActivator.getResources().getI18NString(\"service.gui.ERROR\"), msgText);\r\n                    break;\r\n                case RegistrationStateChangeEvent.REASON_NON_EXISTING_USER_ID:\r\n                    msgText = UtilActivator.getResources().getI18NString(\"service.gui.NON_EXISTING_USER_ID\", new String[] { protocolProvider.getProtocolDisplayName() });\r\n                    UtilActivator.getAlertUIService().showAlertDialog(UtilActivator.getResources().getI18NString(\"service.gui.ERROR\"), msgText);\r\n                    break;\r\n                case RegistrationStateChangeEvent.REASON_TLS_REQUIRED:\r\n                    msgText = UtilActivator.getResources().getI18NString(\"service.gui.NON_SECURE_CONNECTION\", new String[] { accountID.getAccountAddress() });\r\n                    UtilActivator.getAlertUIService().showAlertDialog(UtilActivator.getResources().getI18NString(\"service.gui.ERROR\"), msgText);\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n            if (logger.isTraceEnabled())\r\n                logger.trace(evt.getReason());\r\n        } else if (newState.equals(RegistrationState.EXPIRED)) {\r\n            msgText = UtilActivator.getResources().getI18NString(\"service.gui.CONNECTION_EXPIRED_MSG\", new String[] { protocolProvider.getProtocolDisplayName() });\r\n            UtilActivator.getAlertUIService().showAlertDialog(UtilActivator.getResources().getI18NString(\"service.gui.ERROR\"), msgText);\r\n            logger.error(evt.getReason());\r\n        } else if (newState.equals(RegistrationState.UNREGISTERED)) {\r\n            if (!manuallyDisconnected) {\r\n                if (evt.getReasonCode() == RegistrationStateChangeEvent.REASON_MULTIPLE_LOGINS) {\r\n                    msgText = UtilActivator.getResources().getI18NString(\"service.gui.MULTIPLE_LOGINS\", new String[] { accountID.getUserID(), accountID.getService() });\r\n                    UtilActivator.getAlertUIService().showAlertDialog(UtilActivator.getResources().getI18NString(\"service.gui.ERROR\"), msgText);\r\n                } else if (evt.getReasonCode() == RegistrationStateChangeEvent.REASON_CLIENT_LIMIT_REACHED_FOR_IP) {\r\n                    msgText = UtilActivator.getResources().getI18NString(\"service.gui.LIMIT_REACHED_FOR_IP\", new String[] { protocolProvider.getProtocolDisplayName() });\r\n                    UtilActivator.getAlertUIService().showAlertDialog(UtilActivator.getResources().getI18NString(\"service.gui.ERROR\"), msgText);\r\n                } else if (evt.getReasonCode() == RegistrationStateChangeEvent.REASON_USER_REQUEST) {\r\n                } else {\r\n                    msgText = UtilActivator.getResources().getI18NString(\"service.gui.UNREGISTERED_MESSAGE\", new String[] { accountID.getUserID(), accountID.getService() });\r\n                    UtilActivator.getAlertUIService().showAlertDialog(UtilActivator.getResources().getI18NString(\"service.gui.ERROR\"), msgText);\r\n                }\r\n                if (logger.isTraceEnabled())\r\n                    logger.trace(evt.getReason());\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ScServiceDiscoveryManager.discoverInfo",
	"Comment": "returns the discovered information of a given xmpp entity addressed byits jid and note attribute. use this message only when trying to queryinformation which is not directly addressable.",
	"Method": "DiscoverInfo discoverInfo(String entityID,DiscoverInfo discoverInfo,String entityID,String node){\r\n    return discoveryManager.discoverInfo(entityID, node);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.JabberAccRegWizzActivator.getConfigurationService",
	"Comment": "returns the configurationservice obtained from the bundlecontext.",
	"Method": "ConfigurationService getConfigurationService(){\r\n    if (configService == null) {\r\n        ServiceReference serviceReference = bundleContext.getServiceReference(ConfigurationService.class.getName());\r\n        configService = (ConfigurationService) bundleContext.getService(serviceReference);\r\n    }\r\n    return configService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.GuiUtils.replaceSpecialRegExpChars",
	"Comment": "replaces some chars that are special in a regular expression.",
	"Method": "String replaceSpecialRegExpChars(String text){\r\n    return text.replaceAll(\"([.()^&$*|])\", \"\\\\\\\\$1\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.simpleaccreg.SimpleAccountRegistrationActivator.getProvisioningConfigForm",
	"Comment": "returns the first available provisioning configuration form.",
	"Method": "ConfigurationForm getProvisioningConfigForm(){\r\n    return ConfigFormUtils.getConfigForm(ConfigurationForm.ADVANCED_TYPE, provisioningFormClassName);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.TreeContactList.refreshContact",
	"Comment": "indicates that the information corresponding to the givencontact has changed.",
	"Method": "void refreshContact(UIContact contact){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                refreshContact(contact);\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    synchronized (contact) {\r\n        if (!(contact instanceof UIContactImpl))\r\n            return;\r\n        treeModel.nodeChanged(((UIContactImpl) contact).getContactNode());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.TreeContactList.refreshContact",
	"Comment": "indicates that the information corresponding to the givencontact has changed.",
	"Method": "void refreshContact(UIContact contact){\r\n    refreshContact(contact);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomJabberImpl.revokeOwnership",
	"Comment": "revokes ownership privileges from another user. the occupant that loses ownership privileges will become an administrator. room owners may revoke ownership privileges. some room implementations will not allow to grant ownership privileges to other users.",
	"Method": "void revokeOwnership(String jid){\r\n    try {\r\n        multiUserChat.revokeOwnership(jid);\r\n    } catch (XMPPException ex) {\r\n        logger.error(\"An error occurs revoking ownership \" + \"privileges from a user\", ex);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.notificationwiring.NotificationWiringActivator.getImageLoaderService",
	"Comment": "returns an instance of the imageloaderservice obtained from thebundle context.",
	"Method": "ImageLoaderService<?> getImageLoaderService(){\r\n    if (imageLoaderService == null) {\r\n        imageLoaderService = ServiceUtils.getService(bundleContext, ImageLoaderService.class);\r\n    }\r\n    return imageLoaderService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ProtocolIconJabberImpl.getConnectingIcon",
	"Comment": "returns the icon image used to represent the protocol connecting state.",
	"Method": "byte[] getConnectingIcon(){\r\n    return loadIcon(iconPath + \"/status16x16-connecting.gif\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageSourceService.getType",
	"Comment": "returns default type to indicate that this contact source can be queriedby default filters.",
	"Method": "int getType(){\r\n    return sourceServiceType;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.OperationSetMultiUserChatIrcImpl.getExistingChatRooms",
	"Comment": "returns the list of chatrooms currently available onthe server that this protocol provider is connected to.",
	"Method": "List<String> getExistingChatRooms(){\r\n    final IrcConnection connection = this.ircProvider.getIrcStack().getConnection();\r\n    if (connection == null) {\r\n        throw new IllegalStateException(\"Connection is not available.\");\r\n    }\r\n    return connection.getServerChannelLister().getList();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.StringContactSourceServiceImpl.createSourceContact",
	"Comment": "returns the source contact corresponding to the query string.",
	"Method": "SourceContact createSourceContact(String queryString){\r\n    ArrayList<ContactDetail> contactDetails = new ArrayList<ContactDetail>();\r\n    ContactDetail contactDetail = new ContactDetail(queryString);\r\n    ArrayList<Class<? extends OperationSet>> supportedOpSets = new ArrayList<Class<? extends OperationSet>>();\r\n    supportedOpSets.add(opSetClass);\r\n    contactDetail.setSupportedOpSets(supportedOpSets);\r\n    Map<Class<? extends OperationSet>, ProtocolProviderService> providers = new HashMap<Class<? extends OperationSet>, ProtocolProviderService>();\r\n    providers.put(opSetClass, protocolProvider);\r\n    contactDetail.setPreferredProviders(providers);\r\n    contactDetails.add(contactDetail);\r\n    GenericSourceContact sourceContact = new GenericSourceContact(StringContactSourceServiceImpl.this, queryString, contactDetails);\r\n    if (disableDisplayDetails) {\r\n        sourceContact.setDisplayDetails(GuiActivator.getResources().getI18NString(\"service.gui.CALL_VIA\") + \" \" + protocolProvider.getAccountID().getDisplayName());\r\n    }\r\n    return sourceContact;\r\n}"
}, {
	"Path": "net.librec.eval.ranking.NoveltyEvaluator.evaluate",
	"Comment": "evaluate on the test set with the the list of recommended items.",
	"Method": "double evaluate(RecommendedList groundTruthList,RecommendedList recommendedList){\r\n    int numUsers = groundTruthList.size();\r\n    int[] itemCounts = conf.getInts(\"rec.eval.item.purchase.num\");\r\n    double sumInformation = 0;\r\n    for (int contextIdx = 0; contextIdx < numUsers; contextIdx++) {\r\n        List<KeyValue<Integer, Double>> recoList = recommendedList.getKeyValueListByContext(contextIdx);\r\n        int topK = this.topN <= recoList.size() ? this.topN : recoList.size();\r\n        for (int recoIdx = 0; recoIdx < topK; recoIdx++) {\r\n            int itemIdx = recoList.get(recoIdx).getKey();\r\n            int count = itemCounts[itemIdx];\r\n            if (count > 0) {\r\n                double estmProbability = ((double) count) / numUsers;\r\n                double selfInformation = -Math.log(estmProbability);\r\n                sumInformation += selfInformation;\r\n            }\r\n        }\r\n    }\r\n    return sumInformation / (numUsers * Math.log(2));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockChatRoom.removePropertyChangeListener",
	"Comment": "removes a listener that was being notified of changes in the property ofthe chat room such as the subject being change or the room state beingchanged.",
	"Method": "void removePropertyChangeListener(ChatRoomPropertyChangeListener listener){\r\n    propertyChangeListeners.remove(listener);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.SearchField.enableUnknownContactView",
	"Comment": "sets the unknown contact view to the main contact list window.",
	"Method": "void enableUnknownContactView(boolean isEnabled){\r\n    SwingUtilities.invokeLater(new Runnable() {\r\n        public void run() {\r\n            if (mainFrame != null)\r\n                mainFrame.enableUnknownContactView(isEnabled);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.SearchField.enableUnknownContactView",
	"Comment": "sets the unknown contact view to the main contact list window.",
	"Method": "void enableUnknownContactView(boolean isEnabled){\r\n    if (mainFrame != null)\r\n        mainFrame.enableUnknownContactView(isEnabled);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.sip.TestOperationSetServerStoredInfo.testReadInfo",
	"Comment": "tests reading info. puts the image to the server by using xcap client andthen gets it by using sip communicator interfaces.",
	"Method": "void testReadInfo(){\r\n    byte[] imageContent = TestOperationSetServerStoredInfoData.IMAGE_CONTENT_1;\r\n    ServerStoredDetails.ImageDetail imageDetail1 = new ServerStoredDetails.ImageDetail(null, imageContent);\r\n    opSetServerStoredAccountInfo.addDetail(imageDetail1);\r\n    Iterator<ServerStoredDetails.GenericDetail> storedDetails = opSetServerStoredAccountInfo.getDetails(ServerStoredDetails.ImageDetail.class);\r\n    assertNotNull(\"Stored details cannot be null\", storedDetails);\r\n    assertTrue(\"Stored details doesn't have ImageDetail\", storedDetails.hasNext());\r\n    ServerStoredDetails.GenericDetail storedImageDetail = storedDetails.next();\r\n    assertTrue(\"Stored details is not ImageDetail\", storedImageDetail instanceof ServerStoredDetails.ImageDetail);\r\n    byte[] savedContent = ((ServerStoredDetails.ImageDetail) storedImageDetail).getBytes();\r\n    assertEquals(\"The ImageDetail we set is not set or not read properly\", imageContent.length, savedContent.length);\r\n    for (int i = 0; i < imageContent.length; i++) {\r\n        assertSame(\"The ImageDetail we set has not the same content\", imageContent[i], savedContent[i]);\r\n    }\r\n    ContentType presContent = xCapClient.getPresContent(ServerStoredContactListSipImpl.PRES_CONTENT_IMAGE_NAME);\r\n    assertNotNull(\"Pres-content cannot be null\", presContent);\r\n    assertNotNull(\"Pres-content data cannot be null\", presContent.getData());\r\n    assertNotNull(\"Pres-content data value cannot be null\", presContent.getData().getValue());\r\n    byte[] serverContent = Base64.decode(presContent.getData().getValue());\r\n    assertEquals(\"The ImageDetail we set is not set or not read properly\", imageContent.length, serverContent.length);\r\n    for (int i = 0; i < imageContent.length; i++) {\r\n        assertSame(\"The ImageDetail we set has not the same content\", imageContent[i], serverContent[i]);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.menus.SIPCommWindowMenuBar.isTransparent",
	"Comment": "determines whether a specific image is transparent and thus doesnot need drawing because nothing will be drawn.",
	"Method": "boolean isTransparent(Image image){\r\n    if (image instanceof BufferedImage) {\r\n        BufferedImage bufferedImage = (BufferedImage) image;\r\n        int width = bufferedImage.getWidth();\r\n        if ((-1 < width) && (width < 17)) {\r\n            int height = bufferedImage.getHeight();\r\n            if ((-1 < height) && (height < 17) && (bufferedImage.getTransparency() != Transparency.OPAQUE)) {\r\n                boolean transparent = true;\r\n                for (int i = 0, min = Math.min(width, height); i < min; i++) {\r\n                    int rgb = bufferedImage.getRGB(i, i);\r\n                    if ((rgb & 0xFF000000) != 0) {\r\n                        transparent = false;\r\n                        break;\r\n                    }\r\n                }\r\n                return transparent;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.ConferenceDescription.addTransport",
	"Comment": "adds a transport to the set of transports supportedby the conference.",
	"Method": "void addTransport(String transport){\r\n    transports.add(transport);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ServerStoredContactListIcqImpl.fireGroupEvent",
	"Comment": "creates the corresponding event and notifies allserverstoredgrouplisteners that the source group has beenremoved, changed, renamed or whatever happened to it.",
	"Method": "void fireGroupEvent(ContactGroup group,int eventID){\r\n    if (parentOperationSet == null) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"No presence op. set available. Bailing out.\");\r\n        return;\r\n    }\r\n    ServerStoredGroupEvent evt = new ServerStoredGroupEvent(group, eventID, parentOperationSet.getServerStoredContactListRoot(), icqProvider, parentOperationSet);\r\n    if (logger.isTraceEnabled())\r\n        logger.trace(\"Will dispatch the following grp event: \" + evt);\r\n    Iterable<ServerStoredGroupListener> listeners;\r\n    synchronized (serverStoredGroupListeners) {\r\n        listeners = new ArrayList<ServerStoredGroupListener>(serverStoredGroupListeners);\r\n    }\r\n    for (ServerStoredGroupListener listener : listeners) {\r\n        if (eventID == ServerStoredGroupEvent.GROUP_REMOVED_EVENT)\r\n            listener.groupRemoved(evt);\r\n        else if (eventID == ServerStoredGroupEvent.GROUP_RENAMED_EVENT)\r\n            listener.groupNameChanged(evt);\r\n        else if (eventID == ServerStoredGroupEvent.GROUP_CREATED_EVENT)\r\n            listener.groupCreated(evt);\r\n        else if (eventID == ServerStoredGroupEvent.GROUP_RESOLVED_EVENT)\r\n            listener.groupResolved(evt);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.IceUdpTransportManager.wrapupCandidateHarvest",
	"Comment": "simply returns the list of local candidates that we gathered during theharvest.",
	"Method": "List<ContentPacketExtension> wrapupCandidateHarvest(){\r\n    return cpeList;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.presence.GlobalStatusMessageMenu.getDescriptor",
	"Comment": "returns the descriptor common for this status message menu instance.",
	"Method": "Object getDescriptor(){\r\n    return GlobalStatusMessageMenu.class;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.presence.AbstractStatusMessageMenu.clearSelectedItems",
	"Comment": "clears all items that they are not selected and its name is not bold.",
	"Method": "void clearSelectedItems(){\r\n    for (int i = 0; i < getMenuComponentCount(); i++) {\r\n        Object c = getMenuComponent(i);\r\n        if (c instanceof JCheckBoxMenuItem) {\r\n            JCheckBoxMenuItem checkItem = (JCheckBoxMenuItem) c;\r\n            checkItem.setSelected(false);\r\n            checkItem.setText(checkItem.getName());\r\n        } else if (c instanceof CheckboxMenuItem) {\r\n            CheckboxMenuItem checkItem = (CheckboxMenuItem) c;\r\n            checkItem.setState(false);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetBasicInstantMessagingSipImpl.sendInstantMessage",
	"Comment": "sends the message to the destination indicated by theto contact.",
	"Method": "void sendInstantMessage(Contact to,Message message){\r\n    if (!(to instanceof ContactSipImpl))\r\n        throw new IllegalArgumentException(\"The specified contact is not a Sip contact.\" + to);\r\n    assertConnected();\r\n    if (to.getPresenceStatus().equals(sipStatusEnum.getStatus(SipStatusEnum.OFFLINE)) && !offlineMessageSupported) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"trying to send a message to an offline contact\");\r\n        fireMessageDeliveryFailed(message, to, MessageDeliveryFailedEvent.OFFLINE_MESSAGES_NOT_SUPPORTED);\r\n        return;\r\n    }\r\n    Message[] transformedMessages = transformSIPMessage(to, message);\r\n    for (Message msg : transformedMessages) {\r\n        Request mes;\r\n        try {\r\n            mes = createMessageRequest(to, msg);\r\n        } catch (OperationFailedException ex) {\r\n            logger.error(\"Failed to create the message.\", ex);\r\n            fireMessageDeliveryFailed(message, to, MessageDeliveryFailedEvent.INTERNAL_ERROR);\r\n            continue;\r\n        }\r\n        try {\r\n            sendMessageRequest(mes, to, message);\r\n        } catch (TransactionUnavailableException ex) {\r\n            logger.error(\"Failed to create messageTransaction.\\n\" + \"This is most probably a network connection error.\", ex);\r\n            fireMessageDeliveryFailed(message, to, MessageDeliveryFailedEvent.NETWORK_FAILURE);\r\n            continue;\r\n        } catch (SipException ex) {\r\n            logger.error(\"Failed to send the message.\", ex);\r\n            fireMessageDeliveryFailed(message, to, MessageDeliveryFailedEvent.INTERNAL_ERROR);\r\n            continue;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ContactJabberImpl.setJid",
	"Comment": "used from volatile contacts to handle jid and resources.volatile contacts are always unavailable so do not remove theirresources from the contact as it will be the only resource we will use.",
	"Method": "void setJid(String fullJid){\r\n    this.jid = fullJid;\r\n    if (resources == null)\r\n        resources = new ConcurrentHashMap<String, ContactResourceJabberImpl>();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.AdHocChatRoomIcqImpl.join",
	"Comment": "joins this chat room with the nickname of the local user so that the userwould start receiving events and messages for it.",
	"Method": "void join(){\r\n    if (chatRoomSession == null && chatInvitation == null) {\r\n        ChatRoomManager chatRoomManager = provider.getAimConnection().getChatRoomManager();\r\n        chatRoomSession = chatRoomManager.joinRoom(this.getName());\r\n        chatRoomSession.addListener(new AdHocChatRoomSessionListenerImpl(this));\r\n    } else if (chatInvitation != null) {\r\n        chatRoomSession = chatInvitation.accept();\r\n        chatRoomSession.addListener(new AdHocChatRoomSessionListenerImpl(this));\r\n    }\r\n    opSetMuc.fireLocalUserPresenceEvent(this, LocalUserAdHocChatRoomPresenceChangeEvent.LOCAL_USER_JOINED, null);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetFileTransferIcqImpl.removeFileTransferListener",
	"Comment": "removes the given filetransferlistener that listens forfile transfer requests and created file transfers.",
	"Method": "void removeFileTransferListener(FileTransferListener listener){\r\n    synchronized (fileTransferListeners) {\r\n        this.fileTransferListeners.remove(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.notifsource.NotificationContact.setReadMessageCount",
	"Comment": "sets the number of read messages, this notification is about.",
	"Method": "void setReadMessageCount(int count){\r\n    this.readMessageCount = count;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.provdisc.dhcp.DHCPProvisioningDiscover.discoverProvisioningURL",
	"Comment": "it sends a dhcpinform message from all interfaces and wait for aresponse. thread stops after first successful answer that containsspecific option and thus the provisioning url.",
	"Method": "String discoverProvisioningURL(){\r\n    DHCPPacket inform = new DHCPPacket();\r\n    byte[] macAddress = null;\r\n    byte[] zeroIPAddress = { 0x00, 0x00, 0x00, 0x00 };\r\n    byte[] broadcastIPAddr = { (byte) 255, (byte) 255, (byte) 255, (byte) 255 };\r\n    DHCPOption[] dhcpOpts = new DHCPOption[1];\r\n    List<DHCPTransaction> transactions = new ArrayList<DHCPTransaction>();\r\n    try {\r\n        inform.setOp(DHCPConstants.BOOTREQUEST);\r\n        inform.setHtype(DHCPConstants.HTYPE_ETHER);\r\n        inform.setHlen((byte) 6);\r\n        inform.setHops((byte) 0);\r\n        inform.setXid(xid);\r\n        inform.setSecs((short) 0);\r\n        inform.setFlags((short) 0);\r\n        inform.setYiaddr(InetAddress.getByAddress(zeroIPAddress));\r\n        inform.setSiaddr(InetAddress.getByAddress(zeroIPAddress));\r\n        inform.setGiaddr(InetAddress.getByAddress(zeroIPAddress));\r\n        inform.setDhcp(true);\r\n        inform.setDHCPMessageType(DHCPConstants.DHCPINFORM);\r\n        dhcpOpts[0] = new DHCPOption(DHCPConstants.DHO_DHCP_PARAMETER_REQUEST_LIST, new byte[] { option });\r\n        inform.setOptions(dhcpOpts);\r\n        Enumeration<NetworkInterface> en = NetworkInterface.getNetworkInterfaces();\r\n        while (en.hasMoreElements()) {\r\n            NetworkInterface iface = en.nextElement();\r\n            Enumeration<InetAddress> enAddr = iface.getInetAddresses();\r\n            while (enAddr.hasMoreElements()) {\r\n                InetAddress addr = enAddr.nextElement();\r\n                if (addr instanceof Inet4Address) {\r\n                    NetworkAddressManagerService netaddr = ProvisioningDiscoveryDHCPActivator.getNetworkAddressManagerService();\r\n                    if (!addr.isLoopbackAddress()) {\r\n                        macAddress = netaddr.getHardwareAddress(iface);\r\n                        DHCPPacket p = inform.clone();\r\n                        p.setCiaddr(addr);\r\n                        p.setChaddr(macAddress);\r\n                        byte[] msg = p.serialize();\r\n                        DatagramPacket pkt = new DatagramPacket(msg, msg.length, InetAddress.getByAddress(broadcastIPAddr), port - 1);\r\n                        DHCPTransaction transaction = new DHCPTransaction(socket, pkt);\r\n                        transaction.schedule();\r\n                        transactions.add(transaction);\r\n                        msg = null;\r\n                        pkt = null;\r\n                        p = null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        boolean found = false;\r\n        try {\r\n            DatagramPacket pkt2 = new DatagramPacket(new byte[1500], 1500);\r\n            while (!found) {\r\n                socket.receive(pkt2);\r\n                DHCPPacket dhcp = DHCPPacket.getPacket(pkt2);\r\n                if (dhcp.getXid() != xid) {\r\n                    continue;\r\n                }\r\n                DHCPOption optProvisioning = dhcp.getOption(option);\r\n                if (optProvisioning != null) {\r\n                    found = true;\r\n                    for (DHCPTransaction t : transactions) {\r\n                        t.cancel();\r\n                    }\r\n                    return new String(optProvisioning.getValue());\r\n                }\r\n            }\r\n        } catch (SocketTimeoutException est) {\r\n            logger.warn(\"Timeout, no DHCP answer received\", est);\r\n        }\r\n    } catch (Exception e) {\r\n        logger.warn(\"Exception occurred during DHCP discover\", e);\r\n    }\r\n    for (DHCPTransaction t : transactions) {\r\n        t.cancel();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.GuiActivator.getKeybindingsService",
	"Comment": "returns the keybindingsservice obtained from the bundle context.",
	"Method": "KeybindingsService getKeybindingsService(){\r\n    if (keybindingsService == null) {\r\n        keybindingsService = ServiceUtils.getService(bundleContext, KeybindingsService.class);\r\n    }\r\n    return keybindingsService;\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.server.ab.AbstractABCase.clone",
	"Comment": "make a copy of a byte buffer.this is important in some tests, as the underlying byte buffer contained in a frame can be modified throughmasking and make it difficult to compare the results in the fuzzer.",
	"Method": "ByteBuffer clone(ByteBuffer payload){\r\n    ByteBuffer copy = ByteBuffer.allocate(payload.remaining());\r\n    copy.put(payload.slice());\r\n    copy.flip();\r\n    return copy;\r\n}"
}, {
	"Path": "io.lettuce.core.support.LettuceCdiExtension.afterBeanDiscovery",
	"Comment": "implementation of a an observer which registers beans to the cdi container for the detected redisuris.the repository beans are associated to the entitymanagers using their qualifiers.",
	"Method": "void afterBeanDiscovery(AfterBeanDiscovery afterBeanDiscovery,BeanManager beanManager){\r\n    int counter = 0;\r\n    for (Entry<Set<Annotation>, Bean<RedisURI>> entry : redisUris.entrySet()) {\r\n        Bean<RedisURI> redisUri = entry.getValue();\r\n        Set<Annotation> qualifiers = entry.getKey();\r\n        String clientBeanName = RedisClient.class.getSimpleName();\r\n        String clusterClientBeanName = RedisClusterClient.class.getSimpleName();\r\n        if (!containsDefault(qualifiers)) {\r\n            clientBeanName += counter;\r\n            clusterClientBeanName += counter;\r\n            counter++;\r\n        }\r\n        Bean<ClientResources> clientResources = this.clientResources.get(qualifiers);\r\n        RedisClientCdiBean clientBean = new RedisClientCdiBean(redisUri, clientResources, beanManager, qualifiers, clientBeanName);\r\n        register(afterBeanDiscovery, qualifiers, clientBean);\r\n        RedisClusterClientCdiBean clusterClientBean = new RedisClusterClientCdiBean(redisUri, clientResources, beanManager, qualifiers, clusterClientBeanName);\r\n        register(afterBeanDiscovery, qualifiers, clusterClientBean);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.keybindings.KeybindingsServiceImpl.update",
	"Comment": "listens for changes in binding sets so changes can be written.",
	"Method": "void update(Observable obs,Object arg){\r\n    if (obs instanceof KeybindingSetImpl) {\r\n        KeybindingSetImpl changedBindings = (KeybindingSetImpl) obs;\r\n        if (changedBindings.isWritable()) {\r\n            synchronized (this) {\r\n                if (changedBindings.isWritable()) {\r\n                    File customFile = changedBindings.getCustomFile();\r\n                    try {\r\n                        FileOutputStream out = new FileOutputStream(customFile);\r\n                        Persistence format = changedBindings.getCategory().getFormat();\r\n                        format.save(out, changedBindings.getBindings());\r\n                        out.close();\r\n                    } catch (IOException exc) {\r\n                        logger.error(\"unable to write to: \" + customFile.getAbsolutePath(), exc);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.CreationTest.testSessionCreateWithEviction",
	"Comment": "test creating a session when the cache is set toevict after the request exits.",
	"Method": "void testSessionCreateWithEviction(){\r\n    String contextPath = \"\";\r\n    String servletMapping = \"/server\";\r\n    DefaultSessionCacheFactory cacheFactory = new DefaultSessionCacheFactory();\r\n    cacheFactory.setEvictionPolicy(SessionCache.EVICT_ON_SESSION_EXIT);\r\n    SessionDataStoreFactory storeFactory = new TestSessionDataStoreFactory();\r\n    TestServer server1 = new TestServer(0, -1, -1, cacheFactory, storeFactory);\r\n    TestServlet servlet = new TestServlet();\r\n    ServletHolder holder = new ServletHolder(servlet);\r\n    ServletContextHandler contextHandler = server1.addContext(contextPath);\r\n    TestContextScopeListener scopeListener = new TestContextScopeListener();\r\n    contextHandler.addEventListener(scopeListener);\r\n    contextHandler.addServlet(holder, servletMapping);\r\n    servlet.setStore(contextHandler.getSessionHandler().getSessionCache().getSessionDataStore());\r\n    server1.start();\r\n    int port1 = server1.getPort();\r\n    try (StacklessLogging stackless = new StacklessLogging(Log.getLogger(\"org.eclipse.jetty.server.session\"))) {\r\n        HttpClient client = new HttpClient();\r\n        client.start();\r\n        String url = \"http://localhost:\" + port1 + contextPath + servletMapping + \"?action=create&check=false\";\r\n        CountDownLatch synchronizer = new CountDownLatch(1);\r\n        scopeListener.setExitSynchronizer(synchronizer);\r\n        ContentResponse response = client.GET(url);\r\n        assertEquals(HttpServletResponse.SC_OK, response.getStatus());\r\n        String sessionCookie = response.getHeaders().get(\"Set-Cookie\");\r\n        assertTrue(sessionCookie != null);\r\n        synchronizer.await(5, TimeUnit.SECONDS);\r\n        String id = TestServer.extractSessionId(sessionCookie);\r\n        assertFalse(contextHandler.getSessionHandler().getSessionCache().contains(id));\r\n        assertTrue(contextHandler.getSessionHandler().getSessionCache().getSessionDataStore().exists(id));\r\n        synchronizer = new CountDownLatch(1);\r\n        scopeListener.setExitSynchronizer(synchronizer);\r\n        Request request = client.newRequest(\"http://localhost:\" + port1 + contextPath + servletMapping + \"?action=test\");\r\n        response = request.send();\r\n        assertEquals(HttpServletResponse.SC_OK, response.getStatus());\r\n        synchronizer.await(5, TimeUnit.SECONDS);\r\n        assertFalse(contextHandler.getSessionHandler().getSessionCache().contains(TestServer.extractSessionId(sessionCookie)));\r\n    } finally {\r\n        server1.stop();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.gibberish.TestAccountUninstallation.testUninstallAccount",
	"Comment": "uinstalls our test account and makes sure it really has been removed.",
	"Method": "void testUninstallAccount(){\r\n    assertFalse(\"No installed accounts found\", fixture.providerFactory.getRegisteredAccounts().isEmpty());\r\n    assertNotNull(\"Found no provider corresponding to URI \" + fixture.userID1, fixture.providerFactory.getProviderForAccount(fixture.provider1.getAccountID()));\r\n    assertTrue(\"Failed to remove a provider corresponding to URI \" + fixture.userID1, fixture.providerFactory.uninstallAccount(fixture.provider1.getAccountID()));\r\n    assertTrue(\"Failed to remove a provider corresponding to URI \" + fixture.userID1, fixture.providerFactory.uninstallAccount(fixture.provider2.getAccountID()));\r\n    ServiceReference[] gibberishProviderRefs = null;\r\n    try {\r\n        gibberishProviderRefs = GibberishSlickFixture.bc.getServiceReferences(ProtocolProviderService.class.getName(), \"(\" + ProtocolProviderFactory.PROTOCOL + \"=Gibberish)\");\r\n    } catch (InvalidSyntaxException ex) {\r\n        fail(\"We apparently got our filter wrong \" + ex.getMessage());\r\n    }\r\n    assertTrue(\"A Protocol Provider Service was still regged as an osgi \" + \"service for Gibberish URI:\" + fixture.userID1 + \"After it was explicitly uninstalled\", gibberishProviderRefs == null || gibberishProviderRefs.length == 0);\r\n    assertTrue(\"The Gibberish provider factory kept a reference to the provider we \" + \"just uninstalled (uri=\" + fixture.userID1 + \")\", fixture.providerFactory.getRegisteredAccounts().isEmpty() && fixture.providerFactory.getProviderForAccount(fixture.provider1.getAccountID()) == null);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.customcontrols.BoxPopupMenu.getPopupLocation",
	"Comment": "returns the location of the popup depending on the invoking componentcoordinates.",
	"Method": "Point getPopupLocation(){\r\n    Component component = this.getInvoker();\r\n    Point point = new Point();\r\n    int x = component.getX();\r\n    int y = component.getY();\r\n    while (component.getParent() != null) {\r\n        component = component.getParent();\r\n        x += component.getX();\r\n        y += component.getY();\r\n    }\r\n    point.x = x;\r\n    point.y = y + this.getInvoker().getHeight();\r\n    return point;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.ChatRoomListImpl.addChatRoomListChangeListener",
	"Comment": "adds the given chatroomlistchangelistener that will listen forall changes of the chat room list data model.",
	"Method": "void addChatRoomListChangeListener(ChatRoomListChangeListener l){\r\n    synchronized (listChangeListeners) {\r\n        listChangeListeners.add(l);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.notificationwiring.NotificationManager.shouldPlayDialingSound",
	"Comment": "determines whether the dialing sound notification should beplayed for a specific callpeer.",
	"Method": "boolean shouldPlayDialingSound(WeakReference<CallPeer> weakPeer){\r\n    CallPeer peer = weakPeer.get();\r\n    if (peer == null)\r\n        return false;\r\n    Call call = peer.getCall();\r\n    if (call == null)\r\n        return false;\r\n    CallConference conference = call.getConference();\r\n    if (conference == null)\r\n        return false;\r\n    boolean play = false;\r\n    for (Call aCall : conference.getCalls()) {\r\n        Iterator<? extends CallPeer> peerIter = aCall.getCallPeers();\r\n        while (peerIter.hasNext()) {\r\n            CallPeer aPeer = peerIter.next();\r\n            if (peer == aPeer)\r\n                play = true;\r\n            CallPeerState state = peer.getState();\r\n            if (CallPeerState.INITIATING_CALL.equals(state) || CallPeerState.CONNECTING.equals(state)) {\r\n                if (peer != aPeer)\r\n                    return false;\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return play;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler.isRemotelyOnHold",
	"Comment": "determines whether the remote party has placed all our streams on hold.",
	"Method": "boolean isRemotelyOnHold(){\r\n    for (MediaType mediaType : MediaType.values()) {\r\n        MediaStream stream = getStream(mediaType);\r\n        if ((stream != null) && stream.getDirection().allowsSending())\r\n            return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "net.librec.eval.ranking.ReciprocalRankEvaluator.evaluate",
	"Comment": "evaluate on the test set with the the list of recommended items.",
	"Method": "double evaluate(RecommendedList groundTruthList,RecommendedList recommendedList){\r\n    double reciprocalRank = 0.0;\r\n    int numContext = groundTruthList.size();\r\n    int nonZeroContext = 0;\r\n    for (int contextIdx = 0; contextIdx < numContext; ++contextIdx) {\r\n        Set<Integer> testSetByContext = groundTruthList.getKeySetByContext(contextIdx);\r\n        if (testSetByContext.size() > 0) {\r\n            List<KeyValue<Integer, Double>> recommendListByContext = recommendedList.getKeyValueListByContext(contextIdx);\r\n            int topK = this.topN <= recommendListByContext.size() ? this.topN : recommendListByContext.size();\r\n            for (int indexOfKey = 0; indexOfKey < topK; ++indexOfKey) {\r\n                int key = recommendListByContext.get(indexOfKey).getKey();\r\n                if (testSetByContext.contains(key)) {\r\n                    reciprocalRank += 1.0d / (indexOfKey + 1.0d);\r\n                    break;\r\n                }\r\n            }\r\n            nonZeroContext++;\r\n        }\r\n    }\r\n    return nonZeroContext > 0 ? reciprocalRank / nonZeroContext : 0.0d;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.configuration.TestConfigurationService.testSinglePropertyEventNotification",
	"Comment": "make sure that adding listeners for a single property nameonly gets us events for that listeners. removing a listener for aspecific property should also be proved to no obstruct event delivery tothe same listener had it been registered for other properties.",
	"Method": "void testSinglePropertyEventNotification(){\r\n    String listenedPropertyValue = \"19.2598\";\r\n    String listenedPropertyNewValue = \"19.29581\";\r\n    configurationService.addPropertyChangeListener(listenedPropertyName, pListener);\r\n    propertyChangeEvent = null;\r\n    configurationService.setProperty(propertyName, propertyValue);\r\n    assertNull(\"setting prop:\" + propertyName + \" caused an event notif. to \" + \"listener registered for prop:\" + listenedPropertyName, propertyChangeEvent);\r\n    configurationService.setProperty(listenedPropertyName, listenedPropertyValue);\r\n    assertNotNull(\"No event was dispatched upon modification of prop:\" + listenedPropertyName, propertyChangeEvent);\r\n    assertNull(\"oldValue must be null\", propertyChangeEvent.getOldValue());\r\n    assertEquals(\"wrong newValue\", listenedPropertyValue, propertyChangeEvent.getNewValue());\r\n    propertyChangeEvent = null;\r\n    configurationService.removePropertyChangeListener(pListener);\r\n    configurationService.setProperty(listenedPropertyName, listenedPropertyNewValue);\r\n    assertNotNull(\"No event was dispatched upon modification of prop:\" + listenedPropertyName + \". The listener was wrongfully removed.\", propertyChangeEvent);\r\n    assertEquals(\"wrong oldValue\", listenedPropertyValue, propertyChangeEvent.getOldValue());\r\n    assertEquals(\"wrong newValue\", listenedPropertyNewValue, propertyChangeEvent.getNewValue());\r\n    propertyChangeEvent = null;\r\n    configurationService.removePropertyChangeListener(listenedPropertyName, pListener);\r\n    configurationService.setProperty(listenedPropertyName, propertyValue);\r\n    assertNull(\"An event was wrongfully dispatched after removing a listener\", propertyChangeEvent);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.MetaUIContact.getContactDetailsForOperationSet",
	"Comment": "returns a list of uicontactdetails supporting the givenoperationset class.",
	"Method": "List<UIContactDetail> getContactDetailsForOperationSet(Class<? extends OperationSet> opSetClass){\r\n    List<UIContactDetail> resultList = new LinkedList<UIContactDetail>();\r\n    Iterator<Contact> contacts = metaContact.getContactsForOperationSet(opSetClass).iterator();\r\n    while (contacts.hasNext()) {\r\n        resultList.add(new MetaContactDetail(contacts.next()));\r\n    }\r\n    return resultList;\r\n}"
}, {
	"Path": "io.lettuce.core.protocol.DefaultEndpoint.reset",
	"Comment": "reset the writer state. queued commands will be canceled and the internal state will be reset. this is useful when theinternal state machine gets out of sync with the connection.",
	"Method": "void reset(){\r\n    if (debugEnabled) {\r\n        logger.debug(\"{} reset()\", logPrefix());\r\n    }\r\n    if (channel != null) {\r\n        channel.pipeline().fireUserEventTriggered(new ConnectionEvents.Reset());\r\n    }\r\n    cancelBufferedCommands(\"Reset\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetPersistentPresenceIcqImpl.getLocalContact",
	"Comment": "returns the protocol specific contact instance representing the localuser.",
	"Method": "Contact getLocalContact(){\r\n    return localContact;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.ProviderPresenceStatusChangeEvent.toString",
	"Comment": "returns a string representation of this providerpresencestatuschangeevent",
	"Method": "String toString(){\r\n    StringBuffer buff = new StringBuffer(\"ProviderPresenceStatusChangeEvent-[\");\r\n    return buff.append(\"OldStatus=\").append(getOldStatus()).append(\", NewStatus=\").append(getNewStatus()).append(\"]\").toString();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetServerStoredAccountInfoIcqImpl.assertConnected",
	"Comment": "utility method throwing an exception if the icq stack is not properlyinitialized.",
	"Method": "void assertConnected(){\r\n    if (icqProvider == null)\r\n        throw new IllegalStateException(\"The icq provider must be non-null and signed on the ICQ \" + \"service before being able to communicate.\");\r\n    if (!icqProvider.isRegistered())\r\n        throw new IllegalStateException(\"The icq provider must be signed on the ICQ service before \" + \"being able to communicate.\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommTextField.removeTextChangeListener",
	"Comment": "removes the given textfieldchangelistener from the list oflisteners notified on changes of the text contained in this field.",
	"Method": "void removeTextChangeListener(TextFieldChangeListener l){\r\n    synchronized (changeListeners) {\r\n        changeListeners.remove(l);\r\n    }\r\n}"
}, {
	"Path": "net.librec.data.model.ArffDataModelTestCase.getTrainSize",
	"Comment": "returns the size of training matrix of a specified datamodel object",
	"Method": "int getTrainSize(DataModel dataModel){\r\n    return dataModel.getDataSplitter().getTrainData().size();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MclStorageManager.initVirginDocument",
	"Comment": "fills the document with the tags necessary for it to be filled properlyas the meta contact list evolves.",
	"Method": "void initVirginDocument(MetaContactListServiceImpl mclServImpl,Document contactListDoc){\r\n    Element root = contactListDoc.createElement(DOCUMENT_ROOT_NAME);\r\n    contactListDoc.appendChild(root);\r\n    Element rootGroup = createMetaContactGroupNode(mclServImpl.getRoot());\r\n    root.appendChild(rootGroup);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.callhistory.CallHistoryServiceLick.start",
	"Comment": "start the history sevice implementation compatibility kit.",
	"Method": "void start(BundleContext bundleContext){\r\n    CallHistoryServiceLick.bc = bundleContext;\r\n    setName(\"CallHistoryServiceLick\");\r\n    Hashtable<String, String> properties = new Hashtable<String, String>();\r\n    properties.put(\"service.pid\", getName());\r\n    addTest(TestCallHistoryService.suite());\r\n    bundleContext.registerService(getClass().getName(), this, properties);\r\n    logger.debug(\"Successfully registered \" + getClass().getName());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.notification.SoundNotificationHandlerImpl.start",
	"Comment": "plays the sound given by the containing soundfiledescriptor. thesound is played in loop if the loopinterval is defined.",
	"Method": "void start(SoundNotificationAction action,NotificationData data){\r\n    if (isMute())\r\n        return;\r\n    boolean playOnlyOnPlayback = true;\r\n    AudioNotifierService audioNotifService = NotificationActivator.getAudioNotifier();\r\n    if (audioNotifService != null) {\r\n        playOnlyOnPlayback = audioNotifService.audioOutAndNotificationsShareSameDevice();\r\n    }\r\n    if (playOnlyOnPlayback) {\r\n        if (action.isSoundNotificationEnabled() || action.isSoundPlaybackEnabled()) {\r\n            play(action, data, SCAudioClipDevice.PLAYBACK);\r\n        }\r\n    } else {\r\n        if (action.isSoundNotificationEnabled())\r\n            play(action, data, SCAudioClipDevice.NOTIFICATION);\r\n        if (action.isSoundPlaybackEnabled())\r\n            play(action, data, SCAudioClipDevice.PLAYBACK);\r\n    }\r\n    if (action.isSoundPCSpeakerEnabled())\r\n        play(action, data, SCAudioClipDevice.PC_SPEAKER);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.JabberAccountRegistrationWizard.getSummary",
	"Comment": "returns the set of data that user has entered through this wizard.",
	"Method": "Iterator<Map.Entry<String, String>> getSummary(){\r\n    Hashtable<String, String> summaryTable = new Hashtable<String, String>();\r\n    summaryTable.put(Resources.getString(\"plugin.jabberaccregwizz.USERNAME\"), registration.getUserID());\r\n    summaryTable.put(Resources.getString(\"service.gui.REMEMBER_PASSWORD\"), Boolean.toString(registration.isRememberPassword()));\r\n    summaryTable.put(Resources.getString(\"plugin.jabberaccregwizz.SERVER\"), registration.getServerAddress());\r\n    summaryTable.put(Resources.getString(\"service.gui.PORT\"), String.valueOf(registration.getServerPort()));\r\n    summaryTable.put(Resources.getString(\"plugin.jabberaccregwizz.ENABLE_KEEP_ALIVE\"), String.valueOf(registration.isSendKeepAlive()));\r\n    summaryTable.put(Resources.getString(\"plugin.jabberaccregwizz.ENABLE_GMAIL_NOTIFICATIONS\"), String.valueOf(registration.isGmailNotificationEnabled()));\r\n    summaryTable.put(Resources.getString(\"plugin.jabberaccregwizz.RESOURCE\"), registration.getResource());\r\n    summaryTable.put(Resources.getString(\"plugin.jabberaccregwizz.PRIORITY\"), String.valueOf(registration.getPriority()));\r\n    summaryTable.put(Resources.getString(\"plugin.sipaccregwizz.DTMF_METHOD\"), registration.getDTMFMethod());\r\n    summaryTable.put(Resources.getString(\"plugin.sipaccregwizz.DTMF_MINIMAL_TONE_DURATION\"), registration.getDtmfMinimalToneDuration());\r\n    return summaryTable.entrySet().iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.notificationconfiguration.NotificationConfigurationPanel.actionPerformed",
	"Comment": "indicates that one of the contained in this panel buttons has beenclicked.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    int row = notificationList.getSelectedRow();\r\n    if (e.getSource() == restoreButton) {\r\n        notificationList.clear();\r\n        NotificationConfigurationActivator.getNotificationService().restoreDefaults();\r\n    } else if (e.getSource() == soundFileButton) {\r\n        if (row < 0)\r\n            return;\r\n        NotificationEntry entry = notificationList.getNotificationEntry(row);\r\n        File file = soundFileChooser.getFileFromDialog();\r\n        if (file != null) {\r\n            try {\r\n                setLastSoundPath(file.getParent());\r\n                String fileUri = file.toURI().toURL().toExternalForm();\r\n                if (logger.isDebugEnabled())\r\n                    logger.debug(\"Opening: \" + fileUri);\r\n                entry.setSoundFile(fileUri);\r\n                soundFileTextField.setText(fileUri);\r\n            } catch (MalformedURLException ex) {\r\n                logger.error(\"Error file path parsing\", ex);\r\n            }\r\n        } else {\r\n            if (logger.isDebugEnabled())\r\n                logger.debug(\"Open command cancelled by user.\");\r\n        }\r\n    } else if (e.getSource() == programFileButton) {\r\n        if (row < 0)\r\n            return;\r\n        NotificationEntry entry = notificationList.getNotificationEntry(row);\r\n        File file = programFileChooser.getFileFromDialog();\r\n        if (file != null) {\r\n            setLastProgramPath(file.getParent());\r\n            if (logger.isDebugEnabled())\r\n                logger.debug(\"Opening: \" + file.getAbsolutePath());\r\n            entry.setProgramFile(file.getAbsolutePath());\r\n            programFileTextField.setText(file.getAbsolutePath());\r\n        } else {\r\n            if (logger.isDebugEnabled())\r\n                logger.debug(\"Open command cancelled by user.\");\r\n        }\r\n    } else if (e.getSource() == playSoundButton) {\r\n        String soundFile = soundFileTextField.getText();\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"****\" + soundFile + \"****\" + soundFile.length());\r\n        if (soundFile.length() != 0) {\r\n            AudioNotifierService audioNotifServ = NotificationConfigurationActivator.getAudioNotifierService();\r\n            SCAudioClip sound = audioNotifServ.createAudio(soundFile);\r\n            sound.play();\r\n        } else {\r\n            if (logger.isDebugEnabled())\r\n                logger.debug(\"No file specified\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.RootContactGroupJabberImpl.getPersistentData",
	"Comment": "returns null as no persistent data is required and the group name issufficient for restoring the contact.",
	"Method": "String getPersistentData(){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.gui.UIContact.getPreferredHeight",
	"Comment": "returns the preferred height of this group in the contact list.",
	"Method": "int getPreferredHeight(){\r\n    return -1;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.UtilActivator.getUIService",
	"Comment": "gets the uiservice instance registered in thebundlecontext of the utilactivator.",
	"Method": "UIService getUIService(){\r\n    if (uiService == null)\r\n        uiService = ServiceUtils.getService(bundleContext, UIService.class);\r\n    return uiService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.icqaccregwizz.IcqAccountRegistrationWizard.getRegistration",
	"Comment": "returns the registration object, which will store all the data throughthe wizard.",
	"Method": "IcqAccountRegistration getRegistration(){\r\n    return registration;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.InfoRetreiver.getDetailsAndDescendants",
	"Comment": "returns the user details from the specified class or its descendantsthe class is one from thenet.java.sip.communicator.service.protocol.serverstoreddetailsor implemented one in the operation set for the user info",
	"Method": "Iterator<T> getDetailsAndDescendants(String uin,Class<T> detailClass){\r\n    List<GenericDetail> details = getContactDetails(uin);\r\n    List<T> result = new LinkedList<T>();\r\n    for (GenericDetail item : details) if (detailClass.isInstance(item)) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        T t = (T) item;\r\n        result.add(t);\r\n    }\r\n    return result.iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.dns.DnsUtilActivator.getConfigurationService",
	"Comment": "returns the configurationservice obtained from the bundlecontext.",
	"Method": "ConfigurationService getConfigurationService(){\r\n    if (configurationService == null) {\r\n        configurationService = ServiceUtils.getService(bundleContext, ConfigurationService.class);\r\n    }\r\n    return configurationService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.AbstractOperationSetTelephonyConferencing.addPeerToConferenceInfo",
	"Comment": "adds a user element to confinfo which describescallpeer, or the local peer if remote is false.",
	"Method": "void addPeerToConferenceInfo(ConferenceInfoDocument confInfo,MediaAwareCallPeer<?, ?, ?> callPeer,boolean remote){\r\n    String entity = remote ? callPeer.getEntity() : getLocalEntity(callPeer);\r\n    ConferenceInfoDocument.User user = confInfo.addNewUser(entity);\r\n    String displayName = remote ? callPeer.getDisplayName() : getLocalDisplayName();\r\n    user.setDisplayText(displayName);\r\n    ConferenceInfoDocument.Endpoint endpoint = user.addNewEndpoint(entity);\r\n    endpoint.setStatus(remote ? getEndpointStatus(callPeer) : ConferenceInfoDocument.EndpointStatusType.connected);\r\n    CallPeerMediaHandler<?> mediaHandler = callPeer.getMediaHandler();\r\n    for (MediaType mediaType : MediaType.values()) {\r\n        MediaStream stream = mediaHandler.getStream(mediaType);\r\n        if (stream != null || !remote) {\r\n            long srcId = -1;\r\n            if (remote) {\r\n                srcId = getRemoteSourceID(callPeer, mediaType);\r\n            } else if (stream != null) {\r\n                srcId = stream.getLocalSourceID();\r\n            } else {\r\n                for (MediaAwareCallPeer<?, ?, ?> otherCallPeer : callPeer.getCall().getCallPeerList()) {\r\n                    MediaStream otherStream = otherCallPeer.getMediaHandler().getStream(mediaType);\r\n                    if (otherStream != null) {\r\n                        srcId = otherStream.getLocalSourceID();\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            MediaDirection direction = MediaDirection.INACTIVE;\r\n            if (remote) {\r\n                direction = callPeer.getDirection(mediaType).getReverseDirection();\r\n            } else {\r\n                if (mediaType == MediaType.AUDIO && callPeer.getMediaHandler().isLocalAudioTransmissionEnabled())\r\n                    direction = direction.or(MediaDirection.SENDONLY);\r\n                else if (mediaType == MediaType.VIDEO && callPeer.isLocalVideoStreaming())\r\n                    direction = direction.or(MediaDirection.SENDONLY);\r\n                if (callPeer.getDirection(mediaType).allowsReceiving())\r\n                    direction = direction.or(MediaDirection.RECVONLY);\r\n            }\r\n            if ((srcId != -1) || (direction != MediaDirection.INACTIVE)) {\r\n                ConferenceInfoDocument.Media media = endpoint.addNewMedia(mediaType.toString());\r\n                media.setType(mediaType.toString());\r\n                if (srcId != -1)\r\n                    media.setSrcId(Long.toString(srcId));\r\n                media.setStatus(direction.toString());\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.ChatRoomMemberPropertyChangeEvent.getSourceChatRoomMember",
	"Comment": "returns the member of the chat room, for which this event is about.",
	"Method": "ChatRoomMember getSourceChatRoomMember(){\r\n    return (ChatRoomMember) getSource();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.lookandfeel.SIPCommLookAndFeel.isNativeLookAndFeel",
	"Comment": "returns false to indicate that this is not a native look&feel.",
	"Method": "boolean isNativeLookAndFeel(){\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.conference.BasicConferenceCallPanel.updateHoldButtonState",
	"Comment": "updates the state of the general hold button. the hold button is selectedonly if all call peers are locally or mutually on hold at the same time.in all other cases the hold button is unselected.",
	"Method": "void updateHoldButtonState(){\r\n    callPanel.updateHoldButtonState();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.UIServiceImpl.isContainerSupported",
	"Comment": "implements the uiservice.iscontainersupported method.checks if the plugable container with the given container is supportedby this implementation.",
	"Method": "boolean isContainerSupported(Container containderID){\r\n    return supportedContainers.contains(containderID);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.osdependent.OsDependentActivator.getResources",
	"Comment": "returns the resourcemanagementservice, through which we willaccess all resources.",
	"Method": "ResourceManagementService getResources(){\r\n    if (resourcesService == null) {\r\n        resourcesService = ResourceManagementServiceUtils.getService(bundleContext);\r\n    }\r\n    return resourcesService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.ChatRoomInvitationRejectedEvent.getTimestamp",
	"Comment": "a timestamp indicating the exact date when the event ocurred.",
	"Method": "Date getTimestamp(){\r\n    return timestamp;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.TestOperationSetBasicInstantMessaging.firstTestReceiveMessage",
	"Comment": "send an instant message from the tested operation set and assertreception by the tester agent.",
	"Method": "void firstTestReceiveMessage(){\r\n    String body = \"This is an IM coming from the tester agent\" + \" on \" + new Date().toString();\r\n    ImEventCollector evtCollector = new ImEventCollector();\r\n    opSetBasicIM1.addMessageListener(evtCollector);\r\n    Contact testerAgentContact = opSetPresence2.findContactByID(fixture.userID1);\r\n    logger.debug(\"Will send message \" + body + \" to: \" + testerAgentContact);\r\n    opSetBasicIM2.sendInstantMessage(testerAgentContact, opSetBasicIM2.createMessage(body));\r\n    evtCollector.waitForEvent(10000);\r\n    opSetBasicIM1.removeMessageListener(evtCollector);\r\n    assertTrue(\"No events delivered upon a received message\", evtCollector.collectedEvents.size() > 0);\r\n    assertTrue(\"Received evt was not an instance of \" + MessageReceivedEvent.class.getName(), evtCollector.collectedEvents.get(0) instanceof MessageReceivedEvent);\r\n    MessageReceivedEvent evt = (MessageReceivedEvent) evtCollector.collectedEvents.get(0);\r\n    assertEquals(\"message sender \", evt.getSourceContact().getAddress(), fixture.userID2);\r\n    assertEquals(\"message body\", body, evt.getSourceMessage().getContent());\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.sipaccregwizz.ConnectionPanel.getCertificateId",
	"Comment": "gets the id of the selected client tls certificate or null if nocertificate is selected.",
	"Method": "String getCertificateId(){\r\n    Object selectedItem = certificate.getSelectedItem();\r\n    if ((selectedItem != null) && (selectedItem instanceof CertificateConfigEntry)) {\r\n        return ((CertificateConfigEntry) selectedItem).getId();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.MUCActivator.getGlobalDisplayDetailsService",
	"Comment": "returns the globaldisplaydetailsservice obtained from the bundlecontext.",
	"Method": "GlobalDisplayDetailsService getGlobalDisplayDetailsService(){\r\n    if (globalDisplayDetailsService == null) {\r\n        globalDisplayDetailsService = ServiceUtils.getService(bundleContext, GlobalDisplayDetailsService.class);\r\n    }\r\n    return globalDisplayDetailsService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.MetaContactChatSession.metaContactRenamed",
	"Comment": "implements metacontactlistlistener.metacontactrenamed method.when a meta contact is renamed, updates all related labels in thischat panel.",
	"Method": "void metaContactRenamed(MetaContactRenamedEvent evt){\r\n    String newName = evt.getNewDisplayName();\r\n    if (evt.getSourceMetaContact().equals(metaContact)) {\r\n        ChatContact<?> chatContact = findChatContactByMetaContact(evt.getSourceMetaContact());\r\n        sessionRenderer.setContactName(chatContact, newName);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatTransportSelectorBox.allowsSmsMessage",
	"Comment": "returns true if this contains a chat transport thatsupports sms messaging, otherwise returns false.",
	"Method": "boolean allowsSmsMessage(){\r\n    for (ChatTransport tr : transportMenuItems.keySet()) {\r\n        if (tr.allowsSmsMessage())\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.ChooseCallAccountDialog.callButtonPressed",
	"Comment": "calls through the selected account when the call button is pressed.",
	"Method": "void callButtonPressed(){\r\n    if (uiContact != null)\r\n        CallManager.createCall(opSetClass, getSelectedProvider(), contactAddress, uiContact);\r\n    else\r\n        CallManager.createCall(opSetClass, getSelectedProvider(), contactAddress);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.whiteboard.WhiteboardObjectJabberImpl.setID",
	"Comment": "sets a string uniquely identifying this whiteboardobject.",
	"Method": "void setID(String ID){\r\n    this.ID = ID;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.OutputVolumeControlButton.getComponent",
	"Comment": "returns the component associated with this output volume control button.",
	"Method": "Component getComponent(){\r\n    if (fullScreen)\r\n        return createSliderComponent();\r\n    else {\r\n        return createVolumeControlButton(inButtonToolBar, iconImageID, \"service.gui.VOLUME_CONTROL_TOOL_TIP\");\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.SearchField.textInserted",
	"Comment": "handles the change when a char has been inserted in the field.",
	"Method": "void textInserted(){\r\n    String filterString = this.getText();\r\n    if (filterString == null || filterString.length() <= 0)\r\n        return;\r\n    updateContactListView();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWindow.setTabTitle",
	"Comment": "sets the given title to the tab opened for the given chat panel.",
	"Method": "void setTabTitle(ChatPanel chatPanel,String title){\r\n    int index = this.chatTabbedPane.indexOfComponent(chatPanel);\r\n    if (index > -1)\r\n        this.chatTabbedPane.setTitleAt(index, title);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaAwareCall.setLocalVideoAllowed",
	"Comment": "modifies the local media setup of all peers in the call to reflect therequested setting for the streaming of the local video and then passesthe setting to the participating mediaawarecallpeer instances.",
	"Method": "void setLocalVideoAllowed(boolean allowed,MediaUseCase useCase){\r\n    if (mediaUseCase != useCase)\r\n        setVideoDevice(null, useCase);\r\n    localVideoAllowed = allowed;\r\n    mediaUseCase = useCase;\r\n    Iterator<T> peers = getCallPeers();\r\n    while (peers.hasNext()) peers.next().setLocalVideoAllowed(allowed);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetServerStoredContactInfoIcqImpl.getDetails",
	"Comment": "returns the user details from the specified classexactly that class not its descendants",
	"Method": "Iterator<GenericDetail> getDetails(Contact contact,Class<? extends GenericDetail> detailClass){\r\n    assertConnected();\r\n    if (detailClass.equals(ServerStoredDetails.ImageDetail.class) && contact.getImage() != null) {\r\n        List<GenericDetail> res = new Vector<GenericDetail>();\r\n        res.add(new ServerStoredDetails.ImageDetail(\"Image\", contact.getImage()));\r\n        return res.iterator();\r\n    }\r\n    return infoRetreiver.getDetails(contact.getAddress(), detailClass);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.contactsource.SortedGenericSourceContact.getIndex",
	"Comment": "returns the index of this source contact in its parent group.",
	"Method": "int getIndex(){\r\n    return parentQuery.getQueryResults().indexOf(this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.WhiteboardInvitationRejectedEvent.getTimestamp",
	"Comment": "a timestamp indicating the exact date when the event ocurred.",
	"Method": "Date getTimestamp(){\r\n    return timestamp;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetServerStoredAccountInfoJabberImpl.assertConnected",
	"Comment": "utility method throwing an exception if the jabber stack is not properlyinitialized.",
	"Method": "void assertConnected(){\r\n    if (jabberProvider == null)\r\n        throw new IllegalStateException(\"The jabber provider must be non-null and signed on \" + \"before being able to communicate.\");\r\n    if (!jabberProvider.isRegistered())\r\n        throw new IllegalStateException(\"The jabber provider must be signed on before \" + \"being able to communicate.\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.FileTransferCreatedEvent.getTimestamp",
	"Comment": "a timestamp indicating the exact date when the event occurred.",
	"Method": "Date getTimestamp(){\r\n    return timestamp;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.account.AccountList.dispatchEventToCheckBox",
	"Comment": "dispatches the given mouse event to the underlying buttons.",
	"Method": "void dispatchEventToCheckBox(MouseEvent event){\r\n    if (enableAccountWorker != null) {\r\n        logger.warn(\"Enable account worker is already running\");\r\n        return;\r\n    }\r\n    int mouseIndex = this.locationToIndex(event.getPoint());\r\n    if (logger.isTraceEnabled())\r\n        logger.trace(\"Account list: index under mouse found:\" + mouseIndex);\r\n    if (mouseIndex < 0)\r\n        return;\r\n    Account account = (Account) getModel().getElementAt(mouseIndex);\r\n    if (logger.isTraceEnabled())\r\n        logger.trace(\"Account list: element at mouse index:\" + account.getName());\r\n    AccountListCellRenderer renderer = (AccountListCellRenderer) getCellRenderer().getListCellRendererComponent(this, account, mouseIndex, true, true);\r\n    if (logger.isTraceEnabled())\r\n        logger.trace(\"Account list: renderer bounds for mouse index:\" + renderer.getBounds());\r\n    Rectangle r = this.getCellBounds(mouseIndex, mouseIndex);\r\n    int translatedX = event.getX() - r.x;\r\n    int translatedY = event.getY() - r.y;\r\n    if (logger.isTraceEnabled())\r\n        logger.trace(\"Account list: find component at:\" + translatedX + \", \" + translatedY);\r\n    if (renderer.isOverCheckBox(translatedX, translatedY)) {\r\n        JCheckBox checkBox = account.getEnableCheckBox();\r\n        if (logger.isTraceEnabled())\r\n            logger.trace(\"Account list: checkBox set selected\" + !checkBox.isSelected());\r\n        checkBox.setSelected(!checkBox.isSelected());\r\n        this.enableAccountWorker = new EnableAccountWorker(account, checkBox.isSelected());\r\n        enableAccountWorker.start();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.AbstractOperationSetTelephonyConferencing.callPeerRemoved",
	"Comment": "notifies this callchangelistener that a specificcallpeer has been remove from a specific call.",
	"Method": "void callPeerRemoved(CallPeerEvent event){\r\n    @SuppressWarnings(\"unchecked\")\r\n    MediaAwareCallPeerT callPeer = (MediaAwareCallPeerT) event.getSourceCallPeer();\r\n    callPeer.removeCallPeerListener(callPeerListener);\r\n    callPeer.getMediaHandler().removePropertyChangeListener(this);\r\n    callPeersChanged(event);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.JabberAccountRegistrationForm.getCreateAccountService",
	"Comment": "returns an instance of createaccountservice through which theuser could create an account. this method is meant to be implemented byspecific protocol provider wizards.",
	"Method": "JabberAccountCreationFormService getCreateAccountService(){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommTabbedPane.setSelectedIndex",
	"Comment": "overrides setselectedindex in jtabbedpane in order to remove thehighlight if the tab which is selected.",
	"Method": "void setSelectedIndex(int tabIndex){\r\n    SIPCommTabbedPaneEnhancedUI ui = (SIPCommTabbedPaneEnhancedUI) this.getUI();\r\n    if (ui.isTabHighlighted(tabIndex)) {\r\n        ui.tabRemoveHighlight(tabIndex);\r\n    }\r\n    super.setSelectedIndex(tabIndex);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.osdependent.jdic.StatusSubMenu.actionPerformed",
	"Comment": "change the status of the protocol according to the menu item selected",
	"Method": "void actionPerformed(ActionEvent evt){\r\n    Object source = evt.getSource();\r\n    if (source instanceof JMenuItem)\r\n        changeStatusFromName(((JMenuItem) source).getName());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactGroupImpl.getMclServiceImpl",
	"Comment": "returns the implementation of the metacontactlistservice, towhich this group belongs.",
	"Method": "MetaContactListServiceImpl getMclServiceImpl(){\r\n    return mclServiceImpl;\r\n}"
}, {
	"Path": "net.librec.similarity.AbstractRecommenderSimilarity.getCorrelation",
	"Comment": "find the common rated items by this user and that user, or the commonusers have rated this item or that item. and then return the similarity.",
	"Method": "double getCorrelation(SequentialSparseVector thisVector,SequentialSparseVector thatVector){\r\n    List<Double> thisList = new ArrayList();\r\n    List<Double> thatList = new ArrayList();\r\n    int thisPosition = 0, thatPosition = 0;\r\n    int thisSize = thisVector.getNumEntries(), thatSize = thatVector.getNumEntries();\r\n    int thisIndex, thatIndex;\r\n    while (thisPosition < thisSize && thatPosition < thatSize) {\r\n        thisIndex = thisVector.getIndexAtPosition(thisPosition);\r\n        thatIndex = thatVector.getIndexAtPosition(thatPosition);\r\n        if (thisIndex == thatIndex) {\r\n            thisList.add(thisVector.getAtPosition(thisPosition));\r\n            thatList.add(thatVector.getAtPosition(thatPosition));\r\n            thisPosition++;\r\n            thatPosition++;\r\n        } else if (thisIndex > thatIndex) {\r\n            thatPosition++;\r\n        } else {\r\n            thisPosition++;\r\n        }\r\n    }\r\n    double sim = getSimilarity(thisList, thatList);\r\n    if (!Double.isNaN(sim)) {\r\n        int n = thisList.size();\r\n        int shrinkage = conf.getInt(\"rec.similarity.shrinkage\", 0);\r\n        if (shrinkage > 0)\r\n            sim *= n / (n + shrinkage + 0.0);\r\n    }\r\n    return sim;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.AbstractOperationSetTelephonyConferencing.endpointsMatch",
	"Comment": "checks whether two conferenceinfodocument.endpoint instancesmatch according to the needs of our implementation. can returntrue for endpoints which are not identical.",
	"Method": "boolean endpointsMatch(ConferenceInfoDocument.Endpoint a,ConferenceInfoDocument.Endpoint b){\r\n    if (a == null && b == null)\r\n        return true;\r\n    else if (a == null || b == null)\r\n        return false;\r\n    else if (!stringsMatch(a.getEntity(), b.getEntity()))\r\n        return false;\r\n    else if (a.getStatus() != b.getStatus())\r\n        return false;\r\n    else if (a.getMedias().size() != b.getMedias().size())\r\n        return false;\r\n    for (ConferenceInfoDocument.Media aMedia : a.getMedias()) {\r\n        if (!mediasMatch(aMedia, b.getMedia(aMedia.getId())))\r\n            return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.gibberishaccregwizz.GibberishAccRegWizzActivator.getBundleContext",
	"Comment": "returns the bundlecontext that we received when we were started.",
	"Method": "BundleContext getBundleContext(){\r\n    return bundleContext;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.RawUdpTransportManager.getICECandidateExtendedType",
	"Comment": "returns the extended type of the candidate selected if this transportmanager is using ice.",
	"Method": "String getICECandidateExtendedType(String streamName){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWritePanel.currentChatTransportChanged",
	"Comment": "event in case of chat transport changed, for example because a differenttransport was selected.",
	"Method": "void currentChatTransportChanged(ChatSession chatSession){\r\n    List<PluginComponent> components;\r\n    synchronized (this.pluginComponents) {\r\n        components = new ArrayList<PluginComponent>(this.pluginComponents);\r\n    }\r\n    final Contact contact;\r\n    final Object descriptor = chatSession.getDescriptor();\r\n    if (descriptor instanceof MetaContact) {\r\n        contact = ((MetaContact) descriptor).getDefaultContact();\r\n    } else if (descriptor instanceof Contact) {\r\n        contact = (Contact) descriptor;\r\n    } else if (descriptor == null) {\r\n        for (PluginComponent c : components) {\r\n            c.setCurrentContact((Contact) null);\r\n        }\r\n        return;\r\n    } else {\r\n        logger.warn(String.format(\"Unsupported descriptor type %s (%s),\" + \"this event will not be propagated.\", descriptor, descriptor.getClass().getCanonicalName()));\r\n        return;\r\n    }\r\n    final String resourceName = chatSession.getCurrentChatTransport().getResourceName();\r\n    for (PluginComponent c : components) {\r\n        try {\r\n            c.setCurrentContact(contact, resourceName);\r\n        } catch (RuntimeException e) {\r\n            logger.error(\"BUG: setCurrentContact of PluginComponent instance: \" + c.getClass().getCanonicalName() + \" throws a RuntimeException.\", e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.librec.recommender.ext.BipolarSlopeOneTestCase.testRecommender",
	"Comment": "test the whole process of bipolarslopeonerecommender recommendation",
	"Method": "void testRecommender(){\r\n    Configuration.Resource resource = new Configuration.Resource(\"rec/ext/bipolarslopeone-test.properties\");\r\n    conf.addResource(resource);\r\n    RecommenderJob job = new RecommenderJob(conf);\r\n    job.runJob();\r\n}"
}, {
	"Path": "io.lettuce.core.internal.LettuceAssert.assertState",
	"Comment": "ensures the truth of an expression involving the state of the calling instance, but not involving any parameters to thecalling method.",
	"Method": "void assertState(boolean condition,String message){\r\n    if (!condition) {\r\n        throw new IllegalStateException(message);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ContactSipImpl.getAddress",
	"Comment": "returns a string that can be used for identifying the contact.",
	"Method": "String getAddress(){\r\n    SipURI sipURI = (SipURI) sipAddress.getURI();\r\n    return sipURI.toString().substring(sipURI.getScheme().length() + 1);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.WhiteboardSessionJabberImpl.participantStateChanged",
	"Comment": "verifies whether the whiteboard participant has entered a state.",
	"Method": "void participantStateChanged(WhiteboardParticipantChangeEvent evt){\r\n    Object newValue = evt.getNewValue();\r\n    if ((newValue == WhiteboardParticipantState.DISCONNECTED) || (newValue == WhiteboardParticipantState.FAILED)) {\r\n        removeWhiteboardParticipant(evt.getSourceWhiteboardParticipant());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.MetaContactChatTransport.getName",
	"Comment": "returns the contact address corresponding to this chat transport.",
	"Method": "String getName(){\r\n    return contact.getAddress();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.menus.AutoAnswerMenu.removeAccount",
	"Comment": "remove menu item for the account given by protocolprovider.",
	"Method": "void removeAccount(ProtocolProviderService protocolProvider,SIPCommMenu parentMenu){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                removeAccount(protocolProvider, parentMenu);\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    for (int i = 0; i < parentMenu.getItemCount(); i++) {\r\n        JMenuItem c = parentMenu.getItem(i);\r\n        if (!(c instanceof AutoAnswerMenuItem))\r\n            continue;\r\n        AutoAnswerMenuItem menu = (AutoAnswerMenuItem) c;\r\n        AccountID menuAccountID = menu.getProtocolProvider().getAccountID();\r\n        if (menuAccountID.equals(protocolProvider.getAccountID())) {\r\n            parentMenu.remove(menu);\r\n            menu.clear();\r\n            break;\r\n        }\r\n    }\r\n    if (ConfigurationUtils.isAutoAnswerDisableSubmenu() && getAutoAnswerItemCount(parentMenu) == 1) {\r\n        updateItem(getAutoAnswerItem(parentMenu, 0), true);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.menus.AutoAnswerMenu.removeAccount",
	"Comment": "remove menu item for the account given by protocolprovider.",
	"Method": "void removeAccount(ProtocolProviderService protocolProvider,SIPCommMenu parentMenu){\r\n    removeAccount(protocolProvider, parentMenu);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl.isSignalingTransportSecure",
	"Comment": "indicates if the sip transport channel is using a tls secured socket.",
	"Method": "boolean isSignalingTransportSecure(){\r\n    return ListeningPoint.TLS.equalsIgnoreCase(connection.getTransport());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.AddContactDialog.dispose",
	"Comment": "overwrites the dispose method in order to clean instancesof this window before closing it.",
	"Method": "void dispose(){\r\n    super.dispose();\r\n    this.getContentPane().removeAll();\r\n    this.accountLabel = null;\r\n    this.accountCombo = null;\r\n    this.groupLabel = null;\r\n    this.contactAddressLabel = null;\r\n    this.displayNameLabel = null;\r\n    this.contactAddressField = null;\r\n    this.displayNameField = null;\r\n    this.addButton = null;\r\n    this.cancelButton = null;\r\n    this.imageLabel = null;\r\n    this.groupCombo = null;\r\n    this.initialized = false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetServerStoredContactInfoJabberImpl.getAllDetailsForContact",
	"Comment": "request the full info for the given uinwaits and return this details",
	"Method": "Iterator<GenericDetail> getAllDetailsForContact(Contact contact){\r\n    if (isPrivateMessagingContact(contact))\r\n        return new LinkedList<GenericDetail>().iterator();\r\n    List<GenericDetail> details = infoRetreiver.getContactDetails(contact.getAddress());\r\n    if (details == null)\r\n        return new LinkedList<GenericDetail>().iterator();\r\n    else\r\n        return new LinkedList<GenericDetail>(details).iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.InfoRetreiver.retrieveDetails",
	"Comment": "retrieve details and return them or if missing return an empty list.",
	"Method": "List<GenericDetail> retrieveDetails(String uin){\r\n    List<GenericDetail> result = null;\r\n    try {\r\n        long toICQUin = Long.parseLong(uin);\r\n        int reqID = requestID++;\r\n        MetaFullInfoRequest infoRequest = new MetaFullInfoRequest(Long.parseLong(ownerUin), reqID, toICQUin);\r\n        UserInfoResponseRetriever responseRetriever = new UserInfoResponseRetriever(reqID);\r\n        icqProvider.getAimConnection().getInfoService().getOscarConnection().sendSnacRequest(infoRequest, responseRetriever);\r\n        responseRetriever.waitForLastInfo(60000);\r\n        result = responseRetriever.result;\r\n    } catch (Exception e) {\r\n    }\r\n    if (result == null)\r\n        result = new LinkedList<GenericDetail>();\r\n    retreivedDetails.put(uin, result);\r\n    return result;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ScServiceDiscoveryManager.discoverItems",
	"Comment": "returns the discovered items of a given xmpp entity addressed by its jidand note attribute. use this message only when trying to queryinformation which is not directly addressable.",
	"Method": "DiscoverItems discoverItems(String entityID,DiscoverItems discoverItems,String entityID,String node){\r\n    return discoveryManager.discoverItems(entityID, node);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.isPrivateMessagingChat",
	"Comment": "returns true if the chat is private messaging chat and false if not.",
	"Method": "boolean isPrivateMessagingChat(){\r\n    return isPrivateMessagingChat;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.ircaccregwizz.IrcAccountRegistrationWizard.getProtocolDescription",
	"Comment": "implements the accountregistrationwizard.getprotocoldescription method. returns the description of the protocol for this wizard.",
	"Method": "String getProtocolDescription(){\r\n    return Resources.getString(\"plugin.ircaccregwizz.PROTOCOL_DESCRIPTION\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomJabberImpl.assertConnected",
	"Comment": "utility method throwing an exception if the stack is not properlyinitialized.",
	"Method": "void assertConnected(){\r\n    if (provider == null)\r\n        throw new IllegalStateException(\"The provider must be non-null and signed on the \" + \"service before being able to communicate.\");\r\n    if (!provider.isRegistered())\r\n        throw new IllegalStateException(\"The provider must be signed on the service before \" + \"being able to communicate.\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallManager.isRegionDesktopSharingEnabled",
	"Comment": "indicates if the desktop sharing is currently enabled for the givencall.",
	"Method": "boolean isRegionDesktopSharingEnabled(Call call){\r\n    OperationSetDesktopStreaming desktopOpSet = call.getProtocolProvider().getOperationSet(OperationSetDesktopStreaming.class);\r\n    if (desktopOpSet != null && desktopOpSet.isPartialStreaming(call))\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipStatusEnum.getSupportedStatusSet",
	"Comment": "returns an iterator over all status instances supported by the sipprovider.",
	"Method": "Iterator<PresenceStatus> getSupportedStatusSet(){\r\n    return supportedStatusSet.iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ContactGroupIcqImpl.subgroups",
	"Comment": "returns an empty iterator. subgroups may only be present in the rootgroup.",
	"Method": "Iterator<ContactGroup> subgroups(){\r\n    return dummyGroupsList.iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetWhiteboardingJabberImpl.findWhiteboardSession",
	"Comment": "returns a reference to a whiteboardsession namedsessionname or null if no such session exists.",
	"Method": "WhiteboardSession findWhiteboardSession(String sessionName){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AccountID.storeProperties",
	"Comment": "stores configuration properties held by this object into givenaccountproperties map.",
	"Method": "void storeProperties(String protocolIconPath,String accountIconPath,Map<String, String> accountProperties){\r\n    if (protocolIconPath != null)\r\n        setProtocolIconPath(protocolIconPath);\r\n    if (accountIconPath != null)\r\n        setAccountIconPath(accountIconPath);\r\n    mergeProperties(this.accountProperties, accountProperties);\r\n    accountProperties.remove(\"ENCRYPTED_PASSWORD\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.launchutils.LaunchArgHandler.handleConfigArg",
	"Comment": "instructs sip communicator change the location of its home dir.",
	"Method": "int handleConfigArg(String configArg){\r\n    if (configArg.startsWith(\"--config=\")) {\r\n        configArg = configArg.substring(\"--config=\".length());\r\n    }\r\n    File configDir = new File(configArg);\r\n    configDir.mkdirs();\r\n    if (!configDir.isDirectory()) {\r\n        System.out.println(\"Failed to create directory \" + configArg);\r\n        errorCode = ERROR_CODE_CREATE_DIR_FAILED;\r\n        return ACTION_ERROR;\r\n    }\r\n    System.setProperty(PNAME_SC_HOME_DIR_LOCATION, configDir.getParent());\r\n    System.setProperty(PNAME_SC_CACHE_DIR_LOCATION, configDir.getParent());\r\n    System.setProperty(PNAME_SC_LOG_DIR_LOCATION, configDir.getParent());\r\n    System.setProperty(PNAME_SC_HOME_DIR_NAME, configDir.getName());\r\n    logger.reset();\r\n    return ACTION_CONTINUE;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockChatRoom.getMembersWhiteList",
	"Comment": "returns the ids of the users that has the member role in the room.when the room is member only, this are the users allowed to join.",
	"Method": "List<String> getMembersWhiteList(){\r\n    return new ArrayList<String>();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetFileTransferJabberImpl.addFileTransferListener",
	"Comment": "adds the given filetransferlistener that would listen forfile transfer requests and created file transfers.",
	"Method": "void addFileTransferListener(FileTransferListener listener){\r\n    synchronized (fileTransferListeners) {\r\n        if (!fileTransferListeners.contains(listener)) {\r\n            this.fileTransferListeners.add(listener);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetExtendedAuthorizationsIcqImpl.reRequestAuthorization",
	"Comment": "send an authorization request, requesting contact to add themto our contact list?",
	"Method": "void reRequestAuthorization(AuthorizationRequest request,Contact contact){\r\n    assertConnected();\r\n    if (!(contact instanceof ContactIcqImpl))\r\n        throw new IllegalArgumentException(\"Argument is not an icq contact (contact=\" + contact + \")\");\r\n    icqProvider.getAimConnection().getSsiService().requestBuddyAuthorization(new Screenname(contact.getAddress()), request.getReason());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.thumbnail.ThumbnailIQ.getChildElementXML",
	"Comment": "returns the xml representing the data element in this iq packet.",
	"Method": "String getChildElementXML(){\r\n    StringBuffer buf = new StringBuffer();\r\n    buf.append(\"<\").append(ELEMENT_NAME).append(\" xmlns=\\\"\").append(NAMESPACE).append(\"\\\"\").append(\" \" + CID).append(\"=\\\"\").append(cid).append(\"\\\"\");\r\n    if (mimeType != null)\r\n        buf.append(\" \" + TYPE).append(\"=\\\"\").append(mimeType).append(\"\\\">\");\r\n    else\r\n        buf.append(\">\");\r\n    if (data != null) {\r\n        byte[] encodedData = Base64.encode(data);\r\n        buf.append(new String(encodedData));\r\n    }\r\n    buf.append(\"<\/data>\");\r\n    return buf.toString();\r\n}"
}, {
	"Path": "net.librec.recommender.TensorRecommender.predict",
	"Comment": "predict a specific rating for user useridx on item itemidx with some other contexts indices. tt is useful forevalution which requires predictions are bounded.",
	"Method": "double predict(int[] keys,double predict,int userIdx,int itemIdx,double predict,int[] keys,boolean bound){\r\n    double predictRating = predict(keys);\r\n    if (bound) {\r\n        if (predictRating > maxRate) {\r\n            predictRating = maxRate;\r\n        } else if (predictRating < minRate) {\r\n            predictRating = minRate;\r\n        }\r\n    }\r\n    return predictRating;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.InputVolumeControlButton.toggleMute",
	"Comment": "mutes or unmutes the associated call upon clicking this button.",
	"Method": "void toggleMute(){\r\n    if (muteRunner == null) {\r\n        muteRunner = new Thread(this, getToolTipText());\r\n        muteRunner.setDaemon(true);\r\n        setEnabled(false);\r\n        muteRunner.start();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.ChatRoomProviderWrapperImpl.findChatRoomWrapperForChatRoom",
	"Comment": "returns the chat room wrapper contained in this provider that correspondsto the given chat room.",
	"Method": "ChatRoomWrapper findChatRoomWrapperForChatRoom(ChatRoom chatRoom){\r\n    return findChatRoomWrapperForChatRoomID(chatRoom.getIdentifier());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.OneToOneCallPeerPanel.securityTimeout",
	"Comment": "indicates that the security is timeouted, is not supported by theother end.",
	"Method": "void securityTimeout(CallPeerSecurityTimeoutEvent evt){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                securityTimeout(evt);\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    if (securityPanel != null)\r\n        securityPanel.securityTimeout(evt);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.OneToOneCallPeerPanel.securityTimeout",
	"Comment": "indicates that the security is timeouted, is not supported by theother end.",
	"Method": "void securityTimeout(CallPeerSecurityTimeoutEvent evt){\r\n    securityTimeout(evt);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.MessageReceivedEvent.getContactResource",
	"Comment": "returns a reference to the contactresource that has sent themessage whose reception this event represents.",
	"Method": "ContactResource getContactResource(){\r\n    return fromResource;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.conference.ConferencePeerPanel.securityTimeout",
	"Comment": "indicates that the security is timeouted, is not supported by theother end.",
	"Method": "void securityTimeout(CallPeerSecurityTimeoutEvent evt){\r\n    if (Boolean.parseBoolean(GuiActivator.getResources().getSettingsString(\"impl.gui.PARANOIA_UI\"))) {\r\n        try {\r\n            CallPeer peer = (CallPeer) evt.getSource();\r\n            OperationSetBasicTelephony<?> telephony = peer.getProtocolProvider().getOperationSet(OperationSetBasicTelephony.class);\r\n            telephony.hangupCallPeer(peer, OperationSetBasicTelephony.HANGUP_REASON_ENCRYPTION_REQUIRED, \"Encryption Required!\");\r\n        } catch (OperationFailedException ex) {\r\n            Logger.getLogger(getClass()).error(\"Failed to hangup peer\", ex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractContact.removeResourceListener",
	"Comment": "removes the given contactresourcelistener listening for eventsrelated to contact resources changes.",
	"Method": "void removeResourceListener(ContactResourceListener l){\r\n    if (resourceListeners == null)\r\n        return;\r\n    synchronized (resourceListeners) {\r\n        resourceListeners.remove(l);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractOperationSetPersistentPresence.fireContactPropertyChangeEvent",
	"Comment": "notify all subscription listeners of the corresponding contact propertychange event.",
	"Method": "void fireContactPropertyChangeEvent(String eventID,Contact source,Object oldValue,Object newValue){\r\n    ContactPropertyChangeEvent evt = new ContactPropertyChangeEvent(source, eventID, oldValue, newValue);\r\n    Collection<SubscriptionListener> listeners;\r\n    synchronized (subscriptionListeners) {\r\n        listeners = new ArrayList<SubscriptionListener>(subscriptionListeners);\r\n    }\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Dispatching a Contact Property Change Event to\" + listeners.size() + \" listeners. Evt=\" + evt);\r\n    for (SubscriptionListener listener : listeners) listener.contactModified(evt);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.keybindingchooser.globalchooser.GlobalShortcutEntry.equals",
	"Comment": "checks if argument is an instance of this class with the same shortcutand associated action. it does not compare aspects of the displayelements.",
	"Method": "boolean equals(Object obj){\r\n    if (obj == this)\r\n        return true;\r\n    else if (!(obj instanceof GlobalShortcutEntry))\r\n        return false;\r\n    GlobalShortcutEntry entry = (GlobalShortcutEntry) obj;\r\n    boolean equals = true;\r\n    String action = this.getAction();\r\n    if (action == null)\r\n        equals &= entry.getAction() == null;\r\n    else\r\n        equals &= action.equals(entry.getAction());\r\n    AWTKeyStroke shortcut = this.getShortcut();\r\n    if (shortcut == null)\r\n        equals &= entry.getShortcut() == null;\r\n    else\r\n        equals &= shortcut.equals(entry.getShortcut());\r\n    shortcut = this.getShortcut2();\r\n    if (shortcut == null)\r\n        equals &= entry.getShortcut() == null;\r\n    else\r\n        equals &= shortcut.equals(entry.getShortcut2());\r\n    return equals;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.notifsource.NotificationContact.getScaledAvatar",
	"Comment": "returns the icon indicating that this is a notification contact.",
	"Method": "ImageIcon getScaledAvatar(boolean isSelected,int width,int height){\r\n    ImageIcon avatarIcon = null;\r\n    if (messageType.equals(MessageType.VOICE)) {\r\n        avatarIcon = GuiActivator.getResources().getImage(\"service.gui.icons.VOICEMAIL\");\r\n    }\r\n    return avatarIcon;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaAwareCall.updateRecorderMuteState",
	"Comment": "updates the recorder mute state by looking at the peers state.if one of the peers is not muted and the recorder is not.if all the peers are muted so must be and the recorder.",
	"Method": "void updateRecorderMuteState(Recorder recorder){\r\n    Iterator<T> iter = getCallPeers();\r\n    while (iter.hasNext()) {\r\n        if (!iter.next().isMute()) {\r\n            recorder.setMute(false);\r\n            return;\r\n        }\r\n    }\r\n    recorder.setMute(true);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.msofficecomm.MessengerContact.getPhoneNumber",
	"Comment": "gets the phone number information of the contact associated with thisinstance.",
	"Method": "String getPhoneNumber(int type){\r\n    try {\r\n        return Messenger.getPhoneNumber(this, type);\r\n    } catch (Throwable t) {\r\n        if (t instanceof ThreadDeath)\r\n            throw (ThreadDeath) t;\r\n        else if (t instanceof OutOfMemoryError)\r\n            throw (OutOfMemoryError) t;\r\n        else {\r\n            logger.error(\"Failed to retrieve the phone number information of an\" + \" IMessengerContact with sign-in name: \" + signinName, t);\r\n            throw new RuntimeException(t);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.osdependent.jdic.TrayMenuFactory.changeTrayMenuItem",
	"Comment": "changes the tray menu item properties, like name, text and icon.",
	"Method": "void changeTrayMenuItem(Object trayItem,String name,String textID,String iconID){\r\n    String text = Resources.getString(textID);\r\n    if (trayItem instanceof JMenuItem) {\r\n        JMenuItem jmenuItem = (JMenuItem) trayItem;\r\n        jmenuItem.setName(name);\r\n        jmenuItem.setText(text);\r\n        jmenuItem.setIcon(Resources.getImage(iconID));\r\n    } else if (trayItem instanceof MenuItem) {\r\n        MenuItem menuItem = (MenuItem) trayItem;\r\n        menuItem.setName(name);\r\n        menuItem.setLabel(text);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipRegistrarlessConnection.toString",
	"Comment": "returns a string representation of this connection instanceinstance including information that would permit to distinguish it amongother sip listeners when reading a log file.",
	"Method": "String toString(){\r\n    String className = getClass().getName();\r\n    try {\r\n        className = className.substring(className.lastIndexOf('.') + 1);\r\n    } catch (Exception ex) {\r\n    }\r\n    return className + \"-[dn=\" + sipProvider.getOurDisplayName() + \" addr=\" + sipProvider.getAccountID().getUserID() + \"]\";\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.TreeContactList.selectFirstContact",
	"Comment": "selects the first found contact node from the beginning of the contactlist.",
	"Method": "void selectFirstContact(){\r\n    SwingUtilities.invokeLater(new Runnable() {\r\n        public void run() {\r\n            ContactNode contactNode = treeModel.findFirstContactNode();\r\n            if (contactNode != null) {\r\n                if (!contactNode.equals(getSelectedValue()))\r\n                    setSelectionPath(new TreePath(contactNode.getPath()));\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.TreeContactList.selectFirstContact",
	"Comment": "selects the first found contact node from the beginning of the contactlist.",
	"Method": "void selectFirstContact(){\r\n    ContactNode contactNode = treeModel.findFirstContactNode();\r\n    if (contactNode != null) {\r\n        if (!contactNode.equals(getSelectedValue()))\r\n            setSelectionPath(new TreePath(contactNode.getPath()));\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.neomedia.NeomediaActivator.start",
	"Comment": "starts the execution of the neomedia bundle in the specified context.",
	"Method": "void start(BundleContext bundleContext){\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Started.\");\r\n    NeomediaActivator.bundleContext = bundleContext;\r\n    mediaServiceImpl = (MediaServiceImpl) LibJitsi.getMediaService();\r\n    bundleContext.registerService(MediaService.class.getName(), mediaServiceImpl, null);\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Media Service ... [REGISTERED]\");\r\n    mediaConfiguration = new MediaConfigurationImpl();\r\n    bundleContext.registerService(MediaConfigurationService.class.getName(), getMediaConfiguration(), null);\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Media Configuration ... [REGISTERED]\");\r\n    ConfigurationService cfg = NeomediaActivator.getConfigurationService();\r\n    Dictionary<String, String> mediaProps = new Hashtable<String, String>();\r\n    mediaProps.put(ConfigurationForm.FORM_TYPE, ConfigurationForm.GENERAL_TYPE);\r\n    if ((cfg == null) || !cfg.getBoolean(AUDIO_CONFIG_DISABLED_PROP, false)) {\r\n        audioConfigurationForm = new LazyConfigurationForm(AudioConfigurationPanel.class.getName(), getClass().getClassLoader(), \"plugin.mediaconfig.AUDIO_ICON\", \"impl.neomedia.configform.AUDIO\", 3);\r\n        bundleContext.registerService(ConfigurationForm.class.getName(), audioConfigurationForm, mediaProps);\r\n        if (audioDeviceConfigurationPropertyChangeListener == null) {\r\n            getNotificationService();\r\n            audioDeviceConfigurationPropertyChangeListener = new AudioDeviceConfigurationListener(audioConfigurationForm);\r\n            mediaServiceImpl.getDeviceConfiguration().addPropertyChangeListener(audioDeviceConfigurationPropertyChangeListener);\r\n        }\r\n    }\r\n    if ((cfg == null) || !cfg.getBoolean(VIDEO_CONFIG_DISABLED_PROP, false)) {\r\n        videoConfigurationForm = new LazyConfigurationForm(VideoConfigurationPanel.class.getName(), getClass().getClassLoader(), \"plugin.mediaconfig.VIDEO_ICON\", \"impl.neomedia.configform.VIDEO\", 4);\r\n        bundleContext.registerService(ConfigurationForm.class.getName(), videoConfigurationForm, mediaProps);\r\n    }\r\n    if ((cfg == null) || !cfg.getBoolean(H264_CONFIG_DISABLED_PROP, false)) {\r\n        Dictionary<String, String> h264Props = new Hashtable<String, String>();\r\n        h264Props.put(ConfigurationForm.FORM_TYPE, ConfigurationForm.ADVANCED_TYPE);\r\n        bundleContext.registerService(ConfigurationForm.class.getName(), new LazyConfigurationForm(ConfigurationPanel.class.getName(), getClass().getClassLoader(), \"plugin.mediaconfig.VIDEO_ICON\", \"impl.neomedia.configform.H264\", -1, true), h264Props);\r\n    }\r\n    if ((cfg == null) || !cfg.getBoolean(ZRTP_CONFIG_DISABLED_PROP, false)) {\r\n        Dictionary<String, String> securityProps = new Hashtable<String, String>();\r\n        securityProps.put(ConfigurationForm.FORM_TYPE, ConfigurationForm.SECURITY_TYPE);\r\n        bundleContext.registerService(ConfigurationForm.class.getName(), new LazyConfigurationForm(SecurityConfigForm.class.getName(), getClass().getClassLoader(), \"impl.media.security.zrtp.CONF_ICON\", \"impl.media.security.zrtp.TITLE\", 0), securityProps);\r\n    }\r\n    System.setProperty(\"gov.nist.core.STRIP_ADDR_SCOPES\", \"true\");\r\n    AudioNotifierService audioNotifierService = LibJitsi.getAudioNotifierService();\r\n    audioNotifierService.setMute((cfg == null) || !cfg.getBoolean(\"net.java.sip.communicator\" + \".impl.sound.isSoundEnabled\", true));\r\n    bundleContext.registerService(AudioNotifierService.class.getName(), audioNotifierService, null);\r\n    if (logger.isInfoEnabled())\r\n        logger.info(\"Audio Notifier Service ...[REGISTERED]\");\r\n    if ((cfg == null) || !(cfg.getBoolean(CALL_RECORDING_CONFIG_DISABLED_PROP, false) || cfg.getBoolean(\"net.java.sip.communicator\" + \".impl.gui.main.call.HIDE_CALL_RECORD_BUTTON\", false))) {\r\n        Dictionary<String, String> callRecordingProps = new Hashtable<String, String>();\r\n        callRecordingProps.put(ConfigurationForm.FORM_TYPE, ConfigurationForm.ADVANCED_TYPE);\r\n        bundleContext.registerService(ConfigurationForm.class.getName(), new LazyConfigurationForm(CallRecordingConfigForm.class.getName(), getClass().getClassLoader(), null, \"plugin.callrecordingconfig.CALL_RECORDING_CONFIG\", 1100, true), callRecordingProps);\r\n    }\r\n    OpenH264Retriever.checkForUpdateAndDownload();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.replacement.smiley.ReplacementServiceSmileyImpl.getReplacement",
	"Comment": "replaces the smiley strings with their corresponding smiley image.",
	"Method": "String getReplacement(String sourceString){\r\n    try {\r\n        Smiley smiley = Resources.getSmiley(sourceString.trim());\r\n        if (smiley != null)\r\n            return smiley.getImagePath();\r\n    } catch (Exception e) {\r\n        logger.error(\"Failed to get smiley replacement for \" + sourceString, e);\r\n    }\r\n    return sourceString;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.msoutlook.MsOutlookMAPIHResultException.toString",
	"Comment": "converts a specific hresult to a touch more readablestring in accord with the rule of constructing mapihresult values.",
	"Method": "String toString(long hResult){\r\n    if (hResult == 0)\r\n        return \"S_OK\";\r\n    else {\r\n        StringBuilder s = new StringBuilder(\"MAPI_\");\r\n        s.append(((hResult & 0x80000000L) == 0) ? 'W' : 'E');\r\n        s.append(\"_0x\");\r\n        s.append(Long.toHexString(hResult & 0xFFFL));\r\n        s.append(\" (\" + Long.toHexString(hResult) + \")\");\r\n        return s.toString();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.MessageIrcImpl.setContent",
	"Comment": "sets the content to this message. used to change the content,before showing action messages to the user.",
	"Method": "void setContent(String messageContent){\r\n    super.setContent(messageContent);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.ShowMoreContact.getDisplayName",
	"Comment": "returns an empty string to indicate that this contact has no displayname.",
	"Method": "String getDisplayName(){\r\n    return \"\";\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.JingleNodesCandidateDatagramSocket.getNbLost",
	"Comment": "return the number of loss between the 2 last rtp packets received.",
	"Method": "long getNbLost(long lastRtpSequenceNumber,long newSeq){\r\n    long newNbLost = 0;\r\n    if (lastRtpSequenceNumber <= newSeq) {\r\n        newNbLost = newSeq - lastRtpSequenceNumber;\r\n    } else {\r\n        newNbLost = (0xffff - lastRtpSequenceNumber) + newSeq;\r\n    }\r\n    if (newNbLost > 1) {\r\n        if (newNbLost < 0x00ff) {\r\n            return newNbLost - 1;\r\n        } else {\r\n            return 1;\r\n        }\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetPersistentPresenceJabberImpl.presenceStatusToJabberMode",
	"Comment": "converts the specified jabberstatusenum member to the correspondingjabber mode",
	"Method": "Presence.Mode presenceStatusToJabberMode(PresenceStatus status){\r\n    return scToJabberModesMappings.get(status.getStatusName());\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.usersearch.UserSearchActivator.removeSupportedProvider",
	"Comment": "removes provider from the list of providers that support user search.",
	"Method": "void removeSupportedProvider(ProtocolProviderService provider){\r\n    if (supportedProviders.contains(provider)) {\r\n        supportedProviders.remove(provider);\r\n        for (UserSearchSupportedProviderListener l : listeners) {\r\n            l.providerRemoved(provider);\r\n        }\r\n        if (supportedProviders.isEmpty() && contactSourceRegistration != null) {\r\n            contactSourceRegistration.unregister();\r\n            contactSourceRegistration = null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.DTMFHandler.addParent",
	"Comment": "adds a window on which key presses and releases are to bemonitored for the purposes of this dtmfhandler.",
	"Method": "void addParent(Window parent){\r\n    synchronized (parents) {\r\n        if (!parents.contains(parent) && parents.add(parent) && (keyboardFocusManager == null)) {\r\n            keyboardFocusManager = KeyboardFocusManager.getCurrentKeyboardFocusManager();\r\n            keyboardFocusManager.addKeyEventDispatcher(this);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.provdisc.mdns.ProvisioningDiscoveryServiceMDNSImpl.startDiscovery",
	"Comment": "launch a mdns discovery for a provisioning url.this method is asynchronous, the response will be notified to anyprovisioninglistener registered.",
	"Method": "void startDiscovery(){\r\n    if (discover != null) {\r\n        new Thread(discover).start();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetBasicTelephonyJabberImpl.convertReasonCodeToSIPCode",
	"Comment": "converts the codes for hangup from operationsetbasictelephony oneto the jabber reasons.",
	"Method": "Reason convertReasonCodeToSIPCode(int reasonCode){\r\n    switch(reasonCode) {\r\n        case HANGUP_REASON_NORMAL_CLEARING:\r\n            return Reason.SUCCESS;\r\n        case HANGUP_REASON_ENCRYPTION_REQUIRED:\r\n            return Reason.SECURITY_ERROR;\r\n        case HANGUP_REASON_TIMEOUT:\r\n            return Reason.TIMEOUT;\r\n        case HANGUP_REASON_BUSY_HERE:\r\n            return Reason.BUSY;\r\n        default:\r\n            return null;\r\n    }\r\n}"
}, {
	"Path": "net.librec.recommender.context.ranking.SBPRRecommender.predict",
	"Comment": "predict a specific ranking score for user useridx on item itemidx.",
	"Method": "double predict(int userIdx,int itemIdx){\r\n    double predictRating = itemBiases.get(itemIdx) + userFactors.row(userIdx).dot(itemFactors.row(itemIdx));\r\n    return predictRating;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.skinmanager.Resources.getString",
	"Comment": "returns an internationalized string corresponding to the given key.",
	"Method": "String getString(String key){\r\n    return getResources().getI18NString(key);\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.GuiUtils.compareDatesOnly",
	"Comment": "compares the two dates. the comparison is based only on the day, monthand year values. returns 0 if the two dates are equals, a value0 if the first date isafter the second one.",
	"Method": "int compareDatesOnly(long date1,long date2,int compareDatesOnly,Date date1,Date date2){\r\n    return compareDatesOnly(date1.getTime(), date2.getTime());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetAdHocMultiUserChatIcqImpl.fireInvitationEvent",
	"Comment": "delivers a adhocchatroominvitationreceivedevent to allregistered adhocchatroominvitationlisteners.",
	"Method": "void fireInvitationEvent(AdHocChatRoom targetChatRoom,String inviter,String reason,byte[] password){\r\n    AdHocChatRoomInvitationIcqImpl invitation = new AdHocChatRoomInvitationIcqImpl(targetChatRoom, inviter, reason, password);\r\n    AdHocChatRoomInvitationReceivedEvent evt = new AdHocChatRoomInvitationReceivedEvent(this, invitation, new Date(System.currentTimeMillis()));\r\n    Iterable<AdHocChatRoomInvitationListener> listeners;\r\n    synchronized (invitationListeners) {\r\n        listeners = new ArrayList<AdHocChatRoomInvitationListener>(invitationListeners);\r\n    }\r\n    for (AdHocChatRoomInvitationListener listener : listeners) listener.invitationReceived(evt);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.GuiActivator.getDirectImageReplacementSource",
	"Comment": "returns the directimagereplacementservice obtained from thebundle context.",
	"Method": "DirectImageReplacementService getDirectImageReplacementSource(){\r\n    if (directImageService == null) {\r\n        directImageService = ServiceUtils.getService(bundleContext, DirectImageReplacementService.class);\r\n    }\r\n    return directImageService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.account.Account.getProtocolProvider",
	"Comment": "returns the protocol provider, on which this account is based.",
	"Method": "ProtocolProviderService getProtocolProvider(){\r\n    return protocolProvider;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.RenameContactDialog.requestFocusInFiled",
	"Comment": "requests the focus in the text field contained in thisdialog.",
	"Method": "void requestFocusInFiled(){\r\n    this.renameContactPanel.requestFocusInField();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ServerStoredContactList.fireContactRemoved",
	"Comment": "make the parent persistent presence operation set dispatch a contactremoved event.",
	"Method": "void fireContactRemoved(ContactGroupSipImpl parentGroup,ContactSipImpl contact){\r\n    parentOperationSet.fireSubscriptionEvent(contact, parentGroup, SubscriptionEvent.SUBSCRIPTION_REMOVED);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockPersistentPresenceOperationSet.getSupportedStatusSet",
	"Comment": "returns the set of presencestatus objects that a user of this servicemay request the provider to enter.",
	"Method": "Iterator<PresenceStatus> getSupportedStatusSet(){\r\n    return MockStatusEnum.supportedStatusSet();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.MessageDeliveryFailedEvent.getReason",
	"Comment": "returns a human readable message indicating the reason for the failureor null if the reason is unknown.",
	"Method": "String getReason(){\r\n    return reasonPhrase;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.iptelaccregwizz.IptelAccountRegistrationWizard.getUserNameExample",
	"Comment": "returns an example string, which should indicate to the user how theuser name should look like.",
	"Method": "String getUserNameExample(){\r\n    return \"Ex: myusername or myusername@iptel.org\";\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ServerStoredContactListIcqImpl.fireContactRemoved",
	"Comment": "make the parent persistent presence operation set dispatch a contactremoved event.",
	"Method": "void fireContactRemoved(ContactGroup parentGroup,Contact contact){\r\n    if (parentOperationSet == null) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"No presence op. set available. Bailing out.\");\r\n        return;\r\n    }\r\n    parentOperationSet.fireSubscriptionEvent(contact, parentGroup, SubscriptionEvent.SUBSCRIPTION_REMOVED);\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.NetworkUtils.getAAAARecord",
	"Comment": "returns array of hosts from the aaaa record of the specified domain.the records are ordered against the aaaa record priority",
	"Method": "InetSocketAddress getAAAARecord(String domain,int port){\r\n    byte[] address;\r\n    if ((address = strToIPv6(domain)) != null) {\r\n        try {\r\n            return new InetSocketAddress(InetAddress.getByAddress(domain, address), port);\r\n        } catch (UnknownHostException e) {\r\n            logger.error(\"Unable to create InetAddress for <\" + domain + \">\", e);\r\n            return null;\r\n        }\r\n    }\r\n    Record[] records;\r\n    try {\r\n        Lookup lookup = createLookup(domain, Type.AAAA);\r\n        records = lookup.run();\r\n    } catch (TextParseException tpe) {\r\n        logger.error(\"Failed to parse domain=\" + domain, tpe);\r\n        throw new ParseException(tpe.getMessage(), 0);\r\n    } catch (DnssecRuntimeException e) {\r\n        throw new DnssecException(e);\r\n    }\r\n    if (records != null && records.length > 0) {\r\n        if (logger.isTraceEnabled())\r\n            logger.trace(\"AAAA record for \" + domain + \"=\" + ((AAAARecord) records[0]).getAddress());\r\n        try {\r\n            return new InetSocketAddress(InetAddress.getByAddress(domain, ((AAAARecord) records[0]).getAddress().getAddress()), port);\r\n        } catch (UnknownHostException e) {\r\n            return null;\r\n        }\r\n    } else {\r\n        if (logger.isTraceEnabled())\r\n            logger.trace(\"No AAAA record found for \" + domain);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockChatRoom.revokeModerator",
	"Comment": "revokes the moderator role for the participant given by address.",
	"Method": "void revokeModerator(String address){\r\n    throw new UnsupportedOperationException(\"Not supported yet.\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.MetaContactListSource.metaContactMoved",
	"Comment": "performs needed operations, when a metacontact has beenmoved in the metacontactlistservice from one group to another.",
	"Method": "void metaContactMoved(MetaContactMovedEvent evt){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                metaContactMoved(evt);\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    final MetaContact metaContact = evt.getSourceMetaContact();\r\n    final MetaContactGroup oldParent = evt.getOldParent();\r\n    final MetaContactGroup newParent = evt.getNewParent();\r\n    synchronized (metaContact) {\r\n        UIContactImpl uiContact = MetaContactListSource.getUIContact(metaContact);\r\n        if (uiContact == null)\r\n            return;\r\n        UIGroup oldUIGroup;\r\n        if (MetaContactListSource.isRootGroup(oldParent))\r\n            oldUIGroup = GuiActivator.getContactList().getTreeModel().getRoot().getGroupDescriptor();\r\n        else\r\n            synchronized (oldParent) {\r\n                oldUIGroup = MetaContactListSource.getUIGroup(oldParent);\r\n            }\r\n        if (oldUIGroup != null)\r\n            GuiActivator.getContactList().removeContact(uiContact);\r\n        uiContact = MetaContactListSource.createUIContact(metaContact);\r\n        UIGroup newUIGroup = null;\r\n        if (!MetaContactListSource.isRootGroup(newParent)) {\r\n            synchronized (newParent) {\r\n                newUIGroup = MetaContactListSource.getUIGroup(newParent);\r\n                if (newUIGroup == null)\r\n                    newUIGroup = MetaContactListSource.createUIGroup(newParent);\r\n            }\r\n        }\r\n        ContactListFilter currentFilter = GuiActivator.getContactList().getCurrentFilter();\r\n        synchronized (uiContact) {\r\n            if (currentFilter.isMatching(uiContact) && uiContact.getContactNode() == null)\r\n                GuiActivator.getContactList().addContact(uiContact, newUIGroup, true, true);\r\n            else\r\n                MetaContactListSource.removeUIContact(metaContact);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.MetaContactListSource.metaContactMoved",
	"Comment": "performs needed operations, when a metacontact has beenmoved in the metacontactlistservice from one group to another.",
	"Method": "void metaContactMoved(MetaContactMovedEvent evt){\r\n    metaContactMoved(evt);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.googletalkaccregwizz.GoogleTalkAccRegWizzActivator.getGoogleTalkProtocolProviderFactory",
	"Comment": "returns the protocolproviderfactory for the google talkprotocol.",
	"Method": "ProtocolProviderFactory getGoogleTalkProtocolProviderFactory(){\r\n    ServiceReference[] serRefs = null;\r\n    String osgiFilter = \"(\" + ProtocolProviderFactory.PROTOCOL + \"=\" + ProtocolNames.JABBER + \")\";\r\n    try {\r\n        serRefs = bundleContext.getServiceReferences(ProtocolProviderFactory.class.getName(), osgiFilter);\r\n    } catch (InvalidSyntaxException ex) {\r\n        logger.error(\"GoogleTalkAccRegWizzActivator : \" + ex);\r\n    }\r\n    return (ProtocolProviderFactory) bundleContext.getService(serRefs[0]);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.TestOperationSetPresence.testChangingStateToAway",
	"Comment": "verify that changing state to away works as supposed to and that itgenerates the corresponding event.",
	"Method": "void testChangingStateToAway(){\r\n    subtestStateTransition(JabberStatusEnum.AWAY);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.globalshortcut.CallShortcut.shortcutReceived",
	"Comment": "notifies this globalshortcutlistener that a shortcut wastriggered.",
	"Method": "void shortcutReceived(GlobalShortcutEvent evt){\r\n    AWTKeyStroke keystroke = evt.getKeyStroke();\r\n    GlobalKeybindingSet set = keybindingsService.getGlobalBindings();\r\n    for (Map.Entry<String, List<AWTKeyStroke>> entry : set.getBindings().entrySet()) {\r\n        for (AWTKeyStroke ks : entry.getValue()) {\r\n            if (ks == null)\r\n                continue;\r\n            String entryKey = entry.getKey();\r\n            if (entryKey.equals(\"answer\") && keystroke.getKeyCode() == ks.getKeyCode() && keystroke.getModifiers() == ks.getModifiers()) {\r\n                manageNextIncomingCall(CallAction.ANSWER);\r\n            } else if (entryKey.equals(\"hangup\") && keystroke.getKeyCode() == ks.getKeyCode() && keystroke.getModifiers() == ks.getModifiers()) {\r\n                if (!manageNextIncomingCall(CallAction.HANGUP)) {\r\n                    if (!closeAnsweredCalls(true)) {\r\n                        closeAnsweredCalls(false);\r\n                    }\r\n                }\r\n            } else if (entryKey.equals(\"answer_hangup\") && keystroke.getKeyCode() == ks.getKeyCode() && keystroke.getModifiers() == ks.getModifiers()) {\r\n                if (!manageNextIncomingCall(CallAction.ANSWER)) {\r\n                    if (!closeAnsweredCalls(true)) {\r\n                        closeAnsweredCalls(false);\r\n                    }\r\n                }\r\n            } else if (entryKey.equals(\"mute\") && keystroke.getKeyCode() == ks.getKeyCode() && keystroke.getModifiers() == ks.getModifiers()) {\r\n                try {\r\n                    handleAllCallsMute(mute);\r\n                } finally {\r\n                    mute = !mute;\r\n                }\r\n            } else if (entryKey.equals(\"push_to_talk\") && keystroke.getKeyCode() == ks.getKeyCode() && keystroke.getModifiers() == ks.getModifiers() && evt.isReleased() == ptt_pressed) {\r\n                try {\r\n                    handleAllCallsMute(ptt_pressed);\r\n                } finally {\r\n                    ptt_pressed = !ptt_pressed;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ProtocolProviderServiceJabberImpl.connectAndLogin",
	"Comment": "tries to login to the xmpp server with the supplied user id. if theprotocol is google talk, the user id including the service name is used.for other protocols, if the login with the user id without the servicename fails, a second attempt including the service name is made.",
	"Method": "ConnectState connectAndLogin(InetSocketAddress currentAddress,String serviceName,JabberLoginStrategy loginStrategy,ConnectState connectAndLogin,InetSocketAddress address,String serviceName,String userName,String resource,JabberLoginStrategy loginStrategy){\r\n    ConnectionConfiguration confConn;\r\n    String boshURL = accountID.getBoshUrl();\r\n    boolean isBosh = !org.jitsi.util.StringUtils.isNullOrEmpty(boshURL);\r\n    if (isBosh) {\r\n        confConn = new BOSHConfiguration(serviceName);\r\n        ((BOSHConfiguration) confConn).setBoshUrl(boshURL);\r\n    } else {\r\n        confConn = new ConnectionConfiguration(address.getAddress().getHostAddress(), address.getPort(), serviceName, proxy);\r\n    }\r\n    if (getOperationSet(OperationSetPersistentPresence.class) != null)\r\n        confConn.setSendPresence(false);\r\n    confConn.setReconnectionAllowed(false);\r\n    boolean tlsRequired = loginStrategy.isTlsRequired();\r\n    confConn.setSecurityMode(tlsRequired ? ConnectionConfiguration.SecurityMode.required : ConnectionConfiguration.SecurityMode.enabled);\r\n    TLSUtils.setTLSOnly(confConn);\r\n    if (connection != null) {\r\n        logger.error(\"Connection is not null and isConnected:\" + connection.isConnected(), new Exception(\"Trace possible duplicate connections: \" + getAccountID().getAccountAddress()));\r\n        disconnectAndCleanConnection();\r\n    }\r\n    connection = isBosh ? new XMPPBOSHConnection((BOSHConfiguration) confConn) : new XMPPConnection(confConn);\r\n    this.address = address;\r\n    try {\r\n        CertificateService cvs = getCertificateVerificationService();\r\n        if (cvs != null) {\r\n            SSLContext sslContext = loginStrategy.createSslContext(cvs, getTrustManager(cvs, serviceName));\r\n            if (logger.isDebugEnabled() && sslContext != null) {\r\n                final StringBuilder buff = new StringBuilder();\r\n                buff.append(\"Available TLS protocols and algorithms:\\n\");\r\n                buff.append(\"Default protocols: \");\r\n                buff.append(Arrays.toString(sslContext.getDefaultSSLParameters().getProtocols()));\r\n                buff.append(\"\\n\");\r\n                buff.append(\"Supported protocols: \");\r\n                buff.append(Arrays.toString(sslContext.getSupportedSSLParameters().getProtocols()));\r\n                buff.append(\"\\n\");\r\n                buff.append(\"Default cipher suites: \");\r\n                buff.append(Arrays.toString(sslContext.getDefaultSSLParameters().getCipherSuites()));\r\n                buff.append(\"\\n\");\r\n                buff.append(\"Supported cipher suites: \");\r\n                buff.append(Arrays.toString(sslContext.getSupportedSSLParameters().getCipherSuites()));\r\n                logger.debug(buff.toString());\r\n            }\r\n            confConn.setCustomSSLContext(sslContext);\r\n        } else if (tlsRequired)\r\n            throw new XMPPException(\"Certificate verification service is \" + \"unavailable and TLS is required\");\r\n    } catch (GeneralSecurityException e) {\r\n        logger.error(\"Error creating custom trust manager\", e);\r\n        throw new XMPPException(\"Error creating custom trust manager\", e);\r\n    }\r\n    if (debugger == null) {\r\n        debugger = new SmackPacketDebugger();\r\n        debugger.setConnection(connection);\r\n        connection.addPacketListener(debugger, null);\r\n        connection.addPacketInterceptor(debugger, null);\r\n    }\r\n    connection.connect();\r\n    setTrafficClass();\r\n    if (abortConnecting) {\r\n        abortConnecting = false;\r\n        disconnectAndCleanConnection();\r\n        return ConnectState.ABORT_CONNECTING;\r\n    }\r\n    registerServiceDiscoveryManager();\r\n    if (connectionListener == null) {\r\n        connectionListener = new JabberConnectionListener();\r\n    }\r\n    if (!connection.isSecureConnection() && tlsRequired) {\r\n        throw new XMPPException(\"TLS is required by client\");\r\n    }\r\n    if (!connection.isConnected()) {\r\n        disconnectAndCleanConnection();\r\n        logger.error(\"Connection not established, server not found!\");\r\n        eventDuringLogin = null;\r\n        fireRegistrationStateChanged(getRegistrationState(), RegistrationState.CONNECTION_FAILED, RegistrationStateChangeEvent.REASON_SERVER_NOT_FOUND, null);\r\n        return ConnectState.ABORT_CONNECTING;\r\n    } else {\r\n        final SSLSocket sslSocket = getSSLSocket();\r\n        if (sslSocket != null) {\r\n            StringBuilder buff = new StringBuilder();\r\n            buff.append(\"Chosen TLS protocol and algorithm:\\n\").append(\"Protocol: \").append(sslSocket.getSession().getProtocol()).append(\"\\n\").append(\"Cipher suite: \").append(sslSocket.getSession().getCipherSuite());\r\n            logger.info(buff.toString());\r\n            if (logger.isDebugEnabled()) {\r\n                buff = new StringBuilder();\r\n                buff.append(\"Server TLS certificate chain:\\n\");\r\n                try {\r\n                    buff.append(Arrays.toString(sslSocket.getSession().getPeerCertificates()));\r\n                } catch (SSLPeerUnverifiedException ex) {\r\n                    buff.append(\"<unavailable: \").append(ex.getLocalizedMessage()).append(\">\");\r\n                }\r\n                logger.debug(buff.toString());\r\n            }\r\n        }\r\n        connection.addConnectionListener(connectionListener);\r\n    }\r\n    if (abortConnecting) {\r\n        abortConnecting = false;\r\n        disconnectAndCleanConnection();\r\n        return ConnectState.ABORT_CONNECTING;\r\n    }\r\n    fireRegistrationStateChanged(getRegistrationState(), RegistrationState.REGISTERING, RegistrationStateChangeEvent.REASON_NOT_SPECIFIED, null);\r\n    if (!loginStrategy.login(connection, userName, resource)) {\r\n        disconnectAndCleanConnection();\r\n        eventDuringLogin = null;\r\n        fireRegistrationStateChanged(getRegistrationState(), RegistrationState.CONNECTION_FAILED, RegistrationStateChangeEvent.REASON_AUTHENTICATION_FAILED, loginStrategy.getClass().getName() + \" requests abort\");\r\n        return ConnectState.ABORT_CONNECTING;\r\n    }\r\n    if (connection.isAuthenticated()) {\r\n        eventDuringLogin = null;\r\n        fireRegistrationStateChanged(getRegistrationState(), RegistrationState.REGISTERED, RegistrationStateChangeEvent.REASON_NOT_SPECIFIED, null);\r\n        return ConnectState.STOP_TRYING;\r\n    } else {\r\n        disconnectAndCleanConnection();\r\n        eventDuringLogin = null;\r\n        fireRegistrationStateChanged(getRegistrationState(), RegistrationState.UNREGISTERED, RegistrationStateChangeEvent.REASON_NOT_SPECIFIED, null);\r\n        return ConnectState.CONTINUE_TRYING;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.jabber.JabberAccountRegistration.isRememberPassword",
	"Comment": "returns true if password has to remembered, false otherwise.",
	"Method": "boolean isRememberPassword(){\r\n    return rememberPassword;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaAwareCallPeer.addStreamSoundLevelListener",
	"Comment": "adds a specific soundlevellistener to the list of listenersinterested in and notified about changes in the sound level of the audiosent by the remote party. when the first listener is being registeredthe method also registers its single listener with the media handler sothat it would receive level change events and delegate them to thelisteners that have registered with us.",
	"Method": "void addStreamSoundLevelListener(SoundLevelListener listener){\r\n    synchronized (streamSoundLevelListenersSyncRoot) {\r\n        if ((streamSoundLevelListeners == null) || streamSoundLevelListeners.isEmpty()) {\r\n            CallPeerMediaHandler<?> mediaHandler = getMediaHandler();\r\n            if (isJitsiVideobridge()) {\r\n                mediaHandler.setCsrcAudioLevelListener(this);\r\n            } else {\r\n                mediaHandler.setStreamAudioLevelListener(this);\r\n            }\r\n        }\r\n        streamSoundLevelListeners = (streamSoundLevelListeners == null) ? new ArrayList<SoundLevelListener>() : new ArrayList<SoundLevelListener>(streamSoundLevelListeners);\r\n        streamSoundLevelListeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.contactsourceconfig.ContactSourceConfigActivator.getConfigurationService",
	"Comment": "returns a reference to the configurationservice implementation currentlyregistered in the bundle context or null if no such implementation wasfound.",
	"Method": "ConfigurationService getConfigurationService(){\r\n    if (configurationService == null) {\r\n        configurationService = ServiceUtils.getService(bundleContext, ConfigurationService.class);\r\n    }\r\n    return configurationService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.NetworkUtils.compareDnsNames",
	"Comment": "compares two dns names against each other. helper method to avoid theexport of dnsjava.",
	"Method": "int compareDnsNames(String dns1,String dns2){\r\n    try {\r\n        return Name.fromString(dns1).compareTo(Name.fromString(dns2));\r\n    } catch (TextParseException e) {\r\n        throw new ParseException(e.getMessage(), 0);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractChatRoom.fireConferencePublishedEvent",
	"Comment": "creates the corresponding chatroomconferencepublishedevent andnotifies all chatroomconferencepublishedlisteners thatmember has published a conference description.",
	"Method": "void fireConferencePublishedEvent(ChatRoomMember member,ConferenceDescription cd,int eventType){\r\n    ChatRoomConferencePublishedEvent evt = new ChatRoomConferencePublishedEvent(eventType, this, member, cd);\r\n    List<ChatRoomConferencePublishedListener> listeners;\r\n    synchronized (conferencePublishedListeners) {\r\n        listeners = new LinkedList<ChatRoomConferencePublishedListener>(conferencePublishedListeners);\r\n    }\r\n    for (ChatRoomConferencePublishedListener listener : listeners) listener.conferencePublished(evt);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.globalproxyconfig.Resources.getString",
	"Comment": "returns an internationalized string corresponding to the given key.",
	"Method": "String getString(String key){\r\n    return getResources().getI18NString(key);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.callhistory.CallHistoryServiceImpl.handleProviderRemoved",
	"Comment": "removes the specified provider from the list of currently known providersand ignores all the calls made by it",
	"Method": "void handleProviderRemoved(ProtocolProviderService provider){\r\n    OperationSetBasicTelephony<?> opSetTelephony = provider.getOperationSet(OperationSetBasicTelephony.class);\r\n    if (opSetTelephony != null) {\r\n        opSetTelephony.removeCallListener(this);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.AbstractPacketExtension.getNamespace",
	"Comment": "returns the xml namespace for this element or null if theelement does not live in a namespace of its own.",
	"Method": "String getNamespace(){\r\n    return namespace;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.geolocation.GeolocationPacketExtension.getLocality",
	"Comment": "returns a locality within the administrative region, such as a town orcity.",
	"Method": "String getLocality(){\r\n    return locality;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.UINotification.getTime",
	"Comment": "returns the time in milliseconds the notification was received.",
	"Method": "long getTime(){\r\n    return notificationTime;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.OneToOneCallPanel.getCallContainer",
	"Comment": "returns the parent call container, where this renderer is contained.",
	"Method": "CallPanel getCallContainer(){\r\n    return callContainer;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.TreeContactList.metaGroupReceived",
	"Comment": "indicates that a metagroup has been received from a search inthe metacontactlistservice.",
	"Method": "void metaGroupReceived(MetaGroupQueryEvent event){\r\n    MetaContactGroup metaGroup = event.getMetaGroup();\r\n    UIGroup uiGroup;\r\n    synchronized (metaGroup) {\r\n        uiGroup = MetaContactListSource.createUIGroup(metaGroup);\r\n    }\r\n    if (uiGroup != null)\r\n        this.addGroup(uiGroup, true);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.EncryptionPacketExtension.setRequired",
	"Comment": "specifies whether encryption is required for this session or not.",
	"Method": "void setRequired(boolean required){\r\n    if (required)\r\n        super.setAttribute(REQUIRED_ATTR_NAME, required);\r\n    else\r\n        super.removeAttribute(REQUIRED_ATTR_NAME);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.FullScreenShareIndicator.propertyChange",
	"Comment": "listens for vide change events of local video straming in mesia casedesktop, whether we need to start and show the dialog, or if alreadyshown to close it.",
	"Method": "void propertyChange(PropertyChangeEvent evt){\r\n    if (!evt.getPropertyName().equals(OperationSetVideoTelephony.LOCAL_VIDEO_STREAMING) || (call instanceof MediaAwareCall && ((MediaAwareCall) call).getMediaUseCase() != MediaUseCase.DESKTOP))\r\n        return;\r\n    Object newValue = evt.getNewValue();\r\n    Object oldValue = evt.getOldValue();\r\n    if ((oldValue == null || oldValue == MediaDirection.RECVONLY) && newValue == MediaDirection.SENDRECV && DesktopSharingFrame.getFrameForCall(call) == null) {\r\n        showDialog();\r\n    } else if (oldValue == MediaDirection.SENDRECV && (newValue == null || newValue == MediaDirection.RECVONLY)) {\r\n        closeDialog();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetPresenceSipImpl.stopEvents",
	"Comment": "will wait for every subscribe, notify and publish transactionto finish before continuing the unsubscription",
	"Method": "void stopEvents(){\r\n    for (byte i = 0; i < 10; i++) {\r\n        synchronized (waitedCallIds) {\r\n            if (waitedCallIds.size() == 0) {\r\n                break;\r\n            }\r\n        }\r\n        synchronized (this) {\r\n            try {\r\n                wait(500);\r\n            } catch (InterruptedException e) {\r\n                if (logger.isDebugEnabled()) {\r\n                    logger.debug(\"abnormal behavior, may cause unnecessary CPU use\", e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetMultiUserChatJabberImpl.contactModified",
	"Comment": "updates corresponding chat room members when a contact has been modifiedin our contact list.",
	"Method": "void contactModified(ContactPropertyChangeEvent evt){\r\n    Contact modifiedContact = evt.getSourceContact();\r\n    this.updateChatRoomMembers(modifiedContact);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractContact.addResourceListener",
	"Comment": "adds the given contactresourcelistener to listen for eventsrelated to contact resources changes.",
	"Method": "void addResourceListener(ContactResourceListener l){\r\n    if (resourceListeners == null)\r\n        resourceListeners = new ArrayList<ContactResourceListener>();\r\n    synchronized (resourceListeners) {\r\n        resourceListeners.add(l);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.server.WebSocketOverSSLTest.testEcho",
	"Comment": "test the requirement of issuing socket and receiving echo response",
	"Method": "void testEcho(){\r\n    assertThat(\"server scheme\", server.getServerUri().getScheme(), is(\"wss\"));\r\n    WebSocketClient client = new WebSocketClient(server.getSslContextFactory(), null, bufferPool);\r\n    try {\r\n        client.start();\r\n        CaptureSocket clientSocket = new CaptureSocket();\r\n        URI requestUri = server.getServerUri();\r\n        System.err.printf(\"Request URI: %s%n\", requestUri.toASCIIString());\r\n        Future<Session> fut = client.connect(clientSocket, requestUri);\r\n        Session session = fut.get(FUTURE_TIMEOUT_SEC, TimeUnit.SECONDS);\r\n        String msg = \"this is an echo ... cho ... ho ... o\";\r\n        RemoteEndpoint remote = session.getRemote();\r\n        remote.sendString(msg);\r\n        if (remote.getBatchMode() == BatchMode.ON)\r\n            remote.flush();\r\n        LinkedBlockingQueue<String> captured = clientSocket.messages;\r\n        assertThat(\"Text Message\", captured.poll(Timeouts.POLL_EVENT, Timeouts.POLL_EVENT_UNIT), is(msg));\r\n        clientSocket.close();\r\n    } finally {\r\n        client.stop();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.CallEvent.getEventID",
	"Comment": "returns an event id int indicating whether this event was triggered byan outgoing or an incoming call.",
	"Method": "int getEventID(){\r\n    return this.eventID;\r\n}"
}, {
	"Path": "net.librec.math.algorithm.Randoms.pareto",
	"Comment": "return a real number with a pareto distribution with parameter alpha.",
	"Method": "double pareto(double alpha){\r\n    return Math.pow(1 - uniform(), -1.0 / alpha) - 1.0;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomIrcImpl.addMemberRoleListener",
	"Comment": "adds a listener that will be notified of changes of a member role in theroom such as being granted operator.",
	"Method": "void addMemberRoleListener(ChatRoomMemberRoleListener listener){\r\n    synchronized (memberRoleListeners) {\r\n        if (!memberRoleListeners.contains(listener)) {\r\n            memberRoleListeners.add(listener);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.notification.SoundNotificationAction.isSoundNotificationEnabled",
	"Comment": "returns if this sound is to be played on notification device.",
	"Method": "boolean isSoundNotificationEnabled(){\r\n    return isSoundNotificationEnabled;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.customcontrols.wizard.WizardModel.firePropertyChange",
	"Comment": "informs allpropertychangelisteners that the a given propertyhas changed.",
	"Method": "void firePropertyChange(String propertyName,Object oldValue,Object newValue){\r\n    propertyChangeSupport.firePropertyChange(propertyName, oldValue, newValue);\r\n}"
}, {
	"Path": "io.lettuce.core.protocol.RedisStateMachine.add",
	"Comment": "add a state as tail element. this method shifts the whole stack if the stack is not empty.",
	"Method": "void add(State[] stack,State state){\r\n    if (stackElements != 0) {\r\n        System.arraycopy(stack, 0, stack, 1, stackElements);\r\n    }\r\n    stack[0] = state;\r\n    stackElements++;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.contactlist.TestMetaContactGroup.testCountChildContacts",
	"Comment": "verifies whehter the returned number of contacts corresponds to thechildren of the corresponding mock contact group.",
	"Method": "void testCountChildContacts(){\r\n    assertEquals(\"MetaContactGroup.countChildContacts failed\", metaGroup.countChildContacts(), mockGroup.countContacts());\r\n}"
}, {
	"Path": "io.lettuce.core.dynamic.parameter.Parameter.findAnnotation",
	"Comment": "return the parameter annotation of the given type, if available.",
	"Method": "A findAnnotation(Class<A> annotationType){\r\n    if (absentCache.contains(annotationType)) {\r\n        return null;\r\n    }\r\n    A result = (A) annotationCache.computeIfAbsent(annotationType, key -> methodParameter.getParameterAnnotation(annotationType));\r\n    if (result == null) {\r\n        absentCache.add(annotationType);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "io.lettuce.core.dynamic.support.MethodParameter.setContainingClass",
	"Comment": "set a containing class to resolve the parameter type against.",
	"Method": "void setContainingClass(Class<?> containingClass){\r\n    this.containingClass = containingClass;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetGeolocationJabberImpl.removeGeolocationListener",
	"Comment": "remove a listener that would get notifications any time a contactrefreshed its geolocation via presence.",
	"Method": "void removeGeolocationListener(GeolocationListener listener){\r\n    synchronized (geolocationContactsListeners) {\r\n        geolocationContactsListeners.remove(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.googletalkaccregwizz.GoogleTalkAccountRegistrationWizard.getPageImage",
	"Comment": "implements the accountregistrationwizard.getpageimage method.returns the image used to decorate the wizard page",
	"Method": "byte[] getPageImage(){\r\n    return GoogleTalkAccRegWizzActivator.getResources().getImageInBytes(PAGE_IMAGE);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.neomedia.VideoDeviceConfigurationListener.propertyChange",
	"Comment": "notifies this instance that a property related to the configuration ofdevices has had its value changed and thus signals that a video devicemay have been plugged or unplugged.",
	"Method": "void propertyChange(PropertyChangeEvent ev){\r\n    if (DeviceConfiguration.VIDEO_CAPTURE_DEVICE.equals(ev.getPropertyName())) {\r\n        Object newValue = ev.getNewValue();\r\n        if (newValue != null) {\r\n            String title = NeomediaActivator.getResources().getI18NString(\"impl.media.configform.VIDEO_DEVICE_SELECTED\");\r\n            String body = ((CaptureDeviceInfo) newValue).getName();\r\n            String popUpEvent = NeomediaActivator.NEW_SELECTED_DEVICE;\r\n            showPopUpNotification(title, body, popUpEvent);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.launchutils.LaunchArgHandler.getPackageName",
	"Comment": "returns the package name of the application. that should be jitsimost of the time but who knows ..",
	"Method": "String getPackageName(){\r\n    String name = versionProperties.getProperty(PNAME_PACKAGE_NAME);\r\n    return name == null ? \"jitsi\" : name;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.gibberishaccregwizz.GibberishAccountRegistrationWizard.getPageImage",
	"Comment": "implements the accountregistrationwizard.getpageimage method.returns the image used to decorate the wizard page",
	"Method": "byte[] getPageImage(){\r\n    return Resources.getImage(Resources.PAGE_IMAGE);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipRegistrarConnection.updateRegisterSequenceNumber",
	"Comment": "updates our local sequence counter based on the value in the cseq header of the request that originated the lastclienttran transation. the method is used after running an authentication challenge through the security manager. the security manager would manually increment the cseq number of the request so we need to update our local counter or otherwise the next register we send would have a wrong cseq.",
	"Method": "void updateRegisterSequenceNumber(ClientTransaction lastClientTran){\r\n    Request req = lastClientTran.getRequest();\r\n    CSeqHeader cSeqHeader = (CSeqHeader) req.getHeader(CSeqHeader.NAME);\r\n    long sequenceNumber = cSeqHeader.getSeqNumber();\r\n    this.nextCSeqValue = sequenceNumber + 1;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.WhiteboardInvitationJabberImpl.getTargetWhiteboard",
	"Comment": "returns the whiteboardsession, that this invitation is about.",
	"Method": "WhiteboardSession getTargetWhiteboard(){\r\n    return whiteboardSession;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetMultiUserChatJabberImpl.isPrivateMessagingContact",
	"Comment": "checks if the contact address is associated with private messagingcontact or not.",
	"Method": "boolean isPrivateMessagingContact(String contactAddress){\r\n    return opSetPersPresence.isPrivateMessagingContact(contactAddress);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.jabberconstants.JabberStatusEnum.getSupportedStatusSet",
	"Comment": "returns an iterator over all status instances supported by the sipprovider.",
	"Method": "Iterator<PresenceStatus> getSupportedStatusSet(){\r\n    return supportedStatusSet.iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.ConfigurationUtils.isShowStatusChangedInChat",
	"Comment": "returns true if status changed should be shown inchat history area, false otherwise.",
	"Method": "boolean isShowStatusChangedInChat(){\r\n    return showStatusChangedInChat;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.launchutils.LaunchArgHandler.setDelegationPeer",
	"Comment": "sets the delegationpeer that would be handling all uris passedas command line arguments to sip communicator.",
	"Method": "void setDelegationPeer(ArgDelegationPeer delegationPeer){\r\n    this.argDelegator.setDelegationPeer(delegationPeer);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetContactCapabilitiesJabberImpl.getLargestSupportedOperationSet",
	"Comment": "gets the largest set of operationsets supported from alist of full jids. the returned operationsets are consideredby the associated protocol provider to capabilities possessed by thespecified contact.",
	"Method": "Map<String, OperationSet> getLargestSupportedOperationSet(ArrayList<String> fullJids){\r\n    Map<String, OperationSet> supportedOperationSets = new HashMap<String, OperationSet>();\r\n    if (fullJids != null) {\r\n        for (String fullJid : fullJids) {\r\n            Map<String, OperationSet> newSupportedOperationSets = getSupportedOperationSets(fullJid, true);\r\n            if (newSupportedOperationSets.size() > supportedOperationSets.size()) {\r\n                supportedOperationSets = newSupportedOperationSets;\r\n            }\r\n        }\r\n    }\r\n    return supportedOperationSets;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.OperationSetMultiUserChatIrcImpl.registerChatRoomInstance",
	"Comment": "register chat room instance in case it is not yet registered.",
	"Method": "void registerChatRoomInstance(ChatRoomIrcImpl chatroom){\r\n    synchronized (this.chatRoomCache) {\r\n        this.chatRoomCache.put(chatroom.getIdentifier(), chatroom);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.gibberish.TestOperationSetPersistentPresence.testRetrievingServerStoredContactList",
	"Comment": "retrieves a server stored contact list and checks whether it containsall contacts that have been added there during the initializationphase by the testeragent.",
	"Method": "void testRetrievingServerStoredContactList(){\r\n    ContactGroup rootGroup = opSetPersPresence1.getServerStoredContactListRoot();\r\n    logger.debug(\"=========== Server Stored Contact List =================\");\r\n    logger.debug(\"rootGroup=\" + rootGroup.getGroupName() + \" rootGroup.childContacts=\" + rootGroup.countContacts() + \"rootGroup.childGroups=\" + rootGroup.countSubgroups() + \"Printing rootGroupContents=\\n\" + rootGroup.toString());\r\n    Hashtable<String, List<String>> expectedContactList = GibberishSlickFixture.preInstalledBuddyList;\r\n    logger.debug(\"============== Expected Contact List ===================\");\r\n    logger.debug(expectedContactList);\r\n    Iterator<ContactGroup> groups = rootGroup.subgroups();\r\n    while (groups.hasNext()) {\r\n        ContactGroup group = groups.next();\r\n        List<String> expectedContactsInGroup = expectedContactList.get(group.getGroupName());\r\n        if (!group.getGroupName().equals(\"NotInContactList\")) {\r\n            assertNotNull(\"Group \" + group.getGroupName() + \" was returned by \" + \"the server but was not in the expected contact list.\", expectedContactsInGroup);\r\n            Iterator<Contact> contactsIter = group.contacts();\r\n            while (contactsIter.hasNext()) {\r\n                String contactID = contactsIter.next().getAddress();\r\n                expectedContactsInGroup.remove(contactID);\r\n            }\r\n            if (expectedContactsInGroup.size() == 0)\r\n                expectedContactList.remove(group.getGroupName());\r\n        }\r\n    }\r\n    assertTrue(\"The following contacts were on the server sidec contact \" + \"list, but were not returned by the pers. pres. op. set\" + expectedContactList.toString(), expectedContactList.isEmpty());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetPersistentPresenceJabberImpl.clearLocalContactResources",
	"Comment": "clear resources used for local contact and before that update itsresources in order to fire the needed events.",
	"Method": "void clearLocalContactResources(){\r\n    if (localContact != null)\r\n        removeResource(localContact, localContact.getAddress());\r\n    currentPresence = null;\r\n    localContact = null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.GenericUIContactImpl.getToolTip",
	"Comment": "creates a tool tip for this contact. if such tooltip isprovided it would be shown on mouse over over this uicontact.",
	"Method": "ExtendedTooltip getToolTip(){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.msoutlook.calendar.CalendarServiceImpl.start",
	"Comment": "retrieves, parses and stores all the calendar items from the outlook.",
	"Method": "void start(){\r\n    getAllCalendarItems(new NotificationsDelegate());\r\n}"
}, {
	"Path": "net.librec.conf.Configuration.setInts",
	"Comment": "set the array of int values for the name property as ascomma delimited values.",
	"Method": "void setInts(String name,int[] values){\r\n    set(name, StringUtil.arrayToString(values));\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.common.WebSocketRemoteEndpointTest.testLargeSmallText",
	"Comment": "ensure that websocketremoteendpoint honors the correct order of websocket frames.",
	"Method": "void testLargeSmallText(TestInfo testInfo){\r\n    LocalWebSocketConnection conn = new LocalWebSocketConnection(testInfo.getDisplayName(), bufferPool);\r\n    OutgoingFrames orderingAssert = new SaneFrameOrderingAssertion();\r\n    WebSocketRemoteEndpoint remote = new WebSocketRemoteEndpoint(conn, orderingAssert);\r\n    conn.connect();\r\n    conn.open();\r\n    int largeMessageSize = 60000;\r\n    byte[] buf = new byte[largeMessageSize];\r\n    Arrays.fill(buf, (byte) 'x');\r\n    String largeMessage = new String(buf, UTF_8);\r\n    int messageCount = 10000;\r\n    for (int i = 0; i < messageCount; i++) {\r\n        Future<Void> fut;\r\n        if (i % 2 == 0)\r\n            fut = remote.sendStringByFuture(largeMessage);\r\n        else\r\n            fut = remote.sendStringByFuture(\"Short Message: \" + i);\r\n        fut.get();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.account.AccountListCellRenderer.isOverCheckBox",
	"Comment": "indicates if the point given by x and y coordinates is over the checkbox component.",
	"Method": "boolean isOverCheckBox(int x,int y){\r\n    JCheckBox checkBox = account.getEnableCheckBox();\r\n    Point location = checkBox.getLocation();\r\n    Dimension size = checkBox.getSize();\r\n    return (x >= location.x && x <= size.width) && (y >= location.y && y <= size.height);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomJabberImpl.sendPresenceExtension",
	"Comment": "adds given packetextension to the muc presence and publishes itimmediately.",
	"Method": "void sendPresenceExtension(PacketExtension extension){\r\n    if (lastPresenceSent != null) {\r\n        setPacketExtension(lastPresenceSent, extension, extension.getNamespace());\r\n        provider.getConnection().sendPacket(lastPresenceSent);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ChatConferenceCallDialog.setSelectedRadioButton",
	"Comment": "selects a radio button and shows the correct panel related to the selected radio button.",
	"Method": "void setSelectedRadioButton(boolean isCreateSelected){\r\n    if (isCreateSelected) {\r\n        createConferenceButton.setSelected(true);\r\n    } else {\r\n        joinConferenceButton.setSelected(true);\r\n    }\r\n    updateView();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomIrcImpl.addLocalUserRoleListener",
	"Comment": "adds a listener that will be notified of changes in our role in the roomsuch as us being granded operator.",
	"Method": "void addLocalUserRoleListener(ChatRoomLocalUserRoleListener listener){\r\n    synchronized (localUserRoleListeners) {\r\n        if (!localUserRoleListeners.contains(listener)) {\r\n            localUserRoleListeners.add(listener);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.googlecontacts.GoogleContactsActivator.getBrowserLauncherService",
	"Comment": "return reference to a browser launcher service implementation.",
	"Method": "BrowserLauncherService getBrowserLauncherService(){\r\n    if (browserLauncherService == null) {\r\n        browserLauncherService = ServiceUtils.getService(bundleContext, BrowserLauncherService.class);\r\n    }\r\n    return browserLauncherService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.addChatMessage",
	"Comment": "passes the message to the contained chatconversationpanelfor processing and appends it at the end of the conversationpaneldocument.",
	"Method": "void addChatMessage(ChatMessage chatMessage){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                addChatMessage(chatMessage);\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    if (ConfigurationUtils.isHistoryShown() && !isHistoryLoaded) {\r\n        synchronized (incomingEventBuffer) {\r\n            incomingEventBuffer.add(chatMessage);\r\n        }\r\n    } else {\r\n        displayChatMessage(chatMessage);\r\n    }\r\n    this.lastHistoryMsgTimestamp = chatMessage.getDate();\r\n    if (chatMessage.getMessageType().equals(Chat.OUTGOING_MESSAGE)) {\r\n        this.lastSentMessageUID = chatMessage.getMessageUID();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.addChatMessage",
	"Comment": "passes the message to the contained chatconversationpanelfor processing and appends it at the end of the conversationpaneldocument.",
	"Method": "void addChatMessage(ChatMessage chatMessage){\r\n    addChatMessage(chatMessage);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.SmileysSelectorBox.clearMouseOverEffects",
	"Comment": "clears all mouse over effects for the given smiley item. this methodshould be invoked when the mouse has exited the smiley area or whena smiley has been selected and the popup menu is closed.",
	"Method": "void clearMouseOverEffects(SmileyMenuItem smileyItem){\r\n    ImageIcon imageIcon = GuiActivator.getResources().getImage(smileyItem.smiley.getImageID());\r\n    smileyItem.setIcon(imageIcon);\r\n    smileyTextLabel.setText(\"\");\r\n    smileyDescriptionLabel.setText(\"\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.gui.UIGroup.getPreferredHeight",
	"Comment": "returns the preferred height of this group in the contact list.",
	"Method": "int getPreferredHeight(){\r\n    return preferredGroupHeight;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaAwareCallPeer.removeStreamSoundLevelListener",
	"Comment": "removes a specific soundlevellistener of the list oflisteners interested in and notified about changes in stream sound levelrelated information.",
	"Method": "void removeStreamSoundLevelListener(SoundLevelListener listener){\r\n    synchronized (streamSoundLevelListenersSyncRoot) {\r\n        if (streamSoundLevelListeners != null) {\r\n            streamSoundLevelListeners = new ArrayList<SoundLevelListener>(streamSoundLevelListeners);\r\n            if (streamSoundLevelListeners.remove(listener) && streamSoundLevelListeners.isEmpty())\r\n                streamSoundLevelListeners = null;\r\n        }\r\n        if ((streamSoundLevelListeners == null) || streamSoundLevelListeners.isEmpty()) {\r\n            getMediaHandler().setStreamAudioLevelListener(null);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.configuration.TestConfigurationServicePersistency.testStoreConfiguration",
	"Comment": "test whether a configuration is properly stored in the configurationfile.",
	"Method": "void testStoreConfiguration(){\r\n    configurationService.setProperty(addedPropertyPath + addedProperty, addedPropertyValue2);\r\n    configurationService.setProperty(property1Path + property1, property1Value2);\r\n    configurationService.setProperty(systemPropertyPath + systemProperty, systemPropertyValue2);\r\n    configurationService.setProperty(innerPropertyPath + innerProperty, innerPropertyValue2);\r\n    configurationService.storeConfiguration();\r\n    configurationService.reloadConfiguration();\r\n    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\r\n    DocumentBuilder builder = factory.newDocumentBuilder();\r\n    Document document = builder.parse(confFile);\r\n    Node root = document.getFirstChild();\r\n    Node parent = XMLUtils.findChild((Element) root, \"parent\");\r\n    Node property1Node = XMLUtils.findChild((Element) parent, property1);\r\n    Node systemPropertyNode = XMLUtils.findChild((Element) parent, systemProperty);\r\n    Node addedPropertyNode = XMLUtils.findChild((Element) parent, addedProperty);\r\n    Node innerpropNode = XMLUtils.findChild((Element) parent, \"innerprops\");\r\n    Node innerPropertyNode = XMLUtils.findChild((Element) innerpropNode, innerProperty);\r\n    String xmlProp1Value = XMLUtils.getAttribute(property1Node, \"value\");\r\n    String xmlProp2Value = XMLUtils.getAttribute(systemPropertyNode, \"value\");\r\n    String xmlAddedPropertyValue = XMLUtils.getAttribute(addedPropertyNode, \"value\");\r\n    String xmlInnerPropertyValue = XMLUtils.getAttribute(innerPropertyNode, \"value\");\r\n    assertEquals(\"property1 was incorrectly stored\", property1Value2, xmlProp1Value);\r\n    assertEquals(\"System property was incorrectly stored\", systemPropertyValue2, xmlProp2Value);\r\n    assertEquals(\"The added property was incorrectly stored\", addedPropertyValue2, xmlAddedPropertyValue);\r\n    assertEquals(\"The inner property was incorrectly stored\", innerPropertyValue2, xmlInnerPropertyValue);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.keybindingchooser.chooser.BindingAdaptor.getInputEventType",
	"Comment": "provides the type of keystroke registered by input via generated keyadaptors.",
	"Method": "int getInputEventType(){\r\n    return this.inputEventType;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.aimaccregwizz.FirstWizardPage.getIdentifier",
	"Comment": "implements the wizardpage.getidentifier to return thispage identifier.",
	"Method": "Object getIdentifier(){\r\n    return FIRST_PAGE_IDENTIFIER;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapDirectorySettingsImpl.mergeStrings",
	"Comment": "merge string elements from a list to a single string separated by space.",
	"Method": "String mergeStrings(List<String> lst){\r\n    StringBuilder bld = new StringBuilder();\r\n    for (String s : lst) {\r\n        bld.append(s).append(\" \");\r\n    }\r\n    return bld.toString();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetPersistentPresencePermissionsJabberImpl.isReadOnly",
	"Comment": "checks whether the contact can be edited, removed, moved. ifthe parent group is readonly.",
	"Method": "boolean isReadOnly(boolean isReadOnly,Contact contact,boolean isReadOnly,ContactGroup group){\r\n    if (isReadOnly())\r\n        return true;\r\n    if (group instanceof RootContactGroupJabberImpl)\r\n        return readonlyGroups.contains(ROOT_GROUP_STR);\r\n    else\r\n        return readonlyGroups.contains(group.getGroupName());\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.SessionRenewTest.doTest",
	"Comment": "perform the test by making a request to create a sessionthen another request that will renew the session id.",
	"Method": "void doTest(RenewalVerifier verifier){\r\n    String contextPath = \"\";\r\n    String servletMapping = \"/server\";\r\n    WebAppContext context = _server.addWebAppContext(\".\", contextPath);\r\n    context.setParentLoaderPriority(true);\r\n    context.addServlet(TestServlet.class, servletMapping);\r\n    TestHttpSessionIdListener testListener = new TestHttpSessionIdListener();\r\n    context.addEventListener(testListener);\r\n    HttpClient client = new HttpClient();\r\n    try {\r\n        _server.start();\r\n        int port = _server.getPort();\r\n        client.start();\r\n        ContentResponse response = client.GET(\"http://localhost:\" + port + contextPath + servletMapping + \"?action=create\");\r\n        assertEquals(HttpServletResponse.SC_OK, response.getStatus());\r\n        String sessionCookie = response.getHeaders().get(\"Set-Cookie\");\r\n        assertTrue(sessionCookie != null);\r\n        assertFalse(testListener.isCalled());\r\n        Request request = client.newRequest(\"http://localhost:\" + port + contextPath + servletMapping + \"?action=renew\");\r\n        ContentResponse renewResponse = request.send();\r\n        assertEquals(HttpServletResponse.SC_OK, renewResponse.getStatus());\r\n        String renewSessionCookie = renewResponse.getHeaders().get(\"Set-Cookie\");\r\n        assertNotNull(renewSessionCookie);\r\n        assertNotSame(sessionCookie, renewSessionCookie);\r\n        assertTrue(testListener.isCalled());\r\n        if (verifier != null)\r\n            verifier.verify(context, TestServer.extractSessionId(sessionCookie), TestServer.extractSessionId(renewSessionCookie));\r\n    } finally {\r\n        client.stop();\r\n        _server.stop();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ProtocolProviderServiceIcqImpl.joustSimStateToRegistrationState",
	"Comment": "converts the specified joust sim connection state to a correspondingregistrationstate.",
	"Method": "RegistrationState joustSimStateToRegistrationState(State joustSimConnState,StateInfo joustSimConnStateInfo){\r\n    if (joustSimConnState == State.ONLINE)\r\n        return RegistrationState.REGISTERED;\r\n    else if (joustSimConnState == State.CONNECTING)\r\n        return RegistrationState.REGISTERING;\r\n    else if (joustSimConnState == State.AUTHORIZING)\r\n        return RegistrationState.AUTHENTICATING;\r\n    else if (joustSimConnState == State.CONNECTINGAUTH)\r\n        return RegistrationState.AUTHENTICATING;\r\n    else if (joustSimConnState == State.SIGNINGON)\r\n        return RegistrationState.REGISTERING;\r\n    else if (joustSimConnState == State.DISCONNECTED || joustSimConnState == State.NOTCONNECTED) {\r\n        if (joustSimConnStateInfo != null && joustSimConnStateInfo instanceof DisconnectedStateInfo && !((DisconnectedStateInfo) joustSimConnStateInfo).isOnPurpose()) {\r\n            return RegistrationState.CONNECTION_FAILED;\r\n        }\r\n        return RegistrationState.UNREGISTERED;\r\n    } else if (joustSimConnState == State.FAILED) {\r\n        if (joustSimConnStateInfo != null && joustSimConnStateInfo instanceof LoginFailureStateInfo) {\r\n            LoginFailureInfo lfInfo = ((LoginFailureStateInfo) joustSimConnStateInfo).getLoginFailureInfo();\r\n            if (lfInfo instanceof AuthFailureInfo)\r\n                return RegistrationState.AUTHENTICATION_FAILED;\r\n        }\r\n        return RegistrationState.CONNECTION_FAILED;\r\n    } else {\r\n        logger.warn(\"Unknown state \" + joustSimConnState + \". Defaulting to \" + RegistrationState.UNREGISTERED);\r\n        return RegistrationState.UNREGISTERED;\r\n    }\r\n}"
}, {
	"Path": "net.librec.recommender.cf.rating.IRRGRecommender.computeItemset",
	"Comment": "find out itemsets which contain three items and store them into mylist.",
	"Method": "void computeItemset(){\r\n    for (int y : itemCorrsAR.columnKeySet()) {\r\n        Object[] x = itemCorrsAR_Sorted.column(y).keySet().toArray();\r\n        for (int i = 0; i < x.length - 1; i++) {\r\n            for (int j = i + 1; j < x.length; j++) {\r\n                if (itemCount.contains(x[i], x[j])) {\r\n                    ArrayList list = new ArrayList(3);\r\n                    list.add(y);\r\n                    list.add(x[i]);\r\n                    list.add(x[j]);\r\n                    mylist.add(list);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatTransport.sendMultimediaFile",
	"Comment": "sending file in sms messages is not supported by this chat transportimplementation.",
	"Method": "FileTransfer sendMultimediaFile(File file){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.osdependent.jdic.StatusSelector.changeStatus",
	"Comment": "searches for presence status with the supplied name and publish thisstatus to the provider.",
	"Method": "void changeStatus(String statusName){\r\n    Iterator<PresenceStatus> statusSet = presence.getSupportedStatusSet();\r\n    while (statusSet.hasNext()) {\r\n        PresenceStatus status = statusSet.next();\r\n        if (status.getStatusName().equals(statusName)) {\r\n            OsDependentActivator.getGlobalStatusService().publishStatus(provider, status);\r\n            break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetFileTransferJabberImpl.assertConnected",
	"Comment": "utility method throwing an exception if the stack is not properlyinitialized.",
	"Method": "void assertConnected(){\r\n    if (jabberProvider == null)\r\n        throw new IllegalStateException(\"The provider must be non-null and signed on the \" + \"service before being able to send a file.\");\r\n    else if (!jabberProvider.isRegistered()) {\r\n        if (opSetPersPresence.getPresenceStatus().isOnline()) {\r\n            opSetPersPresence.fireProviderStatusChangeEvent(opSetPersPresence.getPresenceStatus(), jabberProvider.getJabberStatusEnum().getStatus(JabberStatusEnum.OFFLINE));\r\n        }\r\n        throw new IllegalStateException(\"The provider must be signed on the service before \" + \"being able to send a file.\");\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.plaf.SIPCommTextFieldUI.installListeners",
	"Comment": "adds the custom mouse listeners defined in this class to the installedlisteners.",
	"Method": "void installListeners(){\r\n    super.installListeners();\r\n    getComponent().addMouseListener(this);\r\n    getComponent().addMouseMotionListener(this);\r\n}"
}, {
	"Path": "net.librec.recommender.cf.UserKNNTestCase.test05SplitterRatioUserFixed",
	"Comment": "test ratiodatasplitter with user fixed ratio, evaluating enabled.",
	"Method": "void test05SplitterRatioUserFixed(){\r\n    Resource resource = new Resource(\"rec/cf/userknn-test.properties\");\r\n    conf.addResource(resource);\r\n    conf.set(\"rec.eval.enable\", \"true\");\r\n    conf.set(\"data.model.splitter\", \"ratio\");\r\n    conf.set(\"data.splitter.ratio\", \"userfixed\");\r\n    RecommenderJob job = new RecommenderJob(conf);\r\n    job.runJob();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.SourceUIContact.getScaledAvatar",
	"Comment": "returns the image corresponding to the underlying sourcecontact.",
	"Method": "ImageIcon getScaledAvatar(boolean isSelected,int width,int height){\r\n    byte[] image = sourceContact.getImage();\r\n    if ((image != null) && (image.length > 0)) {\r\n        ImageIcon icon = new ImageIcon(image);\r\n        if (icon.getIconWidth() > width || icon.getIconHeight() > height) {\r\n            icon = ImageUtils.getScaledRoundedIcon(icon.getImage(), width, height);\r\n        }\r\n        return icon;\r\n    } else\r\n        return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.mailnotification.MailThreadInfo.parse",
	"Comment": "creates and initializes a mailthreadinfo instance according tothe details that come with the parser.",
	"Method": "MailThreadInfo parse(XmlPullParser parser){\r\n    MailThreadInfo info = new MailThreadInfo();\r\n    info.setTid(parser.getAttributeValue(\"\", \"tid\"));\r\n    String participationStr = parser.getAttributeValue(\"\", \"participation\");\r\n    if (participationStr != null)\r\n        info.setParticipation(Integer.parseInt(participationStr));\r\n    String messagesStr = parser.getAttributeValue(\"\", \"messages\");\r\n    if (messagesStr != null)\r\n        info.setMessageCount(Integer.parseInt(messagesStr));\r\n    String dateStr = parser.getAttributeValue(\"\", \"date\");\r\n    if (dateStr != null)\r\n        info.setDate(Long.parseLong(dateStr));\r\n    info.setURL(parser.getAttributeValue(\"\", \"url\"));\r\n    int eventType = parser.next();\r\n    while (eventType != XmlPullParser.END_TAG) {\r\n        if (eventType == XmlPullParser.START_TAG) {\r\n            String name = parser.getName();\r\n            if (SENDERS_ELEMENT_NAME.equals(name)) {\r\n                info.parseSenders(parser);\r\n            } else if (LABELS_ELEMENT_NAME.equals(name)) {\r\n                info.setLabels(parser.nextText());\r\n            } else if (SUBJECT_ELEMENT_NAME.equals(name)) {\r\n                info.setSubject(parser.nextText());\r\n            } else if (SNIPPET_ELEMENT_NAME.equals(name)) {\r\n                info.setSnippet(parser.nextText());\r\n            }\r\n        }\r\n        eventType = parser.next();\r\n    }\r\n    return info;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.TestAccountUninstallation.testMultipleLogins",
	"Comment": "before we uninstall the current account which is registered to the serverwe add a registration change listener and wait for unregistered eventto be fired.then we use the tester agent to register to the servers withthe account info of the currently logged in account so we mustreceive multiple logins event.",
	"Method": "void testMultipleLogins(){\r\n    fixture.provider.addRegistrationStateChangeListener(regEvtCollector);\r\n    String passwd = System.getProperty(IcqProtocolProviderSlick.TESTED_IMPL_PWD_PROP_NAME, null);\r\n    String uin = System.getProperty(IcqProtocolProviderSlick.TESTED_IMPL_USER_ID_PROP_NAME, null);\r\n    IcqTesterAgent testerAgent = new IcqTesterAgent(uin);\r\n    testerAgent.register(passwd);\r\n    Object lock = new Object();\r\n    synchronized (lock) {\r\n        try {\r\n            logger.debug(\"Giving the aim server time to notify for our arrival!\");\r\n            lock.wait(5000);\r\n        } catch (Exception ex) {\r\n        }\r\n    }\r\n    testerAgent.unregister();\r\n    assertNotNull(\"No event was dispatched\", regEvtCollector.stateRecieved);\r\n    assertEquals(\"Event is not UNREGISTERED event\", regEvtCollector.stateRecieved, RegistrationState.UNREGISTERED);\r\n    assertEquals(\"No registration event notifying of Multiple logins dispatched \", regEvtCollector.eventReason, RegistrationStateChangeEvent.REASON_MULTIPLE_LOGINS);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.dns.SecureMessage.toString",
	"Comment": "converts the message to a string. the fields secure, bogus and whybogusare append as a comment.",
	"Method": "String toString(){\r\n    StringBuilder s = new StringBuilder(super.toString());\r\n    s.append('\\n');\r\n    s.append(\";; Secure: \");\r\n    s.append(secure);\r\n    s.append('\\n');\r\n    s.append(\";; Bogus:  \");\r\n    s.append(bogus);\r\n    s.append('\\n');\r\n    if (bogus) {\r\n        s.append(\";;  Reason: \");\r\n        s.append(bogusReason);\r\n        s.append('\\n');\r\n    }\r\n    return s.toString();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ChatRoomConferenceCallsListPanel.initConferences",
	"Comment": "initializes the list of the conferences that are already announced.",
	"Method": "void initConferences(){\r\n    conferenceCallsListModel.initConferences();\r\n    setSelectedIndex(0);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.IceConfigPanel.getAdditionalStunServers",
	"Comment": "returns the list of additional stun servers entered by the user.",
	"Method": "List<StunServerDescriptor> getAdditionalStunServers(){\r\n    LinkedList<StunServerDescriptor> serversList = new LinkedList<StunServerDescriptor>();\r\n    Vector<Vector<StunServerDescriptor>> serverRows = tableModel.getDataVector();\r\n    for (Vector<StunServerDescriptor> row : serverRows) serversList.add(row.elementAt(0));\r\n    return serversList;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ContactListTreeCellRenderer.internalPaintComponent",
	"Comment": "paint a background for all groups and a round blue border and backgroundwhen a cell is selected.",
	"Method": "void internalPaintComponent(Graphics2D g2){\r\n    Color borderColor = Color.GRAY;\r\n    if (isSelected) {\r\n        g2.setPaint(new GradientPaint(0, 0, Constants.SELECTED_COLOR, 0, getHeight(), Constants.SELECTED_GRADIENT_COLOR));\r\n        borderColor = Constants.SELECTED_COLOR;\r\n    } else if (treeNode instanceof GroupNode) {\r\n        g2.setPaint(new GradientPaint(0, 0, Constants.CONTACT_LIST_GROUP_BG_GRADIENT_COLOR, 0, getHeight(), Constants.CONTACT_LIST_GROUP_BG_COLOR));\r\n        borderColor = Constants.CONTACT_LIST_GROUP_BG_COLOR;\r\n    }\r\n    g2.fillRect(0, 0, getWidth(), getHeight());\r\n    g2.setColor(borderColor);\r\n    g2.drawLine(0, 0, getWidth(), 0);\r\n    g2.drawLine(0, getHeight() - 1, getWidth(), getHeight() - 1);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatConversationComponent.getDateString",
	"Comment": "returns the date string to be used in order to show date and time in thechat conversation component.",
	"Method": "String getDateString(Date date){\r\n    return ChatHtmlUtils.getDateString(date) + GuiUtils.formatTime(date) + \" \";\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.RootContactGroupJabberImpl.isPersistent",
	"Comment": "determines whether or not this contact group is being stored by theserver. non persistent contact groups exist for the sole purpose ofcontaining non persistent contacts.",
	"Method": "boolean isPersistent(){\r\n    return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.OneToOneCallPeerPanel.updateViewFromModelInEventDispatchThread",
	"Comment": "updates this view i.e. onetoonecallpeerpanel so that it depictsthe current state of its model i.e. callpeer. the update isperformed in the awt event dispatching thread.",
	"Method": "void updateViewFromModelInEventDispatchThread(){\r\n    if (disposed)\r\n        return;\r\n    OperationSetVideoTelephony videoTelephony = callPeer.getProtocolProvider().getOperationSet(OperationSetVideoTelephony.class);\r\n    Component remoteVideo = null;\r\n    Component localVideo = null;\r\n    if (videoTelephony != null) {\r\n        List<Component> remoteVideos = videoTelephony.getVisualComponents(callPeer);\r\n        if ((remoteVideos != null) && !remoteVideos.isEmpty()) {\r\n            remoteVideo = remoteVideos.get(0);\r\n        }\r\n        if (uiVideoHandler.isLocalVideoVisible()) {\r\n            try {\r\n                localVideo = videoTelephony.getLocalVisualComponent(callPeer);\r\n            } catch (OperationFailedException ofe) {\r\n                logger.warn(\"Failed to retrieve local video to be displayed.\", ofe);\r\n            }\r\n        }\r\n        boolean localVideoChanged = ((localVideo != this.localVideo) || ((localVideo != null) && !UIVideoHandler2.isAncestor(center, localVideo)));\r\n        boolean remoteVideoChanged = ((remoteVideo != this.remoteVideo) || ((remoteVideo != null) && !UIVideoHandler2.isAncestor(center, remoteVideo)));\r\n        if (remoteVideoChanged) {\r\n            if (desktopSharingMouseAndKeyboardListener != null) {\r\n                desktopSharingMouseAndKeyboardListener.setVideoComponent(remoteVideo);\r\n            }\r\n            CallPanel callPanel = callRenderer.getCallContainer();\r\n            if (remoteVideo != null) {\r\n                callPanel.addRemoteVideoSpecificComponents(callPeer);\r\n            } else {\r\n                callPanel.removeRemoteVideoSpecificComponents();\r\n            }\r\n        }\r\n        if (localVideoChanged || remoteVideoChanged) {\r\n            if (localVideoChanged && !remoteVideoChanged && (localVideo == null)) {\r\n                if (this.localVideo != null) {\r\n                    center.remove(this.localVideo);\r\n                    this.localVideo = null;\r\n                    if (closeLocalVisualComponentButton != null)\r\n                        center.remove(closeLocalVisualComponentButton);\r\n                }\r\n            } else {\r\n                center.removeAll();\r\n                this.localVideo = null;\r\n                this.remoteVideo = null;\r\n                if (localVideo != null) {\r\n                    if (closeLocalVisualComponentButton == null) {\r\n                        closeLocalVisualComponentButton = new CloseLocalVisualComponentButton(uiVideoHandler);\r\n                    }\r\n                    center.add(closeLocalVisualComponentButton, VideoLayout.CLOSE_LOCAL_BUTTON, -1);\r\n                    center.add(localVideo, VideoLayout.LOCAL, -1);\r\n                    this.localVideo = localVideo;\r\n                }\r\n                if (remoteVideo != null) {\r\n                    center.add(remoteVideo, VideoLayout.CENTER_REMOTE, -1);\r\n                    this.remoteVideo = remoteVideo;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.spellcheck.DocUnderliner.clearUnderlining",
	"Comment": "clears any underlining that spans to include the given range. sinceformatting is defined by ranges this will likely clear more than thedefined range.",
	"Method": "void clearUnderlining(int start,int end){\r\n    if (end > start) {\r\n        if (this.isEnabled) {\r\n            for (Highlighter.Highlight highlight : this.docHighlighter.getHighlights()) {\r\n                if ((highlight.getStartOffset() <= start && highlight.getEndOffset() > start) || (highlight.getStartOffset() < end && highlight.getEndOffset() >= end)) {\r\n                    this.docHighlighter.removeHighlight(highlight);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.SecurityAccountRegistration.setEncryptionProtocolStatus",
	"Comment": "sets the map between the encryption protocols and their status.",
	"Method": "void setEncryptionProtocolStatus(Map<String, Boolean> encryptionProtocolStatus){\r\n    this.encryptionProtocolStatus = encryptionProtocolStatus;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.aimaccregwizz.AimAccountRegistrationWizard.getPageImage",
	"Comment": "implements the accountregistrationwizard.getpageimagemethod. returns the image used to decorate the wizard page",
	"Method": "byte[] getPageImage(){\r\n    return Resources.getImage(Resources.PAGE_IMAGE);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomIrcImpl.fireMemberPropertyChangeEvent",
	"Comment": "delivers the specified event to all registered property change listeners.",
	"Method": "void fireMemberPropertyChangeEvent(ChatRoomMemberPropertyChangeEvent evt){\r\n    Iterable<ChatRoomMemberPropertyChangeListener> listeners;\r\n    synchronized (memberPropChangeListeners) {\r\n        listeners = new ArrayList<ChatRoomMemberPropertyChangeListener>(memberPropChangeListeners);\r\n    }\r\n    for (ChatRoomMemberPropertyChangeListener listener : listeners) {\r\n        listener.chatRoomPropertyChanged(evt);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.TransportManagerJabberImpl.doCreateStreamConnector",
	"Comment": "creates a media streamconnector for a stream of a specificmediatype. the minimum and maximum of the media port boundariesare taken into account.",
	"Method": "StreamConnector doCreateStreamConnector(MediaType mediaType){\r\n    return super.createStreamConnector(mediaType);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.ippiaccregwizz.IppiAccountRegistrationWizard.getPageImage",
	"Comment": "implements the accountregistrationwizard.getpageimage method.returns the image used to decorate the wizard page",
	"Method": "byte[] getPageImage(){\r\n    return IppiAccRegWizzActivator.getResources().getImageInBytes(PAGE_IMAGE);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallManager.getTelephonyConferencingProviders",
	"Comment": "returns a list of all currently registered telephony providers supportingconferencing.",
	"Method": "List<ProtocolProviderService> getTelephonyConferencingProviders(){\r\n    return AccountUtils.getRegisteredProviders(OperationSetTelephonyConferencing.class);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockChatRoom.isSystem",
	"Comment": "returns true if this chat room is a system room andfalse otherwise.",
	"Method": "boolean isSystem(){\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.login.LoginRendererSwingImpl.startConnectingUI",
	"Comment": "starts the connecting user interface for the given protocol provider.",
	"Method": "void startConnectingUI(ProtocolProviderService protocolProvider){\r\n    mainFrame.getAccountStatusPanel().startConnecting(protocolProvider);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.GroupRightButtonMenu.pluginComponentRemoved",
	"Comment": "indicates that a new plugin component has been removed. removes it tofrom this container if it belongs to it.",
	"Method": "void pluginComponentRemoved(PluginComponentEvent event){\r\n    PluginComponentFactory factory = event.getPluginComponentFactory();\r\n    if (factory.getContainer().equals(Container.CONTAINER_GROUP_RIGHT_BUTTON_MENU)) {\r\n        this.remove((Component) factory.getPluginComponentInstance(this).getComponent());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.presence.AbstractStatusMessageMenu.getLastCustomStatusMessageIndex",
	"Comment": "searches for custom messages in configuration service andgets the highest index.",
	"Method": "int getLastCustomStatusMessageIndex(){\r\n    int ix = -1;\r\n    java.util.List<String> customMessagesProps = DesktopUtilActivator.getConfigurationService().getPropertyNamesByPrefix(CUSTOM_MESSAGES_PREFIX, false);\r\n    int prefixLen = CUSTOM_MESSAGES_PREFIX.length() + 1;\r\n    for (String p : customMessagesProps) {\r\n        if (prefixLen > p.length())\r\n            continue;\r\n        String s = p.substring(prefixLen);\r\n        try {\r\n            int i = Integer.parseInt(s);\r\n            if (i > ix)\r\n                ix = i;\r\n        } catch (Throwable t) {\r\n        }\r\n    }\r\n    return ix;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.whiteboard.gui.whiteboardshapes.WhiteboardShapeRect.setFill",
	"Comment": "sets the fill state of the whiteboardshaperect.true is filled, false is unfilled.",
	"Method": "void setFill(boolean fill){\r\n    this.fill = fill;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetMultiUserChatJabberImpl.subscriptionCreated",
	"Comment": "updates corresponding chat room members when a contact has been created in our contact list.",
	"Method": "void subscriptionCreated(SubscriptionEvent evt){\r\n    Contact createdContact = evt.getSourceContact();\r\n    this.updateChatRoomMembers(createdContact);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.IceUdpTransportPacketExtension.cloneTransportAndCandidates",
	"Comment": "clones a specific iceudptransportpacketextension and itscandidates.",
	"Method": "IceUdpTransportPacketExtension cloneTransportAndCandidates(IceUdpTransportPacketExtension src,IceUdpTransportPacketExtension cloneTransportAndCandidates,IceUdpTransportPacketExtension src,boolean copyDtls){\r\n    if (src == null)\r\n        return null;\r\n    IceUdpTransportPacketExtension dst = AbstractPacketExtension.clone(src);\r\n    for (CandidatePacketExtension srcCand : src.getCandidateList()) {\r\n        if (!(srcCand instanceof RemoteCandidatePacketExtension))\r\n            dst.addCandidate(AbstractPacketExtension.clone(srcCand));\r\n    }\r\n    for (WebSocketPacketExtension wspe : src.getChildExtensionsOfType(WebSocketPacketExtension.class)) {\r\n        dst.addChildExtension(new WebSocketPacketExtension(wspe.getUrl()));\r\n    }\r\n    if (src.isRtcpMux()) {\r\n        dst.addChildExtension(new RtcpmuxPacketExtension());\r\n    }\r\n    if (copyDtls) {\r\n        for (DtlsFingerprintPacketExtension dtlsFingerprint : src.getChildExtensionsOfType(DtlsFingerprintPacketExtension.class)) {\r\n            DtlsFingerprintPacketExtension copy = new DtlsFingerprintPacketExtension();\r\n            copy.setFingerprint(dtlsFingerprint.getFingerprint());\r\n            copy.setHash(dtlsFingerprint.getHash());\r\n            copy.setRequired(dtlsFingerprint.getRequired());\r\n            copy.setSetup(dtlsFingerprint.getSetup());\r\n            dst.addChildExtension(copy);\r\n        }\r\n    }\r\n    return dst;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.TestOperationSetPresence.subtestQueryContactStatus",
	"Comment": "used by functions testing the querycontactstatus method of thepresence operation set.",
	"Method": "void subtestQueryContactStatus(String status,String expectedReturn){\r\n    operationSetPresence2.publishPresenceStatus(supportedStatusSet2.get(status), \"status message\");\r\n    pauseAfterStateChanges();\r\n    PresenceStatus actualReturn = operationSetPresence1.queryContactStatus(fixture.userID2);\r\n    assertEquals(\"Querying a \" + expectedReturn + \" state did not return as expected\", supportedStatusSet1.get(expectedReturn), actualReturn);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.TreeContactList.removeContactSource",
	"Comment": "removes the given contact source from the list of available contactsources.",
	"Method": "void removeContactSource(ContactSourceService contactSource){\r\n    Iterator<UIContactSource> extSourcesIter = contactSources.iterator();\r\n    while (extSourcesIter.hasNext()) {\r\n        UIContactSource extSource = extSourcesIter.next();\r\n        if (extSource.getContactSourceService().equals(contactSource)) {\r\n            contactSources.remove(extSource);\r\n            break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetDesktopStreamingJabberImpl.createVideoCall",
	"Comment": "create a new video call and invite the specified callpeer to it.",
	"Method": "Call createVideoCall(String uri,MediaDevice mediaDevice,Call createVideoCall,Contact callee,MediaDevice mediaDevice,Call createVideoCall,String uri,Call createVideoCall,Contact callee){\r\n    return createVideoCall(callee.getAddress());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.history.DatesPanel.valueChanged",
	"Comment": "implements the listselectionlistener.valuechanged.shows all history records for the selected date.",
	"Method": "void valueChanged(ListSelectionEvent e){\r\n    synchronized (listModel) {\r\n        int selectedIndex = this.datesList.getSelectedIndex();\r\n        if (selectedIndex != -1 && lastSelectedIndex != selectedIndex) {\r\n            this.setLastSelectedIndex(selectedIndex);\r\n            Date date = (Date) this.listModel.get(selectedIndex);\r\n            this.historyWindow.showHistoryByPeriod(date, historyWindow.getNextDateFromHistory(date));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.msoutlook.calendar.CalendarItemTimerTask.setPattern",
	"Comment": "sets the recurringpattern associated with the calendar item.",
	"Method": "void setPattern(RecurringPattern pattern){\r\n    this.pattern = pattern;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.EncodingsRegistrationUtil.storeProperties",
	"Comment": "stores encoding configuration properties in given propertiesmap.",
	"Method": "void storeProperties(Map<String, String> propertiesMap){\r\n    propertiesMap.put(ProtocolProviderFactory.OVERRIDE_ENCODINGS, Boolean.toString(isOverrideEncodings()));\r\n    propertiesMap.putAll(getEncodingProperties());\r\n}"
}, {
	"Path": "stack.MyQueue.pop",
	"Comment": "removes the element from in front of queue and returns that element.",
	"Method": "int pop(){\r\n    Stack<Integer> auxStack = new Stack();\r\n    while (!stack.isEmpty()) {\r\n        auxStack.push(stack.pop());\r\n    }\r\n    int result = auxStack.pop();\r\n    while (!auxStack.isEmpty()) {\r\n        stack.push(auxStack.pop());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.whiteboard.gui.WhiteboardFrame.setActualBoundry",
	"Comment": "calculate the new values for the global varibles drawx and drawyaccording to the new positions of the mouse cursor.",
	"Method": "void setActualBoundry(){\r\n    if (mouseX < originX || mouseY < originY) {\r\n        if (mouseX < originX) {\r\n            originWidth = originX - mouseX;\r\n            drawX = originX - originWidth;\r\n        } else {\r\n            drawX = originX;\r\n            originWidth = mouseX - originX;\r\n        }\r\n        if (mouseY < originY) {\r\n            originHeight = originY - mouseY;\r\n            drawY = originY - originHeight;\r\n        } else {\r\n            drawY = originY;\r\n            originHeight = mouseY - originY;\r\n        }\r\n    } else {\r\n        drawX = originX;\r\n        drawY = originY;\r\n        originWidth = mouseX - originX;\r\n        originHeight = mouseY - originY;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetPersistentPresenceJabberImpl.jabberStatusToPresenceStatus",
	"Comment": "converts the specified jabber status to one of the status fields of thejabberstatusenum class.",
	"Method": "PresenceStatus jabberStatusToPresenceStatus(Presence presence,ProtocolProviderServiceJabberImpl jabberProvider){\r\n    JabberStatusEnum jabberStatusEnum = jabberProvider.getJabberStatusEnum();\r\n    if (presence.getMode() == null && presence.isAvailable())\r\n        return jabberStatusEnum.getStatus(JabberStatusEnum.AVAILABLE);\r\n    else if (presence.getMode() == null && !presence.isAvailable())\r\n        return jabberStatusEnum.getStatus(JabberStatusEnum.OFFLINE);\r\n    Presence.Mode mode = presence.getMode();\r\n    if (mode.equals(Presence.Mode.available))\r\n        return jabberStatusEnum.getStatus(JabberStatusEnum.AVAILABLE);\r\n    else if (mode.equals(Presence.Mode.away)) {\r\n        if (presence.getStatus() != null && presence.getStatus().contains(JabberStatusEnum.ON_THE_PHONE))\r\n            return jabberStatusEnum.getStatus(JabberStatusEnum.ON_THE_PHONE);\r\n        else if (presence.getStatus() != null && presence.getStatus().contains(JabberStatusEnum.IN_A_MEETING))\r\n            return jabberStatusEnum.getStatus(JabberStatusEnum.IN_A_MEETING);\r\n        else\r\n            return jabberStatusEnum.getStatus(JabberStatusEnum.AWAY);\r\n    } else if (mode.equals(Presence.Mode.chat))\r\n        return jabberStatusEnum.getStatus(JabberStatusEnum.FREE_FOR_CHAT);\r\n    else if (mode.equals(Presence.Mode.dnd))\r\n        return jabberStatusEnum.getStatus(JabberStatusEnum.DO_NOT_DISTURB);\r\n    else if (mode.equals(Presence.Mode.xa))\r\n        return jabberStatusEnum.getStatus(JabberStatusEnum.EXTENDED_AWAY);\r\n    else {\r\n        if (presence.isAway())\r\n            return jabberStatusEnum.getStatus(JabberStatusEnum.AWAY);\r\n        if (presence.isAvailable())\r\n            return jabberStatusEnum.getStatus(JabberStatusEnum.AVAILABLE);\r\n        return jabberStatusEnum.getStatus(JabberStatusEnum.OFFLINE);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.UriHandlerJabberImpl.registerHandlerService",
	"Comment": "registers this urihandler with the bundle context so that it could starthandling uris",
	"Method": "void registerHandlerService(){\r\n    synchronized (registrationLock) {\r\n        if (ourServiceRegistration != null) {\r\n            return;\r\n        }\r\n        Hashtable<String, String> registrationProperties = new Hashtable<String, String>();\r\n        for (String protocol : getProtocol()) {\r\n            registrationProperties.put(UriHandler.PROTOCOL_PROPERTY, protocol);\r\n        }\r\n        ourServiceRegistration = JabberActivator.bundleContext.registerService(UriHandler.class.getName(), this, registrationProperties);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ContactListPane.fileTransferRequestReceived",
	"Comment": "when a request has been received we show it to the user through thechat session renderer.",
	"Method": "void fileTransferRequestReceived(FileTransferRequestEvent event){\r\n    IncomingFileTransferRequest request = event.getRequest();\r\n    Contact sourceContact = request.getSender();\r\n    MetaContact metaContact = GuiActivator.getContactListService().findMetaContactByContact(sourceContact);\r\n    final ChatPanel chatPanel = chatWindowManager.getContactChat(metaContact, sourceContact);\r\n    chatPanel.addIncomingFileTransferRequest(event.getFileTransferOperationSet(), request, event.getTimestamp());\r\n    ChatTransport chatTransport = chatPanel.getChatSession().findChatTransportForDescriptor(sourceContact, null);\r\n    chatPanel.setSelectedChatTransport(chatTransport, true);\r\n    chatWindowManager.openChat(chatPanel, false);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.chatalerter.ChatAlerterActivator.incomingCallReceived",
	"Comment": "this method is called by a protocol provider whenever an incoming call isreceived.",
	"Method": "void incomingCallReceived(CallEvent event){\r\n    Call call = event.getSourceCall();\r\n    Iterator<? extends CallPeer> peerIter = call.getCallPeers();\r\n    boolean alert = false;\r\n    while (peerIter.hasNext()) {\r\n        CallPeer peer = peerIter.next();\r\n        if (CallPeerState.INCOMING_CALL.equals(peer.getState())) {\r\n            alert = true;\r\n            break;\r\n        }\r\n    }\r\n    if (alert)\r\n        alertWindow(ExportedWindow.MAIN_WINDOW);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.growlnotification.GrowlNotificationServiceImpl.getPreferenceIndex",
	"Comment": "implements getpreferenceindex from popupmessagehandler.this handler is able to show images, detect clicks, match a click to amessage, and use a native popup mechanism, thus the index is 4.",
	"Method": "int getPreferenceIndex(){\r\n    return 4;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.JingleNodesCandidateDatagramSocket.getLocalPort",
	"Comment": "returns the port number on the local host to which this socket is bound.jinglenodescandidatedatagramsocket returns the port ofits localsocketaddress.",
	"Method": "int getLocalPort(){\r\n    return getLocalSocketAddress().getPort();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.whiteboard.gui.whiteboardshapes.WhiteboardShapePolyLine.getPoints",
	"Comment": "returns a list of all the whiteboardpoint instances that thiswhiteboardobject is composed of.",
	"Method": "List<WhiteboardPoint> getPoints(){\r\n    return points;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.dns.SecureMessage.getBogusReason",
	"Comment": "if the result is bogus this contains a string that describes the failure.",
	"Method": "String getBogusReason(){\r\n    return bogusReason;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.configuration.TestConfigurationService.testSetGetProperty",
	"Comment": "tests whether setting and getting properties works correctly.",
	"Method": "void testSetGetProperty(){\r\n    String propertyName = \"my.test.property\";\r\n    Object property = new String(\"my.test.property's value\");\r\n    configurationService.setProperty(propertyName, property);\r\n    Object actualReturn = configurationService.getProperty(propertyName);\r\n    assertEquals(\"a property was not properly stored\", property, actualReturn);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.whiteboard.Resources.getMnemonic",
	"Comment": "returns an internationalized string corresponding to the given key.",
	"Method": "char getMnemonic(String key){\r\n    return getResources().getI18nMnemonic(key);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.Call.addCallChangeListener",
	"Comment": "adds a call change listener to this call so that it could receive eventson new call peers, theme changes and others.",
	"Method": "void addCallChangeListener(CallChangeListener listener){\r\n    synchronized (callListeners) {\r\n        if (!callListeners.contains(listener))\r\n            callListeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.httputil.HttpUtilActivator.getCredentialsService",
	"Comment": "returns a reference to a credentialsstorageconfigurationserviceimplementation currently registered in the bundle context or null if nosuch implementation was found.",
	"Method": "CredentialsStorageService getCredentialsService(){\r\n    if (credentialsService == null) {\r\n        ServiceReference confReference = bundleContext.getServiceReference(CredentialsStorageService.class.getName());\r\n        credentialsService = (CredentialsStorageService) bundleContext.getService(confReference);\r\n    }\r\n    return credentialsService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.sysactivity.SysActivityActivator.getSystemActivityService",
	"Comment": "returns a reference to the bundle context that we were started with.",
	"Method": "SystemActivityNotificationsServiceImpl getSystemActivityService(){\r\n    return sysActivitiesServiceImpl;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.CallPeerState.getLocalizedStateString",
	"Comment": "returns a localized string representation of the callpeerstate.",
	"Method": "String getLocalizedStateString(){\r\n    return callStateLocalizedStr;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.credentialsstorage.TestCredentialsStorageService.testIsUsingMasterPassword",
	"Comment": "tests whether the service knows that we are using a master password.",
	"Method": "void testIsUsingMasterPassword(){\r\n    boolean isUsing = credentialsService.isUsingMasterPassword();\r\n    assertTrue(\"Master password is used, true expected\", isUsing);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.ZrtpHashPacketExtension.setValue",
	"Comment": "sets the value of the zrtp hash this element will be carrying.",
	"Method": "void setValue(String value){\r\n    setText(value);\r\n}"
}, {
	"Path": "net.librec.eval.ranking.EntropyEvaluator.evaluate",
	"Comment": "evaluate on the test set with the the list of recommended items.",
	"Method": "double evaluate(RecommendedList groundTruthList,RecommendedList recommendedList){\r\n    int numUsers = groundTruthList.size();\r\n    int numItems = conf.getInt(\"rec.eval.item.num\");\r\n    int[] itemCounts = new int[numItems];\r\n    for (int contextIdx = 0; contextIdx < numUsers; contextIdx++) {\r\n        List<KeyValue<Integer, Double>> recoList = recommendedList.getKeyValueListByContext(contextIdx);\r\n        int topK = this.topN <= recoList.size() ? this.topN : recoList.size();\r\n        for (int recoIdx = 0; recoIdx < topK; recoIdx++) {\r\n            itemCounts[recoList.get(recoIdx).getKey()]++;\r\n        }\r\n    }\r\n    double sumEntropy = 0;\r\n    for (int count : itemCounts) {\r\n        if (count > 0) {\r\n            double estmProbability = ((double) count) / numUsers;\r\n            sumEntropy += estmProbability * (-Math.log(estmProbability));\r\n        }\r\n    }\r\n    return sumEntropy / Math.log(2);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.IrcStack.connectionInterrupted",
	"Comment": "event for any kind of connection interruption, including normal quitevents.",
	"Method": "void connectionInterrupted(IrcConnection connection){\r\n    if (this.session.get() != connection) {\r\n        LOGGER.debug(\"Interrupted connection is not the current connection\" + \", so assuming that connection interruption was intended.\");\r\n        return;\r\n    }\r\n    LOGGER.warn(\"IRC connection interrupted unexpectedly.\");\r\n    this.provider.setCurrentRegistrationState(RegistrationState.CONNECTION_FAILED, RegistrationStateChangeEvent.REASON_NOT_SPECIFIED);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.TestOperationSetPersistentPresence.postTestRemoveGroup",
	"Comment": "removes the group created in the server stored contact list by the creategroup test, makes sure that the corresponding event has been generatedand verifies that the group is not in the list any more.",
	"Method": "void postTestRemoveGroup(){\r\n    logger.trace(\"testing removal of server stored groups\");\r\n    GroupChangeCollector groupChangeCollector = new GroupChangeCollector();\r\n    opSetPersPresence.addServerStoredGroupChangeListener(groupChangeCollector);\r\n    try {\r\n        opSetPersPresence.removeServerStoredContactGroup(opSetPersPresence.getServerStoredContactListRoot().getGroup(testGroupName2));\r\n    } catch (OperationFailedException ex) {\r\n        logger.error(\"error removing group\", ex);\r\n    }\r\n    groupChangeCollector.waitForEvent(10000);\r\n    opSetPersPresence.removeServerStoredGroupChangeListener(groupChangeCollector);\r\n    assertEquals(\"Collected Group Change event\", 1, groupChangeCollector.collectedEvents.size());\r\n    assertEquals(\"Group name.\", testGroupName2, ((ServerStoredGroupEvent) groupChangeCollector.collectedEvents.get(0)).getSourceGroup().getGroupName());\r\n    ContactGroup group = opSetPersPresence.getServerStoredContactListRoot().getGroup(testGroupName2);\r\n    assertNull(\"A freshly removed group was still on the contact list.\", group);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.sip.TestOperationSetBasicTelephonySipImpl.aTestCreateAnswerHangupCall",
	"Comment": "creates a call from provider1 to provider2, makes provider2 answer itand then reject it.",
	"Method": "void aTestCreateAnswerHangupCall(){\r\n    OperationSetBasicTelephony<?> basicTelephonyP1 = fixture.provider1.getOperationSet(OperationSetBasicTelephony.class);\r\n    OperationSetBasicTelephony<?> basicTelephonyP2 = fixture.provider2.getOperationSet(OperationSetBasicTelephony.class);\r\n    CallEventCollector call1Listener = new CallEventCollector(basicTelephonyP1);\r\n    CallEventCollector call2Listener = new CallEventCollector(basicTelephonyP2);\r\n    String provider2Address = fixture.provider2.getAccountID().getAccountAddress();\r\n    Call callAtP1 = basicTelephonyP1.createCall(provider2Address);\r\n    call1Listener.waitForEvent(10000);\r\n    call2Listener.waitForEvent(10000);\r\n    assertEquals(\"The provider that created the call did not dispatch \" + \"an event that it has done so.\", 1, call1Listener.collectedEvents.size());\r\n    CallEvent callCreatedEvent = (CallEvent) call1Listener.collectedEvents.get(0);\r\n    assertEquals(\"CallEvent.getEventID()\", CallEvent.CALL_INITIATED, callCreatedEvent.getEventID());\r\n    assertSame(\"CallEvent.getSource()\", callAtP1, callCreatedEvent.getSource());\r\n    assertTrue(\"The callee provider did not receive a call or did \" + \"not issue an event.\", call2Listener.collectedEvents.size() > 0);\r\n    CallEvent callReceivedEvent = (CallEvent) call2Listener.collectedEvents.get(0);\r\n    Call callAtP2 = callReceivedEvent.getSourceCall();\r\n    assertEquals(\"CallEvent.getEventID()\", CallEvent.CALL_RECEIVED, callReceivedEvent.getEventID());\r\n    assertNotNull(\"CallEvent.getSource()\", callAtP2);\r\n    assertEquals(\"callAtP1.getCallpeersCount()\", 1, callAtP1.getCallPeerCount());\r\n    assertEquals(\"callAtP2.getCallpeersCount()\", 1, callAtP2.getCallPeerCount());\r\n    CallPeer peerAtP1 = callAtP1.getCallPeers().next();\r\n    CallPeer peerAtP2 = callAtP2.getCallPeers().next();\r\n    CallPeerStateEventCollector stateCollectorForPp1 = new CallPeerStateEventCollector(peerAtP1, CallPeerState.ALERTING_REMOTE_SIDE);\r\n    CallPeerStateEventCollector stateCollectorForPp2 = new CallPeerStateEventCollector(peerAtP2, CallPeerState.INCOMING_CALL);\r\n    stateCollectorForPp1.waitForEvent(10000, true);\r\n    stateCollectorForPp2.waitForEvent(10000, true);\r\n    assertSame(\"peerAtP1.getCall\", peerAtP1.getCall(), callAtP1);\r\n    assertSame(\"peerAtP2.getCall\", peerAtP2.getCall(), callAtP2);\r\n    assertEquals(\"The peer at provider one was not in the \" + \"right state.\", CallPeerState.ALERTING_REMOTE_SIDE, peerAtP1.getState());\r\n    assertEquals(\"The peer at provider two was not in the \" + \"right state.\", CallPeerState.INCOMING_CALL, peerAtP2.getState());\r\n    if (Boolean.getBoolean(\"accounts.sip.PRESERVE_PEER_INFO\")) {\r\n        String expectedPeer1Address = fixture.provider2.getAccountID().getAccountAddress();\r\n        String expectedPeer1DisplayName = System.getProperty(SipProtocolProviderServiceLick.ACCOUNT_2_PREFIX + ProtocolProviderFactory.DISPLAY_NAME);\r\n        assertTrue(\"Provider 2 did not advertise their \" + \"accountID.getAccoutAddress() address.\", expectedPeer1Address.indexOf(peerAtP1.getAddress()) != -1 || peerAtP1.getAddress().indexOf(expectedPeer1Address) != -1);\r\n        assertEquals(\"Provider 2 did not properly advertise their \" + \"display name.\", expectedPeer1DisplayName, peerAtP1.getDisplayName());\r\n        String expectedPeer2Address = fixture.provider1.getAccountID().getAccountAddress();\r\n        String expectedPeer2DisplayName = System.getProperty(SipProtocolProviderServiceLick.ACCOUNT_1_PREFIX + ProtocolProviderFactory.DISPLAY_NAME);\r\n        assertTrue(\"Provider 1 did not advertise their \" + \"accountID.getAccoutAddress() address.\", expectedPeer2Address.indexOf(peerAtP2.getAddress()) != -1 || peerAtP2.getAddress().indexOf(expectedPeer2Address) != -1);\r\n        assertEquals(\"Provider 1 did not properly advertise their \" + \"display name.\", expectedPeer2DisplayName, peerAtP2.getDisplayName());\r\n    }\r\n    stateCollectorForPp1 = new CallPeerStateEventCollector(peerAtP1, CallPeerState.CONNECTED);\r\n    stateCollectorForPp2 = new CallPeerStateEventCollector(peerAtP2, CallPeerState.CONNECTED);\r\n    basicTelephonyP2.answerCallPeer(peerAtP2);\r\n    stateCollectorForPp1.waitForEvent(10000);\r\n    stateCollectorForPp2.waitForEvent(10000);\r\n    assertEquals(\"The peer at provider one was not in the \" + \"right state.\", CallPeerState.CONNECTED, peerAtP1.getState());\r\n    assertEquals(\"The peer at provider two was not in the \" + \"right state.\", CallPeerState.CONNECTED, peerAtP2.getState());\r\n    assertEquals(\"No event was dispatched when a call peer changed \" + \"its state.\", 1, stateCollectorForPp1.collectedEvents.size());\r\n    assertEquals(\"No event was dispatched when a call peer changed \" + \"its state.\", 1, stateCollectorForPp2.collectedEvents.size());\r\n    stateCollectorForPp1 = new CallPeerStateEventCollector(peerAtP1, CallPeerState.DISCONNECTED);\r\n    stateCollectorForPp2 = new CallPeerStateEventCollector(peerAtP2, CallPeerState.DISCONNECTED);\r\n    basicTelephonyP2.hangupCallPeer(peerAtP2);\r\n    stateCollectorForPp1.waitForEvent(10000);\r\n    stateCollectorForPp2.waitForEvent(10000);\r\n    assertEquals(\"The peer at provider one was not in the \" + \"right state.\", CallPeerState.DISCONNECTED, peerAtP1.getState());\r\n    assertEquals(\"The peer at provider two was not in the \" + \"right state.\", CallPeerState.DISCONNECTED, peerAtP2.getState());\r\n    assertEquals(\"a provider did not distribute an event when a call \" + \"peer changed states.\", 1, stateCollectorForPp1.collectedEvents.size());\r\n    assertEquals(\"a provider did not distribute an event when a call \" + \"peer changed states.\", 1, stateCollectorForPp2.collectedEvents.size());\r\n}"
}, {
	"Path": "net.librec.math.algorithm.Randoms.exp",
	"Comment": "return a real number from an exponential distribution with rate lambda.",
	"Method": "double exp(double lambda){\r\n    return -Math.log(1 - uniform()) / lambda;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetBasicTelephonyJabberImpl.answerCallPeer",
	"Comment": "implements method answercallpeerfrom operationsetbasictelephony.",
	"Method": "void answerCallPeer(CallPeer peer){\r\n    if (peer instanceof CallPeerJabberImpl)\r\n        ((CallPeerJabberImpl) peer).answer();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.EventPackageUtils.isByeProcessed",
	"Comment": "determines whether a bye request has already been processed in a specificdialog and thus allows determining whether the dialog inquestion should be terminated when the last associated subscription isterminated.",
	"Method": "boolean isByeProcessed(Dialog dialog,boolean isByeProcessed){\r\n    synchronized (dialog) {\r\n        DialogApplicationData applicationData = (DialogApplicationData) SipApplicationData.getApplicationData(dialog, SipApplicationData.KEY_SUBSCRIPTIONS);\r\n        return (applicationData == null) ? false : applicationData.isByeProcessed();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.ProtocolMediaActivator.getBundleContext",
	"Comment": "returns a reference to the bundle context that we were started with.",
	"Method": "BundleContext getBundleContext(){\r\n    return bundleContext;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatSession.isContactListSupported",
	"Comment": "indicates if the contact list is supported by this session. the contactlist would be supported for all non system and non private sessions.",
	"Method": "boolean isContactListSupported(){\r\n    ChatRoom chatRoom = chatRoomWrapper.getChatRoom();\r\n    return !chatRoom.isSystem() && !MUCService.isPrivate(chatRoom);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.CallPeerSecurityMessageEvent.getI18nMessage",
	"Comment": "returns the internationalized message associated with this event.",
	"Method": "String getI18nMessage(){\r\n    return eventI18nMessage;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.GuiActivator.setContactList",
	"Comment": "sets the contactlist component currently used to show thecontact list.",
	"Method": "void setContactList(TreeContactList list){\r\n    contactList = list;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.ExtendedTooltip.setTitle",
	"Comment": "sets the title of the tooltip. the text would be shown in bold on the topof the tooltip panel.",
	"Method": "void setTitle(String titleText){\r\n    titleLabel.setText(titleText);\r\n    Dimension labelSize = ComponentUtils.getStringSize(titleLabel, titleText);\r\n    recalculateTooltipSize(labelSize.width, labelSize.height);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.ResizeVideoButton.createResizeVideoMenu",
	"Comment": "creates the menu responsible for desktop sharing when a single desktopsharing contact is available.",
	"Method": "JPopupMenu createResizeVideoMenu(){\r\n    final JPopupMenu popupMenu = new JPopupMenu(GuiActivator.getResources().getI18NString(\"service.gui.CHANGE_VIDEO_QUALITY\"));\r\n    popupMenu.setInvoker(this);\r\n    popupMenu.setFocusable(true);\r\n    Dimension loDimension = QualityPreset.LO_QUALITY.getResolution();\r\n    Dimension sdDimension = QualityPreset.SD_QUALITY.getResolution();\r\n    Dimension hdDimension = QualityPreset.HD_QUALITY.getResolution();\r\n    JMenuItem lowQuality = new JMenuItem(GuiActivator.getResources().getI18NString(\"service.gui.LOW_QUALITY\") + getFormattedDimension(loDimension), GuiActivator.getResources().getImage(\"service.gui.icons.LO_VIDEO_ICON\"));\r\n    JMenuItem normalQuality = new JMenuItem(GuiActivator.getResources().getI18NString(\"service.gui.SD_QUALITY\") + getFormattedDimension(sdDimension), GuiActivator.getResources().getImage(\"service.gui.icons.SD_VIDEO_ICON\"));\r\n    JMenuItem hdQuality = new JMenuItem(GuiActivator.getResources().getI18NString(\"service.gui.HD_QUALITY\") + getFormattedDimension(hdDimension), GuiActivator.getResources().getImage(\"service.gui.icons.HD_VIDEO_ICON\"));\r\n    JLabel titleLabel = new JLabel(GuiActivator.getResources().getI18NString(\"service.gui.CHANGE_VIDEO_QUALITY\"));\r\n    titleLabel.setFont(titleLabel.getFont().deriveFont(Font.BOLD));\r\n    titleLabel.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 0));\r\n    popupMenu.add(titleLabel);\r\n    popupMenu.addSeparator();\r\n    if (hdOptionPresent)\r\n        popupMenu.add(hdQuality);\r\n    if (sdOptionPresent)\r\n        popupMenu.add(normalQuality);\r\n    if (loOptionPresent)\r\n        popupMenu.add(lowQuality);\r\n    lowQuality.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent e) {\r\n            popupMenu.setVisible(false);\r\n            setIconImageID(ImageLoader.LO_VIDEO_BUTTON);\r\n            CallManager.setVideoQualityPreset(call.getCallPeers().next(), QualityPreset.LO_QUALITY);\r\n        }\r\n    });\r\n    normalQuality.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent e) {\r\n            popupMenu.setVisible(false);\r\n            setIconImageID(ImageLoader.SD_VIDEO_BUTTON);\r\n            CallManager.setVideoQualityPreset(call.getCallPeers().next(), QualityPreset.SD_QUALITY);\r\n        }\r\n    });\r\n    hdQuality.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent e) {\r\n            popupMenu.setVisible(false);\r\n            setIconImageID(ImageLoader.HD_VIDEO_BUTTON);\r\n            CallManager.setVideoQualityPreset(call.getCallPeers().next(), QualityPreset.HD_QUALITY);\r\n        }\r\n    });\r\n    return popupMenu;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.ResizeVideoButton.createResizeVideoMenu",
	"Comment": "creates the menu responsible for desktop sharing when a single desktopsharing contact is available.",
	"Method": "JPopupMenu createResizeVideoMenu(){\r\n    popupMenu.setVisible(false);\r\n    setIconImageID(ImageLoader.LO_VIDEO_BUTTON);\r\n    CallManager.setVideoQualityPreset(call.getCallPeers().next(), QualityPreset.LO_QUALITY);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.ResizeVideoButton.createResizeVideoMenu",
	"Comment": "creates the menu responsible for desktop sharing when a single desktopsharing contact is available.",
	"Method": "JPopupMenu createResizeVideoMenu(){\r\n    popupMenu.setVisible(false);\r\n    setIconImageID(ImageLoader.SD_VIDEO_BUTTON);\r\n    CallManager.setVideoQualityPreset(call.getCallPeers().next(), QualityPreset.SD_QUALITY);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.ResizeVideoButton.createResizeVideoMenu",
	"Comment": "creates the menu responsible for desktop sharing when a single desktopsharing contact is available.",
	"Method": "JPopupMenu createResizeVideoMenu(){\r\n    popupMenu.setVisible(false);\r\n    setIconImageID(ImageLoader.HD_VIDEO_BUTTON);\r\n    CallManager.setVideoQualityPreset(call.getCallPeers().next(), QualityPreset.HD_QUALITY);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.ExternalContactSource.getUIContact",
	"Comment": "returns the uicontact corresponding to the givensourcecontact.",
	"Method": "UIContact getUIContact(SourceContact sourceContact){\r\n    return (UIContact) sourceContact.getData(UI_CONTACT_DATA_KEY);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.MainFrame.hasProtocolProvider",
	"Comment": "checks whether we have already loaded the protocol provider.",
	"Method": "boolean hasProtocolProvider(ProtocolProviderService protocolProvider){\r\n    synchronized (this.protocolProviders) {\r\n        return this.protocolProviders.containsKey(protocolProvider);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.ShowMoreContact.getDefaultContactDetail",
	"Comment": "returns null to indicate that this contact has no contact details.",
	"Method": "UIContactDetail getDefaultContactDetail(Class<? extends OperationSet> opSetClass){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetContactCapabilitiesJabberImpl.userCapsNodeAdded",
	"Comment": "notifies this listener that an entitycapsmanager has added arecord for a specific user about the caps node the user has.",
	"Method": "void userCapsNodeAdded(String user,ArrayList<String> fullJids,String node,boolean online){\r\n    userCapsNodeChanged(user, fullJids, node, online);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaAwareCallPeer.securityTimeout",
	"Comment": "indicates that the other party has timeouted replying to ouroffer to secure the connection.",
	"Method": "void securityTimeout(MediaType mediaType){\r\n    fireCallPeerSecurityTimeoutEvent(new CallPeerSecurityTimeoutEvent(this, toSessionType(mediaType)));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.LoginByPasswordStrategy.loadPassword",
	"Comment": "load the password from the account configuration or ask the user.",
	"Method": "UserCredentials loadPassword(SecurityAuthority authority,int reasonCode){\r\n    UserCredentials cachedCredentials = null;\r\n    password = JabberActivator.getProtocolProviderFactory().loadPassword(accountID);\r\n    if (password == null) {\r\n        UserCredentials credentials = new UserCredentials();\r\n        credentials.setUserName(accountID.getUserID());\r\n        credentials = authority.obtainCredentials(accountID.getDisplayName(), credentials, reasonCode);\r\n        if (credentials == null) {\r\n            protocolProvider.fireRegistrationStateChanged(protocolProvider.getRegistrationState(), RegistrationState.UNREGISTERED, RegistrationStateChangeEvent.REASON_USER_REQUEST, \"No credentials provided\");\r\n            return null;\r\n        }\r\n        char[] pass = credentials.getPassword();\r\n        if (pass == null) {\r\n            protocolProvider.fireRegistrationStateChanged(protocolProvider.getRegistrationState(), RegistrationState.UNREGISTERED, RegistrationStateChangeEvent.REASON_USER_REQUEST, \"No password entered\");\r\n            return null;\r\n        }\r\n        password = new String(pass);\r\n        if (credentials.isPasswordPersistent()) {\r\n            JabberActivator.getProtocolProviderFactory().storePassword(accountID, password);\r\n        } else\r\n            cachedCredentials = credentials;\r\n    }\r\n    return cachedCredentials;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.MonitorPresenceWatcher.setUpMonitor",
	"Comment": "set up monitor based on the nick watch list in its current state.created a static method as not to interfere too much with a state that isstill being initialized.",
	"Method": "void setUpMonitor(IRCApi irc,Collection<String> nickWatchList,int maxListSize){\r\n    List<String> current;\r\n    synchronized (nickWatchList) {\r\n        current = new LinkedList<String>(nickWatchList);\r\n    }\r\n    if (current.size() > maxListSize) {\r\n        current = current.subList(0, maxListSize);\r\n    }\r\n    final int maxLength = 510 - MONITOR_ADD_CMD_STATIC_OVERHEAD;\r\n    final StringBuilder query = new StringBuilder();\r\n    for (String nick : current) {\r\n        if (query.length() + nick.length() + 1 > maxLength) {\r\n            irc.rawMessage(\"MONITOR + \" + query);\r\n            query.delete(0, query.length());\r\n        } else if (query.length() > 0) {\r\n            query.append(\",\");\r\n        }\r\n        query.append(nick);\r\n    }\r\n    if (query.length() > 0) {\r\n        irc.rawMessage(\"MONITOR + \" + query);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.TestOperationSetFileTransferImpl.prepareContactList",
	"Comment": "create the list to be sure that contacts exchanging messagesexists in each other lists",
	"Method": "void prepareContactList(){\r\n    if (getContact1() == null && getContact2() == null)\r\n        fixture.clearProvidersLists();\r\n    if (getContact1() == null) {\r\n        Object o = new Object();\r\n        synchronized (o) {\r\n            o.wait(2000);\r\n        }\r\n        try {\r\n            opSetPresence1.setAuthorizationHandler(new AuthHandler());\r\n            opSetPresence1.subscribe(fixture.userID2);\r\n        } catch (OperationFailedException ex) {\r\n        }\r\n    }\r\n    if (getContact2() == null) {\r\n        try {\r\n            opSetPresence2.setAuthorizationHandler(new AuthHandler());\r\n            opSetPresence2.subscribe(fixture.userID1);\r\n        } catch (OperationFailedException ex1) {\r\n        }\r\n        logger.info(\"will wait till the list prepare is completed\");\r\n        Object o = new Object();\r\n        synchronized (o) {\r\n            o.wait(4000);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.TestFileSessions.testInitialize",
	"Comment": "test that when it initializes, the filesessiondatastore deletes old expired sessions.",
	"Method": "void testInitialize(){\r\n    ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);\r\n    context.setContextPath(\"/\");\r\n    SessionDataStoreFactory factory = createSessionDataStoreFactory();\r\n    ((AbstractSessionDataStoreFactory) factory).setGracePeriodSec(10);\r\n    SessionDataStore store = factory.getSessionDataStore(context.getSessionHandler());\r\n    SessionContext sessionContext = new SessionContext(\"foo\", context.getServletContext());\r\n    store.initialize(sessionContext);\r\n    FileTestHelper.createFile(\"101_foobar_0.0.0.0_sessiona\");\r\n    FileTestHelper.assertSessionExists(\"sessiona\", true);\r\n    String nonExpiredForeign = (System.currentTimeMillis() + TimeUnit.DAYS.toMillis(1)) + \"_foobar_0.0.0.0_sessionb\";\r\n    FileTestHelper.createFile(nonExpiredForeign);\r\n    FileTestHelper.assertFileExists(nonExpiredForeign, true);\r\n    String expiredForeign = (System.currentTimeMillis() - TimeUnit.SECONDS.toMillis(1)) + \"_foobar_0.0.0.0_sessionc\";\r\n    FileTestHelper.createFile(expiredForeign);\r\n    FileTestHelper.assertFileExists(expiredForeign, true);\r\n    FileTestHelper.createFile(\"whatever.txt\");\r\n    FileTestHelper.assertFileExists(\"whatever.txt\", true);\r\n    FileTestHelper.createFile(\"nonNumber_0.0.0.0_spuriousFile\");\r\n    FileTestHelper.assertFileExists(\"nonNumber_0.0.0.0_spuriousFile\", true);\r\n    String nonExpired = (System.currentTimeMillis() + TimeUnit.DAYS.toMillis(1)) + \"_test_0.0.0.0_sessionb\";\r\n    FileTestHelper.createFile(nonExpired);\r\n    FileTestHelper.assertFileExists(nonExpired, true);\r\n    String neverExpired = \"0_test_0.0.0.0_sessionc\";\r\n    FileTestHelper.createFile(neverExpired);\r\n    FileTestHelper.assertFileExists(neverExpired, true);\r\n    String foreignNeverExpired = \"0_test_0.0.0.0_sessionc\";\r\n    FileTestHelper.createFile(foreignNeverExpired);\r\n    FileTestHelper.assertFileExists(foreignNeverExpired, true);\r\n    ((FileSessionDataStore) store).initializeStore();\r\n    FileTestHelper.assertSessionExists(\"sessiona\", false);\r\n    FileTestHelper.assertFileExists(\"whatever.txt\", true);\r\n    FileTestHelper.assertFileExists(\"nonNumber_0.0.0.0_spuriousFile\", true);\r\n    FileTestHelper.assertFileExists(nonExpired, true);\r\n    FileTestHelper.assertFileExists(nonExpiredForeign, true);\r\n    FileTestHelper.assertFileExists(expiredForeign, true);\r\n    FileTestHelper.assertFileExists(neverExpired, true);\r\n    FileTestHelper.assertFileExists(foreignNeverExpired, true);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.MoveSubcontactMessageDialog.setDialogLocation",
	"Comment": "computes the location of this dialog in order to show it on the leftor the right side of the main application window.",
	"Method": "void setDialogLocation(JFrame parentWindow){\r\n    int dialogY = (int) Toolkit.getDefaultToolkit().getScreenSize().getHeight() / 2 - dialogHeight / 2;\r\n    int parentX = parentWindow.getLocation().x;\r\n    if ((parentX - dialogWidth) > 0) {\r\n        this.setLocation(parentX - dialogWidth, dialogY);\r\n    } else {\r\n        this.setLocation(parentX + parentWindow.getWidth(), dialogY);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ProtocolIconIrcImpl.getImageInBytes",
	"Comment": "returns the byte representation of the image corresponding to the givenidentifier.",
	"Method": "byte[] getImageInBytes(String imageID){\r\n    InputStream in = IrcActivator.getResources().getImageInputStream(imageID);\r\n    byte[] image = null;\r\n    if (in != null) {\r\n        try {\r\n            image = new byte[in.available()];\r\n            in.read(image);\r\n        } catch (IOException e) {\r\n            LOGGER.error(\"Failed to load image:\" + imageID, e);\r\n        }\r\n    }\r\n    return image;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.googletalkaccregwizz.GoogleTalkAccountRegistrationWizard.getProtocolDescription",
	"Comment": "implements the accountregistrationwizard.getprotocoldescription method. returns the description of the protocol for this wizard.",
	"Method": "String getProtocolDescription(){\r\n    return GoogleTalkAccRegWizzActivator.getResources().getI18NString(\"plugin.googletalkaccregwizz.PROTOCOL_DESCRIPTION\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatSession.loadChatRoom",
	"Comment": "loads the given chat room in the this chat conference panel. loads allmembers and adds all corresponding listeners.",
	"Method": "void loadChatRoom(ChatRoom chatRoom){\r\n    currentChatTransport = new ConferenceChatTransport(this, chatRoomWrapper.getChatRoom());\r\n    chatTransports.clear();\r\n    chatTransports.add(currentChatTransport);\r\n    synchronized (this.chatParticipants) {\r\n        sessionRenderer.removeAllChatContacts();\r\n        this.chatParticipants.clear();\r\n        for (ChatRoomMember member : chatRoom.getMembers()) {\r\n            ConferenceChatContact contact = new ConferenceChatContact(member);\r\n            chatParticipants.add(contact);\r\n            sessionRenderer.addChatContact(contact);\r\n        }\r\n    }\r\n    chatRoom.addPropertyChangeListener(this);\r\n    chatRoom.addMemberPresenceListener(this);\r\n    sessionRenderer.setChatSubject(chatRoom.getSubject());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl.queryTransportManager",
	"Comment": "returns the transport manager that is handling our address management.",
	"Method": "TransportManagerSipImpl queryTransportManager(){\r\n    return transportManager;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockProvider.getRegistrationState",
	"Comment": "mock implementation of the corresponding protocolproviderservice method.",
	"Method": "RegistrationState getRegistrationState(){\r\n    return RegistrationState.REGISTERED;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.UIServiceImpl.getBorderLayoutConstraintsFromContainer",
	"Comment": "returns the corresponding borderlayout constraint from the givencontainer constraint.",
	"Method": "Object getBorderLayoutConstraintsFromContainer(Object containerConstraints){\r\n    Object layoutConstraint = null;\r\n    if (containerConstraints == null)\r\n        return null;\r\n    if (containerConstraints.equals(Container.START))\r\n        layoutConstraint = BorderLayout.LINE_START;\r\n    else if (containerConstraints.equals(Container.END))\r\n        layoutConstraint = BorderLayout.LINE_END;\r\n    else if (containerConstraints.equals(Container.TOP))\r\n        layoutConstraint = BorderLayout.NORTH;\r\n    else if (containerConstraints.equals(Container.BOTTOM))\r\n        layoutConstraint = BorderLayout.SOUTH;\r\n    else if (containerConstraints.equals(Container.LEFT))\r\n        layoutConstraint = BorderLayout.WEST;\r\n    else if (containerConstraints.equals(Container.RIGHT))\r\n        layoutConstraint = BorderLayout.EAST;\r\n    return layoutConstraint;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetPersistentPresenceIcqImpl.getCurrentStatusMessage",
	"Comment": "returns the status message that was confirmed by the serfver",
	"Method": "String getCurrentStatusMessage(){\r\n    return this.currentStatusMessage;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.AbstractCallJabberGTalkImpl.getPeer",
	"Comment": "returns the peer whose corresponding session has the specifiedsid.",
	"Method": "T getPeer(String sid){\r\n    if (sid == null)\r\n        return null;\r\n    for (T peer : getCallPeerList()) {\r\n        if (sid.equals(peer.getSID()))\r\n            return peer;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomIrcImpl.sendMessage",
	"Comment": "sends the message to the destination indicated by theto contact.",
	"Method": "void sendMessage(Message message){\r\n    assertConnected();\r\n    String[] splitMessages = message.getContent().split(\"\\n\");\r\n    String messagePortion = null;\r\n    for (int i = 0; i < splitMessages.length; i++) {\r\n        messagePortion = splitMessages[i];\r\n        if (messagePortion.equals(\"\\n\") || messagePortion.matches(\"[\\\\ ]*\")) {\r\n            continue;\r\n        }\r\n        final IrcConnection connection = this.parentProvider.getIrcStack().getConnection();\r\n        if (connection == null) {\r\n            throw new IllegalStateException(\"Connection is not available.\");\r\n        }\r\n        if (((MessageIrcImpl) message).isCommand()) {\r\n            try {\r\n                connection.getMessageManager().command(this, messagePortion);\r\n                this.fireMessageReceivedEvent(message, this.user, new Date(), ChatRoomMessageReceivedEvent.SYSTEM_MESSAGE_RECEIVED);\r\n            } catch (final UnsupportedCommandException e) {\r\n                this.fireMessageDeliveryFailedEvent(ChatRoomMessageDeliveryFailedEvent.UNSUPPORTED_OPERATION, e.getMessage(), new Date(), message);\r\n            } catch (BadCommandException e) {\r\n                LOGGER.error(\"An error occurred while constructing \" + \"the command. This is most likely due to a bug \" + \"in the implementation of the command. Message: \" + message + \"'\", e);\r\n                this.fireMessageDeliveryFailedEvent(ChatRoomMessageDeliveryFailedEvent.INTERNAL_ERROR, \"Command cannot be executed. This is most likely due \" + \"to a bug in the implementation.\", new Date(), message);\r\n            } catch (BadCommandInvocationException e) {\r\n                StringBuilder helpText = new StringBuilder();\r\n                if (e.getCause() != null) {\r\n                    helpText.append(e.getCause().getMessage());\r\n                    helpText.append('\\n');\r\n                }\r\n                helpText.append(e.getHelp());\r\n                MessageIrcImpl helpMessage = new MessageIrcImpl(helpText.toString(), OperationSetBasicInstantMessaging.DEFAULT_MIME_TYPE, OperationSetBasicInstantMessaging.DEFAULT_MIME_ENCODING, \"Command usage:\");\r\n                this.fireMessageReceivedEvent(helpMessage, this.user, new Date(), MessageReceivedEvent.SYSTEM_MESSAGE_RECEIVED);\r\n            }\r\n        } else {\r\n            connection.getMessageManager().message(this, messagePortion);\r\n            this.fireMessageDeliveredEvent(new MessageIrcImpl(messagePortion, message.getContentType(), message.getEncoding(), message.getSubject()));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.IceConfigPanel.getJingleNodes",
	"Comment": "indicates if a jinglenodes with the given address already existsin the additional stun servers table.",
	"Method": "JingleNodeDescriptor getJingleNodes(String address){\r\n    for (int i = 0; i < jnTableModel.getRowCount(); i++) {\r\n        JingleNodeDescriptor jn = (JingleNodeDescriptor) jnTableModel.getValueAt(i, 0);\r\n        if (jn.getJID().equalsIgnoreCase(address))\r\n            return jn;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.SimpleStatusMenu.actionPerformed",
	"Comment": "handles the actionevent triggered when one of the items in thelist is selected.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    if (GuiActivator.getGlobalStatusService() == null)\r\n        return;\r\n    JMenuItem menuItem = (JMenuItem) e.getSource();\r\n    String itemName = menuItem.getName();\r\n    if (itemName.equals(GlobalStatusEnum.ONLINE_STATUS)) {\r\n        GuiActivator.getGlobalStatusService().publishStatus(protocolProvider, GlobalStatusEnum.ONLINE);\r\n    } else {\r\n        GuiActivator.getGlobalStatusService().publishStatus(protocolProvider, GlobalStatusEnum.OFFLINE);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.common.ParserTest.testParseCase5_15",
	"Comment": "similar to the server side 5.15 testcase. a normal 2 fragment text text message, followed by another continuation.",
	"Method": "void testParseCase5_15(){\r\n    List<WebSocketFrame> send = new ArrayList();\r\n    send.add(new TextFrame().setPayload(\"fragment1\").setFin(false));\r\n    send.add(new ContinuationFrame().setPayload(\"fragment2\").setFin(true));\r\n    send.add(new ContinuationFrame().setPayload(\"fragment3\").setFin(false));\r\n    send.add(new TextFrame().setPayload(\"fragment4\").setFin(true));\r\n    send.add(new CloseInfo(StatusCode.NORMAL).asFrame());\r\n    ByteBuffer completeBuf = UnitGenerator.generate(send);\r\n    UnitParser parser = new UnitParser();\r\n    IncomingFramesCapture capture = new IncomingFramesCapture();\r\n    parser.setIncomingFramesHandler(capture);\r\n    ProtocolException x = assertThrows(ProtocolException.class, () -> parser.parseQuietly(completeBuf));\r\n    assertThat(x.getMessage(), containsString(\"CONTINUATION frame without prior !FIN\"));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl.getContact",
	"Comment": "returns the contact corresponding to this peer or null if noparticular contact has been associated.",
	"Method": "Contact getContact(){\r\n    if (getCall() == null)\r\n        return null;\r\n    ProtocolProviderService pps = getCall().getProtocolProvider();\r\n    OperationSetPresenceSipImpl opSetPresence = (OperationSetPresenceSipImpl) pps.getOperationSet(OperationSetPresence.class);\r\n    if (opSetPresence != null)\r\n        return opSetPresence.resolveContactID(getAddress());\r\n    else\r\n        return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallPanel.ensureSize",
	"Comment": "attempts to give a specific component a visible rectangle with aspecific widthand a specific height if possible and sane by resizingthe window which contains this instance.",
	"Method": "void ensureSize(Component component,int width,int height){\r\n    CallContainer callContainer = getCallWindow();\r\n    if (callContainer != null)\r\n        callContainer.ensureSize(component, width, height);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.ircaccregwizz.IrcAccountRegistration.isRememberPassword",
	"Comment": "returns true if password has to remembered, falseotherwise.",
	"Method": "boolean isRememberPassword(){\r\n    return rememberPassword;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.AdHocConferenceChatTransport.sendMultimediaFile",
	"Comment": "sending file in sms messages is not supported by this chat transportimplementation.",
	"Method": "FileTransfer sendMultimediaFile(File file){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.menus.ToolsMenu.pluginComponentRemoved",
	"Comment": "indicates that a plugin component has been removed. removes it from thiscontainer if it is contained in it.",
	"Method": "void pluginComponentRemoved(PluginComponentEvent event){\r\n    final PluginComponentFactory c = event.getPluginComponentFactory();\r\n    if (c.getContainer().equals(Container.CONTAINER_TOOLS_MENU)) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                remove((Component) c.getPluginComponentInstance(ToolsMenu.this).getComponent());\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.menus.ToolsMenu.pluginComponentRemoved",
	"Comment": "indicates that a plugin component has been removed. removes it from thiscontainer if it is contained in it.",
	"Method": "void pluginComponentRemoved(PluginComponentEvent event){\r\n    remove((Component) c.getPluginComponentInstance(ToolsMenu.this).getComponent());\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.systray.AbstractPopupMessageHandler.firePopupMessageClicked",
	"Comment": "notifies the systraypopupmessagelisteners registered with thisinstance that a systraypopupmessageevent has occurred.",
	"Method": "void firePopupMessageClicked(SystrayPopupMessageEvent evt){\r\n    List<SystrayPopupMessageListener> listeners;\r\n    synchronized (popupMessageListeners) {\r\n        listeners = new ArrayList<SystrayPopupMessageListener>(popupMessageListeners);\r\n    }\r\n    for (SystrayPopupMessageListener listener : listeners) listener.popupMessageClicked(evt);\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.ByteFormat.format",
	"Comment": "formats a long which represent a number of bytes to human readable form.",
	"Method": "String format(long bytes){\r\n    long check = 1;\r\n    String[] sufixes = { \"\", \" bytes\", \" K\", \" MB\", \" GB\" };\r\n    for (int i = 1; i <= 4; i++) {\r\n        long tempCheck = check * 1024;\r\n        if (bytes < tempCheck || i == 4) {\r\n            return new DecimalFormat(check == 1 ? \"#,##0\" : \"#,##0.0\").format((double) bytes / check) + sufixes[i];\r\n        }\r\n        check = tempCheck;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.StringContactSourceServiceImpl.setDisableDisplayDetails",
	"Comment": "changes whether to add display details for contact sources.",
	"Method": "void setDisableDisplayDetails(boolean disableDisplayDetails){\r\n    this.disableDisplayDetails = disableDisplayDetails;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.AdHocChatRoomIcqImpl.fireParticipantPresenceEvent",
	"Comment": "creates the corresponding adhocchatroomparticipantpresencechangeevent andnotifies all adhocchatroomparticipantpresencelisteners that acontact has joined or left this adhocchatroom.",
	"Method": "void fireParticipantPresenceEvent(Contact member,String eventID,String eventReason){\r\n    AdHocChatRoomParticipantPresenceChangeEvent evt = new AdHocChatRoomParticipantPresenceChangeEvent(this, member, eventID, eventReason);\r\n    if (logger.isTraceEnabled())\r\n        logger.trace(\"Will dispatch the following ChatRoom event: \" + evt);\r\n    Iterator<AdHocChatRoomParticipantPresenceListener> listeners = null;\r\n    synchronized (memberListeners) {\r\n        listeners = new ArrayList<AdHocChatRoomParticipantPresenceListener>(memberListeners).iterator();\r\n    }\r\n    while (listeners.hasNext()) {\r\n        AdHocChatRoomParticipantPresenceListener listener = listeners.next();\r\n        listener.participantPresenceChanged(evt);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.notification.PopupMessageNotificationHandlerImpl.addPopupMessageListener",
	"Comment": "adds a listener for systraypopupmessageevents posted when userclicks on the system tray popup message.",
	"Method": "void addPopupMessageListener(SystrayPopupMessageListener listener){\r\n    SystrayService systray = NotificationActivator.getSystray();\r\n    if (systray == null)\r\n        return;\r\n    systray.addPopupMessageListener(listener);\r\n}"
}, {
	"Path": "com.keybox.common.filter.AuthFilter.doFilter",
	"Comment": "dofilter determines if user is an administrator or redirect to login page",
	"Method": "void doFilter(ServletRequest req,ServletResponse resp,FilterChain chain){\r\n    HttpServletRequest servletRequest = (HttpServletRequest) req;\r\n    HttpServletResponse servletResponse = (HttpServletResponse) resp;\r\n    boolean isAdmin = false;\r\n    String authToken = AuthUtil.getAuthToken(servletRequest.getSession());\r\n    if (authToken != null && !authToken.trim().equals(\"\")) {\r\n        String userType = AuthDB.isAuthorized(AuthUtil.getUserId(servletRequest.getSession()), authToken);\r\n        if (userType != null) {\r\n            String uri = servletRequest.getRequestURI();\r\n            if (Auth.MANAGER.equals(userType)) {\r\n                isAdmin = true;\r\n            } else if (uri.matches(\"^\" + servletRequest.getContextPath().replaceAll(\"/\", \"\\\\\\\\/\") + \"\\\\/admin\\\\/.*\") && Auth.ADMINISTRATOR.equals(userType)) {\r\n                isAdmin = true;\r\n            }\r\n            AuthUtil.setUserType(servletRequest.getSession(), userType);\r\n            String timeStr = AuthUtil.getTimeout(servletRequest.getSession());\r\n            try {\r\n                if (timeStr != null && !timeStr.trim().equals(\"\")) {\r\n                    SimpleDateFormat sdf = new SimpleDateFormat(\"MMddyyyyHHmmss\");\r\n                    Date sessionTimeout = sdf.parse(timeStr);\r\n                    Date currentTime = new Date();\r\n                    if (sessionTimeout == null || currentTime.after(sessionTimeout)) {\r\n                        isAdmin = false;\r\n                    } else {\r\n                        AuthUtil.setTimeout(servletRequest.getSession());\r\n                    }\r\n                } else {\r\n                    isAdmin = false;\r\n                }\r\n            } catch (Exception ex) {\r\n                log.error(ex.toString(), ex);\r\n                isAdmin = false;\r\n            }\r\n        }\r\n    }\r\n    if (!isAdmin) {\r\n        AuthUtil.deleteAllSession(servletRequest.getSession());\r\n        servletResponse.sendRedirect(servletRequest.getContextPath() + \"/\");\r\n    } else {\r\n        chain.doFilter(req, resp);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.filehistory.FileHistoryServiceImpl.serviceChanged",
	"Comment": "when new protocol provider is registered we checkdoes it supports filetransfer and if so add a listener to it",
	"Method": "void serviceChanged(ServiceEvent serviceEvent){\r\n    Object sService = bundleContext.getService(serviceEvent.getServiceReference());\r\n    if (logger.isTraceEnabled())\r\n        logger.trace(\"Received a service event for: \" + sService.getClass().getName());\r\n    if (!(sService instanceof ProtocolProviderService)) {\r\n        return;\r\n    }\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Service is a protocol provider.\");\r\n    if (serviceEvent.getType() == ServiceEvent.REGISTERED) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Handling registration of a new Protocol Provider.\");\r\n        this.handleProviderAdded((ProtocolProviderService) sService);\r\n    } else if (serviceEvent.getType() == ServiceEvent.UNREGISTERING) {\r\n        this.handleProviderRemoved((ProtocolProviderService) sService);\r\n    }\r\n}"
}, {
	"Path": "com.github.ltsopensource.core.support.CronExpression.isValidExpression",
	"Comment": "indicates whether the specified cron expression can be parsed into avalid cron expression",
	"Method": "boolean isValidExpression(String cronExpression){\r\n    try {\r\n        new CronExpression(cronExpression);\r\n    } catch (ParseException pe) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chatroomslist.joinforms.JoinChatRoomWizardPage1.valueChanged",
	"Comment": "listens for selection evens so that we would only enable the next buttonif an account has actually been chosen.",
	"Method": "void valueChanged(ListSelectionEvent e){\r\n    setNextButtonAccordingToRowSelection();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageHistoryServiceImpl.convertHistoryRecordToMessageEvent",
	"Comment": "used to convert historyrecord in chatroommessagedeliveredevent orchatroommessagereceivedeventwhich are returned by the finder methods",
	"Method": "EventObject convertHistoryRecordToMessageEvent(HistoryRecord hr,Contact contact,EventObject convertHistoryRecordToMessageEvent,HistoryRecord hr,ChatRoom room){\r\n    MessageImpl msg = createMessageFromHistoryRecord(hr);\r\n    Date timestamp;\r\n    Date messageReceivedDate = msg.getMessageReceivedDate();\r\n    Date hrTimestamp = hr.getTimestamp();\r\n    if (messageReceivedDate.getTime() != 0) {\r\n        if (messageReceivedDate.getTime() - hrTimestamp.getTime() > 86400000)\r\n            timestamp = hrTimestamp;\r\n        else\r\n            timestamp = msg.getMessageReceivedDate();\r\n    } else\r\n        timestamp = hrTimestamp;\r\n    String fromStr = hr.getPropertyValues()[5];\r\n    ChatRoomMember from = new ChatRoomMemberImpl(fromStr, room, null);\r\n    if (msg.isOutgoing) {\r\n        return new ChatRoomMessageDeliveredEvent(room, timestamp, msg, ChatRoomMessageDeliveredEvent.CONVERSATION_MESSAGE_DELIVERED);\r\n    } else\r\n        return new ChatRoomMessageReceivedEvent(room, from, timestamp, msg, ChatRoomMessageReceivedEvent.CONVERSATION_MESSAGE_RECEIVED);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.UriHandlerJabberImpl.showErrorMessage",
	"Comment": "uses the uiservice to show an error message and log andexception.",
	"Method": "void showErrorMessage(String message,Exception exc){\r\n    JabberActivator.getUIService().getPopupDialog().showMessagePopupDialog(message, \"Failed to create chat!\", PopupDialog.ERROR_MESSAGE);\r\n    logger.error(message, exc);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWindowManager.findChatPanelForDescriptor",
	"Comment": "finds the chatpanel corresponding to the given chat descriptor.",
	"Method": "ChatPanel findChatPanelForDescriptor(Object descriptor){\r\n    for (ChatPanel chatPanel : chatPanels) if (chatPanel.getChatSession().getDescriptor().equals(descriptor))\r\n        return chatPanel;\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.pluginmanager.PluginTableModel.refreshSortedBundlesList",
	"Comment": "syncs the content of the bundle list with the bundles currentlyavailable in the bundle context and sorts it again.",
	"Method": "void refreshSortedBundlesList(){\r\n    this.bundles = this.bundleContext.getBundles();\r\n    Arrays.sort(this.bundles, bundleComparator);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetPresenceSipImpl.renameServerStoredContactGroup",
	"Comment": "renames the specified group from the server stored contact list.",
	"Method": "void renameServerStoredContactGroup(ContactGroup group,String newName){\r\n    if (!(group instanceof ContactGroupSipImpl)) {\r\n        String errorMessage = String.format(\"Group %1s does not seem to belong to this protocol's \" + \"contact list\", group.getGroupName());\r\n        throw new IllegalArgumentException(errorMessage);\r\n    }\r\n    ssContactList.renameGroup((ContactGroupSipImpl) group, newName);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.gui.UIContactDetail.getPreferredProtocol",
	"Comment": "returns the name of the protocol preferred for contacting this detail forthe given operationset class if no preferred protocol provideris set.",
	"Method": "String getPreferredProtocol(Class<? extends OperationSet> opSetClass){\r\n    if (preferredProtocols != null)\r\n        return preferredProtocols.get(opSetClass);\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapFactoryImpl.createServerSettings",
	"Comment": "required by ldapfactory interface.return a new instance of ldapdirectorysettings,a wrapper around a directory settings",
	"Method": "LdapDirectorySettings createServerSettings(){\r\n    return new LdapDirectorySettingsImpl();\r\n}"
}, {
	"Path": "util.AbbreviateListFinder.getListByKeyWord",
	"Comment": "return a list of abbreviates of classes with specified key word.",
	"Method": "List<String> getListByKeyWord(String keyword){\r\n    ArrayList<String> abbrevList = new ArrayList();\r\n    Iterator<Map.Entry<Object, Object>> propIter = prop.entrySet().iterator();\r\n    while (propIter.hasNext()) {\r\n        Map.Entry<Object, Object> entry = propIter.next();\r\n        String value = (String) entry.getValue();\r\n        if (StringUtils.contains(value, keyword)) {\r\n            String key = (String) entry.getKey();\r\n            abbrevList.add(key);\r\n        }\r\n    }\r\n    return abbrevList;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.MetaUIGroup.countChildContacts",
	"Comment": "returns the count of child contacts of the underlyingmetacontactgroup.",
	"Method": "int countChildContacts(){\r\n    return metaGroup.countChildContacts();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ServerStoredContactListXivoImpl.moveContactToGroup",
	"Comment": "removes the specified contact from its current parent and places itunder newparent.",
	"Method": "void moveContactToGroup(ContactSipImpl contact,ContactGroupSipImpl newParentGroup){\r\n    throw new OperationFailedException(\"Modification not supported.\", OperationFailedException.NOT_SUPPORTED_OPERATION);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ProtocolProviderServiceIcqImpl.getProtocolDisplayName",
	"Comment": "returns the protocol display name. this is the name that would be usedby the gui to display the protocol name.",
	"Method": "String getProtocolDisplayName(){\r\n    if (USING_ICQ)\r\n        return ProtocolNames.ICQ;\r\n    else\r\n        return ProtocolNames.AIM;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.connectioninfo.ConnectionDetailsPanel.getLineString",
	"Comment": "returns an html string corresponding to the given labeltext and infotext,that could be easily added to the information text pane.",
	"Method": "String getLineString(String labelText,String infoText){\r\n    return \"<b>\" + labelText + \"<\/b> : \" + infoText + \"<br/>\";\r\n}"
}, {
	"Path": "org.joor.Reflect.wrapper",
	"Comment": "get a wrapper type for a primitive type, or the argument type itself, ifit is not a primitive type.",
	"Method": "Class<?> wrapper(Class<?> type){\r\n    if (type == null) {\r\n        return null;\r\n    } else if (type.isPrimitive()) {\r\n        if (boolean.class == type) {\r\n            return Boolean.class;\r\n        } else if (int.class == type) {\r\n            return Integer.class;\r\n        } else if (long.class == type) {\r\n            return Long.class;\r\n        } else if (short.class == type) {\r\n            return Short.class;\r\n        } else if (byte.class == type) {\r\n            return Byte.class;\r\n        } else if (double.class == type) {\r\n            return Double.class;\r\n        } else if (float.class == type) {\r\n            return Float.class;\r\n        } else if (char.class == type) {\r\n            return Character.class;\r\n        } else if (void.class == type) {\r\n            return Void.class;\r\n        }\r\n    }\r\n    return type;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.customcontrols.BoxPopupMenu.getItemsCount",
	"Comment": "returns the count of components that will be added to the grid.",
	"Method": "int getItemsCount(){\r\n    return itemsCount;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.history.HistoryWriterImpl.createRecord",
	"Comment": "creates a record element for the supplied doc and populates itwith the property names from propertynames and correspondingvalues from propertyvalues. the date will be usedfor the record timestamp attribute.",
	"Method": "Element createRecord(Document doc,String[] propertyNames,String[] propertyValues,Date date){\r\n    Element elem = doc.createElement(\"record\");\r\n    SimpleDateFormat sdf = new SimpleDateFormat(DATE_FORMAT);\r\n    elem.setAttribute(\"timestamp\", sdf.format(date));\r\n    for (int i = 0; i < propertyNames.length; i++) {\r\n        String propertyName = propertyNames[i];\r\n        if (propertyName.endsWith(CDATA_SUFFIX)) {\r\n            if (propertyValues[i] != null) {\r\n                propertyName = propertyName.replaceFirst(CDATA_SUFFIX, \"\");\r\n                Element propertyElement = doc.createElement(propertyName);\r\n                Text value = doc.createCDATASection(XmlEscapers.xmlContentEscaper().escape(propertyValues[i].replaceAll(\"\\0\", \" \")));\r\n                propertyElement.appendChild(value);\r\n                elem.appendChild(propertyElement);\r\n            }\r\n        } else {\r\n            if (propertyValues[i] != null) {\r\n                Element propertyElement = doc.createElement(propertyName);\r\n                Text value = doc.createTextNode(XmlEscapers.xmlContentEscaper().escape(propertyValues[i].replaceAll(\"\\0\", \" \")));\r\n                propertyElement.appendChild(value);\r\n                elem.appendChild(propertyElement);\r\n            }\r\n        }\r\n    }\r\n    return elem;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.RtpDescriptionPacketExtension.setEncryption",
	"Comment": "sets the optional encryption element that contains encryption parametersfor this session.",
	"Method": "void setEncryption(EncryptionPacketExtension encryption){\r\n    this.encryption = encryption;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.AbstractPacketExtension.getText",
	"Comment": "returns the text content of this extension or null if no textcontent has been specified so far.",
	"Method": "String getText(){\r\n    return textContent;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.notificationconfiguration.SoundFilter.accept",
	"Comment": "method which describes differents permits extensions and defines whichfile or directory will be displayed in the filechoser.",
	"Method": "boolean accept(File f){\r\n    if (f.isDirectory()) {\r\n        return true;\r\n    } else {\r\n        return SoundFileUtils.isSoundFile(f, this.soundFormats);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.securityconfig.masterpassword.MasterPasswordPanel.removeMasterPassword",
	"Comment": "displays a master password prompt to the user, verifies the enteredpassword and then executes changemasterpasswordcallback.executemethod with null as the new password, thus removing it.",
	"Method": "void removeMasterPassword(){\r\n    String master;\r\n    boolean correct = true;\r\n    MasterPasswordInputService masterPasswordInputService = SecurityConfigActivator.getMasterPasswordInputService();\r\n    if (masterPasswordInputService == null) {\r\n        logger.error(\"Missing MasterPasswordInputService to show input dialog\");\r\n        return;\r\n    }\r\n    do {\r\n        master = masterPasswordInputService.showInputDialog(correct);\r\n        if (master == null)\r\n            return;\r\n        correct = (master.length() != 0) && SecurityConfigActivator.getCredentialsStorageService().verifyMasterPassword(master);\r\n    } while (!correct);\r\n    new ChangeMasterPasswordCallback().execute(master, null);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.contactlist.event.MetaContactGroupEvent.getSourceProtoGroup",
	"Comment": "returns the proto group associated with this event or null if the eventdoes not concern a particular source group.",
	"Method": "ContactGroup getSourceProtoGroup(){\r\n    return this.sourceProtoGroup;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactGroupImpl.getSubgroups",
	"Comment": "returns an java.util.iterator over the sub groups that thismetacontactgroup contains.in order to prevent problems with concurrency, the iteratorreturned by this method is not over the actual list of groups but over acopy of that list.",
	"Method": "Iterator<MetaContactGroup> getSubgroups(){\r\n    return subgroupsOrderedCopy.iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.UIServiceImpl.unregisterExportedWindow",
	"Comment": "unregisters the given exportedwindow from the list of windowsthat could be accessed from other bundles.",
	"Method": "void unregisterExportedWindow(ExportedWindow window){\r\n    WindowID identifier = window.getIdentifier();\r\n    ExportedWindow removed = exportedWindows.remove(identifier);\r\n    if ((removed != null) && !removed.equals(window)) {\r\n        exportedWindows.put(identifier, removed);\r\n        for (Iterator<Map.Entry<WindowID, ExportedWindow>> entryIt = exportedWindows.entrySet().iterator(); entryIt.hasNext(); ) {\r\n            Map.Entry<WindowID, ExportedWindow> entry = entryIt.next();\r\n            if (window.equals(entry.getValue()))\r\n                entryIt.remove();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommMenu.setMouseOver",
	"Comment": "sets the ismouseover property value and repaints this component.",
	"Method": "void setMouseOver(boolean isMouseOver){\r\n    this.repaint();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.DynamicRTPExtensionsRegistry.getMappings",
	"Comment": "returns a copy of all mappings currently registered in this registry.",
	"Method": "Map<RTPExtension, Byte> getMappings(){\r\n    return new Hashtable<RTPExtension, Byte>(extMap);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.notification.NotificationActivator.getAudioNotifier",
	"Comment": "returns the audionotifierservice obtained from the bundlecontext.",
	"Method": "AudioNotifierService getAudioNotifier(){\r\n    if (audioNotifierService == null) {\r\n        ServiceReference serviceReference = bundleContext.getServiceReference(AudioNotifierService.class.getName());\r\n        if (serviceReference != null)\r\n            audioNotifierService = (AudioNotifierService) bundleContext.getService(serviceReference);\r\n    }\r\n    return audioNotifierService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallPanel.isCallTimerStarted",
	"Comment": "returns true if the call timer has been started, otherwisereturns false.",
	"Method": "boolean isCallTimerStarted(){\r\n    return isCallTimerStarted;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.pluginmanager.Resources.getString",
	"Comment": "returns an internationalized string corresponding to the given key.",
	"Method": "String getString(String key){\r\n    return getResources().getI18NString(key);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.SecurityAccountRegistration.setEncryptionProtocols",
	"Comment": "sets the map between the encryption protocols and their priority order.",
	"Method": "void setEncryptionProtocols(Map<String, Integer> encryptionProtocols){\r\n    this.encryptionProtocols = encryptionProtocols;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.notification.NotificationServiceImpl.removeNotificationChangeListener",
	"Comment": "removes the given listener from the list of change listeners.",
	"Method": "void removeNotificationChangeListener(NotificationChangeListener listener){\r\n    synchronized (changeListeners) {\r\n        changeListeners.remove(listener);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.common.extensions.compress.PerMessageDeflateExtensionTest.testIncomingUncompressedFrames",
	"Comment": "verify that incoming uncompressed frames are properly passed through",
	"Method": "void testIncomingUncompressedFrames(){\r\n    PerMessageDeflateExtension ext = new PerMessageDeflateExtension();\r\n    ext.setBufferPool(bufferPool);\r\n    ext.setPolicy(WebSocketPolicy.newServerPolicy());\r\n    ExtensionConfig config = ExtensionConfig.parse(\"permessage-deflate\");\r\n    ext.setConfig(config);\r\n    IncomingFramesCapture capture = new IncomingFramesCapture();\r\n    ext.setNextIncomingFrames(capture);\r\n    List<String> quote = new ArrayList();\r\n    quote.add(\"No amount of experimentation can ever prove me right;\");\r\n    quote.add(\"a single experiment can prove me wrong.\");\r\n    quote.add(\"-- Albert Einstein\");\r\n    for (String q : quote) {\r\n        TextFrame frame = new TextFrame().setPayload(q);\r\n        frame.setRsv1(false);\r\n        ext.incomingFrame(frame);\r\n    }\r\n    int len = quote.size();\r\n    capture.assertFrameCount(len);\r\n    capture.assertHasFrame(OpCode.TEXT, len);\r\n    String prefix;\r\n    int i = 0;\r\n    for (WebSocketFrame actual : capture.getFrames()) {\r\n        prefix = \"Frame[\" + i + \"]\";\r\n        assertThat(prefix + \".opcode\", actual.getOpCode(), is(OpCode.TEXT));\r\n        assertThat(prefix + \".fin\", actual.isFin(), is(true));\r\n        assertThat(prefix + \".rsv1\", actual.isRsv1(), is(false));\r\n        assertThat(prefix + \".rsv2\", actual.isRsv2(), is(false));\r\n        assertThat(prefix + \".rsv3\", actual.isRsv3(), is(false));\r\n        ByteBuffer expected = BufferUtil.toBuffer(quote.get(i), StandardCharsets.UTF_8);\r\n        assertThat(prefix + \".payloadLength\", actual.getPayloadLength(), is(expected.remaining()));\r\n        ByteBufferAssert.assertEquals(prefix + \".payload\", expected, actual.getPayload().slice());\r\n        i++;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapDirectoryImpl.setEnabled",
	"Comment": "sets the state of the enabled markerrequired by ldapdirectory interface.",
	"Method": "void setEnabled(boolean enabled){\r\n    this.settings.setEnabled(enabled);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.dnsconfig.DnsConfigActivator.getFileAccessService",
	"Comment": "returns the fileaccessservice obtained from the bundle context.",
	"Method": "FileAccessService getFileAccessService(){\r\n    if (fileAccessService == null) {\r\n        fileAccessService = ServiceUtils.getService(bundleContext, FileAccessService.class);\r\n    }\r\n    return fileAccessService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.mailnotification.MailThreadInfo.getURL",
	"Comment": "returns an url linking to this thread. it is important to distinguishbetween this url and the one returned by the mailboxiq whichpoints to the whole mailbox.",
	"Method": "String getURL(){\r\n    return url;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactListServiceImpl.removeMetaContactListListener",
	"Comment": "removes a listener previously added with addcontactlistlistener.",
	"Method": "void removeMetaContactListListener(MetaContactListListener listener){\r\n    synchronized (metaContactListListeners) {\r\n        this.metaContactListListeners.remove(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.CallPeerGibberishImpl.addStreamSoundLevelListener",
	"Comment": "adds a specific soundlevellistener to the list oflisteners interested in and notified about changes in stream sound levelrelated information.",
	"Method": "void addStreamSoundLevelListener(SoundLevelListener listener){\r\n    synchronized (soundLevelListeners) {\r\n        if (!soundLevelListeners.contains(listener))\r\n            soundLevelListeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetServerStoredContactInfoJabberImpl.getDetails",
	"Comment": "returns the user details from the specified classexactly that class not its descendants",
	"Method": "Iterator<GenericDetail> getDetails(Contact contact,Class<? extends GenericDetail> detailClass){\r\n    if (isPrivateMessagingContact(contact))\r\n        return new LinkedList<GenericDetail>().iterator();\r\n    List<GenericDetail> details = infoRetreiver.getContactDetails(contact.getAddress());\r\n    List<GenericDetail> result = new LinkedList<GenericDetail>();\r\n    if (details == null)\r\n        return result.iterator();\r\n    for (GenericDetail item : details) if (detailClass.equals(item.getClass()))\r\n        result.add(item);\r\n    return result.iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ContactIcqImpl.setNickname",
	"Comment": "used to set the nickname of the contact if it is updatein the contactlist",
	"Method": "void setNickname(String nickname){\r\n    this.nickName = nickname;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl.fireResponseProcessed",
	"Comment": "notifies the methodprocessorlisteners registered with thiscallpeer that it has processed a specific sip responseby sending a specific sip request.",
	"Method": "void fireResponseProcessed(Response response,Request request){\r\n    Iterable<MethodProcessorListener> listeners;\r\n    synchronized (methodProcessorListeners) {\r\n        listeners = new LinkedList<MethodProcessorListener>(methodProcessorListeners);\r\n    }\r\n    for (MethodProcessorListener listener : listeners) listener.responseProcessed(this, response, request);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.notification.PopupMessageNotificationAction.getGroupName",
	"Comment": "returns name of popup group that will be used for merging notifications.",
	"Method": "String getGroupName(){\r\n    return groupName;\r\n}"
}, {
	"Path": "net.librec.data.model.ArffDataModelTestCase.getValidSize",
	"Comment": "returns the size of validation matrix of a specified datamodel object",
	"Method": "int getValidSize(DataModel dataModel){\r\n    return dataModel.getDataSplitter().getValidData().size();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.ContactPresenceStatusChangeEvent.toString",
	"Comment": "returns a string representation of this contactpresencestatuschangeevent",
	"Method": "String toString(){\r\n    StringBuffer buff = new StringBuffer(\"ContactPresenceStatusChangeEvent-[ ContactID=\");\r\n    buff.append(getSourceContact().getAddress());\r\n    if (getParentGroup() != null)\r\n        buff.append(\", ParentGroup\").append(getParentGroup().getGroupName());\r\n    return buff.append(\", OldStatus=\").append(getOldStatus()).append(\", NewStatus=\").append(getNewStatus()).append(\"]\").toString();\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.generic.TestOperationSetFileTransfer.testSenderCancelsWhileTransfering",
	"Comment": "when the transfer starts waits for a while and the sendercancels the transfer while its in progress.",
	"Method": "void testSenderCancelsWhileTransfering(){\r\n    if (!enableTestSenderCancelsWhileTransfering())\r\n        return;\r\n    logger.trace(\"Start test : Sender will cancel fileTransfer\" + \" while transfering.\");\r\n    File fileToTransfer = getTempFileToTransfer(12345678);\r\n    OperationSetFileTransfer ftOpSet1 = getOpSetFilTransfer1();\r\n    OperationSetFileTransfer ftOpSet2 = getOpSetFilTransfer2();\r\n    FileTransferStatusEventCollector senderStatusListener = new FileTransferStatusEventCollector(\"Sender\");\r\n    FileTransferEventCollector senderFTListerner = new FileTransferEventCollector(\"Sender\", senderStatusListener);\r\n    ftOpSet1.addFileTransferListener(senderFTListerner);\r\n    FileTransferEventCollector receiverFTListerner = new FileTransferEventCollector(\"Receiver\", null);\r\n    ftOpSet2.addFileTransferListener(receiverFTListerner);\r\n    try {\r\n        FileTransfer ft1 = ftOpSet1.sendFile(getContact1(), fileToTransfer);\r\n        senderFTListerner.waitForEvent(4000);\r\n        receiverFTListerner.waitForEvent(4000);\r\n        senderStatusListener.waitForEvent(4000);\r\n        assertEquals(\"A file transfer created must be received on send side\", 1, senderFTListerner.collectedEvents.size());\r\n        FileTransferCreatedEvent fileTransferCreatedEvent = (FileTransferCreatedEvent) senderFTListerner.collectedEvents.get(0);\r\n        assertEquals(\"FileTransfer file\", fileTransferCreatedEvent.getFileTransfer().getLocalFile(), fileToTransfer);\r\n        assertEquals(\"A file transfer status changed - \" + \"preparing received on send side\", 1, senderStatusListener.collectedEvents.size());\r\n        FileTransferStatusChangeEvent fileTransferStatusEvent = senderStatusListener.collectedEvents.get(0);\r\n        assertEquals(\"Event must be preparing\", FileTransferStatusChangeEvent.PREPARING, fileTransferStatusEvent.getNewStatus());\r\n        assertEquals(\"A file transfer request must be \" + \"received on the receiver side\", 1, receiverFTListerner.collectedEvents.size());\r\n        FileTransferRequestEvent fileTransferRequestEvent = (FileTransferRequestEvent) receiverFTListerner.collectedEvents.get(0);\r\n        IncomingFileTransferRequest req = fileTransferRequestEvent.getRequest();\r\n        assertEquals(\"FileTransfer file name must be the same\", req.getFileName(), fileToTransfer.getName());\r\n        assertEquals(\"FileTransfer file size must be the same\", req.getFileSize(), fileToTransfer.length());\r\n        senderFTListerner.clear();\r\n        receiverFTListerner.clear();\r\n        senderStatusListener.clear();\r\n        File receiveFile = getFileService().getTemporaryFile();\r\n        FileTransferStatusEventCollector receiverStatusListener = new FileTransferStatusEventCollector(\"Receiver\");\r\n        final FileTransfer ft2 = req.acceptFile(receiveFile);\r\n        ft2.addStatusListener(receiverStatusListener);\r\n        senderStatusListener.waitForEvent(4000);\r\n        FileTransferStatusChangeEvent stat1 = senderStatusListener.collectedEvents.get(0);\r\n        senderStatusListener.collectedEvents.clear();\r\n        assertEquals(\"Event must be inProgress\", FileTransferStatusChangeEvent.IN_PROGRESS, stat1.getNewStatus());\r\n        ft1.cancel();\r\n        senderStatusListener.waitForEvent(4000);\r\n        FileTransferStatusChangeEvent stat2 = senderStatusListener.collectedEvents.get(0);\r\n        senderStatusListener.collectedEvents.clear();\r\n        assertEquals(\"Event must be canceled\", FileTransferStatusChangeEvent.CANCELED, stat2.getNewStatus());\r\n        receiverFTListerner.waitForEvent(4000);\r\n        assertEquals(\"A file transfer created must be received on \" + \"receiver side\", 1, receiverFTListerner.collectedEvents.size());\r\n        fileTransferCreatedEvent = (FileTransferCreatedEvent) receiverFTListerner.collectedEvents.get(0);\r\n        assertEquals(\"FileTransfer file\", fileTransferCreatedEvent.getFileTransfer().getLocalFile(), receiveFile);\r\n        receiverStatusListener.waitForEvent(4000, 3);\r\n        assertTrue(\"Cancel event must be received\", receiverStatusListener.contains(FileTransferStatusChangeEvent.CANCELED));\r\n    } finally {\r\n        ftOpSet1.removeFileTransferListener(senderFTListerner);\r\n        ftOpSet2.addFileTransferListener(receiverFTListerner);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl.fireRequestProcessed",
	"Comment": "notifies the methodprocessorlisteners registered with thiscallpeer that it has processed a specific sip requestby sending a specific sip response.",
	"Method": "void fireRequestProcessed(Request request,Response response){\r\n    Iterable<MethodProcessorListener> listeners;\r\n    synchronized (methodProcessorListeners) {\r\n        listeners = new LinkedList<MethodProcessorListener>(methodProcessorListeners);\r\n    }\r\n    for (MethodProcessorListener listener : listeners) listener.requestProcessed(this, request, response);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatConversationPanel.finishMessageAdd",
	"Comment": "performs all operations needed in order to finish the adding of themessage to the document.",
	"Method": "void finishMessageAdd(String message){\r\n    if (!isHistory)\r\n        ensureDocumentSize();\r\n    ConfigurationService cfg = GuiActivator.getConfigurationService();\r\n    if (cfg.getBoolean(ReplacementProperty.REPLACEMENT_ENABLE, true) || cfg.getBoolean(ReplacementProperty.REPLACEMENT_PROPOSAL, true) || cfg.getBoolean(ReplacementProperty.getPropertyName(\"SMILEY\"), true)) {\r\n        processReplacement(ChatHtmlUtils.MESSAGE_TEXT_ID + lastMessageUID, message);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomJabberImpl.revokeAdmin",
	"Comment": "revokes administrator privileges from a user. the occupant that loses administrator privileges will become a member. room owners may revoke administrator privileges from a member or unaffiliated user.",
	"Method": "void revokeAdmin(String jid){\r\n    try {\r\n        multiUserChat.revokeAdmin(jid);\r\n    } catch (XMPPException ex) {\r\n        logger.error(\"n error occurs revoking administrator \" + \"privileges to a user\", ex);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.TestOperationSetPersistentPresence.prepareContactList",
	"Comment": "create the contact list. later will be test to be sure that creating is ok",
	"Method": "void prepareContactList(){\r\n    fixture.clearProvidersLists();\r\n    Object o = new Object();\r\n    synchronized (o) {\r\n        o.wait(3000);\r\n    }\r\n    String contactList = System.getProperty(JabberProtocolProviderServiceLick.CONTACT_LIST_PROPERTY_NAME, null);\r\n    logger.debug(\"The \" + JabberProtocolProviderServiceLick.CONTACT_LIST_PROPERTY_NAME + \" property is set to=\" + contactList);\r\n    if (contactList == null || contactList.trim().length() < 6)\r\n        throw new IllegalArgumentException(\"The \" + JabberProtocolProviderServiceLick.CONTACT_LIST_PROPERTY_NAME + \" property did not contain a contact list.\");\r\n    StringTokenizer tokenizer = new StringTokenizer(contactList, \" \\n\\t\");\r\n    logger.debug(\"tokens contained by the CL tokenized=\" + tokenizer.countTokens());\r\n    Hashtable<String, List<String>> contactListToCreate = new Hashtable<String, List<String>>();\r\n    while (tokenizer.hasMoreTokens()) {\r\n        String groupUinToken = tokenizer.nextToken();\r\n        int dotIndex = groupUinToken.indexOf(\".\");\r\n        if (dotIndex == -1) {\r\n            throw new IllegalArgumentException(groupUinToken + \" is not a valid Group.UIN token\");\r\n        }\r\n        String groupName = groupUinToken.substring(0, dotIndex);\r\n        String uin = groupUinToken.substring(dotIndex + 1);\r\n        if (groupName.trim().length() < 1 || uin.trim().length() < 4) {\r\n            throw new IllegalArgumentException(groupName + \" or \" + uin + \" are not a valid group name or Jabber UIN.\");\r\n        }\r\n        List<String> uinInThisGroup = contactListToCreate.get(groupName);\r\n        if (uinInThisGroup == null) {\r\n            uinInThisGroup = new ArrayList<String>();\r\n            contactListToCreate.put(groupName, uinInThisGroup);\r\n        }\r\n        uinInThisGroup.add(uin);\r\n    }\r\n    Enumeration<String> newGroupsEnum = contactListToCreate.keys();\r\n    while (newGroupsEnum.hasMoreElements()) {\r\n        String groupName = newGroupsEnum.nextElement();\r\n        logger.debug(\"Will add group \" + groupName);\r\n        opSetPersPresence1.createServerStoredContactGroup(opSetPersPresence1.getServerStoredContactListRoot(), groupName);\r\n        ContactGroup newlyCreatedGroup = opSetPersPresence1.getServerStoredContactListRoot().getGroup(groupName);\r\n        Iterator<String> contactsToAddToThisGroup = contactListToCreate.get(groupName).iterator();\r\n        while (contactsToAddToThisGroup.hasNext()) {\r\n            String id = contactsToAddToThisGroup.next();\r\n            logger.debug(\"Will add buddy \" + id);\r\n            opSetPersPresence1.subscribe(newlyCreatedGroup, id);\r\n        }\r\n    }\r\n    JabberSlickFixture.preInstalledBuddyList = contactListToCreate;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.MetaContactChatSession.getChatSessionRenderer",
	"Comment": "returns the chatsessionrenderer that provides the connectionbetween this chat session and its ui.",
	"Method": "ChatSessionRenderer getChatSessionRenderer(){\r\n    return sessionRenderer;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaAwareCallPeer.addConferenceMembersSoundLevelListener",
	"Comment": "adds a specific conferencememberssoundlevellistener to the listof listeners interested in and notified about changes in conferencemembers sound level.",
	"Method": "void addConferenceMembersSoundLevelListener(ConferenceMembersSoundLevelListener listener){\r\n    if (listener == null)\r\n        return;\r\n    synchronized (conferenceMembersSoundLevelListeners) {\r\n        if (conferenceMembersSoundLevelListeners.size() == 0) {\r\n            getMediaHandler().setCsrcAudioLevelListener(this);\r\n        }\r\n        conferenceMembersSoundLevelListeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.toolBars.MainToolBar.updateInviteContactButton",
	"Comment": "updates invite contact button depending on the user role we have.",
	"Method": "void updateInviteContactButton(){\r\n    if (chatSession instanceof ConferenceChatSession) {\r\n        ChatRoomMemberRole role = ((ChatRoomWrapper) chatSession.getDescriptor()).getChatRoom().getUserRole();\r\n        inviteButton.setEnabled(role.getRoleIndex() >= 50);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.JabberAccountRegistrationForm.getRegistration",
	"Comment": "returns the current jabber registration holding all values.",
	"Method": "JabberAccountRegistration getRegistration(){\r\n    return wizard.getRegistration();\r\n}"
}, {
	"Path": "io.lettuce.core.dynamic.support.ClassTypeInformation.getTypeVariableMap",
	"Comment": "little helper to allow us to create a generified map, actually just to satisfy the compiler.",
	"Method": "Map<TypeVariable<?>, Type> getTypeVariableMap(Class<?> type,Map<TypeVariable<?>, Type> getTypeVariableMap,Class<?> type,Collection<Type> visited){\r\n    if (visited.contains(type)) {\r\n        return Collections.emptyMap();\r\n    } else {\r\n        visited.add(type);\r\n    }\r\n    Map<TypeVariable, Type> source = GenericTypeResolver.getTypeVariableMap(type);\r\n    Map<TypeVariable<?>, Type> map = new HashMap(source.size());\r\n    for (Entry<TypeVariable, Type> entry : source.entrySet()) {\r\n        Type value = entry.getValue();\r\n        map.put(entry.getKey(), entry.getValue());\r\n        if (value instanceof Class) {\r\n            map.putAll(getTypeVariableMap((Class<?>) value, visited));\r\n        }\r\n    }\r\n    return map;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.GuiActivator.getDesktopService",
	"Comment": "returns the desktopservice obtained from the bundle context.",
	"Method": "DesktopService getDesktopService(){\r\n    if (desktopService == null) {\r\n        desktopService = ServiceUtils.getService(bundleContext, DesktopService.class);\r\n    }\r\n    return desktopService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.history.HistoryReaderImpl.findByEndDate",
	"Comment": "searches the history for all records with timestamp beforeenddate.",
	"Method": "QueryResultSet<HistoryRecord> findByEndDate(Date endDate){\r\n    return find(null, endDate, null, null, false);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl.putOffHold",
	"Comment": "resumes communication with a call peer previously put on hold.",
	"Method": "void putOffHold(CallPeer peer){\r\n    putOnHold(peer, false);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.login.DefaultSecurityAuthority.obtainCredentials",
	"Comment": "implements the securityauthority.obtaincredentials method.creates and show an authenticationwindow, where user could enterits password.",
	"Method": "UserCredentials obtainCredentials(String realm,UserCredentials userCredentials,int reasonCode,UserCredentials obtainCredentials,String realm,UserCredentials userCredentials){\r\n    return this.obtainCredentials(realm, userCredentials, SecurityAuthority.AUTHENTICATION_REQUIRED);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.TestOperationSetPresence.testChangingStateToInvisible",
	"Comment": "verify that changing state to invisible works as supposed to and that itgenerates the corresponding event.",
	"Method": "void testChangingStateToInvisible(){\r\n    subtestStateTransition(IcqStatusEnum.INVISIBLE);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.notifsource.NotificationGroup.getParentGroup",
	"Comment": "returns null to indicate that the parent group is the root group.",
	"Method": "UIGroup getParentGroup(){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.JabberAccountRegistrationWizard.getUserNameExample",
	"Comment": "returns an example string, which should indicate to the user how theuser name should look like.",
	"Method": "String getUserNameExample(){\r\n    return \"Ex: johnsmith@jabber.org\";\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.gibberish.TestProtocolProviderServiceGibberishImpl.testOperationSetTypes",
	"Comment": "verifies that all operation sets have the type they are declarded tohave.",
	"Method": "void testOperationSetTypes(){\r\n    Map<String, OperationSet> supportedOperationSets = fixture.provider1.getSupportedOperationSets();\r\n    for (Map.Entry<String, OperationSet> entry : supportedOperationSets.entrySet()) {\r\n        String setName = entry.getKey();\r\n        Object opSet = entry.getValue();\r\n        assertTrue(opSet + \" was not an instance of \" + setName + \" as declared\", Class.forName(setName).isInstance(opSet));\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractCallPeer.getCallInfoURL",
	"Comment": "returns a url pointing ta a location with call control information forthis peer or null if no such url is available for this callpeer.",
	"Method": "URL getCallInfoURL(){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.account.AccountList.providerStatusChanged",
	"Comment": "refreshes the account status icon, when the status has changed.",
	"Method": "void providerStatusChanged(ProviderPresenceStatusChangeEvent evt){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                providerStatusChanged(evt);\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    accountListModelContentChanged(evt.getProvider());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.account.AccountList.providerStatusChanged",
	"Comment": "refreshes the account status icon, when the status has changed.",
	"Method": "void providerStatusChanged(ProviderPresenceStatusChangeEvent evt){\r\n    providerStatusChanged(evt);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.IncomingFileTransferRequestJabberImpl.getFileDescription",
	"Comment": "returns the description of the file corresponding to this request.",
	"Method": "String getFileDescription(){\r\n    return fileTransferRequest.getDescription();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ProviderManagerExt.addExtProvider",
	"Comment": "adds an extension provider with the specified element name and name space. the providerwill override any providers loaded through the classpath. the provider must be eithera packetextensionprovider instance, or a class object of a javabean.",
	"Method": "void addExtProvider(String elementName,String namespace,Class<?> provider){\r\n    try {\r\n        if (PacketExtensionProvider.class.isAssignableFrom(provider)) {\r\n            addExtensionProvider(elementName, namespace, provider.newInstance());\r\n        } else if (PacketExtension.class.isAssignableFrom(provider)) {\r\n            addExtensionProvider(elementName, namespace, provider);\r\n        }\r\n    } catch (Throwable t) {\r\n        logger.error(\"Error adding extension provider.\", t);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.FullUserInfoCmd.writeOutString",
	"Comment": "writes string data to the icqdataoutwhich is send to the server",
	"Method": "void writeOutString(int dataType,String value){\r\n    try {\r\n        byte[] data = BinaryTools.getAsciiBytes(value);\r\n        writeUShort(icqDataOut, dataType);\r\n        writeUShort(icqDataOut, data.length + 2);\r\n        writeUShort(icqDataOut, data.length);\r\n        icqDataOut.write(data);\r\n    } catch (IOException ex) {\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.TestAccountUninstallation.testUninstallAccount",
	"Comment": "uinstalls our test account and makes sure it really has been removed.",
	"Method": "void testUninstallAccount(){\r\n    assertFalse(\"No installed accounts found\", fixture.providerFactory.getRegisteredAccounts().isEmpty());\r\n    assertNotNull(\"Found no provider corresponding to account ID \" + IcqSlickFixture.icqAccountID, fixture.providerFactory.getProviderForAccount(IcqSlickFixture.icqAccountID));\r\n    assertTrue(\"Failed to remove a provider corresponding to acc id \" + IcqSlickFixture.icqAccountID, fixture.providerFactory.uninstallAccount(IcqSlickFixture.icqAccountID));\r\n    ServiceReference[] icqProviderRefs = null;\r\n    try {\r\n        icqProviderRefs = IcqSlickFixture.bc.getServiceReferences(ProtocolProviderService.class.getName(), \"(&\" + \"(\" + ProtocolProviderFactory.PROTOCOL + \"=\" + ProtocolNames.ICQ + \")\" + \"(\" + ProtocolProviderFactory.USER_ID + \"=\" + IcqSlickFixture.icqAccountID.getUserID() + \")\" + \")\");\r\n    } catch (InvalidSyntaxException ex) {\r\n        fail(\"We apparently got our filter wrong: \" + ex.getMessage());\r\n    }\r\n    assertTrue(\"A Protocol Provider Service was still regged as an osgi service \" + \"for ICQ UIN:\" + IcqSlickFixture.icqAccountID + \"After it was explicitly uninstalled\", icqProviderRefs == null || icqProviderRefs.length == 0);\r\n    assertTrue(\"The ICQ provider factory kept a reference to the provider we just \" + \"uninstalled (accID=\" + IcqSlickFixture.icqAccountID + \")\", fixture.providerFactory.getRegisteredAccounts().isEmpty() && fixture.providerFactory.getProviderForAccount(IcqSlickFixture.icqAccountID) == null);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.OperationSetPersistentPresenceGibberishImpl.findContactParent",
	"Comment": "returns the group that is parent of the specified gibberishcontactornull if no parent was found.",
	"Method": "ContactGroupGibberishImpl findContactParent(ContactGibberishImpl gibberishContact){\r\n    return (ContactGroupGibberishImpl) gibberishContact.getParentContactGroup();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetPresenceSipImpl.moveContactToGroup",
	"Comment": "removes the specified contact from its current parent and places itunder newparent.",
	"Method": "void moveContactToGroup(Contact contactToMove,ContactGroup newParent){\r\n    if (!(contactToMove instanceof ContactSipImpl)) {\r\n        return;\r\n    }\r\n    try {\r\n        ssContactList.moveContactToGroup((ContactSipImpl) contactToMove, (ContactGroupSipImpl) newParent);\r\n        if (this.presenceEnabled) {\r\n            subscriber.subscribe(new PresenceSubscriberSubscription((ContactSipImpl) contactToMove));\r\n        }\r\n    } catch (OperationFailedException ex) {\r\n        throw new IllegalStateException(\"Failed to move contact \" + contactToMove.getAddress(), ex);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.TestOperationSetMultiUserChat.testGetExistingChatRooms",
	"Comment": "retrieves existing chat room from the protocol provider and makes surethat the room we created in previous tests is in there.",
	"Method": "void testGetExistingChatRooms(){\r\n    List<String> existingChatRooms = opSetMultiChat1.getExistingChatRooms();\r\n    assertTrue(\"No chat rooms found on the server, even after we \" + \"have created one. \", existingChatRooms.size() > 0);\r\n    logger.info(\"Server returned the following list of chat rooms: \" + existingChatRooms);\r\n    boolean testRoomFound = false;\r\n    for (String roomName : existingChatRooms) if (roomName.equals(fixture.chatRoomName))\r\n        testRoomFound = true;\r\n    assertTrue(\"The room we created in previous tests \" + fixture.chatRoomName + \" was not among the existing rooms list returned by \" + \"the provider.\", testRoomFound);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetCusaxUtilsJabberImpl.doesDetailBelong",
	"Comment": "checks if the given detailaddress exists in the givencontact details.",
	"Method": "boolean doesDetailBelong(Contact contact,String detailAddress){\r\n    List<String> contactPhones = ContactPhoneUtil.getContactAdditionalPhones(contact, null, false, false);\r\n    if (contactPhones == null || contactPhones.size() <= 0)\r\n        return false;\r\n    Iterator<String> phonesIter = contactPhones.iterator();\r\n    while (phonesIter.hasNext()) {\r\n        String phone = phonesIter.next();\r\n        String normalizedPhone = JabberActivator.getPhoneNumberI18nService().normalize(phone);\r\n        if (phone.equals(detailAddress) || normalizedPhone.equals(detailAddress) || detailAddress.contains(phone) || detailAddress.contains(normalizedPhone))\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.sdp.SdpUtils.extractMediaDescriptions",
	"Comment": "extracts and returns all mediadescriptions provided insessiondescription.",
	"Method": "Vector<MediaDescription> extractMediaDescriptions(SessionDescription sessionDescription){\r\n    Vector<MediaDescription> remoteDescriptions = null;\r\n    try {\r\n        remoteDescriptions = sessionDescription.getMediaDescriptions(false);\r\n    } catch (SdpException e) {\r\n    }\r\n    if (remoteDescriptions == null || remoteDescriptions.size() == 0) {\r\n        throw new IllegalArgumentException(\"Could not find any media descriptions.\");\r\n    }\r\n    return remoteDescriptions;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.ircaccregwizz.IrcAccountRegistration.setRememberPassword",
	"Comment": "sets the rememberpassword value of this irc account registration.",
	"Method": "void setRememberPassword(boolean rememberPassword){\r\n    this.rememberPassword = rememberPassword;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.sipaccregwizz.SIPAccountRegistrationWizard.getProtocolName",
	"Comment": "implements the accountregistrationwizard.getprotocolnamemethod. returns the protocol name for this wizard.",
	"Method": "String getProtocolName(){\r\n    return Resources.getString(\"plugin.sipaccregwizz.PROTOCOL_NAME\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.whiteboard.gui.whiteboardshapes.WhiteboardShapePath.getPoints",
	"Comment": "returns a list of all the whiteboardpoint instances that thiswhiteboardobject is composed of.",
	"Method": "List<WhiteboardPoint> getPoints(){\r\n    return points;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.contactsource.AbstractContactQuery.removeContactQueryListener",
	"Comment": "removes a contactquerylistener from the list of listenersinterested in notifications about this contactquery changing itsstatus, the receipt of new sourcecontacts via thiscontactquery, etc.",
	"Method": "void removeContactQueryListener(ContactQueryListener l){\r\n    if (l != null) {\r\n        synchronized (listeners) {\r\n            listeners.remove(l);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.lettuce.core.ZStoreArgs.sum",
	"Comment": "aggregate scores of elements existing across multiple sets by summing up.",
	"Method": "ZStoreArgs sum(ZStoreArgs sum){\r\n    this.aggregate = Aggregate.SUM;\r\n    return this;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.notification.NotificationServiceImpl.addActionHandler",
	"Comment": "adds an object that executes the actual action of a notification action.if the same action type is added twice, the last added wins.",
	"Method": "void addActionHandler(NotificationHandler handler){\r\n    if (handler == null)\r\n        throw new IllegalArgumentException(\"handler cannot be null\");\r\n    synchronized (handlers) {\r\n        handlers.put(handler.getActionType(), handler);\r\n        if ((handlers.size() == NUM_ACTIONS) && (notificationCache != null)) {\r\n            for (NotificationData event : notificationCache) fireNotification(event);\r\n            notificationCache.clear();\r\n            notificationCache = null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.toolBars.HistorySelectorBox.chatLinkClicked",
	"Comment": "if a link is clicked with certain action to open the history popup menu.",
	"Method": "void chatLinkClicked(URI url){\r\n    if (url.getPath().equals(\"/showHistoryPopupMenu\")) {\r\n        this.doClick();\r\n    }\r\n}"
}, {
	"Path": "io.lettuce.core.EpollProvider.checkForEpollLibrary",
	"Comment": "check whether the epoll library is available on the class path.",
	"Method": "void checkForEpollLibrary(){\r\n    LettuceAssert.assertState(EPOLL_ENABLED, String.format(\"epoll use is disabled via System properties (%s)\", EPOLL_ENABLED_KEY));\r\n    LettuceAssert.assertState(isAvailable(), \"netty-transport-native-epoll is not available. Make sure netty-transport-native-epoll library on the class path and supported by your operating system.\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.security.SipSecurityManager.createAuthorizationHeader",
	"Comment": "generates an authorization header in response to wwwauthheader.",
	"Method": "AuthorizationHeader createAuthorizationHeader(String method,String uri,String requestBody,WWWAuthenticateHeader authHeader,UserCredentials userCredentials){\r\n    String response = null;\r\n    String qopList = authHeader.getQop();\r\n    String qop = (qopList != null) ? \"auth\" : null;\r\n    String nc_value = \"00000001\";\r\n    String cnonce = \"xyz\";\r\n    try {\r\n        response = // JvB added\r\n        MessageDigestAlgorithm.calculateResponse(// JvB added\r\n        authHeader.getAlgorithm(), // JvB added\r\n        userCredentials.getUserName(), // JvB added\r\n        authHeader.getRealm(), // JvB added\r\n        new String(userCredentials.getPassword()), authHeader.getNonce(), nc_value, // jvb changed\r\n        cnonce, // jvb changed\r\n        method, // jvb changed\r\n        uri, requestBody, qop);\r\n    } catch (NullPointerException exc) {\r\n        throw new OperationFailedException(\"The authenticate header was malformatted\", OperationFailedException.GENERAL_ERROR, exc);\r\n    }\r\n    AuthorizationHeader authorization = null;\r\n    try {\r\n        if (authHeader instanceof ProxyAuthenticateHeader) {\r\n            authorization = headerFactory.createProxyAuthorizationHeader(authHeader.getScheme());\r\n        } else {\r\n            authorization = headerFactory.createAuthorizationHeader(authHeader.getScheme());\r\n        }\r\n        authorization.setUsername(userCredentials.getUserName());\r\n        authorization.setRealm(authHeader.getRealm());\r\n        authorization.setNonce(authHeader.getNonce());\r\n        authorization.setParameter(\"uri\", uri);\r\n        authorization.setResponse(response);\r\n        if (authHeader.getAlgorithm() != null) {\r\n            authorization.setAlgorithm(authHeader.getAlgorithm());\r\n        }\r\n        if (authHeader.getOpaque() != null) {\r\n            authorization.setOpaque(authHeader.getOpaque());\r\n        }\r\n        if (qop != null) {\r\n            authorization.setQop(qop);\r\n            authorization.setCNonce(cnonce);\r\n            authorization.setNonceCount(Integer.parseInt(nc_value));\r\n        }\r\n        authorization.setResponse(response);\r\n    } catch (ParseException ex) {\r\n        throw new SecurityException(\"Failed to create an authorization header!\");\r\n    }\r\n    return authorization;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaHandler.audioLevelChanged",
	"Comment": "notifies this instance that a simpleaudiolevellistener has beeninvoked. forwards the notification to a specific list ofsimpleaudiolevellisteners.",
	"Method": "void audioLevelChanged(Object lock,List<SimpleAudioLevelListener> listeners,int level){\r\n    List<SimpleAudioLevelListener> ls;\r\n    synchronized (lock) {\r\n        if (listeners.isEmpty())\r\n            return;\r\n        else\r\n            ls = listeners;\r\n    }\r\n    for (int i = 0, count = ls.size(); i < count; i++) {\r\n        ls.get(i).audioLevelChanged(level);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.updateChatTransportStatus",
	"Comment": "updates the status of the given chat transport in the send via selectorbox and notifies the user for the status change.",
	"Method": "void updateChatTransportStatus(ChatTransport chatTransport){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                updateChatTransportStatus(chatTransport);\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    writeMessagePanel.updateChatTransportStatus(chatTransport);\r\n    if (!chatTransport.equals(chatSession.getCurrentChatTransport()))\r\n        return;\r\n    if (ConfigurationUtils.isShowStatusChangedInChat()) {\r\n        this.addMessage(chatTransport.getName(), new Date(), Chat.STATUS_MESSAGE, GuiActivator.getResources().getI18NString(\"service.gui.STATUS_CHANGED_CHAT_MESSAGE\", new String[] { chatTransport.getStatus().getStatusName() }), \"text/plain\");\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.updateChatTransportStatus",
	"Comment": "updates the status of the given chat transport in the send via selectorbox and notifies the user for the status change.",
	"Method": "void updateChatTransportStatus(ChatTransport chatTransport){\r\n    updateChatTransportStatus(chatTransport);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl.doNonSynchronisedProcessAnswer",
	"Comment": "handles the specified answer by creating and initializing thecorresponding mediastreams.",
	"Method": "void doNonSynchronisedProcessAnswer(SessionDescription answer){\r\n    List<MediaDescription> remoteDescriptions = SdpUtils.extractMediaDescriptions(answer);\r\n    this.setCallInfoURL(SdpUtils.getCallInfoURL(answer));\r\n    boolean masterStreamSet = false;\r\n    List<MediaType> seenMediaTypes = new ArrayList<MediaType>();\r\n    for (MediaDescription mediaDescription : remoteDescriptions) {\r\n        MediaType mediaType;\r\n        try {\r\n            mediaType = SdpUtils.getMediaType(mediaDescription);\r\n            if (seenMediaTypes.contains(mediaType))\r\n                continue;\r\n            seenMediaTypes.add(mediaType);\r\n        } catch (IllegalArgumentException iae) {\r\n            logger.info(\"Remote party added to answer a media type that \" + \"we don't understand. Ignoring stream.\");\r\n            continue;\r\n        }\r\n        MediaStreamTarget target = SdpUtils.extractDefaultTarget(mediaDescription, answer);\r\n        if (target.getDataAddress().getPort() == 0) {\r\n            closeStream(mediaType);\r\n            continue;\r\n        }\r\n        List<MediaFormat> supportedFormats = SdpUtils.extractFormats(mediaDescription, getDynamicPayloadTypes());\r\n        MediaDevice dev = getDefaultDevice(mediaType);\r\n        if (!isDeviceActive(dev)) {\r\n            closeStream(mediaType);\r\n            continue;\r\n        }\r\n        MediaDirection devDirection = (dev == null) ? MediaDirection.INACTIVE : dev.getDirection();\r\n        devDirection = devDirection.and(getDirectionUserPreference(mediaType));\r\n        if (supportedFormats.isEmpty()) {\r\n            ProtocolProviderServiceSipImpl.throwOperationFailedException(\"Remote party sent an invalid SDP answer. The codecs in \" + \"the answer are either not present or not \" + \"supported\", OperationFailedException.ILLEGAL_ARGUMENT, null, logger);\r\n        }\r\n        StreamConnector connector = getTransportManager().getStreamConnector(mediaType);\r\n        MediaDirection remoteDirection = SdpUtils.getDirection(mediaDescription);\r\n        MediaDirection direction = devDirection.getDirectionForAnswer(remoteDirection);\r\n        if (isLocallyOnHold())\r\n            direction = direction.and(MediaDirection.SENDONLY);\r\n        List<RTPExtension> remoteRTPExtensions = SdpUtils.extractRTPExtensions(mediaDescription, getRtpExtensionsRegistry());\r\n        List<RTPExtension> supportedExtensions = getExtensionsForType(mediaType);\r\n        List<RTPExtension> rtpExtensions = intersectRTPExtensions(remoteRTPExtensions, supportedExtensions);\r\n        if (MediaType.VIDEO.equals(mediaType)) {\r\n            supportQualityControls = SdpUtils.containsAttribute(mediaDescription, \"imageattr\");\r\n        }\r\n        updateSrtpControlsForDtls(mediaType, null, mediaDescription);\r\n        SrtpControls srtpControls = getSrtpControls();\r\n        SDesControl sdesControl = (SDesControl) srtpControls.get(mediaType, SrtpControlType.SDES);\r\n        if (sdesControl != null) {\r\n            if (selectSdesCryptoSuite(true, sdesControl, mediaDescription) == null) {\r\n                sdesControl.cleanup(null);\r\n                srtpControls.remove(mediaType, SrtpControlType.SDES);\r\n                logger.warn(\"Received unsupported sdes crypto attribute.\");\r\n            } else {\r\n                removeAndCleanupOtherSrtpControls(mediaType, SrtpControlType.SDES);\r\n                addAdvertisedEncryptionMethod(SrtpControlType.SDES);\r\n            }\r\n        }\r\n        boolean masterStream = false;\r\n        if (!masterStreamSet) {\r\n            if (remoteDescriptions.size() > 1) {\r\n                if (MediaType.AUDIO.equals(mediaType)) {\r\n                    masterStream = true;\r\n                    masterStreamSet = true;\r\n                }\r\n            } else {\r\n                masterStream = true;\r\n                masterStreamSet = true;\r\n            }\r\n        }\r\n        try {\r\n            if (mediaDescription.getAttribute(SdpUtils.ZRTP_HASH_ATTR) != null) {\r\n                addAdvertisedEncryptionMethod(SrtpControlType.ZRTP);\r\n            }\r\n        } catch (SdpParseException e) {\r\n            logger.error(\"received an unparsable sdp attribute\", e);\r\n        }\r\n        MediaStream stream = initStream(connector, dev, supportedFormats.get(0), target, direction, rtpExtensions, masterStream);\r\n        if (stream != null) {\r\n            String rtcpxr;\r\n            try {\r\n                rtcpxr = mediaDescription.getAttribute(RTCPExtendedReport.SDP_ATTRIBUTE);\r\n            } catch (SdpException se) {\r\n                rtcpxr = null;\r\n            }\r\n            stream.setProperty(RTCPExtendedReport.SDP_ATTRIBUTE, rtcpxr);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.TestOperationSetPresence.testChangingStateToDnd",
	"Comment": "verify that changing state to dnd works as supposed to and that itgenerates the corresponding event.",
	"Method": "void testChangingStateToDnd(){\r\n    subtestStateTransition(JabberStatusEnum.DO_NOT_DISTURB);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.CallConference.onCallPeerEvent",
	"Comment": "notifies this telephony conference about a specificcallpeerevent i.e. that a callpeer was either added toor removed from a call.",
	"Method": "void onCallPeerEvent(CallPeerEvent ev){\r\n    Call call = ev.getSourceCall();\r\n    if (containsCall(call)) {\r\n        int eventID = ev.getEventID();\r\n        boolean conferenceFocus = isConferenceFocus(getCalls());\r\n        switch(eventID) {\r\n            case CallPeerEvent.CALL_PEER_ADDED:\r\n                if (conferenceFocus)\r\n                    setConferenceFocus(conferenceFocus);\r\n                break;\r\n            case CallPeerEvent.CALL_PEER_REMOVED:\r\n                if (!conferenceFocus)\r\n                    setConferenceFocus(conferenceFocus);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        try {\r\n            for (CallChangeListener l : getCallChangeListeners()) {\r\n                switch(eventID) {\r\n                    case CallPeerEvent.CALL_PEER_ADDED:\r\n                        l.callPeerAdded(ev);\r\n                        break;\r\n                    case CallPeerEvent.CALL_PEER_REMOVED:\r\n                        l.callPeerRemoved(ev);\r\n                        break;\r\n                    default:\r\n                        break;\r\n                }\r\n            }\r\n        } finally {\r\n            CallPeer callPeer = ev.getSourceCallPeer();\r\n            switch(eventID) {\r\n                case CallPeerEvent.CALL_PEER_ADDED:\r\n                    callPeer.addCallPeerConferenceListener(callPeerConferenceListener);\r\n                    break;\r\n                case CallPeerEvent.CALL_PEER_REMOVED:\r\n                    callPeer.removeCallPeerConferenceListener(callPeerConferenceListener);\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageHistoryServiceImpl.findByStartDate",
	"Comment": "returns all the messages exchanged in the suppliedchat room after the given date",
	"Method": "Collection<EventObject> findByStartDate(MetaContact contact,Date startDate,Collection<EventObject> findByStartDate,ChatRoom room,Date startDate){\r\n    HashSet<EventObject> result = new HashSet<EventObject>();\r\n    try {\r\n        HistoryReader reader = this.getHistoryForMultiChat(room).getReader();\r\n        addHistorySearchProgressListeners(reader, 1);\r\n        Iterator<HistoryRecord> recs = reader.findByStartDate(startDate);\r\n        while (recs.hasNext()) {\r\n            result.add(convertHistoryRecordToMessageEvent(recs.next(), room));\r\n        }\r\n        removeHistorySearchProgressListeners(reader);\r\n    } catch (IOException e) {\r\n        logger.error(\"Could not read history\", e);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactListServiceImpl.loadStoredContactGroup",
	"Comment": "creates a unresolved instance of the proto specific contact groupaccording to the specified arguments and adds it tocontainingmetacontactgroup",
	"Method": "ContactGroup loadStoredContactGroup(MetaContactGroupImpl containingMetaGroup,String contactGroupUID,ContactGroup parentProtoGroup,String persistentData,String accountID){\r\n    ProtocolProviderService sourceProvider = currentlyInstalledProviders.get(accountID);\r\n    OperationSetPersistentPresence presenceOpSet = sourceProvider.getOperationSet(OperationSetPersistentPresence.class);\r\n    ContactGroup newProtoGroup = presenceOpSet.createUnresolvedContactGroup(contactGroupUID, persistentData, (parentProtoGroup == null) ? presenceOpSet.getServerStoredContactListRoot() : parentProtoGroup);\r\n    containingMetaGroup.addProtoGroup(newProtoGroup);\r\n    return newProtoGroup;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.ChatRoomProviderWrapperImpl.getSystemRoomWrapper",
	"Comment": "returns the system room wrapper corresponding to this server.",
	"Method": "ChatRoomWrapper getSystemRoomWrapper(){\r\n    return systemRoomWrapper;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.SingleCallInProgressPolicy.addCallListener",
	"Comment": "registers a specific call with this policy in order to have therules of the latter apply to the former.",
	"Method": "void addCallListener(Call call){\r\n    if (logger.isTraceEnabled()) {\r\n        logger.trace(\"Add call change listener\");\r\n    }\r\n    synchronized (calls) {\r\n        if (!calls.contains(call)) {\r\n            CallState callState = call.getCallState();\r\n            if ((callState != null) && !callState.equals(CallState.CALL_ENDED)) {\r\n                calls.add(call);\r\n            }\r\n        }\r\n    }\r\n    call.addCallChangeListener(listener);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.mailnotification.MailboxIQ.setResultTime",
	"Comment": "sets the time these results were generated, in milliseconds since theunix epoch.",
	"Method": "void setResultTime(long l){\r\n    this.resultTime = l;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.msoutlook.MsOutlookAddrBookContactQuery.insertedOrUpdated",
	"Comment": "callback method when receiving notifications for updated items.",
	"Method": "void insertedOrUpdated(String id,int maxLevel){\r\n    SourceContact sourceContact = findSourceContactByID(id, maxLevel);\r\n    if (sourceContact != null && sourceContact instanceof MsOutlookAddrBookSourceContact) {\r\n        ((MsOutlookAddrBookSourceContact) sourceContact).updated();\r\n        fireContactChanged(sourceContact);\r\n    } else {\r\n        try {\r\n            onMailUser(id);\r\n        } catch (MsOutlookMAPIHResultException e) {\r\n            if (logger.isDebugEnabled()) {\r\n                logger.debug(MsOutlookAddrBookContactQuery.class.getSimpleName() + \"#onMailUser(String)\", e);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.runner.XmlFormatter.addError",
	"Comment": "interface testlistener.an error occurred while running the test.",
	"Method": "void addError(Test test,Throwable t){\r\n    formatError(ERROR, test, t);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.contactsource.GenericSourceContact.getPreferredContactDetail",
	"Comment": "gets the preferred contactdetail for a specificoperationset.",
	"Method": "ContactDetail getPreferredContactDetail(Class<? extends OperationSet> operationSet){\r\n    List<ContactDetail> contactDetails = getContactDetails(operationSet);\r\n    return contactDetails.isEmpty() ? null : contactDetails.get(0);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetAdHocMultiUserChatIcqImpl.removeInvitationListener",
	"Comment": "removes listener from the list of invitation listenersregistered to receive invitation events.",
	"Method": "void removeInvitationListener(AdHocChatRoomInvitationListener listener){\r\n    synchronized (invitationListeners) {\r\n        invitationListeners.remove(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.conference.BasicConferenceCallPanel.addDelayedCallPeer",
	"Comment": "creates a timer for the call peer and adds the timer and the call peer todelayedcallpeers list.",
	"Method": "void addDelayedCallPeer(CallPeer peer){\r\n    Timer timer = new Timer(5000, new ActionListener() {\r\n        public void actionPerformed(ActionEvent event) {\r\n            removeDelayedCallPeer(peer, false);\r\n            updateViewFromModel();\r\n        }\r\n    });\r\n    synchronized (delayedCallPeers) {\r\n        delayedCallPeers.put(peer, timer);\r\n    }\r\n    timer.setRepeats(false);\r\n    timer.start();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.conference.BasicConferenceCallPanel.addDelayedCallPeer",
	"Comment": "creates a timer for the call peer and adds the timer and the call peer todelayedcallpeers list.",
	"Method": "void addDelayedCallPeer(CallPeer peer){\r\n    removeDelayedCallPeer(peer, false);\r\n    updateViewFromModel();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.messagecorrection.MessageCorrectionExtension.getCorrectedMessageUID",
	"Comment": "returns the correctedmessageuid the uid of the message being corrected.",
	"Method": "String getCorrectedMessageUID(){\r\n    return correctedMessageUID;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl.processInviteOK",
	"Comment": "sets our state to connected, sends an ack and processes the sdpdescription in the ok response.",
	"Method": "void processInviteOK(ClientTransaction clientTransaction,Response ok){\r\n    try {\r\n        getProtocolProvider().sendAck(clientTransaction);\r\n    } catch (InvalidArgumentException ex) {\r\n        logAndFail(\"Error creating an ACK (CSeq?)\", ex);\r\n        return;\r\n    } catch (SipException ex) {\r\n        logAndFail(\"Failed to create ACK request!\", ex);\r\n        return;\r\n    }\r\n    try {\r\n        if (!CallPeerState.CONNECTING_WITH_EARLY_MEDIA.equals(getState())) {\r\n            getMediaHandler().processAnswer(SdpUtils.getContentAsString(ok));\r\n        }\r\n    } catch (Exception exc) {\r\n        logger.error(\"There was an error parsing the SDP description of \" + getDisplayName() + \"(\" + getAddress() + \")\", exc);\r\n        try {\r\n            setState(CallPeerState.CONNECTED, \"Error:\" + exc.getLocalizedMessage());\r\n            hangup();\r\n        } catch (Exception e) {\r\n        } finally {\r\n            logAndFail(\"Remote party sent a faulty session description.\", exc);\r\n        }\r\n        return;\r\n    }\r\n    if (!CallPeerState.isOnHold(getState())) {\r\n        setState(CallPeerState.CONNECTED);\r\n        getMediaHandler().start();\r\n        if (this.getCall() != null && isMute() != this.getCall().isMute()) {\r\n            setMute(this.getCall().isMute());\r\n        }\r\n    }\r\n    fireResponseProcessed(ok, null);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.notifsource.NotificationContact.getContactNode",
	"Comment": "returns the corresponding contactnode. the contactnodeis the real node that is stored in the contact list component data model.",
	"Method": "ContactNode getContactNode(){\r\n    return contactNode;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.history.OrderedQueryResultSet.hasPrev",
	"Comment": "returns true if the iteration has elements preceeding the current one.",
	"Method": "boolean hasPrev(){\r\n    return this.currentPos - 1 >= 0;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageHistoryActivator.getResources",
	"Comment": "returns the resourcemanagementservice, through which we willaccess all resources.",
	"Method": "ResourceManagementService getResources(){\r\n    if (resourcesService == null) {\r\n        resourcesService = ServiceUtils.getService(bundleContext, ResourceManagementService.class);\r\n    }\r\n    return resourcesService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl.processTransactionTerminated",
	"Comment": "process an asynchronously reported transactionterminatedevent.",
	"Method": "boolean processTransactionTerminated(TransactionTerminatedEvent transactionTerminatedEvent){\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractOperationSetDesktopSharingClient.fireRemoteControlGranted",
	"Comment": "fires a remotecontrolgrantedevent to all registered listeners.",
	"Method": "void fireRemoteControlGranted(CallPeer peer){\r\n    RemoteControlListener listener = getListener(peer);\r\n    if (listener != null) {\r\n        listener.remoteControlGranted(new RemoteControlGrantedEvent(peer));\r\n    } else {\r\n        this.removesNullAndRevokedControlPeer(peer.getPeerID());\r\n        synchronized (this.grantedRemoteControlPeers) {\r\n            this.grantedRemoteControlPeers.add(peer);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.contactinfo.ContactInfoActivator.getImageLoaderService",
	"Comment": "returns the imageloaderservice instance, if missing query osgi for it.",
	"Method": "ImageLoaderService<?> getImageLoaderService(){\r\n    if (imageLoaderService == null) {\r\n        imageLoaderService = ServiceUtils.getService(bundleContext, ImageLoaderService.class);\r\n    }\r\n    return imageLoaderService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.icqaccregwizz.IcqAccRegWizzActivator.getIcqProtocolProviderFactory",
	"Comment": "returns the protocolproviderfactory for the icq protocol.",
	"Method": "ProtocolProviderFactory getIcqProtocolProviderFactory(){\r\n    ServiceReference[] serRefs = null;\r\n    String osgiFilter = \"(\" + ProtocolProviderFactory.PROTOCOL + \"=\" + ProtocolNames.ICQ + \")\";\r\n    try {\r\n        serRefs = bundleContext.getServiceReferences(ProtocolProviderFactory.class.getName(), osgiFilter);\r\n    } catch (InvalidSyntaxException ex) {\r\n        logger.error(\"IcqAccRegWizzActivator : \" + ex);\r\n    }\r\n    return (ProtocolProviderFactory) bundleContext.getService(serRefs[0]);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallManager.getActiveCallContainer",
	"Comment": "returns the callcontainer corresponding to the givencall. if the call has been finished and no activecallcontainer could be found it returns null.",
	"Method": "CallPanel getActiveCallContainer(Call call){\r\n    return findCallPanel(call.getConference());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.replacement.smiley.SmileyImpl.getImageID",
	"Comment": "returns the identifier of the image corresponding to this smiley.",
	"Method": "String getImageID(){\r\n    return imageID;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipRegistrarConnection.processIntervalTooBrief",
	"Comment": "process error 423 interval too brief. if there is minimum intervalspecified use it. check the specified interval is greater than the onewe used in our register.",
	"Method": "void processIntervalTooBrief(Response response){\r\n    MinExpiresHeader header = (MinExpiresHeader) response.getHeader(MinExpiresHeader.NAME);\r\n    if (header != null) {\r\n        int expires = header.getExpires();\r\n        if (expires > registrationsExpiration) {\r\n            registrationsExpiration = expires;\r\n            try {\r\n                register();\r\n                return;\r\n            } catch (Throwable e) {\r\n                logger.error(\"Cannot send register!\", e);\r\n                setRegistrationState(RegistrationState.CONNECTION_FAILED, RegistrationStateChangeEvent.REASON_NOT_SPECIFIED, \"A timeout occurred while trying to \" + \"connect to the server.\");\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    this.setRegistrationState(RegistrationState.CONNECTION_FAILED, RegistrationStateChangeEvent.REASON_NOT_SPECIFIED, \"Received an error while trying to register. \" + \"Server returned error:\" + response.getReasonPhrase());\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.chatalerter.ChatAlerterActivator.serviceChanged",
	"Comment": "when new protocol provider is registered we checkdoes it supports needed op. sets and if so add a listener to it",
	"Method": "void serviceChanged(ServiceEvent serviceEvent){\r\n    Object sService = bundleContext.getService(serviceEvent.getServiceReference());\r\n    if (logger.isTraceEnabled())\r\n        logger.trace(\"Received a service event for: \" + sService.getClass().getName());\r\n    if (!(sService instanceof ProtocolProviderService))\r\n        return;\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Service is a protocol provider.\");\r\n    switch(serviceEvent.getType()) {\r\n        case ServiceEvent.REGISTERED:\r\n            this.handleProviderAdded((ProtocolProviderService) sService);\r\n            break;\r\n        case ServiceEvent.UNREGISTERING:\r\n            this.handleProviderRemoved((ProtocolProviderService) sService);\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.UtilActivator.getMediaService",
	"Comment": "returns an instance of the mediaservice obtained from thebundle context.",
	"Method": "MediaService getMediaService(){\r\n    if (mediaService == null) {\r\n        mediaService = ServiceUtils.getService(bundleContext, MediaService.class);\r\n    }\r\n    return mediaService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chatroomslist.createforms.CreateChatRoomWizardPage2.getNextPageIdentifier",
	"Comment": "implements the wizardpaneldescriptor method to return theidentifier of the next wizard page.",
	"Method": "Object getNextPageIdentifier(){\r\n    return WizardPage.FINISH_PAGE_IDENTIFIER;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.sipaccregwizz.SIPAccountRegistrationWizard.getLastPageIdentifier",
	"Comment": "returns the identifier of the page to show last in the wizard.",
	"Method": "Object getLastPageIdentifier(){\r\n    return firstWizardPage.getIdentifier();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatManager.localUserPresenceChanged",
	"Comment": "implements thelocaluserchatroompresencelistener.localuserpresencechangedmethod.",
	"Method": "void localUserPresenceChanged(LocalUserChatRoomPresenceChangeEvent evt){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                localUserPresenceChanged(evt);\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    ChatRoom sourceChatRoom = evt.getChatRoom();\r\n    ChatRoomWrapper chatRoomWrapper = GuiActivator.getMUCService().findChatRoomWrapperFromChatRoom(sourceChatRoom);\r\n    String eventType = evt.getEventType();\r\n    if (LocalUserChatRoomPresenceChangeEvent.LOCAL_USER_JOINED.equals(eventType)) {\r\n        if (chatRoomWrapper != null) {\r\n            GuiActivator.getMUCService().fireChatRoomListChangedEvent(chatRoomWrapper, ChatRoomListChangeEvent.CHAT_ROOM_CHANGED);\r\n            boolean createWindow = false;\r\n            String autoOpenConfig = MUCService.getChatRoomAutoOpenOption(sourceChatRoom.getParentProvider(), sourceChatRoom.getIdentifier());\r\n            if (autoOpenConfig != null && autoOpenConfig.equals(MUCService.OPEN_ON_ACTIVITY))\r\n                createWindow = true;\r\n            ChatWindowManager chatWindowManager = GuiActivator.getUIService().getChatWindowManager();\r\n            ChatPanel chatPanel = chatWindowManager.getMultiChat(chatRoomWrapper, createWindow);\r\n            if (chatPanel != null) {\r\n                chatPanel.setChatIcon(chatPanel.getChatSession().getChatStatusIcon());\r\n                if (chatPanel.isShown()) {\r\n                    ((ConferenceChatSession) chatPanel.getChatSession()).loadChatRoom(sourceChatRoom);\r\n                } else {\r\n                    chatWindowManager.openChat(chatPanel, true);\r\n                }\r\n            }\r\n        }\r\n        if (sourceChatRoom.isSystem()) {\r\n            ChatRoomProviderWrapper serverWrapper = GuiActivator.getMUCService().findServerWrapperFromProvider(sourceChatRoom.getParentProvider());\r\n            serverWrapper.setSystemRoom(sourceChatRoom);\r\n        }\r\n        sourceChatRoom.addMessageListener(this);\r\n        sourceChatRoom.addLocalUserRoleListener(this);\r\n    } else if (LocalUserChatRoomPresenceChangeEvent.LOCAL_USER_JOIN_FAILED.equals(eventType)) {\r\n        GuiActivator.getAlertUIService().showAlertPopup(GuiActivator.getResources().getI18NString(\"service.gui.ERROR\"), GuiActivator.getResources().getI18NString(\"service.gui.FAILED_TO_JOIN_CHAT_ROOM\", new String[] { sourceChatRoom.getName() }) + evt.getReason());\r\n    } else if (LocalUserChatRoomPresenceChangeEvent.LOCAL_USER_LEFT.equals(eventType) || LocalUserChatRoomPresenceChangeEvent.LOCAL_USER_KICKED.equals(eventType) || LocalUserChatRoomPresenceChangeEvent.LOCAL_USER_DROPPED.equals(eventType)) {\r\n        if (chatRoomWrapper != null) {\r\n            if (StringUtils.isNullOrEmpty(evt.getReason())) {\r\n                GuiActivator.getUIService().closeChatRoomWindow(chatRoomWrapper);\r\n            } else {\r\n                ChatWindowManager chatWindowManager = GuiActivator.getUIService().getChatWindowManager();\r\n                ChatPanel chatPanel = chatWindowManager.getMultiChat(sourceChatRoom, false);\r\n                if (chatPanel != null) {\r\n                    chatPanel.addMessage(sourceChatRoom.getName(), null, new Date(), Chat.SYSTEM_MESSAGE, evt.getReason(), OperationSetBasicInstantMessaging.DEFAULT_MIME_TYPE, null, null);\r\n                    if (!StringUtils.isNullOrEmpty(evt.getAlternateAddress())) {\r\n                        chatPanel.addMessage(sourceChatRoom.getName(), null, new Date(), Chat.SYSTEM_MESSAGE, GuiActivator.getResources().getI18NString(\"service.gui.CHAT_ROOM_ALTERNATE_ADDRESS\", new String[] { evt.getAlternateAddress() }), OperationSetBasicInstantMessaging.DEFAULT_MIME_TYPE, null, null);\r\n                    }\r\n                }\r\n            }\r\n            GuiActivator.getMUCService().fireChatRoomListChangedEvent(chatRoomWrapper, ChatRoomListChangeEvent.CHAT_ROOM_CHANGED);\r\n        }\r\n        sourceChatRoom.removeMessageListener(this);\r\n        sourceChatRoom.removelocalUserRoleListener(this);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatManager.localUserPresenceChanged",
	"Comment": "implements thelocaluserchatroompresencelistener.localuserpresencechangedmethod.",
	"Method": "void localUserPresenceChanged(LocalUserChatRoomPresenceChangeEvent evt){\r\n    localUserPresenceChanged(evt);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler.requestKeyFrame",
	"Comment": "requests a key frame from the remote peer of the associatedvideomediastream of this callpeermediahandler. thedefault implementation provided by callpeermediahandler alwaysreturns false.",
	"Method": "boolean requestKeyFrame(){\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.lookandfeel.SIPCommCallComboBoxUI.createUI",
	"Comment": "creates an instance of the sipcommcallcomboboxui for the givencomponent.",
	"Method": "ComponentUI createUI(JComponent c){\r\n    return new SIPCommCallComboBoxUI();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactGroupImpl.countContactGroups",
	"Comment": "returns the number of contactgroupss that this groupencapsulates",
	"Method": "int countContactGroups(){\r\n    return protoGroups.size();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.securityconfig.SecurityConfigActivator.getConfigurationService",
	"Comment": "returns a reference to the configurationservice implementation currentlyregistered in the bundle context or null if no such implementation wasfound.",
	"Method": "ConfigurationService getConfigurationService(){\r\n    if (configurationService == null) {\r\n        configurationService = ServiceUtils.getService(bundleContext, ConfigurationService.class);\r\n    }\r\n    return configurationService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.MainFrame.setFrameVisible",
	"Comment": "implements setvisible in the uiservice interface. shows orhides the main application window depending on the parametervisible.",
	"Method": "void setFrameVisible(boolean isVisible){\r\n    ConfigurationUtils.setApplicationVisible(isVisible);\r\n    SwingUtilities.invokeLater(new Runnable() {\r\n        public void run() {\r\n            if (isVisible) {\r\n                MainFrame.this.addNativePlugins();\r\n                Window focusedWindow = keyManager.getFocusedWindow();\r\n                if (focusedWindow != null)\r\n                    setFocusableWindowState(false);\r\n                MainFrame.super.setVisible(isVisible);\r\n                if (focusedWindow != null)\r\n                    setFocusableWindowState(true);\r\n                MainFrame.super.setExtendedState(MainFrame.NORMAL);\r\n                MainFrame.super.toFront();\r\n            } else {\r\n                MainFrame.super.setVisible(isVisible);\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.MainFrame.setFrameVisible",
	"Comment": "implements setvisible in the uiservice interface. shows orhides the main application window depending on the parametervisible.",
	"Method": "void setFrameVisible(boolean isVisible){\r\n    if (isVisible) {\r\n        MainFrame.this.addNativePlugins();\r\n        Window focusedWindow = keyManager.getFocusedWindow();\r\n        if (focusedWindow != null)\r\n            setFocusableWindowState(false);\r\n        MainFrame.super.setVisible(isVisible);\r\n        if (focusedWindow != null)\r\n            setFocusableWindowState(true);\r\n        MainFrame.super.setExtendedState(MainFrame.NORMAL);\r\n        MainFrame.super.toFront();\r\n    } else {\r\n        MainFrame.super.setVisible(isVisible);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.utils.ImageLoader.getImageUri",
	"Comment": "returns the uri corresponding to the image with the given imageidentifier.",
	"Method": "String getImageUri(ImageID imageID){\r\n    URL imageURL = GuiActivator.getResources().getImageURL(imageID.getId());\r\n    try {\r\n        if (imageURL != null)\r\n            return imageURL.toURI().toString();\r\n    } catch (URISyntaxException e) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Unable to parse image URL to URI.\", e);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipRegistrarConnection.processRequest",
	"Comment": "processes a request received on a sipprovider upon which this siplistener is registered.",
	"Method": "boolean processRequest(RequestEvent requestEvent){\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactListServiceImpl.createMetaContactGroup",
	"Comment": "creates a metacontactgroup with the specified group name.the meta contact group would only be created locally and resolvedagainst the different server stored protocol contact lists upon thecreation of the first protocol specific child contact in the respectivegroup.",
	"Method": "MetaContactGroup createMetaContactGroup(MetaContactGroup parent,String groupName){\r\n    if (!(parent instanceof MetaContactGroupImpl)) {\r\n        throw new IllegalArgumentException(parent + \" is not an instance of MetaContactGroupImpl\");\r\n    }\r\n    Iterator<MetaContactGroup> subgroups = parent.getSubgroups();\r\n    while (subgroups.hasNext()) {\r\n        MetaContactGroup group = subgroups.next();\r\n        if (group.getGroupName().equals(groupName)) {\r\n            throw new MetaContactListException(\"Parent \" + parent.getGroupName() + \" already contains a \" + \"group called \" + groupName, new CloneNotSupportedException(\"just testing nested exc-s\"), MetaContactListException.CODE_GROUP_ALREADY_EXISTS_ERROR);\r\n        }\r\n    }\r\n    MetaContactGroupImpl newMetaGroup = new MetaContactGroupImpl(this, groupName);\r\n    ((MetaContactGroupImpl) parent).addSubgroup(newMetaGroup);\r\n    fireMetaContactGroupEvent(newMetaGroup, null, null, MetaContactGroupEvent.META_CONTACT_GROUP_ADDED);\r\n    return newMetaGroup;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MclStorageManager.metaContactRenamed",
	"Comment": "changes the display name attribute of the specified meta contact node.",
	"Method": "void metaContactRenamed(MetaContactRenamedEvent evt){\r\n    Element metaContactNode = findMetaContactNode(evt.getSourceMetaContact().getMetaUID());\r\n    if (metaContactNode == null) {\r\n        logger.error(\"Save after renam failed. Contact not found: \" + evt.getSourceMetaContact());\r\n        return;\r\n    }\r\n    Element displayNameNode = XMLUtils.findChild(metaContactNode, META_CONTACT_DISPLAY_NAME_NODE_NAME);\r\n    if (((MetaContactImpl) evt.getSourceMetaContact()).isDisplayNameUserDefined()) {\r\n        displayNameNode.setAttribute(USER_DEFINED_DISPLAY_NAME_ATTR_NAME, Boolean.TRUE.toString());\r\n    } else {\r\n        displayNameNode.removeAttribute(USER_DEFINED_DISPLAY_NAME_ATTR_NAME);\r\n    }\r\n    XMLUtils.setText(displayNameNode, evt.getNewDisplayName());\r\n    updatePersistentDataForMetaContact(evt.getSourceMetaContact());\r\n    try {\r\n        scheduleContactListStorage();\r\n    } catch (IOException ex) {\r\n        logger.error(\"Writing CL failed after rename of \" + evt.getSourceMetaContact(), ex);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.provisioning.ProvisioningActivator.getProvisioningService",
	"Comment": "returns a reference to a provisioningservice implementation.",
	"Method": "ProvisioningServiceImpl getProvisioningService(){\r\n    return provisioningService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.exception.UnsupportedCommandException.getCommand",
	"Comment": "the unsupported command that is the reason for this exception.",
	"Method": "String getCommand(){\r\n    return this.command;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.ConfigurationUtils.findProviderFromAccountId",
	"Comment": "returns the protocol provider associated with the givenaccountid.",
	"Method": "ProtocolProviderService findProviderFromAccountId(String savedAccountId){\r\n    ProtocolProviderService protocolProvider = null;\r\n    for (ProtocolProviderFactory providerFactory : UtilActivator.getProtocolProviderFactories().values()) {\r\n        for (AccountID accountId : providerFactory.getRegisteredAccounts()) {\r\n            if (!accountId.getAccountUniqueID().equals(savedAccountId))\r\n                continue;\r\n            ServiceReference<ProtocolProviderService> serRef = providerFactory.getProviderForAccount(accountId);\r\n            protocolProvider = UtilActivator.bundleContext.getService(serRef);\r\n            if (protocolProvider != null)\r\n                break;\r\n        }\r\n    }\r\n    return protocolProvider;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.MainFrame.close",
	"Comment": "overwrites the sipcommframe close method. this method isinvoked when user presses the escape key.",
	"Method": "void close(boolean isEscaped){\r\n    TreeContactList contactList = GuiActivator.getContactList();\r\n    Component contactListRightMenu = contactList.getRightButtonMenu();\r\n    CommonRightButtonMenu commonPopupMenu = getContactListPanel().getCommonRightButtonMenu();\r\n    if (contactListRightMenu != null && contactListRightMenu.isVisible()) {\r\n        contactListRightMenu.setVisible(false);\r\n    } else if (commonPopupMenu != null && commonPopupMenu.isVisible()) {\r\n        commonPopupMenu.setVisible(false);\r\n    } else if (accountStatusPanel.hasSelectedMenus() || menu.hasSelectedMenus()) {\r\n        MenuSelectionManager selectionManager = MenuSelectionManager.defaultManager();\r\n        selectionManager.clearSelectedPath();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.AccountStatusPanel.containsAccount",
	"Comment": "checks if an account corresponding to the given protocolprovideris contained in the contained status combo box.",
	"Method": "boolean containsAccount(ProtocolProviderService protocolProvider){\r\n    return statusComboBox.containsAccount(protocolProvider);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.notificationconfiguration.NotificationEntry.setSoundNotification",
	"Comment": "method which set a boolean to true a sound is playing for thenotification.",
	"Method": "void setSoundNotification(boolean sound){\r\n    this.soundNotification = sound;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.sipaccregwizz.PresencePanel.setClistOptionUseSipCredentialsEnabled",
	"Comment": "enables or disable contact list credentials related options.",
	"Method": "void setClistOptionUseSipCredentialsEnabled(boolean isEnabled){\r\n    clistOptionUserValue.setEnabled(!isEnabled);\r\n    clistOptionPasswordValue.setEnabled(!isEnabled);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.GlobalStatusSelectorBox.hasAvailableStatuses",
	"Comment": "check for available statuses we have in the menu.all except online and offline one.",
	"Method": "boolean hasAvailableStatuses(){\r\n    for (GlobalStatusEnum status : GlobalStatusEnum.globalStatusSet) {\r\n        if (status.equals(GlobalStatusEnum.OFFLINE) || status.equals(GlobalStatusEnum.ONLINE))\r\n            continue;\r\n        if (getItemFromStatus(status) != null)\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ServerStoredContactListXivoImpl.init",
	"Comment": "initializes the server stored list. synchronize server stored groups andcontacts with the local groups and contacts.",
	"Method": "void init(){\r\n    try {\r\n        SipAccountIDImpl accountID = (SipAccountIDImpl) sipProvider.getAccountID();\r\n        if (!accountID.isXiVOEnable())\r\n            return;\r\n        boolean useSipCredentials = accountID.isClistOptionUseSipCredentials();\r\n        String serverAddress = accountID.getClistOptionServerUri();\r\n        String username = accountID.getAccountPropertyString(ProtocolProviderFactory.USER_ID);\r\n        Address userAddress = sipProvider.parseAddressString(username);\r\n        if (useSipCredentials) {\r\n            username = ((SipUri) userAddress.getURI()).getUser();\r\n        } else {\r\n            username = accountID.getClistOptionUser();\r\n        }\r\n        try {\r\n            connect(serverAddress);\r\n        } catch (Throwable ex) {\r\n            showError(ex, null, null);\r\n            logger.error(\"Error connecting to server\", ex);\r\n            return;\r\n        }\r\n        Thread thread = new Thread(this, this.getClass().getName());\r\n        thread.setDaemon(true);\r\n        thread.start();\r\n        if (!login(username)) {\r\n            showError(null, null, \"Unauthorized. Cannot login.\");\r\n            logger.error(\"Cannot login.\");\r\n            return;\r\n        }\r\n    } catch (Throwable t) {\r\n        logger.error(\"Error init clist from xivo server\");\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.connectioninfo.ConnectionInfoPanel.getAccountsComboBox",
	"Comment": "returns the combo box that switches between account detail panels.",
	"Method": "JComboBox getAccountsComboBox(){\r\n    return accountsComboBox;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractCallPeer.fireCallPeerSecurityOffEvent",
	"Comment": "constructs a callpeersecuritystatusevent using this call peer assource, setting it to be of type eventtype and the correspondingoldvalue and newvalue.",
	"Method": "void fireCallPeerSecurityOffEvent(CallPeerSecurityOffEvent evt){\r\n    lastSecurityEvent = evt;\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Dispatching a CallPeerSecurityAuthenticationEvent event to \" + callPeerSecurityListeners.size() + \" listeners. event is: \" + evt.toString());\r\n    List<CallPeerSecurityListener> listeners = null;\r\n    synchronized (callPeerSecurityListeners) {\r\n        listeners = new ArrayList<CallPeerSecurityListener>(callPeerSecurityListeners);\r\n    }\r\n    for (CallPeerSecurityListener listener : listeners) {\r\n        listener.securityOff(evt);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.ContactGibberishImpl.getPersistentData",
	"Comment": "returns null as no persistent data is required and the contact address issufficient for restoring the contact.",
	"Method": "String getPersistentData(){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallSipImpl.extractRequestHeaders",
	"Comment": "extracts all headers from the request and return them in a map.",
	"Method": "Map<String, String> extractRequestHeaders(Request req){\r\n    Map<String, String> headers = new HashMap();\r\n    for (Iterator<String> headerNameIter = req.getHeaderNames(); headerNameIter.hasNext(); ) {\r\n        String name = headerNameIter.next();\r\n        SIPHeader header = (SIPHeader) req.getHeader(name);\r\n        if (header != null)\r\n            headers.put(name, header.getValue());\r\n    }\r\n    return headers;\r\n}"
}, {
	"Path": "net.librec.math.structure.VectorBasedSequentialSparseVector.getVectorEntryAtPosition",
	"Comment": "return an object of vector.vectorentry representing an entry of this vector. useful when designing new iteratortypes.",
	"Method": "VectorEntry getVectorEntryAtPosition(int position){\r\n    SparseVectorEntry vectorEntry = new SparseVectorEntry();\r\n    vectorEntry.position = position;\r\n    return vectorEntry;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.addChatHistoryListener",
	"Comment": "adds the given chathistorylistener to the list of listenersnotified when a change occurs in the history shown in this chat panel.",
	"Method": "void addChatHistoryListener(ChatHistoryListener l){\r\n    synchronized (historyListeners) {\r\n        historyListeners.add(l);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetAdHocMultiUserChatIcqImpl.addPresenceListener",
	"Comment": "adds a listener that will be notified of changes in our status in a chatroom such as us being kicked, banned or dropped.",
	"Method": "void addPresenceListener(LocalUserAdHocChatRoomPresenceListener listener){\r\n    synchronized (presenceListeners) {\r\n        if (!presenceListeners.contains(listener))\r\n            presenceListeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactListServiceImpl.isGroupInEventIgnoreList",
	"Comment": "verifies whether the specified group is in the group event ignore list.",
	"Method": "boolean isGroupInEventIgnoreList(String group,ProtocolProviderService ownerProvider){\r\n    List<ProtocolProviderService> existingProvList = this.groupEventIgnoreList.get(group);\r\n    return existingProvList != null && existingProvList.contains(ownerProvider);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.conference.ConferencePeerPanel.printDTMFTone",
	"Comment": "prints the given dtmg character through this callpeerrenderer.",
	"Method": "void printDTMFTone(char dtmfChar){\r\n    dtmfLabel.setText(dtmfLabel.getText() + dtmfChar);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.notificationwiring.NotificationManager.callPeerRemoved",
	"Comment": "implements the callchangelistener.callpeerremoved method.",
	"Method": "void callPeerRemoved(CallPeerEvent evt){\r\n    CallPeer peer = evt.getSourceCallPeer();\r\n    if (peer == null)\r\n        return;\r\n    peer.removeCallPeerListener(this);\r\n    peer.removeCallPeerSecurityListener(this);\r\n    peer.addCallPeerConferenceListener(this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.googlecontacts.GoogleContactsSourceService.setGoogleTalk",
	"Comment": "set whether or not the account has been created via googletalk wizard orexternal google contacts.",
	"Method": "void setGoogleTalk(boolean googleTalk){\r\n    this.googleTalk = googleTalk;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.lookandfeel.SIPCommCallComboBoxUI.installComponents",
	"Comment": "creates and initializes the components which make up theaggregate combo box. this method is called as part of the uiinstallation process.",
	"Method": "void installComponents(){\r\n    if (arrowButton != null)\r\n        configureArrowButton();\r\n    if (comboBox.isEditable())\r\n        addEditor();\r\n    comboBox.add(currentValuePane);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.gibberish.TestOperationSetBasicInstantMessaging.prepareContactList",
	"Comment": "create the list to be sure that contacts exchanging messagesexists in each other lists",
	"Method": "void prepareContactList(){\r\n    fixture.clearProvidersLists();\r\n    Object o = new Object();\r\n    synchronized (o) {\r\n        o.wait(2000);\r\n    }\r\n    try {\r\n        opSetPresence1.subscribe(fixture.userID2);\r\n    } catch (OperationFailedException ex) {\r\n    }\r\n    try {\r\n        opSetPresence2.subscribe(fixture.userID1);\r\n    } catch (OperationFailedException ex1) {\r\n    }\r\n    synchronized (o) {\r\n        o.wait(2000);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chatroomslist.ChatRoomTableDialog.showChatRoomTableDialog",
	"Comment": "shows a chatroomtabledialog creating it first if necessary.the shown instance is shared in order to prevent displaying multipleinstances of one and the same chatroomtabledialog.",
	"Method": "void showChatRoomTableDialog(){\r\n    if (chatRoomTableDialog == null) {\r\n        chatRoomTableDialog = new ChatRoomTableDialog(GuiActivator.getUIService().getMainFrame());\r\n        chatRoomTableDialog.addWindowListener(new WindowAdapter() {\r\n            @Override\r\n            public void windowClosed(WindowEvent e) {\r\n                if (chatRoomTableDialog == e.getWindow())\r\n                    chatRoomTableDialog = null;\r\n            }\r\n        });\r\n    }\r\n    chatRoomTableDialog.setVisible(true);\r\n    chatRoomTableDialog.pack();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chatroomslist.ChatRoomTableDialog.showChatRoomTableDialog",
	"Comment": "shows a chatroomtabledialog creating it first if necessary.the shown instance is shared in order to prevent displaying multipleinstances of one and the same chatroomtabledialog.",
	"Method": "void showChatRoomTableDialog(){\r\n    if (chatRoomTableDialog == e.getWindow())\r\n        chatRoomTableDialog = null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.msoutlook.MsOutlookAddrBookSourceContact.unlock",
	"Comment": "unlocks this object before after or removing several contact details.",
	"Method": "void unlock(){\r\n    synchronized (this) {\r\n        this.save();\r\n        locked = Boolean.FALSE;\r\n        notify();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.RawUdpTransportManager.getNbHarvesting",
	"Comment": "returns the number of harvesting time for the harvester given inparameter.",
	"Method": "int getNbHarvesting(int getNbHarvesting,String harvesterName){\r\n    return 0;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.UIServiceImpl.setLocation",
	"Comment": "locates the main application window to the new x and y coordinates.",
	"Method": "void setLocation(int x,int y){\r\n    mainFrame.setLocation(x, y);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.filehistory.FileHistoryServiceImpl.findFirstRecordsAfter",
	"Comment": "returns the supplied number of recent file transfers after the given date",
	"Method": "Collection<FileRecord> findFirstRecordsAfter(MetaContact contact,Date date,int count){\r\n    TreeSet<FileRecord> result = new TreeSet<FileRecord>(new FileRecordComparator());\r\n    Map<Contact, HistoryReader> readers = getHistoryReaders(contact);\r\n    for (Map.Entry<Contact, HistoryReader> readerEntry : readers.entrySet()) {\r\n        Contact c = readerEntry.getKey();\r\n        HistoryReader reader = readerEntry.getValue();\r\n        Iterator<HistoryRecord> recs = reader.findFirstRecordsAfter(date, count);\r\n        while (recs.hasNext()) {\r\n            result.add(createFileRecordFromHistoryRecord(recs.next(), c));\r\n        }\r\n    }\r\n    LinkedList<FileRecord> resultAsList = new LinkedList<FileRecord>(result);\r\n    int toIndex = count;\r\n    if (toIndex > resultAsList.size())\r\n        toIndex = resultAsList.size();\r\n    return resultAsList.subList(0, toIndex);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ChatConferenceCallsListModels.addElement",
	"Comment": "adds a specific conferencedescription to this model implementation.",
	"Method": "void addElement(ConferenceDescription chatConference){\r\n    if (chatConference == null)\r\n        throw new IllegalArgumentException(\"ConferenceDescription\");\r\n    int index = -1;\r\n    synchronized (chatConferenceCalls) {\r\n        int chatContactCount = chatConferenceCalls.size();\r\n        if (findConferenceDescription(chatConference) != -1)\r\n            return;\r\n        index = chatContactCount;\r\n        chatConferenceCalls.add(index, chatConference);\r\n    }\r\n    fireIntervalAdded(this, index, index);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.update.UpdateActivator.calcHoursToWait",
	"Comment": "calculate the number of hour to wait until the first scheduled updatecheck.this will only be called if daily checking for config updatesis enabled",
	"Method": "int calcHoursToWait(){\r\n    return 24 - Calendar.getInstance().get(Calendar.HOUR_OF_DAY) + configuration.getInt(CHECK_FOR_UPDATES_DAILY_TIME_PROP, 0);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ChatConferenceCallsListModels.removeElement",
	"Comment": "removes a specific conferencedescription from this model implementation.",
	"Method": "void removeElement(ConferenceDescription chatConference){\r\n    synchronized (chatConferenceCalls) {\r\n        int index = findConferenceDescription(chatConference);\r\n        if (index >= 0) {\r\n            chatConferenceCalls.remove(index);\r\n            fireIntervalRemoved(this, index, index);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl.getContactHeader",
	"Comment": "returns a contact header containing a sip uri based on a localhostaddress and therefore usable in register requests only.",
	"Method": "ContactHeader getContactHeader(Address intendedDestination,ContactHeader getContactHeader,SipURI intendedDestination){\r\n    ContactHeader registrationContactHeader = null;\r\n    ListeningPoint srcListeningPoint = getListeningPoint(intendedDestination);\r\n    InetSocketAddress targetAddress = getIntendedDestination(intendedDestination);\r\n    try {\r\n        InetAddress localAddress = SipActivator.getNetworkAddressManagerService().getLocalHost(targetAddress.getAddress());\r\n        SipURI contactURI = addressFactory.createSipURI(getAccountID().getUserID(), localAddress.getHostAddress());\r\n        String transport = srcListeningPoint.getTransport();\r\n        contactURI.setTransportParam(transport);\r\n        int localPort = srcListeningPoint.getPort();\r\n        if (ListeningPoint.TCP.equalsIgnoreCase(transport) || ListeningPoint.TLS.equalsIgnoreCase(transport)) {\r\n            InetSocketAddress localSockAddr = sipStackSharing.getLocalAddressForDestination(targetAddress.getAddress(), targetAddress.getPort(), localAddress, transport);\r\n            localPort = localSockAddr.getPort();\r\n        }\r\n        contactURI.setPort(localPort);\r\n        String paramValue = getContactAddressCustomParamValue();\r\n        if (paramValue != null) {\r\n            contactURI.setParameter(SipStackSharing.CONTACT_ADDRESS_CUSTOM_PARAM_NAME, paramValue);\r\n        }\r\n        Address contactAddress = addressFactory.createAddress(contactURI);\r\n        String ourDisplayName = getOurDisplayName();\r\n        if (ourDisplayName != null) {\r\n            contactAddress.setDisplayName(ourDisplayName);\r\n        }\r\n        registrationContactHeader = headerFactory.createContactHeader(contactAddress);\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"generated contactHeader:\" + registrationContactHeader);\r\n    } catch (ParseException ex) {\r\n        logger.error(\"A ParseException occurred while creating From Header!\", ex);\r\n        throw new IllegalArgumentException(\"A ParseException occurred while creating From Header!\", ex);\r\n    } catch (java.io.IOException ex) {\r\n        logger.error(\"A ParseException occurred while creating From Header!\", ex);\r\n        throw new IllegalArgumentException(\"A ParseException occurred while creating From Header!\", ex);\r\n    }\r\n    return registrationContactHeader;\r\n}"
}, {
	"Path": "io.lettuce.core.protocol.RedisStateMachine.decode",
	"Comment": "attempt to decode a redis response and return a flag indicating whether a complete response was read.",
	"Method": "boolean decode(ByteBuf buffer,CommandOutput<?, ?, ?> output,boolean decode,ByteBuf buffer,RedisCommand<?, ?, ?> command,CommandOutput<?, ?, ?> output){\r\n    int length, end;\r\n    ByteBuffer bytes;\r\n    if (debugEnabled) {\r\n        logger.debug(\"Decode {}\", command);\r\n    }\r\n    if (isEmpty(stack)) {\r\n        add(stack, new State());\r\n    }\r\n    if (output == null) {\r\n        return isEmpty(stack);\r\n    }\r\n    loop: while (!isEmpty(stack)) {\r\n        State state = peek(stack);\r\n        if (state.type == null) {\r\n            if (!buffer.isReadable()) {\r\n                break;\r\n            }\r\n            state.type = readReplyType(buffer);\r\n            buffer.markReaderIndex();\r\n        }\r\n        switch(state.type) {\r\n            case SINGLE:\r\n                if ((bytes = readLine(buffer)) == null) {\r\n                    break loop;\r\n                }\r\n                if (!QUEUED.equals(bytes)) {\r\n                    safeSetSingle(output, bytes, command);\r\n                }\r\n                break;\r\n            case ERROR:\r\n                if ((bytes = readLine(buffer)) == null) {\r\n                    break loop;\r\n                }\r\n                safeSetError(output, bytes, command);\r\n                break;\r\n            case INTEGER:\r\n                if ((end = findLineEnd(buffer)) == -1) {\r\n                    break loop;\r\n                }\r\n                long integer = readLong(buffer, buffer.readerIndex(), end);\r\n                safeSet(output, integer, command);\r\n                break;\r\n            case BULK:\r\n                if ((end = findLineEnd(buffer)) == -1) {\r\n                    break loop;\r\n                }\r\n                length = (int) readLong(buffer, buffer.readerIndex(), end);\r\n                if (length == -1) {\r\n                    safeSet(output, null, command);\r\n                } else {\r\n                    state.type = BYTES;\r\n                    state.count = length + 2;\r\n                    buffer.markReaderIndex();\r\n                    continue loop;\r\n                }\r\n                break;\r\n            case MULTI:\r\n                if (state.count == -1) {\r\n                    if ((end = findLineEnd(buffer)) == -1) {\r\n                        break loop;\r\n                    }\r\n                    length = (int) readLong(buffer, buffer.readerIndex(), end);\r\n                    state.count = length;\r\n                    buffer.markReaderIndex();\r\n                    safeMulti(output, state.count, command);\r\n                }\r\n                if (state.count <= 0) {\r\n                    break;\r\n                }\r\n                state.count--;\r\n                addFirst(stack, new State());\r\n                continue loop;\r\n            case BYTES:\r\n                if ((bytes = readBytes(buffer, state.count)) == null) {\r\n                    break loop;\r\n                }\r\n                safeSet(output, bytes, command);\r\n                break;\r\n            default:\r\n                throw new IllegalStateException(\"State \" + state.type + \" not supported\");\r\n        }\r\n        buffer.markReaderIndex();\r\n        remove(stack);\r\n        output.complete(size(stack));\r\n    }\r\n    if (debugEnabled) {\r\n        logger.debug(\"Decoded {}, empty stack: {}\", command, isEmpty(stack));\r\n    }\r\n    return isEmpty(stack);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.EventPackageSubscriber.createSubscription",
	"Comment": "creates a new subscribe request in the form of aclienttransaction with the parameters of a specificsubscription.",
	"Method": "ClientTransaction createSubscription(Subscription subscription,Dialog dialog,int expires,ClientTransaction createSubscription,Subscription subscription,int expires){\r\n    Address toAddress = subscription.getAddress();\r\n    HeaderFactory headerFactory = protocolProvider.getHeaderFactory();\r\n    CallIdHeader callIdHeader = protocolProvider.getDefaultJainSipProvider().getNewCallId();\r\n    CSeqHeader cSeqHeader;\r\n    try {\r\n        cSeqHeader = headerFactory.createCSeqHeader(1l, Request.SUBSCRIBE);\r\n    } catch (InvalidArgumentException ex) {\r\n        logger.error(\"An unexpected error occurred while\" + \"constructing the CSeqHeader\", ex);\r\n        throw new OperationFailedException(\"An unexpected error occurred while\" + \"constructing the CSeqHeader\", OperationFailedException.INTERNAL_ERROR, ex);\r\n    } catch (ParseException ex) {\r\n        logger.error(\"An unexpected error occurred while\" + \"constructing the CSeqHeader\", ex);\r\n        throw new OperationFailedException(\"An unexpected error occurred while\" + \"constructing the CSeqHeader\", OperationFailedException.INTERNAL_ERROR, ex);\r\n    }\r\n    String localTag = SipMessageFactory.generateLocalTag();\r\n    FromHeader fromHeader;\r\n    ToHeader toHeader;\r\n    try {\r\n        fromHeader = headerFactory.createFromHeader(protocolProvider.getOurSipAddress(toAddress), localTag);\r\n        toHeader = headerFactory.createToHeader(toAddress, null);\r\n    } catch (ParseException ex) {\r\n        logger.error(\"An unexpected error occurred while\" + \"constructing the FromHeader or ToHeader\", ex);\r\n        throw new OperationFailedException(\"An unexpected error occurred while\" + \"constructing the FromHeader or ToHeader\", OperationFailedException.INTERNAL_ERROR, ex);\r\n    }\r\n    ArrayList<ViaHeader> viaHeaders = protocolProvider.getLocalViaHeaders(toAddress);\r\n    MaxForwardsHeader maxForwards = protocolProvider.getMaxForwardsHeader();\r\n    Request req;\r\n    try {\r\n        req = protocolProvider.getMessageFactory().createRequest(toHeader.getAddress().getURI(), Request.SUBSCRIBE, callIdHeader, cSeqHeader, fromHeader, toHeader, viaHeaders, maxForwards);\r\n    } catch (ParseException ex) {\r\n        logger.error(\"Failed to create message Request!\", ex);\r\n        throw new OperationFailedException(\"Failed to create message Request!\", OperationFailedException.INTERNAL_ERROR, ex);\r\n    }\r\n    populateSubscribeRequest(req, subscription, expires);\r\n    ClientTransaction subscribeTransaction;\r\n    try {\r\n        subscribeTransaction = protocolProvider.getDefaultJainSipProvider().getNewClientTransaction(req);\r\n    } catch (TransactionUnavailableException ex) {\r\n        logger.error(\"Failed to create subscribe transaction.\\n\" + \"This is most probably a network connection error.\", ex);\r\n        throw new OperationFailedException(\"Failed to create the subscription transaction\", OperationFailedException.NETWORK_FAILURE);\r\n    }\r\n    return subscribeTransaction;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.contactsource.AbstractContactQuery.fireContactChanged",
	"Comment": "notifies the contactquerylisteners registered with thiscontactquery that a sourcecontact has beenchanged.",
	"Method": "void fireContactChanged(SourceContact contact){\r\n    ContactQueryListener[] ls;\r\n    synchronized (listeners) {\r\n        ls = listeners.toArray(new ContactQueryListener[listeners.size()]);\r\n    }\r\n    ContactChangedEvent ev = new ContactChangedEvent(this, contact);\r\n    for (ContactQueryListener l : ls) l.contactChanged(ev);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.gui.UIContactDetail.addPreferredProtocolProvider",
	"Comment": "adds a preferred protocol provider for a given operationset class.",
	"Method": "void addPreferredProtocolProvider(Class<? extends OperationSet> opSetClass,ProtocolProviderService protocolProvider){\r\n    if (preferredProviders == null)\r\n        preferredProviders = new HashMap<Class<? extends OperationSet>, ProtocolProviderService>();\r\n    preferredProviders.put(opSetClass, protocolProvider);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.authorization.AuthorizationRequestedDialog.actionPerformed",
	"Comment": "handles the actionevent triggered when one user clickson one of the buttons.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    JButton button = (JButton) e.getSource();\r\n    String name = button.getName();\r\n    synchronized (lock) {\r\n        if (name.equals(\"authorize\")) {\r\n            this.result = ACCEPT_CODE;\r\n        } else if (name.equals(\"deny\")) {\r\n            this.result = REJECT_CODE;\r\n        } else if (name.equals(\"ignore\")) {\r\n            this.result = IGNORE_CODE;\r\n        } else {\r\n            this.result = ERROR_CODE;\r\n        }\r\n        lock.notify();\r\n    }\r\n    this.dispose();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.UIServiceImpl.isVisible",
	"Comment": "implements isvisible in the uiservice interface. checks ifthe main application window is visible.",
	"Method": "boolean isVisible(){\r\n    return mainFrame.isFrameVisible();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.SourceUIContact.getSearchStrings",
	"Comment": "returns an iterator over a list of strings, which can be usedto find this contact.",
	"Method": "Iterator<String> getSearchStrings(){\r\n    return searchStrings.iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.keybindingchooser.chooser.BindingAdaptor.getDisablingKeyCode",
	"Comment": "provides the keycode that can be input to generated key adaptors todisable key bindings.",
	"Method": "int getDisablingKeyCode(){\r\n    return this.disablingKeyCode;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipMessageFactory.createResponse",
	"Comment": "calls the same method in the internal wrapped factoryand returns a response marked with its service.",
	"Method": "Response createResponse(int statusCode,CallIdHeader callId,CSeqHeader cSeq,FromHeader from,ToHeader to,List via,MaxForwardsHeader maxForwards,ContentTypeHeader contentType,Object content,Response createResponse,int statusCode,CallIdHeader callId,CSeqHeader cSeq,FromHeader from,ToHeader to,List via,MaxForwardsHeader maxForwards,ContentTypeHeader contentType,byte[] content,Response createResponse,int statusCode,CallIdHeader callId,CSeqHeader cSeq,FromHeader from,ToHeader to,List via,MaxForwardsHeader maxForwards,Response createResponse,int statusCode,Request request,ContentTypeHeader contentType,Object content,Response createResponse,int statusCode,Request request,ContentTypeHeader contentType,byte[] content,Response createResponse,int statusCode,Request request,Response createResponse,String responseParam){\r\n    Response response = this.wrappedFactory.createResponse(responseParam);\r\n    return (Response) attachScSpecifics(response);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactGroupImpl.addMetaContact",
	"Comment": "adds the specified metacontact to ths local list of childcontacts.",
	"Method": "void addMetaContact(MetaContactImpl metaContact){\r\n    metaContact.setParentGroup(this);\r\n    lightAddMetaContact(metaContact);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ProtocolProviderFactoryIcqImpl.installAccount",
	"Comment": "initializes and creates an account corresponding to the specifiedaccountproperties and registers the resulting protocolprovider in thecontext bundlecontext parameter. this method has a persistenteffect. once created the resulting account will remain installed untilremoved through the uninstall account method.",
	"Method": "AccountID installAccount(String userIDStr,Map<String, String> accountProperties){\r\n    BundleContext context = IcqActivator.getBundleContext();\r\n    if (context == null)\r\n        throw new NullPointerException(\"The specified BundleContext was null\");\r\n    if (userIDStr == null)\r\n        throw new NullPointerException(\"The specified AccountID was null\");\r\n    if (accountProperties == null)\r\n        throw new NullPointerException(\"The specified property map was null\");\r\n    accountProperties.put(USER_ID, userIDStr);\r\n    if (isAimFactory)\r\n        accountProperties.put(IcqAccountID.IS_AIM, \"true\");\r\n    AccountID accountID = new IcqAccountID(userIDStr, accountProperties);\r\n    if (registeredAccounts.containsKey(accountID))\r\n        throw new IllegalStateException(\"An account for id \" + userIDStr + \" was already installed!\");\r\n    this.storeAccount(accountID, false);\r\n    accountID = loadAccount(accountProperties);\r\n    return accountID;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.keybindingchooser.KeybindingChooserActivator.getConfigService",
	"Comment": "returns a reference to a configurationservice implementation currentlyregistered in the bundle context or null if no such implementation wasfound.",
	"Method": "ConfigurationService getConfigService(){\r\n    if (configService == null) {\r\n        ServiceReference confReference = bundleContext.getServiceReference(ConfigurationService.class.getName());\r\n        configService = (ConfigurationService) bundleContext.getService(confReference);\r\n    }\r\n    return configService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.AbstractOperationSetTelephonyConferencing.incomingCallReceived",
	"Comment": "notifies this calllistener that a specific incomingcall has been received.",
	"Method": "void incomingCallReceived(CallEvent event){\r\n    callBegun(event);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.googlecontacts.GoogleContactsActivator.getConfigService",
	"Comment": "returns a reference to a configurationservice implementation currentlyregistered in the bundle context or null if no such implementation wasfound.",
	"Method": "ConfigurationService getConfigService(){\r\n    if (configService == null) {\r\n        configService = ServiceUtils.getService(bundleContext, ConfigurationService.class);\r\n    }\r\n    return configService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractOperationSetContactCapabilities.fireContactCapabilitiesEvent",
	"Comment": "fires a new contactcapabilitiesevent to notify the registeredcontactcapabilitieslisteners that a specific contacthas changed its list of operationset capabilities.",
	"Method": "void fireContactCapabilitiesEvent(Contact sourceContact,int eventID,Map<String, ? extends OperationSet> opSets){\r\n    ContactCapabilitiesListener[] listeners;\r\n    synchronized (contactCapabilitiesListeners) {\r\n        listeners = contactCapabilitiesListeners.toArray(new ContactCapabilitiesListener[contactCapabilitiesListeners.size()]);\r\n    }\r\n    if (listeners.length != 0) {\r\n        ContactCapabilitiesEvent event = new ContactCapabilitiesEvent(sourceContact, eventID, opSets);\r\n        for (ContactCapabilitiesListener listener : listeners) {\r\n            switch(eventID) {\r\n                case ContactCapabilitiesEvent.SUPPORTED_OPERATION_SETS_CHANGED:\r\n                    listener.supportedOperationSetsChanged(event);\r\n                    break;\r\n                default:\r\n                    if (logger.isDebugEnabled()) {\r\n                        logger.debug(\"Cannot fire ContactCapabilitiesEvent with\" + \" unsupported eventID: \" + eventID);\r\n                    }\r\n                    throw new IllegalArgumentException(\"eventID\");\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.security.CredentialsCache.get",
	"Comment": "returns the credentials corresponding to the specified realmor null if none could be found.",
	"Method": "CredentialsCacheEntry get(String realm){\r\n    return this.authenticatedRealms.get(realm);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.msoutlook.MsOutlookAddrBookSourceContact.waitUnlock",
	"Comment": "waits to be unlocked. this object must be synchronized before callingthis function.",
	"Method": "void waitUnlock(){\r\n    boolean continueToWait = this.locked;\r\n    while (continueToWait) {\r\n        try {\r\n            wait();\r\n            continueToWait = false;\r\n        } catch (InterruptedException ie) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.account.AccountRightButtonMenu.pluginComponentAdded",
	"Comment": "indicates that a new plugin component has been added. adds it to thiscontainer if it belongs to it.",
	"Method": "void pluginComponentAdded(PluginComponentEvent event){\r\n    PluginComponentFactory factory = event.getPluginComponentFactory();\r\n    if (!factory.getContainer().equals(Container.CONTAINER_ACCOUNT_RIGHT_BUTTON_MENU))\r\n        return;\r\n    PluginComponent c = factory.getPluginComponentInstance(this);\r\n    this.add((Component) c.getComponent());\r\n    this.repaint();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.security.SipSecurityManager.getCachedAuthorizationHeader",
	"Comment": "returns an authorization header cached against the specifiedcallid or null if no auth. header has been previouslycached for this callid.",
	"Method": "AuthorizationHeader getCachedAuthorizationHeader(String callID){\r\n    return this.cachedCredentials.getCachedAuthorizationHeader(callID);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ContactListModel.getElementAt",
	"Comment": "recursively searches the given group in depth for the element at thegiven index.",
	"Method": "Object getElementAt(int index,Object getElementAt,MetaContactGroup group,int currentIndex,int searchedIndex){\r\n    Object element = null;\r\n    if (currentIndex == searchedIndex) {\r\n        element = group;\r\n    } else {\r\n        if (!isGroupClosed(group)) {\r\n            int childCount = countChildContacts(group);\r\n            if (searchedIndex <= (currentIndex + childCount)) {\r\n                MetaContact contact = group.getMetaContact(searchedIndex - currentIndex - 1);\r\n                if (showOffline || isContactOnline(contact))\r\n                    element = contact;\r\n            } else {\r\n                currentIndex += childCount;\r\n                Iterator<MetaContactGroup> subgroups = group.getSubgroups();\r\n                while (subgroups.hasNext()) {\r\n                    MetaContactGroup subgroup = subgroups.next();\r\n                    if (showOffline || containsOnlineContacts(subgroup))\r\n                        element = getElementAt(subgroup, currentIndex + 1, searchedIndex);\r\n                    if (element != null)\r\n                        break;\r\n                    else if (showOffline || containsOnlineContacts(subgroup)) {\r\n                        if (!isGroupClosed(subgroup))\r\n                            currentIndex += countChildContacts(subgroup) + 1;\r\n                        else\r\n                            currentIndex++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return element;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.TestOperationSetPersistentPresence.suite",
	"Comment": "creates a test suite containing all tests of this class followed bytest methods that we want executed in a specified order.",
	"Method": "Test suite(){\r\n    TestSuite suite = new TestSuite();\r\n    suite.addTest(new TestOperationSetPersistentPresence(\"postTestCreateGroup\"));\r\n    suite.addTest(new TestOperationSetPersistentPresence(\"postTestRenameGroup\"));\r\n    suite.addTest(new TestOperationSetPersistentPresence(\"postTestRemoveGroup\"));\r\n    suite.addTest(new TestOperationSetPersistentPresence(\"prepareContactList\"));\r\n    suite.addTestSuite(TestOperationSetPersistentPresence.class);\r\n    return suite;\r\n}"
}, {
	"Path": "net.librec.recommender.item.RecommendedList.getKeyValueListByContext",
	"Comment": "returns the key score pairs list of context index in this list.",
	"Method": "List<KeyValue<Integer, Double>> getKeyValueListByContext(int contextIdx){\r\n    rangeCheck(contextIdx);\r\n    return elementData.get(contextIdx);\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.ConfigurationUtils.isRouteVideoAndDesktopUsingPhoneNumberEnabled",
	"Comment": "whether allow to use additional phone numbersto route video calls and desktop sharing through it.",
	"Method": "boolean isRouteVideoAndDesktopUsingPhoneNumberEnabled(){\r\n    return routeVideoAndDesktopUsingPhoneNumber;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.update.UpdateServiceImpl.createBrowser",
	"Comment": "initializes a new web browser component instance and navigatesit to a specific url.",
	"Method": "Component createBrowser(String url){\r\n    JEditorPane editorPane = new JEditorPane();\r\n    editorPane.setContentType(\"text/html\");\r\n    editorPane.setEditable(false);\r\n    JScrollPane scrollPane = new JScrollPane();\r\n    scrollPane.setViewportView(editorPane);\r\n    try {\r\n        Document document = editorPane.getDocument();\r\n        if (document instanceof AbstractDocument)\r\n            ((AbstractDocument) document).setAsynchronousLoadPriority(0);\r\n        editorPane.setPage(new URL(url));\r\n    } catch (Throwable t) {\r\n        if (t instanceof ThreadDeath)\r\n            throw (ThreadDeath) t;\r\n        else {\r\n            logger.error(\"Failed to navigate the Web browser to: \" + url, t);\r\n        }\r\n    }\r\n    return scrollPane;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.generic.SecurityAuthorityImpl.setUserNameEditable",
	"Comment": "sets the usernameeditable property, which should indicate if theuser name could be changed by user or not.",
	"Method": "void setUserNameEditable(boolean isUserNameEditable){\r\n    this.isUserNameEditable = isUserNameEditable;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.OperationSetBasicTelephonyGibberishImpl.putOffHold",
	"Comment": "resumes communication with a call peer previously put on hold.",
	"Method": "void putOffHold(CallPeer peer){\r\n    this.putOnHold(peer, false);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.FirstWizardPage.loadAccount",
	"Comment": "fills the user id and password fields in this panel with the data comingfrom the given protocolprovider.",
	"Method": "void loadAccount(ProtocolProviderService protocolProvider){\r\n    registrationForm.setModification(wizard.isModification());\r\n    wizard.getRegistration().loadAccount(protocolProvider.getAccountID(), JabberAccRegWizzActivator.bundleContext);\r\n    registrationForm.loadAccount(wizard.getRegistration());\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.contactinfo.ContactInfoDetailsPanel.loadContactDetails",
	"Comment": "retrieve and display the information for the newly selected contact, c.",
	"Method": "void loadContactDetails(Contact c){\r\n    this.contact = c;\r\n    ProtocolProviderService pps = contact.getProtocolProvider();\r\n    contactInfoOpSet = pps.getOperationSet(OperationSetServerStoredContactInfo.class);\r\n    this.removeAll();\r\n    if (contactInfoOpSet == null || !pps.isRegistered()) {\r\n        JPanel unsupportedPanel = createUnsupportedPanel();\r\n        this.add(unsupportedPanel);\r\n        this.revalidate();\r\n        this.repaint();\r\n        return;\r\n    }\r\n    this.tabbedPane.removeAll();\r\n    ImageIcon icon = new ImageIcon(contact.getProtocolProvider().getProtocolIcon().getIcon(ProtocolIcon.ICON_SIZE_16x16));\r\n    JPanel summaryPanel = createSummaryInfoPanel();\r\n    JPanel extendedPanel = createExtendedInfoPanel();\r\n    JScrollPane extendedScrollPane = new JScrollPane(extendedPanel);\r\n    this.tabbedPane.addTab(Resources.getString(\"service.gui.SUMMARY\"), icon, summaryPanel, Resources.getString(\"plugin.contactinfo.CONTACT_SUMMARY_DESCRIPTION\") + contact.getDisplayName());\r\n    this.tabbedPane.setMnemonicAt(0, KeyEvent.VK_1);\r\n    this.tabbedPane.addTab(Resources.getString(\"plugin.accountinfo.EXTENDED\"), icon, extendedScrollPane, Resources.getString(\"plugin.contactinfo.CONTACT_EXTENDED_DESCRIPTION\") + contact.getDisplayName());\r\n    this.tabbedPane.setMnemonicAt(1, KeyEvent.VK_2);\r\n    this.add(tabbedPane);\r\n    this.revalidate();\r\n    this.repaint();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.resources.ResourceManagementServiceImpl.getColor",
	"Comment": "returns the int representation of the color corresponding to thegiven key.",
	"Method": "int getColor(String key){\r\n    String res = getColorResources().get(key);\r\n    if (res == null) {\r\n        logger.error(\"Missing color resource for key: \" + key);\r\n        return 0xFFFFFF;\r\n    } else\r\n        return Integer.parseInt(res, 16);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractProtocolProviderService.getOperationSet",
	"Comment": "returns the operation set corresponding to the specified class or null ifthis operation set is not supported by the provider implementation.",
	"Method": "T getOperationSet(Class<T> opsetClass){\r\n    return (T) supportedOperationSets.get(opsetClass.getName());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.ShowMoreContact.getSearchStrings",
	"Comment": "returns null to indicate that this contact cannot be searched.",
	"Method": "Iterator<String> getSearchStrings(){\r\n    return null;\r\n}"
}, {
	"Path": "com.keybox.manage.db.UserDB.isUnique",
	"Comment": "checks to see if username is unique while ignoring current user",
	"Method": "boolean isUnique(Long userId,String username){\r\n    boolean isUnique = true;\r\n    if (userId == null) {\r\n        userId = -99L;\r\n    }\r\n    Connection con = null;\r\n    try {\r\n        con = DBUtils.getConn();\r\n        PreparedStatement stmt = con.prepareStatement(\"select * from users where lower(username) like lower(?) and id != ?\");\r\n        stmt.setString(1, username);\r\n        stmt.setLong(2, userId);\r\n        ResultSet rs = stmt.executeQuery();\r\n        if (rs.next()) {\r\n            isUnique = false;\r\n        }\r\n        DBUtils.closeRs(rs);\r\n        DBUtils.closeStmt(stmt);\r\n    } catch (Exception ex) {\r\n        log.error(ex.toString(), ex);\r\n    } finally {\r\n        DBUtils.closeConn(con);\r\n    }\r\n    return isUnique;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallPanel.updateHoldButtonState",
	"Comment": "updates the state of the general hold button. the hold button is selectedonly if all call peers are locally or mutually on hold at the same time.in all other cases the hold button is unselected.",
	"Method": "void updateHoldButtonState(){\r\n    if (holdButton == null)\r\n        return;\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                updateHoldButtonState();\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    List<CallPeer> peers = callConference.getCallPeers();\r\n    boolean areAllPeersLocallyOnHold;\r\n    if (peers.isEmpty()) {\r\n        areAllPeersLocallyOnHold = false;\r\n    } else {\r\n        areAllPeersLocallyOnHold = true;\r\n        for (CallPeer peer : callConference.getCallPeers()) {\r\n            CallPeerState state = peer.getState();\r\n            if (!state.equals(CallPeerState.ON_HOLD_LOCALLY) && !state.equals(CallPeerState.ON_HOLD_MUTUALLY)) {\r\n                areAllPeersLocallyOnHold = false;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    holdButton.setSelected(areAllPeersLocallyOnHold);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallPanel.updateHoldButtonState",
	"Comment": "updates the state of the general hold button. the hold button is selectedonly if all call peers are locally or mutually on hold at the same time.in all other cases the hold button is unselected.",
	"Method": "void updateHoldButtonState(){\r\n    updateHoldButtonState();\r\n}"
}, {
	"Path": "org.eclipse.jetty.test.support.JettyDistro.getBaseUri",
	"Comment": "return the baseuri being used for this jetty process instance.",
	"Method": "URI getBaseUri(){\r\n    return this.baseUri;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.netaddr.NetworkConfigurationWatcher.activityChanged",
	"Comment": "this method gets called when a notification action for a particular eventtype has been changed. we are interested in sleep and networkchanged events.",
	"Method": "void activityChanged(SystemActivityEvent event){\r\n    if (event.getEventID() == SystemActivityEvent.EVENT_SLEEP) {\r\n        downAllInterfaces();\r\n    } else if (event.getEventID() == SystemActivityEvent.EVENT_NETWORK_CHANGE) {\r\n        try {\r\n            checkNetworkInterfaces(true, 0, true);\r\n        } catch (SocketException e) {\r\n            logger.error(\"Error checking network interfaces\", e);\r\n        }\r\n    } else if (event.getEventID() == SystemActivityEvent.EVENT_DNS_CHANGE) {\r\n        try {\r\n            eventDispatcher.fireChangeEvent(new ChangeEvent(event.getSource(), ChangeEvent.DNS_CHANGE));\r\n        } catch (Throwable t) {\r\n            logger.error(\"Error dispatching dns change.\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.CallPeerEvent.getSourceCall",
	"Comment": "returns the call that the source call peer is associated with.",
	"Method": "Call getSourceCall(){\r\n    return sourceCall;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AccountManager.loadAccount",
	"Comment": "loads the account corresponding to the given accountid. anaccount is loaded when its protocolproviderservice is registeredin the bundle context. this method is meant to load the account throughthe corresponding protocolproviderfactory.",
	"Method": "void loadAccount(AccountID accountID){\r\n    if (isAccountLoaded(accountID))\r\n        return;\r\n    ProtocolProviderFactory providerFactory = ProtocolProviderActivator.getProtocolProviderFactory(accountID.getProtocolName());\r\n    if (providerFactory.loadAccount(accountID)) {\r\n        accountID.putAccountProperty(ProtocolProviderFactory.IS_ACCOUNT_DISABLED, String.valueOf(false));\r\n        storeAccount(providerFactory, accountID);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ContactListTreeCellRenderer.getAddContactButton",
	"Comment": "returns the add contact button contained in the current cell.",
	"Method": "JButton getAddContactButton(){\r\n    return addContactButton;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.msoutlook.MsOutlookAddrBookSourceContact.save",
	"Comment": "saves all the properties from this source contact into the outlookdatabase.",
	"Method": "void save(){\r\n    synchronized (this) {\r\n        setDisplayPostalAddress();\r\n        MsOutlookAddrBookContactDetail outlookContactDetail;\r\n        for (ContactDetail contactDetail : this.contactDetails) {\r\n            if (contactDetail instanceof MsOutlookAddrBookContactDetail) {\r\n                outlookContactDetail = (MsOutlookAddrBookContactDetail) contactDetail;\r\n                for (Long propId : outlookContactDetail.getOutlookPropId()) {\r\n                    MsOutlookAddrBookContactQuery.IMAPIProp_SetPropString(propId.longValue(), contactDetail.getDetail(), this.getId());\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.conference.ProtocolProviderSelectorBox.createProviderImage",
	"Comment": "obtains the status icon for the given provider andadds to it the account index information.",
	"Method": "Image createProviderImage(ProtocolProviderService provider){\r\n    return ImageLoader.getIndexedProtocolImage(ImageUtils.getBytesInImage(provider.getProtocolIcon().getIcon(ProtocolIcon.ICON_SIZE_16x16)), provider);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.OneToOneCallPeerPanel.updateViewFromModel",
	"Comment": "updates this view i.e. onetoonecallpeerpanel so that it depictsthe current state of its model i.e. callpeer.",
	"Method": "void updateViewFromModel(){\r\n    if (!disposed) {\r\n        if (SwingUtilities.isEventDispatchThread())\r\n            updateViewFromModelInEventDispatchThread();\r\n        else {\r\n            SwingUtilities.invokeLater(updateViewFromModelInEventDispatchThread);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.DynamicPayloadTypeRegistry.getMappings",
	"Comment": "returns a copy of all mappings currently registered in this registry.",
	"Method": "Map<MediaFormat, Byte> getMappings(){\r\n    return new HashMap<MediaFormat, Byte>(payloadTypeMappings);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.InfoRetreiver.getDetails",
	"Comment": "returns the user details from the specified classexactly that class not its descendants",
	"Method": "Iterator<GenericDetail> getDetails(String uin,Class<? extends GenericDetail> detailClass){\r\n    List<GenericDetail> details = getContactDetails(uin);\r\n    List<GenericDetail> result = new LinkedList<GenericDetail>();\r\n    for (GenericDetail item : details) {\r\n        if (detailClass.equals(item.getClass()))\r\n            result.add(item);\r\n    }\r\n    return result.iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.WhiteboardInvitationReceivedEvent.getTimestamp",
	"Comment": "a timestamp indicating the exact date when the event ocurred.",
	"Method": "Date getTimestamp(){\r\n    return timestamp;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.security.SipSecurityManager.setHeaderFactory",
	"Comment": "set the header factory to be used when creating authorization headers",
	"Method": "void setHeaderFactory(HeaderFactory headerFactory){\r\n    this.headerFactory = headerFactory;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockContactGroup.findGroupParent",
	"Comment": "returns the group that is parent of the specified mockgroup or nullif no parent was found.",
	"Method": "MockContactGroup findGroupParent(MockContactGroup mockGroup){\r\n    if (subGroups.contains(mockGroup))\r\n        return this;\r\n    Iterator<ContactGroup> subGroupsIter = subgroups();\r\n    while (subGroupsIter.hasNext()) {\r\n        MockContactGroup subgroup = (MockContactGroup) subGroupsIter.next();\r\n        MockContactGroup parent = subgroup.findGroupParent(mockGroup);\r\n        if (parent != null)\r\n            return parent;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.aimaccregwizz.Resources.getString",
	"Comment": "returns an internationalized string corresponding to the given key.",
	"Method": "String getString(String key){\r\n    return getResources().getI18NString(key);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetPersistentPresenceJabberImpl.moveContactToGroup",
	"Comment": "removes the specified contact from its current parent and places itunder newparent.",
	"Method": "void moveContactToGroup(Contact contactToMove,ContactGroup newParent){\r\n    assertConnected();\r\n    if (!(contactToMove instanceof ContactJabberImpl))\r\n        throw new IllegalArgumentException(\"The specified contact is not an jabber contact.\" + contactToMove);\r\n    if (!(newParent instanceof AbstractContactGroupJabberImpl))\r\n        throw new IllegalArgumentException(\"The specified group is not an jabber contact group.\" + newParent);\r\n    ssContactList.moveContact((ContactJabberImpl) contactToMove, (AbstractContactGroupJabberImpl) newParent);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ChatRoomMemberListPanel.addContact",
	"Comment": "adds a chatcontact to the list of contacts contained in thechat.",
	"Method": "void addContact(ChatContact<?> chatContact){\r\n    memberListModel.addElement(chatContact);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetPersistentPresenceIcqImpl.getServerStoredContactListRoot",
	"Comment": "returns the root group of the server stored contact list. most often thiswould be a dummy group that user interface implementations may better notshow.",
	"Method": "ContactGroup getServerStoredContactListRoot(){\r\n    return ssContactList.getRootGroup();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.gibberishaccregwizz.GibberishAccountRegistrationWizard.getLastPageIdentifier",
	"Comment": "returns the identifier of the page to show last in the wizard.",
	"Method": "Object getLastPageIdentifier(){\r\n    return firstWizardPage.getIdentifier();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.callhistory.CallHistoryActivator.getCallHistoryService",
	"Comment": "returns the instance of callhistoryservice created in thisactivator.",
	"Method": "CallHistoryService getCallHistoryService(){\r\n    return callHistoryService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ContactListTreeCellRenderer.getIconWidth",
	"Comment": "returns the width of this icon. used for the drag&drop component.",
	"Method": "int getIconWidth(){\r\n    return treeContactList.getWidth() + 10;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.conference.BasicConferenceParticipantPanel.securityPending",
	"Comment": "indicates that the security status is pending confirmation.",
	"Method": "void securityPending(){\r\n    securityStatusLabel.setSecurityPending();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chatroomslist.joinforms.JoinChatRoomWizardPage2.getNextPageIdentifier",
	"Comment": "implements the wizardpaneldescriptor method to return theidentifier of the next wizard page.",
	"Method": "Object getNextPageIdentifier(){\r\n    return WizardPage.FINISH_PAGE_IDENTIFIER;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.GroupPacketExtension.createBundleGroup",
	"Comment": "creates new grouppacketextension for bundle semanticsinitialized with given contents list.",
	"Method": "GroupPacketExtension createBundleGroup(List<ContentPacketExtension> contents){\r\n    GroupPacketExtension group = new GroupPacketExtension();\r\n    group.setSemantics(SEMANTICS_BUNDLE);\r\n    group.addContents(contents);\r\n    return group;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractOperationSetServerStoredAccountInfo.addServerStoredDetailsChangeListener",
	"Comment": "registers a serverstoreddetailschangelistener with this operation set sothat it gets notifications of details change.",
	"Method": "void addServerStoredDetailsChangeListener(ServerStoredDetailsChangeListener listener){\r\n    synchronized (serverStoredDetailsListeners) {\r\n        if (!serverStoredDetailsListeners.contains(listener))\r\n            serverStoredDetailsListeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.whiteboard.gui.whiteboardshapes.WhiteboardShapePolygon.setFill",
	"Comment": "sets the fill state of the whiteboardobject.true is filled, false is unfilled.",
	"Method": "void setFill(boolean fill){\r\n    this.fill = fill;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChannelManager.convertMemberMode",
	"Comment": "convert a member mode character to a chatroommemberrole instance.",
	"Method": "ChatRoomMemberRole convertMemberMode(char modeSymbol){\r\n    return Mode.bySymbol(modeSymbol).getRole();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.caps.CapsPacketExtension.getVersion",
	"Comment": "returns the version associated with this packet. a version is astring that is used to verify the identity and supported features of theentity",
	"Method": "String getVersion(){\r\n    return ver;\r\n}"
}, {
	"Path": "net.librec.recommender.cf.UserKNNTestCase.test27SplitterRatioItemDate",
	"Comment": "test ratiodatasplitter with item date ratio, filter enabled.",
	"Method": "void test27SplitterRatioItemDate(){\r\n    Resource resource = new Resource(\"rec/cf/userknn-test.properties\");\r\n    conf.addResource(resource);\r\n    conf.set(\"rec.eval.enable\", \"false\");\r\n    conf.set(\"rec.filter.class\", \"generic\");\r\n    conf.set(\"data.model.splitter\", \"ratio\");\r\n    conf.set(\"data.input.path\", \"test/datamodeltest/ratings-date.txt\");\r\n    conf.set(\"data.column.format\", \"UIRT\");\r\n    conf.set(\"data.splitter.ratio\", \"itemdate\");\r\n    RecommenderJob job = new RecommenderJob(conf);\r\n    job.runJob();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.propertieseditor.PropertiesEditorPanel.initTableModel",
	"Comment": "gets the data from the configurationservice that will constructthe propstablemodel for the properties table.",
	"Method": "Object[][] initTableModel(){\r\n    ConfigurationService confService = PropertiesEditorActivator.getConfigurationService();\r\n    java.util.List<String> properties = confService.getAllPropertyNames();\r\n    Object[][] data = new Object[properties.size()][];\r\n    int i = 0;\r\n    for (String property : properties) {\r\n        data[i++] = new Object[] { property, confService.getProperty(property) };\r\n    }\r\n    return data;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.fireChatFocusEvent",
	"Comment": "informs all chatfocuslisteners that a chatfocuseventhas been triggered.",
	"Method": "void fireChatFocusEvent(int eventID){\r\n    ChatFocusEvent evt = new ChatFocusEvent(this, eventID);\r\n    if (logger.isTraceEnabled())\r\n        logger.trace(\"Will dispatch the following chat event: \" + evt);\r\n    Iterable<ChatFocusListener> listeners;\r\n    synchronized (focusListeners) {\r\n        listeners = new ArrayList<ChatFocusListener>(focusListeners);\r\n    }\r\n    for (ChatFocusListener listener : listeners) {\r\n        switch(evt.getEventID()) {\r\n            case ChatFocusEvent.FOCUS_GAINED:\r\n                listener.chatFocusGained(evt);\r\n                break;\r\n            case ChatFocusEvent.FOCUS_LOST:\r\n                listener.chatFocusLost(evt);\r\n                break;\r\n            default:\r\n                logger.error(\"Unknown event type \" + evt.getEventID());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.AdHocConferenceChatTransport.getName",
	"Comment": "returns the contact address corresponding to this chat transport.",
	"Method": "String getName(){\r\n    return adHocChatRoom.getName();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.ExternalContactSource.initCustomContactActionButtons",
	"Comment": "initializes custom action buttons for this contact source.",
	"Method": "void initCustomContactActionButtons(){\r\n    customContactActionButtons = new LinkedHashMap<ContactAction<SourceContact>, SIPCommButton>();\r\n    for (CustomContactActionsService<SourceContact> ccas : getContactActionsServices()) {\r\n        Iterator<ContactAction<SourceContact>> actionIterator = ccas.getCustomContactActions();\r\n        if (actionIterator != null) {\r\n            while (actionIterator.hasNext()) {\r\n                final ContactAction<SourceContact> ca = actionIterator.next();\r\n                initActionButton(ca, SourceContact.class);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.IncomingFileTransferRequestIcqImpl.getSender",
	"Comment": "returns a string that represents the name of the sender of the filebeing received.if there is no sender name available, returns null.",
	"Method": "Contact getSender(){\r\n    return sender;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.contactsource.GenericSourceContact.getContactDetails",
	"Comment": "returns a list of all contactdetails corresponding to the givencategory.",
	"Method": "List<ContactDetail> getContactDetails(List<ContactDetail> getContactDetails,Class<? extends OperationSet> operationSet,List<ContactDetail> getContactDetails,ContactDetail.Category category){\r\n    List<ContactDetail> contactDetails = new LinkedList<ContactDetail>();\r\n    for (ContactDetail contactDetail : getContactDetails()) {\r\n        if (contactDetail != null) {\r\n            ContactDetail.Category detailCategory = contactDetail.getCategory();\r\n            if (detailCategory != null && detailCategory.equals(category))\r\n                contactDetails.add(contactDetail);\r\n        }\r\n    }\r\n    return contactDetails;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.IcqAccountID.isAIM",
	"Comment": "checks whether the specified set of account properties describes an aimaccount.",
	"Method": "boolean isAIM(Map<String, String> accountProperties){\r\n    String isAim = accountProperties.get(IS_AIM);\r\n    return \"true\".equalsIgnoreCase(isAim);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.RegistrationStateChangeEvent.setUserRequest",
	"Comment": "changes the event to indicate that is created after use request.",
	"Method": "void setUserRequest(boolean userRequest){\r\n    this.userRequest = userRequest;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.MobileIndicator.isMobileResource",
	"Comment": "checks a resource whether it is mobile or not, by checking thecache.",
	"Method": "boolean isMobileResource(String resourceName,String fullJid){\r\n    if (isCapsMobileIndicator) {\r\n        EntityCapsManager capsManager = ssclCallback.getParentProvider().getDiscoveryManager().getCapsManager();\r\n        EntityCapsManager.Caps caps = capsManager.getCapsByUser(fullJid);\r\n        if (caps != null && containsStrings(caps.node, checkStrings))\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n    if (startsWithStrings(resourceName, checkStrings))\r\n        return true;\r\n    else\r\n        return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.caps.CapsPacketExtension.setVersion",
	"Comment": "sets the value of the ver parameter. a version is a string thatis used to verify the identity and supported features of the entity.",
	"Method": "void setVersion(String version){\r\n    this.ver = version;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.sip.SipAccountID.setProxyForceBypassConfigure",
	"Comment": "sets force bypass configuration of proxy enabled or disabled.",
	"Method": "void setProxyForceBypassConfigure(boolean proxyForceBypassConfigure){\r\n    putAccountProperty(ProtocolProviderFactory.FORCE_PROXY_BYPASS, proxyForceBypassConfigure);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.pluginmanager.NewBundleDialog.actionPerformed",
	"Comment": "performs corresponding actions, when a buttons is pressed.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    JButton sourceButton = (JButton) e.getSource();\r\n    if (sourceButton.equals(installButton)) {\r\n        if (bundlePathField.getText().length() > 0) {\r\n            try {\r\n                PluginManagerActivator.bundleContext.installBundle(bundlePathField.getText());\r\n            } catch (BundleException ex) {\r\n                logger.info(\"Failed to install bundle.\", ex);\r\n                PluginManagerActivator.getUIService().getPopupDialog().showMessagePopupDialog(ex.getMessage(), \"Error\", PopupDialog.ERROR_MESSAGE);\r\n            } catch (Throwable ex) {\r\n                logger.info(\"Failed to install bundle.\", ex);\r\n            } finally {\r\n                dispose();\r\n            }\r\n        }\r\n    } else if (sourceButton.equals(fileChooserButton)) {\r\n        SipCommFileChooser chooser = GenericFileDialog.create(null, \"New bundle...\", SipCommFileChooser.LOAD_FILE_OPERATION);\r\n        File newBundleFile = chooser.getFileFromDialog();\r\n        if (newBundleFile != null) {\r\n            try {\r\n                bundlePathField.setText(newBundleFile.toURI().toURL().toString());\r\n            } catch (MalformedURLException ex) {\r\n                logger.info(\"Failed parse URL.\", ex);\r\n            }\r\n        }\r\n    } else\r\n        dispose();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.Resources.getString",
	"Comment": "returns an internationalized string corresponding to the given key.",
	"Method": "String getString(String key){\r\n    return getResources().getI18NString(key);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.ShowMoreContact.getContactDetails",
	"Comment": "returns null to indicate that this contact has no contact details.",
	"Method": "List<UIContactDetail> getContactDetails(){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractProtocolProviderService.toString",
	"Comment": "a clear display for protocolprovider when its printed in logs.",
	"Method": "String toString(){\r\n    return getClass().getSimpleName() + \"(\" + getAccountID().getDisplayName() + \")\";\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.dtmf.DTMFInfo.addDTMFListener",
	"Comment": "registers the specified dtmflistener with this provider so that it couldbe notified when incoming dtmf tone is received.",
	"Method": "void addDTMFListener(DTMFListener listener){\r\n    synchronized (dtmfListeners) {\r\n        if (!dtmfListeners.contains(listener)) {\r\n            dtmfListeners.add(listener);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.ContactGroupGibberishImpl.subgroups",
	"Comment": "returns an iterator over the sub groups that thiscontactgroup contains.",
	"Method": "Iterator<ContactGroup> subgroups(){\r\n    return subGroups.iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MclStorageManager.findMetaContactNode",
	"Comment": "returns the node corresponding to the meta contact with the specified uidor null if no such node was found.",
	"Method": "Element findMetaContactNode(String metaContactUID){\r\n    Element root = (Element) contactListDocument.getFirstChild();\r\n    return XMLUtils.locateElement(root, META_CONTACT_NODE_NAME, UID_ATTR_NAME, metaContactUID);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommToggleButton.setPressedImage",
	"Comment": "sets the image representing the pressed state of this button.",
	"Method": "void setPressedImage(Image pressedImage){\r\n    this.pressedImage = pressedImage;\r\n    this.repaint();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.osdependent.jdic.TrayMenuFactory.actionPerformed",
	"Comment": "handles the actionevent when one of the menu items is selected.",
	"Method": "void actionPerformed(ActionEvent evt){\r\n    Object source = evt.getSource();\r\n    String itemName;\r\n    if (source instanceof JMenuItem) {\r\n        JMenuItem menuItem = (JMenuItem) source;\r\n        itemName = menuItem.getName();\r\n    } else {\r\n        MenuItem menuItem = (MenuItem) source;\r\n        itemName = menuItem.getName();\r\n    }\r\n    if (itemName.equals(\"settings\")) {\r\n        OsDependentActivator.getUIService().getConfigurationContainer().setVisible(true);\r\n    } else if (itemName.equals(\"service.gui.QUIT\")) {\r\n        OsDependentActivator.getShutdownService().beginShutdown();\r\n    } else if (itemName.equals(\"addContact\")) {\r\n        ExportedWindow dialog = OsDependentActivator.getUIService().getExportedWindow(ExportedWindow.ADD_CONTACT_WINDOW);\r\n        if (dialog != null)\r\n            dialog.setVisible(true);\r\n        else\r\n            OsDependentActivator.getUIService().getPopupDialog().showMessagePopupDialog(Resources.getString(\"impl.systray.FAILED_TO_OPEN_ADD_CONTACT_DIALOG\"));\r\n    } else if (itemName.equals(\"service.gui.SHOW\")) {\r\n        OsDependentActivator.getUIService().setVisible(true);\r\n        OsDependentActivator.getUIService().bringToFront();\r\n        changeTrayMenuItem(source, \"service.gui.HIDE\", \"service.gui.HIDE\", \"service.gui.icons.SEARCH_ICON_16x16\");\r\n    } else if (itemName.equals(\"service.gui.HIDE\")) {\r\n        OsDependentActivator.getUIService().setVisible(false);\r\n        changeTrayMenuItem(source, \"service.gui.SHOW\", \"service.gui.SHOW\", \"service.gui.icons.SEARCH_ICON_16x16\");\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.OneToOneCallPeerPanel.securityNegotiationStarted",
	"Comment": "the handler for the security event received. the security eventfor starting establish a secure connection.",
	"Method": "void securityNegotiationStarted(CallPeerSecurityNegotiationStartedEvent evt){\r\n    if (Boolean.parseBoolean(GuiActivator.getResources().getSettingsString(\"impl.gui.PARANOIA_UI\"))) {\r\n        SrtpControl srtpControl = null;\r\n        if (callPeer instanceof MediaAwareCallPeer)\r\n            srtpControl = evt.getSecurityController();\r\n        securityPanel = new ParanoiaTimerSecurityPanel<SrtpControl>(srtpControl);\r\n        setSecurityPanelVisible(true);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.OperationSetPersistentPresenceIrcImpl.findOrCreateContactByID",
	"Comment": "find or create contact by id.in irc every chat room member is also a contact. try to find a contact byits id. if a contact cannot be found, then create one.",
	"Method": "Contact findOrCreateContactByID(String id){\r\n    Contact contact = findContactByID(id);\r\n    if (contact == null) {\r\n        contact = createVolatileContact(id);\r\n        LOGGER.debug(\"No existing contact found. Created volatile contact\" + \" for nick name '\" + id + \"'.\");\r\n    }\r\n    return contact;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetPersistentPresenceJabberImpl.getLocalContact",
	"Comment": "returns the protocol specific contact instance representing the localuser.",
	"Method": "Contact getLocalContact(){\r\n    if (localContact != null)\r\n        return localContact;\r\n    final String id = parentProvider.getAccountID().getUserID();\r\n    localContact = new ContactJabberImpl(null, ssContactList, false, true);\r\n    localContact.setLocal(true);\r\n    localContact.updatePresenceStatus(currentStatus);\r\n    localContact.setJid(parentProvider.getOurJID());\r\n    Map<String, ContactResourceJabberImpl> rs = localContact.getResourcesMap();\r\n    if (currentPresence != null)\r\n        rs.put(parentProvider.getOurJID(), createResource(currentPresence, parentProvider.getOurJID(), localContact));\r\n    Iterator<Presence> presenceIterator = ssContactList.getPresences(id);\r\n    while (presenceIterator.hasNext()) {\r\n        Presence p = presenceIterator.next();\r\n        String fullJid = p.getFrom();\r\n        rs.put(fullJid, createResource(p, p.getFrom(), localContact));\r\n    }\r\n    PacketFilter presenceFilter = new PacketTypeFilter(Presence.class);\r\n    parentProvider.getConnection().addPacketListener(new PacketListener() {\r\n        @Override\r\n        public void processPacket(Packet packet) {\r\n            Presence presence = (Presence) packet;\r\n            String from = presence.getFrom();\r\n            if (from == null || !StringUtils.parseBareAddress(from).equals(id))\r\n                return;\r\n            updateResource(localContact, null, presence);\r\n        }\r\n    }, presenceFilter);\r\n    return localContact;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetPersistentPresenceJabberImpl.getLocalContact",
	"Comment": "returns the protocol specific contact instance representing the localuser.",
	"Method": "Contact getLocalContact(){\r\n    Presence presence = (Presence) packet;\r\n    String from = presence.getFrom();\r\n    if (from == null || !StringUtils.parseBareAddress(from).equals(id))\r\n        return;\r\n    updateResource(localContact, null, presence);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.MainFrame.getAccountAddress",
	"Comment": "returns the account user id for the given protocol provider.",
	"Method": "String getAccountAddress(ProtocolProviderService protocolProvider){\r\n    return protocolProvider.getAccountID().getAccountAddress();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.GroupNode.addContact",
	"Comment": "creates a contactnode for the given uicontactand adds it to this group.",
	"Method": "ContactNode addContact(UIContactImpl uiContact){\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Group node add contact: \" + uiContact.getDisplayName());\r\n    int selectedIndex = getLeadSelectionRow();\r\n    ContactNode contactNode = new ContactNode(uiContact);\r\n    uiContact.setContactNode(contactNode);\r\n    add(contactNode);\r\n    fireNodeInserted(children.size() - 1);\r\n    refreshSelection(selectedIndex, getLeadSelectionRow());\r\n    return contactNode;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ServerStoredContactListJabberImpl.fireContactRemoved",
	"Comment": "make the parent persistent presence operation set dispatch a contactremoved event.",
	"Method": "void fireContactRemoved(ContactGroup parentGroup,ContactJabberImpl contact){\r\n    if (parentOperationSet == null) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"No presence op. set available. Bailing out.\");\r\n        return;\r\n    }\r\n    if (logger.isTraceEnabled())\r\n        logger.trace(\"Removing \" + contact.getAddress() + \" from \" + parentGroup.getGroupName());\r\n    parentOperationSet.fireSubscriptionEvent(contact, parentGroup, SubscriptionEvent.SUBSCRIPTION_REMOVED);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipRegistrarConnection.updateSupportedOperationSets",
	"Comment": "analyzes the content of the allowheader and determines whethersome of the operation sets in our provider need to be disabled.",
	"Method": "void updateSupportedOperationSets(ListIterator<AllowHeader> headerIter){\r\n    HashSet<String> set = new HashSet<String>();\r\n    while (headerIter.hasNext()) {\r\n        set.add(headerIter.next().getMethod());\r\n    }\r\n    if (!set.contains(Request.MESSAGE) && !sipProvider.getAccountID().getAccountPropertyBoolean(FORCE_MESSAGING_PROP, false)) {\r\n        sipProvider.removeSupportedOperationSet(OperationSetBasicInstantMessaging.class);\r\n    }\r\n}"
}, {
	"Path": "net.librec.math.structure.DenseMatrix.minus",
	"Comment": "return a new matrix containing the element by element difference of the recipient and the argument",
	"Method": "DenseMatrix minus(Matrix otherMatrix){\r\n    DenseMatrix denseMatrix = this.clone();\r\n    for (MatrixEntry matrixEntry : otherMatrix) {\r\n        denseMatrix.plus(matrixEntry.row(), matrixEntry.column(), -matrixEntry.get());\r\n    }\r\n    return denseMatrix;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.account.AccountStatusUtils.getGlobalStatusService",
	"Comment": "returns the globalstatusservice obtained from the bundlecontext.",
	"Method": "GlobalStatusService getGlobalStatusService(){\r\n    if (globalStatusService == null) {\r\n        globalStatusService = ServiceUtils.getService(UtilActivator.bundleContext, GlobalStatusService.class);\r\n    }\r\n    return globalStatusService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.jabber.JabberAccountID.isSendKeepAlive",
	"Comment": "determines whether sending of keep alive packets is enabled.",
	"Method": "boolean isSendKeepAlive(){\r\n    return getAccountPropertyBoolean(SEND_KEEP_ALIVE, true);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.netaddr.event.ChangeEvent.isInitial",
	"Comment": "is this event initial one. when starting, no actualchange has occurred in the system.",
	"Method": "boolean isInitial(){\r\n    return initial;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.usersearch.UserSearchActivator.removeUserSearchSupportedProviderListener",
	"Comment": "removes usersearchsupportedproviderlistener from the list oflisteners.",
	"Method": "void removeUserSearchSupportedProviderListener(UserSearchSupportedProviderListener listener){\r\n    synchronized (listeners) {\r\n        listeners.remove(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWindow.addChatTab",
	"Comment": "adds a given chatpanel to the jtabbedpane of thischat window.",
	"Method": "void addChatTab(ChatPanel chatPanel){\r\n    ChatSession chatSession = chatPanel.getChatSession();\r\n    String chatName = chatSession.getChatName();\r\n    ChatPanel currentChatPanel = getCurrentChat();\r\n    if (currentChatPanel == null) {\r\n        this.mainPanel.add(chatPanel, BorderLayout.CENTER);\r\n    } else if (getChatTabCount() == 0) {\r\n        ChatSession firstChatSession = currentChatPanel.getChatSession();\r\n        chatTabbedPane.addTab(firstChatSession.getChatName(), firstChatSession.getChatStatusIcon(), currentChatPanel);\r\n        chatTabbedPane.addTab(chatName, chatSession.getChatStatusIcon(), chatPanel);\r\n        chatTabbedPane.setSelectedComponent(currentChatPanel);\r\n        this.mainPanel.add(chatTabbedPane, BorderLayout.CENTER);\r\n        this.mainPanel.validate();\r\n    } else {\r\n        chatTabbedPane.addTab(chatName, chatSession.getChatStatusIcon(), chatPanel);\r\n        chatTabbedPane.getParent().validate();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SipCommFileChooserImpl.setStartPath",
	"Comment": "sets the default path to be considered for browsing among files.",
	"Method": "void setStartPath(String path){\r\n    if (path == null)\r\n        return;\r\n    try {\r\n        URL url = new URL(path);\r\n        path = url.getPath();\r\n    } catch (MalformedURLException e) {\r\n    }\r\n    File file = new File(path);\r\n    setCurrentDirectory(file);\r\n    if ((file != null) && !file.isDirectory())\r\n        setSelectedFile(file);\r\n    else\r\n        setSelectedFile(null);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomIrcImpl.fireMessageDeliveryFailedEvent",
	"Comment": "notifies interested listeners that a message delivery has failed.",
	"Method": "void fireMessageDeliveryFailedEvent(int errorCode,String reason,Date date,Message message){\r\n    final ChatRoomMessageDeliveryFailedEvent event = new ChatRoomMessageDeliveryFailedEvent(this, null, errorCode, reason, date, message);\r\n    final Iterable<ChatRoomMessageListener> listeners;\r\n    synchronized (messageListeners) {\r\n        listeners = new ArrayList<ChatRoomMessageListener>(messageListeners);\r\n    }\r\n    for (final ChatRoomMessageListener listener : listeners) {\r\n        try {\r\n            listener.messageDeliveryFailed(event);\r\n        } catch (RuntimeException e) {\r\n            LOGGER.error(String.format(\"Listener '%s' threw a runtime exception during execution.\" + \" This is probably due to a bug in the listener's \" + \"implementation.\", listener.getClass().getCanonicalName()), e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.account.AccountUtils.getRegisteredProviders",
	"Comment": "returns a list of all currently registered telephony providers for thegiven protocol name.",
	"Method": "List<ProtocolProviderService> getRegisteredProviders(Class<? extends OperationSet> opSetClass,List<ProtocolProviderService> getRegisteredProviders,String protocolName,Class<? extends OperationSet> opSetClass,Collection<ProtocolProviderService> getRegisteredProviders){\r\n    List<ProtocolProviderService> registeredProviders = new LinkedList<ProtocolProviderService>();\r\n    for (ProtocolProviderFactory providerFactory : UtilActivator.getProtocolProviderFactories().values()) {\r\n        for (AccountID accountID : providerFactory.getRegisteredAccounts()) {\r\n            ServiceReference<ProtocolProviderService> ref = providerFactory.getProviderForAccount(accountID);\r\n            if (ref != null) {\r\n                ProtocolProviderService protocolProvider = UtilActivator.bundleContext.getService(ref);\r\n                registeredProviders.add(protocolProvider);\r\n            }\r\n        }\r\n    }\r\n    return registeredProviders;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.ChooseCallAccountPopupMenu.addTelephonyProviderItem",
	"Comment": "adds the given telephonyprovider to the list of availabletelephony providers.",
	"Method": "void addTelephonyProviderItem(ProtocolProviderService telephonyProvider,String contactString,Class<? extends OperationSet> opSetClass){\r\n    final ProviderMenuItem providerItem = new ProviderMenuItem(telephonyProvider);\r\n    providerItem.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent e) {\r\n            if (uiContact != null)\r\n                itemSelected(opSetClass, providerItem.getProtocolProvider(), contactString, uiContact);\r\n            else\r\n                itemSelected(opSetClass, providerItem.getProtocolProvider(), contactString);\r\n            if (callInterfaceListener != null)\r\n                callInterfaceListener.callInterfaceStarted();\r\n            ChooseCallAccountPopupMenu.this.setVisible(false);\r\n        }\r\n    });\r\n    this.add(providerItem);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.ChooseCallAccountPopupMenu.addTelephonyProviderItem",
	"Comment": "adds the given telephonyprovider to the list of availabletelephony providers.",
	"Method": "void addTelephonyProviderItem(ProtocolProviderService telephonyProvider,String contactString,Class<? extends OperationSet> opSetClass){\r\n    if (uiContact != null)\r\n        itemSelected(opSetClass, providerItem.getProtocolProvider(), contactString, uiContact);\r\n    else\r\n        itemSelected(opSetClass, providerItem.getProtocolProvider(), contactString);\r\n    if (callInterfaceListener != null)\r\n        callInterfaceListener.callInterfaceStarted();\r\n    ChooseCallAccountPopupMenu.this.setVisible(false);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.MetaContactListSource.protoContactMoved",
	"Comment": "adds the new metacontact parent and removes the old one if thefirst is matching the current filter and the last is no longer matchingit.",
	"Method": "void protoContactMoved(ProtoContactEvent evt){\r\n    final MetaContact oldParent = evt.getOldParent();\r\n    final MetaContact newParent = evt.getNewParent();\r\n    UIContact oldUIContact;\r\n    synchronized (oldParent) {\r\n        oldUIContact = MetaContactListSource.getUIContact(oldParent);\r\n    }\r\n    if (oldUIContact != null && !GuiActivator.getContactList().getCurrentFilter().isMatching(oldUIContact)) {\r\n        GuiActivator.getContactList().removeContact(oldUIContact);\r\n    }\r\n    UIContact newUIContact;\r\n    boolean newUIContactCreated = false;\r\n    synchronized (newParent) {\r\n        newUIContact = MetaContactListSource.getUIContact(newParent);\r\n        if (newUIContact == null) {\r\n            newUIContactCreated = true;\r\n            newUIContact = MetaContactListSource.createUIContact(newParent);\r\n        }\r\n    }\r\n    if (newUIContact != null && newUIContactCreated) {\r\n        if (GuiActivator.getContactList().getCurrentFilter().isMatching(newUIContact)) {\r\n            MetaContactGroup parentGroup = newParent.getParentMetaContactGroup();\r\n            UIGroup uiGroup = null;\r\n            if (!MetaContactListSource.isRootGroup(parentGroup)) {\r\n                uiGroup = MetaContactListSource.getUIGroup(parentGroup);\r\n                synchronized (parentGroup) {\r\n                    if (uiGroup == null)\r\n                        uiGroup = MetaContactListSource.createUIGroup(parentGroup);\r\n                }\r\n            }\r\n            GuiActivator.getContactList().addContact(newUIContact, uiGroup, true, true);\r\n        } else\r\n            MetaContactListSource.removeUIContact(newParent);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chatroomslist.joinforms.ChatRoomNamePanel.setChatRoomName",
	"Comment": "sets the given chat room name to the text field, contained in this panel.",
	"Method": "void setChatRoomName(String chatRoomName){\r\n    textField.setText(chatRoomName);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.replacers.ImgTagReplacer.replace",
	"Comment": "replace operation that replaces img tags that immediately close.",
	"Method": "void replace(StringBuilder target,String piece){\r\n    final Pattern p = Pattern.compile(\"<\\\\s*[iI][mM][gG](.*?)(/\\\\s*>)\");\r\n    final Matcher m = p.matcher(piece);\r\n    int slashIndex;\r\n    int start = 0;\r\n    while (m.find()) {\r\n        target.append(piece.substring(start, m.start()));\r\n        slashIndex = m.group().lastIndexOf(\"/\");\r\n        target.append(m.group().substring(0, slashIndex));\r\n        target.append(m.group().substring(slashIndex + 1));\r\n        target.append(\"<\/img>\");\r\n        start = m.end();\r\n    }\r\n    target.append(piece.substring(start));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.SmileysSelectorBox.actionPerformed",
	"Comment": "writes the symbol corresponding to a chosen smiley icon to the writemessage area at the end of the current text.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    SmileyMenuItem smileyItem = (SmileyMenuItem) e.getSource();\r\n    Smiley smiley = smileyItem.smiley;\r\n    chatPanel.getChatWritePanel().appendText(smiley.getDefaultString());\r\n    chatPanel.getChatWritePanel().getEditorPane().requestFocus();\r\n    clearMouseOverEffects(smileyItem);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.AbstractCallPeerJabberGTalkImpl.setDiscoveryInfo",
	"Comment": "sets the service discovery information that we have for this peer.",
	"Method": "void setDiscoveryInfo(DiscoverInfo discoverInfo){\r\n    this.discoverInfo = discoverInfo;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.replacement.flickr.ReplacementServiceFlickrImpl.getReplacement",
	"Comment": "replaces the flickr image links with their corresponding thumbnails.",
	"Method": "String getReplacement(String sourceString){\r\n    final Pattern p = Pattern.compile(\"\\\\/photos\\\\/[0-9a-zA-Z_\\\\-\\\\@]+\\\\/([0-9]+)(\\\\/[^\\\"\\\\<]*)*\", Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\r\n    Matcher m = p.matcher(sourceString);\r\n    String thumbUrl = sourceString;\r\n    while (m.find()) {\r\n        try {\r\n            String url = \"http://api.flickr.com/services/rest/\" + \"?method=flickr.photos.getInfo&api_key=\" + API_KEY + \"&photo_id=\" + m.group(1) + \"&format=json&nojsoncallback=1\";\r\n            URL flickrURL = new URL(url);\r\n            URLConnection conn = flickrURL.openConnection();\r\n            BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\r\n            String inputLine, holder = \"\";\r\n            while ((inputLine = in.readLine()) != null) holder = inputLine;\r\n            in.close();\r\n            JSONObject wrapper = (JSONObject) JSONValue.parseWithException(holder);\r\n            if (wrapper.get(\"stat\").equals(\"ok\")) {\r\n                JSONObject result = (JSONObject) wrapper.get(\"photo\");\r\n                if (!(result.isEmpty())) {\r\n                    String farmID = String.valueOf(result.get(\"farm\"));\r\n                    String serverID = (String) result.get(\"server\");\r\n                    String secret = (String) result.get(\"secret\");\r\n                    thumbUrl = \"http://farm\" + farmID + \".static.flickr.com/\" + serverID + \"/\" + m.group(1) + \"_\" + secret + \"_t.jpg\";\r\n                }\r\n            }\r\n        } catch (Throwable e) {\r\n            logger.error(\"Error parsing\", e);\r\n        }\r\n    }\r\n    return thumbUrl;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.reconnectplugin.ReconnectPluginActivator.getNotificationService",
	"Comment": "returns the notificationservice obtained from the bundle context.",
	"Method": "NotificationService getNotificationService(){\r\n    if (notificationService == null) {\r\n        ServiceReference serviceReference = bundleContext.getServiceReference(NotificationService.class.getName());\r\n        notificationService = (NotificationService) bundleContext.getService(serviceReference);\r\n        notificationService.registerDefaultNotificationForEvent(NETWORK_NOTIFICATIONS, NotificationAction.ACTION_POPUP_MESSAGE, null, null);\r\n    }\r\n    return notificationService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.gibberish.TestOperationSetBasicInstantMessaging.firstTestReceiveMessage",
	"Comment": "send an instant message from the tested operation set and assertreception by the tester agent.",
	"Method": "void firstTestReceiveMessage(){\r\n    String body = \"This is an IM coming from the tester agent\" + \" on \" + new Date().toString();\r\n    ImEventCollector evtCollector = new ImEventCollector();\r\n    opSetBasicIM1.addMessageListener(evtCollector);\r\n    Contact testerAgentContact = opSetPresence2.findContactByID(fixture.userID1);\r\n    logger.debug(\"Will send message \" + body + \" to: \" + testerAgentContact);\r\n    opSetBasicIM2.sendInstantMessage(testerAgentContact, opSetBasicIM2.createMessage(body));\r\n    evtCollector.waitForEvent(10000);\r\n    opSetBasicIM1.removeMessageListener(evtCollector);\r\n    assertTrue(\"No events delivered upon a received message\", evtCollector.collectedEvents.size() > 0);\r\n    assertTrue(\"Received evt was not an instance of \" + MessageReceivedEvent.class.getName(), evtCollector.collectedEvents.get(0) instanceof MessageReceivedEvent);\r\n    MessageReceivedEvent evt = (MessageReceivedEvent) evtCollector.collectedEvents.get(0);\r\n    assertEquals(\"message sender \", evt.getSourceContact().getAddress(), fixture.userID2);\r\n    assertEquals(\"message body\", body, evt.getSourceMessage().getContent());\r\n}"
}, {
	"Path": "net.librec.recommender.cf.UserKNNTestCase.test14SplitterGivenNItemDate",
	"Comment": "test givenndatasplitter with itemdate, evaluating enabled.",
	"Method": "void test14SplitterGivenNItemDate(){\r\n    Resource resource = new Resource(\"rec/cf/userknn-test.properties\");\r\n    conf.addResource(resource);\r\n    conf.set(\"rec.eval.enable\", \"true\");\r\n    conf.set(\"data.model.splitter\", \"givenn\");\r\n    conf.set(\"data.splitter.givenn.n\", \"5\");\r\n    conf.set(\"data.input.path\", \"test/datamodeltest/ratings-date.txt\");\r\n    conf.set(\"data.column.format\", \"UIRT\");\r\n    conf.set(\"data.splitter.givenn\", \"itemdate\");\r\n    RecommenderJob job = new RecommenderJob(conf);\r\n    job.runJob();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockMultiUserChat.getExistingChatRooms",
	"Comment": "returns the list of strings indicating chat roomscurrently available on the server that this protocol provider isconnected to.",
	"Method": "List<String> getExistingChatRooms(){\r\n    List<String> existingChatRoomNames = new ArrayList<String>(existingChatRooms.size());\r\n    for (ChatRoom existingChatRoom : existingChatRooms) existingChatRoomNames.add(existingChatRoom.getName());\r\n    return existingChatRoomNames;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomIrcImpl.getMembersCount",
	"Comment": "returns the number of participants that are currently in this chat room.",
	"Method": "int getMembersCount(){\r\n    return chatRoomMembers.size();\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.sip.TestOperationSetBasicInstantMessaging.firstTestReceiveMessage",
	"Comment": "send an instant message from the testing operation set and assertreception by the tested one.",
	"Method": "void firstTestReceiveMessage(){\r\n    String body = \"This is an IM coming from the tester agent\" + \" on \" + new Date().toString();\r\n    ImEventCollector evtCollector = new ImEventCollector();\r\n    opSetBasicIM1.addMessageListener(evtCollector);\r\n    Contact testerAgentContact = opSetPresence2.findContactByID(fixture.userID1);\r\n    logger.debug(\"Will send message \" + body + \" to: \" + testerAgentContact.getAddress());\r\n    opSetBasicIM2.sendInstantMessage(testerAgentContact, opSetBasicIM2.createMessage(body));\r\n    evtCollector.waitForEvent(25000);\r\n    opSetBasicIM1.removeMessageListener(evtCollector);\r\n    assertTrue(\"No events delivered upon a received message\", evtCollector.collectedEvents.size() > 0);\r\n    assertTrue(\"Received evt was not an instance of \" + MessageReceivedEvent.class.getName(), evtCollector.collectedEvents.get(0) instanceof MessageReceivedEvent);\r\n    MessageReceivedEvent evt = (MessageReceivedEvent) evtCollector.collectedEvents.get(0);\r\n    assertEquals(\"message sender \", evt.getSourceContact().getAddress(), fixture.userID2);\r\n    assertEquals(\"message body\", body, evt.getSourceMessage().getContent());\r\n    assertEquals(\"message content type\", OperationSetBasicInstantMessaging.DEFAULT_MIME_TYPE, evt.getSourceMessage().getContentType());\r\n    try {\r\n        synchronized (this) {\r\n            wait(5000);\r\n        }\r\n    } catch (InterruptedException e) {\r\n        logger.debug(\"the first test's wait has been interrupted, the \" + \"second test may fail\", e);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommTextField.getDefaultTextColor",
	"Comment": "gets the foreground color of the default text shown in this text field.",
	"Method": "Color getDefaultTextColor(){\r\n    return defaultTextColor;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.MainFrame.pluginComponentAdded",
	"Comment": "adds the associated with this plugincomponentevent component tothe appropriate container.",
	"Method": "void pluginComponentAdded(PluginComponentEvent event){\r\n    PluginComponentFactory factory = event.getPluginComponentFactory();\r\n    Container pluginContainer = factory.getContainer();\r\n    if (pluginContainer.equals(Container.CONTAINER_MAIN_WINDOW) || pluginContainer.equals(Container.CONTAINER_STATUS_BAR)) {\r\n        String pluginConstraints = factory.getConstraints();\r\n        Object constraints;\r\n        if (pluginConstraints != null)\r\n            constraints = UIServiceImpl.getBorderLayoutConstraintsFromContainer(pluginConstraints);\r\n        else\r\n            constraints = BorderLayout.SOUTH;\r\n        if (factory.isNativeComponent()) {\r\n            this.nativePluginsTable.add(factory);\r\n            if (isFrameVisible()) {\r\n                SwingUtilities.invokeLater(new Runnable() {\r\n                    public void run() {\r\n                        addNativePlugins();\r\n                    }\r\n                });\r\n            }\r\n        } else {\r\n            this.addPluginComponent((Component) factory.getPluginComponentInstance(MainFrame.this).getComponent(), pluginContainer, constraints);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.MainFrame.pluginComponentAdded",
	"Comment": "adds the associated with this plugincomponentevent component tothe appropriate container.",
	"Method": "void pluginComponentAdded(PluginComponentEvent event){\r\n    addNativePlugins();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetBasicTelephonyJabberImpl.unsubscribeForJinglePackets",
	"Comment": "unsubscribes us from notifications about incoming jingle packets.",
	"Method": "void unsubscribeForJinglePackets(){\r\n    Connection connection = protocolProvider.getConnection();\r\n    if (connection != null)\r\n        connection.removePacketListener(this);\r\n}"
}, {
	"Path": "io.lettuce.core.XClaimArgs.force",
	"Comment": "creates the pending message entry in the pel even if certain specified ids are not already in the pel assigned to adifferent client. however the message must be exist in the stream, otherwise the ids of non existing messages areignored.",
	"Method": "XClaimArgs force(XClaimArgs force,boolean force){\r\n    this.force = force;\r\n    return this;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.whiteboard.gui.whiteboardshapes.WhiteboardShapePolyLine.createPolyWorld",
	"Comment": "creates a generalpath with all the whiteboardpoint.this generalpath is used for the contains test.",
	"Method": "GeneralPath createPolyWorld(){\r\n    GeneralPath polyline = new GeneralPath(GeneralPath.WIND_EVEN_ODD, points.size());\r\n    if (points.size() <= 0)\r\n        return polyline;\r\n    WhiteboardPoint start = points.get(0);\r\n    polyline.moveTo((float) start.getX(), (float) start.getY());\r\n    WhiteboardPoint p;\r\n    for (int i = 0; i < points.size(); i++) {\r\n        p = points.get(i);\r\n        polyline.lineTo((float) p.getX(), (float) p.getY());\r\n    }\r\n    return polyline;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.plaf.SIPCommTabbedPaneEnhancedUI.isScrollTabVisible",
	"Comment": "checks whether the tabindex is visible in the scrollabletabs list.",
	"Method": "boolean isScrollTabVisible(int tabIndex){\r\n    Rectangle tabRect = rects[tabIndex];\r\n    Rectangle viewRect = tabScroller.viewport.getViewRect();\r\n    if ((tabRect.x + tabRect.width - BUTTONSIZE < viewRect.x) || (tabRect.x + BUTTONSIZE > viewRect.x + viewRect.width)) {\r\n        return false;\r\n    } else {\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.globaldisplaydetails.GlobalDisplayDetailsActivator.handleProviderAdded",
	"Comment": "used to attach the listeners to existing orjust registered protocol provider.",
	"Method": "void handleProviderAdded(ProtocolProviderService pps){\r\n    pps.addRegistrationStateChangeListener(displayDetailsImpl);\r\n    globalStatusService.handleProviderAdded(pps);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomIrcImpl.revokeMembership",
	"Comment": "revokes the membership role for the participant given by address",
	"Method": "void revokeMembership(String address){\r\n    final IrcConnection connection = this.parentProvider.getIrcStack().getConnection();\r\n    if (connection == null) {\r\n        throw new IllegalStateException(\"Connection is not available.\");\r\n    }\r\n    connection.getChannelManager().revoke(this, address, Mode.VOICE);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.ContactPropertyChangeEvent.getParentContactGroup",
	"Comment": "returns a reference to the source contact parent contactgroup.",
	"Method": "ContactGroup getParentContactGroup(){\r\n    return getSourceContact().getParentContactGroup();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.PayloadTypePacketExtension.setClockrate",
	"Comment": "specifies the sampling frequency in hertz used by this encoding.",
	"Method": "void setClockrate(int clockrate){\r\n    super.setAttribute(CLOCKRATE_ATTR_NAME, clockrate);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.GlobalStatusSelectorBox.changeTooltip",
	"Comment": "changes the tooltip to default or the current set status message.",
	"Method": "void changeTooltip(String message){\r\n    if (StringUtils.isNullOrEmpty(message)) {\r\n        if (globalStatusMessageMenu != null)\r\n            globalStatusMessageMenu.clearSelectedItems();\r\n        this.setToolTipText(\"<html><b>\" + GuiActivator.getResources().getI18NString(\"service.gui.SET_GLOBAL_STATUS\") + \"<\/b><\/html>\");\r\n        accountStatusPanel.setStatusMessage(null);\r\n    } else {\r\n        this.setToolTipText(\"<html><b>\" + message + \"<\/b><\/html>\");\r\n        accountStatusPanel.setStatusMessage(message);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ActiveCallsRepositorySipImpl.findCallPeer",
	"Comment": "returns the callpeersipimpl whose invite transaction has thespecified branchid and whose corresponding invite requestcontains the specified callid.",
	"Method": "CallPeerSipImpl findCallPeer(Dialog dialog,CallPeerSipImpl findCallPeer,String callID,String localTag,String remoteTag,CallPeerSipImpl findCallPeer,String branchID,String callID,CallPeerSipImpl findCallPeer,String branchID,Header cidHeader){\r\n    if (cidHeader == null || !(cidHeader instanceof CallIdHeader))\r\n        return null;\r\n    return findCallPeer(branchID, (((CallIdHeader) cidHeader).getCallId()));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapPersonFoundImpl.getFirstName",
	"Comment": "returns the first name found in the the directory for this person",
	"Method": "String getFirstName(){\r\n    return this.firstName;\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.SaveOptimizeTest.testCleanSessionWithinSavePeriod",
	"Comment": "test that repeated requests to a session where nothing changes does not dosaves.",
	"Method": "void testCleanSessionWithinSavePeriod(){\r\n    String contextPath = \"\";\r\n    String servletMapping = \"/server\";\r\n    int inactivePeriod = 600;\r\n    int scavengePeriod = 30;\r\n    DefaultSessionCacheFactory cacheFactory = new DefaultSessionCacheFactory();\r\n    cacheFactory.setEvictionPolicy(SessionCache.NEVER_EVICT);\r\n    cacheFactory.setSaveOnCreate(true);\r\n    TestSessionDataStoreFactory storeFactory = new TestSessionDataStoreFactory();\r\n    storeFactory.setSavePeriodSec(300);\r\n    _server1 = new TestServer(0, inactivePeriod, scavengePeriod, cacheFactory, storeFactory);\r\n    _servlet = new TestServlet();\r\n    ServletHolder holder = new ServletHolder(_servlet);\r\n    ServletContextHandler contextHandler = _server1.addContext(contextPath);\r\n    contextHandler.addServlet(holder, servletMapping);\r\n    _servlet.setStore(contextHandler.getSessionHandler().getSessionCache().getSessionDataStore());\r\n    _server1.start();\r\n    int port1 = _server1.getPort();\r\n    try (StacklessLogging stackless = new StacklessLogging(Log.getLogger(\"org.eclipse.jetty.server.session\"))) {\r\n        HttpClient client = new HttpClient();\r\n        try {\r\n            client.start();\r\n            String url = \"http://localhost:\" + port1 + contextPath + servletMapping + \"?action=create&check=true\";\r\n            ContentResponse response = client.GET(url);\r\n            assertEquals(HttpServletResponse.SC_OK, response.getStatus());\r\n            String sessionCookie = response.getHeaders().get(\"Set-Cookie\");\r\n            assertNotNull(sessionCookie);\r\n            String sessionId = TestServer.extractSessionId(sessionCookie);\r\n            SessionData data = contextHandler.getSessionHandler().getSessionCache().getSessionDataStore().load(sessionId);\r\n            assertNotNull(data);\r\n            int initialNumSaves = getNumSaves();\r\n            for (int i = 0; i < 5; i++) {\r\n                client.newRequest(\"http://localhost:\" + port1 + contextPath + servletMapping + \"?action=noop\").send();\r\n                SessionData d = contextHandler.getSessionHandler().getSessionCache().getSessionDataStore().load(sessionId);\r\n                assertNotNull(d);\r\n                assertThat(getNumSaves(), equalTo(initialNumSaves));\r\n                Thread.sleep(500);\r\n            }\r\n        } finally {\r\n            client.stop();\r\n        }\r\n    } finally {\r\n        _server1.stop();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.provisioning.ProvisioningActivator.getNetworkAddressManagerService",
	"Comment": "returns a reference to a networkaddressmanagerservice implementationcurrently registered in the bundle context or null if no suchimplementation was found.",
	"Method": "NetworkAddressManagerService getNetworkAddressManagerService(){\r\n    if (netaddrService == null) {\r\n        ServiceReference netaddrReference = bundleContext.getServiceReference(NetworkAddressManagerService.class.getName());\r\n        netaddrService = (NetworkAddressManagerService) bundleContext.getService(netaddrReference);\r\n    }\r\n    return netaddrService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.SingleWindowContainer.openChat",
	"Comment": "opens the specified chatpanel and optinally brings it to thefront.",
	"Method": "void openChat(ChatPanel chatPanel,boolean setSelected){\r\n    MainFrame mainWindow = GuiActivator.getUIService().getMainFrame();\r\n    if (mainWindow.getExtendedState() != JFrame.ICONIFIED) {\r\n        if (ConfigurationUtils.isAutoPopupNewMessage() || setSelected)\r\n            mainWindow.toFront();\r\n    } else {\r\n        if (setSelected) {\r\n            mainWindow.setExtendedState(JFrame.NORMAL);\r\n            mainWindow.toFront();\r\n        }\r\n        String chatWindowTitle = \"TEST\";\r\n        if (!chatWindowTitle.startsWith(\"*\"))\r\n            setTitle(\"*\" + chatWindowTitle);\r\n    }\r\n    if (setSelected) {\r\n        setCurrentChat(chatPanel);\r\n    } else if (!getCurrentChat().equals(chatPanel) && tabbedPane.getTabCount() > 0) {\r\n        highlightTab(chatPanel);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.busylampfield.CustomActionsBLFSourceContact.getCustomContactActionsMenuItems",
	"Comment": "returns all custom actions menu items defined by this service.",
	"Method": "Iterator<ContactActionMenuItem<SourceContact>> getCustomContactActionsMenuItems(){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.StatusSelectorMenu.paintComponent",
	"Comment": "paints this component. if the state of this menu is connecting, paintsthe connecting icon.",
	"Method": "void paintComponent(Graphics g){\r\n    AntialiasingManager.activateAntialiasing(g);\r\n    super.paintComponent(g);\r\n    if (isConnecting)\r\n        g.drawImage(getConnectingIcon(), 0, 3, this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.advancedconfig.AdvancedConfigurationPanel.valueChanged",
	"Comment": "called when user selects a component in the list of configuration forms.",
	"Method": "void valueChanged(ListSelectionEvent e){\r\n    if (!e.getValueIsAdjusting()) {\r\n        ConfigurationForm configForm = (ConfigurationForm) configList.getSelectedValue();\r\n        if (configForm != null)\r\n            showFormContent(configForm);\r\n    }\r\n}"
}, {
	"Path": "net.librec.recommender.cf.UserKNNTestCase.test19SplitterLOOCVItemDate",
	"Comment": "test loocvdatasplitter with item date, evaluating enabled.",
	"Method": "void test19SplitterLOOCVItemDate(){\r\n    Resource resource = new Resource(\"rec/cf/userknn-test.properties\");\r\n    conf.addResource(resource);\r\n    conf.set(\"data.model.splitter\", \"loocv\");\r\n    conf.set(\"data.input.path\", \"test/datamodeltest/ratings-date.txt\");\r\n    conf.set(\"data.column.format\", \"UIRT\");\r\n    conf.set(\"data.splitter.loocv\", \"itemdate\");\r\n    RecommenderJob job = new RecommenderJob(conf);\r\n    job.runJob();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.otr.OtrConfigurator.getPropertyInt",
	"Comment": "gets the value of a specific property as a signed decimal integer.",
	"Method": "int getPropertyInt(String id,int defaultValue){\r\n    return OtrActivator.configService.getInt(getID(id), defaultValue);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetDesktopSharingServerJabberImpl.accept",
	"Comment": "tests whether or not the specified packet should be handled by thisoperation set. this method is called by smack prior to packet deliveryand it would only accept inputevtiqs.",
	"Method": "boolean accept(Packet packet){\r\n    return (packet instanceof InputEvtIQ);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.contactlist.TestMetaContactListPersistence.assertUnresolvedContents",
	"Comment": "traverses all contacts and groups of root and throws a failureexception the moment if finds one of them not to be unresolved.",
	"Method": "void assertUnresolvedContents(ContactGroup root){\r\n    assertEquals(\"isResolved for grp:\" + root.getGroupName(), false, root.isResolved());\r\n    Iterator<Contact> contacts = root.contacts();\r\n    while (contacts.hasNext()) {\r\n        Contact contact = contacts.next();\r\n        assertEquals(\"isResolved for contact:\" + contact.getDisplayName(), false, contact.isResolved());\r\n    }\r\n    Iterator<ContactGroup> subgroups = root.subgroups();\r\n    while (subgroups.hasNext()) {\r\n        assertUnresolvedContents(subgroups.next());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.keybindingchooser.KeybindingChooserActivator.start",
	"Comment": "starts this bundle and adds thekeybindingsconfigpanel contained in it to the configurationwindow obtained from the uiservice.",
	"Method": "void start(BundleContext bc){\r\n    bundleContext = bc;\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Service Impl: \" + getClass().getName() + \" [  STARTED ]\");\r\n    if (!getConfigService().getBoolean(DISABLED_PROP, false)) {\r\n        Dictionary<String, String> properties = new Hashtable<String, String>();\r\n        properties.put(ConfigurationForm.FORM_TYPE, ConfigurationForm.ADVANCED_TYPE);\r\n        bc.registerService(ConfigurationForm.class.getName(), new LazyConfigurationForm(\"net.java.sip.communicator.plugin.keybindingchooser.KeybindingsConfigPanel\", getClass().getClassLoader(), \"plugin.keybinding.PLUGIN_ICON\", \"plugin.keybindings.PLUGIN_NAME\", 900, true), properties);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.credentialsstorage.CredentialsStorageServiceImpl.isStoredEncrypted",
	"Comment": "check if encrypted account password is saved in the configuration.",
	"Method": "boolean isStoredEncrypted(String accountPrefix){\r\n    return configurationService.getString(accountPrefix + \".\" + ACCOUNT_ENCRYPTED_PASSWORD) != null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.macosx.MacOSXAddrBookSourceContact.unlock",
	"Comment": "unlocks this object before after or removing several contact details.",
	"Method": "void unlock(){\r\n    synchronized (this) {\r\n        locked = Boolean.FALSE;\r\n        notify();\r\n        this.updated();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.MetaUIGroup.getRightButtonMenu",
	"Comment": "returns the jpopupmenu opened on a right button click over thisgroup in the contact list.",
	"Method": "JPopupMenu getRightButtonMenu(){\r\n    boolean hasReadonlyGroup = false;\r\n    Iterator<ContactGroup> groupsIterator = metaGroup.getContactGroups();\r\n    while (groupsIterator.hasNext()) {\r\n        ContactGroup group = groupsIterator.next();\r\n        OperationSetPersistentPresencePermissions opsetPermissions = group.getProtocolProvider().getOperationSet(OperationSetPersistentPresencePermissions.class);\r\n        if (opsetPermissions != null && opsetPermissions.isReadOnly(group)) {\r\n            hasReadonlyGroup = true;\r\n            break;\r\n        }\r\n    }\r\n    if (hasReadonlyGroup)\r\n        return null;\r\n    return new GroupRightButtonMenu(GuiActivator.getUIService().getMainFrame(), metaGroup);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetAutoAnswerSipImpl.getCallForward",
	"Comment": "get the value for automatically forward all calls to the specifiednumber using the same provider.",
	"Method": "String getCallForward(){\r\n    return this.callFwdTo;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ProtocolProviderServiceIrcImpl.getAccountID",
	"Comment": "returns the accountid that uniquely identifies the account representedby this instance of the protocolproviderservice.",
	"Method": "AccountID getAccountID(){\r\n    return accountID;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.filehistory.FileHistoryServiceImpl.findLastRecordsBefore",
	"Comment": "returns the supplied number of recent file transfers before the given date",
	"Method": "Collection<FileRecord> findLastRecordsBefore(MetaContact contact,Date date,int count){\r\n    TreeSet<FileRecord> result = new TreeSet<FileRecord>(new FileRecordComparator());\r\n    Map<Contact, HistoryReader> readers = getHistoryReaders(contact);\r\n    for (Map.Entry<Contact, HistoryReader> readerEntry : readers.entrySet()) {\r\n        Contact c = readerEntry.getKey();\r\n        HistoryReader reader = readerEntry.getValue();\r\n        Iterator<HistoryRecord> recs = reader.findLastRecordsBefore(date, count);\r\n        while (recs.hasNext()) {\r\n            result.add(createFileRecordFromHistoryRecord(recs.next(), c));\r\n        }\r\n    }\r\n    LinkedList<FileRecord> resultAsList = new LinkedList<FileRecord>(result);\r\n    int startIndex = resultAsList.size() - count;\r\n    if (startIndex < 0)\r\n        startIndex = 0;\r\n    return resultAsList.subList(startIndex, resultAsList.size());\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.keybindingchooser.ComponentTools.makeDialog",
	"Comment": "generates a modal dialog capable of having either a frame or dialog parent.",
	"Method": "JDialog makeDialog(Component parent,String title){\r\n    parent = findParent(parent);\r\n    if (parent == null)\r\n        throw new AWTError(\"No suitable parent found for Component.\");\r\n    else if (parent instanceof Frame)\r\n        return new JDialog((Frame) parent, title, true);\r\n    else\r\n        return new JDialog((Dialog) parent, title, true);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl.getOurDisplayName",
	"Comment": "returns the display name string that the user has set as a display namefor this account.",
	"Method": "String getOurDisplayName(){\r\n    return ourDisplayName;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.DynamicPayloadTypeRegistry.getPreferredDynamicPayloadType",
	"Comment": "returns the payload type number that format would like to use ifpossible and null if there is no such preference.",
	"Method": "Byte getPreferredDynamicPayloadType(MediaFormat format){\r\n    Map<MediaFormat, Byte> ptPreferences = getDynamicPayloadTypePreferences();\r\n    return getPayloadTypeFromMap(ptPreferences, format);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ContactGroupIrcImpl.findContact",
	"Comment": "find contact by searching through direct contacts and subsequentlycontinue searching in subgroups.",
	"Method": "ContactIrcImpl findContact(String id){\r\n    ContactIrcImpl contact = getContact(id);\r\n    if (contact != null) {\r\n        return contact;\r\n    }\r\n    for (ContactGroupIrcImpl subgroup : this.subgroups) {\r\n        contact = subgroup.findContact(id);\r\n        if (contact != null) {\r\n            return contact;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.common.extensions.FragmentExtensionTest.testOutgoingFramesByMaxLength",
	"Comment": "verify that outgoing text frames are fragmented by the maxlength configuration.",
	"Method": "void testOutgoingFramesByMaxLength(){\r\n    OutgoingFramesCapture capture = new OutgoingFramesCapture();\r\n    FragmentExtension ext = new FragmentExtension();\r\n    ext.setBufferPool(bufferPool);\r\n    ext.setPolicy(WebSocketPolicy.newServerPolicy());\r\n    ExtensionConfig config = ExtensionConfig.parse(\"fragment;maxLength=20\");\r\n    ext.setConfig(config);\r\n    ext.setNextOutgoingFrames(capture);\r\n    List<String> quote = new ArrayList();\r\n    quote.add(\"No amount of experimentation can ever prove me right;\");\r\n    quote.add(\"a single experiment can prove me wrong.\");\r\n    quote.add(\"-- Albert Einstein\");\r\n    for (String section : quote) {\r\n        Frame frame = new TextFrame().setPayload(section);\r\n        ext.outgoingFrame(frame, null, BatchMode.OFF);\r\n    }\r\n    List<WebSocketFrame> expectedFrames = new ArrayList();\r\n    expectedFrames.add(new TextFrame().setPayload(\"No amount of experim\").setFin(false));\r\n    expectedFrames.add(new ContinuationFrame().setPayload(\"entation can ever pr\").setFin(false));\r\n    expectedFrames.add(new ContinuationFrame().setPayload(\"ove me right;\").setFin(true));\r\n    expectedFrames.add(new TextFrame().setPayload(\"a single experiment \").setFin(false));\r\n    expectedFrames.add(new ContinuationFrame().setPayload(\"can prove me wrong.\").setFin(true));\r\n    expectedFrames.add(new TextFrame().setPayload(\"-- Albert Einstein\").setFin(true));\r\n    int len = expectedFrames.size();\r\n    capture.assertFrameCount(len);\r\n    String prefix;\r\n    LinkedList<WebSocketFrame> frames = capture.getFrames();\r\n    for (int i = 0; i < len; i++) {\r\n        prefix = \"Frame[\" + i + \"]\";\r\n        WebSocketFrame actualFrame = frames.get(i);\r\n        WebSocketFrame expectedFrame = expectedFrames.get(i);\r\n        assertThat(prefix + \".opcode\", actualFrame.getOpCode(), is(expectedFrame.getOpCode()));\r\n        assertThat(prefix + \".fin\", actualFrame.isFin(), is(expectedFrame.isFin()));\r\n        assertThat(prefix + \".rsv1\", actualFrame.isRsv1(), is(expectedFrame.isRsv1()));\r\n        assertThat(prefix + \".rsv2\", actualFrame.isRsv2(), is(expectedFrame.isRsv2()));\r\n        assertThat(prefix + \".rsv3\", actualFrame.isRsv3(), is(expectedFrame.isRsv3()));\r\n        ByteBuffer expectedData = expectedFrame.getPayload().slice();\r\n        ByteBuffer actualData = actualFrame.getPayload().slice();\r\n        assertThat(prefix + \".payloadLength\", actualData.remaining(), is(expectedData.remaining()));\r\n        ByteBufferAssert.assertEquals(prefix + \".payload\", expectedData, actualData);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.whiteboard.gui.whiteboardshapes.WhiteboardShapePolygon.createPolyWorld",
	"Comment": "creates a generalpath with all the whiteboardpoint.this generalpath is used for the contains test.",
	"Method": "GeneralPath createPolyWorld(){\r\n    GeneralPath polygon = new GeneralPath(GeneralPath.WIND_EVEN_ODD, points.size());\r\n    if (points.size() <= 0)\r\n        return polygon;\r\n    WhiteboardPoint start = points.get(0);\r\n    polygon.moveTo((float) start.getX(), (float) start.getY());\r\n    WhiteboardPoint p;\r\n    for (int i = 0; i < points.size(); i++) {\r\n        p = points.get(i);\r\n        polygon.lineTo((float) p.getX(), (float) p.getY());\r\n    }\r\n    polygon.closePath();\r\n    return polygon;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.filehistory.FileHistoryServiceImpl.findByKeyword",
	"Comment": "returns all the file transfers having the given keyword in the filename",
	"Method": "Collection<FileRecord> findByKeyword(MetaContact contact,String keyword,Collection<FileRecord> findByKeyword,MetaContact contact,String keyword,boolean caseSensitive){\r\n    return findByKeywords(contact, new String[] { keyword }, caseSensitive);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.VolumeControlSlider.removeNotify",
	"Comment": "makes this component undisplayable by destroying it native screen resource. stops the thread loop to change volume.",
	"Method": "void removeNotify(){\r\n    super.removeNotify();\r\n    if (setVolumeThread.isAlive()) {\r\n        setVolumeThread.end();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.presence.StatusMessageMenu.getDescriptor",
	"Comment": "returns the descriptor common for this status message menu instance.",
	"Method": "Object getDescriptor(){\r\n    return protocolProvider;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractOperationSetPersistentPresence.addContactPresenceStatusListener",
	"Comment": "implementation of the corresponding protocolproviderservicemethod.",
	"Method": "void addContactPresenceStatusListener(ContactPresenceStatusListener listener){\r\n    synchronized (contactPresenceStatusListeners) {\r\n        if (!contactPresenceStatusListeners.contains(listener))\r\n            contactPresenceStatusListeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.generalconfig.Resources.getString",
	"Comment": "returns an internationalized string corresponding to the given key.",
	"Method": "String getString(String key,String getString,String key,String[] params){\r\n    return getResources().getI18NString(key, params);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.contactlist.TestMetaContactList.testRenameMetaContact",
	"Comment": "renames a contact in the contact list and verifies whether the new namehas taken effect and whether the corresponding event has been dispatched.",
	"Method": "void testRenameMetaContact(){\r\n    String newName = \"testRenameMetaContact.AyNewName\";\r\n    MockContact mockContact = MetaContactListServiceLick.mockContactToRename;\r\n    String oldMockContactDisplayName = mockContact.getDisplayName();\r\n    MetaContact contactToRename = fixture.metaClService.findMetaContactByContact(mockContact);\r\n    MclEventCollector evtCollector = new MclEventCollector();\r\n    fixture.metaClService.addMetaContactListListener(evtCollector);\r\n    fixture.metaClService.renameMetaContact(contactToRename, newName);\r\n    fixture.metaClService.removeMetaContactListListener(evtCollector);\r\n    assertEquals(\"Events delivered while renaming a meta contact\", 1, evtCollector.collectedMetaContactEvents.size());\r\n    MetaContactRenamedEvent event = (MetaContactRenamedEvent) evtCollector.collectedMetaContactEvents.remove(0);\r\n    assertSame(\"Source contact in MetaContactRenamedEvent gen. upon remove.\", contactToRename, event.getSourceMetaContact());\r\n    assertEquals(\"Event ID in MetaContactEvent gen. upon remove.\", MetaContactPropertyChangeEvent.META_CONTACT_RENAMED, event.getPropertyName());\r\n    assertEquals(\"DisplayName of a MetaContact unchanged after renaming\", newName, contactToRename.getDisplayName());\r\n    assertEquals(\"Proto Contact modified after renaming a MetaContact\", oldMockContactDisplayName, mockContact.getDisplayName());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.globalshortcut.GlobalShortcutActivator.handleProviderAdded",
	"Comment": "notifies this manager that a specificprotocolproviderservice has been registered as a service.",
	"Method": "void handleProviderAdded(ProtocolProviderService provider){\r\n    OperationSetBasicTelephony<?> opSet = provider.getOperationSet(OperationSetBasicTelephony.class);\r\n    if (opSet != null)\r\n        opSet.addCallListener(globalShortcutService.getCallShortcut());\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler.findExtension",
	"Comment": "returns the first rtpextension in extlist that usesthe specified extensionurn or null if extlistdid not contain such an extension.",
	"Method": "RTPExtension findExtension(List<RTPExtension> extList,String extensionURN){\r\n    for (RTPExtension rtpExt : extList) if (rtpExt.getURI().toASCIIString().equals(extensionURN))\r\n        return rtpExt;\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chatroomslist.createforms.CreateChatRoomWizardPage1.editingStopped",
	"Comment": "when user stopped editing the next button is enabled or disableddepending on if the user has selected a check box or not.",
	"Method": "void editingStopped(ChangeEvent e){\r\n    setNextButtonAccordingToCheckBox();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.notificationconfiguration.NotificationsTable.removeEntry",
	"Comment": "removes the row corresponding to the given entry from the table.",
	"Method": "void removeEntry(NotificationEntry entry){\r\n    int row = indexOfEntry(entry);\r\n    notifTable.removeRowSelectionInterval(row, row);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactImpl.setDisplayNameUserDefined",
	"Comment": "changes that display name was changed forthis metacontact in user interface.",
	"Method": "void setDisplayNameUserDefined(boolean value){\r\n    this.isDisplayNameUserDefined = value;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ContactPhotoPanel.setChatSession",
	"Comment": "sets the given chatsession parameters to this contactphoto label.",
	"Method": "void setChatSession(ChatSession chatSession){\r\n    this.chatSession = chatSession;\r\n    byte[] chatAvatar = chatSession.getChatAvatar();\r\n    if (chatAvatar != null && chatAvatar.length > 0) {\r\n        this.tooltipIcon = new ImageIcon(chatAvatar);\r\n        ImageIcon contactPhotoIcon = ImageUtils.getScaledRoundedIcon(chatAvatar, ChatContact.AVATAR_ICON_WIDTH, ChatContact.AVATAR_ICON_HEIGHT);\r\n        if (contactPhotoIcon != null)\r\n            this.photoLabel.setIcon(contactPhotoIcon);\r\n    } else {\r\n        this.photoLabel.setIcon(null);\r\n        this.tooltipIcon = null;\r\n    }\r\n    this.setToolTipText(\"\");\r\n    if (!chatSession.isDescriptorPersistent() && !(chatSession instanceof ConferenceChatSession) && !ConfigurationUtils.isAddContactDisabled() && !(chatSession.getPersistableAddress() == null))\r\n        this.add(addContactButton, 0);\r\n    else\r\n        this.remove(addContactButton);\r\n    this.revalidate();\r\n    this.repaint();\r\n}"
}, {
	"Path": "org.joor.Reflect.as",
	"Comment": "create a proxy for the wrapped object allowing to typesafely invokemethods on it using a custom interface",
	"Method": "P as(Class<P> proxyType){\r\n    final boolean isMap = (object instanceof Map);\r\n    final InvocationHandler handler = new InvocationHandler() {\r\n        @Override\r\n        @SuppressWarnings(\"null\")\r\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n            String name = method.getName();\r\n            try {\r\n                return on(type, object).call(name, args).get();\r\n            } catch (ReflectException e) {\r\n                if (isMap) {\r\n                    Map<String, Object> map = (Map<String, Object>) object;\r\n                    int length = (args == null ? 0 : args.length);\r\n                    if (length == 0 && name.startsWith(\"get\")) {\r\n                        return map.get(property(name.substring(3)));\r\n                    } else if (length == 0 && name.startsWith(\"is\")) {\r\n                        return map.get(property(name.substring(2)));\r\n                    } else if (length == 1 && name.startsWith(\"set\")) {\r\n                        map.put(property(name.substring(3)), args[0]);\r\n                        return null;\r\n                    }\r\n                }\r\n                if (method.isDefault()) {\r\n                    return CACHED_LOOKUP_CONSTRUCTOR.newInstance(proxyType).unreflectSpecial(method, proxyType).bindTo(proxy).invokeWithArguments(args);\r\n                }\r\n                throw e;\r\n            }\r\n        }\r\n    };\r\n    return (P) Proxy.newProxyInstance(proxyType.getClassLoader(), new Class[] { proxyType }, handler);\r\n}"
}, {
	"Path": "org.joor.Reflect.as",
	"Comment": "create a proxy for the wrapped object allowing to typesafely invokemethods on it using a custom interface",
	"Method": "P as(Class<P> proxyType){\r\n    String name = method.getName();\r\n    try {\r\n        return on(type, object).call(name, args).get();\r\n    } catch (ReflectException e) {\r\n        if (isMap) {\r\n            Map<String, Object> map = (Map<String, Object>) object;\r\n            int length = (args == null ? 0 : args.length);\r\n            if (length == 0 && name.startsWith(\"get\")) {\r\n                return map.get(property(name.substring(3)));\r\n            } else if (length == 0 && name.startsWith(\"is\")) {\r\n                return map.get(property(name.substring(2)));\r\n            } else if (length == 1 && name.startsWith(\"set\")) {\r\n                map.put(property(name.substring(3)), args[0]);\r\n                return null;\r\n            }\r\n        }\r\n        if (method.isDefault()) {\r\n            return CACHED_LOOKUP_CONSTRUCTOR.newInstance(proxyType).unreflectSpecial(method, proxyType).bindTo(proxy).invokeWithArguments(args);\r\n        }\r\n        throw e;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.MUCServiceImpl.getChatRoomWrapperByChatRoom",
	"Comment": "searches for chat room wrapper in chat room list by chat room.",
	"Method": "ChatRoomWrapper getChatRoomWrapperByChatRoom(ChatRoom chatRoom,boolean create){\r\n    ChatRoomWrapper chatRoomWrapper = chatRoomList.findChatRoomWrapperFromChatRoom(chatRoom);\r\n    if ((chatRoomWrapper == null) && create) {\r\n        ChatRoomProviderWrapper parentProvider = chatRoomList.findServerWrapperFromProvider(chatRoom.getParentProvider());\r\n        chatRoomWrapper = new ChatRoomWrapperImpl(parentProvider, chatRoom);\r\n        chatRoomList.addChatRoom(chatRoomWrapper);\r\n    }\r\n    return chatRoomWrapper;\r\n}"
}, {
	"Path": "io.lettuce.core.dynamic.support.ReflectionUtils.handleInvocationTargetException",
	"Comment": "handle the given invocation target exception. should only be called if no checked exception is expected to be thrown bythe target method.throws the underlying runtimeexception or error in case of such a root cause. throws an undeclaredthrowableexceptionotherwise.",
	"Method": "void handleInvocationTargetException(InvocationTargetException ex){\r\n    rethrowRuntimeException(ex.getTargetException());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.xcap.BaseHttpXCapClient.createResponse",
	"Comment": "creates xcap response from http response.if http code is 200, 201 or 409 the http content would be read.",
	"Method": "XCapHttpResponse createResponse(HttpResponse response){\r\n    XCapHttpResponse xcapHttpResponse = new XCapHttpResponse();\r\n    int statusCode = response.getStatusLine().getStatusCode();\r\n    if (statusCode == HttpStatus.SC_OK || statusCode == HttpStatus.SC_CREATED || statusCode == HttpStatus.SC_CONFLICT) {\r\n        String contentType = getSingleHeaderValue(response, HEADER_CONTENT_TYPE);\r\n        byte[] content = StreamUtils.read(response.getEntity().getContent());\r\n        String eTag = getSingleHeaderValue(response, HEADER_ETAG);\r\n        xcapHttpResponse.setContentType(contentType);\r\n        xcapHttpResponse.setContent(content);\r\n        xcapHttpResponse.setETag(eTag);\r\n    }\r\n    xcapHttpResponse.setHttpCode(statusCode);\r\n    return xcapHttpResponse;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.authorization.RequestAuthorizationDialog.showDialog",
	"Comment": "shows this modal dialog and returns the result of the user choice.",
	"Method": "void showDialog(){\r\n    this.setVisible(true);\r\n    this.requestField.requestFocus();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommTextArea.setDefaultTextColor",
	"Comment": "sets the foreground color of the default text shown in this text field.",
	"Method": "void setDefaultTextColor(Color c){\r\n    defaultTextColor = c;\r\n    if (isDefaultTextVisible)\r\n        setForeground(defaultTextColor);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.sipaccregwizz.SIPAccountRegistrationWizard.getFirstPageIdentifier",
	"Comment": "returns the identifier of the page to show first in the wizard.",
	"Method": "Object getFirstPageIdentifier(){\r\n    return firstWizardPage.getIdentifier();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.osdependent.Resources.getMnemonic",
	"Comment": "returns an internationalized string corresponding to the given key.",
	"Method": "char getMnemonic(String key){\r\n    return getResources().getI18nMnemonic(key);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.resources.ResourceManagementServiceImpl.getImageInputStreamForPath",
	"Comment": "returns the inputstream of the image corresponding to the givenpath.",
	"Method": "InputStream getImageInputStreamForPath(String path){\r\n    SkinPack skinPack = getSkinPack();\r\n    if (skinPack != null) {\r\n        if (skinPack.getClass().getClassLoader().getResourceAsStream(path) != null) {\r\n            return skinPack.getClass().getClassLoader().getResourceAsStream(path);\r\n        }\r\n    }\r\n    ImagePack imagePack = getImagePack();\r\n    if (path != null && imagePack != null)\r\n        return imagePack.getClass().getClassLoader().getResourceAsStream(path);\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractOperationSetTypingNotifications.assertConnected",
	"Comment": "utility method throwing an exception if the stack is not properlyinitialized.",
	"Method": "void assertConnected(){\r\n    if (parentProvider == null)\r\n        throw new IllegalStateException(\"The provider must be non-null\" + \" before being able to communicate.\");\r\n    if (!parentProvider.isRegistered())\r\n        throw new IllegalStateException(\"The provider must be signed on the service\" + \" before being able to communicate.\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.menus.EditMenu.actionPerformed",
	"Comment": "handles the actionevent when one of the menu items is selected.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    JMenuItem menuItem = (JMenuItem) e.getSource();\r\n    String menuItemName = menuItem.getName();\r\n    if (menuItemName.equalsIgnoreCase(\"cut\")) {\r\n        this.chatWindow.getCurrentChat().cut();\r\n    } else if (menuItemName.equalsIgnoreCase(\"copy\")) {\r\n        this.chatWindow.getCurrentChat().copy();\r\n    } else if (menuItemName.equalsIgnoreCase(\"paste\")) {\r\n        this.chatWindow.getCurrentChat().paste();\r\n    } else if (menuItemName.equalsIgnoreCase(\"font\")) {\r\n        this.chatWindow.getCurrentChat().showFontChooserDialog();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.AdHocConferenceChatTransport.isContentTypeSupported",
	"Comment": "determines whether this chat transport supports the supplied content type",
	"Method": "boolean isContentTypeSupported(String contentType){\r\n    return OperationSetBasicInstantMessaging.DEFAULT_MIME_TYPE.equals(contentType);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.configuration.TestConfigurationService.testSinglePropertyVetoEventNotification",
	"Comment": "make sure that adding vetoable listeners for a single property nameonly gets us events for that listeners. removing a listener for aspecific property should also be proved to no obstruct event delivery tothe same listener had it been registered for other properties.",
	"Method": "void testSinglePropertyVetoEventNotification(){\r\n    String listenedPropertyValue = \"19.2598\";\r\n    String listenedPropertyNewValue = \"19.29581\";\r\n    ConfigVetoableChangeListener vetoListener = new ConfigVetoableChangeListener() {\r\n        public void vetoableChange(PropertyChangeEvent event) {\r\n            propertyChangeEvent = event;\r\n        }\r\n    };\r\n    configurationService.addVetoableChangeListener(listenedPropertyName, vetoListener);\r\n    propertyChangeEvent = null;\r\n    configurationService.setProperty(propertyName, propertyValue);\r\n    assertNull(\"setting prop:\" + propertyName + \" caused an event notif. to \" + \"listener registered for prop:\" + listenedPropertyName, propertyChangeEvent);\r\n    configurationService.setProperty(listenedPropertyName, listenedPropertyValue);\r\n    assertNotNull(\"No event was dispatched upon modification of prop:\" + listenedPropertyName, propertyChangeEvent);\r\n    assertNull(\"oldValue must be null\", propertyChangeEvent.getOldValue());\r\n    assertEquals(\"wrong newValue\", listenedPropertyValue, propertyChangeEvent.getNewValue());\r\n    propertyChangeEvent = null;\r\n    configurationService.removeVetoableChangeListener(vetoListener);\r\n    configurationService.setProperty(listenedPropertyName, listenedPropertyNewValue);\r\n    assertNotNull(\"No event was dispatched upon modification of prop:\" + listenedPropertyName + \". The listener was wrongfully removed.\", propertyChangeEvent);\r\n    assertEquals(\"wrong oldValue\", listenedPropertyValue, propertyChangeEvent.getOldValue());\r\n    assertEquals(\"wrong newValue\", listenedPropertyNewValue, propertyChangeEvent.getNewValue());\r\n    propertyChangeEvent = null;\r\n    configurationService.removeVetoableChangeListener(listenedPropertyName, vetoListener);\r\n    configurationService.setProperty(listenedPropertyName, listenedPropertyValue);\r\n    assertNull(\"An event was wrongfully dispatched after removing a listener\", propertyChangeEvent);\r\n    propertyChangeEvent = null;\r\n    configurationService.addVetoableChangeListener(vetoListener);\r\n    configurationService.addVetoableChangeListener(listenedPropertyName, vetoListener);\r\n    configurationService.removeVetoableChangeListener(listenedPropertyName, vetoListener);\r\n    configurationService.setProperty(listenedPropertyName, listenedPropertyNewValue);\r\n    assertNotNull(\"No event was dispatched upon modification of prop:\" + listenedPropertyName + \". The global listener was wrongfully removed.\", propertyChangeEvent);\r\n    assertEquals(\"wrong propertyName\", listenedPropertyName, propertyChangeEvent.getPropertyName());\r\n    assertEquals(\"wrong oldValue\", listenedPropertyValue, propertyChangeEvent.getOldValue());\r\n    assertEquals(\"wrong newValue\", listenedPropertyNewValue, propertyChangeEvent.getNewValue());\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.configuration.TestConfigurationService.testSinglePropertyVetoEventNotification",
	"Comment": "make sure that adding vetoable listeners for a single property nameonly gets us events for that listeners. removing a listener for aspecific property should also be proved to no obstruct event delivery tothe same listener had it been registered for other properties.",
	"Method": "void testSinglePropertyVetoEventNotification(){\r\n    propertyChangeEvent = event;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.OperationSetMultiUserChatIrcImpl.fireInvitationEvent",
	"Comment": "delivers a chatroominvitationreceivedevent to allregistered chatroominvitationlisteners.",
	"Method": "void fireInvitationEvent(ChatRoom targetChatRoom,String inviter,String reason,byte[] password){\r\n    ChatRoomInvitationIrcImpl invitation = new ChatRoomInvitationIrcImpl(targetChatRoom, inviter, reason, password);\r\n    fireInvitationReceived(invitation);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.MetaContactChatSession.getHistory",
	"Comment": "returns a collection of the last n number of messages given by count.",
	"Method": "Collection<Object> getHistory(int count){\r\n    final MetaHistoryService metaHistory = GuiActivator.getMetaHistoryService();\r\n    if (metaHistory == null)\r\n        return null;\r\n    return metaHistory.findLast(chatHistoryFilter, metaContact, ConfigurationUtils.getChatHistorySize());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetDesktopSharingServerSipImpl.disableRemoteControl",
	"Comment": "disable desktop remote control. local desktop stop regenerates keyboardand mouse events received from peer.",
	"Method": "void disableRemoteControl(CallPeer callPeer){\r\n    try {\r\n        Address addr = parentProvider.parseAddressString(callPeer.getAddress());\r\n        subscriber.unsubscribe(addr, false);\r\n    } catch (ParseException ex) {\r\n        logger.error(\"Failed to parse address\", ex);\r\n    } catch (OperationFailedException ofe) {\r\n        logger.error(\"Failed to create or send a remote-control unsubscription\", ofe);\r\n        return;\r\n    }\r\n    remoteControlEnabled = false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.mailnotification.MailThreadInfo.getSenderCount",
	"Comment": "returns the number of people that have been posting in this thread.",
	"Method": "int getSenderCount(){\r\n    return senders.size();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ContactListModel.isShowOffline",
	"Comment": "returns true if offline contacts should be shown, false otherwise.",
	"Method": "boolean isShowOffline(){\r\n    return showOffline;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.certconfig.CertConfigActivator.getConfigService",
	"Comment": "returns a reference to a configurationservice implementation currentlyregistered in the bundle context or null if no such implementation wasfound.",
	"Method": "ConfigurationService getConfigService(){\r\n    return ServiceUtils.getService(bundleContext, ConfigurationService.class);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl.getTransportManager",
	"Comment": "returns the transport manager that is handling our address management.",
	"Method": "TransportManagerSipImpl getTransportManager(){\r\n    return transportManager;\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.CreationTest.testSessionCreateForward",
	"Comment": "create a session in a context, forward to another context and create a session in it too. check that both sessions exist after the responsecompletes.",
	"Method": "void testSessionCreateForward(){\r\n    String contextPath = \"\";\r\n    String contextB = \"/contextB\";\r\n    String servletMapping = \"/server\";\r\n    int inactivePeriod = 20;\r\n    int scavengePeriod = 3;\r\n    DefaultSessionCacheFactory cacheFactory = new DefaultSessionCacheFactory();\r\n    cacheFactory.setEvictionPolicy(SessionCache.NEVER_EVICT);\r\n    SessionDataStoreFactory storeFactory = new TestSessionDataStoreFactory();\r\n    TestServer server1 = new TestServer(0, inactivePeriod, scavengePeriod, cacheFactory, storeFactory);\r\n    TestServlet servlet = new TestServlet();\r\n    ServletHolder holder = new ServletHolder(servlet);\r\n    ServletContextHandler contextHandler = server1.addContext(contextPath);\r\n    TestContextScopeListener scopeListener = new TestContextScopeListener();\r\n    contextHandler.addEventListener(scopeListener);\r\n    contextHandler.addServlet(holder, servletMapping);\r\n    ServletContextHandler ctxB = server1.addContext(contextB);\r\n    ctxB.addServlet(TestServletB.class, servletMapping);\r\n    server1.start();\r\n    int port1 = server1.getPort();\r\n    try (StacklessLogging stackless = new StacklessLogging(Log.getLogger(\"org.eclipse.jetty.server.session\"))) {\r\n        HttpClient client = new HttpClient();\r\n        client.start();\r\n        String url = \"http://localhost:\" + port1 + contextPath + servletMapping;\r\n        CountDownLatch synchronizer = new CountDownLatch(1);\r\n        scopeListener.setExitSynchronizer(synchronizer);\r\n        ContentResponse response = client.GET(url + \"?action=forward\");\r\n        assertEquals(HttpServletResponse.SC_OK, response.getStatus());\r\n        synchronizer.await(5, TimeUnit.SECONDS);\r\n        assertTrue(contextHandler.getSessionHandler().getSessionCache().getSessionDataStore().exists(servlet._id));\r\n        assertTrue(ctxB.getSessionHandler().getSessionCache().getSessionDataStore().exists(servlet._id));\r\n    } finally {\r\n        server1.stop();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.contactinfo.ContactInfoActivator.getContactListService",
	"Comment": "returns the metacontactlistservice obtained from the bundlecontext.",
	"Method": "MetaContactListService getContactListService(){\r\n    if (metaCListService == null) {\r\n        metaCListService = ServiceUtils.getService(bundleContext, MetaContactListService.class);\r\n    }\r\n    return metaCListService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommTextField.setDefaultTextColor",
	"Comment": "sets the foreground color of the default text shown in this text field.",
	"Method": "void setDefaultTextColor(Color c){\r\n    defaultTextColor = c;\r\n    if (isDefaultTextVisible)\r\n        setForeground(defaultTextColor);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ContactIcqImpl.setResolved",
	"Comment": "specifies whether this contact has been resolved, or in other words thatits presence in the server stored contact list has been confirmed.unresolved contacts are created by services which need to quickly obtaina reference to the contact corresponding to a specific address possiblyeven before logging on the net.",
	"Method": "void setResolved(boolean resolved){\r\n    this.isResolved = resolved;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.JabberAccountCreationForm.getCompleteUserID",
	"Comment": "returns the complete user id, by adding to it the server part.",
	"Method": "String getCompleteUserID(String userID,String server){\r\n    if (userID.indexOf(\"@\") < 0 && server != null && server.length() > 0) {\r\n        return userID + \"@\" + server;\r\n    }\r\n    return userID;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatTransport.removeInstantMessageListener",
	"Comment": "removes the instant message listener from this chat transport.",
	"Method": "void removeInstantMessageListener(MessageListener l){\r\n    if (!allowsInstantMessage())\r\n        return;\r\n    OperationSetBasicInstantMessaging imOpSet = chatRoom.getParentProvider().getOperationSet(OperationSetBasicInstantMessaging.class);\r\n    imOpSet.removeMessageListener(l);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.gibberish.TestOperationSetPersistentPresence.suite",
	"Comment": "creates a test suite containing all tests of this class followed bytest methods that we want executed in a specified order.",
	"Method": "Test suite(){\r\n    TestSuite suite = new TestSuite();\r\n    suite.addTest(new TestOperationSetPersistentPresence(\"postTestCreateGroup\"));\r\n    suite.addTest(new TestOperationSetPersistentPresence(\"postTestRenameGroup\"));\r\n    suite.addTest(new TestOperationSetPersistentPresence(\"postTestRemoveGroup\"));\r\n    suite.addTest(new TestOperationSetPersistentPresence(\"prepareContactList\"));\r\n    suite.addTestSuite(TestOperationSetPersistentPresence.class);\r\n    return suite;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.chatalerter.ChatAlerterActivator.localUserPresenceChanged",
	"Comment": "called to notify interested parties that a change in our presence ina chat room has occurred. changes may include us being kicked, join,left.",
	"Method": "void localUserPresenceChanged(LocalUserChatRoomPresenceChangeEvent ev){\r\n    ChatRoom chatRoom = ev.getChatRoom();\r\n    if (LocalUserChatRoomPresenceChangeEvent.LOCAL_USER_JOINED.equals(ev.getEventType())) {\r\n        if (!chatRoom.isSystem())\r\n            chatRoom.addMessageListener(this);\r\n    } else {\r\n        chatRoom.removeMessageListener(this);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.whiteboard.gui.whiteboardshapes.WhiteboardShapePolyLine.setFill",
	"Comment": "sets the fill state of the whiteboardobject.true is filled, false is unfilled.",
	"Method": "void setFill(boolean fill){\r\n    this.fill = fill;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.jabber.AbstractSmackInteroperabilityLayer.getInstance",
	"Comment": "get the instance of smack interoperability layer implementation class",
	"Method": "AbstractSmackInteroperabilityLayer getInstance(){\r\n    if (interopLayerInstance == null) {\r\n        try {\r\n            interopLayerInstance = implementationClass.newInstance();\r\n        } catch (IllegalAccessException e) {\r\n            logger.fatal(\"Your AbstractSmackInteroperabilityLayer \" + \"implementation \" + \"cannot be accessed properly. \" + \"Please fix the implementation\");\r\n        } catch (InstantiationException e) {\r\n            logger.fatal(\"Your AbstractSmackInteroperabilityLayer \" + \"implementation \" + \"cannot be instantiated properly. \" + \"Please fix the implementation\");\r\n        }\r\n    }\r\n    return interopLayerInstance;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.utils.Constants.getMessageStatusIcon",
	"Comment": "returns the image corresponding to the given presence status.",
	"Method": "BufferedImage getMessageStatusIcon(PresenceStatus status){\r\n    if (status != null) {\r\n        int connectivity = status.getStatus();\r\n        if (connectivity < PresenceStatus.ONLINE_THRESHOLD) {\r\n            return ImageLoader.getImage(ImageLoader.CHAT_BUTTON_OFFLINE_ICON);\r\n        } else if (connectivity < PresenceStatus.EXTENDED_AWAY_THRESHOLD) {\r\n            return ImageLoader.getImage(ImageLoader.CHAT_BUTTON_DND_ICON);\r\n        } else if (connectivity == PresenceStatus.EXTENDED_AWAY_THRESHOLD) {\r\n            return ImageLoader.getImage(ImageLoader.CHAT_BUTTON_ON_THE_PHONE_ICON);\r\n        } else if (connectivity < PresenceStatus.AWAY_THRESHOLD) {\r\n            return ImageLoader.getImage(ImageLoader.CHAT_BUTTON_EXTENDED_AWAY_ICON);\r\n        } else if (connectivity < PresenceStatus.AVAILABLE_THRESHOLD) {\r\n            return ImageLoader.getImage(ImageLoader.CHAT_BUTTON_AWAY_ICON);\r\n        } else if (connectivity < PresenceStatus.EAGER_TO_COMMUNICATE_THRESHOLD) {\r\n            return ImageLoader.getImage(ImageLoader.CHAT_BUTTON_ONLINE_ICON);\r\n        } else if (connectivity < PresenceStatus.MAX_STATUS_VALUE) {\r\n            return ImageLoader.getImage(ImageLoader.CHAT_BUTTON_FFC_ICON);\r\n        } else {\r\n            return ImageLoader.getImage(ImageLoader.CHAT_BUTTON_OFFLINE_ICON);\r\n        }\r\n    } else {\r\n        return ImageLoader.getImage(ImageLoader.CHAT_BUTTON_SMALL_WHITE);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomJabberImpl.publishConference",
	"Comment": "publishes a conference to the room by sending a presence iqwhich contains a conferencedescriptionpacketextension",
	"Method": "ConferenceDescription publishConference(ConferenceDescription cd,String name){\r\n    if (publishedConference != null) {\r\n        cd = publishedConference;\r\n        cd.setAvailable(false);\r\n    } else {\r\n        String displayName;\r\n        if (name == null) {\r\n            displayName = JabberActivator.getResources().getI18NString(\"service.gui.CHAT_CONFERENCE_ITEM_LABEL\", new String[] { nickname });\r\n        } else {\r\n            displayName = name;\r\n        }\r\n        cd.setDisplayName(displayName);\r\n    }\r\n    ConferenceDescriptionPacketExtension ext = new ConferenceDescriptionPacketExtension(cd);\r\n    if (lastPresenceSent != null) {\r\n        setPacketExtension(lastPresenceSent, ext, ConferenceDescriptionPacketExtension.NAMESPACE);\r\n        provider.getConnection().sendPacket(lastPresenceSent);\r\n    } else {\r\n        logger.warn(\"Could not publish conference,\" + \" lastPresenceSent is null.\");\r\n        publishedConference = null;\r\n        publishedConferenceExt = null;\r\n        return null;\r\n    }\r\n    publishedConference = (cd == null || !cd.isAvailable()) ? null : cd;\r\n    publishedConferenceExt = (publishedConference == null) ? null : ext;\r\n    fireConferencePublishedEvent(members.get(nickname), cd, ChatRoomConferencePublishedEvent.CONFERENCE_DESCRIPTION_SENT);\r\n    return cd;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CustomHeaderList.encode",
	"Comment": "encodes the headers every header on separate line. skip combining ofheaders.",
	"Method": "StringBuilder encode(StringBuilder buffer){\r\n    ListIterator<SIPHeader> li = hlist.listIterator();\r\n    while (li.hasNext()) {\r\n        li.next().encode(buffer);\r\n    }\r\n    return buffer;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl.getAllInstances",
	"Comment": "returns all running instances of protocolproviderservicesipimpl",
	"Method": "Set<ProtocolProviderServiceSipImpl> getAllInstances(){\r\n    try {\r\n        Set<ProtocolProviderServiceSipImpl> instances = new HashSet<ProtocolProviderServiceSipImpl>();\r\n        BundleContext context = SipActivator.getBundleContext();\r\n        Collection<ServiceReference<ProtocolProviderService>> references = context.getServiceReferences(ProtocolProviderService.class, null);\r\n        for (ServiceReference<ProtocolProviderService> ref : references) {\r\n            ProtocolProviderService service = context.getService(ref);\r\n            if (service instanceof ProtocolProviderServiceSipImpl)\r\n                instances.add((ProtocolProviderServiceSipImpl) service);\r\n        }\r\n        return instances;\r\n    } catch (InvalidSyntaxException ex) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Problem parcing an osgi expression\", ex);\r\n        throw new RuntimeException(\"getServiceReferences() wasn't supposed to fail!\");\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomIrcImpl.isSystem",
	"Comment": "indicates whether or not this chat room is corresponding to a serverchannel.",
	"Method": "boolean isSystem(){\r\n    return isSystem;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.Call.equals",
	"Comment": "compares the specified object with this call and returns true if it thespecified object is an instance of a call object and if theextending telephony protocol considers the calls represented by bothobjects to be the same.",
	"Method": "boolean equals(Object obj){\r\n    if ((obj == null) || !(obj instanceof Call))\r\n        return false;\r\n    return (obj == this) || ((Call) obj).getCallID().equals(getCallID());\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.phonenumbercontactsource.PhoneNumberSourceContact.getDisplayDetails",
	"Comment": "returns the display details of this search contact. this could be anyimportant information that should be shown to the user.",
	"Method": "String getDisplayDetails(){\r\n    return displayDetails;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl.processNotify",
	"Comment": "processes a specific request.notify request for the purposes oftelephony.",
	"Method": "boolean processNotify(ServerTransaction serverTransaction,Request notifyRequest){\r\n    EventHeader eventHeader = (EventHeader) notifyRequest.getHeader(EventHeader.NAME);\r\n    if ((eventHeader == null) || !\"refer\".equals(eventHeader.getEventType())) {\r\n        return false;\r\n    }\r\n    SubscriptionStateHeader ssHeader = (SubscriptionStateHeader) notifyRequest.getHeader(SubscriptionStateHeader.NAME);\r\n    if (ssHeader == null) {\r\n        logger.error(\"NOTIFY of refer event type\" + \"with no Subscription-State header.\");\r\n        return false;\r\n    }\r\n    Dialog dialog = serverTransaction.getDialog();\r\n    CallPeerSipImpl peer = activeCallsRepository.findCallPeer(dialog);\r\n    if (peer == null) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Received a stray refer NOTIFY request.\");\r\n        return false;\r\n    }\r\n    Response ok;\r\n    try {\r\n        ok = messageFactory.createResponse(Response.OK, notifyRequest);\r\n        serverTransaction.sendResponse(ok);\r\n    } catch (ParseException ex) {\r\n        String message = \"Failed to create OK response to refer NOTIFY.\";\r\n        logger.error(message, ex);\r\n        peer.setState(CallPeerState.DISCONNECTED, message);\r\n        return false;\r\n    } catch (Exception ex) {\r\n        String message = \"Failed to send OK response to refer NOTIFY request.\";\r\n        logger.error(message, ex);\r\n        peer.setState(CallPeerState.DISCONNECTED, message);\r\n        return false;\r\n    }\r\n    if (SubscriptionStateHeader.TERMINATED.equalsIgnoreCase(ssHeader.getState()) && !EventPackageUtils.removeSubscriptionThenIsDialogAlive(dialog, \"refer\")) {\r\n        peer.setState(CallPeerState.DISCONNECTED);\r\n    }\r\n    if (!CallPeerState.DISCONNECTED.equals(peer.getState()) && !EventPackageUtils.isByeProcessed(dialog)) {\r\n        try {\r\n            peer.hangup();\r\n        } catch (OperationFailedException ex) {\r\n            logger.error(\"Failed to send BYE in response to refer NOTIFY \" + \"request.\", ex);\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ChatRoomConfigurationWindow.setVisible",
	"Comment": "overwrites the setvisible method in order to set theposition of this window before showing it.",
	"Method": "void setVisible(boolean isVisible){\r\n    if (isVisible)\r\n        setLocationRelativeTo(null);\r\n    super.setVisible(isVisible);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.CallPeerMediaHandlerJabberImpl.processColibriConferenceIQ",
	"Comment": "notifies this instance that a specific colibriconferenceiq hasbeen received. this callpeermediahandler uses the part of theinformation provided in the specified conferenceiq whichconcerns it only.",
	"Method": "void processColibriConferenceIQ(ColibriConferenceIQ conferenceIQ){\r\n    TransportManagerJabberImpl transportManager = this.transportManager;\r\n    if (transportManager != null) {\r\n        long oldAudioRemoteSSRC = getRemoteSSRC(MediaType.AUDIO);\r\n        long oldVideoRemoteSSRC = getRemoteSSRC(MediaType.VIDEO);\r\n        for (MediaType mediaType : MediaType.values()) {\r\n            ColibriConferenceIQ.Channel dst = transportManager.getColibriChannel(mediaType, false);\r\n            if (dst != null) {\r\n                ColibriConferenceIQ.Content content = conferenceIQ.getContent(mediaType.toString());\r\n                if (content != null) {\r\n                    ColibriConferenceIQ.Channel src = content.getChannel(dst.getID());\r\n                    if (src != null) {\r\n                        int[] ssrcs = src.getSSRCs();\r\n                        int[] dstSSRCs = dst.getSSRCs();\r\n                        if (!Arrays.equals(dstSSRCs, ssrcs))\r\n                            dst.setSSRCs(ssrcs);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        long newAudioRemoteSSRC = getRemoteSSRC(MediaType.AUDIO);\r\n        long newVideoRemoteSSRC = getRemoteSSRC(MediaType.VIDEO);\r\n        if (oldAudioRemoteSSRC != newAudioRemoteSSRC) {\r\n            firePropertyChange(AUDIO_REMOTE_SSRC, oldAudioRemoteSSRC, newAudioRemoteSSRC);\r\n        }\r\n        if (oldVideoRemoteSSRC != newVideoRemoteSSRC) {\r\n            firePropertyChange(VIDEO_REMOTE_SSRC, oldVideoRemoteSSRC, newVideoRemoteSSRC);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ContactJabberImpl.getImage",
	"Comment": "returns a reference to the image assigned to this contact. if no imageis present and the retrieveifnecessary flag is true, we schedule theimage for retrieval from the server.",
	"Method": "byte[] getImage(byte[] getImage,boolean retrieveIfNecessary){\r\n    if (image == null && retrieveIfNecessary)\r\n        ssclCallback.addContactForImageUpdate(this);\r\n    return image;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.keybindingchooser.chooser.BindingAdaptor.setBindingsDisableable",
	"Comment": "sets if bindings can be disabled via generated key adaptors with thedisabling key code. by default this is false.",
	"Method": "void setBindingsDisableable(boolean enable){\r\n    this.isDisablingEnabled = enable;\r\n}"
}, {
	"Path": "com.github.ltsopensource.core.support.CronExpression.setCalendarHour",
	"Comment": "advance the calendar to the particular hour paying particular attentionto daylight saving problems.",
	"Method": "void setCalendarHour(Calendar cal,int hour){\r\n    cal.set(java.util.Calendar.HOUR_OF_DAY, hour);\r\n    if (cal.get(java.util.Calendar.HOUR_OF_DAY) != hour && hour != 24) {\r\n        cal.set(java.util.Calendar.HOUR_OF_DAY, hour + 1);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetMultiUserChatJabberImpl.cacheChatRoom",
	"Comment": "adds chatroom to the cache of chat rooms that this operationset is handling.",
	"Method": "void cacheChatRoom(ChatRoom chatRoom){\r\n    this.chatRoomCache.put(chatRoom.getName(), chatRoom);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.GibberishActivator.getProtocolProviderFactory",
	"Comment": "retrurns a reference to the protocol provider factory that we haveregistered.",
	"Method": "ProtocolProviderFactoryGibberishImpl getProtocolProviderFactory(){\r\n    return gibberishProviderFactory;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaAwareCallConference.getRTPTranslator",
	"Comment": "gets the rtptranslator which forwards rtp and rtcp trafficbetween the callpeers of the calls participating inthis telephony conference when the local peer is acting as a conferencefocus.",
	"Method": "RTPTranslator getRTPTranslator(MediaType mediaType){\r\n    if (MediaType.VIDEO.equals(mediaType) && (!OSUtils.IS_ANDROID || isConferenceFocus())) {\r\n        if (videoRTPTranslator == null) {\r\n            videoRTPTranslator = ProtocolMediaActivator.getMediaService().createRTPTranslator();\r\n        }\r\n        return videoRTPTranslator;\r\n    }\r\n    if (this.translator) {\r\n        if (audioRTPTranslator == null) {\r\n            audioRTPTranslator = ProtocolMediaActivator.getMediaService().createRTPTranslator();\r\n        }\r\n        return audioRTPTranslator;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.DesktopUtilActivator.getMediaService",
	"Comment": "returns an instance of the mediaservice obtained from thebundle context.",
	"Method": "MediaService getMediaService(){\r\n    if (mediaService == null) {\r\n        mediaService = ServiceUtils.getService(bundleContext, MediaService.class);\r\n    }\r\n    return mediaService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.whiteboard.WhiteboardSessionManager.whiteboardObjecModified",
	"Comment": "called when a modified whiteboardobject has been received.",
	"Method": "void whiteboardObjecModified(WhiteboardObjectModifiedEvent evt){\r\n    WhiteboardFrame wbf = getWhiteboardFrame(evt.getSourceWhiteboardSession());\r\n    if (wbf == null)\r\n        return;\r\n    wbf.setVisible(true);\r\n    WhiteboardObject wbo = evt.getSourceWhiteboardObject();\r\n    wbf.receiveWhiteboardObject(wbo);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.account.AccountRegWizardContainerImpl.modifyAccount",
	"Comment": "opens the corresponding wizard to modify an existing account given by theprotocolprovider parameter.",
	"Method": "void modifyAccount(ProtocolProviderService protocolProvider){\r\n    AccountRegistrationWizard wizard = getProtocolWizard(protocolProvider);\r\n    this.setCurrentWizard(wizard);\r\n    wizard.setModification(true);\r\n    this.summaryPage.setModification(protocolProvider);\r\n    if (protocolProvider != null && protocolProvider.getAccountID().isReadOnly()) {\r\n        setDisabled(cardPanel.getComponents());\r\n    }\r\n    wizard.loadAccount(protocolProvider);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.thumbnail.ThumbnailElement.addXmlAttribute",
	"Comment": "creates the xml string corresponding to the specified attributeand value and adds them to the buff stringbuffer.",
	"Method": "StringBuffer addXmlAttribute(StringBuffer buff,String attrName,String attrValue){\r\n    buff.append(\" \" + attrName + \"=\\\"\").append(attrValue).append(\"\\\"\");\r\n    return buff;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.CryptoPacketExtension.equalsSessionParams",
	"Comment": "returns if the current session params equals the one given in parameter.",
	"Method": "boolean equalsSessionParams(String sessionParams){\r\n    String currentSessionParams = this.getSessionParams();\r\n    return CryptoPacketExtension.equalsStrings(currentSessionParams, sessionParams);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.AbstractPacketExtension.getAttributeAsURI",
	"Comment": "tries to parse the value of the specified attribute as anuri and returns it.",
	"Method": "URI getAttributeAsURI(String attribute){\r\n    synchronized (attributes) {\r\n        String attributeVal = getAttributeAsString(attribute);\r\n        if (attributeVal == null)\r\n            return null;\r\n        try {\r\n            URI uri = new URI(attributeVal);\r\n            return uri;\r\n        } catch (URISyntaxException e) {\r\n            throw new IllegalArgumentException(e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.conference.BasicConferenceParticipantPanel.enableVideoIndicator",
	"Comment": "enables or disabled video indicator in this conference participantpanel.",
	"Method": "void enableVideoIndicator(boolean enable){\r\n    isVideoIndicatorEnabled = enable;\r\n    setParticipantIcon(null, true);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.QualityControlWrapper.setPreferredRemoteSendMaxPreset",
	"Comment": "changes the current video settings for the peer with the desiredquality settings and inform the peer to stream the videowith those settings.",
	"Method": "void setPreferredRemoteSendMaxPreset(QualityPreset preset){\r\n    QualityControl qControls = getMediaQualityControl();\r\n    if (qControls != null) {\r\n        qControls.setRemoteSendMaxPreset(preset);\r\n        peer.sendModifyVideoResolutionContent();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl.getRegistrationState",
	"Comment": "returns the state of the registration of this protocol provider with thecorresponding registration service.",
	"Method": "RegistrationState getRegistrationState(){\r\n    if (this.sipRegistrarConnection == null) {\r\n        return RegistrationState.UNREGISTERED;\r\n    }\r\n    return sipRegistrarConnection.getRegistrationState();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractOperationSetPersistentPresence.getLocalContact",
	"Comment": "returns the protocol specific contact instance representing the localuser or null if it is not supported.",
	"Method": "Contact getLocalContact(){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.DesktopSharingFrame.addCallListener",
	"Comment": "adds a call listener, which listens for call ended events and wouldclose any related desktop sharing frames when a call is ended.",
	"Method": "void addCallListener(Call call,JFrame frame){\r\n    OperationSetBasicTelephony<?> basicTelephony = call.getProtocolProvider().getOperationSet(OperationSetBasicTelephony.class);\r\n    if (basicTelephony != null) {\r\n        basicTelephony.addCallListener(new CallListener() {\r\n            public void callEnded(CallEvent ev) {\r\n                Call call = ev.getSourceCall();\r\n                JFrame desktopFrame = callDesktopFrames.get(call);\r\n                if (desktopFrame != null) {\r\n                    desktopFrame.dispose();\r\n                    callDesktopFrames.remove(call);\r\n                }\r\n            }\r\n            public void incomingCallReceived(CallEvent ev) {\r\n            }\r\n            public void outgoingCallCreated(CallEvent ev) {\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.DesktopSharingFrame.addCallListener",
	"Comment": "adds a call listener, which listens for call ended events and wouldclose any related desktop sharing frames when a call is ended.",
	"Method": "void addCallListener(Call call,JFrame frame){\r\n    Call call = ev.getSourceCall();\r\n    JFrame desktopFrame = callDesktopFrames.get(call);\r\n    if (desktopFrame != null) {\r\n        desktopFrame.dispose();\r\n        callDesktopFrames.remove(call);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.DesktopSharingFrame.addCallListener",
	"Comment": "adds a call listener, which listens for call ended events and wouldclose any related desktop sharing frames when a call is ended.",
	"Method": "void addCallListener(Call call,JFrame frame){\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.DesktopSharingFrame.addCallListener",
	"Comment": "adds a call listener, which listens for call ended events and wouldclose any related desktop sharing frames when a call is ended.",
	"Method": "void addCallListener(Call call,JFrame frame){\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactGroupImpl.isPersistent",
	"Comment": "determines whether or not this meta group contains only groups that arebeing stored by a server.",
	"Method": "boolean isPersistent(){\r\n    Iterator<ContactGroup> contactGroupsIter = getContactGroups();\r\n    while (contactGroupsIter.hasNext()) {\r\n        ContactGroup contactGroup = contactGroupsIter.next();\r\n        if (contactGroup.isPersistent())\r\n            return true;\r\n    }\r\n    if (countContactGroups() == 0)\r\n        return true;\r\n    else\r\n        return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.macosx.MacOSXAddrBookContactQuery.onPerson",
	"Comment": "notifies this macosxaddrbookcontactquery about a specificabperson.",
	"Method": "boolean onPerson(long person){\r\n    Object[] values = ABRecord_valuesForProperties(person, ABPERSON_PROPERTIES);\r\n    final String id = ABRecord_uniqueId(person);\r\n    String displayName = getDisplayName(values);\r\n    if ((displayName.length() != 0) && (query.matcher(displayName).find() || matches(values))) {\r\n        List<ContactDetail> contactDetails = getContactDetails(values, id);\r\n        if (!contactDetails.isEmpty()) {\r\n            final MacOSXAddrBookSourceContact sourceContact = new MacOSXAddrBookSourceContact(getContactSource(), displayName, contactDetails);\r\n            sourceContact.setData(SourceContact.DATA_ID, id);\r\n            sourceContact.setDisplayDetails(getOrganization(values));\r\n            try {\r\n                byte[] image = ABPerson_imageData(person);\r\n                if (image != null)\r\n                    sourceContact.setImage(image);\r\n            } catch (OutOfMemoryError oome) {\r\n            }\r\n            addQueryResult(sourceContact);\r\n        }\r\n    }\r\n    return (getStatus() == QUERY_IN_PROGRESS);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.MessageReceivedEvent.isPrivateMessaging",
	"Comment": "returns true if this is private messaging event and false if not.",
	"Method": "boolean isPrivateMessaging(){\r\n    return isPrivateMessaging;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.UriHandlerSipImpl.showErrorMessage",
	"Comment": "uses the uiservice to show an error message and log andexception.",
	"Method": "void showErrorMessage(String message,Exception exc){\r\n    SipActivator.getUIService().getPopupDialog().showMessagePopupDialog(message, \"Failed to create call!\", PopupDialog.ERROR_MESSAGE);\r\n    logger.error(message, exc);\r\n}"
}, {
	"Path": "io.lettuce.core.support.LettuceFactoryBeanSupport.setPassword",
	"Comment": "sets the password to use for a redis connection. if the password is set, it has higher precedence than the passwordprovided within the uri meaning the password from the uri is replaced by this one.",
	"Method": "void setPassword(String password){\r\n    if (password == null) {\r\n        this.password = new char[0];\r\n    } else {\r\n        this.password = password.toCharArray();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.RootContactGroupIcqImpl.canContainSubgroups",
	"Comment": "the contactlistroot in icq is the only group that can contain subgroups.",
	"Method": "boolean canContainSubgroups(){\r\n    return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.TestOperationSetBasicInstantMessaging.testSendFunMessages",
	"Comment": "a method that would simply send messages to a group of people so thatthey would get notified that tests are being run.",
	"Method": "void testSendFunMessages(){\r\n    String hostname = \"\";\r\n    try {\r\n        hostname = java.net.InetAddress.getLocalHost().getHostName() + \": \";\r\n    } catch (UnknownHostException ex) {\r\n    }\r\n    String message = hostname + \"Hello this is the SIP Communicator (version \" + System.getProperty(\"sip-communicator.version\") + \") build on: \" + new Date().toString() + \". Have a very nice day!\";\r\n    String list = System.getProperty(\"accounts.reporting.ICQ_REPORT_LIST\");\r\n    logger.debug(\"Will send message \" + message + \" to: \" + list);\r\n    if (list == null || list.trim().length() == 0)\r\n        return;\r\n    StringTokenizer tokenizer = new StringTokenizer(list, \" \");\r\n    while (tokenizer.hasMoreTokens()) {\r\n        IcqSlickFixture.testerAgent.sendMessage(tokenizer.nextToken(), message);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.MainFrame.getTelephonyOpSet",
	"Comment": "returns the telephony operation set for the given protocol provider.",
	"Method": "OperationSetBasicTelephony<?> getTelephonyOpSet(ProtocolProviderService protocolProvider){\r\n    OperationSet opSet = protocolProvider.getOperationSet(OperationSetBasicTelephony.class);\r\n    return (opSet instanceof OperationSetBasicTelephony<?>) ? (OperationSetBasicTelephony<?>) opSet : null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.swingnotification.NonePopupMessageHandlerImpl.getPreferenceIndex",
	"Comment": "implements getpreferenceindex fromnonepopupmessagehandlerimpl.this handler is a empty one, thus the preference index is 0.",
	"Method": "int getPreferenceIndex(){\r\n    return 0;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.GuiActivator.getNotificationService",
	"Comment": "returns the notificationservice obtained from the bundle context.",
	"Method": "NotificationService getNotificationService(){\r\n    if (notificationService == null) {\r\n        notificationService = ServiceUtils.getService(bundleContext, NotificationService.class);\r\n    }\r\n    return notificationService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.ExternalContactSource.initCustomContactActionMenuItems",
	"Comment": "initializes custom action menu items for this contact source.",
	"Method": "void initCustomContactActionMenuItems(){\r\n    customContactActionMenuItems = new LinkedHashMap<ContactActionMenuItem<SourceContact>, JMenuItem>();\r\n    for (CustomContactActionsService<SourceContact> ccas : getContactActionsServices()) {\r\n        Iterator<ContactActionMenuItem<SourceContact>> actionIterator = ccas.getCustomContactActionsMenuItems();\r\n        if (actionIterator != null) {\r\n            while (actionIterator.hasNext()) {\r\n                final ContactActionMenuItem<SourceContact> ca = actionIterator.next();\r\n                initActionMenuItem(ca);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.CallGibberishImpl.removeCallPeer",
	"Comment": "removes callpeer from the list of peers in thiscall. the method has no effect if there was no such peer in thecall.",
	"Method": "void removeCallPeer(CallPeerGibberishImpl callPeer){\r\n    if (!doRemoveCallPeer(callPeer))\r\n        return;\r\n    callPeer.removeCallPeerListener(this);\r\n    fireCallPeerEvent(callPeer, CallPeerEvent.CALL_PEER_REMOVED);\r\n    if (getCallPeerCount() == 0)\r\n        setCallState(CallState.CALL_ENDED);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.configuration.TestConfigurationService.testRemovePrefixedProperty",
	"Comment": "tests whether removing and getting properties works correctly.",
	"Method": "void testRemovePrefixedProperty(){\r\n    String propertyName = \"my.test.property.acc1234\";\r\n    String propertyPrefixName = \"my.test.property.acc\";\r\n    Object property = new String(\"my.test.property's value\");\r\n    configurationService.setProperty(propertyName, property);\r\n    Object actualReturn = configurationService.getProperty(propertyName);\r\n    assertEquals(\"a property was not properly stored\", property, actualReturn);\r\n    configurationService.removeProperty(propertyPrefixName);\r\n    Object actualReturn2 = configurationService.getProperty(propertyName);\r\n    assertNull(\"a property was not properly removed by prefix\", actualReturn2);\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.GuiUtils.escapeFileNameSpecialCharacters",
	"Comment": "replaces the characters that we must escape used for the createdfilename.",
	"Method": "String escapeFileNameSpecialCharacters(String string){\r\n    String resultId = string;\r\n    for (int j = 0; j < ESCAPE_SEQUENCES.length; j++) {\r\n        resultId = resultId.replaceAll(ESCAPE_SEQUENCES[j][0], ESCAPE_SEQUENCES[j][1]);\r\n    }\r\n    return resultId;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.UnknownContactPanel.updateTextArea",
	"Comment": "updates the text area to take into account the new search text.",
	"Method": "void updateTextArea(String searchText){\r\n    if (callButton.getParent() != null) {\r\n        textArea.setText(GuiActivator.getResources().getI18NString(\"service.gui.NO_CONTACTS_FOUND\", new String[] { '\"' + searchText + '\"' }));\r\n        this.revalidate();\r\n        this.repaint();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.IcqTesterAgent.addTypingStateInfoListenerForBuddy",
	"Comment": "adds a typing listener that would receive joust sim based on typingnotifications received from buddy",
	"Method": "void addTypingStateInfoListenerForBuddy(String buddy,ConversationListener l){\r\n    if (!(l instanceof TypingListener))\r\n        throw new ClassCastException(\"In order to receive typing notifications a typing listener \" + \"needs to also implement \" + TypingListener.class.getName());\r\n    conn.getIcbmService().getImConversation(new Screenname(buddy)).addConversationListener(l);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapFactoryImpl.createSearchSettings",
	"Comment": "returns an ldapsearchsettings, to use when performing a search",
	"Method": "LdapSearchSettings createSearchSettings(){\r\n    return new LdapSearchSettingsImpl();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.whiteboard.gui.whiteboardshapes.WhiteboardShapeRect.recalculateSelectionPoints",
	"Comment": "recalculates the selection points coordinates and adds the new selectionpoints to the list of selection points.",
	"Method": "void recalculateSelectionPoints(){\r\n    selectionPoints.clear();\r\n    selectionPoints.add(new WhiteboardPoint(point.getX(), point.getY()));\r\n    selectionPoints.add(new WhiteboardPoint(point.getX() + width, point.getY()));\r\n    selectionPoints.add(new WhiteboardPoint(point.getX(), point.getY() + height));\r\n    selectionPoints.add(new WhiteboardPoint(point.getX() + width, point.getY() + height));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.notifsource.NotificationContact.getDisplayDetails",
	"Comment": "returns the display details of this contact. these would be shownwhenever the contact is selected. in the notificationcontactthese contain information about unread and read messages.",
	"Method": "String getDisplayDetails(){\r\n    String displayDetails;\r\n    if (notificationMessage != null) {\r\n        return notificationMessage.getMessageDetails();\r\n    }\r\n    ResourceManagementService resources = GuiActivator.getResources();\r\n    if ((unreadUrgentMessageCount > 0) && (unreadMessageCount > 0) && (readMessageCount > 0)) {\r\n        displayDetails = resources.getI18NString(\"service.gui.VOICEMAIL_NEW_URGENT_OLD_RECEIVED\", new String[] { Integer.toString(unreadMessageCount), Integer.toString(unreadUrgentMessageCount), Integer.toString(readMessageCount) });\r\n    } else if ((unreadMessageCount > 0) && (readMessageCount > 0)) {\r\n        displayDetails = resources.getI18NString(\"service.gui.VOICEMAIL_NEW_OLD_RECEIVED\", new String[] { Integer.toString(unreadMessageCount), Integer.toString(readMessageCount) });\r\n    } else if ((unreadUrgentMessageCount > 0) && (unreadMessageCount > 0)) {\r\n        displayDetails = resources.getI18NString(\"service.gui.VOICEMAIL_NEW_URGENT_RECEIVED\", new String[] { Integer.toString(unreadMessageCount), Integer.toString(unreadUrgentMessageCount) });\r\n    } else if (unreadMessageCount > 0) {\r\n        displayDetails = resources.getI18NString(\"service.gui.VOICEMAIL_NEW_RECEIVED\", new String[] { Integer.toString(unreadMessageCount) });\r\n    } else if (readMessageCount > 0) {\r\n        displayDetails = resources.getI18NString(\"service.gui.VOICEMAIL_OLD_RECEIVED\", new String[] { Integer.toString(readMessageCount) });\r\n    } else {\r\n        displayDetails = resources.getI18NString(\"service.gui.VOICEMAIL_NO_MESSAGES\");\r\n    }\r\n    return displayDetails;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.ConnectionPanel.getClientTlsCertificateId",
	"Comment": "gets the id of the selected client tls certificate or null if nocertificate is selected.",
	"Method": "String getClientTlsCertificateId(){\r\n    if (certificate.getSelectedItem() != null && certificate.getSelectedItem() instanceof CertificateConfigEntry)\r\n        return ((CertificateConfigEntry) certificate.getSelectedItem()).getId();\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.GenericUIContactImpl.getDisplayDetails",
	"Comment": "returns the display details of this contact. these would be shownwhenever the contact is selected.",
	"Method": "String getDisplayDetails(){\r\n    return displayDetails;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.AdHocChatRoomParticipantPresenceChangeEvent.getReason",
	"Comment": "a reason string indicating a human readable reason for this event.",
	"Method": "String getReason(){\r\n    return this.reason;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetPersistentPresenceIcqImpl.createUnresolvedContact",
	"Comment": "creates and returns a unresolved contact from the specifiedaddress and persistentdata. the method will not tryto establish a network connection and resolve the newly created contactagainst the server. the protocol provider may will later try and resolvethe contact. when this happens the corresponding event would notifyinterested subscription listeners.",
	"Method": "Contact createUnresolvedContact(String address,String persistentData,ContactGroup parentGroup,Contact createUnresolvedContact,String address,String persistentData){\r\n    return createUnresolvedContact(address, persistentData, getServerStoredContactListRoot());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ContactJabberImpl.fireContactResourceEvent",
	"Comment": "notifies all registered contactresourcelisteners that an eventhas occurred.",
	"Method": "void fireContactResourceEvent(ContactResourceEvent event){\r\n    super.fireContactResourceEvent(event);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.lookandfeel.SIPCommButtonUI.installDefaults",
	"Comment": "installs default configurations for the given abstractbutton.",
	"Method": "void installDefaults(AbstractButton b){\r\n    super.installDefaults(b);\r\n    b.setOpaque(false);\r\n    b.setBorderPainted(false);\r\n    b.setFocusPainted(true);\r\n    b.setRolloverEnabled(true);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.mailnotification.MailboxIQ.getUrl",
	"Comment": "returns the http url of the mail server containing the messages thatthis iq refers to.",
	"Method": "String getUrl(){\r\n    return url;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockChatRoomMember.getContact",
	"Comment": "returns the protocol contact corresponding to this member in our contactlist.",
	"Method": "Contact getContact(){\r\n    return contact;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.ComponentUtils.getComponentIndex",
	"Comment": "returns the index of the given component in the given container.",
	"Method": "int getComponentIndex(Component c,Container container){\r\n    for (int i = 0, count = container.getComponentCount(); i < count; i++) {\r\n        if (container.getComponent(i).equals(c))\r\n            return i;\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.history.SearchPanel.removeUpdate",
	"Comment": "when all text is removed from the search field shows the whole history.",
	"Method": "void removeUpdate(DocumentEvent e){\r\n    if (searchTextField.getText() == null || searchTextField.getText().equals(\"\")) {\r\n        historyWindow.showHistoryByKeyword(\"\");\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockContact.getProtocolProvider",
	"Comment": "returns a reference to the protocol provider that created the contact.",
	"Method": "ProtocolProviderService getProtocolProvider(){\r\n    return parentProvider;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipActivator.getBundleContext",
	"Comment": "returns a reference to the bundle context that we were started with.",
	"Method": "BundleContext getBundleContext(){\r\n    return bundleContext;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractOperationSetBasicInstantMessaging.sendInstantMessage",
	"Comment": "sends the message to the destination indicated by theto. provides a default implementation of this method.",
	"Method": "void sendInstantMessage(Contact to,ContactResource toResource,Message message){\r\n    sendInstantMessage(to, message);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.TestOperationSetMultiUserChat.testCreateChatRoom",
	"Comment": "creates a chat room and verifies that it has been properly created.",
	"Method": "void testCreateChatRoom(){\r\n    ChatRoom testChatRoom = opSetMultiChat1.createChatRoom(fixture.chatRoomName, null);\r\n    assertNotNull(\"createChatRoom() returned null\", testChatRoom);\r\n    assertEquals(\"The name of the chat room that was \" + \"created did not match the name that we wanted to have\", fixture.chatRoomName, testChatRoom.getName());\r\n    assertSame(\"The newly created chat room did not had a properly set provider.\", fixture.provider1, testChatRoom.getParentProvider());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ContactSipImpl.getDisplayName",
	"Comment": "returns a string that could be used by any user interacting modulesfor referring to this contact.",
	"Method": "String getDisplayName(){\r\n    if (this.entry.getDisplayName() != null) {\r\n        return this.entry.getDisplayName().getValue();\r\n    }\r\n    SipURI sipURI = (SipURI) sipAddress.getURI();\r\n    String sipUserName = sipURI.getUser();\r\n    if (sipUserName != null && sipUserName.length() > 0)\r\n        return sipUserName;\r\n    if (getAddress().startsWith(\"sip:\"))\r\n        return getAddress().substring(4);\r\n    return getAddress();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.loadNextPageFromHistory",
	"Comment": "implements chatpanel.loadnextfromhistory.loads next page from history.",
	"Method": "void loadNextPageFromHistory(){\r\n    final MetaHistoryService chatHistory = GuiActivator.getMetaHistoryService();\r\n    if (chatHistory == null)\r\n        return;\r\n    SwingWorker worker = new SwingWorker() {\r\n        @Override\r\n        public Object construct() throws Exception {\r\n            Date lastMsgDate = getChatConversationPanel().getPageLastMsgTimestamp();\r\n            Collection<Object> c = null;\r\n            if (lastMsgDate != null) {\r\n                c = chatSession.getHistoryAfterDate(lastMsgDate, MESSAGES_PER_PAGE);\r\n            }\r\n            if (c != null && c.size() > 0)\r\n                SwingUtilities.invokeLater(new HistoryMessagesLoader(c));\r\n            return \"\";\r\n        }\r\n        @Override\r\n        public void finished() {\r\n            getChatContainer().updateHistoryButtonState(ChatPanel.this);\r\n        }\r\n    };\r\n    worker.start();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.loadNextPageFromHistory",
	"Comment": "implements chatpanel.loadnextfromhistory.loads next page from history.",
	"Method": "void loadNextPageFromHistory(){\r\n    Date lastMsgDate = getChatConversationPanel().getPageLastMsgTimestamp();\r\n    Collection<Object> c = null;\r\n    if (lastMsgDate != null) {\r\n        c = chatSession.getHistoryAfterDate(lastMsgDate, MESSAGES_PER_PAGE);\r\n    }\r\n    if (c != null && c.size() > 0)\r\n        SwingUtilities.invokeLater(new HistoryMessagesLoader(c));\r\n    return \"\";\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.loadNextPageFromHistory",
	"Comment": "implements chatpanel.loadnextfromhistory.loads next page from history.",
	"Method": "void loadNextPageFromHistory(){\r\n    getChatContainer().updateHistoryButtonState(ChatPanel.this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.addChatFocusListener",
	"Comment": "implements chat.addchatfocuslistener method. adds the givenchatfocuslistener to the list of listeners.",
	"Method": "void addChatFocusListener(ChatFocusListener listener){\r\n    synchronized (focusListeners) {\r\n        if (!focusListeners.contains(listener))\r\n            focusListeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipActivator.getMediaService",
	"Comment": "returns a reference to a mediaservice implementation currently registeredin the bundle context or null if no such implementation was found.",
	"Method": "MediaService getMediaService(){\r\n    if (mediaService == null) {\r\n        ServiceReference mediaServiceReference = bundleContext.getServiceReference(MediaService.class.getName());\r\n        mediaService = (MediaService) bundleContext.getService(mediaServiceReference);\r\n    }\r\n    return mediaService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.ImageUtils.getScaledRoundedIcon",
	"Comment": "returns a scaled rounded icon from the given image, scaledwithin the given width and height.",
	"Method": "ImageIcon getScaledRoundedIcon(Image image,int width,int height,ImageIcon getScaledRoundedIcon,byte[] imageBytes,int width,int height){\r\n    return getScaledIcon(imageBytes, Shape.ROUNDED_RECTANGLE, width, height);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AccountInfoUtils.getDisplayName",
	"Comment": "returns the display name of the account, to which the givenaccountinfoopset belongs.",
	"Method": "String getDisplayName(OperationSetServerStoredAccountInfo accountInfoOpSet){\r\n    DisplayNameDetail displayName = null;\r\n    Iterator<GenericDetail> displayNameDetails = accountInfoOpSet.getDetails(DisplayNameDetail.class);\r\n    if (displayNameDetails.hasNext())\r\n        displayName = (DisplayNameDetail) displayNameDetails.next();\r\n    if (displayName == null)\r\n        return null;\r\n    return displayName.getString();\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.generic.AdHocMultiUserChatSlickFixture.deleteGroups",
	"Comment": "delete all groups and contacts for the given persistent presence op. set.",
	"Method": "void deleteGroups(OperationSetPersistentPresence opSetPersPresence){\r\n    ContactGroup rootGroup = opSetPersPresence.getServerStoredContactListRoot();\r\n    Vector<ContactGroup> groupsToRemove = new Vector<ContactGroup>();\r\n    Iterator<ContactGroup> iter = rootGroup.subgroups();\r\n    while (iter.hasNext()) {\r\n        groupsToRemove.add(iter.next());\r\n    }\r\n    iter = groupsToRemove.iterator();\r\n    while (iter.hasNext()) {\r\n        ContactGroup item = iter.next();\r\n        opSetPersPresence.removeServerStoredContactGroup(item);\r\n    }\r\n    Vector<Contact> contactsToRemove = new Vector<Contact>();\r\n    Iterator<Contact> iter2 = rootGroup.contacts();\r\n    while (iter2.hasNext()) {\r\n        contactsToRemove.add(iter2.next());\r\n    }\r\n    iter2 = contactsToRemove.iterator();\r\n    while (iter2.hasNext()) {\r\n        opSetPersPresence.unsubscribe(iter2.next());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetContactCapabilitiesJabberImpl.getSupportedOperationSets",
	"Comment": "gets the operationsets supported by a specific contact.the returned operationsets are considered by the associatedprotocol provider to capabilities possessed by the specifiedcontact.",
	"Method": "Map<String, OperationSet> getSupportedOperationSets(Contact contact,boolean online,Map<String, OperationSet> getSupportedOperationSets,String jid,boolean online){\r\n    Map<String, OperationSet> supportedOperationSets = parentProvider.getSupportedOperationSets();\r\n    int supportedOperationSetCount = supportedOperationSets.size();\r\n    Map<String, OperationSet> contactSupportedOperationSets = new HashMap<String, OperationSet>(supportedOperationSetCount);\r\n    if (supportedOperationSetCount != 0) {\r\n        for (Map.Entry<String, OperationSet> supportedOperationSetEntry : supportedOperationSets.entrySet()) {\r\n            String opsetClassName = supportedOperationSetEntry.getKey();\r\n            Class<? extends OperationSet> opsetClass;\r\n            try {\r\n                opsetClass = (Class<? extends OperationSet>) Class.forName(opsetClassName);\r\n            } catch (ClassNotFoundException cnfex) {\r\n                opsetClass = null;\r\n                logger.error(\"Failed to get OperationSet class for name: \" + opsetClassName, cnfex);\r\n            }\r\n            if (opsetClass != null) {\r\n                OperationSet opset = getOperationSet(jid, opsetClass, online);\r\n                if (opset != null) {\r\n                    contactSupportedOperationSets.put(opsetClassName, opset);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return contactSupportedOperationSets;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.MessageWaitingEvent.getSourceProvider",
	"Comment": "returns the protocolproviderservice which originated this event.",
	"Method": "ProtocolProviderService getSourceProvider(){\r\n    return (ProtocolProviderService) getSource();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.utils.InviteContactTransferHandler.setBackupProvider",
	"Comment": "the backup provider to use if no provider has been specified.",
	"Method": "void setBackupProvider(ProtocolProviderService backupProvider){\r\n    this.backupProvider = backupProvider;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.ReceivedCallDialog.updateTextDisplayName",
	"Comment": "uses a table mapping peer to name to update call label display name.",
	"Method": "void updateTextDisplayName(Hashtable<CallPeer, String> peerNamesTable){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                updateTextDisplayName(peerNamesTable);\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    boolean hasMorePeers = false;\r\n    String textDisplayName = \"\";\r\n    Iterator<? extends CallPeer> peersIter = incomingCall.getCallPeers();\r\n    JLabel label = getCallLabels()[1];\r\n    while (peersIter.hasNext()) {\r\n        final CallPeer peer = peersIter.next();\r\n        if (peersIter.hasNext()) {\r\n            textDisplayName = label.getText() + peerNamesTable.get(peer) + \", \";\r\n            hasMorePeers = true;\r\n        } else {\r\n            textDisplayName = GuiActivator.getResources().getI18NString(\"service.gui.IS_CALLING\", new String[] { peerNamesTable.get(peer) });\r\n        }\r\n    }\r\n    if (hasMorePeers)\r\n        textDisplayName = GuiActivator.getResources().getI18NString(\"service.gui.ARE_CALLING\", new String[] { textDisplayName });\r\n    label.setText(textDisplayName);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.ReceivedCallDialog.updateTextDisplayName",
	"Comment": "uses a table mapping peer to name to update call label display name.",
	"Method": "void updateTextDisplayName(Hashtable<CallPeer, String> peerNamesTable){\r\n    updateTextDisplayName(peerNamesTable);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.mailnotification.MailboxIQ.getResultTime",
	"Comment": "returns the time when these results were generated, in millisecondssince the unix epoch.",
	"Method": "long getResultTime(){\r\n    return resultTime;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomJabberImpl.findMemberForNickName",
	"Comment": "finds the member of this chat room corresponding to the given nick name.",
	"Method": "ChatRoomMemberJabberImpl findMemberForNickName(String jabberID){\r\n    synchronized (members) {\r\n        return members.get(jabberID);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MclStorageManager.metaContactAdded",
	"Comment": "indicates that a metacontact has been successfully added to themetacontact list.",
	"Method": "void metaContactAdded(MetaContactEvent evt){\r\n    if (!evt.getParentGroup().isPersistent())\r\n        return;\r\n    Element parentGroupNode = findMetaContactGroupNode(evt.getParentGroup().getMetaUID());\r\n    if (parentGroupNode == null) {\r\n        logger.error(\"Couldn't find parent of a newly added contact: \" + evt.getSourceMetaContact());\r\n        if (logger.isTraceEnabled())\r\n            logger.trace(\"The above exception occurred with the \" + \"following stack trace: \", new Exception());\r\n        return;\r\n    }\r\n    parentGroupNode = XMLUtils.findChild(parentGroupNode, CHILD_CONTACTS_NODE_NAME);\r\n    Element metaContactElement = createMetaContactNode(evt.getSourceMetaContact());\r\n    parentGroupNode.appendChild(metaContactElement);\r\n    try {\r\n        scheduleContactListStorage();\r\n    } catch (IOException ex) {\r\n        logger.error(\"Writing CL failed after adding contact \" + evt.getSourceMetaContact(), ex);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.globaldisplaydetails.GlobalDisplayDetailsActivator.serviceChanged",
	"Comment": "implements the servicelistener method. verifies whether thepassed event concerns a protocolproviderservice and adds orremoves a registration listener.",
	"Method": "void serviceChanged(ServiceEvent event){\r\n    ServiceReference<?> serviceRef = event.getServiceReference();\r\n    if (serviceRef.getBundle().getState() == Bundle.STOPPING) {\r\n        return;\r\n    }\r\n    Object service = UtilActivator.bundleContext.getService(serviceRef);\r\n    if (!(service instanceof ProtocolProviderService)) {\r\n        return;\r\n    }\r\n    ProtocolProviderService pps = (ProtocolProviderService) service;\r\n    switch(event.getType()) {\r\n        case ServiceEvent.REGISTERED:\r\n            this.handleProviderAdded(pps);\r\n            break;\r\n        case ServiceEvent.UNREGISTERING:\r\n            pps.removeRegistrationStateChangeListener(displayDetailsImpl);\r\n            globalStatusService.handleProviderRemoved(pps);\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactListServiceImpl.loadStoredMetaContactGroup",
	"Comment": "the method is called from the storage manager whenever a new contactgroup has been parsed and it has to be created.",
	"Method": "MetaContactGroupImpl loadStoredMetaContactGroup(MetaContactGroupImpl parentGroup,String metaContactGroupUID,String displayName){\r\n    MetaContactGroupImpl newMetaGroup = (MetaContactGroupImpl) parentGroup.getMetaContactSubgroupByUID(metaContactGroupUID);\r\n    if (newMetaGroup != null)\r\n        return newMetaGroup;\r\n    newMetaGroup = new MetaContactGroupImpl(this, displayName, metaContactGroupUID);\r\n    parentGroup.addSubgroup(newMetaGroup);\r\n    fireMetaContactGroupEvent(newMetaGroup, null, null, MetaContactGroupEvent.META_CONTACT_GROUP_ADDED);\r\n    return newMetaGroup;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.resources.ResourceManagementServiceImpl.getColorString",
	"Comment": "returns the string representation of the color corresponding to thegiven key.",
	"Method": "String getColorString(String key){\r\n    String res = getColorResources().get(key);\r\n    if (res == null) {\r\n        logger.error(\"Missing color resource for key: \" + key);\r\n        return \"0xFFFFFF\";\r\n    } else\r\n        return res;\r\n}"
}, {
	"Path": "net.librec.recommender.item.RecommendedList.getKeySetByContext",
	"Comment": "returns the key score pairs list of context index in this list.",
	"Method": "Set<Integer> getKeySetByContext(int contextIdx){\r\n    rangeCheck(contextIdx);\r\n    Set<Integer> keySet = new HashSet();\r\n    for (KeyValue<Integer, Double> keyValue : elementData.get(contextIdx)) {\r\n        keySet.add(keyValue.getKey());\r\n    }\r\n    return keySet;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.SourceUIContact.getContactCustomActionButtons",
	"Comment": "returns all custom action buttons for this notification contact.",
	"Method": "Collection<SIPCommButton> getContactCustomActionButtons(){\r\n    if (sourceContact != null)\r\n        return uiGroup.getParentUISource().getContactCustomActionButtons(sourceContact);\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatTransport.sendTypingNotification",
	"Comment": "sending typing notifications is not supported by this chat transportimplementation.",
	"Method": "int sendTypingNotification(int typingState){\r\n    return 0;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.ShowMoreContact.getRightButtonMenu",
	"Comment": "returns null to indicate that this contact has no right button menu.",
	"Method": "JPopupMenu getRightButtonMenu(){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.provdisc.dhcp.DHCPProvisioningDiscover.removeDiscoveryListener",
	"Comment": "add a listener that will be notified when thediscoverprovisioningurl has finished.",
	"Method": "void removeDiscoveryListener(DiscoveryListener listener){\r\n    if (listeners.contains(listener)) {\r\n        listeners.remove(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.CallPeerGibberishImpl.fireStreamSoundLevelEvent",
	"Comment": "fires a streamsoundlevelevent and notifies all registeredlisteners.",
	"Method": "void fireStreamSoundLevelEvent(int level){\r\n    SoundLevelListener[] listeners;\r\n    synchronized (soundLevelListeners) {\r\n        listeners = soundLevelListeners.toArray(new SoundLevelListener[soundLevelListeners.size()]);\r\n    }\r\n    for (SoundLevelListener listener : listeners) listener.soundLevelChanged(this, level);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.ActiveCallsRepository.callStateChanged",
	"Comment": "if evt indicates that the call has been ended we remove it fromthe repository.",
	"Method": "void callStateChanged(CallChangeEvent evt){\r\n    if (evt.getEventType().equals(CallChangeEvent.CALL_STATE_CHANGE) && evt.getNewValue().equals(CallState.CALL_ENDED)) {\r\n        T sourceCall = activeCalls.remove(evt.getSourceCall().getCallID());\r\n        if (logger.isTraceEnabled()) {\r\n            logger.trace(\"Removing call \" + sourceCall + \" from the list of active calls\" + \" because it entered an ENDED state\");\r\n        }\r\n        fireCallEvent(CallEvent.CALL_ENDED, sourceCall);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.SwingCallListener.onCallEvent",
	"Comment": "notifies this calllistener about a specific callevent.executes in whichever thread brought the event to this listener. deliversthe event to the awt event dispatching thread.",
	"Method": "void onCallEvent(CallEvent ev){\r\n    if (SwingUtilities.isEventDispatchThread())\r\n        onCallEventInEventDispatchThread(ev);\r\n    else {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                onCallEventInEventDispatchThread(ev);\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.SwingCallListener.onCallEvent",
	"Comment": "notifies this calllistener about a specific callevent.executes in whichever thread brought the event to this listener. deliversthe event to the awt event dispatching thread.",
	"Method": "void onCallEvent(CallEvent ev){\r\n    onCallEventInEventDispatchThread(ev);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.JabberActivator.getResources",
	"Comment": "returns a reference to the resourcemanagementservice implementationcurrently registered in the bundle context or null if no suchimplementation was found.",
	"Method": "ResourceManagementService getResources(){\r\n    if (resourcesService == null)\r\n        resourcesService = ResourceManagementServiceUtils.getService(bundleContext);\r\n    return resourcesService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.wizard.EncryptionConfigurationTableModel.init",
	"Comment": "initiates this table model in order to manage the encryption protocolsand the corresponding priority.",
	"Method": "void init(String[] encryptionProtocols,boolean[] encryptionProtocolStatus){\r\n    this.encryptionProtocols = encryptionProtocols;\r\n    this.encryptionProtocolStatus = encryptionProtocolStatus;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetServerStoredAccountInfoSipImpl.removeDetail",
	"Comment": "removes the specified detail from the list of details stored online forthis account.",
	"Method": "boolean removeDetail(GenericDetail detail,boolean removeDetail,GenericDetail detail,boolean fireChangeEvents){\r\n    boolean isFound = false;\r\n    Iterator<?> iter = getAllAvailableDetails();\r\n    while (iter.hasNext()) {\r\n        GenericDetail item = (GenericDetail) iter.next();\r\n        if (item.equals(detail)) {\r\n            isFound = true;\r\n        }\r\n    }\r\n    if (!isFound) {\r\n        return false;\r\n    }\r\n    if (ImageDetail.class.isAssignableFrom(detail.getClass()) && isImageDetailSupported()) {\r\n        deleteImageDetail();\r\n        accountImage = null;\r\n    }\r\n    if (fireChangeEvents)\r\n        fireServerStoredDetailsChangeEvent(provider, ServerStoredDetailsChangeEvent.DETAIL_REMOVED, detail, null);\r\n    return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.AvatarCacheUtils.escapeSpecialCharacters",
	"Comment": "replaces the characters that we must escape used for the createdfilename.",
	"Method": "String escapeSpecialCharacters(String id){\r\n    String resultId = id;\r\n    for (int j = 0; j < ESCAPE_SEQUENCES.length; j++) {\r\n        resultId = resultId.replaceAll(ESCAPE_SEQUENCES[j][0], ESCAPE_SEQUENCES[j][1]);\r\n    }\r\n    return resultId;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallSipImpl.findCallPeer",
	"Comment": "returns the call peer whose associated jain sip dialog matchesdialog.",
	"Method": "CallPeerSipImpl findCallPeer(Dialog dialog){\r\n    Iterator<CallPeerSipImpl> callPeers = this.getCallPeers();\r\n    if (logger.isTraceEnabled()) {\r\n        logger.trace(\"Looking for peer with dialog: \" + dialog + \"among \" + getCallPeerCount() + \" calls\");\r\n    }\r\n    for (CallPeerSipImpl callPeer : getCallPeerList()) {\r\n        if (callPeer.getDialog() == dialog) {\r\n            if (logger.isTraceEnabled())\r\n                logger.trace(\"Returning cp=\" + callPeer);\r\n            return callPeer;\r\n        } else {\r\n            if (logger.isTraceEnabled())\r\n                logger.trace(\"Ignoring cp=\" + callPeer + \" because cp.dialog=\" + callPeer.getDialog() + \" while dialog=\" + dialog);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.ChatRoomInvitationReceivedEvent.getTimestamp",
	"Comment": "a timestamp indicating the exact date when the event ocurred.",
	"Method": "Date getTimestamp(){\r\n    return timestamp;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.dns.ConfigurableDnssecResolver.reset",
	"Comment": "reloads the configuration of forwarders and trust anchors.",
	"Method": "void reset(){\r\n    String forwarders = DnsUtilActivator.getConfigurationService().getString(DnsUtilActivator.PNAME_DNSSEC_NAMESERVERS);\r\n    if (!StringUtils.isNullOrEmpty(forwarders, true)) {\r\n        if (logger.isTraceEnabled()) {\r\n            logger.trace(\"Setting DNSSEC forwarders to: \" + forwarders);\r\n        }\r\n        synchronized (Lookup.class) {\r\n            Lookup.refreshDefault();\r\n            String[] fwds = forwarders.split(\",\");\r\n            Resolver[] rs = headResolver.getResolvers();\r\n            for (Resolver r : rs) {\r\n                headResolver.deleteResolver(r);\r\n            }\r\n            for (String fwd : fwds) {\r\n                try {\r\n                    SimpleResolver sr = new SimpleResolver(fwd);\r\n                    sr.setEDNS(0, 0, ExtendedFlags.DO, null);\r\n                    sr.setIgnoreTruncation(false);\r\n                    headResolver.addResolver(sr);\r\n                } catch (UnknownHostException e) {\r\n                    logger.error(\"Invalid forwarder, ignoring\", e);\r\n                }\r\n            }\r\n            Lookup.setDefaultResolver(this);\r\n        }\r\n    }\r\n    StringBuilder sb = new StringBuilder();\r\n    for (int i = 1; ; i++) {\r\n        String anchor = DnsUtilActivator.getResources().getSettingsString(\"net.java.sip.communicator.util.dns.DS_ROOT.\" + i);\r\n        if (anchor == null) {\r\n            break;\r\n        }\r\n        sb.append(anchor);\r\n        sb.append('\\n');\r\n    }\r\n    try {\r\n        super.loadTrustAnchors(new ByteArrayInputStream(sb.toString().getBytes(\"ASCII\")));\r\n    } catch (IOException e) {\r\n        logger.error(\"Could not load the trust anchors\", e);\r\n    }\r\n    if (logger.isTraceEnabled())\r\n        logger.trace(\"Loaded trust anchors \" + sb.toString());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetBasicTelephonyJabberImpl.getActiveCallPeer",
	"Comment": "returns the active call peer corresponding to the given sid.",
	"Method": "CallPeerJabberImpl getActiveCallPeer(String sid){\r\n    return activeCallsRepository.findCallPeer(sid);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.history.HistoryMenu.actionPerformed",
	"Comment": "handles the actionevent when user selects an item from themenu. when the close item is selected disposes the window.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    JMenuItem menuItem = (JMenuItem) e.getSource();\r\n    String menuName = menuItem.getName();\r\n    if (menuName.equalsIgnoreCase(\"service.gui.CLOSE\")) {\r\n        this.parentWindow.setVisible(false);\r\n        this.parentWindow.dispose();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactListServiceImpl.removeMetaContactGroup",
	"Comment": "removes the specified meta contact group, all its corresponding protocolspecific groups and all their children.",
	"Method": "void removeMetaContactGroup(MetaContactGroup groupToRemove){\r\n    if (!(groupToRemove instanceof MetaContactGroupImpl)) {\r\n        throw new IllegalArgumentException(groupToRemove + \" is not an instance of MetaContactGroupImpl\");\r\n    }\r\n    try {\r\n        Iterator<ContactGroup> protoGroups = groupToRemove.getContactGroups();\r\n        while (protoGroups.hasNext()) {\r\n            ContactGroup protoGroup = protoGroups.next();\r\n            OperationSetPersistentPresence opSetPersPresence = protoGroup.getProtocolProvider().getOperationSet(OperationSetPersistentPresence.class);\r\n            if (opSetPersPresence == null) {\r\n                return;\r\n            }\r\n            opSetPersPresence.removeServerStoredContactGroup(protoGroup);\r\n        }\r\n    } catch (Exception ex) {\r\n        throw new MetaContactListException(ex.getMessage(), MetaContactListException.CODE_REMOVE_GROUP_ERROR);\r\n    }\r\n    MetaContactGroupImpl parentMetaGroup = (MetaContactGroupImpl) findParentMetaContactGroup(groupToRemove);\r\n    parentMetaGroup.removeSubgroup(groupToRemove);\r\n    fireMetaContactGroupEvent(groupToRemove, null, null, MetaContactGroupEvent.META_CONTACT_GROUP_REMOVED);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.whiteboard.WhiteboardObjectJabberImpl.generateID",
	"Comment": "generate a string uniquely identifying this whiteboardobject.",
	"Method": "String generateID(){\r\n    return String.valueOf(System.currentTimeMillis()) + String.valueOf(super.hashCode());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.configuration.JdbcConfigService.loadDefaultProperties",
	"Comment": "loads the specified default properties maps from the jitsi installationdirectory. typically this file is to be called for the default propertiesand the admin overrides.",
	"Method": "void loadDefaultProperties(String fileName){\r\n    try {\r\n        Properties fileProps = new Properties();\r\n        InputStream fileStream;\r\n        if (OSUtils.IS_ANDROID) {\r\n            fileStream = getClass().getClassLoader().getResourceAsStream(fileName);\r\n        } else {\r\n            fileStream = ClassLoader.getSystemResourceAsStream(fileName);\r\n        }\r\n        fileProps.load(fileStream);\r\n        fileStream.close();\r\n        for (Map.Entry<Object, Object> entry : fileProps.entrySet()) {\r\n            String name = (String) entry.getKey();\r\n            String value = (String) entry.getValue();\r\n            if (name == null || value == null || name.trim().length() == 0) {\r\n                continue;\r\n            }\r\n            if (name.startsWith(\"*\")) {\r\n                name = name.substring(1);\r\n                if (name.trim().length() == 0) {\r\n                    continue;\r\n                }\r\n                immutableDefaultProperties.put(name, value);\r\n                defaultProperties.remove(name);\r\n            } else {\r\n                defaultProperties.put(name, value);\r\n                immutableDefaultProperties.remove(name);\r\n            }\r\n        }\r\n    } catch (Exception ex) {\r\n        logger.info(\"No defaults property file loaded: \" + fileName + \". Not a problem.\");\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"load exception\", ex);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.WhiteboardObjectDeletedEvent.getSourceContact",
	"Comment": "returns a reference to the contact that has send thewhiteboardobject whose reception this event represents.",
	"Method": "Contact getSourceContact(){\r\n    return from;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactGroupImpl.findMetaContactByMetaUID",
	"Comment": "returns a meta contact, a child of this group or its subgroups, thathas the specified metauid. if no such meta contact exists, the methodwould return null.",
	"Method": "MetaContact findMetaContactByMetaUID(String metaUID){\r\n    Iterator<MetaContact> contactsIter = getChildContacts();\r\n    while (contactsIter.hasNext()) {\r\n        MetaContact mContact = contactsIter.next();\r\n        if (mContact.getMetaUID().equals(metaUID))\r\n            return mContact;\r\n    }\r\n    Iterator<MetaContactGroup> groupsIter = getSubgroups();\r\n    while (groupsIter.hasNext()) {\r\n        MetaContactGroupImpl mGroup = (MetaContactGroupImpl) groupsIter.next();\r\n        MetaContact mContact = mGroup.findMetaContactByMetaUID(metaUID);\r\n        if (mContact != null)\r\n            return mContact;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.ChatRoomListImpl.addRegisteredChatProvider",
	"Comment": "adds a chat server which is registered and all its existing chat rooms.",
	"Method": "ChatRoomProviderWrapper addRegisteredChatProvider(ProtocolProviderService pps){\r\n    ChatRoomProviderWrapper chatRoomProvider = new ChatRoomProviderWrapperImpl(pps);\r\n    providersList.add(chatRoomProvider);\r\n    ConfigurationService configService = MUCActivator.getConfigurationService();\r\n    String prefix = \"net.java.sip.communicator.impl.gui.accounts\";\r\n    List<String> accounts = configService.getPropertyNamesByPrefix(prefix, true);\r\n    for (String accountRootPropName : accounts) {\r\n        String accountUID = configService.getString(accountRootPropName);\r\n        if (accountUID.equals(pps.getAccountID().getAccountUniqueID())) {\r\n            List<String> chatRooms = configService.getPropertyNamesByPrefix(accountRootPropName + \".chatRooms\", true);\r\n            for (String chatRoomPropName : chatRooms) {\r\n                String chatRoomID = configService.getString(chatRoomPropName);\r\n                String chatRoomName = configService.getString(chatRoomPropName + \".chatRoomName\");\r\n                ChatRoomWrapper chatRoomWrapper = new ChatRoomWrapperImpl(chatRoomProvider, chatRoomID, chatRoomName);\r\n                chatRoomProvider.addChatRoom(chatRoomWrapper);\r\n            }\r\n        }\r\n    }\r\n    fireProviderWrapperAdded(chatRoomProvider);\r\n    return chatRoomProvider;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.history.HistoryWindowManager.addHistoryWindowForContact",
	"Comment": "adds a history window for a given contact in the table of opened historywindows.",
	"Method": "void addHistoryWindowForContact(Object historyContact,HistoryWindow historyWindow){\r\n    contactHistory.put(historyContact, historyWindow);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.menus.ToolsMenu.initPluginComponents",
	"Comment": "initialize plugin components already registered for this container.",
	"Method": "void initPluginComponents(){\r\n    ServiceReference[] serRefs = null;\r\n    String osgiFilter = \"(\" + Container.CONTAINER_ID + \"=\" + Container.CONTAINER_TOOLS_MENU.getID() + \")\";\r\n    try {\r\n        serRefs = GuiActivator.bundleContext.getServiceReferences(PluginComponentFactory.class.getName(), osgiFilter);\r\n    } catch (InvalidSyntaxException exc) {\r\n        logger.error(\"Could not obtain plugin reference.\", exc);\r\n    }\r\n    if (serRefs != null) {\r\n        for (ServiceReference serRef : serRefs) {\r\n            final PluginComponentFactory f = (PluginComponentFactory) GuiActivator.bundleContext.getService(serRef);\r\n            SwingUtilities.invokeLater(new Runnable() {\r\n                public void run() {\r\n                    PluginComponent pluginComponent = f.getPluginComponentInstance(ToolsMenu.this);\r\n                    insertInSection((JMenuItem) pluginComponent.getComponent(), pluginComponent.getPositionIndex());\r\n                }\r\n            });\r\n        }\r\n    }\r\n    GuiActivator.getUIService().addPluginComponentListener(this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.menus.ToolsMenu.initPluginComponents",
	"Comment": "initialize plugin components already registered for this container.",
	"Method": "void initPluginComponents(){\r\n    PluginComponent pluginComponent = f.getPluginComponentInstance(ToolsMenu.this);\r\n    insertInSection((JMenuItem) pluginComponent.getComponent(), pluginComponent.getPositionIndex());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallSipImpl.createCallPeerFor",
	"Comment": "creates a new call peer associated with containingtransaction",
	"Method": "CallPeerSipImpl createCallPeerFor(Transaction containingTransaction,SipProvider sourceProvider){\r\n    CallPeerSipImpl callPeer = new CallPeerSipImpl(containingTransaction.getDialog().getRemoteParty(), this, containingTransaction, sourceProvider) {\r\n        protected void processExtraHeaders(javax.sip.message.Message message) throws ParseException {\r\n            super.processExtraHeaders(message);\r\n            CallSipImpl.this.processExtraHeaders(message);\r\n        }\r\n    };\r\n    addCallPeer(callPeer);\r\n    boolean incomingCall = (containingTransaction instanceof ServerTransaction);\r\n    callPeer.setState(incomingCall ? CallPeerState.INCOMING_CALL : CallPeerState.INITIATING_CALL);\r\n    if (getCallPeerCount() == 1) {\r\n        Map<MediaType, MediaDirection> mediaDirections = new HashMap<MediaType, MediaDirection>();\r\n        mediaDirections.put(MediaType.AUDIO, MediaDirection.INACTIVE);\r\n        mediaDirections.put(MediaType.VIDEO, MediaDirection.INACTIVE);\r\n        boolean hasZrtp = false;\r\n        boolean hasSdes = false;\r\n        try {\r\n            Request inviteReq = containingTransaction.getRequest();\r\n            if (inviteReq != null && inviteReq.getRawContent() != null) {\r\n                String sdpStr = SdpUtils.getContentAsString(inviteReq);\r\n                SessionDescription sesDescr = SdpUtils.parseSdpString(sdpStr);\r\n                List<MediaDescription> remoteDescriptions = SdpUtils.extractMediaDescriptions(sesDescr);\r\n                for (MediaDescription mediaDescription : remoteDescriptions) {\r\n                    MediaType mediaType = SdpUtils.getMediaType(mediaDescription);\r\n                    mediaDirections.put(mediaType, SdpUtils.getDirection(mediaDescription));\r\n                    if (!hasZrtp) {\r\n                        hasZrtp = (mediaDescription.getAttribute(SdpUtils.ZRTP_HASH_ATTR) != null);\r\n                    }\r\n                    if (!hasSdes) {\r\n                        @SuppressWarnings(\"unchecked\")\r\n                        Vector<Attribute> attrs = mediaDescription.getAttributes(true);\r\n                        for (Attribute attr : attrs) {\r\n                            try {\r\n                                if (\"crypto\".equals(attr.getName())) {\r\n                                    hasSdes = true;\r\n                                    break;\r\n                                }\r\n                            } catch (SdpParseException spe) {\r\n                                logger.error(\"Failed to parse SDP attribute\", spe);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } catch (Throwable t) {\r\n            logger.warn(\"Error getting media types\", t);\r\n        }\r\n        fireCallEvent(incomingCall ? CallEvent.CALL_RECEIVED : CallEvent.CALL_INITIATED, this, mediaDirections);\r\n        if (hasZrtp) {\r\n            callPeer.getMediaHandler().addAdvertisedEncryptionMethod(SrtpControlType.ZRTP);\r\n        }\r\n        if (hasSdes) {\r\n            callPeer.getMediaHandler().addAdvertisedEncryptionMethod(SrtpControlType.SDES);\r\n        }\r\n    }\r\n    return callPeer;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallSipImpl.createCallPeerFor",
	"Comment": "creates a new call peer associated with containingtransaction",
	"Method": "CallPeerSipImpl createCallPeerFor(Transaction containingTransaction,SipProvider sourceProvider){\r\n    super.processExtraHeaders(message);\r\n    CallSipImpl.this.processExtraHeaders(message);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.whiteboard.WhiteboardObjectCircleJabberImpl.setFill",
	"Comment": "sets the fill state of the whiteboardobject.true is filled, false is unfilled.",
	"Method": "void setFill(boolean fill){\r\n    this.fill = fill;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.account.AccountList.ensureAccountRemoved",
	"Comment": "ensures that the account with the given accountid is removedfrom the list.",
	"Method": "void ensureAccountRemoved(AccountID accountID){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                ensureAccountRemoved(accountID);\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    Account account = accountListModel.getAccount(accountID);\r\n    if (account != null)\r\n        accountListModel.removeAccount(account);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.account.AccountList.ensureAccountRemoved",
	"Comment": "ensures that the account with the given accountid is removedfrom the list.",
	"Method": "void ensureAccountRemoved(AccountID accountID){\r\n    ensureAccountRemoved(accountID);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.fileaccess.TestFileAccessService.testCreatePersistentFile",
	"Comment": "tests if it is possible for a file to be created if it does not exist",
	"Method": "void testCreatePersistentFile(){\r\n    try {\r\n        File file = this.fileAccessService.getPrivatePersistentFile(fileName, FileCategory.PROFILE);\r\n        if (!file.exists()) {\r\n            assertTrue(file.createNewFile());\r\n        }\r\n    } catch (Exception e) {\r\n        fail(e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "net.librec.recommender.cf.UserKNNTestCase.test24SplitterRatioValid",
	"Comment": "test ratiodatasplitter with valid ratio, filter enabled.",
	"Method": "void test24SplitterRatioValid(){\r\n    Resource resource = new Resource(\"rec/cf/userknn-test.properties\");\r\n    conf.addResource(resource);\r\n    conf.set(\"rec.eval.enable\", \"false\");\r\n    conf.set(\"rec.filter.class\", \"generic\");\r\n    conf.set(\"data.model.splitter\", \"ratio\");\r\n    conf.set(\"data.splitter.ratio\", \"valid\");\r\n    conf.set(\"data.splitter.trainset.ratio\", \"0.5\");\r\n    conf.set(\"data.splitter.validset.ratio\", \"0.2\");\r\n    RecommenderJob job = new RecommenderJob(conf);\r\n    job.runJob();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommTextArea.fireTextFieldChangeListener",
	"Comment": "notifies all registered textfieldchangelisteners that a changehas occurred in the text contained in this field.",
	"Method": "void fireTextFieldChangeListener(int eventType){\r\n    for (TextFieldChangeListener l : changeListeners) switch(eventType) {\r\n        case 0:\r\n            l.textInserted();\r\n            break;\r\n        case 1:\r\n            l.textRemoved();\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.systray.AbstractSystrayService.addPopupMessageListener",
	"Comment": "implements the systrayservice.addpopupmessagelistener method.if activepopuphandler is still not available record the listenerso we can add him later.",
	"Method": "void addPopupMessageListener(SystrayPopupMessageListener listener){\r\n    if (activePopupHandler != null)\r\n        activePopupHandler.addPopupMessageListener(listener);\r\n    else {\r\n        if (earlyAddedListeners == null)\r\n            earlyAddedListeners = new ArrayList<SystrayPopupMessageListener>();\r\n        earlyAddedListeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.credentialsstorage.TestCredentialsStorageService.testRemoveSavedPassword",
	"Comment": "tests whether removing the saved password really removes it.",
	"Method": "void testRemoveSavedPassword(){\r\n    credentialsService.removePassword(accountPrefix);\r\n    String loadedPassword = credentialsService.loadPassword(accountPrefix);\r\n    assertNull(\"Password was not removed\", loadedPassword);\r\n    credentialsService.storePassword(accountPrefix, accountPassword);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl.removeSupportedOperationSet",
	"Comment": "removes an operationset implementation from the set ofsupported operationsets for this instance.",
	"Method": "void removeSupportedOperationSet(Class<T> opsetClass){\r\n    super.removeSupportedOperationSet(opsetClass);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.account.EmptyAccountRegistrationWizardPage.getSimpleForm",
	"Comment": "returns the jpanel that contains the message prompting the userto select a protocol.",
	"Method": "Object getSimpleForm(){\r\n    return mainPanel;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.ircaccregwizz.IrcAccountRegistration.setResolveDnsThroughProxy",
	"Comment": "set property for resolving dns through configured proxy server.",
	"Method": "void setResolveDnsThroughProxy(boolean value){\r\n    this.resolveDnsThroughProxy = value;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ContactListTreeCellRenderer.getDragIcon",
	"Comment": "returns the drag icon used to represent a cell in all drag operations.",
	"Method": "Icon getDragIcon(JTree tree,Object dragObject,int index){\r\n    ContactListTreeCellRenderer dragC = (ContactListTreeCellRenderer) getTreeCellRendererComponent(// is selected\r\n    tree, dragObject, false, false, // has focus\r\n    true, index, true);\r\n    dragC.setBounds(0, 0, dragC.getIconWidth(), dragC.getIconHeight());\r\n    Icon rightLabelIcon = rightLabel.getIcon();\r\n    int imageHeight = 0;\r\n    int imageWidth = 0;\r\n    if (rightLabelIcon != null) {\r\n        imageWidth = rightLabelIcon.getIconWidth();\r\n        imageHeight = rightLabelIcon.getIconHeight();\r\n        dragC.rightLabel.setBounds(tree.getWidth() - imageWidth, 0, imageWidth, imageHeight);\r\n    }\r\n    dragC.statusLabel.setBounds(0, 0, statusLabel.getWidth(), statusLabel.getHeight());\r\n    dragC.nameLabel.setBounds(statusLabel.getWidth(), 0, tree.getWidth() - imageWidth - 5, nameLabel.getHeight());\r\n    dragC.displayDetailsLabel.setBounds(displayDetailsLabel.getX(), nameLabel.getHeight(), displayDetailsLabel.getWidth(), displayDetailsLabel.getHeight());\r\n    return dragC;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.ContactGroupGibberishImpl.isPersistent",
	"Comment": "determines whether or not this contact group is being stored by theserver. non persistent contact groups exist for the sole purpose ofcontaining non persistent contacts.",
	"Method": "boolean isPersistent(){\r\n    return isPersistent;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.replacement.smiley.SmileyActivator.getResources",
	"Comment": "returns the resourcemanagementservice, through which we willaccess all resources.",
	"Method": "ResourceManagementService getResources(){\r\n    if (resourcesService == null) {\r\n        ServiceReference serviceReference = bundleContext.getServiceReference(ResourceManagementService.class.getName());\r\n        if (serviceReference == null)\r\n            return null;\r\n        resourcesService = (ResourceManagementService) bundleContext.getService(serviceReference);\r\n    }\r\n    return resourcesService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.provisioning.ProvisioningServiceImpl.retrieveConfigurationFile",
	"Comment": "retrieve configuration file from provisioning url.this method is blocking until configuration file is retrieved from thenetwork or if an exception happen",
	"Method": "InputStream retrieveConfigurationFile(String url,InputStream retrieveConfigurationFile,String url,List<NameValuePair> parameters){\r\n    try {\r\n        String arg = null;\r\n        String[] args = null;\r\n        URL u = new URL(url);\r\n        InetAddress ipaddr = ProvisioningActivator.getNetworkAddressManagerService().getLocalHost(InetAddress.getByName(u.getHost()));\r\n        Pattern p = Pattern.compile(\"\\\\$\\\\{env\\\\.([^\\\\}]*)\\\\}\");\r\n        Matcher m = p.matcher(url);\r\n        StringBuffer sb = new StringBuffer();\r\n        while (m.find()) {\r\n            String value = System.getenv(m.group(1));\r\n            if (value != null) {\r\n                m.appendReplacement(sb, Matcher.quoteReplacement(value));\r\n            }\r\n        }\r\n        m.appendTail(sb);\r\n        url = sb.toString();\r\n        p = Pattern.compile(\"\\\\$\\\\{system\\\\.([^\\\\}]*)\\\\}\");\r\n        m = p.matcher(url);\r\n        sb = new StringBuffer();\r\n        while (m.find()) {\r\n            String value = System.getProperty(m.group(1));\r\n            if (value != null) {\r\n                m.appendReplacement(sb, Matcher.quoteReplacement(value));\r\n            }\r\n        }\r\n        m.appendTail(sb);\r\n        url = sb.toString();\r\n        if (url.indexOf(\"${home.location}\") != -1) {\r\n            url = url.replace(\"${home.location}\", ProvisioningActivator.getConfigurationService().getScHomeDirLocation());\r\n        }\r\n        if (url.indexOf(\"${home.name}\") != -1) {\r\n            url = url.replace(\"${home.name}\", ProvisioningActivator.getConfigurationService().getScHomeDirName());\r\n        }\r\n        if (url.indexOf(\"${uuid}\") != -1) {\r\n            url = url.replace(\"${uuid}\", (String) ProvisioningActivator.getConfigurationService().getProperty(PROVISIONING_UUID_PROP));\r\n        }\r\n        if (url.indexOf(\"${osname}\") != -1) {\r\n            url = url.replace(\"${osname}\", System.getProperty(\"os.name\"));\r\n        }\r\n        if (url.indexOf(\"${arch}\") != -1) {\r\n            url = url.replace(\"${arch}\", System.getProperty(\"os.arch\"));\r\n        }\r\n        if (url.indexOf(\"${resx}\") != -1 || url.indexOf(\"${resy}\") != -1) {\r\n            Rectangle screen = ScreenInformation.getScreenBounds();\r\n            if (url.indexOf(\"${resx}\") != -1) {\r\n                url = url.replace(\"${resx}\", String.valueOf(screen.width));\r\n            }\r\n            if (url.indexOf(\"${resy}\") != -1) {\r\n                url = url.replace(\"${resy}\", String.valueOf(screen.height));\r\n            }\r\n        }\r\n        if (url.indexOf(\"${build}\") != -1) {\r\n            url = url.replace(\"${build}\", System.getProperty(\"sip-communicator.version\"));\r\n        }\r\n        if (url.indexOf(\"${locale}\") != -1) {\r\n            String locale = ProvisioningActivator.getConfigurationService().getString(ResourceManagementService.DEFAULT_LOCALE_CONFIG);\r\n            if (locale == null)\r\n                locale = \"\";\r\n            url = url.replace(\"${locale}\", locale);\r\n        }\r\n        if (url.indexOf(\"${ipaddr}\") != -1) {\r\n            url = url.replace(\"${ipaddr}\", ipaddr.getHostAddress());\r\n        }\r\n        if (url.indexOf(\"${hostname}\") != -1) {\r\n            String name;\r\n            if (OSUtils.IS_WINDOWS) {\r\n                name = System.getenv(\"COMPUTERNAME\");\r\n            } else {\r\n                name = ipaddr.getHostName();\r\n            }\r\n            url = url.replace(\"${hostname}\", name);\r\n        }\r\n        if (url.indexOf(\"${hwaddr}\") != -1) {\r\n            if (ipaddr != null) {\r\n                Enumeration<NetworkInterface> en = NetworkInterface.getNetworkInterfaces();\r\n                while (en.hasMoreElements()) {\r\n                    NetworkInterface iface = en.nextElement();\r\n                    Enumeration<InetAddress> enInet = iface.getInetAddresses();\r\n                    while (enInet.hasMoreElements()) {\r\n                        InetAddress inet = enInet.nextElement();\r\n                        if (inet.equals(ipaddr)) {\r\n                            byte[] hw = ProvisioningActivator.getNetworkAddressManagerService().getHardwareAddress(iface);\r\n                            if (hw == null || hw.length == 0)\r\n                                continue;\r\n                            StringBuffer buf = new StringBuffer();\r\n                            for (byte h : hw) {\r\n                                int hi = h >= 0 ? h : h + 256;\r\n                                String t = new String((hi <= 0xf) ? \"0\" : \"\");\r\n                                t += Integer.toHexString(hi);\r\n                                buf.append(t);\r\n                                buf.append(\":\");\r\n                            }\r\n                            buf.deleteCharAt(buf.length() - 1);\r\n                            url = url.replace(\"${hwaddr}\", buf.toString());\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (url.contains(\"?\")) {\r\n            if ((url.indexOf('?') + 1) != url.length()) {\r\n                arg = url.substring(url.indexOf('?') + 1);\r\n                args = arg.split(\"&\");\r\n            }\r\n            url = url.substring(0, url.indexOf('?'));\r\n        }\r\n        ArrayList<String> paramNames = null;\r\n        ArrayList<String> paramValues = null;\r\n        int usernameIx = -1;\r\n        int passwordIx = -1;\r\n        if (args != null && args.length > 0) {\r\n            paramNames = new ArrayList<String>(args.length);\r\n            paramValues = new ArrayList<String>(args.length);\r\n            String usernameParam = \"${username}\";\r\n            String passwordParam = \"${password}\";\r\n            for (int i = 0; i < args.length; i++) {\r\n                String s = args[i];\r\n                int equalsIndex = s.indexOf(\"=\");\r\n                String currentParamName = null;\r\n                if (equalsIndex > -1) {\r\n                    currentParamName = s.substring(0, equalsIndex);\r\n                }\r\n                String preloadedParamValue = getParamValue(parameters, currentParamName);\r\n                if (s.indexOf(usernameParam) != -1) {\r\n                    if (preloadedParamValue != null) {\r\n                        s = s.replace(usernameParam, preloadedParamValue);\r\n                    } else\r\n                        s = s.replace(usernameParam, \"\");\r\n                    usernameIx = paramNames.size();\r\n                } else if (s.indexOf(passwordParam) != -1) {\r\n                    if (preloadedParamValue != null) {\r\n                        s = s.replace(passwordParam, preloadedParamValue);\r\n                    } else\r\n                        s = s.replace(passwordParam, \"\");\r\n                    passwordIx = paramNames.size();\r\n                }\r\n                if (equalsIndex > -1) {\r\n                    paramNames.add(currentParamName);\r\n                    paramValues.add(s.substring(equalsIndex + 1));\r\n                } else {\r\n                    if (logger.isInfoEnabled()) {\r\n                        logger.info(\"Invalid provisioning request parameter: \\\"\" + s + \"\\\", is replaced by \\\"\" + s + \"=\\\"\");\r\n                    }\r\n                    paramNames.add(s);\r\n                    paramValues.add(\"\");\r\n                }\r\n            }\r\n        }\r\n        HttpUtils.HTTPResponseResult res = null;\r\n        Throwable errorWhileProvisioning = null;\r\n        try {\r\n            res = HttpUtils.postForm(url, PROPERTY_PROVISIONING_USERNAME, PROPERTY_PROVISIONING_PASSWORD, paramNames, paramValues, usernameIx, passwordIx, new HttpUtils.RedirectHandler() {\r\n                @Override\r\n                public boolean handleRedirect(String location, List<NameValuePair> parameters) {\r\n                    if (!hasParams(location))\r\n                        return false;\r\n                    retrieveConfigurationFile(location, parameters);\r\n                    return true;\r\n                }\r\n                @Override\r\n                public boolean hasParams(String location) {\r\n                    return location.contains(\"${\");\r\n                }\r\n            });\r\n        } catch (Throwable t) {\r\n            logger.error(\"Error posting form\", t);\r\n            errorWhileProvisioning = t;\r\n        }\r\n        if (res == null) {\r\n            if (ProvisioningActivator.getConfigurationService().getBoolean(PROPERTY_PROVISIONING_MANDATORY, false)) {\r\n                String errorMsg;\r\n                if (errorWhileProvisioning != null)\r\n                    errorMsg = errorWhileProvisioning.getLocalizedMessage();\r\n                else\r\n                    errorMsg = \"\";\r\n                ErrorDialog ed = new ErrorDialog(null, ProvisioningActivator.getResourceService().getI18NString(\"plugin.provisioning.PROV_FAILED\"), ProvisioningActivator.getResourceService().getI18NString(\"plugin.provisioning.PROV_FAILED_MSG\", new String[] { errorMsg }), errorWhileProvisioning);\r\n                ed.setModal(true);\r\n                ed.showDialog();\r\n                {\r\n                    for (Bundle b : ProvisioningActivator.bundleContext.getBundles()) {\r\n                        try {\r\n                            if (ProvisioningActivator.bundleContext.equals(b.getBundleContext())) {\r\n                                continue;\r\n                            }\r\n                            b.stop();\r\n                        } catch (BundleException ex) {\r\n                            logger.error(\"Failed to being gentle stop \" + b.getLocation(), ex);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n        String[] userPass = res.getCredentials();\r\n        if (userPass[0] != null && userPass[1] != null) {\r\n            provUsername = userPass[0];\r\n            provPassword = userPass[1];\r\n        }\r\n        InputStream in = res.getContent();\r\n        if (!OSUtils.IS_ANDROID) {\r\n            final ProgressMonitorInputStream pin;\r\n            pin = new ProgressMonitorInputStream(null, u.toString(), in);\r\n            ProgressMonitor pm = pin.getProgressMonitor();\r\n            pm.setMaximum((int) res.getContentLength());\r\n            return pin;\r\n        }\r\n        return in;\r\n    } catch (Exception e) {\r\n        if (logger.isInfoEnabled())\r\n            logger.info(\"Error retrieving provisioning file!\", e);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.provisioning.ProvisioningServiceImpl.retrieveConfigurationFile",
	"Comment": "retrieve configuration file from provisioning url.this method is blocking until configuration file is retrieved from thenetwork or if an exception happen",
	"Method": "InputStream retrieveConfigurationFile(String url,InputStream retrieveConfigurationFile,String url,List<NameValuePair> parameters){\r\n    if (!hasParams(location))\r\n        return false;\r\n    retrieveConfigurationFile(location, parameters);\r\n    return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.provisioning.ProvisioningServiceImpl.retrieveConfigurationFile",
	"Comment": "retrieve configuration file from provisioning url.this method is blocking until configuration file is retrieved from thenetwork or if an exception happen",
	"Method": "InputStream retrieveConfigurationFile(String url,InputStream retrieveConfigurationFile,String url,List<NameValuePair> parameters){\r\n    return location.contains(\"${\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.ConfigurationUtils.setShowMasterPasswordWarning",
	"Comment": "updates the value of whether to show master password warning.",
	"Method": "void setShowMasterPasswordWarning(boolean value){\r\n    showMasterPasswordWarning = value;\r\n    configService.setProperty(MASTER_PASS_WARNING_PROP, value);\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.call.MetaContactPhoneUtil.isCallEnabled",
	"Comment": "is call enabled for metacontact. if any of the childcontacts has call enabled.",
	"Method": "boolean isCallEnabled(DetailsResponseListener listener,boolean isCallEnabled,DetailsResponseListener listener,boolean checkForTelephonyOpSet,boolean isCallEnabled,boolean isCallEnabled,boolean checkForTelephonyOpSet,boolean isCallEnabled,Contact contact){\r\n    if (!checkContactPhones(contact))\r\n        return false;\r\n    return contact.getProtocolProvider().getOperationSet(OperationSetBasicTelephony.class) != null && hasContactCapabilities(contact, OperationSetBasicTelephony.class);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.CallPeerGibberishImpl.addConferenceMembersSoundLevelListener",
	"Comment": "adds a specific soundlevellistener to the listof listeners interested in and notified about changes in conferencemembers sound level.",
	"Method": "void addConferenceMembersSoundLevelListener(ConferenceMembersSoundLevelListener listener){\r\n    synchronized (confMemebrSoundLevelListeners) {\r\n        if (!confMemebrSoundLevelListeners.contains(listener))\r\n            confMemebrSoundLevelListeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.contactinfo.ContactInfoDetailsPanel.createExtendedInfoPanel",
	"Comment": "a panel that displays all of the details retrieved from the opset.",
	"Method": "JPanel createExtendedInfoPanel(){\r\n    JPanel mainExtendedPanel = new TransparentPanel(new BorderLayout());\r\n    JPanel extendedPanel = new TransparentPanel();\r\n    extendedPanel.setLayout(new BoxLayout(extendedPanel, BoxLayout.Y_AXIS));\r\n    JPanel imagePanel = new TransparentPanel();\r\n    imagePanel.setLayout(new BoxLayout(imagePanel, BoxLayout.LINE_AXIS));\r\n    imagePanel.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createTitledBorder(Resources.getString(\"plugin.contactinfo.USER_PICTURES\")), BorderFactory.createEmptyBorder(0, 5, 5, 5)));\r\n    Iterator<GenericDetail> iter = contactInfoOpSet.getAllDetailsForContact(contact);\r\n    GenericDetail detail;\r\n    JLabel detailLabel;\r\n    JTextArea detailValueArea;\r\n    JPanel detailPanel;\r\n    while (iter.hasNext()) {\r\n        detail = iter.next();\r\n        if (detail.getDetailValue().toString().equals(\"\"))\r\n            continue;\r\n        detailLabel = new JLabel();\r\n        detailValueArea = new JTextArea();\r\n        detailPanel = new TransparentPanel(new BorderLayout(10, 10));\r\n        detailValueArea.setAlignmentX(JTextArea.CENTER_ALIGNMENT);\r\n        detailValueArea.setEditable(false);\r\n        detailValueArea.setLineWrap(true);\r\n        detailPanel.add(detailLabel, BorderLayout.WEST);\r\n        detailPanel.add(detailValueArea, BorderLayout.CENTER);\r\n        detailPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));\r\n        extendedPanel.add(detailPanel);\r\n        if (detail instanceof BinaryDetail) {\r\n            JLabel imageLabel = new JLabel(new ImageIcon((byte[]) detail.getDetailValue()));\r\n            imagePanel.add(imageLabel);\r\n        } else if (detail instanceof CalendarDetail) {\r\n            detailLabel.setText(detail.getDetailDisplayName() + \": \");\r\n            Date detailDate = ((Calendar) detail.getDetailValue()).getTime();\r\n            DateFormat df = DateFormat.getDateInstance();\r\n            detailValueArea.setText(df.format(detailDate).trim());\r\n        } else if (detail instanceof LocaleDetail) {\r\n            detailLabel.setText(detail.getDetailDisplayName() + \": \");\r\n            Object value = detail.getDetailValue();\r\n            String valueStr = \"\";\r\n            if (value instanceof Locale)\r\n                valueStr = ((Locale) value).getDisplayName().trim();\r\n            else if (value instanceof String)\r\n                valueStr = (String) value;\r\n            detailValueArea.setText(valueStr);\r\n        } else if (detail instanceof TimeZoneDetail) {\r\n            detailLabel.setText(detail.getDetailDisplayName() + \": \");\r\n            detailValueArea.setText(((TimeZone) detail.getDetailValue()).getDisplayName().trim());\r\n        } else {\r\n            detailLabel.setText(detail.getDetailDisplayName() + \": \");\r\n            detailValueArea.setText(detail.getDetailValue().toString().trim());\r\n        }\r\n    }\r\n    String statusMessage = contact.getStatusMessage();\r\n    if (statusMessage != null && statusMessage.length() > 0) {\r\n        detailLabel = new JLabel();\r\n        HTMLTextPane detailValuePane = new HTMLTextPane();\r\n        detailPanel = new TransparentPanel(new BorderLayout(10, 10));\r\n        detailValuePane.setEditable(false);\r\n        detailValuePane.setOpaque(false);\r\n        detailPanel.add(detailLabel, BorderLayout.WEST);\r\n        detailPanel.add(detailValuePane, BorderLayout.CENTER);\r\n        detailPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));\r\n        extendedPanel.add(detailPanel);\r\n        detailLabel.setText(Resources.getString(\"plugin.contactinfo.USER_STATUS_MESSAGE\") + \": \");\r\n        detailValuePane.setText(statusMessage);\r\n    }\r\n    OperationSetWebContactInfo webContactInfo = contact.getProtocolProvider().getOperationSet(OperationSetWebContactInfo.class);\r\n    if (webContactInfo != null) {\r\n        final String urlString = webContactInfo.getWebContactInfo(contact).toString();\r\n        JLabel webInfoLabel = new JLabel(\"Click to see web info: \");\r\n        JEditorPane webInfoValue = new JEditorPane();\r\n        JPanel webInfoPanel = new TransparentPanel(new BorderLayout());\r\n        webInfoPanel.add(webInfoLabel, BorderLayout.WEST);\r\n        webInfoPanel.add(webInfoValue, BorderLayout.CENTER);\r\n        extendedPanel.add(webInfoPanel);\r\n        webInfoValue.setOpaque(false);\r\n        webInfoValue.setContentType(\"text/html\");\r\n        webInfoValue.setEditable(false);\r\n        webInfoValue.setText(\"<a href='\" + urlString + \"'>\" + contact.getDisplayName() + \" web info<\/a>\");\r\n        webInfoValue.addHyperlinkListener(new HyperlinkListener() {\r\n            public void hyperlinkUpdate(HyperlinkEvent e) {\r\n                if (e.getEventType().equals(HyperlinkEvent.EventType.ACTIVATED)) {\r\n                    ContactInfoActivator.getBrowserLauncher().openURL(urlString);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    if (imagePanel.getComponentCount() > 0)\r\n        mainExtendedPanel.add(imagePanel, BorderLayout.CENTER);\r\n    mainExtendedPanel.add(extendedPanel, BorderLayout.NORTH);\r\n    return mainExtendedPanel;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.contactinfo.ContactInfoDetailsPanel.createExtendedInfoPanel",
	"Comment": "a panel that displays all of the details retrieved from the opset.",
	"Method": "JPanel createExtendedInfoPanel(){\r\n    if (e.getEventType().equals(HyperlinkEvent.EventType.ACTIVATED)) {\r\n        ContactInfoActivator.getBrowserLauncher().openURL(urlString);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.addgroup.CreateGroupDialog.windowGainedFocus",
	"Comment": "indicates that the window has gained the focus. requests the focus inthe text field.",
	"Method": "void windowGainedFocus(WindowEvent e){\r\n    this.groupPanel.requestFocusInField();\r\n}"
}, {
	"Path": "org.eclipse.jetty.test.support.JettyDistro.getJmxUrl",
	"Comment": "return the jmx url being used for this jetty process instance.",
	"Method": "String getJmxUrl(){\r\n    return this.jmxUrl;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.GenericUIContactImpl.getDefaultContactDetail",
	"Comment": "returns the default contactdetail to use for any operationsdepending to the given operationset class.",
	"Method": "UIContactDetail getDefaultContactDetail(Class<? extends OperationSet> opSetClass){\r\n    List<UIContactDetail> opSetDetails = contactDetails.get(opSetClass);\r\n    if (opSetDetails != null && opSetDetails.size() > 0)\r\n        return opSetDetails.get(0);\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.ConfigurationUtils.getChatRoomPrefix",
	"Comment": "returns the chat room prefix saved in configurationserviceassociated with the accountid and chatroomid.",
	"Method": "String getChatRoomPrefix(String accountID,String chatRoomId){\r\n    String prefix = \"net.java.sip.communicator.impl.gui.accounts\";\r\n    List<String> accounts = configService.getPropertyNamesByPrefix(prefix, true);\r\n    for (String accountRootPropName : accounts) {\r\n        String tmpAccountID = configService.getString(accountRootPropName);\r\n        if (tmpAccountID.equals(accountID)) {\r\n            List<String> chatRooms = configService.getPropertyNamesByPrefix(accountRootPropName + \".chatRooms\", true);\r\n            for (String chatRoomPropName : chatRooms) {\r\n                String tmpChatRoomID = configService.getString(chatRoomPropName);\r\n                if (tmpChatRoomID.equals(chatRoomId)) {\r\n                    return chatRoomPropName;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.librec.recommender.cf.rating.LLORMARecommender.kernelSmoothing",
	"Comment": "given the similarity, it applies the given kernel.this is done either for all users or for all items.",
	"Method": "DenseVector kernelSmoothing(int size,int anchorIdx,int kernelType,double width,boolean isItemFeature){\r\n    DenseVector newFeatureVector = new VectorBasedDenseVector(size);\r\n    newFeatureVector.set(anchorIdx, 1.0);\r\n    for (int index = 0; index < size; index++) {\r\n        double sim;\r\n        if (isItemFeature) {\r\n            sim = getItemSimilarity(index, anchorIdx);\r\n        } else {\r\n            sim = getUserSimilarity(index, anchorIdx);\r\n        }\r\n        newFeatureVector.set(index, KernelSmoothing.kernelize(sim, width, kernelType));\r\n    }\r\n    return newFeatureVector;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.UIServiceImpl.addPluginComponentListener",
	"Comment": "adds the given plugincomponentlistener to the list of componentlisteners registered in this uiservice implementation.",
	"Method": "void addPluginComponentListener(PluginComponentListener listener){\r\n    synchronized (pluginComponentListeners) {\r\n        Iterator<WeakReference<PluginComponentListener>> i = pluginComponentListeners.iterator();\r\n        boolean contains = false;\r\n        while (i.hasNext()) {\r\n            PluginComponentListener l = i.next().get();\r\n            if (l == null)\r\n                i.remove();\r\n            else if (l.equals(listener))\r\n                contains = true;\r\n        }\r\n        if (!contains)\r\n            pluginComponentListeners.add(new WeakReference<PluginComponentListener>(listener));\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.globaldisplaydetails.GlobalStatusServiceImpl.publishStatusInternal",
	"Comment": "publish present status. we search for the highest value in thegiven interval.",
	"Method": "void publishStatusInternal(ProtocolProviderService protocolProvider,PresenceStatus status,boolean dueToRegistrationStateChanged){\r\n    OperationSetPresence presence = protocolProvider.getOperationSet(OperationSetPresence.class);\r\n    LoginManager loginManager = null;\r\n    UIService uiService = GlobalDisplayDetailsActivator.getUIService();\r\n    if (uiService != null) {\r\n        loginManager = uiService.getLoginManager();\r\n    }\r\n    RegistrationState registrationState = protocolProvider.getRegistrationState();\r\n    if (registrationState == RegistrationState.REGISTERED && presence != null && !presence.getPresenceStatus().equals(status)) {\r\n        if (status.isOnline()) {\r\n            new PublishPresenceStatusThread(protocolProvider, presence, status).start();\r\n        } else {\r\n            if (loginManager != null)\r\n                loginManager.setManuallyDisconnected(true);\r\n            LoginManager.logoff(protocolProvider);\r\n        }\r\n    } else if (registrationState != RegistrationState.REGISTERED && registrationState != RegistrationState.REGISTERING && registrationState != RegistrationState.AUTHENTICATING && status.isOnline()) {\r\n        if (dueToRegistrationStateChanged) {\r\n            logger.warn(\"Called publish status for provider in wrong state \" + \" provider: \" + protocolProvider + \" registrationState: \" + registrationState + \" status: \" + status);\r\n            return;\r\n        } else {\r\n            GlobalDisplayDetailsActivator.getUIService().getLoginManager().login(protocolProvider);\r\n        }\r\n    } else if (!status.isOnline() && !(registrationState == RegistrationState.UNREGISTERING)) {\r\n        if (loginManager != null)\r\n            loginManager.setManuallyDisconnected(true);\r\n        LoginManager.logoff(protocolProvider);\r\n    }\r\n    saveStatusInformation(protocolProvider, status.getStatusName());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.IceUdpTransportManager.getNbHarvesting",
	"Comment": "returns the number of harvesting time for the harvester given inparameter.",
	"Method": "int getNbHarvesting(int getNbHarvesting,String harvesterName){\r\n    return (iceAgent == null) ? 0 : iceAgent.getHarvestCount(harvesterName);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.propertieseditor.SearchField.filter",
	"Comment": "schedules a filter to be applied to configurationserviceproperties so that only the ones matching the specified filterwill be displayed.",
	"Method": "void filter(String filter){\r\n    synchronized (filterSyncRoot) {\r\n        this.filter = filter;\r\n        if (filterThread == null) {\r\n            filterThread = new Thread() {\r\n                @Override\r\n                public void run() {\r\n                    try {\r\n                        runInFilterThread();\r\n                    } finally {\r\n                        synchronized (filterSyncRoot) {\r\n                            if (Thread.currentThread().equals(filterThread)) {\r\n                                filterThread = null;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n            filterThread.setDaemon(true);\r\n            filterThread.setName(SearchField.class.getName() + \".filterThread\");\r\n            filterThread.start();\r\n        } else {\r\n            filterSyncRoot.notify();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.propertieseditor.SearchField.filter",
	"Comment": "schedules a filter to be applied to configurationserviceproperties so that only the ones matching the specified filterwill be displayed.",
	"Method": "void filter(String filter){\r\n    try {\r\n        runInFilterThread();\r\n    } finally {\r\n        synchronized (filterSyncRoot) {\r\n            if (Thread.currentThread().equals(filterThread)) {\r\n                filterThread = null;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.SingleCallInProgressPolicy.removeCallListener",
	"Comment": "unregisters a specific call from this policy in order to havethe rules of the latter no longer applied to the former.",
	"Method": "void removeCallListener(Call call){\r\n    if (logger.isTraceEnabled()) {\r\n        logger.trace(\"Remove call change listener.\");\r\n    }\r\n    call.removeCallChangeListener(listener);\r\n    synchronized (calls) {\r\n        calls.remove(call);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetServerStoredAccountInfoSipImpl.isDetailClassSupported",
	"Comment": "determines whether a detail class represents a detail supported by theunderlying implementation or not.",
	"Method": "boolean isDetailClassSupported(Class<? extends GenericDetail> detailClass){\r\n    return (ImageDetail.class.isAssignableFrom(detailClass) && isImageDetailSupported()) || DisplayNameDetail.class.isAssignableFrom(detailClass);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.ConnectionPanel.isAutogenerateResourceEnabled",
	"Comment": "is resource auto generate enabled. returns checkbox state.",
	"Method": "boolean isAutogenerateResourceEnabled(){\r\n    return autoGenerateResource.isSelected();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.msoutlook.MsOutlookAddrBookSourceContact.lock",
	"Comment": "locks this object before adding or removing several contact details.",
	"Method": "void lock(){\r\n    synchronized (this) {\r\n        locked = Boolean.TRUE;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.macosx.MacOSXAddrBookContactSourceService.createContactQuery",
	"Comment": "creates query that searches for sourcecontactswhich match a specific query pattern.",
	"Method": "ContactQuery createContactQuery(Pattern query){\r\n    if (latestQuery != null)\r\n        latestQuery.clear();\r\n    latestQuery = new MacOSXAddrBookContactQuery(this, query);\r\n    return latestQuery;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.simpleaccreg.Resources.getString",
	"Comment": "returns an internationalized string corresponding to the given key.",
	"Method": "String getString(String key){\r\n    return getResources().getI18NString(key);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.utils.InviteDialog.enterKeyTyped",
	"Comment": "called when the enter key was typed when this container was the focusedcontainer. performs the appropriate actions depending on the currentstate of the contained contact list.",
	"Method": "void enterKeyTyped(){\r\n    List<UIContact> selectedContacts = srcContactList.getSelectedContacts();\r\n    if (selectedContacts == null)\r\n        return;\r\n    moveContactsFromLeftToRight(selectedContacts.iterator());\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.provisioning.ProvisioningActivator.getCredentialsStorageService",
	"Comment": "returns a reference to a credentialsstorageservice implementationcurrently registered in the bundle context or null if no suchimplementation was found.",
	"Method": "CredentialsStorageService getCredentialsStorageService(){\r\n    if (credentialsService == null) {\r\n        ServiceReference credentialsReference = bundleContext.getServiceReference(CredentialsStorageService.class.getName());\r\n        credentialsService = (CredentialsStorageService) bundleContext.getService(credentialsReference);\r\n    }\r\n    return credentialsService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.JabberAccountRegistrationWizard.getPageImage",
	"Comment": "implements the accountregistrationwizard.getpageimage method.returns the image used to decorate the wizard page",
	"Method": "byte[] getPageImage(){\r\n    return Resources.getImage(Resources.PAGE_IMAGE);\r\n}"
}, {
	"Path": "org.eclipse.jetty.xml.XmlConfiguration.getProperties",
	"Comment": "get the map of properties used by the property xml elementto parameterise configuration.",
	"Method": "Map<String, String> getProperties(){\r\n    return _propertyMap;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockContactGroup.getPersistentData",
	"Comment": "returns null as no persistent data is required and the contact address issufficient for restoring the contact.",
	"Method": "String getPersistentData(){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.RawUdpTransportManager.createTransport",
	"Comment": "creates a raw udp transport element according to a specificstreamconnector.",
	"Method": "PacketExtension createTransport(String media,RawUdpTransportPacketExtension createTransport,MediaType mediaType,StreamConnector connector){\r\n    RawUdpTransportPacketExtension ourTransport = new RawUdpTransportPacketExtension();\r\n    int generation = getCurrentGeneration();\r\n    CandidatePacketExtension rtpCand = new CandidatePacketExtension();\r\n    rtpCand.setComponent(CandidatePacketExtension.RTP_COMPONENT_ID);\r\n    rtpCand.setGeneration(generation);\r\n    rtpCand.setID(getNextID());\r\n    rtpCand.setType(CandidateType.host);\r\n    DatagramSocket dataSocket = connector.getDataSocket();\r\n    rtpCand.setIP(dataSocket.getLocalAddress().getHostAddress());\r\n    rtpCand.setPort(dataSocket.getLocalPort());\r\n    ourTransport.addCandidate(rtpCand);\r\n    CandidatePacketExtension rtcpCand = new CandidatePacketExtension();\r\n    rtcpCand.setComponent(CandidatePacketExtension.RTCP_COMPONENT_ID);\r\n    rtcpCand.setGeneration(generation);\r\n    rtcpCand.setID(getNextID());\r\n    rtcpCand.setType(CandidateType.host);\r\n    DatagramSocket controlSocket = connector.getControlSocket();\r\n    rtcpCand.setIP(controlSocket.getLocalAddress().getHostAddress());\r\n    rtcpCand.setPort(controlSocket.getLocalPort());\r\n    ourTransport.addCandidate(rtcpCand);\r\n    return ourTransport;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.msoutlook.calendar.CalendarServiceImpl.addCalendarItem",
	"Comment": "parses the property values of calendar item and createscalendaritemtimertask instance for the calendar item.",
	"Method": "void addCalendarItem(Object[] props,String id){\r\n    Date startTime = null, endTime = null;\r\n    BusyStatusEnum status = BusyStatusEnum.FREE;\r\n    ResponseStatus responseStatus = ResponseStatus.respNone;\r\n    boolean isRecurring = false;\r\n    byte[] recurringData = null;\r\n    for (int i = 0; i < props.length; i++) {\r\n        if (props[i] == null)\r\n            continue;\r\n        MAPICalendarProperties propertyName = MAPICalendarProperties.getByOrderId(i);\r\n        switch(propertyName) {\r\n            case PidLidAppointmentStartWhole:\r\n                try {\r\n                    long time = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss Z\").parse(props[i] + \" UTC\").getTime();\r\n                    startTime = new Date(time);\r\n                } catch (ParseException e) {\r\n                    logger.error(\"Cannot parse date string: \" + props[i]);\r\n                    return;\r\n                }\r\n                break;\r\n            case PidLidAppointmentEndWhole:\r\n                try {\r\n                    long time = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss Z\").parse(props[i] + \" UTC\").getTime();\r\n                    endTime = new Date(time);\r\n                } catch (ParseException e) {\r\n                    logger.error(\"Cannot parse date string: \" + props[i]);\r\n                    return;\r\n                }\r\n                break;\r\n            case PidLidBusyStatus:\r\n                status = BusyStatusEnum.getFromLong((Long) props[i]);\r\n                break;\r\n            case PidLidRecurring:\r\n                isRecurring = (Boolean) props[i];\r\n                break;\r\n            case PidLidAppointmentRecur:\r\n                recurringData = ((byte[]) props[i]);\r\n                break;\r\n            case PidLidResponseStatus:\r\n                responseStatus = ResponseStatus.getFromLong((Long) props[i]);\r\n                break;\r\n        }\r\n    }\r\n    if (responseStatus != ResponseStatus.respNone && responseStatus != ResponseStatus.respAccepted && responseStatus != ResponseStatus.respOrganized)\r\n        return;\r\n    if (status == BusyStatusEnum.FREE || startTime == null || endTime == null)\r\n        return;\r\n    Date currentTime = new Date();\r\n    boolean executeNow = false;\r\n    if (startTime.before(currentTime) || startTime.equals(currentTime))\r\n        executeNow = true;\r\n    CalendarItemTimerTask task = null;\r\n    if (recurringData != null) {\r\n        task = new CalendarItemTimerTask(status, startTime, endTime, id, executeNow, null);\r\n        try {\r\n            RecurringPattern pattern = new RecurringPattern(recurringData, task);\r\n            task.setPattern(pattern);\r\n        } catch (IndexOutOfBoundsException e) {\r\n            logger.error(\"Error parsing reccuring pattern.\" + e.getMessage(), e);\r\n            logger.error(\"Reccuring data:\\n\" + bytesToHex(recurringData));\r\n            return;\r\n        }\r\n    }\r\n    if (endTime.before(currentTime) || endTime.equals(currentTime)) {\r\n        if (isRecurring) {\r\n            task = task.getPattern().next(startTime, endTime);\r\n        } else\r\n            return;\r\n    }\r\n    if (task == null)\r\n        task = new CalendarItemTimerTask(status, startTime, endTime, id, executeNow, null);\r\n    task.scheduleTasks();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.neomedia.codec.video.h264.ConfigurationPanel.setSelectedNameValuePair",
	"Comment": "sets the selected item in a specific jcombobox populated withnamevaluepairs to the one which has a specific value.",
	"Method": "void setSelectedNameValuePair(JComboBox comboBox,String value){\r\n    for (int i = 0, count = comboBox.getItemCount(); i < count; i++) {\r\n        NameValuePair nameValuePair = (NameValuePair) comboBox.getItemAt(i);\r\n        if (nameValuePair.value.equals(value)) {\r\n            comboBox.setSelectedIndex(i);\r\n            break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageHistoryServiceImpl.findLast",
	"Comment": "returns the supplied number of recent messages exchangedin the supplied chat room",
	"Method": "Collection<EventObject> findLast(MetaContact contact,int count,Collection<EventObject> findLast,ChatRoom room,int count){\r\n    LinkedList<EventObject> result = new LinkedList<EventObject>();\r\n    try {\r\n        HistoryReader reader = this.getHistoryForMultiChat(room).getReader();\r\n        Iterator<HistoryRecord> recs = reader.findLast(count);\r\n        while (recs.hasNext()) {\r\n            result.add(convertHistoryRecordToMessageEvent(recs.next(), room));\r\n        }\r\n    } catch (IOException e) {\r\n        logger.error(\"Could not read history\", e);\r\n    }\r\n    Collections.sort(result, new ChatRoomMessageEventComparator<EventObject>());\r\n    int startIndex = result.size() - count;\r\n    if (startIndex < 0)\r\n        startIndex = 0;\r\n    return result.subList(startIndex, result.size());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.filetransfer.SendFileConversationComponent.setProtocolFileTransfer",
	"Comment": "sets the filetransfer object received from the protocol andcorresponding to the file transfer process associated with this panel.",
	"Method": "void setProtocolFileTransfer(FileTransfer fileTransfer){\r\n    this.setFileTransfer(fileTransfer, file.length());\r\n    fileTransfer.addStatusListener(this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.launchutils.LaunchArgHandler.handleVersionArg",
	"Comment": "prints the name and the version of this application. this method uses theversion.properties file which is created by ant during the build process.if this file does not exist the method would print a default name andversion string.",
	"Method": "void handleVersionArg(){\r\n    String name = getApplicationName();\r\n    String version = getVersion();\r\n    if (name == null || name.trim().length() == 0) {\r\n        name = \"Jitsi\";\r\n    }\r\n    if (version == null || version.trim().length() == 0) {\r\n        version = \"build.by.SVN\";\r\n    }\r\n    System.out.println(name + \" \" + version);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.utils.Constants.isSpecialChar",
	"Comment": "checks if the given char is in the list of application special chars.",
	"Method": "boolean isSpecialChar(int charCode){\r\n    for (int specialChar : specialChars) {\r\n        if (specialChar == charCode)\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.provdisc.mdns.MDNSProvisioningDiscover.removeDiscoveryListener",
	"Comment": "add a listener that will be notified when thediscoverprovisioningurl has finished.",
	"Method": "void removeDiscoveryListener(DiscoveryListener listener){\r\n    if (listeners.contains(listener)) {\r\n        listeners.remove(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.FramedImageWithMenu.popupMenuWillBecomeInvisible",
	"Comment": "this method is called before the popup menu becomes invisiblenote that a jpopupmenu can become invisible any time",
	"Method": "void popupMenuWillBecomeInvisible(PopupMenuEvent e){\r\n    this.drawOverlay = false;\r\n    this.repaint();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.notification.Notification.getActions",
	"Comment": "returns the set of actions registered for this event notification.",
	"Method": "Map<String, NotificationAction> getActions(){\r\n    return actionsTable;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.TestOperationSetFileTransferImpl.enableTestReceiverDecline",
	"Comment": "disabled cause when receiver declines a canceled event is fired.but refused status changed must be fired.its canceled cause its the same event comming from the stackas when while transfering one of the parties cancel the transfer.",
	"Method": "boolean enableTestReceiverDecline(){\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.OutgoingMessageStyle.createIndicatorStyle",
	"Comment": "creates the style of the indicator pointing to the avatar image.",
	"Method": "String createIndicatorStyle(){\r\n    return \"style =\\\"\" + \"width:9px;\" + \" height:19px;\" + \" background-image: url('\" + OUTGOING_MESSAGE_INDICATOR_PATH + \"');\" + \" background-repeat: no-repeat;\" + \" background-position: top left;\" + \"\\\"\";\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.SourceGroupPacketExtension.copy",
	"Comment": "returns deep copy of this sourcegrouppacketextension instance.",
	"Method": "SourceGroupPacketExtension copy(){\r\n    SourceGroupPacketExtension copy = AbstractPacketExtension.clone(this);\r\n    copy.setSemantics(getSemantics());\r\n    List<SourcePacketExtension> sources = getSources();\r\n    List<SourcePacketExtension> sourcesCopy = new ArrayList<SourcePacketExtension>(sources.size());\r\n    for (SourcePacketExtension source : sources) {\r\n        sourcesCopy.add(source.copy());\r\n    }\r\n    copy.addSources(sourcesCopy);\r\n    return copy;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ContactListPane.pluginComponentRemoved",
	"Comment": "removes the plugin component given by event if previously addedin this panel.",
	"Method": "void pluginComponentRemoved(PluginComponentEvent event){\r\n    PluginComponentFactory factory = event.getPluginComponentFactory();\r\n    if (!factory.getContainer().equals(Container.CONTAINER_CONTACT_LIST))\r\n        return;\r\n    this.remove((Component) factory.getPluginComponentInstance(this).getComponent());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.MetaContactChatTransport.getParentChatSession",
	"Comment": "returns the parent session of this chat transport. a chatsessioncould contain more than one transports.",
	"Method": "ChatSession getParentChatSession(){\r\n    return parentChatSession;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.sipaccregwizz.SIPAccountRegistrationWizard.getIcon",
	"Comment": "implements the accountregistrationwizard.geticon method.returns the icon to be used for this wizard.",
	"Method": "byte[] getIcon(){\r\n    return Resources.getImage(Resources.SIP_LOGO);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.filehistory.FileHistoryServiceImpl.findByPeriod",
	"Comment": "returns all the file transfers made between the given datesand having the given keywords in the filename",
	"Method": "Collection<FileRecord> findByPeriod(MetaContact contact,Date startDate,Date endDate,String[] keywords,Collection<FileRecord> findByPeriod,MetaContact contact,Date startDate,Date endDate,String[] keywords,boolean caseSensitive,Collection<FileRecord> findByPeriod,MetaContact contact,Date startDate,Date endDate){\r\n    TreeSet<FileRecord> result = new TreeSet<FileRecord>(new FileRecordComparator());\r\n    Map<Contact, HistoryReader> readers = getHistoryReaders(contact);\r\n    for (Map.Entry<Contact, HistoryReader> readerEntry : readers.entrySet()) {\r\n        Contact c = readerEntry.getKey();\r\n        HistoryReader reader = readerEntry.getValue();\r\n        Iterator<HistoryRecord> recs = reader.findByPeriod(startDate, endDate);\r\n        while (recs.hasNext()) {\r\n            result.add(createFileRecordFromHistoryRecord(recs.next(), c));\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.securityconfig.masterpassword.SavedPasswordsPanel.showSavedPasswordsDialog",
	"Comment": "displays a master password prompt to the user, verifies the enteredpassword and then shows the savedpasswordsdialog.",
	"Method": "void showSavedPasswordsDialog(){\r\n    String master;\r\n    boolean correct = true;\r\n    MasterPasswordInputService masterPasswordInputService = SecurityConfigActivator.getMasterPasswordInputService();\r\n    if (masterPasswordInputService == null) {\r\n        logger.error(\"Missing MasterPasswordInputService to show input dialog\");\r\n        return;\r\n    }\r\n    do {\r\n        master = masterPasswordInputService.showInputDialog(correct);\r\n        if (master == null)\r\n            return;\r\n        correct = (master.length() != 0) && credentialsStorageService.verifyMasterPassword(master);\r\n    } while (!correct);\r\n    SavedPasswordsDialog.getInstance().setVisible(true);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.security.CredentialsCache.remove",
	"Comment": "returns the credentials corresponding to the specified realmor null if none could be found and removes the entry from the cache.",
	"Method": "CredentialsCacheEntry remove(String realm){\r\n    return this.authenticatedRealms.remove(realm);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockContactGroup.addSubgroup",
	"Comment": "adds the specified contact group to the contained by this group.",
	"Method": "void addSubgroup(MockContactGroup subgroup){\r\n    this.subGroups.add(subgroup);\r\n    subgroup.setParentGroup(this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWindowManager.isChatOpenedForDescriptor",
	"Comment": "determines whether there is an opened chatpanel for a specificchat descriptor.",
	"Method": "boolean isChatOpenedForDescriptor(Object descriptor){\r\n    synchronized (chatSyncRoot) {\r\n        ChatPanel chatPanel = findChatPanelForDescriptor(descriptor);\r\n        return ((chatPanel != null) && chatPanel.isShown());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.IceConfigPanel.removeAllJingleNodes",
	"Comment": "remove all jinglenodes to the list of additional jingle nodes.",
	"Method": "void removeAllJingleNodes(){\r\n    int i = jnTableModel.getRowCount();\r\n    while (i != 0) {\r\n        jnTableModel.removeRow(0);\r\n        i--;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.UnknownContactPanel.startCall",
	"Comment": "clicks the call contact button in order to call the unknown contact.",
	"Method": "void startCall(){\r\n    callButton.doClick();\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.server.ab.AbstractABCase.copyOf",
	"Comment": "make a copy of a byte buffer.this is important in some tests, as the underlying byte buffer contained in a frame can be modified throughmasking and make it difficult to compare the results in the fuzzer.",
	"Method": "ByteBuffer copyOf(byte[] payload,ByteBuffer copyOf,ByteBuffer payload){\r\n    ByteBuffer copy = ByteBuffer.allocate(payload.remaining());\r\n    BufferUtil.clearToFill(copy);\r\n    BufferUtil.put(payload, copy);\r\n    BufferUtil.flipToFlush(copy, 0);\r\n    return copy;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockChatRoom.getMembersCount",
	"Comment": "returns the number of participants that are currently in this chat room.",
	"Method": "int getMembersCount(){\r\n    return members.size();\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.TestOperationSetBasicInstantMessaging.thenTestSendMessage",
	"Comment": "send an instant message from the tester agent and assert reception bythe tested implementation",
	"Method": "void thenTestSendMessage(){\r\n    logger.debug(\"Printing Server Stored list to see if message fails are contacts in each other lists\");\r\n    ContactGroup rootGroup1 = ((OperationSetPersistentPresence) opSetPresence1).getServerStoredContactListRoot();\r\n    logger.debug(\"=========== Server Stored Contact List 1 =================\");\r\n    logger.debug(\"rootGroup=\" + rootGroup1.getGroupName() + \" rootGroup.childContacts=\" + rootGroup1.countContacts() + \"rootGroup.childGroups=\" + rootGroup1.countSubgroups() + \"Printing rootGroupContents=\\n\" + rootGroup1.toString());\r\n    ContactGroup rootGroup2 = ((OperationSetPersistentPresence) opSetPresence2).getServerStoredContactListRoot();\r\n    logger.debug(\"=========== Server Stored Contact List 2 =================\");\r\n    logger.debug(\"rootGroup=\" + rootGroup2.getGroupName() + \" rootGroup.childContacts=\" + rootGroup2.countContacts() + \"rootGroup.childGroups=\" + rootGroup2.countSubgroups() + \"Printing rootGroupContents=\\n\" + rootGroup2.toString());\r\n    String body = \"This is an IM coming from the tested implementation\" + \" on \" + new Date().toString();\r\n    net.java.sip.communicator.service.protocol.Message msg = opSetBasicIM1.createMessage(body);\r\n    ImEventCollector imEvtCollector1 = new ImEventCollector();\r\n    opSetBasicIM1.addMessageListener(imEvtCollector1);\r\n    ImEventCollector imEvtCollector2 = new ImEventCollector();\r\n    opSetBasicIM2.addMessageListener(imEvtCollector2);\r\n    Contact testerAgentContact = opSetPresence1.findContactByID(fixture.userID2);\r\n    opSetBasicIM1.sendInstantMessage(testerAgentContact, msg);\r\n    imEvtCollector1.waitForEvent(10000);\r\n    imEvtCollector2.waitForEvent(10000);\r\n    opSetBasicIM1.removeMessageListener(imEvtCollector1);\r\n    opSetBasicIM2.removeMessageListener(imEvtCollector2);\r\n    assertTrue(\"No events delivered when sending a message\", imEvtCollector1.collectedEvents.size() > 0);\r\n    assertTrue(\"Received evt was not an instance of \" + MessageDeliveredEvent.class.getName(), imEvtCollector1.collectedEvents.get(0) instanceof MessageDeliveredEvent);\r\n    MessageDeliveredEvent evt = (MessageDeliveredEvent) imEvtCollector1.collectedEvents.get(0);\r\n    assertEquals(\"message destination \", evt.getDestinationContact().getAddress(), fixture.userID2);\r\n    assertSame(\"source message\", msg, evt.getSourceMessage());\r\n    assertTrue(\"No messages received by the tester agent\", imEvtCollector2.collectedEvents.size() > 0);\r\n    assertFalse(\"Message was unable to deliver !\", imEvtCollector2.collectedEvents.get(0) instanceof MessageDeliveryFailedEvent);\r\n    String receivedBody = ((MessageReceivedEvent) imEvtCollector2.collectedEvents.get(0)).getSourceMessage().getContent();\r\n    assertEquals(\"received message body\", msg.getContent(), receivedBody);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetServerStoredContactInfoJabberImpl.isPrivateMessagingContact",
	"Comment": "checks whether a contact is a private messaging contact for chat rooms.",
	"Method": "boolean isPrivateMessagingContact(Contact contact){\r\n    if (contact instanceof VolatileContactJabberImpl)\r\n        return ((VolatileContactJabberImpl) contact).isPrivateMessagingContact();\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.msoutlook.calendar.RecurringPattern.dateOutOfRange",
	"Comment": "checks whether the given date is in the recurrent pattern range or not",
	"Method": "boolean dateOutOfRange(Date date){\r\n    Calendar cal = Calendar.getInstance();\r\n    cal.setTime(date);\r\n    cal.set(Calendar.HOUR_OF_DAY, 0);\r\n    cal.set(Calendar.MINUTE, 0);\r\n    cal.set(Calendar.SECOND, 0);\r\n    if ((endType != 0x00002023) && (endType != 0xFFFFFFFF) && cal.getTime().after(windowsTimeToDateObject(this.endDate))) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.AuthenticationWindow.getAuthenticationWindowIcon",
	"Comment": "returns the icon corresponding to the given protocolprovider.",
	"Method": "ImageIcon getAuthenticationWindowIcon(ProtocolProviderService protocolProvider){\r\n    Image image = null;\r\n    if (protocolProvider != null) {\r\n        ProtocolIcon protocolIcon = protocolProvider.getProtocolIcon();\r\n        if (protocolIcon.isSizeSupported(ProtocolIcon.ICON_SIZE_64x64))\r\n            image = ImageUtils.getBytesInImage(protocolIcon.getIcon(ProtocolIcon.ICON_SIZE_64x64));\r\n        else if (protocolIcon.isSizeSupported(ProtocolIcon.ICON_SIZE_48x48))\r\n            image = ImageUtils.getBytesInImage(protocolIcon.getIcon(ProtocolIcon.ICON_SIZE_48x48));\r\n    }\r\n    if (image != null)\r\n        return new ImageIcon(image);\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler.getICECandidateExtendedType",
	"Comment": "returns the extended type of the candidate selected if this transportmanager is using ice.",
	"Method": "String getICECandidateExtendedType(String streamName){\r\n    TransportManager<?> transportManager = queryTransportManager();\r\n    return (transportManager == null) ? null : transportManager.getICECandidateExtendedType(streamName);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractCallPeer.fireCallPeerSecurityTimeoutEvent",
	"Comment": "constructs a callpeersecuritystatusevent using this call peer assource, setting it to be of type eventtype and the correspondingoldvalue and newvalue.",
	"Method": "void fireCallPeerSecurityTimeoutEvent(CallPeerSecurityTimeoutEvent evt){\r\n    lastSecurityEvent = evt;\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Dispatching a CallPeerSecurityStatusEvent event to \" + callPeerSecurityListeners.size() + \" listeners. event is: \" + evt.toString());\r\n    List<CallPeerSecurityListener> listeners = null;\r\n    synchronized (callPeerSecurityListeners) {\r\n        listeners = new ArrayList<CallPeerSecurityListener>(callPeerSecurityListeners);\r\n    }\r\n    for (CallPeerSecurityListener listener : listeners) {\r\n        listener.securityTimeout(evt);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.ircaccregwizz.IrcAccountRegistrationWizard.getRegistration",
	"Comment": "returns the registration object, which will store all the data throughthe wizard.",
	"Method": "IrcAccountRegistration getRegistration(){\r\n    return registration;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractCall.getCallPeerCount",
	"Comment": "returns the number of peers currently associated with this call.",
	"Method": "int getCallPeerCount(){\r\n    return getCallPeerList().size();\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.popupmessagehandler.TestPopupMessageHandler.testNotificationHandling",
	"Comment": "we will fire a notification then see if it was handled by the right handlerwhich received the right message.",
	"Method": "void testNotificationHandling(){\r\n    serviceReference = bc.getServiceReference(NotificationService.class.getName());\r\n    notificationService = (NotificationService) bc.getService(serviceReference);\r\n    notificationService.fireNotification(NotificationAction.ACTION_POPUP_MESSAGE, messageStart, messageStart, null);\r\n}"
}, {
	"Path": "net.librec.data.model.TextDataModelTestCase.getTrainRatio",
	"Comment": "calculate the ratio of training set of a specified datamodel object",
	"Method": "double getTrainRatio(DataModel dataModel){\r\n    double trainSize = getTrainSize(dataModel);\r\n    double totalSize = getDataSize(dataModel);\r\n    return trainSize / totalSize;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.thumbnail.ThumbnailElement.createCid",
	"Comment": "creates the cid attrubte value for the given contactjabberaddressand thumbnaildata.",
	"Method": "String createCid(String serverAddress,byte[] thumbnailData){\r\n    try {\r\n        return \"sha1+\" + Sha1Crypto.encode(thumbnailData) + \"@\" + serverAddress;\r\n    } catch (NoSuchAlgorithmException e) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Failed to encode the thumbnail in SHA-1.\", e);\r\n    } catch (UnsupportedEncodingException e) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Failed to encode the thumbnail in SHA-1.\", e);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.gibberishaccregwizz.GibberishAccountRegistrationWizard.getUserNameExample",
	"Comment": "returns an example string, which should indicate to the user how theuser name should look like.",
	"Method": "String getUserNameExample(){\r\n    return FirstWizardPage.USER_NAME_EXAMPLE;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.GroupNode.getContacts",
	"Comment": "returns a collection of all direct children of this groupnode.",
	"Method": "Collection<ContactNode> getContacts(){\r\n    if (children != null)\r\n        return Collections.unmodifiableCollection(children);\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetPersistentPresenceIcqImpl.unsubscribe",
	"Comment": "removes a subscription for the presence status of the specified contact.",
	"Method": "void unsubscribe(Contact contact){\r\n    assertConnected();\r\n    if (!(contact instanceof ContactIcqImpl))\r\n        throw new IllegalArgumentException(\"Argument is not an icq contact (contact=\" + contact + \")\");\r\n    ContactIcqImpl contactIcqImpl = (ContactIcqImpl) contact;\r\n    ContactGroupIcqImpl contactGroup = ssContactList.findContactGroup(contactIcqImpl);\r\n    if (contactGroup == null)\r\n        throw new IllegalArgumentException(\"The specified contact was not found on the local \" + \"contact/subscription list: \" + contact);\r\n    if (!contactIcqImpl.isPersistent()) {\r\n        contactGroup.removeContact(contactIcqImpl);\r\n        fireSubscriptionEvent(contactIcqImpl, contactGroup, SubscriptionEvent.SUBSCRIPTION_REMOVED);\r\n        return;\r\n    }\r\n    if (logger.isTraceEnabled())\r\n        logger.trace(\"Going to remove contact from ss-list : \" + contact);\r\n    if (!contactGroup.isPersistent() && contactIcqImpl.getJoustSimBuddy().isAwaitingAuthorization()) {\r\n        ContactGroupIcqImpl origParent = ssContactList.findGroup(contactIcqImpl.getJoustSimBuddy());\r\n        if (origParent != null) {\r\n            origParent.getJoustSimSourceGroup().deleteBuddy(contactIcqImpl.getJoustSimBuddy());\r\n        }\r\n    } else {\r\n        MutableGroup joustSimContactGroup = contactGroup.getJoustSimSourceGroup();\r\n        joustSimContactGroup.deleteBuddy(contactIcqImpl.getJoustSimBuddy());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWindowManager.fireChatClosed",
	"Comment": "notifies the chatlisteners registered with this instance thata specific chat has been closed.",
	"Method": "void fireChatClosed(Chat chat){\r\n    List<ChatListener> listeners;\r\n    synchronized (chatListeners) {\r\n        listeners = new ArrayList<ChatListener>(chatListeners);\r\n    }\r\n    for (ChatListener listener : listeners) listener.chatClosed(chat);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapFactoryImpl.createServer",
	"Comment": "required by ldapfactory interface.creates an ldapdirectory based on the provided settings.this method will not modify the settingsor save a reference to it, but may save a clone.",
	"Method": "LdapDirectory createServer(LdapDirectorySettings settings){\r\n    return new LdapDirectoryImpl(settings);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.utils.ImageLoader.getImageLoaderService",
	"Comment": "returns the imageloaderservice instance, if missing query osgi for it.",
	"Method": "ImageLoaderServiceImpl getImageLoaderService(){\r\n    if (imageLoaderService == null) {\r\n        imageLoaderService = (ImageLoaderServiceImpl) ServiceUtils.getService(GuiActivator.bundleContext, ImageLoaderService.class);\r\n    }\r\n    return imageLoaderService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ContactGroupIcqImpl.initNameCopy",
	"Comment": "sets the name copy field that we use as a means of detecting changes inthe group name.",
	"Method": "void initNameCopy(){\r\n    this.nameCopy = getGroupName();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomMemberIrcImpl.getContact",
	"Comment": "get the corresponding contact for a chat room member if it exists.",
	"Method": "Contact getContact(){\r\n    return this.parentProvider.getPersistentPresence().findContactByID(this.contactID);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.WhiteboardParticipantEvent.toString",
	"Comment": "returns a string representation of thiswhiteboardparticipantevent.",
	"Method": "String toString(){\r\n    return \"WhiteboardParticipantEvent: ID=\" + getEventID() + \" source participant=\" + getSourceWhiteboardParticipant() + \" source whiteboard=\" + getSourceWhiteboard();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommTextField.replaceSelection",
	"Comment": "remove the default text when inserting a new section, e.g. via drag anddrop.",
	"Method": "void replaceSelection(String content){\r\n    if (super.getText().equals(defaultText)) {\r\n        clearDefaultText();\r\n    }\r\n    super.replaceSelection(content);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWindow.setCurrentChat",
	"Comment": "selects the chat tab which corresponds to the given metacontact.",
	"Method": "void setCurrentChat(ChatPanel chatPanel){\r\n    ChatSession chatSession = chatPanel.getChatSession();\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Set current chat panel to: \" + chatSession.getChatName());\r\n    if (getChatTabCount() > 0)\r\n        this.chatTabbedPane.setSelectedComponent(chatPanel);\r\n    this.setTitle(chatSession.getChatName());\r\n    this.setChatContactPhoto(chatSession);\r\n    this.mainToolBar.getSmileysBox().setChat(chatPanel);\r\n    chatPanel.requestFocusInWriteArea();\r\n    for (ChatChangeListener l : chatChangeListeners) l.chatChanged(chatPanel);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ContactListTransferHandler.canImport",
	"Comment": "indicates whether a component will accept an import of the givenset of data flavors prior to actually attempting to import it. we returntrue to indicate that the transfer with at least one of thegiven flavors would work and false to reject the transfer.",
	"Method": "boolean canImport(JComponent comp,DataFlavor flavor){\r\n    if (!(transferredObject instanceof ContactNode))\r\n        return false;\r\n    Object selectedObject = (((ContactNode) transferredObject).getContactDescriptor()).getDescriptor();\r\n    if (selectedObject instanceof MetaContact) {\r\n        MetaContact metaContact = (MetaContact) selectedObject;\r\n        Iterator<Contact> contacts = metaContact.getContacts();\r\n        while (contacts.hasNext()) {\r\n            Contact contact = contacts.next();\r\n            if (contact.getPersistableAddress() == null) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    for (int i = 0, n = flavor.length; i < n; i++) {\r\n        if (flavor[i].equals(uiContactDataFlavor)) {\r\n            return true;\r\n        }\r\n    }\r\n    return super.canImport(comp, flavor);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.aimaccregwizz.FirstWizardPage.getWizardForm",
	"Comment": "implements the wizardpage.getwizardform to return thispanel.",
	"Method": "Object getWizardForm(){\r\n    initAdvancedPanel();\r\n    return this;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.configuration.JdbcConfigService.checkConnection",
	"Comment": "verifies that the connection to the database and all prepared statementare valid.",
	"Method": "void checkConnection(){\r\n    if (this.connection != null && this.connection.isValid(1)) {\r\n        try {\r\n            PreparedStatement st = this.connection.prepareStatement(\"SELECT 1 FROM INFORMATION_SCHEMA.SYSTEM_USERS\");\r\n            if (st.execute()) {\r\n                return;\r\n            }\r\n        } catch (Exception e) {\r\n            this.connection = null;\r\n            logger.error(\"Database connection is invalid, recreating\", e);\r\n        }\r\n    }\r\n    String filename;\r\n    try {\r\n        File f = fas.getPrivatePersistentFile(\"props.hsql\", FileCategory.PROFILE);\r\n        filename = f.getAbsolutePath();\r\n    } catch (Exception e) {\r\n        throw new SQLException(e);\r\n    }\r\n    this.connection = DriverManager.getConnection(\"jdbc:hsqldb:file:\" + filename + \";shutdown=true;hsqldb.write_delay=false;\" + \"hsqldb.write_delay_millis=0\");\r\n    Statement st = this.connection.createStatement();\r\n    st.executeUpdate(\"CREATE TABLE IF NOT EXISTS Props (\" + \"k LONGVARCHAR UNIQUE, v LONGVARCHAR\" + \")\");\r\n    this.selectExact = this.connection.prepareStatement(\"SELECT v FROM Props WHERE k=?\");\r\n    this.selectLike = this.connection.prepareStatement(\"SELECT k, v FROM Props WHERE k LIKE ?\");\r\n    this.selectAll = this.connection.prepareStatement(\"SELECT k, v FROM Props\");\r\n    this.insertOrUpdate = this.connection.prepareStatement(\"MERGE INTO Props\" + \" USING (VALUES(?,?)) AS i(k,v) ON Props.k = i.k\" + \" WHEN MATCHED THEN UPDATE SET Props.v = i.v\" + \" WHEN NOT MATCHED THEN INSERT (k, v) VALUES (i.k, i.v)\");\r\n    this.delete = this.connection.prepareStatement(\"DELETE FROM Props WHERE k=?\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.collection.DynamicDifferenceSet.containsAll",
	"Comment": "check if all provided elements are contained in the difference set of themoment.",
	"Method": "boolean containsAll(Collection<?> c){\r\n    return calculate().containsAll(c);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.globalproxyconfig.GlobalProxyPluginActivator.initProperties",
	"Comment": "init system properties that corresponds to proxy settings.",
	"Method": "void initProperties(){\r\n    String globalProxyType = getConfigurationService().getString(ProxyInfo.CONNECTION_PROXY_TYPE_PROPERTY_NAME);\r\n    if (globalProxyType != null && !globalProxyType.equals(ProxyInfo.ProxyType.NONE.name())) {\r\n        String globalProxyAddress = getConfigurationService().getString(ProxyInfo.CONNECTION_PROXY_ADDRESS_PROPERTY_NAME);\r\n        if (globalProxyAddress == null || globalProxyAddress.length() <= 0) {\r\n            return;\r\n        }\r\n        String globalProxyPortStr = getConfigurationService().getString(ProxyInfo.CONNECTION_PROXY_PORT_PROPERTY_NAME);\r\n        int globalProxyPort = -1;\r\n        try {\r\n            globalProxyPort = Integer.parseInt(globalProxyPortStr);\r\n        } catch (NumberFormatException ex) {\r\n        }\r\n        String globalProxyUsername = getConfigurationService().getString(ProxyInfo.CONNECTION_PROXY_USERNAME_PROPERTY_NAME);\r\n        String globalProxyPassword = getConfigurationService().getString(ProxyInfo.CONNECTION_PROXY_PASSWORD_PROPERTY_NAME);\r\n        String type = null;\r\n        if (globalProxyType.equals(ProxyInfo.ProxyType.HTTP.name())) {\r\n            type = \"HTTP\";\r\n            System.setProperty(\"http.proxyHost\", globalProxyAddress);\r\n            if (globalProxyPortStr != null) {\r\n                System.setProperty(\"http.proxyPort\", globalProxyPortStr);\r\n            }\r\n            System.setProperty(\"proxySet\", \"true\");\r\n        } else if (globalProxyType.equals(ProxyInfo.ProxyType.SOCKS4.name()) || globalProxyType.equals(ProxyInfo.ProxyType.SOCKS5.name())) {\r\n            type = \"SOCKS\";\r\n            System.setProperty(\"socksProxyHost\", globalProxyAddress);\r\n            if (globalProxyPortStr != null) {\r\n                System.setProperty(\"socksProxyPort\", globalProxyPortStr);\r\n            }\r\n            System.setProperty(\"socksProxySet\", \"true\");\r\n        }\r\n        Authenticator.setDefault(new AuthenticatorImpl(globalProxyAddress, globalProxyPort, type, globalProxyUsername, globalProxyPassword));\r\n    } else\r\n        Authenticator.setDefault(null);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.history.HistoryReaderImpl.findByKeyword",
	"Comment": "searches the history for all records containing the keyword.",
	"Method": "QueryResultSet<HistoryRecord> findByKeyword(String keyword,String field,QueryResultSet<HistoryRecord> findByKeyword,String keyword,String field,boolean caseSensitive){\r\n    return findByKeywords(new String[] { keyword }, field, caseSensitive);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.ConferenceDescription.supportsTransport",
	"Comment": "checks whether transport is supported by thisconferencedescription. if the set of transports for thisconferencedescription is empty, always returns true.",
	"Method": "boolean supportsTransport(String transport){\r\n    if (transports.isEmpty())\r\n        return true;\r\n    return transports.contains(transport);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWritePanel.saveDefaultFontConfiguration",
	"Comment": "saves the given font configuration as default, thus making it the defaultconfiguration for all chats.",
	"Method": "void saveDefaultFontConfiguration(String fontFamily,int fontSize,boolean isBold,boolean isItalic,boolean isUnderline,Color color){\r\n    ConfigurationUtils.setChatDefaultFontFamily(fontFamily);\r\n    ConfigurationUtils.setChatDefaultFontSize(fontSize);\r\n    ConfigurationUtils.setChatFontIsBold(isBold);\r\n    ConfigurationUtils.setChatFontIsItalic(isItalic);\r\n    ConfigurationUtils.setChatFontIsUnderline(isUnderline);\r\n    ConfigurationUtils.setChatDefaultFontColor(color);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.version.VersionImpl.currentVersion",
	"Comment": "returns the versionimpl instance describing the current version ofjitsi.",
	"Method": "VersionImpl currentVersion(){\r\n    return CURRENT_VERSION;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.AbstractOperationSetTelephonyConferencing.outgoingCallCreated",
	"Comment": "notifies this calllistener that a specific outgoingcall has been created.",
	"Method": "void outgoingCallCreated(CallEvent event){\r\n    callBegun(event);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.MetaContactListSource.metaContactRemoved",
	"Comment": "removes the corresponding contact node in the contact list, when ametacontact has been removed from themetacontactlistservice.",
	"Method": "void metaContactRemoved(MetaContactEvent evt){\r\n    MetaContact metaContact = evt.getSourceMetaContact();\r\n    UIContact uiContact;\r\n    synchronized (metaContact) {\r\n        uiContact = MetaContactListSource.getUIContact(metaContact);\r\n    }\r\n    if (uiContact != null)\r\n        GuiActivator.getContactList().removeContact(uiContact);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jibri.XMPPErrorPE.setError",
	"Comment": "sets new instance of xmpperror to be wrapped by thisxmpperrorpe.",
	"Method": "void setError(XMPPError error){\r\n    Objects.requireNonNull(error, \"error\");\r\n    this.error = error;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.ProtocolProviderFactory.getProtocolName",
	"Comment": "gets the name of the protocol this factory registers itsprotocolproviderservices with and to be placed in theproperties of the accounts created by this factory.",
	"Method": "String getProtocolName(){\r\n    return protocolName;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AccountID.getSortedEnabledEncryptionProtocolList",
	"Comment": "sorts the enabled encryption protocol list given in parameter to matchthe preferences set for this account.",
	"Method": "List<SrtpControlType> getSortedEnabledEncryptionProtocolList(){\r\n    Map<String, Integer> encryptionProtocols = getIntegerPropertiesByPrefix(ProtocolProviderFactory.ENCRYPTION_PROTOCOL, true);\r\n    Map<String, Boolean> encryptionProtocolStatus = getBooleanPropertiesByPrefix(ProtocolProviderFactory.ENCRYPTION_PROTOCOL_STATUS, true, false);\r\n    if (encryptionProtocols.size() == 0) {\r\n        encryptionProtocols.put(ProtocolProviderFactory.ENCRYPTION_PROTOCOL + \".ZRTP\", 0);\r\n        encryptionProtocolStatus.put(ProtocolProviderFactory.ENCRYPTION_PROTOCOL_STATUS + \".ZRTP\", true);\r\n    }\r\n    List<SrtpControlType> sortedEncryptionProtocols = new ArrayList<SrtpControlType>(encryptionProtocols.size());\r\n    for (Map.Entry<String, Integer> e : encryptionProtocols.entrySet()) {\r\n        int index = e.getValue();\r\n        if (index != -1) {\r\n            if (index > sortedEncryptionProtocols.size())\r\n                index = sortedEncryptionProtocols.size();\r\n            String name = e.getKey().substring(ProtocolProviderFactory.ENCRYPTION_PROTOCOL.length() + 1);\r\n            try {\r\n                sortedEncryptionProtocols.add(index, SrtpControlType.fromString(name));\r\n            } catch (IllegalArgumentException exc) {\r\n                logger.error(\"Failed to get SRTP control type for name: '\" + name + \"', key: '\" + e.getKey() + \"'\", exc);\r\n            }\r\n        }\r\n    }\r\n    for (Iterator<SrtpControlType> i = sortedEncryptionProtocols.iterator(); i.hasNext(); ) {\r\n        String name = i.next().toString();\r\n        if (!encryptionProtocolStatus.get(ProtocolProviderFactory.ENCRYPTION_PROTOCOL_STATUS + \".\" + name)) {\r\n            i.remove();\r\n        }\r\n    }\r\n    return sortedEncryptionProtocols;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.MetaContactChatSession.findChatContactByMetaContact",
	"Comment": "returns the chatcontact corresponding to the givenmetacontact.",
	"Method": "ChatContact<?> findChatContactByMetaContact(MetaContact metaContact){\r\n    for (ChatContact<?> chatContact : chatParticipants) {\r\n        Object chatSourceContact = chatContact.getDescriptor();\r\n        if (chatSourceContact instanceof MetaContact) {\r\n            MetaContact metaChatContact = (MetaContact) chatSourceContact;\r\n            if (metaChatContact.equals(metaContact))\r\n                return chatContact;\r\n        } else {\r\n            assert chatSourceContact instanceof ChatRoomMember;\r\n            ChatRoomMember metaChatContact = (ChatRoomMember) chatSourceContact;\r\n            Contact contact = metaChatContact.getContact();\r\n            MetaContact parentMetaContact = GuiActivator.getContactListService().findMetaContactByContact(contact);\r\n            if (parentMetaContact != null && parentMetaContact.equals(metaContact))\r\n                return chatContact;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.ContactPropertyChangeEvent.getProtocolProvider",
	"Comment": "returns a reference to the protocol provider where the event hasoriginated.",
	"Method": "ProtocolProviderService getProtocolProvider(){\r\n    return getSourceContact().getProtocolProvider();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chatroomslist.ChatRoomTableDialog.setNickname",
	"Comment": "sets the default value in the nickname field based on chat room provider.",
	"Method": "void setNickname(ChatRoomProviderWrapper provider){\r\n    if (provider == null) {\r\n        return;\r\n    }\r\n    nicknameField.setText(GuiActivator.getGlobalDisplayDetailsService().getDisplayName(provider.getProtocolProvider()));\r\n    updateOKButtonEnableState();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.packetlogging.PacketLoggingConfigurationImpl.setSipLoggingEnabled",
	"Comment": "change whether packet logging for sip protocol is enabledand save it in configuration.",
	"Method": "void setSipLoggingEnabled(boolean enabled){\r\n    super.setSipLoggingEnabled(enabled);\r\n    PacketLoggingActivator.getConfigurationService().setProperty(PACKET_LOGGING_SIP_ENABLED_PROPERTY_NAME, enabled);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactGroupImpl.removeMetaContact",
	"Comment": "removes the specified metacontact from the local list ofcontacts.",
	"Method": "void removeMetaContact(MetaContactImpl metaContact){\r\n    metaContact.unsetParentGroup(this);\r\n    lightRemoveMetaContact(metaContact);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.account.AccountListCellRenderer.internalPaintComponent",
	"Comment": "paint a background for all groups and a round blue border and backgroundwhen a cell is selected.",
	"Method": "void internalPaintComponent(Graphics g){\r\n    AntialiasingManager.activateAntialiasing(g);\r\n    Graphics2D g2 = (Graphics2D) g;\r\n    if (index % 2 > 0) {\r\n        g2.setColor(rowColor);\r\n        g2.fillRect(0, 0, this.getWidth(), this.getHeight());\r\n    }\r\n    if (this.isSelected) {\r\n        g2.setColor(Constants.SELECTED_COLOR);\r\n        g2.fillRect(0, 0, this.getWidth(), this.getHeight());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.rayo.ReasonExtension.setPlatformCode",
	"Comment": "sets new value of platform code attribute. pass null to remove.",
	"Method": "void setPlatformCode(String code){\r\n    setAttribute(PLATFORM_CODE_ATTRIBUTE, code);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetWhiteboardingJabberImpl.getCurrentlyJoinedWhiteboards",
	"Comment": "returns a list of the whiteboardsessions thatwhiteboardparticipant has joined and is currently active in.",
	"Method": "List<WhiteboardSession> getCurrentlyJoinedWhiteboards(List<WhiteboardSession> getCurrentlyJoinedWhiteboards,WhiteboardParticipant participant){\r\n    return null;\r\n}"
}, {
	"Path": "net.librec.recommender.cf.UserKNNTestCase.test06SplitterRatioItem",
	"Comment": "test ratiodatasplitter with item ratio, evaluating enabled.",
	"Method": "void test06SplitterRatioItem(){\r\n    Resource resource = new Resource(\"rec/cf/userknn-test.properties\");\r\n    conf.addResource(resource);\r\n    conf.set(\"rec.eval.enable\", \"true\");\r\n    conf.set(\"data.model.splitter\", \"ratio\");\r\n    conf.set(\"data.splitter.ratio\", \"item\");\r\n    RecommenderJob job = new RecommenderJob(conf);\r\n    job.runJob();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.simpleaccreg.Resources.getLoginProperty",
	"Comment": "returns the application property corresponding to the given key.",
	"Method": "String getLoginProperty(String key){\r\n    return getResources().getSettingsString(key);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageHistoryServiceImpl.start",
	"Comment": "starts the service. check the current registered protocol providerswhich supports basicim and adds message listener to them",
	"Method": "void start(BundleContext bc){\r\n    this.bundleContext = bc;\r\n    ServiceReference refConfig = bundleContext.getServiceReference(ConfigurationService.class.getName());\r\n    configService = (ConfigurationService) bundleContext.getService(refConfig);\r\n    boolean isMessageHistoryEnabled = configService.getBoolean(MessageHistoryService.PNAME_IS_MESSAGE_HISTORY_ENABLED, Boolean.parseBoolean(MessageHistoryActivator.getResources().getSettingsString(MessageHistoryService.PNAME_IS_MESSAGE_HISTORY_ENABLED)));\r\n    msgHistoryPropListener = new MessageHistoryPropertyChangeListener();\r\n    isHistoryLoggingEnabled = configService.getBoolean(MessageHistoryService.PNAME_IS_MESSAGE_HISTORY_ENABLED, Boolean.parseBoolean(UtilActivator.getResources().getSettingsString(MessageHistoryService.PNAME_IS_MESSAGE_HISTORY_ENABLED)));\r\n    configService.addPropertyChangeListener(MessageHistoryService.PNAME_IS_MESSAGE_HISTORY_ENABLED, msgHistoryPropListener);\r\n    if (isMessageHistoryEnabled) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Starting the msg history implementation.\");\r\n        this.loadMessageHistoryService();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.TestOperationSetPersistentPresence.postTestRemoveGroup",
	"Comment": "removes the group created in the server stored contact list by the creategroup test, makes sure that the corresponding event has been generatedand verifies that the group is not in the list any more.",
	"Method": "void postTestRemoveGroup(){\r\n    logger.trace(\"testing removal of server stored groups\");\r\n    GroupChangeCollector groupChangeCollector = new GroupChangeCollector();\r\n    opSetPersPresence1.addServerStoredGroupChangeListener(groupChangeCollector);\r\n    try {\r\n        opSetPersPresence1.removeServerStoredContactGroup(opSetPersPresence1.getServerStoredContactListRoot().getGroup(testGroupName2));\r\n    } catch (OperationFailedException ex) {\r\n        logger.error(\"error removing group\", ex);\r\n    }\r\n    groupChangeCollector.waitForEvent(10000);\r\n    opSetPersPresence1.removeServerStoredGroupChangeListener(groupChangeCollector);\r\n    assertEquals(\"Collected Group Change event\", 1, groupChangeCollector.collectedEvents.size());\r\n    assertEquals(\"Group name.\", testGroupName2, ((ServerStoredGroupEvent) groupChangeCollector.collectedEvents.get(0)).getSourceGroup().getGroupName());\r\n    ContactGroup group = opSetPersPresence1.getServerStoredContactListRoot().getGroup(testGroupName2);\r\n    assertNull(\"A freshly removed group was still on the contact list.\", group);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ContactListTreeCellRenderer.initDisplayDetails",
	"Comment": "initializes the display details component for the givenuicontact.",
	"Method": "void initDisplayDetails(String displayDetails){\r\n    remove(displayDetailsLabel);\r\n    displayDetailsLabel.setText(\"\");\r\n    if (displayDetails != null && displayDetails.length() > 0) {\r\n        displayDetails = Html2Text.extractText(displayDetails);\r\n        displayDetails = displayDetails.replaceAll(\"\\n|<br>|<br/>\", \" / \");\r\n        displayDetailsLabel.setText(displayDetails);\r\n    }\r\n    constraints.anchor = GridBagConstraints.WEST;\r\n    constraints.fill = GridBagConstraints.NONE;\r\n    constraints.gridx = 1;\r\n    constraints.gridy = 1;\r\n    constraints.weightx = 1f;\r\n    constraints.weighty = 0f;\r\n    constraints.gridwidth = 1;\r\n    constraints.gridheight = 1;\r\n    add(displayDetailsLabel, constraints);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.netaddr.NetworkAddressManagerServiceLick.start",
	"Comment": "start the network address manager sevice implementation compatibility kit.",
	"Method": "void start(BundleContext bundleContext){\r\n    NetworkAddressManagerServiceLick.bc = bundleContext;\r\n    setName(\"NetworkAddressManagerServiceLick\");\r\n    Hashtable<String, String> properties = new Hashtable<String, String>();\r\n    properties.put(\"service.pid\", getName());\r\n    bundleContext.registerService(getClass().getName(), this, properties);\r\n    logger.debug(\"Successfully registered \" + getClass().getName());\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.thunderbird.ThunderbirdConfigForm.browseForMab",
	"Comment": "opens a file browser dialog to select a thunderbird .mab file. if theuser has chosen an existing file, the name is set to the filenametextbox.",
	"Method": "void browseForMab(){\r\n    FilenameFilter ff = new FilenameFilter() {\r\n        public boolean accept(File dir, String name) {\r\n            String extension = \"\";\r\n            int i = name.lastIndexOf('.');\r\n            if (i > 0) {\r\n                extension = name.substring(i + 1);\r\n            }\r\n            return \"mab\".equals(extension);\r\n        }\r\n    };\r\n    FileDialog fd = new FileDialog((Frame) null);\r\n    fd.setFilenameFilter(ff);\r\n    if (OSUtils.IS_WINDOWS) {\r\n        File f = new File(new File(System.getenv(\"APPDATA\"), \"Thunderbird\"), \"Profiles\");\r\n        if (f.exists()) {\r\n            fd.setDirectory(f.getAbsolutePath());\r\n        }\r\n    } else if (OSUtils.IS_LINUX) {\r\n        File f = new File(System.getProperty(\"user.home\"), \".thunderbird\");\r\n        if (!f.exists()) {\r\n            f = new File(System.getProperty(\"user.home\"), \".mozilla-thunderbird\");\r\n        }\r\n        if (f.exists()) {\r\n            fd.setDirectory(f.getAbsolutePath());\r\n        }\r\n    } else if (OSUtils.IS_MAC) {\r\n        File f = new File(System.getProperty(\"user.home\"), \"/Library/Profiles\");\r\n        if (!f.exists()) {\r\n            f = new File(System.getProperty(\"user.home\"), \"Application Support/Thunderbird/Profiles\");\r\n        }\r\n        if (f.exists()) {\r\n            fd.setDirectory(f.getAbsolutePath());\r\n        }\r\n    }\r\n    fd.setVisible(true);\r\n    if (fd.getFile() != null) {\r\n        File f = new File(fd.getDirectory(), fd.getFile());\r\n        if (f.exists()) {\r\n            txtFilename.setText(f.getAbsolutePath());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.thunderbird.ThunderbirdConfigForm.browseForMab",
	"Comment": "opens a file browser dialog to select a thunderbird .mab file. if theuser has chosen an existing file, the name is set to the filenametextbox.",
	"Method": "void browseForMab(){\r\n    String extension = \"\";\r\n    int i = name.lastIndexOf('.');\r\n    if (i > 0) {\r\n        extension = name.substring(i + 1);\r\n    }\r\n    return \"mab\".equals(extension);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.WhiteboardParticipantJabberImpl.getProtocolProvider",
	"Comment": "returns the protocol provider instance that this member has originatedin.",
	"Method": "ProtocolProviderService getProtocolProvider(){\r\n    return this.getWhiteboardSession().getProtocolProvider();\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.whiteboard.gui.whiteboardshapes.WhiteboardShapeCircle.setFill",
	"Comment": "sets the fill state of the whiteboardobject.true is filled, false is unfilled.",
	"Method": "void setFill(boolean fill){\r\n    this.fill = fill;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.callhistory.CallHistoryServiceImpl.getHistory",
	"Comment": "returns the history by specified local and remote contactif one of them is null the default is used",
	"Method": "History getHistory(Contact localContact,Contact remoteContact){\r\n    String localId = localContact == null ? \"default\" : localContact.getAddress();\r\n    String remoteId = remoteContact == null ? \"default\" : remoteContact.getAddress();\r\n    HistoryID historyId = HistoryID.createFromRawID(new String[] { \"callhistory\", localId, remoteId });\r\n    return this.historyService.createHistory(historyId, recordStructure);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.customcontrols.wizard.Wizard.unregisterWizardPage",
	"Comment": "removes from the wizard the wizardpage corresponding to thegiven identifier.",
	"Method": "void unregisterWizardPage(Object id){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                unregisterWizardPage(id);\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    WizardPage wizardPage = wizardModel.getWizardPage(id);\r\n    if (wizardPage != null) {\r\n        cardPanel.remove((Component) wizardModel.getWizardPage(id).getWizardForm());\r\n        wizardModel.unregisterPage(id);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.customcontrols.wizard.Wizard.unregisterWizardPage",
	"Comment": "removes from the wizard the wizardpage corresponding to thegiven identifier.",
	"Method": "void unregisterWizardPage(Object id){\r\n    unregisterWizardPage(id);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ProtocolProviderServiceJabberImpl.fireRegistrationStateChanged",
	"Comment": "tries to determine the appropriate message and status to fire,according the exception.",
	"Method": "void fireRegistrationStateChanged(XMPPException ex){\r\n    int reason = RegistrationStateChangeEvent.REASON_NOT_SPECIFIED;\r\n    RegistrationState regState = RegistrationState.UNREGISTERED;\r\n    String reasonStr = null;\r\n    Throwable wrappedEx = ex.getWrappedThrowable();\r\n    if (wrappedEx != null && (wrappedEx instanceof UnknownHostException || wrappedEx instanceof ConnectException || wrappedEx instanceof SocketException)) {\r\n        reason = RegistrationStateChangeEvent.REASON_SERVER_NOT_FOUND;\r\n        regState = RegistrationState.CONNECTION_FAILED;\r\n    } else {\r\n        String exMsg = ex.getMessage().toLowerCase();\r\n        if (isAuthenticationFailed(ex)) {\r\n            JabberActivator.getProtocolProviderFactory().storePassword(getAccountID(), null);\r\n            reason = RegistrationStateChangeEvent.REASON_AUTHENTICATION_FAILED;\r\n            regState = RegistrationState.AUTHENTICATION_FAILED;\r\n            fireRegistrationStateChanged(getRegistrationState(), regState, reason, null);\r\n            reregister(SecurityAuthority.WRONG_PASSWORD);\r\n            return;\r\n        } else if (exMsg.indexOf(\"no response from the server\") != -1 || exMsg.indexOf(\"connection failed\") != -1) {\r\n            reason = RegistrationStateChangeEvent.REASON_NOT_SPECIFIED;\r\n            regState = RegistrationState.CONNECTION_FAILED;\r\n        } else if (exMsg.indexOf(\"tls is required\") != -1) {\r\n            regState = RegistrationState.AUTHENTICATION_FAILED;\r\n            reason = RegistrationStateChangeEvent.REASON_TLS_REQUIRED;\r\n        }\r\n    }\r\n    if (regState == RegistrationState.UNREGISTERED || regState == RegistrationState.CONNECTION_FAILED) {\r\n        disconnectAndCleanConnection();\r\n    }\r\n    fireRegistrationStateChanged(getRegistrationState(), regState, reason, reasonStr);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.TestAccountInstallation.testInstallAccount",
	"Comment": "installs an account and verifies whether the installation has gone well.",
	"Method": "void testInstallAccount(){\r\n    ServiceReference[] serRefs = null;\r\n    String osgiFilter = \"(\" + ProtocolProviderFactory.PROTOCOL + \"=\" + ProtocolNames.JABBER + \")\";\r\n    try {\r\n        serRefs = JabberSlickFixture.bc.getServiceReferences(ProtocolProviderFactory.class.getName(), osgiFilter);\r\n    } catch (InvalidSyntaxException ex) {\r\n        fail(osgiFilter + \" is not a valid osgi filter\");\r\n    }\r\n    assertTrue(\"Failed to find a provider factory service for protocol Jabber\", serRefs != null && serRefs.length > 0);\r\n    ServiceReference confReference = JabberSlickFixture.bc.getServiceReference(ConfigurationService.class.getName());\r\n    ConfigurationService configurationService = (ConfigurationService) JabberSlickFixture.bc.getService(confReference);\r\n    configurationService.setProperty(CertificateService.PNAME_ALWAYS_TRUST, Boolean.TRUE);\r\n    ProtocolProviderFactory jabberProviderFactory = (ProtocolProviderFactory) JabberSlickFixture.bc.getService(serRefs[0]);\r\n    assertTrue(\"There was an account registered with the account mananger \" + \"before we've installed any\", jabberProviderFactory.getRegisteredAccounts().size() == 0);\r\n    Hashtable<String, String> jabberAccount1Properties = getAccountProperties(JabberProtocolProviderServiceLick.ACCOUNT_1_PREFIX);\r\n    Hashtable<String, String> jabberAccount2Properties = getAccountProperties(JabberProtocolProviderServiceLick.ACCOUNT_2_PREFIX);\r\n    Hashtable<String, String> jabberAccount3Properties = getAccountProperties(JabberProtocolProviderServiceLick.ACCOUNT_3_PREFIX);\r\n    try {\r\n        jabberProviderFactory.installAccount(null, jabberAccount1Properties);\r\n        fail(\"installing an account with a null account id must result \" + \"in a NullPointerException\");\r\n    } catch (NullPointerException exc) {\r\n    }\r\n    jabberProviderFactory.installAccount(jabberAccount1Properties.get(ProtocolProviderFactory.USER_ID), jabberAccount1Properties);\r\n    jabberProviderFactory.installAccount(jabberAccount2Properties.get(ProtocolProviderFactory.USER_ID), jabberAccount2Properties);\r\n    jabberProviderFactory.installAccount(jabberAccount3Properties.get(ProtocolProviderFactory.USER_ID), jabberAccount3Properties);\r\n    try {\r\n        jabberProviderFactory.installAccount(jabberAccount1Properties.get(ProtocolProviderFactory.USER_ID), jabberAccount1Properties);\r\n        fail(\"An IllegalStateException must be thrown when trying to \" + \"install a duplicate account\");\r\n    } catch (IllegalStateException exc) {\r\n    }\r\n    assertTrue(\"The newly installed account was not in the acc man's \" + \"registered accounts!\", jabberProviderFactory.getRegisteredAccounts().size() == 3);\r\n    osgiFilter = \"(&(\" + ProtocolProviderFactory.PROTOCOL + \"=\" + ProtocolNames.JABBER + \")\" + \"(\" + ProtocolProviderFactory.USER_ID + \"=\" + jabberAccount1Properties.get(ProtocolProviderFactory.USER_ID) + \"))\";\r\n    try {\r\n        serRefs = JabberSlickFixture.bc.getServiceReferences(ProtocolProviderService.class.getName(), osgiFilter);\r\n    } catch (InvalidSyntaxException ex) {\r\n        fail(osgiFilter + \"is not a valid osgi filter\");\r\n    }\r\n    assertTrue(\"An protocol provider was apparently not installed as \" + \"requested.\", serRefs != null && serRefs.length > 0);\r\n    Object jabberProtocolProvider = JabberSlickFixture.bc.getService(serRefs[0]);\r\n    assertTrue(\"The installed protocol provider does not implement \" + \"the protocol provider service.\", jabberProtocolProvider instanceof ProtocolProviderService);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.JabberActivator.getConfigurationService",
	"Comment": "returns a reference to a configurationservice implementation currentlyregistered in the bundle context or null if no such implementation wasfound.",
	"Method": "ConfigurationService getConfigurationService(){\r\n    if (configurationService == null) {\r\n        configurationService = ServiceUtils.getService(bundleContext, ConfigurationService.class);\r\n    }\r\n    return configurationService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.ChatRoomMessageDeliveredEvent.getTimestamp",
	"Comment": "a timestamp indicating the exact date when the event occurred.",
	"Method": "Date getTimestamp(){\r\n    return timestamp;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.usersearch.UserSearchActivator.addUserSearchSupportedProviderListener",
	"Comment": "adds new usersearchsupportedproviderlistener to the list oflisteners.",
	"Method": "void addUserSearchSupportedProviderListener(UserSearchSupportedProviderListener listener){\r\n    synchronized (listeners) {\r\n        if (!listeners.contains(listener))\r\n            listeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ConferenceChatSession.addLocalUserRoleListener",
	"Comment": "adds the given chatroomlocaluserrolelistener to the containedchat room role listeners.",
	"Method": "void addLocalUserRoleListener(ChatRoomLocalUserRoleListener l){\r\n    chatRoomWrapper.getChatRoom().addLocalUserRoleListener(l);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.generic.TestOperationSetFileTransfer.testSendAndReceive",
	"Comment": "full file transfer process. receiver and sender must end with eventfired for successful finish of the transfers on both sides.",
	"Method": "void testSendAndReceive(){\r\n    if (!enableTestSendAndReceive())\r\n        return;\r\n    logger.trace(\"Start test : send and receive ok.\");\r\n    File fileToTransfer = getTempFileToTransfer(123456);\r\n    OperationSetFileTransfer ftOpSet1 = getOpSetFilTransfer1();\r\n    OperationSetFileTransfer ftOpSet2 = getOpSetFilTransfer2();\r\n    FileTransferStatusEventCollector senderStatusListener = new FileTransferStatusEventCollector(\"Sender\");\r\n    FileTransferEventCollector senderFTListerner = new FileTransferEventCollector(\"Sender\", senderStatusListener);\r\n    ftOpSet1.addFileTransferListener(senderFTListerner);\r\n    FileTransferStatusEventCollector receiverStatusListener = new FileTransferStatusEventCollector(\"Receiver\");\r\n    FileTransferEventCollector receiverFTListerner = new FileTransferEventCollector(\"Receiver\", receiverStatusListener);\r\n    ftOpSet2.addFileTransferListener(receiverFTListerner);\r\n    try {\r\n        ftOpSet1.sendFile(getContact1(), fileToTransfer);\r\n        senderFTListerner.waitForEvent(2000);\r\n        receiverFTListerner.waitForEvent(8000);\r\n        senderStatusListener.waitForEvent(2000);\r\n        assertEquals(\"A file transfer created must be received on send side\", 1, senderFTListerner.collectedEvents.size());\r\n        FileTransferCreatedEvent fileTransferCreatedEvent = (FileTransferCreatedEvent) senderFTListerner.collectedEvents.get(0);\r\n        assertEquals(\"FileTransfer file\", fileTransferCreatedEvent.getFileTransfer().getLocalFile(), fileToTransfer);\r\n        assertEquals(\"A file transfer status changed - \" + \"preparing received on send side\", 1, senderStatusListener.collectedEvents.size());\r\n        FileTransferStatusChangeEvent fileTransferStatusEvent = senderStatusListener.collectedEvents.get(0);\r\n        assertEquals(\"Event must be preparing\", FileTransferStatusChangeEvent.PREPARING, fileTransferStatusEvent.getNewStatus());\r\n        assertEquals(\"A file transfer request must be \" + \"received on the receiver side\", 1, receiverFTListerner.collectedEvents.size());\r\n        FileTransferRequestEvent fileTransferRequestEvent = (FileTransferRequestEvent) receiverFTListerner.collectedEvents.get(0);\r\n        IncomingFileTransferRequest req = fileTransferRequestEvent.getRequest();\r\n        assertEquals(\"FileTransfer file name must be the same\", req.getFileName(), fileToTransfer.getName());\r\n        assertEquals(\"FileTransfer file size must be the same\", req.getFileSize(), fileToTransfer.length());\r\n        senderFTListerner.clear();\r\n        receiverFTListerner.clear();\r\n        senderStatusListener.clear();\r\n        File receiveFile = getFileService().getTemporaryFile();\r\n        req.acceptFile(receiveFile);\r\n        senderFTListerner.waitForEvent(4000);\r\n        receiverFTListerner.waitForEvent(4000);\r\n        assertEquals(\"A file transfer created must be \" + \"received on receiver side\", 1, receiverFTListerner.collectedEvents.size());\r\n        fileTransferCreatedEvent = (FileTransferCreatedEvent) receiverFTListerner.collectedEvents.get(0);\r\n        assertEquals(\"FileTransfer file\", fileTransferCreatedEvent.getFileTransfer().getLocalFile(), receiveFile);\r\n        receiverStatusListener.waitForEvent(30000, 3);\r\n        assertTrue(\"A file transfer status changed - \" + \"preparing, inprogress and completed received on receiver side\", 3 == receiverStatusListener.collectedEvents.size() || 2 == receiverStatusListener.collectedEvents.size());\r\n        fileTransferStatusEvent = receiverStatusListener.collectedEvents.get(0);\r\n        if (receiverStatusListener.collectedEvents.size() == 3) {\r\n            assertEquals(\"Event must be preparing\", FileTransferStatusChangeEvent.PREPARING, fileTransferStatusEvent.getNewStatus());\r\n            fileTransferStatusEvent = receiverStatusListener.collectedEvents.get(1);\r\n        }\r\n        assertEquals(\"Event must be in_progress\", FileTransferStatusChangeEvent.IN_PROGRESS, fileTransferStatusEvent.getNewStatus());\r\n        if (receiverStatusListener.collectedEvents.size() == 3)\r\n            fileTransferStatusEvent = receiverStatusListener.collectedEvents.get(2);\r\n        else\r\n            fileTransferStatusEvent = receiverStatusListener.collectedEvents.get(1);\r\n        assertEquals(\"Event must be completed\", FileTransferStatusChangeEvent.COMPLETED, fileTransferStatusEvent.getNewStatus());\r\n        senderStatusListener.waitForEvent(4000, 2);\r\n        assertTrue(\"Completed event must be received\", senderStatusListener.contains(FileTransferStatusChangeEvent.COMPLETED));\r\n    } finally {\r\n        ftOpSet1.removeFileTransferListener(senderFTListerner);\r\n        ftOpSet2.addFileTransferListener(receiverFTListerner);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.AdHocChatRoomMessageDeliveredEvent.getTimestamp",
	"Comment": "a timestamp indicating the exact date when the event occurred.",
	"Method": "Date getTimestamp(){\r\n    return this.timestamp;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.presence.NewStatusMessageDialog.init",
	"Comment": "initializes the newstatusmessagedialog by adding the buttons,fields, etc.",
	"Method": "void init(){\r\n    ResourceManagementService r = DesktopUtilActivator.getResources();\r\n    JLabel messageLabel = new JLabel(r.getI18NString(\"service.gui.NEW_STATUS_MESSAGE\"));\r\n    JPanel dataPanel = new TransparentPanel(new BorderLayout(5, 5));\r\n    JTextArea infoArea = new JTextArea(r.getI18NString(\"service.gui.STATUS_MESSAGE_INFO\"));\r\n    JLabel infoTitleLabel = new JLabel(r.getI18NString(\"service.gui.NEW_STATUS_MESSAGE\"));\r\n    JPanel labelsPanel = new TransparentPanel(new GridLayout(0, 1));\r\n    JButton okButton = new JButton(r.getI18NString(\"service.gui.OK\"));\r\n    JPanel buttonsPanel = new TransparentPanel(new FlowLayout(FlowLayout.RIGHT));\r\n    saveNewMessage = new JCheckBox(r.getI18NString(\"service.gui.NEW_STATUS_MESSAGE_SAVE\"));\r\n    this.setTitle(r.getI18NString(\"service.gui.NEW_STATUS_MESSAGE\"));\r\n    this.getRootPane().setDefaultButton(okButton);\r\n    this.setPreferredSize(new Dimension(550, 200));\r\n    infoArea.setEditable(false);\r\n    infoArea.setLineWrap(true);\r\n    infoArea.setWrapStyleWord(true);\r\n    infoArea.setOpaque(false);\r\n    dataPanel.add(messageLabel, BorderLayout.WEST);\r\n    messageTextField.setText(currentStatusMessage);\r\n    dataPanel.add(messageTextField, BorderLayout.CENTER);\r\n    infoTitleLabel.setHorizontalAlignment(JLabel.CENTER);\r\n    infoTitleLabel.setFont(infoTitleLabel.getFont().deriveFont(Font.BOLD, 18.0f));\r\n    saveNewMessage.setSelected(true);\r\n    JPanel saveToCustomPanel = new TransparentPanel(new FlowLayout(FlowLayout.RIGHT));\r\n    saveToCustomPanel.add(saveNewMessage);\r\n    labelsPanel.add(infoTitleLabel);\r\n    labelsPanel.add(infoArea);\r\n    labelsPanel.add(dataPanel);\r\n    labelsPanel.add(saveToCustomPanel);\r\n    messagePanel = new TransparentPanel(new GridBagLayout());\r\n    GridBagConstraints messagePanelConstraints = new GridBagConstraints();\r\n    messagePanelConstraints.anchor = GridBagConstraints.NORTHWEST;\r\n    messagePanelConstraints.fill = GridBagConstraints.NONE;\r\n    messagePanelConstraints.gridx = 0;\r\n    messagePanelConstraints.gridy = 0;\r\n    messagePanelConstraints.insets = new Insets(5, 0, 5, 10);\r\n    messagePanelConstraints.weightx = 0;\r\n    messagePanelConstraints.weighty = 0;\r\n    messagePanel.add(new ImageCanvas(DesktopUtilActivator.getImage(RENAME_DIALOG_ICON)), messagePanelConstraints);\r\n    messagePanelConstraints.anchor = GridBagConstraints.NORTH;\r\n    messagePanelConstraints.fill = GridBagConstraints.HORIZONTAL;\r\n    messagePanelConstraints.gridx = 1;\r\n    messagePanelConstraints.insets = new Insets(0, 0, 0, 0);\r\n    messagePanelConstraints.weightx = 1;\r\n    messagePanel.add(labelsPanel, messagePanelConstraints);\r\n    okButton.setName(\"ok\");\r\n    cancelButton.setName(\"cancel\");\r\n    okButton.setMnemonic(r.getI18nMnemonic(\"service.gui.OK\"));\r\n    cancelButton.setMnemonic(r.getI18nMnemonic(\"service.gui.CANCEL\"));\r\n    okButton.addActionListener(this);\r\n    cancelButton.addActionListener(this);\r\n    buttonsPanel.add(okButton);\r\n    buttonsPanel.add(cancelButton);\r\n    JPanel mainPanel = new TransparentPanel(new GridBagLayout());\r\n    mainPanel.setBorder(BorderFactory.createEmptyBorder(5, 10, 0, 10));\r\n    GridBagConstraints mainPanelConstraints = new GridBagConstraints();\r\n    mainPanelConstraints.anchor = GridBagConstraints.NORTH;\r\n    mainPanelConstraints.fill = GridBagConstraints.BOTH;\r\n    mainPanelConstraints.gridx = 0;\r\n    mainPanelConstraints.gridy = 0;\r\n    mainPanelConstraints.weightx = 1;\r\n    mainPanelConstraints.weighty = 1;\r\n    mainPanel.add(messagePanel, mainPanelConstraints);\r\n    mainPanelConstraints.anchor = GridBagConstraints.SOUTHEAST;\r\n    mainPanelConstraints.fill = GridBagConstraints.NONE;\r\n    mainPanelConstraints.gridy = 1;\r\n    mainPanelConstraints.weightx = 0;\r\n    mainPanelConstraints.weighty = 0;\r\n    mainPanel.add(buttonsPanel, mainPanelConstraints);\r\n    this.getContentPane().add(mainPanel);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.whiteboard.WhiteboardObjectImageJabberImpl.getBackgroundImage",
	"Comment": "returns a binary array containing the image that should be displayed asthe background of this whiteboardobject.",
	"Method": "byte[] getBackgroundImage(){\r\n    return this.background;\r\n}"
}, {
	"Path": "io.lettuce.core.LettuceFutures.awaitOrCancel",
	"Comment": "wait until futures are complete or the supplied timeout is reached. commands are canceled if the timeout is reached butthe command is not finished.",
	"Method": "T awaitOrCancel(RedisFuture<T> cmd,long timeout,TimeUnit unit){\r\n    try {\r\n        if (!cmd.await(timeout, unit)) {\r\n            cmd.cancel(true);\r\n            throw ExceptionFactory.createTimeoutException(Duration.ofNanos(unit.toNanos(timeout)));\r\n        }\r\n        return cmd.get();\r\n    } catch (RuntimeException e) {\r\n        throw e;\r\n    } catch (ExecutionException e) {\r\n        if (e.getCause() instanceof RedisCommandExecutionException) {\r\n            throw ExceptionFactory.createExecutionException(e.getCause().getMessage(), e.getCause());\r\n        }\r\n        if (e.getCause() instanceof RedisCommandTimeoutException) {\r\n            throw new RedisCommandTimeoutException(e.getCause());\r\n        }\r\n        throw new RedisException(e.getCause());\r\n    } catch (InterruptedException e) {\r\n        Thread.currentThread().interrupt();\r\n        throw new RedisCommandInterruptedException(e);\r\n    } catch (Exception e) {\r\n        throw ExceptionFactory.createExecutionException(null, e);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomJabberImpl.getMembersCount",
	"Comment": "returns the number of participants that are currently in this chatroom.",
	"Method": "int getMembersCount(){\r\n    return multiUserChat.getOccupantsCount();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl.processReferAccepted",
	"Comment": "processes a specific response.accepted response of an earlierrequest.refer request.",
	"Method": "void processReferAccepted(ClientTransaction clientTransaction,Response accepted){\r\n    try {\r\n        EventPackageUtils.addSubscription(clientTransaction.getDialog(), \"refer\");\r\n    } catch (SipException ex) {\r\n        logger.error(\"Failed to make Accepted REFER response\" + \" keep the dialog alive after BYE:\\n\" + accepted, ex);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.ResizeVideoButton.getFormattedDimension",
	"Comment": "returns a formatted string representing the given dimension.",
	"Method": "String getFormattedDimension(Dimension d){\r\n    return \" (\" + (int) d.getWidth() + \"x\" + (int) d.getHeight() + \")\";\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.account.AccountRegSummaryPage.getNextPageIdentifier",
	"Comment": "implements the wizardpage.getnextpageidentifier method.",
	"Method": "Object getNextPageIdentifier(){\r\n    return WizardPage.FINISH_PAGE_IDENTIFIER;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.usersearch.UserSearchIQ.getItemsToSearch",
	"Comment": "returns xml string with the fields that are not included in the data form",
	"Method": "String getItemsToSearch(){\r\n    StringBuilder buf = new StringBuilder();\r\n    if (simpleFieldsNames.isEmpty()) {\r\n        return \"\";\r\n    }\r\n    for (String name : simpleFieldsNames.keySet()) {\r\n        String value = simpleFieldsNames.get(name);\r\n        if (value != null && value.trim().length() > 0) {\r\n            buf.append(\"<\").append(name).append(\">\").append(StringUtils.escapeForXML(value)).append(\"<\/\").append(name).append(\">\");\r\n        }\r\n    }\r\n    return buf.toString();\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.contactlist.TestMetaContact.testDetails",
	"Comment": "test creating, changing and removing metacontact details.",
	"Method": "void testDetails(){\r\n    String name = \"test_detail_name\";\r\n    String detail_1 = \"detail_1\";\r\n    String detail_2 = \"detail_2\";\r\n    String detail_3 = \"detail_3\";\r\n    metaContact.addDetail(name, detail_1);\r\n    List<String> ds = metaContact.getDetails(name);\r\n    assertTrue(\"Must contain one detail\", 1 == ds.size());\r\n    assertTrue(\"The result details does not contain the desired\", ds.contains(detail_1));\r\n    metaContact.changeDetail(name, detail_1, detail_2);\r\n    ds = metaContact.getDetails(name);\r\n    assertEquals(\"Must contain one detail\", 1, ds.size());\r\n    assertTrue(\"The result details does not contain the desired\", ds.contains(detail_2));\r\n    metaContact.removeDetail(name, detail_2);\r\n    ds = metaContact.getDetails(name);\r\n    assertEquals(\"Must contain no details\", 0, ds.size());\r\n    metaContact.addDetail(name, detail_1);\r\n    metaContact.addDetail(name, detail_2);\r\n    metaContact.addDetail(name, detail_3);\r\n    ds = metaContact.getDetails(name);\r\n    assertEquals(\"Must contain three detail\", 3, ds.size());\r\n    assertTrue(\"The result details does not contain the desired\", ds.contains(detail_1));\r\n    assertTrue(\"The result details does not contain the desired\", ds.contains(detail_2));\r\n    assertTrue(\"The result details does not contain the desired\", ds.contains(detail_3));\r\n    metaContact.removeDetails(name);\r\n    ds = metaContact.getDetails(name);\r\n    assertEquals(\"Must contain no details\", 0, ds.size());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.msghistory.MessageSourceContactQuery.run",
	"Comment": "creates messagesourcecontact for all currently cachedrecent messages in the messagesourceservice.",
	"Method": "void run(){\r\n    getContactSource().updateRecentMessages();\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.TestProtocolProviderServiceJabberImpl.testOperationSetTypes",
	"Comment": "verifies that all operation sets have the type they are declarded tohave.",
	"Method": "void testOperationSetTypes(){\r\n    Map<String, OperationSet> supportedOperationSets = fixture.provider1.getSupportedOperationSets();\r\n    for (Map.Entry<String, OperationSet> entry : supportedOperationSets.entrySet()) {\r\n        String setName = entry.getKey();\r\n        Object opSet = entry.getValue();\r\n        assertTrue(opSet + \" was not an instance of \" + setName + \" as declared\", Class.forName(setName).isInstance(opSet));\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.SourceUIContact.getInternationalizedLabel",
	"Comment": "returns the internationalized label corresponding to the given category.",
	"Method": "String getInternationalizedLabel(ContactDetail.Category category,String getInternationalizedLabel,ContactDetail.SubCategory subCategory){\r\n    if (subCategory == null)\r\n        return null;\r\n    String label;\r\n    ResourceManagementService resources = GuiActivator.getResources();\r\n    switch(subCategory) {\r\n        case City:\r\n            label = resources.getI18NString(\"service.gui.CITY\");\r\n            break;\r\n        case Country:\r\n            label = resources.getI18NString(\"service.gui.COUNTRY\");\r\n            break;\r\n        case Fax:\r\n            label = resources.getI18NString(\"service.gui.FAX\");\r\n            break;\r\n        case Home:\r\n            label = resources.getI18NString(\"service.gui.HOME\");\r\n            break;\r\n        case HomePage:\r\n            label = resources.getI18NString(\"service.gui.HOME_PAGE\");\r\n            break;\r\n        case JobTitle:\r\n            label = resources.getI18NString(\"service.gui.JOB_TITLE\");\r\n            break;\r\n        case LastName:\r\n            label = resources.getI18NString(\"service.gui.LAST_NAME\");\r\n            break;\r\n        case Mobile:\r\n            label = resources.getI18NString(\"service.gui.MOBILE_PHONE\");\r\n            break;\r\n        case Name:\r\n            label = resources.getI18NString(\"service.gui.NAME\");\r\n            break;\r\n        case Nickname:\r\n            label = resources.getI18NString(\"service.gui.NICKNAME\");\r\n            break;\r\n        case Other:\r\n            label = resources.getI18NString(\"service.gui.OTHER\");\r\n            break;\r\n        case PostalCode:\r\n            label = resources.getI18NString(\"service.gui.POSTAL_CODE\");\r\n            break;\r\n        case Street:\r\n            label = resources.getI18NString(\"service.gui.STREET\");\r\n            break;\r\n        case Work:\r\n            label = resources.getI18NString(\"service.gui.WORK_PHONE\");\r\n            break;\r\n        case AIM:\r\n        case ICQ:\r\n        case Jabber:\r\n        case Yahoo:\r\n        case Skype:\r\n        case GoogleTalk:\r\n            label = subCategory.value();\r\n            break;\r\n        default:\r\n            label = null;\r\n            break;\r\n    }\r\n    return label;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.lookandfeel.SIPCommCallComboBoxUI.rectangleForCurrentValue",
	"Comment": "returns the area that is reserved for drawing the currently selected item.",
	"Method": "Rectangle rectangleForCurrentValue(){\r\n    int width = comboBox.getWidth();\r\n    int height = comboBox.getHeight();\r\n    Insets insets = getInsets();\r\n    int buttonSize = 0;\r\n    if (arrowButton != null)\r\n        buttonSize = arrowButton.getWidth();\r\n    if (comboBox.getComponentOrientation().isLeftToRight())\r\n        return new Rectangle(insets.left, insets.top, width - (insets.left + insets.right + buttonSize), height - (insets.top + insets.bottom));\r\n    else\r\n        return new Rectangle(insets.left + buttonSize, insets.top, width - (insets.left + insets.right + buttonSize), height - (insets.top + insets.bottom));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWritePanel.addChatTransport",
	"Comment": "adds the given chattransport to the given send via selector box.",
	"Method": "void addChatTransport(ChatTransport chatTransport){\r\n    if (!SwingUtilities.isEventDispatchThread()) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                addChatTransport(chatTransport);\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    if (transportSelectorBox != null) {\r\n        transportSelectorBox.addChatTransport(chatTransport);\r\n        if (!transportSelectorBox.isVisible() && ConfigurationUtils.isHideAccountSelectionWhenPossibleEnabled() && transportSelectorBox.getMenu().getItemCount() > 1) {\r\n            transportSelectorBox.setVisible(true);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWritePanel.addChatTransport",
	"Comment": "adds the given chattransport to the given send via selector box.",
	"Method": "void addChatTransport(ChatTransport chatTransport){\r\n    addChatTransport(chatTransport);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockContactGroup.subgroups",
	"Comment": "returns an iterator over the sub groups that thiscontactgroup contains.",
	"Method": "Iterator<ContactGroup> subgroups(){\r\n    return subGroups.iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.ProtocolMediaActivator.getMediaService",
	"Comment": "returns a reference to a mediaservice implementation currentlyregistered in the bundle context or null if no such implementation wasfound.",
	"Method": "MediaService getMediaService(){\r\n    if (mediaService == null) {\r\n        mediaService = ServiceUtils.getService(bundleContext, MediaService.class);\r\n    }\r\n    return mediaService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.CallPeerChangeEvent.toString",
	"Comment": "returns a string representation of this callpeerchangeevent.",
	"Method": "String toString(){\r\n    return \"CallPeerChangeEvent: type=\" + getEventType() + \" oldV=\" + getOldValue() + \" newV=\" + getNewValue() + \" for peer=\" + getSourceCallPeer();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ServerStoredContactListJabberImpl.createUnresolvedContactGroup",
	"Comment": "creates a non resolved contact group for the specified name. the newlycreated group would be added to the local contact list as any other groupbut when an event is received from the server concerning this group, thenit will be reused and only its isresolved field would be updated insteadof creating the whole group again.",
	"Method": "ContactGroupJabberImpl createUnresolvedContactGroup(String groupName){\r\n    ContactGroupJabberImpl existingGroup = findContactGroup(groupName);\r\n    if (existingGroup != null) {\r\n        return existingGroup;\r\n    }\r\n    ContactGroupJabberImpl newUnresolvedGroup = new ContactGroupJabberImpl(groupName, this);\r\n    this.rootGroup.addSubGroup(newUnresolvedGroup);\r\n    fireGroupEvent(newUnresolvedGroup, ServerStoredGroupEvent.GROUP_CREATED_EVENT);\r\n    return newUnresolvedGroup;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.caps.EntityCapsManager.getCapsPropertyName",
	"Comment": "gets the name of the property in the configurationservice whichis or is to be associated with a specific caps value.",
	"Method": "String getCapsPropertyName(Caps caps){\r\n    return CAPS_PROPERTY_NAME_PREFIX + caps.node + '#' + caps.hash + '#' + caps.ver;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.RootContactGroupIcqImpl.toString",
	"Comment": "returns a string representation of the root contact group that containsall subgroups and subcontacts of this group.",
	"Method": "String toString(){\r\n    StringBuffer buff = new StringBuffer(getGroupName());\r\n    buff.append(\".subGroups=\" + countSubgroups() + \":\\n\");\r\n    Iterator<ContactGroup> subGroups = subgroups();\r\n    while (subGroups.hasNext()) {\r\n        ContactGroup group = subGroups.next();\r\n        buff.append(group.toString());\r\n        if (subGroups.hasNext())\r\n            buff.append(\"\\n\");\r\n    }\r\n    return buff.toString();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallPanel.doUpdateViewFromModelInEventDispatchThread",
	"Comment": "updates this view i.e. callpanel so that it depicts the currentstate of its model i.e. callconference. the update is performedin the awt event dispatching thread.",
	"Method": "void doUpdateViewFromModelInEventDispatchThread(){\r\n    if (callConference.isEnded() || (callConference.getCallPeerCount() == 0)) {\r\n        updateSettingsPanelInEventDispatchThread(true);\r\n        return;\r\n    }\r\n    boolean isConference = isConference();\r\n    boolean isVideo = CallManager.isVideoStreaming(callConference);\r\n    CallPeer callPeer = null;\r\n    boolean validateAndRepaint = false;\r\n    if (callPanel != null) {\r\n        boolean removeCallPanel;\r\n        if (isConference) {\r\n            if (callPanel instanceof BasicConferenceCallPanel) {\r\n                if (isVideo) {\r\n                    removeCallPanel = !(callPanel instanceof VideoConferenceCallPanel);\r\n                } else {\r\n                    removeCallPanel = (callPanel instanceof VideoConferenceCallPanel);\r\n                }\r\n            } else {\r\n                removeCallPanel = true;\r\n            }\r\n        } else {\r\n            if (callPanel instanceof OneToOneCallPanel) {\r\n                if (callPeer == null) {\r\n                    List<CallPeer> callPeers = callConference.getCallPeers();\r\n                    if (!callPeers.isEmpty())\r\n                        callPeer = callPeers.get(0);\r\n                }\r\n                removeCallPanel = !((OneToOneCallPanel) callPanel).getCallPeer().equals(callPeer);\r\n            } else {\r\n                if ((callPanel instanceof BasicConferenceCallPanel) && ((BasicConferenceCallPanel) callPanel).hasDelayedCallPeers()) {\r\n                    removeCallPanel = false;\r\n                } else {\r\n                    removeCallPanel = true;\r\n                }\r\n            }\r\n        }\r\n        if (removeCallPanel) {\r\n            remove(callPanel);\r\n            validateAndRepaint = true;\r\n            try {\r\n                ((CallRenderer) callPanel).dispose();\r\n            } finally {\r\n                callPanel = null;\r\n            }\r\n        }\r\n    }\r\n    if (callPanel == null) {\r\n        if (isConference) {\r\n            if (isVideo) {\r\n                callPanel = new VideoConferenceCallPanel(this, callConference, uiVideoHandler);\r\n            } else {\r\n                callPanel = new AudioConferenceCallPanel(this, callConference);\r\n            }\r\n            ((BasicConferenceCallPanel) callPanel).addPeerViewlListener(this);\r\n        } else {\r\n            if (callPeer == null) {\r\n                List<CallPeer> callPeers = callConference.getCallPeers();\r\n                if (!callPeers.isEmpty())\r\n                    callPeer = callPeers.get(0);\r\n            }\r\n            if (callPeer != null) {\r\n                callPanel = new OneToOneCallPanel(this, callPeer, uiVideoHandler);\r\n            }\r\n        }\r\n        if (callPanel != null) {\r\n            add(callPanel, BorderLayout.CENTER);\r\n            validateAndRepaint = true;\r\n        }\r\n    }\r\n    try {\r\n        updateSettingsPanelInEventDispatchThread(false);\r\n    } finally {\r\n        if (validateAndRepaint) {\r\n            if (isDisplayable()) {\r\n                validate();\r\n                repaint();\r\n            } else\r\n                doLayout();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWritePanel.isSmsSelected",
	"Comment": "returns true if the sms mode is enabled, otherwise returnsfalse.",
	"Method": "boolean isSmsSelected(){\r\n    return smsMode;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.contactsource.AbstractContactQuery.addContactQueryListener",
	"Comment": "adds a contactquerylistener to the list of listeners interestedin notifications about this contactquery changing its status,the receipt of new sourcecontacts via thiscontactquery, etc.",
	"Method": "void addContactQueryListener(ContactQueryListener l){\r\n    if (l == null)\r\n        throw new NullPointerException(\"l\");\r\n    else {\r\n        synchronized (listeners) {\r\n            if (!listeners.contains(l))\r\n                listeners.add(l);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.callhistory.CallHistoryServiceImpl.addHistorySearchProgressListeners",
	"Comment": "add the registered callhistorysearchprogresslisteners to the givenhistoryreader",
	"Method": "void addHistorySearchProgressListeners(HistoryReader reader,int countContacts){\r\n    synchronized (progressListeners) {\r\n        for (SearchProgressWrapper l : progressListeners.values()) {\r\n            l.contactCount = countContacts;\r\n            reader.addSearchProgressListener(l);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chatroomslist.joinforms.ChatRoomNamePanel.addChatRoomNameListener",
	"Comment": "adds a documentlistener to the text field containing the chosenchat room.",
	"Method": "void addChatRoomNameListener(DocumentListener l){\r\n    this.textField.getDocument().addDocumentListener(l);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.FileTransferStatusChangeEvent.getOldStatus",
	"Comment": "returns the state of the file transfer before this event occured.",
	"Method": "int getOldStatus(){\r\n    return oldStatus;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.packetlogging.PacketLoggingActivator.start",
	"Comment": "creates a packetloggingserviceimpl, starts it, and registers it as apacketloggingservice.",
	"Method": "void start(BundleContext bundleContext){\r\n    fileAccessService = ServiceUtils.getService(bundleContext, FileAccessService.class);\r\n    if (fileAccessService != null) {\r\n        PacketLoggingActivator.bundleContext = bundleContext;\r\n        packetLoggingService = new PacketLoggingServiceImpl();\r\n        packetLoggingService.start();\r\n        bundleContext.registerService(PacketLoggingService.class.getName(), packetLoggingService, null);\r\n        if (logger.isInfoEnabled())\r\n            logger.info(\"Packet Logging Service ...[REGISTERED]\");\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.sipaccregwizz.SIPAccountRegistrationForm.addValidatingPanel",
	"Comment": "adds panel to the list of panels with values which need validation.",
	"Method": "void addValidatingPanel(ValidatingPanel panel){\r\n    validatingPanels.add(panel);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.MainFrame.getProtocolProviderForAccount",
	"Comment": "returns the protocol provider associated to the account givenby the account user identifier.",
	"Method": "ProtocolProviderService getProtocolProviderForAccount(String accountName){\r\n    for (ProtocolProviderService pps : protocolProviders.keySet()) {\r\n        if (pps.getAccountID().getUserID().equals(accountName)) {\r\n            return pps;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.BasicPollerPresenceWatcher.setUpPresenceWatcher",
	"Comment": "set up a timer for watching the presence of nicks in the watch list.",
	"Method": "void setUpPresenceWatcher(AtomicReference<String> serverIdentity){\r\n    final List<List<String>> queryList = Collections.synchronizedList(new LinkedList<List<String>>());\r\n    final Timer presenceWatcher = new Timer();\r\n    irc.addListener(new PresenceReplyListener(presenceWatcher, queryList));\r\n    final PresenceWatcherTask task = new PresenceWatcherTask(this.nickWatchList, queryList, serverIdentity);\r\n    presenceWatcher.schedule(task, INITIAL_PRESENCE_WATCHER_DELAY, PRESENCE_WATCHER_PERIOD);\r\n    LOGGER.trace(\"Basic Poller presence watcher set up.\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.authorization.RequestAuthorizationDialog.actionPerformed",
	"Comment": "handles the actionevent triggered when one user clickson one of the buttons.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    JButton button = (JButton) e.getSource();\r\n    String name = button.getName();\r\n    synchronized (lock) {\r\n        if (name.equals(\"request\")) {\r\n            returnCode = OK_RETURN_CODE;\r\n        } else if (name.equals(\"cancel\")) {\r\n            returnCode = CANCEL_RETURN_CODE;\r\n        }\r\n        lock.notify();\r\n    }\r\n    this.dispose();\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.fileaccess.FileAccessServiceLick.start",
	"Comment": "start the file access sevice implementation compatibility kit.",
	"Method": "void start(BundleContext bundleContext){\r\n    FileAccessServiceLick.bc = bundleContext;\r\n    setName(\"FileAccessServiceLick\");\r\n    Hashtable<String, String> properties = new Hashtable<String, String>();\r\n    properties.put(\"service.pid\", getName());\r\n    addTestSuite(TestFileAccessService.class);\r\n    addTestSuite(TestFailSafeTransaction.class);\r\n    bundleContext.registerService(getClass().getName(), this, properties);\r\n    logger.debug(\"Successfully registered \" + getClass().getName());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactImpl.getDisplayName",
	"Comment": "returns a characteristic display name that can be used when includingthis metacontact in user interface.",
	"Method": "String getDisplayName(){\r\n    return displayName;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatPanel.addChatTransport",
	"Comment": "adds the given chattransport to the given send via selector box.",
	"Method": "void addChatTransport(ChatTransport chatTransport){\r\n    writeMessagePanel.addChatTransport(chatTransport);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatSession.findChatTransportForDescriptor",
	"Comment": "returns the chattransport corresponding to the given descriptor.",
	"Method": "ChatTransport findChatTransportForDescriptor(Object descriptor,String resourceName){\r\n    for (ChatTransport chatTransport : chatTransports) {\r\n        String transportResName = chatTransport.getResourceName();\r\n        if (chatTransport.getDescriptor().equals(descriptor) && (resourceName == null || (transportResName != null && transportResName.equals(resourceName))))\r\n            return chatTransport;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ActiveCallsRepositoryJabberGTalkImpl.fireCallEvent",
	"Comment": "creates and dispatches a callevent notifying registeredlisteners that an event with id eventid has occurred onsourcecall.",
	"Method": "void fireCallEvent(int eventID,Call sourceCall,CallChangeEvent cause){\r\n    parentOperationSet.fireCallEvent(eventID, sourceCall);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.gibberishaccregwizz.GibberishAccRegWizzActivator.getGibberishProtocolProviderFactory",
	"Comment": "returns the protocolproviderfactory for the gibberish protocol.",
	"Method": "ProtocolProviderFactory getGibberishProtocolProviderFactory(){\r\n    ServiceReference[] serRefs = null;\r\n    String osgiFilter = \"(\" + ProtocolProviderFactory.PROTOCOL + \"=\" + \"Gibberish\" + \")\";\r\n    try {\r\n        serRefs = bundleContext.getServiceReferences(ProtocolProviderFactory.class.getName(), osgiFilter);\r\n    } catch (InvalidSyntaxException ex) {\r\n        logger.error(ex);\r\n    }\r\n    return (ProtocolProviderFactory) bundleContext.getService(serRefs[0]);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.AnimatedImage.setCycles",
	"Comment": "specify the number of times to repeat each animation sequence, or cycle.",
	"Method": "void setCycles(int cycles){\r\n    this.cycles = cycles;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.msoutlook.MsOutlookAddrBookSourceContact.match",
	"Comment": "tells if the id given in parameters corresponds to this contact.",
	"Method": "boolean match(String id,int level){\r\n    boolean res = false;\r\n    switch(level) {\r\n        case 0:\r\n            res = this.ids.contains(id);\r\n            break;\r\n        case 1:\r\n            String localId = this.getId();\r\n            res = MsOutlookAddrBookContactQuery.compareEntryIds(id, localId);\r\n            if (res && !this.ids.contains(id)) {\r\n                this.ids.add(id);\r\n            }\r\n            break;\r\n    }\r\n    return res;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.ChooseCallAccountPopupMenu.addTelephonyChatTransportItem",
	"Comment": "adds the given chattransport to the list of availabletelephony chat transports.",
	"Method": "void addTelephonyChatTransportItem(ChatTransport telTransport,Class<? extends OperationSet> opSetClass){\r\n    final ChatTransportMenuItem transportItem = new ChatTransportMenuItem(telTransport);\r\n    transportItem.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent e) {\r\n            ProtocolProviderService provider = telTransport.getProtocolProvider();\r\n            String contactAddress = telTransport.getName();\r\n            if (uiContact != null)\r\n                CallManager.createCall(opSetClass, provider, contactAddress, uiContact);\r\n            else\r\n                CallManager.createCall(opSetClass, provider, contactAddress);\r\n            ChooseCallAccountPopupMenu.this.setVisible(false);\r\n        }\r\n    });\r\n    this.add(transportItem);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.ChooseCallAccountPopupMenu.addTelephonyChatTransportItem",
	"Comment": "adds the given chattransport to the list of availabletelephony chat transports.",
	"Method": "void addTelephonyChatTransportItem(ChatTransport telTransport,Class<? extends OperationSet> opSetClass){\r\n    ProtocolProviderService provider = telTransport.getProtocolProvider();\r\n    String contactAddress = telTransport.getName();\r\n    if (uiContact != null)\r\n        CallManager.createCall(opSetClass, provider, contactAddress, uiContact);\r\n    else\r\n        CallManager.createCall(opSetClass, provider, contactAddress);\r\n    ChooseCallAccountPopupMenu.this.setVisible(false);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.customcontrols.wizard.Wizard.startCommittingPage",
	"Comment": "changes cursor and status label, informing user we are in processof connecting.",
	"Method": "void startCommittingPage(){\r\n    isCurrentlySigningIn = true;\r\n    setBackButtonEnabled(false);\r\n    setCancelButtonEnabled(false);\r\n    setNextFinishButtonEnabled(false);\r\n    statusLabel.setText(GuiActivator.getResources().getI18NString(\"service.gui.CONNECTING\"));\r\n    setCursor(new Cursor(Cursor.WAIT_CURSOR));\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ContactListPane.contactClicked",
	"Comment": "implements the contactlistlistener.contactselected method.",
	"Method": "void contactClicked(ContactListEvent evt){\r\n    if (evt.getClickCount() < 2)\r\n        return;\r\n    UIContact descriptor = evt.getSourceContact();\r\n    if (descriptor.getDescriptor() instanceof MetaContact) {\r\n        MetaContact metaContact = (MetaContact) descriptor.getDescriptor();\r\n        Contact defaultContact = metaContact.getDefaultContact(OperationSetBasicInstantMessaging.class);\r\n        if (defaultContact == null) {\r\n            defaultContact = metaContact.getDefaultContact(OperationSetSmsMessaging.class);\r\n            if (defaultContact == null)\r\n                return;\r\n        }\r\n        ProtocolProviderService defaultProvider = defaultContact.getProtocolProvider();\r\n        OperationSetBasicInstantMessaging defaultIM = defaultProvider.getOperationSet(OperationSetBasicInstantMessaging.class);\r\n        ProtocolProviderService protoContactProvider;\r\n        OperationSetBasicInstantMessaging protoContactIM;\r\n        boolean isOfflineMessagingSupported = defaultIM != null && !defaultIM.isOfflineMessagingSupported();\r\n        if (defaultContact.getPresenceStatus().getStatus() < 1 && (!isOfflineMessagingSupported || !defaultProvider.isRegistered())) {\r\n            Iterator<Contact> protoContacts = metaContact.getContacts();\r\n            while (protoContacts.hasNext()) {\r\n                Contact contact = protoContacts.next();\r\n                protoContactProvider = contact.getProtocolProvider();\r\n                protoContactIM = protoContactProvider.getOperationSet(OperationSetBasicInstantMessaging.class);\r\n                if (protoContactIM != null && protoContactIM.isOfflineMessagingSupported() && protoContactProvider.isRegistered()) {\r\n                    defaultContact = contact;\r\n                }\r\n            }\r\n        }\r\n        ContactEventHandler contactHandler = mainFrame.getContactHandler(defaultContact.getProtocolProvider());\r\n        contactHandler.contactClicked(defaultContact, evt.getClickCount());\r\n    } else if (descriptor.getDescriptor() instanceof SourceContact) {\r\n        SourceContact contact = (SourceContact) descriptor.getDescriptor();\r\n        List<ContactDetail> imDetails = contact.getContactDetails(OperationSetBasicInstantMessaging.class);\r\n        List<ContactDetail> mucDetails = contact.getContactDetails(OperationSetMultiUserChat.class);\r\n        if (imDetails != null && imDetails.size() > 0) {\r\n            ProtocolProviderService pps = imDetails.get(0).getPreferredProtocolProvider(OperationSetBasicInstantMessaging.class);\r\n            if (pps != null)\r\n                GuiActivator.getUIService().getChatWindowManager().startChat(contact.getContactAddress(), pps);\r\n            else\r\n                GuiActivator.getUIService().getChatWindowManager().startChat(contact.getContactAddress());\r\n        } else if (mucDetails != null && mucDetails.size() > 0) {\r\n            ChatRoomWrapper room = GuiActivator.getMUCService().findChatRoomWrapperFromSourceContact(contact);\r\n            if (room == null) {\r\n                ProtocolProviderService pps = mucDetails.get(0).getPreferredProtocolProvider(OperationSetMultiUserChat.class);\r\n                room = GuiActivator.getMUCService().findChatRoomWrapperFromChatRoomID(contact.getContactAddress(), pps);\r\n                if (room == null) {\r\n                    GuiActivator.getMUCService().createChatRoom(contact.getContactAddress(), pps, new ArrayList<String>(), \"\", false, false, false);\r\n                }\r\n            }\r\n            if (room != null)\r\n                GuiActivator.getMUCService().openChatRoom(room);\r\n        } else {\r\n            List<ContactDetail> smsDetails = contact.getContactDetails(OperationSetSmsMessaging.class);\r\n            if (smsDetails != null && smsDetails.size() > 0) {\r\n                GuiActivator.getUIService().getChatWindowManager().startChat(contact.getContactAddress(), true);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.callhistory.CallHistoryQueryImpl.fireQueryEvent",
	"Comment": "notifies all registered historyquerylisteners that a new recordhas been received.",
	"Method": "void fireQueryEvent(CallRecord record){\r\n    CallRecordEvent event = new CallRecordEvent(this, record);\r\n    synchronized (queryListeners) {\r\n        for (CallHistoryQueryListener l : queryListeners) l.callRecordReceived(event);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.account.AccountListCellRenderer.paintComponent",
	"Comment": "paint a background for all groups and a round blue border and backgroundwhen a cell is selected.",
	"Method": "void paintComponent(Graphics g){\r\n    super.paintComponent(g);\r\n    g = g.create();\r\n    try {\r\n        internalPaintComponent(g);\r\n    } finally {\r\n        g.dispose();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetAutoAnswerSipImpl.getAutoAnswerHeaderName",
	"Comment": "returns the name of the header if conditional auto answer is set.",
	"Method": "String getAutoAnswerHeaderName(){\r\n    return headerName;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.googlecontacts.GoogleContactsSourceService.stop",
	"Comment": "stops this contactsourceservice implementation and prepares itfor garbage collection.",
	"Method": "void stop(){\r\n    boolean interrupted = false;\r\n    synchronized (queries) {\r\n        while (!queries.isEmpty()) {\r\n            queries.get(0).cancel();\r\n            try {\r\n                queries.wait();\r\n            } catch (InterruptedException iex) {\r\n                interrupted = true;\r\n            }\r\n        }\r\n    }\r\n    if (interrupted)\r\n        Thread.currentThread().interrupt();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AccountInfoUtils.getEmailAddress",
	"Comment": "returns the email address of the account, to which the givenaccountinfoopset belongs.",
	"Method": "String getEmailAddress(OperationSetServerStoredAccountInfo accountInfoOpSet){\r\n    EmailAddressDetail address = null;\r\n    Iterator<GenericDetail> addressDetails = accountInfoOpSet.getDetails(EmailAddressDetail.class);\r\n    if (addressDetails.hasNext())\r\n        address = (EmailAddressDetail) addressDetails.next();\r\n    if (address == null)\r\n        return null;\r\n    return address.getEMailAddress();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ChatConferenceCallDialog.removeConference",
	"Comment": "removes the given conferencedescription from the list of conferences.",
	"Method": "void removeConference(ConferenceDescription conferenceDescription){\r\n    chatConferenceListPanel.removeConference(conferenceDescription);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.notificationconfiguration.NotificationConfigurationActivator.getConfigurationService",
	"Comment": "returns a reference to the configurationservice implementation currentlyregistered in the bundle context or null if no such implementation wasfound.",
	"Method": "ConfigurationService getConfigurationService(){\r\n    if (configurationService == null) {\r\n        configurationService = ServiceUtils.getService(bundleContext, ConfigurationService.class);\r\n    }\r\n    return configurationService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockPersistentPresenceOperationSet.getLocalContact",
	"Comment": "returns the protocol specific contact instance representing the localuser.",
	"Method": "Contact getLocalContact(){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.packetlogging.PacketLoggingActivator.getConfigurationService",
	"Comment": "returns a reference to a configurationservice implementation currentlyregistered in the bundle context or null if no such implementation wasfound.",
	"Method": "ConfigurationService getConfigurationService(){\r\n    if (configurationService == null) {\r\n        ServiceReference confReference = bundleContext.getServiceReference(ConfigurationService.class.getName());\r\n        configurationService = (ConfigurationService) bundleContext.getService(confReference);\r\n    }\r\n    return configurationService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.addrbook.msoutlook.MsOutlookAddrBookSourceContact.removeContactDetail",
	"Comment": "removes the given contactdetail from the list of details forthis sourcecontact.",
	"Method": "void removeContactDetail(ContactDetail detail){\r\n    synchronized (this) {\r\n        int i = 0;\r\n        while (i < this.contactDetails.size()) {\r\n            MsOutlookAddrBookContactDetail contactDetail = ((MsOutlookAddrBookContactDetail) this.contactDetails.get(i));\r\n            if (contactDetail.match(detail)) {\r\n                this.removeProperty(contactDetail);\r\n                this.contactDetails.remove(i);\r\n            } else {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.InfoRetreiver.readUserAboutInfo",
	"Comment": "method for parsing incoming dataread data in useraboutinfo command",
	"Method": "void readUserAboutInfo(MetaNotesInfoCmd cmd){\r\n    List<GenericDetail> infoData = getInfoForRequest(cmd.getId());\r\n    if (cmd.getNotes() != null)\r\n        infoData.add(new OperationSetServerStoredAccountInfoIcqImpl.NotesDetail(cmd.getNotes()));\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.server.WebSocketServletRFCTest.testEcho",
	"Comment": "test the requirement of issuing socket and receiving echo response",
	"Method": "void testEcho(){\r\n    BlockheadClientRequest request = client.newWsRequest(server.getServerUri());\r\n    Future<BlockheadConnection> connFut = request.sendAsync();\r\n    try (BlockheadConnection clientConn = connFut.get(Timeouts.CONNECT, Timeouts.CONNECT_UNIT)) {\r\n        String msg = \"this is an echo ... cho ... ho ... o\";\r\n        clientConn.write(new TextFrame().setPayload(msg));\r\n        LinkedBlockingQueue<WebSocketFrame> frames = clientConn.getFrameQueue();\r\n        WebSocketFrame tf = frames.poll(Timeouts.POLL_EVENT, Timeouts.POLL_EVENT_UNIT);\r\n        assertThat(\"Text Frame.status code\", tf.getPayloadAsUTF8(), is(msg));\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.IncomingFileTransferJabberImpl.getLocalFile",
	"Comment": "returns the local file that is being transferred or to which we transfer.",
	"Method": "File getLocalFile(){\r\n    return file;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl.getSipCommUserAgentHeader",
	"Comment": "returns a user agent header that could be used for signing our requests.",
	"Method": "UserAgentHeader getSipCommUserAgentHeader(){\r\n    if (userAgentHeader == null) {\r\n        try {\r\n            List<String> userAgentTokens = new LinkedList<String>();\r\n            Version ver = SipActivator.getVersionService().getCurrentVersion();\r\n            userAgentTokens.add(ver.getApplicationName());\r\n            userAgentTokens.add(ver.toString());\r\n            String osName = System.getProperty(\"os.name\");\r\n            userAgentTokens.add(osName);\r\n            userAgentHeader = this.headerFactory.createUserAgentHeader(userAgentTokens);\r\n        } catch (ParseException ex) {\r\n            return null;\r\n        }\r\n    }\r\n    return userAgentHeader;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.ProtocolProviderFactory.loadAccount",
	"Comment": "creates a protocol provider for the given accountid andregisters it in the bundle context. this method has a persistenteffect. once created the resulting account will remain installed untilremoved through the uninstallaccount method.",
	"Method": "AccountID loadAccount(Map<String, String> accountProperties,boolean loadAccount,AccountID accountID){\r\n    String userID = accountID.getAccountPropertyString(ProtocolProviderFactory.USER_ID);\r\n    ProtocolProviderService service = createService(userID, accountID);\r\n    Dictionary<String, String> properties = new Hashtable<String, String>();\r\n    properties.put(PROTOCOL, protocolName);\r\n    properties.put(USER_ID, userID);\r\n    ServiceRegistration<ProtocolProviderService> serviceRegistration = bundleContext.registerService(ProtocolProviderService.class, service, properties);\r\n    if (serviceRegistration == null) {\r\n        return false;\r\n    } else {\r\n        synchronized (registeredAccounts) {\r\n            registeredAccounts.put(accountID, serviceRegistration);\r\n        }\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "net.librec.eval.ranking.AverageReciprocalHitRankEvaluator.evaluate",
	"Comment": "evaluate on the test set with the the list of recommended items.",
	"Method": "double evaluate(RecommendedList groundTruthList,RecommendedList recommendedList){\r\n    double reciprocalRank = 0.0;\r\n    int numContext = groundTruthList.size();\r\n    int nonZeroContext = 0;\r\n    for (int contextIdx = 0; contextIdx < numContext; ++contextIdx) {\r\n        List<KeyValue<Integer, Double>> testListByContext = groundTruthList.getKeyValueListByContext(contextIdx);\r\n        if (testListByContext.size() > 0) {\r\n            List<KeyValue<Integer, Double>> recommendListByContext = recommendedList.getKeyValueListByContext(contextIdx);\r\n            int trueKeyIdx = testListByContext.get(0).getKey();\r\n            int topK = this.topN <= recommendListByContext.size() ? this.topN : recommendListByContext.size();\r\n            for (int indexOfKey = 0; indexOfKey < topK; ++indexOfKey) {\r\n                if (recommendListByContext.get(indexOfKey).getKey() == trueKeyIdx) {\r\n                    reciprocalRank += 1.0 / (indexOfKey + 1.0);\r\n                    break;\r\n                }\r\n            }\r\n            nonZeroContext++;\r\n        }\r\n    }\r\n    return nonZeroContext > 0 ? reciprocalRank / nonZeroContext : 0.0d;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.AvatarCacheUtils.getCachedAvatarPath",
	"Comment": "returns the bytes of the avatar image stored for the accountcorresponding to the given protocol provider.",
	"Method": "String getCachedAvatarPath(ProtocolProviderService protocolProvider,String getCachedAvatarPath,Contact protocolContact,String getCachedAvatarPath,ProtocolProviderService protocolProvider,String contactAddress){\r\n    return AVATAR_DIR + File.separator + escapeSpecialCharacters(protocolProvider.getAccountID().getAccountUniqueID()) + File.separator + escapeSpecialCharacters(contactAddress);\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.Entities.doUnescape",
	"Comment": "underlying unescape method that allows the optimisation of not starting from the 0 index again.",
	"Method": "void doUnescape(Writer writer,String str,int firstAmp){\r\n    writer.write(str, 0, firstAmp);\r\n    int len = str.length();\r\n    for (int i = firstAmp; i < len; i++) {\r\n        char c = str.charAt(i);\r\n        if (c == '&') {\r\n            int nextIdx = i + 1;\r\n            int semiColonIdx = str.indexOf(';', nextIdx);\r\n            if (semiColonIdx == -1) {\r\n                writer.write(c);\r\n                continue;\r\n            }\r\n            int amphersandIdx = str.indexOf('&', i + 1);\r\n            if (amphersandIdx != -1 && amphersandIdx < semiColonIdx) {\r\n                writer.write(c);\r\n                continue;\r\n            }\r\n            String entityContent = str.substring(nextIdx, semiColonIdx);\r\n            int entityValue = -1;\r\n            int entityContentLen = entityContent.length();\r\n            if (entityContentLen > 0) {\r\n                if (entityContent.charAt(0) == '#') {\r\n                    if (entityContentLen > 1) {\r\n                        char isHexChar = entityContent.charAt(1);\r\n                        try {\r\n                            switch(isHexChar) {\r\n                                case 'X':\r\n                                case 'x':\r\n                                    {\r\n                                        entityValue = Integer.parseInt(entityContent.substring(2), 16);\r\n                                        break;\r\n                                    }\r\n                                default:\r\n                                    {\r\n                                        entityValue = Integer.parseInt(entityContent.substring(1), 10);\r\n                                    }\r\n                            }\r\n                            if (entityValue > 0xFFFF) {\r\n                                entityValue = -1;\r\n                            }\r\n                        } catch (NumberFormatException e) {\r\n                            entityValue = -1;\r\n                        }\r\n                    }\r\n                } else {\r\n                    entityValue = this.entityValue(entityContent);\r\n                }\r\n            }\r\n            if (entityValue == -1) {\r\n                writer.write('&');\r\n                writer.write(entityContent);\r\n                writer.write(';');\r\n            } else {\r\n                writer.write(entityValue);\r\n            }\r\n            i = semiColonIdx;\r\n        } else {\r\n            writer.write(c);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatContact.getDescriptor",
	"Comment": "returns the descriptor object corresponding to this chat contact. in thecase of single chat this could be the metacontact and in thecase of conference chat this could be the chatroommember.",
	"Method": "T getDescriptor(){\r\n    return descriptor;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.ReadonlyStatusItem.updateStatus",
	"Comment": "selects a specific presencestatus in this instance and theprotocolproviderservice it depicts.",
	"Method": "void updateStatus(PresenceStatus presenceStatus){\r\n    if (logger.isTraceEnabled())\r\n        logger.trace(\"Update status for provider: \" + protocolProvider.getAccountID().getAccountAddress() + \". The new status will be: \" + presenceStatus.getStatusName());\r\n    this.setSelectedStatus(presenceStatus);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.ContactGroupGibberishImpl.getPersistentData",
	"Comment": "returns null as no persistent data is required and the contact address issufficient for restoring the contact.",
	"Method": "String getPersistentData(){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.gibberish.TestAccountUninstallationPersistence.testAccountUninstallationPersistence",
	"Comment": "retrieves a reference to the gibberish bundle, stops it and uninstallsit and then reinstalls it in order to make sure that accounts are notreloaded once removed.",
	"Method": "void testAccountUninstallationPersistence(){\r\n    Bundle providerBundle = GibberishSlickFixture.providerBundle;\r\n    providerBundle.stop();\r\n    assertTrue(\"Couldn't stop the protocol provider bundle. State was \" + providerBundle.getState(), Bundle.ACTIVE != providerBundle.getState() && Bundle.STOPPING != providerBundle.getState());\r\n    providerBundle.uninstall();\r\n    assertEquals(\"Couldn't stop the protocol provider bundle.\", Bundle.UNINSTALLED, providerBundle.getState());\r\n    providerBundle = GibberishSlickFixture.bc.installBundle(providerBundle.getLocation());\r\n    assertEquals(\"Couldn't re-install protocol provider bundle.\", Bundle.INSTALLED, providerBundle.getState());\r\n    AccountManagerUtils.startBundleAndWaitStoredAccountsLoaded(GibberishSlickFixture.bc, providerBundle, \"Gibberish\");\r\n    assertEquals(\"Couldn't re-start protocol provider bundle.\", Bundle.ACTIVE, providerBundle.getState());\r\n    ServiceReference[] gibberishProviderRefs = null;\r\n    try {\r\n        gibberishProviderRefs = GibberishSlickFixture.bc.getServiceReferences(ProtocolProviderService.class.getName(), \"(\" + ProtocolProviderFactory.PROTOCOL + \"=Gibberish)\");\r\n    } catch (InvalidSyntaxException ex) {\r\n        fail(\"We apparently got our filter wrong \" + ex.getMessage());\r\n    }\r\n    assertTrue(\"A Gibberish Protocol Provider Service was still regged \" + \"as an osgi service after it was explicitly uninstalled\", gibberishProviderRefs == null || gibberishProviderRefs.length == 0);\r\n    ServiceReference confReference = GibberishSlickFixture.bc.getServiceReference(ConfigurationService.class.getName());\r\n    ConfigurationService configurationService = (ConfigurationService) GibberishSlickFixture.bc.getService(confReference);\r\n    configurationService.purgeStoredConfiguration();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.history.HistoryWindow.getConversationContainerWindow",
	"Comment": "implements chatconversationcontainer.getwindow method.",
	"Method": "Window getConversationContainerWindow(){\r\n    return this;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.notifsource.NotificationContactSource.getNotifications",
	"Comment": "returns an iterator over a list of all notification contactscontained in the given group.",
	"Method": "Iterator<? extends UIContact> getNotifications(UIGroup group){\r\n    if (!(group instanceof NotificationGroup))\r\n        return null;\r\n    NotificationGroup notifGroup = (NotificationGroup) group;\r\n    return notifGroup.getNotifications();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.AbstractPacketExtension.getAttribute",
	"Comment": "returns the attribute with the specified name from the list ofattributes registered with this packet extension.",
	"Method": "Object getAttribute(String attribute){\r\n    synchronized (attributes) {\r\n        return attributes.get(attribute);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetContactTypeInfoImpl.getContactType",
	"Comment": "access the contact type. if none specified null is returned.",
	"Method": "String getContactType(Contact contact){\r\n    return contactList.getContactType(contact);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.WhiteboardSessionJabberImpl.fireWhiteboardChangeEvent",
	"Comment": "creates a whiteboardchangeevent with this class assourcewhiteboard,and the specified eventid and oldand new values anddispatches it on all currently registered listeners.",
	"Method": "void fireWhiteboardChangeEvent(String type,Object oldValue,Object newValue){\r\n    WhiteboardChangeEvent ccEvent = new WhiteboardChangeEvent(this, type, oldValue, newValue);\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Dispatching a WhiteboardChange event to \" + whiteboardListeners.size() + \" listeners. event is: \" + ccEvent.toString());\r\n    Iterable<WhiteboardChangeListener> listeners;\r\n    synchronized (whiteboardListeners) {\r\n        listeners = new ArrayList<WhiteboardChangeListener>(whiteboardListeners);\r\n    }\r\n    for (WhiteboardChangeListener listener : listeners) {\r\n        if (type.equals(WhiteboardChangeEvent.WHITEBOARD_STATE_CHANGE))\r\n            listener.whiteboardStateChanged(ccEvent);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.TreeContactList.removeMetaUIRootGroup",
	"Comment": "removes the ui group associated with the root meta contact group.",
	"Method": "void removeMetaUIRootGroup(){\r\n    if (rootUIGroup == null)\r\n        return;\r\n    GroupNode parentNode = treeModel.getRoot();\r\n    parentNode.removeContactGroup(rootUIGroup);\r\n    rootUIGroup = null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.caps.EntityCapsManager.addUserCapsNodeListener",
	"Comment": "adds a specific usercapsnodelistener to the list ofusercapsnodelisteners interested in events notifying aboutchanges in the list of user caps nodes of thisentitycapsmanager.",
	"Method": "void addUserCapsNodeListener(UserCapsNodeListener listener){\r\n    if (listener == null)\r\n        throw new NullPointerException(\"listener\");\r\n    synchronized (userCapsNodeListeners) {\r\n        if (!userCapsNodeListeners.contains(listener))\r\n            userCapsNodeListeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.OneToOneCallPanel.addCallPeerPanel",
	"Comment": "initializes and adds a new onetoonecallpeerpanel instance whichis to depict a specific callpeer on behalf of this instance.",
	"Method": "void addCallPeerPanel(CallPeer peer,UIVideoHandler2 uiVideoHandler){\r\n    if (peerPanel == null) {\r\n        peerPanel = new OneToOneCallPeerPanel(this, peer, uiVideoHandler);\r\n        nameLabel.setText(getPeerDisplayText(peer, peerPanel.getPeerName()));\r\n        topBar = createTopComponent();\r\n        topBar.setVisible(!isFullScreen());\r\n        topBar.add(nameLabel);\r\n        add(topBar, BorderLayout.NORTH);\r\n        add(peerPanel);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.gibberishaccregwizz.GibberishAccountRegistrationWizard.getProtocolName",
	"Comment": "implements the accountregistrationwizard.getprotocolnamemethod. returns the protocol name for this wizard.",
	"Method": "String getProtocolName(){\r\n    return Resources.getString(\"plugin.gibberishaccregwizz.PROTOCOL_NAME\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.contactsource.MetaUIContact.setParentGroup",
	"Comment": "sets the given parentgroup to be the parent uigroupof this metauicontact.",
	"Method": "void setParentGroup(UIGroup parentGroup){\r\n    parentUIGroup = parentGroup;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.RtcpFbPacketExtension.getFeedbackType",
	"Comment": "returns rtcp feedback type attribute value if already setor null otherwise.",
	"Method": "String getFeedbackType(){\r\n    return getAttributeAsString(TYPE_ATTR_NAME);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipMessageFactory.createRequest",
	"Comment": "calls the same method in the internal wrapped factoryand returns a request marked with its service.",
	"Method": "Request createRequest(URI requestURI,String method,CallIdHeader callId,CSeqHeader cSeq,FromHeader from,ToHeader to,List via,MaxForwardsHeader maxForwards,ContentTypeHeader contentType,Object content,Request createRequest,URI requestURI,String method,CallIdHeader callId,CSeqHeader cSeq,FromHeader from,ToHeader to,List via,MaxForwardsHeader maxForwards,ContentTypeHeader contentType,byte[] content,Request createRequest,URI requestURI,String method,CallIdHeader callId,CSeqHeader cSeq,FromHeader from,ToHeader to,List via,MaxForwardsHeader maxForwards,Request createRequest,String requestParam,Request createRequest,Dialog dialog,String method){\r\n    Request request = null;\r\n    try {\r\n        request = dialog.createRequest(method);\r\n    } catch (SipException ex) {\r\n        ProtocolProviderServiceSipImpl.throwOperationFailedException(\"Failed to create \" + method + \" request.\", OperationFailedException.INTERNAL_ERROR, ex, logger);\r\n    }\r\n    ArrayList<ViaHeader> viaHeaders = protocolProvider.getLocalViaHeaders(dialog.getRemoteParty());\r\n    request.setHeader(viaHeaders.get(0));\r\n    attachScSpecifics(request);\r\n    return request;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaAwareCall.addCallPeer",
	"Comment": "adds callpeer to the list of peers in this call.if the call peer is already included in the call, the method hasno effect.",
	"Method": "void addCallPeer(T callPeer){\r\n    if (!doAddCallPeer(callPeer))\r\n        return;\r\n    callPeer.addCallPeerListener(this);\r\n    synchronized (localUserAudioLevelListenersSyncRoot) {\r\n        List<T> callPeers = getCallPeerList();\r\n        if ((callPeers.size() == 1) && callPeers.get(0).equals(callPeer)) {\r\n            callPeer.getMediaHandler().setLocalUserAudioLevelListener(localAudioLevelDelegator);\r\n        }\r\n    }\r\n    fireCallPeerEvent(callPeer, CallPeerEvent.CALL_PEER_ADDED);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.jabber.JabberAccountRegistration.setRememberPassword",
	"Comment": "sets the rememberpassword value of this jabber account registration.",
	"Method": "void setRememberPassword(boolean rememberPassword){\r\n    this.rememberPassword = rememberPassword;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.history.HistoryQueryImpl.fireQueryStatusEvent",
	"Comment": "notifies all registered historyquerylisteners that a new recordhas been received.",
	"Method": "void fireQueryStatusEvent(int newStatus){\r\n    HistoryQueryStatusEvent event = new HistoryQueryStatusEvent(this, newStatus);\r\n    synchronized (queryListeners) {\r\n        for (HistoryQueryListener l : queryListeners) {\r\n            l.queryStatusChanged(event);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.jabberaccregwizz.JabberAccountRegistrationWizard.getProtocolName",
	"Comment": "implements the accountregistrationwizard.getprotocolnamemethod. returns the protocol name for this wizard.",
	"Method": "String getProtocolName(){\r\n    return Resources.getString(\"plugin.jabberaccregwizz.PROTOCOL_NAME\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ServerStoredContactList.getAllContacts",
	"Comment": "returns all avaliable contacts from group and all subgroups.",
	"Method": "List<ContactSipImpl> getAllContacts(ContactGroupSipImpl group){\r\n    List<ContactSipImpl> contacts = new ArrayList<ContactSipImpl>();\r\n    Iterator<ContactGroup> groupIterator = group.subgroups();\r\n    while (groupIterator.hasNext()) {\r\n        contacts.addAll(getAllContacts((ContactGroupSipImpl) groupIterator.next()));\r\n    }\r\n    Iterator<Contact> contactIterator = group.contacts();\r\n    while (contactIterator.hasNext()) {\r\n        ContactSipImpl contact = (ContactSipImpl) contactIterator.next();\r\n        contacts.add(contact);\r\n    }\r\n    return contacts;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.sipaccregwizz.SIPAccountRegistrationForm.setServerFieldAccordingToUIN",
	"Comment": "parse the server part from the sip id and set it to server as defaultvalue. if advanced option is enabled do nothing.",
	"Method": "String setServerFieldAccordingToUIN(String userName){\r\n    String serverAddress = SipAccountID.getServerFromUserName(userName);\r\n    connectionPanel.setServerFieldAccordingToUIN(serverAddress);\r\n    return serverAddress;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.menus.ViewMenu.pluginComponentRemoved",
	"Comment": "indicates that a plugin component has been removed. removes it from thiscontainer if it is contained in it.",
	"Method": "void pluginComponentRemoved(PluginComponentEvent event){\r\n    PluginComponentFactory c = event.getPluginComponentFactory();\r\n    if (c.getContainer().equals(Container.CONTAINER_VIEW_MENU)) {\r\n        this.remove((Component) c.getPluginComponentInstance(ViewMenu.this).getComponent());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.TestOperationSetBasicInstantMessaging.prepareContactList",
	"Comment": "create the list to be sure that contacts exchanging messagesexists in each other lists",
	"Method": "void prepareContactList(){\r\n    fixture.clearProvidersLists();\r\n    Object o = new Object();\r\n    synchronized (o) {\r\n        o.wait(2000);\r\n    }\r\n    try {\r\n        opSetPresence1.subscribe(fixture.userID2);\r\n    } catch (OperationFailedException ex) {\r\n    }\r\n    try {\r\n        opSetPresence2.subscribe(fixture.userID1);\r\n    } catch (OperationFailedException ex1) {\r\n    }\r\n    logger.info(\"will wait till the list prepare is completed\");\r\n    synchronized (o) {\r\n        o.wait(4000);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaAwareCall.removeCallPeer",
	"Comment": "removes callpeer from the list of peers in this call. the methodhas no effect if there was no such peer in the call.",
	"Method": "void removeCallPeer(CallPeerChangeEvent evt){\r\n    @SuppressWarnings(\"unchecked\")\r\n    T callPeer = (T) evt.getSourceCallPeer();\r\n    if (!doRemoveCallPeer(callPeer))\r\n        return;\r\n    callPeer.removeCallPeerListener(this);\r\n    synchronized (localUserAudioLevelListenersSyncRoot) {\r\n        callPeer.getMediaHandler().setLocalUserAudioLevelListener(null);\r\n        List<T> callPeers = getCallPeerList();\r\n        if (!callPeers.isEmpty()) {\r\n            callPeers.get(0).getMediaHandler().setLocalUserAudioLevelListener(localAudioLevelDelegator);\r\n        }\r\n    }\r\n    try {\r\n        fireCallPeerEvent(callPeer, CallPeerEvent.CALL_PEER_REMOVED, (evt.getReasonString() != null));\r\n    } finally {\r\n        callPeer.setCall(null);\r\n    }\r\n    if (getCallPeerCount() == 0)\r\n        setCallState(CallState.CALL_ENDED, evt);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.contactsource.AbstractContactQuery.fireContactRemoved",
	"Comment": "notifies the contactquerylisteners registered with thiscontactquery that a sourcecontact has beenremoved.",
	"Method": "void fireContactRemoved(SourceContact contact){\r\n    ContactQueryListener[] ls;\r\n    synchronized (listeners) {\r\n        ls = listeners.toArray(new ContactQueryListener[listeners.size()]);\r\n    }\r\n    ContactRemovedEvent ev = new ContactRemovedEvent(this, contact);\r\n    for (ContactQueryListener l : ls) l.contactRemoved(ev);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.MessageDeliveredEvent.getTimestamp",
	"Comment": "a timestamp indicating the exact date when the event occurred.",
	"Method": "Date getTimestamp(){\r\n    return timestamp;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.CallConference.callAdded",
	"Comment": "notifies this callconference that a specific call hasbeen added to the list of calls participating in this telephonyconference.",
	"Method": "void callAdded(Call call){\r\n    call.addCallChangeListener(callChangeListener);\r\n    addCallPeerConferenceListener(call);\r\n    boolean conferenceFocus = isConferenceFocus(getCalls());\r\n    if (conferenceFocus)\r\n        setConferenceFocus(conferenceFocus);\r\n    firePropertyChange(CALLS, null, call);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.MediaAwareCall.getRTPTranslator",
	"Comment": "gets the rtptranslator which forwards rtp and rtcp trafficbetween the callpeers of this call when the localpeer represented by this call is acting as a conference focus.",
	"Method": "RTPTranslator getRTPTranslator(MediaType mediaType){\r\n    return getConference().getRTPTranslator(mediaType);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.IrcStack.createServer",
	"Comment": "create matching ircserver instances based on connection parameters.",
	"Method": "IRCServer createServer(ClientConfig config,String host,int port,boolean secureConnection,String password){\r\n    final IRCServer server;\r\n    if (secureConnection) {\r\n        server = new SecureIRCServer(host, port, password, getCustomSSLContext(host), config.getProxy(), config.isResolveByProxy());\r\n    } else {\r\n        server = new IRCServer(host, port, password, false, config.getProxy(), config.isResolveByProxy());\r\n    }\r\n    return server;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.generalconfig.OpusConfigForm.actionPerformed",
	"Comment": "action listener for the checkboxes, buttons and comboboxes. updatesthe configuration service with the appropriate new value.",
	"Method": "void actionPerformed(ActionEvent actionEvent){\r\n    Object source = actionEvent.getSource();\r\n    if (source == restoreButton) {\r\n        restoreDefaults();\r\n    } else if (source == bandwidthCombobox) {\r\n        configurationService.setProperty(Constants.PROP_OPUS_BANDWIDTH, BANDWIDTHS[bandwidthCombobox.getSelectedIndex()]);\r\n    } else if (source == dtxCheckbox) {\r\n        configurationService.setProperty(Constants.PROP_OPUS_DTX, dtxCheckbox.isSelected());\r\n    } else if (source == fecCheckbox) {\r\n        configurationService.setProperty(Constants.PROP_OPUS_FEC, fecCheckbox.isSelected());\r\n    } else if (source == complexityCombobox) {\r\n        Object selectedItem = complexityCombobox.getSelectedItem();\r\n        String complexity = (selectedItem == null) ? null : selectedItem.toString();\r\n        if ((complexity == null) || (complexity.length() == 0)) {\r\n            configurationService.removeProperty(Constants.PROP_OPUS_COMPLEXITY);\r\n        } else {\r\n            configurationService.setProperty(Constants.PROP_OPUS_COMPLEXITY, complexity);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.RenameContactDialog.actionPerformed",
	"Comment": "handles the actionevent. in order to rename the contact invokesthe renamemetacontact method of the currentmetacontactlistservice.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    JButton button = (JButton) e.getSource();\r\n    String name = button.getName();\r\n    if (name.equals(\"rename\")) {\r\n        if (metaContact != null) {\r\n            new Thread() {\r\n                @Override\r\n                public void run() {\r\n                    clist.renameMetaContact(metaContact, renameContactPanel.getNewName());\r\n                }\r\n            }.start();\r\n        }\r\n    } else if (name.equals(\"clear\")) {\r\n        clist.clearUserDefinedDisplayName(metaContact);\r\n    }\r\n    this.dispose();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.RenameContactDialog.actionPerformed",
	"Comment": "handles the actionevent. in order to rename the contact invokesthe renamemetacontact method of the currentmetacontactlistservice.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    clist.renameMetaContact(metaContact, renameContactPanel.getNewName());\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.AvatarEvent.getSourceAvatarOperationSet",
	"Comment": "returns the operationsetavatar instance that is the sourceof this event.",
	"Method": "OperationSetAvatar getSourceAvatarOperationSet(){\r\n    return (OperationSetAvatar) getSource();\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.history.TestHistoryService.testCreatingHistoryIDFromFS",
	"Comment": "test of method createfromrawstrings, used when we read history foldersfrom fs and from their names want to recreate history.",
	"Method": "void testCreatingHistoryIDFromFS(){\r\n    testHistoryIDCreate(new String[] { \"test1\", \"alltests1\" });\r\n    testHistoryIDCreate(new String[] { \"test2\", \"alltests2\", \"Jabber:mincho.penchev@jit.si@jit.si\" });\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.CallJabberImpl.closeColibriStreamConnector",
	"Comment": "closes a specific colibristreamconnector which is associated witha mediastream of a specific mediatype upon request froma specific callpeer.",
	"Method": "void closeColibriStreamConnector(CallPeerJabberImpl peer,MediaType mediaType,ColibriStreamConnector colibriStreamConnector){\r\n    colibriStreamConnector.close();\r\n    synchronized (colibriStreamConnectors) {\r\n        int index = mediaType.ordinal();\r\n        WeakReference<ColibriStreamConnector> weakReference = colibriStreamConnectors.get(index);\r\n        if (weakReference != null && colibriStreamConnector.equals(weakReference.get())) {\r\n            colibriStreamConnectors.set(index, null);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.UserCredentials.getPasswordAsString",
	"Comment": "returns a string containing the password associated with this set ofcredentials.",
	"Method": "String getPasswordAsString(){\r\n    return new String(password);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.OperationSetBasicTelephonyGibberishImpl.getProtocolProvider",
	"Comment": "returns the protocol provider that this operation set belongs to.",
	"Method": "ProtocolProviderServiceGibberishImpl getProtocolProvider(){\r\n    return protocolProvider;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.launchutils.LaunchArgHandler.handleDebugArg",
	"Comment": "instructs sip communicator to print logging messages to the console.",
	"Method": "void handleDebugArg(String arg){\r\n    ScStdOut.setStdOutPrintingEnabled(true);\r\n    java.util.logging.Logger rootLogger = java.util.logging.Logger.getAnonymousLogger().getParent();\r\n    ConsoleHandler conHan = null;\r\n    for (Handler handler : rootLogger.getHandlers()) {\r\n        if (handler instanceof ConsoleHandler) {\r\n            conHan = (ConsoleHandler) handler;\r\n            break;\r\n        }\r\n    }\r\n    if (conHan == null) {\r\n        conHan = new ConsoleHandler();\r\n        rootLogger.addHandler(conHan);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ServerStoredContactListIcqImpl.fireContactResolved",
	"Comment": "make the parent persistent presence operation set dispatch a contactresolved event.",
	"Method": "void fireContactResolved(ContactGroup parentGroup,Contact contact){\r\n    if (parentOperationSet == null) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"No presence op. set available. Bailing out.\");\r\n        return;\r\n    }\r\n    parentOperationSet.fireSubscriptionEvent(contact, parentGroup, SubscriptionEvent.SUBSCRIPTION_RESOLVED);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.AdHocChatRoomInvitationRejectedEvent.getChatRoom",
	"Comment": "returns the adhocchatroom for which the initial invitation was.",
	"Method": "AdHocChatRoom getChatRoom(){\r\n    return adHocChatRoom;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ProtocolProviderServiceIcqImpl.unregister",
	"Comment": "ends the registration of this protocol provider with the service.",
	"Method": "void unregister(){\r\n    fireRegistrationStateChanged(getRegistrationState(), RegistrationState.UNREGISTERING, RegistrationStateChangeEvent.REASON_USER_REQUEST, null);\r\n    if (aimConnection != null)\r\n        aimConnection.disconnect(true);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.dns.ParallelResolverImpl.setIgnoreTruncation",
	"Comment": "sets whether truncated responses will be ignored.if not, a truncatedresponse over udp will cause a retransmission over tcp. backup serverswould always be contacted the same way.",
	"Method": "void setIgnoreTruncation(boolean flag){\r\n    defaultResolver.setIgnoreTruncation(flag);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.OperationSetPersistentPresenceGibberishImpl.createUnresolvedContact",
	"Comment": "creates and returns a unresolved contact from the specifiedaddress and persistentdata. the method will not tryto establish a network connection and resolve the newly created contactagainst the server. the protocol provider may will later try and resolvethe contact. when this happens the corresponding event would notifyinterested subscription listeners.",
	"Method": "Contact createUnresolvedContact(String address,String persistentData,Contact createUnresolvedContact,String address,String persistentData,ContactGroup parent){\r\n    ContactGibberishImpl contact = new ContactGibberishImpl(address, parentProvider);\r\n    contact.setResolved(false);\r\n    ((ContactGroupGibberishImpl) parent).addContact(contact);\r\n    fireSubscriptionEvent(contact, parent, SubscriptionEvent.SUBSCRIPTION_CREATED);\r\n    fireSubscriptionEvent(contact, parent, SubscriptionEvent.SUBSCRIPTION_RESOLVED);\r\n    changePresenceStatusForContact(contact, getPresenceStatus());\r\n    return contact;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.Entities.entityName",
	"Comment": "returns the name of the entity identified by the specified value.",
	"Method": "String entityName(int value){\r\n    return map.name(value);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.RtpDescriptionPacketExtension.getEncryption",
	"Comment": "returns the optional encryption element that contains encryptionparameters for this session.",
	"Method": "EncryptionPacketExtension getEncryption(){\r\n    return encryption;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.GenericUIContactImpl.setContactCustomActionButtons",
	"Comment": "sets all custom action buttons for this notification contact.",
	"Method": "void setContactCustomActionButtons(Collection<SIPCommButton> buttonsList){\r\n    this.customActionButtons = buttonsList;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.EncryptionPacketExtension.isRequired",
	"Comment": "returns true if encryption is required for this session andfalse otherwise. default value is false.",
	"Method": "boolean isRequired(){\r\n    String required = getAttributeAsString(REQUIRED_ATTR_NAME);\r\n    return Boolean.valueOf(required) || \"1\".equals(required);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.transparent.TransparentFrame.createTransparentFrame",
	"Comment": "creates a transparent undecorated frame. if the transparency is notsupported creates a normal undecorated frame.",
	"Method": "TransparentFrame createTransparentFrame(){\r\n    isTranslucencySupported = AWTUtilitiesWrapper.isTranslucencySupported(AWTUtilitiesWrapper.PERPIXEL_TRANSLUCENT);\r\n    GraphicsConfiguration translucencyCapableGC = GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice().getDefaultConfiguration();\r\n    if (!AWTUtilitiesWrapper.isTranslucencyCapable(translucencyCapableGC)) {\r\n        translucencyCapableGC = null;\r\n        GraphicsEnvironment env = GraphicsEnvironment.getLocalGraphicsEnvironment();\r\n        GraphicsDevice[] devices = env.getScreenDevices();\r\n        for (int i = 0; i < devices.length && translucencyCapableGC == null; i++) {\r\n            GraphicsConfiguration[] configs = devices[i].getConfigurations();\r\n            for (int j = 0; j < configs.length && translucencyCapableGC == null; j++) {\r\n                if (AWTUtilitiesWrapper.isTranslucencyCapable(configs[j])) {\r\n                    translucencyCapableGC = configs[j];\r\n                }\r\n            }\r\n        }\r\n        if (translucencyCapableGC == null) {\r\n            isTranslucencySupported = false;\r\n        }\r\n    }\r\n    if (isTranslucencySupported)\r\n        return new TransparentFrame(translucencyCapableGC);\r\n    return new TransparentFrame();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.history.SearchPanel.actionPerformed",
	"Comment": "handles the actionevent which occurred when user clicksthe search button.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    JButton button = (JButton) e.getSource();\r\n    String buttonName = button.getName();\r\n    if (buttonName.equalsIgnoreCase(\"search\")) {\r\n        historyWindow.showHistoryByKeyword(searchTextField.getText());\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chatroomslist.createforms.SelectAccountPanel.addCheckBoxCellListener",
	"Comment": "adds a celleditorlistener to the list of account, which willlisten for events triggered by user clicks on the check boxes in thefirst column of the accounts table.",
	"Method": "void addCheckBoxCellListener(CellEditorListener l){\r\n    if (accountsTable.getModel().getRowCount() != 0) {\r\n        accountsTable.getCellEditor(0, 0).addCellEditorListener(l);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.utils.PluginContainer.removePluginComponent",
	"Comment": "removes the component of a specific plugincomponent fromthis plugincontainer.",
	"Method": "void removePluginComponent(PluginComponentFactory factory){\r\n    Iterator<PluginComponent> iterator = pluginComponents.iterator();\r\n    while (iterator.hasNext()) {\r\n        PluginComponent c = iterator.next();\r\n        if (c.getParentFactory().equals(factory)) {\r\n            iterator.remove();\r\n            container.remove((Component) c.getComponent());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chatroomslist.joinforms.SearchChatRoomPanel.setChatRoomProvider",
	"Comment": "sets the protocol provider that have been chosen by user on the firstpage of the join chat room wizard.",
	"Method": "void setChatRoomProvider(ChatRoomProviderWrapper provider){\r\n    this.chatRoomProvider = provider;\r\n    serverRooms = GuiActivator.getMUCService().getExistingChatRooms(chatRoomProvider);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler.isMute",
	"Comment": "determines whether the audio stream of this media handler is currentlyon mute.",
	"Method": "boolean isMute(){\r\n    MediaStream audioStream = getStream(MediaType.AUDIO);\r\n    return (audioStream != null) && audioStream.isMute();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockContactGroup.isPersistent",
	"Comment": "determines whether or not this contact group is being stored by theserver. non persistent contact groups exist for the sole purpose ofcontaining non persistent contacts.",
	"Method": "boolean isPersistent(){\r\n    return isPersistent;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockPersistentPresenceOperationSet.addMockGroupAndFireEvent",
	"Comment": "a mock provider method to use for fast filling of a contact list. thismethod would add both the group and fire an event.",
	"Method": "void addMockGroupAndFireEvent(MockContactGroup parent,MockContactGroup contactGroup){\r\n    parent.addSubgroup(contactGroup);\r\n    this.fireServerStoredGroupEvent(contactGroup, ServerStoredGroupEvent.GROUP_CREATED_EVENT);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.UIServiceImpl.resize",
	"Comment": "implements resize in the uiservice interface. resizes themain application window.",
	"Method": "void resize(int width,int height){\r\n    this.mainFrame.setSize(width, height);\r\n}"
}, {
	"Path": "net.librec.recommender.cf.UserKNNTestCase.test18SplitterLOOCVUserDate",
	"Comment": "test loocvdatasplitter with user date, evaluating enabled.",
	"Method": "void test18SplitterLOOCVUserDate(){\r\n    Resource resource = new Resource(\"rec/cf/userknn-test.properties\");\r\n    conf.addResource(resource);\r\n    conf.set(\"data.model.splitter\", \"loocv\");\r\n    conf.set(\"data.input.path\", \"test/datamodeltest/ratings-date.txt\");\r\n    conf.set(\"data.column.format\", \"UIRT\");\r\n    conf.set(\"data.splitter.loocv\", \"userdate\");\r\n    RecommenderJob job = new RecommenderJob(conf);\r\n    job.runJob();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapDirectorySettingsImpl.setEnabled",
	"Comment": "simple setter for enabled. required by ldapdirectorysettings interface.",
	"Method": "void setEnabled(boolean enabled){\r\n    this.enabled = enabled;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.muc.BaseChatRoomSourceContact.getChatRoomName",
	"Comment": "returns the name of the chat room associated with the contact.",
	"Method": "String getChatRoomName(){\r\n    return chatRoomName;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.colibri.ColibriConferenceIQ.getEndpoints",
	"Comment": "returns the list of endpoints included in thiscolibriconferenceiq.",
	"Method": "List<Endpoint> getEndpoints(){\r\n    return Collections.unmodifiableList(endpoints);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.customcontrols.TitlePanel.paintComponent",
	"Comment": "overrides the paintcomponent method of jpanel topaint a gradient background of this panel.",
	"Method": "void paintComponent(Graphics g){\r\n    Graphics2D g2 = (Graphics2D) g;\r\n    AntialiasingManager.activateAntialiasing(g2);\r\n    int width = getWidth();\r\n    int height = getHeight();\r\n    GradientPaint p = new GradientPaint(width / 2, 0, gradientStartColor, width / 2, height, gradientEndColor);\r\n    g2.setPaint(p);\r\n    g2.fillRoundRect(0, 0, width, height, 10, 10);\r\n    super.paintComponent(g2);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.contactlist.MetaContactListServiceLick.start",
	"Comment": "start, init and register the slick. create the mock protocol providerand register it as a service.",
	"Method": "void start(BundleContext context){\r\n    MclSlickFixture.bundleContext = context;\r\n    setName(\"MetaContactListServiceLick\");\r\n    Hashtable<String, String> slickServiceProperties = new Hashtable<String, String>();\r\n    slickServiceProperties.put(\"service.pid\", getName());\r\n    logger.debug(\"Service  \" + getClass().getName() + \" [  STARTED ]\");\r\n    MockProvider provider = new MockProvider(\"SlickMockUser\");\r\n    fillMockContactList(provider);\r\n    MclSlickFixture.mockPrServiceRegistration = registerMockProviderService(provider);\r\n    MclSlickFixture.mockProvider = provider;\r\n    MclSlickFixture.mockPresOpSet = (MockPersistentPresenceOperationSet) MclSlickFixture.mockProvider.getOperationSet(OperationSetPersistentPresence.class);\r\n    addTestSuite(TestMetaContactList.class);\r\n    addTestSuite(TestMetaContact.class);\r\n    addTestSuite(TestMetaContactGroup.class);\r\n    addTest(TestSupportForMultipleProviders.suite());\r\n    addTest(TestMetaContactListPersistence.suite());\r\n    context.registerService(getClass().getName(), this, slickServiceProperties);\r\n    logger.debug(\"Service  \" + getClass().getName() + \" [REGISTERED]\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipActivator.getConfigurationService",
	"Comment": "returns a reference to a configurationservice implementation currentlyregistered in the bundle context or null if no such implementation wasfound.",
	"Method": "ConfigurationService getConfigurationService(){\r\n    if (configurationService == null) {\r\n        ServiceReference confReference = bundleContext.getServiceReference(ConfigurationService.class.getName());\r\n        configurationService = (ConfigurationService) bundleContext.getService(confReference);\r\n    }\r\n    return configurationService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomJabberImpl.removelocalUserRoleListener",
	"Comment": "removes a listener that was being notified of changes in our role in thischat room such as us being granded operator.",
	"Method": "void removelocalUserRoleListener(ChatRoomLocalUserRoleListener listener){\r\n    synchronized (localUserRoleListeners) {\r\n        localUserRoleListeners.remove(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.OperationSetPersistentPresenceGibberishImpl.getPresenceStatus",
	"Comment": "returns a presencestatus instance representing the state this provideris currently in.",
	"Method": "PresenceStatus getPresenceStatus(){\r\n    return presenceStatus;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractOperationSetContactCapabilities.addContactCapabilitiesListener",
	"Comment": "registers a specific contactcapabilitieslistener to be notifiedabout changes in the list of operationset capabilities ofcontacts. if the specified listener has already beenregistered, adding it again has no effect.",
	"Method": "void addContactCapabilitiesListener(ContactCapabilitiesListener listener){\r\n    if (listener == null)\r\n        throw new NullPointerException(\"listener\");\r\n    synchronized (contactCapabilitiesListeners) {\r\n        if (!contactCapabilitiesListeners.contains(listener))\r\n            contactCapabilitiesListeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl.isSecure",
	"Comment": "returns true to indicate that the call associated with thegiven peer is secured, otherwise returns false.",
	"Method": "boolean isSecure(CallPeer peer){\r\n    return ((CallPeerSipImpl) peer).getMediaHandler().isSecure();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetAdHocMultiUserChatIcqImpl.fireLocalUserPresenceEvent",
	"Comment": "delivers a localuseradhocchatroompresencechangeevent to allregistered localuseradhocchatroompresencelisteners.",
	"Method": "void fireLocalUserPresenceEvent(AdHocChatRoom chatRoom,String eventType,String reason){\r\n    LocalUserAdHocChatRoomPresenceChangeEvent evt = new LocalUserAdHocChatRoomPresenceChangeEvent(this, chatRoom, eventType, reason);\r\n    Iterable<LocalUserAdHocChatRoomPresenceListener> listeners = null;\r\n    synchronized (presenceListeners) {\r\n        listeners = new ArrayList<LocalUserAdHocChatRoomPresenceListener>(presenceListeners);\r\n    }\r\n    for (LocalUserAdHocChatRoomPresenceListener listener : listeners) listener.localUserAdHocPresenceChanged(evt);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ContactGroupSipImpl.getParentContactGroup",
	"Comment": "returns the contact group that currently contains this group or null ifthis is the root contact group.",
	"Method": "ContactGroup getParentContactGroup(){\r\n    return this.parentGroup;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.ContactGroupGibberishImpl.findGroupParent",
	"Comment": "returns the group that is parent of the specified gibberishgroup or nullif no parent was found.",
	"Method": "ContactGroupGibberishImpl findGroupParent(ContactGroupGibberishImpl gibberishGroup){\r\n    if (subGroups.contains(gibberishGroup))\r\n        return this;\r\n    Iterator<ContactGroup> subGroupsIter = subgroups();\r\n    while (subGroupsIter.hasNext()) {\r\n        ContactGroupGibberishImpl subgroup = (ContactGroupGibberishImpl) subGroupsIter.next();\r\n        ContactGroupGibberishImpl parent = subgroup.findGroupParent(gibberishGroup);\r\n        if (parent != null)\r\n            return parent;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.history.HistoryServiceImpl.isSubHistory",
	"Comment": "checks the ids of the parent, do they exist in the supplied history ids.if it exist the history is sub history of the on with the supplied ids.",
	"Method": "boolean isSubHistory(String[] parentIDs,HistoryID hid){\r\n    String[] hids = hid.getID();\r\n    if (hids.length < parentIDs.length)\r\n        return false;\r\n    for (int i = 0; i < parentIDs.length; i++) {\r\n        if (!parentIDs[i].equals(hids[i]))\r\n            return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "net.librec.recommender.cf.UserKNNTestCase.test09SplitterRatioUserDate",
	"Comment": "test ratiodatasplitter with user date ratio, evaluating enabled.",
	"Method": "void test09SplitterRatioUserDate(){\r\n    Resource resource = new Resource(\"rec/cf/userknn-test.properties\");\r\n    conf.addResource(resource);\r\n    conf.set(\"rec.eval.enable\", \"true\");\r\n    conf.set(\"data.model.splitter\", \"ratio\");\r\n    conf.set(\"data.input.path\", \"test/datamodeltest/ratings-date.txt\");\r\n    conf.set(\"data.column.format\", \"UIRT\");\r\n    conf.set(\"data.splitter.ratio\", \"userdate\");\r\n    RecommenderJob job = new RecommenderJob(conf);\r\n    job.runJob();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.OperationSetPersistentPresenceIcqImpl.addServerStoredGroupChangeListener",
	"Comment": "registers a listener that would receive events upong changes in serverstored groups.",
	"Method": "void addServerStoredGroupChangeListener(ServerStoredGroupListener listener){\r\n    ssContactList.addGroupListener(listener);\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AccountID.getAccountProperties",
	"Comment": "returns a map containing protocol and implementation accountinitialization properties.",
	"Method": "Map<String, String> getAccountProperties(){\r\n    return new HashMap<String, String>(accountProperties);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.gibberish.OperationSetPersistentPresenceGibberishImpl.renameServerStoredContactGroup",
	"Comment": "renames the specified group from the server stored contact list.",
	"Method": "void renameServerStoredContactGroup(ContactGroup group,String newName){\r\n    ((ContactGroupGibberishImpl) group).setGroupName(newName);\r\n    this.fireServerStoredGroupEvent(group, ServerStoredGroupEvent.GROUP_RENAMED_EVENT);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ContactGroupJabberImpl.contacts",
	"Comment": "returns an iterator over all contacts, member of thiscontactgroup.",
	"Method": "Iterator<Contact> contacts(){\r\n    return buddies.values().iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.Base64.encode",
	"Comment": "encode the byte data to base 64 writing it to the given output stream.",
	"Method": "byte[] encode(byte[] data,int encode,byte[] data,OutputStream out,int encode,byte[] data,int off,int length,OutputStream out,int encode,byte[] data,int off,int length,OutputStream out){\r\n    return encoder.encode(data, off, length, out);\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.launchutils.SipCommunicatorLock.interInstanceConnect",
	"Comment": "initializes a client tcp socket, connects if to sockaddr andsends all args to it.",
	"Method": "int interInstanceConnect(InetSocketAddress sockAddr,String[] args){\r\n    try {\r\n        Socket interInstanceSocket = new Socket(sockAddr.getAddress(), sockAddr.getPort());\r\n        LockClient lockClient = new LockClient(interInstanceSocket);\r\n        lockClient.start();\r\n        PrintStream printStream = new PrintStream(interInstanceSocket.getOutputStream());\r\n        printStream.print(ARG_COUNT + \"=\" + args.length + CRLF);\r\n        for (int i = 0; i < args.length; i++) {\r\n            printStream.print(ARGUMENT + \"=\" + args[i] + CRLF);\r\n        }\r\n        lockClient.waitForReply(LOCK_COMMUNICATION_DELAY);\r\n        String serverReadArgCountStr = lockClient.message.substring((ARG_COUNT + \"=\").length());\r\n        int serverReadArgCount = Integer.parseInt(serverReadArgCountStr);\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Server read \" + serverReadArgCount + \" args.\");\r\n        if (serverReadArgCount != args.length)\r\n            return LOCK_ERROR;\r\n        printStream.flush();\r\n        printStream.close();\r\n        interInstanceSocket.close();\r\n    } catch (Exception e) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Failed to connect to a running sc instance.\");\r\n        return LOCK_ERROR;\r\n    }\r\n    return SUCCESS;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.OperationSetBasicInstantMessagingJabberImpl.nextThreadID",
	"Comment": "returns the next unique thread id. each thread id made up of a shortalphanumeric prefix along with a unique numeric value.",
	"Method": "String nextThreadID(){\r\n    return prefix + Long.toString(id++);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.whiteboard.gui.whiteboardshapes.WhiteboardShapeImage.getBackgroundImage",
	"Comment": "returns a binary array containing the image that should be displayed asthe background of this whiteboardobject.",
	"Method": "byte[] getBackgroundImage(){\r\n    return bytes;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWindowManager.getContactChat",
	"Comment": "gets the chatpanel corresponding to the specifiedmetacontact and optionally creates it if it does not exist.must be executed on the event dispatch thread as it is creating ui.",
	"Method": "ChatPanel getContactChat(MetaContact metaContact,boolean create,ChatPanel getContactChat,MetaContact metaContact,boolean create,String escapedMessageID,ChatPanel getContactChat,MetaContact metaContact,Contact protocolContact,ChatPanel getContactChat,MetaContact metaContact,Contact protocolContact,ContactResource contactResource,String escapedMessageID,ChatPanel getContactChat,MetaContact metaContact,Contact protocolContact,ContactResource contactResource,boolean create,String escapedMessageID){\r\n    synchronized (chatSyncRoot) {\r\n        ChatPanel chatPanel = findChatPanelForDescriptor(metaContact);\r\n        if ((chatPanel == null) && create)\r\n            chatPanel = createChat(metaContact, protocolContact, contactResource, escapedMessageID);\r\n        return chatPanel;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.argdelegation.ArgDelegationActivator.start",
	"Comment": "starts the arg delegation bundle and registers the delegationpeer withthe util package uri manager.",
	"Method": "void start(Object dependentService){\r\n    delegationPeer = new ArgDelegationPeerImpl(bundleContext);\r\n    bundleContext.addServiceListener(delegationPeer);\r\n    LaunchArgHandler.getInstance().setDelegationPeer(delegationPeer);\r\n    if (OSUtils.IS_MAC) {\r\n        Application application = Application.getApplication();\r\n        if (application != null) {\r\n            try {\r\n                Method method = application.getClass().getMethod(\"setOpenURIHandler\", OpenURIHandler.class);\r\n                OpenURIHandler handler = new OpenURIHandler() {\r\n                    public void openURI(com.apple.eawt.AppEvent.OpenURIEvent evt) {\r\n                        delegationPeer.handleUri(evt.getURI().toString());\r\n                    }\r\n                };\r\n                method.invoke(application, handler);\r\n            } catch (Throwable ex) {\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.argdelegation.ArgDelegationActivator.start",
	"Comment": "starts the arg delegation bundle and registers the delegationpeer withthe util package uri manager.",
	"Method": "void start(Object dependentService){\r\n    delegationPeer.handleUri(evt.getURI().toString());\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.RegistrationState.equals",
	"Comment": "returns true if the specified object is equal to this provider state.",
	"Method": "boolean equals(Object obj){\r\n    return obj instanceof RegistrationState && obj != null && statusString.equals(((RegistrationState) obj).statusString);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.mock.MockPersistentPresenceOperationSet.removeServerStoredContactGroup",
	"Comment": "removes the specified group from the server stored contact list.",
	"Method": "void removeServerStoredContactGroup(ContactGroup group){\r\n    MockContactGroup mockGroup = (MockContactGroup) group;\r\n    MockContactGroup parent = findGroupParent(mockGroup);\r\n    if (parent == null) {\r\n        throw new IllegalArgumentException(\"group \" + group + \" does not seem to belong to this protocol's contact list.\");\r\n    }\r\n    parent.removeSubGroup(mockGroup);\r\n    this.fireServerStoredGroupEvent(mockGroup, ServerStoredGroupEvent.GROUP_REMOVED_EVENT);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ScServiceDiscoveryManager.addFeature",
	"Comment": "registers that a new feature is supported by this xmpp entity. when thisclient is queried for its information the registered features will beanswered.since no packet is actually sent to the server it is safe to performthis operation before logging to the server. in fact, you may want toconfigure the supported features before logging to the server so thatthe information is already available if it is required upon login.",
	"Method": "void addFeature(String feature){\r\n    synchronized (features) {\r\n        features.add(feature);\r\n        discoveryManager.addFeature(feature);\r\n    }\r\n    updateEntityCapsVersion();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomJabberImpl.revokeModerator",
	"Comment": "revokes moderator privileges from another user. the occupant that loses moderator privileges will become a participant. room administrators may revoke moderator privileges only to occupants whose affiliation is member or none. this means that an administrator is not allowed to revoke moderator privileges from other room administrators or owners.",
	"Method": "void revokeModerator(String nickname){\r\n    try {\r\n        multiUserChat.revokeModerator(nickname);\r\n    } catch (XMPPException ex) {\r\n        logger.error(\"n error occurs revoking moderator \" + \"privileges from a user\", ex);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ContactGroupJabberImpl.getPersistentData",
	"Comment": "returns null as no persistent data is required and the contact address issufficient for restoring the contact.",
	"Method": "String getPersistentData(){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.phonenumbercontactsource.PNContactSourceActivator.handleProviderAdded",
	"Comment": "handles the registration of a new protocolproviderservice. addsthe given protocolprovider to the list of queried providers.",
	"Method": "void handleProviderAdded(ProtocolProviderService protocolProvider){\r\n    if (protocolProvider.getOperationSet(OperationSetServerStoredContactInfo.class) != null && !phoneProviders.contains(protocolProvider)) {\r\n        if (protocolProvider.isRegistered()) {\r\n            phoneProviders.add(protocolProvider);\r\n        } else {\r\n            protocolProvider.addRegistrationStateChangeListener(ppRegListener);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomIrcImpl.fireMemberRoleEvent",
	"Comment": "creates the corresponding chatroommemberrolechangeevent and notifiesall chatroommemberrolelisteners that a chatroommember haschanged his role in this chatroom.",
	"Method": "void fireMemberRoleEvent(ChatRoomMember member,ChatRoomMemberRole newRole){\r\n    member.setRole(newRole);\r\n    ChatRoomMemberRole previousRole = member.getRole();\r\n    ChatRoomMemberRoleChangeEvent evt = new ChatRoomMemberRoleChangeEvent(this, member, previousRole, newRole);\r\n    if (LOGGER.isTraceEnabled()) {\r\n        LOGGER.trace(\"Will dispatch the following ChatRoom event: \" + evt);\r\n    }\r\n    Iterable<ChatRoomMemberRoleListener> listeners;\r\n    synchronized (memberRoleListeners) {\r\n        listeners = new ArrayList<ChatRoomMemberRoleListener>(memberRoleListeners);\r\n    }\r\n    for (ChatRoomMemberRoleListener listener : listeners) {\r\n        listener.memberRoleChanged(evt);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.sip.TestAccountInstallation.testInstallAccount",
	"Comment": "installs an account and verifies whether the installation has gone well.",
	"Method": "void testInstallAccount(){\r\n    ServiceUtils.getService(SipSlickFixture.bc, ConfigurationService.class).setProperty(CertificateService.PNAME_ALWAYS_TRUST, true);\r\n    ServiceReference[] serRefs = null;\r\n    String osgiFilter = \"(\" + ProtocolProviderFactory.PROTOCOL + \"=\" + ProtocolNames.SIP + \")\";\r\n    try {\r\n        serRefs = SipSlickFixture.bc.getServiceReferences(ProtocolProviderFactory.class.getName(), osgiFilter);\r\n    } catch (InvalidSyntaxException ex) {\r\n        fail(osgiFilter + \" is not a valid osgi filter\");\r\n    }\r\n    assertTrue(\"Failed to find a provider factory service for protocol SIP\", serRefs != null && serRefs.length > 0);\r\n    ProtocolProviderFactory sipProviderFactory = (ProtocolProviderFactory) SipSlickFixture.bc.getService(serRefs[0]);\r\n    assertTrue(\"There was an account registered with the account mananger \" + \"before we've installed any\", sipProviderFactory.getRegisteredAccounts().size() == 0);\r\n    Hashtable<String, String> sipAccount1Properties = getAccountProperties(SipProtocolProviderServiceLick.ACCOUNT_1_PREFIX);\r\n    Hashtable<String, String> sipAccount2Properties = getAccountProperties(SipProtocolProviderServiceLick.ACCOUNT_2_PREFIX);\r\n    try {\r\n        sipProviderFactory.installAccount(null, sipAccount1Properties);\r\n        fail(\"installing an account with a null account id must result \" + \"in a NullPointerException\");\r\n    } catch (NullPointerException exc) {\r\n    }\r\n    sipProviderFactory.installAccount(sipAccount1Properties.get(ProtocolProviderFactory.USER_ID), sipAccount1Properties);\r\n    sipProviderFactory.installAccount(sipAccount2Properties.get(ProtocolProviderFactory.USER_ID), sipAccount2Properties);\r\n    try {\r\n        sipProviderFactory.installAccount(sipAccount1Properties.get(ProtocolProviderFactory.USER_ID), sipAccount1Properties);\r\n        fail(\"An IllegalStateException must be thrown when trying to \" + \"install a duplicate account\");\r\n    } catch (IllegalStateException exc) {\r\n    }\r\n    assertTrue(\"The newly installed account was not in the acc man's \" + \"registered accounts!\", sipProviderFactory.getRegisteredAccounts().size() == 2);\r\n    osgiFilter = \"(&(\" + ProtocolProviderFactory.PROTOCOL + \"=\" + ProtocolNames.SIP + \")\" + \"(\" + ProtocolProviderFactory.USER_ID + \"=\" + sipAccount1Properties.get(ProtocolProviderFactory.USER_ID) + \"))\";\r\n    try {\r\n        serRefs = SipSlickFixture.bc.getServiceReferences(ProtocolProviderService.class.getName(), osgiFilter);\r\n    } catch (InvalidSyntaxException ex) {\r\n        fail(osgiFilter + \"is not a valid osgi filter\");\r\n    }\r\n    assertTrue(\"A SIP protocol provider was apparently not installed as \" + \"requested.\", serRefs != null && serRefs.length > 0);\r\n    Object icqProtocolProvider = SipSlickFixture.bc.getService(serRefs[0]);\r\n    assertTrue(\"The installed protocol provider does not implement \" + \"the protocol provider service.\", icqProtocolProvider instanceof ProtocolProviderService);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.callhistory.CallHistoryServiceImpl.findByStartDate",
	"Comment": "returns all the calls made by all the contacts in the suppliedcontact after the given date.",
	"Method": "Collection<CallRecord> findByStartDate(MetaContact contact,Date startDate,Collection<CallRecord> findByStartDate,Date startDate){\r\n    TreeSet<CallRecord> result = new TreeSet<CallRecord>(new CallRecordComparator());\r\n    try {\r\n        History history = this.getHistory(null, null);\r\n        historyReader = history.getReader();\r\n        addHistorySearchProgressListeners(historyReader, 1);\r\n        QueryResultSet<HistoryRecord> rs = historyReader.findByStartDate(startDate);\r\n        while (rs.hasNext()) {\r\n            HistoryRecord hr = rs.next();\r\n            result.add(convertHistoryRecordToCallRecord(hr));\r\n        }\r\n        removeHistorySearchProgressListeners(historyReader);\r\n    } catch (IOException ex) {\r\n        logger.error(\"Could not read history\", ex);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatSession.getTransportsForOperationSet",
	"Comment": "returns a list of all chattransports contained in this sessionsupporting the given opsetclass.",
	"Method": "List<ChatTransport> getTransportsForOperationSet(Class<? extends OperationSet> opSetClass){\r\n    LinkedList<ChatTransport> opSetTransports = new LinkedList<ChatTransport>();\r\n    for (ChatTransport transport : chatTransports) {\r\n        if (transport.getProtocolProvider().getOperationSet(opSetClass) != null)\r\n            opSetTransports.add(transport);\r\n    }\r\n    return opSetTransports;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipRegistrarConnection.toString",
	"Comment": "returns a string representation of this connection instance instance including information that would permit to distinguish it among other sip listeners when reading a log file.",
	"Method": "String toString(){\r\n    String className = getClass().getName();\r\n    try {\r\n        className = className.substring(className.lastIndexOf('.') + 1);\r\n    } catch (Exception ex) {\r\n    }\r\n    return className + \"-[dn=\" + sipProvider.getOurDisplayName() + \" addr=\" + getAddressOfRecord() + \"]\";\r\n}"
}, {
	"Path": "net.librec.recommender.baseline.UserAverageRecommender.predict",
	"Comment": "the user ratings average value as the predictive ratingfor user useridx on item itemidx.",
	"Method": "double predict(int userIdx,int itemIdx){\r\n    if (!userMeans.containsKey(userIdx)) {\r\n        SequentialSparseVector userRatingsVector = trainMatrix.row(userIdx);\r\n        userMeans.put(userIdx, userRatingsVector.getNumEntries() > 0 ? userRatingsVector.mean() : globalMean);\r\n    }\r\n    return userMeans.get(userIdx);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.utils.ImageLoaderServiceImpl.getImageBytes",
	"Comment": "loads an image from a given image identifier and returnbytes of the image.",
	"Method": "byte[] getImageBytes(ImageID imageID){\r\n    BufferedImage image = getImage(imageID);\r\n    if (image != null)\r\n        return ImageUtils.toByteArray(image);\r\n    else\r\n        return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.account.AccountStatusUtils.getLastPresenceStatus",
	"Comment": "returns the last status that was stored in the configuration xml for thegiven protocol provider.",
	"Method": "PresenceStatus getLastPresenceStatus(ProtocolProviderService protocolProvider){\r\n    if (getGlobalStatusService() != null)\r\n        return getGlobalStatusService().getLastPresenceStatus(protocolProvider);\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.history.DBStructSerializer.findElement",
	"Comment": "this method seraches through all children of a given node and returns thefirst with the name matching the given one. if no node is found, null isreturned.",
	"Method": "Element findElement(Node parent,String name){\r\n    Element retVal = null;\r\n    NodeList nodes = parent.getChildNodes();\r\n    int count = nodes.getLength();\r\n    for (int i = 0; i < count; i++) {\r\n        Node node = nodes.item(i);\r\n        if (node.getNodeType() == Node.ELEMENT_NODE && name.equals(node.getNodeName())) {\r\n            retVal = (Element) node;\r\n            break;\r\n        }\r\n    }\r\n    return retVal;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.jingle.RtpDescriptionPacketExtension.getPayloadTypes",
	"Comment": "returns a reference to the list of payload types that we haveregistered with this description so far.",
	"Method": "List<PayloadTypePacketExtension> getPayloadTypes(){\r\n    return payloadTypes;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.RootContactGroupIcqImpl.getPersistentData",
	"Comment": "returns null as no persistent data is required and the group name issufficient for restoring the contact.",
	"Method": "String getPersistentData(){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.replacers.NewlineReplacer.replace",
	"Comment": "new line characters are searched and replaced with a combination ofnewline and br tag.",
	"Method": "void replace(StringBuilder target,String piece){\r\n    target.append(piece.replaceAll(\"\\n\", \"<BR/>&#10;\"));\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.runner.XmlFormatter.getStackTrace",
	"Comment": "convenient method to retrieve the full stacktrace from a given exception.",
	"Method": "String getStackTrace(Throwable t){\r\n    StringWriter sw = new StringWriter();\r\n    PrintWriter pw = new PrintWriter(sw, true);\r\n    t.printStackTrace(pw);\r\n    pw.flush();\r\n    pw.close();\r\n    return sw.toString();\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.ChatRoomMessageDeliveryFailedEvent.getErrorCode",
	"Comment": "returns an error code descibing the reason for the failure of the message delivery.",
	"Method": "int getErrorCode(){\r\n    return errorCode;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.launchutils.ArgDelegator.setDelegationPeer",
	"Comment": "sets a delegation peer that we can now use to pass arguments to andmakes it handle all arguments that have been already registered.",
	"Method": "void setDelegationPeer(ArgDelegationPeer delegationPeer){\r\n    synchronized (recordedArgs) {\r\n        if (logger.isTraceEnabled())\r\n            logger.trace(\"Someone set a delegationPeer. \" + \"Will dispatch \" + recordedArgs.size() + \" args\");\r\n        this.uriDelegationPeer = delegationPeer;\r\n        for (String arg : recordedArgs) {\r\n            if (logger.isTraceEnabled())\r\n                logger.trace(\"Dispatching arg: \" + arg);\r\n            uriDelegationPeer.handleUri(arg);\r\n        }\r\n        recordedArgs.clear();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.MetaContactChatTransport.sendMultimediaFile",
	"Comment": "sends the given sms multimedia message trough this chat transport,leaving the transport to choose the destination.",
	"Method": "FileTransfer sendMultimediaFile(File file){\r\n    return sendFile(file, true);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.OperationSetMultiUserChatIrcImpl.findOrCreateRoom",
	"Comment": "find an existing room with the provided name, or create a new room withthis name.",
	"Method": "ChatRoomIrcImpl findOrCreateRoom(String roomName){\r\n    synchronized (this.chatRoomCache) {\r\n        ChatRoomIrcImpl room = chatRoomCache.get(roomName);\r\n        if (room == null) {\r\n            room = createLocalChatRoomInstance(roomName);\r\n        }\r\n        return room;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.call.CallTransferHandler.canImport",
	"Comment": "indicates whether a component will accept an import of the givenset of data flavors prior to actually attempting to import it. we returntrue to indicate that the transfer with at least one of thegiven flavors would work and false to reject the transfer.",
	"Method": "boolean canImport(JComponent comp,DataFlavor[] flavor){\r\n    for (DataFlavor f : flavor) {\r\n        if (f.equals(DataFlavor.stringFlavor) || f.equals(uiContactDataFlavor)) {\r\n            return (comp instanceof JPanel);\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.notifsource.NotificationContact.getUnreadMessageCount",
	"Comment": "returns the number of unread messages, this notification is about.",
	"Method": "int getUnreadMessageCount(){\r\n    return unreadMessageCount;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommTextField.removeUpdate",
	"Comment": "handles the change when a char has been removed from the field.",
	"Method": "void removeUpdate(DocumentEvent e){\r\n    if (!isDefaultTextVisible)\r\n        fireTextFieldChangeListener(1);\r\n    else\r\n        isDefaultTextVisible = false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractOperationSetBasicInstantMessaging.fireMessageEvent",
	"Comment": "delivers the specified event to all registered message listeners.",
	"Method": "void fireMessageEvent(EventObject evt){\r\n    Collection<MessageListener> listeners = null;\r\n    synchronized (this.messageListeners) {\r\n        listeners = new ArrayList<MessageListener>(this.messageListeners);\r\n    }\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Dispatching Message Listeners=\" + listeners.size() + \" evt=\" + evt);\r\n    MessageEventType eventType = MessageEventType.None;\r\n    if (evt instanceof MessageDeliveredEvent) {\r\n        eventType = MessageEventType.MessageDelivered;\r\n    } else if (evt instanceof MessageReceivedEvent) {\r\n        eventType = MessageEventType.MessageReceived;\r\n    } else if (evt instanceof MessageDeliveryFailedEvent) {\r\n        eventType = MessageEventType.MessageDeliveryFailed;\r\n    }\r\n    EventObject[] events = messageTransform(evt, eventType);\r\n    for (EventObject event : events) {\r\n        try {\r\n            if (event == null)\r\n                return;\r\n            for (MessageListener listener : listeners) {\r\n                switch(eventType) {\r\n                    case MessageDelivered:\r\n                        listener.messageDelivered((MessageDeliveredEvent) event);\r\n                        break;\r\n                    case MessageDeliveryFailed:\r\n                        listener.messageDeliveryFailed((MessageDeliveryFailedEvent) event);\r\n                        break;\r\n                    case MessageReceived:\r\n                        listener.messageReceived((MessageReceivedEvent) event);\r\n                        break;\r\n                    default:\r\n                        break;\r\n                }\r\n            }\r\n        } catch (Throwable e) {\r\n            logger.error(\"Error delivering message\", e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.lettuce.core.protocol.SharedLock.incrementWriters",
	"Comment": "wait for statelock and increment writers. will wait if statelock is locked and if writer counter is negative.",
	"Method": "void incrementWriters(){\r\n    if (exclusiveLockOwner == Thread.currentThread()) {\r\n        return;\r\n    }\r\n    synchronized (this) {\r\n        for (; ; ) {\r\n            if (writers.get() >= 0) {\r\n                writers.incrementAndGet();\r\n                return;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.DynamicRTPExtensionsRegistry.obtainExtensionMapping",
	"Comment": "returns the id that has been allocated for extension. a mappingfor the specified extension would be created even if it did notpreviously exist. the method is meant for use primarily during generationof sdp descriptions.",
	"Method": "byte obtainExtensionMapping(RTPExtension extension){\r\n    Byte extID = extMap.get(extension);\r\n    if (extID == null) {\r\n        extID = nextExtensionID();\r\n        extMap.put(extension, extID);\r\n    }\r\n    return extID;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.inputevt.RemoteControlExtensionProvider.append",
	"Comment": "appends a specific array of strings to a specificstringbuffer.",
	"Method": "void append(StringBuffer stringBuffer,String strings){\r\n    for (String str : strings) stringBuffer.append(str);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.FileDragLabel.drop",
	"Comment": "called when the drag operation has terminated with a drop onthe operable part of the drop site for the droptargetregistered with this listener.",
	"Method": "void drop(DropTargetDropEvent event){\r\n    try {\r\n        Transferable transferable = event.getTransferable();\r\n        if (transferable.isDataFlavorSupported(DataFlavor.javaFileListFlavor)) {\r\n            event.acceptDrop(DnDConstants.ACTION_COPY);\r\n            event.getDropTargetContext().dropComplete(true);\r\n        } else {\r\n            event.rejectDrop();\r\n        }\r\n    } catch (Exception ex) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Unable to drop label.\", ex);\r\n        event.rejectDrop();\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWritePanel.initDefaultFontConfiguration",
	"Comment": "initializes the default font configuration for this chat write area.",
	"Method": "void initDefaultFontConfiguration(){\r\n    String fontFamily = ConfigurationUtils.getChatDefaultFontFamily();\r\n    int fontSize = ConfigurationUtils.getChatDefaultFontSize();\r\n    if (fontFamily != null && fontSize > 0)\r\n        setFontFamilyAndSize(fontFamily, fontSize);\r\n    setBoldStyleEnable(ConfigurationUtils.isChatFontBold());\r\n    setItalicStyleEnable(ConfigurationUtils.isChatFontItalic());\r\n    setUnderlineStyleEnable(ConfigurationUtils.isChatFontUnderline());\r\n    Color fontColor = ConfigurationUtils.getChatDefaultFontColor();\r\n    if (fontColor != null)\r\n        setFontColor(fontColor);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.keybindings.KeybindingsServiceImpl.getGlobalBindings",
	"Comment": "provides the bindings associated with the global category.",
	"Method": "GlobalKeybindingSet getGlobalBindings(){\r\n    return globalBindings;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.sdp.SdpUtils.parseFmtpAttribute",
	"Comment": "parses the value of the fmtpattr attribute into a formatparameters map and returns it.",
	"Method": "Map<String, String> parseFmtpAttribute(Attribute fmtpAttr){\r\n    Map<String, String> fmtpMap = new Hashtable<String, String>();\r\n    String fmtpValue = fmtpAttr.getValue();\r\n    StringTokenizer tokenizer = new StringTokenizer(fmtpValue, \" ;\", false);\r\n    while (tokenizer.hasMoreTokens()) {\r\n        String token = tokenizer.nextToken();\r\n        int indexOfEq = token.indexOf(\"=\");\r\n        if ((indexOfEq == -1) || (indexOfEq == token.length() - 1))\r\n            continue;\r\n        String paramName = token.substring(0, indexOfEq);\r\n        String paramValue = token.substring(indexOfEq + 1);\r\n        fmtpMap.put(paramName, paramValue);\r\n    }\r\n    if (fmtpMap.isEmpty())\r\n        return null;\r\n    return fmtpMap;\r\n}"
}, {
	"Path": "net.librec.math.algorithm.Randoms.bernoulli",
	"Comment": "return a boolean, which is true with probability .5, and false otherwise.",
	"Method": "boolean bernoulli(double p,boolean bernoulli){\r\n    return bernoulli(0.5);\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.UtilActivator.getAccountManager",
	"Comment": "returns the accountmanager obtained from the bundle context.",
	"Method": "AccountManager getAccountManager(){\r\n    if (accountManager == null) {\r\n        accountManager = ServiceUtils.getService(bundleContext, AccountManager.class);\r\n    }\r\n    return accountManager;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.ChatConferenceCallDialog.updateView",
	"Comment": "checks whether the create or join panel should be visible and shows it.",
	"Method": "void updateView(){\r\n    mainPanel.remove((createConferenceButton.isSelected() ? joinPanel : createPanel));\r\n    mainPanel.add((createConferenceButton.isSelected() ? createPanel : joinPanel), BorderLayout.CENTER);\r\n    if (joinConferenceButton.isSelected())\r\n        this.chatConferenceListPanel.setSelectedIndex(0);\r\n    pack();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.mailnotification.MailboxIQ.setUrl",
	"Comment": "specifies an http url of the mail server that contains the messagesindicated in this mailbox iq.",
	"Method": "void setUrl(String url){\r\n    this.url = url;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.TestProtocolProviderServiceIcqImpl.testIsRegistered",
	"Comment": "verifies whether the isregistered method returns whatever it has to.",
	"Method": "void testIsRegistered(){\r\n    if (!IcqStatusEnum.OFFLINE.equals(IcqSlickFixture.testerAgent.getBuddyStatus(fixture.ourUserID)))\r\n        assertTrue(\"provider.isRegistered() returned false while registered\", fixture.provider.isRegistered());\r\n    else\r\n        assertFalse(\"provider.isRegistered() returned true while unregistered\", fixture.provider.isRegistered());\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.TransportManagerSipImpl.getNbHarvesting",
	"Comment": "returns the number of harvesting time for the harvester given inparameter.",
	"Method": "int getNbHarvesting(int getNbHarvesting,String harvesterName){\r\n    return 0;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ContactSipImpl.isResolvable",
	"Comment": "determines whether or not this contact can be resolved against theserver.",
	"Method": "boolean isResolvable(){\r\n    return this.isResolvable;\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.runner.ScTestRunner.start",
	"Comment": "starts a test run. analyzes the command line argumentsand runs the given test suite.",
	"Method": "TestResult start(String args){\r\n    String testCase = \"\";\r\n    boolean wait = false;\r\n    for (int i = 0; i < args.length; i++) {\r\n        if (args[i].equals(\"-wait\"))\r\n            wait = true;\r\n        else if (args[i].equals(\"-c\"))\r\n            testCase = extractClassName(args[++i]);\r\n        else if (args[i].equals(\"-v\"))\r\n            System.err.println(\"JUnit \" + Version.id() + \" by Kent Beck and Erich Gamma\");\r\n        else\r\n            testCase = args[i];\r\n    }\r\n    if (testCase.equals(\"\"))\r\n        throw new Exception(\"Usage: TestRunner [-wait] testCaseName, where name is the name of the TestCase class\");\r\n    try {\r\n        Test suite = getTest(testCase);\r\n        return doRun(suite, wait);\r\n    } catch (Exception e) {\r\n        throw new Exception(\"Could not create and run test suite: \" + e);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.SipRegistrarConnection.isRequestFromSameConnection",
	"Comment": "checks a particular request is it coming from the same proxy we arecurrently using. a check for security reasons, preventing injectionof other messages in the pp.",
	"Method": "boolean isRequestFromSameConnection(Request request){\r\n    SIPMessage msg = (SIPMessage) request;\r\n    if (msg.getRemoteAddress() != null && lastRegisterAddressReceived != null) {\r\n        if (!msg.getRemoteAddress().equals(lastRegisterAddressReceived) || msg.getRemotePort() != lastRegisterPortReceived) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomJabberImpl.removeMemberRoleListener",
	"Comment": "removes a listener that was being notified of changes of a member role inthis chat room such as us being granded operator.",
	"Method": "void removeMemberRoleListener(ChatRoomMemberRoleListener listener){\r\n    synchronized (memberRoleListeners) {\r\n        memberRoleListeners.remove(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.event.ChatRoomMemberRoleChangeEvent.getNewRole",
	"Comment": "returns the new role given to the member that this event is about.",
	"Method": "ChatRoomMemberRole getNewRole(){\r\n    return newRole;\r\n}"
}, {
	"Path": "net.librec.recommender.baseline.RandomGuessRecommender.predict",
	"Comment": "a random value as the predictive rating for user useridx on item itemidx.",
	"Method": "double predict(int userIdx,int itemIdx){\r\n    return Randoms.uniform(minRate, maxRate);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapDirectorySettingsImpl.persistentLoad",
	"Comment": "loads the settings with the given name from the config filesinto the ldapdirectorysetting.",
	"Method": "void persistentLoad(String name){\r\n    ConfigurationService configService = LdapServiceImpl.getConfigService();\r\n    CredentialsStorageService credentialsService = LdapServiceImpl.getCredentialsService();\r\n    String node = \"dir\" + Math.abs(name.hashCode());\r\n    if (configService.getProperty(directoriesPath + \".\" + node) == null)\r\n        this.setName(\"\");\r\n    else\r\n        this.setName((String) configService.getProperty(directoriesPath + \".\" + node));\r\n    if (configService.getProperty(directoriesPath + \".\" + node + \".enabled\") == null)\r\n        this.setEnabled(true);\r\n    else\r\n        this.setEnabled(Boolean.parseBoolean((String) configService.getProperty(directoriesPath + \".\" + node + \".enabled\")));\r\n    if (configService.getProperty(directoriesPath + \".\" + node + \".hostname\") == null)\r\n        this.setHostname(\"\");\r\n    else\r\n        this.setHostname((String) configService.getProperty(directoriesPath + \".\" + node + \".hostname\"));\r\n    if (configService.getProperty(directoriesPath + \".\" + node + \".encryption\") == null)\r\n        this.setEncryption(Encryption.defaultValue());\r\n    else\r\n        this.setEncryption(Encryption.valueOf((String) configService.getProperty(directoriesPath + \".\" + node + \".encryption\")));\r\n    if (configService.getProperty(directoriesPath + \".\" + node + \".port\") == null)\r\n        this.setPort(0);\r\n    else\r\n        this.setPort(Integer.parseInt((String) configService.getProperty(directoriesPath + \".\" + node + \".port\")));\r\n    if (configService.getProperty(directoriesPath + \".\" + node + \".auth\") == null)\r\n        this.setAuth(Auth.defaultValue());\r\n    else\r\n        this.setAuth(Auth.valueOf((String) configService.getProperty(directoriesPath + \".\" + node + \".auth\")));\r\n    if (configService.getProperty(directoriesPath + \".\" + node + \".bindDN\") == null)\r\n        this.setBindDN(\"\");\r\n    else\r\n        this.setBindDN((String) configService.getProperty(directoriesPath + \".\" + node + \".bindDN\"));\r\n    String password = credentialsService.loadPassword(directoriesPath + \".\" + node);\r\n    if (password == null) {\r\n        this.setPassword(\"\");\r\n    } else {\r\n        this.setPassword(password);\r\n    }\r\n    if (configService.getProperty(directoriesPath + \".\" + node + \".scope\") == null)\r\n        this.setScope(Scope.defaultValue());\r\n    else\r\n        this.setScope(Scope.valueOf((String) configService.getProperty(directoriesPath + \".\" + node + \".scope\")));\r\n    if (configService.getProperty(directoriesPath + \".\" + node + \".baseDN\") == null)\r\n        this.setBaseDN(\"\");\r\n    else\r\n        this.setBaseDN((String) configService.getProperty(directoriesPath + \".\" + node + \".baseDN\"));\r\n    if (configService.getProperty(directoriesPath + \".\" + node + \".overridemail\") != null) {\r\n        String ret = (String) configService.getProperty(directoriesPath + \".\" + node + \".overridemail\");\r\n        mapAttributes.put(\"mail\", mergeString(ret));\r\n    }\r\n    if (configService.getProperty(directoriesPath + \".\" + node + \".overridemailsuffix\") != null) {\r\n        String ret = (String) configService.getProperty(directoriesPath + \".\" + node + \".overridemailsuffix\");\r\n        this.mailSuffix = ret;\r\n    }\r\n    if (configService.getProperty(directoriesPath + \".\" + node + \".overrideworkphone\") != null) {\r\n        String ret = (String) configService.getProperty(directoriesPath + \".\" + node + \".overrideworkphone\");\r\n        mapAttributes.put(\"workPhone\", mergeString(ret));\r\n    }\r\n    if (configService.getProperty(directoriesPath + \".\" + node + \".overridemobilephone\") != null) {\r\n        String ret = (String) configService.getProperty(directoriesPath + \".\" + node + \".overridemobilephone\");\r\n        mapAttributes.put(\"mobilePhone\", mergeString(ret));\r\n    }\r\n    if (configService.getProperty(directoriesPath + \".\" + node + \".overridehomephone\") != null) {\r\n        String ret = (String) configService.getProperty(directoriesPath + \".\" + node + \".overridehomephone\");\r\n        mapAttributes.put(\"homePhone\", mergeString(ret));\r\n    }\r\n    if (configService.getProperty(directoriesPath + \".\" + node + \".globalPhonePrefix\") != null) {\r\n        String ret = (String) configService.getProperty(directoriesPath + \".\" + node + \".globalPhonePrefix\");\r\n        if (ret != null)\r\n            setGlobalPhonePrefix(ret);\r\n    }\r\n    if (configService.getProperty(directoriesPath + \".\" + node + \".querymode\") != null) {\r\n        String ret = (String) configService.getProperty(directoriesPath + \".\" + node + \".querymode\");\r\n        if (ret != null)\r\n            setQueryMode(ret);\r\n    }\r\n    if (configService.getProperty(directoriesPath + \".\" + node + \".customquery\") != null) {\r\n        String ret = (String) configService.getProperty(directoriesPath + \".\" + node + \".customquery\");\r\n        if (ret != null)\r\n            setCustomQuery(ret);\r\n    }\r\n    if (configService.getProperty(directoriesPath + \".\" + node + \".mangle\") != null) {\r\n        Boolean ret = Boolean.parseBoolean((String) configService.getProperty(directoriesPath + \".\" + node + \".mangle\"));\r\n        if (ret != null)\r\n            setMangleQuery(ret);\r\n    }\r\n    if (configService.getProperty(directoriesPath + \".\" + node + \".inlinephoto\") != null) {\r\n        Boolean ret = Boolean.parseBoolean((String) configService.getProperty(directoriesPath + \".\" + node + \".inlinephoto\"));\r\n        if (ret != null)\r\n            setPhotoInline(ret);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.SIPCommScrollPane.dispose",
	"Comment": "releases the resources allocated by this instance throughout its lifetimeand prepares it for garbage collection.",
	"Method": "void dispose(){\r\n    if (OSUtils.IS_MAC) {\r\n        try {\r\n            Toolkit defaultToolkit = Toolkit.getDefaultToolkit();\r\n            PropertyChangeListener[] pcl = defaultToolkit.getPropertyChangeListeners(\"apple.awt.contentScaleFactor\");\r\n            for (PropertyChangeListener pc : pcl) {\r\n                Field f = pc.getClass().getDeclaredField(\"this$0\");\r\n                f.setAccessible(true);\r\n                if (f.get(pc).equals(this.getViewport())) {\r\n                    defaultToolkit.removePropertyChangeListener(\"apple.awt.contentScaleFactor\", pc);\r\n                    break;\r\n                }\r\n            }\r\n        } catch (Throwable t) {\r\n            if (t instanceof ThreadDeath)\r\n                throw (ThreadDeath) t;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AuthorizationRequest.getReason",
	"Comment": "returns the reason that should be sent to the remote user when askingfor authorization.",
	"Method": "String getReason(){\r\n    return reason;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.presence.GlobalStatusSelectorBox.removeAccount",
	"Comment": "removes the status menu corresponding to the account given byprotocolprovider.",
	"Method": "void removeAccount(ProtocolProviderService protocolProvider){\r\n    StatusEntry menu = getStatusEntry(protocolProvider);\r\n    if (menu != null) {\r\n        menu.dispose();\r\n        remove(menu.getEntryComponent());\r\n    }\r\n    if (!isPresenceOpSetForProvidersAvailable())\r\n        removeAvailableStatuses();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.InfoRetreiver.getCachedContactDetails",
	"Comment": "request the full info for the given uin if available in cache,if missing return null.",
	"Method": "List<GenericDetail> getCachedContactDetails(String uin){\r\n    return retreivedDetails.get(uin);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.JabberActivator.getProtocolProviderFactory",
	"Comment": "retrurns a reference to the protocol provider factory that we haveregistered.",
	"Method": "ProtocolProviderFactoryJabberImpl getProtocolProviderFactory(){\r\n    return jabberProviderFactory;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.provdisc.mdns.MDNSProvisioningDiscover.addDiscoveryListener",
	"Comment": "add a listener that will be notified when thediscoverprovisioningurl has finished.",
	"Method": "void addDiscoveryListener(DiscoveryListener listener){\r\n    if (!listeners.contains(listener)) {\r\n        listeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.ServerStoredContactListIcqImpl.init",
	"Comment": "sets a reference to the currently active and valid instance ofthe joustsim ssiservice that this list is to use for retrievingserver stored information",
	"Method": "void init(SsiService joustSimSsiService){\r\n    this.jSimSsiService = joustSimSsiService;\r\n    jSimSsiService.addItemChangeListener(jsimItemChangeListener);\r\n    this.buddyList = jSimSsiService.getBuddyList();\r\n    buddyList.addRetroactiveLayoutListener(buddyListListener);\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.spellcheck.LanguageMenuBar.getPositionIndex",
	"Comment": "returns the index indicating the position of this menu in its container.",
	"Method": "int getPositionIndex(){\r\n    return -1;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomConfigurationFormFieldJabberImpl.getType",
	"Comment": "for each of the smack form field types returns the correspondingchatroomconfigurationformfield type.",
	"Method": "String getType(){\r\n    String smackType = smackFormField.getType();\r\n    if (smackType.equals(FormField.TYPE_BOOLEAN))\r\n        return TYPE_BOOLEAN;\r\n    if (smackType.equals(FormField.TYPE_FIXED))\r\n        return TYPE_TEXT_FIXED;\r\n    else if (smackType.equals(FormField.TYPE_TEXT_PRIVATE))\r\n        return TYPE_TEXT_PRIVATE;\r\n    else if (smackType.equals(FormField.TYPE_TEXT_SINGLE))\r\n        return TYPE_TEXT_SINGLE;\r\n    else if (smackType.equals(FormField.TYPE_TEXT_MULTI))\r\n        return TYPE_TEXT_MULTI;\r\n    else if (smackType.equals(FormField.TYPE_LIST_SINGLE))\r\n        return TYPE_LIST_SINGLE;\r\n    else if (smackType.equals(FormField.TYPE_LIST_MULTI))\r\n        return TYPE_LIST_MULTI;\r\n    else if (smackType.equals(FormField.TYPE_JID_SINGLE))\r\n        return TYPE_ID_SINGLE;\r\n    else if (smackType.equals(FormField.TYPE_JID_MULTI))\r\n        return TYPE_ID_MULTI;\r\n    else\r\n        return TYPE_UNDEFINED;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactGroupImpl.getChildContacts",
	"Comment": "returns a java.util.iterator over the metacontactscontained in this metacontactgroup.in order to prevent problems with concurrency, the iteratorreturned by this method is not over the actual list of groups but over acopy of that list.",
	"Method": "Iterator<MetaContact> getChildContacts(){\r\n    return childContactsOrderedCopy.iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.MetaContactChatTransport.updateContactStatus",
	"Comment": "updates the status of this contact with the new given status.",
	"Method": "void updateContactStatus(){\r\n    parentChatSession.getChatSessionRenderer().updateChatTransportStatus(this);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ProtocolProviderServiceIrcImpl.initialize",
	"Comment": "initializes the service implementation, and puts it in a state where itcould operate with other services. it is strongly recommended thatproperties in this map be mapped to property names as specified byaccountproperties.",
	"Method": "void initialize(String userID,AccountID accountID){\r\n    synchronized (initializationLock) {\r\n        this.accountID = accountID;\r\n        addSupportedOperationSet(OperationSetInstantMessageTransform.class, new OperationSetInstantMessageTransformImpl());\r\n        multiUserChat = new OperationSetMultiUserChatIrcImpl(this);\r\n        addSupportedOperationSet(OperationSetMultiUserChat.class, multiUserChat);\r\n        this.instantMessaging = new OperationSetBasicInstantMessagingIrcImpl(this);\r\n        addSupportedOperationSet(OperationSetBasicInstantMessaging.class, this.instantMessaging);\r\n        addSupportedOperationSet(OperationSetBasicInstantMessagingTransport.class, this.instantMessaging);\r\n        persistentPresence = new OperationSetPersistentPresenceIrcImpl(this);\r\n        addSupportedOperationSet(OperationSetPersistentPresence.class, persistentPresence);\r\n        addSupportedOperationSet(OperationSetPresence.class, persistentPresence);\r\n        final String user = getAccountID().getUserID();\r\n        ircstack = new IrcStack(this, user, user, \"Jitsi\", user);\r\n        isInitialized = true;\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactListServiceImpl.addContactGroupToMetaGroup",
	"Comment": "creates meta contacts and meta contact groups for all children of thespecified contactgroup and adds them to metagroup",
	"Method": "void addContactGroupToMetaGroup(ContactGroup protoGroup,MetaContactGroupImpl metaGroup,boolean fireEvents){\r\n    metaGroup.addProtoGroup(protoGroup);\r\n    Iterator<ContactGroup> subgroupsIter = protoGroup.subgroups();\r\n    while (subgroupsIter.hasNext()) {\r\n        ContactGroup group = subgroupsIter.next();\r\n        if (metaGroup.findMetaContactGroupByContactGroup(group) != null)\r\n            continue;\r\n        MetaContactGroupImpl newMetaGroup = new MetaContactGroupImpl(this, group.getGroupName());\r\n        metaGroup.addSubgroup(newMetaGroup);\r\n        addContactGroupToMetaGroup(group, newMetaGroup, false);\r\n        if (fireEvents) {\r\n            this.fireMetaContactGroupEvent(newMetaGroup, group.getProtocolProvider(), group, MetaContactGroupEvent.META_CONTACT_GROUP_ADDED);\r\n        }\r\n    }\r\n    Iterator<Contact> contactsIter = protoGroup.contacts();\r\n    while (contactsIter.hasNext()) {\r\n        Contact contact = contactsIter.next();\r\n        if (metaGroup.findMetaContactByContact(contact) != null)\r\n            continue;\r\n        MetaContactImpl newMetaContact = new MetaContactImpl();\r\n        newMetaContact.addProtoContact(contact);\r\n        metaGroup.addMetaContact(newMetaContact);\r\n        if (fireEvents) {\r\n            this.fireMetaContactEvent(newMetaContact, metaGroup, MetaContactEvent.META_CONTACT_ADDED);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.ldap.LdapDirectoryImpl.checkRetrievedAttributes",
	"Comment": "checks whether the found attributes match the current query.",
	"Method": "boolean checkRetrievedAttributes(String queryString,Pattern searchPattern,Map<String, Set<Object>> retrievedAttributes){\r\n    for (Map.Entry<String, Set<Object>> en : retrievedAttributes.entrySet()) {\r\n        if (!searchableAttrs.contains(en.getKey())) {\r\n            continue;\r\n        }\r\n        boolean isPhoneNumber = phoneNumberAttributes.contains(en.getKey());\r\n        for (Object o : en.getValue()) {\r\n            if (!(o instanceof String))\r\n                continue;\r\n            if (searchPattern.matcher((String) o).find() || (isPhoneNumber && LdapActivator.getPhoneNumberI18nService().phoneNumbersMatch(queryString, (String) o)))\r\n                return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractProtocolProviderService.addRegistrationStateChangeListener",
	"Comment": "registers the specified listener with this provider so that it wouldreceive notifications on changes of its state or other properties suchas its local address and display name.",
	"Method": "void addRegistrationStateChangeListener(RegistrationStateChangeListener listener){\r\n    if (listener == null) {\r\n        throw new IllegalArgumentException(\"listener cannot be null\");\r\n    }\r\n    synchronized (registrationListeners) {\r\n        if (!registrationListeners.contains(listener))\r\n            registrationListeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ServerStoredContactListSipImpl.moveContactToGroup",
	"Comment": "removes the specified contact from its current parent and places itunder newparent.",
	"Method": "void moveContactToGroup(ContactSipImpl contact,ContactGroupSipImpl newParentGroup){\r\n    if (contact == null) {\r\n        throw new IllegalArgumentException(\"Moving contact cannot be null\");\r\n    }\r\n    if (newParentGroup == null) {\r\n        throw new IllegalArgumentException(\"New contact's parent group  be null\");\r\n    }\r\n    if (newParentGroup.getContact(contact.getUri()) != null) {\r\n        throw new OperationFailedException(\"Contact \" + contact.getUri() + \" already exists.\", OperationFailedException.SUBSCRIPTION_ALREADY_EXISTS);\r\n    }\r\n    ContactGroupSipImpl oldParentGroup = (ContactGroupSipImpl) contact.getParentContactGroup();\r\n    oldParentGroup.removeContact(contact);\r\n    boolean wasContactPersistent = contact.isPersistent();\r\n    if (newParentGroup.isPersistent())\r\n        contact.setPersistent(true);\r\n    newParentGroup.addContact(contact);\r\n    if (contact.isPersistent()) {\r\n        try {\r\n            updateResourceLists();\r\n        } catch (XCapException e) {\r\n            newParentGroup.removeContact(contact);\r\n            oldParentGroup.addContact(contact);\r\n            throw new OperationFailedException(\"Error while moving XCAP contact\", OperationFailedException.NETWORK_FAILURE, e);\r\n        }\r\n        if (!wasContactPersistent) {\r\n            contact.setResolved(true);\r\n            if (xCapClient.isConnected() && xCapClient.isResourceListsSupported()) {\r\n                contact.setXCapResolved(true);\r\n                try {\r\n                    if (!isContactInWhiteRule(contact.getAddress())) {\r\n                        if (addContactToWhiteList(contact))\r\n                            updatePresRules();\r\n                    }\r\n                } catch (XCapException e) {\r\n                    logger.error(\"Cannot add contact to white list while \" + \"creating it\", e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    fireContactMoved(oldParentGroup, newParentGroup, contact);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.contactlist.MetaContactImpl.getContactsForProvider",
	"Comment": "returns a contact, encapsulated by this metacontact and coming fromthe specified protocolproviderservice.in order to prevent problems with concurrency, the iteratorreturned by this method is not be over the actual list of contacts butover a copy of that list.",
	"Method": "Iterator<Contact> getContactsForProvider(ProtocolProviderService provider){\r\n    LinkedList<Contact> providerContacts = new LinkedList<Contact>();\r\n    for (Contact contact : protoContacts) {\r\n        if (contact.getProtocolProvider() == provider)\r\n            providerContacts.add(contact);\r\n    }\r\n    return providerContacts.iterator();\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.ContactProtocolButton.setProtocolContact",
	"Comment": "sets the specific protocol contact corresponding to this button.",
	"Method": "void setProtocolContact(Contact protocolContact){\r\n    this.protocolContact = protocolContact;\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.ircaccregwizz.IrcAccountRegistration.isAutoChangeNick",
	"Comment": "indicates if the nick should be changed automatically in case of nickcollision.",
	"Method": "boolean isAutoChangeNick(){\r\n    return autoChangeNick;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomIrcImpl.firePropertyChangeEvent",
	"Comment": "delivers the specified event to all registered property change listeners.",
	"Method": "void firePropertyChangeEvent(PropertyChangeEvent evt){\r\n    Iterable<ChatRoomPropertyChangeListener> listeners;\r\n    synchronized (propertyChangeListeners) {\r\n        listeners = new ArrayList<ChatRoomPropertyChangeListener>(propertyChangeListeners);\r\n    }\r\n    for (ChatRoomPropertyChangeListener listener : listeners) {\r\n        if (evt instanceof ChatRoomPropertyChangeEvent) {\r\n            listener.chatRoomPropertyChanged((ChatRoomPropertyChangeEvent) evt);\r\n        } else if (evt instanceof ChatRoomPropertyChangeFailedEvent) {\r\n            listener.chatRoomPropertyChangeFailed((ChatRoomPropertyChangeFailedEvent) evt);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.plugin.desktoputil.X509CertificatePanel.renderX509",
	"Comment": "appends an html representation of the given x509certificate.",
	"Method": "void renderX509(StringBuilder sb,X509Certificate certificate){\r\n    X500Principal issuer = certificate.getIssuerX500Principal();\r\n    X500Principal subject = certificate.getSubjectX500Principal();\r\n    sb.append(\"<table cellspacing='1' cellpadding='1'>\\n\");\r\n    addTitle(sb, R.getI18NString(\"service.gui.CERT_INFO_ISSUED_TO\"));\r\n    try {\r\n        for (Rdn name : new LdapName(subject.getName()).getRdns()) {\r\n            String nameType = name.getType();\r\n            String lblKey = \"service.gui.CERT_INFO_\" + nameType;\r\n            String lbl = R.getI18NString(lblKey);\r\n            if ((lbl == null) || (\"!\" + lblKey + \"!\").equals(lbl))\r\n                lbl = nameType;\r\n            final String value;\r\n            Object nameValue = name.getValue();\r\n            if (nameValue instanceof byte[]) {\r\n                byte[] nameValueAsByteArray = (byte[]) nameValue;\r\n                value = getHex(nameValueAsByteArray) + \" (\" + new String(nameValueAsByteArray) + \")\";\r\n            } else\r\n                value = nameValue.toString();\r\n            addField(sb, lbl, value);\r\n        }\r\n    } catch (InvalidNameException ine) {\r\n        addField(sb, R.getI18NString(\"service.gui.CERT_INFO_CN\"), subject.getName());\r\n    }\r\n    addTitle(sb, R.getI18NString(\"service.gui.CERT_INFO_ISSUED_BY\"));\r\n    try {\r\n        for (Rdn name : new LdapName(issuer.getName()).getRdns()) {\r\n            String nameType = name.getType();\r\n            String lblKey = \"service.gui.CERT_INFO_\" + nameType;\r\n            String lbl = R.getI18NString(lblKey);\r\n            if ((lbl == null) || (\"!\" + lblKey + \"!\").equals(lbl))\r\n                lbl = nameType;\r\n            final String value;\r\n            Object nameValue = name.getValue();\r\n            if (nameValue instanceof byte[]) {\r\n                byte[] nameValueAsByteArray = (byte[]) nameValue;\r\n                value = getHex(nameValueAsByteArray) + \" (\" + new String(nameValueAsByteArray) + \")\";\r\n            } else\r\n                value = nameValue.toString();\r\n            addField(sb, lbl, value);\r\n        }\r\n    } catch (InvalidNameException ine) {\r\n        addField(sb, R.getI18NString(\"service.gui.CERT_INFO_CN\"), issuer.getName());\r\n    }\r\n    addTitle(sb, R.getI18NString(\"service.gui.CERT_INFO_VALIDITY\"));\r\n    addField(sb, R.getI18NString(\"service.gui.CERT_INFO_ISSUED_ON\"), certificate.getNotBefore().toString());\r\n    addField(sb, R.getI18NString(\"service.gui.CERT_INFO_EXPIRES_ON\"), certificate.getNotAfter().toString());\r\n    addTitle(sb, R.getI18NString(\"service.gui.CERT_INFO_FINGERPRINTS\"));\r\n    try {\r\n        String sha256String = getThumbprint(certificate, \"SHA-256\");\r\n        String sha1String = getThumbprint(certificate, \"SHA1\");\r\n        addField(sb, \"SHA256:\", sha256String, 48);\r\n        addField(sb, \"SHA1:\", sha1String, 72);\r\n    } catch (CertificateException e) {\r\n    }\r\n    addTitle(sb, R.getI18NString(\"service.gui.CERT_INFO_CERT_DETAILS\"));\r\n    addField(sb, R.getI18NString(\"service.gui.CERT_INFO_SER_NUM\"), certificate.getSerialNumber().toString());\r\n    addField(sb, R.getI18NString(\"service.gui.CERT_INFO_VER\"), String.valueOf(certificate.getVersion()));\r\n    addField(sb, R.getI18NString(\"service.gui.CERT_INFO_SIGN_ALG\"), String.valueOf(certificate.getSigAlgName()));\r\n    addTitle(sb, R.getI18NString(\"service.gui.CERT_INFO_PUB_KEY_INFO\"));\r\n    addField(sb, R.getI18NString(\"service.gui.CERT_INFO_ALG\"), certificate.getPublicKey().getAlgorithm());\r\n    if (certificate.getPublicKey().getAlgorithm().equals(\"RSA\")) {\r\n        RSAPublicKey key = (RSAPublicKey) certificate.getPublicKey();\r\n        addField(sb, R.getI18NString(\"service.gui.CERT_INFO_PUB_KEY\"), R.getI18NString(\"service.gui.CERT_INFO_KEY_BITS_PRINT\", new String[] { String.valueOf((key.getModulus().toByteArray().length - 1) * 8) }), getHex(key.getModulus().toByteArray()), 48);\r\n        addField(sb, R.getI18NString(\"service.gui.CERT_INFO_EXP\"), key.getPublicExponent().toString());\r\n        addField(sb, R.getI18NString(\"service.gui.CERT_INFO_KEY_SIZE\"), R.getI18NString(\"service.gui.CERT_INFO_KEY_BITS_PRINT\", new String[] { String.valueOf(key.getModulus().bitLength()) }));\r\n    } else if (certificate.getPublicKey().getAlgorithm().equals(\"DSA\")) {\r\n        DSAPublicKey key = (DSAPublicKey) certificate.getPublicKey();\r\n        addField(sb, \"Y:\", key.getY().toString(16));\r\n    }\r\n    addField(sb, R.getI18NString(\"service.gui.CERT_INFO_SIGN\"), R.getI18NString(\"service.gui.CERT_INFO_KEY_BITS_PRINT\", new String[] { String.valueOf(certificate.getSignature().length * 8) }), getHex(certificate.getSignature()), 48);\r\n    sb.append(\"<\/table>\\n\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler.findMediaFormat",
	"Comment": "finds a mediaformat in a specific list of mediaformatswhich matches a specific mediaformat.",
	"Method": "MediaFormat findMediaFormat(List<MediaFormat> formats,MediaFormat format){\r\n    for (MediaFormat match : formats) {\r\n        if (match.matches(format))\r\n            return match;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.whiteboard.WhiteboardObjectPolyLineJabberImpl.setPoints",
	"Comment": "sets the list of whiteboardpoint instances that thiswhiteboardobject is composed of.",
	"Method": "void setPoints(List<WhiteboardPoint> points){\r\n    this.listPoints = new LinkedList<WhiteboardPoint>(points);\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.jabber.TestOperationSetTypingNotifications.prepareContactList",
	"Comment": "create the list to be sure that contacts exchanging messagesexists in each other lists",
	"Method": "void prepareContactList(){\r\n    try {\r\n        opSetPresence1.subscribe(fixture.userID2);\r\n    } catch (OperationFailedException ex) {\r\n    }\r\n    try {\r\n        opSetPresence2.subscribe(fixture.userID1);\r\n    } catch (OperationFailedException ex1) {\r\n    }\r\n    Object o = new Object();\r\n    synchronized (o) {\r\n        o.wait(2000);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl.getAddressFactory",
	"Comment": "returns the addressfactory used to create urls ans address objects.",
	"Method": "AddressFactoryEx getAddressFactory(){\r\n    return addressFactory;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.ConfigurationUtils.isContactListGroupCollapsed",
	"Comment": "returns true if the group given by groupid is collapsedor false otherwise.",
	"Method": "boolean isContactListGroupCollapsed(String groupID){\r\n    String prefix = \"net.java.sip.communicator.impl.gui.contactlist.groups\";\r\n    List<String> groups = configService.getPropertyNamesByPrefix(prefix, true);\r\n    for (String groupRootPropName : groups) {\r\n        String storedID = configService.getString(groupRootPropName);\r\n        if (storedID.equals(groupID)) {\r\n            String status = (String) configService.getProperty(groupRootPropName + \".isClosed\");\r\n            return Boolean.parseBoolean(status);\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.service.protocol.AbstractOperationSetBasicInstantMessaging.createMessageWithUID",
	"Comment": "create a message instance with the specified uid, content typeand a default encoding.this method can be useful when message correction is required. one canconstruct the corrected message to have the same uid as the messagebefore correction.",
	"Method": "Message createMessageWithUID(String messageText,String contentType,String messageUID){\r\n    return createMessage(messageText);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.contactlist.TreeContactList.removeContactListListener",
	"Comment": "removes a listener previously added with addcontactlistlistener.",
	"Method": "void removeContactListListener(ContactListListener listener){\r\n    synchronized (contactListListeners) {\r\n        contactListListeners.remove(listener);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.irc.ChatRoomIrcImpl.addMemberPropertyChangeListener",
	"Comment": "adds the given listener to the list of listeners registered toreceive events upon modification of chat room member properties such asits nickname being changed for example.",
	"Method": "void addMemberPropertyChangeListener(ChatRoomMemberPropertyChangeListener listener){\r\n    synchronized (memberPropChangeListeners) {\r\n        if (!memberPropChangeListeners.contains(listener)) {\r\n            memberPropChangeListeners.add(listener);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetAutoAnswerSipImpl.autoAnswer",
	"Comment": "makes a check after creating call locally, should we answer it.",
	"Method": "boolean autoAnswer(Call call){\r\n    if (answerUnconditional || satisfyAutoAnswerConditions(call)) {\r\n        boolean isVideoCall = doesRequestContainsActiveVideoMediaType(call);\r\n        this.answerCall(call, isVideoCall);\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.ScStdOut.getSystemOut",
	"Comment": "returns the default system.out printstream that was in usebefore this class was instantiated.",
	"Method": "PrintStream getSystemOut(){\r\n    return systemOut;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.extensions.geolocation.GeolocationPacketExtension.addXmlElement",
	"Comment": "creates the xml string corresponding to the specified elementand value and addsthem to the buff stringbuffer.",
	"Method": "StringBuffer addXmlElement(StringBuffer buff,String element,String value){\r\n    if (value != null) {\r\n        buff.append(\"<\").append(element).append(\">\").append(value).append(\"<\/\").append(element).append(\">\");\r\n    }\r\n    return buff;\r\n}"
}, {
	"Path": "net.java.sip.communicator.util.ServiceObserver.getServices",
	"Comment": "returns list of services compatible with service class observed bythis instance.",
	"Method": "List<T> getServices(){\r\n    return Collections.unmodifiableList(services);\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.osdependent.OsDependentActivator.getConfigurationService",
	"Comment": "returns the configurationservice obtained from the bundlecontext.",
	"Method": "ConfigurationService getConfigurationService(){\r\n    if (configService == null) {\r\n        configService = ServiceUtils.getService(bundleContext, ConfigurationService.class);\r\n    }\r\n    return configService;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.icq.AdHocChatRoomIcqImpl.fireMessageEvent",
	"Comment": "notifies all interested listeners that achatroommessagedeliveredevent,chatroommessagereceivedevent or achatroommessagedeliveryfailedevent has been fired.",
	"Method": "void fireMessageEvent(EventObject evt){\r\n    Iterator<AdHocChatRoomMessageListener> listeners = null;\r\n    synchronized (messageListeners) {\r\n        listeners = new ArrayList<AdHocChatRoomMessageListener>(messageListeners).iterator();\r\n    }\r\n    while (listeners.hasNext()) {\r\n        AdHocChatRoomMessageListener listener = listeners.next();\r\n        if (evt instanceof AdHocChatRoomMessageDeliveredEvent) {\r\n            listener.messageDelivered((AdHocChatRoomMessageDeliveredEvent) evt);\r\n        } else if (evt instanceof AdHocChatRoomMessageReceivedEvent) {\r\n            listener.messageReceived((AdHocChatRoomMessageReceivedEvent) evt);\r\n        } else if (evt instanceof AdHocChatRoomMessageDeliveryFailedEvent) {\r\n            listener.messageDeliveryFailed((AdHocChatRoomMessageDeliveryFailedEvent) evt);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.jabber.ChatRoomMemberJabberImpl.getContactAddress",
	"Comment": "returns the contact identifier representing this contact.",
	"Method": "String getContactAddress(){\r\n    return nickName;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.conference.AdHocConferenceChatTransport.sendFile",
	"Comment": "sending files through a chat room is not yet supported by this chattransport implementation.",
	"Method": "FileTransfer sendFile(File file){\r\n    return null;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl.updateMediaDescriptionForZrtp",
	"Comment": "updates the supplied media description with zrtp hello hash if necessary.",
	"Method": "boolean updateMediaDescriptionForZrtp(MediaType mediaType,MediaDescription localMd){\r\n    MediaAwareCallPeer<?, ?, ?> peer = getPeer();\r\n    AccountID accountID = peer.getProtocolProvider().getAccountID();\r\n    boolean b = false;\r\n    if (accountID.getAccountPropertyBoolean(ProtocolProviderFactory.DEFAULT_ENCRYPTION, true) && accountID.isEncryptionProtocolEnabled(SrtpControlType.ZRTP) && peer.getCall().isSipZrtpAttribute()) {\r\n        ZrtpControl zrtpControl = (ZrtpControl) getSrtpControls().getOrCreate(mediaType, SrtpControlType.ZRTP);\r\n        int numberSupportedVersions = zrtpControl.getNumberSupportedVersions();\r\n        try {\r\n            for (int i = 0; i < numberSupportedVersions; i++) {\r\n                String helloHash = zrtpControl.getHelloHash(i);\r\n                if ((helloHash != null) && helloHash.length() > 0) {\r\n                    localMd.setAttribute(SdpUtils.ZRTP_HASH_ATTR, helloHash);\r\n                    b = true;\r\n                }\r\n            }\r\n        } catch (SdpException ex) {\r\n            logger.error(\"Cannot add zrtp-hash to sdp\", ex);\r\n        }\r\n    }\r\n    return b;\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.gui.main.chat.ChatWindowManager.closeChatPanel",
	"Comment": "closes the selected chat tab or the window if there are no tabs.",
	"Method": "void closeChatPanel(ChatPanel chatPanel){\r\n    ChatContainer chatContainer = chatPanel.getChatContainer();\r\n    if (chatContainer != null)\r\n        chatContainer.removeChat(chatPanel);\r\n    boolean isChatPanelContained;\r\n    synchronized (chatPanels) {\r\n        isChatPanelContained = chatPanels.remove(chatPanel);\r\n    }\r\n    if (isChatPanelContained) {\r\n        chatPanel.dispose();\r\n        fireChatClosed(chatPanel);\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.protocol.sip.OperationSetBasicInstantMessagingSipImpl.assertConnected",
	"Comment": "utility method throwing an exception if the stack is not properlyinitialized.",
	"Method": "void assertConnected(){\r\n    if (this.sipProvider == null)\r\n        throw new IllegalStateException(\"The provider must be non-null and signed on the \" + \"service before being able to communicate.\");\r\n    if (!this.sipProvider.isRegistered())\r\n        throw new IllegalStateException(\"The provider must be signed on the service before \" + \"being able to communicate.\");\r\n}"
}, {
	"Path": "net.java.sip.communicator.impl.history.HistoryQueryImpl.fireQueryEvent",
	"Comment": "notifies all registered historyquerylisteners that a new recordhas been received.",
	"Method": "void fireQueryEvent(HistoryRecord record){\r\n    HistoryRecordEvent event = new HistoryRecordEvent(this, record);\r\n    synchronized (queryListeners) {\r\n        for (HistoryQueryListener l : queryListeners) {\r\n            l.historyRecordReceived(event);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.java.sip.communicator.slick.protocol.icq.TestOperationSetFileTransferImpl.suite",
	"Comment": "creates a test suite containing all tests of this class followed bymethod that we want executed last to clear used providers.",
	"Method": "Test suite(){\r\n    TestSuite suite = new TestSuite(TestOperationSetFileTransferImpl.class);\r\n    suite.addTest(new TestOperationSetFileTransferImpl(\"clearProviders\"));\r\n    return suite;\r\n}"
}]