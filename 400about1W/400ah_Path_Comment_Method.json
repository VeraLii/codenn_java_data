[{
	"Path": "net.sourceforge.pmd.lang.metrics.AbstractMetricsFacade.computeForOperation",
	"Comment": "computes a metric identified by its key on a operation ast node.",
	"Method": "double computeForOperation(MetricKey<O> key,O node,MetricOptions options){\r\n    Objects.requireNonNull(key, NULL_KEY_MESSAGE);\r\n    Objects.requireNonNull(options, NULL_OPTIONS_MESSAGE);\r\n    Objects.requireNonNull(node, NULL_NODE_MESSAGE);\r\n    if (!key.supports(node)) {\r\n        return Double.NaN;\r\n    }\r\n    MetricMemoizer<O> memoizer = getLanguageSpecificProjectMemoizer().getOperationMemoizer(node.getQualifiedName());\r\n    return memoizer == null ? Double.NaN : getLanguageSpecificComputer().computeForOperation(key, node, false, options, memoizer);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.fxdesigner.popups.EditPropertyDialogController.bindToDescriptor",
	"Comment": "wires this dialog to the descriptor, so that the controls edit the descriptor.",
	"Method": "void bindToDescriptor(PropertyDescriptorSpec spec,ObservableList<PropertyDescriptorSpec> allDescriptors){\r\n    backingDescriptor.setValue(spec);\r\n    backingDescriptorList.setValue(allDescriptors);\r\n    rewire(spec.nameProperty(), this.nameProperty(), this::setName);\r\n    rewire(spec.typeIdProperty(), this.typeIdProperty(), this::setTypeId);\r\n    rewire(spec.valueProperty(), this.valueProperty(), this::setValue);\r\n    rewire(spec.descriptionProperty(), this.descriptionProperty(), this::setDescription);\r\n}"
}, {
	"Path": "com.querydsl.core.QueryResults.getResults",
	"Comment": "get the results in list forman empty list is returned for no results.",
	"Method": "List<T> getResults(){\r\n    return results;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.rule.XPathRule.evaluate",
	"Comment": "evaluate the xpath query with the ast node. all matches are reported as violations.",
	"Method": "void evaluate(Node node,RuleContext data){\r\n    if (xPathRuleQueryNeedsInitialization()) {\r\n        initXPathRuleQuery();\r\n    }\r\n    List<Node> nodesWithViolation = xpathRuleQuery.evaluate(node, data);\r\n    for (Node nodeWithViolation : nodesWithViolation) {\r\n        addViolation(data, nodeWithViolation, nodeWithViolation.getImage());\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.ast.ASTForStatement.getBody",
	"Comment": "returns the statement that represents the body of thisloop.",
	"Method": "ASTStatement getBody(){\r\n    return (ASTStatement) jjtGetChild(jjtGetNumChildren() - 1);\r\n}"
}, {
	"Path": "org.powermock.core.MockRepository.addFieldTypeToSuppress",
	"Comment": "add a field type to suppress. all fields of this type will be suppressed.",
	"Method": "void addFieldTypeToSuppress(String fieldType){\r\n    suppressFieldTypes.add(fieldType);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.ecmascript.ast.ASTName.isFunctionCallName",
	"Comment": "returns whether this name node is the name of a function call.",
	"Method": "boolean isFunctionCallName(){\r\n    return jjtGetParent() instanceof ASTFunctionCall && ((ASTFunctionCall) jjtGetParent()).getTarget() == this;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.PMDConfiguration.isIgnoreIncrementalAnalysis",
	"Comment": "returns whether incremental analysis was explicitly disabled by the useror not.",
	"Method": "boolean isIgnoreIncrementalAnalysis(){\r\n    return ignoreIncrementalAnalysis;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.qname.JavaTypeQualifiedName.isAnonymousClass",
	"Comment": "returns true if this qualified name identifies ananonymous class.",
	"Method": "boolean isAnonymousClass(){\r\n    return !isLocalClass() && StringUtils.isNumeric(getClassSimpleName());\r\n}"
}, {
	"Path": "com.kabouzeid.gramophone.appwidgets.AppWidgetClassic.defaultAppWidget",
	"Comment": "initialize given widgets to default state, where we launch music ondefault click and hide actions if service not running.",
	"Method": "void defaultAppWidget(Context context,int[] appWidgetIds){\r\n    final RemoteViews appWidgetView = new RemoteViews(context.getPackageName(), R.layout.app_widget_classic);\r\n    appWidgetView.setViewVisibility(R.id.media_titles, View.INVISIBLE);\r\n    appWidgetView.setImageViewResource(R.id.image, R.drawable.default_album_art);\r\n    appWidgetView.setImageViewBitmap(R.id.button_next, createBitmap(Util.getTintedVectorDrawable(context, R.drawable.ic_skip_next_white_24dp, MaterialValueHelper.getSecondaryTextColor(context, true)), 1f));\r\n    appWidgetView.setImageViewBitmap(R.id.button_prev, createBitmap(Util.getTintedVectorDrawable(context, R.drawable.ic_skip_previous_white_24dp, MaterialValueHelper.getSecondaryTextColor(context, true)), 1f));\r\n    appWidgetView.setImageViewBitmap(R.id.button_toggle_play_pause, createBitmap(Util.getTintedVectorDrawable(context, R.drawable.ic_play_arrow_white_24dp, MaterialValueHelper.getSecondaryTextColor(context, true)), 1f));\r\n    linkButtons(context, appWidgetView);\r\n    pushUpdate(context, appWidgetIds, appWidgetView);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.codestyle.UnnecessaryModifierRule.getNodeName",
	"Comment": "todo this should probably make it into a prettyprintingutil or something.",
	"Method": "String getNodeName(Node node){\r\n    if (node instanceof ASTMethodDeclaration) {\r\n        return ((ASTMethodDeclaration) node).getMethodName();\r\n    } else if (node instanceof ASTMethodOrConstructorDeclaration) {\r\n        return ((ASTConstructorDeclaration) node).getQualifiedName().getOperation();\r\n    } else if (node instanceof ASTFieldDeclaration) {\r\n        return ((ASTFieldDeclaration) node).getVariableName();\r\n    } else if (node instanceof ASTResource) {\r\n        return ((ASTResource) node).getVariableDeclaratorId().getImage();\r\n    } else {\r\n        return node.getImage();\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.fxdesigner.util.codearea.SyntaxHighlightingCodeArea.wrapNode",
	"Comment": "wraps a node into a convenience layer that can for example provide the rich text associated with it.",
	"Method": "TextAwareNodeWrapper wrapNode(Node node){\r\n    return NodeStyleSpan.fromNode(node, this).snapshot();\r\n}"
}, {
	"Path": "com.querydsl.core.types.PathMetadataFactory.forMapAccess",
	"Comment": "create a new pathmetadata instance for for key based map access",
	"Method": "PathMetadata forMapAccess(Path<?> parent,Expression<KT> key,PathMetadata forMapAccess,Path<?> parent,KT key){\r\n    return new PathMetadata(parent, key, PathType.MAPVALUE_CONSTANT);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration.getBlock",
	"Comment": "returns the block defined by this method, ornull if the method is abstract.",
	"Method": "ASTBlock getBlock(){\r\n    return getFirstChildOfType(ASTBlock.class);\r\n}"
}, {
	"Path": "org.powermock.reflect.internal.WhiteboxImpl.getFieldsAnnotatedWith",
	"Comment": "get all fields annotated with a particular annotation. this methodtraverses the class hierarchy when checking for the annotation.",
	"Method": "Set<Field> getFieldsAnnotatedWith(Object object,Class<? extends Annotation> annotation,Class<? extends Annotation> additionalAnnotations,Set<Field> getFieldsAnnotatedWith,Object object,Class<? extends Annotation>[] annotationTypes){\r\n    return findAllFieldsUsingStrategy(new FieldAnnotationMatcherStrategy(annotationTypes), object, true, getType(object));\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.jsp.rule.design.NoInlineStyleInformationRule.isStyleAttribute",
	"Comment": "checks whether the attributenode argument is a style attribute of a htmlelement that can have style attributes.",
	"Method": "boolean isStyleAttribute(ASTAttribute attributeNode){\r\n    if (STYLE_ATTRIBUTES.contains(attributeNode.getName().toUpperCase(Locale.ROOT))) {\r\n        if (attributeNode.jjtGetParent() instanceof ASTElement) {\r\n            ASTElement parent = (ASTElement) attributeNode.jjtGetParent();\r\n            if (ELEMENT_NAMES_THAT_CAN_HAVE_STYLE_ATTRIBUTES.contains(parent.getName().toUpperCase(Locale.ROOT))) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.symboltable.ClassScope.determineParameterTypes",
	"Comment": "provide a list of types of the parameters of the given methoddeclaration. the types are simple type images.",
	"Method": "List<TypedNameDeclaration> determineParameterTypes(MethodNameDeclaration mnd){\r\n    List<ASTFormalParameter> parameters = mnd.getMethodNameDeclaratorNode().findDescendantsOfType(ASTFormalParameter.class);\r\n    if (parameters.isEmpty()) {\r\n        return Collections.emptyList();\r\n    }\r\n    List<TypedNameDeclaration> parameterTypes = new ArrayList(parameters.size());\r\n    SourceFileScope fileScope = getEnclosingScope(SourceFileScope.class);\r\n    Map<String, Node> qualifiedTypeNames = fileScope.getQualifiedTypeNames();\r\n    for (ASTFormalParameter p : parameters) {\r\n        if (p.isExplicitReceiverParameter()) {\r\n            continue;\r\n        }\r\n        String typeImage = p.getTypeNode().getTypeImage();\r\n        typeImage = qualifyTypeName(typeImage);\r\n        Node declaringNode = qualifiedTypeNames.get(typeImage);\r\n        Class<?> resolvedType = fileScope.resolveType(typeImage);\r\n        if (resolvedType == null) {\r\n            resolvedType = resolveGenericType(p, typeImage);\r\n        }\r\n        parameterTypes.add(new SimpleTypedNameDeclaration(typeImage, resolvedType, determineSuper(declaringNode)));\r\n    }\r\n    return parameterTypes;\r\n}"
}, {
	"Path": "com.querydsl.core.types.dsl.ComparableExpressionBase.desc",
	"Comment": "create an orderspecifier for descending order of this expression",
	"Method": "OrderSpecifier<T> desc(){\r\n    if (desc == null) {\r\n        desc = new OrderSpecifier<T>(Order.DESC, mixin);\r\n    }\r\n    return desc;\r\n}"
}, {
	"Path": "io.paperdb.DbStoragePlainFile.sync",
	"Comment": "perform an fsync on the given fileoutputstream.the stream at thispoint must be flushed but not yet closed.",
	"Method": "void sync(FileOutputStream stream){\r\n    try {\r\n        if (stream != null) {\r\n            stream.getFD().sync();\r\n        }\r\n    } catch (IOException e) {\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.design.SignatureDeclareThrowsExceptionRule.evaluateExceptions",
	"Comment": "checks all exceptions for possible violation on the exceptiondeclaration.",
	"Method": "void evaluateExceptions(List<ASTName> exceptionList,Object context){\r\n    for (ASTName exception : exceptionList) {\r\n        if (hasDeclaredExceptionInSignature(exception)) {\r\n            addViolation(context, exception);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.errorprone.ConstructorCallsOverridableMethodRule.evaluateDangerOfMethods",
	"Comment": "check the methods called on this class by each of the methods on thisclass. if a method calls an unsafe method, mark the calling method asunsafe. this changes the list of unsafe methods which necessitatesanother pass. keep passing until you make a clean pass in which nomethods are changed to unsafe. for speed it is possible to limit thenumber of passes.impossible to tell type of arguments to method, so forget method matchingon types. just use name and num of arguments. will be some false hits,but oh well.todo investigate limiting the number of passes through config.",
	"Method": "boolean evaluateDangerOfMethods(Map<MethodHolder, List<MethodInvocation>> classMethodMap){\r\n    boolean found = false;\r\n    for (Map.Entry<MethodHolder, List<MethodInvocation>> entry : classMethodMap.entrySet()) {\r\n        MethodHolder h = entry.getKey();\r\n        List<MethodInvocation> calledMeths = entry.getValue();\r\n        for (Iterator<MethodInvocation> calledMethsIter = calledMeths.iterator(); calledMethsIter.hasNext() && !h.isDangerous(); ) {\r\n            MethodInvocation meth = calledMethsIter.next();\r\n            for (MethodHolder h3 : classMethodMap.keySet()) {\r\n                if (h3.isDangerous()) {\r\n                    String matchMethodName = h3.getASTMethodDeclarator().getImage();\r\n                    int matchMethodParamCount = h3.getASTMethodDeclarator().getParameterCount();\r\n                    List<String> parameterTypes = getMethodDeclaratorParameterTypes(h3.getASTMethodDeclarator());\r\n                    if (matchMethodName.equals(meth.getName()) && matchMethodParamCount == meth.getArgumentCount() && parameterTypes.equals(meth.getArgumentTypes())) {\r\n                        h.setDangerous();\r\n                        h.setCalledMethod(matchMethodName);\r\n                        found = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return found;\r\n}"
}, {
	"Path": "com.querydsl.jpa.support.TeradataDialect.getTypeName",
	"Comment": "get the name of the database type associated with the givenjava.sql.types typecode.",
	"Method": "String getTypeName(int code,int length,int precision,int scale){\r\n    float f = precision > 0 ? (float) scale / (float) precision : 0;\r\n    int p = (precision > 18 ? 18 : precision);\r\n    int s = (precision > 18 ? (int) (18.0 * f) : (scale > 18 ? 18 : scale));\r\n    return super.getTypeName(code, length, p, s);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.PMD.getConfiguration",
	"Comment": "get the runtime configuration. the configuration can be modified toaffect how pmd behaves.",
	"Method": "PMDConfiguration getConfiguration(){\r\n    return configuration;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.RuleSet.end",
	"Comment": "triggers the end lifecycle event on each rule in the ruleset. some rulesperform a final summary calculation or cleanup in the end.",
	"Method": "void end(RuleContext ctx){\r\n    for (Rule rule : rules) {\r\n        rule.end(ctx);\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.stat.StatisticalRuleTest.expectedSigma",
	"Comment": "this returns the expected number of results when the sigma rating is thesmallest.",
	"Method": "int expectedSigma(double sigma){\r\n    long expectedMin = Math.round(MEAN + (sigma * SIGMA));\r\n    if (((POINTS - 1) - expectedMin) < 0) {\r\n        return 0;\r\n    }\r\n    return (POINTS - 1) - (int) expectedMin;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.PMDConfiguration.createRenderer",
	"Comment": "create a renderer instance based upon the configured reporting options.no writer is created.",
	"Method": "Renderer createRenderer(Renderer createRenderer,boolean withReportWriter){\r\n    Renderer renderer = RendererFactory.createRenderer(reportFormat, reportProperties);\r\n    renderer.setShowSuppressedViolations(showSuppressedViolations);\r\n    if (withReportWriter) {\r\n        renderer.setWriter(IOUtil.createWriter(reportFile));\r\n    }\r\n    return renderer;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.filter.Filters.getFileExtensionOrDirectoryFilter",
	"Comment": "get a file filter for directories or for files with the given extensions,ignoring case.",
	"Method": "Filter<File> getFileExtensionOrDirectoryFilter(String extensions){\r\n    return new OrFilter(getFileExtensionFilter(extensions), getDirectoryFilter());\r\n}"
}, {
	"Path": "com.querydsl.core.types.Projections.array",
	"Comment": "create a typed array projection for the given type and expressions",
	"Method": "ArrayConstructorExpression<T> array(Class<T[]> type,Expression<T> exprs){\r\n    return new ArrayConstructorExpression<T>(type, exprs);\r\n}"
}, {
	"Path": "samples.expectnew.ExpectNewDemo.throwExceptionWhenInvoction",
	"Comment": "the purpose of the method is to demonstrate that a test case can mock the\tnew instance call and throw an exception upon instantiation.",
	"Method": "void throwExceptionWhenInvoction(){\r\n    new MyClass();\r\n}"
}, {
	"Path": "net.sourceforge.pmd.properties.AbstractPropertySource.copyPropertyValues",
	"Comment": "creates a copied map of the values of the properties and returns it.",
	"Method": "Map<PropertyDescriptor<?>, Object> copyPropertyValues(){\r\n    return new HashMap(propertyValuesByDescriptor);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.ast.ASTForStatement.getGuardExpressionNode",
	"Comment": "returns the node that represents the guard of this loop.this may be any expression of type boolean.if this node represents a foreach loop, or if there isno specified guard, then returns null.",
	"Method": "ASTExpression getGuardExpressionNode(){\r\n    if (isForeach()) {\r\n        return null;\r\n    }\r\n    return getFirstChildOfType(ASTExpression.class);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.database.DBMSMetadata.getConnection",
	"Comment": "return jdbc connection for direct jdbc access to the specified database.",
	"Method": "Connection getConnection(){\r\n    return connection;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.CollectionUtil.getCollectionTypeFor",
	"Comment": "returns the collection type if we recognize it by its short name.",
	"Method": "Class<?> getCollectionTypeFor(String shortName){\r\n    Class<?> cls = COLLECTION_CLASSES_BY_NAMES.typeFor(shortName);\r\n    if (cls != null) {\r\n        return cls;\r\n    }\r\n    return COLLECTION_INTERFACES_BY_NAMES.typeFor(shortName);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.Report.end",
	"Comment": "mark the end time of the report. this is ued to get the elapsed time.",
	"Method": "void end(){\r\n    end = System.currentTimeMillis();\r\n}"
}, {
	"Path": "com.querydsl.core.util.BeanMap.entrySet",
	"Comment": "gets a set of mapentry objects that are the mappings for this beanmap.each mapentry can be set but not removed.",
	"Method": "Set<Entry<String, Object>> entrySet(){\r\n    return new AbstractSet<Entry<String, Object>>() {\r\n        @Override\r\n        public Iterator<Entry<String, Object>> iterator() {\r\n            return entryIterator();\r\n        }\r\n        @Override\r\n        public int size() {\r\n            return BeanMap.this.readMethods.size();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.querydsl.core.util.BeanMap.entrySet",
	"Comment": "gets a set of mapentry objects that are the mappings for this beanmap.each mapentry can be set but not removed.",
	"Method": "Set<Entry<String, Object>> entrySet(){\r\n    return entryIterator();\r\n}"
}, {
	"Path": "com.querydsl.core.util.BeanMap.entrySet",
	"Comment": "gets a set of mapentry objects that are the mappings for this beanmap.each mapentry can be set but not removed.",
	"Method": "Set<Entry<String, Object>> entrySet(){\r\n    return BeanMap.this.readMethods.size();\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.apex.rule.security.ApexOpenRedirectRule.getObjectValue",
	"Comment": "finds any variables being present in pagereference constructor",
	"Method": "void getObjectValue(ApexNode<?> node,Object data){\r\n    final List<ASTVariableExpression> variableExpressions = node.findChildrenOfType(ASTVariableExpression.class);\r\n    for (ASTVariableExpression variable : variableExpressions) {\r\n        if (variable.jjtGetChildIndex() == 0 && !listOfStringLiteralVariables.contains(Helper.getFQVariableName(variable))) {\r\n            addViolation(data, variable);\r\n        }\r\n    }\r\n    final List<ASTBinaryExpression> binaryExpressions = node.findChildrenOfType(ASTBinaryExpression.class);\r\n    for (ASTBinaryExpression z : binaryExpressions) {\r\n        getObjectValue(z, data);\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.CollectionUtil.valuesAreTransitivelyEqual",
	"Comment": "returns whether the arrays are equal by examining each of their elements,even if they are arrays themselves.",
	"Method": "boolean valuesAreTransitivelyEqual(Object[] thisArray,Object[] thatArray){\r\n    if (thisArray == thatArray) {\r\n        return true;\r\n    }\r\n    if (thisArray == null || thatArray == null) {\r\n        return false;\r\n    }\r\n    if (thisArray.length != thatArray.length) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < thisArray.length; i++) {\r\n        if (!areEqual(thisArray[i], thatArray[i])) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "sun.tools.attach.HotSpotVirtualMachine.attachTimeout",
	"Comment": "return attach timeout based on the value of the sun.tools.attach.attachtimeoutproperty, or the default timeout if the property is not set to a positivevalue.",
	"Method": "long attachTimeout(){\r\n    if (attachTimeout == 0) {\r\n        synchronized (this) {\r\n            if (attachTimeout == 0) {\r\n                try {\r\n                    String s = System.getProperty(\"sun.tools.attach.attachTimeout\");\r\n                    attachTimeout = Long.parseLong(s);\r\n                } catch (SecurityException se) {\r\n                } catch (NumberFormatException ne) {\r\n                }\r\n                if (attachTimeout <= 0) {\r\n                    attachTimeout = defaultAttachTimeout;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return attachTimeout;\r\n}"
}, {
	"Path": "org.powermock.reflect.internal.WhiteboxImpl.getAllInstanceFields",
	"Comment": "get all instance fields for a particular object. it returns all fieldsregardless of the field modifier and regardless of where in the classhierarchy a field is located.",
	"Method": "Set<Field> getAllInstanceFields(Object object){\r\n    return findAllFieldsUsingStrategy(new AllFieldsMatcherStrategy(), object, true, getUnproxyType(object));\r\n}"
}, {
	"Path": "net.sourceforge.pmd.RuleSetReferenceId.parse",
	"Comment": "parse a string comma separated list of ruleset reference ids into a listof rulereferenceid instances.",
	"Method": "List<RuleSetReferenceId> parse(String referenceString){\r\n    List<RuleSetReferenceId> references = new ArrayList();\r\n    if (referenceString != null && referenceString.trim().length() > 0) {\r\n        if (referenceString.indexOf(',') == -1) {\r\n            references.add(new RuleSetReferenceId(referenceString));\r\n        } else {\r\n            for (String name : referenceString.split(\",\")) {\r\n                references.add(new RuleSetReferenceId(name.trim()));\r\n            }\r\n        }\r\n    }\r\n    return references;\r\n}"
}, {
	"Path": "org.powermock.api.easymock.PowerMock.createNiceMockAndExpectNew",
	"Comment": "convenience method for createnicemock followed by expectnew.",
	"Method": "T createNiceMockAndExpectNew(Class<T> type,Object arguments,T createNiceMockAndExpectNew,Class<T> type,Class<?>[] parameterTypes,Object arguments){\r\n    T mock = createNiceMock(type);\r\n    IExpectationSetters<T> expectationSetters = expectNiceNew(type, parameterTypes, arguments);\r\n    if (expectationSetters != null) {\r\n        expectationSetters.andReturn(mock);\r\n    }\r\n    return mock;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.properties.PropertyBuilder.require",
	"Comment": "add a constraint on the values that this property may take.the validity of values will be checked when parsing the xml,and invalid values will be reported. a rule will never be runif some of its properties violate some constraints.",
	"Method": "B require(PropertyConstraint<? super T> constraint){\r\n    validators.add(constraint);\r\n    return (B) this;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.testframework.RuleTst.getCleanRuleName",
	"Comment": "getresourceasstream tries to find the xml file in weird locations if therulename includes the package, so we strip it here.",
	"Method": "String getCleanRuleName(Rule rule){\r\n    String fullClassName = rule.getClass().getName();\r\n    if (fullClassName.equals(rule.getName())) {\r\n        String packageName = rule.getClass().getPackage().getName();\r\n        return fullClassName.substring(packageName.length() + 1);\r\n    } else {\r\n        return rule.getName();\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.stat.StatisticalRuleTest.testMetrics",
	"Comment": "this test verifies that the stat rule creates a metric, with the propervalues.",
	"Method": "void testMetrics(){\r\n    Report report = makeReport(ruleUnderTest);\r\n    Iterator<Metric> metrics = report.metrics();\r\n    assertTrue(metrics.hasNext());\r\n    Metric m = metrics.next();\r\n    assertEquals(\"net.sourceforge.pmd.stat.MockStatisticalRule\", m.getMetricName());\r\n    assertEquals(0.0, m.getLowValue(), 0.05);\r\n    assertEquals(POINTS - 1.0, m.getHighValue(), 0.05);\r\n    assertEquals(MEAN, m.getAverage(), 0.05);\r\n    assertEquals(SIGMA, m.getStandardDeviation(), 0.05);\r\n}"
}, {
	"Path": "org.powermock.api.easymock.PowerMock.expectStrictNew",
	"Comment": "allows specifying expectations on new invocations. for example you mightwant to throw an exception or return a mock.this method checks the order of constructor invocations.note that you must replay the class when using this method since thisbehavior is part of the class mock.",
	"Method": "IExpectationSetters<T> expectStrictNew(Class<T> type,Object arguments,IExpectationSetters<T> expectStrictNew,Class<T> type,Class<?>[] parameterTypes,Object arguments){\r\n    return doExpectNew(type, new StrictMockStrategy(), parameterTypes, arguments);\r\n}"
}, {
	"Path": "samples.expectnew.ExpectNewDemo.throwExceptionAndWrapInRunTimeWhenInvoction",
	"Comment": "the purpose of the method is to demonstrate that a test case can mock the\tnew instance call and throw an exception upon instantiation.",
	"Method": "void throwExceptionAndWrapInRunTimeWhenInvoction(){\r\n    try {\r\n        new MyClass();\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.typeresolution.PMDASMClassLoader.getInstance",
	"Comment": "a new pmdasmclassloader is created for each compilation unit, this methodallows to reuse the same pmdasmclassloader across all the compilationunits.",
	"Method": "PMDASMClassLoader getInstance(ClassLoader parent){\r\n    if (parent.equals(cachedClassLoader)) {\r\n        return cachedPMDASMClassLoader;\r\n    }\r\n    cachedClassLoader = parent;\r\n    cachedPMDASMClassLoader = new PMDASMClassLoader(parent);\r\n    return cachedPMDASMClassLoader;\r\n}"
}, {
	"Path": "com.kabouzeid.gramophone.appwidgets.AppWidgetBig.defaultAppWidget",
	"Comment": "initialize given widgets to default state, where we launch music ondefault click and hide actions if service not running.",
	"Method": "void defaultAppWidget(Context context,int[] appWidgetIds){\r\n    final RemoteViews appWidgetView = new RemoteViews(context.getPackageName(), R.layout.app_widget_big);\r\n    appWidgetView.setViewVisibility(R.id.media_titles, View.INVISIBLE);\r\n    appWidgetView.setImageViewResource(R.id.image, R.drawable.default_album_art);\r\n    appWidgetView.setImageViewBitmap(R.id.button_next, createBitmap(Util.getTintedVectorDrawable(context, R.drawable.ic_skip_next_white_24dp, MaterialValueHelper.getPrimaryTextColor(context, false)), 1f));\r\n    appWidgetView.setImageViewBitmap(R.id.button_prev, createBitmap(Util.getTintedVectorDrawable(context, R.drawable.ic_skip_previous_white_24dp, MaterialValueHelper.getPrimaryTextColor(context, false)), 1f));\r\n    appWidgetView.setImageViewBitmap(R.id.button_toggle_play_pause, createBitmap(Util.getTintedVectorDrawable(context, R.drawable.ic_play_arrow_white_24dp, MaterialValueHelper.getPrimaryTextColor(context, false)), 1f));\r\n    linkButtons(context, appWidgetView);\r\n    pushUpdate(context, appWidgetIds, appWidgetView);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.fxdesigner.util.codearea.HighlightLayerCodeArea.updateStyling",
	"Comment": "applies the given update and applies the styling to the code area.we use a closure parameter to encapsulate the application of theupdate inside the restyling procedure, and mostly to make obviousthat each update needs restyling, and each restyling needs an update.",
	"Method": "void updateStyling(Runnable update){\r\n    update.run();\r\n    try {\r\n        this.setStyleSpans(0, recomputePainting());\r\n    } catch (Exception e) {\r\n        if (\"StyleSpan's length cannot be negative\".equals(e.getMessage()) || e.getMessage().contains(\"is not a valid range within\")) {\r\n            return;\r\n        }\r\n        throw new RuntimeException(\"Unhandled error while recomputing the styling\", e);\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.vf.ast.VfDocStyleTest.testELInTagValueWithCommentSQ",
	"Comment": "test parsing of el in attribute of an element that also has a comment.",
	"Method": "void testELInTagValueWithCommentSQ(){\r\n    Set<ASTElement> elememts = getNodes(ASTElement.class, TEST_EL_IN_TAG_ATTRIBUTE_WITH_COMMENT_SQ);\r\n    assertEquals(\"One element expected!\", 1, elememts.size());\r\n    ASTElement element = elememts.iterator().next();\r\n    ASTElExpression elExpr = element.getFirstDescendantOfType(ASTElExpression.class);\r\n    ASTIdentifier id = elExpr.getFirstDescendantOfType(ASTIdentifier.class);\r\n    assertEquals(\"Correct identifier expected\", \"init\", id.getImage());\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.qname.JavaOperationQualifiedName.isLambda",
	"Comment": "returns true if this qualified name identifies a lambda expression.",
	"Method": "boolean isLambda(){\r\n    return isLambda;\r\n}"
}, {
	"Path": "org.powermock.core.MockRepository.addSuppressStaticInitializer",
	"Comment": "add a fully qualified class name for a class that should have its static\tinitializers suppressed.",
	"Method": "void addSuppressStaticInitializer(String className){\r\n    suppressStaticInitializers.add(className);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.fxdesigner.util.codearea.SyntaxHighlightingCodeArea.updateSyntaxHighlightingSynchronously",
	"Comment": "forces synchronous updating of the syntax highlighting.this can be done when we suspect the highlighting is outdatedbut we really need the most up to date one, for example becausewe want to overlay other spans on it.",
	"Method": "void updateSyntaxHighlightingSynchronously(){\r\n    syntaxHighlighter.getOpt().map(h -> h.computeHighlighting(getText())).ifPresent(currentSyntaxHighlight::setValue);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.Report.getCountSummary",
	"Comment": "calculate a summary of violation counts per fully classified class name.",
	"Method": "Map<String, Integer> getCountSummary(){\r\n    Map<String, Integer> summary = new HashMap();\r\n    for (RuleViolation rv : violationTree) {\r\n        String key = keyFor(rv);\r\n        Integer o = summary.get(key);\r\n        summary.put(key, o == null ? NumericConstants.ONE : o + 1);\r\n    }\r\n    return summary;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.RuleSetFactory.containsRule",
	"Comment": "check whether the given rulename is contained in the given ruleset.",
	"Method": "boolean containsRule(RuleSetReferenceId ruleSetReferenceId,String ruleName){\r\n    boolean found = false;\r\n    try (InputStream ruleSet = ruleSetReferenceId.getInputStream(resourceLoader)) {\r\n        DocumentBuilder builder = createDocumentBuilder();\r\n        Document document = builder.parse(ruleSet);\r\n        Element ruleSetElement = document.getDocumentElement();\r\n        NodeList rules = ruleSetElement.getElementsByTagName(\"rule\");\r\n        for (int i = 0; i < rules.getLength(); i++) {\r\n            Element rule = (Element) rules.item(i);\r\n            if (rule.hasAttribute(\"name\") && rule.getAttribute(\"name\").equals(ruleName)) {\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n    return found;\r\n}"
}, {
	"Path": "org.powermock.reflect.internal.WhiteboxImpl.getFieldsOfType",
	"Comment": "get all fields assignable from a particular type. this method traversesthe class hierarchy when checking for the type.",
	"Method": "Set<Field> getFieldsOfType(Object object,Class<?> type){\r\n    return findAllFieldsUsingStrategy(new AssignableFromFieldTypeMatcherStrategy(type), object, true, getType(object));\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.vf.ast.VfDocStyleTest.noSpacesBetweenTags",
	"Comment": "test parsing of html with no spaces between tags. parser is likely inthis scenario.",
	"Method": "void noSpacesBetweenTags(){\r\n    Set<ASTElement> scripts = getNodes(ASTElement.class, TEST_TAGS_NO_SPACE);\r\n    assertEquals(\"Two tags expected!\", 2, scripts.size());\r\n    List<ASTElement> elmts = sortNodesByName(scripts);\r\n    Iterator<ASTElement> iterator = elmts.iterator();\r\n    ASTElement script = iterator.next();\r\n    assertEquals(\"Correct content expected!\", \"a\", script.getName());\r\n    script = iterator.next();\r\n    assertEquals(\"Correct content expected!\", \"b\", script.getName());\r\n}"
}, {
	"Path": "net.sourceforge.pmd.RuleSetFactoryCompatibility.determineEncoding",
	"Comment": "determines the encoding of the given bytes, assuming this is a xmldocument, which specifies the encoding in the first 1024 bytes.",
	"Method": "String determineEncoding(byte[] bytes){\r\n    String firstBytes = new String(bytes, 0, bytes.length > 1024 ? 1024 : bytes.length, Charset.forName(\"ISO-8859-1\"));\r\n    Matcher matcher = ENCODING_PATTERN.matcher(firstBytes);\r\n    String encoding = Charset.forName(\"UTF-8\").name();\r\n    if (matcher.find()) {\r\n        encoding = matcher.group(1);\r\n    }\r\n    return encoding;\r\n}"
}, {
	"Path": "samples.testng.SimpleBaseTest.assertTestResultsEqual",
	"Comment": "compare a list of itestresult with a list of string method names,",
	"Method": "void assertTestResultsEqual(List<ITestResult> results,List<String> methods){\r\n    List<String> resultMethods = Lists.newArrayList();\r\n    for (ITestResult r : results) {\r\n        resultMethods.add(r.getMethod().getMethodName());\r\n    }\r\n    Assert.assertEquals(resultMethods, methods);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.metrics.impl.AbstractJavaClassMetric.countMatchingOpSigs",
	"Comment": "counts the operations matching the signature mask in this class.",
	"Method": "int countMatchingOpSigs(ASTAnyTypeDeclaration classNode,JavaOperationSigMask mask){\r\n    int count = 0;\r\n    List<ASTMethodOrConstructorDeclaration> decls = getMethodsAndConstructors(classNode);\r\n    for (ASTMethodOrConstructorDeclaration decl : decls) {\r\n        if (mask.covers(decl.getSignature())) {\r\n            count++;\r\n        }\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.errorprone.DataflowAnomalyAnalysisRule.violationAlreadyExists",
	"Comment": "checks if a violation already exists. this is needed because on thedifferent paths same anomalies can occur.",
	"Method": "boolean violationAlreadyExists(String type,String var,int startLine,int endLine){\r\n    for (DaaRuleViolation violation : daaRuleViolations) {\r\n        if (violation.getBeginLine() == startLine && violation.getEndLine() == endLine && violation.getType().equals(type) && violation.getVariableName().equals(var)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.performance.ConsecutiveLiteralAppendsRule.checkForViolation",
	"Comment": "helper method checks to see if a violation occurred, and adds aruleviolation if it did",
	"Method": "void checkForViolation(Node node,Object data,int concurrentCount){\r\n    if (concurrentCount > threshold) {\r\n        String[] param = { String.valueOf(concurrentCount) };\r\n        addViolation(data, node, param);\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.AbstractInefficientZeroCheck.checkComparison",
	"Comment": "checks if the equality expression passed in is of comparing against thevalue passed in as i",
	"Method": "boolean checkComparison(String operator,Node equality,int i){\r\n    Node target = equality.jjtGetChild(i).jjtGetChild(0).jjtGetChild(0);\r\n    return target instanceof ASTLiteral && getComparisonTargets().get(operator).contains(target.getImage());\r\n}"
}, {
	"Path": "com.querydsl.core.types.Projections.fields",
	"Comment": "create a field access based bean populating projection for the given type and bindings",
	"Method": "QBean<T> fields(Class<? extends T> type,Expression<?> exprs,QBean<T> fields,Path<? extends T> type,Expression<?> exprs,QBean<T> fields,Path<? extends T> type,Map<String, ? extends Expression<?>> bindings,QBean<T> fields,Class<? extends T> type,Map<String, ? extends Expression<?>> bindings){\r\n    return new QBean<T>(type, true, bindings);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.codestyle.IdenticalCatchBranchesRule.getCaughtExceptionsAsString",
	"Comment": "gets the representation of the set of catch statements as a single multicatch",
	"Method": "String getCaughtExceptionsAsString(ASTCatchStatement stmt){\r\n    StringBuilder sb = new StringBuilder();\r\n    final String delim = \" | \";\r\n    for (ASTType type : stmt.getCaughtExceptionTypeNodes()) {\r\n        sb.append(type.getTypeImage()).append(delim);\r\n    }\r\n    sb.replace(sb.length() - 3, sb.length(), \"\");\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.ramotion.paperonboarding.PaperOnboardingEngine.calculateCurrentCenterCoordinatesOfPagerElement",
	"Comment": "calculate current center coordinates of pager element with provided index",
	"Method": "int[] calculateCurrentCenterCoordinatesOfPagerElement(int activeElementIndex){\r\n    int y = (int) (mPagerIconsContainer.getY() + mPagerIconsContainer.getHeight() / 2);\r\n    if (activeElementIndex >= mPagerIconsContainer.getChildCount())\r\n        return new int[] { mRootLayout.getWidth() / 2, y };\r\n    View pagerElem = mPagerIconsContainer.getChildAt(activeElementIndex);\r\n    int x = (int) (mPagerIconsContainer.getX() + pagerElem.getX() + pagerElem.getWidth() / 2);\r\n    return new int[] { x, y };\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.CollectionUtil.areEqual",
	"Comment": "a comprehensive isequal method that handles nulls and arrays safely.",
	"Method": "boolean areEqual(Object value,Object otherValue){\r\n    if (value == otherValue) {\r\n        return true;\r\n    }\r\n    if (value == null) {\r\n        return false;\r\n    }\r\n    if (otherValue == null) {\r\n        return false;\r\n    }\r\n    if (value.getClass().getComponentType() != null) {\r\n        return arraysAreEqual(value, otherValue);\r\n    }\r\n    return value.equals(otherValue);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.ast.ASTSwitchStatement.getTestedExpression",
	"Comment": "gets the expression tested by this switch.this is the expression between the parentheses.",
	"Method": "ASTExpression getTestedExpression(){\r\n    return (ASTExpression) jjtGetChild(0);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.ast.ASTTypeBound.getBoundTypeNodes",
	"Comment": "returns a list with the type bounds of this node.the returned list has at least one element.",
	"Method": "List<ASTClassOrInterfaceType> getBoundTypeNodes(){\r\n    return findChildrenOfType(ASTClassOrInterfaceType.class);\r\n}"
}, {
	"Path": "com.kabouzeid.gramophone.provider.SongPlayCountStore.updateExistingRow",
	"Comment": "this function will take a song entry and update it to the latest week and increase the countfor the current week by 1 if necessary",
	"Method": "void updateExistingRow(SQLiteDatabase database,long id,boolean bumpCount){\r\n    String stringId = String.valueOf(id);\r\n    database.beginTransaction();\r\n    final Cursor cursor = database.query(SongPlayCountColumns.NAME, null, WHERE_ID_EQUALS, new String[] { stringId }, null, null, null);\r\n    if (cursor != null && cursor.moveToFirst()) {\r\n        int lastUpdatedIndex = cursor.getColumnIndex(SongPlayCountColumns.LAST_UPDATED_WEEK_INDEX);\r\n        int lastUpdatedWeek = cursor.getInt(lastUpdatedIndex);\r\n        int weekDiff = mNumberOfWeeksSinceEpoch - lastUpdatedWeek;\r\n        if (Math.abs(weekDiff) >= NUM_WEEKS) {\r\n            deleteEntry(database, stringId);\r\n            if (bumpCount) {\r\n                createNewPlayedEntry(database, id);\r\n            }\r\n        } else if (weekDiff != 0) {\r\n            int[] playCounts = new int[NUM_WEEKS];\r\n            if (weekDiff > 0) {\r\n                for (int i = 0; i < NUM_WEEKS - weekDiff; i++) {\r\n                    playCounts[i + weekDiff] = cursor.getInt(getColumnIndexForWeek(i));\r\n                }\r\n            } else if (weekDiff < 0) {\r\n                for (int i = 0; i < NUM_WEEKS + weekDiff; i++) {\r\n                    playCounts[i] = cursor.getInt(getColumnIndexForWeek(i - weekDiff));\r\n                }\r\n            }\r\n            if (bumpCount) {\r\n                playCounts[0]++;\r\n            }\r\n            float score = calculateScore(playCounts);\r\n            if (score < .01f) {\r\n                deleteEntry(database, stringId);\r\n            } else {\r\n                ContentValues values = new ContentValues(NUM_WEEKS + 2);\r\n                values.put(SongPlayCountColumns.LAST_UPDATED_WEEK_INDEX, mNumberOfWeeksSinceEpoch);\r\n                values.put(SongPlayCountColumns.PLAY_COUNT_SCORE, score);\r\n                for (int i = 0; i < NUM_WEEKS; i++) {\r\n                    values.put(getColumnNameForWeek(i), playCounts[i]);\r\n                }\r\n                database.update(SongPlayCountColumns.NAME, values, WHERE_ID_EQUALS, new String[] { stringId });\r\n            }\r\n        } else if (bumpCount) {\r\n            ContentValues values = new ContentValues(2);\r\n            int scoreIndex = cursor.getColumnIndex(SongPlayCountColumns.PLAY_COUNT_SCORE);\r\n            float score = cursor.getFloat(scoreIndex) + getScoreMultiplierForWeek(0);\r\n            values.put(SongPlayCountColumns.PLAY_COUNT_SCORE, score);\r\n            values.put(getColumnNameForWeek(0), cursor.getInt(getColumnIndexForWeek(0)) + 1);\r\n            database.update(SongPlayCountColumns.NAME, values, WHERE_ID_EQUALS, new String[] { stringId });\r\n        }\r\n        cursor.close();\r\n    } else if (bumpCount) {\r\n        createNewPlayedEntry(database, id);\r\n    }\r\n    database.setTransactionSuccessful();\r\n    database.endTransaction();\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.JavaRuleViolationTest.testEnumName",
	"Comment": "tests that the enum name is taken correctly from the given node.",
	"Method": "void testEnumName(){\r\n    ASTCompilationUnit ast = parse(\"enum Foo {FOO; void bar(int x) {} }\");\r\n    ASTMethodDeclaration md = ast.getFirstDescendantOfType(ASTMethodDeclaration.class);\r\n    final RuleContext context = new RuleContext();\r\n    final JavaRuleViolation violation = new JavaRuleViolation(null, context, md, null);\r\n    assertEquals(\"Foo\", violation.getClassName());\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.CollectionUtil.isCollectionType",
	"Comment": "return whether we can identify the typename as a java.util collectionclass or interface as specified.",
	"Method": "boolean isCollectionType(String typeName,boolean includeInterfaces,boolean isCollectionType,Class<?> clazzType,boolean includeInterfaces){\r\n    if (COLLECTION_CLASSES_BY_NAMES.contains(clazzType)) {\r\n        return true;\r\n    }\r\n    return includeInterfaces && COLLECTION_INTERFACES_BY_NAMES.contains(clazzType);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.design.SimplifyBooleanReturnsRule.isJustReturnsBooleanAfter",
	"Comment": "checks, whether there is a statement after the given if statement, and ifso, whether this is just a return boolean statement.",
	"Method": "boolean isJustReturnsBooleanAfter(ASTIfStatement ifNode){\r\n    Node blockStatement = ifNode.jjtGetParent().jjtGetParent();\r\n    Node block = blockStatement.jjtGetParent();\r\n    if (block.jjtGetNumChildren() != blockStatement.jjtGetChildIndex() + 1 + 1) {\r\n        return false;\r\n    }\r\n    Node nextBlockStatement = block.jjtGetChild(blockStatement.jjtGetChildIndex() + 1);\r\n    return terminatesInBooleanLiteral(nextBlockStatement);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.jsp.ast.AbstractJspNodesTst.getNodesOfType",
	"Comment": "return a subset of allnodes, containing the items in allnodes that are ofthe given type.",
	"Method": "Set<T> getNodesOfType(Class<T> clazz,Set<JspNode> allNodes){\r\n    Set<T> result = new HashSet();\r\n    for (Node node : allNodes) {\r\n        if (clazz.equals(node.getClass())) {\r\n            result.add((T) node);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "io.paperdb.Book.contains",
	"Comment": "checks if an object with the given key is saved in book storage.",
	"Method": "boolean contains(String key){\r\n    return mStorage.exists(key);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration.getVariableName",
	"Comment": "gets the variable name of this field. this method searches the firstvariabledeclartorid node and returns its image or null ifthe child node is not found.",
	"Method": "String getVariableName(){\r\n    ASTVariableDeclaratorId decl = getFirstDescendantOfType(ASTVariableDeclaratorId.class);\r\n    if (decl != null) {\r\n        return decl.getImage();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.PMDConfiguration.getReportProperties",
	"Comment": "get the report properties. these are used to create the renderer.",
	"Method": "Properties getReportProperties(){\r\n    return reportProperties;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.StringUtil.areSemanticEquals",
	"Comment": "returns true if both strings are effectively null or whitespace, returnsfalse otherwise if they have actual text that differs.",
	"Method": "boolean areSemanticEquals(String a,String b){\r\n    if (a == null) {\r\n        return isEmpty(b);\r\n    }\r\n    if (b == null) {\r\n        return isEmpty(a);\r\n    }\r\n    return a.equals(b);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.cpd.PLSQLTokenizer.tokenize",
	"Comment": "read reader from sourcecode and output an ordered tree of plsql tokens.",
	"Method": "void tokenize(SourceCode sourceCode,Tokens tokenEntries){\r\n    long encounteredTokens = 0;\r\n    long addedTokens = 0;\r\n    if (LOGGER.isLoggable(Level.FINE)) {\r\n        LOGGER.fine(\"PLSQLTokenizer: ignoreIdentifiers==\" + ignoreIdentifiers);\r\n        LOGGER.fine(\"PLSQLTokenizer: ignoreLiterals==\" + ignoreLiterals);\r\n    }\r\n    String fileName = sourceCode.getFileName();\r\n    StringBuilder sb = sourceCode.getCodeBuffer();\r\n    TokenFilter tokenFilter = new JavaCCTokenFilter(new PLSQLTokenManager(new StringReader(sb.toString())));\r\n    Token currentToken = (Token) tokenFilter.getNextToken();\r\n    while (currentToken != null) {\r\n        String image = currentToken.image;\r\n        encounteredTokens++;\r\n        if (ignoreIdentifiers && currentToken.kind == PLSQLParserConstants.IDENTIFIER) {\r\n            image = String.valueOf(currentToken.kind);\r\n        }\r\n        if (ignoreLiterals && (currentToken.kind == PLSQLParserConstants.UNSIGNED_NUMERIC_LITERAL || currentToken.kind == PLSQLParserConstants.FLOAT_LITERAL || currentToken.kind == PLSQLParserConstants.INTEGER_LITERAL || currentToken.kind == PLSQLParserConstants.CHARACTER_LITERAL || currentToken.kind == PLSQLParserConstants.STRING_LITERAL || currentToken.kind == PLSQLParserConstants.QUOTED_LITERAL)) {\r\n            image = String.valueOf(currentToken.kind);\r\n        }\r\n        tokenEntries.add(new TokenEntry(image, fileName, currentToken.beginLine));\r\n        addedTokens++;\r\n        currentToken = (Token) tokenFilter.getNextToken();\r\n    }\r\n    tokenEntries.add(TokenEntry.getEOF());\r\n    if (LOGGER.isLoggable(Level.FINE)) {\r\n        LOGGER.fine(sourceCode.getFileName() + \": encountered \" + encounteredTokens + \" tokens;\" + \" added \" + addedTokens + \" tokens\");\r\n    }\r\n}"
}, {
	"Path": "com.querydsl.core.group.GroupBy.sortedMap",
	"Comment": "create a new aggregating map expression using a backing treemap using the given comparator",
	"Method": "AbstractGroupExpression<Pair<K, V>, SortedMap<K, V>> sortedMap(Expression<K> key,Expression<V> value,AbstractGroupExpression<Pair<K, V>, SortedMap<T, V>> sortedMap,GroupExpression<K, T> key,Expression<V> value,AbstractGroupExpression<Pair<K, V>, SortedMap<K, U>> sortedMap,Expression<K> key,GroupExpression<V, U> value,AbstractGroupExpression<Pair<K, V>, SortedMap<T, U>> sortedMap,GroupExpression<K, T> key,GroupExpression<V, U> value,AbstractGroupExpression<Pair<K, V>, SortedMap<K, V>> sortedMap,Expression<K> key,Expression<V> value,Comparator<? super K> comparator,AbstractGroupExpression<Pair<K, V>, SortedMap<T, V>> sortedMap,GroupExpression<K, T> key,Expression<V> value,Comparator<? super T> comparator,AbstractGroupExpression<Pair<K, V>, SortedMap<K, U>> sortedMap,Expression<K> key,GroupExpression<V, U> value,Comparator<? super K> comparator,AbstractGroupExpression<Pair<K, V>, SortedMap<T, U>> sortedMap,GroupExpression<K, T> key,GroupExpression<V, U> value,Comparator<? super T> comparator){\r\n    return new GMap.Mixin<K, V, T, U, SortedMap<T, U>>(key, value, GMap.createSorted(QPair.create(key, value), comparator));\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.ClassUtil.asShortestName",
	"Comment": "return the name of the type in its short form if its known to usotherwise return its name fully packaged.",
	"Method": "String asShortestName(Class<?> type){\r\n    String name = SHORT_NAMES_BY_TYPE.get(type);\r\n    return name == null ? type.getName() : name;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.benchmark.TimeTracker.startGlobalTracking",
	"Comment": "starts global tracking. allows tracking operations to take place and starts the wall clock.must be called once pmd starts if tracking is desired, no tracking will be performed otherwise.",
	"Method": "void startGlobalTracking(){\r\n    wallClockStartMillis = System.currentTimeMillis();\r\n    trackTime = true;\r\n    ACCUMULATED_RESULTS.clear();\r\n    initThread();\r\n}"
}, {
	"Path": "net.sourceforge.pmd.PMDConfiguration.setMinimumPriority",
	"Comment": "set the minimum priority threshold when loading rules from rulesets.",
	"Method": "void setMinimumPriority(RulePriority minimumPriority){\r\n    this.minimumPriority = minimumPriority;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.AbstractRuleSetFactoryTest.testReadWriteRoundTrip",
	"Comment": "reads and writes the rulesets to make sure, that no data is lost if therulests are processed.",
	"Method": "void testReadWriteRoundTrip(){\r\n    List<String> ruleSetFileNames = getRuleSetFileNames();\r\n    for (String fileName : ruleSetFileNames) {\r\n        testRuleSet(fileName);\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.design.StdCyclomaticComplexityTest.entryStackMustBeEmpty",
	"Comment": "make sure the entry stack is empty, if show classes complexity isdisabled.",
	"Method": "void entryStackMustBeEmpty(){\r\n    StdCyclomaticComplexityRule rule = new StdCyclomaticComplexityRule();\r\n    rule.setProperty(StdCyclomaticComplexityRule.SHOW_CLASSES_COMPLEXITY_DESCRIPTOR, Boolean.FALSE);\r\n    RuleContext ctx = new RuleContext();\r\n    LanguageVersion javaLanguageVersion = LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion(\"1.8\");\r\n    ParserOptions parserOptions = javaLanguageVersion.getLanguageVersionHandler().getDefaultParserOptions();\r\n    Parser parser = javaLanguageVersion.getLanguageVersionHandler().getParser(parserOptions);\r\n    Node node = parser.parse(\"test\", new StringReader(\"public class SampleClass {}\"));\r\n    rule.apply(Arrays.asList(node), ctx);\r\n    Assert.assertTrue(rule.entryStack.isEmpty());\r\n}"
}, {
	"Path": "net.sourceforge.pmd.testframework.RuleTst.runTest",
	"Comment": "run the rule on the given code, and check the expected number ofviolations.",
	"Method": "void runTest(TestDescriptor test){\r\n    Rule rule = test.getRule();\r\n    if (test.getReinitializeRule()) {\r\n        rule = reinitializeRule(rule);\r\n    }\r\n    Map<PropertyDescriptor<?>, Object> oldProperties = rule.getPropertiesByPropertyDescriptor();\r\n    try {\r\n        int res;\r\n        Report report;\r\n        try {\r\n            if (test.getProperties() != null) {\r\n                for (Map.Entry<Object, Object> entry : test.getProperties().entrySet()) {\r\n                    String propertyName = (String) entry.getKey();\r\n                    PropertyDescriptor propertyDescriptor = rule.getPropertyDescriptor(propertyName);\r\n                    if (propertyDescriptor == null) {\r\n                        throw new IllegalArgumentException(\"No such property '\" + propertyName + \"' on Rule \" + rule.getName());\r\n                    }\r\n                    Object value = propertyDescriptor.valueFrom((String) entry.getValue());\r\n                    rule.setProperty(propertyDescriptor, value);\r\n                }\r\n            }\r\n            report = processUsingStringReader(test, rule);\r\n            res = report.size();\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            throw new RuntimeException('\"' + test.getDescription() + \"\\\" failed\", e);\r\n        }\r\n        if (test.getNumberOfProblemsExpected() != res) {\r\n            printReport(test, report);\r\n        }\r\n        assertEquals('\"' + test.getDescription() + \"\\\" resulted in wrong number of failures,\", test.getNumberOfProblemsExpected(), res);\r\n        assertMessages(report, test);\r\n        assertLineNumbers(report, test);\r\n    } finally {\r\n        for (Map.Entry<PropertyDescriptor<?>, Object> entry : oldProperties.entrySet()) {\r\n            rule.setProperty((PropertyDescriptor) entry.getKey(), entry.getValue());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.kabouzeid.gramophone.service.MultiPlayer.setNextDataSource",
	"Comment": "set the mediaplayer to start when this mediaplayer finishes playback.",
	"Method": "void setNextDataSource(String path){\r\n    if (context == null) {\r\n        return;\r\n    }\r\n    try {\r\n        mCurrentMediaPlayer.setNextMediaPlayer(null);\r\n    } catch (IllegalArgumentException e) {\r\n        Log.i(TAG, \"Next media player is current one, continuing\");\r\n    } catch (IllegalStateException e) {\r\n        Log.e(TAG, \"Media player not initialized!\");\r\n        return;\r\n    }\r\n    if (mNextMediaPlayer != null) {\r\n        mNextMediaPlayer.release();\r\n        mNextMediaPlayer = null;\r\n    }\r\n    if (path == null) {\r\n        return;\r\n    }\r\n    if (PreferenceUtil.getInstance(context).gaplessPlayback()) {\r\n        mNextMediaPlayer = new MediaPlayer();\r\n        mNextMediaPlayer.setWakeMode(context, PowerManager.PARTIAL_WAKE_LOCK);\r\n        mNextMediaPlayer.setAudioSessionId(getAudioSessionId());\r\n        if (setDataSourceImpl(mNextMediaPlayer, path)) {\r\n            try {\r\n                mCurrentMediaPlayer.setNextMediaPlayer(mNextMediaPlayer);\r\n            } catch (@NonNull IllegalArgumentException | IllegalStateException e) {\r\n                Log.e(TAG, \"setNextDataSource: setNextMediaPlayer()\", e);\r\n                if (mNextMediaPlayer != null) {\r\n                    mNextMediaPlayer.release();\r\n                    mNextMediaPlayer = null;\r\n                }\r\n            }\r\n        } else {\r\n            if (mNextMediaPlayer != null) {\r\n                mNextMediaPlayer.release();\r\n                mNextMediaPlayer = null;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.fxdesigner.util.beans.BeanModelNodeSeq.getPropertyName",
	"Comment": "returns the name of the property that contains the collection.",
	"Method": "String getPropertyName(){\r\n    return propertyName;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.RuleSetReferenceId.getInputStream",
	"Comment": "try to load the ruleset resource with the specified resourceloader. multipleattempts to get independent inputstream instances may be made, sosubclasses must ensure they support this behavior. delegates to anexternal rulesetreferenceid if there is one associated with thisinstance.",
	"Method": "InputStream getInputStream(ResourceLoader rl){\r\n    if (externalRuleSetReferenceId == null) {\r\n        InputStream in = StringUtils.isBlank(ruleSetFileName) ? null : rl.loadResourceAsStream(ruleSetFileName);\r\n        if (in == null) {\r\n            throw new RuleSetNotFoundException(\"Can't find resource '\" + ruleSetFileName + \"' for rule '\" + ruleName + \"'\" + \".  Make sure the resource is a valid file or URL and is on the CLASSPATH. \" + \"Here's the current classpath: \" + System.getProperty(\"java.class.path\"));\r\n        }\r\n        return in;\r\n    } else {\r\n        return externalRuleSetReferenceId.getInputStream(rl);\r\n    }\r\n}"
}, {
	"Path": "com.kabouzeid.gramophone.appwidgets.AppWidgetCard.defaultAppWidget",
	"Comment": "initialize given widgets to default state, where we launch music ondefault click and hide actions if service not running.",
	"Method": "void defaultAppWidget(Context context,int[] appWidgetIds){\r\n    final RemoteViews appWidgetView = new RemoteViews(context.getPackageName(), R.layout.app_widget_card);\r\n    appWidgetView.setViewVisibility(R.id.media_titles, View.INVISIBLE);\r\n    appWidgetView.setImageViewResource(R.id.image, R.drawable.default_album_art);\r\n    appWidgetView.setImageViewBitmap(R.id.button_next, createBitmap(Util.getTintedVectorDrawable(context, R.drawable.ic_skip_next_white_24dp, MaterialValueHelper.getSecondaryTextColor(context, true)), 1f));\r\n    appWidgetView.setImageViewBitmap(R.id.button_prev, createBitmap(Util.getTintedVectorDrawable(context, R.drawable.ic_skip_previous_white_24dp, MaterialValueHelper.getSecondaryTextColor(context, true)), 1f));\r\n    appWidgetView.setImageViewBitmap(R.id.button_toggle_play_pause, createBitmap(Util.getTintedVectorDrawable(context, R.drawable.ic_play_arrow_white_24dp, MaterialValueHelper.getSecondaryTextColor(context, true)), 1f));\r\n    linkButtons(context, appWidgetView);\r\n    pushUpdate(context, appWidgetIds, appWidgetView);\r\n}"
}, {
	"Path": "com.querydsl.core.types.dsl.Expressions.currentDate",
	"Comment": "create an expression representing the current date as a dateexpression instance",
	"Method": "DateExpression<Date> currentDate(){\r\n    return DateExpression.currentDate();\r\n}"
}, {
	"Path": "net.sourceforge.pmd.properties.AbstractPropertySource.copyPropertyDescriptors",
	"Comment": "creates a copied list of the property descriptors and returns it.",
	"Method": "List<PropertyDescriptor<?>> copyPropertyDescriptors(){\r\n    return new ArrayList(propertyDescriptors);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.database.DBMSMetadata.getSourceObjectList",
	"Comment": "return all source code objects associated with any associated dburi.",
	"Method": "List<SourceObject> getSourceObjectList(List<SourceObject> getSourceObjectList,List<String> languages,List<String> schemas,List<String> sourceCodeTypes,List<String> sourceCodeNames){\r\n    List<SourceObject> sourceObjectsList = new ArrayList();\r\n    List<String> searchLanguages = languages;\r\n    List<String> searchSchemas = schemas;\r\n    List<String> searchSourceCodeTypes = sourceCodeTypes;\r\n    List<String> searchSourceCodeNames = sourceCodeNames;\r\n    List<String> wildcardList = Arrays.asList(\"%\");\r\n    if (null == searchLanguages) {\r\n        List<String> dbURIList = (null == dburi) ? null : dburi.getLanguagesList();\r\n        if (null == dbURIList || dbURIList.isEmpty()) {\r\n            searchLanguages = wildcardList;\r\n        } else {\r\n            searchLanguages = dbURIList;\r\n        }\r\n    }\r\n    if (null == searchSchemas) {\r\n        List<String> dbURIList = (null == dburi) ? null : dburi.getSchemasList();\r\n        if (null == dbURIList || dbURIList.isEmpty()) {\r\n            searchSchemas = wildcardList;\r\n        } else {\r\n            searchSchemas = dbURIList;\r\n        }\r\n    }\r\n    if (null == searchSourceCodeTypes) {\r\n        List<String> dbURIList = (null == dburi) ? null : dburi.getSourceCodeTypesList();\r\n        if (null == dbURIList || dbURIList.isEmpty()) {\r\n            searchSourceCodeTypes = wildcardList;\r\n        } else {\r\n            searchSourceCodeTypes = dbURIList;\r\n        }\r\n    }\r\n    if (null == searchSourceCodeNames) {\r\n        List<String> dbURIList = (null == dburi) ? null : dburi.getSourceCodeNamesList();\r\n        if (null == dbURIList || dbURIList.isEmpty()) {\r\n            searchSourceCodeNames = wildcardList;\r\n        } else {\r\n            searchSourceCodeNames = dbURIList;\r\n        }\r\n    }\r\n    try {\r\n        if (null != returnSourceCodeObjectsStatement) {\r\n            LOGGER.log(Level.FINE, \"Have bespoke returnSourceCodeObjectsStatement from DBURI: \\\"{0}\\\"\", returnSourceCodeObjectsStatement);\r\n            try (PreparedStatement sourceCodeObjectsStatement = getConnection().prepareStatement(returnSourceCodeObjectsStatement)) {\r\n                for (String language : searchLanguages) {\r\n                    for (String schema : searchSchemas) {\r\n                        for (String sourceCodeType : searchSourceCodeTypes) {\r\n                            for (String sourceCodeName : searchSourceCodeNames) {\r\n                                sourceObjectsList.addAll(findSourceObjects(sourceCodeObjectsStatement, language, schema, sourceCodeType, sourceCodeName));\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            LOGGER.fine(\"Have dbUri - no returnSourceCodeObjectsStatement, reverting to DatabaseMetaData.getProcedures(...)\");\r\n            DatabaseMetaData metadata = connection.getMetaData();\r\n            List<String> schemasList = dburi.getSchemasList();\r\n            for (String schema : schemasList) {\r\n                for (String sourceCodeName : dburi.getSourceCodeNamesList()) {\r\n                    sourceObjectsList.addAll(findSourceObjectFromMetaData(metadata, schema, sourceCodeName));\r\n                }\r\n            }\r\n        }\r\n        LOGGER.finer(String.format(\"Identfied=%d sourceObjects\", sourceObjectsList.size()));\r\n        return sourceObjectsList;\r\n    } catch (SQLException sqle) {\r\n        throw new RuntimeException(\"Problem collecting list of source code objects\", sqle);\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.codestyle.PrematureDeclarationRule.isReference",
	"Comment": "return whether the shortname is part of the compound name by itself or asa method call receiver.",
	"Method": "boolean isReference(String shortName,String compoundName){\r\n    int dotPos = compoundName.indexOf('.');\r\n    return dotPos < 0 ? shortName.equals(compoundName) : shortName.equals(compoundName.substring(0, dotPos));\r\n}"
}, {
	"Path": "samples.staticinitializer.EvilStaticInitializerExample.doSomeNativeStuffUsingTheLoadedSystemLibrary",
	"Comment": "we imagine that this method require the library to execute, but we want\tto test it anyway in separation.",
	"Method": "String doSomeNativeStuffUsingTheLoadedSystemLibrary(){\r\n    return \"native stuff\";\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.metrics.impl.TccMetric.numMethodsRelatedByAttributeAccess",
	"Comment": "gets the number of pairs of methods that use at least one attribute in common.",
	"Method": "int numMethodsRelatedByAttributeAccess(Map<String, Set<String>> usagesByMethod){\r\n    List<String> methods = new ArrayList(usagesByMethod.keySet());\r\n    int methodCount = methods.size();\r\n    int pairs = 0;\r\n    if (methodCount > 1) {\r\n        for (int i = 0; i < methodCount - 1; i++) {\r\n            for (int j = i + 1; j < methodCount; j++) {\r\n                String firstMethodName = methods.get(i);\r\n                String secondMethodName = methods.get(j);\r\n                if (!Collections.disjoint(usagesByMethod.get(firstMethodName), usagesByMethod.get(secondMethodName))) {\r\n                    pairs++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return pairs;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.CollectionUtil.mapFrom",
	"Comment": "creates and returns a map populated with the keyvaluessets where thevalue held by the tuples are they key and value in that order.",
	"Method": "Map<K, V> mapFrom(K[] keys,V[] values){\r\n    if (keys.length != values.length) {\r\n        throw new RuntimeException(\"mapFrom keys and values arrays have different sizes\");\r\n    }\r\n    Map<K, V> map = new HashMap(keys.length);\r\n    for (int i = 0; i < keys.length; i++) {\r\n        map.put(keys[i], values[i]);\r\n    }\r\n    return map;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.vm.directive.Break.isScopeProvided",
	"Comment": "since there is no processing of content, there is never a need for aninternal scope.",
	"Method": "boolean isScopeProvided(){\r\n    return false;\r\n}"
}, {
	"Path": "com.querydsl.jpa.JPAExpressions.selectDistinct",
	"Comment": "create a new detached jpqlquery instance with the given projection",
	"Method": "JPQLQuery<T> selectDistinct(Expression<T> expr,JPQLQuery<Tuple> selectDistinct,Expression<?> exprs){\r\n    return new JPASubQuery<Void>().select(exprs).distinct();\r\n}"
}, {
	"Path": "com.kabouzeid.gramophone.loader.SortedCursor.buildCursorPositionMapping",
	"Comment": "this function populates morderedpositions with the cursor positions in the order basedon the order passed in",
	"Method": "ArrayList<String> buildCursorPositionMapping(String[] order,String columnName){\r\n    ArrayList<String> missingValues = new ArrayList();\r\n    mOrderedPositions = new ArrayList(mCursor.getCount());\r\n    mMapCursorPositions = new HashMap(mCursor.getCount());\r\n    final int valueColumnIndex = mCursor.getColumnIndex(columnName);\r\n    if (mCursor.moveToFirst()) {\r\n        do {\r\n            mMapCursorPositions.put(mCursor.getString(valueColumnIndex), mCursor.getPosition());\r\n        } while (mCursor.moveToNext());\r\n        if (order != null) {\r\n            for (final String value : order) {\r\n                if (mMapCursorPositions.containsKey(value)) {\r\n                    mOrderedPositions.add(mMapCursorPositions.get(value));\r\n                    mMapCursorPositions.remove(value);\r\n                } else {\r\n                    missingValues.add(value);\r\n                }\r\n            }\r\n        }\r\n        mCursor.moveToFirst();\r\n    }\r\n    return missingValues;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.vf.ast.VfDocStyleTest.testComplexHtmlScript",
	"Comment": "a complex script containing html comments, escapes, quotes, etc.",
	"Method": "void testComplexHtmlScript(){\r\n    Set<ASTHtmlScript> script = getNodes(ASTHtmlScript.class, TEST_COMPLEX_SCRIPT);\r\n    assertEquals(\"One script expected!\", 1, script.size());\r\n    ASTHtmlScript next = script.iterator().next();\r\n    ASTText text = next.getFirstChildOfType(ASTText.class);\r\n    assertTrue(text.getImage().contains(\"<!--\"));\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.performance.InsufficientStringBufferDeclarationRule.storeBlockStatistics",
	"Comment": "this rule is concerned with if and switch blocks. process the block intoa local map, from which we can later determine which is the longest blockinside",
	"Method": "void storeBlockStatistics(Map<Node, Map<Node, Integer>> blocks,int thisSize,Node block){\r\n    Node statement = block.jjtGetParent();\r\n    if (block.jjtGetParent() instanceof ASTIfStatement) {\r\n        Node possibleStatement = statement.getFirstParentOfType(ASTIfStatement.class);\r\n        while (possibleStatement instanceof ASTIfStatement) {\r\n            statement = possibleStatement;\r\n            possibleStatement = possibleStatement.getFirstParentOfType(ASTIfStatement.class);\r\n        }\r\n    }\r\n    Map<Node, Integer> thisBranch = blocks.get(statement);\r\n    if (thisBranch == null) {\r\n        thisBranch = new HashMap();\r\n        blocks.put(statement, thisBranch);\r\n    }\r\n    Integer x = thisBranch.get(block);\r\n    if (x != null) {\r\n        thisSize += x;\r\n    }\r\n    thisBranch.put(statement, thisSize);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.RuleContext.getLanguageVersion",
	"Comment": "get the languageversion associated with the current source file.",
	"Method": "LanguageVersion getLanguageVersion(){\r\n    return this.languageVersion;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.apex.metrics.impl.AbstractApexMetricTestRule.optionMappings",
	"Comment": "mappings of labels to options for use in the options property.",
	"Method": "Map<String, MetricOption> optionMappings(){\r\n    return new HashMap();\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.ast.ASTSwitchStatement.isExhaustiveEnumSwitch",
	"Comment": "returns true if this switch statement tests an expressionhaving an enum type and all the constants of this typeare covered by a switch case. returns false if the type ofthe tested expression could not be resolved.",
	"Method": "boolean isExhaustiveEnumSwitch(){\r\n    ASTExpression expression = getTestedExpression();\r\n    if (expression.getType() == null) {\r\n        return false;\r\n    }\r\n    if (Enum.class.isAssignableFrom(expression.getType())) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        Set<String> constantNames = EnumUtils.getEnumMap((Class<? extends Enum>) expression.getType()).keySet();\r\n        for (ASTSwitchLabel label : this) {\r\n            constantNames.remove(label.getFirstDescendantOfType(ASTName.class).getImage());\r\n        }\r\n        return constantNames.isEmpty();\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.powermock.api.easymock.PowerMock.expectNiceNew",
	"Comment": "allows specifying expectations on new invocations. for example you mightwant to throw an exception or return a mock.this method allows any number of calls to a new constructor withoutthrowing an exception.note that you must replay the class when using this method since thisbehavior is part of the class mock.",
	"Method": "IExpectationSetters<T> expectNiceNew(Class<T> type,Object arguments,IExpectationSetters<T> expectNiceNew,Class<T> type,Class<?>[] parameterTypes,Object arguments){\r\n    return doExpectNew(type, new NiceMockStrategy(), parameterTypes, arguments);\r\n}"
}, {
	"Path": "com.querydsl.lucene5.AbstractLuceneQuery.distinct",
	"Comment": "add a duplicatefilter for the field of the given property path",
	"Method": "Q distinct(Q distinct,Path<?> property){\r\n    return filter(new DuplicateFilter(serializer.toField(property)));\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.ecmascript.ast.ASTName.isFunctionNodeName",
	"Comment": "returns whether this name node is the name of a function declaration.",
	"Method": "boolean isFunctionNodeName(){\r\n    return jjtGetParent() instanceof ASTFunctionNode && ((ASTFunctionNode) jjtGetParent()).getFunctionName() == this;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.fxdesigner.util.beans.SettingsPersistenceUtil.restoreProperties",
	"Comment": "restores properties contained in the file into the given object.",
	"Method": "void restoreProperties(SettingsOwner root,File file){\r\n    Optional<Document> odoc = getDocument(file);\r\n    odoc.flatMap(XmlFormatRevision::getSuitableReader).map(rev -> rev.xmlInterface).flatMap(xmlInterface -> odoc.flatMap(xmlInterface::parseXml)).ifPresent(n -> restoreSettings(root, n));\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.vf.ast.AbstractVfNodesTest.getNodes",
	"Comment": "run the vf parser on the source, and return the nodes of type clazz.",
	"Method": "Set<T> getNodes(Class<T> clazz,String source){\r\n    VfParser parser = new VfParser(new JavaCharStream(new StringReader(source)));\r\n    Node rootNode = parser.CompilationUnit();\r\n    Set<T> nodes = new HashSet();\r\n    addNodeAndSubnodes(rootNode, nodes, clazz);\r\n    return nodes;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.RuleSetFactory.parseRuleSetReferenceNode",
	"Comment": "parse a rule node as an rulesetreference for all rules. every rule fromthe referred to ruleset will be added as a rulereference except for thoseexplicitly excluded, below the minimum priority threshold for thisrulesetfactory, or which are deprecated.",
	"Method": "void parseRuleSetReferenceNode(RuleSetBuilder ruleSetBuilder,Element ruleElement,String ref){\r\n    String priority = null;\r\n    NodeList childNodes = ruleElement.getChildNodes();\r\n    Set<String> excludedRulesCheck = new HashSet();\r\n    for (int i = 0; i < childNodes.getLength(); i++) {\r\n        Node child = childNodes.item(i);\r\n        if (isElementNode(child, \"exclude\")) {\r\n            Element excludeElement = (Element) child;\r\n            String excludedRuleName = excludeElement.getAttribute(\"name\");\r\n            excludedRulesCheck.add(excludedRuleName);\r\n        } else if (isElementNode(child, PRIORITY)) {\r\n            priority = parseTextNode(child).trim();\r\n        }\r\n    }\r\n    final RuleSetReference ruleSetReference = new RuleSetReference(ref, true, excludedRulesCheck);\r\n    RuleSetFactory ruleSetFactory = new RuleSetFactory(resourceLoader, RulePriority.LOW, warnDeprecated, this.compatibilityFilter != null);\r\n    RuleSet otherRuleSet = ruleSetFactory.createRuleSet(RuleSetReferenceId.parse(ref).get(0));\r\n    List<RuleReference> potentialRules = new ArrayList();\r\n    int countDeprecated = 0;\r\n    for (Rule rule : otherRuleSet.getRules()) {\r\n        excludedRulesCheck.remove(rule.getName());\r\n        if (!ruleSetReference.getExcludes().contains(rule.getName())) {\r\n            RuleReference ruleReference = new RuleReference(rule, ruleSetReference);\r\n            if (priority != null) {\r\n                ruleReference.setPriority(RulePriority.valueOf(Integer.parseInt(priority)));\r\n            }\r\n            if (rule.isDeprecated()) {\r\n                countDeprecated++;\r\n            }\r\n            potentialRules.add(ruleReference);\r\n        }\r\n    }\r\n    boolean rulesetDeprecated = false;\r\n    if (!potentialRules.isEmpty() && potentialRules.size() == countDeprecated) {\r\n        rulesetDeprecated = true;\r\n        LOG.warning(\"The RuleSet \" + ref + \" has been deprecated and will be removed in PMD \" + PMDVersion.getNextMajorRelease());\r\n    }\r\n    for (RuleReference r : potentialRules) {\r\n        if (rulesetDeprecated || !r.getRule().isDeprecated()) {\r\n            ruleSetBuilder.addRuleIfNotExists(r);\r\n        }\r\n    }\r\n    if (!excludedRulesCheck.isEmpty()) {\r\n        throw new IllegalArgumentException(\"Unable to exclude rules \" + excludedRulesCheck + \"; perhaps the rule name is mispelled?\");\r\n    }\r\n}"
}, {
	"Path": "org.powermock.api.easymock.PowerMock.expectPrivate",
	"Comment": "used to specify expectations on methods using the method name. works onfor example private or package private methods.",
	"Method": "IExpectationSetters<T> expectPrivate(Class<?> clazz,Method method,Object arguments,IExpectationSetters<T> expectPrivate,Object instance,Method method,Object arguments,IExpectationSetters<T> expectPrivate,Object instance,String methodName,Class<?>[] parameterTypes,Object arguments,IExpectationSetters<T> expectPrivate,Object instance,String methodName,Object arguments,IExpectationSetters<T> expectPrivate,Object instance,Object arguments,IExpectationSetters<T> expectPrivate,Object instance,String methodName,Class<?> where,Class<?>[] parameterTypes,Object arguments,IExpectationSetters<T> expectPrivate,Object instance,String methodName,Class<?> where,Object arguments){\r\n    return expectPrivate(instance, methodName, where, null, arguments);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.dfa.Structure.pushOnStack",
	"Comment": "the bracestack contains all nodes which are important to link the dataflow nodes. the cbrstack contains continue, break, and return nodes.there are 2 stacks because the have to process differently.",
	"Method": "void pushOnStack(NodeType type,DataFlowNode node){\r\n    StackObject obj = new StackObject(type, node);\r\n    if (type == NodeType.RETURN_STATEMENT || type == NodeType.BREAK_STATEMENT || type == NodeType.CONTINUE_STATEMENT || type == NodeType.THROW_STATEMENT) {\r\n        continueBreakReturnStack.push(obj);\r\n        tryToLog(\"continueBreakReturnStack\", node);\r\n    } else {\r\n        braceStack.push(obj);\r\n        tryToLog(\"braceStack\", node);\r\n    }\r\n    node.setType(type);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.Report.merge",
	"Comment": "merges the given report into this report. this might be necessary, if asummary over all violations is needed as pmd creates one report per fileby default.",
	"Method": "void merge(Report r){\r\n    Iterator<ProcessingError> i = r.errors();\r\n    while (i.hasNext()) {\r\n        addError(i.next());\r\n    }\r\n    Iterator<ConfigurationError> ce = r.configErrors();\r\n    while (ce.hasNext()) {\r\n        addConfigError(ce.next());\r\n    }\r\n    Iterator<Metric> m = r.metrics();\r\n    while (m.hasNext()) {\r\n        addMetric(m.next());\r\n    }\r\n    Iterator<RuleViolation> v = r.iterator();\r\n    while (v.hasNext()) {\r\n        RuleViolation violation = v.next();\r\n        int index = Collections.binarySearch(violations, violation, RuleViolationComparator.INSTANCE);\r\n        violations.add(index < 0 ? -index - 1 : index, violation);\r\n        violationTree.addRuleViolation(violation);\r\n    }\r\n    Iterator<SuppressedViolation> s = r.getSuppressedRuleViolations().iterator();\r\n    while (s.hasNext()) {\r\n        suppressedRuleViolations.add(s.next());\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.ast.ASTLocalVariableDeclaration.getVariableName",
	"Comment": "for a deprecated attribute. we may use another annotation for that.",
	"Method": "String getVariableName(){\r\n    ASTVariableDeclaratorId decl = getFirstDescendantOfType(ASTVariableDeclaratorId.class);\r\n    if (decl != null) {\r\n        return decl.getImage();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.jsp.ast.JspDocStyleTest.noQuoteAttrTab",
	"Comment": "tests whether parse correctly interprets an tab instead of an attribute",
	"Method": "void noQuoteAttrTab(){\r\n    Set<ASTAttributeValue> attributes = getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_TAB_ATTR);\r\n    assertEquals(\"One attribute expected!\", 1, attributes.size());\r\n    Iterator<ASTAttributeValue> iterator = attributes.iterator();\r\n    ASTAttributeValue attr = iterator.next();\r\n    assertEquals(\"Expected to detect proper value for attribute!\", \"\\t\", attr.getImage());\r\n}"
}, {
	"Path": "net.sourceforge.pmd.renderers.RendererFactory.createRenderer",
	"Comment": "construct an instance of a renderer based on report format name.",
	"Method": "Renderer createRenderer(String reportFormat,Properties properties){\r\n    Class<? extends Renderer> rendererClass = getRendererClass(reportFormat);\r\n    Constructor<? extends Renderer> constructor = getRendererConstructor(rendererClass);\r\n    Renderer renderer;\r\n    try {\r\n        if (constructor.getParameterTypes().length > 0) {\r\n            LOG.warning(\"The renderer uses a deprecated mechanism to use the properties. Please define the needed properties with this.definePropertyDescriptor(..).\");\r\n            renderer = constructor.newInstance(properties);\r\n        } else {\r\n            renderer = constructor.newInstance();\r\n            for (PropertyDescriptor<?> prop : renderer.getPropertyDescriptors()) {\r\n                String value = properties.getProperty(prop.name());\r\n                if (value != null) {\r\n                    @SuppressWarnings(\"unchecked\")\r\n                    PropertyDescriptor<Object> prop2 = (PropertyDescriptor<Object>) prop;\r\n                    Object valueFrom = prop2.valueFrom(value);\r\n                    renderer.setProperty(prop2, valueFrom);\r\n                }\r\n            }\r\n        }\r\n    } catch (InstantiationException | IllegalAccessException e) {\r\n        throw new IllegalArgumentException(\"Unable to construct report renderer class: \" + e.getLocalizedMessage(), e);\r\n    } catch (InvocationTargetException e) {\r\n        throw new IllegalArgumentException(\"Unable to construct report renderer class: \" + e.getTargetException().getLocalizedMessage(), e);\r\n    }\r\n    if (REPORT_FORMAT_TO_RENDERER.containsKey(reportFormat) && !reportFormat.equals(renderer.getName())) {\r\n        if (LOG.isLoggable(Level.WARNING)) {\r\n            LOG.warning(\"Report format '\" + reportFormat + \"' is deprecated, and has been replaced with '\" + renderer.getName() + \"'. Future versions of PMD will remove support for this deprecated Report format usage.\");\r\n        }\r\n    }\r\n    return renderer;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.ast.xpath.saxon.AbstractNodeInfo.createUnsupportedOperationException",
	"Comment": "used to create a customized instance of unsupportedoperationexception.the caller of this method is intended to throw theexception.",
	"Method": "UnsupportedOperationException createUnsupportedOperationException(String name){\r\n    return new UnsupportedOperationException(name + \" is not implemented by \" + this.getClass().getName());\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.JavaRuleViolationTest.testPackageAndClassName",
	"Comment": "tests that the class name is taken correctly, even if the node is outsideof a class scope, e.g. a import declaration.",
	"Method": "void testPackageAndClassName(){\r\n    ASTCompilationUnit ast = parse(\"package pkg; import java.util.List; public class Foo { }\");\r\n    ASTImportDeclaration importNode = ast.getFirstDescendantOfType(ASTImportDeclaration.class);\r\n    JavaRuleViolation violation = new JavaRuleViolation(null, new RuleContext(), importNode, null);\r\n    assertEquals(\"pkg\", violation.getPackageName());\r\n    assertEquals(\"Foo\", violation.getClassName());\r\n}"
}, {
	"Path": "org.powermock.api.easymock.PowerMock.createStrictPartialMock",
	"Comment": "strictly mock a single specific method. use this to handle overloadedmethods.",
	"Method": "T createStrictPartialMock(Class<T> type,String methodNameToMock,Class<?> firstArgumentType,Class<?> additionalArgumentTypes,T createStrictPartialMock,Class<T> type,String methodNames,T createStrictPartialMock,Class<T> type,Class<? super T> where,String methodNames,T createStrictPartialMock,Class<T> type,String[] methodNames,Object constructorArguments,T createStrictPartialMock,Class<T> type,String methodName,Class<?>[] methodParameterTypes,Object constructorArguments,T createStrictPartialMock,Class<T> type,String methodName,Class<?>[] methodParameterTypes,Object[] constructorArguments,Class<?>[] constructorParameterTypes){\r\n    ConstructorArgs constructorArgs = new ConstructorArgs(Whitebox.getConstructor(type, constructorParameterTypes), constructorArguments);\r\n    return doMockSpecific(type, new StrictMockStrategy(), new String[] { methodName }, constructorArgs, methodParameterTypes);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.StringUtil.maxCommonLeadingWhitespaceForAll",
	"Comment": "determine the maximum number of common leading whitespace characters thestrings share in the same sequence. useful for determining how manyleading characters can be removed to shift all the text in the strings tothe left without misaligning them.",
	"Method": "int maxCommonLeadingWhitespaceForAll(String[] strings){\r\n    int shortest = lengthOfShortestIn(strings);\r\n    if (shortest == 0) {\r\n        return 0;\r\n    }\r\n    char[] matches = new char[shortest];\r\n    String str;\r\n    for (int m = 0; m < matches.length; m++) {\r\n        matches[m] = strings[0].charAt(m);\r\n        if (!Character.isWhitespace(matches[m])) {\r\n            return m;\r\n        }\r\n        for (int i = 0; i < strings.length; i++) {\r\n            str = strings[i];\r\n            if (str.charAt(m) != matches[m]) {\r\n                return m;\r\n            }\r\n        }\r\n    }\r\n    return shortest;\r\n}"
}, {
	"Path": "org.powermock.core.DefaultFieldValueGenerator.substituteKnownProblemTypes",
	"Comment": "substitute class types that are known to cause problems when generatingthem.",
	"Method": "Class<?> substituteKnownProblemTypes(Class<?> fieldType){\r\n    if (fieldType == InetAddress.class) {\r\n        return Inet4Address.class;\r\n    }\r\n    return fieldType;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.symboltable.ScopeAndDeclarationFinder.createClassScope",
	"Comment": "creates a new class scope for an ast node. the scope on top of the stackis set as the parent of the new scope, which is then also stored on thescope stack.",
	"Method": "void createClassScope(JavaNode node){\r\n    Scope s = ((JavaNode) node.jjtGetParent()).getScope();\r\n    ClassNameDeclaration classNameDeclaration = new ClassNameDeclaration(node);\r\n    s.addDeclaration(classNameDeclaration);\r\n    if (node instanceof ASTClassOrInterfaceBody) {\r\n        addScope(new ClassScope(classNameDeclaration), node);\r\n    } else {\r\n        addScope(new ClassScope(node.getImage(), classNameDeclaration), node);\r\n    }\r\n}"
}, {
	"Path": "com.querydsl.core.group.GroupBy.map",
	"Comment": "create a new aggregating map expression using a backing linkedhashmap",
	"Method": "AbstractGroupExpression<Pair<K, V>, Map<K, V>> map(Expression<K> key,Expression<V> value,AbstractGroupExpression<Pair<K, V>, Map<T, V>> map,GroupExpression<K, T> key,Expression<V> value,AbstractGroupExpression<Pair<K, V>, Map<K, U>> map,Expression<K> key,GroupExpression<V, U> value,AbstractGroupExpression<Pair<K, V>, Map<T, U>> map,GroupExpression<K, T> key,GroupExpression<V, U> value){\r\n    return new GMap.Mixin<K, V, T, U, Map<T, U>>(key, value, GMap.createLinked(QPair.create(key, value)));\r\n}"
}, {
	"Path": "com.querydsl.core.types.dsl.PathBuilder.get",
	"Comment": "create a pathbuilder for the given property with the given type",
	"Method": "PathBuilder<Object> get(String property,PathBuilder<A> get,String property,Class<A> type,BooleanPath get,BooleanPath path,ComparablePath<A> get,ComparablePath<A> path,DatePath<A> get,DatePath<A> path,DateTimePath<A> get,DateTimePath<A> path,EnumPath<A> get,EnumPath<A> path,NumberPath<A> get,NumberPath<A> path,SimplePath<A> get,Path<A> path,StringPath get,StringPath path,TimePath<A> get,TimePath<A> path){\r\n    TimePath<A> newPath = getTime(toString(path), (Class<A>) path.getType());\r\n    return addMetadataOf(newPath, path);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.apex.rule.design.AbstractNcssCountRule.countNodeChildren",
	"Comment": "count the number of children of the given node. adds one to count thenode itself.",
	"Method": "Integer countNodeChildren(Node node,Object data){\r\n    Integer nodeCount;\r\n    int lineCount = 0;\r\n    for (int i = 0; i < node.jjtGetNumChildren(); i++) {\r\n        nodeCount = (Integer) ((AbstractApexNodeBase) node.jjtGetChild(i)).jjtAccept(this, data);\r\n        lineCount += nodeCount.intValue();\r\n    }\r\n    return ++lineCount;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.Report.addRuleViolation",
	"Comment": "adds a new rule violation to the report and notify the listeners.",
	"Method": "void addRuleViolation(RuleViolation violation){\r\n    int line = violation.getBeginLine();\r\n    if (linesToSuppress.containsKey(line)) {\r\n        suppressedRuleViolations.add(new SuppressedViolation(violation, true, linesToSuppress.get(line)));\r\n        return;\r\n    }\r\n    if (violation.isSuppressed()) {\r\n        suppressedRuleViolations.add(new SuppressedViolation(violation, false, null));\r\n        return;\r\n    }\r\n    int index = Collections.binarySearch(violations, violation, RuleViolationComparator.INSTANCE);\r\n    violations.add(index < 0 ? -index - 1 : index, violation);\r\n    violationTree.addRuleViolation(violation);\r\n    for (ThreadSafeReportListener listener : listeners) {\r\n        listener.ruleViolationAdded(violation);\r\n    }\r\n}"
}, {
	"Path": "com.querydsl.collections.AbstractCollQuery.innerJoin",
	"Comment": "define an inner join from the collection typed path to the alias",
	"Method": "Q innerJoin(Path<? extends Collection<P>> target,Path<P> alias,Q innerJoin,MapExpression<?, P> target,Path<P> alias){\r\n    getMetadata().addJoin(JoinType.INNERJOIN, createAlias(target, alias));\r\n    return queryMixin.getSelf();\r\n}"
}, {
	"Path": "com.querydsl.jpa.hibernate.AbstractHibernateQuery.createQuery",
	"Comment": "expose the original hibernate query for the given projection",
	"Method": "Query createQuery(Query createQuery,QueryModifiers modifiers,boolean forCount){\r\n    JPQLSerializer serializer = serialize(forCount);\r\n    String queryString = serializer.toString();\r\n    logQuery(queryString, serializer.getConstantToLabel());\r\n    Query query = session.createQuery(queryString);\r\n    HibernateUtil.setConstants(query, serializer.getConstantToLabel(), getMetadata().getParams());\r\n    if (fetchSize > 0) {\r\n        query.setFetchSize(fetchSize);\r\n    }\r\n    if (timeout > 0) {\r\n        query.setTimeout(timeout);\r\n    }\r\n    if (cacheable != null) {\r\n        query.setCacheable(cacheable);\r\n    }\r\n    if (cacheRegion != null) {\r\n        query.setCacheRegion(cacheRegion);\r\n    }\r\n    if (comment != null) {\r\n        query.setComment(comment);\r\n    }\r\n    if (readOnly != null) {\r\n        query.setReadOnly(readOnly);\r\n    }\r\n    for (Map.Entry<Path<?>, LockMode> entry : lockModes.entrySet()) {\r\n        query.setLockMode(entry.getKey().toString(), entry.getValue());\r\n    }\r\n    if (flushMode != null) {\r\n        query.setFlushMode(flushMode);\r\n    }\r\n    if (modifiers != null && modifiers.isRestricting()) {\r\n        Integer limit = modifiers.getLimitAsInteger();\r\n        Integer offset = modifiers.getOffsetAsInteger();\r\n        if (limit != null) {\r\n            query.setMaxResults(limit);\r\n        }\r\n        if (offset != null) {\r\n            query.setFirstResult(offset);\r\n        }\r\n    }\r\n    Expression<?> projection = getMetadata().getProjection();\r\n    if (!forCount && projection instanceof FactoryExpression) {\r\n        query.setResultTransformer(new FactoryExpressionTransformer((FactoryExpression<?>) projection));\r\n    }\r\n    return query;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.database.DBTypeTest.testAsProperties",
	"Comment": "test of getresourcebundleasproperties method, of class dbtype.",
	"Method": "void testAsProperties(){\r\n    System.out.println(\"asProperties\");\r\n    ResourceBundle bundle = ResourceBundle.getBundle(DBType.class.getPackage().getName() + \".test\");\r\n    Properties expResult = testProperties;\r\n    Properties result = DBType.getResourceBundleAsProperties(bundle);\r\n    Assert.assertEquals(expResult, result);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.metrics.impl.TccMetric.maxMethodPairs",
	"Comment": "calculates the number of possible method pairs of two methods.",
	"Method": "int maxMethodPairs(int methods){\r\n    return methods * (methods - 1) / 2;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.codestyle.FieldDeclarationsShouldBeAtStartOfClassRule.skipAnnotations",
	"Comment": "ignore all annotations, until anything, that is not an annotation andreturn this node",
	"Method": "Node skipAnnotations(Node child){\r\n    Node nextChild = child.jjtGetChild(0);\r\n    for (int j = 0; j < child.jjtGetNumChildren(); j++) {\r\n        if (!(child.jjtGetChild(j) instanceof ASTAnnotation)) {\r\n            nextChild = child.jjtGetChild(j);\r\n            break;\r\n        }\r\n    }\r\n    return nextChild;\r\n}"
}, {
	"Path": "com.querydsl.codegen.ClassPathUtils.safeClassForName",
	"Comment": "get the class for the given classname via the given classloader",
	"Method": "Class<?> safeClassForName(ClassLoader classLoader,String className){\r\n    try {\r\n        if (className.startsWith(\"com.sun.\") || className.startsWith(\"com.apple.\")) {\r\n            return null;\r\n        } else {\r\n            return Class.forName(className, true, classLoader);\r\n        }\r\n    } catch (ClassNotFoundException e) {\r\n        return null;\r\n    } catch (NoClassDefFoundError e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.CollectionUtil.toList",
	"Comment": "consumes all the elements of the iterator andreturns a list containing them. the iterator isthen unusable",
	"Method": "List<T> toList(Iterator<T> it){\r\n    List<T> list = new ArrayList();\r\n    while (it.hasNext()) {\r\n        list.add(it.next());\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.testframework.RuleTestRunner.hasUnitTests",
	"Comment": "checks whether this test class has additionally unit test methods.",
	"Method": "boolean hasUnitTests(){\r\n    return !getTestClass().getAnnotatedMethods(Test.class).isEmpty();\r\n}"
}, {
	"Path": "org.powermock.core.transformers.javassist.support.PowerMockExpressionEditor.addNewDeferConstructor",
	"Comment": "create a defer constructor in the class which will be called when theconstructor is suppressed.",
	"Method": "void addNewDeferConstructor(CtClass clazz){\r\n    final CtClass superClass;\r\n    try {\r\n        superClass = clazz.getSuperclass();\r\n    } catch (NotFoundException e1) {\r\n        throw new IllegalArgumentException(\"Internal error: Failed to get superclass for \" + clazz.getName() + \" when about to create a new default constructor.\");\r\n    }\r\n    ClassPool classPool = clazz.getClassPool();\r\n    final CtClass constructorType;\r\n    try {\r\n        constructorType = classPool.get(IndicateReloadClass.class.getName());\r\n    } catch (NotFoundException e) {\r\n        throw new IllegalArgumentException(\"Internal error: failed to get the \" + IndicateReloadClass.class.getName() + \" when added defer constructor.\");\r\n    }\r\n    clazz.defrost();\r\n    if (superClass.getName().equals(Object.class.getName())) {\r\n        try {\r\n            clazz.addConstructor(CtNewConstructor.make(new CtClass[] { constructorType }, new CtClass[0], \"{super();}\", clazz));\r\n        } catch (DuplicateMemberException e) {\r\n        }\r\n    } else {\r\n        addNewDeferConstructor(superClass);\r\n        try {\r\n            clazz.addConstructor(CtNewConstructor.make(new CtClass[] { constructorType }, new CtClass[0], \"{super($$);}\", clazz));\r\n        } catch (DuplicateMemberException e) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.codestyle.AbstractNamingConventionRule.defaultProp",
	"Comment": "the argument is interpreted as the display name, and is converted to camel case to get the property name.",
	"Method": "RegexPropertyBuilder defaultProp(String displayName,RegexPropertyBuilder defaultProp,String name,String displayName){\r\n    return PropertyFactory.regexProperty(name + \"Pattern\").desc(\"Regex which applies to \" + displayName.trim() + \" names\").defaultValue(defaultConvention());\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.plsql.PLSQLParser.createPLSQLParser",
	"Comment": "subclass should override this method to modify the plsqlparser as needed.",
	"Method": "net.sourceforge.pmd.lang.plsql.ast.PLSQLParser createPLSQLParser(Reader source){\r\n    Reader in = IOUtil.skipBOM(source);\r\n    return new net.sourceforge.pmd.lang.plsql.ast.PLSQLParser(in);\r\n}"
}, {
	"Path": "samples.powermockito.junit4.agent.SuppressConstructorDemoTest.testSuppressParentConstructor",
	"Comment": "this test makes sure that the real parent constructor has never beencalled.",
	"Method": "void testSuppressParentConstructor(){\r\n    suppress(constructor(SuppressConstructorSubclassDemo.class));\r\n    final SuppressConstructorDemo tested = new SuppressConstructorDemo(\"a message\");\r\n    assertNull(\"Message should have been null since we're skipping the execution of the constructor code.\", tested.getMessage());\r\n}"
}, {
	"Path": "net.sourceforge.pmd.PMDConfiguration.setDefaultLanguageVersions",
	"Comment": "set the given languageversions as the current default for theirlanguages.",
	"Method": "void setDefaultLanguageVersions(List<LanguageVersion> languageVersions){\r\n    for (LanguageVersion languageVersion : languageVersions) {\r\n        languageVersionDiscoverer.setDefaultLanguageVersion(languageVersion);\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.fxdesigner.util.controls.TreeViewWrapper.isIndexVisible",
	"Comment": "returns true if the item at the given indexis visible in the treeview.",
	"Method": "boolean isIndexVisible(int index){\r\n    if (virtualFlow == null && wrapped.getSkin() == null) {\r\n        return false;\r\n    } else if (virtualFlow == null && wrapped.getSkin() != null) {\r\n        virtualFlow = getVirtualFlow(wrapped.getSkin());\r\n    }\r\n    if (virtualFlow == null) {\r\n        return false;\r\n    }\r\n    Optional<TreeCell<T>> first = getFirstVisibleCell();\r\n    Optional<TreeCell<T>> last = getLastVisibleCell();\r\n    return first.isPresent() && last.isPresent() && first.get().getIndex() <= index && last.get().getIndex() >= index;\r\n}"
}, {
	"Path": "com.querydsl.jpa.JPAExpressions.selectOne",
	"Comment": "create a new detached jpqlquery instance with the projection one",
	"Method": "JPQLQuery<Integer> selectOne(){\r\n    return select(Expressions.ONE);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.errorprone.ConstructorCallsOverridableMethodRule.visitClassDec",
	"Comment": "this check must be evaluated independently for each class. inner classesget their own evalpackage in order to perform independent evaluation.",
	"Method": "Object visitClassDec(ASTClassOrInterfaceDeclaration node,Object data){\r\n    String className = node.getImage();\r\n    if (!node.isFinal()) {\r\n        putEvalPackage(new EvalPackage(className));\r\n    } else {\r\n        putEvalPackage(NULL_EVAL_PACKAGE);\r\n    }\r\n    super.visit(node, data);\r\n    if (!(getCurrentEvalPackage() instanceof NullEvalPackage)) {\r\n        while (evaluateDangerOfMethods(getCurrentEvalPackage().allMethodsOfClass)) {\r\n        }\r\n        evaluateDangerOfConstructors1(getCurrentEvalPackage().allPrivateConstructorsOfClass, getCurrentEvalPackage().allMethodsOfClass.keySet());\r\n        while (evaluateDangerOfConstructors2(getCurrentEvalPackage().allPrivateConstructorsOfClass)) {\r\n        }\r\n        for (MethodInvocation meth : getCurrentEvalPackage().calledMethods) {\r\n            for (MethodHolder h : getCurrentEvalPackage().allMethodsOfClass.keySet()) {\r\n                if (h.isDangerous()) {\r\n                    String methName = h.getASTMethodDeclarator().getImage();\r\n                    int count = h.getASTMethodDeclarator().getParameterCount();\r\n                    List<String> parameterTypes = getMethodDeclaratorParameterTypes(h.getASTMethodDeclarator());\r\n                    if (methName.equals(meth.getName()) && meth.getArgumentCount() == count && parameterTypes.equals(meth.getArgumentTypes())) {\r\n                        addViolation(data, meth.getASTPrimaryExpression(), \"method '\" + h.getCalled() + \"'\");\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        for (ConstructorHolder ch : getCurrentEvalPackage().allPrivateConstructorsOfClass.keySet()) {\r\n            if (ch.isDangerous()) {\r\n                int paramCount = ch.getASTConstructorDeclaration().getParameterCount();\r\n                for (ConstructorInvocation ci : getCurrentEvalPackage().calledConstructors) {\r\n                    if (ci.getArgumentCount() == paramCount) {\r\n                        addViolation(data, ci.getASTExplicitConstructorInvocation(), \"constructor\");\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    removeCurrentEvalPackage();\r\n    return data;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.ast.ASTAssignmentOperator.setCompound",
	"Comment": "todo this could be determined from the image of the operator, no need to set it in the parser...",
	"Method": "void setCompound(){\r\n    isCompound = true;\r\n}"
}, {
	"Path": "org.powermock.core.classloader.DeferSupportingClassLoader.findResource",
	"Comment": "finds the resource with the specified name on the search path.",
	"Method": "URL findResource(String name){\r\n    try {\r\n        return Whitebox.invokeMethod(deferTo, \"findResource\", name);\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "org.powermock.core.ClassReplicaCreator.getReplicaMethodDelegationCode",
	"Comment": "invokes a instance method of the original instance. this enables partialmocking of system classes.",
	"Method": "String getReplicaMethodDelegationCode(Class<?> clazz,CtMethod ctMethod,String classOrInstanceToDelegateTo){\r\n    StringBuilder builder = new StringBuilder();\r\n    builder.append(\"{java.lang.reflect.Method originalMethod = \");\r\n    builder.append(clazz.getName());\r\n    builder.append(\".class.getDeclaredMethod(\\\"\");\r\n    builder.append(ctMethod.getName());\r\n    builder.append(\"\\\", \");\r\n    final String parametersAsString = getParametersAsString(getParameterTypes(ctMethod));\r\n    if (\"\".equals(parametersAsString)) {\r\n        builder.append(\"null\");\r\n    } else {\r\n        builder.append(parametersAsString);\r\n    }\r\n    builder.append(\");\\n\");\r\n    builder.append(\"originalMethod.setAccessible(true);\\n\");\r\n    final CtClass returnType = ctMethod.getReturnType();\r\n    final boolean isVoid = returnType.equals(CtClass.voidType);\r\n    if (!isVoid) {\r\n        builder.append(\"return (\");\r\n        builder.append(returnType.getName());\r\n        builder.append(\") \");\r\n    }\r\n    builder.append(\"originalMethod.invoke(\");\r\n    if (Modifier.isStatic(ctMethod.getModifiers()) || classOrInstanceToDelegateTo == null) {\r\n        builder.append(clazz.getName());\r\n        builder.append(\".class\");\r\n    } else {\r\n        builder.append(classOrInstanceToDelegateTo);\r\n    }\r\n    builder.append(\", $args);}\");\r\n    return builder.toString();\r\n}"
}, {
	"Path": "com.querydsl.jpa.hibernate.AbstractHibernateQuery.scroll",
	"Comment": "return the query results as scrollableresults. thescrollability of the returned results depends upon jdbc driversupport for scrollable resultsets.",
	"Method": "ScrollableResults scroll(ScrollMode mode){\r\n    try {\r\n        return createQuery().scroll(mode);\r\n    } finally {\r\n        reset();\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.rule.AbstractRuleChainVisitor.initialize",
	"Comment": "initialize the rulechainvisitor to be ready to perform visitations. thismethod should not be called until it is known that all rulesparticipating in the rulechain are ready to be initialized themselves.some rules may require full initialization to determine if they willparticipate in the rulechain, so this has been delayed as long aspossible to ensure that manipulation of the rules is no longer occurring.",
	"Method": "void initialize(){\r\n    if (nodeNameToNodes != null) {\r\n        return;\r\n    }\r\n    Set<String> visitedNodes = new HashSet();\r\n    for (Iterator<Map.Entry<RuleSet, List<Rule>>> entryIterator = ruleSetRules.entrySet().iterator(); entryIterator.hasNext(); ) {\r\n        Map.Entry<RuleSet, List<Rule>> entry = entryIterator.next();\r\n        for (Iterator<Rule> ruleIterator = entry.getValue().iterator(); ruleIterator.hasNext(); ) {\r\n            Rule rule = ruleIterator.next();\r\n            if (rule.isRuleChain()) {\r\n                visitedNodes.addAll(rule.getRuleChainVisits());\r\n            } else {\r\n                ruleIterator.remove();\r\n            }\r\n        }\r\n        if (entry.getValue().isEmpty()) {\r\n            entryIterator.remove();\r\n        }\r\n    }\r\n    nodeNameToNodes = new HashMap();\r\n    for (String s : visitedNodes) {\r\n        List<Node> nodes = new ArrayList(100);\r\n        nodeNameToNodes.put(s, nodes);\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.vm.directive.Macro.isScopeProvided",
	"Comment": "since this class does no processing of content, there is never a need foran internal scope.",
	"Method": "boolean isScopeProvided(){\r\n    return false;\r\n}"
}, {
	"Path": "org.powermock.core.MockRepository.putMethodProxy",
	"Comment": "set a proxy for a method. whenever this method is called the invocation\thandler will be invoked instead.",
	"Method": "InvocationHandler putMethodProxy(Method method,InvocationHandler invocationHandler){\r\n    return methodProxies.put(method, invocationHandler);\r\n}"
}, {
	"Path": "org.powermock.reflect.Whitebox.getFieldsAnnotatedWith",
	"Comment": "get all fields annotated with a particular annotation. this method\ttraverses the class hierarchy when checking for the annotation.",
	"Method": "Set<Field> getFieldsAnnotatedWith(Object object,Class<? extends Annotation> annotation,Class<? extends Annotation> additionalAnnotations,Set<Field> getFieldsAnnotatedWith,Object object,Class<? extends Annotation>[] annotationTypes){\r\n    return WhiteboxImpl.getFieldsAnnotatedWith(object, annotationTypes);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.typeresolution.typeinference.TypeInferenceResolver.merge",
	"Comment": "merge two types of the same class to something both can be assigned to and is most specific.",
	"Method": "JavaTypeDefinition merge(JavaTypeDefinition first,JavaTypeDefinition second){\r\n    if (first.getType() != second.getType()) {\r\n        throw new IllegalStateException(\"Must be called with typedefinitions of the same class\");\r\n    }\r\n    if (!first.isGeneric()) {\r\n        return first;\r\n    }\r\n    JavaTypeDefinition[] mergedGeneric = new JavaTypeDefinition[first.getTypeParameterCount()];\r\n    for (int i = 0; i < first.getTypeParameterCount(); ++i) {\r\n        if (MethodTypeResolution.isSubtypeable(first.getGenericType(i), second.getGenericType(i))) {\r\n            mergedGeneric[i] = first.getGenericType(i);\r\n        } else if (MethodTypeResolution.isSubtypeable(second.getGenericType(i), first.getGenericType(i))) {\r\n            mergedGeneric[i] = second.getGenericType(i);\r\n        } else {\r\n            return JavaTypeDefinition.forClass(Object.class);\r\n        }\r\n    }\r\n    return JavaTypeDefinition.forClass(first.getType(), mergedGeneric);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.AbstractRuleSetFactoryTest.testXmlSchema",
	"Comment": "verifies that all rulesets are valid xml according to the xsd schema.",
	"Method": "void testXmlSchema(){\r\n    boolean allValid = true;\r\n    List<String> ruleSetFileNames = getRuleSetFileNames();\r\n    for (String fileName : ruleSetFileNames) {\r\n        boolean valid = validateAgainstSchema(fileName);\r\n        allValid = allValid && valid;\r\n    }\r\n    assertTrue(\"All XML must parse without producing validation messages.\", allValid);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId.getTypeNameNode",
	"Comment": "todo unreliable, not typesafe and not useful, should be deprecated",
	"Method": "Node getTypeNameNode(){\r\n    ASTType type = getTypeNode();\r\n    return type == null ? null : getTypeNode().jjtGetChild(0);\r\n}"
}, {
	"Path": "com.querydsl.core.alias.AliasFactory.createAliasForProperty",
	"Comment": "create an alias instance for the given class, parent and path",
	"Method": "A createAliasForProperty(Class<A> cl,Expression<?> path){\r\n    return createProxy(cl, path);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.qname.QualifiedNameResolver.getLongestPackagePrefix",
	"Comment": "returns the longest list of package names contained in the cachethat is a prefix of the given string. this method proceeds recursively,trimming one package name at each iteration and checking if the remainingprefix is already cached.",
	"Method": "ImmutableList<String> getLongestPackagePrefix(String acc,int i){\r\n    ImmutableList<String> prefix = FOUND_PACKAGES.get(acc);\r\n    if (prefix != null) {\r\n        return prefix;\r\n    }\r\n    if (i == 1) {\r\n        return ListFactory.emptyList();\r\n    }\r\n    return getLongestPackagePrefix(acc.substring(0, acc.lastIndexOf('.')), i - 1);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.RuleSetFactoryCompatibility.filterRuleSetFile",
	"Comment": "applies all configured filters against the given input stream. theresulting reader will contain the original ruleset modified by thefilters.",
	"Method": "Reader filterRuleSetFile(InputStream stream){\r\n    byte[] bytes = IOUtils.toByteArray(stream);\r\n    String encoding = determineEncoding(bytes);\r\n    String ruleset = new String(bytes, encoding);\r\n    ruleset = applyAllFilters(ruleset);\r\n    return new StringReader(ruleset);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.bestpractices.JUnitTestsShouldIncludeAssertRule.isExpectAnnotated",
	"Comment": "tells if the node contains a test annotation with an expected exception.",
	"Method": "boolean isExpectAnnotated(Node methodParent){\r\n    List<ASTNormalAnnotation> annotations = methodParent.findDescendantsOfType(ASTNormalAnnotation.class);\r\n    for (ASTNormalAnnotation annotation : annotations) {\r\n        ASTName name = annotation.getFirstChildOfType(ASTName.class);\r\n        if (name != null && TypeHelper.isA(name, JUNIT4_CLASS_NAME)) {\r\n            List<ASTMemberValuePair> memberValues = annotation.findDescendantsOfType(ASTMemberValuePair.class);\r\n            for (ASTMemberValuePair pair : memberValues) {\r\n                if (\"expected\".equals(pair.getImage())) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.querydsl.core.util.BeanMap.setBean",
	"Comment": "sets the bean to be operated on by this map.the given value maybe null, in which case this map will be empty.",
	"Method": "void setBean(Object newBean){\r\n    bean = newBean;\r\n    reinitialise();\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.dfa.pathfinder.DAAPathFinder.phase3",
	"Comment": "decompose the path until it finds a node which branches are not alltraversed.",
	"Method": "boolean phase3(){\r\n    while (!currentPath.isEmpty()) {\r\n        if (currentPath.isBranch()) {\r\n            if (this.countLoops() == 1) {\r\n                if (this.hasMoreChildren()) {\r\n                    this.incChild();\r\n                    return true;\r\n                } else {\r\n                    this.removeFromTree();\r\n                    currentPath.removeLast();\r\n                }\r\n            } else {\r\n                this.removeFromTree();\r\n                currentPath.removeLast();\r\n            }\r\n        } else {\r\n            currentPath.removeLast();\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.renderers.CodeClimateRenderer.asIssue",
	"Comment": "generate a codeclimateissue suitable for processing into json from thegiven ruleviolation.",
	"Method": "CodeClimateIssue asIssue(RuleViolation rv){\r\n    CodeClimateIssue issue = new CodeClimateIssue();\r\n    issue.check_name = rule.getName();\r\n    issue.description = cleaned(rv.getDescription());\r\n    issue.content = new CodeClimateIssue.Content(BODY_PLACEHOLDER);\r\n    issue.location = getLocation(rv);\r\n    issue.remediation_points = getRemediationPoints();\r\n    issue.categories = getCategories();\r\n    switch(rule.getPriority()) {\r\n        case HIGH:\r\n            issue.severity = \"critical\";\r\n            break;\r\n        case MEDIUM_HIGH:\r\n        case MEDIUM:\r\n        case MEDIUM_LOW:\r\n            issue.severity = \"normal\";\r\n            break;\r\n        case LOW:\r\n        default:\r\n            issue.severity = \"info\";\r\n            break;\r\n    }\r\n    return issue;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.RuleSetFactory.createRuleSet",
	"Comment": "create a ruleset from a rulesetreferenceid. priority filtering is ignoredwhen loading a single rule. the currently configured resourceloader is used.",
	"Method": "RuleSet createRuleSet(String referenceString,RuleSet createRuleSet,RuleSetReferenceId ruleSetReferenceId,RuleSet createRuleSet,RuleSetReferenceId ruleSetReferenceId,boolean withDeprecatedRuleReferences){\r\n    return parseRuleSetNode(ruleSetReferenceId, withDeprecatedRuleReferences);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.fxdesigner.util.PropertyDescriptorSpec.build",
	"Comment": "builds the descriptor. may throw illegalargumentexception.",
	"Method": "PropertyDescriptor<?> build(){\r\n    PropertyDescriptorExternalBuilder<?> externalBuilder = getTypeId().getFactory();\r\n    Map<PropertyDescriptorField, String> values = new HashMap();\r\n    values.put(PropertyDescriptorField.NAME, getName());\r\n    values.put(PropertyDescriptorField.DEFAULT_VALUE, getValue());\r\n    values.put(PropertyDescriptorField.DESCRIPTION, getDescription());\r\n    values.put(PropertyDescriptorField.MIN, \"-2000000\");\r\n    values.put(PropertyDescriptorField.MAX, \"+2000000\");\r\n    return externalBuilder.build(values);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.LanguageVersionDiscoverer.getDefaultLanguageVersionForFile",
	"Comment": "get the languageversion for the first language of a source file with thegiven name.",
	"Method": "LanguageVersion getDefaultLanguageVersionForFile(File sourceFile,LanguageVersion getDefaultLanguageVersionForFile,String fileName){\r\n    List<Language> languages = getLanguagesForFile(fileName);\r\n    LanguageVersion languageVersion = null;\r\n    if (!languages.isEmpty()) {\r\n        languageVersion = getDefaultLanguageVersion(languages.get(0));\r\n    }\r\n    return languageVersion;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.codestyle.PrematureDeclarationRule.statementsAfter",
	"Comment": "returns all the block statements following the given local var declaration.",
	"Method": "List<ASTBlockStatement> statementsAfter(ASTLocalVariableDeclaration node){\r\n    Node blockOrSwitch = node.jjtGetParent().jjtGetParent();\r\n    int count = blockOrSwitch.jjtGetNumChildren();\r\n    int start = node.jjtGetParent().jjtGetChildIndex() + 1;\r\n    List<ASTBlockStatement> nextBlocks = new ArrayList(count - start);\r\n    for (int i = start; i < count; i++) {\r\n        Node maybeBlock = blockOrSwitch.jjtGetChild(i);\r\n        if (maybeBlock instanceof ASTBlockStatement) {\r\n            nextBlocks.add((ASTBlockStatement) maybeBlock);\r\n        }\r\n    }\r\n    return nextBlocks;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.ast.ASTDoStatement.getBody",
	"Comment": "returns the statement that will be run while the guardevaluates to true.",
	"Method": "ASTStatement getBody(){\r\n    return (ASTStatement) jjtGetChild(0);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.LanguageRegistry.findWithRuleSupport",
	"Comment": "a utility method to find the languages which have rule support.",
	"Method": "List<Language> findWithRuleSupport(){\r\n    return new ArrayList(getLanguages());\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.AbstractInefficientZeroCheck.isCompare",
	"Comment": "we only need to report if this is comparing against one of the comparisontargets",
	"Method": "boolean isCompare(Node equality){\r\n    if (isLiteralLeftHand(equality)) {\r\n        return checkComparison(inverse.get(equality.getImage()), equality, 0);\r\n    } else if (isLiteralRightHand(equality)) {\r\n        return checkComparison(equality.getImage(), equality, 1);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.bestpractices.MissingOverrideRule.overriddenMethods",
	"Comment": "returns the set of methods declared in this type that are overridden.",
	"Method": "Set<Method> overriddenMethods(Class<?> exploredType){\r\n    return overriddenMethodsRec(exploredType, true, new HashSet(Arrays.asList(exploredType.getDeclaredMethods())), new HashSet<Method>(), new HashSet<Class<?>>(), false);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.xml.XmlParserTest.testDefaultParsingNamespaces",
	"Comment": "verifies the default parsing behavior of the xml parser with namespaces.",
	"Method": "void testDefaultParsingNamespaces(){\r\n    LanguageVersionHandler xmlVersionHandler = LanguageRegistry.getLanguage(XmlLanguageModule.NAME).getDefaultVersion().getLanguageVersionHandler();\r\n    Parser parser = xmlVersionHandler.getParser(xmlVersionHandler.getDefaultParserOptions());\r\n    Node document = parser.parse(null, new StringReader(XML_NAMESPACE_TEST));\r\n    assertNode(document, \"document\", 1);\r\n    Node rootElement = document.jjtGetChild(0);\r\n    assertNode(rootElement, \"pmd:rootElement\", 7, \"xmlns:pmd\", \"http://pmd.sf.net\");\r\n    Assert.assertEquals(\"http://pmd.sf.net\", ((XmlNode) rootElement).getNode().getNamespaceURI());\r\n    Assert.assertEquals(\"pmd\", ((XmlNode) rootElement).getNode().getPrefix());\r\n    Assert.assertEquals(\"rootElement\", ((XmlNode) rootElement).getNode().getLocalName());\r\n    Assert.assertEquals(\"pmd:rootElement\", ((XmlNode) rootElement).getNode().getNodeName());\r\n    assertTextNode(rootElement.jjtGetChild(0), \"\\\\n    \");\r\n    assertNode(rootElement.jjtGetChild(1), \"comment\", 0);\r\n    assertTextNode(rootElement.jjtGetChild(2), \"\\\\n    \");\r\n    Node child1 = rootElement.jjtGetChild(3);\r\n    assertNode(child1, \"pmd:child1\", 1, \"test\", \"1\");\r\n    assertTextNode(child1.jjtGetChild(0), \"entity: &\\\\n    \");\r\n    assertTextNode(rootElement.jjtGetChild(4), \"\\\\n    \");\r\n    Node child2 = rootElement.jjtGetChild(5);\r\n    assertNode(child2, \"pmd:child2\", 3);\r\n    assertTextNode(child2.jjtGetChild(0), \"\\\\n      \");\r\n    assertTextNode(child2.jjtGetChild(1), \" cdata section \", \"cdata-section\");\r\n    assertTextNode(child2.jjtGetChild(2), \"\\\\n    \");\r\n    assertTextNode(rootElement.jjtGetChild(6), \"\\\\n\");\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.fxdesigner.model.EventLogger.getLog",
	"Comment": "returns a stream that emits an event each time an exception is logged by somepart of the application.",
	"Method": "EventStream<LogEntry> getLog(){\r\n    return latestEvent.filter(Objects::nonNull);\r\n}"
}, {
	"Path": "com.ramotion.paperonboarding.PaperOnboardingEngine.toggleToPreviousElement",
	"Comment": "changes active element to the previous one and returns a new content",
	"Method": "PaperOnboardingPage toggleToPreviousElement(){\r\n    if (mActiveElementIndex - 1 >= 0) {\r\n        mActiveElementIndex--;\r\n        return mElements.size() > mActiveElementIndex ? mElements.get(mActiveElementIndex) : null;\r\n    } else\r\n        return null;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.filter.AbstractDelegateFilter.toString",
	"Comment": "subclass should override to do something other the simply delegate.",
	"Method": "String toString(){\r\n    return filter.toString();\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.errorprone.CloseResourceRule.nullCheckIfCondition",
	"Comment": "checks, whether the given node is inside a if condition, and if so,whether this is a null check for the given varname.",
	"Method": "boolean nullCheckIfCondition(ASTBlock enclosingBlock,Node node,String varName){\r\n    ASTIfStatement ifStatement = findIfStatement(enclosingBlock, node);\r\n    if (ifStatement != null) {\r\n        try {\r\n            List<?> nodes = ifStatement.findChildNodesWithXPath(\"Expression/EqualityExpression[@Image='!=']\" + \"  [PrimaryExpression/PrimaryPrefix/Name[@Image='\" + varName + \"']]\" + \"  [PrimaryExpression/PrimaryPrefix/Literal/NullLiteral]\");\r\n            return !nodes.isEmpty();\r\n        } catch (JaxenException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.powermock.api.easymock.PowerMock.createNiceMock",
	"Comment": "creates a nice mock object that supports mocking of final and nativemethods and invokes a specific constructor based on the supplied argumentvalues.",
	"Method": "T createNiceMock(Class<T> type,Method methods,T createNiceMock,Class<T> type,T createNiceMock,Class<T> type,ConstructorArgs constructorArgs,Method methods,T createNiceMock,Class<T> type,Object constructorArguments){\r\n    Constructor<?> constructor = WhiteboxImpl.findUniqueConstructorOrThrowException(type, constructorArguments);\r\n    ConstructorArgs constructorArgs = new ConstructorArgs(constructor, constructorArguments);\r\n    return doMock(type, false, new NiceMockStrategy(), constructorArgs, (Method[]) null);\r\n}"
}, {
	"Path": "org.powermock.api.easymock.PowerMock.createPartialMockForAllMethodsExcept",
	"Comment": "mock all methods of a class except for a specific one. use this methodonly if you have several overloaded methods.",
	"Method": "T createPartialMockForAllMethodsExcept(Class<T> type,String methodNames,T createPartialMockForAllMethodsExcept,Class<T> type,String methodNameToExclude,Class<?> firstArgumentType,Class<?> moreTypes){\r\n    final Class<?>[] argumentTypes = mergeArgumentTypes(firstArgumentType, moreTypes);\r\n    return createMock(type, WhiteboxImpl.getAllMethodsExcept(type, methodNameToExclude, argumentTypes));\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.fxdesigner.NodeInfoPanelController.getAttributes",
	"Comment": "gets the xpath attributes of the node for display within a listview.",
	"Method": "ObservableList<String> getAttributes(Node node){\r\n    ObservableList<String> result = FXCollections.observableArrayList();\r\n    Iterator<Attribute> attributeAxisIterator = node.getXPathAttributesIterator();\r\n    while (attributeAxisIterator.hasNext()) {\r\n        Attribute attribute = attributeAxisIterator.next();\r\n        result.add(attribute.getName() + \" = \" + ((attribute.getValue() != null) ? attribute.getStringValue() : \"null\"));\r\n    }\r\n    if (node instanceof TypeNode) {\r\n        result.add(\"typeIs() = \" + ((TypeNode) node).getType());\r\n    }\r\n    Collections.sort(result);\r\n    return result;\r\n}"
}, {
	"Path": "org.powermock.reflect.WhiteBoxTest.testInvokeConstructorWithBothNormalAndVarArgsParameter",
	"Comment": "asserts that issue118 is fixed. thanks to cemcatik for finding this.",
	"Method": "void testInvokeConstructorWithBothNormalAndVarArgsParameter(){\r\n    ClassWithVarArgsConstructor2 instance = Whitebox.invokeConstructor(ClassWithVarArgsConstructor2.class, \"first\", \"second\", \"third\");\r\n    assertArrayEquals(new String[] { \"first\", \"second\", \"third\" }, instance.getStrings());\r\n}"
}, {
	"Path": "com.querydsl.core.types.dsl.TimeExpression.currentTime",
	"Comment": "create an expression representing the current time as a timeexpression instance",
	"Method": "TimeExpression<Time> currentTime(TimeExpression<T> currentTime,Class<T> cl){\r\n    return Expressions.timeOperation(cl, Ops.DateTimeOps.CURRENT_TIME);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.metrics.impl.AbstractMetricTestRule.optionMappings",
	"Comment": "mappings of labels to versions for use in the options property.",
	"Method": "Map<String, MetricOption> optionMappings(){\r\n    return new HashMap();\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.FileUtil.normalizeFilename",
	"Comment": "normalizes the filename by taking the casing into account, e.g. onwindows, the filename is changed to lowercase only.",
	"Method": "String normalizeFilename(String fileName){\r\n    if (fileName != null && File.separatorChar == '\\\\') {\r\n        return fileName.toLowerCase(Locale.ROOT);\r\n    }\r\n    return fileName;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.fxdesigner.util.codearea.HighlightLayerCodeArea.clearStyleLayers",
	"Comment": "clears all style layers from their contents, including syntax highlighting.",
	"Method": "void clearStyleLayers(){\r\n    updateStyling(() -> {\r\n        layersById.values().forEach(StyleLayer::clearStyles);\r\n        clearSyntaxHighlighting();\r\n    });\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.rule.xpath.SaxonXPathRuleQuery.getAtomicRepresentation",
	"Comment": "gets the saxon representation of the parameter, if its type corresponds to an xpath 2.0 atomic datatype.",
	"Method": "AtomicValue getAtomicRepresentation(Object value){\r\n    if (value == null) {\r\n        return UntypedAtomicValue.ZERO_LENGTH_UNTYPED;\r\n    } else if (value instanceof String) {\r\n        return new StringValue((String) value);\r\n    } else if (value instanceof Boolean) {\r\n        return BooleanValue.get((Boolean) value);\r\n    } else if (value instanceof Integer) {\r\n        return Int64Value.makeIntegerValue((Integer) value);\r\n    } else if (value instanceof Long) {\r\n        return new BigIntegerValue((Long) value);\r\n    } else if (value instanceof Double) {\r\n        return new DoubleValue((Double) value);\r\n    } else if (value instanceof Character) {\r\n        return new StringValue(value.toString());\r\n    } else if (value instanceof Float) {\r\n        return new FloatValue((Float) value);\r\n    } else if (value instanceof Pattern) {\r\n        return new StringValue(String.valueOf(value));\r\n    } else {\r\n        throw new RuntimeException(\"Unable to create ValueRepresentation for value of type: \" + value.getClass());\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.ecmascript.ast.ASTName.isVariableDeclaration",
	"Comment": "returns whether this name node is the name of a variable declaration.",
	"Method": "boolean isVariableDeclaration(){\r\n    return jjtGetParent() instanceof ASTVariableInitializer && ((ASTVariableInitializer) jjtGetParent()).getTarget() == this;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.LanguageVersion.getTerseName",
	"Comment": "get the terse name of this languageversion. this is language terse nameappended with the languageversion version if not an empty string.",
	"Method": "String getTerseName(){\r\n    return version.length() > 0 ? language.getTerseName() + ' ' + version : language.getTerseName();\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.ast.ASTWhileStatement.getGuardExpressionNode",
	"Comment": "returns the node that represents the guard of this loop.this may be any expression of type boolean.",
	"Method": "ASTExpression getGuardExpressionNode(){\r\n    return (ASTExpression) jjtGetChild(0);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.xml.XmlParserTest.testParsingNotNamespaceAware",
	"Comment": "verifies the default parsing behavior of the xml parser with namespacesbut not namespace aware.",
	"Method": "void testParsingNotNamespaceAware(){\r\n    LanguageVersionHandler xmlVersionHandler = LanguageRegistry.getLanguage(XmlLanguageModule.NAME).getDefaultVersion().getLanguageVersionHandler();\r\n    XmlParserOptions parserOptions = new XmlParserOptions();\r\n    parserOptions.setNamespaceAware(false);\r\n    Parser parser = xmlVersionHandler.getParser(parserOptions);\r\n    Node document = parser.parse(null, new StringReader(XML_NAMESPACE_TEST));\r\n    assertNode(document, \"document\", 1);\r\n    Node rootElement = document.jjtGetChild(0);\r\n    assertNode(rootElement, \"pmd:rootElement\", 7, \"xmlns:pmd\", \"http://pmd.sf.net\");\r\n    Assert.assertNull(((XmlNode) rootElement).getNode().getNamespaceURI());\r\n    Assert.assertNull(((XmlNode) rootElement).getNode().getPrefix());\r\n    Assert.assertNull(((XmlNode) rootElement).getNode().getLocalName());\r\n    Assert.assertEquals(\"pmd:rootElement\", ((XmlNode) rootElement).getNode().getNodeName());\r\n    assertTextNode(rootElement.jjtGetChild(0), \"\\\\n    \");\r\n    assertNode(rootElement.jjtGetChild(1), \"comment\", 0);\r\n    assertTextNode(rootElement.jjtGetChild(2), \"\\\\n    \");\r\n    Node child1 = rootElement.jjtGetChild(3);\r\n    assertNode(child1, \"pmd:child1\", 1, \"test\", \"1\");\r\n    assertTextNode(child1.jjtGetChild(0), \"entity: &\\\\n    \");\r\n    assertTextNode(rootElement.jjtGetChild(4), \"\\\\n    \");\r\n    Node child2 = rootElement.jjtGetChild(5);\r\n    assertNode(child2, \"pmd:child2\", 3);\r\n    assertTextNode(child2.jjtGetChild(0), \"\\\\n      \");\r\n    assertTextNode(child2.jjtGetChild(1), \" cdata section \", \"cdata-section\");\r\n    assertTextNode(child2.jjtGetChild(2), \"\\\\n    \");\r\n    assertTextNode(rootElement.jjtGetChild(6), \"\\\\n\");\r\n}"
}, {
	"Path": "powermock.modules.test.mockito.junit4.delegate.parameterized.SuppressConstructorDemoTest.testSuppressConstructor",
	"Comment": "this test makes sure that the real constructor has never been called.",
	"Method": "void testSuppressConstructor(){\r\n    suppress(constructor(constructor2suppress));\r\n    final SuppressConstructorDemo tested = new SuppressConstructorDemo(\"a message\");\r\n    assertNull(\"Message should have been null since we're skipping the execution of the constructor code.\", tested.getMessage());\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.ast.ASTIfStatement.getThenBranch",
	"Comment": "returns the statement that will be run if the guard evaluatesto true.",
	"Method": "ASTStatement getThenBranch(){\r\n    return (ASTStatement) jjtGetChild(1);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.plsql.symboltable.ScopeAndDeclarationFinder.createSourceFileScope",
	"Comment": "creates a new global scope for an ast node. the new scope is stored onthe scope stack.",
	"Method": "void createSourceFileScope(ASTInput node){\r\n    Scope scope;\r\n    ASTObjectDeclaration n = null;\r\n    if (n != null) {\r\n        scope = new SourceFileScope(n.jjtGetChild(0).getImage());\r\n    } else {\r\n        scope = new SourceFileScope();\r\n    }\r\n    scopes.push(scope);\r\n    node.setScope(scope);\r\n}"
}, {
	"Path": "com.querydsl.core.types.Projections.bean",
	"Comment": "create a bean populating projection for the given type and bindings",
	"Method": "QBean<T> bean(Class<? extends T> type,Expression<?> exprs,QBean<T> bean,Path<? extends T> type,Expression<?> exprs,QBean<T> bean,Path<? extends T> type,Map<String, ? extends Expression<?>> bindings,QBean<T> bean,Class<? extends T> type,Map<String, ? extends Expression<?>> bindings){\r\n    return new QBean<T>(type, bindings);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.PMDConfiguration.getMinimumPriority",
	"Comment": "get the minimum priority threshold when loading rules from rulesets.",
	"Method": "RulePriority getMinimumPriority(){\r\n    return minimumPriority;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.LanguageVersion.getName",
	"Comment": "get the name of this languageversion. this is language name appended withthe languageversion version if not an empty string.",
	"Method": "String getName(){\r\n    return version.length() > 0 ? language.getName() + ' ' + version : language.getName();\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.ast.SourceCodePositionerTest.testLineNumberFromOffset",
	"Comment": "tests whether the lines and columns are calculated correctly.",
	"Method": "void testLineNumberFromOffset(){\r\n    SourceCodePositioner positioner = new SourceCodePositioner(SOURCE_CODE);\r\n    int offset;\r\n    offset = SOURCE_CODE.indexOf('a');\r\n    assertEquals(1, positioner.lineNumberFromOffset(offset));\r\n    assertEquals(1, positioner.columnFromOffset(1, offset));\r\n    offset = SOURCE_CODE.indexOf('b');\r\n    assertEquals(1, positioner.lineNumberFromOffset(offset));\r\n    assertEquals(2, positioner.columnFromOffset(1, offset));\r\n    offset = SOURCE_CODE.indexOf('e');\r\n    assertEquals(2, positioner.lineNumberFromOffset(offset));\r\n    assertEquals(2, positioner.columnFromOffset(2, offset));\r\n    offset = SOURCE_CODE.indexOf('q');\r\n    assertEquals(5, positioner.lineNumberFromOffset(offset));\r\n    assertEquals(3, positioner.columnFromOffset(5, offset));\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.database.DBURITest.testDefaultSourceCodeTypesList",
	"Comment": "verify that default source code types are returned if non are provided inthe dburi.",
	"Method": "void testDefaultSourceCodeTypesList(){\r\n    System.out.println(\"testDefaultSourceCodeTypesList\");\r\n    List<String> defaultSourceCodeTypesList = Arrays.asList(C_DEFAULT_SOURCE_CODE_TYPES.split(\",\"));\r\n    DBURI instance = new DBURI(C_TEST_DEFAULTS);\r\n    List<String> result = instance.getSourceCodeTypesList();\r\n    assertEquals(defaultSourceCodeTypesList, result);\r\n}"
}, {
	"Path": "com.querydsl.core.QueryResults.isEmpty",
	"Comment": "return whether there are results in the current query window",
	"Method": "boolean isEmpty(){\r\n    return results.isEmpty();\r\n}"
}, {
	"Path": "com.ramotion.paperonboarding.PaperOnboardingEngine.toggleToNextElement",
	"Comment": "changes active element to the next one and returns a new content",
	"Method": "PaperOnboardingPage toggleToNextElement(){\r\n    if (mActiveElementIndex + 1 < mElements.size()) {\r\n        mActiveElementIndex++;\r\n        return mElements.size() > mActiveElementIndex ? mElements.get(mActiveElementIndex) : null;\r\n    } else\r\n        return null;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.design.SignatureDeclareThrowsExceptionRule.hasDeclaredExceptionInSignature",
	"Comment": "checks if the given value is defined as exception and theparent is either a method or constructor declaration.",
	"Method": "boolean hasDeclaredExceptionInSignature(ASTName exception){\r\n    return exception.hasImageEqualTo(\"Exception\") && isParentSignatureDeclaration(exception);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.design.SignatureDeclareThrowsExceptionRule.isParentSignatureDeclaration",
	"Comment": "checks if the given exception is declared in the method or constructorsignature.",
	"Method": "boolean isParentSignatureDeclaration(ASTName exception){\r\n    Node parent = exception.jjtGetParent().jjtGetParent();\r\n    return parent instanceof ASTMethodDeclaration || parent instanceof ASTConstructorDeclaration;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.fxdesigner.util.DesignerUtil.stackTraceToXPath",
	"Comment": "works out an xpath query that matches the nodewhich was being visited during the failure.",
	"Method": "Optional<String> stackTraceToXPath(String stackTrace,Optional<String> stackTraceToXPath,Throwable e){\r\n    return stackTraceToXPath(ExceptionUtils.getStackTrace(e));\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.database.DBURITest.testExplicitSchemasList",
	"Comment": "verify that languages are returned if provided in the dburi.",
	"Method": "void testExplicitSchemasList(){\r\n    System.out.println(\"testExplicitSchemasList\");\r\n    List<String> defaultSchemasList = Arrays.asList(C_EXPLICIT_SCHEMAS.split(\",\"));\r\n    DBURI instance = new DBURI(C_TEST_EXPLICIT);\r\n    List<String> result = instance.getSchemasList();\r\n    assertEquals(defaultSchemasList, result);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.it.PMDExecutor.runPMDRules",
	"Comment": "executes the pmd found in tempdir against the given sourcedirectory path with the given ruleset.",
	"Method": "ExecutionResult runPMDRules(Path tempDir,String sourceDirectory,String ruleset){\r\n    if (SystemUtils.IS_OS_WINDOWS) {\r\n        return runPMDWindows(tempDir, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset, FORMAT_FLAG, FORMATTER);\r\n    } else {\r\n        return runPMDUnix(tempDir, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset, FORMAT_FLAG, FORMATTER);\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration.iterator",
	"Comment": "returns an iterator over the ids of the fieldsdeclared in this statement.",
	"Method": "Iterator<ASTVariableDeclaratorId> iterator(){\r\n    return ASTVariableDeclarator.iterateIds(this);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.benchmark.TimeTracker.stopGlobalTracking",
	"Comment": "stops global tracking. stops the wall clock. all further operations will be treated as noop.",
	"Method": "TimingReport stopGlobalTracking(){\r\n    if (!trackTime) {\r\n        return null;\r\n    }\r\n    finishThread();\r\n    trackTime = false;\r\n    final TimedResult unaccountedResult = ACCUMULATED_RESULTS.get(new TimedOperationKey(TimedOperationCategory.UNACCOUNTED, null));\r\n    unaccountedResult.totalTimeNanos.set(unaccountedResult.selfTimeNanos.get());\r\n    unaccountedResult.callCount.set(0);\r\n    return new TimingReport(System.currentTimeMillis() - wallClockStartMillis, ACCUMULATED_RESULTS);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.fxdesigner.XPathPanelController.bindToParent",
	"Comment": "binds the underlying rule parameters to the parent ui, disconnecting it from the wizard if need be",
	"Method": "void bindToParent(){\r\n    DesignerUtil.rewire(getRuleBuilder().languageProperty(), Val.map(parent.languageVersionProperty(), LanguageVersion::getLanguage));\r\n    DesignerUtil.rewire(getRuleBuilder().xpathVersionProperty(), parent.xpathVersionProperty());\r\n    DesignerUtil.rewire(getRuleBuilder().xpathExpressionProperty(), xpathExpressionProperty());\r\n    DesignerUtil.rewire(getRuleBuilder().rulePropertiesProperty(), propertyTableView.rulePropertiesProperty(), propertyTableView::setRuleProperties);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.fxdesigner.util.codearea.NodeStyleSpan.indentationOffset",
	"Comment": "pmd counts it correctly as 8 columns, so we must offset the position",
	"Method": "int indentationOffset(int paragraph){\r\n    Paragraph<Collection<String>, String, Collection<String>> p = codeArea.getParagraph(paragraph);\r\n    Matcher m = TAB_INDENT.matcher(p.getText());\r\n    if (m.matches()) {\r\n        return m.group(1).length() * 7;\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.document.DocumentFile.writeUntilOffsetReached",
	"Comment": "write characters between the current offset until the next offset to be read",
	"Method": "void writeUntilOffsetReached(int nextOffsetToRead){\r\n    if (nextOffsetToRead < currentPosition) {\r\n        throw new IllegalStateException();\r\n    }\r\n    final char[] bufferToCopy = new char[nextOffsetToRead - currentPosition];\r\n    reader.read(bufferToCopy);\r\n    writer.write(bufferToCopy);\r\n    currentPosition = nextOffsetToRead;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.vf.ast.AbstractVfNodesTest.addNodeAndSubnodes",
	"Comment": "add the given node and its subnodes to the set of nodes. if clazz is notnull, only nodes of the given class are put in the set of nodes.",
	"Method": "void addNodeAndSubnodes(Node node,Set<T> nodes,Class<T> clazz){\r\n    if (null != node) {\r\n        if ((null == clazz) || (clazz.equals(node.getClass()))) {\r\n            nodes.add((T) node);\r\n        }\r\n        for (int i = 0; i < node.jjtGetNumChildren(); i++) {\r\n            addNodeAndSubnodes(node.jjtGetChild(i), nodes, clazz);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "samples.junit4.suppressconstructor.SuppressConstructorDemoTest.testSuppressConstructor",
	"Comment": "this test makes sure that the real constructor has never been called.",
	"Method": "void testSuppressConstructor(){\r\n    suppress(constructor(SuppressConstructorDemo.class));\r\n    final SuppressConstructorDemo tested = new SuppressConstructorDemo(\"a message\");\r\n    assertNull(\"Message should have been null since we're skipping the execution of the constructor code.\", tested.getMessage());\r\n}"
}, {
	"Path": "com.kabouzeid.gramophone.adapter.MusicLibraryPagerAdapter.alignCache",
	"Comment": "aligns the fragment cache with the current category layout.",
	"Method": "void alignCache(){\r\n    if (mFragmentArray.size() == 0)\r\n        return;\r\n    HashMap<String, WeakReference<Fragment>> mappings = new HashMap(mFragmentArray.size());\r\n    for (int i = 0, size = mFragmentArray.size(); i < size; i++) {\r\n        WeakReference<Fragment> ref = mFragmentArray.valueAt(i);\r\n        Fragment fragment = ref.get();\r\n        if (fragment != null) {\r\n            mappings.put(fragment.getClass().getName(), ref);\r\n        }\r\n    }\r\n    for (int i = 0, size = mHolderList.size(); i < size; i++) {\r\n        WeakReference<Fragment> ref = mappings.get(mHolderList.get(i).mClassName);\r\n        if (ref != null) {\r\n            mFragmentArray.put(i, ref);\r\n        } else {\r\n            mFragmentArray.remove(i);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.stat.StatisticalRuleTest.randomMinimum",
	"Comment": "this generates a random minimum value for which fewer results would bereturned.",
	"Method": "double randomMinimum(double randomMinimum,int minimum){\r\n    double diffTarget = 1.0 * (POINTS - 1 - minimum);\r\n    return (random.nextDouble() * minimum) + diffTarget;\r\n}"
}, {
	"Path": "org.powermock.api.support.SuppressCode.suppressSpecificConstructor",
	"Comment": "this method can be used to suppress the code in a specific constructor.",
	"Method": "void suppressSpecificConstructor(Class<?> clazz,Class<?> parameterTypes){\r\n    MockRepository.addConstructorToSuppress(Whitebox.getConstructor(clazz, parameterTypes));\r\n}"
}, {
	"Path": "net.sourceforge.pmd.PMDConfiguration.setClassLoader",
	"Comment": "set the classloader being used by pmd when processing rules. setting avalue of null will cause the default classloader to be used.",
	"Method": "void setClassLoader(ClassLoader classLoader){\r\n    if (classLoader == null) {\r\n        this.classLoader = getClass().getClassLoader();\r\n    } else {\r\n        this.classLoader = classLoader;\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.RuleSetFactory.isRuleName",
	"Comment": "determine if the specified rule element will represent a rule with thegiven name.",
	"Method": "boolean isRuleName(Element ruleElement,String ruleName){\r\n    if (ruleElement.hasAttribute(\"name\")) {\r\n        return ruleElement.getAttribute(\"name\").equals(ruleName);\r\n    } else if (ruleElement.hasAttribute(\"ref\")) {\r\n        RuleSetReferenceId ruleSetReferenceId = RuleSetReferenceId.parse(ruleElement.getAttribute(\"ref\")).get(0);\r\n        return ruleSetReferenceId.getRuleName() != null && ruleSetReferenceId.getRuleName().equals(ruleName);\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.powermock.api.mockito.PowerMockito.whenNew",
	"Comment": "allows specifying expectations on new invocations. for example you mightwant to throw an exception or return a mock.",
	"Method": "WithOrWithoutExpectedArguments<T> whenNew(Constructor<T> ctor,ConstructorExpectationSetup<T> whenNew,Class<T> type,ConstructorExpectationSetup<T> whenNew,String fullyQualifiedName){\r\n    final Class<T> forName = (Class<T>) Class.forName(fullyQualifiedName);\r\n    return new DefaultConstructorExpectationSetup<T>(forName);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.ast.ASTConditionalExpression.getTrueAlternative",
	"Comment": "returns the node that represents the expression that will be evaluatedif the guard evaluates to true.",
	"Method": "ASTExpression getTrueAlternative(){\r\n    return (ASTExpression) jjtGetChild(1);\r\n}"
}, {
	"Path": "com.kabouzeid.gramophone.util.PreferenceUtil.getLastAddedCutoffTimeSecs",
	"Comment": "the last added cutoff time is compared against the android media store timestamps, which is seconds based.",
	"Method": "long getLastAddedCutoffTimeSecs(){\r\n    return getCutoffTimeMillis(LAST_ADDED_CUTOFF) / 1000;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.fxdesigner.model.XPathEvaluator.evaluateQuery",
	"Comment": "evaluates an xpath query on the compilation unit. performsno side effects.",
	"Method": "List<Node> evaluateQuery(Node compilationUnit,LanguageVersion languageVersion,String xpathVersion,String xpathQuery,List<PropertyDescriptorSpec> properties){\r\n    if (StringUtils.isBlank(xpathQuery)) {\r\n        return emptyList();\r\n    }\r\n    try {\r\n        List<Node> results = new ArrayList();\r\n        XPathRule xpathRule = new XPathRule() {\r\n            @Override\r\n            public void addViolation(Object data, Node node, String arg) {\r\n                results.add(node);\r\n            }\r\n        };\r\n        xpathRule.setMessage(\"\");\r\n        xpathRule.setLanguage(languageVersion.getLanguage());\r\n        xpathRule.setXPath(xpathQuery);\r\n        xpathRule.setVersion(xpathVersion);\r\n        properties.stream().map(PropertyDescriptorSpec::build).forEach(xpathRule::definePropertyDescriptor);\r\n        final RuleSet ruleSet = new RuleSetFactory().createSingleRuleRuleSet(xpathRule);\r\n        RuleSets ruleSets = new RuleSets(ruleSet);\r\n        RuleContext ruleContext = new RuleContext();\r\n        ruleContext.setLanguageVersion(languageVersion);\r\n        ruleContext.setIgnoreExceptions(false);\r\n        ruleSets.apply(singletonList(compilationUnit), ruleContext, xpathRule.getLanguage());\r\n        return results;\r\n    } catch (RuntimeException e) {\r\n        throw new XPathEvaluationException(e);\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.fxdesigner.model.XPathEvaluator.evaluateQuery",
	"Comment": "evaluates an xpath query on the compilation unit. performsno side effects.",
	"Method": "List<Node> evaluateQuery(Node compilationUnit,LanguageVersion languageVersion,String xpathVersion,String xpathQuery,List<PropertyDescriptorSpec> properties){\r\n    results.add(node);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.vf.ast.VfDocStyleTest.testELInTagValueWithCommentDQ",
	"Comment": "test parsing of el in attribute of an element that also has a comment.",
	"Method": "void testELInTagValueWithCommentDQ(){\r\n    Set<ASTElement> elememts = getNodes(ASTElement.class, TEST_EL_IN_TAG_ATTRIBUTE_WITH_COMMENT);\r\n    assertEquals(\"One element expected!\", 1, elememts.size());\r\n    ASTElement element = elememts.iterator().next();\r\n    ASTElExpression elExpr = element.getFirstDescendantOfType(ASTElExpression.class);\r\n    ASTIdentifier id = elExpr.getFirstDescendantOfType(ASTIdentifier.class);\r\n    assertEquals(\"Correct identifier expected\", \"init\", id.getImage());\r\n}"
}, {
	"Path": "com.querydsl.core.util.BeanMap.entryIterator",
	"Comment": "convenience method for getting an iterator over the entries.",
	"Method": "Iterator<Entry<String, Object>> entryIterator(){\r\n    final Iterator<String> iter = keyIterator();\r\n    return new Iterator<Entry<String, Object>>() {\r\n        @Override\r\n        public boolean hasNext() {\r\n            return iter.hasNext();\r\n        }\r\n        @Override\r\n        public Entry<String, Object> next() {\r\n            String key = iter.next();\r\n            Object value = get(key);\r\n            return new MyMapEntry(BeanMap.this, key, value);\r\n        }\r\n        @Override\r\n        public void remove() {\r\n            throw new UnsupportedOperationException(\"remove() not supported for BeanMap\");\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.querydsl.core.util.BeanMap.entryIterator",
	"Comment": "convenience method for getting an iterator over the entries.",
	"Method": "Iterator<Entry<String, Object>> entryIterator(){\r\n    return iter.hasNext();\r\n}"
}, {
	"Path": "com.querydsl.core.util.BeanMap.entryIterator",
	"Comment": "convenience method for getting an iterator over the entries.",
	"Method": "Iterator<Entry<String, Object>> entryIterator(){\r\n    String key = iter.next();\r\n    Object value = get(key);\r\n    return new MyMapEntry(BeanMap.this, key, value);\r\n}"
}, {
	"Path": "com.querydsl.core.util.BeanMap.entryIterator",
	"Comment": "convenience method for getting an iterator over the entries.",
	"Method": "Iterator<Entry<String, Object>> entryIterator(){\r\n    throw new UnsupportedOperationException(\"remove() not supported for BeanMap\");\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.viewer.model.ViewerModel.commitSource",
	"Comment": "commits source code to the model. all existing source will be replaced.",
	"Method": "void commitSource(String source,LanguageVersion languageVersion){\r\n    LanguageVersionHandler languageVersionHandler = languageVersion.getLanguageVersionHandler();\r\n    Node node = languageVersionHandler.getParser(languageVersionHandler.getDefaultParserOptions()).parse(null, new StringReader(source));\r\n    rootNode = node;\r\n    fireViewerModelEvent(new ViewerModelEvent(this, ViewerModelEvent.CODE_RECOMPILED));\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.apex.rule.design.StdCyclomaticComplexityTest.entryStackMustBeEmpty",
	"Comment": "make sure the entry stack is empty, if show classes complexity isdisabled.",
	"Method": "void entryStackMustBeEmpty(){\r\n    StdCyclomaticComplexityRule rule = new StdCyclomaticComplexityRule();\r\n    rule.setProperty(StdCyclomaticComplexityRule.SHOW_CLASSES_COMPLEXITY_DESCRIPTOR, Boolean.FALSE);\r\n    RuleContext ctx = new RuleContext();\r\n    LanguageVersion javaLanguageVersion = LanguageRegistry.getLanguage(ApexLanguageModule.NAME).getDefaultVersion();\r\n    ParserOptions parserOptions = javaLanguageVersion.getLanguageVersionHandler().getDefaultParserOptions();\r\n    Parser parser = javaLanguageVersion.getLanguageVersionHandler().getParser(parserOptions);\r\n    Node node = parser.parse(\"test\", new StringReader(\"public class SampleClass {}\"));\r\n    rule.apply(Arrays.asList(node), ctx);\r\n    Assert.assertTrue(rule.entryStack.isEmpty());\r\n}"
}, {
	"Path": "net.sourceforge.pmd.PMDConfiguration.setAnalysisCacheLocation",
	"Comment": "sets the location of the analysis cache to be used. this will automatically configureand appropriate analysiscache implementation.",
	"Method": "void setAnalysisCacheLocation(String cacheLocation){\r\n    setAnalysisCache(cacheLocation == null ? new NoopAnalysisCache() : new FileAnalysisCache(new File(cacheLocation)));\r\n}"
}, {
	"Path": "com.querydsl.codegen.ClassPathUtils.scanPackage",
	"Comment": "return the classes from the given package and subpackages using the supplied classloader",
	"Method": "Set<Class<?>> scanPackage(ClassLoader classLoader,Package pkg,Set<Class<?>> scanPackage,ClassLoader classLoader,String pkg){\r\n    Reflections reflections = new Reflections(new ConfigurationBuilder().addUrls(ClasspathHelper.forPackage(pkg, classLoader)).addClassLoader(classLoader).setScanners(new SubTypesScanner(false)));\r\n    Set<Class<?>> classes = new HashSet<Class<?>>();\r\n    for (String typeNames : reflections.getStore().get(SubTypesScanner.class.getSimpleName()).values()) {\r\n        Class<?> clazz = safeClassForName(classLoader, typeNames);\r\n        if (clazz != null) {\r\n            classes.add(clazz);\r\n        }\r\n    }\r\n    return classes;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.ast.JavaQualifiedName.isLocalClass",
	"Comment": "returns true if this qualified name identifies alocal class.",
	"Method": "boolean isLocalClass(){\r\n    return getClassName().isLocalClass();\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.jsp.ast.JspDocStyleTest.noSpacesBetweenTags",
	"Comment": "test parsing of html with no spaces between tags. parser is likely inthis scenario.",
	"Method": "void noSpacesBetweenTags(){\r\n    Set<ASTElement> scripts = getNodes(ASTElement.class, TEST_TAGS_NO_SPACE);\r\n    assertEquals(\"Two tags expected!\", 2, scripts.size());\r\n    List<ASTElement> elmts = sortNodesByName(scripts);\r\n    Iterator<ASTElement> iterator = elmts.iterator();\r\n    ASTElement script = iterator.next();\r\n    assertEquals(\"Correct content expected!\", \"a\", script.getName());\r\n    script = iterator.next();\r\n    assertEquals(\"Correct content expected!\", \"b\", script.getName());\r\n}"
}, {
	"Path": "com.querydsl.core.BooleanBuilder.orNot",
	"Comment": "create the union of this and the negation of the given predicate",
	"Method": "BooleanBuilder orNot(Predicate right){\r\n    return or(right.not());\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.TypeMap.size",
	"Comment": "returns the total number of entries in the receiver. this will be exactlytwice the number of types added.",
	"Method": "int size(){\r\n    return typesByName.size();\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.metrics.impl.AbstractJavaClassMetric.countMatchingFieldSigs",
	"Comment": "counts the fields matching the signature mask in this class.",
	"Method": "int countMatchingFieldSigs(ASTAnyTypeDeclaration classNode,JavaFieldSigMask mask){\r\n    int count = 0;\r\n    List<ASTFieldDeclaration> decls = getFields(classNode);\r\n    for (ASTFieldDeclaration decl : decls) {\r\n        if (mask.covers(decl.getSignature())) {\r\n            count++;\r\n        }\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.symboltable.ScopeAndDeclarationFinder.createMethodScope",
	"Comment": "creates a new method scope for an ast node. the scope on top of the stackis set as the parent of the new scope, which is then also stored on thescope stack.",
	"Method": "void createMethodScope(JavaNode node){\r\n    addScope(new MethodScope(node), node);\r\n}"
}, {
	"Path": "com.querydsl.jpa.impl.AbstractJPAQuery.clone",
	"Comment": "clone the state of this query to a new instance with the given entitymanagerand the specified templates",
	"Method": "void clone(Q query,Q clone,EntityManager entityManager,Q clone,EntityManager entityManager,JPQLTemplates templates,Q clone){\r\n    return clone(entityManager, getTemplates());\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.qname.JavaOperationQualifiedName.getOperation",
	"Comment": "returns the operation specific part of the name. itidentifies an operation in its namespace.",
	"Method": "String getOperation(){\r\n    return operation;\r\n}"
}, {
	"Path": "com.querydsl.collections.DefaultEvaluatorFactory.create",
	"Comment": "create an evaluator for the given query sources and projection",
	"Method": "Evaluator<T> create(QueryMetadata metadata,List<? extends Expression<?>> sources,Expression<T> projection){\r\n    final CollQuerySerializer serializer = new CollQuerySerializer(templates);\r\n    serializer.append(\"return \");\r\n    if (projection instanceof FactoryExpression<?>) {\r\n        serializer.append(\"(\");\r\n        serializer.append(ClassUtils.getName(projection.getType()));\r\n        serializer.append(\")(\");\r\n        serializer.handle(projection);\r\n        serializer.append(\")\");\r\n    } else {\r\n        serializer.handle(projection);\r\n    }\r\n    serializer.append(\";\");\r\n    Map<Object, String> constantToLabel = serializer.getConstantToLabel();\r\n    Map<String, Object> constants = getConstants(metadata, constantToLabel);\r\n    Class<?>[] types = new Class<?>[sources.size()];\r\n    String[] names = new String[sources.size()];\r\n    for (int i = 0; i < sources.size(); i++) {\r\n        types[i] = sources.get(i).getType();\r\n        names[i] = sources.get(i).toString();\r\n    }\r\n    for (int i = 0; i < types.length; i++) {\r\n        if (Primitives.isWrapperType(types[i])) {\r\n            types[i] = Primitives.unwrap(types[i]);\r\n        }\r\n    }\r\n    return factory.createEvaluator(serializer.toString(), projection.getType(), names, types, constants);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.symboltable.ScopeAndDeclarationFinder.createLocalScope",
	"Comment": "creates a new local scope for an ast node. the scope on top of the stackis set as the parent of the new scope, which is then also stored on thescope stack.",
	"Method": "void createLocalScope(JavaNode node){\r\n    addScope(new LocalScope(), node);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.database.DBURITest.testDefaultSchemasList",
	"Comment": "verify that default languages are returned if non are provided in thedburi.",
	"Method": "void testDefaultSchemasList(){\r\n    System.out.println(\"testDefaultSchemasList\");\r\n    List<String> defaultSchemasList = Arrays.asList(C_DEFAULT_SCHEMAS.split(\",\"));\r\n    DBURI instance = new DBURI(C_TEST_DEFAULTS);\r\n    List<String> result = instance.getSchemasList();\r\n    assertEquals(defaultSchemasList, result);\r\n}"
}, {
	"Path": "com.querydsl.mongodb.MongodbExpressions.nearSphere",
	"Comment": "finds the closest points relative to the given location on a sphere and orders the results with decreasing proximity",
	"Method": "BooleanExpression nearSphere(Expression<Double[]> expr,double latVal,double longVal){\r\n    return Expressions.booleanOperation(MongodbOps.NEAR_SPHERE, expr, ConstantImpl.create(new Double[] { latVal, longVal }));\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.CollectionUtil.arraysAreEqual",
	"Comment": "returns true if the objects are array instances and each of theirelements compares via equals as well.",
	"Method": "boolean arraysAreEqual(Object value,Object otherValue){\r\n    if (value instanceof Object[]) {\r\n        if (otherValue instanceof Object[]) {\r\n            return valuesAreTransitivelyEqual((Object[]) value, (Object[]) otherValue);\r\n        }\r\n        return false;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.plsql.ast.AbstractPLSQLNode.getCanonicalImage",
	"Comment": "convert arbitrary string to normal oracle format, under assumption thatthe passed image is an oracle name.this a helper method for plsql classes dependent on simplenode, thatwould otherwise have to import plsqparser.",
	"Method": "String getCanonicalImage(String getCanonicalImage,String image){\r\n    return PLSQLParser.canonicalName(image);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.PMD.newRuleContext",
	"Comment": "creates a new rule context, initialized with a new, empty report.",
	"Method": "RuleContext newRuleContext(String sourceCodeFilename,File sourceCodeFile){\r\n    RuleContext context = new RuleContext();\r\n    context.setSourceCodeFile(sourceCodeFile);\r\n    context.setSourceCodeFilename(sourceCodeFilename);\r\n    context.setReport(new Report());\r\n    return context;\r\n}"
}, {
	"Path": "com.querydsl.core.types.dsl.Expressions.currentTimestamp",
	"Comment": "create an expression representing the current time instant as a datetimeexpression instance",
	"Method": "DateTimeExpression<Date> currentTimestamp(){\r\n    return DateTimeExpression.currentTimestamp();\r\n}"
}, {
	"Path": "com.kabouzeid.gramophone.appwidgets.AppWidgetSmall.defaultAppWidget",
	"Comment": "initialize given widgets to default state, where we launch music ondefault click and hide actions if service not running.",
	"Method": "void defaultAppWidget(Context context,int[] appWidgetIds){\r\n    final RemoteViews appWidgetView = new RemoteViews(context.getPackageName(), R.layout.app_widget_small);\r\n    appWidgetView.setViewVisibility(R.id.media_titles, View.INVISIBLE);\r\n    appWidgetView.setImageViewResource(R.id.image, R.drawable.default_album_art);\r\n    appWidgetView.setImageViewBitmap(R.id.button_next, createBitmap(Util.getTintedVectorDrawable(context, R.drawable.ic_skip_next_white_24dp, MaterialValueHelper.getSecondaryTextColor(context, true)), 1f));\r\n    appWidgetView.setImageViewBitmap(R.id.button_prev, createBitmap(Util.getTintedVectorDrawable(context, R.drawable.ic_skip_previous_white_24dp, MaterialValueHelper.getSecondaryTextColor(context, true)), 1f));\r\n    appWidgetView.setImageViewBitmap(R.id.button_toggle_play_pause, createBitmap(Util.getTintedVectorDrawable(context, R.drawable.ic_play_arrow_white_24dp, MaterialValueHelper.getSecondaryTextColor(context, true)), 1f));\r\n    linkButtons(context, appWidgetView);\r\n    pushUpdate(context, appWidgetIds, appWidgetView);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.metrics.impl.AbstractJavaOperationMetric.supports",
	"Comment": "returns true if the metric can be computed on this operation. by default, abstract operations are filtered out.",
	"Method": "boolean supports(MethodLikeNode node,boolean supports,ASTMethodOrConstructorDeclaration node){\r\n    return supports((MethodLikeNode) node);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.rules.RuleFactory.parsePropertyDefinition",
	"Comment": "parses a property definition node and returns the defined property descriptor.",
	"Method": "PropertyDescriptor<?> parsePropertyDefinition(Element propertyElement){\r\n    String typeId = propertyElement.getAttribute(PropertyDescriptorField.TYPE.attributeName());\r\n    PropertyDescriptorExternalBuilder<?> pdFactory = PropertyTypeId.factoryFor(typeId);\r\n    if (pdFactory == null) {\r\n        throw new IllegalArgumentException(\"No property descriptor factory for type: \" + typeId);\r\n    }\r\n    Map<PropertyDescriptorField, String> values = new HashMap();\r\n    NamedNodeMap atts = propertyElement.getAttributes();\r\n    for (int i = 0; i < atts.getLength(); i++) {\r\n        Attr a = (Attr) atts.item(i);\r\n        values.put(PropertyDescriptorField.getConstant(a.getName()), a.getValue());\r\n    }\r\n    if (StringUtils.isBlank(values.get(DEFAULT_VALUE))) {\r\n        NodeList children = propertyElement.getElementsByTagName(DEFAULT_VALUE.attributeName());\r\n        if (children.getLength() == 1) {\r\n            values.put(DEFAULT_VALUE, children.item(0).getTextContent());\r\n        } else {\r\n            throw new IllegalArgumentException(\"No value defined!\");\r\n        }\r\n    }\r\n    return pdFactory.build(values);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.metrics.MetricOptions.getOptions",
	"Comment": "returns an immutable set of options. metrics may use these options as they see fit.",
	"Method": "Set<MetricOption> getOptions(){\r\n    return options;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.RuleSets.usesDFA",
	"Comment": "check if the rules that apply to a source of the given language use dfa.",
	"Method": "boolean usesDFA(Language language){\r\n    for (RuleSet ruleSet : ruleSets) {\r\n        if (ruleSet.usesDFA(language)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.dfa.report.ReportTree.addRuleViolation",
	"Comment": "adds the ruleviolation to the tree. splits the package name. eachpackage, class and violation gets there own tree node.",
	"Method": "void addRuleViolation(RuleViolation violation){\r\n    String packageName = violation.getPackageName();\r\n    if (packageName == null) {\r\n        packageName = \"\";\r\n    }\r\n    level = rootNode;\r\n    int endIndex = packageName.indexOf('.');\r\n    while (true) {\r\n        String parentPackage;\r\n        if (endIndex < 0) {\r\n            parentPackage = packageName;\r\n        } else {\r\n            parentPackage = packageName.substring(0, endIndex);\r\n        }\r\n        if (!isStringInLevel(parentPackage)) {\r\n            PackageNode node = new PackageNode(parentPackage);\r\n            level.addFirst(node);\r\n            level = node;\r\n        }\r\n        if (endIndex < 0) {\r\n            break;\r\n        }\r\n        endIndex = packageName.indexOf('.', endIndex + 1);\r\n    }\r\n    String cl = violation.getClassName();\r\n    if (!isStringInLevel(cl)) {\r\n        ClassNode node = new ClassNode(cl);\r\n        level.addFirst(node);\r\n        level = node;\r\n    }\r\n    ViolationNode tmp = new ViolationNode(violation);\r\n    if (!equalsNodeInLevel(level, tmp)) {\r\n        level.add(tmp);\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.codestyle.PrematureDeclarationRule.hasReferencesIn",
	"Comment": "returns whether the variable is mentioned within the statement or not.",
	"Method": "boolean hasReferencesIn(ASTBlockStatement block,String varName){\r\n    for (ASTName name : block.findDescendantsOfType(ASTName.class, true)) {\r\n        if (isReference(varName, name.getImage())) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.qname.QualifiedNameResolver.contextOperationQName",
	"Comment": "creates a new operation qname, using the current context for the class part.",
	"Method": "JavaOperationQualifiedName contextOperationQName(String op,boolean isLambda){\r\n    return new JavaOperationQualifiedName(innermostEnclosingTypeName.peek(), op, isLambda);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.ast.ASTTypeParameter.getTypeBoundNode",
	"Comment": "returns the type bound node of this parameter,or null if it is not bounded.",
	"Method": "ASTTypeBound getTypeBoundNode(){\r\n    return getFirstChildOfType(ASTTypeBound.class);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.it.CpdExecutor.runCpd",
	"Comment": "executes cpd found in tempdir with the given command line arguments.",
	"Method": "ExecutionResult runCpd(Path tempDir,String arguments){\r\n    if (SystemUtils.IS_OS_WINDOWS) {\r\n        return runCpdWindows(tempDir, arguments);\r\n    } else {\r\n        return runCpdUnix(tempDir, arguments);\r\n    }\r\n}"
}, {
	"Path": "org.powermock.reflect.internal.WhiteboxImpl.invokeConstructor",
	"Comment": "invoke a constructor. useful for testing classes with a privateconstructor.",
	"Method": "T invokeConstructor(Class<T> classThatContainsTheConstructorToTest,Class<?>[] parameterTypes,Object[] arguments,T invokeConstructor,Class<T> classThatContainsTheConstructorToTest,Object arguments){\r\n    if (classThatContainsTheConstructorToTest == null) {\r\n        throw new IllegalArgumentException(\"The class should contain the constructor cannot be null.\");\r\n    }\r\n    Class<?>[] argumentTypes = null;\r\n    if (arguments == null) {\r\n        argumentTypes = new Class<?>[0];\r\n    } else {\r\n        argumentTypes = new Class<?>[arguments.length];\r\n        for (int i = 0; i < arguments.length; i++) {\r\n            argumentTypes[i] = getType(arguments[i]);\r\n        }\r\n    }\r\n    Constructor<T> constructor = null;\r\n    constructor = getBestCandidateConstructor(classThatContainsTheConstructorToTest, argumentTypes, arguments);\r\n    return createInstance(constructor, arguments);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.fxdesigner.MainDesignerController.wrapNode",
	"Comment": "returns a wrapper around the given node that gives accessto its textual representation in the editor area.",
	"Method": "TextAwareNodeWrapper wrapNode(Node node){\r\n    return sourceEditorController.wrapNode(node);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.it.PMDExecutor.runPMD",
	"Comment": "executes pmd found in tempdir with the given command line arguments.",
	"Method": "ExecutionResult runPMD(Path tempDir,String arguments){\r\n    if (SystemUtils.IS_OS_WINDOWS) {\r\n        return runPMDWindows(tempDir, arguments);\r\n    } else {\r\n        return runPMDUnix(tempDir, arguments);\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.xml.XmlParserTest.testParsingWithValidation",
	"Comment": "verifies the parsing behavior of the xml parser with validation on.",
	"Method": "void testParsingWithValidation(){\r\n    LanguageVersionHandler xmlVersionHandler = LanguageRegistry.getLanguage(XmlLanguageModule.NAME).getDefaultVersion().getLanguageVersionHandler();\r\n    XmlParserOptions parserOptions = new XmlParserOptions();\r\n    parserOptions.setValidating(true);\r\n    Parser parser = xmlVersionHandler.getParser(parserOptions);\r\n    PrintStream oldErr = System.err;\r\n    Locale oldLocale = Locale.getDefault();\r\n    try {\r\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n        System.setErr(new PrintStream(bos));\r\n        Locale.setDefault(Locale.ENGLISH);\r\n        Node document = parser.parse(null, new StringReader(XML_INVALID_WITH_DTD));\r\n        Assert.assertNotNull(document);\r\n        String output = bos.toString(\"UTF-8\");\r\n        Assert.assertTrue(output.contains(\"Element type \\\"invalidChild\\\" must be declared.\"));\r\n        Assert.assertTrue(output.contains(\"The content of element type \\\"rootElement\\\" must match \\\"(child)\\\".\"));\r\n        Assert.assertEquals(2, document.jjtGetNumChildren());\r\n        Assert.assertEquals(\"invalidChild\", String.valueOf(document.jjtGetChild(1).jjtGetChild(1)));\r\n    } finally {\r\n        System.setErr(oldErr);\r\n        Locale.setDefault(oldLocale);\r\n    }\r\n}"
}, {
	"Path": "org.powermock.api.easymock.PowerMock.verify",
	"Comment": "switches the mocks or classes to verify mode. note that you must use thismethod when using powermock!",
	"Method": "void verify(Object objects){\r\n    for (Object mock : objects) {\r\n        if (mock instanceof Class<?>) {\r\n            verifyClass((Class<?>) mock);\r\n        } else {\r\n            EasyMockMethodInvocationControl invocationControl = (EasyMockMethodInvocationControl) MockRepository.getInstanceMethodInvocationControl(mock);\r\n            if (invocationControl != null) {\r\n                invocationControl.verify();\r\n            } else {\r\n                if (isNiceReplayAndVerifyMode() && !isEasyMocked(mock)) {\r\n                } else {\r\n                    try {\r\n                        org.easymock.EasyMock.verify(mock);\r\n                    } catch (RuntimeException e) {\r\n                        throw new RuntimeException(mock + \" is not a mock object\", e);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.bestpractices.ForLoopCanBeForeachRule.getIndexVarDeclaration",
	"Comment": "finds the declaration of the index variable and its occurrences, null to abort",
	"Method": "Entry<VariableNameDeclaration, List<NameOccurrence>> getIndexVarDeclaration(ASTForInit init,ASTForUpdate update){\r\n    if (init == null) {\r\n        return guessIndexVarFromUpdate(update);\r\n    }\r\n    ASTLocalVariableDeclaration decl = init.getFirstChildOfType(ASTLocalVariableDeclaration.class);\r\n    if (decl == null) {\r\n        return null;\r\n    }\r\n    int numDeclaredVars = decl.findChildrenOfType(ASTVariableDeclarator.class).size();\r\n    if (numDeclaredVars > 1) {\r\n        return null;\r\n    }\r\n    Map<VariableNameDeclaration, List<NameOccurrence>> decls = init.getScope().getDeclarations(VariableNameDeclaration.class);\r\n    Entry<VariableNameDeclaration, List<NameOccurrence>> indexVarAndOccurrences = null;\r\n    for (Entry<VariableNameDeclaration, List<NameOccurrence>> e : decls.entrySet()) {\r\n        ASTForInit declInit = e.getKey().getNode().getFirstParentOfType(ASTForInit.class);\r\n        if (Objects.equals(declInit, init)) {\r\n            indexVarAndOccurrences = e;\r\n            break;\r\n        }\r\n    }\r\n    return indexVarAndOccurrences;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.AbstractIgnoredAnnotationRule.hasIgnoredAnnotation",
	"Comment": "checks whether any annotation in ignoredannotationsdescriptor is present on the node.",
	"Method": "boolean hasIgnoredAnnotation(Annotatable node){\r\n    return node.isAnyAnnotationPresent(getProperty(ignoredAnnotationsDescriptor));\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.rule.AbstractRuleChainVisitor.clear",
	"Comment": "clears the internal data structure used to manage the nodes visitedbetween visiting different asts.",
	"Method": "void clear(){\r\n    for (List<Node> l : nodeNameToNodes.values()) {\r\n        l.clear();\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.xml.ast.XmlParser.wrapDomNode",
	"Comment": "gets the wrapper for a dom node, implementing pmd interfaces.",
	"Method": "XmlNode wrapDomNode(Node domNode){\r\n    XmlNode wrapper = nodeCache.get(domNode);\r\n    if (wrapper == null) {\r\n        wrapper = new XmlNodeWrapper(this, domNode);\r\n        nodeCache.put(domNode, wrapper);\r\n    }\r\n    return wrapper;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.RuleSet.equals",
	"Comment": "two rulesets are equals, if they have the same name and contain the samerules.",
	"Method": "boolean equals(Object o){\r\n    if (!(o instanceof RuleSet)) {\r\n        return false;\r\n    }\r\n    if (this == o) {\r\n        return true;\r\n    }\r\n    RuleSet ruleSet = (RuleSet) o;\r\n    return getName().equals(ruleSet.getName()) && getRules().equals(ruleSet.getRules());\r\n}"
}, {
	"Path": "com.querydsl.collections.AbstractCollQuery.bind",
	"Comment": "bind the given collection to an already existing query source",
	"Method": "Q bind(Path<A> entity,Iterable<? extends A> col){\r\n    iterables.put(entity, col);\r\n    return queryMixin.getSelf();\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.symboltable.ScopeAndDeclarationFinder.addScope",
	"Comment": "sets the scope of a node and adjusts the scope stack accordingly. thescope on top of the stack is set as the parent of the given scope, whichis then also stored on the scope stack.",
	"Method": "void addScope(Scope newScope,JavaNode node){\r\n    newScope.setParent(scopes.peek());\r\n    scopes.push(newScope);\r\n    node.setScope(newScope);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.design.CouplingBetweenObjectsRule.checkVariableType",
	"Comment": "performs a check on the variable and updates the counter. counter isinstance for a class and is reset upon new class scan.",
	"Method": "void checkVariableType(Node nameNode,String variableType){\r\n    if (nameNode.getParentsOfType(ASTClassOrInterfaceDeclaration.class).isEmpty()) {\r\n        return;\r\n    }\r\n    ClassScope clzScope = ((JavaNode) nameNode).getScope().getEnclosingScope(ClassScope.class);\r\n    if (!clzScope.getClassName().equals(variableType) && !this.filterTypes(variableType) && !this.typesFoundSoFar.contains(variableType)) {\r\n        couplingCount++;\r\n        typesFoundSoFar.add(variableType);\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.AbstractJavaParser.createJavaParser",
	"Comment": "subclass should override this method to modify the javaparser as needed.",
	"Method": "JavaParser createJavaParser(Reader source){\r\n    parser = new JavaParser(new JavaCharStream(source));\r\n    String suppressMarker = getParserOptions().getSuppressMarker();\r\n    if (suppressMarker != null) {\r\n        parser.setSuppressMarker(suppressMarker);\r\n    }\r\n    return parser;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.plsql.rule.design.AbstractNcssCountRule.countNodeChildren",
	"Comment": "count the number of children of the given plsql node. adds one to countthe node itself.",
	"Method": "Integer countNodeChildren(Node node,Object data){\r\n    Integer nodeCount = null;\r\n    int lineCount = 0;\r\n    for (int i = 0; i < node.jjtGetNumChildren(); i++) {\r\n        nodeCount = (Integer) ((PLSQLNode) node.jjtGetChild(i)).jjtAccept(this, data);\r\n        lineCount += nodeCount.intValue();\r\n    }\r\n    return ++lineCount;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.RuleContext.setLanguageVersion",
	"Comment": "set the languageversion associated with the current source file. this maybe set to null to indicate the version is unknown and shouldbe automatically determined.",
	"Method": "void setLanguageVersion(LanguageVersion languageVersion){\r\n    this.languageVersion = languageVersion;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.ast.ASTDoStatement.getGuardExpressionNode",
	"Comment": "returns the node that represents the guard of this loop.this may be any expression of type boolean.",
	"Method": "ASTExpression getGuardExpressionNode(){\r\n    return (ASTExpression) jjtGetChild(1);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.PMDConfiguration.getInputPaths",
	"Comment": "get the comma separated list of input paths to process for source files.",
	"Method": "String getInputPaths(){\r\n    return inputPaths;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.PMDConfiguration.isStressTest",
	"Comment": "return the stress test indicator. if this value is true thenpmd will randomize the order of file processing to attempt to shake outbugs.",
	"Method": "boolean isStressTest(){\r\n    return stressTest;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.Report.suppress",
	"Comment": "configure the lines, that are suppressed via a nopmd comment.",
	"Method": "void suppress(Map<Integer, String> lines){\r\n    linesToSuppress = lines;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.ast.ASTLiteral.getEscapedStringLiteral",
	"Comment": "tries to reconstruct the original string literal. if the original lengthis greater than the parsed string literal, then probably some unicodeescape sequences have been used.",
	"Method": "String getEscapedStringLiteral(){\r\n    String image = getImage();\r\n    if (!isStringLiteral() && !isCharLiteral()) {\r\n        return image;\r\n    }\r\n    int fullLength = getEndColumn() - getBeginColumn();\r\n    if (fullLength > image.length()) {\r\n        StringBuilder result = new StringBuilder(fullLength);\r\n        for (int i = 0; i < image.length(); i++) {\r\n            char c = image.charAt(i);\r\n            if (c < 0x20 || c > 0xff || image.length() == 1) {\r\n                String hex = \"0000\" + Integer.toHexString(c);\r\n                result.append(\"\\\%u\").append(hex.substring(hex.length() - 4));\r\n            } else {\r\n                result.append(c);\r\n            }\r\n        }\r\n        return result.toString();\r\n    }\r\n    return image;\r\n}"
}, {
	"Path": "com.querydsl.core.util.BeanMap.put",
	"Comment": "sets the bean property with the given name to the given value.",
	"Method": "Object put(String name,Object value){\r\n    if (bean != null) {\r\n        Object oldValue = get(name);\r\n        Method method = getWriteMethod(name);\r\n        if (method == null) {\r\n            throw new IllegalArgumentException(\"The bean of type: \" + bean.getClass().getName() + \" has no property called: \" + name);\r\n        }\r\n        try {\r\n            Object[] arguments = createWriteMethodArguments(method, value);\r\n            method.invoke(bean, arguments);\r\n            Object newValue = get(name);\r\n            firePropertyChange(name, oldValue, newValue);\r\n        } catch (InvocationTargetException e) {\r\n            throw new IllegalArgumentException(e.getMessage());\r\n        } catch (IllegalAccessException e) {\r\n            throw new IllegalArgumentException(e.getMessage());\r\n        }\r\n        return oldValue;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.StringUtil.lengthOfShortestIn",
	"Comment": "return the length of the shortest string in the array. if the collectionis empty or any one of them is null then it returns 0.",
	"Method": "int lengthOfShortestIn(String[] strings){\r\n    if (CollectionUtil.isEmpty(strings)) {\r\n        return 0;\r\n    }\r\n    int minLength = Integer.MAX_VALUE;\r\n    for (int i = 0; i < strings.length; i++) {\r\n        if (strings[i] == null) {\r\n            return 0;\r\n        }\r\n        minLength = Math.min(minLength, strings[i].length());\r\n    }\r\n    return minLength;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.apex.rule.ApexRuleViolation.isSupressed",
	"Comment": "check for suppression on this node, on parents, and on contained typesfor astcompilationunit",
	"Method": "boolean isSupressed(Node node,Rule rule){\r\n    boolean result = suppresses(node, rule);\r\n    if (!result) {\r\n        Node parent = node.jjtGetParent();\r\n        while (!result && parent != null) {\r\n            result = suppresses(parent, rule);\r\n            parent = parent.jjtGetParent();\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.AbstractJavaRule.getDeclaringType",
	"Comment": "gets the image of the first parent node of typeastclassorinterfacedeclaration or null",
	"Method": "String getDeclaringType(Node node){\r\n    ASTClassOrInterfaceDeclaration c = node.getFirstParentOfType(ASTClassOrInterfaceDeclaration.class);\r\n    if (c != null) {\r\n        return c.getImage();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.PMDVersion.getNextMajorRelease",
	"Comment": "retrieves the next major release to be expected.useful when logging deprecation messages to indicate when support will be removed.",
	"Method": "String getNextMajorRelease(){\r\n    if (isUnknown()) {\r\n        return UNKNOWN_VERSION;\r\n    }\r\n    final int major = Integer.parseInt(VERSION.split(\"\\\\.\")[0]);\r\n    return (major + 1) + \".0.0\";\r\n}"
}, {
	"Path": "net.sourceforge.pmd.properties.constraints.NumericConstraints.positive",
	"Comment": "requires the number to be strictly positive.the int values of the number is used for comparisonso there may be some unexpected behaviour with decimalnumbers.",
	"Method": "PropertyConstraint<N> positive(){\r\n    return ConstraintFactory.fromPredicate(new Predicate<N>() {\r\n        @Override\r\n        public boolean test(N t) {\r\n            return t.intValue() > 0;\r\n        }\r\n    }, \"Should be positive\");\r\n}"
}, {
	"Path": "net.sourceforge.pmd.properties.constraints.NumericConstraints.positive",
	"Comment": "requires the number to be strictly positive.the int values of the number is used for comparisonso there may be some unexpected behaviour with decimalnumbers.",
	"Method": "PropertyConstraint<N> positive(){\r\n    return t.intValue() > 0;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.database.DBURITest.testDefaultSourceCodeNamesList",
	"Comment": "verify that default languages are returned if non are provided in thedburi.",
	"Method": "void testDefaultSourceCodeNamesList(){\r\n    System.out.println(\"testDefaultSourceCodeNamesList\");\r\n    List<String> defaultSourceCodeNamesList = Arrays.asList(C_DEFAULT_SOURCE_CODE_NAMES.split(\",\"));\r\n    DBURI instance = new DBURI(C_TEST_DEFAULTS);\r\n    List<String> result = instance.getSourceCodeNamesList();\r\n    assertEquals(defaultSourceCodeNamesList, result);\r\n}"
}, {
	"Path": "com.querydsl.lucene4.AbstractLuceneQuery.distinct",
	"Comment": "add a duplicatefilter for the field of the given property path",
	"Method": "Q distinct(Q distinct,Path<?> property){\r\n    return filter(new DuplicateFilter(serializer.toField(property)));\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.vm.ast.ASTDirective.setDirectiveName",
	"Comment": "sets the directive name. used by the parser. this keeps us from having todig it out of the token stream and gives the parse the change tooverride.",
	"Method": "void setDirectiveName(String str){\r\n    directiveName = str;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.PMDConfiguration.setInputPaths",
	"Comment": "set the comma separated list of input paths to process for source files.",
	"Method": "void setInputPaths(String inputPaths){\r\n    this.inputPaths = inputPaths;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.bestpractices.AbstractSunSecureRule.isLocalVariable",
	"Comment": "todo modify usages to use symbol table tells if the variable name is alocal variable declared in the method.",
	"Method": "boolean isLocalVariable(String vn,Node node){\r\n    final List<ASTLocalVariableDeclaration> lvars = node.findDescendantsOfType(ASTLocalVariableDeclaration.class);\r\n    if (lvars != null) {\r\n        for (ASTLocalVariableDeclaration lvd : lvars) {\r\n            final ASTVariableDeclaratorId vid = lvd.getFirstDescendantOfType(ASTVariableDeclaratorId.class);\r\n            if (vid != null && vid.hasImageEqualTo(vn)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.errorprone.CompareObjectsWithEqualsRule.isPartOfQualifiedName",
	"Comment": "checks whether the given node contains a qualified name, consisting ofone astprimaryprefix and one or more astprimarysuffix nodes.",
	"Method": "boolean isPartOfQualifiedName(Node node){\r\n    return node.jjtGetChild(0) instanceof ASTPrimaryPrefix && !node.findChildrenOfType(ASTPrimarySuffix.class).isEmpty();\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.ast.ASTSingleMemberAnnotation.getMemberValue",
	"Comment": "returns the value of the default memberset by this annotation.",
	"Method": "ASTMemberValue getMemberValue(){\r\n    return (ASTMemberValue) jjtGetChild(1);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.bestpractices.JUnitTestsShouldIncludeAssertRule.getRuleAnnotatedExpectedExceptions",
	"Comment": "gets a list of namedeclarations for all the fields that have typeexpectedexception and have a rule annotation.",
	"Method": "Map<String, List<NameOccurrence>> getRuleAnnotatedExpectedExceptions(Scope classScope){\r\n    Map<String, List<NameOccurrence>> result = new HashMap();\r\n    Map<NameDeclaration, List<NameOccurrence>> decls = classScope.getDeclarations();\r\n    for (Map.Entry<NameDeclaration, List<NameOccurrence>> entry : decls.entrySet()) {\r\n        Node parent = entry.getKey().getNode().jjtGetParent().jjtGetParent().jjtGetParent();\r\n        if (parent.hasDescendantOfType(ASTMarkerAnnotation.class) && parent.getFirstChildOfType(ASTFieldDeclaration.class) != null) {\r\n            String annot = parent.getFirstDescendantOfType(ASTMarkerAnnotation.class).jjtGetChild(0).getImage();\r\n            if (!\"Rule\".equals(annot) && !\"org.junit.Rule\".equals(annot)) {\r\n                continue;\r\n            }\r\n            Node type = parent.getFirstDescendantOfType(ASTReferenceType.class);\r\n            if (!\"ExpectedException\".equals(type.jjtGetChild(0).getImage())) {\r\n                continue;\r\n            }\r\n            result.put(entry.getKey().getName(), entry.getValue());\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.querydsl.core.types.dsl.ComparableExpressionBase.asc",
	"Comment": "create an orderspecifier for ascending order of this expression",
	"Method": "OrderSpecifier<T> asc(){\r\n    if (asc == null) {\r\n        asc = new OrderSpecifier<T>(Order.ASC, mixin);\r\n    }\r\n    return asc;\r\n}"
}, {
	"Path": "io.paperdb.Book.exist",
	"Comment": "checks if an object with the given key is saved in book storage.",
	"Method": "boolean exist(String key){\r\n    return mStorage.exists(key);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.rule.xpath.SaxonXPathRuleQuery.getDocumentNodeForRootNode",
	"Comment": "gets the documentnode representation for the whole ast in which the node is, that is, if the node is not the rootof the ast, then the ast is traversed all the way up until the root node is found. if the documentnode wascached because this method was previously called, then a new documentnode will not be instanced.",
	"Method": "DocumentNode getDocumentNodeForRootNode(Node node){\r\n    final Node root = getRootNode(node);\r\n    DocumentNode documentNode;\r\n    synchronized (CACHE) {\r\n        documentNode = CACHE.get(root);\r\n        if (documentNode == null) {\r\n            documentNode = new DocumentNode(root);\r\n            CACHE.put(root, documentNode);\r\n        }\r\n    }\r\n    return documentNode;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.docs.RuleSetUtils.getRuleSetFilename",
	"Comment": "gets the sanitized base name of the ruleset.for some reason, the filename might contain some newlines, which are removed.",
	"Method": "String getRuleSetFilename(RuleSet ruleset,String getRuleSetFilename,String rulesetFileName){\r\n    return FilenameUtils.getBaseName(StringUtils.chomp(rulesetFileName));\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.apex.metrics.ApexMetrics.get",
	"Comment": "computes the standard version of the metric identified by the key on a operation ast node.",
	"Method": "double get(MetricKey<ASTUserClassOrInterface<?>> key,ASTUserClass node,double get,MetricKey<ASTUserClassOrInterface<?>> key,ASTUserClass node,MetricOptions options,double get,MetricKey<ASTMethod> key,ASTMethod node,double get,MetricKey<ASTMethod> key,ASTMethod node,MetricOptions options,double get,MetricKey<ASTMethod> key,ASTUserClassOrInterface<?> node,ResultOption resultOption,double get,MetricKey<ASTMethod> key,ASTUserClassOrInterface<?> node,MetricOptions options,ResultOption resultOption){\r\n    return FACADE.computeWithResultOption(key, node, options, resultOption);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.it.ExecutionResult.assertExecutionResult",
	"Comment": "asserts that the command exited with the expected exit code and that the given expectedoutput is contained in the actual command output.",
	"Method": "void assertExecutionResult(int expectedExitCode,String expectedOutput){\r\n    assertEquals(\"Command exited with wrong code\", expectedExitCode, exitCode);\r\n    assertNotNull(\"No output found\", output);\r\n    if (!output.contains(expectedOutput)) {\r\n        fail(\"Expected output '\" + expectedOutput + \"' not present.\\nComplete output:\\n\\n\" + output);\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.design.CouplingBetweenObjectsRule.handleASTTypeChildren",
	"Comment": "convience method to handle hierarchy. this is probably too much work andwill go away once i figure out the framework",
	"Method": "void handleASTTypeChildren(Node node){\r\n    for (int x = 0; x < node.jjtGetNumChildren(); x++) {\r\n        Node sNode = node.jjtGetChild(x);\r\n        if (sNode instanceof ASTType) {\r\n            Node nameNode = sNode.jjtGetChild(0);\r\n            checkVariableType(nameNode, nameNode.getImage());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.fxdesigner.util.codearea.HighlightLayerCodeArea.styleSyntaxHighlightChange",
	"Comment": "attempts to preserve the other layers when syntax highlighting changes. the resultmisplaces some style classes, which is undesirable, but covered up by the subsequentparsing update.",
	"Method": "StyleSpans<Collection<String>> styleSyntaxHighlightChange(Optional<StyleSpans<Collection<String>>> oldSyntax,StyleSpans<Collection<String>> newSyntax){\r\n    StyleSpans<Collection<String>> currentSpans = getStyleSpans(new IndexRange(0, getLength()));\r\n    StyleSpans<Collection<String>> base = oldSyntax.map(s -> subtract(currentSpans, s)).orElse(currentSpans);\r\n    return Optional.ofNullable(newSyntax).map(s -> base.overlay(s, SyntaxHighlightingCodeArea::additiveOverlay)).orElse(base).subView(0, getLength());\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.database.DBURITest.testExplicitSourceCodeTypesList",
	"Comment": "verify that source code types are returned if provided in the dburi.",
	"Method": "void testExplicitSourceCodeTypesList(){\r\n    System.out.println(\"testExplicitSourceCodeTypesList\");\r\n    List<String> defaultSourceCodeTypesList = Arrays.asList(C_EXPLICIT_SOURCE_CODE_TYPES.split(\",\"));\r\n    DBURI instance = new DBURI(C_TEST_EXPLICIT);\r\n    List<String> result = instance.getSourceCodeTypesList();\r\n    assertEquals(defaultSourceCodeTypesList, result);\r\n}"
}, {
	"Path": "com.querydsl.jpa.JPAExpressions.select",
	"Comment": "create a new detached jpqlquery instance with the given projection",
	"Method": "JPQLQuery<T> select(Expression<T> expr,JPQLQuery<Tuple> select,Expression<?> exprs){\r\n    return new JPASubQuery<Void>().select(exprs);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.StringUtil.isSame",
	"Comment": "are the two string values the same. the strings can be optionally trimmedbefore checking. the strings can be optionally compared ignoring case.the strings can be have embedded whitespace standardized beforecomparing. two null values are treated as equal.",
	"Method": "boolean isSame(String s1,String s2,boolean trim,boolean ignoreCase,boolean standardizeWhitespace){\r\n    if (s1 == null && s2 == null) {\r\n        return true;\r\n    } else if (s1 == null || s2 == null) {\r\n        return false;\r\n    } else {\r\n        if (trim) {\r\n            s1 = s1.trim();\r\n            s2 = s2.trim();\r\n        }\r\n        if (standardizeWhitespace) {\r\n            s1 = s1.replaceAll(\"\\\\s+\", \" \");\r\n            s2 = s2.replaceAll(\"\\\\s+\", \" \");\r\n        }\r\n        return ignoreCase ? s1.equalsIgnoreCase(s2) : s1.equals(s2);\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.ast.xpath.AttributeAxisIterator.isAttributeAccessor",
	"Comment": "returns whether the given method is an attribute accessor,in which case a corresponding attribute will be added tothe iterator.",
	"Method": "boolean isAttributeAccessor(Method method){\r\n    String methodName = method.getName();\r\n    return CONSIDERED_RETURN_TYPES.contains(method.getReturnType()) && method.getParameterTypes().length == 0 && !methodName.startsWith(\"jjt\") && !FILTERED_OUT_NAMES.contains(methodName);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.ast.ASTTypeArguments.isDiamond",
	"Comment": "returns true if this is a diamond, that is, theactual type arguments are inferred.",
	"Method": "boolean isDiamond(){\r\n    return jjtGetNumChildren() == 0;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.ParserOptionsTest.testEqualsHashcode",
	"Comment": "verify that the equals and hashcode methods work as expected.",
	"Method": "void testEqualsHashcode(){\r\n    ParserOptions options1 = new ParserOptions();\r\n    options1.setSuppressMarker(\"foo\");\r\n    ParserOptions options2 = new ParserOptions();\r\n    options2.setSuppressMarker(\"bar\");\r\n    ParserOptions options3 = new ParserOptions();\r\n    options3.setSuppressMarker(\"foo\");\r\n    ParserOptions options4 = new ParserOptions();\r\n    options4.setSuppressMarker(\"bar\");\r\n    verifyOptionsEqualsHashcode(options1, options2, options3, options4);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.ast.ASTLocalVariableDeclaration.getTypeNode",
	"Comment": "gets the type node for this variable declaration statement.with java10 and local variable type inference, there might beno type node at all.",
	"Method": "ASTType getTypeNode(){\r\n    return getFirstChildOfType(ASTType.class);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.database.DBURITest.testExplicitCharacterSet",
	"Comment": "verify that characterset are returned if provided in the dburi.",
	"Method": "void testExplicitCharacterSet(){\r\n    System.out.println(\"testExplicitCharacterSet\");\r\n    DBURI instance = new DBURI(C_TEST_EXPLICIT);\r\n    String result = instance.getCharacterSet();\r\n    assertEquals(C_EXPLICIT_CHARACTERSET, result);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.fxdesigner.util.codearea.SyntaxHighlightingCodeArea.setCurrentSyntaxHighlight",
	"Comment": "update the syntax highlighting to the specified value.if null, syntax highlighting is stripped off.",
	"Method": "void setCurrentSyntaxHighlight(StyleSpans<Collection<String>> newSyntax){\r\n    Optional<StyleSpans<Collection<String>>> oldSyntaxHighlight = currentSyntaxHighlight.getOpt();\r\n    this.currentSyntaxHighlight.setValue(newSyntax);\r\n    setStyleSpans(0, styleSyntaxHighlightChange(oldSyntaxHighlight, newSyntax));\r\n}"
}, {
	"Path": "com.querydsl.core.types.PathMetadataFactory.forCollectionAny",
	"Comment": "create a new pathmetadata instance for collection any access",
	"Method": "PathMetadata forCollectionAny(Path<?> parent){\r\n    return new PathMetadata(parent, \"\", PathType.COLLECTION_ANY);\r\n}"
}, {
	"Path": "com.kabouzeid.gramophone.provider.MusicPlaybackQueueStore.saveQueue",
	"Comment": "clears the existing database and saves the queue into the db so that when theapp is restarted, the tracks you were listening to is restored",
	"Method": "void saveQueue(String tableName,ArrayList<Song> queue){\r\n    final SQLiteDatabase database = getWritableDatabase();\r\n    database.beginTransaction();\r\n    try {\r\n        database.delete(tableName, null, null);\r\n        database.setTransactionSuccessful();\r\n    } finally {\r\n        database.endTransaction();\r\n    }\r\n    final int NUM_PROCESS = 20;\r\n    int position = 0;\r\n    while (position < queue.size()) {\r\n        database.beginTransaction();\r\n        try {\r\n            for (int i = position; i < queue.size() && i < position + NUM_PROCESS; i++) {\r\n                Song song = queue.get(i);\r\n                ContentValues values = new ContentValues(4);\r\n                values.put(BaseColumns._ID, song.id);\r\n                values.put(AudioColumns.TITLE, song.title);\r\n                values.put(AudioColumns.TRACK, song.trackNumber);\r\n                values.put(AudioColumns.YEAR, song.year);\r\n                values.put(AudioColumns.DURATION, song.duration);\r\n                values.put(AudioColumns.DATA, song.data);\r\n                values.put(AudioColumns.DATE_MODIFIED, song.dateModified);\r\n                values.put(AudioColumns.ALBUM_ID, song.albumId);\r\n                values.put(AudioColumns.ALBUM, song.albumName);\r\n                values.put(AudioColumns.ARTIST_ID, song.artistId);\r\n                values.put(AudioColumns.ARTIST, song.artistName);\r\n                database.insert(tableName, null, values);\r\n            }\r\n            database.setTransactionSuccessful();\r\n        } finally {\r\n            database.endTransaction();\r\n            position += NUM_PROCESS;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.jsp.ast.AbstractJspNodesTst.getNodes",
	"Comment": "run the jsp parser on the source, and return the nodes of type clazz.",
	"Method": "Set<T> getNodes(Class<T> clazz,String source){\r\n    JspParser parser = new JspParser(new JavaCharStream(new StringReader(source)));\r\n    Node rootNode = parser.CompilationUnit();\r\n    Set<T> nodes = new HashSet();\r\n    addNodeAndSubnodes(rootNode, nodes, clazz);\r\n    return nodes;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.vm.ast.NodeUtils.getSpecialText",
	"Comment": "collect all the s that are carried along with a token.special tokens do not participate in parsing but can still triggercertain lexical actions. in some cases you may want to retrieve thesespecial tokens, this is simply a way to extract them.",
	"Method": "StrBuilder getSpecialText(Token t){\r\n    final StrBuilder sb = new StrBuilder();\r\n    Token tmpToken = t.specialToken;\r\n    while (tmpToken.specialToken != null) {\r\n        tmpToken = tmpToken.specialToken;\r\n    }\r\n    while (tmpToken != null) {\r\n        final String st = tmpToken.image;\r\n        for (int i = 0; i < st.length(); i++) {\r\n            final char c = st.charAt(i);\r\n            if (c == '#' || c == '$') {\r\n                sb.append(c);\r\n            }\r\n            if (c == '\\\\') {\r\n                boolean ok = true;\r\n                boolean term = false;\r\n                int j = i;\r\n                for (ok = true; ok && j < st.length(); j++) {\r\n                    final char cc = st.charAt(j);\r\n                    if (cc == '\\\\') {\r\n                        continue;\r\n                    } else if (cc == '$') {\r\n                        term = true;\r\n                        ok = false;\r\n                    } else {\r\n                        ok = false;\r\n                    }\r\n                }\r\n                if (term) {\r\n                    final String foo = st.substring(i, j);\r\n                    sb.append(foo);\r\n                    i = j;\r\n                }\r\n            }\r\n        }\r\n        tmpToken = tmpToken.next;\r\n    }\r\n    return sb;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.ast.ASTTryStatement.getCatchStatements",
	"Comment": "returns the catch statement nodes of this try statement.if there are none, returns an empty list.",
	"Method": "List<ASTCatchStatement> getCatchStatements(){\r\n    return findChildrenOfType(ASTCatchStatement.class);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.apex.ast.TestAccessEvaluator.setHasRemoteActionPerm",
	"Comment": "it appears that remote action is enabled by default in most orgs, at least test orgs.so we will behave the same.",
	"Method": "TestAccessEvaluator setHasRemoteActionPerm(boolean hasRemoteActionPerm){\r\n    this.hasRemoteActionPerm = hasRemoteActionPerm;\r\n    return this;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.AbstractRuleSetFactoryTest.testDtd",
	"Comment": "verifies that all rulesets are valid xml according to the dtd.",
	"Method": "void testDtd(){\r\n    boolean allValid = true;\r\n    List<String> ruleSetFileNames = getRuleSetFileNames();\r\n    for (String fileName : ruleSetFileNames) {\r\n        boolean valid = validateAgainstDtd(fileName);\r\n        allValid = allValid && valid;\r\n    }\r\n    assertTrue(\"All XML must parse without producing validation messages.\", allValid);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.fxdesigner.util.codearea.NodeStyleSpan.documentOrderComparator",
	"Comment": "returns a comparator that orders spans according to the startindex of the node they wrap.",
	"Method": "Comparator<NodeStyleSpan> documentOrderComparator(){\r\n    return COMPARATOR;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.jsp.ast.JspDocStyleTest.textMultipleClosingTags",
	"Comment": "parser should be able to handle documents which start or end withunparsed text",
	"Method": "void textMultipleClosingTags(){\r\n    Set<ASTText> scripts = getNodes(ASTText.class, TEST_MULTIPLE_CLOSING_TAGS);\r\n    assertEquals(\"Four text chunks expected!\", 4, scripts.size());\r\n    ASTText script = scripts.iterator().next();\r\n    assertEquals(\"Correct content expected!\", \" some text \", script.getImage());\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.vm.ast.ASTReference.setLiteral",
	"Comment": "routine to allow the literal representation to be externally overridden.used now in the vm system to override a reference in a vm tree with theliteral of the calling arg to make it work nicely when calling arg isnull. it seems a bit much, but does keep things consistant.note, you can only set the literal once...",
	"Method": "void setLiteral(String literal){\r\n    if (this.literal == null) {\r\n        this.literal = literal;\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.plsql.symboltable.ScopeAndDeclarationFinder.createMethodScope",
	"Comment": "creates a new method scope for an ast node. the scope on top of the stackis set as the parent of the new scope, which is then also stored on thescope stack.",
	"Method": "void createMethodScope(PLSQLNode node){\r\n    addScope(new MethodScope(node), node);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.ClassUtil.computeClassShortNames",
	"Comment": "return a map of all the short names of classes we maintain mappings for.the names are keyed by the classes themselves.",
	"Method": "Map<Class<?>, String> computeClassShortNames(){\r\n    Map<Class<?>, String> map = new HashMap();\r\n    map.putAll(PRIMITIVE_TYPE_NAMES.asInverseWithShortName());\r\n    map.putAll(TYPES_BY_NAME.asInverseWithShortName());\r\n    return map;\r\n}"
}, {
	"Path": "org.powermock.api.easymock.PowerMock.createMock",
	"Comment": "creates a mock object that supports mocking of final and native methodsand invokes a specific constructor based on the supplied argument values.",
	"Method": "T createMock(Class<T> type,Method methods,T createMock,Class<T> type,T createMock,Class<T> type,ConstructorArgs constructorArgs,Method methods,T createMock,Class<T> type,Object constructorArguments){\r\n    Constructor<?> constructor = WhiteboxImpl.findUniqueConstructorOrThrowException(type, constructorArguments);\r\n    ConstructorArgs constructorArgs = new ConstructorArgs(constructor, constructorArguments);\r\n    return doMock(type, false, new DefaultMockStrategy(), constructorArgs, (Method[]) null);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.xml.XmlParserTest.testParsingIgnoreElementContentWhitespace",
	"Comment": "verifies the parsing behavior of the xml parser if ignoring whitespacesin elements.",
	"Method": "void testParsingIgnoreElementContentWhitespace(){\r\n    LanguageVersionHandler xmlVersionHandler = LanguageRegistry.getLanguage(XmlLanguageModule.NAME).getDefaultVersion().getLanguageVersionHandler();\r\n    XmlParserOptions parserOptions = new XmlParserOptions();\r\n    parserOptions.setIgnoringElementContentWhitespace(true);\r\n    Parser parser = xmlVersionHandler.getParser(parserOptions);\r\n    Node document = parser.parse(null, new StringReader(XML_TEST));\r\n    assertNode(document, \"document\", 2);\r\n    Node dtdElement = document.jjtGetChild(0);\r\n    assertNode(dtdElement, \"rootElement\", 0);\r\n    Node rootElement = document.jjtGetChild(1);\r\n    assertNode(rootElement, \"rootElement\", 3);\r\n    assertNode(rootElement.jjtGetChild(0), \"comment\", 0);\r\n    Node child1 = rootElement.jjtGetChild(1);\r\n    assertNode(child1, \"child1\", 1, \"test\", \"1\");\r\n    assertTextNode(child1.jjtGetChild(0), \"entity: Copyright: PMD\\\\n    \");\r\n    Node child2 = rootElement.jjtGetChild(2);\r\n    assertNode(child2, \"child2\", 3);\r\n    assertTextNode(child2.jjtGetChild(0), \"\\\\n      \");\r\n    assertTextNode(child2.jjtGetChild(1), \" cdata section \", \"cdata-section\");\r\n    assertTextNode(child2.jjtGetChild(2), \"\\\\n    \");\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.ast.ASTFormalParameter.isArray",
	"Comment": "returns true if this formal parameter is of an array type.this includes varargs parameters.",
	"Method": "boolean isArray(){\r\n    return isVarargs() || getTypeNode() != null && getTypeNode().isArray() || getVariableDeclaratorId().isArray();\r\n}"
}, {
	"Path": "org.powermock.core.MockRepository.putAdditionalState",
	"Comment": "when a mock framework api needs to store additional state not applicable\tfor the other methods, it may use this method to do so.",
	"Method": "Object putAdditionalState(String key,Object value){\r\n    return additionalState.put(key, value);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.docs.RuleDocGenerator.generateLanguageIndex",
	"Comment": "writes for each language an index file, which lists the rulesets, the rulesand links to the ruleset pages.",
	"Method": "void generateLanguageIndex(Map<Language, List<RuleSet>> rulesets,Map<Language, List<RuleSet>> sortedAdditionalRulesets){\r\n    for (Map.Entry<Language, List<RuleSet>> entry : rulesets.entrySet()) {\r\n        String languageTersename = entry.getKey().getTerseName();\r\n        String filename = LANGUAGE_INDEX_FILENAME_PATTERN.replace(\"${language.tersename}\", languageTersename);\r\n        Path path = getAbsoluteOutputPath(filename);\r\n        List<String> lines = new LinkedList();\r\n        lines.add(\"---\");\r\n        lines.add(\"title: \" + entry.getKey().getName() + \" Rules\");\r\n        lines.add(\"tags: [rule_references, \" + languageTersename + \"]\");\r\n        lines.add(\"summary: Index of all built-in rules available for \" + entry.getKey().getName());\r\n        lines.add(\"language_name: \" + entry.getKey().getName());\r\n        lines.add(\"permalink: \" + LANGUAGE_INDEX_PERMALINK_PATTERN.replace(\"${language.tersename}\", languageTersename));\r\n        lines.add(\"folder: pmd/rules\");\r\n        lines.add(\"---\");\r\n        lines.add(GENERATED_WARNING_NO_SOURCE);\r\n        for (RuleSet ruleset : entry.getValue()) {\r\n            lines.add(\"## \" + ruleset.getName());\r\n            lines.add(\"\");\r\n            lines.add(\"{% include callout.html content=\\\"\" + getRuleSetDescriptionSingleLine(ruleset) + \"\\\" %}\");\r\n            lines.add(\"\");\r\n            for (Rule rule : getSortedRules(ruleset)) {\r\n                String link = RULESET_INDEX_PERMALINK_PATTERN.replace(\"${language.tersename}\", languageTersename).replace(\"${ruleset.name}\", RuleSetUtils.getRuleSetFilename(ruleset));\r\n                if (rule instanceof RuleReference) {\r\n                    RuleReference ref = (RuleReference) rule;\r\n                    if (ruleset.getFileName().equals(ref.getRuleSetReference().getRuleSetFileName())) {\r\n                        lines.add(\"*   [\" + rule.getName() + \"](\" + link + \"#\" + rule.getName().toLowerCase(Locale.ROOT) + \"): \" + DEPRECATION_LABEL_SMALL + \"The rule has been renamed. Use instead \" + \"[\" + ref.getRule().getName() + \"](\" + link + \"#\" + ref.getRule().getName().toLowerCase(Locale.ROOT) + \").\");\r\n                    } else {\r\n                        String otherLink = RULESET_INDEX_PERMALINK_PATTERN.replace(\"${language.tersename}\", languageTersename).replace(\"${ruleset.name}\", RuleSetUtils.getRuleSetFilename(ref.getRuleSetReference().getRuleSetFileName()));\r\n                        lines.add(\"*   [\" + rule.getName() + \"](\" + link + \"#\" + rule.getName().toLowerCase(Locale.ROOT) + \"): \" + DEPRECATION_LABEL_SMALL + \"The rule has been moved to another ruleset. Use instead \" + \"[\" + ref.getRule().getName() + \"](\" + otherLink + \"#\" + ref.getRule().getName().toLowerCase(Locale.ROOT) + \").\");\r\n                    }\r\n                } else {\r\n                    link += \"#\" + rule.getName().toLowerCase(Locale.ROOT);\r\n                    lines.add(\"*   [\" + rule.getName() + \"](\" + link + \"): \" + (rule.isDeprecated() ? DEPRECATION_LABEL_SMALL : \"\") + getShortRuleDescription(rule));\r\n                }\r\n            }\r\n            lines.add(\"\");\r\n        }\r\n        List<RuleSet> additionalRulesetsForLanguage = sortedAdditionalRulesets.get(entry.getKey());\r\n        if (additionalRulesetsForLanguage != null) {\r\n            lines.add(\"## Additional rulesets\");\r\n            lines.add(\"\");\r\n            for (RuleSet ruleset : additionalRulesetsForLanguage) {\r\n                boolean deprecated = RuleSetUtils.isRuleSetDeprecated(ruleset);\r\n                String rulesetName = ruleset.getName() + \" (`\" + RuleSetUtils.getRuleSetClasspath(ruleset) + \"`)\";\r\n                if (!deprecated) {\r\n                    lines.add(\"*   \" + rulesetName + \":\");\r\n                    lines.add(\"\");\r\n                    lines.add(\"    \" + getRuleSetDescriptionSingleLine(ruleset));\r\n                    lines.add(\"\");\r\n                } else {\r\n                    lines.add(\"*   \" + rulesetName + \":\");\r\n                    lines.add(\"\");\r\n                    lines.add(\"    \" + DEPRECATION_LABEL_SMALL + \" This ruleset is for backwards compatibility.\");\r\n                    lines.add(\"\");\r\n                }\r\n                lines.add(\"    It contains the following rules:\");\r\n                lines.add(\"\");\r\n                StringBuilder rules = new StringBuilder();\r\n                for (Rule rule : getSortedRules(ruleset)) {\r\n                    if (rules.length() == 0) {\r\n                        rules.append(\"    \");\r\n                    } else {\r\n                        rules.append(\", \");\r\n                    }\r\n                    Rule resolvedRule = RuleSetUtils.resolveRuleReferences(rule);\r\n                    if (resolvedRule instanceof RuleReference) {\r\n                        RuleReference ref = (RuleReference) resolvedRule;\r\n                        String otherLink = RULESET_INDEX_PERMALINK_PATTERN.replace(\"${language.tersename}\", languageTersename).replace(\"${ruleset.name}\", RuleSetUtils.getRuleSetFilename(ref.getRuleSetReference().getRuleSetFileName()));\r\n                        rules.append(\"[\").append(ref.getName()).append(\"](\");\r\n                        rules.append(otherLink).append(\"#\").append(ref.getRule().getName().toLowerCase(Locale.ROOT)).append(\")\");\r\n                    } else {\r\n                        rules.append(rule.getName());\r\n                    }\r\n                }\r\n                lines.add(rules.toString());\r\n                lines.add(\"\");\r\n            }\r\n            lines.add(\"\");\r\n        }\r\n        System.out.println(\"Generated \" + path);\r\n        writer.write(path, lines);\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.RuleSet.applies",
	"Comment": "does the given rule apply to the given languageversion? if so, thelanguage must be the same and be between the minimum and maximumsversions on the rule.",
	"Method": "boolean applies(File file,boolean applies,Rule rule,LanguageVersion languageVersion){\r\n    final LanguageVersion min = rule.getMinimumLanguageVersion();\r\n    final LanguageVersion max = rule.getMaximumLanguageVersion();\r\n    return rule.getLanguage().equals(languageVersion.getLanguage()) && (min == null || min.compareTo(languageVersion) <= 0) && (max == null || max.compareTo(languageVersion) >= 0);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.ast.ASTTypeParameter.getParameterName",
	"Comment": "returns the name of the type variable introduced by this declaration.",
	"Method": "String getParameterName(){\r\n    return getImage();\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.symboltable.ScopeAndDeclarationFinder.createSourceFileScope",
	"Comment": "creates a new global scope for an ast node. the new scope is stored onthe scope stack.",
	"Method": "void createSourceFileScope(ASTCompilationUnit node){\r\n    SourceFileScope scope;\r\n    ASTPackageDeclaration n = node.getPackageDeclaration();\r\n    if (n != null) {\r\n        scope = new SourceFileScope(classLoader, n.jjtGetChild(0).getImage());\r\n    } else {\r\n        scope = new SourceFileScope(classLoader);\r\n    }\r\n    scope.configureImports(node.findChildrenOfType(ASTImportDeclaration.class));\r\n    scopes.push(scope);\r\n    node.setScope(scope);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.vf.ast.AbstractVfNodesTest.getNodesOfType",
	"Comment": "return a subset of allnodes, containing the items in allnodes that are ofthe given type.",
	"Method": "Set<T> getNodesOfType(Class<T> clazz,Set<VfNode> allNodes){\r\n    Set<T> result = new HashSet();\r\n    for (Node node : allNodes) {\r\n        if (clazz.equals(node.getClass())) {\r\n            result.add((T) node);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.bestpractices.GuardLogStatementRule.getFirstChild",
	"Comment": "gets the first child, first grand child, ... of the given types.the children must follow the given order of types",
	"Method": "N getFirstChild(Node root,Class<? extends Node> childrenTypes){\r\n    Node current = root;\r\n    for (Class<? extends Node> clazz : childrenTypes) {\r\n        Node child = current.getFirstChildOfType(clazz);\r\n        if (child != null) {\r\n            current = child;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n    @SuppressWarnings(\"unchecked\")\r\n    N result = (N) current;\r\n    return result;\r\n}"
}, {
	"Path": "org.powermock.reflect.Whitebox.getAllInstanceFields",
	"Comment": "get all instance fields for a particular object. it returns all fields\tregardless of the field modifier and regardless of where in the class\thierarchy a field is located.",
	"Method": "Set<Field> getAllInstanceFields(Object object){\r\n    return WhiteboxImpl.getAllInstanceFields(object);\r\n}"
}, {
	"Path": "org.powermock.api.easymock.PowerMock.createNicePartialMockForAllMethodsExcept",
	"Comment": "mock all methods of a class except for a specific one nicely. use thismethod only if you have several overloaded methods.",
	"Method": "T createNicePartialMockForAllMethodsExcept(Class<T> type,String methodNames,T createNicePartialMockForAllMethodsExcept,Class<T> type,String methodNameToExclude,Class<?> firstArgumentType,Class<?> moreTypes){\r\n    final Class<?>[] argumentTypes = mergeArgumentTypes(firstArgumentType, moreTypes);\r\n    return createNiceMock(type, WhiteboxImpl.getAllMethodsExcept(type, methodNameToExclude, argumentTypes));\r\n}"
}, {
	"Path": "net.sourceforge.pmd.typeresolution.ClassTypeResolverTest.selectNodes",
	"Comment": "this is the master overload, others just default the parameters",
	"Method": "List<T> selectNodes(String source,Class<T> resultType,String xpath,List<T> selectNodes,String source,String version,Class<T> resultType,String xpath,List<T> selectNodes,Class<?> source,Class<T> resultType,List<T> selectNodes,Class<?> source,Class<T> resultType,String xpath,List<T> selectNodes,Class<?> source,String version,Class<T> resultType,String xpath){\r\n    return selectNodes(ParserTstUtil.getSourceFromClass(source), version, resultType, xpath);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.StringUtil.toCamelCase",
	"Comment": "converts the given string to camel case,that is, removing all spaces, and capitalisingthe first letter of each word except the first.the second parameter can be used to force thewords to be converted to lowercase before capitalising.this can be useful if eg the first word containsseveral uppercase letters.",
	"Method": "String toCamelCase(String name,String toCamelCase,String name,boolean forceLowerCase){\r\n    StringBuilder sb = new StringBuilder();\r\n    boolean isFirst = true;\r\n    for (String word : name.trim().split(\"\\\\s++\")) {\r\n        String pretreated = forceLowerCase ? word.toLowerCase(Locale.ROOT) : word;\r\n        if (isFirst) {\r\n            sb.append(pretreated);\r\n            isFirst = false;\r\n        } else {\r\n            sb.append(StringUtils.capitalize(pretreated));\r\n        }\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.kabouzeid.gramophone.service.MultiPlayer.release",
	"Comment": "releases resources associated with this mediaplayer object.",
	"Method": "void release(){\r\n    stop();\r\n    mCurrentMediaPlayer.release();\r\n    if (mNextMediaPlayer != null) {\r\n        mNextMediaPlayer.release();\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.design.AbstractNcssCountRule.countNodeChildren",
	"Comment": "count the number of children of the given java node. adds one to countthe node itself.",
	"Method": "Integer countNodeChildren(Node node,Object data){\r\n    Integer nodeCount = null;\r\n    int lineCount = 0;\r\n    for (int i = 0; i < node.jjtGetNumChildren(); i++) {\r\n        nodeCount = (Integer) ((JavaNode) node.jjtGetChild(i)).jjtAccept(this, data);\r\n        lineCount += nodeCount.intValue();\r\n    }\r\n    return ++lineCount;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.JavaRuleViolationTest.testMethodName",
	"Comment": "tests that the method name is taken correctly from the given node.",
	"Method": "void testMethodName(){\r\n    ASTCompilationUnit ast = parse(\"class Foo { void bar(int x) {} }\");\r\n    ASTMethodDeclaration md = ast.getFirstDescendantOfType(ASTMethodDeclaration.class);\r\n    final RuleContext context = new RuleContext();\r\n    final JavaRuleViolation violation = new JavaRuleViolation(null, context, md, null);\r\n    assertEquals(\"bar\", violation.getMethodName());\r\n}"
}, {
	"Path": "com.querydsl.core.types.Projections.list",
	"Comment": "create a new list typed projection for the given expressions",
	"Method": "QList list(Expression<?> args,QList list,ImmutableList<Expression<?>> args,QList list,Expression<?>[] args){\r\n    return new QList(args);\r\n}"
}, {
	"Path": "samples.suppressconstructor.SuppressConstructorHierarchy.getNumber",
	"Comment": "this method is just here to check if it works to execute several tests\twith the same test suite class loader.",
	"Method": "int getNumber(){\r\n    return 42;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.properties.AbstractPropertySource.checkValidPropertyDescriptor",
	"Comment": "checks whether this property descriptor is defined for this property source.",
	"Method": "void checkValidPropertyDescriptor(PropertyDescriptor<?> propertyDescriptor){\r\n    if (!hasDescriptor(propertyDescriptor)) {\r\n        throw new IllegalArgumentException(\"Property descriptor not defined for \" + getPropertySourceType() + \" \" + getName() + \": \" + propertyDescriptor);\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.errorprone.ConstructorCallsOverridableMethodRule.visit",
	"Comment": "create a methodholder to hold the method. store the methodholder in themap as the key store each method called by the current method as a listin the map as the object",
	"Method": "Object visit(ASTCompilationUnit node,Object data,Object visit,ASTEnumDeclaration node,Object data,Object visit,ASTClassOrInterfaceDeclaration node,Object data,Object visit,ASTConstructorDeclaration node,Object data,Object visit,ASTMethodDeclarator node,Object data){\r\n    if (!(getCurrentEvalPackage() instanceof NullEvalPackage)) {\r\n        AccessNode parent = (AccessNode) node.jjtGetParent();\r\n        MethodHolder h = new MethodHolder(node);\r\n        if (!parent.isAbstract() && !parent.isPrivate() && !parent.isStatic() && !parent.isFinal()) {\r\n            h.setDangerous();\r\n            ASTMethodDeclaration decl = node.getFirstParentOfType(ASTMethodDeclaration.class);\r\n            h.setCalledMethod(decl.getMethodName());\r\n        }\r\n        List<MethodInvocation> l = new ArrayList();\r\n        addCalledMethodsOfNode(parent, l, getCurrentEvalPackage().className);\r\n        getCurrentEvalPackage().allMethodsOfClass.put(h, l);\r\n    }\r\n    return super.visit(node, data);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.xml.XmlParserTest.testParsingIgnoreComments",
	"Comment": "verifies the parsing behavior of the xml parser if ignoring comments.",
	"Method": "void testParsingIgnoreComments(){\r\n    LanguageVersionHandler xmlVersionHandler = LanguageRegistry.getLanguage(XmlLanguageModule.NAME).getDefaultVersion().getLanguageVersionHandler();\r\n    XmlParserOptions parserOptions = new XmlParserOptions();\r\n    parserOptions.setIgnoringComments(true);\r\n    Parser parser = xmlVersionHandler.getParser(parserOptions);\r\n    Node document = parser.parse(null, new StringReader(XML_TEST));\r\n    assertNode(document, \"document\", 2);\r\n    Node dtdElement = document.jjtGetChild(0);\r\n    assertNode(dtdElement, \"rootElement\", 0);\r\n    Node rootElement = document.jjtGetChild(1);\r\n    assertNode(rootElement, \"rootElement\", 5);\r\n    assertTextNode(rootElement.jjtGetChild(0), \"\\\\n    \\\\n    \");\r\n    Node child1 = rootElement.jjtGetChild(1);\r\n    assertNode(child1, \"child1\", 1, \"test\", \"1\");\r\n    assertTextNode(child1.jjtGetChild(0), \"entity: Copyright: PMD\\\\n    \");\r\n    assertTextNode(rootElement.jjtGetChild(2), \"\\\\n    \");\r\n    Node child2 = rootElement.jjtGetChild(3);\r\n    assertNode(child2, \"child2\", 3);\r\n    assertTextNode(child2.jjtGetChild(0), \"\\\\n      \");\r\n    assertTextNode(child2.jjtGetChild(1), \" cdata section \", \"cdata-section\");\r\n    assertTextNode(child2.jjtGetChild(2), \"\\\\n    \");\r\n    assertTextNode(rootElement.jjtGetChild(4), \"\\\\n\");\r\n}"
}, {
	"Path": "org.powermock.core.MockRepository.addObjectsToAutomaticallyReplayAndVerify",
	"Comment": "add classes that should be automatically replayed or verified.",
	"Method": "void addObjectsToAutomaticallyReplayAndVerify(Object objects){\r\n    Collections.addAll(objectsToAutomaticallyReplayAndVerify, objects);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.jsp.ast.JspDocStyleTest.testComplexHtmlScript",
	"Comment": "a complex script containing html comments, escapes, quotes, etc.",
	"Method": "void testComplexHtmlScript(){\r\n    Set<ASTHtmlScript> script = getNodes(ASTHtmlScript.class, TEST_COMPLEX_SCRIPT);\r\n    assertEquals(\"One script expected!\", 1, script.size());\r\n    ASTHtmlScript next = script.iterator().next();\r\n    assertTrue(next.getImage().contains(\"<!--\"));\r\n    Set<ASTCommentTag> comments = getNodes(ASTCommentTag.class, TEST_COMPLEX_SCRIPT);\r\n    assertEquals(\"One comment expected!\", 1, comments.size());\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.ast.ASTBlockStatement.isAllocation",
	"Comment": "tells if this blockstatement is an allocation statement. this is done by",
	"Method": "boolean isAllocation(){\r\n    return hasDescendantOfType(ASTAllocationExpression.class);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.security.HardCodedCryptoKeyRule.validateProperKeyArgument",
	"Comment": "recursively resolves the argument again, if the variable initializeris itself a expression.then checks the expression for being a string literal or array",
	"Method": "void validateProperKeyArgument(Object data,ASTPrimaryPrefix firstArgumentExpression){\r\n    if (firstArgumentExpression == null) {\r\n        return;\r\n    }\r\n    ASTName namedVar = firstArgumentExpression.getFirstDescendantOfType(ASTName.class);\r\n    if (namedVar != null) {\r\n        if (namedVar != null && namedVar.getNameDeclaration() instanceof VariableNameDeclaration) {\r\n            VariableNameDeclaration varDecl = (VariableNameDeclaration) namedVar.getNameDeclaration();\r\n            ASTVariableInitializer initializer = varDecl.getAccessNodeParent().getFirstDescendantOfType(ASTVariableInitializer.class);\r\n            if (initializer != null) {\r\n                validateProperKeyArgument(data, initializer.getFirstDescendantOfType(ASTPrimaryPrefix.class));\r\n            }\r\n        }\r\n    }\r\n    ASTArrayInitializer arrayInit = firstArgumentExpression.getFirstDescendantOfType(ASTArrayInitializer.class);\r\n    if (arrayInit != null) {\r\n        addViolation(data, arrayInit);\r\n    }\r\n    ASTLiteral literal = firstArgumentExpression.getFirstDescendantOfType(ASTLiteral.class);\r\n    if (literal != null && literal.isStringLiteral()) {\r\n        addViolation(data, literal);\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.fxdesigner.util.codearea.HighlightLayerCodeArea.recomputePainting",
	"Comment": "recomputes a single style spans from the syntax highlighting layer and nodes to highlight.",
	"Method": "StyleSpans<Collection<String>> recomputePainting(){\r\n    List<StyleSpans<Collection<String>>> allSpans = layersById.values().stream().flatMap(layer -> layer.getCollections().stream()).filter(c -> !c.isEmpty()).map(UniformStyleCollection::toSpans).collect(Collectors.toList());\r\n    if (allSpans.isEmpty()) {\r\n        return syntaxHighlight.getOrElse(emptySpan());\r\n    }\r\n    if (syntaxHighlight.getOpt().map(StyleSpans::length).filter(l -> l != getLength()).isPresent()) {\r\n        updateSyntaxHighlightingSynchronously();\r\n    }\r\n    syntaxHighlight.ifPresent(allSpans::add);\r\n    final StyleSpans<Collection<String>> base = allSpans.get(0);\r\n    return allSpans.stream().filter(spans -> spans != base).filter(spans -> spans.length() <= getLength()).reduce(base, (accumulator, elt) -> accumulator.overlay(elt, SyntaxHighlightingCodeArea::additiveOverlay));\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.ast.AbstractNode.hasDecendantOfAnyType",
	"Comment": "returns true if this node has a descendant of any type among the provided types.",
	"Method": "boolean hasDecendantOfAnyType(Class<?> types){\r\n    return hasDescendantOfAnyType(types);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.properties.modules.NumericPropertyModule.rangeString",
	"Comment": "returns a string representing the range defined by the two bounds.",
	"Method": "String rangeString(Number low,Number up){\r\n    return \"(\" + low + \" -> \" + up + \")\";\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.vm.util.VelocityCharStream.adjustBeginLineColumn",
	"Comment": "method to adjust line and column numbers for the start of a token.",
	"Method": "void adjustBeginLineColumn(int newLine,int newCol){\r\n    int start = tokenBegin;\r\n    int len;\r\n    if (bufpos >= tokenBegin) {\r\n        len = bufpos - tokenBegin + inBuf + 1;\r\n    } else {\r\n        len = bufsize - tokenBegin + bufpos + 1 + inBuf;\r\n    }\r\n    int i = 0;\r\n    int j = start % bufsize;\r\n    int k = (start + 1) % bufsize;\r\n    int nextColDiff = 0;\r\n    int columnDiff = 0;\r\n    while (i < len && bufline[j] == bufline[k]) {\r\n        bufline[j] = newLine;\r\n        nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];\r\n        bufcolumn[j] = newCol + columnDiff;\r\n        columnDiff = nextColDiff;\r\n        i++;\r\n        start++;\r\n        j = start % bufsize;\r\n        k = (start + 1) % bufsize;\r\n    }\r\n    if (i < len) {\r\n        bufline[j] = newLine++;\r\n        bufcolumn[j] = newCol + columnDiff;\r\n        while (i++ < len) {\r\n            j = start % bufsize;\r\n            start++;\r\n            if (bufline[j] != bufline[start % bufsize]) {\r\n                bufline[j] = newLine++;\r\n            } else {\r\n                bufline[j] = newLine;\r\n            }\r\n        }\r\n    }\r\n    line = bufline[j];\r\n    column = bufcolumn[j];\r\n}"
}, {
	"Path": "com.querydsl.jpa.hibernate.AbstractHibernateQuery.setFlushMode",
	"Comment": "override the current session flush mode, just for this query.",
	"Method": "Q setFlushMode(FlushMode flushMode){\r\n    this.flushMode = flushMode;\r\n    return (Q) this;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.bestpractices.ForLoopCanBeForeachRule.indexStartsAtZero",
	"Comment": "we only report loops with int initializers starting at zero.",
	"Method": "boolean indexStartsAtZero(VariableNameDeclaration index){\r\n    ASTVariableDeclaratorId name = (ASTVariableDeclaratorId) index.getNode();\r\n    ASTVariableDeclarator declarator = name.getFirstParentOfType(ASTVariableDeclarator.class);\r\n    if (declarator == null) {\r\n        return false;\r\n    }\r\n    try {\r\n        List<Node> zeroLiteral = declarator.findChildNodesWithXPath(\"./VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Literal[@Image='0' and \" + \"@StringLiteral='false']\");\r\n        if (!zeroLiteral.isEmpty()) {\r\n            return true;\r\n        }\r\n    } catch (JaxenException je) {\r\n        throw new RuntimeException(je);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.RuleSetReferenceId.isAllRules",
	"Comment": "is this a reference to all rules in a ruleset, or a single rule?",
	"Method": "boolean isAllRules(){\r\n    return allRules;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.AbstractPoorMethodCall.isNotedMethod",
	"Comment": "returns whether the name occurrence is one of the method calls we areinterested in.",
	"Method": "boolean isNotedMethod(NameOccurrence occurrence){\r\n    if (occurrence == null) {\r\n        return false;\r\n    }\r\n    String methodCall = occurrence.getImage();\r\n    String[] methodNames = methodNames();\r\n    for (String element : methodNames) {\r\n        if (methodCall.indexOf(element) != -1) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.StringUtil.escapeWhitespace",
	"Comment": "replace some whitespace characters so they are visually apparent.",
	"Method": "String escapeWhitespace(Object o){\r\n    if (o == null) {\r\n        return null;\r\n    }\r\n    String s = String.valueOf(o);\r\n    s = s.replace(\"\\n\", \"\\\\n\");\r\n    s = s.replace(\"\\r\", \"\\\\r\");\r\n    s = s.replace(\"\\t\", \"\\\\t\");\r\n    return s;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.fxdesigner.model.ASTManager.updateIfChanged",
	"Comment": "refreshes the compilation unit given the current parameters of the model.",
	"Method": "Optional<Node> updateIfChanged(String source,ClassLoader classLoader){\r\n    if (compilationUnit.isPresent() && getLanguageVersion().equals(lastLanguageVersion) && StringUtils.equals(source, lastValidSource)) {\r\n        return getCompilationUnit();\r\n    }\r\n    LanguageVersionHandler languageVersionHandler = getLanguageVersion().getLanguageVersionHandler();\r\n    Parser parser = languageVersionHandler.getParser(languageVersionHandler.getDefaultParserOptions());\r\n    Node node;\r\n    try {\r\n        node = parser.parse(null, new StringReader(source));\r\n    } catch (Exception e) {\r\n        designerRoot.getLogger().logEvent(new LogEntry(e, Category.PARSE_EXCEPTION));\r\n        compilationUnit.setValue(null);\r\n        throw new ParseAbortedException(e);\r\n    }\r\n    try {\r\n        languageVersionHandler.getSymbolFacade().start(node);\r\n    } catch (Exception e) {\r\n        designerRoot.getLogger().logEvent(new LogEntry(e, Category.SYMBOL_FACADE_EXCEPTION));\r\n    }\r\n    try {\r\n        languageVersionHandler.getQualifiedNameResolutionFacade(classLoader).start(node);\r\n    } catch (Exception e) {\r\n        designerRoot.getLogger().logEvent(new LogEntry(e, Category.QUALIFIED_NAME_RESOLUTION_EXCEPTION));\r\n    }\r\n    try {\r\n        languageVersionHandler.getTypeResolutionFacade(classLoader).start(node);\r\n    } catch (Exception e) {\r\n        designerRoot.getLogger().logEvent(new LogEntry(e, Category.TYPERESOLUTION_EXCEPTION));\r\n    }\r\n    compilationUnit.setValue(node);\r\n    lastValidSource = source;\r\n    lastLanguageVersion = getLanguageVersion();\r\n    return getCompilationUnit();\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.typeresolution.MethodTypeResolution.getApplicableMethods",
	"Comment": "looks for potentially applicable methods in a given type definition.",
	"Method": "List<MethodType> getApplicableMethods(JavaTypeDefinition context,String methodName,List<JavaTypeDefinition> typeArguments,int argArity,Class<?> accessingClass){\r\n    List<MethodType> result = new ArrayList();\r\n    if (context == null) {\r\n        return result;\r\n    }\r\n    Class<?> contextClass = context.getType();\r\n    try {\r\n        for (Method method : contextClass.getDeclaredMethods()) {\r\n            if (isMethodApplicable(method, methodName, argArity, accessingClass, typeArguments)) {\r\n                result.add(getTypeDefOfMethod(context, method, typeArguments));\r\n            }\r\n        }\r\n    } catch (final LinkageError ignored) {\r\n    }\r\n    if (!contextClass.equals(Object.class)) {\r\n        List<MethodType> inheritedMethods = getApplicableMethods(context.resolveTypeDefinition(contextClass.getGenericSuperclass()), methodName, typeArguments, argArity, accessingClass);\r\n        for (MethodType inherited : inheritedMethods) {\r\n            if (!result.contains(inherited)) {\r\n                result.add(inherited);\r\n            }\r\n        }\r\n    }\r\n    for (Type interfaceType : contextClass.getGenericInterfaces()) {\r\n        result.addAll(getApplicableMethods(context.resolveTypeDefinition(interfaceType), methodName, typeArguments, argArity, accessingClass));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.ast.ASTCatchStatement.getCaughtExceptionTypeNodes",
	"Comment": "returns the list of type nodes denoting the exception typescaught by this catch block. the returned list has at leastone element.",
	"Method": "List<ASTType> getCaughtExceptionTypeNodes(){\r\n    return getFirstChildOfType(ASTFormalParameter.class).findChildrenOfType(ASTType.class);\r\n}"
}, {
	"Path": "com.querydsl.codegen.GenericExporter.addAnnotationHelper",
	"Comment": "add a annotation helper object to process custom annotations",
	"Method": "void addAnnotationHelper(AnnotationHelper annotationHelper){\r\n    annotationHelpers.add(annotationHelper);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.RulesetsFactoryUtils.getRuleSets",
	"Comment": "creates a new rulesets with the given string. the resulting rulesets willcontain all referenced rulesets.",
	"Method": "RuleSets getRuleSets(String rulesets,RuleSetFactory factory){\r\n    RuleSets ruleSets = null;\r\n    try {\r\n        ruleSets = factory.createRuleSets(rulesets);\r\n        printRuleNamesInDebug(ruleSets);\r\n        if (ruleSets.ruleCount() == 0) {\r\n            String msg = \"No rules found. Maybe you mispelled a rule name? (\" + rulesets + ')';\r\n            LOG.log(Level.SEVERE, msg);\r\n            throw new IllegalArgumentException(msg);\r\n        }\r\n    } catch (RuleSetNotFoundException rsnfe) {\r\n        LOG.log(Level.SEVERE, \"Ruleset not found\", rsnfe);\r\n        throw new IllegalArgumentException(rsnfe);\r\n    }\r\n    return ruleSets;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.fxdesigner.util.codearea.SyntaxHighlightingCodeArea.setSyntaxHighlighter",
	"Comment": "enables syntax highlighting if disabled and sets it to use the given highlighter.if the argument is null, then this method disables syntax highlighting.",
	"Method": "void setSyntaxHighlighter(SyntaxHighlighter highlighter){\r\n    if (Objects.equals(highlighter, syntaxHighlighter.getValue())) {\r\n        return;\r\n    }\r\n    syntaxHighlighter.ifPresent(previous -> getStyleClass().remove(\".\" + previous.getLanguageTerseName()));\r\n    syntaxAutoRefresh.ifPresent(Subscription::unsubscribe);\r\n    if (highlighter == null) {\r\n        syntaxAutoRefresh.setValue(null);\r\n        this.setCurrentSyntaxHighlight(null);\r\n        return;\r\n    }\r\n    syntaxHighlighter.setValue(highlighter);\r\n    getStyleClass().add(\".\" + highlighter.getLanguageTerseName());\r\n    syntaxAutoRefresh.setValue(subscribeSyntaxHighlighting(defaultHighlightingTicks(), highlighter));\r\n    try {\r\n        Task<StyleSpans<Collection<String>>> t = computeHighlightingAsync(Executors.newSingleThreadExecutor(), highlighter, getText());\r\n        t.setOnSucceeded(e -> this.setCurrentSyntaxHighlight(t.getValue()));\r\n    } catch (Exception ignored) {\r\n    }\r\n}"
}, {
	"Path": "org.powermock.reflect.Whitebox.getInternalState",
	"Comment": "get the value of a field using reflection based on the field type. use\tthis method when you need to specify in which class the field is\tdeclared. the first field matching the fieldtype in\twhere is the field whose value will be returned.",
	"Method": "T getInternalState(Object object,String fieldName,T getInternalState,Object object,String fieldName,Class<?> where,T getInternalState,Object object,String fieldName,Class<?> where,Class<T> type,T getInternalState,Object object,Class<T> fieldType,T getInternalState,Object object,Class<T> fieldType,Class<?> where){\r\n    return WhiteboxImpl.getInternalState(object, fieldType, where);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.ast.AbstractNode.hasDescendantOfAnyType",
	"Comment": "returns true if this node has a descendant of any type among the provided types.",
	"Method": "boolean hasDescendantOfAnyType(Class<?> types){\r\n    for (Class<?> type : types) {\r\n        if (hasDescendantOfType(type)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.vm.directive.Stop.isScopeProvided",
	"Comment": "since there is no processing of content, there is never a need for aninternal scope.",
	"Method": "boolean isScopeProvided(){\r\n    return false;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.typeresolution.PMDASMClassLoaderTest.testCachingMemoryConsumption",
	"Comment": "with this test you can verify, how much memory could be consumed by thedontbother cache.",
	"Method": "void testCachingMemoryConsumption(){\r\n    MockedClassLoader mockedClassLoader = new MockedClassLoader();\r\n    PMDASMClassLoader cl = PMDASMClassLoader.getInstance(mockedClassLoader);\r\n    Runtime runtime = Runtime.getRuntime();\r\n    System.gc();\r\n    long usedBytesBefore = runtime.totalMemory() - runtime.freeMemory();\r\n    for (long i = 0; i < 3000; i++) {\r\n        try {\r\n            cl.loadClass(\"com.very.long.package.name.and.structure.MyClass\" + i);\r\n        } catch (ClassNotFoundException e) {\r\n        }\r\n    }\r\n    long usedBytesAfter = runtime.totalMemory() - runtime.freeMemory();\r\n    System.out.println((usedBytesAfter - usedBytesBefore) / (1024.0 * 1024.0) + \" mb needed\");\r\n}"
}, {
	"Path": "com.querydsl.core.alias.Alias.alias",
	"Comment": "create a new alias proxy of the given type for the given variable",
	"Method": "A alias(Class<A> cl,A alias,Class<A> cl,Expression<? extends A> expr,A alias,Class<A> cl,String var){\r\n    return aliasFactory.createAliasForVariable(cl, var);\r\n}"
}, {
	"Path": "com.querydsl.core.types.Projections.appending",
	"Comment": "create an appending factory expression which serializes all the arguments but the usesthe base value as the return value",
	"Method": "AppendingFactoryExpression<T> appending(Expression<T> base,Expression<?> rest){\r\n    return new AppendingFactoryExpression<T>(base, rest);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.codestyle.PrematureDeclarationRule.hasExit",
	"Comment": "returns whether the block contains a return call or throws an exception.exclude blocks that have these things as part of an inner class.",
	"Method": "boolean hasExit(ASTBlockStatement block){\r\n    return block.hasDescendantOfAnyType(ASTThrowStatement.class, ASTReturnStatement.class);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.ClassUtil.asMethodGroupsByTypeName",
	"Comment": "return the methods as a map keyed by their common declaration types.",
	"Method": "Map<String, List<Method>> asMethodGroupsByTypeName(Method[] methods,Map<String, List<Method>> asMethodGroupsByTypeName,List<Method> methods){\r\n    Map<String, List<Method>> methodGroups = new HashMap(methods.size());\r\n    for (Method m : methods) {\r\n        String clsName = asShortestName(m.getDeclaringClass());\r\n        if (!methodGroups.containsKey(clsName)) {\r\n            methodGroups.put(clsName, new ArrayList<Method>());\r\n        }\r\n        methodGroups.get(clsName).add(m);\r\n    }\r\n    return methodGroups;\r\n}"
}, {
	"Path": "org.powermock.modules.testng.internal.TestClassInstanceFactory.createTestClass",
	"Comment": "we proxy the test class in order to be able to clear state after eachtest method invocation. it would be much better to be able to register atestng listener programmtically but i cannot find a way to do so.",
	"Method": "Class<?> createTestClass(Class<?> actualTestClass){\r\n    final Class<?> testClassLoadedByMockedClassLoader = Class.forName(actualTestClass.getName(), false, mockLoader);\r\n    if (extendsPowerMockTestCase(actualTestClass)) {\r\n        return testClassLoadedByMockedClassLoader;\r\n    } else {\r\n        return createProxyTestClass(testClassLoadedByMockedClassLoader);\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.ecmascript.ast.ASTName.isFunctionNodeParameter",
	"Comment": "returns whether this name node is the name of a function declarationparameter.",
	"Method": "boolean isFunctionNodeParameter(){\r\n    if (jjtGetParent() instanceof ASTFunctionNode) {\r\n        ASTFunctionNode functionNode = (ASTFunctionNode) jjtGetParent();\r\n        for (int i = 0; i < functionNode.getNumParams(); i++) {\r\n            if (functionNode.getParam(i) == this) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.TypeMap.storeShortest",
	"Comment": "store the shorter of the incoming value or the existing value in the mapat the key specified.",
	"Method": "void storeShortest(Map<Class<?>, String> map,Class<?> key,String value){\r\n    String existingValue = map.get(key);\r\n    if (existingValue == null) {\r\n        map.put(key, value);\r\n        return;\r\n    }\r\n    if (existingValue.length() < value.length()) {\r\n        return;\r\n    }\r\n    map.put(key, value);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.database.DBURITest.testDefaultCharacterSet",
	"Comment": "verify that default characterset are returned if non are provided in thedburi.",
	"Method": "void testDefaultCharacterSet(){\r\n    System.out.println(\"testDefaultCharacterSet\");\r\n    DBURI instance = new DBURI(C_TEST_DEFAULTS);\r\n    String result = instance.getCharacterSet();\r\n    assertEquals(C_DEFAULT_CHARACTERSET, result);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.properties.modules.MethodPropertyModule.asStringOn",
	"Comment": "serializes the method signature onto the specified buffer.",
	"Method": "void asStringOn(Method method,StringBuilder sb){\r\n    Class<?> clazz = method.getDeclaringClass();\r\n    sb.append(shortestNameFor(clazz));\r\n    sb.append(CLASS_METHOD_DELIMITER);\r\n    sb.append(method.getName());\r\n    sb.append(METHOD_GROUP_DELIMITERS[0]);\r\n    Class<?>[] argTypes = method.getParameterTypes();\r\n    if (argTypes.length == 0) {\r\n        sb.append(METHOD_GROUP_DELIMITERS[1]);\r\n        return;\r\n    }\r\n    serializedTypeIdOn(argTypes[0], sb);\r\n    for (int i = 1; i < argTypes.length; i++) {\r\n        sb.append(METHOD_ARG_DELIMITER);\r\n        serializedTypeIdOn(argTypes[i], sb);\r\n    }\r\n    sb.append(METHOD_GROUP_DELIMITERS[1]);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.vm.ast.ASTStringLiteral.adjTokenLineNums",
	"Comment": "adjust all the line and column numbers that comprise a node so that theyare corrected for the string literals position within the template file.this is neccessary if an exception is thrown while processing the node sothat the line and column position reported reflects the error positionwithin the template and not just relative to the error position withinthe string literal.",
	"Method": "void adjTokenLineNums(AbstractVmNode node){\r\n    Token tok = node.getFirstToken();\r\n    while (tok != null && tok != node.getLastToken()) {\r\n        if (tok.beginLine == 1) {\r\n            tok.beginColumn += getColumn();\r\n        }\r\n        if (tok.endLine == 1) {\r\n            tok.endColumn += getColumn();\r\n        }\r\n        tok.beginLine += getLine() - 1;\r\n        tok.endLine += getLine() - 1;\r\n        tok = tok.next;\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.PMDConfiguration.getAnalysisCache",
	"Comment": "retrieves the currently used analysis cache. will never be null.",
	"Method": "AnalysisCache getAnalysisCache(){\r\n    if (analysisCache == null || isIgnoreIncrementalAnalysis() && !(analysisCache instanceof NoopAnalysisCache)) {\r\n        setAnalysisCache(new NoopAnalysisCache());\r\n    }\r\n    return analysisCache;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.vm.directive.VelocimacroProxy.setArgArray",
	"Comment": "sets the array of arguments specified in the macro definition",
	"Method": "void setArgArray(String[] arr){\r\n    numMacroArgs = arr.length - 1;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.fxdesigner.model.MetricEvaluator.evaluateAllMetrics",
	"Comment": "evaluates all available metrics and returns a list of results.",
	"Method": "List<MetricResult> evaluateAllMetrics(Node node,List<MetricResult> evaluateAllMetrics,ASTMethodOrConstructorDeclaration node,List<MetricResult> evaluateAllMetrics,ASTAnyTypeDeclaration node,List<MetricResult> evaluateAllMetrics,ASTMethod node,List<MetricResult> evaluateAllMetrics,ASTUserClass node){\r\n    List<MetricResult> metricResults = new ArrayList();\r\n    for (ApexClassMetricKey key : ApexClassMetricKey.values()) {\r\n        metricResults.add(new MetricResult(key, ApexMetrics.get(key, node)));\r\n    }\r\n    return metricResults;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.GenericLiteralCheckerRule.visit",
	"Comment": "this method checks if the literal matches the pattern. if it does, aviolation is logged.",
	"Method": "Object visit(ASTLiteral node,Object data){\r\n    init();\r\n    String image = node.getImage();\r\n    if (image != null && image.length() > 0 && RegexHelper.isMatch(this.pattern, image)) {\r\n        addViolation(data, node);\r\n    }\r\n    return data;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.AbstractConfiguration.isDebug",
	"Comment": "return the debug indicator. if this value is true then pmdwill log debug information.",
	"Method": "boolean isDebug(){\r\n    return debug;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.RuleSets.applies",
	"Comment": "check if a given source file should be checked by rules in this rulesets.",
	"Method": "boolean applies(File file){\r\n    for (RuleSet ruleSet : ruleSets) {\r\n        if (ruleSet.applies(file)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.database.ResourceLoaderTest.testGetResourceStream",
	"Comment": "test of getresourcestream method, of class resourceloader.",
	"Method": "void testGetResourceStream(){\r\n    System.out.println(\"getResourceStream\");\r\n    String path = \"\";\r\n    ResourceLoader instance = new ResourceLoader();\r\n    InputStream expResult = null;\r\n    InputStream result = instance.getResourceStream(path);\r\n    Assert.assertNotNull(result);\r\n}"
}, {
	"Path": "com.querydsl.core.util.ConstructorUtils.getConstructorParameters",
	"Comment": "returns the parameters for the constructor that matches the given types.",
	"Method": "Class<?>[] getConstructorParameters(Class<?> type,Class<?>[] givenTypes){\r\n    next_constructor: for (Constructor<?> constructor : type.getConstructors()) {\r\n        int matches = 0;\r\n        Class<?>[] parameters = constructor.getParameterTypes();\r\n        Iterator<Class<?>> parameterIterator = Arrays.asList(parameters).iterator();\r\n        if (!isEmpty(givenTypes) && !isEmpty(parameters)) {\r\n            Class<?> parameter = null;\r\n            for (Class<?> argument : givenTypes) {\r\n                if (parameterIterator.hasNext()) {\r\n                    parameter = parameterIterator.next();\r\n                    if (!compatible(parameter, argument)) {\r\n                        continue next_constructor;\r\n                    }\r\n                    matches++;\r\n                } else if (constructor.isVarArgs()) {\r\n                    if (!compatible(parameter, argument)) {\r\n                        continue next_constructor;\r\n                    }\r\n                } else {\r\n                    continue next_constructor;\r\n                }\r\n            }\r\n            if (matches == parameters.length) {\r\n                return parameters;\r\n            }\r\n        } else if (isEmpty(givenTypes) && isEmpty(parameters)) {\r\n            return NO_ARGS;\r\n        }\r\n    }\r\n    throw new ExpressionException(\"No constructor found for \" + type.toString() + \" with parameters: \" + Arrays.deepToString(givenTypes));\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.jsp.ast.AbstractJspNodesTst.addNodeAndSubnodes",
	"Comment": "add the given node and its subnodes to the set of nodes. if clazz is notnull, only nodes of the given class are put in the set of nodes.",
	"Method": "void addNodeAndSubnodes(Node node,Set<T> nodes,Class<T> clazz){\r\n    if (null != node) {\r\n        if ((null == clazz) || (clazz.equals(node.getClass()))) {\r\n            nodes.add((T) node);\r\n        }\r\n        for (int i = 0; i < node.jjtGetNumChildren(); i++) {\r\n            addNodeAndSubnodes(node.jjtGetChild(i), nodes, clazz);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.plsql.rule.AbstractPLSQLRule.getDeclaringType",
	"Comment": "gets the image of the first parent node of typeastclassorinterfacedeclaration or null",
	"Method": "String getDeclaringType(Node node){\r\n    Node c;\r\n    c = node.getFirstParentOfType(ASTPackageSpecification.class);\r\n    if (c != null) {\r\n        return c.getImage();\r\n    }\r\n    c = node.getFirstParentOfType(ASTTypeSpecification.class);\r\n    if (c != null) {\r\n        return c.getImage();\r\n    }\r\n    c = node.getFirstParentOfType(ASTPackageBody.class);\r\n    if (c != null) {\r\n        return c.getImage();\r\n    }\r\n    c = node.getFirstParentOfType(ASTTriggerUnit.class);\r\n    if (c != null) {\r\n        return c.getImage();\r\n    }\r\n    c = node.getFirstParentOfType(ASTProgramUnit.class);\r\n    if (c != null) {\r\n        return c.getImage();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.powermock.api.easymock.PowerMock.createStrictMockAndExpectNew",
	"Comment": "convenience method for createstrictmock followed by expectnew.",
	"Method": "T createStrictMockAndExpectNew(Class<T> type,Object arguments,T createStrictMockAndExpectNew,Class<T> type,Class<?>[] parameterTypes,Object arguments){\r\n    T mock = createStrictMock(type);\r\n    expectStrictNew(type, parameterTypes, arguments).andReturn(mock);\r\n    return mock;\r\n}"
}, {
	"Path": "com.querydsl.core.types.PathMetadataFactory.forArrayAccess",
	"Comment": "create a new pathmetadata instance for indexed array access",
	"Method": "PathMetadata forArrayAccess(Path<?> parent,Expression<Integer> index,PathMetadata forArrayAccess,Path<?> parent,int index){\r\n    return new PathMetadata(parent, index, PathType.ARRAYVALUE_CONSTANT);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.testframework.SimpleAggregatorTst.addRule",
	"Comment": "add new xml tests associated with the rule to the test suite. this shouldbe called from the setup method.",
	"Method": "void addRule(String ruleSet,String ruleName){\r\n    rules.add(findRule(ruleSet, ruleName));\r\n}"
}, {
	"Path": "com.querydsl.core.BooleanBuilder.andNot",
	"Comment": "create the insertion of this and the negation of the given predicate",
	"Method": "BooleanBuilder andNot(Predicate right){\r\n    return and(right.not());\r\n}"
}, {
	"Path": "net.sourceforge.pmd.PMD.getURIDataSources",
	"Comment": "parses the given string as a database uri and returns a list ofdatasources.",
	"Method": "List<DataSource> getURIDataSources(String uriString){\r\n    List<DataSource> dataSources = new ArrayList();\r\n    try {\r\n        DBURI dbUri = new DBURI(uriString);\r\n        DBMSMetadata dbmsMetadata = new DBMSMetadata(dbUri);\r\n        LOG.log(Level.FINE, \"DBMSMetadata retrieved\");\r\n        List<SourceObject> sourceObjectList = dbmsMetadata.getSourceObjectList();\r\n        LOG.log(Level.FINE, \"Located {0} database source objects\", sourceObjectList.size());\r\n        for (SourceObject sourceObject : sourceObjectList) {\r\n            String falseFilePath = sourceObject.getPseudoFileName();\r\n            LOG.log(Level.FINEST, \"Adding database source object {0}\", falseFilePath);\r\n            try {\r\n                dataSources.add(new ReaderDataSource(dbmsMetadata.getSourceCode(sourceObject), falseFilePath));\r\n            } catch (SQLException ex) {\r\n                if (LOG.isLoggable(Level.WARNING)) {\r\n                    LOG.log(Level.WARNING, \"Cannot get SourceCode for \" + falseFilePath + \"  - skipping ...\", ex);\r\n                }\r\n            }\r\n        }\r\n    } catch (URISyntaxException e) {\r\n        throw new PMDException(\"Cannot get DataSources from DBURI - \\\"\" + uriString + \"\\\"\", e);\r\n    } catch (SQLException e) {\r\n        throw new PMDException(\"Cannot get DataSources from DBURI, couldn't access the database - \\\"\" + uriString + \"\\\"\", e);\r\n    } catch (ClassNotFoundException e) {\r\n        throw new PMDException(\"Cannot get DataSources from DBURI, probably missing database jdbc driver - \\\"\" + uriString + \"\\\"\", e);\r\n    } catch (Exception e) {\r\n        throw new PMDException(\"Encountered unexpected problem with URI \\\"\" + uriString + \"\\\"\", e);\r\n    }\r\n    return dataSources;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.properties.modules.PackagedPropertyModule.checkValidDefaults",
	"Comment": "evaluates the names of the items against the allowable name prefixes. if one or more do not have valid prefixesthen an exception will be thrown.",
	"Method": "void checkValidDefaults(List<T> items,String[] legalNamePrefixes){\r\n    if (legalNamePrefixes == null) {\r\n        return;\r\n    }\r\n    Set<String> nameSet = new HashSet();\r\n    for (T item : items) {\r\n        if (item == null) {\r\n            continue;\r\n        }\r\n        nameSet.add(packageNameOf(item));\r\n    }\r\n    Set<String> notAllowed = new HashSet(nameSet);\r\n    for (String name : nameSet) {\r\n        for (String prefix : legalNamePrefixes) {\r\n            if (name.startsWith(prefix)) {\r\n                notAllowed.remove(name);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (notAllowed.isEmpty()) {\r\n        return;\r\n    }\r\n    throw new IllegalArgumentException(\"Invalid items: \" + notAllowed);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.docs.RuleSetUtils.resolveRuleReferences",
	"Comment": "recursively resolves rule references until the last reference.the last reference is returned.if the given rule not a reference, the rule is returned.",
	"Method": "Rule resolveRuleReferences(Rule rule){\r\n    Rule result = rule;\r\n    Rule ref = rule;\r\n    while (ref instanceof RuleReference) {\r\n        result = ref;\r\n        ref = ((RuleReference) ref).getRule();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.filter.Filters.getFileExtensionFilter",
	"Comment": "get a file filter for files with the given extensions, ignoring case.",
	"Method": "Filter<File> getFileExtensionFilter(String extensions){\r\n    return new FileExtensionFilter(extensions);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.fxdesigner.util.codearea.StyleLayer.clearStyles",
	"Comment": "reset this layer to its empty state, clearing all the styles.",
	"Method": "void clearStyles(){\r\n    styleToCollection.clear();\r\n}"
}, {
	"Path": "com.querydsl.mongodb.Point.near",
	"Comment": "finds the closest points relative to the given location and orders the results with decreasing proximity",
	"Method": "BooleanExpression near(double latVal,double longVal){\r\n    return MongodbExpressions.near(this, latVal, longVal);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.database.DBURITest.testExplicitLanguagesList",
	"Comment": "verify that languages are returned if provided in the dburi.",
	"Method": "void testExplicitLanguagesList(){\r\n    System.out.println(\"testExplicitLanguagesList\");\r\n    List<String> defaultLanguagesList = Arrays.asList(C_EXPLICIT_LANGUAGES.split(\",\"));\r\n    DBURI instance = new DBURI(C_TEST_EXPLICIT);\r\n    List<String> result = instance.getLanguagesList();\r\n    assertEquals(defaultLanguagesList, result);\r\n}"
}, {
	"Path": "samples.powermockito.junit4.agent.SuppressConstructorDemoTest.testSuppressConstructor",
	"Comment": "this test makes sure that the real constructor has never been called.",
	"Method": "void testSuppressConstructor(){\r\n    suppress(constructor(SuppressConstructorDemo.class));\r\n    final SuppressConstructorDemo tested = new SuppressConstructorDemo(\"a message\");\r\n    assertNull(\"Message should have been null since we're skipping the execution of the constructor code.\", tested.getMessage());\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.vm.directive.Include.isScopeProvided",
	"Comment": "since there is no processing of content, there is never a need for aninternal scope.",
	"Method": "boolean isScopeProvided(){\r\n    return false;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.LanguageVersion.getShortName",
	"Comment": "get the short name of this languageversion. this is language short nameappended with the languageversion version if not an empty string.",
	"Method": "String getShortName(){\r\n    return version.length() > 0 ? language.getShortName() + ' ' + version : language.getShortName();\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.errorprone.ConstructorCallsOverridableMethodRule.evaluateDangerOfConstructors1",
	"Comment": "marks constructors dangerous if they call any dangerous methods requiresonly a single pass as methods are already markedtodo optimize by having methods already evaluated somehow!?",
	"Method": "void evaluateDangerOfConstructors1(Map<ConstructorHolder, List<MethodInvocation>> classConstructorMap,Set<MethodHolder> evaluatedMethods){\r\n    for (Map.Entry<ConstructorHolder, List<MethodInvocation>> entry : classConstructorMap.entrySet()) {\r\n        ConstructorHolder ch = entry.getKey();\r\n        if (!ch.isDangerous()) {\r\n            List<MethodInvocation> calledMeths = entry.getValue();\r\n            for (Iterator<MethodInvocation> calledMethsIter = calledMeths.iterator(); calledMethsIter.hasNext() && !ch.isDangerous(); ) {\r\n                MethodInvocation meth = calledMethsIter.next();\r\n                String methName = meth.getName();\r\n                int methArgCount = meth.getArgumentCount();\r\n                for (MethodHolder h : evaluatedMethods) {\r\n                    if (h.isDangerous()) {\r\n                        String matchName = h.getASTMethodDeclarator().getImage();\r\n                        int matchParamCount = h.getASTMethodDeclarator().getParameterCount();\r\n                        List<String> parameterTypes = getMethodDeclaratorParameterTypes(h.getASTMethodDeclarator());\r\n                        if (methName.equals(matchName) && methArgCount == matchParamCount && parameterTypes.equals(meth.getArgumentTypes())) {\r\n                            ch.setDangerous(true);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration.isLocal",
	"Comment": "returns true if the class is declared inside a block otherthan the body of another class, or the top level.",
	"Method": "boolean isLocal(){\r\n    if (!isLocalComputed) {\r\n        Node current = jjtGetParent();\r\n        while (current != null) {\r\n            if (current instanceof ASTAnyTypeDeclaration) {\r\n                isLocal = false;\r\n                break;\r\n            } else if (current instanceof ASTMethodOrConstructorDeclaration || current instanceof ASTInitializer) {\r\n                isLocal = true;\r\n                break;\r\n            }\r\n            current = current.jjtGetParent();\r\n        }\r\n        if (current == null) {\r\n            isLocal = false;\r\n        }\r\n        isLocalComputed = true;\r\n    }\r\n    return isLocal;\r\n}"
}, {
	"Path": "com.querydsl.mongodb.MongodbExpressions.near",
	"Comment": "finds the closest points relative to the given location and orders the results with decreasing proximity",
	"Method": "BooleanExpression near(Expression<Double[]> expr,double latVal,double longVal){\r\n    return Expressions.booleanOperation(MongodbOps.NEAR, expr, ConstantImpl.create(new Double[] { latVal, longVal }));\r\n}"
}, {
	"Path": "com.querydsl.core.util.BeanMap.valueIterator",
	"Comment": "convenience method for getting an iterator over the values.",
	"Method": "Iterator<Object> valueIterator(){\r\n    final Iterator<String> iter = keyIterator();\r\n    return new Iterator<Object>() {\r\n        @Override\r\n        public boolean hasNext() {\r\n            return iter.hasNext();\r\n        }\r\n        @Override\r\n        public Object next() {\r\n            Object key = iter.next();\r\n            return get(key);\r\n        }\r\n        @Override\r\n        public void remove() {\r\n            throw new UnsupportedOperationException(\"remove() not supported for BeanMap\");\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.querydsl.core.util.BeanMap.valueIterator",
	"Comment": "convenience method for getting an iterator over the values.",
	"Method": "Iterator<Object> valueIterator(){\r\n    return iter.hasNext();\r\n}"
}, {
	"Path": "com.querydsl.core.util.BeanMap.valueIterator",
	"Comment": "convenience method for getting an iterator over the values.",
	"Method": "Iterator<Object> valueIterator(){\r\n    Object key = iter.next();\r\n    return get(key);\r\n}"
}, {
	"Path": "com.querydsl.core.util.BeanMap.valueIterator",
	"Comment": "convenience method for getting an iterator over the values.",
	"Method": "Iterator<Object> valueIterator(){\r\n    throw new UnsupportedOperationException(\"remove() not supported for BeanMap\");\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.fxdesigner.XPathPanelController.evaluateXPath",
	"Comment": "evaluate the contents of the xpath expression areaon the given compilation unit. this updates the xpathresult panel, and can log xpath exceptions to theevent log panel.",
	"Method": "void evaluateXPath(Node compilationUnit,LanguageVersion version){\r\n    try {\r\n        String xpath = getXpathExpression();\r\n        if (StringUtils.isBlank(xpath)) {\r\n            invalidateResults(false);\r\n            return;\r\n        }\r\n        ObservableList<Node> results = FXCollections.observableArrayList(xpathEvaluator.evaluateQuery(compilationUnit, version, getXpathVersion(), xpath, ruleBuilder.getRuleProperties()));\r\n        xpathResultListView.setItems(results.stream().map(parent::wrapNode).collect(Collectors.toCollection(LiveArrayList::new)));\r\n        parent.highlightXPathResults(results);\r\n        violationsTitledPane.setText(\"Matched nodes\\t(\" + results.size() + \")\");\r\n    } catch (XPathEvaluationException e) {\r\n        invalidateResults(true);\r\n        designerRoot.getLogger().logEvent(new LogEntry(e, Category.XPATH_EVALUATION_EXCEPTION));\r\n    }\r\n    xpathResultListView.refresh();\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.vf.ast.VfDocStyleTest.testAttributeValueContainingHash",
	"Comment": "test exposing a bug of parsing error when having a hash as last characterin an attribute value.",
	"Method": "void testAttributeValueContainingHash(){\r\n    Set<VfNode> nodes = getNodes(null, TEST_ATTRIBUTE_VALUE_CONTAINING_HASH);\r\n    Set<ASTAttribute> attributes = getNodesOfType(ASTAttribute.class, nodes);\r\n    assertEquals(\"Three attributes expected!\", 3, attributes.size());\r\n    List<ASTAttribute> attrsList = new ArrayList(attributes);\r\n    Collections.sort(attrsList, new Comparator<ASTAttribute>() {\r\n        public int compare(ASTAttribute arg0, ASTAttribute arg1) {\r\n            return arg0.getName().compareTo(arg1.getName());\r\n        }\r\n    });\r\n    ASTAttribute attr = attrsList.get(0);\r\n    assertEquals(\"Correct attribute name expected!\", \"foo\", attr.getName());\r\n    assertEquals(\"Correct attribute value expected!\", \"CREATE\", attr.getFirstDescendantOfType(ASTText.class).getImage());\r\n    attr = attrsList.get(1);\r\n    assertEquals(\"Correct attribute name expected!\", \"href\", attr.getName());\r\n    assertEquals(\"Correct attribute value expected!\", \"#\", attr.getFirstDescendantOfType(ASTText.class).getImage());\r\n    attr = attrsList.get(2);\r\n    assertEquals(\"Correct attribute name expected!\", \"something\", attr.getName());\r\n    assertEquals(\"Correct attribute value expected!\", \"#yes#\", attr.getFirstDescendantOfType(ASTText.class).getImage());\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.vf.ast.VfDocStyleTest.testAttributeValueContainingHash",
	"Comment": "test exposing a bug of parsing error when having a hash as last characterin an attribute value.",
	"Method": "void testAttributeValueContainingHash(){\r\n    return arg0.getName().compareTo(arg1.getName());\r\n}"
}, {
	"Path": "net.sourceforge.pmd.RuleSet.apply",
	"Comment": "executes the rules in this ruleset against each of the given nodes.",
	"Method": "void apply(List<? extends Node> acuList,RuleContext ctx){\r\n    try (TimedOperation to = TimeTracker.startOperation(TimedOperationCategory.RULE)) {\r\n        for (Rule rule : rules) {\r\n            if (!rule.isRuleChain() && applies(rule, ctx.getLanguageVersion())) {\r\n                try (TimedOperation rto = TimeTracker.startOperation(TimedOperationCategory.RULE, rule.getName())) {\r\n                    rule.apply(acuList, ctx);\r\n                } catch (RuntimeException e) {\r\n                    if (ctx.isIgnoreExceptions()) {\r\n                        ctx.getReport().addError(new Report.ProcessingError(e, ctx.getSourceCodeFilename()));\r\n                        if (LOG.isLoggable(Level.WARNING)) {\r\n                            LOG.log(Level.WARNING, \"Exception applying rule \" + rule.getName() + \" on file \" + ctx.getSourceCodeFilename() + \", continuing with next rule\", e);\r\n                        }\r\n                    } else {\r\n                        throw e;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.metrics.impl.AbstractJavaClassMetric.supports",
	"Comment": "returns true if the metric can be computed on this type declaration. by default, annotation and interfacedeclarations are filtered out.",
	"Method": "boolean supports(ASTAnyTypeDeclaration node){\r\n    return node.getTypeKind() != TypeKind.ANNOTATION && node.getTypeKind() != TypeKind.INTERFACE;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.plsql.symboltable.ScopeAndDeclarationFinder.createClassScope",
	"Comment": "creates a new class scope for an ast node. the scope on top of the stackis set as the parent of the new scope, which is then also stored on thescope stack.",
	"Method": "void createClassScope(PLSQLNode node){\r\n    if (node instanceof ASTDeclarativeUnit) {\r\n        addScope(new ClassScope(), node);\r\n    } else {\r\n        addScope(new ClassScope(node.getImage()), node);\r\n    }\r\n}"
}, {
	"Path": "org.powermock.api.mockito.PowerMockito.when",
	"Comment": "expect calls to private static methods without having to specify themethod name. the method will be looked up using the parameter types ifpossible",
	"Method": "OngoingStubbing<T> when(Object instance,String methodName,Object arguments,WithOrWithoutExpectedArguments<T> when,Object instance,Method method,WithOrWithoutExpectedArguments<T> when,Class<?> cls,Method method,OngoingStubbing<T> when,Object instance,Object arguments,OngoingStubbing<T> when,Class<?> clazz,String methodToExpect,Object arguments,OngoingStubbing<T> when,Class<?> klass,Object arguments,OngoingStubbing<T> when,T methodCall){\r\n    return Mockito.when(methodCall);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.PMDConfiguration.getSuppressMarker",
	"Comment": "get the suppress marker. this is the source level marker used to indicatea ruleviolation should be suppressed.",
	"Method": "String getSuppressMarker(){\r\n    return suppressMarker;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.RuleSet.start",
	"Comment": "triggers that start lifecycle event on each rule in this ruleset. somerules perform initialization tasks on start.",
	"Method": "void start(RuleContext ctx){\r\n    for (Rule rule : rules) {\r\n        rule.start(ctx);\r\n    }\r\n}"
}, {
	"Path": "org.powermock.reflect.internal.WhiteboxImpl.invokeMethod",
	"Comment": "invoke a private or inner class method. this might be useful to testprivate methods.",
	"Method": "T invokeMethod(Object tested,Object arguments,T invokeMethod,Class<?> tested,Object arguments,T invokeMethod,Object tested,String methodToExecute,Object arguments,T invokeMethod,Object tested,String methodToExecute,Class<?>[] argumentTypes,Object arguments,T invokeMethod,Object tested,String methodToExecute,Class<?> definedIn,Class<?>[] argumentTypes,Object arguments,T invokeMethod,Object tested,Class<?> declaringClass,String methodToExecute,Object arguments,T invokeMethod,Object object,Class<?> declaringClass,String methodToExecute,Class<?>[] parameterTypes,Object arguments,T invokeMethod,Class<?> clazz,String methodToExecute,Object arguments){\r\n    return (T) doInvokeMethod(clazz, null, methodToExecute, arguments);\r\n}"
}, {
	"Path": "com.querydsl.core.types.OrderSpecifier.nullsFirst",
	"Comment": "create a new orderspecifier instance with null first enabled",
	"Method": "OrderSpecifier<T> nullsFirst(){\r\n    return new OrderSpecifier<T>(order, target, NullHandling.NullsFirst);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.processor.AbstractPMDProcessor.removeBrokenRules",
	"Comment": "remove and return the misconfigured rules from the rulesets and log themfor good measure.",
	"Method": "Set<Rule> removeBrokenRules(RuleSets ruleSets){\r\n    final Set<Rule> brokenRules = new HashSet();\r\n    ruleSets.removeDysfunctionalRules(brokenRules);\r\n    for (final Rule rule : brokenRules) {\r\n        if (LOG.isLoggable(Level.WARNING)) {\r\n            LOG.log(Level.WARNING, \"Removed misconfigured rule: \" + rule.getName() + \"  cause: \" + rule.dysfunctionReason());\r\n        }\r\n    }\r\n    return brokenRules;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.PMDConfiguration.getLanguageVersionDiscoverer",
	"Comment": "get the languageversiondiscoverer, used to determine the languageversionof a source file.",
	"Method": "LanguageVersionDiscoverer getLanguageVersionDiscoverer(){\r\n    return languageVersionDiscoverer;\r\n}"
}, {
	"Path": "com.querydsl.jpa.JPAExpressions.selectZero",
	"Comment": "create a new detached jpqlquery instance with the projection zero",
	"Method": "JPQLQuery<Integer> selectZero(){\r\n    return select(Expressions.ZERO);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.RuleSetFactory.createRuleSets",
	"Comment": "create a rulesets from a list of rulesetreferenceids. the currentlyconfigured resourceloader is used.",
	"Method": "RuleSets createRuleSets(String referenceString,RuleSets createRuleSets,List<RuleSetReferenceId> ruleSetReferenceIds){\r\n    RuleSets ruleSets = new RuleSets();\r\n    for (RuleSetReferenceId ruleSetReferenceId : ruleSetReferenceIds) {\r\n        RuleSet ruleSet = createRuleSet(ruleSetReferenceId);\r\n        ruleSets.addRuleSet(ruleSet);\r\n    }\r\n    return ruleSets;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.filter.AbstractDelegateFilter.filter",
	"Comment": "subclass should override to do something other the simply delegate.",
	"Method": "boolean filter(T obj){\r\n    return filter.filter(obj);\r\n}"
}, {
	"Path": "com.querydsl.lucene3.AbstractLuceneQuery.distinct",
	"Comment": "add a duplicatefilter for the field of the given property path",
	"Method": "Q distinct(Q distinct,Path<?> property){\r\n    return filter(new DuplicateFilter(serializer.toField(property)));\r\n}"
}, {
	"Path": "net.sourceforge.pmd.stat.StatisticalRuleTest.randomSigma",
	"Comment": "this returns a random value for sigma which value is greater than theparameter.",
	"Method": "double randomSigma(double randomSigma,int minimum){\r\n    double minSigma = ((POINTS - 1 - minimum) - MEAN) / SIGMA;\r\n    if ((minSigma <= 0) || (minSigma > 2)) {\r\n        return randomSigma();\r\n    }\r\n    return minSigma + (random.nextDouble() * (2 - minSigma));\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.errorprone.UselessOperationOnImmutableRule.getDeclaration",
	"Comment": "this method checks the variable declaration if it is on a class we careabout. if it is, it returns the declaratorid",
	"Method": "ASTVariableDeclaratorId getDeclaration(ASTLocalVariableDeclaration node){\r\n    ASTType type = node.getTypeNode();\r\n    if (type != null) {\r\n        if (MAP_CLASSES.keySet().contains(type.getTypeImage())) {\r\n            return node.getFirstDescendantOfType(ASTVariableDeclaratorId.class);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.querydsl.core.types.Projections.constructor",
	"Comment": "create a constructor invocation projection for given type, parameter types and expressions",
	"Method": "ConstructorExpression<T> constructor(Class<? extends T> type,Expression<?> exprs,ConstructorExpression<T> constructor,Class<? extends T> type,Class<?>[] paramTypes,Expression<?> exprs,ConstructorExpression<T> constructor,Class<? extends T> type,Class<?>[] paramTypes,ImmutableList<Expression<?>> exprs){\r\n    return new ConstructorExpression<T>(type, paramTypes, exprs);\r\n}"
}, {
	"Path": "io.paperdb.Paper.bookOn",
	"Comment": "returns book instance to save data at custom location, e.g. on sdcard.",
	"Method": "Book bookOn(String location,String name,Book bookOn,String location){\r\n    return bookOn(location, DEFAULT_DB_NAME);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.jsp.ast.JspDocStyleTest.testAttributeValueContainingHash",
	"Comment": "test exposing a bug of parsing error when having a hash as last characterin an attribute value.",
	"Method": "void testAttributeValueContainingHash(){\r\n    Set<JspNode> nodes = getNodes(null, TEST_ATTRIBUTE_VALUE_CONTAINING_HASH);\r\n    Set<ASTAttribute> attributes = getNodesOfType(ASTAttribute.class, nodes);\r\n    assertEquals(\"Three attributes expected!\", 3, attributes.size());\r\n    List<ASTAttribute> attrsList = new ArrayList(attributes);\r\n    Collections.sort(attrsList, new Comparator<ASTAttribute>() {\r\n        public int compare(ASTAttribute arg0, ASTAttribute arg1) {\r\n            return arg0.getName().compareTo(arg1.getName());\r\n        }\r\n    });\r\n    ASTAttribute attr = attrsList.get(0);\r\n    assertEquals(\"Correct attribute name expected!\", \"foo\", attr.getName());\r\n    assertEquals(\"Correct attribute value expected!\", \"CREATE\", attr.getFirstDescendantOfType(ASTAttributeValue.class).getImage());\r\n    attr = attrsList.get(1);\r\n    assertEquals(\"Correct attribute name expected!\", \"href\", attr.getName());\r\n    assertEquals(\"Correct attribute value expected!\", \"#\", attr.getFirstDescendantOfType(ASTAttributeValue.class).getImage());\r\n    attr = attrsList.get(2);\r\n    assertEquals(\"Correct attribute name expected!\", \"something\", attr.getName());\r\n    assertEquals(\"Correct attribute value expected!\", \"#yes#\", attr.getFirstDescendantOfType(ASTAttributeValue.class).getImage());\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.jsp.ast.JspDocStyleTest.testAttributeValueContainingHash",
	"Comment": "test exposing a bug of parsing error when having a hash as last characterin an attribute value.",
	"Method": "void testAttributeValueContainingHash(){\r\n    return arg0.getName().compareTo(arg1.getName());\r\n}"
}, {
	"Path": "org.powermock.api.easymock.PowerMock.createStrictMock",
	"Comment": "creates a strict mock object that supports mocking of final and nativemethods and invokes a specific constructor based on the supplied argumentvalues.",
	"Method": "T createStrictMock(Class<T> type,Method methods,T createStrictMock,Class<T> type,T createStrictMock,Class<T> type,ConstructorArgs constructorArgs,Method methods,T createStrictMock,Class<T> type,Object constructorArguments){\r\n    Constructor<?> constructor = WhiteboxImpl.findUniqueConstructorOrThrowException(type, constructorArguments);\r\n    ConstructorArgs constructorArgs = new ConstructorArgs(constructor, constructorArguments);\r\n    return doMock(type, false, new StrictMockStrategy(), constructorArgs, (Method[]) null);\r\n}"
}, {
	"Path": "org.powermock.api.easymock.PowerMock.expectNew",
	"Comment": "allows specifying expectations on new invocations. for example you mightwant to throw an exception or return a mock. note that you must replaythe class when using this method since this behavior is part of the classmock.",
	"Method": "IExpectationSetters<T> expectNew(Class<T> type,Class<?>[] parameterTypes,Object arguments,IExpectationSetters<T> expectNew,Class<T> type,Object arguments,IExpectationSetters<T> expectNew,String fullyQualifiedName,Object arguments){\r\n    final Class<?> forName = Class.forName(fullyQualifiedName);\r\n    return (IExpectationSetters<T>) doExpectNew(forName, new DefaultMockStrategy(), null, arguments);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.jsp.ast.JspDocStyleTest.unclosedTagsWithJspExpressionWithin",
	"Comment": "make sure jsp expressions are properly detected when they are next tounclosed tags.",
	"Method": "void unclosedTagsWithJspExpressionWithin(){\r\n    Set<ASTJspExpression> scripts = getNodes(ASTJspExpression.class, TEST_TAGS_WITH_EXPRESSION_WITHIN);\r\n    assertEquals(\"Two JSP expressions expected!\", 2, scripts.size());\r\n    ASTJspExpression script = scripts.iterator().next();\r\n    assertEquals(\"Correct content expected!\", \"expr\", script.getImage());\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.plsql.symboltable.ScopeAndDeclarationFinder.createLocalScope",
	"Comment": "creates a new local scope for an ast node. the scope on top of the stackis set as the parent of the new scope, which is then also stored on thescope stack.",
	"Method": "void createLocalScope(PLSQLNode node){\r\n    addScope(new LocalScope(), node);\r\n}"
}, {
	"Path": "org.powermock.api.easymock.PowerMock.createPartialMock",
	"Comment": "mock a single specific method. use this to handle overloaded methods.",
	"Method": "T createPartialMock(Class<T> type,String methodNameToMock,Class<?> firstArgumentType,Class<?> additionalArgumentTypes,T createPartialMock,Class<T> type,String methodNames,T createPartialMock,Class<T> type,Class<? super T> where,String methodNames,T createPartialMock,Class<T> type,String[] methodNames,Object constructorArguments,T createPartialMock,Class<T> type,String methodName,Class<?>[] methodParameterTypes,Object constructorArguments,T createPartialMock,Class<T> type,String methodName,Class<?>[] methodParameterTypes,Object[] constructorArguments,Class<?>[] constructorParameterTypes){\r\n    ConstructorArgs constructorArgs = new ConstructorArgs(Whitebox.getConstructor(type, constructorParameterTypes), constructorArguments);\r\n    return doMockSpecific(type, new DefaultMockStrategy(), new String[] { methodName }, constructorArgs, methodParameterTypes);\r\n}"
}, {
	"Path": "com.querydsl.core.alias.AliasFactory.createAliasForVariable",
	"Comment": "create an alias instance for the given class and variable name",
	"Method": "A createAliasForVariable(Class<A> cl,String var){\r\n    try {\r\n        Expression<?> path = pathCache.get(Pair.<Class<?>, String>of(cl, var));\r\n        return (A) proxyCache.get(Pair.<Class<?>, Expression<?>>of(cl, path));\r\n    } catch (ExecutionException e) {\r\n        throw new QueryException(e);\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.database.DBURITest.testDefaultLanguagesList",
	"Comment": "verify that default languages are returned if non are provided in thedburi.",
	"Method": "void testDefaultLanguagesList(){\r\n    System.out.println(\"testDefaultLanguagesList\");\r\n    List<String> defaultLanguagesList = Arrays.asList(C_DEFAULT_LANGUAGES.split(\",\"));\r\n    DBURI instance = new DBURI(C_TEST_DEFAULTS);\r\n    List<String> result = instance.getLanguagesList();\r\n    assertEquals(defaultLanguagesList, result);\r\n}"
}, {
	"Path": "com.querydsl.core.types.dsl.DateTimeExpression.currentTimestamp",
	"Comment": "create an expression representing the current time instant as a datetimeexpression instance",
	"Method": "DateTimeExpression<Date> currentTimestamp(DateTimeExpression<T> currentTimestamp,Class<T> cl){\r\n    return Expressions.dateTimeOperation(cl, Ops.DateTimeOps.CURRENT_TIMESTAMP);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.JavaRuleViolation.isSupressed",
	"Comment": "check for suppression on this node, on parents, and on contained typesfor astcompilationunit",
	"Method": "boolean isSupressed(Node node,Rule rule){\r\n    boolean result = suppresses(node, rule);\r\n    if (!result && node instanceof ASTCompilationUnit) {\r\n        for (int i = 0; !result && i < node.jjtGetNumChildren(); i++) {\r\n            result = suppresses(node.jjtGetChild(i), rule);\r\n        }\r\n    }\r\n    if (!result) {\r\n        Node parent = node.jjtGetParent();\r\n        while (!result && parent != null) {\r\n            result = suppresses(parent, rule);\r\n            parent = parent.jjtGetParent();\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.powermock.api.easymock.PowerMock.createNicePartialMock",
	"Comment": "nicely mock a single specific method. use this to handle overloadedmethods.",
	"Method": "T createNicePartialMock(Class<T> type,String methodNameToMock,Class<?> firstArgumentType,Class<?> additionalArgumentTypes,T createNicePartialMock,Class<T> type,String methodNames,T createNicePartialMock,Class<T> type,Class<? super T> where,String methodNames,T createNicePartialMock,Class<T> type,String[] methodNames,Object constructorArguments,T createNicePartialMock,Class<T> type,String methodName,Class<?>[] methodParameterTypes,Object constructorArguments,T createNicePartialMock,Class<T> type,String methodName,Class<?>[] methodParameterTypes,Object[] constructorArguments,Class<?>[] constructorParameterTypes){\r\n    ConstructorArgs constructorArgs = new ConstructorArgs(Whitebox.getConstructor(type, constructorParameterTypes), constructorArguments);\r\n    return doMockSpecific(type, new NiceMockStrategy(), new String[] { methodName }, constructorArgs, methodParameterTypes);\r\n}"
}, {
	"Path": "sun.tools.attach.HotSpotVirtualMachine.loadAgent",
	"Comment": "load jplis agent which will load the agent jar file and invokethe agentmain method.",
	"Method": "void loadAgent(String agent,String options){\r\n    String args = agent;\r\n    if (options != null) {\r\n        args = args + \"=\" + options;\r\n    }\r\n    try {\r\n        loadAgentLibrary(\"instrument\", args);\r\n    } catch (AgentLoadException x) {\r\n        throw new InternalError(\"instrument library is missing in target VM\");\r\n    } catch (AgentInitializationException x) {\r\n        int rc = x.returnValue();\r\n        switch(rc) {\r\n            case JNI_ENOMEM:\r\n                throw new AgentLoadException(\"Insuffient memory\");\r\n            case ATTACH_ERROR_BADJAR:\r\n                throw new AgentLoadException(\"Agent JAR not found or no Agent-Class attribute\");\r\n            case ATTACH_ERROR_NOTONCP:\r\n                throw new AgentLoadException(\"Unable to add JAR file to system class path\");\r\n            case ATTACH_ERROR_STARTFAIL:\r\n                throw new AgentInitializationException(\"Agent JAR loaded but agent failed to initialize\");\r\n            default:\r\n                throw new AgentLoadException(\"Failed to load agent - unknown reason: \" + rc);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.database.DBURITest.testExplicitSourceCodeNamesList",
	"Comment": "verify that languages are returned if provided in the dburi.",
	"Method": "void testExplicitSourceCodeNamesList(){\r\n    System.out.println(\"testExplicitSourceCodeNamesList\");\r\n    List<String> defaultSourceCodeNamesList = Arrays.asList(C_EXPLICIT_SOURCE_CODE_NAMES.split(\",\"));\r\n    DBURI instance = new DBURI(C_TEST_EXPLICIT);\r\n    List<String> result = instance.getSourceCodeNamesList();\r\n    assertEquals(defaultSourceCodeNamesList, result);\r\n}"
}, {
	"Path": "com.querydsl.core.alias.AliasFactory.getCurrent",
	"Comment": "get the current thread bound expression without resetting it",
	"Method": "A getCurrent(){\r\n    return (A) current.get();\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.ast.ASTLocalVariableDeclaration.iterator",
	"Comment": "returns an iterator over the ids of the variablesdeclared in this statement.",
	"Method": "Iterator<ASTVariableDeclaratorId> iterator(){\r\n    return ASTVariableDeclarator.iterateIds(this);\r\n}"
}, {
	"Path": "com.querydsl.core.util.ConstructorUtils.getTransformers",
	"Comment": "returns a fetch of transformers applicable to the given constructor.",
	"Method": "Iterable<Function<Object[], Object[]>> getTransformers(Constructor<?> constructor){\r\n    Iterable<ArgumentTransformer> transformers = Lists.newArrayList(new PrimitiveAwareVarArgsTransformer(constructor), new PrimitiveTransformer(constructor), new VarArgsTransformer(constructor));\r\n    return ImmutableList.<Function<Object[], Object[]>>copyOf(filter(transformers, applicableFilter));\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.LanguageVersionDiscoverer.getDefaultLanguageVersion",
	"Comment": "get the current default languageversion for the given language.",
	"Method": "LanguageVersion getDefaultLanguageVersion(Language language){\r\n    LanguageVersion languageVersion = languageToLanguageVersion.get(language);\r\n    if (languageVersion == null) {\r\n        languageVersion = language.getDefaultVersion();\r\n    }\r\n    return languageVersion;\r\n}"
}, {
	"Path": "org.powermock.api.mockito.PowerMockito.mock",
	"Comment": "creates a mock object that supports mocking of final and native methods.",
	"Method": "T mock(Class<T> type,T mock,Class<T> classToMock,Answer defaultAnswer,T mock,Class<T> classToMock,MockSettings mockSettings){\r\n    return DefaultMockCreator.mock(classToMock, false, false, null, mockSettings, (Method[]) null);\r\n}"
}, {
	"Path": "org.powermock.core.PowerMockUtils.getClassIterator",
	"Comment": "get an iterator of all classes loaded by the specific classloader.",
	"Method": "Iterator<Class<?>> getClassIterator(ClassLoader classLoader){\r\n    Class<?> classLoaderClass = classLoader.getClass();\r\n    while (classLoaderClass != ClassLoader.class) {\r\n        classLoaderClass = classLoaderClass.getSuperclass();\r\n    }\r\n    Field classesField = classLoaderClass.getDeclaredField(\"classes\");\r\n    classesField.setAccessible(true);\r\n    Vector<Class<?>> classes = (Vector<Class<?>>) classesField.get(classLoader);\r\n    return classes.iterator();\r\n}"
}, {
	"Path": "org.powermock.reflect.Whitebox.getFieldsOfType",
	"Comment": "get all fields assignable from a particular type. this method traverses\tthe class hierarchy when checking for the type.",
	"Method": "Set<Field> getFieldsOfType(Object object,Class<?> type){\r\n    return WhiteboxImpl.getFieldsOfType(object, type);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.PMDConfiguration.isBenchmark",
	"Comment": "return the benchmark indicator. if this value is true thenpmd will log benchmark information.",
	"Method": "boolean isBenchmark(){\r\n    return benchmark;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.viewer.model.ViewerModel.evaluateXPathExpression",
	"Comment": "evaluates the given xpath expression against the current tree.",
	"Method": "void evaluateXPathExpression(String xPath,Object evaluator){\r\n    try {\r\n        if (LOGGER.isLoggable(Level.FINEST)) {\r\n            LOGGER.finest(\"xPath=\" + xPath);\r\n            LOGGER.finest(\"evaluator=\" + evaluator);\r\n        }\r\n        XPath xpath = new BaseXPath(xPath, new DocumentNavigator());\r\n        if (LOGGER.isLoggable(Level.FINEST)) {\r\n            LOGGER.finest(\"xpath=\" + xpath);\r\n            LOGGER.finest(\"rootNode=\" + rootNode);\r\n        }\r\n        try {\r\n            evaluationResults = xpath.selectNodes(rootNode);\r\n        } catch (Exception e) {\r\n            LOGGER.finest(\"selectNodes problem:\");\r\n            e.printStackTrace(System.err);\r\n        }\r\n        if (LOGGER.isLoggable(Level.FINEST)) {\r\n            LOGGER.finest(\"evaluationResults=\" + evaluationResults);\r\n        }\r\n        fireViewerModelEvent(new ViewerModelEvent(evaluator, ViewerModelEvent.PATH_EXPRESSION_EVALUATED));\r\n    } catch (JaxenException je) {\r\n        je.printStackTrace(System.err);\r\n        throw je;\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.jsp.ast.JspDocStyleTest.noQuoteAttrWithJspEL",
	"Comment": "tests whether jsp el is properly detected as attribute value",
	"Method": "void noQuoteAttrWithJspEL(){\r\n    Set<ASTAttributeValue> attributes = getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_ATTR_WITH_EL);\r\n    assertEquals(\"two attributes expected!\", 2, attributes.size());\r\n    Iterator<ASTAttributeValue> iterator = attributes.iterator();\r\n    ASTAttributeValue attr2 = iterator.next();\r\n    if (\"url\".equals(attr2.getImage())) {\r\n        attr2 = iterator.next();\r\n    }\r\n    assertEquals(\"Expected to detect proper value for EL in attribute!\", \"${something}\", attr2.getImage());\r\n}"
}, {
	"Path": "net.sourceforge.pmd.AbstractRuleSetFactoryTest.testAllPMDBuiltInRulesMeetConventions",
	"Comment": "checks all rulesets of all languages on the classpath and verifies thatall required attributes for all rules are specified.",
	"Method": "void testAllPMDBuiltInRulesMeetConventions(){\r\n    int invalidSinceAttributes = 0;\r\n    int invalidExternalInfoURL = 0;\r\n    int invalidClassName = 0;\r\n    int invalidRegexSuppress = 0;\r\n    int invalidXPathSuppress = 0;\r\n    String messages = \"\";\r\n    List<String> ruleSetFileNames = getRuleSetFileNames();\r\n    for (String fileName : ruleSetFileNames) {\r\n        RuleSet ruleSet = loadRuleSetByFileName(fileName);\r\n        for (Rule rule : ruleSet.getRules()) {\r\n            if (rule instanceof RuleReference) {\r\n                continue;\r\n            }\r\n            Language language = rule.getLanguage();\r\n            String group = fileName.substring(fileName.lastIndexOf('/') + 1);\r\n            group = group.substring(0, group.indexOf(\".xml\"));\r\n            if (group.indexOf('-') >= 0) {\r\n                group = group.substring(0, group.indexOf('-'));\r\n            }\r\n            if (rule.getSince() == null) {\r\n                invalidSinceAttributes++;\r\n                messages += \"Rule \" + fileName + \"/\" + rule.getName() + \" is missing 'since' attribute\" + PMD.EOL;\r\n            }\r\n            if (rule.getExternalInfoUrl() == null || \"\".equalsIgnoreCase(rule.getExternalInfoUrl())) {\r\n                invalidExternalInfoURL++;\r\n                messages += \"Rule \" + fileName + \"/\" + rule.getName() + \" is missing 'externalInfoURL' attribute\" + PMD.EOL;\r\n            } else {\r\n                String expectedExternalInfoURL = \"https?://pmd.(sourceforge.net|github.io)/.+/pmd_rules_\" + language.getTerseName() + \"_\" + FilenameUtils.getBaseName(fileName) + \".html#\" + rule.getName().toLowerCase(Locale.ROOT);\r\n                if (rule.getExternalInfoUrl() == null || !rule.getExternalInfoUrl().matches(expectedExternalInfoURL)) {\r\n                    invalidExternalInfoURL++;\r\n                    messages += \"Rule \" + fileName + \"/\" + rule.getName() + \" seems to have an invalid 'externalInfoURL' value (\" + rule.getExternalInfoUrl() + \"), it should be:\" + expectedExternalInfoURL + PMD.EOL;\r\n                }\r\n            }\r\n            String expectedClassName = \"net.sourceforge.pmd.lang.\" + language.getTerseName() + \".rule.\" + group + \".\" + rule.getName() + \"Rule\";\r\n            if (!rule.getRuleClass().equals(expectedClassName) && !validXPathClassNames.contains(rule.getRuleClass())) {\r\n                invalidClassName++;\r\n                messages += \"Rule \" + fileName + \"/\" + rule.getName() + \" seems to have an invalid 'class' value (\" + rule.getRuleClass() + \"), it should be:\" + expectedClassName + PMD.EOL;\r\n            }\r\n            if (rule.getProperty(Rule.VIOLATION_SUPPRESS_REGEX_DESCRIPTOR) != null) {\r\n                invalidRegexSuppress++;\r\n                messages += \"Rule \" + fileName + \"/\" + rule.getName() + \" should not have '\" + Rule.VIOLATION_SUPPRESS_REGEX_DESCRIPTOR.name() + \"', this is intended for end user customization only.\" + PMD.EOL;\r\n            }\r\n            if (rule.getProperty(Rule.VIOLATION_SUPPRESS_XPATH_DESCRIPTOR) != null) {\r\n                invalidXPathSuppress++;\r\n                messages += \"Rule \" + fileName + \"/\" + rule.getName() + \" should not have '\" + Rule.VIOLATION_SUPPRESS_XPATH_DESCRIPTOR.name() + \"', this is intended for end user customization only.\" + PMD.EOL;\r\n            }\r\n        }\r\n    }\r\n    if (invalidSinceAttributes > 0 || invalidExternalInfoURL > 0 || invalidClassName > 0 || invalidRegexSuppress > 0 || invalidXPathSuppress > 0) {\r\n        fail(\"All built-in PMD rules need 'since' attribute (\" + invalidSinceAttributes + \" are missing), a proper ExternalURLInfo (\" + invalidExternalInfoURL + \" are invalid), a class name meeting conventions (\" + invalidClassName + \" are invalid), no '\" + Rule.VIOLATION_SUPPRESS_REGEX_DESCRIPTOR.name() + \"' property (\" + invalidRegexSuppress + \" are invalid), and no '\" + Rule.VIOLATION_SUPPRESS_XPATH_DESCRIPTOR.name() + \"' property (\" + invalidXPathSuppress + \" are invalid)\" + PMD.EOL + messages);\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.rules.RuleFactory.getPropertyValue",
	"Comment": "gets a mapping of property name to its value from the given property element.",
	"Method": "Entry<String, String> getPropertyValue(Element propertyElement){\r\n    String name = propertyElement.getAttribute(PropertyDescriptorField.NAME.attributeName());\r\n    return new SimpleEntry(name, valueFrom(propertyElement));\r\n}"
}, {
	"Path": "com.querydsl.collections.DefaultEvaluatorFactory.createEvaluator",
	"Comment": "create an evaluator for the given sources and the given optional filter",
	"Method": "Evaluator<List<T>> createEvaluator(QueryMetadata metadata,Expression<? extends T> source,Predicate filter,Evaluator<List<Object[]>> createEvaluator,QueryMetadata metadata,List<JoinExpression> joins,Predicate filter){\r\n    List<String> sourceNames = new ArrayList<String>();\r\n    List<Type> sourceTypes = new ArrayList<Type>();\r\n    List<Class<?>> sourceClasses = new ArrayList<Class<?>>();\r\n    StringBuilder vars = new StringBuilder();\r\n    CollQuerySerializer ser = new CollQuerySerializer(templates);\r\n    ser.append(\"java.util.List<Object[]> rv = new java.util.ArrayList<Object[]>();\\n\");\r\n    List<String> anyJoinMatchers = new ArrayList<String>();\r\n    for (JoinExpression join : joins) {\r\n        Expression<?> target = join.getTarget();\r\n        String typeName = com.mysema.codegen.support.ClassUtils.getName(target.getType());\r\n        if (vars.length() > 0) {\r\n            vars.append(\",\");\r\n        }\r\n        switch(join.getType()) {\r\n            case DEFAULT:\r\n                ser.append(\"for (\" + typeName + \" \" + target + \" : \" + target + \"_) {\\n\");\r\n                vars.append(target);\r\n                sourceNames.add(target + \"_\");\r\n                sourceTypes.add(new SimpleType(Types.ITERABLE, new ClassType(TypeCategory.SIMPLE, target.getType())));\r\n                sourceClasses.add(Iterable.class);\r\n                break;\r\n            case INNERJOIN:\r\n            case LEFTJOIN:\r\n                Operation<?> alias = (Operation<?>) join.getTarget();\r\n                boolean colAnyJoin = join.getCondition() != null && join.getCondition().toString().equals(\"any\");\r\n                boolean leftJoin = join.getType() == JoinType.LEFTJOIN;\r\n                String matcher = null;\r\n                if (colAnyJoin) {\r\n                    matcher = alias.getArg(1).toString() + \"_matched\";\r\n                    ser.append(\"boolean \" + matcher + \" = false;\\n\");\r\n                    anyJoinMatchers.add(matcher);\r\n                }\r\n                ser.append(\"for (\" + typeName + \" \" + alias.getArg(1) + \" : \");\r\n                if (leftJoin) {\r\n                    ser.append(CollQueryFunctions.class.getName() + \".leftJoin(\");\r\n                }\r\n                if (colAnyJoin) {\r\n                    Context context = new Context();\r\n                    Expression<?> replacement = alias.getArg(0).accept(collectionAnyVisitor, context);\r\n                    ser.handle(replacement);\r\n                } else {\r\n                    ser.handle(alias.getArg(0));\r\n                }\r\n                if (alias.getArg(0).getType().equals(Map.class)) {\r\n                    ser.append(\".values()\");\r\n                }\r\n                if (leftJoin) {\r\n                    ser.append(\")\");\r\n                }\r\n                ser.append(\") {\\n\");\r\n                if (matcher != null) {\r\n                    ser.append(\"if (!\" + matcher + \") {\\n\");\r\n                }\r\n                vars.append(alias.getArg(1));\r\n                break;\r\n            default:\r\n                throw new IllegalArgumentException(\"Illegal join expression \" + join);\r\n        }\r\n    }\r\n    if (filter != null) {\r\n        ser.append(\"try {\\n\");\r\n        ser.append(\"if (\");\r\n        ser.handle(filter).append(\") {\\n\");\r\n        for (String matcher : anyJoinMatchers) {\r\n            ser.append(\"    \" + matcher + \" = true;\\n\");\r\n        }\r\n        ser.append(\"    rv.add(new Object[]{\" + vars + \"});\\n\");\r\n        ser.append(\"}\\n\");\r\n        ser.append(\"} catch (NullPointerException npe) { }\\n\");\r\n    } else {\r\n        ser.append(\"rv.add(new Object[]{\" + vars + \"});\\n\");\r\n    }\r\n    int amount = joins.size() + anyJoinMatchers.size();\r\n    for (int i = 0; i < amount; i++) {\r\n        ser.append(\"}\\n\");\r\n    }\r\n    ser.append(\"return rv;\");\r\n    Map<Object, String> constantToLabel = ser.getConstantToLabel();\r\n    Map<String, Object> constants = getConstants(metadata, constantToLabel);\r\n    ClassType projectionType = new ClassType(TypeCategory.LIST, List.class, Types.OBJECTS);\r\n    return factory.createEvaluator(ser.toString(), projectionType, sourceNames.toArray(new String[sourceNames.size()]), sourceTypes.toArray(new Type[sourceTypes.size()]), sourceClasses.toArray(new Class<?>[sourceClasses.size()]), constants);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.multifile.PackageStats.getSubPackage",
	"Comment": "returns the deepest packagestats that contains the named resource. if the second parameter is set, creates themissing packagestats along the way.",
	"Method": "PackageStats getSubPackage(JavaTypeQualifiedName qname,boolean createIfNotFound){\r\n    if (qname.getPackageList().isEmpty()) {\r\n        return this;\r\n    }\r\n    List<String> packagePath = qname.getPackageList();\r\n    PackageStats next = this;\r\n    for (Iterator<String> it = packagePath.iterator(); it.hasNext() && next != null; ) {\r\n        String currentPackage = it.next();\r\n        if (createIfNotFound && next.subPackages.get(currentPackage) == null) {\r\n            next.subPackages.put(currentPackage, new PackageStats());\r\n        }\r\n        next = next.subPackages.get(currentPackage);\r\n    }\r\n    return next;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.cpd.token.JavaCCTokenFilter.isLanguageSpecificDiscarding",
	"Comment": "extension point for subclasses to indicate tokens are to be filtered.",
	"Method": "boolean isLanguageSpecificDiscarding(){\r\n    return false;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.properties.StringMultiProperty.containsDelimiter",
	"Comment": "returns true if the multi value delimiter is present in the string.",
	"Method": "boolean containsDelimiter(String value){\r\n    return value.indexOf(multiValueDelimiter()) >= 0;\r\n}"
}, {
	"Path": "com.querydsl.core.types.dsl.DateTimeExpression.currentDate",
	"Comment": "create an expression representing the current date as a datetimeexpression instance",
	"Method": "DateTimeExpression<Date> currentDate(DateTimeExpression<T> currentDate,Class<T> cl){\r\n    return Expressions.dateTimeOperation(cl, Ops.DateTimeOps.CURRENT_DATE);\r\n}"
}, {
	"Path": "org.powermock.api.easymock.PowerMock.createStrictPartialMockForAllMethodsExcept",
	"Comment": "mock all methods of a class except for a specific one strictly. use thismethod only if you have several overloaded methods.",
	"Method": "T createStrictPartialMockForAllMethodsExcept(Class<T> type,String methodNames,T createStrictPartialMockForAllMethodsExcept,Class<T> type,String methodNameToExclude,Class<?> firstArgumentType,Class<?> moreTypes){\r\n    final Class<?>[] argumentTypes = mergeArgumentTypes(firstArgumentType, moreTypes);\r\n    return createStrictMock(type, WhiteboxImpl.getAllMethodsExcept(type, methodNameToExclude, argumentTypes));\r\n}"
}, {
	"Path": "org.powermock.core.MockRepository.shouldSuppressStaticInitializerFor",
	"Comment": "check whether or not a class with the fully qualified name should have\tits static initializers suppressed.",
	"Method": "boolean shouldSuppressStaticInitializerFor(String className){\r\n    return suppressStaticInitializers.contains(className);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.vm.ast.AbstractVmNode.dump",
	"Comment": "override this method if you want to customize how the node dumps out itschildren.",
	"Method": "void dump(String prefix,boolean recurse,Writer writer){\r\n    final PrintWriter printWriter = writer instanceof PrintWriter ? (PrintWriter) writer : new PrintWriter(writer);\r\n    printWriter.println(toString(prefix));\r\n    if (children != null && recurse) {\r\n        for (int i = 0; i < children.length; ++i) {\r\n            final AbstractVmNode n = (AbstractVmNode) children[i];\r\n            if (n != null) {\r\n                n.dump(prefix + \" \", recurse, printWriter);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.fxdesigner.util.codearea.SimpleRegexSyntaxHighlighter.alternation",
	"Comment": "returns a regex alternation for the given words.the words must not begin with an escaped character.",
	"Method": "String alternation(String[] alternatives){\r\n    String firstChars = Arrays.stream(alternatives).map(s -> s.substring(0, 1)).distinct().reduce((s1, s2) -> s1 + s2).get();\r\n    String alt = \"(?=[\" + firstChars + \"])(?:\" + String.join(\"|\", alternatives) + \")\";\r\n    return asWord(alt);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.errorprone.BrokenNullCheckRule.findExpressionNames",
	"Comment": "find the names of variables, methods and array arguments in aprimaryexpression.",
	"Method": "void findExpressionNames(Node nullCompareVariable,List<String> results){\r\n    for (int i = 0; i < nullCompareVariable.jjtGetNumChildren(); i++) {\r\n        Node child = nullCompareVariable.jjtGetChild(i);\r\n        if (child instanceof ASTName) {\r\n            results.add(((ASTName) child).getImage());\r\n        } else if (child instanceof ASTLiteral) {\r\n            String literalImage = ((ASTLiteral) child).getImage();\r\n            if (literalImage != null) {\r\n                results.add(literalImage);\r\n            }\r\n        } else if (child instanceof ASTPrimarySuffix) {\r\n            String name = ((ASTPrimarySuffix) child).getImage();\r\n            if (StringUtils.isNotBlank(name)) {\r\n                results.add(name);\r\n            }\r\n        } else if (child instanceof ASTClassOrInterfaceType) {\r\n            String name = ((ASTClassOrInterfaceType) child).getImage();\r\n            results.add(name);\r\n        }\r\n        if (child.jjtGetNumChildren() > 0) {\r\n            findExpressionNames(child, results);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.codestyle.IdenticalCatchBranchesRule.hasSameSubTree",
	"Comment": "checks whether two nodes define the same subtree,up to the renaming of one local variable.",
	"Method": "boolean hasSameSubTree(Node node1,Node node2,String exceptionName1,String exceptionName2){\r\n    if (node1 == null && node2 == null) {\r\n        return true;\r\n    } else if (node1 == null || node2 == null) {\r\n        return false;\r\n    }\r\n    if (node1.jjtGetNumChildren() != node2.jjtGetNumChildren()) {\r\n        return false;\r\n    }\r\n    for (int num = 0; num < node1.jjtGetNumChildren(); num++) {\r\n        if (!basicEquivalence(node1.jjtGetChild(num), node2.jjtGetChild(num), exceptionName1, exceptionName2)) {\r\n            return false;\r\n        }\r\n        if (!hasSameSubTree(node1.jjtGetChild(num), node2.jjtGetChild(num), exceptionName1, exceptionName2)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "samples.junit4.suppressconstructor.SuppressConstructorDemoTest.testSuppressParentConstructor",
	"Comment": "this test makes sure that the real parent constructor has never beencalled.",
	"Method": "void testSuppressParentConstructor(){\r\n    suppress(constructor(SuppressConstructorSubclassDemo.class));\r\n    final SuppressConstructorDemo tested = new SuppressConstructorDemo(\"a message\");\r\n    assertNull(\"Message should have been null since we're skipping the execution of the constructor code.\", tested.getMessage());\r\n}"
}, {
	"Path": "org.powermock.api.mockito.PowerMockito.verifyPrivate",
	"Comment": "verify a private method invocation for a class with a given verificationmode.",
	"Method": "PrivateMethodVerification verifyPrivate(Object object,PrivateMethodVerification verifyPrivate,Object object,VerificationMode verificationMode,PrivateMethodVerification verifyPrivate,Class<?> clazz,PrivateMethodVerification verifyPrivate,Class<?> clazz,VerificationMode verificationMode){\r\n    return verifyPrivate((Object) clazz, verificationMode);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.qname.JavaTypeQualifiedName.isUnnamedPackage",
	"Comment": "returns true if the class represented by thisqualified name is in the unnamed package.",
	"Method": "boolean isUnnamedPackage(){\r\n    return packages.isEmpty();\r\n}"
}, {
	"Path": "org.powermock.api.easymock.PowerMock.suppressSpecificConstructor",
	"Comment": "this method can be used to suppress the code in a specific constructor.",
	"Method": "void suppressSpecificConstructor(Class<?> clazz,Class<?> parameterTypes){\r\n    SuppressCode.suppressSpecificConstructor(clazz, parameterTypes);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.ast.ASTLiteral.isSingleCharacterStringLiteral",
	"Comment": "returns true if this is a string literal with only one character. handlesoctal and escape characters.",
	"Method": "boolean isSingleCharacterStringLiteral(){\r\n    if (isString) {\r\n        String image = getImage();\r\n        int length = image.length();\r\n        if (length == 3) {\r\n            return true;\r\n        } else if (image.charAt(1) == '\\\\') {\r\n            return SINGLE_CHAR_ESCAPE_PATTERN.matcher(image).matches();\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.fxdesigner.MainDesignerController.onNodeItemSelected",
	"Comment": "executed when the user selects a node in a treeview or listview.",
	"Method": "void onNodeItemSelected(Node selectedValue){\r\n    nodeInfoPanelController.displayInfo(selectedValue);\r\n    sourceEditorController.setFocusNode(selectedValue);\r\n    sourceEditorController.focusNodeInTreeView(selectedValue);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.PMDConfiguration.getClassLoader",
	"Comment": "get the classloader being used by pmd when processing rules.",
	"Method": "ClassLoader getClassLoader(){\r\n    return classLoader;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.rules.RuleFactory.getPropertyValuesFrom",
	"Comment": "parses a properties element looking only for the values of the properties defined or overridden.",
	"Method": "Map<String, String> getPropertyValuesFrom(Element propertiesNode){\r\n    Map<String, String> overridenProperties = new HashMap();\r\n    for (int i = 0; i < propertiesNode.getChildNodes().getLength(); i++) {\r\n        Node node = propertiesNode.getChildNodes().item(i);\r\n        if (node.getNodeType() == Node.ELEMENT_NODE && PROPERTY.equals(node.getNodeName())) {\r\n            Entry<String, String> overridden = getPropertyValue((Element) node);\r\n            overridenProperties.put(overridden.getKey(), overridden.getValue());\r\n        }\r\n    }\r\n    return overridenProperties;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.plsql.symboltable.ScopeAndDeclarationFinder.addScope",
	"Comment": "sets the scope of a node and adjusts the scope stack accordingly. thescope on top of the stack is set as the parent of the given scope, whichis then also stored on the scope stack.",
	"Method": "void addScope(Scope newScope,PLSQLNode node){\r\n    newScope.setParent(scopes.peek());\r\n    scopes.push(newScope);\r\n    node.setScope(newScope);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.xml.XmlParserTest.testParsingDoNotExpandEntities",
	"Comment": "verifies the parsing behavior of the xml parser if entities are notexpanded.",
	"Method": "void testParsingDoNotExpandEntities(){\r\n    LanguageVersionHandler xmlVersionHandler = LanguageRegistry.getLanguage(XmlLanguageModule.NAME).getDefaultVersion().getLanguageVersionHandler();\r\n    XmlParserOptions parserOptions = new XmlParserOptions();\r\n    parserOptions.setExpandEntityReferences(false);\r\n    Parser parser = xmlVersionHandler.getParser(parserOptions);\r\n    Node document = parser.parse(null, new StringReader(XML_TEST));\r\n    assertNode(document, \"document\", 2);\r\n    Node dtdElement = document.jjtGetChild(0);\r\n    assertNode(dtdElement, \"rootElement\", 0);\r\n    Node rootElement = document.jjtGetChild(1);\r\n    assertNode(rootElement, \"rootElement\", 7);\r\n    assertTextNode(rootElement.jjtGetChild(0), \"\\\\n    \");\r\n    assertNode(rootElement.jjtGetChild(1), \"comment\", 0);\r\n    assertTextNode(rootElement.jjtGetChild(2), \"\\\\n    \");\r\n    Node child1 = rootElement.jjtGetChild(3);\r\n    assertNode(child1, \"child1\", 3, \"test\", \"1\");\r\n    assertTextNode(child1.jjtGetChild(0), \"entity: \");\r\n    assertNode(child1.jjtGetChild(1), \"pmd\", 0);\r\n    assertTextNode(child1.jjtGetChild(2), \"Copyright: PMD\\\\n    \");\r\n    assertTextNode(rootElement.jjtGetChild(4), \"\\\\n    \");\r\n    Node child2 = rootElement.jjtGetChild(5);\r\n    assertNode(child2, \"child2\", 3);\r\n    assertTextNode(child2.jjtGetChild(0), \"\\\\n      \");\r\n    assertTextNode(child2.jjtGetChild(1), \" cdata section \", \"cdata-section\");\r\n    assertTextNode(child2.jjtGetChild(2), \"\\\\n    \");\r\n    assertTextNode(rootElement.jjtGetChild(6), \"\\\\n\");\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.metrics.impl.AbstractJavaClassMetric.getMethodsAndConstructors",
	"Comment": "gets a list of all methods and constructors declared in the class.",
	"Method": "List<ASTMethodOrConstructorDeclaration> getMethodsAndConstructors(ASTAnyTypeDeclaration node){\r\n    return getDeclarationsOfType(node, ASTMethodOrConstructorDeclaration.class);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.fxdesigner.util.beans.SettingsPersistenceUtil.getDocument",
	"Comment": "returns an xml document for the given file if it exists and can be parsed.",
	"Method": "Optional<Document> getDocument(File file){\r\n    if (file.exists()) {\r\n        try (InputStream stream = Files.newInputStream(file.toPath())) {\r\n            DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\r\n            Document document = builder.parse(stream);\r\n            return Optional.of(document);\r\n        } catch (SAXException | ParserConfigurationException | IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n    return Optional.empty();\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.rule.errorprone.ConstructorCallsOverridableMethodRule.addCalledMethodsOfNode",
	"Comment": "adds all methods called on this instance from within this node.",
	"Method": "void addCalledMethodsOfNode(Node node,List<MethodInvocation> calledMethods,String className){\r\n    List<ASTPrimaryExpression> expressions = new ArrayList();\r\n    node.findDescendantsOfType(ASTPrimaryExpression.class, expressions, !(node instanceof AccessNode));\r\n    addCalledMethodsOfNodeImpl(expressions, calledMethods, className);\r\n}"
}, {
	"Path": "org.powermock.reflect.internal.WhiteboxImpl.getInternalState",
	"Comment": "get the value of a field using reflection. use this method when you needto specify in which class the field is declared. this might be usefulwhen you have mocked the instance you are trying to access. use thismethod to avoid casting.",
	"Method": "T getInternalState(Object object,String fieldName,T getInternalState,Object object,Class<T> fieldType,T getInternalState,Object object,Class<T> fieldType,Class<?> where,T getInternalState,Object object,String fieldName,Class<?> where){\r\n    if (object == null || fieldName == null || fieldName.equals(\"\") || fieldName.startsWith(\" \")) {\r\n        throw new IllegalArgumentException(\"object, field name, and \\\"where\\\" must not be empty or null.\");\r\n    }\r\n    Field field = null;\r\n    try {\r\n        field = where.getDeclaredField(fieldName);\r\n        field.setAccessible(true);\r\n        return (T) field.get(object);\r\n    } catch (NoSuchFieldException e) {\r\n        throw new FieldNotFoundException(\"Field '\" + fieldName + \"' was not found in class \" + where.getName() + \".\");\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(\"Internal error: Failed to get field in method getInternalState.\", e);\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.metrics.JavaMetrics.get",
	"Comment": "computes a metric identified by its key on a operation ast node.",
	"Method": "double get(MetricKey<ASTAnyTypeDeclaration> key,ASTAnyTypeDeclaration node,double get,MetricKey<ASTAnyTypeDeclaration> key,ASTAnyTypeDeclaration node,MetricOptions options,double get,MetricKey<MethodLikeNode> key,MethodLikeNode node,double get,MetricKey<MethodLikeNode> key,ASTMethodOrConstructorDeclaration node,double get,MetricKey<MethodLikeNode> key,ASTMethodOrConstructorDeclaration node,MetricOptions options,double get,MetricKey<MethodLikeNode> key,MethodLikeNode node,MetricOptions options,double get,MetricKey<MethodLikeNode> key,ASTAnyTypeDeclaration node,ResultOption resultOption,double get,MetricKey<MethodLikeNode> key,ASTAnyTypeDeclaration node,MetricOptions options,ResultOption resultOption){\r\n    return FACADE.computeWithResultOption(key, node, options, resultOption);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.vm.directive.Literal.isScopeProvided",
	"Comment": "since there is no processing of content, there is never a need for aninternal scope.",
	"Method": "boolean isScopeProvided(){\r\n    return false;\r\n}"
}, {
	"Path": "com.kabouzeid.gramophone.provider.SongPlayCountStore.createNewPlayedEntry",
	"Comment": "this creates a new entry that indicates a song has been played once as well as its score",
	"Method": "void createNewPlayedEntry(SQLiteDatabase database,long songId){\r\n    float newScore = getScoreMultiplierForWeek(0);\r\n    int newPlayCount = 1;\r\n    final ContentValues values = new ContentValues(3);\r\n    values.put(SongPlayCountColumns.ID, songId);\r\n    values.put(SongPlayCountColumns.PLAY_COUNT_SCORE, newScore);\r\n    values.put(SongPlayCountColumns.LAST_UPDATED_WEEK_INDEX, mNumberOfWeeksSinceEpoch);\r\n    values.put(getColumnNameForWeek(0), newPlayCount);\r\n    database.insert(SongPlayCountColumns.NAME, null, values);\r\n}"
}, {
	"Path": "com.kabouzeid.gramophone.loader.SortedLongCursor.buildCursorPositionMapping",
	"Comment": "this function populates morderedpositions with the cursor positions in the order basedon the order passed in",
	"Method": "ArrayList<Long> buildCursorPositionMapping(long[] order,String columnName){\r\n    ArrayList<Long> missingIds = new ArrayList();\r\n    mOrderedPositions = new ArrayList(mCursor.getCount());\r\n    mMapCursorPositions = new HashMap(mCursor.getCount());\r\n    final int idPosition = mCursor.getColumnIndex(columnName);\r\n    if (mCursor.moveToFirst()) {\r\n        do {\r\n            mMapCursorPositions.put(mCursor.getLong(idPosition), mCursor.getPosition());\r\n        } while (mCursor.moveToNext());\r\n        for (int i = 0; order != null && i < order.length; i++) {\r\n            final long id = order[i];\r\n            if (mMapCursorPositions.containsKey(id)) {\r\n                mOrderedPositions.add(mMapCursorPositions.get(id));\r\n                mMapCursorPositions.remove(id);\r\n            } else {\r\n                missingIds.add(id);\r\n            }\r\n        }\r\n        mCursor.moveToFirst();\r\n    }\r\n    return missingIds;\r\n}"
}, {
	"Path": "com.querydsl.core.types.FactoryExpressionBase.skipNulls",
	"Comment": "returns a wrapper expression which returns null if all arguments to newinstance are null",
	"Method": "FactoryExpression<T> skipNulls(){\r\n    return new FactoryExpressionWrapper<T>(this);\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.apex.metrics.signature.ApexOperationSigMask.restrictVisibilitiesTo",
	"Comment": "restricts the visibilities covered by the mask to the parameters.",
	"Method": "void restrictVisibilitiesTo(Visibility visibilities){\r\n    visMask.clear();\r\n    visMask.addAll(Arrays.asList(visibilities));\r\n}"
}, {
	"Path": "org.powermock.core.WildcardMatcher.matches",
	"Comment": "performs a wildcard matching for the text and pattern provided.",
	"Method": "boolean matches(String text,String pattern){\r\n    if (text == null) {\r\n        throw new IllegalArgumentException(\"text cannot be null\");\r\n    }\r\n    text += '\\0';\r\n    pattern += '\\0';\r\n    int N = pattern.length();\r\n    boolean[] states = new boolean[N + 1];\r\n    boolean[] old = new boolean[N + 1];\r\n    old[0] = true;\r\n    for (int i = 0; i < text.length(); i++) {\r\n        char c = text.charAt(i);\r\n        states = new boolean[N + 1];\r\n        for (int j = 0; j < N; j++) {\r\n            char p = pattern.charAt(j);\r\n            if (old[j] && (p == WILDCARD))\r\n                old[j + 1] = true;\r\n            if (old[j] && (p == c))\r\n                states[j + 1] = true;\r\n            if (old[j] && (p == WILDCARD))\r\n                states[j] = true;\r\n            if (old[j] && (p == WILDCARD))\r\n                states[j + 1] = true;\r\n        }\r\n        old = states;\r\n    }\r\n    return states[N];\r\n}"
}, {
	"Path": "net.sourceforge.pmd.Report.start",
	"Comment": "mark the start time of the report. this is used to get the elapsed timein the end.",
	"Method": "void start(){\r\n    start = System.currentTimeMillis();\r\n}"
}, {
	"Path": "net.sourceforge.pmd.util.fxdesigner.util.codearea.SyntaxHighlightingCodeArea.styleSyntaxHighlightChange",
	"Comment": "given the old value of the highlighting spans, and a newly computed value,computes the spans as they should be applied to the codearea. the default behavioursimply returns the newest spans, which works flawlessly when there is no otherstyle layer in the game. subclasses are free to override, to get a chance topreserve additional style layers.",
	"Method": "StyleSpans<Collection<String>> styleSyntaxHighlightChange(Optional<StyleSpans<Collection<String>>> oldSyntax,StyleSpans<Collection<String>> newSyntax){\r\n    return newSyntax;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.stat.StatisticalRuleTest.expectedTopScore",
	"Comment": "this will return the expected number of results with the given top score.",
	"Method": "int expectedTopScore(int target){\r\n    return target;\r\n}"
}, {
	"Path": "com.querydsl.core.util.BeanMap.getBean",
	"Comment": "returns the bean currently being operated on.the return value maybe null if this map is empty.",
	"Method": "Object getBean(){\r\n    return bean;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.typeresolution.ClassTypeResolverTest.testFullyQualifiedType",
	"Comment": "the type should be filled also on the astvariabledeclaratorid node, notonly on the variable name declaration.",
	"Method": "void testFullyQualifiedType(){\r\n    String source = \"public class Foo {\\n\" + \"    public void bar() {\\n\" + \"        java.util.StringTokenizer st = new StringTokenizer(\\\"a.b.c.d\\\", \\\".\\\");\\n\" + \"        while (st.hasMoreTokens()) {\\n\" + \"            System.out.println(st.nextToken());\\n\" + \"        }\\n\" + \"    }\\n\" + \"}\";\r\n    ASTCompilationUnit acu = parseAndTypeResolveForString(source, \"1.5\");\r\n    List<ASTName> names = acu.findDescendantsOfType(ASTName.class);\r\n    ASTName theStringTokenizer = null;\r\n    for (ASTName name : names) {\r\n        if (name.hasImageEqualTo(\"st.hasMoreTokens\")) {\r\n            theStringTokenizer = name;\r\n            break;\r\n        }\r\n    }\r\n    Assert.assertNotNull(theStringTokenizer);\r\n    VariableNameDeclaration declaration = (VariableNameDeclaration) theStringTokenizer.getNameDeclaration();\r\n    Assert.assertNotNull(declaration);\r\n    Assert.assertEquals(\"java.util.StringTokenizer\", declaration.getTypeImage());\r\n    Assert.assertNotNull(declaration.getType());\r\n    Assert.assertSame(StringTokenizer.class, declaration.getType());\r\n    ASTVariableDeclaratorId id = (ASTVariableDeclaratorId) declaration.getNode();\r\n    Assert.assertNotNull(id.getType());\r\n    Assert.assertSame(StringTokenizer.class, id.getType());\r\n}"
}, {
	"Path": "net.sourceforge.pmd.PMDConfiguration.setReportProperties",
	"Comment": "set the report properties. these are used to create the renderer.",
	"Method": "void setReportProperties(Properties reportProperties){\r\n    this.reportProperties = reportProperties;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.stat.StatisticalRuleTest.randomTopScore",
	"Comment": "this will return a random value for the top score which will return morethan the minimum provided.",
	"Method": "int randomTopScore(int randomTopScore,double target){\r\n    if (target < 0) {\r\n        return 0;\r\n    }\r\n    return random.nextInt(Double.valueOf(target).intValue());\r\n}"
}, {
	"Path": "org.powermock.reflect.WhiteBoxTest.testInvokeMethodWithBothNormalAndVarArgsParameter",
	"Comment": "asserts that issue118 is fixed. thanks to cemcatik for finding this.",
	"Method": "void testInvokeMethodWithBothNormalAndVarArgsParameter(){\r\n    ClassWithPrivateMethods tested = new ClassWithPrivateMethods();\r\n    assertEquals(4, Whitebox.invokeMethod(tested, \"varArgsMethod2\", 1, 2, 3));\r\n}"
}, {
	"Path": "net.sourceforge.pmd.RuleSets.ruleCount",
	"Comment": "determines the total count of rules that are used in all rule sets.",
	"Method": "int ruleCount(){\r\n    int count = 0;\r\n    for (RuleSet r : ruleSets) {\r\n        count += r.getRules().size();\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "net.sourceforge.pmd.Report.hasConfigErrors",
	"Comment": "checks whether any configuration errors have been reported.",
	"Method": "boolean hasConfigErrors(){\r\n    return configErrors != null && !configErrors.isEmpty();\r\n}"
}, {
	"Path": "net.sourceforge.pmd.lang.java.ast.ASTIfStatement.getGuardExpressionNode",
	"Comment": "returns the node that represents the guard of this conditional.this may be any expression of type boolean.",
	"Method": "ASTExpression getGuardExpressionNode(){\r\n    return (ASTExpression) jjtGetChild(0);\r\n}"
}]