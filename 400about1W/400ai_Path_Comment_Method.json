[{
	"Path": "com.querydsl.sql.SQLExpressions.percentileCont",
	"Comment": "calculates a percentile based on a continuous distribution of the column value",
	"Method": "WithinGroup<T> percentileCont(T arg,WithinGroup<T> percentileCont,Expression<T> arg){\r\n    return new WithinGroup<T>(arg.getType(), SQLOps.PERCENTILECONT, arg);\r\n}"
}, {
	"Path": "org.testcontainers.containers.wait.Wait.forListeningPort",
	"Comment": "convenience method to return a waitstrategy for an exposed or mapped port.",
	"Method": "HostPortWaitStrategy forListeningPort(){\r\n    return new HostPortWaitStrategy();\r\n}"
}, {
	"Path": "com.nanchen.rxjava2examples.ui.SystemBarTintManager.setNavigationBarTintColor",
	"Comment": "apply the specified color tint to the system navigation bar.",
	"Method": "void setNavigationBarTintColor(int color){\r\n    if (mNavBarAvailable) {\r\n        mNavBarTintView.setBackgroundColor(color);\r\n    }\r\n}"
}, {
	"Path": "uk.co.real_logic.sbe.generation.cpp.CppUtil.formatByteOrderEncoding",
	"Comment": "return the cpp98 formatted byte order encoding string to use for a given byte order and primitivetype",
	"Method": "String formatByteOrderEncoding(ByteOrder byteOrder,PrimitiveType primitiveType){\r\n    switch(primitiveType.size()) {\r\n        case 2:\r\n            return \"SBE_\" + byteOrder + \"_ENCODE_16\";\r\n        case 4:\r\n            return \"SBE_\" + byteOrder + \"_ENCODE_32\";\r\n        case 8:\r\n            return \"SBE_\" + byteOrder + \"_ENCODE_64\";\r\n        default:\r\n            return \"\";\r\n    }\r\n}"
}, {
	"Path": "com.simplecity.amp_library.services.Equalizer.closeEqualizerSessions",
	"Comment": "sends a broadcast to close any existing audio effect sessions",
	"Method": "void closeEqualizerSessions(boolean internal,int audioSessionId){\r\n    if (internal) {\r\n        Intent intent = new Intent(Equalizer.ACTION_CLOSE_EQUALIZER_SESSION);\r\n        intent.putExtra(AudioEffect.EXTRA_AUDIO_SESSION, audioSessionId);\r\n        intent.putExtra(AudioEffect.EXTRA_PACKAGE_NAME, context.getPackageName());\r\n        context.sendBroadcast(intent);\r\n    } else {\r\n        Intent intent = new Intent(AudioEffect.ACTION_CLOSE_AUDIO_EFFECT_CONTROL_SESSION);\r\n        intent.putExtra(AudioEffect.EXTRA_PACKAGE_NAME, context.getPackageName());\r\n        intent.putExtra(AudioEffect.EXTRA_AUDIO_SESSION, audioSessionId);\r\n        context.sendBroadcast(intent);\r\n        intent = new Intent(AudioEffect.ACTION_CLOSE_AUDIO_EFFECT_CONTROL_SESSION);\r\n        intent.putExtra(AudioEffect.EXTRA_PACKAGE_NAME, context.getPackageName());\r\n        intent.putExtra(AudioEffect.EXTRA_AUDIO_SESSION, 0);\r\n        context.sendBroadcast(intent);\r\n    }\r\n}"
}, {
	"Path": "spock.util.Exceptions.getRootCause",
	"Comment": "returns the innermost cause of the specified exception. if the specified exceptionhas no cause, the exception itself is returned.",
	"Method": "Throwable getRootCause(Throwable exception){\r\n    Assert.notNull(exception);\r\n    return exception.getCause() == null ? exception : getRootCause(exception.getCause());\r\n}"
}, {
	"Path": "netgloo.controllers.MainController.index",
	"Comment": "show the index page containing the form for uploading a file.",
	"Method": "String index(){\r\n    return \"index\";\r\n}"
}, {
	"Path": "com.querydsl.sql.codegen.MetaDataExporter.setBeansTargetFolder",
	"Comment": "set the target folder for beansdefaults to the targetfolder value",
	"Method": "void setBeansTargetFolder(File targetFolder){\r\n    this.beansTargetFolder = targetFolder;\r\n}"
}, {
	"Path": "org.springsource.loaded.test.MethodInvokerRewriterTests.superCallsRemovingMethods",
	"Comment": "this is similar to the first case except the hierarchy is split such that a middle type exists where the methods\tinitially exist but then they are removed in a reload. we should end up at the top level methods.",
	"Method": "void superCallsRemovingMethods(){\r\n    TypeRegistry tr = getTypeRegistry(\"invokespecial..*\");\r\n    ReloadableType a = loadType(tr, \"invokespecial.A\");\r\n    ReloadableType b = loadType(tr, \"invokespecial.B\");\r\n    ReloadableType c = loadType(tr, \"invokespecial.C\");\r\n    Object object = c.getClazz().newInstance();\r\n    Method method = null;\r\n    String string = null;\r\n    method = c.getClazz().getMethod(\"run1\");\r\n    string = (String) method.invoke(object);\r\n    assertEquals(\"66\", string);\r\n    method = c.getClazz().getMethod(\"run2\");\r\n    string = (String) method.invoke(object);\r\n    assertEquals(\"66falseabc\", string);\r\n    b.loadNewVersion(\"002\", retrieveRename(\"invokespecial.B\", \"invokespecial.B002\"));\r\n    method = c.getClazz().getMethod(\"run1\");\r\n    string = (String) method.invoke(object);\r\n    assertEquals(\"65\", string);\r\n    method = c.getClazz().getMethod(\"run2\");\r\n    string = (String) method.invoke(object);\r\n    assertEquals(\"65falseabc\", string);\r\n    a.loadNewVersion(\"002\", retrieveRename(\"invokespecial.A\", \"invokespecial.A002\"));\r\n    method = c.getClazz().getMethod(\"run1\");\r\n    try {\r\n        string = (String) method.invoke(object);\r\n        fail();\r\n    } catch (InvocationTargetException ite) {\r\n        assertEquals(\"java.lang.NoSuchMethodError\", ite.getCause().getClass().getName());\r\n        assertEquals(\"invokespecial.A.getInt()I\", ite.getCause().getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.springsource.loaded.TypeRegistry.isReloadableTypeName",
	"Comment": "determine if the type specified is a reloadable type. this method works purely by name, it does not load\tanything.",
	"Method": "boolean isReloadableTypeName(String slashedName,ReloadableTypeNameDecision isReloadableTypeName,String slashedName,ProtectionDomain protectionDomain,byte[] bytes){\r\n    if (GlobalConfiguration.verboseMode && log.isLoggable(Level.FINER)) {\r\n        log.finer(\"entering TypeRegistry.isReloadableTypeName(\" + slashedName + \")\");\r\n    }\r\n    if (slashedName == null) {\r\n        return ReloadableTypeNameDecision.No;\r\n    }\r\n    if (GlobalConfiguration.assertsMode) {\r\n        Utils.assertSlashed(slashedName);\r\n    }\r\n    if (GlobalConfiguration.isProfiling) {\r\n        if (slashedName.startsWith(\"com/yourkit\")) {\r\n            if (GlobalConfiguration.explainMode && log.isLoggable(Level.FINER)) {\r\n                log.finer(\"[explanation] The type \" + slashedName + \" is considered part of yourkit and is not being made reloadable\");\r\n            }\r\n            return ReloadableTypeNameDecision.No;\r\n        }\r\n    }\r\n    for (IsReloadableTypePlugin plugin : SpringLoadedPreProcessor.getIsReloadableTypePlugins()) {\r\n        ReloadDecision decision = plugin.shouldBeMadeReloadable(this, slashedName, protectionDomain, bytes);\r\n        if (decision == ReloadDecision.YES) {\r\n            if (GlobalConfiguration.explainMode && log.isLoggable(Level.FINER)) {\r\n                log.finer(\"[explanation] The plugin \" + plugin.getClass().getName() + \" determined type \" + slashedName + \" is reloadable\");\r\n            }\r\n            return ReloadableTypeNameDecision.Yes;\r\n        } else if (decision == ReloadDecision.NO) {\r\n            if (GlobalConfiguration.explainMode && log.isLoggable(Level.FINER)) {\r\n                log.finer(\"[explanation] The plugin \" + plugin.getClass().getName() + \" determined type \" + slashedName + \" is not reloadable\");\r\n            }\r\n            return ReloadableTypeNameDecision.No;\r\n        }\r\n    }\r\n    if (inclusionPatterns.isEmpty()) {\r\n        if (exclusionPatterns.isEmpty()) {\r\n            CouldBeReloadableDecision cbrd = couldBeReloadable(slashedName, true);\r\n            if (cbrd.couldBeReloadable) {\r\n                if (GlobalConfiguration.explainMode && log.isLoggable(Level.FINER)) {\r\n                    log.finer(\"[explanation] The class \" + slashedName + \" is currently considered reloadable. It matches no exclusions, is accessible from this classloader and is not in a jar/zip.\");\r\n                }\r\n                return new ReloadableTypeNameDecision(true, cbrd, null, true, false);\r\n            } else {\r\n                if (GlobalConfiguration.explainMode && log.isLoggable(Level.FINER)) {\r\n                    log.finer(\"[explanation] The class \" + slashedName + \" is not going to be treated as reloadable.\");\r\n                }\r\n                return new ReloadableTypeNameDecision(false, cbrd, null, true, false);\r\n            }\r\n        } else {\r\n            if (slashedName != null) {\r\n                boolean isExcluded = false;\r\n                String matchName = slashedName.replace('/', '.');\r\n                for (TypePattern typepattern : exclusionPatterns) {\r\n                    if (typepattern.matches(matchName)) {\r\n                        isExcluded = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (isExcluded) {\r\n                    return new ReloadableTypeNameDecision(false, null, null, false, false);\r\n                }\r\n            }\r\n            CouldBeReloadableDecision cbrd = couldBeReloadable(slashedName, true);\r\n            if (cbrd.couldBeReloadable) {\r\n                return new ReloadableTypeNameDecision(true, cbrd, null, false, false);\r\n            } else {\r\n                return new ReloadableTypeNameDecision(false, cbrd, null, false, false);\r\n            }\r\n        }\r\n    } else {\r\n        String matchName = null;\r\n        if (slashedName != null) {\r\n            boolean isIncluded = false;\r\n            matchName = slashedName.replace('/', '.');\r\n            for (TypePattern typepattern : inclusionPatterns) {\r\n                if (typepattern.matches(matchName)) {\r\n                    isIncluded = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!isIncluded) {\r\n                if (!GlobalConfiguration.InTestMode) {\r\n                    CouldBeReloadableDecision cbrd = couldBeReloadable(slashedName, true);\r\n                    if (cbrd.couldBeReloadable) {\r\n                        return new ReloadableTypeNameDecision(true, cbrd, null, true, false);\r\n                    }\r\n                }\r\n                return ReloadableTypeNameDecision.No;\r\n            }\r\n        }\r\n        if (exclusionPatterns.isEmpty()) {\r\n            return new ReloadableTypeNameDecision(true, null, null, true, true);\r\n        } else {\r\n            boolean isExcluded = false;\r\n            if (slashedName != null) {\r\n                for (TypePattern typepattern : exclusionPatterns) {\r\n                    if (typepattern.matches(matchName)) {\r\n                        isExcluded = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            return new ReloadableTypeNameDecision(!isExcluded, null, null, true, true);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springsource.loaded.test.SuperDispatcherTests.noSuperDispatcher",
	"Comment": "a reloadable type extends a type and overrides a method from that type. this time the overridden method is not\tprotected so no superdispatcher is needed.",
	"Method": "void noSuperDispatcher(){\r\n    String t = \"foo.ControllerC\";\r\n    TypeRegistry typeRegistry = getTypeRegistry(t);\r\n    ReloadableType rtype = typeRegistry.addType(t, loadBytesForClass(t));\r\n    String rtypeDisassembled = toStringClass(rtype.bytesLoaded);\r\n    assertEquals(15, countMethods(rtype.bytesLoaded));\r\n    assertEquals(0, filter(getMethods(rtype.bytesLoaded), methodSuffixSuperDispatcher).size());\r\n    String expectedName = \"foo\" + methodSuffixSuperDispatcher;\r\n    assertDoesNotContain(\"METHOD: 0x0001(public) \" + expectedName + \"()V\", rtypeDisassembled);\r\n    String stdout = runOnInstance(rtype.getClazz(), rtype.getClazz().newInstance(), \"foo\").stdout;\r\n    assertEquals(\"TopC.foo() running\\nControllerC.foo() running\", stdout);\r\n    Assert.assertTrue(rtype.loadNewVersion(\"2\", retrieveRename(t, t + \"2\")));\r\n    stdout = runOnInstance(rtype.getClazz(), rtype.getClazz().newInstance(), \"foo\").stdout;\r\n    assertEquals(\"TopC.foo() running\\nControllerC.foo() running again!\", stdout);\r\n}"
}, {
	"Path": "com.querydsl.spatial.jts.JTSGeometryExpressions.dwithin",
	"Comment": "returns true if the geometries are within the specified distance of one another.for geometry units are in those of spatial reference and for geography units are in meters.",
	"Method": "BooleanExpression dwithin(Expression<? extends Geometry> expr1,Expression<? extends Geometry> expr2,Expression<Double> distance,BooleanExpression dwithin,Expression<? extends Geometry> expr1,Expression<? extends Geometry> expr2,double distance){\r\n    return Expressions.booleanOperation(SpatialOps.DWITHIN, expr1, expr2, ConstantImpl.create(distance));\r\n}"
}, {
	"Path": "org.unitils.core.dbsupport.H2DbSupport.disableNotNullConstraints",
	"Comment": "disables all not null constraints on all tables in the schema",
	"Method": "void disableNotNullConstraints(){\r\n    Connection connection = null;\r\n    Statement queryStatement = null;\r\n    Statement alterStatement = null;\r\n    ResultSet resultSet = null;\r\n    try {\r\n        connection = getSQLHandler().getDataSource().getConnection();\r\n        queryStatement = connection.createStatement();\r\n        alterStatement = connection.createStatement();\r\n        resultSet = queryStatement.executeQuery(\"select col.TABLE_NAME, \" + \"col.COLUMN_NAME from INFORMATION_SCHEMA.COLUMNS col where \" + \"col.IS_NULLABLE = 'NO' and col.TABLE_SCHEMA = '\" + getSchemaName() + \"' \" + \"AND NOT EXISTS (select COLUMN_NAME \" + \"from INFORMATION_SCHEMA.INDEXES pk where pk.TABLE_NAME = \" + \"col.TABLE_NAME and pk.COLUMN_NAME = col.COLUMN_NAME and \" + \"pk.TABLE_SCHEMA = '\" + getSchemaName() + \"' AND pk.PRIMARY_KEY = TRUE)\");\r\n        while (resultSet.next()) {\r\n            String tableName = resultSet.getString(\"TABLE_NAME\");\r\n            String columnName = resultSet.getString(\"COLUMN_NAME\");\r\n            alterStatement.executeUpdate(\"alter table \" + qualified(tableName) + \" alter column \" + quoted(columnName) + \" set null\");\r\n        }\r\n    } catch (Exception e) {\r\n        throw new UnitilsException(\"Error while disabling not null \" + \"constraints on schema \" + getSchemaName(), e);\r\n    } finally {\r\n        closeQuietly(queryStatement);\r\n        closeQuietly(connection, alterStatement, resultSet);\r\n    }\r\n}"
}, {
	"Path": "org.springsource.loaded.test.CglibProxyTests.testSimpleProxyWithSuperCallsWithFastClass",
	"Comment": "variation of the test above, but now the super calls are allowed to occur. this means fastclass objects will be\tcreated by cglib, these also need auto regenerating and reloading.",
	"Method": "void testSimpleProxyWithSuperCallsWithFastClass(){\r\n    String t = \"example.ProxyTestcase\";\r\n    Class<?> clazz = binLoader.loadClass(t);\r\n    String output = runMethodAndCollectOutput(clazz, \"run\");\r\n    assertContains(\"[void example.Simple.moo()]\", output);\r\n    assertContains(\"Simple.moo() running\", output);\r\n    ReloadableType rtype = TypeRegistry.getTypeRegistryFor(binLoader).getReloadableType(toSlash(t), false);\r\n    assertNotNull(rtype);\r\n    Set<String> rtypesForFastClass = getFastClasses(TypeRegistry.getTypeRegistryFor(binLoader).getReloadableTypes());\r\n    assertEquals(2, rtypesForFastClass.size());\r\n    assertContains(\"example.Simple$$FastClassByCGLIB$$........\", rtypesForFastClass.toString());\r\n    assertContains(\"example.Simple$$EnhancerByCGLIB$$........$$FastClassByCGLIB$$........\", rtypesForFastClass.toString());\r\n    ReloadableType rtype2 = TypeRegistry.getTypeRegistryFor(binLoader).getReloadableType(toSlash(\"example.Simple\"), false);\r\n    assertNotNull(rtype2);\r\n    rtype.loadNewVersion(retrieveRename(t, t + \"2\", \"example.Simple2:example.Simple\"));\r\n    rtype2.loadNewVersion(retrieveRename(\"example.Simple\", \"example.Simple2\"));\r\n    output = runMethodAndCollectOutput(clazz, \"run\");\r\n    assertContains(\"Simple2.boo() running\", output);\r\n    assertContains(\"[void example.Simple.boo()]\", output);\r\n    output = runMethodAndCollectOutput(clazz, \"runMoo\");\r\n    assertContains(\"Simple2.moo() running\", output);\r\n    assertContains(\"[void example.Simple.moo()]\", output);\r\n    output = runMethodAndCollectOutput(clazz, \"runBar\");\r\n    assertContains(\"Simple2.bar(1,abc,3) running\", output);\r\n    assertContains(\"[public void example.Simple.bar(int,java.lang.String,long)]\", output);\r\n}"
}, {
	"Path": "com.klinker.android.twitter.utils.text.Regex.digitsAndPlusOnly",
	"Comment": "convenience method to return only the digits and plus signsin the matching string.",
	"Method": "String digitsAndPlusOnly(Matcher matcher){\r\n    StringBuilder buffer = new StringBuilder();\r\n    String matchingRegion = matcher.group();\r\n    for (int i = 0, size = matchingRegion.length(); i < size; i++) {\r\n        char character = matchingRegion.charAt(i);\r\n        if (character == '+' || Character.isDigit(character)) {\r\n            buffer.append(character);\r\n        }\r\n    }\r\n    return buffer.toString();\r\n}"
}, {
	"Path": "org.springsource.loaded.ConstantPoolScanner.accessUtf8",
	"Comment": "return the utf8 at the specified index in the constant pool. the data found at the constant pool for that index\tmay not have been unpacked yet if this is the first access of the string. if not unpacked the constant pool entry\tis a pair of ints in an array representing the offset and length within the classbytes where the utf8 string is\tencoded. once decoded the constant pool entry is flipped from an int array to a string for future fast access.",
	"Method": "String accessUtf8(int cpIndex){\r\n    Object object = cpdata[cpIndex];\r\n    if (object instanceof String) {\r\n        return (String) object;\r\n    }\r\n    int[] ptrAndLen = (int[]) object;\r\n    String value;\r\n    try {\r\n        value = new String(classbytes, ptrAndLen[0], ptrAndLen[1], \"UTF8\");\r\n    } catch (UnsupportedEncodingException e) {\r\n        throw new IllegalStateException(\"Bad data found at constant pool position \" + cpIndex + \" offset=\" + ptrAndLen[0] + \" length=\" + ptrAndLen[1], e);\r\n    }\r\n    cpdata[cpIndex] = value;\r\n    return value;\r\n}"
}, {
	"Path": "com.querydsl.spatial.jts.JTSGeometryExpression.intersection",
	"Comment": "returns a geometric object that represents the point set intersection of this geometricobject with anothergeometry.",
	"Method": "JTSGeometryExpression<Geometry> intersection(Geometry geometry,JTSGeometryExpression<Geometry> intersection,Expression<? extends Geometry> geometry){\r\n    return JTSGeometryExpressions.geometryOperation(SpatialOps.INTERSECTION, mixin, geometry);\r\n}"
}, {
	"Path": "org.springsource.loaded.FieldReaderWriter.locateFieldByReflection",
	"Comment": "discover the named field in the hierarchy using the standard rules of resolution.",
	"Method": "Field locateFieldByReflection(Class<?> clazz,String typeWanted,boolean isInterface,String name){\r\n    if (clazz.getName().equals(typeWanted)) {\r\n        Field[] fs = clazz.getDeclaredFields();\r\n        if (fs != null) {\r\n            for (Field f : fs) {\r\n                if (f.getName().equals(name)) {\r\n                    return f;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (!isInterface) {\r\n        Class<?>[] interfaces = clazz.getInterfaces();\r\n        if (interfaces != null) {\r\n            for (Class<?> intface : interfaces) {\r\n                Field f = locateFieldByReflection(intface, typeWanted, isInterface, name);\r\n                if (f != null) {\r\n                    return f;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    Class<?> superclass = clazz.getSuperclass();\r\n    if (superclass == null) {\r\n        return null;\r\n    } else {\r\n        return locateFieldByReflection(superclass, typeWanted, isInterface, name);\r\n    }\r\n}"
}, {
	"Path": "io.rx_cache2.internal.cache.memory.apache.AbstractHashedMap.createEntrySetIterator",
	"Comment": "creates an entry set iterator.subclasses can override this to return iterators with different properties.",
	"Method": "Iterator<Map.Entry<K, V>> createEntrySetIterator(){\r\n    if (size() == 0) {\r\n        return io.rx_cache2.internal.cache.memory.apache.EmptyIterator.<Map.Entry<K, V>>emptyIterator();\r\n    }\r\n    return new EntrySetIterator<K, V>(this);\r\n}"
}, {
	"Path": "org.springsource.loaded.testgen.GenerativeTest.assertEqualExceptions",
	"Comment": "this method gets called to compare two resultexceptions, but only when the standard equals method returned false.\tsubclasses may override this to relax the equality check.",
	"Method": "void assertEqualExceptions(ResultException expected,ResultException actual){\r\n    throw new ComparisonFailure(null, expected.toString(), actual.toString());\r\n}"
}, {
	"Path": "org.springsource.loaded.ri.ReflectiveInterceptor.asSetableField",
	"Comment": "performs all necessary checks that need to be done before a field set should be allowed.",
	"Method": "Field asSetableField(Field field,Object target,Class<?> valueType,Object value,boolean makeAccessibleCopy){\r\n    if (isDeleted(field)) {\r\n        throw Exceptions.noSuchFieldError(field);\r\n    }\r\n    Class<?> clazz = field.getDeclaringClass();\r\n    int mods = field.getModifiers();\r\n    if (field.isAccessible() || Modifier.isPublic(mods & jlClassGetModifiers(clazz))) {\r\n    } else {\r\n        Class<?> callerClass = getCallerClass();\r\n        JVM.ensureMemberAccess(callerClass, clazz, target, mods);\r\n        if (makeAccessibleCopy) {\r\n            field = JVM.copyField(field);\r\n            field.setAccessible(true);\r\n        }\r\n    }\r\n    if (isPrimitive(valueType)) {\r\n        typeCheckFieldSet(field, valueType, value);\r\n        if (!field.isAccessible() && Modifier.isFinal(mods)) {\r\n            throw Exceptions.illegalSetFinalFieldException(field, field.getType(), coerce(value, field.getType()));\r\n        }\r\n    } else {\r\n        if (!field.isAccessible() && Modifier.isFinal(mods)) {\r\n            throw Exceptions.illegalSetFinalFieldException(field, valueType, value);\r\n        }\r\n        typeCheckFieldSet(field, valueType, value);\r\n    }\r\n    return makeAccessibleCopy ? field : null;\r\n}"
}, {
	"Path": "org.springsource.loaded.Utils.insertPopsForAllParameters",
	"Comment": "looks at the supplied descriptor and inserts enough pops to remove all parameters. should be used when about to\tavoid a method call.",
	"Method": "int insertPopsForAllParameters(MethodVisitor mv,String desc){\r\n    String descSequence = Utils.getParamSequence(desc);\r\n    if (descSequence == null) {\r\n        return 0;\r\n    }\r\n    int count = descSequence.length();\r\n    for (int dpos = count - 1; dpos >= 0; dpos--) {\r\n        char ch = descSequence.charAt(dpos);\r\n        switch(ch) {\r\n            case 'O':\r\n            case 'I':\r\n            case 'Z':\r\n            case 'F':\r\n            case 'S':\r\n            case 'C':\r\n            case 'B':\r\n                mv.visitInsn(POP);\r\n                break;\r\n            case 'J':\r\n            case 'D':\r\n                mv.visitInsn(POP2);\r\n                break;\r\n            default:\r\n                throw new IllegalStateException(\"Unexpected character: \" + ch + \" from \" + desc + \":\" + dpos);\r\n        }\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "netgloo.search.UserSearch.search",
	"Comment": "a basic search for the entity user. the search is done by exact match perkeywords on fields name, city and email.",
	"Method": "List<User> search(String text){\r\n    FullTextEntityManager fullTextEntityManager = org.hibernate.search.jpa.Search.getFullTextEntityManager(entityManager);\r\n    QueryBuilder queryBuilder = fullTextEntityManager.getSearchFactory().buildQueryBuilder().forEntity(User.class).get();\r\n    org.apache.lucene.search.Query query = queryBuilder.keyword().onFields(\"name\", \"city\", \"email\").matching(text).createQuery();\r\n    org.hibernate.search.jpa.FullTextQuery jpaQuery = fullTextEntityManager.createFullTextQuery(query, User.class);\r\n    @SuppressWarnings(\"unchecked\")\r\n    List<User> results = jpaQuery.getResultList();\r\n    return results;\r\n}"
}, {
	"Path": "org.testcontainers.ext.ScriptUtils.containsSqlScriptDelimiters",
	"Comment": "does the provided sql script contain the specified delimiter?",
	"Method": "boolean containsSqlScriptDelimiters(String script,String delim){\r\n    boolean inLiteral = false;\r\n    char[] content = script.toCharArray();\r\n    for (int i = 0; i < script.length(); i++) {\r\n        if (content[i] == '\\'') {\r\n            inLiteral = !inLiteral;\r\n        }\r\n        if (!inLiteral && script.startsWith(delim, i)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.spockframework.util.inspector.AstInspector.getStatement",
	"Comment": "returns the first statement found immediately preceded by a label with thespecified name.",
	"Method": "Statement getStatement(String name){\r\n    return getNode(statements, name);\r\n}"
}, {
	"Path": "com.klinker.android.twitter.views.swipe_refresh_layout.FullScreenSwipeRefreshLayout.setOnRefreshListener",
	"Comment": "set the listener to be notified when a refresh is triggered via the swipegesture.",
	"Method": "void setOnRefreshListener(OnRefreshListener listener){\r\n    mListener = listener;\r\n}"
}, {
	"Path": "com.simplecity.amp_library.utils.FileHelper.resolveSymlink",
	"Comment": "method that resolves a symbolic link to the real file or directory.",
	"Method": "File resolveSymlink(File file){\r\n    return file.getCanonicalFile();\r\n}"
}, {
	"Path": "org.testcontainers.junit.wait.strategy.HttpWaitStrategyTest.createHttpWaitStrategy",
	"Comment": "create a httpwaitstrategy instance with a waituntilready implementation",
	"Method": "HttpWaitStrategy createHttpWaitStrategy(AtomicBoolean ready){\r\n    return new HttpWaitStrategy() {\r\n        @Override\r\n        protected void waitUntilReady() {\r\n            super.waitUntilReady();\r\n            ready.set(true);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.testcontainers.junit.wait.strategy.HttpWaitStrategyTest.createHttpWaitStrategy",
	"Comment": "create a httpwaitstrategy instance with a waituntilready implementation",
	"Method": "HttpWaitStrategy createHttpWaitStrategy(AtomicBoolean ready){\r\n    super.waitUntilReady();\r\n    ready.set(true);\r\n}"
}, {
	"Path": "org.spockframework.runtime.model.MethodInfo.invoke",
	"Comment": "invokes this method on the specified target and with the specified arguments.does not handle interceptors.",
	"Method": "Object invoke(Object target,Object arguments){\r\n    return ReflectionUtil.invokeMethod(target, getReflection(), arguments);\r\n}"
}, {
	"Path": "com.querydsl.spatial.jts.JTSMultiCurveExpression.length",
	"Comment": "the length of this multicurve which is equal to the sum of the lengths of the elementcurves.",
	"Method": "NumberExpression<Double> length(){\r\n    if (length == null) {\r\n        length = Expressions.numberOperation(Double.class, SpatialOps.LENGTH, mixin);\r\n    }\r\n    return length;\r\n}"
}, {
	"Path": "org.spockframework.compiler.InteractionRewriter.rewrite",
	"Comment": "if the given statement is a valid interaction definition, returns the rewritten statement.if the given statement is not an interaction definition, returns null.if the given statement is an invalid interaction definition, records a compile errorand returns null.",
	"Method": "ExpressionStatement rewrite(ExpressionStatement stat){\r\n    try {\r\n        if (!isInteraction(stat))\r\n            return null;\r\n        createBuilder();\r\n        setCount();\r\n        setCall();\r\n        addResponses();\r\n        build();\r\n        return register();\r\n    } catch (InvalidSpecCompileException e) {\r\n        resources.getErrorReporter().error(e);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.springsource.loaded.testgen.ExploreAllChoicesRunner.sanitise",
	"Comment": "certain characters confuse the eclipse junit view... replace those with harmless ones.",
	"Method": "String sanitise(String displayName){\r\n    return displayName.replace('(', '[').replace(')', ']').replace('\\n', ' ').replace('\\r', ' ');\r\n}"
}, {
	"Path": "com.squareup.tape2.QueueFileTest.testFileExpansionCorrectlyZeroesData",
	"Comment": "exercise a bug where file expansion would leave garbage at the start of the headerand after the last element.",
	"Method": "void testFileExpansionCorrectlyZeroesData(){\r\n    QueueFile queue = newQueueFile();\r\n    byte[][] values = new byte[5][];\r\n    for (int blockNum = 0; blockNum < values.length; blockNum++) {\r\n        values[blockNum] = new byte[1024];\r\n        for (int i = 0; i < values[blockNum].length; i++) {\r\n            values[blockNum][i] = (byte) (blockNum + 1);\r\n        }\r\n    }\r\n    queue.add(values[0]);\r\n    queue.add(values[1]);\r\n    queue.remove();\r\n    queue.add(values[2]);\r\n    queue.add(values[3]);\r\n    queue.add(values[4]);\r\n    int firstElementPadding = Element.HEADER_LENGTH + 1024;\r\n    byte[] data = new byte[firstElementPadding];\r\n    queue.raf.seek(headerLength);\r\n    queue.raf.readFully(data, 0, firstElementPadding);\r\n    assertThat(data).isEqualTo(new byte[firstElementPadding]);\r\n    int endOfLastElement = headerLength + firstElementPadding + 4 * (Element.HEADER_LENGTH + 1024);\r\n    int readLength = (int) (queue.raf.length() - endOfLastElement);\r\n    data = new byte[readLength];\r\n    queue.raf.seek(endOfLastElement);\r\n    queue.raf.readFully(data, 0, readLength);\r\n    assertThat(data).isEqualTo(new byte[readLength]);\r\n}"
}, {
	"Path": "com.simplecity.amp_library.utils.DrawableUtils.getColoredBitmap",
	"Comment": "takes a drawable resource and applies the current theme highlight color to it",
	"Method": "Bitmap getColoredBitmap(Context context,int baseDrawableResId){\r\n    Drawable baseDrawable = ContextCompat.getDrawable(context, baseDrawableResId).getConstantState().newDrawable();\r\n    ColorFilter highlightColorFilter = new LightingColorFilter(Aesthetic.get(context).colorPrimary().blockingFirst(), 0);\r\n    baseDrawable.mutate().setColorFilter(highlightColorFilter);\r\n    Bitmap bitmap = Bitmap.createBitmap(baseDrawable.getIntrinsicWidth(), baseDrawable.getIntrinsicHeight(), Bitmap.Config.ARGB_8888);\r\n    Canvas canvas = new Canvas(bitmap);\r\n    baseDrawable.setBounds(0, 0, canvas.getWidth(), canvas.getHeight());\r\n    baseDrawable.draw(canvas);\r\n    return bitmap;\r\n}"
}, {
	"Path": "org.testcontainers.containers.GenericContainer.createVolumeDirectory",
	"Comment": "creates a directory on the local filesystem which will be mounted as a volume for the container.",
	"Method": "Path createVolumeDirectory(boolean temporary){\r\n    Path directory = new File(\".tmp-volume-\" + System.currentTimeMillis()).toPath();\r\n    PathUtils.mkdirp(directory);\r\n    if (temporary)\r\n        Runtime.getRuntime().addShutdownHook(new Thread(DockerClientFactory.TESTCONTAINERS_THREAD_GROUP, () -> {\r\n            PathUtils.recursiveDeleteDir(directory);\r\n        }));\r\n    return directory;\r\n}"
}, {
	"Path": "com.querydsl.sql.SQLExpressions.covarPop",
	"Comment": "corr returns the coefficient of correlation of a set of number pairs.",
	"Method": "WindowOver<Double> covarPop(Expression<? extends Number> expr1,Expression<? extends Number> expr2){\r\n    return new WindowOver<Double>(Double.class, SQLOps.COVARPOP, expr1, expr2);\r\n}"
}, {
	"Path": "uk.co.real_logic.sbe.PrimitiveValue.byteArrayValue",
	"Comment": "return byte array value for this primitivevalue given a particular type",
	"Method": "byte[] byteArrayValue(byte[] byteArrayValue,PrimitiveType type){\r\n    if (representation == Representation.BYTE_ARRAY) {\r\n        return byteArrayValue;\r\n    } else if (representation == Representation.LONG && size == 1 && type == PrimitiveType.CHAR) {\r\n        byteArrayValueForLong[0] = (byte) longValue;\r\n        return byteArrayValueForLong;\r\n    }\r\n    throw new IllegalStateException(\"PrimitiveValue is not a byte[] representation\");\r\n}"
}, {
	"Path": "org.springsource.loaded.TypeRegistry.methodCallRewriteUseCacheIfAvailable",
	"Comment": "this version will attempt to use a cache if one is being managed.",
	"Method": "byte[] methodCallRewriteUseCacheIfAvailable(String slashedClassName,byte[] bytes){\r\n    if (GlobalConfiguration.isCaching) {\r\n        return MethodInvokerRewriter.rewriteUsingCache(slashedClassName, this, bytes);\r\n    } else {\r\n        return MethodInvokerRewriter.rewrite(this, bytes);\r\n    }\r\n}"
}, {
	"Path": "org.springsource.loaded.ReloadableType.getCurrentMethod",
	"Comment": "gets the method corresponding to given name and descriptor, taking into consideration changes that have happened\tby reloading.",
	"Method": "MethodMember getCurrentMethod(String name,String descriptor){\r\n    if (liveVersion == null) {\r\n        return getMethod(name, descriptor);\r\n    } else {\r\n        return liveVersion.getReloadableMethod(name, descriptor);\r\n    }\r\n}"
}, {
	"Path": "uk.co.real_logic.sbe.generation.java.JavaUtil.generateOptionDecodeJavadoc",
	"Comment": "generate the javadoc comment header for a bitset choice option decode method.",
	"Method": "String generateOptionDecodeJavadoc(String indent,Token optionToken){\r\n    final String description = optionToken.description();\r\n    if (null == description || description.isEmpty()) {\r\n        return \"\";\r\n    }\r\n    return indent + \"/**\\n\" + indent + \" * \" + description + '\\n' + indent + \" *\\n\" + indent + \" * @return true if \" + optionToken.name() + \" is set or false if not\\n\" + indent + \" */\\n\";\r\n}"
}, {
	"Path": "com.querydsl.spatial.GeometryExpression.difference",
	"Comment": "returns a geometric object that represents the pointset difference of this geometric object with anothergeometry.",
	"Method": "GeometryExpression<Geometry> difference(Geometry geometry,GeometryExpression<Geometry> difference,Expression<? extends Geometry> geometry){\r\n    return GeometryExpressions.geometryOperation(SpatialOps.DIFFERENCE, mixin, geometry);\r\n}"
}, {
	"Path": "org.springsource.loaded.CurrentLiveVersion.define",
	"Comment": "defines this version. called up front but can also be called later if the childclassloader in a type registry is\tdiscarded and recreated.",
	"Method": "void define(){\r\n    staticInitializer = null;\r\n    haveLookedForStaticInitializer = false;\r\n    if (!typeDescriptor.isInterface()) {\r\n        try {\r\n            dispatcherClass = reloadableType.typeRegistry.defineClass(dispatcherName, dispatcher, false);\r\n        } catch (RuntimeException t) {\r\n            if (t.getMessage().indexOf(\"duplicate class definition\") == -1) {\r\n                throw t;\r\n            } else {\r\n                t.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n    try {\r\n        executorClass = reloadableType.typeRegistry.defineClass(executorName, executor, false);\r\n    } catch (RuntimeException t) {\r\n        if (t.getMessage().indexOf(\"duplicate class definition\") == -1) {\r\n            throw t;\r\n        } else {\r\n            t.printStackTrace();\r\n        }\r\n    }\r\n    if (!typeDescriptor.isInterface()) {\r\n        try {\r\n            dispatcherInstance = dispatcherClass.newInstance();\r\n        } catch (InstantiationException e) {\r\n            throw new RuntimeException(\"Unable to build dispatcher class instance\", e);\r\n        } catch (IllegalAccessException e) {\r\n            throw new RuntimeException(\"Unable to build dispatcher class instance\", e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.querydsl.spatial.jts.JTSPolygonExpression.interiorRingN",
	"Comment": "returns the n th interior ring for this polygon as a linestring.",
	"Method": "JTSLineStringExpression<LineString> interiorRingN(int idx){\r\n    return JTSGeometryExpressions.lineStringOperation(SpatialOps.INTERIOR_RINGN, mixin, ConstantImpl.create(idx));\r\n}"
}, {
	"Path": "reflection.fields.FieldSetAccessTarget002.setFieldWithAccess",
	"Comment": "sets a field in class, can override access constraints if requested to do so.",
	"Method": "void setFieldWithAccess(Class<?> targetClass,String whichField,boolean setAccess){\r\n    Object targetInstance = targetClass.newInstance();\r\n    Field field = targetClass.getDeclaredField(whichField);\r\n    if (setAccess) {\r\n        field.setAccessible(true);\r\n    }\r\n    if (field.getType().equals(int.class)) {\r\n        field.set(targetInstance, 888);\r\n    } else {\r\n        field.set(targetInstance, \"<BANG>\");\r\n    }\r\n}"
}, {
	"Path": "uk.co.real_logic.sbe.ir.Encoding.semanticType",
	"Comment": "the semantic type of an encoding which can have relevance to the application layer.",
	"Method": "String semanticType(Builder semanticType,String semanticType){\r\n    return semanticType;\r\n}"
}, {
	"Path": "org.testcontainers.jdbc.ContainerDatabaseDriver.wrapConnection",
	"Comment": "wrap the connection, setting up a callback to be called when the connection is closed.when there are no more open connections, the container itself will be stopped.",
	"Method": "Connection wrapConnection(Connection connection,JdbcDatabaseContainer container,ConnectionUrl connectionUrl){\r\n    final boolean isDaemon = connectionUrl.isInDaemonMode();\r\n    Set<Connection> connections = containerConnections.computeIfAbsent(container.getContainerId(), k -> new HashSet());\r\n    connections.add(connection);\r\n    final Set<Connection> finalConnections = connections;\r\n    return new ConnectionWrapper(connection, () -> {\r\n        finalConnections.remove(connection);\r\n        if (!isDaemon && finalConnections.isEmpty()) {\r\n            container.stop();\r\n            jdbcUrlContainerCache.remove(connectionUrl.getUrl());\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.spockframework.runtime.SpecUtil.getFeatureCount",
	"Comment": "returns the number of features contained in the given specification.because spock allows for the dynamic creation of new features atspecification run time, this number is only an estimate.",
	"Method": "int getFeatureCount(Class<?> spec){\r\n    checkIsSpec(spec);\r\n    int count = 0;\r\n    do {\r\n        for (Method method : spec.getDeclaredMethods()) if (method.isAnnotationPresent(FeatureMetadata.class))\r\n            count++;\r\n        spec = spec.getSuperclass();\r\n    } while (spec != null && isSpec(spec));\r\n    return count;\r\n}"
}, {
	"Path": "uk.co.senab.photoview.PhotoViewAttacher.checkAndDisplayMatrix",
	"Comment": "helper method that simply checks the matrix, and then displays the result",
	"Method": "void checkAndDisplayMatrix(){\r\n    if (checkMatrixBounds()) {\r\n        setImageViewMatrix(getDrawMatrix());\r\n    }\r\n}"
}, {
	"Path": "com.querydsl.sql.mysql.AbstractMySQLQuery.lockInShareMode",
	"Comment": "using lock in share mode sets a shared lock that permits other transactions to read the examinedrows but not to update or delete them.",
	"Method": "C lockInShareMode(){\r\n    return addFlag(Position.END, LOCK_IN_SHARE_MODE);\r\n}"
}, {
	"Path": "android.support.design.widget.CustomCollapsingToolbarLayout.setCollapsedTitleGravity",
	"Comment": "sets the horizontal alignment of the collapsed title and the vertical gravity that willbe used when there is extra space in the collapsed bounds beyond what is required forthe title itself.",
	"Method": "void setCollapsedTitleGravity(int gravity){\r\n    mCollapsingTextHelper.setCollapsedTextGravity(gravity);\r\n}"
}, {
	"Path": "com.querydsl.spatial.GeometryExpression.symDifference",
	"Comment": "returns a geometric object that represents thepoint set symmetric difference of this geometric object with anothergeometry.",
	"Method": "GeometryExpression<Geometry> symDifference(Geometry geometry,GeometryExpression<Geometry> symDifference,Expression<? extends Geometry> geometry){\r\n    return GeometryExpressions.geometryOperation(SpatialOps.SYMDIFFERENCE, mixin, geometry);\r\n}"
}, {
	"Path": "org.springsource.loaded.FieldReaderWriter.findAndSetFieldValueInHierarchy",
	"Comment": "walk up the instance hierarchy looking for the field, and when it is found set it. will exit via exception if it\tcannot find the field or something goes wrong when accessing it.",
	"Method": "void findAndSetFieldValueInHierarchy(Object instance,Object newValue){\r\n    Class<?> clazz = instance.getClass();\r\n    String fieldname = theField.getName();\r\n    String searchName = typeDescriptor.getName().replace('/', '.');\r\n    while (clazz != null && !clazz.getName().equals(searchName)) {\r\n        clazz = clazz.getSuperclass();\r\n    }\r\n    if (clazz == null) {\r\n        throw new IllegalStateException(\"Failed to find \" + searchName + \" in hierarchy of \" + instance.getClass());\r\n    }\r\n    try {\r\n        Field f = clazz.getDeclaredField(fieldname);\r\n        f.setAccessible(true);\r\n        f.set(instance, newValue);\r\n    } catch (Exception e) {\r\n        throw new IllegalStateException(\"Unexpectedly could not access field named \" + fieldname + \" on class \" + clazz.getName());\r\n    }\r\n}"
}, {
	"Path": "org.spockframework.util.IoUtil.getText",
	"Comment": "returns the text read from the given stream as a string.closes the given stream upon return.",
	"Method": "String getText(Reader reader,String getText,File path,String getText,InputStream stream){\r\n    return getText(new InputStreamReader(stream));\r\n}"
}, {
	"Path": "com.querydsl.sql.ProjectableSQLQuery.addJoinFlag",
	"Comment": "add the given string literal as a join flag to the last added join",
	"Method": "Q addJoinFlag(String flag,Q addJoinFlag,String flag,JoinFlag.Position position){\r\n    queryMixin.addJoinFlag(new JoinFlag(flag, position));\r\n    return (Q) this;\r\n}"
}, {
	"Path": "cn.finalteam.rxgalleryfinal.ui.widget.FlexibleDividerDecoration.getGroupIndex",
	"Comment": "returns a group index for gridlayoutmanager.for linearlayoutmanager, always returns position.",
	"Method": "int getGroupIndex(int position,RecyclerView parent){\r\n    if (parent.getLayoutManager() instanceof GridLayoutManager) {\r\n        GridLayoutManager layoutManager = (GridLayoutManager) parent.getLayoutManager();\r\n        GridLayoutManager.SpanSizeLookup spanSizeLookup = layoutManager.getSpanSizeLookup();\r\n        int spanCount = layoutManager.getSpanCount();\r\n        return spanSizeLookup.getSpanGroupIndex(position, spanCount);\r\n    }\r\n    return position;\r\n}"
}, {
	"Path": "cn.finalteam.rxgalleryfinal.RxGalleryFinal.cropMaxScaleMultiplier",
	"Comment": "this method sets multiplier that is used to calculate max image scale from min image scale.",
	"Method": "RxGalleryFinal cropMaxScaleMultiplier(float maxScaleMultiplier){\r\n    configuration.setMaxScaleMultiplier(maxScaleMultiplier);\r\n    return this;\r\n}"
}, {
	"Path": "com.klinker.android.twitter.utils.QustomDialogBuilder.setDividerColor",
	"Comment": "use this method to color the divider between the title and content.will not display if no title is set.",
	"Method": "QustomDialogBuilder setDividerColor(int color){\r\n    mDivider.setBackgroundColor(color);\r\n    return this;\r\n}"
}, {
	"Path": "com.querydsl.sql.dml.AbstractSQLDeleteClause.addFlag",
	"Comment": "add the given expression at the given position as a query flag",
	"Method": "C addFlag(Position position,String flag,C addFlag,Position position,Expression<?> flag){\r\n    metadata.addFlag(new QueryFlag(position, flag));\r\n    return (C) this;\r\n}"
}, {
	"Path": "com.querydsl.sql.SQLExpressions.lastValue",
	"Comment": "returns value evaluated at the row that is the last row of the window frame",
	"Method": "WindowOver<T> lastValue(Expression<T> expr){\r\n    return new WindowOver<T>(expr.getType(), SQLOps.LASTVALUE, expr);\r\n}"
}, {
	"Path": "org.springsource.loaded.ri.JavaMethodCache.initialize",
	"Comment": "this method should be called to put all entries into the map.",
	"Method": "void initialize(Initializer init){\r\n    this.cache = init.cache;\r\n    init.cache = null;\r\n}"
}, {
	"Path": "org.testcontainers.containers.wait.strategy.Wait.forHttp",
	"Comment": "convenience method to return a waitstrategy for an http endpoint.",
	"Method": "HttpWaitStrategy forHttp(String path){\r\n    return new HttpWaitStrategy().forPath(path);\r\n}"
}, {
	"Path": "com.r0adkll.slidr.util.ViewDragHelper.clampMag",
	"Comment": "clamp the magnitude of value for absmin and absmax.if the value is below the minimum, it will be clamped to zero.if the value is above the maximum, it will be clamped to the maximum.",
	"Method": "int clampMag(int value,int absMin,int absMax,float clampMag,float value,float absMin,float absMax){\r\n    final float absValue = Math.abs(value);\r\n    if (absValue < absMin)\r\n        return 0;\r\n    if (absValue > absMax)\r\n        return value > 0 ? absMax : -absMax;\r\n    return value;\r\n}"
}, {
	"Path": "org.testcontainers.containers.wait.strategy.Wait.forLogMessage",
	"Comment": "convenience method to return a waitstrategy for log messages.",
	"Method": "LogMessageWaitStrategy forLogMessage(String regex,int times){\r\n    return new LogMessageWaitStrategy().withRegEx(regex).withTimes(times);\r\n}"
}, {
	"Path": "org.testng.internal.ConfigInvoker.invokeBeforeGroupsConfigurations",
	"Comment": "filter all the beforegroups methods and invoke only those that apply to the current testmethod",
	"Method": "void invokeBeforeGroupsConfigurations(ITestNGMethod currentTestMethod,ConfigurationGroupMethods groupMethods,XmlSuite suite,Map<String, String> params,Object instance){\r\n    List<ITestNGMethod> filteredMethods = Lists.newArrayList();\r\n    String[] groups = currentTestMethod.getGroups();\r\n    for (String group : groups) {\r\n        List<ITestNGMethod> methods = groupMethods.getBeforeGroupMethodsForGroup(group);\r\n        if (methods != null) {\r\n            filteredMethods.addAll(methods);\r\n        }\r\n    }\r\n    ITestNGMethod[] beforeMethodsArray = filteredMethods.toArray(new ITestNGMethod[0]);\r\n    if (beforeMethodsArray.length > 0) {\r\n        invokeConfigurations(null, beforeMethodsArray, suite, params, null, instance);\r\n    }\r\n    groupMethods.removeBeforeGroups(groups);\r\n}"
}, {
	"Path": "com.alipay.sofa.rpc.client.aft.FaultBaseTest.delayGetCount",
	"Comment": "because of subscriber is async, this get method will delay 100ms",
	"Method": "long delayGetCount(InvocationStat invocationStat,long expect){\r\n    return delayGet(new Callable<Long>() {\r\n        @Override\r\n        public Long call() throws Exception {\r\n            return invocationStat.getInvokeCount();\r\n        }\r\n    }, expect, 10, 10);\r\n}"
}, {
	"Path": "com.alipay.sofa.rpc.client.aft.FaultBaseTest.delayGetCount",
	"Comment": "because of subscriber is async, this get method will delay 100ms",
	"Method": "long delayGetCount(InvocationStat invocationStat,long expect){\r\n    return invocationStat.getInvokeCount();\r\n}"
}, {
	"Path": "com.querydsl.spatial.jts.JTSGeometryExpression.symDifference",
	"Comment": "returns a geometric object that represents thepoint set symmetric difference of this geometric object with anothergeometry.",
	"Method": "JTSGeometryExpression<Geometry> symDifference(Geometry geometry,JTSGeometryExpression<Geometry> symDifference,Expression<? extends Geometry> geometry){\r\n    return JTSGeometryExpressions.geometryOperation(SpatialOps.SYMDIFFERENCE, mixin, geometry);\r\n}"
}, {
	"Path": "org.springsource.loaded.ri.test.ClassReflectionTests.test_getDeclaredLateMethodAndInvoke",
	"Comment": "testing class.getdeclaredmethod and method.invoke\tcan we retrieve and invoke a method that was added in a reloaded type?",
	"Method": "void test_getDeclaredLateMethodAndInvoke(){\r\n    try {\r\n        getDeclaredMethodAndInvoke(\"lateMethod\");\r\n        fail(\"getting/invoking a method that hs not yet been defined should fail\");\r\n    } catch (ResultException e) {\r\n        assertNoSuchMethodException(TARGET_CLASS_NAME + \".lateMethod()\", e);\r\n    }\r\n    reloadType(\"002\");\r\n    Result r = getDeclaredMethodAndInvoke(\"lateMethod\");\r\n    Assert.assertEquals(42, r.returnValue);\r\n}"
}, {
	"Path": "io.rx_cache2.ActionsList.add",
	"Comment": "func2 will be called for every iteration until its condition returns true. when true, theelement is added to the cache at the position of the current iteration.",
	"Method": "ActionsList<T> add(Func2 func2,T element){\r\n    return addAll(func2, Arrays.asList(element));\r\n}"
}, {
	"Path": "org.springsource.loaded.test.FieldReloadingTests.newFieldAddedInstance",
	"Comment": "variant of the first test but uses a new instance after reloading",
	"Method": "void newFieldAddedInstance(){\r\n    TypeRegistry r = getTypeRegistry(\"fields.Add\");\r\n    ReloadableType add = loadType(r, \"fields.Add\");\r\n    Class<?> addClazz = add.getClazz();\r\n    Object addInstance = addClazz.newInstance();\r\n    assertEquals(0, runOnInstance(addClazz, addInstance, \"getValue\").returnValue);\r\n    ClassPrinter.print(add.bytesLoaded, true);\r\n    add.loadNewVersion(\"2\", retrieveRename(\"fields.Add\", \"fields.Add002\"));\r\n    addInstance = addClazz.newInstance();\r\n    assertEquals(0, runOnInstance(addClazz, addInstance, \"getValue\").returnValue);\r\n    runOnInstance(addClazz, addInstance, \"setValue\", 45);\r\n    assertEquals(45, runOnInstance(addClazz, addInstance, \"getValue\").returnValue);\r\n    assertEquals(45, add.getField(addInstance, \"i\", false));\r\n}"
}, {
	"Path": "android.support.design.widget.CustomCollapsingToolbarLayout.setContentScrim",
	"Comment": "set the drawable to use for the content scrim from resources. providing null will disablethe scrim functionality.",
	"Method": "void setContentScrim(Drawable drawable){\r\n    if (mContentScrim != drawable) {\r\n        if (mContentScrim != null) {\r\n            mContentScrim.setCallback(null);\r\n        }\r\n        mContentScrim = drawable != null ? drawable.mutate() : null;\r\n        if (mContentScrim != null) {\r\n            mContentScrim.setBounds(0, 0, getWidth(), getHeight());\r\n            mContentScrim.setCallback(this);\r\n            mContentScrim.setAlpha(mScrimAlpha);\r\n        }\r\n        ViewCompat.postInvalidateOnAnimation(this);\r\n    }\r\n}"
}, {
	"Path": "org.testcontainers.containers.output.FrameConsumerResultCallback.addConsumer",
	"Comment": "set this callback to use the specified consumer for the given output type.the same consumer can be configured for more than one output type.",
	"Method": "void addConsumer(OutputFrame.OutputType outputType,Consumer<OutputFrame> consumer){\r\n    consumers.put(outputType, consumer);\r\n}"
}, {
	"Path": "com.querydsl.spatial.GeometryCollectionExpression.numGeometries",
	"Comment": "returns the number of geometries in this geometrycollection.",
	"Method": "NumberExpression<Integer> numGeometries(){\r\n    if (numGeometries == null) {\r\n        numGeometries = Expressions.numberOperation(Integer.class, SpatialOps.NUM_GEOMETRIES, mixin);\r\n    }\r\n    return numGeometries;\r\n}"
}, {
	"Path": "com.simplecity.amp_library.playback.QueueManager.serializePlaylist",
	"Comment": "converts a playlist to a string which can be saved to sharedprefs",
	"Method": "String serializePlaylist(List<QueueItem> queueItems){\r\n    StringBuilder q = new StringBuilder();\r\n    List<Song> songs = Stream.of(queueItems).map(QueueItem::getSong).toList();\r\n    int len = songs.size();\r\n    for (int i = 0; i < len; i++) {\r\n        long n = songs.get(i).id;\r\n        if (n >= 0) {\r\n            if (n == 0) {\r\n                q.append(\"0;\");\r\n            } else {\r\n                while (n != 0) {\r\n                    final int digit = (int) (n & 0xf);\r\n                    n >>>= 4;\r\n                    q.append(hexDigits[digit]);\r\n                }\r\n                q.append(\";\");\r\n            }\r\n        }\r\n    }\r\n    return q.toString();\r\n}"
}, {
	"Path": "org.springsource.loaded.agent.SpringLoadedPreProcessor.injectReflectiveInterceptorMethods",
	"Comment": "this method tries to inject the reflectiveinterceptor methods into any system types that have been rewritten.",
	"Method": "void injectReflectiveInterceptorMethods(String slashedClassName,int bits,Class<?> clazz){\r\n    if ((bits & Constants.JLC_GETDECLAREDFIELDS) != 0) {\r\n        Field f = clazz.getDeclaredField(\"__sljlcgdfs\");\r\n        f.setAccessible(true);\r\n        f.set(null, method_jlcgdfs);\r\n    }\r\n    if ((bits & Constants.JLC_GETDECLAREDFIELD) != 0) {\r\n        Field f = clazz.getDeclaredField(jlcgdf);\r\n        f.setAccessible(true);\r\n        f.set(null, method_jlcgdf);\r\n    }\r\n    if ((bits & Constants.JLC_GETFIELD) != 0) {\r\n        Field f = clazz.getDeclaredField(jlcgf);\r\n        f.setAccessible(true);\r\n        f.set(null, method_jlcgf);\r\n    }\r\n    if ((bits & Constants.JLC_GETDECLAREDMETHODS) != 0) {\r\n        Field f = clazz.getDeclaredField(jlcgdms);\r\n        f.setAccessible(true);\r\n        f.set(null, method_jlcgdms);\r\n    }\r\n    if ((bits & Constants.JLC_GETDECLAREDMETHOD) != 0) {\r\n        Field f = clazz.getDeclaredField(jlcgdm);\r\n        f.setAccessible(true);\r\n        f.set(null, method_jlcgdm);\r\n    }\r\n    if ((bits & Constants.JLC_GETMETHOD) != 0) {\r\n        Field f = clazz.getDeclaredField(jlcgm);\r\n        f.setAccessible(true);\r\n        f.set(null, method_jlcgm);\r\n    }\r\n    if ((bits & Constants.JLC_GETDECLAREDCONSTRUCTOR) != 0) {\r\n        Field f = clazz.getDeclaredField(jlcgdc);\r\n        f.setAccessible(true);\r\n        f.set(null, method_jlcgdc);\r\n    }\r\n    if ((bits & Constants.JLC_GETMODIFIERS) != 0) {\r\n        Field f = clazz.getDeclaredField(jlcgmods);\r\n        f.setAccessible(true);\r\n        f.set(null, method_jlcgmods);\r\n    }\r\n    if ((bits & Constants.JLC_GETMETHODS) != 0) {\r\n        Field f = clazz.getDeclaredField(jlcgms);\r\n        f.setAccessible(true);\r\n        f.set(null, method_jlcgms);\r\n    }\r\n    if ((bits & Constants.JLC_GETCONSTRUCTOR) != 0) {\r\n        Field f = clazz.getDeclaredField(jlcgc);\r\n        f.setAccessible(true);\r\n        f.set(null, method_jlcgc);\r\n    }\r\n    if ((bits & Constants.JLC_GETDECLAREDCONSTRUCTORS) != 0) {\r\n        Field f = clazz.getDeclaredField(jlcGetDeclaredConstructorsMember);\r\n        f.setAccessible(true);\r\n        f.set(null, method_jlcgdcs);\r\n    }\r\n    if ((bits & Constants.JLRF_GET) != 0) {\r\n        Field f = clazz.getDeclaredField(jlrfGetMember);\r\n        f.setAccessible(true);\r\n        f.set(null, method_jlrfg);\r\n    }\r\n    if ((bits & Constants.JLRF_GETLONG) != 0) {\r\n        Field f = clazz.getDeclaredField(jlrfGetLongMember);\r\n        f.setAccessible(true);\r\n        f.set(null, method_jlrfgl);\r\n    }\r\n    if ((bits & Constants.JLRM_INVOKE) != 0) {\r\n        Field f = clazz.getDeclaredField(jlrmInvokeMember);\r\n        f.setAccessible(true);\r\n        f.set(null, method_jlrmi);\r\n    }\r\n    if ((bits & Constants.JLOS_HASSTATICINITIALIZER) != 0) {\r\n        Field f = clazz.getDeclaredField(jloObjectStream_hasInitializerMethod);\r\n        f.setAccessible(true);\r\n        f.set(null, method_jloObjectStream_hasInitializerMethod);\r\n    }\r\n}"
}, {
	"Path": "org.spockframework.compiler.SpecRewriter.moveInitializer",
	"Comment": "moves initialization of the given field to the given position of the first block of the given method.",
	"Method": "void moveInitializer(Field field,Method method,int position){\r\n    method.getFirstBlock().getAst().add(position, new ExpressionStatement(new FieldInitializationExpression(field.getAst())));\r\n    field.getAst().setInitialValueExpression(null);\r\n}"
}, {
	"Path": "com.querydsl.sql.SQLTemplatesRegistry.getTemplates",
	"Comment": "get the sqltemplates instance that matches best the sql engine of thegiven database metadata",
	"Method": "SQLTemplates getTemplates(DatabaseMetaData md){\r\n    return getBuilder(md).build();\r\n}"
}, {
	"Path": "com.nanchen.rxjava2examples.ui.SystemBarTintManager.setNavigationBarTintEnabled",
	"Comment": "enable tinting of the system navigation bar.if the platform does not have soft navigation keys, is running jelly beanor earlier, or translucent system ui modes have not been enabled in eitherthe theme or via window flags, then this method does nothing.",
	"Method": "void setNavigationBarTintEnabled(boolean enabled){\r\n    mNavBarTintEnabled = enabled;\r\n    if (mNavBarAvailable) {\r\n        mNavBarTintView.setVisibility(enabled ? View.VISIBLE : View.GONE);\r\n    }\r\n}"
}, {
	"Path": "org.springsource.loaded.FieldReaderWriter.findStaticStateManager",
	"Comment": "discover the static state manager on the specified class and return it. will fail by exception rather than\treturning null.",
	"Method": "SSMgr findStaticStateManager(Class<?> clazz){\r\n    try {\r\n        Field stateManagerField = clazz.getField(Constants.fStaticFieldsName);\r\n        if (stateManagerField == null) {\r\n            throw new IllegalStateException(\"Cant find field accessor for type \" + typeDescriptor.getReloadableType().getName());\r\n        }\r\n        SSMgr stateManager = (SSMgr) stateManagerField.get(null);\r\n        if (stateManager == null) {\r\n            throw new IllegalStateException(\"Instance of this class has no state manager: \" + clazz.getName());\r\n        }\r\n        return stateManager;\r\n    } catch (Exception e) {\r\n        throw new IllegalStateException(\"Unexpectedly unable to find static state manager on class \" + clazz.getName(), e);\r\n    }\r\n}"
}, {
	"Path": "uk.co.real_logic.sbe.xml.XmlSchemaParser.getAttributeValue",
	"Comment": "helper function that uses a default value when value not set.",
	"Method": "String getAttributeValue(Node elementNode,String attrName,String getAttributeValue,Node elementNode,String attrName,String defValue){\r\n    final Node attrNode = elementNode.getAttributes().getNamedItem(attrName);\r\n    if (attrNode == null) {\r\n        return defValue;\r\n    }\r\n    return attrNode.getNodeValue();\r\n}"
}, {
	"Path": "org.springsource.loaded.test.InnerClassesTests.reloadDefaultVisClass",
	"Comment": "similar to the first test but this is just using a regular default visibility class.",
	"Method": "void reloadDefaultVisClass(){\r\n    String tclass = \"inners.Two\";\r\n    TypeRegistry typeRegistry = getTypeRegistry(\"inners..*\");\r\n    typeRegistry.addType(\"inners.TwoDefault\", loadBytesForClass(\"inners.TwoDefault\"));\r\n    ReloadableType rtype = typeRegistry.addType(tclass, loadBytesForClass(tclass));\r\n    runUnguarded(rtype.getClazz(), \"runner\");\r\n    rtype.loadNewVersion(\"2\", retrieveRename(tclass, tclass + \"2\"));\r\n    runUnguarded(rtype.getClazz(), \"runner\");\r\n}"
}, {
	"Path": "org.testcontainers.containers.BrowserWebDriverContainer.withLinkToContainer",
	"Comment": "remember any other containers this needs to link to. we have to pass these down to the container so thatthe other containers will be initialized before linking occurs.",
	"Method": "SELF withLinkToContainer(LinkableContainer otherContainer,String alias){\r\n    addLink(otherContainer, alias);\r\n    return self();\r\n}"
}, {
	"Path": "uk.co.real_logic.sbe.PrimitiveValue.parse",
	"Comment": "parse constant value string and set representation based on type, length, and characterencoding",
	"Method": "PrimitiveValue parse(String value,PrimitiveType primitiveType,PrimitiveValue parse,String value,PrimitiveType primitiveType,String characterEncoding,PrimitiveValue parse,String value,int length,String characterEncoding){\r\n    if (value.length() > length) {\r\n        throw new IllegalStateException(\"value.length=\" + value.length() + \" greater than length=\" + length);\r\n    }\r\n    byte[] bytes = value.getBytes(forName(characterEncoding));\r\n    if (bytes.length < length) {\r\n        bytes = Arrays.copyOf(bytes, length);\r\n    }\r\n    return new PrimitiveValue(bytes, characterEncoding, length);\r\n}"
}, {
	"Path": "org.springsource.loaded.test.CrossLoaderTests.cglibProxiesAcrossLoader1",
	"Comment": "avoiding fastclass in this test, one less thing to worry about",
	"Method": "void cglibProxiesAcrossLoader1(){\r\n    binLoader = new SubLoader(new String[] {}, new String[] { \"../testdata/lib/cglib-nodep-2.2.jar\" });\r\n    subLoader = (SubLoader) binLoader;\r\n    String t = \"subpkg.ProxyTestcase\";\r\n    ReloadableType proxyTestcaseR = subLoader.loadAsReloadableType(t);\r\n    result = runUnguarded(proxyTestcaseR.getClazz(), \"run\");\r\n    System.out.println(result);\r\n    result = runUnguarded(proxyTestcaseR.getClazz(), \"getProxyLoader\");\r\n    System.out.println(result.returnValue);\r\n    result = runUnguarded(proxyTestcaseR.getClazz(), \"getSimpleLoader\");\r\n    System.out.println(result.returnValue);\r\n}"
}, {
	"Path": "org.springsource.loaded.Utils.arrayCopyOf",
	"Comment": "utility method similar to java 1.6 arrays.copyof, used instead of that method to stick to java 1.5 only api.",
	"Method": "T[] arrayCopyOf(T[] array,int newSize){\r\n    @SuppressWarnings(\"unchecked\")\r\n    T[] newArr = (T[]) Array.newInstance(array.getClass().getComponentType(), newSize);\r\n    System.arraycopy(array, 0, newArr, 0, Math.min(newSize, newArr.length));\r\n    return newArr;\r\n}"
}, {
	"Path": "com.querydsl.sql.mysql.AbstractMySQLQuery.intoDumpfile",
	"Comment": "select ... into dumpfile writes a single row to a file without any formatting.",
	"Method": "C intoDumpfile(File file){\r\n    return addFlag(Position.END, \"\\ninto dumpfile '\" + file.getPath() + \"'\");\r\n}"
}, {
	"Path": "com.querydsl.sql.AbstractSQLQuery.setStatementOptions",
	"Comment": "set the options to be applied to the jdbc statements of this query",
	"Method": "void setStatementOptions(StatementOptions statementOptions){\r\n    this.statementOptions = statementOptions;\r\n}"
}, {
	"Path": "com.alipay.sofa.rpc.server.tracer.util.TracerChecker.readTracerDigest",
	"Comment": "readtracerdigest all rpc client and rpc server digest to jsonobject",
	"Method": "List<JSONObject> readTracerDigest(File file){\r\n    LOGGER.info(\"start to read tracer file,\" + file.toURI());\r\n    List<JSONObject> jsonObjects = new ArrayList<JSONObject>();\r\n    List<String> contents = null;\r\n    try {\r\n        contents = FileUtils.readLines(file);\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    }\r\n    for (String content : contents) {\r\n        jsonObjects.add(JSON.parseObject(content));\r\n    }\r\n    LOGGER.info(\"end to read tracer file,jsonObjects\" + jsonObjects);\r\n    return jsonObjects;\r\n}"
}, {
	"Path": "uk.co.real_logic.sbe.PrimitiveValue.size",
	"Comment": "return encodedlength for this primitivevalue for serialization purposes.",
	"Method": "int size(){\r\n    return size;\r\n}"
}, {
	"Path": "org.spockframework.compiler.SpecRewriter.moveVariableDeclarations",
	"Comment": "moves variable declarations from one statement list to another. initializerexpressions are kept at their former place.",
	"Method": "void moveVariableDeclarations(List<Statement> from,List<Statement> to){\r\n    for (Statement stat : from) {\r\n        DeclarationExpression declExpr = AstUtil.getExpression(stat, DeclarationExpression.class);\r\n        if (declExpr == null)\r\n            continue;\r\n        ((ExpressionStatement) stat).setExpression(new BinaryExpression(copyLhsVariableExpressions(declExpr), Token.newSymbol(Types.ASSIGN, -1, -1), declExpr.getRightExpression()));\r\n        declExpr.setRightExpression(createDefaultValueInitializer(declExpr));\r\n        to.add(new ExpressionStatement(declExpr));\r\n    }\r\n}"
}, {
	"Path": "com.querydsl.sql.SQLExpressions.selectFrom",
	"Comment": "create a new detached sqlquery instance with the given projection",
	"Method": "SQLQuery<T> selectFrom(RelationalPath<T> expr){\r\n    return select(expr).from(expr);\r\n}"
}, {
	"Path": "com.alipay.sofa.rpc.codec.snappy.SnappyDecompressor.readUncompressedLength",
	"Comment": "reads the variable length integer encoded a the specified offset, andreturns this length with the number of bytes read.",
	"Method": "int[] readUncompressedLength(byte[] compressed,int compressedOffset){\r\n    int result;\r\n    int bytesRead = 0;\r\n    {\r\n        int b = compressed[compressedOffset + bytesRead++] & 0xFF;\r\n        result = b & 0x7f;\r\n        if ((b & 0x80) != 0) {\r\n            b = compressed[compressedOffset + bytesRead++] & 0xFF;\r\n            result |= (b & 0x7f) << 7;\r\n            if ((b & 0x80) != 0) {\r\n                b = compressed[compressedOffset + bytesRead++] & 0xFF;\r\n                result |= (b & 0x7f) << 14;\r\n                if ((b & 0x80) != 0) {\r\n                    b = compressed[compressedOffset + bytesRead++] & 0xFF;\r\n                    result |= (b & 0x7f) << 21;\r\n                    if ((b & 0x80) != 0) {\r\n                        b = compressed[compressedOffset + bytesRead++] & 0xFF;\r\n                        result |= (b & 0x7f) << 28;\r\n                        if ((b & 0x80) != 0) {\r\n                            throw new CorruptionException(\"last byte of compressed length int has high bit set\");\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return new int[] { result, bytesRead };\r\n}"
}, {
	"Path": "com.simplecity.amp_library.ui.views.BreadcrumbItem.getItemPath",
	"Comment": "returns the item path associated with with this breadcrumb item",
	"Method": "String getItemPath(){\r\n    return this.mItemPath;\r\n}"
}, {
	"Path": "io.rx_cache2.internal.cache.memory.apache.AbstractHashedMap.hashIndex",
	"Comment": "gets the index into the data storage for the hashcode specified.this implementation uses the least significant bits of the hashcode.subclasses can override this to return alternate bucketing.",
	"Method": "int hashIndex(int hashCode,int dataSize){\r\n    return hashCode & dataSize - 1;\r\n}"
}, {
	"Path": "org.springsource.loaded.test.EnumTests.testEnumsConstructor",
	"Comment": "old constructor deleted, new one added. this checks that the rewritten clinit that initializes the set of values\tis working.",
	"Method": "void testEnumsConstructor(){\r\n    String t = \"enumtests.ColoursD\";\r\n    String runner = \"enumtests.RunnerD\";\r\n    binLoader.loadClass(t);\r\n    Class<?> runnerClazz = binLoader.loadClass(runner);\r\n    assertNotNull(runnerClazz);\r\n    String output = runMethodAndCollectOutput(runnerClazz, \"run1\");\r\n    assertContains(\"[Red 1111 0 Green 2222 1 Blue 3333 2]\", output);\r\n    ReloadableType rtype = TypeRegistry.getTypeRegistryFor(binLoader).getReloadableType(toSlash(t), false);\r\n    assertNotNull(rtype);\r\n    ReloadableType rtypeRunner = TypeRegistry.getTypeRegistryFor(binLoader).getReloadableType(toSlash(runner), false);\r\n    assertNotNull(rtypeRunner);\r\n    rtype.loadNewVersion(retrieveRename(t, t + \"2\"));\r\n    rtypeRunner.loadNewVersion(retrieveRename(runner, runner + \"2\", \"enumtests.ColoursD2:enumtests.ColoursD\"));\r\n    output = runMethodAndCollectOutput(runnerClazz, \"run1\");\r\n    assertContains(\"[Red a 0 Green b 1 Blue c 2]\", output);\r\n    assertContains(\"value count = 3\", output);\r\n}"
}, {
	"Path": "uk.co.real_logic.sbe.generation.java.JavaUtil.generateOptionEncodeJavadoc",
	"Comment": "generate the javadoc comment header for a bitset choice option encode method.",
	"Method": "String generateOptionEncodeJavadoc(String indent,Token optionToken){\r\n    final String description = optionToken.description();\r\n    if (null == description || description.isEmpty()) {\r\n        return \"\";\r\n    }\r\n    return indent + \"/**\\n\" + indent + \" * \" + description + '\\n' + indent + \" *\\n\" + indent + \" * @param value true if \" + optionToken.name() + \" is set or false if not\\n\" + indent + \" */\\n\";\r\n}"
}, {
	"Path": "org.springsource.loaded.test.GroovyTests.reflection",
	"Comment": "test is too sensitive to changes between groovy compiler versions",
	"Method": "void reflection(){\r\n    binLoader = new TestClassloaderWithRewriting();\r\n    String a = \"simple.SelfReflector\";\r\n    TypeRegistry r = getTypeRegistry(a);\r\n    ReloadableType rtypea = r.addType(a, loadBytesForClass(a));\r\n    result = runUnguarded(rtypea.getClazz(), \"run\");\r\n    assertEquals(\"14 $callSiteArray $class$java$lang$String $class$java$lang$StringBuilder $class$java$lang$reflect$Field $class$java$util$ArrayList $class$java$util$Collections $class$java$util$Iterator $class$java$util$List $class$simple$SelfReflector $staticClassInfo __$stMC array$$class$java$lang$reflect$Field i metaClass\", result.returnValue);\r\n}"
}, {
	"Path": "com.querydsl.sql.Configuration.getUseLiterals",
	"Comment": "get whether literals are serialized or prepared statement bindings are used",
	"Method": "boolean getUseLiterals(){\r\n    return useLiterals;\r\n}"
}, {
	"Path": "com.querydsl.sql.SQLTemplatesRegistry.getBuilder",
	"Comment": "get a sqltemplates.builder instance that matches best the sql engine of thegiven database metadata",
	"Method": "SQLTemplates.Builder getBuilder(DatabaseMetaData md){\r\n    String name = md.getDatabaseProductName().toLowerCase();\r\n    if (name.equals(\"cubrid\")) {\r\n        return CUBRIDTemplates.builder();\r\n    } else if (name.equals(\"apache derby\")) {\r\n        return DerbyTemplates.builder();\r\n    } else if (name.startsWith(\"firebird\")) {\r\n        return FirebirdTemplates.builder();\r\n    } else if (name.equals(\"h2\")) {\r\n        return H2Templates.builder();\r\n    } else if (name.equals(\"hsql\")) {\r\n        return HSQLDBTemplates.builder();\r\n    } else if (name.equals(\"mysql\")) {\r\n        return MySQLTemplates.builder();\r\n    } else if (name.equals(\"oracle\")) {\r\n        return OracleTemplates.builder();\r\n    } else if (name.equals(\"postgresql\")) {\r\n        return PostgreSQLTemplates.builder();\r\n    } else if (name.equals(\"sqlite\")) {\r\n        return SQLiteTemplates.builder();\r\n    } else if (name.startsWith(\"teradata\")) {\r\n        return TeradataTemplates.builder();\r\n    } else if (name.equals(\"microsoft sql server\")) {\r\n        switch(md.getDatabaseMajorVersion()) {\r\n            case 13:\r\n            case 12:\r\n            case 11:\r\n                return SQLServer2012Templates.builder();\r\n            case 10:\r\n                return SQLServer2008Templates.builder();\r\n            case 9:\r\n                return SQLServer2005Templates.builder();\r\n            default:\r\n                return SQLServerTemplates.builder();\r\n        }\r\n    } else {\r\n        return new SQLTemplates.Builder() {\r\n            @Override\r\n            protected SQLTemplates build(char escape, boolean quote) {\r\n                return new SQLTemplates(Keywords.DEFAULT, \"\\\"\", escape, quote, false);\r\n            }\r\n        };\r\n    }\r\n}"
}, {
	"Path": "com.querydsl.sql.SQLTemplatesRegistry.getBuilder",
	"Comment": "get a sqltemplates.builder instance that matches best the sql engine of thegiven database metadata",
	"Method": "SQLTemplates.Builder getBuilder(DatabaseMetaData md){\r\n    return new SQLTemplates(Keywords.DEFAULT, \"\\\"\", escape, quote, false);\r\n}"
}, {
	"Path": "com.querydsl.sql.RelationalPathBase.eq",
	"Comment": "compares the two relational paths using primary key columns",
	"Method": "BooleanExpression eq(T right,BooleanExpression eq,Expression<? super T> right){\r\n    if (right instanceof RelationalPath) {\r\n        return primaryKeyOperation(Ops.EQ, primaryKey, ((RelationalPath) right).getPrimaryKey());\r\n    } else {\r\n        return super.eq(right);\r\n    }\r\n}"
}, {
	"Path": "org.unitils.core.dbsupport.H2DbSupport.incrementSequenceToValue",
	"Comment": "sets the next value of the sequence with the given sequence name to thegiven sequence value.",
	"Method": "void incrementSequenceToValue(String sequenceName,long newSequenceValue){\r\n    getSQLHandler().executeUpdate(\"alter sequence \" + qualified(sequenceName) + \" restart with \" + newSequenceValue);\r\n}"
}, {
	"Path": "org.springsource.loaded.ReloadableType.reloadProxiesIfNecessary",
	"Comment": "go through proxies we know about in this registry and see if any of them are for the type we have just reloaded.\tif they are, regenerate them and reload them.",
	"Method": "void reloadProxiesIfNecessary(String versionsuffix){\r\n    ReloadableType proxy = typeRegistry.cglibProxies.get(this.slashedtypename);\r\n    if (proxy != null) {\r\n        if (GlobalConfiguration.isRuntimeLogging && log.isLoggable(Level.INFO)) {\r\n            log.log(Level.INFO, \"Attempting reload of cglib proxy for type \" + this.slashedtypename);\r\n        }\r\n        Object[] strategyAndGeneratorPair = CglibPluginCapturing.clazzToGeneratorStrategyAndClassGeneratorMap.get(getClazz());\r\n        if (strategyAndGeneratorPair == null) {\r\n            if (log.isLoggable(Level.SEVERE)) {\r\n                log.severe(\"Unable to find regeneration methods for cglib proxies - proxies will be out of date for type: \" + getClazz());\r\n            }\r\n            return;\r\n        }\r\n        Object a = strategyAndGeneratorPair[0];\r\n        Object b = strategyAndGeneratorPair[1];\r\n        try {\r\n            Method[] ms = a.getClass().getMethods();\r\n            Method found = null;\r\n            for (Method m : ms) {\r\n                if (m.getName().equals(\"generate\")) {\r\n                    found = m;\r\n                    break;\r\n                }\r\n            }\r\n            found.setAccessible(true);\r\n            byte[] bs = (byte[]) found.invoke(a, b);\r\n            if (GlobalConfiguration.isRuntimeLogging && log.isLoggable(Level.INFO)) {\r\n                log.log(Level.INFO, \"Proxy regenerate successful for \" + this.slashedtypename);\r\n            }\r\n            proxy.loadNewVersion(versionsuffix, bs);\r\n            proxy.runStaticInitializer();\r\n        } catch (Throwable t) {\r\n            t.printStackTrace();\r\n        }\r\n    }\r\n    proxy = typeRegistry.cglibProxiesFastClass.get(this.slashedtypename);\r\n    if (proxy != null) {\r\n        Object[] strategyAndFCGeneratorPair = CglibPluginCapturing.clazzToGeneratorStrategyAndFastClassGeneratorMap.get(getClazz());\r\n        strategyAndFCGeneratorPair = CglibPluginCapturing.clazzToGeneratorStrategyAndFastClassGeneratorMap.get(getClazz());\r\n        if (strategyAndFCGeneratorPair != null) {\r\n            Object a = strategyAndFCGeneratorPair[0];\r\n            Object b = strategyAndFCGeneratorPair[1];\r\n            try {\r\n                Method[] ms = a.getClass().getMethods();\r\n                Method found = null;\r\n                for (Method m : ms) {\r\n                    if (m.getName().equals(\"generate\")) {\r\n                        found = m;\r\n                        break;\r\n                    }\r\n                }\r\n                byte[] bs = (byte[]) found.invoke(a, b);\r\n                if (GlobalConfiguration.isRuntimeLogging && log.isLoggable(Level.INFO)) {\r\n                    log.log(Level.INFO, \"Proxy (fastclass) regenerate successful for \" + this.slashedtypename);\r\n                }\r\n                proxy.loadNewVersion(versionsuffix, bs);\r\n                proxy.runStaticInitializer();\r\n            } catch (Throwable t) {\r\n                t.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n    try {\r\n        if (this.clazz.isInterface()) {\r\n            Set<ReloadableType> relevantProxies = typeRegistry.jdkProxiesForInterface.get(this.slashedtypename);\r\n            if (relevantProxies != null) {\r\n                for (ReloadableType relevantProxy : relevantProxies) {\r\n                    Class<?>[] interfacesImplementedByProxy = relevantProxy.getClazz().getInterfaces();\r\n                    byte[] newProxyBytes = Utils.generateProxyClass(relevantProxy.getSlashedName(), interfacesImplementedByProxy);\r\n                    relevantProxy.loadNewVersion(versionsuffix, newProxyBytes, true);\r\n                }\r\n            }\r\n        }\r\n    } catch (Throwable t) {\r\n        new RuntimeException(\"Unexpected problem trying to reload proxy for interface \" + this.dottedtypename, t).printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "com.querydsl.sql.ColumnMetadata.getSize",
	"Comment": "for char or date types this is the maximum number of characters, for numeric or decimal types this is precision.",
	"Method": "int getSize(){\r\n    return size;\r\n}"
}, {
	"Path": "io.rx_cache2.internal.cache.memory.apache.AbstractReferenceMap.init",
	"Comment": "initialise this subclass during construction, cloning or deserialization.",
	"Method": "void init(){\r\n    queue = new ReferenceQueue<Object>();\r\n}"
}, {
	"Path": "com.r0adkll.slidr.model.SlidrConfig.getScrimEndAlpha",
	"Comment": "get the end alpha value for when the user almost swipes the activity off the screen",
	"Method": "float getScrimEndAlpha(){\r\n    return scrimEndAlpha;\r\n}"
}, {
	"Path": "com.querydsl.spatial.GeometryExpressions.dwithin",
	"Comment": "returns true if the geometries are within the specified distance of one another.for geometry units are in those of spatial reference and for geography units are in meters.",
	"Method": "BooleanExpression dwithin(Expression<? extends Geometry> expr1,Expression<? extends Geometry> expr2,Expression<Double> distance,BooleanExpression dwithin,Expression<? extends Geometry> expr1,Expression<? extends Geometry> expr2,double distance){\r\n    return Expressions.booleanOperation(SpatialOps.DWITHIN, expr1, expr2, ConstantImpl.create(distance));\r\n}"
}, {
	"Path": "com.r0adkll.slidr.util.ViewDragHelper.getEdgeSize",
	"Comment": "return the size of an edge. this is the range in pixels along the edges of this viewthat will actively detect edge touches or drags if edge tracking is enabled.",
	"Method": "int getEdgeSize(){\r\n    return mEdgeSize;\r\n}"
}, {
	"Path": "org.springsource.loaded.TypeRegistry.recordBootstrapMethod",
	"Comment": "when an invokedynamic instruction is reached, we allocate an id that recognizes that bsm and the parameters to\tthat bsm. the index can be used when rewriting that invokedynamic",
	"Method": "int recordBootstrapMethod(String slashedClassName,Handle bsm,Object[] bsmArgs){\r\n    if (bsmmap == null) {\r\n        bsmmap = new HashMap<String, BsmInfo[]>();\r\n    }\r\n    BsmInfo[] bsminfo = bsmmap.get(slashedClassName);\r\n    if (bsminfo == null) {\r\n        bsminfo = new BsmInfo[1];\r\n        bsminfo[0] = new BsmInfo(bsm, bsmArgs);\r\n        bsmmap.put(slashedClassName, bsminfo);\r\n        return 0;\r\n    } else {\r\n        int len = bsminfo.length;\r\n        BsmInfo[] newarray = new BsmInfo[len + 1];\r\n        System.arraycopy(bsminfo, 0, newarray, 0, len);\r\n        bsminfo = newarray;\r\n        bsmmap.put(slashedClassName, bsminfo);\r\n        bsminfo[len] = new BsmInfo(bsm, bsmArgs);\r\n        return len;\r\n    }\r\n}"
}, {
	"Path": "org.springsource.loaded.test.TypeRewriterTests.constructorReloading3",
	"Comment": "test that also relies on correct dispatch to super constructors to do things",
	"Method": "void constructorReloading3(){\r\n    String t = \"ctors.Three\";\r\n    String st = \"ctors.SuperThree\";\r\n    TypeRegistry r = getTypeRegistry(t + \",ctors.SuperThree\");\r\n    ReloadableType supertype = r.addType(\"ctors.SuperThree\", loadBytesForClass(\"ctors.SuperThree\"));\r\n    ReloadableType rtype = r.addType(t, loadBytesForClass(t));\r\n    result = runConstructor(rtype.getClazz(), \"\");\r\n    assertEquals(\"Hello from SuperThree.Hello from Three.\", result.stderr);\r\n    assertEquals(rtype.getClazz().getName(), result.returnValue.getClass().getName());\r\n    rtype.loadNewVersion(\"000\", rtype.bytesInitial);\r\n    result = runConstructor(rtype.getClazz(), \"\");\r\n    assertEquals(\"Hello from SuperThree.Hello from Three.\", result.stderr);\r\n    assertEquals(rtype.getClazz().getName(), result.returnValue.getClass().getName());\r\n    rtype.loadNewVersion(\"002\", retrieveRename(t, t + \"2\"));\r\n    result = runConstructor(rtype.getClazz(), \"\");\r\n    assertEquals(\"Hello from SuperThree.Hello from Three2.\", result.stderr);\r\n    assertEquals(rtype.getClazz().getName(), result.returnValue.getClass().getName());\r\n    supertype.loadNewVersion(\"002\", retrieveRename(st, st + \"2\"));\r\n    result = runConstructor(rtype.getClazz(), \"\");\r\n    assertEquals(\"Hello from SuperThree2.Hello from Three2.\", result.stderr);\r\n    assertEquals(rtype.getClazz().getName(), result.returnValue.getClass().getName());\r\n}"
}, {
	"Path": "com.alipay.sofa.rpc.codec.snappy.SnappyCompressor.writeUncompressedLength",
	"Comment": "writes the uncompressed length as variable length integer.",
	"Method": "int writeUncompressedLength(byte[] compressed,int compressedOffset,int uncompressedLength){\r\n    int highBitMask = 0x80;\r\n    if (uncompressedLength < (1 << 7) && uncompressedLength >= 0) {\r\n        compressed[compressedOffset++] = (byte) (uncompressedLength);\r\n    } else if (uncompressedLength < (1 << 14) && uncompressedLength > 0) {\r\n        compressed[compressedOffset++] = (byte) (uncompressedLength | highBitMask);\r\n        compressed[compressedOffset++] = (byte) (uncompressedLength >>> 7);\r\n    } else if (uncompressedLength < (1 << 21) && uncompressedLength > 0) {\r\n        compressed[compressedOffset++] = (byte) (uncompressedLength | highBitMask);\r\n        compressed[compressedOffset++] = (byte) ((uncompressedLength >>> 7) | highBitMask);\r\n        compressed[compressedOffset++] = (byte) (uncompressedLength >>> 14);\r\n    } else if (uncompressedLength < (1 << 28) && uncompressedLength > 0) {\r\n        compressed[compressedOffset++] = (byte) (uncompressedLength | highBitMask);\r\n        compressed[compressedOffset++] = (byte) ((uncompressedLength >>> 7) | highBitMask);\r\n        compressed[compressedOffset++] = (byte) ((uncompressedLength >>> 14) | highBitMask);\r\n        compressed[compressedOffset++] = (byte) (uncompressedLength >>> 21);\r\n    } else {\r\n        compressed[compressedOffset++] = (byte) (uncompressedLength | highBitMask);\r\n        compressed[compressedOffset++] = (byte) ((uncompressedLength >>> 7) | highBitMask);\r\n        compressed[compressedOffset++] = (byte) ((uncompressedLength >>> 14) | highBitMask);\r\n        compressed[compressedOffset++] = (byte) ((uncompressedLength >>> 21) | highBitMask);\r\n        compressed[compressedOffset++] = (byte) (uncompressedLength >>> 28);\r\n    }\r\n    return compressedOffset;\r\n}"
}, {
	"Path": "org.springsource.loaded.test.SuperDispatcherTests.basic",
	"Comment": "a reloadable type extends a type and overrides a protected method from that type.",
	"Method": "void basic(){\r\n    String t = \"foo.ControllerB\";\r\n    TypeRegistry typeRegistry = getTypeRegistry(t);\r\n    ReloadableType rtype = typeRegistry.addType(t, loadBytesForClass(t));\r\n    String rtypeDisassembled = toStringClass(rtype.bytesLoaded);\r\n    assertEquals(16, countMethods(rtype.bytesLoaded));\r\n    assertEquals(1, filter(getMethods(rtype.bytesLoaded), methodSuffixSuperDispatcher).size());\r\n    String expectedName = \"foo\" + methodSuffixSuperDispatcher;\r\n    assertContains(\"METHOD: 0x0001(public) \" + expectedName + \"()V\", rtypeDisassembled);\r\n    assertContains(\"    ALOAD 0\\n\" + \"    INVOKESPECIAL grails/TopB.foo()V\\n\" + \"    RETURN\\n\", toStringMethod(rtype.bytesLoaded, expectedName, false));\r\n    String stdout = runOnInstance(rtype.getClazz(), rtype.getClazz().newInstance(), \"foo\").stdout;\r\n    assertEquals(\"TopB.foo() running\\nControllerB.foo() running\", stdout);\r\n    Assert.assertTrue(rtype.loadNewVersion(\"2\", retrieveRename(t, t + \"2\")));\r\n    stdout = runOnInstance(rtype.getClazz(), rtype.getClazz().newInstance(), \"foo\").stdout;\r\n    assertEquals(\"TopB.foo() running\\nControllerB.foo() running again!\", stdout);\r\n}"
}, {
	"Path": "org.testcontainers.containers.wait.strategy.Wait.forListeningPort",
	"Comment": "convenience method to return a waitstrategy for an exposed or mapped port.",
	"Method": "HostPortWaitStrategy forListeningPort(){\r\n    return new HostPortWaitStrategy();\r\n}"
}, {
	"Path": "com.querydsl.spatial.jts.JTSGeometryCollectionExpression.numGeometries",
	"Comment": "returns the number of geometries in this geometrycollection.",
	"Method": "NumberExpression<Integer> numGeometries(){\r\n    if (numGeometries == null) {\r\n        numGeometries = Expressions.numberOperation(Integer.class, SpatialOps.NUM_GEOMETRIES, mixin);\r\n    }\r\n    return numGeometries;\r\n}"
}, {
	"Path": "com.simplecity.amp_library.ui.fragments.BaseFragment.getNextAnimationDuration",
	"Comment": "attempt to get the resource id of the next animation thatwill be applied to the given fragment.",
	"Method": "long getNextAnimationDuration(Fragment fragment,long defValue){\r\n    try {\r\n        Field nextAnimField = Fragment.class.getDeclaredField(\"mNextAnim\");\r\n        nextAnimField.setAccessible(true);\r\n        int nextAnimResource = nextAnimField.getInt(fragment);\r\n        Animation nextAnim = AnimationUtils.loadAnimation(fragment.getActivity(), nextAnimResource);\r\n        return (nextAnim == null) ? defValue : nextAnim.getDuration();\r\n    } catch (NoSuchFieldException | IllegalAccessException | Resources.NotFoundException ignored) {\r\n        return defValue;\r\n    }\r\n}"
}, {
	"Path": "org.springsource.loaded.testgen.GenerativeSpringLoadedTest.getReloableTypeConfig",
	"Comment": "override this in your own test class to configure springloaded type registry.",
	"Method": "String getReloableTypeConfig(){\r\n    String targetPackage = getTargetPackage();\r\n    Assert.assertNotNull(targetPackage);\r\n    return targetPackage + \"..*\";\r\n}"
}, {
	"Path": "io.rx_cache2.ActionsList.evictAllKeepingLastN",
	"Comment": "evict elements from the cache starting from the last position until its count is equal to thevalue specified in n param.",
	"Method": "ActionsList<T> evictAllKeepingLastN(int n){\r\n    Func3<T> func3 = new Func3<T>() {\r\n        @Override\r\n        public boolean call(int position, int count, T element) {\r\n            int elementsToEvict = count - n;\r\n            return position < elementsToEvict;\r\n        }\r\n    };\r\n    return evictIterable(func3);\r\n}"
}, {
	"Path": "io.rx_cache2.ActionsList.evictAllKeepingLastN",
	"Comment": "evict elements from the cache starting from the last position until its count is equal to thevalue specified in n param.",
	"Method": "ActionsList<T> evictAllKeepingLastN(int n){\r\n    int elementsToEvict = count - n;\r\n    return position < elementsToEvict;\r\n}"
}, {
	"Path": "com.nanchen.rxjava2examples.ui.SystemBarTintManager.setTintResource",
	"Comment": "apply the specified drawable or color resource to all system ui bars.",
	"Method": "void setTintResource(int res){\r\n    setStatusBarTintResource(res);\r\n    setNavigationBarTintResource(res);\r\n}"
}, {
	"Path": "org.spockframework.runtime.extension.builtin.IncludeExcludeExtension.handleFeatureIncludes",
	"Comment": "in contrast to the three other handlexxx methods, this one includes nodes",
	"Method": "void handleFeatureIncludes(SpecInfo spec,IncludeExcludeCriteria criteria){\r\n    if (criteria.isEmpty())\r\n        return;\r\n    for (FeatureInfo feature : spec.getAllFeatures()) if (hasAnyAnnotation(feature.getFeatureMethod(), criteria.annotations))\r\n        feature.setExcluded(false);\r\n}"
}, {
	"Path": "io.rx_cache2.internal.cache.memory.apache.AbstractHashedMap.removeEntry",
	"Comment": "removes an entry from the chain stored in a particular index.this implementation removes the entry from the data storage table.the size is not updated.subclasses could override to handle changes to the map.",
	"Method": "void removeEntry(HashEntry<K, V> entry,int hashIndex,HashEntry<K, V> previous){\r\n    if (previous == null) {\r\n        data[hashIndex] = entry.next;\r\n    } else {\r\n        previous.next = entry.next;\r\n    }\r\n}"
}, {
	"Path": "org.spockframework.util.TextUtil.getTrailingWhitespace",
	"Comment": "returns the number of whitespace characters at the end of the given line.",
	"Method": "int getTrailingWhitespace(String line){\r\n    return line.length() - line.trim().length() - getIndent(line);\r\n}"
}, {
	"Path": "com.querydsl.spatial.jts.JTSGeometryExpression.union",
	"Comment": "returns a geometric object that represents the point setunion of this geometric object with anothergeometry.",
	"Method": "JTSGeometryExpression<Geometry> union(Geometry geometry,JTSGeometryExpression<Geometry> union,Expression<? extends Geometry> geometry){\r\n    return JTSGeometryExpressions.geometryOperation(SpatialOps.UNION, mixin, geometry);\r\n}"
}, {
	"Path": "org.springsource.loaded.test.CodeGenerationTests.testInterfaceWriting2",
	"Comment": "like the previous test but now we invoke a new method on the interface.",
	"Method": "void testInterfaceWriting2(){\r\n    TypeRegistry typeRegistry = getTypeRegistry(\"\");\r\n    String theInterface = \"interfacerewriting.TheInterface\";\r\n    String theImpl = \"interfacerewriting.TheImpl\";\r\n    String runner = \"interfacerewriting.TheRunner\";\r\n    configureForTesting(typeRegistry, theInterface + \",\" + theImpl + \",\" + runner);\r\n    ReloadableType rInterface = typeRegistry.addType(theInterface, loadBytesForClass(theInterface));\r\n    ReloadableType rImpl = typeRegistry.addType(theImpl, loadBytesForClass(theImpl));\r\n    ReloadableType rRunner = typeRegistry.addType(runner, loadBytesForClass(runner));\r\n    String[] retargets = new String[] { theInterface + \"002:\" + theInterface, theImpl + \"002:\" + theImpl, runner + \"002:\" + runner };\r\n    Result result = runUnguarded(rRunner.getClazz(), \"run\");\r\n    assertNull(result.returnValue);\r\n    rInterface.loadNewVersion(\"002\", ClassRenamer.rename(theInterface, loadBytesForClass(theInterface + \"002\"), retargets));\r\n    rImpl.loadNewVersion(\"002\", ClassRenamer.rename(theImpl, loadBytesForClass(theImpl + \"002\"), retargets));\r\n    rRunner.loadNewVersion(\"002\", ClassRenamer.rename(runner, loadBytesForClass(runner + \"002\"), retargets));\r\n    result = runUnguarded(rRunner.getClazz(), \"run\");\r\n    assertEquals(\"abc\", result.returnValue);\r\n}"
}, {
	"Path": "org.springsource.loaded.TypeRegistry.associateReloadableType",
	"Comment": "called from the static initializer of a reloadabletype, allowing it to connect itself to the parent type, such\tthat when reloading occurs we can mark all relevant types in the hierarchy as being impacted by the reload.",
	"Method": "void associateReloadableType(ReloadableType child,Class<?> parent){\r\n    ClassLoader parentClassLoader = parent.getClassLoader();\r\n    if (parentClassLoader == null) {\r\n        return;\r\n    }\r\n    TypeRegistry parentTypeRegistry = TypeRegistry.getTypeRegistryFor(parent.getClassLoader());\r\n    ReloadableType parentReloadableType = parentTypeRegistry.getReloadableType(parent);\r\n    if (parentReloadableType != null) {\r\n        parentReloadableType.recordSubtype(child);\r\n    }\r\n}"
}, {
	"Path": "org.springsource.loaded.test.MethodInvokerRewriterTests.invokevirtualNonCatchers",
	"Comment": "testing what happens when reloading introduces a new method in the supertype that is called from the subtype.",
	"Method": "void invokevirtualNonCatchers(){\r\n    String top = \"virtual.FourTop\";\r\n    String bot = \"virtual.FourBot\";\r\n    TypeRegistry typeRegistry = getTypeRegistry(top + \",\" + bot);\r\n    ReloadableType topR = typeRegistry.addType(top, loadBytesForClass(top));\r\n    ReloadableType botR = typeRegistry.addType(bot, loadBytesForClass(bot));\r\n    result = runUnguarded(botR.getClazz(), \"run\");\r\n    assertEquals(42, result.returnValue);\r\n    topR.loadNewVersion(retrieveRename(top, top + \"2\"));\r\n    botR.loadNewVersion(retrieveRename(bot, bot + \"2\", top + \"2:\" + top));\r\n    result = runUnguarded(botR.getClazz(), \"run\");\r\n    assertEquals(77, result.returnValue);\r\n}"
}, {
	"Path": "com.querydsl.spatial.jts.JTSGeometryExpression.buffer",
	"Comment": "returns a geometric object that represents all points whose distance from this geometricobject is less than or equal to distance. calculations are in the spatial reference systemof this geometric object. because of the limitations of linear interpolation, there willoften be some relatively small error in this distance, but it should be near the resolutionof the coordinates used.",
	"Method": "JTSGeometryExpression<Geometry> buffer(double distance){\r\n    return JTSGeometryExpressions.geometryOperation(SpatialOps.BUFFER, mixin, ConstantImpl.create(distance));\r\n}"
}, {
	"Path": "reflection.FieldInvoker.setFieldWithAccess",
	"Comment": "sets a field in class, can override access constraints if requested to do so.",
	"Method": "void setFieldWithAccess(Class<?> targetClass,String whichField,boolean setAccess){\r\n    Object targetInstance = targetClass.newInstance();\r\n    Field field = targetClass.getDeclaredField(whichField);\r\n    if (setAccess) {\r\n        field.setAccessible(true);\r\n    }\r\n    if (field.getType().equals(int.class)) {\r\n        field.set(targetInstance, 888);\r\n    } else {\r\n        field.set(targetInstance, \"<BANG>\");\r\n    }\r\n}"
}, {
	"Path": "com.simplecity.amp_library.utils.ArtworkUtils.getTagArtwork",
	"Comment": "retrieves the artwork from the id3 tags of the file at the given path.",
	"Method": "InputStream getTagArtwork(String filePath){\r\n    InputStream inputStream = null;\r\n    if (filePath != null) {\r\n        try {\r\n            AudioFile audioFIle = AudioFileIO.read(new File(filePath));\r\n            if (audioFIle != null) {\r\n                Tag tag = audioFIle.getTag();\r\n                if (tag != null) {\r\n                    org.jaudiotagger.tag.datatype.Artwork artwork = tag.getFirstArtwork();\r\n                    if (artwork != null) {\r\n                        inputStream = new ByteArrayInputStream(artwork.getBinaryData());\r\n                    }\r\n                }\r\n            }\r\n        } catch (CannotReadException | IOException | TagException | ReadOnlyFileException | InvalidAudioFrameException ignored) {\r\n        }\r\n    }\r\n    return inputStream;\r\n}"
}, {
	"Path": "com.klinker.android.twitter.activities.scheduled_tweets.NewScheduledTweet.discardClick",
	"Comment": "finishes the activity when the discard button is clicked, without making any changes or saving anything",
	"Method": "boolean discardClick(){\r\n    finish();\r\n    return true;\r\n}"
}, {
	"Path": "org.testcontainers.containers.wait.Wait.forLogMessage",
	"Comment": "convenience method to return a waitstrategy for log messages.",
	"Method": "LogMessageWaitStrategy forLogMessage(String regex,int times){\r\n    return new LogMessageWaitStrategy().withRegEx(regex).withTimes(times);\r\n}"
}, {
	"Path": "com.querydsl.spatial.GeometryExpression.geometryType",
	"Comment": "returns the name of the instantiable subtype of geometry of which thisgeometric object is an instantiable member. the name of the subtype of geometry is returned as a string.",
	"Method": "StringExpression geometryType(){\r\n    if (geometryType == null) {\r\n        geometryType = Expressions.stringOperation(SpatialOps.GEOMETRY_TYPE, mixin);\r\n    }\r\n    return geometryType;\r\n}"
}, {
	"Path": "android.support.design.widget.CustomCollapsingToolbarLayout.setExpandedTitleTextAppearance",
	"Comment": "sets the text color and size for the expanded title from the specifiedtextappearance resource.",
	"Method": "void setExpandedTitleTextAppearance(int resId){\r\n    mCollapsingTextHelper.setExpandedTextAppearance(resId);\r\n}"
}, {
	"Path": "com.squareup.tape2.ObjectQueue.createInMemory",
	"Comment": "a queue for objects that are not serious enough to be written to disk. objects in this queueare kept in memory and will not be serialized.",
	"Method": "ObjectQueue<T> createInMemory(){\r\n    return new InMemoryObjectQueue();\r\n}"
}, {
	"Path": "com.querydsl.spatial.GeometryExpression.srid",
	"Comment": "returns the spatial reference system id for this geometric object. this will normally be aforeign key to an index of reference systems stored in either the same or some other datastore.",
	"Method": "NumberExpression<Integer> srid(){\r\n    if (srid == null) {\r\n        srid = Expressions.numberOperation(Integer.class, SpatialOps.SRID, mixin);\r\n    }\r\n    return srid;\r\n}"
}, {
	"Path": "com.simplecity.amp_library.playback.QueueManager.saveQueue",
	"Comment": "saves our state to preferences, including the queue position, repeat mode & shuffle mode.",
	"Method": "void saveQueue(boolean saveQueue){\r\n    if (!queueIsSaveable) {\r\n        return;\r\n    }\r\n    if (queueReloading) {\r\n        return;\r\n    }\r\n    if (saveQueue) {\r\n        PlaybackSettingsManager.INSTANCE.setQueueList(serializePlaylist(playlist));\r\n        if (shuffleMode == ShuffleMode.ON) {\r\n            PlaybackSettingsManager.INSTANCE.setShuffleList(serializePlaylist(shuffleList));\r\n        }\r\n    }\r\n    PlaybackSettingsManager.INSTANCE.setQueuePosition(queuePosition);\r\n    PlaybackSettingsManager.INSTANCE.setRepeatMode(repeatMode);\r\n    PlaybackSettingsManager.INSTANCE.setShuffleMode(shuffleMode);\r\n}"
}, {
	"Path": "uk.co.real_logic.sbe.xml.CompositeType.checkForValidOffsets",
	"Comment": "check the composite for any specified offsets and validate they are correctly specified.",
	"Method": "void checkForValidOffsets(Node node){\r\n    int offset = 0;\r\n    for (final Type edt : containedTypeByNameMap.values()) {\r\n        final int offsetAttribute = edt.offsetAttribute();\r\n        if (-1 != offsetAttribute) {\r\n            if (offsetAttribute < offset) {\r\n                XmlSchemaParser.handleError(node, String.format(\"composite element \\\"%s\\\" has incorrect offset specified\", edt.name()));\r\n            }\r\n            offset = offsetAttribute;\r\n        }\r\n        offset += edt.encodedLength();\r\n    }\r\n}"
}, {
	"Path": "org.springsource.loaded.ri.test.ClassReflectionTests.test_invokeProtectedInheritedMethod",
	"Comment": "test getdeclaredmethod and invoke for protected inherited method.",
	"Method": "void test_invokeProtectedInheritedMethod(){\r\n    String subClassName = TARGET_PACKAGE + \".SubClassTarget\";\r\n    ReloadableType subTarget = registry.addType(subClassName, loadBytesForClass(subClassName));\r\n    try {\r\n        getDeclaredMethod(subTarget.getClazz(), \"protectedMethod\");\r\n        Assert.fail(\"A protected inherited method should not be considered 'declared' in the subclass\");\r\n    } catch (ResultException e) {\r\n        assertNoSuchMethodException(subClassName + \".protectedMethod()\", e);\r\n    }\r\n    Object subInstance = subTarget.getClazz().newInstance();\r\n    Method m = (Method) getDeclaredMethod(\"protectedMethod\").returnValue;\r\n    m.setAccessible(true);\r\n    Result r = invokeOn(subInstance, m);\r\n    Assert.assertEquals(\"protectedMethod result\", r.returnValue);\r\n    reloadType(subTarget, \"002\");\r\n    r = getDeclaredMethod(subTarget.getClazz(), \"protectedMethod\");\r\n    assertMethod(\"protected java.lang.String \" + subClassName + \".protectedMethod()\", r);\r\n    m = (Method) r.returnValue;\r\n    try {\r\n        invokeOn(subInstance, m);\r\n        Assert.fail(\"invoker class is in different package than target class shouldn't be allowed to invoke protected method!\");\r\n    } catch (ResultException e) {\r\n        assertIllegalAccess(\"Class \" + callerClazz.getName() + \" can not access a member of class \" + subTarget.dottedtypename + \" with modifiers \\\"protected\\\"\", e);\r\n    }\r\n    m.setAccessible(true);\r\n    r = invokeOn(subInstance, m);\r\n    Assert.assertEquals(\"SubClassTarget002.protectedMethod\", r.returnValue);\r\n}"
}, {
	"Path": "uk.co.senab.photoview.PhotoViewAttacher.getDisplayRect",
	"Comment": "helper method that maps the supplied matrix to the current drawable",
	"Method": "RectF getDisplayRect(RectF getDisplayRect,Matrix matrix){\r\n    ImageView imageView = getImageView();\r\n    if (null != imageView) {\r\n        Drawable d = imageView.getDrawable();\r\n        if (null != d) {\r\n            mDisplayRect.set(0, 0, d.getIntrinsicWidth(), d.getIntrinsicHeight());\r\n            matrix.mapRect(mDisplayRect);\r\n            return mDisplayRect;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.testng.internal.ClassHelper.findAnnotatedConstructor",
	"Comment": "find the best constructor given the parameters found on the annotation",
	"Method": "Constructor<?> findAnnotatedConstructor(IAnnotationFinder finder,Class<?> declaringClass){\r\n    Constructor<?>[] constructors = declaringClass.getDeclaredConstructors();\r\n    for (Constructor<?> result : constructors) {\r\n        IParametersAnnotation parametersAnnotation = finder.findAnnotation(result, IParametersAnnotation.class);\r\n        if (parametersAnnotation != null) {\r\n            String[] parameters = parametersAnnotation.getValue();\r\n            Class<?>[] parameterTypes = result.getParameterTypes();\r\n            if (parameters.length != parameterTypes.length) {\r\n                throw new TestNGException(\"Parameter count mismatch:  \" + result + \"\\naccepts \" + parameterTypes.length + \" parameters but the @Test annotation declares \" + parameters.length);\r\n            }\r\n            return result;\r\n        }\r\n        IFactoryAnnotation factoryAnnotation = finder.findAnnotation(result, IFactoryAnnotation.class);\r\n        if (factoryAnnotation != null) {\r\n            return result;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.querydsl.sql.SQLSerializer.getIdentifierColumns",
	"Comment": "return a list of expressions that can be used to uniquely define the query sources",
	"Method": "List<Expression<?>> getIdentifierColumns(List<JoinExpression> joins,boolean alias){\r\n    if (joins.size() == 1) {\r\n        JoinExpression join = joins.get(0);\r\n        if (join.getTarget() instanceof RelationalPath) {\r\n            return ((RelationalPath) join.getTarget()).getColumns();\r\n        } else {\r\n            return Collections.emptyList();\r\n        }\r\n    } else {\r\n        List<Expression<?>> rv = Lists.newArrayList();\r\n        int counter = 0;\r\n        for (JoinExpression join : joins) {\r\n            if (join.getTarget() instanceof RelationalPath) {\r\n                RelationalPath path = (RelationalPath) join.getTarget();\r\n                List<Expression<?>> columns;\r\n                if (path.getPrimaryKey() != null) {\r\n                    columns = path.getPrimaryKey().getLocalColumns();\r\n                } else {\r\n                    columns = path.getColumns();\r\n                }\r\n                if (alias) {\r\n                    for (Expression<?> column : columns) {\r\n                        rv.add(ExpressionUtils.as(column, \"col\" + (++counter)));\r\n                    }\r\n                } else {\r\n                    rv.addAll(columns);\r\n                }\r\n            } else {\r\n                return Collections.emptyList();\r\n            }\r\n        }\r\n        return rv;\r\n    }\r\n}"
}, {
	"Path": "org.springsource.loaded.test.SpringLoadedTests.runMethodAndCollectOutput",
	"Comment": "execute a specific method, returning all output that occurred during the run to the caller.",
	"Method": "String runMethodAndCollectOutput(Class<?> clazz,String methodname){\r\n    captureOn();\r\n    Method m = clazz.getDeclaredMethod(methodname);\r\n    if (!Modifier.isStatic(m.getModifiers())) {\r\n        fail(\"Method should be static: \" + m);\r\n    }\r\n    m.invoke(null);\r\n    return captureOff();\r\n}"
}, {
	"Path": "com.querydsl.sql.SQLExpressions.stddev",
	"Comment": "returns the sample standard deviation of expr, a set of numbers.",
	"Method": "WindowOver<T> stddev(Expression<T> expr){\r\n    return new WindowOver<T>(expr.getType(), SQLOps.STDDEV, expr);\r\n}"
}, {
	"Path": "com.squareup.tape2.QueueFile.ringRead",
	"Comment": "reads count bytes into buffer from file. wraps if necessary.",
	"Method": "void ringRead(long position,byte[] buffer,int offset,int count){\r\n    position = wrapPosition(position);\r\n    if (position + count <= fileLength) {\r\n        raf.seek(position);\r\n        raf.readFully(buffer, offset, count);\r\n    } else {\r\n        int beforeEof = (int) (fileLength - position);\r\n        raf.seek(position);\r\n        raf.readFully(buffer, offset, beforeEof);\r\n        raf.seek(headerLength);\r\n        raf.readFully(buffer, offset + beforeEof, count - beforeEof);\r\n    }\r\n}"
}, {
	"Path": "uk.co.real_logic.sbe.ir.Token.version",
	"Comment": "the version context for this token. this is the schema version in which the type was introduced.",
	"Method": "int version(Builder version,int version){\r\n    return version;\r\n}"
}, {
	"Path": "com.nanchen.rxjava2examples.ui.SystemBarTintManager.setNavigationBarTintResource",
	"Comment": "apply the specified drawable or color resource to the system navigation bar.",
	"Method": "void setNavigationBarTintResource(int res){\r\n    if (mNavBarAvailable) {\r\n        mNavBarTintView.setBackgroundResource(res);\r\n    }\r\n}"
}, {
	"Path": "org.springsource.loaded.ReloadableType.setField",
	"Comment": "attempt to set the value of a field on an instance to the specified value.",
	"Method": "void setField(Object instance,String fieldname,boolean isStatic,Object newValue){\r\n    FieldReaderWriter fieldReaderWriter = locateField(fieldname);\r\n    if (isStatic && !fieldReaderWriter.isStatic()) {\r\n        throw new IncompatibleClassChangeError(\"Expected static field \" + fieldReaderWriter.theField.getDeclaringTypeName() + \".\" + fieldReaderWriter.theField.getName());\r\n    } else if (!isStatic && fieldReaderWriter.isStatic()) {\r\n        throw new IncompatibleClassChangeError(\"Expected non-static field \" + fieldReaderWriter.theField.getDeclaringTypeName() + \".\" + fieldReaderWriter.theField.getName());\r\n    }\r\n    if (fieldReaderWriter.isStatic()) {\r\n        fieldReaderWriter.setStaticFieldValue(getClazz(), newValue, null);\r\n    } else {\r\n        fieldReaderWriter.setValue(instance, newValue, null);\r\n    }\r\n}"
}, {
	"Path": "uk.co.real_logic.sbe.xml.Type.deprecated",
	"Comment": "version in which type was deprecated. only valid if greater than zero.",
	"Method": "int deprecated(){\r\n    return deprecated;\r\n}"
}, {
	"Path": "org.springsource.loaded.Utils.getSize",
	"Comment": "compute the size required for a specific method descriptor.",
	"Method": "int getSize(String descriptor){\r\n    int size = 0;\r\n    int descriptorpos = 1;\r\n    char ch;\r\n    while ((ch = descriptor.charAt(descriptorpos)) != ')') {\r\n        switch(ch) {\r\n            case '[':\r\n                size++;\r\n                while (descriptor.charAt(++descriptorpos) == '[') {\r\n                    ;\r\n                }\r\n                if (descriptor.charAt(descriptorpos) == 'L') {\r\n                    descriptorpos = descriptor.indexOf(';', descriptorpos) + 1;\r\n                } else {\r\n                    descriptorpos++;\r\n                }\r\n                break;\r\n            case 'L':\r\n                size++;\r\n                descriptorpos = descriptor.indexOf(';', descriptorpos) + 1;\r\n                break;\r\n            case 'J':\r\n                size = size + 2;\r\n                descriptorpos++;\r\n                break;\r\n            case 'D':\r\n                size = size + 2;\r\n                descriptorpos++;\r\n                break;\r\n            case 'F':\r\n            case 'B':\r\n            case 'S':\r\n            case 'I':\r\n            case 'Z':\r\n            case 'C':\r\n                size++;\r\n                descriptorpos++;\r\n                break;\r\n            default:\r\n                throw new IllegalStateException(\"Unexpected character in descriptor: \" + ch);\r\n        }\r\n    }\r\n    return size;\r\n}"
}, {
	"Path": "com.querydsl.spatial.jts.JTSGeometryExpression.boundary",
	"Comment": "returns the closure of the combinatorial boundary of this geometric object",
	"Method": "JTSGeometryExpression<Geometry> boundary(){\r\n    if (boundary == null) {\r\n        boundary = JTSGeometryExpressions.geometryOperation(SpatialOps.BOUNDARY, mixin);\r\n    }\r\n    return boundary;\r\n}"
}, {
	"Path": "org.springsource.loaded.ri.ReflectiveInterceptor.getRType",
	"Comment": "access and return the reloadabletype field on a specified class.",
	"Method": "ReloadableType getRType(Class<?> clazz){\r\n    WeakReference<ReloadableType> ref = classToRType.get(clazz);\r\n    ReloadableType rtype = null;\r\n    if (ref != null) {\r\n        rtype = ref.get();\r\n    }\r\n    if (rtype == null) {\r\n        if (!theOldWay) {\r\n            ClassLoader cl = clazz.getClassLoader();\r\n            TypeRegistry tr = TypeRegistry.getTypeRegistryFor(cl);\r\n            if (tr == null) {\r\n                classToRType.put(clazz, ReloadableType.NOT_RELOADABLE_TYPE_REF);\r\n            } else {\r\n                rtype = tr.getReloadableType(clazz.getName().replace('.', '/'));\r\n                if (rtype == null) {\r\n                    classToRType.put(clazz, ReloadableType.NOT_RELOADABLE_TYPE_REF);\r\n                } else {\r\n                    classToRType.put(clazz, new WeakReference<ReloadableType>(rtype));\r\n                }\r\n            }\r\n        } else {\r\n            Field rtypeField;\r\n            try {\r\n                rtypeField = clazz.getDeclaredField(Constants.fReloadableTypeFieldName);\r\n            } catch (NoSuchFieldException nsfe) {\r\n                classToRType.put(clazz, ReloadableType.NOT_RELOADABLE_TYPE_REF);\r\n                return null;\r\n            }\r\n            try {\r\n                rtypeField.setAccessible(true);\r\n                rtype = (ReloadableType) rtypeField.get(null);\r\n                if (rtype == null) {\r\n                    classToRType.put(clazz, ReloadableType.NOT_RELOADABLE_TYPE_REF);\r\n                    throw new ReloadException(\"ReloadableType field '\" + Constants.fReloadableTypeFieldName + \"' is 'null' on type \" + clazz.getName());\r\n                } else {\r\n                    classToRType.put(clazz, new WeakReference<ReloadableType>(rtype));\r\n                }\r\n            } catch (Exception e) {\r\n                throw new ReloadException(\"Unable to access ReloadableType field '\" + Constants.fReloadableTypeFieldName + \"' on type \" + clazz.getName(), e);\r\n            }\r\n        }\r\n    } else if (rtype == ReloadableType.NOT_RELOADABLE_TYPE) {\r\n        return null;\r\n    }\r\n    return rtype;\r\n}"
}, {
	"Path": "org.testcontainers.containers.wait.Wait.forHttp",
	"Comment": "convenience method to return a waitstrategy for an http endpoint.",
	"Method": "HttpWaitStrategy forHttp(String path){\r\n    return new HttpWaitStrategy().forPath(path);\r\n}"
}, {
	"Path": "uk.co.real_logic.sbe.generation.Generators.findFirst",
	"Comment": "find the first token with a given name from an index inclusive.",
	"Method": "Token findFirst(String name,List<Token> tokens,int index){\r\n    for (int i = index, size = tokens.size(); i < size; i++) {\r\n        final Token token = tokens.get(i);\r\n        if (token.name().equals(name)) {\r\n            return token;\r\n        }\r\n    }\r\n    throw new IllegalStateException(\"name not found: \" + name);\r\n}"
}, {
	"Path": "org.springsource.loaded.ReloadableType.hasFieldChangedInHierarchy",
	"Comment": "want to check if this field looks the same as originally declared and is on the same type as it was",
	"Method": "FieldWalkDiscoveryResult hasFieldChangedInHierarchy(String fieldname,String slashedName,boolean hasFieldChangedInHierarchy,String name){\r\n    ReloadableType rtype = this;\r\n    FieldMember field = null;\r\n    TypeDescriptor originalTypeDescriptor = rtype.getTypeDescriptor();\r\n    FieldMember originalField = originalTypeDescriptor.getField(name);\r\n    TypeDescriptor typedescriptor = rtype.getLatestTypeDescriptor();\r\n    field = typedescriptor.getField(name);\r\n    if (originalField != null && field == null) {\r\n        return true;\r\n    }\r\n    if (originalField != null && field != null) {\r\n        return !originalField.equals(field);\r\n    }\r\n    if (originalField == null && field != null) {\r\n        return true;\r\n    }\r\n    FieldWalkDiscoveryResult b = hasFieldChangedInHierarchy(name, rtype.getTypeDescriptor().getSupertypeName());\r\n    switch(b) {\r\n        case CHANGED_STOPNOW:\r\n            return true;\r\n        case UNCHANGED_STOPWALKINGNOW:\r\n            return false;\r\n        case DONTKNOW:\r\n            throw new IllegalStateException();\r\n    }\r\n    throw new IllegalStateException();\r\n}"
}, {
	"Path": "com.querydsl.sql.SQLExpressions.stddevSamp",
	"Comment": "returns the cumulative sample standard deviation and returns the square root of the sample variance.",
	"Method": "WindowOver<T> stddevSamp(Expression<T> expr){\r\n    return new WindowOver<T>(expr.getType(), SQLOps.STDDEVSAMP, expr);\r\n}"
}, {
	"Path": "org.springsource.loaded.TypeRegistry.idycheck",
	"Comment": "used to determine if the invokedynamic needs to be intercepted.",
	"Method": "Object idycheck(){\r\n    if (TypeRegistry.nothingReloaded) {\r\n        return null;\r\n    } else {\r\n        return \"reloading-happened\";\r\n    }\r\n}"
}, {
	"Path": "org.springsource.loaded.test.CrossLoaderTests.verifyingAssociatedTypesInfo2",
	"Comment": "large scale test loading a bunch of types and verifying what happens in terms of tagging",
	"Method": "void verifyingAssociatedTypesInfo2(){\r\n    ReloadableType bm = subLoader.loadAsReloadableType(\"associatedtypes.CM\");\r\n    ReloadableType cm = subLoader.loadAsReloadableType(\"associatedtypes.CM\");\r\n    assertNotNull(cm);\r\n    assertNotEquals(subLoader, cm.getClazz().getClassLoader());\r\n    ReloadableType im1 = subLoader.loadAsReloadableType(\"associatedtypes.IM\");\r\n    assertNotNull(im1);\r\n    runUnguarded(cm.getClazz(), \"run\");\r\n    assertContains(\"associatedtypes.CM\", toString(im1.getAssociatedSubtypes()));\r\n    assertFalse(cm.isAffectedByReload());\r\n    assertFalse(cm.isAffectedByReload());\r\n    assertFalse(bm.isAffectedByReload());\r\n    cm.loadNewVersion(\"2\", cm.bytesInitial);\r\n    assertTrue(cm.isAffectedByReload());\r\n    assertTrue(im1.isAffectedByReload());\r\n    assertTrue(bm.isAffectedByReload());\r\n}"
}, {
	"Path": "com.nanchen.rxjava2examples.ui.SystemBarTintManager.setStatusBarTintResource",
	"Comment": "apply the specified drawable or color resource to the system status bar.",
	"Method": "void setStatusBarTintResource(int res){\r\n    if (mStatusBarAvailable) {\r\n        mStatusBarTintView.setBackgroundResource(res);\r\n    }\r\n}"
}, {
	"Path": "com.afollestad.aesthetic.Aesthetic.apply",
	"Comment": "notifies all listening views that theme properties have been updated.",
	"Method": "void apply(){\r\n    editor.commit();\r\n}"
}, {
	"Path": "org.springsource.loaded.test.Java8Tests.defaultMethods",
	"Comment": "that default method is reloaded and modified to do something else.",
	"Method": "void defaultMethods(){\r\n    String t = \"basic.DefaultMethodsI1A\";\r\n    String t2 = \"basic.DefaultMethodsC1A\";\r\n    TypeRegistry typeRegistry = getTypeRegistry(\"basic..*\");\r\n    byte[] ia = loadBytesForClass(t);\r\n    ReloadableType rtypeI = typeRegistry.addType(t, ia);\r\n    byte[] ca = loadBytesForClass(t2);\r\n    ReloadableType rtypeC = typeRegistry.addType(t2, ca);\r\n    Class<?> simpleClass = rtypeC.getClazz();\r\n    Result r = runUnguarded(simpleClass, \"run\");\r\n    r = runUnguarded(simpleClass, \"run\");\r\n    assertEquals(42, r.returnValue);\r\n    rtypeI.loadNewVersion(\"002\", ia);\r\n    r = runUnguarded(simpleClass, \"run\");\r\n    assertEquals(42, r.returnValue);\r\n    byte[] renamed2 = retrieveRename(t, t + \"2\");\r\n    rtypeI.loadNewVersion(renamed2);\r\n    r = runUnguarded(simpleClass, \"run\");\r\n    assertEquals(42, r.returnValue);\r\n    assertEquals(\"FOO\", r.stdout);\r\n}"
}, {
	"Path": "org.testng.internal.ClassHelper.forName",
	"Comment": "tries to load the specified class using the context classloader or if none, than from thedefault classloader. this method differs from the standard class loading methods in that itdoes not throw an exception if the class is not found but returns null instead.",
	"Method": "Class<?> forName(String className){\r\n    List<ClassLoader> allClassLoaders = appendContextualClassLoaders(classLoaders);\r\n    for (ClassLoader classLoader : allClassLoaders) {\r\n        if (null == classLoader) {\r\n            continue;\r\n        }\r\n        try {\r\n            return classLoader.loadClass(className);\r\n        } catch (ClassNotFoundException ex) {\r\n            if (classLoaders.isEmpty()) {\r\n                logClassNotFoundError(className, ex);\r\n            }\r\n        }\r\n    }\r\n    if (RuntimeBehavior.shouldSkipUsingCallerClassLoader()) {\r\n        return null;\r\n    }\r\n    try {\r\n        return Class.forName(className);\r\n    } catch (ClassNotFoundException cnfe) {\r\n        logClassNotFoundError(className, cnfe);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.cloud.alicloud.oss.resource.OssStorageResource.getOSSObject",
	"Comment": "gets the underlying resource object in aliyun object storage service.",
	"Method": "OSSObject getOSSObject(){\r\n    return this.oss.getObject(this.bucketName, this.objectKey);\r\n}"
}, {
	"Path": "org.springsource.loaded.Utils.toPaddedNumber",
	"Comment": "create the string representation of an integer and pad it to a particular width using leading zeroes.",
	"Method": "String toPaddedNumber(int value,int width){\r\n    StringBuilder s = new StringBuilder(\"00000000\").append(Integer.toString(value));\r\n    return s.substring(s.length() - width);\r\n}"
}, {
	"Path": "org.springsource.loaded.ri.test.ClassReflectionTests.test_cacheGetDeclaredMethodDeletedAndInvoke",
	"Comment": "testing class.getdeclaredmethod and method.invoke\twhat happens if we invoke a cached method object when the method it refers to was deleted?",
	"Method": "void test_cacheGetDeclaredMethodDeletedAndInvoke(){\r\n    Method m = (Method) getDeclaredMethod(\"methodDeleted\").returnValue;\r\n    Result r = invoke(m);\r\n    Assert.assertEquals(37, r.returnValue);\r\n    reloadType(\"002\");\r\n    try {\r\n        invoke(m);\r\n        fail(\"Invoking a deleted method should fail\");\r\n    } catch (ResultException e) {\r\n        assertNoSuchMethodError(TARGET_CLASS_NAME + \".methodDeleted()I\", e);\r\n    }\r\n}"
}, {
	"Path": "org.springsource.loaded.test.CglibProxyTests.runMethodAndCollectOutput",
	"Comment": "execute a specific method, returning all output that occurred during the run to the caller.",
	"Method": "String runMethodAndCollectOutput(Class<?> clazz,String methodname){\r\n    captureOn();\r\n    clazz.getDeclaredMethod(methodname).invoke(null);\r\n    return captureOff();\r\n}"
}, {
	"Path": "com.querydsl.sql.SQLExpressions.listagg",
	"Comment": "listagg orders data within each group specified in the order by clause and then concatenatesthe values of the measure column.",
	"Method": "WithinGroup<Object> listagg(Expression<?> expr,String delimiter){\r\n    return new WithinGroup<Object>(Object.class, SQLOps.LISTAGG, expr, ConstantImpl.create(delimiter));\r\n}"
}, {
	"Path": "com.querydsl.spatial.jts.JTSCurveExpression.length",
	"Comment": "the length of this curve in its associated spatial reference.",
	"Method": "NumberExpression<Double> length(){\r\n    if (length == null) {\r\n        length = Expressions.numberOperation(Double.class, SpatialOps.LENGTH, mixin);\r\n    }\r\n    return length;\r\n}"
}, {
	"Path": "io.rx_cache2.ActionsList.evictLastN",
	"Comment": "evict as much objects as requested by n param starting from the last position.",
	"Method": "ActionsList<T> evictLastN(int n,ActionsList<T> evictLastN,Func1Count func1Count,int n){\r\n    startToEvict = false;\r\n    Func3<T> func3 = new Func3<T>() {\r\n        @Override\r\n        public boolean call(int position, int count, T element) {\r\n            if (!startToEvict)\r\n                startToEvict = count - position == n;\r\n            if (startToEvict) {\r\n                return count - position <= n && func1Count.call(count);\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n    };\r\n    return evictIterable(func3);\r\n}"
}, {
	"Path": "io.rx_cache2.ActionsList.evictLastN",
	"Comment": "evict as much objects as requested by n param starting from the last position.",
	"Method": "ActionsList<T> evictLastN(int n,ActionsList<T> evictLastN,Func1Count func1Count,int n){\r\n    if (!startToEvict)\r\n        startToEvict = count - position == n;\r\n    if (startToEvict) {\r\n        return count - position <= n && func1Count.call(count);\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.springsource.loaded.Utils.getParameterCount",
	"Comment": "return the number of parameters in the descriptor. copes with primitives and arrays and reference types.",
	"Method": "int getParameterCount(String methodDescriptor){\r\n    int pos = 1;\r\n    int count = 0;\r\n    char ch;\r\n    while ((ch = methodDescriptor.charAt(pos)) != ')') {\r\n        if (ch == 'L') {\r\n            pos = methodDescriptor.indexOf(';', pos + 1);\r\n        } else if (ch == '[') {\r\n            while (methodDescriptor.charAt(++pos) == '[') {\r\n            }\r\n            if (methodDescriptor.charAt(pos) == 'L') {\r\n                pos = methodDescriptor.indexOf(';', pos + 1);\r\n            }\r\n        }\r\n        count++;\r\n        pos++;\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "com.querydsl.spatial.SurfaceExpression.centroid",
	"Comment": "the mathematical centroid for this surface as a point. the result is not guaranteed tobe on this surface.",
	"Method": "PointExpression<Point> centroid(){\r\n    if (centroid == null) {\r\n        centroid = GeometryExpressions.pointOperation(SpatialOps.CENTROID, mixin);\r\n    }\r\n    return centroid;\r\n}"
}, {
	"Path": "com.querydsl.sql.AbstractSQLQuery.onException",
	"Comment": "called to make the call back to listeners when an exception happens",
	"Method": "void onException(SQLListenerContextImpl context,Exception e){\r\n    context.setException(e);\r\n    listeners.exception(context);\r\n}"
}, {
	"Path": "org.springsource.loaded.test.CrossLoaderTests.reloadTargetInSuperloaderCallingStaticMethod",
	"Comment": "in a class loaded by the subloader, calling a new static method in a class loaded by the superloader.",
	"Method": "void reloadTargetInSuperloaderCallingStaticMethod(){\r\n    String target = \"superpkg.TargetB\";\r\n    String invoker = \"subpkg.InvokerB\";\r\n    ReloadableType targetR = subLoader.loadAsReloadableType(target);\r\n    ReloadableType invokerR = subLoader.loadAsReloadableType(invoker);\r\n    targetR.loadNewVersion(\"2\", retrieveRename(target, target + \"002\"));\r\n    invokerR.loadNewVersion(\"2\", retrieveRename(invoker, invoker + \"002\", target + \"002:\" + target));\r\n    int targetId = NameRegistry.getIdFor(toSlash(target));\r\n    assertEquals(0, targetId);\r\n    TypeRegistry trtarget = TypeRegistry.getTypeRegistryFor(subLoader.getParent());\r\n    assertEquals(target, trtarget.getReloadableType(targetId).getName());\r\n    assertEquals(target, trtarget.getReloadableType(toSlash(target)).getName());\r\n    int invokerId = NameRegistry.getIdFor(toSlash(invoker));\r\n    TypeRegistry trinvokerR = TypeRegistry.getTypeRegistryFor(subLoader);\r\n    assertEquals(1, invokerId);\r\n    assertEquals(invoker, trinvokerR.getReloadableType(invokerId).getName());\r\n    assertEquals(invoker, trinvokerR.getReloadableType(toSlash(invoker)).getName());\r\n    result = runUnguarded(invokerR.getClazz(), \"run\");\r\n    assertEquals(\"TargetB002.m() running\", result.stdout);\r\n}"
}, {
	"Path": "org.springsource.loaded.test.FieldReloadingTests.intArrayFieldAccessing",
	"Comment": "instead of the generic object one checking fields ok after rewriting",
	"Method": "void intArrayFieldAccessing(){\r\n    TypeRegistry typeRegistry = TypeRegistry.getTypeRegistryFor(binLoader);\r\n    configureForTesting(typeRegistry, \"data.Pear\");\r\n    typeRegistry.addType(\"data.Pear\", loadBytesForClass(\"data.Pear\"));\r\n    byte[] callerbytes = loadBytesForClass(\"data.Banana\");\r\n    byte[] rewrittenBytes = MethodInvokerRewriter.rewrite(typeRegistry, callerbytes);\r\n    Class<?> callerClazz = loadit(\"data.Banana\", rewrittenBytes);\r\n    Object o = callerClazz.newInstance();\r\n    Result result = runOnInstance(callerClazz, o, \"getIntArrayField\");\r\n    System.out.println(result);\r\n    Assert.assertTrue(result.returnValue instanceof int[]);\r\n    Assert.assertEquals(3, ((int[]) result.returnValue)[1]);\r\n    result = runOnInstance(callerClazz, o, \"setIntArrayField\", new Object[] { new int[] { 44, 55, 66 } });\r\n    result = runOnInstance(callerClazz, o, \"getIntArrayField\");\r\n    Assert.assertTrue(result.returnValue instanceof int[]);\r\n    Assert.assertEquals(55, ((int[]) result.returnValue)[1]);\r\n}"
}, {
	"Path": "com.alipay.sofa.rpc.common.struct.ConcurrentHashSet.clear",
	"Comment": "removes all of the elements from this set. the set will be empty afterthis call returns.",
	"Method": "void clear(){\r\n    map.clear();\r\n}"
}, {
	"Path": "org.spockframework.runtime.model.FeatureInfo.hasBytecodeName",
	"Comment": "tells if any of the methods associated with this feature has the specifiedname in bytecode.",
	"Method": "boolean hasBytecodeName(String name){\r\n    if (featureMethod.hasBytecodeName(name))\r\n        return true;\r\n    if (dataProcessorMethod != null && dataProcessorMethod.hasBytecodeName(name))\r\n        return true;\r\n    for (DataProviderInfo provider : dataProviders) if (provider.getDataProviderMethod().hasBytecodeName(name))\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "org.testng.ClassMethodMap.removeAndCheckIfLast",
	"Comment": "remove the method from this map and returns true if it is the last of its class.",
	"Method": "boolean removeAndCheckIfLast(ITestNGMethod m,Object instance){\r\n    Collection<ITestNGMethod> l = classMap.get(instance);\r\n    if (l == null) {\r\n        throw new AssertionError(\"l should not be null\");\r\n    }\r\n    l.remove(m);\r\n    for (ITestNGMethod tm : l) {\r\n        if (tm.getEnabled() && tm.getTestClass().equals(m.getTestClass())) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.klinker.android.twitter.views.swipe_refresh_layout.SwipeProgressBar.setColorScheme",
	"Comment": "set the four colors used in the progress animation. the first color willalso be the color of the bar that grows in response to a user swipegesture.",
	"Method": "void setColorScheme(int color1,int color2,int color3,int color4){\r\n    mColor1 = color1;\r\n    mColor2 = color2;\r\n    mColor3 = color3;\r\n    mColor4 = color4;\r\n}"
}, {
	"Path": "com.querydsl.sql.ColumnMetadata.named",
	"Comment": "creates default column meta data with the given column name, but withoutany type or constraint information. use the fluent builder methods tofurther configure it.",
	"Method": "ColumnMetadata named(String name){\r\n    return new ColumnMetadata(null, name, null, true, UNDEFINED, UNDEFINED);\r\n}"
}, {
	"Path": "com.squareup.tape2.QueueFile.peek",
	"Comment": "reads the eldest element. returns null if the queue is empty.",
	"Method": "byte[] peek(){\r\n    if (closed)\r\n        throw new IllegalStateException(\"closed\");\r\n    if (isEmpty())\r\n        return null;\r\n    int length = first.length;\r\n    byte[] data = new byte[length];\r\n    ringRead(first.position + Element.HEADER_LENGTH, data, 0, length);\r\n    return data;\r\n}"
}, {
	"Path": "org.testcontainers.containers.CassandraContainer.runInitScriptIfRequired",
	"Comment": "load init script content and apply it to the database if initscriptpath is set",
	"Method": "void runInitScriptIfRequired(){\r\n    if (initScriptPath != null) {\r\n        try {\r\n            URL resource = Thread.currentThread().getContextClassLoader().getResource(initScriptPath);\r\n            if (resource == null) {\r\n                logger().warn(\"Could not load classpath init script: {}\", initScriptPath);\r\n                throw new ScriptLoadException(\"Could not load classpath init script: \" + initScriptPath + \". Resource not found.\");\r\n            }\r\n            String cql = IOUtils.toString(resource, StandardCharsets.UTF_8);\r\n            DatabaseDelegate databaseDelegate = getDatabaseDelegate();\r\n            ScriptUtils.executeDatabaseScript(databaseDelegate, initScriptPath, cql);\r\n        } catch (IOException e) {\r\n            logger().warn(\"Could not load classpath init script: {}\", initScriptPath);\r\n            throw new ScriptLoadException(\"Could not load classpath init script: \" + initScriptPath, e);\r\n        } catch (ScriptException e) {\r\n            logger().error(\"Error while executing init script: {}\", initScriptPath, e);\r\n            throw new ScriptUtils.UncategorizedScriptException(\"Error while executing init script: \" + initScriptPath, e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.querydsl.sql.postgresql.AbstractPostgreSQLQuery.noWait",
	"Comment": "with nowait, the statement reports an error, rather than waiting, if a selected row cannotbe locked immediately.",
	"Method": "C noWait(){\r\n    QueryFlag noWaitFlag = configuration.getTemplates().getNoWaitFlag();\r\n    return addFlag(noWaitFlag);\r\n}"
}, {
	"Path": "io.rx_cache2.internal.cache.memory.apache.AbstractMapEntry.setValue",
	"Comment": "sets the value stored in this map.entry.this map.entry is not connected to a map, so only thelocal data is changed.",
	"Method": "V setValue(V value){\r\n    return super.setValue(value);\r\n}"
}, {
	"Path": "com.querydsl.spatial.jts.JTSMultiSurfaceExpression.centroid",
	"Comment": "the mathematical centroid for this multisurface. the result is not guaranteed to be onthis multisurface.",
	"Method": "JTSPointExpression<Point> centroid(){\r\n    if (centroid == null) {\r\n        centroid = JTSGeometryExpressions.pointOperation(SpatialOps.CENTROID, mixin);\r\n    }\r\n    return centroid;\r\n}"
}, {
	"Path": "com.querydsl.spatial.jts.JTSGeometryExpressions.translate",
	"Comment": "translates the geometry to a new location using the numeric parameters as offsets.",
	"Method": "JTSGeometryExpression<T> translate(Expression<T> expr,float deltax,float deltay,JTSGeometryExpression<T> translate,Expression<T> expr,float deltax,float deltay,float deltaz){\r\n    return geometryOperation(expr.getType(), SpatialOps.TRANSLATE2, expr, ConstantImpl.create(deltax), ConstantImpl.create(deltay), ConstantImpl.create(deltaz));\r\n}"
}, {
	"Path": "com.querydsl.spatial.MultiSurfaceExpression.centroid",
	"Comment": "the mathematical centroid for this multisurface. the result is not guaranteed to be onthis multisurface.",
	"Method": "PointExpression<Point> centroid(){\r\n    if (centroid == null) {\r\n        centroid = GeometryExpressions.pointOperation(SpatialOps.CENTROID, mixin);\r\n    }\r\n    return centroid;\r\n}"
}, {
	"Path": "org.springsource.loaded.test.UtilsTests.encoding",
	"Comment": "test the encoding of a number to a string and the subsequent decoding",
	"Method": "void encoding(){\r\n    Random rand = new Random(666);\r\n    for (int r = 0; r < 2000; r++) {\r\n        long l = Math.abs(rand.nextLong());\r\n        String encoded = Utils.encode(l);\r\n        long decoded = Utils.decode(encoded);\r\n        assertEquals(l, decoded);\r\n    }\r\n}"
}, {
	"Path": "com.simplecity.amp_library.utils.menu.MenuUtils.addToQueue",
	"Comment": "adds the passed in songs to the queue, then calls oncomplete with a message to be displayedin a toast.",
	"Method": "void addToQueue(MediaManager mediaManager,List<Song> songs,UnsafeConsumer<String> onComplete,Disposable addToQueue,MediaManager mediaManager,Single<List<Song>> single,UnsafeConsumer<String> onComplete){\r\n    return single.observeOn(AndroidSchedulers.mainThread()).subscribe(songs -> mediaManager.addToQueue(songs, s -> {\r\n        onComplete.accept(s);\r\n        return Unit.INSTANCE;\r\n    }), throwable -> LogUtils.logException(TAG, \"Error adding to queue\", throwable));\r\n}"
}, {
	"Path": "org.unitils.core.dbsupport.H2DbSupport.getTriggerNames",
	"Comment": "retrieves the names of all the triggers in the database schema.",
	"Method": "Set<String> getTriggerNames(){\r\n    return getSQLHandler().getItemsAsStringSet(\"select TRIGGER_NAME from \" + \"INFORMATION_SCHEMA.TRIGGERS where TRIGGER_SCHEMA = '\" + getSchemaName() + \"'\");\r\n}"
}, {
	"Path": "org.spockframework.spring.mock.SpockMockPostprocessor.createMock",
	"Comment": "factory method used by defined beans to actually create the mock.",
	"Method": "Object createMock(MockDefinition mockDefinition,String name){\r\n    return mockDefinition.createMock(name + \" bean\");\r\n}"
}, {
	"Path": "org.testcontainers.containers.wait.Wait.forHttps",
	"Comment": "convenience method to return a waitstrategy for an https endpoint.",
	"Method": "HttpWaitStrategy forHttps(String path){\r\n    return forHttp(path).usingTls();\r\n}"
}, {
	"Path": "com.r0adkll.slidr.util.ViewDragHelper.getMinVelocity",
	"Comment": "return the currently configured minimum velocity. any flings with a magnitude lessthan this value in pixels per second. callback methods accepting a velocity will receivezero as a velocity value if the real detected velocity was below this threshold.",
	"Method": "float getMinVelocity(){\r\n    return mMinVelocity;\r\n}"
}, {
	"Path": "cn.finalteam.rxgalleryfinal.RxGalleryFinal.cropAspectRatioOptions",
	"Comment": "pass an ordered list of desired aspect ratios that should be available for a user.",
	"Method": "RxGalleryFinal cropAspectRatioOptions(int selectedByDefault,AspectRatio aspectRatio){\r\n    configuration.setSelectedByDefault(selectedByDefault);\r\n    configuration.setAspectRatio(aspectRatio);\r\n    return this;\r\n}"
}, {
	"Path": "org.spockframework.compiler.StatementReplacingVisitorSupport.replaceVisitedStatementWith",
	"Comment": "replaces the currently visited statement with the specified statement.",
	"Method": "void replaceVisitedStatementWith(Statement other){\r\n    replacement = other;\r\n}"
}, {
	"Path": "org.spockframework.gentyref.GenericTypeReflector.buildUpperBoundClassAndInterfaces",
	"Comment": "helper method for getupperboundclassandinterfaces, adding the result to the given set.",
	"Method": "void buildUpperBoundClassAndInterfaces(Type type,Set<Class<?>> result){\r\n    if (type instanceof ParameterizedType || type instanceof Class<?>) {\r\n        result.add(erase(type));\r\n        return;\r\n    }\r\n    for (Type superType : getExactDirectSuperTypes(type)) {\r\n        buildUpperBoundClassAndInterfaces(superType, result);\r\n    }\r\n}"
}, {
	"Path": "org.springsource.loaded.ConstantPoolChecker2.main",
	"Comment": "test entry point just goes through all the code in the bin folder",
	"Method": "void main(String[] args){\r\n    File[] fs = new File(\"./bin\").listFiles();\r\n    checkThemAll(fs);\r\n    System.out.println(\"total=\" + total / 1000000d);\r\n}"
}, {
	"Path": "com.nanchen.rxjava2examples.ui.SystemBarTintManager.setStatusBarTintEnabled",
	"Comment": "enable tinting of the system status bar.if the platform is running jelly bean or earlier, or translucent systemui modes have not been enabled in either the theme or via window flags,then this method does nothing.",
	"Method": "void setStatusBarTintEnabled(boolean enabled){\r\n    mStatusBarTintEnabled = enabled;\r\n    if (mStatusBarAvailable) {\r\n        mStatusBarTintView.setVisibility(enabled ? View.VISIBLE : View.GONE);\r\n    }\r\n}"
}, {
	"Path": "org.springsource.loaded.ReloadableType.resetEnumRelatedState",
	"Comment": "when an enum type is reloaded, two caches need to be cleared out from the class object for the enum type.",
	"Method": "void resetEnumRelatedState(){\r\n    if (clazz == null) {\r\n        return;\r\n    }\r\n    try {\r\n        Field f = clazz.getClass().getDeclaredField(\"enumConstants\");\r\n        f.setAccessible(true);\r\n        f.set(clazz, null);\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n    try {\r\n        Field f = clazz.getClass().getDeclaredField(\"enumConstantDirectory\");\r\n        f.setAccessible(true);\r\n        f.set(clazz, null);\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "com.querydsl.sql.SQLExpressions.ntile",
	"Comment": "divides an ordered data set into a number of buckets indicated by expr and assigns theappropriate bucket number to each row",
	"Method": "WindowOver<T> ntile(T num){\r\n    return new WindowOver<T>((Class<T>) num.getClass(), SQLOps.NTILE, ConstantImpl.create(num));\r\n}"
}, {
	"Path": "uk.co.real_logic.sbe.xml.MessageSchema.semanticVersion",
	"Comment": "the semantic version number of the schema. typically use to reference a third party standard such as fix.",
	"Method": "String semanticVersion(){\r\n    return semanticVersion;\r\n}"
}, {
	"Path": "org.springsource.loaded.support.Java8.enhanceInnerClassLambdaMetaFactory",
	"Comment": "the metafactory we are enhancing is responsible for generating the anonymous classes that will call the lambda\tmethods in our type",
	"Method": "byte[] enhanceInnerClassLambdaMetaFactory(byte[] bytes){\r\n    return null;\r\n}"
}, {
	"Path": "org.springsource.loaded.ReloadableType.getSuperRtype",
	"Comment": "return the reloadabletype representing the superclass of this type. if the supertype is not reloadable, this\tmethod will return null. the reloadabletype that is returned may not be within the same type registry, if the\tsupertype was loaded by a different classloader.",
	"Method": "ReloadableType getSuperRtype(){\r\n    if (superRtype != null) {\r\n        return superRtype;\r\n    }\r\n    if (superclazz == null) {\r\n        String name = this.getSlashedSupertypeName();\r\n        if (name == null) {\r\n            return null;\r\n        } else {\r\n            ReloadableType rtype = typeRegistry.getReloadableSuperType(name);\r\n            superRtype = rtype;\r\n            return superRtype;\r\n        }\r\n    } else {\r\n        ClassLoader superClassLoader = superclazz.getClassLoader();\r\n        TypeRegistry superTypeRegistry = TypeRegistry.getTypeRegistryFor(superClassLoader);\r\n        superRtype = superTypeRegistry.getReloadableType(superclazz);\r\n        return superRtype;\r\n    }\r\n}"
}, {
	"Path": "org.springsource.loaded.ri.test.ClassReflectionTests.test_getDeclaredMethodsIdentical2",
	"Comment": "test to see if method objects retrieved by getdeclaredmethod remain identical even after class gets reloaded.",
	"Method": "void test_getDeclaredMethodsIdentical2(){\r\n    reloadType(\"002\");\r\n    Method m1 = (Method) (getDeclaredMethod(\"methodStays\").returnValue);\r\n    Method m2 = (Method) (getDeclaredMethod(\"methodStays\").returnValue);\r\n    Assert.assertEquals(m1, m2);\r\n    m1 = (Method) (getDeclaredMethod(\"lateMethod\").returnValue);\r\n    m2 = (Method) (getDeclaredMethod(\"lateMethod\").returnValue);\r\n    Assert.assertEquals(m1, m2);\r\n}"
}, {
	"Path": "org.springsource.loaded.ri.test.ClassReflectionTests.test_getDeclaredMethodDeletedAndInvoke",
	"Comment": "testing class.getdeclaredmethod and method.invoke\tcan we retrieve and invoke a method that existed before we reloaded the type, and was deleted later.",
	"Method": "void test_getDeclaredMethodDeletedAndInvoke(){\r\n    Result r = getDeclaredMethodAndInvoke(\"methodDeleted\");\r\n    Assert.assertEquals(37, r.returnValue);\r\n    reloadType(\"002\");\r\n    try {\r\n        getDeclaredMethodAndInvoke(\"methodDeleted\");\r\n        fail(\"getting/invoking a deleted method should fail\");\r\n    } catch (ResultException e) {\r\n        assertNoSuchMethodException(TARGET_CLASS_NAME + \".methodDeleted()\", e);\r\n    }\r\n}"
}, {
	"Path": "org.springsource.loaded.test.FieldReloadingTests.switchToFromBoxing",
	"Comment": "switch some fields from their primitive forms to their boxed forms, check data is preserved, then switch them\tback and check data is preserved.",
	"Method": "void switchToFromBoxing(){\r\n    String e = \"fields.E\";\r\n    TypeRegistry tr = getTypeRegistry(e);\r\n    ReloadableType type = tr.addType(e, loadBytesForClass(e));\r\n    Class<?> clazz = type.getClazz();\r\n    Object rInstance = clazz.newInstance();\r\n    assertEquals(100, runOnInstance(clazz, rInstance, \"getInt\").returnValue);\r\n    assertEquals(100, type.getField(rInstance, \"i\", false));\r\n    assertEquals((short) 200, runOnInstance(clazz, rInstance, \"getShort\").returnValue);\r\n    assertEquals((short) 200, type.getField(rInstance, \"s\", false));\r\n    assertEquals(324L, runOnInstance(clazz, rInstance, \"getLong\").returnValue);\r\n    assertEquals(324L, type.getField(rInstance, \"j\", false));\r\n    assertEquals(2.5d, runOnInstance(clazz, rInstance, \"getDouble\").returnValue);\r\n    assertEquals(2.5d, type.getField(rInstance, \"d\", false));\r\n    assertEquals(true, runOnInstance(clazz, rInstance, \"getBoolean\").returnValue);\r\n    assertEquals(true, type.getField(rInstance, \"z\", false));\r\n    assertEquals(32f, runOnInstance(clazz, rInstance, \"getFloat\").returnValue);\r\n    assertEquals(32f, type.getField(rInstance, \"f\", false));\r\n    assertEquals('a', runOnInstance(clazz, rInstance, \"getChar\").returnValue);\r\n    assertEquals('a', type.getField(rInstance, \"c\", false));\r\n    assertEquals((byte) 255, runOnInstance(clazz, rInstance, \"getByte\").returnValue);\r\n    assertEquals((byte) 255, type.getField(rInstance, \"b\", false));\r\n    type.loadNewVersion(\"2\", retrieveRename(e, e + \"2\"));\r\n    assertEquals(100, runOnInstance(clazz, rInstance, \"getInt\").returnValue);\r\n    assertEquals(100, type.getField(rInstance, \"i\", false));\r\n    assertEquals((short) 200, runOnInstance(clazz, rInstance, \"getShort\").returnValue);\r\n    assertEquals((short) 200, type.getField(rInstance, \"s\", false));\r\n    assertEquals(324L, runOnInstance(clazz, rInstance, \"getLong\").returnValue);\r\n    assertEquals(324L, type.getField(rInstance, \"j\", false));\r\n    assertEquals(2.5d, runOnInstance(clazz, rInstance, \"getDouble\").returnValue);\r\n    assertEquals(2.5d, type.getField(rInstance, \"d\", false));\r\n    assertEquals(true, runOnInstance(clazz, rInstance, \"getBoolean\").returnValue);\r\n    assertEquals(true, type.getField(rInstance, \"z\", false));\r\n    assertEquals(32f, runOnInstance(clazz, rInstance, \"getFloat\").returnValue);\r\n    assertEquals(32f, type.getField(rInstance, \"f\", false));\r\n    assertEquals('a', runOnInstance(clazz, rInstance, \"getChar\").returnValue);\r\n    assertEquals('a', type.getField(rInstance, \"c\", false));\r\n    assertEquals((byte) 255, runOnInstance(clazz, rInstance, \"getByte\").returnValue);\r\n    assertEquals((byte) 255, type.getField(rInstance, \"b\", false));\r\n    type.loadNewVersion(\"3\", loadBytesForClass(e));\r\n    assertEquals(100, runOnInstance(clazz, rInstance, \"getInt\").returnValue);\r\n    assertEquals(100, type.getField(rInstance, \"i\", false));\r\n    assertEquals((short) 200, runOnInstance(clazz, rInstance, \"getShort\").returnValue);\r\n    assertEquals((short) 200, type.getField(rInstance, \"s\", false));\r\n    assertEquals(324L, runOnInstance(clazz, rInstance, \"getLong\").returnValue);\r\n    assertEquals(324L, type.getField(rInstance, \"j\", false));\r\n    assertEquals(2.5d, runOnInstance(clazz, rInstance, \"getDouble\").returnValue);\r\n    assertEquals(2.5d, type.getField(rInstance, \"d\", false));\r\n    assertEquals(true, runOnInstance(clazz, rInstance, \"getBoolean\").returnValue);\r\n    assertEquals(true, type.getField(rInstance, \"z\", false));\r\n    assertEquals(32f, runOnInstance(clazz, rInstance, \"getFloat\").returnValue);\r\n    assertEquals(32f, type.getField(rInstance, \"f\", false));\r\n    assertEquals('a', runOnInstance(clazz, rInstance, \"getChar\").returnValue);\r\n    assertEquals('a', type.getField(rInstance, \"c\", false));\r\n    assertEquals((byte) 255, runOnInstance(clazz, rInstance, \"getByte\").returnValue);\r\n    assertEquals((byte) 255, type.getField(rInstance, \"b\", false));\r\n}"
}, {
	"Path": "org.springsource.loaded.test.FieldReloadingTests.changingFieldFromNonstaticToStaticWithSubtypes",
	"Comment": "an instance field is accessed from a subtype, then the supertype is reloaded where the field has been made\tstatic. should be an error when the subtype attempts to access it again.",
	"Method": "void changingFieldFromNonstaticToStaticWithSubtypes(){\r\n    String y = \"fields.Ya\";\r\n    String z = \"fields.Za\";\r\n    TypeRegistry tr = getTypeRegistry(y + \",\" + z);\r\n    ReloadableType rtype = tr.addType(y, loadBytesForClass(y));\r\n    ReloadableType ztype = tr.addType(z, loadBytesForClass(z));\r\n    Class<?> clazz = ztype.getClazz();\r\n    Object instance = clazz.newInstance();\r\n    assertEquals(5, runOnInstance(clazz, instance, \"getJ\").returnValue);\r\n    runOnInstance(clazz, instance, \"setJ\", 4);\r\n    assertEquals(4, runOnInstance(clazz, instance, \"getJ\").returnValue);\r\n    rtype.loadNewVersion(\"2\", retrieveRename(y, y + \"002\"));\r\n    try {\r\n        runOnInstance(clazz, instance, \"setJ\", 4);\r\n        fail(\"should not have worked, field has changed from non-static to static\");\r\n    } catch (ResultException re) {\r\n        assertTrue(re.getCause() instanceof InvocationTargetException);\r\n        assertTrue(re.getCause().getCause() instanceof IncompatibleClassChangeError);\r\n        assertEquals(\"Expected non-static field fields.Za.j\", re.getCause().getCause().getMessage());\r\n    }\r\n    try {\r\n        runOnInstance(clazz, instance, \"getJ\");\r\n        fail(\"should not have worked, field has changed from non-static to static\");\r\n    } catch (ResultException re) {\r\n        assertTrue(re.getCause() instanceof InvocationTargetException);\r\n        assertTrue(re.getCause().getCause() instanceof IncompatibleClassChangeError);\r\n        assertEquals(\"Expected non-static field fields.Za.j\", re.getCause().getCause().getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.springsource.loaded.ReloadableType.changed",
	"Comment": "check if the specified method is different to the original form from the type as loaded.",
	"Method": "int changed(int methodId){\r\n    if (liveVersion == null) {\r\n        return 0;\r\n    } else {\r\n        int retval = 0;\r\n        if (liveVersion != null) {\r\n            if (GlobalConfiguration.logging && log.isLoggable(Level.FINER)) {\r\n                log.info(\"MethodId=\" + methodId + \" method=\" + typedescriptor.getMethod(methodId));\r\n            }\r\n            boolean b = liveVersion.incrementalTypeDescriptor.hasBeenDeleted(methodId);\r\n            if (b) {\r\n                retval = 2;\r\n            } else {\r\n                retval = liveVersion.incrementalTypeDescriptor.mustUseExecutorForThisMethod(methodId) ? 1 : 0;\r\n            }\r\n        }\r\n        return retval;\r\n    }\r\n}"
}, {
	"Path": "org.springsource.loaded.test.MethodInvokerRewriterTests.privateMethodCallsAndInvokeSpecial",
	"Comment": "rewriting invokespecial when used for private method access.",
	"Method": "void privateMethodCallsAndInvokeSpecial(){\r\n    registry = getTypeRegistry(\"invokespecial..*\");\r\n    ReloadableType t = loadType(registry, \"invokespecial.ContainsPrivateCalls\");\r\n    Class<?> clazz = t.getClazz();\r\n    Object o = clazz.newInstance();\r\n    Method m = clazz.getDeclaredMethod(\"callMyPrivates\");\r\n    assertEquals(\"12123abctruez\", m.invoke(o));\r\n    reload(t, \"001\");\r\n    assertEquals(\"12123abctruez\", m.invoke(o));\r\n}"
}, {
	"Path": "com.klinker.android.twitter.activities.scheduled_tweets.NewScheduledTweet.doneClick",
	"Comment": "including the alarm manager and writing the files to the database to save them",
	"Method": "boolean doneClick(){\r\n    if (!mEditText.getText().toString().equals(\"\") && timeDone) {\r\n        ScheduledTweet tweet = new ScheduledTweet(getApplicationContext(), context, mEditText.getText().toString(), setDate.getTime(), settings.currentAccount);\r\n        tweet.createScheduledTweet();\r\n        finish();\r\n    } else {\r\n        Context context = getApplicationContext();\r\n        CharSequence text = getString(R.string.complete_form);\r\n        int duration = Toast.LENGTH_SHORT;\r\n        Toast toast = Toast.makeText(context, text, duration);\r\n        toast.show();\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.testcontainers.containers.GenericContainer.start",
	"Comment": "starts the container using docker, pulling an image if necessary.",
	"Method": "void start(){\r\n    if (containerId != null) {\r\n        return;\r\n    }\r\n    doStart();\r\n}"
}, {
	"Path": "uk.co.real_logic.sbe.xml.CompositeType.getType",
	"Comment": "return the encodeddatatype within this composite with the given name",
	"Method": "Type getType(String name){\r\n    return containedTypeByNameMap.get(name);\r\n}"
}, {
	"Path": "android.support.design.widget.CustomCollapsingToolbarLayout.setContentScrimResource",
	"Comment": "set the drawable to use for the content scrim from resources.",
	"Method": "void setContentScrimResource(int resId){\r\n    setContentScrim(ContextCompat.getDrawable(getContext(), resId));\r\n}"
}, {
	"Path": "com.squareup.tape2.ObjectQueue.clear",
	"Comment": "clears this queue. also truncates the file to the initial size.",
	"Method": "void clear(){\r\n    remove(size());\r\n}"
}, {
	"Path": "org.testcontainers.utility.ResourceReaper.registerContainerForCleanup",
	"Comment": "register a container to be cleaned up, either on explicit call to stopandremovecontainer, or at jvm shutdown.",
	"Method": "void registerContainerForCleanup(String containerId,String imageName){\r\n    setHook();\r\n    registeredContainers.put(containerId, imageName);\r\n}"
}, {
	"Path": "com.querydsl.sql.SQLExpressions.selectZero",
	"Comment": "create a new detached sqlquery instance with zero as the projection",
	"Method": "SQLQuery<Integer> selectZero(){\r\n    return select(Expressions.ZERO);\r\n}"
}, {
	"Path": "com.querydsl.spatial.jts.JTSGeometryExpression.geometryType",
	"Comment": "returns the name of the instantiable subtype of geometry of which thisgeometric object is an instantiable member. the name of the subtype of geometry is returned as a string.",
	"Method": "StringExpression geometryType(){\r\n    if (geometryType == null) {\r\n        geometryType = Expressions.stringOperation(SpatialOps.GEOMETRY_TYPE, mixin);\r\n    }\r\n    return geometryType;\r\n}"
}, {
	"Path": "com.r0adkll.slidr.model.SlidrConfig.getListener",
	"Comment": "get the slidr listener set by the user to respond to certain events in the slidingmechanism.",
	"Method": "SlidrListener getListener(){\r\n    return listener;\r\n}"
}, {
	"Path": "android.support.design.widget.CustomCollapsingToolbarLayout.findDirectChild",
	"Comment": "returns the direct child of this layout, which itself is the ancestor of thegiven view.",
	"Method": "View findDirectChild(View descendant){\r\n    View directChild = descendant;\r\n    for (ViewParent p = descendant.getParent(); p != this && p != null; p = p.getParent()) {\r\n        if (p instanceof View) {\r\n            directChild = (View) p;\r\n        }\r\n    }\r\n    return directChild;\r\n}"
}, {
	"Path": "org.springsource.loaded.TypeDescriptor.getDottedName",
	"Comment": "could be worth caching if used for more than error messages...",
	"Method": "String getDottedName(){\r\n    return getName().replace('/', '.');\r\n}"
}, {
	"Path": "org.springsource.loaded.test.CodeGenerationTests.testInterfaceWriting",
	"Comment": "testing that when we load a rewritable interface and its implementation, the dynamic dispatch method is created.",
	"Method": "void testInterfaceWriting(){\r\n    TypeRegistry typeRegistry = TypeRegistry.getTypeRegistryFor(binLoader);\r\n    String theInterface = \"interfacerewriting.TheInterface\";\r\n    String theImpl = \"interfacerewriting.TheImpl\";\r\n    configureForTesting(typeRegistry, theInterface + \",\" + theImpl);\r\n    typeRegistry.addType(theInterface, loadBytesForClass(theInterface));\r\n    typeRegistry.addType(theImpl, loadBytesForClass(theImpl));\r\n}"
}, {
	"Path": "spock.util.concurrent.PollingConditions.eventually",
	"Comment": "repeatedly evaluates the specified conditions until they are satisfied or the timeout has elapsed.",
	"Method": "void eventually(Closure<?> conditions){\r\n    within(timeout, conditions);\r\n}"
}, {
	"Path": "com.klinker.android.twitter.views.swipe_refresh_layout.SwipeProgressBar.setTriggerPercentage",
	"Comment": "update the progress the user has made toward triggering the swipegesture. and use this value to update the percentage of the trigger thatis shown.",
	"Method": "void setTriggerPercentage(float triggerPercentage){\r\n    mTriggerPercentage = triggerPercentage;\r\n    mStartTime = 0;\r\n    ViewCompat.postInvalidateOnAnimation(mParent);\r\n}"
}, {
	"Path": "com.querydsl.spatial.jts.JTSGeometryExpression.distance",
	"Comment": "returns the shortest distance between any two points in the two geometric objects ascalculated in the spatial reference system of this geometric object. because the geometriesare closed, it is possible to find a point on each geometric object involved, such that thedistance between these 2 points is the returned distance between their geometric objects.",
	"Method": "NumberExpression<Double> distance(Geometry geometry,NumberExpression<Double> distance,Expression<? extends Geometry> geometry){\r\n    return Expressions.numberOperation(Double.class, SpatialOps.DISTANCE, mixin, geometry);\r\n}"
}, {
	"Path": "android.support.design.widget.CustomCollapsingToolbarLayout.getExpandedTitleGravity",
	"Comment": "returns the horizontal and vertical alignment for title when expanded.",
	"Method": "int getExpandedTitleGravity(){\r\n    return mCollapsingTextHelper.getExpandedTextGravity();\r\n}"
}, {
	"Path": "com.querydsl.sql.dml.SQLMergeClause.executeWithKey",
	"Comment": "execute the clause and return the generated key cast to the given type.if no rows were created, null is returned, otherwise the key of the first row is returned.",
	"Method": "T executeWithKey(Path<T> path,T executeWithKey,Class<T> type,T executeWithKey,Class<T> type,Path<T> path){\r\n    ResultSet rs = executeWithKeys();\r\n    try {\r\n        if (rs.next()) {\r\n            return configuration.get(rs, path, 1, type);\r\n        } else {\r\n            return null;\r\n        }\r\n    } catch (SQLException e) {\r\n        throw configuration.translate(e);\r\n    } finally {\r\n        close(rs);\r\n    }\r\n}"
}, {
	"Path": "org.unitils.core.dbsupport.H2DbSupport.incrementIdentityColumnToValue",
	"Comment": "increments the identity value for the specified identity column on thespecified table to the given value.",
	"Method": "void incrementIdentityColumnToValue(String tableName,String identityColumnName,long identityValue){\r\n    getSQLHandler().executeUpdate(\"alter table \" + qualified(tableName) + \" alter column \" + quoted(identityColumnName) + \" RESTART WITH \" + identityValue);\r\n}"
}, {
	"Path": "org.testng.internal.annotations.AnnotationHelper.findMethodsWithAnnotation",
	"Comment": "delegation method for creating the list of itestmethods to be analysed.",
	"Method": "ITestNGMethod[] findMethodsWithAnnotation(Class<?> rootClass,Class<? extends IAnnotation> annotationClass,IAnnotationFinder annotationFinder,XmlTest xmlTest){\r\n    Map<String, ITestNGMethod> vResult = Maps.newHashMap();\r\n    try {\r\n        vResult = Maps.newHashMap();\r\n        Class<?> cls = rootClass;\r\n        while (null != cls) {\r\n            boolean hasClassAnnotation = isAnnotationPresent(annotationFinder, cls, annotationClass);\r\n            Method[] methods = ReflectionHelper.getLocalMethods(cls);\r\n            for (Method m : methods) {\r\n                boolean hasMethodAnnotation = isAnnotationPresent(annotationFinder, m, annotationClass);\r\n                boolean hasTestNGAnnotation = isAnnotationPresent(annotationFinder, m, IFactoryAnnotation.class) || isAnnotationPresent(annotationFinder, m, ITestAnnotation.class) || isAnnotationPresent(annotationFinder, m);\r\n                boolean isPublic = Modifier.isPublic(m.getModifiers());\r\n                boolean isSynthetic = m.isSynthetic();\r\n                if ((isPublic && hasClassAnnotation && !isSynthetic && (!hasTestNGAnnotation)) || hasMethodAnnotation) {\r\n                    if (isAnnotationPresent(annotationFinder, m, IConfigurationAnnotation.class) && isAnnotationPresent(annotationFinder, cls, ITestAnnotation.class)) {\r\n                        Utils.log(\"\", 3, \"Method \" + m + \" has a configuration annotation\" + \" and a class-level @Test. This method will only be kept as a\" + \" configuration method.\");\r\n                        continue;\r\n                    }\r\n                    if (m.getReturnType() != void.class && !xmlTest.getAllowReturnValues()) {\r\n                        Utils.log(\"\", 2, \"Method \" + m + \" has a @Test annotation\" + \" but also a return value:\" + \" ignoring it. Use <suite allow-return-values=\\\"true\\\"> to fix this\");\r\n                        continue;\r\n                    }\r\n                    String key = createMethodKey(m);\r\n                    if (null == vResult.get(key)) {\r\n                        ITestNGMethod tm = new TestNGMethod(m, annotationFinder, xmlTest, null);\r\n                        vResult.put(key, tm);\r\n                    }\r\n                }\r\n            }\r\n            cls = cls.getSuperclass();\r\n        }\r\n    } catch (SecurityException e) {\r\n        LOGGER.error(e.getMessage(), e);\r\n    }\r\n    return vResult.values().toArray(new ITestNGMethod[0]);\r\n}"
}, {
	"Path": "org.testng.asserts.Assertion.executeAssert",
	"Comment": "run the assert command in parameter. meant to be overridden by subclasses.",
	"Method": "void executeAssert(IAssert<?> assertCommand){\r\n    assertCommand.doAssert();\r\n}"
}, {
	"Path": "io.rx_cache2.internal.cache.memory.apache.AbstractHashedMap.createKeySetIterator",
	"Comment": "creates a key set iterator.subclasses can override this to return iterators with different properties.",
	"Method": "Iterator<K> createKeySetIterator(){\r\n    if (size() == 0) {\r\n        return io.rx_cache2.internal.cache.memory.apache.EmptyIterator.<K>emptyIterator();\r\n    }\r\n    return new KeySetIterator<K>(this);\r\n}"
}, {
	"Path": "org.testcontainers.containers.localstack.LocalStackContainer.withServices",
	"Comment": "declare a set of simulated aws services that should be launched by this container.",
	"Method": "LocalStackContainer withServices(Service services){\r\n    this.services.addAll(Arrays.asList(services));\r\n    return self();\r\n}"
}, {
	"Path": "com.alipay.sofa.rpc.registry.utils.RegistryUtils.processWarmUpWeight",
	"Comment": "read the warmup weight parameter,decide whether to switch the state to the preheating period,and set the corresponding parameters during the preheating period.",
	"Method": "void processWarmUpWeight(ProviderInfo providerInfo){\r\n    String warmupTimeStr = providerInfo.getStaticAttr(ProviderInfoAttrs.ATTR_WARMUP_TIME);\r\n    String warmupWeightStr = providerInfo.getStaticAttr(ProviderInfoAttrs.ATTR_WARMUP_WEIGHT);\r\n    String startTimeStr = providerInfo.getStaticAttr(ProviderInfoAttrs.ATTR_START_TIME);\r\n    if (StringUtils.isNotBlank(warmupTimeStr) && StringUtils.isNotBlank(warmupWeightStr) && StringUtils.isNotBlank(startTimeStr)) {\r\n        long warmupTime = CommonUtils.parseLong(warmupTimeStr, 0);\r\n        int warmupWeight = CommonUtils.parseInt(warmupWeightStr, Integer.parseInt(providerInfo.getStaticAttr(ProviderInfoAttrs.ATTR_WEIGHT)));\r\n        long startTime = CommonUtils.parseLong(startTimeStr, 0);\r\n        long warmupEndTime = startTime + warmupTime;\r\n        providerInfo.setDynamicAttr(ProviderInfoAttrs.ATTR_WARMUP_WEIGHT, warmupWeight);\r\n        providerInfo.setDynamicAttr(ProviderInfoAttrs.ATTR_WARM_UP_END_TIME, warmupEndTime);\r\n        providerInfo.setStatus(ProviderStatus.WARMING_UP);\r\n    }\r\n    providerInfo.getStaticAttrs().remove(ProviderInfoAttrs.ATTR_WARMUP_TIME);\r\n    providerInfo.getStaticAttrs().remove(ProviderInfoAttrs.ATTR_WARMUP_WEIGHT);\r\n}"
}, {
	"Path": "com.querydsl.sql.dml.AbstractSQLInsertClause.addFlag",
	"Comment": "add the given expression at the given position as a query flag",
	"Method": "C addFlag(Position position,String flag,C addFlag,Position position,Expression<?> flag){\r\n    metadata.addFlag(new QueryFlag(position, flag));\r\n    return (C) this;\r\n}"
}, {
	"Path": "org.testcontainers.jdbc.ConnectionUrl.parseContainerParameters",
	"Comment": "get the testcontainers parameters such as init function, init script path etc.",
	"Method": "Map<String, String> parseContainerParameters(){\r\n    Map<String, String> results = new HashMap();\r\n    Matcher matcher = Patterns.TC_PARAM_MATCHING_PATTERN.matcher(this.getUrl());\r\n    while (matcher.find()) {\r\n        String key = matcher.group(1);\r\n        String value = matcher.group(2);\r\n        results.put(key, value);\r\n    }\r\n    return results;\r\n}"
}, {
	"Path": "com.simplecity.amp_library.playback.MusicService.startForegroundImpl",
	"Comment": "starts the foreground notification, and cancels any stop messages",
	"Method": "void startForegroundImpl(){\r\n    try {\r\n        notificationStateHandler.sendEmptyMessage(NotificationStateHandler.START_FOREGROUND);\r\n        Song song = queueManager.getCurrentSong();\r\n        if (song != null) {\r\n            Log.i(TAG, \"startForeground called\");\r\n            notificationHelper.startForeground(this, queueManager.getCurrentSong(), isPlaying(), playbackManager.getMediaSessionToken());\r\n        } else {\r\n            Log.e(TAG, \"startForeground should have been called, but song is null\");\r\n        }\r\n    } catch (NullPointerException | ConcurrentModificationException e) {\r\n        Crashlytics.log(\"startForegroundImpl error: \" + e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "com.querydsl.sql.Configuration.getJavaType",
	"Comment": "get the java type for the given jdbc type, table name and column name",
	"Method": "Class<?> getJavaType(int sqlType,String typeName,int size,int digits,String tableName,String columnName){\r\n    Type<?> type = javaTypeMapping.getType(tableName, columnName);\r\n    if (type != null) {\r\n        return type.getReturnedClass();\r\n    } else if (typeName != null && !typeName.isEmpty()) {\r\n        typeName = typeName.toLowerCase();\r\n        Class<?> clazz = typeToName.get(typeName);\r\n        if (clazz != null) {\r\n            return clazz;\r\n        }\r\n        if (sqlType == Types.ARRAY) {\r\n            if (typeName.startsWith(\"_\")) {\r\n                typeName = typeName.substring(1);\r\n            } else if (typeName.endsWith(\" array\")) {\r\n                typeName = typeName.substring(0, typeName.length() - 6);\r\n            }\r\n            if (typeName.contains(\"[\")) {\r\n                typeName = typeName.substring(0, typeName.indexOf(\"[\"));\r\n            }\r\n            if (typeName.contains(\"(\")) {\r\n                typeName = typeName.substring(0, typeName.indexOf(\"(\"));\r\n            }\r\n            Integer sqlComponentType = templates.getCodeForTypeName(typeName);\r\n            if (sqlComponentType == null) {\r\n                logger.warn(\"Found no JDBC type for \" + typeName + \" using OTHER instead\");\r\n                sqlComponentType = Types.OTHER;\r\n            }\r\n            Class<?> componentType = jdbcTypeMapping.get(sqlComponentType, size, digits);\r\n            return Array.newInstance(componentType, 0).getClass();\r\n        }\r\n    }\r\n    return jdbcTypeMapping.get(sqlType, size, digits);\r\n}"
}, {
	"Path": "org.springsource.loaded.TypeDiffComputer.computeAnyMethodDifferences",
	"Comment": "determine if there any differences between the methods supplied. a methoddelta object is built to record any\tdifferences and stored against the type delta.",
	"Method": "void computeAnyMethodDifferences(MethodNode oMethod,MethodNode nMethod,TypeDelta td){\r\n    MethodDelta md = new MethodDelta(oMethod.name, oMethod.desc);\r\n    if (oMethod.access != nMethod.access) {\r\n        md.setAccessChanged(oMethod.access, nMethod.access);\r\n    }\r\n    InsnList oInstructions = oMethod.instructions;\r\n    InsnList nInstructions = nMethod.instructions;\r\n    if (oInstructions.size() != nInstructions.size()) {\r\n        md.setInstructionsChanged(oInstructions.toArray(), nInstructions.toArray());\r\n    } else {\r\n        if (oMethod.name.charAt(0) == '<') {\r\n            String oInvokeSpecialDescriptor = null;\r\n            String nInvokeSpecialDescriptor = null;\r\n            int oUninitCount = 0;\r\n            int nUninitCount = 0;\r\n            boolean codeChange = false;\r\n            for (int i = 0, max = oInstructions.size(); i < max; i++) {\r\n                AbstractInsnNode oInstruction = oInstructions.get(i);\r\n                AbstractInsnNode nInstruction = nInstructions.get(i);\r\n                if (!codeChange) {\r\n                    if (!sameInstruction(oInstruction, nInstruction)) {\r\n                        codeChange = true;\r\n                    }\r\n                }\r\n                if (oInstruction.getType() == AbstractInsnNode.TYPE_INSN) {\r\n                    if (oInstruction.getOpcode() == Opcodes.NEW) {\r\n                        oUninitCount++;\r\n                    }\r\n                }\r\n                if (nInstruction.getType() == AbstractInsnNode.TYPE_INSN) {\r\n                    if (nInstruction.getOpcode() == Opcodes.NEW) {\r\n                        nUninitCount++;\r\n                    }\r\n                }\r\n                if (oInstruction.getType() == AbstractInsnNode.METHOD_INSN) {\r\n                    MethodInsnNode mi = (MethodInsnNode) oInstruction;\r\n                    if (mi.getOpcode() == INVOKESPECIAL && mi.name.equals(\"<init>\")) {\r\n                        if (oUninitCount == 0) {\r\n                            oInvokeSpecialDescriptor = mi.desc;\r\n                        } else {\r\n                            oUninitCount--;\r\n                        }\r\n                    }\r\n                }\r\n                if (nInstruction.getType() == AbstractInsnNode.METHOD_INSN) {\r\n                    MethodInsnNode mi = (MethodInsnNode) nInstruction;\r\n                    if (mi.getOpcode() == INVOKESPECIAL && mi.name.equals(\"<init>\")) {\r\n                        if (nUninitCount == 0) {\r\n                            nInvokeSpecialDescriptor = mi.desc;\r\n                        } else {\r\n                            nUninitCount--;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (oInvokeSpecialDescriptor == null) {\r\n                if (nInvokeSpecialDescriptor != null) {\r\n                    md.setInvokespecialChanged(oInvokeSpecialDescriptor, nInvokeSpecialDescriptor);\r\n                }\r\n            } else {\r\n                if (!oInvokeSpecialDescriptor.equals(nInvokeSpecialDescriptor)) {\r\n                    md.setInvokespecialChanged(oInvokeSpecialDescriptor, nInvokeSpecialDescriptor);\r\n                }\r\n            }\r\n            if (codeChange) {\r\n                md.setCodeChanged(oInstructions.toArray(), nInstructions.toArray());\r\n            }\r\n        }\r\n    }\r\n    if (md.hasAnyChanges()) {\r\n        td.addChangedMethod(md);\r\n    }\r\n}"
}, {
	"Path": "com.querydsl.sql.SQLExpressions.varSamp",
	"Comment": "returns the sample variance of a set of numbers after discarding the nulls in this set.",
	"Method": "WindowOver<T> varSamp(Expression<T> expr){\r\n    return new WindowOver<T>(expr.getType(), SQLOps.VARSAMP, expr);\r\n}"
}, {
	"Path": "android.support.design.widget.CustomCollapsingToolbarLayout.setStatusBarScrimResource",
	"Comment": "set the drawable to use for the content scrim from resources.",
	"Method": "void setStatusBarScrimResource(int resId){\r\n    setStatusBarScrim(ContextCompat.getDrawable(getContext(), resId));\r\n}"
}, {
	"Path": "io.rx_cache2.internal.cache.memory.apache.AbstractHashedMap.entryHashCode",
	"Comment": "gets the hashcode field from a hashentry.used in subclasses that have no visibility of the field.",
	"Method": "int entryHashCode(HashEntry<K, V> entry){\r\n    return entry.hashCode;\r\n}"
}, {
	"Path": "com.querydsl.spatial.jts.JTSGeometryExpression.convexHull",
	"Comment": "returns a geometric object that represents the convex hull of this geometric object.convex hulls, being dependent on straight lines, can be accurately represented in linearinterpolations for any geometry restricted to linear interpolations.",
	"Method": "JTSGeometryExpression<Geometry> convexHull(){\r\n    if (convexHull == null) {\r\n        convexHull = JTSGeometryExpressions.geometryOperation(SpatialOps.CONVEXHULL, mixin);\r\n    }\r\n    return convexHull;\r\n}"
}, {
	"Path": "com.r0adkll.slidr.util.ViewDragHelper.canScroll",
	"Comment": "tests scrollability within child views of v given a delta of dx.",
	"Method": "boolean canScroll(View v,boolean checkV,int dx,int dy,int x,int y){\r\n    if (v instanceof ViewGroup) {\r\n        final ViewGroup group = (ViewGroup) v;\r\n        final int scrollX = v.getScrollX();\r\n        final int scrollY = v.getScrollY();\r\n        final int count = group.getChildCount();\r\n        for (int i = count - 1; i >= 0; i--) {\r\n            final View child = group.getChildAt(i);\r\n            if (x + scrollX >= child.getLeft() && x + scrollX < child.getRight() && y + scrollY >= child.getTop() && y + scrollY < child.getBottom() && canScroll(child, true, dx, dy, x + scrollX - child.getLeft(), y + scrollY - child.getTop())) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return checkV && (ViewCompat.canScrollHorizontally(v, -dx) || ViewCompat.canScrollVertically(v, -dy));\r\n}"
}, {
	"Path": "com.querydsl.sql.dml.SQLMergeClause.executeWithKeys",
	"Comment": "execute the clause and return the generated keys as a resultset",
	"Method": "List<T> executeWithKeys(Path<T> path,List<T> executeWithKeys,Class<T> type,List<T> executeWithKeys,Class<T> type,Path<T> path,ResultSet executeWithKeys){\r\n    context = startContext(connection(), metadata, entity);\r\n    try {\r\n        if (configuration.getTemplates().isNativeMerge()) {\r\n            PreparedStatement stmt = null;\r\n            if (batches.isEmpty()) {\r\n                stmt = createStatement(true);\r\n                listeners.notifyMerge(entity, metadata, keys, columns, values, subQuery);\r\n                listeners.preExecute(context);\r\n                stmt.executeUpdate();\r\n                listeners.executed(context);\r\n            } else {\r\n                Collection<PreparedStatement> stmts = createStatements(true);\r\n                if (stmts != null && stmts.size() > 1) {\r\n                    throw new IllegalStateException(\"executeWithKeys called with batch statement and multiple SQL strings\");\r\n                }\r\n                stmt = stmts.iterator().next();\r\n                listeners.notifyMerges(entity, metadata, batches);\r\n                listeners.preExecute(context);\r\n                stmt.executeBatch();\r\n                listeners.executed(context);\r\n            }\r\n            final Statement stmt2 = stmt;\r\n            ResultSet rs = stmt.getGeneratedKeys();\r\n            return new ResultSetAdapter(rs) {\r\n                @Override\r\n                public void close() throws SQLException {\r\n                    try {\r\n                        super.close();\r\n                    } finally {\r\n                        stmt2.close();\r\n                        reset();\r\n                        endContext(context);\r\n                    }\r\n                }\r\n            };\r\n        } else {\r\n            if (hasRow()) {\r\n                SQLUpdateClause update = new SQLUpdateClause(connection(), configuration, entity);\r\n                update.addListener(listeners);\r\n                populate(update);\r\n                addKeyConditions(update);\r\n                reset();\r\n                endContext(context);\r\n                return EmptyResultSet.DEFAULT;\r\n            } else {\r\n                SQLInsertClause insert = new SQLInsertClause(connection(), configuration, entity);\r\n                insert.addListener(listeners);\r\n                populate(insert);\r\n                return insert.executeWithKeys();\r\n            }\r\n        }\r\n    } catch (SQLException e) {\r\n        onException(context, e);\r\n        reset();\r\n        endContext(context);\r\n        throw configuration.translate(queryString, constants, e);\r\n    }\r\n}"
}, {
	"Path": "com.querydsl.sql.dml.SQLMergeClause.executeWithKeys",
	"Comment": "execute the clause and return the generated keys as a resultset",
	"Method": "List<T> executeWithKeys(Path<T> path,List<T> executeWithKeys,Class<T> type,List<T> executeWithKeys,Class<T> type,Path<T> path,ResultSet executeWithKeys){\r\n    try {\r\n        super.close();\r\n    } finally {\r\n        stmt2.close();\r\n        reset();\r\n        endContext(context);\r\n    }\r\n}"
}, {
	"Path": "org.spockframework.util.ExceptionUtil.sneakyThrow",
	"Comment": "allows to throw an unchecked exception without declaring it in a throws clause.",
	"Method": "void sneakyThrow(Throwable t){\r\n    ExceptionUtil.<RuntimeException>doSneakyThrow(t);\r\n}"
}, {
	"Path": "org.spockframework.compiler.AstUtil.hasPlausibleSourcePosition",
	"Comment": "tells if the source position for the given ast node is plausible.does not imply that the source position is correct.",
	"Method": "boolean hasPlausibleSourcePosition(ASTNode node){\r\n    return node.getLineNumber() > 0 && node.getLastLineNumber() >= node.getLineNumber() && node.getColumnNumber() > 0 && node.getLastColumnNumber() > node.getColumnNumber();\r\n}"
}, {
	"Path": "com.simplecity.amp_library.glide.utils.CustomAppWidgetTarget.update",
	"Comment": "updates the appwidget after the imageview has loaded the bitmap.",
	"Method": "void update(){\r\n    try {\r\n        AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(this.context);\r\n        if (this.componentName != null) {\r\n            appWidgetManager.updateAppWidget(this.componentName, this.remoteViews);\r\n        } else {\r\n            appWidgetManager.updateAppWidget(this.widgetIds, this.remoteViews);\r\n        }\r\n    } catch (IllegalArgumentException e) {\r\n        if (customErrorListener != null) {\r\n            customErrorListener.onRemoteViewMemoryException(e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springsource.loaded.test.MethodInvokerRewriterTests.privateMethodCallsAndInvokeSpecial3",
	"Comment": "rewriting invokespecial when used for private method access. similar to the previous test but now changing the\tvisibility of the private method.",
	"Method": "void privateMethodCallsAndInvokeSpecial3(){\r\n    registry = getTypeRegistry(\"invokespecial..*\");\r\n    ReloadableType t = loadType(registry, \"invokespecial.ContainsPrivateCalls\");\r\n    Class<?> clazz = t.getClazz();\r\n    Object o = clazz.newInstance();\r\n    Method m = clazz.getDeclaredMethod(\"callMyPrivates\");\r\n    assertEquals(\"12123abctruez\", m.invoke(o));\r\n    t.loadNewVersion(\"002\", retrieveRename(\"invokespecial.ContainsPrivateCalls\", \"invokespecial.ContainsPrivateCalls003\"));\r\n    assertEquals(\"12123abctruez\", m.invoke(o));\r\n}"
}, {
	"Path": "com.github.florent37.glidepalette.BitmapPalette.apply",
	"Comment": "apply the palette profile & swatch to our current targetspalettethe palette to applycachehit true if the palette was retrieved from the cache, else false",
	"Method": "void apply(Palette palette,boolean cacheHit){\r\n    for (CallBack c : callbacks) {\r\n        c.onPaletteLoaded(palette);\r\n    }\r\n    if (palette == null)\r\n        return;\r\n    for (PaletteTarget target : targets) {\r\n        Palette.Swatch swatch = null;\r\n        switch(target.paletteProfile) {\r\n            case Profile.VIBRANT:\r\n                swatch = palette.getVibrantSwatch();\r\n                break;\r\n            case Profile.VIBRANT_DARK:\r\n                swatch = palette.getDarkVibrantSwatch();\r\n                break;\r\n            case Profile.VIBRANT_LIGHT:\r\n                swatch = palette.getLightVibrantSwatch();\r\n                break;\r\n            case Profile.MUTED:\r\n                swatch = palette.getMutedSwatch();\r\n                break;\r\n            case Profile.MUTED_DARK:\r\n                swatch = palette.getDarkMutedSwatch();\r\n                break;\r\n            case Profile.MUTED_LIGHT:\r\n                swatch = palette.getLightMutedSwatch();\r\n                break;\r\n        }\r\n        if (swatch == null) {\r\n            swatch = new Palette.Swatch(Color.BLACK, 1);\r\n        }\r\n        for (Pair<View, Integer> t : target.targetsBackground) {\r\n            int color = getColor(swatch, t.second);\r\n            if (!cacheHit && target.targetCrossfade) {\r\n                crossfadeTargetBackground(target, t, color);\r\n            } else {\r\n                t.first.setBackgroundColor(color);\r\n            }\r\n        }\r\n        for (Pair<TextView, Integer> t : target.targetsText) {\r\n            int color = getColor(swatch, t.second);\r\n            t.first.setTextColor(color);\r\n        }\r\n        target.clear();\r\n        this.callbacks = null;\r\n    }\r\n}"
}, {
	"Path": "org.springsource.loaded.test.MethodInvokerRewriterTests.privateMethodCallsAndInvokeSpecial2",
	"Comment": "rewriting invokespecial when used for private method access. similar to the previous test but now we are deleting\tsome of the methods on reload.",
	"Method": "void privateMethodCallsAndInvokeSpecial2(){\r\n    registry = getTypeRegistry(\"invokespecial..*\");\r\n    ReloadableType t = loadType(registry, \"invokespecial.ContainsPrivateCalls\");\r\n    Class<?> clazz = t.getClazz();\r\n    Object o = clazz.newInstance();\r\n    Method m = clazz.getDeclaredMethod(\"callMyPrivates\");\r\n    assertEquals(\"12123abctruez\", m.invoke(o));\r\n    t.loadNewVersion(\"002\", retrieveRename(\"invokespecial.ContainsPrivateCalls\", \"invokespecial.ContainsPrivateCalls002\"));\r\n    assertEquals(\"123abctruez\", m.invoke(o));\r\n}"
}, {
	"Path": "org.springsource.loaded.test.MethodInvokerRewriterTests.privateMethodCallsAndInvokeSpecial4",
	"Comment": "rewriting invokespecial when used for private method access. similar to the previous test but now we change a\tpublic method to private",
	"Method": "void privateMethodCallsAndInvokeSpecial4(){\r\n    registry = getTypeRegistry(\"invokespecial..*\");\r\n    ReloadableType t = loadType(registry, \"invokespecial.ContainsPrivateCallsB\");\r\n    Class<?> clazz = t.getClazz();\r\n    Object o = clazz.newInstance();\r\n    Method m = clazz.getDeclaredMethod(\"callMyPrivates\");\r\n    assertEquals(\"12123abctruez\", m.invoke(o));\r\n    t.loadNewVersion(\"002\", retrieveRename(\"invokespecial.ContainsPrivateCallsB\", \"invokespecial.ContainsPrivateCallsB002\"));\r\n    assertEquals(\"12123abctruez\", m.invoke(o));\r\n}"
}, {
	"Path": "org.springsource.loaded.ri.ReflectiveInterceptor.jlClassGetModifiers",
	"Comment": "retrieve modifiers for a java class, which might or might not be reloadable or reloaded.",
	"Method": "int jlClassGetModifiers(Class<?> clazz){\r\n    ReloadableType rtype = getRType(clazz);\r\n    if (rtype == null) {\r\n        return clazz.getModifiers();\r\n    } else {\r\n        return rtype.getLatestTypeDescriptor().getModifiers() & ~Opcodes.ACC_SUPER;\r\n    }\r\n}"
}, {
	"Path": "com.alipay.sofa.rpc.api.future.SofaResponseFuture.getResponse",
	"Comment": "get responseif remoting get exception, framework will wrapped it to sofarpcexception",
	"Method": "Object getResponse(long timeout,boolean clear){\r\n    RpcInvokeContext context = RpcInvokeContext.getContext();\r\n    Future future = context.getFuture();\r\n    if (null == future) {\r\n        throw new SofaRpcException(RpcErrorType.CLIENT_UNDECLARED_ERROR, LogCodes.getLog(LogCodes.ERROR_RESPONSE_FUTURE_NULL, Thread.currentThread()));\r\n    }\r\n    try {\r\n        if (clear) {\r\n            context.setFuture(null);\r\n        }\r\n        return future.get(timeout, TimeUnit.MILLISECONDS);\r\n    } catch (TimeoutException ex) {\r\n        if (!future.isDone()) {\r\n            throw new SofaTimeOutException(\"Future is not done when timeout.\", ex);\r\n        } else {\r\n            throw new SofaTimeOutException(ex.getMessage(), ex);\r\n        }\r\n    } catch (ExecutionException ex) {\r\n        Throwable cause = ex.getCause();\r\n        if (cause instanceof SofaRpcException) {\r\n            throw (SofaRpcException) cause;\r\n        } else {\r\n            throw new SofaRpcException(RpcErrorType.SERVER_UNDECLARED_ERROR, cause.getMessage(), cause);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.alipay.sofa.rpc.common.utils.ClassUtils.isAssignableFrom",
	"Comment": "the isassignablefrom method which can cross multiple classloader.",
	"Method": "boolean isAssignableFrom(Class<?> interfaceClass,Class<?> implementClass){\r\n    if (interfaceClass.isAssignableFrom(implementClass)) {\r\n        return true;\r\n    }\r\n    String interfaceName = interfaceClass.getCanonicalName();\r\n    return implementClass.getCanonicalName().equals(interfaceName) || isImplementOrSubclass(interfaceName, implementClass);\r\n}"
}, {
	"Path": "org.springsource.loaded.test.TypeRegistryTests.sameInstance",
	"Comment": "same instance for two different calls passing the same classloader.",
	"Method": "void sameInstance(){\r\n    TypeRegistry typeRegistry = TypeRegistry.getTypeRegistryFor(binLoader);\r\n    assertNotNull(typeRegistry);\r\n    TypeRegistry typeRegistry2 = TypeRegistry.getTypeRegistryFor(binLoader);\r\n    assertNotNull(typeRegistry2);\r\n    assertTrue(typeRegistry == typeRegistry2);\r\n}"
}, {
	"Path": "com.querydsl.spatial.jts.JTSSurfaceExpression.area",
	"Comment": "the area of this surface, as measured in the spatial reference system of this surface.",
	"Method": "NumberExpression<Double> area(){\r\n    if (area == null) {\r\n        area = Expressions.numberOperation(Double.class, SpatialOps.AREA, mixin);\r\n    }\r\n    return area;\r\n}"
}, {
	"Path": "android.support.design.widget.CustomCollapsingToolbarLayout.setTitleEnabled",
	"Comment": "sets whether this view should display its own title.the title displayed by this view will shrink and grow based on the scroll offset.",
	"Method": "void setTitleEnabled(boolean enabled){\r\n    if (enabled != mCollapsingTitleEnabled) {\r\n        mCollapsingTitleEnabled = enabled;\r\n        updateDummyView();\r\n        requestLayout();\r\n    }\r\n}"
}, {
	"Path": "org.springsource.loaded.ri.test.ClassReflectionTests.test_invokeStaticMethodOverriden",
	"Comment": "test invoking a static... does it truly use static dispatch?",
	"Method": "void test_invokeStaticMethodOverriden(){\r\n    String methodName = \"staticMethodAdded\";\r\n    try {\r\n        Result r = getDeclaredMethod(methodName);\r\n        fail(\"Method shouldn't exist at first!\\n\" + r.toString());\r\n    } catch (ResultException e) {\r\n        assertNoSuchMethodException(TARGET_CLASS_NAME + \".\" + methodName + \"()\", e);\r\n    }\r\n    reloadType(\"002\");\r\n    String subClassName = TARGET_PACKAGE + \".SubClassTarget\";\r\n    ReloadableType subTarget = registry.addType(subClassName, loadBytesForClass(subClassName));\r\n    Object subInstance = subTarget.getClazz().newInstance();\r\n    assertMethod(\"public static int \" + subClassName + \".\" + methodName + \"()\", getDeclaredMethod(subTarget.getClazz(), methodName));\r\n    Result r = getDeclaredMethod(methodName);\r\n    assertMethod(\"public static int \" + TARGET_CLASS_NAME + \".\" + methodName + \"()\", r);\r\n    Method m = (Method) r.returnValue;\r\n    r = invokeOn(subTarget, m);\r\n    assertEquals(2, r.returnValue);\r\n    reloadType(\"003\");\r\n    r = invokeOn(subInstance, m);\r\n    assertEquals(3, r.returnValue);\r\n    m = (Method) getDeclaredMethod(methodName).returnValue;\r\n    r = invokeOn(subInstance, m);\r\n    assertEquals(3, r.returnValue);\r\n}"
}, {
	"Path": "org.springsource.loaded.Utils.toParamClasses",
	"Comment": "given a method descriptor, extract the parameter descriptor and convert into corresponding class objects. this\trequires a reference to a class loader to convert type names into class objects.",
	"Method": "Class<?>[] toParamClasses(String methodDescriptor,ClassLoader classLoader){\r\n    Type[] paramTypes = Type.getArgumentTypes(methodDescriptor);\r\n    Class<?>[] paramClasses = new Class<?>[paramTypes.length];\r\n    for (int i = 0; i < paramClasses.length; i++) {\r\n        paramClasses[i] = toClass(paramTypes[i], classLoader);\r\n    }\r\n    return paramClasses;\r\n}"
}, {
	"Path": "com.querydsl.spatial.jts.JTSMultiSurfaceExpression.area",
	"Comment": "the area of this multisurface, as measured in the spatial reference system of this multisurface.",
	"Method": "NumberExpression<Double> area(){\r\n    if (area == null) {\r\n        area = Expressions.numberOperation(Double.class, SpatialOps.AREA, mixin);\r\n    }\r\n    return area;\r\n}"
}, {
	"Path": "com.r0adkll.slidr.Slidr.attach",
	"Comment": "attach a slideable mechanism to an activity that adds the slide to dismiss functionalityand allows for the statusbar to transition between colors",
	"Method": "SlidrInterface attach(Activity activity,SlidrInterface attach,Activity activity,int statusBarColor1,int statusBarColor2,SlidrInterface attach,Activity activity,SlidrConfig config){\r\n    final SliderPanel panel = attachSliderPanel(activity, config);\r\n    panel.setOnPanelSlideListener(new ConfigPanelSlideListener(activity, config));\r\n    return panel.getDefaultInterface();\r\n}"
}, {
	"Path": "org.spockframework.compiler.ExpressionReplacingVisitorSupport.replaceVisitedExpressionWith",
	"Comment": "replaces the currently visited expression with the specified expression.",
	"Method": "void replaceVisitedExpressionWith(Expression other){\r\n    replacementExpr = other;\r\n}"
}, {
	"Path": "org.springsource.loaded.testgen.SystematicChoiceGenerator.replay",
	"Comment": "reinitialise the state of the choice generator to replay a given list of choices.",
	"Method": "void replay(List<Boolean> replayChoices){\r\n    this.choices = replayChoices;\r\n    this.next = 0;\r\n}"
}, {
	"Path": "org.springsource.loaded.FieldReaderWriter.findAndGetFieldValueInHierarchy",
	"Comment": "walk up the instance hierarchy looking for the field, and when it is found access it and return the result. will\texit via exception if it cannot find the field or something goes wrong when accessing it.",
	"Method": "Object findAndGetFieldValueInHierarchy(Object instance){\r\n    Class<?> clazz = instance.getClass();\r\n    String fieldname = theField.getName();\r\n    String searchName = typeDescriptor.getName().replace('/', '.');\r\n    while (clazz != null && !clazz.getName().equals(searchName)) {\r\n        clazz = clazz.getSuperclass();\r\n    }\r\n    if (clazz == null) {\r\n        throw new IllegalStateException(\"Failed to find \" + searchName + \" in hierarchy of \" + instance.getClass());\r\n    }\r\n    try {\r\n        Field f = clazz.getDeclaredField(fieldname);\r\n        f.setAccessible(true);\r\n        return f.get(instance);\r\n    } catch (Exception e) {\r\n        throw new IllegalStateException(\"Unexpectedly could not access field named \" + fieldname + \" on class \" + clazz.getName());\r\n    }\r\n}"
}, {
	"Path": "org.spockframework.compiler.ConditionRewriter.visitStaticMethodCallExpression",
	"Comment": "only used for statically imported methods called by their simple name",
	"Method": "void visitStaticMethodCallExpression(StaticMethodCallExpression expr){\r\n    StaticMethodCallExpression conversion = new StaticMethodCallExpression(expr.getOwnerType(), recordNa(expr.getMethod()), convert(expr.getArguments()));\r\n    conversion.setSourcePosition(expr);\r\n    conversion.setMetaMethod(expr.getMetaMethod());\r\n    result = record(conversion);\r\n}"
}, {
	"Path": "org.springsource.loaded.test.CatcherTests.exerciseCatcher2",
	"Comment": "now we work with a mixed hierarchy. type x declares the methods, type y extends x does not, type z extends y\tdoes.",
	"Method": "void exerciseCatcher2(){\r\n    TypeRegistry registry = getTypeRegistry(\"catchers..*\");\r\n    String x = \"catchers.X\";\r\n    String y = \"catchers.Y\";\r\n    String z = \"catchers.Z\";\r\n    ReloadableType rtypeX = registry.addType(x, loadBytesForClass(x));\r\n    ReloadableType rtypeY = registry.addType(y, loadBytesForClass(y));\r\n    ReloadableType rtypeZ = registry.addType(z, loadBytesForClass(z));\r\n    Class<?> clazz = loadRunner(\"catchers.Runner2\");\r\n    Assert.assertEquals(1, runUnguarded(clazz, \"runPublicX\").returnValue);\r\n    Assert.assertEquals(1, runUnguarded(clazz, \"runPublicY\").returnValue);\r\n    Assert.assertEquals(3, runUnguarded(clazz, \"runPublicZ\").returnValue);\r\n    Assert.assertEquals('a', runUnguarded(clazz, \"runDefaultX\").returnValue);\r\n    Assert.assertEquals('a', runUnguarded(clazz, \"runDefaultY\").returnValue);\r\n    Assert.assertEquals('c', runUnguarded(clazz, \"runDefaultZ\").returnValue);\r\n    Assert.assertEquals(100L, runUnguarded(clazz, \"runProtectedX\").returnValue);\r\n    Assert.assertEquals(100L, runUnguarded(clazz, \"runProtectedY\").returnValue);\r\n    Assert.assertEquals(300L, runUnguarded(clazz, \"runProtectedZ\").returnValue);\r\n    rtypeY.loadNewVersion(\"2\", retrieveRename(y, y + \"2\"));\r\n    Assert.assertEquals(1, runUnguarded(clazz, \"runPublicX\").returnValue);\r\n    Assert.assertEquals(22, runUnguarded(clazz, \"runPublicY\").returnValue);\r\n    Assert.assertEquals(3, runUnguarded(clazz, \"runPublicZ\").returnValue);\r\n    Assert.assertEquals('a', runUnguarded(clazz, \"runDefaultX\").returnValue);\r\n    Assert.assertEquals('B', runUnguarded(clazz, \"runDefaultY\").returnValue);\r\n    Assert.assertEquals('c', runUnguarded(clazz, \"runDefaultZ\").returnValue);\r\n    Assert.assertEquals(100L, runUnguarded(clazz, \"runProtectedX\").returnValue);\r\n    Assert.assertEquals(200L, runUnguarded(clazz, \"runProtectedY\").returnValue);\r\n    Assert.assertEquals(300L, runUnguarded(clazz, \"runProtectedZ\").returnValue);\r\n}"
}, {
	"Path": "com.squareup.tape2.QueueFile.getSneakyThrowable",
	"Comment": "use this to throw checked exceptions from iterator methods that do not declare that they throwchecked exceptions.",
	"Method": "T getSneakyThrowable(Throwable t){\r\n    throw (T) t;\r\n}"
}, {
	"Path": "io.rx_cache2.ActionsList.evictAllKeepingFirstN",
	"Comment": "evict elements from the cache starting from the first position until its count is equal to thevalue specified in n param.",
	"Method": "ActionsList<T> evictAllKeepingFirstN(int n){\r\n    Func3<T> func3 = new Func3<T>() {\r\n        @Override\r\n        public boolean call(int position, int count, T element) {\r\n            int positionToStartEvicting = count - (count - n);\r\n            return position >= positionToStartEvicting;\r\n        }\r\n    };\r\n    return evictIterable(func3);\r\n}"
}, {
	"Path": "io.rx_cache2.ActionsList.evictAllKeepingFirstN",
	"Comment": "evict elements from the cache starting from the first position until its count is equal to thevalue specified in n param.",
	"Method": "ActionsList<T> evictAllKeepingFirstN(int n){\r\n    int positionToStartEvicting = count - (count - n);\r\n    return position >= positionToStartEvicting;\r\n}"
}, {
	"Path": "org.springsource.loaded.test.SystemClassReflectionRewriterTests.helperJLRMI_0",
	"Comment": "the testcase for jlrmi uses gdm to find the method object, so that is why this helper exists",
	"Method": "Method helperJLRMI_0(Class<?> clazz,String name,Class<?>[] argTypes){\r\n    return SystemClassReflectionRewriterTests.class.getDeclaredMethod(\"helperJLRMI\", Method.class, Object.class, Object[].class);\r\n}"
}, {
	"Path": "android.support.design.widget.CustomCollapsingToolbarLayout.getCollapsedTitleGravity",
	"Comment": "returns the horizontal and vertical alignment for title when collapsed.",
	"Method": "int getCollapsedTitleGravity(){\r\n    return mCollapsingTextHelper.getCollapsedTextGravity();\r\n}"
}, {
	"Path": "org.testcontainers.jdbc.ContainerDatabaseDriver.getContainer",
	"Comment": "utility method to get an instance of a database container given its jdbc url.",
	"Method": "JdbcDatabaseContainer getContainer(String jdbcUrl){\r\n    synchronized (jdbcUrlContainerCache) {\r\n        return jdbcUrlContainerCache.get(jdbcUrl);\r\n    }\r\n}"
}, {
	"Path": "com.simplecity.amp_library.ui.views.BreadcrumbView.createFile",
	"Comment": "creates the a new file reference for a partial breadcrumb item.",
	"Method": "File createFile(String[] dirs,int pos){\r\n    File parent = new File(FileHelper.ROOT_DIRECTORY);\r\n    for (int i = 1; i < pos; i++) {\r\n        parent = new File(parent, dirs[i]);\r\n    }\r\n    return new File(parent, dirs[pos]);\r\n}"
}, {
	"Path": "com.klinker.android.twitter.views.NotificationDrawerLayout.setScrimColor",
	"Comment": "set a color to use for the scrim that obscures primary content while a drawer is open.",
	"Method": "void setScrimColor(int color){\r\n    mScrimColor = color;\r\n    invalidate();\r\n}"
}, {
	"Path": "android.support.design.widget.CustomCollapsingToolbarLayout.setExpandedTitleGravity",
	"Comment": "sets the horizontal alignment of the expanded title and the vertical gravity that willbe used when there is extra space in the expanded bounds beyond what is required forthe title itself.",
	"Method": "void setExpandedTitleGravity(int gravity){\r\n    mCollapsingTextHelper.setExpandedTextGravity(gravity);\r\n}"
}, {
	"Path": "com.querydsl.sql.dml.AbstractSQLInsertClause.populate",
	"Comment": "populate the insert clause with the properties of the given bean usingthe given mapper.",
	"Method": "C populate(Object bean,C populate,T obj,Mapper<T> mapper){\r\n    Map<Path<?>, Object> values = mapper.createMap(entity, obj);\r\n    for (Map.Entry<Path<?>, Object> entry : values.entrySet()) {\r\n        set((Path) entry.getKey(), entry.getValue());\r\n    }\r\n    return (C) this;\r\n}"
}, {
	"Path": "org.springsource.loaded.test.SystemClassReflectionRewriterTests.jlClass_getDeclaredFields",
	"Comment": "first test. here we are simulating a system class that is making a call to class.getdeclaredfields. the\tinvocation is rewritten to go via a helper method generated into the target which uses a field settable from\toutside. the aim is that when springloaded is initialized far enough it can set the fields in these types,\teffectively plugging in the reflective interceptor system.",
	"Method": "void jlClass_getDeclaredFields(){\r\n    byte[] classbytes = loadBytesForClass(\"system.One\");\r\n    RewriteResult rr = SystemClassReflectionRewriter.rewrite(\"system.One\", classbytes);\r\n    byte[] newbytes = rr.bytes;\r\n    Class<?> clazz = loadit(\"system.One\", newbytes);\r\n    assertEquals(\"CLASS: system/One v50 0x0021(public synchronized) super java/lang/Object\\n\" + \"SOURCE: One.java null\\n\" + \"FIELD 0x0009(public static) __sljlcgdfs Ljava/lang/reflect/Method;\\n\" + \"METHOD: 0x0001(public) <init>()V\\n\" + \"METHOD: 0x0001(public) runIt()Ljava/lang/String;\\n\" + \"METHOD: 0x0001(public) fs()[Ljava/lang/reflect/Field;\\n\" + \"METHOD: 0x000a(private static) __sljlcgdfs(Ljava/lang/Class;)[Ljava/lang/reflect/Field;\\n\" + \"\\n\", toStringClass(newbytes));\r\n    Object value = run(clazz, \"runIt\");\r\n    assertEquals(\"complete:fields:null?false fields:size=1\", value);\r\n    assertEquals(0, callcount);\r\n    Method m = SystemClassReflectionRewriterTests.class.getDeclaredMethod(\"helper\", Class.class);\r\n    assertNotNull(m);\r\n    clazz.getDeclaredField(jlcgdfs).set(null, m);\r\n    value = run(clazz, \"runIt\");\r\n    assertEquals(\"complete:fields:null?true\", value);\r\n    assertTrue((rr.bits & JLC_GETDECLAREDFIELDS) != 0);\r\n    assertTrue((rr.bits & ~JLC_GETDECLAREDFIELDS) == 0);\r\n    assertEquals(1, callcount);\r\n    assertEquals(\"Class.getDeclaredFields()\", rr.summarize());\r\n}"
}, {
	"Path": "org.springsource.loaded.test.ExecutorBuilderTests.typeLevelAnnotations2",
	"Comment": "testing that type level annotations are copied to the executor. this loads a different form of the type with a\tsecond annotation.",
	"Method": "void typeLevelAnnotations2(){\r\n    String t = \"executor.A\";\r\n    TypeRegistry typeRegistry = getTypeRegistry(t);\r\n    ReloadableType rtype = typeRegistry.addType(t, loadBytesForClass(t));\r\n    rtype.loadNewVersion(\"2\", retrieveRename(t, t + \"2\"));\r\n    Class<?> clazz = rtype.getLatestExecutorClass();\r\n    Assert.assertEquals(Utils.getExecutorName(t, \"2\"), clazz.getName());\r\n    Annotation[] annos = clazz.getAnnotations();\r\n    Assert.assertNotNull(annos);\r\n    Assert.assertEquals(2, annos.length);\r\n    Set<String> s = new HashSet<String>();\r\n    for (Annotation anno : annos) {\r\n        s.add(anno.toString());\r\n    }\r\n    Assert.assertTrue(s.remove(\"@common.Marker()\"));\r\n    if (!s.remove(\"@common.Anno(someValue=37, longValue=2, id=abc)\")) {\r\n        Assert.assertTrue(s.remove(\"@common.Anno(longValue=2, someValue=37, id=abc)\"));\r\n    }\r\n    Assert.assertEquals(0, s.size());\r\n}"
}, {
	"Path": "io.rx_cache2.internal.cache.memory.apache.AbstractHashedMap.checkCapacity",
	"Comment": "checks the capacity of the map and enlarges it if necessary.this implementation uses the threshold to check if the map needs enlarging",
	"Method": "void checkCapacity(){\r\n    if (size >= threshold) {\r\n        final int newCapacity = data.length * 2;\r\n        if (newCapacity <= MAXIMUM_CAPACITY) {\r\n            ensureCapacity(newCapacity);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.querydsl.sql.dml.AbstractSQLInsertClause.setBatchToBulk",
	"Comment": "set whether batches should be optimized into a single bulk operation.will revert to batches, if bulk is not supported",
	"Method": "void setBatchToBulk(boolean b){\r\n    this.batchToBulk = b && configuration.getTemplates().isBatchToBulkSupported();\r\n}"
}, {
	"Path": "com.simplecity.amp_library.ui.views.RepeatingImageButton.setRepeatListener",
	"Comment": "sets the listener to be called while the button is pressed andthe interval in milliseconds with which it will be called.",
	"Method": "void setRepeatListener(RepeatListener l){\r\n    listener = l;\r\n}"
}, {
	"Path": "org.testcontainers.containers.JdbcDatabaseContainer.withConnectTimeoutSeconds",
	"Comment": "set time to allow for the database to start and establish an initial connection, in seconds.",
	"Method": "SELF withConnectTimeoutSeconds(int connectTimeoutSeconds){\r\n    this.connectTimeoutSeconds = connectTimeoutSeconds;\r\n    return self();\r\n}"
}, {
	"Path": "org.springsource.loaded.support.Java8.emulateInvokeDynamic",
	"Comment": "programmatic emulation of invokedynamic so initialize the callsite via use of the bootstrap method then invoke\tthe result.",
	"Method": "Object emulateInvokeDynamic(ReloadableType rtype,Class<?> executorClass,Handle handle,Object[] bsmArgs,Object lookup,String indyNameAndDescriptor,Object[] indyParams){\r\n    try {\r\n        CallSite callsite = callLambdaMetaFactory(rtype, bsmArgs, lookup, indyNameAndDescriptor, executorClass);\r\n        return callsite.dynamicInvoker().invokeWithArguments(indyParams);\r\n    } catch (Throwable t) {\r\n        throw new RuntimeException(t);\r\n    }\r\n}"
}, {
	"Path": "cn.finalteam.rxgalleryfinal.ui.widget.FlexibleDividerDecoration.wasDividerAlreadyDrawn",
	"Comment": "determines whether divider was already drawn for the row the item is in,effectively only makes sense for a grid",
	"Method": "boolean wasDividerAlreadyDrawn(int position,RecyclerView parent){\r\n    if (parent.getLayoutManager() instanceof GridLayoutManager) {\r\n        GridLayoutManager layoutManager = (GridLayoutManager) parent.getLayoutManager();\r\n        GridLayoutManager.SpanSizeLookup spanSizeLookup = layoutManager.getSpanSizeLookup();\r\n        int spanCount = layoutManager.getSpanCount();\r\n        return spanSizeLookup.getSpanIndex(position, spanCount) > 0;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "io.rx_cache2.internal.cache.memory.apache.AbstractHashedMap.ensureCapacity",
	"Comment": "changes the size of the data structure to the capacity proposed.",
	"Method": "void ensureCapacity(int newCapacity){\r\n    final int oldCapacity = data.length;\r\n    if (newCapacity <= oldCapacity) {\r\n        return;\r\n    }\r\n    if (size == 0) {\r\n        threshold = calculateThreshold(newCapacity, loadFactor);\r\n        data = new HashEntry[newCapacity];\r\n    } else {\r\n        final HashEntry<K, V>[] oldEntries = data;\r\n        final HashEntry<K, V>[] newEntries = new HashEntry[newCapacity];\r\n        modCount++;\r\n        for (int i = oldCapacity - 1; i >= 0; i--) {\r\n            HashEntry<K, V> entry = oldEntries[i];\r\n            if (entry != null) {\r\n                oldEntries[i] = null;\r\n                do {\r\n                    final HashEntry<K, V> next = entry.next;\r\n                    final int index = hashIndex(entry.hashCode, newCapacity);\r\n                    entry.next = newEntries[index];\r\n                    newEntries[index] = entry;\r\n                    entry = next;\r\n                } while (entry != null);\r\n            }\r\n        }\r\n        threshold = calculateThreshold(newCapacity, loadFactor);\r\n        data = newEntries;\r\n    }\r\n}"
}, {
	"Path": "com.alipay.sofa.rpc.message.http.HttpResponseFuture.getSofaResponse",
	"Comment": "waits if necessary for at most the given time for the computationto complete, and then retrieves its result, if available.",
	"Method": "SofaResponse getSofaResponse(int timeout,TimeUnit unit){\r\n    long realTimeOut = unit.toMillis(timeout);\r\n    long remainTime = realTimeOut - (sentTime - genTime);\r\n    if (remainTime <= 0) {\r\n        if (isDone()) {\r\n            return getNowResponse();\r\n        }\r\n    } else {\r\n        if (await(remainTime, TimeUnit.MILLISECONDS)) {\r\n            return getNowResponse();\r\n        }\r\n    }\r\n    this.setDoneTime();\r\n    throw new TimeoutException();\r\n}"
}, {
	"Path": "org.springsource.loaded.test.TypeRewriterTests.testInterfaceRTypeField",
	"Comment": "checking that rtype field is created and initialized for a reloadable interface type.",
	"Method": "void testInterfaceRTypeField(){\r\n    String interfaceName = \"reflection.targets.InterfaceTarget\";\r\n    registry = getTypeRegistry(interfaceName);\r\n    ReloadableType rtype = registry.addType(interfaceName, loadBytesForClass(interfaceName));\r\n    assertEquals(rtype, ReflectiveInterceptor.getRType(rtype.getClazz()));\r\n}"
}, {
	"Path": "org.springsource.loaded.test.TypeRegistryTests.classloaderCounting",
	"Comment": "checking that the counting is working correctly for the managed classloader.",
	"Method": "void classloaderCounting(){\r\n    String one = \"basic.Basic\";\r\n    String two = \"basic.BasicB\";\r\n    String three = \"basic.BasicC\";\r\n    TypeRegistry typeRegistry = getTypeRegistry(one + \",\" + two + \",\" + three);\r\n    ReloadableType tOne = typeRegistry.addType(one, loadBytesForClass(one));\r\n    ReloadableType tTwo = typeRegistry.addType(two, loadBytesForClass(two));\r\n    ReloadableType tThree = typeRegistry.addType(three, loadBytesForClass(three));\r\n    result = runUnguarded(tOne.getClazz(), \"getValue\");\r\n    assertEquals(5, result.returnValue);\r\n    assertEquals(0, typeRegistry.getChildClassLoader().getDefinedCount());\r\n    tOne.loadNewVersion(\"002\", retrieveRename(one, one + \"002\"));\r\n    assertEquals(2, typeRegistry.getChildClassLoader().getDefinedCount());\r\n    tTwo.loadNewVersion(\"002\", tTwo.bytesInitial);\r\n    assertEquals(4, typeRegistry.getChildClassLoader().getDefinedCount());\r\n    tThree.loadNewVersion(\"002\", tThree.bytesInitial);\r\n    assertEquals(6, typeRegistry.getChildClassLoader().getDefinedCount());\r\n}"
}, {
	"Path": "reflection.FieldInvoker.getFieldWithAccess",
	"Comment": "gets a field in class, can override access constraints if requested to do so.",
	"Method": "String getFieldWithAccess(Class<?> targetClass,String whichField,boolean setAccess){\r\n    Object targetInstance = targetClass.newInstance();\r\n    Field field = targetClass.getDeclaredField(whichField);\r\n    if (setAccess) {\r\n        field.setAccessible(true);\r\n    }\r\n    return (String) field.get(targetInstance);\r\n}"
}, {
	"Path": "com.querydsl.sql.SQLExpressions.firstValue",
	"Comment": "returns value evaluated at the row that is the first row of the window frame",
	"Method": "WindowOver<T> firstValue(Expression<T> expr){\r\n    return new WindowOver<T>(expr.getType(), SQLOps.FIRSTVALUE, expr);\r\n}"
}, {
	"Path": "org.springsource.loaded.test.TestInfrastructureTests.loader",
	"Comment": "just attempt to access something in the testdata project through the classloader",
	"Method": "void loader(){\r\n    TestClassLoader tcl = new TestClassLoader(toURLs(TestDataPath), this.getClass().getClassLoader());\r\n    URL url = tcl.findResource(\"data/SimpleClass.class\");\r\n    Assert.assertNotNull(url);\r\n    url = tcl.findResource(\"data/MissingClass.class\");\r\n    Assert.assertNull(url);\r\n}"
}, {
	"Path": "org.testcontainers.vault.VaultContainer.withVaultToken",
	"Comment": "sets the vault root token for the container so application tests can source secrets using the token",
	"Method": "SELF withVaultToken(String token){\r\n    withEnv(\"VAULT_DEV_ROOT_TOKEN_ID\", token);\r\n    withEnv(\"VAULT_TOKEN\", token);\r\n    return self();\r\n}"
}, {
	"Path": "org.spockframework.gentyref.GenericTypeReflector.getExactDirectSuperTypes",
	"Comment": "returns the direct supertypes of the given type. resolves type parameters.",
	"Method": "Type[] getExactDirectSuperTypes(Type type){\r\n    if (type instanceof ParameterizedType || type instanceof Class) {\r\n        Class<?> clazz;\r\n        if (type instanceof ParameterizedType) {\r\n            clazz = (Class<?>) ((ParameterizedType) type).getRawType();\r\n        } else {\r\n            clazz = (Class<?>) type;\r\n            if (clazz.isArray())\r\n                return getArrayExactDirectSuperTypes(clazz);\r\n        }\r\n        Type[] superInterfaces = clazz.getGenericInterfaces();\r\n        Type superClass = clazz.getGenericSuperclass();\r\n        Type[] result;\r\n        int resultIndex;\r\n        if (superClass == null) {\r\n            result = new Type[superInterfaces.length];\r\n            resultIndex = 0;\r\n        } else {\r\n            result = new Type[superInterfaces.length + 1];\r\n            resultIndex = 1;\r\n            result[0] = mapTypeParameters(superClass, type);\r\n        }\r\n        for (Type superInterface : superInterfaces) {\r\n            result[resultIndex++] = mapTypeParameters(superInterface, type);\r\n        }\r\n        return result;\r\n    } else if (type instanceof TypeVariable) {\r\n        TypeVariable<?> tv = (TypeVariable<?>) type;\r\n        return tv.getBounds();\r\n    } else if (type instanceof WildcardType) {\r\n        return ((WildcardType) type).getUpperBounds();\r\n    } else if (type instanceof CaptureType) {\r\n        return ((CaptureType) type).getUpperBounds();\r\n    } else if (type instanceof GenericArrayType) {\r\n        return getArrayExactDirectSuperTypes(type);\r\n    } else {\r\n        throw new RuntimeException(\"not implemented type: \" + type);\r\n    }\r\n}"
}, {
	"Path": "com.querydsl.spatial.GeometryExpression.distance",
	"Comment": "returns the shortest distance between any two points in the two geometric objects ascalculated in the spatial reference system of this geometric object. because the geometriesare closed, it is possible to find a point on each geometric object involved, such that thedistance between these 2 points is the returned distance between their geometric objects.",
	"Method": "NumberExpression<Double> distance(Geometry geometry,NumberExpression<Double> distance,Expression<? extends Geometry> geometry){\r\n    return Expressions.numberOperation(Double.class, SpatialOps.DISTANCE, mixin, geometry);\r\n}"
}, {
	"Path": "org.testcontainers.utility.DockerStatus.isContainerRunning",
	"Comment": "based on this status, is this container running, and has it been doing so for the specified amount of time?",
	"Method": "boolean isContainerRunning(InspectContainerResponse.ContainerState state,Duration minimumRunningDuration,Instant now){\r\n    if (state.getRunning()) {\r\n        if (minimumRunningDuration == null) {\r\n            return true;\r\n        }\r\n        Instant startedAt = DateTimeFormatter.ISO_INSTANT.parse(state.getStartedAt(), Instant::from);\r\n        if (startedAt.isBefore(now.minus(minimumRunningDuration))) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.r0adkll.slidr.model.SlidrConfig.getSecondaryColor",
	"Comment": "get the secondary color that the slider will interpolatel that is the color of the activitythat you are making slidable",
	"Method": "int getSecondaryColor(){\r\n    return colorSecondary;\r\n}"
}, {
	"Path": "spock.util.concurrent.BlockingVariable.get",
	"Comment": "blocks until a value has been set for this variable, or a timeout expires.",
	"Method": "T get(){\r\n    if (!valueReady.await((long) (timeout * 1000), TimeUnit.MILLISECONDS)) {\r\n        String msg = String.format(\"BlockingVariable.get() timed out after %1.2f seconds\", timeout);\r\n        throw new SpockTimeoutError(timeout, msg);\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "org.springsource.loaded.test.UtilsTests.testReturning",
	"Comment": "test the helper that adds the correct return instructions based on the descriptor in use.",
	"Method": "void testReturning(){\r\n    FakeMethodVisitor fmv = new FakeMethodVisitor();\r\n    Utils.addCorrectReturnInstruction(fmv, ReturnType.ReturnTypeVoid, true);\r\n    assertEquals(\"visitInsn(RETURN)\", fmv.getEvents());\r\n    fmv.clearEvents();\r\n    Utils.addCorrectReturnInstruction(fmv, ReturnType.ReturnTypeFloat, true);\r\n    assertEquals(\"visitInsn(FRETURN)\", fmv.getEvents());\r\n    fmv.clearEvents();\r\n    Utils.addCorrectReturnInstruction(fmv, ReturnType.ReturnTypeBoolean, true);\r\n    assertEquals(\"visitInsn(IRETURN)\", fmv.getEvents());\r\n    fmv.clearEvents();\r\n    Utils.addCorrectReturnInstruction(fmv, ReturnType.ReturnTypeShort, true);\r\n    assertEquals(\"visitInsn(IRETURN)\", fmv.getEvents());\r\n    fmv.clearEvents();\r\n    Utils.addCorrectReturnInstruction(fmv, ReturnType.ReturnTypeLong, true);\r\n    assertEquals(\"visitInsn(LRETURN)\", fmv.getEvents());\r\n    fmv.clearEvents();\r\n    Utils.addCorrectReturnInstruction(fmv, ReturnType.ReturnTypeDouble, true);\r\n    assertEquals(\"visitInsn(DRETURN)\", fmv.getEvents());\r\n    fmv.clearEvents();\r\n    Utils.addCorrectReturnInstruction(fmv, ReturnType.ReturnTypeChar, true);\r\n    assertEquals(\"visitInsn(IRETURN)\", fmv.getEvents());\r\n    fmv.clearEvents();\r\n    Utils.addCorrectReturnInstruction(fmv, ReturnType.ReturnTypeByte, true);\r\n    assertEquals(\"visitInsn(IRETURN)\", fmv.getEvents());\r\n    fmv.clearEvents();\r\n    Utils.addCorrectReturnInstruction(fmv, ReturnType.ReturnTypeInt, true);\r\n    assertEquals(\"visitInsn(IRETURN)\", fmv.getEvents());\r\n    fmv.clearEvents();\r\n    Utils.addCorrectReturnInstruction(fmv, ReturnType.getReturnType(\"java/lang/String\", ReturnType.Kind.REFERENCE), true);\r\n    assertEquals(\"visitTypeInsn(CHECKCAST,java/lang/String) visitInsn(ARETURN)\", fmv.getEvents());\r\n    fmv.clearEvents();\r\n    Utils.addCorrectReturnInstruction(fmv, ReturnType.getReturnType(\"[[I\", ReturnType.Kind.ARRAY), true);\r\n    assertEquals(\"visitTypeInsn(CHECKCAST,[[I) visitInsn(ARETURN)\", fmv.getEvents());\r\n    fmv.clearEvents();\r\n    Utils.addCorrectReturnInstruction(fmv, ReturnType.getReturnType(\"[[Ljava/lang/String;\", ReturnType.Kind.ARRAY), true);\r\n    assertEquals(\"visitTypeInsn(CHECKCAST,[[Ljava/lang/String;) visitInsn(ARETURN)\", fmv.getEvents());\r\n    fmv.clearEvents();\r\n}"
}, {
	"Path": "io.rx_cache2.ActionsList.evictFirstN",
	"Comment": "evict as much objects as requested by n param starting from the first position.",
	"Method": "ActionsList<T> evictFirstN(int n,ActionsList<T> evictFirstN,Func1Count func1Count,int n){\r\n    Func3<T> func3 = new Func3<T>() {\r\n        @Override\r\n        public boolean call(int position, int count, T element) {\r\n            return position < n && func1Count.call(count);\r\n        }\r\n    };\r\n    return evictIterable(func3);\r\n}"
}, {
	"Path": "io.rx_cache2.ActionsList.evictFirstN",
	"Comment": "evict as much objects as requested by n param starting from the first position.",
	"Method": "ActionsList<T> evictFirstN(int n,ActionsList<T> evictFirstN,Func1Count func1Count,int n){\r\n    return position < n && func1Count.call(count);\r\n}"
}, {
	"Path": "android.support.design.widget.CustomCollapsingToolbarLayout.getScrimAnimationDuration",
	"Comment": "returns the duration in milliseconds used for scrim visibility animations.",
	"Method": "long getScrimAnimationDuration(){\r\n    return mScrimAnimationDuration;\r\n}"
}, {
	"Path": "org.springsource.loaded.test.SpringLoadedTests.ensureCaptureOff",
	"Comment": "called at the end of a test to tidy up in case a test crashed and failed to stop capturing.",
	"Method": "void ensureCaptureOff(){\r\n    if (oldo != null) {\r\n        System.setOut(oldo);\r\n        System.setErr(olde);\r\n        oldo = null;\r\n    }\r\n}"
}, {
	"Path": "org.testcontainers.vault.VaultContainer.withVaultPort",
	"Comment": "sets the vault port in the container as well as the port bindings for the host to reach the container over http.",
	"Method": "SELF withVaultPort(int port){\r\n    setVaultPortRequested(true);\r\n    String vaultPort = String.valueOf(port);\r\n    withEnv(\"VAULT_ADDR\", \"http://0.0.0.0:\" + VAULT_PORT);\r\n    setPortBindings(Arrays.asList(vaultPort + \":\" + VAULT_PORT));\r\n    return self();\r\n}"
}, {
	"Path": "com.querydsl.spatial.GeometryExpression.intersection",
	"Comment": "returns a geometric object that represents the point set intersection of this geometricobject with anothergeometry.",
	"Method": "GeometryExpression<Geometry> intersection(Geometry geometry,GeometryExpression<Geometry> intersection,Expression<? extends Geometry> geometry){\r\n    return GeometryExpressions.geometryOperation(SpatialOps.INTERSECTION, mixin, geometry);\r\n}"
}, {
	"Path": "org.springsource.loaded.testgen.GenerativeSpringLoadedTest.classForName",
	"Comment": "get a type from the classloader. use this to get references to already loaded classes, or to get classes that\tfall outside the reloadable types universe.",
	"Method": "Class<?> classForName(String className){\r\n    return classProvider.classForName(className);\r\n}"
}, {
	"Path": "com.r0adkll.slidr.model.SlidrConfig.isEdgeOnly",
	"Comment": "has the user configured slidr to only catch at the edge of the screen ?",
	"Method": "boolean isEdgeOnly(){\r\n    return edgeOnly;\r\n}"
}, {
	"Path": "com.alipay.sofa.rpc.common.struct.ConcurrentHashSet.iterator",
	"Comment": "returns an iterator over the elements in this set. the elements arereturned in no particular order.",
	"Method": "Iterator<E> iterator(){\r\n    return map.keySet().iterator();\r\n}"
}, {
	"Path": "com.querydsl.spatial.GeometryExpression.union",
	"Comment": "returns a geometric object that represents the point setunion of this geometric object with anothergeometry.",
	"Method": "GeometryExpression<Geometry> union(Geometry geometry,GeometryExpression<Geometry> union,Expression<? extends Geometry> geometry){\r\n    return GeometryExpressions.geometryOperation(SpatialOps.UNION, mixin, geometry);\r\n}"
}, {
	"Path": "org.springsource.loaded.Utils.addCorrectReturnInstruction",
	"Comment": "depending on the signature of the return type, add the appropriate instructions to the method visitor.",
	"Method": "void addCorrectReturnInstruction(MethodVisitor mv,ReturnType returnType,boolean createCast){\r\n    if (returnType.isPrimitive()) {\r\n        char ch = returnType.descriptor.charAt(0);\r\n        switch(ch) {\r\n            case 'V':\r\n                mv.visitInsn(RETURN);\r\n                break;\r\n            case 'I':\r\n            case 'Z':\r\n            case 'S':\r\n            case 'B':\r\n            case 'C':\r\n                mv.visitInsn(IRETURN);\r\n                break;\r\n            case 'F':\r\n                mv.visitInsn(FRETURN);\r\n                break;\r\n            case 'D':\r\n                mv.visitInsn(DRETURN);\r\n                break;\r\n            case 'J':\r\n                mv.visitInsn(LRETURN);\r\n                break;\r\n            default:\r\n                throw new IllegalArgumentException(\"Not supported for '\" + ch + \"'\");\r\n        }\r\n    } else {\r\n        if (GlobalConfiguration.assertsMode) {\r\n            if (returnType.descriptor.endsWith(\";\") && !returnType.descriptor.startsWith(\"[\")) {\r\n                throw new IllegalArgumentException(\"Invalid signature of '\" + returnType.descriptor + \"'\");\r\n            }\r\n        }\r\n        if (createCast) {\r\n            mv.visitTypeInsn(CHECKCAST, returnType.descriptor);\r\n        }\r\n        mv.visitInsn(ARETURN);\r\n    }\r\n}"
}, {
	"Path": "org.springsource.loaded.testgen.GenerativeTest.assertEqualResults",
	"Comment": "this method gets called to compare two results, but only when the standard equals method returned false.\tsubclasses may override this to relax the equality check.",
	"Method": "void assertEqualResults(Result expected,Result actual){\r\n    throw new ComparisonFailure(null, expected.toString(), actual.toString());\r\n}"
}, {
	"Path": "org.testcontainers.containers.JdbcDatabaseContainer.getJdbcDriverInstance",
	"Comment": "obtain an instance of the correct jdbc driver for this particular database container type",
	"Method": "Driver getJdbcDriverInstance(){\r\n    synchronized (DRIVER_LOAD_MUTEX) {\r\n        if (driver == null) {\r\n            try {\r\n                driver = (Driver) Class.forName(this.getDriverClassName()).newInstance();\r\n            } catch (InstantiationException | IllegalAccessException | ClassNotFoundException e) {\r\n                throw new RuntimeException(\"Could not get Driver\", e);\r\n            }\r\n        }\r\n    }\r\n    return driver;\r\n}"
}, {
	"Path": "com.querydsl.spatial.PolygonExpression.interiorRingN",
	"Comment": "returns the n th interior ring for this polygon as a linestring.",
	"Method": "LineStringExpression<LineString> interiorRingN(int idx){\r\n    return GeometryExpressions.lineStringOperation(SpatialOps.INTERIOR_RINGN, mixin, ConstantImpl.create(idx));\r\n}"
}, {
	"Path": "com.alipay.sofa.rpc.bootstrap.DefaultConsumerBootstrap.subscribeFromRegistries",
	"Comment": "subscribe provider list from all registries, the providers will be merged.",
	"Method": "List<ProviderGroup> subscribeFromRegistries(){\r\n    List<ProviderGroup> result = new ArrayList<ProviderGroup>();\r\n    List<RegistryConfig> registryConfigs = consumerConfig.getRegistry();\r\n    if (CommonUtils.isEmpty(registryConfigs)) {\r\n        return result;\r\n    }\r\n    int addressWaitTime = consumerConfig.getAddressWait();\r\n    int maxAddressWaitTime = SofaConfigs.getIntegerValue(consumerConfig.getAppName(), SofaOptions.CONFIG_MAX_ADDRESS_WAIT_TIME, SofaOptions.MAX_ADDRESS_WAIT_TIME);\r\n    addressWaitTime = addressWaitTime < 0 ? maxAddressWaitTime : Math.min(addressWaitTime, maxAddressWaitTime);\r\n    ProviderInfoListener listener = consumerConfig.getProviderInfoListener();\r\n    respondRegistries = addressWaitTime == 0 ? null : new CountDownLatch(registryConfigs.size());\r\n    Map<String, ProviderGroup> tmpProviderInfoList = new HashMap<String, ProviderGroup>();\r\n    for (RegistryConfig registryConfig : registryConfigs) {\r\n        Registry registry = RegistryFactory.getRegistry(registryConfig);\r\n        registry.init();\r\n        registry.start();\r\n        try {\r\n            List<ProviderGroup> current;\r\n            try {\r\n                if (respondRegistries != null) {\r\n                    consumerConfig.setProviderInfoListener(new WrapperClusterProviderInfoListener(listener, respondRegistries));\r\n                }\r\n                current = registry.subscribe(consumerConfig);\r\n            } finally {\r\n                if (respondRegistries != null) {\r\n                    consumerConfig.setProviderInfoListener(listener);\r\n                }\r\n            }\r\n            if (current == null) {\r\n                continue;\r\n            } else {\r\n                if (respondRegistries != null) {\r\n                    respondRegistries.countDown();\r\n                }\r\n            }\r\n            for (ProviderGroup group : current) {\r\n                String groupName = group.getName();\r\n                if (!group.isEmpty()) {\r\n                    ProviderGroup oldGroup = tmpProviderInfoList.get(groupName);\r\n                    if (oldGroup != null) {\r\n                        oldGroup.addAll(group.getProviderInfos());\r\n                    } else {\r\n                        tmpProviderInfoList.put(groupName, group);\r\n                    }\r\n                }\r\n            }\r\n        } catch (SofaRpcRuntimeException e) {\r\n            throw e;\r\n        } catch (Throwable e) {\r\n            String appName = consumerConfig.getAppName();\r\n            if (LOGGER.isWarnEnabled(appName)) {\r\n                LOGGER.warnWithApp(appName, \"Catch exception when subscribe from registry: \" + registryConfig.getId() + \", but you can ignore if it's called by JVM shutdown hook\", e);\r\n            }\r\n        }\r\n    }\r\n    if (respondRegistries != null) {\r\n        try {\r\n            respondRegistries.await(addressWaitTime, TimeUnit.MILLISECONDS);\r\n        } catch (Exception ignore) {\r\n        }\r\n    }\r\n    return new ArrayList<ProviderGroup>(tmpProviderInfoList.values());\r\n}"
}, {
	"Path": "com.klinker.android.twitter.utils.ActivityUtils.refreshActivity",
	"Comment": "refresh the new followers, mentions, number of favorites, and retweeters",
	"Method": "boolean refreshActivity(){\r\n    Thread killer = new Thread(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            try {\r\n                Thread.sleep(45000);\r\n                Log.v(\"talon_activity\", \"activity refresh killed. What is the issue here...?\");\r\n                android.os.Process.killProcess(android.os.Process.myPid());\r\n            } catch (InterruptedException e) {\r\n                Log.v(\"talon_activity\", \"activity killer interrupted. This is good.\");\r\n            }\r\n        }\r\n    });\r\n    killer.start();\r\n    boolean newActivity = false;\r\n    Twitter twitter;\r\n    if (!useSecondAccount) {\r\n        twitter = Utils.getTwitter(context, settings);\r\n    } else {\r\n        twitter = Utils.getSecondTwitter(context);\r\n    }\r\n    if (getMentions(twitter)) {\r\n        newActivity = true;\r\n    }\r\n    if (getQuotes(twitter)) {\r\n        newActivity = true;\r\n    }\r\n    if (getFollowers(twitter)) {\r\n        newActivity = true;\r\n    }\r\n    List<Status> myTweets = getMyTweets(twitter);\r\n    if (myTweets != null) {\r\n        if (getRetweets(twitter, myTweets)) {\r\n            newActivity = true;\r\n        }\r\n        if (getFavorites(myTweets)) {\r\n            newActivity = true;\r\n        }\r\n    }\r\n    killer.interrupt();\r\n    return newActivity;\r\n}"
}, {
	"Path": "com.klinker.android.twitter.utils.ActivityUtils.refreshActivity",
	"Comment": "refresh the new followers, mentions, number of favorites, and retweeters",
	"Method": "boolean refreshActivity(){\r\n    try {\r\n        Thread.sleep(45000);\r\n        Log.v(\"talon_activity\", \"activity refresh killed. What is the issue here...?\");\r\n        android.os.Process.killProcess(android.os.Process.myPid());\r\n    } catch (InterruptedException e) {\r\n        Log.v(\"talon_activity\", \"activity killer interrupted. This is good.\");\r\n    }\r\n}"
}, {
	"Path": "org.springsource.loaded.test.FileSystemWatcherTests.dirs",
	"Comment": "create a folder, watch it then put a couple of files in and check they are detected",
	"Method": "void dirs(){\r\n    TestFileChangeListener listener = new TestFileChangeListener();\r\n    File dir = getTempDir();\r\n    FileSystemWatcher watcher = new FileSystemWatcher(listener, -1, \"test\");\r\n    watcher.register(dir);\r\n    pause(1000);\r\n    create(dir, \"abc.txt\");\r\n    pause(1100);\r\n    create(dir, \"abcd.txt\");\r\n    pause(1100);\r\n    watcher.shutdown();\r\n    Assert.assertTrue(listener.changesDetected.contains(\"abc.txt\"));\r\n    Assert.assertTrue(listener.changesDetected.contains(\"abcd.txt\"));\r\n}"
}, {
	"Path": "com.querydsl.sql.dml.AbstractSQLInsertClause.executeWithKey",
	"Comment": "execute the clause and return the generated key cast to the given type.if no rows were created, null is returned, otherwise the key of the firstrow is returned.",
	"Method": "T executeWithKey(Path<T> path,T executeWithKey,Class<T> type,T executeWithKey,Class<T> type,Path<T> path){\r\n    ResultSet rs = null;\r\n    try {\r\n        rs = executeWithKeys();\r\n        if (rs.next()) {\r\n            return configuration.get(rs, path, 1, type);\r\n        } else {\r\n            return null;\r\n        }\r\n    } catch (SQLException e) {\r\n        throw configuration.translate(e);\r\n    } finally {\r\n        if (rs != null) {\r\n            close(rs);\r\n        }\r\n        reset();\r\n    }\r\n}"
}, {
	"Path": "org.springsource.loaded.test.ReloadableTypeTests.serialization2",
	"Comment": "unlike the first test, this one will reload the class in between serialize and deserialize",
	"Method": "void serialization2(){\r\n    TypeRegistry tr = getTypeRegistry(\"remote..*\");\r\n    ReloadableType person = tr.addType(\"remote.Person\", loadBytesForClass(\"remote.Person\"));\r\n    ReloadableType runner = tr.addType(\"remote.Serialize\", loadBytesForClass(\"remote.Serialize\"));\r\n    Class<?> clazz = runner.getClazz();\r\n    Object instance = clazz.newInstance();\r\n    Result r = null;\r\n    r = runOnInstance(clazz, instance, \"writePerson\");\r\n    assertStdoutContains(\"Person stored ok\", r);\r\n    r = runOnInstance(clazz, instance, \"readPerson\");\r\n    assertContains(\"Person read ok\", r.stdout);\r\n    r = runOnInstance(clazz, instance, \"writePerson\");\r\n    assertStdoutContains(\"Person stored ok\", r);\r\n    person.loadNewVersion(\"2\", retrieveRename(\"remote.Person\", \"remote.Person2\"));\r\n    r = runOnInstance(clazz, instance, \"readPerson\");\r\n    assertContains(\"Person read ok\", r.stdout);\r\n}"
}, {
	"Path": "org.springsource.loaded.ReloadableType.getMethod",
	"Comment": "todo introduce a cache for people trolling through the methods array? same for fields?",
	"Method": "MethodMember getMethod(String name,String descriptor,MethodMember getMethod,String nameAndDescriptor){\r\n    for (MethodMember method : typedescriptor.getMethods()) {\r\n        if (nameAndDescriptor.startsWith(method.getName()) && nameAndDescriptor.endsWith(method.getDescriptor())) {\r\n            return method;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.springsource.loaded.Utils.toClass",
	"Comment": "convert an asm type into a corresponding class object, requires a reference to a classloader to be able to\tconvert classnames to class objects.",
	"Method": "Class<?> toClass(Type type,ClassLoader classLoader,Class<?> toClass,ReloadableType rtype){\r\n    try {\r\n        return toClass(Type.getObjectType(rtype.getSlashedName()), rtype.typeRegistry.getClassLoader());\r\n    } catch (ClassNotFoundException e) {\r\n        throw new IllegalStateException(e);\r\n    }\r\n}"
}, {
	"Path": "org.springsource.loaded.test.ReloadableTypeTests.serialization3",
	"Comment": "variant of the second test but using serialversionuid and adding methods to the class on reload",
	"Method": "void serialization3(){\r\n    TypeRegistry tr = getTypeRegistry(\"remote..*\");\r\n    ReloadableType person = tr.addType(\"remote.PersonB\", loadBytesForClass(\"remote.PersonB\"));\r\n    ReloadableType runner = tr.addType(\"remote.SerializeB\", loadBytesForClass(\"remote.SerializeB\"));\r\n    Class<?> clazz = runner.getClazz();\r\n    Object instance = clazz.newInstance();\r\n    Result r = null;\r\n    r = runOnInstance(runner.getClazz(), instance, \"writePerson\");\r\n    assertStdoutContains(\"Person stored ok\", r);\r\n    r = runOnInstance(runner.getClazz(), instance, \"readPerson\");\r\n    assertContains(\"Person read ok\", r.stdout);\r\n    r = runOnInstance(runner.getClazz(), instance, \"writePerson\");\r\n    assertStdoutContains(\"Person stored ok\", r);\r\n    person.loadNewVersion(\"2\", retrieveRename(\"remote.PersonB\", \"remote.PersonB2\"));\r\n    r = runOnInstance(runner.getClazz(), instance, \"readPerson\");\r\n    assertContains(\"Person read ok\", r.stdout);\r\n    r = runOnInstance(clazz, instance, \"printInitials\");\r\n    assertContains(\"Person read ok\\nWS\", r.stdout);\r\n}"
}, {
	"Path": "org.springsource.loaded.test.ReloadableTypeTests.serialization4",
	"Comment": "there is a test that will work in the springloadedtestsinseparatejvm",
	"Method": "void serialization4(){\r\n    TypeRegistry tr = getTypeRegistry(\"remote..*\");\r\n    tr.addType(\"remote.Person\", loadBytesForClass(\"remote.Person\"));\r\n    ReloadableType runner = tr.addType(\"remote.Serialize\", loadBytesForClass(\"remote.Serialize\"));\r\n    Class<?> clazz = runner.getClazz();\r\n    Object instance = clazz.newInstance();\r\n    Result r = runOnInstance(clazz, instance, \"checkPredeserializedData\");\r\n    assertStdoutContains(\"Person stored ok\", r);\r\n}"
}, {
	"Path": "com.querydsl.sql.SQLExpressions.rank",
	"Comment": "as an aggregate function, rank calculates the rank of a hypothetical row identified by thearguments of the function with respect to a given sort specification. the arguments of thefunction must all evaluate to constant expressions within each aggregate group, because theyidentify a single row within each group. the constant argument expressions and the expressionsin the order by clause of the aggregate match by position. therefore, the number of argumentsmust be the same and their types must be compatible.",
	"Method": "WindowOver<Long> rank(WithinGroup<Long> rank,Object args,WithinGroup<Long> rank,Expression<?> args){\r\n    return new WithinGroup<Long>(Long.class, SQLOps.RANK2, args);\r\n}"
}, {
	"Path": "com.querydsl.sql.ColumnMetadata.getName",
	"Comment": "extract the column name for the given path, returns the path name, if no columnmetadata is attached",
	"Method": "String getName(Path<?> path,String getName){\r\n    return name;\r\n}"
}, {
	"Path": "org.testcontainers.containers.JdbcDatabaseContainer.runInitScriptIfRequired",
	"Comment": "load init script content and apply it to the database if initscriptpath is set",
	"Method": "void runInitScriptIfRequired(){\r\n    if (initScriptPath != null) {\r\n        ScriptUtils.runInitScript(getDatabaseDelegate(), initScriptPath);\r\n    }\r\n}"
}, {
	"Path": "io.rx_cache2.internal.cache.memory.apache.AbstractReferenceMap.isEqualKey",
	"Comment": "compares two keys, in internal converted form, to see if they are equal.this implementation converts the key from the entry to a real referencebefore comparison.",
	"Method": "boolean isEqualKey(Object key1,Object key2){\r\n    key2 = keyType == ReferenceStrength.HARD ? key2 : ((Reference<K>) key2).get();\r\n    return key1 == key2 || key1.equals(key2);\r\n}"
}, {
	"Path": "org.spockframework.mock.constraint.PositionalArgumentListConstraint.hasExpandableVarArgs",
	"Comment": "tells if the given method call has expandable varargs. note that groovysupports vararg syntax for all methods whose last parameter is of array type.",
	"Method": "boolean hasExpandableVarArgs(IMockMethod method,List<Object> args){\r\n    List<Class<?>> paramTypes = method.getParameterTypes();\r\n    return !paramTypes.isEmpty() && CollectionUtil.getLastElement(paramTypes).isArray() && CollectionUtil.getLastElement(args) != null;\r\n}"
}, {
	"Path": "com.querydsl.sql.SQLExpressions.stddevPop",
	"Comment": "returns the population standard deviation and returns the square root of the population variance.",
	"Method": "WindowOver<T> stddevPop(Expression<T> expr){\r\n    return new WindowOver<T>(expr.getType(), SQLOps.STDDEVPOP, expr);\r\n}"
}, {
	"Path": "io.rx_cache2.ActionsList.addAll",
	"Comment": "func2 will be called for every iteration until its condition returns true. when true, theelements are added to the cache at the position of the current iteration.",
	"Method": "ActionsList<T> addAll(Func2 func2,List<T> elements){\r\n    cache = cache.map(new Function<List<T>, List<T>>() {\r\n        @Override\r\n        public List<T> apply(List<T> items) throws Exception {\r\n            int count = items.size();\r\n            for (int position = 0; position <= count; position++) {\r\n                if (func2.call(position, count)) {\r\n                    items.addAll(position, elements);\r\n                    break;\r\n                }\r\n            }\r\n            return items;\r\n        }\r\n    });\r\n    return this;\r\n}"
}, {
	"Path": "io.rx_cache2.ActionsList.addAll",
	"Comment": "func2 will be called for every iteration until its condition returns true. when true, theelements are added to the cache at the position of the current iteration.",
	"Method": "ActionsList<T> addAll(Func2 func2,List<T> elements){\r\n    int count = items.size();\r\n    for (int position = 0; position <= count; position++) {\r\n        if (func2.call(position, count)) {\r\n            items.addAll(position, elements);\r\n            break;\r\n        }\r\n    }\r\n    return items;\r\n}"
}, {
	"Path": "com.simplecity.amp_library.utils.DialogUtils.showUpgradeNagDialog",
	"Comment": "displays the popup dialog recommending the user try the paid version",
	"Method": "void showUpgradeNagDialog(Context context,MaterialDialog.SingleButtonCallback listener){\r\n    if (!ShuttleUtils.isUpgraded() && SettingsManager.getInstance().getLaunchCount() > 15 && !SettingsManager.getInstance().getNagMessageRead()) {\r\n        MaterialDialog.Builder builder = getBuilder(context).title(context.getResources().getString(R.string.get_pro_title)).content(context.getResources().getString(R.string.get_pro_message)).positiveText(R.string.btn_upgrade).onPositive(listener).negativeText(R.string.get_pro_button_no);\r\n        builder.show();\r\n        SettingsManager.getInstance().setNagMessageRead();\r\n        AnalyticsManager.logUpgrade(AnalyticsManager.UpgradeType.NAG);\r\n    }\r\n}"
}, {
	"Path": "org.springsource.loaded.test.ReloadableTypeTests.callIt",
	"Comment": "check calling it, reloading it and calling the new version.",
	"Method": "void callIt(){\r\n    TypeRegistry typeRegistry = getTypeRegistry(\"basic.Basic\");\r\n    byte[] sc = loadBytesForClass(\"basic.Basic\");\r\n    ReloadableType rtype = typeRegistry.addType(\"basic.Basic\", sc);\r\n    Class<?> simpleClass = rtype.getClazz();\r\n    Result r = runUnguarded(simpleClass, \"foo\");\r\n    r = runUnguarded(simpleClass, \"getValue\");\r\n    assertEquals(5, r.returnValue);\r\n    rtype.loadNewVersion(\"002\", retrieveRename(\"basic.Basic\", \"basic.Basic002\"));\r\n    r = runUnguarded(simpleClass, \"getValue\");\r\n    assertEquals(7, r.returnValue);\r\n}"
}, {
	"Path": "com.simplecity.amp_library.ui.views.BreadcrumbView.init",
	"Comment": "initialises the view. loads all necessaryinformation and creates an appropriate layout for the view",
	"Method": "void init(){\r\n    this.mBreadcrumbListeners = Collections.synchronizedList(new ArrayList<BreadcrumbListener>());\r\n    addView(inflate(getContext(), R.layout.breadcrumb_view, null));\r\n    this.mScrollView = findViewById(R.id.breadcrumb_scrollview);\r\n    this.mBreadcrumbBar = findViewById(R.id.breadcrumb);\r\n}"
}, {
	"Path": "org.testcontainers.jdbc.JDBCDriverTest.performSimpleTestWithCharacterSet",
	"Comment": "this method intentionally verifies encoding twice to ensure that the query string parameters are used whenconnections are created from cached containers.",
	"Method": "void performSimpleTestWithCharacterSet(String jdbcUrl){\r\n    HikariDataSource datasource1 = verifyCharacterSet(jdbcUrl);\r\n    HikariDataSource datasource2 = verifyCharacterSet(jdbcUrl);\r\n    datasource1.close();\r\n    datasource2.close();\r\n}"
}, {
	"Path": "reflection.FieldInvoker.setAndGetFieldWithAccess",
	"Comment": "sets and gets a field in so we can see if the value was actually set.",
	"Method": "String setAndGetFieldWithAccess(Class<?> targetClass,String whichField,boolean setAccess){\r\n    Object targetInstance = targetClass.newInstance();\r\n    Field field = targetClass.getDeclaredField(whichField);\r\n    if (setAccess) {\r\n        field.setAccessible(true);\r\n    }\r\n    String orgVal = (String) field.get(targetInstance);\r\n    field.set(targetInstance, orgVal + \"<BANG>\");\r\n    return (String) field.get(targetInstance);\r\n}"
}, {
	"Path": "org.springsource.loaded.NameRegistry.reset",
	"Comment": "typically used by tests to ensure it looks like a fresh nameregistry is being used.",
	"Method": "void reset(){\r\n    nextTypeId = 0;\r\n    size = 10;\r\n    allocatedIds = new String[size];\r\n}"
}, {
	"Path": "org.testcontainers.DockerClientFactory.checkAndPullImage",
	"Comment": "check whether the image is available locally and pull it otherwise",
	"Method": "void checkAndPullImage(DockerClient client,String image){\r\n    List<Image> images = client.listImagesCmd().withImageNameFilter(image).exec();\r\n    if (images.isEmpty()) {\r\n        client.pullImageCmd(image).exec(new PullImageResultCallback()).awaitSuccess();\r\n    }\r\n}"
}, {
	"Path": "com.r0adkll.slidr.model.SlidrConfig.getPrimaryColor",
	"Comment": "get the primary color that the slider will interpolate. that is this color is the colorof the status bar of the activity you are returning to",
	"Method": "int getPrimaryColor(){\r\n    return colorPrimary;\r\n}"
}, {
	"Path": "reflection.AdHocClassInvoker.callMethodWithAccess",
	"Comment": "calls private method in reloadable class, can override access constraints if requested to do so.",
	"Method": "String callMethodWithAccess(String whichMethod,boolean setAccess){\r\n    Method theMethod = ClassTarget.class.getDeclaredMethod(whichMethod);\r\n    if (setAccess) {\r\n        theMethod.setAccessible(true);\r\n    }\r\n    return (String) theMethod.invoke(t);\r\n}"
}, {
	"Path": "com.afollestad.aesthetic.Util.isColorLight",
	"Comment": "optional convenience method, this can be called when we have information about the background color and want to consider it",
	"Method": "boolean isColorLight(int color,boolean isColorLight,int color,int bgColor){\r\n    if (Color.alpha(color) < 128) {\r\n        return isColorLight(bgColor);\r\n    }\r\n    return isColorLight(color);\r\n}"
}, {
	"Path": "org.unitils.core.dbsupport.H2DbSupport.disableCheckAndUniqueConstraints",
	"Comment": "disables all check and unique constraints on all tables in the schema",
	"Method": "void disableCheckAndUniqueConstraints(){\r\n    Connection connection = null;\r\n    Statement queryStatement = null;\r\n    Statement alterStatement = null;\r\n    ResultSet resultSet = null;\r\n    try {\r\n        connection = getSQLHandler().getDataSource().getConnection();\r\n        queryStatement = connection.createStatement();\r\n        alterStatement = connection.createStatement();\r\n        resultSet = queryStatement.executeQuery(\"select TABLE_NAME, \" + \"CONSTRAINT_NAME from INFORMATION_SCHEMA.CONSTRAINTS where \" + \"CONSTRAINT_TYPE IN ('CHECK', 'UNIQUE') AND CONSTRAINT_SCHEMA \" + \"= '\" + getSchemaName() + \"'\");\r\n        while (resultSet.next()) {\r\n            String tableName = resultSet.getString(\"TABLE_NAME\");\r\n            String constraintName = resultSet.getString(\"CONSTRAINT_NAME\");\r\n            alterStatement.executeUpdate(\"alter table \" + qualified(tableName) + \" drop constraint \" + quoted(constraintName));\r\n        }\r\n    } catch (Exception e) {\r\n        throw new UnitilsException(\"Error while disabling check and unique \" + \"constraints on schema \" + getSchemaName(), e);\r\n    } finally {\r\n        closeQuietly(queryStatement);\r\n        closeQuietly(connection, alterStatement, resultSet);\r\n    }\r\n}"
}, {
	"Path": "com.querydsl.sql.postgresql.AbstractPostgreSQLQuery.forShare",
	"Comment": "for share causes the rows retrieved by the select statement to be locked as though for update.",
	"Method": "C forShare(){\r\n    return super.forShare();\r\n}"
}, {
	"Path": "com.querydsl.spatial.jts.JTSSurfaceExpression.centroid",
	"Comment": "the mathematical centroid for this surface as a point. the result is not guaranteed tobe on this surface.",
	"Method": "JTSPointExpression<Point> centroid(){\r\n    if (centroid == null) {\r\n        centroid = JTSGeometryExpressions.pointOperation(SpatialOps.CENTROID, mixin);\r\n    }\r\n    return centroid;\r\n}"
}, {
	"Path": "reflection.fields.FieldSetAccessTarget002.getFieldWithAccess",
	"Comment": "gets a field in class, can override access constraints if requested to do so.",
	"Method": "String getFieldWithAccess(Class<?> targetClass,String whichField,boolean setAccess){\r\n    Object targetInstance = targetClass.newInstance();\r\n    Field field = targetClass.getDeclaredField(whichField);\r\n    if (setAccess) {\r\n        field.setAccessible(true);\r\n    }\r\n    return (String) field.get(targetInstance);\r\n}"
}, {
	"Path": "com.simplecity.amp_library.playback.QueueManager.removeQueueItem",
	"Comment": "removes the first instance of the song the playlist & shufflelist.",
	"Method": "void removeQueueItem(QueueItem queueItem,UnsafeAction stop,UnsafeAction moveToNextTrack){\r\n    QueueItem currentQueueItem = getCurrentQueueItem();\r\n    playlist.remove(queueItem);\r\n    shuffleList.remove(queueItem);\r\n    if (queueItem == currentQueueItem) {\r\n        onCurrentSongRemoved(stop, moveToNextTrack);\r\n    } else {\r\n        queuePosition = getCurrentPlaylist().indexOf(currentQueueItem);\r\n    }\r\n    QueueItemKt.updateOccurrence(getCurrentPlaylist());\r\n    notifyQueueChanged();\r\n}"
}, {
	"Path": "org.spockframework.gentyref.GenericTypeReflector.getArrayComponentType",
	"Comment": "if type is an array type, returns the type of the component of the array.\totherwise, returns null.",
	"Method": "Type getArrayComponentType(Type type){\r\n    if (type instanceof Class) {\r\n        Class<?> clazz = (Class<?>) type;\r\n        return clazz.getComponentType();\r\n    } else if (type instanceof GenericArrayType) {\r\n        GenericArrayType aType = (GenericArrayType) type;\r\n        return aType.getGenericComponentType();\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.springsource.loaded.testgen.GenerativeSpringLoadedTest.toStringList",
	"Comment": "converts a list of any type of object into a list of strings by calling the tostring method on each object.",
	"Method": "List<String> toStringList(List<?> list){\r\n    List<String> result = new ArrayList<String>();\r\n    for (Object obj : list) {\r\n        result.add(\"\" + obj);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.querydsl.sql.oracle.AbstractOracleQuery.connectBy",
	"Comment": "connect by specifies the relationship between parent rows and child rows of the hierarchy.",
	"Method": "C connectBy(Predicate cond){\r\n    return addFlag(Position.BEFORE_ORDER, CONNECT_BY, cond);\r\n}"
}, {
	"Path": "android.support.design.widget.CustomCollapsingToolbarLayout.getScrimVisibleHeightTrigger",
	"Comment": "returns the amount of visible height in pixels used to define when to trigger a scrimvisibility change.",
	"Method": "int getScrimVisibleHeightTrigger(){\r\n    if (mScrimVisibleHeightTrigger >= 0) {\r\n        return mScrimVisibleHeightTrigger;\r\n    }\r\n    final int insetTop = mLastInsets != null ? mLastInsets.getSystemWindowInsetTop() : 0;\r\n    final int minHeight = ViewCompat.getMinimumHeight(this);\r\n    if (minHeight > 0) {\r\n        return Math.min((minHeight * 2) + insetTop, getHeight());\r\n    }\r\n    return getHeight() / 3;\r\n}"
}, {
	"Path": "org.springsource.loaded.TypeRegistry.getTypeIdFor",
	"Comment": "lookup the type id for a string. first checks those allocated but not yet registered, then those that are already\tregistered. if not found then a new one is allocated and recorded.",
	"Method": "int getTypeIdFor(String slashname,boolean allocateIfNotFound){\r\n    if (allocateIfNotFound) {\r\n        return NameRegistry.getIdOrAllocateFor(slashname);\r\n    } else {\r\n        return NameRegistry.getIdFor(slashname);\r\n    }\r\n}"
}, {
	"Path": "org.springsource.loaded.test.MethodInvokerRewriterTests.superCallsMethodDeletion",
	"Comment": "call an existing super method through a super call then remove it, check an nsme occurs.",
	"Method": "void superCallsMethodDeletion(){\r\n    TypeRegistry tr = getTypeRegistry(\"invokespecial..*\");\r\n    ReloadableType p = loadType(tr, \"invokespecial.P\");\r\n    ReloadableType q = loadType(tr, \"invokespecial.Q\");\r\n    Method method = q.getClazz().getMethod(\"run\");\r\n    Object object = q.getClazz().newInstance();\r\n    String string = method.invoke(object).toString();\r\n    assertEquals(\"1\", string);\r\n    p.loadNewVersion(\"002\", retrieveRename(\"invokespecial.P\", \"invokespecial.P002\"));\r\n    try {\r\n        string = method.invoke(object).toString();\r\n        fail();\r\n    } catch (InvocationTargetException ite) {\r\n        assertEquals(\"java.lang.NoSuchMethodError\", ite.getCause().getClass().getName());\r\n        assertEquals(\"invokespecial.P.foo()I\", ite.getCause().getMessage());\r\n    }\r\n}"
}, {
	"Path": "com.klinker.android.twitter.views.swipe_refresh_layout.FullScreenSwipeRefreshLayout.setRefreshing",
	"Comment": "notify the widget that refresh state has changed. do not call this whenrefresh is triggered by a swipe gesture.",
	"Method": "void setRefreshing(boolean refreshing){\r\n    if (mRefreshing != refreshing) {\r\n        ensureTarget();\r\n        mCurrPercentage = 0;\r\n        mRefreshing = refreshing;\r\n        if (mRefreshing) {\r\n            mProgressBar.start();\r\n        } else {\r\n            mProgressBar.stop();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.querydsl.sql.SQLExpressions.varPop",
	"Comment": "returns the population variance of a set of numbers after discarding the nulls in this set.",
	"Method": "WindowOver<T> varPop(Expression<T> expr){\r\n    return new WindowOver<T>(expr.getType(), SQLOps.VARPOP, expr);\r\n}"
}, {
	"Path": "spock.util.environment.OperatingSystem.isOther",
	"Comment": "tells whether the operating system family is anything other than those listed above.",
	"Method": "boolean isOther(){\r\n    return family == Family.OTHER;\r\n}"
}, {
	"Path": "org.springsource.loaded.test.InnerClassesTests.reloadPrivateVisInner",
	"Comment": "similar to the first test but this is just using a private visibility inner class. private inner class becomes\tdefault visibility when compiled",
	"Method": "void reloadPrivateVisInner(){\r\n    String tclass = \"inners.Three\";\r\n    TypeRegistry typeRegistry = getTypeRegistry(\"inners..*\");\r\n    ReloadableType rtype = typeRegistry.addType(tclass, loadBytesForClass(tclass));\r\n    runUnguarded(rtype.getClazz(), \"runner\");\r\n    typeRegistry.addType(\"inners.Three$Inner\", retrieveRename(\"inners.Three$Inner\", \"inners.Three2$Inner\", \"inners.Three2:inners.Three\"));\r\n    rtype.loadNewVersion(\"2\", retrieveRename(tclass, tclass + \"2\", \"inners.Three2$Inner:inners.Three$Inner\", \"inners.Three2:inners.Three\"));\r\n    runUnguarded(rtype.getClazz(), \"runner\");\r\n}"
}, {
	"Path": "com.alipay.sofa.rpc.client.ProviderHelper.compareGroups",
	"Comment": "compare two provider group list, return add list and remove list",
	"Method": "void compareGroups(List<ProviderGroup> oldGroups,List<ProviderGroup> newGroups,List<ProviderInfo> add,List<ProviderInfo> remove){\r\n    if (CommonUtils.isEmpty(oldGroups)) {\r\n        if (CommonUtils.isNotEmpty(newGroups)) {\r\n            for (ProviderGroup newGroup : newGroups) {\r\n                add.addAll(newGroup.getProviderInfos());\r\n            }\r\n        }\r\n    } else {\r\n        if (CommonUtils.isEmpty(newGroups)) {\r\n            for (ProviderGroup oldGroup : oldGroups) {\r\n                remove.addAll(oldGroup.getProviderInfos());\r\n            }\r\n        } else {\r\n            if (CommonUtils.isNotEmpty(oldGroups)) {\r\n                Map<String, List<ProviderInfo>> oldMap = convertToMap(oldGroups);\r\n                Map<String, List<ProviderInfo>> mapTmp = convertToMap(newGroups);\r\n                for (Map.Entry<String, List<ProviderInfo>> oldEntry : oldMap.entrySet()) {\r\n                    String key = oldEntry.getKey();\r\n                    List<ProviderInfo> oldList = oldEntry.getValue();\r\n                    if (mapTmp.containsKey(key)) {\r\n                        final List<ProviderInfo> newList = mapTmp.remove(key);\r\n                        compareProviders(oldList, newList, add, remove);\r\n                        mapTmp.remove(key);\r\n                    } else {\r\n                        remove.addAll(oldList);\r\n                    }\r\n                }\r\n                for (Map.Entry<String, List<ProviderInfo>> entry : mapTmp.entrySet()) {\r\n                    add.addAll(entry.getValue());\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.rx_cache2.internal.cache.memory.apache.AbstractHashedMap.calculateThreshold",
	"Comment": "calculates the new threshold of the map, where it will be resized.this implementation uses the load factor.",
	"Method": "int calculateThreshold(int newCapacity,float factor){\r\n    return (int) (newCapacity * factor);\r\n}"
}, {
	"Path": "org.springsource.loaded.test.TypeRewriterTests.constructorChangingButNotSuper",
	"Comment": "testing the type delta which records what has changed on a reload. here we are reloading a type twice. in the\tfirst reload nothing has changed. in the second reload the code in the constructor has changed, but the\tinvokespecial call to super has not changed.",
	"Method": "void constructorChangingButNotSuper(){\r\n    String t = \"ctors.V\";\r\n    registry = getTypeRegistry(t);\r\n    ReloadableType type = loadType(registry, t);\r\n    result = runConstructor(type.getClazz(), \"\");\r\n    assertEquals(\"Hello\", result.stdout);\r\n    type.loadNewVersion(\"2\", retrieveRename(t, t + \"2\"));\r\n    result = runConstructor(type.getClazz(), \"\");\r\n    assertEquals(\"Hello\", result.stdout);\r\n    TypeDelta td = type.getLiveVersion().getTypeDelta();\r\n    assertNotNull(td);\r\n    assertFalse(td.hasAnythingChanged());\r\n    assertNull(td.getChangedMethods());\r\n    type.loadNewVersion(\"3\", retrieveRename(t, t + \"3\"));\r\n    result = runConstructor(type.getClazz(), \"\");\r\n    assertEquals(\"Goodbye\", result.stdout);\r\n    td = type.getLiveVersion().getTypeDelta();\r\n    assertNotNull(td);\r\n    assertTrue(td.hasAnythingChanged());\r\n    Map<String, MethodDelta> changedMethods = td.getChangedMethods();\r\n    assertNotNull(changedMethods);\r\n    assertEquals(1, changedMethods.size());\r\n    assertEquals(\"MethodDelta[method:<init>()V]\", changedMethods.get(\"<init>()V\").toString());\r\n    MethodDelta md = changedMethods.get(\"<init>()V\");\r\n    assertTrue(md.hasAnyChanges());\r\n    assertFalse(md.hasInvokeSpecialChanged());\r\n    assertTrue(md.hasCodeChanged());\r\n}"
}, {
	"Path": "org.springsource.loaded.agent.SpringPlugin.clearMappingRegistry",
	"Comment": "the inithandlermethods below we will get an error about already existing mappings",
	"Method": "void clearMappingRegistry(Object o,Class<?> clazz_AbstractHandlerMethodMapping){\r\n    if (debug) {\r\n        System.out.println(\"SPRING_PLUGIN: clearing out mapping registry...\");\r\n    }\r\n    Object mappingRegistryInstance = null;\r\n    try {\r\n        Field field_mappingRegistry = clazz_AbstractHandlerMethodMapping.getDeclaredField(\"mappingRegistry\");\r\n        field_mappingRegistry.setAccessible(true);\r\n        mappingRegistryInstance = field_mappingRegistry.get(o);\r\n    } catch (NoSuchFieldException e) {\r\n        if (debug) {\r\n            System.out.println(\"SPRING_PLUGIN: Unable to get mappingRegistry field on AbstractHandlerMethodMapping\");\r\n        }\r\n    } catch (IllegalAccessException e) {\r\n        if (GlobalConfiguration.debugplugins || debug) {\r\n            System.out.println(\"SPRING_PLUGIN: Problem accessing mappingRegistry field on AbstractHandlerMethodMapping: \");\r\n            e.printStackTrace(System.out);\r\n        }\r\n    }\r\n    if (mappingRegistryInstance == null) {\r\n        return;\r\n    }\r\n    Class mappingRegistryClass = mappingRegistryInstance.getClass();\r\n    clearMapField(mappingRegistryClass, mappingRegistryInstance, \"registry\");\r\n    clearMapField(mappingRegistryClass, mappingRegistryInstance, \"mappingLookup\");\r\n    clearMapField(mappingRegistryClass, mappingRegistryInstance, \"urlLookup\");\r\n    clearMapField(mappingRegistryClass, mappingRegistryInstance, \"nameLookup\");\r\n    clearMapField(mappingRegistryClass, mappingRegistryInstance, \"corsLookup\");\r\n    if (debug) {\r\n        System.out.println(\"SPRING_PLUGIN: ... cleared out the mapping registry contents\");\r\n    }\r\n}"
}, {
	"Path": "org.testcontainers.images.builder.Transferable.transferTo",
	"Comment": "transfer content of this transferable to the output stream. must not close the stream.",
	"Method": "void transferTo(TarArchiveOutputStream tarArchiveOutputStream,String destination){\r\n    TarArchiveEntry tarEntry = new TarArchiveEntry(destination);\r\n    tarEntry.setSize(getSize());\r\n    tarEntry.setMode(getFileMode());\r\n    try {\r\n        tarArchiveOutputStream.putArchiveEntry(tarEntry);\r\n        IOUtils.write(getBytes(), tarArchiveOutputStream);\r\n        tarArchiveOutputStream.closeArchiveEntry();\r\n    } catch (IOException e) {\r\n        throw new RuntimeException(\"Can't transfer \" + getDescription(), e);\r\n    }\r\n}"
}, {
	"Path": "org.spockframework.util.inspector.AstInspector.getConstructor",
	"Comment": "returns the first constructor found in the class with the specified simple name.",
	"Method": "ConstructorNode getConstructor(String className){\r\n    return getNode(constructors, className);\r\n}"
}, {
	"Path": "io.rx_cache2.ActionsList.evict",
	"Comment": "func3 will be called for every iteration until its condition returns true. when true, theelement of the current iteration is evicted from the cache.",
	"Method": "ActionsList<T> evict(Func1Element<T> func1Element,ActionsList<T> evict,Func3<T> func3){\r\n    cache = cache.map(new Function<List<T>, List<T>>() {\r\n        @Override\r\n        public List<T> apply(List<T> elements) throws Exception {\r\n            int count = elements.size();\r\n            for (int position = 0; position < count; position++) {\r\n                if (func3.call(position, count, elements.get(position))) {\r\n                    elements.remove(position);\r\n                    break;\r\n                }\r\n            }\r\n            return elements;\r\n        }\r\n    });\r\n    return this;\r\n}"
}, {
	"Path": "io.rx_cache2.ActionsList.evict",
	"Comment": "func3 will be called for every iteration until its condition returns true. when true, theelement of the current iteration is evicted from the cache.",
	"Method": "ActionsList<T> evict(Func1Element<T> func1Element,ActionsList<T> evict,Func3<T> func3){\r\n    int count = elements.size();\r\n    for (int position = 0; position < count; position++) {\r\n        if (func3.call(position, count, elements.get(position))) {\r\n            elements.remove(position);\r\n            break;\r\n        }\r\n    }\r\n    return elements;\r\n}"
}, {
	"Path": "com.querydsl.sql.SQLExpressions.select",
	"Comment": "create a new detached sqlquery instance with the given projection",
	"Method": "SQLQuery<T> select(Expression<T> expr,SQLQuery<Tuple> select,Expression<?> exprs){\r\n    return new SQLQuery<Void>().select(exprs);\r\n}"
}, {
	"Path": "org.springsource.loaded.test.TestInfrastructureTests.loading",
	"Comment": "size changed here from 331 to 394 when switched to aspectj project for testcode!",
	"Method": "void loading(){\r\n    TestClassLoader tcl = new TestClassLoader(toURLs(TestDataPath), this.getClass().getClassLoader());\r\n    byte[] classdata = Utils.loadDottedClassAsBytes(tcl, \"data.SimpleClass\");\r\n    Assert.assertNotNull(classdata);\r\n    Assert.assertEquals(331, classdata.length);\r\n}"
}, {
	"Path": "com.querydsl.spatial.jts.JTSGeometryExpression.difference",
	"Comment": "returns a geometric object that represents the pointset difference of this geometric object with anothergeometry.",
	"Method": "JTSGeometryExpression<Geometry> difference(Geometry geometry,JTSGeometryExpression<Geometry> difference,Expression<? extends Geometry> geometry){\r\n    return JTSGeometryExpressions.geometryOperation(SpatialOps.DIFFERENCE, mixin, geometry);\r\n}"
}, {
	"Path": "com.querydsl.spatial.GeometryExpression.convexHull",
	"Comment": "returns a geometric object that represents the convex hull of this geometric object.convex hulls, being dependent on straight lines, can be accurately represented in linearinterpolations for any geometry restricted to linear interpolations.",
	"Method": "GeometryExpression<Geometry> convexHull(){\r\n    if (convexHull == null) {\r\n        convexHull = GeometryExpressions.geometryOperation(SpatialOps.CONVEXHULL, mixin);\r\n    }\r\n    return convexHull;\r\n}"
}, {
	"Path": "io.rx_cache2.ActionsList.update",
	"Comment": "func3 will be called for every iteration until its condition returns true. when true, theelement of the current iteration is updated.",
	"Method": "ActionsList<T> update(Func1Element<T> func1Element,Replace<T> replace,ActionsList<T> update,Func3<T> func3,Replace<T> replace){\r\n    cache = cache.map(new Function<List<T>, List<T>>() {\r\n        @Override\r\n        public List<T> apply(List<T> elements) throws Exception {\r\n            int count = elements.size();\r\n            for (int position = 0; position < count; position++) {\r\n                if (func3.call(position, count, elements.get(position))) {\r\n                    elements.set(position, replace.call(elements.get(position)));\r\n                    break;\r\n                }\r\n            }\r\n            return elements;\r\n        }\r\n    });\r\n    return this;\r\n}"
}, {
	"Path": "io.rx_cache2.ActionsList.update",
	"Comment": "func3 will be called for every iteration until its condition returns true. when true, theelement of the current iteration is updated.",
	"Method": "ActionsList<T> update(Func1Element<T> func1Element,Replace<T> replace,ActionsList<T> update,Func3<T> func3,Replace<T> replace){\r\n    int count = elements.size();\r\n    for (int position = 0; position < count; position++) {\r\n        if (func3.call(position, count, elements.get(position))) {\r\n            elements.set(position, replace.call(elements.get(position)));\r\n            break;\r\n        }\r\n    }\r\n    return elements;\r\n}"
}, {
	"Path": "org.testcontainers.containers.wait.strategy.Wait.forHttps",
	"Comment": "convenience method to return a waitstrategy for an https endpoint.",
	"Method": "HttpWaitStrategy forHttps(String path){\r\n    return forHttp(path).usingTls();\r\n}"
}, {
	"Path": "io.rx_cache2.ActionsList.updateIterable",
	"Comment": "func3 will be called for every iteration. when true, the element of the current iteration isupdated.",
	"Method": "ActionsList<T> updateIterable(Func1Element<T> func1Element,Replace<T> replace,ActionsList<T> updateIterable,Func3<T> func3,Replace<T> replace){\r\n    cache = cache.map(new Function<List<T>, List<T>>() {\r\n        @Override\r\n        public List<T> apply(List<T> elements) throws Exception {\r\n            int count = elements.size();\r\n            for (int position = 0; position < count; position++) {\r\n                if (func3.call(position, count, elements.get(position))) {\r\n                    elements.set(position, replace.call(elements.get(position)));\r\n                }\r\n            }\r\n            return elements;\r\n        }\r\n    });\r\n    return this;\r\n}"
}, {
	"Path": "io.rx_cache2.ActionsList.updateIterable",
	"Comment": "func3 will be called for every iteration. when true, the element of the current iteration isupdated.",
	"Method": "ActionsList<T> updateIterable(Func1Element<T> func1Element,Replace<T> replace,ActionsList<T> updateIterable,Func3<T> func3,Replace<T> replace){\r\n    int count = elements.size();\r\n    for (int position = 0; position < count; position++) {\r\n        if (func3.call(position, count, elements.get(position))) {\r\n            elements.set(position, replace.call(elements.get(position)));\r\n        }\r\n    }\r\n    return elements;\r\n}"
}, {
	"Path": "io.rx_cache2.internal.cache.memory.apache.AbstractHashedMap.entryKey",
	"Comment": "gets the key field from a hashentry.used in subclasses that have no visibility of the field.",
	"Method": "K entryKey(HashEntry<K, V> entry){\r\n    return entry.getKey();\r\n}"
}, {
	"Path": "org.springsource.loaded.TypeDescriptor.getByDescriptor",
	"Comment": "check if this descriptor defines a method with the specified name and descriptor. return the method if it is\tfound. modifiers, generic signature and exceptions are ignored in this search.",
	"Method": "MethodMember getByDescriptor(String name,String descriptor){\r\n    for (MethodMember existingMethod : methods) {\r\n        if (existingMethod.getName().equals(name) && existingMethod.getDescriptor().equals(descriptor)) {\r\n            return existingMethod;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.squareup.tape2.QueueFileTest.testFileExpansionDoesntCorruptWrappedElements",
	"Comment": "exercise a bug where wrapped elements were getting corrupted when thequeuefile was forced to expand in size and a portion of the final elementhad been wrapped into space at the beginning of the file.",
	"Method": "void testFileExpansionDoesntCorruptWrappedElements(){\r\n    QueueFile queue = newQueueFile();\r\n    byte[][] values = new byte[5][];\r\n    for (int blockNum = 0; blockNum < values.length; blockNum++) {\r\n        values[blockNum] = new byte[1024];\r\n        for (int i = 0; i < values[blockNum].length; i++) {\r\n            values[blockNum][i] = (byte) (blockNum + 1);\r\n        }\r\n    }\r\n    queue.add(values[0]);\r\n    queue.add(values[1]);\r\n    queue.remove();\r\n    queue.add(values[2]);\r\n    queue.add(values[3]);\r\n    queue.add(values[4]);\r\n    for (int blockNum = 1; blockNum < values.length; blockNum++) {\r\n        byte[] value = queue.peek();\r\n        queue.remove();\r\n        for (int i = 0; i < value.length; i++) {\r\n            assertThat(value[i]).named(\"Block %1$d corrupted at byte index %2$d.\", blockNum + 1, i).isEqualTo((byte) (blockNum + 1));\r\n        }\r\n    }\r\n    queue.close();\r\n}"
}, {
	"Path": "io.rx_cache2.internal.cache.memory.apache.AbstractHashedMap.isEqualKey",
	"Comment": "compares two keys, in internal converted form, to see if they are equal.this implementation uses the equals method and assumes neither key is null.subclasses can override this to match differently.",
	"Method": "boolean isEqualKey(Object key1,Object key2){\r\n    return key1 == key2 || key1.equals(key2);\r\n}"
}, {
	"Path": "cn.finalteam.rxgalleryfinal.RxGalleryFinal.cropMaxBitmapSize",
	"Comment": "setter for max size for both width and height of bitmap that will be decoded from an input uri and used in the view.",
	"Method": "RxGalleryFinal cropMaxBitmapSize(int maxBitmapSize){\r\n    configuration.setMaxBitmapSize(maxBitmapSize);\r\n    return this;\r\n}"
}, {
	"Path": "org.springsource.loaded.TypeRegistry.loadPlugins",
	"Comment": "determine if any plugins are visible from the attached classloader",
	"Method": "void loadPlugins(){\r\n    try {\r\n        Enumeration<URL> pluginResources = classLoader.get().getResources(\"META-INF/services/org.springsource.reloading.agent.Plugins\");\r\n        while (pluginResources.hasMoreElements()) {\r\n            URL pluginResource = pluginResources.nextElement();\r\n            if (GlobalConfiguration.isRuntimeLogging && log.isLoggable(Level.FINEST)) {\r\n                log.finest(\"loadPlugins: TypeRegistry=\" + this.toString() + \": loading plugin list file \" + pluginResource);\r\n            }\r\n            InputStream is = pluginResource.openStream();\r\n            BufferedReader pluginClassNamesReader = new BufferedReader(new InputStreamReader(is));\r\n            try {\r\n                while (true) {\r\n                    String pluginName = pluginClassNamesReader.readLine();\r\n                    if (pluginName == null) {\r\n                        break;\r\n                    }\r\n                    if (!pluginName.startsWith(\"#\")) {\r\n                        pluginClassNames.add(pluginName);\r\n                    }\r\n                }\r\n            } catch (IOException ioe) {\r\n            }\r\n            is.close();\r\n        }\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    }\r\n    for (String pluginClassName : pluginClassNames) {\r\n        if (GlobalConfiguration.isRuntimeLogging && log.isLoggable(Level.FINEST)) {\r\n            log.finest(\"loadPlugins: TypeRegistry=\" + this.toString() + \": loading plugin \" + pluginClassName);\r\n        }\r\n        try {\r\n            Class<?> pluginClass = Class.forName(pluginClassName, false, this.classLoader.get());\r\n            Plugin pluginInstance = (Plugin) pluginClass.newInstance();\r\n            localPlugins.add(pluginInstance);\r\n        } catch (Exception e) {\r\n            log.log(Level.WARNING, \"Unable to find and instantiate plugin \" + pluginClassName, e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springsource.loaded.jvm.JVM.copyMethod",
	"Comment": "creates a copy of a method object that is equivalent to the original.",
	"Method": "Method copyMethod(Method method){\r\n    try {\r\n        if (jlrMethodRootField != null) {\r\n            jlrMethodRootField.set(method, null);\r\n        }\r\n        return (Method) jlrMethodCopy.invoke(method);\r\n    } catch (Exception e) {\r\n        log.log(Level.SEVERE, \"Problems copying method. Incompatible JVM?\", e);\r\n        return method;\r\n    }\r\n}"
}, {
	"Path": "android.support.design.widget.CustomCollapsingToolbarLayout.isTitleEnabled",
	"Comment": "returns whether this view is currently displaying its own title.",
	"Method": "boolean isTitleEnabled(){\r\n    return mCollapsingTitleEnabled;\r\n}"
}, {
	"Path": "org.springsource.loaded.TypeRegistry.getTypeRegistryFor",
	"Comment": "factory access method for obtaining typeregistry instances. returns a typeregistry for the specified classloader.",
	"Method": "TypeRegistry getTypeRegistryFor(ClassLoader classloader){\r\n    if (classloader == null) {\r\n        return null;\r\n    }\r\n    TypeRegistry existingRegistry = loaderToRegistryMap.get(classloader);\r\n    if (existingRegistry != null) {\r\n        return existingRegistry;\r\n    }\r\n    if (GlobalConfiguration.isRuntimeLogging && log.isLoggable(Level.INFO)) {\r\n        if (excludedLoaderInstances.contains(classloader.toString())) {\r\n            return null;\r\n        }\r\n    }\r\n    String classloaderName = classloader.getClass().getName();\r\n    if (classloaderName.equals(\"sun.reflect.DelegatingClassLoader\")) {\r\n        return null;\r\n    }\r\n    for (String excluded : excludedLoaders) {\r\n        if (classloaderName.startsWith(excluded)) {\r\n            if (GlobalConfiguration.isRuntimeLogging && log.isLoggable(Level.FINEST)) {\r\n                log.info(\"Classloader \" + classloaderName + \" has been deliberately excluded\");\r\n            }\r\n            excludedLoaderInstances.add(classloader.toString());\r\n            return null;\r\n        }\r\n    }\r\n    try {\r\n        Class.forName(\"org.springsource.loaded.ri.ReflectiveInterceptor\", false, classloader);\r\n    } catch (ClassNotFoundException ex) {\r\n        if (GlobalConfiguration.isRuntimeLogging && log.isLoggable(Level.INFO)) {\r\n            log.info(\"No TypeRegistry (can't load ReflectiveInterceptor) for loader \" + classloader);\r\n        }\r\n        return null;\r\n    }\r\n    if (GlobalConfiguration.isRuntimeLogging && log.isLoggable(Level.INFO)) {\r\n        log.info(\"TypeRegistry.getRegistryFor(): creating new TypeRegistry for loader \" + classloader);\r\n    }\r\n    TypeRegistry tr = new TypeRegistry(classloader);\r\n    return tr;\r\n}"
}, {
	"Path": "com.querydsl.sql.SQLExpressions.rowNumber",
	"Comment": "number of the current row within its partition, counting from 1",
	"Method": "WindowOver<Long> rowNumber(){\r\n    return rowNumber;\r\n}"
}, {
	"Path": "org.testcontainers.containers.ContainerState.getMappedPort",
	"Comment": "get the actual mapped port for a given port exposed by the container.",
	"Method": "Integer getMappedPort(int originalPort){\r\n    Preconditions.checkState(this.getContainerId() != null, \"Mapped port can only be obtained after the container is started\");\r\n    Ports.Binding[] binding = new Ports.Binding[0];\r\n    final InspectContainerResponse containerInfo = this.getContainerInfo();\r\n    if (containerInfo != null) {\r\n        binding = containerInfo.getNetworkSettings().getPorts().getBindings().get(new ExposedPort(originalPort));\r\n    }\r\n    if (binding != null && binding.length > 0 && binding[0] != null) {\r\n        return Integer.valueOf(binding[0].getHostPortSpec());\r\n    } else {\r\n        throw new IllegalArgumentException(\"Requested port (\" + originalPort + \") is not mapped\");\r\n    }\r\n}"
}, {
	"Path": "com.klinker.android.twitter.view.CircularProgressBar.interpolateSpeed",
	"Comment": "get the speed of the animation that we want based on the current sweep angle, needs a normal distribution",
	"Method": "float interpolateSpeed(float sweepAngle){\r\n    double increase = getUnstableIncrease();\r\n    double speed = (increase * Math.pow(e, -1 * pi * Math.pow(sweepAngle / 100 - 1.5, 2))) + increase;\r\n    return (float) speed;\r\n}"
}, {
	"Path": "com.querydsl.sql.AbstractSQLQuery.forShare",
	"Comment": "for share causes the rows retrieved by the select statement to be locked as though for update.supported by mysql, postgresql, sqlserver.",
	"Method": "Q forShare(Q forShare,boolean fallbackToForUpdate){\r\n    SQLTemplates sqlTemplates = configuration.getTemplates();\r\n    if (sqlTemplates.isForShareSupported()) {\r\n        QueryFlag forShareFlag = sqlTemplates.getForShareFlag();\r\n        return addFlag(forShareFlag);\r\n    }\r\n    if (fallbackToForUpdate) {\r\n        return forUpdate();\r\n    }\r\n    throw new QueryException(\"Using forShare() is not supported\");\r\n}"
}, {
	"Path": "org.springsource.loaded.Utils.discoverClassname",
	"Comment": "discover the classname specified in the supplied bytecode and return it.",
	"Method": "String discoverClassname(byte[] classbytes){\r\n    ClassReader cr = new ClassReader(classbytes);\r\n    ClassnameDiscoveryVisitor v = new ClassnameDiscoveryVisitor();\r\n    cr.accept(v, 0);\r\n    return v.classname;\r\n}"
}, {
	"Path": "com.querydsl.sql.SQLExpressions.corr",
	"Comment": "corr returns the coefficient of correlation of a set of number pairs.",
	"Method": "WindowOver<Double> corr(Expression<? extends Number> expr1,Expression<? extends Number> expr2){\r\n    return new WindowOver<Double>(Double.class, SQLOps.CORR, expr1, expr2);\r\n}"
}, {
	"Path": "com.simplecity.amp_library.saf.SafManager.getExtSdCardFolder",
	"Comment": "check whether the file is stored on an sd card, and if so, return the sd card path",
	"Method": "String getExtSdCardFolder(File file){\r\n    List<String> extSdPaths = getExtSdCardPaths();\r\n    try {\r\n        for (String extSdPath : extSdPaths) {\r\n            if (file.getCanonicalPath().startsWith(extSdPath)) {\r\n                return extSdPath;\r\n            }\r\n        }\r\n    } catch (IOException e) {\r\n        return null;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.querydsl.sql.dml.AbstractSQLUpdateClause.populate",
	"Comment": "populate the update clause with the properties of the given bean using the given mapper.",
	"Method": "C populate(Object bean,C populate,T obj,Mapper<T> mapper){\r\n    Collection<? extends Path<?>> primaryKeyColumns = entity.getPrimaryKey() != null ? entity.getPrimaryKey().getLocalColumns() : Collections.<Path<?>>emptyList();\r\n    Map<Path<?>, Object> values = mapper.createMap(entity, obj);\r\n    for (Map.Entry<Path<?>, Object> entry : values.entrySet()) {\r\n        if (!primaryKeyColumns.contains(entry.getKey())) {\r\n            set((Path) entry.getKey(), entry.getValue());\r\n        }\r\n    }\r\n    return (C) this;\r\n}"
}, {
	"Path": "com.klinker.android.twitter.utils.api_helper.TwitLongerHelper.updateTwitlonger",
	"Comment": "updates the status on twitlonger to include the tweet id from twitter.helpful for threading.",
	"Method": "boolean updateTwitlonger(TwitLongerStatus status,long tweetId){\r\n    try {\r\n        HttpClient client = new DefaultHttpClient();\r\n        HttpPut put = new HttpPut(PUT_URL + status.getId());\r\n        put.addHeader(\"X-API-KEY\", TWITLONGER_API_KEY);\r\n        put.addHeader(\"X-Auth-Service-Provider\", SERVICE_PROVIDER);\r\n        put.addHeader(\"X-Verify-Credentials-Authorization\", getAuthrityHeader(twitter));\r\n        List<NameValuePair> nvps = new ArrayList<NameValuePair>();\r\n        nvps.add(new BasicNameValuePair(\"twitter_status_id\", tweetId + \"\"));\r\n        put.setEntity(new UrlEncodedFormEntity(nvps));\r\n        HttpResponse response = client.execute(put);\r\n        BufferedReader rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));\r\n        if (rd.readLine() != null) {\r\n            Log.v(\"twitlonger\", \"updated the status successfully\");\r\n            return true;\r\n        }\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.springsource.loaded.test.MethodInvokerRewriterTests.rewriteInvokeStatic3",
	"Comment": "reloading target with a new static method that takes no parameters.",
	"Method": "void rewriteInvokeStatic3(){\r\n    TypeRegistry typeRegistry = getTypeRegistry(\"tgt.SimpleClass\");\r\n    ReloadableType callee = typeRegistry.addType(\"tgt.SimpleClass\", loadBytesForClass(\"tgt.SimpleClass\"));\r\n    byte[] callerbytes = loadBytesForClass(\"tgt.StaticCaller\");\r\n    byte[] rewrittenBytes = MethodInvokerRewriter.rewrite(typeRegistry, callerbytes);\r\n    Class<?> callerClazz = loadit(\"tgt.StaticCaller\", rewrittenBytes);\r\n    Result result = runUnguarded(callerClazz, \"run\");\r\n    assertEquals(123, result.returnValue);\r\n    callerbytes = loadBytesForClass(\"tgt.StaticCaller003\");\r\n    callerbytes = ClassRenamer.rename(\"tgt.StaticCaller003\", callerbytes, \"tgt.SimpleClass003:tgt.SimpleClass\");\r\n    rewrittenBytes = MethodInvokerRewriter.rewrite(typeRegistry, callerbytes);\r\n    Class<?> callerClazz002 = loadit(\"tgt.StaticCaller003\", rewrittenBytes);\r\n    callee.loadNewVersion(\"3\", retrieveRename(\"tgt.SimpleClass\", \"tgt.SimpleClass003\"));\r\n    result = runUnguarded(callerClazz002, \"run3\");\r\n    assertEquals(\"42\", result.returnValue);\r\n}"
}, {
	"Path": "com.querydsl.sql.SQLExpressions.covarSamp",
	"Comment": "corr returns the coefficient of correlation of a set of number pairs.",
	"Method": "WindowOver<Double> covarSamp(Expression<? extends Number> expr1,Expression<? extends Number> expr2){\r\n    return new WindowOver<Double>(Double.class, SQLOps.COVARSAMP, expr1, expr2);\r\n}"
}, {
	"Path": "org.testcontainers.junit.wait.strategy.HttpWaitStrategyTest.testWaitUntilReadyWithSuccess",
	"Comment": "expects that the waitstrategy returns successfully after receiving an http 200 response from the container.",
	"Method": "void testWaitUntilReadyWithSuccess(){\r\n    waitUntilReadyAndSucceed(createShellCommand(\"200 OK\", GOOD_RESPONSE_BODY));\r\n}"
}, {
	"Path": "com.simplecity.amp_library.ui.views.BreadcrumbItem.setItemPath",
	"Comment": "sets the item path associated with with this breadcrumb item",
	"Method": "void setItemPath(String itemPath){\r\n    this.mItemPath = itemPath;\r\n}"
}, {
	"Path": "uk.co.real_logic.sbe.generation.java.JavaUtil.generateFlyweightPropertyJavadoc",
	"Comment": "generate the javadoc comment header for flyweight property.",
	"Method": "String generateFlyweightPropertyJavadoc(String indent,Token propertyToken,String typeName){\r\n    final String description = propertyToken.description();\r\n    if (null == description || description.isEmpty()) {\r\n        return \"\";\r\n    }\r\n    return indent + \"/**\\n\" + indent + \" * \" + description + '\\n' + indent + \" *\\n\" + indent + \" * @return \" + typeName + \" : \" + description + \"\\n\" + indent + \" */\\n\";\r\n}"
}, {
	"Path": "org.springsource.loaded.TypeRegistry.couldBeReloadable",
	"Comment": "determine if the named type could be reloadable. this method is invoked if the user has not setup any inclusions.\twith no inclusions specified, something is considered reloadable if it is accessible by the classloader for this\tregistry and is not in a jar",
	"Method": "CouldBeReloadableDecision couldBeReloadable(String slashedName,boolean usePackageNameDecisionCache){\r\n    if (slashedName == null) {\r\n        return CouldBeReloadableDecision.No_BuiltIn;\r\n    }\r\n    if (slashedName.startsWith(\"java/\")) {\r\n        return CouldBeReloadableDecision.No_BuiltIn;\r\n    }\r\n    char ch = slashedName.charAt(0);\r\n    int index = ch - 'a';\r\n    if (usePackageNameDecisionCache && index > 0 && index < 26) {\r\n        String[] candidates = ignorablePackagePrefixes[index];\r\n        if (candidates != null) {\r\n            for (String ignorablePackagePrefix : candidates) {\r\n                if (slashedName.startsWith(ignorablePackagePrefix)) {\r\n                    if (GlobalConfiguration.explainMode && log.isLoggable(Level.INFO)) {\r\n                        log.info(\"WhyNotReloadable? The type \" + slashedName + \" is using a package name '\" + ignorablePackagePrefix + \"' which is considered infrastructure and types within it are not made reloadable\");\r\n                    }\r\n                    return CouldBeReloadableDecision.No_FixedPackageList;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (slashedName.indexOf(\"$Proxy\") != -1 || slashedName.indexOf(\"$$EnhancerBy\") != -1 || slashedName.indexOf(\"$$FastClassBy\") != -1) {\r\n        return CouldBeReloadableDecision.Yes_CGLIB;\r\n    }\r\n    int underscorePos = slashedName.indexOf(\"_\");\r\n    if (underscorePos != -1) {\r\n        if (slashedName.endsWith(\"_jspx\") || slashedName.endsWith(\"_tagx\")) {\r\n            return CouldBeReloadableDecision.No_JSP;\r\n        }\r\n        if (slashedName.endsWith(\"_jspx$Helper\") || slashedName.endsWith(\"_tagx$Helper\")) {\r\n            return CouldBeReloadableDecision.No_JSP;\r\n        }\r\n        if (ch == '_' && slashedName.indexOf(\"_groovy\") != -1) {\r\n            return CouldBeReloadableDecision.No_GroovyScript;\r\n        }\r\n    }\r\n    int lastSlashPos = slashedName.lastIndexOf('/');\r\n    String packageName = lastSlashPos == -1 ? null : slashedName.substring(0, lastSlashPos);\r\n    if (packageName != null && !GlobalConfiguration.allowSplitPackages && usePackageNameDecisionCache) {\r\n        for (String foundPackageName : packagesFound) {\r\n            if (packageName.equals(foundPackageName)) {\r\n                return CouldBeReloadableDecision.Yes_PackageCache;\r\n            }\r\n        }\r\n        for (String notfoundPackageName : packagesNotFound) {\r\n            if (packageName.equals(notfoundPackageName)) {\r\n                return CouldBeReloadableDecision.No_PackageCache;\r\n            }\r\n        }\r\n    }\r\n    if (ch == '[') {\r\n        return CouldBeReloadableDecision.No_Array;\r\n    }\r\n    try {\r\n        if (getResourceMethod == null) {\r\n            try {\r\n                getResourceMethod = ClassLoader.class.getDeclaredMethod(\"getResource\", String.class);\r\n            } catch (Exception e) {\r\n                throw new ReloadException(\"Unable to locate 'getResource' on the ClassLoader class\", e);\r\n            }\r\n        }\r\n        getResourceMethod.setAccessible(true);\r\n        URL url = (URL) getResourceMethod.invoke(classLoader.get(), slashedName + \".class\");\r\n        boolean reloadable = false;\r\n        boolean jarEntry = false;\r\n        if (url != null) {\r\n            String protocol = url.getProtocol();\r\n            reloadable = protocol.equals(\"file\");\r\n            if (!reloadable && protocol.equals(\"jar\")) {\r\n                if (GlobalConfiguration.jarsToWatch != null) {\r\n                    String urlstring = url.toString();\r\n                    int bangSlash = urlstring.lastIndexOf(\"!/\");\r\n                    if (bangSlash != -1) {\r\n                        String pathInJar = urlstring.substring(bangSlash + 2);\r\n                        String remainingPrefix = urlstring.substring(0, bangSlash);\r\n                        int lastSlash = remainingPrefix.lastIndexOf(File.separator);\r\n                        String jarname = remainingPrefix.substring(lastSlash + 1);\r\n                        for (String jarToWatch : GlobalConfiguration.jarsToWatch) {\r\n                            if (jarname.equals(jarToWatch)) {\r\n                                reloadable = true;\r\n                                jarEntry = true;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (packageName != null && !GlobalConfiguration.allowSplitPackages && usePackageNameDecisionCache) {\r\n            if (reloadable) {\r\n                packagesFound.add(packageName);\r\n            } else {\r\n                packagesNotFound.add(packageName);\r\n            }\r\n        }\r\n        if (reloadable) {\r\n            if (jarEntry) {\r\n                return CouldBeReloadableDecision.Yes_FoundInJar;\r\n            } else {\r\n                return CouldBeReloadableDecision.Yes_FoundOnDisk;\r\n            }\r\n        } else {\r\n            return CouldBeReloadableDecision.No_DiskCheck;\r\n        }\r\n    } catch (Exception e) {\r\n        throw new ReloadException(\"Unexpected problem locating the bytecode for \" + slashedName + \".class\", e);\r\n    }\r\n}"
}, {
	"Path": "com.querydsl.sql.oracle.AbstractOracleQuery.connectByPrior",
	"Comment": "connect by specifies the relationship between parent rows and child rows of the hierarchy.",
	"Method": "C connectByPrior(Predicate cond){\r\n    return addFlag(Position.BEFORE_ORDER, CONNECT_BY_PRIOR, cond);\r\n}"
}, {
	"Path": "com.querydsl.sql.SQLExpressions.selectOne",
	"Comment": "create a new detached sqlquery instance with one as the projection",
	"Method": "SQLQuery<Integer> selectOne(){\r\n    return select(Expressions.ONE);\r\n}"
}, {
	"Path": "com.r0adkll.slidr.model.SlidrConfig.getPosition",
	"Comment": "get the position of the slidable mechanism for this configuration. this is the position onthe screen that the user can swipe the activity away from",
	"Method": "SlidrPosition getPosition(){\r\n    return position;\r\n}"
}, {
	"Path": "com.querydsl.sql.dml.AbstractSQLUpdateClause.addFlag",
	"Comment": "add the given expression at the given position as a query flag",
	"Method": "C addFlag(Position position,String flag,C addFlag,Position position,Expression<?> flag){\r\n    metadata.addFlag(new QueryFlag(position, flag));\r\n    return (C) this;\r\n}"
}, {
	"Path": "org.springsource.loaded.testgen.GenerativeTest.assertEqualIResults",
	"Comment": "this method is called by the test runner to compare predicted results against actual results.\toverride this method to customise how you want these compared.",
	"Method": "void assertEqualIResults(IResult expected,IResult actual){\r\n    if (expected.equals(actual)) {\r\n        return;\r\n    }\r\n    if (expected.getClass() != actual.getClass()) {\r\n        throw new ComparisonFailure(null, expected.toString(), actual.toString());\r\n    }\r\n    if (expected instanceof Result) {\r\n        assertEqualResults((Result) expected, (Result) actual);\r\n    } else if (expected instanceof ResultException) {\r\n        assertEqualExceptions((ResultException) expected, (ResultException) actual);\r\n    } else {\r\n        throw new ComparisonFailure(null, expected.toString(), actual.toString());\r\n    }\r\n}"
}, {
	"Path": "android.support.design.widget.CustomCollapsingToolbarLayout.setScrimVisibleHeightTrigger",
	"Comment": "set the amount of visible height in pixels used to define when to trigger a scrimvisibility change.if the visible height of this view is less than the given value, the scrims will bemade visible, otherwise they are hidden.",
	"Method": "void setScrimVisibleHeightTrigger(int height){\r\n    if (mScrimVisibleHeightTrigger != height) {\r\n        mScrimVisibleHeightTrigger = height;\r\n        updateScrimVisibility();\r\n    }\r\n}"
}, {
	"Path": "org.springsource.loaded.ReloadableType.getOriginalMethod",
	"Comment": "gets the method corresponding to given name and descriptor, from the original type descriptor.",
	"Method": "MethodMember getOriginalMethod(String nameAndDescriptor){\r\n    return getMethod(nameAndDescriptor);\r\n}"
}, {
	"Path": "uk.co.senab.photoview.DefaultOnDoubleTapListener.setPhotoViewAttacher",
	"Comment": "allows to change photoviewattacher within range of single instance",
	"Method": "void setPhotoViewAttacher(PhotoViewAttacher newPhotoViewAttacher){\r\n    this.photoViewAttacher = newPhotoViewAttacher;\r\n}"
}, {
	"Path": "org.testcontainers.containers.DockerComposeContainer.addWaitStrategy",
	"Comment": "can have multiple wait strategies for a single container, e.g. if waiting on several portsif no wait strategy is defined, the waitallstrategy will return immediately.the waitallstrategy uses an long timeout, because timeouts should be handled by the inner strategies.",
	"Method": "void addWaitStrategy(String serviceInstanceName,WaitStrategy waitStrategy){\r\n    final WaitAllStrategy waitAllStrategy = waitStrategyMap.computeIfAbsent(serviceInstanceName, __ -> (WaitAllStrategy) new WaitAllStrategy().withStartupTimeout(Duration.ofMinutes(30)));\r\n    waitAllStrategy.withStrategy(waitStrategy);\r\n}"
}, {
	"Path": "io.rx_cache2.internal.cache.memory.apache.AbstractHashedMap.hash",
	"Comment": "gets the hash code for the key specified.this implementation uses the additional hashing routine from jdk1.4.subclasses can override this to return alternate hash codes.",
	"Method": "int hash(Object key){\r\n    int h = key.hashCode();\r\n    h += ~(h << 9);\r\n    h ^= h >>> 14;\r\n    h += h << 4;\r\n    h ^= h >>> 10;\r\n    return h;\r\n}"
}, {
	"Path": "io.rx_cache2.internal.cache.memory.apache.AbstractHashedMap.calculateNewCapacity",
	"Comment": "calculates the new capacity of the map.this implementation normalizes the capacity to a power of two.",
	"Method": "int calculateNewCapacity(int proposedCapacity){\r\n    int newCapacity = 1;\r\n    if (proposedCapacity > MAXIMUM_CAPACITY) {\r\n        newCapacity = MAXIMUM_CAPACITY;\r\n    } else {\r\n        while (newCapacity < proposedCapacity) {\r\n            newCapacity <<= 1;\r\n        }\r\n        if (newCapacity > MAXIMUM_CAPACITY) {\r\n            newCapacity = MAXIMUM_CAPACITY;\r\n        }\r\n    }\r\n    return newCapacity;\r\n}"
}, {
	"Path": "io.rx_cache2.internal.cache.memory.apache.AbstractReferenceMap.hashEntry",
	"Comment": "gets the hash code for a mapentry.subclasses can override this, for example to use the identityhashcode.",
	"Method": "int hashEntry(Object key,Object value){\r\n    return (key == null ? 0 : key.hashCode()) ^ (value == null ? 0 : value.hashCode());\r\n}"
}, {
	"Path": "org.testcontainers.utility.MountableFile.extractClassPathResourceToTempLocation",
	"Comment": "extract a file or directory tree from a jar file to a temporary location.this allows docker to mount classpath resources as files.",
	"Method": "String extractClassPathResourceToTempLocation(String hostPath){\r\n    File tmpLocation = createTempDirectory();\r\n    tmpLocation.delete();\r\n    String urldecodedJarPath = unencodeResourceURIToFilePath(hostPath);\r\n    String internalPath = hostPath.replaceAll(\"[^!]*!/\", \"\");\r\n    try (JarFile jarFile = new JarFile(urldecodedJarPath)) {\r\n        Enumeration<JarEntry> entries = jarFile.entries();\r\n        while (entries.hasMoreElements()) {\r\n            JarEntry entry = entries.nextElement();\r\n            final String name = entry.getName();\r\n            if (name.startsWith(internalPath)) {\r\n                log.debug(\"Copying classpath resource(s) from {} to {} to permit Docker to bind\", hostPath, tmpLocation);\r\n                copyFromJarToLocation(jarFile, entry, internalPath, tmpLocation);\r\n            }\r\n        }\r\n    } catch (IOException e) {\r\n        throw new IllegalStateException(\"Failed to process JAR file when extracting classpath resource: \" + hostPath, e);\r\n    }\r\n    deleteOnExit(tmpLocation.toPath());\r\n    return tmpLocation.getAbsolutePath();\r\n}"
}, {
	"Path": "org.springsource.loaded.test.ReloadableTypeTests.protectedFieldAccessors3",
	"Comment": "in this test a protected field has the same name as another field being referenced from the reloadable type.\tcheck only the right one is redirect to the accessor.",
	"Method": "void protectedFieldAccessors3(){\r\n    TypeRegistry tr = getTypeRegistry(\"prot.SubThree,prot.PeerThree\");\r\n    tr.addType(\"prot.PeerThree\", loadBytesForClass(\"prot.PeerThree\"));\r\n    ReloadableType rtype = tr.addType(\"prot.SubThree\", loadBytesForClass(\"prot.SubThree\"));\r\n    Object instance = rtype.getClazz().newInstance();\r\n    runOnInstance(rtype.getClazz(), instance, \"setField\", 3);\r\n    assertEquals(3, runOnInstance(rtype.getClazz(), instance, \"getField\").returnValue);\r\n    runOnInstance(rtype.getClazz(), instance, \"setPeerField\", 5);\r\n    assertEquals(5, runOnInstance(rtype.getClazz(), instance, \"getPeerField\").returnValue);\r\n    assertEquals(3, runOnInstance(rtype.getClazz(), instance, \"getField\").returnValue);\r\n    rtype.loadNewVersion(rtype.bytesInitial);\r\n    runOnInstance(rtype.getClazz(), instance, \"setField\", 3);\r\n    assertEquals(3, runOnInstance(rtype.getClazz(), instance, \"getField\").returnValue);\r\n    runOnInstance(rtype.getClazz(), instance, \"setPeerField\", 5);\r\n    assertEquals(5, runOnInstance(rtype.getClazz(), instance, \"getPeerField\").returnValue);\r\n    assertEquals(3, runOnInstance(rtype.getClazz(), instance, \"getField\").returnValue);\r\n}"
}, {
	"Path": "org.springsource.loaded.test.SuperDispatcherTests.twolevels",
	"Comment": "a reloadable type extends a type and overrides a protected method from that type, then a further subtype extends\tthe reloadable type.",
	"Method": "void twolevels(){\r\n    String t0 = \"foo.ControllerB\";\r\n    String t = \"foo.SubControllerB\";\r\n    TypeRegistry typeRegistry = getTypeRegistry(\"foo..*\");\r\n    ReloadableType rtype0 = typeRegistry.addType(t0, loadBytesForClass(t0));\r\n    ReloadableType rtype = typeRegistry.addType(t, loadBytesForClass(t));\r\n    String rtypeDisassembled = toStringClass(rtype.bytesLoaded);\r\n    String stdout = runOnInstance(rtype.getClazz(), rtype.getClazz().newInstance(), \"foo\").stdout;\r\n    assertEquals(\"TopB.foo() running\\nControllerB.foo() running\\nSubControllerB.foo() running\", stdout);\r\n    assertEquals(1, filter(getMethods(rtype.bytesLoaded), methodSuffixSuperDispatcher).size());\r\n    Assert.assertTrue(rtype0.loadNewVersion(\"2\", retrieveRename(t0, t0 + \"2\")));\r\n    stdout = runOnInstance(rtype.getClazz(), rtype.getClazz().newInstance(), \"foo\").stdout;\r\n    assertEquals(\"TopB.foo() running\\nControllerB.foo() running again!\\nSubControllerB.foo() running\", stdout);\r\n    Assert.assertTrue(rtype.loadNewVersion(\"2\", retrieveRename(t, t + \"2\")));\r\n    stdout = runOnInstance(rtype.getClazz(), rtype.getClazz().newInstance(), \"foo\").stdout;\r\n    assertEquals(\"TopB.foo() running\\nControllerB.foo() running again!\\nSubControllerB.foo() running again!\", stdout);\r\n}"
}, {
	"Path": "org.unitils.core.dbsupport.H2DbSupport.getSequenceNames",
	"Comment": "retrieves the names of all the sequences in the database schema.",
	"Method": "Set<String> getSequenceNames(){\r\n    return getSQLHandler().getItemsAsStringSet(\"select SEQUENCE_NAME from \" + \"INFORMATION_SCHEMA.SEQUENCES where SEQUENCE_SCHEMA = '\" + getSchemaName() + \"'\");\r\n}"
}, {
	"Path": "com.r0adkll.slidr.util.ViewDragHelper.continueSettling",
	"Comment": "move the captured settling view by the appropriate amount for the current time.if continuesettling returns true, the caller should call it againon the next frame to continue.",
	"Method": "boolean continueSettling(boolean deferCallbacks){\r\n    if (mDragState == STATE_SETTLING) {\r\n        boolean keepGoing = mScroller.computeScrollOffset();\r\n        final int x = mScroller.getCurrX();\r\n        final int y = mScroller.getCurrY();\r\n        final int dx = x - mCapturedView.getLeft();\r\n        final int dy = y - mCapturedView.getTop();\r\n        if (dx != 0) {\r\n            ViewCompat.offsetLeftAndRight(mCapturedView, dx);\r\n        }\r\n        if (dy != 0) {\r\n            ViewCompat.offsetTopAndBottom(mCapturedView, dy);\r\n        }\r\n        if (dx != 0 || dy != 0) {\r\n            mCallback.onViewPositionChanged(mCapturedView, x, y, dx, dy);\r\n        }\r\n        if (keepGoing && x == mScroller.getFinalX() && y == mScroller.getFinalY()) {\r\n            mScroller.abortAnimation();\r\n            keepGoing = false;\r\n        }\r\n        if (!keepGoing) {\r\n            if (deferCallbacks) {\r\n                mParentView.post(mSetIdleRunnable);\r\n            } else {\r\n                setDragState(STATE_IDLE);\r\n            }\r\n        }\r\n    }\r\n    return mDragState == STATE_SETTLING;\r\n}"
}, {
	"Path": "com.querydsl.sql.SQLExpressions.any",
	"Comment": "get an aggregate any expression for the given boolean expression",
	"Method": "BooleanExpression any(BooleanExpression expr){\r\n    return Expressions.booleanOperation(Ops.AggOps.BOOLEAN_ANY, expr);\r\n}"
}, {
	"Path": "com.querydsl.sql.SQLExpressions.stddevDistinct",
	"Comment": "returns the sample standard deviation of expr, a set of numbers.",
	"Method": "WindowOver<T> stddevDistinct(Expression<T> expr){\r\n    return new WindowOver<T>(expr.getType(), SQLOps.STDDEV_DISTINCT, expr);\r\n}"
}, {
	"Path": "org.testcontainers.containers.JdbcDatabaseContainer.createConnection",
	"Comment": "creates a connection to the underlying containerized database instance.",
	"Method": "Connection createConnection(String queryString){\r\n    final Properties info = new Properties();\r\n    info.put(\"user\", this.getUsername());\r\n    info.put(\"password\", this.getPassword());\r\n    final String url = constructUrlForConnection(queryString);\r\n    final Driver jdbcDriverInstance = getJdbcDriverInstance();\r\n    try {\r\n        return Unreliables.retryUntilSuccess(getConnectTimeoutSeconds(), TimeUnit.SECONDS, () -> DB_CONNECT_RATE_LIMIT.getWhenReady(() -> jdbcDriverInstance.connect(url, info)));\r\n    } catch (Exception e) {\r\n        throw new SQLException(\"Could not create new connection\", e);\r\n    }\r\n}"
}, {
	"Path": "com.r0adkll.slidr.Slidr.replace",
	"Comment": "attach a slider mechanism to a fragment view replacing an internal view",
	"Method": "SlidrInterface replace(View oldScreen,SlidrConfig config){\r\n    ViewGroup parent = (ViewGroup) oldScreen.getParent();\r\n    ViewGroup.LayoutParams params = oldScreen.getLayoutParams();\r\n    parent.removeView(oldScreen);\r\n    final SliderPanel panel = new SliderPanel(oldScreen.getContext(), oldScreen, config);\r\n    panel.setId(R.id.slidable_panel);\r\n    oldScreen.setId(R.id.slidable_content);\r\n    panel.addView(oldScreen);\r\n    parent.addView(panel, 0, params);\r\n    panel.setOnPanelSlideListener(new FragmentPanelSlideListener(oldScreen, config));\r\n    return panel.getDefaultInterface();\r\n}"
}, {
	"Path": "com.simplecity.amp_library.playback.QueueManager.removeQueueItems",
	"Comment": "removes the range of songs specified from the playlist & shufflelist. if a songwithin the range is the file currently being played, playback will moveto the next song after the range.",
	"Method": "void removeQueueItems(List<QueueItem> queueItems,UnsafeAction stop,UnsafeAction moveToNextTrack){\r\n    playlist.removeAll(queueItems);\r\n    shuffleList.removeAll(queueItems);\r\n    QueueItemKt.updateOccurrence(getCurrentPlaylist());\r\n    if (queueItems.contains(getCurrentQueueItem())) {\r\n        queuePosition = Collections.indexOfSubList(getCurrentPlaylist(), queueItems);\r\n        onCurrentSongRemoved(stop, moveToNextTrack);\r\n    } else {\r\n        queuePosition = getCurrentPlaylist().indexOf(getCurrentQueueItem());\r\n    }\r\n    notifyQueueChanged();\r\n}"
}, {
	"Path": "com.r0adkll.slidr.model.SlidrConfig.getVelocityThreshold",
	"Comment": "get the velocity threshold at which the slide action is completed regardless of offsetdistance of the drag",
	"Method": "float getVelocityThreshold(){\r\n    return velocityThreshold;\r\n}"
}, {
	"Path": "com.querydsl.spatial.SurfaceExpression.area",
	"Comment": "the area of this surface, as measured in the spatial reference system of this surface.",
	"Method": "NumberExpression<Double> area(){\r\n    if (area == null) {\r\n        area = Expressions.numberOperation(Double.class, SpatialOps.AREA, mixin);\r\n    }\r\n    return area;\r\n}"
}, {
	"Path": "uk.co.real_logic.sbe.generation.java.JavaUtil.generateGroupEncodePropertyJavadoc",
	"Comment": "generate the javadoc comment header for group encode property.",
	"Method": "String generateGroupEncodePropertyJavadoc(String indent,Token propertyToken,String typeName){\r\n    final String description = propertyToken.description();\r\n    if (null == description || description.isEmpty()) {\r\n        return \"\";\r\n    }\r\n    return indent + \"/**\\n\" + indent + \" * \" + description + \"\\n\" + indent + \" *\\n\" + indent + \" * @param count of times the group will be encoded\\n\" + indent + \" * @return \" + typeName + \" : encoder for the group\\n\" + indent + \" */\\n\";\r\n}"
}, {
	"Path": "org.springsource.loaded.InterfaceExtractor.extract",
	"Comment": "extract the fixed interface for a class and a type descriptor with more details on the methods.",
	"Method": "byte[] extract(byte[] classbytes,TypeRegistry registry,TypeDescriptor typeDescriptor,byte[] extract,byte[] classbytes,TypeDescriptor typeDescriptor){\r\n    ClassReader fileReader = new ClassReader(classbytes);\r\n    ExtractorVisitor extractorVisitor = new ExtractorVisitor(typeDescriptor);\r\n    fileReader.accept(extractorVisitor, 0);\r\n    return extractorVisitor.getBytes();\r\n}"
}, {
	"Path": "org.springsource.loaded.test.TypeRewriterTests.newConstructors",
	"Comment": "looking at how constructors get rewritten when the target did not originally declare the constructor",
	"Method": "void newConstructors(){\r\n    String caller = \"ctors.Caller\";\r\n    String callee = \"ctors.Callee\";\r\n    TypeRegistry r = getTypeRegistry(caller + \",\" + callee);\r\n    ReloadableType rcaller = r.addType(caller, loadBytesForClass(caller));\r\n    ReloadableType rcallee = r.addType(callee, loadBytesForClass(callee));\r\n    Result res = null;\r\n    Object callerInstance = rcaller.getClazz().newInstance();\r\n    res = runOnInstance(rcaller.getClazz(), callerInstance, \"runA\");\r\n    assertEquals(\"callee\", res.returnValue.toString());\r\n    rcaller.loadNewVersion(\"002\", retrieveRename(caller, caller + \"2\", \"ctors.Callee2:ctors.Callee\"));\r\n    rcallee.loadNewVersion(\"002\", retrieveRename(callee, callee + \"2\"));\r\n    res = runOnInstance(rcaller.getClazz(), callerInstance, \"runB\");\r\n    assertEquals(\"callee\", res.returnValue.toString());\r\n}"
}, {
	"Path": "com.querydsl.spatial.CurveExpression.length",
	"Comment": "the length of this curve in its associated spatial reference.",
	"Method": "NumberExpression<Double> length(){\r\n    if (length == null) {\r\n        length = Expressions.numberOperation(Double.class, SpatialOps.LENGTH, mixin);\r\n    }\r\n    return length;\r\n}"
}, {
	"Path": "io.rx_cache2.internal.cache.memory.apache.AbstractHashedMap.entryValue",
	"Comment": "gets the value field from a hashentry.used in subclasses that have no visibility of the field.",
	"Method": "V entryValue(HashEntry<K, V> entry){\r\n    return entry.getValue();\r\n}"
}, {
	"Path": "com.squareup.tape2.QueueFile.ringWrite",
	"Comment": "writes count bytes from buffer to position in file. automatically wraps write if position ispast the end of the file or if buffer overlaps it.",
	"Method": "void ringWrite(long position,byte[] buffer,int offset,int count){\r\n    position = wrapPosition(position);\r\n    if (position + count <= fileLength) {\r\n        raf.seek(position);\r\n        raf.write(buffer, offset, count);\r\n    } else {\r\n        int beforeEof = (int) (fileLength - position);\r\n        raf.seek(position);\r\n        raf.write(buffer, offset, beforeEof);\r\n        raf.seek(headerLength);\r\n        raf.write(buffer, offset + beforeEof, count - beforeEof);\r\n    }\r\n}"
}, {
	"Path": "com.querydsl.sql.SQLExpressions.relationalFunctionCall",
	"Comment": "create a new relationalfunctioncall for the given function and arguments",
	"Method": "RelationalFunctionCall<T> relationalFunctionCall(Class<? extends T> type,String function,Object args){\r\n    return new RelationalFunctionCall<T>(type, function, args);\r\n}"
}, {
	"Path": "org.springsource.loaded.test.MethodInvokerRewriterTests.virtualDispatchCallingSubMethodIntroducedLater",
	"Comment": "calling a method on a target that is initially satisfied by the subtype but is then added to the subtype with a\tdifferent implementation.",
	"Method": "void virtualDispatchCallingSubMethodIntroducedLater(){\r\n    TypeRegistry tr = getTypeRegistry(\"invokevirtual..*\");\r\n    ReloadableType x = loadType(tr, \"invokevirtual.X\");\r\n    ReloadableType y = loadType(tr, \"invokevirtual.Y\");\r\n    Method method = null;\r\n    String string = null;\r\n    Object object = x.getClazz().newInstance();\r\n    method = x.getClazz().getMethod(\"run\");\r\n    string = method.invoke(object).toString();\r\n    assertEquals(\"1111\", string);\r\n    y.loadNewVersion(\"002\", this.retrieveRename(\"invokevirtual.Y\", \"invokevirtual.Y002\"));\r\n    string = method.invoke(object).toString();\r\n    assertEquals(\"2222\", string);\r\n}"
}, {
	"Path": "com.simplecity.amp_library.utils.ResourceUtils.toPixels",
	"Comment": "this method converts dp unit to equivalent pixels, depending on device density.",
	"Method": "int toPixels(float dp){\r\n    DisplayMetrics metrics = Resources.getSystem().getDisplayMetrics();\r\n    return (int) (dp * (metrics.densityDpi / 160f));\r\n}"
}, {
	"Path": "com.simplecity.amp_library.utils.color.BitmapPaletteProcessor.processBitmap",
	"Comment": "processes a builder of a media notification and calculates the appropriate colors that shouldbe used.",
	"Method": "Pair<Integer, Integer> processBitmap(Bitmap bitmap){\r\n    int backgroundColor = 0;\r\n    Palette.Builder paletteBuilder = Palette.from(bitmap).clearFilters();\r\n    Palette palette = paletteBuilder.generate();\r\n    backgroundColor = findBackgroundColorAndFilter(palette);\r\n    if (mFilteredBackgroundHsl != null) {\r\n        paletteBuilder.addFilter((rgb, hsl) -> {\r\n            float diff = Math.abs(hsl[0] - mFilteredBackgroundHsl[0]);\r\n            return diff > 10 && diff < 350;\r\n        });\r\n    }\r\n    paletteBuilder.addFilter(mBlackWhiteFilter);\r\n    palette = paletteBuilder.generate();\r\n    int foregroundColor = selectForegroundColor(backgroundColor, palette);\r\n    return new Pair(backgroundColor, foregroundColor);\r\n}"
}, {
	"Path": "com.querydsl.spatial.GeometryExpression.boundary",
	"Comment": "returns the closure of the combinatorial boundary of this geometric object",
	"Method": "GeometryExpression<Geometry> boundary(){\r\n    if (boundary == null) {\r\n        boundary = GeometryExpressions.geometryOperation(SpatialOps.BOUNDARY, mixin);\r\n    }\r\n    return boundary;\r\n}"
}, {
	"Path": "org.springsource.loaded.TypeRegistry.ivicheck",
	"Comment": "used in code the generated code replaces invokevirtual calls. determine if the code can run as it was originally\tcompiled.\tthis method will return false if nothing has changed to interfere with the invocation and it should proceed. this\tmethod will return true if something has changed and the caller needs to do something different.",
	"Method": "boolean ivicheck(int ids,String nameAndDescriptor){\r\n    if (nothingReloaded) {\r\n        return false;\r\n    }\r\n    int registryId = ids >>> 16;\r\n    int typeId = ids & 0xffff;\r\n    TypeRegistry typeRegistry = registryInstances[registryId].get();\r\n    ReloadableType reloadableType = typeRegistry.getReloadableType(typeId);\r\n    if (reloadableType == null) {\r\n        reloadableType = searchForReloadableType(typeId, typeRegistry);\r\n    }\r\n    if (reloadableType != null && !reloadableType.isAffectedByReload()) {\r\n        return false;\r\n    }\r\n    if (reloadableType != null && reloadableType.hasBeenReloaded()) {\r\n        MethodMember method = reloadableType.getLiveVersion().incrementalTypeDescriptor.getFromLatestByDescriptor(nameAndDescriptor);\r\n        boolean dispatchThroughDescriptor = false;\r\n        if (method == null) {\r\n            if (!reloadableType.getTypeDescriptor().isFinalInHierarchy(nameAndDescriptor)) {\r\n                throw new NoSuchMethodError(reloadableType.getBaseName() + \".\" + nameAndDescriptor);\r\n            }\r\n        } else if (IncrementalTypeDescriptor.isBrandNewMethod(method)) {\r\n            dispatchThroughDescriptor = true;\r\n        } else if (IncrementalTypeDescriptor.hasChanged(method)) {\r\n            if (!IncrementalTypeDescriptor.isCatcher(method)) {\r\n                if (!IncrementalTypeDescriptor.wasDeleted(method)) {\r\n                    dispatchThroughDescriptor = true;\r\n                }\r\n            }\r\n        }\r\n        if (dispatchThroughDescriptor) {\r\n            if (GlobalConfiguration.isRuntimeLogging && log.isLoggable(Level.FINER)) {\r\n                log.info(\"versionstamp \" + reloadableType.getLiveVersion().versionstamp);\r\n                log.exiting(\"TypeRegistry\", \"ivicheck\", true);\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.querydsl.sql.dml.AbstractSQLInsertClause.executeWithKeys",
	"Comment": "execute the clause and return the generated keys as a resultset",
	"Method": "List<T> executeWithKeys(Path<T> path,List<T> executeWithKeys,Class<T> type,List<T> executeWithKeys,Class<T> type,Path<T> path,ResultSet executeWithKeys){\r\n    context = startContext(connection(), metadata, entity);\r\n    try {\r\n        PreparedStatement stmt = null;\r\n        if (batches.isEmpty()) {\r\n            stmt = createStatement(true);\r\n            listeners.notifyInsert(entity, metadata, columns, values, subQuery);\r\n            listeners.preExecute(context);\r\n            stmt.executeUpdate();\r\n            listeners.executed(context);\r\n        } else if (batchToBulk) {\r\n            stmt = createStatement(true);\r\n            listeners.notifyInserts(entity, metadata, batches);\r\n            listeners.preExecute(context);\r\n            stmt.executeUpdate();\r\n            listeners.executed(context);\r\n        } else {\r\n            Collection<PreparedStatement> stmts = createStatements(true);\r\n            if (stmts != null && stmts.size() > 1) {\r\n                throw new IllegalStateException(\"executeWithKeys called with batch statement and multiple SQL strings\");\r\n            }\r\n            stmt = stmts.iterator().next();\r\n            listeners.notifyInserts(entity, metadata, batches);\r\n            listeners.preExecute(context);\r\n            stmt.executeBatch();\r\n            listeners.executed(context);\r\n        }\r\n        final Statement stmt2 = stmt;\r\n        ResultSet rs = stmt.getGeneratedKeys();\r\n        return new ResultSetAdapter(rs) {\r\n            @Override\r\n            public void close() throws SQLException {\r\n                try {\r\n                    super.close();\r\n                } finally {\r\n                    stmt2.close();\r\n                    reset();\r\n                    endContext(context);\r\n                }\r\n            }\r\n        };\r\n    } catch (SQLException e) {\r\n        onException(context, e);\r\n        reset();\r\n        endContext(context);\r\n        throw configuration.translate(queryString, constants, e);\r\n    }\r\n}"
}, {
	"Path": "com.querydsl.sql.dml.AbstractSQLInsertClause.executeWithKeys",
	"Comment": "execute the clause and return the generated keys as a resultset",
	"Method": "List<T> executeWithKeys(Path<T> path,List<T> executeWithKeys,Class<T> type,List<T> executeWithKeys,Class<T> type,Path<T> path,ResultSet executeWithKeys){\r\n    try {\r\n        super.close();\r\n    } finally {\r\n        stmt2.close();\r\n        reset();\r\n        endContext(context);\r\n    }\r\n}"
}, {
	"Path": "org.springsource.loaded.test.ClassRenamerTests.simpleRename",
	"Comment": "load the byteform of a class, manipulate the bytes to rename it, then try and define it and use it under the new",
	"Method": "void simpleRename(){\r\n    byte[] classbytes = loadBytesForClass(\"data.Fruity002\");\r\n    byte[] renamedbytes = ClassRenamer.rename(\"data.Fruity\", classbytes);\r\n    Class<?> clazz = loadit(\"data.Fruity\", renamedbytes);\r\n    Object value = run(clazz, \"getFruit\");\r\n    Assert.assertEquals(\"orange\", value);\r\n}"
}, {
	"Path": "com.querydsl.spatial.GeometryExpressions.translate",
	"Comment": "translates the geometry to a new location using the numeric parameters as offsets.",
	"Method": "GeometryExpression<T> translate(Expression<T> expr,float deltax,float deltay,GeometryExpression<T> translate,Expression<T> expr,float deltax,float deltay,float deltaz){\r\n    return geometryOperation(expr.getType(), SpatialOps.TRANSLATE2, expr, ConstantImpl.create(deltax), ConstantImpl.create(deltay), ConstantImpl.create(deltaz));\r\n}"
}]