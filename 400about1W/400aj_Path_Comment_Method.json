[{
	"Path": "com.marshalchen.common.uimodule.swipelayout.SwipeLayout.computeSurfaceLayoutArea",
	"Comment": "a helper function to compute the rect area that surface will hold in.",
	"Method": "Rect computeSurfaceLayoutArea(boolean open){\r\n    int l = getPaddingLeft(), t = getPaddingTop();\r\n    if (open) {\r\n        if (mDragEdge == DragEdge.Left)\r\n            l = getPaddingLeft() + mDragDistance;\r\n        else if (mDragEdge == DragEdge.Right)\r\n            l = getPaddingLeft() - mDragDistance;\r\n        else if (mDragEdge == DragEdge.Top)\r\n            t = getPaddingTop() + mDragDistance;\r\n        else\r\n            t = getPaddingTop() - mDragDistance;\r\n    }\r\n    return new Rect(l, t, l + getMeasuredWidth(), t + getMeasuredHeight());\r\n}"
}, {
	"Path": "org.isoron.uhabits.core.io.HabitsCSVExporter.writeMultipleHabitsHeader",
	"Comment": "writes the first row, containing header information, using the given writer.this consists of the date title and the names of the selected habits.",
	"Method": "void writeMultipleHabitsHeader(Writer out){\r\n    out.write(\"Date\" + DELIMITER);\r\n    for (Habit h : selectedHabits) {\r\n        out.write(h.getName());\r\n        out.write(DELIMITER);\r\n    }\r\n    out.write(\"\\n\");\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.staggeredgridview.ExtendableListView.rememberSyncState",
	"Comment": "remember enough information to restore the screen state when the data haschanged.",
	"Method": "void rememberSyncState(){\r\n    if (getChildCount() > 0) {\r\n        mNeedSync = true;\r\n        mSyncHeight = getHeight();\r\n        View v = getChildAt(0);\r\n        ListAdapter adapter = getAdapter();\r\n        if (mFirstPosition >= 0 && mFirstPosition < adapter.getCount()) {\r\n            mSyncRowId = adapter.getItemId(mFirstPosition);\r\n        } else {\r\n            mSyncRowId = NO_ID;\r\n        }\r\n        if (v != null) {\r\n            mSpecificTop = v.getTop();\r\n        }\r\n        mSyncPosition = mFirstPosition;\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.animation.AnimatorSet.isRunning",
	"Comment": "returns true if any of the child animations of this animatorset have been started and havenot yet ended.",
	"Method": "boolean isRunning(){\r\n    for (Node node : mNodes) {\r\n        if (node.animation.isRunning()) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.animation.ValueAnimator.getRepeatCount",
	"Comment": "defines how many times the animation should repeat. the default valueis 0.",
	"Method": "int getRepeatCount(){\r\n    return mRepeatCount;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.showcaseview.ShowcaseView.setFadeDurations",
	"Comment": "set the duration of the fading in and fading out of the showcaseview",
	"Method": "void setFadeDurations(long fadeInMillis,long fadeOutMillis){\r\n    this.fadeInMillis = fadeInMillis;\r\n    this.fadeOutMillis = fadeOutMillis;\r\n}"
}, {
	"Path": "test.thread.parallelization.TestNgRunStateTracker.getTestMethodEventLogsForMethod",
	"Comment": "out in a map where the keys are the class instances on which the method was run.",
	"Method": "Multimap<Object, EventLog> getTestMethodEventLogsForMethod(String suiteName,String testName,String className,String methodName){\r\n    Multimap<Object, EventLog> testMethodEventLogs = ArrayListMultimap.create();\r\n    for (EventLog eventLog : eventLogs) {\r\n        if (belongsToMethod(suiteName, testName, className, methodName, eventLog)) {\r\n            testMethodEventLogs.put(eventLog.getData(EventInfo.CLASS_INSTANCE), eventLog);\r\n        }\r\n    }\r\n    return testMethodEventLogs;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.stickygridheaders.StickyGridHeadersBaseAdapterWrapper.unFilledSpacesInHeaderGroup",
	"Comment": "counts the number of items that would be need to fill out the last row inthe group of items with the given header.",
	"Method": "int unFilledSpacesInHeaderGroup(int header){\r\n    if (mNumColumns == 0) {\r\n        return 0;\r\n    }\r\n    int remainder = mDelegate.getCountForHeader(header) % mNumColumns;\r\n    return remainder == 0 ? 0 : mNumColumns - remainder;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.tileView.tileview.TileView.translate",
	"Comment": "translate a relative x and y position into a point object with x and y values populated as pixel values, relative to the size of the tileview.",
	"Method": "Point translate(double x,double y,List<Point> translate,List<double[]> positions){\r\n    return positionManager.translate(positions);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.rebound.ui.SpringConfiguratorView.generateHierarchy",
	"Comment": "programmatically build up the view hierarchy to avoid the need for resources.",
	"Method": "View generateHierarchy(Context context){\r\n    Resources resources = getResources();\r\n    LayoutParams params;\r\n    int fivePx = dpToPx(5, resources);\r\n    int tenPx = dpToPx(10, resources);\r\n    int twentyPx = dpToPx(20, resources);\r\n    TableLayout.LayoutParams tableLayoutParams = new TableLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1f);\r\n    tableLayoutParams.setMargins(0, 0, fivePx, 0);\r\n    LinearLayout seekWrapper;\r\n    FrameLayout root = new FrameLayout(context);\r\n    params = createLayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, dpToPx(300, resources));\r\n    root.setLayoutParams(params);\r\n    FrameLayout container = new FrameLayout(context);\r\n    params = createMatchParams();\r\n    params.setMargins(0, twentyPx, 0, 0);\r\n    container.setLayoutParams(params);\r\n    container.setBackgroundColor(Color.argb(100, 0, 0, 0));\r\n    root.addView(container);\r\n    mSpringSelectorSpinner = new Spinner(context, Spinner.MODE_DIALOG);\r\n    params = createMatchWrapParams();\r\n    params.gravity = Gravity.TOP;\r\n    params.setMargins(tenPx, tenPx, tenPx, 0);\r\n    mSpringSelectorSpinner.setLayoutParams(params);\r\n    container.addView(mSpringSelectorSpinner);\r\n    LinearLayout linearLayout = new LinearLayout(context);\r\n    params = createMatchWrapParams();\r\n    params.setMargins(0, 0, 0, dpToPx(80, resources));\r\n    params.gravity = Gravity.BOTTOM;\r\n    linearLayout.setLayoutParams(params);\r\n    linearLayout.setOrientation(LinearLayout.VERTICAL);\r\n    container.addView(linearLayout);\r\n    seekWrapper = new LinearLayout(context);\r\n    params = createMatchWrapParams();\r\n    params.setMargins(tenPx, tenPx, tenPx, twentyPx);\r\n    seekWrapper.setPadding(tenPx, tenPx, tenPx, tenPx);\r\n    seekWrapper.setLayoutParams(params);\r\n    seekWrapper.setOrientation(LinearLayout.HORIZONTAL);\r\n    linearLayout.addView(seekWrapper);\r\n    mTensionSeekBar = new SeekBar(context);\r\n    mTensionSeekBar.setLayoutParams(tableLayoutParams);\r\n    seekWrapper.addView(mTensionSeekBar);\r\n    mTensionLabel = new TextView(getContext());\r\n    mTensionLabel.setTextColor(mTextColor);\r\n    params = createLayoutParams(dpToPx(50, resources), ViewGroup.LayoutParams.MATCH_PARENT);\r\n    mTensionLabel.setGravity(Gravity.CENTER_VERTICAL | Gravity.LEFT);\r\n    mTensionLabel.setLayoutParams(params);\r\n    mTensionLabel.setMaxLines(1);\r\n    seekWrapper.addView(mTensionLabel);\r\n    seekWrapper = new LinearLayout(context);\r\n    params = createMatchWrapParams();\r\n    params.setMargins(tenPx, tenPx, tenPx, twentyPx);\r\n    seekWrapper.setPadding(tenPx, tenPx, tenPx, tenPx);\r\n    seekWrapper.setLayoutParams(params);\r\n    seekWrapper.setOrientation(LinearLayout.HORIZONTAL);\r\n    linearLayout.addView(seekWrapper);\r\n    mFrictionSeekBar = new SeekBar(context);\r\n    mFrictionSeekBar.setLayoutParams(tableLayoutParams);\r\n    seekWrapper.addView(mFrictionSeekBar);\r\n    mFrictionLabel = new TextView(getContext());\r\n    mFrictionLabel.setTextColor(mTextColor);\r\n    params = createLayoutParams(dpToPx(50, resources), ViewGroup.LayoutParams.MATCH_PARENT);\r\n    mFrictionLabel.setGravity(Gravity.CENTER_VERTICAL | Gravity.LEFT);\r\n    mFrictionLabel.setLayoutParams(params);\r\n    mFrictionLabel.setMaxLines(1);\r\n    seekWrapper.addView(mFrictionLabel);\r\n    View nub = new View(context);\r\n    params = createLayoutParams(dpToPx(60, resources), dpToPx(40, resources));\r\n    params.gravity = Gravity.TOP | Gravity.CENTER;\r\n    nub.setLayoutParams(params);\r\n    nub.setOnTouchListener(new OnNubTouchListener());\r\n    nub.setBackgroundColor(Color.argb(255, 0, 164, 209));\r\n    root.addView(nub);\r\n    return root;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.flipViews.flipview.FlipView.setOnFlipListener",
	"Comment": "the onfliplistener will notify you when a page has been fully turned.",
	"Method": "void setOnFlipListener(OnFlipListener onFlipListener){\r\n    mOnFlipListener = onFlipListener;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.slideactivity.SlidingLayout.setSliderFadeColor",
	"Comment": "set the color used to fade the sliding pane out when it is slid most of the way offscreen.",
	"Method": "void setSliderFadeColor(int color){\r\n    mSliderFadeColor = color;\r\n}"
}, {
	"Path": "org.testng.internal.TestNgMethodUtils.containsConfigurationMethod",
	"Comment": "a helper method which checks if a given method is a configuration method and is part of list oftestng methods",
	"Method": "boolean containsConfigurationMethod(ITestNGMethod method,List<ITestNGMethod> methods){\r\n    return isConfigurationMethod(method, true) && methods.contains(method);\r\n}"
}, {
	"Path": "org.testng.reporters.JUnitXMLReporter.generateReport",
	"Comment": "generate the xml report given what we know from all the test results",
	"Method": "void generateReport(ITestContext context){\r\n    XMLStringBuffer document = new XMLStringBuffer();\r\n    document.addComment(\"Generated by \" + getClass().getName());\r\n    Properties attrs = new Properties();\r\n    attrs.setProperty(XMLConstants.ATTR_ERRORS, \"0\");\r\n    attrs.setProperty(XMLConstants.ATTR_FAILURES, Integer.toString(m_numFailed));\r\n    attrs.setProperty(XMLConstants.ATTR_IGNORED, Integer.toString(context.getExcludedMethods().size()));\r\n    try {\r\n        attrs.setProperty(XMLConstants.ATTR_HOSTNAME, InetAddress.getLocalHost().getHostName());\r\n    } catch (UnknownHostException e) {\r\n    }\r\n    Set<String> packages = getPackages(context);\r\n    if (packages.size() > 0) {\r\n        attrs.setProperty(XMLConstants.ATTR_NAME, context.getCurrentXmlTest().getName());\r\n    }\r\n    attrs.setProperty(XMLConstants.ATTR_TESTS, Integer.toString(m_allTests.size()));\r\n    attrs.setProperty(XMLConstants.ATTR_TIME, Double.toString((context.getEndDate().getTime() - context.getStartDate().getTime()) / 1000.0));\r\n    attrs.setProperty(XMLConstants.ATTR_TIMESTAMP, formattedTime());\r\n    document.push(XMLConstants.TESTSUITE, attrs);\r\n    createElementFromTestResults(document, m_configIssues);\r\n    createElementFromTestResults(document, m_allTests);\r\n    createElementFromIgnoredTests(document, context);\r\n    document.pop();\r\n    Utils.writeUtf8File(context.getOutputDirectory(), generateFileName(context) + \".xml\", document.toXML());\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.swipeback.SwipeBackLayout.setEdgeSize",
	"Comment": "set the size of an edge. this is the range in pixels along the edges ofthis view that will actively detect edge touches or drags if edgetracking is enabled.",
	"Method": "void setEdgeSize(int size){\r\n    mDragHelper.setEdgeSize(size);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.imageprocessing.helper.ImageHelper.bitmapToTexture",
	"Comment": "this method takes in a bitmap and binds it to an opengl texture.this method can only be called if\tthere is an active opengl context.",
	"Method": "int bitmapToTexture(Bitmap bitmap){\r\n    int[] tex = new int[1];\r\n    GLES20.glGenTextures(1, tex, 0);\r\n    GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, tex[0]);\r\n    GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_NEAREST);\r\n    GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_NEAREST);\r\n    GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, bitmap, 0);\r\n    return tex[0];\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.superlistview.BaseSuperAbsListview.setAdapter",
	"Comment": "set the adapter to the listviewautomativally hide the progressbarset the refresh to falseif adapter is empty, then the emptyview is shown",
	"Method": "void setAdapter(ListAdapter adapter){\r\n    mProgress.setVisibility(View.GONE);\r\n    if (mEmpty != null && mEmptyId != 0)\r\n        mList.setEmptyView(mEmpty);\r\n    mList.setVisibility(View.VISIBLE);\r\n    mPtrLayout.setRefreshing(false);\r\n    adapter.registerDataSetObserver(new DataSetObserver() {\r\n        @Override\r\n        public void onChanged() {\r\n            super.onChanged();\r\n            mProgress.setVisibility(View.GONE);\r\n            isLoadingMore = false;\r\n            mPtrLayout.setRefreshing(false);\r\n            if (mList.getAdapter().getCount() == 0 && mEmptyId != 0) {\r\n                mEmpty.setVisibility(View.VISIBLE);\r\n            } else if (mEmptyId != 0) {\r\n                mEmpty.setVisibility(View.GONE);\r\n            }\r\n        }\r\n    });\r\n    if ((adapter == null || adapter.getCount() == 0) && mEmptyId != 0) {\r\n        mEmpty.setVisibility(View.VISIBLE);\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.superlistview.BaseSuperAbsListview.setAdapter",
	"Comment": "set the adapter to the listviewautomativally hide the progressbarset the refresh to falseif adapter is empty, then the emptyview is shown",
	"Method": "void setAdapter(ListAdapter adapter){\r\n    super.onChanged();\r\n    mProgress.setVisibility(View.GONE);\r\n    isLoadingMore = false;\r\n    mPtrLayout.setRefreshing(false);\r\n    if (mList.getAdapter().getCount() == 0 && mEmptyId != 0) {\r\n        mEmpty.setVisibility(View.VISIBLE);\r\n    } else if (mEmptyId != 0) {\r\n        mEmpty.setVisibility(View.GONE);\r\n    }\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase4Scenario1.verifyOnlyOneInstanceOfTestClassForAllTestMethodsForAllSuites",
	"Comment": "verify that the same test class instance is associated with each of the test methods from the sample test class",
	"Method": "void verifyOnlyOneInstanceOfTestClassForAllTestMethodsForAllSuites(){\r\n    verifyNumberOfInstancesOfTestClassesForMethods(SUITE_A, SUITE_A_TEST_A, Arrays.asList(TestClassAFiveMethodsWithDataProviderOnSomeMethodsAndNoDepsSample.class, TestClassBSixMethodsWithDataProviderOnSomeMethodsAndNoDepsSample.class), 1);\r\n    verifySameInstancesOfTestClassesAssociatedWithMethods(SUITE_A, SUITE_A_TEST_A, Arrays.asList(TestClassAFiveMethodsWithDataProviderOnSomeMethodsAndNoDepsSample.class, TestClassBSixMethodsWithDataProviderOnSomeMethodsAndNoDepsSample.class));\r\n    verifyNumberOfInstancesOfTestClassForMethods(SUITE_B, SUITE_B_TEST_A, TestClassCFiveMethodsWithDataProviderOnSomeMethodsAndNoDepsSample.class, 1);\r\n    verifySameInstancesOfTestClassAssociatedWithMethods(SUITE_B, SUITE_B_TEST_A, TestClassCFiveMethodsWithDataProviderOnSomeMethodsAndNoDepsSample.class);\r\n    verifyNumberOfInstancesOfTestClassesForMethods(SUITE_B, SUITE_B_TEST_B, Arrays.asList(TestClassDThreeMethodsWithDataProviderOnSomeMethodsAndNoDepsSample.class, TestClassEFourMethodsWithDataProviderOnSomeMethodsAndNoDepsSample.class, TestClassFSixMethodsWithDataProviderOnSomeMethodsAndNoDepsSample.class), 1);\r\n    verifySameInstancesOfTestClassesAssociatedWithMethods(SUITE_B, SUITE_B_TEST_B, Arrays.asList(TestClassDThreeMethodsWithDataProviderOnSomeMethodsAndNoDepsSample.class, TestClassEFourMethodsWithDataProviderOnSomeMethodsAndNoDepsSample.class, TestClassFSixMethodsWithDataProviderOnSomeMethodsAndNoDepsSample.class));\r\n    verifyNumberOfInstancesOfTestClassesForMethods(SUITE_C, SUITE_C_TEST_A, Arrays.asList(TestClassDThreeMethodsWithDataProviderOnAllMethodsAndNoDepsSample.class, TestClassGFourMethodsWithDataProviderOnSomeMethodsAndNoDepsSample.class, TestClassAFiveMethodsWithDataProviderOnAllMethodsAndNoDepsSample.class), 1);\r\n    verifySameInstancesOfTestClassesAssociatedWithMethods(SUITE_C, SUITE_C_TEST_A, Arrays.asList(TestClassDThreeMethodsWithDataProviderOnAllMethodsAndNoDepsSample.class, TestClassGFourMethodsWithDataProviderOnSomeMethodsAndNoDepsSample.class, TestClassAFiveMethodsWithDataProviderOnAllMethodsAndNoDepsSample.class));\r\n    verifyNumberOfInstancesOfTestClassesForMethods(SUITE_C, SUITE_C_TEST_B, Arrays.asList(TestClassBFourMethodsWithDataProviderOnAllMethodsAndNoDepsSample.class, TestClassHFiveMethodsWithDataProviderOnSomeMethodsAndNoDepsSample.class), 1);\r\n    verifySameInstancesOfTestClassesAssociatedWithMethods(SUITE_C, SUITE_C_TEST_B, Arrays.asList(TestClassBFourMethodsWithDataProviderOnAllMethodsAndNoDepsSample.class, TestClassHFiveMethodsWithDataProviderOnSomeMethodsAndNoDepsSample.class));\r\n    verifyNumberOfInstancesOfTestClassesForMethods(SUITE_C, SUITE_C_TEST_C, Arrays.asList(TestClassIThreeMethodsWithDataProviderOnSomeMethodsAndNoDepsSample.class, TestClassJFourMethodsWithDataProviderOnSomeMethodsAndNoDepsSample.class, TestClassKFiveMethodsWithDataProviderOnSomeMethodsAndNoDepsSample.class, TestClassBSixMethodsWithDataProviderOnAllMethodsAndNoDepsSample.class), 1);\r\n    verifySameInstancesOfTestClassesAssociatedWithMethods(SUITE_C, SUITE_C_TEST_C, Arrays.asList(TestClassIThreeMethodsWithDataProviderOnSomeMethodsAndNoDepsSample.class, TestClassJFourMethodsWithDataProviderOnSomeMethodsAndNoDepsSample.class, TestClassKFiveMethodsWithDataProviderOnSomeMethodsAndNoDepsSample.class, TestClassBSixMethodsWithDataProviderOnAllMethodsAndNoDepsSample.class));\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.slider.Transformers.BaseTransformer.isPagingEnabled",
	"Comment": "indicates if the default animations of the view pager should be used.",
	"Method": "boolean isPagingEnabled(){\r\n    return false;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.staggeredgridview.ExtendableListView.fillFromTop",
	"Comment": "fills the list from top to bottom, starting with mfirstposition",
	"Method": "View fillFromTop(int nextTop){\r\n    mFirstPosition = Math.min(mFirstPosition, mItemCount - 1);\r\n    if (mFirstPosition < 0) {\r\n        mFirstPosition = 0;\r\n    }\r\n    return fillDown(mFirstPosition, nextTop);\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.recyclerplayground.layout.FixedGridLayoutManager.generateDefaultLayoutParams",
	"Comment": "we must override this method to provide the default layoutparameters that each child view will receive when added.",
	"Method": "RecyclerView.LayoutParams generateDefaultLayoutParams(){\r\n    return new RecyclerView.LayoutParams(RecyclerView.LayoutParams.WRAP_CONTENT, RecyclerView.LayoutParams.WRAP_CONTENT);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.rippleDrawable.RippleDrawable.onHotspotBoundsChanged",
	"Comment": "notifies all the animating ripples that the hotspot bounds have changed.",
	"Method": "void onHotspotBoundsChanged(){\r\n    final int count = mExitingRipplesCount;\r\n    final Ripple[] ripples = mExitingRipples;\r\n    for (int i = 0; i < count; i++) {\r\n        ripples[i].onHotspotBoundsChanged();\r\n    }\r\n    if (mRipple != null) {\r\n        mRipple.onHotspotBoundsChanged();\r\n    }\r\n    if (mBackground != null) {\r\n        mBackground.onHotspotBoundsChanged();\r\n    }\r\n}"
}, {
	"Path": "com.android.datetimepicker.date.DayPickerView.goTo",
	"Comment": "this moves to the specified time in the view. if the time is not alreadyin range it will move the list so that the first of the month containingthe time is at the top of the view. if the new time is already in viewthe list will not be scrolled unless forcescroll is true. this time mayoptionally be highlighted as selected as well.",
	"Method": "boolean goTo(CalendarDay day,boolean animate,boolean setSelected,boolean forceScroll){\r\n    if (setSelected) {\r\n        mSelectedDay.set(day);\r\n    }\r\n    mTempDay.set(day);\r\n    final int position = (day.year - mController.getMinYear()) * MonthAdapter.MONTHS_IN_YEAR + day.month;\r\n    View child;\r\n    int i = 0;\r\n    int top = 0;\r\n    do {\r\n        child = getChildAt(i++);\r\n        if (child == null) {\r\n            break;\r\n        }\r\n        top = child.getTop();\r\n        if (Log.isLoggable(TAG, Log.DEBUG)) {\r\n            Log.d(TAG, \"child at \" + (i - 1) + \" has top \" + top);\r\n        }\r\n    } while (top < 0);\r\n    int selectedPosition;\r\n    if (child != null) {\r\n        selectedPosition = getPositionForView(child);\r\n    } else {\r\n        selectedPosition = 0;\r\n    }\r\n    if (setSelected) {\r\n        mAdapter.setSelectedDay(mSelectedDay);\r\n    }\r\n    if (Log.isLoggable(TAG, Log.DEBUG)) {\r\n        Log.d(TAG, \"GoTo position \" + position);\r\n    }\r\n    if (position != selectedPosition || forceScroll) {\r\n        setMonthDisplayed(mTempDay);\r\n        mPreviousScrollState = OnScrollListener.SCROLL_STATE_FLING;\r\n        if (animate) {\r\n            smoothScrollToPositionFromTop(position, LIST_TOP_OFFSET, GOTO_SCROLL_DURATION);\r\n            return true;\r\n        } else {\r\n            postSetSelection(position);\r\n        }\r\n    } else if (setSelected) {\r\n        setMonthDisplayed(mSelectedDay);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.stickygridheaders.StickyGridHeadersBaseAdapterWrapper.getItem",
	"Comment": "get the data item associated with the specified position in the data set.since this wrapper inserts fake entries to fill out items grouped byheader and also spaces to insert headers into some positions will returnnull.",
	"Method": "Object getItem(int position){\r\n    Position adapterPosition = translatePosition(position);\r\n    if (adapterPosition.mPosition == POSITION_FILLER || adapterPosition.mPosition == POSITION_HEADER) {\r\n        return null;\r\n    }\r\n    return mDelegate.getItem(adapterPosition.mPosition);\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.ThumbnailParameter.isKeepAspectRatio",
	"Comment": "returns whether or not the thumbnail is to maintain the aspect ratio of\tthe source image when creating the thumbnail.",
	"Method": "boolean isKeepAspectRatio(){\r\n    return keepAspectRatio;\r\n}"
}, {
	"Path": "com.marshalchen.common.commonUtils.urlUtils.UniversalImageLoader.getDefaultImageLoaderConfigurationBuilder",
	"Comment": "get default imageloaderconfiguration.builder,and you can easily change the builder.",
	"Method": "ImageLoaderConfiguration.Builder getDefaultImageLoaderConfigurationBuilder(Context context){\r\n    File cacheDir = StorageUtils.getCacheDirectory(context);\r\n    ImageLoaderConfiguration.Builder builder = // .discCacheExtraOptions(480, 800, Bitmap.CompressFormat.JPEG, 75, null)\r\n    new ImageLoaderConfiguration.Builder(context).threadPoolSize(// default\r\n    3).threadPriority(Thread.NORM_PRIORITY - // default\r\n    1).tasksProcessingOrder(QueueProcessingType.FIFO).denyCacheImageMultipleSizesInMemory().memoryCacheSizePercentage(// default\r\n    13).discCache(new UnlimitedDiscCache(// .discCacheSize(50 * 1024 * 1024)\r\n    cacheDir)).discCacheFileCount(// default\r\n    1000).discCacheFileNameGenerator(// default\r\n    new HashCodeFileNameGenerator()).imageDownloader(// default\r\n    new BaseImageDownloader(context)).imageDecoder(// .defaultDisplayImageOptions(DisplayImageOptions.createSimple()) // default\r\n    new BaseImageDecoder(false)).defaultDisplayImageOptions(getDefaultImageOptions());\r\n    return builder;\r\n}"
}, {
	"Path": "org.testng.reporters.JUnitXMLReporter.generateFileName",
	"Comment": "this method guarantees unique file names for reports.also, this will guarantee that the old reports are overwritten when tests are run again.",
	"Method": "String generateFileName(ITestContext context){\r\n    String fileName;\r\n    String keyToSearch = context.getSuite().getName() + context.getName();\r\n    if (m_fileNameMap.get(keyToSearch) == null) {\r\n        fileName = context.getName();\r\n    } else {\r\n        fileName = context.getName() + m_fileNameIncrementer++;\r\n    }\r\n    m_fileNameMap.put(keyToSearch, fileName);\r\n    return fileName;\r\n}"
}, {
	"Path": "org.testng.log4testng.Logger.testDebugOn",
	"Comment": "makes sure the debug value can be turned on and actualls logs something.",
	"Method": "void testDebugOn(){\r\n    Properties props = new Properties();\r\n    ByteArrayOutputStream out1 = new ByteArrayOutputStream();\r\n    ByteArrayOutputStream err1 = new ByteArrayOutputStream();\r\n    PrintStream out2 = new PrintStream(out1);\r\n    PrintStream err2 = new PrintStream(err1);\r\n    props.put(\"log4testng.debug\", \"true\");\r\n    props.put(\"log4testng.rootLogger\", \"WARN\");\r\n    testInitialize(props, out2, err2);\r\n    Assert.assertTrue(out1.toString().startsWith(\"[log4testng][debug]\"));\r\n    Assert.assertEquals(err1.toString(), \"\");\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase5Scenario2.verifyThatMethodLevelEventsRunInDifferentThreadsFromSuiteAndTestLevelEvents",
	"Comment": "verifies that the test method listener and execution events for a given test method all run in the same thread.",
	"Method": "void verifyThatMethodLevelEventsRunInDifferentThreadsFromSuiteAndTestLevelEvents(){\r\n    verifyEventThreadsSpawnedAfter(getAllSuiteListenerStartEventLogs().get(0).getThreadId(), testMethodLevelEventLogs, \"All the thread IDs for the test method level events should be greater than the thread ID for the \" + \"suite and test level events. The expectation is that since the suite and test level events \" + \"are running sequentially, and all the test methods are running in parallel, new threads \" + \"will be spawned after the thread executing the suite and test level events when new methods \" + \"begin executing. Suite and test level events thread ID: \" + getAllSuiteListenerStartEventLogs().get(0).getThreadId() + \". Test method level event logs: \" + testMethodLevelEventLogs);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassAFiveMethodsWithNoDepsSample.class, SUITE_A, SUITE_A_TEST_A);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassCSixMethodsWithNoDepsSample.class, SUITE_A, SUITE_A_TEST_A);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassEFiveMethodsWithNoDepsSample.class, SUITE_B, SUITE_B_TEST_A);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassDThreeMethodsWithNoDepsSample.class, SUITE_B, SUITE_B_TEST_B);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassBFourMethodsWithNoDepsSample.class, SUITE_B, SUITE_B_TEST_B);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassFSixMethodsWithNoDepsSample.class, SUITE_B, SUITE_B_TEST_B);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.dynamicgrid.AbstractDynamicGridAdapter.removeStableID",
	"Comment": "remove stable id for item. should called on remove data item from adapter",
	"Method": "void removeStableID(Object item){\r\n    mIdMap.remove(item);\r\n}"
}, {
	"Path": "com.marshalchen.common.ui.CircularImageView.setSelectorColor",
	"Comment": "sets the color of the selector to be draw over the\tcircularimageview. be sure to provide some opacity.",
	"Method": "void setSelectorColor(int selectorColor){\r\n    this.selectorFilter = new PorterDuffColorFilter(selectorColor, PorterDuff.Mode.SRC_ATOP);\r\n    this.invalidate();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.cropimage.ImageViewTouchBase.setImageBitmapResetBase",
	"Comment": "of the bitmap, and optionally reset the supplementary matrix",
	"Method": "void setImageBitmapResetBase(Bitmap bitmap,boolean resetSupp){\r\n    setImageRotateBitmapResetBase(new RotateBitmap(bitmap, 0), resetSupp);\r\n}"
}, {
	"Path": "com.marshalchen.common.commonUtils.basicUtils.ArrayUtils.getNext",
	"Comment": "get next element of the target element, after the first one that match the target element front to backif array is empty, return defaultvalueif target element is not exist in array, return defaultvalueif target element exist in array and not the last one in array, return the next elementif target element exist in array and the last one in array, return the first one in array if iscircle istrue, else return defaultvalue",
	"Method": "V getNext(V[] sourceArray,V value,V defaultValue,boolean isCircle,V getNext,V[] sourceArray,V value,boolean isCircle,long getNext,long[] sourceArray,long value,long defaultValue,boolean isCircle,int getNext,int[] sourceArray,int value,int defaultValue,boolean isCircle){\r\n    if (sourceArray.length == 0) {\r\n        throw new IllegalArgumentException(\"The length of source array must be greater than 0.\");\r\n    }\r\n    Integer[] array = ObjectUtils.transformIntArray(sourceArray);\r\n    return getNext(array, value, defaultValue, isCircle);\r\n}"
}, {
	"Path": "org.testng.xml.Parser.parse",
	"Comment": "parses the testng test suite and returns the corresponding xmlsuite, and possibly, otherxmlsuite that are pointed to bytags.",
	"Method": "Collection<XmlSuite> parse(Collection<XmlSuite> parse,String suite,IPostProcessor processor,Collection<XmlSuite> parse,InputStream is,IPostProcessor processor){\r\n    return newParser(is, processor).parse();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.dragSortListView.DragSortListView.startDrag",
	"Comment": "start a drag of item at position without usinga floatviewmanager.",
	"Method": "boolean startDrag(int position,int dragFlags,int deltaX,int deltaY,boolean startDrag,int position,View floatView,int dragFlags,int deltaX,int deltaY){\r\n    if (mDragState != IDLE || !mInTouchEvent || mFloatView != null || floatView == null || !mDragEnabled) {\r\n        return false;\r\n    }\r\n    if (getParent() != null) {\r\n        getParent().requestDisallowInterceptTouchEvent(true);\r\n    }\r\n    int pos = position + getHeaderViewsCount();\r\n    mFirstExpPos = pos;\r\n    mSecondExpPos = pos;\r\n    mSrcPos = pos;\r\n    mFloatPos = pos;\r\n    mDragState = DRAGGING;\r\n    mDragFlags = 0;\r\n    mDragFlags |= dragFlags;\r\n    mFloatView = floatView;\r\n    measureFloatView();\r\n    mDragDeltaX = deltaX;\r\n    mDragDeltaY = deltaY;\r\n    mDragStartY = mY;\r\n    mFloatLoc.x = mX - mDragDeltaX;\r\n    mFloatLoc.y = mY - mDragDeltaY;\r\n    final View srcItem = getChildAt(mSrcPos - getFirstVisiblePosition());\r\n    if (srcItem != null) {\r\n        srcItem.setVisibility(View.INVISIBLE);\r\n    }\r\n    if (mTrackDragSort) {\r\n        mDragSortTracker.startTracking();\r\n    }\r\n    switch(mCancelMethod) {\r\n        case ON_TOUCH_EVENT:\r\n            super.onTouchEvent(mCancelEvent);\r\n            break;\r\n        case ON_INTERCEPT_TOUCH_EVENT:\r\n            super.onInterceptTouchEvent(mCancelEvent);\r\n            break;\r\n    }\r\n    requestLayout();\r\n    if (mLiftAnimator != null) {\r\n        mLiftAnimator.start();\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.modifysys.ViewPager.executeKeyEvent",
	"Comment": "you can call this function yourself to have the scroll view performscrolling from a key event, just as if the event had been dispatched toit by the view hierarchy.",
	"Method": "boolean executeKeyEvent(KeyEvent event){\r\n    boolean handled = false;\r\n    if (event.getAction() == KeyEvent.ACTION_DOWN) {\r\n        switch(event.getKeyCode()) {\r\n            case KeyEvent.KEYCODE_DPAD_LEFT:\r\n                handled = arrowScroll(FOCUS_LEFT);\r\n                break;\r\n            case KeyEvent.KEYCODE_DPAD_RIGHT:\r\n                handled = arrowScroll(FOCUS_RIGHT);\r\n                break;\r\n            case KeyEvent.KEYCODE_TAB:\r\n                if (Build.VERSION.SDK_INT >= 11) {\r\n                    if (KeyEventCompat.hasNoModifiers(event)) {\r\n                        handled = arrowScroll(FOCUS_FORWARD);\r\n                    } else if (KeyEventCompat.hasModifiers(event, KeyEvent.META_SHIFT_ON)) {\r\n                        handled = arrowScroll(FOCUS_BACKWARD);\r\n                    }\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    return handled;\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.builders.ThumbnailParameterBuilder.keepAspectRatio",
	"Comment": "sets whether or not the thumbnail is to maintain the aspect ratio of\tthe original image.",
	"Method": "ThumbnailParameterBuilder keepAspectRatio(boolean keep){\r\n    this.keepAspectRatio = keep;\r\n    return this;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.view.ViewPropertyAnimatorHC.getDuration",
	"Comment": "returns the current duration of property animations. if the duration was set on thisobject, that value is returned. otherwise, the default value of the underlying animatoris returned.",
	"Method": "long getDuration(){\r\n    if (mDurationSet) {\r\n        return mDuration;\r\n    } else {\r\n        return new ValueAnimator().getDuration();\r\n    }\r\n}"
}, {
	"Path": "test.thread.MultiThreadedDependentTest.assertOrder",
	"Comment": "make sure that the topological order is preserved and that ifthe testng runner is configured to run n threads, the dependentmethods are using these n threads.",
	"Method": "void assertOrder(List<String> methods){\r\n    List<String> expectedMethods = Arrays.asList(new String[] { \"a1\", \"a2\", \"a3\", \"b1\", \"b2\", \"b3\", \"b4\", \"b5\", \"c1\", \"d\", \"x\", \"y\", \"z\", \"t\" });\r\n    int size = expectedMethods.size();\r\n    Assert.assertEquals(methods.size(), size);\r\n    for (String em : expectedMethods) {\r\n        Assert.assertTrue(methods.contains(em));\r\n    }\r\n    Map<String, Boolean> map = Maps.newHashMap();\r\n    for (String m : methods) {\r\n        map.put(m, Boolean.TRUE);\r\n        if (\"b1\".equals(m) || \"b2\".equals(m) || \"b3\".equals(m) || \"b4\".equals(m) || \"b5\".equals(m)) {\r\n            Assert.assertTrue(map.get(\"a1\"));\r\n            Assert.assertTrue(map.get(\"a2\"));\r\n            Assert.assertTrue(map.get(\"a3\"));\r\n        }\r\n        if (\"d\".equals(m)) {\r\n            Assert.assertTrue(map.get(\"a1\"));\r\n            Assert.assertTrue(map.get(\"a2\"));\r\n        }\r\n        if (\"c1\".equals(m)) {\r\n            Assert.assertTrue(map.get(\"b1\"));\r\n            Assert.assertTrue(map.get(\"b2\"));\r\n        }\r\n    }\r\n    Assert.assertEquals(map.size(), size);\r\n    for (Boolean val : map.values()) {\r\n        Assert.assertTrue(val);\r\n    }\r\n}"
}, {
	"Path": "org.testng.TestNG.setOutputDirectory",
	"Comment": "sets the output directory where the reports will be created.",
	"Method": "void setOutputDirectory(String outputdir){\r\n    if (isStringNotEmpty(outputdir)) {\r\n        m_outputDir = outputdir;\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.animation.ValueAnimator.ofPropertyValuesHolder",
	"Comment": "constructs and returns a valueanimator that animates between the valuesspecified in the propertyvaluesholder objects.",
	"Method": "ValueAnimator ofPropertyValuesHolder(PropertyValuesHolder values){\r\n    ValueAnimator anim = new ValueAnimator();\r\n    anim.setValues(values);\r\n    return anim;\r\n}"
}, {
	"Path": "com.marshalchen.ua.common.usefulModule.CircularImageView.setSelectorColor",
	"Comment": "sets the color of the selector to be draw over the\tcircularimageview. be sure to provide some opacity.",
	"Method": "void setSelectorColor(int selectorColor){\r\n    this.selectorFilter = new PorterDuffColorFilter(selectorColor, PorterDuff.Mode.SRC_ATOP);\r\n    this.invalidate();\r\n}"
}, {
	"Path": "org.isoron.uhabits.activities.habits.list.views.HabitCardListAdapter.getItem",
	"Comment": "returns the item that occupies a certain position on the list",
	"Method": "Habit getItem(int position){\r\n    return cache.getHabitByPosition(position);\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase5Scenario1.verifyThatAllEventsForATestMethodInClassInstanceExecuteInSameThread",
	"Comment": "thread ids because there are two instances of the test class that run.",
	"Method": "void verifyThatAllEventsForATestMethodInClassInstanceExecuteInSameThread(){\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassAFiveMethodsWithNoDepsSample.class, SUITE, TEST);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.easyandroidanimations.UnfoldAnimation.getAnchorFactor",
	"Comment": "the available anchor factors range from 0 to 1. for example, in order to\tanchor the fold on the left, the anchor factor should be 0.",
	"Method": "float getAnchorFactor(){\r\n    return anchorFactor;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.view.ViewPropertyAnimatorHC.startAnimation",
	"Comment": "starts the underlying animator for a set of properties. we use a single animator thatsimply runs from 0 to 1, and then use that fractional value to set each propertyvalue accordingly.",
	"Method": "void startAnimation(){\r\n    ValueAnimator animator = ValueAnimator.ofFloat(1.0f);\r\n    ArrayList<NameValuesHolder> nameValueList = (ArrayList<NameValuesHolder>) mPendingAnimations.clone();\r\n    mPendingAnimations.clear();\r\n    int propertyMask = 0;\r\n    int propertyCount = nameValueList.size();\r\n    for (int i = 0; i < propertyCount; ++i) {\r\n        NameValuesHolder nameValuesHolder = nameValueList.get(i);\r\n        propertyMask |= nameValuesHolder.mNameConstant;\r\n    }\r\n    mAnimatorMap.put(animator, new PropertyBundle(propertyMask, nameValueList));\r\n    animator.addUpdateListener(mAnimatorEventListener);\r\n    animator.addListener(mAnimatorEventListener);\r\n    if (mStartDelaySet) {\r\n        animator.setStartDelay(mStartDelay);\r\n    }\r\n    if (mDurationSet) {\r\n        animator.setDuration(mDuration);\r\n    }\r\n    if (mInterpolatorSet) {\r\n        animator.setInterpolator(mInterpolator);\r\n    }\r\n    animator.start();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.swipelayout.SwipeLayout.safeBottomView",
	"Comment": "prevent bottom view get any touch event. especially in laydown mode.",
	"Method": "void safeBottomView(){\r\n    Status status = getOpenStatus();\r\n    ViewGroup bottom = getBottomView();\r\n    if (status == Status.Close) {\r\n        if (bottom.getVisibility() != INVISIBLE)\r\n            bottom.setVisibility(INVISIBLE);\r\n    } else {\r\n        if (bottom.getVisibility() != VISIBLE)\r\n            bottom.setVisibility(VISIBLE);\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.rebound.Spring.setOvershootClampingEnabled",
	"Comment": "force the spring to clamp at its end value to avoid overshooting the target value.",
	"Method": "Spring setOvershootClampingEnabled(boolean overshootClampingEnabled){\r\n    mOvershootClampingEnabled = overshootClampingEnabled;\r\n    return this;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.simplemodule.DropDownListView.getHeaderPaddingTopRate",
	"Comment": "get rate about drop down distance and header padding top when drop down",
	"Method": "float getHeaderPaddingTopRate(){\r\n    return headerPaddingTopRate;\r\n}"
}, {
	"Path": "com.marshalchen.ua.common.commonUtils.moduleUtils.WebViewUtils.getWebSettings",
	"Comment": "a webview setting which enable javascript ,domstorage and file access.",
	"Method": "WebSettings getWebSettings(WebView webView,String appCacheDir){\r\n    WebSettings wSet = webView.getSettings();\r\n    wSet.setJavaScriptEnabled(true);\r\n    wSet.setDomStorageEnabled(true);\r\n    wSet.setAppCachePath(appCacheDir);\r\n    wSet.setAllowFileAccess(true);\r\n    wSet.setAppCacheEnabled(true);\r\n    wSet.setCacheMode(WebSettings.LOAD_DEFAULT);\r\n    return wSet;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.rebound.Spring.getRestSpeedThreshold",
	"Comment": "returns the speed at which the spring should be considered at rest in pixels per second",
	"Method": "double getRestSpeedThreshold(){\r\n    return mRestSpeedThreshold;\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase6Scenario1.verifyThatMethodLevelEventsRunInDifferentThreadsFromSuiteAndTestLevelEvents",
	"Comment": "verifies that the test method listener and execution events for a given test method all run in the same thread.",
	"Method": "void verifyThatMethodLevelEventsRunInDifferentThreadsFromSuiteAndTestLevelEvents(){\r\n    verifyEventThreadsSpawnedAfter(getAllSuiteListenerStartEventLogs().get(0).getThreadId(), testMethodLevelEventLogs, \"All the thread IDs for the test method level events should be greater than the thread ID for the \" + \"suite and test level events. The expectation is that since the suite and test level events \" + \"are running sequentially, and all the test methods are running in parallel, new threads \" + \"will be spawned after the thread executing the suite and test level events when new methods \" + \"begin executing. Suite and test level events thread ID: \" + getAllSuiteListenerStartEventLogs().get(0).getThreadId() + \". Test method level event logs: \" + testMethodLevelEventLogs);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassAFiveMethodsWithNoDepsSample.class, SUITE_A, SUITE_A_TEST_A);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassCSixMethodsWithNoDepsSample.class, SUITE_A, SUITE_A_TEST_A);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassEFiveMethodsWithNoDepsSample.class, SUITE_B, SUITE_B_TEST_A);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassDThreeMethodsWithNoDepsSample.class, SUITE_B, SUITE_B_TEST_B);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassBFourMethodsWithNoDepsSample.class, SUITE_B, SUITE_B_TEST_B);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassFSixMethodsWithNoDepsSample.class, SUITE_B, SUITE_B_TEST_B);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassGThreeMethodsWithNoDepsSample.class, SUITE_C, SUITE_C_TEST_A);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassHFourMethodsWithNoDepsSample.class, SUITE_C, SUITE_C_TEST_A);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassIFiveMethodsWithNoDepsSample.class, SUITE_C, SUITE_C_TEST_A);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassJFourMethodsWithNoDepsSample.class, SUITE_C, SUITE_C_TEST_B);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassKFiveMethodsWithNoDepsSample.class, SUITE_C, SUITE_C_TEST_B);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassLThreeMethodsWithNoDepsSample.class, SUITE_C, SUITE_C_TEST_C);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassMFourMethodsWithNoDepsSample.class, SUITE_C, SUITE_C_TEST_C);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassNFiveMethodsWithNoDepsSample.class, SUITE_C, SUITE_C_TEST_C);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassOSixMethodsWithNoDepsSample.class, SUITE_C, SUITE_C_TEST_C);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.square_progressbar.utils.PercentStyle.setTextColor",
	"Comment": "set the color of the text that display the current progress. this will\talso change the color of the text that normally represents a %.",
	"Method": "void setTextColor(int textColor){\r\n    this.textColor = textColor;\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase3Scenario1.verifyTestMethodLevelEventsAllOccurBetweenTestListenerStartAndFinish",
	"Comment": "verifies that all the test method level events execute between the test listener onstart and onfinish methods",
	"Method": "void verifyTestMethodLevelEventsAllOccurBetweenTestListenerStartAndFinish(){\r\n    verifyEventsOccurBetween(testListenerOnStartEventLog, testMethodLevelEventLogs, testListenerOnFinishEventLog, \"All of the test method level event logs should have timestamps between the test listener's onStart \" + \"and onFinish event logs. Test Listener onStart event log: \" + testListenerOnStartEventLog + \". Test Listener onFinish event log: \" + testListenerOnFinishEventLog + \". Test method level \" + \"event logs: \" + testMethodLevelEventLogs);\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase3Scenario1.verifyThatAllEventsForATestMethodExecuteInSameThread",
	"Comment": "verifies that all the test method level events for any given test method run in the same thread.",
	"Method": "void verifyThatAllEventsForATestMethodExecuteInSameThread(){\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassAFiveMethodsWithDataProviderOnAllMethodsAndNoDepsSample.class, SUITE, TEST);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.discreteseekbar.internal.PopupIndicator.dismiss",
	"Comment": "this will start the closing animation of the marker and call onclosingcomplete when finished",
	"Method": "void dismiss(){\r\n    mPopupView.mMarker.animateClose();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.superlistview.BaseSuperAbsListview.setRefreshListener",
	"Comment": "set the listener when refresh is triggered and enable the swiperefreshlayout",
	"Method": "void setRefreshListener(SwipeRefreshLayout.OnRefreshListener listener){\r\n    mPtrLayout.setEnabled(true);\r\n    mPtrLayout.setOnRefreshListener(listener);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.imageprocessing.inputprocess.VideoResourceInput.setVideoSource",
	"Comment": "sets the video to a new video source. the id must be from the same context as the previous id.",
	"Method": "void setVideoSource(int id){\r\n    this.id = id;\r\n}"
}, {
	"Path": "com.android.datetimepicker.time.RadialPickerLayout.trySettingInputEnabled",
	"Comment": "set touch input as enabled or disabled, for use with keyboard mode.",
	"Method": "boolean trySettingInputEnabled(boolean inputEnabled){\r\n    if (mDoingTouch && !inputEnabled) {\r\n        return false;\r\n    }\r\n    mInputEnabled = inputEnabled;\r\n    mGrayBox.setVisibility(inputEnabled ? View.INVISIBLE : View.VISIBLE);\r\n    return true;\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase3Scenario2.verifySuiteAndTestLevelEventsRunInSequentialOrderForIndividualSuites",
	"Comment": "for all suites, verify that the test level events run sequentially because the parallel mode is by methods only.",
	"Method": "void verifySuiteAndTestLevelEventsRunInSequentialOrderForIndividualSuites(){\r\n    verifySequentialTests(suiteOneSuiteAndTestLevelEventLogs, suiteOneTestLevelEventLogs, suiteOneSuiteListenerOnStartEventLog, suiteOneSuiteListenerOnFinishEventLog);\r\n    verifySequentialTests(suiteTwoSuiteAndTestLevelEventLogs, suiteTwoTestLevelEventLogs, suiteTwoSuiteListenerOnStartEventLog, suiteTwoSuiteListenerOnFinishEventLog);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.rebound.Spring.getRestDisplacementThreshold",
	"Comment": "get the threshold of displacement from rest below which the spring should be considered at rest",
	"Method": "double getRestDisplacementThreshold(){\r\n    return mDisplacementFromRestThreshold;\r\n}"
}, {
	"Path": "com.android.datetimepicker.time.RadialPickerLayout.getCurrentlyShowingValue",
	"Comment": "if the hours are showing, return the current hour. if the minutes are showing, return thecurrent minute.",
	"Method": "int getCurrentlyShowingValue(){\r\n    int currentIndex = getCurrentItemShowing();\r\n    if (currentIndex == HOUR_INDEX) {\r\n        return mCurrentHoursOfDay;\r\n    } else if (currentIndex == MINUTE_INDEX) {\r\n        return mCurrentMinutes;\r\n    } else {\r\n        return -1;\r\n    }\r\n}"
}, {
	"Path": "org.testng.internal.Graph.removeFromNodes",
	"Comment": "remove a node from a list of nodes and update the list of predecessors for all the remainingnodes.",
	"Method": "void removeFromNodes(List<Node<T>> nodes,Node<T> node){\r\n    nodes.remove(node);\r\n    for (Node<T> n : nodes) {\r\n        n.removePredecessor(node.getObject());\r\n    }\r\n}"
}, {
	"Path": "org.isoron.uhabits.core.models.Timestamp.daysUntil",
	"Comment": "returns the number of days between this timestamp and the given one. ifthe other timestamp equals this one, returns zero. if the other timestampis older than this one, returns a negative number.",
	"Method": "int daysUntil(Timestamp other){\r\n    return (int) ((other.unixTime - this.unixTime) / DAY_LENGTH);\r\n}"
}, {
	"Path": "com.android.datetimepicker.time.TimePickerDialog.isTypedTimeFullyLegal",
	"Comment": "check if the time that has been typed so far is completely legal, as is.",
	"Method": "boolean isTypedTimeFullyLegal(){\r\n    if (mIs24HourMode) {\r\n        int[] values = getEnteredTime(null);\r\n        return (values[0] >= 0 && values[1] >= 0 && values[1] < 60);\r\n    } else {\r\n        return (mTypedTimes.contains(getAmOrPmKeyCode(AM)) || mTypedTimes.contains(getAmOrPmKeyCode(PM)));\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.freeflow.core.FreeFlowContainer.setAdapter",
	"Comment": "sets the adapter for the this collectionview.all view pools will be\tcleared at this point and all views on the stage will be cleared",
	"Method": "void setAdapter(SectionedAdapter adapter){\r\n    if (adapter == mAdapter) {\r\n        return;\r\n    }\r\n    stopScrolling();\r\n    logLifecycleEvent(\"setting adapter\");\r\n    markAdapterDirty = true;\r\n    viewPortX = 0;\r\n    viewPortY = 0;\r\n    shouldRecalculateScrollWhenComputingLayout = true;\r\n    this.mAdapter = adapter;\r\n    if (adapter != null) {\r\n        viewpool.initializeViewPool(adapter.getViewTypes());\r\n    }\r\n    if (mLayout != null) {\r\n        mLayout.setAdapter(mAdapter);\r\n    }\r\n    requestLayout();\r\n}"
}, {
	"Path": "com.android.datetimepicker.time.RadialPickerLayout.getDegreesFromCoords",
	"Comment": "calculate the degrees within the circle that corresponds to the specified coordinates, ifthe coordinates are within the range that will trigger a selection.",
	"Method": "int getDegreesFromCoords(float pointX,float pointY,boolean forceLegal,Boolean[] isInnerCircle){\r\n    int currentItem = getCurrentItemShowing();\r\n    if (currentItem == HOUR_INDEX) {\r\n        return mHourRadialSelectorView.getDegreesFromCoords(pointX, pointY, forceLegal, isInnerCircle);\r\n    } else if (currentItem == MINUTE_INDEX) {\r\n        return mMinuteRadialSelectorView.getDegreesFromCoords(pointX, pointY, forceLegal, isInnerCircle);\r\n    } else {\r\n        return -1;\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.twowayview.widget.ItemSpacingOffsets.isLastChildInLane",
	"Comment": "checks whether the given position is placed at the end of a layout lane.",
	"Method": "boolean isLastChildInLane(BaseLayoutManager lm,int itemPosition,int itemCount){\r\n    final int laneCount = lm.getLanes().getCount();\r\n    if (itemPosition < itemCount - laneCount) {\r\n        return false;\r\n    }\r\n    if (lm instanceof SpannableGridLayoutManager || lm instanceof StaggeredGridLayoutManager) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.testng.reporters.XMLUtils.xml",
	"Comment": "generate tag. an opening and closing tag will be generated even if value is null.",
	"Method": "String xml(String indent,String name,String content,Properties attributes){\r\n    IBuffer result = Buffer.create();\r\n    xmlOpen(result, indent, name, attributes, true);\r\n    if (content != null) {\r\n        result.append(content);\r\n    }\r\n    xmlClose(result, \"\", name, XMLUtils.extractComment(name, attributes));\r\n    return result.toString();\r\n}"
}, {
	"Path": "org.isoron.uhabits.core.models.Habit.copyFrom",
	"Comment": "copies all the attributes of the specified habit into this habit",
	"Method": "void copyFrom(Habit model){\r\n    this.data = new HabitData(model.data);\r\n    observable.notifyListeners();\r\n}"
}, {
	"Path": "test.thread.parallelization.BaseParallelizationTest.verifyEventsOccurBetween",
	"Comment": "print the specified failure message if the assertion on the timestamps fails.",
	"Method": "void verifyEventsOccurBetween(EventLog earlierEventLog,List<EventLog> inBetweenEventLogs,EventLog laterEventLog,String failMessage){\r\n    for (EventLog eventLog : inBetweenEventLogs) {\r\n        assertTrue(eventLog.getTimeOfEvent() >= earlierEventLog.getTimeOfEvent() && eventLog.getTimeOfEvent() <= laterEventLog.getTimeOfEvent(), failMessage);\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.rebound.SpringLooper.setSpringSystem",
	"Comment": "set the basespringsystem that the springlooper will call back to.",
	"Method": "void setSpringSystem(BaseSpringSystem springSystem){\r\n    mSpringSystem = springSystem;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.imageprocessing.GLRenderer.setBackgroundRed",
	"Comment": "sets only the red component of the background colour currently set for this glrenderer.",
	"Method": "void setBackgroundRed(float red){\r\n    this.red = red;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.rebound.Spring.getEndValue",
	"Comment": "get the rest value used for determining the displacement of the spring",
	"Method": "double getEndValue(){\r\n    return mEndValue;\r\n}"
}, {
	"Path": "org.isoron.uhabits.activities.habits.list.views.HabitCardListAdapter.onDetached",
	"Comment": "notify the adapter that it has been detached from a listview.",
	"Method": "void onDetached(){\r\n    cache.onDetached();\r\n    midnightTimer.removeListener(this);\r\n}"
}, {
	"Path": "com.marshalchen.common.commonUtils.urlUtils.HttpUtilsAsync.getUseCookie",
	"Comment": "perform a http get request with cookies which are defined in hashmap",
	"Method": "void getUseCookie(Context context,String url,HashMap hashMap,AsyncHttpResponseHandler responseHandler){\r\n    PersistentCookieStore myCookieStore = new PersistentCookieStore(context);\r\n    if (BasicUtils.judgeNotNull(hashMap)) {\r\n        Iterator iterator = hashMap.entrySet().iterator();\r\n        while (iterator.hasNext()) {\r\n            Map.Entry entry = (Map.Entry) iterator.next();\r\n            Object key = entry.getKey();\r\n            Object value = entry.getValue();\r\n            Cookie cookie = new BasicClientCookie(key.toString(), value.toString());\r\n            myCookieStore.addCookie(cookie);\r\n        }\r\n    }\r\n    AsyncHttpClient client = new AsyncHttpClient();\r\n    client.setCookieStore(myCookieStore);\r\n    client.get(getAbsoluteUrl(url), responseHandler);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.animation.PropertyValuesHolder.setupSetterOrGetter",
	"Comment": "returns the setter or getter requested. this utility function checks whether therequested method exists in the propertymapmap cache. if not, it calls anotherutility function to request the method from the targetclass directly.",
	"Method": "Method setupSetterOrGetter(Class targetClass,HashMap<Class, HashMap<String, Method>> propertyMapMap,String prefix,Class valueType){\r\n    Method setterOrGetter = null;\r\n    try {\r\n        mPropertyMapLock.writeLock().lock();\r\n        HashMap<String, Method> propertyMap = propertyMapMap.get(targetClass);\r\n        if (propertyMap != null) {\r\n            setterOrGetter = propertyMap.get(mPropertyName);\r\n        }\r\n        if (setterOrGetter == null) {\r\n            setterOrGetter = getPropertyFunction(targetClass, prefix, valueType);\r\n            if (propertyMap == null) {\r\n                propertyMap = new HashMap<String, Method>();\r\n                propertyMapMap.put(targetClass, propertyMap);\r\n            }\r\n            propertyMap.put(mPropertyName, setterOrGetter);\r\n        }\r\n    } finally {\r\n        mPropertyMapLock.writeLock().unlock();\r\n    }\r\n    return setterOrGetter;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.tileView.tileview.TileView.addHotSpot",
	"Comment": "register a hotspot that should fire an listener when a touch event occurs that intersects that rectangle.\tthe hotspot moves and scales with the tileview.",
	"Method": "HotSpot addHotSpot(HotSpot hotSpot,HotSpot addHotSpot,List<double[]> positions,HotSpot addHotSpot,List<double[]> positions,HotSpotEventListener listener){\r\n    HotSpot hotSpot = addHotSpot(positions);\r\n    hotSpot.setHotSpotEventListener(listener);\r\n    return hotSpot;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.imageprocessing.GLRenderer.setBackgroundColour",
	"Comment": "sets the background colour for this glrenderer to the given colour in rgba space.",
	"Method": "void setBackgroundColour(float red,float green,float blue,float alpha){\r\n    this.setBackgroundRed(red);\r\n    this.setBackgroundGreen(green);\r\n    this.setBackgroundBlue(blue);\r\n    this.setBackgroundAlpha(alpha);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.modifysys.ViewPager.addTouchables",
	"Comment": "we only want the current page that is being shown to be touchable.",
	"Method": "void addTouchables(ArrayList<View> views){\r\n    for (int i = 0; i < getChildCount(); i++) {\r\n        final View child = getChildAt(i);\r\n        if (child.getVisibility() == VISIBLE) {\r\n            ItemInfo ii = infoForChild(child);\r\n            if (ii != null && ii.position == mCurItem) {\r\n                child.addTouchables(views);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.rebound.SpringConfig.fromOrigamiTensionAndFriction",
	"Comment": "a helper to make creating a springconfig easier with values mapping to the origami values.",
	"Method": "SpringConfig fromOrigamiTensionAndFriction(double qcTension,double qcFriction){\r\n    return new SpringConfig(OrigamiValueConverter.tensionFromOrigamiValue(qcTension), OrigamiValueConverter.frictionFromOrigamiValue(qcFriction));\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.slideactivity.SlidingLayout.closePane",
	"Comment": "close the sliding pane if it is currently slideable. if first layouthas already completed this will animate.",
	"Method": "boolean closePane(View pane,int initialVelocity,boolean closePane){\r\n    return closePane(mSlideableView, 0);\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.recyclerplayground.layout.FixedGridLayoutManager.getGlobalRowOfPosition",
	"Comment": "return the overall row index of this position in the global layout",
	"Method": "int getGlobalRowOfPosition(int position){\r\n    return position / getTotalColumnCount();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.gesturedetectors.BaseGestureDetector.getTimeDelta",
	"Comment": "return the time difference in milliseconds between the previous accepted\tgesturedetector event and the current gesturedetector event.",
	"Method": "long getTimeDelta(){\r\n    return mTimeDelta;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.imageprocessing.input.GLTextureOutputRenderer.getLockObject",
	"Comment": "returns the object used to lock the target list.iterating over or changing the target list\tshould be done in a synchronized block that is locked using the object return.",
	"Method": "Object getLockObject(){\r\n    return listLock;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.imageprocessing.GLRenderer.getHeight",
	"Comment": "returns the current height the glrenderer is rendering at.",
	"Method": "int getHeight(){\r\n    return height;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.animation.PropertyValuesHolder.setKeyframes",
	"Comment": "set the animated values for this object to this set of keyframes.",
	"Method": "void setKeyframes(Keyframe values){\r\n    int numKeyframes = values.length;\r\n    Keyframe[] keyframes = new Keyframe[Math.max(numKeyframes, 2)];\r\n    mValueType = ((Keyframe) values[0]).getType();\r\n    for (int i = 0; i < numKeyframes; ++i) {\r\n        keyframes[i] = (Keyframe) values[i];\r\n    }\r\n    mKeyframeSet = new KeyframeSet(keyframes);\r\n}"
}, {
	"Path": "org.isoron.uhabits.core.models.ScoreList.getValue",
	"Comment": "returns the value of the score for a given day.if the timestamp given happens before the first repetition of the habitthen returns zero.",
	"Method": "double getValue(Timestamp timestamp){\r\n    compute(timestamp, timestamp);\r\n    Score s = getComputedByTimestamp(timestamp);\r\n    if (s == null)\r\n        throw new IllegalStateException();\r\n    return s.getValue();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.slideactivity.SlidingLayout.isOpen",
	"Comment": "check if the layout is completely open. it can be open either because the slideritself is open revealing the left pane, or if all content fits without sliding.",
	"Method": "boolean isOpen(){\r\n    return !mCanSlide || mSlideOffset == 1;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.cropimage.ImageViewTouchBase.getImageViewMatrix",
	"Comment": "combine the base matrix and the supp matrix to make the final matrix",
	"Method": "Matrix getImageViewMatrix(){\r\n    displayMatrix.set(baseMatrix);\r\n    displayMatrix.postConcat(suppMatrix);\r\n    return displayMatrix;\r\n}"
}, {
	"Path": "com.marshalchen.common.commonUtils.basicUtils.StringUtils.ifStringInList",
	"Comment": "judge if the arraylist contains the string variablethis method judgestrim string.",
	"Method": "boolean ifStringInList(String s,ArrayList<String> arrayList){\r\n    if (BasicUtils.judgeNotNull(s) && BasicUtils.judgeNotNull(arrayList)) {\r\n        for (String str : arrayList) {\r\n            if (str.trim().contains(s))\r\n                return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.marshalchen.ua.common.commonUtils.fileUtils.FileUtils.writeFile",
	"Comment": "if the file already exists, it will be truncated. the file will be created if it does not exist.",
	"Method": "boolean writeFile(String filePath,String content,boolean append,boolean writeFile,String filePath,String content,boolean writeFile,String filePath,InputStream stream,boolean writeFile,String filePath,InputStream stream,boolean append,boolean writeFile,File file,InputStream stream,boolean writeFile,File file,InputStream stream,boolean append){\r\n    OutputStream o = null;\r\n    try {\r\n        makeDirs(file.getAbsolutePath());\r\n        o = new FileOutputStream(file, append);\r\n        byte[] data = new byte[1024];\r\n        int length = -1;\r\n        while ((length = stream.read(data)) != -1) {\r\n            o.write(data, 0, length);\r\n        }\r\n        o.flush();\r\n        return true;\r\n    } catch (FileNotFoundException e) {\r\n        throw new RuntimeException(\"FileNotFoundException occurred. \", e);\r\n    } catch (IOException e) {\r\n        throw new RuntimeException(\"IOException occurred. \", e);\r\n    } finally {\r\n        if (o != null) {\r\n            try {\r\n                o.close();\r\n                stream.close();\r\n            } catch (IOException e) {\r\n                throw new RuntimeException(\"IOException occurred. \", e);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.testng.internal.reflect.ReflectionRecipes.isOrImplementsInterface",
	"Comment": "checks a class instance for being a given interface or its implementation.",
	"Method": "boolean isOrImplementsInterface(Class<?> reference,Class<?> clazz){\r\n    boolean implementsInterface = false;\r\n    if (reference.isInterface()) {\r\n        if (reference.equals(clazz)) {\r\n            implementsInterface = true;\r\n        } else {\r\n            final Class<?>[] interfaces = clazz.getInterfaces();\r\n            for (final Class<?> interfaceClazz : interfaces) {\r\n                implementsInterface = interfaceClazz.equals(reference);\r\n                if (implementsInterface)\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n    return implementsInterface;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.imageprocessing.input.GLTextureOutputRenderer.addTarget",
	"Comment": "adds the given target to the list of targets that this renderer sends its output to.",
	"Method": "void addTarget(GLTextureInputRenderer target){\r\n    synchronized (listLock) {\r\n        targets.add(target);\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.rippleDrawable.Ripple.jump",
	"Comment": "jump all animations to their end state. the caller is responsible forremoving the ripple from the list of animating ripples.",
	"Method": "void jump(){\r\n    mCanceled = true;\r\n    endSoftwareAnimations();\r\n    mCanceled = false;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.easyandroidanimations.FlipHorizontalAnimation.setDegrees",
	"Comment": "in order to flip to the left, the number of degrees should be negative\tand vice versa.",
	"Method": "FlipHorizontalAnimation setDegrees(float degrees){\r\n    this.degrees = degrees;\r\n    return this;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.rebound.Spring.getCurrentDisplacementDistance",
	"Comment": "get the displacement of the springs current value from its rest value.",
	"Method": "double getCurrentDisplacementDistance(){\r\n    return getDisplacementDistanceForState(mCurrentState);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.kenburnsview.RandomTransitionGenerator.setTransitionDuration",
	"Comment": "sets the duration, in milliseconds, for each transition generated.",
	"Method": "void setTransitionDuration(long transitionDuration){\r\n    mTransitionDuration = transitionDuration;\r\n}"
}, {
	"Path": "com.marshalchen.ua.common.commonUtils.dbUtils.GreenDaoUtils.queryBuilderLazyList",
	"Comment": "executes the query and returns the result as a list that lazy loads the entities on first access. entities are cached, so accessing the same entity more than once will not result in loading an entity from the underlying cursor again.make sure to close it to close the underlying cursor.",
	"Method": "LazyList queryBuilderLazyList(AbstractDao dao,WhereCondition cond,WhereCondition condmore){\r\n    return getQueryBuilder(dao, cond, condmore).listLazy();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.imageprocessing.GLRenderer.rotateClockwise90Degrees",
	"Comment": "rotates the renderer clockwise by 90 degrees a given number of times.",
	"Method": "void rotateClockwise90Degrees(int numOfTimes){\r\n    curRotation += numOfTimes;\r\n    curRotation = curRotation % 4;\r\n    if (numOfTimes % 2 == 1) {\r\n        int temp = width;\r\n        width = height;\r\n        height = temp;\r\n    }\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.makers.FixedSizeThumbnailMaker.keepAspectRatio",
	"Comment": "sets whether or not the thumbnail is to maintain the aspect ratio of\tthe original image.",
	"Method": "FixedSizeThumbnailMaker keepAspectRatio(boolean keep){\r\n    if (ready.isSet(PARAM_KEEP_RATIO)) {\r\n        throw new IllegalStateException(\"Whether to keep the aspect ratio has already been set.\");\r\n    }\r\n    this.keepRatio = keep;\r\n    ready.set(PARAM_KEEP_RATIO);\r\n    return this;\r\n}"
}, {
	"Path": "org.isoron.uhabits.core.models.ModelObservable.notifyListeners",
	"Comment": "notifies every listener that the model has changed.only models should call this method.",
	"Method": "void notifyListeners(){\r\n    for (Listener l : listeners) l.onModelChange();\r\n}"
}, {
	"Path": "org.isoron.uhabits.core.models.RepetitionList.containsTimestamp",
	"Comment": "returns true if the list contains a repetition that has the giventimestamp.",
	"Method": "boolean containsTimestamp(Timestamp timestamp){\r\n    return (getByTimestamp(timestamp) != null);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.twowayview.widget.ItemSpacingOffsets.isSecondLane",
	"Comment": "checks whether the given position is placed just after the item in thefirst lane of the layout taking items spans into account.",
	"Method": "boolean isSecondLane(BaseLayoutManager lm,int itemPosition,int lane){\r\n    if (lane == 0 || itemPosition == 0) {\r\n        return false;\r\n    }\r\n    int previousLane = Lanes.NO_LANE;\r\n    int previousPosition = itemPosition - 1;\r\n    while (previousPosition >= 0) {\r\n        lm.getLaneForPosition(mTempLaneInfo, previousPosition, Direction.END);\r\n        previousLane = mTempLaneInfo.startLane;\r\n        if (previousLane != lane) {\r\n            break;\r\n        }\r\n        previousPosition--;\r\n    }\r\n    final int previousLaneSpan = lm.getLaneSpanForPosition(previousPosition);\r\n    if (previousLane == 0) {\r\n        return (lane == previousLane + previousLaneSpan);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.animation.ObjectAnimator.setTarget",
	"Comment": "sets the target object whose property will be animated by this animation",
	"Method": "void setTarget(Object target){\r\n    if (mTarget != target) {\r\n        final Object oldTarget = mTarget;\r\n        mTarget = target;\r\n        if (oldTarget != null && target != null && oldTarget.getClass() == target.getClass()) {\r\n            return;\r\n        }\r\n        mInitialized = false;\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.ua.common.commonUtils.urlUtils.Base64.decodeToObject",
	"Comment": "attempts to decode base64 data and deserialize a javaobject within. returns null if there was an error.if loader is not null, it will be the class loaderused when deserializing.",
	"Method": "Object decodeToObject(String encodedObject,Object decodeToObject,String encodedObject,int options,ClassLoader loader){\r\n    byte[] objBytes = decode(encodedObject, options);\r\n    java.io.ByteArrayInputStream bais = null;\r\n    java.io.ObjectInputStream ois = null;\r\n    Object obj = null;\r\n    try {\r\n        bais = new java.io.ByteArrayInputStream(objBytes);\r\n        if (loader == null) {\r\n            ois = new java.io.ObjectInputStream(bais);\r\n        } else {\r\n            ois = new java.io.ObjectInputStream(bais) {\r\n                @Override\r\n                public Class<?> resolveClass(java.io.ObjectStreamClass streamClass) throws java.io.IOException, ClassNotFoundException {\r\n                    Class c = Class.forName(streamClass.getName(), false, loader);\r\n                    if (c == null) {\r\n                        return super.resolveClass(streamClass);\r\n                    } else {\r\n                        return c;\r\n                    }\r\n                }\r\n            };\r\n        }\r\n        obj = ois.readObject();\r\n    } catch (java.io.IOException e) {\r\n        throw e;\r\n    } catch (ClassNotFoundException e) {\r\n        throw e;\r\n    } finally {\r\n        try {\r\n            bais.close();\r\n        } catch (Exception e) {\r\n        }\r\n        try {\r\n            ois.close();\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n    return obj;\r\n}"
}, {
	"Path": "com.marshalchen.ua.common.commonUtils.urlUtils.Base64.decodeToObject",
	"Comment": "attempts to decode base64 data and deserialize a javaobject within. returns null if there was an error.if loader is not null, it will be the class loaderused when deserializing.",
	"Method": "Object decodeToObject(String encodedObject,Object decodeToObject,String encodedObject,int options,ClassLoader loader){\r\n    Class c = Class.forName(streamClass.getName(), false, loader);\r\n    if (c == null) {\r\n        return super.resolveClass(streamClass);\r\n    } else {\r\n        return c;\r\n    }\r\n}"
}, {
	"Path": "test.conffailure.ClassWithFailedBeforeSuiteVerification.tearDown",
	"Comment": "should not be run because beforesuite failed on the other class",
	"Method": "void tearDown(){\r\n    m_success2 = false;\r\n}"
}, {
	"Path": "com.marshalchen.ua.common.commonUtils.fileUtils.PreferencesUtils.getBoolean",
	"Comment": "get boolean from custom preferences with custom default value",
	"Method": "boolean getBoolean(Context context,String key,boolean getBoolean,Context context,String preferenceName,String key,boolean getBoolean,Context context,String preferenceName,String key,boolean defaultValue){\r\n    SharedPreferences sharedPreferences = context.getSharedPreferences(preferenceName, Context.MODE_PRIVATE);\r\n    return sharedPreferences.getBoolean(key, defaultValue);\r\n}"
}, {
	"Path": "com.marshalchen.ua.common.usefulModule.AutofitTextView.refitText",
	"Comment": "re size the font so the specified text fits in the text box assuming the text box is thespecified width.",
	"Method": "void refitText(){\r\n    if (!mSizeToFit) {\r\n        return;\r\n    }\r\n    if (mMaxLines <= 0) {\r\n        return;\r\n    }\r\n    CharSequence text = getText();\r\n    TransformationMethod method = getTransformationMethod();\r\n    if (method != null) {\r\n        text = method.getTransformation(text, this);\r\n    }\r\n    int targetWidth = getWidth() - getPaddingLeft() - getPaddingRight();\r\n    if (targetWidth > 0) {\r\n        Context context = getContext();\r\n        Resources r = Resources.getSystem();\r\n        DisplayMetrics displayMetrics;\r\n        float size = mMaxTextSize;\r\n        float high = size;\r\n        float low = 0;\r\n        if (context != null) {\r\n            r = context.getResources();\r\n        }\r\n        displayMetrics = r.getDisplayMetrics();\r\n        mPaint.set(getPaint());\r\n        mPaint.setTextSize(size);\r\n        if ((mMaxLines == 1 && mPaint.measureText(text, 0, text.length()) > targetWidth) || getLineCount(text, mPaint, size, targetWidth, displayMetrics) > mMaxLines) {\r\n            size = getTextSize(text, mPaint, targetWidth, mMaxLines, low, high, mPrecision, displayMetrics);\r\n        }\r\n        if (size < mMinTextSize) {\r\n            size = mMinTextSize;\r\n        }\r\n        super.setTextSize(TypedValue.COMPLEX_UNIT_PX, size);\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.imageprocessing.inputprocess.GLTextureOutputRenderer.removeTarget",
	"Comment": "removes the given target from the list of targets that this renderer sends its output to.",
	"Method": "void removeTarget(GLTextureInputRenderer target){\r\n    synchronized (listLock) {\r\n        targets.remove(target);\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.swipeback.SwipeBackLayout.setSwipeListener",
	"Comment": "register a callback to be invoked when a swipe event is sent to thisview.",
	"Method": "void setSwipeListener(SwipeListener listener){\r\n    addSwipeListener(listener);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.dynamicgrid.DynamicGridUtils.swap",
	"Comment": "swap item in list at position firstindex with item at position secondindex",
	"Method": "void swap(ArrayList list,int firstIndex,int secondIndex){\r\n    Object firstObject = list.get(firstIndex);\r\n    Object secondObject = list.get(secondIndex);\r\n    list.set(firstIndex, secondObject);\r\n    list.set(secondIndex, firstObject);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.tileView.layouts.ZoomPanLayout.getPinchStartThreshold",
	"Comment": "returns the minimum distance required to start a pinch operation, in pixels.",
	"Method": "int getPinchStartThreshold(){\r\n    return pinchStartThreshold;\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.recyclerplayground.layout.StaticGridLayoutManager.canScrollHorizontally",
	"Comment": "use this method to tell the recyclerview if scrolling is even possiblein the horizontal direction.",
	"Method": "boolean canScrollHorizontally(){\r\n    return true;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.freeflow.core.FreeFlowContainer.setLayout",
	"Comment": "sets the layout on the container. if a previous layout was already\tapplied, this causes the views to animate to the new layout positions.\tscroll positions will also be reset.",
	"Method": "void setLayout(FreeFlowLayout newLayout){\r\n    if (newLayout == mLayout || newLayout == null) {\r\n        return;\r\n    }\r\n    stopScrolling();\r\n    oldLayout = mLayout;\r\n    mLayout = newLayout;\r\n    shouldRecalculateScrollWhenComputingLayout = true;\r\n    if (mAdapter != null) {\r\n        mLayout.setAdapter(mAdapter);\r\n    }\r\n    dispatchLayoutChanging(oldLayout, newLayout);\r\n    markLayoutDirty = true;\r\n    viewPortX = 0;\r\n    viewPortY = 0;\r\n    logLifecycleEvent(\"Setting layout\");\r\n    requestLayout();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.swipeback.ViewDragHelper.clampMag",
	"Comment": "clamp the magnitude of value for absmin and absmax. if the value is belowthe minimum, it will be clamped to zero. if the value is above themaximum, it will be clamped to the maximum.",
	"Method": "int clampMag(int value,int absMin,int absMax,float clampMag,float value,float absMin,float absMax){\r\n    final float absValue = Math.abs(value);\r\n    if (absValue < absMin)\r\n        return 0;\r\n    if (absValue > absMax)\r\n        return value > 0 ? absMax : -absMax;\r\n    return value;\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.resizers.AbstractResizer.performChecks",
	"Comment": "performs checks on the source and destination image to see if they are\timages which can be processed.",
	"Method": "void performChecks(BufferedImage srcImage,BufferedImage destImage){\r\n    if (srcImage == null || destImage == null) {\r\n        throw new NullPointerException(\"The source and/or destination image is null.\");\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.twowayview.ItemClickSupport.setOnItemClickListener",
	"Comment": "register a callback to be invoked when an item in therecyclerview has been clicked.",
	"Method": "void setOnItemClickListener(OnItemClickListener listener){\r\n    mItemClickListener = listener;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.slider.SliderTypes.BaseSliderView.errorDisappear",
	"Comment": "determine whether remove the image which failed to download or load from file",
	"Method": "BaseSliderView errorDisappear(boolean disappear){\r\n    mErrorDisappear = disappear;\r\n    return this;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.customshapeimageview.svgandroid.SVG.getBounds",
	"Comment": "gets the bounding rectangle for the svg, if one was specified.",
	"Method": "RectF getBounds(){\r\n    return bounds;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.staggeredgridview.ExtendableListView.hasSpaceUp",
	"Comment": "override to tell filling flow to continue to fill up as we have space.",
	"Method": "boolean hasSpaceUp(){\r\n    return false;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.animation.AnimatorSet.getDuration",
	"Comment": "gets the length of each of the child animations of this animatorset. this value maybe less than 0, which indicates that no duration has been set on this animatorsetand each of the child animations will use their own duration.",
	"Method": "long getDuration(){\r\n    return mDuration;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.customshapeimageview.svgandroid.SVGParser.parsePath",
	"Comment": "parses a single svg path and returns it as a android.graphics.path object.an example path is m250,150l150,350l350,350z, which draws a triangle.",
	"Method": "Path parsePath(String pathString){\r\n    return doPath(pathString);\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase2Scenario2.verifyThatMethodLevelEventsRunInDifferentThreadsFromSuiteAndTestLevelEvents",
	"Comment": "verifies that the test method listener and execution events for a given test method all run in the same thread.",
	"Method": "void verifyThatMethodLevelEventsRunInDifferentThreadsFromSuiteAndTestLevelEvents(){\r\n    verifyEventThreadsSpawnedAfter(getAllSuiteListenerStartEventLogs().get(0).getThreadId(), testMethodLevelEventLogs, \"All the thread IDs for the test method level events should be greater than the thread ID for the \" + \"suite and test level events. The expectation is that since the suite and test level events \" + \"are running sequentially, and all the test methods are running in parallel, new threads \" + \"will be spawned after the thread executing the suite and test level events when new methods \" + \"begin executing. Suite and test level events thread ID: \" + getAllSuiteListenerStartEventLogs().get(0).getThreadId() + \". Test method level event logs: \" + testMethodLevelEventLogs);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassAFiveMethodsWithNoDepsSample.class, SUITE_A, SUITE_A_TEST_A);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassAFiveMethodsWithNoDepsSample.class, SUITE_A, SUITE_A_TEST_A);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassCSixMethodsWithNoDepsSample.class, SUITE_A, SUITE_A_TEST_A);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassEFiveMethodsWithNoDepsSample.class, SUITE_B, SUITE_B_TEST_A);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassDThreeMethodsWithNoDepsSample.class, SUITE_B, SUITE_B_TEST_B);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassBFourMethodsWithNoDepsSample.class, SUITE_B, SUITE_B_TEST_B);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassFSixMethodsWithNoDepsSample.class, SUITE_B, SUITE_B_TEST_B);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassGThreeMethodsWithNoDepsSample.class, SUITE_C, SUITE_C_TEST_A);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassHFourMethodsWithNoDepsSample.class, SUITE_C, SUITE_C_TEST_A);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassIFiveMethodsWithNoDepsSample.class, SUITE_C, SUITE_C_TEST_A);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassJFourMethodsWithNoDepsSample.class, SUITE_C, SUITE_C_TEST_B);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassKFiveMethodsWithNoDepsSample.class, SUITE_C, SUITE_C_TEST_B);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassLThreeMethodsWithNoDepsSample.class, SUITE_C, SUITE_C_TEST_C);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassMFourMethodsWithNoDepsSample.class, SUITE_C, SUITE_C_TEST_C);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassNFiveMethodsWithNoDepsSample.class, SUITE_C, SUITE_C_TEST_C);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassOSixMethodsWithNoDepsSample.class, SUITE_C, SUITE_C_TEST_C);\r\n}"
}, {
	"Path": "com.android.datetimepicker.Utils.tryAccessibilityAnnounce",
	"Comment": "try to speak the specified text, for accessibility. only available on jb or later.",
	"Method": "void tryAccessibilityAnnounce(View view,CharSequence text){\r\n    if (isJellybeanOrLater() && view != null && text != null) {\r\n        view.announceForAccessibility(text);\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.ui.CircularImageView.setSelectorStrokeWidth",
	"Comment": "sets the stroke width to be drawn around the circularimageview\tduring click events when the selector is enabled.",
	"Method": "void setSelectorStrokeWidth(int selectorStrokeWidth){\r\n    this.selectorStrokeWidth = selectorStrokeWidth;\r\n    this.requestLayout();\r\n    this.invalidate();\r\n}"
}, {
	"Path": "org.testng.reporters.EmailableReporter.generateMethodSummaryReport",
	"Comment": "creates a table showing the highlights of each test method with links to the method details",
	"Method": "void generateMethodSummaryReport(List<ISuite> suites){\r\n    m_methodIndex = 0;\r\n    startResultSummaryTable();\r\n    int testIndex = 1;\r\n    for (ISuite suite : suites) {\r\n        if (suites.size() > 1) {\r\n            titleRow(suite.getName(), 5);\r\n        }\r\n        Map<String, ISuiteResult> r = suite.getResults();\r\n        for (ISuiteResult r2 : r.values()) {\r\n            ITestContext testContext = r2.getTestContext();\r\n            String testName = testContext.getName();\r\n            m_testIndex = testIndex;\r\n            resultSummary(suite, testContext.getFailedConfigurations(), testName, \"failed\", \" (configuration methods)\");\r\n            resultSummary(suite, testContext.getFailedTests(), testName, \"failed\", \"\");\r\n            resultSummary(suite, testContext.getSkippedConfigurations(), testName, \"skipped\", \" (configuration methods)\");\r\n            resultSummary(suite, testContext.getSkippedTests(), testName, \"skipped\", \"\");\r\n            resultSummary(suite, testContext.getPassedTests(), testName, \"passed\", \"\");\r\n            testIndex++;\r\n        }\r\n    }\r\n    m_out.println(\"<\/table>\");\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.tileView.tileview.TileView.getPathPaint",
	"Comment": "returns the paint instance used by default.this can be modified for future path paint operations.",
	"Method": "Paint getPathPaint(){\r\n    return pathManager.getPaint();\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.recyclerplayground.layout.FixedGridLayoutManager.getGlobalColumnOfPosition",
	"Comment": "return the overall column index of this position in the global layout",
	"Method": "int getGlobalColumnOfPosition(int position){\r\n    return position % getTotalColumnCount();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.tileView.layouts.ZoomPanLayout.getDistance",
	"Comment": "sugar to calculate distance between 2 points, because android.graphics.point is horrible",
	"Method": "double getDistance(Point p1,Point p2){\r\n    int x = p1.x - p2.x;\r\n    int y = p1.y - p2.y;\r\n    return Math.sqrt(x * x + y * y);\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.recyclerplayground.layout.FixedGridLayoutManager.scrollVerticallyBy",
	"Comment": "this method describes how far recyclerview thinks the contents should scroll vertically.you are responsible for verifying edge boundaries, and determining if this scrollevent somehow requires that new views be added or old views get recycled.",
	"Method": "int scrollVerticallyBy(int dy,RecyclerView.Recycler recycler,RecyclerView.State state){\r\n    if (getChildCount() == 0) {\r\n        return 0;\r\n    }\r\n    final View topView = getChildAt(0);\r\n    final View bottomView = getChildAt(getChildCount() - 1);\r\n    int viewSpan = getDecoratedBottom(bottomView) - getDecoratedTop(topView);\r\n    if (viewSpan <= getVerticalSpace()) {\r\n        return 0;\r\n    }\r\n    int delta;\r\n    int maxRowCount = getTotalRowCount();\r\n    boolean topBoundReached = getFirstVisibleRow() == 0;\r\n    boolean bottomBoundReached = getLastVisibleRow() >= maxRowCount;\r\n    if (dy > 0) {\r\n        if (bottomBoundReached) {\r\n            int bottomOffset;\r\n            if (rowOfIndex(getChildCount() - 1) >= (maxRowCount - 1)) {\r\n                bottomOffset = getVerticalSpace() - getDecoratedBottom(bottomView) + getPaddingBottom();\r\n            } else {\r\n                bottomOffset = getVerticalSpace() - (getDecoratedBottom(bottomView) + mDecoratedChildHeight) + getPaddingBottom();\r\n            }\r\n            delta = Math.max(-dy, bottomOffset);\r\n        } else {\r\n            delta = -dy;\r\n        }\r\n    } else {\r\n        if (topBoundReached) {\r\n            int topOffset = -getDecoratedTop(topView) + getPaddingTop();\r\n            delta = Math.min(-dy, topOffset);\r\n        } else {\r\n            delta = -dy;\r\n        }\r\n    }\r\n    offsetChildrenVertical(delta);\r\n    if (dy > 0) {\r\n        if (getDecoratedBottom(topView) < 0 && !bottomBoundReached) {\r\n            fillGrid(DIRECTION_DOWN, recycler);\r\n        } else if (!bottomBoundReached) {\r\n            fillGrid(DIRECTION_NONE, recycler);\r\n        }\r\n    } else {\r\n        if (getDecoratedTop(topView) > 0 && !topBoundReached) {\r\n            fillGrid(DIRECTION_UP, recycler);\r\n        } else if (!topBoundReached) {\r\n            fillGrid(DIRECTION_NONE, recycler);\r\n        }\r\n    }\r\n    return -delta;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.imageprocessing.FastImageProcessingPipeline.startRendering",
	"Comment": "starts the rendering of the graph. if this is called before a root node renderer has been\tadded, it will do nothing.",
	"Method": "void startRendering(){\r\n    if (rootRenderers.size() != 0) {\r\n        rendering = true;\r\n    }\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase3Scenario1.verifyThatMethodLevelEventsRunInDifferentThreadsFromSuiteAndTestLevelEvents",
	"Comment": "verifies that the method level events all run in different threads from the test and suite level events.",
	"Method": "void verifyThatMethodLevelEventsRunInDifferentThreadsFromSuiteAndTestLevelEvents(){\r\n    verifyEventThreadsSpawnedAfter(testListenerOnStartThreadId, testMethodLevelEventLogs, \"All the thread IDs \" + \"for the test method level events should be greater than the thread ID for the suite and test level \" + \"events. The expectation is that since the suite and test level events are running sequentially, and \" + \"all the test methods are running in parallel, new threads will be spawned after the thread \" + \"executing the suite and test level events when new methods begin executing. Suite and test level \" + \"events thread ID: \" + testListenerOnStartThreadId + \". Test method level event logs: \" + testMethodLevelEventLogs);\r\n}"
}, {
	"Path": "com.marshalchen.common.commonUtils.fileUtils.ParcelUtils.writeHashMapStringAndString",
	"Comment": "write a hashmap to a parcel, class of key and value are both string",
	"Method": "void writeHashMapStringAndString(Map<String, String> map,Parcel out,int flags){\r\n    if (map != null) {\r\n        out.writeInt(map.size());\r\n        for (Entry<String, String> entry : map.entrySet()) {\r\n            out.writeString(entry.getKey());\r\n            out.writeString(entry.getValue());\r\n        }\r\n    } else {\r\n        out.writeInt(-1);\r\n    }\r\n}"
}, {
	"Path": "org.testng.xml.XmlTest.getInvocationNumbers",
	"Comment": "convenience method to cache the ordering numbers for methods.",
	"Method": "List<Integer> getInvocationNumbers(String method){\r\n    if (m_failedInvocationNumbers == null) {\r\n        m_failedInvocationNumbers = Maps.newHashMap();\r\n        for (XmlClass c : getXmlClasses()) {\r\n            for (XmlInclude xi : c.getIncludedMethods()) {\r\n                List<Integer> invocationNumbers = xi.getInvocationNumbers();\r\n                if (invocationNumbers.size() > 0) {\r\n                    String methodName = c.getName() + \".\" + xi.getName();\r\n                    m_failedInvocationNumbers.put(methodName, invocationNumbers);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    List<Integer> result = m_failedInvocationNumbers.get(method);\r\n    if (result == null) {\r\n        return Lists.newArrayList();\r\n    } else {\r\n        return result;\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.freeflow.core.LayoutChangeset.getAdded",
	"Comment": "returns the list of freeflowitems that will be added because they are\tpresent in the new layout that the freeflowcontainer is transitioning to.\tthe views representing these items are already placed on the stage before\tthe layoutanimator is called.",
	"Method": "List<FreeFlowItem> getAdded(){\r\n    return added;\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase4Scenario1.verifyThatTestMethodsRunInParallelThreads",
	"Comment": "verifies that the test methods execute in different threads in parallel fashion.",
	"Method": "void verifyThatTestMethodsRunInParallelThreads(){\r\n    verifyParallelTestMethodsWithNonParallelDataProvider(getTestMethodLevelEventLogsForTest(SUITE_A, SUITE_A_TEST_A), SUITE_A_TEST_A, expectedInvocationCounts, 11, 3);\r\n    verifyParallelTestMethodsWithNonParallelDataProvider(getTestMethodLevelEventLogsForTest(SUITE_B, SUITE_B_TEST_A), SUITE_B_TEST_A, expectedInvocationCounts, 5, 6);\r\n    verifyParallelTestMethodsWithNonParallelDataProvider(getTestMethodLevelEventLogsForTest(SUITE_B, SUITE_B_TEST_B), SUITE_B_TEST_B, expectedInvocationCounts, 13, 20);\r\n    verifyParallelTestMethodsWithNonParallelDataProvider(getTestMethodLevelEventLogsForTest(SUITE_C, SUITE_C_TEST_A), SUITE_C_TEST_A, expectedInvocationCounts, 12, 10);\r\n    verifyParallelTestMethodsWithNonParallelDataProvider(getTestMethodLevelEventLogsForTest(SUITE_C, SUITE_C_TEST_B), SUITE_C_TEST_B, expectedInvocationCounts, 9, 5);\r\n    verifyParallelTestMethodsWithNonParallelDataProvider(getTestMethodLevelEventLogsForTest(SUITE_C, SUITE_C_TEST_C), SUITE_C_TEST_C, expectedInvocationCounts, 18, 12);\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.builders.ThumbnailParameterBuilder.fitWithinDimensions",
	"Comment": "sets whether or not the thumbnail should fit within the specified\tdimensions.",
	"Method": "ThumbnailParameterBuilder fitWithinDimensions(boolean fit){\r\n    this.fitWithinDimensions = fit;\r\n    return this;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.slider.SliderTypes.BaseSliderView.getBundle",
	"Comment": "when you have some extra information, please put it in this bundle.",
	"Method": "Bundle getBundle(){\r\n    return mBundle;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.freeflow.core.AbsLayoutContainer.setOnItemClickListener",
	"Comment": "register a callback to be invoked when an item in this adapterview has\tbeen clicked.",
	"Method": "void setOnItemClickListener(OnItemClickListener listener){\r\n    mOnItemClickListener = listener;\r\n}"
}, {
	"Path": "com.marshalchen.common.DiskLruCache.DiskLruCache.size",
	"Comment": "returns the number of bytes currently being used to store the values inthis cache. this may be greater than the max size if a backgrounddeletion is pending.",
	"Method": "long size(){\r\n    return size;\r\n}"
}, {
	"Path": "org.testng.internal.Utils.toString",
	"Comment": "returns the string representation of the specified object, transparently handling nullreferences and arrays.",
	"Method": "String toString(Object object,Class<?> objectClass,String toString,Class<?>[] classes,String toString,Object obj){\r\n    String result;\r\n    if (obj != null) {\r\n        if (obj instanceof boolean[]) {\r\n            result = Arrays.toString((boolean[]) obj);\r\n        } else if (obj instanceof byte[]) {\r\n            result = Arrays.toString((byte[]) obj);\r\n        } else if (obj instanceof char[]) {\r\n            result = Arrays.toString((char[]) obj);\r\n        } else if (obj instanceof double[]) {\r\n            result = Arrays.toString((double[]) obj);\r\n        } else if (obj instanceof float[]) {\r\n            result = Arrays.toString((float[]) obj);\r\n        } else if (obj instanceof int[]) {\r\n            result = Arrays.toString((int[]) obj);\r\n        } else if (obj instanceof long[]) {\r\n            result = Arrays.toString((long[]) obj);\r\n        } else if (obj instanceof Object[]) {\r\n            result = Arrays.deepToString((Object[]) obj);\r\n        } else if (obj instanceof short[]) {\r\n            result = Arrays.toString((short[]) obj);\r\n        } else {\r\n            result = obj.toString();\r\n        }\r\n    } else {\r\n        result = \"null\";\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.recyclerplayground.layout.FixedGridLayoutManager.updateWindowSizing",
	"Comment": "rather than continuously checking how many views we can fitbased on scroll offsets, we simplify the math by computing thevisible grid as what will initially fit on screen, plus one.",
	"Method": "void updateWindowSizing(){\r\n    mVisibleColumnCount = (getHorizontalSpace() / mDecoratedChildWidth) + 1;\r\n    if (getHorizontalSpace() % mDecoratedChildWidth > 0) {\r\n        mVisibleColumnCount++;\r\n    }\r\n    if (mVisibleColumnCount > getTotalColumnCount()) {\r\n        mVisibleColumnCount = getTotalColumnCount();\r\n    }\r\n    mVisibleRowCount = (getVerticalSpace() / mDecoratedChildHeight) + 1;\r\n    if (getVerticalSpace() % mDecoratedChildHeight > 0) {\r\n        mVisibleRowCount++;\r\n    }\r\n    if (mVisibleRowCount > getTotalRowCount()) {\r\n        mVisibleRowCount = getTotalRowCount();\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.freeflow.core.FreeFlowContainer.copyFrames",
	"Comment": "copies the frames from one linkedhashmap into another. the items are\tcloned cause we modify the rectangles of the items as they are moving",
	"Method": "void copyFrames(Map<Object, FreeFlowItem> srcFrames,Map<Object, FreeFlowItem> destFrames){\r\n    Iterator<?> it = srcFrames.entrySet().iterator();\r\n    while (it.hasNext()) {\r\n        Map.Entry<?, ?> pairs = (Map.Entry<?, ?>) it.next();\r\n        FreeFlowItem pr = (FreeFlowItem) pairs.getValue();\r\n        pr = FreeFlowItem.clone(pr);\r\n        destFrames.put(pairs.getKey(), pr);\r\n    }\r\n}"
}, {
	"Path": "test.sanitycheck.CheckSuiteNamesTest.checkProgrammaticSuitesFails",
	"Comment": "checks that suites created programmatically also works as expected",
	"Method": "void checkProgrammaticSuitesFails(){\r\n    XmlSuite xmlSuite1 = new XmlSuite();\r\n    xmlSuite1.setName(\"SanityCheckSuite\");\r\n    {\r\n        XmlTest result = new XmlTest(xmlSuite1);\r\n        result.getXmlClasses().add(new XmlClass(SampleTest1.class.getCanonicalName()));\r\n    }\r\n    XmlSuite xmlSuite2 = new XmlSuite();\r\n    xmlSuite2.setName(\"SanityCheckSuite\");\r\n    {\r\n        XmlTest result = new XmlTest(xmlSuite2);\r\n        result.getXmlClasses().add(new XmlClass(SampleTest2.class.getCanonicalName()));\r\n    }\r\n    TestNG tng = create();\r\n    tng.setXmlSuites(Arrays.asList(xmlSuite1, xmlSuite2));\r\n    tng.run();\r\n    Assert.assertEquals(xmlSuite1.getName(), \"SanityCheckSuite\");\r\n    Assert.assertEquals(xmlSuite2.getName(), \"SanityCheckSuite (0)\");\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.animation.TimeAnimator.setTimeListener",
	"Comment": "sets a listener that is sent update events throughout the life ofan animation.",
	"Method": "void setTimeListener(TimeListener listener){\r\n    mListener = listener;\r\n}"
}, {
	"Path": "org.testng.TestNG.setVerbose",
	"Comment": "sets the level of verbosity. this value will override the value specified in the test suites.",
	"Method": "void setVerbose(int verbose){\r\n    m_verbose = verbose;\r\n}"
}, {
	"Path": "org.isoron.uhabits.core.models.ScoreList.forceRecompute",
	"Comment": "computes and stores one score for each day inside the given interval.this function does not check if the scores have already been computed. ifthey have, then it stores duplicate scores, which is a bad thing.",
	"Method": "void forceRecompute(Timestamp from,Timestamp to,double previousValue){\r\n    if (from.isNewerThan(to))\r\n        return;\r\n    final double freq = habit.getFrequency().toDouble();\r\n    final int[] checkmarkValues = habit.getCheckmarks().getValues(from, to);\r\n    List<Score> scores = new LinkedList();\r\n    for (int i = 0; i < checkmarkValues.length; i++) {\r\n        double value = checkmarkValues[checkmarkValues.length - i - 1];\r\n        if (habit.isNumerical()) {\r\n            value /= 1000;\r\n            value /= habit.getTargetValue();\r\n            value = Math.min(1, value);\r\n        }\r\n        if (!habit.isNumerical() && value > 0)\r\n            value = 1;\r\n        previousValue = Score.compute(freq, previousValue, value);\r\n        scores.add(new Score(from.plus(i), previousValue));\r\n    }\r\n    add(scores);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.slideactivity.SlidingLayout.canScroll",
	"Comment": "tests scrollability within child views of v given a delta of dx.",
	"Method": "boolean canScroll(View v,boolean checkV,int dx,int x,int y){\r\n    if (v instanceof ViewGroup) {\r\n        final ViewGroup group = (ViewGroup) v;\r\n        final int scrollX = v.getScrollX();\r\n        final int scrollY = v.getScrollY();\r\n        final int count = group.getChildCount();\r\n        for (int i = count - 1; i >= 0; i--) {\r\n            final View child = group.getChildAt(i);\r\n            if (x + scrollX >= child.getLeft() && x + scrollX < child.getRight() && y + scrollY >= child.getTop() && y + scrollY < child.getBottom() && canScroll(child, true, dx, x + scrollX - child.getLeft(), y + scrollY - child.getTop())) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return checkV && (ViewCompat.canScrollHorizontally(v, -dx) || ((v instanceof ViewPager) && canViewPagerScrollHorizontally((ViewPager) v, -dx)));\r\n}"
}, {
	"Path": "com.marshalchen.common.DiskLruCache.DiskLruCache.processJournal",
	"Comment": "computes the initial size and collects garbage as a part of opening thecache. dirty entries are assumed to be inconsistent and will be deleted.",
	"Method": "void processJournal(){\r\n    deleteIfExists(journalFileTmp);\r\n    for (Iterator<Entry> i = lruEntries.values().iterator(); i.hasNext(); ) {\r\n        Entry entry = i.next();\r\n        if (entry.currentEditor == null) {\r\n            for (int t = 0; t < valueCount; t++) {\r\n                size += entry.lengths[t];\r\n            }\r\n        } else {\r\n            entry.currentEditor = null;\r\n            for (int t = 0; t < valueCount; t++) {\r\n                deleteIfExists(entry.getCleanFile(t));\r\n                deleteIfExists(entry.getDirtyFile(t));\r\n            }\r\n            i.remove();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.staggeredgridview.ExtendableListView.getChildBottom",
	"Comment": "override to set you custom listviews child to a bottom top location",
	"Method": "int getChildBottom(int position){\r\n    int count = getChildCount();\r\n    int paddingBottom = 0;\r\n    if (mClipToPadding) {\r\n        paddingBottom = getListPaddingBottom();\r\n    }\r\n    return count > 0 ? getChildAt(0).getTop() : getHeight() - paddingBottom;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.rebound.BaseSpringSystem.registerSpring",
	"Comment": "registers a spring to this basespringsystem so it can be iterated if active.",
	"Method": "void registerSpring(Spring spring){\r\n    if (spring == null) {\r\n        throw new IllegalArgumentException(\"spring is required\");\r\n    }\r\n    if (mSpringRegistry.containsKey(spring.getId())) {\r\n        throw new IllegalArgumentException(\"spring is already registered\");\r\n    }\r\n    mSpringRegistry.put(spring.getId(), spring);\r\n}"
}, {
	"Path": "test.thread.parallelization.BaseParallelizationTest.verifyEventsForTestMethodsRunInTheSameThread",
	"Comment": "thread for each instance of the test class for the specified suite and test",
	"Method": "void verifyEventsForTestMethodsRunInTheSameThread(Class<?> testClass,String suiteName,String testName){\r\n    for (Method method : testClass.getMethods()) {\r\n        boolean isTestMethod = false;\r\n        Annotation[] annotations = method.getDeclaredAnnotations();\r\n        for (Annotation a : annotations) {\r\n            if (Test.class.isAssignableFrom(a.getClass())) {\r\n                isTestMethod = true;\r\n            }\r\n        }\r\n        if (method.getDeclaringClass().equals(testClass) && isTestMethod) {\r\n            Multimap<Object, EventLog> testMethodEventLogs = getTestMethodEventLogsForMethod(suiteName, testName, testClass.getCanonicalName(), method.getName());\r\n            for (Object instanceKey : testMethodEventLogs.keySet()) {\r\n                long threadId = -1;\r\n                for (EventLog eventLog : testMethodEventLogs.get(instanceKey)) {\r\n                    if (threadId == -1) {\r\n                        threadId = eventLog.getThreadId();\r\n                    } else {\r\n                        assertEquals(eventLog.getThreadId(), threadId, \"All of the method level events for the test \" + \"method \" + method.getName() + \" in the test class \" + testClass.getCanonicalName() + \" for the test \" + suiteName + \" should be run in the same thread\");\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase7Scenario1.sanityCheck",
	"Comment": "verifies that the expected number of suite, test and test method level events were logged.",
	"Method": "void sanityCheck(){\r\n    assertEquals(suiteLevelEventLogs.size(), 2, \"There should be 2 suite level events logged for \" + SUITE + \": \" + suiteLevelEventLogs);\r\n    assertEquals(testLevelEventLogs.size(), 2, \"There should be 2 test level events logged for \" + SUITE + \": \" + testLevelEventLogs);\r\n    assertEquals(testMethodLevelEventLogs.size(), 45, \"There should be 45 test method level events logged for \" + SUITE + \": \" + testMethodLevelEventLogs);\r\n}"
}, {
	"Path": "com.marshalchen.common.ui.ShimmerFrameLayout.createBitmapAndGcIfNecessary",
	"Comment": "creates a bitmap with the given width and height.if it fails with an outofmemory error, it will force a gc and then try to create the bitmapone more time.",
	"Method": "Bitmap createBitmapAndGcIfNecessary(int width,int height){\r\n    try {\r\n        return Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);\r\n    } catch (OutOfMemoryError e) {\r\n        System.gc();\r\n        return Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.kenburnsview.Transition.getSourceRect",
	"Comment": "gets the rect that will take the scene when a ken burns transition starts.",
	"Method": "RectF getSourceRect(){\r\n    return mSrcRect;\r\n}"
}, {
	"Path": "com.marshalchen.common.commonUtils.dbUtils.GreenDaoUtils.query",
	"Comment": "creates a repeatable query object based on the given raw sql where you can pass any where clause and arguments.",
	"Method": "Query query(AbstractDao dao,String queryString,String queryValue,Query query,AbstractDao dao,String queryString){\r\n    Query query = dao.queryBuilder().where(new WhereCondition.StringCondition(queryString)).build();\r\n    return query;\r\n}"
}, {
	"Path": "org.testng.internal.MethodGroupsHelper.collectMethodsByGroup",
	"Comment": "collect all the methods that belong to the included groups and exclude all the methods thatbelong to an excluded group.",
	"Method": "void collectMethodsByGroup(ITestNGMethod[] methods,boolean forTests,List<ITestNGMethod> outIncludedMethods,List<ITestNGMethod> outExcludedMethods,RunInfo runInfo,IAnnotationFinder finder,boolean unique){\r\n    for (ITestNGMethod tm : methods) {\r\n        boolean in = false;\r\n        Method m = tm.getConstructorOrMethod().getMethod();\r\n        if (forTests) {\r\n            in = MethodGroupsHelper.includeMethod(AnnotationHelper.findTest(finder, m), runInfo, tm, forTests, unique, outIncludedMethods);\r\n        } else {\r\n            IConfigurationAnnotation annotation = AnnotationHelper.findConfiguration(finder, m);\r\n            if (annotation.getAlwaysRun()) {\r\n                if (!unique || MethodGroupsHelper.isMethodAlreadyNotPresent(outIncludedMethods, tm)) {\r\n                    in = true;\r\n                }\r\n            } else {\r\n                in = MethodGroupsHelper.includeMethod(AnnotationHelper.findTest(finder, tm), runInfo, tm, forTests, unique, outIncludedMethods);\r\n            }\r\n        }\r\n        if (in) {\r\n            outIncludedMethods.add(tm);\r\n        } else {\r\n            outExcludedMethods.add(tm);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.slider.SliderTypes.BaseSliderView.error",
	"Comment": "if you set errordisappear false, this will set a error placeholder image.",
	"Method": "BaseSliderView error(int resId){\r\n    mErrorPlaceHolderRes = resId;\r\n    return this;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.imageprocessing.inputprocess.GLTextureOutputRenderer.getLockObject",
	"Comment": "returns the object used to lock the target list.iterating over or changing the target list\tshould be done in a synchronized block that is locked using the object return.",
	"Method": "Object getLockObject(){\r\n    return listLock;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.gesturedetectors.TwoFingerGestureDetector.getPreviousSpan",
	"Comment": "return the previous distance between the two pointers forming thegesture in progress.",
	"Method": "float getPreviousSpan(){\r\n    if (mPrevLen == -1) {\r\n        final float pvx = mPrevFingerDiffX;\r\n        final float pvy = mPrevFingerDiffY;\r\n        mPrevLen = FloatMath.sqrt(pvx * pvx + pvy * pvy);\r\n    }\r\n    return mPrevLen;\r\n}"
}, {
	"Path": "com.android.datetimepicker.date.MonthView.initView",
	"Comment": "sets up the text and style properties for painting. override this if youwant to use a different paint.",
	"Method": "void initView(){\r\n    mMonthTitlePaint = new Paint();\r\n    mMonthTitlePaint.setFakeBoldText(true);\r\n    mMonthTitlePaint.setAntiAlias(true);\r\n    mMonthTitlePaint.setTextSize(MONTH_LABEL_TEXT_SIZE);\r\n    mMonthTitlePaint.setTypeface(Typeface.create(mMonthTitleTypeface, Typeface.BOLD));\r\n    mMonthTitlePaint.setColor(mDayTextColor);\r\n    mMonthTitlePaint.setTextAlign(Align.CENTER);\r\n    mMonthTitlePaint.setStyle(Style.FILL);\r\n    mMonthTitleBGPaint = new Paint();\r\n    mMonthTitleBGPaint.setFakeBoldText(true);\r\n    mMonthTitleBGPaint.setAntiAlias(true);\r\n    mMonthTitleBGPaint.setColor(mMonthTitleBGColor);\r\n    mMonthTitleBGPaint.setTextAlign(Align.CENTER);\r\n    mMonthTitleBGPaint.setStyle(Style.FILL);\r\n    mSelectedCirclePaint = new Paint();\r\n    mSelectedCirclePaint.setFakeBoldText(true);\r\n    mSelectedCirclePaint.setAntiAlias(true);\r\n    mSelectedCirclePaint.setColor(mTodayNumberColor);\r\n    mSelectedCirclePaint.setTextAlign(Align.CENTER);\r\n    mSelectedCirclePaint.setStyle(Style.FILL);\r\n    mSelectedCirclePaint.setAlpha(SELECTED_CIRCLE_ALPHA);\r\n    mMonthDayLabelPaint = new Paint();\r\n    mMonthDayLabelPaint.setAntiAlias(true);\r\n    mMonthDayLabelPaint.setTextSize(MONTH_DAY_LABEL_TEXT_SIZE);\r\n    mMonthDayLabelPaint.setColor(mDayTextColor);\r\n    mMonthDayLabelPaint.setTypeface(Typeface.create(mDayOfWeekTypeface, Typeface.NORMAL));\r\n    mMonthDayLabelPaint.setStyle(Style.FILL);\r\n    mMonthDayLabelPaint.setTextAlign(Align.CENTER);\r\n    mMonthDayLabelPaint.setFakeBoldText(true);\r\n    mMonthNumPaint = new Paint();\r\n    mMonthNumPaint.setAntiAlias(true);\r\n    mMonthNumPaint.setTextSize(MINI_DAY_NUMBER_TEXT_SIZE);\r\n    mMonthNumPaint.setStyle(Style.FILL);\r\n    mMonthNumPaint.setTextAlign(Align.CENTER);\r\n    mMonthNumPaint.setFakeBoldText(false);\r\n}"
}, {
	"Path": "com.marshalchen.common.commonUtils.dbUtils.GreenDaoUtils.getList",
	"Comment": "executes the query and returns the result as a list containing all entities loaded into memory.",
	"Method": "List getList(AbstractDao dao,Property orderProperty,WhereCondition whereCondition,WhereCondition whereConditions,List getList,AbstractDao dao,WhereCondition whereCondition,WhereCondition whereConditions,List getList,AbstractDao dao,Property orderProperty,List getList,AbstractDao dao,boolean isAsc,Property orderProperty,List getList,AbstractDao dao){\r\n    setIfLog();\r\n    List indexFavList = dao.queryBuilder().list();\r\n    return indexFavList;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.cropperimage.cropwindow.handle.HandleHelper.getActiveEdges",
	"Comment": "gets the edges associated with this handle as an ordered pair. theprimary edge in the pair is the determining side. thismethod is used when we need to maintain the aspect ratio.",
	"Method": "EdgePair getActiveEdges(EdgePair getActiveEdges,float x,float y,float targetAspectRatio){\r\n    final float potentialAspectRatio = getAspectRatio(x, y);\r\n    if (potentialAspectRatio > targetAspectRatio) {\r\n        mActiveEdges.primary = mVerticalEdge;\r\n        mActiveEdges.secondary = mHorizontalEdge;\r\n    } else {\r\n        mActiveEdges.primary = mHorizontalEdge;\r\n        mActiveEdges.secondary = mVerticalEdge;\r\n    }\r\n    return mActiveEdges;\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.recyclerplayground.layout.FixedGridLayoutManager.findViewByPosition",
	"Comment": "this is a helper method used by recyclerview to determineif a specific child view can be returned.",
	"Method": "View findViewByPosition(int position){\r\n    for (int i = 0; i < getChildCount(); i++) {\r\n        if (positionOfIndex(i) == position) {\r\n            return getChildAt(i);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.modifysys.ViewPager.addFocusables",
	"Comment": "we only want the current page that is being shown to be focusable.",
	"Method": "void addFocusables(ArrayList<View> views,int direction,int focusableMode){\r\n    final int focusableCount = views.size();\r\n    final int descendantFocusability = getDescendantFocusability();\r\n    if (descendantFocusability != FOCUS_BLOCK_DESCENDANTS) {\r\n        for (int i = 0; i < getChildCount(); i++) {\r\n            final View child = getChildAt(i);\r\n            if (child.getVisibility() == VISIBLE) {\r\n                ItemInfo ii = infoForChild(child);\r\n                if (ii != null && ii.position == mCurItem) {\r\n                    child.addFocusables(views, direction, focusableMode);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (descendantFocusability != FOCUS_AFTER_DESCENDANTS || (focusableCount == views.size())) {\r\n        if (!isFocusable()) {\r\n            return;\r\n        }\r\n        if ((focusableMode & FOCUSABLES_TOUCH_MODE) == FOCUSABLES_TOUCH_MODE && isInTouchMode() && !isFocusableInTouchMode()) {\r\n            return;\r\n        }\r\n        if (views != null) {\r\n            views.add(this);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.imageprocessing.GLRenderer.setBackgroundAlpha",
	"Comment": "sets only the alpha component of the background colour currently set for this glrenderer.",
	"Method": "void setBackgroundAlpha(float alpha){\r\n    this.alpha = alpha;\r\n}"
}, {
	"Path": "test.sanitycheck.CheckTestNamesTest.checkNoErrorWtihChildSuites",
	"Comment": "child suites and tests within different suites have same names",
	"Method": "void checkNoErrorWtihChildSuites(){\r\n    TestListenerAdapter tla = new TestListenerAdapter();\r\n    TestNG tng = create();\r\n    String testngXmlPath = getPathToResource(\"sanitycheck/test-b.xml\");\r\n    tng.setTestSuites(Collections.singletonList(testngXmlPath));\r\n    tng.addListener((ITestNGListener) tla);\r\n    tng.run();\r\n    Assert.assertEquals(tla.getPassedTests().size(), 4);\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase3Scenario2.verifyThatMethodLevelEventsRunInDifferentThreadsFromSuiteAndTestLevelEvents",
	"Comment": "verifies that the test method listener and execution events for a given test method all run in the same thread.",
	"Method": "void verifyThatMethodLevelEventsRunInDifferentThreadsFromSuiteAndTestLevelEvents(){\r\n    verifyEventThreadsSpawnedAfter(getAllSuiteListenerStartEventLogs().get(0).getThreadId(), testMethodLevelEventLogs, \"All the thread IDs for the test method level events should be greater than the thread ID for the \" + \"suite and test level events. The expectation is that since the suite and test level events \" + \"are running sequentially, and all the test methods are running in parallel, new threads \" + \"will be spawned after the thread executing the suite and test level events when new methods \" + \"begin executing. Suite and test level events thread ID: \" + getAllSuiteListenerStartEventLogs().get(0).getThreadId() + \". Test method level event logs: \" + testMethodLevelEventLogs);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassAFiveMethodsWithDataProviderOnSomeMethodsAndNoDepsSample.class, SUITE_A, SUITE_A_TEST_A);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassBSixMethodsWithDataProviderOnSomeMethodsAndNoDepsSample.class, SUITE_A, SUITE_A_TEST_A);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassCFiveMethodsWithDataProviderOnSomeMethodsAndNoDepsSample.class, SUITE_B, SUITE_B_TEST_A);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassDThreeMethodsWithDataProviderOnSomeMethodsAndNoDepsSample.class, SUITE_B, SUITE_B_TEST_B);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassEFourMethodsWithDataProviderOnSomeMethodsAndNoDepsSample.class, SUITE_B, SUITE_B_TEST_B);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassFSixMethodsWithDataProviderOnSomeMethodsAndNoDepsSample.class, SUITE_B, SUITE_B_TEST_B);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.easyandroidanimations.ParallelAnimator.animate",
	"Comment": "this method gets the arraylist, sets any parameters if needed and plays\tall animations in parallel.",
	"Method": "void animate(){\r\n    ArrayList<Animator> animatorList = new ArrayList<Animator>();\r\n    for (int i = 0; i < combinableList.size(); i++) {\r\n        if (duration > 0) {\r\n            combinableList.get(i).setDuration(duration);\r\n        }\r\n        animatorList.add(combinableList.get(i).getAnimatorSet());\r\n    }\r\n    AnimatorSet parallelSet = new AnimatorSet();\r\n    parallelSet.playTogether(animatorList);\r\n    if (interpolator != null) {\r\n        parallelSet.setInterpolator(interpolator);\r\n    }\r\n    parallelSet.addListener(new AnimatorListenerAdapter() {\r\n        @Override\r\n        public void onAnimationEnd(Animator animation) {\r\n            if (getListener() != null) {\r\n                getListener().onAnimationEnd(ParallelAnimator.this);\r\n            }\r\n        }\r\n    });\r\n    parallelSet.start();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.easyandroidanimations.ParallelAnimator.animate",
	"Comment": "this method gets the arraylist, sets any parameters if needed and plays\tall animations in parallel.",
	"Method": "void animate(){\r\n    if (getListener() != null) {\r\n        getListener().onAnimationEnd(ParallelAnimator.this);\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.staggeredgridview.ExtendableListView.makeAndAddView",
	"Comment": "gets a view either a new view an unused view?? or a recycled view and adds it to our children",
	"Method": "View makeAndAddView(int position,int y,boolean flowDown,boolean selected){\r\n    View child;\r\n    onChildCreated(position, flowDown);\r\n    if (!mDataChanged) {\r\n        child = mRecycleBin.getActiveView(position);\r\n        if (child != null) {\r\n            setupChild(child, position, y, flowDown, selected, true);\r\n            return child;\r\n        }\r\n    }\r\n    child = obtainView(position, mIsScrap);\r\n    setupChild(child, position, y, flowDown, selected, mIsScrap[0]);\r\n    return child;\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase1Scenario2.verifySuiteAndTestLevelEventsRunInSequentialOrderForIndividualSuites",
	"Comment": "for all suites, verify that the test level events run sequentially because the parallel mode is by methods only.",
	"Method": "void verifySuiteAndTestLevelEventsRunInSequentialOrderForIndividualSuites(){\r\n    verifySequentialTests(suiteOneSuiteAndTestLevelEventLogs, suiteOneTestLevelEventLogs, suiteOneSuiteListenerOnStartEventLog, suiteOneSuiteListenerOnFinishEventLog);\r\n    verifySequentialTests(suiteTwoSuiteAndTestLevelEventLogs, suiteTwoTestLevelEventLogs, suiteTwoSuiteListenerOnStartEventLog, suiteTwoSuiteListenerOnFinishEventLog);\r\n    verifySequentialTests(suiteThreeSuiteAndTestLevelEventLogs, suiteThreeTestLevelEventLogs, suiteThreeSuiteListenerOnStartEventLog, suiteThreeSuiteListenerOnFinishEventLog);\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase1Scenario1.verifyThatMethodLevelEventsRunInDifferentThreadsFromSuiteAndTestLevelEvents",
	"Comment": "verifies that the method level events all run in different threads from the test and suite level events.",
	"Method": "void verifyThatMethodLevelEventsRunInDifferentThreadsFromSuiteAndTestLevelEvents(){\r\n    verifyEventThreadsSpawnedAfter(testListenerOnStartThreadId, testMethodLevelEventLogs, \"All the thread IDs \" + \"for the test method level events should be greater than the thread ID for the suite and test level \" + \"events. The expectation is that since the suite and test level events are running sequentially, and \" + \"all the test methods are running in parallel, new threads will be spawned after the thread \" + \"executing the suite and test level events when new methods begin executing. Suite and test level \" + \"events thread ID: \" + testListenerOnStartThreadId + \". Test method level event logs: \" + testMethodLevelEventLogs);\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.BlurNavigationDrawer.NavigationDrawerFragment.setUp",
	"Comment": "users of this fragment must call this method to set up the navigation drawer interactions.",
	"Method": "void setUp(int fragmentId,DrawerLayout drawerLayout){\r\n    mFragmentContainerView = getActivity().findViewById(fragmentId);\r\n    mDrawerLayout = drawerLayout;\r\n    mDrawerLayout.setDrawerShadow(R.drawable.drawer_shadow, GravityCompat.START);\r\n    mDrawerLayout.setScrimColor(Color.TRANSPARENT);\r\n    mDrawerToggle = ((BlurDrawerLayout) mDrawerLayout).getBlurActionBarDrawerToggle();\r\n    ActionBar actionBar = getActionBar();\r\n    actionBar.setDisplayHomeAsUpEnabled(true);\r\n    actionBar.setHomeButtonEnabled(true);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.flipViews.flipview.FlipView.peakPrevious",
	"Comment": "hint that there is a previous page will do nothing if there is no\tprevious page",
	"Method": "void peakPrevious(boolean once){\r\n    if (mCurrentPageIndex > 0) {\r\n        peak(false, once);\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.imageprocessing.GLRenderer.getBackgroundAlpha",
	"Comment": "returns the alpha component of the background colour currently set for this glrenderer.",
	"Method": "float getBackgroundAlpha(){\r\n    return alpha;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.circularfloatingactionmenu.FloatingActionMenu.getActionViewCoordinates",
	"Comment": "gets the coordinates of the main action viewthis method should only be called after the main layout of the activity is drawn,such as when a user clicks the action button.",
	"Method": "Point getActionViewCoordinates(){\r\n    int[] coords = new int[2];\r\n    mainActionView.getLocationOnScreen(coords);\r\n    Rect activityFrame = new Rect();\r\n    getActivityContentView().getWindowVisibleDisplayFrame(activityFrame);\r\n    coords[0] -= (getScreenSize().x - getActivityContentView().getMeasuredWidth());\r\n    coords[1] -= (activityFrame.height() + activityFrame.top - getActivityContentView().getMeasuredHeight());\r\n    return new Point(coords[0], coords[1]);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.freeflow.core.FreeFlowContainer.prepareViewForAddition",
	"Comment": "does all the necessary work right before a view is about to be laid out.",
	"Method": "void prepareViewForAddition(View view,FreeFlowItem freeflowItem){\r\n    if (view instanceof Checkable) {\r\n        ((Checkable) view).setChecked(isChecked(freeflowItem.itemSection, freeflowItem.itemIndex));\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.freeflow.core.FreeFlowContainer.getScrollPercentY",
	"Comment": "returns the percentage of height scrolled. the values range from 0 to 1",
	"Method": "float getScrollPercentY(){\r\n    if (mLayout == null || mAdapter == null)\r\n        return 0;\r\n    float ht = mLayout.getContentHeight();\r\n    float scrollableHeight = ht - getHeight();\r\n    if (scrollableHeight == 0)\r\n        return 0;\r\n    return viewPortY / scrollableHeight;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.freeflow.core.FreeFlowContainer.getScrollPercentX",
	"Comment": "returns the percentage of width scrolled. the values range from 0 to 1",
	"Method": "float getScrollPercentX(){\r\n    if (mLayout == null || mAdapter == null)\r\n        return 0;\r\n    float w = mLayout.getContentWidth();\r\n    float scrollableWidth = w - getWidth();\r\n    if (scrollableWidth == 0)\r\n        return 0;\r\n    return viewPortX / scrollableWidth;\r\n}"
}, {
	"Path": "org.isoron.uhabits.core.models.StreakList.findBeginning",
	"Comment": "finds the place where we should start when recomputing the streaks.",
	"Method": "Timestamp findBeginning(){\r\n    Streak newestStreak = getNewestComputed();\r\n    if (newestStreak != null)\r\n        return newestStreak.getStart();\r\n    Repetition oldestRep = habit.getRepetitions().getOldest();\r\n    if (oldestRep != null)\r\n        return oldestRep.getTimestamp();\r\n    return null;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.cropperimage.CropImageView.setGuidelines",
	"Comment": "sets the guidelines for the cropoverlayview to be either on, off, or to show whenresizing the application.",
	"Method": "void setGuidelines(int guidelines){\r\n    mCropOverlayView.setGuidelines(guidelines);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.tileView.widgets.Scroller.fling",
	"Comment": "start scrolling based on a fling gesture. the distance travelled willdepend on the initial velocity of the fling.",
	"Method": "void fling(int startX,int startY,int velocityX,int velocityY,int minX,int maxX,int minY,int maxY){\r\n    if (mFlywheel && !mFinished) {\r\n        float oldVel = getCurrVelocity();\r\n        float dx = (float) (mFinalX - mStartX);\r\n        float dy = (float) (mFinalY - mStartY);\r\n        float hyp = FloatMath.sqrt(dx * dx + dy * dy);\r\n        float ndx = dx / hyp;\r\n        float ndy = dy / hyp;\r\n        float oldVelocityX = ndx * oldVel;\r\n        float oldVelocityY = ndy * oldVel;\r\n        if (Math.signum(velocityX) == Math.signum(oldVelocityX) && Math.signum(velocityY) == Math.signum(oldVelocityY)) {\r\n            velocityX += oldVelocityX;\r\n            velocityY += oldVelocityY;\r\n        }\r\n    }\r\n    mMode = FLING_MODE;\r\n    mFinished = false;\r\n    float velocity = FloatMath.sqrt(velocityX * velocityX + velocityY * velocityY);\r\n    mVelocity = velocity;\r\n    final double l = Math.log(START_TENSION * velocity / ALPHA);\r\n    mDuration = (int) (1000.0 * Math.exp(l / (DECELERATION_RATE - 1.0)));\r\n    mStartTime = AnimationUtils.currentAnimationTimeMillis();\r\n    mStartX = startX;\r\n    mStartY = startY;\r\n    float coeffX = velocity == 0 ? 1.0f : velocityX / velocity;\r\n    float coeffY = velocity == 0 ? 1.0f : velocityY / velocity;\r\n    int totalDistance = (int) (ALPHA * Math.exp(DECELERATION_RATE / (DECELERATION_RATE - 1.0) * l));\r\n    mMinX = minX;\r\n    mMaxX = maxX;\r\n    mMinY = minY;\r\n    mMaxY = maxY;\r\n    mFinalX = startX + Math.round(totalDistance * coeffX);\r\n    mFinalX = Math.min(mFinalX, mMaxX);\r\n    mFinalX = Math.max(mFinalX, mMinX);\r\n    mFinalY = startY + Math.round(totalDistance * coeffY);\r\n    mFinalY = Math.min(mFinalY, mMaxY);\r\n    mFinalY = Math.max(mFinalY, mMinY);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.animation.ValueAnimator.getRepeatMode",
	"Comment": "defines what this animation should do when it reaches the end.",
	"Method": "int getRepeatMode(){\r\n    return mRepeatMode;\r\n}"
}, {
	"Path": "com.marshalchen.common.ui.ShimmerFrameLayout.getBaseAlpha",
	"Comment": "get the alpha currently used to render the base view i.e. the unhighlighted view over which the highlight is drawn.",
	"Method": "float getBaseAlpha(){\r\n    return (float) mAlphaPaint.getAlpha() / 0xff;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.circularfloatingactionmenu.animation.MenuAnimationHandler.restoreSubActionViewAfterAnimation",
	"Comment": "restores the specified sub action view to its final state, accoding to the current actiontypeshould be called after an animation finishes.",
	"Method": "void restoreSubActionViewAfterAnimation(FloatingActionMenu.Item subActionItem,ActionType actionType){\r\n    FrameLayout.LayoutParams params = (FrameLayout.LayoutParams) subActionItem.view.getLayoutParams();\r\n    subActionItem.view.setTranslationX(0);\r\n    subActionItem.view.setTranslationY(0);\r\n    subActionItem.view.setRotation(0);\r\n    subActionItem.view.setScaleX(1);\r\n    subActionItem.view.setScaleY(1);\r\n    subActionItem.view.setAlpha(1);\r\n    if (actionType == ActionType.OPENING) {\r\n        params.setMargins(subActionItem.x, subActionItem.y, 0, 0);\r\n        subActionItem.view.setLayoutParams(params);\r\n    } else if (actionType == ActionType.CLOSING) {\r\n        Point center = menu.getActionViewCenter();\r\n        params.setMargins(center.x - subActionItem.width / 2, center.y - subActionItem.height / 2, 0, 0);\r\n        subActionItem.view.setLayoutParams(params);\r\n        ((ViewGroup) menu.getActivityContentView()).removeView(subActionItem.view);\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.tileView.widgets.Scroller.getDuration",
	"Comment": "returns how long the scroll event will take, in milliseconds.",
	"Method": "int getDuration(){\r\n    return mDuration;\r\n}"
}, {
	"Path": "test.conffailure.ClassWithFailedBeforeSuiteVerification.setUp",
	"Comment": "should not be run because beforesuite failed on the other class",
	"Method": "void setUp(){\r\n    m_success1 = false;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.kenburnsview.Transition.getInterpolatedRect",
	"Comment": "gets the current rect that represents the part of the image to take the scenein the current frame.",
	"Method": "RectF getInterpolatedRect(long elapsedTime){\r\n    float elapsedTimeFraction = elapsedTime / (float) mDuration;\r\n    float interpolationProgress = Math.min(elapsedTimeFraction, 1);\r\n    float interpolation = mInterpolator.getInterpolation(interpolationProgress);\r\n    float currentWidth = mSrcRect.width() + (interpolation * mWidthDiff);\r\n    float currentHeight = mSrcRect.height() + (interpolation * mHeightDiff);\r\n    float currentCenterX = mSrcRect.centerX() + (interpolation * mCenterXDiff);\r\n    float currentCenterY = mSrcRect.centerY() + (interpolation * mCenterYDiff);\r\n    float left = currentCenterX - (currentWidth / 2);\r\n    float top = currentCenterY - (currentHeight / 2);\r\n    float right = left + currentWidth;\r\n    float bottom = top + currentHeight;\r\n    mCurrentRect.set(left, top, right, bottom);\r\n    return mCurrentRect;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.rebound.Spring.setRestDisplacementThreshold",
	"Comment": "set the threshold of displacement from rest below which the spring should be considered at rest",
	"Method": "Spring setRestDisplacementThreshold(double displacementFromRestThreshold){\r\n    mDisplacementFromRestThreshold = displacementFromRestThreshold;\r\n    return this;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.tileView.tileview.TileView.refresh",
	"Comment": "request the tileview reevaluate tile sets, rendered tiles, samples, invalidates, etc",
	"Method": "void refresh(){\r\n    updateViewport();\r\n    tileManager.updateTileSet();\r\n    tileManager.requestRender();\r\n    sampleManager.update();\r\n    redraw();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.cropperimage.util.HandleUtil.isInVerticalTargetZone",
	"Comment": "determines if the specified coordinate is in the target touch zone for avertical bar handle.",
	"Method": "boolean isInVerticalTargetZone(float x,float y,float handleX,float handleYStart,float handleYEnd,float targetRadius){\r\n    if (Math.abs(x - handleX) <= targetRadius && y > handleYStart && y < handleYEnd) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.freeflow.core.FreeFlowContainer.getFreeFlowItem",
	"Comment": "returns the freeflowitem representing the data passed in if\tthat item is being rendered in the container.",
	"Method": "FreeFlowItem getFreeFlowItem(Object dataItem){\r\n    for (FreeFlowItem item : frames.values()) {\r\n        if (item.data.equals(dataItem)) {\r\n            return item;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.ThumbnailParameter.useOriginalImageType",
	"Comment": "returns whether or not the original image type should be used for the\tthumbnail.",
	"Method": "boolean useOriginalImageType(){\r\n    return imageType == ORIGINAL_IMAGE_TYPE;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.foldingLayout.BaseFoldingLayout.calculateMatrices",
	"Comment": "calculates the transformation matrices used to draw each of the separatefolding segments from this view.",
	"Method": "void calculateMatrices(){\r\n    mShouldDraw = true;\r\n    if (!mIsFoldPrepared) {\r\n        return;\r\n    }\r\n    if (mFoldFactor == 1) {\r\n        mShouldDraw = false;\r\n        return;\r\n    }\r\n    if (mFoldFactor == 0 && mPreviousFoldFactor > 0 && mFoldListener != null) {\r\n        mFoldListener.onEndFold();\r\n    }\r\n    if (mPreviousFoldFactor == 0 && mFoldFactor > 0 && mFoldListener != null) {\r\n        mFoldListener.onStartFold();\r\n    }\r\n    mPreviousFoldFactor = mFoldFactor;\r\n    for (int x = 0; x < mNumberOfFolds; x++) {\r\n        mMatrix[x].reset();\r\n    }\r\n    float cTranslationFactor = 1 - mFoldFactor;\r\n    float translatedDistance = mIsHorizontal ? mOriginalWidth * cTranslationFactor : mOriginalHeight * cTranslationFactor;\r\n    float translatedDistancePerFold = Math.round(translatedDistance / mNumberOfFolds);\r\n    mFoldDrawWidth = mFoldMaxWidth < translatedDistancePerFold ? translatedDistancePerFold : mFoldMaxWidth;\r\n    mFoldDrawHeight = mFoldMaxHeight < translatedDistancePerFold ? translatedDistancePerFold : mFoldMaxHeight;\r\n    float translatedDistanceFoldSquared = translatedDistancePerFold * translatedDistancePerFold;\r\n    float depth = mIsHorizontal ? (float) Math.sqrt((double) (mFoldDrawWidth * mFoldDrawWidth - translatedDistanceFoldSquared)) : (float) Math.sqrt((double) (mFoldDrawHeight * mFoldDrawHeight - translatedDistanceFoldSquared));\r\n    float scaleFactor = DEPTH_CONSTANT / (DEPTH_CONSTANT + depth);\r\n    float scaledWidth, scaledHeight, bottomScaledPoint, topScaledPoint, rightScaledPoint, leftScaledPoint;\r\n    if (mIsHorizontal) {\r\n        scaledWidth = mFoldDrawWidth * cTranslationFactor;\r\n        scaledHeight = mFoldDrawHeight * scaleFactor;\r\n    } else {\r\n        scaledWidth = mFoldDrawWidth * scaleFactor;\r\n        scaledHeight = mFoldDrawHeight * cTranslationFactor;\r\n    }\r\n    topScaledPoint = (mFoldDrawHeight - scaledHeight) / 2.0f;\r\n    bottomScaledPoint = topScaledPoint + scaledHeight;\r\n    leftScaledPoint = (mFoldDrawWidth - scaledWidth) / 2.0f;\r\n    rightScaledPoint = leftScaledPoint + scaledWidth;\r\n    float anchorPoint = mIsHorizontal ? mAnchorFactor * mOriginalWidth : mAnchorFactor * mOriginalHeight;\r\n    float midFold = mIsHorizontal ? (anchorPoint / mFoldDrawWidth) : anchorPoint / mFoldDrawHeight;\r\n    mSrc[0] = 0;\r\n    mSrc[1] = 0;\r\n    mSrc[2] = 0;\r\n    mSrc[3] = mFoldDrawHeight;\r\n    mSrc[4] = mFoldDrawWidth;\r\n    mSrc[5] = 0;\r\n    mSrc[6] = mFoldDrawWidth;\r\n    mSrc[7] = mFoldDrawHeight;\r\n    for (int x = 0; x < mNumberOfFolds; x++) {\r\n        boolean isEven = (x % 2 == 0);\r\n        if (mIsHorizontal) {\r\n            mDst[0] = (anchorPoint > x * mFoldDrawWidth) ? anchorPoint + (x - midFold) * scaledWidth : anchorPoint - (midFold - x) * scaledWidth;\r\n            mDst[1] = isEven ? 0 : topScaledPoint;\r\n            mDst[2] = mDst[0];\r\n            mDst[3] = isEven ? mFoldDrawHeight : bottomScaledPoint;\r\n            mDst[4] = (anchorPoint > (x + 1) * mFoldDrawWidth) ? anchorPoint + (x + 1 - midFold) * scaledWidth : anchorPoint - (midFold - x - 1) * scaledWidth;\r\n            mDst[5] = isEven ? topScaledPoint : 0;\r\n            mDst[6] = mDst[4];\r\n            mDst[7] = isEven ? bottomScaledPoint : mFoldDrawHeight;\r\n        } else {\r\n            mDst[0] = isEven ? 0 : leftScaledPoint;\r\n            mDst[1] = (anchorPoint > x * mFoldDrawHeight) ? anchorPoint + (x - midFold) * scaledHeight : anchorPoint - (midFold - x) * scaledHeight;\r\n            mDst[2] = isEven ? leftScaledPoint : 0;\r\n            mDst[3] = (anchorPoint > (x + 1) * mFoldDrawHeight) ? anchorPoint + (x + 1 - midFold) * scaledHeight : anchorPoint - (midFold - x - 1) * scaledHeight;\r\n            mDst[4] = isEven ? mFoldDrawWidth : rightScaledPoint;\r\n            mDst[5] = mDst[1];\r\n            mDst[6] = isEven ? rightScaledPoint : mFoldDrawWidth;\r\n            mDst[7] = mDst[3];\r\n        }\r\n        for (int y = 0; y < 8; y++) {\r\n            mDst[y] = Math.round(mDst[y]);\r\n        }\r\n        if (mIsHorizontal) {\r\n            if (mDst[4] <= mDst[0] || mDst[6] <= mDst[2]) {\r\n                mShouldDraw = false;\r\n                return;\r\n            }\r\n        } else {\r\n            if (mDst[3] <= mDst[1] || mDst[7] <= mDst[5]) {\r\n                mShouldDraw = false;\r\n                return;\r\n            }\r\n        }\r\n        mMatrix[x].setPolyToPoly(mSrc, 0, mDst, 0, NUM_OF_POLY_POINTS / 2);\r\n    }\r\n    int alpha = (int) (mFoldFactor * 255 * SHADING_ALPHA);\r\n    mSolidShadow.setColor(Color.argb(alpha, 0, 0, 0));\r\n    if (mIsHorizontal) {\r\n        mShadowGradientMatrix.setScale(mFoldDrawWidth, 1);\r\n        mShadowLinearGradient.setLocalMatrix(mShadowGradientMatrix);\r\n    } else {\r\n        mShadowGradientMatrix.setScale(1, mFoldDrawHeight);\r\n        mShadowLinearGradient.setLocalMatrix(mShadowGradientMatrix);\r\n    }\r\n    mGradientShadow.setAlpha(alpha);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.animation.ValueAnimator.getCurrentAnimationsCount",
	"Comment": "return the number of animations currently running.used by strictmode internally to annotate violations.onlycalled on the main thread.",
	"Method": "int getCurrentAnimationsCount(){\r\n    return sAnimations.get().size();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.animation.ObjectAnimator.getTarget",
	"Comment": "the target object whose property will be animated by this animation",
	"Method": "Object getTarget(){\r\n    return mTarget;\r\n}"
}, {
	"Path": "org.testng.log4testng.Logger.testRootLoggerSetError",
	"Comment": "test setting the root logger to an illegal level value throws an exception.",
	"Method": "void testRootLoggerSetError(){\r\n    Properties props = new Properties();\r\n    ByteArrayOutputStream out1 = new ByteArrayOutputStream();\r\n    ByteArrayOutputStream err1 = new ByteArrayOutputStream();\r\n    PrintStream out2 = new PrintStream(out1);\r\n    PrintStream err2 = new PrintStream(err1);\r\n    props.put(\"log4testng.rootLogger\", \"unknown\");\r\n    try {\r\n        testInitialize(props, out2, err2);\r\n        throw new RuntimeException(\"failure\");\r\n    } catch (IllegalArgumentException pEx) {\r\n        Assert.assertEquals(out1.toString(), \"\");\r\n        Assert.assertEquals(err1.toString(), \"\");\r\n    }\r\n}"
}, {
	"Path": "com.android.colorpicker.ColorStateDrawable.getPressedColor",
	"Comment": "given a particular color, adjusts its value by a multiplier.",
	"Method": "int getPressedColor(int color){\r\n    float[] hsv = new float[3];\r\n    Color.colorToHSV(color, hsv);\r\n    hsv[2] = hsv[2] * PRESSED_STATE_MULTIPLIER;\r\n    return Color.HSVToColor(hsv);\r\n}"
}, {
	"Path": "com.marshalchen.common.ui.ShimmerFrameLayout.setBaseAlpha",
	"Comment": "set the alpha to be used to render the base view i.e. the unhighlighted view over which the highlight is drawn.",
	"Method": "void setBaseAlpha(float alpha){\r\n    mAlphaPaint.setAlpha((int) (clamp(0, 1, alpha) * 0xff));\r\n    resetAll();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.animation.PropertyValuesHolder.setProperty",
	"Comment": "sets the property that will be animated.note that if this propertyvaluesholder object is used with objectanimator, the propertymust exist on the target object specified in that objectanimator.",
	"Method": "void setProperty(Property property){\r\n    mProperty = property;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.imageprocessing.inputprocess.VideoResourceInput.startWhenReady",
	"Comment": "starts the video player if the opengl context has initialized the video already.otherwise,\tstarts the video once the opengl context has been initialized.",
	"Method": "void startWhenReady(){\r\n    if (ready) {\r\n        player.start();\r\n    } else {\r\n        startWhenReady = true;\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.staggeredgridview.ExtendableListView.fillSpecific",
	"Comment": "put a specific item at a specific location on the screen and then buildup and down from there.",
	"Method": "View fillSpecific(int position,int top){\r\n    boolean tempIsSelected = false;\r\n    View temp = makeAndAddView(position, top, true, tempIsSelected);\r\n    mFirstPosition = position;\r\n    View above;\r\n    View below;\r\n    int nextBottom = getNextChildUpsBottom(position - 1);\r\n    int nextTop = getNextChildDownsTop(position + 1);\r\n    above = fillUp(position - 1, nextBottom);\r\n    adjustViewsUpOrDown();\r\n    below = fillDown(position + 1, nextTop);\r\n    int childCount = getChildCount();\r\n    if (childCount > 0) {\r\n        correctTooHigh(childCount);\r\n    }\r\n    if (tempIsSelected) {\r\n        return temp;\r\n    } else if (above != null) {\r\n        return above;\r\n    } else {\r\n        return below;\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.cropperimage.util.HandleUtil.focusCenter",
	"Comment": "determines if the cropper should focus on the center handle or the sidehandles. if it is a small image, focus on the center handle so the usercan move it. if it is a large image, focus on the side handles so usercan grab them. corresponds to the appearance of theruleofthirdsguidelines.",
	"Method": "boolean focusCenter(){\r\n    return (!CropOverlayView.showGuidelines());\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.recyclerplayground.layout.FixedGridLayoutManager.positionOfIndex",
	"Comment": "mapping between child view indices and adapter datapositions helps fill the proper views during scrolling.",
	"Method": "int positionOfIndex(int childIndex){\r\n    int row = childIndex / mVisibleColumnCount;\r\n    int column = childIndex % mVisibleColumnCount;\r\n    return mFirstVisiblePosition + (row * getTotalColumnCount()) + column;\r\n}"
}, {
	"Path": "test.thread.parallelization.TestNgRunStateTracker.getTestMethodExecutionEventLogsForTest",
	"Comment": "get the test method execution event logs for the specified suite and test",
	"Method": "List<EventLog> getTestMethodExecutionEventLogsForTest(String suiteName,String testName){\r\n    List<EventLog> testMethodExecuteEventLogs = new ArrayList();\r\n    for (EventLog eventLog : eventLogs) {\r\n        if (eventLog.getEvent() == TestNgRunEvent.TEST_METHOD_EXECUTION && belongsToTest(suiteName, testName, eventLog)) {\r\n            testMethodExecuteEventLogs.add(eventLog);\r\n        }\r\n    }\r\n    return testMethodExecuteEventLogs;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.cropperimage.util.HandleUtil.isInCenterTargetZone",
	"Comment": "determines if the specified coordinate falls anywhere inside the givenbounds.",
	"Method": "boolean isInCenterTargetZone(float x,float y,float left,float top,float right,float bottom){\r\n    if (x > left && x < right && y > top && y < bottom) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.dragSortListView.DragSortController.setFlingHandleId",
	"Comment": "set the resource id for the view that represents the flinghandle in a list item.",
	"Method": "void setFlingHandleId(int id){\r\n    mFlingHandleId = id;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.swipeback.ViewDragHelper.setMinVelocity",
	"Comment": "set the minimum velocity that will be detected as having a magnitudegreater than zero in pixels per second. callback methods accepting avelocity will be clamped appropriately.",
	"Method": "void setMinVelocity(float minVel){\r\n    mMinVelocity = minVel;\r\n}"
}, {
	"Path": "com.marshalchen.ua.common.commonUtils.dbUtils.GreenDaoUtils.getList",
	"Comment": "executes the query and returns the result as a list containing all entities loaded into memory.",
	"Method": "List getList(AbstractDao dao,Property orderProperty,WhereCondition whereCondition,WhereCondition whereConditions,List getList,AbstractDao dao,WhereCondition whereCondition,WhereCondition whereConditions,List getList,AbstractDao dao,Property orderProperty,List getList,AbstractDao dao,boolean isAsc,Property orderProperty,List getList,AbstractDao dao){\r\n    setIfLog();\r\n    List indexFavList = dao.queryBuilder().list();\r\n    return indexFavList;\r\n}"
}, {
	"Path": "org.testng.internal.TestMethodWorker.getTimeOut",
	"Comment": "retrieves the maximum specified timeout of all itestngmethods to be run.",
	"Method": "long getTimeOut(){\r\n    long result = 0;\r\n    for (IMethodInstance mi : m_methodInstances) {\r\n        ITestNGMethod tm = mi.getMethod();\r\n        if (tm.getTimeOut() > result) {\r\n            result = tm.getTimeOut();\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.recyclerplayground.layout.StaticGridLayoutManager.updateWindowSizing",
	"Comment": "rather than continuously checking how many views we can fitbased on scroll offsets, we simplify the math by computing thevisible grid as what will initially fit on screen, plus one.",
	"Method": "void updateWindowSizing(){\r\n    mVisibleColumnCount = (getHorizontalSpace() / mDecoratedChildWidth) + 1;\r\n    if (getHorizontalSpace() % mDecoratedChildWidth > 0) {\r\n        mVisibleColumnCount++;\r\n    }\r\n    if (mVisibleColumnCount > getTotalColumnCount()) {\r\n        mVisibleColumnCount = getTotalColumnCount();\r\n    }\r\n    mVisibleRowCount = (getVerticalSpace() / mDecoratedChildHeight) + 1;\r\n    if (getVerticalSpace() % mDecoratedChildHeight > 0) {\r\n        mVisibleRowCount++;\r\n    }\r\n    if (mVisibleRowCount > getTotalRowCount()) {\r\n        mVisibleRowCount = getTotalRowCount();\r\n    }\r\n}"
}, {
	"Path": "org.testng.reporters.EmailableReporter2.writeTag",
	"Comment": "writes an arbitrary html element with the specified contents and css class names.",
	"Method": "void writeTag(String tag,String html,String cssClasses){\r\n    writer.print(\"<\");\r\n    writer.print(tag);\r\n    if (cssClasses != null) {\r\n        writer.print(\" class=\\\"\");\r\n        writer.print(cssClasses);\r\n        writer.print(\"\\\"\");\r\n    }\r\n    writer.print(\">\");\r\n    writer.print(html);\r\n    writer.print(\"<\/\");\r\n    writer.print(tag);\r\n    writer.print(\">\");\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase5Scenario2.verifySuiteAndTestLevelEventsRunInSequentialOrderForIndividualSuites",
	"Comment": "for all suites, verify that the test level events run sequentially because the parallel mode is by methods only.",
	"Method": "void verifySuiteAndTestLevelEventsRunInSequentialOrderForIndividualSuites(){\r\n    verifySequentialTests(suiteOneSuiteAndTestLevelEventLogs, suiteOneTestLevelEventLogs, suiteOneSuiteListenerOnStartEventLog, suiteOneSuiteListenerOnFinishEventLog);\r\n    verifySequentialTests(suiteTwoSuiteAndTestLevelEventLogs, suiteTwoTestLevelEventLogs, suiteTwoSuiteListenerOnStartEventLog, suiteTwoSuiteListenerOnFinishEventLog);\r\n}"
}, {
	"Path": "com.marshalchen.ua.common.usefulModule.CircularImageView.setShadow",
	"Comment": "enables a dark shadow for this circularimageview.\tif the radius is set to 0, the shadow is removed.",
	"Method": "void setShadow(float radius,float dx,float dy,int color){\r\n    shadowRadius = radius;\r\n    shadowDx = dx;\r\n    shadowDy = dy;\r\n    shadowColor = color;\r\n    updateShadow();\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.dragSortListview.DSLVFragment.getItemLayout",
	"Comment": "return list item layout resource passed to the arrayadapter.",
	"Method": "int getItemLayout(){\r\n    if (removeMode == DragSortController.CLICK_REMOVE) {\r\n        return R.layout.drag_sort_listview_list_item_click_remove;\r\n    } else {\r\n        return R.layout.drag_sort_listview_list_item_handle_left;\r\n    }\r\n}"
}, {
	"Path": "org.isoron.uhabits.core.database.Repository.findFirst",
	"Comment": "returns the first record matching the given sql query.see findall for more details about the parameters.",
	"Method": "T findFirst(String query,String params){\r\n    try (Cursor c = db.query(buildSelectQuery() + query, params)) {\r\n        if (!c.moveToNext())\r\n            return null;\r\n        return cursorToSingleRecord(c);\r\n    }\r\n}"
}, {
	"Path": "org.isoron.androidbase.activities.BaseScreen.startSelection",
	"Comment": "instructs the screen to start a selection.if a selection menu was provided, this menu will be shown instead of theregular one.",
	"Method": "void startSelection(){\r\n    activity.startSupportActionMode(new ActionModeWrapper());\r\n}"
}, {
	"Path": "com.android.datetimepicker.time.RadialPickerLayout.isHourInnerCircle",
	"Comment": "check if a given hour appears in the outer circle or the inner circle",
	"Method": "boolean isHourInnerCircle(int hourOfDay){\r\n    return mIs24HourMode && (hourOfDay <= 12 && hourOfDay != 0);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.view.ViewPropertyAnimatorPreHC.setDuration",
	"Comment": "sets the duration for the underlying animator that animates the requested properties.by default, the animator uses the default value for valueanimator. calling this methodwill cause the declared value to be used instead.",
	"Method": "ViewPropertyAnimator setDuration(long duration){\r\n    if (duration < 0) {\r\n        throw new IllegalArgumentException(\"Animators cannot have negative duration: \" + duration);\r\n    }\r\n    mDurationSet = true;\r\n    mDuration = duration;\r\n    return this;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.animation.PropertyValuesHolder.setupStartValue",
	"Comment": "this function is called by objectanimator when setting the start values for an animation.the start values are set according to the current values in the target object. theproperty whose value is extracted is whatever is specified by the propertyname of thispropertyvaluesholder object.",
	"Method": "void setupStartValue(Object target){\r\n    setupValue(target, mKeyframeSet.mKeyframes.get(0));\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.animation.Keyframe.getInterpolator",
	"Comment": "gets the optional interpolator for this keyframe. a value of null indicatesthat there is no interpolation, which is the same as linear interpolation.",
	"Method": "Interpolator getInterpolator(){\r\n    return mInterpolator;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.animation.ValueAnimator.removeAllUpdateListeners",
	"Comment": "removes all listeners from the set listening to frame updates for this animation.",
	"Method": "void removeAllUpdateListeners(){\r\n    if (mUpdateListeners == null) {\r\n        return;\r\n    }\r\n    mUpdateListeners.clear();\r\n    mUpdateListeners = null;\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase5Scenario1.sanityCheck",
	"Comment": "verifies that the expected number of suite, test and test method level events were logged.",
	"Method": "void sanityCheck(){\r\n    assertEquals(suiteLevelEventLogs.size(), 2, \"There should be 2 suite level events logged for \" + SUITE + \": \" + suiteLevelEventLogs);\r\n    assertEquals(testLevelEventLogs.size(), 2, \"There should be 2 test level events logged for \" + SUITE + \": \" + testLevelEventLogs);\r\n    assertEquals(testMethodLevelEventLogs.size(), 30, \"There should be 15 test method level event logged for \" + SUITE + \": \" + testMethodLevelEventLogs);\r\n}"
}, {
	"Path": "com.marshalchen.ua.common.usefulModule.CircularImageView.setSelectorStrokeWidth",
	"Comment": "sets the stroke width to be drawn around the circularimageview\tduring click events when the selector is enabled.",
	"Method": "void setSelectorStrokeWidth(int selectorStrokeWidth){\r\n    this.selectorStrokeWidth = selectorStrokeWidth;\r\n    this.requestLayout();\r\n    this.invalidate();\r\n}"
}, {
	"Path": "com.marshalchen.ua.common.commonUtils.urlUtils.HttpsUtils.getSSLSocketFactory",
	"Comment": "build sslsocketfactory using certificate file from assets.",
	"Method": "SSLSocketFactory getSSLSocketFactory(Context context,String certFilePath,SSLSocketFactory getSSLSocketFactory,Context context,String certFilePath,InputStream key,String keyPassword,SSLSocketFactory getSSLSocketFactory,InputStream certificates,InputStream key,String keyPassword){\r\n    CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\r\n    InputStream caInput = new BufferedInputStream(certificates);\r\n    Certificate ca;\r\n    try {\r\n        ca = cf.generateCertificate(caInput);\r\n    } finally {\r\n        caInput.close();\r\n    }\r\n    String keyStoreType = KeyStore.getDefaultType();\r\n    KeyStore keyStore = KeyStore.getInstance(keyStoreType);\r\n    keyStore.load(null, null);\r\n    keyStore.setCertificateEntry(\"ca\", ca);\r\n    KeyManagerFactory kmf = null;\r\n    if (key != null && keyPassword != null) {\r\n        kmf = getKeyManagerFactory(key, keyPassword);\r\n    }\r\n    String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\r\n    TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\r\n    tmf.init(keyStore);\r\n    SSLContext contexts = SSLContext.getInstance(\"TLS\");\r\n    contexts.init(kmf == null ? null : kmf.getKeyManagers(), tmf.getTrustManagers(), null);\r\n    return contexts.getSocketFactory();\r\n}"
}, {
	"Path": "com.android.datetimepicker.date.MonthView.drawMonthNums",
	"Comment": "draws the week and month day numbers for this week. override this methodif you need different placement.",
	"Method": "void drawMonthNums(Canvas canvas){\r\n    int y = (((mRowHeight + MINI_DAY_NUMBER_TEXT_SIZE) / 2) - DAY_SEPARATOR_WIDTH) + MONTH_HEADER_SIZE;\r\n    int dayWidthHalf = (mWidth - mPadding * 2) / (mNumDays * 2);\r\n    int j = findDayOffset();\r\n    for (int dayNumber = 1; dayNumber <= mNumCells; dayNumber++) {\r\n        int x = (2 * j + 1) * dayWidthHalf + mPadding;\r\n        int yRelativeToDay = (mRowHeight + MINI_DAY_NUMBER_TEXT_SIZE) / 2 - DAY_SEPARATOR_WIDTH;\r\n        int startX = x - dayWidthHalf;\r\n        int stopX = x + dayWidthHalf;\r\n        int startY = y - yRelativeToDay;\r\n        int stopY = startY + mRowHeight;\r\n        drawMonthDay(canvas, mYear, mMonth, dayNumber, x, y, startX, stopX, startY, stopY);\r\n        j++;\r\n        if (j == mNumDays) {\r\n            j = 0;\r\n            y += mRowHeight;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.ua.common.commonUtils.fileUtils.ParcelUtils.writeHashMapStringKey",
	"Comment": "write a hashmap to a parcel, class of key is string, class of value can parcelable",
	"Method": "void writeHashMapStringKey(Map<String, V> map,Parcel out,int flags){\r\n    if (map != null) {\r\n        out.writeInt(map.size());\r\n        for (Entry<String, V> entry : map.entrySet()) {\r\n            out.writeString(entry.getKey());\r\n            out.writeParcelable(entry.getValue(), flags);\r\n        }\r\n    } else {\r\n        out.writeInt(-1);\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.square_progressbar.SquareProgressBar.setClearOnHundred",
	"Comment": "if the progress hits 100% then the progressbar disappears if this flag is\tset to true. the default is set to false.",
	"Method": "void setClearOnHundred(boolean clearOnHundred){\r\n    bar.setClearOnHundred(clearOnHundred);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.dragSortListView.SimpleDragSortCursorAdapter.getCursorToStringConverter",
	"Comment": "returns the converter used to convert the filtering cursorinto a string.",
	"Method": "CursorToStringConverter getCursorToStringConverter(){\r\n    return mCursorToStringConverter;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.discreteseekbar.internal.PopupIndicator.dismissComplete",
	"Comment": "force the popup window to be removed.you typically calls this when the parent view is being removed from the window to avoid a window leak",
	"Method": "void dismissComplete(){\r\n    if (isShowing()) {\r\n        mShowing = false;\r\n        try {\r\n            mWindowManager.removeViewImmediate(mPopupView);\r\n        } finally {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "test.priority.parallel.EfficientPriorityParallelizationTest.verifyThatMethodLevelEventsRunInDifferentThreadsFromSuiteAndTestLevelEvents",
	"Comment": "verifies that the test method listener and execution events for a given test method all run in the same thread.",
	"Method": "void verifyThatMethodLevelEventsRunInDifferentThreadsFromSuiteAndTestLevelEvents(){\r\n    verifyEventThreadsSpawnedAfter(getAllSuiteListenerStartEventLogs().get(0).getThreadId(), testMethodLevelEventLogs, \"All the thread IDs for the test method level events should be greater than the thread ID for the \" + \"suite and test level events. The expectation is that since the suite and test level events \" + \"are running sequentially, and all the test methods are running in parallel, new threads \" + \"will be spawned after the thread executing the suite and test level events when new methods \" + \"begin executing. Suite and test level events thread ID: \" + getAllSuiteListenerStartEventLogs().get(0).getThreadId() + \". Test method level event logs: \" + testMethodLevelEventLogs);\r\n    verifyEventsForTestMethodsRunInTheSameThread(HighPriorityTestSample.class, SUITE_A, SUITE_A_TEST_A);\r\n    verifyEventsForTestMethodsRunInTheSameThread(LowPriorityTestSample.class, SUITE_A, SUITE_A_TEST_B);\r\n}"
}, {
	"Path": "com.marshalchen.common.ui.MaterialProgressWheel.setProgress",
	"Comment": "set the progress to a specific value,the bar will smoothly animate until that value",
	"Method": "void setProgress(float progress){\r\n    if (isSpinning) {\r\n        mProgress = 0.0f;\r\n        isSpinning = false;\r\n    }\r\n    if (progress > 1.0f) {\r\n        progress -= 1.0f;\r\n    } else if (progress < 0) {\r\n        progress = 0;\r\n    }\r\n    if (progress == mTargetProgress) {\r\n        return;\r\n    }\r\n    if (mProgress == mTargetProgress) {\r\n        lastTimeAnimated = SystemClock.uptimeMillis();\r\n    }\r\n    mTargetProgress = Math.min(progress * 360.0f, 360.0f);\r\n    invalidate();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.signaturepad.views.SignaturePad.expandDirtyRect",
	"Comment": "called when replaying history to ensure the dirty region includes allmpoints.",
	"Method": "void expandDirtyRect(float historicalX,float historicalY){\r\n    if (historicalX < mDirtyRect.left) {\r\n        mDirtyRect.left = historicalX;\r\n    } else if (historicalX > mDirtyRect.right) {\r\n        mDirtyRect.right = historicalX;\r\n    }\r\n    if (historicalY < mDirtyRect.top) {\r\n        mDirtyRect.top = historicalY;\r\n    } else if (historicalY > mDirtyRect.bottom) {\r\n        mDirtyRect.bottom = historicalY;\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.dragSortListView.DragSortController.setClickRemoveId",
	"Comment": "set the resource id for the view that represents clickremoval button.",
	"Method": "void setClickRemoveId(int id){\r\n    mClickRemoveId = id;\r\n}"
}, {
	"Path": "com.marshalchen.common.commonUtils.fileUtils.FileUtils.isFileExist",
	"Comment": "indicates if this file represents a file on the underlying file system.",
	"Method": "boolean isFileExist(String filePath){\r\n    if (StringUtils.isBlank(filePath)) {\r\n        return false;\r\n    }\r\n    File file = new File(filePath);\r\n    return (file.exists() && file.isFile());\r\n}"
}, {
	"Path": "com.marshalchen.common.commonUtils.urlUtils.UniversalImageLoader.getDefaultImageLoaderConfiguration",
	"Comment": "the method is to get the default universalimageloader config",
	"Method": "ImageLoaderConfiguration getDefaultImageLoaderConfiguration(Context context,ImageLoaderConfiguration getDefaultImageLoaderConfiguration,Context context,boolean isWriteLog){\r\n    ImageLoaderConfiguration.Builder builder = getDefaultImageLoaderConfigurationBuilder(context);\r\n    if (isWriteLog) {\r\n        builder.writeDebugLogs();\r\n    }\r\n    ImageLoaderConfiguration config = builder.build();\r\n    return config;\r\n}"
}, {
	"Path": "com.marshalchen.common.usefulModule.AbstractSwipeRefreshActivity.disableSwipe",
	"Comment": "disables swipe gesture. it prevents manual gestures but keeps the option tu showrefreshing programatically.",
	"Method": "void disableSwipe(){\r\n    refreshLayout.setEnabled(false);\r\n}"
}, {
	"Path": "org.isoron.uhabits.core.models.ScoreList.getValues",
	"Comment": "returns the values of the scores that fall inside a certain intervalof time.the values are returned in an array containing one integer value for eachday of the interval. the first entry corresponds to the most recent dayin the interval. each subsequent entry corresponds to one day older thanthe previous entry. the boundaries of the time interval are included.",
	"Method": "double[] getValues(Timestamp from,Timestamp to){\r\n    List<Score> scores = getByInterval(from, to);\r\n    double[] values = new double[scores.size()];\r\n    for (int i = 0; i < values.length; i++) values[i] = scores.get(i).getValue();\r\n    return values;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.tileView.layouts.ZoomPanLayout.setScaleFromCenter",
	"Comment": "set the scale of the zoompanlayout while maintaining the current center point",
	"Method": "void setScaleFromCenter(double s){\r\n    int centerOffsetX = (int) (getWidth() * 0.5f);\r\n    int centerOffsetY = (int) (getHeight() * 0.5f);\r\n    Point offset = new Point(centerOffsetX, centerOffsetY);\r\n    Point scroll = new Point(getScrollX(), getScrollY());\r\n    scroll.offset(offset.x, offset.y);\r\n    double deltaScale = s / getScale();\r\n    int x = (int) (scroll.x * deltaScale) - offset.x;\r\n    int y = (int) (scroll.y * deltaScale) - offset.y;\r\n    Point destination = new Point(x, y);\r\n    setScale(s);\r\n    scrollToPoint(destination);\r\n}"
}, {
	"Path": "com.marshalchen.common.commonUtils.urlUtils.HttpUtilsAsync.getAbsoluteUrl",
	"Comment": "to get the true url.if you want to use some relative url,you should override this method.",
	"Method": "String getAbsoluteUrl(String relativeUrl){\r\n    return relativeUrl;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.animation.PropertyValuesHolder.init",
	"Comment": "internal function, called by valueanimator, to set up the typeevaluator that will be usedto calculate animated values.",
	"Method": "void init(){\r\n    if (mEvaluator == null) {\r\n        mEvaluator = (mValueType == Integer.class) ? sIntEvaluator : (mValueType == Float.class) ? sFloatEvaluator : null;\r\n    }\r\n    if (mEvaluator != null) {\r\n        mKeyframeSet.setEvaluator(mEvaluator);\r\n    }\r\n}"
}, {
	"Path": "test.CommandLineTest.testNameOverride",
	"Comment": "test the ability to override the default command line test name",
	"Method": "void testNameOverride(){\r\n    String testName = \"My Test Name\";\r\n    String[] argv = { \"-log\", \"0\", \"-d\", OutputDirectoryPatch.getOutputDirectory(), \"-junit\", \"-testclass\", \"test.sample.JUnitSample1\", \"-testname\", \"\\\"\" + testName + \"\\\"\" };\r\n    TestListenerAdapter tla = new TestListenerAdapter();\r\n    TestNG.privateMain(argv, tla);\r\n    List<ITestContext> contexts = tla.getTestContexts();\r\n    assertTrue(contexts.size() > 0);\r\n    for (ITestContext context : contexts) {\r\n        assertEquals(context.getName(), testName);\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.gesturedetectors.ShoveGestureDetector.getShovePixelsDelta",
	"Comment": "return the distance in pixels from the previous shove event to the currentevent.",
	"Method": "float getShovePixelsDelta(){\r\n    return mCurrAverageY - mPrevAverageY;\r\n}"
}, {
	"Path": "org.testng.log4testng.Logger.testDebugOff",
	"Comment": "makes sure the debug value can be turned off and logs nothing.",
	"Method": "void testDebugOff(){\r\n    Properties props = new Properties();\r\n    ByteArrayOutputStream out1 = new ByteArrayOutputStream();\r\n    ByteArrayOutputStream err1 = new ByteArrayOutputStream();\r\n    PrintStream out2 = new PrintStream(out1);\r\n    PrintStream err2 = new PrintStream(err1);\r\n    props.put(\"log4testng.debug\", \"false\");\r\n    props.put(\"log4testng.rootLogger\", \"WARN\");\r\n    testInitialize(props, out2, err2);\r\n    Assert.assertEquals(out1.toString(), \"\");\r\n    Assert.assertEquals(err1.toString(), \"\");\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase5Scenario1.verifyThatMethodLevelEventsRunInDifferentThreadsFromSuiteAndTestLevelEvents",
	"Comment": "verifies that the method level events all run in different threads from the test and suite level events.",
	"Method": "void verifyThatMethodLevelEventsRunInDifferentThreadsFromSuiteAndTestLevelEvents(){\r\n    verifyEventThreadsSpawnedAfter(testListenerOnStartThreadId, testMethodLevelEventLogs, \"All the thread IDs \" + \"for the test method level events should be greater than the thread ID for the suite and test level \" + \"events. The expectation is that since the suite and test level events are running sequentially, and \" + \"all the test methods are running in parallel, new threads will be spawned after the thread \" + \"executing the suite and test level events when new methods begin executing. Suite and test level \" + \"events thread ID: \" + testListenerOnStartThreadId + \". Test method level event logs: \" + testMethodLevelEventLogs);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.cropperimage.util.PaintUtil.newGuidelinePaint",
	"Comment": "creates the paint object for drawing the crop window guidelines.",
	"Method": "Paint newGuidelinePaint(){\r\n    final Paint paint = new Paint();\r\n    paint.setColor(Color.parseColor(SEMI_TRANSPARENT));\r\n    paint.setStrokeWidth(DEFAULT_GUIDELINE_THICKNESS_PX);\r\n    return paint;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.dragSortListView.DragSortController.setDragHandleId",
	"Comment": "set the resource id for the view that represents the draghandle in a list item.",
	"Method": "void setDragHandleId(int id){\r\n    mDragHandleId = id;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.slider.Indicators.PagerIndicator.setDefaultIndicatorColor",
	"Comment": "if you are using the default indicator , this method will help you to set the selected status andthe unselected status color.",
	"Method": "void setDefaultIndicatorColor(int selectedColor,int unselectedColor){\r\n    if (mUserSetSelectedIndicatorResId == 0) {\r\n        mSelectedGradientDrawable.setColor(selectedColor);\r\n    }\r\n    if (mUserSetUnSelectedIndicatorResId == 0) {\r\n        mUnSelectedGradientDrawable.setColor(unselectedColor);\r\n    }\r\n    resetDrawable();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.freeflow.core.FreeFlowContainer.resetAllCallbacks",
	"Comment": "resets all runnables that are checking on various statuses",
	"Method": "void resetAllCallbacks(){\r\n    if (mPendingCheckForTap != null) {\r\n        removeCallbacks(mPendingCheckForTap);\r\n        mPendingCheckForTap = null;\r\n    }\r\n    if (mPendingCheckForLongPress != null) {\r\n        removeCallbacks(mPendingCheckForLongPress);\r\n        mPendingCheckForLongPress = null;\r\n    }\r\n    if (mTouchModeReset != null) {\r\n        removeCallbacks(mTouchModeReset);\r\n        mTouchModeReset = null;\r\n    }\r\n    if (mPerformClick != null) {\r\n        removeCallbacks(mPerformClick);\r\n        mPerformClick = null;\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.rebound.Spring.setEndValue",
	"Comment": "set the rest value to determine the displacement for the spring",
	"Method": "Spring setEndValue(double endValue){\r\n    if (mEndValue == endValue && isAtRest()) {\r\n        return this;\r\n    }\r\n    mStartValue = getCurrentValue();\r\n    mEndValue = endValue;\r\n    mSpringSystem.activateSpring(this.getId());\r\n    for (SpringListener listener : mListeners) {\r\n        listener.onSpringEndStateChange(this);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.tileView.tileview.TileView.suppressRender",
	"Comment": "tell the tile renderer to not start any more tasks, but it can continue with any that are already running",
	"Method": "void suppressRender(){\r\n    tileManager.suppressRender();\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase7Scenario1.verifyThatTestMethodsRunInParallelThreads",
	"Comment": "verifies that the test methods execute in different threads in parallel fashion.",
	"Method": "void verifyThatTestMethodsRunInParallelThreads(){\r\n    verifySimultaneousTestMethods(getTestMethodLevelEventLogsForTest(SUITE, TEST), TEST, 15);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.staggeredgridview.StaggeredGridView.getRowPaddingLeft",
	"Comment": "grid padding is applied to the list item rows but not the header and footer",
	"Method": "int getRowPaddingLeft(){\r\n    return getListPaddingLeft() + mGridPaddingLeft;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.tileView.layouts.ZoomPanLayout.setDragStartThreshold",
	"Comment": "returns the minimum distance required to start a drag operation, in pixels.",
	"Method": "void setDragStartThreshold(int threshold){\r\n    dragStartThreshold = threshold;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.dragSortListView.DragSortListView.setDragScrollStart",
	"Comment": "set the width of each drag scroll region by specifyinga fraction of the listview height.",
	"Method": "void setDragScrollStart(float heightFraction){\r\n    setDragScrollStarts(heightFraction, heightFraction);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.circularfloatingactionmenu.FloatingActionButton.setContentView",
	"Comment": "sets a content view that will be displayed inside this floatingactionbutton.",
	"Method": "void setContentView(View contentView,FrameLayout.LayoutParams contentParams,Builder setContentView,View contentView,Builder setContentView,View contentView,LayoutParams contentParams){\r\n    this.contentView = contentView;\r\n    FrameLayout.LayoutParams params;\r\n    if (contentParams == null) {\r\n        params = new FrameLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT, Gravity.CENTER);\r\n        final int margin = getResources().getDimensionPixelSize(R.dimen.action_button_content_margin);\r\n        params.setMargins(margin, margin, margin, margin);\r\n    } else {\r\n        params = contentParams;\r\n    }\r\n    params.gravity = Gravity.CENTER;\r\n    contentView.setClickable(false);\r\n    this.addView(contentView, params);\r\n}"
}, {
	"Path": "org.testng.reporters.JUnitReportReporter.putElement",
	"Comment": "put a xml start or empty tag to the xmlstringbuffer depending on haschildelements parameter",
	"Method": "boolean putElement(XMLStringBuffer xsb,String tagName,Properties attributes,boolean hasChildElements){\r\n    if (hasChildElements) {\r\n        xsb.push(tagName, attributes);\r\n    } else {\r\n        xsb.addEmptyElement(tagName, attributes);\r\n    }\r\n    return hasChildElements;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.animation.ValueAnimator.getCurrentPlayTime",
	"Comment": "gets the current position of the animation in time, which is equal to the currenttime minus the time that the animation started. an animation that is not yet started willreturn a value of zero.",
	"Method": "long getCurrentPlayTime(){\r\n    if (!mInitialized || mPlayingState == STOPPED) {\r\n        return 0;\r\n    }\r\n    return AnimationUtils.currentAnimationTimeMillis() - mStartTime;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.rebound.Spring.getStartValue",
	"Comment": "get the displacement value from the last time setcurrentvalue was called.",
	"Method": "double getStartValue(){\r\n    return mStartValue;\r\n}"
}, {
	"Path": "test.conffailure.ClassWithFailedBeforeTestClassVerification.tearDown",
	"Comment": "should be run even though classwithfailedbeforetestclassfailed in its configuration",
	"Method": "void tearDown(){\r\n    m_success2 = true;\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.recyclerplayground.layout.FixedGridLayoutManager.scrollHorizontallyBy",
	"Comment": "this method describes how far recyclerview thinks the contents should scroll horizontally.you are responsible for verifying edge boundaries, and determining if this scrollevent somehow requires that new views be added or old views get recycled.",
	"Method": "int scrollHorizontallyBy(int dx,RecyclerView.Recycler recycler,RecyclerView.State state){\r\n    if (getChildCount() == 0) {\r\n        return 0;\r\n    }\r\n    final View topView = getChildAt(0);\r\n    final View bottomView = getChildAt(mVisibleColumnCount - 1);\r\n    int viewSpan = getDecoratedRight(bottomView) - getDecoratedLeft(topView);\r\n    if (viewSpan <= getHorizontalSpace()) {\r\n        return 0;\r\n    }\r\n    int delta;\r\n    boolean leftBoundReached = getFirstVisibleColumn() == 0;\r\n    boolean rightBoundReached = getLastVisibleColumn() >= getTotalColumnCount();\r\n    if (dx > 0) {\r\n        if (rightBoundReached) {\r\n            int rightOffset = getHorizontalSpace() - getDecoratedRight(bottomView) + getPaddingRight();\r\n            delta = Math.max(-dx, rightOffset);\r\n        } else {\r\n            delta = -dx;\r\n        }\r\n    } else {\r\n        if (leftBoundReached) {\r\n            int leftOffset = -getDecoratedLeft(topView) + getPaddingLeft();\r\n            delta = Math.min(-dx, leftOffset);\r\n        } else {\r\n            delta = -dx;\r\n        }\r\n    }\r\n    offsetChildrenHorizontal(delta);\r\n    if (dx > 0) {\r\n        if (getDecoratedRight(topView) < 0 && !rightBoundReached) {\r\n            fillGrid(DIRECTION_END, recycler);\r\n        } else if (!rightBoundReached) {\r\n            fillGrid(DIRECTION_NONE, recycler);\r\n        }\r\n    } else {\r\n        if (getDecoratedLeft(topView) > 0 && !leftBoundReached) {\r\n            fillGrid(DIRECTION_START, recycler);\r\n        } else if (!leftBoundReached) {\r\n            fillGrid(DIRECTION_NONE, recycler);\r\n        }\r\n    }\r\n    return -delta;\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase5Scenario1.verifyThatTestMethodsRunInParallelThreads",
	"Comment": "verifies that the test methods execute in different threads in parallel fashion.",
	"Method": "void verifyThatTestMethodsRunInParallelThreads(){\r\n    verifySimultaneousTestMethods(testMethodLevelEventLogs, TEST, 10);\r\n}"
}, {
	"Path": "com.marshalchen.ua.common.commonUtils.fileUtils.PreferencesUtils.getString",
	"Comment": "get string from custom preferences with custom default value",
	"Method": "String getString(Context context,String key,String getString,Context context,String preferenceName,String key,String getString,Context context,String preferenceName,String key,String defaultValue){\r\n    SharedPreferences sharedPreferences = context.getSharedPreferences(preferenceName, Context.MODE_PRIVATE);\r\n    return sharedPreferences.getString(key, defaultValue);\r\n}"
}, {
	"Path": "org.isoron.androidbase.activities.BaseScreen.setMenu",
	"Comment": "sets the menu to be shown by this screen.this menu will be visible if when there is no active selection operation.if the provided menu is null, then no menu will be shown.",
	"Method": "void setMenu(BaseMenu menu){\r\n    activity.setBaseMenu(menu);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.swipeback.ViewDragHelper.setMaxVelocity",
	"Comment": "set the max velocity that will be detected as having a magnitudegreater than zero in pixels per second. callback methods accepting avelocity will be clamped appropriately.",
	"Method": "void setMaxVelocity(float maxVel){\r\n    mMaxVelocity = maxVel;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.swipeback.ViewDragHelper.setEdgeSize",
	"Comment": "set the size of an edge. this is the range in pixels along the edges ofthis view that will actively detect edge touches or drags if edgetracking is enabled.",
	"Method": "void setEdgeSize(int size){\r\n    mEdgeSize = size;\r\n}"
}, {
	"Path": "org.isoron.uhabits.core.models.CheckmarkList.getAllValues",
	"Comment": "returns the values for all the checkmarks, since the oldest repetition ofthe habit until today.if there are no repetitions at all, returns an empty array. the valuesare returned in an array containing one integer value for each day sincethe first repetition of the habit until today. the first entrycorresponds to today, the second entry corresponds to yesterday, and soon.",
	"Method": "int[] getAllValues(){\r\n    Repetition oldestRep = habit.getRepetitions().getOldest();\r\n    if (oldestRep == null)\r\n        return new int[0];\r\n    Timestamp fromTimestamp = oldestRep.getTimestamp();\r\n    Timestamp toTimestamp = DateUtils.getToday();\r\n    return getValues(fromTimestamp, toTimestamp);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.square_progressbar.SquareProgressBar.isClearOnHundred",
	"Comment": "if the progressbar disappears when the progress reaches 100%.",
	"Method": "boolean isClearOnHundred(){\r\n    return bar.isClearOnHundred();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.imageprocessing.input.VideoResourceInput.startWhenReady",
	"Comment": "starts the video player if the opengl context has initialized the video already.otherwise,\tstarts the video once the opengl context has been initialized.",
	"Method": "void startWhenReady(){\r\n    if (ready) {\r\n        player.start();\r\n    } else {\r\n        startWhenReady = true;\r\n    }\r\n}"
}, {
	"Path": "org.testng.TestNGAntTask.executeHaltTarget",
	"Comment": "executes the target, if any, that user designates executing before failing the test",
	"Method": "void executeHaltTarget(int exitValue){\r\n    if (m_onHaltTarget != null) {\r\n        if (m_outputDir != null) {\r\n            getProject().setProperty(\"testng.outputdir\", m_outputDir.getAbsolutePath());\r\n        }\r\n        getProject().setProperty(\"testng.returncode\", String.valueOf(exitValue));\r\n        Target t = getProject().getTargets().get(m_onHaltTarget);\r\n        if (t != null) {\r\n            t.execute();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.ui.ShimmerFrameLayout.getRepeatDelay",
	"Comment": "get the delay after which the current animation will repeat. the default value is 0, which means the animationwill repeat immediately, unless it has ended.",
	"Method": "int getRepeatDelay(){\r\n    return mRepeatDelay;\r\n}"
}, {
	"Path": "com.marshalchen.common.ui.ShimmerFrameLayout.setRepeatDelay",
	"Comment": "set the delay after which the animation repeat, unless it has ended.",
	"Method": "void setRepeatDelay(int repeatDelay){\r\n    mRepeatDelay = repeatDelay;\r\n    resetAll();\r\n}"
}, {
	"Path": "com.marshalchen.common.ui.ShimmerFrameLayout.getTilt",
	"Comment": "get the tilt angle of the highlight, in degrees. the default value is 20.",
	"Method": "float getTilt(){\r\n    return mMask.tilt;\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase7Scenario2.verifyThatMethodLevelEventsRunInDifferentThreadsFromSuiteAndTestLevelEvents",
	"Comment": "verifies that the test method listener and execution events for a given test method all run in the same thread.",
	"Method": "void verifyThatMethodLevelEventsRunInDifferentThreadsFromSuiteAndTestLevelEvents(){\r\n    verifyEventThreadsSpawnedAfter(getAllSuiteListenerStartEventLogs().get(0).getThreadId(), testMethodLevelEventLogs, \"All the thread IDs for the test method level events should be greater than the thread ID for the \" + \"suite and test level events. The expectation is that since the suite and test level events \" + \"are running sequentially, and all the test methods are running in parallel, new threads \" + \"will be spawned after the thread executing the suite and test level events when new methods \" + \"begin executing. Suite and test level events thread ID: \" + getAllSuiteListenerStartEventLogs().get(0).getThreadId() + \". Test method level event logs: \" + testMethodLevelEventLogs);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassAFiveMethodsWithFactoryUsingDataProviderAndNoDepsSample.class, SUITE_A, SUITE_A_TEST_A);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassCSixMethodsWithFactoryUsingDataProviderAndNoDepsSample.class, SUITE_A, SUITE_A_TEST_A);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassEFiveMethodsWithNoDepsSample.class, SUITE_B, SUITE_B_TEST_A);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassDThreeMethodsWithFactoryUsingDataProviderAndNoDepsSample.class, SUITE_B, SUITE_B_TEST_B);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassBFourMethodsWithFactoryUsingDataProviderAndNoDepsSample.class, SUITE_B, SUITE_B_TEST_B);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassFSixMethodsWithFactoryUsingDataProviderAndNoDepsSample.class, SUITE_B, SUITE_B_TEST_B);\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.recyclerplayground.layout.StaticGridLayoutManager.positionOfIndex",
	"Comment": "mapping between child view indices and adapter datapositions helps fill the proper views during scrolling.",
	"Method": "int positionOfIndex(int childIndex){\r\n    int row = childIndex / mVisibleColumnCount;\r\n    int column = childIndex % mVisibleColumnCount;\r\n    return mFirstVisiblePosition + (row * getTotalColumnCount()) + column;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.view.ViewPropertyAnimatorHC.getValue",
	"Comment": "this method gets the value of the named property from the view object.",
	"Method": "float getValue(int propertyConstant){\r\n    View v = mView.get();\r\n    if (v != null) {\r\n        switch(propertyConstant) {\r\n            case TRANSLATION_X:\r\n                return v.getTranslationX();\r\n            case TRANSLATION_Y:\r\n                return v.getTranslationY();\r\n            case ROTATION:\r\n                return v.getRotation();\r\n            case ROTATION_X:\r\n                return v.getRotationX();\r\n            case ROTATION_Y:\r\n                return v.getRotationY();\r\n            case SCALE_X:\r\n                return v.getScaleX();\r\n            case SCALE_Y:\r\n                return v.getScaleY();\r\n            case X:\r\n                return v.getX();\r\n            case Y:\r\n                return v.getY();\r\n            case ALPHA:\r\n                return v.getAlpha();\r\n        }\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase1Scenario1.verifyThatAllEventsForATestMethodExecuteInSameThread",
	"Comment": "verifies that all the test method level events for any given test method run in the same thread.",
	"Method": "void verifyThatAllEventsForATestMethodExecuteInSameThread(){\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassAFiveMethodsWithNoDepsSample.class, SUITE, TEST);\r\n}"
}, {
	"Path": "org.isoron.uhabits.core.models.CheckmarkList.writeCSV",
	"Comment": "writes the entire list of checkmarks to the given writer, in csv format.",
	"Method": "void writeCSV(Writer out){\r\n    int[] values;\r\n    synchronized (this) {\r\n        compute();\r\n        values = getAllValues();\r\n    }\r\n    Timestamp timestamp = DateUtils.getToday();\r\n    SimpleDateFormat dateFormat = DateFormats.getCSVDateFormat();\r\n    for (int value : values) {\r\n        String date = dateFormat.format(timestamp.toJavaDate());\r\n        out.write(String.format(\"%s,%d\\n\", date, value));\r\n        timestamp = timestamp.minus(1);\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.freeflow.core.FreeFlowContainer.logLifecycleEvent",
	"Comment": "a utility method for debugging lifecycle events and putting them in the\tlog messages",
	"Method": "void logLifecycleEvent(String msg){\r\n    Logs.d(\"ContainerLifecycleEvent\", msg);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.listviewanimations.itemmanipulation.AnimateAdditionAdapter.setShouldAnimateDown",
	"Comment": "set whether the list should animate downwards when items are added above the first visible item.",
	"Method": "void setShouldAnimateDown(boolean shouldAnimateDown){\r\n    mShouldAnimateDown = shouldAnimateDown;\r\n}"
}, {
	"Path": "com.marshalchen.common.ui.CircularImageView.setShadow",
	"Comment": "enables a dark shadow for this circularimageview.\tif the radius is set to 0, the shadow is removed.",
	"Method": "void setShadow(float radius,float dx,float dy,int color){\r\n    shadowRadius = radius;\r\n    shadowDx = dx;\r\n    shadowDy = dy;\r\n    shadowColor = color;\r\n    updateShadow();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.tileView.widgets.Scroller.timePassed",
	"Comment": "returns the time elapsed since the beginning of the scrolling.",
	"Method": "int timePassed(){\r\n    return (int) (AnimationUtils.currentAnimationTimeMillis() - mStartTime);\r\n}"
}, {
	"Path": "com.marshalchen.common.ui.CircularImageView.setSelectorStrokeColor",
	"Comment": "sets the stroke color to be drawn around the circularimageview\tduring click events when the selector is enabled.",
	"Method": "void setSelectorStrokeColor(int selectorStrokeColor){\r\n    if (paintSelectorBorder != null)\r\n        paintSelectorBorder.setColor(selectorStrokeColor);\r\n    this.invalidate();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.cropperimage.CropImageView.getOnMeasureSpec",
	"Comment": "determines the specs for the onmeasure function. calculates the width or heightdepending on the mode.",
	"Method": "int getOnMeasureSpec(int measureSpecMode,int measureSpecSize,int desiredSize){\r\n    int spec;\r\n    if (measureSpecMode == MeasureSpec.EXACTLY) {\r\n        spec = measureSpecSize;\r\n    } else if (measureSpecMode == MeasureSpec.AT_MOST) {\r\n        spec = Math.min(desiredSize, measureSpecSize);\r\n    } else {\r\n        spec = desiredSize;\r\n    }\r\n    return spec;\r\n}"
}, {
	"Path": "org.testng.internal.MethodHelper.findDependedUponMethods",
	"Comment": "finds testng methods that the specified testng method depends upon",
	"Method": "ITestNGMethod[] findDependedUponMethods(ITestNGMethod m,List<ITestNGMethod> methods,ITestNGMethod[] findDependedUponMethods,ITestNGMethod m,ITestNGMethod[] methods){\r\n    String canonicalMethodName = calculateMethodCanonicalName(m);\r\n    List<ITestNGMethod> vResult = Lists.newArrayList();\r\n    String regexp = null;\r\n    for (String fullyQualifiedRegexp : m.getMethodsDependedUpon()) {\r\n        boolean foundAtLeastAMethod = false;\r\n        if (null != fullyQualifiedRegexp) {\r\n            regexp = fullyQualifiedRegexp.replace(\"$\", \"\\\\$\");\r\n            MatchResults results = matchMethod(methods, regexp);\r\n            foundAtLeastAMethod = results.foundAtLeastAMethod;\r\n            vResult.addAll(results.matchedMethods);\r\n            if (!foundAtLeastAMethod) {\r\n                int lastIndex = regexp.lastIndexOf('.');\r\n                String newMethodName;\r\n                if (lastIndex != -1) {\r\n                    newMethodName = m.getTestClass().getRealClass().getName() + regexp.substring(lastIndex);\r\n                    results = matchMethod(methods, newMethodName);\r\n                    foundAtLeastAMethod = results.foundAtLeastAMethod;\r\n                    vResult.addAll(results.matchedMethods);\r\n                }\r\n            }\r\n        }\r\n        if (!foundAtLeastAMethod) {\r\n            if (m.ignoreMissingDependencies()) {\r\n                continue;\r\n            }\r\n            if (m.isAlwaysRun()) {\r\n                continue;\r\n            }\r\n            Method maybeReferringTo = findMethodByName(m, regexp);\r\n            if (maybeReferringTo != null) {\r\n                throw new TestNGException(canonicalMethodName + \"() is depending on method \" + maybeReferringTo + \", which is not annotated with @Test or not included.\");\r\n            }\r\n            throw new TestNGException(canonicalMethodName + \"() depends on nonexistent method \" + regexp);\r\n        }\r\n    }\r\n    return vResult.toArray(new ITestNGMethod[0]);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.animation.Animator.removeListener",
	"Comment": "removes a listener from the set listening to this animation.",
	"Method": "void removeListener(AnimatorListener listener){\r\n    if (mListeners == null) {\r\n        return;\r\n    }\r\n    mListeners.remove(listener);\r\n    if (mListeners.size() == 0) {\r\n        mListeners = null;\r\n    }\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase3Scenario2.verifyOnlyOneInstanceOfTestClassForAllTestMethodsForAllSuites",
	"Comment": "verify that the same test class instance is associated with each of the test methods from the sample test class",
	"Method": "void verifyOnlyOneInstanceOfTestClassForAllTestMethodsForAllSuites(){\r\n    verifyNumberOfInstancesOfTestClassesForMethods(SUITE_A, SUITE_A_TEST_A, Arrays.asList(TestClassAFiveMethodsWithDataProviderOnSomeMethodsAndNoDepsSample.class, TestClassBSixMethodsWithDataProviderOnSomeMethodsAndNoDepsSample.class), 1);\r\n    verifySameInstancesOfTestClassesAssociatedWithMethods(SUITE_A, SUITE_A_TEST_A, Arrays.asList(TestClassAFiveMethodsWithDataProviderOnSomeMethodsAndNoDepsSample.class, TestClassBSixMethodsWithDataProviderOnSomeMethodsAndNoDepsSample.class));\r\n    verifyNumberOfInstancesOfTestClassForMethods(SUITE_B, SUITE_B_TEST_A, TestClassCFiveMethodsWithDataProviderOnSomeMethodsAndNoDepsSample.class, 1);\r\n    verifySameInstancesOfTestClassAssociatedWithMethods(SUITE_B, SUITE_B_TEST_A, TestClassCFiveMethodsWithDataProviderOnSomeMethodsAndNoDepsSample.class);\r\n    verifyNumberOfInstancesOfTestClassesForMethods(SUITE_B, SUITE_B_TEST_B, Arrays.asList(TestClassDThreeMethodsWithDataProviderOnSomeMethodsAndNoDepsSample.class, TestClassEFourMethodsWithDataProviderOnSomeMethodsAndNoDepsSample.class, TestClassFSixMethodsWithDataProviderOnSomeMethodsAndNoDepsSample.class), 1);\r\n    verifySameInstancesOfTestClassesAssociatedWithMethods(SUITE_B, SUITE_B_TEST_B, Arrays.asList(TestClassDThreeMethodsWithDataProviderOnSomeMethodsAndNoDepsSample.class, TestClassEFourMethodsWithDataProviderOnSomeMethodsAndNoDepsSample.class, TestClassFSixMethodsWithDataProviderOnSomeMethodsAndNoDepsSample.class));\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.tasks.io.URLImageSource.getSource",
	"Comment": "returns the url from which the source image is retrieved from.",
	"Method": "URL getSource(){\r\n    return url;\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase7Scenario2.verifyNumberOfInstanceOfTestClassForAllTestMethodsForAllSuites",
	"Comment": "verify that the same test class instances are associated with each of the test methods from the sample test class",
	"Method": "void verifyNumberOfInstanceOfTestClassForAllTestMethodsForAllSuites(){\r\n    verifyNumberOfInstancesOfTestClassesForMethods(SUITE_A, SUITE_A_TEST_A, Arrays.asList(TestClassAFiveMethodsWithFactoryUsingDataProviderAndNoDepsSample.class, TestClassCSixMethodsWithFactoryUsingDataProviderAndNoDepsSample.class), 3, 4);\r\n    verifySameInstancesOfTestClassesAssociatedWithMethods(SUITE_A, SUITE_A_TEST_A, Arrays.asList(TestClassAFiveMethodsWithFactoryUsingDataProviderAndNoDepsSample.class, TestClassCSixMethodsWithFactoryUsingDataProviderAndNoDepsSample.class));\r\n    verifyNumberOfInstancesOfTestClassForMethods(SUITE_B, SUITE_B_TEST_A, TestClassEFiveMethodsWithNoDepsSample.class, 1);\r\n    verifySameInstancesOfTestClassAssociatedWithMethods(SUITE_B, SUITE_B_TEST_A, TestClassEFiveMethodsWithNoDepsSample.class);\r\n    verifyNumberOfInstancesOfTestClassesForMethods(SUITE_B, SUITE_B_TEST_B, Arrays.asList(TestClassDThreeMethodsWithFactoryUsingDataProviderAndNoDepsSample.class, TestClassBFourMethodsWithFactoryUsingDataProviderAndNoDepsSample.class, TestClassFSixMethodsWithFactoryUsingDataProviderAndNoDepsSample.class), 3, 4, 5);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.cropimage.CropImageView.ensureVisible",
	"Comment": "pan the displayed image to make sure the cropping rectangle is visible.",
	"Method": "void ensureVisible(HighlightView hv){\r\n    Rect r = hv.drawRect;\r\n    int panDeltaX1 = Math.max(0, getLeft() - r.left);\r\n    int panDeltaX2 = Math.min(0, getRight() - r.right);\r\n    int panDeltaY1 = Math.max(0, getTop() - r.top);\r\n    int panDeltaY2 = Math.min(0, getBottom() - r.bottom);\r\n    int panDeltaX = panDeltaX1 != 0 ? panDeltaX1 : panDeltaX2;\r\n    int panDeltaY = panDeltaY1 != 0 ? panDeltaY1 : panDeltaY2;\r\n    if (panDeltaX != 0 || panDeltaY != 0) {\r\n        panBy(panDeltaX, panDeltaY);\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.ResideMenu.ResideMenu.setMenuListener",
	"Comment": "if you need to do something on the action of closing or openingmenu, set the listener here.",
	"Method": "void setMenuListener(OnMenuListener menuListener){\r\n    this.menuListener = menuListener;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.rippleDrawable.Ripple.getBounds",
	"Comment": "returns the maximum bounds of the ripple relative to the ripple center.",
	"Method": "void getBounds(Rect bounds){\r\n    final int outerX = (int) mOuterX;\r\n    final int outerY = (int) mOuterY;\r\n    final int r = (int) mOuterRadius + 1;\r\n    bounds.set(outerX - r, outerY - r, outerX + r, outerY + r);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.animation.KeyframeSet.setEvaluator",
	"Comment": "sets the typeevaluator to be used when calculating animated values. this objectis required only for keyframesets that are not either intkeyframeset or floatkeyframeset,both of which assume their own evaluator to speed up calculations with those primitivetypes.",
	"Method": "void setEvaluator(TypeEvaluator evaluator){\r\n    mEvaluator = evaluator;\r\n}"
}, {
	"Path": "com.marshalchen.common.ui.ShimmerFrameLayout.getRepeatMode",
	"Comment": "get what the current animation will do after reaching the end. one ofreverse orrestart",
	"Method": "int getRepeatMode(){\r\n    return mRepeatMode;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.modifysys.ViewPager.onRequestFocusInDescendants",
	"Comment": "we only want the current page that is being shown to be focusable.",
	"Method": "boolean onRequestFocusInDescendants(int direction,Rect previouslyFocusedRect){\r\n    int index;\r\n    int increment;\r\n    int end;\r\n    int count = getChildCount();\r\n    if ((direction & FOCUS_FORWARD) != 0) {\r\n        index = 0;\r\n        increment = 1;\r\n        end = count;\r\n    } else {\r\n        index = count - 1;\r\n        increment = -1;\r\n        end = -1;\r\n    }\r\n    for (int i = index; i != end; i += increment) {\r\n        View child = getChildAt(i);\r\n        if (child.getVisibility() == VISIBLE) {\r\n            ItemInfo ii = infoForChild(child);\r\n            if (ii != null && ii.position == mCurItem) {\r\n                if (child.requestFocus(direction, previouslyFocusedRect)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.isoron.uhabits.core.database.Repository.remove",
	"Comment": "removes the given record from the repository.the id of the given record is also set to null.",
	"Method": "void remove(T record){\r\n    try {\r\n        Long id = (Long) getIdField().get(record);\r\n        if (id == null)\r\n            return;\r\n        db.delete(getTableName(), getIdName() + \"=?\", id.toString());\r\n        getIdField().set(record, null);\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.swipeback.ViewDragHelper.getMinVelocity",
	"Comment": "return the currently configured minimum velocity. any flings with amagnitude less than this value in pixels per second. callback methodsaccepting a velocity will receive zero as a velocity value if the realdetected velocity was below this threshold.",
	"Method": "float getMinVelocity(){\r\n    return mMinVelocity;\r\n}"
}, {
	"Path": "com.android.datetimepicker.time.AmPmCirclesView.getIsTouchingAmOrPm",
	"Comment": "calculate whether the coordinates are touching the am or pm circle.",
	"Method": "int getIsTouchingAmOrPm(float xCoord,float yCoord){\r\n    if (!mDrawValuesReady) {\r\n        return -1;\r\n    }\r\n    int squaredYDistance = (int) ((yCoord - mAmPmYCenter) * (yCoord - mAmPmYCenter));\r\n    int distanceToAmCenter = (int) Math.sqrt((xCoord - mAmXCenter) * (xCoord - mAmXCenter) + squaredYDistance);\r\n    if (distanceToAmCenter <= mAmPmCircleRadius) {\r\n        return AM;\r\n    }\r\n    int distanceToPmCenter = (int) Math.sqrt((xCoord - mPmXCenter) * (xCoord - mPmXCenter) + squaredYDistance);\r\n    if (distanceToPmCenter <= mAmPmCircleRadius) {\r\n        return PM;\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "com.marshalchen.common.ui.HoloCircularProgressBar.updateProgressColor",
	"Comment": "updates the paint of the progress and the thumb to give them a new visual\tstyle",
	"Method": "void updateProgressColor(){\r\n    mProgressColorPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\r\n    mProgressColorPaint.setColor(mProgressColor);\r\n    mProgressColorPaint.setStyle(Paint.Style.STROKE);\r\n    mProgressColorPaint.setStrokeWidth(mCircleStrokeWidth);\r\n    mThumbColorPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\r\n    mThumbColorPaint.setColor(mProgressColor);\r\n    mThumbColorPaint.setStyle(Paint.Style.FILL_AND_STROKE);\r\n    mThumbColorPaint.setStrokeWidth(mCircleStrokeWidth);\r\n    invalidate();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.listviewanimations.itemmanipulation.InsertQueue.removeActiveIndex",
	"Comment": "clear the active state for given index. will insert any pending pairs if this call leads to a state where there are no active pairs.",
	"Method": "void removeActiveIndex(int index){\r\n    boolean found = false;\r\n    for (Iterator<AtomicInteger> iterator = mActiveIndexes.iterator(); iterator.hasNext() && !found; ) {\r\n        if (iterator.next().get() == index) {\r\n            iterator.remove();\r\n            found = true;\r\n        }\r\n    }\r\n    if (mActiveIndexes.isEmpty()) {\r\n        insertPending();\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.swipeback.SwipeBackLayout.addSwipeListener",
	"Comment": "add a callback to be invoked when a swipe event is sent to this view.",
	"Method": "void addSwipeListener(SwipeListener listener){\r\n    if (mListeners == null) {\r\n        mListeners = new ArrayList<SwipeListener>();\r\n    }\r\n    mListeners.add(listener);\r\n}"
}, {
	"Path": "org.testng.reporters.EmailableReporter.getMethodSet",
	"Comment": "since the methods will be sorted chronologically, we want to return the itestngmethod from theinvoked methods.",
	"Method": "Collection<ITestNGMethod> getMethodSet(IResultMap tests,ISuite suite){\r\n    List<IInvokedMethod> r = Lists.newArrayList();\r\n    List<IInvokedMethod> invokedMethods = suite.getAllInvokedMethods();\r\n    for (IInvokedMethod im : invokedMethods) {\r\n        if (tests.getAllMethods().contains(im.getTestMethod())) {\r\n            r.add(im);\r\n        }\r\n    }\r\n    Arrays.sort(r.toArray(new IInvokedMethod[r.size()]), new TestSorter());\r\n    List<ITestNGMethod> result = Lists.newArrayList();\r\n    for (IInvokedMethod m : r) {\r\n        result.add(m.getTestMethod());\r\n    }\r\n    for (ITestNGMethod m : tests.getAllMethods()) {\r\n        if (!result.contains(m)) {\r\n            result.add(m);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.testng.internal.TestNGMethod.setThreadPoolSize",
	"Comment": "sets the number of threads on which this method should be invoked.",
	"Method": "void setThreadPoolSize(int threadPoolSize){\r\n    m_threadPoolSize = threadPoolSize;\r\n}"
}, {
	"Path": "com.marshalchen.common.usefulModule.AbstractSwipeRefreshLoadMoreActivity.disableSwipe",
	"Comment": "disables swipe gesture. it prevents manual gestures but keeps the option tu showrefreshing programatically.",
	"Method": "void disableSwipe(){\r\n    refreshLayout.setEnabled(false);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.circularfloatingactionmenu.FloatingActionButton.setPosition",
	"Comment": "sets the position of the button by calculating its gravity from the position parameter",
	"Method": "void setPosition(int position,FrameLayout.LayoutParams layoutParams,Builder setPosition,int position){\r\n    int gravity;\r\n    switch(position) {\r\n        case POSITION_TOP_CENTER:\r\n            gravity = Gravity.TOP | Gravity.CENTER_HORIZONTAL;\r\n            break;\r\n        case POSITION_TOP_RIGHT:\r\n            gravity = Gravity.TOP | Gravity.RIGHT;\r\n            break;\r\n        case POSITION_RIGHT_CENTER:\r\n            gravity = Gravity.RIGHT | Gravity.CENTER_VERTICAL;\r\n            break;\r\n        case POSITION_BOTTOM_CENTER:\r\n            gravity = Gravity.BOTTOM | Gravity.CENTER_HORIZONTAL;\r\n            break;\r\n        case POSITION_BOTTOM_LEFT:\r\n            gravity = Gravity.BOTTOM | Gravity.LEFT;\r\n            break;\r\n        case POSITION_LEFT_CENTER:\r\n            gravity = Gravity.LEFT | Gravity.CENTER_VERTICAL;\r\n            break;\r\n        case POSITION_TOP_LEFT:\r\n            gravity = Gravity.TOP | Gravity.LEFT;\r\n            break;\r\n        case POSITION_BOTTOM_RIGHT:\r\n        default:\r\n            gravity = Gravity.BOTTOM | Gravity.RIGHT;\r\n            break;\r\n    }\r\n    layoutParams.gravity = gravity;\r\n    setLayoutParams(layoutParams);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.customPullRefreshLayout.widget.MaterialProgressDrawable.setColorSchemeColors",
	"Comment": "set the colors used in the progress animation from color resources.the first color will also be the color of the bar that grows in responseto a user swipe gesture.",
	"Method": "void setColorSchemeColors(int colors){\r\n    mRing.setColors(colors);\r\n    mRing.setColorIndex(0);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.animation.PropertyValuesHolder.setupEndValue",
	"Comment": "this function is called by objectanimator when setting the end values for an animation.the end values are set according to the current values in the target object. theproperty whose value is extracted is whatever is specified by the propertyname of thispropertyvaluesholder object.",
	"Method": "void setupEndValue(Object target){\r\n    setupValue(target, mKeyframeSet.mKeyframes.get(mKeyframeSet.mKeyframes.size() - 1));\r\n}"
}, {
	"Path": "com.marshalchen.ua.common.usefulModule.CircularImageView.setSelectorStrokeColor",
	"Comment": "sets the stroke color to be drawn around the circularimageview\tduring click events when the selector is enabled.",
	"Method": "void setSelectorStrokeColor(int selectorStrokeColor){\r\n    if (paintSelectorBorder != null)\r\n        paintSelectorBorder.setColor(selectorStrokeColor);\r\n    this.invalidate();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.swipeback.ViewDragHelper.canScroll",
	"Comment": "tests scrollability within child views of v given a delta of dx.",
	"Method": "boolean canScroll(View v,boolean checkV,int dx,int dy,int x,int y){\r\n    if (v instanceof ViewGroup) {\r\n        final ViewGroup group = (ViewGroup) v;\r\n        final int scrollX = v.getScrollX();\r\n        final int scrollY = v.getScrollY();\r\n        final int count = group.getChildCount();\r\n        for (int i = count - 1; i >= 0; i--) {\r\n            final View child = group.getChildAt(i);\r\n            if (x + scrollX >= child.getLeft() && x + scrollX < child.getRight() && y + scrollY >= child.getTop() && y + scrollY < child.getBottom() && canScroll(child, true, dx, dy, x + scrollX - child.getLeft(), y + scrollY - child.getTop())) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return checkV && (ViewCompat.canScrollHorizontally(v, -dx) || ViewCompat.canScrollVertically(v, -dy));\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.foldingLayout.BaseFoldingLayout.setFoldFactor",
	"Comment": "sets the fold factor of the folding view and updates all thecorresponding matrices and values to account for the new fold factor.once that is complete, it redraws itself with the new fold.",
	"Method": "void setFoldFactor(float foldFactor){\r\n    if (foldFactor != mFoldFactor) {\r\n        mFoldFactor = foldFactor;\r\n        calculateMatrices();\r\n        invalidate();\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.dragSortListview.DSLVFragment.buildController",
	"Comment": "called in oncreateview. override this to provide a customdragsortcontroller.",
	"Method": "DragSortController buildController(DragSortListView dslv){\r\n    DragSortController controller = new DragSortController(dslv);\r\n    controller.setDragHandleId(R.id.drag_handle);\r\n    controller.setClickRemoveId(R.id.click_remove);\r\n    controller.setRemoveEnabled(removeEnabled);\r\n    controller.setSortEnabled(sortEnabled);\r\n    controller.setDragInitMode(dragStartMode);\r\n    controller.setRemoveMode(removeMode);\r\n    return controller;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.cropperimage.util.HandleUtil.isInHorizontalTargetZone",
	"Comment": "determines if the specified coordinate is in the target touch zone for ahorizontal bar handle.",
	"Method": "boolean isInHorizontalTargetZone(float x,float y,float handleXStart,float handleXEnd,float handleY,float targetRadius){\r\n    if (x > handleXStart && x < handleXEnd && Math.abs(y - handleY) <= targetRadius) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.simplemodule.FilckerAnimationListView.animatePostLayout",
	"Comment": "animate items that just appeared and items that move within the screen.",
	"Method": "void animatePostLayout(float durationUnit){\r\n    final AnimatorSet animatorSet = new AnimatorSet();\r\n    for (int i = 0; i < getChildCount(); i++) {\r\n        final View child = getChildAt(i);\r\n        final long id = getItemIdAtPosition(getFirstVisiblePosition() + i);\r\n        ObjectAnimator anim = null;\r\n        ViewHelper.setAlpha(child, 1f);\r\n        if (yMap.containsKey(id)) {\r\n            final float oldY = yMap.remove(id);\r\n            final float newY = ViewHelper.getY(child);\r\n            if (oldY != newY) {\r\n                anim = animateY(child, oldY, newY, durationUnit);\r\n            }\r\n        } else {\r\n            if (beforeVisible.contains(id)) {\r\n                final float newY = ViewHelper.getY(child);\r\n                final float oldY = -child.getHeight();\r\n                anim = animateY(child, oldY, newY, durationUnit);\r\n            } else if (afterVisible.contains(id)) {\r\n                final float newY = ViewHelper.getY(child);\r\n                final float oldY = getHeight();\r\n                anim = animateY(child, oldY, newY, durationUnit);\r\n            } else {\r\n                ViewHelper.setAlpha(child, 0f);\r\n                anim = animateAlpha(child, true);\r\n                anim.setStartDelay(MIN_ANIM_DURATION);\r\n            }\r\n        }\r\n        if (anim != null) {\r\n            animatorSet.play(anim);\r\n        }\r\n    }\r\n    animatorSet.addListener(new AnimatorListenerAdapter() {\r\n        @Override\r\n        public void onAnimationEnd(final Animator animation) {\r\n            finishAnimation();\r\n        }\r\n    });\r\n    animatorSet.start();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.simplemodule.FilckerAnimationListView.animatePostLayout",
	"Comment": "animate items that just appeared and items that move within the screen.",
	"Method": "void animatePostLayout(float durationUnit){\r\n    finishAnimation();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.slider.Tricks.ViewPagerEx.addFocusables",
	"Comment": "we only want the current page that is being shown to be focusable.",
	"Method": "void addFocusables(ArrayList<View> views,int direction,int focusableMode){\r\n    final int focusableCount = views.size();\r\n    final int descendantFocusability = getDescendantFocusability();\r\n    if (descendantFocusability != FOCUS_BLOCK_DESCENDANTS) {\r\n        for (int i = 0; i < getChildCount(); i++) {\r\n            final View child = getChildAt(i);\r\n            if (child.getVisibility() == VISIBLE) {\r\n                ItemInfo ii = infoForChild(child);\r\n                if (ii != null && ii.position == mCurItem) {\r\n                    child.addFocusables(views, direction, focusableMode);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (descendantFocusability != FOCUS_AFTER_DESCENDANTS || (focusableCount == views.size())) {\r\n        if (!isFocusable()) {\r\n            return;\r\n        }\r\n        if ((focusableMode & FOCUSABLES_TOUCH_MODE) == FOCUSABLES_TOUCH_MODE && isInTouchMode() && !isFocusableInTouchMode()) {\r\n            return;\r\n        }\r\n        if (views != null) {\r\n            views.add(this);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.imageprocessing.inputprocess.CameraPreviewInput.onPause",
	"Comment": "closes and releases the camera for other applications to use.\tshould be called when the pause is called in the activity.",
	"Method": "void onPause(){\r\n    if (camera != null) {\r\n        camera.stopPreview();\r\n        camera.release();\r\n        camera = null;\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.motion.ParallaxImageView.setParallaxIntensity",
	"Comment": "sets the intensity of the parallax effect. the stronger the effect, the more distancethe image will have to move around.",
	"Method": "void setParallaxIntensity(float parallaxIntensity){\r\n    if (parallaxIntensity < 1)\r\n        throw new IllegalArgumentException(\"Parallax effect must have a intensity of 1.0 or greater\");\r\n    mParallaxIntensity = parallaxIntensity;\r\n    configureMatrix();\r\n}"
}, {
	"Path": "com.marshalchen.ua.common.commonUtils.fileUtils.ParcelUtils.readHashMap",
	"Comment": "read a hashmap from a parcel, class of key and value can parcelable both",
	"Method": "Map<K, V> readHashMap(Parcel in,ClassLoader loader){\r\n    if (in == null) {\r\n        return null;\r\n    }\r\n    int size = in.readInt();\r\n    if (size == -1) {\r\n        return null;\r\n    }\r\n    Map<K, V> map = new HashMap();\r\n    for (int i = 0; i < size; i++) {\r\n        map.put((K) in.readParcelable(loader), (V) in.readParcelable(loader));\r\n    }\r\n    return map;\r\n}"
}, {
	"Path": "org.testng.internal.thread.ThreadUtil.execute",
	"Comment": "parallel execution of the tasks. the startup is synchronized so this methodemulates a load test.",
	"Method": "void execute(String name,List<? extends Runnable> tasks,int threadPoolSize,long timeout,boolean triggerAtOnce){\r\n    Utils.log(\"ThreadUtil\", 2, \"Starting executor timeOut:\" + timeout + \"ms\" + \" workers:\" + tasks.size() + \" threadPoolSize:\" + threadPoolSize);\r\n    ExecutorService pooledExecutor = new ThreadPoolExecutor(threadPoolSize, threadPoolSize, timeout, TimeUnit.MILLISECONDS, new LinkedBlockingQueue(), new TestNGThreadFactory(name));\r\n    List<Callable<Object>> callables = Lists.newArrayList();\r\n    for (final Runnable task : tasks) {\r\n        callables.add(() -> {\r\n            task.run();\r\n            return null;\r\n        });\r\n    }\r\n    try {\r\n        if (timeout != 0) {\r\n            pooledExecutor.invokeAll(callables, timeout, TimeUnit.MILLISECONDS);\r\n        } else {\r\n            pooledExecutor.invokeAll(callables);\r\n        }\r\n    } catch (InterruptedException handled) {\r\n        Logger.getLogger(ThreadUtil.class).error(handled.getMessage(), handled);\r\n        Thread.currentThread().interrupt();\r\n    } finally {\r\n        pooledExecutor.shutdown();\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.ua.common.commonUtils.basicUtils.BasicUtils.iterateHashMapConcurrent",
	"Comment": "print all items of hashmap,avoid concurrentmodificationexceptions",
	"Method": "void iterateHashMapConcurrent(HashMap<String, Object> hashMap){\r\n    Iterator<Map.Entry<String, Object>> iterator = hashMap.entrySet().iterator();\r\n    while (iterator.hasNext()) {\r\n        Map.Entry<String, Object> entry = iterator.next();\r\n        Logs.d(\"key: \" + entry.getKey() + \"   \" + \"value:  \" + entry.getValue().toString());\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.imageprocessing.GLRenderer.getBackgroundBlue",
	"Comment": "returns the blue component of the background colour currently set for this glrenderer.",
	"Method": "float getBackgroundBlue(){\r\n    return blue;\r\n}"
}, {
	"Path": "org.testng.internal.reflect.ReflectionRecipes.exactMatch",
	"Comment": "matches an array of class instances to an array of instances.",
	"Method": "boolean exactMatch(Parameter[] parameters,Object[] args,boolean exactMatch,Class<?>[] classes,Object[] args){\r\n    boolean matching = true;\r\n    if (classes.length == args.length) {\r\n        int i = 0;\r\n        for (final Class<?> clazz : classes) {\r\n            matching = ReflectionRecipes.isInstanceOf(clazz, args[i]);\r\n            i++;\r\n            if (!matching)\r\n                break;\r\n        }\r\n    } else {\r\n        matching = false;\r\n    }\r\n    return matching;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.imageprocessing.GLRenderer.setBackgroundBlue",
	"Comment": "sets only the blue component of the background colour currently set for this glrenderer.",
	"Method": "void setBackgroundBlue(float blue){\r\n    this.blue = blue;\r\n}"
}, {
	"Path": "org.isoron.androidbase.activities.BaseScreen.setSelectionMenu",
	"Comment": "sets the menu to be shown when a selection is active on the screen.",
	"Method": "void setSelectionMenu(BaseSelectionMenu menu){\r\n    this.selectionMenu = menu;\r\n}"
}, {
	"Path": "org.testng.SuiteRunner.getAnnotationFinder",
	"Comment": "returns the annotation finder for the given annotation type.",
	"Method": "IAnnotationFinder getAnnotationFinder(){\r\n    return configuration.getAnnotationFinder();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.slider.Tricks.ViewPagerEx.executeKeyEvent",
	"Comment": "you can call this function yourself to have the scroll view performscrolling from a key event, just as if the event had been dispatched toit by the view hierarchy.",
	"Method": "boolean executeKeyEvent(KeyEvent event){\r\n    boolean handled = false;\r\n    if (event.getAction() == KeyEvent.ACTION_DOWN) {\r\n        switch(event.getKeyCode()) {\r\n            case KeyEvent.KEYCODE_DPAD_LEFT:\r\n                handled = arrowScroll(FOCUS_LEFT);\r\n                break;\r\n            case KeyEvent.KEYCODE_DPAD_RIGHT:\r\n                handled = arrowScroll(FOCUS_RIGHT);\r\n                break;\r\n            case KeyEvent.KEYCODE_TAB:\r\n                if (Build.VERSION.SDK_INT >= 11) {\r\n                    if (KeyEventCompat.hasNoModifiers(event)) {\r\n                        handled = arrowScroll(FOCUS_FORWARD);\r\n                    } else if (KeyEventCompat.hasModifiers(event, KeyEvent.META_SHIFT_ON)) {\r\n                        handled = arrowScroll(FOCUS_BACKWARD);\r\n                    }\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    return handled;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.rebound.Spring.setCurrentValue",
	"Comment": "set the displaced value to determine the displacement for the spring from the rest value.this value is retained and used to calculate the displacement ratio.this also updates the start value of the spring.",
	"Method": "Spring setCurrentValue(double currentValue){\r\n    mStartValue = currentValue;\r\n    mCurrentState.position = currentValue;\r\n    for (SpringListener listener : mListeners) {\r\n        listener.onSpringUpdate(this);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.isoron.uhabits.core.database.Repository.find",
	"Comment": "returns the record that has the id provided.if no record is found, returns null.",
	"Method": "T find(Long id){\r\n    return findFirst(String.format(\"where %s=?\", getIdName()), id.toString());\r\n}"
}, {
	"Path": "org.isoron.uhabits.core.models.Timestamp.oldest",
	"Comment": "given two timestamps, returns whichever timestamp is the oldest one.",
	"Method": "Timestamp oldest(Timestamp first,Timestamp second){\r\n    return first.unixTime < second.unixTime ? first : second;\r\n}"
}, {
	"Path": "com.marshalchen.common.commonUtils.dbUtils.GreenDaoUtils.setIsLog",
	"Comment": "set if the greendao will log the resulting sql command and the passed values when calling one of the build methods.like this you can compare if you actually get what you expected. it might also help to copy generated sql into some sqlite database explorer and execute it with the values.",
	"Method": "void setIsLog(boolean isLog){\r\n    GreenDaoUtils.isLog = isLog;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.easyandroidanimations.FoldAnimation.setOrientation",
	"Comment": "the available orientations are orientation.horizontal and\torientation.vertical.",
	"Method": "FoldAnimation setOrientation(Orientation orientation){\r\n    this.orientation = orientation;\r\n    return this;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.slider.Tricks.ViewPagerEx.onRequestFocusInDescendants",
	"Comment": "we only want the current page that is being shown to be focusable.",
	"Method": "boolean onRequestFocusInDescendants(int direction,Rect previouslyFocusedRect){\r\n    int index;\r\n    int increment;\r\n    int end;\r\n    int count = getChildCount();\r\n    if ((direction & FOCUS_FORWARD) != 0) {\r\n        index = 0;\r\n        increment = 1;\r\n        end = count;\r\n    } else {\r\n        index = count - 1;\r\n        increment = -1;\r\n        end = -1;\r\n    }\r\n    for (int i = index; i != end; i += increment) {\r\n        View child = getChildAt(i);\r\n        if (child.getVisibility() == VISIBLE) {\r\n            ItemInfo ii = infoForChild(child);\r\n            if (ii != null && ii.position == mCurItem) {\r\n                if (child.requestFocus(direction, previouslyFocusedRect)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.tileView.tileview.TileView.framePoints",
	"Comment": "scales and moves tileview so that each of the passed points is visible.",
	"Method": "void framePoints(List<double[]> points){\r\n    double topMost = -Integer.MAX_VALUE;\r\n    double bottomMost = Integer.MAX_VALUE;\r\n    double leftMost = Integer.MAX_VALUE;\r\n    double rightMost = -Integer.MAX_VALUE;\r\n    for (double[] coordinate : points) {\r\n        double x = coordinate[0];\r\n        double y = coordinate[1];\r\n        if (positionManager.contains(x, y)) {\r\n            topMost = Math.max(topMost, x);\r\n            bottomMost = Math.min(bottomMost, x);\r\n            leftMost = Math.min(leftMost, y);\r\n            rightMost = Math.max(rightMost, y);\r\n        }\r\n    }\r\n    Point topRight = translate(topMost, rightMost);\r\n    Point bottomLeft = translate(bottomMost, leftMost);\r\n    int width = bottomLeft.x - topRight.x;\r\n    int height = bottomLeft.y - topRight.y;\r\n    double scaleX = Math.abs(getWidth() / (double) width);\r\n    double scaleY = Math.abs(getHeight() / (double) height);\r\n    double destinationScale = Math.min(scaleX, scaleY);\r\n    double middleX = (rightMost + leftMost) * 0.5f;\r\n    double middleY = (topMost + bottomMost) * 0.5f;\r\n    moveToAndCenter(middleY, middleX);\r\n    setScaleFromCenter(destinationScale);\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.Thumbnails.of",
	"Comment": "indicate to make thumbnails for images with the specified filenames.",
	"Method": "Builder<File> of(String files,Builder<File> of,File files,Builder<URL> of,URL urls,Builder<? extends InputStream> of,InputStream inputStreams,Builder<BufferedImage> of,BufferedImage images){\r\n    checkForNull(images, \"Cannot specify null for images.\");\r\n    checkForEmpty(images, \"Cannot specify an empty array for images.\");\r\n    return Builder.ofBufferedImages(Arrays.asList(images));\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase1Scenario2.verifyOnlyOneInstanceOfTestClassForAllTestMethodsForAllSuites",
	"Comment": "verify that the same test class instance is associated with each of the test methods from the sample test class",
	"Method": "void verifyOnlyOneInstanceOfTestClassForAllTestMethodsForAllSuites(){\r\n    verifyNumberOfInstancesOfTestClassesForMethods(SUITE_A, SUITE_A_TEST_A, Arrays.asList(TestClassAFiveMethodsWithNoDepsSample.class, TestClassCSixMethodsWithNoDepsSample.class), 1);\r\n    verifySameInstancesOfTestClassesAssociatedWithMethods(SUITE_A, SUITE_A_TEST_A, Arrays.asList(TestClassAFiveMethodsWithNoDepsSample.class, TestClassCSixMethodsWithNoDepsSample.class));\r\n    verifyNumberOfInstancesOfTestClassForMethods(SUITE_B, SUITE_B_TEST_A, TestClassEFiveMethodsWithNoDepsSample.class, 1);\r\n    verifySameInstancesOfTestClassAssociatedWithMethods(SUITE_B, SUITE_B_TEST_A, TestClassEFiveMethodsWithNoDepsSample.class);\r\n    verifyNumberOfInstancesOfTestClassesForMethods(SUITE_B, SUITE_B_TEST_B, Arrays.asList(TestClassDThreeMethodsWithNoDepsSample.class, TestClassBFourMethodsWithNoDepsSample.class, TestClassFSixMethodsWithNoDepsSample.class), 1);\r\n    verifySameInstancesOfTestClassesAssociatedWithMethods(SUITE_B, SUITE_B_TEST_B, Arrays.asList(TestClassDThreeMethodsWithNoDepsSample.class, TestClassBFourMethodsWithNoDepsSample.class, TestClassFSixMethodsWithNoDepsSample.class));\r\n    verifyNumberOfInstancesOfTestClassesForMethods(SUITE_C, SUITE_C_TEST_A, Arrays.asList(TestClassGThreeMethodsWithNoDepsSample.class, TestClassHFourMethodsWithNoDepsSample.class, TestClassIFiveMethodsWithNoDepsSample.class), 1);\r\n    verifySameInstancesOfTestClassesAssociatedWithMethods(SUITE_C, SUITE_C_TEST_A, Arrays.asList(TestClassGThreeMethodsWithNoDepsSample.class, TestClassHFourMethodsWithNoDepsSample.class, TestClassIFiveMethodsWithNoDepsSample.class));\r\n    verifyNumberOfInstancesOfTestClassesForMethods(SUITE_C, SUITE_C_TEST_B, Arrays.asList(TestClassJFourMethodsWithNoDepsSample.class, TestClassKFiveMethodsWithNoDepsSample.class), 1);\r\n    verifySameInstancesOfTestClassesAssociatedWithMethods(SUITE_C, SUITE_C_TEST_B, Arrays.asList(TestClassJFourMethodsWithNoDepsSample.class, TestClassKFiveMethodsWithNoDepsSample.class));\r\n    verifyNumberOfInstancesOfTestClassesForMethods(SUITE_C, SUITE_C_TEST_C, Arrays.asList(TestClassLThreeMethodsWithNoDepsSample.class, TestClassMFourMethodsWithNoDepsSample.class, TestClassNFiveMethodsWithNoDepsSample.class, TestClassOSixMethodsWithNoDepsSample.class), 1);\r\n    verifySameInstancesOfTestClassesAssociatedWithMethods(SUITE_C, SUITE_C_TEST_C, Arrays.asList(TestClassLThreeMethodsWithNoDepsSample.class, TestClassMFourMethodsWithNoDepsSample.class, TestClassNFiveMethodsWithNoDepsSample.class, TestClassOSixMethodsWithNoDepsSample.class));\r\n}"
}, {
	"Path": "org.testng.internal.TestInvoker.checkDependencies",
	"Comment": "checks to see of the test method has certain dependencies that prevents testng from executing",
	"Method": "String checkDependencies(ITestNGMethod testMethod,ITestNGMethod[] allTestMethods){\r\n    if (testMethod.isAlwaysRun()) {\r\n        return null;\r\n    }\r\n    if (testMethod.getMissingGroup() != null && !testMethod.ignoreMissingDependencies()) {\r\n        return \"Method \" + testMethod + \" depends on nonexistent group \\\"\" + testMethod.getMissingGroup() + \"\\\"\";\r\n    }\r\n    String[] groups = testMethod.getGroupsDependedUpon();\r\n    if (null != groups && groups.length > 0) {\r\n        for (String element : groups) {\r\n            ITestNGMethod[] methods = MethodGroupsHelper.findMethodsThatBelongToGroup(testMethod, m_testContext.getAllTestMethods(), element);\r\n            if (methods.length == 0 && !testMethod.ignoreMissingDependencies()) {\r\n                return \"Method \" + testMethod + \" depends on nonexistent group \\\"\" + element + \"\\\"\";\r\n            }\r\n            if (failuresPresentInUpstreamDependency(testMethod, methods)) {\r\n                return \"Method \" + testMethod + \" depends on not successfully finished methods in group \\\"\" + element + \"\\\"\";\r\n            }\r\n        }\r\n    }\r\n    if (TestNgMethodUtils.cannotRunMethodIndependently(testMethod)) {\r\n        ITestNGMethod[] methods = MethodHelper.findDependedUponMethods(testMethod, allTestMethods);\r\n        if (failuresPresentInUpstreamDependency(testMethod, methods)) {\r\n            return \"Method \" + testMethod + \" depends on not successfully finished methods\";\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.marshalchen.common.commonUtils.fileUtils.ParcelUtils.readHashMapStringAndString",
	"Comment": "read a hashmap from a parcel, class of key and value are both string",
	"Method": "Map<String, String> readHashMapStringAndString(Parcel in){\r\n    if (in == null) {\r\n        return null;\r\n    }\r\n    int size = in.readInt();\r\n    if (size == -1) {\r\n        return null;\r\n    }\r\n    Map<String, String> map = new HashMap<String, String>();\r\n    for (int i = 0; i < size; i++) {\r\n        String key = in.readString();\r\n        map.put(key, in.readString());\r\n    }\r\n    return map;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.motion.ParallaxImageView.setMaximumJump",
	"Comment": "sets the maximum percentage of the image that image matrix is allowed to translatefor each sensor reading.",
	"Method": "void setMaximumJump(float maximumJump){\r\n    mMaximumJump = maximumJump;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.circularfloatingactionmenu.animation.MenuAnimationHandler.animateMenuOpening",
	"Comment": "starts the opening animationshould be overriden by children",
	"Method": "void animateMenuOpening(Point center){\r\n    if (menu == null) {\r\n        throw new NullPointerException(\"MenuAnimationHandler cannot animate without a valid FloatingActionMenu.\");\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.animation.ValueAnimator.initAnimation",
	"Comment": "this function is called immediately before processing the first animationframe of an animation. if there is a nonzero startdelay, thefunction is called after that delay ends.it takes care of the final initialization steps for theanimation. overrides of this method should call the superclass method to ensure that internal mechanisms for the animation are set up correctly.",
	"Method": "void initAnimation(){\r\n    if (!mInitialized) {\r\n        int numValues = mValues.length;\r\n        for (int i = 0; i < numValues; ++i) {\r\n            mValues[i].init();\r\n        }\r\n        mInitialized = true;\r\n    }\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.builders.ThumbnailParameterBuilder.region",
	"Comment": "sets the region of the source image to use when creating a thumbnail.",
	"Method": "ThumbnailParameterBuilder region(Region sourceRegion){\r\n    this.sourceRegion = sourceRegion;\r\n    return this;\r\n}"
}, {
	"Path": "com.marshalchen.ua.common.commonUtils.basicUtils.ArrayUtils.getNext",
	"Comment": "get next element of the target element, after the first one that match the target element front to backif array is empty, return defaultvalueif target element is not exist in array, return defaultvalueif target element exist in array and not the last one in array, return the next elementif target element exist in array and the last one in array, return the first one in array if iscircle istrue, else return defaultvalue",
	"Method": "V getNext(V[] sourceArray,V value,V defaultValue,boolean isCircle,V getNext,V[] sourceArray,V value,boolean isCircle,long getNext,long[] sourceArray,long value,long defaultValue,boolean isCircle,int getNext,int[] sourceArray,int value,int defaultValue,boolean isCircle){\r\n    if (sourceArray.length == 0) {\r\n        throw new IllegalArgumentException(\"The length of source array must be greater than 0.\");\r\n    }\r\n    Integer[] array = transformIntArray(sourceArray);\r\n    return getNext(array, value, defaultValue, isCircle);\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.easyandroidanimations.AnimationDetailFragment.doAnimation",
	"Comment": "this method performs the various animations available in theandroidanimator library.",
	"Method": "void doAnimation(){\r\n    switch(mItem.id) {\r\n        case 1:\r\n            new BlindAnimation(card).animate();\r\n            break;\r\n        case 2:\r\n            new BlinkAnimation(card).setListener(new AnimationListener() {\r\n                @Override\r\n                public void onAnimationEnd(Animation animation) {\r\n                    mPlayView.setVisibility(View.VISIBLE);\r\n                }\r\n            }).animate();\r\n            break;\r\n        case 3:\r\n            new BounceAnimation(card).setNumOfBounces(3).setDuration(Animation.DURATION_SHORT).setListener(new AnimationListener() {\r\n                @Override\r\n                public void onAnimationEnd(Animation animation) {\r\n                    mPlayView.setVisibility(View.VISIBLE);\r\n                }\r\n            }).animate();\r\n            break;\r\n        case 4:\r\n            new ExplodeAnimation(card).animate();\r\n            break;\r\n        case 5:\r\n            new FadeInAnimation(card).animate();\r\n            break;\r\n        case 6:\r\n            new FadeOutAnimation(card).animate();\r\n            break;\r\n        case 7:\r\n            new FlipHorizontalAnimation(card).setListener(new AnimationListener() {\r\n                @Override\r\n                public void onAnimationEnd(Animation animation) {\r\n                    mPlayView.setVisibility(View.VISIBLE);\r\n                }\r\n            }).animate();\r\n            break;\r\n        case 8:\r\n            new FlipHorizontalToAnimation(card).setFlipToView(card2).setInterpolator(new LinearInterpolator()).animate();\r\n            break;\r\n        case 9:\r\n            new FlipVerticalAnimation(card).setListener(new AnimationListener() {\r\n                @Override\r\n                public void onAnimationEnd(Animation animation) {\r\n                    mPlayView.setVisibility(View.VISIBLE);\r\n                }\r\n            }).animate();\r\n            break;\r\n        case 10:\r\n            new FlipVerticalToAnimation(card).setFlipToView(card2).setInterpolator(new LinearInterpolator()).animate();\r\n            break;\r\n        case 11:\r\n            card2.setVisibility(View.VISIBLE);\r\n            new UnfoldAnimation(card).setNumOfFolds(10).setDuration(1000).setOrientation(Orientation.HORIZONTAL).animate();\r\n            break;\r\n        case 12:\r\n            card2.setVisibility(View.VISIBLE);\r\n            new FoldAnimation(card).setNumOfFolds(10).setDuration(1000).setOrientation(Orientation.VERTICAL).animate();\r\n            break;\r\n        case 13:\r\n            new HighlightAnimation(card).setListener(new AnimationListener() {\r\n                @Override\r\n                public void onAnimationEnd(Animation animation) {\r\n                    mPlayView.setVisibility(View.VISIBLE);\r\n                }\r\n            }).animate();\r\n            break;\r\n        case 14:\r\n            ArrayList<Point> points = new ArrayList();\r\n            points.add(new Point(0, 100));\r\n            points.add(new Point(50, 0));\r\n            points.add(new Point(100, 100));\r\n            points.add(new Point(0, 50));\r\n            points.add(new Point(100, 50));\r\n            points.add(new Point(0, 100));\r\n            points.add(new Point(50, 50));\r\n            new PathAnimation(card).setPoints(points).setDuration(2000).setListener(new AnimationListener() {\r\n                @Override\r\n                public void onAnimationEnd(Animation animation) {\r\n                    mPlayView.setVisibility(View.VISIBLE);\r\n                }\r\n            }).animate();\r\n            break;\r\n        case 15:\r\n            new PuffInAnimation(card).animate();\r\n            break;\r\n        case 16:\r\n            new PuffOutAnimation(card).animate();\r\n            break;\r\n        case 17:\r\n            new RotationAnimation(card).setPivot(RotationAnimation.PIVOT_TOP_LEFT).setListener(new AnimationListener() {\r\n                @Override\r\n                public void onAnimationEnd(Animation animation) {\r\n                    mPlayView.setVisibility(View.VISIBLE);\r\n                }\r\n            }).animate();\r\n            break;\r\n        case 18:\r\n            new ScaleInAnimation(card).animate();\r\n            break;\r\n        case 19:\r\n            new ScaleOutAnimation(card).animate();\r\n            break;\r\n        case 20:\r\n            new ShakeAnimation(card).setNumOfShakes(3).setDuration(Animation.DURATION_SHORT).setListener(new AnimationListener() {\r\n                @Override\r\n                public void onAnimationEnd(Animation animation) {\r\n                    mPlayView.setVisibility(View.VISIBLE);\r\n                }\r\n            }).animate();\r\n            break;\r\n        case 21:\r\n            new SlideInAnimation(card).setDirection(Animation.DIRECTION_UP).animate();\r\n            break;\r\n        case 22:\r\n            new SlideInUnderneathAnimation(card).setDirection(Animation.DIRECTION_DOWN).animate();\r\n            break;\r\n        case 23:\r\n            new SlideOutAnimation(card).setDirection(Animation.DIRECTION_LEFT).animate();\r\n            break;\r\n        case 24:\r\n            new SlideOutUnderneathAnimation(card).setDirection(Animation.DIRECTION_RIGHT).animate();\r\n            break;\r\n        case 25:\r\n            new TransferAnimation(card).setDestinationView(target).animate();\r\n            break;\r\n        case 26:\r\n            card.setImageResource(R.drawable.test_back2);\r\n            final AnimationListener explodeAnimListener = new AnimationListener() {\r\n                @Override\r\n                public void onAnimationEnd(Animation animation) {\r\n                    card.setVisibility(View.INVISIBLE);\r\n                    mPlayView.setVisibility(View.VISIBLE);\r\n                }\r\n            };\r\n            final AnimationListener bounceAnimListener = new AnimationListener() {\r\n                @Override\r\n                public void onAnimationEnd(Animation animation) {\r\n                    new ExplodeAnimation(card2).setListener(explodeAnimListener).animate();\r\n                }\r\n            };\r\n            final ParallelAnimatorListener slideFadeInAnimListener = new ParallelAnimatorListener() {\r\n                @Override\r\n                public void onAnimationEnd(ParallelAnimator parallelAnimator) {\r\n                    BounceAnimation bounceAnim = new BounceAnimation(card2);\r\n                    bounceAnim.setNumOfBounces(10);\r\n                    bounceAnim.setListener(bounceAnimListener);\r\n                    bounceAnim.animate();\r\n                }\r\n            };\r\n            final ParallelAnimatorListener slideFadeOutAnimListener = new ParallelAnimatorListener() {\r\n                @Override\r\n                public void onAnimationEnd(ParallelAnimator parallelAnimator) {\r\n                    ParallelAnimator slideFadeInAnim = new ParallelAnimator();\r\n                    slideFadeInAnim.add(new SlideInAnimation(card2).setDirection(Animation.DIRECTION_RIGHT));\r\n                    slideFadeInAnim.add(new FadeInAnimation(card2));\r\n                    slideFadeInAnim.setDuration(1000);\r\n                    slideFadeInAnim.setListener(slideFadeInAnimListener);\r\n                    slideFadeInAnim.animate();\r\n                }\r\n            };\r\n            final ParallelAnimatorListener rotatePathAnimListener = new ParallelAnimatorListener() {\r\n                @Override\r\n                public void onAnimationEnd(ParallelAnimator parallelAnimator) {\r\n                    ParallelAnimator slideFadeOutAnim = new ParallelAnimator();\r\n                    slideFadeOutAnim.add(new SlideOutAnimation(card).setDirection(Animation.DIRECTION_RIGHT));\r\n                    slideFadeOutAnim.add(new FadeOutAnimation(card));\r\n                    slideFadeOutAnim.setInterpolator(new LinearInterpolator());\r\n                    slideFadeOutAnim.setDuration(1000);\r\n                    slideFadeOutAnim.setListener(slideFadeOutAnimListener);\r\n                    slideFadeOutAnim.animate();\r\n                }\r\n            };\r\n            final ParallelAnimatorListener scaleFlipAnimListener = new ParallelAnimatorListener() {\r\n                @Override\r\n                public void onAnimationEnd(ParallelAnimator parallelAnimator) {\r\n                    ArrayList<Point> parallelPoints = new ArrayList();\r\n                    parallelPoints.add(new Point(50, 0));\r\n                    parallelPoints.add(new Point(100, 50));\r\n                    parallelPoints.add(new Point(50, 100));\r\n                    parallelPoints.add(new Point(0, 50));\r\n                    parallelPoints.add(new Point(50, 50));\r\n                    ParallelAnimator rotatePathAnim = new ParallelAnimator();\r\n                    rotatePathAnim.add(new PathAnimation(card).setPoints(parallelPoints));\r\n                    rotatePathAnim.add(new RotationAnimation(card));\r\n                    rotatePathAnim.setInterpolator(new LinearInterpolator());\r\n                    rotatePathAnim.setDuration(2000);\r\n                    rotatePathAnim.setListener(rotatePathAnimListener);\r\n                    rotatePathAnim.animate();\r\n                }\r\n            };\r\n            ParallelAnimator scaleFlipAnim = new ParallelAnimator();\r\n            scaleFlipAnim.add(new ScaleInAnimation(card));\r\n            scaleFlipAnim.add(new FlipHorizontalAnimation(card));\r\n            scaleFlipAnim.add(new FlipVerticalAnimation(card));\r\n            scaleFlipAnim.setDuration(2000);\r\n            scaleFlipAnim.setListener(scaleFlipAnimListener);\r\n            scaleFlipAnim.animate();\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.easyandroidanimations.AnimationDetailFragment.doAnimation",
	"Comment": "this method performs the various animations available in theandroidanimator library.",
	"Method": "void doAnimation(){\r\n    mPlayView.setVisibility(View.VISIBLE);\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.easyandroidanimations.AnimationDetailFragment.doAnimation",
	"Comment": "this method performs the various animations available in theandroidanimator library.",
	"Method": "void doAnimation(){\r\n    mPlayView.setVisibility(View.VISIBLE);\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.easyandroidanimations.AnimationDetailFragment.doAnimation",
	"Comment": "this method performs the various animations available in theandroidanimator library.",
	"Method": "void doAnimation(){\r\n    mPlayView.setVisibility(View.VISIBLE);\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.easyandroidanimations.AnimationDetailFragment.doAnimation",
	"Comment": "this method performs the various animations available in theandroidanimator library.",
	"Method": "void doAnimation(){\r\n    mPlayView.setVisibility(View.VISIBLE);\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.easyandroidanimations.AnimationDetailFragment.doAnimation",
	"Comment": "this method performs the various animations available in theandroidanimator library.",
	"Method": "void doAnimation(){\r\n    mPlayView.setVisibility(View.VISIBLE);\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.easyandroidanimations.AnimationDetailFragment.doAnimation",
	"Comment": "this method performs the various animations available in theandroidanimator library.",
	"Method": "void doAnimation(){\r\n    mPlayView.setVisibility(View.VISIBLE);\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.easyandroidanimations.AnimationDetailFragment.doAnimation",
	"Comment": "this method performs the various animations available in theandroidanimator library.",
	"Method": "void doAnimation(){\r\n    mPlayView.setVisibility(View.VISIBLE);\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.easyandroidanimations.AnimationDetailFragment.doAnimation",
	"Comment": "this method performs the various animations available in theandroidanimator library.",
	"Method": "void doAnimation(){\r\n    mPlayView.setVisibility(View.VISIBLE);\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.easyandroidanimations.AnimationDetailFragment.doAnimation",
	"Comment": "this method performs the various animations available in theandroidanimator library.",
	"Method": "void doAnimation(){\r\n    card.setVisibility(View.INVISIBLE);\r\n    mPlayView.setVisibility(View.VISIBLE);\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.easyandroidanimations.AnimationDetailFragment.doAnimation",
	"Comment": "this method performs the various animations available in theandroidanimator library.",
	"Method": "void doAnimation(){\r\n    new ExplodeAnimation(card2).setListener(explodeAnimListener).animate();\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.easyandroidanimations.AnimationDetailFragment.doAnimation",
	"Comment": "this method performs the various animations available in theandroidanimator library.",
	"Method": "void doAnimation(){\r\n    BounceAnimation bounceAnim = new BounceAnimation(card2);\r\n    bounceAnim.setNumOfBounces(10);\r\n    bounceAnim.setListener(bounceAnimListener);\r\n    bounceAnim.animate();\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.easyandroidanimations.AnimationDetailFragment.doAnimation",
	"Comment": "this method performs the various animations available in theandroidanimator library.",
	"Method": "void doAnimation(){\r\n    ParallelAnimator slideFadeInAnim = new ParallelAnimator();\r\n    slideFadeInAnim.add(new SlideInAnimation(card2).setDirection(Animation.DIRECTION_RIGHT));\r\n    slideFadeInAnim.add(new FadeInAnimation(card2));\r\n    slideFadeInAnim.setDuration(1000);\r\n    slideFadeInAnim.setListener(slideFadeInAnimListener);\r\n    slideFadeInAnim.animate();\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.easyandroidanimations.AnimationDetailFragment.doAnimation",
	"Comment": "this method performs the various animations available in theandroidanimator library.",
	"Method": "void doAnimation(){\r\n    ParallelAnimator slideFadeOutAnim = new ParallelAnimator();\r\n    slideFadeOutAnim.add(new SlideOutAnimation(card).setDirection(Animation.DIRECTION_RIGHT));\r\n    slideFadeOutAnim.add(new FadeOutAnimation(card));\r\n    slideFadeOutAnim.setInterpolator(new LinearInterpolator());\r\n    slideFadeOutAnim.setDuration(1000);\r\n    slideFadeOutAnim.setListener(slideFadeOutAnimListener);\r\n    slideFadeOutAnim.animate();\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.easyandroidanimations.AnimationDetailFragment.doAnimation",
	"Comment": "this method performs the various animations available in theandroidanimator library.",
	"Method": "void doAnimation(){\r\n    ArrayList<Point> parallelPoints = new ArrayList();\r\n    parallelPoints.add(new Point(50, 0));\r\n    parallelPoints.add(new Point(100, 50));\r\n    parallelPoints.add(new Point(50, 100));\r\n    parallelPoints.add(new Point(0, 50));\r\n    parallelPoints.add(new Point(50, 50));\r\n    ParallelAnimator rotatePathAnim = new ParallelAnimator();\r\n    rotatePathAnim.add(new PathAnimation(card).setPoints(parallelPoints));\r\n    rotatePathAnim.add(new RotationAnimation(card));\r\n    rotatePathAnim.setInterpolator(new LinearInterpolator());\r\n    rotatePathAnim.setDuration(2000);\r\n    rotatePathAnim.setListener(rotatePathAnimListener);\r\n    rotatePathAnim.animate();\r\n}"
}, {
	"Path": "org.testng.reporters.EmailableReporter2.writeTableHeader",
	"Comment": "writes a th element with the specified contents and css class names.",
	"Method": "void writeTableHeader(String html,String cssClasses){\r\n    writeTag(\"th\", html, cssClasses);\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase8Scenario1.verifyThatTestMethodsRunInParallelThreads",
	"Comment": "verifies that the test methods execute in different threads in parallel fashion.",
	"Method": "void verifyThatTestMethodsRunInParallelThreads(){\r\n    verifySimultaneousTestMethods(getTestMethodLevelEventLogsForTest(SUITE_A, SUITE_A_TEST_A), SUITE_A_TEST_A, 10);\r\n    verifySimultaneousTestMethods(getTestMethodLevelEventLogsForTest(SUITE_B, SUITE_B_TEST_A), SUITE_B_TEST_A, 3);\r\n    verifySimultaneousTestMethods(getTestMethodLevelEventLogsForTest(SUITE_B, SUITE_B_TEST_B), SUITE_B_TEST_B, 20);\r\n    verifySimultaneousTestMethods(getTestMethodLevelEventLogsForTest(SUITE_C, SUITE_C_TEST_A), SUITE_C_TEST_A, 25);\r\n    verifySimultaneousTestMethods(getTestMethodLevelEventLogsForTest(SUITE_C, SUITE_C_TEST_B), SUITE_C_TEST_B, 5);\r\n    verifySimultaneousTestMethods(getTestMethodLevelEventLogsForTest(SUITE_C, SUITE_C_TEST_C), SUITE_C_TEST_C, 12);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.photoview.PhotoViewAttacher.getDisplayRect",
	"Comment": "helper method that maps the supplied matrix to the current drawable",
	"Method": "RectF getDisplayRect(RectF getDisplayRect,Matrix matrix){\r\n    ImageView imageView = getImageView();\r\n    if (null != imageView) {\r\n        Drawable d = imageView.getDrawable();\r\n        if (null != d) {\r\n            mDisplayRect.set(0, 0, d.getIntrinsicWidth(), d.getIntrinsicHeight());\r\n            matrix.mapRect(mDisplayRect);\r\n            return mDisplayRect;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "test.thread.parallelization.TestNgRunStateTracker.getTestListenerStartEventLogsForSuite",
	"Comment": "get all the test listener onstart event logs for the specified suite",
	"Method": "List<EventLog> getTestListenerStartEventLogsForSuite(String suiteName){\r\n    List<EventLog> testStartEventLogs = new ArrayList();\r\n    for (EventLog eventLog : eventLogs) {\r\n        if (eventLog.getEvent() == TestNgRunEvent.LISTENER_TEST_START && belongsToSuite(suiteName, eventLog)) {\r\n            testStartEventLogs.add(eventLog);\r\n        }\r\n    }\r\n    return testStartEventLogs;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.cropimage.HighlightView.getScaledCropRect",
	"Comment": "returns the cropping rectangle in image space with specified scale",
	"Method": "Rect getScaledCropRect(float scale){\r\n    return new Rect((int) (cropRect.left * scale), (int) (cropRect.top * scale), (int) (cropRect.right * scale), (int) (cropRect.bottom * scale));\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.tileView.tileview.TileView.clear",
	"Comment": "clear bitmap image files, appropriate for activity.onpause",
	"Method": "void clear(){\r\n    tileManager.clear();\r\n    sampleManager.clear();\r\n    pathManager.setShouldDraw(false);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.easyandroidanimations.UnfoldAnimation.setOrientation",
	"Comment": "the available orientations are orientation.horizontal and\torientation.vertical.",
	"Method": "UnfoldAnimation setOrientation(Orientation orientation){\r\n    this.orientation = orientation;\r\n    return this;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.switchbutton.SwitchButton.getConfiguration",
	"Comment": "return a reference of configuration, it is suggested that not to change that",
	"Method": "Configuration getConfiguration(){\r\n    return mConf;\r\n}"
}, {
	"Path": "com.marshalchen.ua.common.commonUtils.basicUtils.ArrayUtils.getLast",
	"Comment": "get last element of the target element, before the first one that match the target element front to backif array is empty, return defaultvalueif target element is not exist in array, return defaultvalueif target element exist in array and its index is not 0, return the last elementif target element exist in array and its index is 0, return the last one in array if iscircle is true, elsereturn defaultvalue",
	"Method": "V getLast(V[] sourceArray,V value,V defaultValue,boolean isCircle,V getLast,V[] sourceArray,V value,boolean isCircle,long getLast,long[] sourceArray,long value,long defaultValue,boolean isCircle,int getLast,int[] sourceArray,int value,int defaultValue,boolean isCircle){\r\n    if (sourceArray.length == 0) {\r\n        throw new IllegalArgumentException(\"The length of source array must be greater than 0.\");\r\n    }\r\n    Integer[] array = transformIntArray(sourceArray);\r\n    return getLast(array, value, defaultValue, isCircle);\r\n}"
}, {
	"Path": "com.marshalchen.common.commonUtils.fileUtils.PreferencesUtils.getBoolean",
	"Comment": "get boolean from custom preferences with custom default value",
	"Method": "boolean getBoolean(Context context,String key,boolean getBoolean,Context context,String preferenceName,String key,boolean getBoolean,Context context,String preferenceName,String key,boolean defaultValue){\r\n    SharedPreferences settings = context.getSharedPreferences(preferenceName, Context.MODE_PRIVATE);\r\n    return settings.getBoolean(key, defaultValue);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.twowayview.widget.ItemSpacingOffsets.isFirstChildInLane",
	"Comment": "checks whether the given position is placed at the start of a layout lane.",
	"Method": "boolean isFirstChildInLane(BaseLayoutManager lm,int itemPosition){\r\n    final int laneCount = lm.getLanes().getCount();\r\n    if (itemPosition >= laneCount) {\r\n        return false;\r\n    }\r\n    int count = 0;\r\n    for (int i = 0; i < itemPosition; i++) {\r\n        count += lm.getLaneSpanForPosition(i);\r\n        if (count >= laneCount) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase8Scenario1.verifyThatMethodLevelEventsRunInDifferentThreadsFromSuiteAndTestLevelEvents",
	"Comment": "verifies that the test method listener and execution events for a given test method all run in the same thread.",
	"Method": "void verifyThatMethodLevelEventsRunInDifferentThreadsFromSuiteAndTestLevelEvents(){\r\n    verifyEventThreadsSpawnedAfter(getAllSuiteListenerStartEventLogs().get(0).getThreadId(), testMethodLevelEventLogs, \"All the thread IDs for the test method level events should be greater than the thread ID for the \" + \"suite and test level events. The expectation is that since the suite and test level events \" + \"are running sequentially, and all the test methods are running in parallel, new threads \" + \"will be spawned after the thread executing the suite and test level events when new methods \" + \"begin executing. Suite and test level events thread ID: \" + getAllSuiteListenerStartEventLogs().get(0).getThreadId() + \". Test method level event logs: \" + testMethodLevelEventLogs);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassAFiveMethodsWithFactoryUsingDataProviderAndNoDepsSample.class, SUITE_A, SUITE_A_TEST_A);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassCSixMethodsWithFactoryUsingDataProviderAndNoDepsSample.class, SUITE_A, SUITE_A_TEST_A);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassEFiveMethodsWithNoDepsSample.class, SUITE_B, SUITE_B_TEST_A);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassDThreeMethodsWithFactoryUsingDataProviderAndNoDepsSample.class, SUITE_B, SUITE_B_TEST_B);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassBFourMethodsWithFactoryUsingDataProviderAndNoDepsSample.class, SUITE_B, SUITE_B_TEST_B);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassFSixMethodsWithFactoryUsingDataProviderAndNoDepsSample.class, SUITE_B, SUITE_B_TEST_B);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassGThreeMethodsWithNoDepsSample.class, SUITE_C, SUITE_C_TEST_A);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassHFourMethodsWithNoDepsSample.class, SUITE_C, SUITE_C_TEST_A);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassIFiveMethodsWithNoDepsSample.class, SUITE_C, SUITE_C_TEST_A);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassJFourMethodsWithNoDepsSample.class, SUITE_C, SUITE_C_TEST_B);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassKFiveMethodsWithNoDepsSample.class, SUITE_C, SUITE_C_TEST_B);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassLThreeMethodsWithNoDepsSample.class, SUITE_C, SUITE_C_TEST_C);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassMFourMethodsWithNoDepsSample.class, SUITE_C, SUITE_C_TEST_C);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassNFiveMethodsWithNoDepsSample.class, SUITE_C, SUITE_C_TEST_C);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassOSixMethodsWithNoDepsSample.class, SUITE_C, SUITE_C_TEST_C);\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase7Scenario1.verifyThatMethodLevelEventsRunInDifferentThreadsFromSuiteAndTestLevelEvents",
	"Comment": "verifies that the method level events all run in different threads from the test and suite level events.",
	"Method": "void verifyThatMethodLevelEventsRunInDifferentThreadsFromSuiteAndTestLevelEvents(){\r\n    verifyEventThreadsSpawnedAfter(testListenerOnStartThreadId, testMethodLevelEventLogs, \"All the thread IDs \" + \"for the test method level events should be greater than the thread ID for the suite and test level \" + \"events. The expectation is that since the suite and test level events are running sequentially, and \" + \"all the test methods are running in parallel, new threads will be spawned after the thread \" + \"executing the suite and test level events when new methods begin executing. Suite and test level \" + \"events thread ID: \" + testListenerOnStartThreadId + \". Test method level event logs: \" + testMethodLevelEventLogs);\r\n}"
}, {
	"Path": "org.isoron.uhabits.core.models.CheckmarkList.compute",
	"Comment": "computes and stores one checkmark for each day, from the first habitrepetition to today. if this list is already computed, does nothing.",
	"Method": "void compute(){\r\n    final Timestamp today = DateUtils.getToday();\r\n    Checkmark newest = getNewestComputed();\r\n    if (newest != null && newest.getTimestamp().equals(today))\r\n        return;\r\n    invalidateNewerThan(Timestamp.ZERO);\r\n    Repetition oldestRep = habit.getRepetitions().getOldest();\r\n    if (oldestRep == null)\r\n        return;\r\n    final Timestamp from = oldestRep.getTimestamp();\r\n    Repetition[] reps = habit.getRepetitions().getByInterval(from, today).toArray(new Repetition[0]);\r\n    if (habit.isNumerical())\r\n        computeNumerical(reps);\r\n    else\r\n        computeYesNo(reps);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.cropperimage.util.HandleUtil.getOffset",
	"Comment": "calculates the offset of the touch point from the precise location of thespecified handle.",
	"Method": "Pair<Float, Float> getOffset(Handle handle,float x,float y,float left,float top,float right,float bottom){\r\n    if (handle == null) {\r\n        return null;\r\n    }\r\n    float touchOffsetX = 0;\r\n    float touchOffsetY = 0;\r\n    switch(handle) {\r\n        case TOP_LEFT:\r\n            touchOffsetX = left - x;\r\n            touchOffsetY = top - y;\r\n            break;\r\n        case TOP_RIGHT:\r\n            touchOffsetX = right - x;\r\n            touchOffsetY = top - y;\r\n            break;\r\n        case BOTTOM_LEFT:\r\n            touchOffsetX = left - x;\r\n            touchOffsetY = bottom - y;\r\n            break;\r\n        case BOTTOM_RIGHT:\r\n            touchOffsetX = right - x;\r\n            touchOffsetY = bottom - y;\r\n            break;\r\n        case LEFT:\r\n            touchOffsetX = left - x;\r\n            touchOffsetY = 0;\r\n            break;\r\n        case TOP:\r\n            touchOffsetX = 0;\r\n            touchOffsetY = top - y;\r\n            break;\r\n        case RIGHT:\r\n            touchOffsetX = right - x;\r\n            touchOffsetY = 0;\r\n            break;\r\n        case BOTTOM:\r\n            touchOffsetX = 0;\r\n            touchOffsetY = bottom - y;\r\n            break;\r\n        case CENTER:\r\n            final float centerX = (right + left) / 2;\r\n            final float centerY = (top + bottom) / 2;\r\n            touchOffsetX = centerX - x;\r\n            touchOffsetY = centerY - y;\r\n            break;\r\n    }\r\n    final Pair<Float, Float> result = new Pair<Float, Float>(touchOffsetX, touchOffsetY);\r\n    return result;\r\n}"
}, {
	"Path": "com.marshalchen.common.usefulModule.UltimateListview.setRefreshListener",
	"Comment": "set the listener when refresh is triggered and enable the swiperefreshlayout",
	"Method": "void setRefreshListener(SwipeRefreshLayout.OnRefreshListener listener){\r\n    mSwipeRefreshLayout.setEnabled(true);\r\n    mSwipeRefreshLayout.setOnRefreshListener(listener);\r\n}"
}, {
	"Path": "com.android.datetimepicker.time.RadialPickerLayout.setItem",
	"Comment": "set either the hour or the minute. will set the internal value, and set the selection.",
	"Method": "void setItem(int index,int value){\r\n    if (index == HOUR_INDEX) {\r\n        setValueForItem(HOUR_INDEX, value);\r\n        int hourDegrees = (value % 12) * HOUR_VALUE_TO_DEGREES_STEP_SIZE;\r\n        mHourRadialSelectorView.setSelection(hourDegrees, isHourInnerCircle(value), false);\r\n        mHourRadialSelectorView.invalidate();\r\n    } else if (index == MINUTE_INDEX) {\r\n        setValueForItem(MINUTE_INDEX, value);\r\n        int minuteDegrees = value * MINUTE_VALUE_TO_DEGREES_STEP_SIZE;\r\n        mMinuteRadialSelectorView.setSelection(minuteDegrees, false, false);\r\n        mMinuteRadialSelectorView.invalidate();\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.tileView.layouts.ZoomPanLayout.getDragStartThreshold",
	"Comment": "returns the minimum distance required to start a drag operation, in pixels.",
	"Method": "int getDragStartThreshold(){\r\n    return dragStartThreshold;\r\n}"
}, {
	"Path": "org.testng.TestNG.runSuitesSequentially",
	"Comment": "recursively runs suites. runs the children suites before running the parent suite. this is doneso that the results for parent suite can reflect the combined results of the children suites.",
	"Method": "void runSuitesSequentially(XmlSuite xmlSuite,SuiteRunnerMap suiteRunnerMap,int verbose,String defaultSuiteName){\r\n    for (XmlSuite childSuite : xmlSuite.getChildSuites()) {\r\n        runSuitesSequentially(childSuite, suiteRunnerMap, verbose, defaultSuiteName);\r\n    }\r\n    SuiteRunnerWorker srw = new SuiteRunnerWorker(suiteRunnerMap.get(xmlSuite), suiteRunnerMap, verbose, defaultSuiteName);\r\n    srw.run();\r\n}"
}, {
	"Path": "com.marshalchen.common.ui.ShimmerFrameLayout.setDuration",
	"Comment": "set the duration of the animation i.e. the time it will take for the highlight to move from one end of the layoutto the other.",
	"Method": "void setDuration(int duration){\r\n    mDuration = duration;\r\n    resetAll();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.titanic.TitanicTextView.createShader",
	"Comment": "create the shaderdraw the wave with current color for a backgroundrepeat the bitmap horizontally, and clamp colors vertically",
	"Method": "void createShader(){\r\n    if (wave == null) {\r\n        wave = getResources().getDrawable(R.drawable.titanic_wave_black);\r\n    }\r\n    int waveW = wave.getIntrinsicWidth();\r\n    int waveH = wave.getIntrinsicHeight();\r\n    Bitmap b = Bitmap.createBitmap(waveW, waveH, Bitmap.Config.ARGB_8888);\r\n    Canvas c = new Canvas(b);\r\n    c.drawColor(getCurrentTextColor());\r\n    wave.setBounds(0, 0, waveW, waveH);\r\n    wave.draw(c);\r\n    shader = new BitmapShader(b, Shader.TileMode.REPEAT, Shader.TileMode.CLAMP);\r\n    getPaint().setShader(shader);\r\n    offsetY = (getHeight() - waveH) / 2;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.tileView.os.AsyncTask.get",
	"Comment": "waits if necessary for at most the given time for the computationto complete, and then retrieves its result.",
	"Method": "Result get(Result get,long timeout,TimeUnit unit){\r\n    return mFuture.get(timeout, unit);\r\n}"
}, {
	"Path": "com.marshalchen.ua.common.commonUtils.fileUtils.PreferencesUtils.getFloat",
	"Comment": "get float from custom preferences with custom default value",
	"Method": "float getFloat(Context context,String key,float getFloat,Context context,String preferenceName,String key,float getFloat,Context context,String preferenceName,String key,float defaultValue){\r\n    SharedPreferences sharedPreferences = context.getSharedPreferences(preferenceName, Context.MODE_PRIVATE);\r\n    return sharedPreferences.getFloat(key, defaultValue);\r\n}"
}, {
	"Path": "test.priority.parallel.EfficientPriorityParallelizationTest2.verifyThatMethodLevelEventsRunInDifferentThreadsFromSuiteAndTestLevelEvents",
	"Comment": "verifies that the test method listener and execution events for a given test method all run in the same thread.",
	"Method": "void verifyThatMethodLevelEventsRunInDifferentThreadsFromSuiteAndTestLevelEvents(){\r\n    verifyEventThreadsSpawnedAfter(getAllSuiteListenerStartEventLogs().get(0).getThreadId(), testMethodLevelEventLogs, \"All the thread IDs for the test method level events should be greater than the thread ID for the \" + \"suite and test level events. The expectation is that since the suite and test level events \" + \"are running sequentially, and all the test methods are running in parallel, new threads \" + \"will be spawned after the thread executing the suite and test level events when new methods \" + \"begin executing. Suite and test level events thread ID: \" + getAllSuiteListenerStartEventLogs().get(0).getThreadId() + \". Test method level event logs: \" + testMethodLevelEventLogs);\r\n    verifyEventsForTestMethodsRunInTheSameThread(HighPriorityTestSample.class, SUITE_A, SUITE_A_TEST_A);\r\n    verifyEventsForTestMethodsRunInTheSameThread(LowPriorityTestSample.class, SUITE_A, SUITE_A_TEST_A);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.imageprocessing.filter.GenericFilter.setFragmentShader",
	"Comment": "sets the fragment shader to be used for this program. if this is changed during filter processing, it will\tbe updated on the next drawing pass.",
	"Method": "void setFragmentShader(String fragmentShader){\r\n    this.fragmentShader = fragmentShader;\r\n    reInitialize();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.widget.MaterialProgressDrawable.setColorSchemeColors",
	"Comment": "set the colors used in the progress animation from color resources.the first color will also be the color of the bar that grows in responseto a user swipe gesture.",
	"Method": "void setColorSchemeColors(int colors){\r\n    mRing.setColors(colors);\r\n    mRing.setColorIndex(0);\r\n}"
}, {
	"Path": "com.marshalchen.common.commonUtils.dbUtils.GreenDaoUtils.queryBuilderLazyList",
	"Comment": "executes the query and returns the result as a list that lazy loads the entities on first access. entities are cached, so accessing the same entity more than once will not result in loading an entity from the underlying cursor again.make sure to close it to close the underlying cursor.",
	"Method": "LazyList queryBuilderLazyList(AbstractDao dao,WhereCondition cond,WhereCondition condmore){\r\n    return getQueryBuilder(dao, cond, condmore).listLazy();\r\n}"
}, {
	"Path": "test.SimpleBaseTest.assertTestResultsEqual",
	"Comment": "compare a list of itestresult with a list of string method names,",
	"Method": "void assertTestResultsEqual(List<ITestResult> results,List<String> methods){\r\n    List<String> resultMethods = Lists.newArrayList();\r\n    for (ITestResult r : results) {\r\n        resultMethods.add(r.getMethod().getMethodName());\r\n    }\r\n    Assert.assertEquals(resultMethods, methods);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.easyandroidanimations.FoldLayout.calculateMatrices",
	"Comment": "calculates the transformation matrices used to draw each of the separate folding segments from this view.",
	"Method": "void calculateMatrices(){\r\n    mShouldDraw = true;\r\n    if (!mIsFoldPrepared) {\r\n        return;\r\n    }\r\n    if (mFoldFactor == 1) {\r\n        mShouldDraw = false;\r\n        return;\r\n    }\r\n    mPreviousFoldFactor = mFoldFactor;\r\n    for (int x = 0; x < mNumberOfFolds; x++) {\r\n        mMatrix[x].reset();\r\n    }\r\n    float cTranslationFactor = 1 - mFoldFactor;\r\n    float translatedDistance = mIsHorizontal ? mOriginalWidth * cTranslationFactor : mOriginalHeight * cTranslationFactor;\r\n    float translatedDistancePerFold = Math.round(translatedDistance / mNumberOfFolds);\r\n    mFoldDrawWidth = mFoldMaxWidth < translatedDistancePerFold ? translatedDistancePerFold : mFoldMaxWidth;\r\n    mFoldDrawHeight = mFoldMaxHeight < translatedDistancePerFold ? translatedDistancePerFold : mFoldMaxHeight;\r\n    float translatedDistanceFoldSquared = translatedDistancePerFold * translatedDistancePerFold;\r\n    float depth = mIsHorizontal ? (float) Math.sqrt((double) (mFoldDrawWidth * mFoldDrawWidth - translatedDistanceFoldSquared)) : (float) Math.sqrt((double) (mFoldDrawHeight * mFoldDrawHeight - translatedDistanceFoldSquared));\r\n    float scaleFactor = DEPTH_CONSTANT / (DEPTH_CONSTANT + depth);\r\n    float scaledWidth, scaledHeight, bottomScaledPoint, topScaledPoint, rightScaledPoint, leftScaledPoint;\r\n    if (mIsHorizontal) {\r\n        scaledWidth = mFoldDrawWidth * cTranslationFactor;\r\n        scaledHeight = mFoldDrawHeight * scaleFactor;\r\n    } else {\r\n        scaledWidth = mFoldDrawWidth * scaleFactor;\r\n        scaledHeight = mFoldDrawHeight * cTranslationFactor;\r\n    }\r\n    topScaledPoint = (mFoldDrawHeight - scaledHeight) / 2.0f;\r\n    bottomScaledPoint = topScaledPoint + scaledHeight;\r\n    leftScaledPoint = (mFoldDrawWidth - scaledWidth) / 2.0f;\r\n    rightScaledPoint = leftScaledPoint + scaledWidth;\r\n    float anchorPoint = mIsHorizontal ? mAnchorFactor * mOriginalWidth : mAnchorFactor * mOriginalHeight;\r\n    float midFold = mIsHorizontal ? (anchorPoint / mFoldDrawWidth) : anchorPoint / mFoldDrawHeight;\r\n    mSrc[0] = 0;\r\n    mSrc[1] = 0;\r\n    mSrc[2] = 0;\r\n    mSrc[3] = mFoldDrawHeight;\r\n    mSrc[4] = mFoldDrawWidth;\r\n    mSrc[5] = 0;\r\n    mSrc[6] = mFoldDrawWidth;\r\n    mSrc[7] = mFoldDrawHeight;\r\n    for (int x = 0; x < mNumberOfFolds; x++) {\r\n        boolean isEven = (x % 2 == 0);\r\n        if (mIsHorizontal) {\r\n            mDst[0] = (anchorPoint > x * mFoldDrawWidth) ? anchorPoint + (x - midFold) * scaledWidth : anchorPoint - (midFold - x) * scaledWidth;\r\n            mDst[1] = isEven ? 0 : topScaledPoint;\r\n            mDst[2] = mDst[0];\r\n            mDst[3] = isEven ? mFoldDrawHeight : bottomScaledPoint;\r\n            mDst[4] = (anchorPoint > (x + 1) * mFoldDrawWidth) ? anchorPoint + (x + 1 - midFold) * scaledWidth : anchorPoint - (midFold - x - 1) * scaledWidth;\r\n            mDst[5] = isEven ? topScaledPoint : 0;\r\n            mDst[6] = mDst[4];\r\n            mDst[7] = isEven ? bottomScaledPoint : mFoldDrawHeight;\r\n        } else {\r\n            mDst[0] = isEven ? 0 : leftScaledPoint;\r\n            mDst[1] = (anchorPoint > x * mFoldDrawHeight) ? anchorPoint + (x - midFold) * scaledHeight : anchorPoint - (midFold - x) * scaledHeight;\r\n            mDst[2] = isEven ? leftScaledPoint : 0;\r\n            mDst[3] = (anchorPoint > (x + 1) * mFoldDrawHeight) ? anchorPoint + (x + 1 - midFold) * scaledHeight : anchorPoint - (midFold - x - 1) * scaledHeight;\r\n            mDst[4] = isEven ? mFoldDrawWidth : rightScaledPoint;\r\n            mDst[5] = mDst[1];\r\n            mDst[6] = isEven ? rightScaledPoint : mFoldDrawWidth;\r\n            mDst[7] = mDst[3];\r\n        }\r\n        for (int y = 0; y < 8; y++) {\r\n            mDst[y] = Math.round(mDst[y]);\r\n        }\r\n        if (mIsHorizontal) {\r\n            if (mDst[4] <= mDst[0] || mDst[6] <= mDst[2]) {\r\n                mShouldDraw = false;\r\n                return;\r\n            }\r\n        } else {\r\n            if (mDst[3] <= mDst[1] || mDst[7] <= mDst[5]) {\r\n                mShouldDraw = false;\r\n                return;\r\n            }\r\n        }\r\n        mMatrix[x].setPolyToPoly(mSrc, 0, mDst, 0, NUM_OF_POLY_POINTS / 2);\r\n    }\r\n    int alpha = (int) (mFoldFactor * 255 * SHADING_ALPHA);\r\n    mSolidShadow.setColor(Color.argb(alpha, 0, 0, 0));\r\n    if (mIsHorizontal) {\r\n        mShadowGradientMatrix.setScale(mFoldDrawWidth, 1);\r\n        mShadowLinearGradient.setLocalMatrix(mShadowGradientMatrix);\r\n    } else {\r\n        mShadowGradientMatrix.setScale(1, mFoldDrawHeight);\r\n        mShadowLinearGradient.setLocalMatrix(mShadowGradientMatrix);\r\n    }\r\n    mGradientShadow.setAlpha(alpha);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.slideactivity.SlidingLayout.setCoveredFadeColor",
	"Comment": "set the color used to fade the pane covered by the sliding pane out when the panewill become fully covered in the closed state.",
	"Method": "void setCoveredFadeColor(int color){\r\n    mCoveredFadeColor = color;\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase2Scenario2.verifyOnlyOneInstanceOfTestClassForAllTestMethodsForAllSuites",
	"Comment": "verify that the same test class instance is associated with each of the test methods from the sample test class",
	"Method": "void verifyOnlyOneInstanceOfTestClassForAllTestMethodsForAllSuites(){\r\n    verifyNumberOfInstancesOfTestClassesForMethods(SUITE_A, SUITE_A_TEST_A, Arrays.asList(TestClassAFiveMethodsWithNoDepsSample.class, TestClassCSixMethodsWithNoDepsSample.class), 1);\r\n    verifySameInstancesOfTestClassesAssociatedWithMethods(SUITE_A, SUITE_A_TEST_A, Arrays.asList(TestClassAFiveMethodsWithNoDepsSample.class, TestClassCSixMethodsWithNoDepsSample.class));\r\n    verifyNumberOfInstancesOfTestClassForMethods(SUITE_B, SUITE_B_TEST_A, TestClassEFiveMethodsWithNoDepsSample.class, 1);\r\n    verifySameInstancesOfTestClassAssociatedWithMethods(SUITE_B, SUITE_B_TEST_A, TestClassEFiveMethodsWithNoDepsSample.class);\r\n    verifyNumberOfInstancesOfTestClassesForMethods(SUITE_B, SUITE_B_TEST_B, Arrays.asList(TestClassDThreeMethodsWithNoDepsSample.class, TestClassBFourMethodsWithNoDepsSample.class, TestClassFSixMethodsWithNoDepsSample.class), 1);\r\n    verifySameInstancesOfTestClassesAssociatedWithMethods(SUITE_B, SUITE_B_TEST_B, Arrays.asList(TestClassDThreeMethodsWithNoDepsSample.class, TestClassBFourMethodsWithNoDepsSample.class, TestClassFSixMethodsWithNoDepsSample.class));\r\n    verifyNumberOfInstancesOfTestClassesForMethods(SUITE_C, SUITE_C_TEST_A, Arrays.asList(TestClassGThreeMethodsWithNoDepsSample.class, TestClassHFourMethodsWithNoDepsSample.class, TestClassIFiveMethodsWithNoDepsSample.class), 1);\r\n    verifySameInstancesOfTestClassesAssociatedWithMethods(SUITE_C, SUITE_C_TEST_A, Arrays.asList(TestClassGThreeMethodsWithNoDepsSample.class, TestClassHFourMethodsWithNoDepsSample.class, TestClassIFiveMethodsWithNoDepsSample.class));\r\n    verifyNumberOfInstancesOfTestClassesForMethods(SUITE_C, SUITE_C_TEST_B, Arrays.asList(TestClassJFourMethodsWithNoDepsSample.class, TestClassKFiveMethodsWithNoDepsSample.class), 1);\r\n    verifySameInstancesOfTestClassesAssociatedWithMethods(SUITE_C, SUITE_C_TEST_B, Arrays.asList(TestClassJFourMethodsWithNoDepsSample.class, TestClassKFiveMethodsWithNoDepsSample.class));\r\n    verifyNumberOfInstancesOfTestClassesForMethods(SUITE_C, SUITE_C_TEST_C, Arrays.asList(TestClassLThreeMethodsWithNoDepsSample.class, TestClassMFourMethodsWithNoDepsSample.class, TestClassNFiveMethodsWithNoDepsSample.class, TestClassOSixMethodsWithNoDepsSample.class), 1);\r\n    verifySameInstancesOfTestClassesAssociatedWithMethods(SUITE_C, SUITE_C_TEST_C, Arrays.asList(TestClassLThreeMethodsWithNoDepsSample.class, TestClassMFourMethodsWithNoDepsSample.class, TestClassNFiveMethodsWithNoDepsSample.class, TestClassOSixMethodsWithNoDepsSample.class));\r\n}"
}, {
	"Path": "org.isoron.uhabits.core.ui.screens.habits.list.HabitCardListCache.getHabitByPosition",
	"Comment": "returns the habits that occupies a certain position on the list.",
	"Method": "Habit getHabitByPosition(int position){\r\n    if (position < 0 || position >= data.habits.size())\r\n        return null;\r\n    return data.habits.get(position);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.rippleDrawable.Ripple.cancel",
	"Comment": "cancels all animations. the caller is responsible for removingthe ripple from the list of animating ripples.",
	"Method": "void cancel(){\r\n    mCanceled = true;\r\n    cancelSoftwareAnimations();\r\n    mCanceled = false;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.rebound.Spring.systemShouldAdvance",
	"Comment": "check if this spring should be advanced by the system. the rule is if the spring iscurrently at rest and it was at rest in the previous advance, the system can skip this spring",
	"Method": "boolean systemShouldAdvance(){\r\n    return !isAtRest() || !wasAtRest();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.freeflow.core.FreeFlowContainer.computeLayout",
	"Comment": "the heart of the system. calls the layout to get the frames needed,\tdecides which view should be kept in focus if view transitions are going\tto happen and then kicks off animation changes if things have changed",
	"Method": "void computeLayout(int w,int h){\r\n    markLayoutDirty = false;\r\n    markAdapterDirty = false;\r\n    mLayout.prepareLayout();\r\n    if (shouldRecalculateScrollWhenComputingLayout) {\r\n        computeViewPort(mLayout);\r\n    }\r\n    Map<Object, FreeFlowItem> oldFrames = frames;\r\n    frames = new LinkedHashMap<Object, FreeFlowItem>();\r\n    copyFrames(mLayout.getItemProxies(viewPortX, viewPortY), frames);\r\n    dispatchLayoutComputed();\r\n    animateChanges(getViewChanges(oldFrames, frames));\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.staggeredgridview.ExtendableListView.getChildTop",
	"Comment": "override to set you custom listviews child to a specific top location",
	"Method": "int getChildTop(int position){\r\n    int count = getChildCount();\r\n    int paddingTop = 0;\r\n    if (mClipToPadding) {\r\n        paddingTop = getListPaddingTop();\r\n    }\r\n    return count > 0 ? getChildAt(count - 1).getBottom() : paddingTop;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.cropperimage.CropImageView.rotateImage",
	"Comment": "rotates image by the specified number of degrees clockwise. cycles from 0 to 360degrees.",
	"Method": "void rotateImage(int degrees){\r\n    Matrix matrix = new Matrix();\r\n    matrix.postRotate(degrees);\r\n    mBitmap = Bitmap.createBitmap(mBitmap, 0, 0, mBitmap.getWidth(), mBitmap.getHeight(), matrix, true);\r\n    setImageBitmap(mBitmap);\r\n    mDegreesRotated += degrees;\r\n    mDegreesRotated = mDegreesRotated % 360;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.listviewanimations.itemmanipulation.ExpandableListItemAdapter.isExpanded",
	"Comment": "indicates if the item at the specified position is expanded.",
	"Method": "boolean isExpanded(int position){\r\n    long itemId = getItemId(position);\r\n    return mExpandedIds.contains(itemId);\r\n}"
}, {
	"Path": "org.testng.xml.XmlSuite.getTimeOut",
	"Comment": "returns the timeout as a long value specifying the default value to be used if no timeout wasspecified.",
	"Method": "String getTimeOut(long getTimeOut,long def){\r\n    long result = def;\r\n    if (m_timeOut != null) {\r\n        result = Long.parseLong(m_timeOut);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.simplemodule.HoloCircularProgressBar.updateProgressColor",
	"Comment": "updates the paint of the progress and the thumb to give them a new visual\tstyle",
	"Method": "void updateProgressColor(){\r\n    mProgressColorPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\r\n    mProgressColorPaint.setColor(mProgressColor);\r\n    mProgressColorPaint.setStyle(Paint.Style.STROKE);\r\n    mProgressColorPaint.setStrokeWidth(mCircleStrokeWidth);\r\n    mThumbColorPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\r\n    mThumbColorPaint.setColor(mProgressColor);\r\n    mThumbColorPaint.setStyle(Paint.Style.FILL_AND_STROKE);\r\n    mThumbColorPaint.setStrokeWidth(mCircleStrokeWidth);\r\n    invalidate();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.tileView.tileview.TileView.resetDetailLevels",
	"Comment": "clear all previously registered zoom levels.this method is experimental.",
	"Method": "void resetDetailLevels(){\r\n    detailManager.resetDetailLevels();\r\n    refresh();\r\n}"
}, {
	"Path": "com.android.datetimepicker.date.DayPickerView.refreshAdapter",
	"Comment": "creates a new adapter if necessary and sets up its parameters. overridethis method to provide a custom adapter.",
	"Method": "void refreshAdapter(){\r\n    if (mAdapter == null) {\r\n        mAdapter = createMonthAdapter(getContext(), mController);\r\n    } else {\r\n        mAdapter.setSelectedDay(mSelectedDay);\r\n    }\r\n    setAdapter(mAdapter);\r\n}"
}, {
	"Path": "org.isoron.uhabits.core.models.ScoreList.computeAll",
	"Comment": "computes and saves the scores that are missing since the first repetitionof the habit.",
	"Method": "void computeAll(){\r\n    Repetition oldestRep = habit.getRepetitions().getOldest();\r\n    if (oldestRep == null)\r\n        return;\r\n    Timestamp today = DateUtils.getToday();\r\n    compute(oldestRep.getTimestamp(), today);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.rebound.Spring.setRestSpeedThreshold",
	"Comment": "sets the speed at which the spring should be considered at rest.",
	"Method": "Spring setRestSpeedThreshold(double restSpeedThreshold){\r\n    mRestSpeedThreshold = restSpeedThreshold;\r\n    return this;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.cropperimage.cropwindow.CropOverlayView.showGuidelines",
	"Comment": "indicates whether the crop window is small enough that the guidelinesshould be shown. public because this function is also used to determineif the center handle should be focused.",
	"Method": "boolean showGuidelines(){\r\n    if ((Math.abs(Edge.LEFT.getCoordinate() - Edge.RIGHT.getCoordinate()) < DEFAULT_SHOW_GUIDELINES_LIMIT) || (Math.abs(Edge.TOP.getCoordinate() - Edge.BOTTOM.getCoordinate()) < DEFAULT_SHOW_GUIDELINES_LIMIT))\r\n        return false;\r\n    else\r\n        return true;\r\n}"
}, {
	"Path": "com.marshalchen.common.ui.ShimmerFrameLayout.getFixedWidth",
	"Comment": "get the fixed width of the highlight mask, or 0 if it is not set. by default it is 0.",
	"Method": "int getFixedWidth(){\r\n    return mMask.fixedWidth;\r\n}"
}, {
	"Path": "org.testng.internal.DynamicGraphTest.testLotsOfEdges",
	"Comment": "inefficient algorithms within dynamicgraph can quickly make the execution time explode. thistest puts some minimal limits on the time it takes to process the graph. at the time of theaddition of this test, it took less than 100ms to execute. 2000ms gives enough headroom toprevent flaky failures because of external conditions such as slower or lower cpu resources.",
	"Method": "void testLotsOfEdges(){\r\n    TestNG tng = create(LotsOfEdgesTest.class);\r\n    InvokedMethodNameListener listener = new InvokedMethodNameListener();\r\n    tng.addListener(listener);\r\n    tng.run();\r\n}"
}, {
	"Path": "org.testng.junit.JUnitTestRunner.start",
	"Comment": "starts a test run. analyzes the command line arguments and runs the given test suite.",
	"Method": "TestResult start(Class testCase,String methods){\r\n    try {\r\n        Test suite = getTest(testCase, methods);\r\n        if (null != suite) {\r\n            return doRun(suite);\r\n        } else {\r\n            runFailed(testCase, \"could not create/run JUnit test suite\");\r\n        }\r\n    } catch (Exception e) {\r\n        runFailed(testCase, \"could not create/run JUnit test suite: \" + e.getMessage());\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.isoron.uhabits.core.database.Repository.executeAsTransaction",
	"Comment": "executes the given callback inside a database transaction.if the callback terminates without throwing any exceptions, thetransaction is considered successful. if any exceptions are thrown,the transaction is aborted. nesting transactions is not allowed.",
	"Method": "void executeAsTransaction(Runnable callback){\r\n    db.beginTransaction();\r\n    try {\r\n        callback.run();\r\n        db.setTransactionSuccessful();\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e);\r\n    } finally {\r\n        db.endTransaction();\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.ui.ShimmerFrameLayout.setFixedHeight",
	"Comment": "set the fixed height of the highlight mask, regardless of the size of the layout.",
	"Method": "void setFixedHeight(int fixedHeight){\r\n    mMask.fixedHeight = fixedHeight;\r\n    resetAll();\r\n}"
}, {
	"Path": "com.marshalchen.common.ui.DropDownListView.onBottom",
	"Comment": "on bottom loading, you can call it by manual, but you should manual call onbottomcomplete at the same time.",
	"Method": "void onBottom(){\r\n    if (isOnBottomStyle && !isOnBottomLoading) {\r\n        isOnBottomLoading = true;\r\n        onBottomBegin();\r\n        footerButton.performClick();\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.slider.Tricks.ViewPagerEx.setInternalPageChangeListener",
	"Comment": "set a separate onpagechangelistener for internal use by the support library.",
	"Method": "OnPageChangeListener setInternalPageChangeListener(OnPageChangeListener listener){\r\n    OnPageChangeListener oldListener = mInternalPageChangeListener;\r\n    mInternalPageChangeListener = listener;\r\n    return oldListener;\r\n}"
}, {
	"Path": "com.marshalchen.common.DiskLruCache.DiskLruCache.journalRebuildRequired",
	"Comment": "we only rebuild the journal when it will halve the size of the journaland eliminate at least 2000 ops.",
	"Method": "boolean journalRebuildRequired(){\r\n    final int redundantOpCompactThreshold = 2000;\r\n    return redundantOpCount >= redundantOpCompactThreshold && redundantOpCount >= lruEntries.size();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.staggeredgridview.ExtendableListView.getChildLeft",
	"Comment": "override to set you custom listviews child to a specific left location",
	"Method": "int getChildLeft(int position){\r\n    return getListPaddingLeft();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.foldingLayout.BaseFoldingLayout.throwCustomException",
	"Comment": "throws an exception if the number of views added to this layout exceedsone.",
	"Method": "void throwCustomException(int numOfChildViews){\r\n    if (numOfChildViews == 1) {\r\n        throw new NumberOfFoldingLayoutChildrenException(FOLDING_VIEW_EXCEPTION_MESSAGE);\r\n    }\r\n}"
}, {
	"Path": "org.testng.reporters.FailedReporter.findMethodLocalParameters",
	"Comment": "get local parameters of one include method from origin test xml.",
	"Method": "Map<String, String> findMethodLocalParameters(XmlTest srcXmlTest,ITestNGMethod method){\r\n    Class clazz = method.getRealClass();\r\n    for (XmlClass c : srcXmlTest.getClasses()) {\r\n        if (clazz == c.getSupportClass()) {\r\n            for (XmlInclude xmlInclude : c.getIncludedMethods()) {\r\n                if (xmlInclude.getName().equals(method.getMethodName())) {\r\n                    return xmlInclude.getLocalParameters();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return Collections.emptyMap();\r\n}"
}, {
	"Path": "org.isoron.uhabits.core.ui.screens.habits.list.HintList.pop",
	"Comment": "returns a new hint to be shown to the user.the hint returned is marked as read on the list, and will not be returnedagain. in case all hints have already been read, and there is nothingleft, returns null.",
	"Method": "String pop(){\r\n    int next = prefs.getLastHintNumber() + 1;\r\n    if (next >= hints.length)\r\n        return null;\r\n    prefs.updateLastHint(next, DateUtils.getToday());\r\n    return hints[next];\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.recyclerplayground.layout.StaticGridLayoutManager.scrollHorizontallyBy",
	"Comment": "this method describes how far recyclerview thinks the contents should scroll horizontally.you are responsible for verifying edge boundaries, and determining if this scrollevent somehow requires that new views be added or old views get recycled.",
	"Method": "int scrollHorizontallyBy(int dx,RecyclerView.Recycler recycler,RecyclerView.State state){\r\n    if (getChildCount() == 0) {\r\n        return 0;\r\n    }\r\n    final View topView = getChildAt(0);\r\n    final View bottomView = getChildAt(mVisibleColumnCount - 1);\r\n    int viewSpan = getDecoratedRight(bottomView) - getDecoratedLeft(topView);\r\n    if (viewSpan <= getHorizontalSpace()) {\r\n        return 0;\r\n    }\r\n    int delta;\r\n    boolean leftBoundReached = getFirstVisibleColumn() == 0;\r\n    boolean rightBoundReached = getLastVisibleColumn() >= getTotalColumnCount();\r\n    if (dx > 0) {\r\n        if (rightBoundReached) {\r\n            int rightOffset = getHorizontalSpace() - getDecoratedRight(bottomView) + getPaddingRight();\r\n            delta = Math.max(-dx, rightOffset);\r\n        } else {\r\n            delta = -dx;\r\n        }\r\n    } else {\r\n        if (leftBoundReached) {\r\n            int leftOffset = -getDecoratedLeft(topView) + getPaddingLeft();\r\n            delta = Math.min(-dx, leftOffset);\r\n        } else {\r\n            delta = -dx;\r\n        }\r\n    }\r\n    offsetChildrenHorizontal(delta);\r\n    if (dx > 0) {\r\n        if (getDecoratedRight(topView) < 0 && !rightBoundReached) {\r\n            fillGrid(DIRECTION_END, recycler);\r\n        } else if (!rightBoundReached) {\r\n            fillGrid(DIRECTION_NONE, recycler);\r\n        }\r\n    } else {\r\n        if (getDecoratedLeft(topView) > 0 && !leftBoundReached) {\r\n            fillGrid(DIRECTION_START, recycler);\r\n        } else if (!leftBoundReached) {\r\n            fillGrid(DIRECTION_NONE, recycler);\r\n        }\r\n    }\r\n    return -delta;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.gesturedetectors.RotateGestureDetector.getRotationDegreesDelta",
	"Comment": "return the rotation difference from the previous rotate event to the currentevent.",
	"Method": "float getRotationDegreesDelta(){\r\n    double diffRadians = Math.atan2(mPrevFingerDiffY, mPrevFingerDiffX) - Math.atan2(mCurrFingerDiffY, mCurrFingerDiffX);\r\n    return (float) (diffRadians * 180 / Math.PI);\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.easyandroidanimations.AnimationDetailFragment.onViewCreated",
	"Comment": "this method is prevents any padding from obstructing the animations.",
	"Method": "void onViewCreated(View view,Bundle savedInstanceState){\r\n    super.onViewCreated(view, savedInstanceState);\r\n    ViewGroup vg = (ViewGroup) view;\r\n    vg.setClipToPadding(false);\r\n}"
}, {
	"Path": "org.isoron.uhabits.core.models.ModelObservable.removeListener",
	"Comment": "removes the given listener.the listener will no longer be notified when the model changes. if thegiven listener is not subscribed to this observable, does nothing.",
	"Method": "void removeListener(Listener l){\r\n    listeners.remove(l);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.animation.ValueAnimator.getDuration",
	"Comment": "gets the length of the animation. the default duration is 300 milliseconds.",
	"Method": "long getDuration(){\r\n    return mDuration;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.modifysys.ViewPager.setAdapter",
	"Comment": "set a pageradapter that will supply views for this pager as needed.",
	"Method": "void setAdapter(PagerAdapter adapter){\r\n    if (mAdapter != null) {\r\n        mAdapter.unregisterDataSetObserver(mObserver);\r\n        mAdapter.startUpdate(this);\r\n        for (int i = 0; i < mItems.size(); i++) {\r\n            final ItemInfo ii = mItems.get(i);\r\n            mAdapter.destroyItem(this, ii.position, ii.object);\r\n        }\r\n        mAdapter.finishUpdate(this);\r\n        mItems.clear();\r\n        removeNonDecorViews();\r\n        mCurItem = 0;\r\n        scrollTo(0, 0);\r\n    }\r\n    final PagerAdapter oldAdapter = mAdapter;\r\n    mAdapter = adapter;\r\n    mExpectedAdapterCount = 0;\r\n    if (mAdapter != null) {\r\n        if (mObserver == null) {\r\n            mObserver = new PagerObserver();\r\n        }\r\n        mAdapter.registerDataSetObserver(mObserver);\r\n        mPopulatePending = false;\r\n        final boolean wasFirstLayout = mFirstLayout;\r\n        mFirstLayout = true;\r\n        mExpectedAdapterCount = mAdapter.getCount();\r\n        if (mRestoredCurItem >= 0) {\r\n            mAdapter.restoreState(mRestoredAdapterState, mRestoredClassLoader);\r\n            setCurrentItemInternal(mRestoredCurItem, false, true);\r\n            mRestoredCurItem = -1;\r\n            mRestoredAdapterState = null;\r\n            mRestoredClassLoader = null;\r\n        } else if (!wasFirstLayout) {\r\n            populate();\r\n        } else {\r\n            requestLayout();\r\n        }\r\n    }\r\n    if (mAdapterChangeListener != null && oldAdapter != adapter) {\r\n        mAdapterChangeListener.onAdapterChanged(oldAdapter, adapter);\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.slideExpand.AbstractSlideExpandableListAdapter.collapseLastOpen",
	"Comment": "closes the current open item.if it is current visible it will be closed with an animation.",
	"Method": "boolean collapseLastOpen(){\r\n    if (isAnyItemExpanded()) {\r\n        Logs.d(\"11111111111\");\r\n        if (lastOpen != null) {\r\n            animateView(lastOpen, ExpandCollapseAnimation.COLLAPSE);\r\n        }\r\n        openItems.set(lastOpenPosition, false);\r\n        lastOpenPosition = -1;\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase5Scenario1.verifyTwoInstancesOfTestClassForAllTestMethods",
	"Comment": "verify that the same test class instances are associated with each of the test methods from the sample test class",
	"Method": "void verifyTwoInstancesOfTestClassForAllTestMethods(){\r\n    verifyNumberOfInstancesOfTestClassForMethods(SUITE, TEST, TestClassAFiveMethodsWithNoDepsSample.class, 2);\r\n    verifySameInstancesOfTestClassAssociatedWithMethods(SUITE, TEST, TestClassAFiveMethodsWithNoDepsSample.class);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.modifysys.ViewPager.getOffscreenPageLimit",
	"Comment": "returns the number of pages that will be retained to either side of thecurrent page in the view hierarchy in an idle state. defaults to 1.",
	"Method": "int getOffscreenPageLimit(){\r\n    return mOffscreenPageLimit;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.dynamicgrid.DynamicGridUtils.reorder",
	"Comment": "delete item in list from position indexfrom and insert it to indextwo",
	"Method": "void reorder(ArrayList list,int indexFrom,int indexTwo){\r\n    Object obj = list.remove(indexFrom);\r\n    list.add(indexTwo, obj);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.flipViews.flipview.Recycler.addScrapView",
	"Comment": "put a view into the scrapviews list. these views are unordered.",
	"Method": "void addScrapView(View scrap,int position,int viewType){\r\n    Scrap item = new Scrap(scrap, true);\r\n    if (viewTypeCount == 1) {\r\n        currentScraps.put(position, item);\r\n    } else {\r\n        scraps[viewType].put(position, item);\r\n    }\r\n    if (Build.VERSION.SDK_INT >= 14) {\r\n        scrap.setAccessibilityDelegate(null);\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.dragSortListView.DragSortListView.stopDrag",
	"Comment": "stop a drag in progress. pass true if you wouldlike to remove the dragged item from the list.",
	"Method": "boolean stopDrag(boolean remove,boolean stopDrag,boolean remove,float velocityX){\r\n    if (mFloatView != null) {\r\n        mDragScroller.stopScrolling(true);\r\n        if (remove) {\r\n            removeItem(mSrcPos - getHeaderViewsCount(), velocityX);\r\n        } else {\r\n            if (mDropAnimator != null) {\r\n                mDropAnimator.start();\r\n            } else {\r\n                dropFloatView();\r\n            }\r\n        }\r\n        if (mTrackDragSort) {\r\n            mDragSortTracker.stopTracking();\r\n        }\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.animation.Animator.addListener",
	"Comment": "adds a listener to the set of listeners that are sent events through the life of ananimation, such as start, repeat, and end.",
	"Method": "void addListener(AnimatorListener listener){\r\n    if (mListeners == null) {\r\n        mListeners = new ArrayList<AnimatorListener>();\r\n    }\r\n    mListeners.add(listener);\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase6Scenario1.verifyNumberOfInstanceOfTestClassForAllTestMethodsForAllSuites",
	"Comment": "verify that the same test class instances are associated with each of the test methods from the sample test class",
	"Method": "void verifyNumberOfInstanceOfTestClassForAllTestMethodsForAllSuites(){\r\n    verifyNumberOfInstancesOfTestClassesForMethods(SUITE_A, SUITE_A_TEST_A, Arrays.asList(TestClassAFiveMethodsWithNoDepsSample.class, TestClassCSixMethodsWithNoDepsSample.class), 2, 3);\r\n    verifySameInstancesOfTestClassesAssociatedWithMethods(SUITE_A, SUITE_A_TEST_A, Arrays.asList(TestClassAFiveMethodsWithNoDepsSample.class, TestClassCSixMethodsWithNoDepsSample.class));\r\n    verifyNumberOfInstancesOfTestClassForMethods(SUITE_B, SUITE_B_TEST_A, TestClassEFiveMethodsWithNoDepsSample.class, 1);\r\n    verifySameInstancesOfTestClassAssociatedWithMethods(SUITE_B, SUITE_B_TEST_A, TestClassEFiveMethodsWithNoDepsSample.class);\r\n    verifyNumberOfInstancesOfTestClassesForMethods(SUITE_B, SUITE_B_TEST_B, Arrays.asList(TestClassDThreeMethodsWithNoDepsSample.class, TestClassBFourMethodsWithNoDepsSample.class, TestClassFSixMethodsWithNoDepsSample.class), 4, 5, 6);\r\n    verifySameInstancesOfTestClassesAssociatedWithMethods(SUITE_B, SUITE_B_TEST_B, Arrays.asList(TestClassDThreeMethodsWithNoDepsSample.class, TestClassBFourMethodsWithNoDepsSample.class, TestClassFSixMethodsWithNoDepsSample.class));\r\n    verifyNumberOfInstancesOfTestClassesForMethods(SUITE_C, SUITE_C_TEST_A, Arrays.asList(TestClassGThreeMethodsWithNoDepsSample.class, TestClassHFourMethodsWithNoDepsSample.class, TestClassIFiveMethodsWithNoDepsSample.class), 1);\r\n    verifySameInstancesOfTestClassesAssociatedWithMethods(SUITE_C, SUITE_C_TEST_A, Arrays.asList(TestClassGThreeMethodsWithNoDepsSample.class, TestClassHFourMethodsWithNoDepsSample.class, TestClassIFiveMethodsWithNoDepsSample.class));\r\n    verifyNumberOfInstancesOfTestClassesForMethods(SUITE_C, SUITE_C_TEST_B, Arrays.asList(TestClassJFourMethodsWithNoDepsSample.class, TestClassKFiveMethodsWithNoDepsSample.class), 1);\r\n    verifySameInstancesOfTestClassesAssociatedWithMethods(SUITE_C, SUITE_C_TEST_B, Arrays.asList(TestClassJFourMethodsWithNoDepsSample.class, TestClassKFiveMethodsWithNoDepsSample.class));\r\n    verifyNumberOfInstancesOfTestClassesForMethods(SUITE_C, SUITE_C_TEST_C, Arrays.asList(TestClassLThreeMethodsWithNoDepsSample.class, TestClassMFourMethodsWithNoDepsSample.class, TestClassNFiveMethodsWithNoDepsSample.class, TestClassOSixMethodsWithNoDepsSample.class), 1);\r\n    verifySameInstancesOfTestClassesAssociatedWithMethods(SUITE_C, SUITE_C_TEST_C, Arrays.asList(TestClassLThreeMethodsWithNoDepsSample.class, TestClassMFourMethodsWithNoDepsSample.class, TestClassNFiveMethodsWithNoDepsSample.class, TestClassOSixMethodsWithNoDepsSample.class));\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.recyclerplayground.layout.FixedGridLayoutManager.canScrollHorizontally",
	"Comment": "use this method to tell the recyclerview if scrolling is even possiblein the horizontal direction.",
	"Method": "boolean canScrollHorizontally(){\r\n    return true;\r\n}"
}, {
	"Path": "org.testng.reporters.EmailableReporter2.writeScenarioDetails",
	"Comment": "writes the scenario details for the results of a given state for a single test.",
	"Method": "void writeScenarioDetails(int writeScenarioDetails,List<ClassResult> classResults,int startingScenarioIndex){\r\n    int scenarioIndex = startingScenarioIndex;\r\n    for (ClassResult classResult : classResults) {\r\n        String className = classResult.getClassName();\r\n        for (MethodResult methodResult : classResult.getMethodResults()) {\r\n            List<ITestResult> results = methodResult.getResults();\r\n            assert !results.isEmpty();\r\n            String label = Utils.escapeHtml(className + \"#\" + results.iterator().next().getMethod().getMethodName());\r\n            for (ITestResult result : results) {\r\n                writeScenario(scenarioIndex, label, result);\r\n                scenarioIndex++;\r\n            }\r\n        }\r\n    }\r\n    return scenarioIndex - startingScenarioIndex;\r\n}"
}, {
	"Path": "test.sanitycheck.CheckTestNamesTest.checkTestNamesForProgrammaticSuites",
	"Comment": "checks that suites created programmatically also run as expected",
	"Method": "void checkTestNamesForProgrammaticSuites(){\r\n    XmlSuite xmlSuite = new XmlSuite();\r\n    xmlSuite.setName(\"SanityCheckSuite\");\r\n    XmlTest result = new XmlTest(xmlSuite);\r\n    result.getXmlClasses().add(new XmlClass(SampleTest1.class.getCanonicalName()));\r\n    result = new XmlTest(xmlSuite);\r\n    result.getXmlClasses().add(new XmlClass(SampleTest2.class.getCanonicalName()));\r\n    TestNG tng = new TestNG();\r\n    tng.setVerbose(0);\r\n    tng.setXmlSuites(Collections.singletonList(xmlSuite));\r\n    tng.run();\r\n}"
}, {
	"Path": "org.isoron.uhabits.core.database.Repository.execSQL",
	"Comment": "executes the given sql query on the repository.the query can be of any kind. for example, complex deletes and updatesare allowed. the repository does not perform any checks to guaranteethat the query is valid, however the underlying database might.",
	"Method": "void execSQL(String query,Object params){\r\n    db.execute(query, params);\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.recyclerplayground.layout.StaticGridLayoutManager.getGlobalColumnOfPosition",
	"Comment": "return the overall column index of this position in the global layout",
	"Method": "int getGlobalColumnOfPosition(int position){\r\n    return position % getTotalColumnCount();\r\n}"
}, {
	"Path": "test.CheckSuitesInitializationTest.check",
	"Comment": "child suites and tests within different suites have same names",
	"Method": "void check(){\r\n    TestListenerAdapter tla = new TestListenerAdapter();\r\n    TestNG tng = create();\r\n    String testngXmlPath = getPathToResource(\"checksuitesinitialization/parent-suite.xml\");\r\n    tng.setTestSuites(Collections.singletonList(testngXmlPath));\r\n    tng.addListener(tla);\r\n    tng.run();\r\n    Assert.assertEquals(tla.getPassedTests().size(), 4);\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase8Scenario1.verifyNumberOfInstanceOfTestClassForAllTestMethodsForAllSuites",
	"Comment": "verify that the same test class instances are associated with each of the test methods from the sample test class",
	"Method": "void verifyNumberOfInstanceOfTestClassForAllTestMethodsForAllSuites(){\r\n    verifyNumberOfInstancesOfTestClassesForMethods(SUITE_A, SUITE_A_TEST_A, Arrays.asList(TestClassAFiveMethodsWithFactoryUsingDataProviderAndNoDepsSample.class, TestClassCSixMethodsWithFactoryUsingDataProviderAndNoDepsSample.class), 3, 4);\r\n    verifySameInstancesOfTestClassesAssociatedWithMethods(SUITE_A, SUITE_A_TEST_A, Arrays.asList(TestClassAFiveMethodsWithFactoryUsingDataProviderAndNoDepsSample.class, TestClassCSixMethodsWithFactoryUsingDataProviderAndNoDepsSample.class));\r\n    verifyNumberOfInstancesOfTestClassForMethods(SUITE_B, SUITE_B_TEST_A, TestClassEFiveMethodsWithNoDepsSample.class, 1);\r\n    verifySameInstancesOfTestClassAssociatedWithMethods(SUITE_B, SUITE_B_TEST_A, TestClassEFiveMethodsWithNoDepsSample.class);\r\n    verifyNumberOfInstancesOfTestClassesForMethods(SUITE_B, SUITE_B_TEST_B, Arrays.asList(TestClassDThreeMethodsWithFactoryUsingDataProviderAndNoDepsSample.class, TestClassBFourMethodsWithFactoryUsingDataProviderAndNoDepsSample.class, TestClassFSixMethodsWithFactoryUsingDataProviderAndNoDepsSample.class), 4, 4, 4);\r\n    verifySameInstancesOfTestClassesAssociatedWithMethods(SUITE_B, SUITE_B_TEST_B, Arrays.asList(TestClassDThreeMethodsWithFactoryUsingDataProviderAndNoDepsSample.class, TestClassBFourMethodsWithFactoryUsingDataProviderAndNoDepsSample.class, TestClassFSixMethodsWithFactoryUsingDataProviderAndNoDepsSample.class));\r\n    verifyNumberOfInstancesOfTestClassesForMethods(SUITE_C, SUITE_C_TEST_A, Arrays.asList(TestClassGThreeMethodsWithNoDepsSample.class, TestClassHFourMethodsWithNoDepsSample.class, TestClassIFiveMethodsWithNoDepsSample.class), 1);\r\n    verifySameInstancesOfTestClassesAssociatedWithMethods(SUITE_C, SUITE_C_TEST_A, Arrays.asList(TestClassGThreeMethodsWithNoDepsSample.class, TestClassHFourMethodsWithNoDepsSample.class, TestClassIFiveMethodsWithNoDepsSample.class));\r\n    verifyNumberOfInstancesOfTestClassesForMethods(SUITE_C, SUITE_C_TEST_B, Arrays.asList(TestClassJFourMethodsWithNoDepsSample.class, TestClassKFiveMethodsWithNoDepsSample.class), 1);\r\n    verifySameInstancesOfTestClassesAssociatedWithMethods(SUITE_C, SUITE_C_TEST_B, Arrays.asList(TestClassJFourMethodsWithNoDepsSample.class, TestClassKFiveMethodsWithNoDepsSample.class));\r\n    verifyNumberOfInstancesOfTestClassesForMethods(SUITE_C, SUITE_C_TEST_C, Arrays.asList(TestClassLThreeMethodsWithNoDepsSample.class, TestClassMFourMethodsWithNoDepsSample.class, TestClassNFiveMethodsWithNoDepsSample.class, TestClassOSixMethodsWithNoDepsSample.class), 1);\r\n    verifySameInstancesOfTestClassesAssociatedWithMethods(SUITE_C, SUITE_C_TEST_C, Arrays.asList(TestClassLThreeMethodsWithNoDepsSample.class, TestClassMFourMethodsWithNoDepsSample.class, TestClassNFiveMethodsWithNoDepsSample.class, TestClassOSixMethodsWithNoDepsSample.class));\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.tileView.layouts.ZoomPanLayout.addGestureListener",
	"Comment": "adds a gesturelistener to the zoompanlayout, which will receive gesture events",
	"Method": "boolean addGestureListener(GestureListener listener){\r\n    return gestureListeners.add(listener);\r\n}"
}, {
	"Path": "com.android.datetimepicker.time.RadialTextsView.calculateGridSizes",
	"Comment": "using the trigonometric unit circle, calculate the positions that the text will need to bedrawn at based on the specified circle radius. place the values in the textgridheights andtextgridwidths parameters.",
	"Method": "void calculateGridSizes(float numbersRadius,float xCenter,float yCenter,float textSize,float[] textGridHeights,float[] textGridWidths){\r\n    float offset1 = numbersRadius;\r\n    float offset2 = numbersRadius * ((float) Math.sqrt(3)) / 2f;\r\n    float offset3 = numbersRadius / 2f;\r\n    mPaint.setTextSize(textSize);\r\n    yCenter -= (mPaint.descent() + mPaint.ascent()) / 2;\r\n    textGridHeights[0] = yCenter - offset1;\r\n    textGridWidths[0] = xCenter - offset1;\r\n    textGridHeights[1] = yCenter - offset2;\r\n    textGridWidths[1] = xCenter - offset2;\r\n    textGridHeights[2] = yCenter - offset3;\r\n    textGridWidths[2] = xCenter - offset3;\r\n    textGridHeights[3] = yCenter;\r\n    textGridWidths[3] = xCenter;\r\n    textGridHeights[4] = yCenter + offset3;\r\n    textGridWidths[4] = xCenter + offset3;\r\n    textGridHeights[5] = yCenter + offset2;\r\n    textGridWidths[5] = xCenter + offset2;\r\n    textGridHeights[6] = yCenter + offset1;\r\n    textGridWidths[6] = xCenter + offset1;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.listviewanimations.swinginadapters.AnimationAdapter.setHasParentAnimationAdapter",
	"Comment": "set whether this animationadapter is encapsulated by anotheranimationadapter. when this is set to true, this animationadapter doesnot apply any animations to the views. should not be set explicitly, theanimationadapter class manages this by itself.",
	"Method": "void setHasParentAnimationAdapter(boolean hasParentAnimationAdapter){\r\n    mHasParentAnimationAdapter = hasParentAnimationAdapter;\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase1Scenario2.verifyThatMethodLevelEventsRunInDifferentThreadsFromSuiteAndTestLevelEvents",
	"Comment": "verifies that the test method listener and execution events for a given test method all run in the same thread.",
	"Method": "void verifyThatMethodLevelEventsRunInDifferentThreadsFromSuiteAndTestLevelEvents(){\r\n    verifyEventThreadsSpawnedAfter(getAllSuiteListenerStartEventLogs().get(0).getThreadId(), testMethodLevelEventLogs, \"All the thread IDs for the test method level events should be greater than the thread ID for the \" + \"suite and test level events. The expectation is that since the suite and test level events \" + \"are running sequentially, and all the test methods are running in parallel, new threads \" + \"will be spawned after the thread executing the suite and test level events when new methods \" + \"begin executing. Suite and test level events thread ID: \" + getAllSuiteListenerStartEventLogs().get(0).getThreadId() + \". Test method level event logs: \" + testMethodLevelEventLogs);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassAFiveMethodsWithNoDepsSample.class, SUITE_A, SUITE_A_TEST_A);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassCSixMethodsWithNoDepsSample.class, SUITE_A, SUITE_A_TEST_A);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassEFiveMethodsWithNoDepsSample.class, SUITE_B, SUITE_B_TEST_A);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassDThreeMethodsWithNoDepsSample.class, SUITE_B, SUITE_B_TEST_B);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassBFourMethodsWithNoDepsSample.class, SUITE_B, SUITE_B_TEST_B);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassFSixMethodsWithNoDepsSample.class, SUITE_B, SUITE_B_TEST_B);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassGThreeMethodsWithNoDepsSample.class, SUITE_C, SUITE_C_TEST_A);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassHFourMethodsWithNoDepsSample.class, SUITE_C, SUITE_C_TEST_A);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassIFiveMethodsWithNoDepsSample.class, SUITE_C, SUITE_C_TEST_A);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassJFourMethodsWithNoDepsSample.class, SUITE_C, SUITE_C_TEST_B);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassKFiveMethodsWithNoDepsSample.class, SUITE_C, SUITE_C_TEST_B);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassLThreeMethodsWithNoDepsSample.class, SUITE_C, SUITE_C_TEST_C);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassMFourMethodsWithNoDepsSample.class, SUITE_C, SUITE_C_TEST_C);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassNFiveMethodsWithNoDepsSample.class, SUITE_C, SUITE_C_TEST_C);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassOSixMethodsWithNoDepsSample.class, SUITE_C, SUITE_C_TEST_C);\r\n}"
}, {
	"Path": "com.android.datetimepicker.time.RadialPickerLayout.onMeasure",
	"Comment": "measure the view to end up as a square, based on the minimum of the height and width.",
	"Method": "void onMeasure(int widthMeasureSpec,int heightMeasureSpec){\r\n    int measuredWidth = MeasureSpec.getSize(widthMeasureSpec);\r\n    int widthMode = MeasureSpec.getMode(widthMeasureSpec);\r\n    int measuredHeight = MeasureSpec.getSize(heightMeasureSpec);\r\n    int heightMode = MeasureSpec.getMode(heightMeasureSpec);\r\n    int minDimension = Math.min(measuredWidth, measuredHeight);\r\n    super.onMeasure(MeasureSpec.makeMeasureSpec(minDimension, widthMode), MeasureSpec.makeMeasureSpec(minDimension, heightMode));\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.tileView.tileview.TileView.removeTileViewEventListener",
	"Comment": "removes a tilevieweventlistener object from those listening to this tileview.",
	"Method": "void removeTileViewEventListener(TileViewEventListener listener){\r\n    tileViewEventListeners.remove(listener);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.animation.ValueAnimator.clearAllAnimations",
	"Comment": "clear all animations on this thread, without canceling or ending them.this should be used with caution.",
	"Method": "void clearAllAnimations(){\r\n    sAnimations.get().clear();\r\n    sPendingAnimations.get().clear();\r\n    sDelayedAnims.get().clear();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.dragSortListView.DragSortListView.setDragScrollStarts",
	"Comment": "set the width of each drag scroll region by specifyinga fraction of the listview height.",
	"Method": "void setDragScrollStarts(float upperFrac,float lowerFrac){\r\n    if (lowerFrac > 0.5f) {\r\n        mDragDownScrollStartFrac = 0.5f;\r\n    } else {\r\n        mDragDownScrollStartFrac = lowerFrac;\r\n    }\r\n    if (upperFrac > 0.5f) {\r\n        mDragUpScrollStartFrac = 0.5f;\r\n    } else {\r\n        mDragUpScrollStartFrac = upperFrac;\r\n    }\r\n    if (getHeight() != 0) {\r\n        updateScrollStarts();\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.weekview.WeekView.computePositionOfEvents",
	"Comment": "calculates the left and right positions of each events. this comes handy specially if eventsare overlapping.",
	"Method": "void computePositionOfEvents(List<EventRect> eventRects){\r\n    List<List<EventRect>> collisionGroups = new ArrayList<List<EventRect>>();\r\n    for (EventRect eventRect : eventRects) {\r\n        boolean isPlaced = false;\r\n        outerLoop: for (List<EventRect> collisionGroup : collisionGroups) {\r\n            for (EventRect groupEvent : collisionGroup) {\r\n                if (isEventsCollide(groupEvent.event, eventRect.event)) {\r\n                    collisionGroup.add(eventRect);\r\n                    isPlaced = true;\r\n                    break outerLoop;\r\n                }\r\n            }\r\n        }\r\n        if (!isPlaced) {\r\n            List<EventRect> newGroup = new ArrayList<EventRect>();\r\n            newGroup.add(eventRect);\r\n            collisionGroups.add(newGroup);\r\n        }\r\n    }\r\n    for (List<EventRect> collisionGroup : collisionGroups) {\r\n        expandEventsToMaxWidth(collisionGroup);\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.commonUtils.fileUtils.ParcelUtils.writeHashMapStringKey",
	"Comment": "write a hashmap to a parcel, class of key is string, class of value can parcelable",
	"Method": "void writeHashMapStringKey(Map<String, V> map,Parcel out,int flags){\r\n    if (map != null) {\r\n        out.writeInt(map.size());\r\n        for (Entry<String, V> entry : map.entrySet()) {\r\n            out.writeString(entry.getKey());\r\n            out.writeParcelable(entry.getValue(), flags);\r\n        }\r\n    } else {\r\n        out.writeInt(-1);\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.swipeback.ViewDragHelper.isEdgeTouched",
	"Comment": "check if any of the edges specified were initially touched by the pointerwith the specified id. if there is no currently active gesture or ifthere is no pointer with the given id currently down this method willreturn false.",
	"Method": "boolean isEdgeTouched(int edges,boolean isEdgeTouched,int edges,int pointerId){\r\n    return isPointerDown(pointerId) && (mInitialEdgeTouched[pointerId] & edges) != 0;\r\n}"
}, {
	"Path": "com.marshalchen.ua.common.usefulModule.UltimateListview.setRefreshListener",
	"Comment": "set the listener when refresh is triggered and enable the swiperefreshlayout",
	"Method": "void setRefreshListener(SwipeRefreshLayout.OnRefreshListener listener){\r\n    mSwipeRefreshLayout.setEnabled(true);\r\n    mSwipeRefreshLayout.setOnRefreshListener(listener);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.freeflow.core.FreeFlowContainer.computeViewPort",
	"Comment": "computes the rectangle that defines the viewport. the container tries to\tkeep the view at the top left of the old layout visible in the new\tlayout.",
	"Method": "void computeViewPort(FreeFlowLayout newLayout){\r\n    if (mLayout == null || frames == null || frames.size() == 0) {\r\n        viewPortX = 0;\r\n        viewPortY = 0;\r\n        return;\r\n    }\r\n    Object data = null;\r\n    int lowestSection = Integer.MAX_VALUE;\r\n    int lowestPosition = Integer.MAX_VALUE;\r\n    for (FreeFlowItem fd : frames.values()) {\r\n        if (fd.itemSection < lowestSection || (fd.itemSection == lowestSection && fd.itemIndex < lowestPosition)) {\r\n            data = fd.data;\r\n            lowestSection = fd.itemSection;\r\n            lowestPosition = fd.itemIndex;\r\n        }\r\n    }\r\n    FreeFlowItem freeflowItem = newLayout.getFreeFlowItemForItem(data);\r\n    freeflowItem = FreeFlowItem.clone(freeflowItem);\r\n    if (freeflowItem == null) {\r\n        viewPortX = 0;\r\n        viewPortY = 0;\r\n        return;\r\n    }\r\n    Rect vpFrame = freeflowItem.frame;\r\n    viewPortX = vpFrame.left;\r\n    viewPortY = vpFrame.top;\r\n    mScrollableWidth = mLayout.getContentWidth() - getWidth();\r\n    mScrollableHeight = mLayout.getContentHeight() - getHeight();\r\n    if (mScrollableWidth < 0) {\r\n        mScrollableWidth = 0;\r\n    }\r\n    if (mScrollableHeight < 0) {\r\n        mScrollableHeight = 0;\r\n    }\r\n    if (viewPortX > mScrollableWidth)\r\n        viewPortX = mScrollableWidth;\r\n    if (viewPortY > mScrollableHeight)\r\n        viewPortY = mScrollableHeight;\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase7Scenario2.verifySuiteAndTestLevelEventsRunInSequentialOrderForIndividualSuites",
	"Comment": "for all suites, verify that the test level events run sequentially because the parallel mode is by methods only.",
	"Method": "void verifySuiteAndTestLevelEventsRunInSequentialOrderForIndividualSuites(){\r\n    verifySequentialTests(suiteOneSuiteAndTestLevelEventLogs, suiteOneTestLevelEventLogs, suiteOneSuiteListenerOnStartEventLog, suiteOneSuiteListenerOnFinishEventLog);\r\n    verifySequentialTests(suiteTwoSuiteAndTestLevelEventLogs, suiteTwoTestLevelEventLogs, suiteTwoSuiteListenerOnStartEventLog, suiteTwoSuiteListenerOnFinishEventLog);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.easyandroidanimations.FoldAnimation.getOrientation",
	"Comment": "the available orientations are orientation.horizontal and\torientation.vertical.",
	"Method": "Orientation getOrientation(){\r\n    return orientation;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.staggeredgridview.ExtendableListView.obtainView",
	"Comment": "get a view and have it show the data associated with the specifiedposition. this is called when we have already discovered that the view isnot available for reuse in the recycle bin. the only choices left areconverting an old view or making a new one.",
	"Method": "View obtainView(int position,boolean[] isScrap){\r\n    isScrap[0] = false;\r\n    View scrapView;\r\n    scrapView = mRecycleBin.getScrapView(position);\r\n    View child;\r\n    if (scrapView != null) {\r\n        if (DBG)\r\n            Log.d(TAG, \"getView from scrap position:\" + position);\r\n        child = mAdapter.getView(position, scrapView, this);\r\n        if (child != scrapView) {\r\n            mRecycleBin.addScrapView(scrapView, position);\r\n        } else {\r\n            isScrap[0] = true;\r\n        }\r\n    } else {\r\n        if (DBG)\r\n            Log.d(TAG, \"getView position:\" + position);\r\n        child = mAdapter.getView(position, null, this);\r\n    }\r\n    return child;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.tileView.tileview.TileView.cancelRender",
	"Comment": "notify the tileview that it may stop rendering tiles.the rendering thread will be\tsent an interrupt request, but no guarantee is provided when the request will be responded to.",
	"Method": "void cancelRender(){\r\n    tileManager.cancelRender();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.rippleDrawable.RippleBackground.cancel",
	"Comment": "cancel all animations. the caller is responsible for removingthe ripple from the list of animating ripples.",
	"Method": "void cancel(){\r\n    cancelSoftwareAnimations();\r\n}"
}, {
	"Path": "test.thread.parallelization.TestNgRunStateTracker.getTestMethodEventLogsByEventTypeForClass",
	"Comment": "test in a multimap where the keys are the class instances for the test class",
	"Method": "Multimap<Object, EventLog> getTestMethodEventLogsByEventTypeForClass(String suiteName,String testName,String className,TestNgRunEvent event){\r\n    Multimap<Object, EventLog> testMethodEventLogs = ArrayListMultimap.create();\r\n    for (EventLog eventLog : eventLogs) {\r\n        if (eventLog.getEvent() == event && belongsToClass(suiteName, testName, className, eventLog)) {\r\n            testMethodEventLogs.put(eventLog.getData(EventInfo.CLASS_INSTANCE), eventLog);\r\n        }\r\n    }\r\n    return testMethodEventLogs;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.easyandroidanimations.FoldLayout.throwCustomException",
	"Comment": "throws an exception if the number of views added to this layout exceeds one.",
	"Method": "void throwCustomException(int numOfChildViews){\r\n    if (numOfChildViews == 1) {\r\n        throw new NumberOfFoldingLayoutChildrenException(FOLDING_VIEW_EXCEPTION_MESSAGE);\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.ui.CustomViewPager.postInitViewPager",
	"Comment": "override the scroller instance with our own class so we can change theduration",
	"Method": "void postInitViewPager(){\r\n    try {\r\n        Field scroller = ViewPager.class.getDeclaredField(\"mScroller\");\r\n        scroller.setAccessible(true);\r\n        Field interpolator = ViewPager.class.getDeclaredField(\"sInterpolator\");\r\n        interpolator.setAccessible(true);\r\n        mScroller = new FixSpeedScroller(getContext(), (Interpolator) interpolator.get(null));\r\n        scroller.set(this, mScroller);\r\n    } catch (Exception e) {\r\n        Logs.e(e, \"\");\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.slideExpand.AbstractSlideExpandableListAdapter.getAnimationDuration",
	"Comment": "gets the duration of the collapse animation in ms.default is 330ms. override this method to change the default.",
	"Method": "int getAnimationDuration(){\r\n    return animationDuration;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.passcodelock.AppLockManager.setExtendedTimeout",
	"Comment": "convenience method used to extend the default timeout.there are situations where an activity will start a different application with an intent.in these situations call this method right before leaving the app.",
	"Method": "void setExtendedTimeout(){\r\n    if (currentAppLocker == null)\r\n        return;\r\n    currentAppLocker.setOneTimeTimeout(AbstractAppLock.EXTENDED_TIMEOUT);\r\n}"
}, {
	"Path": "org.testng.TestNG.populateSuiteGraph",
	"Comment": "populates the dynamic graph with the reverse hierarchy of suites. edges are added pointing fromchild suite runners to parent suite runners, hence making parent suite runners dependent on allthe child suite runners",
	"Method": "void populateSuiteGraph(DynamicGraph<ISuite> suiteGraph,SuiteRunnerMap suiteRunnerMap,XmlSuite xmlSuite){\r\n    ISuite parentSuiteRunner = suiteRunnerMap.get(xmlSuite);\r\n    if (xmlSuite.getChildSuites().isEmpty()) {\r\n        suiteGraph.addNode(parentSuiteRunner);\r\n    } else {\r\n        for (XmlSuite childSuite : xmlSuite.getChildSuites()) {\r\n            suiteGraph.addEdge(0, parentSuiteRunner, suiteRunnerMap.get(childSuite));\r\n            populateSuiteGraph(suiteGraph, suiteRunnerMap, childSuite);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.swipeback.SwipeBackLayout.setScrimColor",
	"Comment": "set a color to use for the scrim that obscures primary content while adrawer is open.",
	"Method": "void setScrimColor(int color){\r\n    mScrimColor = color;\r\n    invalidate();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.listviewanimations.widget.DynamicListView.handleMobileCellScroll",
	"Comment": "this method is in charge of determining if the hover cell is aboveor below the bounds of the listview. if so, the listview does an appropriateupward or downward smooth scroll so as to reveal new items.",
	"Method": "void handleMobileCellScroll(boolean handleMobileCellScroll,Rect r){\r\n    int offset = computeVerticalScrollOffset();\r\n    int height = getHeight();\r\n    int extent = computeVerticalScrollExtent();\r\n    int range = computeVerticalScrollRange();\r\n    int hoverViewTop = r.top;\r\n    int hoverHeight = r.height();\r\n    if (hoverViewTop <= 0 && offset > 0) {\r\n        smoothScrollBy(-mSmoothScrollAmountAtEdge, 0);\r\n        return true;\r\n    }\r\n    if (hoverViewTop + hoverHeight >= height && (offset + extent) < range) {\r\n        smoothScrollBy(mSmoothScrollAmountAtEdge, 0);\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "test.thread.parallelization.BaseParallelizationTest.verifyEventThreadsSpawnedAfter",
	"Comment": "the specified failure message if the assertion on the thread ids fails.",
	"Method": "void verifyEventThreadsSpawnedAfter(Long earlierThreadId,List<EventLog> eventsFromLaterThread,String failMessage){\r\n    for (EventLog eventLog : eventsFromLaterThread) {\r\n        assertTrue(eventLog.getThreadId() > earlierThreadId, failMessage);\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.cropperimage.cropwindow.CropOverlayView.initCropWindow",
	"Comment": "set the initial crop window size and position. this is dependent on thesize and position of the image being cropped.",
	"Method": "void initCropWindow(Rect bitmapRect){\r\n    if (initializedCropWindow == false)\r\n        initializedCropWindow = true;\r\n    if (mFixAspectRatio) {\r\n        if (AspectRatioUtil.calculateAspectRatio(bitmapRect) > mTargetAspectRatio) {\r\n            Edge.TOP.setCoordinate(bitmapRect.top);\r\n            Edge.BOTTOM.setCoordinate(bitmapRect.bottom);\r\n            final float centerX = getWidth() / 2f;\r\n            final float cropWidth = Math.max(Edge.MIN_CROP_LENGTH_PX, AspectRatioUtil.calculateWidth(Edge.TOP.getCoordinate(), Edge.BOTTOM.getCoordinate(), mTargetAspectRatio));\r\n            if (cropWidth == Edge.MIN_CROP_LENGTH_PX)\r\n                mTargetAspectRatio = (Edge.MIN_CROP_LENGTH_PX) / (Edge.BOTTOM.getCoordinate() - Edge.TOP.getCoordinate());\r\n            final float halfCropWidth = cropWidth / 2f;\r\n            Edge.LEFT.setCoordinate(centerX - halfCropWidth);\r\n            Edge.RIGHT.setCoordinate(centerX + halfCropWidth);\r\n        } else {\r\n            Edge.LEFT.setCoordinate(bitmapRect.left);\r\n            Edge.RIGHT.setCoordinate(bitmapRect.right);\r\n            final float centerY = getHeight() / 2f;\r\n            final float cropHeight = Math.max(Edge.MIN_CROP_LENGTH_PX, AspectRatioUtil.calculateHeight(Edge.LEFT.getCoordinate(), Edge.RIGHT.getCoordinate(), mTargetAspectRatio));\r\n            if (cropHeight == Edge.MIN_CROP_LENGTH_PX)\r\n                mTargetAspectRatio = (Edge.RIGHT.getCoordinate() - Edge.LEFT.getCoordinate()) / Edge.MIN_CROP_LENGTH_PX;\r\n            final float halfCropHeight = cropHeight / 2f;\r\n            Edge.TOP.setCoordinate(centerY - halfCropHeight);\r\n            Edge.BOTTOM.setCoordinate(centerY + halfCropHeight);\r\n        }\r\n    } else {\r\n        final float horizontalPadding = 0.1f * bitmapRect.width();\r\n        final float verticalPadding = 0.1f * bitmapRect.height();\r\n        Edge.LEFT.setCoordinate(bitmapRect.left + horizontalPadding);\r\n        Edge.TOP.setCoordinate(bitmapRect.top + verticalPadding);\r\n        Edge.RIGHT.setCoordinate(bitmapRect.right - horizontalPadding);\r\n        Edge.BOTTOM.setCoordinate(bitmapRect.bottom - verticalPadding);\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.ui.DrawableView.expandDirtyRect",
	"Comment": "called when replaying history to ensure the dirty region includes allpoints.",
	"Method": "void expandDirtyRect(float historicalX,float historicalY){\r\n    if (historicalX < dirtyRect.left) {\r\n        dirtyRect.left = historicalX;\r\n    } else if (historicalX > dirtyRect.right) {\r\n        dirtyRect.right = historicalX;\r\n    }\r\n    if (historicalY < dirtyRect.top) {\r\n        dirtyRect.top = historicalY;\r\n    } else if (historicalY > dirtyRect.bottom) {\r\n        dirtyRect.bottom = historicalY;\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.dragSortListView.DragSortListView.updateFloatView",
	"Comment": "sets float view location based on suggested values andconstraints set in mdragflags.",
	"Method": "void updateFloatView(){\r\n    if (mFloatViewManager != null) {\r\n        mTouchLoc.set(mX, mY);\r\n        mFloatViewManager.onDragFloatView(mFloatView, mFloatLoc, mTouchLoc);\r\n    }\r\n    final int floatX = mFloatLoc.x;\r\n    final int floatY = mFloatLoc.y;\r\n    int padLeft = getPaddingLeft();\r\n    if ((mDragFlags & DRAG_POS_X) == 0 && floatX > padLeft) {\r\n        mFloatLoc.x = padLeft;\r\n    } else if ((mDragFlags & DRAG_NEG_X) == 0 && floatX < padLeft) {\r\n        mFloatLoc.x = padLeft;\r\n    }\r\n    final int numHeaders = getHeaderViewsCount();\r\n    final int numFooters = getFooterViewsCount();\r\n    final int firstPos = getFirstVisiblePosition();\r\n    final int lastPos = getLastVisiblePosition();\r\n    int topLimit = getPaddingTop();\r\n    if (firstPos < numHeaders) {\r\n        topLimit = getChildAt(numHeaders - firstPos - 1).getBottom();\r\n    }\r\n    if ((mDragFlags & DRAG_NEG_Y) == 0) {\r\n        if (firstPos <= mSrcPos) {\r\n            topLimit = Math.max(getChildAt(mSrcPos - firstPos).getTop(), topLimit);\r\n        }\r\n    }\r\n    int bottomLimit = getHeight() - getPaddingBottom();\r\n    if (lastPos >= getCount() - numFooters - 1) {\r\n        bottomLimit = getChildAt(getCount() - numFooters - 1 - firstPos).getBottom();\r\n    }\r\n    if ((mDragFlags & DRAG_POS_Y) == 0) {\r\n        if (lastPos >= mSrcPos) {\r\n            bottomLimit = Math.min(getChildAt(mSrcPos - firstPos).getBottom(), bottomLimit);\r\n        }\r\n    }\r\n    if (floatY < topLimit) {\r\n        mFloatLoc.y = topLimit;\r\n    } else if (floatY + mFloatViewHeight > bottomLimit) {\r\n        mFloatLoc.y = bottomLimit - mFloatViewHeight;\r\n    }\r\n    mFloatViewMid = mFloatLoc.y + mFloatViewHeightHalf;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.rebound.Spring.wasAtRest",
	"Comment": "check if the spring was at rest in the prior iteration. this is used for ensuring the endingcallbacks are fired as the spring comes to a rest.",
	"Method": "boolean wasAtRest(){\r\n    return mWasAtRest;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.listviewanimations.widget.DynamicListView.updateNeighborViewsForId",
	"Comment": "stores a reference to the views above and below the item currentlycorresponding to the hover cell. it is important to note that if thisitem is either at the top or bottom of the list, maboveitemid or mbelowitemidmay be invalid.",
	"Method": "void updateNeighborViewsForId(long itemId){\r\n    int position = getPositionForId(itemId);\r\n    ListAdapter adapter = getAdapter();\r\n    if (!adapter.hasStableIds()) {\r\n        throw new IllegalStateException(\"Adapter doesn't have stable ids! Make sure your adapter has stable ids, and override hasStableIds() to return true.\");\r\n    }\r\n    mAboveItemId = position - 1 >= 0 ? adapter.getItemId(position - 1) : INVALID_ROW_ID;\r\n    mBelowItemId = position + 1 < adapter.getCount() ? adapter.getItemId(position + 1) : INVALID_ROW_ID;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.rebound.Spring.interpolate",
	"Comment": "linear interpolation between the previous and current physics state based on the amount oftimestep remaining after processing the rendering delta time in timestep sized chunks.",
	"Method": "void interpolate(double alpha){\r\n    mCurrentState.position = mCurrentState.position * alpha + mPreviousState.position * (1 - alpha);\r\n    mCurrentState.velocity = mCurrentState.velocity * alpha + mPreviousState.velocity * (1 - alpha);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.tileView.tileview.TileView.updateViewport",
	"Comment": "let the zoom manager know what tiles to show based on our position and dimensions",
	"Method": "void updateViewport(){\r\n    int left = getScrollX();\r\n    int top = getScrollY();\r\n    int right = left + getWidth();\r\n    int bottom = top + getHeight();\r\n    detailManager.updateViewport(left, top, right, bottom);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.cropimage.ImageViewTouchBase.getProperBaseMatrix",
	"Comment": "setup the base matrix so that the image is centered and scaled properly.",
	"Method": "void getProperBaseMatrix(RotateBitmap bitmap,Matrix matrix,boolean includeRotation){\r\n    float viewWidth = getWidth();\r\n    float viewHeight = getHeight();\r\n    float w = bitmap.getWidth();\r\n    float h = bitmap.getHeight();\r\n    matrix.reset();\r\n    float widthScale = Math.min(viewWidth / w, 3.0f);\r\n    float heightScale = Math.min(viewHeight / h, 3.0f);\r\n    float scale = Math.min(widthScale, heightScale);\r\n    if (includeRotation) {\r\n        matrix.postConcat(bitmap.getRotateMatrix());\r\n    }\r\n    matrix.postScale(scale, scale);\r\n    matrix.postTranslate((viewWidth - w * scale) / 2F, (viewHeight - h * scale) / 2F);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.freeflow.core.FreeFlowContainer.setCheckedValue",
	"Comment": "updates the internal arraymap keeping track of checked states. will not\tupdate the check ui.",
	"Method": "void setCheckedValue(int sectionIndex,int positionInSection,boolean val){\r\n    int foundAtIndex = -1;\r\n    for (int i = 0; i < mCheckStates.size(); i++) {\r\n        IndexPath p = mCheckStates.keyAt(i);\r\n        if (p.section == sectionIndex && p.positionInSection == positionInSection) {\r\n            foundAtIndex = i;\r\n            break;\r\n        }\r\n    }\r\n    if (foundAtIndex > -1 && val == false) {\r\n        mCheckStates.removeAt(foundAtIndex);\r\n    } else if (foundAtIndex == -1 && val == true) {\r\n        IndexPath pos = new IndexPath(sectionIndex, positionInSection);\r\n        mCheckStates.put(pos, true);\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.commonUtils.basicUtils.BasicUtils.iterateHashMapConcurrent",
	"Comment": "print all items of hashmap,avoid concurrentmodificationexceptions",
	"Method": "void iterateHashMapConcurrent(HashMap<String, Object> hashMap){\r\n    Iterator<Map.Entry<String, Object>> iterator = hashMap.entrySet().iterator();\r\n    while (iterator.hasNext()) {\r\n        Map.Entry<String, Object> entry = iterator.next();\r\n        Logs.d(\"key: \" + entry.getKey() + \"   \" + \"value:  \" + entry.getValue().toString());\r\n    }\r\n}"
}, {
	"Path": "org.testng.junit.JUnit4TestRunner.getTestMethods",
	"Comment": "needed from testrunner in order to figure out what junit test methods were run.",
	"Method": "List<ITestNGMethod> getTestMethods(){\r\n    return m_methods;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.viewpagertransforms.ABaseTransformer.isPagingEnabled",
	"Comment": "indicates if the default animations of the view pager should be used.",
	"Method": "boolean isPagingEnabled(){\r\n    return false;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.animation.Keyframe.getFraction",
	"Comment": "gets the time for this keyframe, as a fraction of the overall animation duration.",
	"Method": "float getFraction(){\r\n    return mFraction;\r\n}"
}, {
	"Path": "com.marshalchen.common.commonUtils.urlUtils.Base64.decodeToObject",
	"Comment": "attempts to decode base64 data and deserialize a javaobject within. returns null if there was an error.if loader is not null, it will be the class loaderused when deserializing.",
	"Method": "Object decodeToObject(String encodedObject,Object decodeToObject,String encodedObject,int options,ClassLoader loader){\r\n    byte[] objBytes = decode(encodedObject, options);\r\n    java.io.ByteArrayInputStream bais = null;\r\n    java.io.ObjectInputStream ois = null;\r\n    Object obj = null;\r\n    try {\r\n        bais = new java.io.ByteArrayInputStream(objBytes);\r\n        if (loader == null) {\r\n            ois = new java.io.ObjectInputStream(bais);\r\n        } else {\r\n            ois = new java.io.ObjectInputStream(bais) {\r\n                @Override\r\n                public Class<?> resolveClass(java.io.ObjectStreamClass streamClass) throws java.io.IOException, ClassNotFoundException {\r\n                    Class c = Class.forName(streamClass.getName(), false, loader);\r\n                    if (c == null) {\r\n                        return super.resolveClass(streamClass);\r\n                    } else {\r\n                        return c;\r\n                    }\r\n                }\r\n            };\r\n        }\r\n        obj = ois.readObject();\r\n    } catch (java.io.IOException e) {\r\n        throw e;\r\n    } catch (ClassNotFoundException e) {\r\n        throw e;\r\n    } finally {\r\n        try {\r\n            bais.close();\r\n        } catch (Exception e) {\r\n        }\r\n        try {\r\n            ois.close();\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n    return obj;\r\n}"
}, {
	"Path": "com.marshalchen.common.commonUtils.urlUtils.Base64.decodeToObject",
	"Comment": "attempts to decode base64 data and deserialize a javaobject within. returns null if there was an error.if loader is not null, it will be the class loaderused when deserializing.",
	"Method": "Object decodeToObject(String encodedObject,Object decodeToObject,String encodedObject,int options,ClassLoader loader){\r\n    Class c = Class.forName(streamClass.getName(), false, loader);\r\n    if (c == null) {\r\n        return super.resolveClass(streamClass);\r\n    } else {\r\n        return c;\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.customshapeimageview.svgandroid.SVGParser.getSVGFromInputStream",
	"Comment": "parse svg data from an input stream, replacing a single color with another color.",
	"Method": "SVG getSVGFromInputStream(InputStream svgData,SVG getSVGFromInputStream,InputStream svgData,int targetWidth,int targetHeight,SVG getSVGFromInputStream,InputStream svgData,int searchColor,int replaceColor,int targetWidth,int targetHeight){\r\n    return SVGParser.parse(svgData, searchColor, replaceColor, false, targetWidth, targetHeight);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.slideactivity.SlidingLayout.smoothSlideTo",
	"Comment": "smoothly animate mdraggingpane to the target x position within its range.",
	"Method": "boolean smoothSlideTo(float slideOffset,int velocity){\r\n    if (!mCanSlide) {\r\n        return false;\r\n    }\r\n    final LayoutParams lp = (LayoutParams) mSlideableView.getLayoutParams();\r\n    final int leftBound = getPaddingLeft() + lp.leftMargin;\r\n    int x = (int) (leftBound + slideOffset * mSlideRange);\r\n    if (mDragHelper.smoothSlideViewTo(mSlideableView, x, mSlideableView.getTop())) {\r\n        setAllChildrenVisible();\r\n        ViewCompat.postInvalidateOnAnimation(this);\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.square_progressbar.SquareProgressBar.drawOutline",
	"Comment": "draws an outline of the progressbar. looks quite cool in some situations.",
	"Method": "void drawOutline(boolean drawOutline){\r\n    bar.setOutline(drawOutline);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.ImageFilter.PixelateFilter.getPredominantRGB",
	"Comment": "method gets the predominant colour pixels to extrapolatethe pixelation from",
	"Method": "int getPredominantRGB(Image imageIn,int a_x,int a_y,int squareSize){\r\n    int red = -1;\r\n    int green = -1;\r\n    int blue = -1;\r\n    for (int x = a_x; x < a_x + squareSize; x++) {\r\n        for (int y = a_y; y < a_y + squareSize; y++) {\r\n            if (x < imageIn.getWidth() && y < imageIn.getHeight()) {\r\n                if (red == -1) {\r\n                    red = imageIn.getRComponent(x, y);\r\n                } else {\r\n                    red = (red + imageIn.getRComponent(x, y)) / 2;\r\n                }\r\n                if (green == -1) {\r\n                    green = imageIn.getGComponent(x, y);\r\n                } else {\r\n                    green = (green + imageIn.getGComponent(x, y)) / 2;\r\n                }\r\n                if (blue == -1) {\r\n                    blue = imageIn.getBComponent(x, y);\r\n                } else {\r\n                    blue = (blue + imageIn.getBComponent(x, y)) / 2;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return (255 << 24) + (red << 16) + (green << 8) + blue;\r\n}"
}, {
	"Path": "org.isoron.uhabits.activities.common.views.StreakChart.getMaxStreakCount",
	"Comment": "returns the maximum number of streaks this view is able to show, givenits current size.",
	"Method": "int getMaxStreakCount(){\r\n    return (int) Math.floor(getMeasuredHeight() / baseSize);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.dragSortListView.DragSortListView.setAdapter",
	"Comment": "for each dragsortlistview listener interface implemented byadapter, this method calls the appropriate listener method with adapter as the argument.",
	"Method": "void setAdapter(ListAdapter adapter){\r\n    if (adapter != null) {\r\n        mAdapterWrapper = new AdapterWrapper(adapter);\r\n        adapter.registerDataSetObserver(mObserver);\r\n        if (adapter instanceof DropListener) {\r\n            setDropListener((DropListener) adapter);\r\n        }\r\n        if (adapter instanceof DragListener) {\r\n            setDragListener((DragListener) adapter);\r\n        }\r\n        if (adapter instanceof RemoveListener) {\r\n            setRemoveListener((RemoveListener) adapter);\r\n        }\r\n    } else {\r\n        mAdapterWrapper = null;\r\n    }\r\n    super.setAdapter(mAdapterWrapper);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.rippleDrawable.RippleBackground.jump",
	"Comment": "jump all animations to their end state. the caller is responsible forremoving the ripple from the list of animating ripples.",
	"Method": "void jump(){\r\n    endSoftwareAnimations();\r\n}"
}, {
	"Path": "com.marshalchen.common.commonUtils.fileUtils.PreferencesUtils.getFloat",
	"Comment": "get float from custom preferences with custom default value",
	"Method": "float getFloat(Context context,String key,float getFloat,Context context,String preferenceName,String key,float getFloat,Context context,String preferenceName,String key,float defaultValue){\r\n    SharedPreferences settings = context.getSharedPreferences(preferenceName, Context.MODE_PRIVATE);\r\n    return settings.getFloat(key, defaultValue);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.rebound.SpringSystem.create",
	"Comment": "create a new springsystem providing the appropriate constructor parameters to work properlyin an android environment.",
	"Method": "SpringSystem create(){\r\n    return new SpringSystem(new SpringClock(), AndroidSpringLooperFactory.createSpringLooper());\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.staggeredgridview.ExtendableListView.hasSpaceDown",
	"Comment": "override to tell filling flow to continue to fill up as we have space.",
	"Method": "boolean hasSpaceDown(){\r\n    return false;\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.recyclerplayground.layout.StaticGridLayoutManager.canScrollVertically",
	"Comment": "use this method to tell the recyclerview if scrolling is even possiblein the vertical direction.",
	"Method": "boolean canScrollVertically(){\r\n    return true;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.square_progressbar.utils.PercentStyle.setCustomText",
	"Comment": "with this you can set a custom text which should get displayed right\tbehind the number of the progress. per default it displays a %.",
	"Method": "void setCustomText(String customText){\r\n    this.customText = customText;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.animation.PropertyValuesHolder.ofFloat",
	"Comment": "constructs and returns a propertyvaluesholder with a given property andset of float values.",
	"Method": "PropertyValuesHolder ofFloat(String propertyName,float values,PropertyValuesHolder ofFloat,Property<?, Float> property,float values){\r\n    return new FloatPropertyValuesHolder(property, values);\r\n}"
}, {
	"Path": "com.marshalchen.common.commonUtils.fileUtils.FileUtils.writeFile",
	"Comment": "write file, the string list will be written to the begin of the file",
	"Method": "boolean writeFile(String filePath,String content,boolean append,boolean writeFile,String filePath,String content,boolean writeFile,String filePath,InputStream stream,boolean writeFile,String filePath,InputStream stream,boolean append,boolean writeFile,File file,InputStream stream,boolean writeFile,File file,InputStream stream,boolean append){\r\n    OutputStream o = null;\r\n    try {\r\n        makeDirs(file.getAbsolutePath());\r\n        o = new FileOutputStream(file, append);\r\n        byte[] data = new byte[1024];\r\n        int length = -1;\r\n        while ((length = stream.read(data)) != -1) {\r\n            o.write(data, 0, length);\r\n        }\r\n        o.flush();\r\n        return true;\r\n    } catch (FileNotFoundException e) {\r\n        throw new RuntimeException(\"FileNotFoundException occurred. \", e);\r\n    } catch (IOException e) {\r\n        throw new RuntimeException(\"IOException occurred. \", e);\r\n    } finally {\r\n        if (o != null) {\r\n            try {\r\n                o.close();\r\n                stream.close();\r\n            } catch (IOException e) {\r\n                throw new RuntimeException(\"IOException occurred. \", e);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.dragSortListView.SimpleDragSortCursorAdapter.setCursorToStringConverter",
	"Comment": "sets the converterused to convert the filtering cursorinto a string.",
	"Method": "void setCursorToStringConverter(CursorToStringConverter cursorToStringConverter){\r\n    mCursorToStringConverter = cursorToStringConverter;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.kenburnsview.Transition.getDestinyRect",
	"Comment": "gets the rect that will take the scene when a ken burns transition ends.",
	"Method": "RectF getDestinyRect(){\r\n    return mDstRect;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.imageprocessing.FastImageProcessingView.setPipeline",
	"Comment": "sets the fastimageprocessingpipeline that will do the rendering for this view.",
	"Method": "void setPipeline(FastImageProcessingPipeline pipeline){\r\n    setRenderer(pipeline);\r\n    setRenderMode(RENDERMODE_WHEN_DIRTY);\r\n}"
}, {
	"Path": "org.testng.log4testng.Logger.testUserLoggerSetError",
	"Comment": "test setting a user logger to an illegal level value throws an exception",
	"Method": "void testUserLoggerSetError(){\r\n    Properties props = new Properties();\r\n    ByteArrayOutputStream out1 = new ByteArrayOutputStream();\r\n    ByteArrayOutputStream err1 = new ByteArrayOutputStream();\r\n    PrintStream out2 = new PrintStream(out1);\r\n    PrintStream err2 = new PrintStream(err1);\r\n    props.put(\"log4testng.logger.java.lang.String\", \"unknown\");\r\n    try {\r\n        testInitialize(props, out2, err2);\r\n        throw new RuntimeException(\"failure\");\r\n    } catch (IllegalArgumentException pEx) {\r\n        Assert.assertEquals(out1.toString(), \"\");\r\n        Assert.assertEquals(err1.toString(), \"\");\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.animation.ValueAnimator.getValues",
	"Comment": "returns the values that this valueanimator animates between. these values are stored inpropertyvaluesholder objects, even if the valueanimator was created with a simple listof value objects instead.",
	"Method": "PropertyValuesHolder[] getValues(){\r\n    return mValues;\r\n}"
}, {
	"Path": "com.marshalchen.common.DiskLruCache.DiskLruCache.rebuildJournal",
	"Comment": "creates a new journal that omits redundant information. this replaces thecurrent journal if it exists.",
	"Method": "void rebuildJournal(){\r\n    if (journalWriter != null) {\r\n        journalWriter.close();\r\n    }\r\n    Writer writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(journalFileTmp), Util.US_ASCII));\r\n    try {\r\n        writer.write(MAGIC);\r\n        writer.write(\"\\n\");\r\n        writer.write(VERSION_1);\r\n        writer.write(\"\\n\");\r\n        writer.write(Integer.toString(appVersion));\r\n        writer.write(\"\\n\");\r\n        writer.write(Integer.toString(valueCount));\r\n        writer.write(\"\\n\");\r\n        writer.write(\"\\n\");\r\n        for (Entry entry : lruEntries.values()) {\r\n            if (entry.currentEditor != null) {\r\n                writer.write(DIRTY + ' ' + entry.key + '\\n');\r\n            } else {\r\n                writer.write(CLEAN + ' ' + entry.key + entry.getLengths() + '\\n');\r\n            }\r\n        }\r\n    } finally {\r\n        writer.close();\r\n    }\r\n    if (journalFile.exists()) {\r\n        renameTo(journalFile, journalFileBackup, true);\r\n    }\r\n    renameTo(journalFileTmp, journalFile, false);\r\n    journalFileBackup.delete();\r\n    journalWriter = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(journalFile, true), Util.US_ASCII));\r\n}"
}, {
	"Path": "org.testng.reporters.JUnitReportReporter.getNextConfiguration",
	"Comment": "add the time of the configuration method to this test method.the only problem with this method is that the timing of a test method might not be added tothe time of the same configuration method that ran before it but since they should all beequivalent, this should never be an issue.",
	"Method": "long getNextConfiguration(ListMultiMap<Object, ITestResult> configurations,ITestResult tr){\r\n    long result = 0;\r\n    List<ITestResult> confResults = configurations.get(tr.getInstance());\r\n    Map<ITestNGMethod, ITestResult> seen = Maps.newHashMap();\r\n    for (ITestResult r : confResults) {\r\n        if (!seen.containsKey(r.getMethod())) {\r\n            result += r.getEndMillis() - r.getStartMillis();\r\n            seen.put(r.getMethod(), r);\r\n        }\r\n    }\r\n    confResults.removeAll(seen.values());\r\n    return result;\r\n}"
}, {
	"Path": "org.testng.reporters.util.StackTraceTools.getTestRoot",
	"Comment": "finds topmost position of the test method in the stack, or top of stack if methodis not in it.",
	"Method": "int getTestRoot(StackTraceElement[] stack,ITestNGMethod method){\r\n    if (stack == null || method == null) {\r\n        return -1;\r\n    }\r\n    String cname = method.getTestClass().getName();\r\n    for (int x = stack.length - 1; x >= 0; x--) {\r\n        if (cname.equals(stack[x].getClassName()) && method.getMethodName().equals(stack[x].getMethodName())) {\r\n            return x;\r\n        }\r\n    }\r\n    return stack.length - 1;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.swipeback.ViewDragHelper.getEdgeSize",
	"Comment": "return the size of an edge. this is the range in pixels along the edgesof this view that will actively detect edge touches or drags if edgetracking is enabled.",
	"Method": "int getEdgeSize(){\r\n    return mEdgeSize;\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.makers.ThumbnailMaker.makeThumbnail",
	"Comment": "makes a thumbnail of the specified dimensions, from the specified\tsource image.",
	"Method": "BufferedImage makeThumbnail(BufferedImage img,int width,int height){\r\n    if (!ready.isReady()) {\r\n        throw new IllegalStateException(ThumbnailMaker.NOT_READY_FOR_MAKE);\r\n    }\r\n    if (width <= 0) {\r\n        throw new IllegalArgumentException(\"Width must be greater than zero.\");\r\n    }\r\n    if (height <= 0) {\r\n        throw new IllegalArgumentException(\"Height must be greater than zero.\");\r\n    }\r\n    BufferedImage thumbnailImage = new BufferedImageBuilder(width, height, imageType).build();\r\n    Dimension imgSize = new Dimension(img.getWidth(), img.getHeight());\r\n    Dimension thumbnailSize = new Dimension(width, height);\r\n    Resizer resizer = resizerFactory.getResizer(imgSize, thumbnailSize);\r\n    resizer.resize(img, thumbnailImage);\r\n    return thumbnailImage;\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase7Scenario1.verifyThreeInstancesOfTestClassForAllTestMethods",
	"Comment": "verify that the same test class instances are associated with each of the test methods from the sample test class",
	"Method": "void verifyThreeInstancesOfTestClassForAllTestMethods(){\r\n    verifyNumberOfInstancesOfTestClassForMethods(SUITE, TEST, TestClassAFiveMethodsWithFactoryUsingDataProviderAndNoDepsSample.class, 3);\r\n    verifySameInstancesOfTestClassAssociatedWithMethods(SUITE, TEST, TestClassAFiveMethodsWithFactoryUsingDataProviderAndNoDepsSample.class);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.animation.ValueAnimator.getFrameDelay",
	"Comment": "the amount of time, in milliseconds, between each frame of the animation. this is arequested time that the animation will attempt to honor, but the actual delay betweenframes may be different, depending on system load and capabilities. this is a staticfunction because the same delay will be applied to all animations, since they are allrun off of a single timing loop.",
	"Method": "long getFrameDelay(){\r\n    return sFrameDelay;\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.tasks.io.FileImageSink.isMatchingFormat",
	"Comment": "determines whether an specified format name and file extension are\tfor the same format.",
	"Method": "boolean isMatchingFormat(String formatName,String fileExtension){\r\n    if (formatName == null || fileExtension == null) {\r\n        return false;\r\n    }\r\n    ImageWriter iw;\r\n    try {\r\n        iw = ImageIO.getImageWritersByFormatName(formatName).next();\r\n    } catch (NoSuchElementException e) {\r\n        return false;\r\n    }\r\n    String[] suffixes = iw.getOriginatingProvider().getFileSuffixes();\r\n    for (String suffix : suffixes) {\r\n        if (fileExtension.equalsIgnoreCase(suffix)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.slider.Indicators.PagerIndicator.setDefaultIndicatorShape",
	"Comment": "if you are using the default indicator, this method will help you to set the shape ofindicator, there are two kind of shapes youcan set, oval and rect.",
	"Method": "void setDefaultIndicatorShape(Shape shape){\r\n    if (mUserSetSelectedIndicatorResId == 0) {\r\n        if (shape == Shape.Oval) {\r\n            mSelectedGradientDrawable.setShape(GradientDrawable.OVAL);\r\n        } else {\r\n            mSelectedGradientDrawable.setShape(GradientDrawable.RECTANGLE);\r\n        }\r\n    }\r\n    if (mUserSetUnSelectedIndicatorResId == 0) {\r\n        if (shape == Shape.Oval) {\r\n            mUnSelectedGradientDrawable.setShape(GradientDrawable.OVAL);\r\n        } else {\r\n            mUnSelectedGradientDrawable.setShape(GradientDrawable.RECTANGLE);\r\n        }\r\n    }\r\n    resetDrawable();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.customFonts.CalligraphyUtils.pullFontPathFromTheme",
	"Comment": "last but not least, try to pull the font path from the theme, which is defined.",
	"Method": "String pullFontPathFromTheme(Context context,int styleId,int attributeId){\r\n    if (styleId == -1 || attributeId == -1)\r\n        return null;\r\n    final Resources.Theme theme = context.getTheme();\r\n    final TypedValue value = new TypedValue();\r\n    theme.resolveAttribute(styleId, value, true);\r\n    final TypedArray typedArray = theme.obtainStyledAttributes(value.resourceId, new int[] { attributeId });\r\n    try {\r\n        return typedArray.getString(0);\r\n    } catch (Exception ignore) {\r\n        return null;\r\n    } finally {\r\n        typedArray.recycle();\r\n    }\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase7Scenario1.verifyTestMethodLevelEventsAllOccurBetweenTestListenerStartAndFinish",
	"Comment": "verifies that all the test method level events execute between the test listener onstart and onfinish methods",
	"Method": "void verifyTestMethodLevelEventsAllOccurBetweenTestListenerStartAndFinish(){\r\n    verifyEventsOccurBetween(testListenerOnStartEventLog, testMethodLevelEventLogs, testListenerOnFinishEventLog, \"All of the test method level event logs should have timestamps between the test listener's onStart \" + \"and onFinish event logs. Test Listener onStart event log: \" + testListenerOnStartEventLog + \". Test Listener onFinish event log: \" + testListenerOnFinishEventLog + \". Test method level \" + \"event logs: \" + testMethodLevelEventLogs);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.cropimage.Crop.pickImage",
	"Comment": "utility method that starts an image picker since that often precedes a crop",
	"Method": "void pickImage(Activity activity){\r\n    Intent intent = new Intent(Intent.ACTION_GET_CONTENT).setType(\"image/*\");\r\n    try {\r\n        activity.startActivityForResult(intent, REQUEST_PICK);\r\n    } catch (ActivityNotFoundException e) {\r\n        Toast.makeText(activity, \"crop__pick_error\", Toast.LENGTH_SHORT).show();\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.commonUtils.uiUtils.ImageUtils.revertImageSize",
	"Comment": "revert image file to a square with width and height equal 1000",
	"Method": "Bitmap revertImageSize(String path,int width,Bitmap revertImageSize,String path,Bitmap revertImageSize,String path,int width,int height){\r\n    BufferedInputStream in = new BufferedInputStream(new FileInputStream(new File(path)));\r\n    BitmapFactory.Options options = new BitmapFactory.Options();\r\n    options.inJustDecodeBounds = true;\r\n    BitmapFactory.decodeStream(in, null, options);\r\n    in.close();\r\n    int i = 0;\r\n    Bitmap bitmap = null;\r\n    while (true) {\r\n        if ((options.outWidth >> i <= width) && (options.outHeight >> i <= height)) {\r\n            in = new BufferedInputStream(new FileInputStream(new File(path)));\r\n            options.inSampleSize = (int) Math.pow(2.0D, i);\r\n            options.inJustDecodeBounds = false;\r\n            bitmap = BitmapFactory.decodeStream(in, null, options);\r\n            break;\r\n        }\r\n        i += 1;\r\n    }\r\n    return bitmap;\r\n}"
}, {
	"Path": "org.isoron.uhabits.core.io.HabitsCSVExporter.writeMultipleHabits",
	"Comment": "writes a scores file and a checkmarks file containing scores and checkmarks of every habit.the first column corresponds to the date. subsequent columns correspond to a habit.habits are taken from the list of selected habits.dates are determined from the oldest repetition date to the newest repetition date found inthe list of habits.",
	"Method": "void writeMultipleHabits(){\r\n    String scoresFileName = \"Scores.csv\";\r\n    String checksFileName = \"Checkmarks.csv\";\r\n    generateFilenames.add(scoresFileName);\r\n    generateFilenames.add(checksFileName);\r\n    FileWriter scoresWriter = new FileWriter(exportDirName + scoresFileName);\r\n    FileWriter checksWriter = new FileWriter(exportDirName + checksFileName);\r\n    writeMultipleHabitsHeader(scoresWriter);\r\n    writeMultipleHabitsHeader(checksWriter);\r\n    Timestamp[] timeframe = getTimeframe();\r\n    Timestamp oldest = timeframe[0];\r\n    Timestamp newest = DateUtils.getToday();\r\n    List<int[]> checkmarks = new ArrayList();\r\n    List<double[]> scores = new ArrayList();\r\n    for (Habit h : selectedHabits) {\r\n        checkmarks.add(h.getCheckmarks().getValues(oldest, newest));\r\n        scores.add(h.getScores().getValues(oldest, newest));\r\n    }\r\n    int days = oldest.daysUntil(newest);\r\n    SimpleDateFormat dateFormat = DateFormats.getCSVDateFormat();\r\n    for (int i = 0; i <= days; i++) {\r\n        Date day = newest.minus(i).toJavaDate();\r\n        String date = dateFormat.format(day);\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append(date).append(DELIMITER);\r\n        checksWriter.write(sb.toString());\r\n        scoresWriter.write(sb.toString());\r\n        for (int j = 0; j < selectedHabits.size(); j++) {\r\n            checksWriter.write(String.valueOf(checkmarks.get(j)[i]));\r\n            checksWriter.write(DELIMITER);\r\n            String score = String.format(\"%.4f\", ((float) scores.get(j)[i]));\r\n            scoresWriter.write(score);\r\n            scoresWriter.write(DELIMITER);\r\n        }\r\n        checksWriter.write(\"\\n\");\r\n        scoresWriter.write(\"\\n\");\r\n    }\r\n    scoresWriter.close();\r\n    checksWriter.close();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.tileView.tileview.TileView.destroy",
	"Comment": "clear tile image files and remove all views, appropriate for activity.ondestroy\treferences to tileview should be set to null following invocations of this method.",
	"Method": "void destroy(){\r\n    tileManager.clear();\r\n    sampleManager.clear();\r\n    pathManager.clear();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.fancycoverflow.FancyCoverFlow.setMaxRotation",
	"Comment": "sets the maximum rotation that is applied to items left and right of the center of the coverflow.",
	"Method": "void setMaxRotation(int maxRotation){\r\n    this.maxRotation = maxRotation;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.slideactivity.SlidingLayout.openPane",
	"Comment": "open the sliding pane if it is currently slideable. if first layouthas already completed this will animate.",
	"Method": "boolean openPane(View pane,int initialVelocity,boolean openPane){\r\n    return openPane(mSlideableView, 0);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.animation.ValueAnimator.setFrameDelay",
	"Comment": "the amount of time, in milliseconds, between each frame of the animation. this is arequested time that the animation will attempt to honor, but the actual delay betweenframes may be different, depending on system load and capabilities. this is a staticfunction because the same delay will be applied to all animations, since they are allrun off of a single timing loop.",
	"Method": "void setFrameDelay(long frameDelay){\r\n    sFrameDelay = frameDelay;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.slideactivity.SlidingLayout.setParallaxDistance",
	"Comment": "set a distance to parallax the lower pane by when the upper pane is in itsfully closed state. the lower pane will scroll between this position andits fully open state.",
	"Method": "void setParallaxDistance(int parallaxBy){\r\n    mParallaxBy = parallaxBy;\r\n    requestLayout();\r\n}"
}, {
	"Path": "org.isoron.uhabits.activities.habits.list.views.HabitCardListAdapter.setListView",
	"Comment": "sets the habitcardlistview that this adapter will provide data for.this object will be used to generated new habitcardviews, upon demand.",
	"Method": "void setListView(HabitCardListView listView){\r\n    this.listView = listView;\r\n}"
}, {
	"Path": "test.thread.parallelization.TestNgRunStateTracker.getTestMethodEventLogsForClass",
	"Comment": "out in a map where the keys are the class instances on which the methods were run.",
	"Method": "Multimap<Object, EventLog> getTestMethodEventLogsForClass(String suiteName,String testName,String className){\r\n    Multimap<Object, EventLog> testMethodEventLogs = ArrayListMultimap.create();\r\n    for (EventLog eventLog : eventLogs) {\r\n        if (isTestMethodLevelEventLog(eventLog) && belongsToClass(suiteName, testName, className, eventLog)) {\r\n            testMethodEventLogs.put(eventLog.getData(EventInfo.CLASS_INSTANCE), eventLog);\r\n        }\r\n    }\r\n    return testMethodEventLogs;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.freeflow.core.AbsLayoutContainer.setOnItemSelectedListener",
	"Comment": "register a callback to be invoked when an item in this adapterview has\tbeen selected.",
	"Method": "void setOnItemSelectedListener(OnItemSelectedListener listener){\r\n    mOnItemSelectedListener = listener;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.slideExpand.AbstractSlideExpandableListAdapter.readBitSet",
	"Comment": "utility methods to read and write a bitset from and to a parcel",
	"Method": "BitSet readBitSet(Parcel src){\r\n    BitSet set = new BitSet();\r\n    if (src == null) {\r\n        return set;\r\n    }\r\n    int cardinality = src.readInt();\r\n    for (int i = 0; i < cardinality; i++) {\r\n        set.set(src.readInt());\r\n    }\r\n    return set;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.cropperimage.util.HandleUtil.isInCornerTargetZone",
	"Comment": "determines if the specified coordinate is in the target touch zone for acorner handle.",
	"Method": "boolean isInCornerTargetZone(float x,float y,float handleX,float handleY,float targetRadius){\r\n    if (Math.abs(x - handleX) <= targetRadius && Math.abs(y - handleY) <= targetRadius) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "test.dataprovider.DataProviderTest.allMethodsShouldBeInvoked",
	"Comment": "make sure that if a test method fails in the middle of a data provider, the rest of the dataset is still run.",
	"Method": "void allMethodsShouldBeInvoked(){\r\n    InvokedMethodNameListener listener = run(FailedDataProviderSample.class);\r\n    assertThat(listener.getSucceedMethodNames()).containsExactly(\"f(1)\", \"f(3)\");\r\n    assertThat(listener.getFailedMethodNames()).containsExactly(\"f(2)\");\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.recyclerplayground.layout.StaticGridLayoutManager.getGlobalRowOfPosition",
	"Comment": "return the overall row index of this position in the global layout",
	"Method": "int getGlobalRowOfPosition(int position){\r\n    return position / getTotalColumnCount();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.rebound.Spring.setAtRest",
	"Comment": "set the spring to be at rest by making its end value equal to its current value and settingvelocity to 0.",
	"Method": "Spring setAtRest(){\r\n    mEndValue = mCurrentState.position;\r\n    mTempState.position = mCurrentState.position;\r\n    mCurrentState.velocity = 0;\r\n    return this;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.foldingLayout.FoldingLayout.throwCustomException",
	"Comment": "throws an exception if the number of views added to this layout exceeds",
	"Method": "void throwCustomException(int numOfChildViews){\r\n    if (numOfChildViews == 1) {\r\n        throw new NumberOfFoldingLayoutChildrenException(FOLDING_VIEW_EXCEPTION_MESSAGE);\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.tileView.widgets.Scroller.computeScrollOffset",
	"Comment": "call this when you want to know the new location.if it returns true,the animation is not yet finished.loc will be altered to provide thenew location.",
	"Method": "boolean computeScrollOffset(){\r\n    if (mFinished) {\r\n        return false;\r\n    }\r\n    int timePassed = (int) (AnimationUtils.currentAnimationTimeMillis() - mStartTime);\r\n    if (timePassed < mDuration) {\r\n        switch(mMode) {\r\n            case SCROLL_MODE:\r\n                float x = timePassed * mDurationReciprocal;\r\n                if (mInterpolator == null)\r\n                    x = viscousFluid(x);\r\n                else\r\n                    x = mInterpolator.getInterpolation(x);\r\n                mCurrX = mStartX + Math.round(x * mDeltaX);\r\n                mCurrY = mStartY + Math.round(x * mDeltaY);\r\n                break;\r\n            case FLING_MODE:\r\n                final float t = (float) timePassed / mDuration;\r\n                final int index = (int) (NB_SAMPLES * t);\r\n                final float t_inf = (float) index / NB_SAMPLES;\r\n                final float t_sup = (float) (index + 1) / NB_SAMPLES;\r\n                final float d_inf = SPLINE[index];\r\n                final float d_sup = SPLINE[index + 1];\r\n                final float distanceCoef = d_inf + (t - t_inf) / (t_sup - t_inf) * (d_sup - d_inf);\r\n                mCurrX = mStartX + Math.round(distanceCoef * (mFinalX - mStartX));\r\n                mCurrX = Math.min(mCurrX, mMaxX);\r\n                mCurrX = Math.max(mCurrX, mMinX);\r\n                mCurrY = mStartY + Math.round(distanceCoef * (mFinalY - mStartY));\r\n                mCurrY = Math.min(mCurrY, mMaxY);\r\n                mCurrY = Math.max(mCurrY, mMinY);\r\n                if (mCurrX == mFinalX && mCurrY == mFinalY) {\r\n                    mFinished = true;\r\n                }\r\n                break;\r\n        }\r\n    } else {\r\n        mCurrX = mFinalX;\r\n        mCurrY = mFinalY;\r\n        mFinished = true;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.imageprocessing.FastImageProcessingPipeline.addFilterToDestroy",
	"Comment": "adds a given filter to the list of filters to have its resources removed next time this pipeline \treceives an opengl context.the filter will still be usable and will recreate all of the destroyed\topengl objects next time it is used in the pipeline.",
	"Method": "void addFilterToDestroy(GLRenderer renderer){\r\n    synchronized (filtersToDestroy) {\r\n        filtersToDestroy.add(renderer);\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.percentsamples.NavigationDrawerFragment.setUp",
	"Comment": "users of this fragment must call this method to set up the navigation drawer interactions.",
	"Method": "void setUp(int fragmentId,DrawerLayout drawerLayout){\r\n    mFragmentContainerView = getActivity().findViewById(fragmentId);\r\n    mDrawerLayout = drawerLayout;\r\n    mDrawerLayout.setDrawerShadow(R.drawable.drawer_shadow, GravityCompat.START);\r\n    ActionBar actionBar = getActivity().getActionBar();\r\n    mDrawerToggle = new ActionBarDrawerToggle(getActivity(), mDrawerLayout, R.drawable.ic_drawer, R.string.drawer_open, R.string.drawer_close) {\r\n        @Override\r\n        public void onDrawerClosed(View drawerView) {\r\n            super.onDrawerClosed(drawerView);\r\n            if (!isAdded()) {\r\n                return;\r\n            }\r\n            getActivity().invalidateOptionsMenu();\r\n        }\r\n        @Override\r\n        public void onDrawerOpened(View drawerView) {\r\n            super.onDrawerOpened(drawerView);\r\n            if (!isAdded()) {\r\n                return;\r\n            }\r\n            if (!mUserLearnedDrawer) {\r\n                mUserLearnedDrawer = true;\r\n                SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getActivity());\r\n                sp.edit().putBoolean(PREF_USER_LEARNED_DRAWER, true).commit();\r\n            }\r\n            getActivity().invalidateOptionsMenu();\r\n        }\r\n    };\r\n    if (!mUserLearnedDrawer && !mFromSavedInstanceState) {\r\n        mDrawerLayout.openDrawer(mFragmentContainerView);\r\n    }\r\n    mDrawerLayout.post(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            mDrawerToggle.syncState();\r\n        }\r\n    });\r\n    mDrawerLayout.setDrawerListener(mDrawerToggle);\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.percentsamples.NavigationDrawerFragment.setUp",
	"Comment": "users of this fragment must call this method to set up the navigation drawer interactions.",
	"Method": "void setUp(int fragmentId,DrawerLayout drawerLayout){\r\n    super.onDrawerClosed(drawerView);\r\n    if (!isAdded()) {\r\n        return;\r\n    }\r\n    getActivity().invalidateOptionsMenu();\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.percentsamples.NavigationDrawerFragment.setUp",
	"Comment": "users of this fragment must call this method to set up the navigation drawer interactions.",
	"Method": "void setUp(int fragmentId,DrawerLayout drawerLayout){\r\n    super.onDrawerOpened(drawerView);\r\n    if (!isAdded()) {\r\n        return;\r\n    }\r\n    if (!mUserLearnedDrawer) {\r\n        mUserLearnedDrawer = true;\r\n        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getActivity());\r\n        sp.edit().putBoolean(PREF_USER_LEARNED_DRAWER, true).commit();\r\n    }\r\n    getActivity().invalidateOptionsMenu();\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.percentsamples.NavigationDrawerFragment.setUp",
	"Comment": "users of this fragment must call this method to set up the navigation drawer interactions.",
	"Method": "void setUp(int fragmentId,DrawerLayout drawerLayout){\r\n    mDrawerToggle.syncState();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.tileView.layouts.ZoomPanLayout.getClip",
	"Comment": "returns the single child of the zoompanlayout, a viewgroup that serves as an intermediary container",
	"Method": "View getClip(){\r\n    return clip;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.customFonts.CalligraphyUtils.pullFontPathFromView",
	"Comment": "tries to pull the custom attribute directly from the textview.",
	"Method": "String pullFontPathFromView(Context context,AttributeSet attrs,int attributeId){\r\n    if (attributeId == -1)\r\n        return null;\r\n    final String attributeName;\r\n    try {\r\n        attributeName = context.getResources().getResourceEntryName(attributeId);\r\n    } catch (Resources.NotFoundException e) {\r\n        return null;\r\n    }\r\n    final int stringResourceId = attrs.getAttributeResourceValue(null, attributeName, -1);\r\n    return stringResourceId > 0 ? context.getString(stringResourceId) : attrs.getAttributeValue(null, attributeName);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.weekview.WeekView.expandEventsToMaxWidth",
	"Comment": "expands all the events to maximum possible width. the events will try to occupy maximumspace available horizontally.",
	"Method": "void expandEventsToMaxWidth(List<EventRect> collisionGroup){\r\n    List<List<EventRect>> columns = new ArrayList<List<EventRect>>();\r\n    columns.add(new ArrayList<EventRect>());\r\n    for (EventRect eventRect : collisionGroup) {\r\n        boolean isPlaced = false;\r\n        for (List<EventRect> column : columns) {\r\n            if (column.size() == 0) {\r\n                column.add(eventRect);\r\n                isPlaced = true;\r\n            } else if (!isEventsCollide(eventRect.event, column.get(column.size() - 1).event)) {\r\n                column.add(eventRect);\r\n                isPlaced = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!isPlaced) {\r\n            List<EventRect> newColumn = new ArrayList<EventRect>();\r\n            newColumn.add(eventRect);\r\n            columns.add(newColumn);\r\n        }\r\n    }\r\n    int maxRowCount = columns.get(0).size();\r\n    for (int i = 0; i < maxRowCount; i++) {\r\n        float j = 0;\r\n        for (List<EventRect> column : columns) {\r\n            if (column.size() >= i + 1) {\r\n                EventRect eventRect = column.get(i);\r\n                eventRect.width = 1f / columns.size();\r\n                eventRect.left = j / columns.size();\r\n                eventRect.top = eventRect.event.getStartTime().get(Calendar.HOUR_OF_DAY) * 60 + eventRect.event.getStartTime().get(Calendar.MINUTE);\r\n                eventRect.bottom = eventRect.event.getEndTime().get(Calendar.HOUR_OF_DAY) * 60 + eventRect.event.getEndTime().get(Calendar.MINUTE);\r\n                ;\r\n                mEventRects.add(eventRect);\r\n            }\r\n            j++;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.recyclerplayground.layout.FixedGridLayoutManager.setTotalColumnCount",
	"Comment": "set the number of columns the layout manager will use. this willtrigger a layout update.",
	"Method": "void setTotalColumnCount(int count){\r\n    mTotalColumnCount = count;\r\n    requestLayout();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.animation.AnimatorSet.setDuration",
	"Comment": "sets the length of each of the current child animations of this animatorset. by default,each child animation will use its own duration. if the duration is set on the animatorset,then each child animation inherits this duration.",
	"Method": "AnimatorSet setDuration(long duration){\r\n    if (duration < 0) {\r\n        throw new IllegalArgumentException(\"duration must be a value of zero or greater\");\r\n    }\r\n    for (Node node : mNodes) {\r\n        node.animation.setDuration(duration);\r\n    }\r\n    mDuration = duration;\r\n    return this;\r\n}"
}, {
	"Path": "com.marshalchen.common.commonUtils.moduleUtils.WebViewUtils.getWebSettings",
	"Comment": "a webview setting which enable javascript ,domstorage and file access.",
	"Method": "WebSettings getWebSettings(WebView webView,String appCacheDir){\r\n    WebSettings wSet = webView.getSettings();\r\n    wSet.setJavaScriptEnabled(true);\r\n    wSet.setDomStorageEnabled(true);\r\n    wSet.setAppCachePath(appCacheDir);\r\n    wSet.setAllowFileAccess(true);\r\n    wSet.setAppCacheEnabled(true);\r\n    wSet.setCacheMode(WebSettings.LOAD_DEFAULT);\r\n    return wSet;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.rippleDrawable.RippleDrawable.tryRippleExit",
	"Comment": "attempts to start an exit animation for the active hotspot. fails ifthere is no active hotspot.",
	"Method": "void tryRippleExit(){\r\n    if (mRipple != null) {\r\n        if (mExitingRipples == null) {\r\n            mExitingRipples = new Ripple[MAX_RIPPLES];\r\n        }\r\n        mExitingRipples[mExitingRipplesCount++] = mRipple;\r\n        mRipple.exit();\r\n        mRipple = null;\r\n    }\r\n}"
}, {
	"Path": "com.android.datetimepicker.date.DayPickerView.setUpListView",
	"Comment": "sets all the required fields for the list view. override this method toset a different list view behavior.",
	"Method": "void setUpListView(){\r\n    setCacheColorHint(0);\r\n    setDivider(null);\r\n    setItemsCanFocus(true);\r\n    setFastScrollEnabled(false);\r\n    setVerticalScrollBarEnabled(false);\r\n    setOnScrollListener(this);\r\n    setFadingEdgeLength(0);\r\n    setFriction(ViewConfiguration.getScrollFriction() * mFriction);\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.recyclerplayground.layout.StaticGridLayoutManager.findViewByPosition",
	"Comment": "this is a helper method used by recyclerview to determineif a specific child view can be returned.",
	"Method": "View findViewByPosition(int position){\r\n    for (int i = 0; i < getChildCount(); i++) {\r\n        if (positionOfIndex(i) == position) {\r\n            return getChildAt(i);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.motion.ParallaxImageView.setTiltSensitivity",
	"Comment": "sets the parallax tilt sensitivity for the image view. the stronger the sensitivity,the more a given tilt will adjust the image and the smaller needed tilt to reach theimage bounds.",
	"Method": "void setTiltSensitivity(float sensitivity){\r\n    mSensorInterpreter.setTiltSensitivity(sensitivity);\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase1Scenario1.verifyThatTestMethodsRunInParallelThreads",
	"Comment": "verifies that the test methods execute in different threads in parallel fashion.",
	"Method": "void verifyThatTestMethodsRunInParallelThreads(){\r\n    verifySimultaneousTestMethods(testMethodLevelEventLogs, TEST, 5);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.easyandroidanimations.FoldAnimation.setAnchorFactor",
	"Comment": "the available anchor factors range from 0 to 1. for example, in order to\tanchor the fold at the top, the anchor factor should be 0.",
	"Method": "FoldAnimation setAnchorFactor(float anchorFactor){\r\n    this.anchorFactor = anchorFactor;\r\n    return this;\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase3Scenario1.verifyThatTestMethodsRunInParallelThreads",
	"Comment": "verifies that the test methods execute in different threads in parallel fashion.",
	"Method": "void verifyThatTestMethodsRunInParallelThreads(){\r\n    verifyParallelTestMethodsWithNonParallelDataProvider(getTestMethodLevelEventLogsForTest(SUITE, TEST), TEST, expectedInvocationCounts, 5, 5);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.ImageFilter.MonitorFilter.getValidInterval",
	"Comment": "method to calculate an appropriate interval for flicker lines",
	"Method": "int getValidInterval(int a_value){\r\n    if (a_value < 0)\r\n        return 0;\r\n    if (a_value > 255)\r\n        return 255;\r\n    return a_value;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.modifysys.ViewPager.setInternalPageChangeListener",
	"Comment": "set a separate onpagechangelistener for internal use by the support library.",
	"Method": "OnPageChangeListener setInternalPageChangeListener(OnPageChangeListener listener){\r\n    OnPageChangeListener oldListener = mInternalPageChangeListener;\r\n    mInternalPageChangeListener = listener;\r\n    return oldListener;\r\n}"
}, {
	"Path": "org.isoron.uhabits.core.io.HabitsCSVExporter.getTimeframe",
	"Comment": "gets the overall timeframe of the selected habits.the timeframe is an array containing the oldest timestamp among the habits and thenewest timestamp among the habits.both timestamps are in milliseconds.",
	"Method": "Timestamp[] getTimeframe(){\r\n    Timestamp oldest = Timestamp.ZERO.plus(1000000);\r\n    Timestamp newest = Timestamp.ZERO;\r\n    for (Habit h : selectedHabits) {\r\n        if (h.getRepetitions().getOldest() == null || h.getRepetitions().getNewest() == null)\r\n            continue;\r\n        Timestamp currOld = h.getRepetitions().getOldest().getTimestamp();\r\n        Timestamp currNew = h.getRepetitions().getNewest().getTimestamp();\r\n        oldest = currOld.isOlderThan(oldest) ? oldest : currOld;\r\n        newest = currNew.isNewerThan(newest) ? newest : currNew;\r\n    }\r\n    return new Timestamp[] { oldest, newest };\r\n}"
}, {
	"Path": "test.thread.parallelization.TestNgRunStateTracker.getTestMethodListenerStartEventLogsForTest",
	"Comment": "get the test method listener onteststart event logs for the specified suite and test",
	"Method": "List<EventLog> getTestMethodListenerStartEventLogsForTest(String suiteName,String testName){\r\n    List<EventLog> testMethodStartEventLogs = new ArrayList();\r\n    for (EventLog eventLog : eventLogs) {\r\n        if (eventLog.getEvent() == TestNgRunEvent.LISTENER_TEST_METHOD_START && belongsToTest(suiteName, testName, eventLog)) {\r\n            testMethodStartEventLogs.add(eventLog);\r\n        }\r\n    }\r\n    return testMethodStartEventLogs;\r\n}"
}, {
	"Path": "com.marshalchen.common.ui.ShimmerFrameLayout.setMaskOffsetY",
	"Comment": "translate the mask offset vertically. used by the animator.",
	"Method": "void setMaskOffsetY(int maskOffsetY){\r\n    if (mMaskOffsetY == maskOffsetY) {\r\n        return;\r\n    }\r\n    mMaskOffsetY = maskOffsetY;\r\n    invalidate();\r\n}"
}, {
	"Path": "com.marshalchen.common.ui.ShimmerFrameLayout.setMaskOffsetX",
	"Comment": "translate the mask offset horizontally. used by the animator.",
	"Method": "void setMaskOffsetX(int maskOffsetX){\r\n    if (mMaskOffsetX == maskOffsetX) {\r\n        return;\r\n    }\r\n    mMaskOffsetX = maskOffsetX;\r\n    invalidate();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.widget.MaterialProgressDrawable.updateSizes",
	"Comment": "set the overall size for the progress spinner. this updates the radiusand stroke width of the ring.",
	"Method": "void updateSizes(int size){\r\n    if (size == LARGE) {\r\n        setSizeParameters(CIRCLE_DIAMETER_LARGE, CIRCLE_DIAMETER_LARGE, CENTER_RADIUS_LARGE, STROKE_WIDTH_LARGE, ARROW_WIDTH_LARGE, ARROW_HEIGHT_LARGE);\r\n    } else {\r\n        setSizeParameters(CIRCLE_DIAMETER, CIRCLE_DIAMETER, CENTER_RADIUS, STROKE_WIDTH, ARROW_WIDTH, ARROW_HEIGHT);\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.imageprocessing.GLRenderer.getBackgroundRed",
	"Comment": "returns the red component of the background colour currently set for this glrenderer.",
	"Method": "float getBackgroundRed(){\r\n    return red;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.easyandroidanimations.UnfoldAnimation.getOrientation",
	"Comment": "the available orientations are orientation.horizontal and\torientation.vertical.",
	"Method": "Orientation getOrientation(){\r\n    return orientation;\r\n}"
}, {
	"Path": "org.isoron.uhabits.core.models.CheckmarkList.getValues",
	"Comment": "returns the values of the checkmarks that fall inside a certain intervalof time.the values are returned in an array containing one integer value for eachday of the interval. the first entry corresponds to the most recent dayin the interval. each subsequent entry corresponds to one day older thanthe previous entry. the boundaries of the time interval are included.",
	"Method": "int[] getValues(Timestamp from,Timestamp to){\r\n    if (from.isNewerThan(to))\r\n        return new int[0];\r\n    List<Checkmark> checkmarks = getByInterval(from, to);\r\n    int[] values = new int[checkmarks.size()];\r\n    int i = 0;\r\n    for (Checkmark c : checkmarks) values[i++] = c.getValue();\r\n    return values;\r\n}"
}, {
	"Path": "com.marshalchen.common.commonUtils.fileUtils.ParcelUtils.readHashMap",
	"Comment": "read a hashmap from a parcel, class of key and value can parcelable both",
	"Method": "Map<K, V> readHashMap(Parcel in,ClassLoader loader){\r\n    if (in == null) {\r\n        return null;\r\n    }\r\n    int size = in.readInt();\r\n    if (size == -1) {\r\n        return null;\r\n    }\r\n    Map<K, V> map = new HashMap<K, V>();\r\n    for (int i = 0; i < size; i++) {\r\n        map.put((K) in.readParcelable(loader), (V) in.readParcelable(loader));\r\n    }\r\n    return map;\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase2Scenario1.verifyThatMethodLevelEventsRunInDifferentThreadsFromSuiteAndTestLevelEvents",
	"Comment": "verifies that the test method listener and execution events for a given test method all run in the same thread.",
	"Method": "void verifyThatMethodLevelEventsRunInDifferentThreadsFromSuiteAndTestLevelEvents(){\r\n    verifyEventThreadsSpawnedAfter(getAllSuiteListenerStartEventLogs().get(0).getThreadId(), testMethodLevelEventLogs, \"All the thread IDs for the test method level events should be greater than the thread ID for the \" + \"suite and test level events. The expectation is that since the suite and test level events \" + \"are running sequentially, and all the test methods are running in parallel, new threads \" + \"will be spawned after the thread executing the suite and test level events when new methods \" + \"begin executing. Suite and test level events thread ID: \" + getAllSuiteListenerStartEventLogs().get(0).getThreadId() + \". Test method level event logs: \" + testMethodLevelEventLogs);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassAFiveMethodsWithNoDepsSample.class, SUITE_A, SUITE_A_TEST_A);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassCSixMethodsWithNoDepsSample.class, SUITE_A, SUITE_A_TEST_A);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassEFiveMethodsWithNoDepsSample.class, SUITE_B, SUITE_B_TEST_A);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassDThreeMethodsWithNoDepsSample.class, SUITE_B, SUITE_B_TEST_B);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassBFourMethodsWithNoDepsSample.class, SUITE_B, SUITE_B_TEST_B);\r\n    verifyEventsForTestMethodsRunInTheSameThread(TestClassFSixMethodsWithNoDepsSample.class, SUITE_B, SUITE_B_TEST_B);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.viewpagerindicator.TitlePageIndicator.calculateAllBounds",
	"Comment": "calculate views bounds and scroll them according to the current index",
	"Method": "ArrayList<Rect> calculateAllBounds(Paint paint){\r\n    ArrayList<Rect> list = new ArrayList<Rect>();\r\n    final int count = mViewPager.getAdapter().getCount();\r\n    final int width = getWidth();\r\n    final int halfWidth = width / 2;\r\n    for (int i = 0; i < count; i++) {\r\n        Rect bounds = calcBounds(i, paint);\r\n        int w = bounds.right - bounds.left;\r\n        int h = bounds.bottom - bounds.top;\r\n        bounds.left = (int) (halfWidth - (w / 2f) + ((i - mCurrentPage - mPageOffset) * width));\r\n        bounds.right = bounds.left + w;\r\n        bounds.top = 0;\r\n        bounds.bottom = h;\r\n        list.add(bounds);\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.animation.ValueAnimator.setValues",
	"Comment": "sets the values, per property, being animated between. this function is called internallyby the constructors of valueanimator that take a list of values. but an valueanimator canbe constructed without values and this method can be called to set the values manuallyinstead.",
	"Method": "void setValues(PropertyValuesHolder values){\r\n    int numValues = values.length;\r\n    mValues = values;\r\n    mValuesMap = new HashMap<String, PropertyValuesHolder>(numValues);\r\n    for (int i = 0; i < numValues; ++i) {\r\n        PropertyValuesHolder valuesHolder = (PropertyValuesHolder) values[i];\r\n        mValuesMap.put(valuesHolder.getPropertyName(), valuesHolder);\r\n    }\r\n    mInitialized = false;\r\n}"
}, {
	"Path": "org.testng.reporters.JUnitXMLReporter.onFinish",
	"Comment": "invoked after all the tests have run and all their configuration methods have been called.",
	"Method": "void onFinish(ITestContext context){\r\n    generateReport(context);\r\n    resetAll();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.kenburnsview.KenBurnsView.updateViewport",
	"Comment": "updates the viewport rect. this must be called every time the size of this view changes.",
	"Method": "void updateViewport(float width,float height){\r\n    mViewportRect.set(0, 0, width, height);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.view.ViewPropertyAnimatorPreHC.getDuration",
	"Comment": "returns the current duration of property animations. if the duration was set on thisobject, that value is returned. otherwise, the default value of the underlying animatoris returned.",
	"Method": "long getDuration(){\r\n    if (mDurationSet) {\r\n        return mDuration;\r\n    } else {\r\n        return new ValueAnimator().getDuration();\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.easyandroidanimations.FoldLayout.setFoldFactor",
	"Comment": "sets the fold factor of the folding view and updates all the correspondingmatrices and values to account for the new fold factor. once that is complete,it redraws itself with the new fold.",
	"Method": "void setFoldFactor(float foldFactor){\r\n    if (foldFactor != mFoldFactor) {\r\n        mFoldFactor = foldFactor;\r\n        calculateMatrices();\r\n        invalidate();\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.animation.ValueAnimator.endAnimation",
	"Comment": "called internally to end an animation by removing it from the animations list. must becalled on the ui thread.",
	"Method": "void endAnimation(){\r\n    sAnimations.get().remove(this);\r\n    sPendingAnimations.get().remove(this);\r\n    sDelayedAnims.get().remove(this);\r\n    mPlayingState = STOPPED;\r\n    if (mRunning && mListeners != null) {\r\n        ArrayList<AnimatorListener> tmpListeners = (ArrayList<AnimatorListener>) mListeners.clone();\r\n        int numListeners = tmpListeners.size();\r\n        for (int i = 0; i < numListeners; ++i) {\r\n            tmpListeners.get(i).onAnimationEnd(this);\r\n        }\r\n    }\r\n    mRunning = false;\r\n    mStarted = false;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.dragSortListView.DragSortCursorAdapter.getCursorPositions",
	"Comment": "get the current order of cursor positions presented by thelist.",
	"Method": "ArrayList<Integer> getCursorPositions(){\r\n    ArrayList<Integer> result = new ArrayList<Integer>();\r\n    for (int i = 0; i < getCount(); ++i) {\r\n        result.add(mListMapping.get(i, i));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.rippleDrawable.RippleDrawable.clearHotspots",
	"Comment": "cancels and removes the active ripple, all exiting ripples, and thebackground. nothing will be drawn after this method is called.",
	"Method": "void clearHotspots(){\r\n    boolean needsDraw = false;\r\n    if (mRipple != null) {\r\n        needsDraw = false;\r\n        mRipple.cancel();\r\n        mRipple = null;\r\n    }\r\n    if (mBackground != null) {\r\n        needsDraw = mBackground.isHardwareAnimating();\r\n        mBackground.cancel();\r\n        mBackground = null;\r\n    }\r\n    needsDraw |= cancelExitingRipples();\r\n    mNeedsDraw = needsDraw;\r\n    invalidateSelf();\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase1Scenario1.verifyTestMethodLevelEventsAllOccurBetweenTestListenerStartAndFinish",
	"Comment": "verifies that all the test method level events execute between the test listener onstart and onfinish methods",
	"Method": "void verifyTestMethodLevelEventsAllOccurBetweenTestListenerStartAndFinish(){\r\n    verifyEventsOccurBetween(testListenerOnStartEventLog, testMethodLevelEventLogs, testListenerOnFinishEventLog, \"All of the test method level event logs should have timestamps between the test listener's onStart \" + \"and onFinish event logs. Test Listener onStart event log: \" + testListenerOnStartEventLog + \". Test Listener onFinish event log: \" + testListenerOnFinishEventLog + \". Test method level \" + \"event logs: \" + testMethodLevelEventLogs);\r\n}"
}, {
	"Path": "com.marshalchen.common.commonUtils.urlUtils.HttpsUtils.buildSslSocketFactory",
	"Comment": "build sslsocketfactory using certificate file from assets.",
	"Method": "SSLSocketFactory buildSslSocketFactory(Context context,String certFilePath){\r\n    try {\r\n        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\r\n        InputStream is = context.getResources().getAssets().open(crtUrl);\r\n        InputStream caInput = new BufferedInputStream(is);\r\n        Certificate ca;\r\n        try {\r\n            ca = cf.generateCertificate(caInput);\r\n        } finally {\r\n            caInput.close();\r\n        }\r\n        String keyStoreType = KeyStore.getDefaultType();\r\n        KeyStore keyStore = KeyStore.getInstance(keyStoreType);\r\n        keyStore.load(null, null);\r\n        keyStore.setCertificateEntry(\"ca\", ca);\r\n        String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\r\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\r\n        tmf.init(keyStore);\r\n        SSLContext contexts = SSLContext.getInstance(\"TLS\");\r\n        contexts.init(null, tmf.getTrustManagers(), null);\r\n        return contexts.getSocketFactory();\r\n    } catch (NoSuchAlgorithmException e) {\r\n        e.printStackTrace();\r\n    } catch (KeyStoreException e) {\r\n        e.printStackTrace();\r\n    } catch (KeyManagementException e) {\r\n        e.printStackTrace();\r\n    } catch (CertificateException e) {\r\n        e.printStackTrace();\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.dynamicgrid.DynamicGridView.isPostHoneycomb",
	"Comment": "seems that gridview before honeycomb not support stable id in proper way.that cause bugs on view recycle if we will animate or change visibility state for items.",
	"Method": "boolean isPostHoneycomb(){\r\n    return Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.tileView.tileview.TileView.unscale",
	"Comment": "divides a number by the current scale value, effectively flipping scaled values.this can be useful when\tdetermining a relative position or dimension from a real pixel value.",
	"Method": "double unscale(double value){\r\n    return value / getScale();\r\n}"
}, {
	"Path": "com.marshalchen.common.commonUtils.urlUtils.HttpUtilsAsync.postUseCookie",
	"Comment": "perform a http post request with cookies which are defined in hashmap",
	"Method": "void postUseCookie(Context context,String url,HashMap hashMap,AsyncHttpResponseHandler responseHandler){\r\n    PersistentCookieStore myCookieStore = new PersistentCookieStore(context);\r\n    if (BasicUtils.judgeNotNull(hashMap)) {\r\n        Iterator iterator = hashMap.entrySet().iterator();\r\n        while (iterator.hasNext()) {\r\n            Map.Entry entry = (Map.Entry) iterator.next();\r\n            Object key = entry.getKey();\r\n            Object value = entry.getValue();\r\n            Cookie cookie = new BasicClientCookie(key.toString(), value.toString());\r\n            myCookieStore.addCookie(cookie);\r\n        }\r\n    }\r\n    AsyncHttpClient client = new AsyncHttpClient();\r\n    client.setCookieStore(myCookieStore);\r\n    client.post(getAbsoluteUrl(url), responseHandler);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.stickygridheaders.StickyGridHeadersGridView.getHeaderAt",
	"Comment": "gets the header at an item position. however, the position must be thatof a headerfiller.",
	"Method": "View getHeaderAt(int position){\r\n    if (position == MATCHED_STICKIED_HEADER) {\r\n        return mStickiedHeader;\r\n    }\r\n    try {\r\n        return (View) getChildAt(position).getTag();\r\n    } catch (Exception e) {\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.Thumbnails.fromFilenames",
	"Comment": "indicate to make thumbnails for images with the specified filenames.",
	"Method": "Builder<File> fromFilenames(Iterable<String> files){\r\n    checkForNull(files, \"Cannot specify null for input files.\");\r\n    checkForEmpty(files, \"Cannot specify an empty collection for input files.\");\r\n    return Builder.ofStrings(files);\r\n}"
}, {
	"Path": "com.marshalchen.common.ui.roundedimageview.RoundedImageView.setScaleType",
	"Comment": "controls how the image should be resized or moved to match the sizeof this imageview.",
	"Method": "void setScaleType(ScaleType scaleType){\r\n    assert scaleType != null;\r\n    if (mScaleType != scaleType) {\r\n        mScaleType = scaleType;\r\n        switch(scaleType) {\r\n            case CENTER:\r\n            case CENTER_CROP:\r\n            case CENTER_INSIDE:\r\n            case FIT_CENTER:\r\n            case FIT_START:\r\n            case FIT_END:\r\n            case FIT_XY:\r\n                super.setScaleType(ScaleType.FIT_XY);\r\n                break;\r\n            default:\r\n                super.setScaleType(scaleType);\r\n                break;\r\n        }\r\n        updateDrawableAttrs();\r\n        updateBackgroundDrawableAttrs(false);\r\n        invalidate();\r\n    }\r\n}"
}, {
	"Path": "org.testng.junit.JUnitTestRunner.getTestMethods",
	"Comment": "needed from testrunner in order to figure out what junit test methods were run.",
	"Method": "List<ITestNGMethod> getTestMethods(){\r\n    return m_methods;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.easyandroidanimations.UnfoldAnimation.setAnchorFactor",
	"Comment": "the available anchor factors range from 0 to 1. for example, in order to\tanchor the fold on the left, the anchor factor should be 0.",
	"Method": "UnfoldAnimation setAnchorFactor(float anchorFactor){\r\n    this.anchorFactor = anchorFactor;\r\n    return this;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.cropimage.HighlightView.computeLayout",
	"Comment": "maps the cropping rectangle from image space to screen space",
	"Method": "Rect computeLayout(){\r\n    RectF r = new RectF(cropRect.left, cropRect.top, cropRect.right, cropRect.bottom);\r\n    matrix.mapRect(r);\r\n    return new Rect(Math.round(r.left), Math.round(r.top), Math.round(r.right), Math.round(r.bottom));\r\n}"
}, {
	"Path": "com.marshalchen.common.ui.ShimmerFrameLayout.getFixedHeight",
	"Comment": "get the fixed height of the highlight mask, or 0 if it is not set. by default it is 0.",
	"Method": "int getFixedHeight(){\r\n    return mMask.fixedHeight;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.listviewanimations.widget.DynamicListView.touchEventsEnded",
	"Comment": "resets all the appropriate fields to a default state while also animatingthe hover cell back to its correct location.",
	"Method": "void touchEventsEnded(){\r\n    final View mobileView = getViewForId(mMobileItemId);\r\n    if (mCellIsMobile || mIsWaitingForScrollFinish) {\r\n        mCellIsMobile = false;\r\n        mIsWaitingForScrollFinish = false;\r\n        mIsMobileScrolling = false;\r\n        mActivePointerId = INVALID_POINTER_ID;\r\n        setTranscriptMode(mOriginalTranscriptMode);\r\n        if (mScrollState != OnScrollListener.SCROLL_STATE_IDLE) {\r\n            mIsWaitingForScrollFinish = true;\r\n            return;\r\n        }\r\n        mHoverCellCurrentBounds.offsetTo(mHoverCellOriginalBounds.left, mobileView.getTop());\r\n        ObjectAnimator hoverViewAnimator = ObjectAnimator.ofObject(mHoverCell, \"bounds\", sBoundEvaluator, mHoverCellCurrentBounds);\r\n        hoverViewAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\r\n            @Override\r\n            public void onAnimationUpdate(ValueAnimator valueAnimator) {\r\n                invalidate();\r\n            }\r\n        });\r\n        hoverViewAnimator.addListener(new AnimatorListenerAdapter() {\r\n            @Override\r\n            public void onAnimationStart(Animator animation) {\r\n                setEnabled(false);\r\n            }\r\n            @Override\r\n            public void onAnimationEnd(Animator animation) {\r\n                mAboveItemId = INVALID_ID;\r\n                mMobileItemId = INVALID_ID;\r\n                mBelowItemId = INVALID_ID;\r\n                mobileView.setVisibility(VISIBLE);\r\n                mHoverCell = null;\r\n                setEnabled(true);\r\n                invalidate();\r\n                if (mOnItemMovedListener != null) {\r\n                    mOnItemMovedListener.onItemMoved(mLastMovedToIndex - getHeaderViewsCount());\r\n                }\r\n            }\r\n        });\r\n        hoverViewAnimator.start();\r\n    } else {\r\n        touchEventsCancelled();\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.listviewanimations.widget.DynamicListView.touchEventsEnded",
	"Comment": "resets all the appropriate fields to a default state while also animatingthe hover cell back to its correct location.",
	"Method": "void touchEventsEnded(){\r\n    invalidate();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.listviewanimations.widget.DynamicListView.touchEventsEnded",
	"Comment": "resets all the appropriate fields to a default state while also animatingthe hover cell back to its correct location.",
	"Method": "void touchEventsEnded(){\r\n    setEnabled(false);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.listviewanimations.widget.DynamicListView.touchEventsEnded",
	"Comment": "resets all the appropriate fields to a default state while also animatingthe hover cell back to its correct location.",
	"Method": "void touchEventsEnded(){\r\n    mAboveItemId = INVALID_ID;\r\n    mMobileItemId = INVALID_ID;\r\n    mBelowItemId = INVALID_ID;\r\n    mobileView.setVisibility(VISIBLE);\r\n    mHoverCell = null;\r\n    setEnabled(true);\r\n    invalidate();\r\n    if (mOnItemMovedListener != null) {\r\n        mOnItemMovedListener.onItemMoved(mLastMovedToIndex - getHeaderViewsCount());\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.ui.ShimmerFrameLayout.getShimmerAnimation",
	"Comment": "object, which is responsible for driving the highlight mask animation.",
	"Method": "Animator getShimmerAnimation(){\r\n    if (mAnimator != null) {\r\n        return mAnimator;\r\n    }\r\n    int width = getWidth();\r\n    int height = getHeight();\r\n    switch(mMask.shape) {\r\n        default:\r\n        case LINEAR:\r\n            switch(mMask.angle) {\r\n                default:\r\n                case CW_0:\r\n                    mMaskTranslation.set(-width, 0, width, 0);\r\n                    break;\r\n                case CW_90:\r\n                    mMaskTranslation.set(0, -height, 0, height);\r\n                    break;\r\n                case CW_180:\r\n                    mMaskTranslation.set(width, 0, -width, 0);\r\n                    break;\r\n                case CW_270:\r\n                    mMaskTranslation.set(0, height, 0, -height);\r\n                    break;\r\n            }\r\n    }\r\n    mAnimator = ValueAnimator.ofFloat(0.0f, 1.0f + (float) mRepeatDelay / mDuration);\r\n    mAnimator.setDuration(mDuration + mRepeatDelay);\r\n    mAnimator.setRepeatCount(mRepeatCount);\r\n    mAnimator.setRepeatMode(mRepeatMode);\r\n    mAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\r\n        @Override\r\n        public void onAnimationUpdate(ValueAnimator animation) {\r\n            float value = Math.max(0.0f, Math.min(1.0f, (Float) animation.getAnimatedValue()));\r\n            setMaskOffsetX((int) (mMaskTranslation.fromX * (1 - value) + mMaskTranslation.toX * value));\r\n            setMaskOffsetY((int) (mMaskTranslation.fromY * (1 - value) + mMaskTranslation.toY * value));\r\n        }\r\n    });\r\n    return mAnimator;\r\n}"
}, {
	"Path": "com.marshalchen.common.ui.ShimmerFrameLayout.getShimmerAnimation",
	"Comment": "object, which is responsible for driving the highlight mask animation.",
	"Method": "Animator getShimmerAnimation(){\r\n    float value = Math.max(0.0f, Math.min(1.0f, (Float) animation.getAnimatedValue()));\r\n    setMaskOffsetX((int) (mMaskTranslation.fromX * (1 - value) + mMaskTranslation.toX * value));\r\n    setMaskOffsetY((int) (mMaskTranslation.fromY * (1 - value) + mMaskTranslation.toY * value));\r\n}"
}, {
	"Path": "com.marshalchen.common.ui.DropDownListView.setHasMore",
	"Comment": "set whether has more. if hasmore is false, onbottm will not be called when listview scroll to bottom",
	"Method": "void setHasMore(boolean hasMore){\r\n    this.hasMore = hasMore;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.view.ViewPropertyAnimatorPreHC.getValue",
	"Comment": "this method gets the value of the named property from the view object.",
	"Method": "float getValue(int propertyConstant){\r\n    switch(propertyConstant) {\r\n        case TRANSLATION_X:\r\n            return mProxy.getTranslationX();\r\n        case TRANSLATION_Y:\r\n            return mProxy.getTranslationY();\r\n        case ROTATION:\r\n            return mProxy.getRotation();\r\n        case ROTATION_X:\r\n            return mProxy.getRotationX();\r\n        case ROTATION_Y:\r\n            return mProxy.getRotationY();\r\n        case SCALE_X:\r\n            return mProxy.getScaleX();\r\n        case SCALE_Y:\r\n            return mProxy.getScaleY();\r\n        case X:\r\n            return mProxy.getX();\r\n        case Y:\r\n            return mProxy.getY();\r\n        case ALPHA:\r\n            return mProxy.getAlpha();\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.recyclerplayground.fragments.NavigationDrawerFragment.setUp",
	"Comment": "users of this fragment must call this method to set up the navigation drawer interactions.",
	"Method": "void setUp(int fragmentId,DrawerLayout drawerLayout){\r\n    mFragmentContainerView = getActivity().findViewById(fragmentId);\r\n    mDrawerLayout = drawerLayout;\r\n    mDrawerLayout.setDrawerShadow(R.drawable.drawer_shadow, GravityCompat.START);\r\n    ActionBar actionBar = getActionBar();\r\n    actionBar.setDisplayHomeAsUpEnabled(true);\r\n    actionBar.setHomeButtonEnabled(true);\r\n    mDrawerToggle = new ActionBarDrawerToggle(getActivity(), mDrawerLayout, R.drawable.ic_drawer, R.string.drawer_open, R.string.drawer_close) {\r\n        @Override\r\n        public void onDrawerClosed(View drawerView) {\r\n            super.onDrawerClosed(drawerView);\r\n            if (!isAdded()) {\r\n                return;\r\n            }\r\n            getActivity().invalidateOptionsMenu();\r\n        }\r\n        @Override\r\n        public void onDrawerOpened(View drawerView) {\r\n            super.onDrawerOpened(drawerView);\r\n            if (!isAdded()) {\r\n                return;\r\n            }\r\n            if (!mUserLearnedDrawer) {\r\n                mUserLearnedDrawer = true;\r\n                SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getActivity());\r\n                sp.edit().putBoolean(PREF_USER_LEARNED_DRAWER, true).apply();\r\n            }\r\n            getActivity().invalidateOptionsMenu();\r\n        }\r\n    };\r\n    if (!mUserLearnedDrawer && !mFromSavedInstanceState) {\r\n        mDrawerLayout.openDrawer(mFragmentContainerView);\r\n    }\r\n    mDrawerLayout.post(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            mDrawerToggle.syncState();\r\n        }\r\n    });\r\n    mDrawerLayout.setDrawerListener(mDrawerToggle);\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.recyclerplayground.fragments.NavigationDrawerFragment.setUp",
	"Comment": "users of this fragment must call this method to set up the navigation drawer interactions.",
	"Method": "void setUp(int fragmentId,DrawerLayout drawerLayout){\r\n    super.onDrawerClosed(drawerView);\r\n    if (!isAdded()) {\r\n        return;\r\n    }\r\n    getActivity().invalidateOptionsMenu();\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.recyclerplayground.fragments.NavigationDrawerFragment.setUp",
	"Comment": "users of this fragment must call this method to set up the navigation drawer interactions.",
	"Method": "void setUp(int fragmentId,DrawerLayout drawerLayout){\r\n    super.onDrawerOpened(drawerView);\r\n    if (!isAdded()) {\r\n        return;\r\n    }\r\n    if (!mUserLearnedDrawer) {\r\n        mUserLearnedDrawer = true;\r\n        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getActivity());\r\n        sp.edit().putBoolean(PREF_USER_LEARNED_DRAWER, true).apply();\r\n    }\r\n    getActivity().invalidateOptionsMenu();\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.recyclerplayground.fragments.NavigationDrawerFragment.setUp",
	"Comment": "users of this fragment must call this method to set up the navigation drawer interactions.",
	"Method": "void setUp(int fragmentId,DrawerLayout drawerLayout){\r\n    mDrawerToggle.syncState();\r\n}"
}, {
	"Path": "com.android.datetimepicker.HapticFeedbackController.tryVibrate",
	"Comment": "try to vibrate. to prevent this becoming a single continuous vibration, nothing willhappen if we have vibrated very recently.",
	"Method": "void tryVibrate(){\r\n    if (mVibrator != null && mIsGloballyEnabled) {\r\n        long now = SystemClock.uptimeMillis();\r\n        if (now - mLastVibrate >= VIBRATE_DELAY_MS) {\r\n            mVibrator.vibrate(VIBRATE_LENGTH_MS);\r\n            mLastVibrate = now;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.slider.Tricks.ViewPagerEx.setAdapter",
	"Comment": "set a pageradapter that will supply views for this pager as needed.",
	"Method": "void setAdapter(PagerAdapter adapter){\r\n    if (mAdapter != null) {\r\n        mAdapter.unregisterDataSetObserver(mObserver);\r\n        mAdapter.startUpdate(this);\r\n        for (int i = 0; i < mItems.size(); i++) {\r\n            final ItemInfo ii = mItems.get(i);\r\n            mAdapter.destroyItem(this, ii.position, ii.object);\r\n        }\r\n        mAdapter.finishUpdate(this);\r\n        mItems.clear();\r\n        removeNonDecorViews();\r\n        mCurItem = 0;\r\n        scrollTo(0, 0);\r\n    }\r\n    final PagerAdapter oldAdapter = mAdapter;\r\n    mAdapter = adapter;\r\n    mExpectedAdapterCount = 0;\r\n    if (mAdapter != null) {\r\n        if (mObserver == null) {\r\n            mObserver = new PagerObserver();\r\n        }\r\n        mAdapter.registerDataSetObserver(mObserver);\r\n        mPopulatePending = false;\r\n        final boolean wasFirstLayout = mFirstLayout;\r\n        mFirstLayout = true;\r\n        mExpectedAdapterCount = mAdapter.getCount();\r\n        if (mRestoredCurItem >= 0) {\r\n            mAdapter.restoreState(mRestoredAdapterState, mRestoredClassLoader);\r\n            setCurrentItemInternal(mRestoredCurItem, false, true);\r\n            mRestoredCurItem = -1;\r\n            mRestoredAdapterState = null;\r\n            mRestoredClassLoader = null;\r\n        } else if (!wasFirstLayout) {\r\n            populate();\r\n        } else {\r\n            requestLayout();\r\n        }\r\n    }\r\n    if (mAdapterChangeListener != null && oldAdapter != adapter) {\r\n        mAdapterChangeListener.onAdapterChanged(oldAdapter, adapter);\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.freeflow.core.FreeFlowContainer.onLayoutChangeAnimationsCompleted",
	"Comment": "this method is called by the layoutanimator instance once\tall transition animations have been completed.",
	"Method": "void onLayoutChangeAnimationsCompleted(FreeFlowLayoutAnimator anim){\r\n    isAnimatingChanges = false;\r\n    logLifecycleEvent(\"layout change animations complete\");\r\n    for (FreeFlowItem freeflowItem : anim.getChangeSet().getRemoved()) {\r\n        View v = freeflowItem.view;\r\n        removeView(v);\r\n        returnItemToPoolIfNeeded(freeflowItem);\r\n    }\r\n    dispatchLayoutChangeAnimationsComplete();\r\n}"
}, {
	"Path": "org.testng.internal.Parameters.createInstantiationParameters",
	"Comment": "creates the parameters needed for constructing a test class instance.",
	"Method": "Object[] createInstantiationParameters(Constructor ctor,String methodAnnotation,IAnnotationFinder finder,String[] parameterNames,Map<String, String> params,XmlSuite xmlSuite){\r\n    return createParametersForConstructor(ctor, ctor.getParameterTypes(), finder.findOptionalValues(ctor), methodAnnotation, parameterNames, new MethodParameters(params, Collections.emptyMap()), xmlSuite);\r\n}"
}, {
	"Path": "com.marshalchen.ua.common.commonUtils.dbUtils.GreenDaoUtils.query",
	"Comment": "creates a repeatable query object based on the given raw sql where you can pass any where clause and arguments.",
	"Method": "Query query(AbstractDao dao,String queryString,String queryValue,Query query,AbstractDao dao,String queryString){\r\n    Query query = dao.queryBuilder().where(new WhereCondition.StringCondition(queryString)).build();\r\n    return query;\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase1Scenario1.verifyOnlyOneInstanceOfTestClassForAllTestMethods",
	"Comment": "verify that the same test class instance is associated with each of the test methods from the sample test class",
	"Method": "void verifyOnlyOneInstanceOfTestClassForAllTestMethods(){\r\n    verifyNumberOfInstancesOfTestClassForMethods(SUITE, TEST, TestClassAFiveMethodsWithNoDepsSample.class, 1);\r\n    verifySameInstancesOfTestClassAssociatedWithMethods(SUITE, TEST, TestClassAFiveMethodsWithNoDepsSample.class);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.animation.ObjectAnimator.ofPropertyValuesHolder",
	"Comment": "constructs and returns an objectanimator that animates between the sets of values specifiedin propertyvalueholder objects. this variant should be used when animatingseveral properties at once with the same objectanimator, since propertyvaluesholder allowsyou to associate a set of animation values with a property name.",
	"Method": "ObjectAnimator ofPropertyValuesHolder(Object target,PropertyValuesHolder values){\r\n    ObjectAnimator anim = new ObjectAnimator();\r\n    anim.mTarget = target;\r\n    anim.setValues(values);\r\n    return anim;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.view.ViewPropertyAnimatorPreHC.startAnimation",
	"Comment": "starts the underlying animator for a set of properties. we use a single animator thatsimply runs from 0 to 1, and then use that fractional value to set each propertyvalue accordingly.",
	"Method": "void startAnimation(){\r\n    ValueAnimator animator = ValueAnimator.ofFloat(1.0f);\r\n    ArrayList<NameValuesHolder> nameValueList = (ArrayList<NameValuesHolder>) mPendingAnimations.clone();\r\n    mPendingAnimations.clear();\r\n    int propertyMask = 0;\r\n    int propertyCount = nameValueList.size();\r\n    for (int i = 0; i < propertyCount; ++i) {\r\n        NameValuesHolder nameValuesHolder = nameValueList.get(i);\r\n        propertyMask |= nameValuesHolder.mNameConstant;\r\n    }\r\n    mAnimatorMap.put(animator, new PropertyBundle(propertyMask, nameValueList));\r\n    animator.addUpdateListener(mAnimatorEventListener);\r\n    animator.addListener(mAnimatorEventListener);\r\n    if (mStartDelaySet) {\r\n        animator.setStartDelay(mStartDelay);\r\n    }\r\n    if (mDurationSet) {\r\n        animator.setDuration(mDuration);\r\n    }\r\n    if (mInterpolatorSet) {\r\n        animator.setInterpolator(mInterpolator);\r\n    }\r\n    animator.start();\r\n}"
}, {
	"Path": "test.thread.parallelization.TestNgRunStateTracker.getTestMethodEventLogsByEventTypeForMethod",
	"Comment": "separated out in a map where the keys are the class instances on which the method was run.",
	"Method": "Map<Object, EventLog> getTestMethodEventLogsByEventTypeForMethod(String suiteName,String testName,String className,String methodName,TestNgRunEvent event){\r\n    Map<Object, EventLog> testMethodEventLogs = new HashMap();\r\n    for (EventLog eventLog : eventLogs) {\r\n        if (eventLog.getEvent() == event && belongsToMethod(suiteName, testName, className, methodName, eventLog)) {\r\n            testMethodEventLogs.put(eventLog.getData(EventInfo.CLASS_INSTANCE), eventLog);\r\n        }\r\n    }\r\n    return testMethodEventLogs;\r\n}"
}, {
	"Path": "com.android.datetimepicker.date.MonthView.restoreAccessibilityFocus",
	"Comment": "attempts to restore accessibility focus to the specified date.",
	"Method": "boolean restoreAccessibilityFocus(CalendarDay day){\r\n    if ((day.year != mYear) || (day.month != mMonth) || (day.day > mNumCells)) {\r\n        return false;\r\n    }\r\n    mTouchHelper.setFocusedVirtualView(day.day);\r\n    return true;\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.builders.ThumbnailParameterBuilder.useExifOrientation",
	"Comment": "sets whether or not the exif metadata should be used to determine the\torientation of the thumbnail.",
	"Method": "ThumbnailParameterBuilder useExifOrientation(boolean use){\r\n    this.useExifOrientation = use;\r\n    return this;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.imageprocessing.GLRenderer.setBackgroundGreen",
	"Comment": "sets only the green component of the background colour currently set for this glrenderer.",
	"Method": "void setBackgroundGreen(float green){\r\n    this.green = green;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.cropperimage.cropwindow.handle.HandleHelper.getAspectRatio",
	"Comment": "gets the aspect ratio of the resulting crop window if this handle weredragged to the given point.",
	"Method": "float getAspectRatio(float x,float y){\r\n    final float left = (mVerticalEdge == Edge.LEFT) ? x : Edge.LEFT.getCoordinate();\r\n    final float top = (mHorizontalEdge == Edge.TOP) ? y : Edge.TOP.getCoordinate();\r\n    final float right = (mVerticalEdge == Edge.RIGHT) ? x : Edge.RIGHT.getCoordinate();\r\n    final float bottom = (mHorizontalEdge == Edge.BOTTOM) ? y : Edge.BOTTOM.getCoordinate();\r\n    final float aspectRatio = AspectRatioUtil.calculateAspectRatio(left, top, right, bottom);\r\n    return aspectRatio;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.circularfloatingactionmenu.FloatingActionButton.attach",
	"Comment": "attaches it to the activity content view with specified layoutparams.",
	"Method": "void attach(FrameLayout.LayoutParams layoutParams){\r\n    ((ViewGroup) getActivityContentView()).addView(this, layoutParams);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.animation.ValueAnimator.removeUpdateListener",
	"Comment": "removes a listener from the set listening to frame updates for this animation.",
	"Method": "void removeUpdateListener(AnimatorUpdateListener listener){\r\n    if (mUpdateListeners == null) {\r\n        return;\r\n    }\r\n    mUpdateListeners.remove(listener);\r\n    if (mUpdateListeners.size() == 0) {\r\n        mUpdateListeners = null;\r\n    }\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase3Scenario2.verifyThatTestMethodsRunInParallelThreads",
	"Comment": "verifies that the test methods execute in different threads in parallel fashion.",
	"Method": "void verifyThatTestMethodsRunInParallelThreads(){\r\n    verifyParallelTestMethodsWithNonParallelDataProvider(getTestMethodLevelEventLogsForTest(SUITE_A, SUITE_A_TEST_A), SUITE_A_TEST_A, expectedInvocationCounts, 11, 3);\r\n    verifyParallelTestMethodsWithNonParallelDataProvider(getTestMethodLevelEventLogsForTest(SUITE_B, SUITE_B_TEST_A), SUITE_B_TEST_A, expectedInvocationCounts, 5, 4);\r\n    verifyParallelTestMethodsWithNonParallelDataProvider(getTestMethodLevelEventLogsForTest(SUITE_B, SUITE_B_TEST_B), SUITE_B_TEST_B, expectedInvocationCounts, 13, 4);\r\n}"
}, {
	"Path": "com.marshalchen.common.ui.ShimmerFrameLayout.getDuration",
	"Comment": "get the duration of the current animation i.e. the time it takes for the highlight to move from one endof the layout to the other. the default value is 1000 ms.",
	"Method": "int getDuration(){\r\n    return mDuration;\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.util.ThumbnailatorUtils.isSupportedOutputFormat",
	"Comment": "returns whether a specified format is supported for output.",
	"Method": "boolean isSupportedOutputFormat(String format){\r\n    if (format == ThumbnailParameter.ORIGINAL_FORMAT) {\r\n        return true;\r\n    }\r\n    for (String supportedFormat : getSupportedOutputFormats()) {\r\n        if (supportedFormat.equals(format)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.slider.Tricks.ViewPagerEx.addTouchables",
	"Comment": "we only want the current page that is being shown to be touchable.",
	"Method": "void addTouchables(ArrayList<View> views){\r\n    for (int i = 0; i < getChildCount(); i++) {\r\n        final View child = getChildAt(i);\r\n        if (child.getVisibility() == VISIBLE) {\r\n            ItemInfo ii = infoForChild(child);\r\n            if (ii != null && ii.position == mCurItem) {\r\n                child.addTouchables(views);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.gesturedetectors.BaseGestureDetector.getEventTime",
	"Comment": "return the event time of the current gesturedetector event being\tprocessed.",
	"Method": "long getEventTime(){\r\n    return mCurrEvent.getEventTime();\r\n}"
}, {
	"Path": "com.android.datetimepicker.date.DayPickerView.setMonthDisplayed",
	"Comment": "sets the month displayed at the top of this view based on time. overrideto add custom events when the title is changed.",
	"Method": "void setMonthDisplayed(CalendarDay date){\r\n    mCurrentMonthDisplayed = date.month;\r\n    invalidateViews();\r\n}"
}, {
	"Path": "com.marshalchen.common.ui.AutofitTextView.refitText",
	"Comment": "re size the font so the specified text fits in the text box assuming the text box is thespecified width.",
	"Method": "void refitText(){\r\n    if (!mSizeToFit) {\r\n        return;\r\n    }\r\n    if (mMaxLines <= 0) {\r\n        return;\r\n    }\r\n    CharSequence text = getText();\r\n    TransformationMethod method = getTransformationMethod();\r\n    if (method != null) {\r\n        text = method.getTransformation(text, this);\r\n    }\r\n    int targetWidth = getWidth() - getPaddingLeft() - getPaddingRight();\r\n    if (targetWidth > 0) {\r\n        Context context = getContext();\r\n        Resources r = Resources.getSystem();\r\n        DisplayMetrics displayMetrics;\r\n        float size = mMaxTextSize;\r\n        float high = size;\r\n        float low = 0;\r\n        if (context != null) {\r\n            r = context.getResources();\r\n        }\r\n        displayMetrics = r.getDisplayMetrics();\r\n        mPaint.set(getPaint());\r\n        mPaint.setTextSize(size);\r\n        if ((mMaxLines == 1 && mPaint.measureText(text, 0, text.length()) > targetWidth) || getLineCount(text, mPaint, size, targetWidth, displayMetrics) > mMaxLines) {\r\n            size = getTextSize(text, mPaint, targetWidth, mMaxLines, low, high, mPrecision, displayMetrics);\r\n        }\r\n        if (size < mMinTextSize) {\r\n            size = mMinTextSize;\r\n        }\r\n        super.setTextSize(TypedValue.COMPLEX_UNIT_PX, size);\r\n    }\r\n}"
}, {
	"Path": "test.thread.parallelization.TestNgRunStateTracker.getTestMethodListenerPassEventLogsForTest",
	"Comment": "get the test method listener ontestsuccess event logs for the specified suite and test",
	"Method": "List<EventLog> getTestMethodListenerPassEventLogsForTest(String suiteName,String testName){\r\n    List<EventLog> testMethodPassEventLogs = new ArrayList();\r\n    for (EventLog eventLog : eventLogs) {\r\n        if (eventLog.getEvent() == TestNgRunEvent.LISTENER_TEST_METHOD_PASS && belongsToTest(suiteName, testName, eventLog)) {\r\n            testMethodPassEventLogs.add(eventLog);\r\n        }\r\n    }\r\n    return testMethodPassEventLogs;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.photoview.DefaultOnDoubleTapListener.setPhotoViewAttacher",
	"Comment": "allows to change photoviewattacher within range of single instance",
	"Method": "void setPhotoViewAttacher(PhotoViewAttacher newPhotoViewAttacher){\r\n    this.photoViewAttacher = newPhotoViewAttacher;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.imageprocessing.filter.MultiInputFilter.clearRegisteredFilterLocations",
	"Comment": "removes all currently registered filters from filter location list.",
	"Method": "void clearRegisteredFilterLocations(){\r\n    filterLocations.clear();\r\n}"
}, {
	"Path": "com.marshalchen.common.ui.ShimmerFrameLayout.setRepeatMode",
	"Comment": "set what the animation should do after reaching the end. one ofreverse orrestart",
	"Method": "void setRepeatMode(int repeatMode){\r\n    mRepeatMode = repeatMode;\r\n    resetAll();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.animation.ValueAnimator.getInterpolator",
	"Comment": "returns the timing interpolator that this valueanimator uses.",
	"Method": "Interpolator getInterpolator(){\r\n    return mInterpolator;\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase1Scenario1.sanityCheck",
	"Comment": "verifies that the expected number of suite, test and test method level events were logged.",
	"Method": "void sanityCheck(){\r\n    assertEquals(suiteLevelEventLogs.size(), 2, \"There should be 2 suite level events logged for \" + SUITE + \": \" + suiteLevelEventLogs);\r\n    assertEquals(testLevelEventLogs.size(), 2, \"There should be 2 test level events logged for \" + SUITE + \": \" + testLevelEventLogs);\r\n    assertEquals(testMethodLevelEventLogs.size(), 15, \"There should be 15 test method level event logged for \" + SUITE + \": \" + testMethodLevelEventLogs);\r\n}"
}, {
	"Path": "org.testng.TestNG.sanityCheck",
	"Comment": "before suites are executed, do a sanity check to ensure all required conditions are met. ifnot, throw an exception to stop test execution",
	"Method": "void sanityCheck(){\r\n    XmlSuiteUtils.validateIfSuitesContainDuplicateTests(m_suites);\r\n    XmlSuiteUtils.adjustSuiteNamesToEnsureUniqueness(m_suites);\r\n}"
}, {
	"Path": "test.CommandLineTest.suiteNameOverride",
	"Comment": "test the ability to override the default command line suite name",
	"Method": "void suiteNameOverride(){\r\n    String suiteName = \"MySuiteName\";\r\n    String[] argv = { \"-log\", \"0\", \"-d\", OutputDirectoryPatch.getOutputDirectory(), \"-junit\", \"-testclass\", \"test.sample.JUnitSample1\", \"-suitename\", \"\\\"\" + suiteName + \"\\\"\" };\r\n    TestListenerAdapter tla = new TestListenerAdapter();\r\n    TestNG.privateMain(argv, tla);\r\n    List<ITestContext> contexts = tla.getTestContexts();\r\n    assertTrue(contexts.size() > 0);\r\n    for (ITestContext context : contexts) {\r\n        assertEquals(context.getSuite().getName(), suiteName);\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.fancycoverflow.FancyCoverFlow.getMaxRotation",
	"Comment": "returns the maximum rotation that is applied to items left and right of the center of the coverflow.",
	"Method": "int getMaxRotation(){\r\n    return maxRotation;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.enhanceListView.EnhancedListView.setShouldSwipeCallback",
	"Comment": "sets the callback to be called when the user is swiping an item from the list.",
	"Method": "EnhancedListView setShouldSwipeCallback(OnShouldSwipeCallback shouldSwipeCallback){\r\n    mShouldSwipeCallback = shouldSwipeCallback;\r\n    return this;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.swipeback.ViewDragHelper.continueSettling",
	"Comment": "move the captured settling view by the appropriate amount for the currenttime. if continuesettling returns true, the caller shouldcall it again on the next frame to continue.",
	"Method": "boolean continueSettling(boolean deferCallbacks){\r\n    if (mDragState == STATE_SETTLING) {\r\n        boolean keepGoing = mScroller.computeScrollOffset();\r\n        final int x = mScroller.getCurrX();\r\n        final int y = mScroller.getCurrY();\r\n        final int dx = x - mCapturedView.getLeft();\r\n        final int dy = y - mCapturedView.getTop();\r\n        if (dx != 0) {\r\n            mCapturedView.offsetLeftAndRight(dx);\r\n        }\r\n        if (dy != 0) {\r\n            mCapturedView.offsetTopAndBottom(dy);\r\n        }\r\n        if (dx != 0 || dy != 0) {\r\n            mCallback.onViewPositionChanged(mCapturedView, x, y, dx, dy);\r\n        }\r\n        if (keepGoing && x == mScroller.getFinalX() && y == mScroller.getFinalY()) {\r\n            mScroller.abortAnimation();\r\n            keepGoing = mScroller.isFinished();\r\n        }\r\n        if (!keepGoing) {\r\n            if (deferCallbacks) {\r\n                mParentView.post(mSetIdleRunnable);\r\n            } else {\r\n                setDragState(STATE_IDLE);\r\n            }\r\n        }\r\n    }\r\n    return mDragState == STATE_SETTLING;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.dragSortListView.SimpleFloatViewManager.onCreateFloatView",
	"Comment": "this simple implementation creates a bitmap copy of thelist item currently shown at listview position.",
	"Method": "View onCreateFloatView(int position){\r\n    View v = mListView.getChildAt(position + mListView.getHeaderViewsCount() - mListView.getFirstVisiblePosition());\r\n    if (v == null) {\r\n        return null;\r\n    }\r\n    v.setPressed(false);\r\n    v.setDrawingCacheEnabled(true);\r\n    mFloatBitmap = Bitmap.createBitmap(v.getDrawingCache());\r\n    v.setDrawingCacheEnabled(false);\r\n    if (mImageView == null) {\r\n        mImageView = new ImageView(mListView.getContext());\r\n    }\r\n    mImageView.setBackgroundColor(mFloatBGColor);\r\n    mImageView.setPadding(0, 0, 0, 0);\r\n    mImageView.setImageBitmap(mFloatBitmap);\r\n    mImageView.setLayoutParams(new ViewGroup.LayoutParams(v.getWidth(), v.getHeight()));\r\n    return mImageView;\r\n}"
}, {
	"Path": "test.thread.parallelization.BaseParallelizationTest.getEarliestAndLatestTimestamps",
	"Comment": "helper method that retrieves the earliest and latest timestamps for the specified list of event logs",
	"Method": "Pair<Long, Long> getEarliestAndLatestTimestamps(List<EventLog> eventLogs){\r\n    if (eventLogs.isEmpty()) {\r\n        return null;\r\n    }\r\n    long earliestTimestamp = eventLogs.get(0).getTimeOfEvent();\r\n    long latestTimestamp = eventLogs.get(0).getTimeOfEvent();\r\n    for (int i = 1; i < eventLogs.size(); i++) {\r\n        long timestamp = eventLogs.get(i).getTimeOfEvent();\r\n        if (timestamp < earliestTimestamp) {\r\n            earliestTimestamp = timestamp;\r\n        }\r\n        if (timestamp > latestTimestamp) {\r\n            latestTimestamp = timestamp;\r\n        }\r\n    }\r\n    return new Pair(earliestTimestamp, latestTimestamp);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.tileView.tileview.TileView.addTileViewEventListener",
	"Comment": "register an event listener callback object for this tileview.\tnote this is method adds a listener to an array of listeners, and does not set\ta single listener member a single listener.",
	"Method": "void addTileViewEventListener(TileViewEventListener listener){\r\n    tileViewEventListeners.add(listener);\r\n}"
}, {
	"Path": "org.isoron.uhabits.core.models.CheckmarkList.snapIntervalsTogether",
	"Comment": "starting from the oldest interval, this function tries to slide theintervals backwards into the past, so that gaps are eliminated andstreaks are maximized. when it detects that sliding an intervalwould not help fixing any gap, it leaves the interval unchanged.",
	"Method": "void snapIntervalsTogether(ArrayList<Interval> intervals){\r\n    for (int i = 1; i < intervals.size(); i++) {\r\n        Interval curr = intervals.get(i);\r\n        Interval prev = intervals.get(i - 1);\r\n        int gap = prev.end.daysUntil(curr.begin) - 1;\r\n        if (gap <= 0 || curr.end.minus(gap).isOlderThan(curr.center))\r\n            continue;\r\n        intervals.set(i, new Interval(curr.begin.minus(gap), curr.center, curr.end.minus(gap)));\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.ua.common.commonUtils.uiUtils.ImageUtils.revertImageSize",
	"Comment": "revert image file to a square with width and height equal 1000",
	"Method": "Bitmap revertImageSize(String path,int width,Bitmap revertImageSize,String path,Bitmap revertImageSize,String path,int width,int height){\r\n    BufferedInputStream in = new BufferedInputStream(new FileInputStream(new File(path)));\r\n    BitmapFactory.Options options = new BitmapFactory.Options();\r\n    options.inJustDecodeBounds = true;\r\n    BitmapFactory.decodeStream(in, null, options);\r\n    in.close();\r\n    int i = 0;\r\n    Bitmap bitmap = null;\r\n    while (true) {\r\n        if ((options.outWidth >> i <= width) && (options.outHeight >> i <= height)) {\r\n            in = new BufferedInputStream(new FileInputStream(new File(path)));\r\n            options.inSampleSize = (int) Math.pow(2.0D, i);\r\n            options.inJustDecodeBounds = false;\r\n            bitmap = BitmapFactory.decodeStream(in, null, options);\r\n            break;\r\n        }\r\n        i += 1;\r\n    }\r\n    return bitmap;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.imageprocessing.input.GLTextureOutputRenderer.removeTarget",
	"Comment": "removes the given target from the list of targets that this renderer sends its output to.",
	"Method": "void removeTarget(GLTextureInputRenderer target){\r\n    synchronized (listLock) {\r\n        targets.remove(target);\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.listviewanimations.widget.DynamicListView.handleCellSwitch",
	"Comment": "this method determines whether the hover cell has been shifted far enoughto invoke a cell swap. if so, then the respective cell swap candidate isdetermined and the data set is changed. upon posting a notification of thedata set change, a layout is invoked to place the cells in the right place.using a viewtreeobserver and a corresponding onpredrawlistener, we canoffset the cell being swapped to where it previously was and then animate it toits new position.",
	"Method": "void handleCellSwitch(){\r\n    final int deltaY = mLastEventY - mDownY;\r\n    int deltaYTotal = mHoverCellOriginalBounds.top + mTotalOffset + deltaY;\r\n    View belowView = getViewForId(mBelowItemId);\r\n    View mobileView = getViewForId(mMobileItemId);\r\n    View aboveView = getViewForId(mAboveItemId);\r\n    boolean isBelow = (belowView != null) && (deltaYTotal > belowView.getTop());\r\n    boolean isAbove = (aboveView != null) && (deltaYTotal < aboveView.getTop());\r\n    if (isBelow || isAbove) {\r\n        final long switchItemId = isBelow ? mBelowItemId : mAboveItemId;\r\n        View switchView = isBelow ? belowView : aboveView;\r\n        final int originalItem = getPositionForView(mobileView);\r\n        if (switchView == null) {\r\n            updateNeighborViewsForId(mMobileItemId);\r\n            return;\r\n        }\r\n        if (getPositionForView(switchView) < getHeaderViewsCount()) {\r\n            return;\r\n        }\r\n        swapElements(originalItem, getPositionForView(switchView));\r\n        BaseAdapter adapter;\r\n        if (getAdapter() instanceof HeaderViewListAdapter) {\r\n            adapter = (BaseAdapter) ((HeaderViewListAdapter) getAdapter()).getWrappedAdapter();\r\n        } else {\r\n            adapter = (BaseAdapter) getAdapter();\r\n        }\r\n        adapter.notifyDataSetChanged();\r\n        mDownY = mLastEventY;\r\n        mDownX = mLastEventX;\r\n        final int switchViewStartTop = switchView.getTop();\r\n        mobileView.setVisibility(View.VISIBLE);\r\n        switchView.setVisibility(View.INVISIBLE);\r\n        updateNeighborViewsForId(mMobileItemId);\r\n        final ViewTreeObserver observer = getViewTreeObserver();\r\n        observer.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {\r\n            public boolean onPreDraw() {\r\n                observer.removeOnPreDrawListener(this);\r\n                View switchView = getViewForId(switchItemId);\r\n                mTotalOffset += deltaY;\r\n                int switchViewNewTop = switchView.getTop();\r\n                int delta = switchViewStartTop - switchViewNewTop;\r\n                ViewHelper.setTranslationY(switchView, delta);\r\n                ObjectAnimator animator = ObjectAnimator.ofFloat(switchView, \"translationY\", 0);\r\n                animator.setDuration(MOVE_DURATION);\r\n                animator.start();\r\n                return true;\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.listviewanimations.widget.DynamicListView.handleCellSwitch",
	"Comment": "this method determines whether the hover cell has been shifted far enoughto invoke a cell swap. if so, then the respective cell swap candidate isdetermined and the data set is changed. upon posting a notification of thedata set change, a layout is invoked to place the cells in the right place.using a viewtreeobserver and a corresponding onpredrawlistener, we canoffset the cell being swapped to where it previously was and then animate it toits new position.",
	"Method": "void handleCellSwitch(){\r\n    observer.removeOnPreDrawListener(this);\r\n    View switchView = getViewForId(switchItemId);\r\n    mTotalOffset += deltaY;\r\n    int switchViewNewTop = switchView.getTop();\r\n    int delta = switchViewStartTop - switchViewNewTop;\r\n    ViewHelper.setTranslationY(switchView, delta);\r\n    ObjectAnimator animator = ObjectAnimator.ofFloat(switchView, \"translationY\", 0);\r\n    animator.setDuration(MOVE_DURATION);\r\n    animator.start();\r\n    return true;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.cropperimage.util.PaintUtil.newBorderPaint",
	"Comment": "creates the paint object for drawing the crop window border.",
	"Method": "Paint newBorderPaint(Context context){\r\n    final float lineThicknessPx = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, DEFAULT_LINE_THICKNESS_DP, context.getResources().getDisplayMetrics());\r\n    final Paint borderPaint = new Paint();\r\n    borderPaint.setColor(Color.parseColor(SEMI_TRANSPARENT));\r\n    borderPaint.setStrokeWidth(lineThicknessPx);\r\n    borderPaint.setStyle(Paint.Style.STROKE);\r\n    return borderPaint;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.modifysys.ViewPager.canScroll",
	"Comment": "tests scrollability within child views of v given a delta of dx.",
	"Method": "boolean canScroll(View v,boolean checkV,int dx,int x,int y,boolean canScroll){\r\n    if (v instanceof ViewGroup) {\r\n        final ViewGroup group = (ViewGroup) v;\r\n        final int scrollX = v.getScrollX();\r\n        final int scrollY = v.getScrollY();\r\n        final int count = group.getChildCount();\r\n        for (int i = count - 1; i >= 0; i--) {\r\n            final View child = group.getChildAt(i);\r\n            if (x + scrollX >= child.getLeft() && x + scrollX < child.getRight() && y + scrollY >= child.getTop() && y + scrollY < child.getBottom() && canScroll(child, true, dx, x + scrollX - child.getLeft(), y + scrollY - child.getTop())) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return checkV && ViewCompat.canScrollHorizontally(v, -dx);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.imageprocessing.FastImageProcessingPipeline.removeRootRenderer",
	"Comment": "removes a root node of graph of filters that the pipeline will process and draw to the given endpoints of the graph.",
	"Method": "void removeRootRenderer(GLRenderer rootRenderer){\r\n    rootRenderers.remove(rootRenderer);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.freeflow.core.FreeFlowContainer.notifyDataSetChanged",
	"Comment": "notifies the attached observers that the underlying data has been changed\tand any view reflecting the data set should refresh itself.",
	"Method": "void notifyDataSetChanged(){\r\n    dataSetChanged = true;\r\n    requestLayout();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.passcodelock.AbstractAppLock.setOneTimeTimeout",
	"Comment": "there are situations where an activity will start a different application with an intent.in these situations call this method right before leaving the app.",
	"Method": "void setOneTimeTimeout(int timeout){\r\n    this.lockTimeOut = timeout;\r\n}"
}, {
	"Path": "com.android.datetimepicker.time.RadialTextsView.drawTexts",
	"Comment": "draw the 12 text values at the positions specified by the textgrid parameters.",
	"Method": "void drawTexts(Canvas canvas,float textSize,Typeface typeface,String[] texts,float[] textGridWidths,float[] textGridHeights){\r\n    mPaint.setTextSize(textSize);\r\n    mPaint.setTypeface(typeface);\r\n    canvas.drawText(texts[0], textGridWidths[3], textGridHeights[0], mPaint);\r\n    canvas.drawText(texts[1], textGridWidths[4], textGridHeights[1], mPaint);\r\n    canvas.drawText(texts[2], textGridWidths[5], textGridHeights[2], mPaint);\r\n    canvas.drawText(texts[3], textGridWidths[6], textGridHeights[3], mPaint);\r\n    canvas.drawText(texts[4], textGridWidths[5], textGridHeights[4], mPaint);\r\n    canvas.drawText(texts[5], textGridWidths[4], textGridHeights[5], mPaint);\r\n    canvas.drawText(texts[6], textGridWidths[3], textGridHeights[6], mPaint);\r\n    canvas.drawText(texts[7], textGridWidths[2], textGridHeights[5], mPaint);\r\n    canvas.drawText(texts[8], textGridWidths[1], textGridHeights[4], mPaint);\r\n    canvas.drawText(texts[9], textGridWidths[0], textGridHeights[3], mPaint);\r\n    canvas.drawText(texts[10], textGridWidths[1], textGridHeights[2], mPaint);\r\n    canvas.drawText(texts[11], textGridWidths[2], textGridHeights[1], mPaint);\r\n}"
}, {
	"Path": "org.testng.TestRunner.privateRun",
	"Comment": "main method that create a graph of methods and then pass it to the graph executor to run them.",
	"Method": "void privateRun(XmlTest xmlTest){\r\n    boolean parallel = xmlTest.getParallel().isParallel();\r\n    {\r\n        int threadCount = parallel ? xmlTest.getThreadCount() : 1;\r\n        ITestNGMethod[] interceptedOrder = intercept(m_allTestMethods);\r\n        DynamicGraph<ITestNGMethod> graph = DynamicGraphHelper.createDynamicGraph(interceptedOrder, getCurrentXmlTest());\r\n        boolean needPrioritySort = m_methodInterceptors.size() > 1 || Arrays.stream(interceptedOrder).anyMatch(m -> m.getPriority() != 0);\r\n        Comparator<ITestNGMethod> methodComparator = needPrioritySort ? new TestMethodComparator() : null;\r\n        graph.setVisualisers(this.visualisers);\r\n        if (parallel) {\r\n            if (graph.getNodeCount() > 0) {\r\n                BlockingQueue<Runnable> queue = needPrioritySort ? new PriorityBlockingQueue() : new LinkedBlockingQueue();\r\n                GraphThreadPoolExecutor<ITestNGMethod> executor = new GraphThreadPoolExecutor(\"test=\" + xmlTest.getName(), graph, this, threadCount, threadCount, 0, TimeUnit.MILLISECONDS, queue, methodComparator);\r\n                executor.run();\r\n                try {\r\n                    long timeOut = m_xmlTest.getTimeOut(XmlTest.DEFAULT_TIMEOUT_MS);\r\n                    Utils.log(\"TestRunner\", 2, \"Starting executor for test \" + m_xmlTest.getName() + \" with time out:\" + timeOut + \" milliseconds.\");\r\n                    executor.awaitTermination(timeOut, TimeUnit.MILLISECONDS);\r\n                    executor.shutdownNow();\r\n                } catch (InterruptedException handled) {\r\n                    LOGGER.error(handled.getMessage(), handled);\r\n                    Thread.currentThread().interrupt();\r\n                }\r\n            }\r\n        } else {\r\n            List<ITestNGMethod> freeNodes = graph.getFreeNodes();\r\n            if (graph.getNodeCount() > 0 && freeNodes.isEmpty()) {\r\n                throw new TestNGException(\"No free nodes found in:\" + graph);\r\n            }\r\n            while (!freeNodes.isEmpty()) {\r\n                if (needPrioritySort) {\r\n                    freeNodes.sort(methodComparator);\r\n                    freeNodes = freeNodes.subList(0, 1);\r\n                }\r\n                List<IWorker<ITestNGMethod>> runnables = createWorkers(freeNodes);\r\n                for (IWorker<ITestNGMethod> r : runnables) {\r\n                    r.run();\r\n                }\r\n                graph.setStatus(freeNodes, Status.FINISHED);\r\n                freeNodes = graph.getFreeNodes();\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.dragSortListView.SimpleDragSortCursorAdapter.setStringConversionColumn",
	"Comment": "defines the index of the column in the cursor used to get a stringrepresentation of that cursor. the column is used to convert thecursor to a string only when the current cursortostringconverteris null.",
	"Method": "void setStringConversionColumn(int stringConversionColumn){\r\n    mStringConversionColumn = stringConversionColumn;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.listbuddies.adapters.CircularLoopAdapter.getCircularPosition",
	"Comment": "gets the position that correspond to the position in the amount of items we actually have",
	"Method": "int getCircularPosition(int position){\r\n    if (getCircularCount() == 0)\r\n        return 0;\r\n    return position % getCircularCount();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.cropperimage.util.PaintUtil.newBackgroundPaint",
	"Comment": "creates the paint object for drawing the translucent overlay outside thecrop window.",
	"Method": "Paint newBackgroundPaint(Context context){\r\n    final Paint paint = new Paint();\r\n    paint.setColor(Color.parseColor(DEFAULT_BACKGROUND_COLOR_ID));\r\n    return paint;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.smoothprogressbar.ContentLoadingSmoothProgressBar.hide",
	"Comment": "hide the progress view if it is visible. the progress view will not behidden until it has been shown for at least a minimum show time. if theprogress view was not yet visible, cancels showing the progress view.",
	"Method": "void hide(){\r\n    mDismissed = true;\r\n    removeCallbacks(mDelayedShow);\r\n    long diff = System.currentTimeMillis() - mStartTime;\r\n    if (diff >= MIN_SHOW_TIME || mStartTime == -1) {\r\n        setVisibility(GONE);\r\n    } else {\r\n        if (!mPostedHide) {\r\n            postDelayed(mDelayedHide, MIN_SHOW_TIME - diff);\r\n            mPostedHide = true;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.slider.Tricks.ViewPagerEx.canScroll",
	"Comment": "tests scrollability within child views of v given a delta of dx.",
	"Method": "boolean canScroll(View v,boolean checkV,int dx,int x,int y,boolean canScroll){\r\n    if (v instanceof ViewGroup) {\r\n        final ViewGroup group = (ViewGroup) v;\r\n        final int scrollX = v.getScrollX();\r\n        final int scrollY = v.getScrollY();\r\n        final int count = group.getChildCount();\r\n        for (int i = count - 1; i >= 0; i--) {\r\n            final View child = group.getChildAt(i);\r\n            if (x + scrollX >= child.getLeft() && x + scrollX < child.getRight() && y + scrollY >= child.getTop() && y + scrollY < child.getBottom() && canScroll(child, true, dx, x + scrollX - child.getLeft(), y + scrollY - child.getTop())) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return checkV && ViewCompat.canScrollHorizontally(v, -dx);\r\n}"
}, {
	"Path": "org.isoron.uhabits.core.models.ScoreList.compute",
	"Comment": "computes and stores one score for each day inside the given interval.scores that have already been computed are skipped, therefore there is noharm in calling this function more times, or with larger intervals, thanstrictly needed. the endpoints of the interval are included.this method assumes the list of computed scores has no holes. that is, ifthere is a score computed at time t1 and another at time t2, then everyscore between t1 and t2 is also computed.",
	"Method": "void compute(Timestamp from,Timestamp to){\r\n    Score newest = getNewestComputed();\r\n    Score oldest = getOldestComputed();\r\n    if (newest == null) {\r\n        Repetition oldestRep = habit.getRepetitions().getOldest();\r\n        if (oldestRep != null)\r\n            from = Timestamp.oldest(from, oldestRep.getTimestamp());\r\n        forceRecompute(from, to, 0);\r\n    } else {\r\n        if (oldest == null)\r\n            throw new IllegalStateException();\r\n        forceRecompute(from, oldest.getTimestamp().minus(1), 0);\r\n        forceRecompute(newest.getTimestamp().plus(1), to, newest.getValue());\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.easyandroidanimations.FlipVerticalAnimation.setDegrees",
	"Comment": "in order to flip down, the number of degrees should be negative and vice\tversa.",
	"Method": "FlipVerticalAnimation setDegrees(float degrees){\r\n    this.degrees = degrees;\r\n    return this;\r\n}"
}, {
	"Path": "com.marshalchen.common.DiskLruCache.DiskLruCache.setMaxSize",
	"Comment": "changes the maximum number of bytes the cache can store and queues a jobto trim the existing store, if necessary.",
	"Method": "void setMaxSize(long maxSize){\r\n    this.maxSize = maxSize;\r\n    executorService.submit(cleanupCallable);\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.ThumbnailParameter.fitWithinDimenions",
	"Comment": "returns whether or not to fit the thumbnail within the specified\tdimensions.",
	"Method": "boolean fitWithinDimenions(){\r\n    return fitWithinDimensions;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.slider.Tricks.ViewPagerEx.getOffscreenPageLimit",
	"Comment": "returns the number of pages that will be retained to either side of thecurrent page in the view hierarchy in an idle state. defaults to 1.",
	"Method": "int getOffscreenPageLimit(){\r\n    return mOffscreenPageLimit;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.staggeredgridview.ExtendableListView.fillGap",
	"Comment": "as we move and scroll and recycle views we want to fill the gap created with new views",
	"Method": "void fillGap(boolean down){\r\n    final int count = getChildCount();\r\n    if (down) {\r\n        int position = mFirstPosition + count;\r\n        final int startOffset = getChildTop(position);\r\n        fillDown(position, startOffset);\r\n    } else {\r\n        int position = mFirstPosition - 1;\r\n        final int startOffset = getChildBottom(position);\r\n        fillUp(position, startOffset);\r\n    }\r\n    adjustViewsAfterFillGap(down);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.animation.Keyframe.setFraction",
	"Comment": "sets the time for this keyframe, as a fraction of the overall animation duration.",
	"Method": "void setFraction(float fraction){\r\n    mFraction = fraction;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.customshapeimageview.svgandroid.SVG.getLimits",
	"Comment": "gets the bounding rectangle for the svg that was computed upon parsing. it may not be entirely accurate for certain curves or transformations, but is often better than nothing.",
	"Method": "RectF getLimits(){\r\n    return limits;\r\n}"
}, {
	"Path": "com.marshalchen.common.ui.FloatingActionButtonWithListView.ScrollDirectionDetector.isSignificantDelta",
	"Comment": "make sure wrong direction method is not called when stopping scrollingand finger moved a little to opposite direction.",
	"Method": "boolean isSignificantDelta(int newScrollY){\r\n    boolean isSignificantDelta = Math.abs(mLastChangeY - newScrollY) > mMinSignificantScroll;\r\n    if (isSignificantDelta)\r\n        mLastChangeY = newScrollY;\r\n    return isSignificantDelta;\r\n}"
}, {
	"Path": "org.testng.internal.TestNgMethodUtils.isConfigurationMethod",
	"Comment": "a helper method that checks to see if a method is a configuration method or not.",
	"Method": "boolean isConfigurationMethod(ITestNGMethod method,boolean isConfigurationMethod,ITestNGMethod method,boolean includeGroupConfigs){\r\n    boolean flag = method.isBeforeMethodConfiguration() || method.isAfterMethodConfiguration() || method.isBeforeTestConfiguration() || method.isAfterTestConfiguration() || method.isBeforeClassConfiguration() || method.isAfterClassConfiguration() || method.isBeforeSuiteConfiguration() || method.isAfterSuiteConfiguration();\r\n    if (includeGroupConfigs) {\r\n        flag = flag || method.isBeforeGroupsConfiguration() || method.isAfterGroupsConfiguration();\r\n    }\r\n    return flag;\r\n}"
}, {
	"Path": "com.marshalchen.ua.common.commonUtils.dbUtils.GreenDaoUtils.setIsLog",
	"Comment": "set if the greendao will log the resulting sql command and the passed values when calling one of the build methods.like this you can compare if you actually get what you expected. it might also help to copy generated sql into some sqlite database explorer and execute it with the values.",
	"Method": "void setIsLog(boolean isLog){\r\n    GreenDaoUtils.isLog = isLog;\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase5Scenario2.verifyNumberOfInstanceOfTestClassForAllTestMethodsForAllSuites",
	"Comment": "verify that the same test class instances are associated with each of the test methods from the sample test class",
	"Method": "void verifyNumberOfInstanceOfTestClassForAllTestMethodsForAllSuites(){\r\n    verifyNumberOfInstancesOfTestClassesForMethods(SUITE_A, SUITE_A_TEST_A, Arrays.asList(TestClassAFiveMethodsWithNoDepsSample.class, TestClassCSixMethodsWithNoDepsSample.class), 2, 3);\r\n    verifySameInstancesOfTestClassesAssociatedWithMethods(SUITE_A, SUITE_A_TEST_A, Arrays.asList(TestClassAFiveMethodsWithNoDepsSample.class, TestClassCSixMethodsWithNoDepsSample.class));\r\n    verifyNumberOfInstancesOfTestClassForMethods(SUITE_B, SUITE_B_TEST_A, TestClassEFiveMethodsWithNoDepsSample.class, 1);\r\n    verifySameInstancesOfTestClassAssociatedWithMethods(SUITE_B, SUITE_B_TEST_A, TestClassEFiveMethodsWithNoDepsSample.class);\r\n    verifyNumberOfInstancesOfTestClassesForMethods(SUITE_B, SUITE_B_TEST_B, Arrays.asList(TestClassDThreeMethodsWithNoDepsSample.class, TestClassBFourMethodsWithNoDepsSample.class, TestClassFSixMethodsWithNoDepsSample.class), 4, 5, 6);\r\n    verifySameInstancesOfTestClassesAssociatedWithMethods(SUITE_B, SUITE_B_TEST_B, Arrays.asList(TestClassDThreeMethodsWithNoDepsSample.class, TestClassBFourMethodsWithNoDepsSample.class, TestClassFSixMethodsWithNoDepsSample.class));\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.ThumbnailParameter.useExifOrientation",
	"Comment": "returns whether or not the exif metadata should be used to determine\tthe orientation of the thumbnail.",
	"Method": "boolean useExifOrientation(){\r\n    return useExifOrientation;\r\n}"
}, {
	"Path": "com.marshalchen.ua.common.commonUtils.fileUtils.ParcelUtils.readHashMapStringKey",
	"Comment": "read a hashmap from a parcel, class of key is string, class of value can parcelable",
	"Method": "Map<String, V> readHashMapStringKey(Parcel in,ClassLoader loader){\r\n    if (in == null) {\r\n        return null;\r\n    }\r\n    int size = in.readInt();\r\n    if (size == -1) {\r\n        return null;\r\n    }\r\n    Map<String, V> map = new HashMap();\r\n    for (int i = 0; i < size; i++) {\r\n        String key = in.readString();\r\n        map.put(key, (V) in.readParcelable(loader));\r\n    }\r\n    return map;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.animation.ValueAnimator.setDuration",
	"Comment": "sets the length of the animation. the default duration is 300 milliseconds.",
	"Method": "ValueAnimator setDuration(long duration){\r\n    if (duration < 0) {\r\n        throw new IllegalArgumentException(\"Animators cannot have negative duration: \" + duration);\r\n    }\r\n    mDuration = duration;\r\n    return this;\r\n}"
}, {
	"Path": "com.marshalchen.common.ui.DropDownListView.getHeaderPaddingTopRate",
	"Comment": "get rate about drop down distance and header padding top when drop down",
	"Method": "float getHeaderPaddingTopRate(){\r\n    return headerPaddingTopRate;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.imageprocessing.input.CameraPreviewInput.onPause",
	"Comment": "closes and releases the camera for other applications to use.\tshould be called when the pause is called in the activity.",
	"Method": "void onPause(){\r\n    if (camera != null) {\r\n        camera.stopPreview();\r\n        camera.release();\r\n        camera = null;\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.recyclerplayground.layout.StaticGridLayoutManager.generateDefaultLayoutParams",
	"Comment": "we must override this method to provide the default layoutparameters that each child view will receive when added.",
	"Method": "RecyclerView.LayoutParams generateDefaultLayoutParams(){\r\n    return new RecyclerView.LayoutParams(RecyclerView.LayoutParams.WRAP_CONTENT, RecyclerView.LayoutParams.WRAP_CONTENT);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.view.ViewPropertyAnimator.animate",
	"Comment": "this method returns a viewpropertyanimator object, which can be used to animate specificproperties on this view.",
	"Method": "ViewPropertyAnimator animate(View view){\r\n    ViewPropertyAnimator animator = ANIMATORS.get(view);\r\n    if (animator == null) {\r\n        final int version = Integer.valueOf(Build.VERSION.SDK);\r\n        if (version >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {\r\n            animator = new ViewPropertyAnimatorICS(view);\r\n        } else if (version >= Build.VERSION_CODES.HONEYCOMB) {\r\n            animator = new ViewPropertyAnimatorHC(view);\r\n        } else {\r\n            animator = new ViewPropertyAnimatorPreHC(view);\r\n        }\r\n        ANIMATORS.put(view, animator);\r\n    }\r\n    return animator;\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase3Scenario1.verifyOnlyOneInstanceOfTestClassForAllTestMethods",
	"Comment": "verify that the same test class instance is associated with each of the test methods from the sample test class",
	"Method": "void verifyOnlyOneInstanceOfTestClassForAllTestMethods(){\r\n    verifyNumberOfInstancesOfTestClassForMethods(SUITE, TEST, TestClassAFiveMethodsWithDataProviderOnAllMethodsAndNoDepsSample.class, 1);\r\n    verifySameInstancesOfTestClassAssociatedWithMethods(SUITE, TEST, TestClassAFiveMethodsWithDataProviderOnAllMethodsAndNoDepsSample.class);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.simplemodule.DropDownListView.setHasMore",
	"Comment": "set whether has more. if hasmore is false, onbottm will not be called when listview scroll to bottom",
	"Method": "void setHasMore(boolean hasMore){\r\n    this.hasMore = hasMore;\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.tasks.io.URLImageSource.getProxy",
	"Comment": "returns the proxy to use when connecting to the url to retrieve the\tsource image.",
	"Method": "Proxy getProxy(){\r\n    return proxy;\r\n}"
}, {
	"Path": "com.marshalchen.ua.common.commonUtils.fileUtils.ParcelUtils.writeHashMapStringAndString",
	"Comment": "write a hashmap to a parcel, class of key and value are both string",
	"Method": "void writeHashMapStringAndString(Map<String, String> map,Parcel out,int flags){\r\n    if (map != null) {\r\n        out.writeInt(map.size());\r\n        for (Entry<String, String> entry : map.entrySet()) {\r\n            out.writeString(entry.getKey());\r\n            out.writeString(entry.getValue());\r\n        }\r\n    } else {\r\n        out.writeInt(-1);\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.view.ViewPropertyAnimatorHC.setDuration",
	"Comment": "sets the duration for the underlying animator that animates the requested properties.by default, the animator uses the default value for valueanimator. calling this methodwill cause the declared value to be used instead.",
	"Method": "ViewPropertyAnimator setDuration(long duration){\r\n    if (duration < 0) {\r\n        throw new IllegalArgumentException(\"Animators cannot have negative duration: \" + duration);\r\n    }\r\n    mDurationSet = true;\r\n    mDuration = duration;\r\n    return this;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.tileView.tileview.TileView.setTransitionsEnabled",
	"Comment": "defines whether tile bitmaps should be rendered using an alphaanimation",
	"Method": "void setTransitionsEnabled(boolean enabled){\r\n    tileManager.setTransitionsEnabled(enabled);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.flipViews.flipview.FlipView.peakNext",
	"Comment": "hint that there is a next page will do nothing if there is no next page",
	"Method": "void peakNext(boolean once){\r\n    if (mCurrentPageIndex < mPageCount - 1) {\r\n        peak(true, once);\r\n    }\r\n}"
}, {
	"Path": "org.testng.internal.DynamicGraphTest.testParallel",
	"Comment": "test that dynamicgraph correctly handles selecting free nodes so that independent nodes can beprocessed in parallel.",
	"Method": "void testParallel(){\r\n    DynamicGraph<Integer> dg = new DynamicGraph();\r\n    List<Integer> fizz = Lists.newArrayList();\r\n    List<Integer> buzz = Lists.newArrayList();\r\n    List<Integer> fizzBuzz = Lists.newArrayList();\r\n    List<Integer> other = Lists.newArrayList();\r\n    for (int i = 0; i < 100; i++) {\r\n        dg.addNode(i);\r\n        if (i % 15 == 0) {\r\n            fizzBuzz.add(i);\r\n        } else if (i % 5 == 0) {\r\n            buzz.add(i);\r\n        } else if (i % 3 == 0) {\r\n            fizz.add(i);\r\n        } else {\r\n            other.add(i);\r\n        }\r\n    }\r\n    for (Integer f : fizz) {\r\n        for (Integer o : other) {\r\n            dg.addEdge(0, f, o);\r\n        }\r\n    }\r\n    for (Integer b : buzz) {\r\n        for (Integer f : fizz) {\r\n            dg.addEdge(0, b, f);\r\n        }\r\n    }\r\n    for (Integer fb : fizzBuzz) {\r\n        for (Integer b : buzz) {\r\n            dg.addEdge(0, fb, b);\r\n        }\r\n    }\r\n    assertFreeNodesEquals(dg, other);\r\n    dg.setStatus(other, Status.FINISHED);\r\n    assertFreeNodesEquals(dg, fizz);\r\n    dg.setStatus(fizz, Status.FINISHED);\r\n    assertFreeNodesEquals(dg, buzz);\r\n    dg.setStatus(buzz, Status.FINISHED);\r\n    assertFreeNodesEquals(dg, fizzBuzz);\r\n    dg.setStatus(fizzBuzz, Status.FINISHED);\r\n    assertThat(dg.getFreeNodes()).isEmpty();\r\n    assertThat(dg.getNodeCountWithStatus(Status.READY)).isEqualTo(0);\r\n    assertThat(dg.getNodeCountWithStatus(Status.FINISHED)).isEqualTo(100);\r\n}"
}, {
	"Path": "com.android.datetimepicker.date.DayPickerView.onScroll",
	"Comment": "updates the title and selected month if the view has moved to a newmonth.",
	"Method": "void onScroll(AbsListView view,int firstVisibleItem,int visibleItemCount,int totalItemCount){\r\n    MonthView child = (MonthView) view.getChildAt(0);\r\n    if (child == null) {\r\n        return;\r\n    }\r\n    long currScroll = view.getFirstVisiblePosition() * child.getHeight() - child.getBottom();\r\n    mPreviousScrollPosition = currScroll;\r\n    mPreviousScrollState = mCurrentScrollState;\r\n}"
}, {
	"Path": "com.marshalchen.common.commonUtils.fileUtils.ParcelUtils.readHashMapStringKey",
	"Comment": "read a hashmap from a parcel, class of key is string, class of value can parcelable",
	"Method": "Map<String, V> readHashMapStringKey(Parcel in,ClassLoader loader){\r\n    if (in == null) {\r\n        return null;\r\n    }\r\n    int size = in.readInt();\r\n    if (size == -1) {\r\n        return null;\r\n    }\r\n    Map<String, V> map = new HashMap<String, V>();\r\n    for (int i = 0; i < size; i++) {\r\n        String key = in.readString();\r\n        map.put(key, (V) in.readParcelable(loader));\r\n    }\r\n    return map;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.androidviewhover.BlurLayout.enableTouchEvent",
	"Comment": "sets whether or not touching the blurlayout will trigger the hover view and blur effect",
	"Method": "void enableTouchEvent(boolean enableTouchEvent){\r\n    this.enableTouchEvent = enableTouchEvent;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.gesturedetectors.TwoFingerGestureDetector.getCurrentSpan",
	"Comment": "return the current distance between the two pointers forming thegesture in progress.",
	"Method": "float getCurrentSpan(){\r\n    if (mCurrLen == -1) {\r\n        final float cvx = mCurrFingerDiffX;\r\n        final float cvy = mCurrFingerDiffY;\r\n        mCurrLen = FloatMath.sqrt(cvx * cvx + cvy * cvy);\r\n    }\r\n    return mCurrLen;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.switchbutton.SwitchButton.fetchDrawableFromAttr",
	"Comment": "fetch drawable resources from attrs, drop them to conf, after the size\thas been confirmed",
	"Method": "void fetchDrawableFromAttr(TypedArray ta){\r\n    if (mConf == null) {\r\n        return;\r\n    }\r\n    mConf.setOffDrawable(fetchDrawable(ta, R.styleable.SwitchButton_switch_button_offDrawable, R.styleable.SwitchButton_switch_button_offColor, Configuration.Default.DEFAULT_OFF_COLOR));\r\n    mConf.setOnDrawable(fetchDrawable(ta, R.styleable.SwitchButton_switch_button_onDrawable, R.styleable.SwitchButton_switch_button_onColor, Configuration.Default.DEFAULT_ON_COLOR));\r\n    mConf.setThumbDrawable(fetchDrawable(ta, R.styleable.SwitchButton_thumbDrawable, R.styleable.SwitchButton_thumbColor, Configuration.Default.DEFAULT_THUMB_COLOR));\r\n}"
}, {
	"Path": "org.isoron.androidbase.AndroidBugReporter.getBugReport",
	"Comment": "captures and returns a bug report. the bug report contains some deviceinformation and the logcat.",
	"Method": "String getBugReport(){\r\n    String logcat = getLogcat();\r\n    String deviceInfo = getDeviceInfo();\r\n    String log = \"---------- BUG REPORT BEGINS ----------\\n\";\r\n    log += deviceInfo + \"\\n\" + logcat;\r\n    log += \"---------- BUG REPORT ENDS ------------\\n\";\r\n    return log;\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.util.ThumbnailatorUtils.isSupportedOutputFormatType",
	"Comment": "returns whether a specified format type is supported for a specified\toutput format.",
	"Method": "boolean isSupportedOutputFormatType(String format,String type){\r\n    if (!isSupportedOutputFormat(format)) {\r\n        return false;\r\n    }\r\n    if (format == ThumbnailParameter.ORIGINAL_FORMAT && type == ThumbnailParameter.DEFAULT_FORMAT_TYPE) {\r\n        return true;\r\n    } else if (format == ThumbnailParameter.ORIGINAL_FORMAT && type != ThumbnailParameter.DEFAULT_FORMAT_TYPE) {\r\n        return false;\r\n    } else if (type == ThumbnailParameter.DEFAULT_FORMAT_TYPE) {\r\n        return true;\r\n    }\r\n    for (String supportedType : getSupportedOutputFormatTypes(format)) {\r\n        if (supportedType.equals(type)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "test.thread.parallelization.ParallelByMethodsTestCase3Scenario1.sanityCheck",
	"Comment": "verifies that the expected number of suite, test and test method level events were logged.",
	"Method": "void sanityCheck(){\r\n    assertEquals(suiteLevelEventLogs.size(), 2, \"There should be 2 suite level events logged for \" + SUITE + \": \" + suiteLevelEventLogs);\r\n    assertEquals(testLevelEventLogs.size(), 2, \"There should be 2 test level events logged for \" + SUITE + \": \" + testLevelEventLogs);\r\n    assertEquals(testMethodLevelEventLogs.size(), 45, \"There should be 45 test method level events logged for \" + SUITE + \": \" + testMethodLevelEventLogs);\r\n}"
}, {
	"Path": "org.testng.reporters.EmailableReporter2.writeScenarioSummary",
	"Comment": "writes the scenario summary for the results of a given state for a single test.",
	"Method": "void writeScenarioSummary(int writeScenarioSummary,String description,List<ClassResult> classResults,String cssClassPrefix,int startingScenarioIndex){\r\n    int scenarioCount = 0;\r\n    if (!classResults.isEmpty()) {\r\n        writer.print(\"<tr><th colspan=\\\"4\\\">\");\r\n        writer.print(description);\r\n        writer.print(\"<\/th><\/tr>\");\r\n        int scenarioIndex = startingScenarioIndex;\r\n        int classIndex = 0;\r\n        for (ClassResult classResult : classResults) {\r\n            String cssClass = cssClassPrefix + ((classIndex % 2) == 0 ? \"even\" : \"odd\");\r\n            buffer.setLength(0);\r\n            int scenariosPerClass = 0;\r\n            int methodIndex = 0;\r\n            for (MethodResult methodResult : classResult.getMethodResults()) {\r\n                List<ITestResult> results = methodResult.getResults();\r\n                int resultsCount = results.size();\r\n                assert resultsCount > 0;\r\n                ITestResult firstResult = results.iterator().next();\r\n                String methodName = Utils.escapeHtml(firstResult.getMethod().getMethodName());\r\n                long start = firstResult.getStartMillis();\r\n                long duration = firstResult.getEndMillis() - start;\r\n                if (methodIndex > 0) {\r\n                    buffer.append(\"<tr class=\\\"\").append(cssClass).append(\"\\\">\");\r\n                }\r\n                buffer.append(\"<td><a href=\\\"#m\").append(scenarioIndex).append(\"\\\">\").append(methodName).append(\"<\/a><\/td>\").append(\"<td rowspan=\\\"\").append(resultsCount).append(\"\\\">\").append(start).append(\"<\/td>\").append(\"<td rowspan=\\\"\").append(resultsCount).append(\"\\\">\").append(duration).append(\"<\/td><\/tr>\");\r\n                scenarioIndex++;\r\n                for (int i = 1; i < resultsCount; i++) {\r\n                    buffer.append(\"<tr class=\\\"\").append(cssClass).append(\"\\\">\").append(\"<td><a href=\\\"#m\").append(scenarioIndex).append(\"\\\">\").append(methodName).append(\"<\/a><\/td><\/tr>\");\r\n                    scenarioIndex++;\r\n                }\r\n                scenariosPerClass += resultsCount;\r\n                methodIndex++;\r\n            }\r\n            writer.print(\"<tr class=\\\"\");\r\n            writer.print(cssClass);\r\n            writer.print(\"\\\">\");\r\n            writer.print(\"<td rowspan=\\\"\");\r\n            writer.print(scenariosPerClass);\r\n            writer.print(\"\\\">\");\r\n            writer.print(Utils.escapeHtml(classResult.getClassName()));\r\n            writer.print(\"<\/td>\");\r\n            writer.print(buffer);\r\n            classIndex++;\r\n        }\r\n        scenarioCount = scenarioIndex - startingScenarioIndex;\r\n    }\r\n    return scenarioCount;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.simplemodule.DropDownListView.onBottom",
	"Comment": "on bottom loading, you can call it by manual, but you should manual call onbottomcomplete at the same time.",
	"Method": "void onBottom(){\r\n    if (isOnBottomStyle && !isOnBottomLoading) {\r\n        isOnBottomLoading = true;\r\n        onBottomBegin();\r\n        footerButton.performClick();\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.cropperimage.cropwindow.CropOverlayView.setInitialAttributeValues",
	"Comment": "sets all initial values, but does not call initcropwindow to reset theviews. used once at the very start to initialize the attributes.",
	"Method": "void setInitialAttributeValues(int guidelines,boolean fixAspectRatio,int aspectRatioX,int aspectRatioY){\r\n    if (guidelines < 0 || guidelines > 2)\r\n        throw new IllegalArgumentException(\"Guideline value must be set between 0 and 2. See documentation.\");\r\n    else\r\n        mGuidelines = guidelines;\r\n    mFixAspectRatio = fixAspectRatio;\r\n    if (aspectRatioX <= 0)\r\n        throw new IllegalArgumentException(\"Cannot set aspect ratio value to a number less than or equal to 0.\");\r\n    else {\r\n        mAspectRatioX = aspectRatioX;\r\n        mTargetAspectRatio = ((float) mAspectRatioX) / mAspectRatioY;\r\n    }\r\n    if (aspectRatioY <= 0)\r\n        throw new IllegalArgumentException(\"Cannot set aspect ratio value to a number less than or equal to 0.\");\r\n    else {\r\n        mAspectRatioY = aspectRatioY;\r\n        mTargetAspectRatio = ((float) mAspectRatioX) / mAspectRatioY;\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.cropperimage.util.AspectRatioUtil.calculateWidth",
	"Comment": "calculates the width of a rectangle given the top and bottom edges and anaspect ratio.",
	"Method": "float calculateWidth(float top,float bottom,float targetAspectRatio){\r\n    final float height = bottom - top;\r\n    final float width = targetAspectRatio * height;\r\n    return width;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.motion.ParallaxImageView.registerSensorManager",
	"Comment": "registers a sensor manager with the parallax imageview. should be called in onresumefrom an activity or fragment.",
	"Method": "void registerSensorManager(){\r\n    if (getContext() == null || mSensorManager != null)\r\n        return;\r\n    mSensorManager = (SensorManager) getContext().getSystemService(Context.SENSOR_SERVICE);\r\n    if (mSensorManager != null) {\r\n        mSensorManager.registerListener(this, mSensorManager.getDefaultSensor(Sensor.TYPE_ORIENTATION), SensorManager.SENSOR_DELAY_FASTEST);\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.staggeredgridview.ExtendableListView.adjustViewsUpOrDown",
	"Comment": "make sure views are touching the top or bottom edge, as appropriate forour gravity",
	"Method": "void adjustViewsUpOrDown(){\r\n    final int childCount = getChildCount();\r\n    int delta;\r\n    if (childCount > 0) {\r\n        delta = getHighestChildTop() - getListPaddingTop();\r\n        if (delta < 0) {\r\n            delta = 0;\r\n        }\r\n        if (delta != 0) {\r\n            offsetChildrenTopAndBottom(-delta);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.listviewanimations.itemmanipulation.InsertQueue.clearActive",
	"Comment": "clears the active states and inserts any pending pairs if applicable.",
	"Method": "void clearActive(){\r\n    mActiveIndexes.clear();\r\n    insertPending();\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.observablescrollview.ui.widget.SlidingTabLayout.setSelectedIndicatorColors",
	"Comment": "sets the colors to be used for indicating the selected tab. these colors are treated as acircular array. providing one color will mean that all tabs are indicated with the same color.",
	"Method": "void setSelectedIndicatorColors(int colors){\r\n    mTabStrip.setSelectedIndicatorColors(colors);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.animation.Keyframe.setInterpolator",
	"Comment": "sets the optional interpolator for this keyframe. a value of null indicatesthat there is no interpolation, which is the same as linear interpolation.",
	"Method": "void setInterpolator(Interpolator interpolator){\r\n    mInterpolator = interpolator;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.tileView.layouts.ZoomPanLayout.isFlinging",
	"Comment": "returns whether the zoompanlayout is currently being flung",
	"Method": "boolean isFlinging(){\r\n    return isBeingFlung;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.animation.ValueAnimator.delayedAnimationFrame",
	"Comment": "internal function called to process an animation frame on an animation that is currentlysleeping through its startdelay phase. the return value indicates whether itshould be woken up and put on the active animations queue.",
	"Method": "boolean delayedAnimationFrame(long currentTime){\r\n    if (!mStartedDelay) {\r\n        mStartedDelay = true;\r\n        mDelayStartTime = currentTime;\r\n    } else {\r\n        long deltaTime = currentTime - mDelayStartTime;\r\n        if (deltaTime > mStartDelay) {\r\n            mStartTime = currentTime - (deltaTime - mStartDelay);\r\n            mPlayingState = RUNNING;\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.tileView.tileview.TileView.setTileSetPatternParser",
	"Comment": "define a custom parser to manage string file names representing image tiles",
	"Method": "void setTileSetPatternParser(DetailLevelPatternParser parser){\r\n    detailManager.setDetailLevelPatternParser(parser);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.rippleDrawable.RippleBackground.getBounds",
	"Comment": "returns the maximum bounds of the ripple relative to the ripple center.",
	"Method": "void getBounds(Rect bounds){\r\n    final int outerX = (int) mOuterX;\r\n    final int outerY = (int) mOuterY;\r\n    final int r = (int) mOuterRadius + 1;\r\n    bounds.set(outerX - r, outerY - r, outerX + r, outerY + r);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.kenburnsview.KenBurnsView.handleImageChange",
	"Comment": "this method is called every time the underlying imageis changed.",
	"Method": "void handleImageChange(){\r\n    updateDrawableBounds();\r\n    if (mInitialized && !mViewportRect.isEmpty()) {\r\n        startNewTransition();\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.kenburnsview.KenBurnsView.updateDrawableBounds",
	"Comment": "updates the drawable bounds rect. this must be called every time the drawableassociated to this view changes.",
	"Method": "void updateDrawableBounds(){\r\n    Drawable d = getDrawable();\r\n    if (d != null) {\r\n        if (mDrawableRect == null) {\r\n            mDrawableRect = new RectF();\r\n        }\r\n        mDrawableRect.set(0, 0, d.getIntrinsicWidth(), d.getIntrinsicHeight());\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.listviewanimations.itemmanipulation.ExpandableListItemAdapter.expand",
	"Comment": "expand the view at given position. will do nothing if the view is already expanded.",
	"Method": "void expand(int position){\r\n    long itemId = getItemId(position);\r\n    if (mExpandedIds.contains(itemId)) {\r\n        return;\r\n    }\r\n    toggle(position);\r\n}"
}, {
	"Path": "org.testng.internal.Utils.annotationFormFor",
	"Comment": "given a testng method, returns the corresponding annotation based on the method type",
	"Method": "String annotationFormFor(ITestNGMethod method){\r\n    if (method.isBeforeSuiteConfiguration()) {\r\n        return \"@BeforeSuite\";\r\n    }\r\n    if (method.isBeforeTestConfiguration()) {\r\n        return \"@BeforeTest\";\r\n    }\r\n    if (method.isBeforeClassConfiguration()) {\r\n        return \"@BeforeClass\";\r\n    }\r\n    if (method.isBeforeGroupsConfiguration()) {\r\n        return \"@BeforeGroups\";\r\n    }\r\n    if (method.isBeforeMethodConfiguration()) {\r\n        return \"@BeforeMethod\";\r\n    }\r\n    if (method.isAfterMethodConfiguration()) {\r\n        return \"@AfterMethod\";\r\n    }\r\n    if (method.isAfterGroupsConfiguration()) {\r\n        return \"@AfterGroups\";\r\n    }\r\n    if (method.isAfterClassConfiguration()) {\r\n        return \"@AfterClass\";\r\n    }\r\n    if (method.isAfterTestConfiguration()) {\r\n        return \"@AfterTest\";\r\n    }\r\n    if (method.isAfterSuiteConfiguration()) {\r\n        return \"@AfterSuite\";\r\n    }\r\n    return \"\";\r\n}"
}, {
	"Path": "test.thread.parallelization.TestNgRunStateTracker.getSuiteAndTestLevelEventLogsForSuite",
	"Comment": "get all suite and test level event logs for the specified suite",
	"Method": "List<EventLog> getSuiteAndTestLevelEventLogsForSuite(String suiteName){\r\n    List<EventLog> testEventLogs = new ArrayList();\r\n    for (EventLog eventLog : eventLogs) {\r\n        if ((isSuiteLevelEventLog(eventLog) || isTestLevelEventLog(eventLog)) && belongsToSuite(suiteName, eventLog)) {\r\n            testEventLogs.add(eventLog);\r\n        }\r\n    }\r\n    return testEventLogs;\r\n}"
}, {
	"Path": "org.testng.internal.Utils.checkInstanceOrStatic",
	"Comment": "make sure that either we have an instance or if not, that the method is static",
	"Method": "void checkInstanceOrStatic(Object instance,Method method){\r\n    if (instance == null && method != null && !Modifier.isStatic(method.getModifiers())) {\r\n        throw new TestNGException(\"Can't invoke \" + method + \": either make it static or add \" + \"a no-args constructor to your class\");\r\n    }\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.util.exif.IfdStructure.getCount",
	"Comment": "returns the count element in the ifd structure, indicating the number\tof values the value field..",
	"Method": "int getCount(){\r\n    return count;\r\n}"
}, {
	"Path": "com.marshalchen.common.commonUtils.fileUtils.PreferencesUtils.getString",
	"Comment": "get string from custom preferences with custom default value",
	"Method": "String getString(Context context,String key,String getString,Context context,String preferenceName,String key,String getString,Context context,String preferenceName,String key,String defaultValue){\r\n    SharedPreferences settings = context.getSharedPreferences(preferenceName, Context.MODE_PRIVATE);\r\n    return settings.getString(key, defaultValue);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.imageprocessing.FastImageProcessingPipeline.addRootRenderer",
	"Comment": "adds a root node of graph of filters that the pipeline will process and draw to the given endpoints of the graph.",
	"Method": "void addRootRenderer(GLRenderer rootRenderer){\r\n    rootRenderers.add(rootRenderer);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.simplemodule.DropDownListView.setHeaderPaddingTopRate",
	"Comment": "set rate about drop down distance and header padding top when drop down",
	"Method": "void setHeaderPaddingTopRate(float headerPaddingTopRate){\r\n    this.headerPaddingTopRate = headerPaddingTopRate;\r\n}"
}, {
	"Path": "test.conffailure.ClassWithFailedBeforeTestClassVerification.setUpShouldPass",
	"Comment": "should be run even though classwithfailedbeforetestclass failed in its configuration",
	"Method": "void setUpShouldPass(){\r\n    m_success1 = true;\r\n}"
}, {
	"Path": "org.testng.TestRunner.getAllPackages",
	"Comment": "returns all packages to use for the current test. this includes the test from the testsuite. never returns null.",
	"Method": "List<XmlPackage> getAllPackages(){\r\n    final List<XmlPackage> allPackages = Lists.newArrayList();\r\n    final List<XmlPackage> suitePackages = this.m_xmlTest.getSuite().getPackages();\r\n    if (suitePackages != null) {\r\n        allPackages.addAll(suitePackages);\r\n    }\r\n    final List<XmlPackage> testPackages = this.m_xmlTest.getPackages();\r\n    if (testPackages != null) {\r\n        allPackages.addAll(testPackages);\r\n    }\r\n    return allPackages;\r\n}"
}, {
	"Path": "com.marshalchen.common.commonUtils.fileUtils.FileUtils.isFolderExist",
	"Comment": "indicates if this file represents a directory on the underlying file system.",
	"Method": "boolean isFolderExist(String directoryPath){\r\n    if (StringUtils.isBlank(directoryPath)) {\r\n        return false;\r\n    }\r\n    File dire = new File(directoryPath);\r\n    return (dire.exists() && dire.isDirectory());\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.recyclerplayground.layout.StaticGridLayoutManager.scrollVerticallyBy",
	"Comment": "this method describes how far recyclerview thinks the contents should scroll vertically.you are responsible for verifying edge boundaries, and determining if this scrollevent somehow requires that new views be added or old views get recycled.",
	"Method": "int scrollVerticallyBy(int dy,RecyclerView.Recycler recycler,RecyclerView.State state){\r\n    if (getChildCount() == 0) {\r\n        return 0;\r\n    }\r\n    final View topView = getChildAt(0);\r\n    final View bottomView = getChildAt(getChildCount() - 1);\r\n    int viewSpan = getDecoratedBottom(bottomView) - getDecoratedTop(topView);\r\n    if (viewSpan <= getVerticalSpace()) {\r\n        return 0;\r\n    }\r\n    int delta;\r\n    int maxRowCount = getTotalRowCount();\r\n    boolean topBoundReached = getFirstVisibleRow() == 0;\r\n    boolean bottomBoundReached = getLastVisibleRow() >= maxRowCount;\r\n    if (dy > 0) {\r\n        if (bottomBoundReached) {\r\n            int bottomOffset;\r\n            if (rowOfIndex(getChildCount() - 1) >= (maxRowCount - 1)) {\r\n                bottomOffset = getVerticalSpace() - getDecoratedBottom(bottomView) + getPaddingBottom();\r\n            } else {\r\n                bottomOffset = getVerticalSpace() - (getDecoratedBottom(bottomView) + mDecoratedChildHeight) + getPaddingBottom();\r\n            }\r\n            delta = Math.max(-dy, bottomOffset);\r\n        } else {\r\n            delta = -dy;\r\n        }\r\n    } else {\r\n        if (topBoundReached) {\r\n            int topOffset = -getDecoratedTop(topView) + getPaddingTop();\r\n            delta = Math.min(-dy, topOffset);\r\n        } else {\r\n            delta = -dy;\r\n        }\r\n    }\r\n    offsetChildrenVertical(delta);\r\n    if (dy > 0) {\r\n        if (getDecoratedBottom(topView) < 0 && !bottomBoundReached) {\r\n            fillGrid(DIRECTION_DOWN, recycler);\r\n        } else if (!bottomBoundReached) {\r\n            fillGrid(DIRECTION_NONE, recycler);\r\n        }\r\n    } else {\r\n        if (getDecoratedTop(topView) > 0 && !topBoundReached) {\r\n            fillGrid(DIRECTION_UP, recycler);\r\n        } else if (!topBoundReached) {\r\n            fillGrid(DIRECTION_NONE, recycler);\r\n        }\r\n    }\r\n    return -delta;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.twowayview.ItemClickSupport.setOnItemLongClickListener",
	"Comment": "register a callback to be invoked when an item in therecyclerview has been clicked and held.",
	"Method": "void setOnItemLongClickListener(OnItemLongClickListener listener){\r\n    if (!mRecyclerView.isLongClickable()) {\r\n        mRecyclerView.setLongClickable(true);\r\n    }\r\n    mItemLongClickListener = listener;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.square_progressbar.SquareProgressBar.drawStartline",
	"Comment": "draws the startline. this is the line where the progressbar starts the\tdrawing around the image.",
	"Method": "void drawStartline(boolean drawStartline){\r\n    bar.setStartline(drawStartline);\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.nineoldandroids.animation.AnimatorInflater.loadAnimator",
	"Comment": "creates a new animation whose parameters come from the specified context andattributes set.",
	"Method": "Animator loadAnimator(Context context,int id,ValueAnimator loadAnimator,Context context,AttributeSet attrs,ValueAnimator anim){\r\n    TypedArray a = context.obtainStyledAttributes(attrs, Animator);\r\n    long duration = a.getInt(Animator_duration, 0);\r\n    long startDelay = a.getInt(Animator_startOffset, 0);\r\n    int valueType = a.getInt(Animator_valueType, VALUE_TYPE_FLOAT);\r\n    if (anim == null) {\r\n        anim = new ValueAnimator();\r\n    }\r\n    int valueFromIndex = Animator_valueFrom;\r\n    int valueToIndex = Animator_valueTo;\r\n    boolean getFloats = (valueType == VALUE_TYPE_FLOAT);\r\n    TypedValue tvFrom = a.peekValue(valueFromIndex);\r\n    boolean hasFrom = (tvFrom != null);\r\n    int fromType = hasFrom ? tvFrom.type : 0;\r\n    TypedValue tvTo = a.peekValue(valueToIndex);\r\n    boolean hasTo = (tvTo != null);\r\n    int toType = hasTo ? tvTo.type : 0;\r\n    if ((hasFrom && (fromType >= TypedValue.TYPE_FIRST_COLOR_INT) && (fromType <= TypedValue.TYPE_LAST_COLOR_INT)) || (hasTo && (toType >= TypedValue.TYPE_FIRST_COLOR_INT) && (toType <= TypedValue.TYPE_LAST_COLOR_INT))) {\r\n        getFloats = false;\r\n        anim.setEvaluator(new ArgbEvaluator());\r\n    }\r\n    if (getFloats) {\r\n        float valueFrom;\r\n        float valueTo;\r\n        if (hasFrom) {\r\n            if (fromType == TypedValue.TYPE_DIMENSION) {\r\n                valueFrom = a.getDimension(valueFromIndex, 0f);\r\n            } else {\r\n                valueFrom = a.getFloat(valueFromIndex, 0f);\r\n            }\r\n            if (hasTo) {\r\n                if (toType == TypedValue.TYPE_DIMENSION) {\r\n                    valueTo = a.getDimension(valueToIndex, 0f);\r\n                } else {\r\n                    valueTo = a.getFloat(valueToIndex, 0f);\r\n                }\r\n                anim.setFloatValues(valueFrom, valueTo);\r\n            } else {\r\n                anim.setFloatValues(valueFrom);\r\n            }\r\n        } else {\r\n            if (toType == TypedValue.TYPE_DIMENSION) {\r\n                valueTo = a.getDimension(valueToIndex, 0f);\r\n            } else {\r\n                valueTo = a.getFloat(valueToIndex, 0f);\r\n            }\r\n            anim.setFloatValues(valueTo);\r\n        }\r\n    } else {\r\n        int valueFrom;\r\n        int valueTo;\r\n        if (hasFrom) {\r\n            if (fromType == TypedValue.TYPE_DIMENSION) {\r\n                valueFrom = (int) a.getDimension(valueFromIndex, 0f);\r\n            } else if ((fromType >= TypedValue.TYPE_FIRST_COLOR_INT) && (fromType <= TypedValue.TYPE_LAST_COLOR_INT)) {\r\n                valueFrom = a.getColor(valueFromIndex, 0);\r\n            } else {\r\n                valueFrom = a.getInt(valueFromIndex, 0);\r\n            }\r\n            if (hasTo) {\r\n                if (toType == TypedValue.TYPE_DIMENSION) {\r\n                    valueTo = (int) a.getDimension(valueToIndex, 0f);\r\n                } else if ((toType >= TypedValue.TYPE_FIRST_COLOR_INT) && (toType <= TypedValue.TYPE_LAST_COLOR_INT)) {\r\n                    valueTo = a.getColor(valueToIndex, 0);\r\n                } else {\r\n                    valueTo = a.getInt(valueToIndex, 0);\r\n                }\r\n                anim.setIntValues(valueFrom, valueTo);\r\n            } else {\r\n                anim.setIntValues(valueFrom);\r\n            }\r\n        } else {\r\n            if (hasTo) {\r\n                if (toType == TypedValue.TYPE_DIMENSION) {\r\n                    valueTo = (int) a.getDimension(valueToIndex, 0f);\r\n                } else if ((toType >= TypedValue.TYPE_FIRST_COLOR_INT) && (toType <= TypedValue.TYPE_LAST_COLOR_INT)) {\r\n                    valueTo = a.getColor(valueToIndex, 0);\r\n                } else {\r\n                    valueTo = a.getInt(valueToIndex, 0);\r\n                }\r\n                anim.setIntValues(valueTo);\r\n            }\r\n        }\r\n    }\r\n    anim.setDuration(duration);\r\n    anim.setStartDelay(startDelay);\r\n    if (a.hasValue(Animator_repeatCount)) {\r\n        anim.setRepeatCount(a.getInt(Animator_repeatCount, 0));\r\n    }\r\n    if (a.hasValue(Animator_repeatMode)) {\r\n        anim.setRepeatMode(a.getInt(Animator_repeatMode, ValueAnimator.RESTART));\r\n    }\r\n    final int resID = a.getResourceId(Animator_interpolator, 0);\r\n    if (resID > 0) {\r\n        anim.setInterpolator(AnimationUtils.loadInterpolator(context, resID));\r\n    }\r\n    a.recycle();\r\n    return anim;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.tileView.layouts.ZoomPanLayout.addZoomPanListener",
	"Comment": "adds a zoompanlistener to the zoompanlayout, which will receive events relating to zoom and pan actions",
	"Method": "boolean addZoomPanListener(ZoomPanListener listener){\r\n    return zoomPanListeners.add(listener);\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.makers.ScaledThumbnailMaker.scale",
	"Comment": "sets the scaling factor for the thumbnail.\tthe aspect ratio of the resulting image is unaltered from the original.",
	"Method": "ScaledThumbnailMaker scale(double factor,ScaledThumbnailMaker scale,double widthFactor,double heightFactor){\r\n    if (ready.isSet(PARAM_SCALE)) {\r\n        throw new IllegalStateException(\"The scaling factor has already been set.\");\r\n    }\r\n    if (widthFactor <= 0 || heightFactor <= 0) {\r\n        throw new IllegalArgumentException(\"The scaling factor must be greater than zero.\");\r\n    }\r\n    this.widthFactor = widthFactor;\r\n    this.heightFactor = heightFactor;\r\n    ready.set(PARAM_SCALE);\r\n    return this;\r\n}"
}, {
	"Path": "com.marshalchen.common.demoofui.recyclerplayground.layout.FixedGridLayoutManager.canScrollVertically",
	"Comment": "use this method to tell the recyclerview if scrolling is even possiblein the vertical direction.",
	"Method": "boolean canScrollVertically(){\r\n    return true;\r\n}"
}, {
	"Path": "com.marshalchen.common.ui.ShimmerFrameLayout.setFixedWidth",
	"Comment": "set the fixed width of the highlight mask, regardless of the size of the layout.",
	"Method": "void setFixedWidth(int fixedWidth){\r\n    mMask.fixedWidth = fixedWidth;\r\n    resetAll();\r\n}"
}, {
	"Path": "com.marshalchen.ua.common.commonUtils.basicUtils.StringUtils.ifStringInList",
	"Comment": "judge if the arraylist contains the string variablethis method judgestrim string.",
	"Method": "boolean ifStringInList(String s,ArrayList<String> arrayList){\r\n    if (BasicUtils.judgeNotNull(s) && BasicUtils.judgeNotNull(arrayList)) {\r\n        for (String str : arrayList) {\r\n            if (str.trim().contains(s))\r\n                return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.name.ConsecutivelyNumberedFilenames.iterator",
	"Comment": "returns an iterator which generates file names according to the rules\tspecified by this object.",
	"Method": "Iterator<File> iterator(){\r\n    return iter;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.easyandroidanimations.FoldAnimation.getAnchorFactor",
	"Comment": "the available anchor factors range from 0 to 1. for example, in order to\tanchor the fold at the top, the anchor factor should be 0.",
	"Method": "float getAnchorFactor(){\r\n    return anchorFactor;\r\n}"
}, {
	"Path": "org.testng.TestNG.setTestSuites",
	"Comment": "set the suites file names to be run by this testng object. this method tries to load and parsethe specified testng suite xml files. if a file is missing, it is ignored.",
	"Method": "void setTestSuites(List<String> suites){\r\n    m_stringSuites = suites;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.simplemodule.FilckerAnimationListView.animatePreLayout",
	"Comment": "animate items that are deleted entirely and items that move out of\tbounds.",
	"Method": "void animatePreLayout(float durationUnit,Animator.AnimatorListener listener){\r\n    final AnimatorSet animatorSet = new AnimatorSet();\r\n    final int firstVisiblePosition = getFirstVisiblePosition();\r\n    final int childCount = getChildCount();\r\n    for (final Iterator<Entry<Long, Float>> iter = yMap.entrySet().iterator(); iter.hasNext(); ) {\r\n        final Entry<Long, Float> entry = iter.next();\r\n        final long id = entry.getKey();\r\n        final int oldPos = positionMap.get(id);\r\n        final View child = getChildAt(oldPos - firstVisiblePosition);\r\n        final int newPos = getPositionForId(id);\r\n        if (newPos == -1) {\r\n            final ObjectAnimator anim = animateAlpha(child, false);\r\n            animatorSet.play(anim);\r\n            iter.remove();\r\n            positionMap.remove(id);\r\n            continue;\r\n        }\r\n        if (newPos < firstVisiblePosition || newPos > firstVisiblePosition + childCount) {\r\n            final float offset;\r\n            if (newPos < firstVisiblePosition) {\r\n                offset = -getHeight();\r\n            } else {\r\n                offset = getHeight();\r\n            }\r\n            final AnimatorProxy proxy = AnimatorProxy.wrap(child);\r\n            final ObjectAnimator anim = ObjectAnimator.ofFloat(proxy, \"translationY\", 0f, offset);\r\n            final int finalDuration = getDuration(0, getHeight() / 2, durationUnit);\r\n            anim.setInterpolator(new AccelerateInterpolator());\r\n            anim.setDuration((long) (finalDuration * animationDurationFactor));\r\n            animatorSet.addListener(new AnimatorListenerAdapter() {\r\n                @Override\r\n                public void onAnimationEnd(final Animator animation) {\r\n                    child.post(new Runnable() {\r\n                        @Override\r\n                        public void run() {\r\n                            proxy.setTranslationY(0f);\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n            animatorSet.play(anim);\r\n            iter.remove();\r\n            positionMap.remove(id);\r\n            continue;\r\n        }\r\n    }\r\n    if (!animatorSet.getChildAnimations().isEmpty()) {\r\n        animatorSet.addListener(listener);\r\n        animatorSet.start();\r\n    } else {\r\n        listener.onAnimationEnd(animatorSet);\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.simplemodule.FilckerAnimationListView.animatePreLayout",
	"Comment": "animate items that are deleted entirely and items that move out of\tbounds.",
	"Method": "void animatePreLayout(float durationUnit,Animator.AnimatorListener listener){\r\n    child.post(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            proxy.setTranslationY(0f);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.simplemodule.FilckerAnimationListView.animatePreLayout",
	"Comment": "animate items that are deleted entirely and items that move out of\tbounds.",
	"Method": "void animatePreLayout(float durationUnit,Animator.AnimatorListener listener){\r\n    proxy.setTranslationY(0f);\r\n}"
}, {
	"Path": "com.marshalchen.common.ui.MaterialProgressWheel.setInstantProgress",
	"Comment": "set the progress to a specific value,the bar will be set instantly to that value",
	"Method": "void setInstantProgress(float progress){\r\n    if (isSpinning) {\r\n        mProgress = 0.0f;\r\n        isSpinning = false;\r\n    }\r\n    if (progress > 1.0f) {\r\n        progress -= 1.0f;\r\n    } else if (progress < 0) {\r\n        progress = 0;\r\n    }\r\n    if (progress == mTargetProgress) {\r\n        return;\r\n    }\r\n    mTargetProgress = Math.min(progress * 360.0f, 360.0f);\r\n    mProgress = mTargetProgress;\r\n    lastTimeAnimated = SystemClock.uptimeMillis();\r\n    invalidate();\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.swipeback.SwipeBackLayout.setScrollThresHold",
	"Comment": "set scroll threshold, we will close the activity, when scrollpercent overthis value",
	"Method": "void setScrollThresHold(float threshold){\r\n    if (threshold >= 1.0f || threshold <= 0) {\r\n        throw new IllegalArgumentException(\"Threshold value should be between 0 and 1.0\");\r\n    }\r\n    mScrollThreshold = threshold;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.cropperimage.util.AspectRatioUtil.calculateHeight",
	"Comment": "calculates the height of a rectangle given the left and right edges andan aspect ratio.",
	"Method": "float calculateHeight(float left,float right,float targetAspectRatio){\r\n    final float width = right - left;\r\n    final float height = width / targetAspectRatio;\r\n    return height;\r\n}"
}, {
	"Path": "com.marshalchen.common.uimodule.weekview.WeekView.deleteFarMonths",
	"Comment": "deletes the events of the months that are too far away from the current month.",
	"Method": "void deleteFarMonths(Calendar currentDay){\r\n    if (mEventRects == null)\r\n        return;\r\n    Calendar nextMonth = (Calendar) currentDay.clone();\r\n    nextMonth.add(Calendar.MONTH, 1);\r\n    nextMonth.set(Calendar.DAY_OF_MONTH, nextMonth.getActualMaximum(Calendar.DAY_OF_MONTH));\r\n    nextMonth.set(Calendar.HOUR_OF_DAY, 12);\r\n    nextMonth.set(Calendar.MINUTE, 59);\r\n    nextMonth.set(Calendar.SECOND, 59);\r\n    Calendar prevMonth = (Calendar) currentDay.clone();\r\n    prevMonth.add(Calendar.MONTH, -1);\r\n    prevMonth.set(Calendar.DAY_OF_MONTH, 1);\r\n    prevMonth.set(Calendar.HOUR_OF_DAY, 0);\r\n    prevMonth.set(Calendar.MINUTE, 0);\r\n    prevMonth.set(Calendar.SECOND, 0);\r\n    List<EventRect> newEvents = new ArrayList<EventRect>();\r\n    for (EventRect eventRect : mEventRects) {\r\n        boolean isFarMonth = eventRect.event.getStartTime().getTimeInMillis() > nextMonth.getTimeInMillis() || eventRect.event.getEndTime().getTimeInMillis() < prevMonth.getTimeInMillis();\r\n        if (!isFarMonth)\r\n            newEvents.add(eventRect);\r\n    }\r\n    mEventRects.clear();\r\n    mEventRects.addAll(newEvents);\r\n}"
}]