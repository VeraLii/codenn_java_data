[{
	"Path": "org.drools.core.definitions.rule.impl.RuleImpl.setTimer",
	"Comment": "sets the timer semantics for a rule. timer based rules are not added directly to the agendainstead they are scheduled for agenda addition, based on the timer.",
	"Method": "void setTimer(Timer timer){\r\n    this.timer = timer;\r\n}"
}, {
	"Path": "org.drools.compiler.integrationtests.marshalling.MarshallingTest.testSerializabilityWithJarFacts",
	"Comment": "in this case we are dealing with facts which are not on the systems classpath.",
	"Method": "void testSerializabilityWithJarFacts(){\r\n    MapBackedClassLoader loader = new MapBackedClassLoader(this.getClass().getClassLoader());\r\n    JarInputStream jis = new JarInputStream(this.getClass().getResourceAsStream(\"/billasurf.jar\"));\r\n    JarEntry entry = null;\r\n    byte[] buf = new byte[1024];\r\n    int len = 0;\r\n    while ((entry = jis.getNextJarEntry()) != null) {\r\n        if (!entry.isDirectory()) {\r\n            ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n            while ((len = jis.read(buf)) >= 0) {\r\n                out.write(buf, 0, len);\r\n            }\r\n            loader.addResource(entry.getName(), out.toByteArray());\r\n        }\r\n    }\r\n    String drl = \"package foo.bar \\n\" + \"import com.billasurf.Board\\n\" + \"rule 'MyGoodRule' \\n dialect 'mvel' \\n when \" + \"   Board() \" + \"then \\n\" + \" System.err.println(42); \\n\" + \"end\\n\";\r\n    KnowledgeBuilderConfiguration kbuilderConf = KnowledgeBuilderFactory.newKnowledgeBuilderConfiguration(null, loader);\r\n    Collection<KiePackage> kpkgs = loadKnowledgePackagesFromString(kbuilderConf, drl);\r\n    kpkgs = SerializationHelper.serializeObject(kpkgs, loader);\r\n}"
}, {
	"Path": "org.drools.core.definitions.rule.impl.RuleImpl.setEnabled",
	"Comment": "a rule is enabled by default. this can explicitly disable it in which case it will never activate.",
	"Method": "void setEnabled(Enabled b){\r\n    this.enabled = b;\r\n}"
}, {
	"Path": "org.drools.compiler.integrationtests.eventgenerator.PseudoSessionClock.timeinHMSM",
	"Comment": "convert time given as hours, minutes, seconds, milliseconds to milliseconds",
	"Method": "long timeinHMSM(long hours,long mins,long secs,long msecs){\r\n    return timeInHours(hours) + timeInMinutes(mins) + timeInSeconds(secs) + msecs;\r\n}"
}, {
	"Path": "org.drools.core.impl.StatefulKnowledgeSessionImpl.iterateObjects",
	"Comment": "this class is not thread safe, changes to the working memory duringiteration may give unexpected results",
	"Method": "Iterator iterateObjects(Iterator iterateObjects,org.kie.api.runtime.ObjectFilter filter){\r\n    return getObjectStore().iterateObjects(filter);\r\n}"
}, {
	"Path": "org.drools.core.rule.DialectRuntimeRegistry.writeExternal",
	"Comment": "handles the write serialization of the packagecompilationdata. patterns in rules may reference generated data which cannot be serialized bydefault methods. the packagecompilationdata holds a reference to the generated bytecode. the generated bytecode must be restored before any rules.",
	"Method": "void writeExternal(ObjectOutput stream){\r\n    stream.writeObject(this.dialects);\r\n    stream.writeObject(this.lineMappings);\r\n}"
}, {
	"Path": "org.drools.core.reteoo.LeftTupleSinkNodeList.add",
	"Comment": "add a tuplesinknode to the list. if the linkedlist is empty then the first andlast nodes are set to the added node.",
	"Method": "void add(LeftTupleSinkNode node){\r\n    if (this.firstNode == null) {\r\n        this.firstNode = node;\r\n        this.lastNode = node;\r\n        ;\r\n    } else {\r\n        this.lastNode.setNextLeftTupleSinkNode(node);\r\n        node.setPreviousLeftTupleSinkNode(this.lastNode);\r\n        this.lastNode = node;\r\n    }\r\n    this.size++;\r\n}"
}, {
	"Path": "org.drools.core.rule.EntryPointId.getOuterDeclarations",
	"Comment": "it is not possible to declare and export any variables,so always return an empty map",
	"Method": "Map<String, Declaration> getOuterDeclarations(){\r\n    return Collections.EMPTY_MAP;\r\n}"
}, {
	"Path": "org.drools.core.audit.WorkingMemoryLogger.removeFilter",
	"Comment": "removes the given filter from the list of filters for this event log.if the given filter was not a filter of this event log, nothinghappens.",
	"Method": "void removeFilter(ILogEventFilter filter){\r\n    this.filters.remove(filter);\r\n}"
}, {
	"Path": "org.drools.core.rule.ConditionalBranch.getInnerDeclarations",
	"Comment": "it is not possible to declare any new variables, so alwaysreturn an empty map",
	"Method": "Map<String, Declaration> getInnerDeclarations(){\r\n    return Collections.emptyMap();\r\n}"
}, {
	"Path": "org.drools.core.common.ProjectClassLoader.internalLoadClass",
	"Comment": "this method has to be public because is also used by the android classloader",
	"Method": "Class<?> internalLoadClass(String name,boolean resolve){\r\n    if (CACHE_NON_EXISTING_CLASSES && nonExistingClasses.contains(name)) {\r\n        throw dummyCFNE;\r\n    }\r\n    if (droolsClassLoader != null) {\r\n        try {\r\n            return Class.forName(name, resolve, droolsClassLoader);\r\n        } catch (ClassNotFoundException e) {\r\n        }\r\n    }\r\n    try {\r\n        return super.loadClass(name, resolve);\r\n    } catch (ClassNotFoundException e) {\r\n        return Class.forName(name, resolve, getParent());\r\n    }\r\n}"
}, {
	"Path": "org.drools.core.reteoo.compiled.AbstractCompilerHandler.getVariableName",
	"Comment": "returns a variable name based on the simple name of the specified class appended with the specifiednodeid.",
	"Method": "String getVariableName(AlphaNode alphaNode,String getVariableName,Sink sink,String getVariableName,String getVariableName,Class clazz,int nodeId){\r\n    String type = clazz.getSimpleName();\r\n    return Character.toLowerCase(type.charAt(0)) + type.substring(1) + nodeId;\r\n}"
}, {
	"Path": "org.drools.core.base.evaluators.EvaluatorRegistry.getEvaluatorDefinition",
	"Comment": "returns the evaluator definition for the given operatoror null if no one was found",
	"Method": "EvaluatorDefinition getEvaluatorDefinition(String evaluatorId,EvaluatorDefinition getEvaluatorDefinition,Operator operator){\r\n    return this.evaluators.get(operator.getOperatorString());\r\n}"
}, {
	"Path": "org.drools.core.reteoo.builder.BuildUtils.createBetaNodeConstraint",
	"Comment": "creates and returns a betaconstraints object for the given list of constraints",
	"Method": "BetaConstraints createBetaNodeConstraint(BuildContext context,List<BetaNodeFieldConstraint> list,boolean disableIndexing){\r\n    BetaConstraints constraints;\r\n    switch(list.size()) {\r\n        case 0:\r\n            constraints = EmptyBetaConstraints.getInstance();\r\n            break;\r\n        case 1:\r\n            constraints = new SingleBetaConstraints(list.get(0), context.getKnowledgeBase().getConfiguration(), disableIndexing);\r\n            break;\r\n        case 2:\r\n            constraints = new DoubleBetaConstraints(list.toArray(new BetaNodeFieldConstraint[list.size()]), context.getKnowledgeBase().getConfiguration(), disableIndexing);\r\n            break;\r\n        case 3:\r\n            constraints = new TripleBetaConstraints(list.toArray(new BetaNodeFieldConstraint[list.size()]), context.getKnowledgeBase().getConfiguration(), disableIndexing);\r\n            break;\r\n        case 4:\r\n            constraints = new QuadroupleBetaConstraints(list.toArray(new BetaNodeFieldConstraint[list.size()]), context.getKnowledgeBase().getConfiguration(), disableIndexing);\r\n            break;\r\n        default:\r\n            constraints = new DefaultBetaConstraints(list.toArray(new BetaNodeFieldConstraint[list.size()]), context.getKnowledgeBase().getConfiguration(), disableIndexing);\r\n    }\r\n    return constraints;\r\n}"
}, {
	"Path": "org.drools.core.definitions.rule.impl.RuleImpl.getDeclarations",
	"Comment": "retrieve the set of all root fact objectparameterdeclarations.",
	"Method": "Map<String, Declaration> getDeclarations(){\r\n    if (this.dirty || (this.declarations == null)) {\r\n        this.declarations = this.getExtendedLhs(this, null).getOuterDeclarations();\r\n        this.dirty = false;\r\n    }\r\n    return this.declarations;\r\n}"
}, {
	"Path": "org.drools.core.phreak.AddRemoveRule.addRule",
	"Comment": "this method is called after the rule nodes have been added to the networkfor add tuples are processed after the segments and pmems have been adjusted",
	"Method": "void addRule(TerminalNode tn,Collection<InternalWorkingMemory> wms,InternalKnowledgeBase kBase){\r\n    if (log.isTraceEnabled()) {\r\n        log.trace(\"Adding Rule {}\", tn.getRule().getName());\r\n    }\r\n    boolean hasProtos = kBase.hasSegmentPrototypes();\r\n    boolean hasWms = !wms.isEmpty();\r\n    if (!hasProtos && !hasWms) {\r\n        return;\r\n    }\r\n    RuleImpl rule = tn.getRule();\r\n    LeftTupleNode firstSplit = getNetworkSplitPoint(tn);\r\n    PathEndNodes pathEndNodes = getPathEndNodes(kBase, firstSplit, tn, rule, hasProtos, hasWms);\r\n    for (InternalWorkingMemory wm : wms) {\r\n        wm.flushPropagations();\r\n        if (NodeTypeEnums.LeftInputAdapterNode == firstSplit.getType() && firstSplit.getAssociationsSize() == 1) {\r\n            insertLiaFacts(firstSplit, wm);\r\n        } else {\r\n            PathEndNodeMemories tnms = getPathEndMemories(wm, pathEndNodes);\r\n            if (tnms.subjectPmem == null) {\r\n                continue;\r\n            }\r\n            Map<PathMemory, SegmentMemory[]> prevSmemsLookup = reInitPathMemories(tnms.otherPmems, null);\r\n            Set<SegmentMemory> smemsToNotify = handleExistingPaths(tn, prevSmemsLookup, tnms.otherPmems, wm, ExistingPathStrategy.ADD_STRATEGY);\r\n            addNewPaths(wm, smemsToNotify, tnms.subjectPmems);\r\n            processLeftTuples(firstSplit, wm, true, rule);\r\n            notifySegments(smemsToNotify, wm);\r\n        }\r\n    }\r\n    if (hasWms) {\r\n        insertFacts(pathEndNodes, wms);\r\n    } else {\r\n        for (PathEndNode node : pathEndNodes.otherEndNodes) {\r\n            node.resetPathMemSpec(null);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.drools.compiler.rule.builder.util.PackageBuilderUtil.isReadLocalsFromTuple",
	"Comment": "this method checks for the conditions when local declarations should be read from a tuple insteadof the right object when resolving declarations in an accumulate",
	"Method": "boolean isReadLocalsFromTuple(RuleBuildContext context,AccumulateDescr accumDescr,RuleConditionElement source){\r\n    if (accumDescr.isMultiPattern()) {\r\n        return true;\r\n    }\r\n    PatternDescr inputPattern = accumDescr.getInputPattern();\r\n    if (inputPattern == null) {\r\n        context.addError(new DescrBuildError(context.getParentDescr(), accumDescr, null, \"Invalid accumulate pattern in rule '\" + context.getRule().getName() + \"'.\"));\r\n        return true;\r\n    }\r\n    if (source instanceof Pattern) {\r\n        if (((Pattern) source).hasXPath()) {\r\n            return true;\r\n        }\r\n        if (((Pattern) source).getSource() instanceof EntryPointId) {\r\n            return false;\r\n        }\r\n    }\r\n    if (inputPattern.getSource() != null && !(inputPattern.getSource() instanceof WindowReferenceDescr) && !(inputPattern.getSource() instanceof EntryPointDescr)) {\r\n        return true;\r\n    }\r\n    return source instanceof QueryElement || (source.getNestedElements().size() == 1 && source.getNestedElements().get(0) instanceof QueryElement);\r\n}"
}, {
	"Path": "org.drools.core.common.ProjectClassLoader.tryDefineType",
	"Comment": "this method has to be public because is also used by the android classloader",
	"Method": "Class<?> tryDefineType(String name,ClassNotFoundException cnfe){\r\n    byte[] bytecode = getBytecode(convertClassToResourcePath(name));\r\n    if (bytecode == null) {\r\n        if (CACHE_NON_EXISTING_CLASSES) {\r\n            nonExistingClasses.add(name);\r\n        }\r\n        throw cnfe != null ? cnfe : new ClassNotFoundException(name);\r\n    }\r\n    return defineType(name, bytecode);\r\n}"
}, {
	"Path": "org.drools.core.QueryResultsRowImpl.getDeclarations",
	"Comment": "return a map of declarations where the key is the identifier and the valueis the declaration.",
	"Method": "Map<String, Declaration> getDeclarations(){\r\n    return this.queryResults.getDeclarations(row.getSubruleIndex());\r\n}"
}, {
	"Path": "org.drools.core.common.ConcurrentNodeMemories.createNodeMemory",
	"Comment": "checks if a memory does not exists for the given node andcreates it.",
	"Method": "Memory createNodeMemory(MemoryFactory node,InternalWorkingMemory wm){\r\n    try {\r\n        this.lock.lock();\r\n        Memory memory = this.memories.get(node.getMemoryId());\r\n        if (memory == null) {\r\n            memory = node.createMemory(this.kBase.getConfiguration(), wm);\r\n            if (!this.memories.compareAndSet(node.getMemoryId(), null, memory)) {\r\n                memory = this.memories.get(node.getMemoryId());\r\n            }\r\n        }\r\n        return memory;\r\n    } finally {\r\n        this.lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.drools.core.phreak.AddRemoveRule.removeRule",
	"Comment": "this method is called before the rule nodes are removed from the network.for remove tuples are processed before the segments and pmems have been adjusted",
	"Method": "void removeRule(TerminalNode tn,Collection<InternalWorkingMemory> wms,InternalKnowledgeBase kBase){\r\n    if (log.isTraceEnabled()) {\r\n        log.trace(\"Removing Rule {}\", tn.getRule().getName());\r\n    }\r\n    boolean hasProtos = kBase.hasSegmentPrototypes();\r\n    boolean hasWms = !wms.isEmpty();\r\n    if (!hasProtos && !hasWms) {\r\n        return;\r\n    }\r\n    RuleImpl rule = tn.getRule();\r\n    LeftTupleNode firstSplit = getNetworkSplitPoint(tn);\r\n    PathEndNodes pathEndNodes = getPathEndNodes(kBase, firstSplit, tn, rule, hasProtos, hasWms);\r\n    for (InternalWorkingMemory wm : wms) {\r\n        wm.flushPropagations();\r\n        PathEndNodeMemories tnms = getPathEndMemories(wm, pathEndNodes);\r\n        if (!tnms.subjectPmems.isEmpty()) {\r\n            if (NodeTypeEnums.LeftInputAdapterNode == firstSplit.getType() && firstSplit.getAssociationsSize() == 1) {\r\n                if (tnms.subjectPmem != null) {\r\n                    flushStagedTuples(firstSplit, tnms.subjectPmem, wm);\r\n                }\r\n                processLeftTuples(firstSplit, wm, false, tn.getRule());\r\n                removeNewPaths(wm, tnms.subjectPmems);\r\n            } else {\r\n                flushStagedTuples(tn, tnms.subjectPmem, pathEndNodes, wm);\r\n                processLeftTuples(firstSplit, wm, false, tn.getRule());\r\n                removeNewPaths(wm, tnms.subjectPmems);\r\n                Map<PathMemory, SegmentMemory[]> prevSmemsLookup = reInitPathMemories(tnms.otherPmems, tn);\r\n                Set<SegmentMemory> smemsToNotify = handleExistingPaths(tn, prevSmemsLookup, tnms.otherPmems, wm, ExistingPathStrategy.REMOVE_STRATEGY);\r\n                notifySegments(smemsToNotify, wm);\r\n            }\r\n        }\r\n        if (tnms.subjectPmem != null && tnms.subjectPmem.isInitialized() && tnms.subjectPmem.getRuleAgendaItem().isQueued()) {\r\n            tnms.subjectPmem.getRuleAgendaItem().dequeue();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.drools.compiler.lang.descr.OperatorDescr.getLeftString",
	"Comment": "this is an internal cache of the left string parameter that is set during the rewriteinto mvel, allowing for further analysis of the parameter type.",
	"Method": "String getLeftString(){\r\n    return leftString;\r\n}"
}, {
	"Path": "org.drools.core.base.ClassFieldAccessorFactory.build3ArgConstructor",
	"Comment": "creates a constructor for the field extractor receivingthe index, field type and value type",
	"Method": "void build3ArgConstructor(Class<?> superClazz,String className,ClassWriter cw){\r\n    MethodVisitor mv;\r\n    {\r\n        mv = cw.visitMethod(Opcodes.ACC_PUBLIC, \"<init>\", Type.getMethodDescriptor(Type.VOID_TYPE, Type.getType(int.class), Type.getType(Class.class), Type.getType(ValueType.class)), null, null);\r\n        mv.visitCode();\r\n        final Label l0 = new Label();\r\n        mv.visitLabel(l0);\r\n        mv.visitVarInsn(Opcodes.ALOAD, 0);\r\n        mv.visitVarInsn(Opcodes.ILOAD, 1);\r\n        mv.visitVarInsn(Opcodes.ALOAD, 2);\r\n        mv.visitVarInsn(Opcodes.ALOAD, 3);\r\n        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, Type.getInternalName(superClazz), \"<init>\", Type.getMethodDescriptor(Type.VOID_TYPE, Type.getType(int.class), Type.getType(Class.class), Type.getType(ValueType.class)));\r\n        final Label l1 = new Label();\r\n        mv.visitLabel(l1);\r\n        mv.visitInsn(Opcodes.RETURN);\r\n        final Label l2 = new Label();\r\n        mv.visitLabel(l2);\r\n        mv.visitLocalVariable(\"this\", \"L\" + className + \";\", null, l0, l2, 0);\r\n        mv.visitLocalVariable(\"index\", Type.getDescriptor(int.class), null, l0, l2, 1);\r\n        mv.visitLocalVariable(\"fieldType\", Type.getDescriptor(Class.class), null, l0, l2, 2);\r\n        mv.visitLocalVariable(\"valueType\", Type.getDescriptor(ValueType.class), null, l0, l2, 3);\r\n        mv.visitMaxs(0, 0);\r\n        mv.visitEnd();\r\n    }\r\n}"
}, {
	"Path": "org.drools.compiler.reteoo.compiled.ObjectTypeNodeCompiler.createClassDeclaration",
	"Comment": "this method will output the package statement, followed by the opening of the class declaration",
	"Method": "void createClassDeclaration(){\r\n    builder.append(\"package \").append(PACKAGE_NAME).append(\";\").append(NEWLINE);\r\n    builder.append(\"public class \").append(generatedClassSimpleName).append(\" extends \").append(CompiledNetwork.class.getName()).append(\"{ \").append(NEWLINE);\r\n    builder.append(\"org.drools.core.spi.InternalReadAccessor readAccessor;\\n\");\r\n}"
}, {
	"Path": "org.drools.core.factmodel.DefaultBeanClassBuilder.buildTraitMap",
	"Comment": "a traitable class is a special class with support for dynamic properties and types.this method builds the trait map, containing the references to the proxiesfor each trait carried by an object at a given time.",
	"Method": "void buildTraitMap(ClassWriter cw,ClassDefinition classDef){\r\n    FieldVisitor fv = cw.visitField(ACC_PRIVATE, TraitableBean.TRAITSET_FIELD_NAME, Type.getDescriptor(Map.class), \"Ljava/util/Map<Ljava/lang/String;Lorg/drools/core/factmodel/traits/Thing;>;\", null);\r\n    fv.visitEnd();\r\n    MethodVisitor mv;\r\n    mv = cw.visitMethod(ACC_PUBLIC, \"_getTraitMap\", Type.getMethodDescriptor(Type.getType(Map.class), new Type[] {}), \"()Ljava/util/Map<Ljava/lang/String;Lorg/drools/factmodel/traits/Thing;>;\", null);\r\n    mv.visitCode();\r\n    mv.visitVarInsn(ALOAD, 0);\r\n    mv.visitFieldInsn(GETFIELD, BuildUtils.getInternalType(classDef.getName()), TraitableBean.TRAITSET_FIELD_NAME, Type.getDescriptor(Map.class));\r\n    mv.visitInsn(ARETURN);\r\n    mv.visitMaxs(0, 0);\r\n    mv.visitEnd();\r\n    mv = cw.visitMethod(ACC_PUBLIC, \"_setTraitMap\", Type.getMethodDescriptor(Type.getType(void.class), new Type[] { Type.getType(Map.class) }), null, null);\r\n    mv.visitCode();\r\n    mv.visitVarInsn(ALOAD, 0);\r\n    mv.visitVarInsn(ALOAD, 1);\r\n    mv.visitFieldInsn(PUTFIELD, BuildUtils.getInternalType(classDef.getName()), TraitableBean.TRAITSET_FIELD_NAME, Type.getDescriptor(Map.class));\r\n    mv.visitInsn(RETURN);\r\n    mv.visitMaxs(0, 0);\r\n    mv.visitEnd();\r\n    mv = cw.visitMethod(ACC_PUBLIC, \"addTrait\", Type.getMethodDescriptor(Type.getType(void.class), new Type[] { Type.getType(String.class), Type.getType(Thing.class) }), \"(Ljava/lang/String;Lorg/drools/core/factmodel/traits/Thing;)V\", null);\r\n    mv.visitCode();\r\n    mv.visitVarInsn(ALOAD, 0);\r\n    mv.visitMethodInsn(INVOKEVIRTUAL, BuildUtils.getInternalType(classDef.getName()), \"_getTraitMap\", Type.getMethodDescriptor(Type.getType(Map.class), new Type[] {}));\r\n    mv.visitVarInsn(ALOAD, 1);\r\n    mv.visitVarInsn(ALOAD, 2);\r\n    mv.visitMethodInsn(INVOKEINTERFACE, Type.getInternalName(Map.class), \"put\", Type.getMethodDescriptor(Type.getType(Object.class), new Type[] { Type.getType(Object.class), Type.getType(Object.class) }));\r\n    mv.visitInsn(POP);\r\n    mv.visitInsn(RETURN);\r\n    mv.visitMaxs(0, 0);\r\n    mv.visitEnd();\r\n    mv = cw.visitMethod(ACC_PUBLIC, \"getTrait\", Type.getMethodDescriptor(Type.getType(Thing.class), new Type[] { Type.getType(String.class) }), Type.getMethodDescriptor(Type.getType(Thing.class), new Type[] { Type.getType(String.class) }), null);\r\n    mv.visitCode();\r\n    mv.visitVarInsn(ALOAD, 0);\r\n    mv.visitMethodInsn(INVOKEVIRTUAL, BuildUtils.getInternalType(classDef.getName()), \"_getTraitMap\", Type.getMethodDescriptor(Type.getType(Map.class), new Type[] {}));\r\n    mv.visitVarInsn(ALOAD, 1);\r\n    mv.visitMethodInsn(INVOKEINTERFACE, Type.getInternalName(Map.class), \"get\", Type.getMethodDescriptor(Type.getType(Object.class), new Type[] { Type.getType(Object.class) }));\r\n    mv.visitTypeInsn(CHECKCAST, Type.getInternalName(Thing.class));\r\n    mv.visitInsn(ARETURN);\r\n    mv.visitMaxs(0, 0);\r\n    mv.visitEnd();\r\n    mv = cw.visitMethod(ACC_PUBLIC, \"hasTrait\", Type.getMethodDescriptor(Type.getType(boolean.class), new Type[] { Type.getType(String.class) }), null, null);\r\n    mv.visitCode();\r\n    mv.visitVarInsn(ALOAD, 0);\r\n    mv.visitMethodInsn(INVOKEVIRTUAL, BuildUtils.getInternalType(classDef.getName()), \"_getTraitMap\", Type.getMethodDescriptor(Type.getType(Map.class), new Type[] {}));\r\n    Label l0 = new Label();\r\n    mv.visitJumpInsn(IFNONNULL, l0);\r\n    mv.visitInsn(ICONST_0);\r\n    mv.visitInsn(IRETURN);\r\n    mv.visitLabel(l0);\r\n    mv.visitVarInsn(ALOAD, 0);\r\n    mv.visitMethodInsn(INVOKEVIRTUAL, BuildUtils.getInternalType(classDef.getName()), \"_getTraitMap\", Type.getMethodDescriptor(Type.getType(Map.class), new Type[] {}));\r\n    mv.visitVarInsn(ALOAD, 1);\r\n    mv.visitMethodInsn(INVOKEINTERFACE, Type.getInternalName(Map.class), \"containsKey\", Type.getMethodDescriptor(Type.getType(boolean.class), new Type[] { Type.getType(Object.class) }));\r\n    mv.visitInsn(IRETURN);\r\n    mv.visitMaxs(0, 0);\r\n    mv.visitEnd();\r\n    mv = cw.visitMethod(ACC_PUBLIC, \"hasTraits\", Type.getMethodDescriptor(Type.getType(boolean.class), new Type[] {}), null, null);\r\n    mv.visitCode();\r\n    mv.visitVarInsn(ALOAD, 0);\r\n    mv.visitFieldInsn(GETFIELD, BuildUtils.getInternalType(classDef.getName()), TraitableBean.TRAITSET_FIELD_NAME, Type.getDescriptor(Map.class));\r\n    Label l5 = new Label();\r\n    mv.visitJumpInsn(IFNULL, l5);\r\n    mv.visitVarInsn(ALOAD, 0);\r\n    mv.visitFieldInsn(GETFIELD, BuildUtils.getInternalType(classDef.getName()), TraitableBean.TRAITSET_FIELD_NAME, Type.getDescriptor(Map.class));\r\n    mv.visitMethodInsn(INVOKEINTERFACE, Type.getInternalName(Map.class), \"isEmpty\", Type.getMethodDescriptor(Type.BOOLEAN_TYPE, new Type[] {}));\r\n    mv.visitJumpInsn(IFNE, l5);\r\n    mv.visitInsn(ICONST_1);\r\n    Label l4 = new Label();\r\n    mv.visitJumpInsn(GOTO, l4);\r\n    mv.visitLabel(l5);\r\n    mv.visitInsn(ICONST_0);\r\n    mv.visitLabel(l4);\r\n    mv.visitInsn(IRETURN);\r\n    mv.visitMaxs(0, 0);\r\n    mv.visitEnd();\r\n    mv = cw.visitMethod(ACC_PUBLIC, \"removeTrait\", Type.getMethodDescriptor(Type.getType(Collection.class), new Type[] { Type.getType(String.class) }), Type.getMethodDescriptor(Type.getType(Collection.class), new Type[] { Type.getType(String.class) }), null);\r\n    mv.visitCode();\r\n    mv.visitVarInsn(ALOAD, 0);\r\n    mv.visitMethodInsn(INVOKEVIRTUAL, BuildUtils.getInternalType(classDef.getName()), \"_getTraitMap\", Type.getMethodDescriptor(Type.getType(Map.class), new Type[] {}));\r\n    mv.visitTypeInsn(CHECKCAST, Type.getInternalName(TraitTypeMap.class));\r\n    mv.visitVarInsn(ALOAD, 1);\r\n    mv.visitMethodInsn(INVOKEVIRTUAL, Type.getInternalName(TraitTypeMap.class), \"removeCascade\", Type.getMethodDescriptor(Type.getType(Collection.class), new Type[] { Type.getType(String.class) }));\r\n    mv.visitInsn(ARETURN);\r\n    mv.visitMaxs(0, 0);\r\n    mv.visitEnd();\r\n    mv = cw.visitMethod(ACC_PUBLIC, \"removeTrait\", Type.getMethodDescriptor(Type.getType(Collection.class), new Type[] { Type.getType(BitSet.class) }), Type.getMethodDescriptor(Type.getType(Collection.class), new Type[] { Type.getType(BitSet.class) }), null);\r\n    mv.visitCode();\r\n    mv.visitVarInsn(ALOAD, 0);\r\n    mv.visitMethodInsn(INVOKEVIRTUAL, BuildUtils.getInternalType(classDef.getName()), \"_getTraitMap\", Type.getMethodDescriptor(Type.getType(Map.class), new Type[] {}));\r\n    mv.visitTypeInsn(CHECKCAST, Type.getInternalName(TraitTypeMap.class));\r\n    mv.visitVarInsn(ALOAD, 1);\r\n    mv.visitMethodInsn(INVOKEVIRTUAL, Type.getInternalName(TraitTypeMap.class), \"removeCascade\", Type.getMethodDescriptor(Type.getType(Collection.class), new Type[] { Type.getType(BitSet.class) }));\r\n    mv.visitInsn(ARETURN);\r\n    mv.visitMaxs(0, 0);\r\n    mv.visitEnd();\r\n    mv = cw.visitMethod(ACC_PUBLIC, \"getTraits\", Type.getMethodDescriptor(Type.getType(Collection.class), new Type[] {}), \"()Ljava/util/Collection<Ljava/lang/String;>;\", null);\r\n    mv.visitCode();\r\n    mv.visitVarInsn(ALOAD, 0);\r\n    mv.visitMethodInsn(INVOKEVIRTUAL, BuildUtils.getInternalType(classDef.getName()), \"_getTraitMap\", Type.getMethodDescriptor(Type.getType(Map.class), new Type[] {}));\r\n    mv.visitMethodInsn(INVOKEINTERFACE, Type.getInternalName(Map.class), \"keySet\", Type.getMethodDescriptor(Type.getType(Set.class), new Type[] {}));\r\n    mv.visitInsn(ARETURN);\r\n    mv.visitMaxs(0, 0);\r\n    mv.visitEnd();\r\n    mv = cw.visitMethod(ACC_PUBLIC, \"_setBottomTypeCode\", Type.getMethodDescriptor(Type.getType(void.class), new Type[] { Type.getType(BitSet.class) }), null, null);\r\n    mv.visitCode();\r\n    mv.visitVarInsn(ALOAD, 0);\r\n    mv.visitFieldInsn(GETFIELD, BuildUtils.getInternalType(classDef.getName()), TraitableBean.TRAITSET_FIELD_NAME, Type.getDescriptor(Map.class));\r\n    mv.visitTypeInsn(CHECKCAST, Type.getInternalName(TraitTypeMap.class));\r\n    mv.visitVarInsn(ALOAD, 1);\r\n    mv.visitMethodInsn(INVOKEVIRTUAL, Type.getInternalName(TraitTypeMap.class), \"setBottomCode\", Type.getMethodDescriptor(Type.getType(void.class), new Type[] { Type.getType(BitSet.class) }));\r\n    mv.visitInsn(RETURN);\r\n    mv.visitMaxs(0, 0);\r\n    mv.visitEnd();\r\n    mv = cw.visitMethod(ACC_PUBLIC, \"getMostSpecificTraits\", Type.getMethodDescriptor(Type.getType(Collection.class), new Type[] {}), \"()Ljava/util/Collection<Lorg/drools/core/factmodel/traits/Thing;>;\", null);\r\n    mv.visitCode();\r\n    mv.visitVarInsn(ALOAD, 0);\r\n    mv.visitFieldInsn(GETFIELD, BuildUtils.getInternalType(classDef.getName()), TraitableBean.TRAITSET_FIELD_NAME, Type.getDescriptor(Map.class));\r\n    Label l99 = new Label();\r\n    mv.visitJumpInsn(IFNULL, l99);\r\n    mv.visitVarInsn(ALOAD, 0);\r\n    mv.visitFieldInsn(GETFIELD, BuildUtils.getInternalType(classDef.getName()), TraitableBean.TRAITSET_FIELD_NAME, Type.getDescriptor(Map.class));\r\n    mv.visitTypeInsn(CHECKCAST, Type.getInternalName(TraitTypeMap.class));\r\n    mv.visitMethodInsn(INVOKEVIRTUAL, Type.getInternalName(TraitTypeMap.class), \"getMostSpecificTraits\", Type.getMethodDescriptor(Type.getType(Collection.class), new Type[] {}));\r\n    mv.visitInsn(ARETURN);\r\n    mv.visitLabel(l99);\r\n    mv.visitMethodInsn(INVOKESTATIC, Type.getInternalName(Collections.class), \"emptySet\", Type.getMethodDescriptor(Type.getType(Set.class), new Type[] {}));\r\n    mv.visitMethodInsn(INVOKESTATIC, Type.getInternalName(Collections.class), \"unmodifiableCollection\", Type.getMethodDescriptor(Type.getType(Collection.class), new Type[] { Type.getType(Collection.class) }));\r\n    mv.visitInsn(ARETURN);\r\n    mv.visitMaxs(0, 0);\r\n    mv.visitEnd();\r\n    mv = cw.visitMethod(ACC_PUBLIC, \"getCurrentTypeCode\", Type.getMethodDescriptor(Type.getType(BitSet.class), new Type[] {}), null, null);\r\n    mv.visitCode();\r\n    mv.visitVarInsn(ALOAD, 0);\r\n    mv.visitFieldInsn(GETFIELD, BuildUtils.getInternalType(classDef.getName()), TraitableBean.TRAITSET_FIELD_NAME, Type.getDescriptor(Map.class));\r\n    Label l3 = new Label();\r\n    mv.visitJumpInsn(IFNONNULL, l3);\r\n    mv.visitInsn(ACONST_NULL);\r\n    mv.visitInsn(ARETURN);\r\n    mv.visitLabel(l3);\r\n    mv.visitVarInsn(ALOAD, 0);\r\n    mv.visitFieldInsn(GETFIELD, BuildUtils.getInternalType(classDef.getName()), TraitableBean.TRAITSET_FIELD_NAME, Type.getDescriptor(Map.class));\r\n    mv.visitTypeInsn(CHECKCAST, Type.getInternalName(TraitTypeMap.class));\r\n    mv.visitMethodInsn(INVOKEVIRTUAL, Type.getInternalName(TraitTypeMap.class), \"getCurrentTypeCode\", Type.getMethodDescriptor(Type.getType(BitSet.class), new Type[] {}));\r\n    mv.visitInsn(ARETURN);\r\n    mv.visitMaxs(0, 0);\r\n    mv.visitEnd();\r\n}"
}, {
	"Path": "org.drools.compiler.compiler.DrlParser.parse",
	"Comment": "parse and build a rule package from a drl source with a domain specificlanguage.",
	"Method": "PackageDescr parse(Resource resource,String text,PackageDescr parse,boolean isEditor,String text,PackageDescr parse,boolean isEditor,Reader reader,PackageDescr parse,Resource resource,Reader reader,PackageDescr parse,Reader reader,PackageDescr parse,Reader drl,Reader dsl,PackageDescr parse,boolean isEditor,Reader drl,Reader dsl,PackageDescr parse,boolean isEditor,String source,Reader dsl,PackageDescr parse,String source,Reader dsl,PackageDescr parse,Resource resource,PackageDescr parse,Resource resource,InputStream is,PackageDescr parse,boolean isEditor,Resource resource,PackageDescr parse,boolean isEditor,Resource resource,InputStream is){\r\n    this.resource = resource;\r\n    String encoding = resource instanceof InternalResource ? ((InternalResource) resource).getEncoding() : null;\r\n    lexer = buildLexer(is, encoding, languageLevel);\r\n    DRLParser parser = buildParser(lexer, languageLevel);\r\n    return compile(isEditor, parser);\r\n}"
}, {
	"Path": "org.drools.core.audit.WorkingMemoryLogger.filterLogEvent",
	"Comment": "this method is invoked every time a new log event is created.it filters out unwanted events.",
	"Method": "void filterLogEvent(LogEvent logEvent){\r\n    for (ILogEventFilter filter : this.filters) {\r\n        if (!filter.acceptEvent(logEvent)) {\r\n            return;\r\n        }\r\n    }\r\n    logEventCreated(logEvent);\r\n}"
}, {
	"Path": "org.drools.core.base.ClassFieldAccessorFactory.getReaderSuperClassFor",
	"Comment": "returns the appropriate base class field extractor classfor the given fieldtype",
	"Method": "Class<?> getReaderSuperClassFor(Class<?> fieldType){\r\n    Class<?> ret = null;\r\n    if (fieldType.isPrimitive()) {\r\n        if (fieldType == char.class) {\r\n            ret = BaseCharClassFieldReader.class;\r\n        } else if (fieldType == byte.class) {\r\n            ret = BaseByteClassFieldReader.class;\r\n        } else if (fieldType == short.class) {\r\n            ret = BaseShortClassFieldReader.class;\r\n        } else if (fieldType == int.class) {\r\n            ret = BaseIntClassFieldReader.class;\r\n        } else if (fieldType == long.class) {\r\n            ret = BaseLongClassFieldReader.class;\r\n        } else if (fieldType == float.class) {\r\n            ret = BaseFloatClassFieldReader.class;\r\n        } else if (fieldType == double.class) {\r\n            ret = BaseDoubleClassFieldReader.class;\r\n        } else if (fieldType == boolean.class) {\r\n            ret = BaseBooleanClassFieldReader.class;\r\n        }\r\n    } else if (Number.class.isAssignableFrom(fieldType)) {\r\n        ret = BaseNumberClassFieldReader.class;\r\n    } else if (Date.class.isAssignableFrom(fieldType)) {\r\n        ret = BaseDateClassFieldReader.class;\r\n    } else if (LocalDate.class.isAssignableFrom(fieldType)) {\r\n        ret = BaseLocalDateClassFieldReader.class;\r\n    } else if (LocalDateTime.class.isAssignableFrom(fieldType)) {\r\n        ret = BaseLocalDateTimeClassFieldReader.class;\r\n    } else if (ZonedDateTime.class.isAssignableFrom(fieldType)) {\r\n        ret = BaseZonedDateTimeClassFieldReader.class;\r\n    } else {\r\n        ret = BaseObjectClassFieldReader.class;\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "org.drools.compiler.lang.descr.OperatorDescr.getRightString",
	"Comment": "this is an internal cache of the right string parameter that is set during the rewriteinto mvel, allowing for further analysis of the parameter type.",
	"Method": "String getRightString(){\r\n    return rightString;\r\n}"
}, {
	"Path": "org.drools.core.rule.NamedConsequence.getOuterDeclarations",
	"Comment": "it is not possible to declare and export any variables,so always return an empty map",
	"Method": "Map<String, Declaration> getOuterDeclarations(){\r\n    return Collections.emptyMap();\r\n}"
}, {
	"Path": "org.drools.core.reteoo.EntryPointNode.retractObject",
	"Comment": "retract a fact object from this rulebase and the specifiedworkingmemory.",
	"Method": "void retractObject(InternalFactHandle handle,PropagationContext context,ObjectTypeConf objectTypeConf,InternalWorkingMemory workingMemory){\r\n    if (log.isTraceEnabled()) {\r\n        log.trace(\"Delete {}\", handle.toString());\r\n    }\r\n    workingMemory.addPropagation(new PropagationEntry.Delete(this, handle, context, objectTypeConf));\r\n}"
}, {
	"Path": "org.drools.compiler.integrationtests.eventgenerator.SimpleEventGenerator.addEventSource",
	"Comment": "add source which will generate events from current clock time on, but only maxitems instances at the most and not exceeding the time specified by maxduration",
	"Method": "EventOccurrence addEventSource(String id,Event ev,long minOccur,long avgOccur,EventOccurrence addEventSource,String id,Event ev,long minOccur,long avgOccur,long maxDuration,int maxItems){\r\n    if (!eventSourceIds.containsKey(id)) {\r\n        this.eventSourceIds.put(id, eventSourceIdCounter++);\r\n        final EventOccurrence evOcc = new EventOccurrence(id, ev, minOccur, avgOccur, this.myClock.getCurrentTime(), maxDuration, maxItems);\r\n        this.nextEventSource.add(evOcc);\r\n        return evOcc;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.drools.core.common.BaseNode.removeAssociation",
	"Comment": "removes the association to the given rule from theassociations map.",
	"Method": "boolean removeAssociation(Rule rule){\r\n    return this.associations.remove(rule);\r\n}"
}, {
	"Path": "org.drools.core.factmodel.FieldDefinition.getWriteMethod",
	"Comment": "creates the string name for the set method for a field with the given name and type",
	"Method": "String getWriteMethod(){\r\n    return setterName != null ? setterName : \"set\" + this.name.substring(0, 1).toUpperCase() + this.name.substring(1);\r\n}"
}, {
	"Path": "org.drools.compiler.builder.impl.errors.ErrorHandler.collectCompilerProblems",
	"Comment": "we must use an error of jci problem objects. if there are noproblems, null is returned. these errors are placed in thedroolserror instances. its not 1 to 1 with reported errors.",
	"Method": "CompilationProblem[] collectCompilerProblems(){\r\n    if (this.errors.isEmpty()) {\r\n        return null;\r\n    } else {\r\n        final CompilationProblem[] list = new CompilationProblem[this.errors.size()];\r\n        this.errors.toArray(list);\r\n        return list;\r\n    }\r\n}"
}, {
	"Path": "org.drools.core.base.evaluators.Operator.addOperatorToRegistry",
	"Comment": "creates a new operator instance for the given parameters,adds it to the registry and return it",
	"Method": "Operator addOperatorToRegistry(String operatorId,boolean isNegated){\r\n    Operator op = new Operator(operatorId, isNegated);\r\n    CACHE.put(getKey(operatorId, isNegated), op);\r\n    return op;\r\n}"
}, {
	"Path": "org.drools.core.reteoo.CompositeObjectSinkAdapter.registerFieldIndex",
	"Comment": "returns a fieldindex which keeps a count on how many times a particular field is used with an equality checkin the sinks.",
	"Method": "FieldIndex registerFieldIndex(int index,InternalReadAccessor fieldExtractor){\r\n    FieldIndex fieldIndex = null;\r\n    if (this.hashedFieldIndexes == null) {\r\n        this.hashedFieldIndexes = new LinkedList<FieldIndex>();\r\n        fieldIndex = new FieldIndex(index, fieldExtractor);\r\n        this.hashedFieldIndexes.add(fieldIndex);\r\n    }\r\n    if (fieldIndex == null) {\r\n        fieldIndex = findFieldIndex(index);\r\n    }\r\n    if (fieldIndex == null) {\r\n        fieldIndex = new FieldIndex(index, fieldExtractor);\r\n        this.hashedFieldIndexes.add(fieldIndex);\r\n    }\r\n    fieldIndex.increaseCounter();\r\n    return fieldIndex;\r\n}"
}, {
	"Path": "org.drools.core.rule.AbstractCompositeConstraint.addConstraint",
	"Comment": "adds a constraint too all lists it belongs to by checking for its type",
	"Method": "void addConstraint(Constraint constraint){\r\n    if (ConstraintType.ALPHA.equals(constraint.getType())) {\r\n        this.addAlphaConstraint((AlphaNodeFieldConstraint) constraint);\r\n    } else if (ConstraintType.BETA.equals(constraint.getType())) {\r\n        this.addBetaConstraint((BetaNodeFieldConstraint) constraint);\r\n    } else {\r\n        throw new RuntimeException(\"Constraint type MUST be known in advance.\");\r\n    }\r\n}"
}, {
	"Path": "org.drools.core.rule.Forall.getInnerDeclarations",
	"Comment": "forall inner declarations are only provided by the base patternssince it negates the remaining patterns",
	"Method": "Map<String, Declaration> getInnerDeclarations(){\r\n    final Map inner = new HashMap(this.basePattern.getOuterDeclarations());\r\n    for (Pattern pattern : remainingPatterns) {\r\n        inner.putAll(pattern.getOuterDeclarations());\r\n    }\r\n    return inner;\r\n}"
}, {
	"Path": "org.drools.core.common.ObjectTypeConfigurationRegistry.getObjectTypeConf",
	"Comment": "returns the objecttypeconfiguration object for the given object orcreates a new one if none is found in the cache",
	"Method": "ObjectTypeConf getObjectTypeConf(EntryPointId entrypoint,Object object){\r\n    Object key;\r\n    if (object instanceof Activation) {\r\n        key = ClassObjectType.Match_ObjectType.getClassType();\r\n    } else if (object instanceof Fact) {\r\n        key = ((Fact) object).getFactTemplate().getName();\r\n    } else {\r\n        key = object.getClass();\r\n    }\r\n    ObjectTypeConf objectTypeConf = this.typeConfMap.get(key);\r\n    if (objectTypeConf == null) {\r\n        if (object instanceof Fact) {\r\n            objectTypeConf = new FactTemplateTypeConf(entrypoint, ((Fact) object).getFactTemplate(), this.kBase);\r\n        } else {\r\n            objectTypeConf = new ClassObjectTypeConf(entrypoint, (Class<?>) key, this.kBase);\r\n        }\r\n        ObjectTypeConf existing = this.typeConfMap.putIfAbsent(key, objectTypeConf);\r\n        if (existing != null) {\r\n            objectTypeConf = existing;\r\n        }\r\n    }\r\n    return objectTypeConf;\r\n}"
}, {
	"Path": "org.drools.core.definitions.rule.impl.RuleImpl.getTimer",
	"Comment": "returns the timer semantics for a rule. timer based rules are not added directly to the agendainstead they are scheduled for agenda addition, based on the timer.",
	"Method": "Timer getTimer(){\r\n    return timer;\r\n}"
}, {
	"Path": "org.drools.core.audit.WorkingMemoryFileLogger.setMaxEventsInMemory",
	"Comment": "sets the maximum number of log events that are allowed in memory. if thisnumber is reached, all events are written to file. the default is 1000.",
	"Method": "void setMaxEventsInMemory(int maxEventsInMemory){\r\n    this.maxEventsInMemory = maxEventsInMemory;\r\n}"
}, {
	"Path": "org.drools.core.io.impl.FileSystemResource.getInputStream",
	"Comment": "this implementation opens a fileinputstream for the underlying file.",
	"Method": "InputStream getInputStream(){\r\n    this.lastRead = getLastModified();\r\n    return new FileInputStream(this.file);\r\n}"
}, {
	"Path": "org.drools.core.reteoo.builder.BuildUtils.addBuilder",
	"Comment": "adds the given builder for the given target to the builders map",
	"Method": "void addBuilder(Class<?> target,ReteooComponentBuilder builder){\r\n    this.componentBuilders.put(target, builder);\r\n}"
}, {
	"Path": "org.drools.core.factmodel.FieldDefinition.getReadMethod",
	"Comment": "creates the string name for the get method for a field with the given name and type",
	"Method": "String getReadMethod(){\r\n    if (getterName != null) {\r\n        return getterName;\r\n    }\r\n    String prefix;\r\n    if (\"boolean\".equals(this.type)) {\r\n        prefix = \"is\";\r\n    } else {\r\n        prefix = \"get\";\r\n    }\r\n    return prefix + this.name.substring(0, 1).toUpperCase() + this.name.substring(1);\r\n}"
}, {
	"Path": "org.drools.compiler.integrationtests.MapConstraintTest.testMapAccessWithVariable2",
	"Comment": "drools does not support variables inside bindings yet... but we should...",
	"Method": "void testMapAccessWithVariable2(){\r\n    final String str = \"package org.drools.compiler;\\n\" + \"import java.util.Map;\\n\" + \"rule \\\"map access with variable\\\"\\n\" + \"    when\\n\" + \"        $key : String( )\\n\" + \"        $p1 : Person( name == 'Bob', namedAddresses[$key] != null, $na : namedAddresses[$key] )\\n\" + \"        $p2 : Person( name == 'Mark', namedAddresses[$key] == $na )\\n\" + \"    then\\n\" + \"end\\n\";\r\n    final KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();\r\n    kbuilder.add(ResourceFactory.newByteArrayResource(str.getBytes()), ResourceType.DRL);\r\n    assertTrue(kbuilder.hasErrors());\r\n}"
}, {
	"Path": "org.drools.core.phreak.SegmentUtilities.isRootNode",
	"Comment": "returns whether the node is the root of a segment.lians are always the root of a segment.node cannot be null.the result should discount any removingrule. that means it gives you the result asif the rule had already been removed from the network.",
	"Method": "boolean isRootNode(LeftTupleNode node,TerminalNode removingTN){\r\n    return node.getType() == NodeTypeEnums.LeftInputAdapterNode || isNonTerminalTipNode(node.getLeftTupleSource(), removingTN);\r\n}"
}, {
	"Path": "org.drools.compiler.kie.builder.impl.KieBuilderImpl.setPomModel",
	"Comment": "this can be used for performance reason to avoid the recomputation of the pommodel when it is already available",
	"Method": "void setPomModel(PomModel pomModel){\r\n    this.pomModel = pomModel;\r\n    if (srcMfs.isAvailable(\"pom.xml\")) {\r\n        this.pomXml = srcMfs.getBytes(\"pom.xml\");\r\n    }\r\n}"
}, {
	"Path": "org.drools.core.rule.ConditionalBranch.getNestedElements",
	"Comment": "it is not possible to nest elements inside a conditional branch, soalways return an empty list.",
	"Method": "List<RuleConditionElement> getNestedElements(){\r\n    return Collections.emptyList();\r\n}"
}, {
	"Path": "org.drools.core.reteoo.compiled.CompiledNetwork.getId",
	"Comment": "returns the unique id that represents the node in the rete network",
	"Method": "int getId(){\r\n    return objectTypeNode.getId();\r\n}"
}, {
	"Path": "org.drools.core.common.EqualityAssertMapComparator.equal",
	"Comment": "special comparatorthatallows facthandles tobekeys, but alwayschecksequals with theidentity of theobjects involved",
	"Method": "boolean equal(Object o1,Object o2){\r\n    if (o1 == o2) {\r\n        return true;\r\n    }\r\n    if (o1 instanceof FactHandle) {\r\n        return ((InternalFactHandle) o1).getId() == ((InternalFactHandle) o2).getId();\r\n    }\r\n    final InternalFactHandle handle = ((InternalFactHandle) o2);\r\n    o2 = handle.getObject();\r\n    return o1 == o2 || o2.equals(o1);\r\n}"
}, {
	"Path": "org.drools.core.audit.WorkingMemoryLogger.addFilter",
	"Comment": "adds the given filter to the list of filters for this event log.a log event must be accepted by all the filters to be entered inthe event log.",
	"Method": "void addFilter(ILogEventFilter filter){\r\n    if (filter == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    this.filters.add(filter);\r\n}"
}, {
	"Path": "org.drools.core.phreak.PhreakBranchNode.getBranchTuples",
	"Comment": "a branch has two potential sinks. rtnsinkis for the sink if the contained logic returns true.mainsink is for propagations after the branch node, if they are allowed.it may have one or the other or both. there is no state that indicates whether one or the other or bothare present, so all tuple children must be inspected and references coalesced from that.when handling updates and deletes it must search the child tuples to colasce the references.this is done by checking the tuple sink with the known main or rtn sink.",
	"Method": "BranchTuples getBranchTuples(LeftTupleSink sink,LeftTuple leftTuple){\r\n    BranchTuples branchTuples = new BranchTuples();\r\n    LeftTuple child = leftTuple.getFirstChild();\r\n    if (child != null) {\r\n        if (child.getTupleSink() == sink) {\r\n            branchTuples.mainLeftTuple = child;\r\n        } else {\r\n            branchTuples.rtnLeftTuple = child;\r\n        }\r\n        child = child.getHandleNext();\r\n        if (child != null) {\r\n            if (child.getTupleSink() == sink) {\r\n                branchTuples.mainLeftTuple = child;\r\n            } else {\r\n                branchTuples.rtnLeftTuple = child;\r\n            }\r\n        }\r\n    }\r\n    return branchTuples;\r\n}"
}, {
	"Path": "org.drools.core.reteoo.ObjectSinkNodeList.removeFirst",
	"Comment": "remove the first node from the list. the next node then becomes the first node. if this is the lastnode then both first and last node references are set to null.",
	"Method": "ObjectSinkNode removeFirst(){\r\n    if (this.firstNode == null) {\r\n        return null;\r\n    }\r\n    final ObjectSinkNode node = this.firstNode;\r\n    this.firstNode = node.getNextObjectSinkNode();\r\n    node.setNextObjectSinkNode(null);\r\n    if (this.firstNode != null) {\r\n        this.firstNode.setPreviousObjectSinkNode(null);\r\n    } else {\r\n        this.lastNode = null;\r\n    }\r\n    this.size--;\r\n    return node;\r\n}"
}, {
	"Path": "org.drools.compiler.lang.DroolsParserExceptionFactory.formatParserLocation",
	"Comment": "this will take paraphrases stack, and create a sensible location",
	"Method": "String formatParserLocation(){\r\n    StringBuilder sb = new StringBuilder();\r\n    if (paraphrases != null) {\r\n        for (Map<DroolsParaphraseTypes, String> map : paraphrases) {\r\n            for (Entry<DroolsParaphraseTypes, String> activeEntry : map.entrySet()) {\r\n                if (activeEntry.getValue().length() == 0) {\r\n                    String kStr = getLocationName(activeEntry.getKey());\r\n                    if (kStr.length() > 0) {\r\n                        sb.append(String.format(PARSER_LOCATION_MESSAGE_PART, kStr));\r\n                    }\r\n                } else {\r\n                    sb.append(String.format(PARSER_LOCATION_MESSAGE_COMPLETE, getLocationName(activeEntry.getKey()), activeEntry.getValue()));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.drools.core.audit.event.ActivationLogEvent.getDeclarations",
	"Comment": "returns a string representation of the declarations in theactivation.",
	"Method": "String getDeclarations(){\r\n    return this.declarations;\r\n}"
}, {
	"Path": "org.drools.core.rule.EntryPointId.resolveDeclaration",
	"Comment": "not possible to resolve any declaration, so always return null.",
	"Method": "Declaration resolveDeclaration(String identifier){\r\n    return null;\r\n}"
}, {
	"Path": "org.drools.core.base.evaluators.EvaluatorRegistry.getEvaluator",
	"Comment": "returns the evaluator instance for the given type and thedefined parametertext",
	"Method": "Evaluator getEvaluator(ValueType type,String operatorId,boolean isNegated,String parameterText,Evaluator getEvaluator,ValueType type,Operator operator,String parameterText,Evaluator getEvaluator,ValueType type,Operator operator){\r\n    return this.getEvaluatorDefinition(operator).getEvaluator(type, operator);\r\n}"
}, {
	"Path": "org.drools.compiler.builder.impl.KnowledgeBuilderImpl.hasErrors",
	"Comment": "this will return true if there were errors in the package building andcompiling phase",
	"Method": "boolean hasErrors(){\r\n    return !getErrorList().isEmpty();\r\n}"
}, {
	"Path": "org.drools.core.reteoo.builder.BuildUtils.isSharingEnabledForNode",
	"Comment": "utility function to check if sharing is enabled for nodes of the given class",
	"Method": "boolean isSharingEnabledForNode(BuildContext context,BaseNode node){\r\n    if (NodeTypeEnums.isLeftTupleSource(node)) {\r\n        return context.getKnowledgeBase().getConfiguration().isShareBetaNodes();\r\n    } else if (NodeTypeEnums.isObjectSource(node)) {\r\n        return context.getKnowledgeBase().getConfiguration().isShareAlphaNodes();\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.drools.core.io.impl.ClassPathResource.getURL",
	"Comment": "this implementation returns a url for the underlying class path resource.",
	"Method": "URL getURL(){\r\n    URL url = null;\r\n    if (this.clazz != null) {\r\n        url = this.clazz.getResource(this.path);\r\n    }\r\n    if (url == null) {\r\n        url = this.classLoader.getResource(this.path);\r\n    }\r\n    if (url == null) {\r\n        throw new FileNotFoundException(\"'\" + this.path + \"' cannot be opened because it does not exist\");\r\n    }\r\n    return url;\r\n}"
}, {
	"Path": "org.drools.compiler.integrationtests.SeveralKieSessionsTest.testFamilyWithTwoKieSessionsFromKieContainer",
	"Comment": "tests evaluation of a backward chaining family relationships example withtwo kiesessions created from the same kiebase.kiesessions are constructed using different kiecontainer instances.",
	"Method": "void testFamilyWithTwoKieSessionsFromKieContainer(){\r\n    final KieServices ks = KieServices.Factory.get();\r\n    final KieContainer kieContainer = ks.newKieContainer(kieModuleId);\r\n    final KieSession ksession = kieContainer.newKieSession();\r\n    performTestAndDispose(ksession);\r\n    final KieContainer kieContainerOther = ks.newKieContainer(kieModuleId);\r\n    final KieSession ksessionOther = kieContainerOther.newKieSession();\r\n    performTestAndDispose(ksessionOther);\r\n}"
}, {
	"Path": "org.drools.core.reteoo.BaseLeftTuple.setLeftTupleSink",
	"Comment": "had to add the set method because sink adapters must override the tuple sink set when the tuple was created.",
	"Method": "void setLeftTupleSink(LeftTupleSink sink){\r\n    this.sink = sink;\r\n}"
}, {
	"Path": "org.drools.compiler.lang.DRL6StrictParser.match",
	"Comment": "match current input symbol against ttype and optionally check the text of the token against text.attempt single token insertion or deletion error recovery.if that fails, throw mismatchedtokenexception.",
	"Method": "Token match(TokenStream input,int ttype,String text,int[] follow,DroolsEditorType etype){\r\n    Token matchedSymbol = null;\r\n    matchedSymbol = input.LT(1);\r\n    if (input.LA(1) == ttype && (text == null || text.equals(matchedSymbol.getText()))) {\r\n        input.consume();\r\n        state.errorRecovery = false;\r\n        state.failed = false;\r\n        helper.emit(matchedSymbol, etype);\r\n        return matchedSymbol;\r\n    }\r\n    if (state.backtracking > 0) {\r\n        state.failed = true;\r\n        return matchedSymbol;\r\n    }\r\n    matchedSymbol = recoverFromMismatchedToken(input, ttype, text, follow);\r\n    helper.emit(matchedSymbol, etype);\r\n    return matchedSymbol;\r\n}"
}, {
	"Path": "org.drools.core.reteoo.ObjectTypeNode.remove",
	"Comment": "otn needs to override remove to avoid releasing the node id, since otn are never removed from the rulebase in the current implementation",
	"Method": "boolean remove(RuleRemovalContext context,ReteooBuilder builder){\r\n    return doRemove(context, builder);\r\n}"
}, {
	"Path": "org.drools.core.common.IdentityAssertMapComparator.equal",
	"Comment": "special comparator that allows facthandles to be keys, but alwayscheckslike for like.",
	"Method": "boolean equal(Object o1,Object o2){\r\n    if (o1 instanceof InternalFactHandle) {\r\n        return ((InternalFactHandle) o1).getId() == ((InternalFactHandle) o2).getId();\r\n    }\r\n    Object left = o1;\r\n    final InternalFactHandle handle = ((InternalFactHandle) o2);\r\n    if (left == handle.getObject()) {\r\n        return true;\r\n    } else if (handle.getTraitType() == TraitTypeEnum.WRAPPED_TRAITABLE) {\r\n        return left == ((CoreWrapper) handle.getObject()).getCore();\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.drools.core.rule.NamedConsequence.getNestedElements",
	"Comment": "it is not possible to nest elements inside an entry point, soalways return an empty list.",
	"Method": "List<RuleConditionElement> getNestedElements(){\r\n    return Collections.emptyList();\r\n}"
}, {
	"Path": "org.drools.core.common.TruthMaintenanceSystem.readLogicalDependency",
	"Comment": "adds a justification for the facthandle to the justifiedmap.",
	"Method": "void readLogicalDependency(InternalFactHandle handle,Object object,Object value,Activation activation,PropagationContext context,RuleImpl rule,ObjectTypeConf typeConf){\r\n    addLogicalDependency(handle, object, value, activation, context, rule, typeConf, true);\r\n}"
}, {
	"Path": "org.drools.core.rule.ConditionalBranch.resolveDeclaration",
	"Comment": "not possible to resolve any declaration, so always return null.",
	"Method": "Declaration resolveDeclaration(String identifier){\r\n    return null;\r\n}"
}, {
	"Path": "org.drools.core.reteoo.ObjectTypeNode.createMemory",
	"Comment": "creates memory for the node using primitivelongmap as its optimised for storage and reteivals of longs.however primitivelongmap is not ideal for spase data. so it should be monitored incase its more optimalto switch back to a standard hashmap.",
	"Method": "ObjectTypeNodeMemory createMemory(RuleBaseConfiguration config,InternalWorkingMemory wm){\r\n    Class<?> classType = ((ClassObjectType) getObjectType()).getClassType();\r\n    if (InitialFact.class.isAssignableFrom(classType)) {\r\n        return new InitialFactObjectTypeNodeMemory(classType);\r\n    }\r\n    return new ObjectTypeNodeMemory(classType, wm);\r\n}"
}, {
	"Path": "org.drools.core.reteoo.builder.BuildUtils.attachNode",
	"Comment": "attaches a node into the network. if a node already exists that couldsubstitute, it is used instead.",
	"Method": "T attachNode(BuildContext context,T candidate){\r\n    BaseNode node = null;\r\n    RuleBasePartitionId partition = null;\r\n    if (candidate.getType() == NodeTypeEnums.EntryPointNode) {\r\n        node = context.getKnowledgeBase().getRete().getEntryPointNode(((EntryPointNode) candidate).getEntryPoint());\r\n        partition = RuleBasePartitionId.MAIN_PARTITION;\r\n    } else if (candidate.getType() == NodeTypeEnums.ObjectTypeNode) {\r\n        Map<ObjectType, ObjectTypeNode> map = context.getKnowledgeBase().getRete().getObjectTypeNodes(context.getCurrentEntryPoint());\r\n        if (map != null) {\r\n            ObjectTypeNode otn = map.get(((ObjectTypeNode) candidate).getObjectType());\r\n            if (otn != null) {\r\n                otn.mergeExpirationOffset((ObjectTypeNode) candidate);\r\n                node = otn;\r\n            }\r\n        }\r\n        partition = RuleBasePartitionId.MAIN_PARTITION;\r\n    } else if (isSharingEnabledForNode(context, candidate)) {\r\n        if ((context.getTupleSource() != null) && NodeTypeEnums.isLeftTupleSink(candidate)) {\r\n            node = context.getTupleSource().getSinkPropagator().getMatchingNode(candidate);\r\n        } else if ((context.getObjectSource() != null) && NodeTypeEnums.isObjectSink(candidate)) {\r\n            node = context.getObjectSource().getObjectSinkPropagator().getMatchingNode(candidate);\r\n        } else {\r\n            throw new RuntimeException(\"This is a bug on node sharing verification. Please report to development team.\");\r\n        }\r\n    }\r\n    if (node != null && !areNodesCompatibleForSharing(context, node, candidate)) {\r\n        node = null;\r\n    }\r\n    if (node == null) {\r\n        node = candidate;\r\n        if (partition == null) {\r\n            if (context.getPartitionId() == null) {\r\n                context.setPartitionId(context.getKnowledgeBase().createNewPartitionId());\r\n            }\r\n            partition = context.getPartitionId();\r\n        }\r\n        node.setPartitionId(context, partition);\r\n        node.attach(context);\r\n        context.getNodes().add(node);\r\n    } else {\r\n        mergeNodes(node, candidate);\r\n        context.releaseId(candidate);\r\n        if (partition == null && context.getPartitionId() == null) {\r\n            partition = node.getPartitionId();\r\n            context.setPartitionId(partition);\r\n        }\r\n    }\r\n    node.addAssociation(context, context.getRule());\r\n    return (T) node;\r\n}"
}, {
	"Path": "org.drools.compiler.rule.builder.dialect.java.JavaDialectConfiguration.setJavaLanguageLevel",
	"Comment": "you cannot set language level below 1.5, as we need static imports, 1.5 is now the default.",
	"Method": "void setJavaLanguageLevel(String languageLevel){\r\n    if (Arrays.binarySearch(LANGUAGE_LEVELS, languageLevel) < 0) {\r\n        throw new RuntimeException(\"value '\" + languageLevel + \"' is not a valid language level\");\r\n    }\r\n    this.languageLevel = languageLevel;\r\n}"
}, {
	"Path": "org.drools.core.facttemplates.FactTemplateImpl.toString",
	"Comment": "method will return a string format with the int type codefor the slot type",
	"Method": "String toString(){\r\n    final StringBuilder buf = new StringBuilder();\r\n    buf.append(\"(\" + this.name + \" \");\r\n    buf.append(\")\");\r\n    return buf.toString();\r\n}"
}, {
	"Path": "org.drools.compiler.lang.DroolsParserExceptionFactory.createDroolsException",
	"Comment": "this method creates a droolsparserexception full of information.",
	"Method": "DroolsParserException createDroolsException(RecognitionException e,DroolsParserException createDroolsException,Exception e,Token token){\r\n    StringWriter sw = new StringWriter();\r\n    e.printStackTrace(new PrintWriter(sw));\r\n    return new DroolsParserException(String.format(DroolsParserExceptionFactory.UNEXPECTED_EXCEPTION, token.getLine(), token.getCharPositionInLine(), getBetterToken(token), e.toString(), sw.toString()), e);\r\n}"
}, {
	"Path": "org.drools.compiler.rule.builder.PatternBuilder.createDeclarationObject",
	"Comment": "creates a declaration object for the field identified by the given identifieron the give pattern object",
	"Method": "Declaration createDeclarationObject(RuleBuildContext context,String identifier,Pattern pattern,Declaration createDeclarationObject,RuleBuildContext context,String identifier,String expr,Pattern pattern){\r\n    final BindingDescr implicitBinding = new BindingDescr(identifier, expr);\r\n    final Declaration declaration = new Declaration(identifier, null, pattern, true);\r\n    InternalReadAccessor extractor = getFieldReadAccessor(context, implicitBinding, pattern, implicitBinding.getExpression(), declaration, false);\r\n    if (extractor == null) {\r\n        return null;\r\n    }\r\n    declaration.setReadAccessor(extractor);\r\n    return declaration;\r\n}"
}, {
	"Path": "org.drools.core.rule.LogicTransformer.fixClonedDeclarations",
	"Comment": "during the logic transformation, we eventually clone ces, specially patterns and corresponding declarations. so nowwe need to fix any references to cloned declarations.",
	"Method": "void fixClonedDeclarations(GroupElement and,Map<String, Class<?>> globals){\r\n    Stack<RuleConditionElement> contextStack = new Stack<RuleConditionElement>();\r\n    DeclarationScopeResolver resolver = new DeclarationScopeResolver(globals, contextStack);\r\n    contextStack.push(and);\r\n    processElement(resolver, contextStack, and);\r\n    contextStack.pop();\r\n}"
}, {
	"Path": "org.drools.compiler.lang.DRL6Parser.match",
	"Comment": "match current input symbol against ttype and optionally check the text of the token against text.attempt single token insertion or deletion error recovery.if that fails, throw mismatchedtokenexception.",
	"Method": "Token match(TokenStream input,int ttype,String text,int[] follow,DroolsEditorType etype){\r\n    Token matchedSymbol = null;\r\n    matchedSymbol = input.LT(1);\r\n    if (input.LA(1) == ttype && (text == null || text.equals(matchedSymbol.getText()))) {\r\n        input.consume();\r\n        state.errorRecovery = false;\r\n        state.failed = false;\r\n        helper.emit(matchedSymbol, etype);\r\n        return matchedSymbol;\r\n    }\r\n    if (state.backtracking > 0) {\r\n        state.failed = true;\r\n        return matchedSymbol;\r\n    }\r\n    matchedSymbol = recoverFromMismatchedToken(input, ttype, text, follow);\r\n    helper.emit(matchedSymbol, etype);\r\n    return matchedSymbol;\r\n}"
}, {
	"Path": "org.drools.compiler.lang.DRL6StrictParser.chunk",
	"Comment": "matches a chunk started by the leftdelimiter and ended by the rightdelimiter.",
	"Method": "String chunk(int leftDelimiter,int rightDelimiter,int location){\r\n    String chunk = \"\";\r\n    int first = -1, last = first;\r\n    try {\r\n        match(input, leftDelimiter, null, null, DroolsEditorType.SYMBOL);\r\n        if (state.failed)\r\n            return chunk;\r\n        if (state.backtracking == 0 && location >= 0) {\r\n            helper.emit(location);\r\n        }\r\n        int nests = 0;\r\n        first = input.index();\r\n        while (input.LA(1) != DRL6Lexer.EOF && (input.LA(1) != rightDelimiter || nests > 0)) {\r\n            if (input.LA(1) == rightDelimiter) {\r\n                nests--;\r\n            } else if (input.LA(1) == leftDelimiter) {\r\n                nests++;\r\n            }\r\n            input.consume();\r\n        }\r\n        last = input.LT(-1).getTokenIndex();\r\n        for (int i = first; i < last + 1; i++) {\r\n            helper.emit(input.get(i), DroolsEditorType.CODE_CHUNK);\r\n        }\r\n        match(input, rightDelimiter, null, null, DroolsEditorType.SYMBOL);\r\n        if (state.failed)\r\n            return chunk;\r\n    } catch (RecognitionException re) {\r\n        reportError(re);\r\n    } finally {\r\n        if (last >= first) {\r\n            chunk = input.toString(first, last);\r\n        }\r\n    }\r\n    return chunk;\r\n}"
}, {
	"Path": "org.drools.core.reteoo.builder.BuildContext.getWorkingMemories",
	"Comment": "return the array of working memories associated with the givenrulebase.",
	"Method": "Collection<InternalWorkingMemory> getWorkingMemories(){\r\n    return this.kBase.getWorkingMemories();\r\n}"
}, {
	"Path": "org.drools.core.definitions.rule.impl.RuleImpl.addPattern",
	"Comment": "add a pattern to the rule. all patterns are searched for bindings which are then added to the ruleas declarations",
	"Method": "void addPattern(RuleConditionElement element){\r\n    this.dirty = true;\r\n    this.lhsRoot.addChild(element);\r\n}"
}, {
	"Path": "org.drools.core.rule.EntryPointId.getInnerDeclarations",
	"Comment": "it is not possible to declare any new variables, so alwaysreturn an empty map",
	"Method": "Map<String, Declaration> getInnerDeclarations(){\r\n    return Collections.EMPTY_MAP;\r\n}"
}, {
	"Path": "org.drools.core.common.DefaultAgenda.fireNextItem",
	"Comment": "fire the next scheduled agenda item, skipping itemsthat are not allowed by the agenda filter.",
	"Method": "int fireNextItem(AgendaFilter filter,int fireCount,int fireLimit){\r\n    boolean tryagain;\r\n    int localFireCount = 0;\r\n    do {\r\n        tryagain = false;\r\n        evaluateEagerList();\r\n        final InternalAgendaGroup group = getNextFocus();\r\n        if (group != null) {\r\n            localFireCount = ruleEvaluator.evaluateAndFire(filter, fireCount, fireLimit, group);\r\n            if (localFireCount == 0) {\r\n                tryagain = true;\r\n                propagationList.flush();\r\n            }\r\n        }\r\n    } while (tryagain);\r\n    return localFireCount;\r\n}"
}, {
	"Path": "org.drools.core.impl.KnowledgeBaseFactory.newKnowledgeBaseConfiguration",
	"Comment": "create a knowledgebaseconfiguration on which properties can be set.",
	"Method": "KieBaseConfiguration newKnowledgeBaseConfiguration(KieBaseConfiguration newKnowledgeBaseConfiguration,Properties properties,ClassLoader classLoaders){\r\n    return new RuleBaseConfiguration(properties, classLoaders);\r\n}"
}, {
	"Path": "org.drools.compiler.lang.DroolsParserExceptionFactory.createErrorMessage",
	"Comment": "this will take a recognitionexception, and create a sensible errormessage out of it",
	"Method": "List<String> createErrorMessage(RecognitionException e){\r\n    List<String> codeAndMessage = new ArrayList<String>(2);\r\n    String message;\r\n    if (e instanceof MismatchedTokenException) {\r\n        MismatchedTokenException mte = (MismatchedTokenException) e;\r\n        String expecting = mte instanceof DroolsMismatchedTokenException ? ((DroolsMismatchedTokenException) mte).getTokenText() : getBetterToken(mte.expecting);\r\n        if (tokenNames != null && mte.expecting >= 0 && mte.expecting < tokenNames.length) {\r\n            message = String.format(MISMATCHED_TOKEN_MESSAGE_COMPLETE, e.line, e.charPositionInLine, getBetterToken(e.token), expecting, formatParserLocation());\r\n            codeAndMessage.add(message);\r\n            codeAndMessage.add(\"ERR 102\");\r\n        } else {\r\n            message = String.format(MISMATCHED_TOKEN_MESSAGE_PART, e.line, e.charPositionInLine, getBetterToken(e.token), formatParserLocation());\r\n            codeAndMessage.add(message);\r\n            codeAndMessage.add(\"ERR 102\");\r\n        }\r\n    } else if (e instanceof MismatchedTreeNodeException) {\r\n        MismatchedTreeNodeException mtne = (MismatchedTreeNodeException) e;\r\n        if (mtne.expecting >= 0 && mtne.expecting < tokenNames.length) {\r\n            message = String.format(MISMATCHED_TREE_NODE_MESSAGE_COMPLETE, e.line, e.charPositionInLine, getBetterToken(e.token), getBetterToken(mtne.expecting), formatParserLocation());\r\n            codeAndMessage.add(message);\r\n            codeAndMessage.add(\"ERR 106\");\r\n        } else {\r\n            message = String.format(MISMATCHED_TREE_NODE_MESSAGE_PART, e.line, e.charPositionInLine, getBetterToken(e.token), formatParserLocation());\r\n            codeAndMessage.add(message);\r\n            codeAndMessage.add(\"ERR 106\");\r\n        }\r\n    } else if (e instanceof NoViableAltException) {\r\n        message = String.format(NO_VIABLE_ALT_MESSAGE, e.line, e.charPositionInLine, getBetterToken(e.token), formatParserLocation());\r\n        codeAndMessage.add(message);\r\n        codeAndMessage.add(\"ERR 101\");\r\n    } else if (e instanceof EarlyExitException) {\r\n        message = String.format(EARLY_EXIT_MESSAGE, e.line, e.charPositionInLine, getBetterToken(e.token), formatParserLocation());\r\n        codeAndMessage.add(message);\r\n        codeAndMessage.add(\"ERR 105\");\r\n    } else if (e instanceof MismatchedSetException) {\r\n        MismatchedSetException mse = (MismatchedSetException) e;\r\n        String expected = expectedTokensAsString(mse.expecting);\r\n        message = String.format(MISMATCHED_SET_MESSAGE, e.line, e.charPositionInLine, getBetterToken(e.token), expected, formatParserLocation());\r\n        codeAndMessage.add(message);\r\n        codeAndMessage.add(\"ERR 107\");\r\n    } else if (e instanceof DroolsMismatchedSetException) {\r\n        DroolsMismatchedSetException mse = (DroolsMismatchedSetException) e;\r\n        String expected = Arrays.asList(mse.getTokenText()).toString();\r\n        message = String.format(MISMATCHED_SET_MESSAGE, e.line, e.charPositionInLine, getBetterToken(e.token), expected, formatParserLocation());\r\n        codeAndMessage.add(message);\r\n        codeAndMessage.add(\"ERR 107\");\r\n    } else if (e instanceof MismatchedNotSetException) {\r\n        MismatchedNotSetException mse = (MismatchedNotSetException) e;\r\n        String expected = expectedTokensAsString(mse.expecting);\r\n        message = String.format(MISMATCHED_NOT_SET_MESSAGE, e.line, e.charPositionInLine, getBetterToken(e.token), expected, formatParserLocation());\r\n        codeAndMessage.add(message);\r\n        codeAndMessage.add(\"ERR 108\");\r\n    } else if (e instanceof FailedPredicateException) {\r\n        FailedPredicateException fpe = (FailedPredicateException) e;\r\n        message = String.format(FAILED_PREDICATE_MESSAGE, e.line, e.charPositionInLine, fpe.ruleName, fpe.predicateText, formatParserLocation());\r\n        codeAndMessage.add(message);\r\n        codeAndMessage.add(\"ERR 103\");\r\n    }\r\n    if (codeAndMessage.get(0).length() == 0) {\r\n        codeAndMessage.add(\"?????\");\r\n    }\r\n    return codeAndMessage;\r\n}"
}, {
	"Path": "org.drools.compiler.lang.ParseException.getMessage",
	"Comment": "this will print out a summary, including the line number. it will also print out the cause message if applicable.",
	"Method": "String getMessage(){\r\n    if (this.cause == null) {\r\n        return super.getMessage() + \" Line number: \" + this.lineNumber;\r\n    } else {\r\n        return super.getMessage() + \" Line number: \" + this.lineNumber + \". Caused by: \" + this.cause.getMessage();\r\n    }\r\n}"
}, {
	"Path": "org.drools.compiler.lang.DRL6Parser.chunk",
	"Comment": "matches a chunk started by the leftdelimiter and ended by the rightdelimiter.",
	"Method": "String chunk(int leftDelimiter,int rightDelimiter,int location){\r\n    String chunk = \"\";\r\n    int first = -1, last = first;\r\n    try {\r\n        match(input, leftDelimiter, null, null, DroolsEditorType.SYMBOL);\r\n        if (state.failed)\r\n            return chunk;\r\n        if (state.backtracking == 0 && location >= 0) {\r\n            helper.emit(location);\r\n        }\r\n        int nests = 0;\r\n        first = input.index();\r\n        while (input.LA(1) != DRL6Lexer.EOF && (input.LA(1) != rightDelimiter || nests > 0)) {\r\n            if (input.LA(1) == rightDelimiter) {\r\n                nests--;\r\n            } else if (input.LA(1) == leftDelimiter) {\r\n                nests++;\r\n            }\r\n            input.consume();\r\n        }\r\n        last = input.LT(-1).getTokenIndex();\r\n        for (int i = first; i < last + 1; i++) {\r\n            helper.emit(input.get(i), DroolsEditorType.CODE_CHUNK);\r\n        }\r\n        match(input, rightDelimiter, null, null, DroolsEditorType.SYMBOL);\r\n        if (state.failed)\r\n            return chunk;\r\n    } catch (RecognitionException re) {\r\n        reportError(re);\r\n    } finally {\r\n        if (last >= first) {\r\n            chunk = input.toString(first, last);\r\n        }\r\n    }\r\n    return chunk;\r\n}"
}, {
	"Path": "org.drools.compiler.compiler.DialectCompiletimeRegistry.addStaticImport",
	"Comment": "iterates all registered dialects, informing them of a static imports added to the packagebuilder",
	"Method": "void addStaticImport(ImportDescr importDescr){\r\n    for (Dialect dialect : this.map.values()) {\r\n        dialect.addStaticImport(importDescr);\r\n    }\r\n}"
}, {
	"Path": "org.drools.core.audit.WorkingMemoryFileLogger.writeToDisk",
	"Comment": "all events in the log are written to file. the log is automaticallycleared afterwards.",
	"Method": "void writeToDisk(){\r\n    if (!initialized) {\r\n        initializeLog();\r\n    }\r\n    Writer writer = null;\r\n    try {\r\n        FileOutputStream fileOut = new FileOutputStream(this.fileName + (this.nbOfFile == 0 ? \".log\" : this.nbOfFile + \".log\"), true);\r\n        writer = new OutputStreamWriter(fileOut, IoUtils.UTF8_CHARSET);\r\n        final XStream xstream = createTrustingXStream();\r\n        WorkingMemoryLog log = null;\r\n        synchronized (this.events) {\r\n            log = new WorkingMemoryLog(new ArrayList<LogEvent>(this.events));\r\n            clear();\r\n        }\r\n        writer.write(xstream.toXML(log) + \"\\n\");\r\n    } catch (final FileNotFoundException exc) {\r\n        throw new RuntimeException(\"Could not create the log file.  Please make sure that directory that the log file should be placed in does exist.\");\r\n    } catch (final Throwable t) {\r\n        logger.error(\"error\", t);\r\n    } finally {\r\n        if (writer != null) {\r\n            try {\r\n                writer.close();\r\n            } catch (Exception e) {\r\n            }\r\n        }\r\n    }\r\n    if (terminate) {\r\n        closeLog();\r\n        terminate = true;\r\n    } else if (split) {\r\n        closeLog();\r\n        this.nbOfFile++;\r\n        initialized = false;\r\n    }\r\n}"
}, {
	"Path": "org.drools.compiler.compiler.SerializableDroolsError.getMessage",
	"Comment": "classes that extend this must provide a printable message,which summarises the error.",
	"Method": "String getMessage(){\r\n    return this.message;\r\n}"
}, {
	"Path": "org.drools.core.reteoo.RuleRemovalContext.getRule",
	"Comment": "returns the reference to the rule being removed from the kbase",
	"Method": "RuleImpl getRule(){\r\n    return rule;\r\n}"
}, {
	"Path": "org.drools.compiler.integrationtests.MTEntryPointsTest.testTwoEntryPoints",
	"Comment": "inserts events using multiple threads into two entrypoints. the insertoperation is synchronized on corresponding sessionentrypoint instance.",
	"Method": "void testTwoEntryPoints(){\r\n    final EntryPoint firstThreadEntryPoint = kieSession.getEntryPoint(\"FirstStream\");\r\n    final EntryPoint secondThreadEntryPoint = kieSession.getEntryPoint(\"SecondStream\");\r\n    final int numInsertersInEachEntryPoint = 10;\r\n    final int numThreadPoolCapacity = numInsertersInEachEntryPoint * 2;\r\n    final ExecutorService executorService = Executors.newFixedThreadPool(numThreadPoolCapacity);\r\n    try {\r\n        final List<Future<?>> futures = new ArrayList();\r\n        for (int i = 0; i < numInsertersInEachEntryPoint; i++) {\r\n            final Future<?> futureForFirstThread = executorService.submit(new TestInserter(kieSession, firstThreadEntryPoint));\r\n            futures.add(futureForFirstThread);\r\n            final Future<?> futureForSecondThread = executorService.submit(new TestInserter(kieSession, secondThreadEntryPoint));\r\n            futures.add(futureForSecondThread);\r\n        }\r\n        for (final Future<?> f : futures) {\r\n            f.get(30, TimeUnit.SECONDS);\r\n        }\r\n    } finally {\r\n        executorService.shutdownNow();\r\n    }\r\n}"
}, {
	"Path": "org.drools.core.reteoo.Rete.addObjectSink",
	"Comment": "adds the objectsink so that it may receiveobjects propagated from this objectsource.",
	"Method": "void addObjectSink(ObjectSink objectSink){\r\n    final EntryPointNode node = (EntryPointNode) objectSink;\r\n    entryPoints.put(node.getEntryPoint(), node);\r\n    kBase.registerAddedEntryNodeCache(node);\r\n}"
}, {
	"Path": "org.drools.core.rule.LogicTransformer.processElement",
	"Comment": "recurse through the rule condition elements updating the declaration objecs",
	"Method": "void processElement(DeclarationScopeResolver resolver,Stack<RuleConditionElement> contextStack,RuleConditionElement element){\r\n    if (element instanceof Pattern) {\r\n        Pattern pattern = (Pattern) element;\r\n        for (RuleConditionElement ruleConditionElement : pattern.getNestedElements()) {\r\n            processElement(resolver, contextStack, ruleConditionElement);\r\n        }\r\n        for (Constraint constraint : pattern.getConstraints()) {\r\n            if (constraint instanceof Declaration) {\r\n                continue;\r\n            }\r\n            replaceDeclarations(resolver, pattern, constraint);\r\n        }\r\n    } else if (element instanceof EvalCondition) {\r\n        processEvalCondition(resolver, (EvalCondition) element);\r\n    } else if (element instanceof Accumulate) {\r\n        for (RuleConditionElement rce : element.getNestedElements()) {\r\n            processElement(resolver, contextStack, rce);\r\n        }\r\n        Accumulate accumulate = (Accumulate) element;\r\n        replaceDeclarations(resolver, accumulate);\r\n    } else if (element instanceof From) {\r\n        DataProvider provider = ((From) element).getDataProvider();\r\n        Declaration[] decl = provider.getRequiredDeclarations();\r\n        for (Declaration aDecl : decl) {\r\n            Declaration resolved = resolver.getDeclaration(aDecl.getIdentifier());\r\n            if (resolved != null && resolved != aDecl) {\r\n                provider.replaceDeclaration(aDecl, resolved);\r\n            } else if (resolved == null) {\r\n                Pattern old = aDecl.getPattern();\r\n                Pattern current = resolver.findPatternByIndex(old.getIndex());\r\n                if (current != null && old != current) {\r\n                    resolved = new Declaration(aDecl.getIdentifier(), aDecl.getExtractor(), current);\r\n                    provider.replaceDeclaration(aDecl, resolved);\r\n                }\r\n            }\r\n        }\r\n    } else if (element instanceof QueryElement) {\r\n        QueryElement qe = (QueryElement) element;\r\n        Pattern pattern = qe.getResultPattern();\r\n        for (Entry<String, Declaration> entry : pattern.getInnerDeclarations().entrySet()) {\r\n            Declaration resolved = resolver.getDeclaration(entry.getValue().getIdentifier());\r\n            if (resolved != null && resolved != entry.getValue() && resolved.getPattern() != pattern) {\r\n                entry.setValue(resolved);\r\n            }\r\n        }\r\n        List<Integer> varIndexes = asList(qe.getVariableIndexes());\r\n        for (int i = 0; i < qe.getArguments().length; i++) {\r\n            if (!(qe.getArguments()[i] instanceof QueryArgument.Declr)) {\r\n                continue;\r\n            }\r\n            Declaration declr = ((QueryArgument.Declr) qe.getArguments()[i]).getDeclaration();\r\n            Declaration resolved = resolver.getDeclaration(declr.getIdentifier());\r\n            if (resolved != declr && resolved.getPattern() != pattern) {\r\n                qe.getArguments()[i] = new QueryArgument.Declr(resolved);\r\n            }\r\n            if (ClassObjectType.DroolsQuery_ObjectType.isAssignableFrom(resolved.getPattern().getObjectType())) {\r\n                declr = pattern.addDeclaration(declr.getIdentifier());\r\n                ArrayElementReader reader = new ArrayElementReader(new SelfReferenceClassFieldReader(Object[].class), i, resolved.getDeclarationClass());\r\n                declr.setReadAccessor(reader);\r\n                varIndexes.add(i);\r\n            }\r\n        }\r\n        qe.setVariableIndexes(toIntArray(varIndexes));\r\n    } else if (element instanceof ConditionalBranch) {\r\n        processBranch(resolver, (ConditionalBranch) element);\r\n    } else {\r\n        contextStack.push(element);\r\n        for (RuleConditionElement ruleConditionElement : element.getNestedElements()) {\r\n            processElement(resolver, contextStack, ruleConditionElement);\r\n        }\r\n        contextStack.pop();\r\n    }\r\n}"
}, {
	"Path": "org.drools.compiler.lang.descr.OperatorDescr.setLeftString",
	"Comment": "this is an internal cache of the left string parameter that is set during the rewriteinto mvel, allowing for further analysis of the parameter type.",
	"Method": "void setLeftString(String left){\r\n    this.leftString = left;\r\n}"
}, {
	"Path": "org.drools.core.phreak.SegmentUtilities.createSegmentMemory",
	"Comment": "initialises the nodesegment memory for all nodes in the segment.",
	"Method": "void createSegmentMemory(LeftTupleSource tupleSource,InternalWorkingMemory wm,SegmentMemory createSegmentMemory,LeftTupleSource tupleSource,Memory mem,InternalWorkingMemory wm){\r\n    while (!SegmentUtilities.isRootNode(tupleSource, null)) {\r\n        tupleSource = tupleSource.getLeftTupleSource();\r\n    }\r\n    LeftTupleSource segmentRoot = tupleSource;\r\n    int nodeTypesInSegment = 0;\r\n    SegmentMemory smem = restoreSegmentFromPrototype(wm, segmentRoot, nodeTypesInSegment);\r\n    if (smem != null) {\r\n        if (NodeTypeEnums.isBetaNode(segmentRoot) && ((BetaNode) segmentRoot).isRightInputIsRiaNode()) {\r\n            createRiaSegmentMemory((BetaNode) segmentRoot, wm);\r\n        }\r\n        return smem;\r\n    }\r\n    smem = new SegmentMemory(segmentRoot);\r\n    long nodePosMask = 1;\r\n    long allLinkedTestMask = 0;\r\n    boolean updateNodeBit = true;\r\n    while (true) {\r\n        nodeTypesInSegment = updateNodeTypesMask(tupleSource, nodeTypesInSegment);\r\n        if (NodeTypeEnums.isBetaNode(tupleSource)) {\r\n            allLinkedTestMask = processBetaNode((BetaNode) tupleSource, wm, smem, nodePosMask, allLinkedTestMask, updateNodeBit);\r\n        } else {\r\n            switch(tupleSource.getType()) {\r\n                case NodeTypeEnums.LeftInputAdapterNode:\r\n                    allLinkedTestMask = processLiaNode((LeftInputAdapterNode) tupleSource, wm, smem, nodePosMask, allLinkedTestMask);\r\n                    break;\r\n                case NodeTypeEnums.EvalConditionNode:\r\n                    processEvalNode((EvalConditionNode) tupleSource, wm, smem);\r\n                    break;\r\n                case NodeTypeEnums.ConditionalBranchNode:\r\n                    updateNodeBit = processBranchNode((ConditionalBranchNode) tupleSource, wm, smem);\r\n                    break;\r\n                case NodeTypeEnums.FromNode:\r\n                    processFromNode((FromNode) tupleSource, wm, smem);\r\n                    break;\r\n                case NodeTypeEnums.ReactiveFromNode:\r\n                    processReactiveFromNode((MemoryFactory) tupleSource, wm, smem, nodePosMask);\r\n                    break;\r\n                case NodeTypeEnums.TimerConditionNode:\r\n                    processTimerNode((TimerNode) tupleSource, wm, smem, nodePosMask);\r\n                    break;\r\n                case NodeTypeEnums.AsyncSendNode:\r\n                    processAsyncSendNode((AsyncSendNode) tupleSource, wm, smem);\r\n                    break;\r\n                case NodeTypeEnums.AsyncReceiveNode:\r\n                    processAsyncReceiveNode((AsyncReceiveNode) tupleSource, wm, smem, nodePosMask);\r\n                    break;\r\n                case NodeTypeEnums.QueryElementNode:\r\n                    updateNodeBit = processQueryNode((QueryElementNode) tupleSource, wm, segmentRoot, smem, nodePosMask);\r\n                    break;\r\n            }\r\n        }\r\n        nodePosMask = nodePosMask << 1;\r\n        if (tupleSource.getSinkPropagator().size() == 1) {\r\n            LeftTupleSinkNode sink = tupleSource.getSinkPropagator().getFirstLeftTupleSink();\r\n            if (NodeTypeEnums.isLeftTupleSource(sink)) {\r\n                tupleSource = (LeftTupleSource) sink;\r\n            } else {\r\n                Memory memory = wm.getNodeMemory((MemoryFactory) sink);\r\n                if (sink.getType() == NodeTypeEnums.RightInputAdaterNode) {\r\n                    PathMemory riaPmem = ((RiaNodeMemory) memory).getRiaPathMemory();\r\n                    smem.getNodeMemories().add(riaPmem);\r\n                    RightInputAdapterNode rian = (RightInputAdapterNode) sink;\r\n                    ObjectSink[] nodes = rian.getObjectSinkPropagator().getSinks();\r\n                    for (ObjectSink node : nodes) {\r\n                        if (NodeTypeEnums.isLeftTupleSource(node)) {\r\n                            createSegmentMemory((LeftTupleSource) node, wm);\r\n                        }\r\n                    }\r\n                } else if (NodeTypeEnums.isTerminalNode(sink)) {\r\n                    smem.getNodeMemories().add(memory);\r\n                }\r\n                memory.setSegmentMemory(smem);\r\n                smem.setTipNode(sink);\r\n                break;\r\n            }\r\n        } else {\r\n            smem.setTipNode(tupleSource);\r\n            break;\r\n        }\r\n    }\r\n    smem.setAllLinkedMaskTest(allLinkedTestMask);\r\n    LeftTupleSource pathRoot = segmentRoot;\r\n    int ruleSegmentPosMask = 1;\r\n    int counter = 0;\r\n    while (pathRoot.getType() != NodeTypeEnums.LeftInputAdapterNode) {\r\n        LeftTupleSource leftTupleSource = pathRoot.getLeftTupleSource();\r\n        if (SegmentUtilities.isNonTerminalTipNode(leftTupleSource, null)) {\r\n            ruleSegmentPosMask = ruleSegmentPosMask << 1;\r\n            counter++;\r\n        }\r\n        pathRoot = leftTupleSource;\r\n    }\r\n    smem.setSegmentPosMaskBit(ruleSegmentPosMask);\r\n    smem.setPos(counter);\r\n    nodeTypesInSegment = updateRiaAndTerminalMemory(tupleSource, tupleSource, smem, wm, false, nodeTypesInSegment);\r\n    ((KnowledgeBaseImpl) wm.getKnowledgeBase()).registerSegmentPrototype(segmentRoot, smem);\r\n    return smem;\r\n}"
}, {
	"Path": "org.drools.compiler.lang.descr.OperatorDescr.setRightString",
	"Comment": "this is an internal cache of the right string parameter that is set during the rewriteinto mvel, allowing for further analysis of the parameter type.",
	"Method": "void setRightString(String right){\r\n    this.rightString = right;\r\n}"
}, {
	"Path": "org.drools.core.reteoo.ObjectSource.addObjectSink",
	"Comment": "adds the objectsink so that it may receivefacthandleimpl propagated from thisobjectsource.",
	"Method": "void addObjectSink(ObjectSink objectSink){\r\n    this.sink = this.sink.addObjectSink(objectSink, this.alphaNodeHashingThreshold);\r\n}"
}, {
	"Path": "org.drools.core.rule.JavaDialectRuntimeData.writeExternal",
	"Comment": "handles the write serialization of the packagecompilationdata. patterns in rules may reference generated data which cannot be serialized bydefault methods. the packagecompilationdata holds a reference to the generated bytecode. the generated bytecode must be restored before any rules.",
	"Method": "void writeExternal(ObjectOutput stream){\r\n    KeyStoreHelper helper = new KeyStoreHelper();\r\n    stream.writeBoolean(helper.isSigned());\r\n    if (helper.isSigned()) {\r\n        stream.writeObject(helper.getPvtKeyAlias());\r\n    }\r\n    ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    ObjectOutput out = new ObjectOutputStream(bos);\r\n    out.writeInt(this.store.size());\r\n    for (Entry<String, byte[]> entry : this.store.entrySet()) {\r\n        out.writeObject(entry.getKey());\r\n        out.writeObject(entry.getValue());\r\n    }\r\n    out.flush();\r\n    out.close();\r\n    byte[] buff = bos.toByteArray();\r\n    stream.writeObject(buff);\r\n    if (helper.isSigned()) {\r\n        sign(stream, helper, buff);\r\n    }\r\n    stream.writeInt(this.invokerLookups.size());\r\n    for (Entry<String, Wireable> entry : this.invokerLookups.entrySet()) {\r\n        stream.writeObject(entry.getKey());\r\n        stream.writeObject(entry.getValue());\r\n    }\r\n    stream.writeInt(this.classLookups.size());\r\n    for (Entry<String, byte[]> entry : this.classLookups.entrySet()) {\r\n        stream.writeObject(entry.getKey());\r\n        stream.writeObject(entry.getValue());\r\n    }\r\n}"
}, {
	"Path": "org.drools.core.reteoo.builder.BuildUtils.calculateTemporalDistance",
	"Comment": "calculates the temporal distance between all event patterns in the given subrule.",
	"Method": "TemporalDependencyMatrix calculateTemporalDistance(GroupElement groupElement){\r\n    List<Pattern> events = new ArrayList<Pattern>();\r\n    selectAllEventPatterns(events, groupElement);\r\n    final int size = events.size();\r\n    if (size >= 1) {\r\n        Interval[][] source = new Interval[size][];\r\n        for (int row = 0; row < size; row++) {\r\n            source[row] = new Interval[size];\r\n            for (int col = 0; col < size; col++) {\r\n                if (row == col) {\r\n                    source[row][col] = new Interval(0, 0);\r\n                } else {\r\n                    source[row][col] = new Interval(Interval.MIN, Interval.MAX);\r\n                }\r\n            }\r\n        }\r\n        Interval[][] result;\r\n        if (size > 1) {\r\n            List<Declaration> declarations = new ArrayList<Declaration>();\r\n            int eventIndex = 0;\r\n            for (Pattern event : events) {\r\n                declarations.add(event.getDeclaration());\r\n                Map<Declaration, Interval> temporal = new HashMap<Declaration, Interval>();\r\n                gatherTemporalRelationships(event.getConstraints(), temporal);\r\n                for (Map.Entry<Declaration, Interval> entry : temporal.entrySet()) {\r\n                    int targetIndex = declarations.indexOf(entry.getKey());\r\n                    Interval interval = entry.getValue();\r\n                    source[targetIndex][eventIndex].intersect(interval);\r\n                    Interval reverse = new Interval(interval.getUpperBound() == Long.MAX_VALUE ? Long.MIN_VALUE : -interval.getUpperBound(), interval.getLowerBound() == Long.MIN_VALUE ? Long.MAX_VALUE : -interval.getLowerBound());\r\n                    source[eventIndex][targetIndex].intersect(reverse);\r\n                }\r\n                eventIndex++;\r\n            }\r\n            result = TimeUtils.calculateTemporalDistance(source);\r\n        } else {\r\n            result = source;\r\n        }\r\n        return new TemporalDependencyMatrix(result, events);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.drools.compiler.lang.descr.AnnotatedBaseDescr.addAnnotation",
	"Comment": "assigns a new annotation to this type with the respective name and value",
	"Method": "AnnotationDescr addAnnotation(AnnotationDescr annotation,AnnotationDescr addAnnotation,String name,AnnotationDescr annotation,AnnotationDescr addAnnotation,String name,String value){\r\n    if (this.annotations == null) {\r\n        this.annotations = new HashMap<String, AnnotationDescr>();\r\n    } else {\r\n        AnnotationDescr existingAnnotation = annotations.get(name);\r\n        if (existingAnnotation != null) {\r\n            existingAnnotation.setDuplicated();\r\n            return existingAnnotation;\r\n        }\r\n    }\r\n    AnnotationDescr annotation = new AnnotationDescr(name, value);\r\n    annotation.setResource(getResource());\r\n    return this.annotations.put(annotation.getName(), annotation);\r\n}"
}, {
	"Path": "org.drools.compiler.rule.builder.dialect.java.parser.JavaParser.createErrorMessage",
	"Comment": "this will take a recognitionexception, and create a sensible error message out of it",
	"Method": "String createErrorMessage(RecognitionException e){\r\n    StringBuilder message = new StringBuilder();\r\n    message.append(source + \":\" + e.line + \":\" + e.charPositionInLine + \" \");\r\n    if (e instanceof MismatchedTokenException) {\r\n        MismatchedTokenException mte = (MismatchedTokenException) e;\r\n        message.append(\"mismatched token: \" + e.token + \"; expecting type \" + tokenNames[mte.expecting]);\r\n    } else if (e instanceof MismatchedTreeNodeException) {\r\n        MismatchedTreeNodeException mtne = (MismatchedTreeNodeException) e;\r\n        message.append(\"mismatched tree node: \" + mtne.node + \"; expecting type \" + tokenNames[mtne.expecting]);\r\n    } else if (e instanceof NoViableAltException) {\r\n        NoViableAltException nvae = (NoViableAltException) e;\r\n        message.append(\"Unexpected token '\" + e.token.getText() + \"'\");\r\n    } else if (e instanceof EarlyExitException) {\r\n        EarlyExitException eee = (EarlyExitException) e;\r\n        message.append(\"required (...)+ loop (decision=\" + eee.decisionNumber + \") did not match anything; token=\" + e.token);\r\n    } else if (e instanceof MismatchedSetException) {\r\n        MismatchedSetException mse = (MismatchedSetException) e;\r\n        message.append(\"mismatched token '\" + e.token + \"' expecting set \" + mse.expecting);\r\n    } else if (e instanceof MismatchedNotSetException) {\r\n        MismatchedNotSetException mse = (MismatchedNotSetException) e;\r\n        message.append(\"mismatched token '\" + e.token + \"' expecting set \" + mse.expecting);\r\n    } else if (e instanceof FailedPredicateException) {\r\n        FailedPredicateException fpe = (FailedPredicateException) e;\r\n        message.append(\"rule \" + fpe.ruleName + \" failed predicate: {\" + fpe.predicateText + \"}?\");\r\n    }\r\n    return message.toString();\r\n}"
}, {
	"Path": "org.drools.core.phreak.SegmentUtilities.inSubNetwork",
	"Comment": "is the lefttuplesource a node in the sub network for the rightinputadapternodeto be in the same network, it must be a node is after the two output of the parentand before the rianode.",
	"Method": "boolean inSubNetwork(RightInputAdapterNode riaNode,LeftTupleSource leftTupleSource){\r\n    LeftTupleSource startTupleSource = riaNode.getStartTupleSource();\r\n    LeftTupleSource parent = riaNode.getLeftTupleSource();\r\n    while (parent != startTupleSource) {\r\n        if (parent == leftTupleSource) {\r\n            return true;\r\n        }\r\n        parent = parent.getLeftTupleSource();\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.drools.core.impl.KnowledgeBaseImpl.writeExternal",
	"Comment": "handles the write serialization of the package. patterns in rules may reference generated data which cannot be serialized by default methods.the package uses packagecompilationdata to hold a reference to the generated bytecode. the generated bytecode must be restored before any rules.",
	"Method": "void writeExternal(ObjectOutput out){\r\n    ObjectOutput droolsStream;\r\n    boolean isDrools = out instanceof DroolsObjectOutputStream;\r\n    ByteArrayOutputStream bytes;\r\n    out.writeBoolean(isDrools);\r\n    if (isDrools) {\r\n        droolsStream = out;\r\n        bytes = null;\r\n    } else {\r\n        bytes = new ByteArrayOutputStream();\r\n        droolsStream = new DroolsObjectOutputStream(bytes);\r\n    }\r\n    droolsStream.writeBoolean(this.config.isClassLoaderCacheEnabled());\r\n    droolsStream.writeObject(((ProjectClassLoader) rootClassLoader).getStore());\r\n    droolsStream.writeObject(this.config);\r\n    droolsStream.writeObject(this.pkgs);\r\n    droolsStream.writeObject(this.id);\r\n    droolsStream.writeInt(this.workingMemoryCounter.get());\r\n    droolsStream.writeObject(this.processes);\r\n    droolsStream.writeUTF(this.factHandleFactory.getClass().getName());\r\n    droolsStream.writeObject(buildGlobalMapForSerialization());\r\n    this.eventSupport.removeEventListener(KieBaseEventListener.class);\r\n    droolsStream.writeObject(this.eventSupport);\r\n    droolsStream.writeObject(this.reteooBuilder);\r\n    droolsStream.writeObject(this.rete);\r\n    droolsStream.writeObject(this.resolvedReleaseId);\r\n    if (!isDrools) {\r\n        droolsStream.flush();\r\n        droolsStream.close();\r\n        bytes.close();\r\n        out.writeObject(bytes.toByteArray());\r\n    }\r\n}"
}, {
	"Path": "org.drools.compiler.integrationtests.session.UpdateTest.testJavaModifyBlock",
	"Comment": "this test requires mvel 1.2.19. leaving it commented until mvel is released.",
	"Method": "void testJavaModifyBlock(){\r\n    final KieBase kbase = SerializationHelper.serializeObject(loadKnowledgeBase(\"test_JavaModifyBlock.drl\"));\r\n    final KieSession ksession = createKnowledgeSession(kbase);\r\n    final List list = new ArrayList();\r\n    ksession.setGlobal(\"results\", list);\r\n    final Person bob = new Person(\"Bob\", 30);\r\n    bob.setStatus(\"hungry\");\r\n    ksession.insert(bob);\r\n    ksession.insert(new Cheese());\r\n    ksession.insert(new Cheese());\r\n    ksession.insert(new OuterClass.InnerClass(1));\r\n    ksession.fireAllRules();\r\n    assertEquals(2, list.size());\r\n    assertEquals(\"full\", bob.getStatus());\r\n    assertEquals(31, bob.getAge());\r\n    assertEquals(2, ((OuterClass.InnerClass) list.get(1)).getIntAttr());\r\n}"
}, {
	"Path": "org.drools.core.phreak.RuleAgendaItem.hashCode",
	"Comment": "return the hashcode of thetuplekey as the hashcode of the agendaitem",
	"Method": "int hashCode(){\r\n    return getRule().hashCode();\r\n}"
}, {
	"Path": "org.drools.core.reteoo.CompositeObjectSinkAdapter.doPropagateAssertObject",
	"Comment": "this is a hook method for subclasses to override. please keep it protected unless you knowwhat you are doing.",
	"Method": "void doPropagateAssertObject(InternalFactHandle factHandle,PropagationContext context,InternalWorkingMemory workingMemory,ObjectSink sink){\r\n    sink.assertObject(factHandle, context, workingMemory);\r\n}"
}, {
	"Path": "org.drools.compiler.integrationtests.waltz.WaltzUtil.inscribed_angle",
	"Comment": "this procedure is passed the basepoint of the intersection of two linesas well as the other two endpoints of the lines and calculates the angleinscribed by these three points.",
	"Method": "double inscribed_angle(int basepoint,int p1,int p2){\r\n    double angle1, angle2, temp;\r\n    angle1 = get_angle(basepoint, p1);\r\n    angle2 = get_angle(basepoint, p2);\r\n    temp = angle1 - angle2;\r\n    if (temp < 0.0) {\r\n        temp = -temp;\r\n    }\r\n    if (temp > WaltzUtil.PI) {\r\n        temp = 2 * WaltzUtil.PI - temp;\r\n    }\r\n    if (temp < 0.0) {\r\n        return (-temp);\r\n    }\r\n    return (temp);\r\n}"
}, {
	"Path": "org.drools.core.factmodel.FieldDefinition.getValue",
	"Comment": "returns the value of this attribute in the target bean instance",
	"Method": "Object getValue(Object bean){\r\n    return this.accessor.getValue(bean);\r\n}"
}, {
	"Path": "org.drools.core.marshalling.impl.PersisterHelper.longToByteArray",
	"Comment": "more efficient than instantiating byte buffers and opening streams",
	"Method": "byte[] longToByteArray(long value){\r\n    return new byte[] { (byte) ((value >>> 56) & 0xFF), (byte) ((value >>> 48) & 0xFF), (byte) ((value >>> 40) & 0xFF), (byte) ((value >>> 32) & 0xFF), (byte) ((value >>> 24) & 0xFF), (byte) ((value >>> 16) & 0xFF), (byte) ((value >>> 8) & 0xFF), (byte) (value & 0xFF) };\r\n}"
}, {
	"Path": "org.drools.compiler.rule.builder.dialect.java.JavaDialect.addRule",
	"Comment": "this will add the rule for compiling later on.it will not actually call the compiler",
	"Method": "void addRule(RuleBuildContext context){\r\n    final RuleImpl rule = context.getRule();\r\n    final RuleDescr ruleDescr = context.getRuleDescr();\r\n    RuleClassBuilder classBuilder = context.getDialect().getRuleClassBuilder();\r\n    String ruleClass = classBuilder.buildRule(context);\r\n    if (ruleClass == null) {\r\n        return;\r\n    }\r\n    addClassCompileTask(this.pkg.getName() + \".\" + ruleDescr.getClassName(), ruleDescr, ruleClass, this.src, new RuleErrorHandler(ruleDescr, rule, \"Rule Compilation error\"));\r\n    JavaDialectRuntimeData data = (JavaDialectRuntimeData) this.pkg.getDialectRuntimeRegistry().getDialectData(ID);\r\n    for (Map.Entry<String, String> invokers : context.getInvokers().entrySet()) {\r\n        final String className = invokers.getKey();\r\n        final Object invoker = context.getInvokerLookup(className);\r\n        if (invoker instanceof Wireable) {\r\n            data.putInvoker(className, (Wireable) invoker);\r\n        }\r\n        final String text = invokers.getValue();\r\n        final BaseDescr descr = context.getDescrLookup(className);\r\n        addClassCompileTask(className, descr, text, this.src, new RuleInvokerErrorHandler(descr, rule, \"Unable to generate rule invoker.\"));\r\n    }\r\n    final String name = this.pkg.getName() + \".\" + StringUtils.ucFirst(ruleDescr.getClassName());\r\n    final LineMappings mapping = new LineMappings(name);\r\n    mapping.setStartLine(ruleDescr.getConsequenceLine());\r\n    mapping.setOffset(ruleDescr.getConsequenceOffset());\r\n    this.pkg.getDialectRuntimeRegistry().getLineMappings().put(name, mapping);\r\n}"
}, {
	"Path": "org.drools.core.impl.StatefulKnowledgeSessionImpl.getObject",
	"Comment": "returns the fact object for the given facthandle. itactually attempts to return the value from the handle, before retrievingit from objects map.",
	"Method": "Object getObject(FactHandle handle){\r\n    if (((InternalFactHandle) handle).isDisconnected()) {\r\n        handle = this.defaultEntryPoint.getObjectStore().reconnect((InternalFactHandle) handle);\r\n    }\r\n    return this.defaultEntryPoint.getObject(handle);\r\n}"
}, {
	"Path": "org.drools.compiler.builder.impl.KnowledgeBuilderConfigurationImpl.setClassLoader",
	"Comment": "use this to override the classloader that will be used for the rules.",
	"Method": "void setClassLoader(ClassLoader classLoader){\r\n    this.classLoader = ProjectClassLoader.getClassLoader(classLoader, getClass(), isClassLoaderCacheEnabled());\r\n}"
}, {
	"Path": "org.drools.core.factmodel.ClassDefinition.getField",
	"Comment": "returns the field definition object for the given field name",
	"Method": "FieldDefinition getField(String fieldName,FieldDefinition getField,int index){\r\n    if (index >= fields.size() || index < 0) {\r\n        return null;\r\n    }\r\n    Iterator<FieldDefinition> iter = fields.values().iterator();\r\n    for (int j = 0; j < index; j++) {\r\n        iter.next();\r\n    }\r\n    return iter.next();\r\n}"
}, {
	"Path": "org.drools.core.impl.KnowledgeBaseImpl.addPackages",
	"Comment": "add a package to the network. iterates through thepackage adding each individual rule to thenetwork. before update network each referenced workingmemoryis locked.",
	"Method": "void addPackages(Collection<? extends KiePackage> newPkgs){\r\n    final List<InternalKnowledgePackage> clonedPkgs = new ArrayList();\r\n    for (KiePackage newPkg : newPkgs) {\r\n        clonedPkgs.add(((InternalKnowledgePackage) newPkg).deepCloneIfAlreadyInUse(rootClassLoader));\r\n    }\r\n    clonedPkgs.sort(Comparator.comparing((InternalKnowledgePackage p) -> p.getRules().size()).reversed().thenComparing(InternalKnowledgePackage::getName));\r\n    enqueueModification(() -> internalAddPackages(clonedPkgs));\r\n}"
}, {
	"Path": "org.drools.compiler.builder.impl.TypeDeclarationUtils.toBuildableType",
	"Comment": "not the cleanest logic, but this is what the builders expect downstream",
	"Method": "String toBuildableType(String className,ClassLoader loader){\r\n    int arrayDim = BuildUtils.externalArrayDimSize(className);\r\n    String prefix = \"\";\r\n    String coreType = arrayDim == 0 ? className : className.substring(0, className.indexOf(\"[\"));\r\n    coreType = typeName2ClassName(coreType, loader);\r\n    if (arrayDim > 0) {\r\n        coreType = BuildUtils.getTypeDescriptor(coreType);\r\n        for (int j = 0; j < arrayDim; j++) {\r\n            prefix = \"[\" + prefix;\r\n        }\r\n    } else {\r\n        return coreType;\r\n    }\r\n    return prefix + coreType;\r\n}"
}, {
	"Path": "org.drools.core.reteoo.LeftTupleSinkNodeList.removeLast",
	"Comment": "remove the last node from the list. the previous node then becomes the last node. if this is the lastnode then both first and last node references are set to null.",
	"Method": "LeftTupleSinkNode removeLast(){\r\n    if (this.lastNode == null) {\r\n        return null;\r\n    }\r\n    final LeftTupleSinkNode node = this.lastNode;\r\n    this.lastNode = node.getPreviousLeftTupleSinkNode();\r\n    node.setPreviousLeftTupleSinkNode(null);\r\n    if (this.lastNode != null) {\r\n        this.lastNode.setNextLeftTupleSinkNode(null);\r\n    } else {\r\n        this.firstNode = this.lastNode;\r\n    }\r\n    this.size--;\r\n    return node;\r\n}"
}, {
	"Path": "org.drools.core.factmodel.BuildUtils.getTypeDescriptor",
	"Comment": "returns the corresponding type descriptor for thegiven type.i decided to not use the asm type class methods because they requireresolving the actual type into a class instance and at this point,i think it is best to delay type resolution until it is really needed.",
	"Method": "String getTypeDescriptor(String type){\r\n    String internalType = null;\r\n    if (\"byte\".equals(type)) {\r\n        internalType = \"B\";\r\n    } else if (\"char\".equals(type)) {\r\n        internalType = \"C\";\r\n    } else if (\"double\".equals(type)) {\r\n        internalType = \"D\";\r\n    } else if (\"float\".equals(type)) {\r\n        internalType = \"F\";\r\n    } else if (\"int\".equals(type)) {\r\n        internalType = \"I\";\r\n    } else if (\"long\".equals(type)) {\r\n        internalType = \"J\";\r\n    } else if (\"short\".equals(type)) {\r\n        internalType = \"S\";\r\n    } else if (\"boolean\".equals(type)) {\r\n        internalType = \"Z\";\r\n    } else if (\"void\".equals(type)) {\r\n        internalType = \"V\";\r\n    } else if (type != null && type.startsWith(\"[\")) {\r\n        int j = 0;\r\n        while (type.charAt(++j) == '[') {\r\n        }\r\n        if (type.charAt(j) == 'L') {\r\n            internalType = type.replace('.', '/');\r\n        } else {\r\n            internalType = type;\r\n        }\r\n    } else if (type != null) {\r\n        internalType = \"L\" + type.replace('.', '/') + \";\";\r\n    }\r\n    return internalType;\r\n}"
}, {
	"Path": "org.drools.core.reteoo.builder.ReteooRuleBuilder.addRule",
	"Comment": "creates the corresponting rete network for the given rule and adds it tothe given rule base.",
	"Method": "List<TerminalNode> addRule(RuleImpl rule,InternalKnowledgeBase kBase){\r\n    final List<TerminalNode> nodes = new ArrayList<TerminalNode>();\r\n    final GroupElement[] subrules = rule.getTransformedLhs(kBase.getConfiguration().getComponentFactory().getLogicTransformerFactory().getLogicTransformer(), kBase.getGlobals());\r\n    for (int i = 0; i < subrules.length; i++) {\r\n        final BuildContext context = new BuildContext(kBase);\r\n        context.setRule(rule);\r\n        if (EventProcessingOption.STREAM.equals(kBase.getConfiguration().getEventProcessingMode())) {\r\n            TemporalDependencyMatrix temporal = this.utils.calculateTemporalDistance(subrules[i]);\r\n            context.setTemporalDistance(temporal);\r\n        }\r\n        if (kBase.getConfiguration().isSequential()) {\r\n            context.setTupleMemoryEnabled(false);\r\n            context.setObjectTypeNodeMemoryEnabled(false);\r\n        } else {\r\n            context.setTupleMemoryEnabled(true);\r\n            context.setObjectTypeNodeMemoryEnabled(true);\r\n        }\r\n        final TerminalNode node = this.addSubRule(context, subrules[i], i, rule);\r\n        nodes.add(node);\r\n    }\r\n    return nodes;\r\n}"
}, {
	"Path": "org.drools.core.facttemplates.FactTemplateObjectType.matches",
	"Comment": "determine if the passed object belongs to the object typedefined by this objecttype instance.",
	"Method": "boolean matches(Object object){\r\n    if (object instanceof Fact) {\r\n        return this.factTemplate.equals(((Fact) object).getFactTemplate());\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.drools.compiler.integrationtests.MTEntryPointsTest.testOneEntryPoint",
	"Comment": "inserts events using multiple threads into one entrypoint. the insertoperation is synchronized on corresponding sessionentrypoint instance.",
	"Method": "void testOneEntryPoint(){\r\n    final EntryPoint firstThreadEntryPoint = kieSession.getEntryPoint(\"FirstStream\");\r\n    final int numInsertersInEachEntryPoint = 10;\r\n    final ExecutorService executorService = Executors.newFixedThreadPool(numInsertersInEachEntryPoint);\r\n    try {\r\n        final List<Future<?>> futures = new ArrayList();\r\n        for (int i = 0; i < numInsertersInEachEntryPoint; i++) {\r\n            final Future<?> futureForFirstThread = executorService.submit(new TestInserter(kieSession, firstThreadEntryPoint));\r\n            futures.add(futureForFirstThread);\r\n        }\r\n        for (final Future<?> f : futures) {\r\n            f.get(30, TimeUnit.SECONDS);\r\n        }\r\n    } finally {\r\n        executorService.shutdownNow();\r\n    }\r\n}"
}, {
	"Path": "org.drools.compiler.integrationtests.ListenersTest.prepareKieModule",
	"Comment": "inserts a new kiemodule containing single kiebase and a stateful and stateless kiesessions with listenersinto kierepository.",
	"Method": "ReleaseId prepareKieModule(){\r\n    final KieServices ks = KieServices.Factory.get();\r\n    KieModuleModel module = ks.newKieModuleModel();\r\n    KieBaseModel baseModel = module.newKieBaseModel(\"defaultKBase\");\r\n    baseModel.setDefault(true);\r\n    baseModel.addPackage(\"*\");\r\n    KieSessionModel sessionModel = baseModel.newKieSessionModel(\"defaultKSession\");\r\n    sessionModel.setDefault(true);\r\n    sessionModel.setType(KieSessionModel.KieSessionType.STATEFUL);\r\n    sessionModel.newListenerModel(MarkingAgendaEventListener.class.getName(), ListenerModel.Kind.AGENDA_EVENT_LISTENER);\r\n    sessionModel.newListenerModel(MarkingRuntimeEventListener.class.getName(), ListenerModel.Kind.RULE_RUNTIME_EVENT_LISTENER);\r\n    KieSessionModel statelessSessionModel = baseModel.newKieSessionModel(\"defaultStatelessKSession\");\r\n    statelessSessionModel.setDefault(true);\r\n    statelessSessionModel.setType(KieSessionModel.KieSessionType.STATELESS);\r\n    statelessSessionModel.newListenerModel(MarkingAgendaEventListener.class.getName(), ListenerModel.Kind.AGENDA_EVENT_LISTENER);\r\n    statelessSessionModel.newListenerModel(MarkingRuntimeEventListener.class.getName(), ListenerModel.Kind.RULE_RUNTIME_EVENT_LISTENER);\r\n    KieFileSystem kfs = ks.newKieFileSystem();\r\n    kfs.writeKModuleXML(module.toXML());\r\n    kfs.generateAndWritePomXML(RELEASE_ID);\r\n    kfs.write(\"src/main/resources/\" + PACKAGE_PATH + \"/test.drl\", ResourceFactory.newByteArrayResource(DRL.getBytes()));\r\n    KieBuilder builder = ks.newKieBuilder(kfs).buildAll();\r\n    assertEquals(\"Unexpected compilation errors\", 0, builder.getResults().getMessages().size());\r\n    ks.getRepository().addKieModule(builder.getKieModule());\r\n    return RELEASE_ID;\r\n}"
}, {
	"Path": "org.drools.compiler.integrationtests.marshalling.MarshallingTest.testSignedSerialization2",
	"Comment": "deserializing a signed package without the proper public key should fail.",
	"Method": "void testSignedSerialization2(){\r\n    try {\r\n        setPrivateKeyProperties();\r\n        try {\r\n            Collection<KiePackage> kpkgs = loadKnowledgePackages(\"../test_Dynamic1_0.drl\");\r\n            fail(\"Deserialisation should have failed.\");\r\n        } catch (Exception e) {\r\n        }\r\n    } finally {\r\n        unsetPrivateKeyProperties();\r\n    }\r\n}"
}, {
	"Path": "org.drools.core.reteoo.ObjectSinkNodeList.add",
	"Comment": "add a objectsinknode to the list. if the linkedlist is empty then the first andlast nodes are set to the added node.",
	"Method": "void add(ObjectSinkNode node){\r\n    if (this.firstNode == null) {\r\n        this.firstNode = node;\r\n        this.lastNode = node;\r\n    } else {\r\n        this.lastNode.setNextObjectSinkNode(node);\r\n        node.setPreviousObjectSinkNode(this.lastNode);\r\n        this.lastNode = node;\r\n    }\r\n    this.size++;\r\n}"
}, {
	"Path": "org.drools.compiler.integrationtests.marshalling.MarshallingTest.testSignedSerialization3",
	"Comment": "deserializing a signed rulebase without the proper public key should fail.",
	"Method": "void testSignedSerialization3(){\r\n    try {\r\n        setPrivateKeyProperties();\r\n        Collection<KiePackage> kpkgs = loadKnowledgePackages(null, false, \"../test_Dynamic1_0.drl\");\r\n        InternalKnowledgeBase kBase = (InternalKnowledgeBase) getKnowledgeBase();\r\n        kBase.addPackages(kpkgs);\r\n        try {\r\n            kBase = SerializationHelper.serializeObject(kBase);\r\n            fail(\"Deserialisation should have failed.\");\r\n        } catch (Exception e) {\r\n        }\r\n    } finally {\r\n        unsetPrivateKeyProperties();\r\n    }\r\n}"
}, {
	"Path": "org.drools.compiler.rule.builder.dialect.java.JavaDialectConfiguration.setCompiler",
	"Comment": "set the compiler to be used when building the rules semantic code blocks.this overrides the default, and even what was set as a system property.",
	"Method": "void setCompiler(CompilerType compiler){\r\n    if (compiler == CompilerType.ECLIPSE) {\r\n        try {\r\n            Class.forName(\"org.eclipse.jdt.internal.compiler.Compiler\", true, this.conf.getClassLoader());\r\n        } catch (ClassNotFoundException e) {\r\n            throw new RuntimeException(\"The Eclipse JDT Core jar is not in the classpath\");\r\n        }\r\n    } else if (compiler == CompilerType.JANINO) {\r\n        try {\r\n            Class.forName(\"org.codehaus.janino.Parser\", true, this.conf.getClassLoader());\r\n        } catch (ClassNotFoundException e) {\r\n            throw new RuntimeException(\"The Janino jar is not in the classpath\");\r\n        }\r\n    }\r\n    switch(compiler) {\r\n        case ECLIPSE:\r\n            this.compiler = CompilerType.ECLIPSE;\r\n            break;\r\n        case JANINO:\r\n            this.compiler = CompilerType.JANINO;\r\n            break;\r\n        case NATIVE:\r\n            this.compiler = CompilerType.NATIVE;\r\n            break;\r\n        default:\r\n            throw new RuntimeException(\"value '\" + compiler + \"' is not a valid compiler\");\r\n    }\r\n}"
}, {
	"Path": "org.drools.core.common.EqualityKeyComparator.equal",
	"Comment": "equality keyreverses the compare, sothatthekeycontrols thecomparison",
	"Method": "boolean equal(Object o1,Object o2){\r\n    return (o1 == null) ? (o2 == null) : (o1 == o2) || o2.equals(o1);\r\n}"
}, {
	"Path": "org.drools.compiler.builder.impl.TypeDeclarationFactory.mergeTypeDeclarations",
	"Comment": "merges all the missing factfields from olddefinition into newdeclaration.",
	"Method": "void mergeTypeDeclarations(TypeDeclaration oldDeclaration,TypeDeclaration newDeclaration){\r\n    if (oldDeclaration == null) {\r\n        return;\r\n    }\r\n    for (FieldDefinition oldFactField : oldDeclaration.getTypeClassDef().getFieldsDefinitions()) {\r\n        FieldDefinition newFactField = newDeclaration.getTypeClassDef().getField(oldFactField.getName());\r\n        if (newFactField == null) {\r\n            newDeclaration.getTypeClassDef().addField(oldFactField);\r\n        }\r\n    }\r\n    newDeclaration.setTypeClass(oldDeclaration.getTypeClass());\r\n}"
}, {
	"Path": "org.drools.core.reteoo.ObjectTypeNode.doRemove",
	"Comment": "otn needs to override remove to avoid releasing the node id, since otn arenever removed from the rulebase in the current implementation",
	"Method": "boolean doRemove(RuleRemovalContext context,ReteooBuilder builder){\r\n    return false;\r\n}"
}, {
	"Path": "org.drools.core.reteoo.Rete.retractObject",
	"Comment": "retract a fact object from this rulebase and the specifiedworkingmemory.",
	"Method": "void retractObject(InternalFactHandle handle,PropagationContext context,InternalWorkingMemory workingMemory){\r\n    EntryPointId entryPoint = context.getEntryPoint();\r\n    EntryPointNode node = this.entryPoints.get(entryPoint);\r\n    ObjectTypeConf typeConf = ((WorkingMemoryEntryPoint) workingMemory.getWorkingMemoryEntryPoint(entryPoint.getEntryPointId())).getObjectTypeConfigurationRegistry().getObjectTypeConf(entryPoint, handle.getObject());\r\n    node.retractObject(handle, context, typeConf, workingMemory);\r\n}"
}, {
	"Path": "org.drools.core.factmodel.BuildUtils.getInternalType",
	"Comment": "returns the corresponding internal type representation for thegiven type.i decided to not use the asm type class methods because they requireresolving the actual type into a class instance and at this point,i think it is best to delay type resolution until it is really needed.",
	"Method": "String getInternalType(String type){\r\n    String internalType = null;\r\n    if (\"byte\".equals(type)) {\r\n        internalType = \"B\";\r\n    } else if (\"char\".equals(type)) {\r\n        internalType = \"C\";\r\n    } else if (\"double\".equals(type)) {\r\n        internalType = \"D\";\r\n    } else if (\"float\".equals(type)) {\r\n        internalType = \"F\";\r\n    } else if (\"int\".equals(type)) {\r\n        internalType = \"I\";\r\n    } else if (\"long\".equals(type)) {\r\n        internalType = \"J\";\r\n    } else if (\"short\".equals(type)) {\r\n        internalType = \"S\";\r\n    } else if (\"boolean\".equals(type)) {\r\n        internalType = \"Z\";\r\n    } else if (\"void\".equals(type)) {\r\n        internalType = \"V\";\r\n    } else if (type != null) {\r\n        internalType = type.replace('.', '/');\r\n    }\r\n    return internalType;\r\n}"
}, {
	"Path": "org.drools.compiler.rule.builder.dialect.java.JavaDialect.compileAll",
	"Comment": "this actually triggers the compiling of all the resources.errors are mapped back to the element that originally generated the semanticcode.",
	"Method": "void compileAll(){\r\n    if (this.generatedClassList.isEmpty()) {\r\n        this.errorHandlers.clear();\r\n        return;\r\n    }\r\n    final String[] classes = new String[this.generatedClassList.size()];\r\n    this.generatedClassList.toArray(classes);\r\n    File dumpDir = this.configuration.getPackageBuilderConfiguration().getDumpDir();\r\n    if (dumpDir != null) {\r\n        dumpResources(classes, dumpDir);\r\n    }\r\n    final CompilationResult result = this.compiler.compile(classes, this.src, this.packageStoreWrapper, rootClassLoader);\r\n    if (result.getErrors().length > 0) {\r\n        for (int i = 0; i < result.getErrors().length; i++) {\r\n            final CompilationProblem err = result.getErrors()[i];\r\n            final ErrorHandler handler = this.errorHandlers.get(err.getFileName());\r\n            handler.addError(err);\r\n        }\r\n        final Collection errors = this.errorHandlers.values();\r\n        for (Object error : errors) {\r\n            final ErrorHandler handler = (ErrorHandler) error;\r\n            if (handler.isInError()) {\r\n                this.results.add(handler.getError());\r\n            }\r\n        }\r\n    }\r\n    this.generatedClassList.clear();\r\n    this.errorHandlers.clear();\r\n}"
}, {
	"Path": "org.drools.core.reteoo.Rete.assertObject",
	"Comment": "this is the entry point into the network for all asserted facts. iterates a cacheof matching objecttypdenodes asserting the fact. if the cache does notexist it first iteraes and builds the cache.",
	"Method": "void assertObject(InternalFactHandle factHandle,PropagationContext context,InternalWorkingMemory workingMemory){\r\n    EntryPointId entryPoint = context.getEntryPoint();\r\n    EntryPointNode node = this.entryPoints.get(entryPoint);\r\n    ObjectTypeConf typeConf = ((WorkingMemoryEntryPoint) workingMemory.getWorkingMemoryEntryPoint(entryPoint.getEntryPointId())).getObjectTypeConfigurationRegistry().getObjectTypeConf(entryPoint, factHandle.getObject());\r\n    node.assertObject(factHandle, context, typeConf, workingMemory);\r\n}"
}, {
	"Path": "org.drools.core.facttemplates.FactImpl.resetId",
	"Comment": "this is used to reset the id, in the event an user tries toassert the same fact again, we reset the id to the existing one.",
	"Method": "void resetId(Fact fact){\r\n    this.id = fact.getFactId();\r\n}"
}, {
	"Path": "org.drools.core.reteoo.LeftTupleSinkNodeList.clear",
	"Comment": "iterates the list removing all the nodes until there are no more nodes to remove.",
	"Method": "void clear(){\r\n    while (removeFirst() != null) {\r\n    }\r\n}"
}, {
	"Path": "org.drools.compiler.compiler.DRLFactory.getBetterToken",
	"Comment": "helper method that creates a user friendly token definition",
	"Method": "String getBetterToken(int tokenType,String defaultValue,LanguageLevelOption languageLevel){\r\n    switch(languageLevel) {\r\n        case DRL5:\r\n            return getBetterTokenForDRL5(tokenType, defaultValue);\r\n        case DRL6:\r\n        case DRL6_STRICT:\r\n            return getBetterTokenForDRL6(tokenType, defaultValue);\r\n    }\r\n    throw new RuntimeException(\"Unknown language level\");\r\n}"
}, {
	"Path": "org.drools.compiler.compiler.DrlParser.getExpandedDRL",
	"Comment": "this will expand the drl using the given expander resolver. useful fordebugging.",
	"Method": "String getExpandedDRL(String source,Reader dsl,String getExpandedDRL,String source,DefaultExpanderResolver resolver){\r\n    final Expander expander = resolver.get(\"*\", null);\r\n    final String expanded = expander.expand(source);\r\n    if (expander.hasErrors()) {\r\n        String err = \"\";\r\n        for (ExpanderException ex : expander.getErrors()) {\r\n            err = err + \"\\n Line:[\" + ex.getLine() + \"] \" + ex.getMessage();\r\n        }\r\n        throw new DroolsParserException(err);\r\n    }\r\n    return expanded;\r\n}"
}, {
	"Path": "org.drools.core.reteoo.ObjectSinkNodeList.clear",
	"Comment": "iterates the list removing all the nodes until there are no more nodes to remove.",
	"Method": "void clear(){\r\n    while (removeFirst() != null) {\r\n    }\r\n}"
}, {
	"Path": "org.drools.compiler.compiler.DialectCompiletimeRegistry.addImport",
	"Comment": "iterates all registered dialects, informing them of an import added to the packagebuilder",
	"Method": "void addImport(ImportDescr importDescr){\r\n    for (Dialect dialect : this.map.values()) {\r\n        dialect.addImport(importDescr);\r\n    }\r\n}"
}, {
	"Path": "org.drools.compiler.builder.impl.ClassDefinitionFactory.generateDeclaredBean",
	"Comment": "generates a bean, and adds it to the composite class loader thateverything is using.",
	"Method": "ClassDefinition generateDeclaredBean(AbstractClassTypeDeclarationDescr typeDescr,TypeDeclaration type,PackageRegistry pkgRegistry,List<TypeDefinition> unresolvedTypeDefinitions,Map<String, AbstractClassTypeDeclarationDescr> unprocesseableDescrs){\r\n    ClassDefinition def = createClassDefinition(typeDescr, type);\r\n    boolean success = true;\r\n    success &= wireAnnotationDefs(typeDescr, type, def, pkgRegistry.getTypeResolver());\r\n    success &= wireEnumLiteralDefs(typeDescr, type, def);\r\n    success &= wireFields(typeDescr, type, def, pkgRegistry, unresolvedTypeDefinitions);\r\n    if (!success) {\r\n        unprocesseableDescrs.put(typeDescr.getType().getFullName(), typeDescr);\r\n    }\r\n    type.setTypeClassDef(def);\r\n    return def;\r\n}"
}, {
	"Path": "org.drools.core.io.impl.ClassPathResource.getInputStream",
	"Comment": "this implementation opens an inputstream for the given class path resource.",
	"Method": "InputStream getInputStream(){\r\n    this.lastRead = this.getLastModified();\r\n    return this.getURL().openStream();\r\n}"
}, {
	"Path": "org.drools.compiler.lang.DroolsParserExceptionFactory.getBetterToken",
	"Comment": "helper method that creates a user friendly token definition",
	"Method": "String getBetterToken(Token token,String getBetterToken,int tokenType){\r\n    return DRLFactory.getBetterToken(tokenType, null, languageLevel);\r\n}"
}, {
	"Path": "org.drools.core.definitions.rule.impl.RuleImpl.setConsequence",
	"Comment": "set the consequence that is associated with the successfulmatch of this rule.",
	"Method": "void setConsequence(Consequence consequence){\r\n    this.consequence = consequence;\r\n}"
}, {
	"Path": "org.drools.core.impl.StatefulKnowledgeSessionImpl.iterateFactHandles",
	"Comment": "this class is not thread safe, changes to the working memory duringiteration may give unexpected results",
	"Method": "Iterator<InternalFactHandle> iterateFactHandles(Iterator<InternalFactHandle> iterateFactHandles,org.kie.api.runtime.ObjectFilter filter){\r\n    return getObjectStore().iterateFactHandles(filter);\r\n}"
}, {
	"Path": "org.drools.compiler.integrationtests.eventgenerator.SimpleEventGenerator.addDelayedEventSource",
	"Comment": "add source which will generate events from the given start time on, but only maxitems instances at the most and not exceeding the time specified by maxduration",
	"Method": "EventOccurrence addDelayedEventSource(String id,Event ev,long minOccur,long avgOccur,long startTime,EventOccurrence addDelayedEventSource,String id,Event ev,long minOccur,long avgOccur,long startTime,long maxDuration,int maxItems){\r\n    if (!eventSourceIds.containsKey(id)) {\r\n        this.eventSourceIds.put(id, eventSourceIdCounter++);\r\n        final EventOccurrence evOcc = new EventOccurrence(id, ev, minOccur, avgOccur, startTime, maxDuration, maxItems);\r\n        this.nextEventSource.add(evOcc);\r\n        return evOcc;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.drools.core.common.EventFactHandle.isEvent",
	"Comment": "always returns true, since the eventfacthandle isonly used for events, and not for regular facts",
	"Method": "boolean isEvent(){\r\n    return true;\r\n}"
}, {
	"Path": "org.drools.core.io.impl.EncodedResource.getEncoding",
	"Comment": "return the encoding to use for reading from the resource,or null if none specified.",
	"Method": "String getEncoding(){\r\n    return this.encoding;\r\n}"
}, {
	"Path": "org.drools.core.reteoo.builder.BuildContext.peekRuleComponent",
	"Comment": "peeks at the top element from the rule component stack.the rule component stack is used to add trackability tothe reteoo nodes so that they can be linked to the rulecomponents that originated them.",
	"Method": "RuleComponent peekRuleComponent(){\r\n    return this.ruleComponent.isEmpty() ? null : this.ruleComponent.peek();\r\n}"
}, {
	"Path": "org.drools.core.rule.ConditionalBranch.getOuterDeclarations",
	"Comment": "it is not possible to declare and export any variables,so always return an empty map",
	"Method": "Map<String, Declaration> getOuterDeclarations(){\r\n    return Collections.emptyMap();\r\n}"
}, {
	"Path": "org.drools.compiler.rule.builder.dialect.java.JavaDialectConfiguration.getDefaultCompiler",
	"Comment": "this will attempt to read the system property to work out what default to set.this should only be done once when the class is loaded. after that point, you will haveto programmatically override it.",
	"Method": "CompilerType getDefaultCompiler(){\r\n    try {\r\n        final String prop = this.conf.getChainedProperties().getProperty(JAVA_COMPILER_PROPERTY, \"ECLIPSE\");\r\n        if (prop.equals(\"NATIVE\")) {\r\n            return CompilerType.NATIVE;\r\n        } else if (prop.equals(\"ECLIPSE\")) {\r\n            return CompilerType.ECLIPSE;\r\n        } else if (prop.equals(\"JANINO\")) {\r\n            return CompilerType.JANINO;\r\n        } else {\r\n            logger.error(\"Drools config: unable to use the drools.compiler property. Using default. It was set to:\" + prop);\r\n            return CompilerType.ECLIPSE;\r\n        }\r\n    } catch (final SecurityException e) {\r\n        logger.error(\"Drools config: unable to read the drools.compiler property. Using default.\", e);\r\n        return CompilerType.ECLIPSE;\r\n    }\r\n}"
}, {
	"Path": "org.drools.core.rule.GroupElement.clone",
	"Comment": "clones all conditional elements but references the non conditionalelement children",
	"Method": "GroupElement clone(GroupElement clone,boolean deepClone){\r\n    GroupElement cloned = new GroupElement();\r\n    cloned.setType(this.getType());\r\n    for (RuleConditionElement re : children) {\r\n        cloned.addChild(deepClone ? re.clone() : re);\r\n    }\r\n    return cloned;\r\n}"
}, {
	"Path": "org.drools.compiler.builder.impl.KnowledgeBuilderImpl.getBuilderConfiguration",
	"Comment": "return the packagebuilderconfiguration for this packagebuilder session",
	"Method": "KnowledgeBuilderConfigurationImpl getBuilderConfiguration(){\r\n    return this.configuration;\r\n}"
}, {
	"Path": "org.drools.core.rule.EntryPointId.getNestedElements",
	"Comment": "it is not possible to nest elements inside an entry point, soalways return an empty list.",
	"Method": "List<? extends RuleConditionElement> getNestedElements(){\r\n    return Collections.EMPTY_LIST;\r\n}"
}, {
	"Path": "org.drools.compiler.builder.impl.KnowledgeBuilderConfigurationImpl.getEvaluatorRegistry",
	"Comment": "returns the evaluator registry for this package builder configuration",
	"Method": "EvaluatorRegistry getEvaluatorRegistry(){\r\n    return this.evaluatorRegistry;\r\n}"
}, {
	"Path": "org.drools.core.reteoo.builder.BuildContext.popRuleComponent",
	"Comment": "removes the top element from the rule component stack.the rule component stack is used to add trackability tothe reteoo nodes so that they can be linked to the rulecomponents that originated them.",
	"Method": "RuleComponent popRuleComponent(){\r\n    return this.ruleComponent.pop();\r\n}"
}, {
	"Path": "org.drools.core.rule.NamedConsequence.resolveDeclaration",
	"Comment": "not possible to resolve any declaration, so always return null.",
	"Method": "Declaration resolveDeclaration(String identifier){\r\n    return null;\r\n}"
}, {
	"Path": "org.drools.core.factmodel.DefaultBeanClassBuilder.buildClass",
	"Comment": "dynamically builds, defines and loads a class based on the given class definition",
	"Method": "byte[] buildClass(ClassDefinition classDef,ClassLoader classLoader){\r\n    ClassWriter cw = this.buildClassHeader(classLoader, classDef);\r\n    buildMetaData(cw, classDef);\r\n    buildFields(cw, classDef);\r\n    if (classDef.isTraitable()) {\r\n        buildDynamicPropertyMap(cw, classDef);\r\n        buildTraitMap(cw, classDef);\r\n        buildFieldTMS(cw, classDef);\r\n    }\r\n    buildConstructors(cw, classDef);\r\n    buildGettersAndSetters(cw, classDef);\r\n    buildEqualityMethods(cw, classDef);\r\n    buildToString(cw, classDef);\r\n    if (classDef.isTraitable()) {\r\n        buildSerializationMethods(cw, classDef);\r\n    }\r\n    if (classDef.isReactive()) {\r\n        implementReactivity(cw, classDef);\r\n    }\r\n    cw.visitEnd();\r\n    return cw.toByteArray();\r\n}"
}, {
	"Path": "org.drools.core.base.ClassFieldAccessorFactory.getWriterSuperClassFor",
	"Comment": "returns the appropriate base class field extractor classfor the given fieldtype",
	"Method": "Class<?> getWriterSuperClassFor(Class<?> fieldType){\r\n    Class<?> ret = null;\r\n    if (fieldType.isPrimitive()) {\r\n        if (fieldType == char.class) {\r\n            ret = BaseCharClassFieldWriter.class;\r\n        } else if (fieldType == byte.class) {\r\n            ret = BaseByteClassFieldWriter.class;\r\n        } else if (fieldType == short.class) {\r\n            ret = BaseShortClassFieldWriter.class;\r\n        } else if (fieldType == int.class) {\r\n            ret = BaseIntClassFieldWriter.class;\r\n        } else if (fieldType == long.class) {\r\n            ret = BaseLongClassFieldWriter.class;\r\n        } else if (fieldType == float.class) {\r\n            ret = BaseFloatClassFieldWriter.class;\r\n        } else if (fieldType == double.class) {\r\n            ret = BaseDoubleClassFieldWriter.class;\r\n        } else if (fieldType == boolean.class) {\r\n            ret = BaseBooleanClassFieldWriter.class;\r\n        }\r\n    } else {\r\n        ret = BaseObjectClassFieldWriter.class;\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "org.drools.core.definitions.rule.impl.RuleImpl.isSalienceDynamic",
	"Comment": "returns true if the rule uses dynamic salience, false otherwise.",
	"Method": "boolean isSalienceDynamic(){\r\n    return getSalience().isDynamic();\r\n}"
}, {
	"Path": "org.drools.core.reteoo.ObjectSinkNodeList.removeLast",
	"Comment": "remove the last node from the list. the previous node then becomes the last node. if this is the lastnode then both first and last node references are set to null.",
	"Method": "ObjectSinkNode removeLast(){\r\n    if (this.lastNode == null) {\r\n        return null;\r\n    }\r\n    final ObjectSinkNode node = this.lastNode;\r\n    this.lastNode = node.getPreviousObjectSinkNode();\r\n    node.setPreviousObjectSinkNode(null);\r\n    if (this.lastNode != null) {\r\n        this.lastNode.setNextObjectSinkNode(null);\r\n    } else {\r\n        this.firstNode = this.lastNode;\r\n    }\r\n    this.size--;\r\n    return node;\r\n}"
}, {
	"Path": "org.drools.core.event.AbstractEventSupport.addEventListener",
	"Comment": "adds the specified listener to the list of listeners. note that this method needs to besynchonized because it performs two independent operations on the underlying list",
	"Method": "void addEventListener(E listener){\r\n    if (!this.listeners.contains(listener)) {\r\n        this.listeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "org.drools.core.common.AgendaItemImpl.hashCode",
	"Comment": "return the hashcode of thetuplekey as the hashcode of the agendaitem",
	"Method": "int hashCode(){\r\n    return this.tuple.hashCode();\r\n}"
}, {
	"Path": "org.drools.core.io.impl.UrlResource.equals",
	"Comment": "this implementation compares the underlying url references.",
	"Method": "boolean equals(Object obj){\r\n    if (obj == null) {\r\n        return false;\r\n    }\r\n    return (obj == this || (obj instanceof UrlResource && this.url.equals(((UrlResource) obj).url)));\r\n}"
}, {
	"Path": "org.drools.core.factmodel.DefaultEnumClassBuilder.buildClass",
	"Comment": "dynamically builds, defines and loads a class based on the given class definition",
	"Method": "byte[] buildClass(ClassDefinition classDef,ClassLoader classLoader){\r\n    if (!(classDef instanceof EnumClassDefinition)) {\r\n        throw new RuntimeException(\"FATAL : Trying to create an enum out of a bean class definition  \" + classDef);\r\n    }\r\n    EnumClassDefinition edef = (EnumClassDefinition) classDef;\r\n    ClassWriter cw = this.buildClassHeader(classLoader, edef);\r\n    this.buildLiterals(cw, edef);\r\n    this.buildFields(cw, edef);\r\n    this.buildConstructors(cw, edef);\r\n    this.buildGettersAndSetters(cw, edef);\r\n    this.buildEqualityMethods(cw, edef);\r\n    this.buildToString(cw, edef);\r\n    cw.visitEnd();\r\n    byte[] serializedClass = cw.toByteArray();\r\n    return serializedClass;\r\n}"
}, {
	"Path": "org.drools.compiler.integrationtests.WorkingMemoryActionsSerializationTest.checkExecutions",
	"Comment": "checks that the rule names passed in are called the number of times passed in.",
	"Method": "void checkExecutions(List<String> rules,List<Integer> expected){\r\n    Assert.assertEquals(\"Wrong config passed. Rules doesn't match times\", rules.size(), expected.size());\r\n    synchronized (ruleCalls) {\r\n        for (int i = 0; i < rules.size(); i++) {\r\n            final String ruleName = rules.get(i);\r\n            Integer actualTimes = ruleCalls.get(ruleName);\r\n            if (actualTimes == null) {\r\n                actualTimes = 0;\r\n            }\r\n            Assert.assertEquals(\"Ruled \" + ruleName + \" is not called as often as expected.\", expected.get(i), actualTimes);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.drools.core.facttemplates.FactTemplateImpl.getFieldTemplate",
	"Comment": "a convienance method for finding the slot matchingthe string name.",
	"Method": "FieldTemplate getFieldTemplate(String name,FieldTemplate getFieldTemplate,int index){\r\n    return this.fields[index];\r\n}"
}, {
	"Path": "org.drools.compiler.lang.dsl.DSLTokenizedMappingFile.readFile",
	"Comment": "read a dsl file and convert it to a string. comment lines are removed.split lines are joined, inserting a space for an eol, but maintaining theoriginal number of lines by inserting eols. options are recognized.keeps track of original line lengths for fixing parser error messages.",
	"Method": "String readFile(Reader reader){\r\n    lineLengths = new ArrayList<Integer>();\r\n    lineLengths.add(null);\r\n    LineNumberReader lnr = new LineNumberReader(reader);\r\n    StringBuilder sb = new StringBuilder();\r\n    int nlCount = 0;\r\n    boolean inEntry = false;\r\n    String line;\r\n    while ((line = lnr.readLine()) != null) {\r\n        lineLengths.add(line.length());\r\n        Matcher commentMat = commentPat.matcher(line);\r\n        if (commentMat.matches()) {\r\n            if (inEntry) {\r\n                nlCount++;\r\n            } else {\r\n                sb.append('\\n');\r\n            }\r\n            if (\"#/\".equals(commentMat.group(2))) {\r\n                String[] options = commentMat.group(1).substring(2).trim().split(\"\\\\s+\");\r\n                for (String option : options) {\r\n                    optionSet.add(option);\r\n                }\r\n            }\r\n            continue;\r\n        }\r\n        if (entryPat.matcher(line).matches()) {\r\n            if (inEntry) {\r\n                for (int i = 0; i < nlCount; i++) sb.append('\\n');\r\n            }\r\n            sb.append(line);\r\n            nlCount = 1;\r\n            inEntry = true;\r\n            continue;\r\n        }\r\n        sb.append(' ').append(line);\r\n        nlCount++;\r\n    }\r\n    if (inEntry)\r\n        sb.append('\\n');\r\n    lnr.close();\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.drools.compiler.kie.builder.impl.KieModuleCacheHelper.longToByteArray",
	"Comment": "more efficient than instantiating byte buffers and opening streams",
	"Method": "byte[] longToByteArray(long value){\r\n    return new byte[] { (byte) ((value >>> 56) & 0xFF), (byte) ((value >>> 48) & 0xFF), (byte) ((value >>> 40) & 0xFF), (byte) ((value >>> 32) & 0xFF), (byte) ((value >>> 24) & 0xFF), (byte) ((value >>> 16) & 0xFF), (byte) ((value >>> 8) & 0xFF), (byte) (value & 0xFF) };\r\n}"
}]