[{
	"Path": "net.majorkernelpanic.streaming.MediaStream.getBitrate",
	"Comment": "returns an approximation of the bit rate consumed by the stream in bit per seconde.",
	"Method": "long getBitrate(){\r\n    return !mStreaming ? 0 : mPacketizer.getRtpSocket().getBitrate();\r\n}"
}, {
	"Path": "jodd.htmlstapler.HtmlStaplerBundlesManager.getLocalAddressAndPort",
	"Comment": "returns local address and port for downloading\tlocal resources.",
	"Method": "String getLocalAddressAndPort(){\r\n    return localAddressAndPort;\r\n}"
}, {
	"Path": "org.joda.time.Duration.toStandardSeconds",
	"Comment": "converts this duration to a period in seconds assuming that there are thestandard number of milliseconds in a second.this method assumes that there are 1000 milliseconds in a second.all currently supplied chronologies use this definition.",
	"Method": "Seconds toStandardSeconds(){\r\n    long seconds = getStandardSeconds();\r\n    return Seconds.seconds(FieldUtils.safeToInt(seconds));\r\n}"
}, {
	"Path": "org.joda.time.Hours.toStandardMinutes",
	"Comment": "converts this period in hours to a period in minutes assuming a60 minute hour.this method allows you to convert between different types of period.however to achieve this it makes the assumption that all hours are 60 minutes long.this may not be true for some unusual chronologies. however, it is includedas it is a useful operation for many applications and business rules.",
	"Method": "Minutes toStandardMinutes(){\r\n    return Minutes.minutes(FieldUtils.safeMultiply(getValue(), DateTimeConstants.MINUTES_PER_HOUR));\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.Session.getSessionDescription",
	"Comment": "returns a session description that can be stored in a file or sent to a client with rtsp.",
	"Method": "String getSessionDescription(){\r\n    StringBuilder sessionDescription = new StringBuilder();\r\n    if (mDestination == null) {\r\n        throw new IllegalStateException(\"setDestination() has not been called !\");\r\n    }\r\n    sessionDescription.append(\"v=0\\r\\n\");\r\n    sessionDescription.append(\"o=- \" + mTimestamp + \" \" + mTimestamp + \" IN IP4 \" + mOrigin + \"\\r\\n\");\r\n    sessionDescription.append(\"s=Unnamed\\r\\n\");\r\n    sessionDescription.append(\"i=N/A\\r\\n\");\r\n    sessionDescription.append(\"c=IN IP4 \" + mDestination + \"\\r\\n\");\r\n    sessionDescription.append(\"t=0 0\\r\\n\");\r\n    sessionDescription.append(\"a=recvonly\\r\\n\");\r\n    if (mAudioStream != null) {\r\n        sessionDescription.append(mAudioStream.getSessionDescription());\r\n        sessionDescription.append(\"a=control:trackID=\" + 0 + \"\\r\\n\");\r\n    }\r\n    if (mVideoStream != null) {\r\n        sessionDescription.append(mVideoStream.getSessionDescription());\r\n        sessionDescription.append(\"a=control:trackID=\" + 1 + \"\\r\\n\");\r\n    }\r\n    return sessionDescription.toString();\r\n}"
}, {
	"Path": "org.json.JSONArray.length",
	"Comment": "get the number of elements in the jsonarray, included nulls.",
	"Method": "int length(){\r\n    return this.myArrayList.size();\r\n}"
}, {
	"Path": "jodd.util.CharUtil.isLowercaseAlpha",
	"Comment": "returns true if specified character is lowercase ascii.\tif user uses only asciis, it is much much faster.",
	"Method": "boolean isLowercaseAlpha(char c){\r\n    return (c >= 'a') && (c <= 'z');\r\n}"
}, {
	"Path": "jodd.props.Props.resolveActiveProfiles",
	"Comment": "resolves active profiles from special property.\tthis property can be only a base property!\tif default active property is not defined, nothing happens.\totherwise, it will replace currently active profiles.",
	"Method": "void resolveActiveProfiles(){\r\n    if (activeProfilesProp == null) {\r\n        activeProfiles = null;\r\n        return;\r\n    }\r\n    final PropsEntry pv = data.getBaseProperty(activeProfilesProp);\r\n    if (pv == null) {\r\n        return;\r\n    }\r\n    final String value = pv.getValue();\r\n    if (StringUtil.isBlank(value)) {\r\n        activeProfiles = null;\r\n        return;\r\n    }\r\n    activeProfiles = StringUtil.splitc(value, ',');\r\n    StringUtil.trimAll(activeProfiles);\r\n}"
}, {
	"Path": "org.joda.time.chrono.LimitChronology.equals",
	"Comment": "a limit chronology is only equal to a limit chronology with thesame base chronology and limits.",
	"Method": "boolean equals(Object obj){\r\n    if (this == obj) {\r\n        return true;\r\n    }\r\n    if (obj instanceof LimitChronology == false) {\r\n        return false;\r\n    }\r\n    LimitChronology chrono = (LimitChronology) obj;\r\n    return getBase().equals(chrono.getBase()) && FieldUtils.equals(getLowerLimit(), chrono.getLowerLimit()) && FieldUtils.equals(getUpperLimit(), chrono.getUpperLimit());\r\n}"
}, {
	"Path": "jodd.util.ClassUtil.getRawType",
	"Comment": "returns raw class for given type when implementation class is known\tand it makes difference.",
	"Method": "Class getRawType(Type type,Class<?> getRawType,Type type,Class implClass){\r\n    if (type instanceof Class) {\r\n        return (Class) type;\r\n    }\r\n    if (type instanceof ParameterizedType) {\r\n        ParameterizedType pType = (ParameterizedType) type;\r\n        return getRawType(pType.getRawType(), implClass);\r\n    }\r\n    if (type instanceof WildcardType) {\r\n        WildcardType wType = (WildcardType) type;\r\n        Type[] lowerTypes = wType.getLowerBounds();\r\n        if (lowerTypes.length > 0) {\r\n            return getRawType(lowerTypes[0], implClass);\r\n        }\r\n        Type[] upperTypes = wType.getUpperBounds();\r\n        if (upperTypes.length != 0) {\r\n            return getRawType(upperTypes[0], implClass);\r\n        }\r\n        return Object.class;\r\n    }\r\n    if (type instanceof GenericArrayType) {\r\n        Type genericComponentType = ((GenericArrayType) type).getGenericComponentType();\r\n        Class<?> rawType = getRawType(genericComponentType, implClass);\r\n        return Array.newInstance(rawType, 0).getClass();\r\n    }\r\n    if (type instanceof TypeVariable) {\r\n        TypeVariable<?> varType = (TypeVariable<?>) type;\r\n        if (implClass != null) {\r\n            Type resolvedType = resolveVariable(varType, implClass);\r\n            if (resolvedType != null) {\r\n                return getRawType(resolvedType, null);\r\n            }\r\n        }\r\n        Type[] boundsTypes = varType.getBounds();\r\n        if (boundsTypes.length == 0) {\r\n            return Object.class;\r\n        }\r\n        return getRawType(boundsTypes[0], implClass);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.joda.time.Interval.withPeriodBeforeEnd",
	"Comment": "creates a new interval with the specified period before the end instant.",
	"Method": "Interval withPeriodBeforeEnd(ReadablePeriod period){\r\n    if (period == null) {\r\n        return withDurationBeforeEnd(null);\r\n    }\r\n    Chronology chrono = getChronology();\r\n    long endMillis = getEndMillis();\r\n    long startMillis = chrono.add(period, endMillis, -1);\r\n    return new Interval(startMillis, endMillis, chrono);\r\n}"
}, {
	"Path": "jodd.asm7.signature.SignatureVisitor.visitTypeArgument",
	"Comment": "visits a type argument of the last visited class or inner class type.",
	"Method": "void visitTypeArgument(SignatureVisitor visitTypeArgument,char wildcard){\r\n    return this;\r\n}"
}, {
	"Path": "jodd.petite.scope.SessionScope.registerSessionBeans",
	"Comment": "registers new session destroy callback if not already registered.",
	"Method": "Map<String, BeanData> registerSessionBeans(HttpSession httpSession){\r\n    SessionBeans sessionBeans = new SessionBeans();\r\n    httpSession.setAttribute(SESSION_BEANS_NAME, sessionBeans);\r\n    return sessionBeans.getBeanMap();\r\n}"
}, {
	"Path": "org.joda.time.convert.ReadablePartialConverter.getChronology",
	"Comment": "gets the chronology, which is taken from the readablepartial.",
	"Method": "Chronology getChronology(Object object,DateTimeZone zone,Chronology getChronology,Object object,Chronology chrono){\r\n    if (chrono == null) {\r\n        chrono = ((ReadablePartial) object).getChronology();\r\n        chrono = DateTimeUtils.getChronology(chrono);\r\n    }\r\n    return chrono;\r\n}"
}, {
	"Path": "jodd.jerry.Jerry.children",
	"Comment": "gets the immediate children of each element in the set of matched elements.",
	"Method": "Jerry children(){\r\n    List<Node> result = new NodeList(nodes.length);\r\n    if (nodes.length > 0) {\r\n        for (Node node : nodes) {\r\n            Node[] children = node.getChildElements();\r\n            Collections.addAll(result, children);\r\n        }\r\n    }\r\n    return new Jerry(this, result);\r\n}"
}, {
	"Path": "org.joda.time.Seconds.seconds",
	"Comment": "obtains an instance of seconds that may be cached.seconds is immutable, so instances can be cached and shared.this factory method provides access to shared instances.",
	"Method": "Seconds seconds(int seconds){\r\n    switch(seconds) {\r\n        case 0:\r\n            return ZERO;\r\n        case 1:\r\n            return ONE;\r\n        case 2:\r\n            return TWO;\r\n        case 3:\r\n            return THREE;\r\n        case Integer.MAX_VALUE:\r\n            return MAX_VALUE;\r\n        case Integer.MIN_VALUE:\r\n            return MIN_VALUE;\r\n        default:\r\n            return new Seconds(seconds);\r\n    }\r\n}"
}, {
	"Path": "org.json.JSONWriter.endObject",
	"Comment": "end an object. this method most be called to balance calls toobject.",
	"Method": "JSONWriter endObject(){\r\n    return this.end('k', '}');\r\n}"
}, {
	"Path": "org.joda.time.DateMidnight.withEra",
	"Comment": "returns a copy of this date with the era field updated.datemidnight is immutable, so there are no set methods.instead, this method returns a new instance with the value ofera changed.",
	"Method": "DateMidnight withEra(int era){\r\n    return withMillis(getChronology().era().set(getMillis(), era));\r\n}"
}, {
	"Path": "jodd.servlet.DispatcherUtil.include",
	"Comment": "include page which path is relative to the current http request.",
	"Method": "boolean include(ServletRequest request,ServletResponse response,String page){\r\n    RequestDispatcher dispatcher = request.getRequestDispatcher(page);\r\n    if (dispatcher != null) {\r\n        dispatcher.include(request, response);\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.joda.time.DateTime.withMillis",
	"Comment": "returns a copy of this datetime with different millis.the returned object will be either be a new instance or this.only the millis will change, the chronology and time zone are kept.",
	"Method": "DateTime withMillis(long newMillis){\r\n    return (newMillis == getMillis() ? this : new DateTime(newMillis, getChronology()));\r\n}"
}, {
	"Path": "org.joda.time.MonthDay.getField",
	"Comment": "gets the field for a specific index in the chronology specified.this method must not use any instance variables.",
	"Method": "DateTimeField getField(int index,Chronology chrono,DateTimeField getField){\r\n    switch(index) {\r\n        case MONTH_OF_YEAR:\r\n            return chrono.monthOfYear();\r\n        case DAY_OF_MONTH:\r\n            return chrono.dayOfMonth();\r\n        default:\r\n            throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.Partial.without",
	"Comment": "gets a copy of this date with the specified field removed.if this partial did not previously support the field, no error occurs.",
	"Method": "Partial without(DateTimeFieldType fieldType){\r\n    int index = indexOf(fieldType);\r\n    if (index != -1) {\r\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[size() - 1];\r\n        int[] newValues = new int[size() - 1];\r\n        System.arraycopy(iTypes, 0, newTypes, 0, index);\r\n        System.arraycopy(iTypes, index + 1, newTypes, index, newTypes.length - index);\r\n        System.arraycopy(iValues, 0, newValues, 0, index);\r\n        System.arraycopy(iValues, index + 1, newValues, index, newValues.length - index);\r\n        Partial newPartial = new Partial(iChronology, newTypes, newValues);\r\n        iChronology.validate(newPartial, newValues);\r\n        return newPartial;\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "jodd.util.ArraysUtil.join",
	"Comment": "joins arrays. component type is resolved from the array argument.",
	"Method": "T[] join(T[] arrays,T[] join,Class<T> componentType,T[][] arrays,String[] join,String[] arrays,byte[] join,byte[] arrays,char[] join,char[] arrays,short[] join,short[] arrays,int[] join,int[] arrays,long[] join,long[] arrays,float[] join,float[] arrays,double[] join,double[] arrays,boolean[] join,boolean[] arrays){\r\n    if (arrays.length == 0) {\r\n        return new boolean[0];\r\n    }\r\n    if (arrays.length == 1) {\r\n        return arrays[0];\r\n    }\r\n    int length = 0;\r\n    for (boolean[] array : arrays) {\r\n        length += array.length;\r\n    }\r\n    boolean[] result = new boolean[length];\r\n    length = 0;\r\n    for (boolean[] array : arrays) {\r\n        System.arraycopy(array, 0, result, length, array.length);\r\n        length += array.length;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "jodd.util.StringUtil.startsWithIgnoreCase",
	"Comment": "tests if this string starts with the specified prefix with ignored case\tand with the specified prefix beginning a specified index.",
	"Method": "boolean startsWithIgnoreCase(String src,String subS,boolean startsWithIgnoreCase,String src,String subS,int startIndex){\r\n    String sub = subS.toLowerCase();\r\n    int sublen = sub.length();\r\n    if (startIndex + sublen > src.length()) {\r\n        return false;\r\n    }\r\n    int j = 0;\r\n    int i = startIndex;\r\n    while (j < sublen) {\r\n        char source = Character.toLowerCase(src.charAt(i));\r\n        if (sub.charAt(j) != source) {\r\n            return false;\r\n        }\r\n        j++;\r\n        i++;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "jodd.util.ClassUtil.isInstanceOf",
	"Comment": "safe version of isinstance, returns false\tif any of the arguments is null.",
	"Method": "boolean isInstanceOf(Object object,Class target){\r\n    if (object == null || target == null) {\r\n        return false;\r\n    }\r\n    return target.isInstance(object);\r\n}"
}, {
	"Path": "jodd.util.cl.ExtendedURLClassLoader.addParentOnlyRules",
	"Comment": "adds parent only rules for classes which must be loaded on the\tparent loader.",
	"Method": "void addParentOnlyRules(String packages){\r\n    parentOnlyRules = ArraysUtil.join(parentOnlyRules, packages);\r\n}"
}, {
	"Path": "org.joda.time.field.FieldUtils.safeDivide",
	"Comment": "divides the dividend by divisor. rounding of result occursas per the roundingmode.",
	"Method": "long safeDivide(long dividend,long divisor,long safeDivide,long dividend,long divisor,RoundingMode roundingMode){\r\n    if (dividend == Long.MIN_VALUE && divisor == -1L) {\r\n        throw new ArithmeticException(\"Multiplication overflows a long: \" + dividend + \" / \" + divisor);\r\n    }\r\n    BigDecimal dividendBigDecimal = new BigDecimal(dividend);\r\n    BigDecimal divisorBigDecimal = new BigDecimal(divisor);\r\n    return dividendBigDecimal.divide(divisorBigDecimal, roundingMode).longValue();\r\n}"
}, {
	"Path": "org.joda.time.Period.withMinutes",
	"Comment": "returns a new period with the specified number of minutes.this period instance is immutable and unaffected by this method call.",
	"Method": "Period withMinutes(int minutes){\r\n    int[] values = getValues();\r\n    getPeriodType().setIndexedField(this, PeriodType.MINUTE_INDEX, values, minutes);\r\n    return new Period(values, getPeriodType());\r\n}"
}, {
	"Path": "org.joda.time.convert.ConverterManager.removePeriodConverter",
	"Comment": "removes a converter from the set of converters. if the converter wasnot in the set, no changes are made.",
	"Method": "PeriodConverter removePeriodConverter(PeriodConverter converter){\r\n    checkAlterPeriodConverters();\r\n    if (converter == null) {\r\n        return null;\r\n    }\r\n    PeriodConverter[] removed = new PeriodConverter[1];\r\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\r\n    return removed[0];\r\n}"
}, {
	"Path": "jodd.servlet.RequestContextListener.getRequest",
	"Comment": "returns current http servlet request. may return null\tis request was not bound to the thread.",
	"Method": "HttpServletRequest getRequest(){\r\n    return requestHolder.get();\r\n}"
}, {
	"Path": "org.joda.time.DateTime.withFields",
	"Comment": "returns a copy of this datetime with the partial set of fields replacing thosefrom this instance.for example, if the partial is a timeofday then the time fieldswould be changed in the returned instance.if the partial is null, then this is returned.",
	"Method": "DateTime withFields(ReadablePartial partial){\r\n    if (partial == null) {\r\n        return this;\r\n    }\r\n    return withMillis(getChronology().set(partial, getMillis()));\r\n}"
}, {
	"Path": "org.joda.time.base.BaseSingleFieldPeriod.getFieldType",
	"Comment": "gets the field type at the specified index.the only index supported by this period is zero which returns thefield type of this class.",
	"Method": "DurationFieldType getFieldType(DurationFieldType getFieldType,int index){\r\n    if (index != 0) {\r\n        throw new IndexOutOfBoundsException(String.valueOf(index));\r\n    }\r\n    return getFieldType();\r\n}"
}, {
	"Path": "jodd.util.StringUtil.toStringArray",
	"Comment": "converts an array object to array of strings, where every element\tof input array is converted to a string. if input is not an array,\tthe result will still be an array with one element.",
	"Method": "String[] toStringArray(Object value){\r\n    if (value == null) {\r\n        return new String[0];\r\n    }\r\n    Class<?> type = value.getClass();\r\n    if (!type.isArray()) {\r\n        return new String[] { value.toString() };\r\n    }\r\n    Class componentType = type.getComponentType();\r\n    if (componentType.isPrimitive()) {\r\n        if (componentType == int.class) {\r\n            return ArraysUtil.toStringArray((int[]) value);\r\n        } else if (componentType == long.class) {\r\n            return ArraysUtil.toStringArray((long[]) value);\r\n        } else if (componentType == double.class) {\r\n            return ArraysUtil.toStringArray((double[]) value);\r\n        } else if (componentType == float.class) {\r\n            return ArraysUtil.toStringArray((float[]) value);\r\n        } else if (componentType == boolean.class) {\r\n            return ArraysUtil.toStringArray((boolean[]) value);\r\n        } else if (componentType == short.class) {\r\n            return ArraysUtil.toStringArray((short[]) value);\r\n        } else if (componentType == byte.class) {\r\n            return ArraysUtil.toStringArray((byte[]) value);\r\n        } else {\r\n            throw new IllegalArgumentException();\r\n        }\r\n    } else {\r\n        return ArraysUtil.toStringArray((Object[]) value);\r\n    }\r\n}"
}, {
	"Path": "org.jooq.tools.StringUtils.toCamelCaseLC",
	"Comment": "convert a string to camel case starting with a lower case letter",
	"Method": "String toCamelCaseLC(String string){\r\n    return toLC(toCamelCase(string));\r\n}"
}, {
	"Path": "jodd.petite.PetiteBeans.defineParameter",
	"Comment": "defines new parameter. parameters with same name will be replaced.",
	"Method": "void defineParameter(String name,Object value){\r\n    paramManager.put(name, value);\r\n}"
}, {
	"Path": "jodd.bean.BeanUtilUtil.arrayForcedSet",
	"Comment": "sets the array element forced. if index is greater then arrays length, array will be expanded to the index.\tif speed is critical, it is better to allocate an array with proper size before using this method.",
	"Method": "void arrayForcedSet(BeanProperty bp,Object array,int index,Object value){\r\n    Class componentType = array.getClass().getComponentType();\r\n    array = ensureArraySize(bp, array, componentType, index);\r\n    value = convertType(value, componentType);\r\n    Array.set(array, index, value);\r\n}"
}, {
	"Path": "org.jooq.impl.DSL.localDateTimeSub",
	"Comment": "subtract an interval from a timestamp, given a date part.this translates into any dialect",
	"Method": "Field<LocalDateTime> localDateTimeSub(LocalDateTime timestamp,Number interval,Field<LocalDateTime> localDateTimeSub,Field<LocalDateTime> timestamp,Field<? extends Number> interval,Field<LocalDateTime> localDateTimeSub,LocalDateTime date,Number interval,DatePart datePart,Field<LocalDateTime> localDateTimeSub,LocalDateTime date,Field<? extends Number> interval,DatePart datePart,Field<LocalDateTime> localDateTimeSub,Field<LocalDateTime> date,Number interval,DatePart datePart,Field<LocalDateTime> localDateTimeSub,Field<LocalDateTime> date,Field<? extends Number> interval,DatePart datePart){\r\n    return new DateAdd<LocalDateTime>(nullSafe(date), nullSafe(interval).neg(), datePart);\r\n}"
}, {
	"Path": "jodd.introspector.ClassDescriptor.isExtendedProperties",
	"Comment": "returns true if properties in this class descriptor\tare extended and include field description.",
	"Method": "boolean isExtendedProperties(){\r\n    return extendedProperties;\r\n}"
}, {
	"Path": "org.joda.time.DateTime.property",
	"Comment": "gets the property object for the specified type, which contains many useful methods.",
	"Method": "Property property(DateTimeFieldType type){\r\n    if (type == null) {\r\n        throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\r\n    }\r\n    DateTimeField field = type.getField(getChronology());\r\n    if (field.isSupported() == false) {\r\n        throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\");\r\n    }\r\n    return new Property(this, field);\r\n}"
}, {
	"Path": "org.joda.time.DateTime.withDurationAdded",
	"Comment": "returns a copy of this datetime with the specified duration added.if the addition is zero, then this is returned.",
	"Method": "DateTime withDurationAdded(long durationToAdd,int scalar,DateTime withDurationAdded,ReadableDuration durationToAdd,int scalar){\r\n    if (durationToAdd == null || scalar == 0) {\r\n        return this;\r\n    }\r\n    return withDurationAdded(durationToAdd.getMillis(), scalar);\r\n}"
}, {
	"Path": "jodd.util.CharUtil.isReserved",
	"Comment": "indicates whether the given character is in the reserved set.",
	"Method": "boolean isReserved(char c){\r\n    return isGenericDelimiter(c) || isSubDelimiter(c);\r\n}"
}, {
	"Path": "jodd.util.cl.ExtendedURLClassLoader.isMatchingRules",
	"Comment": "returns true if class or resource name matches\tat least one package rule from the list.",
	"Method": "boolean isMatchingRules(String name,String rules){\r\n    for (String rule : rules) {\r\n        if (Wildcard.equalsOrMatch(name, rule)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.joda.time.Months.plus",
	"Comment": "returns a new instance with the specified number of months added.this instance is immutable and unaffected by this method call.",
	"Method": "Months plus(int months,Months plus,Months months){\r\n    if (months == null) {\r\n        return this;\r\n    }\r\n    return plus(months.getValue());\r\n}"
}, {
	"Path": "org.joda.time.LocalDate.toDateTimeAtCurrentTime",
	"Comment": "converts this localdate to a full datetime using the specified time zonesetting the date fields from this instance and the time fields fromthe current time.this method uses the chronology from this instance plus the time zonespecified.this method will throw an exception if the datetime that would becreated does not exist when the time zone is taken into account.this instance is immutable and unaffected by this method call.",
	"Method": "DateTime toDateTimeAtCurrentTime(DateTime toDateTimeAtCurrentTime,DateTimeZone zone){\r\n    zone = DateTimeUtils.getZone(zone);\r\n    Chronology chrono = getChronology().withZone(zone);\r\n    long instantMillis = DateTimeUtils.currentTimeMillis();\r\n    long resolved = chrono.set(this, instantMillis);\r\n    return new DateTime(resolved, chrono);\r\n}"
}, {
	"Path": "com.jayway.jsonpath.Criteria.where",
	"Comment": "static factory method to create a criteria using the provided key",
	"Method": "Criteria where(Path key,Criteria where,String key){\r\n    return new Criteria(ValueNode.toValueNode(prefixPath(key)));\r\n}"
}, {
	"Path": "org.joda.time.format.DateTimeFormatter.getParser",
	"Comment": "gets the internal parser object that performs the real parsing work.",
	"Method": "DateTimeParser getParser(){\r\n    return InternalParserDateTimeParser.of(iParser);\r\n}"
}, {
	"Path": "jodd.db.oom.mapper.DefaultResultSetMapper.readColumnValue",
	"Comment": "reads column value from result set. since this method may be called more then once for\tthe same column, it caches column values.",
	"Method": "Object readColumnValue(int colNdx,Class destinationType,Class<? extends SqlType> sqlTypeClass,int columnDbSqlType){\r\n    if (colNdx != cachedColumnNdx) {\r\n        try {\r\n            SqlType sqlType;\r\n            if (sqlTypeClass != null) {\r\n                sqlType = SqlTypeManager.get().lookupSqlType(sqlTypeClass);\r\n            } else {\r\n                sqlType = SqlTypeManager.get().lookup(destinationType);\r\n            }\r\n            if (sqlType != null) {\r\n                cachedColumnValue = sqlType.readValue(resultSet, colNdx + 1, destinationType, columnDbSqlType);\r\n            } else {\r\n                cachedColumnValue = resultSet.getObject(colNdx + 1);\r\n                cachedColumnValue = TypeConverterManager.get().convertType(cachedColumnValue, destinationType);\r\n            }\r\n        } catch (SQLException sex) {\r\n            throw new DbOomException(dbOomQuery, \"Invalid value for column #\" + (colNdx + 1), sex);\r\n        }\r\n        cachedColumnNdx = colNdx;\r\n    }\r\n    return cachedColumnValue;\r\n}"
}, {
	"Path": "org.apache.jorphan.test.AllTests.main",
	"Comment": "starts a run through all unit tests found in the specified classpaths.the first argument should be a list of paths to search. the secondargument is optional and specifies a properties file used to initializelogging. the third argument is also optional, and specifies a class thatimplements the unittestmanager interface. this provides a means ofinitializing your application with a configuration file prior to thestart of any unit tests.",
	"Method": "void main(String[] args){\r\n    if (args.length < 1) {\r\n        System.out.println(\"You must specify a comma-delimited list of paths to search \" + \"for unit tests\");\r\n        return;\r\n    }\r\n    String home = new File(System.getProperty(\"user.dir\")).getParent();\r\n    System.out.println(\"Setting JMeterHome: \" + home);\r\n    JMeterUtils.setJMeterHome(home);\r\n    initializeManager(args);\r\n    log.info(\"JMeterVersion={}\", JMeterUtils.getJMeterVersion());\r\n    System.out.println(\"JMeterVersion=\" + JMeterUtils.getJMeterVersion());\r\n    logprop(\"java.version\", true);\r\n    logprop(\"java.vm.name\");\r\n    logprop(\"java.vendor\");\r\n    logprop(\"java.home\", true);\r\n    logprop(\"file.encoding\", true);\r\n    System.out.println(\"default encoding=\" + Charset.defaultCharset());\r\n    log.info(\"default encoding={}\", Charset.defaultCharset());\r\n    logprop(\"user.home\");\r\n    logprop(\"user.dir\", true);\r\n    logprop(\"user.language\");\r\n    logprop(\"user.region\");\r\n    logprop(\"user.country\");\r\n    logprop(\"user.variant\");\r\n    log.info(\"Locale={}\", Locale.getDefault());\r\n    System.out.println(\"Locale=\" + Locale.getDefault());\r\n    logprop(\"os.name\", true);\r\n    logprop(\"os.version\", true);\r\n    logprop(\"os.arch\");\r\n    logprop(\"java.class.version\");\r\n    String cp = System.getProperty(\"java.class.path\");\r\n    String[] cpe = JOrphanUtils.split(cp, java.io.File.pathSeparator);\r\n    StringBuilder sb = new StringBuilder(3000);\r\n    sb.append(\"java.class.path=\");\r\n    for (String path : cpe) {\r\n        sb.append(\"\\n\");\r\n        sb.append(path);\r\n        if (new File(path).exists()) {\r\n            sb.append(\" - OK\");\r\n        } else {\r\n            sb.append(\" - ??\");\r\n        }\r\n    }\r\n    log.info(sb.toString());\r\n    try {\r\n        int maxKeyLen = Cipher.getMaxAllowedKeyLength(\"AES\");\r\n        System.out.println(\"JCE max key length = \" + maxKeyLen);\r\n    } catch (NoSuchAlgorithmException e) {\r\n        log.warn(e.getLocalizedMessage());\r\n    }\r\n    System.out.println(\"+++++++++++\");\r\n    logprop(\"java.awt.headless\", true);\r\n    logprop(\"java.awt.graphicsenv\", true);\r\n    System.out.println(\"------------\");\r\n    JUnitCore jUnitCore = new JUnitCore();\r\n    jUnitCore.addListener(new TextListener(System.out));\r\n    jUnitCore.addListener(new TimePrinter());\r\n    System.out.println(\"Searching junit tests in : \" + args[0]);\r\n    try {\r\n        List<String> tests = findJMeterJUnitTests(args[0]);\r\n        List<Class<?>> classes = asClasses(tests);\r\n        Result parallelResults = jUnitCore.run(getParallelTests(classes));\r\n        Result serialResults = jUnitCore.run(getSerialTests(classes));\r\n        boolean allTestsSuccessful = parallelResults.wasSuccessful() && serialResults.wasSuccessful();\r\n        System.exit(allTestsSuccessful ? 0 : 1);\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n        System.exit(1);\r\n    }\r\n}"
}, {
	"Path": "jodd.jerry.Jerry.filter",
	"Comment": "reduces the set of matched elements to those that match the selector.",
	"Method": "Jerry filter(String cssSelectors,Jerry filter,JerryFunction jerryFunction){\r\n    List<Node> result = new NodeList(nodes.length);\r\n    for (int i = 0; i < nodes.length; i++) {\r\n        Node node = nodes[i];\r\n        Node parentNode = node.getParentNode();\r\n        if (parentNode == null) {\r\n            continue;\r\n        }\r\n        Jerry $this = new Jerry(this, node);\r\n        boolean accept = jerryFunction.onNode($this, i);\r\n        if (accept) {\r\n            result.add(node);\r\n        }\r\n    }\r\n    return new Jerry(this, result);\r\n}"
}, {
	"Path": "org.joda.time.DateMidnight.withWeekyear",
	"Comment": "returns a copy of this date with the weekyear field updated.the weekyear is the year that matches with the weekofweekyear field.in the standard iso8601 week algorithm, the first week of the yearis that in which at least 4 days are in the year. as a result of thisdefinition, day 1 of the first week may be in the previous year.the weekyear allows you to query the effective year for that day.datemidnight is immutable, so there are no set methods.instead, this method returns a new instance with the value ofweekyear changed.",
	"Method": "DateMidnight withWeekyear(int weekyear){\r\n    return withMillis(getChronology().weekyear().set(getMillis(), weekyear));\r\n}"
}, {
	"Path": "jodd.servlet.filter.CharArrayResponseWrapper.toString",
	"Comment": "get a string representation of the entire buffer.\tdo not call this method multiple times on the same wrapper as\tnew string is created every time.",
	"Method": "String toString(){\r\n    if (writer == null) {\r\n        return StringPool.EMPTY;\r\n    }\r\n    return writer.toString();\r\n}"
}, {
	"Path": "org.joda.time.DateMidnight.withFields",
	"Comment": "returns a copy of this date with the partial set of fields replacing thosefrom this instance.for example, if the partial is a localdate then the date fieldswould be changed in the returned instance.if the partial is null, then this is returned.",
	"Method": "DateMidnight withFields(ReadablePartial partial){\r\n    if (partial == null) {\r\n        return this;\r\n    }\r\n    return withMillis(getChronology().set(partial, getMillis()));\r\n}"
}, {
	"Path": "jodd.io.upload.MultipartStreamParser.getFiles",
	"Comment": "returns all uploaded files the given request parameter has.",
	"Method": "FileUpload[] getFiles(String paramName){\r\n    if (requestFiles == null) {\r\n        return null;\r\n    }\r\n    return requestFiles.get(paramName);\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.ForcedType.getExpressions",
	"Comment": "the same as expression. this is kept for backwards compatibility reasons.",
	"Method": "String getExpressions(){\r\n    return expressions;\r\n}"
}, {
	"Path": "com.jayway.jsonpath.Criteria.contains",
	"Comment": "the contains operator asserts that the provided object is containedin the result. the object that should contain the input can be either an object or a string.",
	"Method": "Criteria contains(Object o){\r\n    this.criteriaType = RelationalOperator.CONTAINS;\r\n    this.right = ValueNode.toValueNode(o);\r\n    return this;\r\n}"
}, {
	"Path": "jodd.proxetta.asm.HistoryMethodAdapter.getArgumentIndex",
	"Comment": "returns argument index from the history.\tmust pop value from the stack after the execution.",
	"Method": "int getArgumentIndex(){\r\n    if (!isPrevious) {\r\n        throw new ProxettaException(\"Unexpected previous instruction type used for setting argument index\");\r\n    }\r\n    int argIndex;\r\n    switch(opcode) {\r\n        case ICONST_0:\r\n            argIndex = 0;\r\n            break;\r\n        case ICONST_1:\r\n            argIndex = 1;\r\n            break;\r\n        case ICONST_2:\r\n            argIndex = 2;\r\n            break;\r\n        case ICONST_3:\r\n            argIndex = 3;\r\n            break;\r\n        case ICONST_4:\r\n            argIndex = 4;\r\n            break;\r\n        case ICONST_5:\r\n            argIndex = 5;\r\n            break;\r\n        case BIPUSH:\r\n        case SIPUSH:\r\n            argIndex = operand;\r\n            break;\r\n        default:\r\n            throw new ProxettaException(\"Unexpected previous instruction used for setting argument index\");\r\n    }\r\n    return argIndex;\r\n}"
}, {
	"Path": "jodd.db.oom.sqlgen.DbSqlBuilder.matchAll",
	"Comment": "creates condition part of the query for all columns, including the null values.",
	"Method": "DbSqlBuilder matchAll(String tableRef,Object value,DbSqlBuilder matchAll,String tableRef,String objectRef){\r\n    return addChunk(new MatchChunk(entityManager, tableRef, objectRef, SqlChunk.COLS_ALL));\r\n}"
}, {
	"Path": "org.joda.time.base.BasePeriod.checkPeriodType",
	"Comment": "validates a period type, converting nulls to a default value andchecking the type is suitable for this instance.",
	"Method": "PeriodType checkPeriodType(PeriodType type){\r\n    return DateTimeUtils.getPeriodType(type);\r\n}"
}, {
	"Path": "org.joda.time.Weeks.toStandardDays",
	"Comment": "converts this period in weeks to a period in days assuming a7 day week.this method allows you to convert between different types of period.however to achieve this it makes the assumption that all weeks are7 days long.this may not be true for some unusual chronologies. however, it is includedas it is a useful operation for many applications and business rules.",
	"Method": "Days toStandardDays(){\r\n    return Days.days(FieldUtils.safeMultiply(getValue(), DateTimeConstants.DAYS_PER_WEEK));\r\n}"
}, {
	"Path": "jodd.introspector.FieldDescriptor.getRawComponentType",
	"Comment": "returns fields raw component type. returns null\tif field has no component type.",
	"Method": "Class getRawComponentType(){\r\n    return rawComponentType;\r\n}"
}, {
	"Path": "jodd.db.oom.sqlgen.chunks.SqlChunk.lookupName",
	"Comment": "lookups for entity name and throws exception if entity name not found.",
	"Method": "DbEntityDescriptor lookupName(String entityName){\r\n    DbEntityDescriptor ded = dbEntityManager.lookupName(entityName);\r\n    if (ded == null) {\r\n        throw new DbSqlBuilderException(\"Entity name not registered: \" + entityName);\r\n    }\r\n    return ded;\r\n}"
}, {
	"Path": "jodd.servlet.wrapper.BufferResponseWrapper.disableBuffering",
	"Comment": "disables buffering by transferring the output to original destinations.",
	"Method": "void disableBuffering(){\r\n    if (buffer == null) {\r\n        return;\r\n    }\r\n    buffer = null;\r\n}"
}, {
	"Path": "jodd.http.HttpMultiMap.get",
	"Comment": "returns the first value from the map associated with the name.\treturns null if name does not exist or\tif associated value is null.",
	"Method": "V get(String name){\r\n    Map.Entry<String, V> entry = getEntry(name);\r\n    if (entry == null) {\r\n        return null;\r\n    }\r\n    return entry.getValue();\r\n}"
}, {
	"Path": "jodd.crypt.DigestEngine.digest",
	"Comment": "returns digest of a file. implementations may not read the whole\tfile into the memory.",
	"Method": "byte[] digest(byte[] byteArray,byte[] digest,File file,byte[] digest,byte[] input,byte[] digest,String input,byte[] digest,File file){\r\n    return digest(StringUtil.getBytes(input));\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.centuryOfEra",
	"Comment": "get the century of era property which provides access to advanced functionality.",
	"Method": "Property centuryOfEra(){\r\n    return new Property(this, getChronology().centuryOfEra());\r\n}"
}, {
	"Path": "jodd.petite.PetiteConfig.resolveWiringMode",
	"Comment": "resolves wiring mode by checking if default and null values.",
	"Method": "WiringMode resolveWiringMode(WiringMode wiringMode){\r\n    if ((wiringMode == null) || (wiringMode == WiringMode.DEFAULT)) {\r\n        wiringMode = defaultWiringMode;\r\n    }\r\n    return wiringMode;\r\n}"
}, {
	"Path": "org.joda.time.base.BasePartial.setValues",
	"Comment": "sets the values of all fields.in version 2.0 and later, this method copies the array into the original.this is because the instance variable has been changed to be final to satisfy the java memory model.this only impacts subclasses that are mutable.",
	"Method": "void setValues(int[] values){\r\n    getChronology().validate(this, values);\r\n    System.arraycopy(values, 0, iValues, 0, iValues.length);\r\n}"
}, {
	"Path": "org.joda.time.DateMidnight.yearOfCentury",
	"Comment": "get the year of century property which provides access to advanced functionality.",
	"Method": "Property yearOfCentury(){\r\n    return new Property(this, getChronology().yearOfCentury());\r\n}"
}, {
	"Path": "org.joda.time.DateTime.withWeekyear",
	"Comment": "returns a copy of this datetime with the weekyear field updated.the weekyear is the year that matches with the weekofweekyear field.in the standard iso8601 week algorithm, the first week of the yearis that in which at least 4 days are in the year. as a result of thisdefinition, day 1 of the first week may be in the previous year.the weekyear allows you to query the effective year for that day.datetime is immutable, so there are no set methods.instead, this method returns a new instance with the value ofweekyear changed.",
	"Method": "DateTime withWeekyear(int weekyear){\r\n    return withMillis(getChronology().weekyear().set(getMillis(), weekyear));\r\n}"
}, {
	"Path": "jodd.crypt.BCrypt.crypt_raw",
	"Comment": "perform the central password hashing step in the\tbcrypt scheme.",
	"Method": "byte[] crypt_raw(byte[] password,byte[] salt,int log_rounds,int[] cdata){\r\n    int rounds, i, j;\r\n    int clen = cdata.length;\r\n    byte[] ret;\r\n    if (log_rounds < 4 || log_rounds > 30) {\r\n        throw new IllegalArgumentException(\"Bad number of rounds\");\r\n    }\r\n    rounds = 1 << log_rounds;\r\n    if (salt.length != BCRYPT_SALT_LEN) {\r\n        throw new IllegalArgumentException(\"Bad salt length\");\r\n    }\r\n    init_key();\r\n    ekskey(salt, password);\r\n    for (i = 0; i != rounds; i++) {\r\n        key(password);\r\n        key(salt);\r\n    }\r\n    for (i = 0; i < 64; i++) {\r\n        for (j = 0; j < (clen >> 1); j++) {\r\n            encipher(cdata, j << 1);\r\n        }\r\n    }\r\n    ret = new byte[clen * 4];\r\n    for (i = 0, j = 0; i < clen; i++) {\r\n        ret[j++] = (byte) ((cdata[i] >> 24) & 0xff);\r\n        ret[j++] = (byte) ((cdata[i] >> 16) & 0xff);\r\n        ret[j++] = (byte) ((cdata[i] >> 8) & 0xff);\r\n        ret[j++] = (byte) (cdata[i] & 0xff);\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "jodd.util.CollectionUtil.asEnumeration",
	"Comment": "adapt the specified iterator to the\tenumeration interface.",
	"Method": "Enumeration<E> asEnumeration(Iterator<E> iter){\r\n    return new Enumeration<E>() {\r\n        @Override\r\n        public boolean hasMoreElements() {\r\n            return iter.hasNext();\r\n        }\r\n        @Override\r\n        public E nextElement() {\r\n            return iter.next();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "jodd.util.CollectionUtil.asEnumeration",
	"Comment": "adapt the specified iterator to the\tenumeration interface.",
	"Method": "Enumeration<E> asEnumeration(Iterator<E> iter){\r\n    return iter.hasNext();\r\n}"
}, {
	"Path": "jodd.util.CollectionUtil.asEnumeration",
	"Comment": "adapt the specified iterator to the\tenumeration interface.",
	"Method": "Enumeration<E> asEnumeration(Iterator<E> iter){\r\n    return iter.next();\r\n}"
}, {
	"Path": "jodd.db.oom.dao.GenericDao.updateProperty",
	"Comment": "updates property in the database by storing the current property value.",
	"Method": "E updateProperty(E entity,String name,Object newValue,E updateProperty,E entity,String name){\r\n    Object value = BeanUtil.declared.getProperty(entity, name);\r\n    query(dbOom.entities().updateColumn(entity, name, value)).autoClose().executeUpdate();\r\n    return entity;\r\n}"
}, {
	"Path": "jodd.db.oom.DbEntityManager.setPrimitiveEntitiesPrefixes",
	"Comment": "specifies array of class name prefixes that will be mapped directly to column.",
	"Method": "void setPrimitiveEntitiesPrefixes(String primitiveEntitiesPrefixes){\r\n    this.primitiveEntitiesPrefixes = primitiveEntitiesPrefixes;\r\n}"
}, {
	"Path": "jodd.cache.FIFOCache.pruneCache",
	"Comment": "prune expired objects and, if cache is still full, the first one.",
	"Method": "int pruneCache(){\r\n    int count = 0;\r\n    CacheObject<K, V> first = null;\r\n    Iterator<CacheObject<K, V>> values = cacheMap.values().iterator();\r\n    while (values.hasNext()) {\r\n        CacheObject<K, V> co = values.next();\r\n        if (co.isExpired()) {\r\n            values.remove();\r\n            onRemove(co.key, co.cachedObject);\r\n            count++;\r\n        }\r\n        if (first == null) {\r\n            first = co;\r\n        }\r\n    }\r\n    if (isFull()) {\r\n        if (first != null) {\r\n            cacheMap.remove(first.key);\r\n            onRemove(first.key, first.cachedObject);\r\n            count++;\r\n        }\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.toLocalDate",
	"Comment": "converts this object to a localdate with the same date and chronology.",
	"Method": "LocalDate toLocalDate(){\r\n    return new LocalDate(getLocalMillis(), getChronology());\r\n}"
}, {
	"Path": "jodd.exception.ExceptionUtil.rollupSqlExceptions",
	"Comment": "rolls up sql exceptions by taking each proceeding exceptionand making it a child of the previous using the setnextexceptionmethod of sqlexception.",
	"Method": "SQLException rollupSqlExceptions(Collection<SQLException> exceptions){\r\n    SQLException parent = null;\r\n    for (SQLException exception : exceptions) {\r\n        if (parent != null) {\r\n            exception.setNextException(parent);\r\n        }\r\n        parent = exception;\r\n    }\r\n    return parent;\r\n}"
}, {
	"Path": "jodd.proxetta.asm.InvokeReplacerMethodAdapter.visitMethodInsn",
	"Comment": "invoked on invokevirtual, invokespecial, invokestatic, invokeinterface or invokedynamic.",
	"Method": "void visitMethodInsn(int opcode,String owner,String name,String desc,boolean isInterface){\r\n    if ((newInvokeReplacer != null) && (opcode == INVOKESPECIAL)) {\r\n        String exOwner = owner;\r\n        owner = newInvokeReplacer.getOwner();\r\n        name = newInvokeReplacer.getMethodName();\r\n        desc = changeReturnType(desc, 'L' + exOwner + ';');\r\n        super.visitMethodInsn(INVOKESTATIC, owner, name, desc, isInterface);\r\n        newInvokeReplacer = null;\r\n        return;\r\n    }\r\n    InvokeInfo invokeInfo = new InvokeInfo(owner, name, desc);\r\n    if (methodInfo.getMethodName().equals(INIT)) {\r\n        if ((!firstSuperCtorInitCalled) && (opcode == INVOKESPECIAL) && name.equals(INIT) && owner.equals(wd.nextSupername)) {\r\n            firstSuperCtorInitCalled = true;\r\n            owner = wd.superReference;\r\n            super.visitMethodInsn(opcode, owner, name, desc, isInterface);\r\n            return;\r\n        }\r\n    }\r\n    if ((opcode == INVOKESPECIAL) && (owner.equals(wd.nextSupername) && (!name.equals(INIT)))) {\r\n        throw new ProxettaException(\"Super call detected in class \" + methodInfo.getClassname() + \" method: \" + methodInfo.getSignature() + \"\\nProxetta can't handle super calls due to VM limitations.\");\r\n    }\r\n    InvokeReplacer ir = null;\r\n    for (InvokeAspect aspect : aspects) {\r\n        ir = aspect.pointcut(invokeInfo);\r\n        if (ir != null) {\r\n            break;\r\n        }\r\n    }\r\n    if (ir == null || ir.isNone()) {\r\n        if (ProxettaAsmUtil.isCreateArgumentsArrayMethod(name, desc)) {\r\n            ProxyTargetReplacement.createArgumentsArray(mv, methodInfo);\r\n            wd.proxyApplied = true;\r\n            return;\r\n        }\r\n        if (ProxettaAsmUtil.isCreateArgumentsClassArrayMethod(name, desc)) {\r\n            ProxyTargetReplacement.createArgumentsClassArray(mv, methodInfo);\r\n            wd.proxyApplied = true;\r\n            return;\r\n        }\r\n        if (ProxettaAsmUtil.isArgumentsCountMethod(name, desc)) {\r\n            ProxyTargetReplacement.argumentsCount(mv, methodInfo);\r\n            wd.proxyApplied = true;\r\n            return;\r\n        }\r\n        if (ProxettaAsmUtil.isTargetMethodNameMethod(name, desc)) {\r\n            ProxyTargetReplacement.targetMethodName(mv, methodInfo);\r\n            wd.proxyApplied = true;\r\n            return;\r\n        }\r\n        if (ProxettaAsmUtil.isTargetMethodDescriptionMethod(name, desc)) {\r\n            ProxyTargetReplacement.targetMethodDescription(mv, methodInfo);\r\n            wd.proxyApplied = true;\r\n            return;\r\n        }\r\n        if (ProxettaAsmUtil.isTargetMethodSignatureMethod(name, desc)) {\r\n            ProxyTargetReplacement.targetMethodSignature(mv, methodInfo);\r\n            wd.proxyApplied = true;\r\n            return;\r\n        }\r\n        if (ProxettaAsmUtil.isReturnTypeMethod(name, desc)) {\r\n            ProxyTargetReplacement.returnType(mv, methodInfo);\r\n            wd.proxyApplied = true;\r\n            return;\r\n        }\r\n        if (ProxettaAsmUtil.isTargetClassMethod(name, desc)) {\r\n            ProxyTargetReplacement.targetClass(mv, methodInfo);\r\n            wd.proxyApplied = true;\r\n            return;\r\n        }\r\n        if (isArgumentTypeMethod(name, desc)) {\r\n            int argIndex = this.getArgumentIndex();\r\n            ProxyTargetReplacement.argumentType(mv, methodInfo, argIndex);\r\n            wd.proxyApplied = true;\r\n            return;\r\n        }\r\n        if (isArgumentMethod(name, desc)) {\r\n            int argIndex = this.getArgumentIndex();\r\n            ProxyTargetReplacement.argument(mv, methodInfo, argIndex);\r\n            wd.proxyApplied = true;\r\n            return;\r\n        }\r\n        if (isInfoMethod(name, desc)) {\r\n            proxyInfoRequested = true;\r\n            wd.proxyApplied = true;\r\n            return;\r\n        }\r\n        if (isTargetMethodAnnotationMethod(name, desc)) {\r\n            String[] args = getLastTwoStringArguments();\r\n            mv.visitInsn(POP);\r\n            mv.visitInsn(POP);\r\n            ProxyTargetReplacement.targetMethodAnnotation(mv, methodInfo, args);\r\n            wd.proxyApplied = true;\r\n            return;\r\n        }\r\n        if (isTargetClassAnnotationMethod(name, desc)) {\r\n            String[] args = getLastTwoStringArguments();\r\n            mv.visitInsn(POP);\r\n            mv.visitInsn(POP);\r\n            ProxyTargetReplacement.targetClassAnnotation(mv, methodInfo.getClassInfo(), args);\r\n            wd.proxyApplied = true;\r\n            return;\r\n        }\r\n        super.visitMethodInsn(opcode, owner, name, desc, isInterface);\r\n        return;\r\n    }\r\n    wd.proxyApplied = true;\r\n    String exOwner = owner;\r\n    owner = ir.getOwner();\r\n    name = ir.getMethodName();\r\n    switch(opcode) {\r\n        case INVOKEINTERFACE:\r\n            desc = prependArgument(desc, AsmUtil.L_SIGNATURE_JAVA_LANG_OBJECT);\r\n            break;\r\n        case INVOKEVIRTUAL:\r\n            desc = prependArgument(desc, AsmUtil.L_SIGNATURE_JAVA_LANG_OBJECT);\r\n            break;\r\n        case INVOKESTATIC:\r\n            break;\r\n        default:\r\n            throw new ProxettaException(\"Unsupported opcode: \" + opcode);\r\n    }\r\n    if (ir.isPassOwnerName()) {\r\n        desc = appendArgument(desc, AsmUtil.L_SIGNATURE_JAVA_LANG_STRING);\r\n        super.visitLdcInsn(exOwner);\r\n    }\r\n    if (ir.isPassMethodName()) {\r\n        desc = appendArgument(desc, AsmUtil.L_SIGNATURE_JAVA_LANG_STRING);\r\n        super.visitLdcInsn(methodInfo.getMethodName());\r\n    }\r\n    if (ir.isPassMethodSignature()) {\r\n        desc = appendArgument(desc, AsmUtil.L_SIGNATURE_JAVA_LANG_STRING);\r\n        super.visitLdcInsn(methodInfo.getSignature());\r\n    }\r\n    if (ir.isPassTargetClass()) {\r\n        desc = appendArgument(desc, AsmUtil.L_SIGNATURE_JAVA_LANG_CLASS);\r\n        super.mv.visitLdcInsn(Type.getType('L' + wd.superReference + ';'));\r\n    }\r\n    if (ir.isPassThis()) {\r\n        desc = appendArgument(desc, AsmUtil.L_SIGNATURE_JAVA_LANG_OBJECT);\r\n        super.mv.visitVarInsn(ALOAD, 0);\r\n    }\r\n    super.visitMethodInsn(INVOKESTATIC, owner, name, desc, false);\r\n}"
}, {
	"Path": "jodd.http.HttpBase.capitalizeHeaderKeys",
	"Comment": "returns whether header keys should be strict or not, when they are\tmodified by changing them to pascalcase.",
	"Method": "boolean capitalizeHeaderKeys(T capitalizeHeaderKeys,boolean capitalizeHeaderKeys){\r\n    this.capitalizeHeaderKeys = capitalizeHeaderKeys;\r\n    return _this();\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractInstant.toDate",
	"Comment": "get the date time as a java.util.date.the date object created has exactly the same millisecondinstant as this object.",
	"Method": "Date toDate(){\r\n    return new Date(getMillis());\r\n}"
}, {
	"Path": "org.joda.time.chrono.BasicDayOfYearDateTimeField.get",
	"Comment": "get the day of the year component of the specified time instant.",
	"Method": "int get(long instant){\r\n    return iChronology.getDayOfYear(instant);\r\n}"
}, {
	"Path": "org.jooq.JSONFormat.header",
	"Comment": "whether to emit a header row with column names, defaulting totrue.",
	"Method": "JSONFormat header(boolean newHeader,boolean header){\r\n    return header;\r\n}"
}, {
	"Path": "jodd.db.DbQueryBase.initializeJdbc",
	"Comment": "performs jdbc initialization of the query. obtains connection, parses the sql query string\tand creates statements. initialization is performed only once, when switching to initialized state.",
	"Method": "void initializeJdbc(){\r\n    if (connection == null) {\r\n        initSession(session);\r\n        connection = session.getConnection();\r\n    }\r\n    this.query = new DbQueryParser(sqlString);\r\n    if (query.callable) {\r\n        try {\r\n            if (debug) {\r\n                if (holdability != QueryHoldability.DEFAULT) {\r\n                    callableStatement = LogabbleStatementFactory.callable().prepareCall(connection, query.sql, type.value(), concurrencyType.value(), holdability.value());\r\n                } else {\r\n                    callableStatement = LogabbleStatementFactory.callable().prepareCall(connection, query.sql, type.value(), concurrencyType.value());\r\n                }\r\n            } else {\r\n                if (holdability != QueryHoldability.DEFAULT) {\r\n                    callableStatement = connection.prepareCall(query.sql, type.value(), concurrencyType.value(), holdability.value());\r\n                } else {\r\n                    callableStatement = connection.prepareCall(query.sql, type.value(), concurrencyType.value());\r\n                }\r\n            }\r\n        } catch (SQLException sex) {\r\n            throw new DbSqlException(this, \"Error creating callable statement\", sex);\r\n        }\r\n        preparedStatement = callableStatement;\r\n        statement = callableStatement;\r\n        return;\r\n    }\r\n    if (query.prepared || forcePreparedStatement) {\r\n        try {\r\n            if (debug) {\r\n                if (generatedColumns != null) {\r\n                    if (generatedColumns.length == 0) {\r\n                        preparedStatement = LogabbleStatementFactory.prepared().create(connection, query.sql, Statement.RETURN_GENERATED_KEYS);\r\n                    } else {\r\n                        preparedStatement = LogabbleStatementFactory.prepared().create(connection, query.sql, generatedColumns);\r\n                    }\r\n                } else {\r\n                    if (holdability != QueryHoldability.DEFAULT) {\r\n                        preparedStatement = LogabbleStatementFactory.prepared().create(connection, query.sql, type.value(), concurrencyType.value(), holdability.value());\r\n                    } else {\r\n                        preparedStatement = LogabbleStatementFactory.prepared().create(connection, query.sql, type.value(), concurrencyType.value());\r\n                    }\r\n                }\r\n            } else {\r\n                if (generatedColumns != null) {\r\n                    if (generatedColumns.length == 0) {\r\n                        preparedStatement = connection.prepareStatement(query.sql, Statement.RETURN_GENERATED_KEYS);\r\n                    } else {\r\n                        preparedStatement = connection.prepareStatement(query.sql, generatedColumns);\r\n                    }\r\n                } else {\r\n                    if (holdability != QueryHoldability.DEFAULT) {\r\n                        preparedStatement = connection.prepareStatement(query.sql, type.value(), concurrencyType.value(), holdability.value());\r\n                    } else {\r\n                        preparedStatement = connection.prepareStatement(query.sql, type.value(), concurrencyType.value());\r\n                    }\r\n                }\r\n            }\r\n        } catch (SQLException sex) {\r\n            throw new DbSqlException(this, \"Error creating prepared statement\", sex);\r\n        }\r\n        statement = preparedStatement;\r\n        return;\r\n    }\r\n    try {\r\n        if (holdability != QueryHoldability.DEFAULT) {\r\n            statement = connection.createStatement(type.value(), concurrencyType.value(), holdability.value());\r\n        } else {\r\n            statement = connection.createStatement(type.value(), concurrencyType.value());\r\n        }\r\n    } catch (SQLException sex) {\r\n        throw new DbSqlException(this, \"Error creating statement\", sex);\r\n    }\r\n}"
}, {
	"Path": "org.json.JSONArray.optInt",
	"Comment": "get the optional int value associated with an index. the defaultvalue isreturned if there is no value for the index, or if the value is not anumber and cannot be converted to a number.",
	"Method": "int optInt(int index,int optInt,int index,int defaultValue){\r\n    final Number val = this.optNumber(index, null);\r\n    if (val == null) {\r\n        return defaultValue;\r\n    }\r\n    return val.intValue();\r\n}"
}, {
	"Path": "org.joda.time.DateTime.withYearOfEra",
	"Comment": "returns a copy of this datetime with the year of era field updated.datetime is immutable, so there are no set methods.instead, this method returns a new instance with the value ofyear of era changed.",
	"Method": "DateTime withYearOfEra(int yearOfEra){\r\n    return withMillis(getChronology().yearOfEra().set(getMillis(), yearOfEra));\r\n}"
}, {
	"Path": "org.joda.time.convert.ConverterManager.removeIntervalConverter",
	"Comment": "removes a converter from the set of converters. if the converter wasnot in the set, no changes are made.",
	"Method": "IntervalConverter removeIntervalConverter(IntervalConverter converter){\r\n    checkAlterIntervalConverters();\r\n    if (converter == null) {\r\n        return null;\r\n    }\r\n    IntervalConverter[] removed = new IntervalConverter[1];\r\n    iIntervalConverters = iIntervalConverters.remove(converter, removed);\r\n    return removed[0];\r\n}"
}, {
	"Path": "org.joda.time.DateTime.withYearOfCentury",
	"Comment": "returns a copy of this datetime with the year of century field updated.datetime is immutable, so there are no set methods.instead, this method returns a new instance with the value ofyear of century changed.",
	"Method": "DateTime withYearOfCentury(int yearOfCentury){\r\n    return withMillis(getChronology().yearOfCentury().set(getMillis(), yearOfCentury));\r\n}"
}, {
	"Path": "jodd.htmlstapler.HtmlStaplerBundlesManager.registerBundle",
	"Comment": "registers new bundle that consist of provided list of source paths.\treturns the real bundle id, as provided one is just a temporary bundle id.",
	"Method": "String registerBundle(String contextPath,String actionPath,String tempBundleId,String bundleContentType,List<String> sources){\r\n    if (tempBundleId == null || sources.isEmpty()) {\r\n        if (strategy == Strategy.ACTION_MANAGED) {\r\n            actionBundles.put(actionPath, StringPool.EMPTY);\r\n        }\r\n        return null;\r\n    }\r\n    String[] sourcesArray = sources.toArray(new String[0]);\r\n    for (int i = 0, sourcesArrayLength = sourcesArray.length; i < sourcesArrayLength; i++) {\r\n        sourcesArray[i] = sourcesArray[i].trim().toLowerCase();\r\n    }\r\n    if (sortResources) {\r\n        Arrays.sort(sourcesArray);\r\n    }\r\n    StringBand sb = new StringBand(sourcesArray.length);\r\n    for (String src : sourcesArray) {\r\n        sb.append(src);\r\n    }\r\n    String sourcesString = sb.toString();\r\n    String bundleId = createDigest(sourcesString);\r\n    bundleId += '.' + bundleContentType;\r\n    if (strategy == Strategy.ACTION_MANAGED) {\r\n        actionBundles.put(actionPath, bundleId);\r\n        mirrors.put(tempBundleId, bundleId);\r\n    }\r\n    try {\r\n        createBundle(contextPath, actionPath, bundleId, sources);\r\n    } catch (IOException ioex) {\r\n        throw new HtmlStaplerException(\"Can't create bundle\", ioex);\r\n    }\r\n    return bundleId;\r\n}"
}, {
	"Path": "org.joda.time.Days.daysIn",
	"Comment": "creates a days representing the number of whole daysin the specified interval. this method correctly handles any daylightsavings time changes that may occur during the interval.",
	"Method": "Days daysIn(ReadableInterval interval){\r\n    if (interval == null) {\r\n        return Days.ZERO;\r\n    }\r\n    int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.days());\r\n    return Days.days(amount);\r\n}"
}, {
	"Path": "jodd.joy.madvoc.AppAction.violations",
	"Comment": "returns validation violations or null if validation was successful.",
	"Method": "List<Violation> violations(){\r\n    if (vtor == null) {\r\n        return null;\r\n    }\r\n    return vtor.getViolations();\r\n}"
}, {
	"Path": "org.joda.time.DurationFieldType.isSupported",
	"Comment": "checks whether this field supported in the given chronology.",
	"Method": "boolean isSupported(Chronology chronology){\r\n    return getField(chronology).isSupported();\r\n}"
}, {
	"Path": "jodd.lagarto.dom.HtmlCCommentExpressionMatcher.match",
	"Comment": "matches conditional comment expression with current mode.\treturns true it conditional comment expression is positive,\totherwise returns false.",
	"Method": "boolean match(float ieVersion,String expression){\r\n    expression = StringUtil.removeChars(expression, \"()\");\r\n    expression = expression.substring(3);\r\n    String[] andChunks = StringUtil.splitc(expression, '&');\r\n    boolean valid = true;\r\n    for (String andChunk : andChunks) {\r\n        String[] orChunks = StringUtil.splitc(andChunk, '|');\r\n        boolean innerValid = false;\r\n        for (String orChunk : orChunks) {\r\n            orChunk = orChunk.trim();\r\n            if (orChunk.startsWith(\"IE \")) {\r\n                String value = orChunk.substring(3);\r\n                float number = Float.parseFloat(value);\r\n                if (versionToCompare(ieVersion, number) == number) {\r\n                    innerValid = true;\r\n                    break;\r\n                }\r\n                continue;\r\n            }\r\n            if (orChunk.startsWith(\"!IE \")) {\r\n                String value = orChunk.substring(4);\r\n                float number = Float.parseFloat(value);\r\n                if (versionToCompare(ieVersion, number) != number) {\r\n                    innerValid = true;\r\n                    break;\r\n                }\r\n                continue;\r\n            }\r\n            if (orChunk.startsWith(\"lt IE \")) {\r\n                String value = orChunk.substring(6);\r\n                float number = Float.parseFloat(value);\r\n                if (ieVersion < number) {\r\n                    innerValid = true;\r\n                    break;\r\n                }\r\n                continue;\r\n            }\r\n            if (orChunk.startsWith(\"lte IE \")) {\r\n                String value = orChunk.substring(7);\r\n                float number = Float.parseFloat(value);\r\n                if (versionToCompare(ieVersion, number) <= number) {\r\n                    innerValid = true;\r\n                    break;\r\n                }\r\n                continue;\r\n            }\r\n            if (orChunk.startsWith(\"gt IE \")) {\r\n                String value = orChunk.substring(6);\r\n                float number = Float.parseFloat(value);\r\n                if (versionToCompare(ieVersion, number) > number) {\r\n                    innerValid = true;\r\n                    break;\r\n                }\r\n                continue;\r\n            }\r\n            if (orChunk.startsWith(\"gte IE \")) {\r\n                String value = orChunk.substring(7);\r\n                float number = Float.parseFloat(value);\r\n                if (ieVersion >= number) {\r\n                    innerValid = true;\r\n                    break;\r\n                }\r\n                continue;\r\n            }\r\n        }\r\n        valid = valid && innerValid;\r\n    }\r\n    return valid;\r\n}"
}, {
	"Path": "org.jooq.types.UInteger.readResolve",
	"Comment": "replace version read through deserialization with cached version.",
	"Method": "Object readResolve(){\r\n    UInteger cached;\r\n    rangeCheck(value);\r\n    if ((cached = getCached(value)) != null)\r\n        return cached;\r\n    return this;\r\n}"
}, {
	"Path": "org.jooq.impl.DSL.revokeGrantOptionFor",
	"Comment": "revoke grant option for some privileges on a table from user or role.",
	"Method": "RevokeOnStep revokeGrantOptionFor(Privilege privilege,RevokeOnStep revokeGrantOptionFor,Privilege privileges,RevokeOnStep revokeGrantOptionFor,Collection<? extends Privilege> privileges){\r\n    return dsl().revoke(privileges);\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Database.isUnsignedTypes",
	"Comment": "generate joou data types for your unsigned data types, which are not natively supported in java",
	"Method": "Boolean isUnsignedTypes(){\r\n    return unsignedTypes;\r\n}"
}, {
	"Path": "jodd.db.oom.DbEntityColumnDescriptor.compareTo",
	"Comment": "compares two column descriptors. identity columns should be the first on the list.\teach group then will be sorted by column name.",
	"Method": "int compareTo(Object o){\r\n    DbEntityColumnDescriptor that = (DbEntityColumnDescriptor) o;\r\n    if (this.isId != that.isId) {\r\n        return this.isId ? -1 : 1;\r\n    }\r\n    return this.columnName.compareTo(that.columnName);\r\n}"
}, {
	"Path": "org.jsonschema2pojo.AnnotatorFactoryTest.attemptToCreateAnnotatorFromIncompatibleClassCausesIllegalArgumentException",
	"Comment": "test uses reflection to get passed the generic type constraints andinvoke as if invoked through typical configuration.",
	"Method": "void attemptToCreateAnnotatorFromIncompatibleClassCausesIllegalArgumentException(){\r\n    Method factoryMethod = AnnotatorFactory.class.getMethod(\"getAnnotator\", Class.class);\r\n    factoryMethod.invoke(String.class);\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractPartial.isEqual",
	"Comment": "is this partial the same as the specified partial.the fields are compared in order, from largest to smallest.if all fields are equal, the result is true.you may not pass null into this method. this is because you needa time zone to accurately determine the current date.",
	"Method": "boolean isEqual(ReadablePartial partial){\r\n    if (partial == null) {\r\n        throw new IllegalArgumentException(\"Partial cannot be null\");\r\n    }\r\n    return compareTo(partial) == 0;\r\n}"
}, {
	"Path": "jodd.lagarto.dom.Node.getLastChildElement",
	"Comment": "returns last child element with given name or\tnull if no such child node exist.",
	"Method": "Element getLastChildElement(Element getLastChildElement,String elementName){\r\n    if (childNodes == null) {\r\n        return null;\r\n    }\r\n    int from = childNodes.size() - 1;\r\n    for (int i = from; i >= 0; i--) {\r\n        Node child = childNodes.get(i);\r\n        if (child.getNodeType() == NodeType.ELEMENT && elementName.equals(child.getNodeName())) {\r\n            child.initSiblingNames();\r\n            return (Element) child;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.joda.time.chrono.BaseChronology.weekyearOfCentury",
	"Comment": "get the year of a week based year in a century field for this chronology.",
	"Method": "DateTimeField weekyearOfCentury(){\r\n    return UnsupportedDateTimeField.getInstance(DateTimeFieldType.weekyearOfCentury(), weekyears());\r\n}"
}, {
	"Path": "jodd.system.SystemUtil.get",
	"Comment": "returns system property. if key is not available, returns the default value.",
	"Method": "String get(String name,String get,String name,String defaultValue){\r\n    Objects.requireNonNull(name);\r\n    String value = null;\r\n    try {\r\n        if (System.getSecurityManager() == null) {\r\n            value = System.getProperty(name);\r\n        } else {\r\n            value = AccessController.doPrivileged((PrivilegedAction<String>) () -> System.getProperty(name));\r\n        }\r\n    } catch (Exception ignore) {\r\n    }\r\n    if (value == null) {\r\n        return defaultValue;\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "org.jooq.impl.DefaultDataType.getNumericClass",
	"Comment": "get the most suitable java class for a given precision and scale",
	"Method": "Class<?> getNumericClass(int precision,int scale){\r\n    if (scale == 0 && precision != 0)\r\n        if (precision < BYTE_PRECISION)\r\n            return Byte.class;\r\n        else if (precision < SHORT_PRECISION)\r\n            return Short.class;\r\n        else if (precision < INTEGER_PRECISION)\r\n            return Integer.class;\r\n        else if (precision < LONG_PRECISION)\r\n            return Long.class;\r\n        else\r\n            return BigInteger.class;\r\n    else\r\n        return BigDecimal.class;\r\n}"
}, {
	"Path": "jodd.http.net.SocketHttpConnectionProvider.getSocketFactory",
	"Comment": "returns socket factory based on proxy type and ssl requirements.",
	"Method": "SocketFactory getSocketFactory(ProxyInfo proxy,boolean ssl,boolean trustAllCertificates){\r\n    switch(proxy.getProxyType()) {\r\n        case NONE:\r\n            if (ssl) {\r\n                return getDefaultSSLSocketFactory(trustAllCertificates);\r\n            } else {\r\n                return SocketFactory.getDefault();\r\n            }\r\n        case HTTP:\r\n            return new HTTPProxySocketFactory(proxy);\r\n        case SOCKS4:\r\n            return new Socks4ProxySocketFactory(proxy);\r\n        case SOCKS5:\r\n            return new Socks5ProxySocketFactory(proxy);\r\n        default:\r\n            return null;\r\n    }\r\n}"
}, {
	"Path": "org.jooq.impl.DefaultVisitListenerProvider.providers",
	"Comment": "convenience method to construct an array ofdefaultvisitlistenerprovider from an array ofvisitlistener instances.",
	"Method": "VisitListenerProvider[] providers(VisitListener listeners){\r\n    VisitListenerProvider[] result = new VisitListenerProvider[listeners.length];\r\n    for (int i = 0; i < listeners.length; i++) result[i] = new DefaultVisitListenerProvider(listeners[i]);\r\n    return result;\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.rtcp.SenderReport.setInterval",
	"Comment": "sets the temporal interval between two rtcp sender reports.\tdefault interval is set to 3 seconds.\tset 0 to disable rtcp.",
	"Method": "void setInterval(long interval){\r\n    this.interval = interval;\r\n}"
}, {
	"Path": "org.joda.time.LocalDate.era",
	"Comment": "get the era property which provides access to advanced functionality.",
	"Method": "Property era(){\r\n    return new Property(this, getChronology().era());\r\n}"
}, {
	"Path": "org.joda.time.TimeOfDay.millisOfSecond",
	"Comment": "get the millis of second property which provides access to advanced functionality.",
	"Method": "Property millisOfSecond(){\r\n    return new Property(this, MILLIS_OF_SECOND);\r\n}"
}, {
	"Path": "jodd.io.upload.MultipartStreamParser.parseRequestStream",
	"Comment": "extracts uploaded files and parameters from the request data.",
	"Method": "void parseRequestStream(InputStream inputStream,String encoding){\r\n    setParsed();\r\n    MultipartRequestInputStream input = new MultipartRequestInputStream(inputStream);\r\n    input.readBoundary();\r\n    while (true) {\r\n        FileUploadHeader header = input.readDataHeader(encoding);\r\n        if (header == null) {\r\n            break;\r\n        }\r\n        if (header.isFile) {\r\n            String fileName = header.fileName;\r\n            if (fileName.length() > 0) {\r\n                if (header.contentType.indexOf(\"application/x-macbinary\") > 0) {\r\n                    input.skipBytes(128);\r\n                }\r\n            }\r\n            FileUpload newFile = fileUploadFactory.create(input);\r\n            newFile.processStream();\r\n            if (fileName.length() == 0) {\r\n                if (newFile.getSize() == 0) {\r\n                    newFile.size = -1;\r\n                }\r\n            }\r\n            putFile(header.formFieldName, newFile);\r\n        } else {\r\n            FastByteArrayOutputStream fbos = new FastByteArrayOutputStream();\r\n            input.copyAll(fbos);\r\n            String value = encoding != null ? new String(fbos.toByteArray(), encoding) : new String(fbos.toByteArray());\r\n            putParameter(header.formFieldName, value);\r\n        }\r\n        input.skipBytes(1);\r\n        input.mark(1);\r\n        int nextByte = input.read();\r\n        if (nextByte == -1 || nextByte == '-') {\r\n            input.reset();\r\n            break;\r\n        }\r\n        input.reset();\r\n    }\r\n}"
}, {
	"Path": "jodd.db.DbQueryBase.isInitialized",
	"Comment": "returns true if query is initialized. initialized query is the one that has\tcreated jdbc statements.",
	"Method": "boolean isInitialized(){\r\n    return queryState == INITIALIZED;\r\n}"
}, {
	"Path": "org.joda.time.DateMidnight.withMillis",
	"Comment": "returns a copy of this date with a different millisecond instant.the returned object will have a local time of midnight.only the millis will change, the chronology and time zone are kept.the returned object will be either be a new instance or this.",
	"Method": "DateMidnight withMillis(long newMillis){\r\n    Chronology chrono = getChronology();\r\n    newMillis = checkInstant(newMillis, chrono);\r\n    return (newMillis == getMillis() ? this : new DateMidnight(newMillis, chrono));\r\n}"
}, {
	"Path": "org.joda.time.Minutes.plus",
	"Comment": "returns a new instance with the specified number of minutes added.this instance is immutable and unaffected by this method call.",
	"Method": "Minutes plus(int minutes,Minutes plus,Minutes minutes){\r\n    if (minutes == null) {\r\n        return this;\r\n    }\r\n    return plus(minutes.getValue());\r\n}"
}, {
	"Path": "org.joda.time.format.PeriodFormatter.getLocale",
	"Comment": "gets the locale that will be used for printing and parsing.a null locale indicates that no specific locale override is in use.",
	"Method": "Locale getLocale(){\r\n    return iLocale;\r\n}"
}, {
	"Path": "org.joda.time.DateTime.weekOfWeekyear",
	"Comment": "get the week of a week based year property which provides access to advanced functionality.",
	"Method": "Property weekOfWeekyear(){\r\n    return new Property(this, getChronology().weekOfWeekyear());\r\n}"
}, {
	"Path": "jodd.paramo.MethodFinder.getResolvedParameters",
	"Comment": "returns method parameters once when method is parsed.\tif method has no parameters, an empty array is returned.",
	"Method": "MethodParameter[] getResolvedParameters(){\r\n    if (paramExtractor == null) {\r\n        return MethodParameter.EMPTY_ARRAY;\r\n    }\r\n    if (!paramExtractor.debugInfoPresent) {\r\n        throw new ParamoException(\"Parameter names not available for method: \" + declaringClass.getName() + '#' + methodName);\r\n    }\r\n    return paramExtractor.getMethodParameters();\r\n}"
}, {
	"Path": "jodd.db.oom.sqlgen.TemplateData.lookupType",
	"Comment": "lookups for entity name and throws an exception if entity type is invalid.",
	"Method": "DbEntityDescriptor lookupType(Class entity){\r\n    DbEntityDescriptor ded = entityManager.lookupType(entity);\r\n    if (ded == null) {\r\n        throw new DbSqlBuilderException(\"Invalid or not-persistent entity type: \" + entity.getName());\r\n    }\r\n    return ded;\r\n}"
}, {
	"Path": "org.jooq.conf.Settings.getFetchSize",
	"Comment": "the default jdbc fetchsize property that should be applied to alljooq queries, for which no specific fetchsize value was specified.",
	"Method": "Integer getFetchSize(){\r\n    return fetchSize;\r\n}"
}, {
	"Path": "jodd.madvoc.component.ActionsManager.registerAction",
	"Comment": "registers action with provided action class and method name.",
	"Method": "ActionRuntime registerAction(Class actionClass,String actionMethodName,ActionDefinition actionDefinition,ActionRuntime registerAction,Class actionClass,Method actionMethod,ActionDefinition actionDefinition){\r\n    final ActionRuntime actionRuntime = actionMethodParser.parse(actionClass, actionMethod, actionDefinition);\r\n    if (actionRuntime == null) {\r\n        return null;\r\n    }\r\n    return registerActionRuntime(actionRuntime);\r\n}"
}, {
	"Path": "org.jooq.conf.Settings.getFetchServerOutputSize",
	"Comment": "whether server output should be fetched after each query execution.",
	"Method": "Integer getFetchServerOutputSize(){\r\n    return fetchServerOutputSize;\r\n}"
}, {
	"Path": "org.jooq.codegen.JavaGenerator.generatePackageClassJavadoc",
	"Comment": "subclasses may override this method to provide their own javadoc.",
	"Method": "void generatePackageClassJavadoc(PackageDefinition pkg,JavaWriter out){\r\n    printClassJavadoc(out, \"Convenience access to all stored procedures and functions in \" + pkg.getName());\r\n}"
}, {
	"Path": "jodd.jtx.proxy.AnnotationTxAdviceManager.getTxMode",
	"Comment": "reads transaction mode from method annotation. annotations are cached for better performances.",
	"Method": "JtxTransactionMode getTxMode(Class type,String methodName,Class[] methodArgTypes,String unique){\r\n    String signature = type.getName() + '#' + methodName + '%' + unique;\r\n    JtxTransactionMode txMode = txmap.get(signature);\r\n    if (txMode == null) {\r\n        if (!txmap.containsKey(signature)) {\r\n            final Method m;\r\n            try {\r\n                m = type.getMethod(methodName, methodArgTypes);\r\n            } catch (NoSuchMethodException nsmex) {\r\n                throw new ProxettaException(nsmex);\r\n            }\r\n            final TransactionAnnotationValues txAnn = readTransactionAnnotation(m);\r\n            if (txAnn != null) {\r\n                txMode = new JtxTransactionMode(txAnn.propagation(), txAnn.isolation(), txAnn.readOnly(), txAnn.timeout());\r\n            } else {\r\n                txMode = defaultTransactionMode;\r\n            }\r\n            txmap.put(signature, txMode);\r\n        }\r\n    }\r\n    return txMode;\r\n}"
}, {
	"Path": "org.joda.time.base.BaseDuration.toPeriodTo",
	"Comment": "converts this duration to a period instance by subtracting the durationfrom an end instant to obtain an interval using the standard periodtype.this conversion will determine the fields of a period accurately.the results are based on the instant millis, the chronology of the instant,the period type and the length of this duration.",
	"Method": "Period toPeriodTo(ReadableInstant endInstant,Period toPeriodTo,ReadableInstant endInstant,PeriodType type){\r\n    return new Period(this, endInstant, type);\r\n}"
}, {
	"Path": "org.jooq.impl.DSL.condition",
	"Comment": "return a condition that connects all argumentconditions with operator.",
	"Method": "Condition condition(SQL sql,Condition condition,String sql,Condition condition,String sql,Object bindings,Condition condition,String sql,QueryPart parts,Condition condition,Boolean value,Condition condition,Field<Boolean> field,Condition condition,Map<Field<?>, ?> map,Condition condition,Record record,Condition condition,Operator operator,Condition left,Condition right,Condition condition,Operator operator,Condition conditions,Condition condition,Operator operator,Collection<? extends Condition> conditions){\r\n    return CombinedCondition.of(operator, conditions);\r\n}"
}, {
	"Path": "org.joda.time.LocalTime.getValue",
	"Comment": "gets the value of the field at the specified index.this method is required to support the readablepartialinterface. the supported fields are hourofday, minuteofhour,secondofminute and millisofsecond.",
	"Method": "int getValue(int index){\r\n    switch(index) {\r\n        case HOUR_OF_DAY:\r\n            return getChronology().hourOfDay().get(getLocalMillis());\r\n        case MINUTE_OF_HOUR:\r\n            return getChronology().minuteOfHour().get(getLocalMillis());\r\n        case SECOND_OF_MINUTE:\r\n            return getChronology().secondOfMinute().get(getLocalMillis());\r\n        case MILLIS_OF_SECOND:\r\n            return getChronology().millisOfSecond().get(getLocalMillis());\r\n        default:\r\n            throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\r\n    }\r\n}"
}, {
	"Path": "jodd.util.StringUtil.isSubstringAt",
	"Comment": "returns true if substring exist at given offset in a string.",
	"Method": "boolean isSubstringAt(String string,String substring,int offset){\r\n    int len = substring.length();\r\n    int max = offset + len;\r\n    if (max > string.length()) {\r\n        return false;\r\n    }\r\n    int ndx = 0;\r\n    for (int i = offset; i < max; i++, ndx++) {\r\n        if (string.charAt(i) != substring.charAt(ndx)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "jodd.madvoc.ActionRequest.createExecutionArray",
	"Comment": "creates execution array that will invoke all filters, actions and results\tin correct order.",
	"Method": "ActionWrapper[] createExecutionArray(){\r\n    int totalInterceptors = (this.actionRuntime.getInterceptors() != null ? this.actionRuntime.getInterceptors().length : 0);\r\n    int totalFilters = (this.actionRuntime.getFilters() != null ? this.actionRuntime.getFilters().length : 0);\r\n    ActionWrapper[] executionArray = new ActionWrapper[totalFilters + 1 + totalInterceptors + 1];\r\n    int index = 0;\r\n    if (totalFilters > 0) {\r\n        System.arraycopy(actionRuntime.getFilters(), 0, executionArray, index, totalFilters);\r\n        index += totalFilters;\r\n    }\r\n    executionArray[index++] = actionRequest -> {\r\n        Object actionResult = actionRequest.invoke();\r\n        ActionRequest.this.madvocController.render(ActionRequest.this, actionResult);\r\n        return actionResult;\r\n    };\r\n    if (totalInterceptors > 0) {\r\n        System.arraycopy(actionRuntime.getInterceptors(), 0, executionArray, index, totalInterceptors);\r\n        index += totalInterceptors;\r\n    }\r\n    executionArray[index] = actionRequest -> {\r\n        actionResult = invokeActionMethod();\r\n        return actionResult;\r\n    };\r\n    return executionArray;\r\n}"
}, {
	"Path": "org.joda.time.Minutes.minutes",
	"Comment": "obtains an instance of minutes that may be cached.minutes is immutable, so instances can be cached and shared.this factory method provides access to shared instances.",
	"Method": "Minutes minutes(int minutes){\r\n    switch(minutes) {\r\n        case 0:\r\n            return ZERO;\r\n        case 1:\r\n            return ONE;\r\n        case 2:\r\n            return TWO;\r\n        case 3:\r\n            return THREE;\r\n        case Integer.MAX_VALUE:\r\n            return MAX_VALUE;\r\n        case Integer.MIN_VALUE:\r\n            return MIN_VALUE;\r\n        default:\r\n            return new Minutes(minutes);\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.YearMonth.size",
	"Comment": "gets the number of fields in this partial, which is two.the supported fields are year and monthofyear.note that only these fields may be queried.",
	"Method": "int size(){\r\n    return 2;\r\n}"
}, {
	"Path": "org.jooq.codegen.JavaGenerator.generateInterfaceSetter",
	"Comment": "subclasses may override this method to provide their own interface setters.",
	"Method": "void generateInterfaceSetter(TypedElementDefinition<?> column,int index,JavaWriter out){\r\n    generateInterfaceSetter0(column, index, out);\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.MediaStream.getLocalPorts",
	"Comment": "returns a pair of source ports, the first one is the \tone used for rtp and the second one is used for rtcp.",
	"Method": "int[] getLocalPorts(){\r\n    return mPacketizer.getRtpSocket().getLocalPorts();\r\n}"
}, {
	"Path": "jodd.asm7.Type.getConstructorDescriptor",
	"Comment": "returns the descriptor corresponding to the given constructor.",
	"Method": "String getConstructorDescriptor(Constructor<?> constructor){\r\n    StringBuilder stringBuilder = new StringBuilder();\r\n    stringBuilder.append('(');\r\n    Class<?>[] parameters = constructor.getParameterTypes();\r\n    for (Class<?> parameter : parameters) {\r\n        appendDescriptor(parameter, stringBuilder);\r\n    }\r\n    return stringBuilder.append(\")V\").toString();\r\n}"
}, {
	"Path": "jodd.jtx.JtxTransaction.isCompleted",
	"Comment": "returns true if transaction is either committed or rolled back.",
	"Method": "boolean isCompleted(){\r\n    return status == STATUS_COMMITTED || status == STATUS_ROLLEDBACK;\r\n}"
}, {
	"Path": "org.joda.time.DateMidnight.withYearOfCentury",
	"Comment": "returns a copy of this date with the year of century field updated.datemidnight is immutable, so there are no set methods.instead, this method returns a new instance with the value ofyear of century changed.",
	"Method": "DateMidnight withYearOfCentury(int yearOfCentury){\r\n    return withMillis(getChronology().yearOfCentury().set(getMillis(), yearOfCentury));\r\n}"
}, {
	"Path": "org.jooq.conf.Settings.isFetchWarnings",
	"Comment": "whether warnings should be fetched after each query execution.",
	"Method": "Boolean isFetchWarnings(){\r\n    return fetchWarnings;\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractPeriod.toMutablePeriod",
	"Comment": "get this object as a mutableperiod.this will always return a new mutableperiod with the same fields.",
	"Method": "MutablePeriod toMutablePeriod(){\r\n    return new MutablePeriod(this);\r\n}"
}, {
	"Path": "org.joda.time.MonthDay.size",
	"Comment": "gets the number of fields in this partial, which is two.the supported fields are monthofyear and dayofmonth.note that only these fields may be queried.",
	"Method": "int size(){\r\n    return 2;\r\n}"
}, {
	"Path": "jodd.net.URLCoder.encodePathSegment",
	"Comment": "encodes the given uri path segment with the given encoding.",
	"Method": "String encodePathSegment(String segment,String encoding,String encodePathSegment,String segment){\r\n    return encodeUriComponent(segment, JoddCore.encoding, URIPart.PATH_SEGMENT);\r\n}"
}, {
	"Path": "org.joda.time.Seconds.secondsBetween",
	"Comment": "creates a seconds representing the number of whole secondsbetween the two specified partial datetimes.the two partials must contain the same fields, for example you can specifytwo localtime objects.",
	"Method": "Seconds secondsBetween(ReadableInstant start,ReadableInstant end,Seconds secondsBetween,ReadablePartial start,ReadablePartial end){\r\n    if (start instanceof LocalTime && end instanceof LocalTime) {\r\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\r\n        int seconds = chrono.seconds().getDifference(((LocalTime) end).getLocalMillis(), ((LocalTime) start).getLocalMillis());\r\n        return Seconds.seconds(seconds);\r\n    }\r\n    int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\r\n    return Seconds.seconds(amount);\r\n}"
}, {
	"Path": "org.joda.time.DateTime.withMillisOfDay",
	"Comment": "returns a copy of this datetime with the millis of day field updated.datetime is immutable, so there are no set methods.instead, this method returns a new instance with the value ofmillis of day changed.",
	"Method": "DateTime withMillisOfDay(int millis){\r\n    return withMillis(getChronology().millisOfDay().set(getMillis(), millis));\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Database.isIncludeInvisibleColumns",
	"Comment": "this flag indicates whether invisible columns should be included in output produced by this database",
	"Method": "Boolean isIncludeInvisibleColumns(){\r\n    return includeInvisibleColumns;\r\n}"
}, {
	"Path": "jodd.json.JsonParser.parseAsMap",
	"Comment": "parses input json to a list with specified key and value types.",
	"Method": "Map<K, V> parseAsMap(String string,Class<K> keyType,Class<V> valueType){\r\n    return new JsonParser().map(JsonParser.KEYS, keyType).map(JsonParser.VALUES, valueType).parse(string);\r\n}"
}, {
	"Path": "org.joda.time.field.AbstractPartialFieldProperty.compareTo",
	"Comment": "compare this field to the same field on another partial instant.the comparison is based on the value of the same field type, irrespectiveof any difference in chronology. thus, if this property represents thehourofday field, then the hourofday field of the other partial will be queriedwhether in the same chronology or not.",
	"Method": "int compareTo(ReadableInstant instant,int compareTo,ReadablePartial partial){\r\n    if (partial == null) {\r\n        throw new IllegalArgumentException(\"The instant must not be null\");\r\n    }\r\n    int thisValue = get();\r\n    int otherValue = partial.get(getFieldType());\r\n    if (thisValue < otherValue) {\r\n        return -1;\r\n    } else if (thisValue > otherValue) {\r\n        return 1;\r\n    } else {\r\n        return 0;\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.DateTime.yearOfEra",
	"Comment": "get the year of era property which provides access to advanced functionality.",
	"Method": "Property yearOfEra(){\r\n    return new Property(this, getChronology().yearOfEra());\r\n}"
}, {
	"Path": "jodd.servlet.wrapper.BufferResponseWrapper.getBufferContentAsBytes",
	"Comment": "returns buffered content as bytes, no matter if stream or writer is used.\treturns null if buffering was not enabled.",
	"Method": "byte[] getBufferContentAsBytes(){\r\n    if (buffer == null) {\r\n        return null;\r\n    }\r\n    if (buffer.isUsingStream()) {\r\n        return buffer.toByteArray();\r\n    }\r\n    char[] content = buffer.toCharArray();\r\n    String encoding = getContentTypeEncoding();\r\n    if (encoding == null) {\r\n        return CharUtil.toByteArray(content);\r\n    } else {\r\n        return CharUtil.toByteArray(content, encoding);\r\n    }\r\n}"
}, {
	"Path": "jodd.servlet.wrapper.BufferResponseWrapper.getOutputStream",
	"Comment": "returns buffered output stream if buffering is enabled,\totherwise returns the original stream.",
	"Method": "ServletOutputStream getOutputStream(){\r\n    preResponseCommit();\r\n    if (buffer == null) {\r\n        return getResponse().getOutputStream();\r\n    }\r\n    return buffer.getOutputStream();\r\n}"
}, {
	"Path": "org.joda.time.IllegalFieldValueException.getIllegalStringValue",
	"Comment": "returns the illegal string value assigned to the field, or null if not applicable.",
	"Method": "String getIllegalStringValue(){\r\n    return iStringValue;\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.dayOfYear",
	"Comment": "get the day of year property which provides access to advanced functionality.",
	"Method": "Property dayOfYear(){\r\n    return new Property(this, getChronology().dayOfYear());\r\n}"
}, {
	"Path": "org.jooq.impl.DSL.dateAdd",
	"Comment": "add an interval to a date, given a date part.this translates into any dialect",
	"Method": "Field<Date> dateAdd(Date date,Number interval,Field<Date> dateAdd,Field<Date> date,Field<? extends Number> interval,Field<Date> dateAdd,Date date,Number interval,DatePart datePart,Field<Date> dateAdd,Date date,Field<? extends Number> interval,DatePart datePart,Field<Date> dateAdd,Field<Date> date,Number interval,DatePart datePart,Field<Date> dateAdd,Field<Date> date,Field<? extends Number> interval,DatePart datePart){\r\n    return new DateAdd<Date>(nullSafe(date), nullSafe(interval), datePart);\r\n}"
}, {
	"Path": "org.jooq.codegen.JavaGenerator.generateRoutineClassJavadoc",
	"Comment": "subclasses may override this method to provide their own javadoc.",
	"Method": "void generateRoutineClassJavadoc(RoutineDefinition routine,JavaWriter out){\r\n    if (generateCommentsOnRoutines())\r\n        printClassJavadoc(out, routine);\r\n    else\r\n        printClassJavadoc(out, \"The routine <code>\" + routine.getQualifiedInputName() + \"<\/code>.\");\r\n}"
}, {
	"Path": "org.joda.time.Period.minusMonths",
	"Comment": "returns a new period minus the specified number of months taken away.this period instance is immutable and unaffected by this method call.",
	"Method": "Period minusMonths(int months){\r\n    return plusMonths(-months);\r\n}"
}, {
	"Path": "org.joda.time.YearMonthDay.withMonthOfYear",
	"Comment": "returns a copy of this date with the month of year field updated.yearmonthday is immutable, so there are no set methods.instead, this method returns a new instance with the value ofmonth of year changed.",
	"Method": "YearMonthDay withMonthOfYear(int monthOfYear){\r\n    int[] newValues = getValues();\r\n    newValues = getChronology().monthOfYear().set(this, MONTH_OF_YEAR, newValues, monthOfYear);\r\n    return new YearMonthDay(this, newValues);\r\n}"
}, {
	"Path": "org.joda.time.PeriodType.forFields",
	"Comment": "gets a period type that contains the duration types of the array.only the 8 standard duration field types are supported.",
	"Method": "PeriodType forFields(DurationFieldType[] types){\r\n    if (types == null || types.length == 0) {\r\n        throw new IllegalArgumentException(\"Types array must not be null or empty\");\r\n    }\r\n    for (int i = 0; i < types.length; i++) {\r\n        if (types[i] == null) {\r\n            throw new IllegalArgumentException(\"Types array must not contain null\");\r\n        }\r\n    }\r\n    Map<PeriodType, Object> cache = cTypes;\r\n    if (cache.isEmpty()) {\r\n        cache.put(standard(), standard());\r\n        cache.put(yearMonthDayTime(), yearMonthDayTime());\r\n        cache.put(yearMonthDay(), yearMonthDay());\r\n        cache.put(yearWeekDayTime(), yearWeekDayTime());\r\n        cache.put(yearWeekDay(), yearWeekDay());\r\n        cache.put(yearDayTime(), yearDayTime());\r\n        cache.put(yearDay(), yearDay());\r\n        cache.put(dayTime(), dayTime());\r\n        cache.put(time(), time());\r\n        cache.put(years(), years());\r\n        cache.put(months(), months());\r\n        cache.put(weeks(), weeks());\r\n        cache.put(days(), days());\r\n        cache.put(hours(), hours());\r\n        cache.put(minutes(), minutes());\r\n        cache.put(seconds(), seconds());\r\n        cache.put(millis(), millis());\r\n    }\r\n    PeriodType inPartType = new PeriodType(null, types, null);\r\n    Object cached = cache.get(inPartType);\r\n    if (cached instanceof PeriodType) {\r\n        return (PeriodType) cached;\r\n    }\r\n    if (cached != null) {\r\n        throw new IllegalArgumentException(\"PeriodType does not support fields: \" + cached);\r\n    }\r\n    PeriodType type = standard();\r\n    List<DurationFieldType> list = new ArrayList<DurationFieldType>(Arrays.asList(types));\r\n    if (list.remove(DurationFieldType.years()) == false) {\r\n        type = type.withYearsRemoved();\r\n    }\r\n    if (list.remove(DurationFieldType.months()) == false) {\r\n        type = type.withMonthsRemoved();\r\n    }\r\n    if (list.remove(DurationFieldType.weeks()) == false) {\r\n        type = type.withWeeksRemoved();\r\n    }\r\n    if (list.remove(DurationFieldType.days()) == false) {\r\n        type = type.withDaysRemoved();\r\n    }\r\n    if (list.remove(DurationFieldType.hours()) == false) {\r\n        type = type.withHoursRemoved();\r\n    }\r\n    if (list.remove(DurationFieldType.minutes()) == false) {\r\n        type = type.withMinutesRemoved();\r\n    }\r\n    if (list.remove(DurationFieldType.seconds()) == false) {\r\n        type = type.withSecondsRemoved();\r\n    }\r\n    if (list.remove(DurationFieldType.millis()) == false) {\r\n        type = type.withMillisRemoved();\r\n    }\r\n    if (list.size() > 0) {\r\n        cache.put(inPartType, list);\r\n        throw new IllegalArgumentException(\"PeriodType does not support fields: \" + list);\r\n    }\r\n    PeriodType checkPartType = new PeriodType(null, type.iTypes, null);\r\n    PeriodType checkedType = (PeriodType) cache.get(checkPartType);\r\n    if (checkedType != null) {\r\n        cache.put(checkPartType, checkedType);\r\n        return checkedType;\r\n    }\r\n    cache.put(checkPartType, type);\r\n    return type;\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Generate.isCommentsOnColumns",
	"Comment": "turn off generation of all sql comments as javadoc on all columns.",
	"Method": "Boolean isCommentsOnColumns(){\r\n    return commentsOnColumns;\r\n}"
}, {
	"Path": "jodd.props.Props.getIntegerValue",
	"Comment": "returns integer value or default one if property not defined.",
	"Method": "Integer getIntegerValue(String key,Integer getIntegerValue,String key,Integer defaultValue,Integer getIntegerValue,String key,String profiles,Integer getIntegerValue,String key,Integer defaultValue,String profiles){\r\n    final String value = getValue(key, profiles);\r\n    if (value == null) {\r\n        return defaultValue;\r\n    }\r\n    return Integer.valueOf(value);\r\n}"
}, {
	"Path": "org.jooq.codegen.JavaGenerator.generateUDTClassJavadoc",
	"Comment": "subclasses may override this method to provide their own javadoc.",
	"Method": "void generateUDTClassJavadoc(UDTDefinition udt,JavaWriter out){\r\n    if (generateCommentsOnUDTs())\r\n        printClassJavadoc(out, udt);\r\n    else\r\n        printClassJavadoc(out, \"The udt <code>\" + udt.getQualifiedInputName() + \"<\/code>.\");\r\n}"
}, {
	"Path": "jodd.system.JavaInfo.getJavaVersion",
	"Comment": "returns java version string, as specified in system property.\treturned string contain major version, minor version and revision.",
	"Method": "String getJavaVersion(){\r\n    return JAVA_VERSION;\r\n}"
}, {
	"Path": "jodd.decora.DecoraServletFilter.init",
	"Comment": "initializes decora filter. loads manager and parser from init parameters.",
	"Method": "void init(FilterConfig filterConfig){\r\n    String decoraManagerClass = filterConfig.getInitParameter(PARAM_DECORA_MANAGER);\r\n    if (decoraManagerClass != null) {\r\n        try {\r\n            Class decoraManagerType = ClassLoaderUtil.loadClass(decoraManagerClass);\r\n            decoraManager = (DecoraManager) ClassUtil.newInstance(decoraManagerType);\r\n        } catch (Exception ex) {\r\n            log.error(\"Unable to load Decora manager class: \" + decoraManagerClass, ex);\r\n            throw new ServletException(ex);\r\n        }\r\n    } else {\r\n        decoraManager = createDecoraManager();\r\n    }\r\n    String decoraParserClass = filterConfig.getInitParameter(PARAM_DECORA_PARSER);\r\n    if (decoraParserClass != null) {\r\n        try {\r\n            Class decoraParserType = ClassLoaderUtil.loadClass(decoraParserClass);\r\n            decoraParser = (DecoraParser) ClassUtil.newInstance(decoraParserType);\r\n        } catch (Exception ex) {\r\n            log.error(\"Unable to load Decora parser class: \" + decoraParserClass, ex);\r\n            throw new ServletException(ex);\r\n        }\r\n    } else {\r\n        decoraParser = createDecoraParser();\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.YearMonth.fromDateFields",
	"Comment": "constructs a yearmonth from a java.util.dateusing exactly the same field values avoiding any time zone effects.each field is queried from the date and assigned to the yearmonth.this factory method always creates a yearmonth with iso chronology.",
	"Method": "YearMonth fromDateFields(Date date){\r\n    if (date == null) {\r\n        throw new IllegalArgumentException(\"The date must not be null\");\r\n    }\r\n    return new YearMonth(date.getYear() + 1900, date.getMonth() + 1);\r\n}"
}, {
	"Path": "org.joda.time.YearMonthDay.withYear",
	"Comment": "returns a copy of this date with the year field updated.yearmonthday is immutable, so there are no set methods.instead, this method returns a new instance with the value ofyear changed.",
	"Method": "YearMonthDay withYear(int year){\r\n    int[] newValues = getValues();\r\n    newValues = getChronology().year().set(this, YEAR, newValues, year);\r\n    return new YearMonthDay(this, newValues);\r\n}"
}, {
	"Path": "org.jooq.conf.Settings.isCacheRecordMappers",
	"Comment": "whether record mappers should be cached in the configuration.",
	"Method": "Boolean isCacheRecordMappers(){\r\n    return cacheRecordMappers;\r\n}"
}, {
	"Path": "jodd.http.HttpRequest.method",
	"Comment": "specifies request method. it will be converted into uppercase.\tdoes not validate if method is one of the http methods.",
	"Method": "String method(HttpRequest method,String method,HttpRequest method,HttpMethod httpMethod){\r\n    this.method = httpMethod.name();\r\n    return this;\r\n}"
}, {
	"Path": "org.joda.time.Period.minusDays",
	"Comment": "returns a new period minus the specified number of days taken away.this period instance is immutable and unaffected by this method call.",
	"Method": "Period minusDays(int days){\r\n    return plusDays(-days);\r\n}"
}, {
	"Path": "org.joda.time.Months.monthsIn",
	"Comment": "creates a months representing the number of whole monthsin the specified interval. this method correctly handles any daylightsavings time changes that may occur during the interval.",
	"Method": "Months monthsIn(ReadableInterval interval){\r\n    if (interval == null) {\r\n        return Months.ZERO;\r\n    }\r\n    int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.months());\r\n    return Months.months(amount);\r\n}"
}, {
	"Path": "org.json.JSONArray.put",
	"Comment": "put or replace an object value in the jsonarray. if the index is greaterthan the length of the jsonarray, then null elements will be added asnecessary to pad it out.",
	"Method": "JSONArray put(boolean value,JSONArray put,Collection<?> value,JSONArray put,double value,JSONArray put,float value,JSONArray put,int value,JSONArray put,long value,JSONArray put,Map<?, ?> value,JSONArray put,Object value,JSONArray put,int index,boolean value,JSONArray put,int index,Collection<?> value,JSONArray put,int index,double value,JSONArray put,int index,float value,JSONArray put,int index,int value,JSONArray put,int index,long value,JSONArray put,int index,Map<?, ?> value,JSONArray put,int index,Object value){\r\n    if (index < 0) {\r\n        throw new JSONException(\"JSONArray[\" + index + \"] not found.\");\r\n    }\r\n    if (index < this.length()) {\r\n        JSONObject.testValidity(value);\r\n        this.myArrayList.set(index, value);\r\n        return this;\r\n    }\r\n    if (index == this.length()) {\r\n        return this.put(value);\r\n    }\r\n    this.myArrayList.ensureCapacity(index + 1);\r\n    while (index != this.length()) {\r\n        this.myArrayList.add(JSONObject.NULL);\r\n    }\r\n    return this.put(value);\r\n}"
}, {
	"Path": "jodd.csselly.CssSelector.getElement",
	"Comment": "returns selector element name. returnsfor\tuniversal selectors.",
	"Method": "String getElement(){\r\n    return element;\r\n}"
}, {
	"Path": "jodd.util.collection.IntHashMap.rehash",
	"Comment": "rehashes the contents of this map into a new inthashmap\tinstance with a larger capacity. this method is called automatically when\tthe number of keys in this map exceeds its capacity and load factor.",
	"Method": "void rehash(){\r\n    int oldCapacity = table.length;\r\n    Entry[] oldMap = table;\r\n    int newCapacity = (oldCapacity << 1) + 1;\r\n    Entry[] newMap = new Entry[newCapacity];\r\n    modCount++;\r\n    threshold = (int) (newCapacity * loadFactor);\r\n    table = newMap;\r\n    for (int i = oldCapacity; i-- > 0; ) {\r\n        for (Entry old = oldMap[i]; old != null; ) {\r\n            Entry e = old;\r\n            old = old.next;\r\n            int index = (e.key & 0x7FFFFFFF) % newCapacity;\r\n            e.next = newMap[index];\r\n            newMap[index] = e;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.DateMidnight.yearOfEra",
	"Comment": "get the year of era property which provides access to advanced functionality.",
	"Method": "Property yearOfEra(){\r\n    return new Property(this, getChronology().yearOfEra());\r\n}"
}, {
	"Path": "jodd.props.Props.setIgnoreMissingMacros",
	"Comment": "ignore missing macros by replacing them with an empty string.",
	"Method": "Props setIgnoreMissingMacros(boolean ignoreMissingMacros){\r\n    data.ignoreMissingMacros = ignoreMissingMacros;\r\n    return this;\r\n}"
}, {
	"Path": "jodd.asm7.Handle.getDesc",
	"Comment": "returns the descriptor of the field or method designated by this handle.",
	"Method": "String getDesc(){\r\n    return descriptor;\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Generate.isCommentsOnCatalogs",
	"Comment": "turn off generation of all sql comments as javadoc on all catalogs.",
	"Method": "Boolean isCommentsOnCatalogs(){\r\n    return commentsOnCatalogs;\r\n}"
}, {
	"Path": "org.apache.jorphan.reflect.TestClassTools.testConstructString",
	"Comment": "test that a class can be constructed using the default constructor",
	"Method": "void testConstructString(){\r\n    String dummy = (String) ClassTools.construct(\"java.lang.String\");\r\n    assertNotNull(dummy);\r\n    assertEquals(\"\", dummy);\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.withCenturyOfEra",
	"Comment": "returns a copy of this datetime with the century of era field updated.localdatetime is immutable, so there are no set methods.instead, this method returns a new instance with the value ofcentury of era changed.",
	"Method": "LocalDateTime withCenturyOfEra(int centuryOfEra){\r\n    return withLocalMillis(getChronology().centuryOfEra().set(getLocalMillis(), centuryOfEra));\r\n}"
}, {
	"Path": "jodd.servlet.wrapper.BufferResponseWrapper.getBufferedChars",
	"Comment": "returns buffered content or null if buffering was not enabled.",
	"Method": "char[] getBufferedChars(){\r\n    if (buffer == null) {\r\n        return null;\r\n    }\r\n    return buffer.toCharArray();\r\n}"
}, {
	"Path": "org.joda.time.format.PeriodFormatterBuilder.append",
	"Comment": "appends a printer parser pair.either the printer or the parser may be null, in which case the builder willbe unable to produce a parser or printer respectively.",
	"Method": "PeriodFormatterBuilder append(PeriodFormatter formatter,PeriodFormatterBuilder append,PeriodPrinter printer,PeriodParser parser){\r\n    if (printer == null && parser == null) {\r\n        throw new IllegalArgumentException(\"No printer or parser supplied\");\r\n    }\r\n    clearPrefix();\r\n    append0(printer, parser);\r\n    return this;\r\n}"
}, {
	"Path": "org.joda.time.chrono.ZonedChronology.getInstance",
	"Comment": "create a zonedchronology for any chronology, overriding any time zone itmay already have.",
	"Method": "ZonedChronology getInstance(Chronology base,DateTimeZone zone){\r\n    if (base == null) {\r\n        throw new IllegalArgumentException(\"Must supply a chronology\");\r\n    }\r\n    base = base.withUTC();\r\n    if (base == null) {\r\n        throw new IllegalArgumentException(\"UTC chronology must not be null\");\r\n    }\r\n    if (zone == null) {\r\n        throw new IllegalArgumentException(\"DateTimeZone must not be null\");\r\n    }\r\n    return new ZonedChronology(base, zone);\r\n}"
}, {
	"Path": "jodd.asm7.MethodVisitor.visitInsnAnnotation",
	"Comment": "visits an annotation on an instruction. this method must be called just after theannotated instruction. it can be called several times for the same instruction.",
	"Method": "AnnotationVisitor visitInsnAnnotation(int typeRef,TypePath typePath,String descriptor,boolean visible){\r\n    if (api < Opcodes.ASM5) {\r\n        throw new UnsupportedOperationException(REQUIRES_ASM5);\r\n    }\r\n    if (mv != null) {\r\n        return mv.visitInsnAnnotation(typeRef, typePath, descriptor, visible);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "jodd.csselly.CSSellyLexer.yytext",
	"Comment": "returns the text matched by the current regular expression.",
	"Method": "String yytext(int startIndex,String yytext,int startIndex,int endIndexOffset,String yytext){\r\n    return new String(zzBuffer, zzStartRead, zzMarkedPos - zzStartRead);\r\n}"
}, {
	"Path": "org.joda.time.Seconds.multipliedBy",
	"Comment": "returns a new instance with the seconds multiplied by the specified scalar.this instance is immutable and unaffected by this method call.",
	"Method": "Seconds multipliedBy(int scalar){\r\n    return Seconds.seconds(FieldUtils.safeMultiply(getValue(), scalar));\r\n}"
}, {
	"Path": "org.joda.time.Days.toStandardDuration",
	"Comment": "converts this period in days to a duration in milliseconds assuming a24 hour day, 60 minute hour and 60 second minute.this method allows you to convert from a period to a duration.however to achieve this it makes the assumption that all days are 24 hourslong, all hours are 60 minutes and all minutes are 60 seconds.this is not true when daylight savings time is considered, and may alsonot be true for some unusual chronologies. however, it is included as itis a useful operation for many applications and business rules.",
	"Method": "Duration toStandardDuration(){\r\n    long days = getValue();\r\n    return new Duration(days * DateTimeConstants.MILLIS_PER_DAY);\r\n}"
}, {
	"Path": "jodd.db.oom.DbEntityManager.registerEntity",
	"Comment": "registers entity. existing entity will be removed if exist, so no exception will be thrown.",
	"Method": "DbEntityDescriptor<E> registerEntity(Class<E> type,DbEntityDescriptor<E> registerEntity,Class<E> type,boolean force){\r\n    if (force) {\r\n        removeEntity(type);\r\n    }\r\n    return registerEntity(type);\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Generator.getName",
	"Comment": "the class used to generate source code. this can be overridden with a custom code generator implementation.",
	"Method": "String getName(){\r\n    return name;\r\n}"
}, {
	"Path": "org.joda.time.LocalDate.withCenturyOfEra",
	"Comment": "returns a copy of this date with the century of era field updated.localdate is immutable, so there are no set methods.instead, this method returns a new instance with the value ofcentury of era changed.",
	"Method": "LocalDate withCenturyOfEra(int centuryOfEra){\r\n    return withLocalMillis(getChronology().centuryOfEra().set(getLocalMillis(), centuryOfEra));\r\n}"
}, {
	"Path": "jodd.csselly.selector.PseudoFunctionSelector.accept",
	"Comment": "accepts node within selected results. invoked after results are matched.",
	"Method": "boolean accept(Node node,boolean accept,List<Node> currentResults,Node node,int index){\r\n    return pseudoFunction.match(currentResults, node, index, parsedExpression);\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractDuration.isShorterThan",
	"Comment": "is the length of this duration shorter than the duration passed in.the comparison takes into account the sign.as such, a duration of minus 5 seconds is shorter than a duration of 3 seconds.",
	"Method": "boolean isShorterThan(ReadableDuration duration){\r\n    if (duration == null) {\r\n        duration = Duration.ZERO;\r\n    }\r\n    return compareTo(duration) < 0;\r\n}"
}, {
	"Path": "org.jooq.impl.Tools.filterOne",
	"Comment": "get the only element from a list or null, or throw anexception",
	"Method": "R filterOne(List<R> list){\r\n    int size = list.size();\r\n    if (size == 0)\r\n        return null;\r\n    else if (size == 1)\r\n        return list.get(0);\r\n    else\r\n        throw new TooManyRowsException(\"Too many rows selected : \" + size);\r\n}"
}, {
	"Path": "org.joda.time.chrono.ISOChronology.writeReplace",
	"Comment": "serialize isochronology instances using a small stub. this reduces theserialized size, and deserialized instances come from the cache.",
	"Method": "Object writeReplace(){\r\n    return new Stub(getZone());\r\n}"
}, {
	"Path": "jodd.asm7.ModuleWriter.getAttributeCount",
	"Comment": "returns the number of module, modulepackages and modulemainclass attributes generated by thismodulewriter.",
	"Method": "int getAttributeCount(){\r\n    return 1 + (packageCount > 0 ? 1 : 0) + (mainClassIndex > 0 ? 1 : 0);\r\n}"
}, {
	"Path": "jodd.introspector.CtorDescriptor.getParameters",
	"Comment": "returns constructors parameters. the returned array\tis not cloned.",
	"Method": "Class[] getParameters(){\r\n    return parameters;\r\n}"
}, {
	"Path": "com.jayway.jsonpath.internal.function.PathFunctionFactory.newFunction",
	"Comment": "returns the function by name or throws invalidpathexception if function not found.",
	"Method": "PathFunction newFunction(String name){\r\n    Class functionClazz = FUNCTIONS.get(name);\r\n    if (functionClazz == null) {\r\n        throw new InvalidPathException(\"Function with name: \" + name + \" does not exist.\");\r\n    } else {\r\n        try {\r\n            return (PathFunction) functionClazz.newInstance();\r\n        } catch (Exception e) {\r\n            throw new InvalidPathException(\"Function of name: \" + name + \" cannot be created\", e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jooq.codegen.JavaGenerator.generateUDTInterfaceClassJavadoc",
	"Comment": "subclasses may override this method to provide their own javadoc.",
	"Method": "void generateUDTInterfaceClassJavadoc(UDTDefinition udt,JavaWriter out){\r\n    if (generateCommentsOnUDTs())\r\n        printClassJavadoc(out, udt);\r\n    else\r\n        printClassJavadoc(out, \"The udt <code>\" + udt.getQualifiedInputName() + \"<\/code>.\");\r\n}"
}, {
	"Path": "jodd.introspector.ClassDescriptor.getAllSuperclasses",
	"Comment": "returns all superclasses of this class.\tobject.class is not included in the\treturned list.",
	"Method": "Class[] getAllSuperclasses(){\r\n    return superclasses;\r\n}"
}, {
	"Path": "jodd.util.CollectionUtil.asIterator",
	"Comment": "adapt the specified enumeration to the iterator interface.",
	"Method": "Iterator<E> asIterator(Enumeration<E> e){\r\n    return new Iterator<E>() {\r\n        @Override\r\n        public boolean hasNext() {\r\n            return e.hasMoreElements();\r\n        }\r\n        @Override\r\n        public E next() {\r\n            if (!hasNext()) {\r\n                throw new NoSuchElementException();\r\n            }\r\n            return e.nextElement();\r\n        }\r\n        @Override\r\n        public void remove() {\r\n            throw new UnsupportedOperationException();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "jodd.util.CollectionUtil.asIterator",
	"Comment": "adapt the specified enumeration to the iterator interface.",
	"Method": "Iterator<E> asIterator(Enumeration<E> e){\r\n    return e.hasMoreElements();\r\n}"
}, {
	"Path": "jodd.util.CollectionUtil.asIterator",
	"Comment": "adapt the specified enumeration to the iterator interface.",
	"Method": "Iterator<E> asIterator(Enumeration<E> e){\r\n    if (!hasNext()) {\r\n        throw new NoSuchElementException();\r\n    }\r\n    return e.nextElement();\r\n}"
}, {
	"Path": "jodd.util.CollectionUtil.asIterator",
	"Comment": "adapt the specified enumeration to the iterator interface.",
	"Method": "Iterator<E> asIterator(Enumeration<E> e){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "org.joda.time.IllegalFieldValueException.getDateTimeFieldType",
	"Comment": "returns the datetimefieldtype whose value was invalid, or null if not applicable.",
	"Method": "DateTimeFieldType getDateTimeFieldType(){\r\n    return iDateTimeFieldType;\r\n}"
}, {
	"Path": "jodd.http.HttpRequest.create",
	"Comment": "generic request builder, usually used when method is a variable.\totherwise, use one of the other static request builder methods.",
	"Method": "HttpRequest create(String method,String destination){\r\n    return new HttpRequest().method(method.toUpperCase()).set(destination);\r\n}"
}, {
	"Path": "jodd.props.Props.countTotalProperties",
	"Comment": "counts the total number of properties, including all profiles.\tthis operation performs calculation each time and it might be\tmore time consuming then expected.",
	"Method": "int countTotalProperties(){\r\n    return data.countBaseProperties() + data.countProfileProperties();\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Database.isIncludePackageConstants",
	"Comment": "this flag indicates whether constants contained in packages should be included in output produced by this database",
	"Method": "Boolean isIncludePackageConstants(){\r\n    return includePackageConstants;\r\n}"
}, {
	"Path": "jodd.http.HttpBrowser.sendRequest",
	"Comment": "sends new request as a browser. before sending,\tall browser cookies are added to the request.\tafter sending, the cookies are read from the response.\tmoreover, status codes 301 and 302 are automatically\thandled. returns very last response.",
	"Method": "HttpResponse sendRequest(HttpRequest httpRequest){\r\n    elapsedTime = System.currentTimeMillis();\r\n    httpRequest.followRedirects(false);\r\n    while (true) {\r\n        this.httpRequest = httpRequest;\r\n        HttpResponse previousResponse = this.httpResponse;\r\n        this.httpResponse = null;\r\n        addDefaultHeaders(httpRequest);\r\n        addCookies(httpRequest);\r\n        if (catchTransportExceptions) {\r\n            try {\r\n                this.httpResponse = _sendRequest(httpRequest, previousResponse);\r\n            } catch (HttpException httpException) {\r\n                httpResponse = new HttpResponse();\r\n                httpResponse.assignHttpRequest(httpRequest);\r\n                httpResponse.statusCode(503);\r\n                httpResponse.statusPhrase(\"Service unavailable. \" + ExceptionUtil.message(httpException));\r\n            }\r\n        } else {\r\n            this.httpResponse = _sendRequest(httpRequest, previousResponse);\r\n        }\r\n        readCookies(httpResponse);\r\n        int statusCode = httpResponse.statusCode();\r\n        if (statusCode == 301) {\r\n            String newPath = httpResponse.location();\r\n            if (newPath == null) {\r\n                break;\r\n            }\r\n            httpRequest = HttpRequest.get(newPath);\r\n            continue;\r\n        }\r\n        if (statusCode == 302 || statusCode == 303) {\r\n            String newPath = httpResponse.location();\r\n            if (newPath == null) {\r\n                break;\r\n            }\r\n            httpRequest = HttpRequest.get(newPath);\r\n            continue;\r\n        }\r\n        if (statusCode == 307 || statusCode == 308) {\r\n            String newPath = httpResponse.location();\r\n            if (newPath == null) {\r\n                break;\r\n            }\r\n            String originalMethod = httpRequest.method();\r\n            httpRequest = new HttpRequest().method(originalMethod).set(newPath);\r\n            continue;\r\n        }\r\n        break;\r\n    }\r\n    elapsedTime = System.currentTimeMillis() - elapsedTime;\r\n    return this.httpResponse;\r\n}"
}, {
	"Path": "org.joda.time.PeriodType.yearMonthDayTime",
	"Comment": "gets a type that defines all standard fields except weeks.yearsmonthsdayshoursminutessecondsmilliseconds",
	"Method": "PeriodType yearMonthDayTime(){\r\n    PeriodType type = cYMDTime;\r\n    if (type == null) {\r\n        type = new PeriodType(\"YearMonthDayTime\", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.months(), DurationFieldType.days(), DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { 0, 1, -1, 2, 3, 4, 5, 6 });\r\n        cYMDTime = type;\r\n    }\r\n    return type;\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractInstant.toMutableDateTimeISO",
	"Comment": "get this object as a mutabledatetime using isochronology in the same zone.",
	"Method": "MutableDateTime toMutableDateTimeISO(){\r\n    return new MutableDateTime(getMillis(), ISOChronology.getInstance(getZone()));\r\n}"
}, {
	"Path": "jodd.servlet.SessionMonitor.iterator",
	"Comment": "returns iterator for all stored session ids.\tkeep in mind that session may not longer\texist during the iteration!",
	"Method": "Iterator<String> iterator(){\r\n    return sessionMap.keySet().iterator();\r\n}"
}, {
	"Path": "org.joda.time.Days.toStandardHours",
	"Comment": "converts this period in days to a period in hours assuming a24 hour day.this method allows you to convert between different types of period.however to achieve this it makes the assumption that all days are 24 hours long.this is not true when daylight savings is considered and may also notbe true for some unusual chronologies. however, it is includedas it is a useful operation for many applications and business rules.",
	"Method": "Hours toStandardHours(){\r\n    return Hours.hours(FieldUtils.safeMultiply(getValue(), DateTimeConstants.HOURS_PER_DAY));\r\n}"
}, {
	"Path": "org.joda.time.Minutes.toStandardWeeks",
	"Comment": "converts this period in minutes to a period in weeks assuming a7 days week, 24 hour day and 60 minute hour.this method allows you to convert between different types of period.however to achieve this it makes the assumption that all weeks are7 days long, all days are 24 hours long and all hours are 60 minutes long.this is not true when daylight savings is considered and may also notbe true for some unusual chronologies. however, it is includedas it is a useful operation for many applications and business rules.",
	"Method": "Weeks toStandardWeeks(){\r\n    return Weeks.weeks(getValue() / DateTimeConstants.MINUTES_PER_WEEK);\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.equals",
	"Comment": "compares this readablepartial with another returning true if the chronology,field types and values are equal.",
	"Method": "boolean equals(Object partial){\r\n    if (this == partial) {\r\n        return true;\r\n    }\r\n    if (partial instanceof LocalDateTime) {\r\n        LocalDateTime other = (LocalDateTime) partial;\r\n        if (iChronology.equals(other.iChronology)) {\r\n            return iLocalMillis == other.iLocalMillis;\r\n        }\r\n    }\r\n    return super.equals(partial);\r\n}"
}, {
	"Path": "org.joda.time.format.PeriodFormatter.getPrinter",
	"Comment": "gets the internal printer object that performs the real printing work.",
	"Method": "PeriodPrinter getPrinter(){\r\n    return iPrinter;\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractInstant.toMutableDateTime",
	"Comment": "get this object as a mutabledatetime using the given chronology and its zone.",
	"Method": "MutableDateTime toMutableDateTime(MutableDateTime toMutableDateTime,DateTimeZone zone,MutableDateTime toMutableDateTime,Chronology chronology){\r\n    return new MutableDateTime(getMillis(), chronology);\r\n}"
}, {
	"Path": "org.joda.time.PeriodType.dayTime",
	"Comment": "gets a type that defines all standard fields from days downwards.dayshoursminutessecondsmilliseconds",
	"Method": "PeriodType dayTime(){\r\n    PeriodType type = cDTime;\r\n    if (type == null) {\r\n        type = new PeriodType(\"DayTime\", new DurationFieldType[] { DurationFieldType.days(), DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { -1, -1, -1, 0, 1, 2, 3, 4 });\r\n        cDTime = type;\r\n    }\r\n    return type;\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractDuration.compareTo",
	"Comment": "compares this duration with the specified duration based on length and direction.the comparison takes into account the sign.as such, a duration of 5 seconds is longer than a duration of minus 7 seconds.",
	"Method": "int compareTo(ReadableDuration other){\r\n    long thisMillis = this.getMillis();\r\n    long otherMillis = other.getMillis();\r\n    if (thisMillis < otherMillis) {\r\n        return -1;\r\n    }\r\n    if (thisMillis > otherMillis) {\r\n        return 1;\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "jodd.madvoc.component.MadvocControllerCfg.setApplyCharacterEncoding",
	"Comment": "defines is character encoding has to be set by madvoc into the request and response.",
	"Method": "void setApplyCharacterEncoding(boolean applyCharacterEncoding){\r\n    this.applyCharacterEncoding = applyCharacterEncoding;\r\n}"
}, {
	"Path": "org.joda.time.convert.ConverterSet.selectSlow",
	"Comment": "returns the closest matching converter for the given type, but not veryefficiently.",
	"Method": "Converter selectSlow(ConverterSet set,Class<?> type){\r\n    Converter[] converters = set.iConverters;\r\n    int length = converters.length;\r\n    Converter converter;\r\n    for (int i = length; --i >= 0; ) {\r\n        converter = converters[i];\r\n        Class<?> supportedType = converter.getSupportedType();\r\n        if (supportedType == type) {\r\n            return converter;\r\n        }\r\n        if (supportedType == null || (type != null && !supportedType.isAssignableFrom(type))) {\r\n            set = set.remove(i, null);\r\n            converters = set.iConverters;\r\n            length = converters.length;\r\n        }\r\n    }\r\n    if (type == null || length == 0) {\r\n        return null;\r\n    }\r\n    if (length == 1) {\r\n        return converters[0];\r\n    }\r\n    for (int i = length; --i >= 0; ) {\r\n        converter = converters[i];\r\n        Class<?> supportedType = converter.getSupportedType();\r\n        for (int j = length; --j >= 0; ) {\r\n            if (j != i && converters[j].getSupportedType().isAssignableFrom(supportedType)) {\r\n                set = set.remove(j, null);\r\n                converters = set.iConverters;\r\n                length = converters.length;\r\n                i = length - 1;\r\n            }\r\n        }\r\n    }\r\n    if (length == 1) {\r\n        return converters[0];\r\n    }\r\n    StringBuilder msg = new StringBuilder();\r\n    msg.append(\"Unable to find best converter for type \\\"\");\r\n    msg.append(type.getName());\r\n    msg.append(\"\\\" from remaining set: \");\r\n    for (int i = 0; i < length; i++) {\r\n        converter = converters[i];\r\n        Class<?> supportedType = converter.getSupportedType();\r\n        msg.append(converter.getClass().getName());\r\n        msg.append('[');\r\n        msg.append(supportedType == null ? null : supportedType.getName());\r\n        msg.append(\"], \");\r\n    }\r\n    throw new IllegalStateException(msg.toString());\r\n}"
}, {
	"Path": "jodd.madvoc.config.Target.ofValue",
	"Comment": "creates a common target over a value, with known scope data.",
	"Method": "Target ofValue(Object value,ScopeData scopeData){\r\n    return new Target(value, null, scopeData, null, VALUE_INSTANCE_CREATOR);\r\n}"
}, {
	"Path": "jodd.util.StringUtil.compressChars",
	"Comment": "compress multiple occurrences of given char into one appearance.",
	"Method": "String compressChars(String s,char c){\r\n    int len = s.length();\r\n    StringBuilder sb = new StringBuilder(len);\r\n    boolean wasChar = false;\r\n    for (int i = 0; i < len; i++) {\r\n        char c1 = s.charAt(i);\r\n        if (c1 == c) {\r\n            if (wasChar) {\r\n                continue;\r\n            }\r\n            wasChar = true;\r\n        } else {\r\n            wasChar = false;\r\n        }\r\n        sb.append(c1);\r\n    }\r\n    if (sb.length() == len) {\r\n        return s;\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Configuration.getGenerator",
	"Comment": "the generator configuration element contains information about source code generation itself.",
	"Method": "Generator getGenerator(){\r\n    return generator;\r\n}"
}, {
	"Path": "org.joda.time.Period.withPeriodType",
	"Comment": "creates a new period instance with the same field values butdifferent periodtype.this period instance is immutable and unaffected by this method call.",
	"Method": "Period withPeriodType(PeriodType type){\r\n    type = DateTimeUtils.getPeriodType(type);\r\n    if (type.equals(getPeriodType())) {\r\n        return this;\r\n    }\r\n    return new Period(this, type);\r\n}"
}, {
	"Path": "jodd.vtor.ValidationConstraintContext.validateWithin",
	"Comment": "validates provided context and value withing this constraint content.",
	"Method": "void validateWithin(ValidationContext vctx,Object value){\r\n    vtor.validate(vctx, value, name);\r\n}"
}, {
	"Path": "jodd.util.collection.StringKeyedMapAdapter.clear",
	"Comment": "removes all attributes from the request as well as clears entries in this map.",
	"Method": "void clear(){\r\n    entries = null;\r\n    Iterator<String> keys = getAttributeNames();\r\n    while (keys.hasNext()) {\r\n        removeAttribute(keys.next());\r\n    }\r\n}"
}, {
	"Path": "jodd.jtx.JtxTransaction.requestResource",
	"Comment": "requests a resource. if resource is not found, it will be created and new transaction will be started on it.",
	"Method": "E requestResource(Class<E> resourceType){\r\n    if (isCompleted()) {\r\n        throw new JtxException(\"TX is already completed, resource are not available after commit or rollback\");\r\n    }\r\n    if (isRollbackOnly()) {\r\n        throw new JtxException(\"TX is marked as rollback only, resource are not available\", rollbackCause);\r\n    }\r\n    if (!isNoTransaction() && !isActive()) {\r\n        throw new JtxException(\"Resources are not available since TX is not active\");\r\n    }\r\n    checkTimeout();\r\n    E resource = lookupResource(resourceType);\r\n    if (resource == null) {\r\n        int maxResources = txManager.getMaxResourcesPerTransaction();\r\n        if ((maxResources != -1) && (resources.size() >= maxResources)) {\r\n            throw new JtxException(\"TX already has attached max. number of resources\");\r\n        }\r\n        JtxResourceManager<E> resourceManager = txManager.lookupResourceManager(resourceType);\r\n        resource = resourceManager.beginTransaction(mode, isActive());\r\n        resources.add(new JtxResource(this, resourceManager, resource));\r\n    }\r\n    return resource;\r\n}"
}, {
	"Path": "jodd.util.ResourceBundleMessageResolver.findMessage",
	"Comment": "finds messages in the provided bundle. if message not found, all parent bundles will be\texamined until the root bundle. at the end, if still no success, all default\tbundles will be examined. returns null if key is not found.",
	"Method": "String findMessage(String bundleName,Locale locale,String key){\r\n    String indexedKey = calcIndexKey(key);\r\n    String name = bundleName;\r\n    while (true) {\r\n        String msg = getMessage(name, locale, key, indexedKey);\r\n        if (msg != null) {\r\n            return msg;\r\n        }\r\n        if (bundleName == null || bundleName.length() == 0) {\r\n            break;\r\n        }\r\n        int ndx = bundleName.lastIndexOf('.');\r\n        if (ndx == -1) {\r\n            bundleName = null;\r\n            name = fallbackBundlename;\r\n        } else {\r\n            bundleName = bundleName.substring(0, ndx);\r\n            name = bundleName + '.' + fallbackBundlename;\r\n        }\r\n    }\r\n    for (String bname : defaultBundles) {\r\n        String msg = getMessage(bname, locale, key, indexedKey);\r\n        if (msg != null) {\r\n            return msg;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.joda.time.convert.ConverterManager.addDurationConverter",
	"Comment": "adds a converter to the set of converters. if a matching converter isalready in the set, the given converter replaces it. if the converter isexactly the same as one already in the set, no changes are made.the order in which converters are added is not relevant. the bestconverter is selected by examining the object hierarchy.",
	"Method": "DurationConverter addDurationConverter(DurationConverter converter){\r\n    checkAlterDurationConverters();\r\n    if (converter == null) {\r\n        return null;\r\n    }\r\n    DurationConverter[] removed = new DurationConverter[1];\r\n    iDurationConverters = iDurationConverters.add(converter, removed);\r\n    return removed[0];\r\n}"
}, {
	"Path": "org.joda.time.PeriodType.withYearsRemoved",
	"Comment": "returns a version of this periodtype instance that does not support years.",
	"Method": "PeriodType withYearsRemoved(){\r\n    return withFieldRemoved(0, \"NoYears\");\r\n}"
}, {
	"Path": "jodd.util.Util.toString",
	"Comment": "returns string representation of an object, while checking for null.",
	"Method": "String toString(Object value){\r\n    if (value == null) {\r\n        return null;\r\n    }\r\n    return value.toString();\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.hw.EncoderDebugger.compareLumaPanes",
	"Comment": "compares the y pane of the initial image, and the y pane\tafter having encoded & decoded the image.",
	"Method": "boolean compareLumaPanes(){\r\n    int d, e, f = 0;\r\n    for (int j = 0; j < NB_DECODED; j++) {\r\n        for (int i = 0; i < mSize; i += 10) {\r\n            d = (mInitialImage[i] & 0xFF) - (mDecodedVideo[j][i] & 0xFF);\r\n            e = (mInitialImage[i + 1] & 0xFF) - (mDecodedVideo[j][i + 1] & 0xFF);\r\n            d = d < 0 ? -d : d;\r\n            e = e < 0 ? -e : e;\r\n            if (d > 50 && e > 50) {\r\n                mDecodedVideo[j] = null;\r\n                f++;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return f <= NB_DECODED / 2;\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractInterval.toString",
	"Comment": "output a string in iso8601 interval format.from version 2.1, the string includes the time zone offset.",
	"Method": "String toString(){\r\n    DateTimeFormatter printer = ISODateTimeFormat.dateTime();\r\n    printer = printer.withChronology(getChronology());\r\n    StringBuffer buf = new StringBuffer(48);\r\n    printer.printTo(buf, getStartMillis());\r\n    buf.append('/');\r\n    printer.printTo(buf, getEndMillis());\r\n    return buf.toString();\r\n}"
}, {
	"Path": "org.jooq.impl.Tools.increment",
	"Comment": "increment a counter and return true if the counter was zero prior toincrementing.",
	"Method": "boolean increment(Map<Object, Object> data,DataKey key){\r\n    boolean result = true;\r\n    Integer updateCounts = (Integer) data.get(key);\r\n    if (updateCounts == null)\r\n        updateCounts = 0;\r\n    else\r\n        result = false;\r\n    data.put(key, updateCounts + 1);\r\n    return result;\r\n}"
}, {
	"Path": "jodd.inex.InExRules.apply",
	"Comment": "applies rules on given flag. flag is only changed if at least one rule\tmatched. otherwise, the same value is returned. this way you can\tchain several rules and have the rule engine change the flag\tonly when a rule is matched.",
	"Method": "boolean apply(V value,boolean flag,boolean apply,V value,boolean blacklist,boolean flag){\r\n    if (rules == null) {\r\n        return flag;\r\n    }\r\n    if (blacklist) {\r\n        flag = processExcludes(value, flag);\r\n        flag = processIncludes(value, flag);\r\n    } else {\r\n        flag = processIncludes(value, flag);\r\n        flag = processExcludes(value, flag);\r\n    }\r\n    return flag;\r\n}"
}, {
	"Path": "jodd.util.CharUtil.toSimpleCharArray",
	"Comment": "converts byte array to char array by simply extending bytes to chars.",
	"Method": "char[] toSimpleCharArray(byte[] barr){\r\n    char[] carr = new char[barr.length];\r\n    for (int i = 0; i < barr.length; i++) {\r\n        carr[i] = (char) (barr[i] & 0xFF);\r\n    }\r\n    return carr;\r\n}"
}, {
	"Path": "jodd.util.Format.toPrettyString",
	"Comment": "converts object into pretty string. all arrays are iterated.",
	"Method": "String toPrettyString(Object value){\r\n    if (value == null) {\r\n        return StringPool.NULL;\r\n    }\r\n    final Class<?> type = value.getClass();\r\n    if (type.isArray()) {\r\n        final Class componentType = type.getComponentType();\r\n        if (componentType.isPrimitive()) {\r\n            final StringBuilder sb = new StringBuilder();\r\n            sb.append('[');\r\n            if (componentType == int.class) {\r\n                sb.append(ArraysUtil.toString((int[]) value));\r\n            } else if (componentType == long.class) {\r\n                sb.append(ArraysUtil.toString((long[]) value));\r\n            } else if (componentType == double.class) {\r\n                sb.append(ArraysUtil.toString((double[]) value));\r\n            } else if (componentType == float.class) {\r\n                sb.append(ArraysUtil.toString((float[]) value));\r\n            } else if (componentType == boolean.class) {\r\n                sb.append(ArraysUtil.toString((boolean[]) value));\r\n            } else if (componentType == short.class) {\r\n                sb.append(ArraysUtil.toString((short[]) value));\r\n            } else if (componentType == byte.class) {\r\n                sb.append(ArraysUtil.toString((byte[]) value));\r\n            } else {\r\n                throw new IllegalArgumentException();\r\n            }\r\n            sb.append(']');\r\n            return sb.toString();\r\n        } else {\r\n            final StringBuilder sb = new StringBuilder();\r\n            sb.append('[');\r\n            final Object[] array = (Object[]) value;\r\n            for (int i = 0; i < array.length; i++) {\r\n                if (i > 0) {\r\n                    sb.append(',');\r\n                }\r\n                sb.append(toPrettyString(array[i]));\r\n            }\r\n            sb.append(']');\r\n            return sb.toString();\r\n        }\r\n    } else if (value instanceof Iterable) {\r\n        final Iterable iterable = (Iterable) value;\r\n        final StringBuilder sb = new StringBuilder();\r\n        sb.append('{');\r\n        int i = 0;\r\n        for (final Object o : iterable) {\r\n            if (i > 0) {\r\n                sb.append(',');\r\n            }\r\n            sb.append(toPrettyString(o));\r\n            i++;\r\n        }\r\n        sb.append('}');\r\n        return sb.toString();\r\n    }\r\n    return value.toString();\r\n}"
}, {
	"Path": "org.jooq.conf.Settings.getQueryPoolable",
	"Comment": "the default jdbc poolable property that should be applied to alljooq queries, for which no specific poolable flag was specified.",
	"Method": "QueryPoolable getQueryPoolable(){\r\n    return queryPoolable;\r\n}"
}, {
	"Path": "jodd.json.meta.JsonAnnotationManager.findSubclassTypeData",
	"Comment": "finds type data of first annotated superclass or interface.",
	"Method": "TypeData findSubclassTypeData(Class type){\r\n    final Class<? extends Annotation> defaultAnnotation = jsonAnnotation;\r\n    if (type.getAnnotation(defaultAnnotation) != null) {\r\n        return null;\r\n    }\r\n    ClassDescriptor cd = ClassIntrospector.get().lookup(type);\r\n    Class[] superClasses = cd.getAllSuperclasses();\r\n    for (Class superClass : superClasses) {\r\n        if (superClass.getAnnotation(defaultAnnotation) != null) {\r\n            return _lookupTypeData(superClass);\r\n        }\r\n    }\r\n    Class[] interfaces = cd.getAllInterfaces();\r\n    for (Class interfaze : interfaces) {\r\n        if (interfaze.getAnnotation(defaultAnnotation) != null) {\r\n            return _lookupTypeData(interfaze);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.joda.time.DateMidnight.dayOfWeek",
	"Comment": "get the day of week property which provides access to advanced functionality.",
	"Method": "Property dayOfWeek(){\r\n    return new Property(this, getChronology().dayOfWeek());\r\n}"
}, {
	"Path": "org.joda.time.format.PeriodFormatter.withParseType",
	"Comment": "returns a new formatter with a different periodtype for parsing.a periodformatter is immutable, so a new instance is returned,and the original is unaltered and still usable.",
	"Method": "PeriodFormatter withParseType(PeriodType type){\r\n    if (type == iParseType) {\r\n        return this;\r\n    }\r\n    return new PeriodFormatter(iPrinter, iParser, iLocale, type);\r\n}"
}, {
	"Path": "jodd.servlet.wrapper.BufferResponseWrapper.getWriter",
	"Comment": "returns buffered writer if buffering is enabled,\totherwise returns the original writer.",
	"Method": "PrintWriter getWriter(){\r\n    preResponseCommit();\r\n    if (buffer == null) {\r\n        return getResponse().getWriter();\r\n    }\r\n    return buffer.getWriter();\r\n}"
}, {
	"Path": "jodd.servlet.wrapper.BufferResponseWrapper.enableBuffering",
	"Comment": "enables buffering by transferring the output to the buffer.",
	"Method": "void enableBuffering(){\r\n    if (buffer != null) {\r\n        return;\r\n    }\r\n    buffer = new Buffer();\r\n}"
}, {
	"Path": "org.joda.time.YearMonthDay.getField",
	"Comment": "gets the field for a specific index in the chronology specified.this method must not use any instance variables.",
	"Method": "DateTimeField getField(int index,Chronology chrono,DateTimeField getField){\r\n    switch(index) {\r\n        case YEAR:\r\n            return chrono.year();\r\n        case MONTH_OF_YEAR:\r\n            return chrono.monthOfYear();\r\n        case DAY_OF_MONTH:\r\n            return chrono.dayOfMonth();\r\n        default:\r\n            throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\r\n    }\r\n}"
}, {
	"Path": "jodd.typeconverter.TypeConverterManager.lookup",
	"Comment": "retrieves converter for provided type. only registered types are matched,\ttherefore subclasses must be also registered.",
	"Method": "TypeConverter<T> lookup(Class<T> type){\r\n    return converters.get(type);\r\n}"
}, {
	"Path": "jodd.csselly.CssSelector.unescape",
	"Comment": "unescapes css string by removing all backslash characters from it.",
	"Method": "String unescape(String value){\r\n    if (value.indexOf('\\\\') == -1) {\r\n        return value;\r\n    }\r\n    return StringUtil.remove(value, '\\\\');\r\n}"
}, {
	"Path": "jodd.jerry.Jerry.prevAll",
	"Comment": "get all preceding siblings of each element in the set of matched \telements, optionally filtered by a selector.",
	"Method": "Jerry prevAll(){\r\n    List<Node> result = new NodeList(nodes.length);\r\n    if (nodes.length > 0) {\r\n        for (Node node : nodes) {\r\n            Node currentSiblingElement = node.getPreviousSiblingElement();\r\n            while (currentSiblingElement != null) {\r\n                result.add(currentSiblingElement);\r\n                currentSiblingElement = currentSiblingElement.getPreviousSiblingElement();\r\n            }\r\n        }\r\n    }\r\n    return new Jerry(this, result);\r\n}"
}, {
	"Path": "org.joda.time.chrono.BaseChronology.add",
	"Comment": "adds the duration to the instant, specifying the number of times to add.",
	"Method": "long add(ReadablePeriod period,long instant,int scalar,long add,long instant,long duration,int scalar){\r\n    if (duration == 0 || scalar == 0) {\r\n        return instant;\r\n    }\r\n    long add = FieldUtils.safeMultiply(duration, scalar);\r\n    return FieldUtils.safeAdd(instant, add);\r\n}"
}, {
	"Path": "jodd.servlet.upload.MultipartRequestWrapper.getFileParameterNames",
	"Comment": "get an enumeration of the parameter names for uploaded files",
	"Method": "Enumeration<String> getFileParameterNames(){\r\n    if (mreq == null) {\r\n        return null;\r\n    }\r\n    return Collections.enumeration(mreq.getFileParameterNames());\r\n}"
}, {
	"Path": "jodd.decora.DecoraServletFilter.createDecoraManager",
	"Comment": "creates decora manager. override to provide custom decora manager.\talternatively, set it in filter init parameters.",
	"Method": "DecoraManager createDecoraManager(){\r\n    return new DecoraManager();\r\n}"
}, {
	"Path": "jodd.io.upload.MultipartStreamParser.setParsed",
	"Comment": "sets the loaded flag that indicates that input stream is loaded and parsed.\tthrows an exception if stream already loaded.",
	"Method": "void setParsed(){\r\n    if (parsed) {\r\n        throw new IOException(\"Multi-part request already parsed\");\r\n    }\r\n    parsed = true;\r\n}"
}, {
	"Path": "jodd.madvoc.result.ServletRedirectActionResult.render",
	"Comment": "redirects to the given location. provided path is parsed, action is used as a value context.",
	"Method": "void render(ActionRequest actionRequest,Object resultValue){\r\n    final Redirect redirectResult;\r\n    if (resultValue == null) {\r\n        redirectResult = Redirect.to(StringPool.EMPTY);\r\n    } else {\r\n        if (resultValue instanceof String) {\r\n            redirectResult = Redirect.to((String) resultValue);\r\n        } else {\r\n            redirectResult = (Redirect) resultValue;\r\n        }\r\n    }\r\n    final String resultBasePath = actionRequest.getActionRuntime().getResultBasePath();\r\n    final String redirectPath = redirectResult.path();\r\n    final String resultPath;\r\n    if (redirectPath.startsWith(\"http://\") || redirectPath.startsWith(\"https://\")) {\r\n        resultPath = redirectPath;\r\n    } else {\r\n        resultPath = resultMapper.resolveResultPathString(resultBasePath, redirectPath);\r\n    }\r\n    HttpServletRequest request = actionRequest.getHttpServletRequest();\r\n    HttpServletResponse response = actionRequest.getHttpServletResponse();\r\n    String path = resultPath;\r\n    path = beanTemplateParser.parseWithBean(path, actionRequest.getAction());\r\n    DispatcherUtil.redirect(request, response, path);\r\n}"
}, {
	"Path": "org.jooq.codegen.JavaGenerator.generateUDTPojoGetter",
	"Comment": "subclasses may override this method to provide their own pojo getters.",
	"Method": "void generateUDTPojoGetter(TypedElementDefinition<?> column,int index,JavaWriter out){\r\n    generatePojoGetter0(column, index, out);\r\n}"
}, {
	"Path": "org.jooq.codegen.JavaGenerator.generatePojoClassJavadoc",
	"Comment": "subclasses may override this method to provide their own javadoc.",
	"Method": "void generatePojoClassJavadoc(TableDefinition table,JavaWriter out){\r\n    if (generateCommentsOnTables())\r\n        printClassJavadoc(out, table);\r\n    else\r\n        printClassJavadoc(out, \"The table <code>\" + table.getQualifiedInputName() + \"<\/code>.\");\r\n}"
}, {
	"Path": "org.joda.time.Duration.negated",
	"Comment": "returns a new duration with this length negated.this instance is immutable and is not altered.",
	"Method": "Duration negated(){\r\n    if (getMillis() == Long.MIN_VALUE) {\r\n        throw new ArithmeticException(\"Negation of this duration would overflow\");\r\n    }\r\n    return new Duration(-getMillis());\r\n}"
}, {
	"Path": "org.joda.time.DateTime.withChronology",
	"Comment": "returns a copy of this datetime with a different chronology.the returned object will be either be a new instance or this.only the chronology will change, the millis are kept.",
	"Method": "DateTime withChronology(Chronology newChronology){\r\n    newChronology = DateTimeUtils.getChronology(newChronology);\r\n    return (newChronology == getChronology() ? this : new DateTime(getMillis(), newChronology));\r\n}"
}, {
	"Path": "org.joda.time.DateTime.minuteOfDay",
	"Comment": "get the minute of day property which provides access to advanced functionality.",
	"Method": "Property minuteOfDay(){\r\n    return new Property(this, getChronology().minuteOfDay());\r\n}"
}, {
	"Path": "jodd.util.CharUtil.toCharArray",
	"Comment": "converts byte array of default jodd encoding to char array.",
	"Method": "char[] toCharArray(byte[] barr,char[] toCharArray,byte[] barr,String charset){\r\n    return StringUtil.newString(barr, charset).toCharArray();\r\n}"
}, {
	"Path": "jodd.asm7.SymbolTable.getSource",
	"Comment": "returns the classreader from which this symboltable was constructed.",
	"Method": "ClassReader getSource(){\r\n    return sourceClassReader;\r\n}"
}, {
	"Path": "org.jooq.JSONFormat.indentString",
	"Comment": "convenience method to get an indentation string at a given level.",
	"Method": "String indentString(int level){\r\n    if (level < indented.length)\r\n        return indented[level];\r\n    else if (format)\r\n        return rightPad(\"\", indent * level);\r\n    else\r\n        return \"\";\r\n}"
}, {
	"Path": "org.joda.time.field.RemainderDateTimeField.addWrapField",
	"Comment": "add the specified amount to the specified time instant, wrapping aroundwithin the remainder range if necessary. the amount added may benegative.",
	"Method": "long addWrapField(long instant,int amount){\r\n    return set(instant, FieldUtils.getWrappedValue(get(instant), amount, 0, iDivisor - 1));\r\n}"
}, {
	"Path": "org.joda.time.base.BaseDateTime.checkChronology",
	"Comment": "checks the specified chronology before storing it, potentially altering it.this method must not access any instance variables.this implementation converts nulls to isochronology in the default zone.",
	"Method": "Chronology checkChronology(Chronology chronology){\r\n    return DateTimeUtils.getChronology(chronology);\r\n}"
}, {
	"Path": "jodd.decora.parser.DecoraTag.startRegion",
	"Comment": "starts defining region by setting the start index and reset region length to zero.",
	"Method": "void startRegion(int start,int tagLen,int deepLevel){\r\n    this.regionStart = start + tagLen;\r\n    this.regionLength = 0;\r\n    this.regionTagStart = start;\r\n    this.deepLevel = deepLevel;\r\n}"
}, {
	"Path": "jodd.jerry.Jerry.css",
	"Comment": "sets one or more css properties for the set of matched elements.",
	"Method": "String css(String propertyName,Jerry css,String propertyName,String value,Jerry css,String css){\r\n    if (nodes.length == 0) {\r\n        return this;\r\n    }\r\n    for (Node node : nodes) {\r\n        String styleAttrValue = node.getAttribute(\"style\");\r\n        Map<String, String> styles = createPropertiesMap(styleAttrValue, ';', ':');\r\n        for (int i = 0; i < css.length; i += 2) {\r\n            String propertyName = css[i];\r\n            propertyName = Format.fromCamelCase(propertyName, '-');\r\n            String value = css[i + 1];\r\n            if (value.length() == 0) {\r\n                styles.remove(propertyName);\r\n            } else {\r\n                styles.put(propertyName, value);\r\n            }\r\n        }\r\n        styleAttrValue = generateAttributeValue(styles, ';', ':');\r\n        node.setAttribute(\"style\", styleAttrValue);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.jooq.impl.DSL.timestampDiff",
	"Comment": "get the timestamp difference as a interval day to secondtype.this translates into any dialect",
	"Method": "Field<DayToSecond> timestampDiff(Timestamp timestamp1,Timestamp timestamp2,Field<DayToSecond> timestampDiff,Field<Timestamp> timestamp1,Timestamp timestamp2,Field<DayToSecond> timestampDiff,Timestamp timestamp1,Field<Timestamp> timestamp2,Field<DayToSecond> timestampDiff,Field<Timestamp> timestamp1,Field<Timestamp> timestamp2){\r\n    return new TimestampDiff(nullSafe(timestamp1), nullSafe(timestamp2));\r\n}"
}, {
	"Path": "org.jsonschema2pojo.rules.TitleRule.apply",
	"Comment": "applies this schema rule to take the required code generation steps.when a title node is found and applied with this rule, the value of thetitle is added as a javadoc comment. this rule is typically applied tothe generated field, generated getter and generated setter for theproperty.note that the title is always inserted at the top of the javadoc comment.",
	"Method": "JDocComment apply(String nodeName,JsonNode node,JsonNode parent,JDocCommentable generatableType,Schema schema){\r\n    JDocComment javadoc = generatableType.javadoc();\r\n    javadoc.add(0, node.asText() + \"\\n<p>\\n\");\r\n    return javadoc;\r\n}"
}, {
	"Path": "org.joda.time.Period.withFieldAdded",
	"Comment": "creates a new period instance with the valuetoadd added to the specified field.this period instance is immutable and unaffected by this method call.",
	"Method": "Period withFieldAdded(DurationFieldType field,int value){\r\n    if (field == null) {\r\n        throw new IllegalArgumentException(\"Field must not be null\");\r\n    }\r\n    if (value == 0) {\r\n        return this;\r\n    }\r\n    int[] newValues = getValues();\r\n    super.addFieldInto(newValues, field, value);\r\n    return new Period(newValues, getPeriodType());\r\n}"
}, {
	"Path": "jodd.introspector.ClassDescriptor.getMethods",
	"Comment": "returns methods collection.\tcreates new collection on first access.",
	"Method": "Methods getMethods(){\r\n    if (methods == null) {\r\n        methods = new Methods(this);\r\n    }\r\n    return methods;\r\n}"
}, {
	"Path": "org.joda.time.base.BaseDuration.toPeriodFrom",
	"Comment": "converts this duration to a period instance by adding the duration to a startinstant to obtain an interval.this conversion will determine the fields of a period accurately.the results are based on the instant millis, the chronology of the instant,the period type and the length of this duration.",
	"Method": "Period toPeriodFrom(ReadableInstant startInstant,Period toPeriodFrom,ReadableInstant startInstant,PeriodType type){\r\n    return new Period(startInstant, this, type);\r\n}"
}, {
	"Path": "org.joda.time.Hours.hours",
	"Comment": "obtains an instance of hours that may be cached.hours is immutable, so instances can be cached and shared.this factory method provides access to shared instances.",
	"Method": "Hours hours(int hours){\r\n    switch(hours) {\r\n        case 0:\r\n            return ZERO;\r\n        case 1:\r\n            return ONE;\r\n        case 2:\r\n            return TWO;\r\n        case 3:\r\n            return THREE;\r\n        case 4:\r\n            return FOUR;\r\n        case 5:\r\n            return FIVE;\r\n        case 6:\r\n            return SIX;\r\n        case 7:\r\n            return SEVEN;\r\n        case 8:\r\n            return EIGHT;\r\n        case Integer.MAX_VALUE:\r\n            return MAX_VALUE;\r\n        case Integer.MIN_VALUE:\r\n            return MIN_VALUE;\r\n        default:\r\n            return new Hours(hours);\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.Days.standardDaysIn",
	"Comment": "creates a new days representing the number of completestandard length days in the specified period.this factory method converts all fields from the period to hours using standardiseddurations for each field. only those fields which have a precise duration inthe iso utc chronology can be converted.one week consists of 7 days.one day consists of 24 hours.one hour consists of 60 minutes.one minute consists of 60 seconds.one second consists of 1000 milliseconds.months and years are imprecise and periods containing these values cannot be converted.",
	"Method": "Days standardDaysIn(ReadablePeriod period){\r\n    int amount = BaseSingleFieldPeriod.standardPeriodIn(period, DateTimeConstants.MILLIS_PER_DAY);\r\n    return Days.days(amount);\r\n}"
}, {
	"Path": "org.jooq.tools.json.Yylex.yytext",
	"Comment": "returns the text matched by the current regular expression.",
	"Method": "String yytext(){\r\n    return new String(zzBuffer, zzStartRead, zzMarkedPos - zzStartRead);\r\n}"
}, {
	"Path": "jodd.db.type.SqlTypeManager.lookupSqlType",
	"Comment": "returns sql type instance. instances are stored for better performances.",
	"Method": "SqlType lookupSqlType(Class<? extends SqlType> sqlTypeClass){\r\n    SqlType sqlType = sqlTypes.get(sqlTypeClass);\r\n    if (sqlType == null) {\r\n        try {\r\n            sqlType = ClassUtil.newInstance(sqlTypeClass);\r\n        } catch (Exception ex) {\r\n            throw new DbSqlException(\"SQL type not found: \" + sqlTypeClass.getSimpleName(), ex);\r\n        }\r\n        sqlTypes.put(sqlTypeClass, sqlType);\r\n    }\r\n    return sqlType;\r\n}"
}, {
	"Path": "jodd.json.MapToBean.generifyList",
	"Comment": "converts type of all list elements to match the component type.",
	"Method": "Object generifyList(List list,Class componentType){\r\n    for (int i = 0; i < list.size(); i++) {\r\n        Object element = list.get(i);\r\n        if (element != null) {\r\n            if (element instanceof Map) {\r\n                Object bean = map2bean((Map) element, componentType);\r\n                list.set(i, bean);\r\n            } else {\r\n                Object value = convert(element, componentType);\r\n                list.set(i, value);\r\n            }\r\n        }\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "org.joda.time.field.BaseDurationField.getValueAsLong",
	"Comment": "get the value of this field from the milliseconds, which is approximateif this field is imprecise.",
	"Method": "long getValueAsLong(long duration){\r\n    return duration / getUnitMillis();\r\n}"
}, {
	"Path": "org.joda.time.Seconds.standardSecondsIn",
	"Comment": "creates a new seconds representing the number of completestandard length seconds in the specified period.this factory method converts all fields from the period to hours using standardiseddurations for each field. only those fields which have a precise duration inthe iso utc chronology can be converted.one week consists of 7 days.one day consists of 24 hours.one hour consists of 60 minutes.one minute consists of 60 seconds.one second consists of 1000 milliseconds.months and years are imprecise and periods containing these values cannot be converted.",
	"Method": "Seconds standardSecondsIn(ReadablePeriod period){\r\n    int amount = BaseSingleFieldPeriod.standardPeriodIn(period, DateTimeConstants.MILLIS_PER_SECOND);\r\n    return Seconds.seconds(amount);\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.hw.EncoderDebugger.createTestImage",
	"Comment": "creates the test image that will be used to feed the encoder.",
	"Method": "void createTestImage(){\r\n    mInitialImage = new byte[3 * mSize / 2];\r\n    for (int i = 0; i < mSize; i++) {\r\n        mInitialImage[i] = (byte) (40 + i % 199);\r\n    }\r\n    for (int i = mSize; i < 3 * mSize / 2; i += 2) {\r\n        mInitialImage[i] = (byte) (40 + i % 200);\r\n        mInitialImage[i + 1] = (byte) (40 + (i + 99) % 200);\r\n    }\r\n}"
}, {
	"Path": "jodd.util.StringBand.expandCapacity",
	"Comment": "expands internal string array by multiplying its size by 2.",
	"Method": "void expandCapacity(){\r\n    String[] newArray = new String[array.length << 1];\r\n    System.arraycopy(array, 0, newArray, 0, index);\r\n    array = newArray;\r\n}"
}, {
	"Path": "jodd.db.pool.CoreConnectionPool.isConnectionValid",
	"Comment": "checks if existing connection is valid and available. it may happens\tthat if connection is not used for a while it becomes inactive,\talthough not technically closed.",
	"Method": "boolean isConnectionValid(ConnectionData connectionData,long now){\r\n    if (!validateConnection) {\r\n        return true;\r\n    }\r\n    if (now < connectionData.lastUsed + validationTimeout) {\r\n        return true;\r\n    }\r\n    Connection conn = connectionData.connection;\r\n    if (validationQuery == null) {\r\n        try {\r\n            return !conn.isClosed();\r\n        } catch (SQLException sex) {\r\n            return false;\r\n        }\r\n    }\r\n    boolean valid = true;\r\n    Statement st = null;\r\n    try {\r\n        st = conn.createStatement();\r\n        st.execute(validationQuery);\r\n    } catch (SQLException sex) {\r\n        valid = false;\r\n    } finally {\r\n        if (st != null) {\r\n            try {\r\n                st.close();\r\n            } catch (SQLException ignore) {\r\n            }\r\n        }\r\n    }\r\n    return valid;\r\n}"
}, {
	"Path": "jodd.jerry.Jerry.contents",
	"Comment": "get the children of each element in the set of matched elements, \t including text and comment nodes.",
	"Method": "Jerry contents(){\r\n    List<Node> result = new NodeList(nodes.length);\r\n    if (nodes.length > 0) {\r\n        for (Node node : nodes) {\r\n            Node[] contents = node.getChildNodes();\r\n            Collections.addAll(result, contents);\r\n        }\r\n    }\r\n    return new Jerry(this, result);\r\n}"
}, {
	"Path": "jodd.introspector.Methods.getAllMethodDescriptors",
	"Comment": "returns all methods for given name. returns null if method not found.",
	"Method": "MethodDescriptor[] getAllMethodDescriptors(String name,MethodDescriptor[] getAllMethodDescriptors){\r\n    if (allMethods == null) {\r\n        List<MethodDescriptor> allMethodsList = new ArrayList();\r\n        for (MethodDescriptor[] methodDescriptors : methodsMap.values()) {\r\n            Collections.addAll(allMethodsList, methodDescriptors);\r\n        }\r\n        MethodDescriptor[] allMethods = allMethodsList.toArray(new MethodDescriptor[0]);\r\n        Arrays.sort(allMethods, new Comparator<MethodDescriptor>() {\r\n            @Override\r\n            public int compare(final MethodDescriptor md1, final MethodDescriptor md2) {\r\n                return md1.getMethod().getName().compareTo(md2.getMethod().getName());\r\n            }\r\n        });\r\n        this.allMethods = allMethods;\r\n    }\r\n    return allMethods;\r\n}"
}, {
	"Path": "jodd.introspector.Methods.getAllMethodDescriptors",
	"Comment": "returns all methods for given name. returns null if method not found.",
	"Method": "MethodDescriptor[] getAllMethodDescriptors(String name,MethodDescriptor[] getAllMethodDescriptors){\r\n    return md1.getMethod().getName().compareTo(md2.getMethod().getName());\r\n}"
}, {
	"Path": "jodd.db.debug.BaseLoggableFactory.getQueryString",
	"Comment": "returns the query string from loggable wrapped statement.",
	"Method": "String getQueryString(T statement){\r\n    try {\r\n        return (String) getQueryStringMethod.invoke(statement);\r\n    } catch (Exception ex) {\r\n        throw new DbSqlException(ex);\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.format.PeriodFormatterBuilder.appendSuffix",
	"Comment": "append a field suffix which applies only to the last appended field. ifthe field is not printed, neither is the suffix.",
	"Method": "PeriodFormatterBuilder appendSuffix(String text,PeriodFormatterBuilder appendSuffix,String singularText,String pluralText,PeriodFormatterBuilder appendSuffix,String[] regularExpressions,String[] suffixes,PeriodFormatterBuilder appendSuffix,PeriodFieldAffix suffix){\r\n    final Object originalPrinter;\r\n    final Object originalParser;\r\n    if (iElementPairs.size() > 0) {\r\n        originalPrinter = iElementPairs.get(iElementPairs.size() - 2);\r\n        originalParser = iElementPairs.get(iElementPairs.size() - 1);\r\n    } else {\r\n        originalPrinter = null;\r\n        originalParser = null;\r\n    }\r\n    if (originalPrinter == null || originalParser == null || originalPrinter != originalParser || !(originalPrinter instanceof FieldFormatter)) {\r\n        throw new IllegalStateException(\"No field to apply suffix to\");\r\n    }\r\n    clearPrefix();\r\n    FieldFormatter newField = new FieldFormatter((FieldFormatter) originalPrinter, suffix);\r\n    iElementPairs.set(iElementPairs.size() - 2, newField);\r\n    iElementPairs.set(iElementPairs.size() - 1, newField);\r\n    iFieldFormatters[newField.getFieldType()] = newField;\r\n    return this;\r\n}"
}, {
	"Path": "jodd.io.upload.impl.AdaptiveFileUploadFactory.setFileExtensions",
	"Comment": "allow or disallow set of file extensions. only one rule can be active at time,\twhich means user can only specify extensions that are either allowed or disallowed.\tsetting this value to null will turn this feature off.",
	"Method": "AdaptiveFileUploadFactory setFileExtensions(String[] fileExtensions,boolean allow){\r\n    this.fileExtensions = fileExtensions;\r\n    this.allowFileExtensions = allow;\r\n    return this;\r\n}"
}, {
	"Path": "org.jooq.impl.Expression.rhsAsNumber",
	"Comment": "in some expressions, the rhs can be safely assumed to be a single number",
	"Method": "Field<Number> rhsAsNumber(Field<Number> rhsAsNumber){\r\n    return (Field<Number>) rhs.get(0);\r\n}"
}, {
	"Path": "org.json.JSONWriter.key",
	"Comment": "append a key. the key will be associated with the next value. in anobject, every value must be preceded by a key.",
	"Method": "JSONWriter key(String string){\r\n    if (string == null) {\r\n        throw new JSONException(\"Null key.\");\r\n    }\r\n    if (this.mode == 'k') {\r\n        try {\r\n            JSONObject topObject = this.stack[this.top - 1];\r\n            if (topObject.has(string)) {\r\n                throw new JSONException(\"Duplicate key \\\"\" + string + \"\\\"\");\r\n            }\r\n            topObject.put(string, true);\r\n            if (this.comma) {\r\n                this.writer.append(',');\r\n            }\r\n            this.writer.append(JSONObject.quote(string));\r\n            this.writer.append(':');\r\n            this.comma = false;\r\n            this.mode = 'o';\r\n            return this;\r\n        } catch (IOException e) {\r\n            throw new JSONException(e);\r\n        }\r\n    }\r\n    throw new JSONException(\"Misplaced key.\");\r\n}"
}, {
	"Path": "jodd.proxetta.ProxettaFactory.setTarget",
	"Comment": "defines class name as a target.\tclass will not be loaded by classloader!",
	"Method": "T setTarget(InputStream target,T setTarget,String targetName,T setTarget,Class target){\r\n    assertTargetIsNotDefined();\r\n    try {\r\n        targetInputStream = ClassLoaderUtil.getClassAsStream(target);\r\n        if (targetInputStream == null) {\r\n            throw new ProxettaException(\"Target class not found: \" + target.getName());\r\n        }\r\n        targetClass = target;\r\n        targetClassName = target.getName();\r\n    } catch (IOException ioex) {\r\n        StreamUtil.close(targetInputStream);\r\n        throw new ProxettaException(\"Unable to stream class: \" + target.getName(), ioex);\r\n    }\r\n    return _this();\r\n}"
}, {
	"Path": "org.jooq.conf.Settings.setReturnAllOnUpdatableRecord",
	"Comment": "sets the value of the returnallonupdatablerecord property.",
	"Method": "void setReturnAllOnUpdatableRecord(Boolean value){\r\n    this.returnAllOnUpdatableRecord = value;\r\n}"
}, {
	"Path": "org.joda.time.Hours.toStandardDays",
	"Comment": "converts this period in hours to a period in days assuming a24 hour day.this method allows you to convert between different types of period.however to achieve this it makes the assumption that all days are 24 hours long.this is not true when daylight savings time is considered, and may alsonot be true for some unusual chronologies. however, it is included as itis a useful operation for many applications and business rules.",
	"Method": "Days toStandardDays(){\r\n    return Days.days(getValue() / DateTimeConstants.HOURS_PER_DAY);\r\n}"
}, {
	"Path": "org.jsonschema2pojo.maven.Jsonschema2PojoMojo.execute",
	"Comment": "executes the plugin, to read the given source and behavioural propertiesand generate pojos. the current implementation acts as a wrapper aroundthe command line interface.",
	"Method": "void execute(){\r\n    addProjectDependenciesToClasspath();\r\n    try {\r\n        getAnnotationStyle();\r\n    } catch (IllegalArgumentException e) {\r\n        throw new MojoExecutionException(\"Not a valid annotation style: \" + annotationStyle);\r\n    }\r\n    try {\r\n        new AnnotatorFactory(this).getAnnotator(getCustomAnnotator());\r\n    } catch (IllegalArgumentException e) {\r\n        throw new MojoExecutionException(e.getMessage(), e);\r\n    }\r\n    if (skip) {\r\n        return;\r\n    }\r\n    if (sourceDirectory != null) {\r\n        sourceDirectory = FilenameUtils.normalize(sourceDirectory);\r\n        try {\r\n            URLUtil.parseURL(sourceDirectory);\r\n        } catch (IllegalArgumentException e) {\r\n            throw new MojoExecutionException(e.getMessage(), e);\r\n        }\r\n    } else if (!isEmpty(sourcePaths)) {\r\n        for (int i = 0; i < sourcePaths.length; i++) {\r\n            sourcePaths[i] = FilenameUtils.normalize(sourcePaths[i]);\r\n            try {\r\n                URLUtil.parseURL(sourcePaths[i]);\r\n            } catch (IllegalArgumentException e) {\r\n                throw new MojoExecutionException(e.getMessage(), e);\r\n            }\r\n        }\r\n    } else {\r\n        throw new MojoExecutionException(\"One of sourceDirectory or sourcePaths must be provided\");\r\n    }\r\n    if (filteringEnabled() || (sourceDirectory != null && isEmpty(sourcePaths))) {\r\n        if (sourceDirectory == null) {\r\n            throw new MojoExecutionException(\"Source includes and excludes require the sourceDirectory property\");\r\n        }\r\n        if (!isEmpty(sourcePaths)) {\r\n            throw new MojoExecutionException(\"Source includes and excludes are incompatible with the sourcePaths property\");\r\n        }\r\n        fileFilter = createFileFilter();\r\n    }\r\n    if (addCompileSourceRoot) {\r\n        project.addCompileSourceRoot(outputDirectory.getPath());\r\n    }\r\n    if (useCommonsLang3) {\r\n        getLog().warn(\"useCommonsLang3 is deprecated. Please remove it from your config.\");\r\n    }\r\n    try {\r\n        Jsonschema2Pojo.generate(this);\r\n    } catch (IOException e) {\r\n        throw new MojoExecutionException(\"Error generating classes from JSON Schema file(s) \" + sourceDirectory, e);\r\n    }\r\n}"
}, {
	"Path": "jodd.asm7.SymbolTable.addMergedType",
	"Comment": "adds a merged type in the type table of this symbol table. does nothing if the type tablealready contains a similar type.",
	"Method": "int addMergedType(int typeTableIndex1,int typeTableIndex2){\r\n    long data = typeTableIndex1 | (((long) typeTableIndex2) << 32);\r\n    int hashCode = hash(Symbol.MERGED_TYPE_TAG, typeTableIndex1 + typeTableIndex2);\r\n    Entry entry = get(hashCode);\r\n    while (entry != null) {\r\n        if (entry.tag == Symbol.MERGED_TYPE_TAG && entry.hashCode == hashCode && entry.data == data) {\r\n            return entry.info;\r\n        }\r\n        entry = entry.next;\r\n    }\r\n    String type1 = typeTable[typeTableIndex1].value;\r\n    String type2 = typeTable[typeTableIndex2].value;\r\n    int commonSuperTypeIndex = addType(classWriter.getCommonSuperClass(type1, type2));\r\n    put(new Entry(typeCount, Symbol.MERGED_TYPE_TAG, data, hashCode)).info = commonSuperTypeIndex;\r\n    return commonSuperTypeIndex;\r\n}"
}, {
	"Path": "jodd.asm7.ClassWriter.getAttributePrototypes",
	"Comment": "returns the prototypes of the attributes used by this class, its fields and its methods.",
	"Method": "Attribute[] getAttributePrototypes(){\r\n    Attribute.Set attributePrototypes = new Attribute.Set();\r\n    attributePrototypes.addAttributes(firstAttribute);\r\n    FieldWriter fieldWriter = firstField;\r\n    while (fieldWriter != null) {\r\n        fieldWriter.collectAttributePrototypes(attributePrototypes);\r\n        fieldWriter = (FieldWriter) fieldWriter.fv;\r\n    }\r\n    MethodWriter methodWriter = firstMethod;\r\n    while (methodWriter != null) {\r\n        methodWriter.collectAttributePrototypes(attributePrototypes);\r\n        methodWriter = (MethodWriter) methodWriter.mv;\r\n    }\r\n    return attributePrototypes.toArray();\r\n}"
}, {
	"Path": "jodd.asm7.ModuleVisitor.visitUse",
	"Comment": "visit a service used by the current module. the name must be the internal name of an interfaceor a class.",
	"Method": "void visitUse(String service){\r\n    if (mv != null) {\r\n        mv.visitUse(service);\r\n    }\r\n}"
}, {
	"Path": "jodd.mail.ReceiveMailSession.receiveEmail",
	"Comment": "receives all emails. messages are not modified. however, servers\tmay set seen flag anyway, so we force messages to remain\tunseen.",
	"Method": "ReceivedEmail[] receiveEmail(ReceivedEmail[] receiveEmail,EmailFilter filter){\r\n    return receiveMessages(filter, null, null, false, null);\r\n}"
}, {
	"Path": "org.joda.time.format.DateTimeFormatterBuilder.appendShortText",
	"Comment": "instructs the printer to emit a field value as short text, and theparser to expect text.",
	"Method": "DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType){\r\n    if (fieldType == null) {\r\n        throw new IllegalArgumentException(\"Field type must not be null\");\r\n    }\r\n    return append0(new TextField(fieldType, true));\r\n}"
}, {
	"Path": "jodd.proxetta.asm.ProxettaClassBuilder.visit",
	"Comment": "creates destination subclass header from current target class. destination name is created from targets by\tadding a suffix and, optionally, a number. destination extends the target.",
	"Method": "void visit(int version,int access,String name,String signature,String superName,String[] interfaces){\r\n    wd.init(name, superName, this.suffix, this.reqProxyClassName);\r\n    access &= ~AsmUtil.ACC_ABSTRACT;\r\n    final int v = ProxettaAsmUtil.resolveJavaVersion(version);\r\n    wd.dest.visit(v, access, wd.thisReference, signature, wd.superName, null);\r\n    wd.proxyAspects = new ProxyAspectData[aspects.length];\r\n    for (int i = 0; i < aspects.length; i++) {\r\n        wd.proxyAspects[i] = new ProxyAspectData(wd, aspects[i], i);\r\n    }\r\n}"
}, {
	"Path": "jodd.introspector.MethodDescriptor.resolveRawReturnComponentTypes",
	"Comment": "resolves raw return component types\tthis value is not cached.",
	"Method": "Class[] resolveRawReturnComponentTypes(){\r\n    return ClassUtil.getComponentTypes(returnType, classDescriptor.getType());\r\n}"
}, {
	"Path": "jodd.asm7.Handle.isInterface",
	"Comment": "returns true if the owner of the field or method designated by this handle is an interface.",
	"Method": "boolean isInterface(){\r\n    return isInterface;\r\n}"
}, {
	"Path": "jodd.asm7.MethodWriter.computeAllFrames",
	"Comment": "computes all the stack map frames of the method, from scratch.",
	"Method": "void computeAllFrames(){\r\n    Handler handler = firstHandler;\r\n    while (handler != null) {\r\n        String catchTypeDescriptor = handler.catchTypeDescriptor == null ? \"java/lang/Throwable\" : handler.catchTypeDescriptor;\r\n        int catchType = Frame.getAbstractTypeFromInternalName(symbolTable, catchTypeDescriptor);\r\n        Label handlerBlock = handler.handlerPc.getCanonicalInstance();\r\n        handlerBlock.flags |= Label.FLAG_JUMP_TARGET;\r\n        Label handlerRangeBlock = handler.startPc.getCanonicalInstance();\r\n        Label handlerRangeEnd = handler.endPc.getCanonicalInstance();\r\n        while (handlerRangeBlock != handlerRangeEnd) {\r\n            handlerRangeBlock.outgoingEdges = new Edge(catchType, handlerBlock, handlerRangeBlock.outgoingEdges);\r\n            handlerRangeBlock = handlerRangeBlock.nextBasicBlock;\r\n        }\r\n        handler = handler.nextHandler;\r\n    }\r\n    Frame firstFrame = firstBasicBlock.frame;\r\n    firstFrame.setInputFrameFromDescriptor(symbolTable, accessFlags, descriptor, this.maxLocals);\r\n    firstFrame.accept(this);\r\n    Label listOfBlocksToProcess = firstBasicBlock;\r\n    listOfBlocksToProcess.nextListElement = Label.EMPTY_LIST;\r\n    int maxStackSize = 0;\r\n    while (listOfBlocksToProcess != Label.EMPTY_LIST) {\r\n        Label basicBlock = listOfBlocksToProcess;\r\n        listOfBlocksToProcess = listOfBlocksToProcess.nextListElement;\r\n        basicBlock.nextListElement = null;\r\n        basicBlock.flags |= Label.FLAG_REACHABLE;\r\n        int maxBlockStackSize = basicBlock.frame.getInputStackSize() + basicBlock.outputStackMax;\r\n        if (maxBlockStackSize > maxStackSize) {\r\n            maxStackSize = maxBlockStackSize;\r\n        }\r\n        Edge outgoingEdge = basicBlock.outgoingEdges;\r\n        while (outgoingEdge != null) {\r\n            Label successorBlock = outgoingEdge.successor.getCanonicalInstance();\r\n            boolean successorBlockChanged = basicBlock.frame.merge(symbolTable, successorBlock.frame, outgoingEdge.info);\r\n            if (successorBlockChanged && successorBlock.nextListElement == null) {\r\n                successorBlock.nextListElement = listOfBlocksToProcess;\r\n                listOfBlocksToProcess = successorBlock;\r\n            }\r\n            outgoingEdge = outgoingEdge.nextEdge;\r\n        }\r\n    }\r\n    Label basicBlock = firstBasicBlock;\r\n    while (basicBlock != null) {\r\n        if ((basicBlock.flags & (Label.FLAG_JUMP_TARGET | Label.FLAG_REACHABLE)) == (Label.FLAG_JUMP_TARGET | Label.FLAG_REACHABLE)) {\r\n            basicBlock.frame.accept(this);\r\n        }\r\n        if ((basicBlock.flags & Label.FLAG_REACHABLE) == 0) {\r\n            Label nextBasicBlock = basicBlock.nextBasicBlock;\r\n            int startOffset = basicBlock.bytecodeOffset;\r\n            int endOffset = (nextBasicBlock == null ? code.length : nextBasicBlock.bytecodeOffset) - 1;\r\n            if (endOffset >= startOffset) {\r\n                for (int i = startOffset; i < endOffset; ++i) {\r\n                    code.data[i] = Opcodes.NOP;\r\n                }\r\n                code.data[endOffset] = (byte) Opcodes.ATHROW;\r\n                int frameIndex = visitFrameStart(startOffset, 0, 1);\r\n                currentFrame[frameIndex] = Frame.getAbstractTypeFromInternalName(symbolTable, \"java/lang/Throwable\");\r\n                visitFrameEnd();\r\n                firstHandler = Handler.removeRange(firstHandler, basicBlock, nextBasicBlock);\r\n                maxStackSize = Math.max(maxStackSize, 1);\r\n            }\r\n        }\r\n        basicBlock = basicBlock.nextBasicBlock;\r\n    }\r\n    this.maxStack = maxStackSize;\r\n}"
}, {
	"Path": "jodd.joy.JoyDb.getJtxManager",
	"Comment": "returns jtx transaction manager once when component is started.",
	"Method": "JtxTransactionManager getJtxManager(){\r\n    return requireStarted(jtxManager);\r\n}"
}, {
	"Path": "jodd.props.Props.load",
	"Comment": "loads base properties from java map using provided prefix.\tnull values are ignored.",
	"Method": "Props load(String data,Props load,File file,Props load,File file,String encoding,Props load,InputStream in,Props load,InputStream in,String encoding,Props load,Map<?, ?> p,Props load,Map<?, ?> map,String prefix){\r\n    String realPrefix = prefix;\r\n    realPrefix += '.';\r\n    for (final Map.Entry entry : map.entrySet()) {\r\n        final String name = entry.getKey().toString();\r\n        final Object value = entry.getValue();\r\n        if (value == null) {\r\n            continue;\r\n        }\r\n        data.putBaseProperty(realPrefix + name, value.toString(), false);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.joda.time.Years.dividedBy",
	"Comment": "returns a new instance with the years divided by the specified divisor.the calculation uses integer division, thus 3 divided by 2 is 1.this instance is immutable and unaffected by this method call.",
	"Method": "Years dividedBy(int divisor){\r\n    if (divisor == 1) {\r\n        return this;\r\n    }\r\n    return Years.years(getValue() / divisor);\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.year",
	"Comment": "get the year property which provides access to advanced functionality.",
	"Method": "Property year(){\r\n    return new Property(this, getChronology().year());\r\n}"
}, {
	"Path": "org.joda.time.YearMonthDay.withDayOfMonth",
	"Comment": "returns a copy of this date with the day of month field updated.yearmonthday is immutable, so there are no set methods.instead, this method returns a new instance with the value ofday of month changed.",
	"Method": "YearMonthDay withDayOfMonth(int dayOfMonth){\r\n    int[] newValues = getValues();\r\n    newValues = getChronology().dayOfMonth().set(this, DAY_OF_MONTH, newValues, dayOfMonth);\r\n    return new YearMonthDay(this, newValues);\r\n}"
}, {
	"Path": "org.json.JSONObject.keys",
	"Comment": "get an enumeration of the keys of the jsonobject. modifying this key set will alsomodify the jsonobject. use with caution.",
	"Method": "Iterator<String> keys(){\r\n    return this.keySet().iterator();\r\n}"
}, {
	"Path": "org.jooq.codegen.JavaGenerator.generateRecordGetter",
	"Comment": "subclasses may override this method to provide their own record getters.",
	"Method": "void generateRecordGetter(TypedElementDefinition<?> column,int index,JavaWriter out){\r\n    generateRecordGetter0(column, index, out);\r\n}"
}, {
	"Path": "jodd.db.pool.CoreConnectionPool.setValidateConnection",
	"Comment": "specifies if connections should be validated before returned.",
	"Method": "void setValidateConnection(boolean validateConnection){\r\n    this.validateConnection = validateConnection;\r\n}"
}, {
	"Path": "org.jooq.codegen.JavaGenerator.generateRecordClassJavadoc",
	"Comment": "subclasses may override this method to provide their own javadoc.",
	"Method": "void generateRecordClassJavadoc(TableDefinition table,JavaWriter out){\r\n    if (generateCommentsOnTables())\r\n        printClassJavadoc(out, table);\r\n    else\r\n        printClassJavadoc(out, \"The table <code>\" + table.getQualifiedInputName() + \"<\/code>.\");\r\n}"
}, {
	"Path": "jodd.decora.parser.DecoratorTagVisitor.defineDecoraTag",
	"Comment": "defines decora tag position inside decorator content.\tresets current decora tag tracking.",
	"Method": "void defineDecoraTag(){\r\n    DecoraTag decoraTag = decoraTagDefaultValueStart == 0 ? new DecoraTag(decoraTagName, decoraIdName, decoraTagStart, decoraTagEnd) : new DecoraTag(decoraTagName, decoraIdName, decoraTagStart, decoraTagEnd, decoraTagDefaultValueStart, decoraTagDefaultValueEnd - decoraTagDefaultValueStart);\r\n    decoraTags.add(decoraTag);\r\n    decoraTagName = null;\r\n    decoraIdName = null;\r\n    closingTagName = null;\r\n    decoraTagDefaultValueStart = 0;\r\n}"
}, {
	"Path": "org.joda.time.Interval.withEndMillis",
	"Comment": "creates a new interval with the specified end millisecond instant.",
	"Method": "Interval withEndMillis(long endInstant){\r\n    if (endInstant == getEndMillis()) {\r\n        return this;\r\n    }\r\n    return new Interval(getStartMillis(), endInstant, getChronology());\r\n}"
}, {
	"Path": "org.jsonschema2pojo.rules.TypeRule.getIntegerType",
	"Comment": "returns the jtype for an integer field. handles type lookup and unboxing.",
	"Method": "JType getIntegerType(JCodeModel owner,JsonNode node,GenerationConfig config){\r\n    if (config.isUseBigIntegers()) {\r\n        return unboxIfNecessary(owner.ref(BigInteger.class), config);\r\n    } else if (config.isUseLongIntegers() || node.has(\"minimum\") && node.get(\"minimum\").isLong() || node.has(\"maximum\") && node.get(\"maximum\").isLong()) {\r\n        return unboxIfNecessary(owner.ref(Long.class), config);\r\n    } else {\r\n        return unboxIfNecessary(owner.ref(Integer.class), config);\r\n    }\r\n}"
}, {
	"Path": "jodd.lagarto.dom.Node.removeAllChilds",
	"Comment": "removes all child nodes. each child node will be detached from this parent.",
	"Method": "void removeAllChilds(){\r\n    List<Node> removedNodes = childNodes;\r\n    childNodes = null;\r\n    childElementNodes = null;\r\n    childElementNodesCount = 0;\r\n    if (removedNodes != null) {\r\n        for (int i = 0, removedNodesSize = removedNodes.size(); i < removedNodesSize; i++) {\r\n            Node removedNode = removedNodes.get(i);\r\n            removedNode.detachFromParent();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.LocalTime.withMinuteOfHour",
	"Comment": "returns a copy of this time with the minute of hour field updated.localtime is immutable, so there are no set methods.instead, this method returns a new instance with the value ofminute of hour changed.",
	"Method": "LocalTime withMinuteOfHour(int minute){\r\n    return withLocalMillis(getChronology().minuteOfHour().set(getLocalMillis(), minute));\r\n}"
}, {
	"Path": "jodd.db.oom.sqlgen.DbSqlBuilder.match",
	"Comment": "creates condition part of the query only for existing columns.",
	"Method": "DbSqlBuilder match(String tableRef,Object value,DbSqlBuilder match,String tableRef,String objectRef,DbSqlBuilder match,String expression){\r\n    return addChunk(new MatchChunk(entityManager, expression));\r\n}"
}, {
	"Path": "org.joda.time.DateMidnight.withDayOfYear",
	"Comment": "returns a copy of this date with the day of year field updated.datemidnight is immutable, so there are no set methods.instead, this method returns a new instance with the value ofday of year changed.",
	"Method": "DateMidnight withDayOfYear(int dayOfYear){\r\n    return withMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear));\r\n}"
}, {
	"Path": "jodd.io.FileUtil.isSymlink",
	"Comment": "determines whether the specified file is a symbolic link rather than an actual file.",
	"Method": "boolean isSymlink(File file){\r\n    return Files.isSymbolicLink(file.toPath());\r\n}"
}, {
	"Path": "jodd.proxetta.asm.ProxettaClassBuilder.applyProxy",
	"Comment": "check if proxy should be applied on method and return proxy method builder if so.\totherwise, returns null.",
	"Method": "ProxettaMethodBuilder applyProxy(MethodSignatureVisitor msign){\r\n    List<ProxyAspectData> aspectList = matchMethodPointcuts(msign);\r\n    if (aspectList == null) {\r\n        return null;\r\n    }\r\n    int access = msign.getAccessFlags();\r\n    if ((access & ACC_ABSTRACT) != 0) {\r\n        throw new ProxettaException(\"Unable to process abstract method: \" + msign);\r\n    }\r\n    wd.proxyApplied = true;\r\n    return new ProxettaMethodBuilder(msign, wd, aspectList);\r\n}"
}, {
	"Path": "jodd.asm7.Label.addForwardReference",
	"Comment": "adds a forward reference to this label. this method must be called only for a true forwardreference, i.e. only if this label is not resolved yet. for backward references, the relativebytecode offset of the reference can be, and must be, computed and stored directly.",
	"Method": "void addForwardReference(int sourceInsnBytecodeOffset,int referenceType,int referenceHandle){\r\n    if (forwardReferences == null) {\r\n        forwardReferences = new int[FORWARD_REFERENCES_CAPACITY_INCREMENT];\r\n    }\r\n    int lastElementIndex = forwardReferences[0];\r\n    if (lastElementIndex + 2 >= forwardReferences.length) {\r\n        int[] newValues = new int[forwardReferences.length + FORWARD_REFERENCES_CAPACITY_INCREMENT];\r\n        System.arraycopy(forwardReferences, 0, newValues, 0, forwardReferences.length);\r\n        forwardReferences = newValues;\r\n    }\r\n    forwardReferences[++lastElementIndex] = sourceInsnBytecodeOffset;\r\n    forwardReferences[++lastElementIndex] = referenceType | referenceHandle;\r\n    forwardReferences[0] = lastElementIndex;\r\n}"
}, {
	"Path": "org.json.XML.noSpace",
	"Comment": "throw an exception if the string contains whitespace. whitespace is notallowed in tagnames and attributes.",
	"Method": "void noSpace(String string){\r\n    int i, length = string.length();\r\n    if (length == 0) {\r\n        throw new JSONException(\"Empty string.\");\r\n    }\r\n    for (i = 0; i < length; i += 1) {\r\n        if (Character.isWhitespace(string.charAt(i))) {\r\n            throw new JSONException(\"'\" + string + \"' contains a space character.\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.base.BaseSingleFieldPeriod.hashCode",
	"Comment": "gets a hash code for the period as defined by readableperiod.",
	"Method": "int hashCode(){\r\n    int total = 17;\r\n    total = 27 * total + getValue();\r\n    total = 27 * total + getFieldType().hashCode();\r\n    return total;\r\n}"
}, {
	"Path": "org.joda.time.LocalTime.millisOfDay",
	"Comment": "get the millis of day property which provides access to advanced functionality.",
	"Method": "Property millisOfDay(){\r\n    return new Property(this, getChronology().millisOfDay());\r\n}"
}, {
	"Path": "org.joda.time.Partial.toStringList",
	"Comment": "gets a string version of the partial that lists all the fields.this method exists to provide a better debugging tostring thanthe standard tostring. this method lists all the fields and theirvalues in a style similar to the collections framework.",
	"Method": "String toStringList(){\r\n    int size = size();\r\n    StringBuilder buf = new StringBuilder(20 * size);\r\n    buf.append('[');\r\n    for (int i = 0; i < size; i++) {\r\n        if (i > 0) {\r\n            buf.append(',').append(' ');\r\n        }\r\n        buf.append(iTypes[i].getName());\r\n        buf.append('=');\r\n        buf.append(iValues[i]);\r\n    }\r\n    buf.append(']');\r\n    return buf.toString();\r\n}"
}, {
	"Path": "com.jayway.jsonpath.Criteria.in",
	"Comment": "the in operator is analogous to the sql in modifier, allowing youto specify an array of possible matches.",
	"Method": "Criteria in(Object o,Criteria in,Collection<?> c){\r\n    notNull(c, \"collection can not be null\");\r\n    this.criteriaType = RelationalOperator.IN;\r\n    this.right = new ValueNode.ValueListNode(c);\r\n    return this;\r\n}"
}, {
	"Path": "jodd.asm7.Type.getDimensions",
	"Comment": "returns the number of dimensions of this array type. this method should only be used for anarray type.",
	"Method": "int getDimensions(){\r\n    int numDimensions = 1;\r\n    while (valueBuffer.charAt(valueBegin + numDimensions) == '[') {\r\n        numDimensions++;\r\n    }\r\n    return numDimensions;\r\n}"
}, {
	"Path": "jodd.util.StringUtil.replace",
	"Comment": "replaces many substring at once. order of string array is important.",
	"Method": "String replace(String s,String sub,String with,String replace,String s,String[] sub,String[] with){\r\n    if ((sub.length != with.length) || (sub.length == 0)) {\r\n        return s;\r\n    }\r\n    int start = 0;\r\n    StringBuilder buf = new StringBuilder(s.length());\r\n    while (true) {\r\n        int[] res = indexOf(s, sub, start);\r\n        if (res == null) {\r\n            break;\r\n        }\r\n        int end = res[1];\r\n        buf.append(s, start, end);\r\n        buf.append(with[res[0]]);\r\n        start = end + sub[res[0]].length();\r\n    }\r\n    buf.append(s.substring(start));\r\n    return buf.toString();\r\n}"
}, {
	"Path": "jodd.madvoc.interceptor.ActionInterceptorStack.intercept",
	"Comment": "interceptor is not used since this is just an interceptor container.",
	"Method": "Object intercept(ActionRequest actionRequest){\r\n    return apply(actionRequest);\r\n}"
}, {
	"Path": "org.joda.time.format.DateTimeFormatterBuilder.appendDecimal",
	"Comment": "instructs the printer to emit a field value as a decimal number, and theparser to expect an unsigned decimal number.",
	"Method": "DateTimeFormatterBuilder appendDecimal(DateTimeFieldType fieldType,int minDigits,int maxDigits){\r\n    if (fieldType == null) {\r\n        throw new IllegalArgumentException(\"Field type must not be null\");\r\n    }\r\n    if (maxDigits < minDigits) {\r\n        maxDigits = minDigits;\r\n    }\r\n    if (minDigits < 0 || maxDigits <= 0) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    if (minDigits <= 1) {\r\n        return append0(new UnpaddedNumber(fieldType, maxDigits, false));\r\n    } else {\r\n        return append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.chrono.GJDayOfWeekDateTimeField.getMaximumShortTextLength",
	"Comment": "get the maximum length of the abbreviated text returned by this field.",
	"Method": "int getMaximumShortTextLength(Locale locale){\r\n    return GJLocaleSymbols.forLocale(locale).getDayOfWeekMaxShortTextLength();\r\n}"
}, {
	"Path": "jodd.joy.madvoc.AppAction.validateAction",
	"Comment": "validates action. profiles are reset after the invocation.",
	"Method": "boolean validateAction(boolean validateAction,String profiles){\r\n    prepareValidator();\r\n    vtor.useProfiles(profiles);\r\n    vtor.validate(this);\r\n    vtor.resetProfiles();\r\n    List<Violation> violations = vtor.getViolations();\r\n    return violations == null;\r\n}"
}, {
	"Path": "org.joda.time.MutablePeriod.addMinutes",
	"Comment": "adds the specified minutes to the number of minutes in the period.",
	"Method": "void addMinutes(int minutes){\r\n    super.addField(DurationFieldType.minutes(), minutes);\r\n}"
}, {
	"Path": "jodd.util.CollectionUtil.collectionOf",
	"Comment": "returns a collection containing all elements of the iterator.",
	"Method": "Collection<T> collectionOf(Iterator<? extends T> iterator){\r\n    final List<T> list = new ArrayList();\r\n    while (iterator.hasNext()) {\r\n        list.add(iterator.next());\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractPartial.toString",
	"Comment": "uses the specified formatter to convert this partial to a string.",
	"Method": "String toString(DateTimeFormatter formatter){\r\n    if (formatter == null) {\r\n        return toString();\r\n    }\r\n    return formatter.print(this);\r\n}"
}, {
	"Path": "jodd.util.StringUtil.join",
	"Comment": "joins an collection of objects into one string with separator.",
	"Method": "String join(Object[] array,String join,Object[] array,char separator,String join,Collection collection,char separator,String join,Collection collection,String separator,String join,Object[] array,String separator){\r\n    if (array == null) {\r\n        return null;\r\n    }\r\n    if (array.length == 0) {\r\n        return StringPool.EMPTY;\r\n    }\r\n    if (array.length == 1) {\r\n        return String.valueOf(array[0]);\r\n    }\r\n    final StringBuilder sb = new StringBuilder(array.length * 16);\r\n    for (int i = 0; i < array.length; i++) {\r\n        if (i > 0) {\r\n            sb.append(separator);\r\n        }\r\n        sb.append(array[i]);\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.jayway.jsonpath.internal.function.Parameter.consume",
	"Comment": "either consume the object as an array and add each element to the collection, or alternatively add each element",
	"Method": "void consume(Class expectedType,EvaluationContext ctx,Collection collection,Object value){\r\n    if (ctx.configuration().jsonProvider().isArray(value)) {\r\n        for (Object o : ctx.configuration().jsonProvider().toIterable(value)) {\r\n            if (o != null && expectedType.isAssignableFrom(o.getClass())) {\r\n                collection.add(o);\r\n            } else if (o != null && expectedType == String.class) {\r\n                collection.add(o.toString());\r\n            }\r\n        }\r\n    } else {\r\n        if (value != null && expectedType.isAssignableFrom(value.getClass())) {\r\n            collection.add(value);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.LocalDate.withEra",
	"Comment": "returns a copy of this date with the era field updated.localdate is immutable, so there are no set methods.instead, this method returns a new instance with the value ofera changed.",
	"Method": "LocalDate withEra(int era){\r\n    return withLocalMillis(getChronology().era().set(getLocalMillis(), era));\r\n}"
}, {
	"Path": "jodd.db.DbQueryBase.setFetchSize",
	"Comment": "gives the jdbc driver a hint as to the number of rows that should be fetched from the database when\tmore rows are needed. the number of rows specified affects only result sets created using this statement.\tif the value specified is zero, then the hint is ignored. the default value is zero.",
	"Method": "Q setFetchSize(int rows){\r\n    checkNotClosed();\r\n    this.fetchSize = rows;\r\n    if (statement != null) {\r\n        try {\r\n            statement.setFetchSize(fetchSize);\r\n        } catch (SQLException sex) {\r\n            throw new DbSqlException(this, \"Unable to set fetch size: \" + fetchSize, sex);\r\n        }\r\n    }\r\n    return _this();\r\n}"
}, {
	"Path": "jodd.typeconverter.impl.ArrayConverter.createArray",
	"Comment": "creates new array of target component type.\tdefault implementation uses reflection to create\tan array of target type. override it for better performances.",
	"Method": "T[] createArray(int length){\r\n    return (T[]) Array.newInstance(targetComponentType, length);\r\n}"
}, {
	"Path": "org.joda.time.TimeOfDay.withMinuteOfHour",
	"Comment": "returns a copy of this time with the minute of hour field updated.timeofday is immutable, so there are no set methods.instead, this method returns a new instance with the value ofminute of hour changed.",
	"Method": "TimeOfDay withMinuteOfHour(int minute){\r\n    int[] newValues = getValues();\r\n    newValues = getChronology().minuteOfHour().set(this, MINUTE_OF_HOUR, newValues, minute);\r\n    return new TimeOfDay(this, newValues);\r\n}"
}, {
	"Path": "jodd.joy.JoyDb.start",
	"Comment": "initializes database. first, creates connection pool.\tand transaction manager. then, jodds dbentitymanager is\tconfigured. it is also configured automagically, by scanning\tthe class path for entities.",
	"Method": "void start(){\r\n    initLogger();\r\n    if (!databaseEnabled) {\r\n        log.info(\"DB not enabled.\");\r\n        return;\r\n    }\r\n    log.info(\"DB start ----------\");\r\n    final PetiteContainer petiteContainer = joyPetiteSupplier.get().getPetiteContainer();\r\n    connectionProvider = createConnectionProviderIfNotSupplied();\r\n    petiteContainer.addBean(beanNamePrefix() + \"pool\", connectionProvider);\r\n    if (connectionProvider instanceof CoreConnectionPool) {\r\n        final CoreConnectionPool pool = (CoreConnectionPool) connectionProvider;\r\n        if (pool.getDriver() == null) {\r\n            databaseEnabled = false;\r\n            log.warn(\"DB configuration not set (\" + beanNamePrefix() + \"pool.*). DB will be disabled.\");\r\n            return;\r\n        }\r\n    }\r\n    connectionProvider.init();\r\n    checkConnectionProvider();\r\n    jtxManager = createJtxTransactionManager(connectionProvider);\r\n    jtxManager.setValidateExistingTransaction(true);\r\n    final AnnotationTxAdviceManager annTxAdviceManager = new AnnotationTxAdviceManager(new LeanJtxWorker(jtxManager), jtxScopePattern);\r\n    AnnotationTxAdviceSupport.manager = annTxAdviceManager;\r\n    joyProxettaSupplier.get().getProxetta().withAspect(createTxProxyAspects(annTxAdviceManager.getAnnotations()));\r\n    final DbSessionProvider sessionProvider = new DbJtxSessionProvider(jtxManager);\r\n    final long startTime = System.currentTimeMillis();\r\n    final QueryMap queryMap = new DbPropsQueryMap();\r\n    log.debug(\"Queries loaded in \" + (System.currentTimeMillis() - startTime) + \"ms.\");\r\n    log.debug(\"Total queries: \" + queryMap.size());\r\n    dbOom = DbOom.create().withConnectionProvider(connectionProvider).withSessionProvider(sessionProvider).withQueryMap(queryMap).get();\r\n    dbOom.connect();\r\n    final DbEntityManager dbEntityManager = dbOom.entityManager();\r\n    dbEntityManager.reset();\r\n    petiteContainer.addBean(beanNamePrefix() + \"query\", dbOom.queryConfig());\r\n    petiteContainer.addBean(beanNamePrefix() + \"oom\", dbOom.config());\r\n    if (autoConfiguration) {\r\n        final AutomagicDbOomConfigurator automagicDbOomConfigurator = new AutomagicDbOomConfigurator(dbEntityManager, true);\r\n        automagicDbOomConfigurator.registerAsConsumer(joyScannerSupplier.get().getClassScanner());\r\n    }\r\n    dbEntityManagerConsumers.accept(dbEntityManager);\r\n    log.info(\"DB OK!\");\r\n}"
}, {
	"Path": "jodd.asm7.Frame.getAbstractTypeFromInternalName",
	"Comment": "returns the abstract type corresponding to the internal name of a class.",
	"Method": "int getAbstractTypeFromInternalName(SymbolTable symbolTable,String internalName){\r\n    return REFERENCE_KIND | symbolTable.addType(internalName);\r\n}"
}, {
	"Path": "jodd.typeconverter.Converter.toShort",
	"Comment": "converts value to short. returns default value\twhen conversion result is null",
	"Method": "Short toShort(Object value,Short toShort,Object value,Short defaultValue){\r\n    final Short result = toShort(value);\r\n    if (result == null) {\r\n        return defaultValue;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.joda.time.YearMonthDay.monthOfYear",
	"Comment": "get the month of year field property which provides access to advanced functionality.",
	"Method": "Property monthOfYear(){\r\n    return new Property(this, MONTH_OF_YEAR);\r\n}"
}, {
	"Path": "jodd.joy.JoyDb.getConnectionProvider",
	"Comment": "returns connection provider once when component is started.",
	"Method": "ConnectionProvider getConnectionProvider(){\r\n    return requireStarted(connectionProvider);\r\n}"
}, {
	"Path": "org.json.JSONObject.optInt",
	"Comment": "get an optional int value associated with a key, or the default if thereis no such key or if the value is not a number. if the value is a string,an attempt will be made to evaluate it as a number.",
	"Method": "int optInt(String key,int optInt,String key,int defaultValue){\r\n    final Number val = this.optNumber(key, null);\r\n    if (val == null) {\r\n        return defaultValue;\r\n    }\r\n    return val.intValue();\r\n}"
}, {
	"Path": "org.jooq.impl.DefaultTransactionProvider.brace",
	"Comment": "ensure an autocommit value on the connection, if it was setto true, originally.",
	"Method": "void brace(Configuration configuration,boolean start){\r\n    DefaultConnectionProvider connection = connection(configuration);\r\n    try {\r\n        boolean autoCommit = autoCommit(configuration);\r\n        if (autoCommit == true)\r\n            connection.setAutoCommit(!start);\r\n    } finally {\r\n        if (!start) {\r\n            connectionProvider.release(connection.connection);\r\n            configuration.data().remove(DATA_DEFAULT_TRANSACTION_PROVIDER_CONNECTION);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.convert.ConverterManager.addPartialConverter",
	"Comment": "adds a converter to the set of converters. if a matching converter isalready in the set, the given converter replaces it. if the converter isexactly the same as one already in the set, no changes are made.the order in which converters are added is not relevant. the bestconverter is selected by examining the object hierarchy.",
	"Method": "PartialConverter addPartialConverter(PartialConverter converter){\r\n    checkAlterPartialConverters();\r\n    if (converter == null) {\r\n        return null;\r\n    }\r\n    PartialConverter[] removed = new PartialConverter[1];\r\n    iPartialConverters = iPartialConverters.add(converter, removed);\r\n    return removed[0];\r\n}"
}, {
	"Path": "jodd.madvoc.component.WrapperManager.lookup",
	"Comment": "looks up for existing wrapper. returns null if wrapper is not already registered.",
	"Method": "T lookup(String name){\r\n    return wrappers.get(name);\r\n}"
}, {
	"Path": "jodd.proxetta.ProxyTarget.returnType",
	"Comment": "inserts return type of target method. null is used for void.",
	"Method": "Class returnType(){\r\n    throw new ProxettaException();\r\n}"
}, {
	"Path": "jodd.asm7.Label.accept",
	"Comment": "makes the given visitor visit this label and its source line numbers, if applicable.",
	"Method": "void accept(MethodVisitor methodVisitor,boolean visitLineNumbers){\r\n    methodVisitor.visitLabel(this);\r\n    if (visitLineNumbers && lineNumber != 0) {\r\n        methodVisitor.visitLineNumber(lineNumber & 0xFFFF, this);\r\n        if (otherLineNumbers != null) {\r\n            for (int i = 1; i <= otherLineNumbers[0]; ++i) {\r\n                methodVisitor.visitLineNumber(otherLineNumbers[i], this);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jodd.db.oom.DbOomQuery.populateGeneratedKeys",
	"Comment": "populates entity with generated column values from executed query.",
	"Method": "void populateGeneratedKeys(Object entity){\r\n    final String[] generatedColumns = getGeneratedColumnNames();\r\n    if (generatedColumns == null) {\r\n        return;\r\n    }\r\n    DbEntityDescriptor ded = dbOom.entityManager().lookupType(entity.getClass());\r\n    Class[] keyTypes = new Class[generatedColumns.length];\r\n    String[] properties = new String[generatedColumns.length];\r\n    for (int i = 0; i < generatedColumns.length; i++) {\r\n        String column = generatedColumns[i];\r\n        DbEntityColumnDescriptor decd = ded.findByColumnName(column);\r\n        if (decd != null) {\r\n            keyTypes[i] = decd.getPropertyType();\r\n            properties[i] = decd.getPropertyName();\r\n        }\r\n    }\r\n    final Object keyValues = findGeneratedColumns(keyTypes);\r\n    if (!keyValues.getClass().isArray()) {\r\n        BeanUtil.declared.setProperty(entity, properties[0], keyValues);\r\n    } else {\r\n        for (int i = 0; i < properties.length; i++) {\r\n            BeanUtil.declared.setProperty(entity, properties[i], ((Object[]) keyValues)[i]);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.Hours.minus",
	"Comment": "returns a new instance with the specified number of hours taken away.this instance is immutable and unaffected by this method call.",
	"Method": "Hours minus(int hours,Hours minus,Hours hours){\r\n    if (hours == null) {\r\n        return this;\r\n    }\r\n    return minus(hours.getValue());\r\n}"
}, {
	"Path": "org.joda.time.MutablePeriod.addHours",
	"Comment": "adds the specified hours to the number of hours in the period.",
	"Method": "void addHours(int hours){\r\n    super.addField(DurationFieldType.hours(), hours);\r\n}"
}, {
	"Path": "jodd.asm7.Type.getArgumentsAndReturnSizes",
	"Comment": "computes the size of the arguments and of the return value of a method.",
	"Method": "int getArgumentsAndReturnSizes(int getArgumentsAndReturnSizes,String methodDescriptor){\r\n    int argumentsSize = 1;\r\n    int currentOffset = 1;\r\n    int currentChar = methodDescriptor.charAt(currentOffset);\r\n    while (currentChar != ')') {\r\n        if (currentChar == 'J' || currentChar == 'D') {\r\n            currentOffset++;\r\n            argumentsSize += 2;\r\n        } else {\r\n            while (methodDescriptor.charAt(currentOffset) == '[') {\r\n                currentOffset++;\r\n            }\r\n            if (methodDescriptor.charAt(currentOffset++) == 'L') {\r\n                currentOffset = methodDescriptor.indexOf(';', currentOffset) + 1;\r\n            }\r\n            argumentsSize += 1;\r\n        }\r\n        currentChar = methodDescriptor.charAt(currentOffset);\r\n    }\r\n    currentChar = methodDescriptor.charAt(currentOffset + 1);\r\n    if (currentChar == 'V') {\r\n        return argumentsSize << 2;\r\n    } else {\r\n        int returnSize = (currentChar == 'J' || currentChar == 'D') ? 2 : 1;\r\n        return argumentsSize << 2 | returnSize;\r\n    }\r\n}"
}, {
	"Path": "com.jayway.jsonpath.Configuration.addEvaluationListeners",
	"Comment": "creates a new configuration by the provided evaluation listeners to the current listeners",
	"Method": "Configuration addEvaluationListeners(EvaluationListener evaluationListener){\r\n    return Configuration.builder().jsonProvider(jsonProvider).mappingProvider(mappingProvider).options(options).evaluationListener(evaluationListener).build();\r\n}"
}, {
	"Path": "jodd.mail.SendMailSession.setRecipients",
	"Comment": "sets to, cc and bcc in msgtoset with to, cc and bcc from emailwithdata.",
	"Method": "void setRecipients(Email emailWithData,MimeMessage msgToSet){\r\n    final InternetAddress[] to = EmailAddress.convert(emailWithData.to());\r\n    if (to.length > 0) {\r\n        msgToSet.setRecipients(RecipientType.TO, to);\r\n    }\r\n    final InternetAddress[] cc = EmailAddress.convert(emailWithData.cc());\r\n    if (cc.length > 0) {\r\n        msgToSet.setRecipients(RecipientType.CC, cc);\r\n    }\r\n    final InternetAddress[] bcc = EmailAddress.convert(emailWithData.bcc());\r\n    if (bcc.length > 0) {\r\n        msgToSet.setRecipients(RecipientType.BCC, bcc);\r\n    }\r\n}"
}, {
	"Path": "jodd.http.HttpResponse.cookies",
	"Comment": "returns list of valid cookies sent from server.\tif no cookie found, returns an empty array. invalid cookies are ignored.",
	"Method": "Cookie[] cookies(){\r\n    List<String> newCookies = headers(\"set-cookie\");\r\n    if (newCookies == null) {\r\n        return new Cookie[0];\r\n    }\r\n    List<Cookie> cookieList = new ArrayList(newCookies.size());\r\n    for (String cookieValue : newCookies) {\r\n        try {\r\n            Cookie cookie = new Cookie(cookieValue);\r\n            cookieList.add(cookie);\r\n        } catch (Exception ex) {\r\n        }\r\n    }\r\n    return cookieList.toArray(new Cookie[0]);\r\n}"
}, {
	"Path": "jodd.db.DbOom.connect",
	"Comment": "initializes the dboom by connecting to the database. database will be detected\tand dboom will be configured to match it.",
	"Method": "DbOom connect(){\r\n    connectionProvider.init();\r\n    final DbDetector dbDetector = new DbDetector();\r\n    dbDetector.detectDatabaseAndConfigureDbOom(connectionProvider, dbOomConfig);\r\n    return this;\r\n}"
}, {
	"Path": "org.joda.time.MutableDateTime.setZone",
	"Comment": "sets the time zone of the datetime, changing the chronology and field values.changing the zone using this method retains the millisecond instant.the millisecond instant is adjusted in the new zone to compensate.chronology. setting the time zone does not affect the millisecond valueof this instant.if the chronology already has this time zone, no change occurs.",
	"Method": "void setZone(DateTimeZone newZone){\r\n    newZone = DateTimeUtils.getZone(newZone);\r\n    Chronology chrono = getChronology();\r\n    if (chrono.getZone() != newZone) {\r\n        setChronology(chrono.withZone(newZone));\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.YearMonth.getFieldTypes",
	"Comment": "gets an array of the field type of each of the fields that this partial supports.the fields are returned largest to smallest, year, month.",
	"Method": "DateTimeFieldType[] getFieldTypes(){\r\n    return (DateTimeFieldType[]) FIELD_TYPES.clone();\r\n}"
}, {
	"Path": "jodd.lagarto.dom.LagartoDOMBuilderTagVisitor.fixUnclosedTagsUpToMatchingParent",
	"Comment": "fixes all unclosed tags up to matching parent. missing end tags will be added\tjust before parent tag is closed, making the whole inner content as its tag body.\ttags that can be closed implicitly are checked and closed.\tthere is optional check for detecting orphan tags inside the\ttable or lists. if set, tags can be closed beyond the border of the\ttable and the list and it is reported as orphan tag.\tthis is just a generic solutions, closest to the rules.",
	"Method": "void fixUnclosedTagsUpToMatchingParent(Tag tag,Node matchingParent){\r\n    if (domBuilder.config.isUnclosedTagAsOrphanCheck()) {\r\n        Node thisNode = parentNode;\r\n        if (!CharSequenceUtil.equalsIgnoreCase(tag.getName(), \"table\")) {\r\n            while (thisNode != matchingParent) {\r\n                String thisNodeName = thisNode.getNodeName().toLowerCase();\r\n                if (thisNodeName.equals(\"table\") || thisNodeName.equals(\"ul\") || thisNodeName.equals(\"ol\")) {\r\n                    String positionString = tag.getPosition();\r\n                    if (positionString == null) {\r\n                        positionString = StringPool.EMPTY;\r\n                    }\r\n                    error(\"Orphan closed tag ignored: <\/\" + tag.getName() + \"> \" + positionString);\r\n                    return;\r\n                }\r\n                thisNode = thisNode.getParentNode();\r\n            }\r\n        }\r\n    }\r\n    while (true) {\r\n        if (parentNode == matchingParent) {\r\n            parentNode = parentNode.getParentNode();\r\n            break;\r\n        }\r\n        Node parentParentNode = parentNode.getParentNode();\r\n        if (domBuilder.config.isImpliedEndTags()) {\r\n            if (implRules.implicitlyCloseParentTagOnNewTag(parentParentNode.getNodeName(), parentNode.getNodeName())) {\r\n                parentNode.detachFromParent();\r\n                parentParentNode.getParentNode().addChild(parentNode);\r\n            }\r\n        }\r\n        error(\"Unclosed tag closed: <\" + parentNode.getNodeName() + \">\");\r\n        parentNode = parentParentNode;\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.MonthDay.monthOfYear",
	"Comment": "get the month of year field property which provides access to advanced functionality.",
	"Method": "Property monthOfYear(){\r\n    return new Property(this, MONTH_OF_YEAR);\r\n}"
}, {
	"Path": "org.joda.time.base.BaseSingleFieldPeriod.get",
	"Comment": "gets the value of a duration field represented by this period.if the field type specified does not match the type used by this classthen zero is returned.",
	"Method": "int get(DurationFieldType type){\r\n    if (type == getFieldType()) {\r\n        return getValue();\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "jodd.io.upload.MultipartRequestInputStream.copyAll",
	"Comment": "copies bytes from this stream to some output until boundary is\treached. returns number of copied bytes. it will throw an exception\tfor any irregular behaviour.",
	"Method": "int copyAll(OutputStream out){\r\n    int count = 0;\r\n    while (true) {\r\n        byte b = readByte();\r\n        if (isBoundary(b)) {\r\n            break;\r\n        }\r\n        out.write(b);\r\n        count++;\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "jodd.decora.parser.DecoraParser.parsePage",
	"Comment": "parses target page and extracts decora regions for replacements.",
	"Method": "void parsePage(char[] pageContent,DecoraTag[] decoraTags){\r\n    LagartoParser lagartoParser = new LagartoParser(pageContent);\r\n    PageRegionExtractor writer = new PageRegionExtractor(decoraTags);\r\n    lagartoParser.parse(writer);\r\n}"
}, {
	"Path": "org.joda.time.TimeOfDay.withSecondOfMinute",
	"Comment": "returns a copy of this time with the second of minute field updated.timeofday is immutable, so there are no set methods.instead, this method returns a new instance with the value ofsecond of minute changed.",
	"Method": "TimeOfDay withSecondOfMinute(int second){\r\n    int[] newValues = getValues();\r\n    newValues = getChronology().secondOfMinute().set(this, SECOND_OF_MINUTE, newValues, second);\r\n    return new TimeOfDay(this, newValues);\r\n}"
}, {
	"Path": "org.joda.time.Years.multipliedBy",
	"Comment": "returns a new instance with the years multiplied by the specified scalar.this instance is immutable and unaffected by this method call.",
	"Method": "Years multipliedBy(int scalar){\r\n    return Years.years(FieldUtils.safeMultiply(getValue(), scalar));\r\n}"
}, {
	"Path": "jodd.csselly.selector.PseudoClass.match",
	"Comment": "returns true if node matches the pseudoclass within current results.",
	"Method": "boolean match(Node node,boolean match,Node node,boolean match,Node node,boolean match,Node node,boolean match,Node node,boolean match,Node node,boolean match,Node node,boolean match,Node node,boolean match,Node node,boolean match,List<Node> currentResults,Node node,int index,boolean match,Node node,boolean match,List<Node> currentResults,Node node,int index,boolean match,Node node,boolean match,Node node,boolean match,Node node,boolean match,Node node,boolean match,Node node,boolean match,Node node,boolean match,Node node,boolean match,Node node,boolean match,Node node,boolean match,Node node,boolean match,Node node,boolean match,Node node,boolean match,Node node,boolean match,Node node,boolean match,Node node,boolean match,List<Node> currentResults,Node node,int index,boolean match,Node node,boolean match,List<Node> currentResults,Node node,int index,boolean match,Node node,boolean match,List<Node> currentResults,Node node,int index){\r\n    return true;\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractDateTime.get",
	"Comment": "get the value of one of the fields of a datetime.this method uses the chronology of the datetime to obtain the value.it is essentially a generic way of calling one of the get methods.",
	"Method": "int get(DateTimeFieldType type){\r\n    if (type == null) {\r\n        throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\r\n    }\r\n    return type.getField(getChronology()).get(getMillis());\r\n}"
}, {
	"Path": "jodd.jtx.worker.LeanJtxWorker.maybeCommitTransaction",
	"Comment": "commits transaction if created in the same level where this method is invoked.\treturns true if transaction was actually committed or false\tif transaction was not created on this level.",
	"Method": "boolean maybeCommitTransaction(JtxTransaction tx){\r\n    if (tx == null) {\r\n        return false;\r\n    }\r\n    log.debug(\"commit tx\");\r\n    tx.commit();\r\n    return true;\r\n}"
}, {
	"Path": "jodd.util.PropertiesUtil.subset",
	"Comment": "creates new properties object from the original one, by copying\tthose properties that have specified first part of the key name.\tprefix may be optionally stripped during this process.",
	"Method": "Properties subset(Properties p,String prefix,boolean stripPrefix){\r\n    if (StringUtil.isBlank(prefix)) {\r\n        return p;\r\n    }\r\n    if (!prefix.endsWith(StringPool.DOT)) {\r\n        prefix += '.';\r\n    }\r\n    Properties result = new Properties();\r\n    int baseLen = prefix.length();\r\n    for (Object o : p.keySet()) {\r\n        String key = (String) o;\r\n        if (key.startsWith(prefix)) {\r\n            result.setProperty(stripPrefix ? key.substring(baseLen) : key, p.getProperty(key));\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.jooq.codegen.JavaGenerator.generateTableClassJavadoc",
	"Comment": "subclasses may override this method to provide their own javadoc.",
	"Method": "void generateTableClassJavadoc(TableDefinition table,JavaWriter out){\r\n    if (generateCommentsOnTables())\r\n        printClassJavadoc(out, table);\r\n    else\r\n        printClassJavadoc(out, \"The table <code>\" + table.getQualifiedInputName() + \"<\/code>.\");\r\n}"
}, {
	"Path": "org.joda.time.Period.plusHours",
	"Comment": "returns a new period plus the specified number of hours added.this period instance is immutable and unaffected by this method call.",
	"Method": "Period plusHours(int hours){\r\n    if (hours == 0) {\r\n        return this;\r\n    }\r\n    int[] values = getValues();\r\n    getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, hours);\r\n    return new Period(values, getPeriodType());\r\n}"
}, {
	"Path": "org.joda.time.MutableDateTime.setZoneRetainFields",
	"Comment": "sets the time zone of the datetime, changing the chronology and millisecond.changing the zone using this method retains the field values.the millisecond instant is adjusted in the new zone to compensate.if the chronology already has this time zone, no change occurs.",
	"Method": "void setZoneRetainFields(DateTimeZone newZone){\r\n    newZone = DateTimeUtils.getZone(newZone);\r\n    DateTimeZone originalZone = DateTimeUtils.getZone(getZone());\r\n    if (newZone == originalZone) {\r\n        return;\r\n    }\r\n    long millis = originalZone.getMillisKeepLocal(newZone, getMillis());\r\n    setChronology(getChronology().withZone(newZone));\r\n    setMillis(millis);\r\n}"
}, {
	"Path": "jodd.util.CharSequenceUtil.equalsOne",
	"Comment": "match if one character equals to any of the given character.",
	"Method": "boolean equalsOne(char c,CharSequence match){\r\n    for (int i = 0; i < match.length(); i++) {\r\n        char aMatch = match.charAt(i);\r\n        if (c == aMatch) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "jodd.inex.InExRules.accept",
	"Comment": "matches value against single rule. by default performs equals on value\tagainst the rule.",
	"Method": "boolean accept(V value,R rule,boolean include){\r\n    return value.equals(rule);\r\n}"
}, {
	"Path": "org.joda.time.Weeks.toStandardMinutes",
	"Comment": "converts this period in weeks to a period in minutes assuming a7 day week, 24 hour day and 60 minute hour.this method allows you to convert between different types of period.however to achieve this it makes the assumption that all weeks are7 days long, all days are 24 hours long and all hours are 60 minutes long.this is not true when daylight savings is considered and may also notbe true for some unusual chronologies. however, it is includedas it is a useful operation for many applications and business rules.",
	"Method": "Minutes toStandardMinutes(){\r\n    return Minutes.minutes(FieldUtils.safeMultiply(getValue(), DateTimeConstants.MINUTES_PER_WEEK));\r\n}"
}, {
	"Path": "jodd.json.JsonParser.consumeOneOf",
	"Comment": "consumes one of the allowed char at current position.\tif char is different, return 0.\tif matched, returns matched char.",
	"Method": "char consumeOneOf(char c1,char c2){\r\n    char c = input[ndx];\r\n    if ((c != c1) && (c != c2)) {\r\n        return 0;\r\n    }\r\n    ndx++;\r\n    return c;\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractPartial.equals",
	"Comment": "compares this readablepartial with another returning true if the chronology,field types and values are equal.",
	"Method": "boolean equals(Object partial){\r\n    if (this == partial) {\r\n        return true;\r\n    }\r\n    if (partial instanceof ReadablePartial == false) {\r\n        return false;\r\n    }\r\n    ReadablePartial other = (ReadablePartial) partial;\r\n    if (size() != other.size()) {\r\n        return false;\r\n    }\r\n    for (int i = 0, isize = size(); i < isize; i++) {\r\n        if (getValue(i) != other.getValue(i) || getFieldType(i) != other.getFieldType(i)) {\r\n            return false;\r\n        }\r\n    }\r\n    return FieldUtils.equals(getChronology(), other.getChronology());\r\n}"
}, {
	"Path": "jodd.petite.scope.ShutdownAwareScope.destroyBean",
	"Comment": "removes destroyable bean from the list and calls it destroy methods.\tif bean is not destroyable, does nothing. bean gets destroyed only once.",
	"Method": "void destroyBean(BeanData beanData){\r\n    if (destroyableBeans == null) {\r\n        return;\r\n    }\r\n    if (!isBeanDestroyable(beanData)) {\r\n        return;\r\n    }\r\n    if (destroyableBeans.remove(beanData)) {\r\n        beanData.callDestroyMethods();\r\n    }\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.MatchersTableType.getExpression",
	"Comment": "this table matcher applies to all unqualified or qualified table names matched by this expression. if left empty, this matcher applies to all tables.",
	"Method": "String getExpression(){\r\n    return expression;\r\n}"
}, {
	"Path": "jodd.servlet.tag.IteratorTag.setVar",
	"Comment": "specifies variable name that will be used for item during iteration.",
	"Method": "void setVar(String var){\r\n    this.var = var;\r\n}"
}, {
	"Path": "org.joda.time.format.PeriodFormatter.withLocale",
	"Comment": "returns a new formatter with a different locale that will be usedfor printing and parsing.a periodformatter is immutable, so a new instance is returned,and the original is unaltered and still usable.a null locale indicates that no specific locale override is in use.",
	"Method": "PeriodFormatter withLocale(Locale locale){\r\n    if (locale == getLocale() || (locale != null && locale.equals(getLocale()))) {\r\n        return this;\r\n    }\r\n    return new PeriodFormatter(iPrinter, iParser, locale, iParseType);\r\n}"
}, {
	"Path": "org.joda.time.DateTime.toYearMonthDay",
	"Comment": "converts this object to a yearmonthday using thesame millis and chronology.",
	"Method": "YearMonthDay toYearMonthDay(){\r\n    return new YearMonthDay(getMillis(), getChronology());\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.MatchersFieldType.getExpression",
	"Comment": "this field matcher applies to all unqualified or qualified field names matched by this expression. if left empty, this matcher applies to all fields.",
	"Method": "String getExpression(){\r\n    return expression;\r\n}"
}, {
	"Path": "jodd.http.ProxyInfo.getProxyUsername",
	"Comment": "returns proxy user name or null if\tno authentication required.",
	"Method": "String getProxyUsername(){\r\n    return proxyUsername;\r\n}"
}, {
	"Path": "jodd.db.DbQueryBase.checkNotClosed",
	"Comment": "checks if query is not closed and throws an exception if it is.",
	"Method": "void checkNotClosed(){\r\n    if (queryState == CLOSED) {\r\n        throw new DbSqlException(this, \"Query is closed. Operation may be performed only on active queries.\");\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.LocalTime.getField",
	"Comment": "gets the field for a specific index in the chronology specified.this method must not use any instance variables.",
	"Method": "DateTimeField getField(int index,Chronology chrono,DateTimeField getField){\r\n    switch(index) {\r\n        case HOUR_OF_DAY:\r\n            return chrono.hourOfDay();\r\n        case MINUTE_OF_HOUR:\r\n            return chrono.minuteOfHour();\r\n        case SECOND_OF_MINUTE:\r\n            return chrono.secondOfMinute();\r\n        case MILLIS_OF_SECOND:\r\n            return chrono.millisOfSecond();\r\n        default:\r\n            throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.format.DateTimeFormatter.getPrinter0",
	"Comment": "gets the internal printer object that performs the real printing work.",
	"Method": "InternalPrinter getPrinter0(){\r\n    return iPrinter;\r\n}"
}, {
	"Path": "jodd.asm7.FieldWriter.collectAttributePrototypes",
	"Comment": "collects the attributes of this field into the given set of attribute prototypes.",
	"Method": "void collectAttributePrototypes(Attribute.Set attributePrototypes){\r\n    attributePrototypes.addAttributes(firstAttribute);\r\n}"
}, {
	"Path": "jodd.http.net.Socks4ProxySocketFactory.createSocks4ProxySocket",
	"Comment": "connects to the socks4 proxy and returns proxified socket.",
	"Method": "Socket createSocks4ProxySocket(String host,int port){\r\n    Socket socket = null;\r\n    String proxyHost = proxy.getProxyAddress();\r\n    int proxyPort = proxy.getProxyPort();\r\n    String user = proxy.getProxyUsername();\r\n    try {\r\n        socket = new Socket(proxyHost, proxyPort);\r\n        InputStream in = socket.getInputStream();\r\n        OutputStream out = socket.getOutputStream();\r\n        socket.setTcpNoDelay(true);\r\n        byte[] buf = new byte[1024];\r\n        int index = 0;\r\n        buf[index++] = 4;\r\n        buf[index++] = 1;\r\n        buf[index++] = (byte) (port >>> 8);\r\n        buf[index++] = (byte) (port & 0xff);\r\n        InetAddress addr = InetAddress.getByName(host);\r\n        byte[] byteAddress = addr.getAddress();\r\n        for (byte byteAddres : byteAddress) {\r\n            buf[index++] = byteAddres;\r\n        }\r\n        if (user != null) {\r\n            System.arraycopy(user.getBytes(), 0, buf, index, user.length());\r\n            index += user.length();\r\n        }\r\n        buf[index++] = 0;\r\n        out.write(buf, 0, index);\r\n        int len = 6;\r\n        int s = 0;\r\n        while (s < len) {\r\n            int i = in.read(buf, s, len - s);\r\n            if (i <= 0) {\r\n                throw new HttpException(ProxyInfo.ProxyType.SOCKS4, \"stream is closed\");\r\n            }\r\n            s += i;\r\n        }\r\n        if (buf[0] != 0) {\r\n            throw new HttpException(ProxyInfo.ProxyType.SOCKS4, \"proxy returned VN \" + buf[0]);\r\n        }\r\n        if (buf[1] != 90) {\r\n            try {\r\n                socket.close();\r\n            } catch (Exception ignore) {\r\n            }\r\n            throw new HttpException(ProxyInfo.ProxyType.SOCKS4, \"proxy returned CD \" + buf[1]);\r\n        }\r\n        byte[] temp = new byte[2];\r\n        in.read(temp, 0, 2);\r\n        return socket;\r\n    } catch (RuntimeException rtex) {\r\n        closeSocket(socket);\r\n        throw rtex;\r\n    } catch (Exception ex) {\r\n        closeSocket(socket);\r\n        throw new HttpException(ProxyInfo.ProxyType.SOCKS4, ex.toString(), ex);\r\n    }\r\n}"
}, {
	"Path": "org.jooq.impl.ReferenceImpl.extractValues",
	"Comment": "extract a list of values from a set of records given some fields",
	"Method": "List<Object> extractValues(Collection<? extends R> records,TableField<R, ?> field2){\r\n    List<Object> result = new ArrayList<Object>(records.size());\r\n    for (R record : records) result.add(record.get(field2));\r\n    return result;\r\n}"
}, {
	"Path": "org.joda.time.Period.plusSeconds",
	"Comment": "returns a new period plus the specified number of seconds added.this period instance is immutable and unaffected by this method call.",
	"Method": "Period plusSeconds(int seconds){\r\n    if (seconds == 0) {\r\n        return this;\r\n    }\r\n    int[] values = getValues();\r\n    getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, seconds);\r\n    return new Period(values, getPeriodType());\r\n}"
}, {
	"Path": "org.joda.time.DateTime.toLocalTime",
	"Comment": "converts this object to a localtime with thesame time and chronology.",
	"Method": "LocalTime toLocalTime(){\r\n    return new LocalTime(getMillis(), getChronology());\r\n}"
}, {
	"Path": "org.joda.time.field.DividedDateTimeField.add",
	"Comment": "add the specified amount of scaled units to the specified timeinstant. the amount added may be negative.",
	"Method": "long add(long instant,int amount,long add,long instant,long amount){\r\n    return getWrappedField().add(instant, amount * iDivisor);\r\n}"
}, {
	"Path": "jodd.util.CharUtil.toAscii",
	"Comment": "returns ascii value of a char. in case of overload, 0x3f is returned.",
	"Method": "int toAscii(char c){\r\n    if (c <= 0xFF) {\r\n        return c;\r\n    } else {\r\n        return 0x3F;\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.PeriodType.withMinutesRemoved",
	"Comment": "returns a version of this periodtype instance that does not support minutes.",
	"Method": "PeriodType withMinutesRemoved(){\r\n    return withFieldRemoved(5, \"NoMinutes\");\r\n}"
}, {
	"Path": "jodd.madvoc.config.Targets.makeTargets",
	"Comment": "joins action and parameters into one single array of targets.",
	"Method": "Target[] makeTargets(Target actionTarget,MethodParam[] methodParams){\r\n    if (methodParams == null) {\r\n        return new Target[] { actionTarget };\r\n    }\r\n    final Target[] target = new Target[methodParams.length + 1];\r\n    target[0] = actionTarget;\r\n    final Object action = actionTarget.value();\r\n    for (int i = 0; i < methodParams.length; i++) {\r\n        final MethodParam methodParam = methodParams[i];\r\n        final Class paramType = methodParam.type();\r\n        final Target paramTarget;\r\n        if (methodParam.annotationType() == null) {\r\n            final ScopeData newScopeData = methodParam.scopeData().inspector().inspectClassScopesWithCache(paramType);\r\n            paramTarget = Target.ofValue(createActionMethodArgument(paramType, action), newScopeData);\r\n        } else if (methodParam.annotationType() == Out.class) {\r\n            paramTarget = Target.ofMethodParam(methodParam, createActionMethodArgument(paramType, action));\r\n        } else {\r\n            paramTarget = Target.ofMethodParam(methodParam, type -> createActionMethodArgument(type, action));\r\n        }\r\n        target[i + 1] = paramTarget;\r\n    }\r\n    return target;\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractDateTime.getWeekyear",
	"Comment": "get the weekyear field value.the weekyear is the year that matches with the weekofweekyear field.in the standard iso8601 week algorithm, the first week of the yearis that in which at least 4 days are in the year. as a result of thisdefinition, day 1 of the first week may be in the previous year.the weekyear allows you to query the effective year for that day.",
	"Method": "int getWeekyear(){\r\n    return getChronology().weekyear().get(getMillis());\r\n}"
}, {
	"Path": "jodd.db.oom.mapper.DefaultResultSetMapper.cacheResultSetEntities",
	"Comment": "caches returned entities. replaces new instances with existing ones.",
	"Method": "void cacheResultSetEntities(Object[] result){\r\n    if (entitiesCache == null) {\r\n        entitiesCache = new HashMap();\r\n    }\r\n    for (int i = 0; i < result.length; i++) {\r\n        Object object = result[i];\r\n        if (object == null) {\r\n            continue;\r\n        }\r\n        DbEntityDescriptor ded = cachedDbEntityDescriptors[i];\r\n        if (ded == null) {\r\n            continue;\r\n        }\r\n        Object key;\r\n        if (ded.hasIdColumn()) {\r\n            key = ded.getKeyValue(object);\r\n        } else {\r\n            key = object;\r\n        }\r\n        Object cachedObject = entitiesCache.get(key);\r\n        if (cachedObject == null) {\r\n            entitiesCache.put(key, object);\r\n        } else {\r\n            result[i] = cachedObject;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jodd.proxetta.asm.ProxettaClassBuilder.processSuperMethods",
	"Comment": "checks for all public super methods that are not overridden.",
	"Method": "void processSuperMethods(){\r\n    for (ClassReader cr : targetClassInfo.superClassReaders) {\r\n        cr.accept(new EmptyClassVisitor() {\r\n            String declaredClassName;\r\n            @Override\r\n            public void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces) {\r\n                declaredClassName = name;\r\n            }\r\n            @Override\r\n            public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) {\r\n                if (name.equals(INIT) || name.equals(CLINIT)) {\r\n                    return null;\r\n                }\r\n                MethodSignatureVisitor msign = targetClassInfo.lookupMethodSignatureVisitor(access, name, desc, declaredClassName);\r\n                if (msign == null) {\r\n                    return null;\r\n                }\r\n                return applyProxy(msign);\r\n            }\r\n        }, 0);\r\n    }\r\n}"
}, {
	"Path": "jodd.proxetta.asm.ProxettaClassBuilder.processSuperMethods",
	"Comment": "checks for all public super methods that are not overridden.",
	"Method": "void processSuperMethods(){\r\n    declaredClassName = name;\r\n}"
}, {
	"Path": "jodd.proxetta.asm.ProxettaClassBuilder.processSuperMethods",
	"Comment": "checks for all public super methods that are not overridden.",
	"Method": "void processSuperMethods(){\r\n    if (name.equals(INIT) || name.equals(CLINIT)) {\r\n        return null;\r\n    }\r\n    MethodSignatureVisitor msign = targetClassInfo.lookupMethodSignatureVisitor(access, name, desc, declaredClassName);\r\n    if (msign == null) {\r\n        return null;\r\n    }\r\n    return applyProxy(msign);\r\n}"
}, {
	"Path": "org.json.JSONTokener.nextString",
	"Comment": "return the characters up to the next close quote character.backslash processing is done. the formal json format does notallow strings in single quotes, but an implementation is allowed toaccept them.",
	"Method": "String nextString(char quote){\r\n    char c;\r\n    StringBuilder sb = new StringBuilder();\r\n    for (; ; ) {\r\n        c = this.next();\r\n        switch(c) {\r\n            case 0:\r\n            case '\\n':\r\n            case '\\r':\r\n                throw this.syntaxError(\"Unterminated string\");\r\n            case '\\\\':\r\n                c = this.next();\r\n                switch(c) {\r\n                    case 'b':\r\n                        sb.append('\\b');\r\n                        break;\r\n                    case 't':\r\n                        sb.append('\\t');\r\n                        break;\r\n                    case 'n':\r\n                        sb.append('\\n');\r\n                        break;\r\n                    case 'f':\r\n                        sb.append('\\f');\r\n                        break;\r\n                    case 'r':\r\n                        sb.append('\\r');\r\n                        break;\r\n                    case 'u':\r\n                        try {\r\n                            sb.append((char) Integer.parseInt(this.next(4), 16));\r\n                        } catch (NumberFormatException e) {\r\n                            throw this.syntaxError(\"Illegal escape.\", e);\r\n                        }\r\n                        break;\r\n                    case '\"':\r\n                    case '\\'':\r\n                    case '\\\\':\r\n                    case '/':\r\n                        sb.append(c);\r\n                        break;\r\n                    default:\r\n                        throw this.syntaxError(\"Illegal escape.\");\r\n                }\r\n                break;\r\n            default:\r\n                if (c == quote) {\r\n                    return sb.toString();\r\n                }\r\n                sb.append(c);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jodd.util.NaturalOrderComparator.compareDigits",
	"Comment": "compare digits at certain position in two strings.\tthe longest run of digits wins. that aside, the greatest\tvalue wins.",
	"Method": "int[] compareDigits(String str1,int ndx1,String str2,int ndx2){\r\n    int zeroCount1 = 0;\r\n    while (charAt(str1, ndx1) == '0') {\r\n        zeroCount1++;\r\n        ndx1++;\r\n    }\r\n    int len1 = 0;\r\n    while (true) {\r\n        final char char1 = charAt(str1, ndx1);\r\n        final boolean isDigitChar1 = CharUtil.isDigit(char1);\r\n        if (!isDigitChar1) {\r\n            break;\r\n        }\r\n        len1++;\r\n        ndx1++;\r\n    }\r\n    int zeroCount2 = 0;\r\n    while (charAt(str2, ndx2) == '0') {\r\n        zeroCount2++;\r\n        ndx2++;\r\n    }\r\n    int len2 = 0;\r\n    int ndx1_new = ndx1 - len1;\r\n    int equalNumbers = 0;\r\n    while (true) {\r\n        final char char2 = charAt(str2, ndx2);\r\n        final boolean isDigitChar2 = CharUtil.isDigit(char2);\r\n        if (!isDigitChar2) {\r\n            break;\r\n        }\r\n        if (equalNumbers == 0 && (ndx1_new < ndx1)) {\r\n            equalNumbers = charAt(str1, ndx1_new++) - char2;\r\n        }\r\n        len2++;\r\n        ndx2++;\r\n    }\r\n    if (len1 != len2) {\r\n        return new int[] { len1 - len2 };\r\n    }\r\n    if (equalNumbers != 0) {\r\n        return new int[] { equalNumbers };\r\n    }\r\n    return new int[] { 0, zeroCount1 - zeroCount2, ndx1, ndx2 };\r\n}"
}, {
	"Path": "org.joda.time.Months.isGreaterThan",
	"Comment": "is this months instance greater than the specified number of months.",
	"Method": "boolean isGreaterThan(Months other){\r\n    if (other == null) {\r\n        return getValue() > 0;\r\n    }\r\n    return getValue() > other.getValue();\r\n}"
}, {
	"Path": "org.joda.time.PeriodType.withHoursRemoved",
	"Comment": "returns a version of this periodtype instance that does not support hours.",
	"Method": "PeriodType withHoursRemoved(){\r\n    return withFieldRemoved(4, \"NoHours\");\r\n}"
}, {
	"Path": "org.json.JSONObject.optDouble",
	"Comment": "get an optional double associated with a key, or the defaultvalue ifthere is no such key or if its value is not a number. if the value is astring, an attempt will be made to evaluate it as a number.",
	"Method": "double optDouble(String key,double optDouble,String key,double defaultValue){\r\n    Number val = this.optNumber(key);\r\n    if (val == null) {\r\n        return defaultValue;\r\n    }\r\n    final double doubleValue = val.doubleValue();\r\n    return doubleValue;\r\n}"
}, {
	"Path": "jodd.io.upload.impl.DiskFileUpload.getFileContent",
	"Comment": "returns files content from disk file.\tif error occurs, it returns null",
	"Method": "byte[] getFileContent(){\r\n    return FileUtil.readBytes(file);\r\n}"
}, {
	"Path": "org.joda.time.MutableDateTime.getRoundingField",
	"Comment": "gets the field used for rounding this instant, returning null if roundingis not enabled.",
	"Method": "DateTimeField getRoundingField(){\r\n    return iRoundingField;\r\n}"
}, {
	"Path": "jodd.util.Format.alignRightAndPad",
	"Comment": "puts the text to the right and pads it with spaces until the size is reached.",
	"Method": "String alignRightAndPad(String text,int size){\r\n    int textLength = text.length();\r\n    if (textLength > size) {\r\n        return text.substring(textLength - size, textLength);\r\n    }\r\n    final StringBuilder sb = new StringBuilder(size);\r\n    while (textLength++ < size) {\r\n        sb.append(' ');\r\n    }\r\n    sb.append(text);\r\n    return sb.toString();\r\n}"
}, {
	"Path": "jodd.db.DbSession.rollbackTransaction",
	"Comment": "roll back the current transaction. transaction mode is closed.",
	"Method": "void rollbackTransaction(){\r\n    log.debug(\"Rolling-back transaction\");\r\n    assertTxIsActive();\r\n    try {\r\n        connection.rollback();\r\n    } catch (SQLException sex) {\r\n        throw new DbSqlException(\"Rollback TX failed\", sex);\r\n    } finally {\r\n        closeTx();\r\n    }\r\n}"
}, {
	"Path": "jodd.lagarto.dom.NodeSelector.selectFirst",
	"Comment": "selects nodes using css3 selector query and returns the very first one.",
	"Method": "Node selectFirst(String query,Node selectFirst,NodeFilter nodeFilter){\r\n    List<Node> selectedNodes = select(nodeFilter);\r\n    if (selectedNodes.isEmpty()) {\r\n        return null;\r\n    }\r\n    return selectedNodes.get(0);\r\n}"
}, {
	"Path": "jodd.jerry.Jerry.has",
	"Comment": "reduce the set of matched elements to those that have a descendant that\tmatches the selector or dom element.",
	"Method": "Jerry has(String cssSelectors){\r\n    List<Node> result = new NodeList(nodes.length);\r\n    if (nodes.length > 0) {\r\n        for (Node node : nodes) {\r\n            NodeSelector nodeSelector = createNodeSelector(node);\r\n            List<Node> selectedNodes = nodeSelector.select(cssSelectors);\r\n            if (!selectedNodes.isEmpty()) {\r\n                result.add(node);\r\n            }\r\n        }\r\n    }\r\n    return new Jerry(this, result);\r\n}"
}, {
	"Path": "jodd.servlet.wrapper.BufferResponseWrapper.bufferContentType",
	"Comment": "determines if some content type has to be buffered. by default returns true.",
	"Method": "boolean bufferContentType(String contentType,String mimeType,String encoding){\r\n    return true;\r\n}"
}, {
	"Path": "jodd.proxetta.ClassInfo.hasAnnotation",
	"Comment": "returns true if class is annotated with one of provided annotation.",
	"Method": "boolean hasAnnotation(Class<? extends Annotation> an){\r\n    AnnotationInfo[] anns = getAnnotations();\r\n    if (anns == null) {\r\n        return false;\r\n    }\r\n    for (Class<? extends Annotation> annotationClass : an) {\r\n        String anName = annotationClass.getName();\r\n        for (AnnotationInfo ann : anns) {\r\n            if (ann.getAnnotationClassname().equals(anName)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.joda.time.chrono.BasicChronology.getDaysInMonthMaxForSet",
	"Comment": "gets the maximum number of days in the month specified by the instant.the value represents what the user is trying to set, and can beused to optimise this method.",
	"Method": "int getDaysInMonthMaxForSet(long instant,int value){\r\n    return getDaysInMonthMax(instant);\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractPeriod.hashCode",
	"Comment": "gets a hash code for the period as defined by readableperiod.",
	"Method": "int hashCode(){\r\n    int total = 17;\r\n    for (int i = 0, isize = size(); i < isize; i++) {\r\n        total = 27 * total + getValue(i);\r\n        total = 27 * total + getFieldType(i).hashCode();\r\n    }\r\n    return total;\r\n}"
}, {
	"Path": "org.joda.time.DateTimeComparator.getUpperLimit",
	"Comment": "gets the field type that represents the upper limit of comparison.",
	"Method": "DateTimeFieldType getUpperLimit(){\r\n    return iUpperLimit;\r\n}"
}, {
	"Path": "org.joda.time.IllegalFieldValueException.getIllegalNumberValue",
	"Comment": "returns the illegal integer value assigned to the field, or null if not applicable.",
	"Method": "Number getIllegalNumberValue(){\r\n    return iNumberValue;\r\n}"
}, {
	"Path": "org.json.JSONArray.optDouble",
	"Comment": "get the optional double value associated with an index. the defaultvalueis returned if there is no value for the index, or if the value is not anumber and cannot be converted to a number.",
	"Method": "double optDouble(int index,double optDouble,int index,double defaultValue){\r\n    final Number val = this.optNumber(index, null);\r\n    if (val == null) {\r\n        return defaultValue;\r\n    }\r\n    final double doubleValue = val.doubleValue();\r\n    return doubleValue;\r\n}"
}, {
	"Path": "org.joda.time.Interval.withChronology",
	"Comment": "creates a new interval with the same start and end, but a different chronology.",
	"Method": "Interval withChronology(Chronology chronology){\r\n    if (getChronology() == chronology) {\r\n        return this;\r\n    }\r\n    return new Interval(getStartMillis(), getEndMillis(), chronology);\r\n}"
}, {
	"Path": "org.joda.example.time.DateTimeBrowser.usage",
	"Comment": "usage a private static method to display usage information tothe user before an error exit.",
	"Method": "void usage(){\r\n    System.err.println(\"Usage:\");\r\n    System.err.print(\"java <options> \");\r\n    System.err.print(DateTimeBrowser.class.getName());\r\n    System.err.println(\" <filename>\");\r\n    System.err.println(\"<filename> contains a list of Strings\");\r\n    System.err.println(\"\\twhich are valid for DateTime instantiation.\");\r\n    System.err.println(\"<optons>\");\r\n    System.err.println(\"\\t-Duse.time.zone=\");\r\n    System.err.println(\"\\t\\tA valid timezone name.  If not specified\");\r\n    System.err.println(\"\\t\\tthe OS/user default is used.  If sepcified\");\r\n    System.err.println(\"\\t\\tincorrectly, GMT is quietly used.\");\r\n    System.err.println(\"\\t-Duse.view=\");\r\n    System.err.println(\"\\t\\tAn initial view to be displayed.\");\r\n    System.err.println(\"\\t\\tValid names are: getter, hex, date, cal\");\r\n    System.err.println(\"\\t\\tIf incorrectly specified, getter is used.\");\r\n    System.err.println(\"\\t\\tThis becomes the default view.\");\r\n}"
}, {
	"Path": "jodd.util.ClassUtil.getBeanPropertyGetterName",
	"Comment": "returns property name from a getter method.\treturns null if method is not a real getter.",
	"Method": "String getBeanPropertyGetterName(Method method){\r\n    int prefixLength = getBeanPropertyGetterPrefixLength(method);\r\n    if (prefixLength == 0) {\r\n        return null;\r\n    }\r\n    String methodName = method.getName().substring(prefixLength);\r\n    return StringUtil.decapitalize(methodName);\r\n}"
}, {
	"Path": "jodd.htmlstapler.HtmlStaplerBundlesManager.isCssResource",
	"Comment": "returns true if resource is css, so the\tcss urls can be fixed.",
	"Method": "boolean isCssResource(String src){\r\n    return src.endsWith(\".css\");\r\n}"
}, {
	"Path": "jodd.madvoc.config.Targets.forEachTargetAndOut",
	"Comment": "iterates all targets and for each target iterates all out injection points of given scope.",
	"Method": "void forEachTargetAndOut(MadvocScope scope,BiConsumer<Target, InjectionPoint> biConsumer){\r\n    for (final Target target : targets) {\r\n        final ScopeData scopeData = target.scopeData();\r\n        if (scopeData.out() == null) {\r\n            continue;\r\n        }\r\n        for (final InjectionPoint out : scopeData.out()) {\r\n            if (out.scope() != scope) {\r\n                continue;\r\n            }\r\n            biConsumer.accept(target, out);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.Weeks.dividedBy",
	"Comment": "returns a new instance with the weeks divided by the specified divisor.the calculation uses integer division, thus 3 divided by 2 is 1.this instance is immutable and unaffected by this method call.",
	"Method": "Weeks dividedBy(int divisor){\r\n    if (divisor == 1) {\r\n        return this;\r\n    }\r\n    return Weeks.weeks(getValue() / divisor);\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.toLocalTime",
	"Comment": "converts this object to a localtime with the same time and chronology.",
	"Method": "LocalTime toLocalTime(){\r\n    return new LocalTime(getLocalMillis(), getChronology());\r\n}"
}, {
	"Path": "jodd.db.oom.naming.BaseNamingStrategy.setUppercase",
	"Comment": "specifies if table name should be converted to uppercase.\ttable names includes prefix and suffix. otherwise, table name\twill be converted to lowercase.",
	"Method": "void setUppercase(boolean uppercase){\r\n    this.uppercase = uppercase;\r\n}"
}, {
	"Path": "org.joda.time.field.RemainderDateTimeField.set",
	"Comment": "set the specified amount of remainder units to the specified time instant.",
	"Method": "long set(long instant,int value){\r\n    FieldUtils.verifyValueBounds(this, value, 0, iDivisor - 1);\r\n    int divided = getDivided(getWrappedField().get(instant));\r\n    return getWrappedField().set(instant, divided * iDivisor + value);\r\n}"
}, {
	"Path": "org.joda.time.LocalTime.secondOfMinute",
	"Comment": "get the second of minute field property which provides access to advanced functionality.",
	"Method": "Property secondOfMinute(){\r\n    return new Property(this, getChronology().secondOfMinute());\r\n}"
}, {
	"Path": "jodd.util.collection.SortedArrayList.addAll",
	"Comment": "add all of the elements in the given collection to this list.",
	"Method": "boolean addAll(Collection<? extends E> c,boolean addAll,int index,Collection<? extends E> c){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "jodd.db.DbQueryBase.executeCount",
	"Comment": "executes count queries and optionally closes query afterwards.",
	"Method": "long executeCount(long executeCount,boolean close){\r\n    start = System.currentTimeMillis();\r\n    init();\r\n    ResultSet rs = null;\r\n    if (log.isDebugEnabled()) {\r\n        log.debug(\"Executing prepared count: \" + getQueryString());\r\n    }\r\n    try {\r\n        if (preparedStatement == null) {\r\n            rs = statement.executeQuery(query.sql);\r\n        } else {\r\n            rs = preparedStatement.executeQuery();\r\n        }\r\n        final long firstLong = DbUtil.getFirstLong(rs);\r\n        elapsed = System.currentTimeMillis() - start;\r\n        if (log.isDebugEnabled()) {\r\n            log.debug(\"execution time: \" + elapsed + \"ms\");\r\n        }\r\n        return firstLong;\r\n    } catch (SQLException sex) {\r\n        throw new DbSqlException(this, \"Count query failed\", sex);\r\n    } finally {\r\n        DbUtil.close(rs);\r\n        if (close) {\r\n            close();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractPeriod.isSupported",
	"Comment": "checks whether the field specified is supported by this period.",
	"Method": "boolean isSupported(DurationFieldType type){\r\n    return getPeriodType().isSupported(type);\r\n}"
}, {
	"Path": "org.joda.time.Seconds.toStandardDuration",
	"Comment": "converts this period in seconds to a duration in milliseconds assuming a24 hour day, 60 minute hour and 60 second minute.this method allows you to convert from a period to a duration.however to achieve this it makes the assumption that all seconds are 24 hourslong, all hours are 60 minutes and all minutes are 60 seconds.this is not true when daylight savings time is considered, and may alsonot be true for some unusual chronologies. however, it is included as itis a useful operation for many applications and business rules.",
	"Method": "Duration toStandardDuration(){\r\n    long seconds = getValue();\r\n    return new Duration(seconds * DateTimeConstants.MILLIS_PER_SECOND);\r\n}"
}, {
	"Path": "org.joda.time.DateTime.withMinuteOfHour",
	"Comment": "returns a copy of this datetime with the minute of hour updated.datetime is immutable, so there are no set methods.instead, this method returns a new instance with the value ofminute of hour changed.",
	"Method": "DateTime withMinuteOfHour(int minute){\r\n    return withMillis(getChronology().minuteOfHour().set(getMillis(), minute));\r\n}"
}, {
	"Path": "org.joda.time.DateTimeZone.setNameProvider",
	"Comment": "sets the name provider factory.the name provider is a pluggable instance factory that supplies thenames of each datetimezone.",
	"Method": "void setNameProvider(NameProvider nameProvider){\r\n    SecurityManager sm = System.getSecurityManager();\r\n    if (sm != null) {\r\n        sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\"));\r\n    }\r\n    if (nameProvider == null) {\r\n        nameProvider = getDefaultNameProvider();\r\n    }\r\n    cNameProvider.set(nameProvider);\r\n}"
}, {
	"Path": "org.joda.time.convert.ConverterManager.removePartialConverter",
	"Comment": "removes a converter from the set of converters. if the converter wasnot in the set, no changes are made.",
	"Method": "PartialConverter removePartialConverter(PartialConverter converter){\r\n    checkAlterPartialConverters();\r\n    if (converter == null) {\r\n        return null;\r\n    }\r\n    PartialConverter[] removed = new PartialConverter[1];\r\n    iPartialConverters = iPartialConverters.remove(converter, removed);\r\n    return removed[0];\r\n}"
}, {
	"Path": "org.joda.time.DateTime.withDayOfMonth",
	"Comment": "returns a copy of this datetime with the day of month field updated.datetime is immutable, so there are no set methods.instead, this method returns a new instance with the value ofday of month changed.",
	"Method": "DateTime withDayOfMonth(int dayOfMonth){\r\n    return withMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth));\r\n}"
}, {
	"Path": "org.json.JSONObject.optFloat",
	"Comment": "get the optional double value associated with an index. the defaultvalueis returned if there is no value for the index, or if the value is not anumber and cannot be converted to a number.",
	"Method": "float optFloat(String key,float optFloat,String key,float defaultValue){\r\n    Number val = this.optNumber(key);\r\n    if (val == null) {\r\n        return defaultValue;\r\n    }\r\n    final float floatValue = val.floatValue();\r\n    return floatValue;\r\n}"
}, {
	"Path": "jodd.props.Props.loadEnvironment",
	"Comment": "loads environment properties with given prefix.\tif prefix is null it will not be used.",
	"Method": "Props loadEnvironment(String prefix){\r\n    final Map<String, String> environmentMap = System.getenv();\r\n    load(environmentMap, prefix);\r\n    return this;\r\n}"
}, {
	"Path": "jodd.asm7.SymbolTable.addConstant",
	"Comment": "adds a number or string constant to the constant pool of this symbol table. does nothing if theconstant pool already contains a similar item.",
	"Method": "Symbol addConstant(Object value){\r\n    if (value instanceof Integer) {\r\n        return addConstantInteger(((Integer) value).intValue());\r\n    } else if (value instanceof Byte) {\r\n        return addConstantInteger(((Byte) value).intValue());\r\n    } else if (value instanceof Character) {\r\n        return addConstantInteger(((Character) value).charValue());\r\n    } else if (value instanceof Short) {\r\n        return addConstantInteger(((Short) value).intValue());\r\n    } else if (value instanceof Boolean) {\r\n        return addConstantInteger(((Boolean) value).booleanValue() ? 1 : 0);\r\n    } else if (value instanceof Float) {\r\n        return addConstantFloat(((Float) value).floatValue());\r\n    } else if (value instanceof Long) {\r\n        return addConstantLong(((Long) value).longValue());\r\n    } else if (value instanceof Double) {\r\n        return addConstantDouble(((Double) value).doubleValue());\r\n    } else if (value instanceof String) {\r\n        return addConstantString((String) value);\r\n    } else if (value instanceof Type) {\r\n        Type type = (Type) value;\r\n        int typeSort = type.getSort();\r\n        if (typeSort == Type.OBJECT) {\r\n            return addConstantClass(type.getInternalName());\r\n        } else if (typeSort == Type.METHOD) {\r\n            return addConstantMethodType(type.getDescriptor());\r\n        } else {\r\n            return addConstantClass(type.getDescriptor());\r\n        }\r\n    } else if (value instanceof Handle) {\r\n        Handle handle = (Handle) value;\r\n        return addConstantMethodHandle(handle.getTag(), handle.getOwner(), handle.getName(), handle.getDesc(), handle.isInterface());\r\n    } else if (value instanceof ConstantDynamic) {\r\n        ConstantDynamic constantDynamic = (ConstantDynamic) value;\r\n        return addConstantDynamic(constantDynamic.getName(), constantDynamic.getDescriptor(), constantDynamic.getBootstrapMethod(), constantDynamic.getBootstrapMethodArgumentsUnsafe());\r\n    } else {\r\n        throw new IllegalArgumentException(\"value \" + value);\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.format.DateTimeFormatterBuilder.appendClockhourOfHalfday",
	"Comment": "instructs the printer to emit a numeric clockhourofhalfday field.",
	"Method": "DateTimeFormatterBuilder appendClockhourOfHalfday(int minDigits){\r\n    return appendDecimal(DateTimeFieldType.clockhourOfHalfday(), minDigits, 2);\r\n}"
}, {
	"Path": "org.jooq.codegen.JavaGenerator.generateEnumClassJavadoc",
	"Comment": "subclasses may override this method to provide their own javadoc.",
	"Method": "void generateEnumClassJavadoc(EnumDefinition e,JavaWriter out){\r\n    if (generateCommentsOnUDTs())\r\n        printClassJavadoc(out, e);\r\n    else\r\n        printClassJavadoc(out, \"The enum <code>\" + e.getQualifiedInputName() + \"<\/code>.\");\r\n}"
}, {
	"Path": "org.joda.time.Partial.toString",
	"Comment": "output the date using the specified format pattern.unsupported fields will appear as special unicode characters.",
	"Method": "String toString(String toString,String pattern,String toString,String pattern,Locale locale){\r\n    if (pattern == null) {\r\n        return toString();\r\n    }\r\n    return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\r\n}"
}, {
	"Path": "org.joda.time.IllegalFieldValueException.getLowerBound",
	"Comment": "returns the lower bound of the legal value range, or null if not applicable.",
	"Method": "Number getLowerBound(){\r\n    return iLowerBound;\r\n}"
}, {
	"Path": "jodd.util.StringUtil.lastIndexOfIgnoreCase",
	"Comment": "finds last index of a substring in the given source string with ignored\tcase in specified range.",
	"Method": "int lastIndexOfIgnoreCase(String s,String subS,int lastIndexOfIgnoreCase,String src,String subS,int startIndex,int lastIndexOfIgnoreCase,String src,String sub,int startIndex,int endIndex,int lastIndexOfIgnoreCase,String src,char c,int startIndex,int endIndex,int[] lastIndexOfIgnoreCase,String s,String arr,int[] lastIndexOfIgnoreCase,String s,String[] arr,int fromIndex){\r\n    int arrLen = arr.length;\r\n    int index = -1;\r\n    int last = -1;\r\n    for (int j = 0; j < arrLen; j++) {\r\n        int i = lastIndexOfIgnoreCase(s, arr[j], fromIndex);\r\n        if (i != -1) {\r\n            if (i > index) {\r\n                index = i;\r\n                last = j;\r\n            }\r\n        }\r\n    }\r\n    return last == -1 ? null : new int[] { last, index };\r\n}"
}, {
	"Path": "org.joda.time.Period.minusMinutes",
	"Comment": "returns a new period minus the specified number of minutes taken away.this period instance is immutable and unaffected by this method call.",
	"Method": "Period minusMinutes(int minutes){\r\n    return plusMinutes(-minutes);\r\n}"
}, {
	"Path": "org.json.JSONObject.increment",
	"Comment": "increment a property of a jsonobject. if there is no such property,create one with a value of 1. if there is such a property, and if it isan integer, long, double, or float, then add one to it.",
	"Method": "JSONObject increment(String key){\r\n    Object value = this.opt(key);\r\n    if (value == null) {\r\n        this.put(key, 1);\r\n    } else if (value instanceof BigInteger) {\r\n        this.put(key, ((BigInteger) value).add(BigInteger.ONE));\r\n    } else if (value instanceof BigDecimal) {\r\n        this.put(key, ((BigDecimal) value).add(BigDecimal.ONE));\r\n    } else if (value instanceof Integer) {\r\n        this.put(key, ((Integer) value).intValue() + 1);\r\n    } else if (value instanceof Long) {\r\n        this.put(key, ((Long) value).longValue() + 1L);\r\n    } else if (value instanceof Double) {\r\n        this.put(key, ((Double) value).doubleValue() + 1.0d);\r\n    } else if (value instanceof Float) {\r\n        this.put(key, ((Float) value).floatValue() + 1.0f);\r\n    } else {\r\n        throw new JSONException(\"Unable to increment [\" + quote(key) + \"].\");\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "jodd.db.oom.sqlgen.DbSqlBuilder.parse",
	"Comment": "builds the query and returns parsed data.\treturned value can be cached or stored as a constant value\tto prevent further parsing of the same code.",
	"Method": "ParsedSql parse(){\r\n    return new ParsedSql(this);\r\n}"
}, {
	"Path": "jodd.util.ClassLoaderUtil.getClassAsStream",
	"Comment": "opens a class of the specified name for reading using provided class loader.",
	"Method": "InputStream getClassAsStream(Class clazz,InputStream getClassAsStream,String className,InputStream getClassAsStream,String className,ClassLoader classLoader){\r\n    return getResourceAsStream(ClassUtil.convertClassNameToFileName(className), classLoader);\r\n}"
}, {
	"Path": "org.apache.jorphan.gui.TableModelEventBacker.assertEvents",
	"Comment": "checks each event assertion against each backed event in order. event storage is cleared after it.",
	"Method": "void assertEvents(EventAssertion assertions){\r\n    try {\r\n        assertEquals(\"event count\", assertions.length, events.size());\r\n        int i = 0;\r\n        for (TableModelEvent event : events) {\r\n            assertions[i].assertEvent(event, i++);\r\n        }\r\n    } finally {\r\n        events.clear();\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractInterval.isAfterNow",
	"Comment": "is this time interval after the current instant.intervals are inclusive of the start instant and exclusive of the end.",
	"Method": "boolean isAfterNow(){\r\n    return isAfter(DateTimeUtils.currentTimeMillis());\r\n}"
}, {
	"Path": "org.jooq.impl.DSL.localDateSub",
	"Comment": "subtract an interval from a date, given a date part.this translates into any dialect",
	"Method": "Field<LocalDate> localDateSub(LocalDate date,Number interval,Field<LocalDate> localDateSub,Field<LocalDate> date,Field<? extends Number> interval,Field<LocalDate> localDateSub,LocalDate date,Number interval,DatePart datePart,Field<LocalDate> localDateSub,LocalDate date,Field<? extends Number> interval,DatePart datePart,Field<LocalDate> localDateSub,Field<LocalDate> date,Number interval,DatePart datePart,Field<LocalDate> localDateSub,Field<LocalDate> date,Field<? extends Number> interval,DatePart datePart){\r\n    return new DateAdd<LocalDate>(nullSafe(date), nullSafe(interval).neg(), datePart);\r\n}"
}, {
	"Path": "org.jsonschema2pojo.rules.RuleFactory.getAnnotator",
	"Comment": "gets the annotator that will in apply annotations to the generated codeto allow correct serialization and deserialization, according to thechosen annotation style.",
	"Method": "Annotator getAnnotator(){\r\n    return annotator;\r\n}"
}, {
	"Path": "jodd.joy.JoyDb.createConnectionProviderIfNotSupplied",
	"Comment": "returns connectionprovider instance.\tinstance will be registered into the petite context.",
	"Method": "ConnectionProvider createConnectionProviderIfNotSupplied(){\r\n    if (connectionProviderSupplier != null) {\r\n        return connectionProviderSupplier.get();\r\n    }\r\n    return new CoreConnectionPool();\r\n}"
}, {
	"Path": "jodd.util.StringUtil.isCharAtEqual",
	"Comment": "safely compares provided char with char on given location.",
	"Method": "boolean isCharAtEqual(String string,int index,char charToCompare){\r\n    if ((index < 0) || (index >= string.length())) {\r\n        return false;\r\n    }\r\n    return string.charAt(index) == charToCompare;\r\n}"
}, {
	"Path": "org.joda.time.Partial.plus",
	"Comment": "gets a copy of this instance with the specified period added.if the amount is zero or null, then this is returned.",
	"Method": "Partial plus(ReadablePeriod period){\r\n    return withPeriodAdded(period, 1);\r\n}"
}, {
	"Path": "org.jooq.impl.AbstractQuery.isExecutable",
	"Comment": "default implementation for executable check. subclasses may override thismethod.",
	"Method": "boolean isExecutable(){\r\n    return true;\r\n}"
}, {
	"Path": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField.get",
	"Comment": "get the week of a week based year component of the specified time instant.",
	"Method": "int get(long instant){\r\n    return iChronology.getWeekOfWeekyear(instant);\r\n}"
}, {
	"Path": "org.joda.time.PeriodType.yearWeekDay",
	"Comment": "gets a type that defines year, week and day fields.yearsweeksdays",
	"Method": "PeriodType yearWeekDay(){\r\n    PeriodType type = cYWD;\r\n    if (type == null) {\r\n        type = new PeriodType(\"YearWeekDay\", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.weeks(), DurationFieldType.days() }, new int[] { 0, -1, 1, 2, -1, -1, -1, -1 });\r\n        cYWD = type;\r\n    }\r\n    return type;\r\n}"
}, {
	"Path": "jodd.madvoc.component.MadvocComponentLifecycle.invoke",
	"Comment": "invoke the listener based on type.\tnot very oop, but works.",
	"Method": "void invoke(Object listener,Class listenerType){\r\n    if (listenerType == Init.class) {\r\n        ((Init) listener).init();\r\n        return;\r\n    }\r\n    if (listenerType == Start.class) {\r\n        ((Start) listener).start();\r\n        return;\r\n    }\r\n    if (listenerType == Ready.class) {\r\n        ((Ready) listener).ready();\r\n        return;\r\n    }\r\n    if (listenerType == Stop.class) {\r\n        ((Stop) listener).stop();\r\n        return;\r\n    }\r\n    throw new MadvocException(\"Invalid listener\");\r\n}"
}, {
	"Path": "jodd.io.findfile.FindFile.addPath",
	"Comment": "adds existing search path to the file list.\tnon existing files are ignored.\tif path is a folder, it will be scanned for all files.",
	"Method": "void addPath(File path){\r\n    if (!path.exists()) {\r\n        return;\r\n    }\r\n    if (pathList == null) {\r\n        pathList = new LinkedList();\r\n    }\r\n    pathList.add(path);\r\n}"
}, {
	"Path": "jodd.joy.auth.AuthInterceptor.authenticateUserViaHttpSession",
	"Comment": "tries to authenticate user via http session. returns the token if user is authenticated.\treturned token may be rotated.",
	"Method": "T authenticateUserViaHttpSession(ActionRequest actionRequest){\r\n    final HttpServletRequest servletRequest = actionRequest.getHttpServletRequest();\r\n    final UserSession<T> userSession = UserSession.get(servletRequest);\r\n    if (userSession == null) {\r\n        return null;\r\n    }\r\n    final T authToken = userSession.getAuthToken();\r\n    if (authToken == null) {\r\n        return null;\r\n    }\r\n    final T newAuthToken = userAuth().rotateToken(authToken);\r\n    if (newAuthToken != authToken) {\r\n        final UserSession<T> newUserSesion = new UserSession(newAuthToken, userAuth().tokenValue(newAuthToken));\r\n        newUserSesion.start(servletRequest, actionRequest.getHttpServletResponse());\r\n    }\r\n    return newAuthToken;\r\n}"
}, {
	"Path": "org.joda.time.DateTime.monthOfYear",
	"Comment": "get the month of year property which provides access to advanced functionality.",
	"Method": "Property monthOfYear(){\r\n    return new Property(this, getChronology().monthOfYear());\r\n}"
}, {
	"Path": "jodd.asm7.SymbolTable.setMajorVersionAndClassName",
	"Comment": "sets the major version and the name of the class to which this symbol table belongs. also addsthe class name to the constant pool.",
	"Method": "int setMajorVersionAndClassName(int majorVersion,String className){\r\n    this.majorVersion = majorVersion;\r\n    this.className = className;\r\n    return addConstantClass(className).index;\r\n}"
}, {
	"Path": "jodd.db.querymap.DbPropsQueryMap.getQuery",
	"Comment": "returns query for given key.\tin debug mode, props are reloaded every time before the lookup.",
	"Method": "String getQuery(String key){\r\n    return props.getValue(key);\r\n}"
}, {
	"Path": "org.jsonschema2pojo.integration.util.Jsonschema2PojoRule.compilePattern",
	"Comment": "returns the compiled pattern, or null if the pattern could not compile.",
	"Method": "Pattern compilePattern(String pattern){\r\n    try {\r\n        return Pattern.compile(pattern);\r\n    } catch (Exception e) {\r\n        System.err.println(\"Could not compile pattern \" + pattern);\r\n        e.printStackTrace(System.err);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.Duration.dividedBy",
	"Comment": "returns a new duration with this length divided by the specified divisor.this instance is immutable and is not altered.if the divisor is one, this instance is returned.",
	"Method": "Duration dividedBy(long divisor,Duration dividedBy,long divisor,RoundingMode roundingMode){\r\n    if (divisor == 1) {\r\n        return this;\r\n    }\r\n    return new Duration(FieldUtils.safeDivide(getMillis(), divisor, roundingMode));\r\n}"
}, {
	"Path": "jodd.db.DbQueryBase.executeUpdate",
	"Comment": "executes update, insert or delete queries and optionally closes the query.",
	"Method": "int executeUpdate(int executeUpdate,boolean closeQuery){\r\n    start = System.currentTimeMillis();\r\n    init();\r\n    final int result;\r\n    if (log.isDebugEnabled()) {\r\n        log.debug(\"Executing update: \" + getQueryString());\r\n    }\r\n    try {\r\n        if (preparedStatement == null) {\r\n            if (generatedColumns != null) {\r\n                if (generatedColumns.length == 0) {\r\n                    result = statement.executeUpdate(query.sql, Statement.RETURN_GENERATED_KEYS);\r\n                } else {\r\n                    result = statement.executeUpdate(query.sql, generatedColumns);\r\n                }\r\n            } else {\r\n                result = statement.executeUpdate(query.sql);\r\n            }\r\n        } else {\r\n            result = preparedStatement.executeUpdate();\r\n        }\r\n    } catch (SQLException sex) {\r\n        throw new DbSqlException(this, \"Query execution failed\", sex);\r\n    }\r\n    if (closeQuery) {\r\n        close();\r\n    }\r\n    elapsed = System.currentTimeMillis() - start;\r\n    if (log.isDebugEnabled()) {\r\n        log.debug(\"execution time: \" + elapsed + \"ms\");\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Database.isIncludePrimaryKeys",
	"Comment": "this flag indicates whether primary keys should be included in output produced by this database",
	"Method": "Boolean isIncludePrimaryKeys(){\r\n    return includePrimaryKeys;\r\n}"
}, {
	"Path": "jodd.http.Cookie.isSecure",
	"Comment": "returns true if the browser is sending cookies\tonly over a secure protocol, or false if the\tbrowser can send cookies using any protocol.",
	"Method": "boolean isSecure(){\r\n    return secure;\r\n}"
}, {
	"Path": "jodd.http.HttpRequest.connectionProvider",
	"Comment": "returns http connection provider that was used for creating\tcurrent http connection. if null, default\tconnection provider will be used.",
	"Method": "HttpConnectionProvider connectionProvider(){\r\n    return httpConnectionProvider;\r\n}"
}, {
	"Path": "org.joda.time.LocalTime.withMillisOfDay",
	"Comment": "returns a copy of this time with the millis of day field updated.localtime is immutable, so there are no set methods.instead, this method returns a new instance with the value ofmillis of day changed.",
	"Method": "LocalTime withMillisOfDay(int millis){\r\n    return withLocalMillis(getChronology().millisOfDay().set(getLocalMillis(), millis));\r\n}"
}, {
	"Path": "org.joda.time.Duration.millis",
	"Comment": "create a duration with the specified number of milliseconds.",
	"Method": "Duration millis(long millis){\r\n    if (millis == 0) {\r\n        return ZERO;\r\n    }\r\n    return new Duration(millis);\r\n}"
}, {
	"Path": "jodd.asm7.TypeReference.newTypeParameterBoundReference",
	"Comment": "returns a reference to a type parameter bound of a generic class or method.",
	"Method": "TypeReference newTypeParameterBoundReference(int sort,int paramIndex,int boundIndex){\r\n    return new TypeReference((sort << 24) | (paramIndex << 16) | (boundIndex << 8));\r\n}"
}, {
	"Path": "org.joda.time.Interval.withDurationAfterStart",
	"Comment": "creates a new interval with the specified duration after the start instant.",
	"Method": "Interval withDurationAfterStart(ReadableDuration duration){\r\n    long durationMillis = DateTimeUtils.getDurationMillis(duration);\r\n    if (durationMillis == toDurationMillis()) {\r\n        return this;\r\n    }\r\n    Chronology chrono = getChronology();\r\n    long startMillis = getStartMillis();\r\n    long endMillis = chrono.add(startMillis, durationMillis, 1);\r\n    return new Interval(startMillis, endMillis, chrono);\r\n}"
}, {
	"Path": "jodd.madvoc.MadvocResponseWrapper.applyContentType",
	"Comment": "applies content type to the response.\tcalled before output stream or a writer are used.",
	"Method": "void applyContentType(){\r\n    if (mimeType != null) {\r\n        super.setContentType(mimeType);\r\n        if (characterEncoding != null) {\r\n            super.setCharacterEncoding(characterEncoding);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jodd.props.PropsEntries.skipDuplicatesByPosition",
	"Comment": "skips all keys after first definition, even if value is set later.",
	"Method": "PropsEntries skipDuplicatesByPosition(){\r\n    propsIterator.skipDuplicatesByPosition = true;\r\n    propsIterator.skipDuplicatesByValue = false;\r\n    return this;\r\n}"
}, {
	"Path": "org.joda.time.Days.isGreaterThan",
	"Comment": "is this days instance greater than the specified number of days.",
	"Method": "boolean isGreaterThan(Days other){\r\n    if (other == null) {\r\n        return getValue() > 0;\r\n    }\r\n    return getValue() > other.getValue();\r\n}"
}, {
	"Path": "jodd.cache.AbstractCacheMap.isPruneExpiredActive",
	"Comment": "returns true if prune of expired objects should be invoked.\tfor internal use.",
	"Method": "boolean isPruneExpiredActive(){\r\n    return (timeout != 0) || existCustomTimeout;\r\n}"
}, {
	"Path": "jodd.db.DbQueryBase.getGeneratedKey",
	"Comment": "returns generated key i.e. first generated column as long.",
	"Method": "long getGeneratedKey(){\r\n    checkInitialized();\r\n    final ResultSet rs = getGeneratedColumns();\r\n    try {\r\n        return DbUtil.getFirstLong(rs);\r\n    } catch (SQLException sex) {\r\n        throw new DbSqlException(this, \"No generated key as long\", sex);\r\n    } finally {\r\n        DbUtil.close(rs);\r\n        resultSets.remove(rs);\r\n        totalOpenResultSetCount--;\r\n    }\r\n}"
}, {
	"Path": "jodd.typeconverter.Converter.toDoubleValue",
	"Comment": "converts value to double. returns default value\twhen conversion result is null.",
	"Method": "double toDoubleValue(Object value,double defaultValue,double toDoubleValue,Object value){\r\n    return toDoubleValue(value, 0);\r\n}"
}, {
	"Path": "org.joda.time.DateTimeZone.setProvider",
	"Comment": "sets the zone provider factory.the zone provider is a pluggable instance factory that supplies theactual instances of datetimezone.",
	"Method": "void setProvider(Provider provider){\r\n    SecurityManager sm = System.getSecurityManager();\r\n    if (sm != null) {\r\n        sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setProvider\"));\r\n    }\r\n    if (provider == null) {\r\n        provider = getDefaultProvider();\r\n    } else {\r\n        validateProvider(provider);\r\n    }\r\n    cProvider.set(provider);\r\n}"
}, {
	"Path": "org.joda.time.Minutes.minutesIn",
	"Comment": "creates a minutes representing the number of whole minutesin the specified interval.",
	"Method": "Minutes minutesIn(ReadableInterval interval){\r\n    if (interval == null) {\r\n        return Minutes.ZERO;\r\n    }\r\n    int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.minutes());\r\n    return Minutes.minutes(amount);\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.withMillisOfDay",
	"Comment": "returns a copy of this datetime with the millis of day field updated.localdatetime is immutable, so there are no set methods.instead, this method returns a new instance with the value ofmillis of day changed.",
	"Method": "LocalDateTime withMillisOfDay(int millis){\r\n    return withLocalMillis(getChronology().millisOfDay().set(getLocalMillis(), millis));\r\n}"
}, {
	"Path": "com.jayway.jsonpath.internal.function.Parameter.toList",
	"Comment": "translate the collection of parameters into a collection of values of type t.",
	"Method": "List<T> toList(Class<T> type,EvaluationContext ctx,List<Parameter> parameters){\r\n    List<T> values = new ArrayList();\r\n    if (null != parameters) {\r\n        for (Parameter param : parameters) {\r\n            consume(type, ctx, values, param.getValue());\r\n        }\r\n    }\r\n    return values;\r\n}"
}, {
	"Path": "jodd.net.HtmlDecoder.detectName",
	"Comment": "detects the longest character reference name on given position in char array.",
	"Method": "String detectName(char[] input,int ndx){\r\n    final Ptr ptr = new Ptr();\r\n    int firstIndex = 0;\r\n    int lastIndex = ENTITY_NAMES.length - 1;\r\n    int len = input.length;\r\n    char[] lastName = null;\r\n    final BinarySearchBase binarySearch = new BinarySearchBase() {\r\n        @Override\r\n        protected int compare(final int index) {\r\n            char[] name = ENTITY_NAMES[index];\r\n            if (ptr.offset >= name.length) {\r\n                return -1;\r\n            }\r\n            return name[ptr.offset] - ptr.c;\r\n        }\r\n    };\r\n    while (true) {\r\n        ptr.c = input[ndx];\r\n        if (!CharUtil.isAlphaOrDigit(ptr.c)) {\r\n            return lastName != null ? new String(lastName) : null;\r\n        }\r\n        firstIndex = binarySearch.findFirst(firstIndex, lastIndex);\r\n        if (firstIndex < 0) {\r\n            return lastName != null ? new String(lastName) : null;\r\n        }\r\n        char[] element = ENTITY_NAMES[firstIndex];\r\n        if (element.length == ptr.offset + 1) {\r\n            lastName = ENTITY_NAMES[firstIndex];\r\n        }\r\n        lastIndex = binarySearch.findLast(firstIndex, lastIndex);\r\n        if (firstIndex == lastIndex) {\r\n            for (int i = ptr.offset; i < element.length; i++) {\r\n                if (element[i] != input[ndx]) {\r\n                    return lastName != null ? new String(lastName) : null;\r\n                }\r\n                ndx++;\r\n            }\r\n            return new String(element);\r\n        }\r\n        ptr.offset++;\r\n        ndx++;\r\n        if (ndx == len) {\r\n            return lastName != null ? new String(lastName) : null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jodd.net.HtmlDecoder.detectName",
	"Comment": "detects the longest character reference name on given position in char array.",
	"Method": "String detectName(char[] input,int ndx){\r\n    char[] name = ENTITY_NAMES[index];\r\n    if (ptr.offset >= name.length) {\r\n        return -1;\r\n    }\r\n    return name[ptr.offset] - ptr.c;\r\n}"
}, {
	"Path": "org.joda.time.field.PreciseDateTimeField.set",
	"Comment": "set the specified amount of units to the specified time instant.",
	"Method": "long set(long instant,int value){\r\n    FieldUtils.verifyValueBounds(this, value, getMinimumValue(), getMaximumValue());\r\n    return instant + (value - get(instant)) * iUnitMillis;\r\n}"
}, {
	"Path": "org.joda.time.field.OffsetDateTimeField.add",
	"Comment": "add the specified amount of offset units to the specified timeinstant. the amount added may be negative.",
	"Method": "long add(long instant,int amount,long add,long instant,long amount){\r\n    instant = super.add(instant, amount);\r\n    FieldUtils.verifyValueBounds(this, get(instant), iMin, iMax);\r\n    return instant;\r\n}"
}, {
	"Path": "org.joda.time.Period.toStandardDays",
	"Comment": "converts this period to a period in days assuming a7 day week, 24 hour day, 60 minute hour and 60 second minute.this method allows you to convert between different types of period.however to achieve this it makes the assumption that allweeks are 7 days, all days are 24 hours, all hours are 60 minutes andall minutes are 60 seconds. this is not true when daylight savings timeis considered, and may also not be true for some unusual chronologies.however, it is included as it is a useful operation for manyapplications and business rules.if the period contains years or months, an exception will be thrown.",
	"Method": "Days toStandardDays(){\r\n    checkYearsAndMonths(\"Days\");\r\n    long millis = getMillis();\r\n    millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;\r\n    millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE;\r\n    millis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR;\r\n    long days = millis / DateTimeConstants.MILLIS_PER_DAY;\r\n    days = FieldUtils.safeAdd(days, getDays());\r\n    days = FieldUtils.safeAdd(days, ((long) getWeeks()) * ((long) DateTimeConstants.DAYS_PER_WEEK));\r\n    return Days.days(FieldUtils.safeToInt(days));\r\n}"
}, {
	"Path": "jodd.asm7.signature.SignatureReader.parseType",
	"Comment": "parses a javatypesignature and makes the given visitor visit it.",
	"Method": "int parseType(String signature,int startOffset,SignatureVisitor signatureVisitor){\r\n    int offset = startOffset;\r\n    char currentChar = signature.charAt(offset++);\r\n    switch(currentChar) {\r\n        case 'Z':\r\n        case 'C':\r\n        case 'B':\r\n        case 'S':\r\n        case 'I':\r\n        case 'F':\r\n        case 'J':\r\n        case 'D':\r\n        case 'V':\r\n            signatureVisitor.visitBaseType(currentChar);\r\n            return offset;\r\n        case '[':\r\n            return parseType(signature, offset, signatureVisitor.visitArrayType());\r\n        case 'T':\r\n            int endOffset = signature.indexOf(';', offset);\r\n            signatureVisitor.visitTypeVariable(signature.substring(offset, endOffset));\r\n            return endOffset + 1;\r\n        case 'L':\r\n            int start = offset;\r\n            boolean visited = false;\r\n            boolean inner = false;\r\n            while (true) {\r\n                currentChar = signature.charAt(offset++);\r\n                if (currentChar == '.' || currentChar == ';') {\r\n                    if (!visited) {\r\n                        String name = signature.substring(start, offset - 1);\r\n                        if (inner) {\r\n                            signatureVisitor.visitInnerClassType(name);\r\n                        } else {\r\n                            signatureVisitor.visitClassType(name);\r\n                        }\r\n                    }\r\n                    if (currentChar == ';') {\r\n                        signatureVisitor.visitEnd();\r\n                        break;\r\n                    }\r\n                    start = offset;\r\n                    visited = false;\r\n                    inner = true;\r\n                } else if (currentChar == '<') {\r\n                    String name = signature.substring(start, offset - 1);\r\n                    if (inner) {\r\n                        signatureVisitor.visitInnerClassType(name);\r\n                    } else {\r\n                        signatureVisitor.visitClassType(name);\r\n                    }\r\n                    visited = true;\r\n                    while ((currentChar = signature.charAt(offset)) != '>') {\r\n                        switch(currentChar) {\r\n                            case '*':\r\n                                ++offset;\r\n                                signatureVisitor.visitTypeArgument();\r\n                                break;\r\n                            case '+':\r\n                            case '-':\r\n                                offset = parseType(signature, offset + 1, signatureVisitor.visitTypeArgument(currentChar));\r\n                                break;\r\n                            default:\r\n                                offset = parseType(signature, offset, signatureVisitor.visitTypeArgument('='));\r\n                                break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return offset;\r\n        default:\r\n            throw new IllegalArgumentException();\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.yearOfCentury",
	"Comment": "get the year of century property which provides access to advanced functionality.",
	"Method": "Property yearOfCentury(){\r\n    return new Property(this, getChronology().yearOfCentury());\r\n}"
}, {
	"Path": "org.jooq.impl.Tools.decrement",
	"Comment": "decrement a counter and return true if the counter is zero afterdecrementing.",
	"Method": "boolean decrement(Map<Object, Object> data,DataKey key){\r\n    boolean result = false;\r\n    Integer updateCounts = (Integer) data.get(key);\r\n    if (updateCounts == null || updateCounts == 0)\r\n        throw new IllegalStateException(\"Unmatching increment / decrement on key: \" + key);\r\n    else if (updateCounts == 1)\r\n        result = true;\r\n    data.put(key, updateCounts - 1);\r\n    return result;\r\n}"
}, {
	"Path": "org.joda.time.Months.dividedBy",
	"Comment": "returns a new instance with the months divided by the specified divisor.the calculation uses integer division, thus 3 divided by 2 is 1.this instance is immutable and unaffected by this method call.",
	"Method": "Months dividedBy(int divisor){\r\n    if (divisor == 1) {\r\n        return this;\r\n    }\r\n    return Months.months(getValue() / divisor);\r\n}"
}, {
	"Path": "jodd.http.HttpTunnel.start",
	"Comment": "starts http tunnel. method ends when the tunnel is stopped.",
	"Method": "void start(){\r\n    serverSocket = new ServerSocket(listenPort, socketBacklog);\r\n    serverSocket.setReuseAddress(true);\r\n    executorService = Executors.newFixedThreadPool(threadPoolSize);\r\n    running = true;\r\n    while (running) {\r\n        Socket socket = serverSocket.accept();\r\n        socket.setKeepAlive(false);\r\n        executorService.execute(onSocketConnection(socket));\r\n    }\r\n    executorService.shutdown();\r\n}"
}, {
	"Path": "jodd.madvoc.MadvocResponseWrapper.getContentType",
	"Comment": "returns content type and, optionally, charset. returns null\twhen mime type is not set.",
	"Method": "String getContentType(){\r\n    String contentType = mimeType;\r\n    if (mimeType != null && characterEncoding != null) {\r\n        contentType += \";charset=\" + characterEncoding;\r\n    }\r\n    return contentType;\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Generate.isCommentsOnSchemas",
	"Comment": "turn off generation of all sql comments as javadoc on all schemas.",
	"Method": "Boolean isCommentsOnSchemas(){\r\n    return commentsOnSchemas;\r\n}"
}, {
	"Path": "org.joda.time.tz.DateTimeZoneBuilder.readFrom",
	"Comment": "decodes a built datetimezone from the given stream, as encoded bywriteto.",
	"Method": "DateTimeZone readFrom(InputStream in,String id,DateTimeZone readFrom,DataInput in,String id,OfYear readFrom,DataInput in,Recurrence readFrom,DataInput in,DSTZone readFrom,DataInput in,String id,PrecalculatedZone readFrom,DataInput in,String id){\r\n    switch(in.readUnsignedByte()) {\r\n        case 'F':\r\n            DateTimeZone fixed = new FixedDateTimeZone(id, in.readUTF(), (int) readMillis(in), (int) readMillis(in));\r\n            if (fixed.equals(DateTimeZone.UTC)) {\r\n                fixed = DateTimeZone.UTC;\r\n            }\r\n            return fixed;\r\n        case 'C':\r\n            return CachedDateTimeZone.forZone(PrecalculatedZone.readFrom(in, id));\r\n        case 'P':\r\n            return PrecalculatedZone.readFrom(in, id);\r\n        default:\r\n            throw new IOException(\"Invalid encoding\");\r\n    }\r\n}"
}, {
	"Path": "org.jooq.conf.SettingsTools.renderLocale",
	"Comment": "the render locale that is applicable, or the default locale if no suchlocale is configured.",
	"Method": "Locale renderLocale(Settings settings){\r\n    return defaultIfNull(settings.getRenderLocale(), Locale.getDefault());\r\n}"
}, {
	"Path": "jodd.http.net.SocketHttpConnectionProvider.getDefaultSSLSocketFactory",
	"Comment": "returns default ssl socket factory allowing setting trust managers.",
	"Method": "SSLSocketFactory getDefaultSSLSocketFactory(boolean trustAllCertificates){\r\n    if (trustAllCertificates) {\r\n        try {\r\n            SSLContext sc = SSLContext.getInstance(sslProtocol);\r\n            sc.init(null, TrustManagers.TRUST_ALL_CERTS, new java.security.SecureRandom());\r\n            return sc.getSocketFactory();\r\n        } catch (NoSuchAlgorithmException | KeyManagementException e) {\r\n            throw new IOException(e);\r\n        }\r\n    } else {\r\n        return (SSLSocketFactory) SSLSocketFactory.getDefault();\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractInstant.isEqualNow",
	"Comment": "is this instant equal to the current instantcomparing solely by millisecond.",
	"Method": "boolean isEqualNow(){\r\n    return isEqual(DateTimeUtils.currentTimeMillis());\r\n}"
}, {
	"Path": "jodd.json.JsonContext.popValue",
	"Comment": "removes object from current bag, indicating it is not anymore in the path.",
	"Method": "void popValue(){\r\n    bagSize--;\r\n    if (bagSize == 0) {\r\n        lastValueContext = null;\r\n    } else {\r\n        lastValueContext = bag.get(bagSize - 1);\r\n    }\r\n}"
}, {
	"Path": "jodd.db.oom.dao.GenericDao.store",
	"Comment": "saves or updates entity. if id is not null, entity will be updated.\totherwise, entity will be inserted into the database.",
	"Method": "E store(E entity){\r\n    Class type = entity.getClass();\r\n    DbEntityDescriptor ded = dbOom.entityManager().lookupType(type);\r\n    if (ded == null) {\r\n        throw new DbOomException(\"Not an entity: \" + type);\r\n    }\r\n    if (!isPersistent(ded, entity)) {\r\n        final DbQuery q;\r\n        if (dbOom.config().isKeysGeneratedByDatabase()) {\r\n            q = query(dbOom.entities().insert(entity));\r\n            q.setGeneratedKey();\r\n            q.executeUpdate();\r\n            long nextId = q.getGeneratedKey();\r\n            setEntityId(ded, entity, nextId);\r\n        } else {\r\n            long nextId = generateNextId(ded);\r\n            setEntityId(ded, entity, nextId);\r\n            q = query(dbOom.entities().insert(entity));\r\n            q.executeUpdate();\r\n        }\r\n        q.close();\r\n    } else {\r\n        query(dbOom.entities().updateAll(entity)).autoClose().executeUpdate();\r\n    }\r\n    return entity;\r\n}"
}, {
	"Path": "jodd.joy.vtor.VtorUtil.resolveValidationMessage",
	"Comment": "prepares validation messages.\tkey is either validation constraint class name or violation name.",
	"Method": "String resolveValidationMessage(HttpServletRequest request,Violation violation){\r\n    ValidationConstraint vc = violation.getConstraint();\r\n    String key = vc != null ? vc.getClass().getName() : violation.getName();\r\n    String msg = LocalizationUtil.findMessage(request, key);\r\n    if (msg != null) {\r\n        return beanTemplateParser.parseWithBean(msg, violation);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.joda.time.base.BaseSingleFieldPeriod.size",
	"Comment": "gets the number of fields that this period supports, which is one.",
	"Method": "int size(){\r\n    return 1;\r\n}"
}, {
	"Path": "jodd.io.findfile.FindFile.init",
	"Comment": "initializes file walking.\tseparates input files and folders.",
	"Method": "void init(){\r\n    rules.detectMode();\r\n    todoFiles = new LinkedList();\r\n    todoFolders = new LinkedList();\r\n    if (pathList == null) {\r\n        pathList = new LinkedList();\r\n        return;\r\n    }\r\n    if (pathListOriginal == null) {\r\n        pathListOriginal = (LinkedList<File>) pathList.clone();\r\n    }\r\n    String[] files = new String[pathList.size()];\r\n    int index = 0;\r\n    Iterator<File> iterator = pathList.iterator();\r\n    while (iterator.hasNext()) {\r\n        File file = iterator.next();\r\n        if (file.isFile()) {\r\n            files[index++] = file.getAbsolutePath();\r\n            iterator.remove();\r\n        }\r\n    }\r\n    if (index != 0) {\r\n        FilesIterator filesIterator = new FilesIterator(files);\r\n        todoFiles.add(filesIterator);\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.DateMidnight.withYearOfEra",
	"Comment": "returns a copy of this date with the year of era field updated.datemidnight is immutable, so there are no set methods.instead, this method returns a new instance with the value ofyear of era changed.",
	"Method": "DateMidnight withYearOfEra(int yearOfEra){\r\n    return withMillis(getChronology().yearOfEra().set(getMillis(), yearOfEra));\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.audio.AACStream.getSessionDescription",
	"Comment": "returns a description of the stream using sdp. it can then be included in an sdp file.\twill fail if called when streaming.",
	"Method": "String getSessionDescription(){\r\n    if (mSessionDescription == null)\r\n        throw new IllegalStateException(\"You need to call configure() first !\");\r\n    return mSessionDescription;\r\n}"
}, {
	"Path": "jodd.db.oom.sqlgen.TemplateData.lookupName",
	"Comment": "lookups for entity name and throws exception if entity name not found.",
	"Method": "DbEntityDescriptor lookupName(String entityName){\r\n    DbEntityDescriptor ded = entityManager.lookupName(entityName);\r\n    if (ded == null) {\r\n        throw new DbSqlBuilderException(\"Entity name not registered: \" + entityName);\r\n    }\r\n    return ded;\r\n}"
}, {
	"Path": "jodd.asm7.Frame.getLocal",
	"Comment": "returns the abstract type stored at the given local variable index in the output frame.",
	"Method": "int getLocal(int localIndex){\r\n    if (outputLocals == null || localIndex >= outputLocals.length) {\r\n        return LOCAL_KIND | localIndex;\r\n    } else {\r\n        int abstractType = outputLocals[localIndex];\r\n        if (abstractType == 0) {\r\n            abstractType = outputLocals[localIndex] = LOCAL_KIND | localIndex;\r\n        }\r\n        return abstractType;\r\n    }\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Database.isIncludePackages",
	"Comment": "this flag indicates whether packages should be included in output produced by this database",
	"Method": "Boolean isIncludePackages(){\r\n    return includePackages;\r\n}"
}, {
	"Path": "org.joda.time.format.FormatUtils.calculateDigitCount",
	"Comment": "calculates the number of decimal digits for the given value,including the sign.",
	"Method": "int calculateDigitCount(long value){\r\n    if (value < 0) {\r\n        if (value != Long.MIN_VALUE) {\r\n            return calculateDigitCount(-value) + 1;\r\n        } else {\r\n            return 20;\r\n        }\r\n    }\r\n    return (value < 10 ? 1 : (value < 100 ? 2 : (value < 1000 ? 3 : (value < 10000 ? 4 : ((int) (Math.log(value) / LOG_10) + 1)))));\r\n}"
}, {
	"Path": "jodd.proxetta.advice.DelegateAdviceUtil.applyAdvice",
	"Comment": "applies advice on given target class and returns proxy instance.",
	"Method": "T applyAdvice(Class<T> targetClass){\r\n    Class adviceClass = cache.get(targetClass);\r\n    if (adviceClass == null) {\r\n        adviceClass = PROXY_PROXETTA.proxy().setTarget(targetClass).define();\r\n        cache.put(targetClass, adviceClass);\r\n    }\r\n    try {\r\n        Object advice = ClassUtil.newInstance(adviceClass);\r\n        Field field = adviceClass.getField(\"$___target$0\");\r\n        field.set(advice, targetClass);\r\n        return (T) advice;\r\n    } catch (Exception ex) {\r\n        throw new ProxettaException(ex);\r\n    }\r\n}"
}, {
	"Path": "org.jooq.codegen.JavaGenerator.generatePojoSetter",
	"Comment": "subclasses may override this method to provide their own pojo setters.",
	"Method": "void generatePojoSetter(TypedElementDefinition<?> column,int index,JavaWriter out){\r\n    generatePojoSetter0(column, index, out);\r\n}"
}, {
	"Path": "jodd.cache.AbstractCacheMap.timeout",
	"Comment": "returns default cache timeout or 0 if it is not set.\ttimeout can be set individually for each object.",
	"Method": "long timeout(){\r\n    return timeout;\r\n}"
}, {
	"Path": "org.joda.time.format.DateTimeFormatter.print",
	"Comment": "prints a readablepartial to a new string.neither the override chronology nor the override zone are usedby this method.",
	"Method": "String print(ReadableInstant instant,String print,long instant,String print,ReadablePartial partial){\r\n    StringBuilder buf = new StringBuilder(requirePrinter().estimatePrintedLength());\r\n    try {\r\n        printTo((Appendable) buf, partial);\r\n    } catch (IOException ex) {\r\n    }\r\n    return buf.toString();\r\n}"
}, {
	"Path": "org.joda.time.format.DateTimeFormatterBuilder.clear",
	"Comment": "clears out all the appended elements, allowing this builder to bereused.",
	"Method": "void clear(){\r\n    iFormatter = null;\r\n    iElementPairs.clear();\r\n}"
}, {
	"Path": "jodd.json.TypeJsonSerializerMap.lookupSerializer",
	"Comment": "get type serializer from map. first the current map is used.\tif element is missing, default map will be used, if exist.",
	"Method": "TypeJsonSerializer lookupSerializer(Class type){\r\n    TypeJsonSerializer tjs = map.get(type);\r\n    if (tjs == null) {\r\n        if (defaultSerializerMap != null) {\r\n            tjs = defaultSerializerMap.map.get(type);\r\n        }\r\n    }\r\n    return tjs;\r\n}"
}, {
	"Path": "org.json.JSONArray.similar",
	"Comment": "determine if two jsonarrays are similar.they must contain similar sequences.",
	"Method": "boolean similar(Object other){\r\n    if (!(other instanceof JSONArray)) {\r\n        return false;\r\n    }\r\n    int len = this.length();\r\n    if (len != ((JSONArray) other).length()) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < len; i += 1) {\r\n        Object valueThis = this.myArrayList.get(i);\r\n        Object valueOther = ((JSONArray) other).myArrayList.get(i);\r\n        if (valueThis == valueOther) {\r\n            continue;\r\n        }\r\n        if (valueThis == null) {\r\n            return false;\r\n        }\r\n        if (valueThis instanceof JSONObject) {\r\n            if (!((JSONObject) valueThis).similar(valueOther)) {\r\n                return false;\r\n            }\r\n        } else if (valueThis instanceof JSONArray) {\r\n            if (!((JSONArray) valueThis).similar(valueOther)) {\r\n                return false;\r\n            }\r\n        } else if (!valueThis.equals(valueOther)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "jodd.madvoc.component.ResultsManager.register",
	"Comment": "registers new action result instance. if action result of the same class is already\tregistered, registration will be skipped. if result for the same result type or\tsame target class exist, it will be replaced! however, default jodd results will\tnever replace other results. after the registration, results are initialized.",
	"Method": "ActionResult register(Class<? extends ActionResult> resultClass,ActionResult register,ActionResult result){\r\n    Class<? extends ActionResult> actionResultClass = result.getClass();\r\n    ActionResult existingResult = allResults.get(actionResultClass);\r\n    if (existingResult != null) {\r\n        if (log.isDebugEnabled()) {\r\n            log.debug(\"ActionResult already registered: \" + actionResultClass);\r\n        }\r\n        return existingResult;\r\n    }\r\n    allResults.put(actionResultClass, result);\r\n    initializeResult(result);\r\n    return result;\r\n}"
}, {
	"Path": "org.jsonschema2pojo.SchemaStore.create",
	"Comment": "create or look up a new schema using the given schema as a parent and thepath as a relative reference. if a schema with the given parent andrelative path is already known, then a reference to the original schemawill be returned.",
	"Method": "Schema create(URI id,String refFragmentPathDelimiters,Schema create,Schema parent,String path,String refFragmentPathDelimiters){\r\n    if (!path.equals(\"#\")) {\r\n        path = stripEnd(path, \"#?&/\");\r\n    }\r\n    if (path.contains(\"#\")) {\r\n        String pathExcludingFragment = substringBefore(path, \"#\");\r\n        String fragment = substringAfter(path, \"#\");\r\n        URI fragmentURI;\r\n        try {\r\n            fragmentURI = new URI(null, null, fragment);\r\n        } catch (URISyntaxException e) {\r\n            throw new IllegalArgumentException(\"Invalid fragment: \" + fragment + \" in path: \" + path);\r\n        }\r\n        path = pathExcludingFragment + \"#\" + fragmentURI.getRawFragment();\r\n    }\r\n    URI id = (parent == null || parent.getId() == null) ? URI.create(path) : parent.getId().resolve(path);\r\n    String stringId = id.toString();\r\n    if (stringId.endsWith(\"#\")) {\r\n        try {\r\n            id = new URI(stripEnd(stringId, \"#\"));\r\n        } catch (URISyntaxException e) {\r\n            throw new IllegalArgumentException(\"Bad path: \" + stringId);\r\n        }\r\n    }\r\n    if (selfReferenceWithoutParentFile(parent, path) || substringBefore(stringId, \"#\").isEmpty()) {\r\n        JsonNode parentContent = parent.getParent().getContent();\r\n        Schema schema = new Schema(id, fragmentResolver.resolve(parentContent, path, refFragmentPathDelimiters), parent.getParent());\r\n        schemas.put(id, schema);\r\n        return schema;\r\n    }\r\n    return create(id, refFragmentPathDelimiters);\r\n}"
}, {
	"Path": "jodd.typeconverter.Converter.toFloatValue",
	"Comment": "converts value to float. returns default value\twhen conversion result is null.",
	"Method": "float toFloatValue(Object value,float defaultValue,float toFloatValue,Object value){\r\n    return toFloatValue(value, 0);\r\n}"
}, {
	"Path": "org.jooq.codegen.JavaGenerator.generateInterfaceGetter",
	"Comment": "subclasses may override this method to provide their own interface getters.",
	"Method": "void generateInterfaceGetter(TypedElementDefinition<?> column,int index,JavaWriter out){\r\n    generateInterfaceGetter0(column, index, out);\r\n}"
}, {
	"Path": "jodd.decora.parser.DecoraTag.isRegionUndefined",
	"Comment": "returns true if region is undefined.\treturns false if region is either started\tor defined.",
	"Method": "boolean isRegionUndefined(){\r\n    return regionStart == -1;\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.rtcp.SenderReport.update",
	"Comment": "updates the number of packets sent, and the total amount of data sent.",
	"Method": "void update(int length,long rtpts){\r\n    mPacketCount += 1;\r\n    mOctetCount += length;\r\n    setLong(mPacketCount, 20, 24);\r\n    setLong(mOctetCount, 24, 28);\r\n    now = SystemClock.elapsedRealtime();\r\n    delta += oldnow != 0 ? now - oldnow : 0;\r\n    oldnow = now;\r\n    if (interval > 0 && delta >= interval) {\r\n        send(System.nanoTime(), rtpts);\r\n        delta = 0;\r\n    }\r\n}"
}, {
	"Path": "jodd.util.CharArraySequence.of",
	"Comment": "static constructor that creates a char sequence using provided char array.",
	"Method": "CharArraySequence of(char value,CharArraySequence of,char[] value,int offset,int len){\r\n    return new CharArraySequence(value, offset, len);\r\n}"
}, {
	"Path": "jodd.db.oom.DbMetaUtil.resolveIsAnnotated",
	"Comment": "returns true if class is annotated with dbtable annotation.",
	"Method": "boolean resolveIsAnnotated(Class<?> type){\r\n    DbTable dbTable = type.getAnnotation(DbTable.class);\r\n    return dbTable != null;\r\n}"
}, {
	"Path": "org.joda.time.DateMidnight.plus",
	"Comment": "returns a copy of this date with the specified duration added.if the amount is zero or null, then this is returned.",
	"Method": "DateMidnight plus(long duration,DateMidnight plus,ReadableDuration duration,DateMidnight plus,ReadablePeriod period){\r\n    return withPeriodAdded(period, 1);\r\n}"
}, {
	"Path": "org.joda.time.DateMidnight.withYear",
	"Comment": "returns a copy of this date with the year field updated.datemidnight is immutable, so there are no set methods.instead, this method returns a new instance with the value ofyear changed.",
	"Method": "DateMidnight withYear(int year){\r\n    return withMillis(getChronology().year().set(getMillis(), year));\r\n}"
}, {
	"Path": "org.joda.time.DateMidnight.centuryOfEra",
	"Comment": "get the century of era property which provides access to advanced functionality.",
	"Method": "Property centuryOfEra(){\r\n    return new Property(this, getChronology().centuryOfEra());\r\n}"
}, {
	"Path": "org.joda.time.base.BaseSingleFieldPeriod.standardPeriodIn",
	"Comment": "creates a new instance representing the number of complete standard length unitsin the specified period.this factory method converts all fields from the period to hours using standardiseddurations for each field. only those fields which have a precise duration inthe iso utc chronology can be converted.one week consists of 7 days.one day consists of 24 hours.one hour consists of 60 minutes.one minute consists of 60 seconds.one second consists of 1000 milliseconds.months and years are imprecise and periods containing these values cannot be converted.",
	"Method": "int standardPeriodIn(ReadablePeriod period,long millisPerUnit){\r\n    if (period == null) {\r\n        return 0;\r\n    }\r\n    Chronology iso = ISOChronology.getInstanceUTC();\r\n    long duration = 0L;\r\n    for (int i = 0; i < period.size(); i++) {\r\n        int value = period.getValue(i);\r\n        if (value != 0) {\r\n            DurationField field = period.getFieldType(i).getField(iso);\r\n            if (field.isPrecise() == false) {\r\n                throw new IllegalArgumentException(\"Cannot convert period to duration as \" + field.getName() + \" is not precise in the period \" + period);\r\n            }\r\n            duration = FieldUtils.safeAdd(duration, FieldUtils.safeMultiply(field.getUnitMillis(), value));\r\n        }\r\n    }\r\n    return FieldUtils.safeToInt(duration / millisPerUnit);\r\n}"
}, {
	"Path": "org.joda.time.Duration.toDuration",
	"Comment": "get this duration as an immutable duration objectby returning this.",
	"Method": "Duration toDuration(){\r\n    return this;\r\n}"
}, {
	"Path": "org.joda.time.format.PeriodFormatterBuilder.printZeroIfSupported",
	"Comment": "print zero values for the next and following appended fields only if theperiod supports it.",
	"Method": "PeriodFormatterBuilder printZeroIfSupported(){\r\n    iPrintZeroSetting = PRINT_ZERO_IF_SUPPORTED;\r\n    return this;\r\n}"
}, {
	"Path": "jodd.mail.SendMailSession.createAttachmentBodyPart",
	"Comment": "creates attachment body part. handles regular and inline attachments.",
	"Method": "MimeBodyPart createAttachmentBodyPart(EmailAttachment<? extends DataSource> attachment){\r\n    final MimeBodyPart part = new MimeBodyPart();\r\n    final String attachmentName = attachment.getEncodedName();\r\n    if (attachmentName != null) {\r\n        part.setFileName(attachmentName);\r\n    }\r\n    part.setDataHandler(new DataHandler(attachment.getDataSource()));\r\n    if (attachment.getContentId() != null) {\r\n        part.setContentID(StringPool.LEFT_CHEV + attachment.getContentId() + StringPool.RIGHT_CHEV);\r\n    }\r\n    if (attachment.isInline()) {\r\n        part.setDisposition(INLINE);\r\n    }\r\n    return part;\r\n}"
}, {
	"Path": "jodd.util.StringBand.append",
	"Comment": "appends a character. this is not efficient\tas in stringbuilder, since new string is created.",
	"Method": "StringBand append(boolean b,StringBand append,double d,StringBand append,float f,StringBand append,int i,StringBand append,long l,StringBand append,short s,StringBand append,char c,StringBand append,byte b,StringBand append,Object obj,StringBand append,String s){\r\n    if (s == null) {\r\n        s = StringPool.NULL;\r\n    }\r\n    if (index >= array.length) {\r\n        expandCapacity();\r\n    }\r\n    array[index++] = s;\r\n    length += s.length();\r\n    return this;\r\n}"
}, {
	"Path": "org.joda.time.Duration.multipliedBy",
	"Comment": "returns a new duration with this length multiplied by the specified multiplicand.this instance is immutable and is not altered.if the multiplicand is one, this instance is returned.",
	"Method": "Duration multipliedBy(long multiplicand){\r\n    if (multiplicand == 1) {\r\n        return this;\r\n    }\r\n    return new Duration(FieldUtils.safeMultiply(getMillis(), multiplicand));\r\n}"
}, {
	"Path": "jodd.asm7.SymbolTable.addBootstrapMethod",
	"Comment": "adds a bootstrap method to the bootstrapmethods attribute of this symbol table. does nothing ifthe bootstrapmethods already contains a similar bootstrap method.",
	"Method": "Symbol addBootstrapMethod(Handle bootstrapMethodHandle,Object bootstrapMethodArguments,Symbol addBootstrapMethod,int offset,int length,int hashCode){\r\n    final byte[] bootstrapMethodsData = bootstrapMethods.data;\r\n    Entry entry = get(hashCode);\r\n    while (entry != null) {\r\n        if (entry.tag == Symbol.BOOTSTRAP_METHOD_TAG && entry.hashCode == hashCode) {\r\n            int otherOffset = (int) entry.data;\r\n            boolean isSameBootstrapMethod = true;\r\n            for (int i = 0; i < length; ++i) {\r\n                if (bootstrapMethodsData[offset + i] != bootstrapMethodsData[otherOffset + i]) {\r\n                    isSameBootstrapMethod = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (isSameBootstrapMethod) {\r\n                bootstrapMethods.length = offset;\r\n                return entry;\r\n            }\r\n        }\r\n        entry = entry.next;\r\n    }\r\n    return put(new Entry(bootstrapMethodCount++, Symbol.BOOTSTRAP_METHOD_TAG, offset, hashCode));\r\n}"
}, {
	"Path": "org.joda.time.format.PeriodFormatterBuilder.minimumPrintedDigits",
	"Comment": "set the minimum digits printed for the next and following appendedfields. by default, the minimum digits printed is one. if the field valueis zero, it is not printed unless a printzero rule is applied.",
	"Method": "PeriodFormatterBuilder minimumPrintedDigits(int minDigits){\r\n    iMinPrintedDigits = minDigits;\r\n    return this;\r\n}"
}, {
	"Path": "com.jayway.jsonpath.internal.function.latebinding.JsonLateBindingValue.get",
	"Comment": "evaluate the json document at the point of need using the json parameter and associated document model which mayitself originate from yet another function thus recursively invoking late binding methods.",
	"Method": "Object get(){\r\n    return jsonProvider.parse(jsonParameter.getJson());\r\n}"
}, {
	"Path": "org.joda.time.LocalDate.yearOfCentury",
	"Comment": "get the year of century property which provides access to advanced functionality.",
	"Method": "Property yearOfCentury(){\r\n    return new Property(this, getChronology().yearOfCentury());\r\n}"
}, {
	"Path": "org.joda.time.LocalDate.weekyear",
	"Comment": "get the weekyear property which provides access to advanced functionality.",
	"Method": "Property weekyear(){\r\n    return new Property(this, getChronology().weekyear());\r\n}"
}, {
	"Path": "jodd.petite.BeanData.wireMethods",
	"Comment": "invokes single method injection point on given bean with given bean definition.",
	"Method": "void wireMethods(){\r\n    for (final MethodInjectionPoint methodRef : definition().methods) {\r\n        invokeMethodInjectionPoint(methodRef);\r\n    }\r\n}"
}, {
	"Path": "org.jooq.impl.DSL.localDateTimeDiff",
	"Comment": "get the timestamp difference as a interval day to secondtype.this translates into any dialect",
	"Method": "Field<DayToSecond> localDateTimeDiff(LocalDateTime timestamp1,LocalDateTime timestamp2,Field<DayToSecond> localDateTimeDiff,Field<LocalDateTime> timestamp1,LocalDateTime timestamp2,Field<DayToSecond> localDateTimeDiff,LocalDateTime timestamp1,Field<LocalDateTime> timestamp2,Field<DayToSecond> localDateTimeDiff,Field<LocalDateTime> timestamp1,Field<LocalDateTime> timestamp2){\r\n    return new TimestampDiff(nullSafe(timestamp1), nullSafe(timestamp2));\r\n}"
}, {
	"Path": "jodd.net.HtmlDecoder.lookup",
	"Comment": "returns replacement chars for given character reference.",
	"Method": "char[] lookup(String name){\r\n    return ENTITY_MAP.get(name);\r\n}"
}, {
	"Path": "org.json.JSONObject.accumulate",
	"Comment": "accumulate values under a key. it is similar to the put method exceptthat if there is already an object stored under the key then a jsonarrayis stored under the key to hold all of the accumulated values. if thereis already a jsonarray, then the new value is appended to it. incontrast, the put method replaces the previous value.if only one value is accumulated that is not a jsonarray, then the resultwill be the same as using put. but if multiple values are accumulated,then the result will be like append.",
	"Method": "JSONObject accumulate(String key,Object value){\r\n    testValidity(value);\r\n    Object object = this.opt(key);\r\n    if (object == null) {\r\n        this.put(key, value instanceof JSONArray ? new JSONArray().put(value) : value);\r\n    } else if (object instanceof JSONArray) {\r\n        ((JSONArray) object).put(value);\r\n    } else {\r\n        this.put(key, new JSONArray().put(object).put(value));\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "jodd.petite.PetiteConfig.setDetectDuplicatedBeanNames",
	"Comment": "specifies if an exception should be thrown if two beans with same exception are registered with this container.",
	"Method": "PetiteConfig setDetectDuplicatedBeanNames(boolean detectDuplicatedBeanNames){\r\n    this.detectDuplicatedBeanNames = detectDuplicatedBeanNames;\r\n    return this;\r\n}"
}, {
	"Path": "jodd.http.HttpUtil.extractHeaderParameter",
	"Comment": "extracts header parameter. returns null\tif parameter not found.",
	"Method": "String extractHeaderParameter(String header,String parameter,char separator){\r\n    int index = 0;\r\n    while (true) {\r\n        index = header.indexOf(separator, index);\r\n        if (index == -1) {\r\n            return null;\r\n        }\r\n        index++;\r\n        while (index < header.length() && header.charAt(index) == ' ') {\r\n            index++;\r\n        }\r\n        int eqNdx = header.indexOf('=', index);\r\n        if (eqNdx == -1) {\r\n            return null;\r\n        }\r\n        String paramName = header.substring(index, eqNdx);\r\n        eqNdx++;\r\n        if (!paramName.equalsIgnoreCase(parameter)) {\r\n            index = eqNdx;\r\n            continue;\r\n        }\r\n        int endIndex = header.indexOf(';', eqNdx);\r\n        if (endIndex == -1) {\r\n            return header.substring(eqNdx);\r\n        } else {\r\n            return header.substring(eqNdx, endIndex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jodd.lagarto.dom.Node.getChildNodes",
	"Comment": "returns an array of all children nodes. returns an empty array\tif there are no children.",
	"Method": "Node[] getChildNodes(){\r\n    if (childNodes == null) {\r\n        return new Node[0];\r\n    }\r\n    return childNodes.toArray(new Node[0]);\r\n}"
}, {
	"Path": "jodd.util.BinarySearch.findFirst",
	"Comment": "finds very first index of given element in inclusive index range. returns negative\tvalue if element is not found.",
	"Method": "int findFirst(E o,int findFirst,E o,int low,int high){\r\n    int ndx = -1;\r\n    while (low <= high) {\r\n        int mid = (low + high) >>> 1;\r\n        int delta = compare(mid, o);\r\n        if (delta < 0) {\r\n            low = mid + 1;\r\n        } else {\r\n            if (delta == 0) {\r\n                ndx = mid;\r\n            }\r\n            high = mid - 1;\r\n        }\r\n    }\r\n    if (ndx == -1) {\r\n        return -(low + 1);\r\n    }\r\n    return ndx;\r\n}"
}, {
	"Path": "org.joda.time.Period.minusMillis",
	"Comment": "returns a new period minus the specified number of millis taken away.this period instance is immutable and unaffected by this method call.",
	"Method": "Period minusMillis(int millis){\r\n    return plusMillis(-millis);\r\n}"
}, {
	"Path": "jodd.introspector.Ctors.getCtorDescriptor",
	"Comment": "finds constructor description that matches given argument types.",
	"Method": "CtorDescriptor getCtorDescriptor(Class args){\r\n    ctors: for (CtorDescriptor ctorDescriptor : allCtors) {\r\n        Class[] arg = ctorDescriptor.getParameters();\r\n        if (arg.length != args.length) {\r\n            continue;\r\n        }\r\n        for (int j = 0; j < arg.length; j++) {\r\n            if (arg[j] != args[j]) {\r\n                continue ctors;\r\n            }\r\n        }\r\n        return ctorDescriptor;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.joda.time.chrono.LimitChronology.withZone",
	"Comment": "if this limitchronology has the same time zone as the one given, thenthis is returned. otherwise, a new instance is returned, with the limitsadjusted to the new time zone.",
	"Method": "Chronology withZone(DateTimeZone zone){\r\n    if (zone == null) {\r\n        zone = DateTimeZone.getDefault();\r\n    }\r\n    if (zone == getZone()) {\r\n        return this;\r\n    }\r\n    if (zone == DateTimeZone.UTC && iWithUTC != null) {\r\n        return iWithUTC;\r\n    }\r\n    DateTime lowerLimit = iLowerLimit;\r\n    if (lowerLimit != null) {\r\n        MutableDateTime mdt = lowerLimit.toMutableDateTime();\r\n        mdt.setZoneRetainFields(zone);\r\n        lowerLimit = mdt.toDateTime();\r\n    }\r\n    DateTime upperLimit = iUpperLimit;\r\n    if (upperLimit != null) {\r\n        MutableDateTime mdt = upperLimit.toMutableDateTime();\r\n        mdt.setZoneRetainFields(zone);\r\n        upperLimit = mdt.toDateTime();\r\n    }\r\n    LimitChronology chrono = getInstance(getBase().withZone(zone), lowerLimit, upperLimit);\r\n    if (zone == DateTimeZone.UTC) {\r\n        iWithUTC = chrono;\r\n    }\r\n    return chrono;\r\n}"
}, {
	"Path": "org.joda.time.LocalTime.size",
	"Comment": "gets the number of fields in this partial, which is four.the supported fields are hourofday, minuteofhour, secondofminuteand millisofsecond.",
	"Method": "int size(){\r\n    return 4;\r\n}"
}, {
	"Path": "jodd.util.CharArraySequence.from",
	"Comment": "static constructor that creates a char sequence by making a copy of provided char array.",
	"Method": "CharArraySequence from(char[] value,int offset,int len){\r\n    final char[] buffer = new char[value.length];\r\n    System.arraycopy(value, offset, buffer, 0, len);\r\n    return new CharArraySequence(buffer);\r\n}"
}, {
	"Path": "jodd.asm7.ClassVisitor.visitOuterClass",
	"Comment": "visits the enclosing class of the class. this method must be called only if the class has anenclosing class.",
	"Method": "void visitOuterClass(String owner,String name,String descriptor){\r\n    if (cv != null) {\r\n        cv.visitOuterClass(owner, name, descriptor);\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.chrono.ZonedChronology.equals",
	"Comment": "a zoned chronology is only equal to a zoned chronology with thesame base chronology and zone.",
	"Method": "boolean equals(Object obj,boolean equals,Object obj,boolean equals,Object obj){\r\n    if (this == obj) {\r\n        return true;\r\n    }\r\n    if (obj instanceof ZonedChronology == false) {\r\n        return false;\r\n    }\r\n    ZonedChronology chrono = (ZonedChronology) obj;\r\n    return getBase().equals(chrono.getBase()) && getZone().equals(chrono.getZone());\r\n}"
}, {
	"Path": "org.joda.time.field.AbstractPartialFieldProperty.getMaximumValue",
	"Comment": "gets the maximum value for this field given the current field values.",
	"Method": "int getMaximumValue(){\r\n    return getField().getMaximumValue(getReadablePartial());\r\n}"
}, {
	"Path": "org.joda.time.DateTime.plus",
	"Comment": "returns a copy of this datetime with the specified duration added.if the amount is zero or null, then this is returned.this datetime instance is immutable and unaffected by this method call.",
	"Method": "DateTime plus(long duration,DateTime plus,ReadableDuration duration,DateTime plus,ReadablePeriod period){\r\n    return withPeriodAdded(period, 1);\r\n}"
}, {
	"Path": "jodd.jtx.JtxTransaction.lookupResource",
	"Comment": "lookups for open resource. returns null if resource not found.\tonly open resources can be found.",
	"Method": "E lookupResource(Class<E> resourceType){\r\n    for (JtxResource jtxResource : resources) {\r\n        if (jtxResource.isSameTypeAsResource(resourceType)) {\r\n            return (E) jtxResource.getResource();\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.jsonschema2pojo.exception.ClassAlreadyExistsException.getExistingClass",
	"Comment": "gets the corresponding existing class that caused this exception.",
	"Method": "JType getExistingClass(){\r\n    return existingClass;\r\n}"
}, {
	"Path": "org.joda.time.DateTimeUtils.getDurationMillis",
	"Comment": "gets the millisecond duration from the specified duration object handling null.if the duration object is null, zero will be returned.otherwise, the millis from the object are returned.",
	"Method": "long getDurationMillis(ReadableDuration duration){\r\n    if (duration == null) {\r\n        return 0L;\r\n    }\r\n    return duration.getMillis();\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.MatchersSchemaType.getExpression",
	"Comment": "this schema matcher applies to all unqualified or qualified schema names matched by this expression. if left empty, this matcher applies to all schemas.",
	"Method": "String getExpression(){\r\n    return expression;\r\n}"
}, {
	"Path": "jodd.madvoc.component.ActionMethodParser.readActionInterceptors",
	"Comment": "reads class or method annotation for action interceptors.",
	"Method": "Class<? extends ActionInterceptor>[] readActionInterceptors(AnnotatedElement actionClassOrMethod){\r\n    Class<? extends ActionInterceptor>[] result = null;\r\n    InterceptedBy interceptedBy = actionClassOrMethod.getAnnotation(InterceptedBy.class);\r\n    if (interceptedBy != null) {\r\n        result = interceptedBy.value();\r\n        if (result.length == 0) {\r\n            result = null;\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.joda.time.TimeOfDay.getFieldTypes",
	"Comment": "gets an array of the field type of each of the fields that this partial supports.the fields are returned largest to smallest, hour, minute, second, millis.",
	"Method": "DateTimeFieldType[] getFieldTypes(){\r\n    return (DateTimeFieldType[]) FIELD_TYPES.clone();\r\n}"
}, {
	"Path": "jodd.proxetta.ProxyTarget.targetMethodSignature",
	"Comment": "inserts target method signature, java alike, including the method name.\tuseful for identifying the method, since it is unique for class.",
	"Method": "String targetMethodSignature(){\r\n    throw new ProxettaException();\r\n}"
}, {
	"Path": "org.joda.time.DateTime.minuteOfHour",
	"Comment": "get the minute of hour field property which provides access to advanced functionality.",
	"Method": "Property minuteOfHour(){\r\n    return new Property(this, getChronology().minuteOfHour());\r\n}"
}, {
	"Path": "org.jooq.codegen.JavaWriter.qualifiedTypeComparator",
	"Comment": "subclasses may override this to specify their own order of qualified types.",
	"Method": "Comparator<String> qualifiedTypeComparator(){\r\n    return null;\r\n}"
}, {
	"Path": "org.joda.time.tz.DefaultNameProvider.getShortName",
	"Comment": "this code could be refactored to avoid duplication, but leaving it as is ensures backward compatibility",
	"Method": "String getShortName(Locale locale,String id,String nameKey,String getShortName,Locale locale,String id,String nameKey,boolean standardTime){\r\n    String[] nameSet = getNameSet(locale, id, nameKey, standardTime);\r\n    return nameSet == null ? null : nameSet[0];\r\n}"
}, {
	"Path": "jodd.bean.BeanUtilUtil.extractGenericComponentType",
	"Comment": "extracts generic component type of a property. returns object.class\twhen property does not have component.",
	"Method": "Class extractGenericComponentType(Getter getter){\r\n    Class componentType = null;\r\n    if (getter != null) {\r\n        componentType = getter.getGetterRawComponentType();\r\n    }\r\n    if (componentType == null) {\r\n        componentType = Object.class;\r\n    }\r\n    return componentType;\r\n}"
}, {
	"Path": "jodd.util.ArraysUtil.toString",
	"Comment": "converts an array to string. elements are separated by comma.\treturned string contains no brackets.",
	"Method": "String toString(Object[] array,String toString,String[] array,String toString,byte[] array,String toString,char[] array,String toString,short[] array,String toString,int[] array,String toString,long[] array,String toString,float[] array,String toString,double[] array,String toString,boolean[] array){\r\n    if (array == null) {\r\n        return NULL;\r\n    }\r\n    if (array.length == 0) {\r\n        return StringPool.EMPTY;\r\n    }\r\n    StringBand sb = new StringBand((array.length << 1) - 1);\r\n    for (int i = 0; i < array.length; i++) {\r\n        if (i != 0) {\r\n            sb.append(StringPool.COMMA);\r\n        }\r\n        sb.append(array[i]);\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.joda.time.Period.withYears",
	"Comment": "returns a new period with the specified number of years.this period instance is immutable and unaffected by this method call.",
	"Method": "Period withYears(int years){\r\n    int[] values = getValues();\r\n    getPeriodType().setIndexedField(this, PeriodType.YEAR_INDEX, values, years);\r\n    return new Period(values, getPeriodType());\r\n}"
}, {
	"Path": "jodd.proxetta.MethodInfo.hasAnnotation",
	"Comment": "returns true if method is annotated with one of provided annotation.",
	"Method": "boolean hasAnnotation(Class<? extends Annotation> an){\r\n    AnnotationInfo[] anns = getAnnotations();\r\n    if (anns == null) {\r\n        return false;\r\n    }\r\n    for (Class<? extends Annotation> annotationClass : an) {\r\n        String anName = annotationClass.getName();\r\n        for (AnnotationInfo ann : anns) {\r\n            if (ann.getAnnotationClassname().equals(anName)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "jodd.db.oom.sqlgen.DbSqlBuilder.append",
	"Comment": "parses provided text into the list of chunks and appends them to the list.",
	"Method": "DbSqlBuilder append(String text){\r\n    templateParser.parse(this, text);\r\n    return this;\r\n}"
}, {
	"Path": "org.apache.jmeter.protocol.http.sampler.PostWriterTest.createExpectedOutput",
	"Comment": "create the expected output post body for form data and file multipartswith specified values",
	"Method": "byte[] createExpectedOutput(String boundaryString,String contentEncoding,String titleValue,String descriptionValue,byte[] fileContent,byte[] createExpectedOutput,String boundaryString,String contentEncoding,String titleField,String titleValue,String descriptionField,String descriptionValue,String fileField,byte[] fileContent){\r\n    byte[] formdataMultipart = createExpectedFormdataOutput(boundaryString, contentEncoding, titleField, titleValue, descriptionField, descriptionValue, true, false);\r\n    byte[] fileMultipart = createExpectedFilepartOutput(boundaryString, fileField, temporaryFile, \"text/plain\", fileContent, false, true);\r\n    ByteArrayOutputStream output = new ByteArrayOutputStream();\r\n    output.write(formdataMultipart);\r\n    output.write(fileMultipart);\r\n    output.flush();\r\n    output.close();\r\n    return output.toByteArray();\r\n}"
}, {
	"Path": "jodd.db.DbThreadSession.closeSession",
	"Comment": "closes current session and remove the association from current thread.",
	"Method": "void closeSession(){\r\n    ThreadDbSessionHolder.remove();\r\n    super.closeSession();\r\n}"
}, {
	"Path": "org.jsonschema2pojo.rules.RuleFactory.setAnnotator",
	"Comment": "the annotator used to mark up java types with any annotations that arerequired to build json compatible types",
	"Method": "void setAnnotator(Annotator annotator){\r\n    this.annotator = annotator;\r\n}"
}, {
	"Path": "jodd.cache.FileCache.maxFileSize",
	"Comment": "returns maximum allowed file size that can be added to the cache.\tfiles larger than this value will be not added, even if there is\tenough room.",
	"Method": "int maxFileSize(){\r\n    return maxFileSize;\r\n}"
}, {
	"Path": "jodd.servlet.filter.GzipResponseStream.setBuffer",
	"Comment": "sets the compressionthreshold number and create buffer for this size.",
	"Method": "void setBuffer(int threshold){\r\n    compressionThreshold = threshold;\r\n    buffer = new byte[compressionThreshold];\r\n}"
}, {
	"Path": "org.joda.time.chrono.CopticChronology.getInstance",
	"Comment": "gets an instance of the copticchronology in the given time zone.",
	"Method": "CopticChronology getInstance(CopticChronology getInstance,DateTimeZone zone,CopticChronology getInstance,DateTimeZone zone,int minDaysInFirstWeek){\r\n    if (zone == null) {\r\n        zone = DateTimeZone.getDefault();\r\n    }\r\n    CopticChronology chrono;\r\n    CopticChronology[] chronos = cCache.get(zone);\r\n    if (chronos == null) {\r\n        chronos = new CopticChronology[7];\r\n        CopticChronology[] oldChronos = cCache.putIfAbsent(zone, chronos);\r\n        if (oldChronos != null) {\r\n            chronos = oldChronos;\r\n        }\r\n    }\r\n    try {\r\n        chrono = chronos[minDaysInFirstWeek - 1];\r\n    } catch (ArrayIndexOutOfBoundsException e) {\r\n        throw new IllegalArgumentException(\"Invalid min days in first week: \" + minDaysInFirstWeek);\r\n    }\r\n    if (chrono == null) {\r\n        synchronized (chronos) {\r\n            chrono = chronos[minDaysInFirstWeek - 1];\r\n            if (chrono == null) {\r\n                if (zone == DateTimeZone.UTC) {\r\n                    chrono = new CopticChronology(null, null, minDaysInFirstWeek);\r\n                    DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);\r\n                    chrono = new CopticChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, minDaysInFirstWeek);\r\n                } else {\r\n                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\r\n                    chrono = new CopticChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);\r\n                }\r\n                chronos[minDaysInFirstWeek - 1] = chrono;\r\n            }\r\n        }\r\n    }\r\n    return chrono;\r\n}"
}, {
	"Path": "jodd.madvoc.result.RawData.as",
	"Comment": "defines mime type by providing real mime type or just extension!",
	"Method": "RawData as(String mimeOrExtension){\r\n    if (mimeOrExtension.contains(StringPool.SLASH)) {\r\n        this.mimeType = mimeOrExtension;\r\n    } else {\r\n        this.mimeType = MimeTypes.getMimeType(mimeOrExtension);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractInterval.toMutableInterval",
	"Comment": "get this time interval as a mutableinterval.this will always return a new mutableinterval with the same interval.",
	"Method": "MutableInterval toMutableInterval(){\r\n    return new MutableInterval(getStartMillis(), getEndMillis(), getChronology());\r\n}"
}, {
	"Path": "org.joda.time.base.BasePeriod.checkAndUpdate",
	"Comment": "checks whether a field type is supported, and if so adds the new valueto the relevant index in the specified array.",
	"Method": "void checkAndUpdate(DurationFieldType type,int[] values,int newValue){\r\n    int index = indexOf(type);\r\n    if (index == -1) {\r\n        if (newValue != 0) {\r\n            throw new IllegalArgumentException(\"Period does not support field '\" + type.getName() + \"'\");\r\n        }\r\n    } else {\r\n        values[index] = newValue;\r\n    }\r\n}"
}, {
	"Path": "jodd.joy.JoddJoy.setApplicationName",
	"Comment": "sets default joy application name used for various components.",
	"Method": "JoddJoy setApplicationName(String name){\r\n    Objects.requireNonNull(name);\r\n    this.appName = name;\r\n    return this;\r\n}"
}, {
	"Path": "jodd.decora.parser.DecoratorTagVisitor.checkNestedDecoraTags",
	"Comment": "check if decora tag is currently defined and throws an exception\ton nested tags.",
	"Method": "void checkNestedDecoraTags(){\r\n    if (decoraTagName != null) {\r\n        throw new DecoraException(\"Nested Decora tags not allowed\");\r\n    }\r\n}"
}, {
	"Path": "jodd.introspector.ClassDescriptor.getPropertyDescriptor",
	"Comment": "returns property descriptor. declared flag is matched on both read and write\tmethods.",
	"Method": "PropertyDescriptor getPropertyDescriptor(String name,boolean declared){\r\n    PropertyDescriptor propertyDescriptor = getProperties().getPropertyDescriptor(name);\r\n    if ((propertyDescriptor != null) && propertyDescriptor.matchDeclared(declared)) {\r\n        return propertyDescriptor;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "jodd.db.DbOom.get",
	"Comment": "returns default dboom instance. if multiple dbooms are in use,\tan exception is thrown.",
	"Method": "DbOom get(DbOom get){\r\n    if (defaultDbOom == null) {\r\n        throw new DbSqlException(\"No default DbOom available. Use DbOom to create one.\\n\" + \"If more then one DbOom is in use, there is no default instance.\");\r\n    }\r\n    return defaultDbOom;\r\n}"
}, {
	"Path": "org.joda.time.Period.withHours",
	"Comment": "returns a new period with the specified number of hours.this period instance is immutable and unaffected by this method call.",
	"Method": "Period withHours(int hours){\r\n    int[] values = getValues();\r\n    getPeriodType().setIndexedField(this, PeriodType.HOUR_INDEX, values, hours);\r\n    return new Period(values, getPeriodType());\r\n}"
}, {
	"Path": "org.joda.time.base.BaseDuration.toIntervalFrom",
	"Comment": "converts this duration to an interval starting at the specified instant.",
	"Method": "Interval toIntervalFrom(ReadableInstant startInstant){\r\n    return new Interval(startInstant, this);\r\n}"
}, {
	"Path": "jodd.servlet.wrapper.Buffer.toByteArray",
	"Comment": "returns buffered servlet output content as byte array.\treturns null if writer is not used.",
	"Method": "byte[] toByteArray(){\r\n    if (bufferOutputStream != null) {\r\n        return bufferOutputStream.getByteArrayStream().toByteArray();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.joda.time.DateTime.secondOfDay",
	"Comment": "get the second of day property which provides access to advanced functionality.",
	"Method": "Property secondOfDay(){\r\n    return new Property(this, getChronology().secondOfDay());\r\n}"
}, {
	"Path": "org.joda.time.format.PeriodFormatterBuilder.appendSecondsWithMillis",
	"Comment": "instruct the printer to emit a combined seconds and millis field, if supported.the millis will overflow into the seconds if necessary.the millis are always output.",
	"Method": "PeriodFormatterBuilder appendSecondsWithMillis(){\r\n    appendField(SECONDS_MILLIS);\r\n    return this;\r\n}"
}, {
	"Path": "org.joda.time.chrono.BasicMonthOfYearDateTimeField.addWrapField",
	"Comment": "add to the month component of the specified time instantwrapping around within that component if necessary.",
	"Method": "long addWrapField(long instant,int months){\r\n    return set(instant, FieldUtils.getWrappedValue(get(instant), months, MIN, iMax));\r\n}"
}, {
	"Path": "org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneOffset",
	"Comment": "instructs the printer to emit text and numbers to display time zoneoffset from utc. a parser will use the parsed time zone offset to adjustthe datetime.if zero offset print text is supplied, then it will be printed when the zone is zero.if zero offset parse text is supplied, then either it or the offset will be parsed.",
	"Method": "DateTimeFormatterBuilder appendTimeZoneOffset(String zeroOffsetText,boolean showSeparators,int minFields,int maxFields,DateTimeFormatterBuilder appendTimeZoneOffset,String zeroOffsetPrintText,String zeroOffsetParseText,boolean showSeparators,int minFields,int maxFields){\r\n    return append0(new TimeZoneOffset(zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields));\r\n}"
}, {
	"Path": "org.joda.time.format.DateTimeParserBucket.setPivotYear",
	"Comment": "sets the pivot year to use when parsing two digit years.if the value is set to null, this will indicate that defaultbehaviour should be used.",
	"Method": "void setPivotYear(Integer pivotYear){\r\n    iPivotYear = pivotYear;\r\n}"
}, {
	"Path": "org.joda.time.Seconds.toStandardHours",
	"Comment": "converts this period in seconds to a period in hours assuming a60 minute hour and 60 second minute.this method allows you to convert between different types of period.however to achieve this it makes the assumption that all hours are60 minutes long and all minutes are 60 seconds long.this may not be true for some unusual chronologies. however, it is includedas it is a useful operation for many applications and business rules.",
	"Method": "Hours toStandardHours(){\r\n    return Hours.hours(getValue() / DateTimeConstants.SECONDS_PER_HOUR);\r\n}"
}, {
	"Path": "org.joda.time.Weeks.minus",
	"Comment": "returns a new instance with the specified number of weeks taken away.this instance is immutable and unaffected by this method call.",
	"Method": "Weeks minus(int weeks,Weeks minus,Weeks weeks){\r\n    if (weeks == null) {\r\n        return this;\r\n    }\r\n    return minus(weeks.getValue());\r\n}"
}, {
	"Path": "org.joda.time.field.UnsupportedDurationField.compareTo",
	"Comment": "always returns zero, indicating that sort order is not relevant.",
	"Method": "int compareTo(DurationField durationField){\r\n    return 0;\r\n}"
}, {
	"Path": "jodd.util.NaturalOrderComparatorTest.testNaturalComparisonSpecialCase",
	"Comment": "the special case when zeros comparison should be ignored, as second number determines\tthe real order.",
	"Method": "void testNaturalComparisonSpecialCase(){\r\n    assertTrue(new NaturalOrderComparator<String>().compare(\"00.1\", \"0.2\") < 0);\r\n}"
}, {
	"Path": "org.joda.time.base.BaseDateTime.setMillis",
	"Comment": "sets the milliseconds of the datetime.all changes to the millisecond field occurs via this method.override and block this method to make a subclass immutable.",
	"Method": "void setMillis(long instant){\r\n    iMillis = checkInstant(instant, iChronology);\r\n}"
}, {
	"Path": "org.jooq.conf.Settings.setExecuteWithOptimisticLockingExcludeUnversioned",
	"Comment": "sets the value of the executewithoptimisticlockingexcludeunversioned property.",
	"Method": "void setExecuteWithOptimisticLockingExcludeUnversioned(Boolean value){\r\n    this.executeWithOptimisticLockingExcludeUnversioned = value;\r\n}"
}, {
	"Path": "org.joda.time.Partial.getFormatter",
	"Comment": "gets a formatter suitable for the fields in this partial.if there is no appropriate iso format, null is returned.this method may return a formatter that does not display all thefields of the partial. this might occur when you have overlappingfields, such as dayofweek and dayofmonth.",
	"Method": "DateTimeFormatter getFormatter(){\r\n    DateTimeFormatter[] f = iFormatter;\r\n    if (f == null) {\r\n        if (size() == 0) {\r\n            return null;\r\n        }\r\n        f = new DateTimeFormatter[2];\r\n        try {\r\n            List<DateTimeFieldType> list = new ArrayList<DateTimeFieldType>(Arrays.asList(iTypes));\r\n            f[0] = ISODateTimeFormat.forFields(list, true, false);\r\n            if (list.size() == 0) {\r\n                f[1] = f[0];\r\n            }\r\n        } catch (IllegalArgumentException ex) {\r\n        }\r\n        iFormatter = f;\r\n    }\r\n    return f[0];\r\n}"
}, {
	"Path": "org.json.CDL.toJSONArray",
	"Comment": "produce a jsonarray of jsonobjects from a comma delimited text stringusing a supplied jsonarray as the source of element names.",
	"Method": "JSONArray toJSONArray(String string,JSONArray toJSONArray,JSONTokener x,JSONArray toJSONArray,JSONArray names,String string,JSONArray toJSONArray,JSONArray names,JSONTokener x){\r\n    if (names == null || names.length() == 0) {\r\n        return null;\r\n    }\r\n    JSONArray ja = new JSONArray();\r\n    for (; ; ) {\r\n        JSONObject jo = rowToJSONObject(names, x);\r\n        if (jo == null) {\r\n            break;\r\n        }\r\n        ja.put(jo);\r\n    }\r\n    if (ja.length() == 0) {\r\n        return null;\r\n    }\r\n    return ja;\r\n}"
}, {
	"Path": "jodd.db.oom.DbOomQuery.initialCollectionSize",
	"Comment": "returns initial collections size when max\tvalue is provided.",
	"Method": "int initialCollectionSize(int max){\r\n    return max > 0 ? max : 10;\r\n}"
}, {
	"Path": "org.jooq.conf.Settings.setReturnIdentityOnUpdatableRecord",
	"Comment": "sets the value of the returnidentityonupdatablerecord property.",
	"Method": "void setReturnIdentityOnUpdatableRecord(Boolean value){\r\n    this.returnIdentityOnUpdatableRecord = value;\r\n}"
}, {
	"Path": "org.joda.time.DateMidnight.property",
	"Comment": "gets the property object for the specified type, which contains many useful methods.",
	"Method": "Property property(DateTimeFieldType type){\r\n    if (type == null) {\r\n        throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\r\n    }\r\n    DateTimeField field = type.getField(getChronology());\r\n    if (field.isSupported() == false) {\r\n        throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\");\r\n    }\r\n    return new Property(this, field);\r\n}"
}, {
	"Path": "jodd.madvoc.interceptor.EchoInterceptor.printAfter",
	"Comment": "prints out the message. user can override this method and modify the way\tthe message is printed.",
	"Method": "void printAfter(ActionRequest request,long executionTime,Object result){\r\n    StringBuilder message = new StringBuilder(prefixOut);\r\n    String resultString = StringUtil.toSafeString(result);\r\n    if (resultString.length() > 70) {\r\n        resultString = resultString.substring(0, 70);\r\n        resultString += \"...\";\r\n    }\r\n    message.append(request.getActionPath()).append(\"  (\").append(resultString).append(\") in \").append(executionTime).append(\"ms.\");\r\n    out(message.toString());\r\n}"
}, {
	"Path": "jodd.util.CharUtil.toSimpleByteArray",
	"Comment": "converts char array into byte array by stripping the high byte of each character.",
	"Method": "byte[] toSimpleByteArray(char[] carr,byte[] toSimpleByteArray,CharSequence charSequence){\r\n    byte[] barr = new byte[charSequence.length()];\r\n    for (int i = 0; i < barr.length; i++) {\r\n        barr[i] = (byte) charSequence.charAt(i);\r\n    }\r\n    return barr;\r\n}"
}, {
	"Path": "org.joda.time.Instant.minus",
	"Comment": "gets a copy of this instant with the specified duration taken away.if the amount is zero or null, then this is returned.",
	"Method": "Instant minus(long duration,Instant minus,ReadableDuration duration){\r\n    return withDurationAdded(duration, -1);\r\n}"
}, {
	"Path": "org.joda.time.LocalTime.withSecondOfMinute",
	"Comment": "returns a copy of this time with the second of minute field updated.localtime is immutable, so there are no set methods.instead, this method returns a new instance with the value ofsecond of minute changed.",
	"Method": "LocalTime withSecondOfMinute(int second){\r\n    return withLocalMillis(getChronology().secondOfMinute().set(getLocalMillis(), second));\r\n}"
}, {
	"Path": "org.joda.time.IllegalFieldValueException.prependMessage",
	"Comment": "provide additional detail by prepending a message to the existing message.a colon is separator is automatically inserted between the messages.",
	"Method": "void prependMessage(String message){\r\n    if (iMessage == null) {\r\n        iMessage = message;\r\n    } else if (message != null) {\r\n        iMessage = message + \": \" + iMessage;\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.field.PreciseDurationDateTimeField.set",
	"Comment": "set the specified amount of units to the specified time instant.",
	"Method": "long set(long instant,int value){\r\n    FieldUtils.verifyValueBounds(this, value, getMinimumValue(), getMaximumValueForSet(instant, value));\r\n    return instant + (value - get(instant)) * iUnitMillis;\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.video.H264Stream.getSessionDescription",
	"Comment": "returns a description of the stream using sdp. it can then be included in an sdp file.",
	"Method": "String getSessionDescription(){\r\n    if (mConfig == null)\r\n        throw new IllegalStateException(\"You need to call configure() first !\");\r\n    return \"m=video \" + String.valueOf(getDestinationPorts()[0]) + \" RTP/AVP 96\\r\\n\" + \"a=rtpmap:96 H264/90000\\r\\n\" + \"a=fmtp:96 packetization-mode=1;profile-level-id=\" + mConfig.getProfileLevel() + \";sprop-parameter-sets=\" + mConfig.getB64SPS() + \",\" + mConfig.getB64PPS() + \";\\r\\n\";\r\n}"
}, {
	"Path": "jodd.util.collection.SetMapAdapter.add",
	"Comment": "adds the specified element to this set if it is not already\tpresent.",
	"Method": "boolean add(E o){\r\n    return map.put(o, DUMMY_VALUE) == null;\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractInterval.isBeforeNow",
	"Comment": "is this time interval before the current instant.intervals are inclusive of the start instant and exclusive of the end.",
	"Method": "boolean isBeforeNow(){\r\n    return isBefore(DateTimeUtils.currentTimeMillis());\r\n}"
}, {
	"Path": "jodd.util.StringUtil.toSafeString",
	"Comment": "converts safely an object to a string. if object is null an empty\tstring is returned.",
	"Method": "String toSafeString(Object value){\r\n    if (value == null) {\r\n        return EMPTY;\r\n    }\r\n    return value.toString();\r\n}"
}, {
	"Path": "jodd.madvoc.ActionRequest.invokeActionMethod",
	"Comment": "invokes action method after starting all interceptors.\tafter method invocation, all interceptors will finish, in opposite order.",
	"Method": "Object invokeActionMethod(){\r\n    if (actionRuntime.isActionHandlerDefined()) {\r\n        actionRuntime.getActionHandler().handle(this);\r\n        return null;\r\n    }\r\n    final Object[] params = targets.extractParametersValues();\r\n    try {\r\n        return actionRuntime.getActionClassMethod().invoke(action, params);\r\n    } catch (InvocationTargetException itex) {\r\n        throw wrapToException(unwrapThrowable(itex));\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.PeriodType.withWeeksRemoved",
	"Comment": "returns a version of this periodtype instance that does not support weeks.",
	"Method": "PeriodType withWeeksRemoved(){\r\n    return withFieldRemoved(2, \"NoWeeks\");\r\n}"
}, {
	"Path": "org.joda.time.LocalDate.getField",
	"Comment": "gets the field for a specific index in the chronology specified.this method must not use any instance variables.",
	"Method": "DateTimeField getField(int index,Chronology chrono,DateTimeField getField){\r\n    switch(index) {\r\n        case YEAR:\r\n            return chrono.year();\r\n        case MONTH_OF_YEAR:\r\n            return chrono.monthOfYear();\r\n        case DAY_OF_MONTH:\r\n            return chrono.dayOfMonth();\r\n        default:\r\n            throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\r\n    }\r\n}"
}, {
	"Path": "jodd.madvoc.component.MadvocController.getApplicationContext",
	"Comment": "returns application context set during the initialization.",
	"Method": "ServletContext getApplicationContext(){\r\n    return servletContextProvider.get();\r\n}"
}, {
	"Path": "org.joda.time.LocalDate.weekOfWeekyear",
	"Comment": "get the week of a week based year property which provides access to advanced functionality.",
	"Method": "Property weekOfWeekyear(){\r\n    return new Property(this, getChronology().weekOfWeekyear());\r\n}"
}, {
	"Path": "org.jooq.impl.Tools.first",
	"Comment": "extract the first item from an iterable or null, if there isno such item, or if iterable itself is null",
	"Method": "T first(Iterable<? extends T> iterable){\r\n    if (iterable == null) {\r\n        return null;\r\n    } else {\r\n        Iterator<? extends T> iterator = iterable.iterator();\r\n        if (iterator.hasNext()) {\r\n            return iterator.next();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jooq.impl.DefaultDiagnosticsListenerProvider.providers",
	"Comment": "convenience method to construct an array ofdefaultdiagnosticslistenerprovider from an array ofdiagnosticslistener instances.",
	"Method": "DiagnosticsListenerProvider[] providers(DiagnosticsListener listeners){\r\n    DiagnosticsListenerProvider[] result = new DiagnosticsListenerProvider[listeners.length];\r\n    for (int i = 0; i < listeners.length; i++) result[i] = new DefaultDiagnosticsListenerProvider(listeners[i]);\r\n    return result;\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractPartial.getFields",
	"Comment": "gets an array of the fields that this partial supports.the fields are returned largest to smallest, for example hour, minute, second.",
	"Method": "DateTimeField[] getFields(){\r\n    DateTimeField[] result = new DateTimeField[size()];\r\n    for (int i = 0; i < result.length; i++) {\r\n        result[i] = getField(i);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "jodd.db.DbQueryBase.closeQuery",
	"Comment": "closes all assigned result sets and then closes the query. query becomes closed.",
	"Method": "SQLException closeQuery(){\r\n    SQLException sqlException = closeQueryResultSets();\r\n    if (statement != null) {\r\n        try {\r\n            statement.close();\r\n        } catch (SQLException sex) {\r\n            if (sqlException == null) {\r\n                sqlException = sex;\r\n            } else {\r\n                sqlException.setNextException(sex);\r\n            }\r\n        }\r\n        statement = null;\r\n    }\r\n    query = null;\r\n    queryState = CLOSED;\r\n    return sqlException;\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.millisOfDay",
	"Comment": "get the millis of day property which provides access to advanced functionality.",
	"Method": "Property millisOfDay(){\r\n    return new Property(this, getChronology().millisOfDay());\r\n}"
}, {
	"Path": "jodd.exception.ExceptionUtil.getCurrentStackTrace",
	"Comment": "returns current stack trace in form of array of stack trace elements.\tfirst stack trace element is removed.\tsince an exception is thrown internally, this method is slow.",
	"Method": "StackTraceElement[] getCurrentStackTrace(){\r\n    StackTraceElement[] ste = new Exception().getStackTrace();\r\n    if (ste.length > 1) {\r\n        StackTraceElement[] result = new StackTraceElement[ste.length - 1];\r\n        System.arraycopy(ste, 1, result, 0, ste.length - 1);\r\n        return result;\r\n    } else {\r\n        return ste;\r\n    }\r\n}"
}, {
	"Path": "jodd.io.NetUtil.downloadFile",
	"Comment": "downloads resource to a file, potentially very efficiently.",
	"Method": "void downloadFile(String url,File file){\r\n    try (InputStream inputStream = new URL(url).openStream();\r\n        ReadableByteChannel rbc = Channels.newChannel(inputStream);\r\n        FileChannel fileChannel = FileChannel.open(file.toPath(), StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.WRITE)) {\r\n        fileChannel.transferFrom(rbc, 0, Long.MAX_VALUE);\r\n    }\r\n}"
}, {
	"Path": "jodd.db.oom.DbMetaUtil.resolveColumnDescriptors",
	"Comment": "resolves column descriptor from property. if property is annotated value will be read\tfrom annotation. if property is not annotated, then property will be ignored\tif entity is annotated. otherwise, column name is generated from the property name.",
	"Method": "DbEntityColumnDescriptor resolveColumnDescriptors(DbEntityDescriptor dbEntityDescriptor,PropertyDescriptor property,boolean isAnnotated,ColumnNamingStrategy columnNamingStrategy){\r\n    String columnName = null;\r\n    boolean isId = false;\r\n    Class<? extends SqlType> sqlTypeClass = null;\r\n    DbId dbId = null;\r\n    if (property.getFieldDescriptor() != null) {\r\n        dbId = property.getFieldDescriptor().getField().getAnnotation(DbId.class);\r\n    }\r\n    if (dbId == null && property.getReadMethodDescriptor() != null) {\r\n        dbId = property.getReadMethodDescriptor().getMethod().getAnnotation(DbId.class);\r\n    }\r\n    if (dbId == null && property.getWriteMethodDescriptor() != null) {\r\n        dbId = property.getWriteMethodDescriptor().getMethod().getAnnotation(DbId.class);\r\n    }\r\n    if (dbId != null) {\r\n        columnName = dbId.value().trim();\r\n        sqlTypeClass = dbId.sqlType();\r\n        isId = true;\r\n    } else {\r\n        DbColumn dbColumn = null;\r\n        if (property.getFieldDescriptor() != null) {\r\n            dbColumn = property.getFieldDescriptor().getField().getAnnotation(DbColumn.class);\r\n        }\r\n        if (dbColumn == null && property.getReadMethodDescriptor() != null) {\r\n            dbColumn = property.getReadMethodDescriptor().getMethod().getAnnotation(DbColumn.class);\r\n        }\r\n        if (dbColumn == null && property.getWriteMethodDescriptor() != null) {\r\n            dbColumn = property.getWriteMethodDescriptor().getMethod().getAnnotation(DbColumn.class);\r\n        }\r\n        if (dbColumn != null) {\r\n            columnName = dbColumn.value().trim();\r\n            sqlTypeClass = dbColumn.sqlType();\r\n        } else {\r\n            if (isAnnotated) {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n    if (StringUtil.isEmpty(columnName)) {\r\n        columnName = columnNamingStrategy.convertPropertyNameToColumnName(property.getName());\r\n    } else {\r\n        if (!columnNamingStrategy.isStrictAnnotationNames()) {\r\n            columnName = columnNamingStrategy.applyToColumnName(columnName);\r\n        }\r\n    }\r\n    if (sqlTypeClass == SqlType.class) {\r\n        sqlTypeClass = null;\r\n    }\r\n    return new DbEntityColumnDescriptor(dbEntityDescriptor, quoteIfRequired(columnName, columnNamingStrategy.isAlwaysQuoteNames(), columnNamingStrategy.getQuoteChar()), property.getName(), property.getType(), isId, sqlTypeClass);\r\n}"
}, {
	"Path": "jodd.util.StringUtil.surround",
	"Comment": "surrounds the string with provided prefix and suffix if such missing from string.",
	"Method": "String surround(String string,String fix,String surround,String string,String prefix,String suffix){\r\n    if (!string.startsWith(prefix)) {\r\n        string = prefix + string;\r\n    }\r\n    if (!string.endsWith(suffix)) {\r\n        string += suffix;\r\n    }\r\n    return string;\r\n}"
}, {
	"Path": "org.joda.time.Seconds.isLessThan",
	"Comment": "is this seconds instance less than the specified number of seconds.",
	"Method": "boolean isLessThan(Seconds other){\r\n    if (other == null) {\r\n        return getValue() < 0;\r\n    }\r\n    return getValue() < other.getValue();\r\n}"
}, {
	"Path": "jodd.htmlstapler.HtmlStaplerBundlesManager.resolveRealActionPath",
	"Comment": "resolves real action path for given one.\twhen some urls are dynamically created, many different links points\tto the same page. use this to prevent memory leaking.",
	"Method": "String resolveRealActionPath(String actionPath){\r\n    return actionPath;\r\n}"
}, {
	"Path": "jodd.asm7.Handler.removeRange",
	"Comment": "removes the range between start and end from the handler list that begins with the givenelement.",
	"Method": "Handler removeRange(Handler firstHandler,Label start,Label end){\r\n    if (firstHandler == null) {\r\n        return null;\r\n    } else {\r\n        firstHandler.nextHandler = removeRange(firstHandler.nextHandler, start, end);\r\n    }\r\n    int handlerStart = firstHandler.startPc.bytecodeOffset;\r\n    int handlerEnd = firstHandler.endPc.bytecodeOffset;\r\n    int rangeStart = start.bytecodeOffset;\r\n    int rangeEnd = end == null ? Integer.MAX_VALUE : end.bytecodeOffset;\r\n    if (rangeStart >= handlerEnd || rangeEnd <= handlerStart) {\r\n        return firstHandler;\r\n    }\r\n    if (rangeStart <= handlerStart) {\r\n        if (rangeEnd >= handlerEnd) {\r\n            return firstHandler.nextHandler;\r\n        } else {\r\n            return new Handler(firstHandler, end, firstHandler.endPc);\r\n        }\r\n    } else if (rangeEnd >= handlerEnd) {\r\n        return new Handler(firstHandler, firstHandler.startPc, start);\r\n    } else {\r\n        firstHandler.nextHandler = new Handler(firstHandler, end, firstHandler.endPc);\r\n        return new Handler(firstHandler, firstHandler.startPc, start);\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.DateTimeComparator.getInstance",
	"Comment": "returns a datetimecomparator the compares the entire date time value.",
	"Method": "DateTimeComparator getInstance(DateTimeComparator getInstance,DateTimeFieldType lowerLimit,DateTimeComparator getInstance,DateTimeFieldType lowerLimit,DateTimeFieldType upperLimit){\r\n    if (lowerLimit == null && upperLimit == null) {\r\n        return ALL_INSTANCE;\r\n    }\r\n    if (lowerLimit == DateTimeFieldType.dayOfYear() && upperLimit == null) {\r\n        return DATE_INSTANCE;\r\n    }\r\n    if (lowerLimit == null && upperLimit == DateTimeFieldType.dayOfYear()) {\r\n        return TIME_INSTANCE;\r\n    }\r\n    return new DateTimeComparator(lowerLimit, upperLimit);\r\n}"
}, {
	"Path": "org.joda.time.chrono.ISOChronology.getInstanceUTC",
	"Comment": "gets an instance of the isochronology.the time zone of the returned instance is utc.",
	"Method": "ISOChronology getInstanceUTC(){\r\n    return INSTANCE_UTC;\r\n}"
}, {
	"Path": "org.joda.time.DateTime.yearOfCentury",
	"Comment": "get the year of century property which provides access to advanced functionality.",
	"Method": "Property yearOfCentury(){\r\n    return new Property(this, getChronology().yearOfCentury());\r\n}"
}, {
	"Path": "jodd.introspector.Fields.getAllFieldDescriptors",
	"Comment": "returns all fields of this collection. returns empty array\tif no fields exist. initialized lazy.",
	"Method": "FieldDescriptor[] getAllFieldDescriptors(){\r\n    if (allFields == null) {\r\n        FieldDescriptor[] allFields = new FieldDescriptor[fieldsMap.size()];\r\n        int index = 0;\r\n        for (FieldDescriptor fieldDescriptor : fieldsMap.values()) {\r\n            allFields[index] = fieldDescriptor;\r\n            index++;\r\n        }\r\n        Arrays.sort(allFields, new Comparator<FieldDescriptor>() {\r\n            public int compare(final FieldDescriptor fd1, final FieldDescriptor fd2) {\r\n                return fd1.getField().getName().compareTo(fd2.getField().getName());\r\n            }\r\n        });\r\n        this.allFields = allFields;\r\n    }\r\n    return allFields;\r\n}"
}, {
	"Path": "jodd.introspector.Fields.getAllFieldDescriptors",
	"Comment": "returns all fields of this collection. returns empty array\tif no fields exist. initialized lazy.",
	"Method": "FieldDescriptor[] getAllFieldDescriptors(){\r\n    return fd1.getField().getName().compareTo(fd2.getField().getName());\r\n}"
}, {
	"Path": "org.joda.time.LocalTime.withMillisOfSecond",
	"Comment": "returns a copy of this time with the millis of second field updated.localtime is immutable, so there are no set methods.instead, this method returns a new instance with the value ofmillis of second changed.",
	"Method": "LocalTime withMillisOfSecond(int millis){\r\n    return withLocalMillis(getChronology().millisOfSecond().set(getLocalMillis(), millis));\r\n}"
}, {
	"Path": "jodd.jerry.Jerry.end",
	"Comment": "ends the most recent filtering operation in the current chain\tand returns the set of matched elements to its previous state.",
	"Method": "Jerry end(){\r\n    return parent;\r\n}"
}, {
	"Path": "jodd.typeconverter.Converter.toBigDecimal",
	"Comment": "converts value to bigdecimal. returns default value\twhen conversion result is null",
	"Method": "BigDecimal toBigDecimal(Object value,BigDecimal toBigDecimal,Object value,BigDecimal defaultValue){\r\n    final BigDecimal result = toBigDecimal(value);\r\n    if (result == null) {\r\n        return defaultValue;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.withFields",
	"Comment": "returns a copy of this datetime with the partial set of fieldsreplacing those from this instance.for example, if the partial is a timeofday then the time fieldswould be changed in the returned instance.if the partial is null, then this is returned.",
	"Method": "LocalDateTime withFields(ReadablePartial partial){\r\n    if (partial == null) {\r\n        return this;\r\n    }\r\n    return withLocalMillis(getChronology().set(partial, getLocalMillis()));\r\n}"
}, {
	"Path": "jodd.net.HtmlEncoder.xml",
	"Comment": "encodes xml string. in xml there are only 5 predefined character entities.",
	"Method": "String xml(CharSequence text){\r\n    return encode(text, TEXT_XML, LEN_XML);\r\n}"
}, {
	"Path": "org.joda.time.Minutes.toStandardDays",
	"Comment": "converts this period in minutes to a period in days assuming a24 hour day and 60 minute hour.this method allows you to convert between different types of period.however to achieve this it makes the assumption that all days are24 hours long and all hours are 60 minutes long.this is not true when daylight savings is considered and may also notbe true for some unusual chronologies. however, it is includedas it is a useful operation for many applications and business rules.",
	"Method": "Days toStandardDays(){\r\n    return Days.days(getValue() / DateTimeConstants.MINUTES_PER_DAY);\r\n}"
}, {
	"Path": "jodd.http.Cookie.setValue",
	"Comment": "assigns a new value to a cookie after the cookie is created.\tif you use a binary value, you may want to use base64 encoding.",
	"Method": "Cookie setValue(String newValue){\r\n    value = newValue;\r\n    return this;\r\n}"
}, {
	"Path": "jodd.csselly.CSSelly.toString",
	"Comment": "returns string representation of given list of selectors.",
	"Method": "String toString(List<CssSelector> selectors){\r\n    StringBuilder out = new StringBuilder();\r\n    for (CssSelector s : selectors) {\r\n        out.append(s.toString());\r\n    }\r\n    return out.toString();\r\n}"
}, {
	"Path": "org.json.JSONTokener.back",
	"Comment": "back up one character. this provides a sort of lookahead capability,so that you can test for a digit or letter before attempting to parsethe next number or identifier.",
	"Method": "void back(){\r\n    if (this.usePrevious || this.index <= 0) {\r\n        throw new JSONException(\"Stepping back two steps is not supported\");\r\n    }\r\n    this.decrementIndexes();\r\n    this.usePrevious = true;\r\n    this.eof = false;\r\n}"
}, {
	"Path": "jodd.proxetta.GenericsReader.parseSignatureForGenerics",
	"Comment": "parses signature for generic information and returns a map where key is generic name\tand value is raw type. returns an empty map if signature does not define any generics.",
	"Method": "Map<String, String> parseSignatureForGenerics(String signature,boolean isInterface){\r\n    if (signature == null) {\r\n        return Collections.emptyMap();\r\n    }\r\n    final Map<String, String> genericsMap = new HashMap();\r\n    SignatureReader sr = new SignatureReader(signature);\r\n    StringBuilder sb = new StringBuilder();\r\n    TraceSignatureVisitor v = new TraceSignatureVisitor(sb, isInterface) {\r\n        String genericName;\r\n        @Override\r\n        public void visitFormalTypeParameter(final String name) {\r\n            genericName = name;\r\n            super.visitFormalTypeParameter(name);\r\n        }\r\n        @Override\r\n        public void visitClassType(final String name) {\r\n            if (genericName != null) {\r\n                genericsMap.put(genericName, 'L' + name + ';');\r\n                genericName = null;\r\n            }\r\n            super.visitClassType(name);\r\n        }\r\n    };\r\n    sr.accept(v);\r\n    return genericsMap;\r\n}"
}, {
	"Path": "jodd.proxetta.GenericsReader.parseSignatureForGenerics",
	"Comment": "parses signature for generic information and returns a map where key is generic name\tand value is raw type. returns an empty map if signature does not define any generics.",
	"Method": "Map<String, String> parseSignatureForGenerics(String signature,boolean isInterface){\r\n    genericName = name;\r\n    super.visitFormalTypeParameter(name);\r\n}"
}, {
	"Path": "jodd.proxetta.GenericsReader.parseSignatureForGenerics",
	"Comment": "parses signature for generic information and returns a map where key is generic name\tand value is raw type. returns an empty map if signature does not define any generics.",
	"Method": "Map<String, String> parseSignatureForGenerics(String signature,boolean isInterface){\r\n    if (genericName != null) {\r\n        genericsMap.put(genericName, 'L' + name + ';');\r\n        genericName = null;\r\n    }\r\n    super.visitClassType(name);\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.hw.EncoderDebugger.compareChromaPanes",
	"Comment": "compares the u or v pane of the initial image, and the u or v pane\tafter having encoded & decoded the image.",
	"Method": "boolean compareChromaPanes(boolean crossed){\r\n    int d, f = 0;\r\n    for (int j = 0; j < NB_DECODED; j++) {\r\n        if (mDecodedVideo[j] != null) {\r\n            if (!crossed) {\r\n                for (int i = mSize; i < 3 * mSize / 2; i += 1) {\r\n                    d = (mInitialImage[i] & 0xFF) - (mDecodedVideo[j][i] & 0xFF);\r\n                    d = d < 0 ? -d : d;\r\n                    if (d > 50) {\r\n                        f++;\r\n                        break;\r\n                    }\r\n                }\r\n            } else {\r\n                for (int i = mSize; i < 3 * mSize / 2; i += 2) {\r\n                    d = (mInitialImage[i] & 0xFF) - (mDecodedVideo[j][i + 1] & 0xFF);\r\n                    d = d < 0 ? -d : d;\r\n                    if (d > 50) {\r\n                        f++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return f <= NB_DECODED / 2;\r\n}"
}, {
	"Path": "org.joda.time.Interval.withDurationBeforeEnd",
	"Comment": "creates a new interval with the specified duration before the end instant.",
	"Method": "Interval withDurationBeforeEnd(ReadableDuration duration){\r\n    long durationMillis = DateTimeUtils.getDurationMillis(duration);\r\n    if (durationMillis == toDurationMillis()) {\r\n        return this;\r\n    }\r\n    Chronology chrono = getChronology();\r\n    long endMillis = getEndMillis();\r\n    long startMillis = chrono.add(endMillis, durationMillis, -1);\r\n    return new Interval(startMillis, endMillis, chrono);\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractPartial.hashCode",
	"Comment": "gets a hash code for the readablepartial that is compatible with the equals method.",
	"Method": "int hashCode(){\r\n    int total = 157;\r\n    for (int i = 0, isize = size(); i < isize; i++) {\r\n        total = 23 * total + getValue(i);\r\n        total = 23 * total + getFieldType(i).hashCode();\r\n    }\r\n    total += getChronology().hashCode();\r\n    return total;\r\n}"
}, {
	"Path": "jodd.jtx.JtxTransactionManager.isNewTxScope",
	"Comment": "returns true if scope is specified and it is different then of existing transaction.",
	"Method": "boolean isNewTxScope(JtxTransaction currentTx,Object destScope){\r\n    if (ignoreScope) {\r\n        return true;\r\n    }\r\n    if (currentTx == null) {\r\n        return true;\r\n    }\r\n    if (destScope == null) {\r\n        return true;\r\n    }\r\n    if (currentTx.getScope() == null) {\r\n        return true;\r\n    }\r\n    return !destScope.equals(currentTx.getScope());\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.dayOfMonth",
	"Comment": "get the day of month property which provides access to advanced functionality.",
	"Method": "Property dayOfMonth(){\r\n    return new Property(this, getChronology().dayOfMonth());\r\n}"
}, {
	"Path": "org.json.XML.parse",
	"Comment": "scan the content following the named tag, attaching it to the context.",
	"Method": "boolean parse(XMLTokener x,JSONObject context,String name,boolean keepStrings){\r\n    char c;\r\n    int i;\r\n    JSONObject jsonobject = null;\r\n    String string;\r\n    String tagName;\r\n    Object token;\r\n    token = x.nextToken();\r\n    if (token == BANG) {\r\n        c = x.next();\r\n        if (c == '-') {\r\n            if (x.next() == '-') {\r\n                x.skipPast(\"-->\");\r\n                return false;\r\n            }\r\n            x.back();\r\n        } else if (c == '[') {\r\n            token = x.nextToken();\r\n            if (\"CDATA\".equals(token)) {\r\n                if (x.next() == '[') {\r\n                    string = x.nextCDATA();\r\n                    if (string.length() > 0) {\r\n                        context.accumulate(\"content\", string);\r\n                    }\r\n                    return false;\r\n                }\r\n            }\r\n            throw x.syntaxError(\"Expected 'CDATA['\");\r\n        }\r\n        i = 1;\r\n        do {\r\n            token = x.nextMeta();\r\n            if (token == null) {\r\n                throw x.syntaxError(\"Missing '>' after '<!'.\");\r\n            } else if (token == LT) {\r\n                i += 1;\r\n            } else if (token == GT) {\r\n                i -= 1;\r\n            }\r\n        } while (i > 0);\r\n        return false;\r\n    } else if (token == QUEST) {\r\n        x.skipPast(\"?>\");\r\n        return false;\r\n    } else if (token == SLASH) {\r\n        token = x.nextToken();\r\n        if (name == null) {\r\n            throw x.syntaxError(\"Mismatched close tag \" + token);\r\n        }\r\n        if (!token.equals(name)) {\r\n            throw x.syntaxError(\"Mismatched \" + name + \" and \" + token);\r\n        }\r\n        if (x.nextToken() != GT) {\r\n            throw x.syntaxError(\"Misshaped close tag\");\r\n        }\r\n        return true;\r\n    } else if (token instanceof Character) {\r\n        throw x.syntaxError(\"Misshaped tag\");\r\n    } else {\r\n        tagName = (String) token;\r\n        token = null;\r\n        jsonobject = new JSONObject();\r\n        for (; ; ) {\r\n            if (token == null) {\r\n                token = x.nextToken();\r\n            }\r\n            if (token instanceof String) {\r\n                string = (String) token;\r\n                token = x.nextToken();\r\n                if (token == EQ) {\r\n                    token = x.nextToken();\r\n                    if (!(token instanceof String)) {\r\n                        throw x.syntaxError(\"Missing value\");\r\n                    }\r\n                    jsonobject.accumulate(string, keepStrings ? ((String) token) : stringToValue((String) token));\r\n                    token = null;\r\n                } else {\r\n                    jsonobject.accumulate(string, \"\");\r\n                }\r\n            } else if (token == SLASH) {\r\n                if (x.nextToken() != GT) {\r\n                    throw x.syntaxError(\"Misshaped tag\");\r\n                }\r\n                if (jsonobject.length() > 0) {\r\n                    context.accumulate(tagName, jsonobject);\r\n                } else {\r\n                    context.accumulate(tagName, \"\");\r\n                }\r\n                return false;\r\n            } else if (token == GT) {\r\n                for (; ; ) {\r\n                    token = x.nextContent();\r\n                    if (token == null) {\r\n                        if (tagName != null) {\r\n                            throw x.syntaxError(\"Unclosed tag \" + tagName);\r\n                        }\r\n                        return false;\r\n                    } else if (token instanceof String) {\r\n                        string = (String) token;\r\n                        if (string.length() > 0) {\r\n                            jsonobject.accumulate(\"content\", keepStrings ? string : stringToValue(string));\r\n                        }\r\n                    } else if (token == LT) {\r\n                        if (parse(x, jsonobject, tagName, keepStrings)) {\r\n                            if (jsonobject.length() == 0) {\r\n                                context.accumulate(tagName, \"\");\r\n                            } else if (jsonobject.length() == 1 && jsonobject.opt(\"content\") != null) {\r\n                                context.accumulate(tagName, jsonobject.opt(\"content\"));\r\n                            } else {\r\n                                context.accumulate(tagName, jsonobject);\r\n                            }\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                throw x.syntaxError(\"Misshaped tag\");\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jodd.jtx.JtxTransactionManager.continueTx",
	"Comment": "check if propagation of a transaction is possible, due to source and destination transaction modes.",
	"Method": "void continueTx(JtxTransaction sourceTx,JtxTransactionMode destMode){\r\n    if (!validateExistingTransaction) {\r\n        return;\r\n    }\r\n    JtxTransactionMode sourceMode = sourceTx.getTransactionMode();\r\n    JtxIsolationLevel destIsolationLevel = destMode.getIsolationLevel();\r\n    if (destIsolationLevel != ISOLATION_DEFAULT) {\r\n        JtxIsolationLevel currentIsolationLevel = sourceMode.getIsolationLevel();\r\n        if (currentIsolationLevel != destIsolationLevel) {\r\n            throw new JtxException(\"Participating TX specifies isolation level: \" + destIsolationLevel + \" which is incompatible with existing TX: \" + currentIsolationLevel);\r\n        }\r\n    }\r\n    if ((!destMode.isReadOnly()) && (sourceMode.isReadOnly())) {\r\n        throw new JtxException(\"Participating TX is not marked as read-only, but existing TX is\");\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.format.DateTimeParserBucket.getOffset",
	"Comment": "returns the time zone offset in milliseconds used by computemillis.",
	"Method": "int getOffset(){\r\n    return (iOffset != null ? iOffset : 0);\r\n}"
}, {
	"Path": "org.joda.time.LocalDate.getValue",
	"Comment": "gets the value of the field at the specified index.this method is required to support the readablepartialinterface. the supported fields are year, monthofyear and dayofmonth.note that all fields from day and above may in fact be queried viaother methods.",
	"Method": "int getValue(int index){\r\n    switch(index) {\r\n        case YEAR:\r\n            return getChronology().year().get(getLocalMillis());\r\n        case MONTH_OF_YEAR:\r\n            return getChronology().monthOfYear().get(getLocalMillis());\r\n        case DAY_OF_MONTH:\r\n            return getChronology().dayOfMonth().get(getLocalMillis());\r\n        default:\r\n            throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\r\n    }\r\n}"
}, {
	"Path": "jodd.typeconverter.Converter.toIntValue",
	"Comment": "converts value to int. returns default value\twhen conversion result is null.",
	"Method": "int toIntValue(Object value,int defaultValue,int toIntValue,Object value){\r\n    return toIntValue(value, 0);\r\n}"
}, {
	"Path": "jodd.madvoc.result.ServletPermanentRedirectActionResult.render",
	"Comment": "redirects to the given location. provided path is parsed, action is used as a value context.",
	"Method": "void render(ActionRequest actionRequest,Object resultValue){\r\n    final PermRedirect redirectResult;\r\n    if (resultValue == null) {\r\n        redirectResult = PermRedirect.to(StringPool.SLASH);\r\n    } else {\r\n        if (resultValue instanceof String) {\r\n            redirectResult = PermRedirect.to((String) resultValue);\r\n        } else {\r\n            redirectResult = (PermRedirect) resultValue;\r\n        }\r\n    }\r\n    final String resultBasePath = actionRequest.getActionRuntime().getResultBasePath();\r\n    final String redirectValue = redirectResult.path();\r\n    final String resultPath;\r\n    if (redirectValue.startsWith(\"http://\") || redirectValue.startsWith(\"https://\")) {\r\n        resultPath = redirectValue;\r\n    } else {\r\n        resultPath = resultMapper.resolveResultPathString(resultBasePath, redirectValue);\r\n    }\r\n    final HttpServletRequest request = actionRequest.getHttpServletRequest();\r\n    final HttpServletResponse response = actionRequest.getHttpServletResponse();\r\n    String path = beanTemplateParser.parseWithBean(resultPath, actionRequest.getAction());\r\n    DispatcherUtil.redirectPermanent(request, response, path);\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.withWeekyear",
	"Comment": "returns a copy of this datetime with the weekyear field updated.the weekyear is the year that matches with the weekofweekyear field.in the standard iso8601 week algorithm, the first week of the yearis that in which at least 4 days are in the year. as a result of thisdefinition, day 1 of the first week may be in the previous year.the weekyear allows you to query the effective year for that day.localdatetime is immutable, so there are no set methods.instead, this method returns a new instance with the value ofweekyear changed.",
	"Method": "LocalDateTime withWeekyear(int weekyear){\r\n    return withLocalMillis(getChronology().weekyear().set(getLocalMillis(), weekyear));\r\n}"
}, {
	"Path": "jodd.servlet.DispatcherUtil.includeAbsolute",
	"Comment": "include page which path relative to the root of the servletcontext.",
	"Method": "boolean includeAbsolute(HttpServletRequest request,HttpServletResponse response,String page,boolean includeAbsolute,ServletContext context,ServletRequest request,HttpServletResponse response,String page){\r\n    RequestDispatcher dispatcher = context.getRequestDispatcher(page);\r\n    if (dispatcher != null) {\r\n        dispatcher.include(request, response);\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.jooq.tools.reflect.Reflect.match",
	"Comment": "check whether two arrays of types match, converting primitive types totheir corresponding wrappers.",
	"Method": "boolean match(Class<?>[] declaredTypes,Class<?>[] actualTypes){\r\n    if (declaredTypes.length == actualTypes.length) {\r\n        for (int i = 0; i < actualTypes.length; i++) {\r\n            if (actualTypes[i] == NULL.class)\r\n                continue;\r\n            if (wrapper(declaredTypes[i]).isAssignableFrom(wrapper(actualTypes[i])))\r\n                continue;\r\n            return false;\r\n        }\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.format.DateTimeFormatter.withDefaultYear",
	"Comment": "returns a new formatter that will use the specified default year.the default year is used when parsing in the case where there is amonth or a day but not a year. specifically, it is used if there isa field parsed with a duration between the length of a month and thelength of a day inclusive.this value is typically used to move the year from 1970 to a leap yearto enable february 29th to be parsed.unless customised, the year 2000 is used.this setting has no effect when printing.",
	"Method": "DateTimeFormatter withDefaultYear(int defaultYear){\r\n    return new DateTimeFormatter(iPrinter, iParser, iLocale, iOffsetParsed, iChrono, iZone, iPivotYear, defaultYear);\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.withMillisOfSecond",
	"Comment": "returns a copy of this datetime with the millis of second field updated.localdatetime is immutable, so there are no set methods.instead, this method returns a new instance with the value ofmillis of second changed.",
	"Method": "LocalDateTime withMillisOfSecond(int millis){\r\n    return withLocalMillis(getChronology().millisOfSecond().set(getLocalMillis(), millis));\r\n}"
}, {
	"Path": "org.joda.time.format.DateTimeFormatterBuilder.appendSignedDecimal",
	"Comment": "instructs the printer to emit a field value as a decimal number, and theparser to expect a signed decimal number.",
	"Method": "DateTimeFormatterBuilder appendSignedDecimal(DateTimeFieldType fieldType,int minDigits,int maxDigits){\r\n    if (fieldType == null) {\r\n        throw new IllegalArgumentException(\"Field type must not be null\");\r\n    }\r\n    if (maxDigits < minDigits) {\r\n        maxDigits = minDigits;\r\n    }\r\n    if (minDigits < 0 || maxDigits <= 0) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    if (minDigits <= 1) {\r\n        return append0(new UnpaddedNumber(fieldType, maxDigits, true));\r\n    } else {\r\n        return append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));\r\n    }\r\n}"
}, {
	"Path": "com.jayway.jsonpath.Configuration.setEvaluationListeners",
	"Comment": "creates a new configuration with the provided evaluation listeners",
	"Method": "Configuration setEvaluationListeners(EvaluationListener evaluationListener){\r\n    return Configuration.builder().jsonProvider(jsonProvider).mappingProvider(mappingProvider).options(options).evaluationListener(evaluationListener).build();\r\n}"
}, {
	"Path": "org.jooq.codegen.JavaGenerator.generateUDTRecordClassJavadoc",
	"Comment": "subclasses may override this method to provide their own javadoc.",
	"Method": "void generateUDTRecordClassJavadoc(UDTDefinition udt,JavaWriter out){\r\n    if (generateCommentsOnUDTs())\r\n        printClassJavadoc(out, udt);\r\n    else\r\n        printClassJavadoc(out, \"The udt <code>\" + udt.getQualifiedInputName() + \"<\/code>.\");\r\n}"
}, {
	"Path": "org.joda.time.DateTimeFieldType.isSupported",
	"Comment": "checks whether this field supported in the given chronology.",
	"Method": "boolean isSupported(Chronology chronology){\r\n    return getField(chronology).isSupported();\r\n}"
}, {
	"Path": "com.jayway.jsonpath.JsonPath.add",
	"Comment": "adds a new value to the array this path points to in the provided jsonobject",
	"Method": "T add(Object jsonObject,Object value,Configuration configuration){\r\n    notNull(jsonObject, \"json can not be null\");\r\n    notNull(configuration, \"configuration can not be null\");\r\n    EvaluationContext evaluationContext = path.evaluate(jsonObject, jsonObject, configuration, true);\r\n    for (PathRef updateOperation : evaluationContext.updateOperations()) {\r\n        updateOperation.add(value, configuration);\r\n    }\r\n    return resultByConfiguration(jsonObject, configuration, evaluationContext);\r\n}"
}, {
	"Path": "jodd.asm7.Handle.getName",
	"Comment": "returns the name of the field or method designated by this handle.",
	"Method": "String getName(){\r\n    return name;\r\n}"
}, {
	"Path": "jodd.util.BinarySearchBase.findLast",
	"Comment": "finds very last index of given element in inclusive index range. returns negative\tvalue if element is not found.",
	"Method": "int findLast(int low,int high){\r\n    int ndx = -1;\r\n    while (low <= high) {\r\n        int mid = (low + high) >>> 1;\r\n        int delta = compare(mid);\r\n        if (delta > 0) {\r\n            high = mid - 1;\r\n        } else {\r\n            if (delta == 0) {\r\n                ndx = mid;\r\n            }\r\n            low = mid + 1;\r\n        }\r\n    }\r\n    if (ndx == -1) {\r\n        return -(low + 1);\r\n    }\r\n    return ndx;\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Generate.setRecordsImplementingRecordN",
	"Comment": "sets the value of the recordsimplementingrecordn property.",
	"Method": "void setRecordsImplementingRecordN(Boolean value){\r\n    this.recordsImplementingRecordN = value;\r\n}"
}, {
	"Path": "org.joda.time.LocalTime.withFields",
	"Comment": "returns a copy of this time with the partial set of fields replacingthose from this instance.for example, if the partial contains an hour and minute then those twofields will be changed in the returned instance.unsupported fields are ignored.if the partial is null, then this is returned.",
	"Method": "LocalTime withFields(ReadablePartial partial){\r\n    if (partial == null) {\r\n        return this;\r\n    }\r\n    return withLocalMillis(getChronology().set(partial, getLocalMillis()));\r\n}"
}, {
	"Path": "jodd.joy.JoyContextListener.registerInServletContext",
	"Comment": "alternative way for registering joy listeners.\tsometimes servlet container does not allow adding new listener\tfrom already added listener. this method therefore registers\tthe listener before container actually called the\tcallback methods.",
	"Method": "void registerInServletContext(ServletContext servletContext,Class<? extends JoyContextListener> joyContextListenerClass){\r\n    try {\r\n        final JoyContextListener joyContextListener = ClassUtil.newInstance(joyContextListenerClass);\r\n        joyContextListener.createJoyAndInitServletContext(servletContext);\r\n    } catch (Exception e) {\r\n        throw new JoyException(e);\r\n    }\r\n    servletContext.addListener(joyContextListenerClass);\r\n}"
}, {
	"Path": "org.joda.time.LocalDate.year",
	"Comment": "get the year property which provides access to advanced functionality.",
	"Method": "Property year(){\r\n    return new Property(this, getChronology().year());\r\n}"
}, {
	"Path": "org.jooq.conf.Settings.setEmulateOnDuplicateKeyUpdateOnPrimaryKeyOnly",
	"Comment": "sets the value of the emulateonduplicatekeyupdateonprimarykeyonly property.",
	"Method": "void setEmulateOnDuplicateKeyUpdateOnPrimaryKeyOnly(Boolean value){\r\n    this.emulateOnDuplicateKeyUpdateOnPrimaryKeyOnly = value;\r\n}"
}, {
	"Path": "org.joda.time.format.DateTimeParserBucket.saveState",
	"Comment": "saves the state of this bucket, returning it in an opaque object. callrestorestate to undo any changes that were made since the state wassaved. calls to savestate may be nested.",
	"Method": "Object saveState(){\r\n    if (iSavedState == null) {\r\n        iSavedState = new SavedState();\r\n    }\r\n    return iSavedState;\r\n}"
}, {
	"Path": "jodd.petite.scope.SingletonScope.shutdown",
	"Comment": "iterate all beans and invokes registered destroy methods.",
	"Method": "void shutdown(){\r\n    for (final BeanData beanData : instances.values()) {\r\n        beanData.callDestroyMethods();\r\n    }\r\n    instances.clear();\r\n}"
}, {
	"Path": "org.joda.time.base.BasePeriod.setValues",
	"Comment": "sets the values of all fields.in version 2.0 and later, this method copies the array into the original.this is because the instance variable has been changed to be final to satisfy the java memory model.this only impacts subclasses that are mutable.",
	"Method": "void setValues(int[] values){\r\n    System.arraycopy(values, 0, iValues, 0, iValues.length);\r\n}"
}, {
	"Path": "org.joda.time.DateTime.toDateMidnight",
	"Comment": "converts this object to a datemidnight using thesame millis and chronology.",
	"Method": "DateMidnight toDateMidnight(){\r\n    return new DateMidnight(getMillis(), getChronology());\r\n}"
}, {
	"Path": "org.joda.time.DateTimeZone.printOffset",
	"Comment": "formats a timezone offset string.this method is kept separate from the formatting classes to speed andsimplify startup and classloading.",
	"Method": "String printOffset(int offset){\r\n    StringBuffer buf = new StringBuffer();\r\n    if (offset >= 0) {\r\n        buf.append('+');\r\n    } else {\r\n        buf.append('-');\r\n        offset = -offset;\r\n    }\r\n    int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\r\n    FormatUtils.appendPaddedInteger(buf, hours, 2);\r\n    offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\r\n    int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\r\n    buf.append(':');\r\n    FormatUtils.appendPaddedInteger(buf, minutes, 2);\r\n    offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\r\n    if (offset == 0) {\r\n        return buf.toString();\r\n    }\r\n    int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\r\n    buf.append(':');\r\n    FormatUtils.appendPaddedInteger(buf, seconds, 2);\r\n    offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\r\n    if (offset == 0) {\r\n        return buf.toString();\r\n    }\r\n    buf.append('.');\r\n    FormatUtils.appendPaddedInteger(buf, offset, 3);\r\n    return buf.toString();\r\n}"
}, {
	"Path": "jodd.htmlstapler.HtmlStaplerBundlesManager.createBundle",
	"Comment": "creates bundle file by loading resource files content. if bundle file already\texist it will not be recreated!",
	"Method": "void createBundle(String contextPath,String actionPath,String bundleId,List<String> sources){\r\n    File bundleFile = createBundleFile(bundleId);\r\n    if (bundleFile.exists()) {\r\n        return;\r\n    }\r\n    StringBand sb = new StringBand(sources.size() * 2);\r\n    for (String src : sources) {\r\n        if (sb.length() != 0) {\r\n            sb.append(StringPool.NEWLINE);\r\n        }\r\n        String content;\r\n        if (isExternalResource(src)) {\r\n            try {\r\n                content = NetUtil.downloadString(src, localFilesEncoding);\r\n            } catch (IOException ioex) {\r\n                if (notFoundExceptionEnabled) {\r\n                    throw ioex;\r\n                }\r\n                if (log.isWarnEnabled()) {\r\n                    log.warn(\"Download failed: \" + src + \"; \" + ioex.getMessage());\r\n                }\r\n                content = null;\r\n            }\r\n        } else {\r\n            if (!downloadLocal) {\r\n                String localFile = webRoot;\r\n                if (src.startsWith(contextPath + '/')) {\r\n                    src = src.substring(contextPath.length());\r\n                }\r\n                if (src.startsWith(StringPool.SLASH)) {\r\n                    localFile += src;\r\n                } else {\r\n                    localFile += '/' + FileNameUtil.getPathNoEndSeparator(actionPath) + '/' + src;\r\n                }\r\n                int qmndx = localFile.indexOf('?');\r\n                if (qmndx != -1) {\r\n                    localFile = localFile.substring(0, qmndx);\r\n                }\r\n                try {\r\n                    content = FileUtil.readString(localFile);\r\n                } catch (IOException ioex) {\r\n                    if (notFoundExceptionEnabled) {\r\n                        throw ioex;\r\n                    }\r\n                    if (log.isWarnEnabled()) {\r\n                        log.warn(ioex.getMessage());\r\n                    }\r\n                    content = null;\r\n                }\r\n            } else {\r\n                String localUrl = localAddressAndPort;\r\n                if (src.startsWith(StringPool.SLASH)) {\r\n                    localUrl += contextPath + src;\r\n                } else {\r\n                    localUrl += contextPath + FileNameUtil.getPath(actionPath) + '/' + src;\r\n                }\r\n                try {\r\n                    content = NetUtil.downloadString(localUrl, localFilesEncoding);\r\n                } catch (IOException ioex) {\r\n                    if (notFoundExceptionEnabled) {\r\n                        throw ioex;\r\n                    }\r\n                    if (log.isWarnEnabled()) {\r\n                        log.warn(\"Download failed: \" + localUrl + \"; \" + ioex.getMessage());\r\n                    }\r\n                    content = null;\r\n                }\r\n            }\r\n            if (content != null) {\r\n                if (isCssResource(src)) {\r\n                    content = fixCssRelativeUrls(content, src);\r\n                }\r\n            }\r\n        }\r\n        if (content != null) {\r\n            content = onResourceContent(content);\r\n            sb.append(content);\r\n        }\r\n    }\r\n    FileUtil.writeString(bundleFile, sb.toString());\r\n    if (log.isInfoEnabled()) {\r\n        log.info(\"Bundle created: \" + bundleId);\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.chrono.GJDayOfWeekDateTimeField.getAsShortText",
	"Comment": "get the abbreviated textual value of the specified time instant.",
	"Method": "String getAsShortText(int fieldValue,Locale locale){\r\n    return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToShortText(fieldValue);\r\n}"
}, {
	"Path": "org.joda.time.Days.isLessThan",
	"Comment": "is this days instance less than the specified number of days.",
	"Method": "boolean isLessThan(Days other){\r\n    if (other == null) {\r\n        return getValue() < 0;\r\n    }\r\n    return getValue() < other.getValue();\r\n}"
}, {
	"Path": "org.jooq.conf.Settings.setRenderOrderByRownumberForEmulatedPagination",
	"Comment": "sets the value of the renderorderbyrownumberforemulatedpagination property.",
	"Method": "void setRenderOrderByRownumberForEmulatedPagination(Boolean value){\r\n    this.renderOrderByRownumberForEmulatedPagination = value;\r\n}"
}, {
	"Path": "org.apache.jmeter.protocol.ldap.config.gui.PackageTest.testLDAPArgumentCreation",
	"Comment": "test that adding an argument to the table results in an appropriatetestelement being created.",
	"Method": "void testLDAPArgumentCreation(){\r\n    LDAPArgumentsPanel gui = new LDAPArgumentsPanel();\r\n    gui.tableModel.addRow(new LDAPArgument());\r\n    gui.tableModel.setValueAt(\"howdy\", 0, 0);\r\n    gui.tableModel.addRow(new LDAPArgument());\r\n    gui.tableModel.setValueAt(\"doody\", 0, 1);\r\n    assertEquals(\"=\", ((LDAPArgument) ((LDAPArguments) gui.createTestElement()).getArguments().get(0).getObjectValue()).getMetaData());\r\n}"
}, {
	"Path": "org.jooq.codegen.JavaGenerator.generateUDTRecordSetter",
	"Comment": "subclasses may override this method to provide their own record setters.",
	"Method": "void generateUDTRecordSetter(TypedElementDefinition<?> column,int index,JavaWriter out){\r\n    generateRecordSetter0(column, index, out);\r\n}"
}, {
	"Path": "org.joda.time.field.FieldUtils.safeMultiplyToInt",
	"Comment": "multiply two values to return an int throwing an exception if overflow occurs.",
	"Method": "int safeMultiplyToInt(long val1,long val2){\r\n    long val = FieldUtils.safeMultiply(val1, val2);\r\n    return FieldUtils.safeToInt(val);\r\n}"
}, {
	"Path": "jodd.http.HttpRequest.query",
	"Comment": "adds many query parameters at once. although it accepts objects,\teach value will be converted to string.",
	"Method": "HttpRequest query(String name,String value,HttpRequest query,String name1,Object value1,Object parameters,HttpRequest query,Map<String, String> queryMap,HttpMultiMap<String> query){\r\n    return query;\r\n}"
}, {
	"Path": "jodd.util.StringUtil.replaceFirst",
	"Comment": "replaces the very first occurrence of a character in a string.",
	"Method": "String replaceFirst(String s,String sub,String with,String replaceFirst,String s,char sub,char with){\r\n    int index = s.indexOf(sub);\r\n    if (index == -1) {\r\n        return s;\r\n    }\r\n    char[] str = s.toCharArray();\r\n    str[index] = with;\r\n    return new String(str);\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractInterval.toDuration",
	"Comment": "gets the duration of this time interval.the duration is equal to the end millis minus the start millis.",
	"Method": "Duration toDuration(){\r\n    long durMillis = toDurationMillis();\r\n    if (durMillis == 0) {\r\n        return Duration.ZERO;\r\n    } else {\r\n        return new Duration(durMillis);\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractInstant.isBefore",
	"Comment": "is this instant strictly before the instant passed incomparing solely by millisecond.",
	"Method": "boolean isBefore(long instant,boolean isBefore,ReadableInstant instant){\r\n    long instantMillis = DateTimeUtils.getInstantMillis(instant);\r\n    return isBefore(instantMillis);\r\n}"
}, {
	"Path": "jodd.jerry.Jerry.siblings",
	"Comment": "gets the siblings of each element in the set of matched elements.",
	"Method": "Jerry siblings(){\r\n    List<Node> result = new NodeList(nodes.length);\r\n    if (nodes.length > 0) {\r\n        for (Node node : nodes) {\r\n            Node[] allElements = node.getParentNode().getChildElements();\r\n            for (Node sibling : allElements) {\r\n                if (sibling != node) {\r\n                    result.add(sibling);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return new Jerry(this, result);\r\n}"
}, {
	"Path": "org.joda.time.LocalDate.dayOfYear",
	"Comment": "get the day of year property which provides access to advanced functionality.",
	"Method": "Property dayOfYear(){\r\n    return new Property(this, getChronology().dayOfYear());\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Configuration.getLogging",
	"Comment": "the logging configuration element specifies the code generation logging threshold.",
	"Method": "Logging getLogging(){\r\n    return logging;\r\n}"
}, {
	"Path": "jodd.util.CharUtil.toRawByteArray",
	"Comment": "converts char array into byte array by replacing each character with two bytes.",
	"Method": "byte[] toRawByteArray(char[] carr){\r\n    byte[] barr = new byte[carr.length << 1];\r\n    for (int i = 0, bpos = 0; i < carr.length; i++) {\r\n        char c = carr[i];\r\n        barr[bpos++] = (byte) ((c & 0xFF00) >> 8);\r\n        barr[bpos++] = (byte) (c & 0x00FF);\r\n    }\r\n    return barr;\r\n}"
}, {
	"Path": "org.joda.time.TimeOfDay.property",
	"Comment": "gets the property object for the specified type, which containsmany useful methods.",
	"Method": "Property property(DateTimeFieldType type){\r\n    return new Property(this, indexOfSupported(type));\r\n}"
}, {
	"Path": "jodd.jerry.Jerry.prev",
	"Comment": "gets the immediately preceding sibling of each element in the\tset of matched elements.",
	"Method": "Jerry prev(){\r\n    List<Node> result = new NodeList(nodes.length);\r\n    if (nodes.length > 0) {\r\n        for (Node node : nodes) {\r\n            result.add(node.getPreviousSiblingElement());\r\n        }\r\n    }\r\n    return new Jerry(this, result);\r\n}"
}, {
	"Path": "jodd.madvoc.config.Target.readValue",
	"Comment": "reads value from the target. if something goes wrong, exception\tis thrown. we assume that outjection is controlled by developer\tand that each reading of a value must be a successful operation.",
	"Method": "Object readValue(InjectionPoint injectionPoint,Object readValue,String name){\r\n    String propertyName = name;\r\n    if (type != null) {\r\n        final int dotNdx = propertyName.indexOf('.');\r\n        if (dotNdx == -1) {\r\n            return value;\r\n        }\r\n        propertyName = propertyName.substring(dotNdx + 1);\r\n    }\r\n    return BeanUtil.declared.getProperty(value, propertyName);\r\n}"
}, {
	"Path": "jodd.madvoc.WebApp.get",
	"Comment": "returns webapp instance from servlet context.\tmay return null indicating webapp\tis not yet initialized.",
	"Method": "WebApp get(ServletContext servletContext){\r\n    return (WebApp) servletContext.getAttribute(WEBAPP_ATTR);\r\n}"
}, {
	"Path": "org.joda.time.DateTime.millisOfSecond",
	"Comment": "get the millis of second property which provides access to advanced functionality.",
	"Method": "Property millisOfSecond(){\r\n    return new Property(this, getChronology().millisOfSecond());\r\n}"
}, {
	"Path": "jodd.util.StringUtil.indexOfWhitespace",
	"Comment": "returns first index of a whitespace character, starting from specified index offset.",
	"Method": "int indexOfWhitespace(String string,int indexOfWhitespace,String string,int startindex,int indexOfWhitespace,String string,int startindex,int endindex){\r\n    for (int i = startindex; i < endindex; i++) {\r\n        if (CharUtil.isWhitespace(string.charAt(i))) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "jodd.db.oom.sqlgen.TemplateData.findTableDescriptorByColumnRef",
	"Comment": "finds entity descriptor of a table that contains provided column reference.",
	"Method": "DbEntityDescriptor findTableDescriptorByColumnRef(String columnRef){\r\n    for (Map.Entry<String, TableRefData> entry : tableRefs.entrySet()) {\r\n        DbEntityDescriptor ded = entry.getValue().desc;\r\n        if (ded.findByPropertyName(columnRef) != null) {\r\n            return ded;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "jodd.madvoc.result.RawData.downloadableAs",
	"Comment": "defines download file name and mime type from the name extension.",
	"Method": "RawData downloadableAs(String downloadFileName){\r\n    this.downloadFileName = downloadFileName;\r\n    this.mimeType = MimeTypes.getMimeType(FileNameUtil.getExtension(downloadFileName));\r\n    return this;\r\n}"
}, {
	"Path": "org.joda.time.DateTimeUtils.setDefaultTimeZoneNames",
	"Comment": "sets the default map of time zone names.the map is copied before storage.",
	"Method": "void setDefaultTimeZoneNames(Map<String, DateTimeZone> names){\r\n    cZoneNames.set(Collections.unmodifiableMap(new HashMap<String, DateTimeZone>(names)));\r\n}"
}, {
	"Path": "jodd.jerry.Jerry.nextAll",
	"Comment": "get all following siblings of each element in the set of matched \telements, optionally filtered by a selector.",
	"Method": "Jerry nextAll(){\r\n    List<Node> result = new NodeList(nodes.length);\r\n    if (nodes.length > 0) {\r\n        for (Node node : nodes) {\r\n            Node currentSiblingElement = node.getNextSiblingElement();\r\n            while (currentSiblingElement != null) {\r\n                result.add(currentSiblingElement);\r\n                currentSiblingElement = currentSiblingElement.getNextSiblingElement();\r\n            }\r\n        }\r\n    }\r\n    return new Jerry(this, result);\r\n}"
}, {
	"Path": "org.jooq.codegen.JavaGenerator.generateInterfaceClassJavadoc",
	"Comment": "subclasses may override this method to provide their own javadoc.",
	"Method": "void generateInterfaceClassJavadoc(TableDefinition table,JavaWriter out){\r\n    if (generateCommentsOnTables())\r\n        printClassJavadoc(out, table);\r\n    else\r\n        printClassJavadoc(out, \"The table <code>\" + table.getQualifiedInputName() + \"<\/code>.\");\r\n}"
}, {
	"Path": "org.joda.time.DateTimeComparator.compare",
	"Comment": "compare two objects against only the range of date time fields asspecified in the constructor.",
	"Method": "int compare(Object lhsObj,Object rhsObj){\r\n    InstantConverter conv = ConverterManager.getInstance().getInstantConverter(lhsObj);\r\n    Chronology lhsChrono = conv.getChronology(lhsObj, (Chronology) null);\r\n    long lhsMillis = conv.getInstantMillis(lhsObj, lhsChrono);\r\n    if (lhsObj == rhsObj) {\r\n        return 0;\r\n    }\r\n    conv = ConverterManager.getInstance().getInstantConverter(rhsObj);\r\n    Chronology rhsChrono = conv.getChronology(rhsObj, (Chronology) null);\r\n    long rhsMillis = conv.getInstantMillis(rhsObj, rhsChrono);\r\n    if (iLowerLimit != null) {\r\n        lhsMillis = iLowerLimit.getField(lhsChrono).roundFloor(lhsMillis);\r\n        rhsMillis = iLowerLimit.getField(rhsChrono).roundFloor(rhsMillis);\r\n    }\r\n    if (iUpperLimit != null) {\r\n        lhsMillis = iUpperLimit.getField(lhsChrono).remainder(lhsMillis);\r\n        rhsMillis = iUpperLimit.getField(rhsChrono).remainder(rhsMillis);\r\n    }\r\n    if (lhsMillis < rhsMillis) {\r\n        return -1;\r\n    } else if (lhsMillis > rhsMillis) {\r\n        return 1;\r\n    } else {\r\n        return 0;\r\n    }\r\n}"
}, {
	"Path": "jodd.jerry.Jerry.each",
	"Comment": "iterates over a jquery object, executing a function for\teach matched element.",
	"Method": "Jerry each(JerryFunction function){\r\n    for (int i = 0; i < nodes.length; i++) {\r\n        Node node = nodes[i];\r\n        Jerry $this = new Jerry(this, node);\r\n        Boolean result = function.onNode($this, i);\r\n        if (result != null && result == Boolean.FALSE) {\r\n            break;\r\n        }\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.json.JSONObject.append",
	"Comment": "append values to the array under a key. if the key does not exist in thejsonobject, then the key is put in the jsonobject with its value being ajsonarray containing the value parameter. if the key was alreadyassociated with a jsonarray, then the value parameter is appended to it.",
	"Method": "JSONObject append(String key,Object value){\r\n    testValidity(value);\r\n    Object object = this.opt(key);\r\n    if (object == null) {\r\n        this.put(key, new JSONArray().put(value));\r\n    } else if (object instanceof JSONArray) {\r\n        this.put(key, ((JSONArray) object).put(value));\r\n    } else {\r\n        throw new JSONException(\"JSONObject[\" + key + \"] is not a JSONArray.\");\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractPeriod.get",
	"Comment": "gets the value of one of the fields.if the field type specified is not supported by the period then zerois returned.",
	"Method": "int get(DurationFieldType type){\r\n    int index = indexOf(type);\r\n    if (index == -1) {\r\n        return 0;\r\n    }\r\n    return getValue(index);\r\n}"
}, {
	"Path": "org.jooq.impl.ReferenceImpl.extractRows",
	"Comment": "extract a list of row value expressions from a set of records given some fields",
	"Method": "List<RowN> extractRows(Collection<? extends R> records,TableField<R, ?>[] fields){\r\n    List<RowN> rows = new ArrayList<RowN>(records.size());\r\n    for (R record : records) {\r\n        Object[] values = new Object[fields.length];\r\n        for (int i = 0; i < fields.length; i++) values[i] = record.get(fields[i]);\r\n        rows.add(row(values));\r\n    }\r\n    return rows;\r\n}"
}, {
	"Path": "jodd.json.JsonArray.add",
	"Comment": "adds a binary value to the json array.\tjson has no notion of binary so the binary will be base64 encoded to a string, and the string added.",
	"Method": "JsonArray add(Enum value,JsonArray add,CharSequence value,JsonArray add,String value,JsonArray add,Integer value,JsonArray add,Long value,JsonArray add,Double value,JsonArray add,Float value,JsonArray add,Boolean value,JsonArray add,JsonObject value,JsonArray add,JsonArray value,JsonArray add,byte[] value,JsonArray add,Object value){\r\n    Objects.requireNonNull(value);\r\n    value = JsonObject.resolveValue(value);\r\n    list.add(value);\r\n    return this;\r\n}"
}, {
	"Path": "jodd.petite.scope.ProtoScope.accept",
	"Comment": "allows all scopes to be injected into prototype scoped beans.",
	"Method": "boolean accept(Scope referenceScope){\r\n    return true;\r\n}"
}, {
	"Path": "jodd.joy.i18n.I18nInterceptor.getActionClassName",
	"Comment": "returns correct action class name. detects proxetta classes.",
	"Method": "String getActionClassName(Object action){\r\n    Class clazz = action.getClass();\r\n    clazz = ProxettaUtil.resolveTargetClass(clazz);\r\n    return clazz.getName();\r\n}"
}, {
	"Path": "jodd.exception.UncheckedException.callAndWrapException",
	"Comment": "wraps checked exceptions in a uncheckedexception.\tunchecked exceptions are not wrapped.",
	"Method": "V callAndWrapException(Callable<V> callable){\r\n    try {\r\n        return callable.call();\r\n    } catch (IOException ioex) {\r\n        throw new UncheckedIOException(ioex);\r\n    } catch (RuntimeException rtex) {\r\n        throw rtex;\r\n    } catch (Exception t) {\r\n        throw new UncheckedException(t);\r\n    }\r\n}"
}, {
	"Path": "jodd.http.HttpRequest.queryString",
	"Comment": "sets query from provided query string. previous query values\tare discarded.",
	"Method": "HttpRequest queryString(String queryString,HttpRequest queryString,String queryString,boolean decode,String queryString){\r\n    if (query == null) {\r\n        return StringPool.EMPTY;\r\n    }\r\n    return HttpUtil.buildQuery(query, queryEncoding);\r\n}"
}, {
	"Path": "org.joda.time.DateTime.secondOfMinute",
	"Comment": "get the second of minute field property which provides access to advanced functionality.",
	"Method": "Property secondOfMinute(){\r\n    return new Property(this, getChronology().secondOfMinute());\r\n}"
}, {
	"Path": "org.joda.time.Years.yearsIn",
	"Comment": "creates a years representing the number of whole yearsin the specified interval. this method correctly handles any daylightsavings time changes that may occur during the interval.",
	"Method": "Years yearsIn(ReadableInterval interval){\r\n    if (interval == null) {\r\n        return Years.ZERO;\r\n    }\r\n    int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.years());\r\n    return Years.years(amount);\r\n}"
}, {
	"Path": "jodd.util.StringUtil.equals",
	"Comment": "compares 2 strings. if one of the strings is null, false is returned. if\tboth string are null, true is returned.",
	"Method": "boolean equals(String s1,String s2,boolean equals,String[] as,String[] as1){\r\n    if (as.length != as1.length) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < as.length; i++) {\r\n        if (!as[i].equals(as1[i])) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "jodd.util.ClassUtil.findMethod",
	"Comment": "returns method from an object, matched by name. this may be considered as\ta slow operation, since methods are matched one by one.\treturns only accessible methods.\tonly first method is matched.",
	"Method": "Method findMethod(Class c,String methodName){\r\n    return findDeclaredMethod(c, methodName, true);\r\n}"
}, {
	"Path": "org.jooq.impl.DSL.timestampAdd",
	"Comment": "add an interval to a timestamp, given a date part.this translates into any dialect",
	"Method": "Field<Timestamp> timestampAdd(Timestamp timestamp,Number interval,Field<Timestamp> timestampAdd,Field<Timestamp> timestamp,Field<? extends Number> interval,Field<Timestamp> timestampAdd,Timestamp date,Number interval,DatePart datePart,Field<Timestamp> timestampAdd,Timestamp date,Field<? extends Number> interval,DatePart datePart,Field<Timestamp> timestampAdd,Field<Timestamp> date,Number interval,DatePart datePart,Field<Timestamp> timestampAdd,Field<Timestamp> date,Field<? extends Number> interval,DatePart datePart){\r\n    return new DateAdd<Timestamp>(nullSafe(date), nullSafe(interval), datePart);\r\n}"
}, {
	"Path": "jodd.servlet.ServletUtil.readRequestBodyFromStream",
	"Comment": "reads http request body using the request stream. once body is read,\tit cannot be read again!",
	"Method": "String readRequestBodyFromStream(HttpServletRequest request){\r\n    String charEncoding = request.getCharacterEncoding();\r\n    if (charEncoding == null) {\r\n        charEncoding = JoddCore.encoding;\r\n    }\r\n    CharArrayWriter charArrayWriter = new CharArrayWriter();\r\n    BufferedReader bufferedReader = null;\r\n    try {\r\n        InputStream inputStream = request.getInputStream();\r\n        if (inputStream != null) {\r\n            bufferedReader = new BufferedReader(new InputStreamReader(inputStream, charEncoding));\r\n            StreamUtil.copy(bufferedReader, charArrayWriter);\r\n        } else {\r\n            return StringPool.EMPTY;\r\n        }\r\n    } finally {\r\n        StreamUtil.close(bufferedReader);\r\n    }\r\n    return charArrayWriter.toString();\r\n}"
}, {
	"Path": "org.joda.time.YearMonthDay.getFieldTypes",
	"Comment": "gets an array of the field type of each of the fields that this partial supports.the fields are returned largest to smallest, year, month, day",
	"Method": "DateTimeFieldType[] getFieldTypes(){\r\n    return (DateTimeFieldType[]) FIELD_TYPES.clone();\r\n}"
}, {
	"Path": "jodd.io.PathUtil.resolve",
	"Comment": "resolves subpath in safer way. for some reason, if child starts with\ta separator it gets resolved as a full path, ignoring the base.\tthis method acts different.",
	"Method": "Path resolve(Path base,String child,Path resolve,Path path,String childs){\r\n    for (String child : childs) {\r\n        path = resolve(path, child);\r\n    }\r\n    return path;\r\n}"
}, {
	"Path": "jodd.servlet.tag.IteratorTag.setStatus",
	"Comment": "specifies status variable name. if omitted, status will not be used.",
	"Method": "void setStatus(String status){\r\n    this.status = status;\r\n}"
}, {
	"Path": "org.joda.time.MutablePeriod.addSeconds",
	"Comment": "adds the specified seconds to the number of seconds in the period.",
	"Method": "void addSeconds(int seconds){\r\n    super.addField(DurationFieldType.seconds(), seconds);\r\n}"
}, {
	"Path": "org.joda.time.TimeOfDay.minuteOfHour",
	"Comment": "get the minute of hour field property which provides access to advanced functionality.",
	"Method": "Property minuteOfHour(){\r\n    return new Property(this, MINUTE_OF_HOUR);\r\n}"
}, {
	"Path": "jodd.madvoc.Madvoc.get",
	"Comment": "returns madvoc instance from servlet context.\tmay return null indicating madvoc\tis not yet initialized.",
	"Method": "Madvoc get(ServletContext servletContext){\r\n    return (Madvoc) servletContext.getAttribute(MADVOC_ATTR);\r\n}"
}, {
	"Path": "jodd.proxetta.ProxettaFactory.dumpClassInDebugFolder",
	"Comment": "writes created class content to output folder for debugging purposes.",
	"Method": "void dumpClassInDebugFolder(byte[] bytes){\r\n    File debugFolder = proxetta.getDebugFolder();\r\n    if (debugFolder == null) {\r\n        return;\r\n    }\r\n    if (!debugFolder.exists() || !debugFolder.isDirectory()) {\r\n        log.warn(\"Invalid debug folder: \" + debugFolder);\r\n    }\r\n    String fileName = proxyClassName;\r\n    if (fileName == null) {\r\n        fileName = \"proxetta-\" + System.currentTimeMillis();\r\n    }\r\n    fileName += \".class\";\r\n    File file = new File(debugFolder, fileName);\r\n    try {\r\n        FileUtil.writeBytes(file, bytes);\r\n    } catch (IOException ioex) {\r\n        log.warn(\"Error writing class as \" + file, ioex);\r\n    }\r\n}"
}, {
	"Path": "jodd.lagarto.dom.Node.getFirstChildElement",
	"Comment": "returns first child element with given name or\tnull if no such children exist.",
	"Method": "Element getFirstChildElement(Element getFirstChildElement,String elementName){\r\n    if (childNodes == null) {\r\n        return null;\r\n    }\r\n    for (int i = 0, childNodesSize = childNodes.size(); i < childNodesSize; i++) {\r\n        Node child = childNodes.get(i);\r\n        if (child.getNodeType() == NodeType.ELEMENT && elementName.equals(child.getNodeName())) {\r\n            child.initSiblingNames();\r\n            return (Element) child;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Database.setRegexMatchesPartialQualification",
	"Comment": "sets the value of the regexmatchespartialqualification property.",
	"Method": "void setRegexMatchesPartialQualification(Boolean value){\r\n    this.regexMatchesPartialQualification = value;\r\n}"
}, {
	"Path": "com.jayway.jsonpath.Criteria.notEmpty",
	"Comment": "the notempty operator checks that an array or string is not empty.",
	"Method": "Criteria notEmpty(){\r\n    return empty(false);\r\n}"
}, {
	"Path": "org.joda.time.Period.minusWeeks",
	"Comment": "returns a new period minus the specified number of weeks taken away.this period instance is immutable and unaffected by this method call.",
	"Method": "Period minusWeeks(int weeks){\r\n    return plusWeeks(-weeks);\r\n}"
}, {
	"Path": "org.joda.time.Minutes.toStandardHours",
	"Comment": "converts this period in minutes to a period in hours assuming a60 minute hour.this method allows you to convert between different types of period.however to achieve this it makes the assumption that all hours are60 minutes long.this may not be true for some unusual chronologies. however, it is includedas it is a useful operation for many applications and business rules.",
	"Method": "Hours toStandardHours(){\r\n    return Hours.hours(getValue() / DateTimeConstants.MINUTES_PER_HOUR);\r\n}"
}, {
	"Path": "org.joda.time.DateTime.weekyear",
	"Comment": "get the year of a week based year property which provides access to advanced functionality.",
	"Method": "Property weekyear(){\r\n    return new Property(this, getChronology().weekyear());\r\n}"
}, {
	"Path": "org.joda.time.base.BaseDateTime.checkInstant",
	"Comment": "checks the specified instant before storing it, potentially altering it.this method must not access any instance variables.this implementation simply returns the instant.",
	"Method": "long checkInstant(long instant,Chronology chronology){\r\n    return instant;\r\n}"
}, {
	"Path": "jodd.typeconverter.Converter.toInteger",
	"Comment": "converts value to integer. returns default value\twhen conversion result is null",
	"Method": "Integer toInteger(Object value,Integer toInteger,Object value,Integer defaultValue){\r\n    final Integer result = toInteger(value);\r\n    if (result == null) {\r\n        return defaultValue;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.joda.time.Hours.hoursBetween",
	"Comment": "creates a hours representing the number of whole hoursbetween the two specified partial datetimes.the two partials must contain the same fields, for example you can specifytwo localtime objects.",
	"Method": "Hours hoursBetween(ReadableInstant start,ReadableInstant end,Hours hoursBetween,ReadablePartial start,ReadablePartial end){\r\n    if (start instanceof LocalTime && end instanceof LocalTime) {\r\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\r\n        int hours = chrono.hours().getDifference(((LocalTime) end).getLocalMillis(), ((LocalTime) start).getLocalMillis());\r\n        return Hours.hours(hours);\r\n    }\r\n    int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\r\n    return Hours.hours(amount);\r\n}"
}, {
	"Path": "jodd.htmlstapler.HtmlStaplerBundlesManager.createDigest",
	"Comment": "creates digest i.e. bundle id from given string.\treturned digest must be filename safe, for all platforms.",
	"Method": "String createDigest(String source){\r\n    final DigestEngine digestEngine = DigestEngine.sha256();\r\n    final byte[] bytes = digestEngine.digest(CharUtil.toSimpleByteArray(source));\r\n    String digest = Base32.encode(bytes);\r\n    if (uniqueDigestKey != null) {\r\n        digest += uniqueDigestKey;\r\n    }\r\n    return digest;\r\n}"
}, {
	"Path": "org.joda.time.Weeks.isLessThan",
	"Comment": "is this weeks instance less than the specified number of weeks.",
	"Method": "boolean isLessThan(Weeks other){\r\n    if (other == null) {\r\n        return getValue() < 0;\r\n    }\r\n    return getValue() < other.getValue();\r\n}"
}, {
	"Path": "jodd.props.Props.loadSystemProperties",
	"Comment": "loads system properties with given prefix.\tif prefix is null it will not be ignored.",
	"Method": "Props loadSystemProperties(String prefix){\r\n    final Properties environmentProperties = System.getProperties();\r\n    load(environmentProperties, prefix);\r\n    return this;\r\n}"
}, {
	"Path": "org.jooq.SchemaMapping.setSchemaMapping",
	"Comment": "initialise schemamapping. added for better interoperability with spring",
	"Method": "void setSchemaMapping(Map<String, String> schemaMap){\r\n    for (Entry<String, String> entry : schemaMap.entrySet()) {\r\n        add(entry.getKey(), entry.getValue());\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.withDayOfYear",
	"Comment": "returns a copy of this datetime with the day of year field updated.localdatetime is immutable, so there are no set methods.instead, this method returns a new instance with the value ofday of year changed.",
	"Method": "LocalDateTime withDayOfYear(int dayOfYear){\r\n    return withLocalMillis(getChronology().dayOfYear().set(getLocalMillis(), dayOfYear));\r\n}"
}, {
	"Path": "jodd.util.CharSequenceUtil.findFirstDiff",
	"Comment": "finds index of the first character in given array the differs from the\tgiven set of characters.",
	"Method": "int findFirstDiff(CharSequence source,int index,CharSequence match,int findFirstDiff,char[] source,int index,char match){\r\n    for (int i = index; i < source.length; i++) {\r\n        if (source[i] != match) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "jodd.db.oom.DbEntityDescriptor.getIdColumnName",
	"Comment": "returns the identity column name of column marked as identity.\tthrows an exception if table has composite primary key.",
	"Method": "String getIdColumnName(){\r\n    ensureSingleIdColumn();\r\n    return idColumnDescriptors[0].getColumnName();\r\n}"
}, {
	"Path": "jodd.asm7.Frame.setInputFrameFromApiFormat",
	"Comment": "sets the input frame from the given public api frame description.",
	"Method": "void setInputFrameFromApiFormat(SymbolTable symbolTable,int numLocal,Object[] local,int numStack,Object[] stack){\r\n    int inputLocalIndex = 0;\r\n    for (int i = 0; i < numLocal; ++i) {\r\n        inputLocals[inputLocalIndex++] = getAbstractTypeFromApiFormat(symbolTable, local[i]);\r\n        if (local[i] == Opcodes.LONG || local[i] == Opcodes.DOUBLE) {\r\n            inputLocals[inputLocalIndex++] = TOP;\r\n        }\r\n    }\r\n    while (inputLocalIndex < inputLocals.length) {\r\n        inputLocals[inputLocalIndex++] = TOP;\r\n    }\r\n    int numStackTop = 0;\r\n    for (int i = 0; i < numStack; ++i) {\r\n        if (stack[i] == Opcodes.LONG || stack[i] == Opcodes.DOUBLE) {\r\n            ++numStackTop;\r\n        }\r\n    }\r\n    inputStack = new int[numStack + numStackTop];\r\n    int inputStackIndex = 0;\r\n    for (int i = 0; i < numStack; ++i) {\r\n        inputStack[inputStackIndex++] = getAbstractTypeFromApiFormat(symbolTable, stack[i]);\r\n        if (stack[i] == Opcodes.LONG || stack[i] == Opcodes.DOUBLE) {\r\n            inputStack[inputStackIndex++] = TOP;\r\n        }\r\n    }\r\n    outputStackTop = 0;\r\n    initializationCount = 0;\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.withEra",
	"Comment": "returns a copy of this datetime with the era field updated.localdatetime is immutable, so there are no set methods.instead, this method returns a new instance with the value ofera changed.",
	"Method": "LocalDateTime withEra(int era){\r\n    return withLocalMillis(getChronology().era().set(getLocalMillis(), era));\r\n}"
}, {
	"Path": "jodd.decora.parser.DecoraTag.isInsideOtherTagRegion",
	"Comment": "returns true if region of this decora tag\tis inside of region of provided decora tag.",
	"Method": "boolean isInsideOtherTagRegion(DecoraTag decoraTag){\r\n    return (regionStart > decoraTag.getRegionStart()) && (regionStart < decoraTag.getRegionStart() + decoraTag.getRegionLength());\r\n}"
}, {
	"Path": "org.jooq.example.guice.Service.transactional",
	"Comment": "a utility method to allow for nested transactions.all code wrapped by the runnable argument is automaticallyexecuted in a transaction.",
	"Method": "void transactional(Runnable runnable){\r\n    runnable.run();\r\n}"
}, {
	"Path": "jodd.util.Util.containsElement",
	"Comment": "returns true if first argument contains provided element.\tit works for strings, collections, maps and arrays.s",
	"Method": "boolean containsElement(Object obj,Object element){\r\n    if (obj == null) {\r\n        return false;\r\n    }\r\n    if (obj instanceof String) {\r\n        if (element == null) {\r\n            return false;\r\n        }\r\n        return ((String) obj).contains(element.toString());\r\n    }\r\n    if (obj instanceof Collection) {\r\n        return ((Collection) obj).contains(element);\r\n    }\r\n    if (obj instanceof Map) {\r\n        return ((Map) obj).values().contains(element);\r\n    }\r\n    if (obj instanceof Iterator) {\r\n        Iterator iter = (Iterator) obj;\r\n        while (iter.hasNext()) {\r\n            Object o = iter.next();\r\n            if (equals(o, element)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    if (obj instanceof Enumeration) {\r\n        Enumeration enumeration = (Enumeration) obj;\r\n        while (enumeration.hasMoreElements()) {\r\n            Object o = enumeration.nextElement();\r\n            if (equals(o, element)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    if (obj.getClass().isArray()) {\r\n        int len = Array.getLength(obj);\r\n        for (int i = 0; i < len; i++) {\r\n            Object o = Array.get(obj, i);\r\n            if (equals(o, element)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "jodd.io.UnicodeInputStream.close",
	"Comment": "closes input stream. if stream was not used, encoding\twill be unavailable.",
	"Method": "void close(){\r\n    internalInputStream.close();\r\n}"
}, {
	"Path": "org.joda.time.Duration.toStandardHours",
	"Comment": "converts this duration to a period in hours assuming that there are thestandard number of milliseconds in an hour.this method assumes that there are 60 minutes in an hour,60 seconds in a minute and 1000 milliseconds in a second.all currently supplied chronologies use this definition.",
	"Method": "Hours toStandardHours(){\r\n    long hours = getStandardHours();\r\n    return Hours.hours(FieldUtils.safeToInt(hours));\r\n}"
}, {
	"Path": "jodd.introspector.PropertyDescriptor.findField",
	"Comment": "locates property field. field is being searched also in all\tsuperclasses of current class.",
	"Method": "FieldDescriptor findField(String fieldName){\r\n    FieldDescriptor fieldDescriptor = classDescriptor.getFieldDescriptor(fieldName, true);\r\n    if (fieldDescriptor != null) {\r\n        return fieldDescriptor;\r\n    }\r\n    Class[] superclasses = classDescriptor.getAllSuperclasses();\r\n    for (Class superclass : superclasses) {\r\n        ClassDescriptor classDescriptor = ClassIntrospector.get().lookup(superclass);\r\n        fieldDescriptor = classDescriptor.getFieldDescriptor(fieldName, true);\r\n        if (fieldDescriptor != null) {\r\n            return fieldDescriptor;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.joda.time.format.PeriodFormatterBuilder.appendPrefix",
	"Comment": "append a field prefix which applies only to the next appended field. ifthe field is not printed, neither is the prefix.",
	"Method": "PeriodFormatterBuilder appendPrefix(String text,PeriodFormatterBuilder appendPrefix,String singularText,String pluralText,PeriodFormatterBuilder appendPrefix,String[] regularExpressions,String[] prefixes,PeriodFormatterBuilder appendPrefix,PeriodFieldAffix prefix){\r\n    if (prefix == null) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    if (iPrefix != null) {\r\n        prefix = new CompositeAffix(iPrefix, prefix);\r\n    }\r\n    iPrefix = prefix;\r\n    return this;\r\n}"
}, {
	"Path": "org.joda.time.Years.years",
	"Comment": "obtains an instance of years that may be cached.years is immutable, so instances can be cached and shared.this factory method provides access to shared instances.",
	"Method": "Years years(int years){\r\n    switch(years) {\r\n        case 0:\r\n            return ZERO;\r\n        case 1:\r\n            return ONE;\r\n        case 2:\r\n            return TWO;\r\n        case 3:\r\n            return THREE;\r\n        case Integer.MAX_VALUE:\r\n            return MAX_VALUE;\r\n        case Integer.MIN_VALUE:\r\n            return MIN_VALUE;\r\n        default:\r\n            return new Years(years);\r\n    }\r\n}"
}, {
	"Path": "jodd.exception.ExceptionUtil.exceptionChainToString",
	"Comment": "prints full exception stack trace, from top to root cause, into a string.",
	"Method": "String exceptionChainToString(Throwable t){\r\n    StringWriter sw = new StringWriter();\r\n    PrintWriter pw = new PrintWriter(sw, true);\r\n    while (t != null) {\r\n        t.printStackTrace(pw);\r\n        t = t.getCause();\r\n    }\r\n    StreamUtil.close(pw);\r\n    StreamUtil.close(sw);\r\n    return sw.toString();\r\n}"
}, {
	"Path": "com.jayway.jsonpath.internal.function.latebinding.PathLateBindingValue.get",
	"Comment": "evaluate the expression at the point of need for path type expressions",
	"Method": "Object get(){\r\n    return path.evaluate(rootDocument, rootDocument, configuration).getValue();\r\n}"
}, {
	"Path": "com.jayway.jsonpath.JsonPath.delete",
	"Comment": "deletes the object this path points to in the provided jsonobject",
	"Method": "T delete(Object jsonObject,Configuration configuration){\r\n    notNull(jsonObject, \"json can not be null\");\r\n    notNull(configuration, \"configuration can not be null\");\r\n    EvaluationContext evaluationContext = path.evaluate(jsonObject, jsonObject, configuration, true);\r\n    for (PathRef updateOperation : evaluationContext.updateOperations()) {\r\n        updateOperation.delete(configuration);\r\n    }\r\n    return resultByConfiguration(jsonObject, configuration, evaluationContext);\r\n}"
}, {
	"Path": "org.apache.jmeter.resources.TestPropertiesFiles.testDefaultProperties",
	"Comment": "the keys in jmeter.properties and reportgenerator.properties should be distinct",
	"Method": "void testDefaultProperties(){\r\n    Properties jmeter = loadProps(new File(JMeterUtils.getJMeterBinDir(), \"jmeter.properties\"));\r\n    Properties report = loadProps(new File(JMeterUtils.getJMeterBinDir(), \"reportgenerator.properties\"));\r\n    Enumeration<?> jmeterNames = jmeter.propertyNames();\r\n    while (jmeterNames.hasMoreElements()) {\r\n        final Object key = jmeterNames.nextElement();\r\n        assertFalse(\"reportgenerator should not contain the jmeter key \" + key, report.containsKey(key));\r\n    }\r\n    Enumeration<?> reportNames = report.propertyNames();\r\n    while (reportNames.hasMoreElements()) {\r\n        final Object key = reportNames.nextElement();\r\n        assertFalse(\"jmeter should not contain the reportgenerator key \" + key, jmeter.containsKey(key));\r\n    }\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.video.VideoQuality.determineClosestSupportedResolution",
	"Comment": "checks if the requested resolution is supported by the camera.\tif not, it modifies it by supported parameters.",
	"Method": "VideoQuality determineClosestSupportedResolution(Camera.Parameters parameters,VideoQuality quality){\r\n    VideoQuality v = quality.clone();\r\n    int minDist = Integer.MAX_VALUE;\r\n    String supportedSizesStr = \"Supported resolutions: \";\r\n    List<Size> supportedSizes = parameters.getSupportedPreviewSizes();\r\n    for (Iterator<Size> it = supportedSizes.iterator(); it.hasNext(); ) {\r\n        Size size = it.next();\r\n        supportedSizesStr += size.width + \"x\" + size.height + (it.hasNext() ? \", \" : \"\");\r\n        int dist = Math.abs(quality.resX - size.width);\r\n        if (dist < minDist) {\r\n            minDist = dist;\r\n            v.resX = size.width;\r\n            v.resY = size.height;\r\n        }\r\n    }\r\n    Log.v(TAG, supportedSizesStr);\r\n    if (quality.resX != v.resX || quality.resY != v.resY) {\r\n        Log.v(TAG, \"Resolution modified: \" + quality.resX + \"x\" + quality.resY + \"->\" + v.resX + \"x\" + v.resY);\r\n    }\r\n    return v;\r\n}"
}, {
	"Path": "org.joda.time.format.DateTimeFormatterBuilder.appendSecondOfMinute",
	"Comment": "instructs the printer to emit a numeric secondofminute field.",
	"Method": "DateTimeFormatterBuilder appendSecondOfMinute(int minDigits){\r\n    return appendDecimal(DateTimeFieldType.secondOfMinute(), minDigits, 2);\r\n}"
}, {
	"Path": "org.json.CDL.rowToString",
	"Comment": "produce a comma delimited text row from a jsonarray. values containingthe comma character will be quoted. troublesome characters may beremoved.",
	"Method": "String rowToString(JSONArray ja){\r\n    StringBuilder sb = new StringBuilder();\r\n    for (int i = 0; i < ja.length(); i += 1) {\r\n        if (i > 0) {\r\n            sb.append(',');\r\n        }\r\n        Object object = ja.opt(i);\r\n        if (object != null) {\r\n            String string = object.toString();\r\n            if (string.length() > 0 && (string.indexOf(',') >= 0 || string.indexOf('\\n') >= 0 || string.indexOf('\\r') >= 0 || string.indexOf(0) >= 0 || string.charAt(0) == '\"')) {\r\n                sb.append('\"');\r\n                int length = string.length();\r\n                for (int j = 0; j < length; j += 1) {\r\n                    char c = string.charAt(j);\r\n                    if (c >= ' ' && c != '\"') {\r\n                        sb.append(c);\r\n                    }\r\n                }\r\n                sb.append('\"');\r\n            } else {\r\n                sb.append(string);\r\n            }\r\n        }\r\n    }\r\n    sb.append('\\n');\r\n    return sb.toString();\r\n}"
}, {
	"Path": "jodd.asm7.Type.getClassName",
	"Comment": "returns the binary name of the class corresponding to this type. this method must not be usedon method types.",
	"Method": "String getClassName(){\r\n    switch(sort) {\r\n        case VOID:\r\n            return \"void\";\r\n        case BOOLEAN:\r\n            return \"boolean\";\r\n        case CHAR:\r\n            return \"char\";\r\n        case BYTE:\r\n            return \"byte\";\r\n        case SHORT:\r\n            return \"short\";\r\n        case INT:\r\n            return \"int\";\r\n        case FLOAT:\r\n            return \"float\";\r\n        case LONG:\r\n            return \"long\";\r\n        case DOUBLE:\r\n            return \"double\";\r\n        case ARRAY:\r\n            StringBuilder stringBuilder = new StringBuilder(getElementType().getClassName());\r\n            for (int i = getDimensions(); i > 0; --i) {\r\n                stringBuilder.append(\"[]\");\r\n            }\r\n            return stringBuilder.toString();\r\n        case OBJECT:\r\n        case INTERNAL:\r\n            return valueBuffer.substring(valueBegin, valueEnd).replace('/', '.');\r\n        default:\r\n            throw new AssertionError();\r\n    }\r\n}"
}, {
	"Path": "jodd.jtx.JtxTransactionManager.isAssociatedWithThread",
	"Comment": "returns true if provided transaction\tis associated with current thread.",
	"Method": "boolean isAssociatedWithThread(JtxTransaction tx){\r\n    ArrayList<JtxTransaction> txList = txStack.get();\r\n    if (txList == null) {\r\n        return false;\r\n    }\r\n    return txList.contains(tx);\r\n}"
}, {
	"Path": "org.joda.time.DateTimeZone.convertLocalToUTC",
	"Comment": "converts a local instant to a standard utc instant with the samelocal time. this conversion is used after performing a calculationwhere the calculation was done using a simple local zone.",
	"Method": "long convertLocalToUTC(long instantLocal,boolean strict,long originalInstantUTC,long convertLocalToUTC,long instantLocal,boolean strict){\r\n    int offsetLocal = getOffset(instantLocal);\r\n    int offset = getOffset(instantLocal - offsetLocal);\r\n    if (offsetLocal != offset) {\r\n        if (strict || offsetLocal < 0) {\r\n            long nextLocal = nextTransition(instantLocal - offsetLocal);\r\n            if (nextLocal == (instantLocal - offsetLocal)) {\r\n                nextLocal = Long.MAX_VALUE;\r\n            }\r\n            long nextAdjusted = nextTransition(instantLocal - offset);\r\n            if (nextAdjusted == (instantLocal - offset)) {\r\n                nextAdjusted = Long.MAX_VALUE;\r\n            }\r\n            if (nextLocal != nextAdjusted) {\r\n                if (strict) {\r\n                    throw new IllegalInstantException(instantLocal, getID());\r\n                } else {\r\n                    offset = offsetLocal;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    long instantUTC = instantLocal - offset;\r\n    if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) {\r\n        throw new ArithmeticException(\"Subtracting time zone offset caused overflow\");\r\n    }\r\n    return instantUTC;\r\n}"
}, {
	"Path": "org.joda.time.Period.withFields",
	"Comment": "creates a new period instance with the fields from the specified periodcopied on top of those from this period.this period instance is immutable and unaffected by this method call.",
	"Method": "Period withFields(ReadablePeriod period){\r\n    if (period == null) {\r\n        return this;\r\n    }\r\n    int[] newValues = getValues();\r\n    newValues = super.mergePeriodInto(newValues, period);\r\n    return new Period(newValues, getPeriodType());\r\n}"
}, {
	"Path": "org.joda.time.TimeOfDay.toDateTimeToday",
	"Comment": "converts this partial to a full datetime using the specified time zonesetting the time fields from this instance and the date fields fromthe current time.this method uses the chronology from this instance plus the time zonespecified.",
	"Method": "DateTime toDateTimeToday(DateTime toDateTimeToday,DateTimeZone zone){\r\n    Chronology chrono = getChronology().withZone(zone);\r\n    long instantMillis = DateTimeUtils.currentTimeMillis();\r\n    long resolved = chrono.set(this, instantMillis);\r\n    return new DateTime(resolved, chrono);\r\n}"
}, {
	"Path": "org.joda.time.base.BaseSingleFieldPeriod.between",
	"Comment": "calculates the number of whole units between the two specified partial datetimes.the two partials must contain the same fields, for example you can specifytwo localdate objects.",
	"Method": "int between(ReadableInstant start,ReadableInstant end,DurationFieldType field,int between,ReadablePartial start,ReadablePartial end,ReadablePeriod zeroInstance){\r\n    if (start == null || end == null) {\r\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\r\n    }\r\n    if (start.size() != end.size()) {\r\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\r\n    }\r\n    for (int i = 0, isize = start.size(); i < isize; i++) {\r\n        if (start.getFieldType(i) != end.getFieldType(i)) {\r\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\r\n        }\r\n    }\r\n    if (DateTimeUtils.isContiguous(start) == false) {\r\n        throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\r\n    }\r\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\r\n    int[] values = chrono.get(zeroInstance, chrono.set(start, START_1972), chrono.set(end, START_1972));\r\n    return values[0];\r\n}"
}, {
	"Path": "org.joda.time.field.PreciseDurationField.equals",
	"Comment": "compares this duration field to another.two fields are equal if of the same type and duration.",
	"Method": "boolean equals(Object obj){\r\n    if (this == obj) {\r\n        return true;\r\n    } else if (obj instanceof PreciseDurationField) {\r\n        PreciseDurationField other = (PreciseDurationField) obj;\r\n        return (getType() == other.getType()) && (iUnitMillis == other.iUnitMillis);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractInterval.isEqual",
	"Comment": "is this interval equal to the specified interval ignoring the chronology.this compares the underlying instants, ignoring the chronology.",
	"Method": "boolean isEqual(ReadableInterval other){\r\n    return getStartMillis() == other.getStartMillis() && getEndMillis() == other.getEndMillis();\r\n}"
}, {
	"Path": "org.joda.time.DateTime.toDateTimeISO",
	"Comment": "get this object as a datetime using isochronology in the default zone,returning this if possible.",
	"Method": "DateTime toDateTimeISO(){\r\n    if (getChronology() == ISOChronology.getInstance()) {\r\n        return this;\r\n    }\r\n    return super.toDateTimeISO();\r\n}"
}, {
	"Path": "jodd.introspector.FieldDescriptor.getRawKeyComponentType",
	"Comment": "returns fields raw component type. returns null\tif field has no component type.",
	"Method": "Class getRawKeyComponentType(){\r\n    return rawKeyComponentType;\r\n}"
}, {
	"Path": "org.joda.time.Days.days",
	"Comment": "obtains an instance of days that may be cached.days is immutable, so instances can be cached and shared.this factory method provides access to shared instances.",
	"Method": "Days days(int days){\r\n    switch(days) {\r\n        case 0:\r\n            return ZERO;\r\n        case 1:\r\n            return ONE;\r\n        case 2:\r\n            return TWO;\r\n        case 3:\r\n            return THREE;\r\n        case 4:\r\n            return FOUR;\r\n        case 5:\r\n            return FIVE;\r\n        case 6:\r\n            return SIX;\r\n        case 7:\r\n            return SEVEN;\r\n        case Integer.MAX_VALUE:\r\n            return MAX_VALUE;\r\n        case Integer.MIN_VALUE:\r\n            return MIN_VALUE;\r\n        default:\r\n            return new Days(days);\r\n    }\r\n}"
}, {
	"Path": "jodd.asm7.ClassWriter.getCommonSuperClass",
	"Comment": "returns the common super type of the two given types. the default implementation of this methodloads the two given classes and uses the java.lang.class methods to find the commonsuper class. it can be overridden to compute this common super type in other ways, inparticular without actually loading any class, or to take into account the class that iscurrently being generated by this classwriter, which can of course not be loaded since it isunder construction.",
	"Method": "String getCommonSuperClass(String type1,String type2){\r\n    ClassLoader classLoader = getClassLoader();\r\n    Class<?> class1;\r\n    try {\r\n        class1 = Class.forName(type1.replace('/', '.'), false, classLoader);\r\n    } catch (ClassNotFoundException e) {\r\n        throw new TypeNotPresentException(type1, e);\r\n    }\r\n    Class<?> class2;\r\n    try {\r\n        class2 = Class.forName(type2.replace('/', '.'), false, classLoader);\r\n    } catch (ClassNotFoundException e) {\r\n        throw new TypeNotPresentException(type2, e);\r\n    }\r\n    if (class1.isAssignableFrom(class2)) {\r\n        return type1;\r\n    }\r\n    if (class2.isAssignableFrom(class1)) {\r\n        return type2;\r\n    }\r\n    if (class1.isInterface() || class2.isInterface()) {\r\n        return \"java/lang/Object\";\r\n    } else {\r\n        do {\r\n            class1 = class1.getSuperclass();\r\n        } while (!class1.isAssignableFrom(class2));\r\n        return class1.getName().replace('.', '/');\r\n    }\r\n}"
}, {
	"Path": "jodd.madvoc.ActionRequest.invoke",
	"Comment": "invokes the action and returns action result value object.\tinvokes all interceptors before and after action invocation.",
	"Method": "Object invoke(){\r\n    return executionArray[executionIndex++].apply(this);\r\n}"
}, {
	"Path": "org.jooq.impl.AbstractBindContext.bindInternal",
	"Comment": "subclasses may override this method to achieve different behaviour",
	"Method": "void bindInternal(QueryPartInternal internal){\r\n    internal.accept(this);\r\n}"
}, {
	"Path": "jodd.htmlstapler.HtmlStaplerBundlesManager.isDownloadLocal",
	"Comment": "returns true if local resource files are downloaded\tand not loaded from file system.",
	"Method": "boolean isDownloadLocal(){\r\n    return downloadLocal;\r\n}"
}, {
	"Path": "org.joda.time.DateMidnight.dayOfMonth",
	"Comment": "get the day of month property which provides access to advanced functionality.",
	"Method": "Property dayOfMonth(){\r\n    return new Property(this, getChronology().dayOfMonth());\r\n}"
}, {
	"Path": "jodd.madvoc.interceptor.EchoInterceptor.out",
	"Comment": "outputs info message. by default, it outputs it to console.",
	"Method": "void out(String message){\r\n    System.out.println(message);\r\n}"
}, {
	"Path": "org.joda.time.LocalDate.withDayOfYear",
	"Comment": "returns a copy of this date with the day of year field updated.localdate is immutable, so there are no set methods.instead, this method returns a new instance with the value ofday of year changed.",
	"Method": "LocalDate withDayOfYear(int dayOfYear){\r\n    return withLocalMillis(getChronology().dayOfYear().set(getLocalMillis(), dayOfYear));\r\n}"
}, {
	"Path": "org.joda.time.MonthDay.fromDateFields",
	"Comment": "constructs a monthday from a java.util.dateusing exactly the same field values avoiding any time zone effects.each field is queried from the date and assigned to the monthday.this factory method always creates a monthday with iso chronology.",
	"Method": "MonthDay fromDateFields(Date date){\r\n    if (date == null) {\r\n        throw new IllegalArgumentException(\"The date must not be null\");\r\n    }\r\n    return new MonthDay(date.getMonth() + 1, date.getDate());\r\n}"
}, {
	"Path": "org.joda.time.Period.negated",
	"Comment": "returns a new instance with each amount in this period negated.",
	"Method": "Period negated(){\r\n    return multipliedBy(-1);\r\n}"
}, {
	"Path": "org.joda.time.LocalDate.isSupported",
	"Comment": "checks if the duration type specified is supported by thislocal date and chronology.",
	"Method": "boolean isSupported(DateTimeFieldType type,boolean isSupported,DurationFieldType type){\r\n    if (type == null) {\r\n        return false;\r\n    }\r\n    DurationField field = type.getField(getChronology());\r\n    if (DATE_DURATION_TYPES.contains(type) || field.getUnitMillis() >= getChronology().days().getUnitMillis()) {\r\n        return field.isSupported();\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.jooq.codegen.JavaGenerator.generateUDTInterfaceSetter",
	"Comment": "subclasses may override this method to provide their own interface setters.",
	"Method": "void generateUDTInterfaceSetter(TypedElementDefinition<?> column,int index,JavaWriter out){\r\n    generateInterfaceSetter0(column, index, out);\r\n}"
}, {
	"Path": "org.joda.time.format.PeriodFormatterBuilder.clear",
	"Comment": "clears out all the appended elements, allowing this builder to be reused.",
	"Method": "void clear(){\r\n    iMinPrintedDigits = 1;\r\n    iPrintZeroSetting = PRINT_ZERO_RARELY_LAST;\r\n    iMaxParsedDigits = 10;\r\n    iRejectSignedValues = false;\r\n    iPrefix = null;\r\n    if (iElementPairs == null) {\r\n        iElementPairs = new ArrayList<Object>();\r\n    } else {\r\n        iElementPairs.clear();\r\n    }\r\n    iNotPrinter = false;\r\n    iNotParser = false;\r\n    iFieldFormatters = new FieldFormatter[10];\r\n}"
}, {
	"Path": "jodd.asm7.MethodVisitor.visitJumpInsn",
	"Comment": "visits a jump instruction. a jump instruction is an instruction that may jump to anotherinstruction.",
	"Method": "void visitJumpInsn(int opcode,Label label){\r\n    if (mv != null) {\r\n        mv.visitJumpInsn(opcode, label);\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.Days.minus",
	"Comment": "returns a new instance with the specified number of days taken away.this instance is immutable and unaffected by this method call.",
	"Method": "Days minus(int days,Days minus,Days days){\r\n    if (days == null) {\r\n        return this;\r\n    }\r\n    return minus(days.getValue());\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.yearOfEra",
	"Comment": "get the year of era property which provides access to advanced functionality.",
	"Method": "Property yearOfEra(){\r\n    return new Property(this, getChronology().yearOfEra());\r\n}"
}, {
	"Path": "org.joda.time.Weeks.standardWeeksIn",
	"Comment": "creates a new weeks representing the number of completestandard length weeks in the specified period.this factory method converts all fields from the period to hours using standardiseddurations for each field. only those fields which have a precise duration inthe iso utc chronology can be converted.one week consists of 7 days.one day consists of 24 hours.one hour consists of 60 minutes.one minute consists of 60 weeks.one second consists of 1000 milliseconds.months and years are imprecise and periods containing these values cannot be converted.",
	"Method": "Weeks standardWeeksIn(ReadablePeriod period){\r\n    int amount = BaseSingleFieldPeriod.standardPeriodIn(period, DateTimeConstants.MILLIS_PER_WEEK);\r\n    return Weeks.weeks(amount);\r\n}"
}, {
	"Path": "org.joda.time.Period.toStandardWeeks",
	"Comment": "converts this period to a period in weeks assuming a7 day week, 24 hour day, 60 minute hour and 60 second minute.this method allows you to convert between different types of period.however to achieve this it makes the assumption that allweeks are 7 days, all days are 24 hours, all hours are 60 minutes andall minutes are 60 seconds. this is not true when daylight savings timeis considered, and may also not be true for some unusual chronologies.however, it is included as it is a useful operation for manyapplications and business rules.if the period contains years or months, an exception will be thrown.",
	"Method": "Weeks toStandardWeeks(){\r\n    checkYearsAndMonths(\"Weeks\");\r\n    long millis = getMillis();\r\n    millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;\r\n    millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE;\r\n    millis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR;\r\n    millis += ((long) getDays()) * DateTimeConstants.MILLIS_PER_DAY;\r\n    long weeks = ((long) getWeeks()) + millis / DateTimeConstants.MILLIS_PER_WEEK;\r\n    return Weeks.weeks(FieldUtils.safeToInt(weeks));\r\n}"
}, {
	"Path": "org.joda.time.DateTime.dayOfMonth",
	"Comment": "get the day of month property which provides access to advanced functionality.",
	"Method": "Property dayOfMonth(){\r\n    return new Property(this, getChronology().dayOfMonth());\r\n}"
}, {
	"Path": "jodd.servlet.SessionMonitor.sessionCreated",
	"Comment": "stores session in map and broadcasts event to registered listeners.",
	"Method": "void sessionCreated(HttpSessionEvent httpSessionEvent){\r\n    HttpSession session = httpSessionEvent.getSession();\r\n    sessionMap.putIfAbsent(session.getId(), session);\r\n    for (HttpSessionListener listener : listeners) {\r\n        listener.sessionCreated(httpSessionEvent);\r\n    }\r\n}"
}, {
	"Path": "jodd.decora.parser.DecoraTag.getDefaultValueLength",
	"Comment": "returns the length of decora default value if exist.\treturns 0 if default value is not specified.",
	"Method": "int getDefaultValueLength(){\r\n    return defaultValueLength;\r\n}"
}, {
	"Path": "jodd.servlet.DispatcherUtil.forward",
	"Comment": "forward to page which path is relative to the current http request.",
	"Method": "boolean forward(ServletRequest request,ServletResponse response,String page){\r\n    RequestDispatcher dispatcher = request.getRequestDispatcher(page);\r\n    if (dispatcher != null) {\r\n        dispatcher.forward(request, response);\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "jodd.json.JsonParser.skipObject",
	"Comment": "skips over complete object. it is not parsed, just skipped. it will be\tparsed later, but oonly if required.",
	"Method": "void skipObject(){\r\n    int bracketCount = 1;\r\n    boolean insideString = false;\r\n    while (ndx < total) {\r\n        final char c = input[ndx];\r\n        if (insideString) {\r\n            if (c == '\\\"' && (ndx == 0 || input[ndx - 1] != '\\\\')) {\r\n                insideString = false;\r\n            }\r\n        } else {\r\n            if (c == '\\\"') {\r\n                insideString = true;\r\n            }\r\n            if (c == '{') {\r\n                bracketCount++;\r\n            } else if (c == '}') {\r\n                bracketCount--;\r\n                if (bracketCount == 0) {\r\n                    ndx++;\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        ndx++;\r\n    }\r\n}"
}, {
	"Path": "jodd.asm7.ClassReader.readBootstrapMethodsAttribute",
	"Comment": "reads the bootstrapmethods attribute to compute the offset of each bootstrap method.",
	"Method": "int[] readBootstrapMethodsAttribute(int maxStringLength){\r\n    char[] charBuffer = new char[maxStringLength];\r\n    int currentAttributeOffset = getFirstAttributeOffset();\r\n    int[] currentBootstrapMethodOffsets = null;\r\n    for (int i = readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) {\r\n        String attributeName = readUTF8(currentAttributeOffset, charBuffer);\r\n        int attributeLength = readInt(currentAttributeOffset + 2);\r\n        currentAttributeOffset += 6;\r\n        if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {\r\n            currentBootstrapMethodOffsets = new int[readUnsignedShort(currentAttributeOffset)];\r\n            int currentBootstrapMethodOffset = currentAttributeOffset + 2;\r\n            for (int j = 0; j < currentBootstrapMethodOffsets.length; ++j) {\r\n                currentBootstrapMethodOffsets[j] = currentBootstrapMethodOffset;\r\n                currentBootstrapMethodOffset += 4 + readUnsignedShort(currentBootstrapMethodOffset + 2) * 2;\r\n            }\r\n            return currentBootstrapMethodOffsets;\r\n        }\r\n        currentAttributeOffset += attributeLength;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "jodd.vtor.Vtor.resetProfiles",
	"Comment": "reset profiles by clearing all enabled profiles\tand setting to default state.",
	"Method": "void resetProfiles(){\r\n    enabledProfiles = null;\r\n}"
}, {
	"Path": "jodd.util.annotation.AnnotationParser.hasAnnotationOn",
	"Comment": "returns true if annotation is present on\tgiven annotated element. should be called first, before using the read methods.",
	"Method": "boolean hasAnnotationOn(AnnotatedElement annotatedElement){\r\n    return annotatedElement.isAnnotationPresent(annotationClass);\r\n}"
}, {
	"Path": "org.joda.time.tz.CachedDateTimeZone.forZone",
	"Comment": "returns a new cacheddatetimezone unless given zone is already cached.",
	"Method": "CachedDateTimeZone forZone(DateTimeZone zone){\r\n    if (zone instanceof CachedDateTimeZone) {\r\n        return (CachedDateTimeZone) zone;\r\n    }\r\n    return new CachedDateTimeZone(zone);\r\n}"
}, {
	"Path": "jodd.petite.PetiteConfig.setLookupReferences",
	"Comment": "specifies references for bean name lookup, when name\tis not specified, in given order.",
	"Method": "PetiteConfig setLookupReferences(PetiteReferenceType lookupReferences){\r\n    this.lookupReferences = lookupReferences;\r\n    return this;\r\n}"
}, {
	"Path": "jodd.asm7.ClassVisitor.visitInnerClass",
	"Comment": "visits information about an inner class. this inner class is not necessarily a member of theclass being visited.",
	"Method": "void visitInnerClass(String name,String outerName,String innerName,int access){\r\n    if (cv != null) {\r\n        cv.visitInnerClass(name, outerName, innerName, access);\r\n    }\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.MatcherRule.getExpression",
	"Comment": "a replacement expression that transforms the matched expression in a new value.",
	"Method": "String getExpression(){\r\n    return expression;\r\n}"
}, {
	"Path": "org.joda.time.IllegalFieldValueException.getUpperBound",
	"Comment": "returns the upper bound of the legal value range, or null if not applicable.",
	"Method": "Number getUpperBound(){\r\n    return iUpperBound;\r\n}"
}, {
	"Path": "jodd.csselly.selector.PseudoClassSelector.accept",
	"Comment": "accepts node within selected results. invoked after results are matched.",
	"Method": "boolean accept(Node node,boolean accept,List<Node> currentResults,Node node,int index){\r\n    return pseudoClass.match(currentResults, node, index);\r\n}"
}, {
	"Path": "org.joda.time.TimeOfDay.fromMillisOfDay",
	"Comment": "constructs a timeofday from the specified millis of day using thespecified chronology.the millisofday value may exceed the number of millis in one day,but additional days will be ignored.this method uses the utc time zone internally.",
	"Method": "TimeOfDay fromMillisOfDay(long millisOfDay,TimeOfDay fromMillisOfDay,long millisOfDay,Chronology chrono){\r\n    chrono = DateTimeUtils.getChronology(chrono);\r\n    chrono = chrono.withUTC();\r\n    return new TimeOfDay(millisOfDay, chrono);\r\n}"
}, {
	"Path": "org.joda.time.PeriodType.equals",
	"Comment": "compares this type to another object.to be equal, the object must be a periodtype with the same set of fields.",
	"Method": "boolean equals(Object obj){\r\n    if (this == obj) {\r\n        return true;\r\n    }\r\n    if (obj instanceof PeriodType == false) {\r\n        return false;\r\n    }\r\n    PeriodType other = (PeriodType) obj;\r\n    return (Arrays.equals(iTypes, other.iTypes));\r\n}"
}, {
	"Path": "org.joda.time.Years.plus",
	"Comment": "returns a new instance with the specified number of years added.this instance is immutable and unaffected by this method call.",
	"Method": "Years plus(int years,Years plus,Years years){\r\n    if (years == null) {\r\n        return this;\r\n    }\r\n    return plus(years.getValue());\r\n}"
}, {
	"Path": "jodd.props.Props.innerMap",
	"Comment": "returns inner map from the props with given prefix. keys in returned map\twill not have the prefix.",
	"Method": "Map<String, Object> innerMap(String prefix){\r\n    initialize();\r\n    return data.extract(null, activeProfiles, null, prefix);\r\n}"
}, {
	"Path": "jodd.util.ClassLoaderUtil.getResourceAsStream",
	"Comment": "opens a resource of the specified name for reading. controls caching,\tthat is important when the same jar is reloaded using custom classloader.",
	"Method": "InputStream getResourceAsStream(String resourceName,InputStream getResourceAsStream,String resourceName,ClassLoader callingClass,InputStream getResourceAsStream,String resourceName,ClassLoader callingClass,boolean useCache){\r\n    URL url = getResourceUrl(resourceName, callingClass);\r\n    if (url != null) {\r\n        URLConnection urlConnection = url.openConnection();\r\n        urlConnection.setUseCaches(useCache);\r\n        return urlConnection.getInputStream();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractInterval.isAfter",
	"Comment": "is this time interval entirely after the specified interval.intervals are inclusive of the start instant and exclusive of the end.only the end time of the specified interval is used in the comparison.",
	"Method": "boolean isAfter(long millisInstant,boolean isAfter,ReadableInstant instant,boolean isAfter,ReadableInterval interval){\r\n    long endMillis;\r\n    if (interval == null) {\r\n        endMillis = DateTimeUtils.currentTimeMillis();\r\n    } else {\r\n        endMillis = interval.getEndMillis();\r\n    }\r\n    return (getStartMillis() >= endMillis);\r\n}"
}, {
	"Path": "org.joda.time.convert.ConverterSet.add",
	"Comment": "returns a copy of this set, with the given converter added. if amatching converter is already in the set, the given converter replacesit. if the converter is exactly the same as one already in the set, theoriginal set is returned.",
	"Method": "ConverterSet add(Converter converter,Converter[] removed){\r\n    Converter[] converters = iConverters;\r\n    int length = converters.length;\r\n    for (int i = 0; i < length; i++) {\r\n        Converter existing = converters[i];\r\n        if (converter.equals(existing)) {\r\n            if (removed != null) {\r\n                removed[0] = null;\r\n            }\r\n            return this;\r\n        }\r\n        if (converter.getSupportedType() == existing.getSupportedType()) {\r\n            Converter[] copy = new Converter[length];\r\n            for (int j = 0; j < length; j++) {\r\n                if (j != i) {\r\n                    copy[j] = converters[j];\r\n                } else {\r\n                    copy[j] = converter;\r\n                }\r\n            }\r\n            if (removed != null) {\r\n                removed[0] = existing;\r\n            }\r\n            return new ConverterSet(copy);\r\n        }\r\n    }\r\n    Converter[] copy = new Converter[length + 1];\r\n    System.arraycopy(converters, 0, copy, 0, length);\r\n    copy[length] = converter;\r\n    if (removed != null) {\r\n        removed[0] = null;\r\n    }\r\n    return new ConverterSet(copy);\r\n}"
}, {
	"Path": "jodd.jtx.JtxTransactionManager.getTransaction",
	"Comment": "returns last transaction associated with current thread or\tnull when thread has no associated transactions created\tby this transaction manager.",
	"Method": "JtxTransaction getTransaction(){\r\n    ArrayList<JtxTransaction> txlist = txStack.get();\r\n    if (txlist == null) {\r\n        return null;\r\n    }\r\n    if (txlist.isEmpty()) {\r\n        return null;\r\n    }\r\n    return txlist.get(txlist.size() - 1);\r\n}"
}, {
	"Path": "org.joda.time.Seconds.plus",
	"Comment": "returns a new instance with the specified number of seconds added.this instance is immutable and unaffected by this method call.",
	"Method": "Seconds plus(int seconds,Seconds plus,Seconds seconds){\r\n    if (seconds == null) {\r\n        return this;\r\n    }\r\n    return plus(seconds.getValue());\r\n}"
}, {
	"Path": "org.joda.time.Hours.toStandardWeeks",
	"Comment": "converts this period in hours to a period in weeks assuming a7 day week and 24 hour day.this method allows you to convert between different types of period.however to achieve this it makes the assumption that all weeks are 7 dayslong and all days are 24 hours long.this is not true when daylight savings time is considered, and may alsonot be true for some unusual chronologies. however, it is included as itis a useful operation for many applications and business rules.",
	"Method": "Weeks toStandardWeeks(){\r\n    return Weeks.weeks(getValue() / DateTimeConstants.HOURS_PER_WEEK);\r\n}"
}, {
	"Path": "org.joda.time.Days.toStandardWeeks",
	"Comment": "converts this period in days to a period in weeks assuming a7 day week.this method allows you to convert between different types of period.however to achieve this it makes the assumption that all weeks are7 days long.this may not be true for some unusual chronologies. however, it is includedas it is a useful operation for many applications and business rules.",
	"Method": "Weeks toStandardWeeks(){\r\n    return Weeks.weeks(getValue() / DateTimeConstants.DAYS_PER_WEEK);\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.video.VideoStream.measureFramerate",
	"Comment": "computes the average frame rate at which the preview callback is called.\twe will then use this average frame rate with the mediacodec.\tblocks the thread in which this function is called.",
	"Method": "void measureFramerate(){\r\n    final Semaphore lock = new Semaphore(0);\r\n    final Camera.PreviewCallback callback = new Camera.PreviewCallback() {\r\n        int i = 0, t = 0;\r\n        long now, oldnow, count = 0;\r\n        @Override\r\n        public void onPreviewFrame(byte[] data, Camera camera) {\r\n            i++;\r\n            now = System.nanoTime() / 1000;\r\n            if (i > 3) {\r\n                t += now - oldnow;\r\n                count++;\r\n            }\r\n            if (i > 20) {\r\n                mQuality.framerate = (int) (1000000 / (t / count) + 1);\r\n                lock.release();\r\n            }\r\n            oldnow = now;\r\n        }\r\n    };\r\n    mCamera.setPreviewCallback(callback);\r\n    try {\r\n        lock.tryAcquire(2, TimeUnit.SECONDS);\r\n        Log.d(TAG, \"Actual framerate: \" + mQuality.framerate);\r\n        if (mSettings != null) {\r\n            Editor editor = mSettings.edit();\r\n            editor.putInt(PREF_PREFIX + \"fps\" + mRequestedQuality.framerate + \",\" + mCameraImageFormat + \",\" + mRequestedQuality.resX + mRequestedQuality.resY, mQuality.framerate);\r\n            editor.commit();\r\n        }\r\n    } catch (InterruptedException e) {\r\n    }\r\n    mCamera.setPreviewCallback(null);\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.video.VideoStream.measureFramerate",
	"Comment": "computes the average frame rate at which the preview callback is called.\twe will then use this average frame rate with the mediacodec.\tblocks the thread in which this function is called.",
	"Method": "void measureFramerate(){\r\n    i++;\r\n    now = System.nanoTime() / 1000;\r\n    if (i > 3) {\r\n        t += now - oldnow;\r\n        count++;\r\n    }\r\n    if (i > 20) {\r\n        mQuality.framerate = (int) (1000000 / (t / count) + 1);\r\n        lock.release();\r\n    }\r\n    oldnow = now;\r\n}"
}, {
	"Path": "jodd.proxetta.asm.ProxettaClassBuilder.matchMethodPointcuts",
	"Comment": "matches pointcuts on method. if no pointcut found, returns null.",
	"Method": "List<ProxyAspectData> matchMethodPointcuts(MethodSignatureVisitor msign){\r\n    List<ProxyAspectData> aspectList = null;\r\n    for (ProxyAspectData aspectData : wd.proxyAspects) {\r\n        if (aspectData.apply(msign)) {\r\n            if (aspectList == null) {\r\n                aspectList = new ArrayList(wd.proxyAspects.length);\r\n            }\r\n            aspectList.add(aspectData);\r\n        }\r\n    }\r\n    return aspectList;\r\n}"
}, {
	"Path": "jodd.htmlstapler.HtmlStaplerBundlesManager.getBundleFolder",
	"Comment": "returns bundles folder. by default, it is a system temp folder.",
	"Method": "String getBundleFolder(){\r\n    return bundleFolder;\r\n}"
}, {
	"Path": "org.joda.time.Years.yearsBetween",
	"Comment": "creates a years representing the number of whole yearsbetween the two specified partial datetimes.the two partials must contain the same fields, for example you can specifytwo localdate objects.",
	"Method": "Years yearsBetween(ReadableInstant start,ReadableInstant end,Years yearsBetween,ReadablePartial start,ReadablePartial end){\r\n    if (start instanceof LocalDate && end instanceof LocalDate) {\r\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\r\n        int years = chrono.years().getDifference(((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\r\n        return Years.years(years);\r\n    }\r\n    int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\r\n    return Years.years(amount);\r\n}"
}, {
	"Path": "org.jooq.impl.DSL.localDateTimeAdd",
	"Comment": "add an interval to a timestamp, given a date part.this translates into any dialect",
	"Method": "Field<LocalDateTime> localDateTimeAdd(LocalDateTime timestamp,Number interval,Field<LocalDateTime> localDateTimeAdd,Field<LocalDateTime> timestamp,Field<? extends Number> interval,Field<LocalDateTime> localDateTimeAdd,LocalDateTime date,Number interval,DatePart datePart,Field<LocalDateTime> localDateTimeAdd,LocalDateTime date,Field<? extends Number> interval,DatePart datePart,Field<LocalDateTime> localDateTimeAdd,Field<LocalDateTime> date,Number interval,DatePart datePart,Field<LocalDateTime> localDateTimeAdd,Field<LocalDateTime> date,Field<? extends Number> interval,DatePart datePart){\r\n    return new DateAdd<LocalDateTime>(nullSafe(date), nullSafe(interval), datePart);\r\n}"
}, {
	"Path": "org.joda.time.base.BaseInterval.setInterval",
	"Comment": "sets this interval from two millisecond instants and a chronology.",
	"Method": "void setInterval(long startInstant,long endInstant,Chronology chrono){\r\n    checkInterval(startInstant, endInstant);\r\n    iStartMillis = startInstant;\r\n    iEndMillis = endInstant;\r\n    iChronology = DateTimeUtils.getChronology(chrono);\r\n}"
}, {
	"Path": "jodd.madvoc.interceptor.AnnotatedPropertyInterceptor.lookupAnnotatedProperties",
	"Comment": "lookups for annotated properties. caches all annotated properties on the first\taction class scan.",
	"Method": "PropertyDescriptor[] lookupAnnotatedProperties(Class type){\r\n    PropertyDescriptor[] properties = annotatedProperties.get(type);\r\n    if (properties != null) {\r\n        return properties;\r\n    }\r\n    ClassDescriptor cd = ClassIntrospector.get().lookup(type);\r\n    PropertyDescriptor[] allProperties = cd.getAllPropertyDescriptors();\r\n    List<PropertyDescriptor> list = new ArrayList();\r\n    for (PropertyDescriptor propertyDescriptor : allProperties) {\r\n        Annotation ann = null;\r\n        if (propertyDescriptor.getFieldDescriptor() != null) {\r\n            ann = propertyDescriptor.getFieldDescriptor().getField().getAnnotation(annotations);\r\n        }\r\n        if (ann == null && propertyDescriptor.getWriteMethodDescriptor() != null) {\r\n            ann = propertyDescriptor.getWriteMethodDescriptor().getMethod().getAnnotation(annotations);\r\n        }\r\n        if (ann == null && propertyDescriptor.getReadMethodDescriptor() != null) {\r\n            ann = propertyDescriptor.getReadMethodDescriptor().getMethod().getAnnotation(annotations);\r\n        }\r\n        if (ann != null) {\r\n            list.add(propertyDescriptor);\r\n        }\r\n    }\r\n    if (list.isEmpty()) {\r\n        properties = EMPTY;\r\n    } else {\r\n        properties = list.toArray(new PropertyDescriptor[0]);\r\n    }\r\n    annotatedProperties.put(type, properties);\r\n    return properties;\r\n}"
}, {
	"Path": "org.joda.time.YearMonth.property",
	"Comment": "gets the property object for the specified type, which containsmany useful methods.",
	"Method": "Property property(DateTimeFieldType type){\r\n    return new Property(this, indexOfSupported(type));\r\n}"
}, {
	"Path": "org.joda.time.TimeOfDay.withHourOfDay",
	"Comment": "returns a copy of this time with the hour of day field updated.timeofday is immutable, so there are no set methods.instead, this method returns a new instance with the value ofhour of day changed.",
	"Method": "TimeOfDay withHourOfDay(int hour){\r\n    int[] newValues = getValues();\r\n    newValues = getChronology().hourOfDay().set(this, HOUR_OF_DAY, newValues, hour);\r\n    return new TimeOfDay(this, newValues);\r\n}"
}, {
	"Path": "jodd.servlet.CsrfShield.setTimeToLive",
	"Comment": "sets time to live for tokens in seconds.\tby setting negative value or 0 token leaves forever.",
	"Method": "void setTimeToLive(int periodInSeconds){\r\n    timeToLive = periodInSeconds;\r\n}"
}, {
	"Path": "jodd.asm7.ModuleVisitor.visitEnd",
	"Comment": "visits the end of the module. this method, which is the last one to be called, is used toinform the visitor that everything have been visited.",
	"Method": "void visitEnd(){\r\n    if (mv != null) {\r\n        mv.visitEnd();\r\n    }\r\n}"
}, {
	"Path": "jodd.jerry.Jerry.hasClass",
	"Comment": "determines whether any of the matched elements are assigned the given class.",
	"Method": "boolean hasClass(String classNames){\r\n    if (nodes.length == 0) {\r\n        return false;\r\n    }\r\n    for (Node node : nodes) {\r\n        String attrClass = node.getAttribute(\"class\");\r\n        Set<String> classes = createPropertiesSet(attrClass, ' ');\r\n        for (String className : classNames) {\r\n            if (classes.contains(className)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.jayway.jsonpath.Configuration.addOptions",
	"Comment": "creates a new configuration by adding the new options to the options used in this configuration.",
	"Method": "Configuration addOptions(Option options){\r\n    EnumSet<Option> opts = EnumSet.noneOf(Option.class);\r\n    opts.addAll(this.options);\r\n    opts.addAll(asList(options));\r\n    return Configuration.builder().jsonProvider(jsonProvider).mappingProvider(mappingProvider).options(opts).evaluationListener(evaluationListeners).build();\r\n}"
}, {
	"Path": "org.joda.time.DateTimeZone.validateProvider",
	"Comment": "sets the zone provider factory without performing the security check.",
	"Method": "Provider validateProvider(Provider provider){\r\n    Set<String> ids = provider.getAvailableIDs();\r\n    if (ids == null || ids.size() == 0) {\r\n        throw new IllegalArgumentException(\"The provider doesn't have any available ids\");\r\n    }\r\n    if (!ids.contains(\"UTC\")) {\r\n        throw new IllegalArgumentException(\"The provider doesn't support UTC\");\r\n    }\r\n    if (!UTC.equals(provider.getZone(\"UTC\"))) {\r\n        throw new IllegalArgumentException(\"Invalid UTC zone provided\");\r\n    }\r\n    return provider;\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Database.getSyntheticIdentities",
	"Comment": "a regular expression matching all columns that represent identities.to be used if columns are not detected as automatically as identities.",
	"Method": "String getSyntheticIdentities(){\r\n    return syntheticIdentities;\r\n}"
}, {
	"Path": "org.joda.time.DateMidnight.era",
	"Comment": "get the era property which provides access to advanced functionality.",
	"Method": "Property era(){\r\n    return new Property(this, getChronology().era());\r\n}"
}, {
	"Path": "jodd.lagarto.dom.HtmlFosterRules.findFosterNodes",
	"Comment": "finds foster elements. returns true if there was no change in\tdom tree of the parent element. otherwise, returns false\tmeaning that parent will scan its childs again.",
	"Method": "boolean findFosterNodes(Node node){\r\n    boolean isTable = false;\r\n    if (!lastTables.isEmpty()) {\r\n        if (node.getNodeType() == Node.NodeType.TEXT) {\r\n            String value = node.getNodeValue();\r\n            if (!StringUtil.isBlank(value)) {\r\n                if (isParentNodeOneOfFosterTableElements(node.getParentNode())) {\r\n                    fosterTexts.add((Text) node);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (node.getNodeType() == Node.NodeType.ELEMENT) {\r\n        Element element = (Element) node;\r\n        isTable = isTableElement(node);\r\n        if (isTable) {\r\n            lastTables.add(element);\r\n        } else {\r\n            if (!lastTables.isEmpty()) {\r\n                Node parentNode = node.getParentNode();\r\n                if (isParentNodeOneOfFosterTableElements(parentNode) && !isOneOfTableElements(element)) {\r\n                    String elementNodeName = element.getNodeName().toLowerCase();\r\n                    if (elementNodeName.equals(\"form\")) {\r\n                        if (element.getChildNodesCount() > 0) {\r\n                            Node[] formChildNodes = element.getChildNodes();\r\n                            parentNode.insertAfter(formChildNodes, element);\r\n                            return false;\r\n                        } else {\r\n                            return true;\r\n                        }\r\n                    }\r\n                    if (elementNodeName.equals(\"input\")) {\r\n                        String inputType = element.getAttribute(\"type\");\r\n                        if (inputType.equals(\"hidden\")) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                    fosterElements.add(element);\r\n                }\r\n            } else {\r\n            }\r\n        }\r\n    }\r\n    allchilds: while (true) {\r\n        int childs = node.getChildNodesCount();\r\n        for (int i = 0; i < childs; i++) {\r\n            Node childNode = node.getChild(i);\r\n            boolean done = findFosterNodes(childNode);\r\n            if (!done) {\r\n                continue allchilds;\r\n            }\r\n        }\r\n        break;\r\n    }\r\n    if (isTable) {\r\n        int size = lastTables.size();\r\n        if (size > 0) {\r\n            lastTables.remove(size - 1);\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "jodd.petite.scope.ShutdownAwareScope.shutdown",
	"Comment": "shutdowns the scope and calls all collected destroyable beans.",
	"Method": "void shutdown(){\r\n    if (destroyableBeans == null) {\r\n        return;\r\n    }\r\n    for (final BeanData destroyableBean : destroyableBeans) {\r\n        destroyableBean.callDestroyMethods();\r\n    }\r\n    destroyableBeans.clear();\r\n}"
}, {
	"Path": "org.joda.time.chrono.JulianChronology.getInstance",
	"Comment": "gets an instance of the julianchronology in the given time zone.",
	"Method": "JulianChronology getInstance(JulianChronology getInstance,DateTimeZone zone,JulianChronology getInstance,DateTimeZone zone,int minDaysInFirstWeek){\r\n    if (zone == null) {\r\n        zone = DateTimeZone.getDefault();\r\n    }\r\n    JulianChronology chrono;\r\n    JulianChronology[] chronos = cCache.get(zone);\r\n    if (chronos == null) {\r\n        chronos = new JulianChronology[7];\r\n        JulianChronology[] oldChronos = cCache.putIfAbsent(zone, chronos);\r\n        if (oldChronos != null) {\r\n            chronos = oldChronos;\r\n        }\r\n    }\r\n    try {\r\n        chrono = chronos[minDaysInFirstWeek - 1];\r\n    } catch (ArrayIndexOutOfBoundsException e) {\r\n        throw new IllegalArgumentException(\"Invalid min days in first week: \" + minDaysInFirstWeek);\r\n    }\r\n    if (chrono == null) {\r\n        synchronized (chronos) {\r\n            chrono = chronos[minDaysInFirstWeek - 1];\r\n            if (chrono == null) {\r\n                if (zone == DateTimeZone.UTC) {\r\n                    chrono = new JulianChronology(null, null, minDaysInFirstWeek);\r\n                } else {\r\n                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\r\n                    chrono = new JulianChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);\r\n                }\r\n                chronos[minDaysInFirstWeek - 1] = chrono;\r\n            }\r\n        }\r\n    }\r\n    return chrono;\r\n}"
}, {
	"Path": "org.joda.time.DateTime.withDayOfYear",
	"Comment": "returns a copy of this datetime with the day of year field updated.datetime is immutable, so there are no set methods.instead, this method returns a new instance with the value ofday of year changed.",
	"Method": "DateTime withDayOfYear(int dayOfYear){\r\n    return withMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear));\r\n}"
}, {
	"Path": "jodd.jtx.JtxTransactionManager.totalThreadTransactions",
	"Comment": "returns total number of transactions associated with current thread.",
	"Method": "int totalThreadTransactions(){\r\n    ArrayList<JtxTransaction> txList = txStack.get();\r\n    if (txList == null) {\r\n        return 0;\r\n    }\r\n    return txList.size();\r\n}"
}, {
	"Path": "jodd.lagarto.dom.Node.getAttribute",
	"Comment": "returns attribute at given index or null if index not found.",
	"Method": "Attribute getAttribute(int index,String getAttribute,String name){\r\n    Attribute attribute = getAttributeInstance(name);\r\n    if (attribute == null) {\r\n        return null;\r\n    }\r\n    return attribute.getValue();\r\n}"
}, {
	"Path": "org.joda.time.field.AbstractReadableInstantFieldProperty.getMinimumValueOverall",
	"Comment": "gets the minimum value for the field ignoring the current time.",
	"Method": "int getMinimumValueOverall(){\r\n    return getField().getMinimumValue();\r\n}"
}, {
	"Path": "jodd.petite.resolver.ReferencesResolver.convertRefToReferences",
	"Comment": "converts single string array to an array of bean references.",
	"Method": "BeanReferences[] convertRefToReferences(String[] references){\r\n    if (references == null) {\r\n        return null;\r\n    }\r\n    BeanReferences[] ref = new BeanReferences[references.length];\r\n    for (int i = 0; i < references.length; i++) {\r\n        ref[i] = BeanReferences.of(references[i]);\r\n    }\r\n    return ref;\r\n}"
}, {
	"Path": "org.json.Cookie.unescape",
	"Comment": "convert %hh sequences to single characters, andconvert plus to space.",
	"Method": "String unescape(String string){\r\n    int length = string.length();\r\n    StringBuilder sb = new StringBuilder(length);\r\n    for (int i = 0; i < length; ++i) {\r\n        char c = string.charAt(i);\r\n        if (c == '+') {\r\n            c = ' ';\r\n        } else if (c == '%' && i + 2 < length) {\r\n            int d = JSONTokener.dehexchar(string.charAt(i + 1));\r\n            int e = JSONTokener.dehexchar(string.charAt(i + 2));\r\n            if (d >= 0 && e >= 0) {\r\n                c = (char) (d * 16 + e);\r\n                i += 2;\r\n            }\r\n        }\r\n        sb.append(c);\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.joda.time.DateMidnight.weekOfWeekyear",
	"Comment": "get the week of a week based year property which provides access to advanced functionality.",
	"Method": "Property weekOfWeekyear(){\r\n    return new Property(this, getChronology().weekOfWeekyear());\r\n}"
}, {
	"Path": "org.joda.time.format.TestDateTimeFormatter.testZoneNameNearTransition",
	"Comment": "ensure time zone name switches properly at the zone dst transition.",
	"Method": "void testZoneNameNearTransition(){\r\n    DateTime inDST_1 = new DateTime(2005, 10, 30, 1, 0, 0, 0, NEWYORK);\r\n    DateTime inDST_2 = new DateTime(2005, 10, 30, 1, 59, 59, 999, NEWYORK);\r\n    DateTime onDST = new DateTime(2005, 10, 30, 2, 0, 0, 0, NEWYORK);\r\n    DateTime outDST = new DateTime(2005, 10, 30, 2, 0, 0, 1, NEWYORK);\r\n    DateTime outDST_2 = new DateTime(2005, 10, 30, 2, 0, 1, 0, NEWYORK);\r\n    DateTimeFormatter fmt = DateTimeFormat.forPattern(\"yyy-MM-dd HH:mm:ss.S zzzz\");\r\n    assertEquals(\"2005-10-30 01:00:00.0 Eastern Daylight Time\", fmt.print(inDST_1));\r\n    assertEquals(\"2005-10-30 01:59:59.9 Eastern Daylight Time\", fmt.print(inDST_2));\r\n    assertEquals(\"2005-10-30 02:00:00.0 Eastern Standard Time\", fmt.print(onDST));\r\n    assertEquals(\"2005-10-30 02:00:00.0 Eastern Standard Time\", fmt.print(outDST));\r\n    assertEquals(\"2005-10-30 02:00:01.0 Eastern Standard Time\", fmt.print(outDST_2));\r\n}"
}, {
	"Path": "jodd.http.Cookie.getPath",
	"Comment": "returns the path on the server\tto which the browser returns this cookie. the\tcookie is visible to all subpaths on the server.",
	"Method": "String getPath(){\r\n    return path;\r\n}"
}, {
	"Path": "jodd.petite.PetiteContainer.initBeanDefinition",
	"Comment": "resolves and initializes bean definition. may be called multiple times.",
	"Method": "void initBeanDefinition(BeanDefinition def){\r\n    if (def.initMethods == null) {\r\n        def.initMethods = petiteResolvers.resolveInitMethodPoint(def.type);\r\n    }\r\n    if (def.destroyMethods == null) {\r\n        def.destroyMethods = petiteResolvers.resolveDestroyMethodPoint(def.type);\r\n    }\r\n    if (def.properties == null) {\r\n        def.properties = petiteResolvers.resolvePropertyInjectionPoint(def.type, def.wiringMode == WiringMode.AUTOWIRE);\r\n    }\r\n    if (def.methods == null) {\r\n        def.methods = petiteResolvers.resolveMethodInjectionPoint(def.type);\r\n    }\r\n    if (def.ctor == null) {\r\n        def.ctor = petiteResolvers.resolveCtorInjectionPoint(def.type);\r\n    }\r\n    if (def.values == null) {\r\n        def.values = paramManager.resolveParamInjectionPoints(def.type);\r\n    }\r\n    if (def.sets == null) {\r\n        def.sets = petiteResolvers.resolveSetInjectionPoint(def.type, def.wiringMode == WiringMode.AUTOWIRE);\r\n    }\r\n    if (def.params == null) {\r\n        def.params = paramManager.filterParametersForBeanName(def.name, petiteConfig.getResolveReferenceParameters());\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.YearMonthDay.toLocalDate",
	"Comment": "converts this object to a localdate with the same date and chronology.",
	"Method": "LocalDate toLocalDate(){\r\n    return new LocalDate(getYear(), getMonthOfYear(), getDayOfMonth(), getChronology());\r\n}"
}, {
	"Path": "org.joda.time.LocalDate.withDayOfMonth",
	"Comment": "returns a copy of this date with the day of month field updated.localdate is immutable, so there are no set methods.instead, this method returns a new instance with the value ofday of month changed.",
	"Method": "LocalDate withDayOfMonth(int dayOfMonth){\r\n    return withLocalMillis(getChronology().dayOfMonth().set(getLocalMillis(), dayOfMonth));\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Database.isIncludeUniqueKeys",
	"Comment": "this flag indicates whether unique keys should be included in output produced by this database",
	"Method": "Boolean isIncludeUniqueKeys(){\r\n    return includeUniqueKeys;\r\n}"
}, {
	"Path": "jodd.htmlstapler.HtmlStaplerBundlesManager.lookupGzipBundleFile",
	"Comment": "locates gzipped version of bundle file. if gzip file\tdoes not exist, it will be created.",
	"Method": "File lookupGzipBundleFile(File file){\r\n    String path = file.getPath() + ZipUtil.GZIP_EXT;\r\n    File gzipFile = new File(path);\r\n    if (!gzipFile.exists()) {\r\n        if (log.isDebugEnabled()) {\r\n            log.debug(\"gzip bundle to \" + path);\r\n        }\r\n        ZipUtil.gzip(file);\r\n    }\r\n    return gzipFile;\r\n}"
}, {
	"Path": "org.joda.time.MonthDay.fromCalendarFields",
	"Comment": "constructs a monthday from a java.util.calendarusing exactly the same field values avoiding any time zone effects.each field is queried from the calendar and assigned to the monthday.this factory method ignores the type of the calendar and alwayscreates a monthday with iso chronology. it is expected that youwill only pass in instances of gregoriancalendar howeverthis is not validated.",
	"Method": "MonthDay fromCalendarFields(Calendar calendar){\r\n    if (calendar == null) {\r\n        throw new IllegalArgumentException(\"The calendar must not be null\");\r\n    }\r\n    return new MonthDay(calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH));\r\n}"
}, {
	"Path": "org.joda.time.PeriodType.withMonthsRemoved",
	"Comment": "returns a version of this periodtype instance that does not support months.",
	"Method": "PeriodType withMonthsRemoved(){\r\n    return withFieldRemoved(1, \"NoMonths\");\r\n}"
}, {
	"Path": "jodd.typeconverter.Converter.toFloat",
	"Comment": "converts value to float. returns default value\twhen conversion result is null",
	"Method": "Float toFloat(Object value,Float toFloat,Object value,Float defaultValue){\r\n    final Float result = toFloat(value);\r\n    if (result == null) {\r\n        return defaultValue;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.joda.time.DateTime.dayOfYear",
	"Comment": "get the day of year property which provides access to advanced functionality.",
	"Method": "Property dayOfYear(){\r\n    return new Property(this, getChronology().dayOfYear());\r\n}"
}, {
	"Path": "jodd.json.JsonObject.put",
	"Comment": "puts another json object into the json object with the specified key.",
	"Method": "JsonObject put(String key,Enum value,JsonObject put,String key,CharSequence value,JsonObject put,String key,String value,JsonObject put,String key,Integer value,JsonObject put,String key,Long value,JsonObject put,String key,Double value,JsonObject put,String key,Float value,JsonObject put,String key,Boolean value,JsonObject put,String key,JsonObject value,JsonObject put,String key,JsonArray value,JsonObject put,String key,byte[] value,JsonObject put,String key,Object value){\r\n    Objects.requireNonNull(key);\r\n    value = resolveValue(value);\r\n    map.put(key, value);\r\n    return this;\r\n}"
}, {
	"Path": "jodd.asm7.Handle.getOwner",
	"Comment": "returns the internal name of the class that owns the field or method designated by this handle.",
	"Method": "String getOwner(){\r\n    return owner;\r\n}"
}, {
	"Path": "jodd.io.FileUtil.checkExistsAndDirectory",
	"Comment": "checks if directory exists. throws ioexception if it does not.",
	"Method": "void checkExistsAndDirectory(File dir){\r\n    if (dir.exists()) {\r\n        checkIsDirectory(dir);\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.DateMidnight.withDurationAdded",
	"Comment": "returns a copy of this date with the specified duration added.if the addition is zero, then this is returned.",
	"Method": "DateMidnight withDurationAdded(long durationToAdd,int scalar,DateMidnight withDurationAdded,ReadableDuration durationToAdd,int scalar){\r\n    if (durationToAdd == null || scalar == 0) {\r\n        return this;\r\n    }\r\n    return withDurationAdded(durationToAdd.getMillis(), scalar);\r\n}"
}, {
	"Path": "org.joda.time.DateTimeZone.getDefaultNameProvider",
	"Comment": "gets the default name provider.tries the system property org.joda.time.datetimezone.nameprovider.then uses defaultnameprovider.",
	"Method": "NameProvider getDefaultNameProvider(){\r\n    NameProvider nameProvider = null;\r\n    try {\r\n        String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\r\n        if (providerClass != null) {\r\n            try {\r\n                Class<?> cls = Class.forName(providerClass, false, DateTimeZone.class.getClassLoader());\r\n                if (!NameProvider.class.isAssignableFrom(cls)) {\r\n                    throw new IllegalArgumentException(\"System property referred to class that does not implement \" + NameProvider.class);\r\n                }\r\n                nameProvider = cls.asSubclass(NameProvider.class).getConstructor().newInstance();\r\n            } catch (Exception ex) {\r\n                throw new RuntimeException(ex);\r\n            }\r\n        }\r\n    } catch (SecurityException ex) {\r\n    }\r\n    if (nameProvider == null) {\r\n        nameProvider = new DefaultNameProvider();\r\n    }\r\n    return nameProvider;\r\n}"
}, {
	"Path": "org.jooq.impl.DefaultRecordListenerProvider.providers",
	"Comment": "convenience method to construct an array ofdefaultrecordlistenerprovider from an array ofrecordlistener instances.",
	"Method": "RecordListenerProvider[] providers(RecordListener listeners){\r\n    RecordListenerProvider[] result = new RecordListenerProvider[listeners.length];\r\n    for (int i = 0; i < listeners.length; i++) result[i] = new DefaultRecordListenerProvider(listeners[i]);\r\n    return result;\r\n}"
}, {
	"Path": "jodd.json.JsonSerializer.deep",
	"Comment": "defines if collections should be followed, i.e. to perform\tdeep serialization.",
	"Method": "JsonSerializer deep(boolean includeCollections){\r\n    this.deep = includeCollections;\r\n    return this;\r\n}"
}, {
	"Path": "org.jooq.conf.Settings.setMapConstructorParameterNames",
	"Comment": "sets the value of the mapconstructorparameternames property.",
	"Method": "void setMapConstructorParameterNames(Boolean value){\r\n    this.mapConstructorParameterNames = value;\r\n}"
}, {
	"Path": "jodd.typeconverter.TypeConverter.convert",
	"Comment": "converts object and returns default value if conversion fails.",
	"Method": "T convert(Object value,T convert,Object value,T defaultValue){\r\n    if (value == null) {\r\n        return defaultValue;\r\n    }\r\n    try {\r\n        return convert(value);\r\n    } catch (Exception e) {\r\n        return defaultValue;\r\n    }\r\n}"
}, {
	"Path": "jodd.asm7.Frame.getAbstractTypeFromDescriptor",
	"Comment": "returns the abstract type corresponding to the given type descriptor.",
	"Method": "int getAbstractTypeFromDescriptor(SymbolTable symbolTable,String buffer,int offset){\r\n    String internalName;\r\n    switch(buffer.charAt(offset)) {\r\n        case 'V':\r\n            return 0;\r\n        case 'Z':\r\n        case 'C':\r\n        case 'B':\r\n        case 'S':\r\n        case 'I':\r\n            return INTEGER;\r\n        case 'F':\r\n            return FLOAT;\r\n        case 'J':\r\n            return LONG;\r\n        case 'D':\r\n            return DOUBLE;\r\n        case 'L':\r\n            internalName = buffer.substring(offset + 1, buffer.length() - 1);\r\n            return REFERENCE_KIND | symbolTable.addType(internalName);\r\n        case '[':\r\n            int elementDescriptorOffset = offset + 1;\r\n            while (buffer.charAt(elementDescriptorOffset) == '[') {\r\n                ++elementDescriptorOffset;\r\n            }\r\n            int typeValue;\r\n            switch(buffer.charAt(elementDescriptorOffset)) {\r\n                case 'Z':\r\n                    typeValue = BOOLEAN;\r\n                    break;\r\n                case 'C':\r\n                    typeValue = CHAR;\r\n                    break;\r\n                case 'B':\r\n                    typeValue = BYTE;\r\n                    break;\r\n                case 'S':\r\n                    typeValue = SHORT;\r\n                    break;\r\n                case 'I':\r\n                    typeValue = INTEGER;\r\n                    break;\r\n                case 'F':\r\n                    typeValue = FLOAT;\r\n                    break;\r\n                case 'J':\r\n                    typeValue = LONG;\r\n                    break;\r\n                case 'D':\r\n                    typeValue = DOUBLE;\r\n                    break;\r\n                case 'L':\r\n                    internalName = buffer.substring(elementDescriptorOffset + 1, buffer.length() - 1);\r\n                    typeValue = REFERENCE_KIND | symbolTable.addType(internalName);\r\n                    break;\r\n                default:\r\n                    throw new IllegalArgumentException();\r\n            }\r\n            return ((elementDescriptorOffset - offset) << DIM_SHIFT) | typeValue;\r\n        default:\r\n            throw new IllegalArgumentException();\r\n    }\r\n}"
}, {
	"Path": "org.jooq.impl.Expression.lhsAsNumber",
	"Comment": "in some expressions, the lhs can be safely assumed to be a single number",
	"Method": "Field<Number> lhsAsNumber(){\r\n    return (Field<Number>) lhs;\r\n}"
}, {
	"Path": "jodd.db.pool.CoreConnectionPool.setValidationTimeout",
	"Comment": "specifies number of milliseconds from connection creation\twhen connection is considered as opened and valid.",
	"Method": "void setValidationTimeout(long validationTimeout){\r\n    this.validationTimeout = validationTimeout;\r\n}"
}, {
	"Path": "jodd.htmlstapler.HtmlStaplerBundlesManager.registerNewBundleId",
	"Comment": "registers new, temporary bundle id for given action path.\tthis id is used on first bundle usage, later it will be replaces with\treal bundle id.",
	"Method": "String registerNewBundleId(){\r\n    bundleCount++;\r\n    return String.valueOf(bundleCount);\r\n}"
}, {
	"Path": "jodd.util.ProcessRunner.run",
	"Comment": "executes a process and returns the process output and exit code.",
	"Method": "ProcessResult run(Process process){\r\n    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n    final StreamGobbler outputGobbler = new StreamGobbler(process.getInputStream(), baos, OUTPUT_PREFIX);\r\n    final StreamGobbler errorGobbler = new StreamGobbler(process.getErrorStream(), baos, ERROR_PREFIX);\r\n    outputGobbler.start();\r\n    errorGobbler.start();\r\n    final int result = process.waitFor();\r\n    outputGobbler.waitFor();\r\n    errorGobbler.waitFor();\r\n    return new ProcessResult(result, baos.toString());\r\n}"
}, {
	"Path": "org.jooq.codegen.JavaGenerator.generateRecordSetter",
	"Comment": "subclasses may override this method to provide their own record setters.",
	"Method": "void generateRecordSetter(TypedElementDefinition<?> column,int index,JavaWriter out){\r\n    generateRecordSetter0(column, index, out);\r\n}"
}, {
	"Path": "jodd.proxetta.Proxetta.getClassLoader",
	"Comment": "returns specified classloader for loading created classes.\tif classloader is not specified, returns null.",
	"Method": "ClassLoader getClassLoader(){\r\n    return classLoader;\r\n}"
}, {
	"Path": "org.jooq.conf.Settings.isMapJPAAnnotations",
	"Comment": "whether jpa annotations should be considered by the defaultrecordmapper.",
	"Method": "Boolean isMapJPAAnnotations(){\r\n    return mapJPAAnnotations;\r\n}"
}, {
	"Path": "org.joda.time.Partial.withChronologyRetainFields",
	"Comment": "creates a new partial instance with the specified chronology.this instance is immutable and unaffected by this method call.this method retains the values of the fields, thus the result willtypically refer to a different instant.the time zone of the specified chronology is ignored, as partialoperates without a time zone.",
	"Method": "Partial withChronologyRetainFields(Chronology newChronology){\r\n    newChronology = DateTimeUtils.getChronology(newChronology);\r\n    newChronology = newChronology.withUTC();\r\n    if (newChronology == getChronology()) {\r\n        return this;\r\n    } else {\r\n        Partial newPartial = new Partial(newChronology, iTypes, iValues);\r\n        newChronology.validate(newPartial, iValues);\r\n        return newPartial;\r\n    }\r\n}"
}, {
	"Path": "jodd.asm7.ClassReader.readStream",
	"Comment": "reads the given input stream and returns its content as a byte array.",
	"Method": "byte[] readStream(InputStream inputStream,boolean close){\r\n    if (inputStream == null) {\r\n        throw new IOException(\"Class not found\");\r\n    }\r\n    try {\r\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\r\n        byte[] data = new byte[INPUT_STREAM_DATA_CHUNK_SIZE];\r\n        int bytesRead;\r\n        while ((bytesRead = inputStream.read(data, 0, data.length)) != -1) {\r\n            outputStream.write(data, 0, bytesRead);\r\n        }\r\n        outputStream.flush();\r\n        return outputStream.toByteArray();\r\n    } finally {\r\n        if (close) {\r\n            inputStream.close();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jooq.conf.Settings.setExecuteDeleteWithoutWhere",
	"Comment": "sets the value of the executedeletewithoutwhere property.",
	"Method": "void setExecuteDeleteWithoutWhere(ExecuteWithoutWhere value){\r\n    this.executeDeleteWithoutWhere = value;\r\n}"
}, {
	"Path": "org.joda.time.chrono.AssembledChronology.getParam",
	"Comment": "returns the same param object as passed into the constructor.",
	"Method": "Object getParam(){\r\n    return iParam;\r\n}"
}, {
	"Path": "org.joda.time.Period.toStandardMinutes",
	"Comment": "converts this period to a period in minutes assuming a7 day week, 24 hour day, 60 minute hour and 60 second minute.this method allows you to convert between different types of period.however to achieve this it makes the assumption that allweeks are 7 days, all days are 24 hours, all hours are 60 minutes andall minutes are 60 seconds. this is not true when daylight savings timeis considered, and may also not be true for some unusual chronologies.however, it is included as it is a useful operation for manyapplications and business rules.if the period contains years or months, an exception will be thrown.",
	"Method": "Minutes toStandardMinutes(){\r\n    checkYearsAndMonths(\"Minutes\");\r\n    long millis = getMillis();\r\n    millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;\r\n    long minutes = millis / DateTimeConstants.MILLIS_PER_MINUTE;\r\n    minutes = FieldUtils.safeAdd(minutes, getMinutes());\r\n    minutes = FieldUtils.safeAdd(minutes, ((long) getHours()) * ((long) DateTimeConstants.MINUTES_PER_HOUR));\r\n    minutes = FieldUtils.safeAdd(minutes, ((long) getDays()) * ((long) DateTimeConstants.MINUTES_PER_DAY));\r\n    minutes = FieldUtils.safeAdd(minutes, ((long) getWeeks()) * ((long) DateTimeConstants.MINUTES_PER_WEEK));\r\n    return Minutes.minutes(FieldUtils.safeToInt(minutes));\r\n}"
}, {
	"Path": "org.joda.time.Minutes.isLessThan",
	"Comment": "is this minutes instance less than the specified number of minutes.",
	"Method": "boolean isLessThan(Minutes other){\r\n    if (other == null) {\r\n        return getValue() < 0;\r\n    }\r\n    return getValue() < other.getValue();\r\n}"
}, {
	"Path": "org.joda.time.chrono.CopticChronology.getInstanceUTC",
	"Comment": "gets an instance of the copticchronology.the time zone of the returned instance is utc.",
	"Method": "CopticChronology getInstanceUTC(){\r\n    return INSTANCE_UTC;\r\n}"
}, {
	"Path": "org.jsonschema2pojo.integration.util.Jsonschema2PojoRule.getClassLoader",
	"Comment": "returns the class loader for compiled classes. only defined after callinga compile method.",
	"Method": "ClassLoader getClassLoader(){\r\n    checkActive();\r\n    return classLoader;\r\n}"
}, {
	"Path": "org.joda.time.field.BaseDateTimeField.roundHalfFloor",
	"Comment": "round to the nearest whole unit of this field. if the given millisecondvalue is closer to the floor or is exactly halfway, this functionbehaves like roundfloor. if the millisecond value is closer to theceiling, this function behaves like roundceiling.",
	"Method": "long roundHalfFloor(long instant){\r\n    long floor = roundFloor(instant);\r\n    long ceiling = roundCeiling(instant);\r\n    long diffFromFloor = instant - floor;\r\n    long diffToCeiling = ceiling - instant;\r\n    if (diffFromFloor <= diffToCeiling) {\r\n        return floor;\r\n    } else {\r\n        return ceiling;\r\n    }\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.rtp.RtpSocket.getBitrate",
	"Comment": "returns an approximation of the bitrate of the rtp stream in bits per second.",
	"Method": "long getBitrate(){\r\n    return mAverageBitrate.average();\r\n}"
}, {
	"Path": "jodd.proxetta.ProxettaUtil.resolveTargetClass",
	"Comment": "returns target class if proxetta applied on given class.\tif not, returns given class as result.",
	"Method": "Class resolveTargetClass(Class proxy){\r\n    final String name = proxy.getName();\r\n    if (name.endsWith(ProxettaNames.proxyClassNameSuffix)) {\r\n        return proxy.getSuperclass();\r\n    }\r\n    if (name.endsWith(ProxettaNames.wrapperClassNameSuffix)) {\r\n        return getTargetWrapperType(proxy);\r\n    }\r\n    return proxy;\r\n}"
}, {
	"Path": "jodd.util.ResourceBundleMessageResolver.getBundle",
	"Comment": "returns specified bundle. invoked every time if cache is disabled.\tinput arguments are always valid.",
	"Method": "ResourceBundle getBundle(String bundleName,Locale locale,ClassLoader classLoader){\r\n    return ResourceBundle.getBundle(bundleName, locale, classLoader);\r\n}"
}, {
	"Path": "jodd.exception.UncheckedException.getMessage",
	"Comment": "returns the detail message, including the message from the nested exception if there is one.",
	"Method": "String getMessage(){\r\n    return ExceptionUtil.buildMessage(super.getMessage(), cause);\r\n}"
}, {
	"Path": "jodd.servlet.filter.CharArrayResponseWrapper.getWriter",
	"Comment": "returns buffered writer. buffer will be created if not already used.",
	"Method": "PrintWriter getWriter(){\r\n    if (writer == null) {\r\n        writer = new FastCharArrayWriter();\r\n        printWriter = new PrintWriter(writer);\r\n    }\r\n    return printWriter;\r\n}"
}, {
	"Path": "jodd.jerry.Jerry.wrap",
	"Comment": "wraps an html structure around each element in the set of matched elements.\treturns the original set of elements for chaining purposes.",
	"Method": "Jerry wrap(String html){\r\n    if (html == null) {\r\n        html = StringPool.EMPTY;\r\n    }\r\n    final Document doc = builder.parse(html);\r\n    if (nodes.length == 0) {\r\n        return this;\r\n    }\r\n    for (Node node : nodes) {\r\n        Document workingDoc = doc.clone();\r\n        Node inmostNode = workingDoc;\r\n        while (inmostNode.hasChildNodes()) {\r\n            inmostNode = inmostNode.getFirstChild();\r\n        }\r\n        Node parent = node.getParentNode();\r\n        int index = node.getSiblingIndex();\r\n        inmostNode.addChild(node);\r\n        parent.insertChild(workingDoc.getFirstChild(), index);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.joda.time.Days.daysBetween",
	"Comment": "creates a days representing the number of whole daysbetween the two specified partial datetimes.the two partials must contain the same fields, for example you can specifytwo localdate objects.",
	"Method": "Days daysBetween(ReadableInstant start,ReadableInstant end,Days daysBetween,ReadablePartial start,ReadablePartial end){\r\n    if (start instanceof LocalDate && end instanceof LocalDate) {\r\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\r\n        int days = chrono.days().getDifference(((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\r\n        return Days.days(days);\r\n    }\r\n    int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\r\n    return Days.days(amount);\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.property",
	"Comment": "gets the property object for the specified type, which contains manyuseful methods.",
	"Method": "Property property(DateTimeFieldType fieldType){\r\n    if (fieldType == null) {\r\n        throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\r\n    }\r\n    if (isSupported(fieldType) == false) {\r\n        throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\r\n    }\r\n    return new Property(this, fieldType.getField(getChronology()));\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.isSupported",
	"Comment": "checks if the duration type specified is supported by thislocal datetime and chronology.",
	"Method": "boolean isSupported(DateTimeFieldType type,boolean isSupported,DurationFieldType type){\r\n    if (type == null) {\r\n        return false;\r\n    }\r\n    return type.getField(getChronology()).isSupported();\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Database.isIncludeSequences",
	"Comment": "this flag indicates whether sequences should be included in output produced by this database",
	"Method": "Boolean isIncludeSequences(){\r\n    return includeSequences;\r\n}"
}, {
	"Path": "org.joda.time.Period.minusSeconds",
	"Comment": "returns a new period minus the specified number of seconds taken away.this period instance is immutable and unaffected by this method call.",
	"Method": "Period minusSeconds(int seconds){\r\n    return plusSeconds(-seconds);\r\n}"
}, {
	"Path": "org.joda.time.LocalDate.yearOfEra",
	"Comment": "get the year of era property which provides access to advanced functionality.",
	"Method": "Property yearOfEra(){\r\n    return new Property(this, getChronology().yearOfEra());\r\n}"
}, {
	"Path": "org.joda.time.LocalDate.toDateTimeAtMidnight",
	"Comment": "converts this localdate to a full datetime at midnight using thespecified time zone.this method will throw an exception if the time zone switchesto daylight savings time at midnight and this localdate representsthat switchover date. the problem is that there is no such time asmidnight on the required date, and as such an exception is thrown.this method uses the chronology from this instance plus the time zonespecified.this instance is immutable and unaffected by this method call.",
	"Method": "DateTime toDateTimeAtMidnight(DateTime toDateTimeAtMidnight,DateTimeZone zone){\r\n    zone = DateTimeUtils.getZone(zone);\r\n    Chronology chrono = getChronology().withZone(zone);\r\n    return new DateTime(getYear(), getMonthOfYear(), getDayOfMonth(), 0, 0, 0, 0, chrono);\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.withYear",
	"Comment": "returns a copy of this datetime with the year field updated.localdatetime is immutable, so there are no set methods.instead, this method returns a new instance with the value ofyear changed.",
	"Method": "LocalDateTime withYear(int year){\r\n    return withLocalMillis(getChronology().year().set(getLocalMillis(), year));\r\n}"
}, {
	"Path": "com.jayway.jsonpath.Configuration.setOptions",
	"Comment": "creates a new configuration with the provided options. options in this configuration are discarded.",
	"Method": "Configuration setOptions(Option options){\r\n    return Configuration.builder().jsonProvider(jsonProvider).mappingProvider(mappingProvider).options(options).evaluationListener(evaluationListeners).build();\r\n}"
}, {
	"Path": "jodd.util.StringUtil.cutFromIndexOf",
	"Comment": "cuts the string from the first index of provided char to the end.",
	"Method": "String cutFromIndexOf(String string,String substring,String cutFromIndexOf,String string,char c){\r\n    int i = string.indexOf(c);\r\n    if (i != -1) {\r\n        string = string.substring(i);\r\n    }\r\n    return string;\r\n}"
}, {
	"Path": "org.joda.time.MutableInterval.copy",
	"Comment": "clone this object without having to cast the returned object.",
	"Method": "MutableInterval copy(){\r\n    return (MutableInterval) clone();\r\n}"
}, {
	"Path": "org.joda.time.LocalDate.equals",
	"Comment": "compares this readablepartial with another returning true if the chronology,field types and values are equal.",
	"Method": "boolean equals(Object partial){\r\n    if (this == partial) {\r\n        return true;\r\n    }\r\n    if (partial instanceof LocalDate) {\r\n        LocalDate other = (LocalDate) partial;\r\n        if (iChronology.equals(other.iChronology)) {\r\n            return iLocalMillis == other.iLocalMillis;\r\n        }\r\n    }\r\n    return super.equals(partial);\r\n}"
}, {
	"Path": "jodd.lagarto.dom.Node.getSiblingIndex",
	"Comment": "get the list index of this node in its node sibling list.\tfor example, if this is the first node sibling, returns 0.\tindex address all nodes, i.e. of all node types.",
	"Method": "int getSiblingIndex(){\r\n    return siblingIndex;\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.secondOfMinute",
	"Comment": "get the second of minute field property which provides access to advanced functionality.",
	"Method": "Property secondOfMinute(){\r\n    return new Property(this, getChronology().secondOfMinute());\r\n}"
}, {
	"Path": "org.joda.time.TestDateTimeComparator.testWOW",
	"Comment": "test unequal comparisons with week of weekyear comparators.",
	"Method": "void testWOW(){\r\n    aDateTime = getADate(\"2000-01-04T00:00:00\");\r\n    bDateTime = getADate(\"2000-01-11T00:00:00\");\r\n    assertEquals(\"WOWM1a\", -1, cWeekOfWeekyear.compare(aDateTime, bDateTime));\r\n    assertEquals(\"WOWP1a\", 1, cWeekOfWeekyear.compare(bDateTime, aDateTime));\r\n    aDateTime = getADate(\"2000-01-04T00:00:00\");\r\n    bDateTime = getADate(\"1999-12-31T00:00:00\");\r\n    assertEquals(\"WOWM1b\", -1, cWeekOfWeekyear.compare(aDateTime, bDateTime));\r\n    assertEquals(\"WOWP1b\", 1, cWeekOfWeekyear.compare(bDateTime, aDateTime));\r\n}"
}, {
	"Path": "org.jooq.impl.DAOImpl.setConfiguration",
	"Comment": "inject a configuration.this method is maintained to be able to configure a daousing spring. it is not exposed in the public api.",
	"Method": "void setConfiguration(Configuration configuration){\r\n    this.configuration = configuration;\r\n    this.mapper = Tools.configuration(configuration).recordMapperProvider().provide(table.recordType(), type);\r\n}"
}, {
	"Path": "org.joda.time.Hours.standardHoursIn",
	"Comment": "creates a new hours representing the number of completestandard length hours in the specified period.this factory method converts all fields from the period to hours using standardiseddurations for each field. only those fields which have a precise duration inthe iso utc chronology can be converted.one week consists of 7 days.one day consists of 24 hours.one hour consists of 60 minutes.one minute consists of 60 seconds.one second consists of 1000 milliseconds.months and years are imprecise and periods containing these values cannot be converted.",
	"Method": "Hours standardHoursIn(ReadablePeriod period){\r\n    int amount = BaseSingleFieldPeriod.standardPeriodIn(period, DateTimeConstants.MILLIS_PER_HOUR);\r\n    return Hours.hours(amount);\r\n}"
}, {
	"Path": "org.joda.time.YearMonthDay.toDateTimeAtMidnight",
	"Comment": "converts this yearmonthday to a full datetime at midnight using thespecified time zone.this method uses the chronology from this instance plus the time zonespecified.",
	"Method": "DateTime toDateTimeAtMidnight(DateTime toDateTimeAtMidnight,DateTimeZone zone){\r\n    Chronology chrono = getChronology().withZone(zone);\r\n    return new DateTime(getYear(), getMonthOfYear(), getDayOfMonth(), 0, 0, 0, 0, chrono);\r\n}"
}, {
	"Path": "jodd.jerry.Jerry.removeClass",
	"Comment": "removes a single class, multiple classes, or all classes\tfrom each element in the set of matched elements.",
	"Method": "Jerry removeClass(String classNames){\r\n    if (nodes.length == 0) {\r\n        return this;\r\n    }\r\n    for (Node node : nodes) {\r\n        String attrClass = node.getAttribute(\"class\");\r\n        Set<String> classes = createPropertiesSet(attrClass, ' ');\r\n        boolean wasChange = false;\r\n        for (String className : classNames) {\r\n            if (classes.remove(className)) {\r\n                wasChange = true;\r\n            }\r\n        }\r\n        if (wasChange) {\r\n            String attrValue = generateAttributeValue(classes, ' ');\r\n            node.setAttribute(\"class\", attrValue);\r\n        }\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "jodd.asm7.ClassWriter.toByteArray",
	"Comment": "returns the content of the class file that was built by this classwriter.",
	"Method": "byte[] toByteArray(){\r\n    int size = 24 + 2 * interfaceCount;\r\n    int fieldsCount = 0;\r\n    FieldWriter fieldWriter = firstField;\r\n    while (fieldWriter != null) {\r\n        ++fieldsCount;\r\n        size += fieldWriter.computeFieldInfoSize();\r\n        fieldWriter = (FieldWriter) fieldWriter.fv;\r\n    }\r\n    int methodsCount = 0;\r\n    MethodWriter methodWriter = firstMethod;\r\n    while (methodWriter != null) {\r\n        ++methodsCount;\r\n        size += methodWriter.computeMethodInfoSize();\r\n        methodWriter = (MethodWriter) methodWriter.mv;\r\n    }\r\n    int attributesCount = 0;\r\n    if (innerClasses != null) {\r\n        ++attributesCount;\r\n        size += 8 + innerClasses.length;\r\n        symbolTable.addConstantUtf8(Constants.INNER_CLASSES);\r\n    }\r\n    if (enclosingClassIndex != 0) {\r\n        ++attributesCount;\r\n        size += 10;\r\n        symbolTable.addConstantUtf8(Constants.ENCLOSING_METHOD);\r\n    }\r\n    if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && (version & 0xFFFF) < Opcodes.V1_5) {\r\n        ++attributesCount;\r\n        size += 6;\r\n        symbolTable.addConstantUtf8(Constants.SYNTHETIC);\r\n    }\r\n    if (signatureIndex != 0) {\r\n        ++attributesCount;\r\n        size += 8;\r\n        symbolTable.addConstantUtf8(Constants.SIGNATURE);\r\n    }\r\n    if (sourceFileIndex != 0) {\r\n        ++attributesCount;\r\n        size += 8;\r\n        symbolTable.addConstantUtf8(Constants.SOURCE_FILE);\r\n    }\r\n    if (debugExtension != null) {\r\n        ++attributesCount;\r\n        size += 6 + debugExtension.length;\r\n        symbolTable.addConstantUtf8(Constants.SOURCE_DEBUG_EXTENSION);\r\n    }\r\n    if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) {\r\n        ++attributesCount;\r\n        size += 6;\r\n        symbolTable.addConstantUtf8(Constants.DEPRECATED);\r\n    }\r\n    if (lastRuntimeVisibleAnnotation != null) {\r\n        ++attributesCount;\r\n        size += lastRuntimeVisibleAnnotation.computeAnnotationsSize(Constants.RUNTIME_VISIBLE_ANNOTATIONS);\r\n    }\r\n    if (lastRuntimeInvisibleAnnotation != null) {\r\n        ++attributesCount;\r\n        size += lastRuntimeInvisibleAnnotation.computeAnnotationsSize(Constants.RUNTIME_INVISIBLE_ANNOTATIONS);\r\n    }\r\n    if (lastRuntimeVisibleTypeAnnotation != null) {\r\n        ++attributesCount;\r\n        size += lastRuntimeVisibleTypeAnnotation.computeAnnotationsSize(Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);\r\n    }\r\n    if (lastRuntimeInvisibleTypeAnnotation != null) {\r\n        ++attributesCount;\r\n        size += lastRuntimeInvisibleTypeAnnotation.computeAnnotationsSize(Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);\r\n    }\r\n    if (symbolTable.computeBootstrapMethodsSize() > 0) {\r\n        ++attributesCount;\r\n        size += symbolTable.computeBootstrapMethodsSize();\r\n    }\r\n    if (moduleWriter != null) {\r\n        attributesCount += moduleWriter.getAttributeCount();\r\n        size += moduleWriter.computeAttributesSize();\r\n    }\r\n    if (nestHostClassIndex != 0) {\r\n        ++attributesCount;\r\n        size += 8;\r\n        symbolTable.addConstantUtf8(Constants.NEST_HOST);\r\n    }\r\n    if (nestMemberClasses != null) {\r\n        ++attributesCount;\r\n        size += 8 + nestMemberClasses.length;\r\n        symbolTable.addConstantUtf8(Constants.NEST_MEMBERS);\r\n    }\r\n    if (firstAttribute != null) {\r\n        attributesCount += firstAttribute.getAttributeCount();\r\n        size += firstAttribute.computeAttributesSize(symbolTable);\r\n    }\r\n    size += symbolTable.getConstantPoolLength();\r\n    int constantPoolCount = symbolTable.getConstantPoolCount();\r\n    if (constantPoolCount > 0xFFFF) {\r\n        throw new ClassTooLargeException(symbolTable.getClassName(), constantPoolCount);\r\n    }\r\n    ByteVector result = new ByteVector(size);\r\n    result.putInt(0xCAFEBABE).putInt(version);\r\n    symbolTable.putConstantPool(result);\r\n    int mask = (version & 0xFFFF) < Opcodes.V1_5 ? Opcodes.ACC_SYNTHETIC : 0;\r\n    result.putShort(accessFlags & ~mask).putShort(thisClass).putShort(superClass);\r\n    result.putShort(interfaceCount);\r\n    for (int i = 0; i < interfaceCount; ++i) {\r\n        result.putShort(interfaces[i]);\r\n    }\r\n    result.putShort(fieldsCount);\r\n    fieldWriter = firstField;\r\n    while (fieldWriter != null) {\r\n        fieldWriter.putFieldInfo(result);\r\n        fieldWriter = (FieldWriter) fieldWriter.fv;\r\n    }\r\n    result.putShort(methodsCount);\r\n    boolean hasFrames = false;\r\n    boolean hasAsmInstructions = false;\r\n    methodWriter = firstMethod;\r\n    while (methodWriter != null) {\r\n        hasFrames |= methodWriter.hasFrames();\r\n        hasAsmInstructions |= methodWriter.hasAsmInstructions();\r\n        methodWriter.putMethodInfo(result);\r\n        methodWriter = (MethodWriter) methodWriter.mv;\r\n    }\r\n    result.putShort(attributesCount);\r\n    if (innerClasses != null) {\r\n        result.putShort(symbolTable.addConstantUtf8(Constants.INNER_CLASSES)).putInt(innerClasses.length + 2).putShort(numberOfInnerClasses).putByteArray(innerClasses.data, 0, innerClasses.length);\r\n    }\r\n    if (enclosingClassIndex != 0) {\r\n        result.putShort(symbolTable.addConstantUtf8(Constants.ENCLOSING_METHOD)).putInt(4).putShort(enclosingClassIndex).putShort(enclosingMethodIndex);\r\n    }\r\n    if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && (version & 0xFFFF) < Opcodes.V1_5) {\r\n        result.putShort(symbolTable.addConstantUtf8(Constants.SYNTHETIC)).putInt(0);\r\n    }\r\n    if (signatureIndex != 0) {\r\n        result.putShort(symbolTable.addConstantUtf8(Constants.SIGNATURE)).putInt(2).putShort(signatureIndex);\r\n    }\r\n    if (sourceFileIndex != 0) {\r\n        result.putShort(symbolTable.addConstantUtf8(Constants.SOURCE_FILE)).putInt(2).putShort(sourceFileIndex);\r\n    }\r\n    if (debugExtension != null) {\r\n        int length = debugExtension.length;\r\n        result.putShort(symbolTable.addConstantUtf8(Constants.SOURCE_DEBUG_EXTENSION)).putInt(length).putByteArray(debugExtension.data, 0, length);\r\n    }\r\n    if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) {\r\n        result.putShort(symbolTable.addConstantUtf8(Constants.DEPRECATED)).putInt(0);\r\n    }\r\n    if (lastRuntimeVisibleAnnotation != null) {\r\n        lastRuntimeVisibleAnnotation.putAnnotations(symbolTable.addConstantUtf8(Constants.RUNTIME_VISIBLE_ANNOTATIONS), result);\r\n    }\r\n    if (lastRuntimeInvisibleAnnotation != null) {\r\n        lastRuntimeInvisibleAnnotation.putAnnotations(symbolTable.addConstantUtf8(Constants.RUNTIME_INVISIBLE_ANNOTATIONS), result);\r\n    }\r\n    if (lastRuntimeVisibleTypeAnnotation != null) {\r\n        lastRuntimeVisibleTypeAnnotation.putAnnotations(symbolTable.addConstantUtf8(Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS), result);\r\n    }\r\n    if (lastRuntimeInvisibleTypeAnnotation != null) {\r\n        lastRuntimeInvisibleTypeAnnotation.putAnnotations(symbolTable.addConstantUtf8(Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS), result);\r\n    }\r\n    symbolTable.putBootstrapMethods(result);\r\n    if (moduleWriter != null) {\r\n        moduleWriter.putAttributes(result);\r\n    }\r\n    if (nestHostClassIndex != 0) {\r\n        result.putShort(symbolTable.addConstantUtf8(Constants.NEST_HOST)).putInt(2).putShort(nestHostClassIndex);\r\n    }\r\n    if (nestMemberClasses != null) {\r\n        result.putShort(symbolTable.addConstantUtf8(Constants.NEST_MEMBERS)).putInt(nestMemberClasses.length + 2).putShort(numberOfNestMemberClasses).putByteArray(nestMemberClasses.data, 0, nestMemberClasses.length);\r\n    }\r\n    if (firstAttribute != null) {\r\n        firstAttribute.putAttributes(symbolTable, result);\r\n    }\r\n    if (hasAsmInstructions) {\r\n        return replaceAsmInstructions(result.data, hasFrames);\r\n    } else {\r\n        return result.data;\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.field.AbstractPartialFieldProperty.getMinimumValueOverall",
	"Comment": "gets the minimum value for the field ignoring the current time.",
	"Method": "int getMinimumValueOverall(){\r\n    return getField().getMinimumValue();\r\n}"
}, {
	"Path": "com.jayway.jsonpath.TestUtils.assertHasNoResults",
	"Comment": "assertion which requires empty list as a result of indefinite path search.",
	"Method": "void assertHasNoResults(String json,String path,Configuration conf){\r\n    assertHasResults(json, path, 0, conf);\r\n}"
}, {
	"Path": "jodd.joy.page.PageData.hasPreviousPage",
	"Comment": "returns true if there is a previous page, i.e. we are not at the first page.",
	"Method": "boolean hasPreviousPage(){\r\n    return currentPage > 1;\r\n}"
}, {
	"Path": "org.joda.time.TimeOfDay.withMillisOfSecond",
	"Comment": "returns a copy of this time with the millis of second field updated.timeofday is immutable, so there are no set methods.instead, this method returns a new instance with the value ofmillis of second changed.",
	"Method": "TimeOfDay withMillisOfSecond(int millis){\r\n    int[] newValues = getValues();\r\n    newValues = getChronology().millisOfSecond().set(this, MILLIS_OF_SECOND, newValues, millis);\r\n    return new TimeOfDay(this, newValues);\r\n}"
}, {
	"Path": "org.joda.time.MonthDay.getFieldTypes",
	"Comment": "gets an array of the field type of each of the fields that this partial supports.the fields are returned largest to smallest, month, day.",
	"Method": "DateTimeFieldType[] getFieldTypes(){\r\n    return (DateTimeFieldType[]) FIELD_TYPES.clone();\r\n}"
}, {
	"Path": "jodd.util.ClassUtil.getAccessibleMethods",
	"Comment": "returns array of all methods that are accessible from given class.",
	"Method": "Method[] getAccessibleMethods(Class clazz,Method[] getAccessibleMethods,Class clazz,Class limit){\r\n    Package topPackage = clazz.getPackage();\r\n    List<Method> methodList = new ArrayList();\r\n    int topPackageHash = topPackage == null ? 0 : topPackage.hashCode();\r\n    boolean top = true;\r\n    do {\r\n        if (clazz == null) {\r\n            break;\r\n        }\r\n        Method[] declaredMethods = clazz.getDeclaredMethods();\r\n        for (Method method : declaredMethods) {\r\n            if (Modifier.isVolatile(method.getModifiers())) {\r\n                continue;\r\n            }\r\n            if (top) {\r\n                methodList.add(method);\r\n                continue;\r\n            }\r\n            int modifier = method.getModifiers();\r\n            if (Modifier.isPrivate(modifier)) {\r\n                continue;\r\n            }\r\n            if (Modifier.isAbstract(modifier)) {\r\n                continue;\r\n            }\r\n            if (Modifier.isPublic(modifier)) {\r\n                addMethodIfNotExist(methodList, method);\r\n                continue;\r\n            }\r\n            if (Modifier.isProtected(modifier)) {\r\n                addMethodIfNotExist(methodList, method);\r\n                continue;\r\n            }\r\n            Package pckg = method.getDeclaringClass().getPackage();\r\n            int pckgHash = pckg == null ? 0 : pckg.hashCode();\r\n            if (pckgHash == topPackageHash) {\r\n                addMethodIfNotExist(methodList, method);\r\n            }\r\n        }\r\n        top = false;\r\n    } while ((clazz = clazz.getSuperclass()) != limit);\r\n    Method[] methods = new Method[methodList.size()];\r\n    for (int i = 0; i < methods.length; i++) {\r\n        methods[i] = methodList.get(i);\r\n    }\r\n    return methods;\r\n}"
}, {
	"Path": "org.jooq.conf.Settings.isReflectionCaching",
	"Comment": "whether reflection information should be cached in the configuration.",
	"Method": "Boolean isReflectionCaching(){\r\n    return reflectionCaching;\r\n}"
}, {
	"Path": "org.joda.time.Seconds.minus",
	"Comment": "returns a new instance with the specified number of seconds taken away.this instance is immutable and unaffected by this method call.",
	"Method": "Seconds minus(int seconds,Seconds minus,Seconds seconds){\r\n    if (seconds == null) {\r\n        return this;\r\n    }\r\n    return minus(seconds.getValue());\r\n}"
}, {
	"Path": "org.joda.time.tz.DateTimeZoneBuilder.addCutover",
	"Comment": "adds a cutover for added rules. the standard offset at the cutoverdefaults to 0. call setstandardoffset afterwards to change it.",
	"Method": "DateTimeZoneBuilder addCutover(int year,char mode,int monthOfYear,int dayOfMonth,int dayOfWeek,boolean advanceDayOfWeek,int millisOfDay){\r\n    if (iRuleSets.size() > 0) {\r\n        OfYear ofYear = new OfYear(mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay);\r\n        RuleSet lastRuleSet = iRuleSets.get(iRuleSets.size() - 1);\r\n        lastRuleSet.setUpperLimit(year, ofYear);\r\n    }\r\n    iRuleSets.add(new RuleSet());\r\n    return this;\r\n}"
}, {
	"Path": "org.jooq.conf.Settings.isAttachRecords",
	"Comment": "whether fetched records should be attached to the fetching configuration.",
	"Method": "Boolean isAttachRecords(){\r\n    return attachRecords;\r\n}"
}, {
	"Path": "org.jooq.impl.DSL.two",
	"Comment": "a 2 literal.this is useful for mathematical functions. the 1 literalwill not generate a bind variable.",
	"Method": "Param<Integer> two(){\r\n    return inline(2);\r\n}"
}, {
	"Path": "org.joda.time.DateTime.withSecondOfMinute",
	"Comment": "returns a copy of this datetime with the second of minute field updated.datetime is immutable, so there are no set methods.instead, this method returns a new instance with the value ofsecond of minute changed.",
	"Method": "DateTime withSecondOfMinute(int second){\r\n    return withMillis(getChronology().secondOfMinute().set(getMillis(), second));\r\n}"
}, {
	"Path": "jodd.petite.scope.SingletonScope.accept",
	"Comment": "allows only singleton scoped beans to be injected into the target singleton bean.",
	"Method": "boolean accept(Scope referenceScope){\r\n    Class<? extends Scope> refScopeType = referenceScope.getClass();\r\n    if (refScopeType == ProtoScope.class) {\r\n        return true;\r\n    }\r\n    if (refScopeType == SingletonScope.class) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.jooq.impl.Limit.isApplicable",
	"Comment": "whether this limit clause is applicable. if false, then nolimit clause should be rendered.",
	"Method": "boolean isApplicable(){\r\n    return offset != null || numberOfRows != null;\r\n}"
}, {
	"Path": "jodd.util.BinarySearch.findLast",
	"Comment": "finds very last index of given element in inclusive index range. returns negative\tvalue if element is not found.",
	"Method": "int findLast(E o,int findLast,E o,int low,int high){\r\n    int ndx = -1;\r\n    while (low <= high) {\r\n        int mid = (low + high) >>> 1;\r\n        int delta = compare(mid, o);\r\n        if (delta > 0) {\r\n            high = mid - 1;\r\n        } else {\r\n            if (delta == 0) {\r\n                ndx = mid;\r\n            }\r\n            low = mid + 1;\r\n        }\r\n    }\r\n    if (ndx == -1) {\r\n        return -(low + 1);\r\n    }\r\n    return ndx;\r\n}"
}, {
	"Path": "org.joda.time.chrono.BasicWeekyearDateTimeField.get",
	"Comment": "get the year of a week based year component of the specified time instant.",
	"Method": "int get(long instant){\r\n    return iChronology.getWeekyear(instant);\r\n}"
}, {
	"Path": "org.joda.time.Period.minusYears",
	"Comment": "returns a new period with the specified number of years taken away.this period instance is immutable and unaffected by this method call.",
	"Method": "Period minusYears(int years){\r\n    return plusYears(-years);\r\n}"
}, {
	"Path": "jodd.htmlstapler.HtmlStaplerBundlesManager.getStaplerPath",
	"Comment": "returns stapler path. it is both the file system folder\tname and the web folder name.",
	"Method": "String getStaplerPath(){\r\n    return staplerPath;\r\n}"
}, {
	"Path": "jodd.jtx.JtxTransactionManager.isValidateExistingTransaction",
	"Comment": "returns whether existing transactions should be validated before participating in them.",
	"Method": "boolean isValidateExistingTransaction(){\r\n    return validateExistingTransaction;\r\n}"
}, {
	"Path": "org.joda.time.MutableInterval.setPeriodBeforeEnd",
	"Comment": "sets the period of this time interval, preserving the end instantand using the isochronology in the default zone for calculations.",
	"Method": "void setPeriodBeforeEnd(ReadablePeriod period){\r\n    if (period == null) {\r\n        setStartMillis(getEndMillis());\r\n    } else {\r\n        setStartMillis(getChronology().add(period, getEndMillis(), -1));\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.base.BasePartial.setValue",
	"Comment": "sets the value of the field at the specified index.in version 2.0 and later, this method copies the array into the original.this is because the instance variable has been changed to be final to satisfy the java memory model.this only impacts subclasses that are mutable.",
	"Method": "void setValue(int index,int value){\r\n    DateTimeField field = getField(index);\r\n    int[] values = field.set(this, index, iValues, value);\r\n    System.arraycopy(values, 0, iValues, 0, iValues.length);\r\n}"
}, {
	"Path": "org.joda.time.Weeks.weeksIn",
	"Comment": "creates a weeks representing the number of whole weeksin the specified interval.",
	"Method": "Weeks weeksIn(ReadableInterval interval){\r\n    if (interval == null) {\r\n        return Weeks.ZERO;\r\n    }\r\n    int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.weeks());\r\n    return Weeks.weeks(amount);\r\n}"
}, {
	"Path": "jodd.asm7.ConstantDynamic.getBootstrapMethodArgument",
	"Comment": "returns an argument passed to the bootstrap method, in order to compute the value of thisconstant.",
	"Method": "Object getBootstrapMethodArgument(int index){\r\n    return bootstrapMethodArguments[index];\r\n}"
}, {
	"Path": "org.joda.time.format.DateTimeFormatterBuilder.appendMinuteOfHour",
	"Comment": "instructs the printer to emit a numeric minuteofhour field.",
	"Method": "DateTimeFormatterBuilder appendMinuteOfHour(int minDigits){\r\n    return appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2);\r\n}"
}, {
	"Path": "org.jooq.impl.Tools.needsBackslashEscaping",
	"Comment": "whether backslash escaping is needed in inlined string literals.",
	"Method": "boolean needsBackslashEscaping(Configuration configuration){\r\n    BackslashEscaping escaping = getBackslashEscaping(configuration.settings());\r\n    return escaping == ON || (escaping == DEFAULT && REQUIRES_BACKSLASH_ESCAPING.contains(configuration.family()));\r\n}"
}, {
	"Path": "org.joda.time.Duration.withDurationAdded",
	"Comment": "returns a new duration with this length plus that specified multiplied by the scalar.this instance is immutable and is not altered.if the addition is zero, this instance is returned.",
	"Method": "Duration withDurationAdded(long durationToAdd,int scalar,Duration withDurationAdded,ReadableDuration durationToAdd,int scalar){\r\n    if (durationToAdd == null || scalar == 0) {\r\n        return this;\r\n    }\r\n    return withDurationAdded(durationToAdd.getMillis(), scalar);\r\n}"
}, {
	"Path": "jodd.madvoc.result.JsonResult.of",
	"Comment": "creates a json response from an exception. response body will have information about the\texception and response status will be set to 500.",
	"Method": "JsonResult of(String json,JsonResult of,Object object,JsonResult of,HttpStatus httpStatus,JsonResult of,Exception exception){\r\n    final HashMap<String, Object> errorMap = new HashMap();\r\n    errorMap.put(\"message\", ExceptionUtil.message(exception));\r\n    errorMap.put(\"error\", exception.getClass().getName());\r\n    errorMap.put(\"cause\", exception.getCause() != null ? exception.getCause().getClass().getName() : null);\r\n    final ArrayList<String> details = new ArrayList();\r\n    final StackTraceElement[] ste = ExceptionUtil.getStackTrace(exception, null, null);\r\n    for (StackTraceElement stackTraceElement : ste) {\r\n        details.add(stackTraceElement.toString());\r\n    }\r\n    errorMap.put(\"details\", details);\r\n    final String json = JsonSerializer.create().deep(true).serialize(errorMap);\r\n    return new JsonResult(json).status(HttpStatus.error500().internalError());\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractInstant.toString",
	"Comment": "uses the specified formatter to convert this partial to a string.",
	"Method": "String toString(String toString,DateTimeFormatter formatter){\r\n    if (formatter == null) {\r\n        return toString();\r\n    }\r\n    return formatter.print(this);\r\n}"
}, {
	"Path": "org.joda.time.format.DateTimeFormatter.withZoneUTC",
	"Comment": "returns a new formatter that will use the utc zone in preferenceto the zone of the printed object, or default zone on a parse.when printing, utc will be used in preference to the zonefrom the datetime that would otherwise be used.when parsing, utc will be set on the parsed datetime.if both an override chronology and an override zone are set, theoverride zone will take precedence over the zone in the chronology.",
	"Method": "DateTimeFormatter withZoneUTC(){\r\n    return withZone(DateTimeZone.UTC);\r\n}"
}, {
	"Path": "jodd.madvoc.component.RootPackages.findPackagePathForActionPackage",
	"Comment": "finds mapping for given action class. returns null\tif no mapping is found. if there is more then one matching root\tpackage, the closest one will be returned.",
	"Method": "String findPackagePathForActionPackage(String actionPackage){\r\n    if (packages == null) {\r\n        return null;\r\n    }\r\n    if (packagePaths == null) {\r\n        packagePaths = new HashMap();\r\n    }\r\n    String packagePath = packagePaths.get(actionPackage);\r\n    if (packagePath != null) {\r\n        return packagePath;\r\n    }\r\n    int ndx = -1;\r\n    int delta = Integer.MAX_VALUE;\r\n    for (int i = 0; i < packages.length; i++) {\r\n        String rootPackage = packages[i];\r\n        if (rootPackage.equals(actionPackage)) {\r\n            ndx = i;\r\n            delta = 0;\r\n            break;\r\n        }\r\n        rootPackage += '.';\r\n        if (actionPackage.startsWith(rootPackage)) {\r\n            int distanceFromTheRoot = actionPackage.length() - rootPackage.length();\r\n            if (distanceFromTheRoot < delta) {\r\n                ndx = i;\r\n                delta = distanceFromTheRoot;\r\n            }\r\n        }\r\n    }\r\n    if (ndx == -1) {\r\n        return null;\r\n    }\r\n    String packageActionPath = delta == 0 ? StringPool.EMPTY : StringUtil.substring(actionPackage, -delta - 1, 0);\r\n    packageActionPath = packageActionPath.replace('.', '/');\r\n    String result = mappings[ndx] + packageActionPath;\r\n    packagePaths.put(actionPackage, result);\r\n    return result;\r\n}"
}, {
	"Path": "org.jsonschema2pojo.Jsonschema2Pojo.generate",
	"Comment": "reads the contents of the given source and initiates schema generation.",
	"Method": "void generate(GenerationConfig config){\r\n    Annotator annotator = getAnnotator(config);\r\n    RuleFactory ruleFactory = createRuleFactory(config);\r\n    ruleFactory.setAnnotator(annotator);\r\n    ruleFactory.setGenerationConfig(config);\r\n    ruleFactory.setSchemaStore(new SchemaStore(createContentResolver(config)));\r\n    SchemaMapper mapper = new SchemaMapper(ruleFactory, createSchemaGenerator(config));\r\n    JCodeModel codeModel = new JCodeModel();\r\n    if (config.isRemoveOldOutput()) {\r\n        removeOldOutput(config.getTargetDirectory());\r\n    }\r\n    for (Iterator<URL> sources = config.getSource(); sources.hasNext(); ) {\r\n        URL source = sources.next();\r\n        if (URLUtil.parseProtocol(source.toString()) == URLProtocol.FILE && URLUtil.getFileFromURL(source).isDirectory()) {\r\n            generateRecursive(config, mapper, codeModel, defaultString(config.getTargetPackage()), Arrays.asList(URLUtil.getFileFromURL(source).listFiles(config.getFileFilter())));\r\n        } else {\r\n            mapper.generate(codeModel, getNodeName(source, config), defaultString(config.getTargetPackage()), source);\r\n        }\r\n    }\r\n    if (config.getTargetDirectory().exists() || config.getTargetDirectory().mkdirs()) {\r\n        if (config.getTargetLanguage() == Language.SCALA) {\r\n            CodeWriter sourcesWriter = new ScalaFileCodeWriter(config.getTargetDirectory(), config.getOutputEncoding());\r\n            CodeWriter resourcesWriter = new FileCodeWriterWithEncoding(config.getTargetDirectory(), config.getOutputEncoding());\r\n            codeModel.build(sourcesWriter, resourcesWriter);\r\n        } else {\r\n            CodeWriter sourcesWriter = new FileCodeWriterWithEncoding(config.getTargetDirectory(), config.getOutputEncoding());\r\n            CodeWriter resourcesWriter = new FileCodeWriterWithEncoding(config.getTargetDirectory(), config.getOutputEncoding());\r\n            codeModel.build(sourcesWriter, resourcesWriter);\r\n        }\r\n    } else {\r\n        throw new GenerationException(\"Could not create or access target directory \" + config.getTargetDirectory().getAbsolutePath());\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.chrono.EthiopicChronology.getInstanceUTC",
	"Comment": "gets an instance of the ethiopicchronology.the time zone of the returned instance is utc.",
	"Method": "EthiopicChronology getInstanceUTC(){\r\n    return INSTANCE_UTC;\r\n}"
}, {
	"Path": "jodd.paramo.Paramo.resolveParameters",
	"Comment": "resolves method parameters from a method or constructor.\treturns an empty array when target does not contain any parameter.\tno caching is involved in this process, i.e. class bytecode\tis examined every time this method is called.",
	"Method": "MethodParameter[] resolveParameters(AccessibleObject methodOrCtor){\r\n    Class[] paramTypes;\r\n    Class declaringClass;\r\n    String name;\r\n    if (methodOrCtor instanceof Method) {\r\n        Method method = (Method) methodOrCtor;\r\n        paramTypes = method.getParameterTypes();\r\n        name = method.getName();\r\n        declaringClass = method.getDeclaringClass();\r\n    } else {\r\n        Constructor constructor = (Constructor) methodOrCtor;\r\n        paramTypes = constructor.getParameterTypes();\r\n        declaringClass = constructor.getDeclaringClass();\r\n        name = CTOR_METHOD;\r\n    }\r\n    if (paramTypes.length == 0) {\r\n        return MethodParameter.EMPTY_ARRAY;\r\n    }\r\n    InputStream stream;\r\n    try {\r\n        stream = ClassLoaderUtil.getClassAsStream(declaringClass);\r\n    } catch (IOException ioex) {\r\n        throw new ParamoException(\"Failed to read class bytes: \" + declaringClass.getName(), ioex);\r\n    }\r\n    if (stream == null) {\r\n        throw new ParamoException(\"Class not found: \" + declaringClass);\r\n    }\r\n    try {\r\n        ClassReader reader = new ClassReader(stream);\r\n        MethodFinder visitor = new MethodFinder(declaringClass, name, paramTypes);\r\n        reader.accept(visitor, 0);\r\n        return visitor.getResolvedParameters();\r\n    } catch (IOException ioex) {\r\n        throw new ParamoException(ioex);\r\n    } finally {\r\n        StreamUtil.close(stream);\r\n    }\r\n}"
}, {
	"Path": "org.jooq.impl.DSL.defaultValue",
	"Comment": "create a default keyword for use with insert,update, or merge statements.",
	"Method": "Field<Object> defaultValue(Field<T> defaultValue,Class<T> type,Field<T> defaultValue,DataType<T> type,Field<T> defaultValue,Field<T> field){\r\n    return new SQLField<T>(field.getDataType(), keyword(\"default\"));\r\n}"
}, {
	"Path": "jodd.lagarto.dom.Node.getChildElement",
	"Comment": "returns a child element node at given index.\tif index is out of bounds, null is returned.",
	"Method": "Element getChildElement(int index){\r\n    initChildElementNodes();\r\n    if ((index < 0) || (index >= childElementNodes.length)) {\r\n        return null;\r\n    }\r\n    return childElementNodes[index];\r\n}"
}, {
	"Path": "jodd.db.DbQueryBase.autoClose",
	"Comment": "defines that query should be automatically closed immediately after using.\tshould be called before actual statement execution.",
	"Method": "Q autoClose(){\r\n    autoClose = true;\r\n    return _this();\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Configuration.getJdbc",
	"Comment": "the jdbc configuration element contains information about how to set up the database connection used for source code generation.",
	"Method": "Jdbc getJdbc(){\r\n    return jdbc;\r\n}"
}, {
	"Path": "jodd.props.Props.setIgnorePrefixWhitespacesOnNewLine",
	"Comment": "defines if the prefix whitespaces should be ignored when value is split into the lines.",
	"Method": "Props setIgnorePrefixWhitespacesOnNewLine(boolean ignorePrefixWhitespacesOnNewLine){\r\n    parser.ignorePrefixWhitespacesOnNewLine = ignorePrefixWhitespacesOnNewLine;\r\n    return this;\r\n}"
}, {
	"Path": "org.joda.time.chrono.LimitChronology.withUTC",
	"Comment": "if this limitchronology is already utc, then this isreturned. otherwise, a new instance is returned, with the limitsadjusted to the new time zone.",
	"Method": "Chronology withUTC(){\r\n    return withZone(DateTimeZone.UTC);\r\n}"
}, {
	"Path": "org.joda.time.PeriodType.yearDayTime",
	"Comment": "gets a type that defines all standard fields except months and weeks.yearsdayshoursminutessecondsmilliseconds",
	"Method": "PeriodType yearDayTime(){\r\n    PeriodType type = cYDTime;\r\n    if (type == null) {\r\n        type = new PeriodType(\"YearDayTime\", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.days(), DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { 0, -1, -1, 1, 2, 3, 4, 5 });\r\n        cYDTime = type;\r\n    }\r\n    return type;\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.MediaStream.setOutputStream",
	"Comment": "if a tcp is used as the transport protocol for the rtp session,\tthe output stream to which rtp packets will be written to must\tbe specified with this method.",
	"Method": "void setOutputStream(OutputStream stream,byte channelIdentifier){\r\n    mOutputStream = stream;\r\n    mChannelIdentifier = channelIdentifier;\r\n}"
}, {
	"Path": "jodd.io.findfile.ClassScanner.scanJarFile",
	"Comment": "scans classes inside single jar archive. archive is scanned as a zip file.",
	"Method": "void scanJarFile(File file){\r\n    final ZipFile zipFile;\r\n    try {\r\n        zipFile = new ZipFile(file);\r\n    } catch (IOException ioex) {\r\n        if (!ignoreException) {\r\n            throw new FindFileException(\"Invalid zip: \" + file.getName(), ioex);\r\n        }\r\n        return;\r\n    }\r\n    final Enumeration entries = zipFile.entries();\r\n    while (entries.hasMoreElements()) {\r\n        final ZipEntry zipEntry = (ZipEntry) entries.nextElement();\r\n        final String zipEntryName = zipEntry.getName();\r\n        try {\r\n            if (StringUtil.endsWithIgnoreCase(zipEntryName, CLASS_FILE_EXT)) {\r\n                final String entryName = prepareEntryName(zipEntryName, true);\r\n                final ClassPathEntry classPathEntry = new ClassPathEntry(entryName, zipFile, zipEntry);\r\n                try {\r\n                    scanEntry(classPathEntry);\r\n                } finally {\r\n                    classPathEntry.closeInputStream();\r\n                }\r\n            } else if (includeResources) {\r\n                final String entryName = prepareEntryName(zipEntryName, false);\r\n                final ClassPathEntry classPathEntry = new ClassPathEntry(entryName, zipFile, zipEntry);\r\n                try {\r\n                    scanEntry(classPathEntry);\r\n                } finally {\r\n                    classPathEntry.closeInputStream();\r\n                }\r\n            }\r\n        } catch (RuntimeException rex) {\r\n            if (!ignoreException) {\r\n                ZipUtil.close(zipFile);\r\n                throw rex;\r\n            }\r\n        }\r\n    }\r\n    ZipUtil.close(zipFile);\r\n}"
}, {
	"Path": "org.joda.time.DateMidnight.withCenturyOfEra",
	"Comment": "returns a copy of this date with the century of era field updated.datemidnight is immutable, so there are no set methods.instead, this method returns a new instance with the value ofcentury of era changed.",
	"Method": "DateMidnight withCenturyOfEra(int centuryOfEra){\r\n    return withMillis(getChronology().centuryOfEra().set(getMillis(), centuryOfEra));\r\n}"
}, {
	"Path": "jodd.typeconverter.impl.CollectionConverter.convertCollectionToCollection",
	"Comment": "converts collection value to target collection.\teach element is converted to target component type.",
	"Method": "Collection<T> convertCollectionToCollection(Collection value){\r\n    Collection<T> collection = createCollection(value.size());\r\n    for (Object v : value) {\r\n        collection.add(convertType(v));\r\n    }\r\n    return collection;\r\n}"
}, {
	"Path": "org.joda.time.format.DateTimeFormatter.getPrinter",
	"Comment": "gets the internal printer object that performs the real printing work.",
	"Method": "DateTimePrinter getPrinter(){\r\n    return InternalPrinterDateTimePrinter.of(iPrinter);\r\n}"
}, {
	"Path": "org.joda.time.chrono.GJChronology.getMinimumDaysInFirstWeek",
	"Comment": "gets the minimum days needed for a week to be the first week in a year.",
	"Method": "int getMinimumDaysInFirstWeek(){\r\n    return iGregorianChronology.getMinimumDaysInFirstWeek();\r\n}"
}, {
	"Path": "jodd.decora.DecoraServletFilter.createDecoraParser",
	"Comment": "creates decora parser. override to provide custom decora parser.",
	"Method": "DecoraParser createDecoraParser(){\r\n    return new DecoraParser();\r\n}"
}, {
	"Path": "org.joda.time.chrono.BasicChronology.getDaysInMonthMax",
	"Comment": "gets the maximum number of days in the month specified by the instant.",
	"Method": "int getDaysInMonthMax(int getDaysInMonthMax,long instant,int getDaysInMonthMax,int month){\r\n    int thisYear = getYear(instant);\r\n    int thisMonth = getMonthOfYear(instant, thisYear);\r\n    return getDaysInYearMonth(thisYear, thisMonth);\r\n}"
}, {
	"Path": "org.joda.time.TestDateTimeComparator.testMillis",
	"Comment": "test unequal comparisons with millis of second comparators.",
	"Method": "void testMillis(){\r\n    aDateTime = new DateTime(System.currentTimeMillis(), DateTimeZone.UTC);\r\n    bDateTime = new DateTime(aDateTime.getMillis() + 1, DateTimeZone.UTC);\r\n    assertEquals(\"MillisM1\", -1, cMillis.compare(aDateTime, bDateTime));\r\n    assertEquals(\"MillisP1\", 1, cMillis.compare(bDateTime, aDateTime));\r\n}"
}, {
	"Path": "jodd.db.oom.sqlgen.chunks.SqlChunk.lookupTableRef",
	"Comment": "lookups for table reference and optionally throws an exception if table reference not found.",
	"Method": "DbEntityDescriptor lookupTableRef(String tableRef,DbEntityDescriptor lookupTableRef,String tableRef,boolean throwExceptionIfNotFound){\r\n    DbEntityDescriptor ded = templateData.getTableDescriptor(tableRef);\r\n    if (ded == null) {\r\n        if (throwExceptionIfNotFound) {\r\n            throw new DbSqlBuilderException(\"Invalid table reference: \" + tableRef);\r\n        }\r\n    }\r\n    return ded;\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.minuteOfHour",
	"Comment": "get the minute of hour field property which provides access to advanced functionality.",
	"Method": "Property minuteOfHour(){\r\n    return new Property(this, getChronology().minuteOfHour());\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.hw.CodecManager.findEncodersForMimeType",
	"Comment": "lists all encoders that claim to support a color format that we know how to use.",
	"Method": "Codec[] findEncodersForMimeType(String mimeType){\r\n    if (sEncoders != null)\r\n        return sEncoders;\r\n    ArrayList<Codec> encoders = new ArrayList();\r\n    for (int j = MediaCodecList.getCodecCount() - 1; j >= 0; j--) {\r\n        MediaCodecInfo codecInfo = MediaCodecList.getCodecInfoAt(j);\r\n        if (!codecInfo.isEncoder())\r\n            continue;\r\n        String[] types = codecInfo.getSupportedTypes();\r\n        for (int i = 0; i < types.length; i++) {\r\n            if (types[i].equalsIgnoreCase(mimeType)) {\r\n                try {\r\n                    MediaCodecInfo.CodecCapabilities capabilities = codecInfo.getCapabilitiesForType(mimeType);\r\n                    Set<Integer> formats = new HashSet();\r\n                    for (int k = 0; k < capabilities.colorFormats.length; k++) {\r\n                        int format = capabilities.colorFormats[k];\r\n                        for (int l = 0; l < SUPPORTED_COLOR_FORMATS.length; l++) {\r\n                            if (format == SUPPORTED_COLOR_FORMATS[l]) {\r\n                                formats.add(format);\r\n                            }\r\n                        }\r\n                    }\r\n                    Codec codec = new Codec(codecInfo.getName(), (Integer[]) formats.toArray(new Integer[formats.size()]));\r\n                    encoders.add(codec);\r\n                } catch (Exception e) {\r\n                    Log.wtf(TAG, e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    sEncoders = (Codec[]) encoders.toArray(new Codec[encoders.size()]);\r\n    return sEncoders;\r\n}"
}, {
	"Path": "jodd.petite.ParamManager.filterParametersForBeanName",
	"Comment": "returns an array of param keys that belongs to provided bean.\toptionally resolves the value of returned parameters.",
	"Method": "String[] filterParametersForBeanName(String beanName,boolean resolveReferenceParams){\r\n    beanName = beanName + '.';\r\n    List<String> list = new ArrayList();\r\n    for (Map.Entry<String, Object> entry : params.entrySet()) {\r\n        String key = entry.getKey();\r\n        if (!key.startsWith(beanName)) {\r\n            continue;\r\n        }\r\n        list.add(key);\r\n        if (!resolveReferenceParams) {\r\n            continue;\r\n        }\r\n        String value = PropertiesUtil.resolveProperty(params, key);\r\n        entry.setValue(value);\r\n    }\r\n    if (list.isEmpty()) {\r\n        return StringPool.EMPTY_ARRAY;\r\n    } else {\r\n        return list.toArray(new String[0]);\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.field.OffsetDateTimeField.set",
	"Comment": "set the specified amount of offset units to the specified time instant.",
	"Method": "long set(long instant,int value){\r\n    FieldUtils.verifyValueBounds(this, value, iMin, iMax);\r\n    return super.set(instant, value - iOffset);\r\n}"
}, {
	"Path": "org.joda.time.Hours.toStandardSeconds",
	"Comment": "converts this period in hours to a period in seconds assuming a60 minute hour and 60 second minute.this method allows you to convert between different types of period.however to achieve this it makes the assumption that all hours are60 minutes long and all minutes are 60 seconds long.this may not be true for some unusual chronologies. however, it is includedas it is a useful operation for many applications and business rules.",
	"Method": "Seconds toStandardSeconds(){\r\n    return Seconds.seconds(FieldUtils.safeMultiply(getValue(), DateTimeConstants.SECONDS_PER_HOUR));\r\n}"
}, {
	"Path": "jodd.jerry.Jerry.html",
	"Comment": "sets the html contents of each element in the set of matched elements.",
	"Method": "String html(Jerry html,String html){\r\n    if (html == null) {\r\n        html = StringPool.EMPTY;\r\n    }\r\n    final Document doc = builder.parse(html);\r\n    if (nodes.length == 0) {\r\n        return this;\r\n    }\r\n    for (Node node : nodes) {\r\n        node.removeAllChilds();\r\n        Document workingDoc = doc.clone();\r\n        node.addChild(workingDoc.getChildNodes());\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.jooq.conf.Settings.setRenderScalarSubqueriesForStoredFunctions",
	"Comment": "sets the value of the renderscalarsubqueriesforstoredfunctions property.",
	"Method": "void setRenderScalarSubqueriesForStoredFunctions(Boolean value){\r\n    this.renderScalarSubqueriesForStoredFunctions = value;\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.video.H263Stream.getSessionDescription",
	"Comment": "returns a description of the stream using sdp. it can then be included in an sdp file.",
	"Method": "String getSessionDescription(){\r\n    return \"m=video \" + String.valueOf(getDestinationPorts()[0]) + \" RTP/AVP 96\\r\\n\" + \"a=rtpmap:96 H263-1998/90000\\r\\n\";\r\n}"
}, {
	"Path": "jodd.introspector.PropertyDescriptor.getFieldDescriptor",
	"Comment": "returns the associated field of this property.\tmay be null if properties are not enhanced by field description.",
	"Method": "FieldDescriptor getFieldDescriptor(){\r\n    return fieldDescriptor;\r\n}"
}, {
	"Path": "org.joda.time.DateTimeZone.getMillisKeepLocal",
	"Comment": "gets the millisecond instant in another zone keeping the same local time.the conversion is performed by converting the specified utc millis to localmillis in this zone, then converting back to utc millis in the new zone.",
	"Method": "long getMillisKeepLocal(DateTimeZone newZone,long oldInstant){\r\n    if (newZone == null) {\r\n        newZone = DateTimeZone.getDefault();\r\n    }\r\n    if (newZone == this) {\r\n        return oldInstant;\r\n    }\r\n    long instantLocal = convertUTCToLocal(oldInstant);\r\n    return newZone.convertLocalToUTC(instantLocal, false, oldInstant);\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.withYearOfEra",
	"Comment": "returns a copy of this datetime with the year of era field updated.localdatetime is immutable, so there are no set methods.instead, this method returns a new instance with the value ofyear of era changed.",
	"Method": "LocalDateTime withYearOfEra(int yearOfEra){\r\n    return withLocalMillis(getChronology().yearOfEra().set(getLocalMillis(), yearOfEra));\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Generate.setDeprecationOnUnknownTypes",
	"Comment": "sets the value of the deprecationonunknowntypes property.",
	"Method": "void setDeprecationOnUnknownTypes(Boolean value){\r\n    this.deprecationOnUnknownTypes = value;\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.Session.setTimeToLive",
	"Comment": "set the ttl of all packets sent during the session. \tchanges will be taken into account the next time you start the session.",
	"Method": "void setTimeToLive(int ttl){\r\n    mTimeToLive = ttl;\r\n}"
}, {
	"Path": "jodd.io.FileUtil.checkDirCopy",
	"Comment": "checks that srcdir exists, that it is a directory and if srcdir and destdir are not equal.",
	"Method": "void checkDirCopy(File srcDir,File destDir){\r\n    checkExists(srcDir);\r\n    checkIsDirectory(srcDir);\r\n    if (equals(srcDir, destDir)) {\r\n        throw new IOException(\"Source '\" + srcDir + \"' and destination '\" + destDir + \"' are equal\");\r\n    }\r\n}"
}, {
	"Path": "jodd.proxetta.ProxyTarget.targetMethodDescription",
	"Comment": "inserts target method description, bytecode alike, without method name.\tmay be used for identifying the method.",
	"Method": "String targetMethodDescription(){\r\n    throw new ProxettaException();\r\n}"
}, {
	"Path": "org.joda.time.Months.months",
	"Comment": "obtains an instance of months that may be cached.months is immutable, so instances can be cached and shared.this factory method provides access to shared instances.",
	"Method": "Months months(int months){\r\n    switch(months) {\r\n        case 0:\r\n            return ZERO;\r\n        case 1:\r\n            return ONE;\r\n        case 2:\r\n            return TWO;\r\n        case 3:\r\n            return THREE;\r\n        case 4:\r\n            return FOUR;\r\n        case 5:\r\n            return FIVE;\r\n        case 6:\r\n            return SIX;\r\n        case 7:\r\n            return SEVEN;\r\n        case 8:\r\n            return EIGHT;\r\n        case 9:\r\n            return NINE;\r\n        case 10:\r\n            return TEN;\r\n        case 11:\r\n            return ELEVEN;\r\n        case 12:\r\n            return TWELVE;\r\n        case Integer.MAX_VALUE:\r\n            return MAX_VALUE;\r\n        case Integer.MIN_VALUE:\r\n            return MIN_VALUE;\r\n        default:\r\n            return new Months(months);\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.format.DateTimeFormatterBuilder.appendClockhourOfDay",
	"Comment": "instructs the printer to emit a numeric clockhourofday field.",
	"Method": "DateTimeFormatterBuilder appendClockhourOfDay(int minDigits){\r\n    return appendDecimal(DateTimeFieldType.clockhourOfDay(), minDigits, 2);\r\n}"
}, {
	"Path": "jodd.introspector.MethodDescriptor.getRawReturnComponentType",
	"Comment": "returns raw component type of return type.\tmay be null if return type does not have\tcomponents.",
	"Method": "Class getRawReturnComponentType(){\r\n    return rawReturnComponentType;\r\n}"
}, {
	"Path": "com.jayway.jsonpath.Criteria.and",
	"Comment": "static factory method to create a criteria using the provided key",
	"Method": "Criteria and(String key){\r\n    checkComplete();\r\n    return new Criteria(this.criteriaChain, ValueNode.toValueNode(prefixPath(key)));\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.rtp.RtpSocket.run",
	"Comment": "the thread sends the packets in the fifo one by one at a constant rate.",
	"Method": "void run(){\r\n    Statistics stats = new Statistics(50, 3000);\r\n    try {\r\n        Thread.sleep(mCacheSize);\r\n        long delta = 0;\r\n        while (mBufferCommitted.tryAcquire(4, TimeUnit.SECONDS)) {\r\n            if (mOldTimestamp != 0) {\r\n                if ((mTimestamps[mBufferOut] - mOldTimestamp) > 0) {\r\n                    stats.push(mTimestamps[mBufferOut] - mOldTimestamp);\r\n                    long d = stats.average() / 1000000;\r\n                    if (mCacheSize > 0)\r\n                        Thread.sleep(d);\r\n                } else if ((mTimestamps[mBufferOut] - mOldTimestamp) < 0) {\r\n                    Log.e(TAG, \"TS: \" + mTimestamps[mBufferOut] + \" OLD: \" + mOldTimestamp);\r\n                }\r\n                delta += mTimestamps[mBufferOut] - mOldTimestamp;\r\n                if (delta > 500000000 || delta < 0) {\r\n                    delta = 0;\r\n                }\r\n            }\r\n            mReport.update(mPackets[mBufferOut].getLength(), (mTimestamps[mBufferOut] / 100L) * (mClock / 1000L) / 10000L);\r\n            mOldTimestamp = mTimestamps[mBufferOut];\r\n            if (mCount++ > 30) {\r\n                if (mTransport == TRANSPORT_UDP) {\r\n                    mSocket.send(mPackets[mBufferOut]);\r\n                } else {\r\n                    sendTCP();\r\n                }\r\n            }\r\n            if (++mBufferOut >= mBufferCount)\r\n                mBufferOut = 0;\r\n            mBufferRequested.release();\r\n        }\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n    mThread = null;\r\n    resetFifo();\r\n}"
}, {
	"Path": "org.joda.time.TimeOfDay.withChronologyRetainFields",
	"Comment": "returns a copy of this time with the specified chronology.this instance is immutable and unaffected by this method call.this method retains the values of the fields, thus the result willtypically refer to a different instant.the time zone of the specified chronology is ignored, as timeofdayoperates without a time zone.",
	"Method": "TimeOfDay withChronologyRetainFields(Chronology newChronology){\r\n    newChronology = DateTimeUtils.getChronology(newChronology);\r\n    newChronology = newChronology.withUTC();\r\n    if (newChronology == getChronology()) {\r\n        return this;\r\n    } else {\r\n        TimeOfDay newTimeOfDay = new TimeOfDay(this, newChronology);\r\n        newChronology.validate(newTimeOfDay, getValues());\r\n        return newTimeOfDay;\r\n    }\r\n}"
}, {
	"Path": "jodd.util.ClassUtil.getBeanPropertySetterName",
	"Comment": "returns beans property setter name or null if method is not a real setter.",
	"Method": "String getBeanPropertySetterName(Method method){\r\n    int prefixLength = getBeanPropertySetterPrefixLength(method);\r\n    if (prefixLength == 0) {\r\n        return null;\r\n    }\r\n    String methodName = method.getName().substring(prefixLength);\r\n    return StringUtil.decapitalize(methodName);\r\n}"
}, {
	"Path": "org.joda.time.LocalDate.centuryOfEra",
	"Comment": "get the century of era property which provides access to advanced functionality.",
	"Method": "Property centuryOfEra(){\r\n    return new Property(this, getChronology().centuryOfEra());\r\n}"
}, {
	"Path": "jodd.asm7.Frame.setLocal",
	"Comment": "replaces the abstract type stored at the given local variable index in the output frame.",
	"Method": "void setLocal(int localIndex,int abstractType){\r\n    if (outputLocals == null) {\r\n        outputLocals = new int[10];\r\n    }\r\n    int outputLocalsLength = outputLocals.length;\r\n    if (localIndex >= outputLocalsLength) {\r\n        int[] newOutputLocals = new int[Math.max(localIndex + 1, 2 * outputLocalsLength)];\r\n        System.arraycopy(outputLocals, 0, newOutputLocals, 0, outputLocalsLength);\r\n        outputLocals = newOutputLocals;\r\n    }\r\n    outputLocals[localIndex] = abstractType;\r\n}"
}, {
	"Path": "jodd.joy.page.DbPager.getDefaultPageRequest",
	"Comment": "returns default page request when passed one is null.\tthis usually happens on initial page view, when no page request is created.\treturned pagerequest defines global defaults.",
	"Method": "PageRequest getDefaultPageRequest(){\r\n    return new PageRequest();\r\n}"
}, {
	"Path": "jodd.time.TimeUtil.toMilliseconds",
	"Comment": "converts local date time to epoh milliseconds assuming start of the day as time point.",
	"Method": "long toMilliseconds(LocalDateTime localDateTime,long toMilliseconds,LocalDate localDate){\r\n    return toMilliseconds(localDate.atStartOfDay());\r\n}"
}, {
	"Path": "org.json.CDL.rowToJSONArray",
	"Comment": "produce a jsonarray of strings from a row of comma delimited values.",
	"Method": "JSONArray rowToJSONArray(JSONTokener x){\r\n    JSONArray ja = new JSONArray();\r\n    for (; ; ) {\r\n        String value = getValue(x);\r\n        char c = x.next();\r\n        if (value == null || (ja.length() == 0 && value.length() == 0 && c != ',')) {\r\n            return null;\r\n        }\r\n        ja.put(value);\r\n        for (; ; ) {\r\n            if (c == ',') {\r\n                break;\r\n            }\r\n            if (c != ' ') {\r\n                if (c == '\\n' || c == '\\r' || c == 0) {\r\n                    return ja;\r\n                }\r\n                throw x.syntaxError(\"Bad character '\" + c + \"' (\" + (int) c + \").\");\r\n            }\r\n            c = x.next();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.DateTimeComparator.getLowerLimit",
	"Comment": "gets the field type that represents the lower limit of comparison.",
	"Method": "DateTimeFieldType getLowerLimit(){\r\n    return iLowerLimit;\r\n}"
}, {
	"Path": "org.joda.time.Days.toStandardSeconds",
	"Comment": "converts this period in days to a period in seconds assuming a24 hour day, 60 minute hour and 60 second minute.this method allows you to convert between different types of period.however to achieve this it makes the assumption that all days are 24 hourslong, all hours are 60 minutes long and all minutes are 60 seconds long.this is not true when daylight savings is considered and may also notbe true for some unusual chronologies. however, it is includedas it is a useful operation for many applications and business rules.",
	"Method": "Seconds toStandardSeconds(){\r\n    return Seconds.seconds(FieldUtils.safeMultiply(getValue(), DateTimeConstants.SECONDS_PER_DAY));\r\n}"
}, {
	"Path": "org.joda.time.DateMidnight.withDayOfMonth",
	"Comment": "returns a copy of this date with the day of month field updated.datemidnight is immutable, so there are no set methods.instead, this method returns a new instance with the value ofday of month changed.",
	"Method": "DateMidnight withDayOfMonth(int dayOfMonth){\r\n    return withMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth));\r\n}"
}, {
	"Path": "jodd.asm7.MethodVisitor.visitFieldInsn",
	"Comment": "visits a field instruction. a field instruction is an instruction that loads or stores thevalue of a field of an object.",
	"Method": "void visitFieldInsn(int opcode,String owner,String name,String descriptor){\r\n    if (mv != null) {\r\n        mv.visitFieldInsn(opcode, owner, name, descriptor);\r\n    }\r\n}"
}, {
	"Path": "jodd.net.URLCoder.build",
	"Comment": "creates url builder with given path that can be optionally encoded.\tsince most of the time path is valid and does not require to be encoded,\tuse this method to gain some performance. when encoding flag is turned off,\tprovided path is used without processing.\tthe purpose of builder is to help with query parameters. all other uri parts\tshould be set previously or after the url is built.",
	"Method": "Builder build(String path,Builder build,String path,boolean encodePath){\r\n    return new Builder(path, encodePath, JoddCore.encoding);\r\n}"
}, {
	"Path": "org.jooq.CSVFormat.header",
	"Comment": "whether to emit a header row with column names, defaulting totrue.",
	"Method": "CSVFormat header(boolean newHeader,boolean header){\r\n    return header;\r\n}"
}, {
	"Path": "org.joda.time.MutableDateTime.setChronology",
	"Comment": "set the chronology of the datetime.all changes to the chronology occur via this method.",
	"Method": "void setChronology(Chronology chronology){\r\n    super.setChronology(chronology);\r\n}"
}, {
	"Path": "jodd.servlet.wrapper.BufferResponseWrapper.getBufferContentAsChars",
	"Comment": "returns buffered content as chars, no matter if stream or writer is used.\treturns null if buffering was not enabled.",
	"Method": "char[] getBufferContentAsChars(){\r\n    if (buffer == null) {\r\n        return null;\r\n    }\r\n    if (!buffer.isUsingStream()) {\r\n        return buffer.toCharArray();\r\n    }\r\n    byte[] content = buffer.toByteArray();\r\n    String encoding = getContentTypeEncoding();\r\n    if (encoding == null) {\r\n        return CharUtil.toCharArray(content);\r\n    } else {\r\n        return CharUtil.toCharArray(content, encoding);\r\n    }\r\n}"
}, {
	"Path": "jodd.asm7.ConstantDynamic.getBootstrapMethod",
	"Comment": "returns the bootstrap method used to compute the value of this constant.",
	"Method": "Handle getBootstrapMethod(){\r\n    return bootstrapMethod;\r\n}"
}, {
	"Path": "org.jooq.tools.reflect.Reflect.as",
	"Comment": "create a proxy for the wrapped object allowing to typesafely invokemethods on it using a custom interface",
	"Method": "P as(Class<P> proxyType){\r\n    final boolean isMap = (object instanceof Map);\r\n    final InvocationHandler handler = new InvocationHandler() {\r\n        @Override\r\n        @SuppressWarnings(\"null\")\r\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n            String name = method.getName();\r\n            try {\r\n                return on(type, object).call(name, args).get();\r\n            } catch (ReflectException e) {\r\n                if (isMap) {\r\n                    Map<String, Object> map = (Map<String, Object>) object;\r\n                    int length = (args == null ? 0 : args.length);\r\n                    if (length == 0 && name.startsWith(\"get\")) {\r\n                        return map.get(property(name.substring(3)));\r\n                    } else if (length == 0 && name.startsWith(\"is\")) {\r\n                        return map.get(property(name.substring(2)));\r\n                    } else if (length == 1 && name.startsWith(\"set\")) {\r\n                        map.put(property(name.substring(3)), args[0]);\r\n                        return null;\r\n                    }\r\n                }\r\n                if (method.isDefault()) {\r\n                    if (CACHED_LOOKUP_CONSTRUCTOR == null) {\r\n                        return MethodHandles.privateLookupIn(proxyType, MethodHandles.lookup()).in(proxyType).unreflectSpecial(method, proxyType).bindTo(proxy).invokeWithArguments(args);\r\n                    }\r\n                    return CACHED_LOOKUP_CONSTRUCTOR.newInstance(proxyType).unreflectSpecial(method, proxyType).bindTo(proxy).invokeWithArguments(args);\r\n                }\r\n                throw e;\r\n            }\r\n        }\r\n    };\r\n    return (P) Proxy.newProxyInstance(proxyType.getClassLoader(), new Class[] { proxyType }, handler);\r\n}"
}, {
	"Path": "org.jooq.tools.reflect.Reflect.as",
	"Comment": "create a proxy for the wrapped object allowing to typesafely invokemethods on it using a custom interface",
	"Method": "P as(Class<P> proxyType){\r\n    String name = method.getName();\r\n    try {\r\n        return on(type, object).call(name, args).get();\r\n    } catch (ReflectException e) {\r\n        if (isMap) {\r\n            Map<String, Object> map = (Map<String, Object>) object;\r\n            int length = (args == null ? 0 : args.length);\r\n            if (length == 0 && name.startsWith(\"get\")) {\r\n                return map.get(property(name.substring(3)));\r\n            } else if (length == 0 && name.startsWith(\"is\")) {\r\n                return map.get(property(name.substring(2)));\r\n            } else if (length == 1 && name.startsWith(\"set\")) {\r\n                map.put(property(name.substring(3)), args[0]);\r\n                return null;\r\n            }\r\n        }\r\n        if (method.isDefault()) {\r\n            if (CACHED_LOOKUP_CONSTRUCTOR == null) {\r\n                return MethodHandles.privateLookupIn(proxyType, MethodHandles.lookup()).in(proxyType).unreflectSpecial(method, proxyType).bindTo(proxy).invokeWithArguments(args);\r\n            }\r\n            return CACHED_LOOKUP_CONSTRUCTOR.newInstance(proxyType).unreflectSpecial(method, proxyType).bindTo(proxy).invokeWithArguments(args);\r\n        }\r\n        throw e;\r\n    }\r\n}"
}, {
	"Path": "jodd.joy.auth.AuthAction.loginViaRequestParams",
	"Comment": "tries to login user with form data. returns session object, otherwise returns null.",
	"Method": "T loginViaRequestParams(HttpServletRequest servletRequest){\r\n    final String username = servletRequest.getParameter(PARAM_USERNAME).trim();\r\n    if (StringUtil.isEmpty(username)) {\r\n        return null;\r\n    }\r\n    final String password = servletRequest.getParameter(PARAM_PASSWORD).trim();\r\n    return userAuth.login(username, password);\r\n}"
}, {
	"Path": "org.joda.time.Period.withSeconds",
	"Comment": "returns a new period with the specified number of seconds.this period instance is immutable and unaffected by this method call.",
	"Method": "Period withSeconds(int seconds){\r\n    int[] values = getValues();\r\n    getPeriodType().setIndexedField(this, PeriodType.SECOND_INDEX, values, seconds);\r\n    return new Period(values, getPeriodType());\r\n}"
}, {
	"Path": "org.joda.time.TimeOfDay.secondOfMinute",
	"Comment": "get the second of minute field property which provides access to advanced functionality.",
	"Method": "Property secondOfMinute(){\r\n    return new Property(this, SECOND_OF_MINUTE);\r\n}"
}, {
	"Path": "org.jooq.conf.Settings.getParamCastMode",
	"Comment": "whether rendered bind values should be cast to their respective type.",
	"Method": "ParamCastMode getParamCastMode(){\r\n    return paramCastMode;\r\n}"
}, {
	"Path": "jodd.jtx.worker.LeanJtxWorker.markOrRollbackTransaction",
	"Comment": "rollbacks transaction if created in the same scope where this method is invoked.\tif not, current transaction is marked for rollback.\treturns true if transaction was actually roll backed.",
	"Method": "boolean markOrRollbackTransaction(JtxTransaction tx,Throwable cause){\r\n    if (tx == null) {\r\n        tx = getCurrentTransaction();\r\n        if (tx == null) {\r\n            return false;\r\n        }\r\n        log.debug(\"set rollback only tx\");\r\n        tx.setRollbackOnly(cause);\r\n        return false;\r\n    }\r\n    log.debug(\"rollback tx\");\r\n    tx.rollback();\r\n    return true;\r\n}"
}, {
	"Path": "jodd.db.DbQueryBase.setMaxRows",
	"Comment": "sets the limit for the maximum number of rows that any resultset object can contain to the given number.\tif the limit is exceeded, the excess rows are silently dropped. zero means there is no limit.",
	"Method": "Q setMaxRows(int maxRows){\r\n    checkNotClosed();\r\n    this.maxRows = maxRows;\r\n    if (statement != null) {\r\n        try {\r\n            statement.setMaxRows(maxRows);\r\n        } catch (SQLException sex) {\r\n            throw new DbSqlException(this, \"Unable to set max rows: \" + maxRows, sex);\r\n        }\r\n    }\r\n    return _this();\r\n}"
}, {
	"Path": "jodd.asm7.ByteVector.putLong",
	"Comment": "puts a long into this byte vector. the byte vector is automatically enlarged if necessary.",
	"Method": "ByteVector putLong(long longValue){\r\n    int currentLength = length;\r\n    if (currentLength + 8 > data.length) {\r\n        enlarge(8);\r\n    }\r\n    byte[] currentData = data;\r\n    int intValue = (int) (longValue >>> 32);\r\n    currentData[currentLength++] = (byte) (intValue >>> 24);\r\n    currentData[currentLength++] = (byte) (intValue >>> 16);\r\n    currentData[currentLength++] = (byte) (intValue >>> 8);\r\n    currentData[currentLength++] = (byte) intValue;\r\n    intValue = (int) longValue;\r\n    currentData[currentLength++] = (byte) (intValue >>> 24);\r\n    currentData[currentLength++] = (byte) (intValue >>> 16);\r\n    currentData[currentLength++] = (byte) (intValue >>> 8);\r\n    currentData[currentLength++] = (byte) intValue;\r\n    length = currentLength;\r\n    return this;\r\n}"
}, {
	"Path": "org.joda.time.TimeOfDay.getField",
	"Comment": "gets the field for a specific index in the chronology specified.this method must not use any instance variables.",
	"Method": "DateTimeField getField(int index,Chronology chrono,DateTimeField getField){\r\n    switch(index) {\r\n        case HOUR_OF_DAY:\r\n            return chrono.hourOfDay();\r\n        case MINUTE_OF_HOUR:\r\n            return chrono.minuteOfHour();\r\n        case SECOND_OF_MINUTE:\r\n            return chrono.secondOfMinute();\r\n        case MILLIS_OF_SECOND:\r\n            return chrono.millisOfSecond();\r\n        default:\r\n            throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\r\n    }\r\n}"
}, {
	"Path": "jodd.util.Format.alignLeftAndPad",
	"Comment": "puts the text to the left and pads with spaces until the size is reached.",
	"Method": "String alignLeftAndPad(String text,int size){\r\n    int textLength = text.length();\r\n    if (textLength > size) {\r\n        return text.substring(0, size);\r\n    }\r\n    final StringBuilder sb = new StringBuilder(size);\r\n    sb.append(text);\r\n    while (textLength++ < size) {\r\n        sb.append(' ');\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "jodd.asm7.Attribute.getAttributeCount",
	"Comment": "returns the number of attributes of the attribute list that begins with this attribute.",
	"Method": "int getAttributeCount(){\r\n    int count = 0;\r\n    Attribute attribute = this;\r\n    while (attribute != null) {\r\n        count += 1;\r\n        attribute = attribute.nextAttribute;\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "org.json.JSONArray.toJSONObject",
	"Comment": "produce a jsonobject by combining a jsonarray of names with the values ofthis jsonarray.",
	"Method": "JSONObject toJSONObject(JSONArray names){\r\n    if (names == null || names.isEmpty() || this.isEmpty()) {\r\n        return null;\r\n    }\r\n    JSONObject jo = new JSONObject(names.length());\r\n    for (int i = 0; i < names.length(); i += 1) {\r\n        jo.put(names.getString(i), this.opt(i));\r\n    }\r\n    return jo;\r\n}"
}, {
	"Path": "org.joda.time.Interval.withStartMillis",
	"Comment": "creates a new interval with the specified start millisecond instant.",
	"Method": "Interval withStartMillis(long startInstant){\r\n    if (startInstant == getStartMillis()) {\r\n        return this;\r\n    }\r\n    return new Interval(startInstant, getEndMillis(), getChronology());\r\n}"
}, {
	"Path": "org.joda.time.Years.isLessThan",
	"Comment": "is this years instance less than the specified number of years.",
	"Method": "boolean isLessThan(Years other){\r\n    if (other == null) {\r\n        return getValue() < 0;\r\n    }\r\n    return getValue() < other.getValue();\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractInterval.getStart",
	"Comment": "gets the start of this time interval, which is inclusive, as a datetime.",
	"Method": "DateTime getStart(){\r\n    return new DateTime(getStartMillis(), getChronology());\r\n}"
}, {
	"Path": "jodd.servlet.DispatcherUtil.getUrl",
	"Comment": "returns url, without context path, convenient for request dispatcher.",
	"Method": "String getUrl(HttpServletRequest request){\r\n    String servletPath = request.getServletPath();\r\n    String query = request.getQueryString();\r\n    if ((query != null) && (query.length() != 0)) {\r\n        servletPath += '?' + query;\r\n    }\r\n    return servletPath;\r\n}"
}, {
	"Path": "org.joda.time.convert.ConverterManager.removeInstantConverter",
	"Comment": "removes a converter from the set of converters. if the converter wasnot in the set, no changes are made.",
	"Method": "InstantConverter removeInstantConverter(InstantConverter converter){\r\n    checkAlterInstantConverters();\r\n    if (converter == null) {\r\n        return null;\r\n    }\r\n    InstantConverter[] removed = new InstantConverter[1];\r\n    iInstantConverters = iInstantConverters.remove(converter, removed);\r\n    return removed[0];\r\n}"
}, {
	"Path": "jodd.asm7.MethodVisitor.visitTypeInsn",
	"Comment": "visits a type instruction. a type instruction is an instruction that takes the internal name ofa class as parameter.",
	"Method": "void visitTypeInsn(int opcode,String type){\r\n    if (mv != null) {\r\n        mv.visitTypeInsn(opcode, type);\r\n    }\r\n}"
}, {
	"Path": "jodd.methref.MethrefAdvice.execute",
	"Comment": "reads method name and stores it in local variable.\tfor methods that return string returns the method name,\totherwise returns null.",
	"Method": "Object execute(){\r\n    methodName = targetMethodName();\r\n    Class returnType = returnType();\r\n    if (returnType == String.class) {\r\n        return ProxyTarget.returnValue(targetMethodName());\r\n    }\r\n    return ProxyTarget.returnValue(null);\r\n}"
}, {
	"Path": "org.joda.time.Duration.toStandardMinutes",
	"Comment": "converts this duration to a period in minutes assuming that there are thestandard number of milliseconds in a minute.this method assumes that there are 60 seconds in a minute and1000 milliseconds in a second.all currently supplied chronologies use this definition.",
	"Method": "Minutes toStandardMinutes(){\r\n    long minutes = getStandardMinutes();\r\n    return Minutes.minutes(FieldUtils.safeToInt(minutes));\r\n}"
}, {
	"Path": "org.joda.time.LocalDate.dayOfMonth",
	"Comment": "get the day of month property which provides access to advanced functionality.",
	"Method": "Property dayOfMonth(){\r\n    return new Property(this, getChronology().dayOfMonth());\r\n}"
}, {
	"Path": "org.joda.time.MutablePeriod.addMonths",
	"Comment": "adds the specified months to the number of months in the period.",
	"Method": "void addMonths(int months){\r\n    super.addField(DurationFieldType.months(), months);\r\n}"
}, {
	"Path": "org.joda.time.field.DividedDateTimeField.get",
	"Comment": "get the amount of scaled units from the specified time instant.",
	"Method": "int get(long instant){\r\n    int value = getWrappedField().get(instant);\r\n    if (value >= 0) {\r\n        return value / iDivisor;\r\n    } else {\r\n        return ((value + 1) / iDivisor) - 1;\r\n    }\r\n}"
}, {
	"Path": "jodd.petite.PetiteConfig.setUseParamo",
	"Comment": "specifies if paramo tool should be used to resolve\tmethod and ctor argument names.",
	"Method": "void setUseParamo(boolean useParamo){\r\n    this.useParamo = useParamo;\r\n}"
}, {
	"Path": "jodd.util.StringBand.charAt",
	"Comment": "returns char at given position.\tthis method is not fast as it calculates\tthe right string array element and the offset!",
	"Method": "char charAt(int pos){\r\n    int len = 0;\r\n    for (int i = 0; i < index; i++) {\r\n        int newlen = len + array[i].length();\r\n        if (pos < newlen) {\r\n            return array[i].charAt(pos - len);\r\n        }\r\n        len = newlen;\r\n    }\r\n    throw new IllegalArgumentException(\"Invalid char index\");\r\n}"
}, {
	"Path": "org.joda.time.Hours.plus",
	"Comment": "returns a new instance with the specified number of hours added.this instance is immutable and unaffected by this method call.",
	"Method": "Hours plus(int hours,Hours plus,Hours hours){\r\n    if (hours == null) {\r\n        return this;\r\n    }\r\n    return plus(hours.getValue());\r\n}"
}, {
	"Path": "jodd.io.findfile.ClassScanner.excludeEntries",
	"Comment": "sets excluded names that narrows included set of packages.",
	"Method": "ClassScanner excludeEntries(String excludedEntries){\r\n    for (final String excludedEntry : excludedEntries) {\r\n        rulesEntries.exclude(excludedEntry);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.joda.time.Hours.dividedBy",
	"Comment": "returns a new instance with the hours divided by the specified divisor.the calculation uses integer division, thus 3 divided by 2 is 1.this instance is immutable and unaffected by this method call.",
	"Method": "Hours dividedBy(int divisor){\r\n    if (divisor == 1) {\r\n        return this;\r\n    }\r\n    return Hours.hours(getValue() / divisor);\r\n}"
}, {
	"Path": "jodd.http.HttpBase.charset",
	"Comment": "defines just content type charset. setting this value to\tnull will remove the charset information from\tthe header.",
	"Method": "String charset(T charset,String charset){\r\n    this.charset = null;\r\n    contentType(null, charset);\r\n    return _this();\r\n}"
}, {
	"Path": "org.joda.time.base.BaseDateTime.setChronology",
	"Comment": "sets the chronology of the datetime.all changes to the chronology field occurs via this method.override and block this method to make a subclass immutable.",
	"Method": "void setChronology(Chronology chronology){\r\n    iChronology = checkChronology(chronology);\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Strategy.getName",
	"Comment": "the class used to provide a naming strategy for generated source code. you may override this with your custom naming strategy. this cannot be combined with a matcher configuration.",
	"Method": "String getName(){\r\n    return name;\r\n}"
}, {
	"Path": "org.joda.time.Partial.getField",
	"Comment": "gets the field for a specific index in the chronology specified.",
	"Method": "DateTimeField getField(int index,Chronology chrono,DateTimeField getField){\r\n    return iTypes[index].getField(chrono);\r\n}"
}, {
	"Path": "org.joda.time.Months.minus",
	"Comment": "returns a new instance with the specified number of months taken away.this instance is immutable and unaffected by this method call.",
	"Method": "Months minus(int months,Months minus,Months months){\r\n    if (months == null) {\r\n        return this;\r\n    }\r\n    return minus(months.getValue());\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractDuration.equals",
	"Comment": "compares this object with the specified object for equality basedon the millisecond length. all readableduration instances are accepted.the comparison takes into account the sign.as such, a duration of 5 seconds is not equal to a duration of minus 5 seconds.",
	"Method": "boolean equals(Object duration){\r\n    if (this == duration) {\r\n        return true;\r\n    }\r\n    if (duration instanceof ReadableDuration == false) {\r\n        return false;\r\n    }\r\n    ReadableDuration other = (ReadableDuration) duration;\r\n    return (getMillis() == other.getMillis());\r\n}"
}, {
	"Path": "jodd.asm7.Frame.addInitializedType",
	"Comment": "adds an abstract type to the list of types on which a constructor is invoked in the basicblock.",
	"Method": "void addInitializedType(int abstractType){\r\n    if (initializations == null) {\r\n        initializations = new int[2];\r\n    }\r\n    int initializationsLength = initializations.length;\r\n    if (initializationCount >= initializationsLength) {\r\n        int[] newInitializations = new int[Math.max(initializationCount + 1, 2 * initializationsLength)];\r\n        System.arraycopy(initializations, 0, newInitializations, 0, initializationsLength);\r\n        initializations = newInitializations;\r\n    }\r\n    initializations[initializationCount++] = abstractType;\r\n}"
}, {
	"Path": "jodd.system.JavaInfo.isJavaVersion",
	"Comment": "checks if the currently running jvm is equal to provided version.",
	"Method": "boolean isJavaVersion(int version){\r\n    return JAVA_VERSION_NUMBER == version;\r\n}"
}, {
	"Path": "org.joda.time.DateTime.withYear",
	"Comment": "returns a copy of this datetime with the year field updated.datetime is immutable, so there are no set methods.instead, this method returns a new instance with the value ofyear changed.",
	"Method": "DateTime withYear(int year){\r\n    return withMillis(getChronology().year().set(getMillis(), year));\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.withMinuteOfHour",
	"Comment": "returns a copy of this datetime with the minute of hour field updated.localdatetime is immutable, so there are no set methods.instead, this method returns a new instance with the value ofminute of hour changed.",
	"Method": "LocalDateTime withMinuteOfHour(int minute){\r\n    return withLocalMillis(getChronology().minuteOfHour().set(getLocalMillis(), minute));\r\n}"
}, {
	"Path": "jodd.asm7.SymbolTable.getMajorVersion",
	"Comment": "returns the major version of the class to which this symbol table belongs.",
	"Method": "int getMajorVersion(){\r\n    return majorVersion;\r\n}"
}, {
	"Path": "jodd.json.JsonArray.addAll",
	"Comment": "appends all of the elements in the specified array to the end of this json array.",
	"Method": "JsonArray addAll(JsonArray array){\r\n    Objects.requireNonNull(array);\r\n    list.addAll(array.list);\r\n    return this;\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.MatchersTableType.getPojoExtends",
	"Comment": "this string provides a super class that a generated pojo should extend.",
	"Method": "String getPojoExtends(){\r\n    return pojoExtends;\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.rtp.RtpSocket.setDestination",
	"Comment": "sets the destination address and to which the packets will be sent.",
	"Method": "void setDestination(InetAddress dest,int dport,int rtcpPort){\r\n    if (dport != 0 && rtcpPort != 0) {\r\n        mTransport = TRANSPORT_UDP;\r\n        mPort = dport;\r\n        for (int i = 0; i < mBufferCount; i++) {\r\n            mPackets[i].setPort(dport);\r\n            mPackets[i].setAddress(dest);\r\n        }\r\n        mReport.setDestination(dest, rtcpPort);\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.YearMonthDay.toDateTimeAtCurrentTime",
	"Comment": "converts this partial to a full datetime using the specified time zonesetting the date fields from this instance and the time fields fromthe current time.this method uses the chronology from this instance plus the time zonespecified.",
	"Method": "DateTime toDateTimeAtCurrentTime(DateTime toDateTimeAtCurrentTime,DateTimeZone zone){\r\n    Chronology chrono = getChronology().withZone(zone);\r\n    long instantMillis = DateTimeUtils.currentTimeMillis();\r\n    long resolved = chrono.set(this, instantMillis);\r\n    return new DateTime(resolved, chrono);\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.gl.SurfaceManager.release",
	"Comment": "discards all resources held by this class, notably the egl context.also releases the\tsurface that was passed to our constructor.",
	"Method": "void release(){\r\n    if (mEGLDisplay != EGL14.EGL_NO_DISPLAY) {\r\n        EGL14.eglMakeCurrent(mEGLDisplay, EGL14.EGL_NO_SURFACE, EGL14.EGL_NO_SURFACE, EGL14.EGL_NO_CONTEXT);\r\n        EGL14.eglDestroySurface(mEGLDisplay, mEGLSurface);\r\n        EGL14.eglDestroyContext(mEGLDisplay, mEGLContext);\r\n        EGL14.eglReleaseThread();\r\n        EGL14.eglTerminate(mEGLDisplay);\r\n    }\r\n    mEGLDisplay = EGL14.EGL_NO_DISPLAY;\r\n    mEGLContext = EGL14.EGL_NO_CONTEXT;\r\n    mEGLSurface = EGL14.EGL_NO_SURFACE;\r\n    mSurface.release();\r\n}"
}, {
	"Path": "jodd.jtx.JtxTransaction.isCommitted",
	"Comment": "returns true if transaction and all its resources are committed successfully.",
	"Method": "boolean isCommitted(){\r\n    return status == STATUS_COMMITTED;\r\n}"
}, {
	"Path": "org.json.JSONWriter.endArray",
	"Comment": "end an array. this method most be called to balance calls toarray.",
	"Method": "JSONWriter endArray(){\r\n    return this.end('a', ']');\r\n}"
}, {
	"Path": "org.joda.time.YearMonthDay.toDateMidnight",
	"Comment": "converts this object to a datemidnight in the default time zone.",
	"Method": "DateMidnight toDateMidnight(DateMidnight toDateMidnight,DateTimeZone zone){\r\n    Chronology chrono = getChronology().withZone(zone);\r\n    return new DateMidnight(getYear(), getMonthOfYear(), getDayOfMonth(), chrono);\r\n}"
}, {
	"Path": "jodd.exception.ExceptionUtil.getExceptionChain",
	"Comment": "returns exception chain starting from top up to root cause.",
	"Method": "Throwable[] getExceptionChain(Throwable throwable){\r\n    ArrayList<Throwable> list = new ArrayList();\r\n    list.add(throwable);\r\n    while ((throwable = throwable.getCause()) != null) {\r\n        list.add(throwable);\r\n    }\r\n    Throwable[] result = new Throwable[list.size()];\r\n    return list.toArray(result);\r\n}"
}, {
	"Path": "jodd.http.Cookie.setVersion",
	"Comment": "sets the version of the cookie protocol this cookie complies\twith. version 0 complies with the original netscape cookie\tspecification. version 1 complies with rfc 2109.",
	"Method": "Cookie setVersion(int version){\r\n    this.version = Integer.valueOf(version);\r\n    return this;\r\n}"
}, {
	"Path": "org.jooq.codegen.GenerationUtil.escapeWindowsForbiddenNames",
	"Comment": "take a name and escape it if it is a windows forbidden name likecon or aux.",
	"Method": "String escapeWindowsForbiddenNames(String name){\r\n    return name == null ? null : WINDOWS_FORBIDDEN.contains(name.toUpperCase()) ? name + \"_\" : name;\r\n}"
}, {
	"Path": "jodd.time.JulianDate.getSignificantFraction",
	"Comment": "calculates and returns significant fraction only as an int.",
	"Method": "int getSignificantFraction(){\r\n    return (int) (fraction * 100_000_000);\r\n}"
}, {
	"Path": "org.joda.time.MonthDay.dayOfMonth",
	"Comment": "get the day of month field property which provides access to advanced functionality.",
	"Method": "Property dayOfMonth(){\r\n    return new Property(this, DAY_OF_MONTH);\r\n}"
}, {
	"Path": "org.joda.time.YearMonthDay.toInterval",
	"Comment": "converts this object to an interval representing the whole day.",
	"Method": "Interval toInterval(Interval toInterval,DateTimeZone zone){\r\n    zone = DateTimeUtils.getZone(zone);\r\n    return toDateMidnight(zone).toInterval();\r\n}"
}, {
	"Path": "jodd.madvoc.component.ResultMapper.resolveResultPathString",
	"Comment": "resolves result path as a string, when parts are not important\tand when only full string matters. additional alias resolving\ton full path is done.",
	"Method": "String resolveResultPathString(String path,String value){\r\n    final ResultPath resultPath = resolveResultPath(path, value);\r\n    final String result = resultPath.pathValue();\r\n    return resolveAlias(result);\r\n}"
}, {
	"Path": "org.joda.time.DateMidnight.toLocalDate",
	"Comment": "converts this object to a localdate with thesame date and chronology.",
	"Method": "LocalDate toLocalDate(){\r\n    return new LocalDate(getMillis(), getChronology());\r\n}"
}, {
	"Path": "org.joda.time.LocalTime.withLocalMillis",
	"Comment": "returns a copy of this time with different local millis.the returned object will be a new instance of the same type.only the millis will change, the chronology is kept.the returned object will be either be a new instance or this.",
	"Method": "LocalTime withLocalMillis(long newMillis){\r\n    return (newMillis == getLocalMillis() ? this : new LocalTime(newMillis, getChronology()));\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.dayOfWeek",
	"Comment": "get the day of week property which provides access to advanced functionality.",
	"Method": "Property dayOfWeek(){\r\n    return new Property(this, getChronology().dayOfWeek());\r\n}"
}, {
	"Path": "org.joda.time.Months.isLessThan",
	"Comment": "is this months instance less than the specified number of months.",
	"Method": "boolean isLessThan(Months other){\r\n    if (other == null) {\r\n        return getValue() < 0;\r\n    }\r\n    return getValue() < other.getValue();\r\n}"
}, {
	"Path": "jodd.asm7.Handle.getTag",
	"Comment": "returns the kind of field or method designated by this handle.",
	"Method": "int getTag(){\r\n    return tag;\r\n}"
}, {
	"Path": "org.joda.time.PeriodType.isSupported",
	"Comment": "checks whether the field specified is supported by this period.",
	"Method": "boolean isSupported(DurationFieldType type){\r\n    return (indexOf(type) >= 0);\r\n}"
}, {
	"Path": "org.jooq.impl.ReferenceImpl.extractDSLContext",
	"Comment": "extract a configuration from the first record of a collection of records",
	"Method": "DSLContext extractDSLContext(Collection<? extends R> records){\r\n    R first = first(records);\r\n    if (first != null)\r\n        return DSL.using(first.configuration());\r\n    else\r\n        throw new DetachedException(\"Supply at least one attachable record\");\r\n}"
}, {
	"Path": "jodd.introspector.MethodDescriptor.getRawReturnKeyComponentType",
	"Comment": "returns raw component type of return type.\tmay be null if return type does not have\tcomponents.",
	"Method": "Class getRawReturnKeyComponentType(){\r\n    return rawReturnKeyComponentType;\r\n}"
}, {
	"Path": "jodd.madvoc.component.AsyncActionExecutor.invoke",
	"Comment": "invokes an action asynchronously by submitting it to the thread pool.",
	"Method": "void invoke(ActionRequest actionRequest){\r\n    if (executorService == null) {\r\n        throw new MadvocException(\"No action is marked as async!\");\r\n    }\r\n    final HttpServletRequest servletRequest = actionRequest.getHttpServletRequest();\r\n    log.debug(() -> \"Async call to: \" + actionRequest);\r\n    final AsyncContext asyncContext = servletRequest.startAsync();\r\n    executorService.submit(() -> {\r\n        try {\r\n            actionRequest.invoke();\r\n        } catch (Exception ex) {\r\n            log.error(\"Invoking async action path failed: \", ExceptionUtil.unwrapThrowable(ex));\r\n        } finally {\r\n            asyncContext.complete();\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.joda.time.Duration.abs",
	"Comment": "returns a duration that has a positive or zero number of milliseconds.this instance is immutable and is not altered.",
	"Method": "Duration abs(){\r\n    if (getMillis() < 0) {\r\n        return negated();\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.jooq.exception.ExceptionTools.getCause",
	"Comment": "find a root cause of a given type, or null if no root causeof that type was found.",
	"Method": "T getCause(Throwable t,Class<? extends T> type){\r\n    Throwable next = t.getCause();\r\n    Throwable prev;\r\n    for (int i = 0; i < maxCauseLookups; i++) {\r\n        if (next == null)\r\n            return null;\r\n        if (type.isInstance(next))\r\n            return (T) next;\r\n        prev = next;\r\n        next = next.getCause();\r\n        if (prev == next)\r\n            return null;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.getWeekyear",
	"Comment": "get the weekyear field value.the weekyear is the year that matches with the weekofweekyear field.in the standard iso8601 week algorithm, the first week of the yearis that in which at least 4 days are in the year. as a result of thisdefinition, day 1 of the first week may be in the previous year.the weekyear allows you to query the effective year for that day.",
	"Method": "int getWeekyear(){\r\n    return getChronology().weekyear().get(getLocalMillis());\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Generate.isCommentsOnPackages",
	"Comment": "turn off generation of all sql comments as javadoc on all packages.",
	"Method": "Boolean isCommentsOnPackages(){\r\n    return commentsOnPackages;\r\n}"
}, {
	"Path": "org.joda.time.Period.plusMillis",
	"Comment": "returns a new period plus the specified number of millis added.this period instance is immutable and unaffected by this method call.",
	"Method": "Period plusMillis(int millis){\r\n    if (millis == 0) {\r\n        return this;\r\n    }\r\n    int[] values = getValues();\r\n    getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, millis);\r\n    return new Period(values, getPeriodType());\r\n}"
}, {
	"Path": "jodd.introspector.PropertyDescriptor.getReadMethodDescriptor",
	"Comment": "returns read method of this property.\tmay be null if read method is not defined.",
	"Method": "MethodDescriptor getReadMethodDescriptor(){\r\n    return readMethodDescriptor;\r\n}"
}, {
	"Path": "jodd.servlet.wrapper.BufferResponseWrapper.getBufferedBytes",
	"Comment": "returns buffered bytes or null if buffering was not enabled.",
	"Method": "byte[] getBufferedBytes(){\r\n    if (buffer == null) {\r\n        return null;\r\n    }\r\n    return buffer.toByteArray();\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.era",
	"Comment": "get the era property which provides access to advanced functionality.",
	"Method": "Property era(){\r\n    return new Property(this, getChronology().era());\r\n}"
}, {
	"Path": "org.jsonschema2pojo.rules.TypeRule.getNumberType",
	"Comment": "returns the jtype for a number field. handles type lookup and unboxing.",
	"Method": "JType getNumberType(JCodeModel owner,GenerationConfig config){\r\n    if (config.isUseBigDecimals()) {\r\n        return unboxIfNecessary(owner.ref(BigDecimal.class), config);\r\n    } else if (config.isUseDoubleNumbers()) {\r\n        return unboxIfNecessary(owner.ref(Double.class), config);\r\n    } else {\r\n        return unboxIfNecessary(owner.ref(Float.class), config);\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.Minutes.multipliedBy",
	"Comment": "returns a new instance with the minutes multiplied by the specified scalar.this instance is immutable and unaffected by this method call.",
	"Method": "Minutes multipliedBy(int scalar){\r\n    return Minutes.minutes(FieldUtils.safeMultiply(getValue(), scalar));\r\n}"
}, {
	"Path": "org.json.JSONArray.optBigInteger",
	"Comment": "get the optional biginteger value associated with an index. the defaultvalue is returned if there is no value for the index, or if the value is not a number and cannot be converted to a number.",
	"Method": "BigInteger optBigInteger(int index,BigInteger defaultValue){\r\n    Object val = this.opt(index);\r\n    return JSONObject.objectToBigInteger(val, defaultValue);\r\n}"
}, {
	"Path": "org.joda.time.field.PreciseDateTimeField.get",
	"Comment": "get the amount of fractional units from the specified time instant.",
	"Method": "int get(long instant){\r\n    if (instant >= 0) {\r\n        return (int) ((instant / getUnitMillis()) % iRange);\r\n    } else {\r\n        return iRange - 1 + (int) (((instant + 1) / getUnitMillis()) % iRange);\r\n    }\r\n}"
}, {
	"Path": "org.jooq.impl.Tools.getAnnotatedGetter",
	"Comment": "get the first getter method annotated with a given column name",
	"Method": "Method getAnnotatedGetter(Configuration configuration,Class<?> type,String name){\r\n    return Cache.run(configuration, new CachedOperation<Method>() {\r\n        @Override\r\n        public Method call() {\r\n            for (Method method : getInstanceMethods(type)) {\r\n                Column column = method.getAnnotation(Column.class);\r\n                if (column != null && namesMatch(name, column.name())) {\r\n                    if (method.getParameterTypes().length == 0) {\r\n                        return accessible(method);\r\n                    } else if (method.getParameterTypes().length == 1) {\r\n                        String m = method.getName();\r\n                        if (m.startsWith(\"set\")) {\r\n                            try {\r\n                                Method getter = type.getMethod(\"get\" + m.substring(3));\r\n                                if (getter.getAnnotation(Column.class) == null)\r\n                                    return accessible(getter);\r\n                            } catch (NoSuchMethodException ignore) {\r\n                            }\r\n                            try {\r\n                                Method getter = type.getMethod(\"is\" + m.substring(3));\r\n                                if (getter.getAnnotation(Column.class) == null)\r\n                                    return accessible(getter);\r\n                            } catch (NoSuchMethodException ignore) {\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n    }, DATA_REFLECTION_CACHE_GET_ANNOTATED_GETTER, Cache.key(type, name));\r\n}"
}, {
	"Path": "org.jooq.impl.Tools.getAnnotatedGetter",
	"Comment": "get the first getter method annotated with a given column name",
	"Method": "Method getAnnotatedGetter(Configuration configuration,Class<?> type,String name){\r\n    for (Method method : getInstanceMethods(type)) {\r\n        Column column = method.getAnnotation(Column.class);\r\n        if (column != null && namesMatch(name, column.name())) {\r\n            if (method.getParameterTypes().length == 0) {\r\n                return accessible(method);\r\n            } else if (method.getParameterTypes().length == 1) {\r\n                String m = method.getName();\r\n                if (m.startsWith(\"set\")) {\r\n                    try {\r\n                        Method getter = type.getMethod(\"get\" + m.substring(3));\r\n                        if (getter.getAnnotation(Column.class) == null)\r\n                            return accessible(getter);\r\n                    } catch (NoSuchMethodException ignore) {\r\n                    }\r\n                    try {\r\n                        Method getter = type.getMethod(\"is\" + m.substring(3));\r\n                        if (getter.getAnnotation(Column.class) == null)\r\n                            return accessible(getter);\r\n                    } catch (NoSuchMethodException ignore) {\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.joda.time.format.DateTimeParserBucket.getOffsetInteger",
	"Comment": "returns the time zone offset in milliseconds used by computemillis.",
	"Method": "Integer getOffsetInteger(){\r\n    return iOffset;\r\n}"
}, {
	"Path": "jodd.util.ArraysUtil.insertAt",
	"Comment": "inserts one array into another by replacing specified offset.",
	"Method": "T[] insertAt(T[] dest,T[] src,int offset,T[] insertAt,T[] dest,T[] src,int offset,Class componentType,String[] insertAt,String[] dest,String[] src,int offset,byte[] insertAt,byte[] dest,byte[] src,int offset,char[] insertAt,char[] dest,char[] src,int offset,short[] insertAt,short[] dest,short[] src,int offset,int[] insertAt,int[] dest,int[] src,int offset,long[] insertAt,long[] dest,long[] src,int offset,float[] insertAt,float[] dest,float[] src,int offset,double[] insertAt,double[] dest,double[] src,int offset,boolean[] insertAt,boolean[] dest,boolean[] src,int offset){\r\n    boolean[] temp = new boolean[dest.length + src.length - 1];\r\n    System.arraycopy(dest, 0, temp, 0, offset);\r\n    System.arraycopy(src, 0, temp, offset, src.length);\r\n    System.arraycopy(dest, offset + 1, temp, src.length + offset, dest.length - offset - 1);\r\n    return temp;\r\n}"
}, {
	"Path": "org.joda.time.convert.ConverterSet.remove",
	"Comment": "returns a copy of this set, with the converter at the given indexremoved.",
	"Method": "ConverterSet remove(Converter converter,Converter[] removed,ConverterSet remove,int index,Converter[] removed){\r\n    Converter[] converters = iConverters;\r\n    int length = converters.length;\r\n    if (index >= length) {\r\n        throw new IndexOutOfBoundsException();\r\n    }\r\n    if (removed != null) {\r\n        removed[0] = converters[index];\r\n    }\r\n    Converter[] copy = new Converter[length - 1];\r\n    int j = 0;\r\n    for (int i = 0; i < length; i++) {\r\n        if (i != index) {\r\n            copy[j++] = converters[i];\r\n        }\r\n    }\r\n    return new ConverterSet(copy);\r\n}"
}, {
	"Path": "jodd.htmlstapler.BundleAction.processLink",
	"Comment": "process links. returns bundle link if this is the first resource\tof the same type. otherwise, returns null indicating\tthat collection is going on and the original link should be removed.",
	"Method": "String processLink(String src){\r\n    if (newAction) {\r\n        if (bundleId == null) {\r\n            bundleId = bundlesManager.registerNewBundleId();\r\n            bundleId += '.' + bundleContentType;\r\n        }\r\n        sources.add(src);\r\n    }\r\n    if (firstScriptTag) {\r\n        firstScriptTag = false;\r\n        return buildStaplerUrl();\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "jodd.servlet.SessionMonitor.sessionDestroyed",
	"Comment": "removes session from a map and broadcasts event to registered listeners.",
	"Method": "void sessionDestroyed(HttpSessionEvent httpSessionEvent){\r\n    HttpSession session = httpSessionEvent.getSession();\r\n    sessionMap.remove(session.getId());\r\n    for (HttpSessionListener listener : listeners) {\r\n        listener.sessionDestroyed(httpSessionEvent);\r\n    }\r\n}"
}, {
	"Path": "jodd.jerry.Jerry.htmlAll",
	"Comment": "gets the combined html contents of each element in the set of\tmatched elements, including their descendants.",
	"Method": "String htmlAll(boolean setIncluded){\r\n    if (nodes.length == 0) {\r\n        return StringPool.EMPTY;\r\n    }\r\n    StringBuilder sb = new StringBuilder();\r\n    for (Node node : nodes) {\r\n        sb.append(setIncluded ? node.getHtml() : node.getInnerHtml());\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.joda.time.Seconds.toStandardDays",
	"Comment": "converts this period in seconds to a period in days assuming a24 hour day, 60 minute hour and 60 second minute.this method allows you to convert between different types of period.however to achieve this it makes the assumption that all days are 24 hourslong, all hours are 60 minutes long and all minutes are 60 seconds long.this is not true when daylight savings is considered and may also notbe true for some unusual chronologies. however, it is includedas it is a useful operation for many applications and business rules.",
	"Method": "Days toStandardDays(){\r\n    return Days.days(getValue() / DateTimeConstants.SECONDS_PER_DAY);\r\n}"
}, {
	"Path": "org.jsonschema2pojo.rules.RuleFactory.getSchemaRule",
	"Comment": "provides a rule instance that should be applied when a schema declarationis found in the schema.",
	"Method": "Rule<JClassContainer, JType> getSchemaRule(){\r\n    return new SchemaRule(this);\r\n}"
}, {
	"Path": "jodd.json.PathQuery.isIncluded",
	"Comment": "returns true if this query indicates that matching\tproperties should be included.",
	"Method": "boolean isIncluded(){\r\n    return included;\r\n}"
}, {
	"Path": "org.joda.time.LocalDate.withYearOfEra",
	"Comment": "returns a copy of this date with the year of era field updated.localdate is immutable, so there are no set methods.instead, this method returns a new instance with the value ofyear of era changed.",
	"Method": "LocalDate withYearOfEra(int yearOfEra){\r\n    return withLocalMillis(getChronology().yearOfEra().set(getLocalMillis(), yearOfEra));\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.MatchersSequenceType.getExpression",
	"Comment": "this sequence matcher applies to all unqualified or qualified sequence names matched by this expression. if left empty, this matcher applies to all sequences.",
	"Method": "String getExpression(){\r\n    return expression;\r\n}"
}, {
	"Path": "jodd.util.collection.IntHashMap.put",
	"Comment": "associates the specified value with the specified key in this map. if the\tmap previously contained a mapping for this key, the old value is\treplaced.",
	"Method": "Object put(Object key,Object value,Object put,int key,Object value){\r\n    Entry[] tab = table;\r\n    int index = (key & 0x7FFFFFFF) % tab.length;\r\n    for (Entry e = tab[index]; e != null; e = e.next) {\r\n        if (e.key == key) {\r\n            Object old = e.value;\r\n            e.value = value;\r\n            return old;\r\n        }\r\n    }\r\n    modCount++;\r\n    if (count >= threshold) {\r\n        rehash();\r\n        tab = table;\r\n        index = (key & 0x7FFFFFFF) % tab.length;\r\n    }\r\n    tab[index] = new Entry(key, value, tab[index]);\r\n    count++;\r\n    return null;\r\n}"
}, {
	"Path": "jodd.asm7.ByteVector.put112",
	"Comment": "puts two bytes and a short into this byte vector. the byte vector is automatically enlarged ifnecessary.",
	"Method": "ByteVector put112(int byteValue1,int byteValue2,int shortValue){\r\n    int currentLength = length;\r\n    if (currentLength + 4 > data.length) {\r\n        enlarge(4);\r\n    }\r\n    byte[] currentData = data;\r\n    currentData[currentLength++] = (byte) byteValue1;\r\n    currentData[currentLength++] = (byte) byteValue2;\r\n    currentData[currentLength++] = (byte) (shortValue >>> 8);\r\n    currentData[currentLength++] = (byte) shortValue;\r\n    length = currentLength;\r\n    return this;\r\n}"
}, {
	"Path": "org.joda.time.Seconds.dividedBy",
	"Comment": "returns a new instance with the seconds divided by the specified divisor.the calculation uses integer division, thus 3 divided by 2 is 1.this instance is immutable and unaffected by this method call.",
	"Method": "Seconds dividedBy(int divisor){\r\n    if (divisor == 1) {\r\n        return this;\r\n    }\r\n    return Seconds.seconds(getValue() / divisor);\r\n}"
}, {
	"Path": "jodd.inex.InExRules.addRule",
	"Comment": "adds a rule. duplicates are not allowed and will be ignored.",
	"Method": "void addRule(D ruleDefinition,boolean include){\r\n    if (rules == null) {\r\n        rules = new ArrayList();\r\n    }\r\n    if (include) {\r\n        includesCount++;\r\n    } else {\r\n        excludesCount++;\r\n    }\r\n    Rule<R> newRule = new Rule(makeRule(ruleDefinition), include);\r\n    if (rules.contains(newRule)) {\r\n        return;\r\n    }\r\n    rules.add(newRule);\r\n}"
}, {
	"Path": "jodd.util.ClassUtil.isPublicPublic",
	"Comment": "returns true if class member is public and if its declaring class is also public.",
	"Method": "boolean isPublicPublic(Member member){\r\n    if (Modifier.isPublic(member.getModifiers())) {\r\n        if (Modifier.isPublic(member.getDeclaringClass().getModifiers())) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "jodd.util.RandomString.randomBase64",
	"Comment": "creates random string that contains only base64 characters.",
	"Method": "String randomBase64(int count){\r\n    return random(count, Base64.CHARS);\r\n}"
}, {
	"Path": "org.joda.time.format.PeriodFormatter.parseMutablePeriod",
	"Comment": "parses a period from the given text, returning a new mutableperiod.",
	"Method": "MutablePeriod parseMutablePeriod(String text){\r\n    checkParser();\r\n    MutablePeriod period = new MutablePeriod(0, iParseType);\r\n    int newPos = getParser().parseInto(period, text, 0, iLocale);\r\n    if (newPos >= 0) {\r\n        if (newPos >= text.length()) {\r\n            return period;\r\n        }\r\n    } else {\r\n        newPos = ~newPos;\r\n    }\r\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\r\n}"
}, {
	"Path": "jodd.proxetta.impl.WrapperProxetta.setCreateTargetInDefaultCtor",
	"Comment": "defines if target should be created in ctor, so no additional injection is required.",
	"Method": "WrapperProxetta setCreateTargetInDefaultCtor(boolean createTargetInstanceInDefaultCtor){\r\n    this.createTargetInDefaultCtor = createTargetInstanceInDefaultCtor;\r\n    return _this();\r\n}"
}, {
	"Path": "org.joda.time.chrono.JulianChronology.getInstanceUTC",
	"Comment": "gets an instance of the julianchronology.the time zone of the returned instance is utc.",
	"Method": "JulianChronology getInstanceUTC(){\r\n    return INSTANCE_UTC;\r\n}"
}, {
	"Path": "org.jooq.tools.json.Yylex.yypushback",
	"Comment": "pushes the specified amount of characters back into the input stream.they will be read again by then next call of the scanning method",
	"Method": "void yypushback(int number){\r\n    if (number > yylength())\r\n        zzScanError(ZZ_PUSHBACK_2BIG);\r\n    zzMarkedPos -= number;\r\n}"
}, {
	"Path": "org.jooq.impl.DSL.using",
	"Comment": "create an executor with a custom connection provider, a dialect and settingsconfigured.",
	"Method": "DSLContext using(SQLDialect dialect,DSLContext using,SQLDialect dialect,Settings settings,DSLContext using,String url,DSLContext using,String url,String username,String password,DSLContext using,String url,Properties properties,DSLContext using,Connection connection,DSLContext using,Connection connection,SQLDialect dialect,DSLContext using,Connection connection,Settings settings,DSLContext using,Connection connection,SQLDialect dialect,Settings settings,DSLContext using,DataSource datasource,SQLDialect dialect,DSLContext using,DataSource datasource,SQLDialect dialect,Settings settings,DSLContext using,ConnectionProvider connectionProvider,SQLDialect dialect,DSLContext using,ConnectionProvider connectionProvider,SQLDialect dialect,Settings settings,DSLContext using,Configuration configuration){\r\n    return new DefaultDSLContext(configuration);\r\n}"
}, {
	"Path": "org.joda.time.DateTime.era",
	"Comment": "get the era property which provides access to advanced functionality.",
	"Method": "Property era(){\r\n    return new Property(this, getChronology().era());\r\n}"
}, {
	"Path": "org.joda.time.base.BaseSingleFieldPeriod.equals",
	"Comment": "compares this object with the specified object for equality based on thevalue of each field. all readableperiod instances are accepted, but onlythose with a matching periodtype can return true.",
	"Method": "boolean equals(Object period){\r\n    if (this == period) {\r\n        return true;\r\n    }\r\n    if (period instanceof ReadablePeriod == false) {\r\n        return false;\r\n    }\r\n    ReadablePeriod other = (ReadablePeriod) period;\r\n    return (other.getPeriodType() == getPeriodType() && other.getValue(0) == getValue());\r\n}"
}, {
	"Path": "jodd.servlet.tag.IteratorStatus.next",
	"Comment": "performs the iterations to the next item and specifies if this is the last iteration.",
	"Method": "void next(boolean isLast){\r\n    count++;\r\n    last = isLast;\r\n}"
}, {
	"Path": "org.json.JSONObject.toJSONArray",
	"Comment": "produce a jsonarray containing the values of the members of thisjsonobject.",
	"Method": "JSONArray toJSONArray(JSONArray names){\r\n    if (names == null || names.isEmpty()) {\r\n        return null;\r\n    }\r\n    JSONArray ja = new JSONArray();\r\n    for (int i = 0; i < names.length(); i += 1) {\r\n        ja.put(this.opt(names.getString(i)));\r\n    }\r\n    return ja;\r\n}"
}, {
	"Path": "org.joda.time.DateTimeZone.getNameProvider",
	"Comment": "gets the name provider factory.the name provider is a pluggable instance factory that supplies thenames of each datetimezone.",
	"Method": "NameProvider getNameProvider(){\r\n    NameProvider nameProvider = cNameProvider.get();\r\n    if (nameProvider == null) {\r\n        nameProvider = getDefaultNameProvider();\r\n        if (!cNameProvider.compareAndSet(null, nameProvider)) {\r\n            nameProvider = cNameProvider.get();\r\n        }\r\n    }\r\n    return nameProvider;\r\n}"
}, {
	"Path": "jodd.db.DbQueryBase.setGeneratedKey",
	"Comment": "specifies that database will generate some columns values,\tusually the single id.",
	"Method": "Q setGeneratedKey(){\r\n    setGeneratedColumns();\r\n    return _this();\r\n}"
}, {
	"Path": "org.json.JSONObject.optString",
	"Comment": "get an optional string associated with a key. it returns the defaultvalueif there is no such key.",
	"Method": "String optString(String key,String optString,String key,String defaultValue){\r\n    Object object = this.opt(key);\r\n    return NULL.equals(object) ? defaultValue : object.toString();\r\n}"
}, {
	"Path": "org.joda.time.field.AbstractPartialFieldProperty.getMaximumValueOverall",
	"Comment": "gets the maximum value for the field ignoring the current time.",
	"Method": "int getMaximumValueOverall(){\r\n    return getField().getMaximumValue();\r\n}"
}, {
	"Path": "jodd.typeconverter.Converter.toString",
	"Comment": "converts value to string. returns default value\twhen conversion result is null",
	"Method": "String toString(Object value,String toString,Object value,String defaultValue){\r\n    final String result = toString(value);\r\n    if (result == null) {\r\n        return defaultValue;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.json.Property.toJSONObject",
	"Comment": "converts a property file object into a jsonobject. the property file object is a table of name value pairs.",
	"Method": "JSONObject toJSONObject(java.util.Properties properties){\r\n    JSONObject jo = new JSONObject();\r\n    if (properties != null && !properties.isEmpty()) {\r\n        Enumeration<?> enumProperties = properties.propertyNames();\r\n        while (enumProperties.hasMoreElements()) {\r\n            String name = (String) enumProperties.nextElement();\r\n            jo.put(name, properties.getProperty(name));\r\n        }\r\n    }\r\n    return jo;\r\n}"
}, {
	"Path": "jodd.db.type.SqlTypeManager.lookup",
	"Comment": "retrieves sql type for provided type. all subclasses and interfaces are examined\tfor matching sql type.",
	"Method": "SqlType lookup(Class clazz){\r\n    SqlType sqlType;\r\n    for (Class x = clazz; x != null; x = x.getSuperclass()) {\r\n        sqlType = types.get(clazz);\r\n        if (sqlType != null) {\r\n            return sqlType;\r\n        }\r\n        Class[] interfaces = x.getInterfaces();\r\n        for (Class i : interfaces) {\r\n            sqlType = types.get(i);\r\n            if (sqlType != null) {\r\n                return sqlType;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "jodd.asm7.ByteVector.put122",
	"Comment": "puts one byte and two shorts into this byte vector. the byte vector is automatically enlargedif necessary.",
	"Method": "ByteVector put122(int byteValue,int shortValue1,int shortValue2){\r\n    int currentLength = length;\r\n    if (currentLength + 5 > data.length) {\r\n        enlarge(5);\r\n    }\r\n    byte[] currentData = data;\r\n    currentData[currentLength++] = (byte) byteValue;\r\n    currentData[currentLength++] = (byte) (shortValue1 >>> 8);\r\n    currentData[currentLength++] = (byte) shortValue1;\r\n    currentData[currentLength++] = (byte) (shortValue2 >>> 8);\r\n    currentData[currentLength++] = (byte) shortValue2;\r\n    length = currentLength;\r\n    return this;\r\n}"
}, {
	"Path": "jodd.json.JsonSerializer.excludeTypes",
	"Comment": "excludes types. supports interfaces and subclasses as well.",
	"Method": "JsonSerializer excludeTypes(String typeNames,JsonSerializer excludeTypes,Class types){\r\n    if (excludedTypes == null) {\r\n        excludedTypes = types;\r\n    } else {\r\n        excludedTypes = ArraysUtil.join(excludedTypes, types);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.joda.time.YearMonth.year",
	"Comment": "get the year field property which provides access to advanced functionality.",
	"Method": "Property year(){\r\n    return new Property(this, YEAR);\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.Session.setDestination",
	"Comment": "the destination address for all the streams of the session. \tchanges will be taken into account the next time you start the session.",
	"Method": "void setDestination(String destination){\r\n    mDestination = destination;\r\n}"
}, {
	"Path": "jodd.vtor.constraint.AssertValidConstraint.isValid",
	"Comment": "invokes validation on inner context. always returns true since\tinner context violations will be appended to provided validator.",
	"Method": "boolean isValid(ValidationConstraintContext vcc,Object value){\r\n    if (value == null) {\r\n        return true;\r\n    }\r\n    vcc.validateWithin(targetValidationContext, value);\r\n    return true;\r\n}"
}, {
	"Path": "jodd.bean.BeanVisitorImplBase.includeAs",
	"Comment": "defines included property names as public properties\tof given template class. sets to black list mode.",
	"Method": "T includeAs(Class template){\r\n    blacklist = false;\r\n    String[] properties = getAllBeanPropertyNames(template, false);\r\n    include(properties);\r\n    return _this();\r\n}"
}, {
	"Path": "org.joda.time.LocalTime.equals",
	"Comment": "compares this readablepartial with another returning true if the chronology,field types and values are equal.",
	"Method": "boolean equals(Object partial){\r\n    if (this == partial) {\r\n        return true;\r\n    }\r\n    if (partial instanceof LocalTime) {\r\n        LocalTime other = (LocalTime) partial;\r\n        if (iChronology.equals(other.iChronology)) {\r\n            return iLocalMillis == other.iLocalMillis;\r\n        }\r\n    }\r\n    return super.equals(partial);\r\n}"
}, {
	"Path": "jodd.net.MimeTypes.registerMimeType",
	"Comment": "registers mime type for provided extension. existing extension type will be overridden.",
	"Method": "void registerMimeType(String ext,String mimeType){\r\n    MIME_TYPE_MAP.put(ext, mimeType);\r\n}"
}, {
	"Path": "jodd.madvoc.component.MadvocControllerCfg.setPreventCaching",
	"Comment": "specifies if madvoc should add response params to prevent browser caching.",
	"Method": "void setPreventCaching(boolean preventCaching){\r\n    this.preventCaching = preventCaching;\r\n}"
}, {
	"Path": "jodd.vtor.Vtor.setSeverity",
	"Comment": "set validation severity. only checks with equal and higher severity\twill be checked.",
	"Method": "void setSeverity(int severity){\r\n    this.severity = severity;\r\n}"
}, {
	"Path": "org.joda.time.DateTime.toLocalDateTime",
	"Comment": "converts this object to a localdatetime withthe same datetime and chronology.",
	"Method": "LocalDateTime toLocalDateTime(){\r\n    return new LocalDateTime(getMillis(), getChronology());\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractInstant.isAfter",
	"Comment": "is this instant strictly after the instant passed incomparing solely by millisecond.",
	"Method": "boolean isAfter(long instant,boolean isAfter,ReadableInstant instant){\r\n    long instantMillis = DateTimeUtils.getInstantMillis(instant);\r\n    return isAfter(instantMillis);\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.MatchersRoutineType.getExpression",
	"Comment": "this routine matcher applies to all unqualified or qualified routine names matched by this expression. if left empty, this matcher applies to all routines.",
	"Method": "String getExpression(){\r\n    return expression;\r\n}"
}, {
	"Path": "jodd.util.collection.SortedArrayList.getComparator",
	"Comment": "returns comparator assigned to this collection, if such exist.",
	"Method": "Comparator getComparator(){\r\n    return comparator;\r\n}"
}, {
	"Path": "jodd.db.DbQueryBase.getOpenResultSetCount",
	"Comment": "returns number of created result sets that are still not explicitly closed.",
	"Method": "int getOpenResultSetCount(){\r\n    return resultSets == null ? 0 : resultSets.size();\r\n}"
}, {
	"Path": "org.joda.time.LocalDate.monthOfYear",
	"Comment": "get the month of year property which provides access to advanced functionality.",
	"Method": "Property monthOfYear(){\r\n    return new Property(this, getChronology().monthOfYear());\r\n}"
}, {
	"Path": "org.joda.time.Years.minus",
	"Comment": "returns a new instance with the specified number of years taken away.this instance is immutable and unaffected by this method call.",
	"Method": "Years minus(int years,Years minus,Years years){\r\n    if (years == null) {\r\n        return this;\r\n    }\r\n    return minus(years.getValue());\r\n}"
}, {
	"Path": "jodd.servlet.filter.CharArrayResponseWrapper.toCharArray",
	"Comment": "get the underlying character array or null if\twriter not used.",
	"Method": "char[] toCharArray(){\r\n    if (writer == null) {\r\n        return null;\r\n    }\r\n    return writer.toCharArray();\r\n}"
}, {
	"Path": "jodd.madvoc.result.AbstractTemplateViewActionResult.resolveTarget",
	"Comment": "locates the target file from action path and the result value.",
	"Method": "String resolveTarget(ActionRequest actionRequest,String resultValue){\r\n    String resultBasePath = actionRequest.getActionRuntime().getResultBasePath();\r\n    ResultPath resultPath = resultMapper.resolveResultPath(resultBasePath, resultValue);\r\n    String actionPath = resultPath.path();\r\n    String path = actionPath;\r\n    String value = resultPath.value();\r\n    if (StringUtil.isEmpty(value)) {\r\n        value = null;\r\n    }\r\n    String target;\r\n    while (true) {\r\n        if (value != null) {\r\n            if (path == null) {\r\n                int lastSlashNdx = actionPath.lastIndexOf('/');\r\n                if (lastSlashNdx != -1) {\r\n                    target = actionPath.substring(0, lastSlashNdx + 1) + value;\r\n                } else {\r\n                    target = '/' + value;\r\n                }\r\n            } else {\r\n                target = path + '.' + value;\r\n            }\r\n            target = locateTarget(actionRequest, target);\r\n            if (target != null) {\r\n                break;\r\n            }\r\n        }\r\n        if (path != null) {\r\n            target = locateTarget(actionRequest, path);\r\n            if (target != null) {\r\n                break;\r\n            }\r\n        }\r\n        if (path == null) {\r\n            return null;\r\n        }\r\n        int dotNdx = MadvocUtil.lastIndexOfDotAfterSlash(path);\r\n        if (dotNdx == -1) {\r\n            path = null;\r\n        } else {\r\n            path = path.substring(0, dotNdx);\r\n        }\r\n    }\r\n    return target;\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.plus",
	"Comment": "returns a copy of this datetime with the specified duration added.if the amount is zero or null, then this is returned.",
	"Method": "LocalDateTime plus(ReadableDuration duration,LocalDateTime plus,ReadablePeriod period){\r\n    return withPeriodAdded(period, 1);\r\n}"
}, {
	"Path": "org.jsonschema2pojo.rules.RuleFactory.getNameHelper",
	"Comment": "gets the name helper that is used to generate normalized class and fieldnames.",
	"Method": "NameHelper getNameHelper(){\r\n    return nameHelper;\r\n}"
}, {
	"Path": "org.joda.time.format.DateTimeFormatter.withLocale",
	"Comment": "returns a new formatter with a different locale that will be usedfor printing and parsing.a datetimeformatter is immutable, so a new instance is returned,and the original is unaltered and still usable.",
	"Method": "DateTimeFormatter withLocale(Locale locale){\r\n    if (locale == getLocale() || (locale != null && locale.equals(getLocale()))) {\r\n        return this;\r\n    }\r\n    return new DateTimeFormatter(iPrinter, iParser, locale, iOffsetParsed, iChrono, iZone, iPivotYear, iDefaultYear);\r\n}"
}, {
	"Path": "jodd.joy.page.PageData.hasNextPage",
	"Comment": "returns true if there is a next page, i.e. we are not at the last page.",
	"Method": "boolean hasNextPage(){\r\n    return currentPage < totalPages - 1;\r\n}"
}, {
	"Path": "jodd.asm7.TypeReference.newTypeParameterReference",
	"Comment": "returns a reference to a type parameter of a generic class or method.",
	"Method": "TypeReference newTypeParameterReference(int sort,int paramIndex){\r\n    return new TypeReference((sort << 24) | (paramIndex << 16));\r\n}"
}, {
	"Path": "jodd.util.ClassUtil.isUserDefinedMethod",
	"Comment": "returns true if method is user defined and not defined in object class.",
	"Method": "boolean isUserDefinedMethod(Method method){\r\n    return method.getDeclaringClass() != Object.class;\r\n}"
}, {
	"Path": "jodd.util.StringUtil.countIgnoreCase",
	"Comment": "count substring occurrences in a source string, ignoring case.",
	"Method": "int countIgnoreCase(String source,String sub){\r\n    int count = 0;\r\n    int j = 0;\r\n    int sublen = sub.length();\r\n    if (sublen == 0) {\r\n        return 0;\r\n    }\r\n    while (true) {\r\n        int i = indexOfIgnoreCase(source, sub, j);\r\n        if (i == -1) {\r\n            break;\r\n        }\r\n        count++;\r\n        j = i + sublen;\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "jodd.bean.BeanCopy.visitProperty",
	"Comment": "copies single property to the destination.\texceptions are ignored, so copying continues if\tdestination does not have some of the sources properties.",
	"Method": "boolean visitProperty(String name,Object value){\r\n    if (isTargetMap) {\r\n        name = LEFT_SQ_BRACKET + name + RIGHT_SQ_BRACKET;\r\n    }\r\n    beanUtil.setProperty(destination, name, value);\r\n    return true;\r\n}"
}, {
	"Path": "org.joda.time.PeriodType.yearWeekDayTime",
	"Comment": "gets a type that defines all standard fields except months.yearsweeksdayshoursminutessecondsmilliseconds",
	"Method": "PeriodType yearWeekDayTime(){\r\n    PeriodType type = cYWDTime;\r\n    if (type == null) {\r\n        type = new PeriodType(\"YearWeekDayTime\", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.weeks(), DurationFieldType.days(), DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { 0, -1, 1, 2, 3, 4, 5, 6 });\r\n        cYWDTime = type;\r\n    }\r\n    return type;\r\n}"
}, {
	"Path": "org.jooq.impl.DSL.localDateAdd",
	"Comment": "add an interval to a date, given a date part.this translates into any dialect",
	"Method": "Field<LocalDate> localDateAdd(LocalDate date,Number interval,Field<LocalDate> localDateAdd,Field<LocalDate> date,Field<? extends Number> interval,Field<LocalDate> localDateAdd,LocalDate date,Number interval,DatePart datePart,Field<LocalDate> localDateAdd,LocalDate date,Field<? extends Number> interval,DatePart datePart,Field<LocalDate> localDateAdd,Field<LocalDate> date,Number interval,DatePart datePart,Field<LocalDate> localDateAdd,Field<LocalDate> date,Field<? extends Number> interval,DatePart datePart){\r\n    return new DateAdd<LocalDate>(nullSafe(date), nullSafe(interval), datePart);\r\n}"
}, {
	"Path": "org.joda.time.chrono.GregorianChronology.getInstance",
	"Comment": "gets an instance of the gregorianchronology in the given time zone.",
	"Method": "GregorianChronology getInstance(GregorianChronology getInstance,DateTimeZone zone,GregorianChronology getInstance,DateTimeZone zone,int minDaysInFirstWeek){\r\n    if (zone == null) {\r\n        zone = DateTimeZone.getDefault();\r\n    }\r\n    GregorianChronology chrono;\r\n    GregorianChronology[] chronos = cCache.get(zone);\r\n    if (chronos == null) {\r\n        chronos = new GregorianChronology[7];\r\n        GregorianChronology[] oldChronos = cCache.putIfAbsent(zone, chronos);\r\n        if (oldChronos != null) {\r\n            chronos = oldChronos;\r\n        }\r\n    }\r\n    try {\r\n        chrono = chronos[minDaysInFirstWeek - 1];\r\n    } catch (ArrayIndexOutOfBoundsException e) {\r\n        throw new IllegalArgumentException(\"Invalid min days in first week: \" + minDaysInFirstWeek);\r\n    }\r\n    if (chrono == null) {\r\n        synchronized (chronos) {\r\n            chrono = chronos[minDaysInFirstWeek - 1];\r\n            if (chrono == null) {\r\n                if (zone == DateTimeZone.UTC) {\r\n                    chrono = new GregorianChronology(null, null, minDaysInFirstWeek);\r\n                } else {\r\n                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\r\n                    chrono = new GregorianChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);\r\n                }\r\n                chronos[minDaysInFirstWeek - 1] = chrono;\r\n            }\r\n        }\r\n    }\r\n    return chrono;\r\n}"
}, {
	"Path": "jodd.system.JavaInfo.isAtLeastJavaVersion",
	"Comment": "checks if the currently running jvm is at least compliant\twith provided jdk version.",
	"Method": "boolean isAtLeastJavaVersion(int version){\r\n    return JAVA_VERSION_NUMBER >= version;\r\n}"
}, {
	"Path": "jodd.asm7.Label.put",
	"Comment": "puts a reference to this label in the bytecode of a method. if the bytecode offset of the labelis known, the relative bytecode offset between the label and the instruction referencing it iscomputed and written directly. otherwise, a null relative offset is written and a new forwardreference is declared for this label.",
	"Method": "void put(ByteVector code,int sourceInsnBytecodeOffset,boolean wideReference){\r\n    if ((flags & FLAG_RESOLVED) == 0) {\r\n        if (wideReference) {\r\n            addForwardReference(sourceInsnBytecodeOffset, FORWARD_REFERENCE_TYPE_WIDE, code.length);\r\n            code.putInt(-1);\r\n        } else {\r\n            addForwardReference(sourceInsnBytecodeOffset, FORWARD_REFERENCE_TYPE_SHORT, code.length);\r\n            code.putShort(-1);\r\n        }\r\n    } else {\r\n        if (wideReference) {\r\n            code.putInt(bytecodeOffset - sourceInsnBytecodeOffset);\r\n        } else {\r\n            code.putShort(bytecodeOffset - sourceInsnBytecodeOffset);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jodd.introspector.Properties.getAllPropertyDescriptors",
	"Comment": "returns all property descriptors.\tproperties are sorted by name.",
	"Method": "PropertyDescriptor[] getAllPropertyDescriptors(){\r\n    if (allProperties == null) {\r\n        PropertyDescriptor[] allProperties = new PropertyDescriptor[propertyDescriptors.size()];\r\n        int index = 0;\r\n        for (PropertyDescriptor propertyDescriptor : propertyDescriptors.values()) {\r\n            allProperties[index] = propertyDescriptor;\r\n            index++;\r\n        }\r\n        Arrays.sort(allProperties, new Comparator<PropertyDescriptor>() {\r\n            @Override\r\n            public int compare(final PropertyDescriptor pd1, final PropertyDescriptor pd2) {\r\n                return pd1.getName().compareTo(pd2.getName());\r\n            }\r\n        });\r\n        this.allProperties = allProperties;\r\n    }\r\n    return allProperties;\r\n}"
}, {
	"Path": "jodd.introspector.Properties.getAllPropertyDescriptors",
	"Comment": "returns all property descriptors.\tproperties are sorted by name.",
	"Method": "PropertyDescriptor[] getAllPropertyDescriptors(){\r\n    return pd1.getName().compareTo(pd2.getName());\r\n}"
}, {
	"Path": "com.jayway.jsonpath.Criteria.subsetof",
	"Comment": "the subsetof operator selects objects for which the specified field isan array whose elements comprise a subset of the set comprised by the elements ofthe specified array.",
	"Method": "Criteria subsetof(Object o,Criteria subsetof,Collection<?> c){\r\n    notNull(c, \"collection can not be null\");\r\n    this.criteriaType = RelationalOperator.SUBSETOF;\r\n    this.right = new ValueNode.ValueListNode(c);\r\n    return this;\r\n}"
}, {
	"Path": "org.joda.time.chrono.StrictChronology.equals",
	"Comment": "a strict chronology is only equal to a strict chronology with thesame base chronology.",
	"Method": "boolean equals(Object obj){\r\n    if (this == obj) {\r\n        return true;\r\n    }\r\n    if (obj instanceof StrictChronology == false) {\r\n        return false;\r\n    }\r\n    StrictChronology chrono = (StrictChronology) obj;\r\n    return getBase().equals(chrono.getBase());\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Generate.isComments",
	"Comment": "turn off generation of all sql comments as javadoc on all objects.",
	"Method": "Boolean isComments(){\r\n    return comments;\r\n}"
}, {
	"Path": "jodd.htmlstapler.HtmlStaplerBundlesManager.setDownloadLocal",
	"Comment": "sets if local resource files should be downloaded or loaded from file system.",
	"Method": "void setDownloadLocal(boolean downloadLocal){\r\n    this.downloadLocal = downloadLocal;\r\n}"
}, {
	"Path": "org.joda.time.YearMonthDay.property",
	"Comment": "gets the property object for the specified type, which containsmany useful methods.",
	"Method": "Property property(DateTimeFieldType type){\r\n    return new Property(this, indexOfSupported(type));\r\n}"
}, {
	"Path": "jodd.db.oom.sqlgen.chunks.ColumnsSelectChunk.appendColumnName",
	"Comment": "simply appends column name with optional table reference and alias.",
	"Method": "void appendColumnName(StringBuilder query,DbEntityDescriptor ded,DbEntityColumnDescriptor dec){\r\n    query.append(resolveTable(tableRef, ded)).append('.').append(dec.getColumnName());\r\n    if (templateData.getColumnAliasType() != null) {\r\n        query.append(AS);\r\n        switch(templateData.getColumnAliasType()) {\r\n            case TABLE_NAME:\r\n                {\r\n                    final String tableName = ded.getTableNameForQuery();\r\n                    query.append(tableName).append(columnAliasSeparator).append(dec.getColumnNameForQuery());\r\n                    break;\r\n                }\r\n            case TABLE_REFERENCE:\r\n                {\r\n                    final String tableName = ded.getTableName();\r\n                    templateData.registerColumnDataForTableRef(tableRef, tableName);\r\n                    query.append(tableRef).append(columnAliasSeparator).append(dec.getColumnNameForQuery());\r\n                    break;\r\n                }\r\n            case COLUMN_CODE:\r\n                {\r\n                    final String tableName = ded.getTableName();\r\n                    final String code = templateData.registerColumnDataForColumnCode(tableName, dec.getColumnName());\r\n                    query.append(code);\r\n                    break;\r\n                }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.chrono.GJChronology.getGregorianCutover",
	"Comment": "gets the cutover instant between gregorian and julian chronologies.",
	"Method": "Instant getGregorianCutover(){\r\n    return iCutoverInstant;\r\n}"
}, {
	"Path": "org.joda.time.Months.multipliedBy",
	"Comment": "returns a new instance with the months multiplied by the specified scalar.this instance is immutable and unaffected by this method call.",
	"Method": "Months multipliedBy(int scalar){\r\n    return Months.months(FieldUtils.safeMultiply(getValue(), scalar));\r\n}"
}, {
	"Path": "com.jayway.jsonpath.Criteria.empty",
	"Comment": "the notempty operator checks that an array or string is empty.",
	"Method": "Criteria empty(boolean empty){\r\n    this.criteriaType = RelationalOperator.EMPTY;\r\n    this.right = empty ? ValueNode.TRUE : ValueNode.FALSE;\r\n    return this;\r\n}"
}, {
	"Path": "org.jsonschema2pojo.rules.RequiredRule.apply",
	"Comment": "applies this schema rule to take the required code generation steps.the required rule simply adds a note to the javadoc comment to mark aproperty as required.",
	"Method": "JDocCommentable apply(String nodeName,JsonNode node,JsonNode parent,JDocCommentable generatableType,Schema schema){\r\n    if (node.asBoolean()) {\r\n        generatableType.javadoc().append(\"\\n(Required)\");\r\n        if (ruleFactory.getGenerationConfig().isIncludeJsr303Annotations() && generatableType instanceof JFieldVar) {\r\n            ((JFieldVar) generatableType).annotate(NotNull.class);\r\n        }\r\n        if (ruleFactory.getGenerationConfig().isIncludeJsr305Annotations() && generatableType instanceof JFieldVar) {\r\n            ((JFieldVar) generatableType).annotate(Nonnull.class);\r\n        }\r\n    } else {\r\n        if (ruleFactory.getGenerationConfig().isIncludeJsr305Annotations() && generatableType instanceof JFieldVar) {\r\n            ((JFieldVar) generatableType).annotate(Nullable.class);\r\n        }\r\n    }\r\n    return generatableType;\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Database.isIncludeUDTs",
	"Comment": "this flag indicates whether udts should be included in output produced by this database",
	"Method": "Boolean isIncludeUDTs(){\r\n    return includeUDTs;\r\n}"
}, {
	"Path": "jodd.util.collection.IntHashMap.putAll",
	"Comment": "copies all of the mappings from the specified map to this one.\tthese mappings replace any mappings that this map had for any of the\tkeys currently in the specified map.",
	"Method": "void putAll(Map t){\r\n    for (Object o : t.entrySet()) {\r\n        Map.Entry e = (Map.Entry) o;\r\n        put(e.getKey(), e.getValue());\r\n    }\r\n}"
}, {
	"Path": "jodd.bean.BeanUtilUtil.invokeSetter",
	"Comment": "invokes setter, but first converts type to match the setter type.",
	"Method": "Object invokeSetter(Setter setter,BeanProperty bp,Object value){\r\n    try {\r\n        final MapperFunction setterMapperFunction = setter.getMapperFunction();\r\n        if (setterMapperFunction != null) {\r\n            value = setterMapperFunction.apply(value);\r\n        }\r\n        final Class type = setter.getSetterRawType();\r\n        if (ClassUtil.isTypeOf(type, Collection.class)) {\r\n            Class componentType = setter.getSetterRawComponentType();\r\n            value = convertToCollection(value, type, componentType);\r\n        } else {\r\n            value = convertType(value, type);\r\n        }\r\n        setter.invokeSetter(bp.bean, value);\r\n    } catch (Exception ex) {\r\n        if (isSilent) {\r\n            return null;\r\n        }\r\n        throw new BeanException(\"Setter failed: \" + setter, ex);\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "jodd.servlet.ServletUtil.getCookie",
	"Comment": "finds and returns cookie from client by its name.\tonly the first cookie is returned.",
	"Method": "Cookie getCookie(HttpServletRequest request,String cookieName){\r\n    Cookie[] cookies = request.getCookies();\r\n    if (cookies != null) {\r\n        for (Cookie cookie : cookies) {\r\n            if (cookie.getName().equals(cookieName)) {\r\n                return cookie;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.gl.TextureManager.changeFragmentShader",
	"Comment": "replaces the fragment shader.pass in null to reset to default.",
	"Method": "void changeFragmentShader(String fragmentShader){\r\n    if (fragmentShader == null) {\r\n        fragmentShader = FRAGMENT_SHADER;\r\n    }\r\n    GLES20.glDeleteProgram(mProgram);\r\n    mProgram = createProgram(VERTEX_SHADER, fragmentShader);\r\n    if (mProgram == 0) {\r\n        throw new RuntimeException(\"failed creating program\");\r\n    }\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.Session.release",
	"Comment": "deletes all existing tracks & release associated resources.",
	"Method": "void release(){\r\n    removeAudioTrack();\r\n    removeVideoTrack();\r\n    mHandler.getLooper().quit();\r\n}"
}, {
	"Path": "org.joda.time.DateMidnight.minus",
	"Comment": "returns a copy of this date with the specified duration taken away.if the amount is zero or null, then this is returned.",
	"Method": "DateMidnight minus(long duration,DateMidnight minus,ReadableDuration duration,DateMidnight minus,ReadablePeriod period){\r\n    return withPeriodAdded(period, -1);\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.withDayOfWeek",
	"Comment": "returns a copy of this datetime with the day of week field updated.localdatetime is immutable, so there are no set methods.instead, this method returns a new instance with the value ofday of week changed.",
	"Method": "LocalDateTime withDayOfWeek(int dayOfWeek){\r\n    return withLocalMillis(getChronology().dayOfWeek().set(getLocalMillis(), dayOfWeek));\r\n}"
}, {
	"Path": "org.jooq.codegen.JavaGenerator.generateUDTRecordGetter",
	"Comment": "subclasses may override this method to provide their own record getters.",
	"Method": "void generateUDTRecordGetter(TypedElementDefinition<?> column,int index,JavaWriter out){\r\n    generateRecordGetter0(column, index, out);\r\n}"
}, {
	"Path": "org.json.JSONPointer.toURIFragment",
	"Comment": "returns a string representing the jsonpointer path value using urifragment identifier representation",
	"Method": "String toURIFragment(){\r\n    try {\r\n        StringBuilder rval = new StringBuilder(\"#\");\r\n        for (String token : this.refTokens) {\r\n            rval.append('/').append(URLEncoder.encode(token, ENCODING));\r\n        }\r\n        return rval.toString();\r\n    } catch (UnsupportedEncodingException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.Session.getBitrate",
	"Comment": "returns an approximation of the bandwidth consumed by the session in bit per second.",
	"Method": "long getBitrate(){\r\n    long sum = 0;\r\n    if (mAudioStream != null)\r\n        sum += mAudioStream.getBitrate();\r\n    if (mVideoStream != null)\r\n        sum += mVideoStream.getBitrate();\r\n    return sum;\r\n}"
}, {
	"Path": "jodd.decora.DecoraManager.decorateRequest",
	"Comment": "determines if a request should be decorated.\tby default returns true.",
	"Method": "boolean decorateRequest(HttpServletRequest request){\r\n    return true;\r\n}"
}, {
	"Path": "jodd.proxetta.asm.TargetClassInfoReader.lookupMethodSignatureVisitor",
	"Comment": "returns method signature for some method. if signature is not found, returns null.\tfounded signatures means that those method can be proxyfied.",
	"Method": "MethodSignatureVisitor lookupMethodSignatureVisitor(int access,String name,String desc,String className){\r\n    String key = ProxettaAsmUtil.createMethodSignaturesKey(access, name, desc, className);\r\n    return methodSignatures.get(key);\r\n}"
}, {
	"Path": "org.joda.time.DateTime.millisOfDay",
	"Comment": "get the millis of day property which provides access to advanced functionality.",
	"Method": "Property millisOfDay(){\r\n    return new Property(this, getChronology().millisOfDay());\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractInstant.toDateTimeISO",
	"Comment": "get this object as a datetime using isochronology in the same zone.",
	"Method": "DateTime toDateTimeISO(){\r\n    return new DateTime(getMillis(), ISOChronology.getInstance(getZone()));\r\n}"
}, {
	"Path": "org.joda.time.Weeks.weeks",
	"Comment": "obtains an instance of weeks that may be cached.weeks is immutable, so instances can be cached and shared.this factory method provides access to shared instances.",
	"Method": "Weeks weeks(int weeks){\r\n    switch(weeks) {\r\n        case 0:\r\n            return ZERO;\r\n        case 1:\r\n            return ONE;\r\n        case 2:\r\n            return TWO;\r\n        case 3:\r\n            return THREE;\r\n        case Integer.MAX_VALUE:\r\n            return MAX_VALUE;\r\n        case Integer.MIN_VALUE:\r\n            return MIN_VALUE;\r\n        default:\r\n            return new Weeks(weeks);\r\n    }\r\n}"
}, {
	"Path": "org.json.CDL.rowToJSONObject",
	"Comment": "produce a jsonobject from a row of comma delimited text, using aparallel jsonarray of strings to provides the names of the elements.",
	"Method": "JSONObject rowToJSONObject(JSONArray names,JSONTokener x){\r\n    JSONArray ja = rowToJSONArray(x);\r\n    return ja != null ? ja.toJSONObject(names) : null;\r\n}"
}, {
	"Path": "jodd.mail.SendMailSession.sendMail",
	"Comment": "prepares message and sends it. returns message id of sent email.",
	"Method": "String sendMail(Email email){\r\n    try {\r\n        final MimeMessage msg = createMessage(email);\r\n        getService().sendMessage(msg, msg.getAllRecipients());\r\n        return msg.getMessageID();\r\n    } catch (final MessagingException msgexc) {\r\n        throw new MailException(\"Failed to send email: \" + email, msgexc);\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractDuration.isEqual",
	"Comment": "is the length of this duration equal to the duration passed in.the comparison takes into account the sign.as such, a duration of 5 seconds is not equal to a duration of minus 5 seconds.",
	"Method": "boolean isEqual(ReadableDuration duration){\r\n    if (duration == null) {\r\n        duration = Duration.ZERO;\r\n    }\r\n    return compareTo(duration) == 0;\r\n}"
}, {
	"Path": "jodd.util.CharUtil.equalsOne",
	"Comment": "match if one character equals to any of the given character.",
	"Method": "boolean equalsOne(char c,char[] match){\r\n    for (char aMatch : match) {\r\n        if (c == aMatch) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.joda.time.field.UnsupportedDateTimeField.getDurationField",
	"Comment": "even though this datetimefield is unsupported, the duration field mightbe supported.",
	"Method": "DurationField getDurationField(){\r\n    return iDurationField;\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractPartial.indexOfSupported",
	"Comment": "gets the index of the first fields to have the specified duration,throwing an exception if the field is unsupported.",
	"Method": "int indexOfSupported(DateTimeFieldType type,int indexOfSupported,DurationFieldType type){\r\n    int index = indexOf(type);\r\n    if (index == -1) {\r\n        throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\");\r\n    }\r\n    return index;\r\n}"
}, {
	"Path": "jodd.log.LoggerFactory.getLogger",
	"Comment": "returns logger for given name. repeated calls to this method with the\tsame argument should return the very same instance of the logger.",
	"Method": "Logger getLogger(Class clazz,Logger getLogger,String name){\r\n    if (loggers == null) {\r\n        return loggerProvider.apply(name);\r\n    }\r\n    return loggers.computeIfAbsent(name, loggerProvider);\r\n}"
}, {
	"Path": "jodd.petite.PetiteContainer.invokeMethod",
	"Comment": "invokes the method of some bean with the container, when its parameters requires to be injected into.\tthe bean is not registered within container.",
	"Method": "T invokeMethod(Object bean,Method method){\r\n    final WiringMode wiringMode = petiteConfig.resolveWiringMode(null);\r\n    final BeanDefinition def = externalsCache.get(bean.getClass(), () -> {\r\n        final BeanDefinition beanDefinition = createBeandDefinitionForExternalBeans(bean.getClass(), wiringMode);\r\n        initBeanDefinition(beanDefinition);\r\n        return beanDefinition;\r\n    });\r\n    final BeanData beanData = new BeanData(this, def, bean);\r\n    for (MethodInjectionPoint methodInjectionPoint : def.methods) {\r\n        if (methodInjectionPoint.method.equals(method)) {\r\n            return (T) beanData.invokeMethodInjectionPoint(methodInjectionPoint);\r\n        }\r\n    }\r\n    try {\r\n        return (T) method.invoke(bean);\r\n    } catch (Exception e) {\r\n        throw new PetiteException(e);\r\n    }\r\n}"
}, {
	"Path": "jodd.htmlstapler.HtmlStaplerBundlesManager.isNotFoundExceptionEnabled",
	"Comment": "returns true if exception will be thrown when\tresource is not found.",
	"Method": "boolean isNotFoundExceptionEnabled(){\r\n    return notFoundExceptionEnabled;\r\n}"
}, {
	"Path": "jodd.decora.parser.DecoraTag.duplicate",
	"Comment": "duplicates static content of the class, for caching purposes.\tif a decorator is static content, it does not have to be\tparsed all over again. instead, just store parsed list of\tdecoratags and duplicate it.",
	"Method": "DecoraTag duplicate(){\r\n    return new DecoraTag(name, id, start, end, defaultValueStart, defaultValueLength);\r\n}"
}, {
	"Path": "jodd.db.oom.DbOomQuery.list",
	"Comment": "iterates result set, maps rows to classes and populates resulting array list.",
	"Method": "List<T> list(Class types,List<T> list,List<T> list,int max,Class types,List<T> list,int max,List<T> list,Class[] types,int max,boolean close){\r\n    List<T> result = new ArrayList(initialCollectionSize(max));\r\n    ResultSetMapper rsm = executeAndBuildResultSetMapper();\r\n    if (types == null) {\r\n        types = rsm.resolveTables();\r\n    }\r\n    Object previousElement = null;\r\n    while (rsm.next()) {\r\n        Object[] objects = rsm.parseObjects(types);\r\n        Object row = resolveRowResults(objects);\r\n        int size = result.size();\r\n        T newElement = (T) row;\r\n        if (entityAwareMode && size > 0) {\r\n            if (previousElement != null && newElement != null) {\r\n                boolean equals;\r\n                if (newElement.getClass().isArray()) {\r\n                    equals = Arrays.equals((Object[]) previousElement, (Object[]) newElement);\r\n                } else {\r\n                    equals = previousElement.equals(newElement);\r\n                }\r\n                if (equals) {\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n        if (size == max) {\r\n            break;\r\n        }\r\n        result.add(newElement);\r\n        previousElement = newElement;\r\n    }\r\n    close(rsm, close);\r\n    return result;\r\n}"
}, {
	"Path": "org.jooq.codegen.JavaGenerator.generateCatalogClassJavadoc",
	"Comment": "subclasses may override this method to provide their own javadoc.",
	"Method": "void generateCatalogClassJavadoc(CatalogDefinition catalog,JavaWriter out){\r\n    if (generateCommentsOnCatalogs())\r\n        printClassJavadoc(out, catalog);\r\n    else\r\n        printClassJavadoc(out, \"The catalog <code>\" + catalog.getQualifiedInputName() + \"<\/code>.\");\r\n}"
}, {
	"Path": "jodd.bean.BeanUtilUtil.convertType",
	"Comment": "converts object to destination type. invoked before the\tvalue is set into destination. throws typeconversionexception\tif conversion fails.",
	"Method": "Object convertType(Object value,Class type){\r\n    return typeConverterManager.convertType(value, type);\r\n}"
}, {
	"Path": "jodd.mail.RFC2822AddressParser.removeAnyBounding",
	"Comment": "if the string starts and ends with start and end char, remove them,\totherwise return the string as it was passed in.",
	"Method": "String removeAnyBounding(char s,char e,String str){\r\n    if (str == null || str.length() < 2) {\r\n        return str;\r\n    }\r\n    if (str.startsWith(String.valueOf(s)) && str.endsWith(String.valueOf(e))) {\r\n        return str.substring(1, str.length() - 1);\r\n    }\r\n    return str;\r\n}"
}, {
	"Path": "jodd.jerry.Jerry.eq",
	"Comment": "reduces the set of matched elements to the one at the specified index.",
	"Method": "Jerry eq(int value){\r\n    List<Node> result = new NodeList(1);\r\n    int matchingIndex = value >= 0 ? value : nodes.length + value;\r\n    if (nodes.length > 0) {\r\n        int index = 0;\r\n        for (Node node : nodes) {\r\n            if (index == matchingIndex) {\r\n                result.add(node);\r\n                break;\r\n            }\r\n            index++;\r\n        }\r\n    }\r\n    return new Jerry(this, result);\r\n}"
}, {
	"Path": "org.joda.time.Minutes.minutesBetween",
	"Comment": "creates a minutes representing the number of whole minutesbetween the two specified partial datetimes.the two partials must contain the same fields, for example you can specifytwo localtime objects.",
	"Method": "Minutes minutesBetween(ReadableInstant start,ReadableInstant end,Minutes minutesBetween,ReadablePartial start,ReadablePartial end){\r\n    if (start instanceof LocalTime && end instanceof LocalTime) {\r\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\r\n        int minutes = chrono.minutes().getDifference(((LocalTime) end).getLocalMillis(), ((LocalTime) start).getLocalMillis());\r\n        return Minutes.minutes(minutes);\r\n    }\r\n    int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\r\n    return Minutes.minutes(amount);\r\n}"
}, {
	"Path": "jodd.cache.LRUCache.removeEldestEntry",
	"Comment": "removes the eldest entry if current cache size exceed cache size.",
	"Method": "boolean removeEldestEntry(int currentSize){\r\n    if (cacheSize == 0) {\r\n        return false;\r\n    }\r\n    return currentSize > cacheSize;\r\n}"
}, {
	"Path": "org.joda.time.format.DateTimeFormatter.isOffsetParsed",
	"Comment": "checks whether the offset from the string is used as the zone ofthe parsed datetime.",
	"Method": "boolean isOffsetParsed(){\r\n    return iOffsetParsed;\r\n}"
}, {
	"Path": "org.joda.time.field.PreciseDateTimeField.addWrapField",
	"Comment": "add to the component of the specified time instant, wrapping aroundwithin that component if necessary.",
	"Method": "long addWrapField(long instant,int amount){\r\n    int thisValue = get(instant);\r\n    int wrappedValue = FieldUtils.getWrappedValue(thisValue, amount, getMinimumValue(), getMaximumValue());\r\n    return instant + (wrappedValue - thisValue) * getUnitMillis();\r\n}"
}, {
	"Path": "org.joda.time.Hours.multipliedBy",
	"Comment": "returns a new instance with the hours multiplied by the specified scalar.this instance is immutable and unaffected by this method call.",
	"Method": "Hours multipliedBy(int scalar){\r\n    return Hours.hours(FieldUtils.safeMultiply(getValue(), scalar));\r\n}"
}, {
	"Path": "jodd.servlet.wrapper.BufferResponseWrapper.bufferStatusCode",
	"Comment": "determines if buffering should be used for some http status code.\tby default returns true only for status code 200.",
	"Method": "boolean bufferStatusCode(int statusCode){\r\n    return statusCode == 200;\r\n}"
}, {
	"Path": "jodd.db.oom.naming.BaseNamingStrategy.setSplitCamelCase",
	"Comment": "specifies if camel case name has to be split.\tif set to false, then name is passed unchanged.",
	"Method": "void setSplitCamelCase(boolean splitCamelCase){\r\n    this.splitCamelCase = splitCamelCase;\r\n}"
}, {
	"Path": "jodd.asm7.Handler.getExceptionTableLength",
	"Comment": "returns the number of elements of the handler list that begins with the given element.",
	"Method": "int getExceptionTableLength(Handler firstHandler){\r\n    int length = 0;\r\n    Handler handler = firstHandler;\r\n    while (handler != null) {\r\n        length++;\r\n        handler = handler.nextHandler;\r\n    }\r\n    return length;\r\n}"
}, {
	"Path": "jodd.proxetta.InvokeAspect.apply",
	"Comment": "determines if some method should be scanned for pointcuts.\treturns true if method should be scanned.",
	"Method": "boolean apply(MethodInfo methodInfo){\r\n    return true;\r\n}"
}, {
	"Path": "jodd.util.StringUtil.cutToIndexOf",
	"Comment": "cuts the string from beginning to the first index of provided char.",
	"Method": "String cutToIndexOf(String string,String substring,String cutToIndexOf,String string,char c){\r\n    int i = string.indexOf(c);\r\n    if (i != -1) {\r\n        string = string.substring(0, i);\r\n    }\r\n    return string;\r\n}"
}, {
	"Path": "org.jooq.impl.DSL.localDateDiff",
	"Comment": "get the date difference in number of days.this translates into any dialect",
	"Method": "Field<Integer> localDateDiff(LocalDate date1,LocalDate date2,Field<Integer> localDateDiff,Field<LocalDate> date1,LocalDate date2,Field<Integer> localDateDiff,LocalDate date1,Field<LocalDate> date2,Field<Integer> localDateDiff,Field<LocalDate> date1,Field<LocalDate> date2){\r\n    return new DateDiff<LocalDate>(nullSafe(date1), nullSafe(date2));\r\n}"
}, {
	"Path": "org.joda.time.Hours.hoursIn",
	"Comment": "creates a hours representing the number of whole hoursin the specified interval.",
	"Method": "Hours hoursIn(ReadableInterval interval){\r\n    if (interval == null) {\r\n        return Hours.ZERO;\r\n    }\r\n    int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.hours());\r\n    return Hours.hours(amount);\r\n}"
}, {
	"Path": "jodd.petite.resolver.ReferencesResolver.readAllReferencesFromAnnotation",
	"Comment": "extracts references from method or constructor annotation.",
	"Method": "BeanReferences[] readAllReferencesFromAnnotation(Executable methodOrCtor){\r\n    PetiteInject petiteInject = methodOrCtor.getAnnotation(PetiteInject.class);\r\n    final Parameter[] parameters = methodOrCtor.getParameters();\r\n    BeanReferences[] references;\r\n    final boolean hasAnnotationOnMethodOrCtor;\r\n    if (petiteInject != null) {\r\n        references = convertAnnValueToReferences(petiteInject.value());\r\n        hasAnnotationOnMethodOrCtor = true;\r\n    } else {\r\n        references = new BeanReferences[parameters.length];\r\n        hasAnnotationOnMethodOrCtor = false;\r\n    }\r\n    int parametersWithAnnotationCount = 0;\r\n    for (int i = 0; i < parameters.length; i++) {\r\n        Parameter parameter = parameters[i];\r\n        petiteInject = parameter.getAnnotation(PetiteInject.class);\r\n        if (petiteInject == null) {\r\n            continue;\r\n        }\r\n        String annotationValue = readAnnotationValue(petiteInject);\r\n        if (annotationValue != null) {\r\n            references[i] = BeanReferences.of(annotationValue);\r\n        }\r\n        parametersWithAnnotationCount++;\r\n    }\r\n    if (!hasAnnotationOnMethodOrCtor) {\r\n        if (parametersWithAnnotationCount == 0) {\r\n            return null;\r\n        }\r\n        if (parametersWithAnnotationCount != parameters.length) {\r\n            throw new PetiteException(\"All arguments must be annotated with PetiteInject\");\r\n        }\r\n    }\r\n    references = updateReferencesWithDefaultsIfNeeded(methodOrCtor, references);\r\n    removeAllDuplicateNames(references);\r\n    return references;\r\n}"
}, {
	"Path": "jodd.lagarto.dom.Node.check",
	"Comment": "checks the health of child nodes. useful during complex tree manipulation,\tto check if everything is ok. not optimized for speed, should be used just\tfor testing purposes.",
	"Method": "boolean check(){\r\n    if (childNodes == null) {\r\n        return true;\r\n    }\r\n    int siblingElementIndex = 0;\r\n    for (int i = 0, childNodesSize = childNodes.size(); i < childNodesSize; i++) {\r\n        Node childNode = childNodes.get(i);\r\n        if (childNode.siblingIndex != i) {\r\n            return false;\r\n        }\r\n        if (childNode.getNodeType() == NodeType.ELEMENT) {\r\n            if (childNode.siblingElementIndex != siblingElementIndex) {\r\n                return false;\r\n            }\r\n            siblingElementIndex++;\r\n        }\r\n    }\r\n    if (childElementNodesCount != siblingElementIndex) {\r\n        return false;\r\n    }\r\n    if (childElementNodes != null) {\r\n        if (childElementNodes.length != childElementNodesCount) {\r\n            return false;\r\n        }\r\n        int childCount = getChildNodesCount();\r\n        for (int i = 0; i < childCount; i++) {\r\n            Node child = getChild(i);\r\n            if (child.siblingElementIndex >= 0) {\r\n                if (childElementNodes[child.siblingElementIndex] != child) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (siblingNameIndex != -1) {\r\n        List<Node> siblings = parentNode.childNodes;\r\n        int index = 0;\r\n        for (int i = 0, siblingsSize = siblings.size(); i < siblingsSize; i++) {\r\n            Node sibling = siblings.get(i);\r\n            if (sibling.siblingNameIndex == -1 && nodeType == NodeType.ELEMENT && nodeName.equals(sibling.getNodeName())) {\r\n                if (sibling.siblingNameIndex != index++) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    for (Node childNode : childNodes) {\r\n        if (!childNode.check()) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.joda.time.LocalDate.withFields",
	"Comment": "returns a copy of this date with the partial set of fields replacingthose from this instance.for example, if the partial contains a year and a month then those twofields will be changed in the returned instance.unsupported fields are ignored.if the partial is null, then this is returned.",
	"Method": "LocalDate withFields(ReadablePartial partial){\r\n    if (partial == null) {\r\n        return this;\r\n    }\r\n    return withLocalMillis(getChronology().set(partial, getLocalMillis()));\r\n}"
}, {
	"Path": "org.joda.time.MutablePeriod.addWeeks",
	"Comment": "adds the specified weeks to the number of weeks in the period.",
	"Method": "void addWeeks(int weeks){\r\n    super.addField(DurationFieldType.weeks(), weeks);\r\n}"
}, {
	"Path": "jodd.typeconverter.Converter.toBoolean",
	"Comment": "converts value to boolean. returns default value\twhen conversion result is null",
	"Method": "Boolean toBoolean(Object value,Boolean toBoolean,Object value,Boolean defaultValue){\r\n    final Boolean result = toBoolean(value);\r\n    if (result == null) {\r\n        return defaultValue;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "jodd.util.BinarySearchBase.find",
	"Comment": "finds index of given element in inclusive index range. returns negative\tvalue if element is not found.",
	"Method": "int find(int low,int high){\r\n    while (low <= high) {\r\n        int mid = (low + high) >>> 1;\r\n        int delta = compare(mid);\r\n        if (delta < 0) {\r\n            low = mid + 1;\r\n        } else if (delta > 0) {\r\n            high = mid - 1;\r\n        } else {\r\n            return mid;\r\n        }\r\n    }\r\n    return -(low + 1);\r\n}"
}, {
	"Path": "jodd.madvoc.Madvoc.setMadvocConfiguratorClass",
	"Comment": "sets class that will be used for configuring the user actions.",
	"Method": "void setMadvocConfiguratorClass(Class madvocConfiguratorClass){\r\n    this.madvocConfiguratorClass = madvocConfiguratorClass;\r\n    this.madvocConfiguratorClassName = null;\r\n}"
}, {
	"Path": "jodd.jerry.Jerry.find",
	"Comment": "gets the descendants of each element in the current set of matched elements,\t filtered by a selector.",
	"Method": "Jerry find(String cssSelector){\r\n    final List<Node> result = new NodeList();\r\n    if (nodes.length > 0) {\r\n        for (Node node : nodes) {\r\n            NodeSelector nodeSelector = createNodeSelector(node);\r\n            List<Node> filteredNodes = nodeSelector.select(cssSelector);\r\n            result.addAll(filteredNodes);\r\n        }\r\n    }\r\n    return new Jerry(this, result);\r\n}"
}, {
	"Path": "jodd.db.pool.CoreConnectionPool.setWaitIfBusy",
	"Comment": "sets if pool should wait for connection to be freed when none\tis available. if wait for busy is false\texception will be thrown when max connection is reached.",
	"Method": "void setWaitIfBusy(boolean waitIfBusy){\r\n    this.waitIfBusy = waitIfBusy;\r\n}"
}, {
	"Path": "jodd.madvoc.config.Targets.forEachTargetAndIn",
	"Comment": "iterates all targets and for each target iterates all in injection points of given scope.",
	"Method": "void forEachTargetAndIn(MadvocScope scope,BiConsumer<Target, InjectionPoint> biConsumer){\r\n    for (final Target target : targets) {\r\n        final ScopeData scopeData = target.scopeData();\r\n        if (scopeData.in() == null) {\r\n            continue;\r\n        }\r\n        for (final InjectionPoint in : scopeData.in()) {\r\n            if (in.scope() != scope) {\r\n                continue;\r\n            }\r\n            biConsumer.accept(target, in);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jodd.petite.scope.SessionScope.shutdown",
	"Comment": "shutdowns the session scope. calls destroyable methods on\tall destroyable beans available in this moment.",
	"Method": "void shutdown(){\r\n    super.shutdown();\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.size",
	"Comment": "gets the number of fields in this partial, which is four.the supported fields are year, monthofday, dayofmonth and millisofday.",
	"Method": "int size(){\r\n    return 4;\r\n}"
}, {
	"Path": "jodd.decora.parser.DecoraTag.isRegionDefined",
	"Comment": "returns true if region is fully defined.\treturns false if region is either started or\tundefined.",
	"Method": "boolean isRegionDefined(){\r\n    return regionLength != 0;\r\n}"
}, {
	"Path": "jodd.db.oom.naming.BaseNamingStrategy.setChangeCase",
	"Comment": "specifies if database names should be convert to\tuppercase or lowercase.",
	"Method": "void setChangeCase(boolean changeCase){\r\n    this.changeCase = changeCase;\r\n}"
}, {
	"Path": "org.joda.time.MonthDay.property",
	"Comment": "gets the property object for the specified type, which containsmany useful methods.",
	"Method": "Property property(DateTimeFieldType type){\r\n    return new Property(this, indexOfSupported(type));\r\n}"
}, {
	"Path": "org.jooq.conf.Settings.getQueryTimeout",
	"Comment": "the default jdbc querytimeout property that should be applied to alljooq queries, for which no specific querytimeout was specified.",
	"Method": "Integer getQueryTimeout(){\r\n    return queryTimeout;\r\n}"
}, {
	"Path": "org.jooq.impl.Tools.escapeForLike",
	"Comment": "utility method to escape string fields, or cast other fields",
	"Method": "Field<String> escapeForLike(Object value,Field<String> escapeForLike,Object value,Configuration configuration,Field<String> escapeForLike,Field<?> field,Field<String> escapeForLike,Field<?> field,Configuration configuration){\r\n    if (nullSafe(field).getDataType().isString()) {\r\n        {\r\n            return escape((Field<String>) field, ESCAPE);\r\n        }\r\n    } else {\r\n        return field.cast(String.class);\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractPartial.isSupported",
	"Comment": "checks whether the field specified is supported by this partial.",
	"Method": "boolean isSupported(DateTimeFieldType type){\r\n    return (indexOf(type) != -1);\r\n}"
}, {
	"Path": "org.joda.time.base.BasePeriod.toDurationFrom",
	"Comment": "gets the total millisecond duration of this period relative to a start instant.this method adds the period to the specified instant in order tocalculate the duration.an instant must be supplied as the duration of a period varies.for example, a period of 1 month could vary between the equivalent of28 and 31 days in milliseconds due to different length months.similarly, a day can vary at daylight savings cutover, typically between23 and 25 hours.",
	"Method": "Duration toDurationFrom(ReadableInstant startInstant){\r\n    long startMillis = DateTimeUtils.getInstantMillis(startInstant);\r\n    Chronology chrono = DateTimeUtils.getInstantChronology(startInstant);\r\n    long endMillis = chrono.add(this, startMillis, 1);\r\n    return new Duration(startMillis, endMillis);\r\n}"
}, {
	"Path": "jodd.jtx.JtxTransaction.rollbackAllResources",
	"Comment": "rollbacks all attached resources. resource will be closed. and detached from this transaction.\tif exception occurs, it will be rethrown at the end.",
	"Method": "void rollbackAllResources(boolean wasForced){\r\n    status = STATUS_ROLLING_BACK;\r\n    Exception lastException = null;\r\n    Iterator<JtxResource> it = resources.iterator();\r\n    while (it.hasNext()) {\r\n        JtxResource resource = it.next();\r\n        try {\r\n            resource.rollbackTransaction();\r\n        } catch (Exception ex) {\r\n            lastException = ex;\r\n        } finally {\r\n            it.remove();\r\n        }\r\n    }\r\n    txManager.removeTransaction(this);\r\n    status = STATUS_ROLLEDBACK;\r\n    if (lastException != null) {\r\n        status = STATUS_UNKNOWN;\r\n        throw new JtxException(\"Rollback failed: one or more TX resources couldn't rollback a TX\", lastException);\r\n    }\r\n    if (wasForced) {\r\n        throw new JtxException(\"TX rolled back because it has been marked as rollback-only\", rollbackCause);\r\n    }\r\n}"
}, {
	"Path": "jodd.util.ClassUtil.findConstructor",
	"Comment": "finds constructor with given parameter types. first matched ctor is returned.",
	"Method": "Constructor<T> findConstructor(Class<T> clazz,Class<?> parameterTypes){\r\n    final Constructor<?>[] constructors = clazz.getConstructors();\r\n    Class<?>[] pts;\r\n    for (Constructor<?> constructor : constructors) {\r\n        pts = constructor.getParameterTypes();\r\n        if (isAllAssignableFrom(pts, parameterTypes)) {\r\n            return (Constructor<T>) constructor;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.joda.time.DateMidnight.dayOfYear",
	"Comment": "get the day of year property which provides access to advanced functionality.",
	"Method": "Property dayOfYear(){\r\n    return new Property(this, getChronology().dayOfYear());\r\n}"
}, {
	"Path": "jodd.http.HttpRequest.port",
	"Comment": "returns request port number. when port is not\texplicitly defined, returns default port for\tcurrent protocol.",
	"Method": "int port(HttpRequest port,int port){\r\n    this.port = port;\r\n    return this;\r\n}"
}, {
	"Path": "jodd.exception.ExceptionUtil.unwrapThrowable",
	"Comment": "unwraps invocation and undeclared exceptions to real cause.",
	"Method": "Throwable unwrapThrowable(Throwable wrappedThrowable){\r\n    Throwable unwrapped = wrappedThrowable;\r\n    while (true) {\r\n        if (unwrapped instanceof InvocationTargetException) {\r\n            unwrapped = ((InvocationTargetException) unwrapped).getTargetException();\r\n        } else if (unwrapped instanceof UndeclaredThrowableException) {\r\n            unwrapped = ((UndeclaredThrowableException) unwrapped).getUndeclaredThrowable();\r\n        } else {\r\n            return unwrapped;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jodd.db.oom.naming.ColumnNamingStrategy.applyToColumnName",
	"Comment": "applies column naming strategy to given column name hint.\treturns full column name.",
	"Method": "String applyToColumnName(String columnName){\r\n    String propertyName = convertColumnNameToPropertyName(columnName);\r\n    return convertPropertyNameToColumnName(propertyName);\r\n}"
}, {
	"Path": "jodd.util.StringUtil.stripToChar",
	"Comment": "strips everything up to the first appearance of given char.\tcharacter is included in the returned string.",
	"Method": "String stripToChar(String string,char c){\r\n    int ndx = string.indexOf(c);\r\n    if (ndx == -1) {\r\n        return string;\r\n    }\r\n    return string.substring(ndx);\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Database.isIncludePackageUDTs",
	"Comment": "this flag indicates whether udts contained in packages should be included in output produced by this database",
	"Method": "Boolean isIncludePackageUDTs(){\r\n    return includePackageUDTs;\r\n}"
}, {
	"Path": "jodd.props.Props.clone",
	"Comment": "clones props by creating new instance and copying current configuration.",
	"Method": "Props clone(){\r\n    final PropsParser parser = this.parser.clone();\r\n    final Props p = new Props(parser);\r\n    p.activeProfilesProp = activeProfilesProp;\r\n    return p;\r\n}"
}, {
	"Path": "org.joda.time.format.ISODateTimeFormat.checkNotStrictISO",
	"Comment": "checks that the iso only flag is not set, throwing an exception if it is.",
	"Method": "void checkNotStrictISO(Collection<DateTimeFieldType> fields,boolean strictISO){\r\n    if (strictISO) {\r\n        throw new IllegalArgumentException(\"No valid ISO8601 format for fields: \" + fields);\r\n    }\r\n}"
}, {
	"Path": "jodd.servlet.CsrfShield.setMaxTokensPerSession",
	"Comment": "sets max number of tokens that will be stored for single session.\tit is actually the number of csrf validation that may occur in the\tsame time. limit prevents from malicious growing of the set.",
	"Method": "void setMaxTokensPerSession(int maxTokensPerSession){\r\n    CsrfShield.maxTokensPerSession = maxTokensPerSession;\r\n}"
}, {
	"Path": "jodd.db.DbQueryBase.close",
	"Comment": "closes the query and all created results sets and detaches itself from the session.",
	"Method": "void close(){\r\n    final SQLException sqlException = closeQuery();\r\n    connection = null;\r\n    if (this.session != null) {\r\n        this.session.detachQuery(this);\r\n    }\r\n    if (sqlException != null) {\r\n        throw new DbSqlException(\"Close query error\", sqlException);\r\n    }\r\n}"
}, {
	"Path": "jodd.decora.DecoraManager.decorateContentType",
	"Comment": "determines if some content type should be decorated.\tby default returns true.",
	"Method": "boolean decorateContentType(String contentType,String mimeType,String encoding){\r\n    return true;\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.hw.CodecManager.findDecodersForMimeType",
	"Comment": "lists all decoders that claim to support a color format that we know how to use.",
	"Method": "Codec[] findDecodersForMimeType(String mimeType){\r\n    if (sDecoders != null)\r\n        return sDecoders;\r\n    ArrayList<Codec> decoders = new ArrayList();\r\n    for (int j = MediaCodecList.getCodecCount() - 1; j >= 0; j--) {\r\n        MediaCodecInfo codecInfo = MediaCodecList.getCodecInfoAt(j);\r\n        if (codecInfo.isEncoder())\r\n            continue;\r\n        String[] types = codecInfo.getSupportedTypes();\r\n        for (int i = 0; i < types.length; i++) {\r\n            if (types[i].equalsIgnoreCase(mimeType)) {\r\n                try {\r\n                    MediaCodecInfo.CodecCapabilities capabilities = codecInfo.getCapabilitiesForType(mimeType);\r\n                    Set<Integer> formats = new HashSet();\r\n                    for (int k = 0; k < capabilities.colorFormats.length; k++) {\r\n                        int format = capabilities.colorFormats[k];\r\n                        for (int l = 0; l < SUPPORTED_COLOR_FORMATS.length; l++) {\r\n                            if (format == SUPPORTED_COLOR_FORMATS[l]) {\r\n                                formats.add(format);\r\n                            }\r\n                        }\r\n                    }\r\n                    Codec codec = new Codec(codecInfo.getName(), (Integer[]) formats.toArray(new Integer[formats.size()]));\r\n                    decoders.add(codec);\r\n                } catch (Exception e) {\r\n                    Log.wtf(TAG, e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    sDecoders = (Codec[]) decoders.toArray(new Codec[decoders.size()]);\r\n    for (int i = 0; i < sDecoders.length; i++) {\r\n        if (sDecoders[i].name.equalsIgnoreCase(\"omx.google.h264.decoder\")) {\r\n            Codec codec = sDecoders[0];\r\n            sDecoders[0] = sDecoders[i];\r\n            sDecoders[i] = codec;\r\n        }\r\n    }\r\n    return sDecoders;\r\n}"
}, {
	"Path": "org.jooq.codegen.JavaGenerator.generateDomainClassJavadoc",
	"Comment": "subclasses may override this method to provide their own javadoc.",
	"Method": "void generateDomainClassJavadoc(DomainDefinition e,JavaWriter out){\r\n    if (generateCommentsOnUDTs())\r\n        printClassJavadoc(out, e);\r\n    else\r\n        printClassJavadoc(out, \"The domain <code>\" + e.getQualifiedInputName() + \"<\/code>.\");\r\n}"
}, {
	"Path": "org.jsonschema2pojo.rules.DescriptionRule.apply",
	"Comment": "applies this schema rule to take the required code generation steps.when a description node is found and applied with this rule, the value ofthe description is added as a class level javadoc comment.",
	"Method": "JDocComment apply(String nodeName,JsonNode node,JsonNode parent,JDocCommentable generatableType,Schema schema){\r\n    JDocComment javadoc = generatableType.javadoc();\r\n    javadoc.append(node.asText());\r\n    return javadoc;\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.withDurationAdded",
	"Comment": "returns a copy of this datetime with the specified duration added.if the addition is zero, then this is returned.",
	"Method": "LocalDateTime withDurationAdded(ReadableDuration durationToAdd,int scalar){\r\n    if (durationToAdd == null || scalar == 0) {\r\n        return this;\r\n    }\r\n    long instant = getChronology().add(getLocalMillis(), durationToAdd.getMillis(), scalar);\r\n    return withLocalMillis(instant);\r\n}"
}, {
	"Path": "jodd.typeconverter.impl.CollectionConverter.createCollection",
	"Comment": "creates new collection of target component type.\tdefault implementation uses reflection to create\tan collection of target type. override it for better performances.",
	"Method": "Collection<T> createCollection(int length){\r\n    if (collectionType.isInterface()) {\r\n        if (collectionType == List.class) {\r\n            if (length > 0) {\r\n                return new ArrayList(length);\r\n            } else {\r\n                return new ArrayList();\r\n            }\r\n        }\r\n        if (collectionType == Set.class) {\r\n            if (length > 0) {\r\n                return new HashSet(length);\r\n            } else {\r\n                return new HashSet();\r\n            }\r\n        }\r\n        throw new TypeConversionException(\"Unknown collection: \" + collectionType.getName());\r\n    }\r\n    if (length > 0) {\r\n        try {\r\n            Constructor<Collection<T>> ctor = (Constructor<Collection<T>>) collectionType.getConstructor(int.class);\r\n            return ctor.newInstance(Integer.valueOf(length));\r\n        } catch (Exception ex) {\r\n        }\r\n    }\r\n    try {\r\n        return collectionType.getDeclaredConstructor().newInstance();\r\n    } catch (Exception ex) {\r\n        throw new TypeConversionException(ex);\r\n    }\r\n}"
}, {
	"Path": "org.json.JSONObject.isNull",
	"Comment": "determine if the value associated with the key is null or if there is novalue.",
	"Method": "boolean isNull(String key){\r\n    return JSONObject.NULL.equals(this.opt(key));\r\n}"
}, {
	"Path": "jodd.io.upload.impl.MemoryFileUpload.processStream",
	"Comment": "reads data from input stream into byte array and stores file size.",
	"Method": "void processStream(){\r\n    FastByteArrayOutputStream out = new FastByteArrayOutputStream();\r\n    size = 0;\r\n    if (maxFileSize == -1) {\r\n        size += input.copyAll(out);\r\n    } else {\r\n        size += input.copyMax(out, maxFileSize + 1);\r\n        if (size > maxFileSize) {\r\n            fileTooBig = true;\r\n            valid = false;\r\n            input.skipToBoundary();\r\n            return;\r\n        }\r\n    }\r\n    data = out.toByteArray();\r\n    size = data.length;\r\n    valid = true;\r\n}"
}, {
	"Path": "jodd.madvoc.scope.RequestScope.injectUploadedFiles",
	"Comment": "inject uploaded files from multipart request parameters.",
	"Method": "void injectUploadedFiles(HttpServletRequest servletRequest,Targets targets){\r\n    if (!(servletRequest instanceof MultipartRequestWrapper)) {\r\n        return;\r\n    }\r\n    final MultipartRequestWrapper multipartRequest = (MultipartRequestWrapper) servletRequest;\r\n    if (!multipartRequest.isMultipart()) {\r\n        return;\r\n    }\r\n    final Enumeration<String> paramNames = multipartRequest.getFileParameterNames();\r\n    while (paramNames.hasMoreElements()) {\r\n        final String paramName = paramNames.nextElement();\r\n        if (servletRequest.getAttribute(paramName) != null) {\r\n            continue;\r\n        }\r\n        targets.forEachTargetAndIn(this, (target, in) -> {\r\n            final String name = in.matchedName(paramName);\r\n            if (name != null) {\r\n                final FileUpload[] paramValues = multipartRequest.getFiles(paramName);\r\n                if (ignoreInvalidUploadFiles) {\r\n                    for (int j = 0; j < paramValues.length; j++) {\r\n                        final FileUpload paramValue = paramValues[j];\r\n                        if ((!paramValue.isValid()) || (!paramValue.isUploaded())) {\r\n                            paramValues[j] = null;\r\n                        }\r\n                    }\r\n                }\r\n                final Object value = (paramValues.length == 1 ? paramValues[0] : paramValues);\r\n                target.writeValue(name, value, true);\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "org.jsonschema2pojo.rules.RuleFactory.getValidRule",
	"Comment": "provides a rule instance that should be applied when a propertydeclaration is found in the schema which itself contains properties, toassign validation of the properties within that property",
	"Method": "Rule<JFieldVar, JFieldVar> getValidRule(){\r\n    return new ValidRule(this);\r\n}"
}, {
	"Path": "org.joda.time.chrono.GJChronology.getInstance",
	"Comment": "factory method returns instances of the gj cutover chronology. anycutover date may be specified.",
	"Method": "GJChronology getInstance(GJChronology getInstance,DateTimeZone zone,GJChronology getInstance,DateTimeZone zone,ReadableInstant gregorianCutover,GJChronology getInstance,DateTimeZone zone,ReadableInstant gregorianCutover,int minDaysInFirstWeek,GJChronology getInstance,DateTimeZone zone,long gregorianCutover,int minDaysInFirstWeek){\r\n    Instant cutoverInstant;\r\n    if (gregorianCutover == DEFAULT_CUTOVER.getMillis()) {\r\n        cutoverInstant = null;\r\n    } else {\r\n        cutoverInstant = new Instant(gregorianCutover);\r\n    }\r\n    return getInstance(zone, cutoverInstant, minDaysInFirstWeek);\r\n}"
}, {
	"Path": "org.json.JSONObject.optLong",
	"Comment": "get an optional long value associated with a key, or the default if thereis no such key or if the value is not a number. if the value is a string,an attempt will be made to evaluate it as a number.",
	"Method": "long optLong(String key,long optLong,String key,long defaultValue){\r\n    final Number val = this.optNumber(key, null);\r\n    if (val == null) {\r\n        return defaultValue;\r\n    }\r\n    return val.longValue();\r\n}"
}, {
	"Path": "org.joda.time.chrono.LenientChronology.equals",
	"Comment": "a lenient chronology is only equal to a lenient chronology with thesame base chronology.",
	"Method": "boolean equals(Object obj){\r\n    if (this == obj) {\r\n        return true;\r\n    }\r\n    if (obj instanceof LenientChronology == false) {\r\n        return false;\r\n    }\r\n    LenientChronology chrono = (LenientChronology) obj;\r\n    return getBase().equals(chrono.getBase());\r\n}"
}, {
	"Path": "org.joda.time.chrono.AssembledChronology.getBase",
	"Comment": "returns the same base chronology as passed into the constructor.",
	"Method": "Chronology getBase(){\r\n    return iBase;\r\n}"
}, {
	"Path": "org.joda.example.time.DateTimeBrowser.getADate",
	"Comment": "getadate returns a new datetime object reference if possible,otherwise null.",
	"Method": "DateTime getADate(String s){\r\n    DateTime retDT = null;\r\n    try {\r\n        retDT = new DateTime(s);\r\n    } catch (IllegalArgumentException pe) {\r\n    }\r\n    return retDT;\r\n}"
}, {
	"Path": "jodd.vtor.Vtor.getViolations",
	"Comment": "returns the list of validation violations or null if validation is successful.",
	"Method": "List<Violation> getViolations(){\r\n    return violations;\r\n}"
}, {
	"Path": "org.joda.time.YearMonth.monthOfYear",
	"Comment": "get the month of year field property which provides access to advanced functionality.",
	"Method": "Property monthOfYear(){\r\n    return new Property(this, MONTH_OF_YEAR);\r\n}"
}, {
	"Path": "jodd.typeconverter.Converter.toByte",
	"Comment": "converts value to byte. returns default value\twhen conversion result is null",
	"Method": "Byte toByte(Object value,Byte toByte,Object value,Byte defaultValue){\r\n    final Byte result = toByte(value);\r\n    if (result == null) {\r\n        return defaultValue;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.joda.time.Period.multipliedBy",
	"Comment": "returns a new instance with each element in this period multipliedby the specified scalar.",
	"Method": "Period multipliedBy(int scalar){\r\n    if (this == ZERO || scalar == 1) {\r\n        return this;\r\n    }\r\n    int[] values = getValues();\r\n    for (int i = 0; i < values.length; i++) {\r\n        values[i] = FieldUtils.safeMultiply(values[i], scalar);\r\n    }\r\n    return new Period(values, getPeriodType());\r\n}"
}, {
	"Path": "org.joda.time.LocalTime.property",
	"Comment": "gets the property object for the specified type, which containsmany useful methods.",
	"Method": "Property property(DateTimeFieldType fieldType){\r\n    if (fieldType == null) {\r\n        throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\r\n    }\r\n    if (isSupported(fieldType) == false) {\r\n        throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\r\n    }\r\n    return new Property(this, fieldType.getField(getChronology()));\r\n}"
}, {
	"Path": "org.jooq.codegen.JavaGenerator.generateUDTInterfaceGetter",
	"Comment": "subclasses may override this method to provide their own interface getters.",
	"Method": "void generateUDTInterfaceGetter(TypedElementDefinition<?> column,int index,JavaWriter out){\r\n    generateInterfaceGetter0(column, index, out);\r\n}"
}, {
	"Path": "org.jooq.impl.DSL.val",
	"Comment": "get a bind value with an associated type.this will try to bind value as type in apreparedstatement. if value andtype are not compatible, jooq will first try to convert andthen to cast value to type.",
	"Method": "Param<T> val(T value,Param<Byte> val,byte value,Param<Byte> val,Byte value,Param<UByte> val,UByte value,Param<Short> val,short value,Param<Short> val,Short value,Param<UShort> val,UShort value,Param<Integer> val,int value,Param<Integer> val,Integer value,Param<UInteger> val,UInteger value,Param<Long> val,long value,Param<Long> val,Long value,Param<ULong> val,ULong value,Param<Float> val,float value,Param<Float> val,Float value,Param<Double> val,double value,Param<Double> val,Double value,Param<Boolean> val,boolean value,Param<Boolean> val,Boolean value,Param<BigDecimal> val,BigDecimal value,Param<BigInteger> val,BigInteger value,Param<byte[]> val,byte[] value,Param<String> val,String value,Param<Date> val,Date value,Param<Time> val,Time value,Param<Timestamp> val,Timestamp value,Param<LocalDate> val,LocalDate value,Param<LocalTime> val,LocalTime value,Param<LocalDateTime> val,LocalDateTime value,Param<OffsetTime> val,OffsetTime value,Param<OffsetDateTime> val,OffsetDateTime value,Param<Instant> val,Instant value,Param<UUID> val,UUID value,Param<T> val,Object value,Class<T> type,Param<T> val,Object value,Field<T> field,Param<T> val,Object value,DataType<T> type){\r\n    if (value instanceof UDTRecord) {\r\n        return new UDTConstant((UDTRecord) value);\r\n    } else {\r\n        T converted = type.convert(value);\r\n        return new Val<T>(converted, mostSpecific(converted, type));\r\n    }\r\n}"
}, {
	"Path": "jodd.servlet.filter.GzipResponseWrapper.getOutputStream",
	"Comment": "returns the servlet output stream associated with this response.",
	"Method": "ServletOutputStream getOutputStream(){\r\n    if (writer != null) {\r\n        throw new IllegalStateException(\"getWriter() has already been called for this response\");\r\n    }\r\n    if (stream == null) {\r\n        stream = createOutputStream();\r\n    }\r\n    return (stream);\r\n}"
}, {
	"Path": "jodd.madvoc.config.ActionRuntime.getMethodParams",
	"Comment": "returns method parameters information, or null if method has no params.",
	"Method": "MethodParam[] getMethodParams(){\r\n    return methodParams;\r\n}"
}, {
	"Path": "jodd.jtx.worker.LeanJtxWorker.getCurrentTransaction",
	"Comment": "returns current transaction or null if there is no transaction at the moment.",
	"Method": "JtxTransaction getCurrentTransaction(){\r\n    return txManager.getTransaction();\r\n}"
}, {
	"Path": "org.joda.time.format.DateTimeFormatterBuilder.appendCenturyOfEra",
	"Comment": "instructs the printer to emit a numeric century of era field.",
	"Method": "DateTimeFormatterBuilder appendCenturyOfEra(int minDigits,int maxDigits){\r\n    return appendSignedDecimal(DateTimeFieldType.centuryOfEra(), minDigits, maxDigits);\r\n}"
}, {
	"Path": "jodd.props.Props.setEscapeNewLineValue",
	"Comment": "specifies the new line string when eol is escaped.\tdefault value is an empty string.",
	"Method": "Props setEscapeNewLineValue(String escapeNewLineValue){\r\n    parser.escapeNewLineValue = escapeNewLineValue;\r\n    return this;\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.audio.AMRNBStream.getSessionDescription",
	"Comment": "returns a description of the stream using sdp. it can then be included in an sdp file.",
	"Method": "String getSessionDescription(){\r\n    return \"m=audio \" + String.valueOf(getDestinationPorts()[0]) + \" RTP/AVP 96\\r\\n\" + \"a=rtpmap:96 AMR/8000\\r\\n\" + \"a=fmtp:96 octet-align=1;\\r\\n\";\r\n}"
}, {
	"Path": "org.joda.time.Partial.getFieldTypes",
	"Comment": "gets an array of the field type of each of the fields thatthis partial supports.the fields are returned largest to smallest.",
	"Method": "DateTimeFieldType[] getFieldTypes(){\r\n    return (DateTimeFieldType[]) iTypes.clone();\r\n}"
}, {
	"Path": "org.jsonschema2pojo.rules.DynamicPropertiesRule.apply",
	"Comment": "this rule adds dynamic getter, setter and builder methods based on the properties and additional propertiesdefined in a schema.if accessors are being generated, then methods for getting and setting properties by name will be added.thesemethods first attempt to call the appropriate getter or setter for the property.if the named property is not defined,then the additional properties map is used.if builders are being generated, then a method for building properties by name will be added.this method firstattempts to call the builder for the property.if no property with the supplied name is defined, then the additionalproperties map is used.the methods generated by this class throw an illegalargumentexception, if the name specified for the property is unknown andadditional properties are not enabled.a classcastexception will be thrown, when the value being set is incompatible with thetype of the named property.",
	"Method": "JDefinedClass apply(String nodeName,JsonNode node,JsonNode parent,JDefinedClass jclass,Schema currentSchema){\r\n    if (!ruleFactory.getGenerationConfig().isIncludeDynamicAccessors() || (!ruleFactory.getGenerationConfig().isIncludeDynamicSetters() && !ruleFactory.getGenerationConfig().isIncludeDynamicGetters() && !ruleFactory.getGenerationConfig().isIncludeDynamicBuilders())) {\r\n        return jclass;\r\n    }\r\n    boolean isIncludeGetters = ruleFactory.getGenerationConfig().isIncludeGetters();\r\n    boolean isIncludeSetters = ruleFactory.getGenerationConfig().isIncludeSetters();\r\n    boolean isGenerateBuilders = ruleFactory.getGenerationConfig().isGenerateBuilders();\r\n    if (isIncludeGetters || isIncludeSetters || isGenerateBuilders) {\r\n        if (LanguageFeatures.canUseJava7(ruleFactory.getGenerationConfig())) {\r\n            if (isIncludeSetters) {\r\n                addInternalSetMethodJava7(jclass, node);\r\n            }\r\n            if (isIncludeGetters) {\r\n                addInternalGetMethodJava7(jclass, node);\r\n            }\r\n        } else {\r\n            if (isIncludeSetters) {\r\n                addInternalSetMethodJava6(jclass, node);\r\n            }\r\n            if (isIncludeGetters) {\r\n                addInternalGetMethodJava6(jclass, node);\r\n            }\r\n        }\r\n    }\r\n    if (isIncludeGetters) {\r\n        addGetMethods(jclass);\r\n    }\r\n    if (isIncludeSetters) {\r\n        addSetMethods(jclass);\r\n    }\r\n    if (isGenerateBuilders) {\r\n        addWithMethods(jclass);\r\n    }\r\n    return jclass;\r\n}"
}, {
	"Path": "org.joda.time.DateTimeZone.adjustOffset",
	"Comment": "adjusts the offset to be the earlier or later one during an overlap.",
	"Method": "long adjustOffset(long instant,boolean earlierOrLater){\r\n    long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR;\r\n    long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR;\r\n    long offsetBefore = getOffset(instantBefore);\r\n    long offsetAfter = getOffset(instantAfter);\r\n    if (offsetBefore <= offsetAfter) {\r\n        return instant;\r\n    }\r\n    long diff = offsetBefore - offsetAfter;\r\n    long transition = nextTransition(instantBefore);\r\n    long overlapStart = transition - diff;\r\n    long overlapEnd = transition + diff;\r\n    if (instant < overlapStart || instant >= overlapEnd) {\r\n        return instant;\r\n    }\r\n    long afterStart = instant - overlapStart;\r\n    if (afterStart >= diff) {\r\n        return earlierOrLater ? instant : instant - diff;\r\n    } else {\r\n        return earlierOrLater ? instant + diff : instant;\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.Partial.minus",
	"Comment": "gets a copy of this instance with the specified period take away.if the amount is zero or null, then this is returned.",
	"Method": "Partial minus(ReadablePeriod period){\r\n    return withPeriodAdded(period, -1);\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractPeriod.getFieldTypes",
	"Comment": "gets an array of the field types that this period supports.the fields are returned largest to smallest, for example hours, minutes, seconds.",
	"Method": "DurationFieldType[] getFieldTypes(){\r\n    DurationFieldType[] result = new DurationFieldType[size()];\r\n    for (int i = 0; i < result.length; i++) {\r\n        result[i] = getFieldType(i);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.SessionBuilder.setContext",
	"Comment": "access to the context is needed for the h264stream class to store some stuff in the sharedpreferences.\tnote that you should pass the application context, not the context of an activity.",
	"Method": "SessionBuilder setContext(Context context){\r\n    mContext = context;\r\n    return this;\r\n}"
}, {
	"Path": "org.joda.time.Days.multipliedBy",
	"Comment": "returns a new instance with the days multiplied by the specified scalar.this instance is immutable and unaffected by this method call.",
	"Method": "Days multipliedBy(int scalar){\r\n    return Days.days(FieldUtils.safeMultiply(getValue(), scalar));\r\n}"
}, {
	"Path": "org.jsonschema2pojo.rules.RuleFactory.getGenerationConfig",
	"Comment": "gets the configuration options that will influence the java codegenerated by rules created by this factory.",
	"Method": "GenerationConfig getGenerationConfig(){\r\n    return generationConfig;\r\n}"
}, {
	"Path": "org.joda.time.Hours.isLessThan",
	"Comment": "is this hours instance less than the specified number of hours.",
	"Method": "boolean isLessThan(Hours other){\r\n    if (other == null) {\r\n        return getValue() < 0;\r\n    }\r\n    return getValue() < other.getValue();\r\n}"
}, {
	"Path": "jodd.util.CharUtil.findFirstEqual",
	"Comment": "finds index of the first character in given array the matches any from the\tgiven set of characters.",
	"Method": "int findFirstEqual(char[] source,int index,char[] match,int findFirstEqual,char[] source,int index,char match){\r\n    for (int i = index; i < source.length; i++) {\r\n        if (source[i] == match) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "org.joda.time.format.DateTimeFormatterBuilder.canBuildPrinter",
	"Comment": "returns true if toprinter can be called without throwing anunsupportedoperationexception.",
	"Method": "boolean canBuildPrinter(){\r\n    return isPrinter(getFormatter());\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.MatchersEnumType.getExpression",
	"Comment": "this sequence matcher applies to all unqualified or qualified enum names matched by this expression. if left empty, this matcher applies to all enums.",
	"Method": "String getExpression(){\r\n    return expression;\r\n}"
}, {
	"Path": "org.jooq.codegen.JavaGenerator.generateArrayClassJavadoc",
	"Comment": "subclasses may override this method to provide their own javadoc.",
	"Method": "void generateArrayClassJavadoc(ArrayDefinition array,JavaWriter out){\r\n    if (generateCommentsOnUDTs())\r\n        printClassJavadoc(out, array);\r\n    else\r\n        printClassJavadoc(out, \"The type <code>\" + array.getQualifiedInputName() + \"<\/code>.\");\r\n}"
}, {
	"Path": "jodd.http.HttpRequest._reset",
	"Comment": "resets the request by resetting all additional values\tadded during the sending.",
	"Method": "void _reset(){\r\n    headers.remove(HEADER_HOST);\r\n}"
}, {
	"Path": "jodd.jerry.Jerry.text",
	"Comment": "sets the content of each element in the set of matched elements to the specified text.",
	"Method": "String text(Jerry text,String text){\r\n    if (nodes.length == 0) {\r\n        return this;\r\n    }\r\n    if (text == null) {\r\n        text = StringPool.EMPTY;\r\n    }\r\n    for (Node node : nodes) {\r\n        node.removeAllChilds();\r\n        Text textNode = new Text(node.getOwnerDocument(), text);\r\n        node.addChild(textNode);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.joda.time.Period.plusWeeks",
	"Comment": "returns a new period plus the specified number of weeks added.this period instance is immutable and unaffected by this method call.",
	"Method": "Period plusWeeks(int weeks){\r\n    if (weeks == 0) {\r\n        return this;\r\n    }\r\n    int[] values = getValues();\r\n    getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, weeks);\r\n    return new Period(values, getPeriodType());\r\n}"
}, {
	"Path": "jodd.petite.scope.ShutdownAwareScope.totalRegisteredDestroyableBeans",
	"Comment": "returns number of destroyable beans that have been registered.",
	"Method": "int totalRegisteredDestroyableBeans(){\r\n    if (destroyableBeans == null) {\r\n        return 0;\r\n    }\r\n    return destroyableBeans.size();\r\n}"
}, {
	"Path": "org.jooq.impl.AbstractField.mul",
	"Comment": "this default implementation is known to be overridden byexpression to generate neater expressions",
	"Method": "Field<T> mul(Number value,Field<T> mul,Field<? extends Number> value){\r\n    return new Expression<T>(MULTIPLY, this, nullSafe(value, getDataType()));\r\n}"
}, {
	"Path": "jodd.db.debug.LoggableAdvice.saveQueryParamValue",
	"Comment": "saves the parameter value obj for the specified position\tfor use in logging output.",
	"Method": "void saveQueryParamValue(int position,Object obj){\r\n    String strValue;\r\n    if (obj instanceof String || obj instanceof Date) {\r\n        strValue = \"'\" + obj + '\\'';\r\n    } else if (obj == null) {\r\n        strValue = \"<null>\";\r\n    } else {\r\n        strValue = Converter.get().toString(obj);\r\n    }\r\n    if (parameterValues == null) {\r\n        parameterValues = new ArrayList();\r\n    }\r\n    while (position >= parameterValues.size()) {\r\n        parameterValues.add(null);\r\n    }\r\n    parameterValues.set(position, strValue);\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Generate.isCommentsOnQueues",
	"Comment": "turn off generation of all sql comments as javadoc on all queues.",
	"Method": "Boolean isCommentsOnQueues(){\r\n    return commentsOnQueues;\r\n}"
}, {
	"Path": "org.joda.time.IllegalFieldValueException.getDurationFieldType",
	"Comment": "returns the durationfieldtype whose value was invalid, or null if not applicable.",
	"Method": "DurationFieldType getDurationFieldType(){\r\n    return iDurationFieldType;\r\n}"
}, {
	"Path": "org.joda.time.format.PeriodFormatterBuilder.maximumParsedDigits",
	"Comment": "set the maximum digits parsed for the next and following appendedfields. by default, the maximum digits parsed is ten.",
	"Method": "PeriodFormatterBuilder maximumParsedDigits(int maxDigits){\r\n    iMaxParsedDigits = maxDigits;\r\n    return this;\r\n}"
}, {
	"Path": "jodd.petite.def.BeanReferences.removeDuplicateNames",
	"Comment": "removes later duplicated references in an array.\treturns new instance of beanreferences if there was changes,\totherwise returns the same instance.",
	"Method": "BeanReferences removeDuplicateNames(){\r\n    if (names.length < 2) {\r\n        return this;\r\n    }\r\n    int nullCount = 0;\r\n    for (int i = 1; i < names.length; i++) {\r\n        String thisRef = names[i];\r\n        if (thisRef == null) {\r\n            nullCount++;\r\n            continue;\r\n        }\r\n        for (int j = 0; j < i; j++) {\r\n            if (names[j] == null) {\r\n                continue;\r\n            }\r\n            if (thisRef.equals(names[j])) {\r\n                names[i] = null;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (nullCount == 0) {\r\n        return this;\r\n    }\r\n    String[] newRefs = new String[names.length - nullCount];\r\n    int ndx = 0;\r\n    for (String name : names) {\r\n        if (name == null) {\r\n            continue;\r\n        }\r\n        newRefs[ndx] = name;\r\n        ndx++;\r\n    }\r\n    return new BeanReferences(newRefs);\r\n}"
}, {
	"Path": "jodd.petite.PetiteContainer.getBean",
	"Comment": "returns petite bean instance.\tpetite container will find the bean in corresponding scope and all its dependencies,\teither by constructor or property injection. when using constructor injection, cyclic dependencies\tcan not be prevented, but at least they are detected.",
	"Method": "T getBean(Class<T> type,Object getBean,BeanReferences beanReferences,T getBean,String name){\r\n    BeanDefinition def = lookupBeanDefinition(name);\r\n    if (def == null) {\r\n        ProviderDefinition providerDefinition = providers.get(name);\r\n        if (providerDefinition != null) {\r\n            return (T) invokeProvider(providerDefinition);\r\n        }\r\n        return null;\r\n    }\r\n    Object bean = def.scopeLookup();\r\n    if (bean == null) {\r\n        initBeanDefinition(def);\r\n        final BeanData beanData = new BeanData(this, def);\r\n        registerBeanAndWireAndInjectParamsAndInvokeInitMethods(beanData);\r\n        bean = beanData.bean();\r\n    }\r\n    return (T) bean;\r\n}"
}, {
	"Path": "jodd.joy.auth.AuthTag.setAuth",
	"Comment": "defines if body should be invoked if user is authenticated.",
	"Method": "void setAuth(boolean auth){\r\n    this.auth = auth;\r\n}"
}, {
	"Path": "jodd.typeconverter.Converter.toCharacter",
	"Comment": "converts value to character. returns default value\twhen conversion result is null",
	"Method": "Character toCharacter(Object value,Character toCharacter,Object value,Character defaultValue){\r\n    final Character result = toCharacter(value);\r\n    if (result == null) {\r\n        return defaultValue;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.joda.time.chrono.BasicWeekyearDateTimeField.set",
	"Comment": "set the year of a week based year component of the specified time instant.",
	"Method": "long set(long instant,int year){\r\n    FieldUtils.verifyValueBounds(this, Math.abs(year), iChronology.getMinYear(), iChronology.getMaxYear());\r\n    int thisWeekyear = get(instant);\r\n    if (thisWeekyear == year) {\r\n        return instant;\r\n    }\r\n    int thisDow = iChronology.getDayOfWeek(instant);\r\n    int weeksInFromYear = iChronology.getWeeksInYear(thisWeekyear);\r\n    int weeksInToYear = iChronology.getWeeksInYear(year);\r\n    int maxOutWeeks = (weeksInToYear < weeksInFromYear) ? weeksInToYear : weeksInFromYear;\r\n    int setToWeek = iChronology.getWeekOfWeekyear(instant);\r\n    if (setToWeek > maxOutWeeks) {\r\n        setToWeek = maxOutWeeks;\r\n    }\r\n    long workInstant = instant;\r\n    workInstant = iChronology.setYear(workInstant, year);\r\n    int workWoyYear = get(workInstant);\r\n    if (workWoyYear < year) {\r\n        workInstant += DateTimeConstants.MILLIS_PER_WEEK;\r\n    } else if (workWoyYear > year) {\r\n        workInstant -= DateTimeConstants.MILLIS_PER_WEEK;\r\n    }\r\n    int currentWoyWeek = iChronology.getWeekOfWeekyear(workInstant);\r\n    workInstant = workInstant + (setToWeek - currentWoyWeek) * (long) DateTimeConstants.MILLIS_PER_WEEK;\r\n    workInstant = iChronology.dayOfWeek().set(workInstant, thisDow);\r\n    return workInstant;\r\n}"
}, {
	"Path": "jodd.util.ClassUtil.resolveAllInterfaces",
	"Comment": "resolves all interfaces of a type. no duplicates are returned.\tdirect interfaces are prior the interfaces of subclasses in\tthe returned array.",
	"Method": "Class[] resolveAllInterfaces(Class type){\r\n    Set<Class> bag = new LinkedHashSet();\r\n    _resolveAllInterfaces(type, bag);\r\n    return bag.toArray(new Class[0]);\r\n}"
}, {
	"Path": "jodd.http.HttpBase.bodyBytes",
	"Comment": "returns raw body bytes. returns null if body is not specified.",
	"Method": "byte[] bodyBytes(){\r\n    if (body == null) {\r\n        return null;\r\n    }\r\n    try {\r\n        return body.getBytes(StringPool.ISO_8859_1);\r\n    } catch (UnsupportedEncodingException ignore) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.rtcp.SenderReport.setOutputStream",
	"Comment": "if a tcp is used as the transport protocol for the rtp session,\tthe output stream to which rtp packets will be written to must\tbe specified with this method.",
	"Method": "void setOutputStream(OutputStream os,byte channelIdentifier){\r\n    mTransport = TRANSPORT_TCP;\r\n    mOutputStream = os;\r\n    mTcpHeader[1] = channelIdentifier;\r\n}"
}, {
	"Path": "org.joda.time.MutablePeriod.addYears",
	"Comment": "adds the specified years to the number of years in the period.",
	"Method": "void addYears(int years){\r\n    super.addField(DurationFieldType.years(), years);\r\n}"
}, {
	"Path": "org.joda.time.Period.withField",
	"Comment": "creates a new period instance with the specified field set to a new value.this period instance is immutable and unaffected by this method call.",
	"Method": "Period withField(DurationFieldType field,int value){\r\n    if (field == null) {\r\n        throw new IllegalArgumentException(\"Field must not be null\");\r\n    }\r\n    int[] newValues = getValues();\r\n    super.setFieldInto(newValues, field, value);\r\n    return new Period(newValues, getPeriodType());\r\n}"
}, {
	"Path": "org.joda.time.Period.plusDays",
	"Comment": "returns a new period plus the specified number of days added.this period instance is immutable and unaffected by this method call.",
	"Method": "Period plusDays(int days){\r\n    if (days == 0) {\r\n        return this;\r\n    }\r\n    int[] values = getValues();\r\n    getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, days);\r\n    return new Period(values, getPeriodType());\r\n}"
}, {
	"Path": "jodd.proxetta.asm.ProxettaClassBuilder.makeStaticInitBlock",
	"Comment": "creates static initialization block that simply calls all\tadvice static init methods in correct order.",
	"Method": "void makeStaticInitBlock(){\r\n    if (wd.adviceClinits != null) {\r\n        MethodVisitor mv = wd.dest.visitMethod(AsmUtil.ACC_STATIC, CLINIT, DESC_VOID, null, null);\r\n        mv.visitCode();\r\n        for (String name : wd.adviceClinits) {\r\n            mv.visitMethodInsn(INVOKESTATIC, wd.thisReference, name, DESC_VOID, false);\r\n        }\r\n        mv.visitInsn(RETURN);\r\n        mv.visitMaxs(0, 0);\r\n        mv.visitEnd();\r\n    }\r\n}"
}, {
	"Path": "jodd.util.CharUtil.toByteArray",
	"Comment": "converts char array to byte array using provided encoding.",
	"Method": "byte[] toByteArray(char[] carr,byte[] toByteArray,char[] carr,String charset){\r\n    return StringUtil.getBytes(new String(carr), charset);\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Database.isIncludeIndexes",
	"Comment": "this flag indicates whether indexes should be included in output produced by this database",
	"Method": "Boolean isIncludeIndexes(){\r\n    return includeIndexes;\r\n}"
}, {
	"Path": "org.joda.time.field.AbstractReadableInstantFieldProperty.getMaximumValueOverall",
	"Comment": "gets the maximum value for the field ignoring the current time.",
	"Method": "int getMaximumValueOverall(){\r\n    return getField().getMaximumValue();\r\n}"
}, {
	"Path": "jodd.json.JsonParser.consume",
	"Comment": "consumes char at current position. if char is different, throws the exception.",
	"Method": "void consume(char c){\r\n    if (input[ndx] != c) {\r\n        syntaxError(\"Invalid char: expected \" + c);\r\n    }\r\n    ndx++;\r\n}"
}, {
	"Path": "jodd.json.JsonContext.matchPathToQueries",
	"Comment": "matched current path to queries. if match is found, provided include\tvalue may be changed.",
	"Method": "boolean matchPathToQueries(boolean include){\r\n    return jsonSerializer.rules.apply(path, include);\r\n}"
}, {
	"Path": "jodd.lagarto.TagAdapter.getTarget",
	"Comment": "returns target tag visitor. it may be another\tnested tagadapter or tagwriter.",
	"Method": "TagVisitor getTarget(){\r\n    return target;\r\n}"
}, {
	"Path": "jodd.asm7.Frame.execute",
	"Comment": "simulates the action of the given instruction on the output stack frame.",
	"Method": "void execute(int opcode,int arg,Symbol argSymbol,SymbolTable symbolTable){\r\n    int abstractType1;\r\n    int abstractType2;\r\n    int abstractType3;\r\n    int abstractType4;\r\n    switch(opcode) {\r\n        case Opcodes.NOP:\r\n        case Opcodes.INEG:\r\n        case Opcodes.LNEG:\r\n        case Opcodes.FNEG:\r\n        case Opcodes.DNEG:\r\n        case Opcodes.I2B:\r\n        case Opcodes.I2C:\r\n        case Opcodes.I2S:\r\n        case Opcodes.GOTO:\r\n        case Opcodes.RETURN:\r\n            break;\r\n        case Opcodes.ACONST_NULL:\r\n            push(NULL);\r\n            break;\r\n        case Opcodes.ICONST_M1:\r\n        case Opcodes.ICONST_0:\r\n        case Opcodes.ICONST_1:\r\n        case Opcodes.ICONST_2:\r\n        case Opcodes.ICONST_3:\r\n        case Opcodes.ICONST_4:\r\n        case Opcodes.ICONST_5:\r\n        case Opcodes.BIPUSH:\r\n        case Opcodes.SIPUSH:\r\n        case Opcodes.ILOAD:\r\n            push(INTEGER);\r\n            break;\r\n        case Opcodes.LCONST_0:\r\n        case Opcodes.LCONST_1:\r\n        case Opcodes.LLOAD:\r\n            push(LONG);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.FCONST_0:\r\n        case Opcodes.FCONST_1:\r\n        case Opcodes.FCONST_2:\r\n        case Opcodes.FLOAD:\r\n            push(FLOAT);\r\n            break;\r\n        case Opcodes.DCONST_0:\r\n        case Opcodes.DCONST_1:\r\n        case Opcodes.DLOAD:\r\n            push(DOUBLE);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.LDC:\r\n            switch(argSymbol.tag) {\r\n                case Symbol.CONSTANT_INTEGER_TAG:\r\n                    push(INTEGER);\r\n                    break;\r\n                case Symbol.CONSTANT_LONG_TAG:\r\n                    push(LONG);\r\n                    push(TOP);\r\n                    break;\r\n                case Symbol.CONSTANT_FLOAT_TAG:\r\n                    push(FLOAT);\r\n                    break;\r\n                case Symbol.CONSTANT_DOUBLE_TAG:\r\n                    push(DOUBLE);\r\n                    push(TOP);\r\n                    break;\r\n                case Symbol.CONSTANT_CLASS_TAG:\r\n                    push(REFERENCE_KIND | symbolTable.addType(\"java/lang/Class\"));\r\n                    break;\r\n                case Symbol.CONSTANT_STRING_TAG:\r\n                    push(REFERENCE_KIND | symbolTable.addType(\"java/lang/String\"));\r\n                    break;\r\n                case Symbol.CONSTANT_METHOD_TYPE_TAG:\r\n                    push(REFERENCE_KIND | symbolTable.addType(\"java/lang/invoke/MethodType\"));\r\n                    break;\r\n                case Symbol.CONSTANT_METHOD_HANDLE_TAG:\r\n                    push(REFERENCE_KIND | symbolTable.addType(\"java/lang/invoke/MethodHandle\"));\r\n                    break;\r\n                case Symbol.CONSTANT_DYNAMIC_TAG:\r\n                    push(symbolTable, argSymbol.value);\r\n                    break;\r\n                default:\r\n                    throw new AssertionError();\r\n            }\r\n            break;\r\n        case Opcodes.ALOAD:\r\n            push(getLocal(arg));\r\n            break;\r\n        case Opcodes.LALOAD:\r\n        case Opcodes.D2L:\r\n            pop(2);\r\n            push(LONG);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.DALOAD:\r\n        case Opcodes.L2D:\r\n            pop(2);\r\n            push(DOUBLE);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.AALOAD:\r\n            pop(1);\r\n            abstractType1 = pop();\r\n            push(abstractType1 == NULL ? abstractType1 : ELEMENT_OF + abstractType1);\r\n            break;\r\n        case Opcodes.ISTORE:\r\n        case Opcodes.FSTORE:\r\n        case Opcodes.ASTORE:\r\n            abstractType1 = pop();\r\n            setLocal(arg, abstractType1);\r\n            if (arg > 0) {\r\n                int previousLocalType = getLocal(arg - 1);\r\n                if (previousLocalType == LONG || previousLocalType == DOUBLE) {\r\n                    setLocal(arg - 1, TOP);\r\n                } else if ((previousLocalType & KIND_MASK) == LOCAL_KIND || (previousLocalType & KIND_MASK) == STACK_KIND) {\r\n                    setLocal(arg - 1, previousLocalType | TOP_IF_LONG_OR_DOUBLE_FLAG);\r\n                }\r\n            }\r\n            break;\r\n        case Opcodes.LSTORE:\r\n        case Opcodes.DSTORE:\r\n            pop(1);\r\n            abstractType1 = pop();\r\n            setLocal(arg, abstractType1);\r\n            setLocal(arg + 1, TOP);\r\n            if (arg > 0) {\r\n                int previousLocalType = getLocal(arg - 1);\r\n                if (previousLocalType == LONG || previousLocalType == DOUBLE) {\r\n                    setLocal(arg - 1, TOP);\r\n                } else if ((previousLocalType & KIND_MASK) == LOCAL_KIND || (previousLocalType & KIND_MASK) == STACK_KIND) {\r\n                    setLocal(arg - 1, previousLocalType | TOP_IF_LONG_OR_DOUBLE_FLAG);\r\n                }\r\n            }\r\n            break;\r\n        case Opcodes.IASTORE:\r\n        case Opcodes.BASTORE:\r\n        case Opcodes.CASTORE:\r\n        case Opcodes.SASTORE:\r\n        case Opcodes.FASTORE:\r\n        case Opcodes.AASTORE:\r\n            pop(3);\r\n            break;\r\n        case Opcodes.LASTORE:\r\n        case Opcodes.DASTORE:\r\n            pop(4);\r\n            break;\r\n        case Opcodes.POP:\r\n        case Opcodes.IFEQ:\r\n        case Opcodes.IFNE:\r\n        case Opcodes.IFLT:\r\n        case Opcodes.IFGE:\r\n        case Opcodes.IFGT:\r\n        case Opcodes.IFLE:\r\n        case Opcodes.IRETURN:\r\n        case Opcodes.FRETURN:\r\n        case Opcodes.ARETURN:\r\n        case Opcodes.TABLESWITCH:\r\n        case Opcodes.LOOKUPSWITCH:\r\n        case Opcodes.ATHROW:\r\n        case Opcodes.MONITORENTER:\r\n        case Opcodes.MONITOREXIT:\r\n        case Opcodes.IFNULL:\r\n        case Opcodes.IFNONNULL:\r\n            pop(1);\r\n            break;\r\n        case Opcodes.POP2:\r\n        case Opcodes.IF_ICMPEQ:\r\n        case Opcodes.IF_ICMPNE:\r\n        case Opcodes.IF_ICMPLT:\r\n        case Opcodes.IF_ICMPGE:\r\n        case Opcodes.IF_ICMPGT:\r\n        case Opcodes.IF_ICMPLE:\r\n        case Opcodes.IF_ACMPEQ:\r\n        case Opcodes.IF_ACMPNE:\r\n        case Opcodes.LRETURN:\r\n        case Opcodes.DRETURN:\r\n            pop(2);\r\n            break;\r\n        case Opcodes.DUP:\r\n            abstractType1 = pop();\r\n            push(abstractType1);\r\n            push(abstractType1);\r\n            break;\r\n        case Opcodes.DUP_X1:\r\n            abstractType1 = pop();\r\n            abstractType2 = pop();\r\n            push(abstractType1);\r\n            push(abstractType2);\r\n            push(abstractType1);\r\n            break;\r\n        case Opcodes.DUP_X2:\r\n            abstractType1 = pop();\r\n            abstractType2 = pop();\r\n            abstractType3 = pop();\r\n            push(abstractType1);\r\n            push(abstractType3);\r\n            push(abstractType2);\r\n            push(abstractType1);\r\n            break;\r\n        case Opcodes.DUP2:\r\n            abstractType1 = pop();\r\n            abstractType2 = pop();\r\n            push(abstractType2);\r\n            push(abstractType1);\r\n            push(abstractType2);\r\n            push(abstractType1);\r\n            break;\r\n        case Opcodes.DUP2_X1:\r\n            abstractType1 = pop();\r\n            abstractType2 = pop();\r\n            abstractType3 = pop();\r\n            push(abstractType2);\r\n            push(abstractType1);\r\n            push(abstractType3);\r\n            push(abstractType2);\r\n            push(abstractType1);\r\n            break;\r\n        case Opcodes.DUP2_X2:\r\n            abstractType1 = pop();\r\n            abstractType2 = pop();\r\n            abstractType3 = pop();\r\n            abstractType4 = pop();\r\n            push(abstractType2);\r\n            push(abstractType1);\r\n            push(abstractType4);\r\n            push(abstractType3);\r\n            push(abstractType2);\r\n            push(abstractType1);\r\n            break;\r\n        case Opcodes.SWAP:\r\n            abstractType1 = pop();\r\n            abstractType2 = pop();\r\n            push(abstractType1);\r\n            push(abstractType2);\r\n            break;\r\n        case Opcodes.IALOAD:\r\n        case Opcodes.BALOAD:\r\n        case Opcodes.CALOAD:\r\n        case Opcodes.SALOAD:\r\n        case Opcodes.IADD:\r\n        case Opcodes.ISUB:\r\n        case Opcodes.IMUL:\r\n        case Opcodes.IDIV:\r\n        case Opcodes.IREM:\r\n        case Opcodes.IAND:\r\n        case Opcodes.IOR:\r\n        case Opcodes.IXOR:\r\n        case Opcodes.ISHL:\r\n        case Opcodes.ISHR:\r\n        case Opcodes.IUSHR:\r\n        case Opcodes.L2I:\r\n        case Opcodes.D2I:\r\n        case Opcodes.FCMPL:\r\n        case Opcodes.FCMPG:\r\n            pop(2);\r\n            push(INTEGER);\r\n            break;\r\n        case Opcodes.LADD:\r\n        case Opcodes.LSUB:\r\n        case Opcodes.LMUL:\r\n        case Opcodes.LDIV:\r\n        case Opcodes.LREM:\r\n        case Opcodes.LAND:\r\n        case Opcodes.LOR:\r\n        case Opcodes.LXOR:\r\n            pop(4);\r\n            push(LONG);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.FALOAD:\r\n        case Opcodes.FADD:\r\n        case Opcodes.FSUB:\r\n        case Opcodes.FMUL:\r\n        case Opcodes.FDIV:\r\n        case Opcodes.FREM:\r\n        case Opcodes.L2F:\r\n        case Opcodes.D2F:\r\n            pop(2);\r\n            push(FLOAT);\r\n            break;\r\n        case Opcodes.DADD:\r\n        case Opcodes.DSUB:\r\n        case Opcodes.DMUL:\r\n        case Opcodes.DDIV:\r\n        case Opcodes.DREM:\r\n            pop(4);\r\n            push(DOUBLE);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.LSHL:\r\n        case Opcodes.LSHR:\r\n        case Opcodes.LUSHR:\r\n            pop(3);\r\n            push(LONG);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.IINC:\r\n            setLocal(arg, INTEGER);\r\n            break;\r\n        case Opcodes.I2L:\r\n        case Opcodes.F2L:\r\n            pop(1);\r\n            push(LONG);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.I2F:\r\n            pop(1);\r\n            push(FLOAT);\r\n            break;\r\n        case Opcodes.I2D:\r\n        case Opcodes.F2D:\r\n            pop(1);\r\n            push(DOUBLE);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.F2I:\r\n        case Opcodes.ARRAYLENGTH:\r\n        case Opcodes.INSTANCEOF:\r\n            pop(1);\r\n            push(INTEGER);\r\n            break;\r\n        case Opcodes.LCMP:\r\n        case Opcodes.DCMPL:\r\n        case Opcodes.DCMPG:\r\n            pop(4);\r\n            push(INTEGER);\r\n            break;\r\n        case Opcodes.JSR:\r\n        case Opcodes.RET:\r\n            throw new IllegalArgumentException(\"JSR/RET are not supported with computeFrames option\");\r\n        case Opcodes.GETSTATIC:\r\n            push(symbolTable, argSymbol.value);\r\n            break;\r\n        case Opcodes.PUTSTATIC:\r\n            pop(argSymbol.value);\r\n            break;\r\n        case Opcodes.GETFIELD:\r\n            pop(1);\r\n            push(symbolTable, argSymbol.value);\r\n            break;\r\n        case Opcodes.PUTFIELD:\r\n            pop(argSymbol.value);\r\n            pop();\r\n            break;\r\n        case Opcodes.INVOKEVIRTUAL:\r\n        case Opcodes.INVOKESPECIAL:\r\n        case Opcodes.INVOKESTATIC:\r\n        case Opcodes.INVOKEINTERFACE:\r\n            pop(argSymbol.value);\r\n            if (opcode != Opcodes.INVOKESTATIC) {\r\n                abstractType1 = pop();\r\n                if (opcode == Opcodes.INVOKESPECIAL && argSymbol.name.charAt(0) == '<') {\r\n                    addInitializedType(abstractType1);\r\n                }\r\n            }\r\n            push(symbolTable, argSymbol.value);\r\n            break;\r\n        case Opcodes.INVOKEDYNAMIC:\r\n            pop(argSymbol.value);\r\n            push(symbolTable, argSymbol.value);\r\n            break;\r\n        case Opcodes.NEW:\r\n            push(UNINITIALIZED_KIND | symbolTable.addUninitializedType(argSymbol.value, arg));\r\n            break;\r\n        case Opcodes.NEWARRAY:\r\n            pop();\r\n            switch(arg) {\r\n                case Opcodes.T_BOOLEAN:\r\n                    push(ARRAY_OF | BOOLEAN);\r\n                    break;\r\n                case Opcodes.T_CHAR:\r\n                    push(ARRAY_OF | CHAR);\r\n                    break;\r\n                case Opcodes.T_BYTE:\r\n                    push(ARRAY_OF | BYTE);\r\n                    break;\r\n                case Opcodes.T_SHORT:\r\n                    push(ARRAY_OF | SHORT);\r\n                    break;\r\n                case Opcodes.T_INT:\r\n                    push(ARRAY_OF | INTEGER);\r\n                    break;\r\n                case Opcodes.T_FLOAT:\r\n                    push(ARRAY_OF | FLOAT);\r\n                    break;\r\n                case Opcodes.T_DOUBLE:\r\n                    push(ARRAY_OF | DOUBLE);\r\n                    break;\r\n                case Opcodes.T_LONG:\r\n                    push(ARRAY_OF | LONG);\r\n                    break;\r\n                default:\r\n                    throw new IllegalArgumentException();\r\n            }\r\n            break;\r\n        case Opcodes.ANEWARRAY:\r\n            String arrayElementType = argSymbol.value;\r\n            pop();\r\n            if (arrayElementType.charAt(0) == '[') {\r\n                push(symbolTable, '[' + arrayElementType);\r\n            } else {\r\n                push(ARRAY_OF | REFERENCE_KIND | symbolTable.addType(arrayElementType));\r\n            }\r\n            break;\r\n        case Opcodes.CHECKCAST:\r\n            String castType = argSymbol.value;\r\n            pop();\r\n            if (castType.charAt(0) == '[') {\r\n                push(symbolTable, castType);\r\n            } else {\r\n                push(REFERENCE_KIND | symbolTable.addType(castType));\r\n            }\r\n            break;\r\n        case Opcodes.MULTIANEWARRAY:\r\n            pop(arg);\r\n            push(symbolTable, argSymbol.value);\r\n            break;\r\n        default:\r\n            throw new IllegalArgumentException();\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.PeriodType.withMillisRemoved",
	"Comment": "returns a version of this periodtype instance that does not support milliseconds.",
	"Method": "PeriodType withMillisRemoved(){\r\n    return withFieldRemoved(7, \"NoMillis\");\r\n}"
}, {
	"Path": "jodd.http.HttpRequest.connectionTimeout",
	"Comment": "returns socket connection timeout. negative value means that default\tvalue is used.",
	"Method": "HttpRequest connectionTimeout(int milliseconds,int connectionTimeout){\r\n    return connectTimeout;\r\n}"
}, {
	"Path": "jodd.lagarto.dom.Node.changeOwnerDocument",
	"Comment": "changes owner document for given node and all its children.",
	"Method": "void changeOwnerDocument(Node node,Document ownerDocument){\r\n    node.ownerDocument = ownerDocument;\r\n    int childCount = node.getChildNodesCount();\r\n    for (int i = 0; i < childCount; i++) {\r\n        Node child = node.getChild(i);\r\n        changeOwnerDocument(child, ownerDocument);\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.LocalTime.withHourOfDay",
	"Comment": "returns a copy of this time with the hour of day field updated.localtime is immutable, so there are no set methods.instead, this method returns a new instance with the value ofhour of day changed.",
	"Method": "LocalTime withHourOfDay(int hour){\r\n    return withLocalMillis(getChronology().hourOfDay().set(getLocalMillis(), hour));\r\n}"
}, {
	"Path": "org.jooq.XMLFormat.indentString",
	"Comment": "convenience method to get an indentation string at a given level.",
	"Method": "String indentString(int level){\r\n    if (level < indented.length)\r\n        return indented[level];\r\n    else if (format)\r\n        return rightPad(\"\", indent * level);\r\n    else\r\n        return \"\";\r\n}"
}, {
	"Path": "org.joda.time.Seconds.isGreaterThan",
	"Comment": "is this seconds instance greater than the specified number of seconds.",
	"Method": "boolean isGreaterThan(Seconds other){\r\n    if (other == null) {\r\n        return getValue() > 0;\r\n    }\r\n    return getValue() > other.getValue();\r\n}"
}, {
	"Path": "jodd.util.collection.IntHashMap.containsValue",
	"Comment": "returns true if this map maps one or more keys to the\tspecified value.",
	"Method": "boolean containsValue(Object value){\r\n    Entry[] tab = table;\r\n    if (value == null) {\r\n        for (int i = tab.length; i-- > 0; ) {\r\n            for (Entry e = tab[i]; e != null; e = e.next) {\r\n                if (e.value == null) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        for (int i = tab.length; i-- > 0; ) {\r\n            for (Entry e = tab[i]; e != null; e = e.next) {\r\n                if (value.equals(e.value)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "jodd.util.BinarySearch.find",
	"Comment": "finds index of given element in inclusive index range. returns negative\tvalue if element is not found.",
	"Method": "int find(E element,int find,E element,int low,int high){\r\n    while (low <= high) {\r\n        int mid = (low + high) >>> 1;\r\n        int delta = compare(mid, element);\r\n        if (delta < 0) {\r\n            low = mid + 1;\r\n        } else if (delta > 0) {\r\n            high = mid - 1;\r\n        } else {\r\n            return mid;\r\n        }\r\n    }\r\n    return -(low + 1);\r\n}"
}, {
	"Path": "jodd.io.watch.DirWatcher.init",
	"Comment": "initializes dir watcher by reading all files\tfrom watched folder.",
	"Method": "void init(){\r\n    File[] filesArray = dir.listFiles();\r\n    filesCount = 0;\r\n    if (filesArray != null) {\r\n        filesCount = filesArray.length;\r\n        for (File file : filesArray) {\r\n            if (!acceptFile(file)) {\r\n                continue;\r\n            }\r\n            map.put(file, new MutableLong(file.lastModified()));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jodd.madvoc.result.AbstractTemplateViewActionResult.render",
	"Comment": "dispatches to the template location created from result value and jsp extension.\tdoes its forward via a requestdispatcher. if the dispatch fails, a 404 error\twill be sent back in the http response.",
	"Method": "void render(ActionRequest actionRequest,Object resultValue){\r\n    final PathResult pathResult;\r\n    if (resultValue == null) {\r\n        pathResult = resultOf(StringPool.EMPTY);\r\n    } else {\r\n        if (resultValue instanceof String) {\r\n            pathResult = resultOf(resultValue);\r\n        } else {\r\n            pathResult = (PathResult) resultValue;\r\n        }\r\n    }\r\n    final String resultBasePath = actionRequest.getActionRuntime().getResultBasePath();\r\n    final String path = pathResult != null ? pathResult.path() : StringPool.EMPTY;\r\n    final String actionAndResultPath = resultBasePath + (pathResult != null ? ':' + path : StringPool.EMPTY);\r\n    String target = targetCache.get(actionAndResultPath);\r\n    if (target == null) {\r\n        if (log.isDebugEnabled()) {\r\n            log.debug(\"new target: \" + actionAndResultPath);\r\n        }\r\n        target = resolveTarget(actionRequest, path);\r\n        if (target == null) {\r\n            targetNotFound(actionRequest, actionAndResultPath);\r\n            return;\r\n        }\r\n        if (log.isDebugEnabled()) {\r\n            log.debug(\"target found: \" + target);\r\n        }\r\n        targetCache.put(actionAndResultPath, target);\r\n    }\r\n    renderView(actionRequest, target);\r\n}"
}, {
	"Path": "jodd.util.ArraysUtil.indexOf",
	"Comment": "finds the first occurrence in an array from specified given position and upto given length.",
	"Method": "int indexOf(byte[] array,byte value,int indexOf,byte[] array,byte value,int startIndex,int indexOf,byte[] array,byte value,int startIndex,int endIndex,int indexOf,char[] array,char value,int indexOf,char[] array,char value,int startIndex,int indexOf,char[] array,char value,int startIndex,int endIndex,int indexOf,short[] array,short value,int indexOf,short[] array,short value,int startIndex,int indexOf,short[] array,short value,int startIndex,int endIndex,int indexOf,int[] array,int value,int indexOf,int[] array,int value,int startIndex,int indexOf,int[] array,int value,int startIndex,int endIndex,int indexOf,long[] array,long value,int indexOf,long[] array,long value,int startIndex,int indexOf,long[] array,long value,int startIndex,int endIndex,int indexOf,boolean[] array,boolean value,int indexOf,boolean[] array,boolean value,int startIndex,int indexOf,boolean[] array,boolean value,int startIndex,int endIndex,int indexOf,float[] array,float value,int indexOf,float[] array,float value,int startIndex,int indexOf,float[] array,float value,int startIndex,int endIndex,int indexOf,double[] array,double value,int indexOf,double[] array,double value,int startIndex,int indexOf,double[] array,double value,int startIndex,int endIndex,int indexOf,Object[] array,Object value,int indexOf,Object[] array,Object value,int startIndex,int indexOf,byte[] array,byte[] sub,int indexOf,byte[] array,byte[] sub,int startIndex,int indexOf,byte[] array,byte[] sub,int startIndex,int endIndex,int indexOf,char[] array,char[] sub,int indexOf,char[] array,char[] sub,int startIndex,int indexOf,char[] array,char[] sub,int startIndex,int endIndex,int indexOf,short[] array,short[] sub,int indexOf,short[] array,short[] sub,int startIndex,int indexOf,short[] array,short[] sub,int startIndex,int endIndex,int indexOf,int[] array,int[] sub,int indexOf,int[] array,int[] sub,int startIndex,int indexOf,int[] array,int[] sub,int startIndex,int endIndex,int indexOf,long[] array,long[] sub,int indexOf,long[] array,long[] sub,int startIndex,int indexOf,long[] array,long[] sub,int startIndex,int endIndex,int indexOf,boolean[] array,boolean[] sub,int indexOf,boolean[] array,boolean[] sub,int startIndex,int indexOf,boolean[] array,boolean[] sub,int startIndex,int endIndex,int indexOf,float[] array,float[] sub,int indexOf,float[] array,float[] sub,int startIndex,int indexOf,float[] array,float[] sub,int startIndex,int endIndex,int indexOf,double[] array,double[] sub,int indexOf,double[] array,double[] sub,int startIndex,int indexOf,double[] array,double[] sub,int startIndex,int endIndex){\r\n    int sublen = sub.length;\r\n    if (sublen == 0) {\r\n        return startIndex;\r\n    }\r\n    int total = endIndex - sublen + 1;\r\n    double c = sub[0];\r\n    mainloop: for (int i = startIndex; i < total; i++) {\r\n        if (Double.compare(array[i], c) != 0) {\r\n            continue;\r\n        }\r\n        int j = 1;\r\n        int k = i + 1;\r\n        while (j < sublen) {\r\n            if (Double.compare(sub[j], array[k]) != 0) {\r\n                continue mainloop;\r\n            }\r\n            j++;\r\n            k++;\r\n        }\r\n        return i;\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "org.joda.time.field.LenientDateTimeField.set",
	"Comment": "set values which may be out of bounds by adding the difference betweenthe new value and the current value.",
	"Method": "long set(long instant,int value){\r\n    long localInstant = iBase.getZone().convertUTCToLocal(instant);\r\n    long difference = FieldUtils.safeSubtract(value, get(instant));\r\n    localInstant = getType().getField(iBase.withUTC()).add(localInstant, difference);\r\n    return iBase.getZone().convertLocalToUTC(localInstant, false, instant);\r\n}"
}, {
	"Path": "jodd.asm7.MethodVisitor.visitLabel",
	"Comment": "visits a label. a label designates the instruction that will be visited just after it.",
	"Method": "void visitLabel(Label label){\r\n    if (mv != null) {\r\n        mv.visitLabel(label);\r\n    }\r\n}"
}, {
	"Path": "org.json.JSONObject.optJSONArray",
	"Comment": "get an optional jsonarray associated with a key. it returns null if thereis no such key, or if its value is not a jsonarray.",
	"Method": "JSONArray optJSONArray(String key){\r\n    Object o = this.opt(key);\r\n    return o instanceof JSONArray ? (JSONArray) o : null;\r\n}"
}, {
	"Path": "org.joda.time.DateMidnight.withZoneRetainFields",
	"Comment": "returns a copy of this date with a different time zone, preserving the daythe returned object will have a local time of midnight in the new zone onthe same day as the original instant.",
	"Method": "DateMidnight withZoneRetainFields(DateTimeZone newZone){\r\n    newZone = DateTimeUtils.getZone(newZone);\r\n    DateTimeZone originalZone = DateTimeUtils.getZone(getZone());\r\n    if (newZone == originalZone) {\r\n        return this;\r\n    }\r\n    long millis = originalZone.getMillisKeepLocal(newZone, getMillis());\r\n    return new DateMidnight(millis, getChronology().withZone(newZone));\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.withLocalMillis",
	"Comment": "returns a copy of this datetime with different local millis.the returned object will be a new instance of the same type.only the millis will change, the chronology is kept.the returned object will be either be a new instance or this.",
	"Method": "LocalDateTime withLocalMillis(long newMillis){\r\n    return (newMillis == getLocalMillis() ? this : new LocalDateTime(newMillis, getChronology()));\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Generate.isCommentsOnKeys",
	"Comment": "turn off generation of all sql comments as javadoc on all keys.",
	"Method": "Boolean isCommentsOnKeys(){\r\n    return commentsOnKeys;\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Target.isClean",
	"Comment": "whether the target package should be cleaned to contain only generated code after a generation run.",
	"Method": "Boolean isClean(){\r\n    return clean;\r\n}"
}, {
	"Path": "org.jooq.conf.Settings.getMaxRows",
	"Comment": "the default jdbc maxrows property that should be applied to alljooq queries, for which no specific maxrows value was specified.",
	"Method": "Integer getMaxRows(){\r\n    return maxRows;\r\n}"
}, {
	"Path": "jodd.jerry.Jerry.lt",
	"Comment": "reduces the set of matched elements to the one at an index less\tthan specified index.",
	"Method": "Jerry lt(int value){\r\n    List<Node> result = new NodeList(nodes.length);\r\n    if (nodes.length > 0) {\r\n        int index = 0;\r\n        for (Node node : nodes) {\r\n            if (index < value) {\r\n                result.add(node);\r\n            }\r\n            index++;\r\n        }\r\n    }\r\n    return new Jerry(this, result);\r\n}"
}, {
	"Path": "jodd.madvoc.MadvocResponseWrapper.setContentType",
	"Comment": "sets content type. if charset is missing, current value is reset.\tif passed value is null, content type will be reset\tas never set.",
	"Method": "void setContentType(String type){\r\n    if (type == null) {\r\n        mimeType = null;\r\n        characterEncoding = null;\r\n        return;\r\n    }\r\n    ContentTypeHeaderResolver contentTypeResolver = new ContentTypeHeaderResolver(type);\r\n    mimeType = contentTypeResolver.getMimeType();\r\n    characterEncoding = contentTypeResolver.getEncoding();\r\n}"
}, {
	"Path": "jodd.servlet.SessionMonitor.getSession",
	"Comment": "returns session for given session id. returns null\tif session expired.",
	"Method": "HttpSession getSession(String sessionId){\r\n    return sessionMap.get(sessionId);\r\n}"
}, {
	"Path": "com.jayway.jsonpath.JsonPath.put",
	"Comment": "adds or updates the object this path points to in the provided jsonobject with a key with a value",
	"Method": "T put(Object jsonObject,String key,Object value,Configuration configuration){\r\n    notNull(jsonObject, \"json can not be null\");\r\n    notEmpty(key, \"key can not be null or empty\");\r\n    notNull(configuration, \"configuration can not be null\");\r\n    EvaluationContext evaluationContext = path.evaluate(jsonObject, jsonObject, configuration, true);\r\n    for (PathRef updateOperation : evaluationContext.updateOperations()) {\r\n        updateOperation.put(key, value, configuration);\r\n    }\r\n    return resultByConfiguration(jsonObject, configuration, evaluationContext);\r\n}"
}, {
	"Path": "jodd.util.collection.SortedArrayList.compare",
	"Comment": "compares two keys using the correct comparison method for this\tcollection.",
	"Method": "int compare(E k1,E k2){\r\n    if (comparator == null) {\r\n        return ((Comparable) k1).compareTo(k2);\r\n    }\r\n    return comparator.compare(k1, k2);\r\n}"
}, {
	"Path": "jodd.joy.auth.UserSession.stop",
	"Comment": "stops the user session by removing it from the http session and invalidating the cookie.",
	"Method": "void stop(HttpServletRequest servletRequest,HttpServletResponse servletResponse){\r\n    final HttpSession httpSession = servletRequest.getSession(false);\r\n    if (httpSession != null) {\r\n        httpSession.removeAttribute(AUTH_SESSION_NAME);\r\n    }\r\n    final Cookie cookie = ServletUtil.getCookie(servletRequest, AUTH_COOKIE_NAME);\r\n    if (cookie == null) {\r\n        return;\r\n    }\r\n    cookie.setMaxAge(0);\r\n    cookie.setPath(\"/\");\r\n    servletResponse.addCookie(cookie);\r\n}"
}, {
	"Path": "org.joda.time.Minutes.minus",
	"Comment": "returns a new instance with the specified number of minutes taken away.this instance is immutable and unaffected by this method call.",
	"Method": "Minutes minus(int minutes,Minutes minus,Minutes minutes){\r\n    if (minutes == null) {\r\n        return this;\r\n    }\r\n    return minus(minutes.getValue());\r\n}"
}, {
	"Path": "jodd.time.JulianDate.daysBetween",
	"Comment": "calculates the number of days between two dates. returned value is always positive.",
	"Method": "int daysBetween(JulianDate otherDate){\r\n    int difference = daysSpan(otherDate);\r\n    return difference >= 0 ? difference : -difference;\r\n}"
}, {
	"Path": "jodd.asm7.ClassReader.readLabel",
	"Comment": "returns the label corresponding to the given bytecode offset. the default implementation ofthis method creates a label for the given offset if it has not been already created.",
	"Method": "Label readLabel(int bytecodeOffset,Label[] labels){\r\n    if (labels[bytecodeOffset] == null) {\r\n        labels[bytecodeOffset] = new Label();\r\n    }\r\n    return labels[bytecodeOffset];\r\n}"
}, {
	"Path": "org.joda.time.Hours.toStandardDuration",
	"Comment": "converts this period in hours to a duration in milliseconds assuming a60 minute hour and 60 second minute.this method allows you to convert from a period to a duration.however to achieve this it makes the assumption that all hours are60 minutes and all minutes are 60 seconds. this might not be true for anunusual chronology, for example one that takes leap seconds into account.however, the method is included as it is a useful operation for manyapplications and business rules.",
	"Method": "Duration toStandardDuration(){\r\n    long hours = getValue();\r\n    return new Duration(hours * DateTimeConstants.MILLIS_PER_HOUR);\r\n}"
}, {
	"Path": "org.joda.time.YearMonthDay.fromCalendarFields",
	"Comment": "constructs a yearmonthday from a java.util.calendarusing exactly the same field values avoiding any time zone effects.each field is queried from the calendar and assigned to the yearmonthday.this is useful if you have been using the calendar as a local date,ignoring the zone.this factory method ignores the type of the calendar and alwayscreates a yearmonthday with iso chronology. it is expected that youwill only pass in instances of gregoriancalendar howeverthis is not validated.",
	"Method": "YearMonthDay fromCalendarFields(Calendar calendar){\r\n    if (calendar == null) {\r\n        throw new IllegalArgumentException(\"The calendar must not be null\");\r\n    }\r\n    return new YearMonthDay(calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH));\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Generate.isPrimaryKeyTypes",
	"Comment": "whether wrapper types should be generated for primary key columns, and for their referencing foreign keys.",
	"Method": "Boolean isPrimaryKeyTypes(){\r\n    return primaryKeyTypes;\r\n}"
}, {
	"Path": "org.joda.time.PeriodType.withDaysRemoved",
	"Comment": "returns a version of this periodtype instance that does not support days.",
	"Method": "PeriodType withDaysRemoved(){\r\n    return withFieldRemoved(3, \"NoDays\");\r\n}"
}, {
	"Path": "org.joda.time.chrono.LimitChronology.getInstance",
	"Comment": "wraps another chronology, with datetime limits. when withutc orwithzone is called, the returned limitchronology instance hasthe same limits, except they are time zone adjusted.",
	"Method": "LimitChronology getInstance(Chronology base,ReadableDateTime lowerLimit,ReadableDateTime upperLimit){\r\n    if (base == null) {\r\n        throw new IllegalArgumentException(\"Must supply a chronology\");\r\n    }\r\n    lowerLimit = lowerLimit == null ? null : lowerLimit.toDateTime();\r\n    upperLimit = upperLimit == null ? null : upperLimit.toDateTime();\r\n    if (lowerLimit != null && upperLimit != null && !lowerLimit.isBefore(upperLimit)) {\r\n        throw new IllegalArgumentException(\"The lower limit must be come before than the upper limit\");\r\n    }\r\n    return new LimitChronology(base, (DateTime) lowerLimit, (DateTime) upperLimit);\r\n}"
}, {
	"Path": "org.joda.time.LocalDate.withLocalMillis",
	"Comment": "returns a copy of this date with different local millis.the returned object will be a new instance of the same type.only the millis will change, the chronology is kept.the returned object will be either be a new instance or this.",
	"Method": "LocalDate withLocalMillis(long newMillis){\r\n    newMillis = iChronology.dayOfMonth().roundFloor(newMillis);\r\n    return (newMillis == getLocalMillis() ? this : new LocalDate(newMillis, getChronology()));\r\n}"
}, {
	"Path": "jodd.servlet.CsrfShield.prepareCsrfToken",
	"Comment": "generates new csrf token and puts it in the session. returns generated token value.",
	"Method": "String prepareCsrfToken(PageContext pageContext,String prepareCsrfToken,HttpSession session,String prepareCsrfToken,HttpSession session,int timeToLive){\r\n    Set<Token> tokenSet = (Set<Token>) session.getAttribute(CSRF_TOKEN_SET);\r\n    if (tokenSet == null) {\r\n        tokenSet = new HashSet();\r\n        session.setAttribute(CSRF_TOKEN_SET, tokenSet);\r\n    }\r\n    String value;\r\n    boolean unique;\r\n    do {\r\n        value = RandomString.get().randomAlphaNumeric(32);\r\n        assureSize(tokenSet);\r\n        unique = tokenSet.add(new Token(value, timeToLive));\r\n    } while (!unique);\r\n    return value;\r\n}"
}, {
	"Path": "org.joda.time.Seconds.toStandardWeeks",
	"Comment": "converts this period in seconds to a period in weeks assuming a7 day week, 24 hour day, 60 minute hour and 60 second minute.this method allows you to convert between different types of period.however to achieve this it makes the assumption that all weeks are 7 dayslong, all days are 24 hours long, all hours are 60 minutes long andall minutes are 60 seconds long.this is not true when daylight savings time is considered, and may alsonot be true for some unusual chronologies. however, it is included as itis a useful operation for many applications and business rules.",
	"Method": "Weeks toStandardWeeks(){\r\n    return Weeks.weeks(getValue() / DateTimeConstants.SECONDS_PER_WEEK);\r\n}"
}, {
	"Path": "org.joda.time.Weeks.toStandardDuration",
	"Comment": "converts this period in weeks to a duration in milliweeks assuming a7 day week, 24 hour day, 60 minute hour and 60 second minute.this method allows you to convert from a period to a duration.however to achieve this it makes the assumption that all weeks are7 days long, all days are 24 hours long, all hours are 60 minutes longand all minutes are 60 seconds long.this is not true when daylight savings time is considered, and may alsonot be true for some unusual chronologies. however, it is included as itis a useful operation for many applications and business rules.",
	"Method": "Duration toStandardDuration(){\r\n    long weeks = getValue();\r\n    return new Duration(weeks * DateTimeConstants.MILLIS_PER_WEEK);\r\n}"
}, {
	"Path": "jodd.http.Cookie.setSecure",
	"Comment": "indicates to the browser whether the cookie should only be sent\tusing a secure protocol, such as https or ssl.",
	"Method": "Cookie setSecure(boolean flag){\r\n    secure = flag;\r\n    return this;\r\n}"
}, {
	"Path": "org.joda.time.field.FieldUtils.safeMultiply",
	"Comment": "multiply two values throwing an exception if overflow occurs.",
	"Method": "int safeMultiply(int val1,int val2,long safeMultiply,long val1,int val2,long safeMultiply,long val1,long val2){\r\n    if (val2 == 1) {\r\n        return val1;\r\n    }\r\n    if (val1 == 1) {\r\n        return val2;\r\n    }\r\n    if (val1 == 0 || val2 == 0) {\r\n        return 0;\r\n    }\r\n    long total = val1 * val2;\r\n    if (total / val2 != val1 || val1 == Long.MIN_VALUE && val2 == -1 || val2 == Long.MIN_VALUE && val1 == -1) {\r\n        throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\r\n    }\r\n    return total;\r\n}"
}, {
	"Path": "jodd.util.BinarySearch.forList",
	"Comment": "creates binary search wrapper over a list with given comparator.",
	"Method": "BinarySearch<T> forList(List<T> list,BinarySearch<T> forList,List<T> list,Comparator<T> comparator){\r\n    return new BinarySearch<T>() {\r\n        @Override\r\n        @SuppressWarnings({ \"unchecked\" })\r\n        protected int compare(final int index, final T element) {\r\n            return comparator.compare(list.get(index), element);\r\n        }\r\n        @Override\r\n        protected int getLastIndex() {\r\n            return list.size() - 1;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "jodd.util.BinarySearch.forList",
	"Comment": "creates binary search wrapper over a list with given comparator.",
	"Method": "BinarySearch<T> forList(List<T> list,BinarySearch<T> forList,List<T> list,Comparator<T> comparator){\r\n    return comparator.compare(list.get(index), element);\r\n}"
}, {
	"Path": "jodd.util.BinarySearch.forList",
	"Comment": "creates binary search wrapper over a list with given comparator.",
	"Method": "BinarySearch<T> forList(List<T> list,BinarySearch<T> forList,List<T> list,Comparator<T> comparator){\r\n    return list.size() - 1;\r\n}"
}, {
	"Path": "org.joda.time.DateTimeZone.forOffsetHours",
	"Comment": "gets a time zone instance for the specified offset to utc in hours.this method assumes standard length hours.this factory is a convenient way of constructing zones with a fixed offset.",
	"Method": "DateTimeZone forOffsetHours(int hoursOffset){\r\n    return forOffsetHoursMinutes(hoursOffset, 0);\r\n}"
}, {
	"Path": "jodd.csselly.CSSelly.parse",
	"Comment": "parses selector string.\treturns null if no selector can be parsed.",
	"Method": "List<CssSelector> parse(List<List<CssSelector>> parse,String query){\r\n    String[] singleQueries = StringUtil.splitc(query, ',');\r\n    List<List<CssSelector>> selectors = new ArrayList(singleQueries.length);\r\n    for (String singleQuery : singleQueries) {\r\n        selectors.add(new CSSelly(singleQuery).parse());\r\n    }\r\n    return selectors;\r\n}"
}, {
	"Path": "jodd.madvoc.component.WrapperManager.resolve",
	"Comment": "resolves single wrapper. creates new wrapper instance if not already registered.\tdoes not expand the wrappers.",
	"Method": "T resolve(Class<? extends T> wrapperClass){\r\n    String wrapperClassName = wrapperClass.getName();\r\n    T wrapper = lookup(wrapperClassName);\r\n    if (wrapper == null) {\r\n        wrapper = createWrapper(wrapperClass);\r\n        initializeWrapper(wrapper);\r\n        wrappers.put(wrapperClassName, wrapper);\r\n    }\r\n    return wrapper;\r\n}"
}, {
	"Path": "jodd.petite.resolver.CtorResolver.resolve",
	"Comment": "resolves constructor injection point from type. looks for single annotated constructor.\tif no annotated constructors found, the total number of constructors will be checked.\tif there is only one constructor, that one will be used as injection point. if more\tconstructors exist, the default one will be used as injection point. otherwise, exception\tis thrown.",
	"Method": "CtorInjectionPoint resolve(Class type,boolean useAnnotation){\r\n    ClassDescriptor cd = ClassIntrospector.get().lookup(type);\r\n    CtorDescriptor[] allCtors = cd.getAllCtorDescriptors();\r\n    Constructor foundedCtor = null;\r\n    Constructor defaultCtor = null;\r\n    BeanReferences[] references = null;\r\n    for (CtorDescriptor ctorDescriptor : allCtors) {\r\n        Constructor<?> ctor = ctorDescriptor.getConstructor();\r\n        Class<?>[] paramTypes = ctor.getParameterTypes();\r\n        if (paramTypes.length == 0) {\r\n            defaultCtor = ctor;\r\n        }\r\n        if (!useAnnotation) {\r\n            continue;\r\n        }\r\n        BeanReferences[] ctorReferences = referencesResolver.readAllReferencesFromAnnotation(ctor);\r\n        if (ctorReferences == null) {\r\n            continue;\r\n        }\r\n        if (foundedCtor != null) {\r\n            throw new PetiteException(\"Two or more constructors are annotated as injection points in the bean: \" + type.getName());\r\n        }\r\n        foundedCtor = ctor;\r\n        references = ctorReferences;\r\n    }\r\n    if (foundedCtor == null) {\r\n        if (allCtors.length == 1) {\r\n            foundedCtor = allCtors[0].getConstructor();\r\n        } else {\r\n            foundedCtor = defaultCtor;\r\n        }\r\n        if (foundedCtor == null) {\r\n            return CtorInjectionPoint.EMPTY;\r\n        }\r\n        references = referencesResolver.readAllReferencesFromAnnotation(foundedCtor);\r\n        if (references == null) {\r\n            references = new BeanReferences[0];\r\n        }\r\n    }\r\n    return new CtorInjectionPoint(foundedCtor, references);\r\n}"
}, {
	"Path": "com.jayway.jsonpath.TestUtils.assertHasOneResult",
	"Comment": "assertion which requires list of one element as a result of indefinite path search.",
	"Method": "void assertHasOneResult(String json,String path,Configuration conf){\r\n    assertHasResults(json, path, 1, conf);\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.MatchersTableType.getPojoClass",
	"Comment": "this rule influences the naming of the generated pojos object.",
	"Method": "MatcherRule getPojoClass(){\r\n    return pojoClass;\r\n}"
}, {
	"Path": "jodd.lagarto.dom.NodeSelector.walkDescendantsIteratively",
	"Comment": "walks over the child notes, maintaining the tree order and not using recursion.",
	"Method": "void walkDescendantsIteratively(LinkedList<Node> nodes,CssSelector cssSelector,List<Node> result){\r\n    while (!nodes.isEmpty()) {\r\n        Node node = nodes.removeFirst();\r\n        selectAndAdd(node, cssSelector, result);\r\n        int childCount = node.getChildNodesCount();\r\n        for (int i = childCount - 1; i >= 0; i--) {\r\n            nodes.addFirst(node.getChild(i));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jsonschema2pojo.SchemaMapper.generate",
	"Comment": "reads a schema and adds generated types to the given code model.",
	"Method": "JType generate(JCodeModel codeModel,String className,String packageName,URL schemaUrl,JType generate,JCodeModel codeModel,String className,String packageName,String json,URI schemaLocation,JType generate,JCodeModel codeModel,String className,String packageName,String json){\r\n    JPackage jpackage = codeModel._package(packageName);\r\n    JsonNode schemaNode = null;\r\n    if (ruleFactory.getGenerationConfig().getSourceType() == SourceType.JSON) {\r\n        JsonNode jsonNode = objectMapper().readTree(json);\r\n        schemaNode = schemaGenerator.schemaFromExample(jsonNode);\r\n    } else {\r\n        schemaNode = objectMapper().readTree(json);\r\n    }\r\n    return ruleFactory.getSchemaRule().apply(className, schemaNode, null, jpackage, new Schema(null, schemaNode, null));\r\n}"
}, {
	"Path": "org.joda.time.DateMidnight.withDayOfWeek",
	"Comment": "returns a copy of this date with the day of week field updated.datemidnight is immutable, so there are no set methods.instead, this method returns a new instance with the value ofday of week changed.",
	"Method": "DateMidnight withDayOfWeek(int dayOfWeek){\r\n    return withMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek));\r\n}"
}, {
	"Path": "jodd.db.DbQueryBase.closeAllResultSets",
	"Comment": "closes all result sets created by this query. query remains active.",
	"Method": "Q closeAllResultSets(){\r\n    final SQLException sex = closeQueryResultSets();\r\n    if (sex != null) {\r\n        throw new DbSqlException(\"Close associated ResultSets error\", sex);\r\n    }\r\n    return _this();\r\n}"
}, {
	"Path": "jodd.jerry.Jerry.after",
	"Comment": "inserts content, specified by the parameter, after each\telement in the set of matched elements.",
	"Method": "Jerry after(String html){\r\n    if (html == null) {\r\n        html = StringPool.EMPTY;\r\n    }\r\n    final Document doc = builder.parse(html);\r\n    if (nodes.length == 0) {\r\n        return this;\r\n    }\r\n    for (Node node : nodes) {\r\n        Document workingDoc = doc.clone();\r\n        node.insertAfter(workingDoc.getChildNodes(), node);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Generate.isCommentsOnAttributes",
	"Comment": "turn off generation of all sql comments as javadoc on all attributes.",
	"Method": "Boolean isCommentsOnAttributes(){\r\n    return commentsOnAttributes;\r\n}"
}, {
	"Path": "jodd.petite.ScopedProxyManager.lookupValue",
	"Comment": "returns scoped proxy bean if injection scopes are mixed on some injection point.\tmay return null if mixing scopes is not detected.",
	"Method": "Object lookupValue(PetiteContainer petiteContainer,BeanDefinition targetBeanDefinition,BeanDefinition refBeanDefinition){\r\n    Scope targetScope = targetBeanDefinition.scope;\r\n    Scope refBeanScope = refBeanDefinition.scope;\r\n    boolean detectMixedScopes = petiteContainer.config().isDetectMixedScopes();\r\n    boolean wireScopedProxy = petiteContainer.config().isWireScopedProxy();\r\n    if (targetScope != null && !targetScope.accept(refBeanScope)) {\r\n        if (!wireScopedProxy) {\r\n            if (detectMixedScopes) {\r\n                throw new PetiteException(createMixingMessage(targetBeanDefinition, refBeanDefinition));\r\n            }\r\n            return null;\r\n        }\r\n        if (detectMixedScopes) {\r\n            if (log.isWarnEnabled()) {\r\n                log.warn(createMixingMessage(targetBeanDefinition, refBeanDefinition));\r\n            }\r\n        } else {\r\n            if (log.isDebugEnabled()) {\r\n                log.debug(createMixingMessage(targetBeanDefinition, refBeanDefinition));\r\n            }\r\n        }\r\n        String scopedProxyBeanName = refBeanDefinition.name;\r\n        Object proxy = proxies.get(scopedProxyBeanName);\r\n        if (proxy == null) {\r\n            proxy = createScopedProxyBean(petiteContainer, refBeanDefinition);\r\n            proxies.put(scopedProxyBeanName, proxy);\r\n        }\r\n        return proxy;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.joda.time.chrono.IslamicChronology.getInstance",
	"Comment": "gets an instance of the islamicchronology in the given time zone.",
	"Method": "IslamicChronology getInstance(IslamicChronology getInstance,DateTimeZone zone,IslamicChronology getInstance,DateTimeZone zone,LeapYearPatternType leapYears){\r\n    if (zone == null) {\r\n        zone = DateTimeZone.getDefault();\r\n    }\r\n    IslamicChronology chrono;\r\n    IslamicChronology[] chronos = cCache.get(zone);\r\n    if (chronos == null) {\r\n        chronos = new IslamicChronology[4];\r\n        IslamicChronology[] oldChronos = cCache.putIfAbsent(zone, chronos);\r\n        if (oldChronos != null) {\r\n            chronos = oldChronos;\r\n        }\r\n    }\r\n    chrono = chronos[leapYears.index];\r\n    if (chrono == null) {\r\n        synchronized (chronos) {\r\n            chrono = chronos[leapYears.index];\r\n            if (chrono == null) {\r\n                if (zone == DateTimeZone.UTC) {\r\n                    chrono = new IslamicChronology(null, null, leapYears);\r\n                    DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);\r\n                    chrono = new IslamicChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, leapYears);\r\n                } else {\r\n                    chrono = getInstance(DateTimeZone.UTC, leapYears);\r\n                    chrono = new IslamicChronology(ZonedChronology.getInstance(chrono, zone), null, leapYears);\r\n                }\r\n                chronos[leapYears.index] = chrono;\r\n            }\r\n        }\r\n    }\r\n    return chrono;\r\n}"
}, {
	"Path": "org.joda.time.format.PeriodFormatterBuilder.rejectSignedValues",
	"Comment": "reject signed values when parsing the next and following appended fields.",
	"Method": "PeriodFormatterBuilder rejectSignedValues(boolean v){\r\n    iRejectSignedValues = v;\r\n    return this;\r\n}"
}, {
	"Path": "jodd.util.collection.SortedArrayList.findInsertionPoint",
	"Comment": "conducts a binary search to find the index where object\tshould be inserted.",
	"Method": "int findInsertionPoint(E o,int findInsertionPoint,E o,int low,int high){\r\n    while (low <= high) {\r\n        int mid = (low + high) >>> 1;\r\n        int delta = compare(get(mid), o);\r\n        if (delta > 0) {\r\n            high = mid - 1;\r\n        } else {\r\n            low = mid + 1;\r\n        }\r\n    }\r\n    return low;\r\n}"
}, {
	"Path": "org.joda.time.Period.toPeriod",
	"Comment": "get this period as an immutable period objectby returning this.",
	"Method": "Period toPeriod(){\r\n    return this;\r\n}"
}, {
	"Path": "jodd.introspector.FieldDescriptor.resolveRawComponentTypes",
	"Comment": "resolves raw component type for given index. this value is not cached.",
	"Method": "Class[] resolveRawComponentTypes(){\r\n    return ClassUtil.getComponentTypes(type, classDescriptor.getType());\r\n}"
}, {
	"Path": "jodd.util.StringUtil.indexOfIgnoreCase",
	"Comment": "finds first index of a substring in the given source string and range with\tignored case.",
	"Method": "int indexOfIgnoreCase(String src,char c,int startIndex,int endIndex,int indexOfIgnoreCase,String src,String subS,int indexOfIgnoreCase,String src,String subS,int startIndex,int indexOfIgnoreCase,String src,String sub,int startIndex,int endIndex,int[] indexOfIgnoreCase,String s,String arr,int[] indexOfIgnoreCase,String s,String[] arr,int start){\r\n    int arrLen = arr.length;\r\n    int index = Integer.MAX_VALUE;\r\n    int last = -1;\r\n    for (int j = 0; j < arrLen; j++) {\r\n        int i = indexOfIgnoreCase(s, arr[j], start);\r\n        if (i != -1) {\r\n            if (i < index) {\r\n                index = i;\r\n                last = j;\r\n            }\r\n        }\r\n    }\r\n    return last == -1 ? null : new int[] { last, index };\r\n}"
}, {
	"Path": "org.jsonschema2pojo.integration.util.CodeGenerationHelper.generateAndCompile",
	"Comment": "invokes the jsonschema2pojo plugin then compiles the resulting source.",
	"Method": "ClassLoader generateAndCompile(String schema,String targetPackage,Map<String, Object> configValues,ClassLoader generateAndCompile,String schema,String targetPackage,ClassLoader generateAndCompile,URL schema,String targetPackage,Map<String, Object> configValues){\r\n    File outputDirectory = generate(schema, targetPackage, configValues);\r\n    return compile(outputDirectory, new ArrayList(), configValues);\r\n}"
}, {
	"Path": "org.json.JSONArray.optFloat",
	"Comment": "get the optional float value associated with an index. the defaultvalueis returned if there is no value for the index, or if the value is not anumber and cannot be converted to a number.",
	"Method": "float optFloat(int index,float optFloat,int index,float defaultValue){\r\n    final Number val = this.optNumber(index, null);\r\n    if (val == null) {\r\n        return defaultValue;\r\n    }\r\n    final float floatValue = val.floatValue();\r\n    return floatValue;\r\n}"
}, {
	"Path": "jodd.jerry.Jerry.eachNode",
	"Comment": "iterates over a jquery object, executing a function for\teach matched element.",
	"Method": "Jerry eachNode(JerryNodeFunction function){\r\n    for (int i = 0; i < nodes.length; i++) {\r\n        Node node = nodes[i];\r\n        if (!function.onNode(node, i)) {\r\n            break;\r\n        }\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "jodd.jerry.Jerry.is",
	"Comment": "checks the current matched set of elements against a selector and\treturn true if at least one of these elements matches\tthe given arguments.",
	"Method": "boolean is(String cssSelectors){\r\n    if (nodes.length == 0) {\r\n        return false;\r\n    }\r\n    for (Node node : nodes) {\r\n        Node parentNode = node.getParentNode();\r\n        if (parentNode == null) {\r\n            continue;\r\n        }\r\n        NodeSelector nodeSelector = createNodeSelector(parentNode);\r\n        List<Node> selectedNodes = nodeSelector.select(cssSelectors);\r\n        for (Node selected : selectedNodes) {\r\n            if (node == selected) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "jodd.typeconverter.Converter.toShortValue",
	"Comment": "converts value to short. returns default value\twhen conversion result is null.",
	"Method": "short toShortValue(Object value,short defaultValue,short toShortValue,Object value){\r\n    return toShortValue(value, (short) 0);\r\n}"
}, {
	"Path": "org.joda.time.Days.plus",
	"Comment": "returns a new instance with the specified number of days added.this instance is immutable and unaffected by this method call.",
	"Method": "Days plus(int days,Days plus,Days days){\r\n    if (days == null) {\r\n        return this;\r\n    }\r\n    return plus(days.getValue());\r\n}"
}, {
	"Path": "org.joda.time.Duration.minus",
	"Comment": "returns a new duration with this length minus that specified.this instance is immutable and is not altered.if the amount is zero, this instance is returned.",
	"Method": "Duration minus(long amount,Duration minus,ReadableDuration amount){\r\n    if (amount == null) {\r\n        return this;\r\n    }\r\n    return withDurationAdded(amount.getMillis(), -1);\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Database.setForceIntegerTypesOnZeroScaleDecimals",
	"Comment": "sets the value of the forceintegertypesonzeroscaledecimals property.",
	"Method": "void setForceIntegerTypesOnZeroScaleDecimals(Boolean value){\r\n    this.forceIntegerTypesOnZeroScaleDecimals = value;\r\n}"
}, {
	"Path": "jodd.typeconverter.Converter.toBooleanValue",
	"Comment": "converts value to boolean. returns default value\twhen conversion result is null.",
	"Method": "boolean toBooleanValue(Object value,boolean defaultValue,boolean toBooleanValue,Object value){\r\n    return toBooleanValue(value, false);\r\n}"
}, {
	"Path": "jodd.madvoc.component.MadvocContainer.requestComponent",
	"Comment": "returns existing component. throws an exception if component is not registered.",
	"Method": "T requestComponent(Class<T> component,T requestComponent,String componentName){\r\n    T existingComponent = (T) lookupComponent(componentName);\r\n    if (existingComponent == null) {\r\n        throw new MadvocException(\"Madvoc component not found: \" + componentName);\r\n    }\r\n    return existingComponent;\r\n}"
}, {
	"Path": "jodd.proxetta.advice.DelegateAdvice.execute",
	"Comment": "looks up for method in target object and invokes it using reflection.",
	"Method": "Object execute(){\r\n    String methodName = ProxyTarget.targetMethodName();\r\n    Class[] argTypes = ProxyTarget.createArgumentsClassArray();\r\n    Object[] args = ProxyTarget.createArgumentsArray();\r\n    Class type = _target.getClass();\r\n    Method method = type.getMethod(methodName, argTypes);\r\n    ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();\r\n    Object result;\r\n    try {\r\n        Thread.currentThread().setContextClassLoader(type.getClassLoader());\r\n        result = method.invoke(_target, args);\r\n    } finally {\r\n        Thread.currentThread().setContextClassLoader(contextClassLoader);\r\n    }\r\n    return ProxyTarget.returnValue(result);\r\n}"
}, {
	"Path": "org.joda.time.YearMonthDay.fromDateFields",
	"Comment": "constructs a yearmonthday from a java.util.dateusing exactly the same field values avoiding any time zone effects.each field is queried from the date and assigned to the yearmonthday.this is useful if you have been using the date as a local date,ignoring the zone.this factory method always creates a yearmonthday with iso chronology.",
	"Method": "YearMonthDay fromDateFields(Date date){\r\n    if (date == null) {\r\n        throw new IllegalArgumentException(\"The date must not be null\");\r\n    }\r\n    return new YearMonthDay(date.getYear() + 1900, date.getMonth() + 1, date.getDate());\r\n}"
}, {
	"Path": "jodd.json.JsonContext.pushValue",
	"Comment": "returns true if object has been already processed during the serialization.\tused to prevent circular dependencies. objects are matched by identity.",
	"Method": "boolean pushValue(Object value){\r\n    for (int i = 0; i < bagSize; i++) {\r\n        JsonValueContext valueContext = bag.get(i);\r\n        if (valueContext.getValue() == value) {\r\n            return true;\r\n        }\r\n    }\r\n    if (bagSize == bag.size()) {\r\n        lastValueContext = new JsonValueContext(value);\r\n        bag.add(lastValueContext);\r\n    } else {\r\n        lastValueContext = bag.get(bagSize);\r\n        lastValueContext.reuse(value);\r\n    }\r\n    bagSize++;\r\n    return false;\r\n}"
}, {
	"Path": "jodd.joy.page.PageData.getPageItemsCount",
	"Comment": "returns the number of shown items per page.\tnote that this value is calculated.",
	"Method": "int getPageItemsCount(){\r\n    return pageItemsCount;\r\n}"
}, {
	"Path": "org.jsonschema2pojo.util.NameHelper.getPropertyName",
	"Comment": "convert jsonfieldname into the equivalent java fieldname by replacingillegal characters and normalizing it.",
	"Method": "String getPropertyName(String jsonFieldName,JsonNode node){\r\n    jsonFieldName = getFieldName(jsonFieldName, node);\r\n    jsonFieldName = replaceIllegalCharacters(jsonFieldName);\r\n    jsonFieldName = normalizeName(jsonFieldName);\r\n    jsonFieldName = makeLowerCamelCase(jsonFieldName);\r\n    if (isKeyword(jsonFieldName)) {\r\n        jsonFieldName = \"_\" + jsonFieldName;\r\n    }\r\n    if (isKeyword(jsonFieldName)) {\r\n        jsonFieldName += \"_\";\r\n    }\r\n    return jsonFieldName;\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractInstant.hashCode",
	"Comment": "gets a hash code for the instant as defined in readableinstant.",
	"Method": "int hashCode(){\r\n    return ((int) (getMillis() ^ (getMillis() >>> 32))) + (getChronology().hashCode());\r\n}"
}, {
	"Path": "jodd.petite.resolver.ReferencesResolver.resolveReferenceFromValue",
	"Comment": "resolves reference from given values. returns bean reference of given value or defaults\tif given name is blank.",
	"Method": "BeanReferences resolveReferenceFromValue(PropertyDescriptor propertyDescriptor,String refName){\r\n    BeanReferences references;\r\n    if (refName == null || refName.isEmpty()) {\r\n        references = buildDefaultReference(propertyDescriptor);\r\n    } else {\r\n        references = BeanReferences.of(refName);\r\n    }\r\n    references = references.removeDuplicateNames();\r\n    return references;\r\n}"
}, {
	"Path": "jodd.props.Props.setValueTrimLeft",
	"Comment": "specifies should the values be trimmed from the left.\tdefault is true.",
	"Method": "Props setValueTrimLeft(boolean valueTrimLeft){\r\n    parser.valueTrimLeft = valueTrimLeft;\r\n    return this;\r\n}"
}, {
	"Path": "org.joda.time.DateTimeField.setExtended",
	"Comment": "sets a value in the milliseconds supplied, allowing a little leniency at the margins.this is primarily an internal method used by parsing.",
	"Method": "long setExtended(long instant,int value){\r\n    return set(instant, value);\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractPartial.get",
	"Comment": "get the value of one of the fields of a datetime.the field specified must be one of those that is supported by the partial.",
	"Method": "int get(DateTimeFieldType type){\r\n    return getValue(indexOfSupported(type));\r\n}"
}, {
	"Path": "org.json.HTTPTokener.nextToken",
	"Comment": "get the next token or string. this is used in parsing http headers.",
	"Method": "String nextToken(){\r\n    char c;\r\n    char q;\r\n    StringBuilder sb = new StringBuilder();\r\n    do {\r\n        c = next();\r\n    } while (Character.isWhitespace(c));\r\n    if (c == '\"' || c == '\\'') {\r\n        q = c;\r\n        for (; ; ) {\r\n            c = next();\r\n            if (c < ' ') {\r\n                throw syntaxError(\"Unterminated string.\");\r\n            }\r\n            if (c == q) {\r\n                return sb.toString();\r\n            }\r\n            sb.append(c);\r\n        }\r\n    }\r\n    for (; ; ) {\r\n        if (c == 0 || Character.isWhitespace(c)) {\r\n            return sb.toString();\r\n        }\r\n        sb.append(c);\r\n        c = next();\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.monthOfYear",
	"Comment": "get the month of year property which provides access to advanced functionality.",
	"Method": "Property monthOfYear(){\r\n    return new Property(this, getChronology().monthOfYear());\r\n}"
}, {
	"Path": "jodd.bean.BeanVisitor.resolveProperties",
	"Comment": "returns an array of bean properties. if bean is a map,\tall its keys will be returned.",
	"Method": "String[] resolveProperties(Object bean,boolean declared){\r\n    String[] properties;\r\n    if (bean instanceof Map) {\r\n        Set keys = ((Map) bean).keySet();\r\n        properties = new String[keys.size()];\r\n        int ndx = 0;\r\n        for (Object key : keys) {\r\n            properties[ndx] = key.toString();\r\n            ndx++;\r\n        }\r\n    } else {\r\n        properties = getAllBeanPropertyNames(bean.getClass(), declared);\r\n    }\r\n    return properties;\r\n}"
}, {
	"Path": "org.json.JSONTokener.incrementIndexes",
	"Comment": "increments the internal indexes according to the previous characterread and the character passed as the current character.",
	"Method": "void incrementIndexes(int c){\r\n    if (c > 0) {\r\n        this.index++;\r\n        if (c == '\\r') {\r\n            this.line++;\r\n            this.characterPreviousLine = this.character;\r\n            this.character = 0;\r\n        } else if (c == '\\n') {\r\n            if (this.previous != '\\r') {\r\n                this.line++;\r\n                this.characterPreviousLine = this.character;\r\n            }\r\n            this.character = 0;\r\n        } else {\r\n            this.character++;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.base.BaseSingleFieldPeriod.setValue",
	"Comment": "sets the amount of this period.to make a subclass immutable you must declare it final, or block this method.",
	"Method": "void setValue(int value){\r\n    iPeriod = value;\r\n}"
}, {
	"Path": "jodd.jerry.Jerry.empty",
	"Comment": "removes all child nodes of the set of matched elements from the dom.",
	"Method": "Jerry empty(){\r\n    if (nodes.length == 0) {\r\n        return this;\r\n    }\r\n    for (Node node : nodes) {\r\n        node.removeAllChilds();\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "jodd.madvoc.component.ActionConfigManager.bindAnnotationConfig",
	"Comment": "binds action annotation and the action config. this can overwrite the default annotation\tconfiguration of an annotation.",
	"Method": "void bindAnnotationConfig(Class<? extends Annotation> annotationType,Class<? extends ActionConfig> actionConfigClass){\r\n    final ActionConfig actionConfig = registerNewActionConfiguration(actionConfigClass);\r\n    actionConfigs.put(annotationType, actionConfig);\r\n    for (final AnnotationParser annotationParser : annotationParsers) {\r\n        if (annotationType.equals(annotationParser.getAnnotationType())) {\r\n            return;\r\n        }\r\n    }\r\n    annotationParsers = ArraysUtil.append(annotationParsers, new AnnotationParser(annotationType, Action.class));\r\n}"
}, {
	"Path": "org.jsonschema2pojo.rules.RuleFactory.setGenerationConfig",
	"Comment": "the generation config options for type generation. these config optionswill influence the java code generated by rules created by this factory.",
	"Method": "void setGenerationConfig(GenerationConfig generationConfig){\r\n    this.generationConfig = generationConfig;\r\n    this.nameHelper = new NameHelper(generationConfig);\r\n}"
}, {
	"Path": "org.joda.time.DateTime.withMillisOfSecond",
	"Comment": "returns a copy of this datetime with the millis of second field updated.datetime is immutable, so there are no set methods.instead, this method returns a new instance with the value ofmillis of second changed.",
	"Method": "DateTime withMillisOfSecond(int millis){\r\n    return withMillis(getChronology().millisOfSecond().set(getMillis(), millis));\r\n}"
}, {
	"Path": "org.json.XMLTokener.nextMeta",
	"Comment": "returns the next xml meta token. this is used for skipping over andstructures.",
	"Method": "Object nextMeta(){\r\n    char c;\r\n    char q;\r\n    do {\r\n        c = next();\r\n    } while (Character.isWhitespace(c));\r\n    switch(c) {\r\n        case 0:\r\n            throw syntaxError(\"Misshaped meta tag\");\r\n        case '<':\r\n            return XML.LT;\r\n        case '>':\r\n            return XML.GT;\r\n        case '/':\r\n            return XML.SLASH;\r\n        case '=':\r\n            return XML.EQ;\r\n        case '!':\r\n            return XML.BANG;\r\n        case '?':\r\n            return XML.QUEST;\r\n        case '\"':\r\n        case '\\'':\r\n            q = c;\r\n            for (; ; ) {\r\n                c = next();\r\n                if (c == 0) {\r\n                    throw syntaxError(\"Unterminated string\");\r\n                }\r\n                if (c == q) {\r\n                    return Boolean.TRUE;\r\n                }\r\n            }\r\n        default:\r\n            for (; ; ) {\r\n                c = next();\r\n                if (Character.isWhitespace(c)) {\r\n                    return Boolean.TRUE;\r\n                }\r\n                switch(c) {\r\n                    case 0:\r\n                    case '<':\r\n                    case '>':\r\n                    case '/':\r\n                    case '=':\r\n                    case '!':\r\n                    case '?':\r\n                    case '\"':\r\n                    case '\\'':\r\n                        back();\r\n                        return Boolean.TRUE;\r\n                }\r\n            }\r\n    }\r\n}"
}, {
	"Path": "jodd.util.cl.DefaultClassLoaderStrategy.prepareArrayClassnameForLoading",
	"Comment": "prepares classname for loading, respecting the arrays.\treturns null if class name is not an array.",
	"Method": "String prepareArrayClassnameForLoading(String className){\r\n    int bracketCount = StringUtil.count(className, '[');\r\n    if (bracketCount == 0) {\r\n        return null;\r\n    }\r\n    String brackets = StringUtil.repeat('[', bracketCount);\r\n    int bracketIndex = className.indexOf('[');\r\n    className = className.substring(0, bracketIndex);\r\n    int primitiveNdx = getPrimitiveClassNameIndex(className);\r\n    if (primitiveNdx >= 0) {\r\n        className = String.valueOf(PRIMITIVE_BYTECODE_NAME[primitiveNdx]);\r\n        return brackets + className;\r\n    } else {\r\n        return brackets + 'L' + className + ';';\r\n    }\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Generate.setJavaBeansGettersAndSetters",
	"Comment": "sets the value of the javabeansgettersandsetters property.",
	"Method": "void setJavaBeansGettersAndSetters(Boolean value){\r\n    this.javaBeansGettersAndSetters = value;\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.millisOfSecond",
	"Comment": "get the millis of second property which provides access to advanced functionality.",
	"Method": "Property millisOfSecond(){\r\n    return new Property(this, getChronology().millisOfSecond());\r\n}"
}, {
	"Path": "org.json.JSONObject.optJSONObject",
	"Comment": "get an optional jsonobject associated with a key. it returns null ifthere is no such key, or if its value is not a jsonobject.",
	"Method": "JSONObject optJSONObject(String key){\r\n    Object object = this.opt(key);\r\n    return object instanceof JSONObject ? (JSONObject) object : null;\r\n}"
}, {
	"Path": "jodd.petite.PetiteBeans.removeBean",
	"Comment": "removes bean and returns definition of removed bean.\tall resolvers references are deleted, too.\treturns bean definition of removed bean or null.",
	"Method": "void removeBean(Class type,BeanDefinition removeBean,String name){\r\n    BeanDefinition bd = beans.remove(name);\r\n    if (bd == null) {\r\n        return null;\r\n    }\r\n    bd.scopeRemove();\r\n    return bd;\r\n}"
}, {
	"Path": "org.json.JSONObject.optBigInteger",
	"Comment": "get an optional biginteger associated with a key, or the defaultvalue ifthere is no such key or if its value is not a number. if the value is astring, an attempt will be made to evaluate it as a number.",
	"Method": "BigInteger optBigInteger(String key,BigInteger defaultValue){\r\n    Object val = this.opt(key);\r\n    return objectToBigInteger(val, defaultValue);\r\n}"
}, {
	"Path": "org.joda.time.MutablePeriod.mergePeriod",
	"Comment": "merges all the fields from the specified period into this one.fields that are not present in the specified period are left unaltered.",
	"Method": "void mergePeriod(ReadablePeriod period){\r\n    super.mergePeriod(period);\r\n}"
}, {
	"Path": "org.json.CDL.toString",
	"Comment": "produce a comma delimited text from a jsonarray of jsonobjects usinga provided list of names. the list of names is not included in theoutput.",
	"Method": "String toString(JSONArray ja,String toString,JSONArray names,JSONArray ja){\r\n    if (names == null || names.length() == 0) {\r\n        return null;\r\n    }\r\n    StringBuffer sb = new StringBuffer();\r\n    for (int i = 0; i < ja.length(); i += 1) {\r\n        JSONObject jo = ja.optJSONObject(i);\r\n        if (jo != null) {\r\n            sb.append(rowToString(jo.toJSONArray(names)));\r\n        }\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "jodd.jerry.Jerry.gt",
	"Comment": "reduces the set of matched elements to the one at an index greater\tthan specified index.",
	"Method": "Jerry gt(int value){\r\n    List<Node> result = new NodeList(nodes.length);\r\n    if (nodes.length > 0) {\r\n        int index = 0;\r\n        for (Node node : nodes) {\r\n            if (index > value) {\r\n                result.add(node);\r\n            }\r\n            index++;\r\n        }\r\n    }\r\n    return new Jerry(this, result);\r\n}"
}, {
	"Path": "org.joda.time.format.DateTimeFormat.appendPatternTo",
	"Comment": "parses the given pattern and appends the rules to the givendatetimeformatterbuilder.",
	"Method": "void appendPatternTo(DateTimeFormatterBuilder builder,String pattern){\r\n    parsePatternTo(builder, pattern);\r\n}"
}, {
	"Path": "jodd.util.ClassUtil.newInstance",
	"Comment": "creates new instance of given class with given optional arguments.",
	"Method": "T newInstance(Class<T> clazz,Object params,T newInstance,Class<T> type){\r\n    if (type.isPrimitive()) {\r\n        if (type == int.class) {\r\n            return (T) Integer.valueOf(0);\r\n        }\r\n        if (type == long.class) {\r\n            return (T) Long.valueOf(0);\r\n        }\r\n        if (type == boolean.class) {\r\n            return (T) Boolean.FALSE;\r\n        }\r\n        if (type == float.class) {\r\n            return (T) Float.valueOf(0);\r\n        }\r\n        if (type == double.class) {\r\n            return (T) Double.valueOf(0);\r\n        }\r\n        if (type == byte.class) {\r\n            return (T) Byte.valueOf((byte) 0);\r\n        }\r\n        if (type == short.class) {\r\n            return (T) Short.valueOf((short) 0);\r\n        }\r\n        if (type == char.class) {\r\n            return (T) Character.valueOf((char) 0);\r\n        }\r\n        throw new IllegalArgumentException(\"Invalid primitive: \" + type);\r\n    }\r\n    if (type.getName().startsWith(\"java.\")) {\r\n        if (type == Integer.class) {\r\n            return (T) Integer.valueOf(0);\r\n        }\r\n        if (type == String.class) {\r\n            return (T) StringPool.EMPTY;\r\n        }\r\n        if (type == Long.class) {\r\n            return (T) Long.valueOf(0);\r\n        }\r\n        if (type == Boolean.class) {\r\n            return (T) Boolean.FALSE;\r\n        }\r\n        if (type == Float.class) {\r\n            return (T) Float.valueOf(0);\r\n        }\r\n        if (type == Double.class) {\r\n            return (T) Double.valueOf(0);\r\n        }\r\n        if (type == Map.class) {\r\n            return (T) new HashMap();\r\n        }\r\n        if (type == List.class) {\r\n            return (T) new ArrayList();\r\n        }\r\n        if (type == Set.class) {\r\n            return (T) new HashSet();\r\n        }\r\n        if (type == Collection.class) {\r\n            return (T) new ArrayList();\r\n        }\r\n        if (type == Byte.class) {\r\n            return (T) Byte.valueOf((byte) 0);\r\n        }\r\n        if (type == Short.class) {\r\n            return (T) Short.valueOf((short) 0);\r\n        }\r\n        if (type == Character.class) {\r\n            return (T) Character.valueOf((char) 0);\r\n        }\r\n    }\r\n    if (type.isEnum()) {\r\n        return type.getEnumConstants()[0];\r\n    }\r\n    if (type.isArray()) {\r\n        return (T) Array.newInstance(type.getComponentType(), 0);\r\n    }\r\n    Constructor<T> declaredConstructor = type.getDeclaredConstructor();\r\n    forceAccess(declaredConstructor);\r\n    return declaredConstructor.newInstance();\r\n}"
}, {
	"Path": "org.joda.time.field.DividedDateTimeField.addWrapField",
	"Comment": "add to the scaled component of the specified time instant,wrapping around within that component if necessary.",
	"Method": "long addWrapField(long instant,int amount){\r\n    return set(instant, FieldUtils.getWrappedValue(get(instant), amount, iMin, iMax));\r\n}"
}, {
	"Path": "org.json.JSONObject.names",
	"Comment": "produce a jsonarray containing the names of the elements of thisjsonobject.",
	"Method": "JSONArray names(){\r\n    if (this.map.isEmpty()) {\r\n        return null;\r\n    }\r\n    return new JSONArray(this.map.keySet());\r\n}"
}, {
	"Path": "jodd.proxetta.ProxyTarget.invoke",
	"Comment": "inserts the invocation of target method and getting the invocation results.\tsmall types are converted to wrappers. if method is void,\tnull is used for return value.",
	"Method": "Object invoke(){\r\n    throw new ProxettaException();\r\n}"
}, {
	"Path": "org.joda.time.DateMidnight.year",
	"Comment": "get the year property which provides access to advanced functionality.",
	"Method": "Property year(){\r\n    return new Property(this, getChronology().year());\r\n}"
}, {
	"Path": "org.joda.time.Seconds.secondsIn",
	"Comment": "creates a seconds representing the number of whole secondsin the specified interval.",
	"Method": "Seconds secondsIn(ReadableInterval interval){\r\n    if (interval == null) {\r\n        return Seconds.ZERO;\r\n    }\r\n    int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.seconds());\r\n    return Seconds.seconds(amount);\r\n}"
}, {
	"Path": "org.joda.time.Interval.withPeriodAfterStart",
	"Comment": "creates a new interval with the specified period after the start instant.",
	"Method": "Interval withPeriodAfterStart(ReadablePeriod period){\r\n    if (period == null) {\r\n        return withDurationAfterStart(null);\r\n    }\r\n    Chronology chrono = getChronology();\r\n    long startMillis = getStartMillis();\r\n    long endMillis = chrono.add(period, startMillis, 1);\r\n    return new Interval(startMillis, endMillis, chrono);\r\n}"
}, {
	"Path": "jodd.asm7.SymbolTable.getClassName",
	"Comment": "returns the internal name of the class to which this symbol table belongs.",
	"Method": "String getClassName(){\r\n    return className;\r\n}"
}, {
	"Path": "org.joda.time.DateTime.year",
	"Comment": "get the year property which provides access to advanced functionality.",
	"Method": "Property year(){\r\n    return new Property(this, getChronology().year());\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.rtsp.RtspServer.getBitrate",
	"Comment": "returns the bandwidth consumed by the rtsp server in bits per second.",
	"Method": "long getBitrate(){\r\n    long bitrate = 0;\r\n    for (Session session : mSessions.keySet()) {\r\n        if (session != null && session.isStreaming()) {\r\n            bitrate += session.getBitrate();\r\n        }\r\n    }\r\n    return bitrate;\r\n}"
}, {
	"Path": "jodd.json.impl.ValueJsonSerializer.serialize",
	"Comment": "detects circular dependencies and pushes value as current\ttype context.",
	"Method": "boolean serialize(JsonContext jsonContext,T value){\r\n    if (jsonContext.pushValue(value)) {\r\n        return false;\r\n    }\r\n    serializeValue(jsonContext, value);\r\n    jsonContext.popValue();\r\n    return true;\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.gl.SurfaceManager.eglSetup",
	"Comment": "prepares egl.we want a gles 2.0 context and a surface that supports recording.",
	"Method": "void eglSetup(){\r\n    mEGLDisplay = EGL14.eglGetDisplay(EGL14.EGL_DEFAULT_DISPLAY);\r\n    if (mEGLDisplay == EGL14.EGL_NO_DISPLAY) {\r\n        throw new RuntimeException(\"unable to get EGL14 display\");\r\n    }\r\n    int[] version = new int[2];\r\n    if (!EGL14.eglInitialize(mEGLDisplay, version, 0, version, 1)) {\r\n        throw new RuntimeException(\"unable to initialize EGL14\");\r\n    }\r\n    int[] attribList;\r\n    if (mEGLSharedContext == null) {\r\n        attribList = new int[] { EGL14.EGL_RED_SIZE, 8, EGL14.EGL_GREEN_SIZE, 8, EGL14.EGL_BLUE_SIZE, 8, EGL14.EGL_RENDERABLE_TYPE, EGL14.EGL_OPENGL_ES2_BIT, EGL14.EGL_NONE };\r\n    } else {\r\n        attribList = new int[] { EGL14.EGL_RED_SIZE, 8, EGL14.EGL_GREEN_SIZE, 8, EGL14.EGL_BLUE_SIZE, 8, EGL14.EGL_RENDERABLE_TYPE, EGL14.EGL_OPENGL_ES2_BIT, EGL_RECORDABLE_ANDROID, 1, EGL14.EGL_NONE };\r\n    }\r\n    EGLConfig[] configs = new EGLConfig[1];\r\n    int[] numConfigs = new int[1];\r\n    EGL14.eglChooseConfig(mEGLDisplay, attribList, 0, configs, 0, configs.length, numConfigs, 0);\r\n    checkEglError(\"eglCreateContext RGB888+recordable ES2\");\r\n    int[] attrib_list = { EGL14.EGL_CONTEXT_CLIENT_VERSION, 2, EGL14.EGL_NONE };\r\n    if (mEGLSharedContext == null) {\r\n        mEGLContext = EGL14.eglCreateContext(mEGLDisplay, configs[0], EGL14.EGL_NO_CONTEXT, attrib_list, 0);\r\n    } else {\r\n        mEGLContext = EGL14.eglCreateContext(mEGLDisplay, configs[0], mEGLSharedContext, attrib_list, 0);\r\n    }\r\n    checkEglError(\"eglCreateContext\");\r\n    int[] surfaceAttribs = { EGL14.EGL_NONE };\r\n    mEGLSurface = EGL14.eglCreateWindowSurface(mEGLDisplay, configs[0], mSurface, surfaceAttribs, 0);\r\n    checkEglError(\"eglCreateWindowSurface\");\r\n    GLES20.glDisable(GLES20.GL_DEPTH_TEST);\r\n    GLES20.glDisable(GLES20.GL_CULL_FACE);\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Generate.isCommentsOnRoutines",
	"Comment": "turn off generation of all sql comments as javadoc on all routines.",
	"Method": "Boolean isCommentsOnRoutines(){\r\n    return commentsOnRoutines;\r\n}"
}, {
	"Path": "org.joda.time.DateTime.withMonthOfYear",
	"Comment": "returns a copy of this datetime with the month of year field updated.datetime is immutable, so there are no set methods.instead, this method returns a new instance with the value ofmonth of year changed.",
	"Method": "DateTime withMonthOfYear(int monthOfYear){\r\n    return withMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear));\r\n}"
}, {
	"Path": "jodd.servlet.tag.LoopTag.setAutoDirection",
	"Comment": "specifies if direction should be detected from the start and end value.",
	"Method": "void setAutoDirection(boolean autoDirection){\r\n    this.autoDirection = autoDirection;\r\n}"
}, {
	"Path": "org.joda.time.Period.toStandardSeconds",
	"Comment": "converts this period to a period in seconds assuming a7 day week, 24 hour day, 60 minute hour and 60 second minute.this method allows you to convert between different types of period.however to achieve this it makes the assumption that allweeks are 7 days, all days are 24 hours, all hours are 60 minutes andall minutes are 60 seconds. this is not true when daylight savings timeis considered, and may also not be true for some unusual chronologies.however, it is included as it is a useful operation for manyapplications and business rules.if the period contains years or months, an exception will be thrown.",
	"Method": "Seconds toStandardSeconds(){\r\n    checkYearsAndMonths(\"Seconds\");\r\n    long seconds = getMillis() / DateTimeConstants.MILLIS_PER_SECOND;\r\n    seconds = FieldUtils.safeAdd(seconds, getSeconds());\r\n    seconds = FieldUtils.safeAdd(seconds, ((long) getMinutes()) * ((long) DateTimeConstants.SECONDS_PER_MINUTE));\r\n    seconds = FieldUtils.safeAdd(seconds, ((long) getHours()) * ((long) DateTimeConstants.SECONDS_PER_HOUR));\r\n    seconds = FieldUtils.safeAdd(seconds, ((long) getDays()) * ((long) DateTimeConstants.SECONDS_PER_DAY));\r\n    seconds = FieldUtils.safeAdd(seconds, ((long) getWeeks()) * ((long) DateTimeConstants.SECONDS_PER_WEEK));\r\n    return Seconds.seconds(FieldUtils.safeToInt(seconds));\r\n}"
}, {
	"Path": "jodd.asm7.ByteVector.put11",
	"Comment": "puts two bytes into this byte vector. the byte vector is automatically enlarged if necessary.",
	"Method": "ByteVector put11(int byteValue1,int byteValue2){\r\n    int currentLength = length;\r\n    if (currentLength + 2 > data.length) {\r\n        enlarge(2);\r\n    }\r\n    byte[] currentData = data;\r\n    currentData[currentLength++] = (byte) byteValue1;\r\n    currentData[currentLength++] = (byte) byteValue2;\r\n    length = currentLength;\r\n    return this;\r\n}"
}, {
	"Path": "jodd.proxetta.asm.ProxettaMethodBuilder.visitEnd",
	"Comment": "finally, builds proxy methods if applied to current method.",
	"Method": "void visitEnd(){\r\n    createFirstChainDelegate_Continue(tmd);\r\n    for (int p = 0; p < tmd.proxyData.length; p++) {\r\n        tmd.selectCurrentProxy(p);\r\n        createProxyMethod(tmd);\r\n    }\r\n}"
}, {
	"Path": "jodd.asm7.ByteVector.put12",
	"Comment": "puts a byte and a short into this byte vector. the byte vector is automatically enlarged ifnecessary.",
	"Method": "ByteVector put12(int byteValue,int shortValue){\r\n    int currentLength = length;\r\n    if (currentLength + 3 > data.length) {\r\n        enlarge(3);\r\n    }\r\n    byte[] currentData = data;\r\n    currentData[currentLength++] = (byte) byteValue;\r\n    currentData[currentLength++] = (byte) (shortValue >>> 8);\r\n    currentData[currentLength++] = (byte) shortValue;\r\n    length = currentLength;\r\n    return this;\r\n}"
}, {
	"Path": "org.jooq.impl.AbstractField.add",
	"Comment": "this default implementation is known to be overridden byexpression to generate neater expressions",
	"Method": "Field<T> add(Number value,Field<T> add,Field<?> value){\r\n    return new Expression<T>(ADD, this, nullSafe(value, getDataType()));\r\n}"
}, {
	"Path": "org.joda.time.field.OffsetDateTimeField.addWrapField",
	"Comment": "add to the offset component of the specified time instant,wrapping around within that component if necessary.",
	"Method": "long addWrapField(long instant,int amount){\r\n    return set(instant, FieldUtils.getWrappedValue(get(instant), amount, iMin, iMax));\r\n}"
}, {
	"Path": "org.joda.time.chrono.BaseChronology.getDateTimeMillis",
	"Comment": "returns a datetime millisecond instant, from from the given instant,hour, minute, second, and millisecond values. the set of given valuesmust refer to a valid datetime, or else an illegalargumentexception isthrown.the default implementation calls upon separate datetimefields todetermine the result. subclasses are encouraged to provide a moreefficient implementation.",
	"Method": "long getDateTimeMillis(int year,int monthOfYear,int dayOfMonth,int millisOfDay,long getDateTimeMillis,int year,int monthOfYear,int dayOfMonth,int hourOfDay,int minuteOfHour,int secondOfMinute,int millisOfSecond,long getDateTimeMillis,long instant,int hourOfDay,int minuteOfHour,int secondOfMinute,int millisOfSecond){\r\n    instant = hourOfDay().set(instant, hourOfDay);\r\n    instant = minuteOfHour().set(instant, minuteOfHour);\r\n    instant = secondOfMinute().set(instant, secondOfMinute);\r\n    return millisOfSecond().set(instant, millisOfSecond);\r\n}"
}, {
	"Path": "com.jayway.jsonpath.Configuration.getEvaluationListeners",
	"Comment": "returns the evaluation listeners registered in this configuration",
	"Method": "Collection<EvaluationListener> getEvaluationListeners(){\r\n    return evaluationListeners;\r\n}"
}, {
	"Path": "org.joda.time.Period.withMonths",
	"Comment": "returns a new period with the specified number of months.this period instance is immutable and unaffected by this method call.",
	"Method": "Period withMonths(int months){\r\n    int[] values = getValues();\r\n    getPeriodType().setIndexedField(this, PeriodType.MONTH_INDEX, values, months);\r\n    return new Period(values, getPeriodType());\r\n}"
}, {
	"Path": "org.joda.time.DateTimeZone.getProvider",
	"Comment": "gets the zone provider factory.the zone provider is a pluggable instance factory that supplies theactual instances of datetimezone.",
	"Method": "Provider getProvider(){\r\n    Provider provider = cProvider.get();\r\n    if (provider == null) {\r\n        provider = getDefaultProvider();\r\n        if (!cProvider.compareAndSet(null, provider)) {\r\n            provider = cProvider.get();\r\n        }\r\n    }\r\n    return provider;\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.minus",
	"Comment": "returns a copy of this datetime with the specified duration taken away.if the amount is zero or null, then this is returned.",
	"Method": "LocalDateTime minus(ReadableDuration duration,LocalDateTime minus,ReadablePeriod period){\r\n    return withPeriodAdded(period, -1);\r\n}"
}, {
	"Path": "jodd.mail.SendMailSession.setHeaders",
	"Comment": "sets headers in msgtoset with headers from emailwithdata.",
	"Method": "void setHeaders(Email emailWithData,MimeMessage msgToSet){\r\n    final Map<String, String> headers = emailWithData.headers();\r\n    if (headers != null) {\r\n        for (final Map.Entry<String, String> entry : headers.entrySet()) {\r\n            msgToSet.setHeader(entry.getKey(), entry.getValue());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jodd.paramo.MethodParameter.getSignature",
	"Comment": "returns method parameter signature.\tgenerics information is available, too.",
	"Method": "String getSignature(){\r\n    return signature;\r\n}"
}, {
	"Path": "org.joda.time.chrono.BasicWeekyearDateTimeField.addWrapField",
	"Comment": "add to the year component of the specified time instantwrapping around within that component if necessary.",
	"Method": "long addWrapField(long instant,int years){\r\n    return add(instant, years);\r\n}"
}, {
	"Path": "org.joda.time.Period.withWeeks",
	"Comment": "returns a new period with the specified number of weeks.this period instance is immutable and unaffected by this method call.",
	"Method": "Period withWeeks(int weeks){\r\n    int[] values = getValues();\r\n    getPeriodType().setIndexedField(this, PeriodType.WEEK_INDEX, values, weeks);\r\n    return new Period(values, getPeriodType());\r\n}"
}, {
	"Path": "org.joda.time.LocalDate.dayOfWeek",
	"Comment": "get the day of week property which provides access to advanced functionality.",
	"Method": "Property dayOfWeek(){\r\n    return new Property(this, getChronology().dayOfWeek());\r\n}"
}, {
	"Path": "org.joda.time.MutableDateTime.property",
	"Comment": "gets the property object for the specified type, which contains many useful methods.",
	"Method": "Property property(DateTimeFieldType type){\r\n    if (type == null) {\r\n        throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\r\n    }\r\n    DateTimeField field = type.getField(getChronology());\r\n    if (field.isSupported() == false) {\r\n        throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\");\r\n    }\r\n    return new Property(this, field);\r\n}"
}, {
	"Path": "org.jooq.impl.DSL.createUniqueIndexIfNotExists",
	"Comment": "create a new dsl create unique index if not exists statement.",
	"Method": "CreateIndexStep createUniqueIndexIfNotExists(String index,CreateIndexStep createUniqueIndexIfNotExists,Name index,CreateIndexStep createUniqueIndexIfNotExists,Index index){\r\n    return dsl().createUniqueIndexIfNotExists(index);\r\n}"
}, {
	"Path": "org.joda.time.DateTime.toLocalDate",
	"Comment": "converts this object to a localdate with thesame date and chronology.",
	"Method": "LocalDate toLocalDate(){\r\n    return new LocalDate(getMillis(), getChronology());\r\n}"
}, {
	"Path": "org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneId",
	"Comment": "instructs the printer to emit the identifier of the time zone.from version 2.0, this field can be parsed.",
	"Method": "DateTimeFormatterBuilder appendTimeZoneId(){\r\n    return append0(TimeZoneId.INSTANCE, TimeZoneId.INSTANCE);\r\n}"
}, {
	"Path": "jodd.props.Props.setValueTrimRight",
	"Comment": "specifies should the values be trimmed from the right.\tdefault is true.",
	"Method": "Props setValueTrimRight(boolean valueTrimRight){\r\n    parser.valueTrimRight = valueTrimRight;\r\n    return this;\r\n}"
}, {
	"Path": "jodd.io.ZipUtil.zip",
	"Comment": "zips a file or a folder. if adding a folder, all its content will be added.",
	"Method": "File zip(String file,File zip,File file){\r\n    String zipFile = file.getAbsolutePath() + ZIP_EXT;\r\n    return ZipBuilder.createZipFile(zipFile).add(file).recursive().save().toZipFile();\r\n}"
}, {
	"Path": "jodd.db.oom.DbEntityManager.registerType",
	"Comment": "registers just type and entity names. enough for most usages.",
	"Method": "DbEntityDescriptor<E> registerType(Class<E> type){\r\n    DbEntityDescriptor<E> ded = createDbEntityDescriptor(type);\r\n    DbEntityDescriptor<E> existing = descriptorsMap.put(type, ded);\r\n    if (log.isDebugEnabled()) {\r\n        log.debug(\"Register \" + type.getName() + \" as \" + ded.getTableName());\r\n    }\r\n    if (existing != null) {\r\n        if (ded.getType() == type) {\r\n            return ded;\r\n        }\r\n        throw new DbOomException(\"Type already registered: \" + existing.getType());\r\n    }\r\n    existing = entityNamesMap.put(ded.getEntityName(), ded);\r\n    if (existing != null) {\r\n        throw new DbOomException(\"Name '\" + ded.getEntityName() + \"' already mapped to an entity: \" + existing.getType());\r\n    }\r\n    return ded;\r\n}"
}, {
	"Path": "jodd.bean.BeanUtilUtil.convertIndexToMapKey",
	"Comment": "converts map index to key type. if conversion fails, original value will be returned.",
	"Method": "Object convertIndexToMapKey(Getter getter,Object index){\r\n    Class indexType = null;\r\n    if (getter != null) {\r\n        indexType = getter.getGetterRawKeyComponentType();\r\n    }\r\n    if (indexType == null) {\r\n        indexType = Object.class;\r\n    }\r\n    if (indexType == Object.class) {\r\n        return index;\r\n    }\r\n    try {\r\n        return convertType(index, indexType);\r\n    } catch (Exception ignore) {\r\n        return index;\r\n    }\r\n}"
}, {
	"Path": "jodd.joy.page.PageRequest.getSize",
	"Comment": "returns size of the page. page size refers to total numbers of items per page.",
	"Method": "int getSize(){\r\n    return size;\r\n}"
}, {
	"Path": "jodd.util.StringUtil.repeat",
	"Comment": "creates a new string that contains the provided string a number of times.",
	"Method": "String repeat(String source,int count,String repeat,char c,int count){\r\n    char[] result = new char[count];\r\n    for (int i = 0; i < count; i++) {\r\n        result[i] = c;\r\n    }\r\n    return new String(result);\r\n}"
}, {
	"Path": "org.joda.time.field.FieldUtils.safeSubtract",
	"Comment": "subtracts two values throwing an exception if overflow occurs.",
	"Method": "long safeSubtract(long val1,long val2){\r\n    long diff = val1 - val2;\r\n    if ((val1 ^ diff) < 0 && (val1 ^ val2) < 0) {\r\n        throw new ArithmeticException(\"The calculation caused an overflow: \" + val1 + \" - \" + val2);\r\n    }\r\n    return diff;\r\n}"
}, {
	"Path": "org.json.XML.stringToValue",
	"Comment": "the one in jsonobject. changes made here should be reflected there.",
	"Method": "Object stringToValue(String string){\r\n    if (string.equals(\"\")) {\r\n        return string;\r\n    }\r\n    if (string.equalsIgnoreCase(\"true\")) {\r\n        return Boolean.TRUE;\r\n    }\r\n    if (string.equalsIgnoreCase(\"false\")) {\r\n        return Boolean.FALSE;\r\n    }\r\n    if (string.equalsIgnoreCase(\"null\")) {\r\n        return JSONObject.NULL;\r\n    }\r\n    char initial = string.charAt(0);\r\n    if ((initial >= '0' && initial <= '9') || initial == '-') {\r\n        try {\r\n            if (string.indexOf('.') > -1 || string.indexOf('e') > -1 || string.indexOf('E') > -1 || \"-0\".equals(string)) {\r\n                Double d = Double.valueOf(string);\r\n                if (!d.isInfinite() && !d.isNaN()) {\r\n                    return d;\r\n                }\r\n            } else {\r\n                Long myLong = Long.valueOf(string);\r\n                if (string.equals(myLong.toString())) {\r\n                    if (myLong.longValue() == myLong.intValue()) {\r\n                        return Integer.valueOf(myLong.intValue());\r\n                    }\r\n                    return myLong;\r\n                }\r\n            }\r\n        } catch (Exception ignore) {\r\n        }\r\n    }\r\n    return string;\r\n}"
}, {
	"Path": "jodd.util.ClassUtil.getComponentType",
	"Comment": "returns single component type for given type and implementation.\tindex is used when type consist of many\tcomponents. if negative, index will be calculated from the end of the\treturned array.returns null if component type\tdoes not exist or if index is out of bounds.",
	"Method": "Class getComponentType(Type type,int index,Class getComponentType,Type type,Class implClass,int index){\r\n    Class[] componentTypes = getComponentTypes(type, implClass);\r\n    if (componentTypes == null) {\r\n        return null;\r\n    }\r\n    if (index < 0) {\r\n        index += componentTypes.length;\r\n    }\r\n    if (index >= componentTypes.length) {\r\n        return null;\r\n    }\r\n    return componentTypes[index];\r\n}"
}, {
	"Path": "jodd.db.oom.sqlgen.chunks.SqlChunk.isEmptyColumnValue",
	"Comment": "returns true if a value is considered empty i.e. not existing.",
	"Method": "boolean isEmptyColumnValue(DbEntityColumnDescriptor dec,Object value){\r\n    if (value == null) {\r\n        return true;\r\n    }\r\n    if (dec.isId() && value instanceof Number) {\r\n        if (((Number) value).intValue() == 0) {\r\n            return true;\r\n        }\r\n    }\r\n    if (dec.getPropertyType().isPrimitive()) {\r\n        int n = ((Number) value).intValue();\r\n        if (n == 0) {\r\n            return true;\r\n        }\r\n    }\r\n    if (value instanceof CharSequence) {\r\n        if (StringUtil.isBlank((CharSequence) value)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.joda.time.Weeks.toStandardHours",
	"Comment": "converts this period in weeks to a period in hours assuming a7 day week and 24 hour day.this method allows you to convert between different types of period.however to achieve this it makes the assumption that all weeks are7 days long and all days are 24 hours long.this is not true when daylight savings is considered and may also notbe true for some unusual chronologies. however, it is includedas it is a useful operation for many applications and business rules.",
	"Method": "Hours toStandardHours(){\r\n    return Hours.hours(FieldUtils.safeMultiply(getValue(), DateTimeConstants.HOURS_PER_WEEK));\r\n}"
}, {
	"Path": "jodd.asm7.FieldVisitor.visitEnd",
	"Comment": "visits the end of the field. this method, which is the last one to be called, is used to informthe visitor that all the annotations and attributes of the field have been visited.",
	"Method": "void visitEnd(){\r\n    if (fv != null) {\r\n        fv.visitEnd();\r\n    }\r\n}"
}, {
	"Path": "jodd.io.findfile.FindFile.nextFile",
	"Comment": "finds the next file. returns founded file that matches search configuration\tor null if no more files can be found.",
	"Method": "File nextFile(File nextFile){\r\n    if (todoFiles == null) {\r\n        init();\r\n    }\r\n    while (true) {\r\n        if (!todoFiles.isEmpty()) {\r\n            FilesIterator filesIterator = todoFiles.getLast();\r\n            File nextFile = filesIterator.next();\r\n            if (nextFile == null) {\r\n                todoFiles.removeLast();\r\n                continue;\r\n            }\r\n            if (nextFile.isDirectory()) {\r\n                if (!walking) {\r\n                    todoFolders.add(nextFile);\r\n                    continue;\r\n                }\r\n                if (recursive) {\r\n                    todoFiles.add(new FilesIterator(nextFile));\r\n                }\r\n                if (includeDirs) {\r\n                    if (acceptFile(nextFile)) {\r\n                        lastFile = nextFile;\r\n                        return nextFile;\r\n                    }\r\n                }\r\n                continue;\r\n            }\r\n            lastFile = nextFile;\r\n            return nextFile;\r\n        }\r\n        File folder;\r\n        boolean initialDir = false;\r\n        if (todoFolders.isEmpty()) {\r\n            if (pathList.isEmpty()) {\r\n                return null;\r\n            }\r\n            folder = pathList.removeFirst();\r\n            rootFile = folder;\r\n            rootPath = rootFile.getAbsolutePath();\r\n            initialDir = true;\r\n        } else {\r\n            folder = todoFolders.removeFirst();\r\n        }\r\n        if ((initialDir) || (recursive)) {\r\n            todoFiles.add(new FilesIterator(folder));\r\n        }\r\n        if ((!initialDir) && (includeDirs)) {\r\n            if (acceptFile(folder)) {\r\n                lastFile = folder;\r\n                return folder;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.video.VideoStream.openCamera",
	"Comment": "opens the camera in a new looper thread so that the preview callback is not called from the main thread\tif an exception is thrown in this looper thread, we bring it back into the main thread.",
	"Method": "void openCamera(){\r\n    final Semaphore lock = new Semaphore(0);\r\n    final RuntimeException[] exception = new RuntimeException[1];\r\n    mCameraThread = new Thread(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            Looper.prepare();\r\n            mCameraLooper = Looper.myLooper();\r\n            try {\r\n                mCamera = Camera.open(mCameraId);\r\n            } catch (RuntimeException e) {\r\n                exception[0] = e;\r\n            } finally {\r\n                lock.release();\r\n                Looper.loop();\r\n            }\r\n        }\r\n    });\r\n    mCameraThread.start();\r\n    lock.acquireUninterruptibly();\r\n    if (exception[0] != null)\r\n        throw new CameraInUseException(exception[0].getMessage());\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.video.VideoStream.openCamera",
	"Comment": "opens the camera in a new looper thread so that the preview callback is not called from the main thread\tif an exception is thrown in this looper thread, we bring it back into the main thread.",
	"Method": "void openCamera(){\r\n    Looper.prepare();\r\n    mCameraLooper = Looper.myLooper();\r\n    try {\r\n        mCamera = Camera.open(mCameraId);\r\n    } catch (RuntimeException e) {\r\n        exception[0] = e;\r\n    } finally {\r\n        lock.release();\r\n        Looper.loop();\r\n    }\r\n}"
}, {
	"Path": "jodd.util.StringUtil.convertCharset",
	"Comment": "converts string charset. if charset names are the same, the same string is returned.",
	"Method": "String convertCharset(String source,String srcCharsetName,String newCharsetName){\r\n    if (srcCharsetName.equals(newCharsetName)) {\r\n        return source;\r\n    }\r\n    return StringUtil.newString(StringUtil.getBytes(source, srcCharsetName), newCharsetName);\r\n}"
}, {
	"Path": "jodd.util.CharUtil.isHexDigit",
	"Comment": "indicates whether the given character is the hexadecimal digit.",
	"Method": "boolean isHexDigit(char c){\r\n    return (c >= '0' && c <= '9') || ((c >= 'a') && (c <= 'f')) || ((c >= 'A') && (c <= 'F'));\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.rtp.RtpSocket.setOutputStream",
	"Comment": "if a tcp is used as the transport protocol for the rtp session,\tthe output stream to which rtp packets will be written to must\tbe specified with this method.",
	"Method": "void setOutputStream(OutputStream outputStream,byte channelIdentifier){\r\n    if (outputStream != null) {\r\n        mTransport = TRANSPORT_TCP;\r\n        mOutputStream = outputStream;\r\n        mTcpHeader[1] = channelIdentifier;\r\n        mReport.setOutputStream(outputStream, (byte) (channelIdentifier + 1));\r\n    }\r\n}"
}, {
	"Path": "jodd.petite.PetiteBeans.beanNames",
	"Comment": "returns set of all bean names. the returned set is a safe\tsnapshot of all bean names.",
	"Method": "Set<String> beanNames(){\r\n    return new HashSet(beans.keySet());\r\n}"
}, {
	"Path": "jodd.props.PropsData.resolveMacros",
	"Comment": "resolves all macros in this props set. called on property lookup.",
	"Method": "String resolveMacros(String value,String profiles){\r\n    StringTemplateParser stringTemplateParser = new StringTemplateParser();\r\n    stringTemplateParser.setResolveEscapes(false);\r\n    if (!ignoreMissingMacros) {\r\n        stringTemplateParser.setReplaceMissingKey(false);\r\n    } else {\r\n        stringTemplateParser.setReplaceMissingKey(true);\r\n        stringTemplateParser.setMissingKeyReplacement(StringPool.EMPTY);\r\n    }\r\n    final Function<String, String> macroResolver = macroName -> {\r\n        String[] lookupProfiles = profiles;\r\n        int leftIndex = macroName.indexOf('<');\r\n        if (leftIndex != -1) {\r\n            int rightIndex = macroName.indexOf('>');\r\n            String profiles1 = macroName.substring(leftIndex + 1, rightIndex);\r\n            macroName = macroName.substring(0, leftIndex).concat(macroName.substring(rightIndex + 1));\r\n            lookupProfiles = StringUtil.splitc(profiles1, ',');\r\n            StringUtil.trimAll(lookupProfiles);\r\n        }\r\n        return lookupValue(macroName, lookupProfiles);\r\n    };\r\n    int loopCount = 0;\r\n    while (loopCount++ < MAX_INNER_MACROS) {\r\n        final String newValue = stringTemplateParser.parse(value, macroResolver);\r\n        if (newValue.equals(value)) {\r\n            break;\r\n        }\r\n        if (skipEmptyProps) {\r\n            if (newValue.length() == 0) {\r\n                return null;\r\n            }\r\n        }\r\n        value = newValue;\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "jodd.cache.TimedCache.pruneCache",
	"Comment": "prunes expired elements from the cache. returns the number of removed objects.",
	"Method": "int pruneCache(){\r\n    int count = 0;\r\n    Iterator<CacheObject<K, V>> values = cacheMap.values().iterator();\r\n    while (values.hasNext()) {\r\n        CacheObject co = values.next();\r\n        if (co.isExpired()) {\r\n            values.remove();\r\n            count++;\r\n        }\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "org.json.JSONArray.optString",
	"Comment": "get the optional string associated with an index. the defaultvalue isreturned if the key is not found.",
	"Method": "String optString(int index,String optString,int index,String defaultValue){\r\n    Object object = this.opt(index);\r\n    return JSONObject.NULL.equals(object) ? defaultValue : object.toString();\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.getValue",
	"Comment": "gets the value of the field at the specified index.this method is required to support the readablepartialinterface. the supported fields are year, monthofday, dayofmonth and millisofday.",
	"Method": "int getValue(int index){\r\n    switch(index) {\r\n        case YEAR:\r\n            return getChronology().year().get(getLocalMillis());\r\n        case MONTH_OF_YEAR:\r\n            return getChronology().monthOfYear().get(getLocalMillis());\r\n        case DAY_OF_MONTH:\r\n            return getChronology().dayOfMonth().get(getLocalMillis());\r\n        case MILLIS_OF_DAY:\r\n            return getChronology().millisOfDay().get(getLocalMillis());\r\n        default:\r\n            throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\r\n    }\r\n}"
}, {
	"Path": "jodd.util.StringUtil.indexOfRegion",
	"Comment": "returns indexes of the first region without escaping character.",
	"Method": "int[] indexOfRegion(String string,String leftBoundary,String rightBoundary,int[] indexOfRegion,String string,String leftBoundary,String rightBoundary,int offset,int[] indexOfRegion,String string,String leftBoundary,String rightBoundary,char escape,int[] indexOfRegion,String string,String leftBoundary,String rightBoundary,char escape,int offset){\r\n    int ndx = offset;\r\n    int[] res = new int[4];\r\n    while (true) {\r\n        ndx = string.indexOf(leftBoundary, ndx);\r\n        if (ndx == -1) {\r\n            return null;\r\n        }\r\n        int leftBoundaryLen = leftBoundary.length();\r\n        if (ndx > 0) {\r\n            if (string.charAt(ndx - 1) == escape) {\r\n                boolean cont = true;\r\n                if (ndx > 1) {\r\n                    if (string.charAt(ndx - 2) == escape) {\r\n                        ndx--;\r\n                        leftBoundaryLen++;\r\n                        cont = false;\r\n                    }\r\n                }\r\n                if (cont) {\r\n                    ndx += leftBoundaryLen;\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n        res[0] = ndx;\r\n        ndx += leftBoundaryLen;\r\n        res[1] = ndx;\r\n        while (true) {\r\n            ndx = string.indexOf(rightBoundary, ndx);\r\n            if (ndx == -1) {\r\n                return null;\r\n            }\r\n            if (ndx > 0) {\r\n                if (string.charAt(ndx - 1) == escape) {\r\n                    ndx += rightBoundary.length();\r\n                    continue;\r\n                }\r\n            }\r\n            res[2] = ndx;\r\n            res[3] = ndx + rightBoundary.length();\r\n            return res;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jodd.servlet.ServletUtil.requireAuthentication",
	"Comment": "sends correct headers to require basic authentication for the given realm.",
	"Method": "void requireAuthentication(HttpServletResponse resp,String realm){\r\n    resp.setHeader(WWW_AUTHENTICATE, \"Basic realm=\\\"\" + realm + '\\\"');\r\n    resp.sendError(HttpServletResponse.SC_UNAUTHORIZED);\r\n}"
}, {
	"Path": "jodd.db.oom.DbEntityDescriptor.getKeyValue",
	"Comment": "returns unique key for this entity. returned key\tis built from entity class and id value.",
	"Method": "String getKeyValue(E object){\r\n    Object idValue = getIdValue(object);\r\n    String idValueString = idValue == null ? StringPool.NULL : idValue.toString();\r\n    return type.getName().concat(StringPool.COLON).concat(idValueString);\r\n}"
}, {
	"Path": "org.joda.time.Weeks.multipliedBy",
	"Comment": "returns a new instance with the weeks multiplied by the specified scalar.this instance is immutable and unaffected by this method call.",
	"Method": "Weeks multipliedBy(int scalar){\r\n    return Weeks.weeks(FieldUtils.safeMultiply(getValue(), scalar));\r\n}"
}, {
	"Path": "jodd.csselly.CSSellyLexer.yypushback",
	"Comment": "pushes the specified amount of characters back into the input stream.they will be read again by then next call of the scanning method",
	"Method": "void yypushback(int number){\r\n    if (number > yylength())\r\n        zzScanError(ZZ_PUSHBACK_2BIG);\r\n    zzMarkedPos -= number;\r\n}"
}, {
	"Path": "jodd.madvoc.component.ActionsManagerCfg.setStrictRoutePaths",
	"Comment": "defines if the router should trim parts of the path to match the action path.",
	"Method": "void setStrictRoutePaths(boolean strictRoutePaths){\r\n    this.strictRoutePaths = strictRoutePaths;\r\n}"
}, {
	"Path": "org.joda.time.field.BaseDateTimeField.roundHalfCeiling",
	"Comment": "round to the nearest whole unit of this field. if the given millisecondvalue is closer to the floor, this function behaves like roundfloor. ifthe millisecond value is closer to the ceiling or is exactly halfway,this function behaves like roundceiling.",
	"Method": "long roundHalfCeiling(long instant){\r\n    long floor = roundFloor(instant);\r\n    long ceiling = roundCeiling(instant);\r\n    long diffFromFloor = instant - floor;\r\n    long diffToCeiling = ceiling - instant;\r\n    if (diffToCeiling <= diffFromFloor) {\r\n        return ceiling;\r\n    } else {\r\n        return floor;\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.base.BaseDuration.toIntervalTo",
	"Comment": "converts this duration to an interval ending at the specified instant.",
	"Method": "Interval toIntervalTo(ReadableInstant endInstant){\r\n    return new Interval(this, endInstant);\r\n}"
}, {
	"Path": "jodd.io.upload.MultipartStreamParser.getParameterValues",
	"Comment": "returns all values all of the values the given request parameter has.",
	"Method": "String[] getParameterValues(String paramName){\r\n    if (requestParameters == null) {\r\n        return null;\r\n    }\r\n    return requestParameters.get(paramName);\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.hw.EncoderDebugger.saveTestResult",
	"Comment": "saves the result of the test in the shared preferences,\twe will run it again only if the sdk has changed on the phone,\tor if this test has been modified.",
	"Method": "void saveTestResult(boolean success){\r\n    String resolution = mWidth + \"x\" + mHeight + \"-\";\r\n    Editor editor = mPreferences.edit();\r\n    editor.putBoolean(PREF_PREFIX + resolution + \"success\", success);\r\n    if (success) {\r\n        editor.putInt(PREF_PREFIX + resolution + \"lastSdk\", Build.VERSION.SDK_INT);\r\n        editor.putInt(PREF_PREFIX + resolution + \"lastVersion\", VERSION);\r\n        editor.putInt(PREF_PREFIX + resolution + \"sliceHeight\", mNV21.getSliceHeigth());\r\n        editor.putInt(PREF_PREFIX + resolution + \"stride\", mNV21.getStride());\r\n        editor.putInt(PREF_PREFIX + resolution + \"padding\", mNV21.getYPadding());\r\n        editor.putBoolean(PREF_PREFIX + resolution + \"planar\", mNV21.getPlanar());\r\n        editor.putBoolean(PREF_PREFIX + resolution + \"reversed\", mNV21.getUVPanesReversed());\r\n        editor.putString(PREF_PREFIX + resolution + \"encoderName\", mEncoderName);\r\n        editor.putInt(PREF_PREFIX + resolution + \"colorFormat\", mEncoderColorFormat);\r\n        editor.putString(PREF_PREFIX + resolution + \"encoderName\", mEncoderName);\r\n        editor.putString(PREF_PREFIX + resolution + \"pps\", mB64PPS);\r\n        editor.putString(PREF_PREFIX + resolution + \"sps\", mB64SPS);\r\n    }\r\n    editor.commit();\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.MediaStream.getDestinationPorts",
	"Comment": "returns a pair of destination ports, the first one is the \tone used for rtp and the second one is used for rtcp.",
	"Method": "int[] getDestinationPorts(){\r\n    return new int[] { mRtpPort, mRtcpPort };\r\n}"
}, {
	"Path": "com.jayway.jsonpath.internal.function.BaseFunctionTest.verifyFunction",
	"Comment": "verify the function returns the correct result based on the input expectedvalue",
	"Method": "void verifyFunction(Configuration conf,String pathExpr,String json,Object expectedValue){\r\n    Object result = using(conf).parse(json).read(pathExpr);\r\n    assertThat(conf.jsonProvider().unwrap(result)).isEqualTo(expectedValue);\r\n}"
}, {
	"Path": "jodd.madvoc.WebApp.bindServletContext",
	"Comment": "defines servlet context. must be called in the web environment.",
	"Method": "WebApp bindServletContext(ServletContext servletContext){\r\n    this.servletContext = servletContext;\r\n    this.servletContext.setAttribute(WEBAPP_ATTR, this);\r\n    return this;\r\n}"
}, {
	"Path": "org.jooq.impl.DefaultExecuteListenerProvider.providers",
	"Comment": "convenience method to construct an array ofdefaultexecutelistenerprovider from an array ofexecutelistener instances.",
	"Method": "ExecuteListenerProvider[] providers(ExecuteListener listeners){\r\n    ExecuteListenerProvider[] result = new ExecuteListenerProvider[listeners.length];\r\n    for (int i = 0; i < listeners.length; i++) result[i] = new DefaultExecuteListenerProvider(listeners[i]);\r\n    return result;\r\n}"
}, {
	"Path": "org.joda.time.DateTime.centuryOfEra",
	"Comment": "get the century of era property which provides access to advanced functionality.",
	"Method": "Property centuryOfEra(){\r\n    return new Property(this, getChronology().centuryOfEra());\r\n}"
}, {
	"Path": "jodd.util.Format.convertTabsToSpaces",
	"Comment": "converts all tabs on a line to spaces according to the provided tab width.\tthis is not a simple tab to spaces replacement, since the resulting\tindentation remains the same.",
	"Method": "String convertTabsToSpaces(String line,int tabWidth){\r\n    int tab_index, tab_size;\r\n    int last_tab_index = 0;\r\n    int added_chars = 0;\r\n    if (tabWidth == 0) {\r\n        return StringUtil.remove(line, '\\t');\r\n    }\r\n    StringBuilder result = new StringBuilder();\r\n    while ((tab_index = line.indexOf('\\t', last_tab_index)) != -1) {\r\n        tab_size = tabWidth - ((tab_index + added_chars) % tabWidth);\r\n        if (tab_size == 0) {\r\n            tab_size = tabWidth;\r\n        }\r\n        added_chars += tab_size - 1;\r\n        result.append(line, last_tab_index, tab_index);\r\n        result.append(StringUtil.repeat(' ', tab_size));\r\n        last_tab_index = tab_index + 1;\r\n    }\r\n    if (last_tab_index == 0) {\r\n        return line;\r\n    }\r\n    result.append(line.substring(last_tab_index));\r\n    return result.toString();\r\n}"
}, {
	"Path": "jodd.petite.BeanData.callDestroyMethods",
	"Comment": "calls destroy methods on given beandata. destroy methods are called\twithout any order.",
	"Method": "void callDestroyMethods(){\r\n    for (final DestroyMethodPoint destroyMethodPoint : beanDefinition.destroyMethodPoints()) {\r\n        try {\r\n            destroyMethodPoint.method.invoke(bean);\r\n        } catch (Exception ex) {\r\n            throw new PetiteException(\"Invalid destroy method: \" + destroyMethodPoint.method, ex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.LocalDate.size",
	"Comment": "gets the number of fields in this partial, which is three.the supported fields are year, monthofyear and dayofmonth.note that all fields from day and above may in fact be queried viaother methods.",
	"Method": "int size(){\r\n    return 3;\r\n}"
}, {
	"Path": "jodd.petite.def.SetInjectionPoint.createSet",
	"Comment": "creates target set for injection. for now it creates hashset,\tbut custom implementation can change this setting.",
	"Method": "Collection<T> createSet(int length){\r\n    return new HashSet(length);\r\n}"
}, {
	"Path": "org.joda.time.DateTimeZone.convertUTCToLocal",
	"Comment": "converts a standard utc instant to a local instant with the samelocal time. this conversion is used before performing a calculationso that the calculation can be done using a simple local zone.",
	"Method": "long convertUTCToLocal(long instantUTC){\r\n    int offset = getOffset(instantUTC);\r\n    long instantLocal = instantUTC + offset;\r\n    if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) {\r\n        throw new ArithmeticException(\"Adding time zone offset caused overflow\");\r\n    }\r\n    return instantLocal;\r\n}"
}, {
	"Path": "org.joda.time.convert.ConverterManager.addIntervalConverter",
	"Comment": "adds a converter to the set of converters. if a matching converter isalready in the set, the given converter replaces it. if the converter isexactly the same as one already in the set, no changes are made.the order in which converters are added is not relevant. the bestconverter is selected by examining the object hierarchy.",
	"Method": "IntervalConverter addIntervalConverter(IntervalConverter converter){\r\n    checkAlterIntervalConverters();\r\n    if (converter == null) {\r\n        return null;\r\n    }\r\n    IntervalConverter[] removed = new IntervalConverter[1];\r\n    iIntervalConverters = iIntervalConverters.add(converter, removed);\r\n    return removed[0];\r\n}"
}, {
	"Path": "jodd.asm7.ByteVector.putByteArray",
	"Comment": "puts an array of bytes into this byte vector. the byte vector is automatically enlarged ifnecessary.",
	"Method": "ByteVector putByteArray(byte[] byteArrayValue,int byteOffset,int byteLength){\r\n    if (length + byteLength > data.length) {\r\n        enlarge(byteLength);\r\n    }\r\n    if (byteArrayValue != null) {\r\n        System.arraycopy(byteArrayValue, byteOffset, data, length, byteLength);\r\n    }\r\n    length += byteLength;\r\n    return this;\r\n}"
}, {
	"Path": "org.joda.time.TimeOfDay.toLocalTime",
	"Comment": "converts this object to a localtime with the same time and chronology.",
	"Method": "LocalTime toLocalTime(){\r\n    return new LocalTime(getHourOfDay(), getMinuteOfHour(), getSecondOfMinute(), getMillisOfSecond(), getChronology());\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.getField",
	"Comment": "gets the field for a specific index in the chronology specified.this method must not use any instance variables.",
	"Method": "DateTimeField getField(int index,Chronology chrono,DateTimeField getField){\r\n    switch(index) {\r\n        case YEAR:\r\n            return chrono.year();\r\n        case MONTH_OF_YEAR:\r\n            return chrono.monthOfYear();\r\n        case DAY_OF_MONTH:\r\n            return chrono.dayOfMonth();\r\n        case MILLIS_OF_DAY:\r\n            return chrono.millisOfDay();\r\n        default:\r\n            throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.convert.ConverterSet.select",
	"Comment": "returns the closest matching converter for the given type, or null ifnone found.",
	"Method": "Converter select(Class<?> type){\r\n    Entry[] entries = iSelectEntries;\r\n    int length = entries.length;\r\n    int index = type == null ? 0 : type.hashCode() & (length - 1);\r\n    Entry e;\r\n    while ((e = entries[index]) != null) {\r\n        if (e.iType == type) {\r\n            return e.iConverter;\r\n        }\r\n        if (++index >= length) {\r\n            index = 0;\r\n        }\r\n    }\r\n    Converter converter = selectSlow(this, type);\r\n    e = new Entry(type, converter);\r\n    entries = (Entry[]) entries.clone();\r\n    entries[index] = e;\r\n    for (int i = 0; i < length; i++) {\r\n        if (entries[i] == null) {\r\n            iSelectEntries = entries;\r\n            return converter;\r\n        }\r\n    }\r\n    int newLength = length << 1;\r\n    Entry[] newEntries = new Entry[newLength];\r\n    for (int i = 0; i < length; i++) {\r\n        e = entries[i];\r\n        type = e.iType;\r\n        index = type == null ? 0 : type.hashCode() & (newLength - 1);\r\n        while (newEntries[index] != null) {\r\n            if (++index >= newLength) {\r\n                index = 0;\r\n            }\r\n        }\r\n        newEntries[index] = e;\r\n    }\r\n    iSelectEntries = newEntries;\r\n    return converter;\r\n}"
}, {
	"Path": "org.joda.time.YearMonthDay.year",
	"Comment": "get the year field property which provides access to advanced functionality.",
	"Method": "Property year(){\r\n    return new Property(this, YEAR);\r\n}"
}, {
	"Path": "org.joda.time.DateTime.withHourOfDay",
	"Comment": "returns a copy of this datetime with the hour of day field updated.datetime is immutable, so there are no set methods.instead, this method returns a new instance with the value ofhour of day changed.",
	"Method": "DateTime withHourOfDay(int hour){\r\n    return withMillis(getChronology().hourOfDay().set(getMillis(), hour));\r\n}"
}, {
	"Path": "org.jooq.tools.jdbc.MockFileDatabase.nullLiteral",
	"Comment": "specify the null literal, i.e. the string that should beparsed as a null reference, rather than as the stringitself.",
	"Method": "MockFileDatabase nullLiteral(String literal){\r\n    this.nullLiteral = literal;\r\n    return this;\r\n}"
}, {
	"Path": "org.joda.time.DateTime.minus",
	"Comment": "returns a copy of this datetime with the specified duration taken away.if the amount is zero or null, then this is returned.this datetime instance is immutable and unaffected by this method call.",
	"Method": "DateTime minus(long duration,DateTime minus,ReadableDuration duration,DateTime minus,ReadablePeriod period){\r\n    return withPeriodAdded(period, -1);\r\n}"
}, {
	"Path": "jodd.madvoc.component.ResultMapper.lookupAlias",
	"Comment": "lookups value as an alias and, if not found, as a default alias.",
	"Method": "String lookupAlias(String alias){\r\n    String value = actionsManager.lookupPathAlias(alias);\r\n    if (value == null) {\r\n        ActionRuntime cfg = actionsManager.lookup(alias);\r\n        if (cfg != null) {\r\n            value = cfg.getActionPath();\r\n        }\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "jodd.cache.LRUCache.pruneCache",
	"Comment": "prune only expired objects, linkedhashmap will take care of lru if needed.",
	"Method": "int pruneCache(){\r\n    if (!isPruneExpiredActive()) {\r\n        return 0;\r\n    }\r\n    int count = 0;\r\n    Iterator<CacheObject<K, V>> values = cacheMap.values().iterator();\r\n    while (values.hasNext()) {\r\n        CacheObject<K, V> co = values.next();\r\n        if (co.isExpired()) {\r\n            values.remove();\r\n            onRemove(co.key, co.cachedObject);\r\n            count++;\r\n        }\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "jodd.io.findfile.FindFile.searchPath",
	"Comment": "specifies the search path. throws an exception if url is invalid.",
	"Method": "FindFile searchPath(File searchPath,FindFile searchPath,File searchPath,FindFile searchPath,String searchPath,FindFile searchPath,URI searchPath,FindFile searchPath,URL searchPath){\r\n    File file = FileUtil.toContainerFile(searchPath);\r\n    if (file == null) {\r\n        throw new FindFileException(\"URL error: \" + searchPath);\r\n    }\r\n    addPath(file);\r\n    return this;\r\n}"
}, {
	"Path": "jodd.http.HttpBrowser.addDefaultHeaders",
	"Comment": "add default headers to the request. if request already has a header set,\tdefault header will be ignored.",
	"Method": "void addDefaultHeaders(HttpRequest httpRequest){\r\n    for (Map.Entry<String, String> entry : defaultHeaders.entries()) {\r\n        String name = entry.getKey();\r\n        if (!httpRequest.headers.contains(name)) {\r\n            httpRequest.headers.add(name, entry.getValue());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jodd.typeconverter.Converter.toDouble",
	"Comment": "converts value to double. returns default value\twhen conversion result is null",
	"Method": "Double toDouble(Object value,Double toDouble,Object value,Double defaultValue){\r\n    final Double result = toDouble(value);\r\n    if (result == null) {\r\n        return defaultValue;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Database.isIncludeRoutines",
	"Comment": "this flag indicates whether routines should be included in output produced by this database",
	"Method": "Boolean isIncludeRoutines(){\r\n    return includeRoutines;\r\n}"
}, {
	"Path": "jodd.servlet.ServletUtil.getAllCookies",
	"Comment": "returns all cookies from client that matches provided name.",
	"Method": "Cookie[] getAllCookies(HttpServletRequest request,String cookieName){\r\n    Cookie[] cookies = request.getCookies();\r\n    if (cookies == null) {\r\n        return null;\r\n    }\r\n    ArrayList<Cookie> list = new ArrayList(cookies.length);\r\n    for (Cookie cookie : cookies) {\r\n        if (cookie.getName().equals(cookieName)) {\r\n            list.add(cookie);\r\n        }\r\n    }\r\n    if (list.isEmpty()) {\r\n        return null;\r\n    }\r\n    return list.toArray(new Cookie[0]);\r\n}"
}, {
	"Path": "org.jooq.conf.Settings.setExecuteWithOptimisticLocking",
	"Comment": "sets the value of the executewithoptimisticlocking property.",
	"Method": "void setExecuteWithOptimisticLocking(Boolean value){\r\n    this.executeWithOptimisticLocking = value;\r\n}"
}, {
	"Path": "jodd.db.oom.naming.TableNamingStrategy.applyToTableName",
	"Comment": "applies table naming strategy to given table name hint.\treturns full table name.",
	"Method": "String applyToTableName(String tableName){\r\n    String entityName = convertTableNameToEntityName(tableName);\r\n    return convertEntityNameToTableName(entityName);\r\n}"
}, {
	"Path": "org.jooq.impl.DSL.timestampSub",
	"Comment": "subtract an interval from a timestamp, given a date part.this translates into any dialect",
	"Method": "Field<Timestamp> timestampSub(Timestamp timestamp,Number interval,Field<Timestamp> timestampSub,Field<Timestamp> timestamp,Field<? extends Number> interval,Field<Timestamp> timestampSub,Timestamp date,Number interval,DatePart datePart,Field<Timestamp> timestampSub,Timestamp date,Field<? extends Number> interval,DatePart datePart,Field<Timestamp> timestampSub,Field<Timestamp> date,Number interval,DatePart datePart,Field<Timestamp> timestampSub,Field<Timestamp> date,Field<? extends Number> interval,DatePart datePart){\r\n    return new DateAdd<Timestamp>(nullSafe(date), nullSafe(interval).neg(), datePart);\r\n}"
}, {
	"Path": "jodd.asm7.ClassVisitor.visitEnd",
	"Comment": "visits the end of the class. this method, which is the last one to be called, is used to informthe visitor that all the fields and methods of the class have been visited.",
	"Method": "void visitEnd(){\r\n    if (cv != null) {\r\n        cv.visitEnd();\r\n    }\r\n}"
}, {
	"Path": "jodd.http.HeadersMultiMap.addHeader",
	"Comment": "adds new header value. if existing value exist, it will be removed\tso the store the new key value.",
	"Method": "void addHeader(String name,String value){\r\n    List<String> valuesList = super.getAll(name);\r\n    if (valuesList.isEmpty()) {\r\n        super.add(name, value);\r\n        return;\r\n    }\r\n    super.remove(name);\r\n    valuesList.add(value);\r\n    super.addAll(name, valuesList);\r\n}"
}, {
	"Path": "jodd.jtx.JtxTransactionManager.totalActiveThreadTransactions",
	"Comment": "returns total number of active transactions associated with current thread.",
	"Method": "int totalActiveThreadTransactions(){\r\n    return totalThreadTransactionsWithStatus(STATUS_ACTIVE);\r\n}"
}, {
	"Path": "org.jooq.tools.reflect.Reflect.wrapper",
	"Comment": "get a wrapper type for a primitive type, or the argument type itself, ifit is not a primitive type.",
	"Method": "Class<?> wrapper(Class<?> type){\r\n    if (type == null) {\r\n        return null;\r\n    } else if (type.isPrimitive()) {\r\n        if (boolean.class == type) {\r\n            return Boolean.class;\r\n        } else if (int.class == type) {\r\n            return Integer.class;\r\n        } else if (long.class == type) {\r\n            return Long.class;\r\n        } else if (short.class == type) {\r\n            return Short.class;\r\n        } else if (byte.class == type) {\r\n            return Byte.class;\r\n        } else if (double.class == type) {\r\n            return Double.class;\r\n        } else if (float.class == type) {\r\n            return Float.class;\r\n        } else if (char.class == type) {\r\n            return Character.class;\r\n        } else if (void.class == type) {\r\n            return Void.class;\r\n        }\r\n    }\r\n    return type;\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Database.isIncludeForeignKeys",
	"Comment": "this flag indicates whether foreign keys should be included in output produced by this database",
	"Method": "Boolean isIncludeForeignKeys(){\r\n    return includeForeignKeys;\r\n}"
}, {
	"Path": "org.joda.time.Period.normalizedStandard",
	"Comment": "normalizes this period using standard rules, assuming a 12 month year,7 day week, 24 hour day, 60 minute hour and 60 second minute.this method allows you to normalize a period.however to achieve this it makes the assumption that all years are12 months, all weeks are 7 days, all days are 24 hours,all hours are 60 minutes and all minutes are 60 seconds. this is nottrue when daylight savings time is considered, and may also not be truefor some chronologies. however, it is included as it is a useful operationfor many applications and business rules.if the period contains years or months, then the months will benormalized to be between 0 and 11. the days field and below will benormalized as necessary, however this will not overflow into the monthsfield. thus a period of 1 year 15 months will normalize to 2 years 3 months.but a period of 1 month 40 days will remain as 1 month 40 days.the result will always have a periodtype of standard, thusdays will be grouped into weeks.",
	"Method": "Period normalizedStandard(Period normalizedStandard,PeriodType type){\r\n    type = DateTimeUtils.getPeriodType(type);\r\n    long millis = getMillis();\r\n    millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\r\n    millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\r\n    millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\r\n    millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\r\n    millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\r\n    Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\r\n    int years = getYears();\r\n    int months = getMonths();\r\n    if (years != 0 || months != 0) {\r\n        long totalMonths = years * 12L + months;\r\n        if (type.isSupported(DurationFieldType.YEARS_TYPE)) {\r\n            int normalizedYears = FieldUtils.safeToInt(totalMonths / 12);\r\n            result = result.withYears(normalizedYears);\r\n            totalMonths = totalMonths - (normalizedYears * 12);\r\n        }\r\n        if (type.isSupported(DurationFieldType.MONTHS_TYPE)) {\r\n            int normalizedMonths = FieldUtils.safeToInt(totalMonths);\r\n            result = result.withMonths(normalizedMonths);\r\n            totalMonths = totalMonths - normalizedMonths;\r\n        }\r\n        if (totalMonths != 0) {\r\n            throw new UnsupportedOperationException(\"Unable to normalize as PeriodType is missing either years or months but period has a month/year amount: \" + toString());\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.jooq.impl.Tools.isJPAAvailable",
	"Comment": "check if jpa classes can be loaded. this is only done once per jvm!",
	"Method": "boolean isJPAAvailable(){\r\n    if (isJPAAvailable == null) {\r\n        synchronized (initLock) {\r\n            if (isJPAAvailable == null) {\r\n                try {\r\n                    Class.forName(Column.class.getName());\r\n                    isJPAAvailable = true;\r\n                } catch (Throwable e) {\r\n                    isJPAAvailable = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return isJPAAvailable;\r\n}"
}, {
	"Path": "org.joda.time.DateMidnight.monthOfYear",
	"Comment": "get the month of year property which provides access to advanced functionality.",
	"Method": "Property monthOfYear(){\r\n    return new Property(this, getChronology().monthOfYear());\r\n}"
}, {
	"Path": "jodd.db.oom.DbMetaUtil.resolveSchemaName",
	"Comment": "resolves schema name from a type. uses default schema name if not specified.",
	"Method": "String resolveSchemaName(Class<?> type,String defaultSchemaName){\r\n    String schemaName = null;\r\n    final DbTable dbTable = type.getAnnotation(DbTable.class);\r\n    if (dbTable != null) {\r\n        schemaName = dbTable.schema().trim();\r\n    }\r\n    if ((schemaName == null) || (schemaName.length() == 0)) {\r\n        schemaName = defaultSchemaName;\r\n    }\r\n    return schemaName;\r\n}"
}, {
	"Path": "org.joda.time.field.BaseDurationField.getValue",
	"Comment": "get the value of this field from the milliseconds, which is approximateif this field is imprecise.",
	"Method": "int getValue(long duration,int getValue,long duration,long instant){\r\n    return FieldUtils.safeToInt(getValueAsLong(duration, instant));\r\n}"
}, {
	"Path": "org.joda.time.base.BaseSingleFieldPeriod.getValue",
	"Comment": "gets the value at the specified index.the only index supported by this period is zero.",
	"Method": "int getValue(int getValue,int index){\r\n    if (index != 0) {\r\n        throw new IndexOutOfBoundsException(String.valueOf(index));\r\n    }\r\n    return getValue();\r\n}"
}, {
	"Path": "org.joda.time.Days.dividedBy",
	"Comment": "returns a new instance with the days divided by the specified divisor.the calculation uses integer division, thus 3 divided by 2 is 1.this instance is immutable and unaffected by this method call.",
	"Method": "Days dividedBy(int divisor){\r\n    if (divisor == 1) {\r\n        return this;\r\n    }\r\n    return Days.days(getValue() / divisor);\r\n}"
}, {
	"Path": "org.joda.time.LocalDate.withWeekyear",
	"Comment": "returns a copy of this date with the weekyear field updated.the weekyear is the year that matches with the weekofweekyear field.in the standard iso8601 week algorithm, the first week of the yearis that in which at least 4 days are in the year. as a result of thisdefinition, day 1 of the first week may be in the previous year.the weekyear allows you to query the effective year for that day.localdate is immutable, so there are no set methods.instead, this method returns a new instance with the value ofweekyear changed.",
	"Method": "LocalDate withWeekyear(int weekyear){\r\n    return withLocalMillis(getChronology().weekyear().set(getLocalMillis(), weekyear));\r\n}"
}, {
	"Path": "jodd.db.oom.sqlgen.chunks.SqlChunk.lookupType",
	"Comment": "lookups for entity name and throws an exception if entity type is invalid.",
	"Method": "DbEntityDescriptor lookupType(Class entity){\r\n    final DbEntityDescriptor ded = dbEntityManager.lookupType(entity);\r\n    if (ded == null) {\r\n        throw new DbSqlBuilderException(\"Invalid or not-persistent entity: \" + entity.getName());\r\n    }\r\n    return ded;\r\n}"
}, {
	"Path": "jodd.madvoc.component.ActionsManager.resolveActionMethod",
	"Comment": "resolves action method for given action class ane method name.",
	"Method": "Method resolveActionMethod(Class<?> actionClass,String methodName){\r\n    MethodDescriptor methodDescriptor = ClassIntrospector.get().lookup(actionClass).getMethodDescriptor(methodName, false);\r\n    if (methodDescriptor == null) {\r\n        throw new MadvocException(\"Public method not found: \" + actionClass.getSimpleName() + \"#\" + methodName);\r\n    }\r\n    return methodDescriptor.getMethod();\r\n}"
}, {
	"Path": "jodd.asm7.TypeReference.getValue",
	"Comment": "returns the int encoded value of this type reference, suitable for use in visit methods relatedto type annotations, like visittypeannotation.",
	"Method": "int getValue(){\r\n    return targetTypeAndInfo;\r\n}"
}, {
	"Path": "jodd.htmlstapler.HtmlStaplerFilter.readFilterConfigParameters",
	"Comment": "reads filter config parameters and set into destination target.",
	"Method": "void readFilterConfigParameters(FilterConfig filterConfig,Object target,String parameters){\r\n    for (String parameter : parameters) {\r\n        String value = filterConfig.getInitParameter(parameter);\r\n        if (value != null) {\r\n            BeanUtil.declared.setProperty(target, parameter, value);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.weekyear",
	"Comment": "get the weekyear property which provides access to advanced functionality.",
	"Method": "Property weekyear(){\r\n    return new Property(this, getChronology().weekyear());\r\n}"
}, {
	"Path": "jodd.io.UnicodeInputStream.init",
	"Comment": "detects and decodes encoding from bom character.\treads ahead four bytes and check for bom marks.\textra bytes are unread back to the stream, so only\tbom bytes are skipped.",
	"Method": "void init(){\r\n    if (initialized) {\r\n        return;\r\n    }\r\n    if (targetEncoding == null) {\r\n        byte[] bom = new byte[MAX_BOM_SIZE];\r\n        int n = internalInputStream.read(bom, 0, bom.length);\r\n        int unread;\r\n        if ((bom[0] == BOM_UTF32_BE[0]) && (bom[1] == BOM_UTF32_BE[1]) && (bom[2] == BOM_UTF32_BE[2]) && (bom[3] == BOM_UTF32_BE[3])) {\r\n            encoding = \"UTF-32BE\";\r\n            unread = n - 4;\r\n        } else if ((bom[0] == BOM_UTF32_LE[0]) && (bom[1] == BOM_UTF32_LE[1]) && (bom[2] == BOM_UTF32_LE[2]) && (bom[3] == BOM_UTF32_LE[3])) {\r\n            encoding = \"UTF-32LE\";\r\n            unread = n - 4;\r\n        } else if ((bom[0] == BOM_UTF8[0]) && (bom[1] == BOM_UTF8[1]) && (bom[2] == BOM_UTF8[2])) {\r\n            encoding = \"UTF-8\";\r\n            unread = n - 3;\r\n        } else if ((bom[0] == BOM_UTF16_BE[0]) && (bom[1] == BOM_UTF16_BE[1])) {\r\n            encoding = \"UTF-16BE\";\r\n            unread = n - 2;\r\n        } else if ((bom[0] == BOM_UTF16_LE[0]) && (bom[1] == BOM_UTF16_LE[1])) {\r\n            encoding = \"UTF-16LE\";\r\n            unread = n - 2;\r\n        } else {\r\n            unread = n;\r\n        }\r\n        BOMSize = MAX_BOM_SIZE - unread;\r\n        if (unread > 0) {\r\n            internalInputStream.unread(bom, (n - unread), unread);\r\n        }\r\n    } else {\r\n        byte[] bom = null;\r\n        if (targetEncoding.equals(\"UTF-8\")) {\r\n            bom = BOM_UTF8;\r\n        } else if (targetEncoding.equals(\"UTF-16LE\")) {\r\n            bom = BOM_UTF16_LE;\r\n        } else if (targetEncoding.equals(\"UTF-16BE\") || targetEncoding.equals(\"UTF-16\")) {\r\n            bom = BOM_UTF16_BE;\r\n        } else if (targetEncoding.equals(\"UTF-32LE\")) {\r\n            bom = BOM_UTF32_LE;\r\n        } else if (targetEncoding.equals(\"UTF-32BE\") || targetEncoding.equals(\"UTF-32\")) {\r\n            bom = BOM_UTF32_BE;\r\n        } else {\r\n        }\r\n        if (bom != null) {\r\n            byte[] fileBom = new byte[bom.length];\r\n            int n = internalInputStream.read(fileBom, 0, bom.length);\r\n            boolean bomDetected = true;\r\n            for (int i = 0; i < n; i++) {\r\n                if (fileBom[i] != bom[i]) {\r\n                    bomDetected = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (!bomDetected) {\r\n                internalInputStream.unread(fileBom, 0, fileBom.length);\r\n            }\r\n        }\r\n    }\r\n    initialized = true;\r\n}"
}, {
	"Path": "jodd.util.ResourceBundleMessageResolver.findDefaultMessage",
	"Comment": "finds message in default bundles only, starting from fallback bundlename.",
	"Method": "String findDefaultMessage(Locale locale,String key){\r\n    String indexedKey = calcIndexKey(key);\r\n    String msg = getMessage(fallbackBundlename, locale, key, indexedKey);\r\n    if (msg != null) {\r\n        return msg;\r\n    }\r\n    for (String bname : defaultBundles) {\r\n        msg = getMessage(bname, locale, key, indexedKey);\r\n        if (msg != null) {\r\n            return msg;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.joda.time.DateTime.toTimeOfDay",
	"Comment": "converts this object to a timeofday using thesame millis and chronology.",
	"Method": "TimeOfDay toTimeOfDay(){\r\n    return new TimeOfDay(getMillis(), getChronology());\r\n}"
}, {
	"Path": "jodd.madvoc.ActionRequest.setNextActionPath",
	"Comment": "specifies the next action path, that will be chained to current action request.",
	"Method": "void setNextActionPath(String nextActionPath){\r\n    this.nextActionPath = nextActionPath;\r\n}"
}, {
	"Path": "jodd.http.Cookie.getComment",
	"Comment": "returns the comment describing the purpose of this cookie, or\tnull if the cookie has no comment.",
	"Method": "String getComment(){\r\n    return comment;\r\n}"
}, {
	"Path": "jodd.util.CharUtil.findFirstDiff",
	"Comment": "finds index of the first character in given array the differs from the\tgiven set of characters.",
	"Method": "int findFirstDiff(char[] source,int index,char[] match,int findFirstDiff,char[] source,int index,char match){\r\n    for (int i = index; i < source.length; i++) {\r\n        if (source[i] != match) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "jodd.util.StringUtil.uncapitalize",
	"Comment": "uncapitalizes a string, changing the first letter to\tlower case. no other letters are changed.",
	"Method": "String uncapitalize(String str){\r\n    return changeFirstCharacterCase(false, str);\r\n}"
}, {
	"Path": "jodd.htmlstapler.HtmlStaplerBundlesManager.onResourceContent",
	"Comment": "invoked before resource content is stored in the bundle.\tmay be us used for additional resource processing, such as\tcompressing, cleaning etc. by default it just returns unmodified\tcontent.",
	"Method": "String onResourceContent(String content){\r\n    return content;\r\n}"
}, {
	"Path": "jodd.io.upload.MultipartStreamParser.getParameterNames",
	"Comment": "returns the names of the parameters contained in this request.",
	"Method": "Set<String> getParameterNames(){\r\n    if (requestParameters == null) {\r\n        return Collections.emptySet();\r\n    }\r\n    return requestParameters.keySet();\r\n}"
}, {
	"Path": "org.joda.time.LocalTime.minuteOfHour",
	"Comment": "get the minute of hour field property which provides access to advanced functionality.",
	"Method": "Property minuteOfHour(){\r\n    return new Property(this, getChronology().minuteOfHour());\r\n}"
}, {
	"Path": "jodd.io.findfile.ClassScanner.ignoreException",
	"Comment": "sets if exceptions during scanning process should be ignored or not.",
	"Method": "ClassScanner ignoreException(boolean ignoreException){\r\n    this.ignoreException = ignoreException;\r\n    return this;\r\n}"
}, {
	"Path": "org.joda.time.MutablePeriod.addMillis",
	"Comment": "adds the specified millis to the number of millis in the period.",
	"Method": "void addMillis(int millis){\r\n    super.addField(DurationFieldType.millis(), millis);\r\n}"
}, {
	"Path": "org.jooq.codegen.GenerationUtil.getArrayBaseType",
	"Comment": "gets the base type for an array type, depending on the rdbms dialect",
	"Method": "Name getArrayBaseType(SQLDialect dialect,String t,Name u){\r\n    switch(dialect.family()) {\r\n        case POSTGRES:\r\n            {\r\n                if (u != null && u.last().startsWith(\"_\")) {\r\n                    String[] name = u.getName();\r\n                    name[name.length - 1] = name[name.length - 1].substring(1);\r\n                    return name(name);\r\n                } else {\r\n                    return u;\r\n                }\r\n            }\r\n        case H2:\r\n            {\r\n                return name(H2DataType.OTHER.getTypeName());\r\n            }\r\n        case HSQLDB:\r\n            {\r\n                if (\"ARRAY\".equalsIgnoreCase(t)) {\r\n                    return name(\"OTHER\");\r\n                } else {\r\n                    return name(t.replace(\" ARRAY\", \"\"));\r\n                }\r\n            }\r\n    }\r\n    throw new SQLDialectNotSupportedException(\"getArrayBaseType() is not supported for dialect \" + dialect);\r\n}"
}, {
	"Path": "jodd.util.PropertiesUtil.getProperty",
	"Comment": "returns string property from a map. if key is not found, or if value is not a string, returns null.\tmimics property.getproperty but on map.",
	"Method": "String getProperty(Map map,String key,String getProperty,Map map,String key,String defaultValue){\r\n    Object val = map.get(key);\r\n    return (val instanceof String) ? (String) val : defaultValue;\r\n}"
}, {
	"Path": "jodd.asm7.ConstantDynamic.getBootstrapMethodArgumentCount",
	"Comment": "returns the number of arguments passed to the bootstrap method, in order to compute the valueof this constant.",
	"Method": "int getBootstrapMethodArgumentCount(){\r\n    return bootstrapMethodArguments.length;\r\n}"
}, {
	"Path": "jodd.time.JulianDate.set",
	"Comment": "sets integer and fractional part with normalization.\tnormalization means that if double is out of range,\tvalues will be correctly fixed.",
	"Method": "void set(int i,double f){\r\n    integer = i;\r\n    int fi = (int) f;\r\n    f -= fi;\r\n    integer += fi;\r\n    if (f < 0) {\r\n        f += 1;\r\n        integer--;\r\n    }\r\n    this.fraction = f;\r\n}"
}, {
	"Path": "org.joda.time.tz.ZoneInfoProvider.getZone",
	"Comment": "if an error is thrown while loading zone data, the exception is loggedto system error and null is returned for this and all future requests.",
	"Method": "DateTimeZone getZone(String id){\r\n    if (id == null) {\r\n        return null;\r\n    }\r\n    Object obj = iZoneInfoMap.get(id);\r\n    if (obj == null) {\r\n        return null;\r\n    }\r\n    if (obj instanceof SoftReference<?>) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj;\r\n        DateTimeZone tz = ref.get();\r\n        if (tz != null) {\r\n            return tz;\r\n        }\r\n        return loadZoneData(id);\r\n    } else if (id.equals(obj)) {\r\n        return loadZoneData(id);\r\n    }\r\n    return getZone((String) obj);\r\n}"
}, {
	"Path": "jodd.util.ClassUtil.forceAccess",
	"Comment": "suppress access check against a reflection object. securityexception is silently ignored.\tchecks first if the object is already accessible.",
	"Method": "void forceAccess(AccessibleObject accObject){\r\n    try {\r\n        if (System.getSecurityManager() == null)\r\n            accObject.setAccessible(true);\r\n        else {\r\n            AccessController.doPrivileged((PrivilegedAction) () -> {\r\n                accObject.setAccessible(true);\r\n                return null;\r\n            });\r\n        }\r\n    } catch (SecurityException sex) {\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.Partial.isMatch",
	"Comment": "does this partial match the specified partial.a match occurs when all the fields of this partial are the same as thecorresponding fields on the specified partial.",
	"Method": "boolean isMatch(ReadableInstant instant,boolean isMatch,ReadablePartial partial){\r\n    if (partial == null) {\r\n        throw new IllegalArgumentException(\"The partial must not be null\");\r\n    }\r\n    for (int i = 0; i < iTypes.length; i++) {\r\n        int value = partial.get(iTypes[i]);\r\n        if (value != iValues[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Generate.isCommentsOnParameters",
	"Comment": "turn off generation of all sql comments as javadoc on all parameters.",
	"Method": "Boolean isCommentsOnParameters(){\r\n    return commentsOnParameters;\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Generate.isCommentsOnLinks",
	"Comment": "turn off generation of all sql comments as javadoc on all links.",
	"Method": "Boolean isCommentsOnLinks(){\r\n    return commentsOnLinks;\r\n}"
}, {
	"Path": "jodd.asm7.Frame.getAbstractTypeFromApiFormat",
	"Comment": "returns the abstract type corresponding to the given public api frame element type.",
	"Method": "int getAbstractTypeFromApiFormat(SymbolTable symbolTable,Object type){\r\n    if (type instanceof Integer) {\r\n        return CONSTANT_KIND | ((Integer) type).intValue();\r\n    } else if (type instanceof String) {\r\n        String descriptor = Type.getObjectType((String) type).getDescriptor();\r\n        return getAbstractTypeFromDescriptor(symbolTable, descriptor, 0);\r\n    } else {\r\n        return UNINITIALIZED_KIND | symbolTable.addUninitializedType(\"\", ((Label) type).bytecodeOffset);\r\n    }\r\n}"
}, {
	"Path": "jodd.servlet.DispatcherUtil.forwardAbsolute",
	"Comment": "forward to page path relative to the root of the servletcontext.",
	"Method": "boolean forwardAbsolute(HttpServletRequest request,ServletResponse response,String page,boolean forwardAbsolute,ServletContext context,ServletRequest request,ServletResponse response,String resource){\r\n    RequestDispatcher dispatcher = context.getRequestDispatcher(resource);\r\n    if (dispatcher != null) {\r\n        dispatcher.forward(request, response);\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.joda.time.Seconds.toStandardMinutes",
	"Comment": "converts this period in seconds to a period in minutes assuming a60 second minute.this method allows you to convert between different types of period.however to achieve this it makes the assumption that all minutes are60 seconds long.this may not be true for some unusual chronologies. however, it is includedas it is a useful operation for many applications and business rules.",
	"Method": "Minutes toStandardMinutes(){\r\n    return Minutes.minutes(getValue() / DateTimeConstants.SECONDS_PER_MINUTE);\r\n}"
}, {
	"Path": "jodd.jtx.JtxTransactionManager.setIgnoreScope",
	"Comment": "sets if transaction scope should be ignored. if ignored,\tthere may be more then one transaction in one scope.\tscopes may be ignored if set to null",
	"Method": "void setIgnoreScope(boolean ignoreScope){\r\n    this.ignoreScope = ignoreScope;\r\n}"
}, {
	"Path": "jodd.joy.page.PageData.getLastIndex",
	"Comment": "returns index of last item of page.\ton every page but last, last index equals to first index plus page size.",
	"Method": "int getLastIndex(){\r\n    return lastIndex;\r\n}"
}, {
	"Path": "jodd.jerry.Jerry.get",
	"Comment": "returns node at given index. returns null\tif index is out of bounds.",
	"Method": "Node get(int index,Node[] get){\r\n    return nodes;\r\n}"
}, {
	"Path": "org.joda.time.TestDateTimeComparator.testWOYY",
	"Comment": "test unequal comparisons with year given the week comparators.",
	"Method": "void testWOYY(){\r\n    aDateTime = getADate(\"1998-12-31T23:59:59\");\r\n    bDateTime = getADate(\"1999-01-01T00:00:00\");\r\n    assertEquals(\"YOYYZ\", 0, cWeekyear.compare(aDateTime, bDateTime));\r\n    bDateTime = getADate(\"1999-01-04T00:00:00\");\r\n    assertEquals(\"YOYYM1\", -1, cWeekyear.compare(aDateTime, bDateTime));\r\n    assertEquals(\"YOYYP1\", 1, cWeekyear.compare(bDateTime, aDateTime));\r\n}"
}, {
	"Path": "jodd.typeconverter.Converter.toByteValue",
	"Comment": "converts value to byte. returns default value\twhen conversion result is null.",
	"Method": "byte toByteValue(Object value,byte defaultValue,byte toByteValue,Object value){\r\n    return toByteValue(value, (byte) 0);\r\n}"
}, {
	"Path": "jodd.asm7.Type.getReturnType",
	"Comment": "returns the return type of methods of this type. this method should only be used for methodtypes.",
	"Method": "Type getReturnType(Type getReturnType,String methodDescriptor,Type getReturnType,Method method){\r\n    return getType(method.getReturnType());\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractDuration.isLongerThan",
	"Comment": "is the length of this duration longer than the duration passed in.the comparison takes into account the sign.as such, a duration of 5 seconds is longer than a duration of minus 7 seconds.",
	"Method": "boolean isLongerThan(ReadableDuration duration){\r\n    if (duration == null) {\r\n        duration = Duration.ZERO;\r\n    }\r\n    return compareTo(duration) > 0;\r\n}"
}, {
	"Path": "jodd.madvoc.component.ActionMethodParser.createActionRuntime",
	"Comment": "creates new instance of action runtime configuration.\tinitialize caches.",
	"Method": "ActionRuntime createActionRuntime(ActionHandler actionHandler,Class actionClass,Method actionClassMethod,Class<? extends ActionResult> actionResult,Class<? extends ActionResult> defaultActionResult,ActionFilter[] filters,ActionInterceptor[] interceptors,ActionDefinition actionDefinition,boolean async,boolean auth){\r\n    if (actionHandler != null) {\r\n        return new ActionRuntime(actionHandler, actionClass, actionClassMethod, filters, interceptors, actionDefinition, NoneActionResult.class, NoneActionResult.class, async, auth, null, null);\r\n    }\r\n    final ScopeData scopeData = scopeDataInspector.inspectClassScopes(actionClass);\r\n    final Class[] paramTypes = actionClassMethod.getParameterTypes();\r\n    final MethodParam[] params = new MethodParam[paramTypes.length];\r\n    final Annotation[][] paramAnns = actionClassMethod.getParameterAnnotations();\r\n    String[] methodParamNames = null;\r\n    for (int ndx = 0; ndx < paramTypes.length; ndx++) {\r\n        Class paramType = paramTypes[ndx];\r\n        if (methodParamNames == null) {\r\n            methodParamNames = actionMethodParamNameResolver.resolveParamNames(actionClassMethod);\r\n        }\r\n        final String paramName = methodParamNames[ndx];\r\n        final Annotation[] parameterAnnotations = paramAnns[ndx];\r\n        final ScopeData paramsScopeData = scopeDataInspector.inspectMethodParameterScopes(paramName, paramType, parameterAnnotations);\r\n        MapperFunction mapperFunction = null;\r\n        for (final Annotation annotation : parameterAnnotations) {\r\n            if (annotation instanceof Mapper) {\r\n                mapperFunction = MapperFunctionInstances.get().lookup(((Mapper) annotation).value());\r\n                break;\r\n            }\r\n        }\r\n        params[ndx] = new MethodParam(paramTypes[ndx], paramName, scopeDataInspector.detectAnnotationType(parameterAnnotations), paramsScopeData, mapperFunction);\r\n    }\r\n    return new ActionRuntime(null, actionClass, actionClassMethod, filters, interceptors, actionDefinition, actionResult, defaultActionResult, async, auth, scopeData, params);\r\n}"
}, {
	"Path": "org.joda.time.PeriodType.withSecondsRemoved",
	"Comment": "returns a version of this periodtype instance that does not support seconds.",
	"Method": "PeriodType withSecondsRemoved(){\r\n    return withFieldRemoved(6, \"NoSeconds\");\r\n}"
}, {
	"Path": "jodd.jtx.JtxTransaction.isActive",
	"Comment": "returns true if transaction is active.\tthis status changes during the transaction flow.",
	"Method": "boolean isActive(){\r\n    return status == STATUS_ACTIVE;\r\n}"
}, {
	"Path": "jodd.jerry.Jerry.replaceWith",
	"Comment": "replace each element in the set of matched elements with the provided \tnew content and return the set of elements that was removed.",
	"Method": "Jerry replaceWith(String html){\r\n    if (html == null) {\r\n        html = StringPool.EMPTY;\r\n    }\r\n    final Document doc = builder.parse(html);\r\n    if (nodes.length == 0) {\r\n        return this;\r\n    }\r\n    for (Node node : nodes) {\r\n        Node parent = node.getParentNode();\r\n        if (parent == null) {\r\n            continue;\r\n        }\r\n        Document workingDoc = doc.clone();\r\n        int index = node.getSiblingIndex();\r\n        parent.insertChild(workingDoc.getFirstChild(), index);\r\n        node.detachFromParent();\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.joda.time.base.BasePeriod.toDurationTo",
	"Comment": "gets the total millisecond duration of this period relative to anend instant.this method subtracts the period from the specified instant in orderto calculate the duration.an instant must be supplied as the duration of a period varies.for example, a period of 1 month could vary between the equivalent of28 and 31 days in milliseconds due to different length months.similarly, a day can vary at daylight savings cutover, typically between23 and 25 hours.",
	"Method": "Duration toDurationTo(ReadableInstant endInstant){\r\n    long endMillis = DateTimeUtils.getInstantMillis(endInstant);\r\n    Chronology chrono = DateTimeUtils.getInstantChronology(endInstant);\r\n    long startMillis = chrono.add(this, endMillis, -1);\r\n    return new Duration(startMillis, endMillis);\r\n}"
}, {
	"Path": "org.joda.time.format.DateTimeFormatterBuilder.canBuildFormatter",
	"Comment": "returns true if toformatter can be called without throwing anunsupportedoperationexception.",
	"Method": "boolean canBuildFormatter(){\r\n    return isFormatter(getFormatter());\r\n}"
}, {
	"Path": "jodd.asm7.ModuleWriter.putAttributes",
	"Comment": "puts the module, modulepackages and modulemainclass attributes generated by this modulewriterin the given bytevector.",
	"Method": "void putAttributes(ByteVector output){\r\n    int moduleAttributeLength = 16 + requires.length + exports.length + opens.length + usesIndex.length + provides.length;\r\n    output.putShort(symbolTable.addConstantUtf8(Constants.MODULE)).putInt(moduleAttributeLength).putShort(moduleNameIndex).putShort(moduleFlags).putShort(moduleVersionIndex).putShort(requiresCount).putByteArray(requires.data, 0, requires.length).putShort(exportsCount).putByteArray(exports.data, 0, exports.length).putShort(opensCount).putByteArray(opens.data, 0, opens.length).putShort(usesCount).putByteArray(usesIndex.data, 0, usesIndex.length).putShort(providesCount).putByteArray(provides.data, 0, provides.length);\r\n    if (packageCount > 0) {\r\n        output.putShort(symbolTable.addConstantUtf8(Constants.MODULE_PACKAGES)).putInt(2 + packageIndex.length).putShort(packageCount).putByteArray(packageIndex.data, 0, packageIndex.length);\r\n    }\r\n    if (mainClassIndex > 0) {\r\n        output.putShort(symbolTable.addConstantUtf8(Constants.MODULE_MAIN_CLASS)).putInt(2).putShort(mainClassIndex);\r\n    }\r\n}"
}, {
	"Path": "jodd.io.upload.impl.AdaptiveFileUploadFactory.setMemoryThreshold",
	"Comment": "specifies per file memory limit for keeping uploaded files in the memory.",
	"Method": "AdaptiveFileUploadFactory setMemoryThreshold(int memoryThreshold){\r\n    if (memoryThreshold >= 0) {\r\n        this.memoryThreshold = memoryThreshold;\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "jodd.jtx.JtxTransactionManager.totalTransactions",
	"Comment": "returns total number of transactions issued by this transaction manager.",
	"Method": "int totalTransactions(){\r\n    return totalTransactions;\r\n}"
}, {
	"Path": "jodd.asm7.TypeReference.newFormalParameterReference",
	"Comment": "returns a reference to the type of a formal parameter of a method.",
	"Method": "TypeReference newFormalParameterReference(int paramIndex){\r\n    return new TypeReference((METHOD_FORMAL_PARAMETER << 24) | (paramIndex << 16));\r\n}"
}, {
	"Path": "jodd.servlet.wrapper.Buffer.toCharArray",
	"Comment": "returns buffered writer content as char array.\treturns null if writer is not used.",
	"Method": "char[] toCharArray(){\r\n    if (bufferedWriter != null) {\r\n        return bufferedWriter.toCharArray();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.joda.time.LocalTime.fromMillisOfDay",
	"Comment": "constructs a localtime from the specified millis of day using thespecified chronology.the millisofday value may exceed the number of millis in one day,but additional days will be ignored.this method uses the utc time zone internally.",
	"Method": "LocalTime fromMillisOfDay(long millisOfDay,LocalTime fromMillisOfDay,long millisOfDay,Chronology chrono){\r\n    chrono = DateTimeUtils.getChronology(chrono).withUTC();\r\n    return new LocalTime(millisOfDay, chrono);\r\n}"
}, {
	"Path": "org.json.JSONArray.optLong",
	"Comment": "get the optional long value associated with an index. the defaultvalue isreturned if there is no value for the index, or if the value is not anumber and cannot be converted to a number.",
	"Method": "long optLong(int index,long optLong,int index,long defaultValue){\r\n    final Number val = this.optNumber(index, null);\r\n    if (val == null) {\r\n        return defaultValue;\r\n    }\r\n    return val.longValue();\r\n}"
}, {
	"Path": "jodd.db.DbQueryBase.checkInitialized",
	"Comment": "checks if query is initialized and throws an exception if it is not.",
	"Method": "void checkInitialized(){\r\n    if (queryState != INITIALIZED) {\r\n        final String message = (queryState == CREATED ? \"Query is created but not yet initialized.\" : \"Query is closed.\");\r\n        throw new DbSqlException(this, message + \" Operation may be performed only on initialized queries.\");\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.chrono.IslamicChronology.getInstanceUTC",
	"Comment": "gets an instance of the islamicchronology.the time zone of the returned instance is utc.",
	"Method": "IslamicChronology getInstanceUTC(){\r\n    return INSTANCE_UTC;\r\n}"
}, {
	"Path": "jodd.typeconverter.Converter.toLongValue",
	"Comment": "converts value to long. returns default value\twhen conversion result is null.",
	"Method": "long toLongValue(Object value,long defaultValue,long toLongValue,Object value){\r\n    return toLongValue(value, 0);\r\n}"
}, {
	"Path": "jodd.db.oom.DbEntityDescriptor.getIdPropertyName",
	"Comment": "returns the first property name of column marked as identity.\tthrows an exception if table has composite primary key.",
	"Method": "String getIdPropertyName(){\r\n    ensureSingleIdColumn();\r\n    return idColumnDescriptors[0].getPropertyName();\r\n}"
}, {
	"Path": "jodd.lagarto.dom.NodeSelector.selectAndAdd",
	"Comment": "selects single node for single selector and appends it to the results.",
	"Method": "void selectAndAdd(Node node,CssSelector cssSelector,List<Node> result){\r\n    if (node.getNodeType() != Node.NodeType.ELEMENT) {\r\n        return;\r\n    }\r\n    boolean matched = cssSelector.accept(node);\r\n    if (matched) {\r\n        if (result.contains(node)) {\r\n            return;\r\n        }\r\n        result.add(node);\r\n    }\r\n}"
}, {
	"Path": "jodd.vtor.Vtor.validate",
	"Comment": "performs validation of provided validation context and appends violations.",
	"Method": "List<Violation> validate(Object target,List<Violation> validate,ValidationContext vctx,Object target,List<Violation> validate,ValidationContext ctx,Object target,String targetName){\r\n    for (Map.Entry<String, List<Check>> entry : ctx.map.entrySet()) {\r\n        String name = entry.getKey();\r\n        Object value = BeanUtil.declaredSilent.getProperty(target, name);\r\n        String valueName = targetName != null ? (targetName + '.' + name) : name;\r\n        ValidationConstraintContext vcc = new ValidationConstraintContext(this, target, valueName);\r\n        for (Check check : entry.getValue()) {\r\n            String[] checkProfiles = check.getProfiles();\r\n            if (!matchProfiles(checkProfiles)) {\r\n                continue;\r\n            }\r\n            if (check.getSeverity() < severity) {\r\n                continue;\r\n            }\r\n            ValidationConstraint constraint = check.getConstraint();\r\n            if (!constraint.isValid(vcc, value)) {\r\n                addViolation(new Violation(valueName, target, value, check));\r\n            }\r\n        }\r\n    }\r\n    return getViolations();\r\n}"
}, {
	"Path": "org.json.JSONArray.optJSONObject",
	"Comment": "get the optional jsonobject associated with an index. null is returned ifthe key is not found, or null if the index has no value, or if the valueis not a jsonobject.",
	"Method": "JSONObject optJSONObject(int index){\r\n    Object o = this.opt(index);\r\n    return o instanceof JSONObject ? (JSONObject) o : null;\r\n}"
}, {
	"Path": "jodd.mail.CommonEmail.from",
	"Comment": "sets the from address by providing personal name and address.",
	"Method": "T from(EmailAddress from,T from,Address from,T from,String from,T from,String personalName,String from,EmailAddress from){\r\n    return from;\r\n}"
}, {
	"Path": "jodd.jerry.Jerry.next",
	"Comment": "gets the immediately following sibling of each element in the\tset of matched elements.",
	"Method": "Jerry next(){\r\n    List<Node> result = new NodeList(nodes.length);\r\n    if (nodes.length > 0) {\r\n        for (Node node : nodes) {\r\n            result.add(node.getNextSiblingElement());\r\n        }\r\n    }\r\n    return new Jerry(this, result);\r\n}"
}, {
	"Path": "org.joda.time.Period.plusYears",
	"Comment": "returns a new period with the specified number of years added.this period instance is immutable and unaffected by this method call.",
	"Method": "Period plusYears(int years){\r\n    if (years == 0) {\r\n        return this;\r\n    }\r\n    int[] values = getValues();\r\n    getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, years);\r\n    return new Period(values, getPeriodType());\r\n}"
}, {
	"Path": "jodd.exception.ExceptionUtil.findCause",
	"Comment": "finds throwing cause in exception stack. returns throwable object if cause class is matched.\totherwise, returns null.",
	"Method": "T findCause(Throwable throwable,Class<T> cause){\r\n    while (throwable != null) {\r\n        if (throwable.getClass().equals(cause)) {\r\n            return (T) throwable;\r\n        }\r\n        throwable = throwable.getCause();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "jodd.typeconverter.Converter.toCharValue",
	"Comment": "converts value to char. returns default value\twhen conversion result is null.",
	"Method": "char toCharValue(Object value,char defaultValue,char toCharValue,Object value){\r\n    return toCharValue(value, (char) 0);\r\n}"
}, {
	"Path": "jodd.http.HttpBase.mediaType",
	"Comment": "defines just content media type.\tsetting this value to null will\tnot have any effects.",
	"Method": "String mediaType(T mediaType,String mediaType){\r\n    contentType(mediaType, null);\r\n    return _this();\r\n}"
}, {
	"Path": "org.jooq.codegen.JavaGenerator.generateUDTPojoClassJavadoc",
	"Comment": "subclasses may override this method to provide their own javadoc.",
	"Method": "void generateUDTPojoClassJavadoc(UDTDefinition udt,JavaWriter out){\r\n    if (generateCommentsOnUDTs())\r\n        printClassJavadoc(out, udt);\r\n    else\r\n        printClassJavadoc(out, \"The udt <code>\" + udt.getQualifiedInputName() + \"<\/code>.\");\r\n}"
}, {
	"Path": "jodd.asm7.ModuleWriter.computeAttributesSize",
	"Comment": "returns the size of the module, modulepackages and modulemainclass attributes generated by thismodulewriter. also add the names of these attributes in the constant pool.",
	"Method": "int computeAttributesSize(){\r\n    symbolTable.addConstantUtf8(Constants.MODULE);\r\n    int size = 22 + requires.length + exports.length + opens.length + usesIndex.length + provides.length;\r\n    if (packageCount > 0) {\r\n        symbolTable.addConstantUtf8(Constants.MODULE_PACKAGES);\r\n        size += 8 + packageIndex.length;\r\n    }\r\n    if (mainClassIndex > 0) {\r\n        symbolTable.addConstantUtf8(Constants.MODULE_MAIN_CLASS);\r\n        size += 8;\r\n    }\r\n    return size;\r\n}"
}, {
	"Path": "org.joda.time.Period.minusHours",
	"Comment": "returns a new period minus the specified number of hours taken away.this period instance is immutable and unaffected by this method call.",
	"Method": "Period minusHours(int hours){\r\n    return plusHours(-hours);\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.withHourOfDay",
	"Comment": "returns a copy of this datetime with the hour of day field updated.localdatetime is immutable, so there are no set methods.instead, this method returns a new instance with the value ofhour of day changed.",
	"Method": "LocalDateTime withHourOfDay(int hour){\r\n    return withLocalMillis(getChronology().hourOfDay().set(getLocalMillis(), hour));\r\n}"
}, {
	"Path": "org.joda.time.field.PreciseDurationField.getUnitMillis",
	"Comment": "returns the amount of milliseconds per unit value of this field.",
	"Method": "long getUnitMillis(){\r\n    return iUnitMillis;\r\n}"
}, {
	"Path": "jodd.http.HttpTunnel.stop",
	"Comment": "stops the tunnel, shutdowns the thread pool and closes server socket.",
	"Method": "void stop(){\r\n    running = false;\r\n    executorService.shutdown();\r\n    try {\r\n        serverSocket.close();\r\n    } catch (IOException ignore) {\r\n    }\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.Session.setOrigin",
	"Comment": "the origin address of the session.\tit appears in the session description.",
	"Method": "void setOrigin(String origin){\r\n    mOrigin = origin;\r\n}"
}, {
	"Path": "org.joda.time.DateMidnight.toYearMonthDay",
	"Comment": "converts this object to a yearmonthday using thesame date and chronology.",
	"Method": "YearMonthDay toYearMonthDay(){\r\n    return new YearMonthDay(getMillis(), getChronology());\r\n}"
}, {
	"Path": "jodd.madvoc.interceptor.EchoInterceptor.printBefore",
	"Comment": "prints out the message. user can override this method and modify the way\tthe message is printed.",
	"Method": "void printBefore(ActionRequest request){\r\n    StringBuilder message = new StringBuilder(prefixIn);\r\n    message.append(request.getActionPath()).append(\"   [\").append(request.getActionRuntime().createActionString()).append(']');\r\n    out(message.toString());\r\n}"
}, {
	"Path": "org.joda.time.Minutes.dividedBy",
	"Comment": "returns a new instance with the minutes divided by the specified divisor.the calculation uses integer division, thus 3 divided by 2 is 1.this instance is immutable and unaffected by this method call.",
	"Method": "Minutes dividedBy(int divisor){\r\n    if (divisor == 1) {\r\n        return this;\r\n    }\r\n    return Minutes.minutes(getValue() / divisor);\r\n}"
}, {
	"Path": "org.jooq.codegen.JavaGenerator.generateUDTPojoSetter",
	"Comment": "subclasses may override this method to provide their own pojo setters.",
	"Method": "void generateUDTPojoSetter(TypedElementDefinition<?> column,int index,JavaWriter out){\r\n    generatePojoSetter0(column, index, out);\r\n}"
}, {
	"Path": "jodd.jerry.Jerry.prepend",
	"Comment": "insert content, specified by the parameter, to the beginning of each \telement in the set of matched elements.",
	"Method": "Jerry prepend(String html){\r\n    if (html == null) {\r\n        html = StringPool.EMPTY;\r\n    }\r\n    final Document doc = builder.parse(html);\r\n    if (nodes.length == 0) {\r\n        return this;\r\n    }\r\n    for (Node node : nodes) {\r\n        Document workingDoc = doc.clone();\r\n        node.insertChild(workingDoc.getChildNodes(), 0);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "jodd.madvoc.component.ScopeResolver.defaultOrScopeType",
	"Comment": "lookups the scope instance of given scope annotation.\tif instance does not exist, it will be created, cached and returned.",
	"Method": "S defaultOrScopeType(Class<S> scopeClass){\r\n    if (scopeClass == null) {\r\n        return (S) getOrInitScope(RequestScope.class);\r\n    }\r\n    return (S) getOrInitScope(scopeClass);\r\n}"
}, {
	"Path": "jodd.joy.auth.AuthInterceptor.authenticateUserViaBasicAuth",
	"Comment": "tires to authenticate user via the basic authentication. returns the token if user is authenticated.",
	"Method": "T authenticateUserViaBasicAuth(ActionRequest actionRequest){\r\n    final HttpServletRequest servletRequest = actionRequest.getHttpServletRequest();\r\n    final String username = ServletUtil.resolveAuthUsername(servletRequest);\r\n    if (username == null) {\r\n        return null;\r\n    }\r\n    final String password = ServletUtil.resolveAuthPassword(servletRequest);\r\n    final T authToken = userAuth().login(username, password);\r\n    if (authToken == null) {\r\n        return null;\r\n    }\r\n    return authToken;\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractInstant.isAfterNow",
	"Comment": "is this instant strictly after the current instantcomparing solely by millisecond.",
	"Method": "boolean isAfterNow(){\r\n    return isAfter(DateTimeUtils.currentTimeMillis());\r\n}"
}, {
	"Path": "jodd.util.CharSequenceUtil.findFirstEqual",
	"Comment": "finds index of the first character in given array the matches any from the\tgiven set of characters.",
	"Method": "int findFirstEqual(CharSequence source,int index,CharSequence match,int findFirstEqual,char[] source,int index,char match){\r\n    for (int i = index; i < source.length; i++) {\r\n        if (source[i] == match) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Database.isIncludeTables",
	"Comment": "this flag indicates whether tables should be included in output produced by this database",
	"Method": "Boolean isIncludeTables(){\r\n    return includeTables;\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Generate.isDeprecationOnUnknownTypes",
	"Comment": "generate deprecation annotations on references to unknown data types.this helps identifying columns, attributes, and parameters, which may not be usable throughjooq api, without adding custom data type bindings to them.",
	"Method": "Boolean isDeprecationOnUnknownTypes(){\r\n    return deprecationOnUnknownTypes;\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractInterval.toDurationMillis",
	"Comment": "gets the duration of this time interval in milliseconds.the duration is equal to the end millis minus the start millis.",
	"Method": "long toDurationMillis(){\r\n    return FieldUtils.safeSubtract(getEndMillis(), getStartMillis());\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.withSecondOfMinute",
	"Comment": "returns a copy of this datetime with the second of minute field updated.localdatetime is immutable, so there are no set methods.instead, this method returns a new instance with the value ofsecond of minute changed.",
	"Method": "LocalDateTime withSecondOfMinute(int second){\r\n    return withLocalMillis(getChronology().secondOfMinute().set(getLocalMillis(), second));\r\n}"
}, {
	"Path": "jodd.bean.BeanUtilUtil.arrayForcedGet",
	"Comment": "returns the element of an array forced. if value is null, it will be instantiated.\tif not the last part of indexed bean property, array will be expanded to the index if necessary.",
	"Method": "Object arrayForcedGet(BeanProperty bp,Object array,int index){\r\n    Class componentType = array.getClass().getComponentType();\r\n    if (!bp.last) {\r\n        array = ensureArraySize(bp, array, componentType, index);\r\n    }\r\n    Object value = Array.get(array, index);\r\n    if (value == null) {\r\n        try {\r\n            value = ClassUtil.newInstance(componentType);\r\n        } catch (Exception ex) {\r\n            if (isSilent) {\r\n                return null;\r\n            }\r\n            throw new BeanException(\"Invalid array element: \" + bp.name + '[' + index + ']', bp, ex);\r\n        }\r\n        Array.set(array, index, value);\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "org.joda.time.Instant.withDurationAdded",
	"Comment": "gets a copy of this instant with the specified duration added.if the addition is zero, then this is returned.",
	"Method": "Instant withDurationAdded(long durationToAdd,int scalar,Instant withDurationAdded,ReadableDuration durationToAdd,int scalar){\r\n    if (durationToAdd == null || scalar == 0) {\r\n        return this;\r\n    }\r\n    return withDurationAdded(durationToAdd.getMillis(), scalar);\r\n}"
}, {
	"Path": "org.joda.time.convert.CalendarConverter.getChronology",
	"Comment": "gets the chronology, which is the gjchronology if a gregoriancalendar is used,buddhistchronology if a buddhistcalendar is used or isochronology otherwise.the time zone specified is used in preference to that on the calendar.",
	"Method": "Chronology getChronology(Object object,Chronology chrono,Chronology getChronology,Object object,DateTimeZone zone){\r\n    if (object.getClass().getName().endsWith(\".BuddhistCalendar\")) {\r\n        return BuddhistChronology.getInstance(zone);\r\n    } else if (object instanceof GregorianCalendar) {\r\n        GregorianCalendar gc = (GregorianCalendar) object;\r\n        long cutover = gc.getGregorianChange().getTime();\r\n        if (cutover == Long.MIN_VALUE) {\r\n            return GregorianChronology.getInstance(zone);\r\n        } else if (cutover == Long.MAX_VALUE) {\r\n            return JulianChronology.getInstance(zone);\r\n        } else {\r\n            return GJChronology.getInstance(zone, cutover, 4);\r\n        }\r\n    } else {\r\n        return ISOChronology.getInstance(zone);\r\n    }\r\n}"
}, {
	"Path": "jodd.util.collection.SetMapAdapter.iterator",
	"Comment": "returns an iterator over the elements in this set.the elements\tare returned in no particular order.",
	"Method": "Iterator<E> iterator(){\r\n    return map.keySet().iterator();\r\n}"
}, {
	"Path": "org.jooq.exception.DataAccessException.getCause",
	"Comment": "find a root cause of a given type, or null if no root causeof that type was found.",
	"Method": "T getCause(Class<? extends T> type){\r\n    return ExceptionTools.getCause(this, type);\r\n}"
}, {
	"Path": "jodd.servlet.filter.GzipResponseStream.close",
	"Comment": "closes this output stream, causing any buffered data to be flushed and any\tfurther output data to throw an ioexception.",
	"Method": "void close(){\r\n    if (closed) {\r\n        return;\r\n    }\r\n    if (gzipstream != null) {\r\n        flushToGZip();\r\n        gzipstream.close();\r\n        gzipstream = null;\r\n    } else {\r\n        if (bufferCount > 0) {\r\n            output.write(buffer, 0, bufferCount);\r\n            bufferCount = 0;\r\n        }\r\n    }\r\n    output.close();\r\n    closed = true;\r\n}"
}, {
	"Path": "jodd.petite.AnnotationResolver.beanHasAnnotationName",
	"Comment": "returns true if bean has name defined by petite annotation.",
	"Method": "boolean beanHasAnnotationName(Class type){\r\n    PetiteBean petiteBean = ((Class<?>) type).getAnnotation(PetiteBean.class);\r\n    if (petiteBean == null) {\r\n        return false;\r\n    }\r\n    String name = petiteBean.value().trim();\r\n    return !name.isEmpty();\r\n}"
}, {
	"Path": "jodd.petite.PetiteContainer.createBean",
	"Comment": "creates and wires a bean within the container and optionally invokes init methods. however, bean is\tnot registered.",
	"Method": "E createBean(Class<E> type,E createBean,Class<E> type,WiringMode wiringMode){\r\n    final WiringMode finalWiringMode = petiteConfig.resolveWiringMode(wiringMode);\r\n    final BeanDefinition def = externalsCache.get(type, () -> {\r\n        final BeanDefinition beanDefinition = createBeandDefinitionForExternalBeans(type, finalWiringMode);\r\n        initBeanDefinition(beanDefinition);\r\n        return beanDefinition;\r\n    });\r\n    final BeanData<E> beanData = new BeanData(this, def);\r\n    registerBeanAndWireAndInjectParamsAndInvokeInitMethods(beanData);\r\n    return beanData.bean();\r\n}"
}, {
	"Path": "org.joda.time.field.OffsetDateTimeField.get",
	"Comment": "get the amount of offset units from the specified time instant.",
	"Method": "int get(long instant){\r\n    return super.get(instant) + iOffset;\r\n}"
}, {
	"Path": "jodd.props.Props.getValueOrDefault",
	"Comment": "returns value of property, using active profiles or default value if not found.",
	"Method": "String getValueOrDefault(String key,String defaultValue){\r\n    initialize();\r\n    final String value = data.lookupValue(key, activeProfiles);\r\n    if (value == null) {\r\n        return defaultValue;\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "org.json.JSONML.toString",
	"Comment": "reverse the jsonml transformation, making an xml text from a jsonarray.",
	"Method": "String toString(JSONArray ja,String toString,JSONObject jo){\r\n    StringBuilder sb = new StringBuilder();\r\n    int i;\r\n    JSONArray ja;\r\n    int length;\r\n    Object object;\r\n    String tagName;\r\n    Object value;\r\n    tagName = jo.optString(\"tagName\");\r\n    if (tagName == null) {\r\n        return XML.escape(jo.toString());\r\n    }\r\n    XML.noSpace(tagName);\r\n    tagName = XML.escape(tagName);\r\n    sb.append('<');\r\n    sb.append(tagName);\r\n    for (final String key : jo.keySet()) {\r\n        if (!\"tagName\".equals(key) && !\"childNodes\".equals(key)) {\r\n            XML.noSpace(key);\r\n            value = jo.opt(key);\r\n            if (value != null) {\r\n                sb.append(' ');\r\n                sb.append(XML.escape(key));\r\n                sb.append('=');\r\n                sb.append('\"');\r\n                sb.append(XML.escape(value.toString()));\r\n                sb.append('\"');\r\n            }\r\n        }\r\n    }\r\n    ja = jo.optJSONArray(\"childNodes\");\r\n    if (ja == null) {\r\n        sb.append('/');\r\n        sb.append('>');\r\n    } else {\r\n        sb.append('>');\r\n        length = ja.length();\r\n        for (i = 0; i < length; i += 1) {\r\n            object = ja.get(i);\r\n            if (object != null) {\r\n                if (object instanceof String) {\r\n                    sb.append(XML.escape(object.toString()));\r\n                } else if (object instanceof JSONObject) {\r\n                    sb.append(toString((JSONObject) object));\r\n                } else if (object instanceof JSONArray) {\r\n                    sb.append(toString((JSONArray) object));\r\n                } else {\r\n                    sb.append(object.toString());\r\n                }\r\n            }\r\n        }\r\n        sb.append('<');\r\n        sb.append('/');\r\n        sb.append(tagName);\r\n        sb.append('>');\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Database.isIncludePackageRoutines",
	"Comment": "this flag indicates whether routines contained in packages should be included in output produced by this database",
	"Method": "Boolean isIncludePackageRoutines(){\r\n    return includePackageRoutines;\r\n}"
}, {
	"Path": "org.joda.time.YearMonth.fromCalendarFields",
	"Comment": "constructs a yearmonth from a java.util.calendarusing exactly the same field values avoiding any time zone effects.each field is queried from the calendar and assigned to the yearmonth.this factory method ignores the type of the calendar and alwayscreates a yearmonth with iso chronology. it is expected that youwill only pass in instances of gregoriancalendar howeverthis is not validated.",
	"Method": "YearMonth fromCalendarFields(Calendar calendar){\r\n    if (calendar == null) {\r\n        throw new IllegalArgumentException(\"The calendar must not be null\");\r\n    }\r\n    return new YearMonth(calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH) + 1);\r\n}"
}, {
	"Path": "org.jsonschema2pojo.maven.ProjectClasspath.getClassLoader",
	"Comment": "provides a class loader that can be used to load classes from thisproject classpath.",
	"Method": "ClassLoader getClassLoader(MavenProject project,ClassLoader parent,Log log){\r\n    @SuppressWarnings(\"unchecked\")\r\n    List<String> classpathElements = project.getCompileClasspathElements();\r\n    final List<URL> classpathUrls = new ArrayList(classpathElements.size());\r\n    for (String classpathElement : classpathElements) {\r\n        try {\r\n            log.debug(\"Adding project artifact to classpath: \" + classpathElement);\r\n            classpathUrls.add(new File(classpathElement).toURI().toURL());\r\n        } catch (MalformedURLException e) {\r\n            log.debug(\"Unable to use classpath entry as it could not be understood as a valid URL: \" + classpathElement, e);\r\n        }\r\n    }\r\n    return AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {\r\n        @Override\r\n        public ClassLoader run() {\r\n            return new URLClassLoader(classpathUrls.toArray(new URL[classpathUrls.size()]), parent);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.jsonschema2pojo.maven.ProjectClasspath.getClassLoader",
	"Comment": "provides a class loader that can be used to load classes from thisproject classpath.",
	"Method": "ClassLoader getClassLoader(MavenProject project,ClassLoader parent,Log log){\r\n    return new URLClassLoader(classpathUrls.toArray(new URL[classpathUrls.size()]), parent);\r\n}"
}, {
	"Path": "org.joda.time.LocalTime.toDateTimeToday",
	"Comment": "converts this localtime to a full datetime using the specified time zonesetting the time fields from this instance and the date fields fromthe current time.this method uses the chronology from this instance plus the time zonespecified.",
	"Method": "DateTime toDateTimeToday(DateTime toDateTimeToday,DateTimeZone zone){\r\n    Chronology chrono = getChronology().withZone(zone);\r\n    long instantMillis = DateTimeUtils.currentTimeMillis();\r\n    long resolved = chrono.set(this, instantMillis);\r\n    return new DateTime(resolved, chrono);\r\n}"
}, {
	"Path": "jodd.util.BinarySearchBase.findFirst",
	"Comment": "finds very first index of given element in inclusive index range. returns negative\tvalue if element is not found.",
	"Method": "int findFirst(int low,int high){\r\n    int ndx = -1;\r\n    while (low <= high) {\r\n        int mid = (low + high) >>> 1;\r\n        int delta = compare(mid);\r\n        if (delta < 0) {\r\n            low = mid + 1;\r\n        } else {\r\n            if (delta == 0) {\r\n                ndx = mid;\r\n            }\r\n            high = mid - 1;\r\n        }\r\n    }\r\n    if (ndx == -1) {\r\n        return -(low + 1);\r\n    }\r\n    return ndx;\r\n}"
}, {
	"Path": "jodd.proxetta.ProxyTarget.targetMethodAnnotation",
	"Comment": "inserts targets method annotation value. inserts null\tif annotation or element is missing.",
	"Method": "Object targetMethodAnnotation(String annotationClassName,String element){\r\n    throw new ProxettaException();\r\n}"
}, {
	"Path": "jodd.servlet.SessionMonitor.destroy",
	"Comment": "destroys this session monitor by removing all collected resources.",
	"Method": "void destroy(){\r\n    listeners.clear();\r\n    sessionMap.clear();\r\n}"
}, {
	"Path": "org.joda.time.chrono.GregorianChronology.getInstanceUTC",
	"Comment": "gets an instance of the gregorianchronology.the time zone of the returned instance is utc.",
	"Method": "GregorianChronology getInstanceUTC(){\r\n    return INSTANCE_UTC;\r\n}"
}, {
	"Path": "jodd.util.BinarySearch.forArray",
	"Comment": "creates binary search wrapper over an array with given comparator.",
	"Method": "BinarySearch<T> forArray(T[] array,BinarySearch<T> forArray,T[] array,Comparator<T> comparator){\r\n    return new BinarySearch<T>() {\r\n        @Override\r\n        @SuppressWarnings({ \"unchecked\" })\r\n        protected int compare(final int index, final T element) {\r\n            return comparator.compare(array[index], element);\r\n        }\r\n        @Override\r\n        protected int getLastIndex() {\r\n            return array.length - 1;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "jodd.util.BinarySearch.forArray",
	"Comment": "creates binary search wrapper over an array with given comparator.",
	"Method": "BinarySearch<T> forArray(T[] array,BinarySearch<T> forArray,T[] array,Comparator<T> comparator){\r\n    return comparator.compare(array[index], element);\r\n}"
}, {
	"Path": "jodd.util.BinarySearch.forArray",
	"Comment": "creates binary search wrapper over an array with given comparator.",
	"Method": "BinarySearch<T> forArray(T[] array,BinarySearch<T> forArray,T[] array,Comparator<T> comparator){\r\n    return array.length - 1;\r\n}"
}, {
	"Path": "jodd.madvoc.Madvoc.setMadvocConfiguratorClassName",
	"Comment": "sets the name of the class that is going to be used for configuration of user actions.",
	"Method": "void setMadvocConfiguratorClassName(String madvocConfiguratorClassName){\r\n    this.madvocConfiguratorClassName = madvocConfiguratorClassName;\r\n    this.madvocConfiguratorClass = null;\r\n}"
}, {
	"Path": "org.joda.time.convert.ConverterManager.removeDurationConverter",
	"Comment": "removes a converter from the set of converters. if the converter wasnot in the set, no changes are made.",
	"Method": "DurationConverter removeDurationConverter(DurationConverter converter){\r\n    checkAlterDurationConverters();\r\n    if (converter == null) {\r\n        return null;\r\n    }\r\n    DurationConverter[] removed = new DurationConverter[1];\r\n    iDurationConverters = iDurationConverters.remove(converter, removed);\r\n    return removed[0];\r\n}"
}, {
	"Path": "jodd.htmlstapler.HtmlStaplerBundlesManager.lookupBundleId",
	"Comment": "lookups for a bundle id for a given action.\treturns null if action still has no bundle.\treturns an empty string if action has an empty bundle.",
	"Method": "String lookupBundleId(String actionPath){\r\n    return actionBundles.get(actionPath);\r\n}"
}, {
	"Path": "jodd.vtor.Vtor.matchProfiles",
	"Comment": "determine if any of checks profiles is among enabled profiles.",
	"Method": "boolean matchProfiles(String[] checkProfiles){\r\n    if ((checkProfiles != null) && (checkProfiles.length == 1) && checkProfiles[0].equals(ALL_PROFILES)) {\r\n        return true;\r\n    }\r\n    if (enabledProfiles == null || enabledProfiles.isEmpty()) {\r\n        if (validateAllProfilesByDefault) {\r\n            return true;\r\n        }\r\n        if ((checkProfiles == null) || (checkProfiles.length == 0)) {\r\n            return true;\r\n        }\r\n        for (String profile : checkProfiles) {\r\n            if (StringUtil.isEmpty(profile)) {\r\n                return true;\r\n            }\r\n            if (profile.equals(DEFAULT_PROFILE)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    if ((checkProfiles == null) || (checkProfiles.length == 0)) {\r\n        return enabledProfiles.contains(DEFAULT_PROFILE);\r\n    }\r\n    boolean result = false;\r\n    for (String profile : checkProfiles) {\r\n        boolean b = true;\r\n        boolean must = false;\r\n        if (StringUtil.isEmpty(profile)) {\r\n            profile = DEFAULT_PROFILE;\r\n        } else if (profile.charAt(0) == '-') {\r\n            profile = profile.substring(1);\r\n            b = false;\r\n        } else if (profile.charAt(0) == '+') {\r\n            profile = profile.substring(1);\r\n            must = true;\r\n        }\r\n        if (enabledProfiles.contains(profile)) {\r\n            if (!b) {\r\n                return false;\r\n            }\r\n            result = true;\r\n        } else {\r\n            if (must) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "jodd.util.ClassUtil.isTypeOf",
	"Comment": "safe version of isassignablefrom method that\treturns false if one of the arguments is null.",
	"Method": "boolean isTypeOf(Class<?> lookupClass,Class<?> targetClass){\r\n    if (targetClass == null || lookupClass == null) {\r\n        return false;\r\n    }\r\n    return targetClass.isAssignableFrom(lookupClass);\r\n}"
}, {
	"Path": "jodd.jerry.Jerry.removeAttr",
	"Comment": "removes an attribute from each element in the set of matched elements.",
	"Method": "Jerry removeAttr(String name){\r\n    if (name == null) {\r\n        return this;\r\n    }\r\n    if (nodes.length == 0) {\r\n        return this;\r\n    }\r\n    for (Node node : nodes) {\r\n        node.removeAttribute(name);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.gl.SurfaceManager.setPresentationTime",
	"Comment": "sends the presentation time stamp to egl.time is expressed in nanoseconds.",
	"Method": "void setPresentationTime(long nsecs){\r\n    EGLExt.eglPresentationTimeANDROID(mEGLDisplay, mEGLSurface, nsecs);\r\n    checkEglError(\"eglPresentationTimeANDROID\");\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractInstant.compareTo",
	"Comment": "compares this object with the specified object for ascendingmillisecond instant order. this ordering is inconsistent withequals, as it ignores the chronology.all readableinstant instances are accepted.",
	"Method": "int compareTo(ReadableInstant other){\r\n    if (this == other) {\r\n        return 0;\r\n    }\r\n    long otherMillis = other.getMillis();\r\n    long thisMillis = getMillis();\r\n    if (thisMillis == otherMillis) {\r\n        return 0;\r\n    }\r\n    if (thisMillis < otherMillis) {\r\n        return -1;\r\n    } else {\r\n        return 1;\r\n    }\r\n}"
}, {
	"Path": "jodd.util.StringUtil.toUpperCase",
	"Comment": "converts all of the characters in the string to upper case, based on the\tlocale.",
	"Method": "String toUpperCase(String s,String toUpperCase,String s,Locale locale){\r\n    if (s == null) {\r\n        return null;\r\n    }\r\n    StringBuilder sb = null;\r\n    for (int i = 0; i < s.length(); i++) {\r\n        char c = s.charAt(i);\r\n        if (c > 127) {\r\n            if (locale == null) {\r\n                locale = Locale.getDefault();\r\n            }\r\n            return s.toUpperCase(locale);\r\n        }\r\n        if ((c >= 'a') && (c <= 'z')) {\r\n            if (sb == null) {\r\n                sb = new StringBuilder(s);\r\n            }\r\n            sb.setCharAt(i, (char) (c - 32));\r\n        }\r\n    }\r\n    if (sb == null) {\r\n        return s;\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "jodd.http.Cookie.getName",
	"Comment": "returns the name of the cookie. the name cannot be changed after\tcreation.",
	"Method": "String getName(){\r\n    return name;\r\n}"
}, {
	"Path": "jodd.util.RandomString.randomRanges",
	"Comment": "creates random string whose length is the number of characters specified.\tcharacters are chosen from the multiple sets defined by range pairs.\tall ranges must be in acceding order.",
	"Method": "String randomRanges(int count,char ranges){\r\n    if (count == 0) {\r\n        return StringPool.EMPTY;\r\n    }\r\n    int i = 0;\r\n    int len = 0;\r\n    int[] lens = new int[ranges.length];\r\n    while (i < ranges.length) {\r\n        int gap = ranges[i + 1] - ranges[i] + 1;\r\n        len += gap;\r\n        lens[i] = len;\r\n        i += 2;\r\n    }\r\n    char[] result = new char[count];\r\n    while (count-- > 0) {\r\n        char c = 0;\r\n        int r = rnd.nextInt(len);\r\n        for (i = 0; i < ranges.length; i += 2) {\r\n            if (r < lens[i]) {\r\n                r += ranges[i];\r\n                if (i != 0) {\r\n                    r -= lens[i - 2];\r\n                }\r\n                c = (char) r;\r\n                break;\r\n            }\r\n        }\r\n        result[count] = c;\r\n    }\r\n    return new String(result);\r\n}"
}, {
	"Path": "org.jooq.codegen.JavaGenerator.generatePojoCopyConstructor",
	"Comment": "subclasses may override this method to provide their own pojo copy constructors.",
	"Method": "void generatePojoCopyConstructor(Definition tableOrUDT,JavaWriter out){\r\n    final String className = getStrategy().getJavaClassName(tableOrUDT, Mode.POJO);\r\n    final String interfaceName = generateInterfaces() ? out.ref(getStrategy().getFullJavaClassName(tableOrUDT, Mode.INTERFACE)) : \"\";\r\n    out.println();\r\n    if (scala) {\r\n        out.tab(1).println(\"def this (value : %s) = {\", generateInterfaces() ? interfaceName : className);\r\n        out.tab(2).println(\"this(\");\r\n        String separator = \"  \";\r\n        for (TypedElementDefinition<?> column : getTypedElements(tableOrUDT)) {\r\n            out.tab(3).println(\"%svalue.%s\", separator, getStrategy().getJavaMemberName(column, Mode.POJO), generateInterfaces() ? getStrategy().getJavaMemberName(column, Mode.INTERFACE) : getStrategy().getJavaMemberName(column, Mode.POJO));\r\n            separator = \", \";\r\n        }\r\n        out.tab(2).println(\")\");\r\n        out.tab(1).println(\"}\");\r\n    } else {\r\n        out.tab(1).println(\"public %s(%s value) {\", className, generateInterfaces() ? interfaceName : className);\r\n        for (TypedElementDefinition<?> column : getTypedElements(tableOrUDT)) {\r\n            out.tab(2).println(\"this.%s = value.%s%s;\", getStrategy().getJavaMemberName(column, Mode.POJO), generateInterfaces() ? getStrategy().getJavaGetterName(column, Mode.INTERFACE) : getStrategy().getJavaMemberName(column, Mode.POJO), generateInterfaces() ? \"()\" : \"\");\r\n        }\r\n        out.tab(1).println(\"}\");\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.LocalDate.hashCode",
	"Comment": "gets a hash code for the instant as defined in readablepartial.",
	"Method": "int hashCode(){\r\n    int hash = iHash;\r\n    if (hash == 0) {\r\n        hash = iHash = super.hashCode();\r\n    }\r\n    return hash;\r\n}"
}, {
	"Path": "org.joda.time.YearMonth.getField",
	"Comment": "gets the field for a specific index in the chronology specified.this method must not use any instance variables.",
	"Method": "DateTimeField getField(int index,Chronology chrono,DateTimeField getField){\r\n    switch(index) {\r\n        case YEAR:\r\n            return chrono.year();\r\n        case MONTH_OF_YEAR:\r\n            return chrono.monthOfYear();\r\n        default:\r\n            throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.Period.withDays",
	"Comment": "returns a new period with the specified number of days.this period instance is immutable and unaffected by this method call.",
	"Method": "Period withDays(int days){\r\n    int[] values = getValues();\r\n    getPeriodType().setIndexedField(this, PeriodType.DAY_INDEX, values, days);\r\n    return new Period(values, getPeriodType());\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.SessionBuilder.setOrigin",
	"Comment": "sets the origin of the session. it appears in the sdp of the session.",
	"Method": "SessionBuilder setOrigin(String origin){\r\n    mOrigin = origin;\r\n    return this;\r\n}"
}, {
	"Path": "org.joda.time.PeriodType.time",
	"Comment": "gets a type that defines all standard time fields.hoursminutessecondsmilliseconds",
	"Method": "PeriodType time(){\r\n    PeriodType type = cTime;\r\n    if (type == null) {\r\n        type = new PeriodType(\"Time\", new DurationFieldType[] { DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { -1, -1, -1, -1, 0, 1, 2, 3 });\r\n        cTime = type;\r\n    }\r\n    return type;\r\n}"
}, {
	"Path": "org.apache.jmeter.protocol.http.sampler.TestHTTPSamplersAgainstHttpMirrorServer.createExpectedFormAndUploadOutput",
	"Comment": "create the expected output post body for form data and file multipartswith specified values, when request is multipart",
	"Method": "byte[] createExpectedFormAndUploadOutput(String boundaryString,String contentEncoding,String titleField,String titleValue,String descriptionField,String descriptionValue,String fileField,File fileValue,String fileMimeType,byte[] fileContent){\r\n    byte[] formdataMultipart = createExpectedFormdataOutput(boundaryString, contentEncoding, titleField, titleValue, descriptionField, descriptionValue, true, false);\r\n    byte[] fileMultipart = createExpectedFilepartOutput(boundaryString, fileField, fileValue, fileMimeType, fileContent, false, true);\r\n    ByteArrayOutputStream output = new ByteArrayOutputStream();\r\n    output.write(formdataMultipart);\r\n    output.write(fileMultipart);\r\n    output.flush();\r\n    output.close();\r\n    return output.toByteArray();\r\n}"
}, {
	"Path": "org.joda.time.Period.toStandardHours",
	"Comment": "converts this period to a period in hours assuming a7 day week, 24 hour day, 60 minute hour and 60 second minute.this method allows you to convert between different types of period.however to achieve this it makes the assumption that allweeks are 7 days, all days are 24 hours, all hours are 60 minutes andall minutes are 60 seconds. this is not true when daylight savings timeis considered, and may also not be true for some unusual chronologies.however, it is included as it is a useful operation for manyapplications and business rules.if the period contains years or months, an exception will be thrown.",
	"Method": "Hours toStandardHours(){\r\n    checkYearsAndMonths(\"Hours\");\r\n    long millis = getMillis();\r\n    millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;\r\n    millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE;\r\n    long hours = millis / DateTimeConstants.MILLIS_PER_HOUR;\r\n    hours = FieldUtils.safeAdd(hours, getHours());\r\n    hours = FieldUtils.safeAdd(hours, ((long) getDays()) * ((long) DateTimeConstants.HOURS_PER_DAY));\r\n    hours = FieldUtils.safeAdd(hours, ((long) getWeeks()) * ((long) DateTimeConstants.HOURS_PER_WEEK));\r\n    return Hours.hours(FieldUtils.safeToInt(hours));\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractPartial.toDateTime",
	"Comment": "resolves this partial against another complete instant to create a newfull instant. the combination is performed using the chronology of thespecified instant.for example, if this partial represents a time, then the result of thismethod will be the datetime from the specified base instant plus thetime from this partial.",
	"Method": "DateTime toDateTime(ReadableInstant baseInstant){\r\n    Chronology chrono = DateTimeUtils.getInstantChronology(baseInstant);\r\n    long instantMillis = DateTimeUtils.getInstantMillis(baseInstant);\r\n    long resolved = chrono.set(this, instantMillis);\r\n    return new DateTime(resolved, chrono);\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.withDayOfMonth",
	"Comment": "returns a copy of this datetime with the day of month field updated.localdatetime is immutable, so there are no set methods.instead, this method returns a new instance with the value ofday of month changed.",
	"Method": "LocalDateTime withDayOfMonth(int dayOfMonth){\r\n    return withLocalMillis(getChronology().dayOfMonth().set(getLocalMillis(), dayOfMonth));\r\n}"
}, {
	"Path": "jodd.madvoc.component.ActionConfigManager.lookup",
	"Comment": "lookup for the action configuration. typically, the input argument is either the action type or annotation type.",
	"Method": "ActionConfig lookup(Class actionTypeOrAnnotationType){\r\n    final ActionConfig actionConfig = actionConfigs.get(actionTypeOrAnnotationType);\r\n    if (actionConfig == null) {\r\n        throw new MadvocException(\"ActionConfiguration not registered:\" + actionTypeOrAnnotationType.getName());\r\n    }\r\n    return actionConfig;\r\n}"
}, {
	"Path": "jodd.http.net.SocketHttpConnectionProvider.setSecuredProtocols",
	"Comment": "csv of default enabled secured protocols. by default the value is\tread from system property https.protocols.",
	"Method": "void setSecuredProtocols(String secureEnabledProtocols){\r\n    this.secureEnabledProtocols = secureEnabledProtocols;\r\n}"
}, {
	"Path": "org.joda.time.YearMonthDay.withChronologyRetainFields",
	"Comment": "returns a copy of this date with the specified chronology.this instance is immutable and unaffected by this method call.this method retains the values of the fields, thus the result willtypically refer to a different instant.the time zone of the specified chronology is ignored, as yearmonthdayoperates without a time zone.",
	"Method": "YearMonthDay withChronologyRetainFields(Chronology newChronology){\r\n    newChronology = DateTimeUtils.getChronology(newChronology);\r\n    newChronology = newChronology.withUTC();\r\n    if (newChronology == getChronology()) {\r\n        return this;\r\n    } else {\r\n        YearMonthDay newYearMonthDay = new YearMonthDay(this, newChronology);\r\n        newChronology.validate(newYearMonthDay, getValues());\r\n        return newYearMonthDay;\r\n    }\r\n}"
}, {
	"Path": "jodd.proxetta.ProxyTarget.targetClassAnnotation",
	"Comment": "inserts targets class annotation value. inserts null\tif annotation or element is missing.",
	"Method": "Object targetClassAnnotation(String annotationClassName,String element){\r\n    throw new ProxettaException();\r\n}"
}, {
	"Path": "jodd.asm7.signature.SignatureVisitor.visitInterfaceBound",
	"Comment": "visits an interface bound of the last visited formal type parameter.",
	"Method": "SignatureVisitor visitInterfaceBound(){\r\n    return this;\r\n}"
}, {
	"Path": "org.jooq.codegen.JavaGenerator.generatePojoDefaultConstructor",
	"Comment": "subclasses may override this method to provide their own pojo default constructors.",
	"Method": "void generatePojoDefaultConstructor(Definition tableOrUDT,JavaWriter out){\r\n    final String className = getStrategy().getJavaClassName(tableOrUDT, Mode.POJO);\r\n    out.println();\r\n    if (scala) {\r\n        int size = getTypedElements(tableOrUDT).size();\r\n        if (size > 0) {\r\n            List<String> nulls = new ArrayList<String>(size);\r\n            for (// and the copy constructor\r\n            TypedElementDefinition<?> column : getTypedElements(tableOrUDT)) if (size == 1)\r\n                nulls.add(\"null : \" + out.ref(getJavaType(column.getType(resolver(Mode.POJO)), Mode.POJO)));\r\n            else\r\n                nulls.add(\"null\");\r\n            out.tab(1).println(\"def this() = {\", className);\r\n            out.tab(2).println(\"this([[%s]])\", nulls);\r\n            out.tab(1).println(\"}\");\r\n        }\r\n    } else {\r\n        out.tab(1).println(\"public %s() {}\", className);\r\n    }\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Generate.isCommentsOnTables",
	"Comment": "turn off generation of all sql comments as javadoc on all tables.",
	"Method": "Boolean isCommentsOnTables(){\r\n    return commentsOnTables;\r\n}"
}, {
	"Path": "jodd.db.DbQueryBase.setGeneratedColumns",
	"Comment": "specifies columns which values will be generated by database.",
	"Method": "Q setGeneratedColumns(String columns){\r\n    checkCreated();\r\n    generatedColumns = columns;\r\n    return _this();\r\n}"
}, {
	"Path": "jodd.madvoc.component.ActionMethodParser.detectAndRegisterAlias",
	"Comment": "detects if alias is defined in annotation and registers it if so.",
	"Method": "void detectAndRegisterAlias(ActionAnnotationValues annotationValues,ActionDefinition actionDefinition){\r\n    final String alias = parseMethodAlias(annotationValues);\r\n    if (alias != null) {\r\n        String aliasPath = StringUtil.cutToIndexOf(actionDefinition.actionPath(), StringPool.HASH);\r\n        actionsManager.registerPathAlias(alias, aliasPath);\r\n    }\r\n}"
}, {
	"Path": "jodd.db.oom.sqlgen.DbSqlBuilder.addChunk",
	"Comment": "appends chunk to the list. chunks must be added using this method.",
	"Method": "DbSqlBuilder addChunk(SqlChunk chunk){\r\n    if (lastChunk == null) {\r\n        lastChunk = firstChunk = chunk;\r\n    } else {\r\n        chunk.insertChunkAfter(lastChunk);\r\n        lastChunk = chunk;\r\n    }\r\n    totalChunks++;\r\n    return this;\r\n}"
}, {
	"Path": "com.mysema.examples.DateTimeExpression.currentDate",
	"Comment": "get an expression representing the current date as a edatetime instance",
	"Method": "DateTimeExpression<Date> currentDate(DateTimeExpression<T> currentDate,Class<T> cl){\r\n    return DateTimeOperation.<T>create(cl, Ops.DateTimeOps.CURRENT_DATE);\r\n}"
}, {
	"Path": "org.apache.jorphan.reflect.TestClassTools.testConstructStringInt",
	"Comment": "test that a class can be constructed using an constructor with an integerparameter",
	"Method": "void testConstructStringInt(){\r\n    Integer dummy = (Integer) ClassTools.construct(\"java.lang.Integer\", 23);\r\n    assertNotNull(dummy);\r\n    assertEquals(Integer.valueOf(23), dummy);\r\n}"
}, {
	"Path": "jodd.io.upload.MultipartRequestInputStream.skipToBoundary",
	"Comment": "skips to the boundary and returns total number of bytes skipped.",
	"Method": "int skipToBoundary(){\r\n    int count = 0;\r\n    while (true) {\r\n        byte b = readByte();\r\n        count++;\r\n        if (isBoundary(b)) {\r\n            break;\r\n        }\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "jodd.http.HttpMultiMap.entries",
	"Comment": "returns all the entries of this map. case sensitivity does not influence\tthe returned list, it always contains all of the values.",
	"Method": "List<Map.Entry<String, V>> entries(){\r\n    List<Map.Entry<String, V>> all = new LinkedList();\r\n    MapEntry<V> e = head.after;\r\n    while (e != head) {\r\n        all.add(e);\r\n        e = e.after;\r\n    }\r\n    return all;\r\n}"
}, {
	"Path": "org.jooq.tools.csv.CSVReader.readNext",
	"Comment": "reads the next line from the buffer and converts to a string array.",
	"Method": "String[] readNext(){\r\n    String[] result = null;\r\n    do {\r\n        String nextLine = getNextLine();\r\n        if (!hasNext) {\r\n            return result;\r\n        }\r\n        String[] r = parser.parseLineMulti(nextLine);\r\n        if (r.length > 0) {\r\n            if (result == null) {\r\n                result = r;\r\n            } else {\r\n                String[] t = new String[result.length + r.length];\r\n                System.arraycopy(result, 0, t, 0, result.length);\r\n                System.arraycopy(r, 0, t, result.length, r.length);\r\n                result = t;\r\n            }\r\n        }\r\n    } while (parser.isPending());\r\n    return result;\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractInstant.isBeforeNow",
	"Comment": "is this instant strictly before the current instantcomparing solely by millisecond.",
	"Method": "boolean isBeforeNow(){\r\n    return isBefore(DateTimeUtils.currentTimeMillis());\r\n}"
}, {
	"Path": "org.joda.time.MutablePeriod.set",
	"Comment": "sets the value of one of the fields.the field type specified must be one of those that is supported by the period.",
	"Method": "void set(DurationFieldType field,int value){\r\n    super.setField(field, value);\r\n}"
}, {
	"Path": "jodd.asm7.MethodVisitor.visitAnnotationDefault",
	"Comment": "visits the default value of this annotation interface method.",
	"Method": "AnnotationVisitor visitAnnotationDefault(){\r\n    if (mv != null) {\r\n        return mv.visitAnnotationDefault();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "jodd.introspector.Methods.getMethodDescriptor",
	"Comment": "returns a method that matches given name and parameter types.\treturns null if method is not found.",
	"Method": "MethodDescriptor getMethodDescriptor(String name,Class[] paramTypes,MethodDescriptor getMethodDescriptor,String name){\r\n    MethodDescriptor[] methodDescriptors = methodsMap.get(name);\r\n    if (methodDescriptors == null) {\r\n        return null;\r\n    }\r\n    if (methodDescriptors.length != 1) {\r\n        throw new IllegalArgumentException(\"Method name not unique: \" + name);\r\n    }\r\n    return methodDescriptors[0];\r\n}"
}, {
	"Path": "org.joda.time.format.TestDateTimeFormatter.testZoneShortNameNearTransition",
	"Comment": "ensure time zone name switches properly at the zone dst transition.",
	"Method": "void testZoneShortNameNearTransition(){\r\n    DateTime inDST_1 = new DateTime(2005, 10, 30, 1, 0, 0, 0, NEWYORK);\r\n    DateTime inDST_2 = new DateTime(2005, 10, 30, 1, 59, 59, 999, NEWYORK);\r\n    DateTime onDST = new DateTime(2005, 10, 30, 2, 0, 0, 0, NEWYORK);\r\n    DateTime outDST = new DateTime(2005, 10, 30, 2, 0, 0, 1, NEWYORK);\r\n    DateTime outDST_2 = new DateTime(2005, 10, 30, 2, 0, 1, 0, NEWYORK);\r\n    DateTimeFormatter fmt = DateTimeFormat.forPattern(\"yyy-MM-dd HH:mm:ss.S z\").withLocale(Locale.ENGLISH);\r\n    assertEquals(\"2005-10-30 01:00:00.0 EDT\", fmt.print(inDST_1));\r\n    assertEquals(\"2005-10-30 01:59:59.9 EDT\", fmt.print(inDST_2));\r\n    assertEquals(\"2005-10-30 02:00:00.0 EST\", fmt.print(onDST));\r\n    assertEquals(\"2005-10-30 02:00:00.0 EST\", fmt.print(outDST));\r\n    assertEquals(\"2005-10-30 02:00:01.0 EST\", fmt.print(outDST_2));\r\n}"
}, {
	"Path": "jodd.jtx.JtxTransaction.rollback",
	"Comment": "roll back and completes current transaction. transaction is rolled back on all attached resources.\tresource are then detached from the transaction. when this method completes, transaction is no\tlonger associated with current thread.",
	"Method": "void rollback(){\r\n    commitOrRollback(false);\r\n}"
}, {
	"Path": "jodd.jtx.JtxTransactionManager.totalThreadTransactionsWithStatus",
	"Comment": "returns total number of transactions of the specified status associated with current thread.",
	"Method": "int totalThreadTransactionsWithStatus(JtxStatus status){\r\n    ArrayList<JtxTransaction> txlist = txStack.get();\r\n    if (txlist == null) {\r\n        return 0;\r\n    }\r\n    int count = 0;\r\n    for (JtxTransaction tx : txlist) {\r\n        if (tx.getStatus() == status) {\r\n            count++;\r\n        }\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "jodd.asm7.MethodVisitor.visitVarInsn",
	"Comment": "visits a local variable instruction. a local variable instruction is an instruction that loadsor stores the value of a local variable.",
	"Method": "void visitVarInsn(int opcode,int var){\r\n    if (mv != null) {\r\n        mv.visitVarInsn(opcode, var);\r\n    }\r\n}"
}, {
	"Path": "jodd.decora.parser.DecoraParser.decorate",
	"Comment": "decorates page content with decorator template and outputs the result.",
	"Method": "void decorate(Writer writer,char[] pageContent,char[] decoraContent){\r\n    DecoraTag[] decoraTags = parseDecorator(decoraContent);\r\n    parsePage(pageContent, decoraTags);\r\n    writeDecoratedPage(writer, decoraContent, pageContent, decoraTags);\r\n}"
}, {
	"Path": "org.joda.time.convert.ReadableInstantConverter.getChronology",
	"Comment": "gets the chronology, which is taken from the readableinstant.if the chronology on the instant is null, the isochronology in thespecified time zone is used.if the chronology on the instant is not in the specified zone, it isadapted.",
	"Method": "Chronology getChronology(Object object,DateTimeZone zone,Chronology getChronology,Object object,Chronology chrono){\r\n    if (chrono == null) {\r\n        chrono = ((ReadableInstant) object).getChronology();\r\n        chrono = DateTimeUtils.getChronology(chrono);\r\n    }\r\n    return chrono;\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.hourOfDay",
	"Comment": "get the hour of day field property which provides access to advanced functionality.",
	"Method": "Property hourOfDay(){\r\n    return new Property(this, getChronology().hourOfDay());\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Database.setLogSlowQueriesAfterSeconds",
	"Comment": "sets the value of the logslowqueriesafterseconds property.",
	"Method": "void setLogSlowQueriesAfterSeconds(Integer value){\r\n    this.logSlowQueriesAfterSeconds = value;\r\n}"
}, {
	"Path": "org.jsonschema2pojo.rules.ObjectRule.searchSuperClassesForField",
	"Comment": "this is recursive with searchclassandsuperclassesforfield",
	"Method": "JFieldVar searchSuperClassesForField(String property,JDefinedClass jclass){\r\n    JClass superClass = jclass._extends();\r\n    JDefinedClass definedSuperClass = definedClassOrNullFromType(superClass);\r\n    if (definedSuperClass == null) {\r\n        return null;\r\n    }\r\n    return searchClassAndSuperClassesForField(property, definedSuperClass);\r\n}"
}, {
	"Path": "jodd.db.oom.sqlgen.DbEntitySql.updateColumn",
	"Comment": "creates update query for single column of an entity that is matched by id.",
	"Method": "DbSqlBuilder updateColumn(Object entity,String columnRef,Object value,DbSqlBuilder updateColumn,Object entity,String columnRef){\r\n    final Object value = BeanUtil.pojo.getProperty(entity, columnRef);\r\n    return updateColumn(entity, columnRef, value);\r\n}"
}, {
	"Path": "org.jsonschema2pojo.rules.RuleFactory.getDefaultRule",
	"Comment": "provides a rule instance that should be applied when a propertydeclaration is found in the schema to assign any appropriate defaultvalue to that property.",
	"Method": "Rule<JFieldVar, JFieldVar> getDefaultRule(){\r\n    return new DefaultRule(this);\r\n}"
}, {
	"Path": "org.joda.time.Hours.isGreaterThan",
	"Comment": "is this hours instance greater than the specified number of hours.",
	"Method": "boolean isGreaterThan(Hours other){\r\n    if (other == null) {\r\n        return getValue() > 0;\r\n    }\r\n    return getValue() > other.getValue();\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.video.VideoStream.setCamera",
	"Comment": "sets the camera that will be used to capture video.\tyou can call this method at any time and changes will take effect next time you start the stream.",
	"Method": "void setCamera(int camera){\r\n    CameraInfo cameraInfo = new CameraInfo();\r\n    int numberOfCameras = Camera.getNumberOfCameras();\r\n    for (int i = 0; i < numberOfCameras; i++) {\r\n        Camera.getCameraInfo(i, cameraInfo);\r\n        if (cameraInfo.facing == camera) {\r\n            mCameraId = i;\r\n            break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jodd.jerry.Jerry.append",
	"Comment": "inserts content, specified by the parameter, to the end of each\telement in the set of matched elements.",
	"Method": "Jerry append(String html){\r\n    if (html == null) {\r\n        html = StringPool.EMPTY;\r\n    }\r\n    final Document doc = builder.parse(html);\r\n    if (nodes.length == 0) {\r\n        return this;\r\n    }\r\n    for (Node node : nodes) {\r\n        Document workingDoc = doc.clone();\r\n        node.addChild(workingDoc.getChildNodes());\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractInterval.getEnd",
	"Comment": "gets the end of this time interval, which is exclusive, as a datetime.",
	"Method": "DateTime getEnd(){\r\n    return new DateTime(getEndMillis(), getChronology());\r\n}"
}, {
	"Path": "org.joda.time.field.UnsupportedDurationField.getInstance",
	"Comment": "gets an instance of unsupporteddurationfield for a specific named field.the returned instance is cached.",
	"Method": "UnsupportedDurationField getInstance(DurationFieldType type){\r\n    UnsupportedDurationField field;\r\n    if (cCache == null) {\r\n        cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7);\r\n        field = null;\r\n    } else {\r\n        field = cCache.get(type);\r\n    }\r\n    if (field == null) {\r\n        field = new UnsupportedDurationField(type);\r\n        cCache.put(type, field);\r\n    }\r\n    return field;\r\n}"
}, {
	"Path": "org.joda.time.convert.AbstractConverter.isReadableInterval",
	"Comment": "checks if the input is a readableinterval.if it is, then the calling code should cast and copy the fields directly.",
	"Method": "boolean isReadableInterval(Object object,Chronology chrono){\r\n    return false;\r\n}"
}, {
	"Path": "org.jooq.impl.DSL.param",
	"Comment": "create a named parameter with a defined type of another field and noinitial value.",
	"Method": "Param<Object> param(Param<T> param,Class<T> type,Param<T> param,DataType<T> type,Param<T> param,Field<T> field,Param<Object> param,String name,Param<T> param,String name,Class<T> type,Param<T> param,String name,DataType<T> type,Param<T> param,String name,Field<T> type,Param<T> param,String name,T value){\r\n    return new Val<T>(value, Tools.field(value).getDataType(), name);\r\n}"
}, {
	"Path": "jodd.net.URLCoder.encodeQueryParam",
	"Comment": "encodes the given uri query parameter with the given encoding.",
	"Method": "String encodeQueryParam(String queryParam,String encoding,String encodeQueryParam,String queryParam){\r\n    return encodeUriComponent(queryParam, JoddCore.encoding, URIPart.QUERY_PARAM);\r\n}"
}, {
	"Path": "jodd.db.jtx.DbJtxSessionProvider.getDbSession",
	"Comment": "returns session from jtx transaction manager and started transaction.",
	"Method": "DbSession getDbSession(){\r\n    log.debug(\"Requesting db TX manager session\");\r\n    final DbJtxTransaction jtx = (DbJtxTransaction) jtxTxManager.getTransaction();\r\n    if (jtx == null) {\r\n        throw new DbSqlException(\"No transaction is in progress and DbSession can't be provided. \" + \"It seems that transaction manager is not used to begin a transaction.\");\r\n    }\r\n    return jtx.requestResource();\r\n}"
}, {
	"Path": "jodd.http.HttpMultiMap.size",
	"Comment": "returns the number of keys. this is not the number of all elements.\tnot optimized.",
	"Method": "int size(){\r\n    return names().size();\r\n}"
}, {
	"Path": "org.joda.time.LocalTime.hourOfDay",
	"Comment": "get the hour of day field property which provides access to advanced functionality.",
	"Method": "Property hourOfDay(){\r\n    return new Property(this, getChronology().hourOfDay());\r\n}"
}, {
	"Path": "jodd.util.StringUtil.stripFromChar",
	"Comment": "strips everything from the first appearance of given char.\tcharacter is not included in the returned string.",
	"Method": "String stripFromChar(String string,char c){\r\n    int ndx = string.indexOf(c);\r\n    if (ndx == -1) {\r\n        return string;\r\n    }\r\n    return string.substring(0, ndx);\r\n}"
}, {
	"Path": "jodd.util.StringUtil.replaceLast",
	"Comment": "replaces the very last occurrence of a character in a string.",
	"Method": "String replaceLast(String s,String sub,String with,String replaceLast,String s,char sub,char with){\r\n    int index = s.lastIndexOf(sub);\r\n    if (index == -1) {\r\n        return s;\r\n    }\r\n    char[] str = s.toCharArray();\r\n    str[index] = with;\r\n    return new String(str);\r\n}"
}, {
	"Path": "jodd.props.Props.getDoubleValue",
	"Comment": "returns double value or default one if property not defined.",
	"Method": "Double getDoubleValue(String key,Double getDoubleValue,String key,Double defaultValue,Double getDoubleValue,String key,String profiles,Double getDoubleValue,String key,Double defaultValue,String profiles){\r\n    final String value = getValue(key, profiles);\r\n    if (value == null) {\r\n        return defaultValue;\r\n    }\r\n    return Double.valueOf(value);\r\n}"
}, {
	"Path": "com.mysema.examples.DateTimeExpression.currentTimestamp",
	"Comment": "get an expression representing the current time instant as a edatetime instance",
	"Method": "DateTimeExpression<Date> currentTimestamp(DateTimeExpression<T> currentTimestamp,Class<T> cl){\r\n    return DateTimeOperation.<T>create(cl, Ops.DateTimeOps.CURRENT_TIMESTAMP);\r\n}"
}, {
	"Path": "jodd.joy.auth.AuthInterceptor.authenticateUserViaToken",
	"Comment": "tries to authenticate user via token. returns the token if user is authenticated.\treturned token may be rotated.",
	"Method": "T authenticateUserViaToken(ActionRequest actionRequest){\r\n    final HttpServletRequest servletRequest = actionRequest.getHttpServletRequest();\r\n    final String token = ServletUtil.resolveAuthBearerToken(servletRequest);\r\n    if (token == null) {\r\n        return null;\r\n    }\r\n    final T authToken = userAuth().validateToken(token);\r\n    if (authToken == null) {\r\n        return null;\r\n    }\r\n    final T newAuthToken = userAuth().rotateToken(authToken);\r\n    actionRequest.getHttpServletResponse().setHeader(\"Authentication\", \"Bearer: \" + userAuth().tokenValue(newAuthToken));\r\n    return newAuthToken;\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.weekOfWeekyear",
	"Comment": "get the week of a week based year property which provides access to advanced functionality.",
	"Method": "Property weekOfWeekyear(){\r\n    return new Property(this, getChronology().weekOfWeekyear());\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractInterval.isBefore",
	"Comment": "is this time interval entirely before the specified instant.intervals are inclusive of the start instant and exclusive of the end.",
	"Method": "boolean isBefore(long millisInstant,boolean isBefore,ReadableInstant instant,boolean isBefore,ReadableInterval interval){\r\n    if (interval == null) {\r\n        return isBeforeNow();\r\n    }\r\n    return isBefore(interval.getStartMillis());\r\n}"
}, {
	"Path": "jodd.http.HttpProgressListener.callbackSize",
	"Comment": "returns callback size in bytes. by default it returns\tsize of 1 percent of a total size. if returned size\tis less then 512, it will be rounded to 512.\tthis is also the size of the chunk that is sent over network.",
	"Method": "int callbackSize(int size){\r\n    this.size = size;\r\n    int callbackSize = (size + 50) / 100;\r\n    if (callbackSize < 512) {\r\n        callbackSize = 512;\r\n    }\r\n    return callbackSize;\r\n}"
}, {
	"Path": "jodd.util.StringUtil.isCharAtEscaped",
	"Comment": "returns true if character at provided index position is escaped\tby escape character.",
	"Method": "boolean isCharAtEscaped(String src,int ndx,char escapeChar){\r\n    if (ndx == 0) {\r\n        return false;\r\n    }\r\n    ndx--;\r\n    return src.charAt(ndx) == escapeChar;\r\n}"
}, {
	"Path": "org.jooq.impl.DefaultTransactionListenerProvider.providers",
	"Comment": "convenience method to construct an array ofdefaulttransactionlistenerprovider from an array oftransactionlistener instances.",
	"Method": "TransactionListenerProvider[] providers(TransactionListener listeners){\r\n    TransactionListenerProvider[] result = new TransactionListenerProvider[listeners.length];\r\n    for (int i = 0; i < listeners.length; i++) result[i] = new DefaultTransactionListenerProvider(listeners[i]);\r\n    return result;\r\n}"
}, {
	"Path": "org.joda.time.Instant.plus",
	"Comment": "gets a copy of this instant with the specified duration added.if the amount is zero or null, then this is returned.",
	"Method": "Instant plus(long duration,Instant plus,ReadableDuration duration){\r\n    return withDurationAdded(duration, 1);\r\n}"
}, {
	"Path": "org.jooq.impl.DSL.begin",
	"Comment": "wrap a collection of statements in an anonymous procedural block.",
	"Method": "Block begin(Statement statements,Block begin,Collection<? extends Statement> statements){\r\n    return DSL.using(new DefaultConfiguration()).begin(statements);\r\n}"
}, {
	"Path": "jodd.jerry.Jerry.attr",
	"Comment": "sets one or more attributes for the set of matched elements.",
	"Method": "String attr(String name,Jerry attr,String name,String value){\r\n    if (nodes.length == 0) {\r\n        return this;\r\n    }\r\n    for (Node node : nodes) {\r\n        node.setAttribute(name, value);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "jodd.props.Props.initialize",
	"Comment": "initializes props. by default it only resolves active profiles.",
	"Method": "void initialize(){\r\n    if (!initialized) {\r\n        synchronized (this) {\r\n            if (!initialized) {\r\n                resolveActiveProfiles();\r\n                initialized = true;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jodd.asm7.Type.getArgumentTypes",
	"Comment": "returns the argument types of methods of this type. this method should only be used for methodtypes.",
	"Method": "Type[] getArgumentTypes(Type[] getArgumentTypes,String methodDescriptor,Type[] getArgumentTypes,Method method){\r\n    Class<?>[] classes = method.getParameterTypes();\r\n    Type[] types = new Type[classes.length];\r\n    for (int i = classes.length - 1; i >= 0; --i) {\r\n        types[i] = getType(classes[i]);\r\n    }\r\n    return types;\r\n}"
}, {
	"Path": "org.joda.time.YearMonthDay.dayOfMonth",
	"Comment": "get the day of month field property which provides access to advanced functionality.",
	"Method": "Property dayOfMonth(){\r\n    return new Property(this, DAY_OF_MONTH);\r\n}"
}, {
	"Path": "org.jooq.conf.Settings.setExecuteUpdateWithoutWhere",
	"Comment": "sets the value of the executeupdatewithoutwhere property.",
	"Method": "void setExecuteUpdateWithoutWhere(ExecuteWithoutWhere value){\r\n    this.executeUpdateWithoutWhere = value;\r\n}"
}, {
	"Path": "jodd.asm7.ByteVector.putByte",
	"Comment": "puts a byte into this byte vector. the byte vector is automatically enlarged if necessary.",
	"Method": "ByteVector putByte(int byteValue){\r\n    int currentLength = length;\r\n    if (currentLength + 1 > data.length) {\r\n        enlarge(1);\r\n    }\r\n    data[currentLength++] = (byte) byteValue;\r\n    length = currentLength;\r\n    return this;\r\n}"
}, {
	"Path": "jodd.db.oom.naming.BaseNamingStrategy.setStrictAnnotationNames",
	"Comment": "defines if annotation names are strict, or if all the naming\trules should apply on them, too.",
	"Method": "void setStrictAnnotationNames(boolean strictAnnotationNames){\r\n    this.strictAnnotationNames = strictAnnotationNames;\r\n}"
}, {
	"Path": "jodd.db.DbQueryBase.prepareQuery",
	"Comment": "prepares the query just after the initialization.\tquery is fully set and ready.",
	"Method": "void prepareQuery(){\r\n    if (fetchSize != 0) {\r\n        setFetchSize(fetchSize);\r\n    }\r\n    if (maxRows != 0) {\r\n        setMaxRows(maxRows);\r\n    }\r\n}"
}, {
	"Path": "jodd.proxetta.asm.ProxettaMethodBuilder.createFirstChainDelegate_Continue",
	"Comment": "continues the creation of the very first method in calling chain that simply delegates invocation to the first proxy method.\tthis method mirrors the target method.",
	"Method": "void createFirstChainDelegate_Continue(TargetMethodData tmd){\r\n    methodVisitor.visitCode();\r\n    if (tmd.msign.isStatic) {\r\n        loadStaticMethodArguments(methodVisitor, tmd.msign);\r\n        methodVisitor.visitMethodInsn(INVOKESTATIC, wd.thisReference, tmd.firstMethodName(), tmd.msign.getDescription(), false);\r\n    } else {\r\n        loadSpecialMethodArguments(methodVisitor, tmd.msign);\r\n        methodVisitor.visitMethodInsn(INVOKESPECIAL, wd.thisReference, tmd.firstMethodName(), tmd.msign.getDescription(), false);\r\n    }\r\n    visitReturn(methodVisitor, tmd.msign, false);\r\n    methodVisitor.visitMaxs(0, 0);\r\n    methodVisitor.visitEnd();\r\n}"
}, {
	"Path": "jodd.io.upload.MultipartStreamParser.getParameter",
	"Comment": "returns single value of a parameter. if parameter name is used for\tmore then one parameter, only the first one will be returned.",
	"Method": "String getParameter(String paramName){\r\n    if (requestParameters == null) {\r\n        return null;\r\n    }\r\n    String[] values = requestParameters.get(paramName);\r\n    if ((values != null) && (values.length > 0)) {\r\n        return values[0];\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "jodd.madvoc.WebApp.registerComponent",
	"Comment": "registers madvoc component instance. use with caution, as injection of\tcomponents registered after this will fail.",
	"Method": "WebApp registerComponent(Class<?> madvocComponent,WebApp registerComponent,Class<T> madvocComponent,Consumer<T> componentConsumer,WebApp registerComponent,Object madvocComponent){\r\n    Objects.requireNonNull(madvocComponent);\r\n    madvocComponentInstances.add(madvocComponent);\r\n    return this;\r\n}"
}, {
	"Path": "org.joda.time.format.DateTimeFormatterBuilder.appendYearOfCentury",
	"Comment": "instructs the printer to emit a numeric year of century field.",
	"Method": "DateTimeFormatterBuilder appendYearOfCentury(int minDigits,int maxDigits){\r\n    return appendDecimal(DateTimeFieldType.yearOfCentury(), minDigits, maxDigits);\r\n}"
}, {
	"Path": "jodd.asm7.MethodVisitor.visitEnd",
	"Comment": "visits the end of the method. this method, which is the last one to be called, is used toinform the visitor that all the annotations and attributes of the method have been visited.",
	"Method": "void visitEnd(){\r\n    if (mv != null) {\r\n        mv.visitEnd();\r\n    }\r\n}"
}, {
	"Path": "org.jooq.impl.TableRecordImpl.setRecordVersionAndTimestamp",
	"Comment": "set a generated version and timestamp value onto this record aftersuccessfully storing the record.",
	"Method": "void setRecordVersionAndTimestamp(BigInteger version,Timestamp timestamp){\r\n    if (version != null) {\r\n        TableField<R, ?> field = getTable().getRecordVersion();\r\n        int fieldIndex = indexOrFail(fieldsRow(), field);\r\n        Object value = field.getDataType().convert(version);\r\n        values[fieldIndex] = value;\r\n        originals[fieldIndex] = value;\r\n        changed.clear(fieldIndex);\r\n    }\r\n    if (timestamp != null) {\r\n        TableField<R, ?> field = getTable().getRecordTimestamp();\r\n        int fieldIndex = indexOrFail(fieldsRow(), field);\r\n        Object value = field.getDataType().convert(timestamp);\r\n        values[fieldIndex] = value;\r\n        originals[fieldIndex] = value;\r\n        changed.clear(fieldIndex);\r\n    }\r\n}"
}, {
	"Path": "org.jooq.TXTFormat.maxRows",
	"Comment": "the maximum number of rows to be included in the format, defaulting to all rows.",
	"Method": "TXTFormat maxRows(int newMaxRows,int maxRows){\r\n    return maxRows;\r\n}"
}, {
	"Path": "com.jayway.jsonpath.JsonPath.read",
	"Comment": "creates a new jsonpath and applies it to the provided json object",
	"Method": "T read(Object jsonObject,T read,Object jsonObject,Configuration configuration,T read,String json,T read,String json,Configuration configuration,T read,URL jsonURL,T read,File jsonFile,T read,File jsonFile,Configuration configuration,T read,InputStream jsonInputStream,T read,InputStream jsonInputStream,Configuration configuration,T read,InputStream jsonInputStream,String charset,Configuration configuration,T read,Object json,String jsonPath,Predicate filters,T read,String json,String jsonPath,Predicate filters,T read,URL jsonURL,String jsonPath,Predicate filters,T read,File jsonFile,String jsonPath,Predicate filters,T read,InputStream jsonInputStream,String jsonPath,Predicate filters){\r\n    return new ParseContextImpl().parse(jsonInputStream).read(jsonPath, filters);\r\n}"
}, {
	"Path": "jodd.io.upload.FileUpload.isFileTooBig",
	"Comment": "returns true if file is too big. file will be marked as invalid.",
	"Method": "boolean isFileTooBig(){\r\n    return fileTooBig;\r\n}"
}, {
	"Path": "jodd.jtx.JtxTransaction.commit",
	"Comment": "commit and completes current transaction. transaction is committed on all attached resources. after, resources\tare detached from the transaction. when this method completes,transaction is no longer\tassociated with current thread.",
	"Method": "void commit(){\r\n    checkTimeout();\r\n    commitOrRollback(true);\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractInterval.toPeriod",
	"Comment": "converts the duration of the interval to a period using thespecified period type.this method should be used to extract the field values describing thedifference between the start and end instants.",
	"Method": "Period toPeriod(Period toPeriod,PeriodType type){\r\n    return new Period(getStartMillis(), getEndMillis(), type, getChronology());\r\n}"
}, {
	"Path": "jodd.util.CharUtil.isUppercaseAlpha",
	"Comment": "returns true if specified character is uppercase ascii.\tif user uses only asciis, it is much much faster.",
	"Method": "boolean isUppercaseAlpha(char c){\r\n    return (c >= 'A') && (c <= 'Z');\r\n}"
}, {
	"Path": "jodd.db.oom.sqlgen.chunks.SqlChunk.separateByCommaOrSpace",
	"Comment": "separates from previous chunk by comma if is of the same type.",
	"Method": "void separateByCommaOrSpace(StringBuilder out){\r\n    if (isPreviousChunkOfSameType()) {\r\n        out.append(',').append(' ');\r\n    } else {\r\n        appendMissingSpace(out);\r\n    }\r\n}"
}, {
	"Path": "jodd.servlet.ServletUtil.readRequestBodyFromReader",
	"Comment": "reads http request body using the request reader. once body is read,\tit cannot be read again!",
	"Method": "String readRequestBodyFromReader(HttpServletRequest request){\r\n    BufferedReader buff = request.getReader();\r\n    StringWriter out = new StringWriter();\r\n    StreamUtil.copy(buff, out);\r\n    return out.toString();\r\n}"
}, {
	"Path": "jodd.servlet.filter.GzipResponseWrapper.createOutputStream",
	"Comment": "creates and returns a servletoutputstream to write the content associated\twith this response.",
	"Method": "ServletOutputStream createOutputStream(){\r\n    GzipResponseStream gzstream = new GzipResponseStream(origResponse);\r\n    gzstream.setBuffer(threshold);\r\n    return gzstream;\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Generator.getTarget",
	"Comment": "options to define where the generated code should be located.",
	"Method": "Target getTarget(){\r\n    return target;\r\n}"
}, {
	"Path": "jodd.http.HttpUtil.parseQuery",
	"Comment": "parses query from give query string. values are optionally decoded.",
	"Method": "HttpMultiMap<String> parseQuery(String query,boolean decode){\r\n    final HttpMultiMap<String> queryMap = HttpMultiMap.newCaseInsensitiveMap();\r\n    if (StringUtil.isBlank(query)) {\r\n        return queryMap;\r\n    }\r\n    int lastNdx = 0;\r\n    while (lastNdx < query.length()) {\r\n        int ndx = query.indexOf('&', lastNdx);\r\n        if (ndx == -1) {\r\n            ndx = query.length();\r\n        }\r\n        final String paramAndValue = query.substring(lastNdx, ndx);\r\n        ndx = paramAndValue.indexOf('=');\r\n        if (ndx == -1) {\r\n            queryMap.add(paramAndValue, null);\r\n        } else {\r\n            String name = paramAndValue.substring(0, ndx);\r\n            if (decode) {\r\n                name = URLDecoder.decodeQuery(name);\r\n            }\r\n            String value = paramAndValue.substring(ndx + 1);\r\n            if (decode) {\r\n                value = URLDecoder.decodeQuery(value);\r\n            }\r\n            queryMap.add(name, value);\r\n        }\r\n        lastNdx += paramAndValue.length() + 1;\r\n    }\r\n    return queryMap;\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractPartial.getFieldTypes",
	"Comment": "gets an array of the field types that this partial supports.the fields are returned largest to smallest, for example hour, minute, second.",
	"Method": "DateTimeFieldType[] getFieldTypes(){\r\n    DateTimeFieldType[] result = new DateTimeFieldType[size()];\r\n    for (int i = 0; i < result.length; i++) {\r\n        result[i] = getFieldType(i);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "jodd.http.net.SocketHttpConnectionProvider.createSSLSocket",
	"Comment": "creates a ssl socket. enables default secure enabled protocols if specified.",
	"Method": "SSLSocket createSSLSocket(String host,int port,int connectionTimeout,boolean trustAll,boolean verifyHttpsHost){\r\n    SocketFactory socketFactory = getSocketFactory(proxy, true, trustAll);\r\n    Socket socket;\r\n    if (connectionTimeout < 0) {\r\n        socket = socketFactory.createSocket(host, port);\r\n    } else {\r\n        socket = new Socket();\r\n        socket.connect(new InetSocketAddress(host, port), connectionTimeout);\r\n    }\r\n    SSLSocket sslSocket;\r\n    if (socket instanceof SSLSocket) {\r\n        sslSocket = (SSLSocket) socket;\r\n    } else {\r\n        if (socketFactory instanceof SSLSocketFactory) {\r\n            sslSocket = (SSLSocket) ((SSLSocketFactory) socketFactory).createSocket(socket, host, port, true);\r\n        } else {\r\n            sslSocket = (SSLSocket) (getDefaultSSLSocketFactory(trustAll)).createSocket(socket, host, port, true);\r\n        }\r\n    }\r\n    if (secureEnabledProtocols != null) {\r\n        final String[] values = StringUtil.splitc(secureEnabledProtocols, ',');\r\n        StringUtil.trimAll(values);\r\n        sslSocket.setEnabledProtocols(values);\r\n    }\r\n    if (verifyHttpsHost) {\r\n        final SSLParameters sslParams = new SSLParameters();\r\n        sslParams.setEndpointIdentificationAlgorithm(\"HTTPS\");\r\n        sslSocket.setSSLParameters(sslParams);\r\n    }\r\n    return sslSocket;\r\n}"
}, {
	"Path": "org.joda.time.MutablePeriod.copy",
	"Comment": "clone this object without having to cast the returned object.",
	"Method": "MutablePeriod copy(){\r\n    return (MutablePeriod) clone();\r\n}"
}, {
	"Path": "org.joda.time.LocalDate.toInterval",
	"Comment": "converts this object to an interval representing the whole day.the interval may have more or less than 24 hours if this is a daylightsavings cutover date.this instance is immutable and unaffected by this method call.",
	"Method": "Interval toInterval(Interval toInterval,DateTimeZone zone){\r\n    zone = DateTimeUtils.getZone(zone);\r\n    DateTime start = toDateTimeAtStartOfDay(zone);\r\n    DateTime end = plusDays(1).toDateTimeAtStartOfDay(zone);\r\n    return new Interval(start, end);\r\n}"
}, {
	"Path": "jodd.jtx.JtxTransactionManager.isSingleResourceManager",
	"Comment": "returns true if this transaction manager works with just one resource.",
	"Method": "boolean isSingleResourceManager(){\r\n    return oneResourceManager;\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Generate.isCommentsOnUDTs",
	"Comment": "turn off generation of all sql comments as javadoc on all udts.",
	"Method": "Boolean isCommentsOnUDTs(){\r\n    return commentsOnUDTs;\r\n}"
}, {
	"Path": "org.joda.example.time.DateTimeBrowser.go",
	"Comment": "go this method reads the file, creates the table to display,the window to display it in, and displays the window.",
	"Method": "void go(String[] args){\r\n    mainArgs = args;\r\n    setDefaultTimeZone();\r\n    setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);\r\n    JMenuBar menuBar = new JMenuBar();\r\n    setJMenuBar(menuBar);\r\n    addMenus(menuBar);\r\n    addWindowListener(new WindowAdapter() {\r\n        public void windowClosing(WindowEvent e) {\r\n            setVisible(false);\r\n            dispose();\r\n            System.exit(0);\r\n        }\r\n    });\r\n    currFile = new LoadedFile(mainArgs[0]);\r\n    TableView tView = getDefaultTableView();\r\n    resetDefaults(tView);\r\n    Dimension screenMax = Toolkit.getDefaultToolkit().getScreenSize();\r\n    setSize(screenMax);\r\n    setVisible(true);\r\n}"
}, {
	"Path": "org.joda.example.time.DateTimeBrowser.go",
	"Comment": "go this method reads the file, creates the table to display,the window to display it in, and displays the window.",
	"Method": "void go(String[] args){\r\n    setVisible(false);\r\n    dispose();\r\n    System.exit(0);\r\n}"
}, {
	"Path": "org.joda.time.Period.plusMonths",
	"Comment": "returns a new period plus the specified number of months added.this period instance is immutable and unaffected by this method call.",
	"Method": "Period plusMonths(int months){\r\n    if (months == 0) {\r\n        return this;\r\n    }\r\n    int[] values = getValues();\r\n    getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, months);\r\n    return new Period(values, getPeriodType());\r\n}"
}, {
	"Path": "jodd.asm7.SymbolTable.get",
	"Comment": "returns the list of entries which can potentially have the given hash code.",
	"Method": "Entry get(int hashCode){\r\n    return entries[hashCode % entries.length];\r\n}"
}, {
	"Path": "jodd.util.collection.SetMapAdapter.remove",
	"Comment": "removes the specified element from this set if it is present.",
	"Method": "boolean remove(Object o){\r\n    return map.remove(o) == DUMMY_VALUE;\r\n}"
}, {
	"Path": "jodd.db.oom.sqlgen.DbSqlBuilder.aliasColumnsAs",
	"Comment": "specifies column alias type. may be null when column aliases are not used.",
	"Method": "DbSqlBuilder aliasColumnsAs(ColumnAliasType aliasesType){\r\n    this.columnAliasType = aliasesType;\r\n    return this;\r\n}"
}, {
	"Path": "org.apache.jorphan.reflect.TestClassTools.testConstructStringString",
	"Comment": "test that a class can be constructed using an constructor with an stringparameter",
	"Method": "void testConstructStringString(){\r\n    String dummy = (String) ClassTools.construct(\"java.lang.String\", \"hello\");\r\n    assertNotNull(dummy);\r\n    assertEquals(\"hello\", dummy);\r\n}"
}, {
	"Path": "jodd.util.StringUtil.findCommonPrefix",
	"Comment": "finds common prefix for several strings. returns an empty string if\targuments do not have a common prefix.",
	"Method": "String findCommonPrefix(String strings){\r\n    StringBuilder prefix = new StringBuilder();\r\n    int index = 0;\r\n    char c = 0;\r\n    loop: while (true) {\r\n        for (int i = 0; i < strings.length; i++) {\r\n            String s = strings[i];\r\n            if (index == s.length()) {\r\n                break loop;\r\n            }\r\n            if (i == 0) {\r\n                c = s.charAt(index);\r\n            } else {\r\n                if (s.charAt(index) != c) {\r\n                    break loop;\r\n                }\r\n            }\r\n        }\r\n        index++;\r\n        prefix.append(c);\r\n    }\r\n    return prefix.length() == 0 ? StringPool.EMPTY : prefix.toString();\r\n}"
}, {
	"Path": "org.joda.time.format.DateTimeFormatterBuilder.appendHourOfHalfday",
	"Comment": "instructs the printer to emit a numeric hourofhalfday field.",
	"Method": "DateTimeFormatterBuilder appendHourOfHalfday(int minDigits){\r\n    return appendDecimal(DateTimeFieldType.hourOfHalfday(), minDigits, 2);\r\n}"
}, {
	"Path": "jodd.madvoc.MadvocRouter.filter",
	"Comment": "returns action filter instance for further configuration.",
	"Method": "MadvocRouter filter(Class<T> actionFilterClass,MadvocRouter filter,Class<T> actionFilterClass,Consumer<T> filterConsumer){\r\n    T filter = (T) filtersManager.resolve(actionFilterClass);\r\n    filterConsumer.accept(filter);\r\n    return this;\r\n}"
}, {
	"Path": "org.joda.time.LocalDate.withYear",
	"Comment": "returns a copy of this date with the year field updated.localdate is immutable, so there are no set methods.instead, this method returns a new instance with the value ofyear changed.",
	"Method": "LocalDate withYear(int year){\r\n    return withLocalMillis(getChronology().year().set(getLocalMillis(), year));\r\n}"
}, {
	"Path": "jodd.io.findfile.FindFile.lastFile",
	"Comment": "returns last founded file.\treturns null at the very beginning.",
	"Method": "File lastFile(){\r\n    return lastFile;\r\n}"
}, {
	"Path": "org.joda.time.DateMidnight.withMonthOfYear",
	"Comment": "returns a copy of this date with the month of year field updated.datemidnight is immutable, so there are no set methods.instead, this method returns a new instance with the value ofmonth of year changed.",
	"Method": "DateMidnight withMonthOfYear(int monthOfYear){\r\n    return withMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear));\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.rtsp.RtspClient.setCallback",
	"Comment": "sets the callback interface that will be called on status updates of the connection\twith the rtsp server.",
	"Method": "void setCallback(Callback cb){\r\n    mCallback = cb;\r\n}"
}, {
	"Path": "org.apache.jorphan.exec.TestKeyToolUtils.testCheckKeytool",
	"Comment": "check the assumption that a missing executable will generateeither an ioexception or status which is neither 0 nor 1",
	"Method": "void testCheckKeytool(){\r\n    SystemCommand sc = new SystemCommand(null, null);\r\n    List<String> arguments = new ArrayList();\r\n    arguments.add(\"xyzqwas\");\r\n    try {\r\n        int status = sc.run(arguments);\r\n        if (status == 0 || status == 1) {\r\n            fail(\"Unexpected status \" + status);\r\n        }\r\n    } catch (IOException expected) {\r\n    }\r\n}"
}, {
	"Path": "jodd.asm7.Type.getElementType",
	"Comment": "returns the type of the elements of this array type. this method should only be used for anarray type.",
	"Method": "Type getElementType(){\r\n    final int numDimensions = getDimensions();\r\n    return getTypeInternal(valueBuffer, valueBegin + numDimensions, valueEnd);\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.withYearOfCentury",
	"Comment": "returns a copy of this datetime with the year of century field updated.localdatetime is immutable, so there are no set methods.instead, this method returns a new instance with the value ofyear of century changed.",
	"Method": "LocalDateTime withYearOfCentury(int yearOfCentury){\r\n    return withLocalMillis(getChronology().yearOfCentury().set(getLocalMillis(), yearOfCentury));\r\n}"
}, {
	"Path": "org.joda.time.field.RemainderDateTimeField.getMaximumValue",
	"Comment": "get the maximum value for the field, which is always one less than thedivisor.",
	"Method": "int getMaximumValue(){\r\n    return iDivisor - 1;\r\n}"
}, {
	"Path": "org.joda.time.Period.toStandardDuration",
	"Comment": "converts this period to a duration assuming a7 day week, 24 hour day, 60 minute hour and 60 second minute.this method allows you to convert from a period to a duration.however to achieve this it makes the assumption that allweeks are 7 days, all days are 24 hours, all hours are 60 minutes andall minutes are 60 seconds. this is not true when daylight savings timeis considered, and may also not be true for some unusual chronologies.however, it is included as it is a useful operation for manyapplications and business rules.if the period contains years or months, an exception will be thrown.",
	"Method": "Duration toStandardDuration(){\r\n    checkYearsAndMonths(\"Duration\");\r\n    long millis = getMillis();\r\n    millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\r\n    millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\r\n    millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\r\n    millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\r\n    millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\r\n    return new Duration(millis);\r\n}"
}, {
	"Path": "jodd.introspector.PropertyDescriptor.isFieldOnly",
	"Comment": "returns true if this is an extended property with\tonly field definition and without getter and setter.",
	"Method": "boolean isFieldOnly(){\r\n    return (readMethodDescriptor == null) && (writeMethodDescriptor == null);\r\n}"
}, {
	"Path": "org.joda.time.MutableDateTime.set",
	"Comment": "sets the value of one of the fields of the instant, such as hourofday.",
	"Method": "void set(DateTimeFieldType type,int value,MutableDateTime set,int value,MutableDateTime set,String text,Locale locale,MutableDateTime set,String text){\r\n    if (type == null) {\r\n        throw new IllegalArgumentException(\"Field must not be null\");\r\n    }\r\n    setMillis(type.getField(getChronology()).set(getMillis(), value));\r\n}"
}, {
	"Path": "org.joda.time.format.DateTimeFormatterBuilder.canBuildParser",
	"Comment": "returns true if toparser can be called without throwing anunsupportedoperationexception.",
	"Method": "boolean canBuildParser(){\r\n    return isParser(getFormatter());\r\n}"
}, {
	"Path": "org.joda.time.convert.ReadableIntervalConverter.isReadableInterval",
	"Comment": "checks if the input is a readableinterval.if it is, then the calling code should cast and copy the fields directly.",
	"Method": "boolean isReadableInterval(Object object,Chronology chrono){\r\n    return true;\r\n}"
}, {
	"Path": "jodd.exception.UncheckedException.runAndWrapException",
	"Comment": "wraps checked exceptions in a uncheckedexception.\tunchecked exceptions are not wrapped.",
	"Method": "void runAndWrapException(CallableVoid callable){\r\n    try {\r\n        callable.call();\r\n    } catch (IOException ioex) {\r\n        throw new UncheckedIOException(ioex);\r\n    } catch (RuntimeException rtex) {\r\n        throw rtex;\r\n    } catch (Exception t) {\r\n        throw new UncheckedException(t);\r\n    }\r\n}"
}, {
	"Path": "jodd.proxetta.Proxetta.setClassLoader",
	"Comment": "specifies classloaders for loading created classes.\tif classloader not specified, default one will be used.",
	"Method": "T setClassLoader(ClassLoader classLoader){\r\n    this.classLoader = classLoader;\r\n    return _this();\r\n}"
}, {
	"Path": "org.joda.time.Weeks.weeksBetween",
	"Comment": "creates a weeks representing the number of whole weeksbetween the two specified partial datetimes.the two partials must contain the same fields, for example you can specifytwo localdate objects.",
	"Method": "Weeks weeksBetween(ReadableInstant start,ReadableInstant end,Weeks weeksBetween,ReadablePartial start,ReadablePartial end){\r\n    if (start instanceof LocalDate && end instanceof LocalDate) {\r\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\r\n        int weeks = chrono.weeks().getDifference(((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\r\n        return Weeks.weeks(weeks);\r\n    }\r\n    int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\r\n    return Weeks.weeks(amount);\r\n}"
}, {
	"Path": "org.joda.time.DateTimeZone.forOffsetMillis",
	"Comment": "gets a time zone instance for the specified offset to utc in milliseconds.",
	"Method": "DateTimeZone forOffsetMillis(int millisOffset){\r\n    if (millisOffset < -MAX_MILLIS || millisOffset > MAX_MILLIS) {\r\n        throw new IllegalArgumentException(\"Millis out of range: \" + millisOffset);\r\n    }\r\n    String id = printOffset(millisOffset);\r\n    return fixedOffsetZone(id, millisOffset);\r\n}"
}, {
	"Path": "org.joda.time.chrono.EthiopicChronology.getInstance",
	"Comment": "gets an instance of the ethiopicchronology in the given time zone.",
	"Method": "EthiopicChronology getInstance(EthiopicChronology getInstance,DateTimeZone zone,EthiopicChronology getInstance,DateTimeZone zone,int minDaysInFirstWeek){\r\n    if (zone == null) {\r\n        zone = DateTimeZone.getDefault();\r\n    }\r\n    EthiopicChronology chrono;\r\n    EthiopicChronology[] chronos = cCache.get(zone);\r\n    if (chronos == null) {\r\n        chronos = new EthiopicChronology[7];\r\n        EthiopicChronology[] oldChronos = cCache.putIfAbsent(zone, chronos);\r\n        if (oldChronos != null) {\r\n            chronos = oldChronos;\r\n        }\r\n    }\r\n    try {\r\n        chrono = chronos[minDaysInFirstWeek - 1];\r\n    } catch (ArrayIndexOutOfBoundsException e) {\r\n        throw new IllegalArgumentException(\"Invalid min days in first week: \" + minDaysInFirstWeek);\r\n    }\r\n    if (chrono == null) {\r\n        synchronized (chronos) {\r\n            chrono = chronos[minDaysInFirstWeek - 1];\r\n            if (chrono == null) {\r\n                if (zone == DateTimeZone.UTC) {\r\n                    chrono = new EthiopicChronology(null, null, minDaysInFirstWeek);\r\n                    DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);\r\n                    chrono = new EthiopicChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, minDaysInFirstWeek);\r\n                } else {\r\n                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\r\n                    chrono = new EthiopicChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);\r\n                }\r\n                chronos[minDaysInFirstWeek - 1] = chrono;\r\n            }\r\n        }\r\n    }\r\n    return chrono;\r\n}"
}, {
	"Path": "org.joda.time.base.BaseSingleFieldPeriod.isSupported",
	"Comment": "checks whether the duration field specified is supported by this period.",
	"Method": "boolean isSupported(DurationFieldType type){\r\n    return (type == getFieldType());\r\n}"
}, {
	"Path": "jodd.madvoc.config.InjectionPoint.targetName",
	"Comment": "returns real targets name, used for writing and reading directly to the target.",
	"Method": "String targetName(){\r\n    return targetName != null ? targetName : name;\r\n}"
}, {
	"Path": "org.joda.time.LocalDateTime.withMonthOfYear",
	"Comment": "returns a copy of this datetime with the month of year field updated.localdatetime is immutable, so there are no set methods.instead, this method returns a new instance with the value ofmonth of year changed.",
	"Method": "LocalDateTime withMonthOfYear(int monthOfYear){\r\n    return withLocalMillis(getChronology().monthOfYear().set(getLocalMillis(), monthOfYear));\r\n}"
}, {
	"Path": "jodd.util.StringUtil.toLowerCase",
	"Comment": "converts all of the characters in the string to lower case, based on the\tlocale. more efficient than string.tolowercase.",
	"Method": "String toLowerCase(String s,String toLowerCase,String s,Locale locale){\r\n    if (s == null) {\r\n        return null;\r\n    }\r\n    StringBuilder sb = null;\r\n    for (int i = 0; i < s.length(); i++) {\r\n        char c = s.charAt(i);\r\n        if (c > 127) {\r\n            if (locale == null) {\r\n                locale = Locale.getDefault();\r\n            }\r\n            return s.toLowerCase(locale);\r\n        }\r\n        if ((c >= 'A') && (c <= 'Z')) {\r\n            if (sb == null) {\r\n                sb = new StringBuilder(s);\r\n            }\r\n            sb.setCharAt(i, (char) (c + 32));\r\n        }\r\n    }\r\n    if (sb == null) {\r\n        return s;\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.joda.time.DateTime.dayOfWeek",
	"Comment": "get the day of week property which provides access to advanced functionality.",
	"Method": "Property dayOfWeek(){\r\n    return new Property(this, getChronology().dayOfWeek());\r\n}"
}, {
	"Path": "jodd.servlet.filter.GzipResponseStream.flush",
	"Comment": "flushes any buffered data for this output stream, which also causes the\tresponse to be committed.",
	"Method": "void flush(){\r\n    if (closed) {\r\n        return;\r\n    }\r\n    if (gzipstream != null) {\r\n        gzipstream.flush();\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.PeriodType.yearMonthDay",
	"Comment": "gets a type that defines the year, month and day fields.yearsmonthsdays",
	"Method": "PeriodType yearMonthDay(){\r\n    PeriodType type = cYMD;\r\n    if (type == null) {\r\n        type = new PeriodType(\"YearMonthDay\", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.months(), DurationFieldType.days() }, new int[] { 0, 1, -1, 2, -1, -1, -1, -1 });\r\n        cYMD = type;\r\n    }\r\n    return type;\r\n}"
}, {
	"Path": "org.jooq.impl.DSL.dateDiff",
	"Comment": "get the date difference in number of days.this translates into any dialect",
	"Method": "Field<Integer> dateDiff(Date date1,Date date2,Field<Integer> dateDiff,Field<Date> date1,Date date2,Field<Integer> dateDiff,Date date1,Field<Date> date2,Field<Integer> dateDiff,Field<Date> date1,Field<Date> date2){\r\n    return new DateDiff<Date>(nullSafe(date1), nullSafe(date2));\r\n}"
}, {
	"Path": "org.jooq.impl.TableList.toSQLFields",
	"Comment": "get a list of names of the namedqueryparts contained in thislist.",
	"Method": "void toSQLFields(Context<?> ctx){\r\n    String separator = \"\";\r\n    boolean unqualified = UNQUALIFY_FIELDS.contains(ctx.family());\r\n    boolean qualify = ctx.qualify();\r\n    if (unqualified)\r\n        ctx.qualify(false);\r\n    for (Table<?> table : this) {\r\n        for (Field<?> field : table.fieldsRow().fields()) {\r\n            ctx.sql(separator);\r\n            ctx.visit(field);\r\n            separator = \", \";\r\n        }\r\n    }\r\n    if (unqualified)\r\n        ctx.qualify(qualify);\r\n}"
}, {
	"Path": "org.jooq.codegen.JavaGenerator.generatePojoMultiConstructor",
	"Comment": "subclasses may override this method to provide their own pojo copy constructors.",
	"Method": "void generatePojoMultiConstructor(Definition tableOrUDT,JavaWriter out){\r\n    final String className = getStrategy().getJavaClassName(tableOrUDT, Mode.POJO);\r\n    int maxLength = 0;\r\n    for (TypedElementDefinition<?> column : getTypedElements(tableOrUDT)) maxLength = Math.max(maxLength, out.ref(getJavaType(column.getType(resolver(Mode.POJO)), Mode.POJO)).length());\r\n    if (scala) {\r\n    } else if (getTypedElements(tableOrUDT).size() > 0 && getTypedElements(tableOrUDT).size() < 256) {\r\n        out.println();\r\n        out.tab(1).print(\"public %s(\", className);\r\n        String separator1 = \"\";\r\n        for (TypedElementDefinition<?> column : getTypedElements(tableOrUDT)) {\r\n            out.println(separator1);\r\n            out.tab(2).print(\"%s %s\", StringUtils.rightPad(out.ref(getJavaType(column.getType(resolver(Mode.POJO)), Mode.POJO)), maxLength), getStrategy().getJavaMemberName(column, Mode.POJO));\r\n            separator1 = \",\";\r\n        }\r\n        out.println();\r\n        out.tab(1).println(\") {\");\r\n        for (TypedElementDefinition<?> column : getTypedElements(tableOrUDT)) {\r\n            final String columnMember = getStrategy().getJavaMemberName(column, Mode.POJO);\r\n            out.tab(2).println(\"this.%s = %s;\", columnMember, columnMember);\r\n        }\r\n        out.tab(1).println(\"}\");\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.LocalDate.withMonthOfYear",
	"Comment": "returns a copy of this date with the month of year field updated.localdate is immutable, so there are no set methods.instead, this method returns a new instance with the value ofmonth of year changed.",
	"Method": "LocalDate withMonthOfYear(int monthOfYear){\r\n    return withLocalMillis(getChronology().monthOfYear().set(getLocalMillis(), monthOfYear));\r\n}"
}, {
	"Path": "org.jooq.types.UInteger.mkValues",
	"Comment": "generate a cached value for initial unsigned integer values.",
	"Method": "UInteger[] mkValues(){\r\n    int precacheSize = getPrecacheSize();\r\n    UInteger[] ret;\r\n    if (precacheSize <= 0)\r\n        return null;\r\n    ret = new UInteger[precacheSize];\r\n    for (int i = 0; i < precacheSize; i++) ret[i] = new UInteger(i);\r\n    return ret;\r\n}"
}, {
	"Path": "jodd.asm7.MethodWriter.collectAttributePrototypes",
	"Comment": "collects the attributes of this method into the given set of attribute prototypes.",
	"Method": "void collectAttributePrototypes(Attribute.Set attributePrototypes){\r\n    attributePrototypes.addAttributes(firstAttribute);\r\n    attributePrototypes.addAttributes(firstCodeAttribute);\r\n}"
}, {
	"Path": "jodd.util.ClassUtil.isAssignableFrom",
	"Comment": "returns true if the first member is accessible from second one.",
	"Method": "boolean isAssignableFrom(Member member1,Member member2){\r\n    return member1.getDeclaringClass().isAssignableFrom(member2.getDeclaringClass());\r\n}"
}, {
	"Path": "jodd.util.StringUtil.capitalize",
	"Comment": "capitalizes a string, changing the first letter to\tupper case. no other letters are changed.",
	"Method": "String capitalize(String str){\r\n    return changeFirstCharacterCase(true, str);\r\n}"
}, {
	"Path": "jodd.lagarto.dom.Node.initChildNodes",
	"Comment": "initializes child nodes list when needed.\talso fix owner document for new node, if needed.",
	"Method": "void initChildNodes(Node newNode){\r\n    if (childNodes == null) {\r\n        childNodes = new ArrayList();\r\n    }\r\n    if (ownerDocument != null) {\r\n        if (newNode.ownerDocument != ownerDocument) {\r\n            changeOwnerDocument(newNode, ownerDocument);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.format.DateTimeParserBucket.restoreState",
	"Comment": "restores the state of this bucket from a previously saved state. thestate object passed into this method is not consumed, and it can be usedlater to restore to that state again.",
	"Method": "boolean restoreState(Object savedState,boolean restoreState,DateTimeParserBucket enclosing){\r\n    if (savedState instanceof SavedState) {\r\n        if (((SavedState) savedState).restoreState(this)) {\r\n            iSavedState = savedState;\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "jodd.madvoc.result.ServletDispatcherActionResult.locateTarget",
	"Comment": "locates target using path with various extensions appended.",
	"Method": "String locateTarget(ActionRequest actionRequest,String path){\r\n    String target;\r\n    if (path.endsWith(StringPool.SLASH)) {\r\n        path = path + defaultViewPageName;\r\n    }\r\n    for (final String ext : defaultViewExtensions) {\r\n        target = path + ext;\r\n        if (targetExists(actionRequest, target)) {\r\n            return target;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "jodd.io.upload.FileUploadHeader.getContentType",
	"Comment": "strips content type information from requests data header.",
	"Method": "String getContentType(String dataHeader,String getContentType){\r\n    return contentType;\r\n}"
}, {
	"Path": "jodd.asm7.MethodVisitor.visitMaxs",
	"Comment": "visits the maximum stack size and the maximum number of local variables of the method.",
	"Method": "void visitMaxs(int maxStack,int maxLocals){\r\n    if (mv != null) {\r\n        mv.visitMaxs(maxStack, maxLocals);\r\n    }\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.gl.TextureManager.createTexture",
	"Comment": "initializes gl state.call this after the egl surface has been created and made current.",
	"Method": "SurfaceTexture createTexture(){\r\n    mProgram = createProgram(VERTEX_SHADER, FRAGMENT_SHADER);\r\n    if (mProgram == 0) {\r\n        throw new RuntimeException(\"failed creating program\");\r\n    }\r\n    maPositionHandle = GLES20.glGetAttribLocation(mProgram, \"aPosition\");\r\n    checkGlError(\"glGetAttribLocation aPosition\");\r\n    if (maPositionHandle == -1) {\r\n        throw new RuntimeException(\"Could not get attrib location for aPosition\");\r\n    }\r\n    maTextureHandle = GLES20.glGetAttribLocation(mProgram, \"aTextureCoord\");\r\n    checkGlError(\"glGetAttribLocation aTextureCoord\");\r\n    if (maTextureHandle == -1) {\r\n        throw new RuntimeException(\"Could not get attrib location for aTextureCoord\");\r\n    }\r\n    muMVPMatrixHandle = GLES20.glGetUniformLocation(mProgram, \"uMVPMatrix\");\r\n    checkGlError(\"glGetUniformLocation uMVPMatrix\");\r\n    if (muMVPMatrixHandle == -1) {\r\n        throw new RuntimeException(\"Could not get attrib location for uMVPMatrix\");\r\n    }\r\n    muSTMatrixHandle = GLES20.glGetUniformLocation(mProgram, \"uSTMatrix\");\r\n    checkGlError(\"glGetUniformLocation uSTMatrix\");\r\n    if (muSTMatrixHandle == -1) {\r\n        throw new RuntimeException(\"Could not get attrib location for uSTMatrix\");\r\n    }\r\n    int[] textures = new int[1];\r\n    GLES20.glGenTextures(1, textures, 0);\r\n    mTextureID = textures[0];\r\n    GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, mTextureID);\r\n    checkGlError(\"glBindTexture mTextureID\");\r\n    GLES20.glTexParameterf(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_NEAREST);\r\n    GLES20.glTexParameterf(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);\r\n    GLES20.glTexParameteri(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);\r\n    GLES20.glTexParameteri(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);\r\n    checkGlError(\"glTexParameter\");\r\n    mSurfaceTexture = new SurfaceTexture(mTextureID);\r\n    return mSurfaceTexture;\r\n}"
}, {
	"Path": "org.joda.time.LocalDate.toLocalDateTime",
	"Comment": "converts this object to a localdatetime using a localtime to fill inthe missing fields.the resulting chronology is determined by the chronology of thislocaldate. the chronology of the time must also match.if the time is null an exception is thrown.this instance is immutable and unaffected by this method call.",
	"Method": "LocalDateTime toLocalDateTime(LocalTime time){\r\n    if (time == null) {\r\n        throw new IllegalArgumentException(\"The time must not be null\");\r\n    }\r\n    if (getChronology() != time.getChronology()) {\r\n        throw new IllegalArgumentException(\"The chronology of the time does not match\");\r\n    }\r\n    long localMillis = getLocalMillis() + time.getLocalMillis();\r\n    return new LocalDateTime(localMillis, getChronology());\r\n}"
}, {
	"Path": "jodd.lagarto.filter.LagartoServletFilter.processActionPath",
	"Comment": "manually process the action path and returns true if path is consumed.\twhen path is consumed, filter chain is not continued.\tby default, it returns false.",
	"Method": "boolean processActionPath(HttpServletRequest servletRequest,HttpServletResponse servletResponse,String actionPath){\r\n    return false;\r\n}"
}, {
	"Path": "org.joda.time.Duration.withMillis",
	"Comment": "creates a new duration instance with a different millisecond length.",
	"Method": "Duration withMillis(long duration){\r\n    if (duration == getMillis()) {\r\n        return this;\r\n    }\r\n    return new Duration(duration);\r\n}"
}, {
	"Path": "org.joda.time.Duration.toStandardDays",
	"Comment": "converts this duration to a period in days assuming that there are thestandard number of milliseconds in a day.this method assumes that there are 24 hours in a day,60 minutes in an hour, 60 seconds in a minute and 1000 milliseconds ina second. this will be true for most days, however days with daylightsavings changes will not have 24 hours, so use this method with care.",
	"Method": "Days toStandardDays(){\r\n    long days = getStandardDays();\r\n    return Days.days(FieldUtils.safeToInt(days));\r\n}"
}, {
	"Path": "jodd.http.HttpBase.form",
	"Comment": "adds the form parameter. existing parameter will not be overwritten.",
	"Method": "T form(String name,Object value,T form,String name,Object value,Object parameters,T form,Map<String, Object> formMap,HttpMultiMap<?> form){\r\n    return form;\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Generate.isVarargSetters",
	"Comment": "generate varargs setters for array types for convenience.this may lead to compilation warnings in current java versions.",
	"Method": "Boolean isVarargSetters(){\r\n    return varargSetters;\r\n}"
}, {
	"Path": "jodd.asm7.signature.SignatureVisitor.visitClassBound",
	"Comment": "visits the class bound of the last visited formal type parameter.",
	"Method": "SignatureVisitor visitClassBound(){\r\n    return this;\r\n}"
}, {
	"Path": "jodd.db.oom.sqlgen.DbEntitySql.createTableRefName",
	"Comment": "creates table reference name from entity type.\talways appends an underscore to reference name in order\tto circumvent sql compatibility issues when entity class name\tequals to a reserved word.",
	"Method": "String createTableRefName(Object entity){\r\n    Class type = entity.getClass();\r\n    type = (type == Class.class ? (Class) entity : type);\r\n    return (type.getSimpleName() + '_');\r\n}"
}, {
	"Path": "org.json.JSONTokener.skipTo",
	"Comment": "skip characters until the next character is the requested character.if the requested character is not found, no characters are skipped.",
	"Method": "char skipTo(char to){\r\n    char c;\r\n    try {\r\n        long startIndex = this.index;\r\n        long startCharacter = this.character;\r\n        long startLine = this.line;\r\n        this.reader.mark(1000000);\r\n        do {\r\n            c = this.next();\r\n            if (c == 0) {\r\n                this.reader.reset();\r\n                this.index = startIndex;\r\n                this.character = startCharacter;\r\n                this.line = startLine;\r\n                return 0;\r\n            }\r\n        } while (c != to);\r\n        this.reader.mark(1);\r\n    } catch (IOException exception) {\r\n        throw new JSONException(exception);\r\n    }\r\n    this.back();\r\n    return c;\r\n}"
}, {
	"Path": "jodd.asm7.Label.resolve",
	"Comment": "sets the bytecode offset of this label to the given value and resolves the forward referencesto this label, if any. this method must be called when this label is added to the bytecode ofthe method, i.e. when its bytecode offset becomes known. this method fills in the blanks thatwhere left in the bytecode by each forward reference previously added to this label.",
	"Method": "boolean resolve(byte[] code,int bytecodeOffset){\r\n    this.flags |= FLAG_RESOLVED;\r\n    this.bytecodeOffset = bytecodeOffset;\r\n    if (forwardReferences == null) {\r\n        return false;\r\n    }\r\n    boolean hasAsmInstructions = false;\r\n    for (int i = forwardReferences[0]; i > 0; i -= 2) {\r\n        final int sourceInsnBytecodeOffset = forwardReferences[i - 1];\r\n        final int reference = forwardReferences[i];\r\n        final int relativeOffset = bytecodeOffset - sourceInsnBytecodeOffset;\r\n        int handle = reference & FORWARD_REFERENCE_HANDLE_MASK;\r\n        if ((reference & FORWARD_REFERENCE_TYPE_MASK) == FORWARD_REFERENCE_TYPE_SHORT) {\r\n            if (relativeOffset < Short.MIN_VALUE || relativeOffset > Short.MAX_VALUE) {\r\n                int opcode = code[sourceInsnBytecodeOffset] & 0xFF;\r\n                if (opcode < Opcodes.IFNULL) {\r\n                    code[sourceInsnBytecodeOffset] = (byte) (opcode + Constants.ASM_OPCODE_DELTA);\r\n                } else {\r\n                    code[sourceInsnBytecodeOffset] = (byte) (opcode + Constants.ASM_IFNULL_OPCODE_DELTA);\r\n                }\r\n                hasAsmInstructions = true;\r\n            }\r\n            code[handle++] = (byte) (relativeOffset >>> 8);\r\n            code[handle] = (byte) relativeOffset;\r\n        } else {\r\n            code[handle++] = (byte) (relativeOffset >>> 24);\r\n            code[handle++] = (byte) (relativeOffset >>> 16);\r\n            code[handle++] = (byte) (relativeOffset >>> 8);\r\n            code[handle] = (byte) relativeOffset;\r\n        }\r\n    }\r\n    return hasAsmInstructions;\r\n}"
}, {
	"Path": "jodd.htmlstapler.HtmlStaplerBundlesManager.reset",
	"Comment": "clears all settings and removes all created bundle files from file system.",
	"Method": "void reset(){\r\n    if (strategy == Strategy.ACTION_MANAGED) {\r\n        actionBundles.clear();\r\n        mirrors.clear();\r\n    }\r\n    FindFile ff = new FindFile();\r\n    ff.includeDirs(false);\r\n    ff.searchPath(new File(bundleFolder, staplerPath));\r\n    File f;\r\n    int count = 0;\r\n    while ((f = ff.nextFile()) != null) {\r\n        f.delete();\r\n        count++;\r\n    }\r\n    if (log.isInfoEnabled()) {\r\n        log.info(\"reset: \" + count + \" bundle files deleted.\");\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.LocalDate.withYearOfCentury",
	"Comment": "returns a copy of this date with the year of century field updated.localdate is immutable, so there are no set methods.instead, this method returns a new instance with the value ofyear of century changed.",
	"Method": "LocalDate withYearOfCentury(int yearOfCentury){\r\n    return withLocalMillis(getChronology().yearOfCentury().set(getLocalMillis(), yearOfCentury));\r\n}"
}, {
	"Path": "jodd.lagarto.dom.MalformedTest.read",
	"Comment": "reads test file and returns its content optionally stripped.",
	"Method": "String read(String filename,boolean strip){\r\n    String data = FileUtil.readString(new File(testDataRoot, filename));\r\n    if (strip) {\r\n        data = strip(data);\r\n    }\r\n    return data;\r\n}"
}, {
	"Path": "com.jayway.jsonpath.Criteria.matches",
	"Comment": "the matches operator checks that an object matches the given predicate.",
	"Method": "Criteria matches(Predicate p){\r\n    this.criteriaType = RelationalOperator.MATCHES;\r\n    this.right = new ValueNode.PredicateNode(p);\r\n    return this;\r\n}"
}, {
	"Path": "org.joda.time.LocalDate.withDayOfWeek",
	"Comment": "returns a copy of this date with the day of week field updated.localdate is immutable, so there are no set methods.instead, this method returns a new instance with the value ofday of week changed.",
	"Method": "LocalDate withDayOfWeek(int dayOfWeek){\r\n    return withLocalMillis(getChronology().dayOfWeek().set(getLocalMillis(), dayOfWeek));\r\n}"
}, {
	"Path": "jodd.introspector.Descriptor.matchDeclared",
	"Comment": "returns true if descriptor content matches required declared flag.",
	"Method": "boolean matchDeclared(boolean declared){\r\n    if (!declared) {\r\n        return isPublic;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "jodd.io.upload.MultipartRequestInputStream.copyMax",
	"Comment": "copies max or less number of bytes to output stream. useful for determining\tif uploaded file is larger then expected.",
	"Method": "int copyMax(OutputStream out,int maxBytes){\r\n    int count = 0;\r\n    while (true) {\r\n        byte b = readByte();\r\n        if (isBoundary(b)) {\r\n            break;\r\n        }\r\n        out.write(b);\r\n        count++;\r\n        if (count == maxBytes) {\r\n            return count;\r\n        }\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "jodd.madvoc.component.ActionMethodParser.parse",
	"Comment": "parses java action method annotation and returns its action runtime.",
	"Method": "ActionRuntime parse(Class<?> actionClass,Method actionMethod,ActionDefinition actionDefinition){\r\n    final ActionAnnotationValues annotationValues = detectActionAnnotationValues(actionMethod);\r\n    final ActionConfig actionConfig = resolveActionConfig(annotationValues);\r\n    ActionInterceptor[] actionInterceptors = parseActionInterceptors(actionClass, actionMethod, actionConfig);\r\n    ActionFilter[] actionFilters = parseActionFilters(actionClass, actionMethod, actionConfig);\r\n    if (actionDefinition == null) {\r\n        actionDefinition = parseActionDefinition(actionClass, actionMethod);\r\n    }\r\n    detectAndRegisterAlias(annotationValues, actionDefinition);\r\n    final boolean async = parseMethodAsyncFlag(actionMethod);\r\n    final boolean auth = parseMethodAuthFlag(actionMethod);\r\n    final Class<? extends ActionResult> actionResult = parseActionResult(actionMethod);\r\n    final Class<? extends ActionResult> defaultActionResult = actionConfig.getActionResult();\r\n    return createActionRuntime(null, actionClass, actionMethod, actionResult, defaultActionResult, actionFilters, actionInterceptors, actionDefinition, async, auth);\r\n}"
}, {
	"Path": "jodd.db.DbThreadSession.getCurrentSession",
	"Comment": "returns current thread session or null if no session is assigned\tto a thread.",
	"Method": "DbSession getCurrentSession(){\r\n    return ThreadDbSessionHolder.get();\r\n}"
}, {
	"Path": "jodd.asm7.Type.getSize",
	"Comment": "returns the size of values of this type. this method must not be used for method types.",
	"Method": "int getSize(){\r\n    switch(sort) {\r\n        case VOID:\r\n            return 0;\r\n        case BOOLEAN:\r\n        case CHAR:\r\n        case BYTE:\r\n        case SHORT:\r\n        case INT:\r\n        case FLOAT:\r\n        case ARRAY:\r\n        case OBJECT:\r\n        case INTERNAL:\r\n            return 1;\r\n        case LONG:\r\n        case DOUBLE:\r\n            return 2;\r\n        default:\r\n            throw new AssertionError();\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractDuration.hashCode",
	"Comment": "gets a hash code for the duration that is compatible with the equals method.",
	"Method": "int hashCode(){\r\n    long len = getMillis();\r\n    return (int) (len ^ (len >>> 32));\r\n}"
}, {
	"Path": "jodd.jtx.JtxTransaction.commitOrRollback",
	"Comment": "performs either commit or rollback on all transaction resources.",
	"Method": "void commitOrRollback(boolean doCommit){\r\n    if (log.isDebugEnabled()) {\r\n        if (doCommit) {\r\n            log.debug(\"Commit JTX\");\r\n        } else {\r\n            log.debug(\"Rollback JTX\");\r\n        }\r\n    }\r\n    boolean forcedRollback = false;\r\n    if (!isNoTransaction()) {\r\n        if (isRollbackOnly()) {\r\n            if (doCommit) {\r\n                doCommit = false;\r\n                forcedRollback = true;\r\n            }\r\n        } else if (!isActive()) {\r\n            if (isCompleted()) {\r\n                throw new JtxException(\"TX is already completed, commit or rollback should be called once per TX\");\r\n            }\r\n            throw new JtxException(\"No active TX to \" + (doCommit ? \"commit\" : \"rollback\"));\r\n        }\r\n    }\r\n    if (doCommit) {\r\n        commitAllResources();\r\n    } else {\r\n        rollbackAllResources(forcedRollback);\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.Weeks.toStandardSeconds",
	"Comment": "converts this period in weeks to a period in seconds assuming a7 day week, 24 hour day, 60 minute hour and 60 second minute.this method allows you to convert between different types of period.however to achieve this it makes the assumption that all weeks are7 days long, all days are 24 hours long, all hours are 60 minutes longand all minutes are 60 seconds long.this is not true when daylight savings is considered and may also notbe true for some unusual chronologies. however, it is includedas it is a useful operation for many applications and business rules.",
	"Method": "Seconds toStandardSeconds(){\r\n    return Seconds.seconds(FieldUtils.safeMultiply(getValue(), DateTimeConstants.SECONDS_PER_WEEK));\r\n}"
}, {
	"Path": "jodd.proxetta.asm.ProxyAspectData.readAdviceData",
	"Comment": "parse advice class to gather some advice data. should be called before any advice use.\tmust be called onlyper advice.",
	"Method": "void readAdviceData(){\r\n    if (ready) {\r\n        return;\r\n    }\r\n    adviceClassReader.accept(new EmptyClassVisitor() {\r\n        @Override\r\n        public void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces) {\r\n            adviceReference = name;\r\n            super.visit(version, access, name, signature, superName, interfaces);\r\n        }\r\n        @Override\r\n        public void visitInnerClass(final String name, final String outerName, final String innerName, final int access) {\r\n            if (outerName.equals(adviceReference)) {\r\n                throw new ProxettaException(\"Proxetta doesn't allow inner classes in/for advice: \" + advice.getName());\r\n            }\r\n            super.visitInnerClass(name, outerName, innerName, access);\r\n        }\r\n        @Override\r\n        public FieldVisitor visitField(final int access, final String name, final String desc, final String signature, final Object value) {\r\n            // [A5]\r\n            wd.dest.visitField(access, adviceFieldName(name, aspectIndex), desc, signature, value);\r\n            return super.visitField(access, name, desc, signature, value);\r\n        }\r\n        @Override\r\n        public MethodVisitor visitMethod(int access, String name, final String desc, final String signature, final String[] exceptions) {\r\n            if (name.equals(CLINIT)) {\r\n                if (!desc.equals(DESC_VOID)) {\r\n                    throw new ProxettaException(\"Invalid static initialization block description for advice: \" + advice.getName());\r\n                }\r\n                name = ProxettaNames.clinitMethodName + ProxettaNames.methodDivider + aspectIndex;\r\n                access |= AsmUtil.ACC_PRIVATE | AsmUtil.ACC_FINAL;\r\n                wd.addAdviceClinitMethod(name);\r\n                return new MethodAdapter(wd.dest.visitMethod(access, name, desc, signature, exceptions)) {\r\n                    @Override\r\n                    public void visitLocalVariable(final String name, final String desc, final String signature, final Label start, final Label end, final int index) {\r\n                    }\r\n                    @Override\r\n                    public void visitLineNumber(final int line, final Label start) {\r\n                    }\r\n                    @Override\r\n                    public void visitMethodInsn(final int opcode, String owner, String name, final String desc, final boolean isInterface) {\r\n                        if (opcode == INVOKESTATIC) {\r\n                            if (owner.equals(adviceReference)) {\r\n                                owner = wd.thisReference;\r\n                                name = adviceMethodName(name, aspectIndex);\r\n                            }\r\n                        }\r\n                        super.visitMethodInsn(opcode, owner, name, desc, isInterface);\r\n                    }\r\n                    @Override\r\n                    public void visitFieldInsn(final int opcode, String owner, String name, final String desc) {\r\n                        if (owner.equals(adviceReference)) {\r\n                            owner = wd.thisReference;\r\n                            name = adviceFieldName(name, aspectIndex);\r\n                        }\r\n                        super.visitFieldInsn(opcode, owner, name, desc);\r\n                    }\r\n                };\r\n            } else if (// [A7]\r\n            name.equals(INIT)) {\r\n                if (!desc.equals(DESC_VOID)) {\r\n                    throw new ProxettaException(\"Advices can have only default constructors. Invalid advice: \" + advice.getName());\r\n                }\r\n                name = ProxettaNames.initMethodName + ProxettaNames.methodDivider + aspectIndex;\r\n                access = ProxettaAsmUtil.makePrivateFinalAccess(access);\r\n                wd.addAdviceInitMethod(name);\r\n                return new MethodAdapter(wd.dest.visitMethod(access, name, desc, signature, exceptions)) {\r\n                    @Override\r\n                    public void visitLocalVariable(final String name, final String desc, final String signature, final Label start, final Label end, final int index) {\r\n                    }\r\n                    @Override\r\n                    public void visitLineNumber(final int line, final Label start) {\r\n                    }\r\n                    int state;\r\n                    @Override\r\n                    public void visitVarInsn(final int opcode, final int var) {\r\n                        if ((state == 0) && (opcode == ALOAD) && (var == 0)) {\r\n                            state++;\r\n                            return;\r\n                        }\r\n                        super.visitVarInsn(opcode, var);\r\n                    }\r\n                    @Override\r\n                    public void visitMethodInsn(final int opcode, String owner, String name, final String desc, final boolean isInterface) {\r\n                        if ((state == 1) && (opcode == INVOKESPECIAL)) {\r\n                            state++;\r\n                            return;\r\n                        }\r\n                        if ((opcode == INVOKEVIRTUAL) || (opcode == INVOKEINTERFACE)) {\r\n                            if (owner.equals(adviceReference)) {\r\n                                owner = wd.thisReference;\r\n                                name = adviceMethodName(name, aspectIndex);\r\n                            }\r\n                        } else if (opcode == INVOKESTATIC) {\r\n                            if (owner.equals(adviceReference)) {\r\n                                owner = wd.thisReference;\r\n                                name = adviceMethodName(name, aspectIndex);\r\n                            }\r\n                        }\r\n                        super.visitMethodInsn(opcode, owner, name, desc, isInterface);\r\n                    }\r\n                    @Override\r\n                    public void visitFieldInsn(final int opcode, String owner, String name, final String desc) {\r\n                        if (owner.equals(adviceReference)) {\r\n                            owner = wd.thisReference;\r\n                            name = adviceFieldName(name, aspectIndex);\r\n                        }\r\n                        super.visitFieldInsn(opcode, owner, name, desc);\r\n                    }\r\n                };\r\n            } else if (!name.equals(ProxettaNames.executeMethodName)) {\r\n                name = adviceMethodName(name, aspectIndex);\r\n                return new MethodAdapter(wd.dest.visitMethod(access, name, desc, signature, exceptions)) {\r\n                    @Override\r\n                    public void visitLocalVariable(final String name, final String desc, final String signature, final Label start, final Label end, final int index) {\r\n                    }\r\n                    @Override\r\n                    public void visitLineNumber(final int line, final Label start) {\r\n                    }\r\n                    @Override\r\n                    public void visitMethodInsn(final int opcode, String owner, String name, final String desc, final boolean isInterface) {\r\n                        if ((opcode == INVOKEVIRTUAL) || (opcode == INVOKEINTERFACE)) {\r\n                            if (owner.equals(adviceReference)) {\r\n                                owner = wd.thisReference;\r\n                                name = adviceMethodName(name, aspectIndex);\r\n                            }\r\n                        } else if (opcode == INVOKESTATIC || opcode == INVOKESPECIAL) {\r\n                            if (owner.equals(adviceReference)) {\r\n                                owner = wd.thisReference;\r\n                                name = adviceMethodName(name, aspectIndex);\r\n                            }\r\n                        }\r\n                        super.visitMethodInsn(opcode, owner, name, desc, isInterface);\r\n                    }\r\n                    @Override\r\n                    public void visitFieldInsn(final int opcode, String owner, String name, final String desc) {\r\n                        if (owner.equals(adviceReference)) {\r\n                            owner = wd.thisReference;\r\n                            name = adviceFieldName(name, aspectIndex);\r\n                        }\r\n                        super.visitFieldInsn(opcode, owner, name, desc);\r\n                    }\r\n                };\r\n            }\r\n            return new EmptyMethodVisitor() {\r\n                @Override\r\n                public void visitVarInsn(final int opcode, final int var) {\r\n                    if (isStoreOpcode(opcode)) {\r\n                        if (var > maxLocalVarOffset) {\r\n                            maxLocalVarOffset = var;\r\n                        }\r\n                    }\r\n                    super.visitVarInsn(opcode, var);\r\n                }\r\n            };\r\n        }\r\n    }, 0);\r\n    maxLocalVarOffset += 2;\r\n    ready = true;\r\n}"
}, {
	"Path": "jodd.proxetta.asm.ProxyAspectData.readAdviceData",
	"Comment": "parse advice class to gather some advice data. should be called before any advice use.\tmust be called onlyper advice.",
	"Method": "void readAdviceData(){\r\n    adviceReference = name;\r\n    super.visit(version, access, name, signature, superName, interfaces);\r\n}"
}, {
	"Path": "jodd.proxetta.asm.ProxyAspectData.readAdviceData",
	"Comment": "parse advice class to gather some advice data. should be called before any advice use.\tmust be called onlyper advice.",
	"Method": "void readAdviceData(){\r\n    if (outerName.equals(adviceReference)) {\r\n        throw new ProxettaException(\"Proxetta doesn't allow inner classes in/for advice: \" + advice.getName());\r\n    }\r\n    super.visitInnerClass(name, outerName, innerName, access);\r\n}"
}, {
	"Path": "jodd.proxetta.asm.ProxyAspectData.readAdviceData",
	"Comment": "parse advice class to gather some advice data. should be called before any advice use.\tmust be called onlyper advice.",
	"Method": "void readAdviceData(){\r\n    // [A5]\r\n    wd.dest.visitField(access, adviceFieldName(name, aspectIndex), desc, signature, value);\r\n    return super.visitField(access, name, desc, signature, value);\r\n}"
}, {
	"Path": "jodd.proxetta.asm.ProxyAspectData.readAdviceData",
	"Comment": "parse advice class to gather some advice data. should be called before any advice use.\tmust be called onlyper advice.",
	"Method": "void readAdviceData(){\r\n    if (name.equals(CLINIT)) {\r\n        if (!desc.equals(DESC_VOID)) {\r\n            throw new ProxettaException(\"Invalid static initialization block description for advice: \" + advice.getName());\r\n        }\r\n        name = ProxettaNames.clinitMethodName + ProxettaNames.methodDivider + aspectIndex;\r\n        access |= AsmUtil.ACC_PRIVATE | AsmUtil.ACC_FINAL;\r\n        wd.addAdviceClinitMethod(name);\r\n        return new MethodAdapter(wd.dest.visitMethod(access, name, desc, signature, exceptions)) {\r\n            @Override\r\n            public void visitLocalVariable(final String name, final String desc, final String signature, final Label start, final Label end, final int index) {\r\n            }\r\n            @Override\r\n            public void visitLineNumber(final int line, final Label start) {\r\n            }\r\n            @Override\r\n            public void visitMethodInsn(final int opcode, String owner, String name, final String desc, final boolean isInterface) {\r\n                if (opcode == INVOKESTATIC) {\r\n                    if (owner.equals(adviceReference)) {\r\n                        owner = wd.thisReference;\r\n                        name = adviceMethodName(name, aspectIndex);\r\n                    }\r\n                }\r\n                super.visitMethodInsn(opcode, owner, name, desc, isInterface);\r\n            }\r\n            @Override\r\n            public void visitFieldInsn(final int opcode, String owner, String name, final String desc) {\r\n                if (owner.equals(adviceReference)) {\r\n                    owner = wd.thisReference;\r\n                    name = adviceFieldName(name, aspectIndex);\r\n                }\r\n                super.visitFieldInsn(opcode, owner, name, desc);\r\n            }\r\n        };\r\n    } else if (// [A7]\r\n    name.equals(INIT)) {\r\n        if (!desc.equals(DESC_VOID)) {\r\n            throw new ProxettaException(\"Advices can have only default constructors. Invalid advice: \" + advice.getName());\r\n        }\r\n        name = ProxettaNames.initMethodName + ProxettaNames.methodDivider + aspectIndex;\r\n        access = ProxettaAsmUtil.makePrivateFinalAccess(access);\r\n        wd.addAdviceInitMethod(name);\r\n        return new MethodAdapter(wd.dest.visitMethod(access, name, desc, signature, exceptions)) {\r\n            @Override\r\n            public void visitLocalVariable(final String name, final String desc, final String signature, final Label start, final Label end, final int index) {\r\n            }\r\n            @Override\r\n            public void visitLineNumber(final int line, final Label start) {\r\n            }\r\n            int state;\r\n            @Override\r\n            public void visitVarInsn(final int opcode, final int var) {\r\n                if ((state == 0) && (opcode == ALOAD) && (var == 0)) {\r\n                    state++;\r\n                    return;\r\n                }\r\n                super.visitVarInsn(opcode, var);\r\n            }\r\n            @Override\r\n            public void visitMethodInsn(final int opcode, String owner, String name, final String desc, final boolean isInterface) {\r\n                if ((state == 1) && (opcode == INVOKESPECIAL)) {\r\n                    state++;\r\n                    return;\r\n                }\r\n                if ((opcode == INVOKEVIRTUAL) || (opcode == INVOKEINTERFACE)) {\r\n                    if (owner.equals(adviceReference)) {\r\n                        owner = wd.thisReference;\r\n                        name = adviceMethodName(name, aspectIndex);\r\n                    }\r\n                } else if (opcode == INVOKESTATIC) {\r\n                    if (owner.equals(adviceReference)) {\r\n                        owner = wd.thisReference;\r\n                        name = adviceMethodName(name, aspectIndex);\r\n                    }\r\n                }\r\n                super.visitMethodInsn(opcode, owner, name, desc, isInterface);\r\n            }\r\n            @Override\r\n            public void visitFieldInsn(final int opcode, String owner, String name, final String desc) {\r\n                if (owner.equals(adviceReference)) {\r\n                    owner = wd.thisReference;\r\n                    name = adviceFieldName(name, aspectIndex);\r\n                }\r\n                super.visitFieldInsn(opcode, owner, name, desc);\r\n            }\r\n        };\r\n    } else if (!name.equals(ProxettaNames.executeMethodName)) {\r\n        name = adviceMethodName(name, aspectIndex);\r\n        return new MethodAdapter(wd.dest.visitMethod(access, name, desc, signature, exceptions)) {\r\n            @Override\r\n            public void visitLocalVariable(final String name, final String desc, final String signature, final Label start, final Label end, final int index) {\r\n            }\r\n            @Override\r\n            public void visitLineNumber(final int line, final Label start) {\r\n            }\r\n            @Override\r\n            public void visitMethodInsn(final int opcode, String owner, String name, final String desc, final boolean isInterface) {\r\n                if ((opcode == INVOKEVIRTUAL) || (opcode == INVOKEINTERFACE)) {\r\n                    if (owner.equals(adviceReference)) {\r\n                        owner = wd.thisReference;\r\n                        name = adviceMethodName(name, aspectIndex);\r\n                    }\r\n                } else if (opcode == INVOKESTATIC || opcode == INVOKESPECIAL) {\r\n                    if (owner.equals(adviceReference)) {\r\n                        owner = wd.thisReference;\r\n                        name = adviceMethodName(name, aspectIndex);\r\n                    }\r\n                }\r\n                super.visitMethodInsn(opcode, owner, name, desc, isInterface);\r\n            }\r\n            @Override\r\n            public void visitFieldInsn(final int opcode, String owner, String name, final String desc) {\r\n                if (owner.equals(adviceReference)) {\r\n                    owner = wd.thisReference;\r\n                    name = adviceFieldName(name, aspectIndex);\r\n                }\r\n                super.visitFieldInsn(opcode, owner, name, desc);\r\n            }\r\n        };\r\n    }\r\n    return new EmptyMethodVisitor() {\r\n        @Override\r\n        public void visitVarInsn(final int opcode, final int var) {\r\n            if (isStoreOpcode(opcode)) {\r\n                if (var > maxLocalVarOffset) {\r\n                    maxLocalVarOffset = var;\r\n                }\r\n            }\r\n            super.visitVarInsn(opcode, var);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "jodd.proxetta.asm.ProxyAspectData.readAdviceData",
	"Comment": "parse advice class to gather some advice data. should be called before any advice use.\tmust be called onlyper advice.",
	"Method": "void readAdviceData(){\r\n}"
}, {
	"Path": "jodd.proxetta.asm.ProxyAspectData.readAdviceData",
	"Comment": "parse advice class to gather some advice data. should be called before any advice use.\tmust be called onlyper advice.",
	"Method": "void readAdviceData(){\r\n}"
}, {
	"Path": "jodd.proxetta.asm.ProxyAspectData.readAdviceData",
	"Comment": "parse advice class to gather some advice data. should be called before any advice use.\tmust be called onlyper advice.",
	"Method": "void readAdviceData(){\r\n    if (opcode == INVOKESTATIC) {\r\n        if (owner.equals(adviceReference)) {\r\n            owner = wd.thisReference;\r\n            name = adviceMethodName(name, aspectIndex);\r\n        }\r\n    }\r\n    super.visitMethodInsn(opcode, owner, name, desc, isInterface);\r\n}"
}, {
	"Path": "jodd.proxetta.asm.ProxyAspectData.readAdviceData",
	"Comment": "parse advice class to gather some advice data. should be called before any advice use.\tmust be called onlyper advice.",
	"Method": "void readAdviceData(){\r\n    if (owner.equals(adviceReference)) {\r\n        owner = wd.thisReference;\r\n        name = adviceFieldName(name, aspectIndex);\r\n    }\r\n    super.visitFieldInsn(opcode, owner, name, desc);\r\n}"
}, {
	"Path": "jodd.proxetta.asm.ProxyAspectData.readAdviceData",
	"Comment": "parse advice class to gather some advice data. should be called before any advice use.\tmust be called onlyper advice.",
	"Method": "void readAdviceData(){\r\n}"
}, {
	"Path": "jodd.proxetta.asm.ProxyAspectData.readAdviceData",
	"Comment": "parse advice class to gather some advice data. should be called before any advice use.\tmust be called onlyper advice.",
	"Method": "void readAdviceData(){\r\n}"
}, {
	"Path": "jodd.proxetta.asm.ProxyAspectData.readAdviceData",
	"Comment": "parse advice class to gather some advice data. should be called before any advice use.\tmust be called onlyper advice.",
	"Method": "void readAdviceData(){\r\n    if ((state == 0) && (opcode == ALOAD) && (var == 0)) {\r\n        state++;\r\n        return;\r\n    }\r\n    super.visitVarInsn(opcode, var);\r\n}"
}, {
	"Path": "jodd.proxetta.asm.ProxyAspectData.readAdviceData",
	"Comment": "parse advice class to gather some advice data. should be called before any advice use.\tmust be called onlyper advice.",
	"Method": "void readAdviceData(){\r\n    if ((state == 1) && (opcode == INVOKESPECIAL)) {\r\n        state++;\r\n        return;\r\n    }\r\n    if ((opcode == INVOKEVIRTUAL) || (opcode == INVOKEINTERFACE)) {\r\n        if (owner.equals(adviceReference)) {\r\n            owner = wd.thisReference;\r\n            name = adviceMethodName(name, aspectIndex);\r\n        }\r\n    } else if (opcode == INVOKESTATIC) {\r\n        if (owner.equals(adviceReference)) {\r\n            owner = wd.thisReference;\r\n            name = adviceMethodName(name, aspectIndex);\r\n        }\r\n    }\r\n    super.visitMethodInsn(opcode, owner, name, desc, isInterface);\r\n}"
}, {
	"Path": "jodd.proxetta.asm.ProxyAspectData.readAdviceData",
	"Comment": "parse advice class to gather some advice data. should be called before any advice use.\tmust be called onlyper advice.",
	"Method": "void readAdviceData(){\r\n    if (owner.equals(adviceReference)) {\r\n        owner = wd.thisReference;\r\n        name = adviceFieldName(name, aspectIndex);\r\n    }\r\n    super.visitFieldInsn(opcode, owner, name, desc);\r\n}"
}, {
	"Path": "jodd.proxetta.asm.ProxyAspectData.readAdviceData",
	"Comment": "parse advice class to gather some advice data. should be called before any advice use.\tmust be called onlyper advice.",
	"Method": "void readAdviceData(){\r\n}"
}, {
	"Path": "jodd.proxetta.asm.ProxyAspectData.readAdviceData",
	"Comment": "parse advice class to gather some advice data. should be called before any advice use.\tmust be called onlyper advice.",
	"Method": "void readAdviceData(){\r\n}"
}, {
	"Path": "jodd.proxetta.asm.ProxyAspectData.readAdviceData",
	"Comment": "parse advice class to gather some advice data. should be called before any advice use.\tmust be called onlyper advice.",
	"Method": "void readAdviceData(){\r\n    if ((opcode == INVOKEVIRTUAL) || (opcode == INVOKEINTERFACE)) {\r\n        if (owner.equals(adviceReference)) {\r\n            owner = wd.thisReference;\r\n            name = adviceMethodName(name, aspectIndex);\r\n        }\r\n    } else if (opcode == INVOKESTATIC || opcode == INVOKESPECIAL) {\r\n        if (owner.equals(adviceReference)) {\r\n            owner = wd.thisReference;\r\n            name = adviceMethodName(name, aspectIndex);\r\n        }\r\n    }\r\n    super.visitMethodInsn(opcode, owner, name, desc, isInterface);\r\n}"
}, {
	"Path": "jodd.proxetta.asm.ProxyAspectData.readAdviceData",
	"Comment": "parse advice class to gather some advice data. should be called before any advice use.\tmust be called onlyper advice.",
	"Method": "void readAdviceData(){\r\n    if (owner.equals(adviceReference)) {\r\n        owner = wd.thisReference;\r\n        name = adviceFieldName(name, aspectIndex);\r\n    }\r\n    super.visitFieldInsn(opcode, owner, name, desc);\r\n}"
}, {
	"Path": "jodd.proxetta.asm.ProxyAspectData.readAdviceData",
	"Comment": "parse advice class to gather some advice data. should be called before any advice use.\tmust be called onlyper advice.",
	"Method": "void readAdviceData(){\r\n    if (isStoreOpcode(opcode)) {\r\n        if (var > maxLocalVarOffset) {\r\n            maxLocalVarOffset = var;\r\n        }\r\n    }\r\n    super.visitVarInsn(opcode, var);\r\n}"
}, {
	"Path": "jodd.petite.PetiteBeans.registerBean",
	"Comment": "registers bean definition by putting it in the beans map. if bean does\tnot have petite name explicitly defined, alternative bean names\twill be registered.",
	"Method": "void registerBean(String name,BeanDefinition beanDefinition){\r\n    beans.put(name, beanDefinition);\r\n    if (!petiteConfig.isUseAltBeanNames()) {\r\n        return;\r\n    }\r\n    Class type = beanDefinition.type();\r\n    if (annotationResolver.beanHasAnnotationName(type)) {\r\n        return;\r\n    }\r\n    Class[] interfaces = ClassUtil.resolveAllInterfaces(type);\r\n    for (Class anInterface : interfaces) {\r\n        String altName = annotationResolver.resolveBeanName(anInterface, petiteConfig.getUseFullTypeNames());\r\n        if (name.equals(altName)) {\r\n            continue;\r\n        }\r\n        if (beans.containsKey(altName)) {\r\n            continue;\r\n        }\r\n        if (beansAlt.containsKey(altName)) {\r\n            BeanDefinition existing = beansAlt.get(altName);\r\n            if (existing != null) {\r\n                beansAlt.put(altName, null);\r\n            }\r\n        } else {\r\n            beansAlt.put(altName, beanDefinition);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jodd.introspector.ClassDescriptor.getCtors",
	"Comment": "returns constructors collection.\tcreates new collection of first access.",
	"Method": "Ctors getCtors(){\r\n    if (ctors == null) {\r\n        ctors = new Ctors(this);\r\n    }\r\n    return ctors;\r\n}"
}, {
	"Path": "jodd.typeconverter.Converter.toBigInteger",
	"Comment": "converts value to biginteger. returns default value\twhen conversion result is null",
	"Method": "BigInteger toBigInteger(Object value,BigInteger toBigInteger,Object value,BigInteger defaultValue){\r\n    final BigInteger result = toBigInteger(value);\r\n    if (result == null) {\r\n        return defaultValue;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "jodd.props.Props.getBooleanValue",
	"Comment": "returns boolean value or default one if property not defined.",
	"Method": "Boolean getBooleanValue(String key,Boolean getBooleanValue,String key,Boolean defaultValue,Boolean getBooleanValue,String key,String profiles,Boolean getBooleanValue,String key,Boolean defaultValue,String profiles){\r\n    final String value = getValue(key, profiles);\r\n    if (value == null) {\r\n        return defaultValue;\r\n    }\r\n    return Boolean.valueOf(value);\r\n}"
}, {
	"Path": "jodd.props.PropsEntry.getProfile",
	"Comment": "returns property profile or null if this is a base property.",
	"Method": "String getProfile(){\r\n    return profile;\r\n}"
}, {
	"Path": "org.joda.time.MutableDateTime.copy",
	"Comment": "clone this object without having to cast the returned object.",
	"Method": "MutableDateTime copy(){\r\n    return (MutableDateTime) clone();\r\n}"
}, {
	"Path": "org.joda.time.base.AbstractInstant.toDateTime",
	"Comment": "get this object as a datetime using the given chronology and its zone.",
	"Method": "DateTime toDateTime(DateTime toDateTime,DateTimeZone zone,DateTime toDateTime,Chronology chronology){\r\n    return new DateTime(getMillis(), chronology);\r\n}"
}, {
	"Path": "org.joda.time.DateTime.hourOfDay",
	"Comment": "get the hour of day field property which provides access to advanced functionality.",
	"Method": "Property hourOfDay(){\r\n    return new Property(this, getChronology().hourOfDay());\r\n}"
}, {
	"Path": "org.joda.time.Minutes.toStandardSeconds",
	"Comment": "converts this period in minutes to a period in seconds assuming a60 second minute.this method allows you to convert between different types of period.however to achieve this it makes the assumption that all minutes are60 seconds long.this may not be true for some unusual chronologies. however, it is includedas it is a useful operation for many applications and business rules.",
	"Method": "Seconds toStandardSeconds(){\r\n    return Seconds.seconds(FieldUtils.safeMultiply(getValue(), DateTimeConstants.SECONDS_PER_MINUTE));\r\n}"
}, {
	"Path": "org.jooq.codegen.GenerationTool.setClassLoader",
	"Comment": "the class loader to use with this generation tool.if set, all classes are loaded with this class loader",
	"Method": "void setClassLoader(ClassLoader loader){\r\n    this.loader = loader;\r\n}"
}, {
	"Path": "org.joda.time.Period.plusMinutes",
	"Comment": "returns a new period plus the specified number of minutes added.this period instance is immutable and unaffected by this method call.",
	"Method": "Period plusMinutes(int minutes){\r\n    if (minutes == 0) {\r\n        return this;\r\n    }\r\n    int[] values = getValues();\r\n    getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, minutes);\r\n    return new Period(values, getPeriodType());\r\n}"
}, {
	"Path": "jodd.util.StringUtil.truncate",
	"Comment": "sets the maximum length of the string. longer strings will be simply truncated.",
	"Method": "String truncate(String string,int length){\r\n    if (string.length() > length) {\r\n        string = string.substring(0, length);\r\n    }\r\n    return string;\r\n}"
}, {
	"Path": "org.jooq.impl.AbstractQuery.prepare",
	"Comment": "default implementation for preparing a statement. subclasses may overridethis method.",
	"Method": "void prepare(ExecuteContext ctx){\r\n    ctx.statement(ctx.connection().prepareStatement(ctx.sql()));\r\n}"
}, {
	"Path": "org.jooq.impl.DSL.all",
	"Comment": "create an all quantified select to be used in quantifiedcomparison predicate expressions.",
	"Method": "QuantifiedSelect<R> all(Select<R> select,QuantifiedSelect<Record1<T>> all,T array,QuantifiedSelect<Record1<T>> all,Field<T[]> array){\r\n    return new QuantifiedSelectImpl<Record1<T>>(Quantifier.ALL, array);\r\n}"
}, {
	"Path": "org.joda.time.format.DateTimeFormat.parsePatternTo",
	"Comment": "parses the given pattern and appends the rules to the givendatetimeformatterbuilder.",
	"Method": "void parsePatternTo(DateTimeFormatterBuilder builder,String pattern){\r\n    int length = pattern.length();\r\n    int[] indexRef = new int[1];\r\n    for (int i = 0; i < length; i++) {\r\n        indexRef[0] = i;\r\n        String token = parseToken(pattern, indexRef);\r\n        i = indexRef[0];\r\n        int tokenLen = token.length();\r\n        if (tokenLen == 0) {\r\n            break;\r\n        }\r\n        char c = token.charAt(0);\r\n        switch(c) {\r\n            case 'G':\r\n                builder.appendEraText();\r\n                break;\r\n            case 'C':\r\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\r\n                break;\r\n            case 'x':\r\n            case 'y':\r\n            case 'Y':\r\n                if (tokenLen == 2) {\r\n                    boolean lenientParse = true;\r\n                    if (i + 1 < length) {\r\n                        indexRef[0]++;\r\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\r\n                            lenientParse = false;\r\n                        }\r\n                        indexRef[0]--;\r\n                    }\r\n                    switch(c) {\r\n                        case 'x':\r\n                            builder.appendTwoDigitWeekyear(new DateTime().getWeekyear() - 30, lenientParse);\r\n                            break;\r\n                        case 'y':\r\n                        case 'Y':\r\n                        default:\r\n                            builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\r\n                            break;\r\n                    }\r\n                } else {\r\n                    int maxDigits = 9;\r\n                    if (i + 1 < length) {\r\n                        indexRef[0]++;\r\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\r\n                            maxDigits = tokenLen;\r\n                        }\r\n                        indexRef[0]--;\r\n                    }\r\n                    switch(c) {\r\n                        case 'x':\r\n                            builder.appendWeekyear(tokenLen, maxDigits);\r\n                            break;\r\n                        case 'y':\r\n                            builder.appendYear(tokenLen, maxDigits);\r\n                            break;\r\n                        case 'Y':\r\n                            builder.appendYearOfEra(tokenLen, maxDigits);\r\n                            break;\r\n                    }\r\n                }\r\n                break;\r\n            case 'M':\r\n                if (tokenLen >= 3) {\r\n                    if (tokenLen >= 4) {\r\n                        builder.appendMonthOfYearText();\r\n                    } else {\r\n                        builder.appendMonthOfYearShortText();\r\n                    }\r\n                } else {\r\n                    builder.appendMonthOfYear(tokenLen);\r\n                }\r\n                break;\r\n            case 'd':\r\n                builder.appendDayOfMonth(tokenLen);\r\n                break;\r\n            case 'a':\r\n                builder.appendHalfdayOfDayText();\r\n                break;\r\n            case 'h':\r\n                builder.appendClockhourOfHalfday(tokenLen);\r\n                break;\r\n            case 'H':\r\n                builder.appendHourOfDay(tokenLen);\r\n                break;\r\n            case 'k':\r\n                builder.appendClockhourOfDay(tokenLen);\r\n                break;\r\n            case 'K':\r\n                builder.appendHourOfHalfday(tokenLen);\r\n                break;\r\n            case 'm':\r\n                builder.appendMinuteOfHour(tokenLen);\r\n                break;\r\n            case 's':\r\n                builder.appendSecondOfMinute(tokenLen);\r\n                break;\r\n            case 'S':\r\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\r\n                break;\r\n            case 'e':\r\n                builder.appendDayOfWeek(tokenLen);\r\n                break;\r\n            case 'E':\r\n                if (tokenLen >= 4) {\r\n                    builder.appendDayOfWeekText();\r\n                } else {\r\n                    builder.appendDayOfWeekShortText();\r\n                }\r\n                break;\r\n            case 'D':\r\n                builder.appendDayOfYear(tokenLen);\r\n                break;\r\n            case 'w':\r\n                builder.appendWeekOfWeekyear(tokenLen);\r\n                break;\r\n            case 'z':\r\n                if (tokenLen >= 4) {\r\n                    builder.appendTimeZoneName();\r\n                } else {\r\n                    builder.appendTimeZoneShortName(null);\r\n                }\r\n                break;\r\n            case 'Z':\r\n                if (tokenLen == 1) {\r\n                    builder.appendTimeZoneOffset(null, \"Z\", false, 2, 2);\r\n                } else if (tokenLen == 2) {\r\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\r\n                } else {\r\n                    builder.appendTimeZoneId();\r\n                }\r\n                break;\r\n            case '\\'':\r\n                String sub = token.substring(1);\r\n                if (sub.length() == 1) {\r\n                    builder.appendLiteral(sub.charAt(0));\r\n                } else {\r\n                    builder.appendLiteral(new String(sub));\r\n                }\r\n                break;\r\n            default:\r\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.SessionBuilder.setSurfaceView",
	"Comment": "sets the surfaceview required to preview the video stream.",
	"Method": "SessionBuilder setSurfaceView(SurfaceView surfaceView){\r\n    mSurfaceView = surfaceView;\r\n    return this;\r\n}"
}, {
	"Path": "org.joda.time.field.BaseDurationField.getMillis",
	"Comment": "get the millisecond duration of this field from its value, which isapproximate if this field is imprecise.",
	"Method": "long getMillis(int value,long getMillis,long value){\r\n    return FieldUtils.safeMultiply(value, getUnitMillis());\r\n}"
}, {
	"Path": "jodd.db.type.SqlType.prepareGetValue",
	"Comment": "once when value is read from result set, prepare it to match destination type.",
	"Method": "E prepareGetValue(T t,Class<E> destinationType){\r\n    if (t == null) {\r\n        return null;\r\n    }\r\n    if (destinationType == null) {\r\n        return (E) t;\r\n    }\r\n    return TypeConverterManager.get().convertType(t, destinationType);\r\n}"
}, {
	"Path": "jodd.util.RandomString.random",
	"Comment": "creates random string whose length is the number of characters specified.\tcharacters are chosen from the provided range.",
	"Method": "String random(int count,char[] chars,String random,int count,String chars,String random,int count,char start,char end){\r\n    if (count == 0) {\r\n        return StringPool.EMPTY;\r\n    }\r\n    char[] result = new char[count];\r\n    int len = end - start + 1;\r\n    while (count-- > 0) {\r\n        result[count] = (char) (rnd.nextInt(len) + start);\r\n    }\r\n    return new String(result);\r\n}"
}, {
	"Path": "org.jooq.codegen.JavaGenerator.generateDaoClassJavadoc",
	"Comment": "subclasses may override this method to provide their own javadoc.",
	"Method": "void generateDaoClassJavadoc(TableDefinition table,JavaWriter out){\r\n    if (generateCommentsOnTables())\r\n        printClassJavadoc(out, table);\r\n    else\r\n        printClassJavadoc(out, \"The table <code>\" + table.getQualifiedInputName() + \"<\/code>.\");\r\n}"
}, {
	"Path": "org.joda.time.format.PeriodFormatter.getParser",
	"Comment": "gets the internal parser object that performs the real parsing work.",
	"Method": "PeriodParser getParser(){\r\n    return iParser;\r\n}"
}, {
	"Path": "jodd.decora.DecoraManager.resolveDecorator",
	"Comment": "resolves decorator path based on request and action path.\tif decorator is not found, returns null.\tby default applies decorator on all .html pages.",
	"Method": "String resolveDecorator(HttpServletRequest request,String actionPath){\r\n    if (actionPath.endsWith(\".html\")) {\r\n        return DEFAULT_DECORATOR;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.joda.time.field.MillisDurationField.getUnitMillis",
	"Comment": "returns the amount of milliseconds per unit value of this field.",
	"Method": "long getUnitMillis(){\r\n    return 1;\r\n}"
}, {
	"Path": "org.jooq.impl.AbstractQuery.execute",
	"Comment": "default implementation for query execution using a prepared statement.subclasses may override this method.",
	"Method": "int execute(int execute,ExecuteContext ctx,ExecuteListener listener){\r\n    int result = 0;\r\n    PreparedStatement stmt = ctx.statement();\r\n    try {\r\n        listener.executeStart(ctx);\r\n        if (!stmt.execute()) {\r\n            result = stmt.getUpdateCount();\r\n            ctx.rows(result);\r\n        }\r\n        listener.executeEnd(ctx);\r\n        return result;\r\n    } catch (SQLException e) {\r\n        consumeExceptions(ctx.configuration(), stmt, e);\r\n        if (ctx.settings().getThrowExceptions() != THROW_NONE)\r\n            throw e;\r\n        else\r\n            return stmt.getUpdateCount();\r\n    }\r\n}"
}, {
	"Path": "jodd.io.findfile.ClassScanner.includeEntries",
	"Comment": "sets included set of names that will be considered during configuration.",
	"Method": "ClassScanner includeEntries(String includedEntries){\r\n    for (final String includedEntry : includedEntries) {\r\n        rulesEntries.include(includedEntry);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.joda.time.DateTime.withEra",
	"Comment": "returns a copy of this datetime with the era field updated.datetime is immutable, so there are no set methods.instead, this method returns a new instance with the value ofera changed.",
	"Method": "DateTime withEra(int era){\r\n    return withMillis(getChronology().era().set(getMillis(), era));\r\n}"
}, {
	"Path": "org.joda.time.TimeOfDay.hourOfDay",
	"Comment": "get the hour of day field property which provides access to advanced functionality.",
	"Method": "Property hourOfDay(){\r\n    return new Property(this, HOUR_OF_DAY);\r\n}"
}, {
	"Path": "jodd.asm7.ByteVector.putShort",
	"Comment": "puts a short into this byte vector. the byte vector is automatically enlarged if necessary.",
	"Method": "ByteVector putShort(int shortValue){\r\n    int currentLength = length;\r\n    if (currentLength + 2 > data.length) {\r\n        enlarge(2);\r\n    }\r\n    byte[] currentData = data;\r\n    currentData[currentLength++] = (byte) (shortValue >>> 8);\r\n    currentData[currentLength++] = (byte) shortValue;\r\n    length = currentLength;\r\n    return this;\r\n}"
}, {
	"Path": "org.jooq.codegen.JavaGenerator.generatePojoGetter",
	"Comment": "subclasses may override this method to provide their own pojo getters.",
	"Method": "void generatePojoGetter(TypedElementDefinition<?> column,int index,JavaWriter out){\r\n    generatePojoGetter0(column, index, out);\r\n}"
}, {
	"Path": "org.joda.time.Days.toStandardMinutes",
	"Comment": "converts this period in days to a period in minutes assuming a24 hour day and 60 minute hour.this method allows you to convert between different types of period.however to achieve this it makes the assumption that all days are 24 hourslong and all hours are 60 minutes long.this is not true when daylight savings is considered and may also notbe true for some unusual chronologies. however, it is includedas it is a useful operation for many applications and business rules.",
	"Method": "Minutes toStandardMinutes(){\r\n    return Minutes.minutes(FieldUtils.safeMultiply(getValue(), DateTimeConstants.MINUTES_PER_DAY));\r\n}"
}, {
	"Path": "org.json.JSONObject.keySet",
	"Comment": "get a set of keys of the jsonobject. modifying this key set will also modify thejsonobject. use with caution.",
	"Method": "Set<String> keySet(){\r\n    return this.map.keySet();\r\n}"
}, {
	"Path": "jodd.db.DbSession.commitTransaction",
	"Comment": "commit the current transaction, writing any unflushed changes to the database.\ttransaction mode is closed.",
	"Method": "void commitTransaction(){\r\n    log.debug(\"Committing transaction\");\r\n    assertTxIsActive();\r\n    try {\r\n        connection.commit();\r\n    } catch (SQLException sex) {\r\n        throw new DbSqlException(\"Commit TX failed\", sex);\r\n    } finally {\r\n        closeTx();\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.Minutes.standardMinutesIn",
	"Comment": "creates a new minutes representing the number of completestandard length minutes in the specified period.this factory method converts all fields from the period to minutes using standardiseddurations for each field. only those fields which have a precise duration inthe iso utc chronology can be converted.one week consists of 7 days.one day consists of 24 hours.one hour consists of 60 minutes.one minute consists of 60 seconds.one second consists of 1000 milliseconds.months and years are imprecise and periods containing these values cannot be converted.",
	"Method": "Minutes standardMinutesIn(ReadablePeriod period){\r\n    int amount = BaseSingleFieldPeriod.standardPeriodIn(period, DateTimeConstants.MILLIS_PER_MINUTE);\r\n    return Minutes.minutes(amount);\r\n}"
}, {
	"Path": "jodd.crypt.BCrypt.checkpw",
	"Comment": "check that a plaintext password matches a previously hashed",
	"Method": "boolean checkpw(String plaintext,String hashed){\r\n    byte[] hashed_bytes;\r\n    byte[] try_bytes;\r\n    try {\r\n        String try_pw = hashpw(plaintext, hashed);\r\n        hashed_bytes = hashed.getBytes(\"UTF-8\");\r\n        try_bytes = try_pw.getBytes(\"UTF-8\");\r\n    } catch (UnsupportedEncodingException uee) {\r\n        return false;\r\n    }\r\n    if (hashed_bytes.length != try_bytes.length) {\r\n        return false;\r\n    }\r\n    byte ret = 0;\r\n    for (int i = 0; i < try_bytes.length; i++) {\r\n        ret |= hashed_bytes[i] ^ try_bytes[i];\r\n    }\r\n    return ret == 0;\r\n}"
}, {
	"Path": "jodd.json.meta.JsonAnnotationManager.lookupTypeData",
	"Comment": "returns all includes for given type. returns an empty array\twhen no includes are defined.",
	"Method": "TypeData lookupTypeData(Class type){\r\n    TypeData typeData = typeDataMap.get(type);\r\n    if (typeData == null) {\r\n        if (serializationSubclassAware) {\r\n            typeData = findSubclassTypeData(type);\r\n        }\r\n        if (typeData == null) {\r\n            typeData = scanClassForAnnotations(type);\r\n            typeDataMap.put(type, typeData);\r\n        }\r\n    }\r\n    return typeData;\r\n}"
}, {
	"Path": "org.joda.time.field.AbstractReadableInstantFieldProperty.remainder",
	"Comment": "returns the fractional duration milliseconds of this field.",
	"Method": "long remainder(){\r\n    return getField().remainder(getMillis());\r\n}"
}, {
	"Path": "org.jsonschema2pojo.ant.Jsonschema2PojoTask.buildExtendedClassloader",
	"Comment": "build a classloader using the additional elements specified inclasspath and classpathref.",
	"Method": "ClassLoader buildExtendedClassloader(){\r\n    final List<URL> classpathUrls = new ArrayList();\r\n    for (String pathElement : getClasspath().list()) {\r\n        try {\r\n            classpathUrls.add(new File(pathElement).toURI().toURL());\r\n        } catch (MalformedURLException e) {\r\n            throw new BuildException(\"Unable to use classpath entry as it could not be understood as a valid URL: \" + pathElement, e);\r\n        }\r\n    }\r\n    final ClassLoader parentClassloader = Thread.currentThread().getContextClassLoader();\r\n    return AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {\r\n        @Override\r\n        public ClassLoader run() {\r\n            return new URLClassLoader(classpathUrls.toArray(new URL[classpathUrls.size()]), parentClassloader);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.jsonschema2pojo.ant.Jsonschema2PojoTask.buildExtendedClassloader",
	"Comment": "build a classloader using the additional elements specified inclasspath and classpathref.",
	"Method": "ClassLoader buildExtendedClassloader(){\r\n    return new URLClassLoader(classpathUrls.toArray(new URL[classpathUrls.size()]), parentClassloader);\r\n}"
}, {
	"Path": "jodd.madvoc.result.AbstractTemplateViewActionResult.targetNotFound",
	"Comment": "called when target not found. by default sends 404 to the response.",
	"Method": "void targetNotFound(ActionRequest actionRequest,String actionAndResultPath){\r\n    final HttpServletResponse response = actionRequest.getHttpServletResponse();\r\n    if (!response.isCommitted()) {\r\n        response.sendError(SC_NOT_FOUND, \"Result not found: \" + actionAndResultPath);\r\n    }\r\n}"
}, {
	"Path": "jodd.io.findfile.ClassScanner.bytecodeSignatureOfType",
	"Comment": "returns type signature bytes used for searching in class file.",
	"Method": "byte[] bytecodeSignatureOfType(Class type){\r\n    final String name = 'L' + type.getName().replace('.', '/') + ';';\r\n    return name.getBytes();\r\n}"
}, {
	"Path": "org.joda.time.PeriodType.standard",
	"Comment": "gets a type that defines all standard fields.yearsmonthsweeksdayshoursminutessecondsmilliseconds",
	"Method": "PeriodType standard(){\r\n    PeriodType type = cStandard;\r\n    if (type == null) {\r\n        type = new PeriodType(\"Standard\", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.months(), DurationFieldType.weeks(), DurationFieldType.days(), DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { 0, 1, 2, 3, 4, 5, 6, 7 });\r\n        cStandard = type;\r\n    }\r\n    return type;\r\n}"
}, {
	"Path": "org.joda.time.DateMidnight.weekyear",
	"Comment": "get the year of a week based year property which provides access to advanced functionality.",
	"Method": "Property weekyear(){\r\n    return new Property(this, getChronology().weekyear());\r\n}"
}, {
	"Path": "net.majorkernelpanic.streaming.audio.AACStream.testADTS",
	"Comment": "records a short sample of aac adts from the microphone to find out what the sampling rate really is\ton some phone indeed, no error will be reported if the sampling rate used differs from the \tone selected with setaudiosamplingrate",
	"Method": "void testADTS(){\r\n    setAudioEncoder(MediaRecorder.AudioEncoder.AAC);\r\n    try {\r\n        Field name = MediaRecorder.OutputFormat.class.getField(\"AAC_ADTS\");\r\n        setOutputFormat(name.getInt(null));\r\n    } catch (Exception ignore) {\r\n        setOutputFormat(6);\r\n    }\r\n    String key = PREF_PREFIX + \"aac-\" + mQuality.samplingRate;\r\n    if (mSettings != null && mSettings.contains(key)) {\r\n        String[] s = mSettings.getString(key, \"\").split(\",\");\r\n        mQuality.samplingRate = Integer.valueOf(s[0]);\r\n        mConfig = Integer.valueOf(s[1]);\r\n        mChannel = Integer.valueOf(s[2]);\r\n        return;\r\n    }\r\n    final String TESTFILE = Environment.getExternalStorageDirectory().getPath() + \"/spydroid-test.adts\";\r\n    if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {\r\n        throw new IllegalStateException(\"No external storage or external storage not ready !\");\r\n    }\r\n    byte[] buffer = new byte[9];\r\n    mMediaRecorder = new MediaRecorder();\r\n    mMediaRecorder.setAudioSource(mAudioSource);\r\n    mMediaRecorder.setOutputFormat(mOutputFormat);\r\n    mMediaRecorder.setAudioEncoder(mAudioEncoder);\r\n    mMediaRecorder.setAudioChannels(1);\r\n    mMediaRecorder.setAudioSamplingRate(mQuality.samplingRate);\r\n    mMediaRecorder.setAudioEncodingBitRate(mQuality.bitRate);\r\n    mMediaRecorder.setOutputFile(TESTFILE);\r\n    mMediaRecorder.setMaxDuration(1000);\r\n    mMediaRecorder.prepare();\r\n    mMediaRecorder.start();\r\n    try {\r\n        Thread.sleep(2000);\r\n    } catch (InterruptedException e) {\r\n    }\r\n    mMediaRecorder.stop();\r\n    mMediaRecorder.release();\r\n    mMediaRecorder = null;\r\n    File file = new File(TESTFILE);\r\n    RandomAccessFile raf = new RandomAccessFile(file, \"r\");\r\n    while (true) {\r\n        if ((raf.readByte() & 0xFF) == 0xFF) {\r\n            buffer[0] = raf.readByte();\r\n            if ((buffer[0] & 0xF0) == 0xF0)\r\n                break;\r\n        }\r\n    }\r\n    raf.read(buffer, 1, 5);\r\n    mSamplingRateIndex = (buffer[1] & 0x3C) >> 2;\r\n    mProfile = ((buffer[1] & 0xC0) >> 6) + 1;\r\n    mChannel = (buffer[1] & 0x01) << 2 | (buffer[2] & 0xC0) >> 6;\r\n    mQuality.samplingRate = AUDIO_SAMPLING_RATES[mSamplingRateIndex];\r\n    mConfig = (mProfile & 0x1F) << 11 | (mSamplingRateIndex & 0x0F) << 7 | (mChannel & 0x0F) << 3;\r\n    Log.i(TAG, \"MPEG VERSION: \" + ((buffer[0] & 0x08) >> 3));\r\n    Log.i(TAG, \"PROTECTION: \" + (buffer[0] & 0x01));\r\n    Log.i(TAG, \"PROFILE: \" + AUDIO_OBJECT_TYPES[mProfile]);\r\n    Log.i(TAG, \"SAMPLING FREQUENCY: \" + mQuality.samplingRate);\r\n    Log.i(TAG, \"CHANNEL: \" + mChannel);\r\n    raf.close();\r\n    if (mSettings != null) {\r\n        Editor editor = mSettings.edit();\r\n        editor.putString(key, mQuality.samplingRate + \",\" + mConfig + \",\" + mChannel);\r\n        editor.commit();\r\n    }\r\n    if (!file.delete())\r\n        Log.e(TAG, \"Temp file could not be erased\");\r\n}"
}, {
	"Path": "jodd.util.StringUtil.trimDownAll",
	"Comment": "trims array of strings where empty strings are set to null.\tnull elements of the array are ignored.",
	"Method": "void trimDownAll(String strings){\r\n    for (int i = 0; i < strings.length; i++) {\r\n        String string = strings[i];\r\n        if (string != null) {\r\n            strings[i] = trimDown(string);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jodd.jtx.JtxTransactionManager.setSingleResourceManager",
	"Comment": "specifies if transaction manager works with just one resource.",
	"Method": "void setSingleResourceManager(boolean oneResourceManager){\r\n    this.oneResourceManager = oneResourceManager;\r\n}"
}, {
	"Path": "org.joda.time.LocalTime.isSupported",
	"Comment": "checks if the duration type specified is supported by thislocal time and chronology.",
	"Method": "boolean isSupported(DateTimeFieldType type,boolean isSupported,DurationFieldType type){\r\n    if (type == null) {\r\n        return false;\r\n    }\r\n    DurationField field = type.getField(getChronology());\r\n    if (TIME_DURATION_TYPES.contains(type) || field.getUnitMillis() < getChronology().days().getUnitMillis()) {\r\n        return field.isSupported();\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "jodd.jerry.Jerry.before",
	"Comment": "inserts content, specified by the parameter, before each\telement in the set of matched elements.",
	"Method": "Jerry before(String html){\r\n    if (html == null) {\r\n        html = StringPool.EMPTY;\r\n    }\r\n    final Document doc = builder.parse(html);\r\n    if (nodes.length == 0) {\r\n        return this;\r\n    }\r\n    for (Node node : nodes) {\r\n        Document workingDoc = doc.clone();\r\n        node.insertBefore(workingDoc.getChildNodes(), node);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "jodd.asm7.ClassReader.readModuleAttributes",
	"Comment": "reads the module, modulepackages and modulemainclass attributes and visit them.",
	"Method": "void readModuleAttributes(ClassVisitor classVisitor,Context context,int moduleOffset,int modulePackagesOffset,String moduleMainClass){\r\n    char[] buffer = context.charBuffer;\r\n    int currentOffset = moduleOffset;\r\n    String moduleName = readModule(currentOffset, buffer);\r\n    int moduleFlags = readUnsignedShort(currentOffset + 2);\r\n    String moduleVersion = readUTF8(currentOffset + 4, buffer);\r\n    currentOffset += 6;\r\n    ModuleVisitor moduleVisitor = classVisitor.visitModule(moduleName, moduleFlags, moduleVersion);\r\n    if (moduleVisitor == null) {\r\n        return;\r\n    }\r\n    if (moduleMainClass != null) {\r\n        moduleVisitor.visitMainClass(moduleMainClass);\r\n    }\r\n    if (modulePackagesOffset != 0) {\r\n        int packageCount = readUnsignedShort(modulePackagesOffset);\r\n        int currentPackageOffset = modulePackagesOffset + 2;\r\n        while (packageCount-- > 0) {\r\n            moduleVisitor.visitPackage(readPackage(currentPackageOffset, buffer));\r\n            currentPackageOffset += 2;\r\n        }\r\n    }\r\n    int requiresCount = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    while (requiresCount-- > 0) {\r\n        String requires = readModule(currentOffset, buffer);\r\n        int requiresFlags = readUnsignedShort(currentOffset + 2);\r\n        String requiresVersion = readUTF8(currentOffset + 4, buffer);\r\n        currentOffset += 6;\r\n        moduleVisitor.visitRequire(requires, requiresFlags, requiresVersion);\r\n    }\r\n    int exportsCount = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    while (exportsCount-- > 0) {\r\n        String exports = readPackage(currentOffset, buffer);\r\n        int exportsFlags = readUnsignedShort(currentOffset + 2);\r\n        int exportsToCount = readUnsignedShort(currentOffset + 4);\r\n        currentOffset += 6;\r\n        String[] exportsTo = null;\r\n        if (exportsToCount != 0) {\r\n            exportsTo = new String[exportsToCount];\r\n            for (int i = 0; i < exportsToCount; ++i) {\r\n                exportsTo[i] = readModule(currentOffset, buffer);\r\n                currentOffset += 2;\r\n            }\r\n        }\r\n        moduleVisitor.visitExport(exports, exportsFlags, exportsTo);\r\n    }\r\n    int opensCount = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    while (opensCount-- > 0) {\r\n        String opens = readPackage(currentOffset, buffer);\r\n        int opensFlags = readUnsignedShort(currentOffset + 2);\r\n        int opensToCount = readUnsignedShort(currentOffset + 4);\r\n        currentOffset += 6;\r\n        String[] opensTo = null;\r\n        if (opensToCount != 0) {\r\n            opensTo = new String[opensToCount];\r\n            for (int i = 0; i < opensToCount; ++i) {\r\n                opensTo[i] = readModule(currentOffset, buffer);\r\n                currentOffset += 2;\r\n            }\r\n        }\r\n        moduleVisitor.visitOpen(opens, opensFlags, opensTo);\r\n    }\r\n    int usesCount = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    while (usesCount-- > 0) {\r\n        moduleVisitor.visitUse(readClass(currentOffset, buffer));\r\n        currentOffset += 2;\r\n    }\r\n    int providesCount = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    while (providesCount-- > 0) {\r\n        String provides = readClass(currentOffset, buffer);\r\n        int providesWithCount = readUnsignedShort(currentOffset + 2);\r\n        currentOffset += 4;\r\n        String[] providesWith = new String[providesWithCount];\r\n        for (int i = 0; i < providesWithCount; ++i) {\r\n            providesWith[i] = readClass(currentOffset, buffer);\r\n            currentOffset += 2;\r\n        }\r\n        moduleVisitor.visitProvide(provides, providesWith);\r\n    }\r\n    moduleVisitor.visitEnd();\r\n}"
}, {
	"Path": "jodd.htmlstapler.HtmlStaplerBundlesManager.setNotFoundExceptionEnabled",
	"Comment": "sets if exception should be thrown when some resource is not found.\tif not enabled, the error will be logged as a warning.",
	"Method": "void setNotFoundExceptionEnabled(boolean notFoundExceptionEnabled){\r\n    this.notFoundExceptionEnabled = notFoundExceptionEnabled;\r\n}"
}, {
	"Path": "jodd.db.type.SqlType.readValue",
	"Comment": "reads value from database. value is casted to destination type.",
	"Method": "E readValue(ResultSet rs,int index,Class<E> destinationType,int dbSqlType){\r\n    T t = get(rs, index, dbSqlType);\r\n    return prepareGetValue(t, destinationType);\r\n}"
}, {
	"Path": "org.json.JSONTokener.next",
	"Comment": "consume the next character, and check that it matches a specifiedcharacter.",
	"Method": "char next(char next,char c,String next,int n){\r\n    if (n == 0) {\r\n        return \"\";\r\n    }\r\n    char[] chars = new char[n];\r\n    int pos = 0;\r\n    while (pos < n) {\r\n        chars[pos] = this.next();\r\n        if (this.end()) {\r\n            throw this.syntaxError(\"Substring bounds error\");\r\n        }\r\n        pos += 1;\r\n    }\r\n    return new String(chars);\r\n}"
}, {
	"Path": "org.json.CDL.getValue",
	"Comment": "get the next value. the value can be wrapped in quotes. the value canbe empty.",
	"Method": "String getValue(JSONTokener x){\r\n    char c;\r\n    char q;\r\n    StringBuffer sb;\r\n    do {\r\n        c = x.next();\r\n    } while (c == ' ' || c == '\\t');\r\n    switch(c) {\r\n        case 0:\r\n            return null;\r\n        case '\"':\r\n        case '\\'':\r\n            q = c;\r\n            sb = new StringBuffer();\r\n            for (; ; ) {\r\n                c = x.next();\r\n                if (c == q) {\r\n                    char nextC = x.next();\r\n                    if (nextC != '\\\"') {\r\n                        if (nextC > 0) {\r\n                            x.back();\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                if (c == 0 || c == '\\n' || c == '\\r') {\r\n                    throw x.syntaxError(\"Missing close quote '\" + q + \"'.\");\r\n                }\r\n                sb.append(c);\r\n            }\r\n            return sb.toString();\r\n        case ',':\r\n            x.back();\r\n            return \"\";\r\n        default:\r\n            x.back();\r\n            return x.nextTo(',');\r\n    }\r\n}"
}, {
	"Path": "org.joda.time.Weeks.isGreaterThan",
	"Comment": "is this weeks instance greater than the specified number of weeks.",
	"Method": "boolean isGreaterThan(Weeks other){\r\n    if (other == null) {\r\n        return getValue() > 0;\r\n    }\r\n    return getValue() > other.getValue();\r\n}"
}, {
	"Path": "org.jooq.meta.jaxb.Database.getExcludes",
	"Comment": "all elements that are excluded from your schema.this is a java regular expression. use the pipe to separate several expressions.excludes match before includes, i.e. excludes have a higher priority.",
	"Method": "String getExcludes(){\r\n    return excludes;\r\n}"
}, {
	"Path": "jodd.asm7.SymbolTable.addType",
	"Comment": "adds a type in the type table of this symbol table. does nothing if the type table alreadycontains a similar type.",
	"Method": "int addType(String value){\r\n    int hashCode = hash(Symbol.TYPE_TAG, value);\r\n    Entry entry = get(hashCode);\r\n    while (entry != null) {\r\n        if (entry.tag == Symbol.TYPE_TAG && entry.hashCode == hashCode && entry.value.equals(value)) {\r\n            return entry.index;\r\n        }\r\n        entry = entry.next;\r\n    }\r\n    return addTypeInternal(new Entry(typeCount, Symbol.TYPE_TAG, value, hashCode));\r\n}"
}]