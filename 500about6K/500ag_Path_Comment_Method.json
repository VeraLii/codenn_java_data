[{
	"Path": "com.uber.nullaway.NullabilityUtil.findEnclosingMethodOrLambdaOrInitializer",
	"Comment": "find the enclosing method, lambda expression or initializer block for the leaf of some treepath",
	"Method": "TreePath findEnclosingMethodOrLambdaOrInitializer(TreePath path){\r\n    TreePath curPath = path.getParentPath();\r\n    while (curPath != null) {\r\n        if (curPath.getLeaf() instanceof MethodTree || curPath.getLeaf() instanceof LambdaExpressionTree) {\r\n            return curPath;\r\n        }\r\n        TreePath parent = curPath.getParentPath();\r\n        if (parent != null && parent.getLeaf() instanceof ClassTree) {\r\n            if (curPath.getLeaf() instanceof BlockTree) {\r\n                return curPath;\r\n            }\r\n            if (curPath.getLeaf() instanceof VariableTree && ((VariableTree) curPath.getLeaf()).getInitializer() != null) {\r\n                return curPath;\r\n            }\r\n        }\r\n        curPath = parent;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "io.objectbox.relation.ToOne.setTarget",
	"Comment": "todo provide a overload with a tomany parameter, which also gets updated",
	"Method": "void setTarget(TARGET target){\r\n    if (target != null) {\r\n        long targetId = relationInfo.targetInfo.getIdGetter().getId(target);\r\n        checkIdOfTargetForPut = targetId == 0;\r\n        setTargetId(targetId);\r\n        setResolvedTarget(target, targetId);\r\n    } else {\r\n        setTargetId(0);\r\n        clearResolved();\r\n    }\r\n}"
}, {
	"Path": "io.restassured.internal.http.URIBuilder.equals",
	"Comment": "determine if this uribuilder is equal to another uribuilder instance.",
	"Method": "boolean equals(Object obj){\r\n    if (!(obj instanceof URIBuilder))\r\n        return false;\r\n    return this.base.equals(((URIBuilder) obj).toURI());\r\n}"
}, {
	"Path": "org.reflections.ReflectionUtils.forNames",
	"Comment": "try to resolve all given string representation of types to a list of java types",
	"Method": "List<Class<? extends T>> forNames(Iterable<String> classes,ClassLoader classLoaders){\r\n    List<Class<? extends T>> result = new ArrayList<Class<? extends T>>();\r\n    for (String className : classes) {\r\n        Class<?> type = forName(className, classLoaders);\r\n        if (type != null) {\r\n            result.add((Class<? extends T>) type);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "net.minecraftforge.common.config.Property.isDoubleValue",
	"Comment": "checks if the current value held by this property is a valid double value.",
	"Method": "boolean isDoubleValue(){\r\n    try {\r\n        Double.parseDouble(value);\r\n        return true;\r\n    } catch (NumberFormatException e) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "co.paralleluniverse.concurrent.util.ScheduledSingleThreadExecutor.onShutdown",
	"Comment": "cancels and clears the queue of all tasks that should not be rundue to shutdown policy. invoked within super.shutdown.",
	"Method": "void onShutdown(){\r\n    BlockingQueue<RunnableScheduledFuture<?>> q = workQueue;\r\n    boolean keepDelayed = getExecuteExistingDelayedTasksAfterShutdownPolicy();\r\n    boolean keepPeriodic = getContinueExistingPeriodicTasksAfterShutdownPolicy();\r\n    if (!keepDelayed && !keepPeriodic) {\r\n        for (Object e : q.toArray()) if (e instanceof RunnableScheduledFuture<?>)\r\n            ((RunnableScheduledFuture<?>) e).cancel(false);\r\n        q.clear();\r\n    } else {\r\n        for (Object e : q) {\r\n            if (e instanceof RunnableScheduledFuture) {\r\n                RunnableScheduledFuture<?> t = (RunnableScheduledFuture<?>) e;\r\n                if ((t.isPeriodic() ? !keepPeriodic : !keepDelayed) || t.isCancelled()) {\r\n                    if (q.remove(t))\r\n                        t.cancel(false);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.config.annotation.web.configurers.FormLoginConfigurer.getUsernameParameter",
	"Comment": "gets the http parameter that is used to submit the username.",
	"Method": "String getUsernameParameter(){\r\n    return getAuthenticationFilter().getUsernameParameter();\r\n}"
}, {
	"Path": "net.minecraftforge.common.brewing.BrewingRecipeRegistry.isValidIngredient",
	"Comment": "returns true if the passed itemstack is a valid ingredient for any of therecipes in the registry.",
	"Method": "boolean isValidIngredient(ItemStack stack){\r\n    if (stack.isEmpty())\r\n        return false;\r\n    for (IBrewingRecipe recipe : recipes) {\r\n        if (recipe.isIngredient(stack)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.uber.nullaway.jarinfer.DefinitelyDerefedParams.analyzeReturnType",
	"Comment": "this is the nullability analysis for the method return value.",
	"Method": "NullnessHint analyzeReturnType(){\r\n    if (method.getReturnType().isPrimitiveType()) {\r\n        LOG(DEBUG, \"DEBUG\", \"Skipping method with primitive return type: \" + method.getSignature());\r\n        return NullnessHint.UNKNOWN;\r\n    }\r\n    LOG(DEBUG, \"DEBUG\", \"@ Return type analysis for: \" + method.getSignature());\r\n    if (prunedCFG == null) {\r\n        prunedCFG = ExceptionPrunedCFG.make(cfg);\r\n    }\r\n    if (prunedCFG.getNumberOfNodes() == 2 && prunedCFG.containsNode(cfg.entry()) && prunedCFG.containsNode(cfg.exit()) && GraphUtil.countEdges(prunedCFG) == 0) {\r\n        return NullnessHint.UNKNOWN;\r\n    }\r\n    for (ISSABasicBlock bb : prunedCFG.getNormalPredecessors(prunedCFG.exit())) {\r\n        for (int i = bb.getFirstInstructionIndex(); i <= bb.getLastInstructionIndex(); i++) {\r\n            SSAInstruction instr = ir.getInstructions()[i];\r\n            if (instr instanceof SSAReturnInstruction) {\r\n                SSAReturnInstruction retInstr = (SSAReturnInstruction) instr;\r\n                if (ir.getSymbolTable().isNullConstant(retInstr.getResult())) {\r\n                    LOG(DEBUG, \"DEBUG\", \"Nullable return in method: \" + method.getSignature());\r\n                    return NullnessHint.NULLABLE;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return NullnessHint.UNKNOWN;\r\n}"
}, {
	"Path": "io.objectbox.Box.count",
	"Comment": "returns the count of all stored objects in this box or the given maxcount, whichever is lower.",
	"Method": "long count(long count,long maxCount){\r\n    Cursor<T> reader = getReader();\r\n    try {\r\n        return reader.count(maxCount);\r\n    } finally {\r\n        releaseReader(reader);\r\n    }\r\n}"
}, {
	"Path": "net.minecraftforge.fml.common.event.FMLPreInitializationEvent.getModConfigurationDirectory",
	"Comment": "get the main configuration directory for this minecraft instance",
	"Method": "File getModConfigurationDirectory(){\r\n    return configurationDir;\r\n}"
}, {
	"Path": "net.orfjackal.retrolambda.test.DefaultMethodsTest.default_methods_with_lambdas_in_another_package",
	"Comment": "lambdas which capture this in default methods will generate the lambda implementationmethod as a private instance method. we must avoid copying those methods tothe interface implementers as if they were default methods.",
	"Method": "void default_methods_with_lambdas_in_another_package(){\r\n    assumeThat(SystemUtils.JAVA_VERSION_FLOAT, is(lessThan(1.8f)));\r\n    UsesLambdasInAnotherPackage obj = new UsesLambdasInAnotherPackage() {\r\n    };\r\n    assertThat(obj.stateless().call(), is(\"foo\"));\r\n    assertThat(obj.captureThis().call(), is(\"foo\"));\r\n    assertThat(\"should contain only delegates to the two default methods\", obj.getClass().getDeclaredMethods(), arrayWithSize(2));\r\n}"
}, {
	"Path": "org.nanohttpd.protocols.http.NanoHTTPD.decodeParameters",
	"Comment": "decode parameters from a url, handing the case where a single parametername might have been supplied several times, by return lists of values.in general these lists will contain a single element.",
	"Method": "Map<String, List<String>> decodeParameters(Map<String, String> parms,Map<String, List<String>> decodeParameters,String queryString){\r\n    Map<String, List<String>> parms = new HashMap<String, List<String>>();\r\n    if (queryString != null) {\r\n        StringTokenizer st = new StringTokenizer(queryString, \"&\");\r\n        while (st.hasMoreTokens()) {\r\n            String e = st.nextToken();\r\n            int sep = e.indexOf('=');\r\n            String propertyName = sep >= 0 ? decodePercent(e.substring(0, sep)).trim() : decodePercent(e).trim();\r\n            if (!parms.containsKey(propertyName)) {\r\n                parms.put(propertyName, new ArrayList<String>());\r\n            }\r\n            String propertyValue = sep >= 0 ? decodePercent(e.substring(sep + 1)) : null;\r\n            if (propertyValue != null) {\r\n                parms.get(propertyName).add(propertyValue);\r\n            }\r\n        }\r\n    }\r\n    return parms;\r\n}"
}, {
	"Path": "net.minecraftforge.fml.client.FMLClientHandler.finishMinecraftLoading",
	"Comment": "called a bit later on during initialization to finish loading modsalso initializes key bindings",
	"Method": "void finishMinecraftLoading(){\r\n    if (hasError()) {\r\n        SplashProgress.finish();\r\n        return;\r\n    }\r\n    try {\r\n        Loader.instance().initializeMods();\r\n    } catch (LoaderException le) {\r\n        if (le.getCause() instanceof CustomModLoadingErrorDisplayException) {\r\n            CustomModLoadingErrorDisplayException custom = (CustomModLoadingErrorDisplayException) le.getCause();\r\n            FMLLog.log.error(\"A custom exception was thrown by a mod, the game will display an error screen and halt.\", custom);\r\n            errorToDisplay = custom;\r\n            MinecraftForge.EVENT_BUS.shutdown();\r\n        } else {\r\n            haltGame(\"There was a severe problem during mod loading that has caused the game to fail\", le);\r\n            return;\r\n        }\r\n    }\r\n    if (Boolean.parseBoolean(System.getProperty(\"fml.reloadResourcesOnStart\", \"false\"))) {\r\n        client.refreshResources();\r\n    }\r\n    RenderingRegistry.loadEntityRenderers(Minecraft.getMinecraft().getRenderManager().entityRenderMap);\r\n    guiFactories = HashBiMap.create();\r\n    for (ModContainer mc : Loader.instance().getActiveModList()) {\r\n        String className = mc.getGuiClassName();\r\n        if (Strings.isNullOrEmpty(className)) {\r\n            if (ConfigManager.hasConfigForMod(mc.getModId())) {\r\n                guiFactories.put(mc, DefaultGuiFactory.forMod(mc));\r\n            }\r\n            continue;\r\n        }\r\n        try {\r\n            Class<?> clazz = Class.forName(className, true, Loader.instance().getModClassLoader());\r\n            Class<? extends IModGuiFactory> guiClassFactory = clazz.asSubclass(IModGuiFactory.class);\r\n            IModGuiFactory guiFactory = guiClassFactory.newInstance();\r\n            guiFactory.initialize(client);\r\n            guiFactories.put(mc, guiFactory);\r\n        } catch (Exception e) {\r\n            FMLLog.log.error(\"A critical error occurred instantiating the gui factory for mod {}\", mc.getModId(), e);\r\n        }\r\n    }\r\n    loading = false;\r\n    client.gameSettings.loadOptions();\r\n    if (!hasError())\r\n        Loader.instance().loadingComplete();\r\n    SplashProgress.finish();\r\n}"
}, {
	"Path": "net.minecraftforge.common.ForgeChunkManager.getPersistentChunksFor",
	"Comment": "the list of persistent chunks in the world. this set is immutable.",
	"Method": "ImmutableSetMultimap<ChunkPos, Ticket> getPersistentChunksFor(World world){\r\n    return forcedChunks.containsKey(world) ? forcedChunks.get(world) : ImmutableSetMultimap.of();\r\n}"
}, {
	"Path": "net.minecraftforge.common.config.ConfigCategory.showInGui",
	"Comment": "gets whether or not this configcategory should be allowed to show on config guis.defaults to true unless set to false.",
	"Method": "boolean showInGui(){\r\n    return showInGui;\r\n}"
}, {
	"Path": "io.objectbox.query.Query.find",
	"Comment": "find all objects matching the query between the given offset and limit. this helps with pagination.",
	"Method": "List<T> find(List<T> find,long offset,long limit){\r\n    ensureNoFilterNoComparator();\r\n    return callInReadTx(new Callable<List<T>>() {\r\n        @Override\r\n        public List<T> call() {\r\n            List entities = nativeFind(handle, cursorHandle(), offset, limit);\r\n            resolveEagerRelations(entities);\r\n            return entities;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "io.objectbox.query.Query.find",
	"Comment": "find all objects matching the query between the given offset and limit. this helps with pagination.",
	"Method": "List<T> find(List<T> find,long offset,long limit){\r\n    List entities = nativeFind(handle, cursorHandle(), offset, limit);\r\n    resolveEagerRelations(entities);\r\n    return entities;\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.AbstractQueuedSynchronizer.transferAfterCancelledWait",
	"Comment": "transfers node, if necessary, to sync queue after a cancelled wait.returns true if strand was cancelled before being signalled.",
	"Method": "boolean transferAfterCancelledWait(Node node){\r\n    if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) {\r\n        enq(node);\r\n        return true;\r\n    }\r\n    while (!isOnSyncQueue(node)) Strand.yield();\r\n    return false;\r\n}"
}, {
	"Path": "io.restassured.http.Cookie.getComment",
	"Comment": "returns the comment describing the purpose of this cookie, ornull if no such comment has been defined.",
	"Method": "String getComment(){\r\n    return comment;\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.channels.SelectAction.message",
	"Comment": "returns the message to send if this is a send operation, or the message that has been received if this is a receive operation and has beensuccessfully completed by the selector.",
	"Method": "Message message(){\r\n    return item;\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.AbstractQueuedSynchronizer.fullGetFirstQueuedStrand",
	"Comment": "version of getfirstqueuedstrand called when fastpath fails",
	"Method": "Strand fullGetFirstQueuedStrand(){\r\n    Node h, s;\r\n    Strand st;\r\n    if (((h = head) != null && (s = h.next) != null && s.prev == head && (st = s.strand) != null) || ((h = head) != null && (s = h.next) != null && s.prev == head && (st = s.strand) != null))\r\n        return st;\r\n    Node t = tail;\r\n    Strand firstStrand = null;\r\n    while (t != null && t != head) {\r\n        Strand tt = t.strand;\r\n        if (tt != null)\r\n            firstStrand = tt;\r\n        t = t.prev;\r\n    }\r\n    return firstStrand;\r\n}"
}, {
	"Path": "co.paralleluniverse.actors.behaviors.SupervisorActor.addChild",
	"Comment": "adds a new child actor to the supervisor. if the child has not been started, it will be started by the supervisor.",
	"Method": "T addChild(ChildSpec spec){\r\n    verifyInActor();\r\n    final ChildEntry child = addChild1(spec);\r\n    ActorRef<?> actor = null;\r\n    if (spec.builder instanceof Actor) {\r\n        final Actor a = ((Actor) spec.builder);\r\n        actor = a.isStarted() ? a.ref() : a.spawn();\r\n    }\r\n    if (actor == null)\r\n        actor = start(child);\r\n    else\r\n        start(child, actor);\r\n    return (T) actor;\r\n}"
}, {
	"Path": "net.minecraftforge.common.model.animation.AnimationStateMachine.load",
	"Comment": "load a new instance if animationstatemachine at specified location, with specified custom parameters.",
	"Method": "IAnimationStateMachine load(IResourceManager manager,ResourceLocation location,ImmutableMap<String, ITimeValue> customParameters){\r\n    try (IResource resource = manager.getResource(location)) {\r\n        ClipResolver clipResolver = new ClipResolver();\r\n        ParameterResolver parameterResolver = new ParameterResolver(customParameters);\r\n        Clips.CommonClipTypeAdapterFactory.INSTANCE.setClipResolver(clipResolver);\r\n        TimeValues.CommonTimeValueTypeAdapterFactory.INSTANCE.setValueResolver(parameterResolver);\r\n        AnimationStateMachine asm = asmGson.fromJson(new InputStreamReader(resource.getInputStream(), StandardCharsets.UTF_8), AnimationStateMachine.class);\r\n        clipResolver.asm = asm;\r\n        parameterResolver.asm = asm;\r\n        asm.initialize();\r\n        return asm;\r\n    } catch (IOException | JsonParseException e) {\r\n        FMLLog.log.error(\"Exception loading Animation State Machine {}, skipping\", location, e);\r\n        return missing;\r\n    } finally {\r\n        Clips.CommonClipTypeAdapterFactory.INSTANCE.setClipResolver(null);\r\n        TimeValues.CommonTimeValueTypeAdapterFactory.INSTANCE.setValueResolver(null);\r\n    }\r\n}"
}, {
	"Path": "net.minecraftforge.fluids.FluidStack.isFluidEqual",
	"Comment": "determines if the fluidids and nbt tags are equal compared to a registered containeritemstack. this does not check amounts.",
	"Method": "boolean isFluidEqual(FluidStack other,boolean isFluidEqual,ItemStack other){\r\n    if (other == null) {\r\n        return false;\r\n    }\r\n    return isFluidEqual(FluidUtil.getFluidContained(other));\r\n}"
}, {
	"Path": "io.restassured.http.Cookies.get",
	"Comment": "get a single cookie with the supplied name. if there are several cookies match the cookiename thenthe first one is returned.",
	"Method": "Cookie get(String cookieName){\r\n    AssertParameter.notNull(cookieName, \"Cookie name\");\r\n    return cookies.get(cookieName);\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.CyclicBarrier.breakBarrier",
	"Comment": "sets current barrier generation as broken and wakes up everyone.called only while holding lock.",
	"Method": "void breakBarrier(){\r\n    generation.broken = true;\r\n    count = parties;\r\n    trip.signalAll();\r\n}"
}, {
	"Path": "co.paralleluniverse.common.util.Debug.printStackTraceAsCause",
	"Comment": "print our stack trace as a cause for the specified stack trace.",
	"Method": "void printStackTraceAsCause(PrintStream s,StackTraceElement[] causedTrace,Throwable t,StackTraceFilter filter){\r\n    StackTraceElement[] trace = t.getStackTrace();\r\n    int m = trace.length - 1, n = causedTrace.length - 1;\r\n    while (m >= 0 && n >= 0 && trace[m].equals(causedTrace[n])) {\r\n        m--;\r\n        n--;\r\n    }\r\n    int framesInCommon = trace.length - 1 - m;\r\n    s.println(\"Caused by: \" + t);\r\n    for (int i = 0; i <= m; i++) {\r\n        if (filter.filter(trace[i]))\r\n            s.println(\"\\tat \" + trace[i]);\r\n    }\r\n    if (framesInCommon != 0)\r\n        s.println(\"\\t... \" + framesInCommon + \" more\");\r\n    Throwable ourCause = t.getCause();\r\n    if (ourCause != null)\r\n        printStackTraceAsCause(s, trace, ourCause, filter);\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.AbstractQueuedSynchronizer.isOnSyncQueue",
	"Comment": "returns true if a node, always one that was initially placed ona condition queue, is now waiting to reacquire on sync queue.",
	"Method": "boolean isOnSyncQueue(Node node){\r\n    if (node.waitStatus == Node.CONDITION || node.prev == null)\r\n        return false;\r\n    if (node.next != null)\r\n        return true;\r\n    return findNodeFromTail(node);\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.dataflow.Val.get",
	"Comment": "returns the delayed value, blocking until it has been set, but no longer than the given timeout.",
	"Method": "V get(V get,long timeout,TimeUnit unit,V get,Timeout timeout){\r\n    return get(timeout.nanosLeft(), TimeUnit.NANOSECONDS);\r\n}"
}, {
	"Path": "com.rxjava2.android.samples.ui.operators.FilterExampleActivity.doSomeWork",
	"Comment": "simple example by using filter operator to emit only even value",
	"Method": "void doSomeWork(){\r\n    Observable.just(1, 2, 3, 4, 5, 6).filter(new Predicate<Integer>() {\r\n        @Override\r\n        public boolean test(Integer integer) {\r\n            return integer % 2 == 0;\r\n        }\r\n    }).subscribe(getObserver());\r\n}"
}, {
	"Path": "com.rxjava2.android.samples.ui.operators.FilterExampleActivity.doSomeWork",
	"Comment": "simple example by using filter operator to emit only even value",
	"Method": "void doSomeWork(){\r\n    return integer % 2 == 0;\r\n}"
}, {
	"Path": "com.uber.nullaway.testdata.NullAwayNativeModels.mapStuff",
	"Comment": "we will add bug annotations when we have full support for maps",
	"Method": "void mapStuff(Map<Object, Object> m){\r\n    m.get(new Object()).toString();\r\n    Object value = m.get(new Object());\r\n    value.toString();\r\n    HashMap<Object, Object> h = new HashMap();\r\n    Object value2 = h.get(new Object());\r\n    value2.toString();\r\n}"
}, {
	"Path": "com.corundumstudio.socketio.SocketIOServer.getRoomOperations",
	"Comment": "get broadcast operations for clients withinroom by room name",
	"Method": "BroadcastOperations getRoomOperations(String room){\r\n    Iterable<SocketIOClient> clients = namespacesHub.getRoomClients(room);\r\n    return new BroadcastOperations(clients, configCopy.getStoreFactory());\r\n}"
}, {
	"Path": "co.paralleluniverse.actors.Actor.isStarted",
	"Comment": "tests whether this actor has been started, i.e. whether the strand executing it has been started.",
	"Method": "boolean isStarted(){\r\n    return runner == null || runner.isStarted();\r\n}"
}, {
	"Path": "com.rxjava2.android.samples.ui.operators.TakeExampleActivity.doSomeWork",
	"Comment": "using take operator, it only emits required number of values. here only 3 out of 5",
	"Method": "void doSomeWork(){\r\n    // Run on a background thread\r\n    getObservable().subscribeOn(// Be notified on the main thread\r\n    Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).take(3).subscribe(getObserver());\r\n}"
}, {
	"Path": "org.nanohttpd.protocols.http.content.CookieHandler.delete",
	"Comment": "set a cookie with an expiration date from a month ago, effectivelydeleting it on the client side.",
	"Method": "void delete(String name){\r\n    set(name, \"-delete-\", -30);\r\n}"
}, {
	"Path": "org.mapdb.jsr166.Collection8Test.testRandomElementRemovalDuringTraversal",
	"Comment": "some elements randomly disappear in the middle of traversal.",
	"Method": "void testRandomElementRemovalDuringTraversal(){\r\n    Collection c = impl.emptyCollection();\r\n    ThreadLocalRandom rnd = ThreadLocalRandom.current();\r\n    int n = rnd.nextInt(6);\r\n    ArrayList copy = new ArrayList();\r\n    for (int i = 0; i < n; i++) {\r\n        Object x = impl.makeElement(i);\r\n        copy.add(x);\r\n        c.add(x);\r\n    }\r\n    ArrayList iterated = new ArrayList();\r\n    ArrayList spliterated = new ArrayList();\r\n    ArrayList removed = new ArrayList();\r\n    Spliterator s = c.spliterator();\r\n    Iterator it = c.iterator();\r\n    if (!(s.hasCharacteristics(Spliterator.CONCURRENT) || s.hasCharacteristics(Spliterator.IMMUTABLE)))\r\n        return;\r\n    for (int i = rnd.nextInt(n + 1); --i >= 0; ) {\r\n        assertTrue(s.tryAdvance(e -> {\r\n        }));\r\n        if (rnd.nextBoolean())\r\n            assertTrue(it.hasNext());\r\n        it.next();\r\n    }\r\n    Consumer alwaysThrows = e -> {\r\n        throw new AssertionError();\r\n    };\r\n    if (rnd.nextBoolean()) {\r\n        for (Iterator z = c.iterator(); z.hasNext(); ) {\r\n            Object e = z.next();\r\n            if (rnd.nextBoolean()) {\r\n                try {\r\n                    z.remove();\r\n                } catch (UnsupportedOperationException ok) {\r\n                    return;\r\n                }\r\n                removed.add(e);\r\n            }\r\n        }\r\n    } else {\r\n        Predicate randomlyRemove = e -> {\r\n            if (rnd.nextBoolean()) {\r\n                removed.add(e);\r\n                return true;\r\n            } else\r\n                return false;\r\n        };\r\n        c.removeIf(randomlyRemove);\r\n    }\r\n    s.forEachRemaining(spliterated::add);\r\n    while (it.hasNext()) iterated.add(it.next());\r\n    assertTrue(copy.containsAll(iterated));\r\n    assertTrue(copy.containsAll(spliterated));\r\n    assertTrue(copy.containsAll(removed));\r\n    if (s.hasCharacteristics(Spliterator.CONCURRENT)) {\r\n        ArrayList iteratedAndRemoved = new ArrayList(iterated);\r\n        ArrayList spliteratedAndRemoved = new ArrayList(spliterated);\r\n        iteratedAndRemoved.retainAll(removed);\r\n        spliteratedAndRemoved.retainAll(removed);\r\n        assertTrue(iteratedAndRemoved.size() <= 1);\r\n        assertTrue(spliteratedAndRemoved.size() <= 1);\r\n        if (testImplementationDetails && !(c instanceof java.util.concurrent.ArrayBlockingQueue))\r\n            assertTrue(spliteratedAndRemoved.isEmpty());\r\n    }\r\n}"
}, {
	"Path": "net.minecraftforge.fml.relauncher.ReflectionHelper.findConstructor",
	"Comment": "finds a constructor in the specified class that has matching parameter types.",
	"Method": "Constructor<T> findConstructor(Class<T> klass,Class<?> parameterTypes){\r\n    Preconditions.checkNotNull(klass, \"class\");\r\n    Preconditions.checkNotNull(parameterTypes, \"parameter types\");\r\n    try {\r\n        Constructor<T> constructor = klass.getDeclaredConstructor(parameterTypes);\r\n        constructor.setAccessible(true);\r\n        return constructor;\r\n    } catch (final NoSuchMethodException e) {\r\n        final StringBuilder desc = new StringBuilder();\r\n        desc.append(klass.getSimpleName());\r\n        StringJoiner joiner = new StringJoiner(\", \", \"(\", \")\");\r\n        for (Class<?> type : parameterTypes) {\r\n            joiner.add(type.getSimpleName());\r\n        }\r\n        desc.append(joiner);\r\n        throw new UnknownConstructorException(\"Could not find constructor '\" + desc.toString() + \"' in \" + klass);\r\n    }\r\n}"
}, {
	"Path": "io.restassured.path.xml.config.XmlPathConfig.isValidating",
	"Comment": "whether xmlpath should validate documents as they are parsed.",
	"Method": "boolean isValidating(){\r\n    return validating;\r\n}"
}, {
	"Path": "co.paralleluniverse.common.util.ExtendedStackTraceElement.getClassName",
	"Comment": "returns the fully qualified name of the class containing theexecution point represented by this stack trace element.",
	"Method": "String getClassName(){\r\n    return declaringClassName;\r\n}"
}, {
	"Path": "net.minecraftforge.common.brewing.BrewingRecipeRegistry.hasOutput",
	"Comment": "returns true if the passed input and ingredient have an output",
	"Method": "boolean hasOutput(ItemStack input,ItemStack ingredient){\r\n    return !getOutput(input, ingredient).isEmpty();\r\n}"
}, {
	"Path": "io.restassured.module.mockmvc.specification.MockMvcRequestSpecBuilder.and",
	"Comment": "returns the same mockmvcrequestspecbuilder instance for syntactic sugar.",
	"Method": "MockMvcRequestSpecBuilder and(){\r\n    return this;\r\n}"
}, {
	"Path": "org.nanohttpd.junit.protocols.http.HttpPostRequestTest.preparePostWithMultipartForm",
	"Comment": "contains common preparation steps for testing post with multipart form",
	"Method": "String preparePostWithMultipartForm(String fileName,String fileContent){\r\n    String divider = UUID.randomUUID().toString();\r\n    String header = \"POST \" + HttpServerTest.URI + \" HTTP/1.1\\nContent-Type: \" + \"multipart/form-data, boundary=\" + divider + \"\\r\\n\";\r\n    String content = \"--\" + divider + \"\\r\\n\" + \"Content-Disposition: form-data; name=\\\"\" + HttpPostRequestTest.FIELD + \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\" + \"Content-Type: image/jpeg\\r\\n\" + \"\\r\\n\" + fileContent + \"\\r\\n\" + \"--\" + divider + \"--\\r\\n\";\r\n    int size = content.length() + header.length();\r\n    int contentLengthHeaderValueSize = String.valueOf(size).length();\r\n    int contentLength = size + contentLengthHeaderValueSize + HttpPostRequestTest.CONTENT_LENGTH.length();\r\n    String input = header + HttpPostRequestTest.CONTENT_LENGTH + (contentLength + 5) + \"\\r\\n\\r\\n\" + content;\r\n    return input;\r\n}"
}, {
	"Path": "io.objectbox.relation.ToOne.setAndPutTarget",
	"Comment": "todo provide a overload with a tomany parameter, which also gets updated",
	"Method": "void setAndPutTarget(TARGET target){\r\n    ensureBoxes(target);\r\n    if (target != null) {\r\n        long targetId = targetBox.getId(target);\r\n        if (targetId == 0) {\r\n            setAndPutTargetAlways(target);\r\n        } else {\r\n            setTargetId(targetId);\r\n            setResolvedTarget(target, targetId);\r\n            entityBox.put(entity);\r\n        }\r\n    } else {\r\n        setTargetId(0);\r\n        clearResolved();\r\n        entityBox.put(entity);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.cas.userdetails.GrantedAuthorityFromAssertionAttributesUserDetailsService.setConvertToUpperCase",
	"Comment": "converts the returned attribute values to uppercase values.",
	"Method": "void setConvertToUpperCase(boolean convertToUpperCase){\r\n    this.convertToUpperCase = convertToUpperCase;\r\n}"
}, {
	"Path": "io.restassured.internal.http.HTTPBuilder.getClient",
	"Comment": "return the underlying httpclient that is used to handle http requests.",
	"Method": "AbstractHttpClient getClient(){\r\n    return this.client;\r\n}"
}, {
	"Path": "co.paralleluniverse.concurrent.util.ScheduledSingleThreadExecutor.decorateTask",
	"Comment": "modifies or replaces the task used to execute a callable.this method can be used to override the concreteclass used for managing internal tasks.the default implementation simply returns the given task.",
	"Method": "RunnableScheduledFuture<V> decorateTask(Runnable runnable,RunnableScheduledFuture<V> task,RunnableScheduledFuture<V> decorateTask,Callable<V> callable,RunnableScheduledFuture<V> task){\r\n    return task;\r\n}"
}, {
	"Path": "io.restassured.builder.ResponseSpecBuilder.expectResponseTime",
	"Comment": "validate that the response time matches the supplied matcher and time unit.",
	"Method": "ResponseSpecBuilder expectResponseTime(Matcher<Long> matcher,ResponseSpecBuilder expectResponseTime,Matcher<Long> matcher,TimeUnit timeUnit){\r\n    spec.time(matcher, timeUnit);\r\n    return this;\r\n}"
}, {
	"Path": "net.minecraftforge.oredict.OreDictionary.getOres",
	"Comment": "retrieves the list of items that are registered to this ore type.creates the list as empty if it did not exist.",
	"Method": "NonNullList<ItemStack> getOres(String name,NonNullList<ItemStack> getOres,String name,boolean alwaysCreateEntry,NonNullList<ItemStack> getOres,int id){\r\n    return idToStackUn.size() > id ? idToStackUn.get(id) : EMPTY_LIST;\r\n}"
}, {
	"Path": "org.springframework.security.cas.web.CasAuthenticationEntryPoint.getEncodeServiceUrlWithSessionId",
	"Comment": "sets whether to encode the service url with the session id or not.",
	"Method": "boolean getEncodeServiceUrlWithSessionId(){\r\n    return this.encodeServiceUrlWithSessionId;\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.channels.ReceivePort.tryReceive",
	"Comment": "retrieves a message from the channel if one is available. this method never blocks.",
	"Method": "Message tryReceive(){\r\n    try {\r\n        return receive(0, TimeUnit.NANOSECONDS);\r\n    } catch (SuspendExecution | InterruptedException ex) {\r\n        throw new AssertionError(ex);\r\n    }\r\n}"
}, {
	"Path": "net.minecraftforge.oredict.OreDictionary.doesOreNameExist",
	"Comment": "returns whether or not an orename exists in the dictionary.this function can be used to safely query the ore dictionary withoutadding needless clutter to the underlying map structure.please use this when possible and appropriate.",
	"Method": "boolean doesOreNameExist(String name){\r\n    return nameToId.get(name) != null;\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.AbstractQueuedLongSynchronizer.setHead",
	"Comment": "sets head of queue to be node, thus dequeuing. called only byacquire methods.also nulls out unused fields for sake of gcand to suppress unnecessary signals and traversals.",
	"Method": "void setHead(Node node){\r\n    head = node;\r\n    node.strand = null;\r\n    node.prev = null;\r\n}"
}, {
	"Path": "net.minecraftforge.fml.common.registry.GameRegistry.createEntitySelectors",
	"Comment": "creates a list of entity selectors using the registered factories.should probably only be called by forge",
	"Method": "List<Predicate<Entity>> createEntitySelectors(Map<String, String> arguments,String mainSelector,ICommandSender sender,Vec3d position){\r\n    List<Predicate<Entity>> selectors = Lists.newArrayList();\r\n    for (IEntitySelectorFactory factory : entitySelectorFactories) {\r\n        try {\r\n            selectors.addAll(factory.createPredicates(arguments, mainSelector, sender, position));\r\n        } catch (Exception e) {\r\n            FMLLog.log.error(\"Exception caught during entity selector creation with {} for argument map {} of {} for {} at {}\", factory, arguments, mainSelector, sender, position, e);\r\n        }\r\n    }\r\n    return selectors;\r\n}"
}, {
	"Path": "io.restassured.module.mockmvc.specification.MockMvcRequestSpecBuilder.setAuth",
	"Comment": "if you need to specify some credentials when performing a request.",
	"Method": "MockMvcRequestSpecBuilder setAuth(MockMvcAuthenticationScheme auth){\r\n    auth.authenticate(spec);\r\n    return this;\r\n}"
}, {
	"Path": "paulscode.sound.codecs.CodecIBXM.appendByteArrays",
	"Comment": "creates a new array with the second array appended to the end of the firstarray.",
	"Method": "byte[] appendByteArrays(byte[] arrayOne,byte[] arrayTwo,int length){\r\n    byte[] newArray;\r\n    if (arrayOne == null && arrayTwo == null) {\r\n        return null;\r\n    } else if (arrayOne == null) {\r\n        newArray = new byte[length];\r\n        System.arraycopy(arrayTwo, 0, newArray, 0, length);\r\n        arrayTwo = null;\r\n    } else if (arrayTwo == null) {\r\n        newArray = new byte[arrayOne.length];\r\n        System.arraycopy(arrayOne, 0, newArray, 0, arrayOne.length);\r\n        arrayOne = null;\r\n    } else {\r\n        newArray = new byte[arrayOne.length + length];\r\n        System.arraycopy(arrayOne, 0, newArray, 0, arrayOne.length);\r\n        System.arraycopy(arrayTwo, 0, newArray, arrayOne.length, length);\r\n        arrayOne = null;\r\n        arrayTwo = null;\r\n    }\r\n    return newArray;\r\n}"
}, {
	"Path": "org.springframework.cloud.netflix.concurrency.limits.reactive.ServerWebExchangeLimiterBuilder.partitionByPathInfo",
	"Comment": "partition the limit by the full path. percentages of the limit are partitioned to named\tgroups.group membership is derived from the provided mapping function.",
	"Method": "ServerWebExchangeLimiterBuilder partitionByPathInfo(Function<String, String> pathToGroup){\r\n    return partitionResolver(exchange -> {\r\n        String path = exchange.getRequest().getPath().contextPath().value();\r\n        return Optional.ofNullable(path).map(pathToGroup).orElse(null);\r\n    });\r\n}"
}, {
	"Path": "io.restassured.module.mockmvc.RestAssuredMockMvc.delete",
	"Comment": "perform a delete request to the statically configured base path.",
	"Method": "MockMvcResponse delete(String path,Object pathParams,MockMvcResponse delete,String path,Map<String, ?> pathParams,MockMvcResponse delete,URI uri,MockMvcResponse delete,URL url,MockMvcResponse delete){\r\n    return given().delete();\r\n}"
}, {
	"Path": "io.restassured.path.xml.XmlPath.getDouble",
	"Comment": "get the result of an xml path expression as a double. for syntax details please refer tothis url.",
	"Method": "double getDouble(String path){\r\n    Object object = get(path);\r\n    return convertObjectTo(object, Double.class);\r\n}"
}, {
	"Path": "net.minecraftforge.fml.common.FMLCommonHandler.handleServerHandshake",
	"Comment": "process initial handshake packet, kicks players from the server if they are connecting while we are starting up.also verifies the client has the fml marker.",
	"Method": "boolean handleServerHandshake(C00Handshake packet,NetworkManager manager){\r\n    if (!shouldAllowPlayerLogins()) {\r\n        TextComponentString text = new TextComponentString(\"Server is still starting! Please wait before reconnecting.\");\r\n        FMLLog.log.info(\"Disconnecting Player: {}\", text.getUnformattedText());\r\n        manager.sendPacket(new SPacketDisconnect(text));\r\n        manager.closeChannel(text);\r\n        return false;\r\n    }\r\n    if (packet.getRequestedState() == EnumConnectionState.LOGIN && (!NetworkRegistry.INSTANCE.isVanillaAccepted(Side.CLIENT) && !packet.hasFMLMarker())) {\r\n        manager.setConnectionState(EnumConnectionState.LOGIN);\r\n        TextComponentString text = new TextComponentString(\"This server has mods that require FML/Forge to be installed on the client. Contact your server admin for more details.\");\r\n        Collection<String> modNames = NetworkRegistry.INSTANCE.getRequiredMods(Side.CLIENT);\r\n        FMLLog.log.info(\"Disconnecting Player: This server has mods that require FML/Forge to be installed on the client: {}\", modNames);\r\n        manager.sendPacket(new SPacketDisconnect(text));\r\n        manager.closeChannel(text);\r\n        return false;\r\n    }\r\n    manager.channel().attr(NetworkRegistry.FML_MARKER).set(packet.hasFMLMarker());\r\n    return true;\r\n}"
}, {
	"Path": "co.paralleluniverse.concurrent.util.DelayQueue.offer",
	"Comment": "inserts the specified element into this delay queue. as the queue isunbounded this method will never block.",
	"Method": "boolean offer(E e,boolean offer,E e,long timeout,TimeUnit unit){\r\n    return offer(e);\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.AbstractQueuedLongSynchronizer.enq",
	"Comment": "inserts node into queue, initializing if necessary. see picture above.",
	"Method": "Node enq(Node node){\r\n    for (; ; ) {\r\n        Node t = tail;\r\n        if (t == null) {\r\n            if (compareAndSetHead(new Node()))\r\n                tail = head;\r\n        } else {\r\n            node.prev = t;\r\n            if (compareAndSetTail(t, node)) {\r\n                t.next = node;\r\n                return t;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.mapdb.jsr166.LinkedBlockingQueueTest.testInterruptedTimedPoll",
	"Comment": "interrupted timed poll throws interruptedexception instead ofreturning timeout status",
	"Method": "void testInterruptedTimedPoll(){\r\n    final BlockingQueue<Integer> q = populatedQueue(SIZE);\r\n    final CountDownLatch pleaseInterrupt = new CountDownLatch(1);\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            long startTime = System.nanoTime();\r\n            for (int i = 0; i < SIZE; i++) assertEquals(i, (int) q.poll(LONG_DELAY_MS, MILLISECONDS));\r\n            Thread.currentThread().interrupt();\r\n            try {\r\n                q.poll(LONG_DELAY_MS, MILLISECONDS);\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n            }\r\n            assertFalse(Thread.interrupted());\r\n            pleaseInterrupt.countDown();\r\n            try {\r\n                q.poll(LONG_DELAY_MS, MILLISECONDS);\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n            }\r\n            assertFalse(Thread.interrupted());\r\n            assertTrue(millisElapsedSince(startTime) < LONG_DELAY_MS);\r\n        }\r\n    });\r\n    await(pleaseInterrupt);\r\n    assertThreadBlocks(t, Thread.State.TIMED_WAITING);\r\n    t.interrupt();\r\n    awaitTermination(t);\r\n    checkEmpty(q);\r\n}"
}, {
	"Path": "org.mapdb.jsr166.LinkedBlockingQueueTest.testInterruptedTimedPoll",
	"Comment": "interrupted timed poll throws interruptedexception instead ofreturning timeout status",
	"Method": "void testInterruptedTimedPoll(){\r\n    long startTime = System.nanoTime();\r\n    for (int i = 0; i < SIZE; i++) assertEquals(i, (int) q.poll(LONG_DELAY_MS, MILLISECONDS));\r\n    Thread.currentThread().interrupt();\r\n    try {\r\n        q.poll(LONG_DELAY_MS, MILLISECONDS);\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n    }\r\n    assertFalse(Thread.interrupted());\r\n    pleaseInterrupt.countDown();\r\n    try {\r\n        q.poll(LONG_DELAY_MS, MILLISECONDS);\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n    }\r\n    assertFalse(Thread.interrupted());\r\n    assertTrue(millisElapsedSince(startTime) < LONG_DELAY_MS);\r\n}"
}, {
	"Path": "io.objectbox.query.PropertyQuery.sumDouble",
	"Comment": "sums up all values for the given property over all objects matching the query.",
	"Method": "double sumDouble(){\r\n    return (Double) query.callInReadTx(new Callable<Double>() {\r\n        @Override\r\n        public Double call() {\r\n            return nativeSumDouble(queryHandle, query.cursorHandle(), propertyId);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "io.objectbox.query.PropertyQuery.sumDouble",
	"Comment": "sums up all values for the given property over all objects matching the query.",
	"Method": "double sumDouble(){\r\n    return nativeSumDouble(queryHandle, query.cursorHandle(), propertyId);\r\n}"
}, {
	"Path": "io.restassured.builder.ResponseSpecBuilder.expectBody",
	"Comment": "expect that the response body conforms to one or more hamcrest matchers.",
	"Method": "ResponseSpecBuilder expectBody(Matcher<?> matcher,ResponseSpecBuilder expectBody,String path,Matcher<?> matcher,ResponseSpecBuilder expectBody,String path,List<Argument> arguments,Matcher<?> matcher){\r\n    spec.body(path, arguments, matcher);\r\n    return this;\r\n}"
}, {
	"Path": "co.paralleluniverse.fibers.Fiber.parkAndSerialize",
	"Comment": "parks the fiber and allows the given callback to serialize it.",
	"Method": "void parkAndSerialize(FiberWriter writer){\r\n    while (!park(SERIALIZER_BLOCKER, new ParkAction() {\r\n        @Override\r\n        public void run(Fiber f) {\r\n            f.record(1, \"Fiber\", \"parkAndSerialize\", \"Serializing fiber %s\", f);\r\n            writer.write(f, getFiberSerializer());\r\n        }\r\n    })) ;\r\n}"
}, {
	"Path": "co.paralleluniverse.fibers.Fiber.parkAndSerialize",
	"Comment": "parks the fiber and allows the given callback to serialize it.",
	"Method": "void parkAndSerialize(FiberWriter writer){\r\n    f.record(1, \"Fiber\", \"parkAndSerialize\", \"Serializing fiber %s\", f);\r\n    writer.write(f, getFiberSerializer());\r\n}"
}, {
	"Path": "net.minecraftforge.common.brewing.BrewingRecipeRegistry.getOutput",
	"Comment": "returns the output itemstack obtained by brewing the passed input andingredient.",
	"Method": "ItemStack getOutput(ItemStack input,ItemStack ingredient){\r\n    if (input.isEmpty() || input.getCount() != 1)\r\n        return ItemStack.EMPTY;\r\n    if (ingredient.isEmpty())\r\n        return ItemStack.EMPTY;\r\n    for (IBrewingRecipe recipe : recipes) {\r\n        ItemStack output = recipe.getOutput(input, ingredient);\r\n        if (!output.isEmpty()) {\r\n            return output;\r\n        }\r\n    }\r\n    return ItemStack.EMPTY;\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.channels.Selector.trySelect",
	"Comment": "attempts to performs exactly one channel operation of a given set if one can be completed without blocking.this method only blocks if the listeners associated with the select actions block.",
	"Method": "SelectAction<Message> trySelect(boolean priority,SelectAction<Message> actions,SelectAction<Message> trySelect,boolean priority,List<? extends SelectAction<Message>> actions,SelectAction<Message> trySelect,SelectAction<Message> actions,SelectAction<Message> trySelect,List<? extends SelectAction<Message>> actions,SelectAction<Message> trySelect){\r\n    selectInit();\r\n    for (int i = 0; i < actions.size(); i++) {\r\n        SelectActionImpl sa = actions.get(i);\r\n        if (sa.isData()) {\r\n            if (((SendPort) sa.port).trySend(sa.message())) {\r\n                sa.fire();\r\n                return sa;\r\n            }\r\n        } else {\r\n            Object m = ((ReceivePort) sa.port).tryReceive();\r\n            if (m != null || ((ReceivePort) sa.port).isClosed()) {\r\n                sa.setItem(m);\r\n                sa.fire();\r\n                return sa;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.mapdb.jsr166.LinkedBlockingDequeTest.testBlockingTakeLast",
	"Comment": "takelast removes existing elements until empty, then blocks interruptibly",
	"Method": "void testBlockingTakeLast(){\r\n    final BlockingDeque q = populatedDeque(SIZE);\r\n    final CountDownLatch pleaseInterrupt = new CountDownLatch(1);\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            for (int i = 0; i < SIZE; i++) assertEquals(SIZE - i - 1, q.takeLast());\r\n            Thread.currentThread().interrupt();\r\n            try {\r\n                q.takeLast();\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n            }\r\n            assertFalse(Thread.interrupted());\r\n            pleaseInterrupt.countDown();\r\n            try {\r\n                q.takeLast();\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n            }\r\n            assertFalse(Thread.interrupted());\r\n        }\r\n    });\r\n    await(pleaseInterrupt);\r\n    assertThreadBlocks(t, Thread.State.WAITING);\r\n    t.interrupt();\r\n    awaitTermination(t);\r\n}"
}, {
	"Path": "org.mapdb.jsr166.LinkedBlockingDequeTest.testBlockingTakeLast",
	"Comment": "takelast removes existing elements until empty, then blocks interruptibly",
	"Method": "void testBlockingTakeLast(){\r\n    for (int i = 0; i < SIZE; i++) assertEquals(SIZE - i - 1, q.takeLast());\r\n    Thread.currentThread().interrupt();\r\n    try {\r\n        q.takeLast();\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n    }\r\n    assertFalse(Thread.interrupted());\r\n    pleaseInterrupt.countDown();\r\n    try {\r\n        q.takeLast();\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n    }\r\n    assertFalse(Thread.interrupted());\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.ReentrantReadWriteLock.getWriteHoldCount",
	"Comment": "queries the number of reentrant write holds on this lock by thecurrent strand.a writer strand has a hold on a lock foreach lock action that is not matched by an unlock action.",
	"Method": "int getWriteHoldCount(int getWriteHoldCount){\r\n    return sync.getWriteHoldCount();\r\n}"
}, {
	"Path": "net.minecraftforge.event.entity.player.CriticalHitEvent.setDamageModifier",
	"Comment": "this set the damage multiplier for the hit. if you set it to 0, then the particles are still generated but damage is not done.",
	"Method": "void setDamageModifier(float mod){\r\n    this.damageModifier = mod;\r\n}"
}, {
	"Path": "org.springframework.security.cas.web.CasAuthenticationFilter.proxyReceptorRequest",
	"Comment": "indicates if the request is elgible to be processed as the proxy receptor.",
	"Method": "boolean proxyReceptorRequest(HttpServletRequest request){\r\n    final boolean result = proxyReceptorConfigured() && proxyReceptorMatcher.matches(request);\r\n    if (logger.isDebugEnabled()) {\r\n        logger.debug(\"proxyReceptorRequest = \" + result);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "net.minecraftforge.event.entity.player.CriticalHitEvent.getDamageModifier",
	"Comment": "the damage modifier for the hit. this is by default 1.5f for ciritcal hits and 1f for normal hits .",
	"Method": "float getDamageModifier(){\r\n    return this.damageModifier;\r\n}"
}, {
	"Path": "net.minecraftforge.oredict.OreDictionary.registerOreImpl",
	"Comment": "registers a ore item into the dictionary.raises the registerore function in all registered handlers.",
	"Method": "void registerOreImpl(String name,ItemStack ore){\r\n    if (\"Unknown\".equals(name))\r\n        return;\r\n    if (ore.isEmpty()) {\r\n        FMLLog.bigWarning(\"Invalid registration attempt for an Ore Dictionary item with name {} has occurred. The registration has been denied to prevent crashes. The mod responsible for the registration needs to correct this.\", name);\r\n        return;\r\n    }\r\n    int oreID = getOreID(name);\r\n    ResourceLocation registryName = ore.getItem().delegate.name();\r\n    int hash;\r\n    if (registryName == null) {\r\n        ModContainer modContainer = Loader.instance().activeModContainer();\r\n        String modContainerName = modContainer == null ? null : modContainer.getName();\r\n        FMLLog.bigWarning(\"A broken ore dictionary registration with name {} has occurred. It adds an item (type: {}) which is currently unknown to the game registry. This dictionary item can only support a single value when\" + \" registered with ores like this, and NO I am not going to turn this spam off. Just register your ore dictionary entries after the GameRegistry.\\n\" + \"TO USERS: YES this is a BUG in the mod \" + modContainerName + \" report it to them!\", name, ore.getItem().getClass());\r\n        hash = -1;\r\n    } else {\r\n        hash = Item.REGISTRY.getIDForObject(ore.getItem().delegate.get());\r\n    }\r\n    if (ore.getItemDamage() != WILDCARD_VALUE) {\r\n        hash |= ((ore.getItemDamage() + 1) << 16);\r\n    }\r\n    List<Integer> ids = stackToId.get(hash);\r\n    if (ids != null && ids.contains(oreID))\r\n        return;\r\n    if (ids == null) {\r\n        ids = Lists.newArrayList();\r\n        stackToId.put(hash, ids);\r\n    }\r\n    ids.add(oreID);\r\n    ore = ore.copy();\r\n    idToStack.get(oreID).add(ore);\r\n    MinecraftForge.EVENT_BUS.post(new OreRegisterEvent(name, ore));\r\n}"
}, {
	"Path": "net.minecraftforge.fml.common.event.FMLPreInitializationEvent.getFMLSigningCertificates",
	"Comment": "retrieve the fml signing certificates, if any. validate these against thepublished fml certificates in your mod, if you wish.deprecated because mods should not trust this code. ratherthey should copy this, or something like this, into their own mods.",
	"Method": "Certificate[] getFMLSigningCertificates(){\r\n    CodeSource codeSource = getClass().getClassLoader().getParent().getClass().getProtectionDomain().getCodeSource();\r\n    Certificate[] certs = codeSource.getCertificates();\r\n    if (certs == null) {\r\n        return new Certificate[0];\r\n    } else {\r\n        return certs;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.cloud.netflix.zuul.filters.pre.Servlet30RequestWrapper.getRequest",
	"Comment": "there is a bug in zuul 1.2.2 where httpservletrequestwrapper.getrequest returns a wrapped request rather than the raw one.",
	"Method": "HttpServletRequest getRequest(){\r\n    return this.request;\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.AbstractQueuedSynchronizer.enq",
	"Comment": "inserts node into queue, initializing if necessary. see picture above.",
	"Method": "Node enq(Node node){\r\n    for (; ; ) {\r\n        Node t = tail;\r\n        if (t == null) {\r\n            if (compareAndSetHead(new Node()))\r\n                tail = head;\r\n        } else {\r\n            node.prev = t;\r\n            if (compareAndSetTail(t, node)) {\r\n                t.next = node;\r\n                return t;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.Phaser.getArrivedParties",
	"Comment": "returns the number of registered parties that have arrived atthe current phase of this phaser. if this phaser has terminated,the returned value is meaningless and arbitrary.",
	"Method": "int getArrivedParties(){\r\n    return arrivedOf(reconcileState());\r\n}"
}, {
	"Path": "org.nanohttpd.protocols.http.NanoHTTPD.createClientHandler",
	"Comment": "create a instance of the client handler, subclasses can return a subclassof the clienthandler.",
	"Method": "ClientHandler createClientHandler(Socket finalAccept,InputStream inputStream){\r\n    return new ClientHandler(this, inputStream, finalAccept);\r\n}"
}, {
	"Path": "net.minecraftforge.event.entity.player.ItemFishedEvent.getHookEntity",
	"Comment": "use this to stuff related to the hook itself, like the position of the bobber.",
	"Method": "EntityFishHook getHookEntity(){\r\n    return hook;\r\n}"
}, {
	"Path": "net.minecraftforge.fml.common.registry.ForgeRegistries.init",
	"Comment": "this function is just to make sure static inializers in other classes have run and setup their registries before we query them.",
	"Method": "void init(){\r\n    GameData.init();\r\n    VillagerRegistry.instance();\r\n    Bootstrap.register();\r\n}"
}, {
	"Path": "com.alibaba.csp.sentinel.node.metric.MetricsReader.readMetricsByEndTime",
	"Comment": "when identity is null, all metric between the time intervalms will be read, otherwise, only the specificidentity will be read.",
	"Method": "List<MetricNode> readMetricsByEndTime(List<String> fileNames,int pos,long offset,long endTimeMs,String identity){\r\n    List<MetricNode> list = new ArrayList<MetricNode>(1024);\r\n    if (readMetricsInOneFileByEndTime(list, fileNames.get(pos++), offset, endTimeMs, identity)) {\r\n        while (pos < fileNames.size() && readMetricsInOneFileByEndTime(list, fileNames.get(pos++), 0, endTimeMs, identity)) {\r\n        }\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "co.paralleluniverse.actors.ActorRegistry.getActor",
	"Comment": "locates a registered actor by name, or blocks until one is registered.",
	"Method": "T getActor(String name,long timeout,TimeUnit unit,T getActor,String name){\r\n    return getActor(name, 0, null);\r\n}"
}, {
	"Path": "net.minecraftforge.fluids.FluidRegistry.addBucketForFluid",
	"Comment": "registers a fluid with the universal bucket.this only has an effect if the universal bucket is enabled.",
	"Method": "boolean addBucketForFluid(Fluid fluid){\r\n    if (fluid == null) {\r\n        return false;\r\n    }\r\n    if (!isFluidRegistered(fluid)) {\r\n        registerFluid(fluid);\r\n    }\r\n    return bucketFluids.add(fluid.getName());\r\n}"
}, {
	"Path": "net.minecraftforge.common.util.FakePlayerFactory.get",
	"Comment": "get a fake player with a given username,mods should either hold weak references to the return value, or listen for aworldevent.unload and kill all references to prevent worlds staying in memory.",
	"Method": "FakePlayer get(WorldServer world,GameProfile username){\r\n    if (!fakePlayers.containsKey(username)) {\r\n        FakePlayer fakePlayer = new FakePlayer(world, username);\r\n        fakePlayers.put(username, fakePlayer);\r\n    }\r\n    return fakePlayers.get(username);\r\n}"
}, {
	"Path": "co.paralleluniverse.concurrent.util.ConcurrentSkipListSet.descendingIterator",
	"Comment": "returns an iterator over the elements in this set in descending order.",
	"Method": "Iterator<E> descendingIterator(){\r\n    return m.descendingKeySet().iterator();\r\n}"
}, {
	"Path": "io.restassured.config.SSLConfig.port",
	"Comment": "the port for which rest assured will apply the ssl configuration. this is advanced configuration and most of the time you do not need to specify a port sincerest assured will apply the configuration to the https port defined in the uri.",
	"Method": "SSLConfig port(int port){\r\n    return new SSLConfig(pathToKeyStore, pathToTrustStore, keyStorePassword, trustStorePassword, keyStoreType, trustStoreType, port, keyStore, trustStore, x509HostnameVerifier, sslSocketFactory, true);\r\n}"
}, {
	"Path": "net.minecraftforge.fml.repackage.com.nothome.delta.Checksum.queryChecksum",
	"Comment": "finds the checksum computed from the buffer.marks, gets, then resets the buffer.",
	"Method": "long queryChecksum(ByteBuffer bb,int len){\r\n    bb.mark();\r\n    long sum = queryChecksum0(bb, len);\r\n    bb.reset();\r\n    return sum;\r\n}"
}, {
	"Path": "io.objectbox.Box.query",
	"Comment": "returns a builder to create queries for object matching supplied criteria.",
	"Method": "QueryBuilder<T> query(){\r\n    return new QueryBuilder(this, store.internalHandle(), store.getDbName(entityClass));\r\n}"
}, {
	"Path": "ibxm.Player.set_loop",
	"Comment": "if loop is true, playback will continue indefinitely,\t\totherwise the module will play through once and stop.",
	"Method": "void set_loop(boolean loop){\r\n    this.loop = loop;\r\n}"
}, {
	"Path": "org.mapdb.jsr166.LinkedBlockingQueueTest.testConstructor5",
	"Comment": "initializing from collection with some null elements throwsnullpointerexception",
	"Method": "void testConstructor5(){\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE - 1; ++i) ints[i] = new Integer(i);\r\n    Collection<Integer> elements = Arrays.asList(ints);\r\n    try {\r\n        new LinkedBlockingQueue(elements);\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "org.mapdb.jsr166.LinkedBlockingQueueTest.testConstructor6",
	"Comment": "queue contains all elements of collection used to initialize",
	"Method": "void testConstructor6(){\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE; ++i) ints[i] = new Integer(i);\r\n    LinkedBlockingQueue q = new LinkedBlockingQueue(Arrays.asList(ints));\r\n    for (int i = 0; i < SIZE; ++i) assertEquals(ints[i], q.poll());\r\n}"
}, {
	"Path": "org.springframework.security.config.annotation.web.configurers.RememberMeConfigurer.rememberMeParameter",
	"Comment": "the http parameter used to indicate to remember the user at time of login.",
	"Method": "RememberMeConfigurer<H> rememberMeParameter(String rememberMeParameter){\r\n    this.rememberMeParameter = rememberMeParameter;\r\n    return this;\r\n}"
}, {
	"Path": "org.mapdb.jsr166.LinkedBlockingQueueTest.testConstructor3",
	"Comment": "initializing from null collection throws nullpointerexception",
	"Method": "void testConstructor3(){\r\n    try {\r\n        new LinkedBlockingQueue(null);\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "org.mapdb.jsr166.LinkedBlockingQueueTest.testConstructor4",
	"Comment": "initializing from collection of null elements throws nullpointerexception",
	"Method": "void testConstructor4(){\r\n    Collection<Integer> elements = Arrays.asList(new Integer[SIZE]);\r\n    try {\r\n        new LinkedBlockingQueue(elements);\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "org.mapdb.jsr166.LinkedBlockingQueueTest.testConstructor2",
	"Comment": "constructor throws illegalargumentexception if capacity argument nonpositive",
	"Method": "void testConstructor2(){\r\n    try {\r\n        new LinkedBlockingQueue(0);\r\n        shouldThrow();\r\n    } catch (IllegalArgumentException success) {\r\n    }\r\n}"
}, {
	"Path": "io.objectbox.reactive.DataSubscriptionList.cancel",
	"Comment": "cancels all tracked subscriptions and removes all references to them.",
	"Method": "void cancel(){\r\n    canceled = true;\r\n    for (DataSubscription subscription : subscriptions) {\r\n        subscription.cancel();\r\n    }\r\n    subscriptions.clear();\r\n}"
}, {
	"Path": "org.nanohttpd.protocols.http.NanoHTTPD.setTempFileManagerFactory",
	"Comment": "pluggable strategy for creating and cleaning up temporary files.",
	"Method": "void setTempFileManagerFactory(IFactory<ITempFileManager> tempFileManagerFactory){\r\n    this.tempFileManagerFactory = tempFileManagerFactory;\r\n}"
}, {
	"Path": "net.minecraftforge.common.chunkio.ChunkIOExecutor.queueChunkLoad",
	"Comment": "queue the chunk to be loaded, and call the runnable when finished",
	"Method": "void queueChunkLoad(World world,AnvilChunkLoader loader,ChunkProviderServer provider,int x,int z,Runnable runnable){\r\n    QueuedChunk key = new QueuedChunk(x, z, world);\r\n    ChunkIOProvider task = tasks.get(key);\r\n    if (task == null) {\r\n        task = new ChunkIOProvider(key, loader, provider);\r\n        task.addCallback(runnable);\r\n        tasks.put(key, task);\r\n        pool.execute(task);\r\n    } else {\r\n        task.addCallback(runnable);\r\n    }\r\n}"
}, {
	"Path": "io.restassured.module.mockmvc.RestAssuredMockMvc.put",
	"Comment": "perform a put request to the statically configured base path.",
	"Method": "MockMvcResponse put(String path,Object pathParams,MockMvcResponse put,URI uri,MockMvcResponse put,URL url,MockMvcResponse put){\r\n    return given().put();\r\n}"
}, {
	"Path": "io.restassured.path.xml.XmlPath.getShort",
	"Comment": "get the result of an xml path expression as a short. for syntax details please refer tothis url.",
	"Method": "short getShort(String path){\r\n    Object object = get(path);\r\n    return convertObjectTo(object, Short.class);\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.Phaser.unarrivedOf",
	"Comment": "the following unpacking methods are usually manually inlined",
	"Method": "int unarrivedOf(long s){\r\n    int counts = (int) s;\r\n    return (counts == EMPTY) ? 0 : counts & UNARRIVED_MASK;\r\n}"
}, {
	"Path": "org.reflections.vfs.Vfs.addDefaultURLTypes",
	"Comment": "add a static default url types to the beginning of the default url types list. can be used to statically plug in urltypes",
	"Method": "void addDefaultURLTypes(UrlType urlType){\r\n    defaultUrlTypes.add(0, urlType);\r\n}"
}, {
	"Path": "org.reflections.vfs.Vfs.fromURL",
	"Comment": "tries to create a dir from the given url, using the given urltypes",
	"Method": "Dir fromURL(URL url,Dir fromURL,URL url,List<UrlType> urlTypes,Dir fromURL,URL url,UrlType urlTypes){\r\n    return fromURL(url, Lists.<UrlType>newArrayList(urlTypes));\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.channels.ThreadReceivePort.close",
	"Comment": "closes the channel so that no more messages could be sent to it. messages already sent to the channel will still be received.",
	"Method": "void close(){\r\n    p.close();\r\n}"
}, {
	"Path": "com.uber.nullaway.jarinfer.StubxWriter.write",
	"Comment": "this method writes the provided list of annotations to a dataoutputstream in the astubx format.",
	"Method": "void write(DataOutputStream out,Map<String, String> importedAnnotations,Map<String, Set<String>> packageAnnotations,Map<String, Set<String>> typeAnnotations,Map<String, MethodAnnotationsRecord> methodRecords){\r\n    out.writeInt(VERSION_0_FILE_MAGIC_NUMBER);\r\n    int numStringEntires = 0;\r\n    Map<String, Integer> encodingDictionary = new LinkedHashMap();\r\n    List<String> strings = new ArrayList<String>();\r\n    List<Collection<String>> keysets = ImmutableList.of(importedAnnotations.values(), packageAnnotations.keySet(), typeAnnotations.keySet(), methodRecords.keySet());\r\n    for (Collection<String> keyset : keysets) {\r\n        for (String key : keyset) {\r\n            assert !encodingDictionary.containsKey(key);\r\n            strings.add(key);\r\n            encodingDictionary.put(key, numStringEntires);\r\n            ++numStringEntires;\r\n        }\r\n    }\r\n    out.writeInt(numStringEntires);\r\n    for (String s : strings) {\r\n        out.writeUTF(s);\r\n    }\r\n    int packageAnnotationSize = 0;\r\n    for (Map.Entry<String, Set<String>> entry : packageAnnotations.entrySet()) {\r\n        packageAnnotationSize += entry.getValue().size();\r\n    }\r\n    out.writeInt(packageAnnotationSize);\r\n    for (Map.Entry<String, Set<String>> entry : packageAnnotations.entrySet()) {\r\n        for (String annot : entry.getValue()) {\r\n            out.writeInt(encodingDictionary.get(entry.getKey()));\r\n            out.writeInt(encodingDictionary.get(importedAnnotations.get(annot)));\r\n        }\r\n    }\r\n    int typeAnnotationSize = 0;\r\n    for (Map.Entry<String, Set<String>> entry : typeAnnotations.entrySet()) {\r\n        typeAnnotationSize += entry.getValue().size();\r\n    }\r\n    out.writeInt(typeAnnotationSize);\r\n    for (Map.Entry<String, Set<String>> entry : typeAnnotations.entrySet()) {\r\n        for (String annot : entry.getValue()) {\r\n            out.writeInt(encodingDictionary.get(entry.getKey()));\r\n            out.writeInt(encodingDictionary.get(importedAnnotations.get(annot)));\r\n        }\r\n    }\r\n    int methodAnnotationSize = 0;\r\n    int methodArgumentRecordsSize = 0;\r\n    for (Map.Entry<String, MethodAnnotationsRecord> entry : methodRecords.entrySet()) {\r\n        methodAnnotationSize += entry.getValue().getMethodAnnotations().size();\r\n        methodArgumentRecordsSize += entry.getValue().getArgumentAnnotations().size();\r\n    }\r\n    out.writeInt(methodAnnotationSize);\r\n    for (Map.Entry<String, MethodAnnotationsRecord> entry : methodRecords.entrySet()) {\r\n        for (String annot : entry.getValue().getMethodAnnotations()) {\r\n            out.writeInt(encodingDictionary.get(entry.getKey()));\r\n            out.writeInt(encodingDictionary.get(importedAnnotations.get(annot)));\r\n        }\r\n    }\r\n    out.writeInt(methodArgumentRecordsSize);\r\n    for (Map.Entry<String, MethodAnnotationsRecord> entry : methodRecords.entrySet()) {\r\n        for (Map.Entry<Integer, ImmutableSet<String>> argEntry : entry.getValue().getArgumentAnnotations().entrySet()) {\r\n            for (String annot : argEntry.getValue()) {\r\n                out.writeInt(encodingDictionary.get(entry.getKey()));\r\n                out.writeInt(argEntry.getKey());\r\n                out.writeInt(encodingDictionary.get(importedAnnotations.get(annot)));\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.mapdb.jsr166.JSR166TestCase.sleep",
	"Comment": "sleeps until the given time has elapsed.throws assertionerror if interrupted.",
	"Method": "void sleep(long millis){\r\n    try {\r\n        delay(millis);\r\n    } catch (InterruptedException fail) {\r\n        throw new AssertionError(\"Unexpected InterruptedException\", fail);\r\n    }\r\n}"
}, {
	"Path": "org.nanohttpd.protocols.http.response.Response.addCookieHeader",
	"Comment": "adds a cookie header to the list. should not be called manually, this isan internal utility.",
	"Method": "void addCookieHeader(String cookie){\r\n    cookieHeaders.add(cookie);\r\n}"
}, {
	"Path": "net.minecraftforge.common.config.Property.showInGui",
	"Comment": "gets whether or not this property should be allowed to show on config guis.defaults to true unless set to false.",
	"Method": "boolean showInGui(){\r\n    return showInGui;\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.Semaphore.drainPermits",
	"Comment": "acquires and returns all permits that are immediately available.",
	"Method": "int drainPermits(int drainPermits){\r\n    return sync.drainPermits();\r\n}"
}, {
	"Path": "org.springframework.cloud.netflix.eureka.server.RefreshablePeerEurekaNodesTests.serviceUrlMatches",
	"Comment": "whether the first element in peereurekanodes matches the given url.",
	"Method": "boolean serviceUrlMatches(String serviceUrl){\r\n    return this.peerEurekaNodes.getPeerEurekaNodes().get(0).getServiceUrl().equals(serviceUrl);\r\n}"
}, {
	"Path": "net.minecraftforge.fml.common.FMLCommonHandler.getEffectiveSide",
	"Comment": "return the effective side for the context in the game. this is dependenton thread analysis to try and determine whether the code is running in theserver or not. use at your own risk",
	"Method": "Side getEffectiveSide(){\r\n    final ThreadGroup group = Thread.currentThread().getThreadGroup();\r\n    return group instanceof SidedThreadGroup ? ((SidedThreadGroup) group).getSide() : Side.CLIENT;\r\n}"
}, {
	"Path": "net.minecraftforge.common.DimensionManager.unloadWorlds",
	"Comment": "to be called by the server at the appropriate time, do not call from mod code.",
	"Method": "void unloadWorlds(Hashtable<Integer, long[]> worldTickTimes){\r\n    IntIterator queueIterator = unloadQueue.iterator();\r\n    while (queueIterator.hasNext()) {\r\n        int id = queueIterator.nextInt();\r\n        Dimension dimension = dimensions.get(id);\r\n        if (dimension.ticksWaited < ForgeModContainer.dimensionUnloadQueueDelay) {\r\n            dimension.ticksWaited++;\r\n            continue;\r\n        }\r\n        WorldServer w = worlds.get(id);\r\n        queueIterator.remove();\r\n        dimension.ticksWaited = 0;\r\n        if (w == null || !canUnloadWorld(w)) {\r\n            FMLLog.log.debug(\"Aborting unload for dimension {} as status changed\", id);\r\n            continue;\r\n        }\r\n        try {\r\n            w.saveAllChunks(true, null);\r\n        } catch (MinecraftException e) {\r\n            FMLLog.log.error(\"Caught an exception while saving all chunks:\", e);\r\n        } finally {\r\n            MinecraftForge.EVENT_BUS.post(new WorldEvent.Unload(w));\r\n            w.flush();\r\n            setWorld(id, null, w.getMinecraftServer());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.minecraftforge.fml.common.FMLCommonHandler.findContainerFor",
	"Comment": "find the container that associates with the supplied mod object",
	"Method": "ModContainer findContainerFor(Object mod){\r\n    if (mod instanceof String) {\r\n        return Loader.instance().getIndexedModList().get(mod);\r\n    } else {\r\n        return Loader.instance().getReversedModObjectList().get(mod);\r\n    }\r\n}"
}, {
	"Path": "io.restassured.builder.ResponseSpecBuilder.expectStatusCode",
	"Comment": "expect that the response status code matches the given hamcrest matcher.",
	"Method": "ResponseSpecBuilder expectStatusCode(Matcher<Integer> expectedStatusCode,ResponseSpecBuilder expectStatusCode,int expectedStatusCode){\r\n    spec.statusCode(expectedStatusCode);\r\n    return this;\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.StampedLock.tryIncReaderOverflow",
	"Comment": "tries to increment readeroverflow by first setting stateaccess bits value to rbits, indicating hold of spinlock,then updating, then releasing.",
	"Method": "long tryIncReaderOverflow(long s){\r\n    if ((s & ABITS) == RFULL) {\r\n        if (STATE.compareAndSet(this, s, s | RBITS)) {\r\n            ++readerOverflow;\r\n            state = s;\r\n            return s;\r\n        }\r\n    } else if ((ThreadLocalRandom.current().nextInt() & OVERFLOW_YIELD_RATE) == 0)\r\n        if (!Strand.isCurrentFiber())\r\n            Thread.yield();\r\n    return 0L;\r\n}"
}, {
	"Path": "org.mapdb.jsr166.LinkedBlockingDequeTest.testInterruptedTimedPollLast",
	"Comment": "interrupted timed polllast throws interruptedexception instead ofreturning timeout status",
	"Method": "void testInterruptedTimedPollLast(){\r\n    final BlockingDeque q = populatedDeque(SIZE);\r\n    final CountDownLatch pleaseInterrupt = new CountDownLatch(1);\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            long startTime = System.nanoTime();\r\n            for (int i = 0; i < SIZE; i++) assertEquals(SIZE - i - 1, q.pollLast(LONG_DELAY_MS, MILLISECONDS));\r\n            Thread.currentThread().interrupt();\r\n            try {\r\n                q.pollLast(LONG_DELAY_MS, MILLISECONDS);\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n            }\r\n            assertFalse(Thread.interrupted());\r\n            pleaseInterrupt.countDown();\r\n            try {\r\n                q.pollLast(LONG_DELAY_MS, MILLISECONDS);\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n            }\r\n            assertFalse(Thread.interrupted());\r\n            assertTrue(millisElapsedSince(startTime) < LONG_DELAY_MS);\r\n        }\r\n    });\r\n    await(pleaseInterrupt);\r\n    assertThreadBlocks(t, Thread.State.TIMED_WAITING);\r\n    t.interrupt();\r\n    awaitTermination(t);\r\n    checkEmpty(q);\r\n}"
}, {
	"Path": "org.mapdb.jsr166.LinkedBlockingDequeTest.testInterruptedTimedPollLast",
	"Comment": "interrupted timed polllast throws interruptedexception instead ofreturning timeout status",
	"Method": "void testInterruptedTimedPollLast(){\r\n    long startTime = System.nanoTime();\r\n    for (int i = 0; i < SIZE; i++) assertEquals(SIZE - i - 1, q.pollLast(LONG_DELAY_MS, MILLISECONDS));\r\n    Thread.currentThread().interrupt();\r\n    try {\r\n        q.pollLast(LONG_DELAY_MS, MILLISECONDS);\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n    }\r\n    assertFalse(Thread.interrupted());\r\n    pleaseInterrupt.countDown();\r\n    try {\r\n        q.pollLast(LONG_DELAY_MS, MILLISECONDS);\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n    }\r\n    assertFalse(Thread.interrupted());\r\n    assertTrue(millisElapsedSince(startTime) < LONG_DELAY_MS);\r\n}"
}, {
	"Path": "co.paralleluniverse.fibers.FiberUtil.get",
	"Comment": "blocks on the input fibers and creates a new list from the results. the result list is the same order as theinput list.",
	"Method": "List<V> get(List<Fiber<V>> fibers,List<V> get,Fiber<V> fibers,List<V> get,long timeout,TimeUnit unit,List<Fiber<V>> fibers,List<V> get,long time,TimeUnit unit,Fiber<V> fibers){\r\n    return get(time, unit, Arrays.asList(fibers));\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.AbstractQueuedLongSynchronizer.owns",
	"Comment": "queries whether the given conditionobjectuses this synchronizer as its lock.",
	"Method": "boolean owns(ConditionObject condition){\r\n    return condition.isOwnedBy(this);\r\n}"
}, {
	"Path": "io.restassured.module.mockmvc.RestAssuredMockMvc.post",
	"Comment": "perform a post request to the statically configured base path.",
	"Method": "MockMvcResponse post(String path,Object pathParams,MockMvcResponse post,String path,Map<String, ?> pathParams,MockMvcResponse post,URI uri,MockMvcResponse post,URL url,MockMvcResponse post){\r\n    return given().post();\r\n}"
}, {
	"Path": "co.paralleluniverse.concurrent.util.ScheduledSingleThreadExecutor.getActiveCount",
	"Comment": "returns the approximate number of threads that are activelyexecuting tasks.",
	"Method": "int getActiveCount(){\r\n    return 1;\r\n}"
}, {
	"Path": "org.mapdb.jsr166.Collection8Test.testTraversalEquivalence",
	"Comment": "various ways of traversing a collection yield same elements",
	"Method": "void testTraversalEquivalence(){\r\n    Collection c = impl.emptyCollection();\r\n    ThreadLocalRandom rnd = ThreadLocalRandom.current();\r\n    int n = rnd.nextInt(6);\r\n    for (int i = 0; i < n; i++) c.add(impl.makeElement(i));\r\n    ArrayList iterated = new ArrayList();\r\n    ArrayList iteratedForEachRemaining = new ArrayList();\r\n    ArrayList tryAdvanced = new ArrayList();\r\n    ArrayList spliterated = new ArrayList();\r\n    ArrayList splitonced = new ArrayList();\r\n    ArrayList forEached = new ArrayList();\r\n    ArrayList streamForEached = new ArrayList();\r\n    ConcurrentLinkedQueue parallelStreamForEached = new ConcurrentLinkedQueue();\r\n    ArrayList removeIfed = new ArrayList();\r\n    for (Object x : c) iterated.add(x);\r\n    c.iterator().forEachRemaining(iteratedForEachRemaining::add);\r\n    for (Spliterator s = c.spliterator(); s.tryAdvance(tryAdvanced::add); ) {\r\n    }\r\n    c.spliterator().forEachRemaining(spliterated::add);\r\n    {\r\n        Spliterator s1 = c.spliterator(), s2 = s1.trySplit();\r\n        if (s2 != null)\r\n            s2.forEachRemaining(splitonced::add);\r\n        s1.forEachRemaining(splitonced::add);\r\n    }\r\n    c.forEach(forEached::add);\r\n    c.stream().forEach(streamForEached::add);\r\n    c.parallelStream().forEach(parallelStreamForEached::add);\r\n    c.removeIf(e -> {\r\n        removeIfed.add(e);\r\n        return false;\r\n    });\r\n    boolean ordered = c.spliterator().hasCharacteristics(Spliterator.ORDERED);\r\n    if (c instanceof List || c instanceof Deque)\r\n        assertTrue(ordered);\r\n    HashSet cset = new HashSet(c);\r\n    assertEquals(cset, new HashSet(parallelStreamForEached));\r\n    if (ordered) {\r\n        assertEquals(iterated, iteratedForEachRemaining);\r\n        assertEquals(iterated, tryAdvanced);\r\n        assertEquals(iterated, spliterated);\r\n        assertEquals(iterated, splitonced);\r\n        assertEquals(iterated, forEached);\r\n        assertEquals(iterated, streamForEached);\r\n        assertEquals(iterated, removeIfed);\r\n    } else {\r\n        assertEquals(cset, new HashSet(iterated));\r\n        assertEquals(cset, new HashSet(iteratedForEachRemaining));\r\n        assertEquals(cset, new HashSet(tryAdvanced));\r\n        assertEquals(cset, new HashSet(spliterated));\r\n        assertEquals(cset, new HashSet(splitonced));\r\n        assertEquals(cset, new HashSet(forEached));\r\n        assertEquals(cset, new HashSet(streamForEached));\r\n        assertEquals(cset, new HashSet(removeIfed));\r\n    }\r\n    if (c instanceof Deque) {\r\n        Deque d = (Deque) c;\r\n        ArrayList descending = new ArrayList();\r\n        ArrayList descendingForEachRemaining = new ArrayList();\r\n        for (Iterator it = d.descendingIterator(); it.hasNext(); ) descending.add(it.next());\r\n        d.descendingIterator().forEachRemaining(e -> descendingForEachRemaining.add(e));\r\n        Collections.reverse(descending);\r\n        Collections.reverse(descendingForEachRemaining);\r\n        assertEquals(iterated, descending);\r\n        assertEquals(iterated, descendingForEachRemaining);\r\n    }\r\n}"
}, {
	"Path": "net.minecraftforge.event.entity.player.ItemFishedEvent.getDrops",
	"Comment": "use this to get the items the player will receive.you cannot use this to modify the drops the player will get.if you want to affect the loot, you should use loottables.",
	"Method": "NonNullList<ItemStack> getDrops(){\r\n    return stacks;\r\n}"
}, {
	"Path": "io.objectbox.query.Query.close",
	"Comment": "if possible, try to close the query once you are done with it to reclaim resources immediately.",
	"Method": "void close(){\r\n    if (handle != 0) {\r\n        nativeDestroy(handle);\r\n        handle = 0;\r\n    }\r\n}"
}, {
	"Path": "io.restassured.internal.http.URIBuilder.toURL",
	"Comment": "convenience method to convert this object to a url instance.",
	"Method": "URL toURL(){\r\n    return base.toURL();\r\n}"
}, {
	"Path": "io.restassured.internal.http.URIBuilder.toURI",
	"Comment": "convenience method to convert this object to a uri instance.",
	"Method": "URI toURI(){\r\n    return this.base;\r\n}"
}, {
	"Path": "com.rxjava2.android.samples.ui.operators.ZipExampleActivity.doSomeWork",
	"Comment": "here we are getting two user list one, the list of cricket fans another one, the list of football fans then we are finding the list of users who loves both",
	"Method": "void doSomeWork(){\r\n    Observable.zip(getCricketFansObservable(), getFootballFansObservable(), new BiFunction<List<User>, List<User>, List<User>>() {\r\n        @Override\r\n        public List<User> apply(List<User> cricketFans, List<User> footballFans) {\r\n            return Utils.filterUserWhoLovesBoth(cricketFans, footballFans);\r\n        }\r\n    }).subscribeOn(// Be notified on the main thread\r\n    Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).subscribe(getObserver());\r\n}"
}, {
	"Path": "com.rxjava2.android.samples.ui.operators.ZipExampleActivity.doSomeWork",
	"Comment": "here we are getting two user list one, the list of cricket fans another one, the list of football fans then we are finding the list of users who loves both",
	"Method": "void doSomeWork(){\r\n    return Utils.filterUserWhoLovesBoth(cricketFans, footballFans);\r\n}"
}, {
	"Path": "net.minecraftforge.fml.common.network.ByteBufUtils.readVarShort",
	"Comment": "an extended length short. used by custom payload packets to extend size.",
	"Method": "int readVarShort(ByteBuf buf){\r\n    int low = buf.readUnsignedShort();\r\n    int high = 0;\r\n    if ((low & 0x8000) != 0) {\r\n        low = low & 0x7FFF;\r\n        high = buf.readUnsignedByte();\r\n    }\r\n    return ((high & 0xFF) << 15) | low;\r\n}"
}, {
	"Path": "com.mcxiaoke.packer.cli.Options.getRequiredIntValue",
	"Comment": "returns the value of the current numeric option, throwing an exception if the value ismissing or is not numeric.",
	"Method": "int getRequiredIntValue(String valueDescription){\r\n    String value = getRequiredValue(valueDescription);\r\n    try {\r\n        return Integer.parseInt(value);\r\n    } catch (NumberFormatException e) {\r\n        throw new OptionsException(valueDescription + \" (\" + lastOptionOriginalForm + \") must be a decimal number: \" + value);\r\n    }\r\n}"
}, {
	"Path": "io.restassured.module.webtestclient.RestAssuredWebTestClient.head",
	"Comment": "perform a head request to the statically configured base path.",
	"Method": "WebTestClientResponse head(String path,Object pathParams,WebTestClientResponse head,String path,Map<String, ?> pathParams,WebTestClientResponse head,Function<UriBuilder, URI> uriFunction,WebTestClientResponse head,URI uri,WebTestClientResponse head,URL url,WebTestClientResponse head){\r\n    return given().head();\r\n}"
}, {
	"Path": "net.minecraftforge.fluids.FluidStack.areFluidStackTagsEqual",
	"Comment": "determines if the nbt tags are equal. useful if the fluidids are known to be equal.",
	"Method": "boolean areFluidStackTagsEqual(FluidStack stack1,FluidStack stack2){\r\n    return stack1 == null && stack2 == null ? true : stack1 == null || stack2 == null ? false : stack1.isFluidStackTagEqual(stack2);\r\n}"
}, {
	"Path": "net.minecraftforge.fluids.FluidUtil.tryPickUpFluid",
	"Comment": "attempts to pick up a fluid in the world and put it in an empty container item.",
	"Method": "FluidActionResult tryPickUpFluid(ItemStack emptyContainer,EntityPlayer playerIn,World worldIn,BlockPos pos,EnumFacing side){\r\n    if (emptyContainer.isEmpty() || worldIn == null || pos == null) {\r\n        return FluidActionResult.FAILURE;\r\n    }\r\n    IBlockState state = worldIn.getBlockState(pos);\r\n    Block block = state.getBlock();\r\n    if (block instanceof IFluidBlock || block instanceof BlockLiquid) {\r\n        IFluidHandler targetFluidHandler = getFluidHandler(worldIn, pos, side);\r\n        if (targetFluidHandler != null) {\r\n            return tryFillContainer(emptyContainer, targetFluidHandler, Integer.MAX_VALUE, playerIn, true);\r\n        }\r\n    }\r\n    return FluidActionResult.FAILURE;\r\n}"
}, {
	"Path": "net.minecraftforge.fml.common.ProgressManager.pop",
	"Comment": "not a fully fleshed out api, may change in future mc versions.however feel free to use and suggest additions.",
	"Method": "void pop(ProgressBar bar){\r\n    if (bar.getSteps() != bar.getStep())\r\n        throw new IllegalStateException(\"can't pop unfinished ProgressBar \" + bar.getTitle());\r\n    bars.remove(bar);\r\n    if (bar.getSteps() != 0) {\r\n        long newTime = System.nanoTime();\r\n        if (bar.timeEachStep) {\r\n            String timeString = String.format(\"%.3f\", ((float) (newTime - bar.lastTime) / 1000000 / 1000));\r\n            FMLLog.log.debug(\"Bar Step: {} - {} took {}s\", bar.getTitle(), bar.getMessage(), timeString);\r\n        }\r\n        String timeString = String.format(\"%.3f\", ((float) (newTime - bar.startTime) / 1000000 / 1000));\r\n        if (bar.getSteps() == 1)\r\n            FMLLog.log.debug(\"Bar Finished: {} - {} took {}s\", bar.getTitle(), bar.getMessage(), timeString);\r\n        else\r\n            FMLLog.log.debug(\"Bar Finished: {} took {}s\", bar.getTitle(), timeString);\r\n    }\r\n    FMLCommonHandler.instance().processWindowMessages();\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.ReentrantReadWriteLock.getWaitQueueLength",
	"Comment": "returns an estimate of the number of strands waiting on thegiven condition associated with the write lock. note that becausetimeouts and interrupts may occur at any time, the estimateserves only as an upper bound on the actual number of waiters.this method is designed for use in monitoring of the systemstate, not for synchronization control.",
	"Method": "int getWaitQueueLength(Condition condition){\r\n    if (condition == null)\r\n        throw new NullPointerException();\r\n    if (!(condition instanceof AbstractQueuedSynchronizer.ConditionObject))\r\n        throw new IllegalArgumentException(\"not owner\");\r\n    return sync.getWaitQueueLength((AbstractQueuedSynchronizer.ConditionObject) condition);\r\n}"
}, {
	"Path": "io.restassured.http.Headers.headers",
	"Comment": "an alternative way to create a headers object from the constructor.",
	"Method": "Headers headers(Header header,Header additionalHeaders){\r\n    notNull(header, \"Header\");\r\n    final List<Header> headerList = new LinkedList<Header>();\r\n    headerList.add(header);\r\n    if (additionalHeaders != null) {\r\n        Collections.addAll(headerList, additionalHeaders);\r\n    }\r\n    return new Headers(headerList);\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.ReentrantReadWriteLock.isWriteLocked",
	"Comment": "queries if the write lock is held by any strand. this method isdesigned for use in monitoring system state, not forsynchronization control.",
	"Method": "boolean isWriteLocked(boolean isWriteLocked){\r\n    return sync.isWriteLocked();\r\n}"
}, {
	"Path": "net.minecraftforge.common.config.Property.getInt",
	"Comment": "returns the value in this property as an integer,if the value is not a valid integer, it will return theprovided default.",
	"Method": "int getInt(int getInt,int _default){\r\n    try {\r\n        return Integer.parseInt(value);\r\n    } catch (NumberFormatException e) {\r\n        return _default;\r\n    }\r\n}"
}, {
	"Path": "net.orfjackal.retrolambda.test.DefaultMethodsTest.lambdas_with_default_methods",
	"Comment": "backporting default methods should not interact badly with backporting lambdas.",
	"Method": "void lambdas_with_default_methods(){\r\n    CallOtherMethods lambda = () -> 2;\r\n    assertThat(lambda.foo(), is(2));\r\n    assertThat(lambda.callsFoo(), is(12));\r\n}"
}, {
	"Path": "org.nanohttpd.protocols.http.NanoHTTPD.createServerRunnable",
	"Comment": "instantiate the server runnable, can be overwritten by subclasses toprovide a subclass of the serverrunnable.",
	"Method": "ServerRunnable createServerRunnable(int timeout){\r\n    return new ServerRunnable(this, timeout);\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.AbstractQueuedLongSynchronizer.isQueued",
	"Comment": "returns true if the given strand is currently queued.this implementation traverses the queue to determinepresence of the given strand.",
	"Method": "boolean isQueued(Strand strand){\r\n    if (strand == null)\r\n        throw new NullPointerException();\r\n    for (Node p = tail; p != null; p = p.prev) if (p.strand == strand)\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "com.uber.nullaway.NullAway.getComputedNullness",
	"Comment": "returns the computed nullness information from an expression. if none is available, it returnsnullable.computed information can be added by handlers or by the core, and should supersede thatcomming from annotations.the default value of an expression without additional computed nullness information isalways nullable, since this method should only be called when the fact that the expression isnonnull is not clear from looking at annotations.",
	"Method": "Nullness getComputedNullness(ExpressionTree e){\r\n    if (computedNullnessMap.containsKey(e)) {\r\n        return computedNullnessMap.get(e);\r\n    } else {\r\n        return Nullness.NULLABLE;\r\n    }\r\n}"
}, {
	"Path": "net.minecraftforge.common.util.PacketUtil.writeItemStackFromClientToServer",
	"Comment": "most itemstack serialization is server to client, and must go through packetbuffer.writeitemstack which uses item.getnbtsharetag.one exception is items from the creative menu, which must be sent from client to server with their full nbt.this method matches packetbuffer.writeitemstack but without the item.getnbtsharetag patch.it is compatible with packetbuffer.readitemstack.",
	"Method": "void writeItemStackFromClientToServer(PacketBuffer buffer,ItemStack stack){\r\n    if (stack.isEmpty()) {\r\n        buffer.writeShort(-1);\r\n    } else {\r\n        buffer.writeShort(Item.getIdFromItem(stack.getItem()));\r\n        buffer.writeByte(stack.getCount());\r\n        buffer.writeShort(stack.getMetadata());\r\n        NBTTagCompound nbttagcompound = null;\r\n        if (stack.getItem().isDamageable() || stack.getItem().getShareTag()) {\r\n            nbttagcompound = stack.getTagCompound();\r\n        }\r\n        buffer.writeCompoundTag(nbttagcompound);\r\n    }\r\n}"
}, {
	"Path": "io.restassured.path.xml.XmlPath.getMap",
	"Comment": "get the result of an xml path expression as a map. for syntax details please refer tothis url.",
	"Method": "Map<K, V> getMap(String path,Map<K, V> getMap,String path,Class<K> keyType,Class<V> valueType){\r\n    final Map<K, V> originalMap = get(path);\r\n    final Map<K, V> newMap = new HashMap<K, V>();\r\n    for (Entry<K, V> entry : originalMap.entrySet()) {\r\n        final K key = entry.getKey() == null ? null : convertObjectTo(entry.getKey(), keyType);\r\n        final V value = entry.getValue() == null ? null : convertObjectTo(entry.getValue(), valueType);\r\n        newMap.put(key, value);\r\n    }\r\n    return Collections.unmodifiableMap(newMap);\r\n}"
}, {
	"Path": "co.paralleluniverse.common.util.SystemProperties.isNotFalse",
	"Comment": "returns the value of a system property which defaults to true.",
	"Method": "boolean isNotFalse(String property){\r\n    final String value = System.getProperty(property);\r\n    if (value == null)\r\n        return true;\r\n    if (value.isEmpty())\r\n        return true;\r\n    return value.isEmpty() || Boolean.parseBoolean(value);\r\n}"
}, {
	"Path": "io.restassured.module.mockmvc.specification.MockMvcRequestSpecBuilder.setConfig",
	"Comment": "define a configuration for redirection settings and http client parameters.",
	"Method": "MockMvcRequestSpecBuilder setConfig(RestAssuredMockMvcConfig config){\r\n    spec.config(config);\r\n    return this;\r\n}"
}, {
	"Path": "net.minecraftforge.fml.client.config.HoverChecker.updateBounds",
	"Comment": "call this method if the intended region has changed such as if the region must follow a scrolling list.it is not necessary to call this method if a guibutton defines the hover region.",
	"Method": "void updateBounds(int top,int bottom,int left,int right){\r\n    this.top = top;\r\n    this.bottom = bottom;\r\n    this.left = left;\r\n    this.right = right;\r\n}"
}, {
	"Path": "io.restassured.http.Cookie.isSecured",
	"Comment": "indicates to the browser whether the cookie should only be sent using a secure protocol, such as https or ssl.",
	"Method": "boolean isSecured(){\r\n    return secured;\r\n}"
}, {
	"Path": "com.baomidou.mybatisplus.extension.plugins.OptimisticLockerInterceptor.getUpdatedVersionVal",
	"Comment": "this method provides the control for version value.returned value type must be the same as original one.",
	"Method": "Object getUpdatedVersionVal(Object originalVersionVal){\r\n    if (null == originalVersionVal) {\r\n        return null;\r\n    }\r\n    Class<?> versionValClass = originalVersionVal.getClass();\r\n    if (long.class.equals(versionValClass)) {\r\n        return ((long) originalVersionVal) + 1;\r\n    } else if (Long.class.equals(versionValClass)) {\r\n        return ((Long) originalVersionVal) + 1;\r\n    } else if (int.class.equals(versionValClass)) {\r\n        return ((int) originalVersionVal) + 1;\r\n    } else if (Integer.class.equals(versionValClass)) {\r\n        return ((Integer) originalVersionVal) + 1;\r\n    } else if (Date.class.equals(versionValClass)) {\r\n        return new Date();\r\n    } else if (Timestamp.class.equals(versionValClass)) {\r\n        return new Timestamp(System.currentTimeMillis());\r\n    } else if (LocalDateTime.class.equals(versionValClass)) {\r\n        return LocalDateTime.now();\r\n    }\r\n    return originalVersionVal;\r\n}"
}, {
	"Path": "org.reflections.util.ConfigurationBuilder.addScanners",
	"Comment": "set the scanners instances for scanning different metadata",
	"Method": "ConfigurationBuilder addScanners(Scanner scanners){\r\n    this.scanners.addAll(Sets.newHashSet(scanners));\r\n    return this;\r\n}"
}, {
	"Path": "io.restassured.config.ObjectMapperConfig.defaultObjectMapperType",
	"Comment": "creates an object mapper configuration that uses the specified object mapper as default.",
	"Method": "ObjectMapperType defaultObjectMapperType(ObjectMapperConfig defaultObjectMapperType,ObjectMapperType defaultObjectMapperType){\r\n    return new ObjectMapperConfig(defaultObjectMapper, defaultObjectMapperType, gsonObjectMapperFactory, jackson1ObjectMapperFactory, jackson2ObjectMapperFactory, jaxbObjectMapperFactory, true);\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.channels.TransformingReceivePort.forEach",
	"Comment": "performs the given action on each message received by this channel.this method returns only after all messages have been consumed and the channel has been closed.",
	"Method": "void forEach(SuspendableAction1<T> action){\r\n    Channels.forEach(this, action);\r\n}"
}, {
	"Path": "net.minecraftforge.common.config.Property.setValidValues",
	"Comment": "sets the array of valid values that this string property can be set to. when an array of valid values is defined for a property thegui control for that property will be a value cycle button.",
	"Method": "Property setValidValues(String[] validValues){\r\n    this.validValues = validValues;\r\n    return this;\r\n}"
}, {
	"Path": "io.restassured.path.xml.config.XmlPathConfig.declareNamespaces",
	"Comment": "specify declared namespaces that will be used when parsing xml.",
	"Method": "XmlPathConfig declareNamespaces(Map<String, String> namespacesToDeclare){\r\n    return new XmlPathConfig(jaxbObjectMapperFactory, defaultParserType, defaultDeserializer, charset, features, namespacesToDeclare, properties, validating, namespaceAware, allowDocTypeDeclaration);\r\n}"
}, {
	"Path": "io.objectbox.query.PropertyQuery.maxDouble",
	"Comment": "finds the maximum value for the given property over all objects matching the query.",
	"Method": "double maxDouble(){\r\n    return (Double) query.callInReadTx(new Callable<Double>() {\r\n        @Override\r\n        public Double call() {\r\n            return nativeMaxDouble(queryHandle, query.cursorHandle(), propertyId);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "io.objectbox.query.PropertyQuery.maxDouble",
	"Comment": "finds the maximum value for the given property over all objects matching the query.",
	"Method": "double maxDouble(){\r\n    return nativeMaxDouble(queryHandle, query.cursorHandle(), propertyId);\r\n}"
}, {
	"Path": "co.paralleluniverse.concurrent.util.ConcurrentSkipListSet.iterator",
	"Comment": "returns an iterator over the elements in this set in ascending order.",
	"Method": "Iterator<E> iterator(){\r\n    return m.navigableKeySet().iterator();\r\n}"
}, {
	"Path": "org.springframework.cloud.netflix.zuul.filters.route.RestClientRibbonCommandTests.testNullEntityWithOldConstruct",
	"Comment": "tests old constructors kept for backwards compatibility with spring cloud sleuth 1.x versions",
	"Method": "void testNullEntityWithOldConstruct(){\r\n    String uri = \"http://example.com\";\r\n    LinkedMultiValueMap<String, String> headers = new LinkedMultiValueMap();\r\n    headers.add(\"my-header\", \"my-value\");\r\n    LinkedMultiValueMap<String, String> params = new LinkedMultiValueMap();\r\n    params.add(\"myparam\", \"myparamval\");\r\n    RestClientRibbonCommand command = new RestClientRibbonCommand(\"cmd\", null, Verb.GET, uri, false, headers, params, null);\r\n    HttpRequest request = command.createRequest();\r\n    assertThat(\"uri is wrong\", request.getUri().toString(), startsWith(uri));\r\n    assertThat(\"my-header is wrong\", request.getHttpHeaders().getFirstValue(\"my-header\"), is(equalTo(\"my-value\")));\r\n    assertThat(\"myparam is missing\", request.getQueryParams().get(\"myparam\").iterator().next(), is(equalTo(\"myparamval\")));\r\n    command = new RestClientRibbonCommand(\"cmd\", null, new RibbonCommandContext(\"example\", \"GET\", uri, false, headers, params, null), zuulProperties);\r\n    request = command.createRequest();\r\n    assertThat(\"uri is wrong\", request.getUri().toString(), startsWith(uri));\r\n    assertThat(\"my-header is wrong\", request.getHttpHeaders().getFirstValue(\"my-header\"), is(equalTo(\"my-value\")));\r\n    assertThat(\"myparam is missing\", request.getQueryParams().get(\"myparam\").iterator().next(), is(equalTo(\"myparamval\")));\r\n}"
}, {
	"Path": "net.minecraftforge.common.config.Property.isIntList",
	"Comment": "checks if all of the current values stored in this property can be converted to an integer.",
	"Method": "boolean isIntList(){\r\n    if (isList && type == Type.INTEGER)\r\n        for (String value : values) {\r\n            try {\r\n                Integer.parseInt(value);\r\n            } catch (NumberFormatException e) {\r\n                return false;\r\n            }\r\n        }\r\n    return isList && type == Type.INTEGER;\r\n}"
}, {
	"Path": "co.paralleluniverse.actors.ActorRegistry.hasGlobalRegistry",
	"Comment": "checks whether the registry is global to the entire cluster.",
	"Method": "boolean hasGlobalRegistry(){\r\n    return !(registry instanceof LocalActorRegistry);\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.StampedLock.tryWriteLock",
	"Comment": "exclusively acquires the lock if it is immediately available.",
	"Method": "long tryWriteLock(long tryWriteLock,long time,TimeUnit unit){\r\n    try {\r\n        long nanos = unit.toNanos(time);\r\n        if (!Strand.interrupted()) {\r\n            long next, deadline;\r\n            if ((next = tryWriteLock()) != 0L)\r\n                return next;\r\n            if (nanos <= 0L)\r\n                return 0L;\r\n            if ((deadline = System.nanoTime() + nanos) == 0L)\r\n                deadline = 1L;\r\n            if ((next = acquireWrite(true, deadline)) != INTERRUPTED)\r\n                return next;\r\n        }\r\n        throw new InterruptedException();\r\n    } catch (SuspendExecution e) {\r\n        throw new AssertionError();\r\n    }\r\n}"
}, {
	"Path": "net.minecraftforge.common.DimensionManager.getDimensions",
	"Comment": "returns a list of dimensions associated with this dimensiontype.",
	"Method": "int[] getDimensions(DimensionType type){\r\n    int[] ret = new int[dimensions.size()];\r\n    int x = 0;\r\n    for (Int2ObjectMap.Entry<Dimension> ent : dimensions.int2ObjectEntrySet()) {\r\n        if (ent.getValue().type == type) {\r\n            ret[x++] = ent.getIntKey();\r\n        }\r\n    }\r\n    return Arrays.copyOf(ret, x);\r\n}"
}, {
	"Path": "com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean.setFailFast",
	"Comment": "if true, a final check is done on configuration to assure that all mappedstatements are fully loaded and there is no one still pending to resolveincludes. defaults to false.",
	"Method": "void setFailFast(boolean failFast){\r\n    this.failFast = failFast;\r\n}"
}, {
	"Path": "org.springframework.cloud.netflix.zuul.filters.route.SimpleHostRoutingFilter.addIgnoredHeaders",
	"Comment": "add header names to exclude from proxied response in the current request.",
	"Method": "void addIgnoredHeaders(String names){\r\n    this.helper.addIgnoredHeaders(names);\r\n}"
}, {
	"Path": "org.springframework.security.acls.jdbc.BasicLookupStrategy.convert",
	"Comment": "the final phase of converting the map of aclimpl\tinstances which contain stubaclparents into proper, valid\taclimpls with correct acl parents.",
	"Method": "AclImpl convert(Map<Serializable, Acl> inputMap,Long currentIdentity){\r\n    Assert.notEmpty(inputMap, \"InputMap required\");\r\n    Assert.notNull(currentIdentity, \"CurrentIdentity required\");\r\n    Acl uncastAcl = inputMap.get(currentIdentity);\r\n    Assert.isInstanceOf(AclImpl.class, uncastAcl, \"The inputMap contained a non-AclImpl\");\r\n    AclImpl inputAcl = (AclImpl) uncastAcl;\r\n    Acl parent = inputAcl.getParentAcl();\r\n    if ((parent != null) && parent instanceof StubAclParent) {\r\n        StubAclParent stubAclParent = (StubAclParent) parent;\r\n        parent = convert(inputMap, stubAclParent.getId());\r\n    }\r\n    AclImpl result = new AclImpl(inputAcl.getObjectIdentity(), (Long) inputAcl.getId(), aclAuthorizationStrategy, grantingStrategy, parent, null, inputAcl.isEntriesInheriting(), inputAcl.getOwner());\r\n    List<AccessControlEntryImpl> aces = readAces(inputAcl);\r\n    List<AccessControlEntryImpl> acesNew = new ArrayList();\r\n    for (AccessControlEntryImpl ace : aces) {\r\n        setAclOnAce(ace, result);\r\n        acesNew.add(ace);\r\n    }\r\n    setAces(result, acesNew);\r\n    return result;\r\n}"
}, {
	"Path": "org.mapdb.jsr166.BlockingQueueTest.makeElement",
	"Comment": "returns an element suitable for insertion in the collection.override for collections with unusual element types.",
	"Method": "Object makeElement(int i){\r\n    return Integer.valueOf(i);\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.ReentrantLock.isLocked",
	"Comment": "queries if this lock is held by any strand. this method isdesigned for use in monitoring of the system state,not for synchronization control.",
	"Method": "boolean isLocked(boolean isLocked){\r\n    return sync.isLocked();\r\n}"
}, {
	"Path": "co.paralleluniverse.concurrent.util.ScheduledSingleThreadExecutor.reExecutePeriodic",
	"Comment": "requeues a periodic task unless current run state precludes it.same idea as delayedexecute except drops task rather than rejecting.",
	"Method": "void reExecutePeriodic(RunnableScheduledFuture<?> task){\r\n    if (canRunInCurrentRunState(true)) {\r\n        workQueue.add(task);\r\n        if (!canRunInCurrentRunState(true) && workQueue.remove(task))\r\n            task.cancel(false);\r\n    }\r\n}"
}, {
	"Path": "org.mapdb.jsr166.JSR166TestCase.permissivePolicy",
	"Comment": "returns a policy containing all the permissions we ever need.",
	"Method": "Policy permissivePolicy(){\r\n    return new AdjustablePolicy(// Permissions needed to change permissions!\r\n    new RuntimePermission(\"modifyThread\"), // Permissions needed to change permissions!\r\n    new RuntimePermission(\"getClassLoader\"), new RuntimePermission(\"setContextClassLoader\"), // Permissions needed by the junit test harness\r\n    new SecurityPermission(\"getPolicy\"), // Permissions needed by the junit test harness\r\n    new SecurityPermission(\"setPolicy\"), new RuntimePermission(\"setSecurityManager\"), new RuntimePermission(\"accessDeclaredMembers\"), new PropertyPermission(\"*\", \"read\"), new java.io.FilePermission(\"<<ALL FILES>>\", \"read\"));\r\n}"
}, {
	"Path": "net.minecraftforge.event.entity.player.ItemTooltipEvent.getEntityPlayer",
	"Comment": "this event is fired with a null player during startup when populating search trees for tooltips.",
	"Method": "EntityPlayer getEntityPlayer(){\r\n    return super.getEntityPlayer();\r\n}"
}, {
	"Path": "io.objectbox.query.PropertyQuery.avg",
	"Comment": "calculates the average of all values for the given property over all objects matching the query.",
	"Method": "double avg(){\r\n    return (Double) query.callInReadTx(new Callable<Double>() {\r\n        @Override\r\n        public Double call() {\r\n            return nativeAvg(queryHandle, query.cursorHandle(), propertyId);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "io.objectbox.query.PropertyQuery.avg",
	"Comment": "calculates the average of all values for the given property over all objects matching the query.",
	"Method": "double avg(){\r\n    return nativeAvg(queryHandle, query.cursorHandle(), propertyId);\r\n}"
}, {
	"Path": "com.uber.nullaway.NullAway.matchMemberReference",
	"Comment": "for method references, we check that the referenced method correctly overrides thecorresponding functional interface method",
	"Method": "Description matchMemberReference(MemberReferenceTree tree,VisitorState state){\r\n    if (!matchWithinClass) {\r\n        return Description.NO_MATCH;\r\n    }\r\n    Symbol.MethodSymbol referencedMethod = ASTHelpers.getSymbol(tree);\r\n    Symbol.MethodSymbol funcInterfaceSymbol = NullabilityUtil.getFunctionalInterfaceMethod(tree, state.getTypes());\r\n    handler.onMatchMethodReference(this, tree, state, referencedMethod);\r\n    return checkOverriding(funcInterfaceSymbol, referencedMethod, tree, state);\r\n}"
}, {
	"Path": "io.restassured.builder.ResponseSpecBuilder.expectContent",
	"Comment": "expect that the response content conforms to one or more hamcrest matchers.",
	"Method": "ResponseSpecBuilder expectContent(Matcher<?> matcher,ResponseSpecBuilder expectContent,String path,Matcher<?> matcher,ResponseSpecBuilder expectContent,String path,List<Argument> arguments,Matcher<?> matcher){\r\n    spec.content(path, arguments, matcher);\r\n    return this;\r\n}"
}, {
	"Path": "io.restassured.path.xml.XmlPath.getLong",
	"Comment": "get the result of an xml path expression as a long. for syntax details please refer tothis url.",
	"Method": "long getLong(String path){\r\n    Object object = get(path);\r\n    return convertObjectTo(object, Long.class);\r\n}"
}, {
	"Path": "io.requery.sql.SchemaModifier.createTablesString",
	"Comment": "convenience method to generated the create table statements as a string.",
	"Method": "String createTablesString(TableCreationMode mode){\r\n    ArrayList<Type<?>> sorted = sortTypes();\r\n    StringBuilder sb = new StringBuilder();\r\n    for (Type<?> type : sorted) {\r\n        String sql = tableCreateStatement(type, mode);\r\n        sb.append(sql);\r\n        sb.append(\";\\n\");\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "paulscode.sound.codecs.CodecIBXM.loadModule",
	"Comment": "decodes the data in the specified inputstream into an instance ofibxm.module.",
	"Method": "Module loadModule(InputStream input){\r\n    DataInputStream data_input_stream = new DataInputStream(input);\r\n    byte[] xm_header = new byte[60];\r\n    data_input_stream.readFully(xm_header);\r\n    if (FastTracker2.is_xm(xm_header))\r\n        return FastTracker2.load_xm(xm_header, data_input_stream);\r\n    byte[] s3m_header = new byte[96];\r\n    System.arraycopy(xm_header, 0, s3m_header, 0, 60);\r\n    data_input_stream.readFully(s3m_header, 60, 36);\r\n    if (ScreamTracker3.is_s3m(s3m_header))\r\n        return ScreamTracker3.load_s3m(s3m_header, data_input_stream);\r\n    byte[] mod_header = new byte[1084];\r\n    System.arraycopy(s3m_header, 0, mod_header, 0, 96);\r\n    data_input_stream.readFully(mod_header, 96, 988);\r\n    return ProTracker.load_mod(mod_header, data_input_stream);\r\n}"
}, {
	"Path": "org.mapdb.jsr166.JSR166TestCase.dumpTestThreads",
	"Comment": "a debugging tool to print stack traces of most threads, as jstack does.uninteresting threads are filtered out.",
	"Method": "void dumpTestThreads(){\r\n    SecurityManager sm = System.getSecurityManager();\r\n    if (sm != null) {\r\n        try {\r\n            System.setSecurityManager(null);\r\n        } catch (SecurityException giveUp) {\r\n            return;\r\n        }\r\n    }\r\n    ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();\r\n    System.err.println(\"------ stacktrace dump start ------\");\r\n    for (ThreadInfo info : threadMXBean.dumpAllThreads(true, true)) {\r\n        final String name = info.getThreadName();\r\n        String lockName;\r\n        if (\"Signal Dispatcher\".equals(name))\r\n            continue;\r\n        if (\"Reference Handler\".equals(name) && (lockName = info.getLockName()) != null && lockName.startsWith(\"java.lang.ref.Reference$Lock\"))\r\n            continue;\r\n        if (\"Finalizer\".equals(name) && (lockName = info.getLockName()) != null && lockName.startsWith(\"java.lang.ref.ReferenceQueue$Lock\"))\r\n            continue;\r\n        if (\"checkForWedgedTest\".equals(name))\r\n            continue;\r\n        System.err.print(info);\r\n    }\r\n    System.err.println(\"------ stacktrace dump end ------\");\r\n    if (sm != null)\r\n        System.setSecurityManager(sm);\r\n}"
}, {
	"Path": "net.minecraftforge.fml.common.registry.EntityEntry.init",
	"Comment": "protected method, to make this optional, in case people subclass this to have a better factory.",
	"Method": "void init(){\r\n    this.factory = new EntityEntryBuilder.ConstructorFactory<Entity>(this.cls) {\r\n        @Override\r\n        protected String describeEntity() {\r\n            return String.valueOf(EntityEntry.this.getRegistryName());\r\n        }\r\n    };\r\n}"
}, {
	"Path": "net.minecraftforge.fml.common.registry.EntityEntry.init",
	"Comment": "protected method, to make this optional, in case people subclass this to have a better factory.",
	"Method": "void init(){\r\n    return String.valueOf(EntityEntry.this.getRegistryName());\r\n}"
}, {
	"Path": "org.springframework.security.config.annotation.web.configurers.AnonymousConfigurer.key",
	"Comment": "sets the key to identify tokens created for anonymous authentication. default is a\tsecure randomly generated key.",
	"Method": "AnonymousConfigurer<H> key(String key){\r\n    this.key = key;\r\n    return this;\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.Strand.equals",
	"Comment": "tests whether two strands represent the same fiber or thread.",
	"Method": "boolean equals(Object strand1,Object strand2,boolean equals,Object obj,boolean equals,Object obj){\r\n    if (strand1 == strand2)\r\n        return true;\r\n    if (strand1 == null | strand2 == null)\r\n        return false;\r\n    return of(strand1).equals(of(strand2));\r\n}"
}, {
	"Path": "io.restassured.matcher.RestAssuredMatchers.matchesXsdInClasspath",
	"Comment": "evaluates to true if an xml file in classpath matches the supplied xsd.",
	"Method": "XmlXsdMatcher matchesXsdInClasspath(String path){\r\n    return XmlXsdMatcher.matchesXsdInClasspath(path);\r\n}"
}, {
	"Path": "io.restassured.config.OAuthConfig.addEmptyAccessTokenToBaseString",
	"Comment": "configure whether or not to add an empty oauth token for oauth1 while generating base string",
	"Method": "OAuthConfig addEmptyAccessTokenToBaseString(boolean addEmptyAccessTokenToBaseString){\r\n    return new OAuthConfig(addEmptyAccessTokenToBaseString, true);\r\n}"
}, {
	"Path": "org.springframework.security.cas.web.CasAuthenticationEntryPoint.createRedirectUrl",
	"Comment": "constructs the url for redirection to the cas server. default implementation relies\ton the cas client to do the bulk of the work.",
	"Method": "String createRedirectUrl(String serviceUrl){\r\n    return CommonUtils.constructRedirectUrl(this.loginUrl, this.serviceProperties.getServiceParameter(), serviceUrl, this.serviceProperties.isSendRenew(), false);\r\n}"
}, {
	"Path": "org.reflections.util.ConfigurationBuilder.useParallelExecutor",
	"Comment": "sets the executor service used for scanning to threadpoolexecutor with core size as the given availableprocessors parameter.the executor service spawns daemon threads by default.default is threadpoolexecutor with a single core",
	"Method": "ConfigurationBuilder useParallelExecutor(ConfigurationBuilder useParallelExecutor,int availableProcessors){\r\n    ThreadFactory factory = new ThreadFactoryBuilder().setDaemon(true).setNameFormat(\"org.reflections-scanner-%d\").build();\r\n    setExecutorService(Executors.newFixedThreadPool(availableProcessors, factory));\r\n    return this;\r\n}"
}, {
	"Path": "io.restassured.module.webtestclient.specification.WebTestClientRequestSpecBuilder.and",
	"Comment": "returns the same webtestclientrequestspecbuilder instance for syntactic sugar.",
	"Method": "WebTestClientRequestSpecBuilder and(){\r\n    return this;\r\n}"
}, {
	"Path": "net.minecraftforge.fml.client.config.GuiSelectStringEntries.elementClicked",
	"Comment": "the element in the slot that was clicked, boolean for whether it was double clicked or not",
	"Method": "void elementClicked(int index,boolean doubleClick,int mouseX,int mouseY){\r\n    selectedIndex = index;\r\n    owningScreen.currentValue = listEntries.get(index).getValue();\r\n}"
}, {
	"Path": "io.restassured.RestAssured.form",
	"Comment": "use form authentication. rest assured will try to parse the responselogin page and determine and try find the action, username and password inputfield automatically.note that the request will be much faster if you also supply a form auth configuration.",
	"Method": "AuthenticationScheme form(String userName,String password,AuthenticationScheme form,String userName,String password,FormAuthConfig config){\r\n    if (userName == null) {\r\n        throw new IllegalArgumentException(\"Username cannot be null\");\r\n    }\r\n    if (password == null) {\r\n        throw new IllegalArgumentException(\"Password cannot be null\");\r\n    }\r\n    final FormAuthScheme scheme = new FormAuthScheme();\r\n    scheme.setUserName(userName);\r\n    scheme.setPassword(password);\r\n    scheme.setConfig(config);\r\n    return scheme;\r\n}"
}, {
	"Path": "io.restassured.module.webtestclient.RestAssuredWebTestClient.put",
	"Comment": "perform a put request to the statically configured base path.",
	"Method": "WebTestClientResponse put(String path,Object pathParams,WebTestClientResponse put,String path,Map<String, ?> pathParams,WebTestClientResponse put,Function<UriBuilder, URI> uriFunction,WebTestClientResponse put,URI uri,WebTestClientResponse put,URL url,WebTestClientResponse put){\r\n    return given().put();\r\n}"
}, {
	"Path": "net.minecraftforge.common.ForgeModContainer.onConfigChanged",
	"Comment": "by subscribing to the onconfigchangedevent we are able to execute code when our config screens are closed.this implementation uses the optional configid string to handle multiple configurations using one event handler.",
	"Method": "void onConfigChanged(OnConfigChangedEvent event){\r\n    if (getMetadata().modId.equals(event.getModID())) {\r\n        if (\"chunkLoader\".equals(event.getConfigID())) {\r\n            ForgeChunkManager.syncConfigDefaults();\r\n            ForgeChunkManager.loadConfiguration();\r\n        } else {\r\n            boolean tmpStairs = disableStairSlabCulling;\r\n            syncConfig(false);\r\n            if (event.isWorldRunning() && tmpStairs != disableStairSlabCulling) {\r\n                FMLCommonHandler.instance().reloadRenderers();\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.StrandFactoryBuilder.setStackSize",
	"Comment": "suggests a stack size of strands created by the resulting strandfactory.the stack size used might be an approximation of the given value, or even ignore the passed value completely.",
	"Method": "StrandFactoryBuilder setStackSize(int stackSize){\r\n    this.stackSize = stackSize;\r\n    return this;\r\n}"
}, {
	"Path": "io.restassured.config.LogConfig.enableLoggingOfRequestAndResponseIfValidationFails",
	"Comment": "enable logging of both the request and the response if rest assureds test validation fails with the specified log detail",
	"Method": "LogConfig enableLoggingOfRequestAndResponseIfValidationFails(LogConfig enableLoggingOfRequestAndResponseIfValidationFails,LogDetail logDetail){\r\n    return new LogConfig(defaultPrintStream, prettyPrintingEnabled, logDetail, urlEncodeRequestUri, true);\r\n}"
}, {
	"Path": "net.minecraftforge.fml.common.event.FMLPostInitializationEvent.buildSoftDependProxy",
	"Comment": "build an object depending on if a specific target mod is loaded or not.usually would be used to access an object from the other mod.",
	"Method": "Optional<?> buildSoftDependProxy(String modId,String className,Object arguments){\r\n    if (Loader.isModLoaded(modId)) {\r\n        Class<?>[] args = Arrays.stream(arguments).filter(Objects::nonNull).map(Object::getClass).toArray(Class<?>[]::new);\r\n        try {\r\n            Class<?> clz = Class.forName(className, true, Loader.instance().getModClassLoader());\r\n            Constructor<?> ct = clz.getConstructor(args);\r\n            return Optional.of(ct.newInstance(arguments));\r\n        } catch (Exception e) {\r\n            FMLLog.log.info(\"An error occurred trying to build a soft depend proxy\", e);\r\n            return Optional.empty();\r\n        }\r\n    }\r\n    return Optional.empty();\r\n}"
}, {
	"Path": "net.minecraftforge.common.config.Property.requiresMcRestart",
	"Comment": "gets whether or not this property requires minecraft to be restarted when changed.defaults to false unless set to true.",
	"Method": "boolean requiresMcRestart(){\r\n    return this.requiresMcRestart;\r\n}"
}, {
	"Path": "paulscode.sound.codecs.CodecIBXM.trimArray",
	"Comment": "trims down the size of the array if it is larger than the specifiedmaximum length.",
	"Method": "byte[] trimArray(byte[] array,int maxLength){\r\n    byte[] trimmedArray = null;\r\n    if (array != null && array.length > maxLength) {\r\n        trimmedArray = new byte[maxLength];\r\n        System.arraycopy(array, 0, trimmedArray, 0, maxLength);\r\n    }\r\n    return trimmedArray;\r\n}"
}, {
	"Path": "org.nanohttpd.protocols.http.NanoHTTPD.setAsyncRunner",
	"Comment": "pluggable strategy for asynchronously executing requests.",
	"Method": "void setAsyncRunner(IAsyncRunner asyncRunner){\r\n    this.asyncRunner = asyncRunner;\r\n}"
}, {
	"Path": "io.restassured.path.json.config.JsonPathConfig.defaultParserType",
	"Comment": "creates an json path configuration that uses the specified parser type as default.",
	"Method": "JsonParserType defaultParserType(JsonPathConfig defaultParserType,JsonParserType defaultParserType){\r\n    return new JsonPathConfig(numberReturnType, defaultParserType, gsonObjectMapperFactory, jackson1ObjectMapperFactory, jackson2ObjectMapperFactory, defaultDeserializer, charset);\r\n}"
}, {
	"Path": "org.mapdb.io.DataIO.unpackRecid",
	"Comment": "unpack recid value from the input stream with 3 bit checksum.",
	"Method": "long unpackRecid(DataInput2 in){\r\n    long val = in.readPackedLong();\r\n    val = DataIO.parity1Get(val);\r\n    return val >>> 1;\r\n}"
}, {
	"Path": "org.springframework.security.acls.jdbc.JdbcAclService.setFindChildrenQuery",
	"Comment": "allows customization of the sql query used to find child object identities.",
	"Method": "void setFindChildrenQuery(String findChildrenSql){\r\n    this.findChildrenSql = findChildrenSql;\r\n}"
}, {
	"Path": "net.minecraftforge.client.model.ModelLoader.setBucketModelDefinition",
	"Comment": "helper method for registering all itemstacks for given item to map to universal bucket model.",
	"Method": "void setBucketModelDefinition(Item item){\r\n    ModelLoader.setCustomMeshDefinition(item, stack -> ModelDynBucket.LOCATION);\r\n    ModelBakery.registerItemVariants(item, ModelDynBucket.LOCATION);\r\n}"
}, {
	"Path": "io.restassured.module.webtestclient.config.WebTestClientParamConfig.replaceAllParameters",
	"Comment": "replace parameter values for all kinds of parameter types.",
	"Method": "WebTestClientParamConfig replaceAllParameters(){\r\n    return new WebTestClientParamConfig(REPLACE, REPLACE, REPLACE, REPLACE, true);\r\n}"
}, {
	"Path": "org.mapdb.jsr166.JSR166TestCase.systemPropertyValue",
	"Comment": "returns the value of the system property, or nan if not defined.",
	"Method": "float systemPropertyValue(String name){\r\n    String floatString = System.getProperty(name);\r\n    if (floatString == null)\r\n        return Float.NaN;\r\n    try {\r\n        return Float.parseFloat(floatString);\r\n    } catch (NumberFormatException ex) {\r\n        throw new IllegalArgumentException(String.format(\"Bad float value in system property %s=%s\", name, floatString));\r\n    }\r\n}"
}, {
	"Path": "co.paralleluniverse.concurrent.util.DelayQueue.poll",
	"Comment": "retrieves and removes the head of this queue, waiting if necessaryuntil an element with an expired delay is available on this queue,or the specified wait time expires.",
	"Method": "E poll(E poll,long timeout,TimeUnit unit){\r\n    long nanos = unit.toNanos(timeout);\r\n    final ReentrantLock lock = this.lock;\r\n    lock.lockInterruptibly();\r\n    try {\r\n        for (; ; ) {\r\n            E first = q.peek();\r\n            if (first == null) {\r\n                if (nanos <= 0)\r\n                    return null;\r\n                else\r\n                    nanos = available.awaitNanos(nanos);\r\n            } else {\r\n                long delay = first.getDelay(TimeUnit.NANOSECONDS);\r\n                if (delay <= 0)\r\n                    return q.poll();\r\n                if (nanos <= 0)\r\n                    return null;\r\n                if (nanos < delay || leader != null)\r\n                    nanos = available.awaitNanos(nanos);\r\n                else {\r\n                    Thread thisThread = Thread.currentThread();\r\n                    leader = thisThread;\r\n                    try {\r\n                        long timeLeft = available.awaitNanos(delay);\r\n                        nanos -= delay - timeLeft;\r\n                    } finally {\r\n                        if (leader == thisThread)\r\n                            leader = null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } finally {\r\n        if (leader == null && q.peek() != null)\r\n            available.signal();\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.nanohttpd.protocols.http.response.Response.closeConnection",
	"Comment": "indicate to close the connection after the response has been sent.",
	"Method": "void closeConnection(boolean close){\r\n    if (close)\r\n        this.header.put(\"connection\", \"close\");\r\n    else\r\n        this.header.remove(\"connection\");\r\n}"
}, {
	"Path": "org.springframework.cloud.netflix.turbine.EurekaInstanceDiscovery.marshall",
	"Comment": "private helper that marshals the information from each instance into something that\tturbine can understand. override this method for your own implementation for\tparsing eureka info.",
	"Method": "Instance marshall(InstanceInfo instanceInfo){\r\n    String hostname = instanceInfo.getHostName();\r\n    final String managementPort = instanceInfo.getMetadata().get(\"management.port\");\r\n    String port = managementPort == null ? String.valueOf(instanceInfo.getPort()) : managementPort;\r\n    String cluster = getClusterName(instanceInfo);\r\n    Boolean status = parseInstanceStatus(instanceInfo.getStatus());\r\n    if (hostname != null && cluster != null && status != null) {\r\n        Instance instance = getInstance(hostname, port, cluster, status);\r\n        Map<String, String> metadata = instanceInfo.getMetadata();\r\n        boolean securePortEnabled = instanceInfo.isPortEnabled(InstanceInfo.PortType.SECURE);\r\n        String securePort = String.valueOf(instanceInfo.getSecurePort());\r\n        addMetadata(instance, hostname, port, securePortEnabled, securePort, metadata);\r\n        String asgName = instanceInfo.getASGName();\r\n        if (asgName != null) {\r\n            instance.getAttributes().put(ASG_KEY, asgName);\r\n        }\r\n        DataCenterInfo dcInfo = instanceInfo.getDataCenterInfo();\r\n        if (dcInfo != null && dcInfo.getName().equals(DataCenterInfo.Name.Amazon)) {\r\n            AmazonInfo amznInfo = (AmazonInfo) dcInfo;\r\n            instance.getAttributes().putAll(amznInfo.getMetadata());\r\n        }\r\n        return instance;\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.cas.ServiceProperties.getServiceParameter",
	"Comment": "configures the request parameter to look for when attempting to send a request to",
	"Method": "String getServiceParameter(){\r\n    return this.serviceParameter;\r\n}"
}, {
	"Path": "com.uber.nullaway.NullAway.setComputedNullness",
	"Comment": "add computed nullness informat to an expression.used by handlers to communicate that an expression should has a more precise nullness thanwhat is known from source annotations.",
	"Method": "void setComputedNullness(ExpressionTree e,Nullness nullness){\r\n    computedNullnessMap.put(e, nullness);\r\n}"
}, {
	"Path": "com.alibaba.csp.sentinel.slots.statistic.base.LongAdder.reset",
	"Comment": "resets variables maintaining the sum to zero.this method maybe a useful alternative to creating a new adder, but is onlyeffective if there are no concurrent updates.because thismethod is intrinsically racy, it should only be used when it isknown that no threads are concurrently updating.",
	"Method": "void reset(){\r\n    internalReset(0L);\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.Phaser.abortWait",
	"Comment": "variant of releasewaiters that additionally tries to remove anynodes no longer waiting for advance due to timeout orinterrupt. currently, nodes are removed only if they are athead of queue, which suffices to reduce memory footprint inmost usages.",
	"Method": "int abortWait(int phase){\r\n    AtomicReference<QNode> head = (phase & 1) == 0 ? evenQ : oddQ;\r\n    for (; ; ) {\r\n        Strand t;\r\n        QNode q = head.get();\r\n        int p = (int) (root.state >>> PHASE_SHIFT);\r\n        if (q == null || ((t = q.strand) != null && q.phase == p)) {\r\n            return p;\r\n        }\r\n        if (head.compareAndSet(q, q.next) && t != null) {\r\n            q.strand = null;\r\n            Strand.unpark(t);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.cas.web.authentication.DefaultServiceAuthenticationDetails.getServicePort",
	"Comment": "gets the port from the casserviceurl ensuring to return the proper value if the\tdefault port is being used.",
	"Method": "int getServicePort(URL casServiceUrl){\r\n    int port = casServiceUrl.getPort();\r\n    if (port == -1) {\r\n        port = casServiceUrl.getDefaultPort();\r\n    }\r\n    return port;\r\n}"
}, {
	"Path": "net.minecraftforge.fml.common.event.FMLPreInitializationEvent.getModLog",
	"Comment": "get a logger instance configured to write to the fml log as a parent, identified by modid. handy for mod logging!",
	"Method": "Logger getModLog(){\r\n    return LogManager.getLogger(modContainer.getModId());\r\n}"
}, {
	"Path": "com.rxjava2.android.samples.ui.operators.ReplayExampleActivity.doSomeWork",
	"Comment": "using replay operator, replay ensure that all observers see the same sequenceof emitted items, even if they subscribe after the observable has begun emitting items",
	"Method": "void doSomeWork(){\r\n    PublishSubject<Integer> source = PublishSubject.create();\r\n    ConnectableObservable<Integer> connectableObservable = source.replay(3);\r\n    connectableObservable.connect();\r\n    connectableObservable.subscribe(getFirstObserver());\r\n    source.onNext(1);\r\n    source.onNext(2);\r\n    source.onNext(3);\r\n    source.onNext(4);\r\n    source.onComplete();\r\n    connectableObservable.subscribe(getSecondObserver());\r\n}"
}, {
	"Path": "com.rxjava2.android.samples.ui.operators.ReplaySubjectExampleActivity.doSomeWork",
	"Comment": "replaysubject emits to any observer all of the items that were emittedby the source observable, regardless of when the observer subscribes.",
	"Method": "void doSomeWork(){\r\n    ReplaySubject<Integer> source = ReplaySubject.create();\r\n    source.subscribe(getFirstObserver());\r\n    source.onNext(1);\r\n    source.onNext(2);\r\n    source.onNext(3);\r\n    source.onNext(4);\r\n    source.onComplete();\r\n    source.subscribe(getSecondObserver());\r\n}"
}, {
	"Path": "net.minecraftforge.common.config.Property.setShowInGui",
	"Comment": "sets whether or not this property should be allowed to show on config guis.defaults to true.",
	"Method": "Property setShowInGui(boolean showInGui){\r\n    this.showInGui = showInGui;\r\n    return this;\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.Phaser.getRoot",
	"Comment": "returns the root ancestor of this phaser, which is the same asthis phaser if it has no parent.",
	"Method": "Phaser getRoot(){\r\n    return root;\r\n}"
}, {
	"Path": "net.minecraftforge.event.entity.player.PlayerInteractEvent.getPos",
	"Comment": "if the interaction was on an entity, will be a blockpos centered on the entity.if the interaction was on a block, will be the position of that block.otherwise, will be a blockpos centered on the player.will never be null.",
	"Method": "BlockPos getPos(){\r\n    return pos;\r\n}"
}, {
	"Path": "paulscode.sound.codecs.CodecIBXM.endOfStream",
	"Comment": "returns false if there is still more data available to be read in.",
	"Method": "boolean endOfStream(boolean endOfStream,boolean action,boolean value){\r\n    if (action == SET)\r\n        endOfStream = value;\r\n    return endOfStream;\r\n}"
}, {
	"Path": "io.restassured.path.xml.XmlPath.get",
	"Comment": "get the result of an xml path expression. for syntax details please refer tothis url.",
	"Method": "Node get(T get,String path){\r\n    AssertParameter.notNull(path, \"path\");\r\n    return getFromPath(path, true);\r\n}"
}, {
	"Path": "co.paralleluniverse.concurrent.util.ConcurrentSkipListPriorityQueue.comparable",
	"Comment": "if using comparator, return a comparableusingcomparator, elsecast key as comparable, which may cause classcastexception,which is propagated back to caller.",
	"Method": "Comparable<? super E> comparable(Object key){\r\n    if (key == null)\r\n        throw new NullPointerException();\r\n    if (comparator != null)\r\n        return new ComparableUsingComparator<E>((E) key, comparator);\r\n    else\r\n        return (Comparable<? super E>) key;\r\n}"
}, {
	"Path": "com.corundumstudio.socketio.Configuration.setExceptionListener",
	"Comment": "exception listener invoked on any exception insocketio listener",
	"Method": "void setExceptionListener(ExceptionListener exceptionListener){\r\n    this.exceptionListener = exceptionListener;\r\n}"
}, {
	"Path": "co.paralleluniverse.common.util.Exceptions.unwrap",
	"Comment": "unwraps several common wrapper exceptions and returns the underlying cause.",
	"Method": "Throwable unwrap(Throwable t){\r\n    for (; ; ) {\r\n        if (t == null)\r\n            throw new NullPointerException();\r\n        if (t instanceof java.util.concurrent.ExecutionException)\r\n            t = t.getCause();\r\n        else if (t instanceof java.lang.reflect.InvocationTargetException)\r\n            t = t.getCause();\r\n        else if (t.getClass().equals(RuntimeException.class) && t.getCause() != null)\r\n            t = t.getCause();\r\n        else\r\n            return t;\r\n    }\r\n}"
}, {
	"Path": "io.restassured.module.webtestclient.matcher.RestAssuredWebTestClientMatchers.matchesXsdInClasspath",
	"Comment": "evaluates to true if an xml file in classpath matches the supplied xsd.",
	"Method": "Matcher<String> matchesXsdInClasspath(String path){\r\n    return XmlXsdMatcher.matchesXsdInClasspath(path);\r\n}"
}, {
	"Path": "io.restassured.config.ObjectMapperConfig.defaultObjectMapper",
	"Comment": "creates an object mapper configuration that uses the specified object mapper as default.",
	"Method": "ObjectMapper defaultObjectMapper(ObjectMapperConfig defaultObjectMapper,ObjectMapper defaultObjectMapper){\r\n    return new ObjectMapperConfig(defaultObjectMapper);\r\n}"
}, {
	"Path": "com.alibaba.csp.sentinel.datasource.redis.config.RedisConnectionConfig.setTimeout",
	"Comment": "sets the command timeout for synchronous command execution.",
	"Method": "void setTimeout(Long timeout){\r\n    AssertUtil.notNull(timeout, \"Timeout must not be null\");\r\n    AssertUtil.isTrue(timeout >= 0, \"Timeout must be greater or equal 0\");\r\n    this.timeout = timeout;\r\n}"
}, {
	"Path": "net.minecraftforge.fluids.FluidUtil.tryEmptyContainer",
	"Comment": "takes a filled container and tries to empty it into the given tank.",
	"Method": "FluidActionResult tryEmptyContainer(ItemStack container,IFluidHandler fluidDestination,int maxAmount,EntityPlayer player,boolean doDrain){\r\n    ItemStack containerCopy = ItemHandlerHelper.copyStackWithSize(container, 1);\r\n    IFluidHandlerItem containerFluidHandler = getFluidHandler(containerCopy);\r\n    if (containerFluidHandler != null) {\r\n        if (doDrain) {\r\n            FluidStack transfer = tryFluidTransfer(fluidDestination, containerFluidHandler, maxAmount, true);\r\n            if (transfer != null) {\r\n                if (player != null) {\r\n                    SoundEvent soundevent = transfer.getFluid().getEmptySound(transfer);\r\n                    player.world.playSound(null, player.posX, player.posY + 0.5, player.posZ, soundevent, SoundCategory.BLOCKS, 1.0F, 1.0F);\r\n                }\r\n                ItemStack resultContainer = containerFluidHandler.getContainer();\r\n                return new FluidActionResult(resultContainer);\r\n            }\r\n        } else {\r\n            FluidStack simulatedTransfer = tryFluidTransfer(fluidDestination, containerFluidHandler, maxAmount, false);\r\n            if (simulatedTransfer != null) {\r\n                containerFluidHandler.drain(simulatedTransfer, true);\r\n                ItemStack resultContainer = containerFluidHandler.getContainer();\r\n                return new FluidActionResult(resultContainer);\r\n            }\r\n        }\r\n    }\r\n    return FluidActionResult.FAILURE;\r\n}"
}, {
	"Path": "net.minecraftforge.oredict.OreDictionary.getOreNames",
	"Comment": "retrieves a list of all unique ore names that are already registered.",
	"Method": "String[] getOreNames(){\r\n    return idToName.toArray(new String[idToName.size()]);\r\n}"
}, {
	"Path": "co.paralleluniverse.concurrent.util.ThreadAccess.cloneThreadLocalMap",
	"Comment": "createinheritedmap works only for inheritablethreadlocals",
	"Method": "Object cloneThreadLocalMap(Object orig){\r\n    try {\r\n        Object clone = createThreadLocalMap(new ThreadLocal(), null);\r\n        Object origTable = threadLocalMapTableField.get(orig);\r\n        final int len = Array.getLength(origTable);\r\n        Object tableClone = Array.newInstance(threadLocalMapEntryClass, len);\r\n        for (int i = 0; i < len; i++) {\r\n            Object entry = Array.get(origTable, i);\r\n            if (entry != null)\r\n                Array.set(tableClone, i, cloneThreadLocalMapEntry(entry));\r\n        }\r\n        threadLocalMapTableField.set(clone, tableClone);\r\n        threadLocalMapSizeField.setInt(clone, threadLocalMapSizeField.getInt(orig));\r\n        threadLocalMapThresholdField.setInt(clone, threadLocalMapThresholdField.getInt(orig));\r\n        return clone;\r\n    } catch (ReflectiveOperationException ex) {\r\n        throw new AssertionError(ex);\r\n    }\r\n}"
}, {
	"Path": "net.minecraftforge.common.config.Configuration.runConfiguration",
	"Comment": "create a configuration file for the file given in parameter with the provided config version number.",
	"Method": "void runConfiguration(File file,String configVersion){\r\n    this.file = file;\r\n    this.definedConfigVersion = configVersion;\r\n    String basePath = ((File) (FMLInjectionData.data()[6])).getAbsolutePath().replace(File.separatorChar, '/').replace(\"/.\", \"\");\r\n    String path = file.getAbsolutePath().replace(File.separatorChar, '/').replace(\"/./\", \"/\").replace(basePath, \"\");\r\n    if (PARENT != null) {\r\n        PARENT.setChild(path, this);\r\n        isChild = true;\r\n    } else {\r\n        fileName = path;\r\n        try {\r\n            load();\r\n        } catch (Throwable e) {\r\n            File fileBak = new File(file.getAbsolutePath() + \"_\" + new SimpleDateFormat(\"yyyyMMdd_HHmmss\").format(new Date()) + \".errored\");\r\n            FMLLog.log.fatal(\"An exception occurred while loading config file {}. This file will be renamed to {} \" + \"and a new config file will be generated.\", file.getName(), fileBak.getName(), e);\r\n            file.renameTo(fileBak);\r\n            load();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.minecraftforge.client.MinecraftForgeClient.getLocale",
	"Comment": "returns the locale set by the player in minecraft.useful for creating string and number formatters.",
	"Method": "Locale getLocale(){\r\n    return Minecraft.getMinecraft().getLanguageManager().getCurrentLanguage().getJavaLocale();\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.Semaphore.availablePermits",
	"Comment": "returns the current number of permits available in this semaphore.this method is typically used for debugging and testing purposes.",
	"Method": "int availablePermits(){\r\n    return sync.getPermits();\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.CyclicBarrier.getParties",
	"Comment": "returns the number of parties required to trip this barrier.",
	"Method": "int getParties(){\r\n    return parties;\r\n}"
}, {
	"Path": "net.minecraftforge.common.config.Configuration.get",
	"Comment": "gets a property object of the specified type using default settings.",
	"Method": "Property get(String category,String key,boolean defaultValue,Property get,String category,String key,boolean defaultValue,String comment,Property get,String category,String key,boolean[] defaultValues,Property get,String category,String key,boolean[] defaultValues,String comment,Property get,String category,String key,boolean[] defaultValues,String comment,boolean isListLengthFixed,int maxListLength,Property get,String category,String key,int defaultValue,Property get,String category,String key,int defaultValue,String comment,Property get,String category,String key,int defaultValue,String comment,int minValue,int maxValue,Property get,String category,String key,int[] defaultValues,Property get,String category,String key,int[] defaultValues,String comment,Property get,String category,String key,int[] defaultValues,String comment,int minValue,int maxValue,Property get,String category,String key,int[] defaultValues,String comment,int minValue,int maxValue,boolean isListLengthFixed,int maxListLength,Property get,String category,String key,double defaultValue,Property get,String category,String key,double defaultValue,String comment,Property get,String category,String key,double defaultValue,String comment,double minValue,double maxValue,Property get,String category,String key,double[] defaultValues,Property get,String category,String key,double[] defaultValues,String comment,Property get,String category,String key,double[] defaultValues,String comment,double minValue,double maxValue,Property get,String category,String key,double[] defaultValues,String comment,double minValue,double maxValue,boolean isListLengthFixed,int maxListLength,Property get,String category,String key,String defaultValue,Property get,String category,String key,String defaultValue,String comment,Property get,String category,String key,String defaultValue,String comment,Pattern validationPattern,Property get,String category,String key,String defaultValue,String comment,String[] validValues,Property get,String category,String key,String[] defaultValues,Property get,String category,String key,String[] defaultValues,String comment,Property get,String category,String key,String[] defaultValues,String comment,Pattern validationPattern,Property get,String category,String key,String[] defaultValues,String comment,boolean isListLengthFixed,int maxListLength,Pattern validationPattern,Property get,String category,String key,String defaultValue,String comment,Property.Type type,Property get,String category,String key,String[] defaultValues,String comment,Property.Type type){\r\n    ConfigCategory cat = getCategory(category);\r\n    if (cat.containsKey(key)) {\r\n        Property prop = cat.get(key);\r\n        if (prop.getType() == null) {\r\n            prop = new Property(prop.getName(), prop.getString(), type);\r\n            cat.put(key, prop);\r\n        }\r\n        prop.setDefaultValues(defaultValues);\r\n        prop.setComment(comment);\r\n        return prop;\r\n    } else if (defaultValues != null) {\r\n        Property prop = new Property(key, defaultValues, type);\r\n        prop.setDefaultValues(defaultValues);\r\n        prop.setComment(comment);\r\n        cat.put(key, prop);\r\n        return prop;\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "io.restassured.internal.http.HTTPBuilder.getUri",
	"Comment": "get the default uri used for requests that do not explicitly take auri param.",
	"Method": "Object getUri(URIBuilder getUri){\r\n    return defaultURI;\r\n}"
}, {
	"Path": "co.paralleluniverse.fibers.Fiber.currentFiber",
	"Comment": "returns the active fiber on this thread or null if no fiber is running.",
	"Method": "Fiber currentFiber(){\r\n    return getCurrentFiber();\r\n}"
}, {
	"Path": "org.mapdb.jsr166.BlockingQueueTest.testAddAllNullElements",
	"Comment": "addall of a collection with null elements throws nullpointerexception",
	"Method": "void testAddAllNullElements(){\r\n    final Collection q = emptyCollection();\r\n    final Collection<Integer> elements = Arrays.asList(new Integer[SIZE]);\r\n    try {\r\n        q.addAll(elements);\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "io.restassured.config.RedirectConfig.and",
	"Comment": "the same redirectconfig instance. this method is only provided as syntactic sugar.",
	"Method": "RedirectConfig and(){\r\n    return this;\r\n}"
}, {
	"Path": "net.minecraftforge.fml.common.network.ByteBufUtils.varIntByteCount",
	"Comment": "the number of bytes to write the supplied int using the 7 bit varint encoding.",
	"Method": "int varIntByteCount(int toCount){\r\n    return (toCount & 0xFFFFFF80) == 0 ? 1 : ((toCount & 0xFFFFC000) == 0 ? 2 : ((toCount & 0xFFE00000) == 0 ? 3 : ((toCount & 0xF0000000) == 0 ? 4 : 5)));\r\n}"
}, {
	"Path": "org.springframework.security.acls.jdbc.BasicLookupStrategy.setSelectClause",
	"Comment": "the sql for the select clause. if customizing in order to modify column names,\tschema etc, the other sql customization fields must also be set to match.",
	"Method": "void setSelectClause(String selectClause){\r\n    this.selectClause = selectClause;\r\n}"
}, {
	"Path": "com.alibaba.csp.sentinel.slots.statistic.base.LeapArray.isWindowDeprecated",
	"Comment": "check if a bucket is deprecated, which means that the buckethas been behind for at least an entire window time span.",
	"Method": "boolean isWindowDeprecated(WindowWrap<T> windowWrap){\r\n    return TimeUtil.currentTimeMillis() - windowWrap.windowStart() >= intervalInMs;\r\n}"
}, {
	"Path": "org.reflections.vfs.Vfs.setDefaultURLTypes",
	"Comment": "sets the static default url types. can be used to statically plug in urltypes",
	"Method": "void setDefaultURLTypes(List<UrlType> urlTypes){\r\n    defaultUrlTypes = urlTypes;\r\n}"
}, {
	"Path": "net.minecraftforge.client.ClientCommandHandler.format",
	"Comment": "couple of helpers because the mcp names are stupid and long...",
	"Method": "TextComponentTranslation format(TextFormatting color,String str,Object args){\r\n    TextComponentTranslation ret = new TextComponentTranslation(str, args);\r\n    ret.getStyle().setColor(color);\r\n    return ret;\r\n}"
}, {
	"Path": "com.rxjava2.android.samples.ui.operators.IntervalExampleActivity.doSomeWork",
	"Comment": "simple example using interval to run task at an interval of 2 secwhich start immediately",
	"Method": "void doSomeWork(){\r\n    disposables.add(// Run on a background thread\r\n    getObservable().subscribeOn(// Be notified on the main thread\r\n    Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).subscribeWith(getObserver()));\r\n}"
}, {
	"Path": "net.minecraftforge.common.capabilities.Capability.getDefaultInstance",
	"Comment": "a new instance of the default implementation.if it important to note that if you want to use the default storageyou may be required to use this exact implementation.refer to the owning api of the capability in question.",
	"Method": "T getDefaultInstance(){\r\n    try {\r\n        return this.factory.call();\r\n    } catch (Exception e) {\r\n        Throwables.throwIfUnchecked(e);\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "net.minecraftforge.common.config.Property.isBooleanList",
	"Comment": "checks if all of current values stored in this property can be converted to a boolean.",
	"Method": "boolean isBooleanList(){\r\n    if (isList && type == Type.BOOLEAN)\r\n        for (String value : values) {\r\n            if (!\"true\".equalsIgnoreCase(value) && !\"false\".equalsIgnoreCase(value)) {\r\n                return false;\r\n            }\r\n        }\r\n    return isList && type == Type.BOOLEAN;\r\n}"
}, {
	"Path": "com.alibaba.csp.sentinel.annotation.aspectj.AbstractSentinelAspectSupport.getDeclaredMethodFor",
	"Comment": "get declared method with provided name and parametertypes in given class and its super classes.all parameters should be valid.",
	"Method": "Method getDeclaredMethodFor(Class<?> clazz,String name,Class<?> parameterTypes){\r\n    try {\r\n        return clazz.getDeclaredMethod(name, parameterTypes);\r\n    } catch (NoSuchMethodException e) {\r\n        Class<?> superClass = clazz.getSuperclass();\r\n        if (superClass != null) {\r\n            return getDeclaredMethodFor(superClass, name, parameterTypes);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "io.restassured.http.Cookies.getValue",
	"Comment": "get a single cookie value with the supplied name. if there are several cookies matching the cookiename thenthe first one is returned.",
	"Method": "String getValue(String cookieName){\r\n    AssertParameter.notNull(cookieName, \"Cookie name\");\r\n    return cookies.getValue(cookieName);\r\n}"
}, {
	"Path": "com.alibaba.csp.sentinel.transport.config.TransportConfig.getHeartbeatClientIp",
	"Comment": "get heartbeat client local ip.if the client ip not configured,it will be the address of local host",
	"Method": "String getHeartbeatClientIp(){\r\n    String ip = SentinelConfig.getConfig(HEARTBEAT_CLIENT_IP);\r\n    if (StringUtil.isBlank(ip)) {\r\n        ip = HostNameUtil.getIp();\r\n    }\r\n    return ip;\r\n}"
}, {
	"Path": "net.minecraftforge.registries.GameData.checkPrefix",
	"Comment": "check a name for a domain prefix, and if not present infer it from thecurrent active mod container.",
	"Method": "ResourceLocation checkPrefix(String name,ResourceLocation checkPrefix,String name,boolean warnOverrides){\r\n    int index = name.lastIndexOf(':');\r\n    String oldPrefix = index == -1 ? \"\" : name.substring(0, index).toLowerCase(Locale.ROOT);\r\n    name = index == -1 ? name : name.substring(index + 1);\r\n    ModContainer mc = Loader.instance().activeModContainer();\r\n    String prefix = mc == null || (mc instanceof InjectedModContainer && ((InjectedModContainer) mc).wrappedContainer instanceof FMLContainer) ? \"minecraft\" : mc.getModId().toLowerCase(Locale.ROOT);\r\n    if (warnOverrides && !oldPrefix.equals(prefix) && oldPrefix.length() > 0) {\r\n        FMLLog.log.warn(\"Potentially Dangerous alternative prefix `{}` for name `{}`, expected `{}`. This could be a intended override, but in most cases indicates a broken mod.\", oldPrefix, name, prefix);\r\n        prefix = oldPrefix;\r\n    }\r\n    return new ResourceLocation(prefix, name);\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.Phaser.doArrive",
	"Comment": "main implementation for methods arrive and arriveandderegister.manually tuned to speed up and minimize race windows for thecommon case of just decrementing unarrived field.",
	"Method": "int doArrive(boolean deregister){\r\n    int adj = deregister ? ONE_ARRIVAL | ONE_PARTY : ONE_ARRIVAL;\r\n    final Phaser root = this.root;\r\n    for (; ; ) {\r\n        long s = (root == this) ? state : reconcileState();\r\n        int phase = (int) (s >>> PHASE_SHIFT);\r\n        int counts = (int) s;\r\n        int unarrived = (counts & UNARRIVED_MASK) - 1;\r\n        if (phase < 0)\r\n            return phase;\r\n        else if (counts == EMPTY || unarrived < 0) {\r\n            if (root == this || reconcileState() == s)\r\n                throw new IllegalStateException(badArrive(s));\r\n        } else if (STATE.compareAndSet(this, s, s -= adj)) {\r\n            if (unarrived == 0) {\r\n                long n = s & PARTIES_MASK;\r\n                int nextUnarrived = (int) n >>> PARTIES_SHIFT;\r\n                if (root != this)\r\n                    return parent.doArrive(nextUnarrived == 0);\r\n                if (onAdvance(phase, nextUnarrived))\r\n                    n |= TERMINATION_BIT;\r\n                else if (nextUnarrived == 0)\r\n                    n |= EMPTY;\r\n                else\r\n                    n |= nextUnarrived;\r\n                n |= (long) ((phase + 1) & MAX_PHASE) << PHASE_SHIFT;\r\n                STATE.compareAndSet(this, s, n);\r\n                releaseWaiters(phase);\r\n            }\r\n            return phase;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.restassured.builder.RequestSpecBuilder.setAuth",
	"Comment": "if you need to specify some credentials when performing a request.",
	"Method": "RequestSpecBuilder setAuth(AuthenticationScheme auth){\r\n    return setAuthentication(auth);\r\n}"
}, {
	"Path": "net.orfjackal.retrolambda.test.DefaultMethodsTest.keeps_annotations_on_interface_methods",
	"Comment": "a naive method for removing method bodies would easily also remove their annotations,because in asm method annotations are expressed as calls on the methodvisitor.",
	"Method": "void keeps_annotations_on_interface_methods(){\r\n    assertThat(\"interface\", AnnotatedInterface.class.getAnnotations(), arrayContaining(someAnnotation(1)));\r\n    assertThat(\"abstract method\", AnnotatedInterface.class.getMethod(\"annotatedAbstractMethod\").getAnnotations(), arrayContaining(someAnnotation(2)));\r\n    assertThat(\"default method\", AnnotatedInterface.class.getMethod(\"annotatedDefaultMethod\").getAnnotations(), arrayContaining(someAnnotation(3)));\r\n    assumeThat(SystemUtils.JAVA_VERSION_FLOAT, is(lessThan(1.8f)));\r\n    assertThat(\"static method\", companionOf(AnnotatedInterface.class).getMethod(\"annotatedStaticMethod\").getAnnotations(), arrayContaining(someAnnotation(4)));\r\n}"
}, {
	"Path": "com.corundumstudio.socketio.Configuration.setAddVersionHeader",
	"Comment": "adds server header with lib version to http response.default is true",
	"Method": "void setAddVersionHeader(boolean addVersionHeader){\r\n    this.addVersionHeader = addVersionHeader;\r\n}"
}, {
	"Path": "io.restassured.config.JsonConfig.numberReturnType",
	"Comment": "specifies if json parsing should use floats and doubles or bigdecimals to represent json numbers.",
	"Method": "JsonPathConfig.NumberReturnType numberReturnType(JsonConfig numberReturnType,JsonPathConfig.NumberReturnType numberReturnType){\r\n    return new JsonConfig(numberReturnType, true);\r\n}"
}, {
	"Path": "com.alibaba.csp.sentinel.slots.statistic.base.Striped64.getUnsafe",
	"Comment": "returns a sun.misc.unsafe.suitable for use in a 3rd party package.replace with a simple call to unsafe.getunsafe when integratinginto a jdk.",
	"Method": "sun.misc.Unsafe getUnsafe(){\r\n    try {\r\n        return sun.misc.Unsafe.getUnsafe();\r\n    } catch (SecurityException se) {\r\n        try {\r\n            return java.security.AccessController.doPrivileged(new java.security.PrivilegedExceptionAction<sun.misc.Unsafe>() {\r\n                public sun.misc.Unsafe run() throws Exception {\r\n                    java.lang.reflect.Field f = sun.misc.Unsafe.class.getDeclaredField(\"theUnsafe\");\r\n                    f.setAccessible(true);\r\n                    return (sun.misc.Unsafe) f.get(null);\r\n                }\r\n            });\r\n        } catch (java.security.PrivilegedActionException e) {\r\n            throw new RuntimeException(\"Could not initialize intrinsics\", e.getCause());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.alibaba.csp.sentinel.slots.statistic.base.Striped64.getUnsafe",
	"Comment": "returns a sun.misc.unsafe.suitable for use in a 3rd party package.replace with a simple call to unsafe.getunsafe when integratinginto a jdk.",
	"Method": "sun.misc.Unsafe getUnsafe(){\r\n    java.lang.reflect.Field f = sun.misc.Unsafe.class.getDeclaredField(\"theUnsafe\");\r\n    f.setAccessible(true);\r\n    return (sun.misc.Unsafe) f.get(null);\r\n}"
}, {
	"Path": "org.mapdb.io.DataIO.intToLong",
	"Comment": "converts 4 int bytes to lowest 4 long bytes. does not preserve negative flag",
	"Method": "long intToLong(int i){\r\n    return i & 0xffffffffL;\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.Strand.currentStrand",
	"Comment": "returns the current strand.this method will return a strand representing the fiber calling this method, or the current thread if this method is notcalled within a fiber.",
	"Method": "Strand currentStrand(){\r\n    if (FiberForkJoinScheduler.isFiberThread(Thread.currentThread()))\r\n        return Fiber.currentFiber();\r\n    Strand s = currentStrand.get();\r\n    if (s == null) {\r\n        s = ThreadStrand.get(Thread.currentThread());\r\n        currentStrand.set(s);\r\n    }\r\n    return s;\r\n}"
}, {
	"Path": "co.paralleluniverse.concurrent.util.DelayQueue.put",
	"Comment": "inserts the specified element into this delay queue. as the queue isunbounded this method will never block.",
	"Method": "void put(E e){\r\n    offer(e);\r\n}"
}, {
	"Path": "io.objectbox.relation.ToOne.setAndPutTargetAlways",
	"Comment": "todo provide a overload with a tomany parameter, which also gets updated",
	"Method": "void setAndPutTargetAlways(TARGET target){\r\n    ensureBoxes(target);\r\n    if (target != null) {\r\n        boxStore.runInTx(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                long targetKey = targetBox.put(target);\r\n                setResolvedTarget(target, targetKey);\r\n                entityBox.put(entity);\r\n            }\r\n        });\r\n    } else {\r\n        setTargetId(0);\r\n        clearResolved();\r\n        entityBox.put(entity);\r\n    }\r\n}"
}, {
	"Path": "io.objectbox.relation.ToOne.setAndPutTargetAlways",
	"Comment": "todo provide a overload with a tomany parameter, which also gets updated",
	"Method": "void setAndPutTargetAlways(TARGET target){\r\n    long targetKey = targetBox.put(target);\r\n    setResolvedTarget(target, targetKey);\r\n    entityBox.put(entity);\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.Phaser.forceTermination",
	"Comment": "forces this phaser to enter termination state. counts ofregistered parties are unaffected. if this phaser is a memberof a tiered set of phasers, then all of the phasers in the setare terminated. if this phaser is already terminated, thismethod has no effect. this method may be useful forcoordinating recovery after one or more tasks encounterunexpected exceptions.",
	"Method": "void forceTermination(){\r\n    final Phaser root = this.root;\r\n    long s;\r\n    while ((s = root.state) >= 0) {\r\n        if (STATE.compareAndSet(this, s, s | TERMINATION_BIT)) {\r\n            releaseWaiters(0);\r\n            releaseWaiters(1);\r\n            return;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.restassured.builder.ResponseSpecBuilder.expectStatusLine",
	"Comment": "expect that the response status line matches the given string.",
	"Method": "ResponseSpecBuilder expectStatusLine(Matcher<String> expectedStatusLine,ResponseSpecBuilder expectStatusLine,String expectedStatusLine){\r\n    spec.statusLine(expectedStatusLine);\r\n    return this;\r\n}"
}, {
	"Path": "net.minecraftforge.fml.client.registry.ClientRegistry.registerEntityShader",
	"Comment": "register a shader for an entity. this shader gets activated when a spectator begins spectating an entity.vanilla examples of this are the green effect for creepers and the invert effect for endermen.",
	"Method": "void registerEntityShader(Class<? extends Entity> entityClass,ResourceLocation shader){\r\n    entityShaderMap.put(entityClass, shader);\r\n}"
}, {
	"Path": "com.rxjava2.android.samples.ui.operators.MapExampleActivity.doSomeWork",
	"Comment": "here we are getting apiuser object from api server then we are converting it into user object because may be our database support user not apiuser object here we are using map operator to do that",
	"Method": "void doSomeWork(){\r\n    // Run on a background thread\r\n    getObservable().subscribeOn(// Be notified on the main thread\r\n    Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).map(new Function<List<ApiUser>, List<User>>() {\r\n        @Override\r\n        public List<User> apply(List<ApiUser> apiUsers) {\r\n            return Utils.convertApiUserListToUserList(apiUsers);\r\n        }\r\n    }).subscribe(getObserver());\r\n}"
}, {
	"Path": "com.rxjava2.android.samples.ui.operators.MapExampleActivity.doSomeWork",
	"Comment": "here we are getting apiuser object from api server then we are converting it into user object because may be our database support user not apiuser object here we are using map operator to do that",
	"Method": "void doSomeWork(){\r\n    return Utils.convertApiUserListToUserList(apiUsers);\r\n}"
}, {
	"Path": "org.nanohttpd.protocols.http.NanoHTTPD.makeSSLSocketFactory",
	"Comment": "creates an sslsocketfactory for https. pass a keystore resource with yourcertificate and passphrase",
	"Method": "SSLServerSocketFactory makeSSLSocketFactory(KeyStore loadedKeyStore,KeyManager[] keyManagers,SSLServerSocketFactory makeSSLSocketFactory,KeyStore loadedKeyStore,KeyManagerFactory loadedKeyFactory,SSLServerSocketFactory makeSSLSocketFactory,String keyAndTrustStoreClasspathPath,char[] passphrase){\r\n    try {\r\n        KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\r\n        InputStream keystoreStream = NanoHTTPD.class.getResourceAsStream(keyAndTrustStoreClasspathPath);\r\n        if (keystoreStream == null) {\r\n            throw new IOException(\"Unable to load keystore from classpath: \" + keyAndTrustStoreClasspathPath);\r\n        }\r\n        keystore.load(keystoreStream, passphrase);\r\n        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\r\n        keyManagerFactory.init(keystore, passphrase);\r\n        return makeSSLSocketFactory(keystore, keyManagerFactory);\r\n    } catch (Exception e) {\r\n        throw new IOException(e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "co.paralleluniverse.fibers.Fiber.setDefaultUncaughtExceptionHandler",
	"Comment": "set the default handler invoked when a fiber abruptly terminatesdue to an uncaught exception, and no other handler has been definedfor that fiber.",
	"Method": "void setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler eh){\r\n    Fiber.defaultUncaughtExceptionHandler = eh;\r\n}"
}, {
	"Path": "net.minecraftforge.common.config.Property.getIntList",
	"Comment": "returns the integer value of all values that canbe parsed in the list.",
	"Method": "int[] getIntList(){\r\n    ArrayList<Integer> nums = new ArrayList<Integer>();\r\n    for (String value : values) {\r\n        try {\r\n            nums.add(Integer.parseInt(value));\r\n        } catch (NumberFormatException e) {\r\n        }\r\n    }\r\n    int[] primitives = new int[nums.size()];\r\n    for (int i = 0; i < nums.size(); i++) {\r\n        primitives[i] = nums.get(i);\r\n    }\r\n    return primitives;\r\n}"
}, {
	"Path": "net.minecraftforge.client.model.ItemTextureQuadConverter.convertTextureHorizontal",
	"Comment": "scans a texture and converts it into a list of horizontal strips stacked on top of each other.the height of the strips is as big as possible.",
	"Method": "List<UnpackedBakedQuad> convertTextureHorizontal(VertexFormat format,TRSRTransformation transform,TextureAtlasSprite template,TextureAtlasSprite sprite,float z,EnumFacing facing,int color,List<UnpackedBakedQuad> convertTextureHorizontal,VertexFormat format,TRSRTransformation transform,TextureAtlasSprite template,TextureAtlasSprite sprite,float z,EnumFacing facing,int color,int tint){\r\n    int w = template.getIconWidth();\r\n    int h = template.getIconHeight();\r\n    float wScale = 16f / (float) w;\r\n    float hScale = 16f / (float) h;\r\n    int[] data = template.getFrameTextureData(0)[0];\r\n    List<UnpackedBakedQuad> quads = Lists.newArrayList();\r\n    int start = -1;\r\n    for (int y = 0; y < h; y++) {\r\n        for (int x = 0; x < w; x++) {\r\n            int pixel = data[y * w + x];\r\n            if (start < 0 && isVisible(pixel)) {\r\n                start = x;\r\n            }\r\n            if (start >= 0 && !isVisible(pixel)) {\r\n                int endY = y + 1;\r\n                boolean sameRow = true;\r\n                while (sameRow && endY < h) {\r\n                    for (int i = 0; i < w; i++) {\r\n                        int px1 = data[y * w + i];\r\n                        int px2 = data[endY * w + i];\r\n                        if (isVisible(px1) != isVisible(px2)) {\r\n                            sameRow = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (sameRow) {\r\n                        endY++;\r\n                    }\r\n                }\r\n                quads.add(genQuad(format, transform, (float) start * wScale, (float) y * hScale, (float) x * wScale, (float) endY * hScale, z, sprite, facing, color, tint));\r\n                if (endY - y > 1) {\r\n                    y = endY - 1;\r\n                }\r\n                start = -1;\r\n            }\r\n        }\r\n    }\r\n    return quads;\r\n}"
}, {
	"Path": "org.springframework.cloud.netflix.turbine.CommonsInstanceDiscovery.marshall",
	"Comment": "private helper that marshals the information from each instance into something that\tturbine can understand. override this method for your own implementation.",
	"Method": "Instance marshall(ServiceInstance serviceInstance){\r\n    String hostname = serviceInstance.getHost();\r\n    String managementPort = serviceInstance.getMetadata().get(\"management.port\");\r\n    String port = managementPort == null ? String.valueOf(serviceInstance.getPort()) : managementPort;\r\n    String cluster = getClusterName(serviceInstance);\r\n    Boolean status = Boolean.TRUE;\r\n    if (hostname != null && cluster != null && status != null) {\r\n        Instance instance = getInstance(hostname, port, cluster, status);\r\n        Map<String, String> metadata = serviceInstance.getMetadata();\r\n        boolean securePortEnabled = serviceInstance.isSecure();\r\n        addMetadata(instance, hostname, port, securePortEnabled, port, metadata);\r\n        return instance;\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "io.restassured.path.json.config.JsonPathConfig.numberReturnType",
	"Comment": "specifies if jsonpath should use floats and doubles or bigdecimals to represent json numbers.",
	"Method": "NumberReturnType numberReturnType(JsonPathConfig numberReturnType,NumberReturnType numberReturnType){\r\n    return new JsonPathConfig(numberReturnType, defaultParserType, gsonObjectMapperFactory, jackson1ObjectMapperFactory, jackson2ObjectMapperFactory, defaultDeserializer, charset);\r\n}"
}, {
	"Path": "io.restassured.matcher.DetailedCookieMatcher.comment",
	"Comment": "verifies whether comment of cookie satisfies specified matcher.",
	"Method": "DetailedCookieMatcher comment(String expectedComment,DetailedCookieMatcher comment,Matcher<? super String> commentMatcher){\r\n    return new DetailedCookieMatcher(and(Matchers.<Cookie>hasProperty(\"comment\", commentMatcher)));\r\n}"
}, {
	"Path": "net.minecraftforge.common.util.RecipeMatcher.claim",
	"Comment": "this is bad... need to think of a better cascade, recursion instead of stack?",
	"Method": "boolean claim(int[] ret,BitSet data,int claimed,int elements){\r\n    Queue<Integer> pending = new LinkedList<Integer>();\r\n    pending.add(claimed);\r\n    while (pending.peek() != null) {\r\n        int test = pending.poll();\r\n        int offset = (test + 2) * elements;\r\n        int used = data.nextSetBit(offset) - offset;\r\n        if (used >= elements || used < 0)\r\n            throw new IllegalStateException(\"What? We matched something, but it wasn't set in the range of this test! Test: \" + test + \" Used: \" + used);\r\n        data.set(used);\r\n        data.set(elements + test);\r\n        ret[used] = test;\r\n        for (int x = 0; x < elements; x++) {\r\n            offset = (x + 2) * elements;\r\n            if (data.get(offset + used) && !data.get(elements + x)) {\r\n                data.clear(offset + used);\r\n                int count = 0;\r\n                for (int y = offset; y < offset + elements; y++) if (data.get(y))\r\n                    count++;\r\n                if (count == 0)\r\n                    return false;\r\n                if (count == 1)\r\n                    pending.add(x);\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "io.restassured.config.HeaderConfig.shouldOverwriteHeaderWithName",
	"Comment": "returns whether or not the specified header should be returned",
	"Method": "boolean shouldOverwriteHeaderWithName(String headerName){\r\n    notNull(headerName, \"Header name\");\r\n    return headersToOverwrite.get(headerName.toUpperCase());\r\n}"
}, {
	"Path": "co.paralleluniverse.fibers.Fiber.unparkSerialized",
	"Comment": "deserializes a fiber from the given byte array and unparks it.",
	"Method": "Fiber<V> unparkSerialized(byte[] serFiber,FiberScheduler scheduler){\r\n    final Fiber<V> f = (Fiber<V>) getFiberSerializer().read(serFiber);\r\n    return unparkDeserialized(f, scheduler);\r\n}"
}, {
	"Path": "io.restassured.matcher.RestAssuredMatchers.matchesDtdInClasspath",
	"Comment": "evaluates to true if an xml file in classpath matches the supplied dtd.",
	"Method": "Matcher<String> matchesDtdInClasspath(String path){\r\n    return XmlDtdMatcher.matchesDtdInClasspath(path);\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.Phaser.badRegister",
	"Comment": "returns message string for bounds exceptions on registration.",
	"Method": "String badRegister(long s){\r\n    return \"Attempt to register more than \" + MAX_PARTIES + \" parties for \" + stateToString(s);\r\n}"
}, {
	"Path": "io.objectbox.query.LazyList.peek",
	"Comment": "like get but does not load the entity if it was not loaded before.",
	"Method": "E peek(int location){\r\n    if (entities != null) {\r\n        return entities.get(location);\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.AbstractQueuedSynchronizer.transferForSignal",
	"Comment": "transfers a node from a condition queue onto sync queue.returns true if successful.",
	"Method": "boolean transferForSignal(Node node){\r\n    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))\r\n        return false;\r\n    Node p = enq(node);\r\n    int ws = p.waitStatus;\r\n    if (ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))\r\n        Strand.unpark(node.strand);\r\n    return true;\r\n}"
}, {
	"Path": "org.reflections.Reflections.getMethodsWithAnyParamAnnotated",
	"Comment": "get methods with any parameter annotated with given annotation, including annotation member values matching",
	"Method": "Set<Method> getMethodsWithAnyParamAnnotated(Class<? extends Annotation> annotation,Set<Method> getMethodsWithAnyParamAnnotated,Annotation annotation){\r\n    return filter(getMethodsWithAnyParamAnnotated(annotation.annotationType()), withAnyParameterAnnotation(annotation));\r\n}"
}, {
	"Path": "net.minecraftforge.common.DungeonHooks.addDungeonMob",
	"Comment": "adds a mob to the possible list of creatures the spawner will create.if the mob is already in the spawn list, the rarity will be added to the existing one,causing the mob to be more common.",
	"Method": "float addDungeonMob(ResourceLocation name,int rarity){\r\n    if (rarity <= 0) {\r\n        throw new IllegalArgumentException(\"Rarity must be greater then zero\");\r\n    }\r\n    for (DungeonMob mob : dungeonMobs) {\r\n        if (name.equals(mob.type)) {\r\n            return mob.itemWeight += rarity;\r\n        }\r\n    }\r\n    dungeonMobs.add(new DungeonMob(rarity, name));\r\n    return rarity;\r\n}"
}, {
	"Path": "net.minecraftforge.client.model.ModelLoaderRegistry.getModel",
	"Comment": "primary method to get imodel instances.resourcelocation argument will be passed directly to the custom model loaders,modelresourcelocation argument will be loaded through the blockstate system.",
	"Method": "IModel getModel(ResourceLocation location){\r\n    IModel model;\r\n    IModel cached = cache.get(location);\r\n    if (cached != null)\r\n        return cached;\r\n    for (ResourceLocation loading : loadingModels) {\r\n        if (location.getClass() == loading.getClass() && location.equals(loading)) {\r\n            throw new LoaderException(\"circular model dependencies, stack: [\" + Joiner.on(\", \").join(loadingModels) + \"]\");\r\n        }\r\n    }\r\n    loadingModels.addLast(location);\r\n    try {\r\n        ResourceLocation aliased = aliases.get(location);\r\n        if (aliased != null)\r\n            return getModel(aliased);\r\n        ResourceLocation actual = getActualLocation(location);\r\n        ICustomModelLoader accepted = null;\r\n        for (ICustomModelLoader loader : loaders) {\r\n            try {\r\n                if (loader.accepts(actual)) {\r\n                    if (accepted != null) {\r\n                        throw new LoaderException(String.format(\"2 loaders (%s and %s) want to load the same model %s\", accepted, loader, location));\r\n                    }\r\n                    accepted = loader;\r\n                }\r\n            } catch (Exception e) {\r\n                throw new LoaderException(String.format(\"Exception checking if model %s can be loaded with loader %s, skipping\", location, loader), e);\r\n            }\r\n        }\r\n        if (accepted == null) {\r\n            if (VariantLoader.INSTANCE.accepts(actual)) {\r\n                accepted = VariantLoader.INSTANCE;\r\n            } else if (VanillaLoader.INSTANCE.accepts(actual)) {\r\n                accepted = VanillaLoader.INSTANCE;\r\n            }\r\n        }\r\n        if (accepted == null) {\r\n            throw new LoaderException(\"no suitable loader found for the model \" + location + \", skipping\");\r\n        }\r\n        try {\r\n            model = accepted.loadModel(actual);\r\n        } catch (Exception e) {\r\n            throw new LoaderException(String.format(\"Exception loading model %s with loader %s, skipping\", location, accepted), e);\r\n        }\r\n        if (model == getMissingModel()) {\r\n            throw new LoaderException(String.format(\"Loader %s returned missing model while loading model %s\", accepted, location));\r\n        }\r\n        if (model == null) {\r\n            throw new LoaderException(String.format(\"Loader %s returned null while loading model %s\", accepted, location));\r\n        }\r\n        textures.addAll(model.getTextures());\r\n    } finally {\r\n        ResourceLocation popLoc = loadingModels.removeLast();\r\n        if (popLoc != location) {\r\n            throw new IllegalStateException(\"Corrupted loading model stack: \" + popLoc + \" != \" + location);\r\n        }\r\n    }\r\n    cache.put(location, model);\r\n    for (ResourceLocation dep : model.getDependencies()) {\r\n        getModelOrMissing(dep);\r\n    }\r\n    return model;\r\n}"
}, {
	"Path": "org.mapdb.jsr166.JSR166TestCase.cloneableClone",
	"Comment": "if o implements cloneable and has a public clone method,returns a clone of o, else null.",
	"Method": "T cloneableClone(T o){\r\n    if (!(o instanceof Cloneable))\r\n        return null;\r\n    final T clone;\r\n    try {\r\n        clone = (T) o.getClass().getMethod(\"clone\").invoke(o);\r\n    } catch (NoSuchMethodException ok) {\r\n        return null;\r\n    } catch (ReflectiveOperationException unexpected) {\r\n        throw new Error(unexpected);\r\n    }\r\n    assertNotSame(o, clone);\r\n    assertSame(o.getClass(), clone.getClass());\r\n    return clone;\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.ReentrantReadWriteLock.getQueueLength",
	"Comment": "returns an estimate of the number of strands waiting to acquireeither the read or write lock.the value is only an estimatebecause the number of strands may change dynamically while thismethod traverses internal data structures.this method isdesigned for use in monitoring of the system state, not forsynchronization control.",
	"Method": "int getQueueLength(){\r\n    return sync.getQueueLength();\r\n}"
}, {
	"Path": "net.minecraftforge.common.config.Property.getBooleanList",
	"Comment": "returns the boolean value of all values that canbe parsed in the list.",
	"Method": "boolean[] getBooleanList(){\r\n    ArrayList<Boolean> tmp = new ArrayList<Boolean>();\r\n    for (String value : values) {\r\n        try {\r\n            tmp.add(Boolean.parseBoolean(value));\r\n        } catch (NumberFormatException e) {\r\n        }\r\n    }\r\n    boolean[] primitives = new boolean[tmp.size()];\r\n    for (int i = 0; i < tmp.size(); i++) {\r\n        primitives[i] = tmp.get(i);\r\n    }\r\n    return primitives;\r\n}"
}, {
	"Path": "net.minecraftforge.common.config.Property.getValidValues",
	"Comment": "gets the array of valid values that this string property can be set to, or null if not defined.",
	"Method": "String[] getValidValues(){\r\n    return this.validValues;\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.ReentrantLock.getWaitQueueLength",
	"Comment": "returns an estimate of the number of strands waiting on thegiven condition associated with this lock. note that becausetimeouts and interrupts may occur at any time, the estimateserves only as an upper bound on the actual number of waiters.this method is designed for use in monitoring of the systemstate, not for synchronization control.",
	"Method": "int getWaitQueueLength(Condition condition){\r\n    if (condition == null)\r\n        throw new NullPointerException();\r\n    if (!(condition instanceof AbstractQueuedSynchronizer.ConditionObject))\r\n        throw new IllegalArgumentException(\"not owner\");\r\n    return sync.getWaitQueueLength((AbstractQueuedSynchronizer.ConditionObject) condition);\r\n}"
}, {
	"Path": "io.restassured.builder.RequestSpecBuilder.setConfig",
	"Comment": "define a configuration for redirection settings and http client parameters.",
	"Method": "RequestSpecBuilder setConfig(RestAssuredConfig config){\r\n    spec.config(config);\r\n    return this;\r\n}"
}, {
	"Path": "net.minecraftforge.fluids.FluidTank.canFillFluidType",
	"Comment": "returns true if the tank can be filled with this type of fluid.used as a filter for fluid types.does not consider the current contents or capacity of the tank,only whether it could ever fill with this type of fluid.",
	"Method": "boolean canFillFluidType(FluidStack fluid){\r\n    return canFill();\r\n}"
}, {
	"Path": "io.restassured.http.Headers.getValue",
	"Comment": "get a single header with the supplied name. if there are several headers match the headername thenthe last one is returned.",
	"Method": "String getValue(String headerName){\r\n    return headers.getValue(headerName);\r\n}"
}, {
	"Path": "net.minecraftforge.client.model.IModel.process",
	"Comment": "allows the model to process custom data from the variant definition.if unknown data is encountered it should be skipped.",
	"Method": "IModel process(ImmutableMap<String, String> customData){\r\n    return this;\r\n}"
}, {
	"Path": "net.minecraftforge.common.config.Property.getLong",
	"Comment": "returns the value in this property as a long,if the value is not a valid long, it will return theprovided default.",
	"Method": "long getLong(long getLong,long _default){\r\n    try {\r\n        return Long.parseLong(value);\r\n    } catch (NumberFormatException e) {\r\n        return _default;\r\n    }\r\n}"
}, {
	"Path": "net.minecraftforge.common.config.Property.getValidationPattern",
	"Comment": "gets the pattern object used to validate user input for this property.",
	"Method": "Pattern getValidationPattern(){\r\n    return this.validationPattern;\r\n}"
}, {
	"Path": "com.uber.nullaway.NullabilityUtil.getFunctionalInterfaceMethod",
	"Comment": "finds the corresponding functional interface method for a lambda expression or method reference",
	"Method": "Symbol.MethodSymbol getFunctionalInterfaceMethod(ExpressionTree tree,Types types){\r\n    Preconditions.checkArgument((tree instanceof LambdaExpressionTree) || (tree instanceof MemberReferenceTree));\r\n    Type funcInterfaceType = ((JCTree.JCFunctionalExpression) tree).type;\r\n    return (Symbol.MethodSymbol) types.findDescriptorSymbol(funcInterfaceType.tsym);\r\n}"
}, {
	"Path": "org.springframework.cloud.netflix.turbine.CommonsInstanceDiscovery.getInstanceList",
	"Comment": "method that queries discoveryclient for a list of configured application names",
	"Method": "Collection<Instance> getInstanceList(){\r\n    List<Instance> instances = new ArrayList();\r\n    List<String> appNames = getApplications();\r\n    if (appNames == null || appNames.size() == 0) {\r\n        log.info(\"No apps configured, returning an empty instance list\");\r\n        return instances;\r\n    }\r\n    log.info(\"Fetching instance list for apps: \" + appNames);\r\n    for (String appName : appNames) {\r\n        try {\r\n            instances.addAll(getInstancesForApp(appName));\r\n        } catch (Exception ex) {\r\n            log.error(\"Failed to fetch instances for app: \" + appName + \", retrying once more\", ex);\r\n            try {\r\n                instances.addAll(getInstancesForApp(appName));\r\n            } catch (Exception retryException) {\r\n                log.error(\"Failed again to fetch instances for app: \" + appName + \", giving up\", ex);\r\n            }\r\n        }\r\n    }\r\n    return instances;\r\n}"
}, {
	"Path": "co.paralleluniverse.common.util.SystemProperties.isEmptyOrTrue",
	"Comment": "returns the value of a system property which defaults to false.",
	"Method": "boolean isEmptyOrTrue(String property){\r\n    final String value = System.getProperty(property);\r\n    if (value == null)\r\n        return false;\r\n    return value.isEmpty() || Boolean.parseBoolean(value);\r\n}"
}, {
	"Path": "org.springframework.cloud.netflix.zuul.filters.route.SimpleHostRoutingFilter.getContentLength",
	"Comment": "get the header value as a long in order to more correctly proxy very large requests",
	"Method": "long getContentLength(HttpServletRequest request){\r\n    if (useServlet31) {\r\n        return request.getContentLengthLong();\r\n    }\r\n    String contentLengthHeader = request.getHeader(HttpHeaders.CONTENT_LENGTH);\r\n    if (contentLengthHeader != null) {\r\n        try {\r\n            return Long.parseLong(contentLengthHeader);\r\n        } catch (NumberFormatException e) {\r\n        }\r\n    }\r\n    return request.getContentLength();\r\n}"
}, {
	"Path": "io.objectbox.rx.RxQuery.flowableOneByOne",
	"Comment": "the returned flowable emits query results one by one. once all results have been processed, oncomplete is called.uses given backpressurestrategy.",
	"Method": "Flowable<T> flowableOneByOne(Query<T> query,Flowable<T> flowableOneByOne,Query<T> query,BackpressureStrategy strategy){\r\n    return Flowable.create(new FlowableOnSubscribe<T>() {\r\n        @Override\r\n        public void subscribe(final FlowableEmitter<T> emitter) throws Exception {\r\n            createListItemEmitter(query, emitter);\r\n        }\r\n    }, strategy);\r\n}"
}, {
	"Path": "io.objectbox.rx.RxQuery.flowableOneByOne",
	"Comment": "the returned flowable emits query results one by one. once all results have been processed, oncomplete is called.uses given backpressurestrategy.",
	"Method": "Flowable<T> flowableOneByOne(Query<T> query,Flowable<T> flowableOneByOne,Query<T> query,BackpressureStrategy strategy){\r\n    createListItemEmitter(query, emitter);\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.AbstractQueuedLongSynchronizer.fullGetFirstQueuedStrand",
	"Comment": "version of getfirstqueuedstrand called when fastpath fails",
	"Method": "Strand fullGetFirstQueuedStrand(){\r\n    Node h, s;\r\n    Strand st;\r\n    if (((h = head) != null && (s = h.next) != null && s.prev == head && (st = s.strand) != null) || ((h = head) != null && (s = h.next) != null && s.prev == head && (st = s.strand) != null))\r\n        return st;\r\n    Node t = tail;\r\n    Strand firstStrand = null;\r\n    while (t != null && t != head) {\r\n        Strand tt = t.strand;\r\n        if (tt != null)\r\n            firstStrand = tt;\r\n        t = t.prev;\r\n    }\r\n    return firstStrand;\r\n}"
}, {
	"Path": "io.restassured.http.Cookie.getPath",
	"Comment": "returns the path attribute of the cookie. the value of the pathattribute specifies the subset of urls on the origin server to whichthis cookie applies.",
	"Method": "String getPath(){\r\n    return path;\r\n}"
}, {
	"Path": "net.minecraftforge.common.config.Property.getDouble",
	"Comment": "returns the value in this property as a double, if the value is not a valid double, it will return the provided default.",
	"Method": "double getDouble(double _default,double getDouble){\r\n    try {\r\n        return Double.parseDouble(value);\r\n    } catch (NumberFormatException e) {\r\n        return Double.parseDouble(defaultValue);\r\n    }\r\n}"
}, {
	"Path": "net.minecraftforge.common.chunkio.ChunkIOExecutor.syncChunkLoad",
	"Comment": "load the chunk completely in this thread. dequeue as needed...",
	"Method": "Chunk syncChunkLoad(World world,AnvilChunkLoader loader,ChunkProviderServer provider,int x,int z){\r\n    QueuedChunk key = new QueuedChunk(x, z, world);\r\n    ChunkIOProvider task = tasks.remove(key);\r\n    if (task != null) {\r\n        if (!pool.remove(task)) {\r\n            synchronized (task) {\r\n                while (!task.runFinished()) {\r\n                    try {\r\n                        task.wait();\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            task.run();\r\n        }\r\n    } else {\r\n        task = new ChunkIOProvider(key, loader, provider);\r\n        task.run();\r\n    }\r\n    task.syncCallback();\r\n    return task.getChunk();\r\n}"
}, {
	"Path": "io.restassured.matcher.DetailedCookieMatcher.maxAge",
	"Comment": "verifies whether max age of cookie satisfies specified matcher.",
	"Method": "DetailedCookieMatcher maxAge(int expectedMaxAgeValue,DetailedCookieMatcher maxAge,Matcher<? super Integer> maxAgeMatcher){\r\n    return new DetailedCookieMatcher(and(Matchers.<Cookie>hasProperty(\"maxAge\", maxAgeMatcher)));\r\n}"
}, {
	"Path": "net.minecraftforge.fml.common.FMLCommonHandler.exitJava",
	"Comment": "used to exit from java, with system exit preventions in place. will be tidy about it and just log a message,unless debugging is enabled",
	"Method": "void exitJava(int exitCode,boolean hardExit){\r\n    FMLLog.log.warn(\"Java has been asked to exit (code {})\", exitCode);\r\n    if (hardExit) {\r\n        FMLLog.log.warn(\"This is an abortive exit and could cause world corruption or other things\");\r\n    }\r\n    StackTraceElement[] stack = Thread.currentThread().getStackTrace();\r\n    FMLLog.log.warn(\"Exit trace:\");\r\n    for (int i = 2; i < stack.length; i++) {\r\n        FMLLog.log.warn(\"\\t{}\", stack[i]);\r\n    }\r\n    if (hardExit) {\r\n        Runtime.getRuntime().halt(exitCode);\r\n    } else {\r\n        Runtime.getRuntime().exit(exitCode);\r\n    }\r\n}"
}, {
	"Path": "io.restassured.config.ConnectionConfig.closeIdleConnectionsAfterEachResponseAfter",
	"Comment": "close open connections that have idled for the amount of time specified in this config after each response.",
	"Method": "ConnectionConfig closeIdleConnectionsAfterEachResponseAfter(long idleTime,TimeUnit timeUnit,ConnectionConfig closeIdleConnectionsAfterEachResponseAfter,CloseIdleConnectionConfig closeIdleConnectionConfig){\r\n    return new ConnectionConfig(closeIdleConnectionConfig);\r\n}"
}, {
	"Path": "co.paralleluniverse.actors.behaviors.EventSource.notify",
	"Comment": "sends an event to the actor, which will be delivered to all registered event handlers.",
	"Method": "void notify(Event event){\r\n    send(event);\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.Timeout.timeLeft",
	"Comment": "returns how long is left before the timeout expires in the given time unit.",
	"Method": "long timeLeft(TimeUnit unit){\r\n    return unit.convert(nanosLeft(), TimeUnit.NANOSECONDS);\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.Phaser.awaitAdvance",
	"Comment": "awaits the phase of this phaser to advance from the given phasevalue, returning immediately if the current phase is not equalto the given phase value or this phaser is terminated.",
	"Method": "int awaitAdvance(int phase){\r\n    try {\r\n        final Phaser root = this.root;\r\n        long s = (root == this) ? state : reconcileState();\r\n        int p = (int) (s >>> PHASE_SHIFT);\r\n        if (phase < 0)\r\n            return phase;\r\n        if (p == phase)\r\n            return root.internalAwaitAdvance(phase, null);\r\n        return p;\r\n    } catch (SuspendExecution e) {\r\n        throw new AssertionError(e);\r\n    }\r\n}"
}, {
	"Path": "io.restassured.module.mockmvc.RestAssuredMockMvc.patch",
	"Comment": "perform a patch request to the statically configured base path.",
	"Method": "MockMvcResponse patch(String path,Object pathParams,MockMvcResponse patch,String path,Map<String, ?> pathParams,MockMvcResponse patch,URI uri,MockMvcResponse patch,URL url,MockMvcResponse patch){\r\n    return given().patch();\r\n}"
}, {
	"Path": "net.minecraftforge.client.model.IModel.getTextures",
	"Comment": "returns all texture locations that this model depends on.assume that returned collection is immutable.",
	"Method": "Collection<ResourceLocation> getTextures(){\r\n    return ImmutableList.of();\r\n}"
}, {
	"Path": "io.socket.client.Socket.id",
	"Comment": "a property on the socket instance that is equal to the underlying engine.io socket id.the value is present once the socket has connected, is removed when the socket disconnects and is updated if the socket reconnects.",
	"Method": "String id(){\r\n    return this.id;\r\n}"
}, {
	"Path": "net.minecraftforge.fluids.FluidRegistry.registerFluid",
	"Comment": "register a new fluid. if a fluid with the same name already exists, registration the alternative fluid is trackedin case it is the default in another place",
	"Method": "boolean registerFluid(Fluid fluid){\r\n    masterFluidReference.put(uniqueName(fluid), fluid);\r\n    delegates.put(fluid, new FluidDelegate(fluid, fluid.getName()));\r\n    if (fluids.containsKey(fluid.getName())) {\r\n        return false;\r\n    }\r\n    fluids.put(fluid.getName(), fluid);\r\n    maxID++;\r\n    fluidIDs.put(fluid, maxID);\r\n    fluidNames.put(maxID, fluid.getName());\r\n    defaultFluidName.put(fluid.getName(), uniqueName(fluid));\r\n    MinecraftForge.EVENT_BUS.post(new FluidRegisterEvent(fluid.getName(), maxID));\r\n    return true;\r\n}"
}, {
	"Path": "io.restassured.path.xml.XmlPath.using",
	"Comment": "configure xmlpath to use a specific jaxb object mapper factory",
	"Method": "XmlPath using(JAXBObjectMapperFactory factory,XmlPath using,XmlPathConfig config){\r\n    return new XmlPath(this, config);\r\n}"
}, {
	"Path": "org.springframework.security.cas.web.authentication.DefaultServiceAuthenticationDetails.getQueryString",
	"Comment": "if present, removes the artifactparametername and the corresponding value from the\tquery string.",
	"Method": "String getQueryString(HttpServletRequest request,Pattern artifactPattern){\r\n    final String query = request.getQueryString();\r\n    if (query == null) {\r\n        return null;\r\n    }\r\n    final String result = artifactPattern.matcher(query).replaceFirst(\"\");\r\n    if (result.length() == 0) {\r\n        return null;\r\n    }\r\n    return result.startsWith(\"&\") ? result.substring(1) : result;\r\n}"
}, {
	"Path": "org.nanohttpd.protocols.http.HTTPSession.findHeaderEnd",
	"Comment": "find byte index separating header from body. it must be the last byte ofthe first two sequential new lines.",
	"Method": "int findHeaderEnd(byte[] buf,int rlen){\r\n    int splitbyte = 0;\r\n    while (splitbyte + 1 < rlen) {\r\n        if (buf[splitbyte] == '\\r' && buf[splitbyte + 1] == '\\n' && splitbyte + 3 < rlen && buf[splitbyte + 2] == '\\r' && buf[splitbyte + 3] == '\\n') {\r\n            return splitbyte + 4;\r\n        }\r\n        if (buf[splitbyte] == '\\n' && buf[splitbyte + 1] == '\\n') {\r\n            return splitbyte + 2;\r\n        }\r\n        splitbyte++;\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "io.restassured.authentication.CertificateAuthSettings.allowAllHostnames",
	"Comment": "configure the certificateauthsettings to allow all host names.",
	"Method": "CertificateAuthSettings allowAllHostnames(){\r\n    return new CertificateAuthSettings(keystoreType, trustStoreType, port, trustStore, keyStore, ALLOW_ALL_HOSTNAME_VERIFIER, sslSocketFactory);\r\n}"
}, {
	"Path": "com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean.setTypeAliasesSuperType",
	"Comment": "super class which domain objects have to extend to have a type alias created.no effect if there is no package to scan configured.",
	"Method": "void setTypeAliasesSuperType(Class<?> typeAliasesSuperType){\r\n    this.typeAliasesSuperType = typeAliasesSuperType;\r\n}"
}, {
	"Path": "io.restassured.path.xml.XmlPath.getList",
	"Comment": "get the result of an xml path expression as a list. for syntax details please refer tothis url.",
	"Method": "List<T> getList(String path,List<T> getList,String path,Class<T> genericType){\r\n    return getAsList(path, genericType);\r\n}"
}, {
	"Path": "net.minecraftforge.server.timings.TimeTracker.enable",
	"Comment": "starts recording tracking data for the given duration in seconds",
	"Method": "void enable(int duration){\r\n    this.trackingDuration = duration;\r\n    this.enabled = true;\r\n}"
}, {
	"Path": "io.restassured.path.xml.config.XmlPathConfig.isAllowDocTypeDeclaration",
	"Comment": "whether xmlpath should provide support for doctype declarations",
	"Method": "boolean isAllowDocTypeDeclaration(){\r\n    return allowDocTypeDeclaration;\r\n}"
}, {
	"Path": "net.minecraftforge.client.model.ModelLoader.defaultTextureGetter",
	"Comment": "get the default texture getter the models will be baked with.",
	"Method": "Function<ResourceLocation, TextureAtlasSprite> defaultTextureGetter(){\r\n    return DefaultTextureGetter.INSTANCE;\r\n}"
}, {
	"Path": "io.restassured.module.webtestclient.matcher.RestAssuredWebTestClientMatchers.matchesDtdInClasspath",
	"Comment": "evaluates to true if an xml file in classpath matches the supplied dtd.",
	"Method": "Matcher<String> matchesDtdInClasspath(String path){\r\n    return XmlDtdMatcher.matchesDtdInClasspath(path);\r\n}"
}, {
	"Path": "co.paralleluniverse.fibers.Fiber.getUncaughtExceptionHandler",
	"Comment": "returns the handler invoked when this fiber abruptly terminatesdue to an uncaught exception.",
	"Method": "UncaughtExceptionHandler getUncaughtExceptionHandler(){\r\n    return uncaughtExceptionHandler;\r\n}"
}, {
	"Path": "co.paralleluniverse.actors.Actor.tryReceive",
	"Comment": "retrieves a message from the mailbox if one is available. this method never blocks.",
	"Method": "Message tryReceive(){\r\n    for (; ; ) {\r\n        checkThrownIn0();\r\n        Object m = mailbox().tryReceive();\r\n        if (m == null)\r\n            return null;\r\n        record(1, \"Actor\", \"tryReceive\", \"Received %s <- %s\", this, m);\r\n        monitorAddMessage();\r\n        Message msg = filterMessage(m);\r\n        if (msg != null)\r\n            return msg;\r\n    }\r\n}"
}, {
	"Path": "net.minecraftforge.common.config.Property.getConfigEntryClass",
	"Comment": "gets the custom iconfigentry class that should be used in place of the standard entry class for this property type, or null ifnone has been set.",
	"Method": "Class<? extends IConfigEntry> getConfigEntryClass(){\r\n    return this.configEntryClass;\r\n}"
}, {
	"Path": "org.mapdb.io.DataIO.JVMSupportsLargeMappedFiles",
	"Comment": "check if large files can be mapped into memory.for example 32bit jvm can only address 2gb and large files can not be mapped,so for 32bit jvm this function returns false.",
	"Method": "boolean JVMSupportsLargeMappedFiles(){\r\n    String arch = System.getProperty(\"os.arch\");\r\n    if (arch == null || !arch.contains(\"64\")) {\r\n        return false;\r\n    }\r\n    if (isWindows())\r\n        return false;\r\n    return true;\r\n}"
}, {
	"Path": "org.mapdb.jsr166.LinkedBlockingDequeTest.testAddAll5",
	"Comment": "deque contains all elements, in traversal order, of successful addall",
	"Method": "void testAddAll5(){\r\n    Integer[] empty = new Integer[0];\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE; ++i) ints[i] = new Integer(i);\r\n    BlockingDeque q = new LinkedBlockingDeque(SIZE);\r\n    assertFalse(q.addAll(Arrays.asList(empty)));\r\n    assertTrue(q.addAll(Arrays.asList(ints)));\r\n    for (int i = 0; i < SIZE; ++i) assertEquals(ints[i], q.poll());\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.AbstractQueuedLongSynchronizer.transferForSignal",
	"Comment": "transfers a node from a condition queue onto sync queue.returns true if successful.",
	"Method": "boolean transferForSignal(Node node){\r\n    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))\r\n        return false;\r\n    Node p = enq(node);\r\n    int ws = p.waitStatus;\r\n    if (ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))\r\n        Strand.unpark(node.strand);\r\n    return true;\r\n}"
}, {
	"Path": "com.uber.nullaway.NullAway.getClosestOverriddenMethod",
	"Comment": "find the closest ancestor method in a superclass or superinterface that method overrides",
	"Method": "Symbol.MethodSymbol getClosestOverriddenMethod(Symbol.MethodSymbol method,Types types){\r\n    Symbol.ClassSymbol owner = method.enclClass();\r\n    for (Type s : types.closure(owner.type)) {\r\n        if (s.equals(owner.type)) {\r\n            continue;\r\n        }\r\n        for (Symbol m : s.tsym.members().getSymbolsByName(method.name)) {\r\n            if (!(m instanceof Symbol.MethodSymbol)) {\r\n                continue;\r\n            }\r\n            Symbol.MethodSymbol msym = (Symbol.MethodSymbol) m;\r\n            if (msym.isStatic()) {\r\n                continue;\r\n            }\r\n            if (method.overrides(msym, owner, types, false)) {\r\n                return msym;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.mapdb.jsr166.LinkedBlockingDequeTest.testAddAll3",
	"Comment": "addall of a collection with any null elements throws npe afterpossibly adding some elements",
	"Method": "void testAddAll3(){\r\n    BlockingDeque q = new LinkedBlockingDeque(SIZE);\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE - 1; ++i) ints[i] = new Integer(i);\r\n    Collection<Integer> elements = Arrays.asList(ints);\r\n    try {\r\n        q.addAll(elements);\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "net.minecraftforge.fml.server.FMLServerHandler.finishServerLoading",
	"Comment": "called a bit later on during server initialization to finish loading mods",
	"Method": "void finishServerLoading(){\r\n    Loader.instance().initializeMods();\r\n}"
}, {
	"Path": "io.restassured.config.DecoderConfig.noContentDecoders",
	"Comment": "specify that no content decoders should be used by rest assured.",
	"Method": "DecoderConfig noContentDecoders(){\r\n    return new DecoderConfig(defaultContentCharset, useNoWrapForInflateDecoding, true, contentTypeToDefaultCharset);\r\n}"
}, {
	"Path": "net.minecraftforge.oredict.OreDictionary.getOreIDs",
	"Comment": "gets all the integer id for the ores that the specified item stack is registered to.if the item stack is not linked to any ore, this will return an empty array and no new entry will be created.",
	"Method": "int[] getOreIDs(ItemStack stack){\r\n    if (stack.isEmpty())\r\n        throw new IllegalArgumentException(\"Stack can not be invalid!\");\r\n    Set<Integer> set = new HashSet<Integer>();\r\n    ResourceLocation registryName = stack.getItem().delegate.name();\r\n    int id;\r\n    if (registryName == null) {\r\n        FMLLog.log.debug(\"Attempted to find the oreIDs for an unregistered object ({}). This won't work very well.\", stack);\r\n        return new int[0];\r\n    } else {\r\n        id = Item.REGISTRY.getIDForObject(stack.getItem().delegate.get());\r\n    }\r\n    List<Integer> ids = stackToId.get(id);\r\n    if (ids != null)\r\n        set.addAll(ids);\r\n    ids = stackToId.get(id | ((stack.getItemDamage() + 1) << 16));\r\n    if (ids != null)\r\n        set.addAll(ids);\r\n    Integer[] tmp = set.toArray(new Integer[set.size()]);\r\n    int[] ret = new int[tmp.length];\r\n    for (int x = 0; x < tmp.length; x++) ret[x] = tmp[x];\r\n    return ret;\r\n}"
}, {
	"Path": "org.springframework.security.cas.web.CasAuthenticationFilter.serviceTicketRequest",
	"Comment": "indicates if the request is elgible to process a service ticket. this method exists\tfor readability.",
	"Method": "boolean serviceTicketRequest(HttpServletRequest request,HttpServletResponse response){\r\n    boolean result = super.requiresAuthentication(request, response);\r\n    if (logger.isDebugEnabled()) {\r\n        logger.debug(\"serviceTicketRequest = \" + result);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "io.restassured.config.LogConfig.enablePrettyPrinting",
	"Comment": "specify a whether or not to enable pretty printing by default.",
	"Method": "LogConfig enablePrettyPrinting(boolean shouldEnable){\r\n    return new LogConfig(defaultPrintStream, shouldEnable, logDetailIfValidationFails, urlEncodeRequestUri, true);\r\n}"
}, {
	"Path": "com.uber.nullaway.jarinfer.CompilerUtil.addSourceFile",
	"Comment": "adds a source file to the test compilation, from an existing resource file.",
	"Method": "CompilerUtil addSourceFile(String path){\r\n    this.sources.add(fileManager.forResource(path));\r\n    return this;\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.Timeout.nanosLeft",
	"Comment": "returns how many nanoseconds are left before the timeout expires,or a negative number indicating how many nanoseconds have elapsed sincethe timeout expired.",
	"Method": "long nanosLeft(){\r\n    return deadline - System.nanoTime();\r\n}"
}, {
	"Path": "net.minecraftforge.event.entity.player.CriticalHitEvent.getOldDamageModifier",
	"Comment": "the orignal damage modifier for the hit wthout any changes. this is 1.5f for ciritcal hits and 1f for normal hits .",
	"Method": "float getOldDamageModifier(){\r\n    return this.oldDamageModifier;\r\n}"
}, {
	"Path": "co.paralleluniverse.concurrent.util.ConcurrentSkipListPriorityQueue.doPut",
	"Comment": "main insertion method. adds element if not present, orreplaces value if present and onlyifabsent is false.",
	"Method": "void doPut(E kkey){\r\n    Comparable<? super E> key = comparable(kkey);\r\n    for (; ; ) {\r\n        Node<E> b = findPredecessor(key);\r\n        Node<E> n = b.next;\r\n        for (; ; ) {\r\n            if (n != null) {\r\n                Node<E> f = n.next;\r\n                if (n != b.next)\r\n                    break;\r\n                Object v = n.value;\r\n                if (v == null) {\r\n                    n.helpDelete(b, f);\r\n                    break;\r\n                }\r\n                if (v == n || b.value == null)\r\n                    break;\r\n                int c = key.compareTo(n.key);\r\n                if (c >= 0) {\r\n                    b = n;\r\n                    n = f;\r\n                    continue;\r\n                }\r\n            }\r\n            Node<E> z = new Node<E>(kkey, n);\r\n            if (!b.casNext(n, z))\r\n                break;\r\n            int level = randomLevel();\r\n            if (level > 0)\r\n                insertIndex(z, level);\r\n            return;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.restassured.builder.RequestSpecBuilder.setAuthentication",
	"Comment": "if you need to specify some credentials when performing a request.",
	"Method": "RequestSpecBuilder setAuthentication(AuthenticationScheme auth){\r\n    spec.setAuthenticationScheme(auth);\r\n    return this;\r\n}"
}, {
	"Path": "net.minecraftforge.common.config.ConfigCategory.setShowInGui",
	"Comment": "sets whether or not this configcategory should be allowed to show on config guis.defaults to true.",
	"Method": "ConfigCategory setShowInGui(boolean showInGui){\r\n    this.showInGui = showInGui;\r\n    return this;\r\n}"
}, {
	"Path": "org.mapdb.io.DataOutput2ByteArray.ensureAvail",
	"Comment": "make sure there will be enough space in buffer to write n bytes",
	"Method": "void ensureAvail(int n){\r\n    n += pos;\r\n    if ((n & sizeMask) != 0) {\r\n        grow(n);\r\n    }\r\n}"
}, {
	"Path": "org.reflections.Reflections.getConstructorsAnnotatedWith",
	"Comment": "get all constructors annotated with a given annotation, including annotation member values matchingdepends on methodannotationsscanner configured",
	"Method": "Set<Constructor> getConstructorsAnnotatedWith(Class<? extends Annotation> annotation,Set<Constructor> getConstructorsAnnotatedWith,Annotation annotation){\r\n    return filter(getConstructorsAnnotatedWith(annotation.annotationType()), withAnnotation(annotation));\r\n}"
}, {
	"Path": "io.restassured.matcher.DetailedCookieMatcher.value",
	"Comment": "verifies whether value of cookie satisfies specified matcher.",
	"Method": "DetailedCookieMatcher value(String expectedValue,DetailedCookieMatcher value,Matcher<? super String> valueMatcher){\r\n    return new DetailedCookieMatcher(and(Matchers.<Cookie>hasProperty(\"value\", valueMatcher)));\r\n}"
}, {
	"Path": "net.minecraftforge.fml.common.ProgressManager.push",
	"Comment": "not a fully fleshed out api, may change in future mc versions.however feel free to use and suggest additions.",
	"Method": "ProgressBar push(String title,int steps,ProgressBar push,String title,int steps,boolean timeEachStep){\r\n    ProgressBar bar = new ProgressBar(title, steps);\r\n    bars.add(bar);\r\n    if (timeEachStep) {\r\n        bar.timeEachStep();\r\n    }\r\n    FMLCommonHandler.instance().processWindowMessages();\r\n    return bar;\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.CyclicBarrier.getNumberWaiting",
	"Comment": "returns the number of parties currently waiting at the barrier.this method is primarily useful for debugging and assertions.",
	"Method": "int getNumberWaiting(){\r\n    final ReentrantLock lock = this.lock;\r\n    lock.lock();\r\n    try {\r\n        return parties - count;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "io.restassured.module.jsv.JsonSchemaValidator.matchesJsonSchemaInClasspath",
	"Comment": "creates a hamcrest matcher that validates that a json document conforms to the json schema provided to this method.",
	"Method": "JsonSchemaValidator matchesJsonSchemaInClasspath(String pathToSchemaInClasspath){\r\n    return matchesJsonSchema(Thread.currentThread().getContextClassLoader().getResource(pathToSchemaInClasspath));\r\n}"
}, {
	"Path": "io.restassured.module.webtestclient.specification.WebTestClientRequestSpecBuilder.setBody",
	"Comment": "specify an object request content that will automatically be serialized to json or xml and sent with the request.\tif the object is a primitive or number the object will\tbe converted to a string and put in the request body. this works for the post, put and patch methods only.\ttrying to do this for the other http methods will cause an exception to be thrown.",
	"Method": "WebTestClientRequestSpecBuilder setBody(String body,WebTestClientRequestSpecBuilder setBody,byte[] body,WebTestClientRequestSpecBuilder setBody,Object object,WebTestClientRequestSpecBuilder setBody,Object object,ObjectMapper mapper,WebTestClientRequestSpecBuilder setBody,Object object,ObjectMapperType mapperType){\r\n    spec.body(object, mapperType);\r\n    return this;\r\n}"
}, {
	"Path": "net.minecraftforge.client.model.IModel.getDefaultState",
	"Comment": "default state this model will be baked with.see imodelstate.",
	"Method": "IModelState getDefaultState(){\r\n    return TRSRTransformation.identity();\r\n}"
}, {
	"Path": "io.restassured.path.xml.config.XmlPathConfig.defaultParserType",
	"Comment": "creates an xml path configuration that uses the specified parser type as default.",
	"Method": "XmlParserType defaultParserType(XmlPathConfig defaultParserType,XmlParserType defaultParserType){\r\n    return new XmlPathConfig(jaxbObjectMapperFactory, defaultParserType, defaultDeserializer, charset, features, declaredNamespaces, properties, validating, namespaceAware, allowDocTypeDeclaration);\r\n}"
}, {
	"Path": "io.restassured.path.xml.XmlPath.getByte",
	"Comment": "get the result of an xml path expression as a byte. for syntax details please refer tothis url.",
	"Method": "byte getByte(String path){\r\n    Object object = get(path);\r\n    return convertObjectTo(object, Byte.class);\r\n}"
}, {
	"Path": "io.restassured.http.Headers.get",
	"Comment": "get a single header with the supplied name. if there are several headers match the headername thenthe last one is returned.",
	"Method": "Header get(String headerName){\r\n    notNull(headerName, \"Header name\");\r\n    return headers.get(headerName);\r\n}"
}, {
	"Path": "net.minecraftforge.oredict.OreDictionary.getOreID",
	"Comment": "gets the integer id for the specified ore name.if the name does not have a id it assigns it a new one.",
	"Method": "int getOreID(String name){\r\n    Integer val = nameToId.get(name);\r\n    if (val == null) {\r\n        idToName.add(name);\r\n        val = idToName.size() - 1;\r\n        nameToId.put(name, val);\r\n        NonNullList<ItemStack> back = NonNullList.create();\r\n        idToStack.add(back);\r\n        idToStackUn.add(back);\r\n    }\r\n    return val;\r\n}"
}, {
	"Path": "org.springframework.security.config.annotation.AbstractConfiguredSecurityBuilder.getSharedObject",
	"Comment": "gets a shared object. note that object heirarchies are not considered.",
	"Method": "C getSharedObject(Class<C> sharedType){\r\n    return (C) this.sharedObjects.get(sharedType);\r\n}"
}, {
	"Path": "co.paralleluniverse.actors.Actor.monitor",
	"Comment": "starts a monitor that exposes information about this actor via a jmx mbean.",
	"Method": "ActorMonitor monitor(){\r\n    if (monitor != null)\r\n        return monitor;\r\n    final String name = getName().replaceAll(\":\", \"\");\r\n    this.monitor = new JMXActorMonitor(name);\r\n    monitor.setActor(ref);\r\n    return monitor;\r\n}"
}, {
	"Path": "io.restassured.matcher.DetailedCookieMatcher.version",
	"Comment": "verifies whether version of cookie satisfies specified matcher.",
	"Method": "DetailedCookieMatcher version(int expectedVersionValue,DetailedCookieMatcher version,Matcher<? super Integer> versionMatcher){\r\n    return new DetailedCookieMatcher(and(Matchers.<Cookie>hasProperty(\"version\", versionMatcher)));\r\n}"
}, {
	"Path": "net.minecraftforge.common.ForgeChunkManager.requestTicket",
	"Comment": "request a chunkloading ticket of the appropriate type for the supplied mod",
	"Method": "Ticket requestTicket(Object mod,World world,Type type){\r\n    ModContainer container = getContainer(mod);\r\n    if (container == null) {\r\n        FMLLog.log.error(\"Failed to locate the container for mod instance {} ({} : {})\", mod, mod.getClass().getName(), Integer.toHexString(System.identityHashCode(mod)));\r\n        return null;\r\n    }\r\n    String modId = container.getModId();\r\n    if (!callbacks.containsKey(modId)) {\r\n        FMLLog.log.fatal(\"The mod {} has attempted to request a ticket without a listener in place\", modId);\r\n        throw new RuntimeException(\"Invalid ticket request\");\r\n    }\r\n    int allowedCount = getMaxTicketLengthFor(modId);\r\n    if (tickets.get(world).get(modId).size() >= allowedCount) {\r\n        if (!warnedMods.contains(modId)) {\r\n            FMLLog.log.info(\"The mod {} has attempted to allocate a chunkloading ticket beyond it's currently allocated maximum: {}\", modId, allowedCount);\r\n            warnedMods.add(modId);\r\n        }\r\n        return null;\r\n    }\r\n    Ticket ticket = new Ticket(modId, type, world);\r\n    tickets.get(world).put(modId, ticket);\r\n    return ticket;\r\n}"
}, {
	"Path": "org.reflections.Reflections.getConstructorsWithAnyParamAnnotated",
	"Comment": "get constructors with any parameter annotated with given annotation, including annotation member values matching",
	"Method": "Set<Constructor> getConstructorsWithAnyParamAnnotated(Class<? extends Annotation> annotation,Set<Constructor> getConstructorsWithAnyParamAnnotated,Annotation annotation){\r\n    return filter(getConstructorsWithAnyParamAnnotated(annotation.annotationType()), withAnyParameterAnnotation(annotation));\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.StampedLock.tryConvertToWriteLock",
	"Comment": "if the lock state matches the given stamp, performs one ofthe following actions. if the stamp represents holding a writelock, returns it. or, if a read lock, if the write lock isavailable, releases the read lock and returns a write stamp.or, if an optimistic read, returns a write stamp only ifimmediately available. this method returns zero in all othercases.",
	"Method": "long tryConvertToWriteLock(long stamp){\r\n    long a = stamp & ABITS, m, s, next;\r\n    while (((s = state) & SBITS) == (stamp & SBITS)) {\r\n        if ((m = s & ABITS) == 0L) {\r\n            if (a != 0L)\r\n                break;\r\n            if (STATE.compareAndSet(this, s, next = s + WBIT))\r\n                return next;\r\n        } else if (m == WBIT) {\r\n            if (a != m)\r\n                break;\r\n            return stamp;\r\n        } else if (m == RUNIT && a != 0L) {\r\n            if (STATE.compareAndSet(this, s, next = s - RUNIT + WBIT))\r\n                return next;\r\n        } else\r\n            break;\r\n    }\r\n    return 0L;\r\n}"
}, {
	"Path": "org.springframework.security.config.annotation.web.builders.WebSecurity.postBuildAction",
	"Comment": "executes the runnable immediately after the build takes place",
	"Method": "WebSecurity postBuildAction(Runnable postBuildAction){\r\n    this.postBuildAction = postBuildAction;\r\n    return this;\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.StampedLock.unlockWrite",
	"Comment": "if the lock state matches the given stamp, releases theexclusive lock.",
	"Method": "void unlockWrite(long stamp){\r\n    WNode h;\r\n    if (state != stamp || (stamp & WBIT) == 0L)\r\n        throw new IllegalMonitorStateException();\r\n    state = (stamp += WBIT) == 0L ? ORIGIN : stamp;\r\n    if ((h = whead) != null && h.status != 0)\r\n        release(h);\r\n}"
}, {
	"Path": "org.mapdb.jsr166.LinkedBlockingDequeTest.testBlockingTakeFirst",
	"Comment": "takefirst removes existing elements until empty, then blocks interruptibly",
	"Method": "void testBlockingTakeFirst(){\r\n    final BlockingDeque q = populatedDeque(SIZE);\r\n    final CountDownLatch pleaseInterrupt = new CountDownLatch(1);\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            for (int i = 0; i < SIZE; i++) assertEquals(i, q.takeFirst());\r\n            Thread.currentThread().interrupt();\r\n            try {\r\n                q.takeFirst();\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n            }\r\n            assertFalse(Thread.interrupted());\r\n            pleaseInterrupt.countDown();\r\n            try {\r\n                q.takeFirst();\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n            }\r\n            assertFalse(Thread.interrupted());\r\n        }\r\n    });\r\n    await(pleaseInterrupt);\r\n    assertThreadBlocks(t, Thread.State.WAITING);\r\n    t.interrupt();\r\n    awaitTermination(t);\r\n}"
}, {
	"Path": "org.mapdb.jsr166.LinkedBlockingDequeTest.testBlockingTakeFirst",
	"Comment": "takefirst removes existing elements until empty, then blocks interruptibly",
	"Method": "void testBlockingTakeFirst(){\r\n    for (int i = 0; i < SIZE; i++) assertEquals(i, q.takeFirst());\r\n    Thread.currentThread().interrupt();\r\n    try {\r\n        q.takeFirst();\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n    }\r\n    assertFalse(Thread.interrupted());\r\n    pleaseInterrupt.countDown();\r\n    try {\r\n        q.takeFirst();\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n    }\r\n    assertFalse(Thread.interrupted());\r\n}"
}, {
	"Path": "io.objectbox.query.PropertyQuery.max",
	"Comment": "finds the maximum value for the given property over all objects matching the query.",
	"Method": "long max(){\r\n    return (Long) query.callInReadTx(new Callable<Long>() {\r\n        @Override\r\n        public Long call() {\r\n            return nativeMax(queryHandle, query.cursorHandle(), propertyId);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "io.objectbox.query.PropertyQuery.max",
	"Comment": "finds the maximum value for the given property over all objects matching the query.",
	"Method": "long max(){\r\n    return nativeMax(queryHandle, query.cursorHandle(), propertyId);\r\n}"
}, {
	"Path": "co.paralleluniverse.fibers.instrument.SuspendablesScanner.scanSuspendablesFile",
	"Comment": "visits classes whose methods are found in the suspendables file, as if they were part of the project",
	"Method": "void scanSuspendablesFile(Function<InputStream, Void> classFileVisitor){\r\n    if (suspendablesFile != null) {\r\n        SimpleSuspendableClassifier tssc = new SimpleSuspendableClassifier(suspendablesFile);\r\n        final Set<String> cs = new HashSet();\r\n        cs.addAll(tssc.getSuspendableClasses());\r\n        for (String susMethod : tssc.getSuspendables()) cs.add(susMethod.substring(0, susMethod.indexOf('.')));\r\n        for (String className : cs) {\r\n            try {\r\n                log(\"Scanning suspendable class:\" + className, Project.MSG_VERBOSE);\r\n                classFileVisitor.apply(cl.getResourceAsStream(classToResource(className)));\r\n            } catch (Exception e) {\r\n                throw new RuntimeException(\"Exception while processing \" + className, e);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.AbstractQueuedLongSynchronizer.transferAfterCancelledWait",
	"Comment": "transfers node, if necessary, to sync queue after a cancelled wait.returns true if strand was cancelled before being signalled.",
	"Method": "boolean transferAfterCancelledWait(Node node){\r\n    if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) {\r\n        enq(node);\r\n        return true;\r\n    }\r\n    while (!isOnSyncQueue(node)) Strand.yield();\r\n    return false;\r\n}"
}, {
	"Path": "io.restassured.module.mockmvc.RestAssuredMockMvc.head",
	"Comment": "perform a head request to the statically configured base path.",
	"Method": "MockMvcResponse head(String path,Object pathParams,MockMvcResponse head,String path,Map<String, ?> pathParams,MockMvcResponse head,URI uri,MockMvcResponse head,URL url,MockMvcResponse head){\r\n    return given().head();\r\n}"
}, {
	"Path": "net.minecraftforge.common.config.ConfigCategory.size",
	"Comment": "map bouncer functions for compatibility with older mods, to be removed once all mods stop using it.",
	"Method": "int size(){\r\n    return properties.size();\r\n}"
}, {
	"Path": "io.restassured.module.mockmvc.specification.MockMvcRequestSpecBuilder.setBody",
	"Comment": "specify an object request content that will automatically be serialized to json or xml and sent with the request.if the object is a primitive or number the object willbe converted to a string and put in the request body. this works for the post, put and patch methods only.trying to do this for the other http methods will cause an exception to be thrown.",
	"Method": "MockMvcRequestSpecBuilder setBody(String body,MockMvcRequestSpecBuilder setBody,byte[] body,MockMvcRequestSpecBuilder setBody,Object object,MockMvcRequestSpecBuilder setBody,Object object,ObjectMapper mapper,MockMvcRequestSpecBuilder setBody,Object object,ObjectMapperType mapperType){\r\n    spec.body(object, mapperType);\r\n    return this;\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.channels.TransferChannel.countOfMode",
	"Comment": "traverses and counts unmatched nodes of the given mode.used by methods size and getwaitingconsumercount.",
	"Method": "int countOfMode(boolean data){\r\n    int count = 0;\r\n    for (Node p = head; p != null; ) {\r\n        if (!p.isMatched()) {\r\n            if (p.isData != data)\r\n                return 0;\r\n            if (++count == Integer.MAX_VALUE)\r\n                break;\r\n        }\r\n        Node n = p.next;\r\n        if (n != p)\r\n            p = n;\r\n        else {\r\n            count = 0;\r\n            p = head;\r\n        }\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "io.restassured.module.mockmvc.RestAssuredMockMvc.get",
	"Comment": "perform a get request to the statically configured base path.",
	"Method": "MockMvcResponse get(String path,Object pathParams,MockMvcResponse get,String path,Map<String, ?> pathParams,MockMvcResponse get,URI uri,MockMvcResponse get,URL url,MockMvcResponse get){\r\n    return given().get();\r\n}"
}, {
	"Path": "com.mcxiaoke.packer.cli.Options.getOptionalBooleanValue",
	"Comment": "gets the value of the current boolean option. boolean options are not required to haveexplicitly specified values.",
	"Method": "boolean getOptionalBooleanValue(boolean defaultValue){\r\n    if (lastOptionValue != null) {\r\n        String stringValue = lastOptionValue;\r\n        lastOptionValue = null;\r\n        if (\"true\".equals(stringValue)) {\r\n            return true;\r\n        } else if (\"false\".equals(stringValue)) {\r\n            return false;\r\n        }\r\n        throw new OptionsException(\"Unsupported value for \" + lastOptionOriginalForm + \": \" + stringValue + \". Only true or false supported.\");\r\n    }\r\n    if (index >= params.length) {\r\n        return defaultValue;\r\n    }\r\n    String stringValue = params[index];\r\n    if (\"true\".equals(stringValue)) {\r\n        index++;\r\n        return true;\r\n    } else if (\"false\".equals(stringValue)) {\r\n        index++;\r\n        return false;\r\n    } else {\r\n        return defaultValue;\r\n    }\r\n}"
}, {
	"Path": "org.reflections.Reflections.getFieldsAnnotatedWith",
	"Comment": "get all methods annotated with a given annotation, including annotation member values matchingdepends on fieldannotationsscanner configured",
	"Method": "Set<Field> getFieldsAnnotatedWith(Class<? extends Annotation> annotation,Set<Field> getFieldsAnnotatedWith,Annotation annotation){\r\n    return filter(getFieldsAnnotatedWith(annotation.annotationType()), withAnnotation(annotation));\r\n}"
}, {
	"Path": "net.minecraftforge.registries.ForgeRegistry.freeze",
	"Comment": "used to control the times where people can modify this registry.users should only ever register things in the register events!",
	"Method": "void freeze(){\r\n    this.isFrozen = true;\r\n}"
}, {
	"Path": "org.springframework.security.config.annotation.authentication.configurers.provisioning.JdbcUserDetailsManagerConfigurer.withDefaultSchema",
	"Comment": "populates the default schema that allows users and authorities to be stored.",
	"Method": "JdbcUserDetailsManagerConfigurer<B> withDefaultSchema(){\r\n    this.initScripts.add(new ClassPathResource(\"org/springframework/security/core/userdetails/jdbc/users.ddl\"));\r\n    return this;\r\n}"
}, {
	"Path": "io.restassured.path.xml.XmlPath.getBoolean",
	"Comment": "get the result of an xml path expression as a boolean. for syntax details please refer tothis url.",
	"Method": "boolean getBoolean(String path){\r\n    Object object = get(path);\r\n    return convertObjectTo(object, Boolean.class);\r\n}"
}, {
	"Path": "org.springframework.security.cas.ServiceProperties.setArtifactParameter",
	"Comment": "configures the request parameter to look for when attempting to see if a cas ticket\twas sent from the server.",
	"Method": "void setArtifactParameter(String artifactParameter){\r\n    this.artifactParameter = artifactParameter;\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.AbstractQueuedLongSynchronizer.findNodeFromTail",
	"Comment": "returns true if node is on sync queue by searching backwards from tail.called only when needed by isonsyncqueue.",
	"Method": "boolean findNodeFromTail(Node node){\r\n    Node t = tail;\r\n    for (; ; ) {\r\n        if (t == node)\r\n            return true;\r\n        if (t == null)\r\n            return false;\r\n        t = t.prev;\r\n    }\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.ReentrantReadWriteLock.getReadHoldCount",
	"Comment": "queries the number of reentrant read holds on this lock by thecurrent strand.a reader strand has a hold on a lock foreach lock action that is not matched by an unlock action.",
	"Method": "int getReadHoldCount(int getReadHoldCount){\r\n    return sync.getReadHoldCount();\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.StampedLock.tryUnlockRead",
	"Comment": "releases one hold of the read lock if it is held, withoutrequiring a stamp value. this method may be useful for recoveryafter errors.",
	"Method": "boolean tryUnlockRead(){\r\n    long s, m;\r\n    WNode h;\r\n    while ((m = (s = state) & ABITS) != 0L && m < WBIT) {\r\n        if (m < RFULL) {\r\n            if (STATE.compareAndSet(this, s, s - RUNIT)) {\r\n                if (m == RUNIT && (h = whead) != null && h.status != 0)\r\n                    release(h);\r\n                return true;\r\n            }\r\n        } else if (tryDecReaderOverflow(s) != 0L)\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.springframework.cloud.netflix.turbine.CommonsInstanceDiscovery.getClusterName",
	"Comment": "helper that fetches the cluster name. cluster is a turbine concept and not a commons\tconcept. by default we choose the amazon serviceid as the cluster. a custom\timplementation can be plugged in by overriding this method.",
	"Method": "String getClusterName(Object object){\r\n    StandardEvaluationContext context = new StandardEvaluationContext(object);\r\n    Object value = this.clusterNameExpression.getValue(context);\r\n    if (value != null) {\r\n        return value.toString();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.minecraftforge.common.ForgeModContainer.syncConfig",
	"Comment": "synchronizes the local fields with the values in the configuration object.",
	"Method": "void syncConfig(boolean load){\r\n    List<String> propOrder = new ArrayList<String>();\r\n    if (!config.isChild) {\r\n        if (load) {\r\n            config.load();\r\n        }\r\n        Property enableGlobalCfg = config.get(Configuration.CATEGORY_GENERAL, \"enableGlobalConfig\", false).setShowInGui(false);\r\n        if (enableGlobalCfg.getBoolean(false)) {\r\n            Configuration.enableGlobalConfig();\r\n        }\r\n    }\r\n    Property prop;\r\n    if (config.getCategory(CATEGORY_GENERAL).containsKey(\"defaultSpawnFuzz\"))\r\n        config.getCategory(CATEGORY_GENERAL).remove(\"defaultSpawnFuzz\");\r\n    if (config.getCategory(CATEGORY_GENERAL).containsKey(\"spawnHasFuzz\"))\r\n        config.getCategory(CATEGORY_GENERAL).remove(\"spawnHasFuzz\");\r\n    if (config.getCategory(CATEGORY_GENERAL).containsKey(\"disableStitchedFileSaving\"))\r\n        config.getCategory(CATEGORY_GENERAL).remove(\"disableStitchedFileSaving\");\r\n    if (config.getCategory(CATEGORY_CLIENT).containsKey(\"java8Reminder\"))\r\n        config.getCategory(CATEGORY_CLIENT).remove(\"java8Reminder\");\r\n    if (config.getCategory(CATEGORY_CLIENT).containsKey(\"replaceVanillaBucketModel\"))\r\n        config.getCategory(CATEGORY_CLIENT).remove(\"replaceVanillaBucketModel\");\r\n    remapGeneralPropertyToClient(\"biomeSkyBlendRange\");\r\n    remapGeneralPropertyToClient(\"forgeLightPipelineEnabled\");\r\n    prop = config.get(CATEGORY_GENERAL, \"disableVersionCheck\", false);\r\n    prop.setComment(\"Set to true to disable Forge's version check mechanics. Forge queries a small json file on our server for version information. For more details see the ForgeVersion class in our github.\");\r\n    prop.setLanguageKey(\"forge.configgui.disableVersionCheck\");\r\n    disableVersionCheck = prop.getBoolean(disableVersionCheck);\r\n    propOrder.add(prop.getName());\r\n    prop = config.get(Configuration.CATEGORY_GENERAL, \"clumpingThreshold\", 64, \"Controls the number threshold at which Packet51 is preferred over Packet52, default and minimum 64, maximum 1024\", 64, 1024);\r\n    prop.setLanguageKey(\"forge.configgui.clumpingThreshold\").setRequiresWorldRestart(true);\r\n    clumpingThreshold = prop.getInt(64);\r\n    if (clumpingThreshold > 1024 || clumpingThreshold < 64) {\r\n        clumpingThreshold = 64;\r\n        prop.set(64);\r\n    }\r\n    propOrder.add(prop.getName());\r\n    prop = config.get(CATEGORY_GENERAL, \"sortRecipies\", true);\r\n    prop.setComment(\"Set to true to enable the post initialization sorting of crafting recipes using Forge's sorter. May cause desyncing on conflicting recipes. MUST RESTART MINECRAFT IF CHANGED FROM THE CONFIG GUI.\");\r\n    prop.setLanguageKey(\"forge.configgui.sortRecipies\").setRequiresMcRestart(true);\r\n    shouldSortRecipies = prop.getBoolean(true);\r\n    propOrder.add(prop.getName());\r\n    prop = config.get(Configuration.CATEGORY_GENERAL, \"removeErroringEntities\", false);\r\n    prop.setComment(\"Set this to true to remove any Entity that throws an error in its update method instead of closing the server and reporting a crash log. BE WARNED THIS COULD SCREW UP EVERYTHING USE SPARINGLY WE ARE NOT RESPONSIBLE FOR DAMAGES.\");\r\n    prop.setLanguageKey(\"forge.configgui.removeErroringEntities\").setRequiresWorldRestart(true);\r\n    removeErroringEntities = prop.getBoolean(false);\r\n    propOrder.add(prop.getName());\r\n    if (removeErroringEntities) {\r\n        FMLLog.log.warn(\"Enabling removal of erroring Entities - USE AT YOUR OWN RISK\");\r\n    }\r\n    prop = config.get(Configuration.CATEGORY_GENERAL, \"removeErroringTileEntities\", false);\r\n    prop.setComment(\"Set this to true to remove any TileEntity that throws an error in its update method instead of closing the server and reporting a crash log. BE WARNED THIS COULD SCREW UP EVERYTHING USE SPARINGLY WE ARE NOT RESPONSIBLE FOR DAMAGES.\");\r\n    prop.setLanguageKey(\"forge.configgui.removeErroringTileEntities\").setRequiresWorldRestart(true);\r\n    removeErroringTileEntities = prop.getBoolean(false);\r\n    propOrder.add(prop.getName());\r\n    if (removeErroringTileEntities) {\r\n        FMLLog.log.warn(\"Enabling removal of erroring Tile Entities - USE AT YOUR OWN RISK\");\r\n    }\r\n    prop = config.get(Configuration.CATEGORY_GENERAL, \"fullBoundingBoxLadders\", false);\r\n    prop.setComment(\"Set this to true to check the entire entity's collision bounding box for ladders instead of just the block they are in. Causes noticeable differences in mechanics so default is vanilla behavior. Default: false\");\r\n    prop.setLanguageKey(\"forge.configgui.fullBoundingBoxLadders\").setRequiresWorldRestart(true);\r\n    fullBoundingBoxLadders = prop.getBoolean(false);\r\n    propOrder.add(prop.getName());\r\n    prop = config.get(Configuration.CATEGORY_GENERAL, \"zombieBaseSummonChance\", 0.1, \"Base zombie summoning spawn chance. Allows changing the bonus zombie summoning mechanic.\", 0.0D, 1.0D);\r\n    prop.setLanguageKey(\"forge.configgui.zombieBaseSummonChance\").setRequiresWorldRestart(true);\r\n    zombieSummonBaseChance = prop.getDouble(0.1);\r\n    propOrder.add(prop.getName());\r\n    prop = config.get(Configuration.CATEGORY_GENERAL, \"zombieBabyChance\", 0.05, \"Chance that a zombie (or subclass) is a baby. Allows changing the zombie spawning mechanic.\", 0.0D, 1.0D);\r\n    prop.setLanguageKey(\"forge.configgui.zombieBabyChance\").setRequiresWorldRestart(true);\r\n    zombieBabyChance = (float) prop.getDouble(0.05);\r\n    propOrder.add(prop.getName());\r\n    prop = config.get(Configuration.CATEGORY_GENERAL, \"logCascadingWorldGeneration\", true, \"Log cascading chunk generation issues during terrain population.\");\r\n    logCascadingWorldGeneration = prop.getBoolean();\r\n    prop.setLanguageKey(\"forge.configgui.logCascadingWorldGeneration\");\r\n    propOrder.add(prop.getName());\r\n    prop = config.get(Configuration.CATEGORY_GENERAL, \"fixVanillaCascading\", false, \"Fix vanilla issues that cause worldgen cascading. This DOES change vanilla worldgen so DO NOT report bugs related to world differences if this flag is on.\");\r\n    fixVanillaCascading = prop.getBoolean();\r\n    prop.setLanguageKey(\"forge.configgui.fixVanillaCascading\");\r\n    propOrder.add(prop.getName());\r\n    prop = config.get(Configuration.CATEGORY_GENERAL, \"dimensionUnloadQueueDelay\", 0, \"The time in ticks the server will wait when a dimension was queued to unload. \" + \"This can be useful when rapidly loading and unloading dimensions, like e.g. throwing items through a nether portal a few time per second.\");\r\n    dimensionUnloadQueueDelay = prop.getInt(0);\r\n    prop.setLanguageKey(\"forge.configgui.dimensionUnloadQueueDelay\");\r\n    propOrder.add(prop.getName());\r\n    config.setCategoryPropertyOrder(CATEGORY_GENERAL, propOrder);\r\n    propOrder = new ArrayList<String>();\r\n    prop = config.get(VERSION_CHECK_CAT, \"Global\", true, \"Enable the entire mod update check system. This only applies to mods using the Forge system.\");\r\n    propOrder.add(\"Global\");\r\n    config.setCategoryPropertyOrder(VERSION_CHECK_CAT, propOrder);\r\n    propOrder = new ArrayList<String>();\r\n    prop = config.get(Configuration.CATEGORY_CLIENT, \"zoomInMissingModelTextInGui\", false, \"Toggle off to make missing model text in the gui fit inside the slot.\");\r\n    zoomInMissingModelTextInGui = prop.getBoolean(false);\r\n    prop.setLanguageKey(\"forge.configgui.zoomInMissingModelTextInGui\");\r\n    propOrder.add(prop.getName());\r\n    prop = config.get(Configuration.CATEGORY_CLIENT, \"forgeCloudsEnabled\", true, \"Enable uploading cloud geometry to the GPU for faster rendering.\");\r\n    prop.setLanguageKey(\"forge.configgui.forgeCloudsEnabled\");\r\n    forgeCloudsEnabled = prop.getBoolean();\r\n    propOrder.add(prop.getName());\r\n    prop = config.get(Configuration.CATEGORY_CLIENT, \"disableStairSlabCulling\", false, \"Disable culling of hidden faces next to stairs and slabs. Causes extra rendering, but may fix some resource packs that exploit this vanilla mechanic.\");\r\n    disableStairSlabCulling = prop.getBoolean(false);\r\n    prop.setLanguageKey(\"forge.configgui.disableStairSlabCulling\");\r\n    propOrder.add(prop.getName());\r\n    prop = config.get(Configuration.CATEGORY_CLIENT, \"alwaysSetupTerrainOffThread\", false, \"Enable forge to queue all chunk updates to the Chunk Update thread. May increase FPS significantly, but may also cause weird rendering lag. Not recommended for computers \" + \"without a significant number of cores available.\");\r\n    alwaysSetupTerrainOffThread = prop.getBoolean(false);\r\n    prop.setLanguageKey(\"forge.configgui.alwaysSetupTerrainOffThread\");\r\n    propOrder.add(prop.getName());\r\n    prop = config.get(Configuration.CATEGORY_CLIENT, \"allowEmissiveItems\", true, \"Allow item rendering to detect emissive quads and draw them properly. This allows glowing blocks to look the same in item form, but incurs a very slight performance hit.\");\r\n    allowEmissiveItems = prop.getBoolean(true);\r\n    prop.setLanguageKey(\"forge.configgui.allowEmissiveItems\");\r\n    propOrder.add(prop.getName());\r\n    prop = config.get(Configuration.CATEGORY_CLIENT, \"biomeSkyBlendRange\", new int[] { 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34 });\r\n    prop.setComment(\"Control the range of sky blending for colored skies in biomes.\");\r\n    prop.setLanguageKey(\"forge.configgui.biomeSkyBlendRange\");\r\n    blendRanges = prop.getIntList();\r\n    propOrder.add(prop.getName());\r\n    prop = config.get(Configuration.CATEGORY_CLIENT, \"forgeLightPipelineEnabled\", true, \"Enable the forge block rendering pipeline - fixes the lighting of custom models.\");\r\n    forgeLightPipelineEnabled = prop.getBoolean(true);\r\n    prop.setLanguageKey(\"forge.configgui.forgeLightPipelineEnabled\");\r\n    propOrder.add(prop.getName());\r\n    prop = config.get(Configuration.CATEGORY_CLIENT, \"selectiveResourceReloadEnabled\", false, \"When enabled, makes specific reload tasks such as language changing quicker to run.\");\r\n    selectiveResourceReloadEnabled = prop.getBoolean(false);\r\n    prop.setLanguageKey(\"forge.configgui.selectiveResourceReloadEnabled\");\r\n    propOrder.add(prop.getName());\r\n    config.setCategoryPropertyOrder(CATEGORY_CLIENT, propOrder);\r\n    if (config.hasChanged()) {\r\n        config.save();\r\n    }\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.AbstractQueuedSynchronizer.owns",
	"Comment": "queries whether the given conditionobjectuses this synchronizer as its lock.",
	"Method": "boolean owns(ConditionObject condition){\r\n    return condition.isOwnedBy(this);\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.StampedLock.tryConvertToReadLock",
	"Comment": "if the lock state matches the given stamp, performs one ofthe following actions. if the stamp represents holding a writelock, releases it and obtains a read lock. or, if a read lock,returns it. or, if an optimistic read, acquires a read lock andreturns a read stamp only if immediately available. this methodreturns zero in all other cases.",
	"Method": "long tryConvertToReadLock(long stamp){\r\n    long a = stamp & ABITS, m, s, next;\r\n    WNode h;\r\n    while (((s = state) & SBITS) == (stamp & SBITS)) {\r\n        if ((m = s & ABITS) == 0L) {\r\n            if (a != 0L)\r\n                break;\r\n            else if (m < RFULL) {\r\n                if (STATE.compareAndSet(this, s, next = s + RUNIT))\r\n                    return next;\r\n            } else if ((next = tryIncReaderOverflow(s)) != 0L)\r\n                return next;\r\n        } else if (m == WBIT) {\r\n            if (a != m)\r\n                break;\r\n            state = next = s + (WBIT + RUNIT);\r\n            if ((h = whead) != null && h.status != 0)\r\n                release(h);\r\n            return next;\r\n        } else if (a != 0L && a < WBIT)\r\n            return stamp;\r\n        else\r\n            break;\r\n    }\r\n    return 0L;\r\n}"
}, {
	"Path": "co.paralleluniverse.fibers.FiberAsync.asyncFailed",
	"Comment": "this method must be called by the callback upon a failure of the asynchronous operation.",
	"Method": "void asyncFailed(Throwable t){\r\n    if (t == null)\r\n        throw new IllegalArgumentException(\"t must not be null\");\r\n    if (completed)\r\n        return;\r\n    this.exception = t;\r\n    completed = true;\r\n    fire(fiber);\r\n}"
}, {
	"Path": "net.minecraftforge.common.config.Property.isLongValue",
	"Comment": "checks if the current value stored in this property can be converted to a long.",
	"Method": "boolean isLongValue(){\r\n    try {\r\n        Long.parseLong(value);\r\n        return true;\r\n    } catch (NumberFormatException e) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.CountDownLatch.getCount",
	"Comment": "returns the current count.this method is typically used for debugging and testing purposes.",
	"Method": "int getCount(long getCount){\r\n    return sync.getCount();\r\n}"
}, {
	"Path": "com.uber.nullaway.NullabilityUtil.lambdaParamIsImplicitlyTyped",
	"Comment": "determines whether a lambda parameter is missing an explicit type declaration",
	"Method": "boolean lambdaParamIsImplicitlyTyped(VariableTree lambdaParameter){\r\n    JCDiagnostic.DiagnosticPosition diagnosticPosition = (JCDiagnostic.DiagnosticPosition) lambdaParameter;\r\n    return diagnosticPosition.getStartPosition() == diagnosticPosition.getPreferredPosition();\r\n}"
}, {
	"Path": "com.alibaba.csp.sentinel.AsyncEntry.initAsyncContext",
	"Comment": "the async context should not be initialized until the node for current resource has been set to current entry.",
	"Method": "void initAsyncContext(){\r\n    if (asyncContext == null) {\r\n        if (context instanceof NullContext) {\r\n            asyncContext = context;\r\n            return;\r\n        }\r\n        this.asyncContext = Context.newAsyncContext(context.getEntranceNode(), context.getName()).setOrigin(context.getOrigin()).setCurEntry(this);\r\n    } else {\r\n        RecordLog.warn(\"[AsyncEntry] Duplicate initialize of async context for entry: \" + resourceWrapper.getName());\r\n    }\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.channels.SelectAction.isDone",
	"Comment": "tests whether this operation is the one operation that has been selected and completed by the selector.",
	"Method": "boolean isDone(){\r\n    return done;\r\n}"
}, {
	"Path": "com.rxjava2.android.samples.ui.operators.DeferExampleActivity.doSomeWork",
	"Comment": "defer used for deferring observable code until subscription in rxjava",
	"Method": "void doSomeWork(){\r\n    Car car = new Car();\r\n    Observable<String> brandDeferObservable = car.brandDeferObservable();\r\n    car.setBrand(\"BMW\");\r\n    brandDeferObservable.subscribe(getObserver());\r\n}"
}, {
	"Path": "net.minecraftforge.fluids.DispenseFluidContainer.dumpContainer",
	"Comment": "drains a filled container and places the fluid in front of the dispenser.",
	"Method": "ItemStack dumpContainer(IBlockSource source,ItemStack stack){\r\n    ItemStack singleStack = stack.copy();\r\n    singleStack.setCount(1);\r\n    IFluidHandlerItem fluidHandler = FluidUtil.getFluidHandler(singleStack);\r\n    if (fluidHandler == null) {\r\n        return super.dispenseStack(source, stack);\r\n    }\r\n    FluidStack fluidStack = fluidHandler.drain(Fluid.BUCKET_VOLUME, false);\r\n    EnumFacing dispenserFacing = source.getBlockState().getValue(BlockDispenser.FACING);\r\n    BlockPos blockpos = source.getBlockPos().offset(dispenserFacing);\r\n    FluidActionResult result = fluidStack != null ? FluidUtil.tryPlaceFluid(null, source.getWorld(), blockpos, stack, fluidStack) : FluidActionResult.FAILURE;\r\n    if (result.isSuccess()) {\r\n        ItemStack drainedStack = result.getResult();\r\n        if (drainedStack.getCount() == 1) {\r\n            return drainedStack;\r\n        } else if (!drainedStack.isEmpty() && ((TileEntityDispenser) source.getBlockTileEntity()).addItemStack(drainedStack) < 0) {\r\n            this.dispenseBehavior.dispense(source, drainedStack);\r\n        }\r\n        ItemStack stackCopy = drainedStack.copy();\r\n        stackCopy.shrink(1);\r\n        return stackCopy;\r\n    } else {\r\n        return this.dispenseBehavior.dispense(source, stack);\r\n    }\r\n}"
}, {
	"Path": "com.alibaba.csp.sentinel.datasource.redis.config.RedisConnectionConfig.getTimeout",
	"Comment": "returns the command timeout for synchronous command execution.",
	"Method": "long getTimeout(){\r\n    return timeout;\r\n}"
}, {
	"Path": "net.minecraftforge.fluids.FluidUtil.getFluidHandler",
	"Comment": "helper method to get an ifluidhandler for at a block position.returns null if there is no valid fluid handler.",
	"Method": "IFluidHandlerItem getFluidHandler(ItemStack itemStack,IFluidHandler getFluidHandler,World world,BlockPos blockPos,EnumFacing side){\r\n    IBlockState state = world.getBlockState(blockPos);\r\n    Block block = state.getBlock();\r\n    if (block.hasTileEntity(state)) {\r\n        TileEntity tileEntity = world.getTileEntity(blockPos);\r\n        if (tileEntity != null && tileEntity.hasCapability(CapabilityFluidHandler.FLUID_HANDLER_CAPABILITY, side)) {\r\n            return tileEntity.getCapability(CapabilityFluidHandler.FLUID_HANDLER_CAPABILITY, side);\r\n        }\r\n    }\r\n    if (block instanceof IFluidBlock) {\r\n        return new FluidBlockWrapper((IFluidBlock) block, world, blockPos);\r\n    } else if (block instanceof BlockLiquid) {\r\n        return new BlockLiquidWrapper((BlockLiquid) block, world, blockPos);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "io.objectbox.Box.getMap",
	"Comment": "get the stored objects for the given ids as a map with ids as keys, and entities as values.ids for which no entity is found will be put in the map with null values.",
	"Method": "Map<Long, T> getMap(Iterable<Long> ids){\r\n    HashMap<Long, T> map = new HashMap();\r\n    Cursor<T> reader = getReader();\r\n    try {\r\n        for (Long id : ids) {\r\n            map.put(id, reader.get(id));\r\n        }\r\n    } finally {\r\n        releaseReader(reader);\r\n    }\r\n    return map;\r\n}"
}, {
	"Path": "io.restassured.path.xml.XmlPath.getUUID",
	"Comment": "get the result of an xml path expression as a uuid. for syntax details please refer tothis url.",
	"Method": "UUID getUUID(String path){\r\n    Object object = get(path);\r\n    return convertObjectTo(object, UUID.class);\r\n}"
}, {
	"Path": "net.minecraftforge.client.model.ItemTextureQuadConverter.convertTextureVertical",
	"Comment": "scans a texture and converts it into a list of vertical strips stacked next to each other from left to right.the width of the strips is as big as possible.",
	"Method": "List<UnpackedBakedQuad> convertTextureVertical(VertexFormat format,TRSRTransformation transform,TextureAtlasSprite template,TextureAtlasSprite sprite,float z,EnumFacing facing,int color,List<UnpackedBakedQuad> convertTextureVertical,VertexFormat format,TRSRTransformation transform,TextureAtlasSprite template,TextureAtlasSprite sprite,float z,EnumFacing facing,int color,int tint){\r\n    int w = template.getIconWidth();\r\n    int h = template.getIconHeight();\r\n    float wScale = 16f / (float) w;\r\n    float hScale = 16f / (float) h;\r\n    int[] data = template.getFrameTextureData(0)[0];\r\n    List<UnpackedBakedQuad> quads = Lists.newArrayList();\r\n    int start = -1;\r\n    for (int x = 0; x < w; x++) {\r\n        for (int y = 0; y < h; y++) {\r\n            int pixel = data[y * w + x];\r\n            if (start < 0 && isVisible(pixel)) {\r\n                start = y;\r\n            }\r\n            if (start >= 0 && !isVisible(pixel)) {\r\n                int endX = x + 1;\r\n                boolean sameColumn = true;\r\n                while (sameColumn && endX < w) {\r\n                    for (int i = 0; i < h; i++) {\r\n                        int px1 = data[i * w + x];\r\n                        int px2 = data[i * w + endX];\r\n                        if (isVisible(px1) != isVisible(px2)) {\r\n                            sameColumn = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (sameColumn) {\r\n                        endX++;\r\n                    }\r\n                }\r\n                quads.add(genQuad(format, transform, (float) x * wScale, (float) start * hScale, (float) endX * wScale, (float) y * hScale, z, sprite, facing, color, tint));\r\n                if (endX - x > 1) {\r\n                    x = endX - 1;\r\n                }\r\n                start = -1;\r\n            }\r\n        }\r\n    }\r\n    return quads;\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.AbstractQueuedSynchronizer.isQueued",
	"Comment": "returns true if the given strand is currently queued.this implementation traverses the queue to determinepresence of the given strand.",
	"Method": "boolean isQueued(Strand strand){\r\n    if (strand == null)\r\n        throw new NullPointerException();\r\n    for (Node p = tail; p != null; p = p.prev) if (p.strand == strand)\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.AbstractQueuedLongSynchronizer.getWaitQueueLength",
	"Comment": "returns an estimate of the number of strands waiting on thegiven condition associated with this synchronizer. note thatbecause timeouts and interrupts may occur at any time, theestimate serves only as an upper bound on the actual number ofwaiters.this method is designed for use in monitoring of thesystem state, not for synchronization control.",
	"Method": "int getWaitQueueLength(ConditionObject condition,int getWaitQueueLength){\r\n    if (!owns(condition))\r\n        throw new IllegalArgumentException(\"Not owner\");\r\n    return condition.getWaitQueueLength();\r\n}"
}, {
	"Path": "net.minecraftforge.fml.client.config.GuiSlider.getHoverState",
	"Comment": "returns 0 if the button is disabled, 1 if the mouse is not hovering over this button and 2 if it is hovering overthis button.",
	"Method": "int getHoverState(boolean par1){\r\n    return 0;\r\n}"
}, {
	"Path": "io.restassured.config.HttpClientConfig.httpClientFactory",
	"Comment": "set the http client factory that rest assured should use when making request. for each request rest assured will invoke the factory to get the a the httpclient instance.",
	"Method": "HttpClientConfig httpClientFactory(HttpClientFactory httpClientFactory){\r\n    return new HttpClientConfig(httpClientFactory, httpClientParams, httpMultipartMode, shouldReuseHttpClientInstance, NO_HTTP_CLIENT, true);\r\n}"
}, {
	"Path": "io.restassured.internal.http.EncoderRegistry.encodeXML",
	"Comment": "encode the content as xml.the argument may be either an object whosetostring produces valid markup, or a closure which will beinterpreted as a builder definition.",
	"Method": "HttpEntity encodeXML(Object contentType,Object xml){\r\n    String contentTypeAsString = contentTypeToString(contentType);\r\n    if (xml instanceof Closure) {\r\n        StreamingMarkupBuilder smb = new StreamingMarkupBuilder();\r\n        xml = smb.bind(xml);\r\n    } else if (xml instanceof File) {\r\n        xml = toString((File) xml, contentTypeAsString);\r\n    }\r\n    return createEntity(contentTypeAsString, xml);\r\n}"
}, {
	"Path": "co.paralleluniverse.common.util.ServiceUtil.loadSingletonService",
	"Comment": "loads a service of the given type and ensures it has exactly one implementation.",
	"Method": "T loadSingletonService(Class<T> type){\r\n    final T service = loadSingletonServiceOrNull(type);\r\n    if (service == null)\r\n        throw new Error(\"No implementation of \" + type.getName() + \" found!\");\r\n    return service;\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.Semaphore.getQueueLength",
	"Comment": "returns an estimate of the number of threads waiting to acquire.the value is only an estimate because the number of threads maychange dynamically while this method traverses internal datastructures.this method is designed for use in monitoring of thesystem state, not for synchronization control.",
	"Method": "int getQueueLength(){\r\n    return sync.getQueueLength();\r\n}"
}, {
	"Path": "net.minecraftforge.client.model.IModel.getDependencies",
	"Comment": "returns all model locations that this model depends on.assume that returned collection is immutable.see modelloaderregistry.getmodel for dependency loading.",
	"Method": "Collection<ResourceLocation> getDependencies(){\r\n    return ImmutableList.of();\r\n}"
}, {
	"Path": "net.minecraftforge.fml.common.eventhandler.Event.getListenerList",
	"Comment": "returns a listenerlist object that contains all listenersthat are registered to this event.",
	"Method": "ListenerList getListenerList(){\r\n    return listeners;\r\n}"
}, {
	"Path": "io.objectbox.Transaction.reset",
	"Comment": "will throw if cursors are still active for this tx.efficient for read transactions.",
	"Method": "void reset(){\r\n    checkOpen();\r\n    initialCommitCount = store.commitCount;\r\n    nativeReset(transaction);\r\n}"
}, {
	"Path": "org.springframework.cloud.netflix.eureka.server.RefreshablePeerEurekaNodesTests.forceUpdate",
	"Comment": "refreshes the context with properties satisfying to invoke update.",
	"Method": "void forceUpdate(){\r\n    changeProperty(\"eureka.client.use-dns-for-fetching-service-urls=false\", \"eureka.client.region=unavailable-region\");\r\n    this.context.publishEvent(new EnvironmentChangeEvent(Collections.singleton(\"eureka.client.service-url.defaultZone\")));\r\n}"
}, {
	"Path": "io.restassured.filter.log.StatusCodeBasedLoggingFilter.cloneResponseIfNeeded",
	"Comment": "if body expectations are defined we need to return a new response otherwise the streamhas been closed due to the logging.",
	"Method": "Response cloneResponseIfNeeded(Response response,byte[] responseAsString){\r\n    if (responseAsString != null && response instanceof RestAssuredResponseImpl && !((RestAssuredResponseImpl) response).getHasExpectations()) {\r\n        final Response build = new ResponseBuilder().clone(response).setBody(responseAsString).build();\r\n        ((RestAssuredResponseImpl) build).setHasExpectations(true);\r\n        return build;\r\n    }\r\n    return response;\r\n}"
}, {
	"Path": "net.minecraftforge.event.AttachCapabilitiesEvent.addCapability",
	"Comment": "adds a capability to be attached to this object.keys must be unique, it is suggested that you set the domain to your mod id.if the capability is an instance of inbtserializable, this key will be used when serializing this capability.",
	"Method": "void addCapability(ResourceLocation key,ICapabilityProvider cap){\r\n    if (caps.containsKey(key))\r\n        throw new IllegalStateException(\"Duplicate Capability Key: \" + key + \" \" + cap);\r\n    this.caps.put(key, cap);\r\n}"
}, {
	"Path": "net.minecraftforge.common.ForgeChunkManager.unforceChunk",
	"Comment": "unforce the supplied chunk, allowing it to be unloaded and stop ticking.",
	"Method": "void unforceChunk(Ticket ticket,ChunkPos chunk){\r\n    if (ticket == null || chunk == null) {\r\n        return;\r\n    }\r\n    ticket.requestedChunks.remove(chunk);\r\n    MinecraftForge.EVENT_BUS.post(new UnforceChunkEvent(ticket, chunk));\r\n    LinkedHashMultimap<ChunkPos, Ticket> copy = LinkedHashMultimap.create(forcedChunks.get(ticket.world));\r\n    copy.remove(chunk, ticket);\r\n    ImmutableSetMultimap<ChunkPos, Ticket> newMap = ImmutableSetMultimap.copyOf(copy);\r\n    forcedChunks.put(ticket.world, newMap);\r\n}"
}, {
	"Path": "net.minecraftforge.common.config.Property.getBoolean",
	"Comment": "returns the value in this property as a boolean, if the value is not a valid boolean, it will return the provided default.",
	"Method": "boolean getBoolean(boolean _default,boolean getBoolean){\r\n    if (isBooleanValue()) {\r\n        return Boolean.parseBoolean(value);\r\n    } else {\r\n        return Boolean.parseBoolean(defaultValue);\r\n    }\r\n}"
}, {
	"Path": "co.paralleluniverse.actors.Actor.receive",
	"Comment": "returns the next message from the mailbox. if no message is currently available, this method blocks until a message arrives,but no longer than the given timeout.",
	"Method": "Message receive(Message receive,long timeout,TimeUnit unit,Message receive,Timeout timeout){\r\n    return receive(timeout.nanosLeft(), TimeUnit.NANOSECONDS);\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.Phaser.internalAwaitAdvance",
	"Comment": "possibly blocks and waits for phase to advance unless aborted.call only from root node.",
	"Method": "int internalAwaitAdvance(int phase,QNode node){\r\n    releaseWaiters(phase - 1);\r\n    boolean queued = false;\r\n    int lastUnarrived = 0;\r\n    final int spinDelta = Strand.isCurrentFiber() ? 0 : SPINS_PER_ARRIVAL;\r\n    int spins = spinDelta;\r\n    long s;\r\n    int p;\r\n    while ((p = (int) ((s = state) >>> PHASE_SHIFT)) == phase) {\r\n        if (node == null) {\r\n            int unarrived = (int) s & UNARRIVED_MASK;\r\n            if (unarrived != lastUnarrived && (lastUnarrived = unarrived) < NCPU)\r\n                spins += spinDelta;\r\n            boolean interrupted = Strand.interrupted();\r\n            if (interrupted || --spins < 0) {\r\n                node = new QNode(this, phase, false, false, 0L);\r\n                node.wasInterrupted = interrupted;\r\n            }\r\n        } else if (node.isReleasable())\r\n            break;\r\n        else if (!queued) {\r\n            AtomicReference<QNode> head = (phase & 1) == 0 ? evenQ : oddQ;\r\n            QNode q = node.next = head.get();\r\n            if ((q == null || q.phase == phase) && (int) (state >>> PHASE_SHIFT) == phase)\r\n                queued = head.compareAndSet(q, node);\r\n        } else {\r\n            try {\r\n                do {\r\n                } while (!node.isReleasable() && !node.block());\r\n            } catch (InterruptedException ie) {\r\n                node.wasInterrupted = true;\r\n            }\r\n        }\r\n    }\r\n    if (node != null) {\r\n        if (node.strand != null)\r\n            node.strand = null;\r\n        if (node.wasInterrupted && !node.interruptible)\r\n            Strand.currentStrand().interrupt();\r\n        if (p == phase && (p = (int) (state >>> PHASE_SHIFT)) == phase)\r\n            return abortWait(phase);\r\n    }\r\n    releaseWaiters(phase);\r\n    return p;\r\n}"
}, {
	"Path": "net.minecraftforge.fml.common.Loader.setupTestHarness",
	"Comment": "used to setup a testharness with a single dummy mod instance for use with various testing hooks",
	"Method": "void setupTestHarness(ModContainer containers){\r\n    modController = new LoadController(this);\r\n    mods = Lists.newArrayList(containers);\r\n    namedMods = Maps.uniqueIndex(mods, ModContainer::getModId);\r\n    modController.transition(LoaderState.LOADING, false);\r\n    modController.transition(LoaderState.CONSTRUCTING, false);\r\n    ObjectHolderRegistry.INSTANCE.findObjectHolders(new ASMDataTable());\r\n    modController.forceActiveContainer(containers[0]);\r\n}"
}, {
	"Path": "org.springframework.cloud.netflix.turbine.EurekaInstanceDiscovery.getInstancesForApp",
	"Comment": "private helper that fetches the instances for each application.",
	"Method": "List<Instance> getInstancesForApp(String serviceId){\r\n    List<Instance> instances = new ArrayList();\r\n    log.info(\"Fetching instances for app: \" + serviceId);\r\n    Application app = eurekaClient.getApplication(serviceId);\r\n    if (app == null) {\r\n        log.warn(\"Eureka returned null for app: \" + serviceId);\r\n        return instances;\r\n    }\r\n    try {\r\n        List<InstanceInfo> instancesForApp = app.getInstances();\r\n        if (instancesForApp != null) {\r\n            log.info(\"Received instance list for app: \" + serviceId + \", size=\" + instancesForApp.size());\r\n            for (InstanceInfo iInfo : instancesForApp) {\r\n                Instance instance = marshall(iInfo);\r\n                if (instance != null) {\r\n                    instances.add(instance);\r\n                }\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n        log.warn(\"Failed to retrieve instances from Eureka\", e);\r\n    }\r\n    return instances;\r\n}"
}, {
	"Path": "co.paralleluniverse.fibers.instrument.ClassLoaderTest.testDynamicallyLoadedFiber",
	"Comment": "test instrumentation of a fiber implementation class that is loaded dynamically.",
	"Method": "void testDynamicallyLoadedFiber(){\r\n    ArrayList<String> results = null;\r\n    try {\r\n        try {\r\n            URI currentURL = this.getClass().getProtectionDomain().getCodeSource().getLocation().toURI();\r\n            System.out.println(currentURL.toString());\r\n            URL testClassesURL = currentURL.resolve(\"../classloadertest/\").toURL();\r\n            System.out.println(testClassesURL.toString());\r\n            ClassLoader cl = new URLClassLoader(new URL[] { testClassesURL });\r\n            Class<?> testClass = cl.loadClass(\"co.paralleluniverse.fibers.dynamic.DynamicallyLoadedFiber\");\r\n            Constructor<?> constructor = testClass.getConstructor();\r\n            final Fiber<ArrayList<String>> testInstance = (Fiber<ArrayList<String>>) constructor.newInstance();\r\n            assertEquals(cl, testInstance.getClass().getClassLoader());\r\n            assertEquals(ClassLoader.getSystemClassLoader(), TestInterface.class.getClassLoader());\r\n            for (int i = 0; i < 4; i++) {\r\n                assertFalse(testInstance.isDone());\r\n                exec(testInstance);\r\n            }\r\n            assertTrue(testInstance.isDone());\r\n            results = testInstance.get();\r\n        } catch (Exception ex) {\r\n            throw new AssertionError(ex);\r\n        }\r\n    } finally {\r\n        System.out.println(results);\r\n    }\r\n    assertEquals(8, results.size());\r\n    assertEquals(Arrays.asList(\"a\", \"b\", \"o1\", \"o2\", \"base1\", \"base2\", \"o3\", \"c\"), results);\r\n}"
}, {
	"Path": "org.mapdb.jsr166.JSR166TestCase.delayedDate",
	"Comment": "returns a new date instance representing a time at leastdelaymillis milliseconds in the future.",
	"Method": "Date delayedDate(long delayMillis){\r\n    return new Date(System.currentTimeMillis() + delayMillis + 1);\r\n}"
}, {
	"Path": "io.restassured.RestAssured.digest",
	"Comment": "use http digest authentication. note that you need to encode the password yourself.",
	"Method": "AuthenticationScheme digest(String userName,String password){\r\n    return basic(userName, password);\r\n}"
}, {
	"Path": "io.restassured.http.Cookies.cookies",
	"Comment": "an alternative way to create a cookies object from the constructor.",
	"Method": "Cookies cookies(Cookie cookie,Cookie additionalCookies){\r\n    AssertParameter.notNull(cookie, \"Cookie\");\r\n    final List<Cookie> cookieList = new LinkedList<Cookie>();\r\n    cookieList.add(cookie);\r\n    Collections.addAll(cookieList, additionalCookies);\r\n    return new Cookies(cookieList);\r\n}"
}, {
	"Path": "co.paralleluniverse.concurrent.util.ConcurrentSkipListSet.removeAll",
	"Comment": "removes from this set all of its elements that are contained inthe specified collection. if the specified collection is alsoa set, this operation effectively modifies this set so that itsvalue is the asymmetric set difference of the two sets.",
	"Method": "boolean removeAll(Collection<?> c){\r\n    boolean modified = false;\r\n    for (Iterator<?> i = c.iterator(); i.hasNext(); ) if (remove(i.next()))\r\n        modified = true;\r\n    return modified;\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.channels.Channels.forEach",
	"Comment": "performs the given action on each message received by the given channel.this method returns only after all messages have been consumed and the channel has been closed.",
	"Method": "void forEach(ReceivePort<T> channel,SuspendableAction1<T> action){\r\n    T m;\r\n    while ((m = channel.receive()) != null) {\r\n        action.call(m);\r\n    }\r\n}"
}, {
	"Path": "org.mapdb.jsr166.JSR166TestCase.tearDown",
	"Comment": "extra checks that get done for all test cases.triggers test case failure if any thread assertions have failed,by rethrowing, in the test harness thread, any exception recordedearlier by threadrecordfailure.triggers test case failure if interrupt status is set in the main thread.",
	"Method": "void tearDown(){\r\n    Throwable t = threadFailure.getAndSet(null);\r\n    if (t != null) {\r\n        if (t instanceof Error)\r\n            throw (Error) t;\r\n        else if (t instanceof RuntimeException)\r\n            throw (RuntimeException) t;\r\n        else if (t instanceof Exception)\r\n            throw (Exception) t;\r\n        else\r\n            throw new AssertionError(t.toString(), t);\r\n    }\r\n    if (Thread.interrupted())\r\n        tearDownFail(\"interrupt status set in main thread\");\r\n    checkForkJoinPoolThreadLeaks();\r\n}"
}, {
	"Path": "org.reflections.util.ConfigurationBuilder.setScanners",
	"Comment": "set the scanners instances for scanning different metadata",
	"Method": "ConfigurationBuilder setScanners(Scanner scanners){\r\n    this.scanners.clear();\r\n    return addScanners(scanners);\r\n}"
}, {
	"Path": "io.restassured.path.xml.XmlPath.getFloat",
	"Comment": "get the result of an xml path expression as a float. for syntax details please refer tothis url.",
	"Method": "float getFloat(String path){\r\n    Object object = get(path);\r\n    return convertObjectTo(object, Float.class);\r\n}"
}, {
	"Path": "org.reflections.Reflections.getMethodsAnnotatedWith",
	"Comment": "get all methods annotated with a given annotation, including annotation member values matchingdepends on methodannotationsscanner configured",
	"Method": "Set<Method> getMethodsAnnotatedWith(Class<? extends Annotation> annotation,Set<Method> getMethodsAnnotatedWith,Annotation annotation){\r\n    return filter(getMethodsAnnotatedWith(annotation.annotationType()), withAnnotation(annotation));\r\n}"
}, {
	"Path": "net.minecraftforge.event.AttachCapabilitiesEvent.getCapabilities",
	"Comment": "a unmodifiable view of the capabilities that will be attached to this object.",
	"Method": "Map<ResourceLocation, ICapabilityProvider> getCapabilities(){\r\n    return view;\r\n}"
}, {
	"Path": "org.springframework.security.config.annotation.web.configurers.FormLoginConfigurer.getPasswordParameter",
	"Comment": "gets the http parameter that is used to submit the password.",
	"Method": "String getPasswordParameter(){\r\n    return getAuthenticationFilter().getPasswordParameter();\r\n}"
}, {
	"Path": "io.restassured.config.XmlConfig.isAllowDocTypeDeclaration",
	"Comment": "whether xmlpath should provide support for doctype declarations",
	"Method": "boolean isAllowDocTypeDeclaration(){\r\n    return allowDocTypeDeclaration;\r\n}"
}, {
	"Path": "io.objectbox.BoxStore.isFileOpen",
	"Comment": "also retries up to 500ms to improve gc race condition situation.",
	"Method": "boolean isFileOpen(String canonicalPath){\r\n    synchronized (openFiles) {\r\n        int tries = 0;\r\n        while (tries < 5 && openFiles.contains(canonicalPath)) {\r\n            tries++;\r\n            System.gc();\r\n            System.runFinalization();\r\n            System.gc();\r\n            System.runFinalization();\r\n            try {\r\n                openFiles.wait(100);\r\n            } catch (InterruptedException e) {\r\n            }\r\n        }\r\n        return openFiles.contains(canonicalPath);\r\n    }\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.channels.ThreadReceivePort.tryReceive",
	"Comment": "retrieves a message from the channel if one is available. this method never blocks.",
	"Method": "Message tryReceive(){\r\n    return p.tryReceive();\r\n}"
}, {
	"Path": "net.minecraftforge.common.ForgeVersion.gatherMods",
	"Comment": "gather a list of mods that have opted in to this update system by providing a url.",
	"Method": "Map<ModContainer, URL> gatherMods(){\r\n    Map<ModContainer, URL> ret = new HashMap<ModContainer, URL>();\r\n    for (ModContainer mod : Loader.instance().getActiveModList()) {\r\n        URL url = mod.getUpdateUrl();\r\n        if (url != null)\r\n            ret.put(mod, url);\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "io.requery.processor.EntityGraph.referencingEntity",
	"Comment": "given a association attribute in an entity find the entity the attribute is referencing.",
	"Method": "Optional<EntityDescriptor> referencingEntity(AttributeDescriptor attribute){\r\n    if (!Names.isEmpty(attribute.referencedTable())) {\r\n        return entities.values().stream().filter(entity -> entity.tableName().equalsIgnoreCase(attribute.referencedTable())).findFirst();\r\n    } else if (!Names.isEmpty(attribute.referencedType())) {\r\n        Optional<TypeKind> primitiveType = Stream.of(TypeKind.values()).filter(TypeKind::isPrimitive).filter(kind -> kind.toString().toLowerCase().equals(attribute.referencedType())).findFirst();\r\n        if (!primitiveType.isPresent()) {\r\n            QualifiedName referencedType = new QualifiedName(attribute.referencedType());\r\n            return entityByName(referencedType);\r\n        }\r\n    } else {\r\n        TypeMirror referencedType = attribute.typeMirror();\r\n        if (attribute.isIterable()) {\r\n            referencedType = collectionElementType(referencedType);\r\n        }\r\n        TypeElement referencedElement = (TypeElement) types.asElement(referencedType);\r\n        if (referencedElement != null) {\r\n            String referencedName = referencedElement.getSimpleName().toString();\r\n            return entities.values().stream().filter(entity -> match(entity, referencedName)).findFirst();\r\n        }\r\n    }\r\n    return Optional.empty();\r\n}"
}, {
	"Path": "io.restassured.authentication.FormAuthConfig.withLoggingEnabled",
	"Comment": "enables logging with the supplied logdetail of the request made to authenticate using form authentication.both the request and the response is logged.",
	"Method": "FormAuthConfig withLoggingEnabled(FormAuthConfig withLoggingEnabled,LogDetail logDetail,FormAuthConfig withLoggingEnabled,LogConfig logConfig,FormAuthConfig withLoggingEnabled,LogDetail logDetail,LogConfig logConfig){\r\n    notNull(logDetail, LogDetail.class);\r\n    notNull(logConfig, LogConfig.class);\r\n    return new FormAuthConfig(formAction, userInputTagName, passwordInputTagName, logDetail, logConfig, csrfFieldName, autoDetectCsrfFieldName, sendCsrfTokenAsFormParam, additionalInputFieldNames);\r\n}"
}, {
	"Path": "io.restassured.config.MatcherConfig.hasErrorDescriptionType",
	"Comment": "returns true if this config has the supplied errordescriptiontype, false otherwise.",
	"Method": "boolean hasErrorDescriptionType(ErrorDescriptionType errorDescriptionType){\r\n    return this.errorDescriptionType == errorDescriptionType;\r\n}"
}, {
	"Path": "ibxm.Player.play",
	"Comment": "open the audio device and begin playback.\t\tif a module is already playing it will be restarted.",
	"Method": "void play(){\r\n    stop();\r\n    play_thread = new Thread(new Driver());\r\n    play_thread.start();\r\n}"
}, {
	"Path": "co.paralleluniverse.common.util.ExtendedStackTraceElement.isNativeMethod",
	"Comment": "returns true if the method containing the execution pointrepresented by this stack trace element is a native method.",
	"Method": "boolean isNativeMethod(){\r\n    return lineNumber == -2;\r\n}"
}, {
	"Path": "com.alibaba.csp.sentinel.transport.command.SimpleHttpCommandCenter.getServerSocketFromBasePort",
	"Comment": "get a server socket from an available port from a base port.increasing on port number will occur when the port has already been used.",
	"Method": "ServerSocket getServerSocketFromBasePort(int basePort){\r\n    int tryCount = 0;\r\n    while (true) {\r\n        try {\r\n            ServerSocket server = new ServerSocket(basePort + tryCount / 3, 100);\r\n            server.setReuseAddress(true);\r\n            return server;\r\n        } catch (IOException e) {\r\n            tryCount++;\r\n            try {\r\n                TimeUnit.MILLISECONDS.sleep(30);\r\n            } catch (InterruptedException e1) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.AbstractQueuedLongSynchronizer.acquireQueued",
	"Comment": "acquires in exclusive uninterruptible mode for strand already inqueue. used by condition wait methods as well as acquire.",
	"Method": "boolean acquireQueued(Node node,long arg){\r\n    boolean failed = true;\r\n    try {\r\n        boolean interrupted = false;\r\n        for (; ; ) {\r\n            final Node p = node.predecessor();\r\n            if (p == head && tryAcquire(arg)) {\r\n                setHead(node);\r\n                p.next = null;\r\n                failed = false;\r\n                return interrupted;\r\n            }\r\n            if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt())\r\n                interrupted = true;\r\n        }\r\n    } finally {\r\n        if (failed)\r\n            cancelAcquire(node);\r\n    }\r\n}"
}, {
	"Path": "org.mapdb.jsr166.Collection8Test.testDetectRaces",
	"Comment": "motley crew of threads concurrently randomly hammer the collection.",
	"Method": "void testDetectRaces(){\r\n    if (!impl.isConcurrent())\r\n        return;\r\n    final ThreadLocalRandom rnd = ThreadLocalRandom.current();\r\n    final Collection c = impl.emptyCollection();\r\n    final long testDurationMillis = expensiveTests ? LONG_DELAY_MS : timeoutMillis();\r\n    final AtomicBoolean done = new AtomicBoolean(false);\r\n    final Object one = impl.makeElement(1);\r\n    final Object two = impl.makeElement(2);\r\n    final Consumer checkSanity = x -> assertTrue(x == one || x == two);\r\n    final Consumer<Object[]> checkArraySanity = array -> {\r\n        for (Object x : array) assertTrue(x == one || x == two);\r\n    };\r\n    final Object[] emptyArray = (Object[]) java.lang.reflect.Array.newInstance(one.getClass(), 0);\r\n    final List<Future<?>> futures;\r\n    final Phaser threadsStarted = new Phaser(1);\r\n    final Runnable[] frobbers = { () -> c.forEach(checkSanity), () -> c.stream().forEach(checkSanity), () -> c.parallelStream().forEach(checkSanity), () -> c.spliterator().trySplit(), () -> {\r\n        Spliterator s = c.spliterator();\r\n        s.tryAdvance(checkSanity);\r\n        s.trySplit();\r\n    }, () -> {\r\n        Spliterator s = c.spliterator();\r\n        do {\r\n        } while (s.tryAdvance(checkSanity));\r\n    }, () -> {\r\n        for (Object x : c) checkSanity.accept(x);\r\n    }, () -> checkArraySanity.accept(c.toArray()), () -> checkArraySanity.accept(c.toArray(emptyArray)), () -> {\r\n        Object[] a = new Object[5];\r\n        Object three = impl.makeElement(3);\r\n        Arrays.fill(a, 0, a.length, three);\r\n        Object[] x = c.toArray(a);\r\n        if (x == a)\r\n            for (int i = 0; i < a.length && a[i] != null; i++) checkSanity.accept(a[i]);\r\n        else\r\n            checkArraySanity.accept(x);\r\n    }, adderRemover(c, one), adderRemover(c, two) };\r\n    final List<Runnable> tasks = // random subset\r\n    Arrays.stream(frobbers).filter(task -> rnd.nextBoolean()).map(task -> (Runnable) () -> {\r\n        threadsStarted.arriveAndAwaitAdvance();\r\n        while (!done.get()) task.run();\r\n    }).collect(Collectors.toList());\r\n    final ExecutorService pool = Executors.newCachedThreadPool();\r\n    try (PoolCleaner cleaner = cleaner(pool, done)) {\r\n        threadsStarted.bulkRegister(tasks.size());\r\n        futures = tasks.stream().map(pool::submit).collect(Collectors.toList());\r\n        threadsStarted.arriveAndDeregister();\r\n        Thread.sleep(testDurationMillis);\r\n    }\r\n    for (Future future : futures) assertNull(future.get(0L, MILLISECONDS));\r\n}"
}, {
	"Path": "io.objectbox.query.PropertyQuery.min",
	"Comment": "finds the minimum value for the given property over all objects matching the query.",
	"Method": "long min(){\r\n    return (Long) query.callInReadTx(new Callable<Long>() {\r\n        @Override\r\n        public Long call() {\r\n            return nativeMin(queryHandle, query.cursorHandle(), propertyId);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "io.objectbox.query.PropertyQuery.min",
	"Comment": "finds the minimum value for the given property over all objects matching the query.",
	"Method": "long min(){\r\n    return nativeMin(queryHandle, query.cursorHandle(), propertyId);\r\n}"
}, {
	"Path": "io.objectbox.query.PropertyQuery.sum",
	"Comment": "sums up all values for the given property over all objects matching the query.",
	"Method": "long sum(){\r\n    return (Long) query.callInReadTx(new Callable<Long>() {\r\n        @Override\r\n        public Long call() {\r\n            return nativeSum(queryHandle, query.cursorHandle(), propertyId);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "io.objectbox.query.PropertyQuery.sum",
	"Comment": "sums up all values for the given property over all objects matching the query.",
	"Method": "long sum(){\r\n    return nativeSum(queryHandle, query.cursorHandle(), propertyId);\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.AbstractQueuedSynchronizer.addWaiter",
	"Comment": "creates and enqueues node for current strand and given mode.",
	"Method": "Node addWaiter(Node mode){\r\n    Node node = new Node(Strand.currentStrand(), mode);\r\n    Node pred = tail;\r\n    if (pred != null) {\r\n        node.prev = pred;\r\n        if (compareAndSetTail(pred, node)) {\r\n            pred.next = node;\r\n            return node;\r\n        }\r\n    }\r\n    enq(node);\r\n    return node;\r\n}"
}, {
	"Path": "io.restassured.builder.ResponseSpecBuilder.expectCookie",
	"Comment": "expect that a response cookie matches the supplied name and value.",
	"Method": "ResponseSpecBuilder expectCookie(String cookieName,Matcher<String> expectedValueMatcher,ResponseSpecBuilder expectCookie,String cookieName,DetailedCookieMatcher detailedCookieMatcher,ResponseSpecBuilder expectCookie,String cookieName,String expectedValue,ResponseSpecBuilder expectCookie,String cookieName){\r\n    spec.cookie(cookieName);\r\n    return this;\r\n}"
}, {
	"Path": "org.nanohttpd.junit.protocols.http.HttpKeepAliveTest.testManyRequests",
	"Comment": "issue the given request many times to check whether an error occurs. forthis test, a small stack size is used, since a stack overflow is amongthe possible errors.",
	"Method": "void testManyRequests(String request,String[] expected){\r\n    Runnable r = new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            try {\r\n                PipedOutputStream requestStream = new PipedOutputStream();\r\n                PipedInputStream inputStream = new PipedInputStream(requestStream);\r\n                ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\r\n                DefaultTempFileManager tempFileManager = new DefaultTempFileManager();\r\n                try {\r\n                    HTTPSession session = HttpKeepAliveTest.this.testServer.createSession(tempFileManager, inputStream, outputStream);\r\n                    for (int i = 0; i < 2048; i++) {\r\n                        requestStream.write(request.getBytes());\r\n                        requestStream.flush();\r\n                        outputStream.reset();\r\n                        session.execute();\r\n                        assertResponse(outputStream, expected);\r\n                    }\r\n                    String closeReq = request.replaceAll(\"HTTP/1.1\", \"HTTP/1.1\\r\\nConnection: Close\");\r\n                    expected[3] = \"Connection: close\";\r\n                    requestStream.write(closeReq.getBytes());\r\n                    outputStream.reset();\r\n                    requestStream.flush();\r\n                    try {\r\n                        session.execute();\r\n                    } catch (java.net.SocketException se) {\r\n                        junit.framework.Assert.assertEquals(se.getMessage(), \"NanoHttpd Shutdown\");\r\n                    }\r\n                    assertResponse(outputStream, expected);\r\n                } finally {\r\n                    tempFileManager.clear();\r\n                }\r\n            } catch (Throwable t) {\r\n                HttpKeepAliveTest.this.error = t;\r\n            }\r\n        }\r\n    };\r\n    Thread t = new Thread(null, r, \"Request Thread\", 1 << 17);\r\n    t.start();\r\n    t.join();\r\n    if (this.error != null) {\r\n        fail(\"\" + this.error);\r\n        this.error.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "org.nanohttpd.junit.protocols.http.HttpKeepAliveTest.testManyRequests",
	"Comment": "issue the given request many times to check whether an error occurs. forthis test, a small stack size is used, since a stack overflow is amongthe possible errors.",
	"Method": "void testManyRequests(String request,String[] expected){\r\n    try {\r\n        PipedOutputStream requestStream = new PipedOutputStream();\r\n        PipedInputStream inputStream = new PipedInputStream(requestStream);\r\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\r\n        DefaultTempFileManager tempFileManager = new DefaultTempFileManager();\r\n        try {\r\n            HTTPSession session = HttpKeepAliveTest.this.testServer.createSession(tempFileManager, inputStream, outputStream);\r\n            for (int i = 0; i < 2048; i++) {\r\n                requestStream.write(request.getBytes());\r\n                requestStream.flush();\r\n                outputStream.reset();\r\n                session.execute();\r\n                assertResponse(outputStream, expected);\r\n            }\r\n            String closeReq = request.replaceAll(\"HTTP/1.1\", \"HTTP/1.1\\r\\nConnection: Close\");\r\n            expected[3] = \"Connection: close\";\r\n            requestStream.write(closeReq.getBytes());\r\n            outputStream.reset();\r\n            requestStream.flush();\r\n            try {\r\n                session.execute();\r\n            } catch (java.net.SocketException se) {\r\n                junit.framework.Assert.assertEquals(se.getMessage(), \"NanoHttpd Shutdown\");\r\n            }\r\n            assertResponse(outputStream, expected);\r\n        } finally {\r\n            tempFileManager.clear();\r\n        }\r\n    } catch (Throwable t) {\r\n        HttpKeepAliveTest.this.error = t;\r\n    }\r\n}"
}, {
	"Path": "io.restassured.builder.ResponseSpecBuilder.expectHeader",
	"Comment": "expect that a response header matches the supplied name and value.",
	"Method": "ResponseSpecBuilder expectHeader(String headerName,Matcher<String> expectedValueMatcher,ResponseSpecBuilder expectHeader,String headerName,String expectedValue){\r\n    spec.header(headerName, expectedValue);\r\n    return this;\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.AbstractQueuedLongSynchronizer.getQueueLength",
	"Comment": "returns an estimate of the number of strands waiting toacquire.the value is only an estimate because the number ofstrands may change dynamically while this method traversesinternal data structures.this method is designed for use inmonitoring system state, not for synchronizationcontrol.",
	"Method": "int getQueueLength(){\r\n    int n = 0;\r\n    for (Node p = tail; p != null; p = p.prev) {\r\n        if (p.strand != null)\r\n            ++n;\r\n    }\r\n    return n;\r\n}"
}, {
	"Path": "org.mapdb.jsr166.Collection8Test.testStickySpliteratorExhaustion",
	"Comment": "concurrent spliterators, once exhausted, stay exhausted.",
	"Method": "void testStickySpliteratorExhaustion(){\r\n    if (!impl.isConcurrent())\r\n        return;\r\n    if (!testImplementationDetails)\r\n        return;\r\n    final ThreadLocalRandom rnd = ThreadLocalRandom.current();\r\n    final Consumer alwaysThrows = e -> {\r\n        throw new AssertionError();\r\n    };\r\n    final Collection c = impl.emptyCollection();\r\n    final Spliterator s = c.spliterator();\r\n    if (rnd.nextBoolean()) {\r\n        assertFalse(s.tryAdvance(alwaysThrows));\r\n    } else {\r\n        s.forEachRemaining(alwaysThrows);\r\n    }\r\n    final Object one = impl.makeElement(1);\r\n    c.add(one);\r\n    if (rnd.nextBoolean()) {\r\n        assertFalse(s.tryAdvance(alwaysThrows));\r\n    } else {\r\n        s.forEachRemaining(alwaysThrows);\r\n    }\r\n}"
}, {
	"Path": "com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean.setDatabaseIdProvider",
	"Comment": "sets the databaseidprovider.as of version 1.2.2 this variable is not initialized by default.",
	"Method": "void setDatabaseIdProvider(DatabaseIdProvider databaseIdProvider){\r\n    this.databaseIdProvider = databaseIdProvider;\r\n}"
}, {
	"Path": "io.restassured.internal.http.HttpRequestFactory.createHttpRequest",
	"Comment": "get the httprequest class that represents this request type.",
	"Method": "HttpRequestBase createHttpRequest(URI uri,String httpMethod,boolean hasBody){\r\n    String method = notNull(upperCase(trimToNull(httpMethod)), \"Http method\");\r\n    Class<? extends HttpRequestBase> type = HTTP_METHOD_TO_HTTP_REQUEST_TYPE.get(method);\r\n    final HttpRequestBase httpRequest;\r\n    if (type == null || (!(type.isInstance(HttpEntityEnclosingRequest.class)) && hasBody)) {\r\n        httpRequest = new CustomHttpMethod(method, uri);\r\n    } else {\r\n        try {\r\n            httpRequest = type.newInstance();\r\n        } catch (Exception e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n        httpRequest.setURI(uri);\r\n    }\r\n    return httpRequest;\r\n}"
}, {
	"Path": "io.restassured.http.Cookie.getDomain",
	"Comment": "returns domain attribute of the cookie. the value of the domainattribute specifies the domain for which the cookie is valid.",
	"Method": "String getDomain(){\r\n    return domain;\r\n}"
}, {
	"Path": "org.springframework.security.cas.web.CasAuthenticationEntryPoint.setEncodeServiceUrlWithSessionId",
	"Comment": "sets whether to encode the service url with the session id or not.",
	"Method": "void setEncodeServiceUrlWithSessionId(boolean encodeServiceUrlWithSessionId){\r\n    this.encodeServiceUrlWithSessionId = encodeServiceUrlWithSessionId;\r\n}"
}, {
	"Path": "net.minecraftforge.items.SlotItemHandler.putStack",
	"Comment": "override if your iitemhandler does not implement iitemhandlermodifiable",
	"Method": "void putStack(ItemStack stack){\r\n    ((IItemHandlerModifiable) this.getItemHandler()).setStackInSlot(index, stack);\r\n    this.onSlotChanged();\r\n}"
}, {
	"Path": "io.restassured.matcher.DetailedCookieMatcher.path",
	"Comment": "verifies whether path of cookie satisfies specified matcher.",
	"Method": "DetailedCookieMatcher path(String expectedPath,DetailedCookieMatcher path,Matcher<? super String> pathMatcher){\r\n    return new DetailedCookieMatcher(and(Matchers.<Cookie>hasProperty(\"path\", pathMatcher)));\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.CyclicBarrier.nextGeneration",
	"Comment": "updates state on barrier trip and wakes up everyone.called only while holding lock.",
	"Method": "void nextGeneration(){\r\n    trip.signalAll();\r\n    count = parties;\r\n    generation = new Generation();\r\n}"
}, {
	"Path": "com.mcxiaoke.packer.cli.Options.getRequiredValue",
	"Comment": "returns the value of the current option, throwing an exception if the value is missing.",
	"Method": "String getRequiredValue(String valueDescription){\r\n    if (lastOptionValue != null) {\r\n        String result = lastOptionValue;\r\n        lastOptionValue = null;\r\n        return result;\r\n    }\r\n    if (index >= params.length) {\r\n        throw new OptionsException(valueDescription + \" missing after \" + lastOptionOriginalForm);\r\n    }\r\n    String param = params[index];\r\n    if (\"--\".equals(param)) {\r\n        throw new OptionsException(valueDescription + \" missing after \" + lastOptionOriginalForm);\r\n    }\r\n    index++;\r\n    return param;\r\n}"
}, {
	"Path": "net.minecraftforge.common.config.Property.isDoubleList",
	"Comment": "checks if all of the current values stored in this property can be converted to a double.",
	"Method": "boolean isDoubleList(){\r\n    if (isList && type == Type.DOUBLE)\r\n        for (String value : values) {\r\n            try {\r\n                Double.parseDouble(value);\r\n            } catch (NumberFormatException e) {\r\n                return false;\r\n            }\r\n        }\r\n    return isList && type == Type.DOUBLE;\r\n}"
}, {
	"Path": "io.restassured.config.OAuthConfig.shouldAddEmptyAccessOAuthTokenToBaseString",
	"Comment": "returns whether or not add an empty oauth token for oauth1 while generating base string.",
	"Method": "boolean shouldAddEmptyAccessOAuthTokenToBaseString(){\r\n    return addEmptyAccessTokenToBaseString;\r\n}"
}, {
	"Path": "com.rxjava2.android.samples.ui.operators.DisposableExampleActivity.doSomeWork",
	"Comment": "example to understand how to use disposables.disposables is cleared in ondestroy of this activity.",
	"Method": "void doSomeWork(){\r\n    disposables.add(// Run on a background thread\r\n    sampleObservable().subscribeOn(// Be notified on the main thread\r\n    Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).subscribeWith(new DisposableObserver<String>() {\r\n        @Override\r\n        public void onComplete() {\r\n            textView.append(\" onComplete\");\r\n            textView.append(AppConstant.LINE_SEPARATOR);\r\n            Log.d(TAG, \" onComplete\");\r\n        }\r\n        @Override\r\n        public void onError(Throwable e) {\r\n            textView.append(\" onError : \" + e.getMessage());\r\n            textView.append(AppConstant.LINE_SEPARATOR);\r\n            Log.d(TAG, \" onError : \" + e.getMessage());\r\n        }\r\n        @Override\r\n        public void onNext(String value) {\r\n            textView.append(\" onNext : value : \" + value);\r\n            textView.append(AppConstant.LINE_SEPARATOR);\r\n            Log.d(TAG, \" onNext value : \" + value);\r\n        }\r\n    }));\r\n}"
}, {
	"Path": "com.rxjava2.android.samples.ui.operators.DisposableExampleActivity.doSomeWork",
	"Comment": "example to understand how to use disposables.disposables is cleared in ondestroy of this activity.",
	"Method": "void doSomeWork(){\r\n    textView.append(\" onComplete\");\r\n    textView.append(AppConstant.LINE_SEPARATOR);\r\n    Log.d(TAG, \" onComplete\");\r\n}"
}, {
	"Path": "com.rxjava2.android.samples.ui.operators.DisposableExampleActivity.doSomeWork",
	"Comment": "example to understand how to use disposables.disposables is cleared in ondestroy of this activity.",
	"Method": "void doSomeWork(){\r\n    textView.append(\" onError : \" + e.getMessage());\r\n    textView.append(AppConstant.LINE_SEPARATOR);\r\n    Log.d(TAG, \" onError : \" + e.getMessage());\r\n}"
}, {
	"Path": "com.rxjava2.android.samples.ui.operators.DisposableExampleActivity.doSomeWork",
	"Comment": "example to understand how to use disposables.disposables is cleared in ondestroy of this activity.",
	"Method": "void doSomeWork(){\r\n    textView.append(\" onNext : value : \" + value);\r\n    textView.append(AppConstant.LINE_SEPARATOR);\r\n    Log.d(TAG, \" onNext value : \" + value);\r\n}"
}, {
	"Path": "org.nanohttpd.protocols.http.response.Response.getCookieHeaders",
	"Comment": "should not be called manually. this is an internally utility for junittest purposes.",
	"Method": "List<String> getCookieHeaders(){\r\n    return cookieHeaders;\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.channels.ThreadSendPort.trySend",
	"Comment": "sends a message to the channel if the channel has room available. this method never blocks.",
	"Method": "boolean trySend(Message message){\r\n    return p.trySend(message);\r\n}"
}, {
	"Path": "net.minecraftforge.common.command.SelectorHandlerManager.getHandler",
	"Comment": "returns the best matching handler for the given string. defaults to the vanilla handler if no prefix applies",
	"Method": "SelectorHandler getHandler(String selectorStr){\r\n    if (!selectorStr.isEmpty()) {\r\n        for (final Entry<String, SelectorHandler> handler : selectorHandlers.subMap(selectorStr, true, selectorStr.substring(0, 1), true).entrySet()) {\r\n            if (selectorStr.startsWith(handler.getKey())) {\r\n                return handler.getValue();\r\n            }\r\n        }\r\n    }\r\n    return vanillaHandler;\r\n}"
}, {
	"Path": "org.springframework.security.config.annotation.web.configurers.RememberMeConfigurer.validateInput",
	"Comment": "validate remembermeservices and remembermecookiename have not been set at\tthe same time.",
	"Method": "void validateInput(){\r\n    if (this.rememberMeServices != null && this.rememberMeCookieName != DEFAULT_REMEMBER_ME_NAME) {\r\n        throw new IllegalArgumentException(\"Can not set rememberMeCookieName \" + \"and custom rememberMeServices.\");\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.cas.authentication.CasAuthenticationProvider.loadUserByAssertion",
	"Comment": "template method for retrieving the userdetails based on the assertion. default is\tto call configured userdetailsservice and pass the username. deployers can override\tthis method and retrieve the user based on any criteria they desire.",
	"Method": "UserDetails loadUserByAssertion(Assertion assertion){\r\n    final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken(assertion, \"\");\r\n    return this.authenticationUserDetailsService.loadUserDetails(token);\r\n}"
}, {
	"Path": "io.restassured.config.ConnectionConfig.closeIdleConnectionsAfterEachResponse",
	"Comment": "close open connections after each response. this is required if you plan to make a lot ofconsecutive requests with small response bodies. it can also be enabled if you never receivechunked http responses.",
	"Method": "ConnectionConfig closeIdleConnectionsAfterEachResponse(){\r\n    return new ConnectionConfig(new CloseIdleConnectionConfig(0, NANOSECONDS));\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.Phaser.getUnarrivedParties",
	"Comment": "returns the number of registered parties that have not yetarrived at the current phase of this phaser. if this phaser hasterminated, the returned value is meaningless and arbitrary.",
	"Method": "int getUnarrivedParties(){\r\n    return unarrivedOf(reconcileState());\r\n}"
}, {
	"Path": "io.restassured.matcher.DetailedCookieMatcher.secured",
	"Comment": "verifies whether secured property of cookie satisfies specified matcher.",
	"Method": "DetailedCookieMatcher secured(boolean expectedSecuredValue,DetailedCookieMatcher secured,Matcher<? super Boolean> securedMatcher){\r\n    return new DetailedCookieMatcher(and(Matchers.<Cookie>hasProperty(\"secured\", securedMatcher)));\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.AbstractQueuedSynchronizer.findNodeFromTail",
	"Comment": "returns true if node is on sync queue by searching backwards from tail.called only when needed by isonsyncqueue.",
	"Method": "boolean findNodeFromTail(Node node){\r\n    Node t = tail;\r\n    for (; ; ) {\r\n        if (t == node)\r\n            return true;\r\n        if (t == null)\r\n            return false;\r\n        t = t.prev;\r\n    }\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.Strand.dumpStack",
	"Comment": "prints a stack trace of the current strand to the standard error stream.this method is used only for debugging.",
	"Method": "void dumpStack(){\r\n    if (isCurrentFiber())\r\n        Fiber.dumpStack();\r\n    else\r\n        Thread.dumpStack();\r\n}"
}, {
	"Path": "org.mapdb.jsr166.LinkedBlockingDeque8Test.testSpliterator_getComparator",
	"Comment": "spliterator.getcomparator always throws illegalstateexception",
	"Method": "void testSpliterator_getComparator(){\r\n    assertThrows(IllegalStateException.class, () -> newDeque().spliterator().getComparator());\r\n}"
}, {
	"Path": "net.minecraftforge.event.AttachCapabilitiesEvent.getObject",
	"Comment": "retrieves the object that is being created, not much state is set.",
	"Method": "T getObject(){\r\n    return this.obj;\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.StampedLock.tryOptimisticRead",
	"Comment": "returns a stamp that can later be validated, or zeroif exclusively locked.",
	"Method": "long tryOptimisticRead(){\r\n    long s;\r\n    return (((s = state) & WBIT) == 0L) ? (s & SBITS) : 0L;\r\n}"
}, {
	"Path": "io.restassured.matcher.DetailedCookieMatcher.domain",
	"Comment": "verifies whether domain of cookie satisfies specified matcher.",
	"Method": "DetailedCookieMatcher domain(String expectedDomain,DetailedCookieMatcher domain,Matcher<? super String> domainMatcher){\r\n    return new DetailedCookieMatcher(and(Matchers.<Cookie>hasProperty(\"domain\", domainMatcher)));\r\n}"
}, {
	"Path": "io.restassured.config.XmlConfig.isValidating",
	"Comment": "whether xmlpath should validate documents as they are parsed.",
	"Method": "boolean isValidating(){\r\n    return validating;\r\n}"
}, {
	"Path": "org.mapdb.jsr166.LinkedBlockingDequeTest.testConstructor5",
	"Comment": "initializing from collection with some null elements throwsnullpointerexception",
	"Method": "void testConstructor5(){\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE - 1; ++i) ints[i] = i;\r\n    Collection<Integer> elements = Arrays.asList(ints);\r\n    try {\r\n        new LinkedBlockingDeque(elements);\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "org.mapdb.jsr166.LinkedBlockingDequeTest.testConstructor4",
	"Comment": "initializing from collection of null elements throws nullpointerexception",
	"Method": "void testConstructor4(){\r\n    Collection<Integer> elements = Arrays.asList(new Integer[SIZE]);\r\n    try {\r\n        new LinkedBlockingDeque(elements);\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "org.mapdb.jsr166.LinkedBlockingDequeTest.testConstructor3",
	"Comment": "initializing from null collection throws nullpointerexception",
	"Method": "void testConstructor3(){\r\n    try {\r\n        new LinkedBlockingDeque(null);\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.acls.jdbc.BasicLookupStrategy.setLookupPrimaryKeysWhereClause",
	"Comment": "the sql for the where clause used in the lookupprimarykey method.",
	"Method": "void setLookupPrimaryKeysWhereClause(String lookupPrimaryKeysWhereClause){\r\n    this.lookupPrimaryKeysWhereClause = lookupPrimaryKeysWhereClause;\r\n}"
}, {
	"Path": "org.mapdb.jsr166.LinkedBlockingDequeTest.testConstructor2",
	"Comment": "constructor throws illegalargumentexception if capacity argument nonpositive",
	"Method": "void testConstructor2(){\r\n    try {\r\n        new LinkedBlockingDeque(0);\r\n        shouldThrow();\r\n    } catch (IllegalArgumentException success) {\r\n    }\r\n}"
}, {
	"Path": "co.paralleluniverse.common.util.ServiceUtil.loadSingletonServiceOrNull",
	"Comment": "loads a service of the given type and ensures it has either one implementation or none.",
	"Method": "T loadSingletonServiceOrNull(Class<T> type){\r\n    final ServiceLoader<T> loader = ServiceLoader.load(type);\r\n    ArrayList<T> services = new ArrayList();\r\n    for (T service : loader) services.add(service);\r\n    final T service;\r\n    if (services.size() == 1)\r\n        service = services.iterator().next();\r\n    else {\r\n        if (services.isEmpty())\r\n            service = null;\r\n        else\r\n            throw new Error(\"Several implementations of \" + type.getName() + \" found: \" + services);\r\n    }\r\n    return service;\r\n}"
}, {
	"Path": "io.requery.processor.EntityGraph.mappedAttributes",
	"Comment": "given an association in an entity find the attributes it maps onto in the referenced entity.",
	"Method": "Set<AttributeDescriptor> mappedAttributes(EntityDescriptor entity,AttributeDescriptor attribute,EntityDescriptor referenced){\r\n    String mappedBy = attribute.mappedBy();\r\n    if (Names.isEmpty(mappedBy)) {\r\n        return referenced.attributes().stream().filter(other -> other.cardinality() != null).filter(other -> referencingEntity(other).isPresent()).filter(other -> referencingEntity(other).orElseThrow(IllegalStateException::new) == entity).collect(Collectors.toSet());\r\n    } else {\r\n        return referenced.attributes().stream().filter(other -> other.name().equals(mappedBy)).collect(Collectors.toSet());\r\n    }\r\n}"
}, {
	"Path": "io.restassured.internal.MultiValueEntity.get",
	"Comment": "get a single entity with the supplied name. if there are several entities match the entityname then the last one is returned.",
	"Method": "T get(String entityName){\r\n    notNull(entityName, \"Entity name\");\r\n    List<T> copyOfEntities = reverse();\r\n    for (T entity : copyOfEntities) {\r\n        if (entity.getName().equalsIgnoreCase(entityName)) {\r\n            return entity;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.AbstractQueuedSynchronizer.getWaitQueueLength",
	"Comment": "returns an estimate of the number of strands waiting on thegiven condition associated with this synchronizer. note thatbecause timeouts and interrupts may occur at any time, theestimate serves only as an upper bound on the actual number ofwaiters.this method is designed for use in monitoring of thesystem state, not for synchronization control.",
	"Method": "int getWaitQueueLength(ConditionObject condition,int getWaitQueueLength){\r\n    if (!owns(condition))\r\n        throw new IllegalArgumentException(\"Not owner\");\r\n    return condition.getWaitQueueLength();\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.channels.ThreadSendPort.close",
	"Comment": "closes the channel so that no more messages could be sent to it.",
	"Method": "void close(){\r\n    p.close();\r\n}"
}, {
	"Path": "org.reflections.Reflections.getSubTypesOf",
	"Comment": "gets all sub types in hierarchy of a given typedepends on subtypesscanner configured",
	"Method": "Set<Class<? extends T>> getSubTypesOf(Class<T> type){\r\n    return Sets.newHashSet(ReflectionUtils.<T>forNames(store.getAll(index(SubTypesScanner.class), Arrays.asList(type.getName())), loaders()));\r\n}"
}, {
	"Path": "co.paralleluniverse.concurrent.util.ConcurrentSkipListPriorityQueue.clearIndexToFirst",
	"Comment": "clears out index nodes associated with deleted first entry.",
	"Method": "void clearIndexToFirst(){\r\n    for (; ; ) {\r\n        Index<E> q = head;\r\n        for (; ; ) {\r\n            Index<E> r = q.right;\r\n            if (r != null && r.indexesDeletedNode() && !q.unlink(r))\r\n                break;\r\n            if ((q = q.down) == null) {\r\n                if (head.right == null)\r\n                    tryReduceLevel();\r\n                return;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.restassured.module.webtestclient.specification.WebTestClientRequestSpecBuilder.setConfig",
	"Comment": "define a configuration for redirection settings and http client parameters.",
	"Method": "WebTestClientRequestSpecBuilder setConfig(RestAssuredWebTestClientConfig config){\r\n    spec.config(config);\r\n    return this;\r\n}"
}, {
	"Path": "io.restassured.internal.http.HttpResponseDecorator.isSuccess",
	"Comment": "quickly determine if the request resulted in an error code.",
	"Method": "boolean isSuccess(){\r\n    return Status.find(getStatus()) == Status.SUCCESS;\r\n}"
}, {
	"Path": "net.minecraftforge.fml.common.toposort.TopologicalSort.topologicalSort",
	"Comment": "sort the input graph into a topologically sorted listuses the reverse depth first search as outlined in ...",
	"Method": "List<T> topologicalSort(DirectedGraph<T> graph){\r\n    DirectedGraph<T> rGraph = reverse(graph);\r\n    List<T> sortedResult = new ArrayList<T>();\r\n    Set<T> visitedNodes = new HashSet<T>();\r\n    Set<T> expandedNodes = new HashSet<T>();\r\n    for (T node : rGraph) {\r\n        explore(node, rGraph, sortedResult, visitedNodes, expandedNodes);\r\n    }\r\n    return sortedResult;\r\n}"
}, {
	"Path": "io.restassured.module.webtestclient.RestAssuredWebTestClient.delete",
	"Comment": "perform a delete request to the statically configured base path.",
	"Method": "WebTestClientResponse delete(String path,Object pathParams,WebTestClientResponse delete,String path,Map<String, ?> pathParams,WebTestClientResponse delete,Function<UriBuilder, URI> uriFunction,WebTestClientResponse delete,URI uri,WebTestClientResponse delete,URL url,WebTestClientResponse delete){\r\n    return given().delete();\r\n}"
}, {
	"Path": "org.mapdb.jsr166.LinkedBlockingDequeTest.testBlockingTake",
	"Comment": "take removes existing elements until empty, then blocks interruptibly",
	"Method": "void testBlockingTake(){\r\n    final BlockingDeque q = populatedDeque(SIZE);\r\n    final CountDownLatch pleaseInterrupt = new CountDownLatch(1);\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            for (int i = 0; i < SIZE; i++) assertEquals(i, q.take());\r\n            Thread.currentThread().interrupt();\r\n            try {\r\n                q.take();\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n            }\r\n            assertFalse(Thread.interrupted());\r\n            pleaseInterrupt.countDown();\r\n            try {\r\n                q.take();\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n            }\r\n            assertFalse(Thread.interrupted());\r\n        }\r\n    });\r\n    await(pleaseInterrupt);\r\n    assertThreadBlocks(t, Thread.State.WAITING);\r\n    t.interrupt();\r\n    awaitTermination(t);\r\n}"
}, {
	"Path": "org.mapdb.jsr166.LinkedBlockingDequeTest.testBlockingTake",
	"Comment": "take removes existing elements until empty, then blocks interruptibly",
	"Method": "void testBlockingTake(){\r\n    for (int i = 0; i < SIZE; i++) assertEquals(i, q.take());\r\n    Thread.currentThread().interrupt();\r\n    try {\r\n        q.take();\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n    }\r\n    assertFalse(Thread.interrupted());\r\n    pleaseInterrupt.countDown();\r\n    try {\r\n        q.take();\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n    }\r\n    assertFalse(Thread.interrupted());\r\n}"
}, {
	"Path": "io.restassured.module.mockmvc.matcher.RestAssuredMockMvcMatchers.matchesXsdInClasspath",
	"Comment": "evaluates to true if an xml file in classpath matches the supplied xsd.",
	"Method": "Matcher<String> matchesXsdInClasspath(String path){\r\n    return XmlXsdMatcher.matchesXsdInClasspath(path);\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.AbstractQueuedSynchronizer.setHead",
	"Comment": "sets head of queue to be node, thus dequeuing. called only byacquire methods.also nulls out unused fields for sake of gcand to suppress unnecessary signals and traversals.",
	"Method": "void setHead(Node node){\r\n    head = node;\r\n    node.strand = null;\r\n    node.prev = null;\r\n}"
}, {
	"Path": "co.paralleluniverse.fibers.FiberAsync.asyncCompleted",
	"Comment": "this method must be called by the callback upon successful completion of the asynchronous operation.",
	"Method": "void asyncCompleted(V result){\r\n    if (completed)\r\n        return;\r\n    this.result = result;\r\n    completed = true;\r\n    fire(fiber);\r\n}"
}, {
	"Path": "org.springframework.security.acls.afterinvocation.AbstractAclProvider.supports",
	"Comment": "this implementation supports any type of class, because it does not query the\tpresented secure object.",
	"Method": "boolean supports(ConfigAttribute attribute,boolean supports,Class<?> clazz){\r\n    return true;\r\n}"
}, {
	"Path": "io.restassured.http.Cookie.getVersion",
	"Comment": "gets the version of the cookie protocol this cookie complies with. version 0 complies with the original netscape cookie specification. version 1 complies with rfc 2109.",
	"Method": "int getVersion(){\r\n    return version;\r\n}"
}, {
	"Path": "io.restassured.module.jsv.JsonSchemaValidator.using",
	"Comment": "validate the json document using the supplied jsonschemavalidatorsettings instance.",
	"Method": "Matcher<?> using(JsonSchemaFactory jsonSchemaFactory,Matcher<?> using,JsonSchemaValidatorSettings jsonSchemaValidatorSettings){\r\n    return new JsonSchemaValidator(schema, jsonSchemaValidatorSettings);\r\n}"
}, {
	"Path": "org.reflections.util.ConfigurationBuilder.setMetadataAdapter",
	"Comment": "sets the metadata adapter used to fetch metadata from classes",
	"Method": "ConfigurationBuilder setMetadataAdapter(MetadataAdapter metadataAdapter){\r\n    this.metadataAdapter = metadataAdapter;\r\n    return this;\r\n}"
}, {
	"Path": "org.mapdb.jsr166.JSR166TestCase.testInParallel",
	"Comment": "runs all the given actions in parallel, failing if any fail.useful for running multiple variants of tests that arenecessarily individually slow because they must block.",
	"Method": "void testInParallel(Action actions){\r\n    ExecutorService pool = Executors.newCachedThreadPool();\r\n    try (PoolCleaner cleaner = cleaner(pool)) {\r\n        ArrayList<Future<?>> futures = new ArrayList(actions.length);\r\n        for (final Action action : actions) futures.add(pool.submit(new CheckedRunnable() {\r\n            public void realRun() throws Throwable {\r\n                action.run();\r\n            }\r\n        }));\r\n        for (Future<?> future : futures) try {\r\n            assertNull(future.get(LONG_DELAY_MS, MILLISECONDS));\r\n        } catch (ExecutionException ex) {\r\n            threadUnexpectedException(ex.getCause());\r\n        } catch (Exception ex) {\r\n            threadUnexpectedException(ex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.mapdb.jsr166.JSR166TestCase.testInParallel",
	"Comment": "runs all the given actions in parallel, failing if any fail.useful for running multiple variants of tests that arenecessarily individually slow because they must block.",
	"Method": "void testInParallel(Action actions){\r\n    action.run();\r\n}"
}, {
	"Path": "org.springframework.security.config.annotation.web.configurers.RememberMeConfigurer.getRememberMeParameter",
	"Comment": "returns the http parameter used to indicate to remember the user at time of login.",
	"Method": "String getRememberMeParameter(){\r\n    return this.rememberMeParameter;\r\n}"
}, {
	"Path": "co.paralleluniverse.actors.behaviors.SupervisorActor.getChildren",
	"Comment": "retrieves the children actor references as an immutable list.",
	"Method": "List<? extends ActorRef<?>> getChildren(){\r\n    verifyInActor();\r\n    final ImmutableList.Builder builder = new ImmutableList.Builder();\r\n    for (final ChildEntry ce : children) builder.add(ce.actor);\r\n    return builder.build();\r\n}"
}, {
	"Path": "io.restassured.config.HttpClientConfig.addParams",
	"Comment": "add the given parameters to an already configured number of parameters.",
	"Method": "HttpClientConfig addParams(Map<String, ?> httpClientParams){\r\n    notNull(httpClientParams, \"httpClientParams\");\r\n    final Map<String, Object> newParams = new HashMap<String, Object>(this.httpClientParams);\r\n    newParams.putAll(httpClientParams);\r\n    return new HttpClientConfig(httpClientFactory, newParams, httpMultipartMode, shouldReuseHttpClientInstance, NO_HTTP_CLIENT, true);\r\n}"
}, {
	"Path": "net.minecraftforge.common.brewing.BrewingRecipeRegistry.canBrew",
	"Comment": "used by the brewing stand to determine if its contents can be brewed.extra parameters exist to allow modders to create bigger brewing standswithout much hassle",
	"Method": "boolean canBrew(NonNullList<ItemStack> inputs,ItemStack ingredient,int[] inputIndexes){\r\n    if (ingredient.isEmpty())\r\n        return false;\r\n    for (int i : inputIndexes) {\r\n        if (hasOutput(inputs.get(i), ingredient)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "io.requery.sql.ParameterInliner.sql",
	"Comment": "the modified sql statement where ? placeholders have been added for inlined elements.",
	"Method": "String sql(){\r\n    return sql;\r\n}"
}, {
	"Path": "org.mapdb.jsr166.JSR166TestCase.assertThreadBlocks",
	"Comment": "checks that thread eventually enters the expected blocked thread state.",
	"Method": "void assertThreadBlocks(Thread thread,Thread.State expected){\r\n    for (long retries = LONG_DELAY_MS * 3 / 4; retries-- > 0; ) {\r\n        try {\r\n            delay(1);\r\n        } catch (InterruptedException fail) {\r\n            throw new AssertionError(\"Unexpected InterruptedException\", fail);\r\n        }\r\n        Thread.State s = thread.getState();\r\n        if (s == expected)\r\n            return;\r\n        else if (s == Thread.State.TERMINATED)\r\n            fail(\"Unexpected thread termination\");\r\n    }\r\n    fail(\"timed out waiting for thread to enter thread state \" + expected);\r\n}"
}, {
	"Path": "io.restassured.path.xml.XmlPath.getInt",
	"Comment": "get the result of an xml path expression as an int. for syntax details please refer tothis url.",
	"Method": "int getInt(String path){\r\n    final Object object = get(path);\r\n    return convertObjectTo(object, Integer.class);\r\n}"
}, {
	"Path": "org.mapdb.jsr166.LinkedBlockingQueue8Test.testSpliterator_getComparator",
	"Comment": "spliterator.getcomparator always throws illegalstateexception",
	"Method": "void testSpliterator_getComparator(){\r\n    assertThrows(IllegalStateException.class, () -> new LinkedBlockingQueue().spliterator().getComparator());\r\n}"
}, {
	"Path": "com.uber.nullaway.jarinfer.JarInfer.main",
	"Comment": "this is the main method of the cli tool. it parses the arguments, invokes the analysis driverand checks that the output file is written.",
	"Method": "void main(String[] args){\r\n    Options options = new Options();\r\n    HelpFormatter hf = new HelpFormatter();\r\n    hf.setWidth(100);\r\n    options.addOption(Option.builder(\"i\").argName(\"in_path\").longOpt(\"input-file\").hasArg().required().desc(\"path to target jar/aar file\").build());\r\n    options.addOption(Option.builder(\"p\").argName(\"pkg_name\").longOpt(\"package\").hasArg().desc(\"qualified package name\").build());\r\n    options.addOption(Option.builder(\"o\").argName(\"out_path\").longOpt(\"output-file\").hasArg().required().desc(\"path to processed jar/aar file\").build());\r\n    options.addOption(Option.builder(\"h\").argName(\"help\").longOpt(\"help\").desc(\"print usage information\").build());\r\n    options.addOption(Option.builder(\"d\").argName(\"debug\").longOpt(\"debug\").desc(\"print debug information\").build());\r\n    options.addOption(Option.builder(\"v\").argName(\"verbose\").longOpt(\"verbose\").desc(\"set verbosity\").build());\r\n    try {\r\n        CommandLine line = new DefaultParser().parse(options, args);\r\n        if (line.hasOption('h')) {\r\n            hf.printHelp(appName, options, true);\r\n            return;\r\n        }\r\n        String jarPath = line.getOptionValue('i');\r\n        String pkgName = line.getOptionValue('p', \"\");\r\n        String outPath = line.getOptionValue('o');\r\n        boolean debug = line.hasOption('d');\r\n        boolean verbose = line.hasOption('v');\r\n        if (!pkgName.isEmpty()) {\r\n            pkgName = \"L\" + pkgName.replaceAll(\"\\\\.\", \"/\");\r\n        }\r\n        DefinitelyDerefedParamsDriver.run(jarPath, pkgName, outPath, debug, verbose);\r\n        if (!new File(outPath).exists()) {\r\n            System.out.println(\"Could not write jar file: \" + outPath);\r\n        }\r\n    } catch (ParseException pe) {\r\n        hf.printHelp(appName, options, true);\r\n    }\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.StampedLock.writeLock",
	"Comment": "exclusively acquires the lock, blocking if necessaryuntil available.",
	"Method": "long writeLock(Lock writeLock){\r\n    try {\r\n        long s, next;\r\n        return ((((s = state) & ABITS) == 0L && STATE.compareAndSet(this, s, next = s + WBIT)) ? next : acquireWrite(false, 0L));\r\n    } catch (SuspendExecution e) {\r\n        throw new AssertionError();\r\n    }\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.AbstractQueuedLongSynchronizer.isOnSyncQueue",
	"Comment": "returns true if a node, always one that was initially placed ona condition queue, is now waiting to reacquire on sync queue.",
	"Method": "boolean isOnSyncQueue(Node node){\r\n    if (node.waitStatus == Node.CONDITION || node.prev == null)\r\n        return false;\r\n    if (node.next != null)\r\n        return true;\r\n    return findNodeFromTail(node);\r\n}"
}, {
	"Path": "net.minecraftforge.client.resource.ReloadRequirements.include",
	"Comment": "creates an inclusive reload predicate. only given resource types will be loaded along with this.",
	"Method": "Predicate<IResourceType> include(IResourceType inclusion){\r\n    Set<IResourceType> inclusionSet = Sets.newHashSet(inclusion);\r\n    return inclusionSet::contains;\r\n}"
}, {
	"Path": "net.minecraftforge.common.config.Property.setRequiresMcRestart",
	"Comment": "sets whether or not this property requires minecraft to be restarted when changed.defaults to false. setting this flag to true will also disable editing ofthis property while a world is running.",
	"Method": "Property setRequiresMcRestart(boolean requiresMcRestart){\r\n    this.requiresMcRestart = this.requiresWorldRestart = requiresMcRestart;\r\n    return this;\r\n}"
}, {
	"Path": "co.paralleluniverse.actors.ActorRef.trySend",
	"Comment": "sends a message to the actor if the channel has mailbox available. this method never blocks.",
	"Method": "boolean trySend(Message msg){\r\n    try {\r\n        return getImpl().trySend(msg);\r\n    } catch (RuntimeException e) {\r\n        LostActor.instance.ref().trySend(msg);\r\n        LostActor.instance.throwIn(e);\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "io.objectbox.query.PropertyQuery.minDouble",
	"Comment": "finds the minimum value for the given property over all objects matching the query.",
	"Method": "double minDouble(){\r\n    return (Double) query.callInReadTx(new Callable<Double>() {\r\n        @Override\r\n        public Double call() {\r\n            return nativeMinDouble(queryHandle, query.cursorHandle(), propertyId);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "io.objectbox.query.PropertyQuery.minDouble",
	"Comment": "finds the minimum value for the given property over all objects matching the query.",
	"Method": "double minDouble(){\r\n    return nativeMinDouble(queryHandle, query.cursorHandle(), propertyId);\r\n}"
}, {
	"Path": "net.minecraftforge.server.permission.PermissionAPI.hasPermission",
	"Comment": "shortcut method using entityplayer and creating playercontext",
	"Method": "boolean hasPermission(GameProfile profile,String node,IContext context,boolean hasPermission,EntityPlayer player,String node){\r\n    Preconditions.checkNotNull(player, \"Player can't be null!\");\r\n    return hasPermission(player.getGameProfile(), node, new PlayerContext(player));\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.channels.TransferChannel.firstOfMode",
	"Comment": "returns the first unmatched node of the given mode, or null ifnone. used by methods isempty, haswaitingconsumer.",
	"Method": "Node firstOfMode(boolean isData){\r\n    for (Node p = head; p != null; p = succ(p)) {\r\n        if (!p.isMatched())\r\n            return (p.isData == isData) ? p : null;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.StampedLock.tryUnlockWrite",
	"Comment": "releases the write lock if it is held, without requiring astamp value. this method may be useful for recovery aftererrors.",
	"Method": "boolean tryUnlockWrite(){\r\n    long s;\r\n    WNode h;\r\n    if (((s = state) & WBIT) != 0L) {\r\n        state = (s += WBIT) == 0L ? ORIGIN : s;\r\n        if ((h = whead) != null && h.status != 0)\r\n            release(h);\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.mapdb.jsr166.LinkedBlockingDequeTest.testConstructor6",
	"Comment": "deque contains all elements of collection used to initialize",
	"Method": "void testConstructor6(){\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE; ++i) ints[i] = i;\r\n    BlockingDeque q = new LinkedBlockingDeque(Arrays.asList(ints));\r\n    for (int i = 0; i < SIZE; ++i) assertEquals(ints[i], q.poll());\r\n}"
}, {
	"Path": "net.minecraftforge.common.BiomeDictionary.ensureHasTypes",
	"Comment": "ensure that at least one type has been added to the given biome.",
	"Method": "void ensureHasTypes(Biome biome){\r\n    if (!hasAnyType(biome)) {\r\n        makeBestGuess(biome);\r\n        FMLLog.log.warn(\"No types have been added to Biome {}, types have been assigned on a best-effort guess: {}\", biome.getRegistryName(), getTypes(biome));\r\n    }\r\n}"
}, {
	"Path": "net.minecraftforge.event.entity.item.ItemEvent.getEntityItem",
	"Comment": "the relevant entityitem for this event, already cast for you.",
	"Method": "EntityItem getEntityItem(){\r\n    return entityItem;\r\n}"
}, {
	"Path": "org.springframework.security.acls.jdbc.BasicLookupStrategy.setLookupObjectIdentitiesWhereClause",
	"Comment": "the sql for the where clause used in the lookupobjectidentities method.",
	"Method": "void setLookupObjectIdentitiesWhereClause(String lookupObjectIdentitiesWhereClause){\r\n    this.lookupObjectIdentitiesWhereClause = lookupObjectIdentitiesWhereClause;\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.ReentrantReadWriteLock.getReadLockCount",
	"Comment": "queries the number of read locks held for this lock. thismethod is designed for use in monitoring system state, not forsynchronization control.",
	"Method": "int getReadLockCount(int getReadLockCount){\r\n    return sync.getReadLockCount();\r\n}"
}, {
	"Path": "io.restassured.module.mockmvc.RestAssuredMockMvc.options",
	"Comment": "perform a options request to the statically configured base path.",
	"Method": "MockMvcResponse options(String path,Object pathParams,MockMvcResponse options,String path,Map<String, ?> pathParams,MockMvcResponse options,URI uri,MockMvcResponse options,URL url,MockMvcResponse options){\r\n    return given().options();\r\n}"
}, {
	"Path": "io.restassured.module.jsv.JsonSchemaValidator.matchesJsonSchema",
	"Comment": "creates a hamcrest matcher that validates that a json document conforms to the json schema provided to this method.",
	"Method": "JsonSchemaValidator matchesJsonSchema(String schema,JsonSchemaValidator matchesJsonSchema,InputStream schema,JsonSchemaValidator matchesJsonSchema,Reader schema,JsonSchemaValidator matchesJsonSchema,File file,JsonSchemaValidator matchesJsonSchema,URL url,JsonSchemaValidator matchesJsonSchema,URI uri){\r\n    return matchesJsonSchema(toURL(uri));\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.AbstractQueuedSynchronizer.getQueueLength",
	"Comment": "returns an estimate of the number of strands waiting toacquire.the value is only an estimate because the number ofstrands may change dynamically while this method traversesinternal data structures.this method is designed for use inmonitoring system state, not for synchronizationcontrol.",
	"Method": "int getQueueLength(){\r\n    int n = 0;\r\n    for (Node p = tail; p != null; p = p.prev) {\r\n        if (p.strand != null)\r\n            ++n;\r\n    }\r\n    return n;\r\n}"
}, {
	"Path": "net.minecraftforge.common.brewing.BrewingRecipeRegistry.brewPotions",
	"Comment": "used by the brewing stand to brew its inventory extra parameters exist toallow modders to create bigger brewing stands without much hassle",
	"Method": "void brewPotions(NonNullList<ItemStack> inputs,ItemStack ingredient,int[] inputIndexes){\r\n    for (int i : inputIndexes) {\r\n        ItemStack output = getOutput(inputs.get(i), ingredient);\r\n        if (!output.isEmpty()) {\r\n            inputs.set(i, output);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.uber.nullaway.testdata.unannotated.UnannotatedClass.foo",
	"Comment": "this is an identity method, without nullability annotations.",
	"Method": "Object foo(Object x){\r\n    return x;\r\n}"
}, {
	"Path": "org.springframework.cloud.netflix.zuul.filters.route.SimpleHostRoutingFilter.isSslHostnameValidationEnabled",
	"Comment": "determines whether the filter enables the validation for ssl hostnames.",
	"Method": "boolean isSslHostnameValidationEnabled(){\r\n    return this.sslHostnameValidationEnabled;\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.AbstractQueuedLongSynchronizer.addWaiter",
	"Comment": "creates and enqueues node for current strand and given mode.",
	"Method": "Node addWaiter(Node mode){\r\n    Node node = new Node(Strand.currentStrand(), mode);\r\n    Node pred = tail;\r\n    if (pred != null) {\r\n        node.prev = pred;\r\n        if (compareAndSetTail(pred, node)) {\r\n            pred.next = node;\r\n            return node;\r\n        }\r\n    }\r\n    enq(node);\r\n    return node;\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.concurrent.ReentrantLock.getQueueLength",
	"Comment": "returns an estimate of the number of strands waiting toacquire this lock.the value is only an estimate because the number ofstrands may change dynamically while this method traversesinternal data structures.this method is designed for use inmonitoring of the system state, not for synchronizationcontrol.",
	"Method": "int getQueueLength(){\r\n    return sync.getQueueLength();\r\n}"
}, {
	"Path": "io.restassured.module.jsv.JsonSchemaValidatorSettings.checkedValidation",
	"Comment": "instruct the jsonschemavalidator to use checked validation or not.",
	"Method": "JsonSchemaValidatorSettings checkedValidation(boolean shouldUseCheckedValidation){\r\n    return new JsonSchemaValidatorSettings(jsonSchemaFactory, shouldUseCheckedValidation, parseUriAndUrlsAsJsonNode);\r\n}"
}, {
	"Path": "net.minecraftforge.fml.common.registry.GameRegistry.register",
	"Comment": "this is now private, you should use either forgeregistries constants.or the registry passed in during the registryevent.register event.",
	"Method": "K register(K object){\r\n    return (K) GameData.register_impl(object);\r\n}"
}, {
	"Path": "co.paralleluniverse.concurrent.util.ScheduledSingleThreadExecutor.isRunningOrShutdown",
	"Comment": "state check needed by scheduledthreadpoolexecutor toenable running tasks during shutdown.",
	"Method": "boolean isRunningOrShutdown(boolean shutdownOK){\r\n    int rs = state;\r\n    return rs == RUNNING || (rs == SHUTDOWN && shutdownOK);\r\n}"
}, {
	"Path": "co.paralleluniverse.fibers.Fiber.setUncaughtExceptionHandler",
	"Comment": "set the handler invoked when this fiber abruptly terminatesdue to an uncaught exception.a fiber can take full control of how it responds to uncaughtexceptions by having its uncaught exception handler explicitly set.",
	"Method": "void setUncaughtExceptionHandler(UncaughtExceptionHandler eh){\r\n    this.uncaughtExceptionHandler = eh;\r\n}"
}, {
	"Path": "net.minecraftforge.common.brewing.BrewingRecipeRegistry.isValidInput",
	"Comment": "returns true if the passed itemstack is a valid input for any of therecipes in the registry.",
	"Method": "boolean isValidInput(ItemStack stack){\r\n    if (stack.getCount() != 1)\r\n        return false;\r\n    for (IBrewingRecipe recipe : recipes) {\r\n        if (recipe.isInput(stack)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.minecraftforge.server.timings.ForgeTimings.getRawTimingData",
	"Comment": "returns a copy of the raw timings data collected by the tracker",
	"Method": "int[] getRawTimingData(){\r\n    return Arrays.copyOfRange(rawTimingData, 0, rawTimingData.length);\r\n}"
}, {
	"Path": "net.minecraftforge.fluids.FluidStack.isFluidStackIdentical",
	"Comment": "determines if the fluidids, amounts, and nbt tags are all equal.",
	"Method": "boolean isFluidStackIdentical(FluidStack other){\r\n    return isFluidEqual(other) && amount == other.amount;\r\n}"
}, {
	"Path": "org.springframework.security.cas.web.CasAuthenticationEntryPoint.createServiceUrl",
	"Comment": "constructs a new service url. the default implementation relies on the cas client\tto do the bulk of the work.",
	"Method": "String createServiceUrl(HttpServletRequest request,HttpServletResponse response){\r\n    return CommonUtils.constructServiceUrl(null, response, this.serviceProperties.getService(), null, this.serviceProperties.getArtifactParameter(), this.encodeServiceUrlWithSessionId);\r\n}"
}, {
	"Path": "co.paralleluniverse.concurrent.util.ConcurrentSkipListPriorityQueue.buildFromSorted",
	"Comment": "streamlined bulk insertion to initialize from elements ofgiven sorted map. call only from constructor or clonemethod.",
	"Method": "void buildFromSorted(ConcurrentSkipListPriorityQueue<E> pq){\r\n    if (pq == null)\r\n        throw new NullPointerException();\r\n    HeadIndex<E> h = head;\r\n    Node<E> basepred = h.node;\r\n    ArrayList<Index<E>> preds = new ArrayList<Index<E>>();\r\n    for (int i = 0; i <= h.level; ++i) preds.add(null);\r\n    Index<E> q = h;\r\n    for (int i = h.level; i > 0; --i) {\r\n        preds.set(i, q);\r\n        q = q.down;\r\n    }\r\n    Iterator<E> it = pq.iterator();\r\n    while (it.hasNext()) {\r\n        E k = it.next();\r\n        int j = randomLevel();\r\n        if (j > h.level)\r\n            j = h.level + 1;\r\n        if (k == null)\r\n            throw new NullPointerException();\r\n        Node<E> z = new Node<E>(k, null);\r\n        basepred.next = z;\r\n        basepred = z;\r\n        if (j > 0) {\r\n            Index<E> idx = null;\r\n            for (int i = 1; i <= j; ++i) {\r\n                idx = new Index<E>(z, idx, null);\r\n                if (i > h.level)\r\n                    h = new HeadIndex<E>(h.node, h, idx, i);\r\n                if (i < preds.size()) {\r\n                    preds.get(i).right = idx;\r\n                    preds.set(i, idx);\r\n                } else\r\n                    preds.add(idx);\r\n            }\r\n        }\r\n    }\r\n    head = h;\r\n}"
}, {
	"Path": "io.restassured.matcher.DetailedCookieMatcher.expiryDate",
	"Comment": "verifies whether expiry date of cookie satisfies specified matcher.",
	"Method": "DetailedCookieMatcher expiryDate(Date expectedExpiryDate,DetailedCookieMatcher expiryDate,Matcher<? super Date> expiryDateMatcher){\r\n    return new DetailedCookieMatcher(and(Matchers.<Cookie>hasProperty(\"expiryDate\", expiryDateMatcher)));\r\n}"
}, {
	"Path": "com.mcxiaoke.packer.cli.Options.getOptionOriginalForm",
	"Comment": "returns the original form of the current option. the original form includes the leading dashor dashes. this is intended to be used for referencing the option in error messages.",
	"Method": "String getOptionOriginalForm(){\r\n    return lastOptionOriginalForm;\r\n}"
}, {
	"Path": "net.minecraftforge.common.config.ConfigCategory.requiresMcRestart",
	"Comment": "gets whether or not this configcategory requires minecraft to be restarted when changed.defaults to false unless set to true.",
	"Method": "boolean requiresMcRestart(){\r\n    return this.requiresMcRestart;\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.channels.ReceivePort.receive",
	"Comment": "retrieves a message from the channels, possibly blocking until one becomes available, but no longer than the specified timeout.",
	"Method": "Message receive(Message receive,long timeout,TimeUnit unit,Message receive,Timeout timeout){\r\n    return receive(timeout.nanosLeft(), TimeUnit.NANOSECONDS);\r\n}"
}, {
	"Path": "com.uber.nullaway.NullabilityUtil.getAllAnnotationsForParameter",
	"Comment": "works for method parameters defined either in source or in class files",
	"Method": "Stream<? extends AnnotationMirror> getAllAnnotationsForParameter(Symbol.MethodSymbol symbol,int paramInd){\r\n    Symbol.VarSymbol varSymbol = symbol.getParameters().get(paramInd);\r\n    return Stream.concat(varSymbol.getAnnotationMirrors().stream(), symbol.getRawTypeAttributes().stream().filter(t -> t.position.type.equals(TargetType.METHOD_FORMAL_PARAMETER) && t.position.parameter_index == paramInd));\r\n}"
}, {
	"Path": "org.mapdb.io.DataIO.toHexa",
	"Comment": "converts binary array into its hexadecimal representation.",
	"Method": "String toHexa(byte[] bb){\r\n    char[] HEXA_CHARS = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };\r\n    char[] ret = new char[bb.length * 2];\r\n    for (int i = 0; i < bb.length; i++) {\r\n        ret[i * 2] = HEXA_CHARS[((bb[i] & 0xF0) >> 4)];\r\n        ret[i * 2 + 1] = HEXA_CHARS[((bb[i] & 0x0F))];\r\n    }\r\n    return new String(ret);\r\n}"
}, {
	"Path": "net.minecraftforge.common.DimensionManager.getCurrentSaveRootDirectory",
	"Comment": "return the current root directory for the world save. accesses getsavehandler from the overworld",
	"Method": "File getCurrentSaveRootDirectory(){\r\n    if (DimensionManager.getWorld(0) != null) {\r\n        return DimensionManager.getWorld(0).getSaveHandler().getWorldDirectory();\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "net.minecraftforge.common.util.RecipeMatcher.backtrack",
	"Comment": "we use recursion here, why? because i feel like it. also because we should only ever be working in data sets9",
	"Method": "boolean backtrack(BitSet data,int[] ret,int start,int elements){\r\n    int test = data.nextClearBit(elements + start) - elements;\r\n    if (test >= elements)\r\n        return true;\r\n    if (test < 0)\r\n        throw new IllegalStateException(\"This should never happen, negative test in backtrack!\");\r\n    int offset = (test + 2) * elements;\r\n    for (int x = 0; x < elements; x++) {\r\n        if (!data.get(offset + x) || data.get(x))\r\n            continue;\r\n        data.set(x);\r\n        if (backtrack(data, ret, test + 1, elements)) {\r\n            ret[x] = test;\r\n            return true;\r\n        }\r\n        data.clear(x);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.minecraftforge.fluids.DispenseFluidContainer.fillContainer",
	"Comment": "picks up fluid in front of a dispenser and fills a container with it.",
	"Method": "ItemStack fillContainer(IBlockSource source,ItemStack stack){\r\n    World world = source.getWorld();\r\n    EnumFacing dispenserFacing = source.getBlockState().getValue(BlockDispenser.FACING);\r\n    BlockPos blockpos = source.getBlockPos().offset(dispenserFacing);\r\n    FluidActionResult actionResult = FluidUtil.tryPickUpFluid(stack, null, world, blockpos, dispenserFacing.getOpposite());\r\n    ItemStack resultStack = actionResult.getResult();\r\n    if (!actionResult.isSuccess() || resultStack.isEmpty()) {\r\n        return super.dispenseStack(source, stack);\r\n    }\r\n    if (stack.getCount() == 1) {\r\n        return resultStack;\r\n    } else if (((TileEntityDispenser) source.getBlockTileEntity()).addItemStack(resultStack) < 0) {\r\n        this.dispenseBehavior.dispense(source, resultStack);\r\n    }\r\n    ItemStack stackCopy = stack.copy();\r\n    stackCopy.shrink(1);\r\n    return stackCopy;\r\n}"
}, {
	"Path": "io.restassured.config.RedirectConfig.rejectRelativeRedirect",
	"Comment": "configure if rest assured should reject relative redirects",
	"Method": "RedirectConfig rejectRelativeRedirect(boolean value){\r\n    return new RedirectConfig(followRedirects, allowCircularRedirects, value, maxRedirects, true);\r\n}"
}, {
	"Path": "org.springframework.cloud.netflix.zuul.filters.discovery.PatternServiceRouteMapper.apply",
	"Comment": "use servicepattern to extract groups and routepattern to construct the route.\tif there is no matches, the serviceid is returned.",
	"Method": "String apply(String serviceId){\r\n    Matcher matcher = this.servicePattern.matcher(serviceId);\r\n    String route = matcher.replaceFirst(this.routePattern);\r\n    route = cleanRoute(route);\r\n    return (StringUtils.hasText(route) ? route : serviceId);\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.channels.ThreadReceivePort.receive",
	"Comment": "retrieves a message from the channels, possibly blocking until one becomes available, but no longer than the specified timeout.",
	"Method": "Message receive(Message receive,long timeout,TimeUnit unit){\r\n    if (Strand.isCurrentFiber())\r\n        throw new IllegalStateException(\"This method cannot be called on a fiber\");\r\n    try {\r\n        return p.receive(timeout, unit);\r\n    } catch (SuspendExecution e) {\r\n        throw new AssertionError(e);\r\n    }\r\n}"
}, {
	"Path": "io.restassured.module.webtestclient.RestAssuredWebTestClient.get",
	"Comment": "perform a get request to the statically configured base path.",
	"Method": "WebTestClientResponse get(String path,Object pathParams,WebTestClientResponse get,String path,Map<String, ?> pathParams,WebTestClientResponse get,Function<UriBuilder, URI> uriFunction,WebTestClientResponse get,URI uri,WebTestClientResponse get,URL url,WebTestClientResponse get){\r\n    return given().get();\r\n}"
}, {
	"Path": "net.minecraftforge.common.brewing.BrewingRecipeRegistry.getRecipes",
	"Comment": "returns an unmodifiable list containing all the recipes in the registry",
	"Method": "List<IBrewingRecipe> getRecipes(){\r\n    return Collections.unmodifiableList(recipes);\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.channels.TransferChannel.succ",
	"Comment": "returns the successor of p, or the head node if p.next has beenlinked to self, which will only be true if traversing with astale pointer that is now off the list.",
	"Method": "Node succ(Node p){\r\n    Node next = p.next;\r\n    return (p == next) ? head : next;\r\n}"
}, {
	"Path": "io.restassured.module.webtestclient.RestAssuredWebTestClient.patch",
	"Comment": "perform a patch request to the statically configured base path.",
	"Method": "WebTestClientResponse patch(String path,Object pathParams,WebTestClientResponse patch,String path,Map<String, ?> pathParams,WebTestClientResponse patch,Function<UriBuilder, URI> uriFunction,WebTestClientResponse patch,URI uri,WebTestClientResponse patch,URL url,WebTestClientResponse patch){\r\n    return given().patch();\r\n}"
}, {
	"Path": "io.restassured.RestAssured.preemptive",
	"Comment": "return the http preemptive authentication specification for setting up preemptive authentication requests.this means that the authentication details are sent in the request header regardless if the server challengedfor authentication or not.",
	"Method": "PreemptiveAuthProvider preemptive(){\r\n    return new PreemptiveAuthProvider();\r\n}"
}, {
	"Path": "com.alibaba.csp.sentinel.log.LoggerUtils.disableOtherHandlers",
	"Comment": "remove all current handlers from the logger and attach it with the given log handler.",
	"Method": "void disableOtherHandlers(Logger logger,Handler handler){\r\n    if (logger == null) {\r\n        return;\r\n    }\r\n    synchronized (logger) {\r\n        Handler[] handlers = logger.getHandlers();\r\n        if (handlers == null) {\r\n            return;\r\n        }\r\n        if (handlers.length == 1 && handlers[0].equals(handler)) {\r\n            return;\r\n        }\r\n        logger.setUseParentHandlers(false);\r\n        for (Handler h : handlers) {\r\n            logger.removeHandler(h);\r\n        }\r\n        logger.addHandler(handler);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.cloud.netflix.zuul.filters.pre.ServletDetectionFilter.filterOrder",
	"Comment": "must run before other filters that rely on the difference between \tdispatcherservlet and zuulservlet.",
	"Method": "int filterOrder(){\r\n    return SERVLET_DETECTION_FILTER_ORDER;\r\n}"
}, {
	"Path": "io.restassured.path.xml.XmlPath.getChar",
	"Comment": "get the result of an xml path expression as a char. for syntax details please refer tothis url.",
	"Method": "char getChar(String path){\r\n    Object object = get(path);\r\n    return convertObjectTo(object, Character.class);\r\n}"
}, {
	"Path": "net.minecraftforge.common.util.EnumHelper.testEnum",
	"Comment": "tests an enum is compatible with these args, throws an error if not.",
	"Method": "void testEnum(Class<? extends Enum<?>> enumType,Class<?>[] paramTypes){\r\n    addEnum(true, enumType, null, paramTypes, (Object[]) null);\r\n}"
}, {
	"Path": "io.restassured.path.xml.XmlPath.getString",
	"Comment": "get the result of an xml path expression as a string. for syntax details please refer tothis url.",
	"Method": "String getString(String path){\r\n    Object object = get(path);\r\n    return convertObjectTo(object, String.class);\r\n}"
}, {
	"Path": "io.restassured.module.webtestclient.matcher.RestAssuredWebTestClientMatchers.matchesDtd",
	"Comment": "evaluates to true if an xml string matches the supplied dtd.",
	"Method": "Matcher<String> matchesDtd(String dtd,Matcher<String> matchesDtd,InputStream dtd,Matcher<String> matchesDtd,File dtd,Matcher<String> matchesDtd,URL url){\r\n    return RestAssuredMatchers.matchesDtd(url);\r\n}"
}, {
	"Path": "org.springframework.security.cas.web.CasAuthenticationFilter.proxyTicketRequest",
	"Comment": "indicates if the request is elgible to process a proxy ticket.",
	"Method": "boolean proxyTicketRequest(boolean serviceTicketRequest,HttpServletRequest request){\r\n    if (serviceTicketRequest) {\r\n        return false;\r\n    }\r\n    final boolean result = authenticateAllArtifacts && obtainArtifact(request) != null && !authenticated();\r\n    if (logger.isDebugEnabled()) {\r\n        logger.debug(\"proxyTicketRequest = \" + result);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "io.objectbox.BoxStore.setDbExceptionListener",
	"Comment": "the given listener will be called when an exception is thrown.this for example allows a central error handling, e.g. a special logging for db related exceptions.",
	"Method": "void setDbExceptionListener(DbExceptionListener dbExceptionListener){\r\n    nativeSetDbExceptionListener(handle, dbExceptionListener);\r\n}"
}, {
	"Path": "io.restassured.config.HttpClientConfig.dontReuseHttpClientInstance",
	"Comment": "instruct rest assured not to reuse the configured http client instance for multiple requests. this is the default behavior.",
	"Method": "HttpClientConfig dontReuseHttpClientInstance(){\r\n    return new HttpClientConfig(httpClientFactory, httpClientParams, httpMultipartMode, false, NO_HTTP_CLIENT, true);\r\n}"
}, {
	"Path": "co.paralleluniverse.actors.Actor.getQueueLength",
	"Comment": "returns the number of messages currently waiting in the mailbox.",
	"Method": "int getQueueLength(){\r\n    return mailbox().getQueueLength();\r\n}"
}, {
	"Path": "io.restassured.path.json.JsonPath.using",
	"Comment": "configure jsonpath to use a specific jackson 2 object mapper factory",
	"Method": "JsonPath using(GsonObjectMapperFactory factory,JsonPath using,Jackson1ObjectMapperFactory factory,JsonPath using,Jackson2ObjectMapperFactory factory,JsonPath using,JsonPathConfig config){\r\n    return new JsonPath(this, config);\r\n}"
}, {
	"Path": "co.paralleluniverse.fibers.instrument.SimpleSuspendableClassifier.isSuspendable",
	"Comment": "test if the given method exists expicitly in the suspendables files",
	"Method": "boolean isSuspendable(String className,String methodName,String methodDesc,SuspendableType isSuspendable,MethodDatabase db,String sourceName,String sourceDebugInfo,boolean isInterface,String className,String superClassName,String[] interfaces,String methodName,String methodDesc,String methodSignature,String[] methodExceptions){\r\n    final String fullMethodName = className + '.' + methodName;\r\n    if (suspendables.contains(fullMethodName + methodDesc))\r\n        return SuspendableType.SUSPENDABLE;\r\n    if (suspendables.contains(fullMethodName))\r\n        return SuspendableType.SUSPENDABLE;\r\n    if (suspendableClasses.contains(className))\r\n        return SuspendableType.SUSPENDABLE;\r\n    if (suspendableSupers.contains(fullMethodName + methodDesc))\r\n        return SuspendableType.SUSPENDABLE_SUPER;\r\n    if (suspendableSupers.contains(fullMethodName))\r\n        return SuspendableType.SUSPENDABLE_SUPER;\r\n    if (suspendableSuperInterfaces.contains(className))\r\n        return SuspendableType.SUSPENDABLE_SUPER;\r\n    if (superClassName != null) {\r\n        MethodDatabase.ClassEntry ce = db.getOrLoadClassEntry(superClassName);\r\n        if (ce != null && isSuspendable(db, sourceName, sourceDebugInfo, isInterface, superClassName, ce.getSuperName(), ce.getInterfaces(), methodName, methodDesc, methodSignature, methodExceptions) == SuspendableType.SUSPENDABLE)\r\n            return SuspendableType.SUSPENDABLE;\r\n    }\r\n    if (interfaces != null) {\r\n        for (String iface : interfaces) {\r\n            MethodDatabase.ClassEntry ce = db.getOrLoadClassEntry(iface);\r\n            if (ce != null && isSuspendable(db, ce.getSourceName(), ce.getSourceDebugInfo(), ce.isInterface(), iface, ce.getSuperName(), ce.getInterfaces(), methodName, methodDesc, methodSignature, methodExceptions) == SuspendableType.SUSPENDABLE)\r\n                return SuspendableType.SUSPENDABLE;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "paulscode.sound.codecs.CodecIBXM.cleanup",
	"Comment": "closes the audio stream and remove references to all instantiated objects.",
	"Method": "void cleanup(){\r\n    playPosition = 0;\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.channels.TransferChannel.xfer1",
	"Comment": "implements all queuing methods. see above for explanation.",
	"Method": "Object xfer1(Message e,boolean haveData,int how,long nanos){\r\n    assert how == SYNC || how == TIMED;\r\n    if (haveData && (e == null))\r\n        throw new NullPointerException();\r\n    Node s = null;\r\n    retry: for (; ; ) {\r\n        Object item = tryMatch(null, e, haveData);\r\n        if (item != NO_MATCH)\r\n            return item;\r\n        if (s == null)\r\n            s = new Node(e, haveData);\r\n        Node pred = tryAppend(s, haveData);\r\n        if (pred == null)\r\n            continue retry;\r\n        if (!haveData && sendClosed) {\r\n            s.item = CHANNEL_CLOSED;\r\n            unsplice(pred, s);\r\n            setReceiveClosed();\r\n            return CHANNEL_CLOSED;\r\n        }\r\n        return awaitMatch(s, pred, e, (how == TIMED), nanos);\r\n    }\r\n}"
}, {
	"Path": "org.mapdb.jsr166.Collection8Test.testGetComparator_IllegalStateException",
	"Comment": "spliterator.getcomparator throws illegalstateexception iff thespliterator does not report sorted.",
	"Method": "void testGetComparator_IllegalStateException(){\r\n    Collection c = impl.emptyCollection();\r\n    Spliterator s = c.spliterator();\r\n    boolean reportsSorted = s.hasCharacteristics(Spliterator.SORTED);\r\n    try {\r\n        s.getComparator();\r\n        assertTrue(reportsSorted);\r\n    } catch (IllegalStateException ex) {\r\n        assertFalse(reportsSorted);\r\n    }\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.channels.SendPort.trySend",
	"Comment": "sends a message to the channel if the channel has room available. this method never blocks.",
	"Method": "boolean trySend(Message message){\r\n    try {\r\n        return send(message, 0, TimeUnit.NANOSECONDS);\r\n    } catch (SuspendExecution | InterruptedException ex) {\r\n        throw new AssertionError(ex);\r\n    }\r\n}"
}, {
	"Path": "net.minecraftforge.common.config.Property.isIntValue",
	"Comment": "checks if the current value stored in this property can be converted to an integer.",
	"Method": "boolean isIntValue(){\r\n    try {\r\n        Integer.parseInt(value);\r\n        return true;\r\n    } catch (NumberFormatException e) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "net.minecraftforge.common.config.Property.setValue",
	"Comment": "sets the value of this property to the provided double value.",
	"Method": "Property setValue(String value,Property setValue,int value,Property setValue,boolean value,Property setValue,double value){\r\n    setValue(Double.toString(value));\r\n    return this;\r\n}"
}, {
	"Path": "io.objectbox.relation.ToOne.getTarget",
	"Comment": "if property backed, entities can pass the target id to avoid reflection.",
	"Method": "TARGET getTarget(TARGET getTarget,long targetId){\r\n    synchronized (this) {\r\n        if (resolvedTargetId == targetId) {\r\n            return target;\r\n        }\r\n    }\r\n    ensureBoxes(null);\r\n    TARGET targetNew = targetBox.get(targetId);\r\n    setResolvedTarget(targetNew, targetId);\r\n    return targetNew;\r\n}"
}, {
	"Path": "org.mapdb.jsr166.LinkedBlockingDequeTest.testInterruptedTimedPollFirst",
	"Comment": "interrupted timed pollfirst throws interruptedexception instead ofreturning timeout status",
	"Method": "void testInterruptedTimedPollFirst(){\r\n    final BlockingDeque q = populatedDeque(SIZE);\r\n    final CountDownLatch pleaseInterrupt = new CountDownLatch(1);\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            long startTime = System.nanoTime();\r\n            for (int i = 0; i < SIZE; i++) assertEquals(i, q.pollFirst(LONG_DELAY_MS, MILLISECONDS));\r\n            Thread.currentThread().interrupt();\r\n            try {\r\n                q.pollFirst(LONG_DELAY_MS, MILLISECONDS);\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n            }\r\n            assertFalse(Thread.interrupted());\r\n            pleaseInterrupt.countDown();\r\n            try {\r\n                q.pollFirst(LONG_DELAY_MS, MILLISECONDS);\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n            }\r\n            assertFalse(Thread.interrupted());\r\n            assertTrue(millisElapsedSince(startTime) < LONG_DELAY_MS);\r\n        }\r\n    });\r\n    await(pleaseInterrupt);\r\n    assertThreadBlocks(t, Thread.State.TIMED_WAITING);\r\n    t.interrupt();\r\n    awaitTermination(t);\r\n}"
}, {
	"Path": "org.mapdb.jsr166.LinkedBlockingDequeTest.testInterruptedTimedPollFirst",
	"Comment": "interrupted timed pollfirst throws interruptedexception instead ofreturning timeout status",
	"Method": "void testInterruptedTimedPollFirst(){\r\n    long startTime = System.nanoTime();\r\n    for (int i = 0; i < SIZE; i++) assertEquals(i, q.pollFirst(LONG_DELAY_MS, MILLISECONDS));\r\n    Thread.currentThread().interrupt();\r\n    try {\r\n        q.pollFirst(LONG_DELAY_MS, MILLISECONDS);\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n    }\r\n    assertFalse(Thread.interrupted());\r\n    pleaseInterrupt.countDown();\r\n    try {\r\n        q.pollFirst(LONG_DELAY_MS, MILLISECONDS);\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n    }\r\n    assertFalse(Thread.interrupted());\r\n    assertTrue(millisElapsedSince(startTime) < LONG_DELAY_MS);\r\n}"
}, {
	"Path": "net.minecraftforge.fml.repackage.com.nothome.delta.Delta.setChunkSize",
	"Comment": "sets the chunk size used.larger chunks are faster and use less memory, but create larger patchesas well.",
	"Method": "void setChunkSize(int size){\r\n    if (size <= 0)\r\n        throw new IllegalArgumentException(\"Invalid size\");\r\n    S = size;\r\n}"
}, {
	"Path": "org.mapdb.jsr166.LinkedBlockingQueueTest.testBlockingTake",
	"Comment": "take removes existing elements until empty, then blocks interruptibly",
	"Method": "void testBlockingTake(){\r\n    final BlockingQueue q = populatedQueue(SIZE);\r\n    final CountDownLatch pleaseInterrupt = new CountDownLatch(1);\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            for (int i = 0; i < SIZE; i++) assertEquals(i, q.take());\r\n            Thread.currentThread().interrupt();\r\n            try {\r\n                q.take();\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n            }\r\n            assertFalse(Thread.interrupted());\r\n            pleaseInterrupt.countDown();\r\n            try {\r\n                q.take();\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n            }\r\n            assertFalse(Thread.interrupted());\r\n        }\r\n    });\r\n    await(pleaseInterrupt);\r\n    assertThreadBlocks(t, Thread.State.WAITING);\r\n    t.interrupt();\r\n    awaitTermination(t);\r\n}"
}, {
	"Path": "org.mapdb.jsr166.LinkedBlockingQueueTest.testBlockingTake",
	"Comment": "take removes existing elements until empty, then blocks interruptibly",
	"Method": "void testBlockingTake(){\r\n    for (int i = 0; i < SIZE; i++) assertEquals(i, q.take());\r\n    Thread.currentThread().interrupt();\r\n    try {\r\n        q.take();\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n    }\r\n    assertFalse(Thread.interrupted());\r\n    pleaseInterrupt.countDown();\r\n    try {\r\n        q.take();\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n    }\r\n    assertFalse(Thread.interrupted());\r\n}"
}, {
	"Path": "net.minecraftforge.fluids.FluidTank.canDrainFluidType",
	"Comment": "returns true if the tank can drain out this type of fluid.used as a filter for fluid types.does not consider the current contents or capacity of the tank,only whether it could ever drain out this type of fluid.",
	"Method": "boolean canDrainFluidType(FluidStack fluid){\r\n    return fluid != null && canDrain();\r\n}"
}, {
	"Path": "io.restassured.module.webtestclient.RestAssuredWebTestClient.post",
	"Comment": "perform a post request to the statically configured base path.",
	"Method": "WebTestClientResponse post(String path,Object pathParams,WebTestClientResponse post,String path,Map<String, ?> pathParams,WebTestClientResponse post,Function<UriBuilder, URI> uriFunction,WebTestClientResponse post,URI uri,WebTestClientResponse post,URL url,WebTestClientResponse post){\r\n    return given().post();\r\n}"
}, {
	"Path": "io.restassured.module.mockmvc.matcher.RestAssuredMockMvcMatchers.matchesDtdInClasspath",
	"Comment": "evaluates to true if an xml file in classpath matches the supplied dtd.",
	"Method": "Matcher<String> matchesDtdInClasspath(String path){\r\n    return XmlDtdMatcher.matchesDtdInClasspath(path);\r\n}"
}, {
	"Path": "paulscode.sound.codecs.CodecIBXM.initialize",
	"Comment": "prepares an audio stream to read from.if another stream is already opened,it will be closed and a new audio stream opened in its place.",
	"Method": "boolean initialize(URL url){\r\n    initialized(SET, false);\r\n    cleanup();\r\n    if (url == null) {\r\n        errorMessage(\"url null in method 'initialize'\");\r\n        cleanup();\r\n        return false;\r\n    }\r\n    InputStream is = null;\r\n    try {\r\n        is = url.openStream();\r\n    } catch (IOException ioe) {\r\n        errorMessage(\"Unable to open stream in method 'initialize'\");\r\n        printStackTrace(ioe);\r\n        return false;\r\n    }\r\n    if (ibxm == null)\r\n        ibxm = new IBXM(48000);\r\n    if (myAudioFormat == null)\r\n        myAudioFormat = new AudioFormat(48000, 16, 2, true, true);\r\n    try {\r\n        setModule(loadModule(is));\r\n    } catch (IllegalArgumentException iae) {\r\n        errorMessage(\"Illegal argument in method 'initialize'\");\r\n        printStackTrace(iae);\r\n        if (is != null) {\r\n            try {\r\n                is.close();\r\n            } catch (IOException ioe) {\r\n            }\r\n        }\r\n        return false;\r\n    } catch (IOException ioe) {\r\n        errorMessage(\"Error loading module in method 'initialize'\");\r\n        printStackTrace(ioe);\r\n        if (is != null) {\r\n            try {\r\n                is.close();\r\n            } catch (IOException ioe2) {\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    if (is != null) {\r\n        try {\r\n            is.close();\r\n        } catch (IOException ioe) {\r\n        }\r\n    }\r\n    endOfStream(SET, false);\r\n    initialized(SET, true);\r\n    return true;\r\n}"
}, {
	"Path": "co.paralleluniverse.strands.channels.Selector.select",
	"Comment": "performs exactly one channel operation of a given set, blocking until any of the actions completes, but no longer than the specified timeout.",
	"Method": "SelectAction<Message> select(boolean priority,SelectAction<Message> actions,SelectAction<Message> select,boolean priority,long timeout,TimeUnit unit,SelectAction<Message> actions,SelectAction<Message> select,boolean priority,Timeout timeout,SelectAction<Message> actions,SelectAction<Message> select,boolean priority,List<? extends SelectAction<Message>> actions,SelectAction<Message> select,boolean priority,long timeout,TimeUnit unit,List<? extends SelectAction<Message>> actions,SelectAction<Message> select,boolean priority,Timeout timeout,List<? extends SelectAction<Message>> actions,SelectAction<Message> select,SelectAction<Message> actions,SelectAction<Message> select,long timeout,TimeUnit unit,SelectAction<Message> actions,SelectAction<Message> select,Timeout timeout,SelectAction<Message> actions,SelectAction<Message> select,List<? extends SelectAction<Message>> actions,SelectAction<Message> select,long timeout,TimeUnit unit,List<? extends SelectAction<Message>> actions,SelectAction<Message> select,Timeout timeout,List<? extends SelectAction<Message>> actions,SelectAction<Message> select,SelectAction<Message> select,Timeout timeout,SelectAction<Message> select,long timeout,TimeUnit unit){\r\n    if (timeout == 0 && unit != null)\r\n        return trySelect();\r\n    selectInit();\r\n    final boolean timed = (timeout > 0 && unit != null);\r\n    long lastTime = timed ? System.nanoTime() : 0L;\r\n    long nanos = timed ? unit.toNanos(timeout) : 0L;\r\n    Object token = register();\r\n    try {\r\n        if (res == null) {\r\n            tryloop: for (; ; ) {\r\n                if (timed && nanos <= 0)\r\n                    break;\r\n                for (int i = 0; i <= lastRegistered; i++) {\r\n                    SelectActionImpl<Message> sa = actions.get(i);\r\n                    if (sa.port.tryNow(sa.token)) {\r\n                        res = sa;\r\n                        break tryloop;\r\n                    }\r\n                }\r\n                if (timed) {\r\n                    long now = System.nanoTime();\r\n                    if ((nanos -= now - lastTime) > 0)\r\n                        Strand.parkNanos(this, nanos);\r\n                    lastTime = now;\r\n                } else\r\n                    Strand.park(this);\r\n            }\r\n        }\r\n    } finally {\r\n        unregister(token);\r\n    }\r\n    if (res != null)\r\n        ((SelectActionImpl<Message>) res).fire();\r\n    return res;\r\n}"
}, {
	"Path": "io.restassured.authentication.PreemptiveAuthProvider.basic",
	"Comment": "use preemptive http basic authentication. this means that the authentication details are sent in the requestheader regardless if the server has challenged for authentication or not.",
	"Method": "AuthenticationScheme basic(String userName,String password){\r\n    final PreemptiveBasicAuthScheme preemptiveBasicAuthScheme = new PreemptiveBasicAuthScheme();\r\n    preemptiveBasicAuthScheme.setUserName(userName);\r\n    preemptiveBasicAuthScheme.setPassword(password);\r\n    return preemptiveBasicAuthScheme;\r\n}"
}, {
	"Path": "io.restassured.module.webtestclient.RestAssuredWebTestClient.options",
	"Comment": "perform a options request to the statically configured base path.",
	"Method": "WebTestClientResponse options(String path,Object pathParams,WebTestClientResponse options,String path,Map<String, ?> pathParams,WebTestClientResponse options,Function<UriBuilder, URI> uriFunction,WebTestClientResponse options,URI uri,WebTestClientResponse options,URL url,WebTestClientResponse options){\r\n    return given().options();\r\n}"
}, {
	"Path": "org.springframework.security.cas.web.authentication.DefaultServiceAuthenticationDetails.getServiceUrl",
	"Comment": "returns the current url minus the artifact parameter and its value, if present.",
	"Method": "String getServiceUrl(){\r\n    return serviceUrl;\r\n}"
}, {
	"Path": "org.springframework.security.config.annotation.AbstractSecurityBuilder.getObject",
	"Comment": "gets the object that was built. if it has not been built yet an exception is\tthrown.",
	"Method": "O getObject(){\r\n    if (!this.building.get()) {\r\n        throw new IllegalStateException(\"This object has not been built\");\r\n    }\r\n    return this.object;\r\n}"
}, {
	"Path": "org.springframework.security.config.annotation.web.configurers.RememberMeConfigurer.rememberMeCookieDomain",
	"Comment": "the domain name within which the remember me cookie is visible.",
	"Method": "RememberMeConfigurer<H> rememberMeCookieDomain(String rememberMeCookieDomain){\r\n    this.rememberMeCookieDomain = rememberMeCookieDomain;\r\n    return this;\r\n}"
}, {
	"Path": "co.paralleluniverse.fibers.FiberTimedScheduler.isRunningOrShutdown",
	"Comment": "state check needed by scheduledthreadpoolexecutor toenable running tasks during shutdown.",
	"Method": "boolean isRunningOrShutdown(boolean shutdownOK){\r\n    int rs = state;\r\n    return rs == RUNNING || (rs == SHUTDOWN && shutdownOK);\r\n}"
}, {
	"Path": "net.minecraftforge.fml.common.eventhandler.Event.isCanceled",
	"Comment": "determine if this event is canceled and should stop executing.",
	"Method": "boolean isCanceled(){\r\n    return isCanceled;\r\n}"
}, {
	"Path": "co.paralleluniverse.concurrent.util.ConcurrentSkipListPriorityQueue.findPredecessorOfLast",
	"Comment": "specialized variant of findpredecessor to get predecessor of lastvalid node. needed when removing the last entry. it is possiblethat all successors of returned node will have been deleted uponreturn, in which case this method can be retried.",
	"Method": "Node<E> findPredecessorOfLast(){\r\n    for (; ; ) {\r\n        Index<E> q = head;\r\n        for (; ; ) {\r\n            Index<E> d, r;\r\n            if ((r = q.right) != null) {\r\n                if (r.indexesDeletedNode()) {\r\n                    q.unlink(r);\r\n                    break;\r\n                }\r\n                if (r.node.next != null) {\r\n                    q = r;\r\n                    continue;\r\n                }\r\n            }\r\n            if ((d = q.down) != null)\r\n                q = d;\r\n            else\r\n                return q.node;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.rxjava2.android.samples.ui.networking.NetworkingActivity.findUsersWhoLovesBoth",
	"Comment": "this do the complete magic, make both network call and then returns the list of user who loves both using zip operator to get both response at a time",
	"Method": "void findUsersWhoLovesBoth(){\r\n    Observable.zip(getCricketFansObservable(), getFootballFansObservable(), new BiFunction<List<User>, List<User>, List<User>>() {\r\n        @Override\r\n        public List<User> apply(List<User> cricketFans, List<User> footballFans) {\r\n            List<User> userWhoLovesBoth = filterUserWhoLovesBoth(cricketFans, footballFans);\r\n            return userWhoLovesBoth;\r\n        }\r\n    }).subscribeOn(Schedulers.newThread()).observeOn(AndroidSchedulers.mainThread()).subscribe(new Observer<List<User>>() {\r\n        @Override\r\n        public void onSubscribe(Disposable d) {\r\n        }\r\n        @Override\r\n        public void onNext(List<User> users) {\r\n            Log.d(TAG, \"userList size : \" + users.size());\r\n            for (User user : users) {\r\n                Log.d(TAG, \"user : \" + user.toString());\r\n            }\r\n        }\r\n        @Override\r\n        public void onError(Throwable e) {\r\n            Utils.logError(TAG, e);\r\n        }\r\n        @Override\r\n        public void onComplete() {\r\n            Log.d(TAG, \"onComplete\");\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.rxjava2.android.samples.ui.networking.NetworkingActivity.findUsersWhoLovesBoth",
	"Comment": "this do the complete magic, make both network call and then returns the list of user who loves both using zip operator to get both response at a time",
	"Method": "void findUsersWhoLovesBoth(){\r\n    List<User> userWhoLovesBoth = filterUserWhoLovesBoth(cricketFans, footballFans);\r\n    return userWhoLovesBoth;\r\n}"
}, {
	"Path": "com.rxjava2.android.samples.ui.networking.NetworkingActivity.findUsersWhoLovesBoth",
	"Comment": "this do the complete magic, make both network call and then returns the list of user who loves both using zip operator to get both response at a time",
	"Method": "void findUsersWhoLovesBoth(){\r\n}"
}, {
	"Path": "com.rxjava2.android.samples.ui.networking.NetworkingActivity.findUsersWhoLovesBoth",
	"Comment": "this do the complete magic, make both network call and then returns the list of user who loves both using zip operator to get both response at a time",
	"Method": "void findUsersWhoLovesBoth(){\r\n    Log.d(TAG, \"userList size : \" + users.size());\r\n    for (User user : users) {\r\n        Log.d(TAG, \"user : \" + user.toString());\r\n    }\r\n}"
}, {
	"Path": "com.rxjava2.android.samples.ui.networking.NetworkingActivity.findUsersWhoLovesBoth",
	"Comment": "this do the complete magic, make both network call and then returns the list of user who loves both using zip operator to get both response at a time",
	"Method": "void findUsersWhoLovesBoth(){\r\n    Utils.logError(TAG, e);\r\n}"
}, {
	"Path": "com.rxjava2.android.samples.ui.networking.NetworkingActivity.findUsersWhoLovesBoth",
	"Comment": "this do the complete magic, make both network call and then returns the list of user who loves both using zip operator to get both response at a time",
	"Method": "void findUsersWhoLovesBoth(){\r\n    Log.d(TAG, \"onComplete\");\r\n}"
}, {
	"Path": "org.mapdb.jsr166.Collection8Test.testElementRemovalDuringTraversal",
	"Comment": "all elements removed in the middle of concurrent traversal.",
	"Method": "void testElementRemovalDuringTraversal(){\r\n    Collection c = impl.emptyCollection();\r\n    ThreadLocalRandom rnd = ThreadLocalRandom.current();\r\n    int n = rnd.nextInt(6);\r\n    ArrayList copy = new ArrayList();\r\n    for (int i = 0; i < n; i++) {\r\n        Object x = impl.makeElement(i);\r\n        copy.add(x);\r\n        c.add(x);\r\n    }\r\n    ArrayList iterated = new ArrayList();\r\n    ArrayList spliterated = new ArrayList();\r\n    Spliterator s = c.spliterator();\r\n    Iterator it = c.iterator();\r\n    for (int i = rnd.nextInt(n + 1); --i >= 0; ) {\r\n        assertTrue(s.tryAdvance(spliterated::add));\r\n        if (rnd.nextBoolean())\r\n            assertTrue(it.hasNext());\r\n        iterated.add(it.next());\r\n    }\r\n    Consumer alwaysThrows = e -> {\r\n        throw new AssertionError();\r\n    };\r\n    if (s.hasCharacteristics(Spliterator.CONCURRENT)) {\r\n        c.clear();\r\n        if (testImplementationDetails && !(c instanceof java.util.concurrent.ArrayBlockingQueue)) {\r\n            if (rnd.nextBoolean())\r\n                assertFalse(s.tryAdvance(alwaysThrows));\r\n            else\r\n                s.forEachRemaining(alwaysThrows);\r\n        }\r\n        if (it.hasNext())\r\n            iterated.add(it.next());\r\n        if (rnd.nextBoolean())\r\n            assertIteratorExhausted(it);\r\n    }\r\n    assertTrue(copy.containsAll(iterated));\r\n    assertTrue(copy.containsAll(spliterated));\r\n}"
}, {
	"Path": "net.minecraftforge.common.ForgeChunkManager.syncConfigDefaults",
	"Comment": "synchronizes the local fields with the values in the configuration object.",
	"Method": "void syncConfigDefaults(){\r\n    List<String> propOrder = new ArrayList<String>();\r\n    config.setCategoryComment(\"defaults\", \"Default configuration for forge chunk loading control\").setCategoryRequiresWorldRestart(\"defaults\", true);\r\n    Property temp = config.get(\"defaults\", \"enabled\", true);\r\n    temp.setComment(\"Are mod overrides enabled?\");\r\n    temp.setLanguageKey(\"forge.configgui.enableModOverrides\");\r\n    overridesEnabled = temp.getBoolean(true);\r\n    propOrder.add(\"enabled\");\r\n    temp = config.get(\"defaults\", \"maximumChunksPerTicket\", 25);\r\n    temp.setComment(\"The default maximum number of chunks a mod can force, per ticket, \\n\" + \"for a mod without an override. This is the maximum number of chunks a single ticket can force.\");\r\n    temp.setLanguageKey(\"forge.configgui.maximumChunksPerTicket\");\r\n    temp.setMinValue(0);\r\n    defaultMaxChunks = temp.getInt(25);\r\n    propOrder.add(\"maximumChunksPerTicket\");\r\n    temp = config.get(\"defaults\", \"maximumTicketCount\", 200);\r\n    temp.setComment(\"The default maximum ticket count for a mod which does not have an override\\n\" + \"in this file. This is the number of chunk loading requests a mod is allowed to make.\");\r\n    temp.setLanguageKey(\"forge.configgui.maximumTicketCount\");\r\n    temp.setMinValue(0);\r\n    defaultMaxCount = temp.getInt(200);\r\n    propOrder.add(\"maximumTicketCount\");\r\n    temp = config.get(\"defaults\", \"playerTicketCount\", 500);\r\n    temp.setComment(\"The number of tickets a player can be assigned instead of a mod. This is shared across all mods and it is up to the mods to use it.\");\r\n    temp.setLanguageKey(\"forge.configgui.playerTicketCount\");\r\n    temp.setMinValue(0);\r\n    playerTicketLength = temp.getInt(500);\r\n    propOrder.add(\"playerTicketCount\");\r\n    temp = config.get(\"defaults\", \"dormantChunkCacheSize\", 0);\r\n    temp.setComment(\"Unloaded chunks can first be kept in a dormant cache for quicker\\n\" + \"loading times. Specify the size (in chunks) of that cache here\");\r\n    temp.setLanguageKey(\"forge.configgui.dormantChunkCacheSize\");\r\n    temp.setMinValue(0);\r\n    dormantChunkCacheSize = temp.getInt(0);\r\n    propOrder.add(\"dormantChunkCacheSize\");\r\n    FMLLog.log.info(\"Configured a dormant chunk cache size of {}\", temp.getInt(0));\r\n    temp = config.get(\"defaults\", \"asyncChunkLoading\", true);\r\n    temp.setComment(\"Load chunks asynchronously for players, reducing load on the server thread.\\n\" + \"Can be disabled to help troubleshoot chunk loading issues.\");\r\n    temp.setLanguageKey(\"forge.configgui.asyncChunkLoading\");\r\n    asyncChunkLoading = temp.getBoolean(true);\r\n    propOrder.add(\"asyncChunkLoading\");\r\n    config.setCategoryPropertyOrder(\"defaults\", propOrder);\r\n    config.addCustomCategoryComment(ForgeVersion.MOD_ID, \"Sample mod specific control section.\\n\" + \"Copy this section and rename the with the modid for the mod you wish to override.\\n\" + \"A value of zero in either entry effectively disables any chunkloading capabilities\\n\" + \"for that mod\");\r\n    temp = config.get(ForgeVersion.MOD_ID, \"maximumTicketCount\", 200);\r\n    temp.setComment(\"Maximum ticket count for the mod. Zero disables chunkloading capabilities.\");\r\n    temp = config.get(ForgeVersion.MOD_ID, \"maximumChunksPerTicket\", 25);\r\n    temp.setComment(\"Maximum chunks per ticket for the mod.\");\r\n    for (String mod : config.getCategoryNames()) {\r\n        if (mod.equals(ForgeVersion.MOD_ID) || mod.equals(\"defaults\")) {\r\n            continue;\r\n        }\r\n        config.get(mod, \"maximumTicketCount\", 200).setLanguageKey(\"forge.configgui.maximumTicketCount\").setMinValue(0);\r\n        config.get(mod, \"maximumChunksPerTicket\", 25).setLanguageKey(\"forge.configgui.maximumChunksPerTicket\").setMinValue(0);\r\n    }\r\n    if (config.hasChanged()) {\r\n        config.save();\r\n    }\r\n}"
}, {
	"Path": "io.restassured.builder.RequestSpecBuilder.setProxy",
	"Comment": "instruct rest assured to connect to a proxy on the specified port on localhost with a specific scheme.",
	"Method": "RequestSpecBuilder setProxy(String host,int port,RequestSpecBuilder setProxy,String host,RequestSpecBuilder setProxy,int port,RequestSpecBuilder setProxy,String host,int port,String scheme,RequestSpecBuilder setProxy,URI uri,RequestSpecBuilder setProxy,ProxySpecification proxySpecification){\r\n    spec.proxy(proxySpecification);\r\n    return this;\r\n}"
}, {
	"Path": "net.minecraftforge.common.config.Property.isBooleanValue",
	"Comment": "checks if the current value held by this property is a valid boolean value.",
	"Method": "boolean isBooleanValue(){\r\n    return (\"true\".equals(value.toLowerCase()) || \"false\".equals(value.toLowerCase()));\r\n}"
}, {
	"Path": "net.minecraftforge.common.config.Property.getArrayEntryClass",
	"Comment": "gets the custom iarrayentry class that should be used in place of the standard entry class for this property type, or null ifnone has been set.",
	"Method": "Class<? extends IArrayEntry> getArrayEntryClass(){\r\n    return this.arrayEntryClass;\r\n}"
}]