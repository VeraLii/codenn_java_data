[{
	"Path": "org.terasology.logic.players.PlayerFactory.findOpenVerticalPosition",
	"Comment": "find a spot above the surface that is big enough for this character",
	"Method": "Vector3i findOpenVerticalPosition(Vector3i spawnPos,float height){\r\n    int consecutiveAirBlocks = 0;\r\n    Vector3i newSpawnPos = new Vector3i(spawnPos);\r\n    for (int i = 1; i < 20; i++) {\r\n        if (worldProvider.isBlockRelevant(newSpawnPos)) {\r\n            if (worldProvider.getBlock(newSpawnPos).isPenetrable()) {\r\n                consecutiveAirBlocks++;\r\n            } else {\r\n                consecutiveAirBlocks = 0;\r\n            }\r\n            if (consecutiveAirBlocks >= height) {\r\n                newSpawnPos.subY(consecutiveAirBlocks);\r\n                return newSpawnPos;\r\n            }\r\n            newSpawnPos.add(0, 1, 0);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.terasology.engine.subsystem.openvr.OpenVRControllers.getControllers",
	"Comment": "get the controller names provided by this controllerdevice.",
	"Method": "List<String> getControllers(){\r\n    List<String> ids = new ArrayList();\r\n    ids.add(\"OpenVR\");\r\n    return ids;\r\n}"
}, {
	"Path": "org.springframework.security.messaging.context.SecurityContextChannelInterceptorTests.restoresOriginalContextNestedThreeDeep",
	"Comment": "if a user sends a websocket when processing another websocket",
	"Method": "void restoresOriginalContextNestedThreeDeep(){\r\n    AnonymousAuthenticationToken anonymous = new AnonymousAuthenticationToken(\"key\", \"anonymous\", AuthorityUtils.createAuthorityList(\"ROLE_USER\"));\r\n    TestingAuthenticationToken origional = new TestingAuthenticationToken(\"original\", \"origional\", \"ROLE_USER\");\r\n    SecurityContextHolder.getContext().setAuthentication(origional);\r\n    messageBuilder.setHeader(SimpMessageHeaderAccessor.USER_HEADER, authentication);\r\n    interceptor.beforeHandle(messageBuilder.build(), channel, handler);\r\n    assertThat(SecurityContextHolder.getContext().getAuthentication()).isSameAs(authentication);\r\n    messageBuilder.setHeader(SimpMessageHeaderAccessor.USER_HEADER, null);\r\n    interceptor.beforeHandle(messageBuilder.build(), channel, handler);\r\n    assertThat(SecurityContextHolder.getContext().getAuthentication().getName()).isEqualTo(anonymous.getName());\r\n    interceptor.afterMessageHandled(messageBuilder.build(), channel, handler, null);\r\n    assertThat(SecurityContextHolder.getContext().getAuthentication()).isSameAs(authentication);\r\n    interceptor.afterMessageHandled(messageBuilder.build(), channel, handler, null);\r\n    assertThat(SecurityContextHolder.getContext().getAuthentication()).isSameAs(origional);\r\n}"
}, {
	"Path": "org.springframework.security.oauth2.server.resource.web.access.server.BearerTokenServerAccessDeniedHandler.setRealmName",
	"Comment": "set the default realm name to use in the bearer token error response",
	"Method": "void setRealmName(String realmName){\r\n    this.realmName = realmName;\r\n}"
}, {
	"Path": "org.terasology.math.ChunkMath.getEdgeRegion",
	"Comment": "produces a region containing the region touching the side of the given region, both in and outside the region.",
	"Method": "Region3i getEdgeRegion(Region3i region,Side side){\r\n    Vector3i sideDir = side.getVector3i();\r\n    Vector3i min = region.min();\r\n    Vector3i max = region.max();\r\n    Vector3i edgeMin = new Vector3i(min);\r\n    Vector3i edgeMax = new Vector3i(max);\r\n    if (sideDir.x < 0) {\r\n        edgeMin.x = min.x;\r\n        edgeMax.x = min.x;\r\n    } else if (sideDir.x > 0) {\r\n        edgeMin.x = max.x;\r\n        edgeMax.x = max.x;\r\n    } else if (sideDir.y < 0) {\r\n        edgeMin.y = min.y;\r\n        edgeMax.y = min.y;\r\n    } else if (sideDir.y > 0) {\r\n        edgeMin.y = max.y;\r\n        edgeMax.y = max.y;\r\n    } else if (sideDir.z < 0) {\r\n        edgeMin.z = min.z;\r\n        edgeMax.z = min.z;\r\n    } else if (sideDir.z > 0) {\r\n        edgeMin.z = max.z;\r\n        edgeMax.z = max.z;\r\n    }\r\n    return Region3i.createFromMinMax(edgeMin, edgeMax);\r\n}"
}, {
	"Path": "org.terasology.input.InputSystem.sendMouseWheelEvent",
	"Comment": "creates and sends an input event based on a provided mouse wheel action.",
	"Method": "boolean sendMouseWheelEvent(Vector2i pos,int wheelTurns,float delta){\r\n    MouseWheelEvent mouseWheelEvent = new MouseWheelEvent(pos, wheelTurns, delta);\r\n    return send(mouseWheelEvent);\r\n}"
}, {
	"Path": "org.terasology.persistence.internal.GamePreviewImageProvider.getNextPreviewImageName",
	"Comment": "gets next preview image name. names are looped and starts from 1.jpg.if there are less than limit files. it takes next number, else the oldest file.",
	"Method": "String getNextPreviewImageName(List<Path> paths){\r\n    if (paths.size() < LIMIT) {\r\n        return getNextNumberFileName(paths);\r\n    }\r\n    return getOldestFileName(paths);\r\n}"
}, {
	"Path": "springfox.documentation.builders.OAuthBuilder.grantTypes",
	"Comment": "updates the grant types that this security definition represents",
	"Method": "OAuthBuilder grantTypes(List<GrantType> grantTypes){\r\n    this.grantTypes.addAll(nullToEmptyList(grantTypes));\r\n    return this;\r\n}"
}, {
	"Path": "org.terasology.math.Rotation.allValues",
	"Comment": "returns all possible rotations for each yaw, pitch & roll combination, including duplicates.",
	"Method": "Iterable<Rotation> allValues(){\r\n    return Arrays.asList(ALL_ROTATIONS);\r\n}"
}, {
	"Path": "org.springframework.security.ldap.SpringSecurityLdapTemplate.searchForMultipleAttributeValues",
	"Comment": "performs a search using the supplied filter and returns the values of each named\tattribute found in all entries matched by the search. note that one directory entry\tmay have several values for the attribute. intended for role searches and similar\tscenarios.",
	"Method": "Set<Map<String, List<String>>> searchForMultipleAttributeValues(String base,String filter,Object[] params,String[] attributeNames){\r\n    Object[] encodedParams = new String[params.length];\r\n    for (int i = 0; i < params.length; i++) {\r\n        encodedParams[i] = LdapEncoder.filterEncode(params[i].toString());\r\n    }\r\n    String formattedFilter = MessageFormat.format(filter, encodedParams);\r\n    logger.debug(\"Using filter: \" + formattedFilter);\r\n    final HashSet<Map<String, List<String>>> set = new HashSet<Map<String, List<String>>>();\r\n    ContextMapper roleMapper = new ContextMapper() {\r\n        public Object mapFromContext(Object ctx) {\r\n            DirContextAdapter adapter = (DirContextAdapter) ctx;\r\n            Map<String, List<String>> record = new HashMap<String, List<String>>();\r\n            if (attributeNames == null || attributeNames.length == 0) {\r\n                try {\r\n                    for (NamingEnumeration ae = adapter.getAttributes().getAll(); ae.hasMore(); ) {\r\n                        Attribute attr = (Attribute) ae.next();\r\n                        extractStringAttributeValues(adapter, record, attr.getID());\r\n                    }\r\n                } catch (NamingException x) {\r\n                    org.springframework.ldap.support.LdapUtils.convertLdapException(x);\r\n                }\r\n            } else {\r\n                for (String attributeName : attributeNames) {\r\n                    extractStringAttributeValues(adapter, record, attributeName);\r\n                }\r\n            }\r\n            record.put(DN_KEY, Arrays.asList(getAdapterDN(adapter)));\r\n            set.add(record);\r\n            return null;\r\n        }\r\n    };\r\n    SearchControls ctls = new SearchControls();\r\n    ctls.setSearchScope(searchControls.getSearchScope());\r\n    ctls.setReturningAttributes(attributeNames != null && attributeNames.length > 0 ? attributeNames : null);\r\n    search(base, formattedFilter, ctls, roleMapper);\r\n    return set;\r\n}"
}, {
	"Path": "org.springframework.security.ldap.SpringSecurityLdapTemplate.searchForMultipleAttributeValues",
	"Comment": "performs a search using the supplied filter and returns the values of each named\tattribute found in all entries matched by the search. note that one directory entry\tmay have several values for the attribute. intended for role searches and similar\tscenarios.",
	"Method": "Set<Map<String, List<String>>> searchForMultipleAttributeValues(String base,String filter,Object[] params,String[] attributeNames){\r\n    DirContextAdapter adapter = (DirContextAdapter) ctx;\r\n    Map<String, List<String>> record = new HashMap<String, List<String>>();\r\n    if (attributeNames == null || attributeNames.length == 0) {\r\n        try {\r\n            for (NamingEnumeration ae = adapter.getAttributes().getAll(); ae.hasMore(); ) {\r\n                Attribute attr = (Attribute) ae.next();\r\n                extractStringAttributeValues(adapter, record, attr.getID());\r\n            }\r\n        } catch (NamingException x) {\r\n            org.springframework.ldap.support.LdapUtils.convertLdapException(x);\r\n        }\r\n    } else {\r\n        for (String attributeName : attributeNames) {\r\n            extractStringAttributeValues(adapter, record, attributeName);\r\n        }\r\n    }\r\n    record.put(DN_KEY, Arrays.asList(getAdapterDN(adapter)));\r\n    set.add(record);\r\n    return null;\r\n}"
}, {
	"Path": "org.terasology.config.flexible.validators.RangedNumberValidator.getMax",
	"Comment": "returns the maximum value in the range. a null value signifies the absence of any maximum value.",
	"Method": "T getMax(){\r\n    return max;\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.layouts.relative.HorizontalHint.center",
	"Comment": "centers the widget on part of the drawing area but with a pixel offset",
	"Method": "HorizontalHint center(HorizontalHint center,int offset,HorizontalHint center,HorizontalAlign targetPart,HorizontalHint center,HorizontalAlign targetPart,int offset){\r\n    return centerRelativeTo(\"\", targetPart, offset);\r\n}"
}, {
	"Path": "org.springframework.security.config.web.server.ServerHttpSecurity.getSecurityMatcher",
	"Comment": "gets the serverexchangematcher that determines which requests apply to this httpsecurity instance.",
	"Method": "ServerWebExchangeMatcher getSecurityMatcher(){\r\n    return this.securityMatcher;\r\n}"
}, {
	"Path": "org.terasology.rendering.openvrprovider.OpenVRProvider.setKeyboardOverlayShowing",
	"Comment": "turn on the keyboard overlay. this is a keyboard that hovers in front of the user, that can be typed upon bypointing the ray extending from the top of the controller at the key the user wants to press.",
	"Method": "boolean setKeyboardOverlayShowing(boolean showingState){\r\n    int ret;\r\n    if (showingState) {\r\n        Pointer pointer = new Memory(3);\r\n        pointer.setString(0, \"mc\");\r\n        Pointer empty = new Memory(1);\r\n        empty.setString(0, \"\");\r\n        ret = vrOverlay.ShowKeyboard.apply(0, 0, pointer, 256, empty, (byte) 1, 0);\r\n        keyboardShowing = 0 == ret;\r\n        if (ret != 0) {\r\n            logger.error(\"VR Overlay Error: \" + vrOverlay.GetOverlayErrorNameFromEnum.apply(ret).getString(0));\r\n        }\r\n    } else {\r\n        try {\r\n            vrOverlay.HideKeyboard.apply();\r\n        } catch (Error e) {\r\n            logger.error(\"Error bringing up keyboard overlay: \" + e.toString());\r\n        }\r\n        keyboardShowing = false;\r\n    }\r\n    return keyboardShowing;\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.layers.mainMenu.StartPlayingScreen.setTargetWorld",
	"Comment": "this method is called before the screen comes to the forefront to set the worldin which the player is about to spawn.",
	"Method": "void setTargetWorld(List<WorldSetupWrapper> worldSetupWrapperList,WorldSetupWrapper spawnWorld,Texture targetWorldTexture,Context context){\r\n    texture = targetWorldTexture;\r\n    worldSetupWrappers = worldSetupWrapperList;\r\n    universeWrapper = context.get(UniverseWrapper.class);\r\n    targetWorld = spawnWorld;\r\n}"
}, {
	"Path": "springfox.documentation.builders.ApiInfoBuilder.contact",
	"Comment": "updates contact information for the person responsible for this api",
	"Method": "ApiInfoBuilder contact(String contact,ApiInfoBuilder contact,Contact contact){\r\n    this.contact = contact;\r\n    return this;\r\n}"
}, {
	"Path": "org.terasology.logic.characters.GazeAuthoritySystem.getGazeEntityForCharacter",
	"Comment": "returns the gaze entity if it exists, otherwise the character entity will be returned.",
	"Method": "EntityRef getGazeEntityForCharacter(EntityRef character){\r\n    GazeMountPointComponent gazeMountPointComponent = character.getComponent(GazeMountPointComponent.class);\r\n    if (gazeMountPointComponent != null && gazeMountPointComponent.gazeEntity.exists()) {\r\n        return gazeMountPointComponent.gazeEntity;\r\n    }\r\n    return character;\r\n}"
}, {
	"Path": "org.terasology.physics.bullet.BulletPhysics.createCustomCollider",
	"Comment": "creates a new collider. colliders are similar to rigid bodies, exceptthat they do not respond to forces from the physics engine. they collidewith other objects and other objects may move if colliding with acollider, but the collider itself will only respond to movement ordersfrom outside the physics engine. colliders also detect any objectscolliding with them. allowing them to be used as sensors.",
	"Method": "CharacterCollider createCustomCollider(Vector3f pos,ConvexShape shape,short groups,short filters,int collisionFlags,EntityRef entity){\r\n    if (entityColliders.containsKey(entity)) {\r\n        entityColliders.remove(entity);\r\n    }\r\n    final BulletCharacterMoverCollider bulletCollider = new BulletCharacterMoverCollider(pos, shape, groups, filters, collisionFlags, entity);\r\n    entityColliders.put(entity, bulletCollider);\r\n    return bulletCollider;\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.layers.mainMenu.UniverseSetupScreen.findWorldByName",
	"Comment": "this method takes the name of the selected world as string and return the correspondingworldsetupwrapper object.",
	"Method": "WorldSetupWrapper findWorldByName(){\r\n    for (WorldSetupWrapper world : worlds) {\r\n        if (world.getWorldName().toString().equals(selectedWorld)) {\r\n            return world;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.security.ldap.userdetails.DefaultLdapAuthoritiesPopulator.getGroupRoleAttribute",
	"Comment": "returns the attribute name of the ldap attribute that will be mapped to the role\tname method available so that classes extending this can override",
	"Method": "String getGroupRoleAttribute(){\r\n    return this.groupRoleAttribute;\r\n}"
}, {
	"Path": "org.terasology.logic.characters.KinematicCharacterMover.checkStep",
	"Comment": "checks of the player will step up to an object. in a single movement step the player can only step up a single item.",
	"Method": "boolean checkStep(CharacterCollider collider,Vector3f position,Vector3f direction,SweepCallback callback,float slopeFactor,float stepHeight){\r\n    if (!stepped) {\r\n        stepped = true;\r\n        boolean moveUpStep = callback.checkForStep(direction, stepHeight, slopeFactor, CHECK_FORWARD_DIST);\r\n        if (moveUpStep) {\r\n            steppedUpDist = moveUp(stepHeight, collider, position);\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.terasology.engine.TerasologyEngine.preInitSubsystems",
	"Comment": "gives a chance to subsystems to do something before managers and time are initialized.",
	"Method": "void preInitSubsystems(){\r\n    changeStatus(TerasologyEngineStatus.PREPARING_SUBSYSTEMS);\r\n    for (EngineSubsystem subsystem : getSubsystems()) {\r\n        changeStatus(() -> \"Pre-initialising \" + subsystem.getName() + \" subsystem\");\r\n        subsystem.preInitialise(rootContext);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.ldap.userdetails.DefaultLdapAuthoritiesPopulator.isConvertToUpperCase",
	"Comment": "returns true if role names are converted to uppercase method available so that\tclasses extending this can override",
	"Method": "boolean isConvertToUpperCase(){\r\n    return this.convertToUpperCase;\r\n}"
}, {
	"Path": "org.terasology.rendering.logic.NearestSortingList.getEntities",
	"Comment": "returns a copy of the entities in this container. although it is notguaranteed the list is sorted, attempts have been made to put entitiesnearer to the player at a lower index.",
	"Method": "List<EntityRef> getEntities(){\r\n    return cloneEntities();\r\n}"
}, {
	"Path": "org.terasology.logic.delay.DelayedActionSystem.setTime",
	"Comment": "only use this for testing. do not use this during regular usage.",
	"Method": "void setTime(Time t){\r\n    time = t;\r\n}"
}, {
	"Path": "org.terasology.logic.console.ConsoleImpl.getCommand",
	"Comment": "get a group of commands by their name. these will vary by the number of parameters they accept",
	"Method": "ConsoleCommand getCommand(Name name){\r\n    return commandRegistry.get(name);\r\n}"
}, {
	"Path": "org.springframework.security.openid.RegexBasedAxFetchListFactory.createAttributeList",
	"Comment": "iterates through the patterns stored in the map and returns the list of attributes\tdefined for the first match. if no match is found, returns an empty list.",
	"Method": "List<OpenIDAttribute> createAttributeList(String identifier){\r\n    for (Map.Entry<Pattern, List<OpenIDAttribute>> entry : idToAttributes.entrySet()) {\r\n        if (entry.getKey().matcher(identifier).matches()) {\r\n            return entry.getValue();\r\n        }\r\n    }\r\n    return Collections.emptyList();\r\n}"
}, {
	"Path": "org.springframework.security.access.vote.AuthenticatedVoter.supports",
	"Comment": "this implementation supports any type of class, because it does not query the\tpresented secure object.",
	"Method": "boolean supports(ConfigAttribute attribute,boolean supports,Class<?> clazz){\r\n    return true;\r\n}"
}, {
	"Path": "org.springframework.security.authentication.dao.AbstractUserDetailsAuthenticationProvider.setHideUserNotFoundExceptions",
	"Comment": "by default the abstractuserdetailsauthenticationprovider throws a\tbadcredentialsexception if a username is not found or the password is\tincorrect. setting this property to false will cause\tusernamenotfoundexceptions to be thrown instead for the former. note\tthis is considered less secure than throwing badcredentialsexception\tfor both exceptions.",
	"Method": "void setHideUserNotFoundExceptions(boolean hideUserNotFoundExceptions){\r\n    this.hideUserNotFoundExceptions = hideUserNotFoundExceptions;\r\n}"
}, {
	"Path": "org.springframework.security.openid.OpenIDAuthenticationFilter.obtainUsername",
	"Comment": "reads the claimedidentityfieldname from the submitted request.",
	"Method": "String obtainUsername(HttpServletRequest req){\r\n    String claimedIdentity = req.getParameter(claimedIdentityFieldName);\r\n    if (!StringUtils.hasText(claimedIdentity)) {\r\n        logger.error(\"No claimed identity supplied in authentication request\");\r\n        return \"\";\r\n    }\r\n    return claimedIdentity.trim();\r\n}"
}, {
	"Path": "org.springframework.security.ldap.authentication.ad.ActiveDirectoryLdapAuthenticationProvider.setContextEnvironmentProperties",
	"Comment": "allows a custom environment properties to be used to create initial ldap context.",
	"Method": "void setContextEnvironmentProperties(Map<String, Object> environment){\r\n    Assert.notEmpty(environment, \"environment must not be empty\");\r\n    this.contextEnvironmentProperties = new Hashtable(environment);\r\n}"
}, {
	"Path": "org.terasology.recording.EventCatcher.addEvent",
	"Comment": "receives a pendingevent and add it as a recordedevent in the recordedeventstore if it is an event type that should berecorded.",
	"Method": "boolean addEvent(PendingEvent pendingEvent){\r\n    if (shouldRecordEvent(pendingEvent)) {\r\n        long timestamp = System.currentTimeMillis() - this.startTime;\r\n        Event e = this.eventCopier.copyEvent(pendingEvent.getEvent());\r\n        PendingEvent newPendingEvent = new PendingEvent(pendingEvent.getEntity(), e);\r\n        RecordedEvent recordedEvent;\r\n        if (pendingEvent.getComponent() == null) {\r\n            recordedEvent = new RecordedEvent(newPendingEvent.getEntity().getId(), newPendingEvent.getEvent(), timestamp, this.eventCounter);\r\n        } else {\r\n            recordedEvent = new RecordedEvent(newPendingEvent.getEntity().getId(), newPendingEvent.getEvent(), newPendingEvent.getComponent(), timestamp, eventCounter);\r\n        }\r\n        this.eventCounter++;\r\n        return recordedEventStore.add(recordedEvent);\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.terasology.logic.players.FirstPersonClientSystem.update",
	"Comment": "modifies the held item mount point to move the held item in first person view",
	"Method": "void update(float delta){\r\n    if (!currentHeldItem.exists() && currentHeldItem != getHandEntity()) {\r\n        linkHeldItemLocationForLocalPlayer(getHandEntity());\r\n    }\r\n    for (EntityRef entityRef : entityManager.getEntitiesWith(ItemIsHeldComponent.class)) {\r\n        if (!entityRef.equals(currentHeldItem) && !entityRef.equals(handEntity)) {\r\n            entityRef.destroy();\r\n        }\r\n    }\r\n    CharacterHeldItemComponent characterHeldItemComponent = localPlayer.getCharacterEntity().getComponent(CharacterHeldItemComponent.class);\r\n    FirstPersonHeldItemMountPointComponent mountPointComponent = localPlayer.getCameraEntity().getComponent(FirstPersonHeldItemMountPointComponent.class);\r\n    if (characterHeldItemComponent == null || mountPointComponent == null) {\r\n        return;\r\n    }\r\n    LocationComponent locationComponent = mountPointComponent.mountPointEntity.getComponent(LocationComponent.class);\r\n    if (locationComponent == null) {\r\n        return;\r\n    }\r\n    long timeElapsedSinceLastUsed = time.getGameTimeInMs() - characterHeldItemComponent.lastItemUsedTime;\r\n    float animateAmount = 0f;\r\n    if (timeElapsedSinceLastUsed < USEANIMATIONLENGTH) {\r\n        animateAmount = 1f - Math.abs(((float) timeElapsedSinceLastUsed / (float) USEANIMATIONLENGTH) - 0.5f);\r\n    }\r\n    float addPitch = 15f * animateAmount;\r\n    float addYaw = 10f * animateAmount;\r\n    locationComponent.setLocalRotation(new Quat4f(TeraMath.DEG_TO_RAD * (mountPointComponent.rotateDegrees.y + addYaw), TeraMath.DEG_TO_RAD * (mountPointComponent.rotateDegrees.x + addPitch), TeraMath.DEG_TO_RAD * mountPointComponent.rotateDegrees.z));\r\n    Vector3f offset = new Vector3f(0.25f * animateAmount, -0.12f * animateAmount, 0f);\r\n    offset.add(mountPointComponent.translate);\r\n    locationComponent.setLocalPosition(offset);\r\n    mountPointComponent.mountPointEntity.saveComponent(locationComponent);\r\n}"
}, {
	"Path": "org.terasology.engine.subsystem.openvr.OpenVRControllers.getInputQueue",
	"Comment": "get all queued actions registered since this method was last called.",
	"Method": "Queue<ControllerAction> getInputQueue(){\r\n    Queue<ControllerAction> result = new ArrayDeque(queuedActions);\r\n    queuedActions.clear();\r\n    return result;\r\n}"
}, {
	"Path": "org.springframework.security.authentication.jaas.JaasAuthenticationProvider.configureJaasUsingLoop",
	"Comment": "loops through the login.config.url.1,login.config.url.2 properties looking for the\tlogin configuration. if it is not set, it will be set to the last available\tlogin.config.url.x property.",
	"Method": "void configureJaasUsingLoop(){\r\n    String loginConfigUrl = convertLoginConfigToUrl();\r\n    boolean alreadySet = false;\r\n    int n = 1;\r\n    final String prefix = \"login.config.url.\";\r\n    String existing;\r\n    while ((existing = Security.getProperty(prefix + n)) != null) {\r\n        alreadySet = existing.equals(loginConfigUrl);\r\n        if (alreadySet) {\r\n            break;\r\n        }\r\n        n++;\r\n    }\r\n    if (!alreadySet) {\r\n        String key = prefix + n;\r\n        log.debug(\"Setting security property [\" + key + \"] to: \" + loginConfigUrl);\r\n        Security.setProperty(key, loginConfigUrl);\r\n    }\r\n}"
}, {
	"Path": "org.terasology.math.Region3i.expand",
	"Comment": "creates a new region that is the same as this region but expanded in all directions by the given amount",
	"Method": "Region3i expand(int amount,Region3i expand,BaseVector3i amount){\r\n    Vector3i expandedMin = min();\r\n    expandedMin.sub(amount);\r\n    Vector3i expandedMax = max();\r\n    expandedMax.add(amount);\r\n    return createFromMinMax(expandedMin, expandedMax);\r\n}"
}, {
	"Path": "org.terasology.input.lwjgl.JInputControllerDevice.removeController",
	"Comment": "removes a controller. also works while iterating over the list.",
	"Method": "void removeController(Controller controller){\r\n    controllers.remove(controller);\r\n    logger.info(\"Removed controller: \" + controller.getName());\r\n}"
}, {
	"Path": "springfox.documentation.spring.web.plugins.Docket.globalOperationParameters",
	"Comment": "adds default parameters which will be applied to all operations.",
	"Method": "Docket globalOperationParameters(List<Parameter> operationParameters){\r\n    this.globalOperationParameters.addAll(nullToEmptyList(operationParameters));\r\n    return this;\r\n}"
}, {
	"Path": "org.terasology.rendering.opengl.FBO.bindNormalsTexture",
	"Comment": "binds the normals attachment to the currently active texture unit.once a texture is bound it can be sampled by shaders.",
	"Method": "void bindNormalsTexture(){\r\n    GL11.glBindTexture(GL11.GL_TEXTURE_2D, normalsBufferTextureId);\r\n}"
}, {
	"Path": "org.springframework.security.authentication.jaas.AbstractJaasAuthenticationProvider.setCallbackHandlers",
	"Comment": "set the jaasauthentcationcallbackhandler array to handle callback objects generated\tby the logincontext.login method.",
	"Method": "void setCallbackHandlers(JaasAuthenticationCallbackHandler[] callbackHandlers){\r\n    this.callbackHandlers = callbackHandlers;\r\n}"
}, {
	"Path": "org.springframework.security.util.MethodInvocationUtils.create",
	"Comment": "generates a methodinvocation for specified methodname on\tthe passed object, using the args to locate the method.",
	"Method": "MethodInvocation create(Object object,String methodName,Object args){\r\n    Assert.notNull(object, \"Object required\");\r\n    Class<?>[] classArgs = null;\r\n    if (args != null) {\r\n        classArgs = new Class<?>[args.length];\r\n        for (int i = 0; i < args.length; i++) {\r\n            classArgs[i] = args[i].getClass();\r\n        }\r\n    }\r\n    Class<?> target = AopUtils.getTargetClass(object);\r\n    if (object instanceof Advised) {\r\n        Advised a = (Advised) object;\r\n        if (!a.isProxyTargetClass()) {\r\n            Class<?>[] possibleInterfaces = a.getProxiedInterfaces();\r\n            for (Class<?> possibleInterface : possibleInterfaces) {\r\n                try {\r\n                    possibleInterface.getMethod(methodName, classArgs);\r\n                    target = possibleInterface;\r\n                    break;\r\n                } catch (Exception ignored) {\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return createFromClass(object, target, methodName, classArgs, args);\r\n}"
}, {
	"Path": "org.terasology.persistence.serializers.EntitySerializer.deserializeOntoComponents",
	"Comment": "deserializes the components from an entitydata onto a map of components",
	"Method": "void deserializeOntoComponents(EntityData.Entity entityData,Map<Class<? extends Component>, Component> componentMap){\r\n    EntityInfoComponent entityInfo = (EntityInfoComponent) componentMap.get(EntityInfoComponent.class);\r\n    if (entityInfo == null) {\r\n        entityInfo = new EntityInfoComponent();\r\n        componentMap.put(EntityInfoComponent.class, entityInfo);\r\n    }\r\n    if (entityData.hasOwner()) {\r\n        entityInfo.owner = entityManager.getEntity(entityData.getOwner());\r\n    }\r\n    if (entityData.hasAlwaysRelevant()) {\r\n        entityInfo.alwaysRelevant = entityData.getAlwaysRelevant();\r\n    }\r\n    switch(entityData.getScope()) {\r\n        case GLOBAL:\r\n            entityInfo.scope = EntityScope.GLOBAL;\r\n            break;\r\n        case SECTOR:\r\n            entityInfo.scope = EntityScope.SECTOR;\r\n            break;\r\n        case CHUNK:\r\n            entityInfo.scope = EntityScope.CHUNK;\r\n            break;\r\n    }\r\n    for (EntityData.Component componentData : entityData.getComponentList()) {\r\n        ComponentMetadata<? extends Component> metadata = componentSerializer.getComponentMetadata(componentData);\r\n        if (metadata == null || !componentSerializeCheck.serialize(metadata)) {\r\n            continue;\r\n        }\r\n        Component existingComponent = componentMap.get(metadata.getType());\r\n        if (existingComponent == null) {\r\n            Component newComponent = componentSerializer.deserialize(componentData);\r\n            componentMap.put(metadata.getType(), newComponent);\r\n        } else {\r\n            componentSerializer.deserializeOnto(existingComponent, componentData, FieldSerializeCheck.NullCheck.<Component>newInstance());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.terasology.logic.console.commands.CoreCommands.dumpEntities",
	"Comment": "writes out information on all entities to a text file for debugging",
	"Method": "void dumpEntities(){\r\n    EngineEntityManager engineEntityManager = (EngineEntityManager) entityManager;\r\n    PrefabSerializer prefabSerializer = new PrefabSerializer(engineEntityManager.getComponentLibrary(), engineEntityManager.getTypeSerializerLibrary());\r\n    WorldDumper worldDumper = new WorldDumper(engineEntityManager, prefabSerializer);\r\n    worldDumper.save(PathManager.getInstance().getHomePath().resolve(\"entityDump.txt\"));\r\n}"
}, {
	"Path": "org.terasology.world.block.family.MultiConnectFamily.getBlockForPlacement",
	"Comment": "using the location of the block, the side the block is being attached to and the direction the block is being placed in,determine what block should be placed.",
	"Method": "Block getBlockForPlacement(Vector3i location,Side attachmentSide,Side direction){\r\n    byte connections = 0;\r\n    for (Side connectSide : SideBitFlag.getSides(getConnectionSides())) {\r\n        if (this.connectionCondition(location, connectSide)) {\r\n            connections += SideBitFlag.getSide(connectSide);\r\n        }\r\n    }\r\n    return blocks.get(connections);\r\n}"
}, {
	"Path": "org.springframework.security.access.intercept.AbstractSecurityInterceptor.afterInvocation",
	"Comment": "completes the work of the abstractsecurityinterceptor after the secure\tobject invocation has been completed.",
	"Method": "Object afterInvocation(InterceptorStatusToken token,Object returnedObject){\r\n    if (token == null) {\r\n        return returnedObject;\r\n    }\r\n    finallyInvocation(token);\r\n    if (afterInvocationManager != null) {\r\n        try {\r\n            returnedObject = afterInvocationManager.decide(token.getSecurityContext().getAuthentication(), token.getSecureObject(), token.getAttributes(), returnedObject);\r\n        } catch (AccessDeniedException accessDeniedException) {\r\n            AuthorizationFailureEvent event = new AuthorizationFailureEvent(token.getSecureObject(), token.getAttributes(), token.getSecurityContext().getAuthentication(), accessDeniedException);\r\n            publishEvent(event);\r\n            throw accessDeniedException;\r\n        }\r\n    }\r\n    return returnedObject;\r\n}"
}, {
	"Path": "org.terasology.rendering.primitives.ChunkMesh.updateMaterial",
	"Comment": "updates a given material with information such as the world position of a chunk and whether it is animated.",
	"Method": "void updateMaterial(Material chunkMaterial,Vector3f chunkPosition,boolean chunkIsAnimated){\r\n    chunkMaterial.setFloat3(\"chunkPositionWorld\", chunkPosition.x * ChunkConstants.SIZE_X, chunkPosition.y * ChunkConstants.SIZE_Y, chunkPosition.z * ChunkConstants.SIZE_Z, true);\r\n    chunkMaterial.setFloat(\"animated\", chunkIsAnimated ? 1.0f : 0.0f, true);\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.rememberme.AbstractRememberMeServices.extractRememberMeCookie",
	"Comment": "locates the spring security remember me cookie in the request and returns its\tvalue. the cookie is searched for by name and also by matching the context path to\tthe cookie path.",
	"Method": "String extractRememberMeCookie(HttpServletRequest request){\r\n    Cookie[] cookies = request.getCookies();\r\n    if ((cookies == null) || (cookies.length == 0)) {\r\n        return null;\r\n    }\r\n    for (Cookie cookie : cookies) {\r\n        if (cookieName.equals(cookie.getName())) {\r\n            return cookie.getValue();\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl.loadUsersByUsername",
	"Comment": "executes the sql usersbyusernamequery and returns a list of userdetails\tobjects. there should normally only be one matching user.",
	"Method": "List<UserDetails> loadUsersByUsername(String username){\r\n    return getJdbcTemplate().query(this.usersByUsernameQuery, new String[] { username }, new RowMapper<UserDetails>() {\r\n        @Override\r\n        public UserDetails mapRow(ResultSet rs, int rowNum) throws SQLException {\r\n            String username = rs.getString(1);\r\n            String password = rs.getString(2);\r\n            boolean enabled = rs.getBoolean(3);\r\n            return new User(username, password, enabled, true, true, true, AuthorityUtils.NO_AUTHORITIES);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl.loadUsersByUsername",
	"Comment": "executes the sql usersbyusernamequery and returns a list of userdetails\tobjects. there should normally only be one matching user.",
	"Method": "List<UserDetails> loadUsersByUsername(String username){\r\n    String username = rs.getString(1);\r\n    String password = rs.getString(2);\r\n    boolean enabled = rs.getBoolean(3);\r\n    return new User(username, password, enabled, true, true, true, AuthorityUtils.NO_AUTHORITIES);\r\n}"
}, {
	"Path": "springfox.documentation.builders.OperationBuilder.uniqueId",
	"Comment": "updates the uniqueid for the operation. this will be used to seed the unique id",
	"Method": "OperationBuilder uniqueId(String uniqueId){\r\n    this.uniqueId = defaultIfAbsent(uniqueId, this.uniqueId);\r\n    return this;\r\n}"
}, {
	"Path": "org.terasology.input.InputSystem.processControllerAxisInput",
	"Comment": "processes input actions by controller axis, and updates bind axis accordingly.",
	"Method": "void processControllerAxisInput(ControllerAction action,Input input){\r\n    BindableRealAxis axis = bindsManager.getControllerAxisBinds().get(input);\r\n    if (axis != null) {\r\n        ControllerInfo info = inputDeviceConfig.getController(action.getController());\r\n        boolean isX = action.getInput().getId() == ControllerId.X_AXIS;\r\n        boolean isY = action.getInput().getId() == ControllerId.Y_AXIS;\r\n        boolean isZ = action.getInput().getId() == ControllerId.Z_AXIS;\r\n        float f = (isX && info.isInvertX() || isY && info.isInvertY() || isZ && info.isInvertZ()) ? -1 : 1;\r\n        axis.setTargetValue(action.getAxisValue() * f);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.ldap.SpringSecurityLdapTemplate.setSearchControls",
	"Comment": "sets the search controls which will be used for search operations by the template.",
	"Method": "void setSearchControls(SearchControls searchControls){\r\n    this.searchControls = searchControls;\r\n}"
}, {
	"Path": "org.springframework.security.ldap.authentication.AbstractLdapAuthenticator.setUserAttributes",
	"Comment": "sets the user attributes which will be retrieved from the directory.",
	"Method": "void setUserAttributes(String[] userAttributes){\r\n    Assert.notNull(userAttributes, \"The userAttributes property cannot be set to null\");\r\n    this.userAttributes = userAttributes;\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.layouts.ScrollableArea.drawWithNeither",
	"Comment": "draws the widget with neither a horizontal or vertical scrollbar.if the widget is too large in either axis, it will be cropped",
	"Method": "void drawWithNeither(Canvas canvas,Vector2i availableSize){\r\n    canvas.drawWidget(content, Rect2i.createFromMinAndSize(Vector2i.zero(), availableSize));\r\n}"
}, {
	"Path": "org.terasology.logic.console.ConsoleImpl.subscribe",
	"Comment": "subscribe for notification of all messages added to the console",
	"Method": "void subscribe(ConsoleSubscriber subscriber){\r\n    this.messageSubscribers.add(subscriber);\r\n}"
}, {
	"Path": "org.terasology.world.block.regions.BlockRegionSystem.onDestroyed",
	"Comment": "trivial priority so that all other logic can happen to the region before erasing the blocks in the region",
	"Method": "void onDestroyed(DoDestroyEvent event,EntityRef entity,BlockRegionComponent blockRegion){\r\n    for (Vector3i blockPosition : blockRegion.region) {\r\n        worldProvider.setBlock(blockPosition, blockManager.getBlock(BlockManager.AIR_ID));\r\n    }\r\n}"
}, {
	"Path": "org.terasology.network.internal.ClientHandshakeHandler.processHandshakeVerification",
	"Comment": "process the handshake verification, checking that both the server and client have attempted it. if successful marks the channel as authenticated.",
	"Method": "void processHandshakeVerification(NetData.HandshakeVerification handshakeVerification,ChannelHandlerContext ctx){\r\n    logger.info(\"Received server verification\");\r\n    if (serverHello == null || clientHello == null) {\r\n        logger.error(\"Received server verification without requesting it: cancelling authentication\");\r\n        joinStatus.setErrorMessage(AUTHENTICATION_FAILURE);\r\n        ctx.getChannel().close();\r\n        return;\r\n    }\r\n    if (!serverCertificate.verify(HandshakeCommon.getSignatureData(serverHello, clientHello), handshakeVerification.getSignature().toByteArray())) {\r\n        logger.error(\"Server failed verification: cancelling authentication\");\r\n        joinStatus.setErrorMessage(AUTHENTICATION_FAILURE);\r\n        ctx.getChannel().close();\r\n        return;\r\n    }\r\n    ctx.getPipeline().remove(this);\r\n    channelAuthenticated(ctx);\r\n}"
}, {
	"Path": "org.terasology.entitySystem.entity.EntityBuilder.build",
	"Comment": "produces an entity with the components contained in this entity builder",
	"Method": "EntityRef build(){\r\n    if (id.isPresent() && !entityManager.registerId(id.get())) {\r\n        return EntityRef.NULL;\r\n    }\r\n    long finalId = id.orElse(entityManager.createEntity());\r\n    components.values().forEach(c -> entityManager.getComponentStore().put(finalId, c));\r\n    entityManager.assignToPool(finalId, pool);\r\n    EntityRef entity = entityManager.getEntity(finalId);\r\n    if (sendLifecycleEvents && entityManager.getEventSystem() != null) {\r\n        entity.send(OnAddedComponent.newInstance());\r\n        entity.send(OnActivatedComponent.newInstance());\r\n    }\r\n    for (Component component : entityManager.iterateComponents(entity.getId())) {\r\n        entityManager.notifyComponentAdded(entity, component.getClass());\r\n    }\r\n    entity.setScope(scope.orElse(getEntityInfo().scope));\r\n    return entity;\r\n}"
}, {
	"Path": "org.springframework.security.openid.OpenIDAuthenticationProvider.createSuccessfulAuthentication",
	"Comment": "handles the creation of the final authentication object which will be\treturned by the provider.\tthe default implementation just creates a new openidauthenticationtoken from the\toriginal, but with the userdetails as the principal and including the authorities\tloaded by the userdetailsservice.",
	"Method": "Authentication createSuccessfulAuthentication(UserDetails userDetails,OpenIDAuthenticationToken auth){\r\n    return new OpenIDAuthenticationToken(userDetails, this.authoritiesMapper.mapAuthorities(userDetails.getAuthorities()), auth.getIdentityUrl(), auth.getAttributes());\r\n}"
}, {
	"Path": "org.springframework.security.web.context.AbstractSecurityWebApplicationInitializer.isAsyncSecuritySupported",
	"Comment": "determine if the springsecurityfilterchain should be marked as supporting asynch.\tdefault is true.",
	"Method": "boolean isAsyncSecuritySupported(){\r\n    return true;\r\n}"
}, {
	"Path": "org.springframework.security.web.csrf.CookieCsrfTokenRepository.setCookieName",
	"Comment": "sets the name of the cookie that the expected csrf token is saved to and read from.",
	"Method": "void setCookieName(String cookieName){\r\n    Assert.notNull(cookieName, \"cookieName is not null\");\r\n    this.cookieName = cookieName;\r\n}"
}, {
	"Path": "org.terasology.audio.formats.OggReader.initVorbis",
	"Comment": "initalizes the vorbis stream. reads the stream until info and comment are read.",
	"Method": "void initVorbis(){\r\n    syncState.init();\r\n    int bufferIndex = syncState.buffer(4096);\r\n    byte[] buffer = syncState.data;\r\n    int bytes = in.read(buffer, bufferIndex, 4096);\r\n    syncState.wrote(bytes);\r\n    if (syncState.pageout(page) != 1) {\r\n        if (bytes < 4096) {\r\n            return;\r\n        }\r\n        throw new Exception(\"Input does not appear to be an Ogg bitstream.\");\r\n    }\r\n    streamState.init(page.serialno());\r\n    info.init();\r\n    comment.init();\r\n    if (streamState.pagein(page) < 0) {\r\n        throw new Exception(\"Error reading first page of Ogg bitstream data.\");\r\n    }\r\n    if (streamState.packetout(packet) != 1) {\r\n        throw new Exception(\"Error reading initial header packet.\");\r\n    }\r\n    if (info.synthesis_headerin(comment, packet) < 0) {\r\n        throw new Exception(\"This Ogg bitstream does not contain Vorbis audio data.\");\r\n    }\r\n    int i = 0;\r\n    while (i < 2) {\r\n        while (i < 2) {\r\n            int result = syncState.pageout(page);\r\n            if (result == 0) {\r\n                break;\r\n            }\r\n            if (result == 1) {\r\n                streamState.pagein(page);\r\n                while (i < 2) {\r\n                    result = streamState.packetout(packet);\r\n                    if (result == 0) {\r\n                        break;\r\n                    }\r\n                    if (result == -1) {\r\n                        throw new Exception(\"Corrupt secondary header. Exiting.\");\r\n                    }\r\n                    info.synthesis_headerin(comment, packet);\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        bufferIndex = syncState.buffer(4096);\r\n        buffer = syncState.data;\r\n        bytes = in.read(buffer, bufferIndex, 4096);\r\n        if (bytes < 0) {\r\n            bytes = 0;\r\n        }\r\n        if (bytes == 0 && i < 2) {\r\n            throw new Exception(\"End of file before finding all Vorbis headers!\");\r\n        }\r\n        syncState.wrote(bytes);\r\n    }\r\n    convsize = 4096 / info.channels;\r\n    dspState.synthesis_init(info);\r\n    block.init(dspState);\r\n}"
}, {
	"Path": "org.terasology.input.InputSystem.isCapturingMouse",
	"Comment": "returns true if the game window currently has display focus, therefore mouse input is being captured.",
	"Method": "boolean isCapturingMouse(){\r\n    return display.hasFocus();\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.switchuser.SwitchUserFilter.setFailureHandler",
	"Comment": "used to define custom behaviour when a switch fails.\tcan be used instead of setting switchfailureurl.",
	"Method": "void setFailureHandler(AuthenticationFailureHandler failureHandler){\r\n    Assert.notNull(failureHandler, \"failureHandler cannot be null\");\r\n    this.failureHandler = failureHandler;\r\n}"
}, {
	"Path": "springfox.documentation.spring.web.plugins.SpringRestDocsOperationBuilderPlugin.read",
	"Comment": "provides response messages with examples for given single operation context.",
	"Method": "Set<ResponseMessage> read(OperationContext context){\r\n    Set<ResponseMessage> ret;\r\n    try {\r\n        PathMatchingResourcePatternResolver resourceResolver = new PathMatchingResourcePatternResolver();\r\n        Resource[] resources = resourceResolver.getResources(\"classpath*:\" + context.getName() + \"*/http-response.springfox\");\r\n        ret = Arrays.stream(resources).map(toRawHttpResponse()).filter(Objects::nonNull).collect(Collectors.collectingAndThen(toMap(RawHttpResponse::getStatusCode, mappingResponseToResponseMessageBuilder(), mergingExamples()), responseMessagesMap -> responseMessagesMap.values().stream().map(ResponseMessageBuilder::build).collect(Collectors.toSet())));\r\n    } catch (Exception e) {\r\n        LOG.warn(\"Failed to read restdocs example for {} \" + context.getName() + \" caused by: \" + e.toString());\r\n        ret = Collections.emptySet();\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "org.terasology.utilities.LWJGLHelper.initNativeLibs",
	"Comment": "used on initializing the game environment, either for playing or for running unit tests",
	"Method": "void initNativeLibs(){\r\n    initLibraryPaths();\r\n}"
}, {
	"Path": "org.springframework.security.web.csrf.CookieCsrfTokenRepository.setHeaderName",
	"Comment": "sets the name of the http header that should be used to provide the token.",
	"Method": "void setHeaderName(String headerName){\r\n    Assert.notNull(headerName, \"headerName is not null\");\r\n    this.headerName = headerName;\r\n}"
}, {
	"Path": "org.springframework.security.authentication.UserDetailsRepositoryReactiveAuthenticationManager.setUserDetailsPasswordService",
	"Comment": "sets the service to use for upgrading passwords on successful authentication.",
	"Method": "void setUserDetailsPasswordService(ReactiveUserDetailsPasswordService userDetailsPasswordService){\r\n    this.userDetailsPasswordService = userDetailsPasswordService;\r\n}"
}, {
	"Path": "org.springframework.security.access.vote.RoleHierarchyVoter.extractAuthorities",
	"Comment": "calls the rolehierarchy to obtain the complete set of user authorities.",
	"Method": "Collection<? extends GrantedAuthority> extractAuthorities(Authentication authentication){\r\n    return roleHierarchy.getReachableGrantedAuthorities(authentication.getAuthorities());\r\n}"
}, {
	"Path": "org.terasology.documentation.apiScraper.ApiComparator.checkMethodChanges",
	"Comment": "checks creation and deletion of methods, as well as existing method changes.",
	"Method": "void checkMethodChanges(Map<String, Collection<ApiMethod>> originalApi,Map<String, Collection<ApiMethod>> newApi){\r\n    System.out.println(\"Checking Method Changes\");\r\n    Collection<ApiMethod> originalMethods;\r\n    Collection<ApiMethod> newMethods;\r\n    for (String className : originalApi.keySet()) {\r\n        originalMethods = originalApi.get(className);\r\n        newMethods = newApi.get(className);\r\n        if (newMethods == null) {\r\n            continue;\r\n        }\r\n        checkMethodDeletion(originalMethods, newMethods);\r\n        for (ApiMethod method2 : newMethods) {\r\n            boolean found = false;\r\n            for (ApiMethod method1 : originalMethods) {\r\n                if (method1.getName().equals(method2.getName())) {\r\n                    ApiMethod auxMethod = getMethodWithSameNameAndParameters(method2, originalMethods);\r\n                    if (auxMethod.getName().equals(\"\")) {\r\n                        ApiMethod auxMethod2 = getMethodWithSameNameAndParameters(method1, newMethods);\r\n                        if (auxMethod2.getName().equals(\"\")) {\r\n                            checkMethodIncrease(method1, method2);\r\n                        } else if (isInterfaceOrAbstract(method2.getClassName())) {\r\n                            System.out.println(\"MINOR INCREASE, NEW OVERLOADED METHOD \" + method2.getName() + \" ON \" + method2.getClassName() + \"\\nNEW PARAMETERS: \" + method2.getParametersType());\r\n                            System.out.println(\"=================================================================\");\r\n                        }\r\n                    } else {\r\n                        checkMethodIncrease(auxMethod, method2);\r\n                    }\r\n                    found = true;\r\n                }\r\n            }\r\n            if (!found) {\r\n                if (isInterfaceOrAbstract(method2.getClassName())) {\r\n                    if (method2.getName().endsWith(\"(ABSTRACT METHOD)\")) {\r\n                        System.out.println(\"MAJOR INCREASE, NEW ABSTRACT METHOD \" + method2.getName() + \" ON \" + method2.getClassName());\r\n                    } else {\r\n                        String minorOrMajor;\r\n                        if (method2.getClassName().endsWith(\"(INTERFACE)\")) {\r\n                            if (method2.getName().endsWith(\"(DEFAULT METHOD)\")) {\r\n                                minorOrMajor = \"MINOR\";\r\n                            } else {\r\n                                minorOrMajor = \"MAJOR\";\r\n                            }\r\n                        } else {\r\n                            minorOrMajor = \"MINOR\";\r\n                        }\r\n                        System.out.println(minorOrMajor + \" INCREASE, NEW METHOD \" + method2.getName() + \" ON \" + method2.getClassName());\r\n                    }\r\n                } else {\r\n                    System.out.println(\"MINOR INCREASE, NEW METHOD \" + method2.getName() + \" ON \" + method2.getClassName());\r\n                }\r\n                System.out.println(\"=================================================================\");\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.access.vote.AbstractAccessDecisionManager.supports",
	"Comment": "iterates through all accessdecisionvoters and ensures each can support\tthe presented class.\tif one or more voters cannot support the presented class, false is\treturned.",
	"Method": "boolean supports(ConfigAttribute attribute,boolean supports,Class<?> clazz){\r\n    for (AccessDecisionVoter voter : this.decisionVoters) {\r\n        if (!voter.supports(clazz)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.AbstractAuthenticationTargetUrlRequestHandler.setRedirectStrategy",
	"Comment": "allows overriding of the behaviour when redirecting to a target url.",
	"Method": "void setRedirectStrategy(RedirectStrategy redirectStrategy){\r\n    this.redirectStrategy = redirectStrategy;\r\n}"
}, {
	"Path": "springfox.documentation.builders.ApiListingBuilder.consumes",
	"Comment": "replaces the existing media types with new entries that this documentation consumes",
	"Method": "ApiListingBuilder consumes(Set<String> mediaTypes){\r\n    if (mediaTypes != null) {\r\n        this.consumes = new HashSet(mediaTypes);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.terasology.rendering.opengl.FBO.dispose",
	"Comment": "properly disposes of the underlying framebuffer and its attachments,effectively freeing memory on the graphic adapter.",
	"Method": "void dispose(){\r\n    glDeleteFramebuffersEXT(fboId);\r\n    glDeleteRenderbuffersEXT(depthStencilRboId);\r\n    GL11.glDeleteTextures(normalsBufferTextureId);\r\n    GL11.glDeleteTextures(depthStencilTextureId);\r\n    GL11.glDeleteTextures(colorBufferTextureId);\r\n    status = Status.DISPOSED;\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.CoreScreenLayer.setDepthAuto",
	"Comment": "automatically sets the depth of this screen using sortordersystem.",
	"Method": "void setDepthAuto(){\r\n    if (SortOrderSystem.isInitialized()) {\r\n        depth = SortOrderSystem.getCurrent();\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.crypto.password.PasswordEncoderUtils.equals",
	"Comment": "constant time comparison to prevent against timing attacks.",
	"Method": "boolean equals(String expected,String actual){\r\n    byte[] expectedBytes = bytesUtf8(expected);\r\n    byte[] actualBytes = bytesUtf8(actual);\r\n    int expectedLength = expectedBytes == null ? -1 : expectedBytes.length;\r\n    int actualLength = actualBytes == null ? -1 : actualBytes.length;\r\n    int result = expectedLength == actualLength ? 0 : 1;\r\n    for (int i = 0; i < actualLength; i++) {\r\n        byte expectedByte = expectedLength <= 0 ? 0 : expectedBytes[i % expectedLength];\r\n        byte actualByte = actualBytes[i % actualLength];\r\n        result |= expectedByte ^ actualByte;\r\n    }\r\n    return result == 0;\r\n}"
}, {
	"Path": "org.springframework.security.web.server.authorization.ExceptionTranslationWebFilter.setAuthenticationEntryPoint",
	"Comment": "sets the authentication entry point used when authentication is required",
	"Method": "void setAuthenticationEntryPoint(ServerAuthenticationEntryPoint authenticationEntryPoint){\r\n    Assert.notNull(authenticationEntryPoint, \"authenticationEntryPoint cannot be null\");\r\n    this.authenticationEntryPoint = authenticationEntryPoint;\r\n}"
}, {
	"Path": "org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl.loadUserAuthorities",
	"Comment": "loads authorities by executing the sql from authoritiesbyusernamequery.",
	"Method": "List<GrantedAuthority> loadUserAuthorities(String username){\r\n    return getJdbcTemplate().query(this.authoritiesByUsernameQuery, new String[] { username }, new RowMapper<GrantedAuthority>() {\r\n        @Override\r\n        public GrantedAuthority mapRow(ResultSet rs, int rowNum) throws SQLException {\r\n            String roleName = JdbcDaoImpl.this.rolePrefix + rs.getString(2);\r\n            return new SimpleGrantedAuthority(roleName);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl.loadUserAuthorities",
	"Comment": "loads authorities by executing the sql from authoritiesbyusernamequery.",
	"Method": "List<GrantedAuthority> loadUserAuthorities(String username){\r\n    String roleName = JdbcDaoImpl.this.rolePrefix + rs.getString(2);\r\n    return new SimpleGrantedAuthority(roleName);\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.layers.mainMenu.NewGameScreen.setGameName",
	"Comment": "sets the game names based on the game number of the last saved game",
	"Method": "void setGameName(UIText gameName){\r\n    if (gameName != null) {\r\n        gameName.setText(GameProvider.getNextGameName());\r\n    }\r\n}"
}, {
	"Path": "springfox.documentation.spi.schema.contexts.ModelContext.returnValue",
	"Comment": "convenience method to provide an new context for an return parameter",
	"Method": "ModelContext returnValue(String groupName,Type type,DocumentationType documentationType,AlternateTypeProvider alternateTypeProvider,GenericTypeNamingStrategy genericNamingStrategy,Set<Class> ignorableTypes){\r\n    return new ModelContext(groupName, type, true, documentationType, alternateTypeProvider, genericNamingStrategy, ignorableTypes);\r\n}"
}, {
	"Path": "org.springframework.security.crypto.bcrypt.BCrypt.crypt_raw",
	"Comment": "perform the central password hashing step in the\tbcrypt scheme",
	"Method": "byte[] crypt_raw(byte password,byte salt,int log_rounds,boolean sign_ext_bug,int safety){\r\n    int rounds, i, j;\r\n    int[] cdata = bf_crypt_ciphertext.clone();\r\n    int clen = cdata.length;\r\n    byte[] ret;\r\n    if (log_rounds < 4 || log_rounds > 31)\r\n        throw new IllegalArgumentException(\"Bad number of rounds\");\r\n    rounds = 1 << log_rounds;\r\n    if (salt.length != BCRYPT_SALT_LEN)\r\n        throw new IllegalArgumentException(\"Bad salt length\");\r\n    init_key();\r\n    ekskey(salt, password, sign_ext_bug, safety);\r\n    for (i = 0; i < rounds; i++) {\r\n        key(password, sign_ext_bug, safety);\r\n        key(salt, false, safety);\r\n    }\r\n    for (i = 0; i < 64; i++) {\r\n        for (j = 0; j < (clen >> 1); j++) encipher(cdata, j << 1);\r\n    }\r\n    ret = new byte[clen * 4];\r\n    for (i = 0, j = 0; i < clen; i++) {\r\n        ret[j++] = (byte) ((cdata[i] >> 24) & 0xff);\r\n        ret[j++] = (byte) ((cdata[i] >> 16) & 0xff);\r\n        ret[j++] = (byte) ((cdata[i] >> 8) & 0xff);\r\n        ret[j++] = (byte) (cdata[i] & 0xff);\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "springfox.documentation.spring.web.plugins.Docket.additionalModels",
	"Comment": "method to add additional models that are not part of any annotation or are perhaps implicit",
	"Method": "Docket additionalModels(ResolvedType first,ResolvedType remaining){\r\n    additionalModels.add(first);\r\n    additionalModels.addAll(Arrays.stream(remaining).collect(toSet()));\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter.setResolveHiddenInputs",
	"Comment": "sets a function used to resolve a map of the hidden inputs where the key is the\tname of the input and the value is the value of the input. typically this is used\tto resolve the csrf token.",
	"Method": "void setResolveHiddenInputs(Function<HttpServletRequest, Map<String, String>> resolveHiddenInputs){\r\n    Assert.notNull(resolveHiddenInputs, \"resolveHiddenInputs cannot be null\");\r\n    this.resolveHiddenInputs = resolveHiddenInputs;\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.widgets.UIList.unsubscribe",
	"Comment": "remove an event listener from being called when the list being activated.",
	"Method": "void unsubscribe(ItemActivateEventListener<T> eventListener){\r\n    activateListeners.remove(eventListener);\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.AbstractAuthenticationTargetUrlRequestHandler.determineTargetUrl",
	"Comment": "builds the target url according to the logic defined in the main class javadoc.",
	"Method": "String determineTargetUrl(HttpServletRequest request,HttpServletResponse response){\r\n    if (isAlwaysUseDefaultTargetUrl()) {\r\n        return defaultTargetUrl;\r\n    }\r\n    String targetUrl = null;\r\n    if (targetUrlParameter != null) {\r\n        targetUrl = request.getParameter(targetUrlParameter);\r\n        if (StringUtils.hasText(targetUrl)) {\r\n            logger.debug(\"Found targetUrlParameter in request: \" + targetUrl);\r\n            return targetUrl;\r\n        }\r\n    }\r\n    if (useReferer && !StringUtils.hasLength(targetUrl)) {\r\n        targetUrl = request.getHeader(\"Referer\");\r\n        logger.debug(\"Using Referer header: \" + targetUrl);\r\n    }\r\n    if (!StringUtils.hasText(targetUrl)) {\r\n        targetUrl = defaultTargetUrl;\r\n        logger.debug(\"Using default Url: \" + targetUrl);\r\n    }\r\n    return targetUrl;\r\n}"
}, {
	"Path": "org.springframework.security.crypto.password.StandardPasswordEncoder.matches",
	"Comment": "constant time comparison to prevent against timing attacks.",
	"Method": "boolean matches(CharSequence rawPassword,String encodedPassword,boolean matches,byte[] expected,byte[] actual){\r\n    if (expected.length != actual.length) {\r\n        return false;\r\n    }\r\n    int result = 0;\r\n    for (int i = 0; i < expected.length; i++) {\r\n        result |= expected[i] ^ actual[i];\r\n    }\r\n    return result == 0;\r\n}"
}, {
	"Path": "springfox.documentation.builders.OperationBuilder.consumes",
	"Comment": "updates the existing media types with new entries that this documentation consumes",
	"Method": "OperationBuilder consumes(Set<String> mediaTypes){\r\n    this.consumes.addAll(nullToEmptySet(mediaTypes));\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.security.config.doc.XsdDocumentedTests.countWhenReviewingDocumentationThenAllElementsDocumented",
	"Comment": "this test checks each xsd element and ensures there is documentation for it.",
	"Method": "void countWhenReviewingDocumentationThenAllElementsDocumented(){\r\n    Map<String, Element> elementNameToElement = this.xml.elementsByElementName(this.schemaDocumentLocation);\r\n    String notDocElmtIds = elementNameToElement.values().stream().filter(element -> StringUtils.isEmpty(element.getDesc()) && !this.ignoredIds.contains(element.getId())).map(element -> element.getId()).sorted().collect(Collectors.joining(\"\\n\"));\r\n    String notDocAttrIds = elementNameToElement.values().stream().flatMap(element -> element.getAttrs().stream()).filter(element -> StringUtils.isEmpty(element.getDesc()) && !this.ignoredIds.contains(element.getId())).map(element -> element.getId()).sorted().collect(Collectors.joining(\"\\n\"));\r\n    assertThat(notDocElmtIds).isEmpty();\r\n    assertThat(notDocAttrIds).isEmpty();\r\n}"
}, {
	"Path": "org.springframework.security.core.SpringSecurityCoreVersion.disableChecks",
	"Comment": "disable if springversion and springsecurityversion are the same to allow working\twith uber jars.",
	"Method": "boolean disableChecks(String springVersion,String springSecurityVersion){\r\n    if (springVersion == null || springVersion.equals(springSecurityVersion)) {\r\n        return true;\r\n    }\r\n    return Boolean.getBoolean(DISABLE_CHECKS);\r\n}"
}, {
	"Path": "org.terasology.engine.GameThread.asynch",
	"Comment": "runs a process on the game thread, not waiting for it to run.if the current thread is the game thread, then the process runs immediately",
	"Method": "void asynch(Runnable process){\r\n    if (Thread.currentThread() != gameThread) {\r\n        pendingRunnables.push(process);\r\n    } else {\r\n        process.run();\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.core.context.SecurityContextHolder.setContext",
	"Comment": "associates a new securitycontext with the current thread of execution.",
	"Method": "void setContext(SecurityContext context){\r\n    strategy.setContext(context);\r\n}"
}, {
	"Path": "org.terasology.rendering.opengl.FBO.getColorBufferRawData",
	"Comment": "returns the content of the color buffer from gpu memory as a bytebuffer.",
	"Method": "ByteBuffer getColorBufferRawData(){\r\n    ByteBuffer buffer = BufferUtils.createByteBuffer(this.width() * this.height() * 4);\r\n    this.bindTexture();\r\n    GL11.glGetTexImage(GL11.GL_TEXTURE_2D, 0, GL11.GL_RGBA, GL11.GL_UNSIGNED_BYTE, buffer);\r\n    FBO.unbindTexture();\r\n    return buffer;\r\n}"
}, {
	"Path": "org.springframework.security.ldap.search.FilterBasedLdapUserSearch.setReturningAttributes",
	"Comment": "specifies the attributes that will be returned as part of the search.\tnull indicates that all attributes will be returned. an empty array indicates no\tattributes are returned.",
	"Method": "void setReturningAttributes(String[] attrs){\r\n    searchControls.setReturningAttributes(attrs);\r\n}"
}, {
	"Path": "org.springframework.security.web.server.authentication.RedirectServerAuthenticationEntryPoint.setRequestCache",
	"Comment": "the request cache to use to save the request before sending a redirect.",
	"Method": "void setRequestCache(ServerRequestCache requestCache){\r\n    Assert.notNull(requestCache, \"requestCache cannot be null\");\r\n    this.requestCache = requestCache;\r\n}"
}, {
	"Path": "org.terasology.logic.characters.KinematicCharacterMover.checkBlockEntry",
	"Comment": "figure out if our position has put us into a new set of blocks and fire the appropriate events.",
	"Method": "void checkBlockEntry(EntityRef entity,Vector3i oldPosition,Vector3i newPosition,float characterHeight){\r\n    if (!oldPosition.equals(newPosition)) {\r\n        Biome oldBiome = worldProvider.getBiome(oldPosition);\r\n        Biome newBiome = worldProvider.getBiome(newPosition);\r\n        if (oldBiome != newBiome) {\r\n            entity.send(new OnEnterBiomeEvent(oldPosition, newPosition, oldBiome, newBiome));\r\n        }\r\n        Block[] oldBlocks = new Block[(int) Math.ceil(characterHeight)];\r\n        Vector3i currentPosition = new Vector3i(oldPosition);\r\n        for (int currentHeight = 0; currentHeight < oldBlocks.length; currentHeight++) {\r\n            oldBlocks[currentHeight] = worldProvider.getBlock(currentPosition);\r\n            currentPosition.add(0, 1, 0);\r\n        }\r\n        Block[] newBlocks = new Block[(int) Math.ceil(characterHeight)];\r\n        currentPosition = new Vector3i(newPosition);\r\n        for (int currentHeight = 0; currentHeight < characterHeight; currentHeight++) {\r\n            newBlocks[currentHeight] = worldProvider.getBlock(currentPosition);\r\n            currentPosition.add(0, 1, 0);\r\n        }\r\n        for (int i = 0; i < characterHeight; i++) {\r\n            entity.send(new OnEnterBlockEvent(oldBlocks[i], newBlocks[i], new Vector3i(0, i, 0)));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.crypto.password.Pbkdf2PasswordEncoder.matches",
	"Comment": "constant time comparison to prevent against timing attacks.",
	"Method": "boolean matches(CharSequence rawPassword,String encodedPassword,boolean matches,byte[] expected,byte[] actual){\r\n    if (expected.length != actual.length) {\r\n        return false;\r\n    }\r\n    int result = 0;\r\n    for (int i = 0; i < expected.length; i++) {\r\n        result |= expected[i] ^ actual[i];\r\n    }\r\n    return result == 0;\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.SimpleUrlAuthenticationFailureHandler.setRedirectStrategy",
	"Comment": "allows overriding of the behaviour when redirecting to a target url.",
	"Method": "void setRedirectStrategy(RedirectStrategy redirectStrategy){\r\n    this.redirectStrategy = redirectStrategy;\r\n}"
}, {
	"Path": "org.terasology.world.block.family.BlockFamilyLibrary.getBlockFamily",
	"Comment": "returns the class representing the block family based off the registered id.",
	"Method": "Class<? extends BlockFamily> getBlockFamily(String uri){\r\n    ClassMetadata<? extends BlockFamily, ?> resolved = library.resolve(uri);\r\n    if (uri == null || uri.isEmpty() || resolved == null) {\r\n        logger.error(\" Failed to resolve Blockfamily {}\", uri);\r\n        return SymmetricFamily.class;\r\n    }\r\n    return resolved.getType();\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.widgets.UIText.update",
	"Comment": "defines what to do at every engine update. specifically, this updates the text and makes the cursor blink.",
	"Method": "void update(float delta){\r\n    super.update(delta);\r\n    blinkCounter += delta;\r\n    while (blinkCounter > 2 * BLINK_RATE) {\r\n        blinkCounter -= 2 * BLINK_RATE;\r\n    }\r\n}"
}, {
	"Path": "org.terasology.rendering.opengl.OpenGLUtils.applyBillboardOrientation",
	"Comment": "removes the rotation and scale part of the current opengl matrix.can be used to render billboards like particles.",
	"Method": "void applyBillboardOrientation(){\r\n    final FloatBuffer model = BufferUtils.createFloatBuffer(16);\r\n    GL11.glGetFloat(GL11.GL_MODELVIEW_MATRIX, model);\r\n    for (int i = 0; i < 3; i++) {\r\n        for (int j = 0; j < 3; j++) {\r\n            if (i == j) {\r\n                model.put(i * 4 + j, 1.0f);\r\n            } else {\r\n                model.put(i * 4 + j, 0.0f);\r\n            }\r\n        }\r\n    }\r\n    GL11.glLoadMatrix(model);\r\n}"
}, {
	"Path": "org.terasology.world.chunks.internal.ChunkImpl.setBlock",
	"Comment": "so whatever sets a block to something extradata sensitive should also initialise the extra data.",
	"Method": "Block setBlock(int x,int y,int z,Block block,Block setBlock,BaseVector3i pos,Block block){\r\n    return setBlock(pos.x(), pos.y(), pos.z(), block);\r\n}"
}, {
	"Path": "org.terasology.world.generation.Border3D.expandTo3D",
	"Comment": "returns a 3d representation of the workd, a region in this case. with the borders added to it.",
	"Method": "Region3i expandTo3D(Region3i region,Region3i expandTo3D,Vector3i size){\r\n    return Region3i.createFromMinMax(new Vector3i(-sides, -bottom, -sides), new Vector3i(size.x + sides - 1, size.y + top - 1, size.z + sides - 1));\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.widgets.UIText.correctCursor",
	"Comment": "make sure that the cursor position lies within 0 and the length of the text in the widget.",
	"Method": "void correctCursor(){\r\n    cursorPosition = TeraMath.clamp(cursorPosition, 0, getText().length());\r\n    selectionStart = TeraMath.clamp(selectionStart, 0, getText().length());\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.widgets.UIText.increaseCursorPosition",
	"Comment": "increase the cursor position. this method moves the start of the selected text along with the cursor.",
	"Method": "int increaseCursorPosition(int delta,boolean moveSelectionStart,int increaseCursorPosition,int delta){\r\n    return increaseCursorPosition(delta, true);\r\n}"
}, {
	"Path": "org.terasology.rendering.openvrprovider.OpenVRProvider.init",
	"Comment": "initialize the vr system. note that calling this method will cause openvr to launch. if there is no headsetconnected, or if the openvr library fails to initialize for some reason, this will return false, and a logentry about why initialization failed will be written.",
	"Method": "boolean init(){\r\n    for (int handIndex = 0; handIndex < 2; handIndex++) {\r\n        controllerDeviceIndex[handIndex] = -1;\r\n        controllerStateReference[handIndex] = new VRControllerState_t();\r\n        inputStateRefernceArray[handIndex] = new VRControllerState_t.ByReference();\r\n        inputStateRefernceArray[handIndex].setAutoRead(false);\r\n        inputStateRefernceArray[handIndex].setAutoWrite(false);\r\n        inputStateRefernceArray[handIndex].setAutoSynch(false);\r\n        texType[handIndex] = new Texture_t();\r\n    }\r\n    if (!initializeOpenVRLibrary()) {\r\n        logger.warn(\"JOpenVR library loading failed.\");\r\n        return false;\r\n    }\r\n    if (!initializeJOpenVR()) {\r\n        logger.warn(\"JOpenVR initialization failed.\");\r\n        return false;\r\n    }\r\n    int initAttempts = 0;\r\n    boolean initSuccess = false;\r\n    while (!initSuccess && initAttempts < 10) {\r\n        try {\r\n            Thread.sleep(300);\r\n        } catch (InterruptedException ex) {\r\n            Thread.currentThread().interrupt();\r\n        }\r\n        initSuccess = initOpenVRCompositor(true);\r\n        initAttempts++;\r\n    }\r\n    if (!initOpenVROverlay()) {\r\n        logger.warn(\"VROverlay initialization failed.\");\r\n        return false;\r\n    }\r\n    if (!initOpenVROSettings()) {\r\n        logger.warn(\"OpenVR settings initialization failed.\");\r\n        return false;\r\n    }\r\n    initialized = true;\r\n    return true;\r\n}"
}, {
	"Path": "org.terasology.logic.actions.PlaySoundAction.onActivationPredicted",
	"Comment": "this method plays sound in prediction for preventing not playing song because of server lags",
	"Method": "void onActivationPredicted(ActivationPredicted event,EntityRef entity){\r\n    PlaySoundActionComponent playSound = entity.getComponent(PlaySoundActionComponent.class);\r\n    StaticSound sound = random.nextItem(playSound.sounds);\r\n    if (sound != null) {\r\n        Vector3f pos = null;\r\n        switch(playSound.relativeTo) {\r\n            case Target:\r\n                pos = event.getTargetLocation();\r\n                break;\r\n            default:\r\n                pos = event.getInstigatorLocation();\r\n                break;\r\n        }\r\n        if (pos == null) {\r\n            pos = event.getOrigin();\r\n        }\r\n        audioManager.playSound(sound, pos, playSound.volume, AudioManager.PRIORITY_NORMAL);\r\n    }\r\n}"
}, {
	"Path": "org.terasology.math.Transform.getBasis",
	"Comment": "returns the rotation and scaling information contained in the transform as a 3x3 basis matrix.",
	"Method": "Matrix3f getBasis(){\r\n    Matrix3f basis = new Matrix3f();\r\n    basis.set(rotation);\r\n    basis.mul(scale);\r\n    return basis;\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.layouts.relative.HorizontalHint.alignRight",
	"Comment": "aligns the right edge of the widget to the given part of the draw area, with a pixel offset",
	"Method": "HorizontalHint alignRight(HorizontalHint alignRight,int offset,HorizontalHint alignRight,HorizontalAlign targetPart,HorizontalHint alignRight,HorizontalAlign targetPart,int offset){\r\n    return alignRightRelativeTo(\"\", targetPart, offset);\r\n}"
}, {
	"Path": "org.springframework.security.util.MethodInvocationUtils.createFromClass",
	"Comment": "generates a methodinvocation for specified methodname on\tthe passed class, using the args to locate the method.",
	"Method": "MethodInvocation createFromClass(Class<?> clazz,String methodName,MethodInvocation createFromClass,Object targetObject,Class<?> clazz,String methodName,Class<?>[] classArgs,Object[] args){\r\n    Assert.notNull(clazz, \"Class required\");\r\n    Assert.hasText(methodName, \"MethodName required\");\r\n    Method method;\r\n    try {\r\n        method = clazz.getMethod(methodName, classArgs);\r\n    } catch (NoSuchMethodException e) {\r\n        return null;\r\n    }\r\n    return new SimpleMethodInvocation(targetObject, method, args);\r\n}"
}, {
	"Path": "org.springframework.security.web.session.SessionManagementFilter.setInvalidSessionStrategy",
	"Comment": "sets the strategy which will be invoked instead of allowing the filter chain to\tprceed, if the user agent requests an invalid session id. if the property is not\tset, no action will be taken.",
	"Method": "void setInvalidSessionStrategy(InvalidSessionStrategy invalidSessionStrategy){\r\n    this.invalidSessionStrategy = invalidSessionStrategy;\r\n}"
}, {
	"Path": "org.terasology.rendering.animation.TimeModifiers.smooth",
	"Comment": "smooth start, fast in the middle, smooth end. almost identical to sin^2, but faster",
	"Method": "TimeModifier smooth(){\r\n    return v -> TeraMath.fadeHermite(v);\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.skin.UIStyle.getBackgroundBorder",
	"Comment": "the background border is the part of the background texture around the edges that should not scale with the size of the area being drawn.this allows for things like windows to have a take a background and resize it for any area without losing the desired border feel.",
	"Method": "Border getBackgroundBorder(){\r\n    return backgroundBorder;\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.layouts.relative.HorizontalHint.alignRightRelativeTo",
	"Comment": "aligns the right edge of the widget against the specified part of another widget, with a pixel offset",
	"Method": "HorizontalHint alignRightRelativeTo(String widgetId,HorizontalAlign targetPart,HorizontalHint alignRightRelativeTo,String widgetId,HorizontalAlign targetPart,int offset){\r\n    positionRight = new HorizontalInfo();\r\n    positionRight.setTarget(targetPart);\r\n    positionRight.setWidget(widgetId);\r\n    positionRight.setOffset(offset);\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.security.TargetObject.makeUpperCase",
	"Comment": "returns the uppercase string, followed by security environment information.",
	"Method": "String makeUpperCase(String input){\r\n    Authentication auth = SecurityContextHolder.getContext().getAuthentication();\r\n    return input.toUpperCase() + \" \" + auth.getClass().getName() + \" \" + auth.isAuthenticated();\r\n}"
}, {
	"Path": "org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.httpBasic",
	"Comment": "convenience mechanism for setting the authorization header to use http basic with\tthe given username and password. this method will automatically perform the\tnecessary base64 encoding.",
	"Method": "RequestPostProcessor httpBasic(String username,String password){\r\n    return new HttpBasicRequestPostProcessor(username, password);\r\n}"
}, {
	"Path": "org.springframework.security.config.web.server.ServerHttpSecurity.securityMatcher",
	"Comment": "the serverexchangematcher that determines which requests apply to this httpsecurity instance.",
	"Method": "ServerHttpSecurity securityMatcher(ServerWebExchangeMatcher matcher){\r\n    Assert.notNull(matcher, \"matcher cannot be null\");\r\n    this.securityMatcher = matcher;\r\n    return this;\r\n}"
}, {
	"Path": "springfox.documentation.builders.DocumentationBuilder.consumes",
	"Comment": "updates the existing media types with new entries that this documentation consumes",
	"Method": "DocumentationBuilder consumes(Set<String> mediaTypes){\r\n    this.consumes.addAll(nullToEmptySet(mediaTypes));\r\n    return this;\r\n}"
}, {
	"Path": "org.terasology.logic.console.commands.CoreCommands.exit",
	"Comment": "triggers a graceful shutdown of the game after the current frame, attempting to dispose all game resources",
	"Method": "void exit(){\r\n    gameEngine.shutdown();\r\n}"
}, {
	"Path": "org.springframework.security.ldap.userdetails.DefaultLdapAuthoritiesPopulator.getLdapTemplate",
	"Comment": "returns the current ldap template. method available so that classes extending this\tcan override the template used",
	"Method": "SpringSecurityLdapTemplate getLdapTemplate(){\r\n    return this.ldapTemplate;\r\n}"
}, {
	"Path": "org.terasology.world.chunks.blockdata.ExtraBlockDataManager.getFieldsFromAnnotations",
	"Comment": "find requests for extensions and which blocks they apply to.",
	"Method": "Map<Integer, Map<String, Set<Block>>> getFieldsFromAnnotations(Context context){\r\n    ModuleEnvironment environment = context.get(ModuleManager.class).getEnvironment();\r\n    Collection<Block> blocks = context.get(BlockManager.class).listRegisteredBlocks();\r\n    Map<Integer, Map<String, Set<Block>>> fieldss = new HashMap();\r\n    TERA_ARRAY_FACTORIES.forEach((size, fac) -> fieldss.put(size, new HashMap()));\r\n    for (Class<?> type : environment.getTypesAnnotatedWith(ExtraDataSystem.class)) {\r\n        for (Method method : type.getMethods()) {\r\n            RegisterExtraData registerAnnotation = method.getAnnotation(RegisterExtraData.class);\r\n            if (registerAnnotation != null) {\r\n                String errorType = validRegistrationMethod(method, registerAnnotation);\r\n                if (errorType != null) {\r\n                    logger.error(\"Unable to register extra block data: \" + errorType + \" for {}.{}: should be \\\"public static boolean {}(Block block)\\\", and bitSize should be 4, 8 or 16.\", type.getName(), method.getName(), method.getName());\r\n                    continue;\r\n                }\r\n                method.setAccessible(true);\r\n                Set<Block> includedBlocks = new HashSet();\r\n                for (Block block : blocks) {\r\n                    try {\r\n                        if ((boolean) method.invoke(null, block)) {\r\n                            includedBlocks.add(block);\r\n                        }\r\n                    } catch (IllegalAccessException e) {\r\n                        throw new RuntimeException(\"Incorrect access modifier on register extra data method\", e);\r\n                    } catch (InvocationTargetException e) {\r\n                        throw new RuntimeException(e);\r\n                    }\r\n                }\r\n                fieldss.get(registerAnnotation.bitSize()).put(registerAnnotation.name(), includedBlocks);\r\n            }\r\n        }\r\n    }\r\n    return fieldss;\r\n}"
}, {
	"Path": "org.terasology.math.AABB.centerPointForNormal",
	"Comment": "returns the center point of one of the six planes for the given normal.",
	"Method": "Vector3f centerPointForNormal(Vector3f normal){\r\n    if (normal.x == 1 && normal.y == 0 && normal.z == 0) {\r\n        return new Vector3f(max.x, getCenter().y, getCenter().z);\r\n    }\r\n    if (normal.x == -1 && normal.y == 0 && normal.z == 0) {\r\n        return new Vector3f(min.x, getCenter().y, getCenter().z);\r\n    }\r\n    if (normal.x == 0 && normal.y == 0 && normal.z == 1) {\r\n        return new Vector3f(getCenter().x, getCenter().y, max.z);\r\n    }\r\n    if (normal.x == 0 && normal.y == 0 && normal.z == -1) {\r\n        return new Vector3f(getCenter().x, getCenter().y, min.z);\r\n    }\r\n    if (normal.x == 0 && normal.y == 1 && normal.z == 0) {\r\n        return new Vector3f(getCenter().x, max.y, getCenter().z);\r\n    }\r\n    if (normal.x == 0 && normal.y == -1 && normal.z == 0) {\r\n        return new Vector3f(getCenter().x, min.y, getCenter().z);\r\n    }\r\n    return new Vector3f();\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.preauth.PreAuthenticatedAuthenticationProvider.authenticate",
	"Comment": "authenticate the given preauthenticatedauthenticationtoken.\tif the principal contained in the authentication object is null, the request will\tbe ignored to allow other providers to authenticate it.",
	"Method": "Authentication authenticate(Authentication authentication){\r\n    if (!supports(authentication.getClass())) {\r\n        return null;\r\n    }\r\n    if (logger.isDebugEnabled()) {\r\n        logger.debug(\"PreAuthenticated authentication request: \" + authentication);\r\n    }\r\n    if (authentication.getPrincipal() == null) {\r\n        logger.debug(\"No pre-authenticated principal found in request.\");\r\n        if (throwExceptionWhenTokenRejected) {\r\n            throw new BadCredentialsException(\"No pre-authenticated principal found in request.\");\r\n        }\r\n        return null;\r\n    }\r\n    if (authentication.getCredentials() == null) {\r\n        logger.debug(\"No pre-authenticated credentials found in request.\");\r\n        if (throwExceptionWhenTokenRejected) {\r\n            throw new BadCredentialsException(\"No pre-authenticated credentials found in request.\");\r\n        }\r\n        return null;\r\n    }\r\n    UserDetails ud = preAuthenticatedUserDetailsService.loadUserDetails((PreAuthenticatedAuthenticationToken) authentication);\r\n    userDetailsChecker.check(ud);\r\n    PreAuthenticatedAuthenticationToken result = new PreAuthenticatedAuthenticationToken(ud, authentication.getCredentials(), ud.getAuthorities());\r\n    result.setDetails(authentication.getDetails());\r\n    return result;\r\n}"
}, {
	"Path": "org.springframework.security.authentication.jaas.SecurityContextLoginModule.abort",
	"Comment": "abort the authentication process by forgetting the spring security\tauthentication.",
	"Method": "boolean abort(){\r\n    if (authen == null) {\r\n        return false;\r\n    }\r\n    authen = null;\r\n    return true;\r\n}"
}, {
	"Path": "org.springframework.security.authentication.event.InteractiveAuthenticationSuccessEvent.getGeneratedBy",
	"Comment": "getter for the class that generated this event. this can be useful for\tgenerating additional logging information.",
	"Method": "Class<?> getGeneratedBy(){\r\n    return generatedBy;\r\n}"
}, {
	"Path": "org.springframework.security.ldap.ppolicy.PasswordPolicyResponseControl.toString",
	"Comment": "create a textual representation containing error and warning messages, if any are\tpresent.",
	"Method": "String toString(){\r\n    StringBuilder sb = new StringBuilder(\"PasswordPolicyResponseControl\");\r\n    if (hasError()) {\r\n        sb.append(\", error: \").append(this.errorStatus.getDefaultMessage());\r\n    }\r\n    if (this.graceLoginsRemaining != Integer.MAX_VALUE) {\r\n        sb.append(\", warning: \").append(this.graceLoginsRemaining).append(\" grace logins remain\");\r\n    }\r\n    if (this.timeBeforeExpiration != Integer.MAX_VALUE) {\r\n        sb.append(\", warning: time before expiration is \").append(this.timeBeforeExpiration);\r\n    }\r\n    if (!hasError() && !hasWarning()) {\r\n        sb.append(\" (no error, no warning)\");\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.springframework.security.ldap.userdetails.DefaultLdapAuthoritiesPopulator.setIgnorePartialResultException",
	"Comment": "sets the corresponding property on the underlying template, avoiding specific\tissues with active directory.",
	"Method": "void setIgnorePartialResultException(boolean ignore){\r\n    getLdapTemplate().setIgnorePartialResultException(ignore);\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.widgets.UIRadialRing.unsubscribe",
	"Comment": "unsubscribes a listener from a section. it will no longer be triggered by that section",
	"Method": "void unsubscribe(int sectionNum,ActivateEventListener listener){\r\n    if (sectionNum >= 0 && sectionNum < sections.size()) {\r\n        sections.get(sectionNum).removeListener(listener);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.rememberme.TokenBasedRememberMeServices.equals",
	"Comment": "constant time comparison to prevent against timing attacks.",
	"Method": "boolean equals(String expected,String actual){\r\n    byte[] expectedBytes = bytesUtf8(expected);\r\n    byte[] actualBytes = bytesUtf8(actual);\r\n    if (expectedBytes.length != actualBytes.length) {\r\n        return false;\r\n    }\r\n    int result = 0;\r\n    for (int i = 0; i < expectedBytes.length; i++) {\r\n        result |= expectedBytes[i] ^ actualBytes[i];\r\n    }\r\n    return result == 0;\r\n}"
}, {
	"Path": "org.terasology.persistence.serializers.EventSerializer.getEventClass",
	"Comment": "determines the event class that the serialized event is for.",
	"Method": "Class<? extends Event> getEventClass(EntityData.Event eventData){\r\n    if (eventData.hasType()) {\r\n        EventMetadata<? extends Event> metadata = null;\r\n        if (!idTable.isEmpty()) {\r\n            Class<? extends Event> eventClass = idTable.inverse().get(eventData.getType());\r\n            if (eventClass != null) {\r\n                metadata = eventLibrary.getMetadata(eventClass);\r\n            }\r\n        }\r\n        if (metadata == null) {\r\n            logger.warn(\"Unable to deserialize unknown event with id: {}\", eventData.getType());\r\n            return null;\r\n        }\r\n        return metadata.getType();\r\n    }\r\n    logger.warn(\"Unable to deserialize event, no type provided.\");\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.security.access.intercept.AbstractSecurityInterceptor.credentialsNotFound",
	"Comment": "helper method which generates an exception containing the passed reason, and\tpublishes an event to the application context.\talways throws an exception.",
	"Method": "void credentialsNotFound(String reason,Object secureObject,Collection<ConfigAttribute> configAttribs){\r\n    AuthenticationCredentialsNotFoundException exception = new AuthenticationCredentialsNotFoundException(reason);\r\n    AuthenticationCredentialsNotFoundEvent event = new AuthenticationCredentialsNotFoundEvent(secureObject, configAttribs, exception);\r\n    publishEvent(event);\r\n    throw exception;\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.widgets.UIDropdownScrollable.createNoScrollItems",
	"Comment": "located in the ondraw method, this draws the menu items when the scrollbar is unnecessary.",
	"Method": "void createNoScrollItems(Canvas canvas,Border itemMargin,int itemHeight){\r\n    for (int i = 0; i < optionListeners.size(); ++i) {\r\n        readItemMouseOver(canvas, i);\r\n        Rect2i itemRegion = Rect2i.createFromMinAndSize(0, canvas.size().y + itemHeight * i, canvas.size().x, itemHeight);\r\n        drawItem(canvas, itemMargin, i, itemRegion);\r\n    }\r\n}"
}, {
	"Path": "org.terasology.persistence.serializers.EntitySerializer.setComponentIdMapping",
	"Comment": "sets the mapping between component classes and the ids that are used for serialization",
	"Method": "void setComponentIdMapping(Map<Class<? extends Component>, Integer> table){\r\n    componentSerializer.setIdMapping(table);\r\n}"
}, {
	"Path": "org.springframework.security.config.doc.XsdDocumentedTests.countLinksWhenReviewingDocumentationThenParentsAndChildrenAreCorrectlyLinked",
	"Comment": "this test ensures that any element that has children or parents contains a section that has links pointing to that\tdocumentation.",
	"Method": "void countLinksWhenReviewingDocumentationThenParentsAndChildrenAreCorrectlyLinked(){\r\n    Map<String, List<String>> docAttrNameToChildren = new HashMap();\r\n    Map<String, List<String>> docAttrNameToParents = new HashMap();\r\n    String docAttrName = null;\r\n    Map<String, List<String>> currentDocAttrNameToElmt = null;\r\n    List<String> lines = Files.readAllLines(Paths.get(this.referenceLocation));\r\n    for (String line : lines) {\r\n        if (line.matches(\"^\\\\[\\\\[.*\\\\]\\\\]$\")) {\r\n            String id = line.substring(2, line.length() - 2);\r\n            if (id.endsWith(\"-children\")) {\r\n                docAttrName = id.substring(0, id.length() - 9);\r\n                currentDocAttrNameToElmt = docAttrNameToChildren;\r\n            } else if (id.endsWith(\"-parents\")) {\r\n                docAttrName = id.substring(0, id.length() - 8);\r\n                currentDocAttrNameToElmt = docAttrNameToParents;\r\n            } else if (docAttrName != null && !id.startsWith(docAttrName)) {\r\n                currentDocAttrNameToElmt = null;\r\n                docAttrName = null;\r\n            }\r\n        }\r\n        if (docAttrName != null && currentDocAttrNameToElmt != null) {\r\n            String expression = \"^\\\\* <<(nsa-.*),.*>>$\";\r\n            if (line.matches(expression)) {\r\n                String elmtId = line.replaceAll(expression, \"$1\");\r\n                currentDocAttrNameToElmt.computeIfAbsent(docAttrName, key -> new ArrayList()).add(elmtId);\r\n            }\r\n        }\r\n    }\r\n    Map<String, Element> elementNameToElement = this.xml.elementsByElementName(this.schemaDocumentLocation);\r\n    Map<String, List<String>> schemaAttrNameToChildren = new HashMap();\r\n    Map<String, List<String>> schemaAttrNameToParents = new HashMap();\r\n    elementNameToElement.entrySet().stream().forEach(entry -> {\r\n        String key = \"nsa-\" + entry.getKey();\r\n        if (this.ignoredIds.contains(key)) {\r\n            return;\r\n        }\r\n        List<String> parentIds = entry.getValue().getAllParentElmts().values().stream().filter(element -> !this.ignoredIds.contains(element.getId())).map(element -> element.getId()).sorted().collect(Collectors.toList());\r\n        if (!parentIds.isEmpty()) {\r\n            schemaAttrNameToParents.put(key, parentIds);\r\n        }\r\n        List<String> childIds = entry.getValue().getAllChildElmts().values().stream().filter(element -> !this.ignoredIds.contains(element.getId())).map(element -> element.getId()).sorted().collect(Collectors.toList());\r\n        if (!childIds.isEmpty()) {\r\n            schemaAttrNameToChildren.put(key, childIds);\r\n        }\r\n    });\r\n    assertThat(docAttrNameToChildren).isEqualTo(schemaAttrNameToChildren);\r\n    assertThat(docAttrNameToParents).isEqualTo(schemaAttrNameToParents);\r\n}"
}, {
	"Path": "org.springframework.security.ldap.authentication.BindAuthenticator.handleBindException",
	"Comment": "allows subclasses to inspect the exception thrown by an attempt to bind with a\tparticular dn. the default implementation just reports the failure to the debug\tlogger.",
	"Method": "void handleBindException(String userDn,String username,Throwable cause){\r\n    if (logger.isDebugEnabled()) {\r\n        logger.debug(\"Failed to bind as \" + userDn + \": \" + cause);\r\n    }\r\n}"
}, {
	"Path": "org.terasology.input.InputSystem.sendMouseEvent",
	"Comment": "creates and sends an input event based on a provided mouse action.",
	"Method": "boolean sendMouseEvent(MouseInput button,boolean buttonDown,Vector2i position,float delta){\r\n    MouseButtonEvent event;\r\n    switch(button) {\r\n        case NONE:\r\n            return false;\r\n        case MOUSE_LEFT:\r\n            event = (buttonDown) ? LeftMouseDownButtonEvent.create(position, delta) : LeftMouseUpButtonEvent.create(position, delta);\r\n            break;\r\n        case MOUSE_RIGHT:\r\n            event = (buttonDown) ? RightMouseDownButtonEvent.create(position, delta) : RightMouseUpButtonEvent.create(position, delta);\r\n            break;\r\n        default:\r\n            event = (buttonDown) ? MouseDownButtonEvent.create(button, position, delta) : MouseUpButtonEvent.create(button, position, delta);\r\n            break;\r\n    }\r\n    boolean consumed = send(event);\r\n    event.reset();\r\n    return consumed;\r\n}"
}, {
	"Path": "org.terasology.world.block.entity.neighbourUpdate.NeighbourBlockFamilyUpdateSystem.onBlockPlaced",
	"Comment": "notifies the adjacent block families when a block is placed next to them.",
	"Method": "void onBlockPlaced(OnBlockItemPlaced event,EntityRef entity){\r\n    BlockComponent blockComponent = event.getPlacedBlock().getComponent(BlockComponent.class);\r\n    if (blockComponent == null) {\r\n        return;\r\n    }\r\n    processUpdateForBlockLocation(blockComponent.position);\r\n}"
}, {
	"Path": "org.terasology.rendering.logic.NearestSortingList.clearQueue",
	"Comment": "clear the command queue in a synchronized way. used when the sortingfails.",
	"Method": "void clearQueue(){\r\n    commands.clear();\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.layers.mainMenu.savedGames.GameProvider.getNextGameName",
	"Comment": "generates the game name based on the game number of the last saved game",
	"Method": "String getNextGameName(){\r\n    int gameNumber = 1;\r\n    for (GameInfo info : GameProvider.getSavedGames()) {\r\n        if (info.getManifest().getTitle().startsWith(DEFAULT_GAME_NAME_PREFIX)) {\r\n            String remainder = info.getManifest().getTitle().substring(DEFAULT_GAME_NAME_PREFIX.length());\r\n            try {\r\n                gameNumber = Math.max(gameNumber, Integer.parseInt(remainder) + 1);\r\n            } catch (NumberFormatException e) {\r\n                logger.trace(\"Could not parse {} as integer (not an error)\", remainder, e);\r\n            }\r\n        }\r\n    }\r\n    return DEFAULT_GAME_NAME_PREFIX + gameNumber;\r\n}"
}, {
	"Path": "org.springframework.security.core.authority.mapping.MapBasedAttributes2GrantedAuthoritiesMapper.getGrantedAuthorities",
	"Comment": "map the given array of attributes to spring security grantedauthorities.",
	"Method": "List<GrantedAuthority> getGrantedAuthorities(Collection<String> attributes){\r\n    ArrayList<GrantedAuthority> gaList = new ArrayList();\r\n    for (String attribute : attributes) {\r\n        Collection<GrantedAuthority> c = attributes2grantedAuthoritiesMap.get(attribute);\r\n        if (c != null) {\r\n            gaList.addAll(c);\r\n        }\r\n    }\r\n    gaList.trimToSize();\r\n    return gaList;\r\n}"
}, {
	"Path": "springfox.documentation.spring.web.dummy.controllers.FeatureDemonstrationService.getEffective",
	"Comment": "calculates effective url and ignores uricomponentsbuilder",
	"Method": "ResponseEntity<Example> getEffective(UriComponentsBuilder builder){\r\n    return new ResponseEntity<Example>(new Example(\"Hello\", 1, EnumType.ONE, new NestedType(\"test\")), HttpStatus.OK);\r\n}"
}, {
	"Path": "org.terasology.logic.characters.interactions.InteractionSystem.onScreenLayerClosed",
	"Comment": "the method listens for the event that the user closes the screen of the current interaction target.when it happens then it cancels the interaction.",
	"Method": "void onScreenLayerClosed(ScreenLayerClosedEvent event,EntityRef container,ClientComponent clientComponent){\r\n    EntityRef character = clientComponent.character;\r\n    ResourceUrn activeInteractionScreenUri = InteractionUtil.getActiveInteractionScreenUri(character);\r\n    if ((activeInteractionScreenUri != null) && (activeInteractionScreenUri.equals(event.getClosedScreenUri()))) {\r\n        InteractionUtil.cancelInteractionAsClient(clientComponent.character);\r\n    }\r\n}"
}, {
	"Path": "org.terasology.rendering.assets.texture.TextureUtil.getTextureUriForWhiteNoise",
	"Comment": "returns a asseturi which represents a texture that contains white noise",
	"Method": "ResourceUrn getTextureUriForWhiteNoise(int size,long seed,int min,int max){\r\n    String name = String.format(\"%s.%d.%d.%d.%d\", \"white\", size, seed, min, max);\r\n    return new ResourceUrn(TerasologyConstants.ENGINE_MODULE, NOISE_RESOURCE_NAME, new Name(name));\r\n}"
}, {
	"Path": "springfox.documentation.builders.ApiListingBuilder.appendConsumes",
	"Comment": "appends to the exiting collection of supported media types this listing consumes",
	"Method": "ApiListingBuilder appendConsumes(List<String> consumes){\r\n    this.consumes.addAll(nullToEmptyList(consumes));\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.security.web.context.HttpSessionSecurityContextRepository.setSpringSecurityContextKey",
	"Comment": "allows the session attribute name to be customized for this repository instance.",
	"Method": "void setSpringSecurityContextKey(String springSecurityContextKey){\r\n    Assert.hasText(springSecurityContextKey, \"springSecurityContextKey cannot be empty\");\r\n    this.springSecurityContextKey = springSecurityContextKey;\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.layers.ingame.metrics.DebugOverlay.toggleMetricsMode",
	"Comment": "moves forward through the metricsmode instances and displays the content of the next available one.",
	"Method": "void toggleMetricsMode(){\r\n    MetricsMode mode = debugMetricsSystem.toggle();\r\n    PerformanceMonitor.setEnabled(mode.isPerformanceManagerMode());\r\n}"
}, {
	"Path": "org.springframework.security.ldap.userdetails.LdapAuthority.getFirstAttributeValue",
	"Comment": "returns the first attribute value for a specified attribute",
	"Method": "String getFirstAttributeValue(String name){\r\n    List<String> result = getAttributeValues(name);\r\n    if (result.isEmpty()) {\r\n        return null;\r\n    } else {\r\n        return result.get(0);\r\n    }\r\n}"
}, {
	"Path": "org.terasology.engine.TerasologyEngine.shutdown",
	"Comment": "causes the main loop to stop at the end of the current frame, cleanly endingthe current gamestate, all running task threads and disposing subsystems.",
	"Method": "void shutdown(){\r\n    shutdownRequested = true;\r\n}"
}, {
	"Path": "org.springframework.security.access.intercept.RunAsManagerImpl.supports",
	"Comment": "this implementation supports any type of class, because it does not query the\tpresented secure object.",
	"Method": "boolean supports(ConfigAttribute attribute,boolean supports,Class<?> clazz){\r\n    return true;\r\n}"
}, {
	"Path": "org.springframework.security.web.util.matcher.AntPathRequestMatcher.valueOf",
	"Comment": "provides a save way of obtaining the httpmethod from a string. if the method is\tinvalid, returns null.",
	"Method": "HttpMethod valueOf(String method){\r\n    try {\r\n        return HttpMethod.valueOf(method);\r\n    } catch (IllegalArgumentException e) {\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.terasology.reflection.metadata.FieldMetadata.getValue",
	"Comment": "obtains the value of the field from a object which is an instance of the owning type.",
	"Method": "U getValue(Object from){\r\n    return accessor.getValue((T) from);\r\n}"
}, {
	"Path": "org.terasology.rendering.logic.NearestSortingList.cloneAndSetSorting",
	"Comment": "these two actions needed to happen atomically and the easier method wasto put them in a synchronized method.",
	"Method": "List<EntityRef> cloneAndSetSorting(){\r\n    sorting = true;\r\n    return cloneEntities();\r\n}"
}, {
	"Path": "org.terasology.network.internal.ClientHandshakeHandler.processServerHello",
	"Comment": "client checks to see if it received the server hello message, if so it processes it into a random key and the certificate.",
	"Method": "void processServerHello(NetData.HandshakeHello helloMessage,ChannelHandlerContext ctx){\r\n    if (serverHello == null) {\r\n        logger.info(\"Received Server Hello\");\r\n        serverHello = helloMessage;\r\n        serverRandom = helloMessage.getRandom().toByteArray();\r\n        NetData.Certificate cert = helloMessage.getCertificate();\r\n        serverCertificate = NetMessageUtil.convert(cert);\r\n        if (!serverCertificate.verifySelfSigned()) {\r\n            logger.error(\"Received invalid server certificate: cancelling authentication\");\r\n            joinStatus.setErrorMessage(AUTHENTICATION_FAILURE);\r\n            ctx.getChannel().close();\r\n            return;\r\n        }\r\n        clientRandom = new byte[IdentityConstants.SERVER_CLIENT_RANDOM_LENGTH];\r\n        identity = config.getSecurity().getIdentity(serverCertificate);\r\n        if (identity == null) {\r\n            requestIdentity(ctx);\r\n        } else {\r\n            sendCertificate(helloMessage, ctx);\r\n        }\r\n    } else {\r\n        logger.error(\"Received multiple hello messages from server: cancelling authentication\");\r\n        joinStatus.setErrorMessage(AUTHENTICATION_FAILURE);\r\n        ctx.getChannel().close();\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.access.vote.AbstractAclVoter.supports",
	"Comment": "this implementation supports only methodsecurityinterceptor, because\tit queries the presented methodinvocation.",
	"Method": "boolean supports(Class<?> clazz){\r\n    return (MethodInvocation.class.isAssignableFrom(clazz));\r\n}"
}, {
	"Path": "org.springframework.security.ldap.userdetails.NestedLdapAuthoritiesPopulator.setAttributeNames",
	"Comment": "sets the attribute names to retrieve for each ldap groups. null means retrieve all",
	"Method": "void setAttributeNames(Set<String> attributeNames){\r\n    this.attributeNames = attributeNames;\r\n}"
}, {
	"Path": "org.springframework.security.ldap.userdetails.NestedLdapAuthoritiesPopulator.getAttributeNames",
	"Comment": "returns the attribute names that this populator has been configured to retrieve\tvalue can be null, represents fetch all attributes",
	"Method": "Set<String> getAttributeNames(){\r\n    return this.attributeNames;\r\n}"
}, {
	"Path": "org.terasology.physics.bullet.BulletPhysics.createCharacterCollider",
	"Comment": "creates a collider for the given entity based on the locationcomponentand charactermovementcomponent.all collision flags are set right for a character movement component.",
	"Method": "CharacterCollider createCharacterCollider(EntityRef owner){\r\n    LocationComponent locComp = owner.getComponent(LocationComponent.class);\r\n    CharacterMovementComponent movementComp = owner.getComponent(CharacterMovementComponent.class);\r\n    if (locComp == null || movementComp == null) {\r\n        throw new IllegalArgumentException(\"Expected an entity with a Location component and CharacterMovementComponent.\");\r\n    }\r\n    Vector3f pos = VecMath.to(locComp.getWorldPosition());\r\n    final float worldScale = locComp.getWorldScale();\r\n    final float height = (movementComp.height - 2 * movementComp.radius) * worldScale;\r\n    final float width = movementComp.radius * worldScale;\r\n    ConvexShape shape = new CapsuleShape(width, height);\r\n    shape.setMargin(0.1f);\r\n    return createCustomCollider(pos, shape, movementComp.collisionGroup.getFlag(), combineGroups(movementComp.collidesWith), CollisionFlags.CHARACTER_OBJECT, owner);\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.editor.layers.AbstractEditorScreen.updateAutosave",
	"Comment": "updates the autosave file with the current state of the tree.",
	"Method": "void updateAutosave(){\r\n    if (!disableAutosave) {\r\n        try (BufferedOutputStream outputStream = new BufferedOutputStream(Files.newOutputStream(getAutosaveFile()))) {\r\n            JsonElement editorContents = JsonTreeConverter.deserialize(getEditor().getModel().getNode(0).getRoot());\r\n            JsonObject autosaveObject = new JsonObject();\r\n            autosaveObject.addProperty(\"selectedAsset\", getSelectedAsset());\r\n            autosaveObject.add(\"editorContents\", editorContents);\r\n            String jsonString = new GsonBuilder().setPrettyPrinting().create().toJson(autosaveObject);\r\n            outputStream.write(jsonString.getBytes());\r\n        } catch (IOException e) {\r\n            logger.warn(\"Could not save to autosave file\", e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.terasology.monitoring.PerformanceMonitor.getAllocationMean",
	"Comment": "returns a mapping from the name of an activity to a running mean of allocated memory duringthe execution of the activity, over a number of cycles.activities may be nested, and while a nested activity is running the collection of data fromouter activities is paused and allocated memory is not assigned to them.no guarantee can be given that the memory allocated during the execution of an activity isentirely due to the activity. other threads for example might increase or decrease thefigure.",
	"Method": "TObjectDoubleMap<String> getAllocationMean(){\r\n    return instance.getAllocationMean();\r\n}"
}, {
	"Path": "org.terasology.rendering.openvrprovider.OpenVRProvider.getInstance",
	"Comment": "as a general rule, we should use this class as a singleton, because multiple instantiation will likely cause problems in the upstream native library. this provides a convenient method of using openvrprovider as a singleton.",
	"Method": "OpenVRProvider getInstance(){\r\n    if (instance == null) {\r\n        instance = new OpenVRProvider();\r\n    }\r\n    return instance;\r\n}"
}, {
	"Path": "springfox.documentation.spi.schema.contexts.ModelPropertyContext.getDocumentationType",
	"Comment": "documentation type this context supports, swagger 1.2, 2.0 or vanilla spring mvc",
	"Method": "DocumentationType getDocumentationType(){\r\n    return documentationType;\r\n}"
}, {
	"Path": "org.springframework.security.web.savedrequest.HttpSessionRequestCache.saveRequest",
	"Comment": "stores the current request, provided the configuration properties allow it.",
	"Method": "void saveRequest(HttpServletRequest request,HttpServletResponse response){\r\n    if (requestMatcher.matches(request)) {\r\n        DefaultSavedRequest savedRequest = new DefaultSavedRequest(request, portResolver);\r\n        if (createSessionAllowed || request.getSession(false) != null) {\r\n            request.getSession().setAttribute(this.sessionAttrName, savedRequest);\r\n            logger.debug(\"DefaultSavedRequest added to Session: \" + savedRequest);\r\n        }\r\n    } else {\r\n        logger.debug(\"Request not saved as configured RequestMatcher did not match\");\r\n    }\r\n}"
}, {
	"Path": "org.terasology.logic.players.LocalPlayerSystem.getValidKey",
	"Comment": "to check if a valid key has been assigned, either primary or secondary and return it",
	"Method": "Input getValidKey(List<Input> inputs){\r\n    for (Input input : inputs) {\r\n        if (input != null) {\r\n            return input;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.security.openid.OpenIDAuthenticationFilter.setClaimedIdentityFieldName",
	"Comment": "the name of the request parameter containing the openid identity, as submitted from\tthe initial login form.",
	"Method": "void setClaimedIdentityFieldName(String claimedIdentityFieldName){\r\n    this.claimedIdentityFieldName = claimedIdentityFieldName;\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.widgets.UIDropdown.setSelection",
	"Comment": "set the item from that should be selected.note that this item does not actually have to be contained in the list of options.",
	"Method": "void setSelection(T value){\r\n    selection.set(value);\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilter.unsuccessfulAuthentication",
	"Comment": "ensures the authentication object in the secure context is set to null when\tauthentication fails.\tcaches the failure exception as a request attribute",
	"Method": "void unsuccessfulAuthentication(HttpServletRequest request,HttpServletResponse response,AuthenticationException failed){\r\n    SecurityContextHolder.clearContext();\r\n    if (logger.isDebugEnabled()) {\r\n        logger.debug(\"Cleared security context due to exception\", failed);\r\n    }\r\n    request.setAttribute(WebAttributes.AUTHENTICATION_EXCEPTION, failed);\r\n    if (authenticationFailureHandler != null) {\r\n        authenticationFailureHandler.onAuthenticationFailure(request, response, failed);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.taglibs.authz.AccessControlListTag.getContext",
	"Comment": "allows test cases to override where application context obtained from.",
	"Method": "ApplicationContext getContext(PageContext pageContext){\r\n    ServletContext servletContext = pageContext.getServletContext();\r\n    return SecurityWebApplicationContextUtils.findRequiredWebApplicationContext(servletContext);\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint.buildHttpsRedirectUrlForRequest",
	"Comment": "builds a url to redirect the supplied request to https. used to redirect the\tcurrent request to https, before doing a forward to the login page.",
	"Method": "String buildHttpsRedirectUrlForRequest(HttpServletRequest request){\r\n    int serverPort = portResolver.getServerPort(request);\r\n    Integer httpsPort = portMapper.lookupHttpsPort(Integer.valueOf(serverPort));\r\n    if (httpsPort != null) {\r\n        RedirectUrlBuilder urlBuilder = new RedirectUrlBuilder();\r\n        urlBuilder.setScheme(\"https\");\r\n        urlBuilder.setServerName(request.getServerName());\r\n        urlBuilder.setPort(httpsPort.intValue());\r\n        urlBuilder.setContextPath(request.getContextPath());\r\n        urlBuilder.setServletPath(request.getServletPath());\r\n        urlBuilder.setPathInfo(request.getPathInfo());\r\n        urlBuilder.setQuery(request.getQueryString());\r\n        return urlBuilder.getUrl();\r\n    }\r\n    logger.warn(\"Unable to redirect to HTTPS as no port mapping found for HTTP port \" + serverPort);\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.security.crypto.password.Md4PasswordEncoder.encode",
	"Comment": "encodes the rawpass using a messagedigest. if a salt is specified it will be merged\twith the password before encoding.",
	"Method": "String encode(CharSequence rawPassword,String encode,byte[] digest){\r\n    if (this.encodeHashAsBase64) {\r\n        return Utf8.decode(Base64.getEncoder().encode(digest));\r\n    } else {\r\n        return new String(Hex.encode(digest));\r\n    }\r\n}"
}, {
	"Path": "org.terasology.rendering.primitives.BlockMeshGeneratorSingleShape.isSideVisibleForBlockTypes",
	"Comment": "returns true if the side should be rendered adjacent to the second side provided.",
	"Method": "boolean isSideVisibleForBlockTypes(Block blockToCheck,Block currentBlock,Side side){\r\n    if (currentBlock.isLiquid() && blockToCheck.isLiquid()) {\r\n        return false;\r\n    }\r\n    return currentBlock.isWaving() != blockToCheck.isWaving() || blockToCheck.getMeshGenerator() == null || !blockToCheck.isFullSide(side.reverse()) || (!currentBlock.isTranslucent() && blockToCheck.isTranslucent());\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.widgets.UIRadialRing.subscribe",
	"Comment": "subscribes a listener to a section. will be triggered when the mouse is released over that section",
	"Method": "void subscribe(int sectionNum,ActivateEventListener listener){\r\n    if (sectionNum >= 0 && sectionNum < sections.size()) {\r\n        sections.get(sectionNum).addListener(listener);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilter.setInvalidateSessionOnPrincipalChange",
	"Comment": "if checkforprincipalchanges is set, and a change of principal is detected,\tdetermines whether any existing session should be invalidated before proceeding to\tauthenticate the new principal.",
	"Method": "void setInvalidateSessionOnPrincipalChange(boolean invalidateSessionOnPrincipalChange){\r\n    this.invalidateSessionOnPrincipalChange = invalidateSessionOnPrincipalChange;\r\n}"
}, {
	"Path": "org.springframework.security.oauth2.server.resource.web.BearerTokenAuthenticationEntryPoint.setRealmName",
	"Comment": "set the default realm name to use in the bearer token error response",
	"Method": "void setRealmName(String realmName){\r\n    this.realmName = realmName;\r\n}"
}, {
	"Path": "org.terasology.network.internal.ClientHandshakeHandler.sendCertificate",
	"Comment": "generates a client hello from clientrandom file, time, and the public client certificate. sends the clients hello and certificate back to the server via network channel.",
	"Method": "void sendCertificate(NetData.HandshakeHello helloMessage,ChannelHandlerContext ctx){\r\n    logger.info(\"Sending client certificate\");\r\n    PublicIdentityCertificate pubClientCert = identity.getPlayerPublicCertificate();\r\n    clientHello = NetData.HandshakeHello.newBuilder().setRandom(ByteString.copyFrom(clientRandom)).setCertificate(NetMessageUtil.convert(pubClientCert)).setTimestamp(System.currentTimeMillis()).build();\r\n    byte[] dataToSign = Bytes.concat(helloMessage.toByteArray(), clientHello.toByteArray());\r\n    byte[] signature = identity.getPlayerPrivateCertificate().sign(dataToSign);\r\n    ctx.getChannel().write(NetData.NetMessage.newBuilder().setHandshakeHello(clientHello).setHandshakeVerification(NetData.HandshakeVerification.newBuilder().setSignature(ByteString.copyFrom(signature))).build());\r\n}"
}, {
	"Path": "org.terasology.network.internal.AbstractClient.findUniquePlayerName",
	"Comment": "provides an alternative name to the client when the preferred name is taken or unavailable, appending a suffix to the end.",
	"Method": "String findUniquePlayerName(String preferredName,EntityManager entityManager,EntityRef player){\r\n    Set<String> usedNames = findNamesOfOtherPlayers(entityManager, player);\r\n    String name = preferredName;\r\n    int nextSuffix = 2;\r\n    while (usedNames.contains(name)) {\r\n        name = preferredName + nextSuffix;\r\n        nextSuffix++;\r\n    }\r\n    return name;\r\n}"
}, {
	"Path": "org.terasology.recording.EventSystemReplayImpl.fillRecordedEvents",
	"Comment": "fills recordedevents with the events in recordedeventstore.",
	"Method": "void fillRecordedEvents(){\r\n    Collection<RecordedEvent> events = recordedEventStore.getEvents();\r\n    for (RecordedEvent event : events) {\r\n        this.recordedEvents.offer(event);\r\n    }\r\n}"
}, {
	"Path": "springfox.documentation.spring.web.plugins.Docket.pathMapping",
	"Comment": "extensibility mechanism to add a servlet path mapping, if there is one, to the apis base path.",
	"Method": "Docket pathMapping(String path){\r\n    this.pathMapping = ofNullable(path);\r\n    return this;\r\n}"
}, {
	"Path": "org.terasology.world.block.Block.calcColorOffsetFor",
	"Comment": "calculates the color offset for a given block type and a specificside of the block.",
	"Method": "Vector4f calcColorOffsetFor(BlockPart part,Biome biome){\r\n    BlockColorSource source = getColorSource(part);\r\n    Vector4f color = source.calcColor(biome);\r\n    Vector4f colorOffset = colorOffsets.get(part);\r\n    color.x *= colorOffset.x;\r\n    color.y *= colorOffset.y;\r\n    color.z *= colorOffset.z;\r\n    color.w *= colorOffset.w;\r\n    return color;\r\n}"
}, {
	"Path": "org.terasology.world.zones.Zone.containsBlock",
	"Comment": "test whether this zone contains the block at the given world position.",
	"Method": "boolean containsBlock(int x,int y,int z,Region chunkRegion){\r\n    return regionFunction.apply(x, y, z, chunkRegion);\r\n}"
}, {
	"Path": "springfox.documentation.schema.Annotations.findPropertyAnnotation",
	"Comment": "finds first annotation of the given type on the given bean property and returns it.search precedence is getter, setter, field.",
	"Method": "Optional<A> findPropertyAnnotation(BeanPropertyDefinition beanPropertyDefinition,Class<A> annotationClass){\r\n    return tryGetFieldAnnotation(beanPropertyDefinition, annotationClass).map(Optional::of).orElse(tryGetGetterAnnotation(beanPropertyDefinition, annotationClass)).map(Optional::of).orElse(tryGetSetterAnnotation(beanPropertyDefinition, annotationClass));\r\n}"
}, {
	"Path": "org.springframework.security.ldap.userdetails.DefaultLdapAuthoritiesPopulator.getDefaultRole",
	"Comment": "returns the default role method available so that classes extending this can\toverride",
	"Method": "GrantedAuthority getDefaultRole(){\r\n    return this.defaultRole;\r\n}"
}, {
	"Path": "org.springframework.security.core.context.SecurityContextHolder.clearContext",
	"Comment": "explicitly clears the context value from the current thread.",
	"Method": "void clearContext(){\r\n    strategy.clearContext();\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.session.ConcurrentSessionControlAuthenticationStrategy.setExceptionIfMaximumExceeded",
	"Comment": "sets the exceptionifmaximumexceeded property, which determines whether the\tuser should be prevented from opening more sessions than allowed. if set to\ttrue, a sessionauthenticationexception will be raised which means\tthe user authenticating will be prevented from authenticating. if set to\tfalse, the user that has already authenticated will be forcibly logged",
	"Method": "void setExceptionIfMaximumExceeded(boolean exceptionIfMaximumExceeded){\r\n    this.exceptionIfMaximumExceeded = exceptionIfMaximumExceeded;\r\n}"
}, {
	"Path": "org.terasology.logic.console.commands.ClientCommands.debugTarget",
	"Comment": "displays debug information on the target entity for the target the camera is pointing at",
	"Method": "String debugTarget(){\r\n    EntityRef cameraTarget = cameraTargetSystem.getTarget();\r\n    return cameraTarget.toFullDescription();\r\n}"
}, {
	"Path": "org.springframework.security.web.header.Header.getValues",
	"Comment": "gets the values of the header. cannot be null, empty, or contain null values.",
	"Method": "List<String> getValues(){\r\n    return this.headerValues;\r\n}"
}, {
	"Path": "org.terasology.rendering.opengl.FBO.bindTexture",
	"Comment": "binds the color attachment to the currently active texture unit.once a texture is bound it can be sampled by shaders.",
	"Method": "void bindTexture(){\r\n    GL11.glBindTexture(GL11.GL_TEXTURE_2D, colorBufferTextureId);\r\n}"
}, {
	"Path": "org.terasology.world.block.family.BlockFamilyLibrary.createFamily",
	"Comment": "create a family based on the type and instantiate from the the family definition of the block and builder",
	"Method": "BlockFamily createFamily(Class<? extends AbstractBlockFamily> blockFamily,BlockFamilyDefinition blockFamilyDefinition,BlockBuilderHelper blockBuilderHelper,BlockFamily createFamily,Class<? extends AbstractBlockFamily> blockFamily,BlockFamilyDefinition blockFamilyDefinition,BlockShape shape,BlockBuilderHelper blockBuilderHelper){\r\n    try {\r\n        SimpleClassFactory simpleClassFactory = new SimpleClassFactory(new ParameterProvider() {\r\n            @Override\r\n            public <T> Optional<T> get(Class<T> type) {\r\n                if (type.isAssignableFrom(BlockBuilderHelper.class)) {\r\n                    return Optional.ofNullable((T) blockBuilderHelper);\r\n                } else if (type.isAssignableFrom(BlockFamilyDefinition.class)) {\r\n                    return Optional.ofNullable((T) blockFamilyDefinition);\r\n                } else if (type.isAssignableFrom(BlockShape.class)) {\r\n                    return Optional.ofNullable((T) shape);\r\n                }\r\n                return Optional.empty();\r\n            }\r\n        });\r\n        BlockFamily result = simpleClassFactory.instantiateClass(blockFamily).get();\r\n        InjectionHelper.inject(result);\r\n        if (result.getURI() == null) {\r\n            throw new Exception(\"Family Is missng a BlockUri\");\r\n        }\r\n        return result;\r\n    } catch (Exception e) {\r\n        logger.error(\"Failed to load blockFamily {}\", blockFamily, e);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.terasology.world.block.family.BlockFamilyLibrary.createFamily",
	"Comment": "create a family based on the type and instantiate from the the family definition of the block and builder",
	"Method": "BlockFamily createFamily(Class<? extends AbstractBlockFamily> blockFamily,BlockFamilyDefinition blockFamilyDefinition,BlockBuilderHelper blockBuilderHelper,BlockFamily createFamily,Class<? extends AbstractBlockFamily> blockFamily,BlockFamilyDefinition blockFamilyDefinition,BlockShape shape,BlockBuilderHelper blockBuilderHelper){\r\n    if (type.isAssignableFrom(BlockBuilderHelper.class)) {\r\n        return Optional.ofNullable((T) blockBuilderHelper);\r\n    } else if (type.isAssignableFrom(BlockFamilyDefinition.class)) {\r\n        return Optional.ofNullable((T) blockFamilyDefinition);\r\n    } else if (type.isAssignableFrom(BlockShape.class)) {\r\n        return Optional.ofNullable((T) shape);\r\n    }\r\n    return Optional.empty();\r\n}"
}, {
	"Path": "org.terasology.entitySystem.entity.internal.PojoEntityPool.createEntityWithoutLifecycleEvents",
	"Comment": "creates the entity without sending any events. the entity life cycle subscriber will however be informed.",
	"Method": "EntityRef createEntityWithoutLifecycleEvents(Iterable<Component> components,EntityRef createEntityWithoutLifecycleEvents,String prefabName,EntityRef createEntityWithoutLifecycleEvents,Prefab prefab){\r\n    return create(prefab, null, null, false);\r\n}"
}, {
	"Path": "org.terasology.rendering.opengl.FBO.bindDepthTexture",
	"Comment": "binds the depth attachment to the currently active texture unit.once a texture is bound it can be sampled by shaders.",
	"Method": "void bindDepthTexture(){\r\n    GL11.glBindTexture(GL11.GL_TEXTURE_2D, depthStencilTextureId);\r\n}"
}, {
	"Path": "org.springframework.security.config.doc.XsdDocumentedTests.sizeWhenReadingFilesystemThenIsCorrectNumberOfSchemaFiles",
	"Comment": "this will check to ensure that the expected number of xsd documents are found to ensure that we are validating\tagainst the current xsd document. if this test fails, all that is needed is to update the schemadocument\tand the expected size for this test.",
	"Method": "void sizeWhenReadingFilesystemThenIsCorrectNumberOfSchemaFiles(){\r\n    ClassPathResource resource = new ClassPathResource(this.schemaDocumentLocation);\r\n    String[] schemas = resource.getFile().getParentFile().list((dir, name) -> name.endsWith(\".xsd\"));\r\n    assertThat(schemas.length).isEqualTo(13).withFailMessage(\"the count is equal to 12, if not then schemaDocument needs updating\");\r\n}"
}, {
	"Path": "org.terasology.reflection.metadata.ClassMetadata.copyRaw",
	"Comment": "this method is for use in situations where metadata is being used generically and the actual type of the value cannot be",
	"Method": "T copyRaw(Object object){\r\n    if (getType().isInstance(object)) {\r\n        return copy(getType().cast(object));\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.terasology.config.BindsConfig.hasBinds",
	"Comment": "returns whether an input bind has been registered with the bindsconfig.it may just have trivial none input.",
	"Method": "boolean hasBinds(SimpleUri uri){\r\n    return !uriBoundInputs.get(uri).isEmpty();\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.layouts.relative.HorizontalHint.centerRelativeTo",
	"Comment": "centers the widget relative to part of another widget, with a pixel offset.",
	"Method": "HorizontalHint centerRelativeTo(String widgetId,HorizontalAlign targetPart,HorizontalHint centerRelativeTo,String widgetId,HorizontalAlign targetPart,int offset){\r\n    positionCenter = new HorizontalInfo();\r\n    positionCenter.setTarget(targetPart);\r\n    positionCenter.setWidget(widgetId);\r\n    positionCenter.setOffset(offset);\r\n    return this;\r\n}"
}, {
	"Path": "org.terasology.rendering.openvrprovider.OpenVRUtil.convertToQuaternion",
	"Comment": "converts the rotation portion of a 4x4 matrix into a unit quaternion.",
	"Method": "Vector4f convertToQuaternion(Matrix4f m1){\r\n    return getQuaternion(true, m1.m00(), m1.m10(), m1.m20(), m1.m01(), m1.m11(), m1.m21(), m1.m02(), m1.m12(), m1.m22());\r\n}"
}, {
	"Path": "org.terasology.logic.console.ConsoleImpl.unsubscribe",
	"Comment": "unsubscribe from receiving notification of messages being added to the console",
	"Method": "void unsubscribe(ConsoleSubscriber subscriber){\r\n    this.messageSubscribers.remove(subscriber);\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.preauth.PreAuthenticatedGrantedAuthoritiesUserDetailsService.createUserDetails",
	"Comment": "creates the final userdetails object. can be overridden to customize the\tcontents.",
	"Method": "UserDetails createUserDetails(Authentication token,Collection<? extends GrantedAuthority> authorities){\r\n    return new User(token.getName(), \"N/A\", true, true, true, true, authorities);\r\n}"
}, {
	"Path": "org.springframework.security.crypto.password.MessageDigestPasswordEncoder.matches",
	"Comment": "takes a previously encoded password and compares it with a rawpassword after mixing\tin the salt and encoding that value",
	"Method": "boolean matches(CharSequence rawPassword,String encodedPassword){\r\n    String salt = extractSalt(encodedPassword);\r\n    String rawPasswordEncoded = digest(salt, rawPassword);\r\n    return PasswordEncoderUtils.equals(encodedPassword.toString(), rawPasswordEncoded);\r\n}"
}, {
	"Path": "org.terasology.input.InputSystem.processMouseWheelInput",
	"Comment": "processes input actions by the mouse wheel, sends input events and updates bind buttons accordingly.",
	"Method": "void processMouseWheelInput(float delta,MouseAction action){\r\n    int dir = action.getInput().getId();\r\n    if (dir != 0 && action.getTurns() != 0) {\r\n        boolean consumed = sendMouseWheelEvent(action.getMousePosition(), dir * action.getTurns(), delta);\r\n        BindableButton bind = (dir == 1) ? bindsManager.getMouseWheelUpBind() : bindsManager.getMouseWheelDownBind();\r\n        if (bind != null) {\r\n            for (int i = 0; i < action.getTurns(); ++i) {\r\n                updateBindState(bind, action.getInput(), true, delta, consumed);\r\n                updateBindState(bind, action.getInput(), false, delta, consumed);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "springfox.documentation.spi.schema.contexts.ModelContext.fromParent",
	"Comment": "convenience method to provide an new context for an input parameter",
	"Method": "ModelContext fromParent(ModelContext context,ResolvedType input){\r\n    return new ModelContext(context, input);\r\n}"
}, {
	"Path": "org.springframework.security.web.util.ThrowableAnalyzer.getRegisteredTypes",
	"Comment": "returns an array containing the classes for which extractors are registered. the\torder of the classes is the order in which comparisons will occur for resolving a\tmatching extractor.",
	"Method": "Class<? extends Throwable>[] getRegisteredTypes(){\r\n    Set<Class<? extends Throwable>> typeList = this.extractorMap.keySet();\r\n    return typeList.toArray(new Class[typeList.size()]);\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.widgets.UIDropdown.setOptionRenderer",
	"Comment": "set the renderer to use for the options.this is used to display the options on the dropdown list and in the selection box.",
	"Method": "void setOptionRenderer(ItemRenderer<T> itemRenderer){\r\n    optionRenderer = itemRenderer;\r\n}"
}, {
	"Path": "org.terasology.math.Rotation.findReverse",
	"Comment": "finds a reverse rotation to the specified one. any side transformed by the rotation passed as a parameter, whenpassed to the returned rotation will return the original side.",
	"Method": "Rotation findReverse(Rotation rotation){\r\n    Preconditions.checkNotNull(rotation);\r\n    return REVERSE_ROTATIONS[rotation.index];\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.layers.mainMenu.NameRecordingScreen.rewriteManifestTitle",
	"Comment": "rewrites the title of the save game manifest to match the new directory title.",
	"Method": "void rewriteManifestTitle(Path destinationPath,String newTitle){\r\n    GameManifest manifest = GameManifest.load(destinationPath.resolve(GameManifest.DEFAULT_FILE_NAME));\r\n    manifest.setTitle(newTitle);\r\n    GameManifest.save(destinationPath.resolve(GameManifest.DEFAULT_FILE_NAME), manifest);\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.www.DigestAuthUtils.generateDigest",
	"Comment": "computes the response portion of a digest authentication header. both\tthe server and user agent should compute the response independently.\tprovided as a static method to simplify the coding of user agents.",
	"Method": "String generateDigest(boolean passwordAlreadyEncoded,String username,String realm,String password,String httpMethod,String uri,String qop,String nonce,String nc,String cnonce){\r\n    String a1Md5;\r\n    String a2 = httpMethod + \":\" + uri;\r\n    String a2Md5 = md5Hex(a2);\r\n    if (passwordAlreadyEncoded) {\r\n        a1Md5 = password;\r\n    } else {\r\n        a1Md5 = DigestAuthUtils.encodePasswordInA1Format(username, realm, password);\r\n    }\r\n    String digest;\r\n    if (qop == null) {\r\n        digest = a1Md5 + \":\" + nonce + \":\" + a2Md5;\r\n    } else if (\"auth\".equals(qop)) {\r\n        digest = a1Md5 + \":\" + nonce + \":\" + nc + \":\" + cnonce + \":\" + qop + \":\" + a2Md5;\r\n    } else {\r\n        throw new IllegalArgumentException(\"This method does not support a qop: '\" + qop + \"'\");\r\n    }\r\n    return md5Hex(digest);\r\n}"
}, {
	"Path": "org.springframework.security.config.doc.SpringSecurityXsdParser.attrgrp",
	"Comment": "processes an individual attributegroup by obtaining all the attributes and then looking for more attributegroup elements and prcessing them.",
	"Method": "Collection<Attribute> attrgrp(XmlNode e){\r\n    Collection<Attribute> attrs = attrs(e);\r\n    attrs.addAll(attrgrps(e));\r\n    return attrs;\r\n}"
}, {
	"Path": "springfox.documentation.spi.service.contexts.ParameterExpansionContext.getField",
	"Comment": "access to the raw field is deprecated to support interface based model attributes with resolvers e.g. pageable",
	"Method": "ResolvedField getField(){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "org.terasology.audio.formats.OggReader.read",
	"Comment": "reads up to len bytes of data from the input stream into a bytebuffer.",
	"Method": "int read(int read,byte[] b,int off,int len,int read,ByteBuffer b,int off,int len){\r\n    if (eos) {\r\n        return -1;\r\n    }\r\n    b.position(off);\r\n    int bytesRead = 0;\r\n    int bytesRemaining = len;\r\n    while (!eos && (bytesRemaining > 0)) {\r\n        fillConvbuffer();\r\n        if (!eos) {\r\n            int bytesToCopy = Math.min(bytesRemaining, convbufferSize - convbufferOff);\r\n            b.put(convbuffer, convbufferOff, bytesToCopy);\r\n            convbufferOff += bytesToCopy;\r\n            bytesRead += bytesToCopy;\r\n            bytesRemaining -= bytesToCopy;\r\n        }\r\n    }\r\n    return bytesRead;\r\n}"
}, {
	"Path": "org.terasology.persistence.serializers.ComponentSerializer.deserializeOnto",
	"Comment": "deserializes the componentdata on top of the target component. any fields that are not present in the componentdata,or which cannot be deserialized, are left unaltered.",
	"Method": "Component deserializeOnto(Component target,EntityData.Component componentData,Component deserializeOnto,Component target,EntityData.Component componentData,Module context,Component deserializeOnto,Component target,EntityData.Component componentData,FieldSerializeCheck<Component> fieldCheck,Component deserializeOnto,Component target,EntityData.Component componentData,FieldSerializeCheck<Component> fieldCheck,Module context,Component deserializeOnto,Component targetComponent,EntityData.Component componentData,ComponentMetadata<T> componentMetadata,FieldSerializeCheck<Component> fieldCheck){\r\n    Serializer serializer = typeSerializationLibrary.getSerializerFor(componentMetadata);\r\n    DeserializationContext context = new ProtobufDeserializationContext(typeSerializationLibrary);\r\n    Map<FieldMetadata<?, ?>, PersistedData> dataMap = Maps.newHashMapWithExpectedSize(componentData.getFieldCount());\r\n    for (EntityData.NameValue field : componentData.getFieldList()) {\r\n        FieldMetadata<?, ?> fieldInfo = null;\r\n        if (field.hasNameIndex()) {\r\n            fieldInfo = componentMetadata.getField(field.getNameIndex());\r\n        } else if (field.hasName()) {\r\n            fieldInfo = componentMetadata.getField(field.getName());\r\n        }\r\n        if (fieldInfo != null) {\r\n            dataMap.put(fieldInfo, new ProtobufPersistedData(field.getValue()));\r\n        } else if (field.hasName()) {\r\n            logger.warn(\"Cannot deserialize unknown field '{}' onto '{}'\", field.getName(), componentMetadata.getUri());\r\n        }\r\n    }\r\n    serializer.deserializeOnto(targetComponent, dataMap, context, fieldCheck);\r\n    return targetComponent;\r\n}"
}, {
	"Path": "springfox.documentation.spring.web.plugins.Docket.enable",
	"Comment": "hook to externally control auto initialization of this swagger plugin instance.typically used if defer initialization.",
	"Method": "Docket enable(boolean externallyConfiguredFlag){\r\n    this.enabled = externallyConfiguredFlag;\r\n    return this;\r\n}"
}, {
	"Path": "org.terasology.logic.players.LocalPlayerSystem.startAutoMove",
	"Comment": "append the input for moving forward to the keyboard command queue to simulate pressing of the forward key.for an input that repeats, the key must be in down state before repeat state can be applied to it.",
	"Method": "void startAutoMove(){\r\n    isAutoMove = false;\r\n    List<Input> inputs = bindsManager.getBindsConfig().getBinds(new SimpleUri(\"engine:forwards\"));\r\n    Input forwardKey = getValidKey(inputs);\r\n    if (forwardKey != null) {\r\n        isAutoMove = true;\r\n        inputSystem.simulateSingleKeyStroke(forwardKey);\r\n        inputSystem.simulateRepeatedKeyStroke(forwardKey);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.ldap.LdapUtils.getFullDn",
	"Comment": "gets the full dn of a name by prepending the name of the context it is relative to.\tif the name already contains the base name, it is returned unaltered.",
	"Method": "DistinguishedName getFullDn(DistinguishedName dn,Context baseCtx){\r\n    DistinguishedName baseDn = new DistinguishedName(baseCtx.getNameInNamespace());\r\n    if (dn.contains(baseDn)) {\r\n        return dn;\r\n    }\r\n    baseDn.append(dn);\r\n    return baseDn;\r\n}"
}, {
	"Path": "org.terasology.entitySystem.entity.internal.PojoEntityPool.destroyEntityWithoutEvents",
	"Comment": "destroys the entity without sending any events. the entity life cycle subscriber will however be informed.",
	"Method": "void destroyEntityWithoutEvents(EntityRef entity){\r\n    if (entity.isActive()) {\r\n        entityManager.notifyComponentRemovalAndEntityDestruction(entity.getId(), entity);\r\n        destroy(entity);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.crypto.password.Md4PasswordEncoder.matches",
	"Comment": "takes a previously encoded password and compares it with a rawpassword after mixing\tin the salt and encoding that value",
	"Method": "boolean matches(CharSequence rawPassword,String encodedPassword){\r\n    String salt = extractSalt(encodedPassword);\r\n    String rawPasswordEncoded = digest(salt, rawPassword);\r\n    return PasswordEncoderUtils.equals(encodedPassword.toString(), rawPasswordEncoded);\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.layers.mainMenu.NameRecordingScreen.doesRecordingExist",
	"Comment": "tests if there is an existing recording with the provided name string.",
	"Method": "boolean doesRecordingExist(String name){\r\n    Path destinationPath = PathManager.getInstance().getRecordingPath(name);\r\n    return FileUtils.fileExists(destinationPath.toString());\r\n}"
}, {
	"Path": "org.terasology.rendering.opengl.AbstractFBOsManager.get",
	"Comment": "returns an fbo given its name.if no fbo maps to the given name, null is returned and an error is logged.",
	"Method": "FBO get(SimpleUri fboName){\r\n    FBO fbo = fboLookup.get(fboName);\r\n    if (fbo == null) {\r\n        logger.warn(\"Failed to retrieve FBO '\" + fboName + \"'!\");\r\n    }\r\n    return fbo;\r\n}"
}, {
	"Path": "org.springframework.security.provisioning.JdbcUserDetailsManager.setUserCache",
	"Comment": "optionally sets the usercache if one is in use in the application. this allows the\tuser to be removed from the cache after updates have taken place to avoid stale\tdata.",
	"Method": "void setUserCache(UserCache userCache){\r\n    Assert.notNull(userCache, \"userCache cannot be null\");\r\n    this.userCache = userCache;\r\n}"
}, {
	"Path": "org.terasology.engine.paths.PathManager.findNativesHome",
	"Comment": "searches for a parent directory containing the natives directory",
	"Method": "Path findNativesHome(Path startPath,int maxDepth){\r\n    int levelsToSearch = maxDepth;\r\n    Path checkedPath = startPath;\r\n    while (levelsToSearch > 0) {\r\n        File dirToTest = new File(checkedPath.toFile(), NATIVES_DIR);\r\n        if (dirToTest.exists()) {\r\n            System.out.println(\"Found the natives dir: \" + dirToTest);\r\n            return checkedPath;\r\n        }\r\n        checkedPath = checkedPath.getParent();\r\n        if (checkedPath.equals(startPath.getRoot())) {\r\n            System.out.println(\"Uh oh, reached the root path, giving up\");\r\n            return null;\r\n        }\r\n        levelsToSearch--;\r\n    }\r\n    System.out.println(\"Failed to find the natives dir within \" + maxDepth + \" levels of \" + startPath);\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.security.config.doc.SpringSecurityXsdParser.elements",
	"Comment": "creates a map of the name to an element object of all the children of element.",
	"Method": "Map<String, Element> elements(XmlNode node){\r\n    Map<String, Element> elementNameToElement = new HashMap();\r\n    node.children().forEach(child -> {\r\n        if (\"element\".equals(child.simpleName())) {\r\n            Element e = elmt(child);\r\n            elementNameToElement.put(e.getName(), e);\r\n        } else {\r\n            elementNameToElement.putAll(elements(child));\r\n        }\r\n    });\r\n    return elementNameToElement;\r\n}"
}, {
	"Path": "org.springframework.security.web.server.DelegatingServerAuthenticationEntryPoint.setDefaultEntryPoint",
	"Comment": "entrypoint which is used when no requestmatcher returned true",
	"Method": "void setDefaultEntryPoint(ServerAuthenticationEntryPoint defaultEntryPoint){\r\n    this.defaultEntryPoint = defaultEntryPoint;\r\n}"
}, {
	"Path": "org.terasology.network.internal.ClientConnectionHandler.receiveModule",
	"Comment": "converts the modules data to a byte array and writes it to a file, which then is copied from the temp directory to the correct directory.",
	"Method": "void receiveModule(ChannelHandlerContext channelHandlerContext,NetData.ModuleData moduleData){\r\n    if (receivingModule == null) {\r\n        joinStatus.setErrorMessage(\"Module download error\");\r\n        channelHandlerContext.getChannel().close();\r\n        return;\r\n    }\r\n    try {\r\n        downloadingModule.write(moduleData.getModule().toByteArray());\r\n        lengthReceived += moduleData.getModule().size();\r\n        joinStatus.setCurrentProgress((float) lengthReceived / receivingModule.getSize());\r\n        if (lengthReceived == receivingModule.getSize()) {\r\n            downloadingModule.close();\r\n            String moduleName = String.format(\"%s-%s.jar\", receivingModule.getId(), receivingModule.getVersion());\r\n            Path finalPath = PathManager.getInstance().getHomeModPath().normalize().resolve(moduleName);\r\n            if (finalPath.normalize().startsWith(PathManager.getInstance().getHomeModPath())) {\r\n                if (Files.exists(finalPath)) {\r\n                    logger.error(\"File already exists at {}\", finalPath);\r\n                    joinStatus.setErrorMessage(\"Module download error\");\r\n                    channelHandlerContext.getChannel().close();\r\n                    return;\r\n                }\r\n                Files.copy(tempModuleLocation, finalPath);\r\n                ModuleLoader loader = new ModuleLoader(moduleManager.getModuleMetadataReader());\r\n                loader.setModuleInfoPath(TerasologyConstants.MODULE_INFO_FILENAME);\r\n                moduleManager.getRegistry().add(loader.load(finalPath));\r\n                receivingModule = null;\r\n                if (missingModules.isEmpty()) {\r\n                    sendJoin(channelHandlerContext);\r\n                }\r\n            } else {\r\n                logger.error(\"Module rejected\");\r\n                joinStatus.setErrorMessage(\"Module download error\");\r\n                channelHandlerContext.getChannel().close();\r\n            }\r\n        }\r\n    } catch (IOException e) {\r\n        logger.error(\"Error saving module\", e);\r\n        joinStatus.setErrorMessage(\"Module download error\");\r\n        channelHandlerContext.getChannel().close();\r\n    }\r\n}"
}, {
	"Path": "org.terasology.utilities.collection.CharSequenceIterator.next",
	"Comment": "the method nextchar is preferred over this one, as it does not create a wrapper for the primitive",
	"Method": "Character next(){\r\n    return nextChar();\r\n}"
}, {
	"Path": "org.springframework.security.jackson2.SecurityJackson2Modules.createWhitelistedDefaultTyping",
	"Comment": "creates a typeresolverbuilder that performs whitelisting.",
	"Method": "TypeResolverBuilder<? extends TypeResolverBuilder> createWhitelistedDefaultTyping(){\r\n    TypeResolverBuilder<? extends TypeResolverBuilder> result = new WhitelistTypeResolverBuilder(ObjectMapper.DefaultTyping.NON_FINAL);\r\n    result = result.init(JsonTypeInfo.Id.CLASS, null);\r\n    result = result.inclusion(JsonTypeInfo.As.PROPERTY);\r\n    return result;\r\n}"
}, {
	"Path": "org.terasology.persistence.typeHandling.Serializer.serializeValue",
	"Comment": "serializes the given value, that was originally obtained from the given field.this is provided for performance, to avoid obtaining the same value twice.",
	"Method": "PersistedData serializeValue(FieldMetadata<?, ?> fieldMetadata,Object rawValue,SerializationContext context){\r\n    return fieldHandlers.get(fieldMetadata).serialize(rawValue, context);\r\n}"
}, {
	"Path": "org.terasology.logic.players.LocalPlayerSystem.stopAutoMove",
	"Comment": "auto move is disabled when the associated key is pressed again.this cancels the simulated repeated key stroke for the forward input button.",
	"Method": "void stopAutoMove(){\r\n    List<Input> inputs = bindsManager.getBindsConfig().getBinds(new SimpleUri(\"engine:forwards\"));\r\n    Input forwardKey = getValidKey(inputs);\r\n    if (forwardKey != null) {\r\n        inputSystem.cancelSimulatedKeyStroke(forwardKey);\r\n        isAutoMove = false;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.switchuser.SwitchUserFilter.setUsernameParameter",
	"Comment": "allows the parameter containing the username to be customized.",
	"Method": "void setUsernameParameter(String usernameParameter){\r\n    this.usernameParameter = usernameParameter;\r\n}"
}, {
	"Path": "org.springframework.security.ldap.SpringSecurityLdapTemplate.compare",
	"Comment": "performs an ldap compare operation of the value of an attribute for a particular\tdirectory entry.",
	"Method": "boolean compare(String dn,String attributeName,Object value){\r\n    final String comparisonFilter = \"(\" + attributeName + \"={0})\";\r\n    class LdapCompareCallback implements ContextExecutor {\r\n        public Object executeWithContext(DirContext ctx) throws NamingException {\r\n            SearchControls ctls = new SearchControls();\r\n            ctls.setReturningAttributes(NO_ATTRS);\r\n            ctls.setSearchScope(SearchControls.OBJECT_SCOPE);\r\n            NamingEnumeration<SearchResult> results = ctx.search(dn, comparisonFilter, new Object[] { value }, ctls);\r\n            Boolean match = Boolean.valueOf(results.hasMore());\r\n            LdapUtils.closeEnumeration(results);\r\n            return match;\r\n        }\r\n    }\r\n    Boolean matches = (Boolean) executeReadOnly(new LdapCompareCallback());\r\n    return matches.booleanValue();\r\n}"
}, {
	"Path": "org.springframework.security.ldap.SpringSecurityLdapTemplate.compare",
	"Comment": "performs an ldap compare operation of the value of an attribute for a particular\tdirectory entry.",
	"Method": "boolean compare(String dn,String attributeName,Object value){\r\n    SearchControls ctls = new SearchControls();\r\n    ctls.setReturningAttributes(NO_ATTRS);\r\n    ctls.setSearchScope(SearchControls.OBJECT_SCOPE);\r\n    NamingEnumeration<SearchResult> results = ctx.search(dn, comparisonFilter, new Object[] { value }, ctls);\r\n    Boolean match = Boolean.valueOf(results.hasMore());\r\n    LdapUtils.closeEnumeration(results);\r\n    return match;\r\n}"
}, {
	"Path": "org.springframework.security.core.authority.mapping.SimpleAuthorityMapper.setConvertToLowerCase",
	"Comment": "whether to convert the authority value to lower case in the mapping.",
	"Method": "void setConvertToLowerCase(boolean convertToLowerCase){\r\n    this.convertToLowerCase = convertToLowerCase;\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter.setUsernameParameter",
	"Comment": "sets the parameter name which will be used to obtain the username from the login\trequest.",
	"Method": "void setUsernameParameter(String usernameParameter){\r\n    Assert.hasText(usernameParameter, \"Username parameter must not be empty or null\");\r\n    this.usernameParameter = usernameParameter;\r\n}"
}, {
	"Path": "org.terasology.persistence.serializers.PrefabSerializer.setComponentIdMapping",
	"Comment": "sets the mapping between component classes and the ids that are used for serialization",
	"Method": "void setComponentIdMapping(Map<Class<? extends Component>, Integer> table){\r\n    componentSerializer.setIdMapping(table);\r\n}"
}, {
	"Path": "org.terasology.logic.ai.AICommands.destroyAI",
	"Comment": "destroys all entities with attached simpleaicomponent or hierarchicalaicomponent in the world",
	"Method": "String destroyAI(){\r\n    int simpleAI = 0;\r\n    for (EntityRef ref : entityManager.getEntitiesWith(SimpleAIComponent.class)) {\r\n        ref.destroy();\r\n        simpleAI++;\r\n    }\r\n    int hierarchicalAI = 0;\r\n    for (EntityRef ref : entityManager.getEntitiesWith(HierarchicalAIComponent.class)) {\r\n        ref.destroy();\r\n        hierarchicalAI++;\r\n    }\r\n    return \"Simple AIs (\" + simpleAI + \") Destroyed, Hierarchical AIs (\" + hierarchicalAI + \") Destroyed \";\r\n}"
}, {
	"Path": "org.terasology.utilities.tree.SpaceTree.addToNode",
	"Comment": "a method used to add a node with a value to another existing node.",
	"Method": "T addToNode(float[] position,Node node,T value){\r\n    Node processedNode = node;\r\n    while (true) {\r\n        if (processedNode.center != null) {\r\n            int subNodeIndex = getSubNodeIndex(position, processedNode.center);\r\n            if (subNodeIndex == -1) {\r\n                T oldValue = processedNode.centerValue;\r\n                processedNode.centerValue = value;\r\n                return oldValue;\r\n            } else {\r\n                Node subNode = processedNode.subNodes[subNodeIndex];\r\n                if (subNode == null) {\r\n                    float[] min = new float[dimensions];\r\n                    float[] max = new float[dimensions];\r\n                    for (int i = 0; i < dimensions; i++) {\r\n                        if (position[i] > processedNode.center[i]) {\r\n                            min[i] = processedNode.center[i];\r\n                            max[i] = processedNode.maxValues[i];\r\n                        } else {\r\n                            min[i] = processedNode.minValues[i];\r\n                            max[i] = processedNode.center[i];\r\n                        }\r\n                    }\r\n                    processedNode.subNodes[subNodeIndex] = createNewNode(position, min, max, value);\r\n                    return null;\r\n                } else {\r\n                    processedNode = subNode;\r\n                }\r\n            }\r\n        } else {\r\n            for (NodeEntry<T> nodeEntry : processedNode.nodeBucket) {\r\n                if (distanceFunction.getDistance(nodeEntry.position, position) == 0) {\r\n                    processedNode.nodeBucket.remove(nodeEntry);\r\n                    processedNode.nodeBucket.add(new NodeEntry(position, value));\r\n                    return nodeEntry.value;\r\n                }\r\n            }\r\n            processedNode.nodeBucket.add(new NodeEntry(position, value));\r\n            if (processedNode.nodeBucket.size() > bucketSize) {\r\n                processedNode.splitNode();\r\n            }\r\n            return null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.session.ConcurrentSessionControlAuthenticationStrategy.onAuthentication",
	"Comment": "in addition to the steps from the superclass, the sessionregistry will be updated\twith the new session information.",
	"Method": "void onAuthentication(Authentication authentication,HttpServletRequest request,HttpServletResponse response){\r\n    final List<SessionInformation> sessions = sessionRegistry.getAllSessions(authentication.getPrincipal(), false);\r\n    int sessionCount = sessions.size();\r\n    int allowedSessions = getMaximumSessionsForThisUser(authentication);\r\n    if (sessionCount < allowedSessions) {\r\n        return;\r\n    }\r\n    if (allowedSessions == -1) {\r\n        return;\r\n    }\r\n    if (sessionCount == allowedSessions) {\r\n        HttpSession session = request.getSession(false);\r\n        if (session != null) {\r\n            for (SessionInformation si : sessions) {\r\n                if (si.getSessionId().equals(session.getId())) {\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    allowableSessionsExceeded(sessions, allowedSessions, sessionRegistry);\r\n}"
}, {
	"Path": "org.springframework.security.web.savedrequest.Enumerator.nextElement",
	"Comment": "returns the next element of this enumeration if this enumeration has at least one\tmore element to provide.",
	"Method": "T nextElement(){\r\n    return (iterator.next());\r\n}"
}, {
	"Path": "org.terasology.documentation.apiScraper.ApiComparator.checkMethodIncrease",
	"Comment": "compares a not overloaded method in the newapi and originalapi to notify parameter type, return type orexception type changes.",
	"Method": "void checkMethodIncrease(ApiMethod method1,ApiMethod method2){\r\n    check(method1.getReturnType(), method2.getReturnType(), method1.getName(), method1.getClassName());\r\n    check(method1.getParametersType(), method2.getParametersType(), method1.getName(), method1.getClassName());\r\n    check(method1.getExceptionType(), method2.getExceptionType(), method1.getName(), method1.getClassName());\r\n}"
}, {
	"Path": "org.springframework.security.web.server.savedrequest.WebSessionServerRequestCache.setSaveRequestMatcher",
	"Comment": "sets the matcher to determine if the request should be saved. the default is to match\ton any get request.",
	"Method": "void setSaveRequestMatcher(ServerWebExchangeMatcher saveRequestMatcher){\r\n    Assert.notNull(saveRequestMatcher, \"saveRequestMatcher cannot be null\");\r\n    this.saveRequestMatcher = saveRequestMatcher;\r\n}"
}, {
	"Path": "org.terasology.input.InputSystem.processControllerButtonInput",
	"Comment": "processes input actions by controller buttons, and updates bind buttons accordingly.",
	"Method": "void processControllerButtonInput(float delta,ControllerAction action,boolean consumed,Input input){\r\n    BindableButton bind = bindsManager.getControllerBinds().get(input);\r\n    if (bind != null) {\r\n        boolean pressed = action.getState() == ButtonState.DOWN;\r\n        updateBindState(bind, input, pressed, delta, consumed);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.authentication.jaas.AbstractJaasAuthenticationProvider.setAuthorityGranters",
	"Comment": "set the authoritygranters that should be consulted for role names to be granted to\tthe authentication.",
	"Method": "void setAuthorityGranters(AuthorityGranter[] authorityGranters){\r\n    this.authorityGranters = authorityGranters;\r\n}"
}, {
	"Path": "org.springframework.security.web.savedrequest.DefaultSavedRequest.getRedirectUrl",
	"Comment": "indicates the url that the user agent used for this request.",
	"Method": "String getRedirectUrl(){\r\n    return UrlUtils.buildFullRequestUrl(scheme, serverName, serverPort, requestURI, queryString);\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.preauth.header.RequestHeaderAuthenticationFilterTests.createAuthenticationManager",
	"Comment": "create an authentication manager which returns the passed in object.",
	"Method": "AuthenticationManager createAuthenticationManager(){\r\n    AuthenticationManager am = mock(AuthenticationManager.class);\r\n    when(am.authenticate(any(Authentication.class))).thenAnswer(new Answer<Authentication>() {\r\n        public Authentication answer(InvocationOnMock invocation) throws Throwable {\r\n            return (Authentication) invocation.getArguments()[0];\r\n        }\r\n    });\r\n    return am;\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.preauth.header.RequestHeaderAuthenticationFilterTests.createAuthenticationManager",
	"Comment": "create an authentication manager which returns the passed in object.",
	"Method": "AuthenticationManager createAuthenticationManager(){\r\n    return (Authentication) invocation.getArguments()[0];\r\n}"
}, {
	"Path": "org.springframework.security.web.util.ThrowableAnalyzer.extractCause",
	"Comment": "extracts the cause of the given throwable using an appropriate extractor.",
	"Method": "Throwable extractCause(Throwable throwable){\r\n    for (Map.Entry<Class<? extends Throwable>, ThrowableCauseExtractor> entry : extractorMap.entrySet()) {\r\n        Class<? extends Throwable> throwableType = entry.getKey();\r\n        if (throwableType.isInstance(throwable)) {\r\n            ThrowableCauseExtractor extractor = entry.getValue();\r\n            return extractor.extractCause(throwable);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.terasology.world.internal.EntityAwareWorldProvider.updateBlockEntityComponents",
	"Comment": "transforms a block entity with the change of block type. this is driven from the delta between the old and newblock type prefabs, but takes into account changes made to the block entity.",
	"Method": "void updateBlockEntityComponents(EntityRef blockEntity,Block oldType,Block type,Set<Class<? extends Component>> retainComponents){\r\n    BlockComponent blockComponent = blockEntity.getComponent(BlockComponent.class);\r\n    Optional<Prefab> oldPrefab = oldType.getPrefab();\r\n    EntityBuilder oldEntityBuilder = entityManager.newBuilder(oldPrefab.orElse(null));\r\n    oldEntityBuilder.addComponent(new BlockComponent(oldType, blockComponent.position));\r\n    BeforeEntityCreated oldEntityEvent = new BeforeEntityCreated(oldPrefab.orElse(null), oldEntityBuilder.iterateComponents());\r\n    blockEntity.send(oldEntityEvent);\r\n    for (Component comp : oldEntityEvent.getResultComponents()) {\r\n        oldEntityBuilder.addComponent(comp);\r\n    }\r\n    Optional<Prefab> newPrefab = type.getPrefab();\r\n    EntityBuilder newEntityBuilder = entityManager.newBuilder(newPrefab.orElse(null));\r\n    newEntityBuilder.addComponent(new BlockComponent(type, blockComponent.position));\r\n    BeforeEntityCreated newEntityEvent = new BeforeEntityCreated(newPrefab.orElse(null), newEntityBuilder.iterateComponents());\r\n    blockEntity.send(newEntityEvent);\r\n    for (Component comp : newEntityEvent.getResultComponents()) {\r\n        newEntityBuilder.addComponent(comp);\r\n    }\r\n    for (Component component : blockEntity.iterateComponents()) {\r\n        if (!COMMON_BLOCK_COMPONENTS.contains(component.getClass()) && !entityManager.getComponentLibrary().getMetadata(component.getClass()).isRetainUnalteredOnBlockChange() && !newEntityBuilder.hasComponent(component.getClass()) && !retainComponents.contains(component.getClass())) {\r\n            blockEntity.removeComponent(component.getClass());\r\n        }\r\n    }\r\n    blockComponent.block = type;\r\n    blockEntity.saveComponent(blockComponent);\r\n    for (Component comp : newEntityBuilder.iterateComponents()) {\r\n        copyIntoPrefab(blockEntity, comp, retainComponents);\r\n    }\r\n}"
}, {
	"Path": "springfox.documentation.builders.ParameterBuilder.allowEmptyValue",
	"Comment": "updates the flag that allows sending empty values for this parameter",
	"Method": "ParameterBuilder allowEmptyValue(Boolean allowEmptyValue){\r\n    this.allowEmptyValue = defaultIfAbsent(allowEmptyValue, this.allowEmptyValue);\r\n    return this;\r\n}"
}, {
	"Path": "org.terasology.physics.HitResult.isWorldHit",
	"Comment": "returns true if the hit has hit the world, rather than an entity.",
	"Method": "boolean isWorldHit(){\r\n    return worldHit;\r\n}"
}, {
	"Path": "org.terasology.config.flexible.validators.RangedNumberValidator.getMin",
	"Comment": "returns the minimum value in the range. a null value signifies the absence of any minimum value.",
	"Method": "T getMin(){\r\n    return min;\r\n}"
}, {
	"Path": "org.springframework.security.core.authority.mapping.SimpleAttributes2GrantedAuthoritiesMapper.afterPropertiesSet",
	"Comment": "check whether all properties have been set to correct values.",
	"Method": "void afterPropertiesSet(){\r\n    Assert.isTrue(!(isConvertAttributeToUpperCase() && isConvertAttributeToLowerCase()), \"Either convertAttributeToUpperCase or convertAttributeToLowerCase can be set to true, but not both\");\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.switchuser.SwitchUserFilter.attemptSwitchUser",
	"Comment": "attempt to switch to another user. if the user does not exist or is not active,\treturn null.",
	"Method": "Authentication attemptSwitchUser(HttpServletRequest request){\r\n    UsernamePasswordAuthenticationToken targetUserRequest;\r\n    String username = request.getParameter(this.usernameParameter);\r\n    if (username == null) {\r\n        username = \"\";\r\n    }\r\n    if (this.logger.isDebugEnabled()) {\r\n        this.logger.debug(\"Attempt to switch to user [\" + username + \"]\");\r\n    }\r\n    UserDetails targetUser = this.userDetailsService.loadUserByUsername(username);\r\n    this.userDetailsChecker.check(targetUser);\r\n    targetUserRequest = createSwitchUserToken(request, targetUser);\r\n    if (this.logger.isDebugEnabled()) {\r\n        this.logger.debug(\"Switch User Token [\" + targetUserRequest + \"]\");\r\n    }\r\n    if (this.eventPublisher != null) {\r\n        this.eventPublisher.publishEvent(new AuthenticationSwitchUserEvent(SecurityContextHolder.getContext().getAuthentication(), targetUser));\r\n    }\r\n    return targetUserRequest;\r\n}"
}, {
	"Path": "org.terasology.audio.formats.OggReader.fillConvbuffer",
	"Comment": "helper function. decodes a packet to the convbuffer if it is empty.updates convbuffersize, convbufferoff, and eos.",
	"Method": "void fillConvbuffer(){\r\n    if (convbufferOff >= convbufferSize) {\r\n        convbufferSize = lazyDecodePacket();\r\n        convbufferOff = 0;\r\n        if (convbufferSize == -1) {\r\n            eos = true;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.web.util.UrlUtils.isAbsoluteUrl",
	"Comment": "decides if a url is absolute based on whether it contains a valid scheme name, as\tdefined in rfc 1738.",
	"Method": "boolean isAbsoluteUrl(String url){\r\n    if (url == null) {\r\n        return false;\r\n    }\r\n    final Pattern ABSOLUTE_URL = Pattern.compile(\"\\\\A[a-z0-9.+-]+://.*\", Pattern.CASE_INSENSITIVE);\r\n    return ABSOLUTE_URL.matcher(url).matches();\r\n}"
}, {
	"Path": "org.springframework.security.remoting.httpinvoker.AuthenticationSimpleHttpInvokerRequestExecutor.prepareConnection",
	"Comment": "called every time a http invocation is made.\tsimply allows the parent to setup the connection, and then adds an\tauthorization http header property that will be used for basic\tauthentication.\tthe securitycontextholder is used to obtain the relevant principal and\tcredentials.",
	"Method": "void prepareConnection(HttpURLConnection con,int contentLength){\r\n    super.prepareConnection(con, contentLength);\r\n    Authentication auth = SecurityContextHolder.getContext().getAuthentication();\r\n    if ((auth != null) && (auth.getName() != null) && (auth.getCredentials() != null) && !trustResolver.isAnonymous(auth)) {\r\n        String base64 = auth.getName() + \":\" + auth.getCredentials().toString();\r\n        con.setRequestProperty(\"Authorization\", \"Basic \" + new String(Base64.getEncoder().encode(base64.getBytes())));\r\n        if (logger.isDebugEnabled()) {\r\n            logger.debug(\"HttpInvocation now presenting via BASIC authentication SecurityContextHolder-derived: \" + auth.toString());\r\n        }\r\n    } else {\r\n        if (logger.isDebugEnabled()) {\r\n            logger.debug(\"Unable to set BASIC authentication header as SecurityContext did not provide \" + \"valid Authentication: \" + auth);\r\n        }\r\n    }\r\n    doPrepareConnection(con, contentLength);\r\n}"
}, {
	"Path": "org.springframework.security.access.intercept.AfterInvocationProviderManager.supports",
	"Comment": "iterates through all afterinvocationproviders and ensures each can\tsupport the presented class.\tif one or more providers cannot support the presented class, false is\treturned.",
	"Method": "boolean supports(ConfigAttribute attribute,boolean supports,Class<?> clazz){\r\n    for (AfterInvocationProvider provider : providers) {\r\n        if (!provider.supports(clazz)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.springframework.security.core.authority.mapping.MapBasedAttributes2GrantedAuthoritiesMapper.getGrantedAuthorityCollection",
	"Comment": "convert the given value to a collection of granted authorities",
	"Method": "Collection<GrantedAuthority> getGrantedAuthorityCollection(Object value){\r\n    Collection<GrantedAuthority> result = new ArrayList();\r\n    addGrantedAuthorityCollection(result, value);\r\n    return result;\r\n}"
}, {
	"Path": "org.terasology.recording.EventSystemReplayImpl.shouldAddToLibrary",
	"Comment": "events are added to the event library if they have a network annotation",
	"Method": "boolean shouldAddToLibrary(Class<? extends Event> eventType){\r\n    return eventType.getAnnotation(ServerEvent.class) != null || eventType.getAnnotation(OwnerEvent.class) != null || eventType.getAnnotation(BroadcastEvent.class) != null;\r\n}"
}, {
	"Path": "org.terasology.logic.players.ThirdPersonRemoteClientSystem.linkHeldItemLocationForRemotePlayer",
	"Comment": "changes held item entity.detaches old held item and removes its components. adds components to new held item andattaches it to the mount point entity.",
	"Method": "void linkHeldItemLocationForRemotePlayer(EntityRef newItem,EntityRef player){\r\n    if (relatesToLocalPlayer(player)) {\r\n        logger.debug(\"linkHeldItemLocationForRemotePlayer called with an entity that relates to the local player, ignoring{}\", player);\r\n        return;\r\n    }\r\n    EntityRef currentHeldItem = EntityRef.NULL;\r\n    for (EntityRef heldItemCandidate : entityManager.getEntitiesWith(ItemIsRemotelyHeldComponent.class)) {\r\n        EntityRef remotePlayerCandidate = heldItemCandidate.getComponent(ItemIsRemotelyHeldComponent.class).remotePlayer;\r\n        logger.debug(\"For held item candidate {} got its player candidate as {}\", heldItemCandidate, remotePlayerCandidate);\r\n        if (remotePlayerCandidate.equals(player)) {\r\n            logger.debug(\"Thinking we found a match with player {} so counting this held item as relevant for processing\", player);\r\n            currentHeldItem = heldItemCandidate;\r\n            if (newItem.equals(EntityRef.NULL)) {\r\n                logger.debug(\"Found an existing held item but the new request was to no longer hold anything so destroying {}\", currentHeldItem);\r\n                currentHeldItem.destroy();\r\n                return;\r\n            }\r\n            break;\r\n        }\r\n    }\r\n    if (newItem != null && !newItem.equals(EntityRef.NULL) && !newItem.equals(currentHeldItem)) {\r\n        RemotePersonHeldItemMountPointComponent mountPointComponent = player.getComponent(RemotePersonHeldItemMountPointComponent.class);\r\n        if (mountPointComponent != null) {\r\n            if (currentHeldItem != EntityRef.NULL) {\r\n                currentHeldItem.destroy();\r\n            }\r\n            currentHeldItem = entityManager.create();\r\n            logger.debug(\"linkHeldItemLocationForRemotePlayer is now creating a new held item {}\", currentHeldItem);\r\n            for (Component component : newItem.iterateComponents()) {\r\n                if (component instanceof VisualComponent && !(component instanceof FirstPersonHeldItemTransformComponent)) {\r\n                    currentHeldItem.addComponent(component);\r\n                }\r\n            }\r\n            currentHeldItem.addComponent(new LocationComponent());\r\n            ItemIsRemotelyHeldComponent itemIsRemotelyHeldComponent = new ItemIsRemotelyHeldComponent();\r\n            itemIsRemotelyHeldComponent.remotePlayer = player;\r\n            currentHeldItem.addComponent(itemIsRemotelyHeldComponent);\r\n            RemotePersonHeldItemTransformComponent heldItemTransformComponent = currentHeldItem.getComponent(RemotePersonHeldItemTransformComponent.class);\r\n            if (heldItemTransformComponent == null) {\r\n                heldItemTransformComponent = new RemotePersonHeldItemTransformComponent();\r\n                currentHeldItem.addComponent(heldItemTransformComponent);\r\n            }\r\n            Location.attachChild(mountPointComponent.mountPointEntity, currentHeldItem, heldItemTransformComponent.translate, new Quat4f(TeraMath.DEG_TO_RAD * heldItemTransformComponent.rotateDegrees.y, TeraMath.DEG_TO_RAD * heldItemTransformComponent.rotateDegrees.x, TeraMath.DEG_TO_RAD * heldItemTransformComponent.rotateDegrees.z), heldItemTransformComponent.scale);\r\n        }\r\n    } else {\r\n        logger.info(\"Somehow ended up in the else during linkHeldItemLocationForRemotePlayer - current item was {} and new item {}\", currentHeldItem, newItem);\r\n    }\r\n}"
}, {
	"Path": "org.terasology.utilities.tree.SpaceTree.addAllFromNode",
	"Comment": "if nodetoaddfrom is not null, then the nodetoaddfrom will be added to the nodetoaddto.",
	"Method": "void addAllFromNode(Node nodeToAddFrom,Node nodeToAddTo){\r\n    if (nodeToAddFrom != null) {\r\n        if (nodeToAddTo == null) {\r\n            add(nodeToAddFrom.center, nodeToAddFrom.centerValue);\r\n        } else {\r\n            addToNode(nodeToAddFrom.center, nodeToAddTo, nodeToAddFrom.centerValue);\r\n        }\r\n        for (Node subNode : nodeToAddFrom.subNodes) {\r\n            addAllFromNode(subNode, nodeToAddTo);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.terasology.world.biomes.BiomeManager.getBiomeById",
	"Comment": "returns a biome with the given id and of the given biome type, only if the biome actually is of the given type.",
	"Method": "Biome getBiomeById(String id,T getBiomeById,String id,Class<T> biomeClass){\r\n    Biome biome = getBiomeById(id);\r\n    if (biome != null) {\r\n        if (biomeClass.isAssignableFrom(biome.getClass())) {\r\n            return biomeClass.cast(biome);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.rememberme.AbstractRememberMeServices.autoLogin",
	"Comment": "template implementation which locates the spring security cookie, decodes it into a\tdelimited array of tokens and submits it to subclasses for processing via the\tprocessautologincookie method.\tthe returned username is then used to load the userdetails object for the user,\twhich in turn is used to create a valid authentication token.",
	"Method": "Authentication autoLogin(HttpServletRequest request,HttpServletResponse response){\r\n    String rememberMeCookie = extractRememberMeCookie(request);\r\n    if (rememberMeCookie == null) {\r\n        return null;\r\n    }\r\n    logger.debug(\"Remember-me cookie detected\");\r\n    if (rememberMeCookie.length() == 0) {\r\n        logger.debug(\"Cookie was empty\");\r\n        cancelCookie(request, response);\r\n        return null;\r\n    }\r\n    UserDetails user = null;\r\n    try {\r\n        String[] cookieTokens = decodeCookie(rememberMeCookie);\r\n        user = processAutoLoginCookie(cookieTokens, request, response);\r\n        userDetailsChecker.check(user);\r\n        logger.debug(\"Remember-me cookie accepted\");\r\n        return createSuccessfulAuthentication(request, user);\r\n    } catch (CookieTheftException cte) {\r\n        cancelCookie(request, response);\r\n        throw cte;\r\n    } catch (UsernameNotFoundException noUser) {\r\n        logger.debug(\"Remember-me login was valid but corresponding user not found.\", noUser);\r\n    } catch (InvalidCookieException invalidCookie) {\r\n        logger.debug(\"Invalid remember-me cookie: \" + invalidCookie.getMessage());\r\n    } catch (AccountStatusException statusInvalid) {\r\n        logger.debug(\"Invalid UserDetails: \" + statusInvalid.getMessage());\r\n    } catch (RememberMeAuthenticationException e) {\r\n        logger.debug(e.getMessage());\r\n    }\r\n    cancelCookie(request, response);\r\n    return null;\r\n}"
}, {
	"Path": "org.terasology.network.internal.AbstractClient.createEntity",
	"Comment": "creates an entity for the client connection, checking if name and color options can be used.",
	"Method": "void createEntity(String preferredName,Color color,EntityManager entityManager){\r\n    clientEntity = entityManager.create(\"engine:client\");\r\n    EntityRef clientInfo = findClientEntityRef(entityManager);\r\n    if (!clientInfo.exists()) {\r\n        clientInfo = createClientInfoEntity(entityManager);\r\n    }\r\n    ClientInfoComponent clientInfoComp = clientInfo.getComponent(ClientInfoComponent.class);\r\n    clientInfoComp.client = clientEntity;\r\n    clientInfo.saveComponent(clientInfoComp);\r\n    ClientComponent clientComponent = clientEntity.getComponent(ClientComponent.class);\r\n    clientComponent.clientInfo = clientInfo;\r\n    clientEntity.saveComponent(clientComponent);\r\n    addOrSetColorComponent(clientInfo, color);\r\n    DisplayNameComponent displayNameComponent = clientInfo.getComponent(DisplayNameComponent.class);\r\n    if (displayNameComponent == null || !displayNameComponent.name.equals(preferredName)) {\r\n        String bestAvailableName = findUniquePlayerName(preferredName, entityManager, clientInfo);\r\n        addOrSetDisplayNameComponent(clientInfo, bestAvailableName);\r\n    }\r\n}"
}, {
	"Path": "org.terasology.rendering.dag.AbstractNode.getMaterial",
	"Comment": "utility method to conveniently retrieve materials from the assets system,hiding the relative complexity of the exception handling.",
	"Method": "Material getMaterial(ResourceUrn materialUrn){\r\n    String materialName = materialUrn.toString();\r\n    return Assets.getMaterial(materialName).orElseThrow(() -> new RuntimeException(\"Failed to resolve required asset: '\" + materialName + \"'\"));\r\n}"
}, {
	"Path": "org.springframework.security.authentication.jaas.AbstractJaasAuthenticationProvider.getCallbackHandlers",
	"Comment": "returns the current jaasauthenticationcallbackhandler array, or null if none are",
	"Method": "JaasAuthenticationCallbackHandler[] getCallbackHandlers(){\r\n    return this.callbackHandlers;\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.layers.mainMenu.NameRecordingScreen.copySaveDirectoryToRecordingLibrary",
	"Comment": "copies the selected save files to a new recording directory.",
	"Method": "void copySaveDirectoryToRecordingLibrary(String oldTitle,String newTitle){\r\n    File saveDirectory = new File(PathManager.getInstance().getSavePath(oldTitle).toString());\r\n    Path destinationPath = PathManager.getInstance().getRecordingPath(newTitle);\r\n    File destDirectory = new File(destinationPath.toString());\r\n    try {\r\n        FileUtils.copyDirectoryStructure(saveDirectory, destDirectory);\r\n        rewriteManifestTitle(destinationPath, newTitle);\r\n    } catch (Exception e) {\r\n        logger.error(\"Error trying to copy the save directory:\", e);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.web.util.matcher.ELRequestMatcher.createELContext",
	"Comment": "subclasses can override this methode if they want to use a different el root\tcontext",
	"Method": "EvaluationContext createELContext(HttpServletRequest request){\r\n    return new StandardEvaluationContext(new ELRequestMatcherContext(request));\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.logout.LogoutFilter.requiresLogout",
	"Comment": "allow subclasses to modify when a logout should take place.",
	"Method": "boolean requiresLogout(HttpServletRequest request,HttpServletResponse response){\r\n    return logoutRequestMatcher.matches(request);\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.layouts.ScrollableArea.moveToBottom",
	"Comment": "moves the layout to display the bottom of the widget.equivalent to scrolling all the way down",
	"Method": "void moveToBottom(){\r\n    moveToBottomPending = true;\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.layouts.relative.HorizontalHint.alignLeft",
	"Comment": "aligns the left edge of the widget against a specified part of the draw region, with a pixel offset",
	"Method": "HorizontalHint alignLeft(HorizontalHint alignLeft,int offset,HorizontalHint alignLeft,HorizontalAlign targetPart,HorizontalHint alignLeft,HorizontalAlign targetPart,int offset){\r\n    return alignLeftRelativeTo(\"\", targetPart, offset);\r\n}"
}, {
	"Path": "springfox.documentation.builders.ModelBuilder.type",
	"Comment": "represents the type information with full fidelity of generics",
	"Method": "ModelBuilder type(ResolvedType modelType){\r\n    this.modelType = defaultIfAbsent(modelType, this.modelType);\r\n    return this;\r\n}"
}, {
	"Path": "springfox.documentation.builders.OAuthBuilder.name",
	"Comment": "updates the unique name to identify the security definition",
	"Method": "OAuthBuilder name(String name){\r\n    this.name = defaultIfAbsent(name, this.name);\r\n    return this;\r\n}"
}, {
	"Path": "org.terasology.persistence.serializers.EventSerializer.setIdMapping",
	"Comment": "sets the mapping between event classes and the ids that are used for serialization",
	"Method": "void setIdMapping(Map<Class<? extends Event>, Integer> table){\r\n    idTable = ImmutableBiMap.copyOf(table);\r\n}"
}, {
	"Path": "org.terasology.rendering.dag.nodes.BufferClearingNode.process",
	"Comment": "clears the buffers selected by the mask provided in setrequiredobjects, with default values.this method is executed within a nodetask in the render tasklist.",
	"Method": "void process(){\r\n    glClear(clearingMask);\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.preauth.RequestAttributeAuthenticationFilterTests.createAuthenticationManager",
	"Comment": "create an authentication manager which returns the passed in object.",
	"Method": "AuthenticationManager createAuthenticationManager(){\r\n    AuthenticationManager am = mock(AuthenticationManager.class);\r\n    when(am.authenticate(any(Authentication.class))).thenAnswer(new Answer<Authentication>() {\r\n        public Authentication answer(InvocationOnMock invocation) throws Throwable {\r\n            return (Authentication) invocation.getArguments()[0];\r\n        }\r\n    });\r\n    return am;\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.preauth.RequestAttributeAuthenticationFilterTests.createAuthenticationManager",
	"Comment": "create an authentication manager which returns the passed in object.",
	"Method": "AuthenticationManager createAuthenticationManager(){\r\n    return (Authentication) invocation.getArguments()[0];\r\n}"
}, {
	"Path": "org.terasology.engine.TerasologyEngine.verifyRequiredSystemIsRegistered",
	"Comment": "verifies that a required class is available through the core registry.",
	"Method": "void verifyRequiredSystemIsRegistered(Class<?> clazz){\r\n    if (rootContext.get(clazz) == null) {\r\n        throw new IllegalStateException(clazz.getSimpleName() + \" not registered as a core system.\");\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.switchuser.SwitchUserGrantedAuthority.getSource",
	"Comment": "returns the original user associated with a successful user switch.",
	"Method": "Authentication getSource(){\r\n    return source;\r\n}"
}, {
	"Path": "org.terasology.rendering.primitives.ChunkMesh.isEmpty",
	"Comment": "returns true if an instance of this class stores no triangles.",
	"Method": "boolean isEmpty(){\r\n    return triangleCount == 0;\r\n}"
}, {
	"Path": "org.springframework.security.web.server.util.matcher.ServerWebExchangeMatchers.pathMatchers",
	"Comment": "creates a matcher that matches on any of the provided patterns.",
	"Method": "ServerWebExchangeMatcher pathMatchers(HttpMethod method,String patterns,ServerWebExchangeMatcher pathMatchers,String patterns){\r\n    return pathMatchers(null, patterns);\r\n}"
}, {
	"Path": "org.springframework.security.ldap.userdetails.NestedLdapAuthoritiesPopulator.getMaxSearchDepth",
	"Comment": "how far should a nested search go. depth is calculated in the number of levels we\tsearch up for parent groups.",
	"Method": "int getMaxSearchDepth(){\r\n    return this.maxSearchDepth;\r\n}"
}, {
	"Path": "org.terasology.monitoring.PerformanceMonitor.rollCycle",
	"Comment": "drops old information and updates the metrics. should be called once per frame.",
	"Method": "void rollCycle(){\r\n    instance.rollCycle();\r\n}"
}, {
	"Path": "org.terasology.logic.players.LocalPlayer.activateTargetAsClient",
	"Comment": "tries to activate the target the player is pointing at.this method is indented to be used on the client.",
	"Method": "boolean activateTargetAsClient(){\r\n    return activateTargetOrOwnedEntity(EntityRef.NULL);\r\n}"
}, {
	"Path": "org.terasology.world.generator.WorldGenerator.getSpawnPosition",
	"Comment": "determines a spawn position suitable for this world, such as that used to spawn the initial player.the default implementation simply picks a position in the very center of the world.",
	"Method": "Vector3f getSpawnPosition(EntityRef entity){\r\n    return new FixedSpawner(0, 0).getSpawnPosition(getWorld(), entity);\r\n}"
}, {
	"Path": "org.springframework.security.config.annotation.web.messaging.MessageSecurityMetadataSourceRegistry.containsMapping",
	"Comment": "allows determining if a mapping was added.\tthis is not exposed so as not to confuse users of the api, which should never need\tto invoke this method.",
	"Method": "boolean containsMapping(){\r\n    return !this.matcherToExpression.isEmpty();\r\n}"
}, {
	"Path": "org.springframework.security.web.savedrequest.DefaultSavedRequest.doesRequestMatch",
	"Comment": "determines if the current request matches the defaultsavedrequest.\tall url arguments are considered but not cookies, locales, headers or parameters.",
	"Method": "boolean doesRequestMatch(HttpServletRequest request,PortResolver portResolver){\r\n    if (!propertyEquals(\"pathInfo\", this.pathInfo, request.getPathInfo())) {\r\n        return false;\r\n    }\r\n    if (!propertyEquals(\"queryString\", this.queryString, request.getQueryString())) {\r\n        return false;\r\n    }\r\n    if (!propertyEquals(\"requestURI\", this.requestURI, request.getRequestURI())) {\r\n        return false;\r\n    }\r\n    if (!\"GET\".equals(request.getMethod()) && \"GET\".equals(method)) {\r\n        return false;\r\n    }\r\n    if (!propertyEquals(\"serverPort\", Integer.valueOf(this.serverPort), Integer.valueOf(portResolver.getServerPort(request)))) {\r\n        return false;\r\n    }\r\n    if (!propertyEquals(\"requestURL\", this.requestURL, request.getRequestURL().toString())) {\r\n        return false;\r\n    }\r\n    if (!propertyEquals(\"scheme\", this.scheme, request.getScheme())) {\r\n        return false;\r\n    }\r\n    if (!propertyEquals(\"serverName\", this.serverName, request.getServerName())) {\r\n        return false;\r\n    }\r\n    if (!propertyEquals(\"contextPath\", this.contextPath, request.getContextPath())) {\r\n        return false;\r\n    }\r\n    return propertyEquals(\"servletPath\", this.servletPath, request.getServletPath());\r\n}"
}, {
	"Path": "org.terasology.entitySystem.entity.internal.PojoEntityManager.getCurrentWorldPool",
	"Comment": "check if world pools have been created and returns them such that subsequent entities are put in them. the global poolis returned if no world pools have been created.",
	"Method": "EngineEntityPool getCurrentWorldPool(){\r\n    if (worldManager == null || worldManager.getCurrentWorldPool() == null) {\r\n        return globalPool;\r\n    } else {\r\n        return worldManager.getCurrentWorldPool();\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.AbstractAuthenticationTargetUrlRequestHandler.setTargetUrlParameter",
	"Comment": "if this property is set, the current request will be checked for this a parameter\twith this name and the value used as the target url if present.",
	"Method": "void setTargetUrlParameter(String targetUrlParameter){\r\n    if (targetUrlParameter != null) {\r\n        Assert.hasText(targetUrlParameter, \"targetUrlParameter cannot be empty\");\r\n    }\r\n    this.targetUrlParameter = targetUrlParameter;\r\n}"
}, {
	"Path": "org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessorsTestSecurityContextTests.testSecurityContextNoContext",
	"Comment": "ensure it does not fail if testsecuritycontextholder is not initialized",
	"Method": "void testSecurityContextNoContext(){\r\n    testSecurityContext().postProcessRequest(request);\r\n    verify(repository, never()).saveContext(any(SecurityContext.class), eq(request), any(HttpServletResponse.class));\r\n}"
}, {
	"Path": "org.springframework.security.ldap.userdetails.NestedLdapAuthoritiesPopulator.setMaxSearchDepth",
	"Comment": "how far should a nested search go. depth is calculated in the number of levels we\tsearch up for parent groups.",
	"Method": "void setMaxSearchDepth(int maxSearchDepth){\r\n    this.maxSearchDepth = maxSearchDepth;\r\n}"
}, {
	"Path": "org.terasology.rendering.dag.nodes.DownSamplerNode.process",
	"Comment": "processes the input fbo downsampling its color attachment into the color attachment of the output fbo.",
	"Method": "void process(){\r\n    PerformanceMonitor.startActivity(\"rendering/\" + getUri());\r\n    downSampler.setFloat(\"size\", outputFbo.width(), true);\r\n    renderFullscreenQuad();\r\n    PerformanceMonitor.endActivity();\r\n}"
}, {
	"Path": "springfox.documentation.spi.schema.contexts.ModelContext.inputParam",
	"Comment": "convenience method to provide an new context for an input parameter",
	"Method": "ModelContext inputParam(String group,Type type,DocumentationType documentationType,AlternateTypeProvider alternateTypeProvider,GenericTypeNamingStrategy genericNamingStrategy,Set<Class> ignorableTypes){\r\n    return new ModelContext(group, type, false, documentationType, alternateTypeProvider, genericNamingStrategy, ignorableTypes);\r\n}"
}, {
	"Path": "org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl.createUserDetails",
	"Comment": "can be overridden to customize the creation of the final userdetailsobject which is\treturned by the loaduserbyusername method.",
	"Method": "UserDetails createUserDetails(String username,UserDetails userFromUserQuery,List<GrantedAuthority> combinedAuthorities){\r\n    String returnUsername = userFromUserQuery.getUsername();\r\n    if (!this.usernameBasedPrimaryKey) {\r\n        returnUsername = username;\r\n    }\r\n    return new User(returnUsername, userFromUserQuery.getPassword(), userFromUserQuery.isEnabled(), true, true, true, combinedAuthorities);\r\n}"
}, {
	"Path": "springfox.documentation.builders.ParameterBuilder.allowableValues",
	"Comment": "updates if the parameter is bound by a range of values or a range of numerical values",
	"Method": "ParameterBuilder allowableValues(AllowableValues allowableValues){\r\n    this.allowableValues = emptyToNull(allowableValues, this.allowableValues);\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter.obtainUsername",
	"Comment": "enables subclasses to override the composition of the username, such as by\tincluding additional values and a separator.",
	"Method": "String obtainUsername(HttpServletRequest request){\r\n    return request.getParameter(usernameParameter);\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.setFilterProcessesUrl",
	"Comment": "sets the url that determines if authentication is required",
	"Method": "void setFilterProcessesUrl(String filterProcessesUrl){\r\n    setRequiresAuthenticationRequestMatcher(new AntPathRequestMatcher(filterProcessesUrl));\r\n}"
}, {
	"Path": "springfox.documentation.builders.RequestHandlerSelectors.withClassAnnotation",
	"Comment": "predicate that matches requesthandler with given annotation on the declaring class of the handler method",
	"Method": "Predicate<RequestHandler> withClassAnnotation(Class<? extends Annotation> annotation){\r\n    return input -> declaringClass(input).map(annotationPresent(annotation)).orElse(false);\r\n}"
}, {
	"Path": "org.terasology.persistence.internal.SaveTransactionHelper.mergeChanges",
	"Comment": "merges all outstanding changes into the save game. if this operation gets interrupted it can be started againwithout any file corruption when the file system supports atomic moves.the write lock for the save directory should be acquired before this method gets called.",
	"Method": "void mergeChanges(){\r\n    final Path sourceDirectory = storagePathProvider.getUnmergedChangesPath();\r\n    final Path targetDirectory = storagePathProvider.getStoragePathDirectory();\r\n    Files.walkFileTree(sourceDirectory, new SimpleFileVisitor<Path>() {\r\n        boolean atomicNotPossibleLogged;\r\n        @Override\r\n        public FileVisitResult preVisitDirectory(Path sourceSubDir, BasicFileAttributes attrs) throws IOException {\r\n            Path targetSubDir = targetDirectory.resolve(sourceDirectory.relativize(sourceSubDir));\r\n            if (!Files.isDirectory(targetSubDir)) {\r\n                Files.createDirectory(targetSubDir);\r\n            }\r\n            return FileVisitResult.CONTINUE;\r\n        }\r\n        @Override\r\n        public FileVisitResult visitFile(Path sourcePath, BasicFileAttributes attrs) throws IOException {\r\n            Path targetPath = targetDirectory.resolve(sourceDirectory.relativize(sourcePath));\r\n            try {\r\n                Files.deleteIfExists(targetPath);\r\n                Files.move(sourcePath, targetPath, StandardCopyOption.ATOMIC_MOVE);\r\n            } catch (AtomicMoveNotSupportedException e) {\r\n                if (!atomicNotPossibleLogged) {\r\n                    logger.warn(\"Atomic move was not possible, doing it non atomically...\");\r\n                    atomicNotPossibleLogged = true;\r\n                }\r\n                Files.move(sourcePath, targetPath);\r\n            }\r\n            return FileVisitResult.CONTINUE;\r\n        }\r\n        @Override\r\n        public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\r\n            try {\r\n                Files.delete(dir);\r\n            } catch (DirectoryNotEmptyException e) {\r\n                logger.warn(\"The save job could not cleanup a temporarly created directory, it will retry once in one second\");\r\n                try {\r\n                    Thread.sleep(1000L);\r\n                } catch (InterruptedException e1) {\r\n                    Thread.currentThread().interrupt();\r\n                }\r\n                Files.delete(dir);\r\n            }\r\n            return FileVisitResult.CONTINUE;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.terasology.persistence.internal.SaveTransactionHelper.mergeChanges",
	"Comment": "merges all outstanding changes into the save game. if this operation gets interrupted it can be started againwithout any file corruption when the file system supports atomic moves.the write lock for the save directory should be acquired before this method gets called.",
	"Method": "void mergeChanges(){\r\n    Path targetSubDir = targetDirectory.resolve(sourceDirectory.relativize(sourceSubDir));\r\n    if (!Files.isDirectory(targetSubDir)) {\r\n        Files.createDirectory(targetSubDir);\r\n    }\r\n    return FileVisitResult.CONTINUE;\r\n}"
}, {
	"Path": "org.terasology.persistence.internal.SaveTransactionHelper.mergeChanges",
	"Comment": "merges all outstanding changes into the save game. if this operation gets interrupted it can be started againwithout any file corruption when the file system supports atomic moves.the write lock for the save directory should be acquired before this method gets called.",
	"Method": "void mergeChanges(){\r\n    Path targetPath = targetDirectory.resolve(sourceDirectory.relativize(sourcePath));\r\n    try {\r\n        Files.deleteIfExists(targetPath);\r\n        Files.move(sourcePath, targetPath, StandardCopyOption.ATOMIC_MOVE);\r\n    } catch (AtomicMoveNotSupportedException e) {\r\n        if (!atomicNotPossibleLogged) {\r\n            logger.warn(\"Atomic move was not possible, doing it non atomically...\");\r\n            atomicNotPossibleLogged = true;\r\n        }\r\n        Files.move(sourcePath, targetPath);\r\n    }\r\n    return FileVisitResult.CONTINUE;\r\n}"
}, {
	"Path": "org.terasology.persistence.internal.SaveTransactionHelper.mergeChanges",
	"Comment": "merges all outstanding changes into the save game. if this operation gets interrupted it can be started againwithout any file corruption when the file system supports atomic moves.the write lock for the save directory should be acquired before this method gets called.",
	"Method": "void mergeChanges(){\r\n    try {\r\n        Files.delete(dir);\r\n    } catch (DirectoryNotEmptyException e) {\r\n        logger.warn(\"The save job could not cleanup a temporarly created directory, it will retry once in one second\");\r\n        try {\r\n            Thread.sleep(1000L);\r\n        } catch (InterruptedException e1) {\r\n            Thread.currentThread().interrupt();\r\n        }\r\n        Files.delete(dir);\r\n    }\r\n    return FileVisitResult.CONTINUE;\r\n}"
}, {
	"Path": "org.terasology.rendering.dag.stateChanges.SetInputTexture.getDefaultInstance",
	"Comment": "returns a statechange instance useful to disconnect the given texture from its assigned texture slot.also disconnects the texture from the shader program.",
	"Method": "StateChange getDefaultInstance(){\r\n    if (defaultInstance == null) {\r\n        defaultInstance = new SetInputTexture(textureType, textureSlot, materialUrn, materialParameter);\r\n    }\r\n    return defaultInstance;\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.layouts.ScrollableArea.willNeedScrollbar",
	"Comment": "checks if the area will need a scrollbar with the given size.can be used for either vertical o r horizontal checks",
	"Method": "boolean willNeedScrollbar(int areaSize,int contentSize,int scrollbarSize){\r\n    return areaSize < contentSize + scrollbarSize;\r\n}"
}, {
	"Path": "springfox.documentation.builders.DocumentationBuilder.produces",
	"Comment": "updates the existing media types with new entries that this documentation produces",
	"Method": "DocumentationBuilder produces(Set<String> mediaTypes){\r\n    this.produces.addAll(nullToEmptySet(mediaTypes));\r\n    return this;\r\n}"
}, {
	"Path": "org.terasology.physics.bullet.BulletPhysics.applyPendingImpulsesAndForces",
	"Comment": "applies all pending impulses to the corresponding rigidbodies and clearsthe pending impulses.",
	"Method": "void applyPendingImpulsesAndForces(){\r\n    for (Map.Entry<EntityRef, BulletRigidBody> entree : entityRigidBodies.entrySet()) {\r\n        BulletRigidBody body = entree.getValue();\r\n        body.rb.applyCentralImpulse(body.pendingImpulse);\r\n        body.rb.applyCentralForce(body.pendingForce);\r\n        body.pendingImpulse.x = 0;\r\n        body.pendingImpulse.y = 0;\r\n        body.pendingImpulse.z = 0;\r\n        body.pendingForce.x = 0;\r\n        body.pendingForce.y = 0;\r\n        body.pendingForce.z = 0;\r\n    }\r\n}"
}, {
	"Path": "org.terasology.identity.storageServiceClient.StorageServiceWorker.logout",
	"Comment": "destroys the current session and switches to the logged out status.",
	"Method": "void logout(boolean deleteLocalIdentities){\r\n    performAction(new LogoutAction(deleteLocalIdentities), StorageServiceWorkerStatus.LOGGED_IN);\r\n}"
}, {
	"Path": "org.springframework.security.ldap.DefaultLdapUsernameToDnMapper.buildDn",
	"Comment": "assembles the distinguished name that should be used the given username.",
	"Method": "DistinguishedName buildDn(String username){\r\n    DistinguishedName dn = new DistinguishedName(userDnBase);\r\n    dn.add(usernameAttribute, username);\r\n    return dn;\r\n}"
}, {
	"Path": "org.springframework.security.openid.OpenIDAttribute.getCount",
	"Comment": "the requested count for the attribute when it is used as part of an authentication\trequest. defaults to 1.",
	"Method": "int getCount(){\r\n    return count;\r\n}"
}, {
	"Path": "springfox.documentation.spring.web.plugins.Docket.pathProvider",
	"Comment": "determines the generated, swagger specific, urls.by default, relative urls are generated. if absolute urls are required, supply an implementation ofabsoluteswaggerpathprovider",
	"Method": "Docket pathProvider(PathProvider pathProvider){\r\n    this.pathProvider = pathProvider;\r\n    return this;\r\n}"
}, {
	"Path": "org.terasology.utilities.ReflectionUtil.getInheritanceTree",
	"Comment": "returns an ordered list of super classes and interfaces for the given class, that have a common base class.the set is ordered with the deepest interface first, through all the interfaces, and then all the super classes.",
	"Method": "List<Class<? extends T>> getInheritanceTree(Class<? extends T> forClass,Class<T> baseClass){\r\n    Set<Class<? extends T>> result = Sets.newLinkedHashSet();\r\n    for (Class<?> interfaceType : forClass.getInterfaces()) {\r\n        if (baseClass.isAssignableFrom(interfaceType)) {\r\n            addInterfaceToInheritanceTree((Class<? extends T>) interfaceType, baseClass, result);\r\n        }\r\n    }\r\n    addClassToInheritanceTree(forClass, baseClass, result);\r\n    return Lists.newArrayList(result);\r\n}"
}, {
	"Path": "org.springframework.security.ldap.SpringSecurityLdapTemplate.searchForSingleEntryInternal",
	"Comment": "internal method extracted to avoid code duplication in ad search.",
	"Method": "DirContextOperations searchForSingleEntryInternal(DirContext ctx,SearchControls searchControls,String base,String filter,Object[] params){\r\n    final DistinguishedName ctxBaseDn = new DistinguishedName(ctx.getNameInNamespace());\r\n    final DistinguishedName searchBaseDn = new DistinguishedName(base);\r\n    final NamingEnumeration<SearchResult> resultsEnum = ctx.search(searchBaseDn, filter, params, buildControls(searchControls));\r\n    if (logger.isDebugEnabled()) {\r\n        logger.debug(\"Searching for entry under DN '\" + ctxBaseDn + \"', base = '\" + searchBaseDn + \"', filter = '\" + filter + \"'\");\r\n    }\r\n    Set<DirContextOperations> results = new HashSet();\r\n    try {\r\n        while (resultsEnum.hasMore()) {\r\n            SearchResult searchResult = resultsEnum.next();\r\n            DirContextAdapter dca = (DirContextAdapter) searchResult.getObject();\r\n            Assert.notNull(dca, \"No object returned by search, DirContext is not correctly configured\");\r\n            if (logger.isDebugEnabled()) {\r\n                logger.debug(\"Found DN: \" + dca.getDn());\r\n            }\r\n            results.add(dca);\r\n        }\r\n    } catch (PartialResultException e) {\r\n        LdapUtils.closeEnumeration(resultsEnum);\r\n        logger.info(\"Ignoring PartialResultException\");\r\n    }\r\n    if (results.size() == 0) {\r\n        throw new IncorrectResultSizeDataAccessException(1, 0);\r\n    }\r\n    if (results.size() > 1) {\r\n        throw new IncorrectResultSizeDataAccessException(1, results.size());\r\n    }\r\n    return results.iterator().next();\r\n}"
}, {
	"Path": "org.springframework.security.config.core.userdetails.UserDetailsResourceFactoryBean.fromString",
	"Comment": "creates a userdetailsresourcefactorybean with a resource from the provided string",
	"Method": "UserDetailsResourceFactoryBean fromString(String users){\r\n    InMemoryResource resource = new InMemoryResource(users);\r\n    return fromResource(resource);\r\n}"
}, {
	"Path": "org.springframework.security.access.annotation.Jsr250MethodSecurityMetadataSourceTests.interfacesNeverContributeAnnotationsMethodLevel",
	"Comment": "the interfaces implemented by a class never contribute annotations to the class\titself or any of its members.",
	"Method": "void interfacesNeverContributeAnnotationsMethodLevel(){\r\n    Parent target = new Parent();\r\n    MockMethodInvocation mi = new MockMethodInvocation(target, target.getClass(), \"interfaceMethod\");\r\n    Collection<ConfigAttribute> accessAttributes = this.mds.getAttributes(mi);\r\n    assertThat(accessAttributes).isEmpty();\r\n}"
}, {
	"Path": "org.terasology.rendering.logic.NearestSortingList.getNearest",
	"Comment": "returns the entities that are expected to be the nearest to the player.it is not guaranteed they are the nearest entities though.",
	"Method": "int getNearest(EntityRef[] output,EntityRef[] getNearest,int count){\r\n    EntityRef[] output = new EntityRef[Math.min(count, size())];\r\n    getNearest(output);\r\n    return output;\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.widgets.UIScrollingText.setAutoReset",
	"Comment": "specifies whether scrolling will restart from the beginning when all text has been scrolled through.",
	"Method": "void setAutoReset(boolean reset){\r\n    this.autoReset = reset;\r\n}"
}, {
	"Path": "org.springframework.security.oauth2.client.userinfo.OAuth2UserRequest.getAdditionalParameters",
	"Comment": "returns the additional parameters that may be used in the request.",
	"Method": "Map<String, Object> getAdditionalParameters(){\r\n    return this.additionalParameters;\r\n}"
}, {
	"Path": "org.terasology.persistence.serializers.EntitySerializer.removeComponentIdMapping",
	"Comment": "clears the mapping between component classes and ids. this causes components to be serialized with their componentclass name instead.",
	"Method": "void removeComponentIdMapping(){\r\n    componentSerializer.removeIdMapping();\r\n}"
}, {
	"Path": "springfox.documentation.spring.web.plugins.Docket.forCodeGeneration",
	"Comment": "set this to true in order to make the documentation code generation friendly",
	"Method": "Docket forCodeGeneration(boolean forCodeGen){\r\n    if (forCodeGen) {\r\n        genericsNamingStrategy = new CodeGenGenericTypeNamingStrategy();\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.terasology.math.ChunkMath.blockInChunk",
	"Comment": "works out whether the given block resides inside the given chunk.both positions must be given as world position, not local position. in addition, the chunk position must begiven in chunk coordinates, not in block coordinates.for example, using chunks of width 32, a block with x coordinate of 33 will be counted as inside a chunk with xcoordinate of 1.",
	"Method": "boolean blockInChunk(Vector3i blockWorldPos,Vector3i chunkWorldPos){\r\n    return calcChunkPos(blockWorldPos).equals(chunkWorldPos);\r\n}"
}, {
	"Path": "org.terasology.telemetry.metrics.Metric.getUnstructuredMetric",
	"Comment": "generates a snowplow unstructured event that the snowplow tracker can track.",
	"Method": "Optional<Unstructured> getUnstructuredMetric(Optional<Unstructured> getUnstructuredMetric,String schema,Map<String, Object> mapSentToServer){\r\n    Optional<Unstructured> optional = Optional.empty();\r\n    if (!isEmpty()) {\r\n        SelfDescribingJson modulesData = new SelfDescribingJson(schema, mapSentToServer);\r\n        Unstructured unstructured = Unstructured.builder().eventData(modulesData).build();\r\n        optional = Optional.of(unstructured);\r\n    }\r\n    return optional;\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilter.setAuthenticationSuccessHandler",
	"Comment": "sets the strategy used to handle a successful authentication.",
	"Method": "void setAuthenticationSuccessHandler(AuthenticationSuccessHandler authenticationSuccessHandler){\r\n    this.authenticationSuccessHandler = authenticationSuccessHandler;\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter.setPasswordParameter",
	"Comment": "sets the parameter name which will be used to obtain the password from the login\trequest..",
	"Method": "void setPasswordParameter(String passwordParameter){\r\n    Assert.hasText(passwordParameter, \"Password parameter must not be empty or null\");\r\n    this.passwordParameter = passwordParameter;\r\n}"
}, {
	"Path": "springfox.documentation.builders.ApiListingBuilder.appendProduces",
	"Comment": "appends to the exiting collection of supported media types this listing produces",
	"Method": "ApiListingBuilder appendProduces(List<String> produces){\r\n    this.produces.addAll(nullToEmptyList(produces));\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.security.web.server.authentication.RedirectServerAuthenticationSuccessHandler.setLocation",
	"Comment": "where the user is redirected to upon authentication success",
	"Method": "void setLocation(URI location){\r\n    Assert.notNull(location, \"location cannot be null\");\r\n    this.location = location;\r\n}"
}, {
	"Path": "org.springframework.security.taglibs.authz.AuthenticationTag.isHtmlEscape",
	"Comment": "return the html escaping setting for this tag, or the default setting if not\toverridden.",
	"Method": "boolean isHtmlEscape(){\r\n    return htmlEscape;\r\n}"
}, {
	"Path": "org.terasology.utilities.procedural.BrownianNoise.getLacunarity",
	"Comment": "lacunarity is what makes the frequency grow. each octavethe frequency is multiplied by the lacunarity.",
	"Method": "double getLacunarity(){\r\n    return this.lacunarity;\r\n}"
}, {
	"Path": "org.terasology.world.internal.WorldProviderCore.setBlocks",
	"Comment": "places all given blocks of specific types at their corresponding positionschunks are",
	"Method": "Map<Vector3i, Block> setBlocks(Map<Vector3i, Block> blocks){\r\n    Map<Vector3i, Block> resultMap = Maps.newHashMap();\r\n    for (Map.Entry<Vector3i, Block> entry : blocks.entrySet()) {\r\n        Block oldBlock = setBlock(entry.getKey(), entry.getValue());\r\n        resultMap.put(entry.getKey(), oldBlock);\r\n    }\r\n    return resultMap;\r\n}"
}, {
	"Path": "org.terasology.rendering.logic.NearestSortingList.processQueueAndSetEntities",
	"Comment": "updates the sorted list with all changes made while sorting beforeswapping the lists.",
	"Method": "void processQueueAndSetEntities(List<EntityRef> newEntities){\r\n    for (Command c : commands) {\r\n        c.executeOn(newEntities);\r\n    }\r\n    commands.clear();\r\n    entities = newEntities;\r\n    sorting = false;\r\n}"
}, {
	"Path": "org.springframework.security.web.access.DefaultWebInvocationPrivilegeEvaluator.isAllowed",
	"Comment": "determines whether the user represented by the supplied authentication\tobject is allowed to invoke the supplied uri, with the given .\tnote the default implementation of filterinvocationsecuritymetadatasource\tdisregards the contextpath when evaluating which secure object\tmetadata applies to a given request uri, so generally the contextpath\tis unimportant unless you are using a custom\tfilterinvocationsecuritymetadatasource.",
	"Method": "boolean isAllowed(String uri,Authentication authentication,boolean isAllowed,String contextPath,String uri,String method,Authentication authentication){\r\n    Assert.notNull(uri, \"uri parameter is required\");\r\n    FilterInvocation fi = new FilterInvocation(contextPath, uri, method);\r\n    Collection<ConfigAttribute> attrs = securityInterceptor.obtainSecurityMetadataSource().getAttributes(fi);\r\n    if (attrs == null) {\r\n        if (securityInterceptor.isRejectPublicInvocations()) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    if (authentication == null) {\r\n        return false;\r\n    }\r\n    try {\r\n        securityInterceptor.getAccessDecisionManager().decide(authentication, fi, attrs);\r\n    } catch (AccessDeniedException unauthorized) {\r\n        if (logger.isDebugEnabled()) {\r\n            logger.debug(fi.toString() + \" denied for \" + authentication.toString(), unauthorized);\r\n        }\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.springframework.security.test.context.support.WithSecurityContextTestExecutionListener.beforeTestExecution",
	"Comment": "if configured before test execution sets the securitycontext",
	"Method": "void beforeTestExecution(TestContext testContext){\r\n    SecurityContext securityContext = (SecurityContext) testContext.removeAttribute(SECURITY_CONTEXT_ATTR_NAME);\r\n    if (securityContext != null) {\r\n        TestSecurityContextHolder.setContext(securityContext);\r\n    }\r\n}"
}, {
	"Path": "org.terasology.recording.EventSystemReplayImpl.processRecordedEvents",
	"Comment": "processes recorded events for a certain amount of time and only if the timestamp is right.",
	"Method": "void processRecordedEvents(){\r\n    if (recordAndReplayCurrentStatus.getStatus() == RecordAndReplayStatus.REPLAYING && !this.areRecordedEventsLoaded) {\r\n        initialiseReplayData();\r\n    }\r\n    if (recordAndReplayCurrentStatus.getStatus() == RecordAndReplayStatus.REPLAYING) {\r\n        processRecordedEventsBatch(1);\r\n        if (this.recordedEvents.isEmpty()) {\r\n            if (recordAndReplayUtils.getFileCount() <= recordAndReplayUtils.getFileAmount()) {\r\n                loadNextRecordedEventFile();\r\n            } else {\r\n                finishReplay();\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.terasology.logic.players.ThirdPersonRemoteClientSystem.ensureClientSideEntityOnHeldItemMountPoint",
	"Comment": "ensures held item mount point entity exists, attaches it to the character and sets its transform.",
	"Method": "void ensureClientSideEntityOnHeldItemMountPoint(OnActivatedComponent event,EntityRef character,RemotePersonHeldItemMountPointComponent remotePersonHeldItemMountPointComponent){\r\n    if (relatesToLocalPlayer(character)) {\r\n        logger.debug(\"ensureClientSideEntityOnHeldItemMountPoint found its given character to relate to the local player, ignoring: {}\", character);\r\n        return;\r\n    }\r\n    if (!remotePersonHeldItemMountPointComponent.mountPointEntity.exists()) {\r\n        EntityBuilder builder = entityManager.newBuilder(\"engine:RemotePersonHeldItemMountPoint\");\r\n        builder.setPersistent(false);\r\n        remotePersonHeldItemMountPointComponent.mountPointEntity = builder.build();\r\n        character.saveComponent(remotePersonHeldItemMountPointComponent);\r\n    }\r\n    Location.removeChild(character, remotePersonHeldItemMountPointComponent.mountPointEntity);\r\n    Location.attachChild(character, remotePersonHeldItemMountPointComponent.mountPointEntity, remotePersonHeldItemMountPointComponent.translate, new Quat4f(TeraMath.DEG_TO_RAD * remotePersonHeldItemMountPointComponent.rotateDegrees.y, TeraMath.DEG_TO_RAD * remotePersonHeldItemMountPointComponent.rotateDegrees.x, TeraMath.DEG_TO_RAD * remotePersonHeldItemMountPointComponent.rotateDegrees.z), remotePersonHeldItemMountPointComponent.scale);\r\n}"
}, {
	"Path": "org.springframework.security.web.server.util.matcher.ServerWebExchangeMatchers.matchers",
	"Comment": "creates a matcher that will match on any of the provided matchers",
	"Method": "ServerWebExchangeMatcher matchers(ServerWebExchangeMatcher matchers){\r\n    return new OrServerWebExchangeMatcher(matchers);\r\n}"
}, {
	"Path": "org.terasology.network.internal.ClientHandshakeHandler.processNewIdentity",
	"Comment": "generates a new secret key for a user and then decrypts the certificate into a byte array. storing the certificate to the user id.",
	"Method": "void processNewIdentity(NetData.ProvisionIdentity provisionIdentity,ChannelHandlerContext ctx){\r\n    logger.info(\"Received identity from server\");\r\n    if (!requestedCertificate) {\r\n        logger.error(\"Received identity without requesting it: cancelling authentication\");\r\n        joinStatus.setErrorMessage(AUTHENTICATION_FAILURE);\r\n        ctx.getChannel().close();\r\n        return;\r\n    }\r\n    try {\r\n        byte[] decryptedCert = null;\r\n        try {\r\n            SecretKeySpec key = HandshakeCommon.generateSymmetricKey(masterSecret, clientRandom, serverRandom);\r\n            Cipher cipher = Cipher.getInstance(IdentityConstants.SYMMETRIC_ENCRYPTION_ALGORITHM);\r\n            cipher.init(Cipher.DECRYPT_MODE, key);\r\n            decryptedCert = cipher.doFinal(provisionIdentity.getEncryptedCertificates().toByteArray());\r\n        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | BadPaddingException | IllegalBlockSizeException e) {\r\n            logger.error(\"Unexpected error decrypting received certificate, ending connection attempt\", e);\r\n            joinStatus.setErrorMessage(AUTHENTICATION_FAILURE);\r\n            ctx.getChannel().close();\r\n            return;\r\n        }\r\n        NetData.CertificateSet certificateSet = NetData.CertificateSet.parseFrom(decryptedCert);\r\n        NetData.Certificate publicCertData = certificateSet.getPublicCertificate();\r\n        PublicIdentityCertificate publicCert = NetMessageUtil.convert(publicCertData);\r\n        if (!publicCert.verifySignedBy(serverCertificate)) {\r\n            logger.error(\"Received invalid certificate, not signed by server: cancelling authentication\");\r\n            joinStatus.setErrorMessage(AUTHENTICATION_FAILURE);\r\n            ctx.getChannel().close();\r\n            return;\r\n        }\r\n        BigInteger exponent = new BigInteger(certificateSet.getPrivateExponent().toByteArray());\r\n        PrivateIdentityCertificate privateCert = new PrivateIdentityCertificate(publicCert.getModulus(), exponent);\r\n        identity = new ClientIdentity(publicCert, privateCert);\r\n        config.getSecurity().addIdentity(serverCertificate, identity);\r\n        config.save();\r\n        StorageServiceWorker storageServiceWorker = CoreRegistry.get(StorageServiceWorker.class);\r\n        if (storageServiceWorker != null && storageServiceWorker.getStatus() == StorageServiceWorkerStatus.LOGGED_IN) {\r\n            storageServiceWorker.putIdentity(serverCertificate, identity);\r\n        }\r\n        ctx.getPipeline().remove(this);\r\n        channelAuthenticated(ctx);\r\n    } catch (InvalidProtocolBufferException e) {\r\n        logger.error(\"Received invalid certificate data: cancelling authentication\", e);\r\n        joinStatus.setErrorMessage(AUTHENTICATION_FAILURE);\r\n        ctx.getChannel().close();\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.www.DigestAuthUtils.split",
	"Comment": "splits a string at the first instance of the delimiter.\tdoes not include the delimiter in the response.",
	"Method": "String[] split(String toSplit,String delimiter){\r\n    Assert.hasLength(toSplit, \"Cannot split a null or empty string\");\r\n    Assert.hasLength(delimiter, \"Cannot use a null or empty delimiter to split a string\");\r\n    if (delimiter.length() != 1) {\r\n        throw new IllegalArgumentException(\"Delimiter can only be one character in length\");\r\n    }\r\n    int offset = toSplit.indexOf(delimiter);\r\n    if (offset < 0) {\r\n        return null;\r\n    }\r\n    String beforeDelimiter = toSplit.substring(0, offset);\r\n    String afterDelimiter = toSplit.substring(offset + 1);\r\n    return new String[] { beforeDelimiter, afterDelimiter };\r\n}"
}, {
	"Path": "org.springframework.security.authentication.DefaultAuthenticationEventPublisher.setAdditionalExceptionMappings",
	"Comment": "sets additional exception to event mappings. these are automatically merged with\tthe default exception to event mappings that providermanager defines.",
	"Method": "void setAdditionalExceptionMappings(Properties additionalExceptionMappings){\r\n    Assert.notNull(additionalExceptionMappings, \"The exceptionMappings object must not be null\");\r\n    for (Object exceptionClass : additionalExceptionMappings.keySet()) {\r\n        String eventClass = (String) additionalExceptionMappings.get(exceptionClass);\r\n        try {\r\n            Class<?> clazz = getClass().getClassLoader().loadClass(eventClass);\r\n            Assert.isAssignable(AbstractAuthenticationFailureEvent.class, clazz);\r\n            addMapping((String) exceptionClass, (Class<? extends AbstractAuthenticationFailureEvent>) clazz);\r\n        } catch (ClassNotFoundException e) {\r\n            throw new RuntimeException(\"Failed to load authentication event class \" + eventClass);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.web.servlet.util.matcher.MvcRequestMatcherTests.matchesInvalidMethodOnRequest",
	"Comment": "malicious users can specify any http method to create a stacktrace and try to\texpose useful information about the system. we should ensure we ignore invalid http\tmethods.",
	"Method": "void matchesInvalidMethodOnRequest(){\r\n    this.matcher.setMethod(HttpMethod.GET);\r\n    this.request.setMethod(\"invalid\");\r\n    assertThat(this.matcher.matches(this.request)).isFalse();\r\n    verifyZeroInteractions(this.introspector);\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.skin.UIStyle.getHorizontalAlignment",
	"Comment": "if the element does not use the full width of the available to it, how should it be aligned",
	"Method": "HorizontalAlign getHorizontalAlignment(){\r\n    return alignmentH;\r\n}"
}, {
	"Path": "org.springframework.security.core.session.SessionInformation.refreshLastRequest",
	"Comment": "refreshes the internal lastrequest to the current date and time.",
	"Method": "void refreshLastRequest(){\r\n    this.lastRequest = new Date();\r\n}"
}, {
	"Path": "org.terasology.rendering.opengl.ScreenGrabber.isTakingScreenshot",
	"Comment": "returns true if the rendering engine is in the process of taking a screenshot.returns false if a screenshot is not being taken.",
	"Method": "boolean isTakingScreenshot(){\r\n    return isTakingScreenshot;\r\n}"
}, {
	"Path": "org.terasology.rendering.dag.nodes.OverlaysNode.enableWireframe",
	"Comment": "enables wireframe.notice that this is just a request and wireframe gets enabled only after therendering task list has been refreshed. this occurs before the beginningof next frame or earlier.",
	"Method": "void enableWireframe(){\r\n    if (!getDesiredStateChanges().contains(wireframeStateChange)) {\r\n        addDesiredStateChange(wireframeStateChange);\r\n        worldRenderer.requestTaskListRefresh();\r\n    }\r\n}"
}, {
	"Path": "org.terasology.engine.subsystem.rpc.DiscordRPCSubSystem.disableLogger",
	"Comment": "to disable the logger from some classes that throw errors and some other spam stuff into our console.",
	"Method": "void disableLogger(Class<?> clazz){\r\n    LoggerContext loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory();\r\n    Logger l = loggerContext.getLogger(clazz);\r\n    ((ch.qos.logback.classic.Logger) l).setLevel(Level.OFF);\r\n}"
}, {
	"Path": "org.springframework.security.ldap.userdetails.DefaultLdapAuthoritiesPopulator.getSearchControls",
	"Comment": "returns the search controls method available so that classes extending this can\toverride the search controls used",
	"Method": "SearchControls getSearchControls(){\r\n    return this.searchControls;\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.session.ConcurrentSessionControlAuthenticationStrategy.getMaximumSessionsForThisUser",
	"Comment": "method intended for use by subclasses to override the maximum number of sessions\tthat are permitted for a particular authentication. the default implementation\tsimply returns the maximumsessions value for the bean.",
	"Method": "int getMaximumSessionsForThisUser(Authentication authentication){\r\n    return maximumSessions;\r\n}"
}, {
	"Path": "org.terasology.recording.EventSystemReplayImpl.process",
	"Comment": "processes recorded and pending events. if recordedevents is not loaded, load it from recordedeventstore.",
	"Method": "void process(){\r\n    processRecordedEvents();\r\n    PendingEvent event = pendingEvents.poll();\r\n    while (event != null) {\r\n        if (event.getComponent() != null) {\r\n            originalSend(event.getEntity(), event.getEvent(), event.getComponent());\r\n        } else {\r\n            originalSend(event.getEntity(), event.getEvent());\r\n        }\r\n        event = pendingEvents.poll();\r\n    }\r\n}"
}, {
	"Path": "org.terasology.world.generation.Border3D.equals",
	"Comment": "checks if the fields of the instance are the same as the object passed in the parameters. it compares the size of the border3d and returns true of all sizes are thesame.",
	"Method": "boolean equals(Object obj){\r\n    if (this == obj) {\r\n        return true;\r\n    }\r\n    if (obj instanceof Border3D) {\r\n        Border3D other = (Border3D) obj;\r\n        return other.top == top && other.bottom == bottom && other.sides == sides;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "springfox.documentation.spring.web.plugins.Docket.globalResponseMessage",
	"Comment": "overrides the default http response messages at the http request method level.to set specific response messages for specific api operations use the swagger core annotations onthe appropriate controller methods.",
	"Method": "Docket globalResponseMessage(RequestMethod requestMethod,List<ResponseMessage> responseMessages){\r\n    this.responseMessages.put(requestMethod, responseMessages);\r\n    return this;\r\n}"
}, {
	"Path": "org.terasology.logic.players.FirstPersonHeldItemMountPointComponent.poseChanged",
	"Comment": "a callback target for the controller listener. when this callback triggers, the pos of the mount point willcuange to the value of the pose parameter. this is mainly designed as a callback, and not intended to be partof the public interface of this class.",
	"Method": "void poseChanged(Matrix4f pose,int handIndex){\r\n    if (handIndex != 0) {\r\n        return;\r\n    }\r\n    trackingDataReceived = true;\r\n    Matrix4f adjustedPose = pose.mul(toolAdjustmentMatrix);\r\n    translate = new Vector3f(adjustedPose.m30(), adjustedPose.m31(), adjustedPose.m32());\r\n    org.joml.Vector4f jomlQuaternion = org.terasology.rendering.openvrprovider.OpenVRUtil.convertToQuaternion(adjustedPose);\r\n    if (rotationQuaternion == null) {\r\n        rotationQuaternion = new Quat4f(jomlQuaternion.x, jomlQuaternion.y, jomlQuaternion.z, jomlQuaternion.w);\r\n    } else {\r\n        rotationQuaternion.set(jomlQuaternion.x, jomlQuaternion.y, jomlQuaternion.z, jomlQuaternion.w);\r\n    }\r\n}"
}, {
	"Path": "org.terasology.engine.TerasologyEngine.postInitSubsystems",
	"Comment": "gives a chance to subsystems to do something after managers and time are initialized.",
	"Method": "void postInitSubsystems(){\r\n    for (EngineSubsystem subsystem : getSubsystems()) {\r\n        changeStatus(() -> \"Post-Initialising \" + subsystem.getName() + \" subsystem\");\r\n        subsystem.postInitialise(rootContext);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.config.http.UserDetailsServiceFactoryBean.getUserDetailsService",
	"Comment": "obtains a user details service for use in remembermeservices etc. will return a\tcaching version if available so should not be used for beans which need to separate\tthe two.",
	"Method": "UserDetailsService getUserDetailsService(){\r\n    Map<String, ?> beans = getBeansOfType(CachingUserDetailsService.class);\r\n    if (beans.size() == 0) {\r\n        beans = getBeansOfType(UserDetailsService.class);\r\n    }\r\n    if (beans.size() == 0) {\r\n        throw new ApplicationContextException(\"No UserDetailsService registered.\");\r\n    } else if (beans.size() > 1) {\r\n        throw new ApplicationContextException(\"More than one UserDetailsService registered. Please \" + \"use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements.\");\r\n    }\r\n    return (UserDetailsService) beans.values().toArray()[0];\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint.determineUrlToUseForThisRequest",
	"Comment": "allows subclasses to modify the login form url that should be applicable for a\tgiven request.",
	"Method": "String determineUrlToUseForThisRequest(HttpServletRequest request,HttpServletResponse response,AuthenticationException exception){\r\n    return getLoginFormUrl();\r\n}"
}, {
	"Path": "org.springframework.security.web.access.intercept.FilterSecurityInterceptorTests.testSuccessfulInvocation",
	"Comment": "we just test invocation works in a success event. there is no need to test access\tdenied events as the abstract parent enforces that logic, which is extensively\ttested separately.",
	"Method": "void testSuccessfulInvocation(){\r\n    Authentication token = new TestingAuthenticationToken(\"Test\", \"Password\", \"NOT_USED\");\r\n    SecurityContextHolder.getContext().setAuthentication(token);\r\n    FilterInvocation fi = createinvocation();\r\n    when(ods.getAttributes(fi)).thenReturn(SecurityConfig.createList(\"MOCK_OK\"));\r\n    interceptor.invoke(fi);\r\n    verify(publisher, never()).publishEvent(any(AuthorizedEvent.class));\r\n}"
}, {
	"Path": "org.terasology.utilities.procedural.BrownianNoise.setLacunarity",
	"Comment": "lacunarity is what makes the frequency grow. each octavethe frequency is multiplied by the lacunarity.",
	"Method": "void setLacunarity(double lacunarity){\r\n    this.lacunarity = lacunarity;\r\n}"
}, {
	"Path": "org.terasology.network.internal.ClientConnectionHandler.receivedServerInfo",
	"Comment": "gets the server information and passes it to the client, while also checking if all required modules have been downloaded.",
	"Method": "void receivedServerInfo(ChannelHandlerContext channelHandlerContext,NetData.ServerInfoMessage message){\r\n    logger.info(\"Received server info\");\r\n    ((EngineTime) CoreRegistry.get(Time.class)).setGameTime(message.getTime());\r\n    this.server = new ServerImpl(networkSystem, channelHandlerContext.getChannel());\r\n    server.setServerInfo(message);\r\n    for (NetData.ModuleInfo info : message.getModuleList()) {\r\n        if (null == moduleManager.getRegistry().getModule(new Name(info.getModuleId()), new Version(info.getModuleVersion()))) {\r\n            missingModules.add(info.getModuleId().toLowerCase(Locale.ENGLISH));\r\n        }\r\n    }\r\n    if (missingModules.isEmpty()) {\r\n        joinStatus.setCurrentActivity(\"Finalizing join\");\r\n        sendJoin(channelHandlerContext);\r\n    } else {\r\n        joinStatus.setCurrentActivity(\"Requesting missing modules\");\r\n        NetData.NetMessage.Builder builder = NetData.NetMessage.newBuilder();\r\n        for (String module : missingModules) {\r\n            builder.addModuleRequest(NetData.ModuleRequest.newBuilder().setModuleId(module));\r\n        }\r\n        channelHandlerContext.getChannel().write(builder.build());\r\n    }\r\n}"
}, {
	"Path": "org.terasology.rendering.animation.TimeModifiers.square",
	"Comment": "always the square of the the given value. useful for constant accelerations.",
	"Method": "TimeModifier square(){\r\n    return v -> v * v;\r\n}"
}, {
	"Path": "org.springframework.security.config.annotation.web.configurers.UrlAuthorizationConfigurer.hasAnyAuthority",
	"Comment": "creates a string for specifying that a user requires one of many authorities",
	"Method": "String[] hasAnyAuthority(String authorities,StandardInterceptUrlRegistry hasAnyAuthority,String authorities){\r\n    return authorities;\r\n}"
}, {
	"Path": "org.springframework.security.crypto.bcrypt.BCrypt.checkpw",
	"Comment": "check that a plaintext password matches a previously hashed",
	"Method": "boolean checkpw(String plaintext,String hashed){\r\n    return equalsNoEarlyReturn(hashed, hashpw(plaintext, hashed));\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.widgets.UIRadialSection.addListener",
	"Comment": "add a listener to this section. it will be fired when the section is activated",
	"Method": "void addListener(ActivateEventListener listener){\r\n    if (listeners == null) {\r\n        listeners = new ArrayList();\r\n    }\r\n    listeners.add(listener);\r\n}"
}, {
	"Path": "org.terasology.audio.formats.OggReader.available",
	"Comment": "returns 0 after eof is reached, otherwise always return 1.programs should not count on this method to return the actual number ofbytes that could be read without blocking.",
	"Method": "int available(){\r\n    return (eos ? 0 : 1);\r\n}"
}, {
	"Path": "org.terasology.network.internal.ClientConnectionHandler.scheduleTimeout",
	"Comment": "sets timeout threshold, if client exceeds this time during connection it will automatically close the channel.",
	"Method": "void scheduleTimeout(Channel inputChannel){\r\n    channel = inputChannel;\r\n    timeoutPoint = System.currentTimeMillis() + timeoutThreshold;\r\n    timeoutTimer.schedule(new java.util.TimerTask() {\r\n        @Override\r\n        public void run() {\r\n            synchronized (joinStatus) {\r\n                if (System.currentTimeMillis() > timeoutPoint && joinStatus.getStatus() != JoinStatus.Status.COMPLETE && joinStatus.getStatus() != JoinStatus.Status.FAILED) {\r\n                    joinStatus.setErrorMessage(\"Server stopped responding.\");\r\n                    channel.close();\r\n                    logger.error(\"Server timeout threshold of {} ms exceeded.\", timeoutThreshold);\r\n                }\r\n            }\r\n        }\r\n    }, timeoutThreshold + 200);\r\n}"
}, {
	"Path": "org.terasology.network.internal.ClientConnectionHandler.scheduleTimeout",
	"Comment": "sets timeout threshold, if client exceeds this time during connection it will automatically close the channel.",
	"Method": "void scheduleTimeout(Channel inputChannel){\r\n    synchronized (joinStatus) {\r\n        if (System.currentTimeMillis() > timeoutPoint && joinStatus.getStatus() != JoinStatus.Status.COMPLETE && joinStatus.getStatus() != JoinStatus.Status.FAILED) {\r\n            joinStatus.setErrorMessage(\"Server stopped responding.\");\r\n            channel.close();\r\n            logger.error(\"Server timeout threshold of {} ms exceeded.\", timeoutThreshold);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.terasology.rendering.world.ChunkMeshUpdateManager.setCameraPosition",
	"Comment": "the method tells the chunk mesh update manager where the camera is, so that is able to prioritize chunks near thecamera. it stores the values in volatile variables so that the change is visible to the chunk updating threadsimmediately.",
	"Method": "void setCameraPosition(Vector3f cameraPosition){\r\n    Vector3i chunkPos = ChunkMath.calcChunkPos(cameraPosition);\r\n    cameraChunkPosX = chunkPos.x;\r\n    cameraChunkPosY = chunkPos.y;\r\n    cameraChunkPosZ = chunkPos.z;\r\n}"
}, {
	"Path": "org.terasology.persistence.serializers.ComponentSerializer.removeIdMapping",
	"Comment": "clears the mapping between component classes and ids. this causes components to be serialized with their componentclass name instead.",
	"Method": "void removeIdMapping(){\r\n    idTable = ImmutableBiMap.<Class<? extends Component>, Integer>builder().build();\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.www.DigestAuthUtils.splitEachArrayElementAndCreateMap",
	"Comment": "takes an array of strings, and for each element removes any instances\tof removecharacter, and splits the element based on the\tdelimiter. a map is then generated, with the left of the\tdelimiter providing the key, and the right of the delimiter providing the value.\twill trim both the key and value before adding to the map.",
	"Method": "Map<String, String> splitEachArrayElementAndCreateMap(String[] array,String delimiter,String removeCharacters){\r\n    if ((array == null) || (array.length == 0)) {\r\n        return null;\r\n    }\r\n    Map<String, String> map = new HashMap();\r\n    for (String s : array) {\r\n        String postRemove;\r\n        if (removeCharacters == null) {\r\n            postRemove = s;\r\n        } else {\r\n            postRemove = StringUtils.replace(s, removeCharacters, \"\");\r\n        }\r\n        String[] splitThisArrayElement = split(postRemove, delimiter);\r\n        if (splitThisArrayElement == null) {\r\n            continue;\r\n        }\r\n        map.put(splitThisArrayElement[0].trim(), splitThisArrayElement[1].trim());\r\n    }\r\n    return map;\r\n}"
}, {
	"Path": "org.terasology.input.InputSystem.processKeyboardInput",
	"Comment": "processes input actions by keyboard buttons, sends key events and updates bind buttons accordingly.",
	"Method": "void processKeyboardInput(float delta){\r\n    Queue<KeyboardAction> keyQueue = keyboard.getInputQueue();\r\n    keyQueue.addAll(simulatedKeys);\r\n    simulatedKeys.clear();\r\n    for (KeyboardAction action : keyQueue) {\r\n        boolean consumed = sendKeyEvent(action.getInput(), action.getInputChar(), action.getState(), delta);\r\n        BindableButton bind = bindsManager.getKeyBinds().get(action.getInput().getId());\r\n        if (bind != null && action.getState() != ButtonState.REPEAT) {\r\n            boolean pressed = action.getState() == ButtonState.DOWN;\r\n            updateBindState(bind, action.getInput(), pressed, delta, consumed);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.terasology.rendering.dag.nodes.OverlaysNode.disableWireframe",
	"Comment": "disables wireframe.notice that this is just a request and wireframe gets disabled only after therendering task list has been refreshed. this occurs before the beginningof next frame or earlier.",
	"Method": "void disableWireframe(){\r\n    if (getDesiredStateChanges().contains(wireframeStateChange)) {\r\n        removeDesiredStateChange(wireframeStateChange);\r\n        worldRenderer.requestTaskListRefresh();\r\n    }\r\n}"
}, {
	"Path": "org.terasology.utilities.concurrency.TaskMaster.offer",
	"Comment": "offers a task to this task master. this does not block, but may fail if the queue is full.",
	"Method": "boolean offer(T task){\r\n    return taskQueue.offer(task);\r\n}"
}, {
	"Path": "springfox.documentation.spring.web.WebMvcPropertySourcedRequestMappingHandlerMapping.lookupHandlerMethod",
	"Comment": "the lookup handler method, maps the seomapper method to the request url.if no mapping is found, or if the url is disabled, it will simply drop throughto the standard 404 handling.",
	"Method": "HandlerMethod lookupHandlerMethod(String urlPath,HttpServletRequest request){\r\n    logger.debug(\"looking up handler for path: \" + urlPath);\r\n    HandlerMethod handlerMethod = handlerMethods.get(urlPath);\r\n    if (handlerMethod != null) {\r\n        return handlerMethod;\r\n    }\r\n    for (String path : handlerMethods.keySet()) {\r\n        UriTemplate template = new UriTemplate(path);\r\n        if (template.matches(urlPath)) {\r\n            request.setAttribute(HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE, template.match(urlPath));\r\n            return handlerMethods.get(path);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.security.config.doc.SpringSecurityXsdParser.elmt",
	"Comment": "given an element creates an element out of it by collecting all its attributes and child elements.",
	"Method": "Element elmt(XmlNode n){\r\n    String name = n.attribute(\"ref\");\r\n    if (StringUtils.isEmpty(name)) {\r\n        name = n.attribute(\"name\");\r\n    } else {\r\n        name = name.split(\":\")[1];\r\n        n = findNode(n, name);\r\n    }\r\n    if (this.elementNameToElement.containsKey(name)) {\r\n        return this.elementNameToElement.get(name);\r\n    }\r\n    this.attrElmts.add(name);\r\n    Element e = new Element();\r\n    e.setName(n.attribute(\"name\"));\r\n    e.setDesc(desc(n));\r\n    e.setChildElmts(elements(n));\r\n    e.setAttrs(attrs(n));\r\n    e.getAttrs().addAll(attrgrps(n));\r\n    e.getAttrs().forEach(attr -> attr.setElmt(e));\r\n    e.getChildElmts().values().forEach(element -> element.getParentElmts().put(e.getName(), e));\r\n    String subGrpName = n.attribute(\"substitutionGroup\");\r\n    if (!StringUtils.isEmpty(subGrpName)) {\r\n        Element subGrp = elmt(findNode(n, subGrpName.split(\":\")[1]));\r\n        subGrp.getSubGrps().add(e);\r\n    }\r\n    this.elementNameToElement.put(name, e);\r\n    return e;\r\n}"
}, {
	"Path": "org.springframework.security.authentication.jaas.AbstractJaasAuthenticationProvider.setLoginContextName",
	"Comment": "set the logincontextname, this name is used as the index to the configuration\tspecified in the loginconfig property.",
	"Method": "void setLoginContextName(String loginContextName){\r\n    this.loginContextName = loginContextName;\r\n}"
}, {
	"Path": "org.terasology.utilities.random.Random.nextItem",
	"Comment": "returns a random item from the given list, or null is the list is empty",
	"Method": "T nextItem(List<T> list){\r\n    if (list.isEmpty()) {\r\n        return null;\r\n    }\r\n    return list.get(nextInt(list.size()));\r\n}"
}, {
	"Path": "org.terasology.entitySystem.sectors.SectorUtil.onlyWatchedChunk",
	"Comment": "calculate whether the entity is watching no loaded chunks, or only the given chunk is loaded.",
	"Method": "boolean onlyWatchedChunk(EntityRef entity,Vector3i chunkPos,ChunkProvider chunkProvider){\r\n    Set<Vector3i> readyChunks = getWatchedChunks(entity).stream().filter(chunkProvider::isChunkReady).collect(Collectors.toSet());\r\n    return readyChunks.isEmpty() || (readyChunks.size() == 1 && readyChunks.contains(chunkPos));\r\n}"
}, {
	"Path": "org.terasology.utilities.procedural.BrownianNoiseOld.setLacunarity",
	"Comment": "lacunarity is what makes the frequency grow. each octavethe frequency is multiplied by the lacunarity.",
	"Method": "void setLacunarity(double lacunarity){\r\n    this.lacunarity = lacunarity;\r\n}"
}, {
	"Path": "org.terasology.rendering.dag.nodes.FinalPostProcessingNode.process",
	"Comment": "execute the final post processing on the rendering of the scene obtained so far.it uses the data stored in multiple fbos as input and the final fbo to store its output, rendering everything to a quad.",
	"Method": "void process(){\r\n    PerformanceMonitor.startActivity(\"rendering/\" + getUri());\r\n    postMaterial.setFloat(\"focalDistance\", cameraTargetSystem.getFocalDistance(), true);\r\n    if (isFilmGrainEnabled) {\r\n        postMaterial.setFloat(\"grainIntensity\", filmGrainIntensity, true);\r\n        postMaterial.setFloat(\"noiseOffset\", randomGenerator.nextFloat(), true);\r\n        postMaterial.setFloat2(\"noiseSize\", noiseTextureSize, noiseTextureSize, true);\r\n        postMaterial.setFloat2(\"renderTargetSize\", lastUpdatedGBuffer.width(), lastUpdatedGBuffer.height(), true);\r\n    }\r\n    if (isMotionBlurEnabled) {\r\n        postMaterial.setMatrix4(\"invViewProjMatrix\", activeCamera.getInverseViewProjectionMatrix(), true);\r\n        postMaterial.setMatrix4(\"prevViewProjMatrix\", activeCamera.getPrevViewProjectionMatrix(), true);\r\n    }\r\n    renderFullscreenQuad();\r\n    if (screenGrabber.isTakingScreenshot()) {\r\n        screenGrabber.saveScreenshot();\r\n    }\r\n    PerformanceMonitor.endActivity();\r\n}"
}, {
	"Path": "org.terasology.math.AABB.createMinMax",
	"Comment": "creates a new aabb from the given minimum and maximum points, both inclusive.",
	"Method": "AABB createMinMax(Vector3f min,Vector3f max){\r\n    return new AABB(new Vector3f(min), new Vector3f(max));\r\n}"
}, {
	"Path": "org.terasology.documentation.apiScraper.CompleteApiScraper.addToApi",
	"Comment": "adds interface or class and their methods and constructors to apiare also added.",
	"Method": "void addToApi(String category,Class<?> apiClass,Multimap<String, String> api){\r\n    String className = apiClass.getName();\r\n    String type;\r\n    if (apiClass.isInterface()) {\r\n        type = \" (INTERFACE)\";\r\n    } else {\r\n        int modifier = apiClass.getModifiers();\r\n        if (Modifier.isAbstract(modifier)) {\r\n            type = \" (ABSTRACT CLASS)\";\r\n        } else {\r\n            type = \" (CLASS)\";\r\n        }\r\n    }\r\n    api.put(category, className + type);\r\n    Constructor[] constructors = apiClass.getDeclaredConstructors();\r\n    for (Constructor constructor : constructors) {\r\n        api.put(category, \" - \" + constructor.getName() + \" (CONSTRUCTOR)\");\r\n        api.put(category, \" -- \" + Arrays.toString(constructor.getParameterTypes()) + \" (PARAMETERS)\");\r\n    }\r\n    Method[] methods = apiClass.getDeclaredMethods();\r\n    for (Method method : methods) {\r\n        if (!method.isDefault() && !method.isBridge() && !method.isSynthetic()) {\r\n            int modifier = method.getModifiers();\r\n            if (Modifier.isAbstract(modifier)) {\r\n                type = \" (ABSTRACT METHOD)\";\r\n            } else {\r\n                type = \" (METHOD)\";\r\n            }\r\n            api.put(category, \" - \" + method.getName() + type);\r\n            api.put(category, \" -- \" + method.getReturnType() + \" (RETURN)\");\r\n            api.put(category, \" -- \" + Arrays.toString(method.getParameterTypes()) + \" (PARAMETERS)\");\r\n            api.put(category, \" -- \" + Arrays.toString(method.getExceptionTypes()) + \" (EXCEPTIONS)\");\r\n        } else if (method.isDefault() && apiClass.isInterface()) {\r\n            api.put(category, \" - \" + method.getName() + \" (DEFAULT METHOD)\");\r\n            api.put(category, \" -- \" + method.getReturnType() + \" (RETURN)\");\r\n            api.put(category, \" -- \" + Arrays.toString(method.getParameterTypes()) + \" (PARAMETERS)\");\r\n            api.put(category, \" -- \" + Arrays.toString(method.getExceptionTypes()) + \" (EXCEPTIONS)\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.ldap.ppolicy.PasswordPolicyResponseControl.getEncodedValue",
	"Comment": "returns the unchanged value of the response control. returns the unchanged value of\tthe response control as byte array.",
	"Method": "byte[] getEncodedValue(){\r\n    return this.encodedValue;\r\n}"
}, {
	"Path": "springfox.documentation.spi.schema.contexts.ModelPropertyContext.getBuilder",
	"Comment": "model property build. use this to override model property attributes",
	"Method": "ModelPropertyBuilder getBuilder(){\r\n    return builder;\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.layers.mainMenu.WorldPreGenerationScreen.findWorldByName",
	"Comment": "this method takes the name of the world selected in the worldsdropdownas string and return the corresponding worldsetupwrapper object.",
	"Method": "WorldSetupWrapper findWorldByName(String searchWorld){\r\n    for (WorldSetupWrapper world : worldList) {\r\n        if (world.getWorldName().toString().equals(searchWorld)) {\r\n            return world;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "springfox.documentation.builders.RequestHandlerSelectors.withMethodAnnotation",
	"Comment": "predicate that matches requesthandler with handlers methods annotated with given annotation",
	"Method": "Predicate<RequestHandler> withMethodAnnotation(Class<? extends Annotation> annotation){\r\n    return input -> input.isAnnotatedWith(annotation);\r\n}"
}, {
	"Path": "org.springframework.security.config.http.DefaultFilterChainValidator.checkLoginPageIsntProtected",
	"Comment": "checks for the common error of having a login page url protected by the security\tinterceptor",
	"Method": "void checkLoginPageIsntProtected(FilterChainProxy fcp,List<Filter> filterStack){\r\n    ExceptionTranslationFilter etf = getFilter(ExceptionTranslationFilter.class, filterStack);\r\n    if (etf == null || !(etf.getAuthenticationEntryPoint() instanceof LoginUrlAuthenticationEntryPoint)) {\r\n        return;\r\n    }\r\n    String loginPage = ((LoginUrlAuthenticationEntryPoint) etf.getAuthenticationEntryPoint()).getLoginFormUrl();\r\n    logger.info(\"Checking whether login URL '\" + loginPage + \"' is accessible with your configuration\");\r\n    FilterInvocation loginRequest = new FilterInvocation(loginPage, \"POST\");\r\n    List<Filter> filters = null;\r\n    try {\r\n        filters = fcp.getFilters(loginPage);\r\n    } catch (Exception e) {\r\n        logger.info(\"Failed to obtain filter chain information for the login page. Unable to complete check.\");\r\n    }\r\n    if (filters == null || filters.isEmpty()) {\r\n        logger.debug(\"Filter chain is empty for the login page\");\r\n        return;\r\n    }\r\n    if (getFilter(DefaultLoginPageGeneratingFilter.class, filters) != null) {\r\n        logger.debug(\"Default generated login page is in use\");\r\n        return;\r\n    }\r\n    FilterSecurityInterceptor fsi = getFilter(FilterSecurityInterceptor.class, filters);\r\n    FilterInvocationSecurityMetadataSource fids = fsi.getSecurityMetadataSource();\r\n    Collection<ConfigAttribute> attributes = fids.getAttributes(loginRequest);\r\n    if (attributes == null) {\r\n        logger.debug(\"No access attributes defined for login page URL\");\r\n        if (fsi.isRejectPublicInvocations()) {\r\n            logger.warn(\"FilterSecurityInterceptor is configured to reject public invocations.\" + \" Your login page may not be accessible.\");\r\n        }\r\n        return;\r\n    }\r\n    AnonymousAuthenticationFilter anonPF = getFilter(AnonymousAuthenticationFilter.class, filters);\r\n    if (anonPF == null) {\r\n        logger.warn(\"The login page is being protected by the filter chain, but you don't appear to have\" + \" anonymous authentication enabled. This is almost certainly an error.\");\r\n        return;\r\n    }\r\n    AnonymousAuthenticationToken token = new AnonymousAuthenticationToken(\"key\", anonPF.getPrincipal(), anonPF.getAuthorities());\r\n    try {\r\n        fsi.getAccessDecisionManager().decide(token, loginRequest, attributes);\r\n    } catch (AccessDeniedException e) {\r\n        logger.warn(\"Anonymous access to the login page doesn't appear to be enabled. This is almost certainly \" + \"an error. Please check your configuration allows unauthenticated access to the configured \" + \"login page. (Simulated access was rejected: \" + e + \")\");\r\n    } catch (Exception e) {\r\n        logger.info(\"Unable to check access to the login page to determine if anonymous access is allowed. This might be an error, but can happen under normal circumstances.\", e);\r\n    }\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.skin.UIStyle.getVerticalAlignment",
	"Comment": "if the element does not use the full height of the available to it, how should it be aligned",
	"Method": "VerticalAlign getVerticalAlignment(){\r\n    return alignmentV;\r\n}"
}, {
	"Path": "org.springframework.security.ldap.authentication.AbstractLdapAuthenticator.getUserDns",
	"Comment": "builds list of possible dns for the user, worked out from the\tuserdnpatterns property.",
	"Method": "List<String> getUserDns(String username){\r\n    if (userDnFormat == null) {\r\n        return Collections.emptyList();\r\n    }\r\n    List<String> userDns = new ArrayList(userDnFormat.length);\r\n    String[] args = new String[] { LdapEncoder.nameEncode(username) };\r\n    synchronized (userDnFormat) {\r\n        for (MessageFormat formatter : userDnFormat) {\r\n            userDns.add(formatter.format(args));\r\n        }\r\n    }\r\n    return userDns;\r\n}"
}, {
	"Path": "org.terasology.documentation.apiScraper.ApiComparator.getApi",
	"Comment": "reads an api file and puts its information in a map to be used in the api comparison.",
	"Method": "Map<String, Collection<ApiMethod>> getApi(BufferedReader br){\r\n    String line = br.readLine();\r\n    Map<String, Collection<ApiMethod>> api = new HashMap();\r\n    while (line != null) {\r\n        if (line.startsWith(\"*\")) {\r\n            if (line.endsWith(\"(PACKAGE)\")) {\r\n                line = br.readLine();\r\n                continue;\r\n            }\r\n            String className = line;\r\n            String aux;\r\n            api.put(className, new ArrayList());\r\n            ApiMethod method;\r\n            aux = br.readLine();\r\n            while ((aux != null && (aux.endsWith(\"(METHOD)\") || aux.endsWith(\"(CONSTRUCTOR)\") || aux.endsWith(\"(ABSTRACT METHOD)\") || aux.endsWith(\"(DEFAULT METHOD)\")))) {\r\n                if (aux.endsWith(\"(METHOD)\") || aux.endsWith(\"(ABSTRACT METHOD)\") || aux.endsWith(\"(DEFAULT METHOD)\")) {\r\n                    String returnType = br.readLine();\r\n                    String parameters = br.readLine();\r\n                    String exceptionType = br.readLine();\r\n                    method = new ApiMethod(className, aux, returnType, exceptionType, parameters);\r\n                } else {\r\n                    String returnType = \"\";\r\n                    String parameters = br.readLine();\r\n                    String exceptionType = \"\";\r\n                    method = new ApiMethod(className, aux, returnType, exceptionType, parameters);\r\n                }\r\n                api.get(className).add(method);\r\n                aux = br.readLine();\r\n            }\r\n            line = aux;\r\n        } else {\r\n            line = br.readLine();\r\n        }\r\n    }\r\n    return api;\r\n}"
}, {
	"Path": "org.springframework.security.web.server.authentication.AuthenticationWebFilter.setAuthenticationFailureHandler",
	"Comment": "sets the failure handler used when authentication fails. the default is to prompt for basic authentication.",
	"Method": "void setAuthenticationFailureHandler(ServerAuthenticationFailureHandler authenticationFailureHandler){\r\n    Assert.notNull(authenticationFailureHandler, \"authenticationFailureHandler cannot be null\");\r\n    this.authenticationFailureHandler = authenticationFailureHandler;\r\n}"
}, {
	"Path": "org.terasology.rendering.world.viewDistance.ClientViewDistanceSystem.onIncreaseViewDistance",
	"Comment": "increases view distance upon receiving an increase view distance event.",
	"Method": "void onIncreaseViewDistance(IncreaseViewDistanceButton button,EntityRef entity){\r\n    int viewDistance = config.getRendering().getViewDistance().getIndex();\r\n    int maxViewDistance = ViewDistance.values().length - 1;\r\n    if (viewDistance != maxViewDistance) {\r\n        ViewDistance greaterViewDistance = ViewDistance.forIndex(viewDistance + 1);\r\n        String greaterViewDistanceStr = translationSystem.translate(greaterViewDistance.toString());\r\n        fireChangeEvent(\"Increasing view distance to \" + greaterViewDistanceStr + \".\", Arrays.asList(entity));\r\n        if (greaterViewDistance == ViewDistance.MEGA || greaterViewDistance == ViewDistance.EXTREME) {\r\n            fireChangeEvent(\"Warning: Increasing view distance to \" + greaterViewDistanceStr + \" may result in performance issues.\", Arrays.asList(entity));\r\n        }\r\n        config.getRendering().setViewDistance(greaterViewDistance);\r\n    }\r\n    button.consume();\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilter.successfulAuthentication",
	"Comment": "puts the authentication instance returned by the authentication\tmanager into the secure context.",
	"Method": "void successfulAuthentication(HttpServletRequest request,HttpServletResponse response,Authentication authResult){\r\n    if (logger.isDebugEnabled()) {\r\n        logger.debug(\"Authentication success: \" + authResult);\r\n    }\r\n    SecurityContextHolder.getContext().setAuthentication(authResult);\r\n    if (this.eventPublisher != null) {\r\n        eventPublisher.publishEvent(new InteractiveAuthenticationSuccessEvent(authResult, this.getClass()));\r\n    }\r\n    if (authenticationSuccessHandler != null) {\r\n        authenticationSuccessHandler.onAuthenticationSuccess(request, response, authResult);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.web.util.ThrowableAnalyzer.getFirstThrowableOfType",
	"Comment": "returns the first throwable from the passed in array that is assignable to the\tprovided type. a returned instance is safe to be cast to the specified type.\tif the passed in array is null or empty this method returns null.",
	"Method": "Throwable getFirstThrowableOfType(Class<? extends Throwable> throwableType,Throwable[] chain){\r\n    if (chain != null) {\r\n        for (Throwable t : chain) {\r\n            if ((t != null) && throwableType.isInstance(t)) {\r\n                return t;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.security.web.servlet.util.matcher.MvcRequestMatcher.setServletPath",
	"Comment": "the servlet path to match on. the default is undefined which means any servlet\tpath.",
	"Method": "void setServletPath(String servletPath){\r\n    this.servletPath = servletPath;\r\n}"
}, {
	"Path": "org.springframework.security.crypto.password.Pbkdf2PasswordEncoder.setAlgorithm",
	"Comment": "sets the algorithm to use. see\tsecretkeyfactory algorithms",
	"Method": "void setAlgorithm(SecretKeyFactoryAlgorithm secretKeyFactoryAlgorithm){\r\n    if (secretKeyFactoryAlgorithm == null) {\r\n        throw new IllegalArgumentException(\"secretKeyFactoryAlgorithm cannot be null\");\r\n    }\r\n    String algorithmName = secretKeyFactoryAlgorithm.name();\r\n    try {\r\n        SecretKeyFactory.getInstance(algorithmName);\r\n    } catch (NoSuchAlgorithmException e) {\r\n        throw new IllegalArgumentException(\"Invalid algorithm '\" + algorithmName + \"'.\", e);\r\n    }\r\n    this.algorithm = algorithmName;\r\n}"
}, {
	"Path": "org.terasology.entitySystem.entity.internal.PojoEntityManager.createEntityWithoutLifecycleEvents",
	"Comment": "creates the entity without sending any events. the entity life cycle subscriber will however be informed.",
	"Method": "EntityRef createEntityWithoutLifecycleEvents(Iterable<Component> components,EntityRef createEntityWithoutLifecycleEvents,String prefabName,EntityRef createEntityWithoutLifecycleEvents,Prefab prefab){\r\n    return getCurrentWorldPool().createEntityWithoutLifecycleEvents(prefab);\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.layouts.ScrollableArea.drawWithBoth",
	"Comment": "draw the widget with both the horizontal and vertical scrollbars",
	"Method": "void drawWithBoth(Canvas canvas,Vector2i availableSize,Vector2i contentSize){\r\n    boolean atBottom = verticalBar.getRange() == verticalBar.getValue();\r\n    Rect2i contentRegion = Rect2i.createFromMinAndSize(Vector2i.zero(), availableSize);\r\n    verticalBar.setRange(contentSize.y - contentRegion.height());\r\n    horizontalBar.setRange(contentSize.x - contentRegion.width());\r\n    if ((stickToBottom && atBottom) || moveToBottomPending) {\r\n        verticalBar.setValue(verticalBar.getRange());\r\n        moveToBottomPending = false;\r\n    }\r\n    if (moveToTopPending) {\r\n        verticalBar.setValue(0);\r\n        moveToTopPending = false;\r\n    }\r\n    canvas.addInteractionRegion(scrollListener);\r\n    canvas.drawWidget(verticalBar, Rect2i.createFromMinAndSize(new Vector2i(availableSize.x, 0), canvas.calculateRestrictedSize(verticalBar, availableSize)));\r\n    canvas.drawWidget(horizontalBar, Rect2i.createFromMinAndSize(new Vector2i(0, availableSize.y), canvas.calculateRestrictedSize(horizontalBar, availableSize)));\r\n    try (SubRegion ignored = canvas.subRegion(contentRegion, true)) {\r\n        canvas.drawWidget(content, Rect2i.createFromMinAndSize(-horizontalBar.getValue(), -verticalBar.getValue(), contentSize.x, contentSize.y));\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.web.header.writers.HstsHeaderWriter.setIncludeSubDomains",
	"Comment": "if true, subdomains should be considered hsts hosts too. the default is true.\tsee section 6.1.2\tfor additional details.",
	"Method": "void setIncludeSubDomains(boolean includeSubDomains){\r\n    this.includeSubDomains = includeSubDomains;\r\n    updateHstsHeaderValue();\r\n}"
}, {
	"Path": "org.terasology.network.internal.HandshakeCommon.generateSymmetricKey",
	"Comment": "generates a symmetric encryption key from the master secret",
	"Method": "SecretKeySpec generateSymmetricKey(byte[] masterSecret,byte[] clientRandom,byte[] serverRandom){\r\n    return new SecretKeySpec(SecretGenerator.generate(masterSecret, SecretGenerator.KEY_EXPANSION, Bytes.concat(clientRandom, serverRandom), IdentityConstants.SYMMETRIC_ENCRYPTION_KEY_LENGTH), IdentityConstants.SYMMETRIC_ENCRYPTION_ALGORITHM);\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.layouts.ScrollableArea.moveToTop",
	"Comment": "moves the layout to display the bottom of the widget.equivalent to scrolling all the way up",
	"Method": "void moveToTop(){\r\n    moveToTopPending = true;\r\n}"
}, {
	"Path": "org.terasology.config.BindsConfig.isBound",
	"Comment": "returns true if an input has already been bound to another key",
	"Method": "boolean isBound(Input newInput){\r\n    return newInput != null && uriBoundInputs.containsValue(newInput);\r\n}"
}, {
	"Path": "org.terasology.rendering.cameras.ViewFrustum.updateFrustum",
	"Comment": "updates the view frustum using the currently active modelview and projection matrices.",
	"Method": "void updateFrustum(FloatBuffer modelViewMatrix,FloatBuffer projectionMatrix){\r\n    clip.put(0, modelViewMatrix.get(0) * projectionMatrix.get(0) + modelViewMatrix.get(1) * projectionMatrix.get(4) + modelViewMatrix.get(2) * projectionMatrix.get(8) + modelViewMatrix.get(3) * projectionMatrix.get(12));\r\n    clip.put(1, modelViewMatrix.get(0) * projectionMatrix.get(1) + modelViewMatrix.get(1) * projectionMatrix.get(5) + modelViewMatrix.get(2) * projectionMatrix.get(9) + modelViewMatrix.get(3) * projectionMatrix.get(13));\r\n    clip.put(2, modelViewMatrix.get(0) * projectionMatrix.get(2) + modelViewMatrix.get(1) * projectionMatrix.get(6) + modelViewMatrix.get(2) * projectionMatrix.get(10) + modelViewMatrix.get(3) * projectionMatrix.get(14));\r\n    clip.put(3, modelViewMatrix.get(0) * projectionMatrix.get(3) + modelViewMatrix.get(1) * projectionMatrix.get(7) + modelViewMatrix.get(2) * projectionMatrix.get(11) + modelViewMatrix.get(3) * projectionMatrix.get(15));\r\n    clip.put(4, modelViewMatrix.get(4) * projectionMatrix.get(0) + modelViewMatrix.get(5) * projectionMatrix.get(4) + modelViewMatrix.get(6) * projectionMatrix.get(8) + modelViewMatrix.get(7) * projectionMatrix.get(12));\r\n    clip.put(5, modelViewMatrix.get(4) * projectionMatrix.get(1) + modelViewMatrix.get(5) * projectionMatrix.get(5) + modelViewMatrix.get(6) * projectionMatrix.get(9) + modelViewMatrix.get(7) * projectionMatrix.get(13));\r\n    clip.put(6, modelViewMatrix.get(4) * projectionMatrix.get(2) + modelViewMatrix.get(5) * projectionMatrix.get(6) + modelViewMatrix.get(6) * projectionMatrix.get(10) + modelViewMatrix.get(7) * projectionMatrix.get(14));\r\n    clip.put(7, modelViewMatrix.get(4) * projectionMatrix.get(3) + modelViewMatrix.get(5) * projectionMatrix.get(7) + modelViewMatrix.get(6) * projectionMatrix.get(11) + modelViewMatrix.get(7) * projectionMatrix.get(15));\r\n    clip.put(8, modelViewMatrix.get(8) * projectionMatrix.get(0) + modelViewMatrix.get(9) * projectionMatrix.get(4) + modelViewMatrix.get(10) * projectionMatrix.get(8) + modelViewMatrix.get(11) * projectionMatrix.get(12));\r\n    clip.put(9, modelViewMatrix.get(8) * projectionMatrix.get(1) + modelViewMatrix.get(9) * projectionMatrix.get(5) + modelViewMatrix.get(10) * projectionMatrix.get(9) + modelViewMatrix.get(11) * projectionMatrix.get(13));\r\n    clip.put(10, modelViewMatrix.get(8) * projectionMatrix.get(2) + modelViewMatrix.get(9) * projectionMatrix.get(6) + modelViewMatrix.get(10) * projectionMatrix.get(10) + modelViewMatrix.get(11) * projectionMatrix.get(14));\r\n    clip.put(11, modelViewMatrix.get(8) * projectionMatrix.get(3) + modelViewMatrix.get(9) * projectionMatrix.get(7) + modelViewMatrix.get(10) * projectionMatrix.get(11) + modelViewMatrix.get(11) * projectionMatrix.get(15));\r\n    clip.put(12, modelViewMatrix.get(12) * projectionMatrix.get(0) + modelViewMatrix.get(13) * projectionMatrix.get(4) + modelViewMatrix.get(14) * projectionMatrix.get(8) + modelViewMatrix.get(15) * projectionMatrix.get(12));\r\n    clip.put(13, modelViewMatrix.get(12) * projectionMatrix.get(1) + modelViewMatrix.get(13) * projectionMatrix.get(5) + modelViewMatrix.get(14) * projectionMatrix.get(9) + modelViewMatrix.get(15) * projectionMatrix.get(13));\r\n    clip.put(14, modelViewMatrix.get(12) * projectionMatrix.get(2) + modelViewMatrix.get(13) * projectionMatrix.get(6) + modelViewMatrix.get(14) * projectionMatrix.get(10) + modelViewMatrix.get(15) * projectionMatrix.get(14));\r\n    clip.put(15, modelViewMatrix.get(12) * projectionMatrix.get(3) + modelViewMatrix.get(13) * projectionMatrix.get(7) + modelViewMatrix.get(14) * projectionMatrix.get(11) + modelViewMatrix.get(15) * projectionMatrix.get(15));\r\n    planes[0].setA(clip.get(3) - clip.get(0));\r\n    planes[0].setB(clip.get(7) - clip.get(4));\r\n    planes[0].setC(clip.get(11) - clip.get(8));\r\n    planes[0].setD(clip.get(15) - clip.get(12));\r\n    planes[0].normalize();\r\n    planes[1].setA(clip.get(3) + clip.get(0));\r\n    planes[1].setB(clip.get(7) + clip.get(4));\r\n    planes[1].setC(clip.get(11) + clip.get(8));\r\n    planes[1].setD(clip.get(15) + clip.get(12));\r\n    planes[1].normalize();\r\n    planes[2].setA(clip.get(3) + clip.get(1));\r\n    planes[2].setB(clip.get(7) + clip.get(5));\r\n    planes[2].setC(clip.get(11) + clip.get(9));\r\n    planes[2].setD(clip.get(15) + clip.get(13));\r\n    planes[2].normalize();\r\n    planes[3].setA(clip.get(3) - clip.get(1));\r\n    planes[3].setB(clip.get(7) - clip.get(5));\r\n    planes[3].setC(clip.get(11) - clip.get(9));\r\n    planes[3].setD(clip.get(15) - clip.get(13));\r\n    planes[3].normalize();\r\n    planes[4].setA(clip.get(3) - clip.get(2));\r\n    planes[4].setB(clip.get(7) - clip.get(6));\r\n    planes[4].setC(clip.get(11) - clip.get(10));\r\n    planes[4].setD(clip.get(15) - clip.get(14));\r\n    planes[4].normalize();\r\n    planes[5].setA(clip.get(3) + clip.get(2));\r\n    planes[5].setB(clip.get(7) + clip.get(6));\r\n    planes[5].setC(clip.get(11) + clip.get(10));\r\n    planes[5].setD(clip.get(15) + clip.get(14));\r\n    planes[5].normalize();\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.widgets.UIText.drawSelection",
	"Comment": "draws the selection indication which indicates that a certain part of the text is selected.",
	"Method": "void drawSelection(Canvas canvas){\r\n    Font font = canvas.getCurrentStyle().getFont();\r\n    String currentText = getText();\r\n    int start = Math.min(getCursorPosition(), selectionStart);\r\n    int end = Math.max(getCursorPosition(), selectionStart);\r\n    Color textColor = canvas.getCurrentStyle().getTextColor();\r\n    int canvasWidth = (multiline) ? canvas.size().x : Integer.MAX_VALUE;\r\n    List<String> rawLinesAfterCursor = TextLineBuilder.getLines(font, currentText, Integer.MAX_VALUE);\r\n    int currentChar = 0;\r\n    int lineOffset = 0;\r\n    for (int lineIndex = 0; lineIndex < rawLinesAfterCursor.size() && currentChar <= end; ++lineIndex) {\r\n        String line = rawLinesAfterCursor.get(lineIndex);\r\n        List<String> innerLines = TextLineBuilder.getLines(font, line, canvasWidth);\r\n        for (int innerLineIndex = 0; innerLineIndex < innerLines.size() && currentChar <= end; ++innerLineIndex) {\r\n            String innerLine = innerLines.get(innerLineIndex);\r\n            String selectionString;\r\n            int offsetX = 0;\r\n            if (currentChar + innerLine.length() < start) {\r\n                selectionString = \"\";\r\n            } else if (currentChar < start) {\r\n                offsetX = font.getWidth(innerLine.substring(0, start - currentChar));\r\n                selectionString = innerLine.substring(start - currentChar, Math.min(end - currentChar, innerLine.length()));\r\n            } else if (currentChar + innerLine.length() >= end) {\r\n                selectionString = innerLine.substring(0, end - currentChar);\r\n            } else {\r\n                selectionString = innerLine;\r\n            }\r\n            if (!selectionString.isEmpty()) {\r\n                int selectionWidth = font.getWidth(selectionString);\r\n                Vector2i selectionTopLeft = new Vector2i(offsetX, (lineOffset) * font.getLineHeight());\r\n                Rect2i region = Rect2i.createFromMinAndSize(selectionTopLeft.x, selectionTopLeft.y, selectionWidth, font.getLineHeight());\r\n                canvas.drawTexture(cursorTexture, region, textColor);\r\n                canvas.drawTextRaw(FontUnderline.strip(FontColor.stripColor(selectionString)), font, textColor.inverse(), region);\r\n            }\r\n            currentChar += innerLine.length();\r\n            lineOffset++;\r\n        }\r\n        currentChar++;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.session.ConcurrentSessionControlAuthenticationStrategy.allowableSessionsExceeded",
	"Comment": "allows subclasses to customise behaviour when too many sessions are detected.",
	"Method": "void allowableSessionsExceeded(List<SessionInformation> sessions,int allowableSessions,SessionRegistry registry){\r\n    if (exceptionIfMaximumExceeded || (sessions == null)) {\r\n        throw new SessionAuthenticationException(messages.getMessage(\"ConcurrentSessionControlAuthenticationStrategy.exceededAllowed\", new Object[] { Integer.valueOf(allowableSessions) }, \"Maximum sessions of {0} for this principal exceeded\"));\r\n    }\r\n    SessionInformation leastRecentlyUsed = null;\r\n    for (SessionInformation session : sessions) {\r\n        if ((leastRecentlyUsed == null) || session.getLastRequest().before(leastRecentlyUsed.getLastRequest())) {\r\n            leastRecentlyUsed = session;\r\n        }\r\n    }\r\n    leastRecentlyUsed.expireNow();\r\n}"
}, {
	"Path": "org.terasology.entitySystem.entity.internal.ComponentTable.entityIdIterator",
	"Comment": "produces an iterator for iterating over all entitiesthis is not designed to be performant, and in general usage entities should not be iterated over.",
	"Method": "TLongIterator entityIdIterator(){\r\n    TLongSet idSet = new TLongHashSet();\r\n    for (TLongObjectMap<Component> componentMap : store.values()) {\r\n        idSet.addAll(componentMap.keys());\r\n    }\r\n    return idSet.iterator();\r\n}"
}, {
	"Path": "org.springframework.security.oauth2.core.endpoint.OAuth2AccessTokenResponse.getAdditionalParameters",
	"Comment": "returns the additional parameters returned in the response.",
	"Method": "Map<String, Object> getAdditionalParameters(){\r\n    return this.additionalParameters;\r\n}"
}, {
	"Path": "org.springframework.security.access.intercept.aopalliance.MethodSecurityInterceptor.invoke",
	"Comment": "this method should be used to enforce security on a methodinvocation.",
	"Method": "Object invoke(MethodInvocation mi){\r\n    InterceptorStatusToken token = super.beforeInvocation(mi);\r\n    Object result;\r\n    try {\r\n        result = mi.proceed();\r\n    } finally {\r\n        super.finallyInvocation(token);\r\n    }\r\n    return super.afterInvocation(token, result);\r\n}"
}, {
	"Path": "org.terasology.utilities.procedural.BrownianNoiseOld.getLacunarity",
	"Comment": "lacunarity is what makes the frequency grow. each octavethe frequency is multiplied by the lacunarity.",
	"Method": "double getLacunarity(){\r\n    return this.lacunarity;\r\n}"
}, {
	"Path": "org.springframework.security.oauth2.core.AbstractOAuth2Token.getExpiresAt",
	"Comment": "returns the expiration time on or after which the token must not be accepted.",
	"Method": "Instant getExpiresAt(){\r\n    return this.expiresAt;\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.widgets.UIList.unsubscribeSelection",
	"Comment": "remove an event listener from being called when a selection is made.",
	"Method": "void unsubscribeSelection(ItemSelectEventListener<T> eventListener){\r\n    selectionListeners.remove(eventListener);\r\n}"
}, {
	"Path": "org.terasology.entitySystem.event.internal.EventSystemImpl.shouldAddToLibrary",
	"Comment": "events are added to the event library if they have a network annotation",
	"Method": "boolean shouldAddToLibrary(Class<? extends Event> eventType){\r\n    return eventType.getAnnotation(ServerEvent.class) != null || eventType.getAnnotation(OwnerEvent.class) != null || eventType.getAnnotation(BroadcastEvent.class) != null;\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.layers.mainMenu.WorldPreGenerationScreen.updatePreview",
	"Comment": "updates the preview according to any changes made to the configurator.also pops up a message and keeps track of percentage world preview prepared.",
	"Method": "void updatePreview(){\r\n    final NUIManager manager = context.get(NUIManager.class);\r\n    final WaitPopup<TextureData> popup = manager.pushScreen(WaitPopup.ASSET_URI, WaitPopup.class);\r\n    popup.setMessage(\"Updating Preview\", \"Please wait ...\");\r\n    ProgressListener progressListener = progress -> popup.setMessage(\"Updating Preview\", String.format(\"Please wait ... %d%%\", (int) (progress * 100f)));\r\n    Callable<TextureData> operation = () -> {\r\n        int zoom = TeraMath.floorToInt(zoomSlider.getValue());\r\n        TextureData data = texture.getData();\r\n        previewGen.render(data, zoom, progressListener);\r\n        return data;\r\n    };\r\n    popup.onSuccess(texture::reload);\r\n    popup.startOperation(operation, true);\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.layers.mainMenu.WorldPreGenerationScreen.createSeed",
	"Comment": "sets a unique seed by simply appending the world name with an incrementing number.",
	"Method": "String createSeed(String world){\r\n    return world + seedNumber++;\r\n}"
}, {
	"Path": "org.springframework.security.core.authority.mapping.SimpleAuthorityMapper.setConvertToUpperCase",
	"Comment": "whether to convert the authority value to upper case in the mapping.",
	"Method": "void setConvertToUpperCase(boolean convertToUpperCase){\r\n    this.convertToUpperCase = convertToUpperCase;\r\n}"
}, {
	"Path": "org.terasology.rendering.cameras.SubmersibleCamera.isUnderWater",
	"Comment": "returns true if the head of the player is underwater. false otherwise.takes in account waves if present.",
	"Method": "boolean isUnderWater(){\r\n    Vector3f cameraPosition = new Vector3f(this.getPosition());\r\n    if (renderingConfig.isAnimateWater()) {\r\n        cameraPosition.y -= RenderHelper.evaluateOceanHeightAtPosition(cameraPosition, worldProvider.getTime().getDays());\r\n    }\r\n    if (worldProvider.isBlockRelevant(cameraPosition)) {\r\n        return worldProvider.getBlock(cameraPosition).isLiquid();\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.rememberme.AbstractRememberMeServices.createSuccessfulAuthentication",
	"Comment": "creates the final authentication object returned from the\tautologin method.\tby default it will create a remembermeauthenticationtoken instance.",
	"Method": "Authentication createSuccessfulAuthentication(HttpServletRequest request,UserDetails user){\r\n    RememberMeAuthenticationToken auth = new RememberMeAuthenticationToken(key, user, authoritiesMapper.mapAuthorities(user.getAuthorities()));\r\n    auth.setDetails(authenticationDetailsSource.buildDetails(request));\r\n    return auth;\r\n}"
}, {
	"Path": "org.terasology.rendering.animation.Animation.pause",
	"Comment": "stops an animation without signaling that it is finished andmaintains its current state.",
	"Method": "Animation pause(){\r\n    if (currentState == AnimState.RUNNING) {\r\n        currentState = AnimState.PAUSED;\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.layouts.ScrollableArea.shouldDrawWithAxisScrollbar",
	"Comment": "checks if the area should display a scrollbar in a given axis.this method has been written to work for both horizontal and vertical checks.",
	"Method": "boolean shouldDrawWithAxisScrollbar(boolean axisScrollbarEnabled,boolean oppositeScrollbarEnabled,int axisAvailableSize,int oppositeAvailableSize,int axisContentSize,int oppositeContentSize,int oppositeScrollbarSize){\r\n    if (!axisScrollbarEnabled) {\r\n        return false;\r\n    } else {\r\n        if (willNeedScrollbar(axisAvailableSize, axisContentSize, 0)) {\r\n            return true;\r\n        } else {\r\n            if (willNeedScrollbar(axisAvailableSize, axisContentSize, oppositeScrollbarSize)) {\r\n                return true;\r\n            } else {\r\n                return oppositeScrollbarEnabled && willNeedScrollbar(oppositeAvailableSize, oppositeContentSize, 0);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl.loadGroupAuthorities",
	"Comment": "loads authorities by executing the sql from\tgroupauthoritiesbyusernamequery.",
	"Method": "List<GrantedAuthority> loadGroupAuthorities(String username){\r\n    return getJdbcTemplate().query(this.groupAuthoritiesByUsernameQuery, new String[] { username }, new RowMapper<GrantedAuthority>() {\r\n        @Override\r\n        public GrantedAuthority mapRow(ResultSet rs, int rowNum) throws SQLException {\r\n            String roleName = getRolePrefix() + rs.getString(3);\r\n            return new SimpleGrantedAuthority(roleName);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl.loadGroupAuthorities",
	"Comment": "loads authorities by executing the sql from\tgroupauthoritiesbyusernamequery.",
	"Method": "List<GrantedAuthority> loadGroupAuthorities(String username){\r\n    String roleName = getRolePrefix() + rs.getString(3);\r\n    return new SimpleGrantedAuthority(roleName);\r\n}"
}, {
	"Path": "org.terasology.math.AABB.transform",
	"Comment": "transform this aabb into a new aabb with the given rotation, offset and scale.",
	"Method": "AABB transform(Quat4f rotation,Vector3f offset,float scale,AABB transform,Transform transform,AABB transform,Transform transform,float margin){\r\n    Vector3f localHalfExtents = new Vector3f();\r\n    localHalfExtents.sub(max, min);\r\n    localHalfExtents.mul(HALVING_FACTOR);\r\n    localHalfExtents.x += margin;\r\n    localHalfExtents.y += margin;\r\n    localHalfExtents.z += margin;\r\n    Vector3f localCenter = new Vector3f(max);\r\n    localCenter.add(min);\r\n    localCenter.mul(HALVING_FACTOR);\r\n    Matrix3f absBasis = transform.getBasis();\r\n    absBasis.m00 = Math.abs(absBasis.m00);\r\n    absBasis.m01 = Math.abs(absBasis.m01);\r\n    absBasis.m02 = Math.abs(absBasis.m02);\r\n    absBasis.m10 = Math.abs(absBasis.m10);\r\n    absBasis.m11 = Math.abs(absBasis.m11);\r\n    absBasis.m12 = Math.abs(absBasis.m12);\r\n    absBasis.m20 = Math.abs(absBasis.m20);\r\n    absBasis.m21 = Math.abs(absBasis.m21);\r\n    absBasis.m22 = Math.abs(absBasis.m22);\r\n    Vector3f center = new Vector3f(localCenter);\r\n    absBasis.transform(center);\r\n    center.add(transform.origin);\r\n    Vector3f extent = new Vector3f();\r\n    extent.x = absBasis.getRow(0).dot(localHalfExtents);\r\n    extent.y = absBasis.getRow(1).dot(localHalfExtents);\r\n    extent.z = absBasis.getRow(2).dot(localHalfExtents);\r\n    Vector3f worldMin = new Vector3f();\r\n    worldMin.sub(center, extent);\r\n    Vector3f worldMax = new Vector3f(center).add(extent);\r\n    return AABB.createMinMax(worldMin, worldMax);\r\n}"
}, {
	"Path": "sample.contact.AddDeleteContactController.addContact",
	"Comment": "handles the submission of the contact form, creating a new instance if the username\tand email are valid.",
	"Method": "String addContact(WebContact form,BindingResult result){\r\n    validator.validate(form, result);\r\n    if (result.hasErrors()) {\r\n        return \"add\";\r\n    }\r\n    Contact contact = new Contact(form.getName(), form.getEmail());\r\n    contactManager.create(contact);\r\n    return \"redirect:/secure/index.htm\";\r\n}"
}, {
	"Path": "org.terasology.rendering.animation.Animation.start",
	"Comment": "notifies that this animation has been set up and is ready for use.",
	"Method": "Animation start(){\r\n    if (currentState == AnimState.STOPPED) {\r\n        currentState = AnimState.RUNNING;\r\n        elapsedTime = 0;\r\n        for (AnimationListener li : this.listeners) {\r\n            li.onStart();\r\n        }\r\n        updateAnimator();\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.widgets.UIText.decreaseCursorPosition",
	"Comment": "decrease the cursor position. this method moves the start of the selected text along with the cursor.",
	"Method": "int decreaseCursorPosition(int delta,boolean moveSelectionStart,int decreaseCursorPosition,int delta){\r\n    return decreaseCursorPosition(delta, true);\r\n}"
}, {
	"Path": "org.springframework.security.web.server.csrf.CookieServerCsrfTokenRepository.setCookieHttpOnly",
	"Comment": "sets the httponly attribute on the cookie containing the csrf token",
	"Method": "void setCookieHttpOnly(boolean cookieHttpOnly){\r\n    this.cookieHttpOnly = cookieHttpOnly;\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.layers.mainMenu.WorldPreGenerationScreen.genTexture",
	"Comment": "generates a texture and sets it to the image view, thus previewing the world.",
	"Method": "void genTexture(){\r\n    int imgWidth = 384;\r\n    int imgHeight = 384;\r\n    ByteBuffer buffer = ByteBuffer.allocateDirect(imgWidth * imgHeight * Integer.BYTES);\r\n    ByteBuffer[] data = new ByteBuffer[] { buffer };\r\n    ResourceUrn uri = new ResourceUrn(\"engine:terrainPreview\");\r\n    TextureData texData = new TextureData(imgWidth, imgHeight, data, Texture.WrapMode.CLAMP, Texture.FilterMode.LINEAR);\r\n    texture = Assets.generateAsset(uri, texData, Texture.class);\r\n    previewImage = find(\"preview\", UIImage.class);\r\n    previewImage.setImage(texture);\r\n}"
}, {
	"Path": "org.springframework.security.ldap.authentication.SpringSecurityAuthenticationSource.getPrincipal",
	"Comment": "get the principals of the logged in user, in this case the distinguished name.",
	"Method": "String getPrincipal(){\r\n    Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\r\n    if (authentication == null) {\r\n        log.warn(\"No Authentication object set in SecurityContext - returning empty String as Principal\");\r\n        return \"\";\r\n    }\r\n    Object principal = authentication.getPrincipal();\r\n    if (principal instanceof LdapUserDetails) {\r\n        LdapUserDetails details = (LdapUserDetails) principal;\r\n        return details.getDn();\r\n    } else if (authentication instanceof AnonymousAuthenticationToken) {\r\n        if (log.isDebugEnabled()) {\r\n            log.debug(\"Anonymous Authentication, returning empty String as Principal\");\r\n        }\r\n        return \"\";\r\n    } else {\r\n        throw new IllegalArgumentException(\"The principal property of the authentication object\" + \"needs to be an LdapUserDetails.\");\r\n    }\r\n}"
}, {
	"Path": "org.terasology.config.flexible.validators.RangedNumberValidator.isMinInclusive",
	"Comment": "returns a boolean stating whether the minimum value should be included in the range.",
	"Method": "boolean isMinInclusive(){\r\n    return minInclusive;\r\n}"
}, {
	"Path": "sample.contact.AdminPermissionController.displayAdminPage",
	"Comment": "displays the permission admin page for a particular contact.",
	"Method": "ModelAndView displayAdminPage(int contactId){\r\n    Contact contact = contactManager.getById(Long.valueOf(contactId));\r\n    Acl acl = aclService.readAclById(new ObjectIdentityImpl(contact));\r\n    Map<String, Object> model = new HashMap();\r\n    model.put(\"contact\", contact);\r\n    model.put(\"acl\", acl);\r\n    return new ModelAndView(\"adminPermission\", \"model\", model);\r\n}"
}, {
	"Path": "org.terasology.monitoring.PerformanceMonitor.getRunningMean",
	"Comment": "returns a mapping from the name of an activity to a running mean of its execution times, over a number of cycles.activities may be nested, and while a nested activity is running the collection of data from outer activitiesis paused and time passing is not assigned to them.",
	"Method": "TObjectDoubleMap<String> getRunningMean(){\r\n    return instance.getRunningMean();\r\n}"
}, {
	"Path": "org.terasology.persistence.serializers.ComponentSerializer.getComponentMetadata",
	"Comment": "determines the component class that the serialized component is for.",
	"Method": "ComponentMetadata<? extends Component> getComponentMetadata(EntityData.Component componentData,ComponentMetadata<? extends Component> getComponentMetadata,EntityData.Component componentData,Module context){\r\n    if (componentData.hasTypeIndex()) {\r\n        ComponentMetadata<? extends Component> metadata = null;\r\n        if (!idTable.isEmpty()) {\r\n            Class<? extends Component> componentClass = idTable.inverse().get(componentData.getTypeIndex());\r\n            if (componentClass != null) {\r\n                metadata = componentLibrary.getMetadata(componentClass);\r\n            }\r\n        }\r\n        if (metadata == null) {\r\n            logger.warn(\"Unable to deserialize unknown component with id: {}\", componentData.getTypeIndex());\r\n            return null;\r\n        }\r\n        return metadata;\r\n    } else if (componentData.hasType()) {\r\n        ComponentMetadata<? extends Component> metadata;\r\n        if (context != null) {\r\n            metadata = componentLibrary.resolve(componentData.getType(), context);\r\n        } else {\r\n            metadata = componentLibrary.resolve(componentData.getType());\r\n        }\r\n        if (metadata == null) {\r\n            logger.warn(\"Unable to deserialize unknown component type: {}\", componentData.getType());\r\n            return null;\r\n        }\r\n        return metadata;\r\n    }\r\n    logger.warn(\"Unable to deserialize component, no type provided.\");\r\n    return null;\r\n}"
}, {
	"Path": "org.terasology.persistence.serializers.ComponentSerializer.setIdMapping",
	"Comment": "sets the mapping between component classes and the ids that are used for serialization",
	"Method": "void setIdMapping(Map<Class<? extends Component>, Integer> table){\r\n    idTable = ImmutableBiMap.copyOf(table);\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.widgets.UIText.hasSelection",
	"Comment": "check whether any part of the text in the text box is currently selected.",
	"Method": "boolean hasSelection(){\r\n    return getCursorPosition() != selectionStart;\r\n}"
}, {
	"Path": "org.springframework.security.config.annotation.web.configurers.SessionManagementConfigurer.isConcurrentSessionControlEnabled",
	"Comment": "returns true if the number of concurrent sessions per user should be restricted.",
	"Method": "boolean isConcurrentSessionControlEnabled(){\r\n    return this.maximumSessions != null;\r\n}"
}, {
	"Path": "org.terasology.rendering.opengl.GLSLShader.registerAllShaderPermutations",
	"Comment": "compiles all combination of available features and stores them in two maps forlookup based on a unique hash of features.",
	"Method": "void registerAllShaderPermutations(){\r\n    Set<Set<ShaderProgramFeature>> allPermutations = Sets.powerSet(availableFeatures);\r\n    for (Set<ShaderProgramFeature> permutation : allPermutations) {\r\n        int fragShaderId = compileShader(GL20.GL_FRAGMENT_SHADER, permutation);\r\n        int vertShaderId = compileShader(GL20.GL_VERTEX_SHADER, permutation);\r\n        if (compileSuccess(fragShaderId) && compileSuccess(vertShaderId)) {\r\n            int featureHash = ShaderProgramFeature.getBitset(permutation);\r\n            disposalAction.fragmentPrograms.put(featureHash, fragShaderId);\r\n            disposalAction.vertexPrograms.put(featureHash, vertShaderId);\r\n        } else {\r\n            throw new RuntimeException(String.format(\"Shader '%s' failed to compile for features '%s'.%n%n\" + \"Vertex Shader Info: %n%s%n\" + \"Fragment Shader Info: %n%s\", getUrn(), permutation, getLogInfo(vertShaderId), getLogInfo(fragShaderId)));\r\n        }\r\n    }\r\n    logger.debug(\"Compiled {} permutations for {}.\", allPermutations.size(), getUrn());\r\n}"
}, {
	"Path": "org.terasology.logic.players.FirstPersonClientSystem.ensureClientSideEntityOnHeldItemMountPoint",
	"Comment": "ensures held item mount point entity exists, attaches it to the camera and sets its transform",
	"Method": "void ensureClientSideEntityOnHeldItemMountPoint(OnActivatedComponent event,EntityRef camera,FirstPersonHeldItemMountPointComponent firstPersonHeldItemMountPointComponent){\r\n    if (!firstPersonHeldItemMountPointComponent.mountPointEntity.exists()) {\r\n        EntityBuilder builder = entityManager.newBuilder(\"engine:FirstPersonHeldItemMountPoint\");\r\n        builder.setPersistent(false);\r\n        firstPersonHeldItemMountPointComponent.mountPointEntity = builder.build();\r\n        camera.saveComponent(firstPersonHeldItemMountPointComponent);\r\n    }\r\n    Location.removeChild(camera, firstPersonHeldItemMountPointComponent.mountPointEntity);\r\n    Location.attachChild(camera, firstPersonHeldItemMountPointComponent.mountPointEntity, firstPersonHeldItemMountPointComponent.translate, new Quat4f(TeraMath.DEG_TO_RAD * firstPersonHeldItemMountPointComponent.rotateDegrees.y, TeraMath.DEG_TO_RAD * firstPersonHeldItemMountPointComponent.rotateDegrees.x, TeraMath.DEG_TO_RAD * firstPersonHeldItemMountPointComponent.rotateDegrees.z), firstPersonHeldItemMountPointComponent.scale);\r\n}"
}, {
	"Path": "org.terasology.entitySystem.entity.internal.PojoEntityManager.notifyReactivation",
	"Comment": "this method gets called when the entity gets reactivated. e.g. after storage an entity needs to be reactivated.",
	"Method": "void notifyReactivation(EntityRef entity,Collection<Component> components){\r\n    for (EntityChangeSubscriber subscriber : subscribers) {\r\n        subscriber.onReactivation(entity, components);\r\n    }\r\n}"
}, {
	"Path": "org.terasology.engine.paths.PathManager.useOverrideHomePath",
	"Comment": "uses the given path as the home instead of the default home path.",
	"Method": "void useOverrideHomePath(Path rootPath){\r\n    this.homePath = rootPath;\r\n    updateDirs();\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.WebAuthenticationDetails.getSessionId",
	"Comment": "indicates the httpsession id the authentication request was received\tfrom.",
	"Method": "String getSessionId(){\r\n    return sessionId;\r\n}"
}, {
	"Path": "org.terasology.utilities.tree.SpaceTree.getSubNodeIndex",
	"Comment": "obtains the index of the subnode specified by center of the node specified by position.",
	"Method": "int getSubNodeIndex(float[] position,float[] center){\r\n    int index = 0;\r\n    int increment = 1;\r\n    for (int i = 0; i < dimensions; i++) {\r\n        if (position[i] > center[i]) {\r\n            index += increment;\r\n        }\r\n        increment *= 2;\r\n    }\r\n    if (index == 0) {\r\n        if (distanceFunction.getDistance(position, center) == 0) {\r\n            return -1;\r\n        }\r\n    }\r\n    return index;\r\n}"
}, {
	"Path": "org.terasology.rendering.world.viewDistance.ClientViewDistanceSystem.onDecreaseViewDistance",
	"Comment": "decreases view distance upon receiving a decrease view distance event.",
	"Method": "void onDecreaseViewDistance(DecreaseViewDistanceButton button,EntityRef entity){\r\n    int viewDistance = config.getRendering().getViewDistance().getIndex();\r\n    int minViewDistance = 0;\r\n    if (viewDistance != minViewDistance) {\r\n        ViewDistance lesserViewDistance = ViewDistance.forIndex(viewDistance - 1);\r\n        String lesserViewDistanceStr = translationSystem.translate(lesserViewDistance.toString());\r\n        fireChangeEvent(\"Decreasing view distance to \" + lesserViewDistanceStr + \".\", Arrays.asList(entity));\r\n        config.getRendering().setViewDistance(lesserViewDistance);\r\n    }\r\n    button.consume();\r\n}"
}, {
	"Path": "org.terasology.math.Region3i.createFromCenterExtents",
	"Comment": "create a region with center point and x,y,z coordinate extents size",
	"Method": "Region3i createFromCenterExtents(BaseVector3f center,BaseVector3f extents,Region3i createFromCenterExtents,BaseVector3i center,BaseVector3i extents,Region3i createFromCenterExtents,BaseVector3i center,int extent){\r\n    Vector3i min = new Vector3i(center.x() - extent, center.y() - extent, center.z() - extent);\r\n    Vector3i max = new Vector3i(center.x() + extent, center.y() + extent, center.z() + extent);\r\n    return createFromMinMax(min, max);\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.SimpleUrlAuthenticationFailureHandler.setUseForward",
	"Comment": "if set to true, performs a forward to the failure destination url instead\tof a redirect. defaults to false.",
	"Method": "void setUseForward(boolean forwardToDestination){\r\n    this.forwardToDestination = forwardToDestination;\r\n}"
}, {
	"Path": "org.springframework.security.ldap.ppolicy.PasswordPolicyResponseControl.isLocked",
	"Comment": "determines whether an account locked error has been returned.",
	"Method": "boolean isLocked(){\r\n    return this.errorStatus == PasswordPolicyErrorStatus.ACCOUNT_LOCKED;\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.widgets.UIDropdownScrollable.createScrollbarItems",
	"Comment": "located in the ondraw method, this draws the menu items with a scrollbar.",
	"Method": "void createScrollbarItems(Canvas canvas,Rect2i frame,Font font,Border itemMargin,int height,int itemHeight){\r\n    Rect2i scrollableArea = Rect2i.createFromMinAndSize(0, canvas.size().y, canvas.size().x, height - itemMargin.getBottom());\r\n    int scrollbarWidth = canvas.calculateRestrictedSize(verticalBar, new Vector2i(canvas.size().x, canvas.size().y)).x;\r\n    int scrollbarHeight = frame.size().y - itemMargin.getTop();\r\n    int availableWidth = frame.size().x - scrollbarWidth;\r\n    int scrollbarXPos = availableWidth - itemMargin.getRight();\r\n    int scrollbarYPos = itemMargin.getTotalHeight() * 2 + font.getLineHeight();\r\n    Rect2i scrollbarRegion = Rect2i.createFromMinAndSize(scrollbarXPos, scrollbarYPos, scrollbarWidth, scrollbarHeight);\r\n    canvas.drawWidget(verticalBar, scrollbarRegion);\r\n    float maxVertBarDesired = itemHeight * (optionListeners.size() - visibleOptionsNum - 0.5f) + itemMargin.getBottom();\r\n    verticalBar.setRange((int) maxVertBarDesired);\r\n    for (int i = 0; i < optionListeners.size(); ++i) {\r\n        readItemMouseOver(canvas, i);\r\n        Rect2i itemRegion = Rect2i.createFromMinAndSize(0, itemHeight * i - verticalBar.getValue(), availableWidth, itemHeight);\r\n        try (SubRegion ignored = canvas.subRegion(scrollableArea, true)) {\r\n            drawItem(canvas, itemMargin, i, itemRegion);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.terasology.utilities.tree.SpaceTree.remove",
	"Comment": "removes a node and then returns the value of the removed node.",
	"Method": "T remove(float[] position){\r\n    validatePosition(position);\r\n    if (rootNode == null) {\r\n        return null;\r\n    } else {\r\n        if (rootNode.center != null) {\r\n            int subNodeIndex = getSubNodeIndex(position, rootNode.center);\r\n            if (subNodeIndex == -1) {\r\n                Node oldRootNode = rootNode;\r\n                rootNode = null;\r\n                for (Node subNode : oldRootNode.subNodes) {\r\n                    addAllFromNode(subNode, null);\r\n                }\r\n                return oldRootNode.centerValue;\r\n            } else {\r\n                return removeFromSubNodeOfNode(position, rootNode, subNodeIndex);\r\n            }\r\n        } else {\r\n            for (NodeEntry<T> nodeEntry : rootNode.nodeBucket) {\r\n                if (distanceFunction.getDistance(nodeEntry.position, position) == 0) {\r\n                    rootNode.nodeBucket.remove(nodeEntry);\r\n                    if (rootNode.nodeBucket.size() == 0) {\r\n                        rootNode = null;\r\n                    }\r\n                    return nodeEntry.value;\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.core.userdetails.UserDetailsByNameServiceWrapper.loadUserDetails",
	"Comment": "get the userdetails object from the wrapped userdetailsservice implementation",
	"Method": "UserDetails loadUserDetails(T authentication){\r\n    return this.userDetailsService.loadUserByUsername(authentication.getName());\r\n}"
}, {
	"Path": "org.terasology.recording.EventSystemReplayImpl.finishReplay",
	"Comment": "empty the recordedeventstore and sets the recordandreplaystatus.",
	"Method": "void finishReplay(){\r\n    recordedEventStore.popEvents();\r\n    recordAndReplayCurrentStatus.setStatus(RecordAndReplayStatus.REPLAY_FINISHED);\r\n}"
}, {
	"Path": "org.terasology.utilities.concurrency.TaskMaster.createFIFOTaskMaster",
	"Comment": "creates a fifo taskmaster which simply reads from a task queue in order",
	"Method": "TaskMaster<T> createFIFOTaskMaster(String name,int threads){\r\n    return new TaskMaster(name, threads, new LinkedBlockingQueue());\r\n}"
}, {
	"Path": "org.springframework.security.crypto.encrypt.Encryptors.noOpText",
	"Comment": "creates a text encryptor that performs no encryption. useful for developer testing\tenvironments where working with plain text strings is desired for simplicity.",
	"Method": "TextEncryptor noOpText(){\r\n    return NO_OP_TEXT_INSTANCE;\r\n}"
}, {
	"Path": "org.springframework.security.test.web.reactive.server.SecurityMockServerConfigurers.mockAuthentication",
	"Comment": "updates the serverwebexchange to use the provided authentication as the principal",
	"Method": "T mockAuthentication(Authentication authentication){\r\n    return (T) new MutatorWebTestClientConfigurer(() -> Mono.just(authentication).map(SecurityContextImpl::new));\r\n}"
}, {
	"Path": "org.springframework.security.ldap.userdetails.DefaultLdapAuthoritiesPopulator.getRolePrefix",
	"Comment": "returns the role prefix used by this populator method available so that classes\textending this can override",
	"Method": "String getRolePrefix(){\r\n    return this.rolePrefix;\r\n}"
}, {
	"Path": "org.terasology.rendering.openvrprovider.OpenVRProvider.getState",
	"Comment": "get the state of the vr system. this contains the poses of the eyes, controllers, etc...",
	"Method": "OpenVRState getState(){\r\n    return VR_STATE;\r\n}"
}, {
	"Path": "org.springframework.security.crypto.password.MessageDigestPasswordEncoder.encode",
	"Comment": "encodes the rawpass using a messagedigest. if a salt is specified it will be merged\twith the password before encoding.",
	"Method": "String encode(CharSequence rawPassword,String encode,byte[] digest){\r\n    if (this.encodeHashAsBase64) {\r\n        return Utf8.decode(Base64.getEncoder().encode(digest));\r\n    } else {\r\n        return new String(Hex.encode(digest));\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.DelegatingAuthenticationEntryPoint.setDefaultEntryPoint",
	"Comment": "entrypoint which is used when no requestmatcher returned true",
	"Method": "void setDefaultEntryPoint(AuthenticationEntryPoint defaultEntryPoint){\r\n    this.defaultEntryPoint = defaultEntryPoint;\r\n}"
}, {
	"Path": "org.terasology.input.InputSystem.processMouseButtonInput",
	"Comment": "processes input actions by the mouse buttons, sends input events and updates bind buttons accordingly.",
	"Method": "void processMouseButtonInput(float delta,MouseAction action){\r\n    int id = action.getInput().getId();\r\n    if (id != MouseInput.NONE.getId()) {\r\n        MouseInput button = MouseInput.find(action.getInput().getType(), action.getInput().getId());\r\n        boolean consumed = sendMouseEvent(button, action.getState().isDown(), action.getMousePosition(), delta);\r\n        BindableButton bind = bindsManager.getMouseButtonBinds().get(button);\r\n        if (bind != null) {\r\n            updateBindState(bind, action.getInput(), action.getState().isDown(), delta, consumed);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.ldap.userdetails.DefaultLdapAuthoritiesPopulator.getGroupSearchFilter",
	"Comment": "returns the search filter configured for this populator method available so that\tclasses extending this can override",
	"Method": "String getGroupSearchFilter(){\r\n    return this.groupSearchFilter;\r\n}"
}, {
	"Path": "org.terasology.recording.RecordAndReplayUtils.reset",
	"Comment": "resets shutdownrequested, filecount and fileamount. should be called once a recording ends.",
	"Method": "void reset(){\r\n    shutdownRequested = false;\r\n    fileCount = 1;\r\n    fileAmount = 0;\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.switchuser.SwitchUserFilter.setSuccessHandler",
	"Comment": "used to define custom behaviour on a successful switch or exit user.\tcan be used instead of setting targeturl.",
	"Method": "void setSuccessHandler(AuthenticationSuccessHandler successHandler){\r\n    Assert.notNull(successHandler, \"successHandler cannot be null\");\r\n    this.successHandler = successHandler;\r\n}"
}, {
	"Path": "org.springframework.security.ldap.SpringSecurityLdapTemplate.searchForSingleAttributeValues",
	"Comment": "performs a search using the supplied filter and returns the union of the values of\tthe named attribute found in all entries matched by the search. note that one\tdirectory entry may have several values for the attribute. intended for role\tsearches and similar scenarios.",
	"Method": "Set<String> searchForSingleAttributeValues(String base,String filter,Object[] params,String attributeName){\r\n    String[] attributeNames = new String[] { attributeName };\r\n    Set<Map<String, List<String>>> multipleAttributeValues = searchForMultipleAttributeValues(base, filter, params, attributeNames);\r\n    Set<String> result = new HashSet();\r\n    for (Map<String, List<String>> map : multipleAttributeValues) {\r\n        List<String> values = map.get(attributeName);\r\n        if (values != null) {\r\n            result.addAll(values);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.terasology.rendering.opengl.AbstractFBOsManager.getFboConfig",
	"Comment": "returns an fboconfig given its name.if no fboconfig maps to the given name, null is returned and an error is logged.",
	"Method": "FBOConfig getFboConfig(SimpleUri fboName){\r\n    FBOConfig fboConfig = fboConfigs.get(fboName);\r\n    if (fboConfig == null) {\r\n        logger.warn(\"Failed to retrieve FBOConfig '\" + fboName + \"'!\");\r\n    }\r\n    return fboConfig;\r\n}"
}, {
	"Path": "org.terasology.utilities.tree.SpaceTree.removeFromSubNodeOfNode",
	"Comment": "removes and returns the value of the subnode removed from the node.",
	"Method": "T removeFromSubNodeOfNode(float[] position,Node node,int subNodeIndex){\r\n    Node processedNode = node;\r\n    int processedSubNodeIndex = subNodeIndex;\r\n    while (true) {\r\n        Node subNode = processedNode.subNodes[processedSubNodeIndex];\r\n        if (subNode == null) {\r\n            return null;\r\n        } else {\r\n            if (subNode.center != null) {\r\n                int subSubNodeIndex = getSubNodeIndex(position, subNode.center);\r\n                if (subSubNodeIndex == -1) {\r\n                    processedNode.subNodes[processedSubNodeIndex] = null;\r\n                    for (Node subSubNode : subNode.subNodes) {\r\n                        addAllFromNode(subSubNode, processedNode);\r\n                    }\r\n                    return subNode.centerValue;\r\n                } else {\r\n                    processedNode = subNode;\r\n                    processedSubNodeIndex = subSubNodeIndex;\r\n                }\r\n            } else {\r\n                for (NodeEntry<T> nodeEntry : subNode.nodeBucket) {\r\n                    if (distanceFunction.getDistance(nodeEntry.position, position) == 0) {\r\n                        subNode.nodeBucket.remove(nodeEntry);\r\n                        if (subNode.nodeBucket.size() == 0) {\r\n                            processedNode.subNodes[processedSubNodeIndex] = null;\r\n                        }\r\n                        return nodeEntry.value;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "sample.dms.DocumentDaoImpl.getDirectoryWithImmediateParentPopulated",
	"Comment": "executes recursive sql as needed to build a full directory hierarchy of objects",
	"Method": "Directory getDirectoryWithImmediateParentPopulated(Long id){\r\n    return getJdbcTemplate().queryForObject(SELECT_FROM_DIRECTORY_SINGLE, new Object[] { id }, new RowMapper<Directory>() {\r\n        public Directory mapRow(ResultSet rs, int rowNumber) throws SQLException {\r\n            Long parentDirectoryId = new Long(rs.getLong(\"parent_directory_id\"));\r\n            Directory parentDirectory = Directory.ROOT_DIRECTORY;\r\n            if (parentDirectoryId != null && !parentDirectoryId.equals(new Long(-1))) {\r\n                parentDirectory = getDirectoryWithImmediateParentPopulated(parentDirectoryId);\r\n            }\r\n            Directory directory = new Directory(rs.getString(\"directory_name\"), parentDirectory);\r\n            FieldUtils.setProtectedFieldValue(\"id\", directory, new Long(rs.getLong(\"id\")));\r\n            return directory;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "sample.dms.DocumentDaoImpl.getDirectoryWithImmediateParentPopulated",
	"Comment": "executes recursive sql as needed to build a full directory hierarchy of objects",
	"Method": "Directory getDirectoryWithImmediateParentPopulated(Long id){\r\n    Long parentDirectoryId = new Long(rs.getLong(\"parent_directory_id\"));\r\n    Directory parentDirectory = Directory.ROOT_DIRECTORY;\r\n    if (parentDirectoryId != null && !parentDirectoryId.equals(new Long(-1))) {\r\n        parentDirectory = getDirectoryWithImmediateParentPopulated(parentDirectoryId);\r\n    }\r\n    Directory directory = new Directory(rs.getString(\"directory_name\"), parentDirectory);\r\n    FieldUtils.setProtectedFieldValue(\"id\", directory, new Long(rs.getLong(\"id\")));\r\n    return directory;\r\n}"
}, {
	"Path": "org.terasology.logic.players.LocalPlayerSystem.onCrouchTemporarily",
	"Comment": "crouches if button is pressed. stands if button is released.",
	"Method": "void onCrouchTemporarily(CrouchButton event,EntityRef entity){\r\n    boolean toggle = event.isDown();\r\n    crouch = crouchPerDefault ^ toggle;\r\n    event.consume();\r\n}"
}, {
	"Path": "org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource.getAllConfigAttributes",
	"Comment": "obtains the configuration attributes explicitly defined against this bean.",
	"Method": "Collection<ConfigAttribute> getAllConfigAttributes(){\r\n    Set<ConfigAttribute> allAttributes = new HashSet();\r\n    for (List<ConfigAttribute> attributeList : methodMap.values()) {\r\n        allAttributes.addAll(attributeList);\r\n    }\r\n    return allAttributes;\r\n}"
}, {
	"Path": "org.terasology.input.InputSystem.sendKeyEvent",
	"Comment": "creates and sends an input event based on a provided keyboard input.",
	"Method": "boolean sendKeyEvent(Input key,char keyChar,ButtonState state,float delta){\r\n    KeyEvent event;\r\n    switch(state) {\r\n        case UP:\r\n            event = KeyUpEvent.create(key, keyChar, delta);\r\n            break;\r\n        case DOWN:\r\n            event = KeyDownEvent.create(key, keyChar, delta);\r\n            break;\r\n        case REPEAT:\r\n            event = KeyRepeatEvent.create(key, keyChar, delta);\r\n            break;\r\n        default:\r\n            return false;\r\n    }\r\n    boolean consumed = send(event);\r\n    event.reset();\r\n    return consumed;\r\n}"
}, {
	"Path": "org.terasology.audio.formats.OggReader.skip",
	"Comment": "skips over and discards n bytes of data from the input stream. the skipmethod may, for a variety of reasons, end up skipping over some smallernumber of bytes, possibly 0. the actual number of bytes skipped is returned.",
	"Method": "long skip(long n){\r\n    int bytesRead = 0;\r\n    while (bytesRead < n) {\r\n        int res = read();\r\n        if (res == -1) {\r\n            break;\r\n        }\r\n        bytesRead++;\r\n    }\r\n    return bytesRead;\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.skin.UIStyle.getBackground",
	"Comment": "the background is a texture that is drawn filling the area of a widget or part, after taking into account size modified but not margin.it is drawn before any contents",
	"Method": "TextureRegion getBackground(){\r\n    return background;\r\n}"
}, {
	"Path": "org.springframework.security.authentication.jaas.AbstractJaasAuthenticationProvider.authenticate",
	"Comment": "attempts to login the user given the authentication objects principal and\tcredential",
	"Method": "Authentication authenticate(Authentication auth){\r\n    if (!(auth instanceof UsernamePasswordAuthenticationToken)) {\r\n        return null;\r\n    }\r\n    UsernamePasswordAuthenticationToken request = (UsernamePasswordAuthenticationToken) auth;\r\n    Set<GrantedAuthority> authorities;\r\n    try {\r\n        LoginContext loginContext = createLoginContext(new InternalCallbackHandler(auth));\r\n        loginContext.login();\r\n        authorities = new HashSet();\r\n        Set<Principal> principals = loginContext.getSubject().getPrincipals();\r\n        for (Principal principal : principals) {\r\n            for (AuthorityGranter granter : this.authorityGranters) {\r\n                Set<String> roles = granter.grant(principal);\r\n                if ((roles != null) && !roles.isEmpty()) {\r\n                    for (String role : roles) {\r\n                        authorities.add(new JaasGrantedAuthority(role, principal));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        JaasAuthenticationToken result = new JaasAuthenticationToken(request.getPrincipal(), request.getCredentials(), new ArrayList(authorities), loginContext);\r\n        publishSuccessEvent(result);\r\n        return result;\r\n    } catch (LoginException loginException) {\r\n        AuthenticationException ase = this.loginExceptionResolver.resolveException(loginException);\r\n        publishFailureEvent(request, ase);\r\n        throw ase;\r\n    }\r\n}"
}, {
	"Path": "org.terasology.rendering.dag.AbstractNode.addDesiredStateChange",
	"Comment": "adds a statechange object to the set of state changes desired by a node.this method is normally used within the constructor of a concrete node class, to set the opengl statea node requires. however, it can also be used when runtime conditions change, i.e. a switch froma normal rendering style to wireframe and viceversa.only statechange objects that are in the set and are not redundant make it into the tasklistand actually modify the opengl state every frame.",
	"Method": "void addDesiredStateChange(StateChange stateChange){\r\n    if (stateChange.isTheDefaultInstance()) {\r\n        logger.error(\"Attempted to add default state change {} to the set of desired state changes. (Node: {})\", stateChange.getClass().getSimpleName(), this.toString());\r\n    }\r\n    desiredStateChanges.add(stateChange);\r\n}"
}, {
	"Path": "org.springframework.security.core.authority.mapping.MapBasedAttributes2GrantedAuthoritiesMapper.preProcessMap",
	"Comment": "preprocess the given map to convert all the values to grantedauthority collections",
	"Method": "Map<String, Collection<GrantedAuthority>> preProcessMap(Map<?, ?> orgMap){\r\n    Map<String, Collection<GrantedAuthority>> result = new HashMap<String, Collection<GrantedAuthority>>(orgMap.size());\r\n    for (Map.Entry<?, ?> entry : orgMap.entrySet()) {\r\n        Assert.isInstanceOf(String.class, entry.getKey(), \"attributes2grantedAuthoritiesMap contains non-String objects as keys\");\r\n        result.put((String) entry.getKey(), getGrantedAuthorityCollection(entry.getValue()));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.terasology.world.generation.facets.base.BaseBooleanFieldFacet2D.getInternal",
	"Comment": "this method exists for performance reasons, but itis recommended to use proper getters and setters instead.",
	"Method": "boolean[] getInternal(){\r\n    return data;\r\n}"
}, {
	"Path": "org.springframework.security.web.csrf.CookieCsrfTokenRepository.setCookiePath",
	"Comment": "set the path that the cookie will be created with. this will override the default functionality which uses the\trequest context as the path.",
	"Method": "void setCookiePath(String path){\r\n    this.cookiePath = path;\r\n}"
}, {
	"Path": "org.springframework.security.core.context.SecurityContextHolder.createEmptyContext",
	"Comment": "delegates the creation of a new, empty context to the configured strategy.",
	"Method": "SecurityContext createEmptyContext(){\r\n    return strategy.createEmptyContext();\r\n}"
}, {
	"Path": "org.springframework.security.test.web.reactive.server.SecurityMockServerConfigurers.mockUser",
	"Comment": "updates the serverwebexchange to use the provided userdetails to create a usernamepasswordauthenticationtoken as\tthe principal",
	"Method": "T mockUser(UserDetails userDetails,UserExchangeMutator mockUser,UserExchangeMutator mockUser,String username){\r\n    return new UserExchangeMutator(username);\r\n}"
}, {
	"Path": "org.springframework.security.core.token.Sha512DigestUtils.shaHex",
	"Comment": "calculates the sha digest and returns the value as a hex string.",
	"Method": "String shaHex(byte[] data,String shaHex,String data){\r\n    return new String(Hex.encode(sha(data)));\r\n}"
}, {
	"Path": "org.springframework.security.config.doc.SpringSecurityXsdParser.attrgrps",
	"Comment": "any children will be searched for an attributegroup, each of its children will be returned as an attribute",
	"Method": "Collection<Attribute> attrgrps(XmlNode element){\r\n    Collection<Attribute> attrgrp = new ArrayList();\r\n    element.children().forEach(c -> {\r\n        if (\"element\".equals(c.simpleName())) {\r\n        } else if (\"attributeGroup\".equals(c.simpleName())) {\r\n            if (c.attribute(\"name\") != null) {\r\n                attrgrp.addAll(attrgrp(c));\r\n            } else {\r\n                String name = c.attribute(\"ref\").split(\":\")[1];\r\n                XmlNode attrGrp = findNode(element, name);\r\n                attrgrp.addAll(attrgrp(attrGrp));\r\n            }\r\n        } else {\r\n            attrgrp.addAll(attrgrps(c));\r\n        }\r\n    });\r\n    return attrgrp;\r\n}"
}, {
	"Path": "org.terasology.rendering.world.viewDistance.ClientViewDistanceSystem.fireChangeEvent",
	"Comment": "fires notification events upon changes to debug parameters.",
	"Method": "void fireChangeEvent(String message,List<EntityRef> entities){\r\n    for (EntityRef client : entities) {\r\n        client.send(new NotificationMessageEvent(message, client));\r\n    }\r\n}"
}, {
	"Path": "org.terasology.network.internal.AbstractClient.findClientEntityRef",
	"Comment": "function to find the clients entity reference and return it.",
	"Method": "EntityRef findClientEntityRef(EntityManager entityManager){\r\n    for (EntityRef entityRef : entityManager.getEntitiesWith(ClientInfoComponent.class)) {\r\n        ClientInfoComponent clientInfoComponent = entityRef.getComponent(ClientInfoComponent.class);\r\n        if (clientInfoComponent.playerId.equals(getId())) {\r\n            return entityRef;\r\n        }\r\n    }\r\n    return EntityRef.NULL;\r\n}"
}, {
	"Path": "org.terasology.physics.shapes.CollisionShapeFactory.getNewUnitCube",
	"Comment": "creates a new box shape with unit extents, that is a cube with sides of length 1.",
	"Method": "BoxShape getNewUnitCube(){\r\n    return getNewBox(Vector3f.one());\r\n}"
}, {
	"Path": "org.springframework.security.web.util.OnCommittedResponseWrapper.checkContentLength",
	"Comment": "adds the contentlengthtowrite to the total contentwritten size and checks to see if\tthe response should be written.",
	"Method": "void checkContentLength(long contentLengthToWrite){\r\n    this.contentWritten += contentLengthToWrite;\r\n    boolean isBodyFullyWritten = this.contentLength > 0 && this.contentWritten >= this.contentLength;\r\n    int bufferSize = getBufferSize();\r\n    boolean requiresFlush = bufferSize > 0 && this.contentWritten >= bufferSize;\r\n    if (isBodyFullyWritten || requiresFlush) {\r\n        doOnResponseCommitted();\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.session.RegisterSessionAuthenticationStrategy.onAuthentication",
	"Comment": "in addition to the steps from the superclass, the sessionregistry will be updated\twith the new session information.",
	"Method": "void onAuthentication(Authentication authentication,HttpServletRequest request,HttpServletResponse response){\r\n    sessionRegistry.registerNewSession(request.getSession().getId(), authentication.getPrincipal());\r\n}"
}, {
	"Path": "org.springframework.security.oauth2.server.resource.web.access.BearerTokenAccessDeniedHandler.setRealmName",
	"Comment": "set the default realm name to use in the bearer token error response",
	"Method": "void setRealmName(String realmName){\r\n    this.realmName = realmName;\r\n}"
}, {
	"Path": "org.terasology.world.zones.Zone.addPreviewLayer",
	"Comment": "add a preview layer to this zone, which will be used when the preview is generated.",
	"Method": "Zone addPreviewLayer(FacetLayer facetLayer){\r\n    facetLayers.add(facetLayer);\r\n    return this;\r\n}"
}, {
	"Path": "org.terasology.logic.console.commands.ClientCommands.setSpawnLocation",
	"Comment": "sets the spawn location for the client to the current location",
	"Method": "String setSpawnLocation(EntityRef sender){\r\n    EntityRef clientInfo = sender.getComponent(ClientComponent.class).clientInfo;\r\n    StaticSpawnLocationComponent staticSpawnLocationComponent = new StaticSpawnLocationComponent();\r\n    if (clientInfo.hasComponent(StaticSpawnLocationComponent.class)) {\r\n        staticSpawnLocationComponent = clientInfo.getComponent(StaticSpawnLocationComponent.class);\r\n    }\r\n    staticSpawnLocationComponent.position = sender.getComponent(ClientComponent.class).character.getComponent(LocationComponent.class).getWorldPosition();\r\n    clientInfo.addOrSaveComponent(staticSpawnLocationComponent);\r\n    return \"Set spawn location to- \" + staticSpawnLocationComponent.position;\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.layers.mainMenu.WorldPreGenerationScreen.setEnvironment",
	"Comment": "a function called before the screen comes to the forefront to setup the environmentand extract necessary objects from the new context.",
	"Method": "void setEnvironment(Context subContext){\r\n    context = subContext;\r\n    environment = context.get(ModuleEnvironment.class);\r\n    context.put(WorldGeneratorPluginLibrary.class, new TempWorldGeneratorPluginLibrary(environment, context));\r\n    worldList = context.get(UniverseSetupScreen.class).getWorldsList();\r\n    selectedWorld = context.get(UniverseSetupScreen.class).getSelectedWorld();\r\n    worldNames = context.get(UniverseSetupScreen.class).worldNames();\r\n    setWorldGenerators();\r\n    worldGenerator = findWorldByName(selectedWorld).getWorldGenerator();\r\n    final UIDropdownScrollable worldsDropdown = find(\"worlds\", UIDropdownScrollable.class);\r\n    worldsDropdown.setOptions(worldNames);\r\n    genTexture();\r\n    List<Zone> previewZones = Lists.newArrayList(worldGenerator.getZones()).stream().filter(z -> !z.getPreviewLayers().isEmpty()).collect(Collectors.toList());\r\n    if (previewZones.isEmpty()) {\r\n        previewGen = new FacetLayerPreview(environment, worldGenerator);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.crypto.password.AbstractPasswordEncoder.matches",
	"Comment": "constant time comparison to prevent against timing attacks.",
	"Method": "boolean matches(CharSequence rawPassword,String encodedPassword,boolean matches,byte[] expected,byte[] actual){\r\n    if (expected.length != actual.length) {\r\n        return false;\r\n    }\r\n    int result = 0;\r\n    for (int i = 0; i < expected.length; i++) {\r\n        result |= expected[i] ^ actual[i];\r\n    }\r\n    return result == 0;\r\n}"
}, {
	"Path": "org.terasology.identity.PrivateIdentityCertificate.sign",
	"Comment": "produces a signature for data that can be verified as by the paired public certificate.",
	"Method": "byte[] sign(byte[] dataToSign){\r\n    RSAPrivateKeySpec keySpec = new RSAPrivateKeySpec(modulus, exponent);\r\n    Signature signer = null;\r\n    try {\r\n        signer = Signature.getInstance(IdentityConstants.SIGNATURE_ALGORITHM);\r\n        KeyFactory keyFactory = KeyFactory.getInstance(IdentityConstants.CERTIFICATE_ALGORITHM);\r\n        PrivateKey key = keyFactory.generatePrivate(keySpec);\r\n        signer.initSign(key, new SecureRandom());\r\n        signer.update(dataToSign);\r\n        return signer.sign();\r\n    } catch (NoSuchAlgorithmException | InvalidKeySpecException | InvalidKeyException | SignatureException e) {\r\n        throw new RuntimeException(\"Unexpected exception during signing\", e);\r\n    }\r\n}"
}, {
	"Path": "org.terasology.reflection.metadata.FieldMetadata.getValueChecked",
	"Comment": "obtains the value of the field from a object which is an instance of the owning type.this method is checked to conform to the generic parameters of the fieldmetadata",
	"Method": "U getValueChecked(T from){\r\n    return getValue(from);\r\n}"
}, {
	"Path": "org.terasology.persistence.typeHandling.TypeSerializationLibrary.add",
	"Comment": "adds a type handler that will be to serialize a specified type.if a type handler was previously registered for that type, it will be replaced with the new type handler.existing serializers will not be updated.",
	"Method": "void add(Class<T> type,TypeHandler<? super T> handler){\r\n    typeHandlers.put(type, handler);\r\n    coreTypeHandlers.add(type);\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.widgets.JsonEditorTreeView.pasteNode",
	"Comment": "pastes the currently copied node as a child of the specified node,then deselects it.",
	"Method": "void pasteNode(JsonTree node){\r\n    paste(node);\r\n    setSelectedIndex(null);\r\n}"
}, {
	"Path": "org.terasology.rendering.opengl.AbstractFBOsManager.retain",
	"Comment": "increases the usage count for a given fbo.when the usage count for a given fbo goes down to zero, it can be safely disposed as it is no longer in use.",
	"Method": "void retain(SimpleUri fboName){\r\n    if (fboUsageCountMap.containsKey(fboName)) {\r\n        int usageCount = fboUsageCountMap.get(fboName) + 1;\r\n        fboUsageCountMap.put(fboName, usageCount);\r\n    } else {\r\n        fboUsageCountMap.put(fboName, 1);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.authentication.ProviderManager.copyDetails",
	"Comment": "copies the authentication details from a source authentication object to a\tdestination one, provided the latter does not already have one set.",
	"Method": "void copyDetails(Authentication source,Authentication dest){\r\n    if ((dest instanceof AbstractAuthenticationToken) && (dest.getDetails() == null)) {\r\n        AbstractAuthenticationToken token = (AbstractAuthenticationToken) dest;\r\n        token.setDetails(source.getDetails());\r\n    }\r\n}"
}, {
	"Path": "org.terasology.rendering.opengl.ScreenGrabber.convertByteBufferToBufferedImage",
	"Comment": "transforms bytebuffer into bufferedimage with specified width and height.",
	"Method": "BufferedImage convertByteBufferToBufferedImage(ByteBuffer buffer,int width,int height){\r\n    BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\r\n    for (int x = 0; x < width; x++) {\r\n        for (int y = 0; y < height; y++) {\r\n            int i = (x + width * y) * 4;\r\n            int r = buffer.get(i) & 0xFF;\r\n            int g = buffer.get(i + 1) & 0xFF;\r\n            int b = buffer.get(i + 2) & 0xFF;\r\n            image.setRGB(x, height - (y + 1), (0xFF << 24) | (r << 16) | (g << 8) | b);\r\n        }\r\n    }\r\n    return image;\r\n}"
}, {
	"Path": "org.terasology.rendering.cameras.ViewFrustum.intersects",
	"Comment": "returns true if this view frustum intersects the given aabb.",
	"Method": "boolean intersects(double x,double y,double z,boolean intersects,AABB aabb,boolean intersects,Vector3f position,float radius){\r\n    for (int i = 0; i < 6; i++) {\r\n        if (planes[i].getA() * position.x + planes[i].getB() * position.y + planes[i].getC() * position.z + planes[i].getD() <= -radius) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.springframework.security.oauth2.server.resource.web.BearerTokenAuthenticationFilter.doFilterInternal",
	"Comment": "extract any bearer token from\tthe request and attempt an authentication.",
	"Method": "void doFilterInternal(HttpServletRequest request,HttpServletResponse response,FilterChain filterChain){\r\n    final boolean debug = this.logger.isDebugEnabled();\r\n    String token;\r\n    try {\r\n        token = this.bearerTokenResolver.resolve(request);\r\n    } catch (OAuth2AuthenticationException invalid) {\r\n        this.authenticationEntryPoint.commence(request, response, invalid);\r\n        return;\r\n    }\r\n    if (token == null) {\r\n        filterChain.doFilter(request, response);\r\n        return;\r\n    }\r\n    BearerTokenAuthenticationToken authenticationRequest = new BearerTokenAuthenticationToken(token);\r\n    authenticationRequest.setDetails(this.authenticationDetailsSource.buildDetails(request));\r\n    try {\r\n        Authentication authenticationResult = this.authenticationManager.authenticate(authenticationRequest);\r\n        SecurityContext context = SecurityContextHolder.createEmptyContext();\r\n        context.setAuthentication(authenticationResult);\r\n        SecurityContextHolder.setContext(context);\r\n        filterChain.doFilter(request, response);\r\n    } catch (AuthenticationException failed) {\r\n        SecurityContextHolder.clearContext();\r\n        if (debug) {\r\n            this.logger.debug(\"Authentication request for failed: \" + failed);\r\n        }\r\n        this.authenticationEntryPoint.commence(request, response, failed);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.authorization.ReactiveAuthorizationManager.verify",
	"Comment": "determines if access should be granted for a specific authentication and object",
	"Method": "Mono<Void> verify(Mono<Authentication> authentication,T object){\r\n    return check(authentication, object).filter(d -> d.isGranted()).switchIfEmpty(Mono.defer(() -> Mono.error(new AccessDeniedException(\"Access Denied\")))).flatMap(d -> Mono.empty());\r\n}"
}, {
	"Path": "springfox.documentation.builders.ApiListingBuilder.produces",
	"Comment": "replaces the existing media types with new entries that this documentation produces",
	"Method": "ApiListingBuilder produces(Set<String> mediaTypes){\r\n    if (mediaTypes != null) {\r\n        this.produces = new HashSet(mediaTypes);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.security.config.annotation.web.configurers.UrlAuthorizationConfigurer.hasAnyRole",
	"Comment": "creates a string for specifying that a user requires one of many roles.",
	"Method": "String[] hasAnyRole(String roles,StandardInterceptUrlRegistry hasAnyRole,String roles){\r\n    for (int i = 0; i < roles.length; i++) {\r\n        roles[i] = \"ROLE_\" + roles[i];\r\n    }\r\n    return roles;\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.widgets.UIText.onKeyEvent",
	"Comment": "handles what to do when a key is pressed while the text box is active.",
	"Method": "boolean onKeyEvent(NUIKeyEvent event){\r\n    correctCursor();\r\n    boolean eventHandled = false;\r\n    if (isEnabled() && event.isDown() && lastFont != null) {\r\n        if (isShowingHintText && !readOnly) {\r\n            if (event.getKeyboard().isKeyDown(Keyboard.KeyId.LEFT_CTRL) || event.getKeyboard().isKeyDown(Keyboard.KeyId.RIGHT_CTRL)) {\r\n                if (event.getKey() == Keyboard.Key.V) {\r\n                    removeSelection();\r\n                    paste();\r\n                    eventHandled = true;\r\n                }\r\n            }\r\n            if (event.getKey() == Keyboard.Key.ENTER || event.getKey() == Keyboard.Key.NUMPAD_ENTER) {\r\n                for (ActivateEventListener listener : activationListeners) {\r\n                    listener.onActivated(this);\r\n                }\r\n                eventHandled = true;\r\n            } else if (event.getKeyCharacter() != 0 && lastFont.hasCharacter(event.getKeyCharacter())) {\r\n                String fullText = text.get();\r\n                String before = fullText.substring(0, Math.min(getCursorPosition(), selectionStart));\r\n                String after = fullText.substring(Math.max(getCursorPosition(), selectionStart));\r\n                setText(before + event.getKeyCharacter() + after);\r\n                setCursorPosition(Math.min(getCursorPosition(), selectionStart) + 1);\r\n                eventHandled = true;\r\n            }\r\n        } else {\r\n            String fullText = text.get();\r\n            switch(event.getKey().getId()) {\r\n                case KeyId.LEFT:\r\n                    {\r\n                        if (hasSelection() && !isSelectionModifierActive(event.getKeyboard())) {\r\n                            setCursorPosition(Math.min(getCursorPosition(), selectionStart));\r\n                        } else if (getCursorPosition() > 0) {\r\n                            decreaseCursorPosition(1, !isSelectionModifierActive(event.getKeyboard()));\r\n                        }\r\n                        eventHandled = true;\r\n                        break;\r\n                    }\r\n                case KeyId.RIGHT:\r\n                    {\r\n                        if (hasSelection() && !isSelectionModifierActive(event.getKeyboard())) {\r\n                            setCursorPosition(Math.max(getCursorPosition(), selectionStart));\r\n                        } else if (getCursorPosition() < fullText.length()) {\r\n                            increaseCursorPosition(1, !isSelectionModifierActive(event.getKeyboard()));\r\n                        }\r\n                        eventHandled = true;\r\n                        break;\r\n                    }\r\n                case KeyId.HOME:\r\n                    {\r\n                        setCursorPosition(0, !isSelectionModifierActive(event.getKeyboard()));\r\n                        offset = 0;\r\n                        eventHandled = true;\r\n                        break;\r\n                    }\r\n                case KeyId.END:\r\n                    {\r\n                        setCursorPosition(fullText.length(), !isSelectionModifierActive(event.getKeyboard()));\r\n                        eventHandled = true;\r\n                        break;\r\n                    }\r\n                default:\r\n                    {\r\n                        if (event.getKeyboard().isKeyDown(KeyId.LEFT_CTRL) || event.getKeyboard().isKeyDown(KeyId.RIGHT_CTRL)) {\r\n                            if (event.getKey() == Keyboard.Key.C) {\r\n                                copySelection();\r\n                                eventHandled = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n            }\r\n            if (!readOnly) {\r\n                switch(event.getKey().getId()) {\r\n                    case KeyId.BACKSPACE:\r\n                        {\r\n                            if (hasSelection()) {\r\n                                removeSelection();\r\n                            } else if (getCursorPosition() > 0) {\r\n                                String before = fullText.substring(0, getCursorPosition() - 1);\r\n                                String after = fullText.substring(getCursorPosition());\r\n                                if (getCursorPosition() < fullText.length()) {\r\n                                    decreaseCursorPosition(1);\r\n                                }\r\n                                setText(before + after);\r\n                            }\r\n                            eventHandled = true;\r\n                            break;\r\n                        }\r\n                    case KeyId.DELETE:\r\n                        {\r\n                            if (hasSelection()) {\r\n                                removeSelection();\r\n                            } else if (getCursorPosition() < fullText.length()) {\r\n                                String before = fullText.substring(0, getCursorPosition());\r\n                                String after = fullText.substring(getCursorPosition() + 1);\r\n                                setText(before + after);\r\n                            }\r\n                            eventHandled = true;\r\n                            break;\r\n                        }\r\n                    case KeyId.ENTER:\r\n                    case KeyId.NUMPAD_ENTER:\r\n                        {\r\n                            if (event.getKeyboard().isKeyDown(Keyboard.Key.LEFT_SHIFT.getId()) || event.getKeyboard().isKeyDown(Keyboard.Key.RIGHT_SHIFT.getId())) {\r\n                                if (multiline) {\r\n                                    setText(fullText + \"\\n\");\r\n                                    increaseCursorPosition(1);\r\n                                }\r\n                            }\r\n                            for (ActivateEventListener listener : activationListeners) {\r\n                                listener.onActivated(this);\r\n                            }\r\n                            eventHandled = true;\r\n                            break;\r\n                        }\r\n                    default:\r\n                        {\r\n                            if (event.getKeyboard().isKeyDown(KeyId.LEFT_CTRL) || event.getKeyboard().isKeyDown(KeyId.RIGHT_CTRL)) {\r\n                                if (event.getKey() == Keyboard.Key.V) {\r\n                                    removeSelection();\r\n                                    paste();\r\n                                    eventHandled = true;\r\n                                    break;\r\n                                } else if (event.getKey() == Keyboard.Key.X) {\r\n                                    copySelection();\r\n                                    removeSelection();\r\n                                    eventHandled = true;\r\n                                    break;\r\n                                }\r\n                            }\r\n                            if (event.getKeyCharacter() != 0 && lastFont.hasCharacter(event.getKeyCharacter())) {\r\n                                String before = fullText.substring(0, Math.min(getCursorPosition(), selectionStart));\r\n                                String after = fullText.substring(Math.max(getCursorPosition(), selectionStart));\r\n                                setText(before + event.getKeyCharacter() + after);\r\n                                setCursorPosition(Math.min(getCursorPosition(), selectionStart) + 1);\r\n                                eventHandled = true;\r\n                            }\r\n                            break;\r\n                        }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    updateOffset();\r\n    return eventHandled;\r\n}"
}, {
	"Path": "org.terasology.audio.system.AudioSystem.playTestSound",
	"Comment": "plays a test dig sound at an offset from the player in the x and z axis.",
	"Method": "void playTestSound(EntityRef sender,float xOffset,float zOffset){\r\n    Vector3f position = localPlayer.getPosition();\r\n    position.x += xOffset;\r\n    position.z += zOffset;\r\n    audioManager.playSound(Assets.getSound(\"engine:dig\").get(), position);\r\n}"
}, {
	"Path": "org.terasology.rendering.opengl.FBO.bindLightBufferTexture",
	"Comment": "binds the light buffer attachment to the currently active texture unit.once a texture is bound it can be sampled by shaders.",
	"Method": "void bindLightBufferTexture(){\r\n    GL11.glBindTexture(GL11.GL_TEXTURE_2D, lightBufferTextureId);\r\n}"
}, {
	"Path": "org.springframework.security.config.ldap.LdapServerBeanDefinitionParser.createEmbeddedServer",
	"Comment": "will be called if no url attribute is supplied.\tregisters beans to create an embedded apache directory server.",
	"Method": "RootBeanDefinition createEmbeddedServer(Element element,ParserContext parserContext){\r\n    Object source = parserContext.extractSource(element);\r\n    String suffix = element.getAttribute(ATT_ROOT_SUFFIX);\r\n    if (!StringUtils.hasText(suffix)) {\r\n        suffix = OPT_DEFAULT_ROOT_SUFFIX;\r\n    }\r\n    String port = element.getAttribute(ATT_PORT);\r\n    if (!StringUtils.hasText(port)) {\r\n        port = getDefaultPort();\r\n        if (logger.isDebugEnabled()) {\r\n            logger.debug(\"Using default port of \" + port);\r\n        }\r\n    }\r\n    String url = \"ldap://127.0.0.1:\" + port + \"/\" + suffix;\r\n    BeanDefinitionBuilder contextSource = BeanDefinitionBuilder.rootBeanDefinition(CONTEXT_SOURCE_CLASS);\r\n    contextSource.addConstructorArgValue(url);\r\n    contextSource.addPropertyValue(\"userDn\", \"uid=admin,ou=system\");\r\n    contextSource.addPropertyValue(\"password\", \"secret\");\r\n    RootBeanDefinition apacheContainer = new RootBeanDefinition(\"org.springframework.security.ldap.server.ApacheDSContainer\", null, null);\r\n    apacheContainer.setSource(source);\r\n    apacheContainer.getConstructorArgumentValues().addGenericArgumentValue(suffix);\r\n    String ldifs = element.getAttribute(ATT_LDIF_FILE);\r\n    if (!StringUtils.hasText(ldifs)) {\r\n        ldifs = OPT_DEFAULT_LDIF_FILE;\r\n    }\r\n    apacheContainer.getConstructorArgumentValues().addGenericArgumentValue(ldifs);\r\n    apacheContainer.getPropertyValues().addPropertyValue(\"port\", port);\r\n    logger.info(\"Embedded LDAP server bean definition created for URL: \" + url);\r\n    if (parserContext.getRegistry().containsBeanDefinition(BeanIds.EMBEDDED_APACHE_DS)) {\r\n        parserContext.getReaderContext().error(\"Only one embedded server bean is allowed per application context\", element);\r\n    }\r\n    parserContext.getRegistry().registerBeanDefinition(BeanIds.EMBEDDED_APACHE_DS, apacheContainer);\r\n    return (RootBeanDefinition) contextSource.getBeanDefinition();\r\n}"
}, {
	"Path": "org.springframework.security.ldap.ppolicy.PasswordPolicyControl.getEncodedValue",
	"Comment": "retrieves the asn.1 ber encoded value of the ldap control. the request value for\tthis control is always empty.",
	"Method": "byte[] getEncodedValue(){\r\n    return null;\r\n}"
}, {
	"Path": "org.terasology.persistence.serializers.EventSerializer.removeIdMapping",
	"Comment": "clears the mapping between event classes and ids. this causes event to be serialized with their eventname instead.",
	"Method": "void removeIdMapping(){\r\n    idTable = ImmutableBiMap.<Class<? extends Event>, Integer>builder().build();\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.widgets.UIList.subscribeSelection",
	"Comment": "subscribe an event listener to be called then an item is selected.",
	"Method": "void subscribeSelection(ItemSelectEventListener<T> eventListener){\r\n    selectionListeners.add(eventListener);\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.setSessionAuthenticationStrategy",
	"Comment": "the session handling strategy which will be invoked immediately after an\tauthentication request is successfully processed by the\tauthenticationmanager. used, for example, to handle changing of the\tsession identifier to prevent session fixation attacks.",
	"Method": "void setSessionAuthenticationStrategy(SessionAuthenticationStrategy sessionStrategy){\r\n    this.sessionStrategy = sessionStrategy;\r\n}"
}, {
	"Path": "org.terasology.config.PlayerConfig.defaultPlayerColor",
	"Comment": "randomly generates a default color for the player via a random int generator using fastrandom object.",
	"Method": "Color defaultPlayerColor(){\r\n    Random rng = new FastRandom();\r\n    List<Color> colors = CieCamColors.L65C65;\r\n    return colors.get(rng.nextInt(colors.size()));\r\n}"
}, {
	"Path": "org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.x509",
	"Comment": "finds an x509cetificate using a resourename and populates it on the request.",
	"Method": "RequestPostProcessor x509(X509Certificate certificates,RequestPostProcessor x509,String resourceName){\r\n    ResourceLoader loader = new DefaultResourceLoader();\r\n    Resource resource = loader.getResource(resourceName);\r\n    InputStream inputStream = resource.getInputStream();\r\n    CertificateFactory certFactory = CertificateFactory.getInstance(\"X.509\");\r\n    X509Certificate certificate = (X509Certificate) certFactory.generateCertificate(inputStream);\r\n    return x509(certificate);\r\n}"
}, {
	"Path": "org.terasology.rendering.dag.AbstractNode.removeDesiredStateChange",
	"Comment": "removes a statechange object from the set of desired state changes.",
	"Method": "void removeDesiredStateChange(StateChange stateChange){\r\n    desiredStateChanges.remove(stateChange);\r\n}"
}, {
	"Path": "org.springframework.security.config.annotation.web.configurers.SessionManagementConfigurer.maximumSessions",
	"Comment": "controls the maximum number of sessions for a user. the default is to allow any\tnumber of users.",
	"Method": "ConcurrencyControlConfigurer maximumSessions(int maximumSessions){\r\n    this.maximumSessions = maximumSessions;\r\n    return new ConcurrencyControlConfigurer();\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.widgets.UIList.subscribe",
	"Comment": "subscribe an event listener to be called upon the list being activated.",
	"Method": "void subscribe(ItemActivateEventListener<T> eventListener){\r\n    activateListeners.add(eventListener);\r\n}"
}, {
	"Path": "org.terasology.rendering.assets.texture.TextureUtil.getTextureUriForColor",
	"Comment": "returns a asseturi which represents a texture of that color.",
	"Method": "ResourceUrn getTextureUriForColor(Color color){\r\n    return new ResourceUrn(TerasologyConstants.ENGINE_MODULE, COLOR_RESOURCE_NAME, new Name(getColorName(color)));\r\n}"
}, {
	"Path": "org.terasology.engine.bootstrap.EnvironmentSwitchHandler.cheapAssetManagerUpdate",
	"Comment": "switches the environment of the asset manager to the specified one. it does not register the prefab formatsas they require a proper componentlibrary.the existence of this method call is questionable. it has only be introduced to make sure thatthe asset type manager has never prefab formats that reference an old componentlibrary.",
	"Method": "void cheapAssetManagerUpdate(Context context,ModuleEnvironment environment){\r\n    ModuleAwareAssetTypeManager moduleAwareAssetTypeManager = context.get(ModuleAwareAssetTypeManager.class);\r\n    unregisterPrefabFormats(moduleAwareAssetTypeManager);\r\n    moduleAwareAssetTypeManager.switchEnvironment(environment);\r\n}"
}, {
	"Path": "org.terasology.logic.location.DistanceComparator.setOrigin",
	"Comment": "sets the origin, which is used to calculate the distance from.this method should not be called while sorting. if done anyway, thecontract of compare method will be broken and the sorting resultsare undefined, if by chance no exception is thrown.",
	"Method": "void setOrigin(Vector3f newOrigin){\r\n    origin.set(newOrigin);\r\n}"
}, {
	"Path": "org.terasology.utilities.concurrency.TaskMaster.put",
	"Comment": "adds a task to this task master. this blocks until the task can be added if the queue is full.",
	"Method": "void put(T task){\r\n    taskQueue.put(task);\r\n}"
}, {
	"Path": "org.terasology.input.InputSystem.updateInputEntities",
	"Comment": "updates the client and input entities of the local player, to be used in input events against the local player.",
	"Method": "void updateInputEntities(){\r\n    inputEntities = new EntityRef[] { localPlayer.getClientEntity(), localPlayer.getCharacterEntity() };\r\n}"
}, {
	"Path": "org.terasology.engine.module.ModuleDownloadListGenerator.isSourceModule",
	"Comment": "whether the given module is present as source in the workspace.this is relevant when running the game from a local workspace to prevent downloading modules already present assource.",
	"Method": "boolean isSourceModule(Module module){\r\n    return module instanceof PathModule;\r\n}"
}, {
	"Path": "org.terasology.math.Rotation.values",
	"Comment": "returns only unique rotations, in respect to transformations, rather than in respect to yaw, pitch & roll.",
	"Method": "Iterable<Rotation> values(){\r\n    return NORMALIZED_ROTATIONS.valueCollection();\r\n}"
}, {
	"Path": "org.springframework.security.oauth2.jwt.NimbusJwtDecoder.decode",
	"Comment": "decode and validate the jwt from its compact claims representation format",
	"Method": "Jwt decode(String token){\r\n    JWT jwt = parse(token);\r\n    if (jwt instanceof SignedJWT) {\r\n        Jwt createdJwt = createJwt(token, jwt);\r\n        return validateJwt(createdJwt);\r\n    }\r\n    throw new JwtException(\"Unsupported algorithm of \" + jwt.getHeader().getAlgorithm());\r\n}"
}, {
	"Path": "org.springframework.security.web.util.matcher.RegexRequestMatcher.valueOf",
	"Comment": "provides a save way of obtaining the httpmethod from a string. if the method is\tinvalid, returns null.",
	"Method": "HttpMethod valueOf(String method){\r\n    try {\r\n        return HttpMethod.valueOf(method);\r\n    } catch (IllegalArgumentException e) {\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.terasology.recording.EventCatcher.startTimer",
	"Comment": "starts the timer to generate the correct timestamp in which an event was sent and stored.",
	"Method": "void startTimer(){\r\n    this.startTime = System.currentTimeMillis();\r\n    this.eventCounter = 0;\r\n}"
}, {
	"Path": "org.terasology.network.internal.HandshakeCommon.generateMasterSecret",
	"Comment": "generates the master secret, a common secret between the server and client used to generate a symmetric encryption key",
	"Method": "byte[] generateMasterSecret(byte[] preMasterSecret,byte[] clientRandom,byte[] serverRandom){\r\n    return SecretGenerator.generate(preMasterSecret, SecretGenerator.MASTER_SECRET_LABEL, Bytes.concat(clientRandom, serverRandom), SecretGenerator.MASTER_SECRET_LENGTH);\r\n}"
}, {
	"Path": "org.terasology.rendering.dag.stateChanges.ReflectedCamera.getDefaultInstance",
	"Comment": "returns an instance of this class configured to generate a task resettingthe reflected flag of the camera provided on construction.",
	"Method": "StateChange getDefaultInstance(){\r\n    if (defaultInstance == null) {\r\n        defaultInstance = new ReflectedCamera(camera, false);\r\n    }\r\n    return defaultInstance;\r\n}"
}, {
	"Path": "org.springframework.security.ldap.SpringSecurityLdapTemplate.buildControls",
	"Comment": "we need to make sure the search controls has the return object flag set to true, in\torder for the search to return dircontextadapter instances.",
	"Method": "SearchControls buildControls(SearchControls originalControls){\r\n    return new SearchControls(originalControls.getSearchScope(), originalControls.getCountLimit(), originalControls.getTimeLimit(), originalControls.getReturningAttributes(), RETURN_OBJECT, originalControls.getDerefLinkFlag());\r\n}"
}, {
	"Path": "org.springframework.security.crypto.password.PasswordEncoder.upgradeEncoding",
	"Comment": "returns true if the encoded password should be encoded again for better security,\telse false. the default implementation always returns false.",
	"Method": "boolean upgradeEncoding(String encodedPassword){\r\n    return false;\r\n}"
}, {
	"Path": "org.terasology.input.InputSystem.updateBindState",
	"Comment": "updates the bind state of a button bind based on provided input information.",
	"Method": "void updateBindState(BindableButton bind,Input input,boolean pressed,float delta,boolean consumed){\r\n    bind.updateBindState(input, pressed, delta, inputEntities, targetSystem.getTarget(), targetSystem.getTargetBlockPosition(), targetSystem.getHitPosition(), targetSystem.getHitNormal(), consumed, time.getGameTimeInMs());\r\n}"
}, {
	"Path": "org.springframework.security.web.context.HttpSessionSecurityContextRepository.setDisableUrlRewriting",
	"Comment": "allows the use of session identifiers in urls to be disabled. off by default.",
	"Method": "void setDisableUrlRewriting(boolean disableUrlRewriting){\r\n    this.disableUrlRewriting = disableUrlRewriting;\r\n}"
}, {
	"Path": "org.terasology.network.internal.ClientConnectionHandler.receiveModuleStart",
	"Comment": "attempts to receive a module from the server and push it to the client. creates a file on the target machine and begins preparation to write to it.",
	"Method": "void receiveModuleStart(ChannelHandlerContext channelHandlerContext,NetData.ModuleDataHeader moduleDataHeader){\r\n    if (receivingModule != null) {\r\n        joinStatus.setErrorMessage(\"Module download error\");\r\n        channelHandlerContext.getChannel().close();\r\n        return;\r\n    }\r\n    String moduleId = moduleDataHeader.getId();\r\n    if (missingModules.remove(moduleId.toLowerCase(Locale.ENGLISH))) {\r\n        if (moduleDataHeader.hasError()) {\r\n            joinStatus.setErrorMessage(\"Module download error: \" + moduleDataHeader.getError());\r\n            channelHandlerContext.getChannel().close();\r\n        } else {\r\n            String sizeString = getSizeString(moduleDataHeader.getSize());\r\n            joinStatus.setCurrentActivity(\"Downloading \" + moduleDataHeader.getId() + \":\" + moduleDataHeader.getVersion() + \" (\" + sizeString + \",\" + missingModules.size() + \" modules remain)\");\r\n            logger.info(\"Downloading \" + moduleDataHeader.getId() + \":\" + moduleDataHeader.getVersion() + \" (\" + sizeString + \",\" + missingModules.size() + \" modules remain)\");\r\n            receivingModule = moduleDataHeader;\r\n            lengthReceived = 0;\r\n            try {\r\n                tempModuleLocation = Files.createTempFile(\"terasologyDownload\", \".tmp\");\r\n                tempModuleLocation.toFile().deleteOnExit();\r\n                downloadingModule = new BufferedOutputStream(Files.newOutputStream(tempModuleLocation, StandardOpenOption.WRITE));\r\n            } catch (IOException e) {\r\n                logger.error(\"Failed to write received module\", e);\r\n                joinStatus.setErrorMessage(\"Module download error\");\r\n                channelHandlerContext.getChannel().close();\r\n            }\r\n        }\r\n    } else {\r\n        logger.error(\"Received unwanted module {}:{} from server\", moduleDataHeader.getId(), moduleDataHeader.getVersion());\r\n        joinStatus.setErrorMessage(\"Module download error\");\r\n        channelHandlerContext.getChannel().close();\r\n    }\r\n}"
}, {
	"Path": "org.springframework.security.taglibs.authz.AbstractAuthorizeTag.authorizeUsingUrlCheck",
	"Comment": "make an authorization decision based on the url and http method attributes. true is\treturned if the user is allowed to access the given url as defined.",
	"Method": "boolean authorizeUsingUrlCheck(){\r\n    String contextPath = ((HttpServletRequest) getRequest()).getContextPath();\r\n    Authentication currentUser = SecurityContextHolder.getContext().getAuthentication();\r\n    return getPrivilegeEvaluator().isAllowed(contextPath, getUrl(), getMethod(), currentUser);\r\n}"
}, {
	"Path": "org.springframework.security.ldap.userdetails.LdapUserDetailsMapper.setConvertToUpperCase",
	"Comment": "determines whether role field values will be converted to upper case when loaded.\tthe default is true.",
	"Method": "void setConvertToUpperCase(boolean convertToUpperCase){\r\n    this.convertToUpperCase = convertToUpperCase;\r\n}"
}, {
	"Path": "springfox.documentation.builders.ResourceListingBuilder.securitySchemes",
	"Comment": "updates the security definitions that protect this resource listing",
	"Method": "ResourceListingBuilder securitySchemes(List<? extends SecurityScheme> authorizations){\r\n    this.securitySchemes.addAll(nullToEmptyList(authorizations));\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.security.web.authentication.switchuser.SwitchUserFilter.createSwitchUserToken",
	"Comment": "create a switch user token that contains an additional grantedauthority\tthat contains the original authentication object.",
	"Method": "UsernamePasswordAuthenticationToken createSwitchUserToken(HttpServletRequest request,UserDetails targetUser){\r\n    UsernamePasswordAuthenticationToken targetUserRequest;\r\n    Authentication currentAuth;\r\n    try {\r\n        currentAuth = attemptExitUser(request);\r\n    } catch (AuthenticationCredentialsNotFoundException e) {\r\n        currentAuth = SecurityContextHolder.getContext().getAuthentication();\r\n    }\r\n    GrantedAuthority switchAuthority = new SwitchUserGrantedAuthority(this.switchAuthorityRole, currentAuth);\r\n    Collection<? extends GrantedAuthority> orig = targetUser.getAuthorities();\r\n    if (this.switchUserAuthorityChanger != null) {\r\n        orig = this.switchUserAuthorityChanger.modifyGrantedAuthorities(targetUser, currentAuth, orig);\r\n    }\r\n    List<GrantedAuthority> newAuths = new ArrayList(orig);\r\n    newAuths.add(switchAuthority);\r\n    targetUserRequest = new UsernamePasswordAuthenticationToken(targetUser, targetUser.getPassword(), newAuths);\r\n    targetUserRequest.setDetails(this.authenticationDetailsSource.buildDetails(request));\r\n    return targetUserRequest;\r\n}"
}, {
	"Path": "org.terasology.rendering.nui.layers.ingame.metrics.DebugMetricsSystem.unregisterAll",
	"Comment": "removes all registered metrics modes except an instance of nullmetricsmode, which is guaranteed to be always available.",
	"Method": "void unregisterAll(){\r\n    modes.clear();\r\n    cursor = 0;\r\n    register(defaultMode);\r\n    currentMode = defaultMode;\r\n}"
}, {
	"Path": "org.springframework.security.TargetObject.makeLowerCase",
	"Comment": "returns the lowercase string, followed by security environment information.",
	"Method": "String makeLowerCase(String input){\r\n    Authentication auth = SecurityContextHolder.getContext().getAuthentication();\r\n    if (auth == null) {\r\n        return input.toLowerCase() + \" Authentication empty\";\r\n    } else {\r\n        return input.toLowerCase() + \" \" + auth.getClass().getName() + \" \" + auth.isAuthenticated();\r\n    }\r\n}"
}]