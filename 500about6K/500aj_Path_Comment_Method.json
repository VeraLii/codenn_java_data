[{
	"Path": "io.aeron.logbuffer.LogBufferDescriptor.defaultFrameHeader",
	"Comment": "get a wrapper around the default frame header from the log meta data.",
	"Method": "UnsafeBuffer defaultFrameHeader(UnsafeBuffer logMetaDataBuffer){\r\n    return new UnsafeBuffer(logMetaDataBuffer, LOG_DEFAULT_FRAME_HEADER_OFFSET, HEADER_LENGTH);\r\n}"
}, {
	"Path": "org.atmosphere.runtime.AtmosphereResponseImpl.newInstance",
	"Comment": "create an instance not associated with any response parent.",
	"Method": "AtmosphereResponse newInstance(AtmosphereResponse newInstance,AtmosphereRequest request,AtmosphereResponse newInstance,AtmosphereConfig config,AtmosphereRequest request,WebSocket webSocket){\r\n    boolean destroyable;\r\n    String s = config.getInitParameter(RECYCLE_ATMOSPHERE_REQUEST_RESPONSE);\r\n    if (s != null && Boolean.valueOf(s)) {\r\n        destroyable = true;\r\n    } else {\r\n        destroyable = false;\r\n    }\r\n    return new AtmosphereResponseImpl(webSocket, request, destroyable);\r\n}"
}, {
	"Path": "org.bitcoinj.protocols.channels.StoredPaymentChannelClientStates.getFromWallet",
	"Comment": "returns this extension from the given wallet, or null if no such extension was added.",
	"Method": "StoredPaymentChannelClientStates getFromWallet(Wallet wallet){\r\n    return (StoredPaymentChannelClientStates) wallet.getExtensions().get(EXTENSION_ID);\r\n}"
}, {
	"Path": "org.bitcoinj.core.TransactionInput.setScriptSig",
	"Comment": "set the given program as the scriptsig that is supposed to satisfy the connected output script.",
	"Method": "void setScriptSig(Script scriptSig){\r\n    this.scriptSig = new WeakReference(checkNotNull(scriptSig));\r\n    setScriptBytes(scriptSig.getProgram());\r\n}"
}, {
	"Path": "org.bitcoinj.protocols.payments.PaymentSession.getMemo",
	"Comment": "returns the memo included by the merchant in the payment request, or null if not found.",
	"Method": "String getMemo(){\r\n    if (paymentDetails.hasMemo())\r\n        return paymentDetails.getMemo();\r\n    else\r\n        return null;\r\n}"
}, {
	"Path": "org.bitcoinj.core.PartialMerkleTree.getTxnHashAndMerkleRoot",
	"Comment": "extracts tx hashes that are in this merkle treeand returns the merkle root of this tree.the returned root should be checked against themerkle root contained in the block header for security.",
	"Method": "Sha256Hash getTxnHashAndMerkleRoot(List<Sha256Hash> matchedHashesOut){\r\n    matchedHashesOut.clear();\r\n    if (transactionCount == 0)\r\n        throw new VerificationException(\"Got a CPartialMerkleTree with 0 transactions\");\r\n    if (transactionCount > Block.MAX_BLOCK_SIZE / 60)\r\n        throw new VerificationException(\"Got a CPartialMerkleTree with more transactions than is possible\");\r\n    if (hashes.size() > transactionCount)\r\n        throw new VerificationException(\"Got a CPartialMerkleTree with more hashes than transactions\");\r\n    if (matchedChildBits.length * 8 < hashes.size())\r\n        throw new VerificationException(\"Got a CPartialMerkleTree with fewer matched bits than hashes\");\r\n    int height = 0;\r\n    while (getTreeWidth(transactionCount, height) > 1) height++;\r\n    ValuesUsed used = new ValuesUsed();\r\n    Sha256Hash merkleRoot = recursiveExtractHashes(height, 0, used, matchedHashesOut);\r\n    if ((used.bitsUsed + 7) / 8 != matchedChildBits.length || used.hashesUsed != hashes.size())\r\n        throw new VerificationException(\"Got a CPartialMerkleTree that didn't need all the data it provided\");\r\n    return merkleRoot;\r\n}"
}, {
	"Path": "org.bitcoinj.script.Script.getScriptSigWithSignature",
	"Comment": "returns a copy of the given scriptsig with the signature inserted in the given position.",
	"Method": "Script getScriptSigWithSignature(Script scriptSig,byte[] sigBytes,int index){\r\n    int sigsPrefixCount = 0;\r\n    int sigsSuffixCount = 0;\r\n    if (ScriptPattern.isPayToScriptHash(this)) {\r\n        sigsPrefixCount = 1;\r\n        sigsSuffixCount = 1;\r\n    } else if (ScriptPattern.isSentToMultisig(this)) {\r\n        sigsPrefixCount = 1;\r\n    } else if (ScriptPattern.isPayToPubKeyHash(this)) {\r\n        sigsSuffixCount = 1;\r\n    }\r\n    return ScriptBuilder.updateScriptWithSignature(scriptSig, sigBytes, index, sigsPrefixCount, sigsSuffixCount);\r\n}"
}, {
	"Path": "org.bitcoinj.core.AlertMessage.getId",
	"Comment": "the numeric identifier of this alert. each alert should have a unique id, but the signer can choose any number.if an alert is broadcast with a cancel field higher than this id, this alert is considered cancelled.",
	"Method": "long getId(){\r\n    return id;\r\n}"
}, {
	"Path": "org.atmosphere.util.analytics.JGoogleAnalyticsTracker.setUrlBuildingStrategy",
	"Comment": "setter injection for urlbuildingstrategy incase if you want to use a different url building logic.",
	"Method": "void setUrlBuildingStrategy(URLBuildingStrategy urlBuildingStrategy){\r\n    this.urlBuildingStrategy = urlBuildingStrategy;\r\n}"
}, {
	"Path": "org.bitcoinj.core.ECKey.fromASN1",
	"Comment": "construct an eckey from an asn.1 encoded private key. these are produced by openssl and stored by bitcoincore in its wallet. note that this is slow because it requires an ec point multiply.",
	"Method": "ECKey fromASN1(byte[] asn1privkey){\r\n    return extractKeyFromASN1(asn1privkey);\r\n}"
}, {
	"Path": "org.bitcoinj.core.VersionMessage.isGetUTXOsSupported",
	"Comment": "returns true if the protocol version and service bits both indicate support for the getutxos message.",
	"Method": "boolean isGetUTXOsSupported(){\r\n    return clientVersion >= GetUTXOsMessage.MIN_PROTOCOL_VERSION && (localServices & NODE_GETUTXOS) == NODE_GETUTXOS;\r\n}"
}, {
	"Path": "org.atmosphere.util.IntrospectionUtils.addToClassPath",
	"Comment": "add all the jar files in a dir to the classpath, represented as a vectorof urls.",
	"Method": "void addToClassPath(Vector<URL> cpV,String dir){\r\n    try {\r\n        String[] cpComp = getFilesByExt(dir, \".jar\");\r\n        if (cpComp != null) {\r\n            int jarCount = cpComp.length;\r\n            for (int i = 0; i < jarCount; i++) {\r\n                URL url = getURL(dir, cpComp[i]);\r\n                if (url != null)\r\n                    cpV.addElement(url);\r\n            }\r\n        }\r\n    } catch (Exception ex) {\r\n        logger.debug(\"failed to add urls to classpath\", ex);\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.script.ScriptBuilder.build",
	"Comment": "creates a new immutable script based on the state of the builder.",
	"Method": "Script build(){\r\n    return new Script(chunks);\r\n}"
}, {
	"Path": "io.aeron.logbuffer.TermScanner.scanForAvailability",
	"Comment": "scan the term buffer for availability of new message fragments from a given offset up to a maxlength of bytes.",
	"Method": "long scanForAvailability(UnsafeBuffer termBuffer,int offset,int maxLength){\r\n    final int limit = Math.min(maxLength, termBuffer.capacity() - offset);\r\n    int available = 0;\r\n    int padding = 0;\r\n    do {\r\n        final int termOffset = offset + available;\r\n        final int frameLength = frameLengthVolatile(termBuffer, termOffset);\r\n        if (frameLength <= 0) {\r\n            break;\r\n        }\r\n        int alignedFrameLength = align(frameLength, FRAME_ALIGNMENT);\r\n        if (isPaddingFrame(termBuffer, termOffset)) {\r\n            padding = alignedFrameLength - HEADER_LENGTH;\r\n            alignedFrameLength = HEADER_LENGTH;\r\n        }\r\n        available += alignedFrameLength;\r\n        if (available > limit) {\r\n            available -= alignedFrameLength;\r\n            padding = 0;\r\n            break;\r\n        }\r\n    } while (0 == padding && available < limit);\r\n    return pack(padding, available);\r\n}"
}, {
	"Path": "org.atmosphere.util.uri.UriTemplate.hashCode",
	"Comment": "hashcode is calculated from string of the regular expression generated from the template.",
	"Method": "int hashCode(){\r\n    return pattern.hashCode();\r\n}"
}, {
	"Path": "problems.medium.RotateImage.rotate",
	"Comment": "the first solution is setting 4 rotated values in its own place.",
	"Method": "void rotate(int[][] a){\r\n    int n = a.length;\r\n    for (int i = 0; i < n / 2; i++) {\r\n        for (int j = i; j < n - i - 1; j++) {\r\n            int temp = a[i][j];\r\n            a[i][j] = a[n - j - 1][i];\r\n            a[n - j - 1][i] = a[n - i - 1][n - j - 1];\r\n            a[n - i - 1][n - j - 1] = a[j][n - i - 1];\r\n            a[j][n - i - 1] = temp;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "problems.medium.PeekingIterator.peek",
	"Comment": "returns the next element in the iteration without advancing the iterator.",
	"Method": "Integer peek(){\r\n    return list.getFirst();\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.removeChangeEventListener",
	"Comment": "removes the given event listener object. returns true if the listener was removed, false if that listenerwas never added.",
	"Method": "boolean removeChangeEventListener(WalletChangeEventListener listener){\r\n    return ListenerRegistration.removeFromList(listener, changeListeners);\r\n}"
}, {
	"Path": "org.bitcoinj.script.ScriptPattern.isSentToCltvPaymentChannel",
	"Comment": "returns whether this script matches the format used for locktimeverify transactions.",
	"Method": "boolean isSentToCltvPaymentChannel(Script script){\r\n    List<ScriptChunk> chunks = script.chunks;\r\n    if (chunks.size() != 10)\r\n        return false;\r\n    if (!chunks.get(0).equalsOpCode(OP_IF))\r\n        return false;\r\n    if (!chunks.get(2).equalsOpCode(OP_CHECKSIGVERIFY))\r\n        return false;\r\n    if (!chunks.get(3).equalsOpCode(OP_ELSE))\r\n        return false;\r\n    if (!chunks.get(5).equalsOpCode(OP_CHECKLOCKTIMEVERIFY))\r\n        return false;\r\n    if (!chunks.get(6).equalsOpCode(OP_DROP))\r\n        return false;\r\n    if (!chunks.get(7).equalsOpCode(OP_ENDIF))\r\n        return false;\r\n    if (!chunks.get(9).equalsOpCode(OP_CHECKSIG))\r\n        return false;\r\n    return true;\r\n}"
}, {
	"Path": "io.aeron.cluster.ClusterMember.resetLogPositions",
	"Comment": "reset the log position of all the members to the provided value.",
	"Method": "void resetLogPositions(ClusterMember[] clusterMembers,long logPosition){\r\n    for (final ClusterMember member : clusterMembers) {\r\n        member.logPosition(logPosition);\r\n    }\r\n}"
}, {
	"Path": "io.aeron.cluster.ClusterMember.isUnanimousCandidate",
	"Comment": "has the member achieved a unanimous view to be a suitable candidate in an election.",
	"Method": "boolean isUnanimousCandidate(ClusterMember[] clusterMembers,ClusterMember candidate){\r\n    for (final ClusterMember member : clusterMembers) {\r\n        if (NULL_POSITION == member.logPosition || compareLog(candidate, member) < 0) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.KeyChainGroup.importKeys",
	"Comment": "imports the given keys into the basic chain, creating it if necessary.",
	"Method": "int importKeys(List<ECKey> keys,int importKeys,ECKey keys){\r\n    return importKeys(ImmutableList.copyOf(keys));\r\n}"
}, {
	"Path": "org.bitcoinj.utils.ExchangeRate.coinToFiat",
	"Comment": "convert a coin amount to a fiat amount using this exchange rate.",
	"Method": "Fiat coinToFiat(Coin convertCoin){\r\n    final BigInteger converted = BigInteger.valueOf(convertCoin.value).multiply(BigInteger.valueOf(fiat.value)).divide(BigInteger.valueOf(coin.value));\r\n    if (converted.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) > 0 || converted.compareTo(BigInteger.valueOf(Long.MIN_VALUE)) < 0)\r\n        throw new ArithmeticException(\"Overflow\");\r\n    return Fiat.valueOf(fiat.currencyCode, converted.longValue());\r\n}"
}, {
	"Path": "io.aeron.ChannelUriStringBuilder.sessionId",
	"Comment": "get the session id for a publication or restricted subscription.",
	"Method": "ChannelUriStringBuilder sessionId(Integer sessionId,Integer sessionId){\r\n    return sessionId;\r\n}"
}, {
	"Path": "io.aeron.samples.RateReporter.onMessage",
	"Comment": "notify rate reporter of number of messages and bytes received, sent, etc.",
	"Method": "void onMessage(long messages,long bytes){\r\n    totalBytes += bytes;\r\n    totalMessages += messages;\r\n}"
}, {
	"Path": "problems.medium.EggDropPuzzle.eggDrop",
	"Comment": "function to get minimum number of trials needed in worstcase with n eggs and k floors",
	"Method": "int eggDrop(int n,int k){\r\n    int[][] eggFloor = new int[n + 1][k + 1];\r\n    int res;\r\n    int i, j, x;\r\n    for (i = 1; i <= n; i++) {\r\n        eggFloor[i][1] = 1;\r\n        eggFloor[i][0] = 0;\r\n    }\r\n    for (j = 1; j <= k; j++) eggFloor[1][j] = j;\r\n    for (i = 2; i <= n; i++) {\r\n        for (j = 2; j <= k; j++) {\r\n            eggFloor[i][j] = Integer.MAX_VALUE;\r\n            for (x = 1; x <= j; x++) {\r\n                res = 1 + max(eggFloor[i - 1][x - 1], eggFloor[i][j - x]);\r\n                if (res < eggFloor[i][j])\r\n                    eggFloor[i][j] = res;\r\n            }\r\n        }\r\n    }\r\n    return eggFloor[n][k];\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.setDescription",
	"Comment": "set the description of the wallet.this is a unicode encoding string typically entered by the user as descriptive text for the wallet.",
	"Method": "void setDescription(String description){\r\n    this.description = description;\r\n}"
}, {
	"Path": "io.aeron.archive.client.AeronArchive.pollForErrorResponse",
	"Comment": "poll the response stream once for an error. if another message is present then it will be skipped overso only call when not expecting another response.",
	"Method": "String pollForErrorResponse(){\r\n    lock.lock();\r\n    try {\r\n        if (controlResponsePoller.poll() != 0 && controlResponsePoller.isPollComplete()) {\r\n            if (controlResponsePoller.controlSessionId() == controlSessionId && controlResponsePoller.templateId() == ControlResponseDecoder.TEMPLATE_ID && controlResponsePoller.code() == ControlResponseCode.ERROR) {\r\n                return controlResponsePoller.errorMessage();\r\n            }\r\n        }\r\n        return null;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "io.aeron.logbuffer.LogBufferDescriptor.activeTermCountOrdered",
	"Comment": "set the value of the current active term count for the producer using memory ordered semantics.",
	"Method": "void activeTermCountOrdered(UnsafeBuffer logMetaDataBuffer,int termCount){\r\n    logMetaDataBuffer.putIntOrdered(LOG_ACTIVE_TERM_COUNT_OFFSET, termCount);\r\n}"
}, {
	"Path": "org.bitcoinj.core.AlertMessage.getMaxVer",
	"Comment": "the inclusive upper bound on software versions considered for the purposes of this alert. bitcoin corecompares this against a protocol version field, but as long as the subver field is used to restrict it youralerts could use any version numbers.",
	"Method": "long getMaxVer(){\r\n    return maxVer;\r\n}"
}, {
	"Path": "org.bitcoinj.script.Script.getPubKeyHash",
	"Comment": "if the program somehow pays to a hash, returns the hash.otherwise this method throws a scriptexception.",
	"Method": "byte[] getPubKeyHash(){\r\n    if (ScriptPattern.isPayToPubKeyHash(this))\r\n        return ScriptPattern.extractHashFromPayToPubKeyHash(this);\r\n    else if (ScriptPattern.isPayToScriptHash(this))\r\n        return ScriptPattern.extractHashFromPayToScriptHash(this);\r\n    else if (ScriptPattern.isPayToWitnessHash(this))\r\n        return ScriptPattern.extractHashFromPayToWitnessHash(this);\r\n    else\r\n        throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, \"Script not in the standard scriptPubKey form\");\r\n}"
}, {
	"Path": "problems.medium.NextPermutation.nextPermutation",
	"Comment": "solution idea, first find an element whose left element is smaller than its value then walk through the array from current index to find min element that is also larger than current element swap min element with current element and sort the array from current index to end",
	"Method": "void nextPermutation(int[] nums){\r\n    for (int i = nums.length - 1; i > 0; i--) {\r\n        if (nums[i] > nums[i - 1]) {\r\n            int min = Integer.MAX_VALUE;\r\n            int mini = i - 1;\r\n            for (int j = i; j < nums.length; j++) {\r\n                if (nums[j] <= nums[i - 1])\r\n                    continue;\r\n                if (nums[j] < min) {\r\n                    min = nums[j];\r\n                    mini = j;\r\n                }\r\n            }\r\n            int temp = nums[i - 1];\r\n            nums[i - 1] = nums[mini];\r\n            nums[mini] = temp;\r\n            Arrays.sort(nums, i, nums.length);\r\n            return;\r\n        }\r\n    }\r\n    Arrays.sort(nums);\r\n}"
}, {
	"Path": "org.bitcoinj.utils.BtcFormat.symbols",
	"Comment": "return a copy of the localized symbols used by this instance for formatting and parsing.",
	"Method": "DecimalFormatSymbols symbols(){\r\n    synchronized (numberFormat) {\r\n        return numberFormat.getDecimalFormatSymbols();\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.AlertMessage.getCancel",
	"Comment": "a marker that results in any alerts with an id lower than this value to be considered cancelled.",
	"Method": "long getCancel(){\r\n    return cancel;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.KeyChainGroup.getKeyCrypter",
	"Comment": "returns the key crypter or null if the group is not encrypted.",
	"Method": "KeyCrypter getKeyCrypter(){\r\n    return keyCrypter;\r\n}"
}, {
	"Path": "org.bitcoinj.protocols.channels.PaymentChannelClientTest.data",
	"Comment": "we use parameterized tests to run the client channel tests with eachversion of the channel.",
	"Method": "Collection<PaymentChannelClient.DefaultClientChannelProperties> data(){\r\n    return Arrays.asList(new PaymentChannelClient.DefaultClientChannelProperties() {\r\n        @Override\r\n        public PaymentChannelClient.VersionSelector versionSelector() {\r\n            return VERSION_1;\r\n        }\r\n    }, new PaymentChannelClient.DefaultClientChannelProperties() {\r\n        @Override\r\n        public PaymentChannelClient.VersionSelector versionSelector() {\r\n            return VERSION_2_ALLOW_1;\r\n        }\r\n    }, new PaymentChannelClient.DefaultClientChannelProperties() {\r\n        @Override\r\n        public PaymentChannelClient.VersionSelector versionSelector() {\r\n            return VERSION_2;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.bitcoinj.protocols.channels.PaymentChannelClientTest.data",
	"Comment": "we use parameterized tests to run the client channel tests with eachversion of the channel.",
	"Method": "Collection<PaymentChannelClient.DefaultClientChannelProperties> data(){\r\n    return VERSION_1;\r\n}"
}, {
	"Path": "org.bitcoinj.protocols.channels.PaymentChannelClientTest.data",
	"Comment": "we use parameterized tests to run the client channel tests with eachversion of the channel.",
	"Method": "Collection<PaymentChannelClient.DefaultClientChannelProperties> data(){\r\n    return VERSION_2_ALLOW_1;\r\n}"
}, {
	"Path": "org.bitcoinj.protocols.channels.PaymentChannelClientTest.data",
	"Comment": "we use parameterized tests to run the client channel tests with eachversion of the channel.",
	"Method": "Collection<PaymentChannelClient.DefaultClientChannelProperties> data(){\r\n    return VERSION_2;\r\n}"
}, {
	"Path": "org.bitcoinj.core.PeerTest.newBlock",
	"Comment": "check that inventory message containing blocks we want is processed correctly.",
	"Method": "void newBlock(){\r\n    Block b1 = createFakeBlock(blockStore, Block.BLOCK_HEIGHT_GENESIS).block;\r\n    blockChain.add(b1);\r\n    final Block b2 = makeSolvedTestBlock(b1);\r\n    final InventoryMessage inv = new InventoryMessage(UNITTEST);\r\n    InventoryItem item = new InventoryItem(InventoryItem.Type.Block, b2.getHash());\r\n    inv.addItem(item);\r\n    final AtomicInteger newBlockMessagesReceived = new AtomicInteger(0);\r\n    connect();\r\n    pingAndWait(writeTarget);\r\n    peer.addPreMessageReceivedEventListener(Threading.SAME_THREAD, new PreMessageReceivedEventListener() {\r\n        @Override\r\n        public synchronized Message onPreMessageReceived(Peer p, Message m) {\r\n            if (p != peer)\r\n                fail.set(true);\r\n            if (m instanceof Pong)\r\n                return m;\r\n            int newValue = newBlockMessagesReceived.incrementAndGet();\r\n            if (newValue == 1 && !inv.equals(m))\r\n                fail.set(true);\r\n            else if (newValue == 2 && !b2.equals(m))\r\n                fail.set(true);\r\n            else if (newValue > 3)\r\n                fail.set(true);\r\n            return m;\r\n        }\r\n    });\r\n    peer.addBlocksDownloadedEventListener(Threading.SAME_THREAD, new BlocksDownloadedEventListener() {\r\n        @Override\r\n        public synchronized void onBlocksDownloaded(Peer p, Block block, @Nullable FilteredBlock filteredBlock, int blocksLeft) {\r\n            int newValue = newBlockMessagesReceived.incrementAndGet();\r\n            if (newValue != 3 || p != peer || !block.equals(b2) || blocksLeft != OTHER_PEER_CHAIN_HEIGHT - 2)\r\n                fail.set(true);\r\n        }\r\n    });\r\n    long height = peer.getBestHeight();\r\n    inbound(writeTarget, inv);\r\n    pingAndWait(writeTarget);\r\n    assertEquals(height + 1, peer.getBestHeight());\r\n    inbound(writeTarget, b2);\r\n    pingAndWait(writeTarget);\r\n    Threading.waitForUserCode();\r\n    pingAndWait(writeTarget);\r\n    assertEquals(3, newBlockMessagesReceived.get());\r\n    GetDataMessage getdata = (GetDataMessage) outbound(writeTarget);\r\n    List<InventoryItem> items = getdata.getItems();\r\n    assertEquals(1, items.size());\r\n    assertEquals(b2.getHash(), items.get(0).hash);\r\n    assertEquals(InventoryItem.Type.Block, items.get(0).type);\r\n}"
}, {
	"Path": "org.bitcoinj.core.PeerTest.newBlock",
	"Comment": "check that inventory message containing blocks we want is processed correctly.",
	"Method": "void newBlock(){\r\n    if (p != peer)\r\n        fail.set(true);\r\n    if (m instanceof Pong)\r\n        return m;\r\n    int newValue = newBlockMessagesReceived.incrementAndGet();\r\n    if (newValue == 1 && !inv.equals(m))\r\n        fail.set(true);\r\n    else if (newValue == 2 && !b2.equals(m))\r\n        fail.set(true);\r\n    else if (newValue > 3)\r\n        fail.set(true);\r\n    return m;\r\n}"
}, {
	"Path": "org.bitcoinj.core.PeerTest.newBlock",
	"Comment": "check that inventory message containing blocks we want is processed correctly.",
	"Method": "void newBlock(){\r\n    int newValue = newBlockMessagesReceived.incrementAndGet();\r\n    if (newValue != 3 || p != peer || !block.equals(b2) || blocksLeft != OTHER_PEER_CHAIN_HEIGHT - 2)\r\n        fail.set(true);\r\n}"
}, {
	"Path": "org.atmosphere.runtime.AtmosphereResponseImpl.writeWithBuffering",
	"Comment": "caches the specified data and writes the previous data if it is not null.",
	"Method": "void writeWithBuffering(Object data){\r\n    if (NO_BUFFERING.get() != null) {\r\n        boolean b = forceAsyncIOWriter;\r\n        try {\r\n            if (data instanceof String) {\r\n                asyncIOWriter.write(AtmosphereResponseImpl.this, (String) data);\r\n            } else if (data instanceof byte[]) {\r\n                asyncIOWriter.write(AtmosphereResponseImpl.this, (byte[]) data);\r\n            }\r\n        } catch (IOException e) {\r\n            handleException(e);\r\n            throw e;\r\n        } finally {\r\n            forceAsyncIOWriter = b;\r\n        }\r\n    } else {\r\n        try {\r\n            NO_BUFFERING.set(Boolean.TRUE);\r\n            Object previous = buffered.getAndSet(data);\r\n            if (previous != null) {\r\n                boolean b = forceAsyncIOWriter;\r\n                try {\r\n                    if (previous instanceof String) {\r\n                        asyncIOWriter.write(AtmosphereResponseImpl.this, (String) previous);\r\n                    } else if (previous instanceof byte[]) {\r\n                        asyncIOWriter.write(AtmosphereResponseImpl.this, (byte[]) previous);\r\n                    }\r\n                } catch (IOException e) {\r\n                    handleException(e);\r\n                    throw e;\r\n                } finally {\r\n                    forceAsyncIOWriter = b;\r\n                }\r\n            }\r\n        } finally {\r\n            NO_BUFFERING.remove();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.KeyChainGroup.numKeys",
	"Comment": "returns the number of keys managed by this group, including the lookahead buffers.",
	"Method": "int numKeys(){\r\n    int result = basic.numKeys();\r\n    for (DeterministicKeyChain chain : chains) result += chain.numKeys();\r\n    return result;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.DeterministicKeyChain.getMnemonicCode",
	"Comment": "returns a list of words that represent the seed or null if this chain is a watching chain.",
	"Method": "List<String> getMnemonicCode(){\r\n    if (seed == null)\r\n        return null;\r\n    lock.lock();\r\n    try {\r\n        return seed.getMnemonicCode();\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.net.BlockingClientManager.setConnectTimeoutMillis",
	"Comment": "sets the number of milliseconds to wait before giving up on a connect attempt",
	"Method": "void setConnectTimeoutMillis(int connectTimeoutMillis){\r\n    this.connectTimeoutMillis = connectTimeoutMillis;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.DefaultRiskAnalysis.isOutputStandard",
	"Comment": "checks the output to see if the script violates a standardness rule. not complete.",
	"Method": "RuleViolation isOutputStandard(TransactionOutput output){\r\n    if (output.getValue().compareTo(MIN_ANALYSIS_NONDUST_OUTPUT) < 0)\r\n        return RuleViolation.DUST;\r\n    for (ScriptChunk chunk : output.getScriptPubKey().getChunks()) {\r\n        if (chunk.isPushData() && !chunk.isShortestPossiblePushData())\r\n            return RuleViolation.SHORTEST_POSSIBLE_PUSHDATA;\r\n    }\r\n    return RuleViolation.NONE;\r\n}"
}, {
	"Path": "io.aeron.Publication.streamId",
	"Comment": "stream identity for scoping within the channel media address.",
	"Method": "int streamId(){\r\n    return streamId;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.isTransactionRelevant",
	"Comment": "returns true if the given transaction sends coins to any of our keys, or has inputs spending any of our outputs,and also returns true if tx has inputs that are spending outputs which arenot ours but which are spent by pending transactions.note that if the tx has inputs containing one of our keys, but the connected transaction is not in the wallet,it will not be considered relevant.",
	"Method": "boolean isTransactionRelevant(Transaction tx){\r\n    lock.lock();\r\n    try {\r\n        return tx.getValueSentFromMe(this).signum() > 0 || tx.getValueSentToMe(this).signum() > 0 || !findDoubleSpendsAgainst(tx, transactions).isEmpty();\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.Transaction.isEveryOwnedOutputSpent",
	"Comment": "returns false if this transaction has at least one output that is owned by the given wallet and unspent, trueotherwise.",
	"Method": "boolean isEveryOwnedOutputSpent(TransactionBag transactionBag){\r\n    for (TransactionOutput output : outputs) {\r\n        if (output.isAvailableForSpending() && output.isMineOrWatched(transactionBag))\r\n            return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.bitcoinj.protocols.payments.PaymentProtocol.createPaymentMessage",
	"Comment": "create a payment message. this wraps up transaction data along with anything else useful for making a payment.",
	"Method": "Protos.Payment createPaymentMessage(List<Transaction> transactions,Coin refundAmount,Address refundAddress,String memo,byte[] merchantData,Protos.Payment createPaymentMessage,List<Transaction> transactions,List<Protos.Output> refundOutputs,String memo,byte[] merchantData){\r\n    Protos.Payment.Builder builder = Protos.Payment.newBuilder();\r\n    for (Transaction transaction : transactions) {\r\n        transaction.verify();\r\n        builder.addTransactions(ByteString.copyFrom(transaction.unsafeBitcoinSerialize()));\r\n    }\r\n    if (refundOutputs != null) {\r\n        for (Protos.Output output : refundOutputs) builder.addRefundTo(output);\r\n    }\r\n    if (memo != null)\r\n        builder.setMemo(memo);\r\n    if (merchantData != null)\r\n        builder.setMerchantData(ByteString.copyFrom(merchantData));\r\n    return builder.build();\r\n}"
}, {
	"Path": "org.atmosphere.runtime.DefaultAsyncSupportResolver.testClassExists",
	"Comment": "convenience method that tests if a class with the given fqn is present on the classpath.",
	"Method": "boolean testClassExists(String testClass){\r\n    try {\r\n        final boolean exists = testClass != null && testClass.length() > 0 && IOUtils.loadClass(null, testClass) != null;\r\n        logger.debug(exists ? \"Found {}\" : \"Not found {}\", testClass);\r\n        return exists;\r\n    } catch (Exception ex) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "problems.medium.SortStack.sort",
	"Comment": "pop element from stack and push it to helper stack and continue this as long as helper peek is smaller than stack pop. when top element in stakc is smaller than peek element in helper, move all elements from helper into stack and push poped stack element into helper.",
	"Method": "void sort(Stack<Integer> stack){\r\n    if (stack.size() <= 1)\r\n        return;\r\n    Stack<Integer> helper = new Stack();\r\n    Integer pop = stack.pop();\r\n    helper.push(pop);\r\n    while (!stack.isEmpty()) {\r\n        if (stack.peek() < helper.peek()) {\r\n            pop = stack.pop();\r\n            while (!helper.isEmpty() && helper.peek() > pop) {\r\n                stack.push(helper.pop());\r\n            }\r\n            helper.push(pop);\r\n        } else {\r\n            helper.push(stack.pop());\r\n        }\r\n    }\r\n    while (!helper.isEmpty()) stack.push(helper.pop());\r\n}"
}, {
	"Path": "org.atmosphere.runtime.AtmosphereConfig.getInitParameter",
	"Comment": "return the value of the init params defined in web.xml or application.xml.",
	"Method": "String getInitParameter(String name,String getInitParameter,String key,String defaultValue,boolean getInitParameter,String key,boolean defaultValue,int getInitParameter,String key,int defaultValue){\r\n    String s = getInitParameter(key);\r\n    if (s == null) {\r\n        return defaultValue;\r\n    }\r\n    return Integer.valueOf(s);\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.WalletProtobufSerializer.isWallet",
	"Comment": "cheap test to see if input stream is a wallet. this checks for a magic value at the beginning of the stream.",
	"Method": "boolean isWallet(InputStream is){\r\n    try {\r\n        final CodedInputStream cis = CodedInputStream.newInstance(is);\r\n        final int tag = cis.readTag();\r\n        final int field = WireFormat.getTagFieldNumber(tag);\r\n        if (field != 1)\r\n            return false;\r\n        final String network = cis.readString();\r\n        return NetworkParameters.fromID(network) != null;\r\n    } catch (IOException x) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.PeerSocketHandler.exceptionCaught",
	"Comment": "catch any exceptions, logging them and then closing the channel.",
	"Method": "void exceptionCaught(Exception e){\r\n    PeerAddress addr = getAddress();\r\n    String s = addr == null ? \"?\" : addr.toString();\r\n    if (e instanceof ConnectException || e instanceof IOException) {\r\n        log.info(s + \" - \" + e.getMessage());\r\n    } else {\r\n        log.warn(s + \" - \", e);\r\n        Thread.UncaughtExceptionHandler handler = Threading.uncaughtExceptionHandler;\r\n        if (handler != null)\r\n            handler.uncaughtException(Thread.currentThread(), e);\r\n    }\r\n    close();\r\n}"
}, {
	"Path": "algo.dp.MinimumSquareSum.sumRecursiveSol",
	"Comment": "bruteforce solution for minimum square sum problem. the time complexity of this solution is exponential.",
	"Method": "int sumRecursiveSol(int val){\r\n    if (val <= 3)\r\n        return val;\r\n    int res = val;\r\n    for (int i = 1; i <= val; i++) {\r\n        int temp = i * i;\r\n        if (temp > val)\r\n            break;\r\n        else {\r\n            res = Math.min(res, 1 + sumRecursiveSol(val - temp));\r\n        }\r\n    }\r\n    return res;\r\n}"
}, {
	"Path": "org.bitcoinj.core.TransactionOutPoint.getConnectedOutput",
	"Comment": "an outpoint is a part of a transaction input that points to the output of another transaction. if we have bothsides in memory, and they have been linked together, this returns a pointer to the connected output, or nullif there is no such connection.",
	"Method": "TransactionOutput getConnectedOutput(){\r\n    if (fromTx != null) {\r\n        return fromTx.getOutputs().get((int) index);\r\n    } else if (connectedOutput != null) {\r\n        return connectedOutput;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "io.aeron.cluster.service.ClusteredServiceContainer.launch",
	"Comment": "launch a clusteredservicecontainer by providing a configuration context.",
	"Method": "ClusteredServiceContainer launch(ClusteredServiceContainer launch,Context ctx){\r\n    return new ClusteredServiceContainer(ctx).start();\r\n}"
}, {
	"Path": "org.bitcoinj.core.Block.calculateHash",
	"Comment": "calculates the block hash by serializing the block and hashing theresulting bytes.",
	"Method": "Sha256Hash calculateHash(){\r\n    try {\r\n        ByteArrayOutputStream bos = new UnsafeByteArrayOutputStream(HEADER_SIZE);\r\n        writeHeader(bos);\r\n        return Sha256Hash.wrapReversed(Sha256Hash.hashTwice(bos.toByteArray()));\r\n    } catch (IOException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.Sha256Hash.getBytes",
	"Comment": "returns the internal byte array, without defensively copying. therefore do not modify the returned array.",
	"Method": "byte[] getBytes(){\r\n    return bytes;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.getTotalReceived",
	"Comment": "returns the amount of bitcoin ever received via output. this is not the balance! if an output spends from atransaction whose inputs are also to our wallet, the input amounts are deducted from the outputs contribution, with a minimum of zerocontribution. the idea behind this is we avoid double counting money sent to us.",
	"Method": "Coin getTotalReceived(){\r\n    Coin total = Coin.ZERO;\r\n    for (Transaction tx : transactions.values()) {\r\n        Coin txTotal = Coin.ZERO;\r\n        for (TransactionOutput output : tx.getOutputs()) {\r\n            if (output.isMine(this)) {\r\n                txTotal = txTotal.add(output.getValue());\r\n            }\r\n        }\r\n        for (TransactionInput in : tx.getInputs()) {\r\n            TransactionOutput prevOut = in.getConnectedOutput();\r\n            if (prevOut != null && prevOut.isMine(this)) {\r\n                txTotal = txTotal.subtract(prevOut.getValue());\r\n            }\r\n        }\r\n        if (txTotal.isPositive()) {\r\n            total = total.add(txTotal);\r\n        }\r\n    }\r\n    return total;\r\n}"
}, {
	"Path": "org.bitcoinj.core.TransactionConfidence.duplicate",
	"Comment": "returns a copy of this object. event listeners are not duplicated.",
	"Method": "TransactionConfidence duplicate(){\r\n    TransactionConfidence c = new TransactionConfidence(hash);\r\n    c.broadcastBy.addAll(broadcastBy);\r\n    c.lastBroadcastedAt = lastBroadcastedAt;\r\n    synchronized (this) {\r\n        c.confidenceType = confidenceType;\r\n        c.overridingTransaction = overridingTransaction;\r\n        c.appearedAtChainHeight = appearedAtChainHeight;\r\n    }\r\n    return c;\r\n}"
}, {
	"Path": "org.bitcoinj.core.PartialMerkleTree.buildFromLeaves",
	"Comment": "calculates a pmt given the list of leaf hashes and which leaves need to be included. the relevant interior hashesare calculated and a new pmt returned.",
	"Method": "PartialMerkleTree buildFromLeaves(NetworkParameters params,byte[] includeBits,List<Sha256Hash> allLeafHashes){\r\n    int height = 0;\r\n    while (getTreeWidth(allLeafHashes.size(), height) > 1) height++;\r\n    List<Boolean> bitList = new ArrayList();\r\n    List<Sha256Hash> hashes = new ArrayList();\r\n    traverseAndBuild(height, 0, allLeafHashes, includeBits, bitList, hashes);\r\n    byte[] bits = new byte[(int) Math.ceil(bitList.size() / 8.0)];\r\n    for (int i = 0; i < bitList.size(); i++) if (bitList.get(i))\r\n        Utils.setBitLE(bits, i);\r\n    return new PartialMerkleTree(params, bits, hashes, allLeafHashes.size());\r\n}"
}, {
	"Path": "org.bitcoinj.script.Script.getSigInsertionIndex",
	"Comment": "returns the index where a signature by the key should be inserted.only applicable toa p2sh scriptsig.",
	"Method": "int getSigInsertionIndex(Sha256Hash hash,ECKey signingKey){\r\n    List<ScriptChunk> existingChunks = chunks.subList(1, chunks.size() - 1);\r\n    ScriptChunk redeemScriptChunk = chunks.get(chunks.size() - 1);\r\n    checkNotNull(redeemScriptChunk.data);\r\n    Script redeemScript = new Script(redeemScriptChunk.data);\r\n    int sigCount = 0;\r\n    int myIndex = redeemScript.findKeyInRedeem(signingKey);\r\n    for (ScriptChunk chunk : existingChunks) {\r\n        if (chunk.opcode == OP_0) {\r\n        } else {\r\n            checkNotNull(chunk.data);\r\n            if (myIndex < redeemScript.findSigInRedeem(chunk.data, hash))\r\n                return sigCount;\r\n            sigCount++;\r\n        }\r\n    }\r\n    return sigCount;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.DeterministicKeyChain.getAccountPath",
	"Comment": "override in subclasses to use a different account derivation path",
	"Method": "ImmutableList<ChildNumber> getAccountPath(){\r\n    if (accountPath != null)\r\n        return accountPath;\r\n    return ACCOUNT_ZERO_PATH;\r\n}"
}, {
	"Path": "io.aeron.ChannelUri.channelTag",
	"Comment": "get the channel tag, if it exists, that refers to an another channel.",
	"Method": "String channelTag(){\r\n    return (null != tags && tags.length > CHANNEL_TAG_INDEX) ? tags[CHANNEL_TAG_INDEX] : null;\r\n}"
}, {
	"Path": "org.bitcoinj.core.PeerGroup.setMinRequiredProtocolVersion",
	"Comment": "if a peer is connected to that claims to speak a protocol version lower than the given version, it willbe disconnected and another one will be tried instead.",
	"Method": "void setMinRequiredProtocolVersion(int minRequiredProtocolVersion){\r\n    this.vMinRequiredProtocolVersion = minRequiredProtocolVersion;\r\n}"
}, {
	"Path": "org.bitcoinj.core.Transaction.addSignedInput",
	"Comment": "adds an input that points to the given output and contains a valid signature for it, calculated using thesigning key.",
	"Method": "TransactionInput addSignedInput(TransactionOutPoint prevOut,Script scriptPubKey,ECKey sigKey,SigHash sigHash,boolean anyoneCanPay,TransactionInput addSignedInput,TransactionOutPoint prevOut,Script scriptPubKey,ECKey sigKey,TransactionInput addSignedInput,TransactionOutput output,ECKey signingKey,TransactionInput addSignedInput,TransactionOutput output,ECKey signingKey,SigHash sigHash,boolean anyoneCanPay){\r\n    return addSignedInput(output.getOutPointFor(), output.getScriptPubKey(), signingKey, sigHash, anyoneCanPay);\r\n}"
}, {
	"Path": "org.bitcoinj.core.FilteredBlock.getTransactionCount",
	"Comment": "number of transactions in this block, before it was filtered",
	"Method": "int getTransactionCount(){\r\n    return merkleTree.getTransactionCount();\r\n}"
}, {
	"Path": "org.bitcoinj.store.DatabaseFullPrunedBlockStore.resetStore",
	"Comment": "resets the store by deleting the contents of the tables and reinitialising them.",
	"Method": "void resetStore(){\r\n    maybeConnect();\r\n    try {\r\n        deleteStore();\r\n        createTables();\r\n        initFromDatabase();\r\n    } catch (SQLException ex) {\r\n        throw new RuntimeException(ex);\r\n    }\r\n}"
}, {
	"Path": "org.atmosphere.runtime.AtmosphereFramework.init",
	"Comment": "initialize the atmosphereframework. invoke this method after having properly configured this class using the setters.",
	"Method": "AtmosphereFramework init(AtmosphereFramework init,ServletConfig sc,AtmosphereFramework init,ServletConfig sc,boolean wrap){\r\n    if (isInit)\r\n        return this;\r\n    servletConfig(sc, wrap);\r\n    readSystemProperties();\r\n    populateBroadcasterType();\r\n    populateObjectFactoryType();\r\n    loadMetaService();\r\n    onPreInit();\r\n    try {\r\n        ServletContextFactory.getDefault().init(sc.getServletContext());\r\n        preventOOM();\r\n        doInitParams(servletConfig);\r\n        doInitParamsForWebSocket(servletConfig);\r\n        lookupDefaultObjectFactoryType();\r\n        if (logger.isTraceEnabled()) {\r\n            asyncSupportListener(newClassInstance(AsyncSupportListener.class, AsyncSupportListenerAdapter.class));\r\n        }\r\n        configureObjectFactory();\r\n        configureAnnotationPackages();\r\n        configureBroadcasterFactory();\r\n        configureMetaBroadcaster();\r\n        configureAtmosphereResourceFactory();\r\n        if (isSessionSupportSpecified) {\r\n            sessionFactory();\r\n        }\r\n        configureScanningPackage(servletConfig, ApplicationConfig.ANNOTATION_PACKAGE);\r\n        configureScanningPackage(servletConfig, FrameworkConfig.JERSEY2_SCANNING_PACKAGE);\r\n        configureScanningPackage(servletConfig, FrameworkConfig.JERSEY_SCANNING_PACKAGE);\r\n        defaultPackagesToScan();\r\n        installAnnotationProcessor(servletConfig);\r\n        autoConfigureService(servletConfig.getServletContext());\r\n        configureBroadcasterFactory();\r\n        patchContainer();\r\n        configureBroadcaster();\r\n        loadConfiguration(servletConfig);\r\n        initWebSocket();\r\n        initEndpointMapper();\r\n        initDefaultSerializer();\r\n        autoDetectContainer();\r\n        configureWebDotXmlAtmosphereHandler(servletConfig);\r\n        asyncSupport.init(servletConfig);\r\n        initAtmosphereHandler(servletConfig);\r\n        configureAtmosphereInterceptor(servletConfig);\r\n        analytics();\r\n        if (sc.getServletContext() != null) {\r\n            sc.getServletContext().setAttribute(BroadcasterFactory.class.getName(), broadcasterFactory);\r\n        }\r\n        String s = config.getInitParameter(ApplicationConfig.BROADCASTER_SHARABLE_THREAD_POOLS);\r\n        if (s != null) {\r\n            sharedThreadPools = Boolean.parseBoolean(s);\r\n        }\r\n        this.shutdownHook = new Thread() {\r\n            public void run() {\r\n                AtmosphereFramework.this.destroy();\r\n            }\r\n        };\r\n        Runtime.getRuntime().addShutdownHook(this.shutdownHook);\r\n        if (logger.isInfoEnabled()) {\r\n            info();\r\n        }\r\n        if (initializationError != null) {\r\n            logger.trace(\"ContainerInitalizer exception. May not be an issue if Atmosphere started properly \", initializationError);\r\n        }\r\n        universe();\r\n    } catch (Throwable t) {\r\n        logger.error(\"Failed to initialize Atmosphere Framework\", t);\r\n        if (t instanceof ServletException) {\r\n            throw (ServletException) t;\r\n        }\r\n        throw new ServletException(t);\r\n    }\r\n    isInit = true;\r\n    config.initComplete();\r\n    onPostInit();\r\n    return this;\r\n}"
}, {
	"Path": "org.atmosphere.runtime.AtmosphereFramework.init",
	"Comment": "initialize the atmosphereframework. invoke this method after having properly configured this class using the setters.",
	"Method": "AtmosphereFramework init(AtmosphereFramework init,ServletConfig sc,AtmosphereFramework init,ServletConfig sc,boolean wrap){\r\n    AtmosphereFramework.this.destroy();\r\n}"
}, {
	"Path": "org.bitcoinj.core.FilteredBlock.getTransactionHashes",
	"Comment": "gets a list of leaf hashes which are contained in the partial merkle tree in this filtered block",
	"Method": "List<Sha256Hash> getTransactionHashes(){\r\n    if (cachedTransactionHashes != null)\r\n        return Collections.unmodifiableList(cachedTransactionHashes);\r\n    List<Sha256Hash> hashesMatched = new LinkedList();\r\n    if (header.getMerkleRoot().equals(merkleTree.getTxnHashAndMerkleRoot(hashesMatched))) {\r\n        cachedTransactionHashes = hashesMatched;\r\n        return Collections.unmodifiableList(cachedTransactionHashes);\r\n    } else\r\n        throw new VerificationException(\"Merkle root of block header does not match merkle root of partial merkle tree.\");\r\n}"
}, {
	"Path": "com.mikepenz.iconics.Iconics.init",
	"Comment": "this makes sure the fonts are initialized. if the given fonts map is empty we set the initialized fonts on it",
	"Method": "void init(Context ctx,HashMap<String, ITypeface> init,Context ctx,HashMap<String, ITypeface> fonts){\r\n    init(ctx);\r\n    if (fonts == null || fonts.size() == 0) {\r\n        fonts = FONTS;\r\n    }\r\n    return fonts;\r\n}"
}, {
	"Path": "org.bitcoinj.utils.BtcFormat.offSatoshis",
	"Comment": "return the number of decimal places by which any value denominated in the units indicated by the given scale differs from that same value denominated in satoshis",
	"Method": "int offSatoshis(int scale){\r\n    return Coin.SMALLEST_UNIT_EXPONENT - scale;\r\n}"
}, {
	"Path": "org.bitcoinj.core.TransactionConfidence.setDepthInBlocks",
	"Comment": "set the depth in blocks. having one block confirmation is a depth of one.",
	"Method": "void setDepthInBlocks(int depth){\r\n    this.depth = depth;\r\n}"
}, {
	"Path": "org.atmosphere.util.IntrospectionUtils.getClassPath",
	"Comment": "construct a url classpath from files in a directory, a cpath property,and tools.jar.",
	"Method": "URL[] getClassPath(Vector<URL> v,URL[] getClassPath,String dir,String cpath,String cpathProp,boolean addTools){\r\n    Vector<URL> jarsV = new Vector<URL>();\r\n    if (dir != null) {\r\n        URL url = getURL(dir, \"classes\");\r\n        if (url != null)\r\n            jarsV.addElement(url);\r\n        addToClassPath(jarsV, dir);\r\n    }\r\n    if (cpath != null)\r\n        addJarsFromClassPath(jarsV, cpath);\r\n    if (cpathProp != null) {\r\n        String cpath1 = System.getProperty(cpathProp);\r\n        addJarsFromClassPath(jarsV, cpath1);\r\n    }\r\n    if (addTools)\r\n        addToolsJar(jarsV);\r\n    return getClassPath(jarsV);\r\n}"
}, {
	"Path": "org.bitcoinj.utils.MonetaryFormat.positiveSign",
	"Comment": "set character to prefix positive values. a zero value means no sign is used in this case. for parsing, a missingsign will always be interpreted as if the positive sign was used.",
	"Method": "MonetaryFormat positiveSign(char positiveSign){\r\n    checkArgument(!Character.isDigit(positiveSign));\r\n    if (positiveSign == this.positiveSign)\r\n        return this;\r\n    else\r\n        return new MonetaryFormat(negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed);\r\n}"
}, {
	"Path": "problems.medium.ConvertSortedListtoBinarySearchTree.sortedListToBST",
	"Comment": "divide list recursively into two parts by finding middle with two pointers, then do merge",
	"Method": "TreeNode sortedListToBST(ListNode head){\r\n    if (head == null)\r\n        return null;\r\n    ListNode slow = head;\r\n    ListNode fast = head;\r\n    ListNode prev = null;\r\n    while (fast != null && fast.next != null) {\r\n        fast = fast.next.next;\r\n        prev = slow;\r\n        slow = slow.next;\r\n    }\r\n    if (prev != null)\r\n        prev.next = null;\r\n    else\r\n        head = null;\r\n    TreeNode root = new TreeNode(slow.val);\r\n    root.left = sortedListToBST(head);\r\n    root.right = sortedListToBST(slow.next);\r\n    return root;\r\n}"
}, {
	"Path": "io.aeron.cluster.ClusterMember.endpointsDetail",
	"Comment": "the string of endpoints for this member in a comma separated list in the same order they are parsed.",
	"Method": "String endpointsDetail(){\r\n    return endpointsDetail;\r\n}"
}, {
	"Path": "org.bitcoinj.utils.MonetaryFormat.postfixCode",
	"Comment": "postfix formatted output with currency code. this configuration is not relevant for parsing.",
	"Method": "MonetaryFormat postfixCode(){\r\n    if (!codePrefixed)\r\n        return this;\r\n    else\r\n        return new MonetaryFormat(negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, false);\r\n}"
}, {
	"Path": "problems.medium.Searcha2DMatrixII.searchMatrix",
	"Comment": "compare first element of every array and it is smaller than target, it binary searches this row",
	"Method": "boolean searchMatrix(int[][] a,int target){\r\n    if (a.length == 0 || a[0].length == 0)\r\n        return false;\r\n    for (int i = 0; i < a.length; i++) {\r\n        int len = a[i].length - 1;\r\n        if (a[i][0] == target || a[i][len] == target)\r\n            return true;\r\n        if (a[i][0] < target && Arrays.binarySearch(a[i], target) > -1)\r\n            return true;\r\n        if (a[i][0] > target)\r\n            return false;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.atmosphere.runtime.DefaultBroadcaster.reactiveThreadsCount",
	"Comment": "return the default number of reactive threads that will be waiting for work when a broadcast operationis executed.",
	"Method": "int reactiveThreadsCount(){\r\n    return Runtime.getRuntime().availableProcessors() * 2;\r\n}"
}, {
	"Path": "commons.validator.routines.CodeValidator.getRegexValidator",
	"Comment": "return the regular expression validator.n.b. optional, if not set no regularexpression validation will be performed on the code.",
	"Method": "RegexValidator getRegexValidator(){\r\n    return regexValidator;\r\n}"
}, {
	"Path": "org.bitcoinj.kits.WalletAppKit.setAutoStop",
	"Comment": "if true, will register a shutdown hook to stop the library. defaults to true.",
	"Method": "WalletAppKit setAutoStop(boolean autoStop){\r\n    this.autoStop = autoStop;\r\n    return this;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.KeyChainGroup.isDeterministicUpgradeRequired",
	"Comment": "returns true if the group contains random keys but no hd chains.",
	"Method": "boolean isDeterministicUpgradeRequired(){\r\n    return basic.numKeys() > 0 && chains.isEmpty();\r\n}"
}, {
	"Path": "io.aeron.logbuffer.LogBufferDescriptor.initialiseTailWithTermId",
	"Comment": "set the initial value for the termid in the upper bits of the tail counter.",
	"Method": "void initialiseTailWithTermId(UnsafeBuffer logMetaData,int partitionIndex,int termId){\r\n    logMetaData.putLong(TERM_TAIL_COUNTERS_OFFSET + (partitionIndex * SIZE_OF_LONG), packTail(termId, 0));\r\n}"
}, {
	"Path": "io.aeron.Aeron.clientId",
	"Comment": "get the client identity that has been allocated for communicating with the media driver.",
	"Method": "long clientId(long clientId){\r\n    return clientId;\r\n}"
}, {
	"Path": "io.aeron.Publication.maxPayloadLength",
	"Comment": "maximum length of a message payload that fits within a message fragment.this is he mtu length minus the message fragment header length.",
	"Method": "int maxPayloadLength(){\r\n    return maxPayloadLength;\r\n}"
}, {
	"Path": "org.bitcoinj.core.BitcoinSerializer.makeBloomFilter",
	"Comment": "make an filter message from the payload. extension point for alternativeserialization format support.",
	"Method": "Message makeBloomFilter(byte[] payloadBytes){\r\n    return new BloomFilter(params, payloadBytes);\r\n}"
}, {
	"Path": "problems.medium.CoinChange.coinChange",
	"Comment": "this is dp solution, using bottom up approach we can identify how many coins take to make up given value.",
	"Method": "int coinChange(int[] coins,int value){\r\n    if (coins == null || coins.length == 0)\r\n        return -1;\r\n    Arrays.sort(coins);\r\n    int[] dp = new int[value + 1];\r\n    findMinRecursive(coins, value, dp);\r\n    return dp[value] == Integer.MAX_VALUE ? -1 : dp[value];\r\n}"
}, {
	"Path": "io.aeron.driver.media.UdpChannel.description",
	"Comment": "used for debugging to get a human readable description of the channel.",
	"Method": "String description(){\r\n    final StringBuilder builder = new StringBuilder(\"UdpChannel - \");\r\n    if (null != localInterface) {\r\n        builder.append(\"interface: \").append(localInterface.getDisplayName()).append(\", \");\r\n    }\r\n    builder.append(\"localData: \").append(localData).append(\", remoteData: \").append(remoteData).append(\", ttl: \").append(multicastTtl);\r\n    return builder.toString();\r\n}"
}, {
	"Path": "com.mikepenz.iconics.IconicsDrawable.typeface",
	"Comment": "sets the typeface of the drawablenote this will overwrite the iconfont!",
	"Method": "IconicsDrawable typeface(Typeface typeface){\r\n    mIconPaint.setTypeface(typeface);\r\n    invalidateSelf();\r\n    return this;\r\n}"
}, {
	"Path": "com.mobsandgeeks.saripaar.ValidationContext.assertNotNull",
	"Comment": "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ private methods~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
	"Method": "void assertNotNull(Object object,String argumentName){\r\n    if (object == null) {\r\n        String message = String.format(\"'%s' cannot be null.\", argumentName);\r\n        throw new IllegalArgumentException(message);\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.utils.BtcAutoFormat.equals",
	"Comment": "return true if the other instance is equivalent to this one. formatters for different locales will never be equal, even if they behave identically.",
	"Method": "boolean equals(Object o){\r\n    if (this == o)\r\n        return true;\r\n    if (!(o instanceof BtcAutoFormat))\r\n        return false;\r\n    return super.equals(o);\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.deserializeExtension",
	"Comment": "deserialize the wallet extension with the supplied data and then install it, replacing any existing extensionthat may have existed with the same id. if an exception is thrown then the extension is removed from the wallet,if already present.",
	"Method": "void deserializeExtension(WalletExtension extension,byte[] data){\r\n    lock.lock();\r\n    keyChainGroupLock.lock();\r\n    try {\r\n        extension.deserializeWalletExtension(this, data);\r\n        extensions.put(extension.getWalletExtensionID(), extension);\r\n    } catch (Throwable throwable) {\r\n        log.error(\"Error during extension deserialization\", throwable);\r\n        extensions.remove(extension.getWalletExtensionID());\r\n        Throwables.propagate(throwable);\r\n    } finally {\r\n        keyChainGroupLock.unlock();\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "commons.validator.routines.RegexValidator.match",
	"Comment": "validate a value against the set of regular expressionsreturning the array of matched groups.",
	"Method": "String[] match(String value){\r\n    if (value == null) {\r\n        return null;\r\n    }\r\n    for (int i = 0; i < patterns.length; i++) {\r\n        Matcher matcher = patterns[i].matcher(value);\r\n        if (matcher.matches()) {\r\n            int count = matcher.groupCount();\r\n            String[] groups = new String[count];\r\n            for (int j = 0; j < count; j++) {\r\n                groups[j] = matcher.group(j + 1);\r\n            }\r\n            return groups;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bitcoinj.core.AbstractBlockChain.resetFalsePositiveEstimate",
	"Comment": "resets estimates of false positives. used when the filter is sent to the peer.",
	"Method": "void resetFalsePositiveEstimate(){\r\n    falsePositiveRate = 0;\r\n    falsePositiveTrend = 0;\r\n    previousFalsePositiveRate = 0;\r\n}"
}, {
	"Path": "org.bitcoinj.protocols.channels.PaymentChannelServerListener.bindAndStart",
	"Comment": "binds to the given port and starts accepting new client connections.",
	"Method": "void bindAndStart(int port){\r\n    server = new NioServer(new StreamConnectionFactory() {\r\n        @Override\r\n        public ProtobufConnection<Protos.TwoWayChannelMessage> getNewConnection(InetAddress inetAddress, int port) {\r\n            return new ServerHandler(new InetSocketAddress(inetAddress, port), timeoutSeconds).socketProtobufHandler;\r\n        }\r\n    }, new InetSocketAddress(port));\r\n    server.startAsync();\r\n    server.awaitRunning();\r\n}"
}, {
	"Path": "org.bitcoinj.protocols.channels.PaymentChannelServerListener.bindAndStart",
	"Comment": "binds to the given port and starts accepting new client connections.",
	"Method": "void bindAndStart(int port){\r\n    return new ServerHandler(new InetSocketAddress(inetAddress, port), timeoutSeconds).socketProtobufHandler;\r\n}"
}, {
	"Path": "org.atmosphere.runtime.AtmosphereSession.awaitNanosForResourceToBePresent",
	"Comment": "await given amount of nanoseconds for resource to become present",
	"Method": "boolean awaitNanosForResourceToBePresent(long nanos,boolean signalBeforeWaiting){\r\n    if (signalBeforeWaiting) {\r\n        signalWaiter();\r\n    }\r\n    do {\r\n        if (nanos < 0L) {\r\n            return false;\r\n        }\r\n        nanos = resourcePresent.awaitNanos(nanos);\r\n    } while (resource == null);\r\n    return true;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.DeterministicKeyChain.numLeafKeysIssued",
	"Comment": "returns number of leaf keys used including both internal and external paths. this may be fewer than the numberthat have been deserialized or held in memory, because of the lookahead zone.",
	"Method": "int numLeafKeysIssued(){\r\n    lock.lock();\r\n    try {\r\n        return issuedExternalKeys + issuedInternalKeys;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.TxConfidenceTable.numBroadcastPeers",
	"Comment": "returns the number of peers that have seen the given hash recently.",
	"Method": "int numBroadcastPeers(Sha256Hash txHash){\r\n    lock.lock();\r\n    try {\r\n        cleanTable();\r\n        WeakConfidenceReference entry = table.get(txHash);\r\n        if (entry == null) {\r\n            return 0;\r\n        } else {\r\n            TransactionConfidence confidence = entry.get();\r\n            if (confidence == null) {\r\n                table.remove(txHash);\r\n                return 0;\r\n            } else {\r\n                return confidence.numBroadcastPeers();\r\n            }\r\n        }\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "algo.string.Trie.startsWith",
	"Comment": "returns if there is any word in the trie that starts with the given prefix.",
	"Method": "boolean startsWith(String word){\r\n    TrieNode t = root;\r\n    for (int i = 0; i < word.length(); i++) {\r\n        int index = word.charAt(i) - 'a';\r\n        if (t.children[index] == null)\r\n            return false;\r\n        t = t.children[index];\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.atmosphere.handler.AbstractReflectorAtmosphereHandler.twoStepWrite",
	"Comment": "writes the given data to the given outputstream in two steps with extraflushes to make servers notice if the connection has been closed. thisenables caching the message instead of losing it, if the client is in theprogress of reconnecting",
	"Method": "void twoStepWrite(ServletOutputStream o,byte[] data){\r\n    o.write(data, 0, 1);\r\n    o.flush();\r\n    o.write(data, 1, data.length - 1);\r\n    o.flush();\r\n}"
}, {
	"Path": "org.bitcoinj.core.BitcoinSerializer.makeInventoryMessage",
	"Comment": "make an inventory message from the payload. extension point for alternativeserialization format support.",
	"Method": "InventoryMessage makeInventoryMessage(byte[] payloadBytes,int length){\r\n    return new InventoryMessage(params, payloadBytes, this, length);\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.KeyChainGroup.serializeToProtobuf",
	"Comment": "returns a list of key protobufs obtained by merging the chains.",
	"Method": "List<Protos.Key> serializeToProtobuf(){\r\n    List<Protos.Key> result;\r\n    if (basic != null)\r\n        result = basic.serializeToProtobuf();\r\n    else\r\n        result = Lists.newArrayList();\r\n    for (DeterministicKeyChain chain : chains) {\r\n        List<Protos.Key> protos = chain.serializeToProtobuf();\r\n        result.addAll(protos);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "io.aeron.archive.client.AeronArchive.controlSessionId",
	"Comment": "the control session id allocated for this connection to the archive.",
	"Method": "long controlSessionId(){\r\n    return controlSessionId;\r\n}"
}, {
	"Path": "org.bitcoinj.core.Block.copyBitcoinHeaderTo",
	"Comment": "copy the block without transactions into the provided empty block.",
	"Method": "void copyBitcoinHeaderTo(Block block){\r\n    block.nonce = nonce;\r\n    block.prevBlockHash = prevBlockHash;\r\n    block.merkleRoot = getMerkleRoot();\r\n    block.version = version;\r\n    block.time = time;\r\n    block.difficultyTarget = difficultyTarget;\r\n    block.transactions = null;\r\n    block.hash = getHash();\r\n}"
}, {
	"Path": "org.bitcoinj.protocols.channels.StateMachine.transition",
	"Comment": "transitions to a new state, provided that the required transition exists",
	"Method": "void transition(State newState){\r\n    if (transitions.containsEntry(currentState, newState)) {\r\n        currentState = newState;\r\n    } else {\r\n        throw new IllegalStateException(String.format(Locale.US, \"Attempted invalid transition from %s to %s\", currentState, newState));\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.Peer.getPeerBlockHeightDifference",
	"Comment": "returns the difference between our best chain height and the peers, which can either be positive if we arebehind the peer, or negative if the peer is ahead of us.",
	"Method": "int getPeerBlockHeightDifference(){\r\n    checkNotNull(blockChain, \"No block chain configured\");\r\n    int chainHeight = (int) getBestHeight();\r\n    checkState(params.allowEmptyPeerChain() || chainHeight > 0, \"Connected to peer with zero/negative chain height\", chainHeight);\r\n    return chainHeight - blockChain.getBestChainHeight();\r\n}"
}, {
	"Path": "org.atmosphere.runtime.DefaultAsyncSupportResolver.resolveNativeCometSupport",
	"Comment": "this method is called to determine which native comet support to the used.",
	"Method": "AsyncSupport resolveNativeCometSupport(java.util.List<Class<? extends AsyncSupport>> available){\r\n    if (available == null || available.isEmpty())\r\n        return null;\r\n    else if (available.size() == 1)\r\n        return newCometSupport(available.get(0));\r\n    else\r\n        return resolveMultipleNativeSupportConflict(available);\r\n}"
}, {
	"Path": "org.bitcoinj.core.BloomFilter.getFalsePositiveRate",
	"Comment": "returns the theoretical false positive rate of this filter if were to contain the given number of elements.",
	"Method": "double getFalsePositiveRate(int elements){\r\n    return pow(1 - pow(E, -1.0 * (hashFuncs * elements) / (data.length * 8)), hashFuncs);\r\n}"
}, {
	"Path": "org.bitcoinj.crypto.DeterministicKey.getPathAsString",
	"Comment": "returns the path of this key as a human readable string starting with m to indicate the master key.",
	"Method": "String getPathAsString(){\r\n    return HDUtils.formatPath(getPath());\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.DeterministicKeyChain.spend",
	"Comment": "creates a key chain that can spend from the given account key.",
	"Method": "DeterministicKeyChain spend(DeterministicKey accountKey){\r\n    return new DeterministicKeyChain(accountKey, false, false);\r\n}"
}, {
	"Path": "org.bitcoinj.core.StoredBlock.getChainWork",
	"Comment": "the total sum of work done in this block, and all the blocks below it in the chain. work is a measure of howmany tries are needed to solve a block. if the target is set to cover 10% of the total hash value space,then the work represented by a block is 10.",
	"Method": "BigInteger getChainWork(){\r\n    return chainWork;\r\n}"
}, {
	"Path": "io.aeron.logbuffer.LogBufferDescriptor.computeTermBeginPosition",
	"Comment": "compute the current position in absolute number of bytes for the beginning of a term.",
	"Method": "long computeTermBeginPosition(int activeTermId,int positionBitsToShift,int initialTermId){\r\n    final long termCount = activeTermId - initialTermId;\r\n    return termCount << positionBitsToShift;\r\n}"
}, {
	"Path": "org.bitcoinj.core.Block.bitcoinSerialize",
	"Comment": "special handling to check if we have a valid byte array for both headerand transactions",
	"Method": "byte[] bitcoinSerialize(){\r\n    if (headerBytesValid && transactionBytesValid) {\r\n        Preconditions.checkNotNull(payload, \"Bytes should never be null if headerBytesValid && transactionBytesValid\");\r\n        if (length == payload.length) {\r\n            return payload;\r\n        } else {\r\n            byte[] buf = new byte[length];\r\n            System.arraycopy(payload, offset, buf, 0, length);\r\n            return buf;\r\n        }\r\n    }\r\n    ByteArrayOutputStream stream = new UnsafeByteArrayOutputStream(length == UNKNOWN_LENGTH ? HEADER_SIZE + guessTransactionsLength() : length);\r\n    try {\r\n        writeHeader(stream);\r\n        writeTransactions(stream);\r\n    } catch (IOException e) {\r\n    }\r\n    return stream.toByteArray();\r\n}"
}, {
	"Path": "org.bitcoinj.core.Coin.isZero",
	"Comment": "returns true if and only if this instance represents zero monetary value,otherwise false.",
	"Method": "boolean isZero(){\r\n    return signum() == 0;\r\n}"
}, {
	"Path": "org.bitcoinj.protocols.channels.PaymentChannelClient.getMissing",
	"Comment": "returns the amount of satoshis missing when a server requests too much value.when insufficientmoneyexception is thrown due to the server requesting too much value, an instance of paymentchannelclient needs access to how many satoshis are missing.",
	"Method": "Coin getMissing(){\r\n    return missing;\r\n}"
}, {
	"Path": "org.bitcoinj.core.AbstractBlockChain.tryConnectingOrphans",
	"Comment": "for each block in orphanblocks, see if we can now fit it on top of the chain and if so, do so.",
	"Method": "void tryConnectingOrphans(){\r\n    checkState(lock.isHeldByCurrentThread());\r\n    int blocksConnectedThisRound;\r\n    do {\r\n        blocksConnectedThisRound = 0;\r\n        Iterator<OrphanBlock> iter = orphanBlocks.values().iterator();\r\n        while (iter.hasNext()) {\r\n            OrphanBlock orphanBlock = iter.next();\r\n            StoredBlock prev = getStoredBlockInCurrentScope(orphanBlock.block.getPrevBlockHash());\r\n            if (prev == null) {\r\n                log.debug(\"Orphan block {} is not connectable right now\", orphanBlock.block.getHash());\r\n                continue;\r\n            }\r\n            log.info(\"Connected orphan {}\", orphanBlock.block.getHash());\r\n            add(orphanBlock.block, false, orphanBlock.filteredTxHashes, orphanBlock.filteredTxn);\r\n            iter.remove();\r\n            blocksConnectedThisRound++;\r\n        }\r\n        if (blocksConnectedThisRound > 0) {\r\n            log.info(\"Connected {} orphan blocks.\", blocksConnectedThisRound);\r\n        }\r\n    } while (blocksConnectedThisRound > 0);\r\n}"
}, {
	"Path": "io.aeron.logbuffer.TermAppender.claim",
	"Comment": "claim length of a the term buffer for writing in the message with zero copy semantics.",
	"Method": "int claim(HeaderWriter header,int length,BufferClaim bufferClaim,int activeTermId){\r\n    final int frameLength = length + HEADER_LENGTH;\r\n    final int alignedLength = align(frameLength, FRAME_ALIGNMENT);\r\n    final UnsafeBuffer termBuffer = this.termBuffer;\r\n    final int termLength = termBuffer.capacity();\r\n    final long rawTail = getAndAddRawTail(alignedLength);\r\n    final int termId = termId(rawTail);\r\n    final long termOffset = rawTail & 0xFFFF_FFFFL;\r\n    checkTerm(activeTermId, termId);\r\n    long resultingOffset = termOffset + alignedLength;\r\n    if (resultingOffset > termLength) {\r\n        resultingOffset = handleEndOfLogCondition(termBuffer, termOffset, header, termLength, termId);\r\n    } else {\r\n        final int frameOffset = (int) termOffset;\r\n        header.write(termBuffer, frameOffset, frameLength, termId);\r\n        bufferClaim.wrap(termBuffer, frameOffset, frameLength);\r\n    }\r\n    return (int) resultingOffset;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.isEncrypted",
	"Comment": "returns true if the wallet is encrypted using any scheme, false if not.",
	"Method": "boolean isEncrypted(){\r\n    return getEncryptionType() != EncryptionType.UNENCRYPTED;\r\n}"
}, {
	"Path": "io.aeron.ChannelUriStringBuilder.sparse",
	"Comment": "get if a term log buffer should be sparse on disk or not. sparse saves space at the potential expense of latency.",
	"Method": "ChannelUriStringBuilder sparse(Boolean isSparse,Boolean sparse){\r\n    return sparse;\r\n}"
}, {
	"Path": "org.bitcoinj.protocols.payments.PaymentProtocol.verifyPaymentRequestPki",
	"Comment": "uses the provided pki method to find the corresponding public key and verify the provided signature.",
	"Method": "PkiVerificationData verifyPaymentRequestPki(Protos.PaymentRequest paymentRequest,KeyStore trustStore){\r\n    List<X509Certificate> certs = null;\r\n    try {\r\n        final String pkiType = paymentRequest.getPkiType();\r\n        if (\"none\".equals(pkiType))\r\n            return null;\r\n        String algorithm;\r\n        if (\"x509+sha256\".equals(pkiType))\r\n            algorithm = \"SHA256withRSA\";\r\n        else if (\"x509+sha1\".equals(pkiType))\r\n            algorithm = \"SHA1withRSA\";\r\n        else\r\n            throw new PaymentProtocolException.InvalidPkiType(\"Unsupported PKI type: \" + pkiType);\r\n        Protos.X509Certificates protoCerts = Protos.X509Certificates.parseFrom(paymentRequest.getPkiData());\r\n        if (protoCerts.getCertificateCount() == 0)\r\n            throw new PaymentProtocolException.InvalidPkiData(\"No certificates provided in message: server config error\");\r\n        CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X.509\");\r\n        certs = Lists.newArrayList();\r\n        for (ByteString bytes : protoCerts.getCertificateList()) certs.add((X509Certificate) certificateFactory.generateCertificate(bytes.newInput()));\r\n        CertPath path = certificateFactory.generateCertPath(certs);\r\n        PKIXParameters params = new PKIXParameters(trustStore);\r\n        params.setRevocationEnabled(false);\r\n        CertPathValidator validator = CertPathValidator.getInstance(\"PKIX\");\r\n        PKIXCertPathValidatorResult result = (PKIXCertPathValidatorResult) validator.validate(path, params);\r\n        PublicKey publicKey = result.getPublicKey();\r\n        Signature signature = Signature.getInstance(algorithm);\r\n        signature.initVerify(publicKey);\r\n        Protos.PaymentRequest.Builder reqToCheck = paymentRequest.toBuilder();\r\n        reqToCheck.setSignature(ByteString.EMPTY);\r\n        signature.update(reqToCheck.build().toByteArray());\r\n        if (!signature.verify(paymentRequest.getSignature().toByteArray()))\r\n            throw new PaymentProtocolException.PkiVerificationException(\"Invalid signature, this payment request is not valid.\");\r\n        final X509Certificate cert = certs.get(0);\r\n        String displayName = X509Utils.getDisplayNameFromCertificate(cert, true);\r\n        if (displayName == null)\r\n            throw new PaymentProtocolException.PkiVerificationException(\"Could not extract name from certificate\");\r\n        return new PkiVerificationData(displayName, publicKey, result.getTrustAnchor());\r\n    } catch (InvalidProtocolBufferException e) {\r\n        throw new PaymentProtocolException.InvalidPkiData(e);\r\n    } catch (CertificateException e) {\r\n        throw new PaymentProtocolException.PkiVerificationException(e);\r\n    } catch (NoSuchAlgorithmException e) {\r\n        throw new RuntimeException(e);\r\n    } catch (InvalidAlgorithmParameterException e) {\r\n        throw new RuntimeException(e);\r\n    } catch (CertPathValidatorException e) {\r\n        throw new PaymentProtocolException.PkiVerificationException(e, certs);\r\n    } catch (InvalidKeyException e) {\r\n        throw new PaymentProtocolException.PkiVerificationException(e);\r\n    } catch (SignatureException e) {\r\n        throw new PaymentProtocolException.PkiVerificationException(e);\r\n    } catch (KeyStoreException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "problems.medium.KthLargestElementinanArray.partition",
	"Comment": "this is main point. this method rearranges the array in a way that all elements less than pivot are on left side of pivot and others on right. it then returns index of the pivot element.",
	"Method": "int partition(int[] a,int lo,int hi,int k){\r\n    int p = lo + (hi - lo) / 2;\r\n    int storeIndex = lo;\r\n    swap(a, p, hi);\r\n    for (int i = lo; i < hi; i++) {\r\n        if (a[i] < a[hi]) {\r\n            swap(a, i, storeIndex);\r\n            storeIndex++;\r\n        }\r\n    }\r\n    swap(a, storeIndex, hi);\r\n    if (storeIndex == k)\r\n        return a[storeIndex];\r\n    else if (k < storeIndex)\r\n        return partition(a, lo, storeIndex - 1, k);\r\n    else\r\n        return partition(a, storeIndex + 1, hi, k);\r\n}"
}, {
	"Path": "org.atmosphere.util.AtmosphereFilterChain.setServlet",
	"Comment": "set the servlet that will be executed at the end of this chain.set by the mapper filter",
	"Method": "void setServlet(ServletConfig configImpl,Servlet servlet){\r\n    this.configImpl = configImpl;\r\n    this.servlet = servlet;\r\n}"
}, {
	"Path": "io.aeron.cluster.ClusterMember.addMemberStatusPublications",
	"Comment": "add the publications for sending status messages to the other members of the cluster.",
	"Method": "void addMemberStatusPublications(ClusterMember[] members,ClusterMember exclude,ChannelUri channelUri,int streamId,Aeron aeron){\r\n    for (final ClusterMember member : members) {\r\n        if (member != exclude) {\r\n            channelUri.put(ENDPOINT_PARAM_NAME, member.memberFacingEndpoint());\r\n            final String channel = channelUri.toString();\r\n            member.publication(aeron.addExclusivePublication(channel, streamId));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.script.ScriptBuilder.createP2SHOutputScript",
	"Comment": "creates a p2sh output script with given public keys and threshold. given public keys will be placed inredeem script in the lexicographical sorting order.",
	"Method": "Script createP2SHOutputScript(byte[] hash,Script createP2SHOutputScript,Script redeemScript,Script createP2SHOutputScript,int threshold,List<ECKey> pubkeys){\r\n    Script redeemScript = createRedeemScript(threshold, pubkeys);\r\n    return createP2SHOutputScript(redeemScript);\r\n}"
}, {
	"Path": "org.bitcoinj.store.DatabaseFullPrunedBlockStore.deleteStore",
	"Comment": "deletes the store by deleting the tables within the database.",
	"Method": "void deleteStore(){\r\n    maybeConnect();\r\n    try {\r\n        Statement s = conn.get().createStatement();\r\n        for (String sql : getDropTablesSQL()) {\r\n            s.execute(sql);\r\n        }\r\n        s.close();\r\n    } catch (SQLException ex) {\r\n        throw new RuntimeException(ex);\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.KeyChainGroup.removeEventListener",
	"Comment": "removes a listener for events that are run when keys are added.",
	"Method": "boolean removeEventListener(KeyChainEventListener listener){\r\n    checkNotNull(listener);\r\n    for (DeterministicKeyChain chain : chains) chain.removeEventListener(listener);\r\n    return basic.removeEventListener(listener);\r\n}"
}, {
	"Path": "org.bitcoinj.core.UTXO.getScript",
	"Comment": "the script object which you can use to get address, script bytes or script type.",
	"Method": "Script getScript(){\r\n    return script;\r\n}"
}, {
	"Path": "com.github.pedrovgs.problem24.SortedArrayToBSTTest.shouldReturnOneBinarySearchTree",
	"Comment": "if you get an in order traversal of a bst you get a sorted collection of elements. we aregoing to use this property to assert the result.",
	"Method": "void shouldReturnOneBinarySearchTree(){\r\n    Integer[] array = { 1, 2, 3, 4, 5, 6, 7, 8 };\r\n    BinaryNode<Integer> result = sortedArrayToBST.transform(array);\r\n    BinaryTreeInOrder inOrder = new BinaryTreeInOrder();\r\n    List<BinaryNode<Integer>> resultList = inOrder.getIterative(result);\r\n    Integer[] resultArray = new Integer[resultList.size()];\r\n    for (int i = 0; i < resultList.size(); i++) {\r\n        resultArray[i] = resultList.get(i).getData();\r\n    }\r\n    assertArrayEquals(array, resultArray);\r\n}"
}, {
	"Path": "org.bitcoinj.script.Script.removeAllInstancesOfOp",
	"Comment": "returns the script bytes of inputscript with all instances of the given op code removed",
	"Method": "byte[] removeAllInstancesOfOp(byte[] inputScript,int opCode){\r\n    return removeAllInstancesOf(inputScript, new byte[] { (byte) opCode });\r\n}"
}, {
	"Path": "org.bitcoinj.script.Script.getNumberOfBytesRequiredToSpend",
	"Comment": "returns number of bytes required to spend this script. it accepts optional eckey and redeemscript that maybe required for certain types of script to estimate target size.",
	"Method": "int getNumberOfBytesRequiredToSpend(ECKey pubKey,Script redeemScript){\r\n    if (ScriptPattern.isPayToScriptHash(this)) {\r\n        checkArgument(redeemScript != null, \"P2SH script requires redeemScript to be spent\");\r\n        return redeemScript.getNumberOfSignaturesRequiredToSpend() * SIG_SIZE + redeemScript.getProgram().length;\r\n    } else if (ScriptPattern.isSentToMultisig(this)) {\r\n        return getNumberOfSignaturesRequiredToSpend() * SIG_SIZE + 1;\r\n    } else if (ScriptPattern.isPayToPubKey(this)) {\r\n        return SIG_SIZE;\r\n    } else if (ScriptPattern.isPayToPubKeyHash(this)) {\r\n        int uncompressedPubKeySize = 65;\r\n        return SIG_SIZE + (pubKey != null ? pubKey.getPubKey().length : uncompressedPubKeySize);\r\n    } else {\r\n        throw new IllegalStateException(\"Unsupported script type\");\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.BasicKeyChain.checkPassword",
	"Comment": "returns whether the given password is correct for this key chain.",
	"Method": "boolean checkPassword(CharSequence password){\r\n    checkNotNull(password);\r\n    checkState(keyCrypter != null, \"Key chain not encrypted\");\r\n    return checkAESKey(keyCrypter.deriveKey(password));\r\n}"
}, {
	"Path": "com.github.pedrovgs.problem51.ReverseString.reverseRecursive",
	"Comment": "tail recursive solution to this problem. this algorithm has the same complexity order in timeand space terms than the previous approach.",
	"Method": "String reverseRecursive(String input){\r\n    validateInput(input);\r\n    return reverseRecursiveInner(input, input.length() - 1, new StringBuilder());\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.removeScriptChangeEventListener",
	"Comment": "removes the given event listener object. returns true if the listener was removed, false if that listenerwas never added.",
	"Method": "boolean removeScriptChangeEventListener(ScriptsChangeEventListener listener){\r\n    return ListenerRegistration.removeFromList(listener, scriptChangeListeners);\r\n}"
}, {
	"Path": "org.bitcoinj.core.PartialMerkleTree.getTreeWidth",
	"Comment": "helper function to efficiently calculate the number of nodes at given height in the merkle tree",
	"Method": "int getTreeWidth(int transactionCount,int height){\r\n    return (transactionCount + (1 << height) - 1) >> height;\r\n}"
}, {
	"Path": "org.bitcoinj.core.PeerGroup.removeDisconnectedEventListener",
	"Comment": "the given event listener will no longer be called with events.",
	"Method": "boolean removeDisconnectedEventListener(PeerDisconnectedEventListener listener){\r\n    boolean result = ListenerRegistration.removeFromList(listener, peerDisconnectedEventListeners);\r\n    for (Peer peer : getConnectedPeers()) peer.removeDisconnectedEventListener(listener);\r\n    for (Peer peer : getPendingPeers()) peer.removeDisconnectedEventListener(listener);\r\n    return result;\r\n}"
}, {
	"Path": "commons.validator.routines.EmailValidator.isValidUser",
	"Comment": "returns true if the user component of an email address is valid.",
	"Method": "boolean isValidUser(String user){\r\n    return USER_PATTERN.matcher(user).matches();\r\n}"
}, {
	"Path": "com.github.pedrovgs.problem9.Factorial.getRecursive",
	"Comment": "recursive implementation of the previous algorithm. the complexity order in time and spaceterms is the same. take into account that this implementation is not tail recursive.",
	"Method": "int getRecursive(int n){\r\n    validateInput(n);\r\n    if (n == 0) {\r\n        return 1;\r\n    } else {\r\n        return n * getRecursive(n - 1);\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.TransactionOutput.getIndex",
	"Comment": "gets the index of this output in the parent transaction, or throws if this output is free standing. iteratesover the parents list to discover this.",
	"Method": "int getIndex(){\r\n    List<TransactionOutput> outputs = getParentTransaction().getOutputs();\r\n    for (int i = 0; i < outputs.size(); i++) {\r\n        if (outputs.get(i) == this)\r\n            return i;\r\n    }\r\n    throw new IllegalStateException(\"Output linked to wrong parent transaction?\");\r\n}"
}, {
	"Path": "org.atmosphere.util.ExcludeSessionBroadcaster.broadcast",
	"Comment": "the atmosphereresources subset will be exclude for this broadcast",
	"Method": "Future<Object> broadcast(Object msg,AtmosphereResource r,Future<Object> broadcast,Object msg,Set<AtmosphereResource> subset,Future<Object> broadcast,Object msg,List<HttpSession> sessions,Future<Object> broadcast,Object msg,HttpSession s){\r\n    if (destroyed.get()) {\r\n        return futureDone(msg);\r\n    }\r\n    Set<AtmosphereResource> subset = new HashSet<AtmosphereResource>();\r\n    subset.addAll(resources);\r\n    for (AtmosphereResource r : resources) {\r\n        if (!r.getAtmosphereResourceEvent().isCancelled() && s.equals(r.getRequest().getSession())) {\r\n            subset.remove(r);\r\n        }\r\n    }\r\n    start();\r\n    Object newMsg = filter(msg);\r\n    if (newMsg == null) {\r\n        return futureDone(msg);\r\n    }\r\n    BroadcasterFuture<Object> f = new BroadcasterFuture<Object>(newMsg, subset.size());\r\n    dispatchMessages(new Deliver(newMsg, subset, f, msg));\r\n    return f;\r\n}"
}, {
	"Path": "io.aeron.archive.client.AeronArchive.listRecordingsForUri",
	"Comment": "list recording descriptors from a recording id with a limit of record count for a given channel and stream id.if the recording id is greater than the largest known id then nothing is returned.",
	"Method": "int listRecordingsForUri(long fromRecordingId,int recordCount,String channel,int streamId,RecordingDescriptorConsumer consumer){\r\n    lock.lock();\r\n    try {\r\n        final long correlationId = aeron.nextCorrelationId();\r\n        if (!archiveProxy.listRecordingsForUri(fromRecordingId, recordCount, channel, streamId, correlationId, controlSessionId)) {\r\n            throw new ArchiveException(\"failed to send list recordings request\");\r\n        }\r\n        return pollForDescriptors(correlationId, recordCount, consumer);\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "io.aeron.cluster.client.AeronCluster.leadershipTermId",
	"Comment": "leadership term identity for the cluster. advances with changing leadership.",
	"Method": "long leadershipTermId(){\r\n    return leadershipTermId;\r\n}"
}, {
	"Path": "io.aeron.cluster.ClusteredMediaDriver.main",
	"Comment": "launch the clustered media driver aggregate and await a shutdown signal.",
	"Method": "void main(String[] args){\r\n    loadPropertiesFiles(args);\r\n    try (ClusteredMediaDriver driver = launch()) {\r\n        driver.consensusModule().context().shutdownSignalBarrier().await();\r\n        System.out.println(\"Shutdown ClusteredMediaDriver...\");\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.NetworkParameters.passesCheckpoint",
	"Comment": "returns true if the block height is either not a checkpoint, or is a checkpoint and the hash matches.",
	"Method": "boolean passesCheckpoint(int height,Sha256Hash hash){\r\n    Sha256Hash checkpointHash = checkpoints.get(height);\r\n    return checkpointHash == null || checkpointHash.equals(hash);\r\n}"
}, {
	"Path": "com.mikepenz.iconics.IconicsDrawable.updateIconColor",
	"Comment": "ensures that the icon paint and alpha is consistent with icon state, invalidates icon ifany changes were made",
	"Method": "void updateIconColor(){\r\n    boolean invalidate = false;\r\n    int color = mIconColor.getColorForState(getState(), mIconColor.getDefaultColor());\r\n    int red = Color.red(color);\r\n    int green = Color.green(color);\r\n    int blue = Color.blue(color);\r\n    int iconColor = Color.rgb(red, green, blue);\r\n    if (iconColor != mIconPaint.getColor()) {\r\n        mIconPaint.setColor(iconColor);\r\n        invalidate = true;\r\n    }\r\n    int alpha = Color.alpha(color);\r\n    if (alpha != 255 && alpha != mAlpha) {\r\n        setAlpha(alpha);\r\n    } else if (invalidate) {\r\n        invalidateSelf();\r\n    }\r\n}"
}, {
	"Path": "io.aeron.Publication.close",
	"Comment": "release resources used by this publication when there are no more references.publications are reference counted and are only truly closed when the ref count reaches zero.",
	"Method": "void close(){\r\n    if (!isClosed) {\r\n        conductor.releasePublication(this);\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.utils.VersionTally.add",
	"Comment": "add a new block version to the tally, and return the count for that versionwithin the window.",
	"Method": "void add(long version){\r\n    versionWindow[versionWriteHead++] = version;\r\n    if (versionWriteHead == versionWindow.length) {\r\n        versionWriteHead = 0;\r\n    }\r\n    versionsStored++;\r\n}"
}, {
	"Path": "problems.easy.ContainsDuplicateII.containsNearbyDuplicate",
	"Comment": "maintain every element with last encountered index in the array. in each loop iteration check ifthis element is in map and check last encountered index to decide.",
	"Method": "boolean containsNearbyDuplicate(int[] a,int k){\r\n    Map<Integer, Integer> map = new HashMap();\r\n    for (int i = 0; i < a.length; i++) {\r\n        if (map.containsKey(a[i]) && i - map.get(a[i]) <= k)\r\n            return true;\r\n        map.put(a[i], i);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "io.aeron.archive.client.AeronArchive.listRecordings",
	"Comment": "list all recording descriptors from a recording id with a limit of record count.if the recording id is greater than the largest known id then nothing is returned.",
	"Method": "int listRecordings(long fromRecordingId,int recordCount,RecordingDescriptorConsumer consumer){\r\n    lock.lock();\r\n    try {\r\n        final long correlationId = aeron.nextCorrelationId();\r\n        if (!archiveProxy.listRecordings(fromRecordingId, recordCount, correlationId, controlSessionId)) {\r\n            throw new ArchiveException(\"failed to send list recordings request\");\r\n        }\r\n        return pollForDescriptors(correlationId, recordCount, consumer);\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "io.aeron.ControlledFragmentAssembler.freeSessionBuffer",
	"Comment": "free an existing session buffer to reduce memory pressure when an image goes inactive or no morelarge messages are expected.",
	"Method": "boolean freeSessionBuffer(int sessionId){\r\n    return null != builderBySessionIdMap.remove(sessionId);\r\n}"
}, {
	"Path": "org.bitcoinj.utils.VersionTally.getCountAtOrAbove",
	"Comment": "get the count of blocks at or above the given version, within the window.",
	"Method": "Integer getCountAtOrAbove(long version){\r\n    if (versionsStored < versionWindow.length) {\r\n        return null;\r\n    }\r\n    int count = 0;\r\n    for (int versionIdx = 0; versionIdx < versionWindow.length; versionIdx++) {\r\n        if (versionWindow[versionIdx] >= version) {\r\n            count++;\r\n        }\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "io.aeron.archive.client.ControlResponseAdapter.dispatchDescriptor",
	"Comment": "dispatch a descriptor message to a consumer by reading the fields in the correct order.",
	"Method": "void dispatchDescriptor(RecordingDescriptorDecoder decoder,RecordingDescriptorConsumer consumer){\r\n    consumer.onRecordingDescriptor(decoder.controlSessionId(), decoder.correlationId(), decoder.recordingId(), decoder.startTimestamp(), decoder.stopTimestamp(), decoder.startPosition(), decoder.stopPosition(), decoder.initialTermId(), decoder.segmentFileLength(), decoder.termBufferLength(), decoder.mtuLength(), decoder.sessionId(), decoder.streamId(), decoder.strippedChannel(), decoder.originalChannel(), decoder.sourceIdentity());\r\n}"
}, {
	"Path": "io.aeron.status.ChannelEndpointStatus.allocate",
	"Comment": "allocate an indicator for tracking the status of a channel endpoint.",
	"Method": "AtomicCounter allocate(MutableDirectBuffer tempBuffer,String name,int typeId,CountersManager countersManager,String channel){\r\n    final int keyLength = tempBuffer.putStringWithoutLengthAscii(CHANNEL_OFFSET + SIZE_OF_INT, channel, 0, MAX_CHANNEL_LENGTH);\r\n    tempBuffer.putInt(CHANNEL_OFFSET, keyLength);\r\n    int labelLength = 0;\r\n    labelLength += tempBuffer.putStringWithoutLengthAscii(keyLength + labelLength, name);\r\n    labelLength += tempBuffer.putStringWithoutLengthAscii(keyLength + labelLength, \": \");\r\n    labelLength += tempBuffer.putStringWithoutLengthAscii(keyLength + labelLength, channel, 0, MAX_LABEL_LENGTH - labelLength);\r\n    return countersManager.newCounter(typeId, tempBuffer, 0, keyLength, tempBuffer, keyLength, labelLength);\r\n}"
}, {
	"Path": "org.bitcoinj.core.TransactionConfidence.getConfidenceType",
	"Comment": "returns a general statement of the level of confidence you can have in this transaction.",
	"Method": "ConfidenceType getConfidenceType(){\r\n    return confidenceType;\r\n}"
}, {
	"Path": "io.aeron.Image.sourceIdentity",
	"Comment": "the source identity of the sending publisher as an abstract concept appropriate for the media.",
	"Method": "String sourceIdentity(){\r\n    return sourceIdentity;\r\n}"
}, {
	"Path": "io.aeron.Image.termBufferLength",
	"Comment": "get the length in bytes for each term partition in the log buffer.",
	"Method": "int termBufferLength(){\r\n    return termLengthMask + 1;\r\n}"
}, {
	"Path": "problems.easy.IntersectionofTwoLinkedLists.getIntersectionNode2",
	"Comment": "this is another iterative solution without knowing size of lists. we can use two iterations to do that. in the first iteration, we will reset the pointer of one linked list to the head of another linked list after it reaches the tail node. in the second iteration, we will move two pointers until they points to the same node. our operations in first iteration will help us counteract the difference. so if two linked list intersects, the meeting point in second iteration must be the intersection point. if the two linked lists have no intersection at all, then the meeting pointer in second iteration must be the tail node of both lists, which is null",
	"Method": "ListNode getIntersectionNode2(ListNode x,ListNode y){\r\n    if (x == null || y == null)\r\n        return null;\r\n    ListNode xhead = x;\r\n    ListNode yhead = y;\r\n    while (xhead != yhead) {\r\n        xhead = xhead == null ? y : xhead.next;\r\n        yhead = yhead == null ? x : yhead.next;\r\n    }\r\n    return xhead;\r\n}"
}, {
	"Path": "commons.validator.routines.AbstractNumberValidator.isAllowFractions",
	"Comment": "indicates whether the number being validated is a decimal or integer.",
	"Method": "boolean isAllowFractions(){\r\n    return allowFractions;\r\n}"
}, {
	"Path": "org.bitcoinj.protocols.channels.PaymentChannelV2ServerState.createOutputScript",
	"Comment": "creates a p2sh script outputting to the client and server pubkeys",
	"Method": "Script createOutputScript(){\r\n    return ScriptBuilder.createP2SHOutputScript(createP2SHRedeemScript());\r\n}"
}, {
	"Path": "org.bitcoinj.kits.WalletAppKit.setWalletFactory",
	"Comment": "sets a wallet factory which will be used when the kit creates a new wallet.",
	"Method": "WalletAppKit setWalletFactory(WalletProtobufSerializer.WalletFactory walletFactory){\r\n    this.walletFactory = walletFactory;\r\n    return this;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.DeterministicKeyChain.getIssuedInternalKeys",
	"Comment": "returns number of keys used on internal path. this may be fewer than the number that have been deserializedor held in memory, because of the lookahead zone.",
	"Method": "int getIssuedInternalKeys(){\r\n    lock.lock();\r\n    try {\r\n        return issuedInternalKeys;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.Peer.getConnectionOpenFuture",
	"Comment": "provides a listenablefuture that can be used to wait for the socket to connect.a socket connection does notmean that protocol handshake has occurred.",
	"Method": "ListenableFuture<Peer> getConnectionOpenFuture(){\r\n    return connectionOpenFuture;\r\n}"
}, {
	"Path": "com.mikepenz.iconics.Iconics.style",
	"Comment": "creates a new spannablestringbuilder and will iterate over the textspanned once and copy overall characters, it will also directly replace icon font placeholders with the correct mapping.afterwards it will apply the styles",
	"Method": "Spanned style(Context ctx,Spanned textSpanned,Spanned style,Context ctx,HashMap<String, ITypeface> fonts,Spanned textSpanned,List<CharacterStyle> styles,HashMap<String, List<CharacterStyle>> stylesFor,IconicsBuilder style,CharacterStyle styles){\r\n    fonts = init(ctx, fonts);\r\n    TextStyleContainer textStyleContainer = IconicsUtils.findIcons(textSpanned, fonts);\r\n    SpannableString sb = SpannableString.valueOf(textStyleContainer.spannableStringBuilder);\r\n    IconicsUtils.applyStyles(ctx, sb, textStyleContainer.styleContainers, styles, stylesFor);\r\n    return sb;\r\n}"
}, {
	"Path": "org.bitcoinj.protocols.payments.PaymentSession.getMerchantData",
	"Comment": "returns the merchant data included by the merchant in the payment request, or null if none.",
	"Method": "byte[] getMerchantData(){\r\n    if (paymentDetails.hasMerchantData())\r\n        return paymentDetails.getMerchantData().toByteArray();\r\n    else\r\n        return null;\r\n}"
}, {
	"Path": "org.bitcoinj.core.Block.verifyHeader",
	"Comment": "checks the block data to ensure it follows the rules laid out in the network parameters. specifically,throws an exception if the proof of work is invalid, or if the timestamp is too far from what it should be.this is not everything that is required for a block to be valid, only what is checkable independentof the chain and without a transaction index.",
	"Method": "void verifyHeader(){\r\n    checkProofOfWork(true);\r\n    checkTimestamp();\r\n}"
}, {
	"Path": "org.atmosphere.interceptor.HeartbeatInterceptor.getPaddingBytes",
	"Comment": "gets the bytes to use when sending an heartbeat for both client and server.",
	"Method": "byte[] getPaddingBytes(){\r\n    return this.paddingBytes;\r\n}"
}, {
	"Path": "org.bitcoinj.core.TransactionOutput.getScriptBytes",
	"Comment": "the backing script bytes which can be turned into a script object.",
	"Method": "byte[] getScriptBytes(){\r\n    return scriptBytes;\r\n}"
}, {
	"Path": "org.bitcoinj.core.PeerGroup.findPeersOfAtLeastVersion",
	"Comment": "returns an array list of peers that implement the given protocol version or better.",
	"Method": "List<Peer> findPeersOfAtLeastVersion(long protocolVersion){\r\n    lock.lock();\r\n    try {\r\n        ArrayList<Peer> results = new ArrayList<Peer>(peers.size());\r\n        for (Peer peer : peers) if (peer.getPeerVersionMessage().clientVersion >= protocolVersion)\r\n            results.add(peer);\r\n        return results;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.testing.FakeTxBuilder.createFakeTx",
	"Comment": "create a fake tx of sufficient realism to exercise the unit tests. two outputs, one to us, one to somewhereelse to simulate change. there is one random input.",
	"Method": "Transaction createFakeTx(NetworkParameters params,Transaction createFakeTx,NetworkParameters params,Coin value,Address to,Transaction createFakeTx,NetworkParameters params,Coin value,ECKey to,Transaction[] createFakeTx,NetworkParameters params,Coin value,Address to,Address from){\r\n    Transaction t = new Transaction(params);\r\n    TransactionOutput outputToMe = new TransactionOutput(params, t, value, to);\r\n    t.addOutput(outputToMe);\r\n    TransactionOutput change = new TransactionOutput(params, t, valueOf(1, 11), LegacyAddress.fromKey(params, new ECKey()));\r\n    t.addOutput(change);\r\n    Transaction feederTx = new Transaction(params);\r\n    TransactionOutput feederOut = new TransactionOutput(params, feederTx, value, from);\r\n    feederTx.addOutput(feederOut);\r\n    Transaction prevTx = new Transaction(params);\r\n    TransactionOutput prevOut = new TransactionOutput(params, prevTx, value, to);\r\n    prevTx.addOutput(prevOut);\r\n    prevTx.addInput(feederOut);\r\n    t.addInput(prevOut);\r\n    return new Transaction[] { roundTripTransaction(params, prevTx), roundTripTransaction(params, t) };\r\n}"
}, {
	"Path": "org.bitcoinj.utils.Fiat.toFriendlyString",
	"Comment": "returns the value as a 0.12 type string. more digits after the decimal place will be used if necessary, but twowill always be present.",
	"Method": "String toFriendlyString(){\r\n    return FRIENDLY_FORMAT.code(0, currencyCode).format(this).toString();\r\n}"
}, {
	"Path": "org.atmosphere.interceptor.HeartbeatInterceptor.clock",
	"Comment": "configures the heartbeat sent by the server in an interval in seconds specified in parameter for the givenresource.",
	"Method": "HeartbeatInterceptor clock(int interval,AtmosphereResource r,AtmosphereRequest request,AtmosphereResponse response){\r\n    try {\r\n        request.setAttribute(HEARTBEAT_FUTURE, heartBeat.schedule(new Callable<Object>() {\r\n            @Override\r\n            public Object call() throws Exception {\r\n                synchronized (r) {\r\n                    if (AtmosphereResourceImpl.class.cast(r).isInScope() && r.isSuspended()) {\r\n                        try {\r\n                            logger.trace(\"Heartbeat for Resource {}\", r);\r\n                            response.write(paddingBytes, false);\r\n                            if (Utils.resumableTransport(r.transport()) && resumeOnHeartbeat) {\r\n                                r.resume();\r\n                            } else if (flushBuffer) {\r\n                                response.flushBuffer();\r\n                            }\r\n                        } catch (Throwable t) {\r\n                            logger.trace(\"{}\", r.uuid(), t);\r\n                            cancelF(request);\r\n                        }\r\n                    } else {\r\n                        cancelF(request);\r\n                    }\r\n                }\r\n                return null;\r\n            }\r\n        }, interval, TimeUnit.SECONDS));\r\n    } catch (Throwable t) {\r\n        logger.warn(\"\", t);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.atmosphere.interceptor.HeartbeatInterceptor.clock",
	"Comment": "configures the heartbeat sent by the server in an interval in seconds specified in parameter for the givenresource.",
	"Method": "HeartbeatInterceptor clock(int interval,AtmosphereResource r,AtmosphereRequest request,AtmosphereResponse response){\r\n    synchronized (r) {\r\n        if (AtmosphereResourceImpl.class.cast(r).isInScope() && r.isSuspended()) {\r\n            try {\r\n                logger.trace(\"Heartbeat for Resource {}\", r);\r\n                response.write(paddingBytes, false);\r\n                if (Utils.resumableTransport(r.transport()) && resumeOnHeartbeat) {\r\n                    r.resume();\r\n                } else if (flushBuffer) {\r\n                    response.flushBuffer();\r\n                }\r\n            } catch (Throwable t) {\r\n                logger.trace(\"{}\", r.uuid(), t);\r\n                cancelF(request);\r\n            }\r\n        } else {\r\n            cancelF(request);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bitcoinj.core.BloomFilter.merge",
	"Comment": "copies filter into this. filter must have the same size, hash function count and ntweak or anillegalargumentexception will be thrown.",
	"Method": "void merge(BloomFilter filter){\r\n    if (!this.matchesAll() && !filter.matchesAll()) {\r\n        checkArgument(filter.data.length == this.data.length && filter.hashFuncs == this.hashFuncs && filter.nTweak == this.nTweak);\r\n        for (int i = 0; i < data.length; i++) this.data[i] |= filter.data[i];\r\n    } else {\r\n        this.data = new byte[] { (byte) 0xff };\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.Sha256Hash.wrapReversed",
	"Comment": "creates a new instance that wraps the given hash value, but with byte order reversed.",
	"Method": "Sha256Hash wrapReversed(byte[] rawHashBytes){\r\n    return wrap(Utils.reverseBytes(rawHashBytes));\r\n}"
}, {
	"Path": "org.bitcoinj.core.ECKey.getPubKeyPoint",
	"Comment": "gets the public key in the form of an elliptic curve point object from bouncy castle.",
	"Method": "ECPoint getPubKeyPoint(){\r\n    return pub.get();\r\n}"
}, {
	"Path": "org.bitcoinj.utils.MonetaryFormat.code",
	"Comment": "configure currency code for given decimal separator shift. this configuration is not relevant for parsing.",
	"Method": "MonetaryFormat code(int codeShift,String code,String code){\r\n    if (codes == null)\r\n        return null;\r\n    if (codes[shift] == null)\r\n        throw new NumberFormatException(\"missing code for shift: \" + shift);\r\n    return codes[shift];\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.DeterministicSeed.check",
	"Comment": "check if our mnemonic is a valid mnemonic phrase for our word list.does nothing if we are encrypted.",
	"Method": "void check(){\r\n    if (mnemonicCode != null)\r\n        MnemonicCode.INSTANCE.check(mnemonicCode);\r\n}"
}, {
	"Path": "org.bitcoinj.core.TransactionConfidence.queueListeners",
	"Comment": "call this after adjusting the confidence, for cases where listeners should be notified. this has to be doneexplicitly rather than being done automatically because sometimes complex changes to transaction states canresult in a series of confidence changes that are not really useful to see separately. by invoking listenersexplicitly, more precise control is available. note that this will run the listeners on the user code thread.",
	"Method": "void queueListeners(Listener.ChangeReason reason){\r\n    for (final ListenerRegistration<Listener> registration : listeners) {\r\n        registration.executor.execute(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                registration.listener.onConfidenceChanged(TransactionConfidence.this, reason);\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.TransactionConfidence.queueListeners",
	"Comment": "call this after adjusting the confidence, for cases where listeners should be notified. this has to be doneexplicitly rather than being done automatically because sometimes complex changes to transaction states canresult in a series of confidence changes that are not really useful to see separately. by invoking listenersexplicitly, more precise control is available. note that this will run the listeners on the user code thread.",
	"Method": "void queueListeners(Listener.ChangeReason reason){\r\n    registration.listener.onConfidenceChanged(TransactionConfidence.this, reason);\r\n}"
}, {
	"Path": "io.aeron.status.HeartbeatStatus.allocate",
	"Comment": "allocate a counter for tracking the last heartbeat of an entity.",
	"Method": "AtomicCounter allocate(MutableDirectBuffer tempBuffer,String name,int typeId,CountersManager countersManager,long registrationId){\r\n    return new AtomicCounter(countersManager.valuesBuffer(), allocateCounterId(tempBuffer, name, typeId, countersManager, registrationId), countersManager);\r\n}"
}, {
	"Path": "org.bitcoinj.utils.MonetaryFormat.codeSeparator",
	"Comment": "separator between currency code and formatted value. this configuration is not relevant for parsing.",
	"Method": "MonetaryFormat codeSeparator(char codeSeparator){\r\n    checkArgument(!Character.isDigit(codeSeparator));\r\n    checkArgument(codeSeparator > 0);\r\n    if (codeSeparator == this.codeSeparator)\r\n        return this;\r\n    else\r\n        return new MonetaryFormat(negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed);\r\n}"
}, {
	"Path": "org.bitcoinj.utils.BtcFormat.inSatoshis",
	"Comment": "takes an object representing a bitcoin quantity of any type theclient is permitted to pass us, and return a biginteger representing thenumber of satoshis having the equivalent value.",
	"Method": "BigInteger inSatoshis(Object qty){\r\n    BigInteger satoshis;\r\n    if (qty instanceof Long || qty instanceof Integer)\r\n        satoshis = BigInteger.valueOf(((Number) qty).longValue());\r\n    else if (qty instanceof BigInteger)\r\n        satoshis = (BigInteger) qty;\r\n    else if (qty instanceof BigDecimal)\r\n        satoshis = ((BigDecimal) qty).movePointRight(Coin.SMALLEST_UNIT_EXPONENT).setScale(0, BigDecimal.ROUND_HALF_UP).unscaledValue();\r\n    else if (qty instanceof Coin)\r\n        satoshis = BigInteger.valueOf(((Coin) qty).value);\r\n    else\r\n        throw new IllegalArgumentException(\"Cannot format a \" + qty.getClass().getSimpleName() + \" as a Bicoin value\");\r\n    return satoshis;\r\n}"
}, {
	"Path": "org.atmosphere.websocket.WebSocket.binaryWrite",
	"Comment": "switch to binary write, or go back to text write. default is false.",
	"Method": "WebSocket binaryWrite(boolean binaryWrite){\r\n    this.binaryWrite = binaryWrite;\r\n    return this;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.DeterministicKeyChain.getIssuedReceiveKeys",
	"Comment": "returns only the external keys that have been issued by this chain, lookahead not included.",
	"Method": "List<ECKey> getIssuedReceiveKeys(){\r\n    final List<ECKey> keys = new ArrayList(getKeys(false, false));\r\n    for (Iterator<ECKey> i = keys.iterator(); i.hasNext(); ) {\r\n        DeterministicKey parent = ((DeterministicKey) i.next()).getParent();\r\n        if (parent == null || !externalParentKey.equals(parent))\r\n            i.remove();\r\n    }\r\n    return keys;\r\n}"
}, {
	"Path": "org.bitcoinj.core.Transaction.clearOutputs",
	"Comment": "removes all the outputs from this transaction.note that this also invalidates the length attribute",
	"Method": "void clearOutputs(){\r\n    unCache();\r\n    for (TransactionOutput output : outputs) {\r\n        output.setParent(null);\r\n    }\r\n    outputs.clear();\r\n    this.length = this.unsafeBitcoinSerialize().length;\r\n}"
}, {
	"Path": "org.atmosphere.util.uri.UriTemplate.match",
	"Comment": "match a uri against the template.if the uri matches against the pattern then the template variable to value map will be filled with template variables as keys and template values as values.",
	"Method": "boolean match(CharSequence uri,Map<String, String> templateVariableToValue,boolean match,CharSequence uri,List<String> groupValues){\r\n    if (groupValues == null)\r\n        throw new IllegalArgumentException();\r\n    return pattern.match(uri, groupValues);\r\n}"
}, {
	"Path": "io.aeron.ChannelUriStringBuilder.reliable",
	"Comment": "get the subscription semantics for if loss is acceptable, or not, for a reliable message delivery.",
	"Method": "ChannelUriStringBuilder reliable(Boolean isReliable,Boolean reliable){\r\n    return reliable;\r\n}"
}, {
	"Path": "io.aeron.cluster.RecordingLog.nextEntryIndex",
	"Comment": "get the next index to be used when appending an entry to the log.",
	"Method": "int nextEntryIndex(){\r\n    return nextEntryIndex;\r\n}"
}, {
	"Path": "org.bitcoinj.core.Transaction.getFee",
	"Comment": "the transaction fee is the difference of the value of all inputs and the value of all outputs. currently, the feecan only be determined for transactions created by us.",
	"Method": "Coin getFee(){\r\n    Coin fee = Coin.ZERO;\r\n    if (inputs.isEmpty() || outputs.isEmpty())\r\n        return null;\r\n    for (TransactionInput input : inputs) {\r\n        if (input.getValue() == null)\r\n            return null;\r\n        fee = fee.add(input.getValue());\r\n    }\r\n    for (TransactionOutput output : outputs) {\r\n        fee = fee.subtract(output.getValue());\r\n    }\r\n    return fee;\r\n}"
}, {
	"Path": "io.aeron.BufferBuilder.reset",
	"Comment": "reset the builder to restart append operations. the internal buffer does not shrink.",
	"Method": "BufferBuilder reset(){\r\n    limit = 0;\r\n    return this;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.removeWatchedAddress",
	"Comment": "removes the given output scripts from the wallet that were being watched.",
	"Method": "boolean removeWatchedAddress(Address address){\r\n    return removeWatchedAddresses(ImmutableList.of(address));\r\n}"
}, {
	"Path": "org.bitcoinj.core.TransactionConfidence.incrementDepthInBlocks",
	"Comment": "called by the wallet when the tx appears on the best chain and a new block is added to the top. updates theinternal counter that tracks how deeply buried the block is.",
	"Method": "int incrementDepthInBlocks(){\r\n    return ++this.depth;\r\n}"
}, {
	"Path": "io.aeron.logbuffer.ExclusiveTermAppender.appendUnfragmentedMessage",
	"Comment": "append an unfragmented message to the the term buffer as a gathering of vectors.",
	"Method": "int appendUnfragmentedMessage(int termId,int termOffset,HeaderWriter header,DirectBuffer srcBuffer,int srcOffset,int length,ReservedValueSupplier reservedValueSupplier,int appendUnfragmentedMessage,int termId,int termOffset,HeaderWriter header,DirectBuffer bufferOne,int offsetOne,int lengthOne,DirectBuffer bufferTwo,int offsetTwo,int lengthTwo,ReservedValueSupplier reservedValueSupplier,int appendUnfragmentedMessage,int termId,int termOffset,HeaderWriter header,DirectBufferVector[] vectors,int length,ReservedValueSupplier reservedValueSupplier){\r\n    final int frameLength = length + HEADER_LENGTH;\r\n    final int alignedLength = align(frameLength, FRAME_ALIGNMENT);\r\n    final UnsafeBuffer termBuffer = this.termBuffer;\r\n    final int termLength = termBuffer.capacity();\r\n    int resultingOffset = termOffset + alignedLength;\r\n    putRawTailOrdered(termId, resultingOffset);\r\n    if (resultingOffset > termLength) {\r\n        resultingOffset = handleEndOfLogCondition(termBuffer, termOffset, header, termLength, termId);\r\n    } else {\r\n        header.write(termBuffer, termOffset, frameLength, termId);\r\n        int offset = termOffset + HEADER_LENGTH;\r\n        for (final DirectBufferVector vector : vectors) {\r\n            termBuffer.putBytes(offset, vector.buffer, vector.offset, vector.length);\r\n            offset += vector.length;\r\n        }\r\n        if (null != reservedValueSupplier) {\r\n            final long reservedValue = reservedValueSupplier.get(termBuffer, termOffset, frameLength);\r\n            termBuffer.putLong(termOffset + RESERVED_VALUE_OFFSET, reservedValue, LITTLE_ENDIAN);\r\n        }\r\n        frameLengthOrdered(termBuffer, termOffset, frameLength);\r\n    }\r\n    return resultingOffset;\r\n}"
}, {
	"Path": "org.bitcoinj.core.PeerGroup.setDownloadTxDependencies",
	"Comment": "configure download of pending transaction dependencies. a change of values only takes effect for newly connectedpeers.",
	"Method": "void setDownloadTxDependencies(int depth){\r\n    lock.lock();\r\n    try {\r\n        this.downloadTxDependencyDepth = depth;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.Block.getTime",
	"Comment": "returns the time at which the block was solved and broadcast, according to the clock of the solving node.",
	"Method": "Date getTime(){\r\n    return new Date(getTimeSeconds() * 1000);\r\n}"
}, {
	"Path": "io.aeron.ChannelUriStringBuilder.linger",
	"Comment": "get the time a network publication will linger in nanoseconds after being drained. this time is so that tail losscan be recovered.",
	"Method": "ChannelUriStringBuilder linger(Long lingerNs,Long linger){\r\n    return linger;\r\n}"
}, {
	"Path": "org.bitcoinj.script.ScriptBuilder.createRedeemScript",
	"Comment": "creates redeem script with given public keys and threshold. given public keys will be placed inredeem script in the lexicographical sorting order.",
	"Method": "Script createRedeemScript(int threshold,List<ECKey> pubkeys){\r\n    pubkeys = new ArrayList(pubkeys);\r\n    Collections.sort(pubkeys, ECKey.PUBKEY_COMPARATOR);\r\n    return ScriptBuilder.createMultiSigOutputScript(threshold, pubkeys);\r\n}"
}, {
	"Path": "org.bitcoinj.core.Utils.finishMockSleep",
	"Comment": "let the sleeping thread pass the synchronization point any number of times.",
	"Method": "void finishMockSleep(){\r\n    if (mockSleepQueue != null) {\r\n        mockSleepQueue.offer(true);\r\n    }\r\n}"
}, {
	"Path": "org.atmosphere.handler.AbstractReflectorAtmosphereHandler.postStateChange",
	"Comment": "inspect the event and decide if the underlying connection must be resumed.",
	"Method": "void postStateChange(AtmosphereResourceEvent event){\r\n    if (event.isCancelled() || event.isResuming())\r\n        return;\r\n    AtmosphereResourceImpl r = AtmosphereResourceImpl.class.cast(event.getResource());\r\n    if (r == null) {\r\n        logger.trace(\"Event {} returned a null AtmosphereResource\", event);\r\n        return;\r\n    }\r\n    Boolean resumeOnBroadcast = r.resumeOnBroadcast();\r\n    if (!resumeOnBroadcast) {\r\n        Object o = r.getRequest(false).getAttribute(ApplicationConfig.RESUME_ON_BROADCAST);\r\n        if (o != null && Boolean.class.isAssignableFrom(o.getClass())) {\r\n            resumeOnBroadcast = Boolean.class.cast(o);\r\n        }\r\n    }\r\n    if (resumeOnBroadcast != null && resumeOnBroadcast) {\r\n        r.resume();\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.MessageSerializer.makeTransaction",
	"Comment": "make a transaction from the payload. extension point for alternativeserialization format support.",
	"Method": "Transaction makeTransaction(byte[] payloadBytes,int offset,int length,byte[] hash,Transaction makeTransaction,byte[] payloadBytes,Transaction makeTransaction,byte[] payloadBytes,int offset){\r\n    return makeTransaction(payloadBytes, offset, payloadBytes.length, null);\r\n}"
}, {
	"Path": "org.bitcoinj.core.Peer.setMinProtocolVersion",
	"Comment": "the minimum p2p protocol version that is accepted. if the peer speaks a protocol version lower than this, itwill be disconnected.",
	"Method": "boolean setMinProtocolVersion(int minProtocolVersion){\r\n    this.vMinProtocolVersion = minProtocolVersion;\r\n    VersionMessage ver = getPeerVersionMessage();\r\n    if (ver != null && ver.clientVersion < minProtocolVersion) {\r\n        log.warn(\"{}: Disconnecting due to new min protocol version {}, got: {}\", this, minProtocolVersion, ver.clientVersion);\r\n        close();\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "io.aeron.cluster.service.RecoveryState.allocate",
	"Comment": "allocate a counter to represent the snapshot services should load on start.",
	"Method": "Counter allocate(Aeron aeron,MutableDirectBuffer tempBuffer,long leadershipTermId,long logPosition,long timestamp,boolean hasReplay,long snapshotRecordingIds){\r\n    tempBuffer.putLong(LEADERSHIP_TERM_ID_OFFSET, leadershipTermId);\r\n    tempBuffer.putLong(LOG_POSITION_OFFSET, logPosition);\r\n    tempBuffer.putLong(TIMESTAMP_OFFSET, timestamp);\r\n    tempBuffer.putInt(REPLAY_FLAG_OFFSET, hasReplay ? 1 : 0);\r\n    final int serviceCount = snapshotRecordingIds.length;\r\n    tempBuffer.putInt(SERVICE_COUNT_OFFSET, serviceCount);\r\n    final int keyLength = SNAPSHOT_RECORDING_IDS_OFFSET + (serviceCount * SIZE_OF_LONG);\r\n    if (keyLength > MAX_KEY_LENGTH) {\r\n        throw new ClusterException(keyLength + \" exceeds max key length \" + MAX_KEY_LENGTH);\r\n    }\r\n    for (int i = 0; i < serviceCount; i++) {\r\n        tempBuffer.putLong(SNAPSHOT_RECORDING_IDS_OFFSET + (i * SIZE_OF_LONG), snapshotRecordingIds[i]);\r\n    }\r\n    final int labelOffset = BitUtil.align(keyLength, SIZE_OF_INT);\r\n    int labelLength = 0;\r\n    labelLength += tempBuffer.putStringWithoutLengthAscii(labelOffset + labelLength, NAME);\r\n    labelLength += tempBuffer.putLongAscii(keyLength + labelLength, leadershipTermId);\r\n    labelLength += tempBuffer.putStringWithoutLengthAscii(labelOffset + labelLength, \" logPosition=\");\r\n    labelLength += tempBuffer.putLongAscii(labelOffset + labelLength, logPosition);\r\n    labelLength += tempBuffer.putStringWithoutLengthAscii(labelOffset + labelLength, \" hasReplay=\" + hasReplay);\r\n    return aeron.addCounter(RECOVERY_STATE_TYPE_ID, tempBuffer, 0, keyLength, tempBuffer, labelOffset, labelLength);\r\n}"
}, {
	"Path": "org.atmosphere.runtime.AtmosphereFramework.autoDetectContainer",
	"Comment": "auto detect the underlying servlet container we are running on.",
	"Method": "void autoDetectContainer(){\r\n    if (getAsyncSupport() == null) {\r\n        setAsyncSupport(createAsyncSupportResolver().resolve(useNativeImplementation, useBlockingImplementation, useServlet30));\r\n    }\r\n}"
}, {
	"Path": "io.aeron.archive.client.AeronArchive.truncateRecording",
	"Comment": "truncate a stopped recording to a given position that is less than the stopped position. the provided positionmust be on a fragment boundary. truncating a recording to the start position effectively deletes the recording.",
	"Method": "void truncateRecording(long recordingId,long position){\r\n    lock.lock();\r\n    try {\r\n        final long correlationId = aeron.nextCorrelationId();\r\n        if (!archiveProxy.truncateRecording(recordingId, position, correlationId, controlSessionId)) {\r\n            throw new ArchiveException(\"failed to send truncate recording request\");\r\n        }\r\n        pollForResponse(correlationId);\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "io.aeron.cluster.ClusterMember.removeMember",
	"Comment": "remove a member from an array if found, otherwise return the array unmodified.",
	"Method": "ClusterMember[] removeMember(ClusterMember[] oldMembers,int memberId){\r\n    return ArrayUtil.remove(oldMembers, findMemberIndex(oldMembers, memberId));\r\n}"
}, {
	"Path": "org.bitcoinj.core.NetworkParameters.unitTests",
	"Comment": "returns a testnet params modified to allow any difficulty target.",
	"Method": "NetworkParameters unitTests(){\r\n    return UnitTestParams.get();\r\n}"
}, {
	"Path": "org.bitcoinj.core.TransactionInput.isCoinBase",
	"Comment": "coinbase transactions have special inputs with hashes of zero. if this is such an input, returns true.",
	"Method": "boolean isCoinBase(){\r\n    return outpoint.getHash().equals(Sha256Hash.ZERO_HASH) && (outpoint.getIndex() & 0xFFFFFFFFL) == 0xFFFFFFFFL;\r\n}"
}, {
	"Path": "org.bitcoinj.protocols.channels.PaymentChannelV2ServerState.signP2SHInput",
	"Comment": "signs the first input of the transaction which must spend the multisig contract.",
	"Method": "void signP2SHInput(Transaction tx,Transaction.SigHash hashType,boolean anyoneCanPay,KeyParameter userKey){\r\n    TransactionSignature signature = tx.calculateSignature(0, serverKey, userKey, createP2SHRedeemScript(), hashType, anyoneCanPay);\r\n    byte[] mySig = signature.encodeToBitcoin();\r\n    Script scriptSig = ScriptBuilder.createCLTVPaymentChannelP2SHInput(bestValueSignature, mySig, createP2SHRedeemScript());\r\n    tx.getInput(0).setScriptSig(scriptSig);\r\n}"
}, {
	"Path": "org.bitcoinj.kits.WalletAppKit.connectToLocalHost",
	"Comment": "will only connect to localhost. cannot be called after startup.",
	"Method": "WalletAppKit connectToLocalHost(){\r\n    try {\r\n        final InetAddress localHost = InetAddress.getLocalHost();\r\n        return setPeerNodes(new PeerAddress(params, localHost, params.getPort()));\r\n    } catch (UnknownHostException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "org.atmosphere.util.uri.UriTemplateParser.getNormalizedTemplate",
	"Comment": "get the normalized template.a normalized template is a template without any explicit regularexpressions.",
	"Method": "String getNormalizedTemplate(){\r\n    return normalizedTemplate.toString();\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.WalletProtobufSerializer.setRequireAllExtensionsKnown",
	"Comment": "if this property is set to true, the wallet will fail to load ifany found extensions are unknown..",
	"Method": "void setRequireAllExtensionsKnown(boolean value){\r\n    requireAllExtensionsKnown = value;\r\n}"
}, {
	"Path": "io.aeron.driver.MediaDriver.launch",
	"Comment": "launch a mediadriver embedded in the current process and provided a configuration ctx.",
	"Method": "MediaDriver launch(MediaDriver launch,Context ctx){\r\n    return new MediaDriver(ctx).start();\r\n}"
}, {
	"Path": "org.atmosphere.util.uri.UriTemplate.isTemplateVariablePresent",
	"Comment": "ascertain if a template variable is a member of thistemplate.",
	"Method": "boolean isTemplateVariablePresent(String name){\r\n    for (String s : templateVariables) {\r\n        if (s.equals(name))\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.bitcoinj.core.ECKey.toASN1",
	"Comment": "output this eckey as an asn.1 encoded private key, as understood by openssl or used by bitcoin corein its wallet storage format.",
	"Method": "byte[] toASN1(){\r\n    try {\r\n        byte[] privKeyBytes = getPrivKeyBytes();\r\n        ByteArrayOutputStream baos = new ByteArrayOutputStream(400);\r\n        DERSequenceGenerator seq = new DERSequenceGenerator(baos);\r\n        seq.addObject(new ASN1Integer(1));\r\n        seq.addObject(new DEROctetString(privKeyBytes));\r\n        seq.addObject(new DERTaggedObject(0, CURVE_PARAMS.toASN1Primitive()));\r\n        seq.addObject(new DERTaggedObject(1, new DERBitString(getPubKey())));\r\n        seq.close();\r\n        return baos.toByteArray();\r\n    } catch (IOException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.Transaction.estimateLockTime",
	"Comment": "returns either the lock time as a date, if it was specified in seconds, or an estimate based on the time inthe current head block if it was specified as a block time.",
	"Method": "Date estimateLockTime(AbstractBlockChain chain){\r\n    if (lockTime < LOCKTIME_THRESHOLD)\r\n        return chain.estimateBlockTime((int) getLockTime());\r\n    else\r\n        return new Date(getLockTime() * 1000);\r\n}"
}, {
	"Path": "org.bitcoinj.core.LegacyAddress.getVersion",
	"Comment": "get the version header of an address. this is the first byte of a base58 encoded address.",
	"Method": "int getVersion(){\r\n    return p2sh ? params.getP2SHHeader() : params.getAddressHeader();\r\n}"
}, {
	"Path": "org.bitcoinj.testing.FakeTxBuilder.createFakeBlock",
	"Comment": "emulates receiving a valid block that builds on top of the chain.",
	"Method": "BlockPair createFakeBlock(BlockStore blockStore,long version,long timeSeconds,Transaction transactions,BlockPair createFakeBlock,BlockStore blockStore,StoredBlock previousStoredBlock,long version,long timeSeconds,int height,Transaction transactions,BlockPair createFakeBlock,BlockStore blockStore,StoredBlock previousStoredBlock,int height,Transaction transactions,BlockPair createFakeBlock,BlockStore blockStore,long version,long timeSeconds,int height,Transaction transactions,BlockPair createFakeBlock,BlockStore blockStore,int height,Transaction transactions,BlockPair createFakeBlock,BlockStore blockStore,Transaction transactions){\r\n    return createFakeBlock(blockStore, Block.BLOCK_VERSION_GENESIS, Utils.currentTimeSeconds(), 0, transactions);\r\n}"
}, {
	"Path": "io.aeron.Aeron.nextCorrelationId",
	"Comment": "generate the next correlation id that is unique for the connected media driver.this is useful generating correlation identifiers for pairing requests with responses in a clients ownapplication protocol.this method is thread safe and will work across processes that all use the same media driver.",
	"Method": "long nextCorrelationId(){\r\n    if (1 == isClosed) {\r\n        throw new AeronException(\"client is closed\");\r\n    }\r\n    return commandBuffer.nextCorrelationId();\r\n}"
}, {
	"Path": "io.aeron.archive.client.ControlResponsePoller.relevantId",
	"Comment": "get the relevant id returned with the response, e.g. replay session id.",
	"Method": "long relevantId(){\r\n    return relevantId;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.findKeyFromPubHash",
	"Comment": "locates a keypair from the basickeychain given the hash of the public key. this is needed when finding out whichkey we need to use to redeem a transaction output.",
	"Method": "ECKey findKeyFromPubHash(byte[] pubkeyHash){\r\n    keyChainGroupLock.lock();\r\n    try {\r\n        return keyChainGroup.findKeyFromPubHash(pubkeyHash);\r\n    } finally {\r\n        keyChainGroupLock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.atmosphere.util.AtmosphereFilterChain.addFilter",
	"Comment": "add a filter to the set of filters that will be executed in this chain.",
	"Method": "void addFilter(FilterConfigImpl filterConfig){\r\n    if (filterConfig.getFilter() == null) {\r\n        throw new NullPointerException(\"Filter is null\");\r\n    }\r\n    if (n == filters.length) {\r\n        FilterConfigImpl[] newFilters = new FilterConfigImpl[n + INCREMENT];\r\n        System.arraycopy(filters, 0, newFilters, 0, n);\r\n        filters = newFilters;\r\n    }\r\n    filters[n++] = filterConfig;\r\n}"
}, {
	"Path": "org.bitcoinj.core.ECKey.encrypt",
	"Comment": "create an encrypted private key with the keycrypter and the aes key supplied.this method returns a new encrypted key and leaves the original unchanged.",
	"Method": "ECKey encrypt(KeyCrypter keyCrypter,KeyParameter aesKey){\r\n    checkNotNull(keyCrypter);\r\n    final byte[] privKeyBytes = getPrivKeyBytes();\r\n    EncryptedData encryptedPrivateKey = keyCrypter.encrypt(privKeyBytes, aesKey);\r\n    ECKey result = ECKey.fromEncrypted(encryptedPrivateKey, keyCrypter, getPubKey());\r\n    result.setCreationTimeSeconds(creationTimeSeconds);\r\n    return result;\r\n}"
}, {
	"Path": "org.bitcoinj.core.Utils.setMockSleep",
	"Comment": "enable or disable mock sleep.if enabled, set mock time to current time.",
	"Method": "void setMockSleep(boolean isEnable){\r\n    if (isEnable) {\r\n        mockSleepQueue = new ArrayBlockingQueue(1);\r\n        mockTime = new Date(System.currentTimeMillis());\r\n    } else {\r\n        mockSleepQueue = null;\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.KeyChainGroup.isMarried",
	"Comment": "whether the active keychain is married.a keychain is married when it vends p2sh addressesfrom multiple keychains in a multisig relationship.",
	"Method": "boolean isMarried(){\r\n    return !chains.isEmpty() && getActiveKeyChain().isMarried();\r\n}"
}, {
	"Path": "problems.easy.LongestCommonPrefix.longestCommonPrefix",
	"Comment": "simple approach to compare first, second, ... elements of every element in array with first element.if any string with not equal character found, return prefix.",
	"Method": "String longestCommonPrefix(String[] strs){\r\n    if (strs.length == 0)\r\n        return \"\";\r\n    if (strs.length == 1)\r\n        return strs[0];\r\n    int len = strs[0].length();\r\n    int i = 0;\r\n    for (; i < len; i++) {\r\n        for (int j = 1; j < strs.length; j++) {\r\n            if (i == strs[j].length() || strs[0].charAt(i) != strs[j].charAt(i))\r\n                return strs[0].substring(0, i);\r\n        }\r\n    }\r\n    return strs[0].substring(0, i);\r\n}"
}, {
	"Path": "io.aeron.ChannelUri.get",
	"Comment": "get the value for a given parameter key or the default value provided if the key does not exist.",
	"Method": "String get(String key,String get,String key,String defaultValue){\r\n    final String value = params.get(key);\r\n    if (null != value) {\r\n        return value;\r\n    }\r\n    return defaultValue;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.findKeyFromPubKey",
	"Comment": "locates a keypair from the basickeychain given the raw public key bytes.",
	"Method": "ECKey findKeyFromPubKey(byte[] pubkey){\r\n    keyChainGroupLock.lock();\r\n    try {\r\n        return keyChainGroup.findKeyFromPubKey(pubkey);\r\n    } finally {\r\n        keyChainGroupLock.unlock();\r\n    }\r\n}"
}, {
	"Path": "problems.medium.BSTSequences.getSequences",
	"Comment": "solution is simple. do level order traversal in binary search tree, and for each level nodes get allpossible permutations to make new lists",
	"Method": "List<List<Integer>> getSequences(TreeNode root){\r\n    List<List<Integer>> lists = new ArrayList();\r\n    if (root == null)\r\n        return lists;\r\n    List<Integer> list = new ArrayList();\r\n    list.add(root.val);\r\n    lists.add(list);\r\n    Queue<TreeNode> levelNodes = new LinkedList();\r\n    levelNodes.add(root);\r\n    int level = 1;\r\n    while (!levelNodes.isEmpty()) {\r\n        TreeNode node = levelNodes.remove();\r\n        level--;\r\n        if (node.left != null)\r\n            levelNodes.add(node.left);\r\n        if (node.right != null)\r\n            levelNodes.add(node.right);\r\n        if (level == 0 && !levelNodes.isEmpty()) {\r\n            List<List<Integer>> perms = new ArrayList();\r\n            getPermutations(new ArrayList(levelNodes), perms, 0);\r\n            List<List<Integer>> lists2 = new ArrayList();\r\n            for (List<Integer> integers : lists) {\r\n                for (List<Integer> perm : perms) {\r\n                    List<Integer> newLevel = new ArrayList();\r\n                    newLevel.addAll(integers);\r\n                    newLevel.addAll(perm);\r\n                    lists2.add(newLevel);\r\n                }\r\n            }\r\n            lists = lists2;\r\n        }\r\n    }\r\n    return lists;\r\n}"
}, {
	"Path": "org.bitcoinj.utils.BtcFormat.equals",
	"Comment": "return true if the given object is equivalent to this one. formatters for different locales will never be equal, even if they behave identically.",
	"Method": "boolean equals(Object o){\r\n    if (o == this)\r\n        return true;\r\n    if (!(o instanceof BtcFormat))\r\n        return false;\r\n    BtcFormat other = (BtcFormat) o;\r\n    return other.pattern().equals(pattern()) && other.symbols().equals(symbols()) && other.minimumFractionDigits == minimumFractionDigits;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.addScriptChangeEventListener",
	"Comment": "adds an event listener object. methods on this object are called when scriptswatched by this wallet change. the listener is executed by the given executor.",
	"Method": "void addScriptChangeEventListener(Executor executor,ScriptsChangeEventListener listener){\r\n    scriptChangeListeners.add(new ListenerRegistration(listener, executor));\r\n}"
}, {
	"Path": "org.bitcoinj.core.ECKey.decrypt",
	"Comment": "create a decrypted private key with aes key. note that if the aes key is wrong, thishas some chance of throwing keycrypterexception due to the corrupted padding that will result, but it can alsojust yield a garbage key.",
	"Method": "ECKey decrypt(KeyCrypter keyCrypter,KeyParameter aesKey,ECKey decrypt,KeyParameter aesKey){\r\n    final KeyCrypter crypter = getKeyCrypter();\r\n    if (crypter == null)\r\n        throw new KeyCrypterException(\"No key crypter available\");\r\n    return decrypt(crypter, aesKey);\r\n}"
}, {
	"Path": "problems.medium.CoinChange.coinChange2",
	"Comment": "this is brute force accepted solution with a lot of pruning. in most cases, this almost exponential solution is not accepted idea is generating all possible permutations and pruning by avoiding some cases",
	"Method": "int coinChange2(int[] a,int n){\r\n    if (a == null || a.length == 0)\r\n        return -1;\r\n    Arrays.sort(a);\r\n    findMinRecursive(a, n, a.length - 1, 0);\r\n    return count == Integer.MAX_VALUE ? -1 : count;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.BasicKeyChain.fromProtobufUnencrypted",
	"Comment": "returns a new basickeychain that contains all basic, original type keys extracted from the list. unrecognisedkey types are ignored.",
	"Method": "BasicKeyChain fromProtobufUnencrypted(List<Protos.Key> keys){\r\n    BasicKeyChain chain = new BasicKeyChain();\r\n    chain.deserializeFromProtobuf(keys);\r\n    return chain;\r\n}"
}, {
	"Path": "com.github.pedrovgs.problem53.CompressString.compressRecursive",
	"Comment": "tail recursive solution to this problem. the complexity order in time and space terms of thisrecursive version is the same than te previous one.",
	"Method": "String compressRecursive(String src){\r\n    validateInput(src);\r\n    if (src.length() <= 1) {\r\n        return src;\r\n    }\r\n    return compressRecursiveInner(src, new StringBuilder(), 1, src.charAt(0), 1);\r\n}"
}, {
	"Path": "org.knowm.xchange.wex.v3.service.WexTradeServiceRaw.getBTCETransHistory",
	"Comment": "get map of transaction history from wex exchange. all parameters are nullable",
	"Method": "Map<Long, WexTransHistoryResult> getBTCETransHistory(Long from,Long count,Long fromId,Long endId,WexAuthenticated.SortOrder order,Long since,Long end){\r\n    WexTransHistoryReturn btceTransHistory = btce.TransHistory(apiKey, signatureCreator, exchange.getNonceFactory(), from, count, fromId, endId, order, since, end);\r\n    String error = btceTransHistory.getError();\r\n    if (MSG_NO_TRADES.equals(error)) {\r\n        return Collections.emptyMap();\r\n    }\r\n    checkResult(btceTransHistory);\r\n    return btceTransHistory.getReturnValue();\r\n}"
}, {
	"Path": "io.aeron.cluster.service.ServiceHeartbeat.allocate",
	"Comment": "allocate a counter to represent the heartbeat of a clustered service.",
	"Method": "Counter allocate(Aeron aeron,MutableDirectBuffer tempBuffer,int serviceId){\r\n    tempBuffer.putInt(SERVICE_ID_OFFSET, serviceId);\r\n    final int labelOffset = BitUtil.align(KEY_LENGTH, SIZE_OF_INT);\r\n    int labelLength = 0;\r\n    labelLength += tempBuffer.putStringWithoutLengthAscii(labelOffset + labelLength, NAME);\r\n    labelLength += tempBuffer.putIntAscii(labelOffset + labelLength, serviceId);\r\n    return aeron.addCounter(SERVICE_HEARTBEAT_TYPE_ID, tempBuffer, 0, KEY_LENGTH, tempBuffer, labelOffset, labelLength);\r\n}"
}, {
	"Path": "io.aeron.cluster.ClusterMember.encodeAsString",
	"Comment": "encode member details from a cluster members array to a string.",
	"Method": "String encodeAsString(ClusterMember[] clusterMembers){\r\n    final StringBuilder builder = new StringBuilder();\r\n    for (int i = 0, length = clusterMembers.length; i < length; i++) {\r\n        final ClusterMember member = clusterMembers[i];\r\n        builder.append(member.id()).append(',').append(member.endpointsDetail());\r\n        if ((length - 1) != i) {\r\n            builder.append('|');\r\n        }\r\n    }\r\n    return builder.toString();\r\n}"
}, {
	"Path": "org.bitcoinj.kits.WalletAppKit.setAutoSave",
	"Comment": "if true, the wallet will save itself to disk automatically whenever it changes.",
	"Method": "WalletAppKit setAutoSave(boolean value){\r\n    checkState(state() == State.NEW, \"Cannot call after startup\");\r\n    useAutoSave = value;\r\n    return this;\r\n}"
}, {
	"Path": "org.bitcoinj.core.Block.addCoinbaseTransaction",
	"Comment": "adds a coinbase transaction to the block. this exists for unit tests.",
	"Method": "void addCoinbaseTransaction(byte[] pubKeyTo,Coin value,int height){\r\n    unCacheTransactions();\r\n    transactions = new ArrayList();\r\n    Transaction coinbase = new Transaction(params);\r\n    final ScriptBuilder inputBuilder = new ScriptBuilder();\r\n    if (height >= Block.BLOCK_HEIGHT_GENESIS) {\r\n        inputBuilder.number(height);\r\n    }\r\n    inputBuilder.data(new byte[] { (byte) txCounter, (byte) (txCounter++ >> 8) });\r\n    coinbase.addInput(new TransactionInput(params, coinbase, inputBuilder.build().getProgram()));\r\n    coinbase.addOutput(new TransactionOutput(params, coinbase, value, ScriptBuilder.createOutputScript(ECKey.fromPublicOnly(pubKeyTo)).getProgram()));\r\n    transactions.add(coinbase);\r\n    coinbase.setParent(this);\r\n    coinbase.length = coinbase.unsafeBitcoinSerialize().length;\r\n    adjustLength(transactions.size(), coinbase.length);\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.BasicKeyChain.importKey",
	"Comment": "imports a key to the key chain. if key is present in the key chain, ignore it.",
	"Method": "void importKey(ECKey key){\r\n    lock.lock();\r\n    try {\r\n        checkKeyEncryptionStateMatches(key);\r\n        if (hasKey(key))\r\n            return;\r\n        importKeyLocked(key);\r\n        queueOnKeysAdded(ImmutableList.of(key));\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.StoredBlock.build",
	"Comment": "creates a new storedblock, calculating the additional fields by adding to the values in this block.",
	"Method": "StoredBlock build(Block block){\r\n    BigInteger chainWork = this.chainWork.add(block.getWork());\r\n    int height = this.height + 1;\r\n    return new StoredBlock(block, chainWork, height);\r\n}"
}, {
	"Path": "org.bitcoinj.store.DatabaseFullPrunedBlockStore.getTransactionOutputSelectSQL",
	"Comment": "get the sql to select the transaction outputs for a given address.",
	"Method": "String getTransactionOutputSelectSQL(){\r\n    return SELECT_TRANSACTION_OUTPUTS_SQL;\r\n}"
}, {
	"Path": "problems.easy.ContainsDuplicate.containsDuplicate",
	"Comment": "in iteration of array we keep track of elements and in each iteration we need to check if this elements ismet already.",
	"Method": "boolean containsDuplicate(int[] nums){\r\n    Set<Integer> set = new HashSet();\r\n    for (int i : nums) {\r\n        if (!set.add(i))\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.bitcoinj.core.ECKey.isCompressed",
	"Comment": "returns whether this key is using the compressed form or not. compressed pubkeys are only 33 bytes, not 64.",
	"Method": "boolean isCompressed(){\r\n    return pub.isCompressed();\r\n}"
}, {
	"Path": "org.atmosphere.runtime.AtmosphereResourceStateRecoveryTest.restoreStateTest",
	"Comment": "this test is no longer working since isclosedbyclient changes the behavior.",
	"Method": "void restoreStateTest(){\r\n    recovery.configure(config);\r\n    recovery.inspect(r);\r\n    config.getBroadcasterFactory().lookup(\"/1\", true).addAtmosphereResource(r);\r\n    config.getBroadcasterFactory().lookup(\"/2\", true).addAtmosphereResource(r);\r\n    config.getBroadcasterFactory().lookup(\"/3\", true).addAtmosphereResource(r);\r\n    config.getBroadcasterFactory().lookup(\"/4\", true).addAtmosphereResource(r);\r\n    r.suspend();\r\n    r.close();\r\n    r.getBroadcaster().removeAtmosphereResource(r);\r\n    r.suspend();\r\n    assertEquals(recovery.states().size(), 1);\r\n    assertEquals(recovery.states().get(r.uuid()).ids().size(), 5);\r\n}"
}, {
	"Path": "org.bitcoinj.utils.Fiat.isPositive",
	"Comment": "returns true if and only if this instance represents a monetary value greater than zero, otherwise false.",
	"Method": "boolean isPositive(){\r\n    return signum() == 1;\r\n}"
}, {
	"Path": "org.bitcoinj.core.Block.getPrevBlockHash",
	"Comment": "returns the hash of the previous block in the chain, as defined by the block header.",
	"Method": "Sha256Hash getPrevBlockHash(){\r\n    return prevBlockHash;\r\n}"
}, {
	"Path": "org.bitcoinj.core.Base58.decode",
	"Comment": "decodes the given base58 string into the original data bytes.",
	"Method": "byte[] decode(String input){\r\n    if (input.length() == 0) {\r\n        return new byte[0];\r\n    }\r\n    byte[] input58 = new byte[input.length()];\r\n    for (int i = 0; i < input.length(); ++i) {\r\n        char c = input.charAt(i);\r\n        int digit = c < 128 ? INDEXES[c] : -1;\r\n        if (digit < 0) {\r\n            throw new AddressFormatException.InvalidCharacter(c, i);\r\n        }\r\n        input58[i] = (byte) digit;\r\n    }\r\n    int zeros = 0;\r\n    while (zeros < input58.length && input58[zeros] == 0) {\r\n        ++zeros;\r\n    }\r\n    byte[] decoded = new byte[input.length()];\r\n    int outputStart = decoded.length;\r\n    for (int inputStart = zeros; inputStart < input58.length; ) {\r\n        decoded[--outputStart] = divmod(input58, inputStart, 58, 256);\r\n        if (input58[inputStart] == 0) {\r\n            ++inputStart;\r\n        }\r\n    }\r\n    while (outputStart < decoded.length && decoded[outputStart] == 0) {\r\n        ++outputStart;\r\n    }\r\n    return Arrays.copyOfRange(decoded, outputStart - zeros, decoded.length);\r\n}"
}, {
	"Path": "io.aeron.archive.client.ArchiveProxy.findLastMatchingRecording",
	"Comment": "truncate a stopped recording to a given position that is less than the stopped position. the provided positionmust be on a fragment boundary. truncating a recording to the start position effectively deletes the recording.find the last recording that matches the given criteria.",
	"Method": "boolean findLastMatchingRecording(long minRecordingId,String channel,int streamId,int sessionId,long correlationId,long controlSessionId){\r\n    findLastMatchingRecordingRequestEncoder.wrapAndApplyHeader(buffer, 0, messageHeaderEncoder).controlSessionId(controlSessionId).correlationId(correlationId).minRecordingId(minRecordingId).sessionId(sessionId).streamId(streamId).channel(channel);\r\n    return offer(findLastMatchingRecordingRequestEncoder.encodedLength());\r\n}"
}, {
	"Path": "org.atmosphere.handler.ReflectorServletProcessor.setFilterClassName",
	"Comment": "add a filterclass. since we are using reflection to call this method,what we are really doing is addfilterclass.",
	"Method": "void setFilterClassName(String filterClass){\r\n    if (filterClass == null)\r\n        return;\r\n    filtersClassAndNames.put(filterClass, filterClass);\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.DeterministicKeyChain.getKeyByPath",
	"Comment": "returns the deterministic key for the given absolute path in the hierarchy, optionally creating it",
	"Method": "DeterministicKey getKeyByPath(ChildNumber path,DeterministicKey getKeyByPath,List<ChildNumber> path,DeterministicKey getKeyByPath,List<ChildNumber> path,boolean create){\r\n    return hierarchy.get(path, false, create);\r\n}"
}, {
	"Path": "org.bitcoinj.core.NetworkParameters.getId",
	"Comment": "a java package style string acting as unique id for these parameters",
	"Method": "String getId(){\r\n    return id;\r\n}"
}, {
	"Path": "org.bitcoinj.crypto.ChildNumber.getI",
	"Comment": "returns the uint32 encoded form of the path element, including the most significant bit.",
	"Method": "int getI(){\r\n    return i;\r\n}"
}, {
	"Path": "org.bitcoinj.testing.FakeTxBuilder.createFakeTxWithChangeAddress",
	"Comment": "create a fake tx of sufficient realism to exercise the unit tests. two outputs, one to us, one to somewhereelse to simulate change. there is one random input.",
	"Method": "Transaction createFakeTxWithChangeAddress(NetworkParameters params,Coin value,Address to,Address changeOutput){\r\n    Transaction t = new Transaction(params);\r\n    TransactionOutput outputToMe = new TransactionOutput(params, t, value, to);\r\n    t.addOutput(outputToMe);\r\n    TransactionOutput change = new TransactionOutput(params, t, valueOf(1, 11), changeOutput);\r\n    t.addOutput(change);\r\n    Transaction prevTx = new Transaction(params);\r\n    TransactionOutput prevOut = new TransactionOutput(params, prevTx, value, to);\r\n    prevTx.addOutput(prevOut);\r\n    t.addInput(prevOut).setScriptSig(ScriptBuilder.createInputScript(TransactionSignature.dummy()));\r\n    return roundTripTransaction(params, t);\r\n}"
}, {
	"Path": "com.github.pedrovgs.problem9.Factorial.getTailRecursive",
	"Comment": "tail recursive implementation of the previous algorithm. the complexity order in time andspace terms is the same but the resources needed by the cpu to execute this method is lowerbecause this implementation is tail recursive.",
	"Method": "int getTailRecursive(int n){\r\n    validateInput(n);\r\n    return getTailRecursiveInner(n, 1);\r\n}"
}, {
	"Path": "org.bitcoinj.core.Block.guessTransactionsLength",
	"Comment": "provides a reasonable guess at the byte length of the transactions part of the block.the returned value will be accurate in 99% of cases and in those cases where not will probably slightlyoversize.this is used to preallocate the underlying byte array for a bytearrayoutputstream.if the size is under thereal value the only penalty is resizing of the underlying byte array.",
	"Method": "int guessTransactionsLength(){\r\n    if (transactionBytesValid)\r\n        return payload.length - HEADER_SIZE;\r\n    if (transactions == null)\r\n        return 0;\r\n    int len = VarInt.sizeOf(transactions.size());\r\n    for (Transaction tx : transactions) {\r\n        len += tx.length == UNKNOWN_LENGTH ? 255 : tx.length;\r\n    }\r\n    return len;\r\n}"
}, {
	"Path": "org.bitcoinj.core.BitcoinSerializer.makeAlertMessage",
	"Comment": "make an alert message from the payload. extension point for alternativeserialization format support.",
	"Method": "Message makeAlertMessage(byte[] payloadBytes){\r\n    return new AlertMessage(params, payloadBytes);\r\n}"
}, {
	"Path": "org.bitcoinj.protocols.channels.PaymentChannelClientConnection.settle",
	"Comment": "closes the connection, notifying the server it should settle the channel by broadcasting the most recent paymenttransaction.",
	"Method": "void settle(){\r\n    try {\r\n        channelClient.settle();\r\n    } catch (IllegalStateException e) {\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.crypto.TransactionSignature.calcSigHashValue",
	"Comment": "calculates the byte used in the protocol to represent the combination of mode and anyonecanpay.",
	"Method": "int calcSigHashValue(Transaction.SigHash mode,boolean anyoneCanPay){\r\n    Preconditions.checkArgument(SigHash.ALL == mode || SigHash.NONE == mode || SigHash.SINGLE == mode);\r\n    int sighashFlags = mode.value;\r\n    if (anyoneCanPay)\r\n        sighashFlags |= Transaction.SigHash.ANYONECANPAY.value;\r\n    return sighashFlags;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.removeKeyChainEventListener",
	"Comment": "removes the given event listener object. returns true if the listener was removed, false if that listenerwas never added.",
	"Method": "boolean removeKeyChainEventListener(KeyChainEventListener listener){\r\n    return keyChainGroup.removeEventListener(listener);\r\n}"
}, {
	"Path": "ds.HashedArrayTree.getLeaf",
	"Comment": "returns available leaf to insert data.if current leaf is already full,creates new leaf and returns it",
	"Method": "Object[] getLeaf(){\r\n    if (jPointer >= data.length) {\r\n        data[++iPointer] = new Object[data.length];\r\n        jPointer = 0;\r\n    }\r\n    return data[iPointer];\r\n}"
}, {
	"Path": "org.bitcoinj.crypto.TransactionSignature.encodeToBitcoin",
	"Comment": "what we get back from the signer are the two components of a signature, r and s. to get a flat byte streamof the type used by bitcoin we have to encode them using der encoding, which is just a way to pack the twocomponents into a structure, and then we append a byte to the end for the sighash flags.",
	"Method": "byte[] encodeToBitcoin(){\r\n    try {\r\n        ByteArrayOutputStream bos = derByteStream();\r\n        bos.write(sighashFlags);\r\n        return bos.toByteArray();\r\n    } catch (IOException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.Sha256Hash.twiceOf",
	"Comment": "creates a new instance containing the hash of the calculated hash of the given bytes.",
	"Method": "Sha256Hash twiceOf(byte[] contents){\r\n    return wrap(hashTwice(contents));\r\n}"
}, {
	"Path": "org.bitcoinj.protocols.channels.StoredPaymentChannelClientStates.getChannel",
	"Comment": "finds a channel with the given id and contract hash and returns it, or returns null.",
	"Method": "StoredClientChannel getChannel(Sha256Hash id,Sha256Hash contractHash){\r\n    lock.lock();\r\n    try {\r\n        Set<StoredClientChannel> setChannels = mapChannels.get(id);\r\n        for (StoredClientChannel channel : setChannels) {\r\n            if (channel.contract.getHash().equals(contractHash))\r\n                return channel;\r\n        }\r\n        return null;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "io.aeron.Publication.position",
	"Comment": "get the current position to which the publication has advanced for this stream.",
	"Method": "long position(){\r\n    if (isClosed) {\r\n        return CLOSED;\r\n    }\r\n    final long rawTail = rawTailVolatile(logMetaDataBuffer);\r\n    final int termOffset = termOffset(rawTail, termBufferLength);\r\n    return computePosition(termId(rawTail), termOffset, positionBitsToShift, initialTermId);\r\n}"
}, {
	"Path": "org.bitcoinj.uri.BitcoinURI.putWithValidation",
	"Comment": "put the value against the key in the map checking for duplication. this avoids address field overwrite etc.",
	"Method": "void putWithValidation(String key,Object value){\r\n    if (parameterMap.containsKey(key)) {\r\n        throw new BitcoinURIParseException(String.format(Locale.US, \"'%s' is duplicated, URI is invalid\", key));\r\n    } else {\r\n        parameterMap.put(key, value);\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.SegwitAddress.getWitnessVersion",
	"Comment": "returns the witness version in decoded form. only version 0 is in use right now.",
	"Method": "int getWitnessVersion(){\r\n    return bytes[0] & 0xff;\r\n}"
}, {
	"Path": "org.bitcoinj.core.BloomFilter.getUpdateFlag",
	"Comment": "the update flag controls how application of the filter to a block modifies the filter. see the enum javadocsfor information on what occurs and when.",
	"Method": "BloomUpdate getUpdateFlag(){\r\n    if (nFlags == 0)\r\n        return BloomUpdate.UPDATE_NONE;\r\n    else if (nFlags == 1)\r\n        return BloomUpdate.UPDATE_ALL;\r\n    else if (nFlags == 2)\r\n        return BloomUpdate.UPDATE_P2PUBKEY_ONLY;\r\n    else\r\n        throw new IllegalStateException(\"Unknown flag combination\");\r\n}"
}, {
	"Path": "org.bitcoinj.protocols.channels.StoredPaymentChannelClientStates.getBalanceForServer",
	"Comment": "returns the outstanding amount of money sent back to us for all channels to this server added together.",
	"Method": "Coin getBalanceForServer(Sha256Hash id){\r\n    Coin balance = Coin.ZERO;\r\n    lock.lock();\r\n    try {\r\n        Set<StoredClientChannel> setChannels = mapChannels.get(id);\r\n        for (StoredClientChannel channel : setChannels) {\r\n            synchronized (channel) {\r\n                if (channel.close != null)\r\n                    continue;\r\n                balance = balance.add(channel.valueToMe);\r\n            }\r\n        }\r\n        return balance;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "commons.validator.routines.UrlValidator.getInstance",
	"Comment": "returns the singleton instance of this class with default schemes and options.",
	"Method": "UrlValidator getInstance(){\r\n    return DEFAULT_URL_VALIDATOR;\r\n}"
}, {
	"Path": "io.aeron.ChannelUriStringBuilder.termId",
	"Comment": "set the current term id at which a publication will start. this when combined with the initial term canestablish a starting position.",
	"Method": "ChannelUriStringBuilder termId(Integer termId,Integer termId){\r\n    return termId;\r\n}"
}, {
	"Path": "io.aeron.cluster.service.ServiceHeartbeat.findCounterId",
	"Comment": "find the active counter id for heartbeat of a given service id.",
	"Method": "int findCounterId(CountersReader counters,int serviceId){\r\n    final DirectBuffer buffer = counters.metaDataBuffer();\r\n    for (int i = 0, size = counters.maxCounterId(); i < size; i++) {\r\n        if (counters.getCounterState(i) == RECORD_ALLOCATED) {\r\n            final int recordOffset = CountersReader.metaDataOffset(i);\r\n            if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == SERVICE_HEARTBEAT_TYPE_ID && buffer.getInt(recordOffset + KEY_OFFSET + SERVICE_ID_OFFSET) == serviceId) {\r\n                return i;\r\n            }\r\n        }\r\n    }\r\n    return NULL_COUNTER_ID;\r\n}"
}, {
	"Path": "org.bitcoinj.protocols.channels.ChannelConnectionTest.data",
	"Comment": "we use parameterized tests to run the channel connection tests with eachversion of the channel.",
	"Method": "Collection<PaymentChannelClient.DefaultClientChannelProperties> data(){\r\n    return Arrays.asList(new PaymentChannelClient.DefaultClientChannelProperties() {\r\n        @Override\r\n        public VersionSelector versionSelector() {\r\n            return VERSION_1;\r\n        }\r\n    }, new PaymentChannelClient.DefaultClientChannelProperties() {\r\n        @Override\r\n        public VersionSelector versionSelector() {\r\n            return VERSION_2_ALLOW_1;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.bitcoinj.protocols.channels.ChannelConnectionTest.data",
	"Comment": "we use parameterized tests to run the channel connection tests with eachversion of the channel.",
	"Method": "Collection<PaymentChannelClient.DefaultClientChannelProperties> data(){\r\n    return VERSION_1;\r\n}"
}, {
	"Path": "org.bitcoinj.protocols.channels.ChannelConnectionTest.data",
	"Comment": "we use parameterized tests to run the channel connection tests with eachversion of the channel.",
	"Method": "Collection<PaymentChannelClient.DefaultClientChannelProperties> data(){\r\n    return VERSION_2_ALLOW_1;\r\n}"
}, {
	"Path": "commons.validator.routines.CodeValidator.getMaxLength",
	"Comment": "return the maximum length of the code.n.b. optional, if less than zero themaximum length will not be checked.",
	"Method": "int getMaxLength(){\r\n    return maxLength;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.cleanup",
	"Comment": "clean up the wallet. currently, it only removes risky pending transaction from the wallet and only if theiroutputs have not been spent.",
	"Method": "void cleanup(){\r\n    lock.lock();\r\n    try {\r\n        boolean dirty = false;\r\n        for (Iterator<Transaction> i = pending.values().iterator(); i.hasNext(); ) {\r\n            Transaction tx = i.next();\r\n            if (isTransactionRisky(tx, null) && !acceptRiskyTransactions) {\r\n                log.debug(\"Found risky transaction {} in wallet during cleanup.\", tx.getHashAsString());\r\n                if (!tx.isAnyOutputSpent()) {\r\n                    for (TransactionInput input : tx.getInputs()) {\r\n                        TransactionOutput output = input.getConnectedOutput();\r\n                        if (output == null)\r\n                            continue;\r\n                        if (output.isMineOrWatched(this))\r\n                            checkState(myUnspents.add(output));\r\n                        input.disconnect();\r\n                    }\r\n                    for (TransactionOutput output : tx.getOutputs()) myUnspents.remove(output);\r\n                    i.remove();\r\n                    transactions.remove(tx.getHash());\r\n                    dirty = true;\r\n                    log.info(\"Removed transaction {} from pending pool during cleanup.\", tx.getHashAsString());\r\n                } else {\r\n                    log.info(\"Cannot remove transaction {} from pending pool during cleanup, as it's already spent partially.\", tx.getHashAsString());\r\n                }\r\n            }\r\n        }\r\n        if (dirty) {\r\n            isConsistentOrThrow();\r\n            saveLater();\r\n            if (log.isInfoEnabled())\r\n                log.info(\"Estimated balance is now: {}\", getBalance(BalanceType.ESTIMATED).toFriendlyString());\r\n        }\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.Coin.valueOf",
	"Comment": "convert an amount expressed in the way humans are used to into satoshis.",
	"Method": "Coin valueOf(long satoshis,Coin valueOf,int coins,int cents){\r\n    checkArgument(cents < 100);\r\n    checkArgument(cents >= 0);\r\n    checkArgument(coins >= 0);\r\n    final Coin coin = COIN.multiply(coins).add(CENT.multiply(cents));\r\n    return coin;\r\n}"
}, {
	"Path": "org.bitcoinj.core.PeerSocketHandler.close",
	"Comment": "closes the connection to the peer if one exists, or immediately closes the connection as soon as it opens",
	"Method": "void close(){\r\n    lock.lock();\r\n    try {\r\n        if (writeTarget == null) {\r\n            closePending = true;\r\n            return;\r\n        }\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n    writeTarget.closeConnection();\r\n}"
}, {
	"Path": "io.aeron.logbuffer.FrameDescriptor.isPaddingFrame",
	"Comment": "is the frame starting at the termoffset a padding frame at the end of a buffer?",
	"Method": "boolean isPaddingFrame(UnsafeBuffer buffer,int termOffset){\r\n    return buffer.getShort(typeOffset(termOffset)) == PADDING_FRAME_TYPE;\r\n}"
}, {
	"Path": "commons.validator.routines.checkdigit.ModulusCheckDigit.getModulus",
	"Comment": "return the modulus value this check digit routine is based on.",
	"Method": "int getModulus(){\r\n    return modulus;\r\n}"
}, {
	"Path": "org.bitcoinj.core.PeerGroup.removeOnTransactionBroadcastListener",
	"Comment": "the given event listener will no longer be called with events.",
	"Method": "boolean removeOnTransactionBroadcastListener(OnTransactionBroadcastListener listener){\r\n    boolean result = ListenerRegistration.removeFromList(listener, peersTransactionBroadastEventListeners);\r\n    for (Peer peer : getConnectedPeers()) peer.removeOnTransactionBroadcastListener(listener);\r\n    for (Peer peer : getPendingPeers()) peer.removeOnTransactionBroadcastListener(listener);\r\n    return result;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.KeyChainGroup.importKeysAndEncrypt",
	"Comment": "imports the given unencrypted keys into the basic chain, encrypting them along the way with the given key.",
	"Method": "int importKeysAndEncrypt(List<ECKey> keys,KeyParameter aesKey){\r\n    checkState(keyCrypter != null, \"Not encrypted\");\r\n    LinkedList<ECKey> encryptedKeys = Lists.newLinkedList();\r\n    for (ECKey key : keys) {\r\n        if (key.isEncrypted())\r\n            throw new IllegalArgumentException(\"Cannot provide already encrypted keys\");\r\n        encryptedKeys.add(key.encrypt(keyCrypter, aesKey));\r\n    }\r\n    return importKeys(encryptedKeys);\r\n}"
}, {
	"Path": "org.bitcoinj.core.VarInt.getOriginalSizeInBytes",
	"Comment": "returns the original number of bytes used to encode the value if it wasdeserialized from a byte array, or the minimum encoded size if it was not.",
	"Method": "int getOriginalSizeInBytes(){\r\n    return originallyEncodedSize;\r\n}"
}, {
	"Path": "io.aeron.logbuffer.LogBufferDescriptor.indexByTermCount",
	"Comment": "determine the partition index based on number of terms that have passed.",
	"Method": "int indexByTermCount(long termCount){\r\n    return (int) (termCount % PARTITION_COUNT);\r\n}"
}, {
	"Path": "org.atmosphere.util.uri.UriTemplate.createURIWithStringValues",
	"Comment": "construct a uri from the component parts each of which may containtemplate variables.",
	"Method": "String createURIWithStringValues(String scheme,String userInfo,String host,String port,String path,String query,String fragment,Map<String, ? extends Object> values,boolean encode,String createURIWithStringValues,String scheme,String authority,String userInfo,String host,String port,String path,String query,String fragment,Map<String, ? extends Object> values,boolean encode,String createURIWithStringValues,String scheme,String userInfo,String host,String port,String path,String query,String fragment,String[] values,boolean encode,String createURIWithStringValues,String scheme,String authority,String userInfo,String host,String port,String path,String query,String fragment,String[] values,boolean encode){\r\n    final Map<String, String> mapValues = new HashMap<String, String>();\r\n    final StringBuilder sb = new StringBuilder();\r\n    int offset = 0;\r\n    if (scheme != null) {\r\n        offset = createURIComponent(UriComponent.Type.SCHEME, scheme, values, offset, false, mapValues, sb);\r\n        sb.append(':');\r\n    }\r\n    if (userInfo != null || host != null || port != null) {\r\n        sb.append(\"//\");\r\n        if (userInfo != null && userInfo.length() > 0) {\r\n            offset = createURIComponent(UriComponent.Type.USER_INFO, userInfo, values, offset, encode, mapValues, sb);\r\n            sb.append('@');\r\n        }\r\n        if (host != null) {\r\n            offset = createURIComponent(UriComponent.Type.HOST, host, values, offset, encode, mapValues, sb);\r\n        }\r\n        if (port != null && port.length() > 0) {\r\n            sb.append(':');\r\n            offset = createURIComponent(UriComponent.Type.PORT, port, values, offset, false, mapValues, sb);\r\n        }\r\n    } else if (authority != null) {\r\n        sb.append(\"//\");\r\n        offset = createURIComponent(UriComponent.Type.AUTHORITY, authority, values, offset, encode, mapValues, sb);\r\n    }\r\n    if (path != null)\r\n        offset = createURIComponent(UriComponent.Type.PATH, path, values, offset, encode, mapValues, sb);\r\n    if (query != null && query.length() > 0) {\r\n        sb.append('?');\r\n        offset = createURIComponent(UriComponent.Type.QUERY_PARAM, query, values, offset, encode, mapValues, sb);\r\n    }\r\n    if (fragment != null && fragment.length() > 0) {\r\n        sb.append('#');\r\n        offset = createURIComponent(UriComponent.Type.FRAGMENT, fragment, values, offset, encode, mapValues, sb);\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.mobsandgeeks.saripaar.tests.UnorderedValidateTest.testField",
	"Comment": "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ private methods~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
	"Method": "void testField(int viewId,String textToType,String fieldToIgnore){\r\n    List<String> words = new ArrayList<String>(Arrays.asList(Constants.FIELD_NAME, Constants.FIELD_ADDRESS, Constants.FIELD_EMAIL, Constants.FIELD_PHONE));\r\n    boolean removed = words.remove(fieldToIgnore);\r\n    if (!removed) {\r\n        String message = String.format(\"Words does not contain '%s'.\", fieldToIgnore);\r\n        throw new IllegalArgumentException(message);\r\n    }\r\n    EspressoHelper.type(viewId, textToType);\r\n    EspressoHelper.clickView(R.id.saripaarButton);\r\n    checkForText(words);\r\n}"
}, {
	"Path": "io.aeron.logbuffer.Header.position",
	"Comment": "get the current position to which the image has advanced on reading this message.",
	"Method": "long position(){\r\n    final int resultingOffset = BitUtil.align(termOffset() + frameLength(), FRAME_ALIGNMENT);\r\n    return computePosition(termId(), resultingOffset, positionBitsToShift, initialTermId);\r\n}"
}, {
	"Path": "org.bitcoinj.core.PeerGroup.removeConnectedEventListener",
	"Comment": "the given event listener will no longer be called with events.",
	"Method": "boolean removeConnectedEventListener(PeerConnectedEventListener listener){\r\n    boolean result = ListenerRegistration.removeFromList(listener, peerConnectedEventListeners);\r\n    for (Peer peer : getConnectedPeers()) peer.removeConnectedEventListener(listener);\r\n    for (Peer peer : getPendingPeers()) peer.removeConnectedEventListener(listener);\r\n    return result;\r\n}"
}, {
	"Path": "io.aeron.logbuffer.ExclusiveBufferClaim.headerType",
	"Comment": "set the value of the header type field. the lower 16 bits are valid.",
	"Method": "ExclusiveBufferClaim headerType(int type){\r\n    buffer.putShort(TYPE_FIELD_OFFSET, (short) type, LITTLE_ENDIAN);\r\n    return this;\r\n}"
}, {
	"Path": "org.bitcoinj.core.PeerGroup.setRequiredServices",
	"Comment": "convenience for connecting only to peers that can serve specific services. it will configure suitable peerdiscoveries.",
	"Method": "void setRequiredServices(long requiredServices){\r\n    lock.lock();\r\n    try {\r\n        this.requiredServices = requiredServices;\r\n        peerDiscoverers.clear();\r\n        addPeerDiscovery(MultiplexingDiscovery.forServices(params, requiredServices));\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "io.aeron.ChannelUriStringBuilder.initialPosition",
	"Comment": "initialise a channel for restarting a publication at a given position.",
	"Method": "ChannelUriStringBuilder initialPosition(long position,int initialTermId,int termLength){\r\n    final int bitsToShift = LogBufferDescriptor.positionBitsToShift(termLength);\r\n    this.initialTermId = initialTermId;\r\n    this.termId = LogBufferDescriptor.computeTermIdFromPosition(position, bitsToShift, initialTermId);\r\n    this.termOffset = (int) (position & (termLength - 1));\r\n    this.termLength = termLength;\r\n    return this;\r\n}"
}, {
	"Path": "org.bitcoinj.core.Block.verify",
	"Comment": "verifies both the header and that the transactions hash to the merkle root.",
	"Method": "void verify(int height,EnumSet<VerifyFlag> flags){\r\n    verifyHeader();\r\n    verifyTransactions(height, flags);\r\n}"
}, {
	"Path": "io.aeron.status.ReadableCounter.getWeak",
	"Comment": "get the value of the counter using weak ordering semantics. this is the same a standard read of a field.",
	"Method": "long getWeak(){\r\n    return UnsafeAccess.UNSAFE.getLong(buffer, addressOffset);\r\n}"
}, {
	"Path": "org.bitcoinj.core.NetworkParameters.fromID",
	"Comment": "returns the network parameters for the given string id or null if not recognized.",
	"Method": "NetworkParameters fromID(String id){\r\n    if (id.equals(ID_MAINNET)) {\r\n        return MainNetParams.get();\r\n    } else if (id.equals(ID_TESTNET)) {\r\n        return TestNet3Params.get();\r\n    } else if (id.equals(ID_UNITTESTNET)) {\r\n        return UnitTestParams.get();\r\n    } else if (id.equals(ID_REGTEST)) {\r\n        return RegTestParams.get();\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.toString",
	"Comment": "formats the wallet as a human readable piece of text. intended for debugging, the format is not meant to bestable or human readable.",
	"Method": "String toString(String toString,boolean includePrivateKeys,boolean includeTransactions,boolean includeExtensions,AbstractBlockChain chain,String toString,boolean includePrivateKeys,KeyParameter aesKey,boolean includeTransactions,boolean includeExtensions,AbstractBlockChain chain){\r\n    lock.lock();\r\n    keyChainGroupLock.lock();\r\n    try {\r\n        StringBuilder builder = new StringBuilder();\r\n        Coin estimatedBalance = getBalance(BalanceType.ESTIMATED);\r\n        Coin availableBalance = getBalance(BalanceType.AVAILABLE_SPENDABLE);\r\n        builder.append(\"Wallet containing \").append(estimatedBalance.toFriendlyString()).append(\" (spendable: \").append(availableBalance.toFriendlyString()).append(\") in:\\n\");\r\n        builder.append(\"  \").append(pending.size()).append(\" pending transactions\\n\");\r\n        builder.append(\"  \").append(unspent.size()).append(\" unspent transactions\\n\");\r\n        builder.append(\"  \").append(spent.size()).append(\" spent transactions\\n\");\r\n        builder.append(\"  \").append(dead.size()).append(\" dead transactions\\n\");\r\n        final Date lastBlockSeenTime = getLastBlockSeenTime();\r\n        builder.append(\"Last seen best block: \").append(getLastBlockSeenHeight()).append(\" (\").append(lastBlockSeenTime == null ? \"time unknown\" : Utils.dateTimeFormat(lastBlockSeenTime)).append(\"): \").append(getLastBlockSeenHash()).append('\\n');\r\n        final KeyCrypter crypter = keyChainGroup.getKeyCrypter();\r\n        if (crypter != null)\r\n            builder.append(\"Encryption: \").append(crypter).append('\\n');\r\n        if (isWatching())\r\n            builder.append(\"Wallet is watching.\\n\");\r\n        builder.append(\"\\nKeys:\\n\");\r\n        builder.append(\"Earliest creation time: \").append(Utils.dateTimeFormat(getEarliestKeyCreationTime() * 1000)).append('\\n');\r\n        final Date keyRotationTime = getKeyRotationTime();\r\n        if (keyRotationTime != null)\r\n            builder.append(\"Key rotation time:      \").append(Utils.dateTimeFormat(keyRotationTime)).append('\\n');\r\n        builder.append(keyChainGroup.toString(includePrivateKeys, aesKey));\r\n        if (!watchedScripts.isEmpty()) {\r\n            builder.append(\"\\nWatched scripts:\\n\");\r\n            for (Script script : watchedScripts) {\r\n                builder.append(\"  \").append(script).append(\"\\n\");\r\n            }\r\n        }\r\n        if (includeTransactions) {\r\n            if (pending.size() > 0) {\r\n                builder.append(\"\\n>>> PENDING:\\n\");\r\n                toStringHelper(builder, pending, chain, Transaction.SORT_TX_BY_UPDATE_TIME);\r\n            }\r\n            if (unspent.size() > 0) {\r\n                builder.append(\"\\n>>> UNSPENT:\\n\");\r\n                toStringHelper(builder, unspent, chain, Transaction.SORT_TX_BY_HEIGHT);\r\n            }\r\n            if (spent.size() > 0) {\r\n                builder.append(\"\\n>>> SPENT:\\n\");\r\n                toStringHelper(builder, spent, chain, Transaction.SORT_TX_BY_HEIGHT);\r\n            }\r\n            if (dead.size() > 0) {\r\n                builder.append(\"\\n>>> DEAD:\\n\");\r\n                toStringHelper(builder, dead, chain, Transaction.SORT_TX_BY_UPDATE_TIME);\r\n            }\r\n        }\r\n        if (includeExtensions && extensions.size() > 0) {\r\n            builder.append(\"\\n>>> EXTENSIONS:\\n\");\r\n            for (WalletExtension extension : extensions.values()) {\r\n                builder.append(extension).append(\"\\n\\n\");\r\n            }\r\n        }\r\n        return builder.toString();\r\n    } finally {\r\n        keyChainGroupLock.unlock();\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "io.aeron.logbuffer.TermAppender.appendFragmentedMessage",
	"Comment": "append a fragmented message to the the term buffer.the message will be split up into fragments of mtu length minus header.",
	"Method": "int appendFragmentedMessage(HeaderWriter header,DirectBuffer buffer,int offset,int length,int maxPayloadLength,ReservedValueSupplier reservedValueSupplier,int activeTermId,int appendFragmentedMessage,HeaderWriter header,DirectBuffer bufferOne,int offsetOne,int lengthOne,DirectBuffer bufferTwo,int offsetTwo,int lengthTwo,int maxPayloadLength,ReservedValueSupplier reservedValueSupplier,int activeTermId,int appendFragmentedMessage,HeaderWriter header,DirectBufferVector[] vectors,int length,int maxPayloadLength,ReservedValueSupplier reservedValueSupplier,int activeTermId){\r\n    final int numMaxPayloads = length / maxPayloadLength;\r\n    final int remainingPayload = length % maxPayloadLength;\r\n    final int lastFrameLength = remainingPayload > 0 ? align(remainingPayload + HEADER_LENGTH, FRAME_ALIGNMENT) : 0;\r\n    final int requiredLength = (numMaxPayloads * (maxPayloadLength + HEADER_LENGTH)) + lastFrameLength;\r\n    final UnsafeBuffer termBuffer = this.termBuffer;\r\n    final int termLength = termBuffer.capacity();\r\n    final long rawTail = getAndAddRawTail(requiredLength);\r\n    final int termId = termId(rawTail);\r\n    final long termOffset = rawTail & 0xFFFF_FFFFL;\r\n    checkTerm(activeTermId, termId);\r\n    long resultingOffset = termOffset + requiredLength;\r\n    if (resultingOffset > termLength) {\r\n        resultingOffset = handleEndOfLogCondition(termBuffer, termOffset, header, termLength, termId);\r\n    } else {\r\n        int frameOffset = (int) termOffset;\r\n        byte flags = BEGIN_FRAG_FLAG;\r\n        int remaining = length;\r\n        int vectorIndex = 0;\r\n        int vectorOffset = 0;\r\n        do {\r\n            final int bytesToWrite = Math.min(remaining, maxPayloadLength);\r\n            final int frameLength = bytesToWrite + HEADER_LENGTH;\r\n            final int alignedLength = align(frameLength, FRAME_ALIGNMENT);\r\n            header.write(termBuffer, frameOffset, frameLength, termId);\r\n            int bytesWritten = 0;\r\n            int payloadOffset = frameOffset + HEADER_LENGTH;\r\n            do {\r\n                final DirectBufferVector vector = vectors[vectorIndex];\r\n                final int vectorRemaining = vector.length - vectorOffset;\r\n                final int numBytes = Math.min(bytesToWrite - bytesWritten, vectorRemaining);\r\n                termBuffer.putBytes(payloadOffset, vector.buffer, vector.offset + vectorOffset, numBytes);\r\n                bytesWritten += numBytes;\r\n                payloadOffset += numBytes;\r\n                vectorOffset += numBytes;\r\n                if (vectorRemaining <= numBytes) {\r\n                    vectorIndex++;\r\n                    vectorOffset = 0;\r\n                }\r\n            } while (bytesWritten < bytesToWrite);\r\n            if (remaining <= maxPayloadLength) {\r\n                flags |= END_FRAG_FLAG;\r\n            }\r\n            frameFlags(termBuffer, frameOffset, flags);\r\n            if (null != reservedValueSupplier) {\r\n                final long reservedValue = reservedValueSupplier.get(termBuffer, frameOffset, frameLength);\r\n                termBuffer.putLong(frameOffset + RESERVED_VALUE_OFFSET, reservedValue, LITTLE_ENDIAN);\r\n            }\r\n            frameLengthOrdered(termBuffer, frameOffset, frameLength);\r\n            flags = 0;\r\n            frameOffset += alignedLength;\r\n            remaining -= bytesToWrite;\r\n        } while (remaining > 0);\r\n    }\r\n    return (int) resultingOffset;\r\n}"
}, {
	"Path": "io.aeron.cluster.ClusterMember.quorumThreshold",
	"Comment": "the threshold of clusters members required to achieve quorum given a count of cluster members.",
	"Method": "int quorumThreshold(int memberCount){\r\n    return (memberCount / 2) + 1;\r\n}"
}, {
	"Path": "io.aeron.driver.LossDetector.scan",
	"Comment": "scan for gaps and handle received data.the handler keeps track from scan to scan what is a gap and what must have been repaired.",
	"Method": "long scan(UnsafeBuffer termBuffer,long rebuildPosition,long hwmPosition,long nowNs,int termLengthMask,int positionBitsToShift,int initialTermId){\r\n    boolean lossFound = false;\r\n    int rebuildOffset = (int) rebuildPosition & termLengthMask;\r\n    if (rebuildPosition < hwmPosition) {\r\n        final int rebuildTermCount = (int) (rebuildPosition >>> positionBitsToShift);\r\n        final int hwmTermCount = (int) (hwmPosition >>> positionBitsToShift);\r\n        final int rebuildTermId = initialTermId + rebuildTermCount;\r\n        final int hwmTermOffset = (int) hwmPosition & termLengthMask;\r\n        final int limitOffset = rebuildTermCount == hwmTermCount ? hwmTermOffset : termBuffer.capacity();\r\n        rebuildOffset = scanForGap(termBuffer, rebuildTermId, rebuildOffset, limitOffset, this);\r\n        if (rebuildOffset < limitOffset) {\r\n            if (!scannedGap.matches(activeGap)) {\r\n                activateGap(nowNs, scannedGap);\r\n                lossFound = true;\r\n            }\r\n            checkTimerExpiry(nowNs);\r\n        }\r\n    }\r\n    return pack(rebuildOffset, lossFound);\r\n}"
}, {
	"Path": "io.aeron.driver.reports.LossReport.createEntry",
	"Comment": "create a new entry for recording loss on a given stream.if not space is remaining in the error report then null is returned.",
	"Method": "ReportEntry createEntry(long initialBytesLost,long timestampMs,int sessionId,int streamId,String channel,String source){\r\n    ReportEntry reportEntry = null;\r\n    final int requiredCapacity = CHANNEL_OFFSET + (SIZE_OF_INT * 2) + channel.length() + source.length();\r\n    if (requiredCapacity <= (buffer.capacity() - nextRecordOffset)) {\r\n        final int offset = nextRecordOffset;\r\n        buffer.putLong(offset + TOTAL_BYTES_LOST_OFFSET, initialBytesLost);\r\n        buffer.putLong(offset + FIRST_OBSERVATION_OFFSET, timestampMs);\r\n        buffer.putLong(offset + LAST_OBSERVATION_OFFSET, timestampMs);\r\n        buffer.putInt(offset + SESSION_ID_OFFSET, sessionId);\r\n        buffer.putInt(offset + STREAM_ID_OFFSET, streamId);\r\n        final int encodedChannelLength = buffer.putStringAscii(offset + CHANNEL_OFFSET, channel);\r\n        buffer.putStringAscii(offset + CHANNEL_OFFSET + encodedChannelLength, source);\r\n        buffer.putLongOrdered(offset + OBSERVATION_COUNT_OFFSET, 1);\r\n        reportEntry = new ReportEntry(buffer, offset);\r\n        nextRecordOffset += BitUtil.align(requiredCapacity, ENTRY_ALIGNMENT);\r\n    }\r\n    return reportEntry;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.addScriptsChangeEventListener",
	"Comment": "adds an event listener object. methods on this object are called when scriptswatched by this wallet change. runs the listener methods in the user thread.",
	"Method": "void addScriptsChangeEventListener(ScriptsChangeEventListener listener){\r\n    addScriptChangeEventListener(Threading.USER_THREAD, listener);\r\n}"
}, {
	"Path": "org.bitcoinj.core.Coin.isPositive",
	"Comment": "returns true if and only if this instance represents a monetary value greater than zero,otherwise false.",
	"Method": "boolean isPositive(){\r\n    return signum() == 1;\r\n}"
}, {
	"Path": "org.bitcoinj.core.PeerGroup.connectTo",
	"Comment": "creates a version message to send, constructs a peer object and attempts to connect it. returns the peer onsuccess or null on failure.",
	"Method": "Peer connectTo(InetSocketAddress address,Peer connectTo,PeerAddress address,boolean incrementMaxConnections,int connectTimeoutMillis){\r\n    checkState(lock.isHeldByCurrentThread());\r\n    VersionMessage ver = getVersionMessage().duplicate();\r\n    ver.bestHeight = chain == null ? 0 : chain.getBestChainHeight();\r\n    ver.time = Utils.currentTimeSeconds();\r\n    ver.receivingAddr = address;\r\n    ver.receivingAddr.setParent(ver);\r\n    Peer peer = createPeer(address, ver);\r\n    peer.addConnectedEventListener(Threading.SAME_THREAD, startupListener);\r\n    peer.addDisconnectedEventListener(Threading.SAME_THREAD, startupListener);\r\n    peer.setMinProtocolVersion(vMinRequiredProtocolVersion);\r\n    pendingPeers.add(peer);\r\n    try {\r\n        log.info(\"Attempting connection to {}     ({} connected, {} pending, {} max)\", address, peers.size(), pendingPeers.size(), maxConnections);\r\n        ListenableFuture<SocketAddress> future = channels.openConnection(address.toSocketAddress(), peer);\r\n        if (future.isDone())\r\n            Uninterruptibles.getUninterruptibly(future);\r\n    } catch (ExecutionException e) {\r\n        Throwable cause = Throwables.getRootCause(e);\r\n        log.warn(\"Failed to connect to \" + address + \": \" + cause.getMessage());\r\n        handlePeerDeath(peer, cause);\r\n        return null;\r\n    }\r\n    peer.setSocketTimeout(connectTimeoutMillis);\r\n    if (incrementMaxConnections) {\r\n        maxConnections++;\r\n    }\r\n    return peer;\r\n}"
}, {
	"Path": "problems.easy.MaximumDepthofBinaryTree.maxDepth",
	"Comment": "find height of both left and right subtree and return max of them plus one",
	"Method": "int maxDepth(TreeNode root){\r\n    if (root == null)\r\n        return 0;\r\n    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.WalletProtobufSerializer.walletToProto",
	"Comment": "converts the given wallet to the object representation of the protocol buffers. this can be modified, oradditional data fields set, before serialization takes place.",
	"Method": "Protos.Wallet walletToProto(Wallet wallet){\r\n    Protos.Wallet.Builder walletBuilder = Protos.Wallet.newBuilder();\r\n    walletBuilder.setNetworkIdentifier(wallet.getNetworkParameters().getId());\r\n    if (wallet.getDescription() != null) {\r\n        walletBuilder.setDescription(wallet.getDescription());\r\n    }\r\n    for (WalletTransaction wtx : wallet.getWalletTransactions()) {\r\n        Protos.Transaction txProto = makeTxProto(wtx);\r\n        walletBuilder.addTransaction(txProto);\r\n    }\r\n    walletBuilder.addAllKey(wallet.serializeKeyChainGroupToProtobuf());\r\n    for (Script script : wallet.getWatchedScripts()) {\r\n        Protos.Script protoScript = Protos.Script.newBuilder().setProgram(ByteString.copyFrom(script.getProgram())).setCreationTimestamp(script.getCreationTimeSeconds() * 1000).build();\r\n        walletBuilder.addWatchedScript(protoScript);\r\n    }\r\n    Sha256Hash lastSeenBlockHash = wallet.getLastBlockSeenHash();\r\n    if (lastSeenBlockHash != null) {\r\n        walletBuilder.setLastSeenBlockHash(hashToByteString(lastSeenBlockHash));\r\n        walletBuilder.setLastSeenBlockHeight(wallet.getLastBlockSeenHeight());\r\n    }\r\n    if (wallet.getLastBlockSeenTimeSecs() > 0)\r\n        walletBuilder.setLastSeenBlockTimeSecs(wallet.getLastBlockSeenTimeSecs());\r\n    KeyCrypter keyCrypter = wallet.getKeyCrypter();\r\n    if (keyCrypter == null) {\r\n        walletBuilder.setEncryptionType(EncryptionType.UNENCRYPTED);\r\n    } else {\r\n        walletBuilder.setEncryptionType(keyCrypter.getUnderstoodEncryptionType());\r\n        if (keyCrypter instanceof KeyCrypterScrypt) {\r\n            KeyCrypterScrypt keyCrypterScrypt = (KeyCrypterScrypt) keyCrypter;\r\n            walletBuilder.setEncryptionParameters(keyCrypterScrypt.getScryptParameters());\r\n        } else {\r\n            throw new RuntimeException(\"The wallet has encryption of type '\" + keyCrypter.getUnderstoodEncryptionType() + \"' but this WalletProtobufSerializer does not know how to persist this.\");\r\n        }\r\n    }\r\n    if (wallet.getKeyRotationTime() != null) {\r\n        long timeSecs = wallet.getKeyRotationTime().getTime() / 1000;\r\n        walletBuilder.setKeyRotationTime(timeSecs);\r\n    }\r\n    populateExtensions(wallet, walletBuilder);\r\n    for (Map.Entry<String, ByteString> entry : wallet.getTags().entrySet()) {\r\n        Protos.Tag.Builder tag = Protos.Tag.newBuilder().setTag(entry.getKey()).setData(entry.getValue());\r\n        walletBuilder.addTags(tag);\r\n    }\r\n    walletBuilder.setVersion(wallet.getVersion());\r\n    return walletBuilder.build();\r\n}"
}, {
	"Path": "org.bitcoinj.core.Peer.downloadDependenciesInternal",
	"Comment": "the marker object in the future returned is the same as the parameter. it is arbitrary and can be anything.",
	"Method": "ListenableFuture<Object> downloadDependenciesInternal(int maxDepth,int depth,Transaction tx,Object marker,List<Transaction> results){\r\n    final SettableFuture<Object> resultFuture = SettableFuture.create();\r\n    final Sha256Hash rootTxHash = tx.getHash();\r\n    Set<Sha256Hash> needToRequest = new CopyOnWriteArraySet();\r\n    for (TransactionInput input : tx.getInputs()) {\r\n        needToRequest.add(input.getOutpoint().getHash());\r\n    }\r\n    lock.lock();\r\n    try {\r\n        List<ListenableFuture<Transaction>> futures = Lists.newArrayList();\r\n        GetDataMessage getdata = new GetDataMessage(params);\r\n        if (needToRequest.size() > 1)\r\n            log.info(\"{}: Requesting {} transactions for depth {} dep resolution\", getAddress(), needToRequest.size(), depth + 1);\r\n        for (Sha256Hash hash : needToRequest) {\r\n            getdata.addTransaction(hash);\r\n            GetDataRequest req = new GetDataRequest(hash, SettableFuture.create());\r\n            futures.add(req.future);\r\n            getDataFutures.add(req);\r\n        }\r\n        ListenableFuture<List<Transaction>> successful = Futures.successfulAsList(futures);\r\n        Futures.addCallback(successful, new FutureCallback<List<Transaction>>() {\r\n            @Override\r\n            public void onSuccess(List<Transaction> transactions) {\r\n                List<ListenableFuture<Object>> childFutures = Lists.newLinkedList();\r\n                for (Transaction tx : transactions) {\r\n                    if (tx == null)\r\n                        continue;\r\n                    log.info(\"{}: Downloaded dependency of {}: {}\", getAddress(), rootTxHash, tx.getHashAsString());\r\n                    results.add(tx);\r\n                    if (depth + 1 < maxDepth)\r\n                        childFutures.add(downloadDependenciesInternal(maxDepth, depth + 1, tx, marker, results));\r\n                }\r\n                if (childFutures.size() == 0) {\r\n                    resultFuture.set(marker);\r\n                } else {\r\n                    Futures.addCallback(Futures.successfulAsList(childFutures), new FutureCallback<List<Object>>() {\r\n                        @Override\r\n                        public void onSuccess(List<Object> objects) {\r\n                            resultFuture.set(marker);\r\n                        }\r\n                        @Override\r\n                        public void onFailure(Throwable throwable) {\r\n                            resultFuture.setException(throwable);\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n            @Override\r\n            public void onFailure(Throwable throwable) {\r\n                resultFuture.setException(throwable);\r\n            }\r\n        });\r\n        sendMessage(getdata);\r\n    } catch (Exception e) {\r\n        log.error(\"{}: Couldn't send getdata in downloadDependencies({})\", this, tx.getHash(), e);\r\n        resultFuture.setException(e);\r\n        return resultFuture;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n    return resultFuture;\r\n}"
}, {
	"Path": "org.bitcoinj.core.Peer.downloadDependenciesInternal",
	"Comment": "the marker object in the future returned is the same as the parameter. it is arbitrary and can be anything.",
	"Method": "ListenableFuture<Object> downloadDependenciesInternal(int maxDepth,int depth,Transaction tx,Object marker,List<Transaction> results){\r\n    List<ListenableFuture<Object>> childFutures = Lists.newLinkedList();\r\n    for (Transaction tx : transactions) {\r\n        if (tx == null)\r\n            continue;\r\n        log.info(\"{}: Downloaded dependency of {}: {}\", getAddress(), rootTxHash, tx.getHashAsString());\r\n        results.add(tx);\r\n        if (depth + 1 < maxDepth)\r\n            childFutures.add(downloadDependenciesInternal(maxDepth, depth + 1, tx, marker, results));\r\n    }\r\n    if (childFutures.size() == 0) {\r\n        resultFuture.set(marker);\r\n    } else {\r\n        Futures.addCallback(Futures.successfulAsList(childFutures), new FutureCallback<List<Object>>() {\r\n            @Override\r\n            public void onSuccess(List<Object> objects) {\r\n                resultFuture.set(marker);\r\n            }\r\n            @Override\r\n            public void onFailure(Throwable throwable) {\r\n                resultFuture.setException(throwable);\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.Peer.downloadDependenciesInternal",
	"Comment": "the marker object in the future returned is the same as the parameter. it is arbitrary and can be anything.",
	"Method": "ListenableFuture<Object> downloadDependenciesInternal(int maxDepth,int depth,Transaction tx,Object marker,List<Transaction> results){\r\n    resultFuture.set(marker);\r\n}"
}, {
	"Path": "org.bitcoinj.core.Peer.downloadDependenciesInternal",
	"Comment": "the marker object in the future returned is the same as the parameter. it is arbitrary and can be anything.",
	"Method": "ListenableFuture<Object> downloadDependenciesInternal(int maxDepth,int depth,Transaction tx,Object marker,List<Transaction> results){\r\n    resultFuture.setException(throwable);\r\n}"
}, {
	"Path": "org.bitcoinj.core.Peer.downloadDependenciesInternal",
	"Comment": "the marker object in the future returned is the same as the parameter. it is arbitrary and can be anything.",
	"Method": "ListenableFuture<Object> downloadDependenciesInternal(int maxDepth,int depth,Transaction tx,Object marker,List<Transaction> results){\r\n    resultFuture.setException(throwable);\r\n}"
}, {
	"Path": "io.aeron.Publication.termBufferLength",
	"Comment": "get the length in bytes for each term partition in the log buffer.",
	"Method": "int termBufferLength(){\r\n    return termBufferLength;\r\n}"
}, {
	"Path": "org.bitcoinj.core.BitcoinSerializer.makeAddressMessage",
	"Comment": "make an address message from the payload. extension point for alternativeserialization format support.",
	"Method": "AddressMessage makeAddressMessage(byte[] payloadBytes,int length){\r\n    return new AddressMessage(params, payloadBytes, this, length);\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.addOrGetExistingExtension",
	"Comment": "atomically adds extension or returns an existing extension if there is one with the same id already present.",
	"Method": "WalletExtension addOrGetExistingExtension(WalletExtension extension){\r\n    String id = checkNotNull(extension).getWalletExtensionID();\r\n    lock.lock();\r\n    try {\r\n        WalletExtension previousExtension = extensions.get(id);\r\n        if (previousExtension != null)\r\n            return previousExtension;\r\n        extensions.put(id, extension);\r\n        saveNow();\r\n        return extension;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.PeerGroup.removeDiscoveredEventListener",
	"Comment": "the given event listener will no longer be called with events.",
	"Method": "boolean removeDiscoveredEventListener(PeerDiscoveredEventListener listener){\r\n    boolean result = ListenerRegistration.removeFromList(listener, peerDiscoveredEventListeners);\r\n    return result;\r\n}"
}, {
	"Path": "org.bitcoinj.core.PeerGroup.getDownloadPeer",
	"Comment": "returns the currently selected download peer. bear in mind that it may have changed as soon as this methodreturns. can return null if no peer was selected.",
	"Method": "Peer getDownloadPeer(){\r\n    lock.lock();\r\n    try {\r\n        return downloadPeer;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.DeterministicKeyChain.getRedeemData",
	"Comment": "get redeem data for a key.only applicable to married keychains.",
	"Method": "RedeemData getRedeemData(DeterministicKey followedKey){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "org.bitcoinj.utils.ExchangeRate.fiatToCoin",
	"Comment": "convert a fiat amount to a coin amount using this exchange rate.",
	"Method": "Coin fiatToCoin(Fiat convertFiat){\r\n    checkArgument(convertFiat.currencyCode.equals(fiat.currencyCode), \"Currency mismatch: %s vs %s\", convertFiat.currencyCode, fiat.currencyCode);\r\n    final BigInteger converted = BigInteger.valueOf(convertFiat.value).multiply(BigInteger.valueOf(coin.value)).divide(BigInteger.valueOf(fiat.value));\r\n    if (converted.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) > 0 || converted.compareTo(BigInteger.valueOf(Long.MIN_VALUE)) < 0)\r\n        throw new ArithmeticException(\"Overflow\");\r\n    try {\r\n        return Coin.valueOf(converted.longValue());\r\n    } catch (IllegalArgumentException x) {\r\n        throw new ArithmeticException(\"Overflow: \" + x.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.StoredBlock.getHeader",
	"Comment": "the block header this object wraps. the referenced block object must not have any transactions in it.",
	"Method": "Block getHeader(){\r\n    return header;\r\n}"
}, {
	"Path": "org.bitcoinj.core.TransactionInput.duplicateDetached",
	"Comment": "returns a copy of the input detached from its containing transaction, if need be.",
	"Method": "TransactionInput duplicateDetached(){\r\n    return new TransactionInput(params, null, bitcoinSerialize(), 0);\r\n}"
}, {
	"Path": "io.aeron.driver.media.UdpChannelTransport.isValidFrame",
	"Comment": "is the received frame valid. this method will do some basic checks on the header and can beoverridden in a subclass for further validation.",
	"Method": "boolean isValidFrame(UnsafeBuffer buffer,int length){\r\n    boolean isFrameValid = true;\r\n    if (frameVersion(buffer, 0) != HeaderFlyweight.CURRENT_VERSION) {\r\n        isFrameValid = false;\r\n        invalidPackets.increment();\r\n    } else if (length < HeaderFlyweight.MIN_HEADER_LENGTH) {\r\n        isFrameValid = false;\r\n        invalidPackets.increment();\r\n    }\r\n    return isFrameValid;\r\n}"
}, {
	"Path": "org.atmosphere.util.Version.equalVersion",
	"Comment": "checks if current atmosphere framework version equals to one passed",
	"Method": "boolean equalVersion(int major,int minor){\r\n    return minor == Version.minor && major == Version.major;\r\n}"
}, {
	"Path": "com.github.pedrovgs.problem62.PalindromeList.checkIterative",
	"Comment": "iterative algorithm to solve this problem. the key of this algorithm is to use two pointers togo just through the fifty percent of the list. using a fast pointer we can create an stack togenerate a reversed list and then check if both lists are equals or not. the complexity orderof this algorithm is the same than the previous one in time and space terms but the executiontime is faster because we are just checking half of the list.",
	"Method": "boolean checkIterative(ListNode list){\r\n    validateInput(list);\r\n    Stack<ListNode> stack = new Stack<ListNode>();\r\n    ListNode fastPointer = list;\r\n    ListNode slowPointer = list;\r\n    while (fastPointer != null && fastPointer.getNext() != null) {\r\n        stack.add(slowPointer);\r\n        slowPointer = slowPointer.getNext();\r\n        fastPointer = fastPointer.getNext().getNext();\r\n    }\r\n    if (fastPointer != null) {\r\n        slowPointer = slowPointer.getNext();\r\n    }\r\n    boolean isPalindrome = true;\r\n    while (slowPointer != null) {\r\n        if (!stack.pop().equals(slowPointer)) {\r\n            isPalindrome = false;\r\n            break;\r\n        }\r\n        slowPointer = slowPointer.getNext();\r\n    }\r\n    return isPalindrome;\r\n}"
}, {
	"Path": "org.bitcoinj.utils.Fiat.isGreaterThan",
	"Comment": "returns true if the monetary value represented by this instance is greater than that of the given other fiat,otherwise false.",
	"Method": "boolean isGreaterThan(Fiat other){\r\n    return compareTo(other) > 0;\r\n}"
}, {
	"Path": "io.aeron.cluster.service.ClientSession.responseStreamId",
	"Comment": "the response channel stream id for responding to the client.",
	"Method": "int responseStreamId(){\r\n    return responseStreamId;\r\n}"
}, {
	"Path": "io.aeron.samples.StreamStat.snapshot",
	"Comment": "take a snapshot of all the counters and group them by streams.",
	"Method": "Map<StreamCompositeKey, List<StreamPosition>> snapshot(){\r\n    final Map<StreamCompositeKey, List<StreamPosition>> streams = new HashMap();\r\n    counters.forEach((counterId, typeId, keyBuffer, label) -> {\r\n        if ((typeId >= PUBLISHER_LIMIT_TYPE_ID && typeId <= RECEIVER_POS_TYPE_ID) || typeId == SENDER_LIMIT_TYPE_ID || typeId == PER_IMAGE_TYPE_ID || typeId == PUBLISHER_POS_TYPE_ID) {\r\n            final StreamCompositeKey key = new StreamCompositeKey(keyBuffer.getInt(SESSION_ID_OFFSET), keyBuffer.getInt(STREAM_ID_OFFSET), keyBuffer.getStringAscii(CHANNEL_OFFSET));\r\n            final StreamPosition position = new StreamPosition(keyBuffer.getLong(REGISTRATION_ID_OFFSET), counters.getCounterValue(counterId), typeId);\r\n            streams.computeIfAbsent(key, (ignore) -> new ArrayList()).add(position);\r\n        }\r\n    });\r\n    return streams;\r\n}"
}, {
	"Path": "org.atmosphere.util.ChunkConcatReaderPool.getReader",
	"Comment": "returns the specified reader. if the reader is absent, returns null. if create is set to true, a new reader is created.",
	"Method": "Reader getReader(String key,boolean create){\r\n    ChunkConcatReader reader = readersPool.get(key);\r\n    if (create && reader == null) {\r\n        reader = new ChunkConcatReader(key);\r\n        readersPool.put(key, reader);\r\n    }\r\n    return reader;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.BasicKeyChain.checkAESKey",
	"Comment": "check whether the aes key can decrypt the first encrypted key in the wallet.",
	"Method": "boolean checkAESKey(KeyParameter aesKey){\r\n    lock.lock();\r\n    try {\r\n        if (hashToKeys.isEmpty())\r\n            return false;\r\n        checkState(keyCrypter != null, \"Key chain is not encrypted\");\r\n        ECKey first = null;\r\n        for (ECKey key : hashToKeys.values()) {\r\n            if (key.isEncrypted()) {\r\n                first = key;\r\n                break;\r\n            }\r\n        }\r\n        checkState(first != null, \"No encrypted keys in the wallet\");\r\n        try {\r\n            ECKey rebornKey = first.decrypt(aesKey);\r\n            return Arrays.equals(first.getPubKey(), rebornKey.getPubKey());\r\n        } catch (KeyCrypterException e) {\r\n            return false;\r\n        }\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.PeerGroup.setConnectTimeoutMillis",
	"Comment": "sets the timeout between when a connection attempt to a peer begins and when the version message exchangecompletes. this does not apply to currently pending peers.",
	"Method": "void setConnectTimeoutMillis(int connectTimeoutMillis){\r\n    this.vConnectTimeoutMillis = connectTimeoutMillis;\r\n}"
}, {
	"Path": "org.bitcoinj.core.Coin.toFriendlyString",
	"Comment": "returns the value as a 0.12 type string. more digits after the decimal place will be usedif necessary, but two will always be present.",
	"Method": "String toFriendlyString(){\r\n    return FRIENDLY_FORMAT.format(this).toString();\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.removeCoinsSentEventListener",
	"Comment": "removes the given event listener object. returns true if the listener was removed, false if that listenerwas never added.",
	"Method": "boolean removeCoinsSentEventListener(WalletCoinsSentEventListener listener){\r\n    return ListenerRegistration.removeFromList(listener, coinsSentListeners);\r\n}"
}, {
	"Path": "org.atmosphere.runtime.BroadcasterConfig.init",
	"Comment": "initialize broadcastfilters and broadcastercache. must always be called after creating a new broadcasterconfig!",
	"Method": "BroadcasterConfig init(){\r\n    if (handleExecutors) {\r\n        configExecutors();\r\n    }\r\n    if (filterList != null) {\r\n        configureBroadcasterFilter(filterList);\r\n    }\r\n    configureBroadcasterCache();\r\n    return this;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.DeterministicKeyChain.getKey",
	"Comment": "returns a freshly derived key that has not been returned by this method before.",
	"Method": "DeterministicKey getKey(KeyPurpose purpose){\r\n    return getKeys(purpose, 1).get(0);\r\n}"
}, {
	"Path": "org.bitcoinj.core.PeerTest.invNoDownload",
	"Comment": "check that an inv to a peer that is not set to download missing blocks does nothing.",
	"Method": "void invNoDownload(){\r\n    peer.setDownloadData(false);\r\n    connect();\r\n    Block b1 = createFakeBlock(blockStore, Block.BLOCK_HEIGHT_GENESIS).block;\r\n    blockChain.add(b1);\r\n    Block b2 = makeSolvedTestBlock(b1);\r\n    InventoryMessage inv = new InventoryMessage(UNITTEST);\r\n    InventoryItem item = new InventoryItem(InventoryItem.Type.Block, b2.getHash());\r\n    inv.addItem(item);\r\n    inbound(writeTarget, inv);\r\n    assertNull(outbound(writeTarget));\r\n}"
}, {
	"Path": "io.aeron.FragmentAssembler.delegate",
	"Comment": "get the delegate unto which assembled messages are delegated.",
	"Method": "FragmentHandler delegate(){\r\n    return delegate;\r\n}"
}, {
	"Path": "org.bitcoinj.core.PeerTest.invTickle",
	"Comment": "check that an inventory tickle is processed correctly when downloading missing blocks is active.",
	"Method": "void invTickle(){\r\n    connect();\r\n    Block b1 = createFakeBlock(blockStore, Block.BLOCK_HEIGHT_GENESIS).block;\r\n    blockChain.add(b1);\r\n    Block b2 = makeSolvedTestBlock(b1);\r\n    Block b3 = makeSolvedTestBlock(b2);\r\n    inbound(writeTarget, b3);\r\n    InventoryMessage inv = new InventoryMessage(UNITTEST);\r\n    InventoryItem item = new InventoryItem(InventoryItem.Type.Block, b3.getHash());\r\n    inv.addItem(item);\r\n    inbound(writeTarget, inv);\r\n    GetBlocksMessage getblocks = (GetBlocksMessage) outbound(writeTarget);\r\n    BlockLocator expectedLocator = new BlockLocator();\r\n    expectedLocator = expectedLocator.add(b1.getHash());\r\n    expectedLocator = expectedLocator.add(UNITTEST.getGenesisBlock().getHash());\r\n    assertEquals(getblocks.getLocator(), expectedLocator);\r\n    assertEquals(getblocks.getStopHash(), b3.getHash());\r\n    assertNull(outbound(writeTarget));\r\n}"
}, {
	"Path": "org.bitcoinj.core.BlockChainTest.badBip65Version",
	"Comment": "test that version 3 blocks are rejected once version 4 blocks are a supermajority.",
	"Method": "void badBip65Version(){\r\n    testDeprecatedBlockVersion(Block.BLOCK_VERSION_BIP66, Block.BLOCK_VERSION_BIP65);\r\n}"
}, {
	"Path": "io.aeron.Image.correlationId",
	"Comment": "the correlationid for identification of the image with the media driver.",
	"Method": "long correlationId(){\r\n    return correlationId;\r\n}"
}, {
	"Path": "org.bitcoinj.protocols.channels.PaymentChannelServerState.makeUnsignedChannelContract",
	"Comment": "create a payment transaction with valuetome going back to us",
	"Method": "SendRequest makeUnsignedChannelContract(Coin valueToMe){\r\n    Transaction tx = new Transaction(wallet.getParams());\r\n    if (!getTotalValue().subtract(valueToMe).equals(Coin.ZERO)) {\r\n        tx.addOutput(getTotalValue().subtract(valueToMe), LegacyAddress.fromKey(wallet.getParams(), getClientKey()));\r\n    }\r\n    tx.addInput(contract.getOutput(0));\r\n    return SendRequest.forTx(tx);\r\n}"
}, {
	"Path": "com.mobsandgeeks.saripaar.tests.EspressoHelper.ensureViewIsVisible",
	"Comment": "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ private methods~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
	"Method": "void ensureViewIsVisible(){\r\n    Espresso.closeSoftKeyboard();\r\n    try {\r\n        Thread.sleep(300);\r\n    } catch (InterruptedException e) {\r\n        e.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "commons.validator.routines.AbstractNumberValidator.getFormatType",
	"Comment": "indicates the type of numberformat created by this validator instance.",
	"Method": "int getFormatType(){\r\n    return formatType;\r\n}"
}, {
	"Path": "org.bitcoinj.core.NetworkParameters.getBlockVerificationFlags",
	"Comment": "the flags indicating which block validation tests should be applied tothe given block. enables support for alternative blockchains which enabletests based on different criteria.",
	"Method": "EnumSet<Block.VerifyFlag> getBlockVerificationFlags(Block block,VersionTally tally,Integer height){\r\n    final EnumSet<Block.VerifyFlag> flags = EnumSet.noneOf(Block.VerifyFlag.class);\r\n    if (block.isBIP34()) {\r\n        final Integer count = tally.getCountAtOrAbove(Block.BLOCK_VERSION_BIP34);\r\n        if (null != count && count >= getMajorityEnforceBlockUpgrade()) {\r\n            flags.add(Block.VerifyFlag.HEIGHT_IN_COINBASE);\r\n        }\r\n    }\r\n    return flags;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.removeWatchedAddresses",
	"Comment": "removes the given output scripts from the wallet that were being watched.",
	"Method": "boolean removeWatchedAddresses(List<Address> addresses){\r\n    List<Script> scripts = Lists.newArrayList();\r\n    for (Address address : addresses) {\r\n        Script script = ScriptBuilder.createOutputScript(address);\r\n        scripts.add(script);\r\n    }\r\n    return removeWatchedScripts(scripts);\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.killTxns",
	"Comment": "updates the wallet when a double spend occurs. overridingtx can be null for the case of coinbases",
	"Method": "void killTxns(Set<Transaction> txnsToKill,Transaction overridingTx){\r\n    LinkedList<Transaction> work = new LinkedList(txnsToKill);\r\n    while (!work.isEmpty()) {\r\n        final Transaction tx = work.poll();\r\n        log.warn(\"TX {} killed{}\", tx.getHashAsString(), overridingTx != null ? \" by \" + overridingTx.getHashAsString() : \"\");\r\n        log.warn(\"Disconnecting each input and moving connected transactions.\");\r\n        pending.remove(tx.getHash());\r\n        unspent.remove(tx.getHash());\r\n        spent.remove(tx.getHash());\r\n        addWalletTransaction(Pool.DEAD, tx);\r\n        for (TransactionInput deadInput : tx.getInputs()) {\r\n            Transaction connected = deadInput.getConnectedTransaction();\r\n            if (connected == null)\r\n                continue;\r\n            if (connected.getConfidence().getConfidenceType() != ConfidenceType.DEAD && deadInput.getConnectedOutput().getSpentBy() != null && deadInput.getConnectedOutput().getSpentBy().equals(deadInput)) {\r\n                checkState(myUnspents.add(deadInput.getConnectedOutput()));\r\n                log.info(\"Added to UNSPENTS: {} in {}\", deadInput.getConnectedOutput(), deadInput.getConnectedOutput().getParentTransaction().getHash());\r\n            }\r\n            deadInput.disconnect();\r\n            maybeMovePool(connected, \"kill\");\r\n        }\r\n        tx.getConfidence().setOverridingTransaction(overridingTx);\r\n        confidenceChanged.put(tx, TransactionConfidence.Listener.ChangeReason.TYPE);\r\n        for (TransactionOutput deadOutput : tx.getOutputs()) {\r\n            if (myUnspents.remove(deadOutput))\r\n                log.info(\"XX Removed from UNSPENTS: {}\", deadOutput);\r\n            TransactionInput connected = deadOutput.getSpentBy();\r\n            if (connected == null)\r\n                continue;\r\n            final Transaction parentTransaction = connected.getParentTransaction();\r\n            log.info(\"This death invalidated dependent tx {}\", parentTransaction.getHash());\r\n            work.push(parentTransaction);\r\n        }\r\n    }\r\n    if (overridingTx == null)\r\n        return;\r\n    log.warn(\"Now attempting to connect the inputs of the overriding transaction.\");\r\n    for (TransactionInput input : overridingTx.getInputs()) {\r\n        TransactionInput.ConnectionResult result = input.connect(unspent, TransactionInput.ConnectMode.DISCONNECT_ON_CONFLICT);\r\n        if (result == TransactionInput.ConnectionResult.SUCCESS) {\r\n            maybeMovePool(input.getConnectedTransaction(), \"kill\");\r\n            myUnspents.remove(input.getConnectedOutput());\r\n            log.info(\"Removing from UNSPENTS: {}\", input.getConnectedOutput());\r\n        } else {\r\n            result = input.connect(spent, TransactionInput.ConnectMode.DISCONNECT_ON_CONFLICT);\r\n            if (result == TransactionInput.ConnectionResult.SUCCESS) {\r\n                maybeMovePool(input.getConnectedTransaction(), \"kill\");\r\n                myUnspents.remove(input.getConnectedOutput());\r\n                log.info(\"Removing from UNSPENTS: {}\", input.getConnectedOutput());\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.protocols.payments.PaymentSession.isExpired",
	"Comment": "this should always be called before attempting to call sendpayment.",
	"Method": "boolean isExpired(){\r\n    return paymentDetails.hasExpires() && System.currentTimeMillis() / 1000L > paymentDetails.getExpires();\r\n}"
}, {
	"Path": "org.atmosphere.config.managed.ManagedAtmosphereHandler.onHeartbeat",
	"Comment": "notifies the heartbeat for the given resource to the annotated method if exists.",
	"Method": "void onHeartbeat(AtmosphereResourceEvent event){\r\n    if (onHeartbeatMethod != null) {\r\n        invoke(onHeartbeatMethod, event);\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.NetworkParameters.getInterval",
	"Comment": "how many blocks pass between difficulty adjustment periods. bitcoin standardises this to be 2016.",
	"Method": "int getInterval(){\r\n    return interval;\r\n}"
}, {
	"Path": "io.aeron.cluster.service.CommitPos.allocate",
	"Comment": "allocate a counter to represent the commit position on stream for the current leadership term.",
	"Method": "Counter allocate(Aeron aeron){\r\n    return aeron.addCounter(COMMIT_POSITION_TYPE_ID, NAME);\r\n}"
}, {
	"Path": "commons.validator.routines.EmailValidator.getInstance",
	"Comment": "returns the singleton instance of this validator, with local validation as required.",
	"Method": "EmailValidator getInstance(EmailValidator getInstance,boolean allowLocal){\r\n    if (allowLocal) {\r\n        return EMAIL_VALIDATOR_WITH_LOCAL;\r\n    }\r\n    return EMAIL_VALIDATOR;\r\n}"
}, {
	"Path": "io.aeron.cluster.ClusterMember.haveVotersReachedPosition",
	"Comment": "has the members of the cluster the voted reached the provided position in their log.",
	"Method": "boolean haveVotersReachedPosition(ClusterMember[] clusterMembers,long position,long leadershipTermId){\r\n    for (final ClusterMember member : clusterMembers) {\r\n        if (member.vote != null && (member.logPosition < position || member.leadershipTermId != leadershipTermId)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.bitcoinj.core.PeerTest.shutdown",
	"Comment": "check that it runs through the event loop and shut down correctly",
	"Method": "void shutdown(){\r\n    closePeer(peer);\r\n}"
}, {
	"Path": "org.bitcoinj.core.RejectedTransactionException.getRejectMessage",
	"Comment": "return the rejectmessage object representing the broadcast rejection.",
	"Method": "RejectMessage getRejectMessage(){\r\n    return rejectMessage;\r\n}"
}, {
	"Path": "org.bitcoinj.core.PeerGroup.findPeersWithServiceMask",
	"Comment": "returns an array list of peers that match the requested service bit mask.",
	"Method": "List<Peer> findPeersWithServiceMask(int mask){\r\n    lock.lock();\r\n    try {\r\n        ArrayList<Peer> results = new ArrayList<Peer>(peers.size());\r\n        for (Peer peer : peers) if ((peer.getPeerVersionMessage().localServices & mask) == mask)\r\n            results.add(peer);\r\n        return results;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "io.aeron.cluster.service.ClusteredServiceContainer.main",
	"Comment": "launch the clustered service container and await a shutdown signal.",
	"Method": "void main(String[] args){\r\n    loadPropertiesFiles(args);\r\n    try (ClusteredServiceContainer container = launch()) {\r\n        container.context().shutdownSignalBarrier().await();\r\n        System.out.println(\"Shutdown ClusteredServiceContainer...\");\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.ECKey.isWatching",
	"Comment": "returns true if this key is watch only, meaning it has a public key but no private key.",
	"Method": "boolean isWatching(){\r\n    return isPubKeyOnly() && !isEncrypted();\r\n}"
}, {
	"Path": "io.aeron.logbuffer.TermReader.pack",
	"Comment": "pack the values for fragmentsread and offset into a long for returning on the stack.",
	"Method": "long pack(int offset,int fragmentsRead){\r\n    return ((long) offset << 32) | fragmentsRead;\r\n}"
}, {
	"Path": "io.aeron.cluster.service.ClientSession.encodedPrincipal",
	"Comment": "cluster session encoded principal from when the session was authenticated.",
	"Method": "byte[] encodedPrincipal(){\r\n    return encodedPrincipal;\r\n}"
}, {
	"Path": "org.atmosphere.util.uri.UriTemplate.createURI",
	"Comment": "create a uri by substituting any template variablesfor corresponding template values.a uri template variable without a value will be substituted by the empty string.",
	"Method": "String createURI(Map<String, String> values,String createURI,String values,String createURI,String[] values,int offset,int length,String createURI,String scheme,String userInfo,String host,String port,String path,String query,String fragment,Map<String, ? extends Object> values,boolean encode,String createURI,String scheme,String authority,String userInfo,String host,String port,String path,String query,String fragment,Map<String, ? extends Object> values,boolean encode,String createURI,String scheme,String userInfo,String host,String port,String path,String query,String fragment,Object[] values,boolean encode,String createURI,String scheme,String authority,String userInfo,String host,String port,String path,String query,String fragment,Object[] values,boolean encode){\r\n    String[] stringValues = new String[values.length];\r\n    for (int i = 0; i < values.length; i++) {\r\n        if (values[i] != null)\r\n            stringValues[i] = values[i].toString();\r\n    }\r\n    return createURIWithStringValues(scheme, authority, userInfo, host, port, path, query, fragment, stringValues, encode);\r\n}"
}, {
	"Path": "org.bitcoinj.core.Block.getTransactions",
	"Comment": "returns an immutable list of transactions held in this block, or null if this object represents just a header.",
	"Method": "List<Transaction> getTransactions(){\r\n    return transactions == null ? null : ImmutableList.copyOf(transactions);\r\n}"
}, {
	"Path": "algo.sortingandsearching.BinarySearch.searchUpperBound",
	"Comment": "when there are duplicates, this finds the last occurrence of the key",
	"Method": "int searchUpperBound(int[] a,int key){\r\n    int lo = 0;\r\n    int hi = a.length - 1;\r\n    while (lo <= hi) {\r\n        int mid = lo + (hi - lo) / 2;\r\n        if (a[mid] == key && (mid == a.length - 1 || a[mid + 1] != key))\r\n            return mid;\r\n        if (a[mid] <= key)\r\n            lo = mid + 1;\r\n        else\r\n            hi = mid - 1;\r\n    }\r\n    return -(hi + 1);\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.completeTx",
	"Comment": "given a spend request containing an incomplete transaction, makes it valid by adding outputs and signed inputsaccording to the instructions in the request. the transaction in the request is modified by this method.",
	"Method": "void completeTx(SendRequest req){\r\n    lock.lock();\r\n    try {\r\n        checkArgument(!req.completed, \"Given SendRequest has already been completed.\");\r\n        Coin value = Coin.ZERO;\r\n        for (TransactionOutput output : req.tx.getOutputs()) {\r\n            value = value.add(output.getValue());\r\n        }\r\n        log.info(\"Completing send tx with {} outputs totalling {} and a fee of {}/kB\", req.tx.getOutputs().size(), value.toFriendlyString(), req.feePerKb.toFriendlyString());\r\n        Coin totalInput = Coin.ZERO;\r\n        for (TransactionInput input : req.tx.getInputs()) if (input.getConnectedOutput() != null)\r\n            totalInput = totalInput.add(input.getConnectedOutput().getValue());\r\n        else\r\n            log.warn(\"SendRequest transaction already has inputs but we don't know how much they are worth - they will be added to fee.\");\r\n        value = value.subtract(totalInput);\r\n        List<TransactionInput> originalInputs = new ArrayList(req.tx.getInputs());\r\n        if (req.ensureMinRequiredFee && !req.emptyWallet) {\r\n            int opReturnCount = 0;\r\n            for (TransactionOutput output : req.tx.getOutputs()) {\r\n                if (output.isDust())\r\n                    throw new DustySendRequested();\r\n                if (ScriptPattern.isOpReturn(output.getScriptPubKey()))\r\n                    ++opReturnCount;\r\n            }\r\n            if (opReturnCount > 1)\r\n                throw new MultipleOpReturnRequested();\r\n        }\r\n        List<TransactionOutput> candidates = calculateAllSpendCandidates(true, req.missingSigsMode == MissingSigsMode.THROW);\r\n        CoinSelection bestCoinSelection;\r\n        TransactionOutput bestChangeOutput = null;\r\n        List<Coin> updatedOutputValues = null;\r\n        if (!req.emptyWallet) {\r\n            FeeCalculation feeCalculation = calculateFee(req, value, originalInputs, req.ensureMinRequiredFee, candidates);\r\n            bestCoinSelection = feeCalculation.bestCoinSelection;\r\n            bestChangeOutput = feeCalculation.bestChangeOutput;\r\n            updatedOutputValues = feeCalculation.updatedOutputValues;\r\n        } else {\r\n            checkState(req.tx.getOutputs().size() == 1, \"Empty wallet TX must have a single output only.\");\r\n            CoinSelector selector = req.coinSelector == null ? coinSelector : req.coinSelector;\r\n            bestCoinSelection = selector.select(params.getMaxMoney(), candidates);\r\n            candidates = null;\r\n            req.tx.getOutput(0).setValue(bestCoinSelection.valueGathered);\r\n            log.info(\"  emptying {}\", bestCoinSelection.valueGathered.toFriendlyString());\r\n        }\r\n        for (TransactionOutput output : bestCoinSelection.gathered) req.tx.addInput(output);\r\n        if (req.emptyWallet) {\r\n            final Coin feePerKb = req.feePerKb == null ? Coin.ZERO : req.feePerKb;\r\n            if (!adjustOutputDownwardsForFee(req.tx, bestCoinSelection, feePerKb, req.ensureMinRequiredFee))\r\n                throw new CouldNotAdjustDownwards();\r\n        }\r\n        if (updatedOutputValues != null) {\r\n            for (int i = 0; i < updatedOutputValues.size(); i++) {\r\n                req.tx.getOutput(i).setValue(updatedOutputValues.get(i));\r\n            }\r\n        }\r\n        if (bestChangeOutput != null) {\r\n            req.tx.addOutput(bestChangeOutput);\r\n            log.info(\"  with {} change\", bestChangeOutput.getValue().toFriendlyString());\r\n        }\r\n        if (req.shuffleOutputs)\r\n            req.tx.shuffleOutputs();\r\n        if (req.signInputs)\r\n            signTransaction(req);\r\n        final int size = req.tx.unsafeBitcoinSerialize().length;\r\n        if (size > Transaction.MAX_STANDARD_TX_SIZE)\r\n            throw new ExceededMaxTransactionSize();\r\n        req.tx.getConfidence().setSource(TransactionConfidence.Source.SELF);\r\n        req.tx.setPurpose(Transaction.Purpose.USER_PAYMENT);\r\n        req.tx.setExchangeRate(req.exchangeRate);\r\n        req.tx.setMemo(req.memo);\r\n        req.completed = true;\r\n        log.info(\"  completed: {}\", req.tx);\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.testing.FakeTxBuilder.createFakeTxWithoutChangeAddress",
	"Comment": "create a fake tx for unit tests, for use with unit tests that need greater control. one outputs, 2 random inputs,split randomly to create randomness.",
	"Method": "Transaction createFakeTxWithoutChangeAddress(NetworkParameters params,Coin value,Address to){\r\n    Transaction t = new Transaction(params);\r\n    TransactionOutput outputToMe = new TransactionOutput(params, t, value, to);\r\n    t.addOutput(outputToMe);\r\n    long split = new Random().nextLong();\r\n    if (split < 0) {\r\n        split *= -1;\r\n    }\r\n    if (split == 0) {\r\n        split = 15;\r\n    }\r\n    while (split > value.getValue()) {\r\n        split /= 2;\r\n    }\r\n    Transaction prevTx1 = new Transaction(params);\r\n    TransactionOutput prevOut1 = new TransactionOutput(params, prevTx1, Coin.valueOf(split), to);\r\n    prevTx1.addOutput(prevOut1);\r\n    t.addInput(prevOut1).setScriptSig(ScriptBuilder.createInputScript(TransactionSignature.dummy()));\r\n    Transaction prevTx2 = new Transaction(params);\r\n    TransactionOutput prevOut2 = new TransactionOutput(params, prevTx2, Coin.valueOf(value.getValue() - split), to);\r\n    prevTx2.addOutput(prevOut2);\r\n    t.addInput(prevOut2).setScriptSig(ScriptBuilder.createInputScript(TransactionSignature.dummy()));\r\n    return roundTripTransaction(params, t);\r\n}"
}, {
	"Path": "org.bitcoinj.core.BitcoinSerializer.makeTransaction",
	"Comment": "make a transaction from the payload. extension point for alternativeserialization format support.",
	"Method": "Transaction makeTransaction(byte[] payloadBytes,int offset,int length,byte[] hash){\r\n    Transaction tx = new Transaction(params, payloadBytes, offset, null, this, length);\r\n    if (hash != null)\r\n        tx.setHash(Sha256Hash.wrapReversed(hash));\r\n    return tx;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.DeterministicKeyChain.findRedeemDataByScriptHash",
	"Comment": "returns the redeem script by its hash or null if this keychain did not generate the script.",
	"Method": "RedeemData findRedeemDataByScriptHash(ByteString bytes){\r\n    return null;\r\n}"
}, {
	"Path": "io.aeron.driver.media.UdpChannelTransport.close",
	"Comment": "close transport, canceling any pending read operations and closing channel",
	"Method": "void close(){\r\n    if (!isClosed) {\r\n        isClosed = true;\r\n        try {\r\n            if (null != selectionKey) {\r\n                selectionKey.cancel();\r\n            }\r\n            if (null != transportPoller) {\r\n                transportPoller.cancelRead(this);\r\n                transportPoller.selectNowWithoutProcessing();\r\n            }\r\n            if (null != sendDatagramChannel) {\r\n                sendDatagramChannel.close();\r\n            }\r\n            if (receiveDatagramChannel != sendDatagramChannel && null != receiveDatagramChannel) {\r\n                receiveDatagramChannel.close();\r\n            }\r\n            if (null != transportPoller) {\r\n                transportPoller.selectNowWithoutProcessing();\r\n            }\r\n        } catch (final IOException ex) {\r\n            errorLog.record(ex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.TransactionInput.disconnect",
	"Comment": "if this input is connected, check the output is connected back to this input and release it if so, makingit spendable once again.",
	"Method": "boolean disconnect(){\r\n    TransactionOutput connectedOutput;\r\n    if (outpoint.fromTx != null) {\r\n        connectedOutput = outpoint.fromTx.getOutput((int) outpoint.getIndex());\r\n        outpoint.fromTx = null;\r\n    } else if (outpoint.connectedOutput != null) {\r\n        connectedOutput = outpoint.connectedOutput;\r\n        outpoint.connectedOutput = null;\r\n    } else {\r\n        return false;\r\n    }\r\n    if (connectedOutput != null && connectedOutput.getSpentBy() == this) {\r\n        connectedOutput.markAsUnspent();\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.kits.WalletAppKit.setUserAgent",
	"Comment": "sets the string that will appear in the subver field of the version message.",
	"Method": "WalletAppKit setUserAgent(String userAgent,String version){\r\n    this.userAgent = checkNotNull(userAgent);\r\n    this.version = checkNotNull(version);\r\n    return this;\r\n}"
}, {
	"Path": "org.bitcoinj.core.ECKey.recoverFromSignature",
	"Comment": "given the components of a signature and a selector value, recover and return the public keythat generated the signature according to the algorithm in sec1v2 section 4.1.6.the recid is an index from 0 to 3 which indicates which of the 4 possible keys is the correct one. becausethe key recovery operation yields multiple potential keys, the correct key must either be stored alongside thesignature, or you must be willing to try each recid in turn until you find one that outputs the key you areexpecting.if this method returns null it means recovery was not possible and recid should be iterated.given the above two points, a correct usage of this method is inside a for loop from 0 to 3, and if theoutput is null or a key that is not the one you expect, you try again with the next recid.",
	"Method": "ECKey recoverFromSignature(int recId,ECDSASignature sig,Sha256Hash message,boolean compressed){\r\n    Preconditions.checkArgument(recId >= 0, \"recId must be positive\");\r\n    Preconditions.checkArgument(sig.r.signum() >= 0, \"r must be positive\");\r\n    Preconditions.checkArgument(sig.s.signum() >= 0, \"s must be positive\");\r\n    Preconditions.checkNotNull(message);\r\n    BigInteger n = CURVE.getN();\r\n    BigInteger i = BigInteger.valueOf((long) recId / 2);\r\n    BigInteger x = sig.r.add(i.multiply(n));\r\n    BigInteger prime = SecP256K1Curve.q;\r\n    if (x.compareTo(prime) >= 0) {\r\n        return null;\r\n    }\r\n    ECPoint R = decompressKey(x, (recId & 1) == 1);\r\n    if (!R.multiply(n).isInfinity())\r\n        return null;\r\n    BigInteger e = message.toBigInteger();\r\n    BigInteger eInv = BigInteger.ZERO.subtract(e).mod(n);\r\n    BigInteger rInv = sig.r.modInverse(n);\r\n    BigInteger srInv = rInv.multiply(sig.s).mod(n);\r\n    BigInteger eInvrInv = rInv.multiply(eInv).mod(n);\r\n    ECPoint q = ECAlgorithms.sumOfTwoMultiplies(CURVE.getG(), eInvrInv, R, srInv);\r\n    return ECKey.fromPublicOnly(q.getEncoded(compressed));\r\n}"
}, {
	"Path": "io.aeron.driver.media.UdpChannelTransport.multicastTtl",
	"Comment": "get the multicast ttl value for sending datagrams on the channel.",
	"Method": "int multicastTtl(){\r\n    return multicastTtl;\r\n}"
}, {
	"Path": "org.bitcoinj.protocols.channels.StoredServerChannel.setConnectedHandler",
	"Comment": "attempts to connect the given handler to this, returning true if it is the new handler, false if there wasalready one attached.",
	"Method": "PaymentChannelServer setConnectedHandler(PaymentChannelServer connectedHandler,boolean override){\r\n    if (this.connectedHandler != null && !override)\r\n        return this.connectedHandler;\r\n    this.connectedHandler = connectedHandler;\r\n    return connectedHandler;\r\n}"
}, {
	"Path": "io.aeron.Publication.isOriginal",
	"Comment": "is this publication the original instance added to the driver? if not then it was added after another clienthas already added the publication.",
	"Method": "boolean isOriginal(){\r\n    return originalRegistrationId == registrationId;\r\n}"
}, {
	"Path": "org.bitcoinj.script.Script.getChunks",
	"Comment": "returns an immutable list of the scripts parsed form. each chunk is either an opcode or data element.",
	"Method": "List<ScriptChunk> getChunks(){\r\n    return Collections.unmodifiableList(chunks);\r\n}"
}, {
	"Path": "io.aeron.cluster.ClusterMember.closeMemberPublications",
	"Comment": "close the publications associated with members of the cluster.",
	"Method": "void closeMemberPublications(ClusterMember[] clusterMembers){\r\n    for (final ClusterMember member : clusterMembers) {\r\n        CloseHelper.close(member.publication);\r\n    }\r\n}"
}, {
	"Path": "org.atmosphere.client.TrackMessageSizeInterceptor.messageDelimiter",
	"Comment": "set the character delimiter used by this class to separate message.",
	"Method": "TrackMessageSizeInterceptor messageDelimiter(String endString){\r\n    this.endString = endString;\r\n    end = endString.getBytes();\r\n    return this;\r\n}"
}, {
	"Path": "org.atmosphere.util.IntrospectionUtils.getURLClassLoader",
	"Comment": "construct a urlclassloader. will compile and work in jdk1.1 too.",
	"Method": "ClassLoader getURLClassLoader(URL urls,ClassLoader parent){\r\n    try {\r\n        Class<?> urlCL = Class.forName(\"java.net.URLClassLoader\");\r\n        Class<?>[] paramT = new Class[2];\r\n        paramT[0] = urls.getClass();\r\n        paramT[1] = ClassLoader.class;\r\n        Method m = findMethod(urlCL, \"newInstance\", paramT);\r\n        if (m == null) {\r\n            return null;\r\n        }\r\n        ClassLoader cl = (ClassLoader) m.invoke(urlCL, new Object[] { urls, parent });\r\n        return cl;\r\n    } catch (ClassNotFoundException ex) {\r\n        return null;\r\n    } catch (Exception ex) {\r\n        logger.error(\"failed getting URLClassLoader\", ex);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.BloomFilter.applyAndUpdate",
	"Comment": "creates a new filteredblock from the given block, using this filter to select transactions. matches can cause thefilter to be updated with the matched element, this ensures that when a filter is applied to a block, spends ofmatched transactions are also matched. however it means this filter can be mutated by the operation. the returnedfiltered block already has the matched transactions associated with it.",
	"Method": "FilteredBlock applyAndUpdate(Block block,boolean applyAndUpdate,Transaction tx){\r\n    if (contains(tx.getHash().getBytes()))\r\n        return true;\r\n    boolean found = false;\r\n    BloomUpdate flag = getUpdateFlag();\r\n    for (TransactionOutput output : tx.getOutputs()) {\r\n        Script script = output.getScriptPubKey();\r\n        for (ScriptChunk chunk : script.getChunks()) {\r\n            if (!chunk.isPushData())\r\n                continue;\r\n            if (contains(chunk.data)) {\r\n                boolean isSendingToPubKeys = ScriptPattern.isPayToPubKey(script) || ScriptPattern.isSentToMultisig(script);\r\n                if (flag == BloomUpdate.UPDATE_ALL || (flag == BloomUpdate.UPDATE_P2PUBKEY_ONLY && isSendingToPubKeys))\r\n                    insert(output.getOutPointFor().unsafeBitcoinSerialize());\r\n                found = true;\r\n            }\r\n        }\r\n    }\r\n    if (found)\r\n        return true;\r\n    for (TransactionInput input : tx.getInputs()) {\r\n        if (contains(input.getOutpoint().unsafeBitcoinSerialize())) {\r\n            return true;\r\n        }\r\n        for (ScriptChunk chunk : input.getScriptSig().getChunks()) {\r\n            if (chunk.isPushData() && contains(chunk.data))\r\n                return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.changeEncryptionPassword",
	"Comment": "changes wallet encryption password, this is atomic operation.",
	"Method": "void changeEncryptionPassword(CharSequence currentPassword,CharSequence newPassword){\r\n    keyChainGroupLock.lock();\r\n    try {\r\n        decrypt(currentPassword);\r\n        encrypt(newPassword);\r\n    } finally {\r\n        keyChainGroupLock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.changeEncryptionKey",
	"Comment": "changes wallet aes encryption key, this is atomic operation.",
	"Method": "void changeEncryptionKey(KeyCrypter keyCrypter,KeyParameter currentAesKey,KeyParameter newAesKey){\r\n    keyChainGroupLock.lock();\r\n    try {\r\n        decrypt(currentAesKey);\r\n        encrypt(keyCrypter, newAesKey);\r\n    } finally {\r\n        keyChainGroupLock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.FilteredBlock.getHash",
	"Comment": "gets the hash of the block represented in this filtered block",
	"Method": "Sha256Hash getHash(){\r\n    return header.getHash();\r\n}"
}, {
	"Path": "io.aeron.logbuffer.TermAppender.appendUnfragmentedMessage",
	"Comment": "append an unfragmented message to the the term buffer as a gathering of vectors.",
	"Method": "int appendUnfragmentedMessage(HeaderWriter header,DirectBuffer bufferOne,int offsetOne,int lengthOne,DirectBuffer bufferTwo,int offsetTwo,int lengthTwo,ReservedValueSupplier reservedValueSupplier,int activeTermId,int appendUnfragmentedMessage,HeaderWriter header,DirectBuffer buffer,int offset,int length,ReservedValueSupplier reservedValueSupplier,int activeTermId,int appendUnfragmentedMessage,HeaderWriter header,DirectBufferVector[] vectors,int length,ReservedValueSupplier reservedValueSupplier,int activeTermId){\r\n    final int frameLength = length + HEADER_LENGTH;\r\n    final int alignedLength = align(frameLength, FRAME_ALIGNMENT);\r\n    final UnsafeBuffer termBuffer = this.termBuffer;\r\n    final int termLength = termBuffer.capacity();\r\n    final long rawTail = getAndAddRawTail(alignedLength);\r\n    final int termId = termId(rawTail);\r\n    final long termOffset = rawTail & 0xFFFF_FFFFL;\r\n    checkTerm(activeTermId, termId);\r\n    long resultingOffset = termOffset + alignedLength;\r\n    if (resultingOffset > termLength) {\r\n        resultingOffset = handleEndOfLogCondition(termBuffer, termOffset, header, termLength, termId);\r\n    } else {\r\n        final int frameOffset = (int) termOffset;\r\n        header.write(termBuffer, frameOffset, frameLength, termId);\r\n        int offset = frameOffset + HEADER_LENGTH;\r\n        for (final DirectBufferVector vector : vectors) {\r\n            termBuffer.putBytes(offset, vector.buffer, vector.offset, vector.length);\r\n            offset += vector.length;\r\n        }\r\n        if (null != reservedValueSupplier) {\r\n            final long reservedValue = reservedValueSupplier.get(termBuffer, frameOffset, frameLength);\r\n            termBuffer.putLong(frameOffset + RESERVED_VALUE_OFFSET, reservedValue, LITTLE_ENDIAN);\r\n        }\r\n        frameLengthOrdered(termBuffer, frameOffset, frameLength);\r\n    }\r\n    return (int) resultingOffset;\r\n}"
}, {
	"Path": "org.bitcoinj.core.Transaction.getOutputSum",
	"Comment": "gets the sum of the outputs of the transaction. if the outputs are less than the inputs, it does not count the fee.",
	"Method": "Coin getOutputSum(){\r\n    Coin totalOut = Coin.ZERO;\r\n    for (TransactionOutput output : outputs) {\r\n        totalOut = totalOut.add(output.getValue());\r\n    }\r\n    return totalOut;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.BasicKeyChain.findOldestKeyAfter",
	"Comment": "returns the first eckey created after the given unix time, or null if there is none.",
	"Method": "ECKey findOldestKeyAfter(long timeSecs){\r\n    lock.lock();\r\n    try {\r\n        ECKey oldest = null;\r\n        for (ECKey key : hashToKeys.values()) {\r\n            final long keyTime = key.getCreationTimeSeconds();\r\n            if (keyTime > timeSecs) {\r\n                if (oldest == null || oldest.getCreationTimeSeconds() > keyTime)\r\n                    oldest = key;\r\n            }\r\n        }\r\n        return oldest;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.removeCoinsReceivedEventListener",
	"Comment": "removes the given event listener object. returns true if the listener was removed, false if that listenerwas never added.",
	"Method": "boolean removeCoinsReceivedEventListener(WalletCoinsReceivedEventListener listener){\r\n    return ListenerRegistration.removeFromList(listener, coinsReceivedListeners);\r\n}"
}, {
	"Path": "io.aeron.exceptions.ChannelEndpointException.statusIndicatorId",
	"Comment": "return the id for the counter associated with the channel endpoint.",
	"Method": "int statusIndicatorId(){\r\n    return statusIndicatorId;\r\n}"
}, {
	"Path": "org.bitcoinj.core.Base58.encodeChecked",
	"Comment": "encodes the given version and bytes as a base58 string. a checksum is appended.",
	"Method": "String encodeChecked(int version,byte[] payload){\r\n    if (version < 0 || version > 255)\r\n        throw new IllegalArgumentException(\"Version not in range.\");\r\n    byte[] addressBytes = new byte[1 + payload.length + 4];\r\n    addressBytes[0] = (byte) version;\r\n    System.arraycopy(payload, 0, addressBytes, 1, payload.length);\r\n    byte[] checksum = Sha256Hash.hashTwice(addressBytes, 0, payload.length + 1);\r\n    System.arraycopy(checksum, 0, addressBytes, payload.length + 1, 4);\r\n    return Base58.encode(addressBytes);\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.DeterministicKeyChain.isMarried",
	"Comment": "whether the keychain is married.a keychain is married when it vends p2sh addressesfrom multiple keychains in a multisig relationship.",
	"Method": "boolean isMarried(){\r\n    return false;\r\n}"
}, {
	"Path": "org.bitcoinj.core.RejectedTransactionException.getTransaction",
	"Comment": "return the original transaction object whose broadcast was rejected.",
	"Method": "Transaction getTransaction(){\r\n    return tx;\r\n}"
}, {
	"Path": "org.bitcoinj.protocols.payments.PaymentSession.getPaymentRequest",
	"Comment": "returns the protobuf that this object was instantiated with.",
	"Method": "Protos.PaymentRequest getPaymentRequest(){\r\n    return paymentRequest;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.DeterministicKeyChain.isWatching",
	"Comment": "returns true if this chain is watch only, meaning it has public keys but no private key.",
	"Method": "boolean isWatching(){\r\n    return getWatchingKey().isWatching();\r\n}"
}, {
	"Path": "org.bitcoinj.store.DatabaseFullPrunedBlockStore.getCompatibilitySQL",
	"Comment": "get the sql statements to check if the database is compatible.",
	"Method": "List<String> getCompatibilitySQL(){\r\n    List<String> sqlStatements = new ArrayList();\r\n    sqlStatements.add(SELECT_COMPATIBILITY_COINBASE_SQL);\r\n    return sqlStatements;\r\n}"
}, {
	"Path": "io.aeron.archive.client.ArchiveProxy.truncateRecording",
	"Comment": "truncate a stopped recording to a given position that is less than the stopped position. the provided positionmust be on a fragment boundary. truncating a recording to the start position effectively deletes the recording.",
	"Method": "boolean truncateRecording(long recordingId,long position,long correlationId,long controlSessionId){\r\n    truncateRecordingRequestEncoder.wrapAndApplyHeader(buffer, 0, messageHeaderEncoder).controlSessionId(controlSessionId).correlationId(correlationId).recordingId(recordingId).position(position);\r\n    return offer(truncateRecordingRequestEncoder.encodedLength());\r\n}"
}, {
	"Path": "org.bitcoinj.core.Block.getWork",
	"Comment": "returns the work represented by this block.work is defined as the number of tries needed to solve a block in theaverage case. consider a difficulty target that covers 5% of all possiblehash values. then the work of the block will be 20. as the target getslower, the amount of work goes up.",
	"Method": "BigInteger getWork(){\r\n    BigInteger target = getDifficultyTargetAsInteger();\r\n    return LARGEST_HASH.divide(target.add(BigInteger.ONE));\r\n}"
}, {
	"Path": "org.bitcoinj.core.Transaction.setHash",
	"Comment": "used by bitcoinserializer.the serializer has to calculate a hash for checksumming so toavoid wasting the considerable effort a set method is provided so the serializer can set it.no verification is performed on this hash.",
	"Method": "void setHash(Sha256Hash hash){\r\n    this.hash = hash;\r\n}"
}, {
	"Path": "algo.ReservoirSampling.getRandom",
	"Comment": "return k random elements from given stream without using any extra space.assume k is valid",
	"Method": "int[] getRandom(int[] stream,int k){\r\n    int[] result = new int[k];\r\n    int i;\r\n    for (i = 0; i < k; i++) {\r\n        result[i] = stream[i];\r\n    }\r\n    for (; i < stream.length; i++) {\r\n        int rand = (int) (Math.random() * (i + 1));\r\n        if (rand < k) {\r\n            result[rand] = stream[i];\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "io.aeron.cluster.ClusterMember.isNotDuplicateEndpoints",
	"Comment": "is the string of member endpoints not duplicated in the members.",
	"Method": "boolean isNotDuplicateEndpoints(ClusterMember[] members,String memberEndpoints){\r\n    for (final ClusterMember member : members) {\r\n        if (member.endpointsDetail().equals(memberEndpoints)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "io.aeron.ChannelUriStringBuilder.termOffset",
	"Comment": "get the offset within a term at which a publication will start.",
	"Method": "ChannelUriStringBuilder termOffset(Integer termOffset,Integer termOffset){\r\n    return termOffset;\r\n}"
}, {
	"Path": "org.bitcoinj.core.StoredBlock.moreWorkThan",
	"Comment": "returns true if this objects chainwork is higher than the others.",
	"Method": "boolean moreWorkThan(StoredBlock other){\r\n    return chainWork.compareTo(other.chainWork) > 0;\r\n}"
}, {
	"Path": "org.bitcoinj.core.ECKey.fromPrivateAndPrecalculatedPublic",
	"Comment": "creates an eckey that simply trusts the caller to ensure that point is really the result of multiplying thegenerator point by the private key. this is used to speed things up when you know you have the right valuesalready. the compression state of the point will be preserved.",
	"Method": "ECKey fromPrivateAndPrecalculatedPublic(BigInteger priv,ECPoint pub,ECKey fromPrivateAndPrecalculatedPublic,byte[] priv,byte[] pub){\r\n    checkNotNull(priv);\r\n    checkNotNull(pub);\r\n    return new ECKey(new BigInteger(1, priv), CURVE.getCurve().decodePoint(pub));\r\n}"
}, {
	"Path": "org.bitcoinj.core.Transaction.getValueSentToMe",
	"Comment": "calculates the sum of the outputs that are sending coins to a key in the wallet.",
	"Method": "Coin getValueSentToMe(TransactionBag transactionBag){\r\n    Coin v = Coin.ZERO;\r\n    for (TransactionOutput o : outputs) {\r\n        if (!o.isMineOrWatched(transactionBag))\r\n            continue;\r\n        v = v.add(o.getValue());\r\n    }\r\n    return v;\r\n}"
}, {
	"Path": "org.atmosphere.handler.ReflectorServletProcessor.addFilterClassName",
	"Comment": "add a filterclass. since we are using reflection to call this method,what we are really doing is addfilterclass.",
	"Method": "void addFilterClassName(String filterClass,String filterName){\r\n    if (filterClass == null || filterName == null)\r\n        return;\r\n    filtersClassAndNames.put(filterClass, filterName);\r\n}"
}, {
	"Path": "org.bitcoinj.core.MessageSerializer.makeBlock",
	"Comment": "make a block from the payload, using an offset of zero and the providedlength as block length. extension point for alternativeserialization format support.",
	"Method": "Block makeBlock(byte[] payloadBytes,Block makeBlock,byte[] payloadBytes,int length,Block makeBlock,byte[] payloadBytes,int offset,int length){\r\n    return makeBlock(payloadBytes, 0, length);\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.fromWatchingKey",
	"Comment": "creates a wallet that tracks payments to and from the hd key hierarchy rooted by the given watching key.",
	"Method": "Wallet fromWatchingKey(NetworkParameters params,DeterministicKey watchKey){\r\n    return new Wallet(params, new KeyChainGroup(params, watchKey));\r\n}"
}, {
	"Path": "io.aeron.cluster.ClusterMember.correlationId",
	"Comment": "correlation id assigned to the current action undertaken by the cluster member.",
	"Method": "ClusterMember correlationId(long correlationId,long correlationId){\r\n    return changeCorrelationId;\r\n}"
}, {
	"Path": "org.bitcoinj.core.AlertMessage.getComment",
	"Comment": "this field is unused. it is presumably intended for the author of the alert to provide a justification for itvisible to protocol developers but not users.",
	"Method": "String getComment(){\r\n    return comment;\r\n}"
}, {
	"Path": "io.aeron.DirectBufferVector.validateAndComputeLength",
	"Comment": "validate an array of vectors to make up a message and compute the total length.",
	"Method": "int validateAndComputeLength(DirectBufferVector[] vectors){\r\n    int messageLength = 0;\r\n    for (final DirectBufferVector vector : vectors) {\r\n        vector.validate();\r\n        messageLength += vector.length;\r\n        if (messageLength < 0) {\r\n            throw new IllegalStateException(\"length overflow: \" + Arrays.toString(vectors));\r\n        }\r\n    }\r\n    return messageLength;\r\n}"
}, {
	"Path": "problems.medium.ShuffleanArray.reset",
	"Comment": "resets the array to its original configuration and return it.",
	"Method": "int[] reset(){\r\n    return nums;\r\n}"
}, {
	"Path": "org.atmosphere.util.Utils.requestScopedInjection",
	"Comment": "inject custom object. this method is mostly for external framework.",
	"Method": "boolean requestScopedInjection(AtmosphereConfig config,AtmosphereHandler h,boolean requestScopedInjection,AtmosphereConfig config,Object o){\r\n    AtmosphereObjectFactory injectableFactory = config.framework().objectFactory();\r\n    if (!InjectableObjectFactory.class.isAssignableFrom(injectableFactory.getClass())) {\r\n        return false;\r\n    }\r\n    try {\r\n        return InjectableObjectFactory.class.cast(config.framework().objectFactory()).needRequestScoped(o.getClass());\r\n    } catch (Exception var4) {\r\n        LOGGER.error(\"\", var4);\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "io.aeron.CommonContext.aeronDirectoryName",
	"Comment": "set the top level aeron directory used for communication between the client and media driver, and the locationof the data buffers.",
	"Method": "String aeronDirectoryName(CommonContext aeronDirectoryName,String dirName){\r\n    this.aeronDirectoryName = dirName;\r\n    return this;\r\n}"
}, {
	"Path": "io.aeron.cluster.ClusterMember.removalPosition",
	"Comment": "the log position as of appending the event to be removed from the cluster.",
	"Method": "ClusterMember removalPosition(long removalPosition,long removalPosition){\r\n    return removalPosition;\r\n}"
}, {
	"Path": "org.bitcoinj.utils.BlockFileLoader.getReferenceClientBlockFileList",
	"Comment": "gets the list of files which contain blocks from bitcoin core.",
	"Method": "List<File> getReferenceClientBlockFileList(File blocksDir,List<File> getReferenceClientBlockFileList){\r\n    return getReferenceClientBlockFileList(defaultBlocksDir());\r\n}"
}, {
	"Path": "org.bitcoinj.core.TransactionOutPoint.getConnectedRedeemData",
	"Comment": "returns the redeemdata identified in the connected output, for either p2pkh scripts, p2pkor p2sh scripts.if the script forms cannot be understood, throws scriptexception.",
	"Method": "RedeemData getConnectedRedeemData(KeyBag keyBag){\r\n    TransactionOutput connectedOutput = getConnectedOutput();\r\n    checkNotNull(connectedOutput, \"Input is not connected so cannot retrieve key\");\r\n    Script connectedScript = connectedOutput.getScriptPubKey();\r\n    if (ScriptPattern.isPayToPubKeyHash(connectedScript)) {\r\n        byte[] addressBytes = ScriptPattern.extractHashFromPayToPubKeyHash(connectedScript);\r\n        return RedeemData.of(keyBag.findKeyFromPubHash(addressBytes), connectedScript);\r\n    } else if (ScriptPattern.isPayToPubKey(connectedScript)) {\r\n        byte[] pubkeyBytes = ScriptPattern.extractKeyFromPayToPubKey(connectedScript);\r\n        return RedeemData.of(keyBag.findKeyFromPubKey(pubkeyBytes), connectedScript);\r\n    } else if (ScriptPattern.isPayToScriptHash(connectedScript)) {\r\n        byte[] scriptHash = ScriptPattern.extractHashFromPayToScriptHash(connectedScript);\r\n        return keyBag.findRedeemDataFromScriptHash(scriptHash);\r\n    } else {\r\n        throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, \"Could not understand form of connected output script: \" + connectedScript);\r\n    }\r\n}"
}, {
	"Path": "commons.validator.routines.EmailValidator.isValidDomain",
	"Comment": "returns true if the domain component of an email address is valid.",
	"Method": "boolean isValidDomain(String domain){\r\n    Matcher ipDomainMatcher = IP_DOMAIN_PATTERN.matcher(domain);\r\n    if (ipDomainMatcher.matches()) {\r\n        InetAddressValidator inetAddressValidator = InetAddressValidator.getInstance();\r\n        return inetAddressValidator.isValid(ipDomainMatcher.group(1));\r\n    }\r\n    DomainValidator domainValidator = DomainValidator.getInstance(allowLocal);\r\n    return domainValidator.isValid(domain) || domainValidator.isValidTld(domain);\r\n}"
}, {
	"Path": "com.mobsandgeeks.saripaar.tests.OrderedValidateTest.testField",
	"Comment": "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ private methods~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
	"Method": "void testField(int viewId,String textToType,String text){\r\n    EspressoHelper.type(viewId, textToType);\r\n    EspressoHelper.clickView(R.id.saripaarButton);\r\n    EspressoHelper.checkForText(text, mResultTextView);\r\n}"
}, {
	"Path": "org.bitcoinj.core.CheckpointManager.checkpoint",
	"Comment": "convenience method that creates a checkpointmanager, loads the given data, gets the checkpoint for the giventime, then inserts it into the store and sets that to be the chain head. useful when you have just createda new store from scratch and want to use configure it all in one go.note that time is adjusted backwards by a week to account for possible clock drift in the block headers.",
	"Method": "void checkpoint(NetworkParameters params,InputStream checkpoints,BlockStore store,long time){\r\n    checkNotNull(params);\r\n    checkNotNull(store);\r\n    checkArgument(!(store instanceof FullPrunedBlockStore), \"You cannot use checkpointing with a full store.\");\r\n    time -= 86400 * 7;\r\n    checkArgument(time > 0);\r\n    log.info(\"Attempting to initialize a new block store with a checkpoint for time {} ({})\", time, Utils.dateTimeFormat(time * 1000));\r\n    BufferedInputStream stream = new BufferedInputStream(checkpoints);\r\n    CheckpointManager manager = new CheckpointManager(params, stream);\r\n    StoredBlock checkpoint = manager.getCheckpointBefore(time);\r\n    store.put(checkpoint);\r\n    store.setChainHead(checkpoint);\r\n}"
}, {
	"Path": "org.bitcoinj.protocols.payments.PaymentSession.getExpires",
	"Comment": "returns the expires time of the payment request, or null if none.",
	"Method": "Date getExpires(){\r\n    if (paymentDetails.hasExpires())\r\n        return new Date(paymentDetails.getExpires() * 1000);\r\n    else\r\n        return null;\r\n}"
}, {
	"Path": "io.aeron.driver.LossDetector.pack",
	"Comment": "pack the values for workcount and rebuildoffset into a long for returning on the stack.",
	"Method": "long pack(int rebuildOffset,boolean lossFound){\r\n    return ((long) rebuildOffset << 32) | (lossFound ? 1 : 0);\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.fromKeys",
	"Comment": "creates a wallet containing a given set of keys. all further keys will be derived from the oldest key.",
	"Method": "Wallet fromKeys(NetworkParameters params,List<ECKey> keys){\r\n    for (ECKey key : keys) checkArgument(!(key instanceof DeterministicKey));\r\n    KeyChainGroup group = new KeyChainGroup(params);\r\n    group.importKeys(keys);\r\n    return new Wallet(params, group);\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.getPendingTransactions",
	"Comment": "returns an immutable view of the transactions currently waiting for network confirmations.",
	"Method": "Collection<Transaction> getPendingTransactions(){\r\n    lock.lock();\r\n    try {\r\n        return Collections.unmodifiableCollection(pending.values());\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "io.aeron.Publication.sessionId",
	"Comment": "session under which messages are published. identifies this publication instance. sessions are unique acrossall active publications on a driver instance.",
	"Method": "int sessionId(){\r\n    return sessionId;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.DeterministicKeyChain.getIssuedExternalKeys",
	"Comment": "returns number of keys used on external path. this may be fewer than the number that have been deserializedor held in memory, because of the lookahead zone.",
	"Method": "int getIssuedExternalKeys(){\r\n    lock.lock();\r\n    try {\r\n        return issuedExternalKeys;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "io.aeron.Publication.maxMessageLength",
	"Comment": "maximum message length supported in bytes. messages may be made of multiple fragments if greater thanmtu length.",
	"Method": "int maxMessageLength(){\r\n    return maxMessageLength;\r\n}"
}, {
	"Path": "io.aeron.ChannelUriStringBuilder.validate",
	"Comment": "validates that the collection of set parameters are valid together.",
	"Method": "ChannelUriStringBuilder validate(){\r\n    if (null == media) {\r\n        throw new IllegalStateException(\"media type is mandatory\");\r\n    }\r\n    if (CommonContext.UDP_MEDIA.equals(media) && (null == endpoint && null == controlEndpoint)) {\r\n        throw new IllegalStateException(\"either 'endpoint' or 'control' must be specified for UDP.\");\r\n    }\r\n    int count = 0;\r\n    count += null == initialTermId ? 0 : 1;\r\n    count += null == termId ? 0 : 1;\r\n    count += null == termOffset ? 0 : 1;\r\n    if (count > 0 && count < 3) {\r\n        throw new IllegalStateException(\"if any of then a complete set of 'initialTermId', 'termId', and 'termOffset' must be provided\");\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "io.aeron.driver.status.StreamPositionCounter.allocate",
	"Comment": "allocate a counter for tracking a position on a stream of messages.",
	"Method": "UnsafeBufferPosition allocate(MutableDirectBuffer tempBuffer,String name,int typeId,CountersManager countersManager,long registrationId,int sessionId,int streamId,String channel,UnsafeBufferPosition allocate,MutableDirectBuffer tempBuffer,String name,int typeId,CountersManager countersManager,long registrationId,int sessionId,int streamId,String channel,long joinPosition){\r\n    tempBuffer.putLong(REGISTRATION_ID_OFFSET, registrationId);\r\n    tempBuffer.putInt(SESSION_ID_OFFSET, sessionId);\r\n    tempBuffer.putInt(STREAM_ID_OFFSET, streamId);\r\n    final int channelLength = tempBuffer.putStringWithoutLengthAscii(CHANNEL_OFFSET + SIZE_OF_INT, channel, 0, MAX_CHANNEL_LENGTH);\r\n    tempBuffer.putInt(CHANNEL_OFFSET, channelLength);\r\n    final int keyLength = CHANNEL_OFFSET + SIZE_OF_INT + channelLength;\r\n    final int labelOffset = BitUtil.align(keyLength, SIZE_OF_INT);\r\n    int labelLength = 0;\r\n    labelLength += tempBuffer.putStringWithoutLengthAscii(labelOffset + labelLength, name);\r\n    labelLength += tempBuffer.putStringWithoutLengthAscii(labelOffset + labelLength, \": \");\r\n    labelLength += tempBuffer.putLongAscii(labelOffset + labelLength, registrationId);\r\n    labelLength += tempBuffer.putStringWithoutLengthAscii(labelOffset + labelLength, \" \");\r\n    labelLength += tempBuffer.putIntAscii(labelOffset + labelLength, sessionId);\r\n    labelLength += tempBuffer.putStringWithoutLengthAscii(labelOffset + labelLength, \" \");\r\n    labelLength += tempBuffer.putIntAscii(labelOffset + labelLength, streamId);\r\n    labelLength += tempBuffer.putStringWithoutLengthAscii(labelOffset + labelLength, \" \");\r\n    labelLength += tempBuffer.putStringWithoutLengthAscii(labelOffset + labelLength, channel, 0, MAX_LABEL_LENGTH - labelLength);\r\n    if (labelLength < (MAX_LABEL_LENGTH - 20)) {\r\n        labelLength += tempBuffer.putStringWithoutLengthAscii(labelOffset + labelLength, \" @\");\r\n        labelLength += tempBuffer.putLongAscii(labelOffset + labelLength, joinPosition);\r\n    }\r\n    final int counterId = countersManager.allocate(typeId, tempBuffer, 0, keyLength, tempBuffer, labelOffset, labelLength);\r\n    return new UnsafeBufferPosition((UnsafeBuffer) countersManager.valuesBuffer(), counterId, countersManager);\r\n}"
}, {
	"Path": "org.bitcoinj.core.TransactionOutput.isDust",
	"Comment": "will this transaction be relayable and mined by default miners?",
	"Method": "boolean isDust(){\r\n    if (ScriptPattern.isOpReturn(getScriptPubKey()))\r\n        return false;\r\n    return getValue().isLessThan(getMinNonDustValue());\r\n}"
}, {
	"Path": "io.aeron.logbuffer.LogBufferDescriptor.rawTailVolatile",
	"Comment": "get the raw value of the tail for the current active partition.",
	"Method": "void rawTailVolatile(UnsafeBuffer logMetaDataBuffer,int partitionIndex,long rawTail,long rawTailVolatile,UnsafeBuffer logMetaDataBuffer,int partitionIndex,long rawTailVolatile,UnsafeBuffer logMetaDataBuffer){\r\n    final int partitionIndex = indexByTermCount(activeTermCount(logMetaDataBuffer));\r\n    return logMetaDataBuffer.getLongVolatile(TERM_TAIL_COUNTERS_OFFSET + (SIZE_OF_LONG * partitionIndex));\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.getTransaction",
	"Comment": "returns a transaction object given its hash, if it exists in this wallet, or null otherwise.",
	"Method": "Transaction getTransaction(Sha256Hash hash){\r\n    lock.lock();\r\n    try {\r\n        return transactions.get(hash);\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.maybeRotateKeys",
	"Comment": "checks to see if any coins are controlled by rotating keys and if so, spends them.",
	"Method": "List<Transaction> maybeRotateKeys(KeyParameter aesKey,boolean sign){\r\n    checkState(lock.isHeldByCurrentThread());\r\n    checkState(keyChainGroupLock.isHeldByCurrentThread());\r\n    List<Transaction> results = Lists.newLinkedList();\r\n    final long keyRotationTimestamp = vKeyRotationTimestamp;\r\n    if (keyRotationTimestamp == 0)\r\n        return results;\r\n    boolean allChainsRotating = true;\r\n    for (DeterministicKeyChain chain : keyChainGroup.getDeterministicKeyChains()) {\r\n        if (chain.getEarliestKeyCreationTime() >= keyRotationTimestamp) {\r\n            allChainsRotating = false;\r\n            break;\r\n        }\r\n    }\r\n    if (allChainsRotating) {\r\n        try {\r\n            if (keyChainGroup.getImportedKeys().isEmpty()) {\r\n                log.info(\"All HD chains are currently rotating and we have no random keys, creating fresh HD chain ...\");\r\n                keyChainGroup.createAndActivateNewHDChain();\r\n            } else {\r\n                log.info(\"All HD chains are currently rotating, attempting to create a new one from the next oldest non-rotating key material ...\");\r\n                keyChainGroup.upgradeToDeterministic(keyRotationTimestamp, aesKey);\r\n                log.info(\" ... upgraded to HD again, based on next best oldest key.\");\r\n            }\r\n        } catch (AllRandomKeysRotating rotating) {\r\n            log.info(\" ... no non-rotating random keys available, generating entirely new HD tree: backup required after this.\");\r\n            keyChainGroup.createAndActivateNewHDChain();\r\n        }\r\n        saveNow();\r\n    }\r\n    Transaction tx;\r\n    do {\r\n        tx = rekeyOneBatch(keyRotationTimestamp, aesKey, results, sign);\r\n        if (tx != null)\r\n            results.add(tx);\r\n    } while (tx != null && tx.getInputs().size() == KeyTimeCoinSelector.MAX_SIMULTANEOUS_INPUTS);\r\n    return results;\r\n}"
}, {
	"Path": "com.github.pedrovgs.problem48.WordSearch.isWordInWordSearchInner",
	"Comment": "this could be better if you put every check if the same line with the return becauseyou are going to check in different directions until you find it instead of check the 8different possibilities.",
	"Method": "boolean isWordInWordSearchInner(char[][] wordSearch,String word,int x,int y){\r\n    if (word.isEmpty()) {\r\n        return true;\r\n    } else {\r\n        boolean firstLetter = matches(wordSearch, x, y, word.charAt(0));\r\n        if (firstLetter) {\r\n            boolean left = isWordInWordSearchInner(wordSearch, word.substring(1), x - 1, y);\r\n            boolean right = isWordInWordSearchInner(wordSearch, word.substring(1), x + 1, y);\r\n            boolean bottom = isWordInWordSearchInner(wordSearch, word.substring(1), x, y + 1);\r\n            boolean top = isWordInWordSearchInner(wordSearch, word.substring(1), x, y - 1);\r\n            boolean topLeft = isWordInWordSearchInner(wordSearch, word.substring(1), x - 1, y - 1);\r\n            boolean topRight = isWordInWordSearchInner(wordSearch, word.substring(1), x + 1, y - 1);\r\n            boolean bottomLeft = isWordInWordSearchInner(wordSearch, word.substring(1), x - 1, y + 1);\r\n            boolean bottomRight = isWordInWordSearchInner(wordSearch, word.substring(1), x + 1, y + 1);\r\n            return left || right || bottom || top || topLeft || topRight || bottomLeft || bottomRight;\r\n        }\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.Transaction.getValueSentFromMe",
	"Comment": "calculates the sum of the inputs that are spending coins with keys in the wallet. this requires thetransactions sending coins to those keys to be in the wallet. this method will not attempt to download theblocks containing the input transactions if the key is in the wallet but the transactions are not.",
	"Method": "Coin getValueSentFromMe(TransactionBag wallet){\r\n    Coin v = Coin.ZERO;\r\n    for (TransactionInput input : inputs) {\r\n        TransactionOutput connected = input.getConnectedOutput(wallet.getTransactionPool(Pool.UNSPENT));\r\n        if (connected == null)\r\n            connected = input.getConnectedOutput(wallet.getTransactionPool(Pool.SPENT));\r\n        if (connected == null)\r\n            connected = input.getConnectedOutput(wallet.getTransactionPool(Pool.PENDING));\r\n        if (connected == null)\r\n            continue;\r\n        if (!connected.isMineOrWatched(wallet))\r\n            continue;\r\n        v = v.add(connected.getValue());\r\n    }\r\n    return v;\r\n}"
}, {
	"Path": "org.bitcoinj.core.Block.getVersion",
	"Comment": "returns the version of the block data structure as defined by the bitcoin protocol.",
	"Method": "long getVersion(){\r\n    return version;\r\n}"
}, {
	"Path": "org.atmosphere.runtime.DefaultBroadcaster.cacheAndSuspend",
	"Comment": "look in the cache to see if there are messages available, and take the appropriate actions.",
	"Method": "void cacheAndSuspend(AtmosphereResource r){\r\n    if (!isAtmosphereResourceValid(r)) {\r\n        logger.debug(\"Unable to add AtmosphereResource {}\", r.uuid());\r\n        return;\r\n    }\r\n    boolean wasResumed = checkCachedAndPush(r, r.getAtmosphereResourceEvent());\r\n    if (!wasResumed && isAtmosphereResourceValid(r)) {\r\n        logger.trace(\"Associating AtmosphereResource {} with Broadcaster {}\", r.uuid(), getID());\r\n        String parentUUID = r.transport().equals(AtmosphereResource.TRANSPORT.WEBSOCKET) ? (String) AtmosphereResourceImpl.class.cast(r).getRequest(false).getAttribute(SUSPENDED_ATMOSPHERE_RESOURCE_UUID) : null;\r\n        if (!backwardCompatible && parentUUID != null) {\r\n            AtmosphereResource p = config.resourcesFactory().find(parentUUID);\r\n            if (p != null && !resources.contains(p)) {\r\n                notifyAndAdd(p);\r\n            } else if (p == null) {\r\n                notifyAndAdd(r);\r\n            } else {\r\n                logger.trace(\"AtmosphereResource {} was already mapped to {}\", r.uuid(), parentUUID);\r\n            }\r\n        } else {\r\n            notifyAndAdd(r);\r\n        }\r\n    } else if (!wasResumed) {\r\n        logger.debug(\"Unable to add AtmosphereResource {} to {}\", r.uuid(), name);\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.AbstractBlockChain.isOrphan",
	"Comment": "returns true if the given block is currently in the orphan blocks list.",
	"Method": "boolean isOrphan(Sha256Hash block){\r\n    lock.lock();\r\n    try {\r\n        return orphanBlocks.containsKey(block);\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.ECKey.isPubKeyCanonical",
	"Comment": "returns true if the given pubkey is canonical, i.e. the correct length taking into account compression.",
	"Method": "boolean isPubKeyCanonical(byte[] pubkey){\r\n    if (pubkey.length < 33)\r\n        return false;\r\n    if (pubkey[0] == 0x04) {\r\n        if (pubkey.length != 65)\r\n            return false;\r\n    } else if (pubkey[0] == 0x02 || pubkey[0] == 0x03) {\r\n        if (pubkey.length != 33)\r\n            return false;\r\n    } else\r\n        return false;\r\n    return true;\r\n}"
}, {
	"Path": "io.aeron.Publication.originalRegistrationId",
	"Comment": "get the registration used to register this publication with the media driver by the first publisher.",
	"Method": "long originalRegistrationId(){\r\n    return originalRegistrationId;\r\n}"
}, {
	"Path": "io.aeron.ChannelUriStringBuilder.prefix",
	"Comment": "get the prefix for the additional action to be taken on the request.",
	"Method": "ChannelUriStringBuilder prefix(String prefix,String prefix){\r\n    return prefix;\r\n}"
}, {
	"Path": "io.aeron.driver.Configuration.validateSocketBufferLengths",
	"Comment": "validate that the socket buffer lengths are sufficient for the media driver configuration.",
	"Method": "void validateSocketBufferLengths(MediaDriver.Context ctx){\r\n    try (DatagramChannel probe = DatagramChannel.open()) {\r\n        final int defaultSoSndBuf = probe.getOption(StandardSocketOptions.SO_SNDBUF);\r\n        probe.setOption(StandardSocketOptions.SO_SNDBUF, Integer.MAX_VALUE);\r\n        final int maxSoSndBuf = probe.getOption(StandardSocketOptions.SO_SNDBUF);\r\n        if (maxSoSndBuf < SOCKET_SNDBUF_LENGTH) {\r\n            System.err.format(\"WARNING: Could not get desired SO_SNDBUF, adjust OS to allow %s: attempted=%d, actual=%d%n\", SOCKET_SNDBUF_LENGTH_PROP_NAME, SOCKET_SNDBUF_LENGTH, maxSoSndBuf);\r\n        }\r\n        probe.setOption(StandardSocketOptions.SO_RCVBUF, Integer.MAX_VALUE);\r\n        final int maxSoRcvBuf = probe.getOption(StandardSocketOptions.SO_RCVBUF);\r\n        if (maxSoRcvBuf < SOCKET_RCVBUF_LENGTH) {\r\n            System.err.format(\"WARNING: Could not get desired SO_RCVBUF, adjust OS to allow %s: attempted=%d, actual=%d%n\", SOCKET_RCVBUF_LENGTH_PROP_NAME, SOCKET_RCVBUF_LENGTH, maxSoRcvBuf);\r\n        }\r\n        final int soSndBuf = 0 == SOCKET_SNDBUF_LENGTH ? defaultSoSndBuf : SOCKET_SNDBUF_LENGTH;\r\n        if (ctx.mtuLength() > soSndBuf) {\r\n            throw new ConfigurationException(String.format(\"MTU greater than socket SO_SNDBUF, adjust %s to match MTU: mtuLength=%d, SO_SNDBUF=%d\", SOCKET_SNDBUF_LENGTH_PROP_NAME, ctx.mtuLength(), soSndBuf));\r\n        }\r\n        if (ctx.initialWindowLength() > maxSoRcvBuf) {\r\n            throw new ConfigurationException(\"Window length greater than socket SO_RCVBUF, increase '\" + Configuration.INITIAL_WINDOW_LENGTH_PROP_NAME + \"' to match window: windowLength=\" + ctx.initialWindowLength() + \", SO_RCVBUF=\" + maxSoRcvBuf);\r\n        }\r\n    } catch (final IOException ex) {\r\n        throw new RuntimeException(\"probe socket: \" + ex.toString(), ex);\r\n    }\r\n}"
}, {
	"Path": "problems.medium.EvaluateReversePolishNotation.evalRPN",
	"Comment": "to solve this problem, i used stack. if the array element is operator, two elements from stack is poppedand do operation according to operator and push back to stack. in this way we calculate the whole expressionthe last stack element is result of expression",
	"Method": "int evalRPN(String[] tokens){\r\n    if (tokens.length == 0)\r\n        return 0;\r\n    Stack<String> stack = new Stack();\r\n    for (String token : tokens) {\r\n        if (token.length() == 1 && !Character.isDigit(token.charAt(0))) {\r\n            int f = Integer.parseInt(stack.pop());\r\n            int s = Integer.parseInt(stack.pop());\r\n            if (token.equals(\"+\"))\r\n                stack.push(String.valueOf(f + s));\r\n            else if (token.equals(\"/\"))\r\n                stack.push(String.valueOf(s / f));\r\n            else if (token.equals(\"*\"))\r\n                stack.push(String.valueOf(s * f));\r\n            else\r\n                stack.push(String.valueOf(s - f));\r\n        } else\r\n            stack.push(token);\r\n    }\r\n    return Integer.parseInt(stack.pop());\r\n}"
}, {
	"Path": "io.aeron.ControlledFragmentAssembler.delegate",
	"Comment": "get the delegate unto which assembled messages are delegated.",
	"Method": "ControlledFragmentHandler delegate(){\r\n    return delegate;\r\n}"
}, {
	"Path": "org.bitcoinj.core.TransactionConfidence.getAppearedAtChainHeight",
	"Comment": "returns the chain height at which the transaction appeared if confidence type is building.",
	"Method": "int getAppearedAtChainHeight(){\r\n    if (getConfidenceType() != ConfidenceType.BUILDING)\r\n        throw new IllegalStateException(\"Confidence type is \" + getConfidenceType() + \", not BUILDING\");\r\n    return appearedAtChainHeight;\r\n}"
}, {
	"Path": "io.aeron.driver.DriverManagedResource.free",
	"Comment": "free external resources such as files. if successful then return true.",
	"Method": "boolean free(){\r\n    return true;\r\n}"
}, {
	"Path": "io.aeron.Counter.close",
	"Comment": "close the counter, releasing the resource managed by the media driver if this was the creator of the counter.this method is idempotent.",
	"Method": "void close(){\r\n    if (!isClosed) {\r\n        if (null != clientConductor) {\r\n            clientConductor.releaseCounter(this);\r\n        } else {\r\n            isClosed = true;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.TransactionInput.getConnectedOutput",
	"Comment": "locates the referenced output from the given pool of transactions.",
	"Method": "TransactionOutput getConnectedOutput(Map<Sha256Hash, Transaction> transactions,TransactionOutput getConnectedOutput){\r\n    return getOutpoint().getConnectedOutput();\r\n}"
}, {
	"Path": "io.aeron.Aeron.isClosed",
	"Comment": "has the client been closed? if not then the cnc file may not be unmapped.",
	"Method": "boolean isClosed(){\r\n    return 1 == isClosed;\r\n}"
}, {
	"Path": "io.aeron.ChannelUri.entityTag",
	"Comment": "get the entity tag, if it exists, that refers to an entity such as subscription or publication.",
	"Method": "String entityTag(){\r\n    return (null != tags && tags.length > ENTITY_TAG_INDEX) ? tags[ENTITY_TAG_INDEX] : null;\r\n}"
}, {
	"Path": "org.bitcoinj.core.AlertMessage.getExpiration",
	"Comment": "the time at which the alert ceases to be relevant. it should not be presented to the user or app administratorafter this time.",
	"Method": "Date getExpiration(){\r\n    return expiration;\r\n}"
}, {
	"Path": "io.aeron.cluster.ClusterMember.isQuorumCandidate",
	"Comment": "has the member achieved a quorum view to be a suitable candidate in an election.",
	"Method": "boolean isQuorumCandidate(ClusterMember[] clusterMembers,ClusterMember candidate){\r\n    int possibleVotes = 0;\r\n    for (final ClusterMember member : clusterMembers) {\r\n        if (NULL_POSITION == member.logPosition || compareLog(candidate, member) < 0) {\r\n            continue;\r\n        }\r\n        ++possibleVotes;\r\n    }\r\n    return possibleVotes >= ClusterMember.quorumThreshold(clusterMembers.length);\r\n}"
}, {
	"Path": "io.aeron.CommonContext.generateRandomDirName",
	"Comment": "convert the default aeron directory name to be a random name for use with embedded drivers.",
	"Method": "String generateRandomDirName(){\r\n    return AERON_DIR_PROP_DEFAULT + '-' + UUID.randomUUID().toString();\r\n}"
}, {
	"Path": "io.aeron.logbuffer.BufferClaim.abort",
	"Comment": "abort a claim of the message space to the log buffer so that the log can progress by ignoring this claim.",
	"Method": "void abort(){\r\n    int frameLength = buffer.capacity();\r\n    if (ByteOrder.nativeOrder() != LITTLE_ENDIAN) {\r\n        frameLength = Integer.reverseBytes(frameLength);\r\n    }\r\n    buffer.putShort(TYPE_FIELD_OFFSET, (short) HDR_TYPE_PAD, LITTLE_ENDIAN);\r\n    buffer.putIntOrdered(FRAME_LENGTH_FIELD_OFFSET, frameLength);\r\n}"
}, {
	"Path": "com.mobsandgeeks.saripaar.Validator.assertNotNull",
	"Comment": "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ private methods~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
	"Method": "void assertNotNull(Object object,String argumentName){\r\n    if (object == null) {\r\n        String message = String.format(\"'%s' cannot be null.\", argumentName);\r\n        throw new IllegalArgumentException(message);\r\n    }\r\n}"
}, {
	"Path": "algo.graph.TopologicalSorting.topSort",
	"Comment": "sources can be found easier if incoming edge count is recorded in each vertex",
	"Method": "List<Integer> topSort(){\r\n    Set<Integer> sources = new HashSet();\r\n    for (Integer vertex : graph.getVertices()) sources.add(vertex);\r\n    for (Integer vertex : graph.getVertices()) for (Integer tVertex : graph.getNeighbors(vertex)) sources.remove(tVertex);\r\n    for (Integer source : sources) if (!visited.contains(source))\r\n        search(source);\r\n    return list;\r\n}"
}, {
	"Path": "io.aeron.logbuffer.TermAppender.rawTailVolatile",
	"Comment": "get the raw current tail value in a volatile memory ordering fashion.",
	"Method": "long rawTailVolatile(){\r\n    return UnsafeAccess.UNSAFE.getLongVolatile(null, tailAddressOffset);\r\n}"
}, {
	"Path": "org.bitcoinj.crypto.DeterministicKey.getChainCode",
	"Comment": "returns the chain code associated with this key. see the specification to learn more about chain codes.",
	"Method": "byte[] getChainCode(){\r\n    return chainCode;\r\n}"
}, {
	"Path": "org.bitcoinj.utils.MonetaryFormat.decimalMark",
	"Comment": "set character to use as the decimal mark. if the formatted value does not have any decimals, no decimal mark isused either.",
	"Method": "MonetaryFormat decimalMark(char decimalMark){\r\n    checkArgument(!Character.isDigit(decimalMark));\r\n    checkArgument(decimalMark > 0);\r\n    if (decimalMark == this.decimalMark)\r\n        return this;\r\n    else\r\n        return new MonetaryFormat(negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed);\r\n}"
}, {
	"Path": "org.bitcoinj.core.PeerGroup.setPeerDiscoveryTimeoutMillis",
	"Comment": "this is how many milliseconds we wait for peer discoveries to return their results.",
	"Method": "void setPeerDiscoveryTimeoutMillis(long peerDiscoveryTimeoutMillis){\r\n    this.vPeerDiscoveryTimeoutMillis = peerDiscoveryTimeoutMillis;\r\n}"
}, {
	"Path": "io.aeron.CommonContext.isDriverActive",
	"Comment": "is a media driver active in the current mapped cnc buffer? if the driver is mid start then it will wait forup to the drivertimeoutms by checking for the cncversion being set.",
	"Method": "boolean isDriverActive(File directory,long driverTimeoutMs,Consumer<String> logger,boolean isDriverActive,long driverTimeoutMs,Consumer<String> logger,boolean isDriverActive,long driverTimeoutMs,Consumer<String> logger,ByteBuffer cncByteBuffer){\r\n    if (null == cncByteBuffer) {\r\n        return false;\r\n    }\r\n    final UnsafeBuffer cncMetaDataBuffer = CncFileDescriptor.createMetaDataBuffer(cncByteBuffer);\r\n    final long startTimeMs = System.currentTimeMillis();\r\n    int cncVersion;\r\n    while (0 == (cncVersion = cncMetaDataBuffer.getIntVolatile(CncFileDescriptor.cncVersionOffset(0)))) {\r\n        if (System.currentTimeMillis() > (startTimeMs + driverTimeoutMs)) {\r\n            throw new DriverTimeoutException(\"CnC file is created but not initialised.\");\r\n        }\r\n        sleep(1);\r\n    }\r\n    if (CNC_VERSION != cncVersion) {\r\n        throw new AeronException(\"Aeron CnC version does not match: required=\" + CNC_VERSION + \" version=\" + cncVersion);\r\n    }\r\n    final ManyToOneRingBuffer toDriverBuffer = new ManyToOneRingBuffer(CncFileDescriptor.createToDriverBuffer(cncByteBuffer, cncMetaDataBuffer));\r\n    final long timestamp = toDriverBuffer.consumerHeartbeatTime();\r\n    final long now = System.currentTimeMillis();\r\n    final long timestampAge = now - timestamp;\r\n    logger.accept(\"INFO: Aeron toDriver consumer heartbeat is (ms): \" + timestampAge);\r\n    return timestampAge <= driverTimeoutMs;\r\n}"
}, {
	"Path": "org.bitcoinj.core.Utils.currentTimeMillis",
	"Comment": "returns the current time in milliseconds since the epoch, or a mocked out equivalent.",
	"Method": "long currentTimeMillis(){\r\n    return mockTime != null ? mockTime.getTime() : System.currentTimeMillis();\r\n}"
}, {
	"Path": "io.aeron.BufferBuilder.append",
	"Comment": "append a source buffer to the end of the internal buffer, resizing the internal buffer as required.",
	"Method": "BufferBuilder append(DirectBuffer srcBuffer,int srcOffset,int length){\r\n    ensureCapacity(length);\r\n    buffer.putBytes(limit, srcBuffer, srcOffset, length);\r\n    limit += length;\r\n    return this;\r\n}"
}, {
	"Path": "io.aeron.logbuffer.LogBufferDescriptor.indexByTerm",
	"Comment": "determine the partition index to be used given the initial term and active term ids.",
	"Method": "int indexByTerm(int initialTermId,int activeTermId){\r\n    return (activeTermId - initialTermId) % PARTITION_COUNT;\r\n}"
}, {
	"Path": "org.bitcoinj.core.Block.getNonce",
	"Comment": "returns the nonce, an arbitrary value that exists only to make the hash of the block header fall below thedifficulty target.",
	"Method": "long getNonce(){\r\n    return nonce;\r\n}"
}, {
	"Path": "io.aeron.logbuffer.LogBufferDescriptor.casRawTail",
	"Comment": "compare and set the raw value of the tail for the given partition.",
	"Method": "boolean casRawTail(UnsafeBuffer logMetaDataBuffer,int partitionIndex,long expectedRawTail,long updateRawTail){\r\n    final int index = TERM_TAIL_COUNTERS_OFFSET + (SIZE_OF_LONG * partitionIndex);\r\n    return logMetaDataBuffer.compareAndSetLong(index, expectedRawTail, updateRawTail);\r\n}"
}, {
	"Path": "org.bitcoinj.crypto.ChildNumber.i",
	"Comment": "returns the uint32 encoded form of the path element, including the most significant bit.",
	"Method": "int i(){\r\n    return i;\r\n}"
}, {
	"Path": "io.aeron.cluster.service.ClientSession.isClosing",
	"Comment": "indicates that a request to close this session has been made.",
	"Method": "boolean isClosing(){\r\n    return isClosing;\r\n}"
}, {
	"Path": "org.bitcoinj.core.ECKey.signMessage",
	"Comment": "signs a text message using the standard bitcoin messaging signing format and returns the signature as a base64encoded string.",
	"Method": "String signMessage(String message,String signMessage,String message,KeyParameter aesKey){\r\n    byte[] data = formatMessageForSigning(message);\r\n    Sha256Hash hash = Sha256Hash.twiceOf(data);\r\n    ECDSASignature sig = sign(hash, aesKey);\r\n    byte recId = findRecoveryId(hash, sig);\r\n    int headerByte = recId + 27 + (isCompressed() ? 4 : 0);\r\n    byte[] sigData = new byte[65];\r\n    sigData[0] = (byte) headerByte;\r\n    System.arraycopy(Utils.bigIntegerToBytes(sig.r, 32), 0, sigData, 1, 32);\r\n    System.arraycopy(Utils.bigIntegerToBytes(sig.s, 32), 0, sigData, 33, 32);\r\n    return new String(Base64.encode(sigData), StandardCharsets.UTF_8);\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.DeterministicKeyChain.setSigsRequiredToSpend",
	"Comment": "the number of signatures required to spend coins received by this keychain.",
	"Method": "void setSigsRequiredToSpend(int sigsRequiredToSpend){\r\n    this.sigsRequiredToSpend = sigsRequiredToSpend;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.getExtensions",
	"Comment": "returns a snapshot of all registered extension objects. the extensions themselves are not copied.",
	"Method": "Map<String, WalletExtension> getExtensions(){\r\n    lock.lock();\r\n    try {\r\n        return ImmutableMap.copyOf(extensions);\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "io.aeron.logbuffer.TermScanner.pack",
	"Comment": "pack the values for available and padding into a long for returning on the stack.",
	"Method": "long pack(int padding,int available){\r\n    return ((long) padding << 32) | available;\r\n}"
}, {
	"Path": "org.bitcoinj.core.PeerGroup.getMostCommonChainHeight",
	"Comment": "returns our peers most commonly reported chain height. if multiple heights are tied, the highest is returned.if no peers are connected, returns zero.",
	"Method": "int getMostCommonChainHeight(int getMostCommonChainHeight,List<Peer> peers){\r\n    if (peers.isEmpty())\r\n        return 0;\r\n    List<Integer> heights = new ArrayList(peers.size());\r\n    for (Peer peer : peers) heights.add((int) peer.getBestHeight());\r\n    return Utils.maxOfMostFreq(heights);\r\n}"
}, {
	"Path": "org.bitcoinj.protocols.channels.StoredPaymentChannelClientStates.updatedChannel",
	"Comment": "notifies the set of stored states that a channel has been updated. use to notify the wallet of an update to thiswallet extension.",
	"Method": "void updatedChannel(StoredClientChannel channel){\r\n    log.info(\"Stored client channel {} was updated\", channel.hashCode());\r\n    containingWallet.addOrUpdateExtension(this);\r\n}"
}, {
	"Path": "algo.sortingandsearching.BinarySearch.searchLowerBound",
	"Comment": "when there are duplicates, this finds the first occurrence of the key",
	"Method": "int searchLowerBound(int[] a,int key){\r\n    int lo = 0;\r\n    int hi = a.length - 1;\r\n    while (lo <= hi) {\r\n        int mid = lo + (hi - lo) / 2;\r\n        if (a[mid] == key && (mid == 0 || a[mid - 1] != key))\r\n            return mid;\r\n        if (a[mid] < key)\r\n            lo = mid + 1;\r\n        else\r\n            hi = mid - 1;\r\n    }\r\n    return -(lo + 1);\r\n}"
}, {
	"Path": "io.aeron.Image.initialTermId",
	"Comment": "the initial term at which the stream started for this session.",
	"Method": "int initialTermId(){\r\n    return initialTermId;\r\n}"
}, {
	"Path": "org.bitcoinj.core.BitcoinSerializer.makeFilteredBlock",
	"Comment": "make a filtered block from the payload. extension point for alternativeserialization format support.",
	"Method": "FilteredBlock makeFilteredBlock(byte[] payloadBytes){\r\n    return new FilteredBlock(params, payloadBytes);\r\n}"
}, {
	"Path": "io.aeron.ChannelUri.toString",
	"Comment": "generate a string representation of the uri that is valid for an aeron channel.",
	"Method": "String toString(){\r\n    final StringBuilder sb;\r\n    if (prefix == null || \"\".equals(prefix)) {\r\n        sb = new StringBuilder((params.size() * 20) + 10);\r\n    } else {\r\n        sb = new StringBuilder((params.size() * 20) + 20);\r\n        sb.append(prefix);\r\n        if (!prefix.endsWith(\":\")) {\r\n            sb.append(':');\r\n        }\r\n    }\r\n    sb.append(AERON_PREFIX).append(media);\r\n    if (params.size() > 0) {\r\n        sb.append('?');\r\n        for (final Map.Entry<String, String> entry : params.entrySet()) {\r\n            sb.append(entry.getKey()).append('=').append(entry.getValue()).append('|');\r\n        }\r\n        sb.setLength(sb.length() - 1);\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "io.aeron.Publication.channelStatusId",
	"Comment": "get the counter used to represent the channel status for this publication.",
	"Method": "int channelStatusId(){\r\n    return channelStatusId;\r\n}"
}, {
	"Path": "io.aeron.logbuffer.Header.context",
	"Comment": "context for storing state related to the context of the callback where the header is used.",
	"Method": "Object context(){\r\n    return context;\r\n}"
}, {
	"Path": "com.github.pedrovgs.problem43.CombinationOfIntegers.calculate",
	"Comment": "combination of recursive and iterative approach to resolve this problem.",
	"Method": "Set<Set<Integer>> calculate(Set<Integer> originalSet){\r\n    validateInputSet(originalSet);\r\n    Set<Set<Integer>> sets = new HashSet<Set<Integer>>();\r\n    if (originalSet.isEmpty()) {\r\n        sets.add(new HashSet<Integer>());\r\n        return sets;\r\n    }\r\n    List<Integer> list = new ArrayList<Integer>(originalSet);\r\n    Integer head = list.get(0);\r\n    Set<Integer> rest = new HashSet<Integer>(list.subList(1, list.size()));\r\n    for (Set<Integer> set : calculate(rest)) {\r\n        Set<Integer> newSet = new HashSet<Integer>();\r\n        newSet.add(head);\r\n        newSet.addAll(set);\r\n        sets.add(newSet);\r\n        sets.add(set);\r\n    }\r\n    return sets;\r\n}"
}, {
	"Path": "org.bitcoinj.core.NetworkParameters.getPacketMagic",
	"Comment": "the header bytes that identify the start of a packet on this network.",
	"Method": "long getPacketMagic(){\r\n    return packetMagic;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.importKeysAndEncrypt",
	"Comment": "takes a list of keys and an aes key, then encrypts and imports them in one step using the current keycrypter.",
	"Method": "int importKeysAndEncrypt(List<ECKey> keys,CharSequence password,int importKeysAndEncrypt,List<ECKey> keys,KeyParameter aesKey){\r\n    keyChainGroupLock.lock();\r\n    try {\r\n        checkNoDeterministicKeys(keys);\r\n        return keyChainGroup.importKeysAndEncrypt(keys, aesKey);\r\n    } finally {\r\n        keyChainGroupLock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.utils.MonetaryFormat.prefixCode",
	"Comment": "prefix formatted output by currency code. this configuration is not relevant for parsing.",
	"Method": "MonetaryFormat prefixCode(){\r\n    if (codePrefixed)\r\n        return this;\r\n    else\r\n        return new MonetaryFormat(negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, true);\r\n}"
}, {
	"Path": "org.bitcoinj.kits.WalletAppKit.setPeerNodes",
	"Comment": "will only connect to the given addresses. cannot be called after startup.",
	"Method": "WalletAppKit setPeerNodes(PeerAddress addresses){\r\n    checkState(state() == State.NEW, \"Cannot call after startup\");\r\n    this.peerAddresses = addresses;\r\n    return this;\r\n}"
}, {
	"Path": "io.aeron.ImageControlledFragmentAssembler.delegate",
	"Comment": "get the delegate unto which assembled messages are delegated.",
	"Method": "ControlledFragmentHandler delegate(){\r\n    return delegate;\r\n}"
}, {
	"Path": "org.bitcoinj.core.NetworkParameters.getP2SHHeader",
	"Comment": "first byte of a base58 encoded p2sh address.p2sh addresses are defined as part of bip0013.",
	"Method": "int getP2SHHeader(){\r\n    return p2shHeader;\r\n}"
}, {
	"Path": "io.aeron.cluster.client.AeronCluster.clusterSessionId",
	"Comment": "cluster session id for the session that was opened as the result of a successful connect.",
	"Method": "long clusterSessionId(){\r\n    return clusterSessionId;\r\n}"
}, {
	"Path": "org.bitcoinj.core.Message.readObject",
	"Comment": "set the serializer for this message when deserialized by java.",
	"Method": "void readObject(ObjectInputStream in){\r\n    in.defaultReadObject();\r\n    if (null != params) {\r\n        this.serializer = params.getDefaultSerializer();\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.TransactionOutput.duplicateDetached",
	"Comment": "returns a copy of the output detached from its containing transaction, if need be.",
	"Method": "TransactionOutput duplicateDetached(){\r\n    return new TransactionOutput(params, null, Coin.valueOf(value), Arrays.copyOf(scriptBytes, scriptBytes.length));\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.loadFromFileStream",
	"Comment": "returns a wallet deserialized from the given input stream and wallet extensions.",
	"Method": "Wallet loadFromFileStream(InputStream stream,WalletExtension walletExtensions){\r\n    Wallet wallet = new WalletProtobufSerializer().readWallet(stream, walletExtensions);\r\n    if (!wallet.isConsistent()) {\r\n        log.error(\"Loaded an inconsistent wallet\");\r\n    }\r\n    return wallet;\r\n}"
}, {
	"Path": "org.bitcoinj.script.ScriptBuilder.number",
	"Comment": "adds the given number to the given index in the program. automaticallyuses shortest encoding possible.",
	"Method": "ScriptBuilder number(long num,ScriptBuilder number,int index,long num){\r\n    if (num == -1) {\r\n        return op(index, OP_1NEGATE);\r\n    } else if (num >= 0 && num <= 16) {\r\n        return smallNum(index, (int) num);\r\n    } else {\r\n        return bigNum(index, num);\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.protocols.channels.PaymentChannelServer.receiveMessage",
	"Comment": "called when a message is received from the client. processes the given message and generates events based on itscontent.",
	"Method": "void receiveMessage(Protos.TwoWayChannelMessage msg){\r\n    lock.lock();\r\n    try {\r\n        checkState(connectionOpen);\r\n        if (channelSettling)\r\n            return;\r\n        try {\r\n            switch(msg.getType()) {\r\n                case CLIENT_VERSION:\r\n                    receiveVersionMessage(msg);\r\n                    return;\r\n                case PROVIDE_REFUND:\r\n                    receiveRefundMessage(msg);\r\n                    return;\r\n                case PROVIDE_CONTRACT:\r\n                    receiveContractMessage(msg);\r\n                    return;\r\n                case UPDATE_PAYMENT:\r\n                    checkState(step == InitStep.CHANNEL_OPEN && msg.hasUpdatePayment());\r\n                    receiveUpdatePaymentMessage(msg.getUpdatePayment(), true);\r\n                    return;\r\n                case CLOSE:\r\n                    receiveCloseMessage();\r\n                    return;\r\n                case ERROR:\r\n                    checkState(msg.hasError());\r\n                    log.error(\"Client sent ERROR {} with explanation {}\", msg.getError().getCode().name(), msg.getError().hasExplanation() ? msg.getError().getExplanation() : \"\");\r\n                    conn.destroyConnection(CloseReason.REMOTE_SENT_ERROR);\r\n                    return;\r\n                default:\r\n                    final String errorText = \"Got unknown message type or type that doesn't apply to servers.\";\r\n                    error(errorText, Protos.Error.ErrorCode.SYNTAX_ERROR, CloseReason.REMOTE_SENT_INVALID_MESSAGE);\r\n            }\r\n        } catch (VerificationException e) {\r\n            log.error(\"Caught verification exception handling message from client\", e);\r\n            error(e.getMessage(), Protos.Error.ErrorCode.BAD_TRANSACTION, CloseReason.REMOTE_SENT_INVALID_MESSAGE);\r\n        } catch (ValueOutOfRangeException e) {\r\n            log.error(\"Caught value out of range exception handling message from client\", e);\r\n            error(e.getMessage(), Protos.Error.ErrorCode.BAD_TRANSACTION, CloseReason.REMOTE_SENT_INVALID_MESSAGE);\r\n        } catch (InsufficientMoneyException e) {\r\n            log.error(\"Caught insufficient money exception handling message from client\", e);\r\n            error(e.getMessage(), Protos.Error.ErrorCode.BAD_TRANSACTION, CloseReason.REMOTE_SENT_INVALID_MESSAGE);\r\n        } catch (IllegalStateException e) {\r\n            log.error(\"Caught illegal state exception handling message from client\", e);\r\n            error(e.getMessage(), Protos.Error.ErrorCode.SYNTAX_ERROR, CloseReason.REMOTE_SENT_INVALID_MESSAGE);\r\n        }\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.PeerGroup.removeWallet",
	"Comment": "unlinks the given wallet so it no longer receives broadcast transactions or has its transactions announced.",
	"Method": "void removeWallet(Wallet wallet){\r\n    wallets.remove(checkNotNull(wallet));\r\n    peerFilterProviders.remove(wallet);\r\n    wallet.removeCoinsReceivedEventListener(walletCoinsReceivedEventListener);\r\n    wallet.removeKeyChainEventListener(walletKeyEventListener);\r\n    wallet.removeScriptChangeEventListener(walletScriptEventListener);\r\n    wallet.setTransactionBroadcaster(null);\r\n    for (Peer peer : peers) {\r\n        peer.removeWallet(wallet);\r\n    }\r\n}"
}, {
	"Path": "com.mobsandgeeks.saripaar.Reflector.getValidateUsingAnnotation",
	"Comment": "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ private methods~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
	"Method": "ValidateUsing getValidateUsingAnnotation(Class<? extends Annotation> annotationType){\r\n    ValidateUsing validateUsing = null;\r\n    Annotation[] declaredAnnotations = annotationType.getDeclaredAnnotations();\r\n    for (Annotation annotation : declaredAnnotations) {\r\n        if (ValidateUsing.class.equals(annotation.annotationType())) {\r\n            validateUsing = (ValidateUsing) annotation;\r\n            break;\r\n        }\r\n    }\r\n    return validateUsing;\r\n}"
}, {
	"Path": "org.bitcoinj.core.AlertMessage.getPriority",
	"Comment": "provides an integer ordering amongst simultaneously active alerts.",
	"Method": "long getPriority(){\r\n    return priority;\r\n}"
}, {
	"Path": "io.aeron.logbuffer.BufferClaim.wrap",
	"Comment": "wrap a region of an underlying log buffer so can can represent a claimed space for use by a publisher.",
	"Method": "void wrap(AtomicBuffer buffer,int offset,int length){\r\n    this.buffer.wrap(buffer, offset, length);\r\n}"
}, {
	"Path": "org.bitcoinj.core.Transaction.hashForSignature",
	"Comment": "this is required for signatures which use a sighashtype which cannot be represented using sighash and anyonecanpaysee transaction c99c49da4c38af669dea436d3e73780dfdb6c1ecf9958baa52960e8baee30e73, which has sighashtype 0",
	"Method": "Sha256Hash hashForSignature(int inputIndex,byte[] redeemScript,SigHash type,boolean anyoneCanPay,Sha256Hash hashForSignature,int inputIndex,Script redeemScript,SigHash type,boolean anyoneCanPay,Sha256Hash hashForSignature,int inputIndex,byte[] connectedScript,byte sigHashType){\r\n    try {\r\n        Transaction tx = this.params.getDefaultSerializer().makeTransaction(this.bitcoinSerialize());\r\n        for (int i = 0; i < tx.inputs.size(); i++) {\r\n            tx.inputs.get(i).clearScriptBytes();\r\n        }\r\n        connectedScript = Script.removeAllInstancesOfOp(connectedScript, ScriptOpCodes.OP_CODESEPARATOR);\r\n        TransactionInput input = tx.inputs.get(inputIndex);\r\n        input.setScriptBytes(connectedScript);\r\n        if ((sigHashType & 0x1f) == SigHash.NONE.value) {\r\n            tx.outputs = new ArrayList(0);\r\n            for (int i = 0; i < tx.inputs.size(); i++) if (i != inputIndex)\r\n                tx.inputs.get(i).setSequenceNumber(0);\r\n        } else if ((sigHashType & 0x1f) == SigHash.SINGLE.value) {\r\n            if (inputIndex >= tx.outputs.size()) {\r\n                return Sha256Hash.wrap(\"0100000000000000000000000000000000000000000000000000000000000000\");\r\n            }\r\n            tx.outputs = new ArrayList(tx.outputs.subList(0, inputIndex + 1));\r\n            for (int i = 0; i < inputIndex; i++) tx.outputs.set(i, new TransactionOutput(tx.params, tx, Coin.NEGATIVE_SATOSHI, new byte[] {}));\r\n            for (int i = 0; i < tx.inputs.size(); i++) if (i != inputIndex)\r\n                tx.inputs.get(i).setSequenceNumber(0);\r\n        }\r\n        if ((sigHashType & SigHash.ANYONECANPAY.value) == SigHash.ANYONECANPAY.value) {\r\n            tx.inputs = new ArrayList<TransactionInput>();\r\n            tx.inputs.add(input);\r\n        }\r\n        ByteArrayOutputStream bos = new UnsafeByteArrayOutputStream(tx.length == UNKNOWN_LENGTH ? 256 : tx.length + 4);\r\n        tx.bitcoinSerialize(bos);\r\n        uint32ToByteStreamLE(0x000000ff & sigHashType, bos);\r\n        Sha256Hash hash = Sha256Hash.twiceOf(bos.toByteArray());\r\n        bos.close();\r\n        return hash;\r\n    } catch (IOException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.PeerTest.startBlockChainDownload",
	"Comment": "check that it starts downloading the block chain correctly on request.",
	"Method": "void startBlockChainDownload(){\r\n    Block b1 = createFakeBlock(blockStore, Block.BLOCK_HEIGHT_GENESIS).block;\r\n    blockChain.add(b1);\r\n    Block b2 = makeSolvedTestBlock(b1);\r\n    blockChain.add(b2);\r\n    connect();\r\n    fail.set(true);\r\n    peer.addChainDownloadStartedEventListener(Threading.SAME_THREAD, new ChainDownloadStartedEventListener() {\r\n        @Override\r\n        public void onChainDownloadStarted(Peer p, int blocksLeft) {\r\n            if (p == peer && blocksLeft == 108)\r\n                fail.set(false);\r\n        }\r\n    });\r\n    peer.startBlockChainDownload();\r\n    BlockLocator expectedLocator = new BlockLocator();\r\n    expectedLocator = expectedLocator.add(b2.getHash());\r\n    expectedLocator = expectedLocator.add(b1.getHash());\r\n    expectedLocator = expectedLocator.add(UNITTEST.getGenesisBlock().getHash());\r\n    GetBlocksMessage message = (GetBlocksMessage) outbound(writeTarget);\r\n    assertEquals(message.getLocator(), expectedLocator);\r\n    assertEquals(Sha256Hash.ZERO_HASH, message.getStopHash());\r\n}"
}, {
	"Path": "org.bitcoinj.core.PeerTest.startBlockChainDownload",
	"Comment": "check that it starts downloading the block chain correctly on request.",
	"Method": "void startBlockChainDownload(){\r\n    if (p == peer && blocksLeft == 108)\r\n        fail.set(false);\r\n}"
}, {
	"Path": "org.bitcoinj.core.ECKey.fromPublicOnly",
	"Comment": "creates an eckey that cannot be used for signing, only verifying signatures, from the given encoded point.the compression state of pub will be preserved.",
	"Method": "ECKey fromPublicOnly(ECPoint pub,ECKey fromPublicOnly,byte[] pub){\r\n    return new ECKey(null, CURVE.getCurve().decodePoint(pub));\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.WalletFiles.saveNow",
	"Comment": "actually write the wallet file to disk, using an atomic rename when possible. runs on the current thread.",
	"Method": "void saveNow(){\r\n    if (executor.isShutdown())\r\n        return;\r\n    Date lastBlockSeenTime = wallet.getLastBlockSeenTime();\r\n    log.info(\"Saving wallet; last seen block is height {}, date {}, hash {}\", wallet.getLastBlockSeenHeight(), lastBlockSeenTime != null ? Utils.dateTimeFormat(lastBlockSeenTime) : \"unknown\", wallet.getLastBlockSeenHash());\r\n    saveNowInternal();\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.getWatchedScripts",
	"Comment": "returns a snapshot of the watched scripts. this view is not live.",
	"Method": "List<Script> getWatchedScripts(){\r\n    keyChainGroupLock.lock();\r\n    try {\r\n        return new ArrayList(watchedScripts);\r\n    } finally {\r\n        keyChainGroupLock.unlock();\r\n    }\r\n}"
}, {
	"Path": "io.aeron.logbuffer.BufferClaim.headerType",
	"Comment": "set the value of the header type field. the lower 16 bits are valid.",
	"Method": "int headerType(BufferClaim headerType,int type){\r\n    buffer.putShort(TYPE_FIELD_OFFSET, (short) type, LITTLE_ENDIAN);\r\n    return this;\r\n}"
}, {
	"Path": "cn.qqtheme.framework.util.LogUtils._getStackOffset",
	"Comment": "determines the starting index of the stack trace, after method calls made by this class.",
	"Method": "int _getStackOffset(StackTraceElement[] trace){\r\n    for (int i = MIN_STACK_OFFSET; i < trace.length; i++) {\r\n        StackTraceElement e = trace[i];\r\n        String name = e.getClassName();\r\n        if (!name.equals(LogUtils.class.getName())) {\r\n            return --i;\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "org.bitcoinj.script.Script.getNumberOfSignaturesRequiredToSpend",
	"Comment": "returns number of signatures required to satisfy this script.",
	"Method": "int getNumberOfSignaturesRequiredToSpend(){\r\n    if (ScriptPattern.isSentToMultisig(this)) {\r\n        ScriptChunk nChunk = chunks.get(0);\r\n        return Script.decodeFromOpN(nChunk.opcode);\r\n    } else if (ScriptPattern.isPayToPubKeyHash(this) || ScriptPattern.isPayToPubKey(this)) {\r\n        return 1;\r\n    } else if (ScriptPattern.isPayToScriptHash(this)) {\r\n        throw new IllegalStateException(\"For P2SH number of signatures depends on redeem script\");\r\n    } else {\r\n        throw new IllegalStateException(\"Unsupported script type\");\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.isNotSpendingTxnsInConfidenceType",
	"Comment": "finds if tx is not spending other txns which are in the specified confidence type",
	"Method": "boolean isNotSpendingTxnsInConfidenceType(Transaction tx,ConfidenceType confidenceType){\r\n    for (TransactionInput txInput : tx.getInputs()) {\r\n        Transaction connectedTx = this.getTransaction(txInput.getOutpoint().getHash());\r\n        if (connectedTx != null && connectedTx.getConfidence().getConfidenceType().equals(confidenceType)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.bitcoinj.core.Block.createNextBlock",
	"Comment": "returns a solved block that builds on top of this one. this exists for unit tests.",
	"Method": "Block createNextBlock(Address to,long version,long time,int blockHeight,Block createNextBlock,Address to,long version,TransactionOutPoint prevOut,long time,byte[] pubKey,Coin coinbaseValue,int height,Block createNextBlock,Address to,TransactionOutPoint prevOut,Block createNextBlock,Address to,Coin value,Block createNextBlock,Address to){\r\n    return createNextBlock(to, FIFTY_COINS);\r\n}"
}, {
	"Path": "org.bitcoinj.protocols.channels.PaymentChannelStateTest.data",
	"Comment": "we use parameterized tests to run the channel connection tests with eachversion of the channel.",
	"Method": "Collection<PaymentChannelClient.VersionSelector> data(){\r\n    return Arrays.asList(PaymentChannelClient.VersionSelector.VERSION_1, PaymentChannelClient.VersionSelector.VERSION_2_ALLOW_1);\r\n}"
}, {
	"Path": "org.bitcoinj.core.NetworkParameters.getDnsSeeds",
	"Comment": "returns dns names that when resolved, give ip addresses of active peers.",
	"Method": "String[] getDnsSeeds(){\r\n    return dnsSeeds;\r\n}"
}, {
	"Path": "org.bitcoinj.utils.Fiat.isNegative",
	"Comment": "returns true if and only if this instance represents a monetary value less than zero, otherwise false.",
	"Method": "boolean isNegative(){\r\n    return signum() == -1;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.KeyChainGroup.removeImportedKey",
	"Comment": "removes a key that was imported into the basic key chain. you cannot remove deterministic keys.",
	"Method": "boolean removeImportedKey(ECKey key){\r\n    checkNotNull(key);\r\n    checkArgument(!(key instanceof DeterministicKey));\r\n    return basic.removeKey(key);\r\n}"
}, {
	"Path": "org.bitcoinj.script.ScriptBuilder.createOutputScript",
	"Comment": "creates a scriptpubkey that encodes payment to the given raw public key.",
	"Method": "Script createOutputScript(Address to,Script createOutputScript,ECKey key){\r\n    return new ScriptBuilder().data(key.getPubKey()).op(OP_CHECKSIG).build();\r\n}"
}, {
	"Path": "org.bitcoinj.utils.Fiat.isLessThan",
	"Comment": "returns true if the monetary value represented by this instance is less than that of the given other fiat,otherwise false.",
	"Method": "boolean isLessThan(Fiat other){\r\n    return compareTo(other) < 0;\r\n}"
}, {
	"Path": "org.bitcoinj.core.NetworkParameters.fromPmtProtocolID",
	"Comment": "returns the network parameters for the given string paymentprotocolid or null if not recognized.",
	"Method": "NetworkParameters fromPmtProtocolID(String pmtProtocolId){\r\n    if (pmtProtocolId.equals(PAYMENT_PROTOCOL_ID_MAINNET)) {\r\n        return MainNetParams.get();\r\n    } else if (pmtProtocolId.equals(PAYMENT_PROTOCOL_ID_TESTNET)) {\r\n        return TestNet3Params.get();\r\n    } else if (pmtProtocolId.equals(PAYMENT_PROTOCOL_ID_UNIT_TESTS)) {\r\n        return UnitTestParams.get();\r\n    } else if (pmtProtocolId.equals(PAYMENT_PROTOCOL_ID_REGTEST)) {\r\n        return RegTestParams.get();\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.isConsistent",
	"Comment": "returns if this wallet is structurally consistent, so e.g. no duplicate transactions. first inconsistency and adump of the wallet will be logged.",
	"Method": "boolean isConsistent(){\r\n    try {\r\n        isConsistentOrThrow();\r\n        return true;\r\n    } catch (IllegalStateException x) {\r\n        log.error(x.getMessage());\r\n        try {\r\n            log.error(toString());\r\n        } catch (RuntimeException x2) {\r\n            log.error(\"Printing inconsistent wallet failed\", x2);\r\n        }\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.removeReorganizeEventListener",
	"Comment": "removes the given event listener object. returns true if the listener was removed, false if that listenerwas never added.",
	"Method": "boolean removeReorganizeEventListener(WalletReorganizeEventListener listener){\r\n    return ListenerRegistration.removeFromList(listener, reorganizeListeners);\r\n}"
}, {
	"Path": "org.bitcoinj.core.Transaction.checkCoinBaseHeight",
	"Comment": "check block height is in coinbase input script, for use after bip 34enforcement is enabled.",
	"Method": "void checkCoinBaseHeight(int height){\r\n    checkArgument(height >= Block.BLOCK_HEIGHT_GENESIS);\r\n    checkState(isCoinBase());\r\n    final TransactionInput in = this.getInputs().get(0);\r\n    final ScriptBuilder builder = new ScriptBuilder();\r\n    builder.number(height);\r\n    final byte[] expected = builder.build().getProgram();\r\n    final byte[] actual = in.getScriptBytes();\r\n    if (actual.length < expected.length) {\r\n        throw new VerificationException.CoinbaseHeightMismatch(\"Block height mismatch in coinbase.\");\r\n    }\r\n    for (int scriptIdx = 0; scriptIdx < expected.length; scriptIdx++) {\r\n        if (actual[scriptIdx] != expected[scriptIdx]) {\r\n            throw new VerificationException.CoinbaseHeightMismatch(\"Block height mismatch in coinbase.\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.aeron.ChannelUriStringBuilder.tags",
	"Comment": "get the tags for a channel used by a publication or subscription. tags can be used to identify or tag achannel so that a configuration can be referenced and reused.",
	"Method": "ChannelUriStringBuilder tags(String tags,String tags){\r\n    return tags;\r\n}"
}, {
	"Path": "org.bitcoinj.utils.BtcAutoFormat.toString",
	"Comment": "return a brief description of this formatter. the exact details of the representationare unspecified and subject to change, but will include some representation of thepattern and the number of fractional decimal places.",
	"Method": "String toString(){\r\n    return \"Auto-format \" + pattern();\r\n}"
}, {
	"Path": "org.bitcoinj.core.CheckpointManager.openStream",
	"Comment": "returns a checkpoints stream pointing to inside the bitcoinj jar",
	"Method": "InputStream openStream(NetworkParameters params){\r\n    return CheckpointManager.class.getResourceAsStream(\"/\" + params.getId() + \".checkpoints.txt\");\r\n}"
}, {
	"Path": "org.bitcoinj.net.discovery.SeedPeers.getPeer",
	"Comment": "acts as an iterator, returning the address of each node in the list sequentially.once all the list has been iterated, null will be returned for each subsequent query.",
	"Method": "InetSocketAddress getPeer(){\r\n    try {\r\n        return nextPeer();\r\n    } catch (UnknownHostException e) {\r\n        throw new PeerDiscoveryException(e);\r\n    }\r\n}"
}, {
	"Path": "io.aeron.logbuffer.ExclusiveTermAppender.claim",
	"Comment": "claim length of a the term buffer for writing in the message with zero copy semantics.",
	"Method": "int claim(int termId,int termOffset,HeaderWriter header,int length,BufferClaim bufferClaim){\r\n    final int frameLength = length + HEADER_LENGTH;\r\n    final int alignedLength = align(frameLength, FRAME_ALIGNMENT);\r\n    final UnsafeBuffer termBuffer = this.termBuffer;\r\n    final int termLength = termBuffer.capacity();\r\n    int resultingOffset = termOffset + alignedLength;\r\n    putRawTailOrdered(termId, resultingOffset);\r\n    if (resultingOffset > termLength) {\r\n        resultingOffset = handleEndOfLogCondition(termBuffer, termOffset, header, termLength, termId);\r\n    } else {\r\n        header.write(termBuffer, termOffset, frameLength, termId);\r\n        bufferClaim.wrap(termBuffer, termOffset, frameLength);\r\n    }\r\n    return resultingOffset;\r\n}"
}, {
	"Path": "org.bitcoinj.utils.BtcFormat.coinSymbol",
	"Comment": "return the unprefixed currency symbol for bitcoins configured for this object.the return value of this method is constant throughout the life of an instance.",
	"Method": "String coinSymbol(){\r\n    synchronized (numberFormat) {\r\n        return numberFormat.getDecimalFormatSymbols().getCurrencySymbol();\r\n    }\r\n}"
}, {
	"Path": "io.aeron.archive.client.ArchiveProxy.listRecordingsForUri",
	"Comment": "list a range of recording descriptors which match a channel and stream id.",
	"Method": "boolean listRecordingsForUri(long fromRecordingId,int recordCount,String channel,int streamId,long correlationId,long controlSessionId){\r\n    listRecordingsForUriRequestEncoder.wrapAndApplyHeader(buffer, 0, messageHeaderEncoder).controlSessionId(controlSessionId).correlationId(correlationId).fromRecordingId(fromRecordingId).recordCount(recordCount).streamId(streamId).channel(channel);\r\n    return offer(listRecordingsForUriRequestEncoder.encodedLength());\r\n}"
}, {
	"Path": "io.aeron.archive.status.RecordingPos.findCounterIdBySession",
	"Comment": "find the active counter id for a stream based on the session id.",
	"Method": "int findCounterIdBySession(CountersReader countersReader,int sessionId){\r\n    final DirectBuffer buffer = countersReader.metaDataBuffer();\r\n    for (int i = 0, size = countersReader.maxCounterId(); i < size; i++) {\r\n        if (countersReader.getCounterState(i) == RECORD_ALLOCATED) {\r\n            final int recordOffset = CountersReader.metaDataOffset(i);\r\n            if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECORDING_POSITION_TYPE_ID && buffer.getInt(recordOffset + KEY_OFFSET + SESSION_ID_OFFSET) == sessionId) {\r\n                return i;\r\n            }\r\n        }\r\n    }\r\n    return NULL_COUNTER_ID;\r\n}"
}, {
	"Path": "com.mobsandgeeks.saripaar.Reflector.isAnnotated",
	"Comment": "checks if an annotation was annotated with the given annotation.",
	"Method": "boolean isAnnotated(Class<? extends Annotation> inspected,Class<? extends Annotation> expected){\r\n    boolean isAnnotated = false;\r\n    Annotation[] declaredAnnotations = inspected.getDeclaredAnnotations();\r\n    for (Annotation declaredAnnotation : declaredAnnotations) {\r\n        isAnnotated = expected.equals(declaredAnnotation.annotationType());\r\n        if (isAnnotated) {\r\n            break;\r\n        }\r\n    }\r\n    return isAnnotated;\r\n}"
}, {
	"Path": "io.aeron.driver.Configuration.ipcPublicationTermWindowLength",
	"Comment": "how far ahead the publisher can get from the minimum subscriber position for ipc only.",
	"Method": "int ipcPublicationTermWindowLength(int termBufferLength){\r\n    int publicationTermWindowLength = termBufferLength;\r\n    if (0 != IPC_PUBLICATION_TERM_WINDOW_LENGTH) {\r\n        publicationTermWindowLength = Math.min(IPC_PUBLICATION_TERM_WINDOW_LENGTH, publicationTermWindowLength);\r\n    }\r\n    return publicationTermWindowLength;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.removeWatchedScripts",
	"Comment": "removes the given output scripts from the wallet that were being watched.",
	"Method": "boolean removeWatchedScripts(List<Script> scripts){\r\n    lock.lock();\r\n    try {\r\n        for (final Script script : scripts) {\r\n            if (!watchedScripts.contains(script))\r\n                continue;\r\n            watchedScripts.remove(script);\r\n        }\r\n        queueOnScriptsChanged(scripts, false);\r\n        saveNow();\r\n        return true;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "commons.validator.routines.UrlValidator.isValidPath",
	"Comment": "returns true if the path is valid.a null value is considered invalid.",
	"Method": "boolean isValidPath(String path){\r\n    if (path == null) {\r\n        return false;\r\n    }\r\n    if (!PATH_PATTERN.matcher(path).matches()) {\r\n        return false;\r\n    }\r\n    int slash2Count = countToken(\"//\", path);\r\n    if (isOff(ALLOW_2_SLASHES) && (slash2Count > 0)) {\r\n        return false;\r\n    }\r\n    int slashCount = countToken(\"/\", path);\r\n    int dot2Count = countToken(\"..\", path);\r\n    if (dot2Count > 0 && (slashCount - slash2Count - 1) <= dot2Count) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.bitcoinj.core.PeerGroup.getVersionMessage",
	"Comment": "returns the version message provided by setversionmessage or a default if none was given.",
	"Method": "VersionMessage getVersionMessage(){\r\n    lock.lock();\r\n    try {\r\n        return versionMessage;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.StoredBlock.getHeight",
	"Comment": "position in the chain for this block. the genesis block has a height of zero.",
	"Method": "int getHeight(){\r\n    return height;\r\n}"
}, {
	"Path": "org.bitcoinj.utils.VersionTally.initialize",
	"Comment": "initialize the version tally from the block store. note this does notsearch backwards past the start of the block store, so if starting froma checkpoint this may not fill the window.",
	"Method": "void initialize(BlockStore blockStore,StoredBlock chainHead){\r\n    StoredBlock versionBlock = chainHead;\r\n    final Stack<Long> versions = new Stack();\r\n    versions.push(versionBlock.getHeader().getVersion());\r\n    for (int headOffset = 0; headOffset < versionWindow.length; headOffset++) {\r\n        versionBlock = versionBlock.getPrev(blockStore);\r\n        if (null == versionBlock) {\r\n            break;\r\n        }\r\n        versions.push(versionBlock.getHeader().getVersion());\r\n    }\r\n    while (!versions.isEmpty()) {\r\n        add(versions.pop());\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.protocols.channels.StoredServerChannel.clearConnectedHandler",
	"Comment": "clears a handler that was connected with setconnectedhandler.",
	"Method": "void clearConnectedHandler(){\r\n    this.connectedHandler = null;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.calculateAllSpendCandidates",
	"Comment": "returns a list of the outputs that can potentially be spent, i.e. that we have the keys for and are unspentaccording to our knowledge of the block chain.",
	"Method": "List<TransactionOutput> calculateAllSpendCandidates(List<TransactionOutput> calculateAllSpendCandidates,boolean excludeImmatureCoinbases,boolean excludeUnsignable){\r\n    lock.lock();\r\n    try {\r\n        List<TransactionOutput> candidates;\r\n        if (vUTXOProvider == null) {\r\n            candidates = new ArrayList(myUnspents.size());\r\n            for (TransactionOutput output : myUnspents) {\r\n                if (excludeUnsignable && !canSignFor(output.getScriptPubKey()))\r\n                    continue;\r\n                Transaction transaction = checkNotNull(output.getParentTransaction());\r\n                if (excludeImmatureCoinbases && !transaction.isMature())\r\n                    continue;\r\n                candidates.add(output);\r\n            }\r\n        } else {\r\n            candidates = calculateAllSpendCandidatesFromUTXOProvider(excludeImmatureCoinbases);\r\n        }\r\n        return candidates;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.AbstractBlockChain.getChainHead",
	"Comment": "returns the block at the head of the current best chain. this is the block which represents the greatestamount of cumulative work done.",
	"Method": "StoredBlock getChainHead(){\r\n    synchronized (chainHeadLock) {\r\n        return chainHead;\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.BasicKeyChain.findKeysBefore",
	"Comment": "returns a list of all eckeys created after the given unix time.",
	"Method": "List<ECKey> findKeysBefore(long timeSecs){\r\n    lock.lock();\r\n    try {\r\n        List<ECKey> results = Lists.newLinkedList();\r\n        for (ECKey key : hashToKeys.values()) {\r\n            final long keyTime = key.getCreationTimeSeconds();\r\n            if (keyTime < timeSecs) {\r\n                results.add(key);\r\n            }\r\n        }\r\n        return results;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.kits.WalletAppKit.setDiscovery",
	"Comment": "sets the peer discovery class to use. if none is provided then dns is used, which is a reasonable default.",
	"Method": "WalletAppKit setDiscovery(PeerDiscovery discovery){\r\n    this.discovery = discovery;\r\n    return this;\r\n}"
}, {
	"Path": "org.bitcoinj.core.PeerGroupTest.createPeerDiscovery",
	"Comment": "utility method to create a peerdiscovery with a certain number of addresses.",
	"Method": "PeerDiscovery createPeerDiscovery(int nrOfAddressesWanted,int port){\r\n    final InetSocketAddress[] addresses = new InetSocketAddress[nrOfAddressesWanted];\r\n    for (int addressNr = 0; addressNr < nrOfAddressesWanted; addressNr++) {\r\n        addresses[addressNr] = new InetSocketAddress(\"localhost\", port + addressNr);\r\n    }\r\n    return new PeerDiscovery() {\r\n        public InetSocketAddress[] getPeers(long services, long unused, TimeUnit unused2) throws PeerDiscoveryException {\r\n            return addresses;\r\n        }\r\n        public void shutdown() {\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.bitcoinj.core.PeerGroupTest.createPeerDiscovery",
	"Comment": "utility method to create a peerdiscovery with a certain number of addresses.",
	"Method": "PeerDiscovery createPeerDiscovery(int nrOfAddressesWanted,int port){\r\n    return addresses;\r\n}"
}, {
	"Path": "org.bitcoinj.core.PeerGroupTest.createPeerDiscovery",
	"Comment": "utility method to create a peerdiscovery with a certain number of addresses.",
	"Method": "PeerDiscovery createPeerDiscovery(int nrOfAddressesWanted,int port){\r\n}"
}, {
	"Path": "org.bitcoinj.crypto.X509Utils.loadKeyStore",
	"Comment": "returns a key store loaded from the given stream. just a convenience around the java apis.",
	"Method": "KeyStore loadKeyStore(String keystoreType,String keystorePassword,InputStream is){\r\n    try {\r\n        KeyStore keystore = KeyStore.getInstance(keystoreType);\r\n        keystore.load(is, keystorePassword != null ? keystorePassword.toCharArray() : null);\r\n        return keystore;\r\n    } catch (IOException x) {\r\n        throw new KeyStoreException(x);\r\n    } catch (GeneralSecurityException x) {\r\n        throw new KeyStoreException(x);\r\n    } finally {\r\n        try {\r\n            is.close();\r\n        } catch (IOException x) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.utils.MonetaryFormat.digits",
	"Comment": "set character range to use for representing digits. it starts with the specified character representing zero.",
	"Method": "MonetaryFormat digits(char zeroDigit){\r\n    if (zeroDigit == this.zeroDigit)\r\n        return this;\r\n    else\r\n        return new MonetaryFormat(negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed);\r\n}"
}, {
	"Path": "io.aeron.CommonContext.newDefaultCncFile",
	"Comment": "create a new command and control file in the administration directory.",
	"Method": "File newDefaultCncFile(){\r\n    return new File(getProperty(AERON_DIR_PROP_NAME, AERON_DIR_PROP_DEFAULT), CncFileDescriptor.CNC_FILE);\r\n}"
}, {
	"Path": "org.atmosphere.runtime.DefaultAsyncSupportResolver.detectContainersPresent",
	"Comment": "returns a list of comet support by containers available on the classpath.",
	"Method": "List<Class<? extends AsyncSupport>> detectContainersPresent(){\r\n    return new LinkedList<Class<? extends AsyncSupport>>() {\r\n        {\r\n            if (testClassExists(NETTY))\r\n                add(NettyCometSupport.class);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.bitcoinj.core.ECKey.getCreationTimeSeconds",
	"Comment": "returns the creation time of this key or zero if the key was deserialized from a version that did not storethat data.",
	"Method": "long getCreationTimeSeconds(){\r\n    return creationTimeSeconds;\r\n}"
}, {
	"Path": "org.bitcoinj.core.DumpedPrivateKey.isPubKeyCompressed",
	"Comment": "returns true if the public key corresponding to this private key is compressed.",
	"Method": "boolean isPubKeyCompressed(){\r\n    return bytes.length == 33 && bytes[32] == 1;\r\n}"
}, {
	"Path": "io.aeron.logbuffer.ExclusiveTermAppender.appendFragmentedMessage",
	"Comment": "append a fragmented message to the the term buffer.the message will be split up into fragments of mtu length minus header.",
	"Method": "int appendFragmentedMessage(int termId,int termOffset,HeaderWriter header,DirectBuffer srcBuffer,int srcOffset,int length,int maxPayloadLength,ReservedValueSupplier reservedValueSupplier,int appendFragmentedMessage,int termId,int termOffset,HeaderWriter header,DirectBuffer bufferOne,int offsetOne,int lengthOne,DirectBuffer bufferTwo,int offsetTwo,int lengthTwo,int maxPayloadLength,ReservedValueSupplier reservedValueSupplier,int appendFragmentedMessage,int termId,int termOffset,HeaderWriter header,DirectBufferVector[] vectors,int length,int maxPayloadLength,ReservedValueSupplier reservedValueSupplier){\r\n    final int numMaxPayloads = length / maxPayloadLength;\r\n    final int remainingPayload = length % maxPayloadLength;\r\n    final int lastFrameLength = remainingPayload > 0 ? align(remainingPayload + HEADER_LENGTH, FRAME_ALIGNMENT) : 0;\r\n    final int requiredLength = (numMaxPayloads * (maxPayloadLength + HEADER_LENGTH)) + lastFrameLength;\r\n    final UnsafeBuffer termBuffer = this.termBuffer;\r\n    final int termLength = termBuffer.capacity();\r\n    int resultingOffset = termOffset + requiredLength;\r\n    putRawTailOrdered(termId, resultingOffset);\r\n    if (resultingOffset > termLength) {\r\n        resultingOffset = handleEndOfLogCondition(termBuffer, termOffset, header, termLength, termId);\r\n    } else {\r\n        int frameOffset = termOffset;\r\n        byte flags = BEGIN_FRAG_FLAG;\r\n        int remaining = length;\r\n        int vectorIndex = 0;\r\n        int vectorOffset = 0;\r\n        do {\r\n            final int bytesToWrite = Math.min(remaining, maxPayloadLength);\r\n            final int frameLength = bytesToWrite + HEADER_LENGTH;\r\n            final int alignedLength = align(frameLength, FRAME_ALIGNMENT);\r\n            header.write(termBuffer, frameOffset, frameLength, termId);\r\n            int bytesWritten = 0;\r\n            int payloadOffset = frameOffset + HEADER_LENGTH;\r\n            do {\r\n                final DirectBufferVector vector = vectors[vectorIndex];\r\n                final int vectorRemaining = vector.length - vectorOffset;\r\n                final int numBytes = Math.min(bytesToWrite - bytesWritten, vectorRemaining);\r\n                termBuffer.putBytes(payloadOffset, vector.buffer, vector.offset + vectorOffset, numBytes);\r\n                bytesWritten += numBytes;\r\n                payloadOffset += numBytes;\r\n                vectorOffset += numBytes;\r\n                if (vectorRemaining <= numBytes) {\r\n                    vectorIndex++;\r\n                    vectorOffset = 0;\r\n                }\r\n            } while (bytesWritten < bytesToWrite);\r\n            if (remaining <= maxPayloadLength) {\r\n                flags |= END_FRAG_FLAG;\r\n            }\r\n            frameFlags(termBuffer, frameOffset, flags);\r\n            if (null != reservedValueSupplier) {\r\n                final long reservedValue = reservedValueSupplier.get(termBuffer, frameOffset, frameLength);\r\n                termBuffer.putLong(frameOffset + RESERVED_VALUE_OFFSET, reservedValue, LITTLE_ENDIAN);\r\n            }\r\n            frameLengthOrdered(termBuffer, frameOffset, frameLength);\r\n            flags = 0;\r\n            frameOffset += alignedLength;\r\n            remaining -= bytesToWrite;\r\n        } while (remaining > 0);\r\n    }\r\n    return resultingOffset;\r\n}"
}, {
	"Path": "org.bitcoinj.protocols.channels.PaymentChannelV1ServerState.signMultisigInput",
	"Comment": "signs the first input of the transaction which must spend the multisig contract.",
	"Method": "void signMultisigInput(Transaction tx,Transaction.SigHash hashType,boolean anyoneCanPay,KeyParameter userKey){\r\n    TransactionSignature signature = tx.calculateSignature(0, serverKey, userKey, getContractScript(), hashType, anyoneCanPay);\r\n    byte[] mySig = signature.encodeToBitcoin();\r\n    Script scriptSig = ScriptBuilder.createMultiSigInputScriptBytes(ImmutableList.of(bestValueSignature, mySig));\r\n    tx.getInput(0).setScriptSig(scriptSig);\r\n}"
}, {
	"Path": "org.bitcoinj.net.BlockingClient.getConnectFuture",
	"Comment": "returns a future that completes once connection has occurred at the socket level or with an exception if failed to connect.",
	"Method": "ListenableFuture<SocketAddress> getConnectFuture(){\r\n    return connectFuture;\r\n}"
}, {
	"Path": "com.mikepenz.iconics.IconicsDrawable.draw",
	"Comment": "region overridden methods from android.graphics.drawable.drawable class",
	"Method": "void draw(Canvas canvas){\r\n    if (mIcon != null || mPlainIcon != null) {\r\n        final Rect viewBounds = getBounds();\r\n        updatePaddingBounds(viewBounds);\r\n        updateTextSize(viewBounds);\r\n        offsetIcon(viewBounds);\r\n        if (mBackgroundPaint != null && mRoundedCornerRy > -1 && mRoundedCornerRx > -1) {\r\n            if (mDrawBackgroundContour && mBackgroundContourPaint != null) {\r\n                float halfContourSize = mBackgroundContourWidth / 2;\r\n                RectF rectF = new RectF(halfContourSize, halfContourSize, viewBounds.width() - halfContourSize, viewBounds.height() - halfContourSize);\r\n                canvas.drawRoundRect(rectF, mRoundedCornerRx, mRoundedCornerRy, mBackgroundPaint);\r\n                canvas.drawRoundRect(rectF, mRoundedCornerRx, mRoundedCornerRy, mBackgroundContourPaint);\r\n            } else {\r\n                RectF rectF = new RectF(0, 0, viewBounds.width(), viewBounds.height());\r\n                canvas.drawRoundRect(rectF, mRoundedCornerRx, mRoundedCornerRy, mBackgroundPaint);\r\n            }\r\n        }\r\n        try {\r\n            mPath.close();\r\n        } catch (Exception ignored) {\r\n        }\r\n        if (mDrawContour) {\r\n            canvas.drawPath(mPath, mContourPaint);\r\n        }\r\n        mIconPaint.setAlpha(mAlpha);\r\n        mIconPaint.setColorFilter(mColorFilter == null ? mTintFilter : mColorFilter);\r\n        canvas.drawPath(mPath, mIconPaint);\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.Coin.isGreaterThan",
	"Comment": "returns true if the monetary value represented by this instance is greater than thatof the given other coin, otherwise false.",
	"Method": "boolean isGreaterThan(Coin other){\r\n    return compareTo(other) > 0;\r\n}"
}, {
	"Path": "io.aeron.Publication.positionLimitId",
	"Comment": "get the counter id for the position limit after which the publication will be back pressured.",
	"Method": "int positionLimitId(){\r\n    return positionLimit.id();\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.RedeemData.of",
	"Comment": "creates redeemdata for p2pkh or p2pk input. provided key is a single private key neededto spend such inputs and provided program should be a proper checksig program.",
	"Method": "RedeemData of(List<ECKey> keys,Script redeemScript,RedeemData of,ECKey key,Script program){\r\n    checkArgument(ScriptPattern.isPayToPubKeyHash(program) || ScriptPattern.isPayToPubKey(program));\r\n    return key != null ? new RedeemData(Collections.singletonList(key), program) : null;\r\n}"
}, {
	"Path": "org.atmosphere.runtime.AtmosphereFramework.objectFactory",
	"Comment": "set an object used for class instantiation.allows for integration with dependency injection frameworks.",
	"Method": "void objectFactory(AtmosphereObjectFactory objectFactory,AtmosphereObjectFactory objectFactory){\r\n    return objectFactory;\r\n}"
}, {
	"Path": "io.aeron.cluster.ClusterMember.checkArchiveEndpoint",
	"Comment": "check that the archive endpoint is correctly configured for the cluster member.",
	"Method": "void checkArchiveEndpoint(ClusterMember member,ChannelUri archiveControlRequestUri){\r\n    if (!UDP_MEDIA.equals(archiveControlRequestUri.media())) {\r\n        throw new ClusterException(\"archive control request channel must be udp\");\r\n    }\r\n    final String archiveEndpoint = archiveControlRequestUri.get(ENDPOINT_PARAM_NAME);\r\n    if (archiveEndpoint != null && !archiveEndpoint.equals(member.archiveEndpoint)) {\r\n        throw new ClusterException(\"archive control request endpoint must match cluster member configuration: \" + archiveEndpoint + \" != \" + member.archiveEndpoint);\r\n    }\r\n}"
}, {
	"Path": "io.aeron.logbuffer.TermScanner.available",
	"Comment": "the number of bytes that are available to be read after a scan.",
	"Method": "int available(long result){\r\n    return (int) result;\r\n}"
}, {
	"Path": "io.aeron.cluster.ClusterMember.quorumPosition",
	"Comment": "calculate the position reached by a quorum of cluster members.",
	"Method": "long quorumPosition(ClusterMember[] members,long[] rankedPositions){\r\n    final int length = rankedPositions.length;\r\n    for (int i = 0; i < length; i++) {\r\n        rankedPositions[i] = 0;\r\n    }\r\n    for (final ClusterMember member : members) {\r\n        long newPosition = member.logPosition;\r\n        for (int i = 0; i < length; i++) {\r\n            final long rankedPosition = rankedPositions[i];\r\n            if (newPosition > rankedPosition) {\r\n                rankedPositions[i] = newPosition;\r\n                newPosition = rankedPosition;\r\n            }\r\n        }\r\n    }\r\n    return rankedPositions[length - 1];\r\n}"
}, {
	"Path": "org.bitcoinj.core.TransactionOutput.isMine",
	"Comment": "returns true if this output is to a key, or an address we have the keys for, in the wallet.",
	"Method": "boolean isMine(TransactionBag transactionBag){\r\n    try {\r\n        Script script = getScriptPubKey();\r\n        if (ScriptPattern.isPayToPubKey(script)) {\r\n            return transactionBag.isPubKeyMine(ScriptPattern.extractKeyFromPayToPubKey(script));\r\n        }\r\n        if (ScriptPattern.isPayToScriptHash(script)) {\r\n            return transactionBag.isPayToScriptHashMine(ScriptPattern.extractHashFromPayToScriptHash(script));\r\n        } else {\r\n            byte[] pubkeyHash = script.getPubKeyHash();\r\n            return transactionBag.isPubKeyHashMine(pubkeyHash);\r\n        }\r\n    } catch (ScriptException e) {\r\n        log.debug(\"Could not parse tx {} output script: {}\", parent != null ? parent.getHash() : \"(no parent)\", e.toString());\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "io.aeron.cluster.service.ClientSession.id",
	"Comment": "cluster session identity uniquely allocated when the session was opened.",
	"Method": "long id(){\r\n    return id;\r\n}"
}, {
	"Path": "io.aeron.driver.Configuration.validatePublicationLingerTimeoutNs",
	"Comment": "validate the publication linger timeout is an appropriate value.",
	"Method": "void validatePublicationLingerTimeoutNs(long timeoutNs,long driverLingerTimeoutNs){\r\n    if (timeoutNs < driverLingerTimeoutNs) {\r\n        throw new ConfigurationException(\"linger must be greater than or equal to driver linger timeout: \" + timeoutNs);\r\n    }\r\n}"
}, {
	"Path": "org.atmosphere.websocket.WebSocket.attachment",
	"Comment": "attach an object. be careful when attaching an object as it can cause memory leak",
	"Method": "WebSocket attachment(Object attachment,Object attachment){\r\n    return attachment;\r\n}"
}, {
	"Path": "commons.validator.routines.CodeValidator.validate",
	"Comment": "validate the code returning either the valid code ornull if invalid.",
	"Method": "Object validate(String input){\r\n    if (input == null) {\r\n        return null;\r\n    }\r\n    String code = input.trim();\r\n    if (code.length() == 0) {\r\n        return null;\r\n    }\r\n    if (regexValidator != null) {\r\n        code = regexValidator.validate(code);\r\n        if (code == null) {\r\n            return null;\r\n        }\r\n    }\r\n    if ((minLength >= 0 && code.length() < minLength) || (maxLength >= 0 && code.length() > maxLength)) {\r\n        return null;\r\n    }\r\n    if (checkdigit != null && !checkdigit.isValid(code)) {\r\n        return null;\r\n    }\r\n    return code;\r\n}"
}, {
	"Path": "io.aeron.archive.client.ArchiveProxy.startRecording",
	"Comment": "start recording streams for a given channel and stream id pairing.",
	"Method": "boolean startRecording(String channel,int streamId,SourceLocation sourceLocation,long correlationId,long controlSessionId){\r\n    startRecordingRequestEncoder.wrapAndApplyHeader(buffer, 0, messageHeaderEncoder).controlSessionId(controlSessionId).correlationId(correlationId).streamId(streamId).sourceLocation(sourceLocation).channel(channel);\r\n    return offer(startRecordingRequestEncoder.encodedLength());\r\n}"
}, {
	"Path": "io.aeron.protocol.StatusMessageFlyweight.receiverId",
	"Comment": "identifier for the receiver to distinguish them for flowcontrol strategies.",
	"Method": "long receiverId(StatusMessageFlyweight receiverId,long id){\r\n    if (ByteOrder.nativeOrder() == LITTLE_ENDIAN) {\r\n        putByte(RECEIVER_ID_FIELD_OFFSET + 7, (byte) (id >> 56));\r\n        putByte(RECEIVER_ID_FIELD_OFFSET + 6, (byte) (id >> 48));\r\n        putByte(RECEIVER_ID_FIELD_OFFSET + 5, (byte) (id >> 40));\r\n        putByte(RECEIVER_ID_FIELD_OFFSET + 4, (byte) (id >> 32));\r\n        putByte(RECEIVER_ID_FIELD_OFFSET + 3, (byte) (id >> 24));\r\n        putByte(RECEIVER_ID_FIELD_OFFSET + 2, (byte) (id >> 16));\r\n        putByte(RECEIVER_ID_FIELD_OFFSET + 1, (byte) (id >> 8));\r\n        putByte(RECEIVER_ID_FIELD_OFFSET + 0, (byte) (id));\r\n    } else {\r\n        putByte(RECEIVER_ID_FIELD_OFFSET + 0, (byte) (id >> 56));\r\n        putByte(RECEIVER_ID_FIELD_OFFSET + 1, (byte) (id >> 48));\r\n        putByte(RECEIVER_ID_FIELD_OFFSET + 2, (byte) (id >> 40));\r\n        putByte(RECEIVER_ID_FIELD_OFFSET + 3, (byte) (id >> 32));\r\n        putByte(RECEIVER_ID_FIELD_OFFSET + 4, (byte) (id >> 24));\r\n        putByte(RECEIVER_ID_FIELD_OFFSET + 5, (byte) (id >> 16));\r\n        putByte(RECEIVER_ID_FIELD_OFFSET + 6, (byte) (id >> 8));\r\n        putByte(RECEIVER_ID_FIELD_OFFSET + 7, (byte) (id));\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.atmosphere.runtime.AtmosphereRequestImpl.cloneRequest",
	"Comment": "copy the httpservletrequest content inside an atmosphererequest. by default the returned atmosphererequestis not destroyable.",
	"Method": "AtmosphereRequest cloneRequest(HttpServletRequest request,boolean loadInMemory,boolean copySession,boolean isDestroyable,boolean createSession){\r\n    Builder b;\r\n    HttpServletRequest r;\r\n    Cookie[] cs = request.getCookies();\r\n    Set<Cookie> hs = Collections.synchronizedSet(new HashSet());\r\n    if (cs != null) {\r\n        for (Cookie c : cs) {\r\n            hs.add(c);\r\n        }\r\n    }\r\n    boolean isWrapped = false;\r\n    if (AtmosphereRequestImpl.class.isAssignableFrom(request.getClass())) {\r\n        b = AtmosphereRequestImpl.class.cast(request).b;\r\n        isWrapped = true;\r\n    } else {\r\n        b = new Builder();\r\n        b.request(request);\r\n    }\r\n    HttpSession session = request.getSession(false);\r\n    if (copySession) {\r\n        session = request.getSession(createSession);\r\n        if (session != null) {\r\n            session = new FakeHttpSession(session);\r\n        } else {\r\n            session = new FakeHttpSession(\"\", null, System.currentTimeMillis(), -1);\r\n        }\r\n    }\r\n    b.servletPath(request.getServletPath()).pathInfo(request.getPathInfo()).contextPath(request.getContextPath()).requestURI(request.getRequestURI()).requestURL(request.getRequestURL().toString()).method(request.getMethod()).serverName(request.getServerName()).serverPort(request.getServerPort()).remoteAddr(request.getRemoteAddr()).remoteHost(request.getRemoteHost()).remotePort(request.getRemotePort()).destroyable(isDestroyable).cookies(hs).session(session).principal(request.getUserPrincipal()).authType(request.getAuthType()).isSSecure(request.isSecure());\r\n    if (loadInMemory) {\r\n        String s = (String) attributeWithoutException(request, FrameworkConfig.THROW_EXCEPTION_ON_CLONED_REQUEST);\r\n        boolean throwException = s != null && Boolean.parseBoolean(s);\r\n        r = new NoOpsRequest(throwException);\r\n        if (isWrapped) {\r\n            load(b.request, b);\r\n        } else {\r\n            load(request, b);\r\n        }\r\n        b.request(r);\r\n    }\r\n    return isWrapped ? AtmosphereRequestImpl.class.cast(request) : b.build();\r\n}"
}, {
	"Path": "org.bitcoinj.protocols.channels.StoredPaymentChannelServerStates.getFromWallet",
	"Comment": "returns this extension from the given wallet, or null if no such extension was added.",
	"Method": "StoredPaymentChannelServerStates getFromWallet(Wallet wallet){\r\n    return (StoredPaymentChannelServerStates) wallet.getExtensions().get(EXTENSION_ID);\r\n}"
}, {
	"Path": "org.bitcoinj.core.Transaction.addOutput",
	"Comment": "creates an output based on the given address and value, adds it to this transaction, and returns the new output.",
	"Method": "TransactionOutput addOutput(TransactionOutput to,TransactionOutput addOutput,Coin value,Address address,TransactionOutput addOutput,Coin value,ECKey pubkey,TransactionOutput addOutput,Coin value,Script script){\r\n    return addOutput(new TransactionOutput(params, this, value, script.getProgram()));\r\n}"
}, {
	"Path": "io.aeron.archive.client.ArchiveProxy.extendRecording",
	"Comment": "extend a recorded stream for a given channel and stream id pairing.",
	"Method": "boolean extendRecording(String channel,int streamId,SourceLocation sourceLocation,long recordingId,long correlationId,long controlSessionId){\r\n    extendRecordingRequestEncoder.wrapAndApplyHeader(buffer, 0, messageHeaderEncoder).controlSessionId(controlSessionId).correlationId(correlationId).recordingId(recordingId).streamId(streamId).sourceLocation(sourceLocation).channel(channel);\r\n    return offer(extendRecordingRequestEncoder.encodedLength());\r\n}"
}, {
	"Path": "org.bitcoinj.core.UnsafeByteArrayOutputStream.toByteArray",
	"Comment": "creates a newly allocated byte array. its size is the currentsize of this output stream and the valid contents of the bufferhave been copied into it.",
	"Method": "byte toByteArray(){\r\n    return count == buf.length ? buf : copyOf(buf, count);\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.DeterministicKeyChain.fromProtobuf",
	"Comment": "returns all the key chains found in the given list of keys. typically there will only be one, but in the case ofkey rotation it can happen that there are multiple chains found.",
	"Method": "List<DeterministicKeyChain> fromProtobuf(List<Protos.Key> keys,KeyCrypter crypter,List<DeterministicKeyChain> fromProtobuf,List<Protos.Key> keys,KeyCrypter crypter,KeyChainFactory factory){\r\n    List<DeterministicKeyChain> chains = newLinkedList();\r\n    DeterministicSeed seed = null;\r\n    DeterministicKeyChain chain = null;\r\n    int lookaheadSize = -1;\r\n    int sigsRequiredToSpend = 1;\r\n    List<ChildNumber> accountPath = newArrayList();\r\n    PeekingIterator<Protos.Key> iter = Iterators.peekingIterator(keys.iterator());\r\n    while (iter.hasNext()) {\r\n        Protos.Key key = iter.next();\r\n        final Protos.Key.Type t = key.getType();\r\n        if (t == Protos.Key.Type.DETERMINISTIC_MNEMONIC) {\r\n            accountPath = newArrayList();\r\n            for (int i : key.getAccountPathList()) {\r\n                accountPath.add(new ChildNumber(i));\r\n            }\r\n            if (accountPath.isEmpty())\r\n                accountPath = ACCOUNT_ZERO_PATH;\r\n            if (chain != null) {\r\n                checkState(lookaheadSize >= 0);\r\n                chain.setLookaheadSize(lookaheadSize);\r\n                chain.setSigsRequiredToSpend(sigsRequiredToSpend);\r\n                chain.maybeLookAhead();\r\n                chains.add(chain);\r\n                chain = null;\r\n            }\r\n            long timestamp = key.getCreationTimestamp() / 1000;\r\n            String passphrase = DEFAULT_PASSPHRASE_FOR_MNEMONIC;\r\n            if (key.hasSecretBytes()) {\r\n                if (key.hasEncryptedDeterministicSeed())\r\n                    throw new UnreadableWalletException(\"Malformed key proto: \" + key.toString());\r\n                byte[] seedBytes = null;\r\n                if (key.hasDeterministicSeed()) {\r\n                    seedBytes = key.getDeterministicSeed().toByteArray();\r\n                }\r\n                seed = new DeterministicSeed(key.getSecretBytes().toStringUtf8(), seedBytes, passphrase, timestamp);\r\n            } else if (key.hasEncryptedData()) {\r\n                if (key.hasDeterministicSeed())\r\n                    throw new UnreadableWalletException(\"Malformed key proto: \" + key.toString());\r\n                EncryptedData data = new EncryptedData(key.getEncryptedData().getInitialisationVector().toByteArray(), key.getEncryptedData().getEncryptedPrivateKey().toByteArray());\r\n                EncryptedData encryptedSeedBytes = null;\r\n                if (key.hasEncryptedDeterministicSeed()) {\r\n                    Protos.EncryptedData encryptedSeed = key.getEncryptedDeterministicSeed();\r\n                    encryptedSeedBytes = new EncryptedData(encryptedSeed.getInitialisationVector().toByteArray(), encryptedSeed.getEncryptedPrivateKey().toByteArray());\r\n                }\r\n                seed = new DeterministicSeed(data, encryptedSeedBytes, timestamp);\r\n            } else {\r\n                throw new UnreadableWalletException(\"Malformed key proto: \" + key.toString());\r\n            }\r\n            if (log.isDebugEnabled())\r\n                log.debug(\"Deserializing: DETERMINISTIC_MNEMONIC: {}\", seed);\r\n        } else if (t == Protos.Key.Type.DETERMINISTIC_KEY) {\r\n            if (!key.hasDeterministicKey())\r\n                throw new UnreadableWalletException(\"Deterministic key missing extra data: \" + key.toString());\r\n            byte[] chainCode = key.getDeterministicKey().getChainCode().toByteArray();\r\n            LinkedList<ChildNumber> path = newLinkedList();\r\n            for (int i : key.getDeterministicKey().getPathList()) path.add(new ChildNumber(i));\r\n            LazyECPoint pubkey = new LazyECPoint(ECKey.CURVE.getCurve(), key.getPublicKey().toByteArray());\r\n            final ImmutableList<ChildNumber> immutablePath = ImmutableList.copyOf(path);\r\n            boolean isWatchingAccountKey = false;\r\n            boolean isFollowingKey = false;\r\n            boolean isSpendingKey = false;\r\n            if (key.getDeterministicKey().getIsFollowing()) {\r\n                if (chain != null) {\r\n                    checkState(lookaheadSize >= 0);\r\n                    chain.setLookaheadSize(lookaheadSize);\r\n                    chain.setSigsRequiredToSpend(sigsRequiredToSpend);\r\n                    chain.maybeLookAhead();\r\n                    chains.add(chain);\r\n                    chain = null;\r\n                    seed = null;\r\n                }\r\n                isFollowingKey = true;\r\n            }\r\n            if (chain == null) {\r\n                boolean isMarried = !isFollowingKey && !chains.isEmpty() && chains.get(chains.size() - 1).isFollowing();\r\n                if (seed == null && key.hasSecretBytes()) {\r\n                    DeterministicKey accountKey = new DeterministicKey(immutablePath, chainCode, pubkey, new BigInteger(1, key.getSecretBytes().toByteArray()), null);\r\n                    accountKey.setCreationTimeSeconds(key.getCreationTimestamp() / 1000);\r\n                    chain = factory.makeSpendingKeyChain(key, iter.peek(), accountKey, isMarried);\r\n                    isSpendingKey = true;\r\n                } else if (seed == null) {\r\n                    DeterministicKey accountKey = new DeterministicKey(immutablePath, chainCode, pubkey, null, null);\r\n                    accountKey.setCreationTimeSeconds(key.getCreationTimestamp() / 1000);\r\n                    chain = factory.makeWatchingKeyChain(key, iter.peek(), accountKey, isFollowingKey, isMarried);\r\n                    isWatchingAccountKey = true;\r\n                } else {\r\n                    chain = factory.makeKeyChain(key, iter.peek(), seed, crypter, isMarried, ImmutableList.<ChildNumber>builder().addAll(accountPath).build());\r\n                    chain.lookaheadSize = LAZY_CALCULATE_LOOKAHEAD;\r\n                }\r\n            }\r\n            DeterministicKey parent = null;\r\n            if (!path.isEmpty() && !isWatchingAccountKey && !isSpendingKey) {\r\n                ChildNumber index = path.removeLast();\r\n                parent = chain.hierarchy.get(path, false, false);\r\n                path.add(index);\r\n            }\r\n            DeterministicKey detkey;\r\n            if (key.hasSecretBytes()) {\r\n                final BigInteger priv = new BigInteger(1, key.getSecretBytes().toByteArray());\r\n                detkey = new DeterministicKey(immutablePath, chainCode, pubkey, priv, parent);\r\n            } else {\r\n                if (key.hasEncryptedData()) {\r\n                    Protos.EncryptedData proto = key.getEncryptedData();\r\n                    EncryptedData data = new EncryptedData(proto.getInitialisationVector().toByteArray(), proto.getEncryptedPrivateKey().toByteArray());\r\n                    checkNotNull(crypter, \"Encountered an encrypted key but no key crypter provided\");\r\n                    detkey = new DeterministicKey(immutablePath, chainCode, crypter, pubkey, data, parent);\r\n                } else {\r\n                    detkey = new DeterministicKey(immutablePath, chainCode, pubkey, null, parent);\r\n                }\r\n            }\r\n            if (key.hasCreationTimestamp())\r\n                detkey.setCreationTimeSeconds(key.getCreationTimestamp() / 1000);\r\n            if (log.isDebugEnabled())\r\n                log.debug(\"Deserializing: DETERMINISTIC_KEY: {}\", detkey);\r\n            if (!isWatchingAccountKey) {\r\n                if (path.isEmpty()) {\r\n                    if (chain.rootKey == null) {\r\n                        chain.rootKey = detkey;\r\n                        chain.hierarchy = new DeterministicHierarchy(detkey);\r\n                    }\r\n                } else if ((path.size() == chain.getAccountPath().size() + 1) || isSpendingKey) {\r\n                    if (detkey.getChildNumber().num() == 0) {\r\n                        chain.externalParentKey = detkey;\r\n                        chain.issuedExternalKeys = key.getDeterministicKey().getIssuedSubkeys();\r\n                        lookaheadSize = Math.max(lookaheadSize, key.getDeterministicKey().getLookaheadSize());\r\n                        sigsRequiredToSpend = key.getDeterministicKey().getSigsRequiredToSpend();\r\n                    } else if (detkey.getChildNumber().num() == 1) {\r\n                        chain.internalParentKey = detkey;\r\n                        chain.issuedInternalKeys = key.getDeterministicKey().getIssuedSubkeys();\r\n                    }\r\n                }\r\n            }\r\n            chain.hierarchy.putKey(detkey);\r\n            chain.basicKeyChain.importKey(detkey);\r\n        }\r\n    }\r\n    if (chain != null) {\r\n        checkState(lookaheadSize >= 0);\r\n        chain.setLookaheadSize(lookaheadSize);\r\n        chain.setSigsRequiredToSpend(sigsRequiredToSpend);\r\n        chain.maybeLookAhead();\r\n        chains.add(chain);\r\n    }\r\n    return chains;\r\n}"
}, {
	"Path": "algo.graph.IsBipartite.hasOddCycle",
	"Comment": "if there is a cycle with odd number of vertices, that graph cannot be bipartite. to check if graph has oddcycle, we traverse the graph with bfs and paint current node with white and its children with black.if any node has the same color as its parent, there is odd cycle.",
	"Method": "boolean hasOddCycle(){\r\n    for (Integer ver : graph.getVertices()) {\r\n        for (Integer nei : graph.getNeighbors(ver)) {\r\n            if (color.get(ver) == color.get(nei))\r\n                return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.bitcoinj.core.Transaction.clearInputs",
	"Comment": "removes all the inputs from this transaction.note that this also invalidates the length attribute",
	"Method": "void clearInputs(){\r\n    unCache();\r\n    for (TransactionInput input : inputs) {\r\n        input.setParent(null);\r\n    }\r\n    inputs.clear();\r\n    this.length = this.unsafeBitcoinSerialize().length;\r\n}"
}, {
	"Path": "org.atmosphere.runtime.AtmosphereSession.enterLockWhenResourcePresent",
	"Comment": "enters the lock only when the resource is present in current session.",
	"Method": "boolean enterLockWhenResourcePresent(int timeInSecond){\r\n    long timeoutNanos = TimeUnit.SECONDS.toNanos(timeInSecond);\r\n    final boolean reentrant = lock.isHeldByCurrentThread();\r\n    if (!lock.tryLock()) {\r\n        final long deadline = System.nanoTime() + timeoutNanos;\r\n        if (!lock.tryLock(timeInSecond, TimeUnit.SECONDS)) {\r\n            return false;\r\n        }\r\n        timeoutNanos = deadline - System.nanoTime();\r\n    }\r\n    boolean satisfied = false;\r\n    boolean threw = true;\r\n    try {\r\n        satisfied = (resource != null) || awaitNanosForResourceToBePresent(timeoutNanos, reentrant);\r\n        threw = false;\r\n        return satisfied;\r\n    } finally {\r\n        if (!satisfied) {\r\n            try {\r\n                if (threw && !reentrant) {\r\n                    signalWaiter();\r\n                }\r\n            } finally {\r\n                lock.unlock();\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.Transaction.toString",
	"Comment": "a human readable version of the transaction useful for debugging. the format is not guaranteed to be stable.",
	"Method": "String toString(String toString,AbstractBlockChain chain){\r\n    StringBuilder s = new StringBuilder();\r\n    s.append(\"  \").append(getHashAsString()).append('\\n');\r\n    if (updatedAt != null)\r\n        s.append(\"  updated: \").append(Utils.dateTimeFormat(updatedAt)).append('\\n');\r\n    if (version != 1)\r\n        s.append(\"  version \").append(version).append('\\n');\r\n    if (isTimeLocked()) {\r\n        s.append(\"  time locked until \");\r\n        if (lockTime < LOCKTIME_THRESHOLD) {\r\n            s.append(\"block \").append(lockTime);\r\n            if (chain != null) {\r\n                s.append(\" (estimated to be reached at \").append(Utils.dateTimeFormat(chain.estimateBlockTime((int) lockTime))).append(')');\r\n            }\r\n        } else {\r\n            s.append(Utils.dateTimeFormat(lockTime * 1000));\r\n        }\r\n        s.append('\\n');\r\n    }\r\n    if (hasRelativeLockTime()) {\r\n        s.append(\"  has relative lock time\\n\");\r\n    }\r\n    if (isOptInFullRBF()) {\r\n        s.append(\"  opts into full replace-by-fee\\n\");\r\n    }\r\n    if (isCoinBase()) {\r\n        String script;\r\n        String script2;\r\n        try {\r\n            script = inputs.get(0).getScriptSig().toString();\r\n            script2 = outputs.get(0).getScriptPubKey().toString();\r\n        } catch (ScriptException e) {\r\n            script = \"???\";\r\n            script2 = \"???\";\r\n        }\r\n        s.append(\"     == COINBASE TXN (scriptSig \").append(script).append(\")  (scriptPubKey \").append(script2).append(\")\\n\");\r\n        return s.toString();\r\n    }\r\n    if (!inputs.isEmpty()) {\r\n        int i = 0;\r\n        for (TransactionInput in : inputs) {\r\n            s.append(\"     \");\r\n            s.append(\"in   \");\r\n            try {\r\n                String scriptSigStr = in.getScriptSig().toString();\r\n                s.append(!Strings.isNullOrEmpty(scriptSigStr) ? scriptSigStr : \"<no scriptSig>\");\r\n                final Coin value = in.getValue();\r\n                if (value != null)\r\n                    s.append(\" \").append(value.toFriendlyString());\r\n                if (in.hasWitness()) {\r\n                    s.append(\"\\n          \");\r\n                    s.append(\"witness:\");\r\n                    s.append(in.getWitness());\r\n                }\r\n                s.append(\"\\n          \");\r\n                s.append(\"outpoint:\");\r\n                final TransactionOutPoint outpoint = in.getOutpoint();\r\n                s.append(outpoint.toString());\r\n                final TransactionOutput connectedOutput = outpoint.getConnectedOutput();\r\n                if (connectedOutput != null) {\r\n                    Script scriptPubKey = connectedOutput.getScriptPubKey();\r\n                    try {\r\n                        byte[] pubKeyHash = scriptPubKey.getPubKeyHash();\r\n                        s.append(\" hash160:\");\r\n                        s.append(Utils.HEX.encode(pubKeyHash));\r\n                    } catch (ScriptException x) {\r\n                    }\r\n                }\r\n                if (in.hasSequence()) {\r\n                    s.append(\"\\n          sequence:\").append(Long.toHexString(in.getSequenceNumber()));\r\n                    if (in.isOptInFullRBF())\r\n                        s.append(\", opts into full RBF\");\r\n                    if (version >= 2 && in.hasRelativeLockTime())\r\n                        s.append(\", has RLT\");\r\n                }\r\n            } catch (Exception e) {\r\n                s.append(\"[exception: \").append(e.getMessage()).append(\"]\");\r\n            }\r\n            s.append('\\n');\r\n            i++;\r\n        }\r\n    } else {\r\n        s.append(\"     \");\r\n        s.append(\"INCOMPLETE: No inputs!\\n\");\r\n    }\r\n    for (TransactionOutput out : outputs) {\r\n        s.append(\"     \");\r\n        s.append(\"out  \");\r\n        try {\r\n            Script scriptPubKey = out.getScriptPubKey();\r\n            s.append(scriptPubKey.getChunks().size() > 0 ? scriptPubKey.toString() : \"<no scriptPubKey>\");\r\n            s.append(\" \");\r\n            s.append(out.getValue().toFriendlyString());\r\n            if (!out.isAvailableForSpending()) {\r\n                s.append(\" Spent\");\r\n            }\r\n            final TransactionInput spentBy = out.getSpentBy();\r\n            if (spentBy != null) {\r\n                s.append(\" by \");\r\n                s.append(spentBy.getParentTransaction().getHashAsString());\r\n            }\r\n            s.append('\\n');\r\n            ScriptType scriptType = scriptPubKey.getScriptType();\r\n            if (scriptType != null)\r\n                s.append(\"          \" + scriptType + \" addr:\" + scriptPubKey.getToAddress(params));\r\n        } catch (Exception e) {\r\n            s.append(\"[exception: \").append(e.getMessage()).append(\"]\");\r\n        }\r\n        s.append('\\n');\r\n    }\r\n    final Coin fee = getFee();\r\n    if (fee != null) {\r\n        final int size = unsafeBitcoinSerialize().length;\r\n        s.append(\"     fee  \").append(fee.multiply(1000).divide(size).toFriendlyString()).append(\"/kB, \").append(fee.toFriendlyString()).append(\" for \").append(size).append(\" bytes\\n\");\r\n    }\r\n    if (purpose != null)\r\n        s.append(\"     prps \").append(purpose).append('\\n');\r\n    return s.toString();\r\n}"
}, {
	"Path": "org.bitcoinj.protocols.channels.PaymentChannelServerTest.data",
	"Comment": "we use parameterized tests to run the client channel tests with eachversion of the channel.",
	"Method": "Collection<Integer> data(){\r\n    return Arrays.asList(1, 2);\r\n}"
}, {
	"Path": "com.github.pedrovgs.problem64.GetTheElementInTheMiddleOfTheList.get2",
	"Comment": "iterative solution to this problem. the complexity order of this algorithm in time and spaceterms is equivalent to the previous algorithm but the execution time is lower in this version.the key of this algorithm is based on use two pointers, going going two times faster troughlist during the iteration.",
	"Method": "ListNode<Integer> get2(ListNode<Integer> list){\r\n    validateInput(list);\r\n    ListNode<Integer> currentNode = list;\r\n    ListNode<Integer> fastNode = list.getNext();\r\n    while (fastNode != null && fastNode.getNext() != null) {\r\n        currentNode = currentNode.getNext();\r\n        fastNode = fastNode.getNext().getNext();\r\n    }\r\n    return currentNode;\r\n}"
}, {
	"Path": "org.bitcoinj.testing.FakeTxBuilder.roundTripTransaction",
	"Comment": "roundtrip a transaction so that it appears as if it has just come from the wire",
	"Method": "Transaction roundTripTransaction(NetworkParameters params,Transaction tx){\r\n    try {\r\n        MessageSerializer bs = params.getDefaultSerializer();\r\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n        bs.serialize(tx, bos);\r\n        return (Transaction) bs.deserialize(ByteBuffer.wrap(bos.toByteArray()));\r\n    } catch (IOException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.MarriedKeyChain.freshOutputScript",
	"Comment": "create a new married key and return the matching output script",
	"Method": "Script freshOutputScript(KeyPurpose purpose){\r\n    DeterministicKey followedKey = getKey(purpose);\r\n    ImmutableList.Builder<ECKey> keys = ImmutableList.<ECKey>builder().add(followedKey);\r\n    for (DeterministicKeyChain keyChain : followingKeyChains) {\r\n        DeterministicKey followingKey = keyChain.getKey(purpose);\r\n        checkState(followedKey.getChildNumber().equals(followingKey.getChildNumber()), \"Following keychains should be in sync\");\r\n        keys.add(followingKey);\r\n    }\r\n    List<ECKey> marriedKeys = keys.build();\r\n    Script redeemScript = ScriptBuilder.createRedeemScript(sigsRequiredToSpend, marriedKeys);\r\n    return ScriptBuilder.createP2SHOutputScript(redeemScript);\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.BasicKeyChain.fromProtobufEncrypted",
	"Comment": "returns a new basickeychain that contains all basic, original type keys and also any encrypted keys extractedfrom the list. unrecognised key types are ignored.",
	"Method": "BasicKeyChain fromProtobufEncrypted(List<Protos.Key> keys,KeyCrypter crypter){\r\n    BasicKeyChain chain = new BasicKeyChain(checkNotNull(crypter));\r\n    chain.deserializeFromProtobuf(keys);\r\n    return chain;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.DefaultRiskAnalysis.isInputStandard",
	"Comment": "checks if the given input passes some of the areinputsstandard checks. not complete.",
	"Method": "RuleViolation isInputStandard(TransactionInput input){\r\n    for (ScriptChunk chunk : input.getScriptSig().getChunks()) {\r\n        if (chunk.data != null && !chunk.isShortestPossiblePushData())\r\n            return RuleViolation.SHORTEST_POSSIBLE_PUSHDATA;\r\n        if (chunk.isPushData()) {\r\n            ECDSASignature signature;\r\n            try {\r\n                signature = ECKey.ECDSASignature.decodeFromDER(chunk.data);\r\n            } catch (IllegalArgumentException x) {\r\n                signature = null;\r\n            }\r\n            if (signature != null) {\r\n                if (!TransactionSignature.isEncodingCanonical(chunk.data))\r\n                    return RuleViolation.SIGNATURE_CANONICAL_ENCODING;\r\n                if (!signature.isCanonical())\r\n                    return RuleViolation.SIGNATURE_CANONICAL_ENCODING;\r\n            }\r\n        }\r\n    }\r\n    return RuleViolation.NONE;\r\n}"
}, {
	"Path": "io.aeron.logbuffer.LogBufferDescriptor.rotateLog",
	"Comment": "rotate the log and update the tail counter for the new term.this method is safe for concurrent use.",
	"Method": "boolean rotateLog(UnsafeBuffer logMetaDataBuffer,int currentTermCount,int currentTermId){\r\n    final int nextTermId = currentTermId + 1;\r\n    final int nextTermCount = currentTermCount + 1;\r\n    final int nextIndex = indexByTermCount(nextTermCount);\r\n    final int expectedTermId = nextTermId - PARTITION_COUNT;\r\n    long rawTail;\r\n    do {\r\n        rawTail = rawTail(logMetaDataBuffer, nextIndex);\r\n        if (expectedTermId != termId(rawTail)) {\r\n            break;\r\n        }\r\n    } while (!casRawTail(logMetaDataBuffer, nextIndex, rawTail, packTail(nextTermId, 0)));\r\n    return casActiveTermCount(logMetaDataBuffer, currentTermCount, nextTermCount);\r\n}"
}, {
	"Path": "org.bitcoinj.core.ECKey.getKeyCrypter",
	"Comment": "returns the keycrypter that was used to encrypt to encrypt this eckey. you need this to decrypt the eckey.",
	"Method": "KeyCrypter getKeyCrypter(){\r\n    return keyCrypter;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.fromSpendingKey",
	"Comment": "creates a wallet that tracks payments to and from the hd key hierarchy rooted by the given spending key.this wallet can also spend.",
	"Method": "Wallet fromSpendingKey(NetworkParameters params,DeterministicKey spendKey){\r\n    return new Wallet(params, new KeyChainGroup(params, spendKey, false));\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.isKeyRotating",
	"Comment": "returns whether the keys creation time is before the key rotation time, if one was set.",
	"Method": "boolean isKeyRotating(ECKey key){\r\n    long time = vKeyRotationTimestamp;\r\n    return time != 0 && key.getCreationTimeSeconds() < time;\r\n}"
}, {
	"Path": "org.bitcoinj.protocols.channels.StoredPaymentChannelClientStates.getSecondsUntilExpiry",
	"Comment": "returns the number of seconds from now until this servers next channel will expire, or zero if no unexpiredchannels found.",
	"Method": "long getSecondsUntilExpiry(Sha256Hash id){\r\n    lock.lock();\r\n    try {\r\n        final Set<StoredClientChannel> setChannels = mapChannels.get(id);\r\n        final long nowSeconds = Utils.currentTimeSeconds();\r\n        int earliestTime = Integer.MAX_VALUE;\r\n        for (StoredClientChannel channel : setChannels) {\r\n            synchronized (channel) {\r\n                if (channel.expiryTimeSeconds() > nowSeconds)\r\n                    earliestTime = Math.min(earliestTime, (int) channel.expiryTimeSeconds());\r\n            }\r\n        }\r\n        return earliestTime == Integer.MAX_VALUE ? 0 : earliestTime - nowSeconds;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "io.aeron.archive.status.RecordingPos.findCounterIdByRecording",
	"Comment": "find the active counter id for a stream based on the recording id.",
	"Method": "int findCounterIdByRecording(CountersReader countersReader,long recordingId){\r\n    final DirectBuffer buffer = countersReader.metaDataBuffer();\r\n    for (int i = 0, size = countersReader.maxCounterId(); i < size; i++) {\r\n        if (countersReader.getCounterState(i) == RECORD_ALLOCATED) {\r\n            final int recordOffset = CountersReader.metaDataOffset(i);\r\n            if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECORDING_POSITION_TYPE_ID && buffer.getLong(recordOffset + KEY_OFFSET + RECORDING_ID_OFFSET) == recordingId) {\r\n                return i;\r\n            }\r\n        }\r\n    }\r\n    return NULL_COUNTER_ID;\r\n}"
}, {
	"Path": "org.bitcoinj.core.PeerGroup.getPendingPeers",
	"Comment": "returns a list containing peers that did not complete connection yet.",
	"Method": "List<Peer> getPendingPeers(){\r\n    lock.lock();\r\n    try {\r\n        return new ArrayList(pendingPeers);\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.atmosphere.websocket.WebSocket.lastWriteTimeStampInMilliseconds",
	"Comment": "the last time, in milliseconds, a write operation occurred.",
	"Method": "long lastWriteTimeStampInMilliseconds(){\r\n    return lastWrite == -1 ? System.currentTimeMillis() : lastWrite;\r\n}"
}, {
	"Path": "commons.validator.routines.CodeValidator.getMinLength",
	"Comment": "return the minimum length of the code.n.b. optional, if less than zero theminimum length will not be checked.",
	"Method": "int getMinLength(){\r\n    return minLength;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.removeTransactionConfidenceEventListener",
	"Comment": "removes the given event listener object. returns true if the listener was removed, false if that listenerwas never added.",
	"Method": "boolean removeTransactionConfidenceEventListener(TransactionConfidenceEventListener listener){\r\n    return ListenerRegistration.removeFromList(listener, transactionConfidenceListeners);\r\n}"
}, {
	"Path": "io.aeron.samples.SamplesUtil.subscriberLoop",
	"Comment": "return a reusable, parametrised event loop that calls and idler when no messages are received",
	"Method": "Consumer<Subscription> subscriberLoop(FragmentHandler fragmentHandler,int limit,AtomicBoolean running,Consumer<Subscription> subscriberLoop,FragmentHandler fragmentHandler,EndOfStreamHandler endOfStreamHandler,int limit,AtomicBoolean running,IdleStrategy idleStrategy){\r\n    return (subscription) -> {\r\n        try {\r\n            boolean reachedEos = false;\r\n            while (running.get()) {\r\n                final int fragmentsRead = subscription.poll(fragmentHandler, limit);\r\n                if (0 == fragmentsRead) {\r\n                    if (!reachedEos && subscription.pollEndOfStreams(endOfStreamHandler) > 0) {\r\n                        reachedEos = true;\r\n                    }\r\n                }\r\n                idleStrategy.idle(fragmentsRead);\r\n            }\r\n        } catch (final Exception ex) {\r\n            LangUtil.rethrowUnchecked(ex);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.bitcoinj.core.Coin.isLessThan",
	"Comment": "returns true if the monetary value represented by this instance is less than thatof the given other coin, otherwise false.",
	"Method": "boolean isLessThan(Coin other){\r\n    return compareTo(other) < 0;\r\n}"
}, {
	"Path": "org.atmosphere.util.FilterConfigImpl.recycle",
	"Comment": "release the filter instance associated with this filterconfig,if there is one.",
	"Method": "void recycle(){\r\n    if (this.filter != null) {\r\n        filter.destroy();\r\n    }\r\n    this.filter = null;\r\n}"
}, {
	"Path": "io.aeron.driver.reports.LossReportUtil.mapLossReport",
	"Comment": "map a new loss report in the aeron directory for a given length.",
	"Method": "MappedByteBuffer mapLossReport(String aeronDirectoryName,int reportFileLength){\r\n    return mapNewFile(file(aeronDirectoryName), reportFileLength, false);\r\n}"
}, {
	"Path": "io.aeron.driver.Configuration.validateInitialWindowLength",
	"Comment": "validate that the initial window length is greater than mtu.",
	"Method": "void validateInitialWindowLength(int initialWindowLength,int mtuLength){\r\n    if (mtuLength > initialWindowLength) {\r\n        throw new IllegalStateException(\"Initial window length must be >= to MTU length: \" + mtuLength);\r\n    }\r\n}"
}, {
	"Path": "problems.medium.ConvertSortedArraytoBinarySearchTree.sortedArrayToBST",
	"Comment": "as an array is sorted, we can find root of array by finding middle element in constant time.then divide both left and right parts of array and apply the method again to find root of subtrees",
	"Method": "TreeNode sortedArrayToBST(int[] a){\r\n    if (a.length == 0)\r\n        return null;\r\n    return helper(a, 0, a.length - 1);\r\n}"
}, {
	"Path": "commons.validator.routines.IntegerValidator.processParsedValue",
	"Comment": "perform further validation and convert the number toan integer.",
	"Method": "Object processParsedValue(Object value,Format formatter){\r\n    long longValue = ((Number) value).longValue();\r\n    if (longValue < Integer.MIN_VALUE || longValue > Integer.MAX_VALUE) {\r\n        return null;\r\n    }\r\n    return new Integer((int) longValue);\r\n}"
}, {
	"Path": "org.bitcoinj.core.PeerGroup.connectToLocalHost",
	"Comment": "helper for forcing a connection to localhost. useful when using regtest mode. returns the peer object.",
	"Method": "Peer connectToLocalHost(){\r\n    lock.lock();\r\n    try {\r\n        final PeerAddress localhost = PeerAddress.localhost(params);\r\n        backoffMap.put(localhost, new ExponentialBackoff(peerBackoffParams));\r\n        return connectTo(localhost, true, vConnectTimeoutMillis);\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "io.aeron.Publication.positionBitsToShift",
	"Comment": "number of bits to right shift a position to get a term count for how far the stream has progressed.",
	"Method": "int positionBitsToShift(){\r\n    return positionBitsToShift;\r\n}"
}, {
	"Path": "org.bitcoinj.core.AbstractBlockChain.addWallet",
	"Comment": "add a wallet to the blockchain. note that the wallet will be unaffected by any blocks received while itwas not part of this blockchain. this method is useful if the wallet has just been created, and its keyshave never been in use, or if the wallet has been loaded along with the blockchain. note that adding multiplewallets is not well tested!",
	"Method": "void addWallet(Wallet wallet){\r\n    addNewBestBlockListener(Threading.SAME_THREAD, wallet);\r\n    addReorganizeListener(Threading.SAME_THREAD, wallet);\r\n    addTransactionReceivedListener(Threading.SAME_THREAD, wallet);\r\n    int walletHeight = wallet.getLastBlockSeenHeight();\r\n    int chainHeight = getBestChainHeight();\r\n    if (walletHeight != chainHeight) {\r\n        log.warn(\"Wallet/chain height mismatch: {} vs {}\", walletHeight, chainHeight);\r\n        log.warn(\"Hashes: {} vs {}\", wallet.getLastBlockSeenHash(), getChainHead().getHeader().getHash());\r\n        if (walletHeight < chainHeight && walletHeight > 0) {\r\n            try {\r\n                rollbackBlockStore(walletHeight);\r\n                log.info(\"Rolled back block store to height {}.\", walletHeight);\r\n            } catch (BlockStoreException x) {\r\n                log.warn(\"Rollback of block store failed, continuing with mismatched heights. This can happen due to a replay.\");\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.Transaction.isCoinBase",
	"Comment": "a coinbase transaction is one that creates a new coin. they are the first transaction in each block and theirvalue is determined by a formula that all implementations of bitcoin share. in 2011 the value of a coinbasetransaction is 50 coins, but in future it will be less. a coinbase transaction is defined not only by itsposition in a block but by the data in the inputs.",
	"Method": "boolean isCoinBase(){\r\n    return inputs.size() == 1 && inputs.get(0).isCoinBase();\r\n}"
}, {
	"Path": "problems.medium.ValidateBinarySearchTree.isValidBST2",
	"Comment": "solution 2basically what i am doing is recursively iterating over the tree while defining intervalfor each node which value must fit in.",
	"Method": "boolean isValidBST2(TreeNode root){\r\n    return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);\r\n}"
}, {
	"Path": "org.bitcoinj.crypto.DeterministicKey.setCreationTimeSeconds",
	"Comment": "the creation time of a deterministic key is equal to that of its parent, unless this key is the root of a tree.thus, setting the creation time on a leaf is forbidden.",
	"Method": "void setCreationTimeSeconds(long newCreationTimeSeconds){\r\n    if (parent != null)\r\n        throw new IllegalStateException(\"Creation time can only be set on root keys.\");\r\n    else\r\n        super.setCreationTimeSeconds(newCreationTimeSeconds);\r\n}"
}, {
	"Path": "org.bitcoinj.kits.WalletAppKit.completeExtensionInitiations",
	"Comment": "as soon as the transaction broadcaster han been created we will pass it to thepayment channel extensions",
	"Method": "void completeExtensionInitiations(TransactionBroadcaster transactionBroadcaster){\r\n    StoredPaymentChannelClientStates clientStoredChannels = (StoredPaymentChannelClientStates) vWallet.getExtensions().get(StoredPaymentChannelClientStates.class.getName());\r\n    if (clientStoredChannels != null) {\r\n        clientStoredChannels.setTransactionBroadcaster(transactionBroadcaster);\r\n    }\r\n    StoredPaymentChannelServerStates serverStoredChannels = (StoredPaymentChannelServerStates) vWallet.getExtensions().get(StoredPaymentChannelServerStates.class.getName());\r\n    if (serverStoredChannels != null) {\r\n        serverStoredChannels.setTransactionBroadcaster(transactionBroadcaster);\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.importKey",
	"Comment": "imports the given eckey to the wallet.if the wallet is configured to auto save to a file, triggers a save immediately. runs the onkeysadded eventhandler. if the key already exists in the wallet, does nothing and returns false.",
	"Method": "boolean importKey(ECKey key){\r\n    return importKeys(Lists.newArrayList(key)) == 1;\r\n}"
}, {
	"Path": "io.aeron.ChannelUriStringBuilder.clear",
	"Comment": "clear out all the values thus setting back to the initial state.",
	"Method": "ChannelUriStringBuilder clear(){\r\n    prefix = null;\r\n    media = null;\r\n    endpoint = null;\r\n    networkInterface = null;\r\n    controlEndpoint = null;\r\n    controlMode = null;\r\n    tags = null;\r\n    reliable = null;\r\n    ttl = null;\r\n    mtu = null;\r\n    termLength = null;\r\n    initialTermId = null;\r\n    termId = null;\r\n    termOffset = null;\r\n    sessionId = null;\r\n    isSessionIdTagged = false;\r\n    return this;\r\n}"
}, {
	"Path": "org.bitcoinj.net.discovery.SeedPeers.getPeers",
	"Comment": "returns an array containing all the bitcoin nodes within the list.",
	"Method": "InetSocketAddress[] getPeers(long services,long timeoutValue,TimeUnit timeoutUnit){\r\n    if (services != 0)\r\n        throw new PeerDiscoveryException(\"Pre-determined peers cannot be filtered by services: \" + services);\r\n    try {\r\n        return allPeers();\r\n    } catch (UnknownHostException e) {\r\n        throw new PeerDiscoveryException(e);\r\n    }\r\n}"
}, {
	"Path": "io.aeron.archive.client.ArchiveProxy.tryConnect",
	"Comment": "try connect to an archive on its control interface providing the response stream details. only one attempt willbe made to offer the request.",
	"Method": "boolean tryConnect(String responseChannel,int responseStreamId,long correlationId){\r\n    connectRequestEncoder.wrapAndApplyHeader(buffer, 0, messageHeaderEncoder).correlationId(correlationId).responseStreamId(responseStreamId).responseChannel(responseChannel);\r\n    final int length = MessageHeaderEncoder.ENCODED_LENGTH + connectRequestEncoder.encodedLength();\r\n    return publication.offer(buffer, 0, length) > 0;\r\n}"
}, {
	"Path": "org.bitcoinj.core.BitcoinSerializer.makeBlock",
	"Comment": "make a block from the payload. extension point for alternativeserialization format support.",
	"Method": "Block makeBlock(byte[] payloadBytes,int offset,int length){\r\n    return new Block(params, payloadBytes, offset, this, length);\r\n}"
}, {
	"Path": "commons.validator.routines.DomainValidator.getInstance",
	"Comment": "returns the singleton instance of this validator, with local validation as required.",
	"Method": "DomainValidator getInstance(DomainValidator getInstance,boolean allowLocal){\r\n    if (allowLocal) {\r\n        return DOMAIN_VALIDATOR_WITH_LOCAL;\r\n    }\r\n    return DOMAIN_VALIDATOR;\r\n}"
}, {
	"Path": "io.aeron.SystemTest.checkInterruptedStatus",
	"Comment": "check if the interrupt flag has been set on the current thread and fail the test if it has.this is useful for terminating tests stuck in a loop on timeout otherwise junit will proceed to the next testand leave the thread spinning and consuming cpu resource.",
	"Method": "void checkInterruptedStatus(){\r\n    if (Thread.currentThread().isInterrupted()) {\r\n        fail(\"Unexpected interrupt - Test likely to have timed out\");\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.AlertMessage.getRelayUntil",
	"Comment": "the time at which the alert should stop being broadcast across the network. note that you can still receivethe alert after this time from other nodes if the alert still applies to them or to you.",
	"Method": "Date getRelayUntil(){\r\n    return relayUntil;\r\n}"
}, {
	"Path": "io.aeron.logbuffer.FrameDescriptor.computeMaxMessageLength",
	"Comment": "compute the maximum supported message length for a buffer of given termlength.",
	"Method": "int computeMaxMessageLength(int termLength){\r\n    return Math.min(termLength / 8, MAX_MESSAGE_LENGTH);\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.addTransactionsDependingOn",
	"Comment": "adds to txset all the txns in txpool spending outputs of txns in txset,and all txns spending the outputs of those txns, recursively.",
	"Method": "void addTransactionsDependingOn(Set<Transaction> txSet,Set<Transaction> txPool){\r\n    Map<Sha256Hash, Transaction> txQueue = new LinkedHashMap();\r\n    for (Transaction tx : txSet) {\r\n        txQueue.put(tx.getHash(), tx);\r\n    }\r\n    while (!txQueue.isEmpty()) {\r\n        Transaction tx = txQueue.remove(txQueue.keySet().iterator().next());\r\n        for (Transaction anotherTx : txPool) {\r\n            if (anotherTx.equals(tx))\r\n                continue;\r\n            for (TransactionInput input : anotherTx.getInputs()) {\r\n                if (input.getOutpoint().getHash().equals(tx.getHash())) {\r\n                    if (txQueue.get(anotherTx.getHash()) == null) {\r\n                        txQueue.put(anotherTx.getHash(), anotherTx);\r\n                        txSet.add(anotherTx);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.aeron.ImageFragmentAssembler.delegate",
	"Comment": "get the delegate unto which assembled messages are delegated.",
	"Method": "FragmentHandler delegate(){\r\n    return delegate;\r\n}"
}, {
	"Path": "org.bitcoinj.core.PeerGroup.getMaxConnections",
	"Comment": "the maximum number of connections that we will create to peers.",
	"Method": "int getMaxConnections(){\r\n    lock.lock();\r\n    try {\r\n        return maxConnections;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.utils.BtcFormat.coinCode",
	"Comment": "return the unprefixed international currency code for bitcoins configured for thisobject.the return value of this method is constant throughough the life of an instance.",
	"Method": "String coinCode(){\r\n    synchronized (numberFormat) {\r\n        return numberFormat.getDecimalFormatSymbols().getInternationalCurrencySymbol();\r\n    }\r\n}"
}, {
	"Path": "io.aeron.cluster.ClusterMember.compareLog",
	"Comment": "the result is positive if lhs has the more recent log, zero if logs are equal, and negative if rhs has the morerecent log.",
	"Method": "int compareLog(long lhsLogLeadershipTermId,long lhsLogPosition,long rhsLogLeadershipTermId,long rhsLogPosition,int compareLog,ClusterMember lhs,ClusterMember rhs){\r\n    return compareLog(lhs.leadershipTermId, lhs.logPosition, rhs.leadershipTermId, rhs.logPosition);\r\n}"
}, {
	"Path": "org.bitcoinj.protocols.channels.PaymentChannelServer.connectionOpen",
	"Comment": "called to indicate the connection has been opened and messages can now be generated for the client.",
	"Method": "void connectionOpen(){\r\n    lock.lock();\r\n    try {\r\n        log.info(\"New server channel active.\");\r\n        connectionOpen = true;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "io.aeron.driver.Configuration.publicationTermWindowLength",
	"Comment": "how far ahead the publisher can get from the sender position.",
	"Method": "int publicationTermWindowLength(int termBufferLength){\r\n    int publicationTermWindowLength = termBufferLength / 2;\r\n    if (0 != PUBLICATION_TERM_WINDOW_LENGTH) {\r\n        publicationTermWindowLength = Math.min(PUBLICATION_TERM_WINDOW_LENGTH, publicationTermWindowLength);\r\n    }\r\n    return publicationTermWindowLength;\r\n}"
}, {
	"Path": "io.aeron.protocol.DataHeaderFlyweight.isHeartbeat",
	"Comment": "is the frame at data frame at the beginning of packet a heartbeat message?",
	"Method": "boolean isHeartbeat(UnsafeBuffer packet,int length){\r\n    return length == HEADER_LENGTH && packet.getInt(0) == 0;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.getBalance",
	"Comment": "returns the balance of this wallet as calculated by the provided balancetype.",
	"Method": "Coin getBalance(Coin getBalance,BalanceType balanceType,Coin getBalance,CoinSelector selector){\r\n    lock.lock();\r\n    try {\r\n        checkNotNull(selector);\r\n        List<TransactionOutput> candidates = calculateAllSpendCandidates(true, false);\r\n        CoinSelection selection = selector.select(params.getMaxMoney(), candidates);\r\n        return selection.valueGathered;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.atmosphere.util.uri.UriTemplate.getNumberOfExplicitRegexes",
	"Comment": "get the number of explicit regexes declared in template variables.",
	"Method": "int getNumberOfExplicitRegexes(){\r\n    return numOfExplicitRegexes;\r\n}"
}, {
	"Path": "io.aeron.Counter.registrationId",
	"Comment": "return the registration id used to register this counter with the media driver.",
	"Method": "long registrationId(){\r\n    return registrationId;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.saveNow",
	"Comment": "if auto saving is enabled, do an immediate sync write to disk ignoring any delays.",
	"Method": "void saveNow(){\r\n    WalletFiles files = vFileManager;\r\n    if (files != null) {\r\n        try {\r\n            files.saveNow();\r\n        } catch (IOException e) {\r\n            log.error(\"Failed to save wallet to disk!\", e);\r\n            Thread.UncaughtExceptionHandler handler = Threading.uncaughtExceptionHandler;\r\n            if (handler != null)\r\n                handler.uncaughtException(Thread.currentThread(), e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.aeron.archive.client.ArchiveProxy.connect",
	"Comment": "connect to an archive on its control interface providing the response stream details.",
	"Method": "boolean connect(String responseChannel,int responseStreamId,long correlationId,boolean connect,String responseChannel,int responseStreamId,long correlationId,AgentInvoker aeronClientInvoker){\r\n    connectRequestEncoder.wrapAndApplyHeader(buffer, 0, messageHeaderEncoder).correlationId(correlationId).responseStreamId(responseStreamId).responseChannel(responseChannel);\r\n    return offerWithTimeout(connectRequestEncoder.encodedLength(), aeronClientInvoker);\r\n}"
}, {
	"Path": "org.bitcoinj.core.TransactionOutput.isWatched",
	"Comment": "returns true if this output is to a key, or an address we have the keys for, in the wallet.",
	"Method": "boolean isWatched(TransactionBag transactionBag){\r\n    try {\r\n        Script script = getScriptPubKey();\r\n        return transactionBag.isWatchedScript(script);\r\n    } catch (ScriptException e) {\r\n        log.debug(\"Could not parse tx output script: {}\", e.toString());\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.core.Block.getMerkleRoot",
	"Comment": "returns the merkle root in big endian form, calculating it from transactions if necessary.",
	"Method": "Sha256Hash getMerkleRoot(){\r\n    if (merkleRoot == null) {\r\n        unCacheHeader();\r\n        merkleRoot = calculateMerkleRoot();\r\n    }\r\n    return merkleRoot;\r\n}"
}, {
	"Path": "org.bitcoinj.protocols.channels.PaymentChannelServerState.close",
	"Comment": "closes this channel and broadcasts the highest value payment transaction on the network.",
	"Method": "ListenableFuture<Transaction> close(ListenableFuture<Transaction> close,KeyParameter userKey){\r\n    return close(null);\r\n}"
}, {
	"Path": "com.github.pedrovgs.problem61.SumLists.sum",
	"Comment": "iterative solution to solve this problem. the complexity order is the same than in theprevious algorithm in time and space terms, but the execution time is bigger here because weneed to know the list size to be able to transform the list into an integer.",
	"Method": "int sum(ListNode<Integer> n1,ListNode<Integer> n2){\r\n    validateInput(n1, n2);\r\n    int n1Value = calculateNumber(n1);\r\n    int n2Value = calculateNumber(n2);\r\n    return n1Value + n2Value;\r\n}"
}, {
	"Path": "org.bitcoinj.core.UTXOsMessage.getHitMap",
	"Comment": "returns a bit map indicating which of the queried outputs were found in the utxo set.",
	"Method": "byte[] getHitMap(){\r\n    return Arrays.copyOf(hits, hits.length);\r\n}"
}, {
	"Path": "org.bitcoinj.core.Peer.getAddr",
	"Comment": "sends a getaddr request to the peer and returns a future that completes with the answer once the peer has replied.",
	"Method": "ListenableFuture<AddressMessage> getAddr(){\r\n    SettableFuture<AddressMessage> future = SettableFuture.create();\r\n    synchronized (getAddrFutures) {\r\n        getAddrFutures.add(future);\r\n    }\r\n    sendMessage(new GetAddrMessage(params));\r\n    return future;\r\n}"
}, {
	"Path": "org.bitcoinj.core.TransactionOutput.getValue",
	"Comment": "returns the value of this output. this is the amount of currency that the destination addressreceives.",
	"Method": "Coin getValue(){\r\n    try {\r\n        return Coin.valueOf(value);\r\n    } catch (IllegalArgumentException e) {\r\n        throw new IllegalStateException(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "problems.medium.MagicDictionary.search",
	"Comment": "returns if there is any word in the trie that equals to the given word after modifying exactly one character",
	"Method": "boolean search(String word){\r\n    char[] a = word.toCharArray();\r\n    for (int i = 0; i < a.length; i++) {\r\n        for (int j = 0; j < 26; j++) {\r\n            if (a[i] != (char) (j + 'a')) {\r\n                char temp = a[i];\r\n                a[i] = (char) (j + 'a');\r\n                String s = new String(a);\r\n                if (set.contains(s))\r\n                    return true;\r\n                a[i] = temp;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.bitcoinj.core.NetworkParameters.getMajorityWindow",
	"Comment": "the sampling window from which the version numbers of blocks are takenin order to determine if a new block version is now the majority.",
	"Method": "int getMajorityWindow(){\r\n    return majorityWindow;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.WalletFiles.saveLater",
	"Comment": "queues up a save in the background. useful for not very important wallet changes.",
	"Method": "void saveLater(){\r\n    if (executor.isShutdown() || savePending.getAndSet(true))\r\n        return;\r\n    executor.schedule(saver, delay, delayTimeUnit);\r\n}"
}, {
	"Path": "org.bitcoinj.core.ECKey.verify",
	"Comment": "verifies the given asn.1 encoded ecdsa signature against a hash using the public key.",
	"Method": "boolean verify(byte[] data,ECDSASignature signature,byte[] pub,boolean verify,byte[] data,byte[] signature,byte[] pub,boolean verify,byte[] hash,byte[] signature,boolean verify,Sha256Hash sigHash,ECDSASignature signature){\r\n    return ECKey.verify(sigHash.getBytes(), signature, getPubKey());\r\n}"
}, {
	"Path": "io.aeron.logbuffer.LogBufferDescriptor.positionBitsToShift",
	"Comment": "get the number of bits to shift when dividing or multiplying by the term buffer length.",
	"Method": "int positionBitsToShift(int termBufferLength){\r\n    switch(termBufferLength) {\r\n        case 64 * 1024:\r\n            return 16;\r\n        case 128 * 1024:\r\n            return 17;\r\n        case 256 * 1024:\r\n            return 18;\r\n        case 512 * 1024:\r\n            return 19;\r\n        case 1024 * 1024:\r\n            return 20;\r\n        case 2 * 1024 * 1024:\r\n            return 21;\r\n        case 4 * 1024 * 1024:\r\n            return 22;\r\n        case 8 * 1024 * 1024:\r\n            return 23;\r\n        case 16 * 1024 * 1024:\r\n            return 24;\r\n        case 32 * 1024 * 1024:\r\n            return 25;\r\n        case 64 * 1024 * 1024:\r\n            return 26;\r\n        case 128 * 1024 * 1024:\r\n            return 27;\r\n        case 256 * 1024 * 1024:\r\n            return 28;\r\n        case 512 * 1024 * 1024:\r\n            return 29;\r\n        case 1024 * 1024 * 1024:\r\n            return 30;\r\n    }\r\n    throw new IllegalArgumentException(\"Invalid term buffer length: \" + termBufferLength);\r\n}"
}, {
	"Path": "commons.validator.routines.UrlValidator.isValidFragment",
	"Comment": "returns true if the given fragment is null or fragments are allowed.",
	"Method": "boolean isValidFragment(String fragment){\r\n    if (fragment == null) {\r\n        return true;\r\n    }\r\n    return isOff(NO_FRAGMENTS);\r\n}"
}, {
	"Path": "org.bitcoinj.core.Base58.decodeChecked",
	"Comment": "decodes the given base58 string into the original data bytes, using the checksum in thelast 4 bytes of the decoded data to verify that the rest are correct. the checksum isremoved from the returned data.",
	"Method": "byte[] decodeChecked(String input){\r\n    byte[] decoded = decode(input);\r\n    if (decoded.length < 4)\r\n        throw new AddressFormatException.InvalidDataLength(\"Input too short: \" + decoded.length);\r\n    byte[] data = Arrays.copyOfRange(decoded, 0, decoded.length - 4);\r\n    byte[] checksum = Arrays.copyOfRange(decoded, decoded.length - 4, decoded.length);\r\n    byte[] actualChecksum = Arrays.copyOfRange(Sha256Hash.hashTwice(data), 0, 4);\r\n    if (!Arrays.equals(checksum, actualChecksum))\r\n        throw new AddressFormatException.InvalidChecksum();\r\n    return data;\r\n}"
}, {
	"Path": "org.atmosphere.runtime.AtmosphereConfig.isSessionTimeoutRemovalAllowed",
	"Comment": "allow http session timeout removal when session support is active",
	"Method": "boolean isSessionTimeoutRemovalAllowed(){\r\n    return sessionTimeoutRemovalAllowed;\r\n}"
}, {
	"Path": "org.bitcoinj.crypto.ChildKeyDerivationTest.reserialization",
	"Comment": "reserializing a deserialized key should yield the original input",
	"Method": "void reserialization(){\r\n    String encoded = \"xpub6D4BDPcP2GT577Vvch3R8wDkScZWzQzMMUm3PWbmWvVJrZwQY4VUNgqFJPMM3No2dFDFGTsxxpG5uJh7n7epu4trkrX7x7DogT5Uv6fcLW5\";\r\n    DeterministicKey key = DeterministicKey.deserializeB58(encoded, MAINNET);\r\n    assertEquals(\"Reserialized parentless private HD key is wrong\", key.serializePubB58(MAINNET), encoded);\r\n    assertEquals(\"Depth of deserialized parentless public HD key is wrong\", key.getDepth(), 3);\r\n    assertEquals(\"Path size of deserialized parentless public HD key is wrong\", key.getPath().size(), 1);\r\n    assertEquals(\"Parent fingerprint of deserialized parentless public HD key is wrong\", key.getParentFingerprint(), 0xbef5a2f9);\r\n    encoded = \"xprv9z4pot5VBttmtdRTWfWQmoH1taj2axGVzFqSb8C9xaxKymcFzXBDptWmT7FwuEzG3ryjH4ktypQSAewRiNMjANTtpgP4mLTj34bhnZX7UiM\";\r\n    key = DeterministicKey.deserializeB58(encoded, MAINNET);\r\n    assertEquals(\"Reserialized parentless private HD key is wrong\", key.serializePrivB58(MAINNET), encoded);\r\n    assertEquals(\"Depth of deserialized parentless private HD key is wrong\", key.getDepth(), 3);\r\n    assertEquals(\"Path size of deserialized parentless private HD key is wrong\", key.getPath().size(), 1);\r\n    assertEquals(\"Parent fingerprint of deserialized parentless private HD key is wrong\", key.getParentFingerprint(), 0xbef5a2f9);\r\n    assertEquals(\"Parent fingerprint of root node public HD key should be zero\", DeterministicKey.deserializeB58(\"xpub661MyMwAqRbcFW31YEwpkMuc5THy2PSt5bDMsktWQcFF8syAmRUapSCGu8ED9W6oDMSgv6Zz8idoc4a6mr8BDzTJY47LJhkJ8UB7WEGuduB\", MAINNET).getParentFingerprint(), 0);\r\n    assertEquals(\"Parent fingerprint of root node private HD key should be zero\", DeterministicKey.deserializeB58(\"xprv9s21ZrQH143K31xYSDQpPDxsXRTUcvj2iNHm5NUtrGiGG5e2DtALGdso3pGz6ssrdK4PFmM8NSpSBHNqPqm55Qn3LqFtT2emdEXVYsCzC2U\", MAINNET).getParentFingerprint(), 0);\r\n}"
}, {
	"Path": "org.atmosphere.interceptor.HeartbeatInterceptor.extractHeartbeatInterval",
	"Comment": "extracts the heartbeat interval as explained in class description. this method could be overridden to change thethe configuration points.",
	"Method": "int extractHeartbeatInterval(AtmosphereResourceImpl resource){\r\n    int interval = heartbeatFrequencyInSeconds;\r\n    final String s = resource.getRequest(false).getHeader(HeaderConfig.X_HEARTBEAT_SERVER);\r\n    if (s != null) {\r\n        try {\r\n            interval = Integer.parseInt(s);\r\n            if (interval != 0 && interval < heartbeatFrequencyInSeconds) {\r\n                interval = heartbeatFrequencyInSeconds;\r\n            }\r\n        } catch (NumberFormatException nfe) {\r\n            logger.warn(\"{} header is not an integer\", HeaderConfig.X_HEARTBEAT_SERVER, nfe);\r\n        }\r\n    }\r\n    return interval;\r\n}"
}, {
	"Path": "org.bitcoinj.core.FilteredBlock.provideTransaction",
	"Comment": "provide this filteredblock with a transaction which is in its merkle tree.",
	"Method": "boolean provideTransaction(Transaction tx){\r\n    Sha256Hash hash = tx.getHash();\r\n    if (getTransactionHashes().contains(hash)) {\r\n        associatedTransactions.put(hash, tx);\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "io.aeron.SystemTest.executeUntil",
	"Comment": "execute a task until a condition is satisfied, or a maximum number of iterations, or a timeout is reached.",
	"Method": "void executeUntil(BooleanSupplier condition,IntConsumer iterationConsumer,int maxIterations,long timeoutNs){\r\n    final long startNs = System.nanoTime();\r\n    long nowNs;\r\n    int i = 0;\r\n    do {\r\n        checkInterruptedStatus();\r\n        iterationConsumer.accept(i);\r\n        nowNs = System.nanoTime();\r\n    } while (!condition.getAsBoolean() && ((nowNs - startNs) < timeoutNs) && i++ < maxIterations);\r\n}"
}, {
	"Path": "org.bitcoinj.core.Coin.isNegative",
	"Comment": "returns true if and only if this instance represents a monetary value less than zero,otherwise false.",
	"Method": "boolean isNegative(){\r\n    return signum() == -1;\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.DeterministicKeyChain.getKeyLookaheadEpoch",
	"Comment": "returns a counter that is incremented each time new keys are generated due to lookahead. used by the networkcode to learn whether to discard the current block and await calculation of a new filter.",
	"Method": "int getKeyLookaheadEpoch(){\r\n    lock.lock();\r\n    try {\r\n        return keyLookaheadEpoch;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.wallet.Wallet.adjustOutputDownwardsForFee",
	"Comment": "reduce the value of the first output of a transaction to pay the given feeperkb as appropriate for its size.",
	"Method": "boolean adjustOutputDownwardsForFee(Transaction tx,CoinSelection coinSelection,Coin feePerKb,boolean ensureMinRequiredFee){\r\n    final int size = tx.unsafeBitcoinSerialize().length + estimateBytesForSigning(coinSelection);\r\n    Coin fee = feePerKb.multiply(size).divide(1000);\r\n    if (ensureMinRequiredFee && fee.compareTo(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE) < 0)\r\n        fee = Transaction.REFERENCE_DEFAULT_MIN_TX_FEE;\r\n    TransactionOutput output = tx.getOutput(0);\r\n    output.setValue(output.getValue().subtract(fee));\r\n    return !output.isDust();\r\n}"
}, {
	"Path": "org.bitcoinj.protocols.payments.PaymentSession.getPaymentUrl",
	"Comment": "returns the payment url where the payment message should be sent.returns null if no payment url was provided in the paymentrequest.",
	"Method": "String getPaymentUrl(){\r\n    if (paymentDetails.hasPaymentUrl())\r\n        return paymentDetails.getPaymentUrl();\r\n    return null;\r\n}"
}, {
	"Path": "org.bitcoinj.core.Transaction.parse",
	"Comment": "deserialize according to bip144 orthe classic format, depending on if thetransaction is segwit or not.",
	"Method": "void parse(){\r\n    cursor = offset;\r\n    optimalEncodingMessageSize = 4;\r\n    version = readUint32();\r\n    byte marker = payload[cursor];\r\n    boolean useSegwit = marker == 0;\r\n    if (useSegwit) {\r\n        readBytes(2);\r\n        optimalEncodingMessageSize += 2;\r\n    }\r\n    parseInputs();\r\n    parseOutputs();\r\n    if (useSegwit)\r\n        parseWitnesses();\r\n    lockTime = readUint32();\r\n    optimalEncodingMessageSize += 4;\r\n    length = cursor - offset;\r\n}"
}, {
	"Path": "org.bitcoinj.crypto.DeterministicKey.isEncrypted",
	"Comment": "a deterministic key is considered to be encrypted if it has access to encrypted private key bytes, or if itsparent does. the reason is because the parent would be encrypted under the same key and this key knows how torederive its own private key bytes from the parent, if needed.",
	"Method": "boolean isEncrypted(){\r\n    return priv == null && (super.isEncrypted() || (parent != null && parent.isEncrypted()));\r\n}"
}, {
	"Path": "io.aeron.ControlledFragmentAssembler.clear",
	"Comment": "clear down the cache of buffers by session for reassembling messages.",
	"Method": "void clear(){\r\n    builderBySessionIdMap.clear();\r\n}"
}, {
	"Path": "com.github.pedrovgs.problem5.DivideUsingSubtraction.divideRecursive",
	"Comment": "recursive version of the previous algorithm .the complexity order in space and memory terms isthe same than the iterative version. however this algorithm is more expensive in computationterms because recursion is going to add a new frame to the stack every time a recursive callis performed. review this algorithm and take into account this algorithm is not tailrecursive.",
	"Method": "float divideRecursive(int dividend,int divider){\r\n    validateInput(divider);\r\n    if (dividend == 0) {\r\n        return 0f;\r\n    } else if (dividend < divider) {\r\n        return (float) dividend / (float) divider;\r\n    } else {\r\n        return 1f + divideRecursive(dividend - divider, divider);\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.kits.WalletAppKit.isChainFileLocked",
	"Comment": "tests to see if the spvchain file has an operating system file lock on it. useful for checking if your appis already running. if another copy of your app is running and you start the appkit anyway, an exception willbe thrown during the startup process. returns false if the chain file does not exist or is a directory.",
	"Method": "boolean isChainFileLocked(){\r\n    RandomAccessFile file2 = null;\r\n    try {\r\n        File file = new File(directory, filePrefix + \".spvchain\");\r\n        if (!file.exists())\r\n            return false;\r\n        if (file.isDirectory())\r\n            return false;\r\n        file2 = new RandomAccessFile(file, \"rw\");\r\n        FileLock lock = file2.getChannel().tryLock();\r\n        if (lock == null)\r\n            return true;\r\n        lock.release();\r\n        return false;\r\n    } finally {\r\n        if (file2 != null)\r\n            file2.close();\r\n    }\r\n}"
}, {
	"Path": "io.aeron.cluster.RecordingLog.createRecoveryPlan",
	"Comment": "create a recovery plan that has only snapshots. used for dynamicjoin snapshot load.",
	"Method": "RecoveryPlan createRecoveryPlan(AeronArchive archive,int serviceCount,RecoveryPlan createRecoveryPlan,ArrayList<RecordingLog.Snapshot> snapshots){\r\n    long lastLeadershipTermId = NULL_VALUE;\r\n    long lastTermBaseLogPosition = 0;\r\n    long committedLogPosition = -1;\r\n    long appendedLogPosition = 0;\r\n    final int snapshotStepsSize = snapshots.size();\r\n    if (snapshotStepsSize > 0) {\r\n        final Snapshot snapshot = snapshots.get(0);\r\n        lastLeadershipTermId = snapshot.leadershipTermId;\r\n        lastTermBaseLogPosition = snapshot.termBaseLogPosition;\r\n        appendedLogPosition = snapshot.logPosition;\r\n        committedLogPosition = snapshot.logPosition;\r\n    }\r\n    return new RecoveryPlan(lastLeadershipTermId, lastTermBaseLogPosition, appendedLogPosition, committedLogPosition, snapshots, new ArrayList());\r\n}"
}, {
	"Path": "org.bitcoinj.core.NetworkParameters.getMaxTarget",
	"Comment": "maximum target represents the easiest allowable proof of work.",
	"Method": "BigInteger getMaxTarget(){\r\n    return maxTarget;\r\n}"
}, {
	"Path": "org.atmosphere.runtime.DefaultAsyncSupportResolver.resolveMultipleNativeSupportConflict",
	"Comment": "this method is called if there are more than one potential native container in scope.",
	"Method": "AsyncSupport resolveMultipleNativeSupportConflict(List<Class<? extends AsyncSupport>> available){\r\n    final StringBuilder b = new StringBuilder(\"Found multiple containers, please specify which one to use: \");\r\n    for (Class<? extends AsyncSupport> cs : available) {\r\n        b.append((cs != null) ? cs.getCanonicalName() : \"null\").append(\", \");\r\n    }\r\n    b.append(\" until you do, Atmosphere will use:\" + available.get(0));\r\n    logger.warn(\"{}\", b.toString());\r\n    return newCometSupport(available.get(0));\r\n}"
}, {
	"Path": "org.bitcoinj.core.AbstractBlockChain.add",
	"Comment": "filteredtxhashlist contains all transactions, filteredtxn just a subset",
	"Method": "boolean add(Block block,boolean add,FilteredBlock block,boolean add,Block block,boolean tryConnecting,List<Sha256Hash> filteredTxHashList,Map<Sha256Hash, Transaction> filteredTxn){\r\n    lock.lock();\r\n    try {\r\n        if (block.equals(getChainHead().getHeader())) {\r\n            return true;\r\n        }\r\n        if (tryConnecting && orphanBlocks.containsKey(block.getHash())) {\r\n            return false;\r\n        }\r\n        if (shouldVerifyTransactions() && block.transactions == null)\r\n            throw new VerificationException(\"Got a block header while running in full-block mode\");\r\n        if (shouldVerifyTransactions() && blockStore.get(block.getHash()) != null) {\r\n            return true;\r\n        }\r\n        final StoredBlock storedPrev;\r\n        final int height;\r\n        final EnumSet<Block.VerifyFlag> flags;\r\n        try {\r\n            block.verifyHeader();\r\n            storedPrev = getStoredBlockInCurrentScope(block.getPrevBlockHash());\r\n            if (storedPrev != null) {\r\n                height = storedPrev.getHeight() + 1;\r\n            } else {\r\n                height = Block.BLOCK_HEIGHT_UNKNOWN;\r\n            }\r\n            flags = params.getBlockVerificationFlags(block, versionTally, height);\r\n            if (shouldVerifyTransactions())\r\n                block.verifyTransactions(height, flags);\r\n        } catch (VerificationException e) {\r\n            log.error(\"Failed to verify block: \", e);\r\n            log.error(block.getHashAsString());\r\n            throw e;\r\n        }\r\n        if (storedPrev == null) {\r\n            checkState(tryConnecting, \"bug in tryConnectingOrphans\");\r\n            log.warn(\"Block does not connect: {} prev {}\", block.getHashAsString(), block.getPrevBlockHash());\r\n            orphanBlocks.put(block.getHash(), new OrphanBlock(block, filteredTxHashList, filteredTxn));\r\n            return false;\r\n        } else {\r\n            checkState(lock.isHeldByCurrentThread());\r\n            params.checkDifficultyTransitions(storedPrev, block, blockStore);\r\n            connectBlock(block, storedPrev, shouldVerifyTransactions(), filteredTxHashList, filteredTxn);\r\n        }\r\n        if (tryConnecting)\r\n            tryConnectingOrphans();\r\n        return true;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "com.mikepenz.iconics.IconicsDrawable.updateTintFilter",
	"Comment": "ensures the tint filter is consistent with the current tint color andmode.",
	"Method": "PorterDuffColorFilter updateTintFilter(ColorStateList tint,PorterDuff.Mode tintMode){\r\n    if (tint == null || tintMode == null) {\r\n        return null;\r\n    }\r\n    final int color = tint.getColorForState(getState(), Color.TRANSPARENT);\r\n    return new PorterDuffColorFilter(color, tintMode);\r\n}"
}, {
	"Path": "io.aeron.logbuffer.BufferClaim.commit",
	"Comment": "commit the message to the log buffer so that is it available to subscribers.",
	"Method": "void commit(){\r\n    int frameLength = buffer.capacity();\r\n    if (ByteOrder.nativeOrder() != LITTLE_ENDIAN) {\r\n        frameLength = Integer.reverseBytes(frameLength);\r\n    }\r\n    buffer.putIntOrdered(FRAME_LENGTH_FIELD_OFFSET, frameLength);\r\n}"
}, {
	"Path": "org.atmosphere.util.uri.UriTemplate.getNumberOfExplicitCharacters",
	"Comment": "get the number of characters in the regular expression not resultingfrom conversion of template variables.",
	"Method": "int getNumberOfExplicitCharacters(){\r\n    return numOfCharacters;\r\n}"
}, {
	"Path": "org.atmosphere.runtime.AtmosphereFramework.addBroadcasterType",
	"Comment": "add a new broadcaster class name that atmosphereservlet can use when initializing requests, and when theatmosphere.xml broadcaster element is unspecified.",
	"Method": "AtmosphereFramework addBroadcasterType(String broadcasterTypeString){\r\n    broadcasterTypes.add(broadcasterTypeString);\r\n    return this;\r\n}"
}, {
	"Path": "commons.validator.routines.CodeValidator.getCheckDigit",
	"Comment": "return the check digit validation routine.n.b. optional, if not set no check digitvalidation will be performed on the code.",
	"Method": "CheckDigit getCheckDigit(){\r\n    return checkdigit;\r\n}"
}, {
	"Path": "org.atmosphere.util.uri.UriTemplate.equals",
	"Comment": "equality is calculated from the string of the regular expression generated from the templates.",
	"Method": "boolean equals(Object o){\r\n    if (o instanceof UriTemplate) {\r\n        UriTemplate that = (UriTemplate) o;\r\n        return this.pattern.equals(that.pattern);\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.script.Script.executeCheckLockTimeVerify",
	"Comment": "this is more or less a direct translation of the code in bitcoin core",
	"Method": "void executeCheckLockTimeVerify(Transaction txContainingThis,int index,LinkedList<byte[]> stack,Set<VerifyFlag> verifyFlags){\r\n    if (stack.size() < 1)\r\n        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, \"Attempted OP_CHECKLOCKTIMEVERIFY on a stack with size < 1\");\r\n    final BigInteger nLockTime = castToBigInteger(stack.getLast(), 5, verifyFlags.contains(VerifyFlag.MINIMALDATA));\r\n    if (nLockTime.compareTo(BigInteger.ZERO) < 0)\r\n        throw new ScriptException(ScriptError.SCRIPT_ERR_NEGATIVE_LOCKTIME, \"Negative locktime\");\r\n    if (!(((txContainingThis.getLockTime() < Transaction.LOCKTIME_THRESHOLD) && (nLockTime.compareTo(Transaction.LOCKTIME_THRESHOLD_BIG)) < 0) || ((txContainingThis.getLockTime() >= Transaction.LOCKTIME_THRESHOLD) && (nLockTime.compareTo(Transaction.LOCKTIME_THRESHOLD_BIG)) >= 0)))\r\n        throw new ScriptException(ScriptError.SCRIPT_ERR_UNSATISFIED_LOCKTIME, \"Locktime requirement type mismatch\");\r\n    if (nLockTime.compareTo(BigInteger.valueOf(txContainingThis.getLockTime())) > 0)\r\n        throw new ScriptException(ScriptError.SCRIPT_ERR_UNSATISFIED_LOCKTIME, \"Locktime requirement not satisfied\");\r\n    if (!txContainingThis.getInput(index).hasSequence())\r\n        throw new ScriptException(ScriptError.SCRIPT_ERR_UNSATISFIED_LOCKTIME, \"Transaction contains a final transaction input for a CHECKLOCKTIMEVERIFY script.\");\r\n}"
}, {
	"Path": "org.bitcoinj.protocols.channels.StoredPaymentChannelServerStates.updatedChannel",
	"Comment": "notifies the set of stored states that a channel has been updated. use to notify the wallet of an update to thiswallet extension.",
	"Method": "void updatedChannel(StoredServerChannel channel){\r\n    log.info(\"Stored server channel {} was updated\", channel.hashCode());\r\n    wallet.addOrUpdateExtension(this);\r\n}"
}, {
	"Path": "org.bitcoinj.utils.Fiat.isZero",
	"Comment": "returns true if and only if this instance represents zero monetary value, otherwise false.",
	"Method": "boolean isZero(){\r\n    return signum() == 0;\r\n}"
}, {
	"Path": "org.bitcoinj.core.VarInt.sizeOf",
	"Comment": "returns the minimum encoded size of the given unsigned long value.",
	"Method": "int sizeOf(long value){\r\n    if (value < 0)\r\n        return 9;\r\n    if (value < 253)\r\n        return 1;\r\n    if (value <= 0xFFFFL)\r\n        return 3;\r\n    if (value <= 0xFFFFFFFFL)\r\n        return 5;\r\n    return 9;\r\n}"
}, {
	"Path": "org.bitcoinj.protocols.channels.PaymentChannelServerState.getContract",
	"Comment": "gets the multisig contract which was used to initialize this channel",
	"Method": "Transaction getContract(){\r\n    checkState(contract != null);\r\n    return contract;\r\n}"
}, {
	"Path": "io.aeron.logbuffer.FrameDescriptor.frameLengthOrdered",
	"Comment": "write the length header for a frame in a memory ordered fashion.",
	"Method": "void frameLengthOrdered(UnsafeBuffer buffer,int termOffset,int frameLength){\r\n    int length = frameLength;\r\n    if (ByteOrder.nativeOrder() != LITTLE_ENDIAN) {\r\n        length = Integer.reverseBytes(frameLength);\r\n    }\r\n    buffer.putIntOrdered(termOffset, length);\r\n}"
}, {
	"Path": "io.aeron.ChannelUri.initialPosition",
	"Comment": "initialise a channel for restarting a publication at a given position.",
	"Method": "void initialPosition(long position,int initialTermId,int termLength){\r\n    final int bitsToShift = LogBufferDescriptor.positionBitsToShift(termLength);\r\n    final int termId = LogBufferDescriptor.computeTermIdFromPosition(position, bitsToShift, initialTermId);\r\n    final int termOffset = (int) (position & (termLength - 1));\r\n    put(INITIAL_TERM_ID_PARAM_NAME, Integer.toString(initialTermId));\r\n    put(TERM_ID_PARAM_NAME, Integer.toString(termId));\r\n    put(TERM_OFFSET_PARAM_NAME, Integer.toString(termOffset));\r\n    put(TERM_LENGTH_PARAM_NAME, Integer.toString(termLength));\r\n}"
}, {
	"Path": "org.bitcoinj.protocols.channels.StoredPaymentChannelClientStates.getUsableChannelForServerID",
	"Comment": "finds an inactive channel with the given id and returns it, or returns null.",
	"Method": "StoredClientChannel getUsableChannelForServerID(Sha256Hash id){\r\n    lock.lock();\r\n    try {\r\n        Set<StoredClientChannel> setChannels = mapChannels.get(id);\r\n        for (StoredClientChannel channel : setChannels) {\r\n            synchronized (channel) {\r\n                log.info(\"Considering channel {} contract {}\", channel.hashCode(), channel.contract.getHash());\r\n                if (channel.close != null || channel.valueToMe.equals(Coin.ZERO)) {\r\n                    log.info(\"  ... but is closed or empty\");\r\n                    continue;\r\n                }\r\n                if (!channel.active) {\r\n                    log.info(\"  ... activating\");\r\n                    channel.active = true;\r\n                    return channel;\r\n                }\r\n                log.info(\"  ... but is already active\");\r\n            }\r\n        }\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "io.aeron.archive.client.AeronArchive.listRecording",
	"Comment": "list all recording descriptors from a recording id with a limit of record count.if the recording id is greater than the largest known id then nothing is returned.",
	"Method": "int listRecording(long recordingId,RecordingDescriptorConsumer consumer){\r\n    lock.lock();\r\n    try {\r\n        final long correlationId = aeron.nextCorrelationId();\r\n        if (!archiveProxy.listRecording(recordingId, correlationId, controlSessionId)) {\r\n            throw new ArchiveException(\"failed to send list recording request\");\r\n        }\r\n        return pollForDescriptors(correlationId, 1, consumer);\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.bitcoinj.script.Script.removeAllInstancesOf",
	"Comment": "returns the script bytes of inputscript with all instances of the specified script object removed",
	"Method": "byte[] removeAllInstancesOf(byte[] inputScript,byte[] chunkToRemove){\r\n    UnsafeByteArrayOutputStream bos = new UnsafeByteArrayOutputStream(inputScript.length);\r\n    int cursor = 0;\r\n    while (cursor < inputScript.length) {\r\n        boolean skip = equalsRange(inputScript, cursor, chunkToRemove);\r\n        int opcode = inputScript[cursor++] & 0xFF;\r\n        int additionalBytes = 0;\r\n        if (opcode >= 0 && opcode < OP_PUSHDATA1) {\r\n            additionalBytes = opcode;\r\n        } else if (opcode == OP_PUSHDATA1) {\r\n            additionalBytes = (0xFF & inputScript[cursor]) + 1;\r\n        } else if (opcode == OP_PUSHDATA2) {\r\n            additionalBytes = Utils.readUint16(inputScript, cursor) + 2;\r\n        } else if (opcode == OP_PUSHDATA4) {\r\n            additionalBytes = (int) Utils.readUint32(inputScript, cursor) + 4;\r\n        }\r\n        if (!skip) {\r\n            try {\r\n                bos.write(opcode);\r\n                bos.write(Arrays.copyOfRange(inputScript, cursor, cursor + additionalBytes));\r\n            } catch (IOException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n        }\r\n        cursor += additionalBytes;\r\n    }\r\n    return bos.toByteArray();\r\n}"
}]