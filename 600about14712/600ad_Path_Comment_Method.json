[{
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.FileExporter.exportFile",
	"Comment": "writes a file to secondary storage and makes entries for the file in themaster catalog and the catalogs of the export rules the file satisfied.",
	"Method": "void exportFile(Long fileId,List<String> ruleNames,Supplier<Boolean> cancelCheck){\r\n    AbstractFile file = Case.getCurrentCaseThrows().getSleuthkitCase().getAbstractFileById(fileId);\r\n    if (!shouldExportFile(file)) {\r\n        return;\r\n    }\r\n    Map<BlackboardArtifact, List<BlackboardAttribute>> artifactsToAttributes = new HashMap();\r\n    List<BlackboardArtifact> artifacts = file.getAllArtifacts();\r\n    for (BlackboardArtifact artifact : artifacts) {\r\n        artifactsToAttributes.put(artifact, artifact.getAttributes());\r\n    }\r\n    Path filePath = exportFileToSecondaryStorage(file, cancelCheck);\r\n    if (filePath == null) {\r\n        return;\r\n    }\r\n    addFileToCatalog(file, artifactsToAttributes, filePath, masterCatalog);\r\n    for (String ruleName : ruleNames) {\r\n        JsonGenerator ruleCatalog = this.ruleNamesToCatalogs.get(ruleName);\r\n        if (null == ruleCatalog) {\r\n            Path catalogPath = Paths.get(reportsDirPath.toString(), ruleName, \"catalog.json\");\r\n            Files.createDirectories(catalogPath.getParent());\r\n            File catalogFile = catalogPath.toFile();\r\n            ruleCatalog = jsonGeneratorFactory.createGenerator(catalogFile, JsonEncoding.UTF8);\r\n            ruleNamesToCatalogs.put(ruleName, ruleCatalog);\r\n        }\r\n        addFileToCatalog(file, artifactsToAttributes, filePath, ruleCatalog);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.LocalFilesDSProcessor.extractLogicalEvidenceFileContents",
	"Comment": "extract the contents of the logical evidence files and return the pathsto those extracted files.",
	"Method": "List<String> extractLogicalEvidenceFileContents(List<String> logicalEvidenceFilePaths){\r\n    final List<String> extractedPaths = new ArrayList();\r\n    Path ewfexportPath;\r\n    ewfexportPath = locateEwfexportExecutable();\r\n    List<String> command = new ArrayList();\r\n    for (final String l01Path : logicalEvidenceFilePaths) {\r\n        command.clear();\r\n        command.add(ewfexportPath.toAbsolutePath().toString());\r\n        command.add(\"-f\");\r\n        command.add(\"files\");\r\n        command.add(\"-t\");\r\n        File l01Dir = new File(Case.getCurrentCaseThrows().getModuleDirectory(), L01_EXTRACTION_DIR);\r\n        if (!l01Dir.exists()) {\r\n            l01Dir.mkdirs();\r\n        }\r\n        Path dirPath = Paths.get(FilenameUtils.getBaseName(l01Path) + UNIQUENESS_CONSTRAINT_SEPERATOR + System.currentTimeMillis());\r\n        command.add(dirPath.toString());\r\n        command.add(l01Path);\r\n        ProcessBuilder processBuilder = new ProcessBuilder(command);\r\n        processBuilder.directory(l01Dir);\r\n        try {\r\n            Path logFileName = Paths.get(l01Dir.toString(), dirPath.toString() + LOG_FILE_EXTENSION);\r\n            File logFile = new File(logFileName.toString());\r\n            Path errFileName = Paths.get(l01Dir.toString(), dirPath.toString() + LOG_FILE_EXTENSION);\r\n            File errFile = new File(errFileName.toString());\r\n            processBuilder.redirectError(ProcessBuilder.Redirect.appendTo(errFile));\r\n            processBuilder.redirectOutput(ProcessBuilder.Redirect.appendTo(logFile));\r\n            ExecUtil.execute(processBuilder, new ExecUtil.TimedProcessTerminator());\r\n            if (l01Dir.toPath().resolve(dirPath).toFile().exists()) {\r\n                extractedPaths.add(l01Dir.toPath().resolve(dirPath).toString());\r\n            } else {\r\n                throw new L01Exception(\"Can not process the selected L01 file, ewfExport was unable to extract any files from it.\");\r\n            }\r\n        } catch (SecurityException ex) {\r\n            throw new L01Exception(\"Security exception occcured while trying to extract l01 contents\", ex);\r\n        } catch (IOException ex) {\r\n            throw new L01Exception(\"IOException occcured while trying to extract l01 contents\", ex);\r\n        }\r\n    }\r\n    return extractedPaths;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.optionspanel.GlobalSettingsPanel.isLocalIngestJobEvent",
	"Comment": "check that the supplied event is a local ingestjobevent whose type isstarted, cancelled, or completed.",
	"Method": "boolean isLocalIngestJobEvent(PropertyChangeEvent event){\r\n    if (event instanceof AutopsyEvent) {\r\n        if (((AutopsyEvent) event).getSourceType() == AutopsyEvent.SourceType.LOCAL) {\r\n            String eventType = event.getPropertyName();\r\n            return (eventType.equals(IngestManager.IngestJobEvent.STARTED.toString()) || eventType.equals(IngestManager.IngestJobEvent.CANCELLED.toString()) || eventType.equals(IngestManager.IngestJobEvent.COMPLETED.toString()));\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.services.TagsManager.containsIllegalCharacters",
	"Comment": "tests whether or not a given tag display name contains an illegalcharacter.",
	"Method": "boolean containsIllegalCharacters(String tagDisplayName){\r\n    return (tagDisplayName.contains(\"\\\\\") || tagDisplayName.contains(\":\") || tagDisplayName.contains(\"*\") || tagDisplayName.contains(\"?\") || tagDisplayName.contains(\"\\\"\") || tagDisplayName.contains(\"<\") || tagDisplayName.contains(\">\") || tagDisplayName.contains(\"|\") || tagDisplayName.contains(\",\") || tagDisplayName.contains(\";\"));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.hashdatabase.HashDbManager.getKnownFileHashSets",
	"Comment": "gets all of the hash databases used to classify files as known.",
	"Method": "List<HashDb> getKnownFileHashSets(){\r\n    List<HashDb> hashDbs = new ArrayList();\r\n    try {\r\n        updateHashSetsFromCentralRepository();\r\n    } catch (TskCoreException ex) {\r\n        Logger.getLogger(HashDbManager.class.getName()).log(Level.SEVERE, \"Error loading central repository hash sets\", ex);\r\n    }\r\n    this.hashSets.stream().filter((db) -> (db.getKnownFilesType() == HashDb.KnownFilesType.KNOWN)).forEach((db) -> {\r\n        hashDbs.add(db);\r\n    });\r\n    return hashDbs;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.FileIDSelectionModel.getSelected",
	"Comment": "expose the list of selected ids so that clients can listen for changes",
	"Method": "ObservableSet<Long> getSelected(){\r\n    return selected;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJobLogger.logDataSourceProcessorCancelled",
	"Comment": "logs cancellation of the addition of a data source to the case database.",
	"Method": "void logDataSourceProcessorCancelled(){\r\n    log(MessageCategory.WARNING, \"Cancelled adding data source to case\");\r\n}"
}, {
	"Path": "com.aliyun.oss.internal.ResponseParsers.parseGetUdfApplicationInfo",
	"Comment": "unmarshall get udf info response body to udf application info.",
	"Method": "UdfApplicationInfo parseGetUdfApplicationInfo(InputStream responseBody){\r\n    try {\r\n        Element root = getXmlRootElement(responseBody);\r\n        String id = root.getChildText(\"ID\");\r\n        String name = root.getChildText(\"Name\");\r\n        String status = root.getChildText(\"Status\");\r\n        String region = root.getChildText(\"Region\");\r\n        Integer imageVersion = Integer.valueOf(root.getChildText(\"ImageVersion\"));\r\n        Integer instanceNum = Integer.valueOf(root.getChildText(\"InstanceNum\"));\r\n        Date date = DateUtil.parseIso8601Date(root.getChildText(\"CreationDate\"));\r\n        String instanceType = root.getChild(\"Flavor\").getChildText(\"InstanceType\");\r\n        InstanceFlavor flavor = new InstanceFlavor(instanceType);\r\n        return new UdfApplicationInfo(name, id, region, status, imageVersion, instanceNum, date, flavor);\r\n    } catch (JDOMParseException e) {\r\n        throw new ResponseParseException(e.getPartialDocument() + \": \" + e.getMessage(), e);\r\n    } catch (Exception e) {\r\n        throw new ResponseParseException(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.AdHocSearchFilterNode.getActions",
	"Comment": "right click action for the nodes that we want to pass to the directorytable and the output view.",
	"Method": "Action[] getActions(boolean popup){\r\n    List<Action> actions = new ArrayList();\r\n    actions.addAll(Arrays.asList(super.getActions(popup)));\r\n    Content content = this.getOriginal().getLookup().lookup(Content.class);\r\n    actions.addAll(content.accept(new GetPopupActionsContentVisitor()));\r\n    return actions.toArray(new Action[actions.size()]);\r\n}"
}, {
	"Path": "com.mcxiaoke.next.utils.StringUtils.toStringArray",
	"Comment": "copy the given enumeration into a string array. the enumeration mustcontain string elements only.",
	"Method": "String[] toStringArray(Collection<String> collection,String[] toStringArray,Enumeration<String> enumeration){\r\n    if (enumeration == null) {\r\n        return null;\r\n    }\r\n    List<String> list = Collections.list(enumeration);\r\n    return list.toArray(new String[list.size()]);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.AbstractSqlEamDb.getCorrelationAttributeInstance",
	"Comment": "find a correlation attribute in the central repository database given theinstance type, case, data source, value, and file path.",
	"Method": "CorrelationAttributeInstance getCorrelationAttributeInstance(CorrelationAttributeInstance.Type type,CorrelationCase correlationCase,CorrelationDataSource correlationDataSource,long objectID,CorrelationAttributeInstance getCorrelationAttributeInstance,CorrelationAttributeInstance.Type type,CorrelationCase correlationCase,CorrelationDataSource correlationDataSource,String value,String filePath){\r\n    if (correlationCase == null) {\r\n        throw new EamDbException(\"Correlation case is null\");\r\n    }\r\n    if (correlationDataSource == null) {\r\n        throw new EamDbException(\"Correlation data source is null\");\r\n    }\r\n    if (filePath == null) {\r\n        throw new EamDbException(\"Correlation file path is null\");\r\n    }\r\n    Connection conn = connect();\r\n    PreparedStatement preparedStatement = null;\r\n    ResultSet resultSet = null;\r\n    CorrelationAttributeInstance correlationAttributeInstance = null;\r\n    try {\r\n        String normalizedValue = CorrelationAttributeNormalizer.normalize(type, value);\r\n        String tableName = EamDbUtil.correlationTypeToInstanceTableName(type);\r\n        String sql = \"SELECT id, known_status, comment FROM \" + tableName + \" WHERE case_id=?\" + \" AND data_source_id=?\" + \" AND value=?\" + \" AND file_path=?\";\r\n        preparedStatement = conn.prepareStatement(sql);\r\n        preparedStatement.setInt(1, correlationCase.getID());\r\n        preparedStatement.setInt(2, correlationDataSource.getID());\r\n        preparedStatement.setString(3, normalizedValue);\r\n        preparedStatement.setString(4, filePath.toLowerCase());\r\n        resultSet = preparedStatement.executeQuery();\r\n        if (resultSet.next()) {\r\n            int instanceId = resultSet.getInt(1);\r\n            int knownStatus = resultSet.getInt(2);\r\n            String comment = resultSet.getString(3);\r\n            correlationAttributeInstance = new CorrelationAttributeInstance(type, value, instanceId, correlationCase, correlationDataSource, filePath, comment, TskData.FileKnown.valueOf((byte) knownStatus), null);\r\n        }\r\n    } catch (SQLException ex) {\r\n        throw new EamDbException(\"Error getting notable artifact instances.\", ex);\r\n    } finally {\r\n        EamDbUtil.closeStatement(preparedStatement);\r\n        EamDbUtil.closeResultSet(resultSet);\r\n        EamDbUtil.closeConnection(conn);\r\n    }\r\n    return correlationAttributeInstance;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.VideoUtils.getTempVideoFile",
	"Comment": "gets a file object in the temp directory of the current case for thegiven abstractfile object.",
	"Method": "File getTempVideoFile(AbstractFile file){\r\n    try {\r\n        return getVideoFileInTempDir(file);\r\n    } catch (NoCurrentCaseException ex) {\r\n        throw new IllegalStateException(ex);\r\n    }\r\n}"
}, {
	"Path": "com.facebook.samples.zoomable.DefaultZoomableController.canScrollInAllDirection",
	"Comment": "returns whether the scroll can happen in all directions. i.e. the image is not on any edge.",
	"Method": "boolean canScrollInAllDirection(){\r\n    return mTransformedImageBounds.left < mViewBounds.left - EPS && mTransformedImageBounds.top < mViewBounds.top - EPS && mTransformedImageBounds.right > mViewBounds.right + EPS && mTransformedImageBounds.bottom > mViewBounds.bottom + EPS;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.healthmonitor.HealthMonitor.startTimer",
	"Comment": "start the scheduledthreadpoolexecutor that will handle the databasewrites.",
	"Method": "void startTimer(){\r\n    stopTimer();\r\n    healthMonitorOutputTimer = new ScheduledThreadPoolExecutor(1, new ThreadFactoryBuilder().setNameFormat(\"health_monitor_timer\").build());\r\n    healthMonitorOutputTimer.scheduleWithFixedDelay(new PeriodicHealthMonitorTask(), DATABASE_WRITE_INTERVAL, DATABASE_WRITE_INTERVAL, TimeUnit.MINUTES);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.filetypeid.FileTypeIdGlobalSettingsPanel.populateTypeDetailsComponents",
	"Comment": "populates all of the components in the file type details portion of thepanel based on the current selection in the file types list.",
	"Method": "void populateTypeDetailsComponents(){\r\n    FileType fileType = typesList.getSelectedValue();\r\n    this.signatureList.setEnabled(false);\r\n    if (null != fileType) {\r\n        List<Signature> signatures = fileType.getSignatures();\r\n        this.signaturesListModel.clear();\r\n        for (Signature sig : signatures) {\r\n            signaturesListModel.addElement(sig);\r\n        }\r\n    }\r\n    enableButtons();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.services.TagOptionsPanel.updateTagNamesListModel",
	"Comment": "updates the tag names model for the tag names list component.",
	"Method": "void updateTagNamesListModel(){\r\n    tagTypesListModel.clear();\r\n    for (TagNameDefinition tagName : tagTypes) {\r\n        tagTypesListModel.addElement(tagName);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.PostgresEamDbSettings.getAddValueIndexTemplate",
	"Comment": "get the template for creating an index on the value column of an instancetable. %s will exist in the template where the name of the new table willbe addedd.",
	"Method": "String getAddValueIndexTemplate(){\r\n    return \"CREATE INDEX IF NOT EXISTS %s_value ON %s (value)\";\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.LuceneQuery.postKeywordHitToBlackboard",
	"Comment": "posts a keyword hit artifact to the blackboard for a given keyword hit.",
	"Method": "BlackboardArtifact postKeywordHitToBlackboard(Content content,Keyword foundKeyword,KeywordHit hit,String snippet,String listName){\r\n    final String MODULE_NAME = KeywordSearchModuleFactory.getModuleName();\r\n    Collection<BlackboardAttribute> attributes = new ArrayList();\r\n    BlackboardArtifact bba;\r\n    try {\r\n        bba = content.newArtifact(ARTIFACT_TYPE.TSK_KEYWORD_HIT);\r\n    } catch (TskCoreException e) {\r\n        logger.log(Level.WARNING, \"Error adding bb artifact for keyword hit\", e);\r\n        return null;\r\n    }\r\n    if (snippet != null) {\r\n        attributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_KEYWORD_PREVIEW, MODULE_NAME, snippet));\r\n    }\r\n    attributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_KEYWORD, MODULE_NAME, foundKeyword.getSearchTerm()));\r\n    if (StringUtils.isNotBlank(listName)) {\r\n        attributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_SET_NAME, MODULE_NAME, listName));\r\n    }\r\n    if (originalKeyword != null) {\r\n        BlackboardAttribute.ATTRIBUTE_TYPE selType = originalKeyword.getArtifactAttributeType();\r\n        if (selType != null) {\r\n            attributes.add(new BlackboardAttribute(selType, MODULE_NAME, foundKeyword.getSearchTerm()));\r\n        }\r\n        if (originalKeyword.searchTermIsWholeWord()) {\r\n            attributes.add(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_KEYWORD_SEARCH_TYPE, MODULE_NAME, KeywordSearch.QueryType.LITERAL.ordinal()));\r\n        } else {\r\n            attributes.add(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_KEYWORD_SEARCH_TYPE, MODULE_NAME, KeywordSearch.QueryType.SUBSTRING.ordinal()));\r\n        }\r\n    }\r\n    hit.getArtifactID().ifPresent(artifactID -> attributes.add(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_ASSOCIATED_ARTIFACT, MODULE_NAME, artifactID)));\r\n    try {\r\n        bba.addAttributes(attributes);\r\n        return bba;\r\n    } catch (TskCoreException e) {\r\n        logger.log(Level.WARNING, \"Error adding bb attributes to artifact\", e);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.encryptiondetection.EncryptionDetectionIngestJobSettings.setMinimumEntropy",
	"Comment": "set the minimum entropy necessary for the creation of blackboardartifacts.",
	"Method": "void setMinimumEntropy(double minimumEntropy){\r\n    this.minimumEntropy = minimumEntropy;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.datamodel.DrawableFile.create",
	"Comment": "skip the database query if we have already determined the file type.",
	"Method": "DrawableFile create(AbstractFile abstractFile,boolean analyzed,DrawableFile create,AbstractFile file,boolean analyzed,boolean isVideo,DrawableFile create,Long fileID,boolean analyzed){\r\n    return create(Case.getCurrentCaseThrows().getSleuthkitCase().getAbstractFileById(fileID), analyzed);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.DataSourceIngestJob.currentDataSourceIngestModuleCancellationCompleted",
	"Comment": "rescind a temporary cancellation of data source level ingest that wasused to stop a single data source level ingest module for this job.",
	"Method": "void currentDataSourceIngestModuleCancellationCompleted(String moduleDisplayName){\r\n    this.currentDataSourceIngestModuleCancelled = false;\r\n    this.cancelledDataSourceIngestModules.add(moduleDisplayName);\r\n    if (this.doUI) {\r\n        synchronized (this.dataSourceIngestProgressLock) {\r\n            this.dataSourceIngestProgress.finish();\r\n            this.dataSourceIngestProgress = null;\r\n            this.startDataSourceIngestProgressBar();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.events.DataSourceAddedEvent.getDataSourceId",
	"Comment": "gets the unique id used to pair this datasourceaddedevent with thecorresponding addingdatasourceevent.",
	"Method": "UUID getDataSourceId(){\r\n    return dataSourceId;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.Case.getLogDirectoryPath",
	"Comment": "gets the full path to the log directory for this case, creating it if itdoes not exist.",
	"Method": "String getLogDirectoryPath(){\r\n    return getOrCreateSubdirectory(LOG_FOLDER);\r\n}"
}, {
	"Path": "com.mcxiaoke.next.collection.WeakFastHashMap.putAll",
	"Comment": "copy all of the mappings from the specified map to this one, replacingany mappings with the same keys.",
	"Method": "void putAll(Map<? extends K, ? extends V> in){\r\n    if (fast) {\r\n        synchronized (this) {\r\n            Map<K, V> temp = cloneMap(map);\r\n            temp.putAll(in);\r\n            map = temp;\r\n        }\r\n    } else {\r\n        synchronized (map) {\r\n            map.putAll(in);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.SqliteEamDb.acquireSharedLock",
	"Comment": "acquire the lock that provides shared access to the case database. callthis method in a try block with a call to the lock release method in anassociated finally block.",
	"Method": "void acquireSharedLock(){\r\n    rwLock.readLock().lock();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.datasourceprocessors.RawDSProcessor.getPanel",
	"Comment": "gets the panel that allows a user to select a data source and do anyconfiguration required by the data source. the panel is less than 544pixels wide and less than 173 pixels high.",
	"Method": "JPanel getPanel(){\r\n    configPanel.readSettings();\r\n    configPanel.select();\r\n    return configPanel;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.ReportProgressPanel.setProgress",
	"Comment": "sets the current value of the progress bar component of this panel.",
	"Method": "void setProgress(int value){\r\n    EventQueue.invokeLater(() -> {\r\n        if (status != ReportStatus.CANCELED) {\r\n            reportProgressBar.setValue(value);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestManager.handleRemoteCaseDeletedEvent",
	"Comment": "processes a case deletion event from another node by triggering animmediate input directory scan.",
	"Method": "void handleRemoteCaseDeletedEvent(AutoIngestCaseDeletedEvent event){\r\n    sysLogger.log(Level.INFO, \"Received delete case event for case {0} from user {1} on machine {2}\", new Object[] { event.getCaseName(), event.getUserName(), event.getNodeName() });\r\n    String hostName = event.getNodeName();\r\n    hostNamesToLastMsgTime.put(hostName, Instant.now());\r\n    scanInputDirsNow();\r\n    setChanged();\r\n    notifyObservers(Event.CASE_DELETED);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestManager.handleCaseOpened",
	"Comment": "handles a current case opened event by clearing the ingest messages inboxand opening a remote event channel for the current case.note that current case change events are published in a strictlyserialized manner, i.e., one event at a time, synchronously.",
	"Method": "void handleCaseOpened(){\r\n    caseIsOpen = true;\r\n    clearIngestMessageBox();\r\n    try {\r\n        Case openedCase = Case.getCurrentCaseThrows();\r\n        String channelPrefix = openedCase.getName();\r\n        if (Case.CaseType.MULTI_USER_CASE == openedCase.getCaseType()) {\r\n            jobEventPublisher.openRemoteEventChannel(String.format(INGEST_JOB_EVENT_CHANNEL_NAME, channelPrefix));\r\n            moduleEventPublisher.openRemoteEventChannel(String.format(INGEST_MODULE_EVENT_CHANNEL_NAME, channelPrefix));\r\n        }\r\n    } catch (NoCurrentCaseException | AutopsyEventException ex) {\r\n        logger.log(Level.SEVERE, \"Failed to open remote events channel\", ex);\r\n        MessageNotifyUtil.Notify.error(NbBundle.getMessage(IngestManager.class, \"IngestManager.OpenEventChannel.Fail.Title\"), NbBundle.getMessage(IngestManager.class, \"IngestManager.OpenEventChannel.Fail.ErrMsg\"));\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.ArtifactSelectionDialog.populateList",
	"Comment": "populate the list of artifact types with all important artifact types.",
	"Method": "void populateList(){\r\n    try {\r\n        ArrayList<BlackboardArtifact.Type> doNotReport = new ArrayList();\r\n        doNotReport.add(new BlackboardArtifact.Type(BlackboardArtifact.ARTIFACT_TYPE.TSK_GEN_INFO.getTypeID(), BlackboardArtifact.ARTIFACT_TYPE.TSK_GEN_INFO.getLabel(), BlackboardArtifact.ARTIFACT_TYPE.TSK_GEN_INFO.getDisplayName()));\r\n        doNotReport.add(new // output is too unstructured for table review\r\n        BlackboardArtifact.Type(// output is too unstructured for table review\r\n        BlackboardArtifact.ARTIFACT_TYPE.TSK_TOOL_OUTPUT.getTypeID(), BlackboardArtifact.ARTIFACT_TYPE.TSK_TOOL_OUTPUT.getLabel(), BlackboardArtifact.ARTIFACT_TYPE.TSK_TOOL_OUTPUT.getDisplayName()));\r\n        artifactTypes = Case.getCurrentCaseThrows().getSleuthkitCase().getArtifactTypesInUse();\r\n        artifactTypes.removeAll(doNotReport);\r\n        Collections.sort(artifactTypes, new Comparator<BlackboardArtifact.Type>() {\r\n            @Override\r\n            public int compare(BlackboardArtifact.Type o1, BlackboardArtifact.Type o2) {\r\n                return o1.getDisplayName().compareTo(o2.getDisplayName());\r\n            }\r\n        });\r\n        artifactTypeSelections = new HashMap();\r\n        for (BlackboardArtifact.Type type : artifactTypes) {\r\n            artifactTypeSelections.put(type, Boolean.TRUE);\r\n        }\r\n    } catch (TskCoreException ex) {\r\n        Logger.getLogger(ArtifactSelectionDialog.class.getName()).log(Level.SEVERE, \"Error getting list of artifacts in use: {0}\", ex.getLocalizedMessage());\r\n    } catch (NoCurrentCaseException ex) {\r\n        Logger.getLogger(ArtifactSelectionDialog.class.getName()).log(Level.SEVERE, \"Exception while getting open case.\", ex.getLocalizedMessage());\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.ArtifactSelectionDialog.populateList",
	"Comment": "populate the list of artifact types with all important artifact types.",
	"Method": "void populateList(){\r\n    return o1.getDisplayName().compareTo(o2.getDisplayName());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.communications.FiltersPanel.validateFilters",
	"Comment": "validate that filters are in a consistent state and will result in someresults. checks that at least one device and at least one account type isselected. disables the apply and refresh button and shows warnings if thefilters are not valid.",
	"Method": "void validateFilters(){\r\n    boolean someDevice = devicesMap.values().stream().anyMatch(JCheckBox::isSelected);\r\n    boolean someAccountType = accountTypeMap.values().stream().anyMatch(JCheckBox::isSelected);\r\n    deviceRequiredLabel.setVisible(someDevice == false);\r\n    accountTypeRequiredLabel.setVisible(someAccountType == false);\r\n    applyFiltersButton.setEnabled(someDevice && someAccountType);\r\n    refreshButton.setEnabled(someDevice && someAccountType && needsRefresh);\r\n    needsRefreshLabel.setVisible(needsRefresh);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.configuration.AutoIngestUserPreferences.getAutoModeResultsFolder",
	"Comment": "get results folder for automated mode from persistent storage.",
	"Method": "String getAutoModeResultsFolder(){\r\n    return getPreferenceValue(AUTO_MODE_RESULTS_FOLDER);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestTasksScheduler.hasTasksForJob",
	"Comment": "checks whether or not a collection of ingest tasks includes a task for agiven data source ingest job.",
	"Method": "boolean hasTasksForJob(Collection<? extends IngestTask> tasks,long jobId,boolean hasTasksForJob,long jobId){\r\n    for (IngestTask task : tasks) {\r\n        if (task.getIngestJob().getId() == jobId) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.configuration.AutoIngestUserPreferences.setMaxConcurrentIngestNodesForOneCase",
	"Comment": "get maximum number of concurrent ingest nodes allowable for one case at atime.",
	"Method": "void setMaxConcurrentIngestNodesForOneCase(int numberOfNodes){\r\n    ModuleSettings.setConfigSetting(UserPreferences.SETTINGS_PROPERTIES, MAX_CONCURRENT_NODES_FOR_ONE_CASE, Integer.toString(numberOfNodes));\r\n}"
}, {
	"Path": "com.anysoftkeyboard.ime.AnySoftKeyboardKeyboardTagsSearcher.isAlphabet",
	"Comment": "helper to determine if a given character code is alphabetic.",
	"Method": "boolean isAlphabet(int code){\r\n    return isTagsSearchCharacter(code);\r\n}"
}, {
	"Path": "com.aliyun.oss.model.UdfApplicationLog.forcedClose",
	"Comment": "forcefully close the object. the remaining data in server side isignored.",
	"Method": "void forcedClose(){\r\n    this.response.abort();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.ThumbnailViewChildren.getComparator",
	"Comment": "get a comparator for the child nodes loaded from the persisted sortcriteria. the comparator is a composite one that applies all the sortcriteria at once.",
	"Method": "Comparator<Node> getComparator(){\r\n    Comparator<Node> comp = (node1, node2) -> 0;\r\n    if (!(parent instanceof TableFilterNode)) {\r\n        return comp;\r\n    } else {\r\n        List<SortCriterion> sortCriteria = loadSortCriteria((TableFilterNode) parent);\r\n        return // default to unordered if nothing is persisted\r\n        sortCriteria.stream().map(this::getCriterionComparator).collect(Collectors.reducing(Comparator::thenComparing)).orElse(comp);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.AbstractSqlEamDb.clearCaches",
	"Comment": "reset the contents of the caches associated with eamdb results.",
	"Method": "void clearCaches(){\r\n    typeCache.invalidateAll();\r\n    caseCacheByUUID.invalidateAll();\r\n    caseCacheById.invalidateAll();\r\n    dataSourceCacheByDsObjectId.invalidateAll();\r\n    dataSourceCacheById.invalidateAll();\r\n}"
}, {
	"Path": "com.mcxiaoke.next.collection.WeakFastHashMap.hashCode",
	"Comment": "return the hash code value for this map.this implementation usesexactly the code that is used to define the list hash function in thedocumentation for the map.hashcode method.",
	"Method": "int hashCode(int hashCode){\r\n    if (fast) {\r\n        int h = 0;\r\n        for (Entry<K, V> e : map.entrySet()) {\r\n            h += e.hashCode();\r\n        }\r\n        return (h);\r\n    } else {\r\n        synchronized (map) {\r\n            int h = 0;\r\n            for (Entry<K, V> e : map.entrySet()) {\r\n                h += e.hashCode();\r\n            }\r\n            return (h);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.aliyun.oss.internal.ResponseParsers.parseInitiateMultipartUpload",
	"Comment": "unmarshall initiate multipart upload response body to correspondingresult.",
	"Method": "InitiateMultipartUploadResult parseInitiateMultipartUpload(InputStream responseBody){\r\n    try {\r\n        Element root = getXmlRootElement(responseBody);\r\n        InitiateMultipartUploadResult result = new InitiateMultipartUploadResult();\r\n        if (root.getChild(\"Bucket\") != null) {\r\n            result.setBucketName(root.getChildText(\"Bucket\"));\r\n        }\r\n        if (root.getChild(\"Key\") != null) {\r\n            result.setKey(root.getChildText(\"Key\"));\r\n        }\r\n        if (root.getChild(\"UploadId\") != null) {\r\n            result.setUploadId(root.getChildText(\"UploadId\"));\r\n        }\r\n        return result;\r\n    } catch (JDOMParseException e) {\r\n        throw new ResponseParseException(e.getPartialDocument() + \": \" + e.getMessage(), e);\r\n    } catch (Exception e) {\r\n        throw new ResponseParseException(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "model.Complex.tan",
	"Comment": "return a new complex object whose value is the complex tangent of this",
	"Method": "Complex tan(){\r\n    return sin().divides(cos());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.KeywordList.hasSearchTerm",
	"Comment": "indicates whether or not a given search term is included in the list.",
	"Method": "boolean hasSearchTerm(String searchTerm){\r\n    for (Keyword word : keywords) {\r\n        if (word.getSearchTerm().equals(searchTerm)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.automon.utils.Utils.toStringWithLimit",
	"Comment": "turns a single method parameter into a string. to keepthe functionality safe we truncate overly long strings andignore any exceptions.",
	"Method": "String toStringWithLimit(Object parameter){\r\n    if (parameter == null) {\r\n        return NULL_STR;\r\n    }\r\n    String value = parameter.toString();\r\n    try {\r\n        if (value.length() > DEFAULT_ARG_STRING_MAX_LENGTH) {\r\n            value = value.substring(0, DEFAULT_ARG_STRING_MAX_LENGTH) + DEFAULT_MAX_STRING_ENDING;\r\n        }\r\n        return value;\r\n    } catch (Throwable e) {\r\n        return UNKNOWN;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.EamDbUtil.executeValidationQuery",
	"Comment": "use the current settings and the validation query to test the connectionto the database.",
	"Method": "boolean executeValidationQuery(Connection conn,String validationQuery){\r\n    if (null == conn) {\r\n        return false;\r\n    }\r\n    ResultSet resultSet = null;\r\n    try {\r\n        Statement tester = conn.createStatement();\r\n        resultSet = tester.executeQuery(validationQuery);\r\n        if (resultSet.next()) {\r\n            return true;\r\n        }\r\n    } catch (SQLException ex) {\r\n        return false;\r\n    } finally {\r\n        EamDbUtil.closeResultSet(resultSet);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.db.EventsRepository.populateFilterData",
	"Comment": "use the given sleuthkitcase to update the data used to determine theavailable filters.",
	"Method": "void populateFilterData(SleuthkitCase skCase){\r\n    for (Map.Entry<Long, String> hashSet : eventDB.getHashSetNames().entrySet()) {\r\n        hashSetMap.putIfAbsent(hashSet.getKey(), hashSet.getValue());\r\n    }\r\n    for (Long id : eventDB.getDataSourceIDs()) {\r\n        try {\r\n            datasourcesMap.putIfAbsent(id, skCase.getContentById(id).getDataSource().getName());\r\n        } catch (TskCoreException ex) {\r\n            logger.log(Level.SEVERE, \"Failed to get datasource by ID.\", ex);\r\n        }\r\n    }\r\n    try {\r\n        tagNames.setAll(skCase.getTagNamesInUse());\r\n    } catch (TskCoreException ex) {\r\n        logger.log(Level.SEVERE, \"Failed to get tag names in use.\", ex);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.encryptiondetection.EncryptionDetectionIngestJobSettingsPanel.customizeComponents",
	"Comment": "update components with values from the ingest job settings.",
	"Method": "void customizeComponents(EncryptionDetectionIngestJobSettings settings){\r\n    minimumEntropyTextbox.setText(String.valueOf(settings.getMinimumEntropy()));\r\n    minimumFileSizeTextbox.setText(String.valueOf(settings.getMinimumFileSize() / MEGABYTE_SIZE));\r\n    fileSizeMultiplesEnforcedCheckbox.setSelected(settings.isFileSizeMultipleEnforced());\r\n    slackFilesAllowedCheckbox.setSelected(settings.isSlackFilesAllowed());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.datamodel.DrawableDB.getDrawableDB",
	"Comment": "public factory method. creates and opens a connection to a new databaseat the given path. if there is already a db at the path, it is checkedfor compatibility, and deleted if it is incompatible, before a connectionis opened.",
	"Method": "DrawableDB getDrawableDB(ImageGalleryController controller){\r\n    Path dbPath = ImageGalleryModule.getModuleOutputDir(controller.getAutopsyCase()).resolve(\"drawable.db\");\r\n    try {\r\n        deleteDatabaseIfOlderVersion(dbPath);\r\n    } catch (SQLException ex) {\r\n        throw new TskCoreException(\"Failed to check for obsolete drawables database schema\", ex);\r\n    } catch (IOException ex) {\r\n        throw new TskCoreException(\"Failed to delete obsolete drawables database\", ex);\r\n    }\r\n    try {\r\n        return new DrawableDB(dbPath, controller);\r\n    } catch (IOException ex) {\r\n        throw new TskCoreException(\"Failed to create drawables database directory\", ex);\r\n    } catch (SQLException ex) {\r\n        throw new TskCoreException(\"Failed to create/open the drawables database\", ex);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.optionspanel.AddNewOrganizationDialog.checkFields",
	"Comment": "tests whether or not all of the settings components are populated.",
	"Method": "boolean checkFields(){\r\n    boolean result = true;\r\n    boolean isPopulated = requiredFieldsArePopulated();\r\n    if (!isPopulated) {\r\n        result = false;\r\n        lbWarningMsg.setText(Bundle.AddNewOrganizationDialog_validation_incompleteFields());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.configuration.AutoIngestUserPreferences.setSharedConfigMaster",
	"Comment": "save shared config master checkbox state to persistent storage.",
	"Method": "void setSharedConfigMaster(boolean sharedSettingsMaster){\r\n    ModuleSettings.setConfigSetting(UserPreferences.SETTINGS_PROPERTIES, SHARED_CONFIG_MASTER, Boolean.toString(sharedSettingsMaster));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestManager.fireIngestJobCancelled",
	"Comment": "publishes an ingest event signifying an ingest job was canceled.",
	"Method": "void fireIngestJobCancelled(long ingestJobId){\r\n    AutopsyEvent event = new AutopsyEvent(IngestJobEvent.CANCELLED.toString(), ingestJobId, null);\r\n    eventPublishingExecutor.submit(new PublishEventTask(event, jobEventPublisher));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.DropdownToolbar.getDefault",
	"Comment": "gets the singleton panel that provides a toolbar button for the dropdownkeyword list search panel and dropdown single keyword search panel.displayed in the upper right hand corner of the application by default.",
	"Method": "DropdownToolbar getDefault(){\r\n    if (instance == null) {\r\n        instance = new DropdownToolbar();\r\n    }\r\n    return instance;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.CommonAttributePanel.handleFrequencyPercentageState",
	"Comment": "check that the integer value of what is entered in the percentagethreshold text box is a valid percentage and update the errormanager toreflect the validity.",
	"Method": "void handleFrequencyPercentageState(){\r\n    if (this.percentageThresholdValue > 0 && this.percentageThresholdValue <= 100) {\r\n        this.errorManager.setError(UserInputErrorManager.FREQUENCY_PERCENTAGE_OUT_OF_RANGE_KEY, false);\r\n    } else {\r\n        this.errorManager.setError(UserInputErrorManager.FREQUENCY_PERCENTAGE_OUT_OF_RANGE_KEY, true);\r\n    }\r\n    this.updateErrorTextAndSearchButton();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.optionspanel.AddNewOrganizationDialog.setTextBoxListeners",
	"Comment": "register for notifications when the text boxes get updated.",
	"Method": "void setTextBoxListeners(){\r\n    textBoxes.add(tfOrganizationName);\r\n    textBoxes.add(tfPocEmail);\r\n    textBoxes.add(tfPocPhone);\r\n    textBoxes.add(tfPocName);\r\n    addDocumentListeners(textBoxes, textBoxChangedListener);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestJobSettings.getSavedModuleSettingsFolder",
	"Comment": "gets the path to the module settings folder for these ingest jobsettings.",
	"Method": "Path getSavedModuleSettingsFolder(String executionContext,Path getSavedModuleSettingsFolder){\r\n    return Paths.get(IngestJobSettings.MODULE_SETTINGS_FOLDER_PATH, executionContext);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.examples.SampleIngestModuleFactory.getGlobalSettingsPanel",
	"Comment": "gets a user interface panel that allows a user to change settings thatare used by all instances of the family of ingest modules the factorycreates. for example, the autopsy core hash lookup ingest module factoryprovides a global settings panel to import and create hash databases. theimported hash databases are then enabled or disabled per ingest job usingingest an ingest job settings panel. if the module family does not have aglobal settings, the factory may extend ingestmodulefactoryadapter to getan implementation of this method that throws anunsupportedoperationexception.",
	"Method": "IngestModuleGlobalSettingsPanel getGlobalSettingsPanel(){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.DataResultViewerTable.clearComponent",
	"Comment": "frees the resources that have been allocated by this tabular resultsviewer, in preparation for permanently disposing of it.",
	"Method": "void clearComponent(){\r\n    this.outlineView.removeAll();\r\n    this.outlineView = null;\r\n    super.clearComponent();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coordinationservice.CaseNodeData.setErrorsOccurred",
	"Comment": "sets whether or not any errors occurred during the processing of job.",
	"Method": "void setErrorsOccurred(boolean errorsOccurred){\r\n    this.errorsOccurred = errorsOccurred;\r\n}"
}, {
	"Path": "org.wikipedia.gallery.GalleryItemFragment.onUpdatePosition",
	"Comment": "notifies this fragment that the current position of its containing viewpager has changed.",
	"Method": "void onUpdatePosition(int fragmentPosition,int pagerPosition){\r\n    if (fragmentPosition != pagerPosition) {\r\n        if (mediaController != null) {\r\n            if (videoView.isPlaying()) {\r\n                videoView.pause();\r\n            }\r\n            mediaController.hide();\r\n        }\r\n    } else {\r\n        if (mediaController != null) {\r\n            if (!videoView.isPlaying()) {\r\n                videoView.start();\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.db.EventDB.getEventIDsForArtifact",
	"Comment": "get a list of event ids for the events that are derived from the givenartifact.",
	"Method": "List<Long> getEventIDsForArtifact(BlackboardArtifact artifact){\r\n    DBLock.lock();\r\n    String query = \"SELECT event_id FROM events WHERE artifact_id == \" + artifact.getArtifactID();\r\n    ArrayList<Long> results = new ArrayList();\r\n    try (Statement stmt = con.createStatement();\r\n        ResultSet rs = stmt.executeQuery(query)) {\r\n        while (rs.next()) {\r\n            results.add(rs.getLong(\"event_id\"));\r\n        }\r\n    } catch (SQLException ex) {\r\n        LOGGER.log(Level.SEVERE, \"Error executing getEventIDsForArtifact query.\", ex);\r\n    } finally {\r\n        DBLock.unlock();\r\n    }\r\n    return results;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coordinationservice.CaseNodeData.getErrorsOccurred",
	"Comment": "gets whether or not any errors occurred during the processing of the job.",
	"Method": "boolean getErrorsOccurred(){\r\n    return this.errorsOccurred;\r\n}"
}, {
	"Path": "com.anysoftkeyboard.AnySoftKeyboard.isAlphabet",
	"Comment": "helper to determine if a given character code is alphabetic.",
	"Method": "boolean isAlphabet(int code){\r\n    if (super.isAlphabet(code))\r\n        return true;\r\n    if (TextEntryState.isPredicting()) {\r\n        return getCurrentAlphabetKeyboard().isInnerWordLetter((char) code);\r\n    } else {\r\n        return getCurrentAlphabetKeyboard().isStartOfWordLetter((char) code);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.datamodel.DrawableFile.getContentPathSafe",
	"Comment": "get the unique path for this drawablefile, or if that fails, just returnthe name.",
	"Method": "String getContentPathSafe(){\r\n    try {\r\n        return getUniquePath();\r\n    } catch (TskCoreException tskCoreException) {\r\n        String contentName = this.getName();\r\n        LOGGER.log(Level.SEVERE, \"Failed to get unique path for \" + contentName, tskCoreException);\r\n        return contentName;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.KeywordList.hasKeyword",
	"Comment": "indicates whether or not a given keyword is included in the list.",
	"Method": "boolean hasKeyword(Keyword keyword){\r\n    return keywords.contains(keyword);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.ReportProgressPanel.increment",
	"Comment": "increments the current value of the progress bar component of this panelby one unit.",
	"Method": "void increment(){\r\n    EventQueue.invokeLater(() -> {\r\n        if (status != ReportStatus.CANCELED) {\r\n            reportProgressBar.setValue(reportProgressBar.getValue() + 1);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.vmextractor.VMExtractorIngestModule.findVirtualMachineFiles",
	"Comment": "locate all supported virtual machine files, if any, contained in a datasource.",
	"Method": "List<AbstractFile> findVirtualMachineFiles(Content dataSource){\r\n    List<AbstractFile> vmFiles = new ArrayList();\r\n    for (String vmExtension : GeneralFilter.VIRTUAL_MACHINE_EXTS) {\r\n        String searchString = \"%\" + vmExtension;\r\n        vmFiles.addAll(Case.getCurrentCaseThrows().getServices().getFileManager().findFiles(dataSource, searchString));\r\n    }\r\n    return vmFiles;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.events.MessageServiceConnectionInfo.getPort",
	"Comment": "gets the port number to use for a message service connection.",
	"Method": "int getPort(){\r\n    return port;\r\n}"
}, {
	"Path": "org.wikipedia.gallery.GalleryActivity.loadGalleryContent",
	"Comment": "kicks off the activity after the views are initialized in oncreate.",
	"Method": "void loadGalleryContent(){\r\n    updateProgressBar(false, true, 0);\r\n    if (getIntent().hasExtra(EXTRA_FEATURED_IMAGE)) {\r\n        FeaturedImage featuredImage = GsonUnmarshaller.unmarshal(FeaturedImage.class, getIntent().getStringExtra(EXTRA_FEATURED_IMAGE));\r\n        int age = getIntent().getIntExtra(EXTRA_FEATURED_IMAGE_AGE, 0);\r\n        loadGalleryItemFor(featuredImage, age);\r\n    } else {\r\n        fetchGalleryItems();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.VideoUtils.getVideoFileInTempDir",
	"Comment": "gets a file object in the temp directory of the current case for thegiven abstractfile object.",
	"Method": "File getVideoFileInTempDir(AbstractFile file){\r\n    return Paths.get(Case.getCurrentCaseThrows().getTempDirectory(), \"videos\", file.getId() + \".\" + file.getNameExtension()).toFile();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.core.UserPreferences.saveToStorage",
	"Comment": "saves the current preferences to storage. this is only needed if thepreferences files are going to be copied to another location whileautopsy is running.",
	"Method": "void saveToStorage(){\r\n    preferences.flush();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.communications.FiltersPanel.getAccountTypeFilter",
	"Comment": "get an accounttypefilter that matches the state of the ui widgets",
	"Method": "AccountTypeFilter getAccountTypeFilter(){\r\n    AccountTypeFilter accountTypeFilter = new AccountTypeFilter(accountTypeMap.entrySet().stream().filter(entry -> entry.getValue().isSelected()).map(entry -> entry.getKey()).collect(Collectors.toSet()));\r\n    return accountTypeFilter;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestJobSettings.getIngestModuleTemplates",
	"Comment": "gets the enabled ingest module templates for the ingest job.",
	"Method": "List<IngestModuleTemplate> getIngestModuleTemplates(){\r\n    return Collections.unmodifiableList(this.moduleTemplates);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.KeywordSearchOptionsPanelController.applyChanges",
	"Comment": "this method is called when both the ok and apply buttons are pressed. itapplies to any of the panels that have been opened in the process ofusing the options pane.",
	"Method": "void applyChanges(){\r\n    if (changed) {\r\n        getPanel().store();\r\n        changed = false;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.datamodel.KeyValueNode.getActions",
	"Comment": "right click action for the nodes that we want to pass to the directorytable and the output view.",
	"Method": "Action[] getActions(boolean popup){\r\n    List<Action> actionsList = new ArrayList();\r\n    actionsList.addAll(Arrays.asList(super.getActions(popup)));\r\n    AbstractFile file = getLookup().lookup(AbstractFile.class);\r\n    if (null != file) {\r\n        actionsList.add(ViewFileInTimelineAction.createViewSourceFileAction(file));\r\n        actionsList.add(new ViewContextAction(Bundle.KeyValueNode_menuItemText_viewFileInDir(), file));\r\n    }\r\n    actionsList.add(null);\r\n    return actionsList.toArray(new Action[actionsList.size()]);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.QueryResults.getOneHitPerTextSourceObject",
	"Comment": "reduce the hits for a given keyword to one hit per text source object sothat only one hit artifact is generated per text source object, no matterhow many times the keyword was actually found.",
	"Method": "Collection<KeywordHit> getOneHitPerTextSourceObject(Keyword keyword){\r\n    HashMap<Long, KeywordHit> hits = new HashMap();\r\n    getResults(keyword).forEach((hit) -> {\r\n        if (!hits.containsKey(hit.getSolrObjectId())) {\r\n            hits.put(hit.getSolrObjectId(), hit);\r\n        } else if (hit.getChunkId() < hits.get(hit.getSolrObjectId()).getChunkId()) {\r\n            hits.put(hit.getSolrObjectId(), hit);\r\n        }\r\n    });\r\n    return hits.values();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.services.TagNameDefinition.readCurrentTagPropertiesFile",
	"Comment": "read the tags.properties file to get the tagnamedefinitions that arepreserved accross cases.",
	"Method": "Set<TagNameDefinition> readCurrentTagPropertiesFile(List<String> tagProperties,Set<String> standardTagsToBeCreated){\r\n    Set<TagNameDefinition> tagNames = new LinkedHashSet();\r\n    for (String tagNameTuple : tagProperties) {\r\n        String[] tagNameAttributes = tagNameTuple.split(\",\");\r\n        standardTagsToBeCreated.remove(tagNameAttributes[0]);\r\n        tagNames.add(new TagNameDefinition(tagNameAttributes[0], tagNameAttributes[1], TagName.HTML_COLOR.valueOf(tagNameAttributes[2]), TskData.FileKnown.valueOf(tagNameAttributes[3])));\r\n    }\r\n    return tagNames;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.hashdatabase.HashDbIngestModule.updateEnabledHashSets",
	"Comment": "cycle through list of hashsets and return the subset that is enabled.",
	"Method": "void updateEnabledHashSets(List<HashDb> allHashSets,List<HashDb> enabledHashSets){\r\n    enabledHashSets.clear();\r\n    for (HashDb db : allHashSets) {\r\n        if (settings.isHashSetEnabled(db)) {\r\n            try {\r\n                if (db.isValid()) {\r\n                    enabledHashSets.add(db);\r\n                }\r\n            } catch (TskCoreException ex) {\r\n                logger.log(Level.WARNING, \"Error getting index status for \" + db.getDisplayName() + \" hash set\", ex);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.filesearch.DataSourcePanel.getDataSourceArray",
	"Comment": "get datasourcemap with object id and data source display name.",
	"Method": "List<String> getDataSourceArray(){\r\n    List<String> dsList = new ArrayList();\r\n    try {\r\n        Case currentCase = Case.getCurrentCaseThrows();\r\n        SleuthkitCase tskDb = currentCase.getSleuthkitCase();\r\n        List<DataSource> dataSources = tskDb.getDataSources();\r\n        Collections.sort(dataSources, (DataSource ds1, DataSource ds2) -> ds1.getName().compareTo(ds2.getName()));\r\n        for (DataSource ds : dataSources) {\r\n            String dsName = ds.getName();\r\n            File dataSourceFullName = new File(dsName);\r\n            String displayName = dataSourceFullName.getName();\r\n            dataSourceMap.put(ds.getId(), displayName);\r\n            dsList.add(displayName);\r\n        }\r\n    } catch (NoCurrentCaseException ex) {\r\n        logger.log(Level.SEVERE, \"Unable to get current open case.\", ex);\r\n    } catch (TskCoreException ex) {\r\n        logger.log(Level.SEVERE, \"Failed to get data source info from database.\", ex);\r\n    }\r\n    return dsList;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.TimeLineController.selectEventIDs",
	"Comment": "select the given event ids and set their spanning interval as theselected time range.",
	"Method": "void selectEventIDs(Collection<Long> eventIDs){\r\n    selectedTimeRange.set(filteredEvents.getSpanningInterval(eventIDs));\r\n    selectedEventIDs.setAll(eventIDs);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.communications.FiltersPanel.getDateRangeFilter",
	"Comment": "get an daterangefilter that matches the state of the ui widgets",
	"Method": "DateRangeFilter getDateRangeFilter(){\r\n    ZoneId zone = Utils.getUserPreferredZoneId();\r\n    long start = startDatePicker.isEnabled() ? startDatePicker.getDate().atStartOfDay(zone).toEpochSecond() : 0;\r\n    long end = endDatePicker.isEnabled() ? endDatePicker.getDate().atStartOfDay(zone).toEpochSecond() : 0;\r\n    return new DateRangeFilter(start, end);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJob.getProcessingStageDetails",
	"Comment": "gets any available details associated with the current processing stageof the job, e.g., the currently running data source level ingest module,an ingest module in the process of being cancelled, etc. if no additionaldetails are available, the stage details will be the same as theprocessing stage.",
	"Method": "StageDetails getProcessingStageDetails(){\r\n    String description;\r\n    Date startDate;\r\n    if (Stage.CANCELLING != this.stage && null != this.ingestJob) {\r\n        IngestJob.ProgressSnapshot progress = this.ingestJob.getSnapshot();\r\n        IngestJob.DataSourceIngestModuleHandle ingestModuleHandle = progress.runningDataSourceIngestModule();\r\n        if (null != ingestModuleHandle) {\r\n            startDate = ingestModuleHandle.startTime();\r\n            if (!ingestModuleHandle.isCancelled()) {\r\n                description = ingestModuleHandle.displayName();\r\n            } else {\r\n                description = String.format(Stage.CANCELLING_MODULE.getDisplayText(), ingestModuleHandle.displayName());\r\n            }\r\n        } else {\r\n            description = Stage.ANALYZING_FILES.getDisplayText();\r\n            startDate = progress.fileIngestStartTime();\r\n        }\r\n    } else {\r\n        description = this.stage.getDisplayText();\r\n        startDate = this.stageStartDate;\r\n    }\r\n    this.stageDetails = new StageDetails(description, startDate);\r\n    return this.stageDetails;\r\n}"
}, {
	"Path": "com.anysoftkeyboard.dictionaries.Suggest.getSuggestions",
	"Comment": "returns a list of words that match the list of character codes passed in.this list will be overwritten the next time this function is called.",
	"Method": "List<CharSequence> getSuggestions(WordComposer wordComposer,boolean includeTypedWordIfValid){\r\n    if (!mEnabledSuggestions)\r\n        return Collections.emptyList();\r\n    mExplodedAbbreviations.clear();\r\n    mHaveCorrection = false;\r\n    mIsFirstCharCapitalized = wordComposer.isFirstCharCapitalized();\r\n    mIsAllUpperCase = wordComposer.isAllUpperCase();\r\n    collectGarbage();\r\n    Arrays.fill(mPriorities, 0);\r\n    CharSequence mOriginalWord = wordComposer.getTypedWord();\r\n    if (mOriginalWord.length() > 0) {\r\n        mOriginalWord = mOriginalWord.toString();\r\n        mLowerOriginalWord = mOriginalWord.toString().toLowerCase(mLocale);\r\n    } else {\r\n        mLowerOriginalWord = \"\";\r\n    }\r\n    if (wordComposer.isAtTagsSearchState() && mTagsSearcher.isEnabled()) {\r\n        final CharSequence typedTagToSearch = mLowerOriginalWord.substring(1);\r\n        return mTagsSearcher.getOutputForTag(typedTagToSearch, wordComposer);\r\n    }\r\n    if (wordComposer.length() >= mMinimumWordLengthToStartCorrecting) {\r\n        mSuggestionsProvider.getSuggestions(wordComposer, mTypingDictionaryWordCallback);\r\n        mSuggestionsProvider.getAbbreviations(wordComposer, mAbbreviationWordCallback);\r\n        if (mSuggestions.size() > 0) {\r\n            mHaveCorrection = true;\r\n        }\r\n    }\r\n    final int typedWordLength = mLowerOriginalWord.length();\r\n    int nextWordInsertionIndex = 0;\r\n    for (CharSequence nextWordSuggestion : mNextSuggestions) {\r\n        if (nextWordSuggestion.length() >= typedWordLength && nextWordSuggestion.subSequence(0, typedWordLength).equals(mOriginalWord)) {\r\n            mSuggestions.add(nextWordInsertionIndex, nextWordSuggestion);\r\n            nextWordInsertionIndex++;\r\n        }\r\n    }\r\n    if (!TextUtils.isEmpty(mOriginalWord)) {\r\n        mSuggestions.add(0, mOriginalWord.toString());\r\n        if (mExplodedAbbreviations.size() > 0) {\r\n            int explodedWordInsertionIndex = 1;\r\n            for (String explodedWord : mExplodedAbbreviations) {\r\n                mSuggestions.add(explodedWordInsertionIndex, explodedWord);\r\n                explodedWordInsertionIndex++;\r\n            }\r\n            mHaveCorrection = true;\r\n        }\r\n    }\r\n    if (mLowerOriginalWord.length() > 0) {\r\n        CharSequence autoText = mSuggestionsProvider.lookupQuickFix(mLowerOriginalWord);\r\n        boolean canAdd = (!TextUtils.isEmpty(autoText)) && (!TextUtils.equals(autoText, mOriginalWord));\r\n        if (canAdd) {\r\n            mHaveCorrection = true;\r\n            if (mSuggestions.size() == 0) {\r\n                mSuggestions.add(mOriginalWord);\r\n            }\r\n            mSuggestions.add(1, autoText);\r\n        }\r\n    }\r\n    IMEUtil.removeDupes(mSuggestions, mStringPool);\r\n    if (mHaveCorrection && mSuggestions.size() > 1 && mExplodedAbbreviations.size() == 0 && !haveSufficientCommonality(mLowerOriginalWord, mSuggestions.get(1))) {\r\n        mHaveCorrection = false;\r\n    }\r\n    return mSuggestions;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coordinationservice.CaseNodeData.toArray",
	"Comment": "gets the node data as a byte array that can be sent to the coordinationservice.",
	"Method": "byte[] toArray(){\r\n    ByteBuffer buffer = ByteBuffer.allocate(5);\r\n    buffer.putInt(this.version);\r\n    buffer.put((byte) (this.errorsOccurred ? 0x80 : 0));\r\n    byte[] array = new byte[buffer.position()];\r\n    buffer.rewind();\r\n    buffer.get(array, 0, array.length);\r\n    return array;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestControlPanel.bnPrioritizeCaseActionPerformed",
	"Comment": "handle a click on the prioritize case button. requests prioritization ofall of the auto ingest jobs for a case.",
	"Method": "void bnPrioritizeCaseActionPerformed(java.awt.event.ActionEvent evt){\r\n    if (pendingTable.getModel().getRowCount() > 0 && pendingTable.getSelectedRow() >= 0) {\r\n        this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\r\n        String caseName = (pendingTable.getModel().getValueAt(pendingTable.convertRowIndexToModel(pendingTable.getSelectedRow()), JobsTableModelColumns.CASE.ordinal())).toString();\r\n        try {\r\n            manager.prioritizeCase(caseName);\r\n        } catch (AutoIngestManager.AutoIngestManagerException ex) {\r\n            sysLogger.log(Level.SEVERE, \"Error prioritizing a case\", ex);\r\n            MessageNotifyUtil.Message.error(Bundle.AutoIngestControlPanel_errorMessage_casePrioritization());\r\n        }\r\n        refreshTables();\r\n        pendingTable.clearSelection();\r\n        enablePrioritizeButtons(false);\r\n        enableDeprioritizeButtons(false);\r\n        AutoIngestControlPanel.this.setCursor(Cursor.getDefaultCursor());\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.Case.addImage",
	"Comment": "adds an image to the current case after it has been added to the db.sends out event and reopens windows if needed.",
	"Method": "Image addImage(String imgPath,long imgId,String timeZone){\r\n    try {\r\n        Image newDataSource = caseDb.getImageById(imgId);\r\n        notifyDataSourceAdded(newDataSource, UUID.randomUUID());\r\n        return newDataSource;\r\n    } catch (TskCoreException ex) {\r\n        throw new CaseActionException(NbBundle.getMessage(this.getClass(), \"Case.addImg.exception.msg\"), ex);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.dataSourceIntegrity.DataSourceIntegrityIngestSettingsPanel.customizeComponents",
	"Comment": "update components with values from the ingest job settings.",
	"Method": "void customizeComponents(DataSourceIntegrityIngestSettings settings){\r\n    computeHashesCheckbox.setSelected(settings.shouldComputeHashes());\r\n    verifyHashesCheckbox.setSelected(settings.shouldVerifyHashes());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.vmextractor.VMExtractorIngestModule.ingestVirtualMachineImage",
	"Comment": "add a virtual machine file to the case as a data source and analyze itwith the ingest modules.",
	"Method": "void ingestVirtualMachineImage(Path vmFile){\r\n    UUID taskId = UUID.randomUUID();\r\n    Case.getCurrentCaseThrows().notifyAddingDataSource(taskId);\r\n    ImageDSProcessor dataSourceProcessor = new ImageDSProcessor();\r\n    AddDataSourceCallback dspCallback = new AddDataSourceCallback(vmFile);\r\n    synchronized (this) {\r\n        dataSourceProcessor.run(parentDeviceId, vmFile.toString(), parentTimeZone, false, new AddDataSourceProgressMonitor(), dspCallback);\r\n        this.wait();\r\n    }\r\n    if (!dspCallback.vmDataSources.isEmpty()) {\r\n        Case.getCurrentCaseThrows().notifyDataSourceAdded(dspCallback.vmDataSources.get(0), taskId);\r\n        List<Content> dataSourceContent = new ArrayList(dspCallback.vmDataSources);\r\n        IngestJobSettings ingestJobSettings = new IngestJobSettings(context.getExecutionContext());\r\n        for (String warning : ingestJobSettings.getWarnings()) {\r\n            logger.log(Level.WARNING, String.format(\"Ingest job settings warning for virtual machine file %s : %s\", vmFile.toString(), warning));\r\n        }\r\n        IngestServices.getInstance().postMessage(IngestMessage.createMessage(IngestMessage.MessageType.INFO, VMExtractorIngestModuleFactory.getModuleName(), NbBundle.getMessage(this.getClass(), \"VMExtractorIngestModule.addedVirtualMachineImage.message\", vmFile.toString())));\r\n        IngestManager.getInstance().queueIngestJob(dataSourceContent, ingestJobSettings);\r\n    } else {\r\n        Case.getCurrentCaseThrows().notifyFailedAddingDataSource(taskId);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.services.Blackboard.getOrAddArtifactType",
	"Comment": "gets an artifact type, creating it if it does not already exist. use thismethod to define custom artifact types.",
	"Method": "BlackboardArtifact.Type getOrAddArtifactType(String typeName,String displayName){\r\n    if (null == caseDb) {\r\n        throw new BlackboardException(\"Blackboard has been closed\");\r\n    }\r\n    try {\r\n        return caseDb.addBlackboardArtifactType(typeName, displayName);\r\n    } catch (TskDataException typeExistsEx) {\r\n        try {\r\n            return caseDb.getArtifactType(typeName);\r\n        } catch (TskCoreException ex) {\r\n            throw new BlackboardException(\"Failed to get or add artifact type\", ex);\r\n        }\r\n    } catch (TskCoreException ex) {\r\n        throw new BlackboardException(\"Failed to get or add artifact type\", ex);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.Server.coreIndexFolderExists",
	"Comment": "determines whether or not the index files folder for a solr core exists.",
	"Method": "boolean coreIndexFolderExists(String coreName){\r\n    CoreAdminResponse response = CoreAdminRequest.getStatus(coreName, currentSolrServer);\r\n    Object dataDirPath = response.getCoreStatus(coreName).get(\"dataDir\");\r\n    if (null != dataDirPath) {\r\n        File indexDir = Paths.get((String) dataDirPath, \"index\").toFile();\r\n        return indexDir.exists();\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.FileExporter.exportFiles",
	"Comment": "writes each file to be exported to secondary storage and makes entriesfor the file in the master catalog and the catalogs of the export rulesthe file satisfied.",
	"Method": "void exportFiles(Map<Long, List<String>> fileIdsToRuleNames,Supplier<Boolean> cancelCheck){\r\n    for (Map.Entry<Long, List<String>> entry : fileIdsToRuleNames.entrySet()) {\r\n        if (cancelCheck.get()) {\r\n            return;\r\n        }\r\n        exportFile(entry.getKey(), entry.getValue(), cancelCheck);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.configuration.SharedConfiguration.convertLocalDbPathToShared",
	"Comment": "change the database path into a form that can be used to createsubfolders in the shared folder.",
	"Method": "String convertLocalDbPathToShared(String localName){\r\n    String sharedName = localName.replace(\":\", \"__colon__\");\r\n    return sharedName;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.SqliteEamDb.getArtifactInstancesByTypeValue",
	"Comment": "retrieves eamartifact instances from the database that are associatedwith the eamartifacttype and eamartifactvalue of the given eamartifact.",
	"Method": "List<CorrelationAttributeInstance> getArtifactInstancesByTypeValue(CorrelationAttributeInstance.Type aType,String value){\r\n    try {\r\n        acquireSharedLock();\r\n        return super.getArtifactInstancesByTypeValue(aType, value);\r\n    } finally {\r\n        releaseSharedLock();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.services.TagsManager.getTagNamesInUseForUser",
	"Comment": "gets a list of all tag names currently in use in the case database fortagging content or artifacts by the specified user.",
	"Method": "List<TagName> getTagNamesInUseForUser(String userName,List<TagName> getTagNamesInUseForUser,long dsObjId,String userName){\r\n    Set<TagName> tagNameSet = new HashSet();\r\n    List<BlackboardArtifactTag> artifactTags = caseDb.getAllBlackboardArtifactTags();\r\n    for (BlackboardArtifactTag tag : artifactTags) {\r\n        if (tag.getUserName().equals(userName) && tag.getArtifact().getDataSource().getId() == dsObjId) {\r\n            tagNameSet.add(tag.getName());\r\n        }\r\n    }\r\n    List<ContentTag> contentTags = caseDb.getAllContentTags();\r\n    for (ContentTag tag : contentTags) {\r\n        if (tag.getUserName().equals(userName) && tag.getContent().getDataSource().getId() == dsObjId) {\r\n            tagNameSet.add(tag.getName());\r\n        }\r\n    }\r\n    return new ArrayList(tagNameSet);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestOptionsPanelController.getPanel",
	"Comment": "get the ingestoptionspanel which is contained inside this controller.",
	"Method": "IngestOptionsPanel getPanel(){\r\n    if (panel == null) {\r\n        panel = new IngestOptionsPanel();\r\n        panel.addPropertyChangeListener(new PropertyChangeListener() {\r\n            @Override\r\n            public void propertyChange(PropertyChangeEvent evt) {\r\n                if (evt.getPropertyName().equals(OptionsPanelController.PROP_CHANGED)) {\r\n                    changed();\r\n                }\r\n            }\r\n        });\r\n    }\r\n    return panel;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestOptionsPanelController.getPanel",
	"Comment": "get the ingestoptionspanel which is contained inside this controller.",
	"Method": "IngestOptionsPanel getPanel(){\r\n    if (evt.getPropertyName().equals(OptionsPanelController.PROP_CHANGED)) {\r\n        changed();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.InterCasePanel.addObserver",
	"Comment": "add an observer to the observable portion of this panel so that it can benotified of changes to this panel.",
	"Method": "void addObserver(Observer observer){\r\n    fileTypeFilterObservable.addObserver(observer);\r\n}"
}, {
	"Path": "org.wikipedia.views.AppTextViewWithImages.makeImageSpan",
	"Comment": "create an imagespan containing a drawable to be inserted in a textview. this also sets theimage size and color.",
	"Method": "Spannable makeImageSpan(int drawableId,float size,int color){\r\n    Spannable result = Spannable.Factory.getInstance().newSpannable(\" \");\r\n    Drawable drawable = getFormattedDrawable(drawableId, size, color);\r\n    result.setSpan(new BaselineAlignedYTranslationImageSpan(drawable, getLineSpacingMultiplier()), 0, 1, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);\r\n    return result;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.IntraCasePanel.addObserver",
	"Comment": "add an observer to the observable portion of this panel so that it can benotified of changes to this panel.",
	"Method": "void addObserver(Observer observer){\r\n    fileTypeFilterObservable.addObserver(observer);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestPipelinesConfiguration.getFileIngestPipelineConfig",
	"Comment": "gets the ordered list of ingest module factory class names for the firststage data source ingest pipeline.",
	"Method": "List<String> getFileIngestPipelineConfig(){\r\n    return new ArrayList(fileIngestPipelineConfig);\r\n}"
}, {
	"Path": "com.aliyun.oss.internal.ResponseParsers.parseGetBucketReplication",
	"Comment": "unmarshall get bucket replication response body to replication result.",
	"Method": "List<ReplicationRule> parseGetBucketReplication(InputStream responseBody){\r\n    try {\r\n        List<ReplicationRule> repRules = new ArrayList<ReplicationRule>();\r\n        Element root = getXmlRootElement(responseBody);\r\n        List<Element> ruleElems = root.getChildren(\"Rule\");\r\n        for (Element ruleElem : ruleElems) {\r\n            ReplicationRule repRule = new ReplicationRule();\r\n            repRule.setReplicationRuleID(ruleElem.getChildText(\"ID\"));\r\n            Element destination = ruleElem.getChild(\"Destination\");\r\n            repRule.setTargetBucketName(destination.getChildText(\"Bucket\"));\r\n            repRule.setTargetBucketLocation(destination.getChildText(\"Location\"));\r\n            repRule.setTargetCloud(destination.getChildText(\"Cloud\"));\r\n            repRule.setTargetCloudLocation(destination.getChildText(\"CloudLocation\"));\r\n            repRule.setReplicationStatus(ReplicationStatus.parse(ruleElem.getChildText(\"Status\")));\r\n            if (ruleElem.getChildText(\"HistoricalObjectReplication\").equals(\"enabled\")) {\r\n                repRule.setEnableHistoricalObjectReplication(true);\r\n            } else {\r\n                repRule.setEnableHistoricalObjectReplication(false);\r\n            }\r\n            if (ruleElem.getChild(\"PrefixSet\") != null) {\r\n                List<String> objectPrefixes = new ArrayList<String>();\r\n                List<Element> prefixElems = ruleElem.getChild(\"PrefixSet\").getChildren(\"Prefix\");\r\n                for (Element prefixElem : prefixElems) {\r\n                    objectPrefixes.add(prefixElem.getText());\r\n                }\r\n                repRule.setObjectPrefixList(objectPrefixes);\r\n            }\r\n            if (ruleElem.getChild(\"Action\") != null) {\r\n                String[] actionStrs = ruleElem.getChildText(\"Action\").split(\",\");\r\n                List<ReplicationAction> repActions = new ArrayList<ReplicationAction>();\r\n                for (String actionStr : actionStrs) {\r\n                    repActions.add(ReplicationAction.parse(actionStr));\r\n                }\r\n                repRule.setReplicationActionList(repActions);\r\n            }\r\n            repRules.add(repRule);\r\n        }\r\n        return repRules;\r\n    } catch (JDOMParseException e) {\r\n        throw new ResponseParseException(e.getPartialDocument() + \": \" + e.getMessage(), e);\r\n    } catch (Exception e) {\r\n        throw new ResponseParseException(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "burrows.apps.example.template.adapter.BaseAdapter.remove",
	"Comment": "removes the first occurrence of the specified object from the data.",
	"Method": "boolean remove(int location,T object,boolean remove,T object,T remove,int location){\r\n    final T removedObject = data.remove(location);\r\n    notifyItemRemoved(location);\r\n    notifyItemRangeChanged(location, data.size());\r\n    return removedObject;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.AbstractCommonAttributeSearcher.getPercentThresholdString",
	"Comment": "get the portion of the title that will display the frequency percentagethreshold. items that existed in over this percent of data sources wereommited from the results.",
	"Method": "String getPercentThresholdString(){\r\n    if (frequencyPercentageThreshold == 0) {\r\n        return \"\";\r\n    } else {\r\n        return Bundle.AbstractCommonFilesMetadataBuilder_getPercentFilter_thresholdPercent(frequencyPercentageThreshold);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.snapshot.SnapShotReportWriter.writeIndexHTML",
	"Comment": "generate and write the main html page with frames for navigation on theleft and content on the right.",
	"Method": "Path writeIndexHTML(){\r\n    HashMap<String, Object> indexContext = new HashMap();\r\n    indexContext.put(\"reportBranding\", reportBranding);\r\n    indexContext.put(\"reportName\", reportName);\r\n    Path reportIndexFile = reportFolderPath.resolve(\"index.html\");\r\n    fillTemplateAndWrite(\"/org/sleuthkit/autopsy/timeline/snapshot/index_template.html\", \"Index\", indexContext, reportIndexFile);\r\n    return reportIndexFile;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.datamodel.CategoryManager.decrementCategoryCount",
	"Comment": "decrement the cached value for the number of files with the givendhsimagecategory",
	"Method": "void decrementCategoryCount(DhsImageCategory cat){\r\n    if (cat != DhsImageCategory.ZERO) {\r\n        categoryCounts.getUnchecked(cat).decrement();\r\n    }\r\n}"
}, {
	"Path": "com.aliyun.oss.common.utils.IniEditor.optionNames",
	"Comment": "returns all option names of a section, not including options from thecommon section.",
	"Method": "List<String> optionNames(String section,List<String> optionNames){\r\n    if (hasSection(section)) {\r\n        return getSection(section).optionNames();\r\n    } else {\r\n        throw new NoSuchSectionException(section);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.filetypeid.FileTypeIdOptionsPanelController.applyChanges",
	"Comment": "this method is called when both the ok and apply buttons are pressed. itapplies to any of the panels that have been opened in the process ofusing the options pane.",
	"Method": "void applyChanges(){\r\n    if (changed) {\r\n        getPanel().store();\r\n        changed = false;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.ReportKML.getInteger",
	"Comment": "get an integer from an artifact if it exists, return null otherwise.",
	"Method": "Integer getInteger(BlackboardArtifact artifact,BlackboardAttribute.ATTRIBUTE_TYPE type){\r\n    Integer returnValue = null;\r\n    try {\r\n        BlackboardAttribute bba = artifact.getAttribute(new BlackboardAttribute.Type(type));\r\n        if (bba != null) {\r\n            Integer value = bba.getValueInt();\r\n            returnValue = value;\r\n        }\r\n    } catch (TskCoreException ex) {\r\n        logger.log(Level.SEVERE, \"Error getting Integer value: \" + type.toString(), ex);\r\n    }\r\n    return returnValue;\r\n}"
}, {
	"Path": "com.stealthcopter.networktools.WakeOnLan.setNoPackets",
	"Comment": "sets the number of packets to send, this is to overcome the flakiness of networks",
	"Method": "WakeOnLan setNoPackets(int noPackets){\r\n    if (noPackets <= 0)\r\n        throw new IllegalArgumentException(\"Invalid number of packets to send \" + noPackets);\r\n    this.noPackets = noPackets;\r\n    return this;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.NoIngestModuleIngestJobSettings.getSetting",
	"Comment": "gets the string used as an ingest options placeholder for serializationpurposes.",
	"Method": "String getSetting(){\r\n    return setting;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.healthmonitor.HealthMonitor.getSharedDbLock",
	"Comment": "get an shared lock for the health monitor database. acquire this beforedatabase reads or writes.",
	"Method": "CoordinationService.Lock getSharedDbLock(){\r\n    try {\r\n        String databaseNodeName = DATABASE_NAME;\r\n        CoordinationService.Lock lock = CoordinationService.getInstance().tryGetSharedLock(CoordinationService.CategoryNode.HEALTH_MONITOR, databaseNodeName, 5, TimeUnit.MINUTES);\r\n        if (lock != null) {\r\n            return lock;\r\n        }\r\n        throw new HealthMonitorException(\"Error acquiring database lock\");\r\n    } catch (InterruptedException | CoordinationService.CoordinationServiceException ex) {\r\n        throw new HealthMonitorException(\"Error acquiring database lock\");\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.SqliteEamDb.getCountArtifactInstancesByCaseDataSource",
	"Comment": "retrieves number of eamartifact instances in the database that areassociated with the casedisplayname and datasource of the giveneamartifact instance.",
	"Method": "Long getCountArtifactInstancesByCaseDataSource(CorrelationDataSource correlationDataSource){\r\n    try {\r\n        acquireSharedLock();\r\n        return super.getCountArtifactInstancesByCaseDataSource(correlationDataSource);\r\n    } finally {\r\n        releaseSharedLock();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.db.EventDB.deleteTag",
	"Comment": "mark any events with the given object and artifact ids as tagged, andrecord the tag it self.",
	"Method": "Set<Long> deleteTag(long objectID,Long artifactID,long tagID,boolean stillTagged){\r\n    DBLock.lock();\r\n    try {\r\n        deleteTagStmt.clearParameters();\r\n        deleteTagStmt.setLong(1, tagID);\r\n        deleteTagStmt.executeUpdate();\r\n        return markEventsTagged(objectID, artifactID, stillTagged);\r\n    } catch (SQLException ex) {\r\n        LOGGER.log(Level.SEVERE, \"failed to add tag to event\", ex);\r\n    } finally {\r\n        DBLock.unlock();\r\n    }\r\n    return Collections.emptySet();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.FileUtil.copyFile",
	"Comment": "copy a file to a new directory, potentially new file name, and overwriteold one if requested",
	"Method": "String copyFile(String source,String destFolder,String newName,String ext,boolean overwrite){\r\n    final String destFileName = destFolder + File.separator + newName + ext;\r\n    final File destFile = new File(destFileName);\r\n    if (destFile.exists()) {\r\n        if (overwrite) {\r\n            destFile.delete();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n    final FileObject sourceFileObj = org.openide.filesystems.FileUtil.createData(new File(source));\r\n    final FileObject destFolderObj = org.openide.filesystems.FileUtil.createData(new File(destFolder));\r\n    FileObject created = org.openide.filesystems.FileUtil.copyFile(sourceFileObj, destFolderObj, newName, ext.substring(1));\r\n    return created.getPath();\r\n}"
}, {
	"Path": "org.automon.utils.Utils.createFirst",
	"Comment": "take a variable list of fully qualified class names and return the first one.",
	"Method": "T createFirst(String classNames){\r\n    for (String className : classNames) {\r\n        try {\r\n            return (T) Class.forName(className).newInstance();\r\n        } catch (Throwable t) {\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.events.AutopsyEventPublisher.openRemoteEventChannel",
	"Comment": "opens an event channel used for publishing events to, and receivingevents from, other autopsy nodes. only one channel may be open at a time.",
	"Method": "void openRemoteEventChannel(String channelName){\r\n    currentChannelName = channelName;\r\n    if (null != remotePublisher) {\r\n        closeRemoteEventChannel();\r\n    }\r\n    try {\r\n        remotePublisher = new RemoteEventPublisher(channelName, localPublisher, UserPreferences.getMessageServiceConnectionInfo());\r\n    } catch (URISyntaxException | JMSException ex) {\r\n        String message = \"Failed to open remote event channel\";\r\n        logger.log(Level.SEVERE, message, ex);\r\n        throw new AutopsyEventException(message, ex);\r\n    } catch (UserPreferencesException ex) {\r\n        String message = \"Error accessing messaging service connection info\";\r\n        logger.log(Level.SEVERE, message, ex);\r\n        throw new AutopsyEventException(message, ex);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.interestingitems.InterestingItemDefsOptionsPanelController.applyChanges",
	"Comment": "this method is called when both the ok and apply buttons are pressed. itapplies to any of the panels that have been opened in the process ofusing the options pane.",
	"Method": "void applyChanges(){\r\n    if (changed) {\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                getPanel().store();\r\n                changed = false;\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.interestingitems.InterestingItemDefsOptionsPanelController.applyChanges",
	"Comment": "this method is called when both the ok and apply buttons are pressed. itapplies to any of the panels that have been opened in the process ofusing the options pane.",
	"Method": "void applyChanges(){\r\n    getPanel().store();\r\n    changed = false;\r\n}"
}, {
	"Path": "com.facebook.samples.gestures.MultiPointerGestureDetector.getStartX",
	"Comment": "gets the start x coordinates for the all pointersmutable array is exposed for performance reasons and is not to be modified by the callers.",
	"Method": "float[] getStartX(){\r\n    return mStartX;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.examples.SampleIngestModuleFactory.hasGlobalSettingsPanel",
	"Comment": "queries the factory to determine if it provides a user interface panel toallow a user to change settings that are used by all instances of thefamily of ingest modules the factory creates. for example, the autopsycore hash lookup ingest module factory provides a global settings panelto import and create hash databases. the hash databases are then enabledor disabled per ingest job using an ingest job settings panel. if themodule family does not have global settings, the factory may extendingestmodulefactoryadapter to get an implementation of this method thatreturns false.",
	"Method": "boolean hasGlobalSettingsPanel(){\r\n    return false;\r\n}"
}, {
	"Path": "com.facebook.samples.gestures.MultiPointerGestureDetector.getStartY",
	"Comment": "gets the start y coordinates for the all pointersmutable array is exposed for performance reasons and is not to be modified by the callers.",
	"Method": "float[] getStartY(){\r\n    return mStartY;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJobNodeData.getDataSourceFileName",
	"Comment": "get the file name portion of the path of the data source for the job.",
	"Method": "String getDataSourceFileName(){\r\n    return Paths.get(dataSourcePath).getFileName().toString();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.GlobalListsManagementPanel.setButtonStates",
	"Comment": "enables and disables buttons on this panel based on the current state.",
	"Method": "void setButtonStates(){\r\n    boolean isIngestRunning = IngestManager.getInstance().isIngestRunning();\r\n    boolean isListSelected = !listsTable.getSelectionModel().isSelectionEmpty();\r\n    boolean canEditList = isListSelected && !isIngestRunning;\r\n    boolean multiSelection = false;\r\n    if (isListSelected) {\r\n        multiSelection = (listsTable.getSelectionModel().getMaxSelectionIndex() != listsTable.getSelectionModel().getMinSelectionIndex());\r\n    }\r\n    importButton.setEnabled(!isIngestRunning);\r\n    deleteListButton.setEnabled(canEditList);\r\n    renameListButton.setEnabled(canEditList);\r\n    renameListButton.setEnabled(canEditList && !multiSelection);\r\n    copyListButton.setEnabled(isListSelected);\r\n    copyListButton.setEnabled(isListSelected && !multiSelection);\r\n    exportButton.setEnabled(isListSelected);\r\n}"
}, {
	"Path": "org.codechimp.apprater.AppRater.showRateAlertDialog",
	"Comment": "the meat of the library, actually shows the rate prompt dialog",
	"Method": "void showRateAlertDialog(Context context,SharedPreferences.Editor editor){\r\n    Builder builder;\r\n    if (Build.VERSION.SDK_INT >= 11 && themeSet) {\r\n        builder = new AlertDialog.Builder(context, (isDark ? AlertDialog.THEME_HOLO_DARK : AlertDialog.THEME_HOLO_LIGHT));\r\n    } else {\r\n        builder = new AlertDialog.Builder(context);\r\n    }\r\n    ApplicationRatingInfo ratingInfo = ApplicationRatingInfo.createApplicationInfo(context);\r\n    builder.setTitle(String.format(context.getString(R.string.apprater_dialog_title), ratingInfo.getApplicationName()));\r\n    builder.setMessage(context.getString(R.string.apprater_rate_message));\r\n    builder.setCancelable(isCancelable);\r\n    builder.setPositiveButton(context.getString(R.string.apprater_rate), new DialogInterface.OnClickListener() {\r\n        public void onClick(DialogInterface dialog, int id) {\r\n            rateNow(context);\r\n            if (editor != null) {\r\n                editor.putBoolean(PREF_DONT_SHOW_AGAIN, true);\r\n                commitOrApply(editor);\r\n            }\r\n            dialog.dismiss();\r\n        }\r\n    });\r\n    builder.setNeutralButton(context.getString(R.string.apprater_later), new DialogInterface.OnClickListener() {\r\n        public void onClick(DialogInterface dialog, int id) {\r\n            if (editor != null) {\r\n                Long date_firstLaunch = System.currentTimeMillis();\r\n                editor.putLong(PREF_FIRST_LAUNCHED, date_firstLaunch);\r\n                editor.putLong(PREF_LAUNCH_COUNT, 0);\r\n                editor.putBoolean(PREF_REMIND_LATER, true);\r\n                editor.putBoolean(PREF_DONT_SHOW_AGAIN, false);\r\n                commitOrApply(editor);\r\n            }\r\n            dialog.dismiss();\r\n        }\r\n    });\r\n    if (!hideNoButton) {\r\n        builder.setNegativeButton(context.getString(R.string.apprater_no_thanks), new DialogInterface.OnClickListener() {\r\n            public void onClick(DialogInterface dialog, int id) {\r\n                if (editor != null) {\r\n                    editor.putBoolean(PREF_DONT_SHOW_AGAIN, true);\r\n                    editor.putBoolean(PREF_REMIND_LATER, false);\r\n                    long date_firstLaunch = System.currentTimeMillis();\r\n                    editor.putLong(PREF_FIRST_LAUNCHED, date_firstLaunch);\r\n                    editor.putLong(PREF_LAUNCH_COUNT, 0);\r\n                    commitOrApply(editor);\r\n                }\r\n                dialog.dismiss();\r\n            }\r\n        });\r\n    }\r\n    final AlertDialog alertDialog = builder.create();\r\n    alertDialog.setOnShowListener(new DialogInterface.OnShowListener() {\r\n        @Override\r\n        public void onShow(DialogInterface dialog) {\r\n            try {\r\n                final Button buttonPositive = alertDialog.getButton(AlertDialog.BUTTON_POSITIVE);\r\n                if (buttonPositive == null) {\r\n                    return;\r\n                }\r\n                LinearLayout linearLayout = (LinearLayout) buttonPositive.getParent();\r\n                if (linearLayout == null) {\r\n                    return;\r\n                }\r\n                boolean shouldUseVerticalLayout = false;\r\n                if (buttonPositive.getLeft() + buttonPositive.getWidth() > linearLayout.getWidth()) {\r\n                    shouldUseVerticalLayout = true;\r\n                }\r\n                if (shouldUseVerticalLayout) {\r\n                    linearLayout.setOrientation(LinearLayout.VERTICAL);\r\n                    linearLayout.setGravity(Gravity.END);\r\n                }\r\n            } catch (Exception ignored) {\r\n            }\r\n        }\r\n    });\r\n    alertDialog.show();\r\n}"
}, {
	"Path": "org.codechimp.apprater.AppRater.showRateAlertDialog",
	"Comment": "the meat of the library, actually shows the rate prompt dialog",
	"Method": "void showRateAlertDialog(Context context,SharedPreferences.Editor editor){\r\n    rateNow(context);\r\n    if (editor != null) {\r\n        editor.putBoolean(PREF_DONT_SHOW_AGAIN, true);\r\n        commitOrApply(editor);\r\n    }\r\n    dialog.dismiss();\r\n}"
}, {
	"Path": "org.codechimp.apprater.AppRater.showRateAlertDialog",
	"Comment": "the meat of the library, actually shows the rate prompt dialog",
	"Method": "void showRateAlertDialog(Context context,SharedPreferences.Editor editor){\r\n    if (editor != null) {\r\n        Long date_firstLaunch = System.currentTimeMillis();\r\n        editor.putLong(PREF_FIRST_LAUNCHED, date_firstLaunch);\r\n        editor.putLong(PREF_LAUNCH_COUNT, 0);\r\n        editor.putBoolean(PREF_REMIND_LATER, true);\r\n        editor.putBoolean(PREF_DONT_SHOW_AGAIN, false);\r\n        commitOrApply(editor);\r\n    }\r\n    dialog.dismiss();\r\n}"
}, {
	"Path": "org.codechimp.apprater.AppRater.showRateAlertDialog",
	"Comment": "the meat of the library, actually shows the rate prompt dialog",
	"Method": "void showRateAlertDialog(Context context,SharedPreferences.Editor editor){\r\n    if (editor != null) {\r\n        editor.putBoolean(PREF_DONT_SHOW_AGAIN, true);\r\n        editor.putBoolean(PREF_REMIND_LATER, false);\r\n        long date_firstLaunch = System.currentTimeMillis();\r\n        editor.putLong(PREF_FIRST_LAUNCHED, date_firstLaunch);\r\n        editor.putLong(PREF_LAUNCH_COUNT, 0);\r\n        commitOrApply(editor);\r\n    }\r\n    dialog.dismiss();\r\n}"
}, {
	"Path": "org.codechimp.apprater.AppRater.showRateAlertDialog",
	"Comment": "the meat of the library, actually shows the rate prompt dialog",
	"Method": "void showRateAlertDialog(Context context,SharedPreferences.Editor editor){\r\n    try {\r\n        final Button buttonPositive = alertDialog.getButton(AlertDialog.BUTTON_POSITIVE);\r\n        if (buttonPositive == null) {\r\n            return;\r\n        }\r\n        LinearLayout linearLayout = (LinearLayout) buttonPositive.getParent();\r\n        if (linearLayout == null) {\r\n            return;\r\n        }\r\n        boolean shouldUseVerticalLayout = false;\r\n        if (buttonPositive.getLeft() + buttonPositive.getWidth() > linearLayout.getWidth()) {\r\n            shouldUseVerticalLayout = true;\r\n        }\r\n        if (shouldUseVerticalLayout) {\r\n            linearLayout.setOrientation(LinearLayout.VERTICAL);\r\n            linearLayout.setGravity(Gravity.END);\r\n        }\r\n    } catch (Exception ignored) {\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.TimeLineController.promptForRebuild",
	"Comment": "prompt the user to confirm rebuilding the db. checks if a databaserebuild is necessary and includes the reasons in the prompt. if the userconfirms, rebuilds the database. shows the timeline window when therebuild is done, or immediately if the rebuild is not confirmed.",
	"Method": "void promptForRebuild(AbstractFile file,BlackboardArtifact artifact){\r\n    if (promptDialogManager.bringCurrentDialogToFront()) {\r\n        return;\r\n    }\r\n    if (eventsRepository.countAllEvents() == 0) {\r\n        rebuildRepo(file, artifact);\r\n        return;\r\n    }\r\n    List<String> rebuildReasons = getRebuildReasons();\r\n    if (false == rebuildReasons.isEmpty()) {\r\n        if (promptDialogManager.confirmRebuild(rebuildReasons)) {\r\n            rebuildRepo(file, artifact);\r\n            return;\r\n        }\r\n    }\r\n    rebuildTagsTable(file, artifact);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.KeywordList.getUseForIngest",
	"Comment": "gets whether or not the list should be used when ingesting a data source.",
	"Method": "Boolean getUseForIngest(){\r\n    return useForIngest;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.RegexQuery.makeSnippet",
	"Comment": "make a snippet from the given content that has the given hit plus somesurrounding context.",
	"Method": "String makeSnippet(String content,Matcher hitMatcher,String hit){\r\n    int maxIndex = content.length() - 1;\r\n    final int end = hitMatcher.end();\r\n    final int start = hitMatcher.start();\r\n    return content.substring(Integer.max(0, start - 20), Integer.max(0, start)) + SNIPPET_DELIMITER + hit + SNIPPET_DELIMITER + content.substring(Integer.min(maxIndex, end), Integer.min(maxIndex, end + 20));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.db.EventDB.countEventsByType",
	"Comment": "get the count of all events that fit the given zoom params organized bythe eventype of the level spcified in the zoomparams",
	"Method": "Map<EventType, Long> countEventsByType(ZoomParams params,Map<EventType, Long> countEventsByType,Long startTime,Long endTime,RootFilter filter,EventTypeZoomLevel zoomLevel){\r\n    if (Objects.equals(startTime, endTime)) {\r\n        endTime++;\r\n    }\r\n    Map<EventType, Long> typeMap = new HashMap();\r\n    final boolean useSubTypes = (zoomLevel == EventTypeZoomLevel.SUB_TYPE);\r\n    final // NON-NLS\r\n    String queryString = \"SELECT count(DISTINCT events.event_id) AS count, \" + typeColumnHelper(useSubTypes) + \" FROM events\" + useHashHitTablesHelper(filter) + useTagTablesHelper(filter) + \" WHERE time >= \" + startTime + \" AND time < \" + endTime + \" AND \" + SQLHelper.getSQLWhere(filter) + \" GROUP BY \" + typeColumnHelper(useSubTypes);\r\n    DBLock.lock();\r\n    try (Statement stmt = con.createStatement();\r\n        ResultSet rs = stmt.executeQuery(queryString)) {\r\n        while (rs.next()) {\r\n            EventType type = useSubTypes ? RootEventType.allTypes.get(rs.getInt(\"sub_type\")) : BaseTypes.values()[rs.getInt(\"base_type\")];\r\n            typeMap.put(type, rs.getLong(\"count\"));\r\n        }\r\n    } catch (Exception ex) {\r\n        LOGGER.log(Level.SEVERE, \"Error getting count of events from db.\", ex);\r\n    } finally {\r\n        DBLock.unlock();\r\n    }\r\n    return typeMap;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.Case.getOrCreateSubdirectory",
	"Comment": "gets the path to the specified subdirectory of the case directory,creating it if it does not already exist.",
	"Method": "String getOrCreateSubdirectory(String subDirectoryName){\r\n    File subDirectory = Paths.get(getOutputDirectory(), subDirectoryName).toFile();\r\n    if (!subDirectory.exists()) {\r\n        subDirectory.mkdirs();\r\n    }\r\n    return subDirectory.toString();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.fileextmismatch.FileExtMismatchDetectorModuleSettings.setSkipKnownFiles",
	"Comment": "sets the flag indicating whether or not known files should be skippedduring file extension mismatch checking.",
	"Method": "void setSkipKnownFiles(boolean skipKnownFiles){\r\n    this.skipKnownFiles = skipKnownFiles;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestControlPanel.bnCancelModuleActionPerformed",
	"Comment": "handles a click on the cancel ingest module button. cancels the currentlyrunning data source level ingest module for the selected job.",
	"Method": "void bnCancelModuleActionPerformed(java.awt.event.ActionEvent evt){\r\n    Object[] options = { org.openide.util.NbBundle.getMessage(AutoIngestControlPanel.class, \"ConfirmationDialog.CancelModule\"), org.openide.util.NbBundle.getMessage(AutoIngestControlPanel.class, \"ConfirmationDialog.DoNotCancelModule\") };\r\n    int reply = JOptionPane.showOptionDialog(this, NbBundle.getMessage(AutoIngestControlPanel.class, \"ConfirmationDialog.CancelModuleAreYouSure\"), NbBundle.getMessage(AutoIngestControlPanel.class, \"ConfirmationDialog.ConfirmCancellationHeader\"), JOptionPane.DEFAULT_OPTION, JOptionPane.WARNING_MESSAGE, null, options, options[1]);\r\n    if (reply == 0) {\r\n        this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\r\n        manager.cancelCurrentDataSourceLevelIngestModule();\r\n        refreshTables();\r\n        this.setCursor(Cursor.getDefaultCursor());\r\n    }\r\n}"
}, {
	"Path": "org.wikipedia.analytics.EventLoggingService.log",
	"Comment": "log the current event.returns immediately after queueing the network request in the background.",
	"Method": "void log(JSONObject event){\r\n    if (!isEventLoggingEnabled()) {\r\n        return;\r\n    }\r\n    Completable.fromAction(() -> {\r\n        String eventStr = event.toString();\r\n        String dataURL = Uri.parse(EVENTLOG_URL).buildUpon().query(eventStr).build().toString();\r\n        if (ReleaseUtil.isDevRelease()) {\r\n            L.d(eventStr);\r\n        }\r\n        if (dataURL.length() > MAX_URL_LEN) {\r\n            L.logRemoteErrorIfProd(new RemoteLogException(\"EventLogging max length exceeded\").put(\"length\", String.valueOf(dataURL.length())));\r\n        }\r\n        Request request = new Request.Builder().url(dataURL).post(EMPTY_REQ).build();\r\n        OkHttpConnectionFactory.getClient().newCall(request).execute().close();\r\n    }).subscribeOn(Schedulers.io()).subscribe(() -> {\r\n    }, throwable -> L.d(\"Lost EL data: \" + event.toString()));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.MultiUserCasesDialog.setVisible",
	"Comment": "set the dialog visibility. when setting it to visible, the contents willrefresh.",
	"Method": "void setVisible(boolean value){\r\n    if (value) {\r\n        multiUserCasesPanel.refresh();\r\n    }\r\n    super.setVisible(value);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.recentactivity.RecentDocumentsByLnk.getRecentDocuments",
	"Comment": "find the documents that windows stores about recent documents and makeartifacts.",
	"Method": "void getRecentDocuments(){\r\n    org.sleuthkit.autopsy.casemodule.services.FileManager fileManager = currentCase.getServices().getFileManager();\r\n    List<AbstractFile> recentFiles;\r\n    try {\r\n        recentFiles = fileManager.findFiles(dataSource, \"%.lnk\", \"Recent\");\r\n    } catch (TskCoreException ex) {\r\n        logger.log(Level.WARNING, \"Error searching for .lnk files.\");\r\n        this.addErrorMessage(NbBundle.getMessage(this.getClass(), \"RecentDocumentsByLnk.getRecDoc.errMsg.errGetLnkFiles\", this.getName()));\r\n        return;\r\n    }\r\n    if (recentFiles.isEmpty()) {\r\n        logger.log(Level.INFO, \"Didn't find any recent files.\");\r\n        return;\r\n    }\r\n    dataFound = true;\r\n    for (AbstractFile recentFile : recentFiles) {\r\n        if (context.dataSourceIngestIsCancelled()) {\r\n            break;\r\n        }\r\n        if (recentFile.getSize() == 0) {\r\n            continue;\r\n        }\r\n        JLNK lnk;\r\n        JLnkParser lnkParser = new JLnkParser(new ReadContentInputStream(recentFile), (int) recentFile.getSize());\r\n        try {\r\n            lnk = lnkParser.parse();\r\n        } catch (JLnkParserException e) {\r\n            boolean unalloc = recentFile.isMetaFlagSet(TskData.TSK_FS_META_FLAG_ENUM.UNALLOC) || recentFile.isDirNameFlagSet(TskData.TSK_FS_NAME_FLAG_ENUM.UNALLOC);\r\n            if (unalloc == false) {\r\n                logger.log(Level.WARNING, \"Error lnk parsing the file to get recent files {0}\", recentFile);\r\n            }\r\n            continue;\r\n        }\r\n        Collection<BlackboardAttribute> bbattributes = new ArrayList();\r\n        String path = lnk.getBestPath();\r\n        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PATH, NbBundle.getMessage(this.getClass(), \"RecentDocumentsByLnk.parentModuleName.noSpace\"), path));\r\n        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PATH_ID, NbBundle.getMessage(this.getClass(), \"RecentDocumentsByLnk.parentModuleName.noSpace\"), Util.findID(dataSource, path)));\r\n        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DATETIME, NbBundle.getMessage(this.getClass(), \"RecentDocumentsByLnk.parentModuleName.noSpace\"), recentFile.getCrtime()));\r\n        this.addArtifact(ARTIFACT_TYPE.TSK_RECENT_OBJECT, recentFile, bbattributes);\r\n    }\r\n    services.fireModuleDataEvent(new ModuleDataEvent(NbBundle.getMessage(this.getClass(), \"RecentDocumentsByLnk.parentModuleName\"), BlackboardArtifact.ARTIFACT_TYPE.TSK_RECENT_OBJECT));\r\n}"
}, {
	"Path": "com.aliyun.oss.model.OSSObjectSummary.getETag",
	"Comment": "gets the object etag. etag is a 128bit md5 signature about the object inhex.",
	"Method": "String getETag(){\r\n    return eTag;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.CriterionChooser.setCriterion",
	"Comment": "populate this chooser with the given criterion. property and sort orderare used, rank is ignored.",
	"Method": "void setCriterion(SortCriterion criterion){\r\n    propComboBox.setSelectedItem(criterion.getProperty());\r\n    if (criterion.getSortOrder() == SortOrder.DESCENDING) {\r\n        descendingRadio.setSelected(true);\r\n    } else {\r\n        ascendingRadio.setSelected(true);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJob.hashCode",
	"Comment": "returns a hash code value for the job. the hash code is derived from themanifest file path.",
	"Method": "int hashCode(){\r\n    int hash = 71 * (Objects.hashCode(this.getManifest().getFilePath()));\r\n    return hash;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.ImageGalleryController.queueDBTask",
	"Comment": "add innertask to the queue that the worker thread gets its work from",
	"Method": "void queueDBTask(BackgroundTask bgTask){\r\n    if (!dbExecutor.isShutdown()) {\r\n        incrementQueueSize();\r\n        dbExecutor.submit(bgTask).addListener(this::decrementQueueSize, MoreExecutors.directExecutor());\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.AbstractSqlEamDb.getCorrelationTypeByIdFromCr",
	"Comment": "get the eamartifact.type that has the given type.id from the central repo",
	"Method": "CorrelationAttributeInstance.Type getCorrelationTypeByIdFromCr(int typeId){\r\n    Connection conn = connect();\r\n    CorrelationAttributeInstance.Type aType;\r\n    PreparedStatement preparedStatement = null;\r\n    ResultSet resultSet = null;\r\n    String sql = \"SELECT * FROM correlation_types WHERE id=?\";\r\n    try {\r\n        preparedStatement = conn.prepareStatement(sql);\r\n        preparedStatement.setInt(1, typeId);\r\n        resultSet = preparedStatement.executeQuery();\r\n        if (resultSet.next()) {\r\n            aType = getCorrelationTypeFromResultSet(resultSet);\r\n            return aType;\r\n        } else {\r\n            throw new EamDbException(\"Failed to find entry for correlation type ID = \" + typeId);\r\n        }\r\n    } catch (SQLException ex) {\r\n        throw new EamDbException(\"Error getting correlation type by id.\", ex);\r\n    } finally {\r\n        EamDbUtil.closeStatement(preparedStatement);\r\n        EamDbUtil.closeResultSet(resultSet);\r\n        EamDbUtil.closeConnection(conn);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.ui.AbstractTimelineChart.addContextLabel",
	"Comment": "add a label node to the contextual label container for the declutteredaxis labels.",
	"Method": "void addContextLabel(String labelText,double labelWidth,double labelX){\r\n    Label label = new Label(labelText);\r\n    label.setAlignment(Pos.CENTER);\r\n    label.setTextAlignment(TextAlignment.CENTER);\r\n    label.setFont(Font.font(10));\r\n    label.setTextOverrun(OverrunStyle.LEADING_ELLIPSIS);\r\n    label.setMinWidth(labelWidth);\r\n    label.setPrefWidth(labelWidth);\r\n    label.setMaxWidth(labelWidth);\r\n    label.relocate(labelX, 0);\r\n    if (labelX == 0) {\r\n        label.setBorder(null);\r\n    } else {\r\n        label.setBorder(ONLY_LEFT_BORDER);\r\n    }\r\n    contextLabelPane.getChildren().add(label);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.gui.GuiUtils.setDialogIcons",
	"Comment": "set the title bar icon for the given dialog to be the autopsy logo icon.",
	"Method": "void setDialogIcons(Dialog<?> dialog){\r\n    ((Stage) dialog.getDialogPane().getScene().getWindow()).getIcons().setAll(AUTOPSY_ICON);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.CorrelationAttributeInstance.setKnownStatus",
	"Comment": "set the knownstatus. this only indicates whether an item has been taggedas notable and should never be set to known.",
	"Method": "void setKnownStatus(TskData.FileKnown knownStatus){\r\n    this.knownStatus = knownStatus;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.datamodel.AbstractAbstractFileNode.getContentTagsFromDatabase",
	"Comment": "get all tags from the case database that are associated with the file",
	"Method": "List<ContentTag> getContentTagsFromDatabase(){\r\n    List<ContentTag> tags = new ArrayList();\r\n    try {\r\n        tags.addAll(Case.getCurrentCaseThrows().getServices().getTagsManager().getContentTagsByContent(content));\r\n    } catch (TskCoreException | NoCurrentCaseException ex) {\r\n        logger.log(Level.SEVERE, \"Failed to get tags for content \" + content.getName(), ex);\r\n    }\r\n    return tags;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.filetypeid.FileTypeIdGlobalSettingsPanel.clearTypeDetailsComponents",
	"Comment": "clears all of the components in the individual type details portion ofthe panel.",
	"Method": "void clearTypeDetailsComponents(){\r\n    typesList.clearSelection();\r\n    this.signaturesListModel.clear();\r\n    enableButtons();\r\n}"
}, {
	"Path": "org.codechimp.apprater.AppRater.setNumDaysForRemindLater",
	"Comment": "sets number of day until rating dialog pops up for next time when remindme later option is chosen",
	"Method": "void setNumDaysForRemindLater(int daysUntilPromt){\r\n    DAYS_UNTIL_PROMPT_FOR_REMIND_LATER = daysUntilPromt;\r\n}"
}, {
	"Path": "burrows.apps.example.template.adapter.BaseAdapter.getLocation",
	"Comment": "searches the data for the specified object and returns the index of thefirst occurrence.",
	"Method": "int getLocation(T object){\r\n    return data.indexOf(object);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.TableFilterChildren.createInstance",
	"Comment": "creates a children object for a tablefilternode. a tablefilternodecreates at most one layer of child nodes for the node it wraps. it isdesigned to be used in the results view to ensure the individual viewersdisplay only the first layer of child nodes.",
	"Method": "Children createInstance(Node wrappedNode,boolean createChildren){\r\n    if (createChildren) {\r\n        return new TableFilterChildren(wrappedNode);\r\n    } else {\r\n        return Children.LEAF;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.ReportKML.generateReport",
	"Comment": "generates a body file format report for use with the mac time tool.",
	"Method": "void generateReport(String baseReportDir,ReportProgressPanel progressPanel){\r\n    try {\r\n        currentCase = Case.getCurrentCaseThrows();\r\n    } catch (NoCurrentCaseException ex) {\r\n        logger.log(Level.SEVERE, \"Exception while getting open case.\", ex);\r\n        return;\r\n    }\r\n    progressPanel.setIndeterminate(true);\r\n    progressPanel.start();\r\n    progressPanel.updateStatusLabel(NbBundle.getMessage(this.getClass(), \"ReportKML.progress.querying\"));\r\n    String kmlFileFullPath = baseReportDir + REPORT_KML;\r\n    skCase = currentCase.getSleuthkitCase();\r\n    progressPanel.updateStatusLabel(NbBundle.getMessage(this.getClass(), \"ReportKML.progress.loading\"));\r\n    ns = Namespace.getNamespace(\"\", \"http://www.opengis.net/kml/2.2\");\r\n    Element kml = new Element(\"kml\", ns);\r\n    kml.addNamespaceDeclaration(Namespace.getNamespace(\"gx\", \"http://www.google.com/kml/ext/2.2\"));\r\n    kml.addNamespaceDeclaration(Namespace.getNamespace(\"kml\", \"http://www.opengis.net/kml/2.2\"));\r\n    kml.addNamespaceDeclaration(Namespace.getNamespace(\"atom\", \"http://www.w3.org/2005/Atom\"));\r\n    Document kmlDocument = new Document(kml);\r\n    Element document = new Element(\"Document\", ns);\r\n    kml.addContent(document);\r\n    Element name = new Element(\"name\", ns);\r\n    ReportBranding rb = new ReportBranding();\r\n    name.setText(rb.getReportTitle() + \" KML\");\r\n    document.addContent(name);\r\n    if (IngestManager.getInstance().isIngestRunning()) {\r\n        Element ingestwarning = new Element(\"snippet\", ns);\r\n        ingestwarning.addContent(NbBundle.getMessage(this.getClass(), \"ReportBodyFile.ingestWarning.text\"));\r\n        document.addContent(ingestwarning);\r\n    }\r\n    Element gpsExifMetadataFolder = new Element(\"Folder\", ns);\r\n    CDATA cdataExifMetadataFolder = new CDATA(\"https://raw.githubusercontent.com/sleuthkit/autopsy/develop/Core/src/org/sleuthkit/autopsy/images/camera-icon-16.png\");\r\n    Element hrefExifMetadata = new Element(\"href\", ns).addContent(cdataExifMetadataFolder);\r\n    gpsExifMetadataFolder.addContent(new Element(\"Icon\", ns).addContent(hrefExifMetadata));\r\n    Element gpsBookmarksFolder = new Element(\"Folder\", ns);\r\n    CDATA cdataBookmarks = new CDATA(\"https://raw.githubusercontent.com/sleuthkit/autopsy/develop/Core/src/org/sleuthkit/autopsy/images/gpsfav.png\");\r\n    Element hrefBookmarks = new Element(\"href\", ns).addContent(cdataBookmarks);\r\n    gpsBookmarksFolder.addContent(new Element(\"Icon\", ns).addContent(hrefBookmarks));\r\n    Element gpsLastKnownLocationFolder = new Element(\"Folder\", ns);\r\n    CDATA cdataLastKnownLocation = new CDATA(\"https://raw.githubusercontent.com/sleuthkit/autopsy/develop/Core/src/org/sleuthkit/autopsy/images/gps-lastlocation.png\");\r\n    Element hrefLastKnownLocation = new Element(\"href\", ns).addContent(cdataLastKnownLocation);\r\n    gpsLastKnownLocationFolder.addContent(new Element(\"Icon\", ns).addContent(hrefLastKnownLocation));\r\n    Element gpsRouteFolder = new Element(\"Folder\", ns);\r\n    CDATA cdataRoute = new CDATA(\"https://raw.githubusercontent.com/sleuthkit/autopsy/develop/Core/src/org/sleuthkit/autopsy/images/gps-trackpoint.png\");\r\n    Element hrefRoute = new Element(\"href\", ns).addContent(cdataRoute);\r\n    gpsRouteFolder.addContent(new Element(\"Icon\", ns).addContent(hrefRoute));\r\n    Element gpsSearchesFolder = new Element(\"Folder\", ns);\r\n    CDATA cdataSearches = new CDATA(\"https://raw.githubusercontent.com/sleuthkit/autopsy/develop/Core/src/org/sleuthkit/autopsy/images/gps-search.png\");\r\n    Element hrefSearches = new Element(\"href\", ns).addContent(cdataSearches);\r\n    gpsSearchesFolder.addContent(new Element(\"Icon\", ns).addContent(hrefSearches));\r\n    Element gpsTrackpointsFolder = new Element(\"Folder\", ns);\r\n    CDATA cdataTrackpoints = new CDATA(\"https://raw.githubusercontent.com/sleuthkit/autopsy/develop/Core/src/org/sleuthkit/autopsy/images/gps-trackpoint.png\");\r\n    Element hrefTrackpoints = new Element(\"href\", ns).addContent(cdataTrackpoints);\r\n    gpsTrackpointsFolder.addContent(new Element(\"Icon\", ns).addContent(hrefTrackpoints));\r\n    gpsExifMetadataFolder.addContent(new Element(\"name\", ns).addContent(\"EXIF Metadata\"));\r\n    gpsBookmarksFolder.addContent(new Element(\"name\", ns).addContent(\"GPS Bookmarks\"));\r\n    gpsLastKnownLocationFolder.addContent(new Element(\"name\", ns).addContent(\"GPS Last Known Location\"));\r\n    gpsRouteFolder.addContent(new Element(\"name\", ns).addContent(\"GPS Routes\"));\r\n    gpsSearchesFolder.addContent(new Element(\"name\", ns).addContent(\"GPS Searches\"));\r\n    gpsTrackpointsFolder.addContent(new Element(\"name\", ns).addContent(\"GPS Trackpoints\"));\r\n    document.addContent(gpsExifMetadataFolder);\r\n    document.addContent(gpsBookmarksFolder);\r\n    document.addContent(gpsLastKnownLocationFolder);\r\n    document.addContent(gpsRouteFolder);\r\n    document.addContent(gpsSearchesFolder);\r\n    document.addContent(gpsTrackpointsFolder);\r\n    ReportProgressPanel.ReportStatus result = ReportProgressPanel.ReportStatus.COMPLETE;\r\n    try {\r\n        for (BlackboardArtifact artifact : skCase.getBlackboardArtifacts(BlackboardArtifact.ARTIFACT_TYPE.TSK_METADATA_EXIF)) {\r\n            String fileName = \"\";\r\n            long fileId = 0;\r\n            try {\r\n                Long timestamp = getLong(artifact, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_CREATED);\r\n                String desc = getDescriptionFromArtifact(artifact, \"EXIF Metadata With Locations\");\r\n                Double lat = getDouble(artifact, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LATITUDE);\r\n                Double lon = getDouble(artifact, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LONGITUDE);\r\n                Element point = makePoint(lat, lon, getDouble(artifact, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_ALTITUDE));\r\n                if (lat != null && lat != 0.0 && lon != null && lon != 0.0) {\r\n                    AbstractFile abstractFile = artifact.getSleuthkitCase().getAbstractFileById(artifact.getObjectID());\r\n                    fileName = abstractFile.getName();\r\n                    fileId = abstractFile.getId();\r\n                    Path path;\r\n                    copyFileUsingStream(abstractFile, Paths.get(baseReportDir, abstractFile.getName()).toFile());\r\n                    try {\r\n                        path = Paths.get(removeLeadingImgAndVol(abstractFile.getUniquePath()));\r\n                    } catch (TskCoreException ex) {\r\n                        path = Paths.get(abstractFile.getParentPath(), abstractFile.getName());\r\n                    }\r\n                    String formattedCoordinates = String.format(\"%.2f, %.2f\", lat, lon);\r\n                    if (path == null) {\r\n                        path = Paths.get(abstractFile.getName());\r\n                    }\r\n                    gpsExifMetadataFolder.addContent(makePlacemarkWithPicture(abstractFile.getName(), FeatureColor.RED, desc, timestamp, point, path, formattedCoordinates));\r\n                }\r\n            } catch (ReadContentInputStreamException ex) {\r\n                logger.log(Level.WARNING, String.format(\"Error reading file '%s' (id=%d).\", fileName, fileId), ex);\r\n            } catch (Exception ex) {\r\n                logger.log(Level.SEVERE, \"Could not extract photo information.\", ex);\r\n                result = ReportProgressPanel.ReportStatus.ERROR;\r\n            }\r\n        }\r\n    } catch (TskCoreException ex) {\r\n        logger.log(Level.SEVERE, \"Could not extract photos with EXIF metadata.\", ex);\r\n        result = ReportProgressPanel.ReportStatus.ERROR;\r\n    }\r\n    try {\r\n        for (BlackboardArtifact artifact : skCase.getBlackboardArtifacts(BlackboardArtifact.ARTIFACT_TYPE.TSK_GPS_BOOKMARK)) {\r\n            try {\r\n                Long timestamp = getLong(artifact, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME);\r\n                String desc = getDescriptionFromArtifact(artifact, \"GPS Bookmark\");\r\n                Double lat = getDouble(artifact, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LATITUDE);\r\n                Double lon = getDouble(artifact, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LONGITUDE);\r\n                Element point = makePoint(lat, lon, getDouble(artifact, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_ALTITUDE));\r\n                String bookmarkName = getString(artifact, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME);\r\n                String formattedCoordinates = String.format(\"%.2f, %.2f\", lat, lon);\r\n                gpsBookmarksFolder.addContent(makePlacemark(bookmarkName, FeatureColor.BLUE, desc, timestamp, point, formattedCoordinates));\r\n            } catch (Exception ex) {\r\n                logger.log(Level.SEVERE, \"Could not extract Bookmark information.\", ex);\r\n                result = ReportProgressPanel.ReportStatus.ERROR;\r\n            }\r\n        }\r\n    } catch (TskCoreException ex) {\r\n        logger.log(Level.SEVERE, \"Could not get GPS Bookmarks from database.\", ex);\r\n        result = ReportProgressPanel.ReportStatus.ERROR;\r\n    }\r\n    try {\r\n        for (BlackboardArtifact artifact : skCase.getBlackboardArtifacts(BlackboardArtifact.ARTIFACT_TYPE.TSK_GPS_LAST_KNOWN_LOCATION)) {\r\n            try {\r\n                Long timestamp = getLong(artifact, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME);\r\n                String desc = getDescriptionFromArtifact(artifact, \"GPS Last Known Location\");\r\n                Double lat = getDouble(artifact, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LATITUDE);\r\n                Double lon = getDouble(artifact, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LONGITUDE);\r\n                Double alt = getDouble(artifact, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_ALTITUDE);\r\n                Element point = makePoint(lat, lon, alt);\r\n                String formattedCoordinates = String.format(\"%.2f, %.2f\", lat, lon);\r\n                gpsLastKnownLocationFolder.addContent(makePlacemark(\"Last Known Location\", FeatureColor.PURPLE, desc, timestamp, point, formattedCoordinates));\r\n            } catch (Exception ex) {\r\n                logger.log(Level.SEVERE, \"Could not extract Last Known Location information.\", ex);\r\n                result = ReportProgressPanel.ReportStatus.ERROR;\r\n            }\r\n        }\r\n    } catch (TskCoreException ex) {\r\n        logger.log(Level.SEVERE, \"Could not get GPS Last Known Location from database.\", ex);\r\n        result = ReportProgressPanel.ReportStatus.ERROR;\r\n    }\r\n    try {\r\n        for (BlackboardArtifact artifact : skCase.getBlackboardArtifacts(BlackboardArtifact.ARTIFACT_TYPE.TSK_GPS_ROUTE)) {\r\n            try {\r\n                Long timestamp = getLong(artifact, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME);\r\n                String desc = getDescriptionFromArtifact(artifact, \"GPS Route\");\r\n                Double latitudeStart = getDouble(artifact, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LATITUDE_START);\r\n                Double longitudeStart = getDouble(artifact, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LONGITUDE_START);\r\n                Double latitudeEnd = getDouble(artifact, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LATITUDE_END);\r\n                Double longitudeEnd = getDouble(artifact, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LONGITUDE_END);\r\n                Double altitude = getDouble(artifact, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_ALTITUDE);\r\n                Element route = makeLineString(latitudeStart, longitudeStart, altitude, latitudeEnd, longitudeEnd, altitude);\r\n                Element startingPoint = makePoint(latitudeStart, longitudeStart, altitude);\r\n                Element endingPoint = makePoint(latitudeEnd, longitudeEnd, altitude);\r\n                String formattedCoordinates = String.format(\"%.2f, %.2f to %.2f, %.2f\", latitudeStart, longitudeStart, latitudeEnd, longitudeEnd);\r\n                gpsRouteFolder.addContent(makePlacemark(\"As-the-crow-flies Route\", FeatureColor.GREEN, desc, timestamp, route, formattedCoordinates));\r\n                formattedCoordinates = String.format(\"%.2f, %.2f\", latitudeStart, longitudeStart);\r\n                gpsRouteFolder.addContent(makePlacemark(\"Start\", FeatureColor.GREEN, desc, timestamp, startingPoint, formattedCoordinates));\r\n                formattedCoordinates = String.format(\"%.2f, %.2f\", latitudeEnd, longitudeEnd);\r\n                gpsRouteFolder.addContent(makePlacemark(\"End\", FeatureColor.GREEN, desc, timestamp, endingPoint, formattedCoordinates));\r\n            } catch (Exception ex) {\r\n                logger.log(Level.SEVERE, \"Could not extract GPS Route information.\", ex);\r\n                result = ReportProgressPanel.ReportStatus.ERROR;\r\n            }\r\n        }\r\n    } catch (TskCoreException ex) {\r\n        logger.log(Level.SEVERE, \"Could not get GPS Routes from database.\", ex);\r\n        result = ReportProgressPanel.ReportStatus.ERROR;\r\n    }\r\n    try {\r\n        for (BlackboardArtifact artifact : skCase.getBlackboardArtifacts(BlackboardArtifact.ARTIFACT_TYPE.TSK_GPS_SEARCH)) {\r\n            Long timestamp = getLong(artifact, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME);\r\n            String desc = getDescriptionFromArtifact(artifact, \"GPS Search\");\r\n            Double lat = getDouble(artifact, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LATITUDE);\r\n            Double lon = getDouble(artifact, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LONGITUDE);\r\n            Double alt = getDouble(artifact, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_ALTITUDE);\r\n            Element point = makePoint(lat, lon, alt);\r\n            String formattedCoordinates = String.format(\"%.2f, %.2f\", lat, lon);\r\n            String searchName = getString(artifact, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME);\r\n            if (searchName == null || searchName.isEmpty()) {\r\n                searchName = getString(artifact, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_LOCATION);\r\n            }\r\n            if (searchName == null || searchName.isEmpty()) {\r\n                searchName = \"GPS Search\";\r\n            }\r\n            gpsSearchesFolder.addContent(makePlacemark(searchName, FeatureColor.WHITE, desc, timestamp, point, formattedCoordinates));\r\n        }\r\n    } catch (TskCoreException ex) {\r\n        logger.log(Level.SEVERE, \"Could not get GPS Searches from database.\", ex);\r\n        result = ReportProgressPanel.ReportStatus.ERROR;\r\n    }\r\n    try {\r\n        for (BlackboardArtifact artifact : skCase.getBlackboardArtifacts(BlackboardArtifact.ARTIFACT_TYPE.TSK_GPS_TRACKPOINT)) {\r\n            try {\r\n                Long timestamp = getLong(artifact, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME);\r\n                String desc = getDescriptionFromArtifact(artifact, \"GPS Trackpoint\");\r\n                Double lat = getDouble(artifact, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LATITUDE);\r\n                Double lon = getDouble(artifact, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LONGITUDE);\r\n                Double alt = getDouble(artifact, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_ALTITUDE);\r\n                Element point = makePoint(lat, lon, alt);\r\n                String formattedCoordinates = String.format(\"%.2f, %.2f, %.2f\", lat, lon, alt);\r\n                String trackName = getString(artifact, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME);\r\n                if (trackName == null || trackName.isEmpty()) {\r\n                    trackName = getString(artifact, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME);\r\n                }\r\n                if (trackName == null || trackName.isEmpty()) {\r\n                    trackName = getString(artifact, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_FLAG);\r\n                }\r\n                if (trackName == null || trackName.isEmpty()) {\r\n                    trackName = \"GPS Trackpoint\";\r\n                }\r\n                gpsTrackpointsFolder.addContent(makePlacemark(trackName, FeatureColor.YELLOW, desc, timestamp, point, formattedCoordinates));\r\n            } catch (Exception ex) {\r\n                logger.log(Level.SEVERE, \"Could not extract Trackpoint information.\", ex);\r\n                result = ReportProgressPanel.ReportStatus.ERROR;\r\n            }\r\n        }\r\n    } catch (TskCoreException ex) {\r\n        logger.log(Level.SEVERE, \"Could not get GPS Trackpoints from database.\", ex);\r\n        result = ReportProgressPanel.ReportStatus.ERROR;\r\n    }\r\n    try {\r\n        InputStream input = getClass().getResourceAsStream(STYLESHEETS_PATH + KML_STYLE_FILE);\r\n        OutputStream output = new FileOutputStream(baseReportDir + KML_STYLE_FILE);\r\n        FileUtil.copy(input, output);\r\n    } catch (IOException ex) {\r\n        logger.log(Level.SEVERE, \"Error placing KML stylesheet. The .KML file will not function properly.\", ex);\r\n        result = ReportProgressPanel.ReportStatus.ERROR;\r\n    }\r\n    try (FileOutputStream writer = new FileOutputStream(kmlFileFullPath)) {\r\n        XMLOutputter outputter = new XMLOutputter(Format.getPrettyFormat());\r\n        outputter.output(kmlDocument, writer);\r\n        String prependedStatus = \"\";\r\n        if (result == ReportProgressPanel.ReportStatus.ERROR) {\r\n            prependedStatus = \"Incomplete \";\r\n        }\r\n        Case.getCurrentCaseThrows().addReport(kmlFileFullPath, NbBundle.getMessage(this.getClass(), \"ReportKML.genReport.srcModuleName.text\"), prependedStatus + NbBundle.getMessage(this.getClass(), \"ReportKML.genReport.reportName\"));\r\n    } catch (IOException ex) {\r\n        logger.log(Level.SEVERE, \"Could not write the KML file.\", ex);\r\n        progressPanel.complete(ReportProgressPanel.ReportStatus.ERROR);\r\n    } catch (TskCoreException ex) {\r\n        String errorMessage = String.format(\"Error adding %s to case as a report\", kmlFileFullPath);\r\n        logger.log(Level.SEVERE, errorMessage, ex);\r\n        result = ReportProgressPanel.ReportStatus.ERROR;\r\n    } catch (NoCurrentCaseException ex) {\r\n        logger.log(Level.SEVERE, \"Exception while getting open case.\", ex);\r\n        result = ReportProgressPanel.ReportStatus.ERROR;\r\n    }\r\n    progressPanel.complete(result);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.QueryResults.writeSingleFileInboxMessage",
	"Comment": "send an ingest inbox message indicating that there was a keyword hit inthe given text source object.",
	"Method": "void writeSingleFileInboxMessage(BlackboardArtifact artifact,Content hitContent){\r\n    StringBuilder subjectSb = new StringBuilder(1024);\r\n    if (!query.isLiteral()) {\r\n        subjectSb.append(NbBundle.getMessage(this.getClass(), \"KeywordSearchIngestModule.regExpHitLbl\"));\r\n    } else {\r\n        subjectSb.append(NbBundle.getMessage(this.getClass(), \"KeywordSearchIngestModule.kwHitLbl\"));\r\n    }\r\n    StringBuilder detailsSb = new StringBuilder(1024);\r\n    String uniqueKey = null;\r\n    BlackboardAttribute attr = artifact.getAttribute(new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_KEYWORD));\r\n    if (attr != null) {\r\n        final String keyword = attr.getValueString();\r\n        subjectSb.append(keyword);\r\n        uniqueKey = keyword.toLowerCase();\r\n        detailsSb.append(\"<table border='0' cellpadding='4' width='280'>\");\r\n        detailsSb.append(\"<tr>\");\r\n        detailsSb.append(NbBundle.getMessage(this.getClass(), \"KeywordSearchIngestModule.kwHitThLbl\"));\r\n        detailsSb.append(\"<td>\").append(EscapeUtil.escapeHtml(keyword)).append(\"<\/td>\");\r\n        detailsSb.append(\"<\/tr>\");\r\n    }\r\n    attr = artifact.getAttribute(new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_KEYWORD_PREVIEW));\r\n    if (attr != null) {\r\n        detailsSb.append(\"<tr>\");\r\n        detailsSb.append(NbBundle.getMessage(this.getClass(), \"KeywordSearchIngestModule.previewThLbl\"));\r\n        detailsSb.append(\"<td>\").append(EscapeUtil.escapeHtml(attr.getValueString())).append(\"<\/td>\");\r\n        detailsSb.append(\"<\/tr>\");\r\n    }\r\n    detailsSb.append(\"<tr>\");\r\n    detailsSb.append(NbBundle.getMessage(this.getClass(), \"KeywordSearchIngestModule.fileThLbl\"));\r\n    if (hitContent instanceof AbstractFile) {\r\n        AbstractFile hitFile = (AbstractFile) hitContent;\r\n        detailsSb.append(\"<td>\").append(hitFile.getParentPath()).append(hitFile.getName()).append(\"<\/td>\");\r\n    } else {\r\n        detailsSb.append(\"<td>\").append(hitContent.getName()).append(\"<\/td>\");\r\n    }\r\n    detailsSb.append(\"<\/tr>\");\r\n    attr = artifact.getAttribute(new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_SET_NAME));\r\n    if (attr != null) {\r\n        detailsSb.append(\"<tr>\");\r\n        detailsSb.append(NbBundle.getMessage(this.getClass(), \"KeywordSearchIngestModule.listThLbl\"));\r\n        detailsSb.append(\"<td>\").append(attr.getValueString()).append(\"<\/td>\");\r\n        detailsSb.append(\"<\/tr>\");\r\n    }\r\n    if (!query.isLiteral()) {\r\n        attr = artifact.getAttribute(new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_KEYWORD_REGEXP));\r\n        if (attr != null) {\r\n            detailsSb.append(\"<tr>\");\r\n            detailsSb.append(NbBundle.getMessage(this.getClass(), \"KeywordSearchIngestModule.regExThLbl\"));\r\n            detailsSb.append(\"<td>\").append(attr.getValueString()).append(\"<\/td>\");\r\n            detailsSb.append(\"<\/tr>\");\r\n        }\r\n    }\r\n    detailsSb.append(\"<\/table>\");\r\n    IngestServices.getInstance().postMessage(IngestMessage.createDataMessage(MODULE_NAME, subjectSb.toString(), detailsSb.toString(), uniqueKey, artifact));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.hashdatabase.HashDbSearcher.findFilesBymd5",
	"Comment": "given a list of string hash values, returns a map of md5 hashes to thelist of files hit.",
	"Method": "Map<String, List<AbstractFile>> findFilesBymd5(List<String> md5Hash,Map<String, List<AbstractFile>> findFilesBymd5,List<String> md5Hash,ProgressHandle progress,SwingWorker<Object, Void> worker){\r\n    Map<String, List<AbstractFile>> map = new LinkedHashMap<String, List<AbstractFile>>();\r\n    if (!worker.isCancelled()) {\r\n        progress.switchToDeterminate(md5Hash.size());\r\n        int size = 0;\r\n        for (String md5 : md5Hash) {\r\n            if (worker.isCancelled()) {\r\n                break;\r\n            }\r\n            List<AbstractFile> files = findFilesByMd5(md5);\r\n            if (!files.isEmpty()) {\r\n                map.put(md5, files);\r\n            }\r\n            size++;\r\n            if (!worker.isCancelled()) {\r\n                progress.progress(size);\r\n            }\r\n        }\r\n    }\r\n    return map;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.KeywordHit.getArtifactID",
	"Comment": "if this hit is in the indexed text of an artifact, get that artifact.",
	"Method": "Optional<Long> getArtifactID(){\r\n    if (isArtifactHit()) {\r\n        return Optional.of(solrObjectId);\r\n    } else {\r\n        return Optional.empty();\r\n    }\r\n}"
}, {
	"Path": "com.google.example.games.catt2.MainActivity.handleException",
	"Comment": "since a lot of the operations use tasks, we can use a common handler for whenever one fails.",
	"Method": "void handleException(Exception exception,String details){\r\n    int status = 0;\r\n    if (exception instanceof ApiException) {\r\n        ApiException apiException = (ApiException) exception;\r\n        status = apiException.getStatusCode();\r\n    }\r\n    String message = getString(R.string.status_exception_error, details, status, exception);\r\n    new AlertDialog.Builder(MainActivity.this).setMessage(message).setNeutralButton(android.R.string.ok, null).show();\r\n    if (status == GamesClientStatusCodes.SNAPSHOT_NOT_FOUND) {\r\n        Log.i(TAG, \"Error: Snapshot not found\");\r\n        Toast.makeText(getBaseContext(), \"Error: Snapshot not found\", Toast.LENGTH_SHORT).show();\r\n    } else if (status == GamesClientStatusCodes.SNAPSHOT_CONTENTS_UNAVAILABLE) {\r\n        Log.i(TAG, \"Error: Snapshot contents unavailable\");\r\n        Toast.makeText(getBaseContext(), \"Error: Snapshot contents unavailable\", Toast.LENGTH_SHORT).show();\r\n    } else if (status == GamesClientStatusCodes.SNAPSHOT_FOLDER_UNAVAILABLE) {\r\n        Log.i(TAG, \"Error: Snapshot folder unavailable\");\r\n        Toast.makeText(getBaseContext(), \"Error: Snapshot folder unavailable.\", Toast.LENGTH_SHORT).show();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.directorytree.DataResultFilterNode.setChildNodeSelectionInfo",
	"Comment": "adds information about which child node of this node, if any, should beselected. can be null.",
	"Method": "void setChildNodeSelectionInfo(NodeSelectionInfo selectedChildNodeInfo){\r\n    if (getOriginal() instanceof DisplayableItemNode) {\r\n        ((DisplayableItemNode) getOriginal()).setChildNodeSelectionInfo(selectedChildNodeInfo);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.healthmonitor.HealthMonitorDashboard.createAdminPanel",
	"Comment": "create the admin panel.this allows the health monitor to be enabled and disabled.",
	"Method": "JPanel createAdminPanel(){\r\n    JPanel adminPanel = new JPanel();\r\n    adminPanel.setBorder(BorderFactory.createEtchedBorder());\r\n    JButton enableButton = new JButton(Bundle.HealthMonitorDashboard_createAdminPanel_enableButton());\r\n    JButton disableButton = new JButton(Bundle.HealthMonitorDashboard_createAdminPanel_disableButton());\r\n    boolean isEnabled = HealthMonitor.monitorIsEnabled();\r\n    enableButton.setEnabled(!isEnabled);\r\n    disableButton.setEnabled(isEnabled);\r\n    enableButton.addActionListener(new ActionListener() {\r\n        @Override\r\n        public void actionPerformed(ActionEvent arg0) {\r\n            try {\r\n                dialog.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\r\n                HealthMonitor.setEnabled(true);\r\n                redisplay();\r\n            } catch (HealthMonitorException ex) {\r\n                logger.log(Level.SEVERE, \"Error enabling monitoring\", ex);\r\n            } finally {\r\n                dialog.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));\r\n            }\r\n        }\r\n    });\r\n    disableButton.addActionListener(new ActionListener() {\r\n        @Override\r\n        public void actionPerformed(ActionEvent arg0) {\r\n            try {\r\n                dialog.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\r\n                HealthMonitor.setEnabled(false);\r\n                redisplay();\r\n            } catch (HealthMonitorException ex) {\r\n                logger.log(Level.SEVERE, \"Error disabling monitoring\", ex);\r\n            } finally {\r\n                dialog.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));\r\n            }\r\n        }\r\n    });\r\n    adminPanel.add(enableButton);\r\n    adminPanel.add(Box.createHorizontalStrut(25));\r\n    adminPanel.add(disableButton);\r\n    return adminPanel;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.healthmonitor.HealthMonitorDashboard.createAdminPanel",
	"Comment": "create the admin panel.this allows the health monitor to be enabled and disabled.",
	"Method": "JPanel createAdminPanel(){\r\n    try {\r\n        dialog.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\r\n        HealthMonitor.setEnabled(true);\r\n        redisplay();\r\n    } catch (HealthMonitorException ex) {\r\n        logger.log(Level.SEVERE, \"Error enabling monitoring\", ex);\r\n    } finally {\r\n        dialog.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.healthmonitor.HealthMonitorDashboard.createAdminPanel",
	"Comment": "create the admin panel.this allows the health monitor to be enabled and disabled.",
	"Method": "JPanel createAdminPanel(){\r\n    try {\r\n        dialog.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\r\n        HealthMonitor.setEnabled(false);\r\n        redisplay();\r\n    } catch (HealthMonitorException ex) {\r\n        logger.log(Level.SEVERE, \"Error disabling monitoring\", ex);\r\n    } finally {\r\n        dialog.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestPipelinesConfiguration.getStageTwoDataSourceIngestPipelineConfig",
	"Comment": "gets the ordered list of ingest module factory class names for the secondstage data source ingest pipeline.",
	"Method": "List<String> getStageTwoDataSourceIngestPipelineConfig(){\r\n    return new ArrayList(stageTwoDataSourceIngestPipelineConfig);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.DataSourceIngestPipeline.isEmpty",
	"Comment": "indicates whether or not there are any ingest modules in this pipeline.",
	"Method": "boolean isEmpty(){\r\n    return modules.isEmpty();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.OptionalCasePropertiesPanel.updateCorrelationCase",
	"Comment": "save changed value from text fields and text areas into the eamcaseobject.",
	"Method": "void updateCorrelationCase(){\r\n    setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\r\n    if (EamDb.isEnabled()) {\r\n        try {\r\n            EamDb dbManager = EamDb.getInstance();\r\n            CorrelationCase correlationCase = dbManager.getCase(Case.getCurrentCaseThrows());\r\n            if (caseDisplayNameTextField.isVisible()) {\r\n                correlationCase.setDisplayName(caseDisplayNameTextField.getText());\r\n            }\r\n            correlationCase.setOrg(selectedOrg);\r\n            correlationCase.setCaseNumber(caseNumberTextField.getText());\r\n            correlationCase.setExaminerName(examinerTextField.getText());\r\n            correlationCase.setExaminerEmail(tfExaminerEmailText.getText());\r\n            correlationCase.setExaminerPhone(tfExaminerPhoneText.getText());\r\n            correlationCase.setNotes(taNotesText.getText());\r\n            dbManager.updateCase(correlationCase);\r\n        } catch (EamDbException ex) {\r\n            logger.log(Level.SEVERE, \"Error connecting to central repository database\", ex);\r\n        } catch (NoCurrentCaseException ex) {\r\n            logger.log(Level.SEVERE, \"Exception while getting open case.\", ex);\r\n        } finally {\r\n            setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "burrows.apps.example.template.util.PlayServicesUtils.hasGooglePlayServices",
	"Comment": "check if device has the correct google play services version.",
	"Method": "boolean hasGooglePlayServices(Activity activity,GoogleApiAvailability availability){\r\n    final int result = availability.isGooglePlayServicesAvailable(activity);\r\n    if (result == ConnectionResult.SUCCESS) {\r\n        return true;\r\n    } else {\r\n        final Dialog dialog = availability.getErrorDialog(activity, result, 0);\r\n        dialog.setOnCancelListener(DialogInterface::cancel);\r\n        dialog.show();\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.ReportVisualPanel2.updateFinishButton",
	"Comment": "set the finish button as either enabled or disabled depending on the uicomponent selections.",
	"Method": "void updateFinishButton(){\r\n    if (taggedResultsRadioButton.isSelected()) {\r\n        wizPanel.setFinish(areTagsSelected());\r\n    } else {\r\n        wizPanel.setFinish(true);\r\n    }\r\n}"
}, {
	"Path": "com.aliyun.oss.common.provider.TestBase.setEnv",
	"Comment": "set environment variables to include those in the given map.",
	"Method": "void setEnv(Map<String, String> newenv){\r\n    try {\r\n        Class<?> processEnvironmentClass = Class.forName(\"java.lang.ProcessEnvironment\");\r\n        Field theEnvironmentField = processEnvironmentClass.getDeclaredField(\"theEnvironment\");\r\n        theEnvironmentField.setAccessible(true);\r\n        Map<String, String> env = (Map<String, String>) theEnvironmentField.get(null);\r\n        env.putAll(newenv);\r\n        Field theCaseInsensitiveEnvironmentField = processEnvironmentClass.getDeclaredField(\"theCaseInsensitiveEnvironment\");\r\n        theCaseInsensitiveEnvironmentField.setAccessible(true);\r\n        Map<String, String> cienv = (Map<String, String>) theCaseInsensitiveEnvironmentField.get(null);\r\n        cienv.putAll(newenv);\r\n    } catch (NoSuchFieldException e) {\r\n        try {\r\n            Class[] classes = Collections.class.getDeclaredClasses();\r\n            Map<String, String> env = System.getenv();\r\n            for (Class cl : classes) {\r\n                if (\"java.util.Collections$UnmodifiableMap\".equals(cl.getName())) {\r\n                    Field field = cl.getDeclaredField(\"m\");\r\n                    field.setAccessible(true);\r\n                    Object obj = field.get(env);\r\n                    Map<String, String> map = (Map<String, String>) obj;\r\n                    map.clear();\r\n                    map.putAll(newenv);\r\n                }\r\n            }\r\n        } catch (Exception e2) {\r\n            e2.printStackTrace();\r\n        }\r\n    } catch (Exception e1) {\r\n        e1.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.encryptiondetection.EncryptionDetectionIngestJobSettings.getMinimumFileSize",
	"Comment": "get the minimum file size necessary for the creation of blackboardartifacts.",
	"Method": "int getMinimumFileSize(){\r\n    return minimumFileSize;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.iOS.TextMessageAnalyzer.findTexts",
	"Comment": "find text messages given an ingest job context and index the results.",
	"Method": "void findTexts(IngestJobContext context){\r\n    Case openCase;\r\n    try {\r\n        openCase = Case.getCurrentCaseThrows();\r\n    } catch (NoCurrentCaseException ex) {\r\n        logger.log(Level.SEVERE, \"Exception while getting open case.\", ex);\r\n        return;\r\n    }\r\n    blackboard = openCase.getServices().getBlackboard();\r\n    try {\r\n        SleuthkitCase skCase = openCase.getSleuthkitCase();\r\n        absFiles = skCase.findAllFilesWhere(\"name ='mmssms.db'\");\r\n        if (absFiles.isEmpty()) {\r\n            return;\r\n        }\r\n        for (AbstractFile file : absFiles) {\r\n            try {\r\n                jFile = new java.io.File(Case.getCurrentCaseThrows().getTempDirectory(), file.getName().replaceAll(\"[<>%|\\\"/:*\\\\\\\\]\", \"\"));\r\n                dbPath = jFile.toString();\r\n                fileId = file.getId();\r\n                ContentUtils.writeToFile(file, jFile, context::dataSourceIngestIsCancelled);\r\n                findTextsInDB(dbPath, fileId);\r\n            } catch (ReadContentInputStream.ReadContentInputStreamException ex) {\r\n                logger.log(Level.WARNING, String.format(\"Error reading content from file '%s' (id=%d).\", file.getName(), fileId), ex);\r\n            } catch (Exception ex) {\r\n                logger.log(Level.SEVERE, String.format(\"Error writing content from file '%s' (id=%d) to '%s'.\", file.getName(), fileId, dbPath), ex);\r\n            }\r\n        }\r\n    } catch (TskCoreException e) {\r\n        logger.log(Level.SEVERE, \"Error finding text messages\", e);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.configuration.AutoIngestUserPreferences.setSharedConfigEnabled",
	"Comment": "save shared config checkbox state for automated mode to persistentstorage.",
	"Method": "void setSharedConfigEnabled(boolean sharedSettingsEnabled){\r\n    ModuleSettings.setConfigSetting(UserPreferences.SETTINGS_PROPERTIES, SHARED_CONFIG_ENABLED, Boolean.toString(sharedSettingsEnabled));\r\n}"
}, {
	"Path": "com.aliyun.oss.ClientConfiguration.setSocketTimeout",
	"Comment": "sets the socket timeout in millisecond. 0 means infinite timeout, notrecommended.",
	"Method": "void setSocketTimeout(int socketTimeout){\r\n    this.socketTimeout = socketTimeout;\r\n}"
}, {
	"Path": "com.klinker.android.peekview.PeekView.show",
	"Comment": "show the content of the peekview by adding it to the android.r.id.content framelayout.",
	"Method": "void show(){\r\n    androidContentView.addView(this);\r\n    content.setTranslationX(distanceFromLeft);\r\n    content.setTranslationY(distanceFromTop);\r\n    ObjectAnimator animator = ObjectAnimator.ofFloat(this, View.ALPHA, 0.0f, 1.0f);\r\n    animator.addListener(new AnimatorEndListener() {\r\n        @Override\r\n        public void onAnimationEnd(Animator animator) {\r\n            if (callbacks != null) {\r\n                callbacks.shown();\r\n            }\r\n        }\r\n    });\r\n    animator.setDuration(options.useFadeAnimation() ? ANIMATION_TIME : 0);\r\n    animator.setInterpolator(INTERPOLATOR);\r\n    animator.start();\r\n}"
}, {
	"Path": "com.klinker.android.peekview.PeekView.show",
	"Comment": "show the content of the peekview by adding it to the android.r.id.content framelayout.",
	"Method": "void show(){\r\n    if (callbacks != null) {\r\n        callbacks.shown();\r\n    }\r\n}"
}, {
	"Path": "com.google.example.games.bc.MainActivity.showGameError",
	"Comment": "show error message about game being cancelled and return to main screen.",
	"Method": "void showGameError(){\r\n    new AlertDialog.Builder(this).setMessage(getString(R.string.game_problem)).setNeutralButton(android.R.string.ok, null).create();\r\n    switchToMainScreen();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.contentviewer.DataContentViewerOtherCases.getCaseDbMatches",
	"Comment": "get all other abstract files in the current case with the same md5 as theselected node.",
	"Method": "List<AbstractFile> getCaseDbMatches(CorrelationAttributeInstance corAttr,Case openCase){\r\n    String md5 = corAttr.getCorrelationValue();\r\n    SleuthkitCase tsk = openCase.getSleuthkitCase();\r\n    List<AbstractFile> matches = tsk.findAllFilesWhere(String.format(\"md5 = '%s'\", new Object[] { md5 }));\r\n    List<AbstractFile> caseDbArtifactInstances = new ArrayList();\r\n    for (AbstractFile fileMatch : matches) {\r\n        if (this.file.equals(fileMatch)) {\r\n            continue;\r\n        }\r\n        caseDbArtifactInstances.add(fileMatch);\r\n    }\r\n    return caseDbArtifactInstances;\r\n}"
}, {
	"Path": "com.facebook.samples.gestures.MultiPointerGestureDetector.startGesture",
	"Comment": "starts a new gesture and calls the listener just before starting it.",
	"Method": "void startGesture(){\r\n    if (!mGestureInProgress) {\r\n        if (mListener != null) {\r\n            mListener.onGestureBegin(this);\r\n        }\r\n        mGestureInProgress = true;\r\n    }\r\n}"
}, {
	"Path": "com.mcxiaoke.next.recycler.HeaderFooterRecyclerAdapter.notifyContentItemMoved",
	"Comment": "notifies that an existing content item is moved to another position.",
	"Method": "void notifyContentItemMoved(int fromPosition,int toPosition){\r\n    if (fromPosition < 0 || toPosition < 0 || fromPosition >= contentItemCount || toPosition >= contentItemCount) {\r\n        throw new IndexOutOfBoundsException(\"The given fromPosition \" + fromPosition + \" or toPosition \" + toPosition + \" is not within the position bounds for content items [0 - \" + (contentItemCount - 1) + \"].\");\r\n    }\r\n    notifyItemMoved(fromPosition + headerItemCount, toPosition + headerItemCount);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.LocalFilesDSProcessor.reset",
	"Comment": "resets the selection and configuration panel for this data sourceprocessor.",
	"Method": "void reset(){\r\n    configPanel.select();\r\n    localFilePaths = null;\r\n    setDataSourceOptionsCalled = false;\r\n}"
}, {
	"Path": "net.ypresto.androidtranscoder.engine.OutputSurface.release",
	"Comment": "discard all resources held by this class, notably the egl context.",
	"Method": "void release(){\r\n    if (mEGLDisplay != EGL14.EGL_NO_DISPLAY) {\r\n        EGL14.eglDestroySurface(mEGLDisplay, mEGLSurface);\r\n        EGL14.eglDestroyContext(mEGLDisplay, mEGLContext);\r\n        EGL14.eglReleaseThread();\r\n        EGL14.eglTerminate(mEGLDisplay);\r\n    }\r\n    mSurface.release();\r\n    mEGLDisplay = EGL14.EGL_NO_DISPLAY;\r\n    mEGLContext = EGL14.EGL_NO_CONTEXT;\r\n    mEGLSurface = EGL14.EGL_NO_SURFACE;\r\n    mTextureRender = null;\r\n    mSurface = null;\r\n    mSurfaceTexture = null;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.healthmonitor.HealthMonitor.databaseExists",
	"Comment": "check whether the health monitor database exists. does not check theschema.",
	"Method": "boolean databaseExists(){\r\n    try {\r\n        CaseDbConnectionInfo db = UserPreferences.getDatabaseConnectionInfo();\r\n        Class.forName(\"org.postgresql.Driver\");\r\n        ResultSet rs = null;\r\n        try (Connection connection = DriverManager.getConnection(\"jdbc:postgresql://\" + db.getHost() + \":\" + db.getPort() + \"/postgres\", db.getUserName(), db.getPassword());\r\n            Statement statement = connection.createStatement()) {\r\n            String createCommand = \"SELECT 1 AS result FROM pg_database WHERE datname='\" + DATABASE_NAME + \"'\";\r\n            rs = statement.executeQuery(createCommand);\r\n            if (rs.next()) {\r\n                return true;\r\n            }\r\n        } finally {\r\n            if (rs != null) {\r\n                rs.close();\r\n            }\r\n        }\r\n    } catch (UserPreferencesException | ClassNotFoundException | SQLException ex) {\r\n        throw new HealthMonitorException(\"Failed check for health monitor database\", ex);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.RegexQuery.postKeywordHitToBlackboard",
	"Comment": "posts a keyword hit artifact to the blackboard for a given keyword hit.",
	"Method": "BlackboardArtifact postKeywordHitToBlackboard(Content content,Keyword foundKeyword,KeywordHit hit,String snippet,String listName){\r\n    final String MODULE_NAME = KeywordSearchModuleFactory.getModuleName();\r\n    if (content == null) {\r\n        LOGGER.log(Level.WARNING, \"Error adding artifact for keyword hit to blackboard\");\r\n        return null;\r\n    }\r\n    if (originalKeyword.getArtifactAttributeType() == ATTRIBUTE_TYPE.TSK_CARD_NUMBER) {\r\n        createCCNAccount(content, foundKeyword, hit, snippet, listName);\r\n        return null;\r\n    }\r\n    BlackboardArtifact newArtifact;\r\n    Collection<BlackboardAttribute> attributes = new ArrayList();\r\n    attributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_KEYWORD, MODULE_NAME, foundKeyword.getSearchTerm()));\r\n    attributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_KEYWORD_REGEXP, MODULE_NAME, getQueryString()));\r\n    try {\r\n        newArtifact = content.newArtifact(ARTIFACT_TYPE.TSK_KEYWORD_HIT);\r\n    } catch (TskCoreException ex) {\r\n        LOGGER.log(Level.SEVERE, \"Error adding artifact for keyword hit to blackboard\", ex);\r\n        return null;\r\n    }\r\n    if (StringUtils.isNotBlank(listName)) {\r\n        attributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_SET_NAME, MODULE_NAME, listName));\r\n    }\r\n    if (snippet != null) {\r\n        attributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_KEYWORD_PREVIEW, MODULE_NAME, snippet));\r\n    }\r\n    hit.getArtifactID().ifPresent(artifactID -> attributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_ASSOCIATED_ARTIFACT, MODULE_NAME, artifactID)));\r\n    if (originalKeyword.searchTermIsLiteral()) {\r\n        attributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_KEYWORD_SEARCH_TYPE, MODULE_NAME, KeywordSearch.QueryType.SUBSTRING.ordinal()));\r\n    } else {\r\n        attributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_KEYWORD_SEARCH_TYPE, MODULE_NAME, KeywordSearch.QueryType.REGEX.ordinal()));\r\n    }\r\n    try {\r\n        newArtifact.addAttributes(attributes);\r\n        return newArtifact;\r\n    } catch (TskCoreException e) {\r\n        LOGGER.log(Level.SEVERE, \"Error adding bb attributes for terms search artifact\", e);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.datamodel.BlackboardArtifactNode.addEmailMsgProperty",
	"Comment": "fill map with emailmsg properties, not all attributes are filled",
	"Method": "void addEmailMsgProperty(Map<String, Object> map,BlackboardAttribute attribute){\r\n    final int attributeTypeID = attribute.getAttributeType().getTypeID();\r\n    if (attributeTypeID == ATTRIBUTE_TYPE.TSK_DATETIME_SENT.getTypeID() || attributeTypeID == ATTRIBUTE_TYPE.TSK_EMAIL_CONTENT_HTML.getTypeID() || attributeTypeID == ATTRIBUTE_TYPE.TSK_EMAIL_CONTENT_RTF.getTypeID() || attributeTypeID == ATTRIBUTE_TYPE.TSK_EMAIL_BCC.getTypeID() || attributeTypeID == ATTRIBUTE_TYPE.TSK_EMAIL_CC.getTypeID() || attributeTypeID == ATTRIBUTE_TYPE.TSK_HEADERS.getTypeID()) {\r\n    } else if (attributeTypeID == ATTRIBUTE_TYPE.TSK_EMAIL_CONTENT_PLAIN.getTypeID()) {\r\n        String value = attribute.getDisplayString();\r\n        if (value.length() > 160) {\r\n            value = value.substring(0, 160) + \"...\";\r\n        }\r\n        map.put(attribute.getAttributeType().getDisplayName(), value);\r\n    } else if (attribute.getAttributeType().getValueType() == BlackboardAttribute.TSK_BLACKBOARD_ATTRIBUTE_VALUE_TYPE.DATETIME) {\r\n        map.put(attribute.getAttributeType().getDisplayName(), ContentUtils.getStringTime(attribute.getValueLong(), associated));\r\n    } else {\r\n        map.put(attribute.getAttributeType().getDisplayName(), attribute.getDisplayString());\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.datamodel.AbstractContentNode.getContentChildrenCount",
	"Comment": "get count of the underlying content object children.useful for lazy loading.",
	"Method": "int getContentChildrenCount(){\r\n    int childrenCount = -1;\r\n    if (content != null) {\r\n        try {\r\n            childrenCount = content.getChildrenCount();\r\n        } catch (TskCoreException ex) {\r\n            logger.log(Level.SEVERE, \"Error checking node content children count, for content: \" + content, ex);\r\n        }\r\n    }\r\n    return childrenCount;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestServices.fireModuleDataEvent",
	"Comment": "fires an event to notify registered listeners that a new artifact hasbeen posted to the blackboard.",
	"Method": "void fireModuleDataEvent(ModuleDataEvent moduleDataEvent){\r\n    IngestManager.getInstance().fireIngestModuleDataEvent(moduleDataEvent);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.TableReportGenerator.writeKeywordHits",
	"Comment": "write the keyword hits to the provided tablereportmodules.",
	"Method": "void writeKeywordHits(TableReportModule tableModule,String comment,HashSet<String> tagNamesFilter){\r\n    String orderByClause;\r\n    Case openCase;\r\n    try {\r\n        openCase = Case.getCurrentCaseThrows();\r\n    } catch (NoCurrentCaseException ex) {\r\n        errorList.add(Bundle.ReportGenerator_errList_noOpenCase());\r\n        logger.log(Level.SEVERE, \"Exception while getting open case: \", ex);\r\n        return;\r\n    }\r\n    String tagIDList = \"\";\r\n    if (!tagNamesFilter.isEmpty()) {\r\n        try {\r\n            Map<String, TagName> tagNamesMap = Case.getCurrentCaseThrows().getServices().getTagsManager().getDisplayNamesToTagNamesMap();\r\n            for (String tagDisplayName : tagNamesFilter) {\r\n                if (tagNamesMap.containsKey(tagDisplayName)) {\r\n                    if (!tagIDList.isEmpty()) {\r\n                        tagIDList += \",\";\r\n                    }\r\n                    tagIDList += tagNamesMap.get(tagDisplayName).getId();\r\n                } else {\r\n                    if (tagDisplayName.endsWith(getNotableTagLabel())) {\r\n                        String editedDisplayName = tagDisplayName.substring(0, tagDisplayName.length() - getNotableTagLabel().length());\r\n                        if (tagNamesMap.containsKey(editedDisplayName)) {\r\n                            if (!tagIDList.isEmpty()) {\r\n                                tagIDList += \",\";\r\n                            }\r\n                            tagIDList += tagNamesMap.get(editedDisplayName).getId();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } catch (NoCurrentCaseException | TskCoreException ex) {\r\n            logger.log(Level.SEVERE, \"Exception while getting tag info - proceeding without tag filter: \", ex);\r\n            tagIDList = \"\";\r\n        }\r\n    }\r\n    // NON-NLS\r\n    String adHocCountQuery = \"SELECT COUNT(*) FROM \" + \"(SELECT art.artifact_id FROM blackboard_artifacts AS art, blackboard_attributes AS att1 \";\r\n    if (!tagIDList.isEmpty()) {\r\n        adHocCountQuery += \", blackboard_artifact_tags as tag \";\r\n    }\r\n    adHocCountQuery += \"WHERE (att1.artifact_id = art.artifact_id) AND (art.artifact_type_id = \" + BlackboardArtifact.ARTIFACT_TYPE.TSK_KEYWORD_HIT.getTypeID() + \") \";\r\n    if (!tagIDList.isEmpty()) {\r\n        adHocCountQuery += \" AND (art.artifact_id = tag.artifact_id) AND (tag.tag_name_id IN (\" + tagIDList + \")) \";\r\n    }\r\n    adHocCountQuery += \"EXCEPT \" + \"SELECT art.artifact_id FROM blackboard_artifacts AS art, blackboard_attributes AS att1 WHERE (att1.artifact_id = art.artifact_id) AND (art.artifact_type_id = \" + BlackboardArtifact.ARTIFACT_TYPE.TSK_KEYWORD_HIT.getTypeID() + \") AND (att1.attribute_type_id = \" + BlackboardAttribute.ATTRIBUTE_TYPE.TSK_SET_NAME.getTypeID() + \")) AS adHocHits\";\r\n    int adHocCount = 0;\r\n    try (SleuthkitCase.CaseDbQuery dbQuery = openCase.getSleuthkitCase().executeQuery(adHocCountQuery)) {\r\n        ResultSet adHocCountResultSet = dbQuery.getResultSet();\r\n        if (adHocCountResultSet.next()) {\r\n            adHocCount = adHocCountResultSet.getInt(1);\r\n        } else {\r\n            throw new TskCoreException(\"Error counting ad hoc keywords\");\r\n        }\r\n    } catch (TskCoreException | SQLException ex) {\r\n        errorList.add(NbBundle.getMessage(this.getClass(), \"ReportGenerator.errList.failedQueryKWLists\"));\r\n        logger.log(Level.SEVERE, \"Failed to count ad hoc searches with query \" + adHocCountQuery, ex);\r\n        return;\r\n    }\r\n    if (openCase.getCaseType() == Case.CaseType.MULTI_USER_CASE) {\r\n        orderByClause = \"ORDER BY convert_to(list, 'SQL_ASCII') ASC NULLS FIRST\";\r\n    } else {\r\n        orderByClause = \"ORDER BY list ASC\";\r\n    }\r\n    String keywordListQuery = \"SELECT att.value_text AS list \" + \"FROM blackboard_attributes AS att, blackboard_artifacts AS art \";\r\n    if (!tagIDList.isEmpty()) {\r\n        keywordListQuery += \", blackboard_artifact_tags as tag \";\r\n    }\r\n    keywordListQuery += \"WHERE att.attribute_type_id = \" + BlackboardAttribute.ATTRIBUTE_TYPE.TSK_SET_NAME.getTypeID() + \" \" + \"AND art.artifact_type_id = \" + BlackboardArtifact.ARTIFACT_TYPE.TSK_KEYWORD_HIT.getTypeID() + \" \" + \"AND att.artifact_id = art.artifact_id \";\r\n    if (!tagIDList.isEmpty()) {\r\n        keywordListQuery += \"AND (art.artifact_id = tag.artifact_id) \" + \"AND (tag.tag_name_id IN (\" + tagIDList + \")) \";\r\n    }\r\n    if (adHocCount > 0) {\r\n        keywordListQuery += \" UNION SELECT \\'\\' AS list \";\r\n    }\r\n    keywordListQuery = \"SELECT * FROM ( \" + keywordListQuery + \" ) kwListNames \";\r\n    keywordListQuery += \"GROUP BY list \" + orderByClause;\r\n    try (SleuthkitCase.CaseDbQuery dbQuery = openCase.getSleuthkitCase().executeQuery(keywordListQuery)) {\r\n        ResultSet listsRs = dbQuery.getResultSet();\r\n        List<String> lists = new ArrayList();\r\n        while (listsRs.next()) {\r\n            String list = listsRs.getString(\"list\");\r\n            if (list.isEmpty()) {\r\n                list = NbBundle.getMessage(this.getClass(), \"ReportGenerator.writeKwHits.userSrchs\");\r\n            }\r\n            lists.add(list);\r\n        }\r\n        tableModule.startDataType(BlackboardArtifact.ARTIFACT_TYPE.TSK_KEYWORD_HIT.getDisplayName(), comment);\r\n        tableModule.addSetIndex(lists);\r\n        progressPanel.updateStatusLabel(NbBundle.getMessage(this.getClass(), \"ReportGenerator.progress.processing\", BlackboardArtifact.ARTIFACT_TYPE.TSK_KEYWORD_HIT.getDisplayName()));\r\n    } catch (TskCoreException | SQLException ex) {\r\n        errorList.add(NbBundle.getMessage(this.getClass(), \"ReportGenerator.errList.failedQueryKWLists\"));\r\n        logger.log(Level.SEVERE, \"Failed to query keyword lists with query \" + keywordListQuery, ex);\r\n        return;\r\n    }\r\n    if (openCase.getCaseType() == Case.CaseType.MULTI_USER_CASE) {\r\n        orderByClause = \"ORDER BY convert_to(list, 'SQL_ASCII') ASC NULLS FIRST, \" + \"convert_to(keyword, 'SQL_ASCII') ASC NULLS FIRST, \" + \"convert_to(parent_path, 'SQL_ASCII') ASC NULLS FIRST, \" + \"convert_to(name, 'SQL_ASCII') ASC NULLS FIRST, \" + \"convert_to(preview, 'SQL_ASCII') ASC NULLS FIRST\";\r\n    } else {\r\n        orderByClause = \"ORDER BY list ASC, keyword ASC, parent_path ASC, name ASC, preview ASC\";\r\n    }\r\n    String keywordListsQuery = \"SELECT art.artifact_id AS artifact_id, art.obj_id AS obj_id, att1.value_text AS keyword, att2.value_text AS preview, att3.value_text AS list, f.name AS name, f.parent_path AS parent_path \" + \"FROM blackboard_artifacts AS art, blackboard_attributes AS att1, blackboard_attributes AS att2, blackboard_attributes AS att3, tsk_files AS f \" + \"WHERE (att1.artifact_id = art.artifact_id) \" + \"AND (att2.artifact_id = art.artifact_id) \" + \"AND (att3.artifact_id = art.artifact_id) \" + \"AND (f.obj_id = art.obj_id) \" + \"AND (att1.attribute_type_id = \" + BlackboardAttribute.ATTRIBUTE_TYPE.TSK_KEYWORD.getTypeID() + \") \" + \"AND (att2.attribute_type_id = \" + BlackboardAttribute.ATTRIBUTE_TYPE.TSK_KEYWORD_PREVIEW.getTypeID() + \") \" + \"AND (att3.attribute_type_id = \" + BlackboardAttribute.ATTRIBUTE_TYPE.TSK_SET_NAME.getTypeID() + \") \" + \"AND (art.artifact_type_id = \" + BlackboardArtifact.ARTIFACT_TYPE.TSK_KEYWORD_HIT.getTypeID() + \") \";\r\n    // NON-NLS\r\n    String keywordAdHocQuery = \"SELECT art.artifact_id AS artifact_id, art.obj_id AS obj_id, att1.value_text AS keyword, att2.value_text AS preview, \\'\\' AS list, f.name AS name, f.parent_path AS parent_path \" + \"FROM blackboard_artifacts AS art, blackboard_attributes AS att1, blackboard_attributes AS att2, tsk_files AS f \" + \"WHERE \" + \" (art.artifact_id IN (SELECT art.artifact_id FROM blackboard_artifacts AS art, blackboard_attributes AS att1 WHERE (att1.artifact_id = art.artifact_id) AND (art.artifact_type_id = \" + BlackboardArtifact.ARTIFACT_TYPE.TSK_KEYWORD_HIT.getTypeID() + \") \" + \"EXCEPT \" + \"SELECT art.artifact_id FROM blackboard_artifacts AS art, blackboard_attributes AS att1 WHERE (att1.artifact_id = art.artifact_id) AND (art.artifact_type_id = \" + BlackboardArtifact.ARTIFACT_TYPE.TSK_KEYWORD_HIT.getTypeID() + \") AND (att1.attribute_type_id = \" + BlackboardAttribute.ATTRIBUTE_TYPE.TSK_SET_NAME.getTypeID() + \"))) \" + \"AND (att1.artifact_id = art.artifact_id) \" + \"AND (att2.artifact_id = art.artifact_id) \" + \"AND (f.obj_id = art.obj_id) \" + \"AND (att1.attribute_type_id = \" + BlackboardAttribute.ATTRIBUTE_TYPE.TSK_KEYWORD.getTypeID() + \") \" + \"AND (att2.attribute_type_id = \" + BlackboardAttribute.ATTRIBUTE_TYPE.TSK_KEYWORD_PREVIEW.getTypeID() + \") \" + \"AND (art.artifact_type_id = \" + BlackboardArtifact.ARTIFACT_TYPE.TSK_KEYWORD_HIT.getTypeID() + \") \";\r\n    String keywordsQuery = \"SELECT * FROM ( \" + keywordListsQuery + \" UNION \" + keywordAdHocQuery + \" ) kwHits \" + orderByClause;\r\n    try (SleuthkitCase.CaseDbQuery dbQuery = openCase.getSleuthkitCase().executeQuery(keywordsQuery)) {\r\n        ResultSet resultSet = dbQuery.getResultSet();\r\n        String currentKeyword = \"\";\r\n        String currentList = \"\";\r\n        while (resultSet.next()) {\r\n            if (progressPanel.getStatus() == ReportProgressPanel.ReportStatus.CANCELED) {\r\n                break;\r\n            }\r\n            HashSet<String> uniqueTagNames = getUniqueTagNames(resultSet.getLong(\"artifact_id\"));\r\n            if (failsTagFilter(uniqueTagNames, tagNamesFilter)) {\r\n                continue;\r\n            }\r\n            String tagsList = makeCommaSeparatedList(uniqueTagNames);\r\n            Long objId = resultSet.getLong(\"obj_id\");\r\n            String keyword = resultSet.getString(\"keyword\");\r\n            String preview = resultSet.getString(\"preview\");\r\n            String list = resultSet.getString(\"list\");\r\n            String uniquePath = \"\";\r\n            try {\r\n                AbstractFile f = openCase.getSleuthkitCase().getAbstractFileById(objId);\r\n                if (f != null) {\r\n                    uniquePath = openCase.getSleuthkitCase().getAbstractFileById(objId).getUniquePath();\r\n                }\r\n            } catch (TskCoreException ex) {\r\n                errorList.add(NbBundle.getMessage(this.getClass(), \"ReportGenerator.errList.failedGetAbstractFileByID\"));\r\n                logger.log(Level.WARNING, \"Failed to get Abstract File by ID.\", ex);\r\n            }\r\n            if ((!list.equals(currentList) && !list.isEmpty()) || (list.isEmpty() && !currentList.equals(NbBundle.getMessage(this.getClass(), \"ReportGenerator.writeKwHits.userSrchs\")))) {\r\n                if (!currentList.isEmpty()) {\r\n                    tableModule.endTable();\r\n                    tableModule.endSet();\r\n                }\r\n                currentList = list.isEmpty() ? NbBundle.getMessage(this.getClass(), \"ReportGenerator.writeKwHits.userSrchs\") : list;\r\n                currentKeyword = \"\";\r\n                tableModule.startSet(currentList);\r\n                progressPanel.updateStatusLabel(NbBundle.getMessage(this.getClass(), \"ReportGenerator.progress.processingList\", BlackboardArtifact.ARTIFACT_TYPE.TSK_KEYWORD_HIT.getDisplayName(), currentList));\r\n            }\r\n            if (!keyword.equals(currentKeyword)) {\r\n                if (!currentKeyword.equals(\"\")) {\r\n                    tableModule.endTable();\r\n                }\r\n                currentKeyword = keyword;\r\n                tableModule.addSetElement(currentKeyword);\r\n                List<String> columnHeaderNames = new ArrayList();\r\n                columnHeaderNames.add(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.preview\"));\r\n                columnHeaderNames.add(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.srcFile\"));\r\n                columnHeaderNames.add(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.tags\"));\r\n                tableModule.startTable(columnHeaderNames);\r\n            }\r\n            tableModule.addRow(Arrays.asList(new String[] { preview, uniquePath, tagsList }));\r\n        }\r\n        if (!currentKeyword.isEmpty()) {\r\n            tableModule.endTable();\r\n        }\r\n        progressPanel.increment();\r\n        tableModule.endDataType();\r\n    } catch (TskCoreException | SQLException ex) {\r\n        errorList.add(NbBundle.getMessage(this.getClass(), \"ReportGenerator.errList.failedQueryKWs\"));\r\n        logger.log(Level.SEVERE, \"Failed to query keywords with query \" + keywordsQuery, ex);\r\n    }\r\n}"
}, {
	"Path": "com.aliyun.oss.model.UploadPartRequest.getPartNumber",
	"Comment": "gets the part number. for every part to upload, it has a number whoserange comes from 1 to 10000. for the given upload id, the part number isunique and uploading the data with an existing part number would lead tothe old data being overwritten.",
	"Method": "int getPartNumber(){\r\n    return partNumber;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.encryptiondetection.EncryptionDetectionTools.calculateEntropy",
	"Comment": "calculate the entropy of the content. the result is used to qualify thecontent as possibly encrypted.",
	"Method": "double calculateEntropy(Content content){\r\n    InputStream in = null;\r\n    BufferedInputStream bin = null;\r\n    try {\r\n        in = new ReadContentInputStream(content);\r\n        bin = new BufferedInputStream(in);\r\n        int[] byteOccurences = new int[BYTE_OCCURENCES_BUFFER_SIZE];\r\n        int readByte;\r\n        while ((readByte = bin.read()) != -1) {\r\n            byteOccurences[readByte]++;\r\n        }\r\n        long dataLength = content.getSize() - 1;\r\n        double entropyAccumulator = 0;\r\n        for (int i = 0; i < BYTE_OCCURENCES_BUFFER_SIZE; i++) {\r\n            if (byteOccurences[i] > 0) {\r\n                double byteProbability = (double) byteOccurences[i] / (double) dataLength;\r\n                entropyAccumulator += (byteProbability * Math.log(byteProbability) * ONE_OVER_LOG2);\r\n            }\r\n        }\r\n        return -entropyAccumulator;\r\n    } finally {\r\n        if (in != null) {\r\n            in.close();\r\n        }\r\n        if (bin != null) {\r\n            bin.close();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.datamodel.DrawableDB.isGroupSeenByExaminer",
	"Comment": "returns true if the specified group has been seen by the specifiedexaminer",
	"Method": "boolean isGroupSeenByExaminer(GroupKey<?> groupKey,long examinerId){\r\n    class GroupSeenQueryResultProcessor extends CompletableFuture<Boolean> implements CaseDbAccessQueryCallback {\r\n        @Override\r\n        public void process(ResultSet resultSet) {\r\n            try {\r\n                if (resultSet != null) {\r\n                    while (resultSet.next()) {\r\n                        complete(resultSet.getInt(\"count\") > 0);\r\n                        return;\r\n                    }\r\n                }\r\n            } catch (SQLException ex) {\r\n                logger.log(Level.SEVERE, \"Failed to get group seen\", ex);\r\n            }\r\n        }\r\n    }\r\n    GroupSeenQueryResultProcessor queryResultProcessor = new GroupSeenQueryResultProcessor();\r\n    try {\r\n        String groupSeenQueryStmt = \"COUNT(*) as count FROM \" + GROUPS_SEEN_TABLENAME + \" WHERE seen = 1 \" + \" AND group_id in ( \" + getGroupIdQuery(groupKey) + \")\" + (examinerId > 0 ? \" AND examiner_id = \" + examinerId : \"\");\r\n        tskCase.getCaseDbAccessManager().select(groupSeenQueryStmt, queryResultProcessor);\r\n        return queryResultProcessor.get();\r\n    } catch (ExecutionException | InterruptedException | TskCoreException ex) {\r\n        String msg = String.format(\"Failed to get is group seen for group key %s\", groupKey.getValueDisplayName());\r\n        logger.log(Level.WARNING, msg, ex);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.datamodel.DrawableDB.isGroupSeenByExaminer",
	"Comment": "returns true if the specified group has been seen by the specifiedexaminer",
	"Method": "boolean isGroupSeenByExaminer(GroupKey<?> groupKey,long examinerId){\r\n    try {\r\n        if (resultSet != null) {\r\n            while (resultSet.next()) {\r\n                complete(resultSet.getInt(\"count\") > 0);\r\n                return;\r\n            }\r\n        }\r\n    } catch (SQLException ex) {\r\n        logger.log(Level.SEVERE, \"Failed to get group seen\", ex);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.directorytree.ExtractUnallocAction.updateExportDirectory",
	"Comment": "update the default export directory. if the directory path matches thecase export directory, then the directory used will always match theexport directory of any given case. otherwise, the path last used will besaved.",
	"Method": "void updateExportDirectory(String exportPath,Case openCase){\r\n    if (exportPath.equalsIgnoreCase(openCase.getExportDirectory())) {\r\n        userDefinedExportPath = null;\r\n    } else {\r\n        userDefinedExportPath = exportPath;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.photoreccarver.PhotoRecCarverIngestJobSettingsPanel.customizeComponents",
	"Comment": "update components with values from the ingest job settings.",
	"Method": "void customizeComponents(PhotoRecCarverIngestJobSettings settings){\r\n    keepCorruptedFilesCheckbox.setSelected(settings.isKeepCorruptedFiles());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.SqliteEamDb.setAttributeInstanceKnownStatus",
	"Comment": "sets an eamartifact instance to the given knownstatus. knownstatus shouldbe bad if the file has been tagged with a notable tag and unknownotherwise. if eamartifact exists, it is updated. if eamartifact does notexist it is added with the given status.",
	"Method": "void setAttributeInstanceKnownStatus(CorrelationAttributeInstance eamArtifact,TskData.FileKnown knownStatus){\r\n    try {\r\n        acquireExclusiveLock();\r\n        super.setAttributeInstanceKnownStatus(eamArtifact, knownStatus);\r\n    } finally {\r\n        releaseExclusiveLock();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.ArchiveUtil.isExtractionSupportedByFileExtension",
	"Comment": "this method returns true if the file extension is currently supported.else it returns false. attempt extension based detection in case apachetika based detection fails.",
	"Method": "boolean isExtractionSupportedByFileExtension(String extension){\r\n    for (String supportedExtension : SUPPORTED_EXTENSIONS) {\r\n        if (extension.equals(supportedExtension)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.Case.getTextIndexName",
	"Comment": "gets the name of the legacy keyword search index for the case. not forgeneral use.",
	"Method": "String getTextIndexName(){\r\n    return getMetadata().getTextIndexName();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.Server.changeSolrStopPort",
	"Comment": "changes the current solr stop port. only call this after available.",
	"Method": "void changeSolrStopPort(int port){\r\n    currentSolrStopPort = port;\r\n    ModuleSettings.setConfigSetting(PROPERTIES_FILE, PROPERTIES_CURRENT_STOP_PORT, String.valueOf(port));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestPipelinesConfiguration.getStageOneDataSourceIngestPipelineConfig",
	"Comment": "gets the ordered list of ingest module factory class names for the fileingest pipeline.",
	"Method": "List<String> getStageOneDataSourceIngestPipelineConfig(){\r\n    return new ArrayList(stageOneDataSourceIngestPipelineConfig);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.datamodel.accounts.Accounts.setShowRejected",
	"Comment": "update the user interface to show or hide rejected artifacts.",
	"Method": "void setShowRejected(boolean showRejected){\r\n    this.showRejected = showRejected;\r\n    reviewStatusBus.post(new ReviewStatusChangeEvent(Collections.emptySet(), null));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.IngestSearchRunner.addKeywordListsToAllJobs",
	"Comment": "add these lists to all of the jobs. used when user wants to search for alist while ingest has already started.",
	"Method": "void addKeywordListsToAllJobs(List<String> keywordListNames){\r\n    for (String listName : keywordListNames) {\r\n        logger.log(Level.INFO, \"Adding keyword list {0} to all jobs\", listName);\r\n        for (SearchJobInfo j : jobs.values()) {\r\n            j.addKeywordListName(listName);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.aliyun.oss.integrationtests.RequestTimeoutTest.testMultiOssClientIndependent",
	"Comment": "multiple ossclient instances test.each instance should work independently without being impacted by other instances.so one timeout instance should not make other instances timeout.",
	"Method": "void testMultiOssClientIndependent(){\r\n    String key = \"test-multi-client-independent\";\r\n    try {\r\n        ClientBuilderConfiguration config = new ClientBuilderConfiguration();\r\n        config.setRequestTimeout(1);\r\n        config.setRequestTimeoutEnabled(true);\r\n        config.setMaxConnections(1);\r\n        OSS client = new OSSClientBuilder().build(endpoint, accessId, accessKey, config);\r\n        Thread[] threads = new Thread[10];\r\n        for (int i = 0; i < 10; i++) {\r\n            if (i % 2 == 0) {\r\n                threads[i] = new TimeoutOperationThread(client, key + i);\r\n            } else {\r\n                threads[i] = new OperationThread(key + i);\r\n            }\r\n        }\r\n        for (int i = 0; i < 10; i++) {\r\n            threads[i].start();\r\n        }\r\n        for (int i = 0; i < 10; i++) {\r\n            threads[i].join();\r\n        }\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n        Assert.fail(e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.AddImageTask.commitOrRevertAddImageProcess",
	"Comment": "commits or reverts the results of the tsk add image process. if theprocess was stopped before it completed or there was a critical error theresults are reverted, otherwise they are committed.",
	"Method": "void commitOrRevertAddImageProcess(Case currentCase,List<String> errorMessages,List<Content> newDataSources){\r\n    synchronized (tskAddImageProcessLock) {\r\n        if (tskAddImageProcessStopped || criticalErrorOccurred) {\r\n            try {\r\n                tskAddImageProcess.revert();\r\n            } catch (TskCoreException ex) {\r\n                logger.log(Level.SEVERE, String.format(\"Error reverting adding image %s to the case database\", imagePath), ex);\r\n                errorMessages.add(ex.getMessage());\r\n                criticalErrorOccurred = true;\r\n            }\r\n        } else {\r\n            try {\r\n                long imageId = tskAddImageProcess.commit();\r\n                if (imageId != 0) {\r\n                    Image newImage = currentCase.getSleuthkitCase().getImageById(imageId);\r\n                    String verificationError = newImage.verifyImageSize();\r\n                    if (!verificationError.isEmpty()) {\r\n                        errorMessages.add(verificationError);\r\n                    }\r\n                    if (imageWriterSettings != null) {\r\n                        ImageWriterService.createImageWriter(imageId, imageWriterSettings);\r\n                    }\r\n                    newDataSources.add(newImage);\r\n                } else {\r\n                    String errorMessage = String.format(\"Error commiting adding image %s to the case database, no object id returned\", imagePath);\r\n                    logger.log(Level.SEVERE, errorMessage);\r\n                    errorMessages.add(errorMessage);\r\n                    criticalErrorOccurred = true;\r\n                }\r\n            } catch (TskCoreException ex) {\r\n                logger.log(Level.SEVERE, String.format(\"Error committing adding image %s to the case database\", imagePath), ex);\r\n                errorMessages.add(ex.getMessage());\r\n                criticalErrorOccurred = true;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.TimeLineController.pushTimeUnit",
	"Comment": "change the view by setting a new time range that is the length oftimeunit and centered at the current center.",
	"Method": "boolean pushTimeUnit(TimeUnits timeUnit){\r\n    if (timeUnit == TimeUnits.FOREVER) {\r\n        return showFullRange();\r\n    } else {\r\n        return pushTimeRange(IntervalUtils.getIntervalAroundMiddle(filteredEvents.getTimeRange(), timeUnit.getPeriod()));\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestControlPanel.bnOptionsActionPerformed",
	"Comment": "handles a click on the options button. displays the options window.",
	"Method": "void bnOptionsActionPerformed(java.awt.event.ActionEvent evt){\r\n    setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\r\n    OptionsDisplayer.getDefault().open();\r\n    setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.ImageGalleryPreferences.isMultiUserCaseInfoDialogDisabled",
	"Comment": "return whether the dialog describing multi user case updating isdisabled.",
	"Method": "boolean isMultiUserCaseInfoDialogDisabled(){\r\n    final boolean aBoolean = preferences.getBoolean(MULTI_USER_CASE_INFO_DIALOG_DISABLED, false);\r\n    return aBoolean;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.configuration.AutoIngestUserPreferences.setAutoModeResultsFolder",
	"Comment": "set results folder for automated mode from persistent storage.",
	"Method": "void setAutoModeResultsFolder(String folder){\r\n    ModuleSettings.setConfigSetting(UserPreferences.SETTINGS_PROPERTIES, AUTO_MODE_RESULTS_FOLDER, folder);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.interestingitems.FilesSet.fileIsMemberOf",
	"Comment": "determines whether a file is a member of this interesting files set.",
	"Method": "String fileIsMemberOf(AbstractFile file){\r\n    if ((this.ignoreKnownFiles) && (file.getKnown() == TskData.FileKnown.KNOWN)) {\r\n        return null;\r\n    }\r\n    if ((this.ignoreUnallocatedSpace) && (file.getType().equals(TskData.TSK_DB_FILES_TYPE_ENUM.UNALLOC_BLOCKS) || file.getType().equals(TskData.TSK_DB_FILES_TYPE_ENUM.SLACK) || file.getType().equals(TskData.TSK_DB_FILES_TYPE_ENUM.UNUSED_BLOCKS))) {\r\n        return null;\r\n    }\r\n    for (Rule rule : rules.values()) {\r\n        if (rule.isSatisfied(file)) {\r\n            return rule.getName();\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.interestingitems.FilesIdentifierIngestJobSettings.getNamesOfDisabledInterestingFilesSets",
	"Comment": "get the names of all explicitly disabled interesting files setdefinitions.",
	"Method": "List<String> getNamesOfDisabledInterestingFilesSets(){\r\n    return new ArrayList(disabledFilesSetNames);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJobLogger.logCrashRecoveryNoRetry",
	"Comment": "logs discovery of a crashed auto ingest job for which recovery will notbe attempted because the retry limit for the job has been reached.",
	"Method": "void logCrashRecoveryNoRetry(){\r\n    log(MessageCategory.ERROR, \"Detected crash while processing, reached retry limit for processing\");\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.stix.EvalFileObj.listSecondaryFields",
	"Comment": "create a list of secondary fields. these are the ones that we only teston the matches for the primary fields.",
	"Method": "String listSecondaryFields(){\r\n    String secondaryFields = \"\";\r\n    if (obj.isIsMasqueraded() != null) {\r\n        secondaryFields += \"is_masqueraded \";\r\n    }\r\n    if (obj.getFileFormat() != null) {\r\n        secondaryFields += \"File_Format \";\r\n    }\r\n    return secondaryFields;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.configuration.AutoIngestUserPreferences.getSharedConfigFolder",
	"Comment": "get shared config folder for automated mode from persistent storage.",
	"Method": "String getSharedConfigFolder(){\r\n    return getPreferenceValue(SHARED_CONFIG_FOLDER);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.DataSourceIngestJob.getCurrentDataSourceIngestModule",
	"Comment": "gets the currently running data source level ingest module for this job.",
	"Method": "DataSourceIngestPipeline.PipelineModule getCurrentDataSourceIngestModule(){\r\n    if (null != this.currentDataSourceIngestPipeline) {\r\n        return this.currentDataSourceIngestPipeline.getCurrentlyRunningModule();\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJobCompletedEvent.shouldRetry",
	"Comment": "queries whether or not the job actually completed or needs to beattempted again.",
	"Method": "boolean shouldRetry(){\r\n    return this.retry;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.volatilityDSP.MemoryDSInputPanel.createTimeZoneList",
	"Comment": "creates the drop down list for the time zones and then makes the localmachine time zone to be selected.",
	"Method": "void createTimeZoneList(){\r\n    List<String> timeZoneList = TimeZoneUtils.createTimeZoneList();\r\n    for (String timeZone : timeZoneList) {\r\n        timeZoneComboBox.addItem(timeZone);\r\n    }\r\n    timeZoneComboBox.setSelectedItem(TimeZoneUtils.createTimeZoneString(Calendar.getInstance().getTimeZone()));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.ImageGalleryModule.getController",
	"Comment": "gets the per case image gallery controller for the current case. thecontroller is changed in the case event listener.",
	"Method": "ImageGalleryController getController(){\r\n    synchronized (controllerLock) {\r\n        if (controller == null) {\r\n            try {\r\n                Case currentCase = Case.getCurrentCaseThrows();\r\n                controller = new ImageGalleryController(currentCase);\r\n            } catch (NoCurrentCaseException ex) {\r\n                throw new TskCoreException(\"Failed to get \", ex);\r\n            }\r\n        }\r\n        return controller;\r\n    }\r\n}"
}, {
	"Path": "com.aliyun.oss.model.UploadPartRequest.setPartNumber",
	"Comment": "sets the part number. for every part to upload, it has a number whoserange comes from 1 to 10000. for the given upload id, the part number isunique and uploading the data with an existing part number would lead tothe old data being overwritten.",
	"Method": "void setPartNumber(int partNumber){\r\n    this.partNumber = partNumber;\r\n}"
}, {
	"Path": "net.dongliu.apk.parser.utils.ParseUtils.readStringPool",
	"Comment": "read string pool, for apk binary xml file and resource table.",
	"Method": "StringPool readStringPool(ByteBuffer buffer,StringPoolHeader stringPoolHeader){\r\n    long beginPos = buffer.position();\r\n    int[] offsets = new int[stringPoolHeader.getStringCount()];\r\n    if (stringPoolHeader.getStringCount() > 0) {\r\n        for (int idx = 0; idx < stringPoolHeader.getStringCount(); idx++) {\r\n            offsets[idx] = Unsigned.toUInt(Buffers.readUInt(buffer));\r\n        }\r\n    }\r\n    boolean sorted = (stringPoolHeader.getFlags() & StringPoolHeader.SORTED_FLAG) != 0;\r\n    boolean utf8 = (stringPoolHeader.getFlags() & StringPoolHeader.UTF8_FLAG) != 0;\r\n    long stringPos = beginPos + stringPoolHeader.getStringsStart() - stringPoolHeader.getHeaderSize();\r\n    Buffers.position(buffer, stringPos);\r\n    StringPoolEntry[] entries = new StringPoolEntry[offsets.length];\r\n    for (int i = 0; i < offsets.length; i++) {\r\n        entries[i] = new StringPoolEntry(i, stringPos + Unsigned.toLong(offsets[i]));\r\n    }\r\n    String lastStr = null;\r\n    long lastOffset = -1;\r\n    StringPool stringPool = new StringPool(stringPoolHeader.getStringCount());\r\n    for (StringPoolEntry entry : entries) {\r\n        if (entry.getOffset() == lastOffset) {\r\n            stringPool.set(entry.getIdx(), lastStr);\r\n            continue;\r\n        }\r\n        Buffers.position(buffer, entry.getOffset());\r\n        lastOffset = entry.getOffset();\r\n        String str = ParseUtils.readString(buffer, utf8);\r\n        lastStr = str;\r\n        stringPool.set(entry.getIdx(), str);\r\n    }\r\n    if (stringPoolHeader.getStyleCount() > 0) {\r\n    }\r\n    Buffers.position(buffer, beginPos + stringPoolHeader.getBodySize());\r\n    return stringPool;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.SQLiteTableReader.ensureOpen",
	"Comment": "ensures that the underlying database connection is open. this entailscopying the abstract file contents to temp directory, copying over anywal or shm files and getting the connection from the drivermanager.",
	"Method": "void ensureOpen(){\r\n    if (Objects.isNull(conn)) {\r\n        try {\r\n            Class.forName(\"org.sqlite.JDBC\");\r\n            String localDiskPath = copyFileToTempDirectory(file, file.getId());\r\n            findAndCopySQLiteMetaFile(file, file.getName() + \"-wal\");\r\n            findAndCopySQLiteMetaFile(file, file.getName() + \"-shm\");\r\n            conn = DriverManager.getConnection(\"jdbc:sqlite:\" + localDiskPath);\r\n        } catch (NoCurrentCaseException | TskCoreException | IOException | ClassNotFoundException | SQLException ex) {\r\n            throw new SQLiteTableReaderException(ex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.DataSourceIngestJob.hasSecondStageDataSourceIngestPipeline",
	"Comment": "checks to see if this job has a second stage data source level ingestpipeline.",
	"Method": "boolean hasSecondStageDataSourceIngestPipeline(){\r\n    return (this.secondStageDataSourceIngestPipeline.isEmpty() == false);\r\n}"
}, {
	"Path": "com.douban.frodo.baseproject.adapter.ArrayAdapterCompat2.sort",
	"Comment": "sorts the content of this adapter using the specified comparator.",
	"Method": "void sort(Comparator<? super T> comparator){\r\n    synchronized (mLock) {\r\n        if (mOriginalValues != null) {\r\n            Collections.sort(mOriginalValues, comparator);\r\n        } else {\r\n            Collections.sort(mObjects, comparator);\r\n        }\r\n    }\r\n    if (mNotifyOnChange)\r\n        notifyDataSetChanged();\r\n}"
}, {
	"Path": "org.wikipedia.util.ReleaseUtil.getChannel",
	"Comment": "gets the distribution channel for the app from sharedpreferences",
	"Method": "String getChannel(Context ctx){\r\n    String channel = Prefs.getAppChannel();\r\n    if (channel == null) {\r\n        channel = getChannelFromManifest(ctx);\r\n        Prefs.setAppChannel(channel);\r\n    }\r\n    return channel;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.KeywordSearchOptionsPanelController.cancel",
	"Comment": "this method is called when the cancel button is pressed. it applies toany of the panels that have been opened in the process of using theoptions pane.",
	"Method": "void cancel(){\r\n    getPanel().cancel();\r\n}"
}, {
	"Path": "com.anysoftkeyboard.dictionaries.WordComposer.getTypedWord",
	"Comment": "returns the word as it was typed, without any correction applied.",
	"Method": "CharSequence getTypedWord(){\r\n    int wordSize = mCodes.size();\r\n    if (wordSize == 0) {\r\n        return \"\";\r\n    }\r\n    return mTypedWord;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.DropdownSingleTermSearchPanel.setComponentsEnabled",
	"Comment": "set the datasourcelist enabled if the datasourcecheckbox is selected",
	"Method": "void setComponentsEnabled(){\r\n    if (getDataSourceListModel().size() > 1) {\r\n        this.dataSourceCheckBox.setEnabled(true);\r\n        boolean enabled = this.dataSourceCheckBox.isSelected();\r\n        this.dataSourceList.setEnabled(enabled);\r\n        if (enabled) {\r\n            this.dataSourceList.setSelectionInterval(0, this.dataSourceList.getModel().getSize() - 1);\r\n        } else {\r\n            this.dataSourceList.setSelectedIndices(new int[0]);\r\n        }\r\n    } else {\r\n        this.dataSourceCheckBox.setEnabled(false);\r\n        this.dataSourceCheckBox.setSelected(false);\r\n        this.dataSourceList.setEnabled(false);\r\n        this.dataSourceList.setSelectedIndices(new int[0]);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.DataSourceIngestJob.finish",
	"Comment": "shuts down the ingest pipelines and progress bars for this job.",
	"Method": "void finish(){\r\n    logger.log(Level.INFO, \"Finished analysis for {0} (jobId={1})\", new Object[] { dataSource.getName(), this.id });\r\n    this.stage = DataSourceIngestJob.Stages.FINALIZATION;\r\n    if (this.doUI) {\r\n        synchronized (this.dataSourceIngestProgressLock) {\r\n            if (this.dataSourceIngestProgress != null) {\r\n                this.dataSourceIngestProgress.finish();\r\n                this.dataSourceIngestProgress = null;\r\n            }\r\n        }\r\n    }\r\n    if (ingestJob != null) {\r\n        if (this.cancelled) {\r\n            try {\r\n                ingestJob.setIngestJobStatus(IngestJobStatusType.CANCELLED);\r\n            } catch (TskCoreException ex) {\r\n                logger.log(Level.SEVERE, \"Failed to set ingest status for ingest job in database.\", ex);\r\n            }\r\n        } else {\r\n            try {\r\n                ingestJob.setIngestJobStatus(IngestJobStatusType.COMPLETED);\r\n            } catch (TskCoreException ex) {\r\n                logger.log(Level.SEVERE, \"Failed to set ingest status for ingest job in database.\", ex);\r\n            }\r\n        }\r\n        try {\r\n            this.ingestJob.setEndDateTime(new Date());\r\n        } catch (TskCoreException ex) {\r\n            logger.log(Level.SEVERE, \"Failed to set end date for ingest job in database.\", ex);\r\n        }\r\n    }\r\n    this.parentJob.dataSourceJobFinished(this);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.DropdownToolbar.customizeComponents",
	"Comment": "does additional initialization of the gui components created by theinitcomponents method.",
	"Method": "void customizeComponents(){\r\n    searchSettingsChangeListener = new SearchSettingsChangeListener();\r\n    KeywordSearch.getServer().addServerActionListener(searchSettingsChangeListener);\r\n    Case.addEventTypeSubscriber(EnumSet.of(Case.Events.CURRENT_CASE, Case.Events.DATA_SOURCE_ADDED), searchSettingsChangeListener);\r\n    listsPanel = DropdownListSearchPanel.getDefault();\r\n    listsPanel.addSearchButtonActionListener((ActionEvent e) -> {\r\n        listsMenu.setVisible(false);\r\n    });\r\n    listsPanel.addPropertyChangeListener(searchSettingsChangeListener);\r\n    listsMenu.setSize(listsPanel.getPreferredSize().width + 6, listsPanel.getPreferredSize().height + 6);\r\n    listsMenu.add(listsPanel);\r\n    listsMenu.addPopupMenuListener(new PopupMenuListener() {\r\n        @Override\r\n        public void popupMenuWillBecomeVisible(PopupMenuEvent e) {\r\n            listsButton.setSelected(true);\r\n        }\r\n        @Override\r\n        public void popupMenuWillBecomeInvisible(PopupMenuEvent e) {\r\n            listsButton.setSelected(false);\r\n        }\r\n        @Override\r\n        public void popupMenuCanceled(PopupMenuEvent e) {\r\n            listsButton.setSelected(false);\r\n        }\r\n    });\r\n    dropPanel = DropdownSingleTermSearchPanel.getDefault();\r\n    dropPanel.addPropertyChangeListener(searchSettingsChangeListener);\r\n    dropPanel.addSearchButtonActionListener(new ActionListener() {\r\n        @Override\r\n        public void actionPerformed(ActionEvent e) {\r\n            searchMenu.setVisible(false);\r\n        }\r\n    });\r\n    searchMenu.setSize(dropPanel.getPreferredSize().width + 6, dropPanel.getPreferredSize().height + 6);\r\n    searchMenu.add(dropPanel);\r\n    searchMenu.addPopupMenuListener(new PopupMenuListener() {\r\n        @Override\r\n        public void popupMenuWillBecomeVisible(PopupMenuEvent e) {\r\n            searchDropButton.setSelected(true);\r\n        }\r\n        @Override\r\n        public void popupMenuWillBecomeInvisible(PopupMenuEvent e) {\r\n            searchDropButton.setSelected(false);\r\n        }\r\n        @Override\r\n        public void popupMenuCanceled(PopupMenuEvent e) {\r\n            searchDropButton.setSelected(false);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.DropdownToolbar.customizeComponents",
	"Comment": "does additional initialization of the gui components created by theinitcomponents method.",
	"Method": "void customizeComponents(){\r\n    listsButton.setSelected(true);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.DropdownToolbar.customizeComponents",
	"Comment": "does additional initialization of the gui components created by theinitcomponents method.",
	"Method": "void customizeComponents(){\r\n    listsButton.setSelected(false);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.DropdownToolbar.customizeComponents",
	"Comment": "does additional initialization of the gui components created by theinitcomponents method.",
	"Method": "void customizeComponents(){\r\n    listsButton.setSelected(false);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.DropdownToolbar.customizeComponents",
	"Comment": "does additional initialization of the gui components created by theinitcomponents method.",
	"Method": "void customizeComponents(){\r\n    searchMenu.setVisible(false);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.DropdownToolbar.customizeComponents",
	"Comment": "does additional initialization of the gui components created by theinitcomponents method.",
	"Method": "void customizeComponents(){\r\n    searchDropButton.setSelected(true);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.DropdownToolbar.customizeComponents",
	"Comment": "does additional initialization of the gui components created by theinitcomponents method.",
	"Method": "void customizeComponents(){\r\n    searchDropButton.setSelected(false);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.DropdownToolbar.customizeComponents",
	"Comment": "does additional initialization of the gui components created by theinitcomponents method.",
	"Method": "void customizeComponents(){\r\n    searchDropButton.setSelected(false);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.AbstractSqlEamDb.getReferenceInstancesByTypeValue",
	"Comment": "get all reference entries having a given correlation type and value",
	"Method": "List<EamGlobalFileInstance> getReferenceInstancesByTypeValue(CorrelationAttributeInstance.Type aType,String aValue){\r\n    String normalizeValued = CorrelationAttributeNormalizer.normalize(aType, aValue);\r\n    Connection conn = connect();\r\n    List<EamGlobalFileInstance> globalFileInstances = new ArrayList();\r\n    PreparedStatement preparedStatement1 = null;\r\n    ResultSet resultSet = null;\r\n    String sql1 = \"SELECT * FROM %s WHERE value=?\";\r\n    try {\r\n        preparedStatement1 = conn.prepareStatement(String.format(sql1, EamDbUtil.correlationTypeToReferenceTableName(aType)));\r\n        preparedStatement1.setString(1, normalizeValued);\r\n        resultSet = preparedStatement1.executeQuery();\r\n        while (resultSet.next()) {\r\n            globalFileInstances.add(getEamGlobalFileInstanceFromResultSet(resultSet));\r\n        }\r\n    } catch (SQLException ex) {\r\n        throw new EamDbException(\"Error getting reference instances by type and value.\", ex);\r\n    } finally {\r\n        EamDbUtil.closeStatement(preparedStatement1);\r\n        EamDbUtil.closeResultSet(resultSet);\r\n        EamDbUtil.closeConnection(conn);\r\n    }\r\n    return globalFileInstances;\r\n}"
}, {
	"Path": "com.mcxiaoke.next.recycler.HeaderFooterRecyclerAdapter.notifyHeaderItemMoved",
	"Comment": "notifies that an existing header item is moved to another position.",
	"Method": "void notifyHeaderItemMoved(int fromPosition,int toPosition){\r\n    if (fromPosition < 0 || toPosition < 0 || fromPosition >= headerItemCount || toPosition >= headerItemCount) {\r\n        throw new IndexOutOfBoundsException(\"The given fromPosition \" + fromPosition + \" or toPosition \" + toPosition + \" is not within the position bounds for header items [0 - \" + (headerItemCount - 1) + \"].\");\r\n    }\r\n    notifyItemMoved(fromPosition, toPosition);\r\n}"
}, {
	"Path": "org.ffmpeg.android.FfmpegController.copyRawFile",
	"Comment": "copies a raw resource file, given its id to the given location",
	"Method": "void copyRawFile(Context ctx,int resid,File file,String mode){\r\n    final String abspath = file.getAbsolutePath();\r\n    final FileOutputStream out = new FileOutputStream(file);\r\n    final InputStream is = ctx.getResources().openRawResource(resid);\r\n    byte[] buf = new byte[1024];\r\n    int len;\r\n    while ((len = is.read(buf)) > 0) {\r\n        out.write(buf, 0, len);\r\n    }\r\n    out.close();\r\n    is.close();\r\n    Runtime.getRuntime().exec(\"chmod \" + mode + \" \" + abspath).waitFor();\r\n}"
}, {
	"Path": "com.mcxiaoke.next.ui.endless.EndlessAdapter.getCount",
	"Comment": "how many items are in the data set represented by thisadapter.",
	"Method": "int getCount(){\r\n    if (isFooterShowing()) {\r\n        return super.getCount() + 1;\r\n    }\r\n    return (super.getCount());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.Server.stop",
	"Comment": "tries to stop the local solr instance.waits for the stop command to finish before returning.",
	"Method": "void stop(){\r\n    try {\r\n        closeCore();\r\n    } catch (KeywordSearchModuleException e) {\r\n        logger.log(Level.WARNING, \"Failed to close core: \", e);\r\n    }\r\n    try {\r\n        logger.log(Level.INFO, \"Stopping Solr server from: {0}\", solrFolder.getAbsolutePath());\r\n        Process process = runSolrCommand(new ArrayList(Arrays.asList(\"--stop\")));\r\n        logger.log(Level.INFO, \"Waiting for Solr server to stop\");\r\n        process.waitFor();\r\n        if (curSolrProcess != null) {\r\n            curSolrProcess.destroy();\r\n            curSolrProcess = null;\r\n        }\r\n    } catch (IOException | InterruptedException ex) {\r\n        logger.log(Level.WARNING, \"Error while attempting to stop Solr server\", ex);\r\n    } finally {\r\n        try {\r\n            if (errorRedirectThread != null) {\r\n                errorRedirectThread.stopRun();\r\n                errorRedirectThread = null;\r\n            }\r\n        } finally {\r\n            killSolr();\r\n        }\r\n        logger.log(Level.INFO, \"Finished stopping Solr server\");\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.PromptDialogManager.setDialogIcons",
	"Comment": "set the title bar icon for the given dialog to be the autopsy logo icon.",
	"Method": "void setDialogIcons(Dialog<?> dialog){\r\n    ((Stage) dialog.getDialogPane().getScene().getWindow()).getIcons().setAll(AUTOPSY_ICON);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.test.CustomArtifactsCreatorFileIngestModule.process",
	"Comment": "creates a custom artifact instance associated with the file to beprocessed.",
	"Method": "ProcessResult process(AbstractFile file){\r\n    if (file.isDir() || file.isVirtual()) {\r\n        return ProcessResult.OK;\r\n    }\r\n    try {\r\n        CustomArtifactType.createInstance(file);\r\n    } catch (TskCoreException ex) {\r\n        logger.log(Level.SEVERE, String.format(\"Failed to process file (obj_id = %d)\", file.getId()), ex);\r\n        return ProcessResult.ERROR;\r\n    }\r\n    return ProcessResult.OK;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.db.SQLHelper.getSQLWhere",
	"Comment": "generate a sql where clause for the given type filter, while trying to beas simple as possible to improve performance.",
	"Method": "String getSQLWhere(IntersectionFilter<?> filter,String getSQLWhere,UnionFilter<?> filter,String getSQLWhere,RootFilter filter,String getSQLWhere,Filter filter,String getSQLWhere,HideKnownFilter filter,String getSQLWhere,DescriptionFilter filter,String getSQLWhere,TagsFilter filter,String getSQLWhere,HashHitsFilter filter,String getSQLWhere,DataSourceFilter filter,String getSQLWhere,DataSourcesFilter filter,String getSQLWhere,TextFilter filter,String getSQLWhere,TypeFilter typeFilter){\r\n    if (typeFilter.isSelected() == false) {\r\n        return \"0\";\r\n    } else if (typeFilter.getEventType() instanceof RootEventType) {\r\n        if (typeFilter.getSubFilters().stream().allMatch(subFilter -> subFilter.isActive() && subFilter.getSubFilters().stream().allMatch(Filter::isActive))) {\r\n            return \"1\";\r\n        }\r\n    }\r\n    return \"(sub_type IN (\" + StringUtils.join(getActiveSubTypes(typeFilter), \",\") + \"))\";\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.MultiUserSettingsPanel.databaseFieldsArePopulated",
	"Comment": "tests whether or not values have been entered in all of the databasesettings text fields.",
	"Method": "boolean databaseFieldsArePopulated(){\r\n    return !tbDbHostname.getText().trim().isEmpty() && !tbDbPort.getText().trim().isEmpty() && !tbDbUsername.getText().trim().isEmpty() && tbDbPassword.getPassword().length != 0;\r\n}"
}, {
	"Path": "org.owntracks.android.ui.preferences.PreferencesFragment.setContentView",
	"Comment": "use this method to inflate the content view for your fragment. this method also handlescreating the binding, setting the view model on the binding and attaching the view.",
	"Method": "void setContentView(Bundle savedInstanceState){\r\n    if (viewModel == null) {\r\n        throw new IllegalStateException(\"viewModel must not be null and should be injected via fragmentComponent().inject(this)\");\r\n    }\r\n    viewModel.attachView(this, savedInstanceState);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.DataSourceIngestJob.currentDataSourceIngestModuleIsCancelled",
	"Comment": "queries whether or not a temporary cancellation of data source levelingest in order to stop the currently executing data source level ingestmodule is in effect for this job.",
	"Method": "boolean currentDataSourceIngestModuleIsCancelled(){\r\n    return this.currentDataSourceIngestModuleCancelled;\r\n}"
}, {
	"Path": "model.Complex.cos",
	"Comment": "return a new complex object whose value is the complex cosine of this",
	"Method": "Complex cos(){\r\n    return new Complex(Math.cos(re) * Math.cosh(im), -Math.sin(re) * Math.sinh(im));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.AutopsyOptionsPanel.writeEtcConfFile",
	"Comment": "take the conf file in the install directory and save a copy of it to theuser directory. the copy will be modified to include the current memorysetting.",
	"Method": "void writeEtcConfFile(){\r\n    StringBuilder content = new StringBuilder();\r\n    List<String> confFile = readConfFile(getInstallFolderConfFile());\r\n    for (String line : confFile) {\r\n        if (line.contains(\"-J-Xmx\")) {\r\n            String[] splitLine = line.split(\" \");\r\n            StringJoiner modifiedLine = new StringJoiner(\" \");\r\n            for (String piece : splitLine) {\r\n                if (piece.contains(\"-J-Xmx\")) {\r\n                    piece = \"-J-Xmx\" + memField.getText() + \"g\";\r\n                }\r\n                modifiedLine.add(piece);\r\n            }\r\n            content.append(modifiedLine.toString());\r\n        } else {\r\n            content.append(line);\r\n        }\r\n        content.append(\"\\n\");\r\n    }\r\n    Files.write(getUserFolderConfFile().toPath(), content.toString().getBytes());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJob.getPriority",
	"Comment": "gets the priority of the job. a higher number indicates a higherpriority.",
	"Method": "Integer getPriority(){\r\n    return this.priority;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.datamodel.ContentUtils.shouldDisplayTimesInLocalTime",
	"Comment": "indicates whether or not times should be displayed using local time.",
	"Method": "boolean shouldDisplayTimesInLocalTime(){\r\n    return displayTimesInLocalTime;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.interestingitems.FilesSetRulePanel.populatePathConditionComponents",
	"Comment": "populates the ui components that display the optional path condition fora rule.",
	"Method": "void populatePathConditionComponents(FilesSet.Rule rule){\r\n    FilesSet.Rule.ParentPathCondition pathCondition = rule.getPathCondition();\r\n    if (pathCondition != null) {\r\n        this.pathCheck.setSelected(true);\r\n        this.pathCheckActionPerformed(null);\r\n        this.pathTextField.setText(pathCondition.getTextToMatch());\r\n        this.pathRegexCheckBox.setSelected(pathCondition.isRegex());\r\n    }\r\n}"
}, {
	"Path": "com.stealthcopter.networktools.SubnetDevices.fromLocalAddress",
	"Comment": "find devices on the subnet working from the local device ip address",
	"Method": "SubnetDevices fromLocalAddress(){\r\n    InetAddress ipv4 = IPTools.getLocalIPv4Address();\r\n    if (ipv4 == null) {\r\n        throw new IllegalAccessError(\"Could not access local ip address\");\r\n    }\r\n    return fromIPAddress(ipv4.getHostAddress());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.KeywordSearchSettings.setDefaults",
	"Comment": "sets the default values of the keywordsearch properties files if nonealready exist.",
	"Method": "void setDefaults(){\r\n    logger.log(Level.INFO, \"Detecting default settings.\");\r\n    if (!ModuleSettings.settingExists(KeywordSearchSettings.PROPERTIES_NSRL, \"SkipKnown\")) {\r\n        logger.log(Level.INFO, \"No configuration for NSRL found, generating default...\");\r\n        KeywordSearchSettings.setSkipKnown(true);\r\n    }\r\n    if (!ModuleSettings.settingExists(KeywordSearchSettings.PROPERTIES_OPTIONS, \"UpdateFrequency\")) {\r\n        logger.log(Level.INFO, \"No configuration for Update Frequency found, generating default...\");\r\n        KeywordSearchSettings.setUpdateFrequency(UpdateFrequency.DEFAULT);\r\n    }\r\n    if (!ModuleSettings.settingExists(KeywordSearchSettings.PROPERTIES_OPTIONS, StringsTextExtractor.ExtractOptions.EXTRACT_UTF8.toString())) {\r\n        logger.log(Level.INFO, \"No configuration for UTF8 found, generating default...\");\r\n        KeywordSearchSettings.setStringExtractOption(StringsTextExtractor.ExtractOptions.EXTRACT_UTF8.toString(), Boolean.TRUE.toString());\r\n    }\r\n    if (!ModuleSettings.settingExists(KeywordSearchSettings.PROPERTIES_OPTIONS, StringsTextExtractor.ExtractOptions.EXTRACT_UTF16.toString())) {\r\n        logger.log(Level.INFO, \"No configuration for UTF16 found, generating defaults...\");\r\n        KeywordSearchSettings.setStringExtractOption(StringsTextExtractor.ExtractOptions.EXTRACT_UTF16.toString(), Boolean.TRUE.toString());\r\n    }\r\n    if (!ModuleSettings.settingExists(KeywordSearchSettings.PROPERTIES_OPTIONS, OCR_ENABLED)) {\r\n        logger.log(Level.INFO, \"No configuration for OCR found, generating defaults...\");\r\n        KeywordSearchSettings.setOcrOption(OCR_ENABLED_DEFAULT);\r\n    }\r\n    if (!ModuleSettings.settingExists(KeywordSearchSettings.PROPERTIES_SCRIPTS, SCRIPT.LATIN_1.name())) {\r\n        logger.log(Level.INFO, \"No configuration for Scripts found, generating defaults...\");\r\n        ModuleSettings.setConfigSetting(KeywordSearchSettings.PROPERTIES_SCRIPTS, SCRIPT.LATIN_1.name(), Boolean.toString(true));\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.runIngestModuleWizard.ShortcutWizardDescriptorPanel.panelEnablesSkipping",
	"Comment": "whether or not this panel under the correct conditions can enable theskipping of the panel after it.",
	"Method": "boolean panelEnablesSkipping(){\r\n    return false;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.ui.AbstractTimeLineView.setOutOfDate",
	"Comment": "set this view out of date because, for example, tags have been updatedbut the view was not refreshed.",
	"Method": "void setOutOfDate(){\r\n    outOfDate.set(true);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJobLogger.logFailedToParseLogicalReportDataSource",
	"Comment": "logs a failure to parse a cellebrite logical report data source.",
	"Method": "void logFailedToParseLogicalReportDataSource(){\r\n    log(MessageCategory.ERROR, \"Failed to parse Cellebrite logical report data source\");\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestManager.fireFileIngestDone",
	"Comment": "publishes an ingest module event signifying the ingest of a file wascompleted.",
	"Method": "void fireFileIngestDone(AbstractFile file){\r\n    AutopsyEvent event = new FileAnalyzedEvent(file);\r\n    eventPublishingExecutor.submit(new PublishEventTask(event, moduleEventPublisher));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.embeddedfileextractor.MSOfficeEmbeddedContentExtractor.getOutputFolderPath",
	"Comment": "gets path to the output folder for file extraction. if the path does notexist, it is created.",
	"Method": "String getOutputFolderPath(String parentFileName){\r\n    String outputFolderPath = moduleDirAbsolute + File.separator + parentFileName;\r\n    File outputFilePath = new File(outputFolderPath);\r\n    if (!outputFilePath.exists()) {\r\n        try {\r\n            outputFilePath.mkdirs();\r\n        } catch (SecurityException ex) {\r\n            LOGGER.log(Level.WARNING, NbBundle.getMessage(this.getClass(), \"EmbeddedFileExtractorIngestModule.ImageExtractor.getOutputFolderPath.exception.msg\", parentFileName), ex);\r\n            return null;\r\n        }\r\n    }\r\n    return outputFolderPath;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.embeddedfileextractor.SevenZipExtractor.getExtractableFilesFromDetailsMap",
	"Comment": "produce a list of archive indices needed for the call to extract, whichwill open the archive and begin unpacking the files.",
	"Method": "int[] getExtractableFilesFromDetailsMap(Map<Integer, InArchiveItemDetails> archiveDetailsMap){\r\n    Integer[] wrappedExtractionIndices = archiveDetailsMap.keySet().toArray(new Integer[archiveDetailsMap.size()]);\r\n    return Arrays.stream(wrappedExtractionIndices).mapToInt(Integer::intValue).toArray();\r\n}"
}, {
	"Path": "com.google.example.games.catt2.MainActivity.getScreenShot",
	"Comment": "gets a screenshot to use with snapshots. note that in practice you probably do not want touse this approach because tablet screen sizes can become pretty large and because the imagewill contain any ui and layout surrounding the area of interest.",
	"Method": "Bitmap getScreenShot(){\r\n    View root = findViewById(R.id.screen_main);\r\n    Bitmap coverImage;\r\n    try {\r\n        root.setDrawingCacheEnabled(true);\r\n        Bitmap base = root.getDrawingCache();\r\n        coverImage = base.copy(base.getConfig(), false);\r\n    } catch (Exception ex) {\r\n        Log.i(TAG, \"Failed to create screenshot\", ex);\r\n        coverImage = null;\r\n    } finally {\r\n        root.setDrawingCacheEnabled(false);\r\n    }\r\n    return coverImage;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.datamodel.accounts.Accounts.newToggleShowRejectedAction",
	"Comment": "gets a new action that when invoked toggles showing rejected artifacts onor off.",
	"Method": "Action newToggleShowRejectedAction(){\r\n    return new ToggleShowRejected();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.gui.navpanel.GroupCellFactory.getCountsText",
	"Comment": "get the counts part of the text to apply to this cell, includingparentheses",
	"Method": "String getCountsText(GroupCell<?> cell){\r\n    return // if item is null or group is null\r\n    cell.getGroup().map(group -> \" (\" + (sortOrder.get() == GroupComparators.ALPHABETICAL ? group.getSize() : sortOrder.get().getFormattedValueOfGroup(group)) + \")\").orElse(\"\");\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.CorrelationAttributeNormalizer.verifySsid",
	"Comment": "verify the wireless network name is validssids for wireless networks can be at most 32 characters, are casesensitive, and allow special characters.",
	"Method": "String verifySsid(String data){\r\n    if (data.length() <= 32) {\r\n        return data;\r\n    } else {\r\n        throw new CorrelationAttributeNormalizationException(\"Name provided was longer than the maximum valid SSID (32 characters). Name: \" + data);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.DataSourceUtils.imageHasFileSystem",
	"Comment": "calls tsk to determine whether apotential data source has a file system.",
	"Method": "boolean imageHasFileSystem(Path dataSourcePath){\r\n    return SleuthkitJNI.isImageSupported(dataSourcePath.toString());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.embeddedfileextractor.SevenZipExtractor.isZipBombArchiveItemCheck",
	"Comment": "check if the item inside archive is a potential zipbombcurrently checks compression ratio.more heuristics to be added here",
	"Method": "boolean isZipBombArchiveItemCheck(AbstractFile archiveFile,ISevenZipInArchive inArchive,int inArchiveItemIndex,ConcurrentHashMap<Long, Archive> depthMap,String escapedFilePath){\r\n    if (archiveFile.isMetaFlagSet(TskData.TSK_FS_META_FLAG_ENUM.UNALLOC)) {\r\n        return false;\r\n    }\r\n    try {\r\n        final Long archiveItemSize = (Long) inArchive.getProperty(inArchiveItemIndex, PropID.SIZE);\r\n        if (archiveItemSize == null || archiveItemSize < MIN_COMPRESSION_RATIO_SIZE) {\r\n            return false;\r\n        }\r\n        final Long archiveItemPackedSize = (Long) inArchive.getProperty(inArchiveItemIndex, PropID.PACKED_SIZE);\r\n        if (archiveItemPackedSize == null || archiveItemPackedSize <= 0) {\r\n            // NON-NLS\r\n            logger.log(Level.WARNING, \"Cannot getting compression ratio, cannot detect if zipbomb: {0}, item: {1}\", new Object[] { archiveFile.getName(), (String) inArchive.getProperty(inArchiveItemIndex, PropID.PATH) });\r\n            return false;\r\n        }\r\n        int cRatio = (int) (archiveItemSize / archiveItemPackedSize);\r\n        if (cRatio >= MAX_COMPRESSION_RATIO) {\r\n            Archive rootArchive = depthMap.get(depthMap.get(archiveFile.getId()).getRootArchiveId());\r\n            String details = NbBundle.getMessage(SevenZipExtractor.class, \"EmbeddedFileExtractorIngestModule.ArchiveExtractor.isZipBombCheck.warnDetails\", cRatio, FileUtil.escapeFileName(getArchiveFilePath(rootArchive.getArchiveFile())));\r\n            flagRootArchiveAsZipBomb(rootArchive, archiveFile, details, escapedFilePath);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    } catch (SevenZipException ex) {\r\n        logger.log(Level.WARNING, \"Error getting archive item size and cannot detect if zipbomb. \", ex);\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.interestingitems.FilesSet.getRules",
	"Comment": "gets a copy of the set membership rules of this interesting files set.",
	"Method": "Map<String, Rule> getRules(){\r\n    return new HashMap(this.rules);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJob.setIngestJob",
	"Comment": "sets the ingest job for the auto ingest job. used for obtainingprocessing stage details, cancelling the currently running data sourceingest module, and cancelling the job.",
	"Method": "void setIngestJob(IngestJob ingestJob){\r\n    this.ingestJob = ingestJob;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.KeywordHit.getContentID",
	"Comment": "get the content id associated with the content underlying hit. for hits on files this will be the same as the object id associated with the file. for hits on artifacts we look up the id of the objectthat produced the artifact.",
	"Method": "long getContentID(){\r\n    if (isArtifactHit()) {\r\n        SleuthkitCase caseDb;\r\n        try {\r\n            caseDb = Case.getCurrentCaseThrows().getSleuthkitCase();\r\n        } catch (NoCurrentCaseException ex) {\r\n            throw new TskCoreException(\"Exception while getting open case.\", ex);\r\n        }\r\n        try (SleuthkitCase.CaseDbQuery executeQuery = caseDb.executeQuery(GET_CONTENT_ID_FROM_ARTIFACT_ID + this.solrObjectId);\r\n            ResultSet resultSet = executeQuery.getResultSet()) {\r\n            if (resultSet.next()) {\r\n                return resultSet.getLong(\"obj_id\");\r\n            } else {\r\n                throw new TskCoreException(\"Failed to get obj_id for artifact with artifact_id =\" + this.solrObjectId + \".  No matching artifact was found.\");\r\n            }\r\n        } catch (SQLException ex) {\r\n            throw new TskCoreException(\"Error getting obj_id for artifact with artifact_id =\" + this.solrObjectId, ex);\r\n        }\r\n    } else {\r\n        return this.solrObjectId;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.volatilityDSP.VolatilityProcessor.flagFiles",
	"Comment": "adds interesting file artifacts for files found by a volatility plugin.",
	"Method": "void flagFiles(Set<String> fileSet,String pluginName){\r\n    Blackboard blackboard = currentCase.getServices().getBlackboard();\r\n    for (String file : fileSet) {\r\n        if (isCancelled) {\r\n            return;\r\n        }\r\n        if (file.isEmpty()) {\r\n            continue;\r\n        }\r\n        File volfile = new File(file);\r\n        String fileName = volfile.getName().trim();\r\n        if (fileName.length() < 1) {\r\n            continue;\r\n        }\r\n        String filePath = volfile.getParent();\r\n        logger.log(Level.INFO, \"Looking up file \" + fileName + \" at path \" + filePath);\r\n        try {\r\n            List<AbstractFile> resolvedFiles;\r\n            if (filePath == null) {\r\n                resolvedFiles = fileManager.findFiles(fileName);\r\n            } else {\r\n                filePath = filePath.replaceAll(\"\\\\\\\\\", \"/\");\r\n                resolvedFiles = fileManager.findFiles(fileName, filePath);\r\n            }\r\n            if ((resolvedFiles.isEmpty()) && (fileName.contains(\".\") == false)) {\r\n                if (fileSet.contains(file + \".exe\")) {\r\n                    continue;\r\n                }\r\n                fileName += \".%\";\r\n                logger.log(Level.INFO, \"Looking up file (extension wildcard) \" + fileName + \" at path \" + filePath);\r\n                if (filePath == null) {\r\n                    resolvedFiles = fileManager.findFiles(fileName);\r\n                } else {\r\n                    resolvedFiles = fileManager.findFiles(fileName, filePath);\r\n                }\r\n            }\r\n            if (resolvedFiles.isEmpty()) {\r\n                errorMsgs.add(Bundle.VolatilityProcessor_exceptionMessage_fileNotFound(filePath, fileName, pluginName));\r\n                continue;\r\n            }\r\n            for (AbstractFile resolvedFile : resolvedFiles) {\r\n                if (resolvedFile.getType() == TSK_DB_FILES_TYPE_ENUM.SLACK) {\r\n                    continue;\r\n                }\r\n                try {\r\n                    Collection<BlackboardAttribute> attributes = new ArrayList();\r\n                    attributes.add(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_SET_NAME, VOLATILITY, Bundle.VolatilityProcessor_artifactAttribute_interestingFileSet(pluginName)));\r\n                    org.sleuthkit.datamodel.Blackboard tskBlackboard = currentCase.getSleuthkitCase().getBlackboard();\r\n                    if (!tskBlackboard.artifactExists(resolvedFile, BlackboardArtifact.ARTIFACT_TYPE.TSK_INTERESTING_FILE_HIT, attributes)) {\r\n                        BlackboardArtifact volArtifact = resolvedFile.newArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_INTERESTING_FILE_HIT);\r\n                        volArtifact.addAttributes(attributes);\r\n                        try {\r\n                            blackboard.indexArtifact(volArtifact);\r\n                        } catch (Blackboard.BlackboardException ex) {\r\n                            errorMsgs.add(Bundle.VolatilityProcessor_errorMessage_failedToIndexArtifact(pluginName));\r\n                            logger.log(Level.SEVERE, String.format(\"Failed to index artifact (artifactId=%d) for for output of %s plugin\", volArtifact.getArtifactID(), pluginName), ex);\r\n                        }\r\n                        services.fireModuleDataEvent(new ModuleDataEvent(VOLATILITY, BlackboardArtifact.ARTIFACT_TYPE.TSK_INTERESTING_FILE_HIT));\r\n                    }\r\n                } catch (TskCoreException ex) {\r\n                    throw new VolatilityProcessorException(Bundle.VolatilityProcessor_exceptionMessage_errorCreatingArtifact(pluginName), ex);\r\n                }\r\n            }\r\n        } catch (TskCoreException ex) {\r\n            throw new VolatilityProcessorException(Bundle.VolatilityProcessor_errorMessage_errorFindingFiles(pluginName), ex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.filetypeid.FileTypeDetector.isDetectableByTika",
	"Comment": "determines whether or not a given mime type is detectable by tika.",
	"Method": "boolean isDetectableByTika(String mimeType){\r\n    return FileTypeDetector.getTikaDetectedTypes().contains(removeOptionalParameter(mimeType));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.SingleUserCaseConverter.deconflictDatabaseName",
	"Comment": "checks that the database name is unique. if it is not, attempts to addnumbers to it until it is unique. gives up if it goes through allpositive integers without finding a unique name.",
	"Method": "void deconflictDatabaseName(ImportCaseData icd){\r\n    Connection postgreSQLConnection = getPostgreSQLConnection(icd, POSTGRES_DEFAULT_DB_NAME);\r\n    int number = 1;\r\n    boolean unique = false;\r\n    String sanitizedDbName = icd.getPostgreSQLDbName();\r\n    if (sanitizedDbName.length() > MAX_DB_NAME_LENGTH) {\r\n        sanitizedDbName = sanitizedDbName.substring(0, MAX_DB_NAME_LENGTH);\r\n    }\r\n    if (postgreSQLConnection != null) {\r\n        while (unique == false) {\r\n            Statement st = postgreSQLConnection.createStatement();\r\n            ResultSet answer = st.executeQuery(\"SELECT datname FROM pg_catalog.pg_database WHERE LOWER(datname) LIKE LOWER('\" + sanitizedDbName + \"%')\");\r\n            if (!answer.next()) {\r\n                unique = true;\r\n            } else {\r\n                if (number == Integer.MAX_VALUE) {\r\n                    throw new Exception(NbBundle.getMessage(SingleUserCaseConverter.class, \"SingleUserCaseConverter.NonUniqueDatabaseName\"));\r\n                }\r\n                sanitizedDbName = \"db_\" + Integer.toString(number) + \"_\" + icd.getPostgreSQLDbName();\r\n                if (sanitizedDbName.length() > MAX_DB_NAME_LENGTH) {\r\n                    sanitizedDbName = sanitizedDbName.substring(0, MAX_DB_NAME_LENGTH);\r\n                }\r\n                ++number;\r\n            }\r\n        }\r\n        postgreSQLConnection.close();\r\n    } else {\r\n    }\r\n    icd.setPostgreSQLDbName(sanitizedDbName);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestJobSettings.getExecutionContext",
	"Comment": "gets the execution context identifier.some examples of execution contexts include the add data source wizard,the run ingest modules dialog, and auto ingest. different executioncontexts may have different ingest job settings.",
	"Method": "String getExecutionContext(){\r\n    return this.executionContext;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.examples.SampleIngestModuleFactory.getModuleVersionNumber",
	"Comment": "gets the version number of the family of ingest modules the factorycreates.",
	"Method": "String getModuleVersionNumber(){\r\n    return VERSION_NUMBER;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.db.EventDB.reInitializeTags",
	"Comment": "drop only the tags table and rebuild it incase the tags have changedwhile tl was not listening,",
	"Method": "void reInitializeTags(){\r\n    DBLock.lock();\r\n    try {\r\n        dropTagsTableStmt.executeUpdate();\r\n        initializeTagsTable();\r\n    } catch (SQLException ex) {\r\n        LOGGER.log(Level.SEVERE, \"could not drop old tags table\", ex);\r\n    } finally {\r\n        DBLock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.events.RemoteEventPublisher.stop",
	"Comment": "stops this publisher, causing it to disconnect from the message service.",
	"Method": "void stop(){\r\n    if (null != producer) {\r\n        producer.close();\r\n    }\r\n    if (null != consumer) {\r\n        consumer.close();\r\n    }\r\n    if (null != session) {\r\n        session.close();\r\n    }\r\n    if (null != connection) {\r\n        connection.close();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.CommonAttributePanel.updateErrorTextAndSearchButton",
	"Comment": "update the error text and the enabled status of the search button toreflect the current validity of the search settings.",
	"Method": "void updateErrorTextAndSearchButton(){\r\n    if (this.errorManager.anyErrors()) {\r\n        this.searchButton.setEnabled(false);\r\n        this.errorText.setText(this.errorManager.getErrors().get(0));\r\n        this.errorText.setVisible(true);\r\n    } else {\r\n        this.searchButton.setEnabled(true);\r\n        this.errorText.setVisible(false);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestMonitor.getRunningJobs",
	"Comment": "gets the snapshot of the running jobs list for an auto ingest cluster.",
	"Method": "List<AutoIngestJob> getRunningJobs(){\r\n    synchronized (jobsLock) {\r\n        return new ArrayList(jobsSnapshot.runningJobs);\r\n    }\r\n}"
}, {
	"Path": "org.automon.utils.AutomonPropertiesLoader.propertyLoader",
	"Comment": "try to load the filename to see if it is there and has properties.",
	"Method": "Properties propertyLoader(String[] fileNames,Properties propertyLoader,String fileName){\r\n    Properties properties = new Properties();\r\n    InputStream input = null;\r\n    try {\r\n        input = getConfigFileInputStream(fileName);\r\n        if (input != null) {\r\n            properties.load(input);\r\n            configFileFound = true;\r\n        }\r\n    } catch (Throwable t) {\r\n    } finally {\r\n        close(input);\r\n    }\r\n    return properties;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.fileextmismatch.FileExtMismatchDetectorModuleSettings.skipKnownFiles",
	"Comment": "gets the flag indicating whether or not known files should be skippedduring file extension mismatch checking.",
	"Method": "boolean skipKnownFiles(){\r\n    return skipKnownFiles;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestJob.isCancelled",
	"Comment": "queries whether or not cancellation of this ingest job has beenrequested.",
	"Method": "boolean isCancelled(boolean isCancelled,boolean isCancelled,boolean isCancelled){\r\n    return (CancellationReason.NOT_CANCELLED != this.cancellationReason);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.PostgresEamDbSettings.verifyConnection",
	"Comment": "use the current settings and the validation query to test the connectionto the database.",
	"Method": "boolean verifyConnection(){\r\n    Connection conn = getEphemeralConnection(true);\r\n    if (null == conn) {\r\n        return false;\r\n    }\r\n    boolean result = EamDbUtil.executeValidationQuery(conn, VALIDATION_QUERY);\r\n    EamDbUtil.closeConnection(conn);\r\n    return result;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.NewCaseVisualPanel1.getCaseParentDir",
	"Comment": "gets the base directory that the user typed on the base directory textfield. will add file separator if it was not added.",
	"Method": "String getCaseParentDir(){\r\n    String parentDir = this.caseParentDirTextField.getText();\r\n    if (parentDir.endsWith(File.separator) == false) {\r\n        parentDir = parentDir + File.separator;\r\n    }\r\n    return parentDir;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.fileextmismatch.FileExtMismatchOptionsPanelController.applyChanges",
	"Comment": "this method is called when both the ok and apply buttons are pressed. itapplies to any of the panels that have been opened in the process ofusing the options pane.",
	"Method": "void applyChanges(){\r\n    if (changed) {\r\n        getPanel().ok();\r\n        changed = false;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.interestingitems.InterestingItemsFilesSetSettings.writeDefinitionsFile",
	"Comment": "writes filesset definitions to disk as an xml file, logging any errors.",
	"Method": "boolean writeDefinitionsFile(String fileName,Map<String, FilesSet> interestingFilesSets){\r\n    try (final NbObjectOutputStream out = new NbObjectOutputStream(new FileOutputStream(Paths.get(PlatformUtil.getUserConfigDirectory(), fileName).toString()))) {\r\n        out.writeObject(new InterestingItemsFilesSetSettings(interestingFilesSets));\r\n    } catch (IOException ex) {\r\n        throw new FilesSetsManager.FilesSetsManagerException(String.format(\"Failed to write settings to %s\", fileName), ex);\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.healthmonitor.HealthMonitorDashboard.updateData",
	"Comment": "check the monitor enabled status and, if enabled, get the timing data.",
	"Method": "void updateData(){\r\n    HealthMonitor.getInstance().updateFromGlobalEnabledStatus();\r\n    if (HealthMonitor.monitorIsEnabled()) {\r\n        timingData = HealthMonitor.getInstance().getTimingMetricsFromDatabase(DateRange.getMaximumTimestampRange());\r\n        userData = HealthMonitor.getInstance().getUserMetricsFromDatabase(DateRange.getMaximumTimestampRange());\r\n    }\r\n}"
}, {
	"Path": "com.aliyun.oss.internal.ResponseParsers.parseCopyObjectResult",
	"Comment": "unmarshall copy object response body to corresponding result.",
	"Method": "CopyObjectResult parseCopyObjectResult(InputStream responseBody){\r\n    try {\r\n        Element root = getXmlRootElement(responseBody);\r\n        CopyObjectResult result = new CopyObjectResult();\r\n        result.setLastModified(DateUtil.parseIso8601Date(root.getChildText(\"LastModified\")));\r\n        result.setEtag(trimQuotes(root.getChildText(\"ETag\")));\r\n        return result;\r\n    } catch (Exception e) {\r\n        throw new ResponseParseException(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.datamodel.FileNode.getIconForFileType",
	"Comment": "gets the path to the icon file that should be used to visually representan abstractfile, using the file name extension to select the icon.",
	"Method": "String getIconForFileType(AbstractFile file){\r\n    String ext = file.getNameExtension();\r\n    if (StringUtils.isBlank(ext)) {\r\n        return \"org/sleuthkit/autopsy/images/file-icon.png\";\r\n    } else {\r\n        ext = \".\" + ext;\r\n    }\r\n    if (FileTypeExtensions.getImageExtensions().contains(ext)) {\r\n        return \"org/sleuthkit/autopsy/images/image-file.png\";\r\n    }\r\n    if (FileTypeExtensions.getVideoExtensions().contains(ext)) {\r\n        return \"org/sleuthkit/autopsy/images/video-file.png\";\r\n    }\r\n    if (FileTypeExtensions.getAudioExtensions().contains(ext)) {\r\n        return \"org/sleuthkit/autopsy/images/audio-file.png\";\r\n    }\r\n    if (FileTypeExtensions.getDocumentExtensions().contains(ext)) {\r\n        return \"org/sleuthkit/autopsy/images/doc-file.png\";\r\n    }\r\n    if (FileTypeExtensions.getExecutableExtensions().contains(ext)) {\r\n        return \"org/sleuthkit/autopsy/images/exe-file.png\";\r\n    }\r\n    if (FileTypeExtensions.getTextExtensions().contains(ext)) {\r\n        return \"org/sleuthkit/autopsy/images/text-file.png\";\r\n    }\r\n    if (FileTypeExtensions.getWebExtensions().contains(ext)) {\r\n        return \"org/sleuthkit/autopsy/images/web-file.png\";\r\n    }\r\n    if (FileTypeExtensions.getPDFExtensions().contains(ext)) {\r\n        return \"org/sleuthkit/autopsy/images/pdf-file.png\";\r\n    }\r\n    if (FileTypeExtensions.getArchiveExtensions().contains(ext)) {\r\n        return \"org/sleuthkit/autopsy/images/archive-file.png\";\r\n    }\r\n    return \"org/sleuthkit/autopsy/images/file-icon.png\";\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.AbstractSqlEamDb.newCorrelationTypeNotKnownId",
	"Comment": "helper function which adds a new eamartifact.type to the db without anid.",
	"Method": "int newCorrelationTypeNotKnownId(CorrelationAttributeInstance.Type newType){\r\n    Connection conn = connect();\r\n    PreparedStatement preparedStatement = null;\r\n    PreparedStatement preparedStatementQuery = null;\r\n    ResultSet resultSet = null;\r\n    int typeId = 0;\r\n    String insertSql;\r\n    String querySql;\r\n    insertSql = \"INSERT INTO correlation_types(display_name, db_table_name, supported, enabled) VALUES (?, ?, ?, ?) \" + getConflictClause();\r\n    querySql = \"SELECT * FROM correlation_types WHERE display_name=? AND db_table_name=?\";\r\n    try {\r\n        preparedStatement = conn.prepareStatement(insertSql);\r\n        preparedStatement.setString(1, newType.getDisplayName());\r\n        preparedStatement.setString(2, newType.getDbTableName());\r\n        preparedStatement.setInt(3, newType.isSupported() ? 1 : 0);\r\n        preparedStatement.setInt(4, newType.isEnabled() ? 1 : 0);\r\n        preparedStatement.executeUpdate();\r\n        preparedStatementQuery = conn.prepareStatement(querySql);\r\n        preparedStatementQuery.setString(1, newType.getDisplayName());\r\n        preparedStatementQuery.setString(2, newType.getDbTableName());\r\n        resultSet = preparedStatementQuery.executeQuery();\r\n        if (resultSet.next()) {\r\n            CorrelationAttributeInstance.Type correlationType = getCorrelationTypeFromResultSet(resultSet);\r\n            typeId = correlationType.getId();\r\n        }\r\n    } catch (SQLException ex) {\r\n        throw new EamDbException(\"Error inserting new correlation type.\", ex);\r\n    } finally {\r\n        EamDbUtil.closeStatement(preparedStatement);\r\n        EamDbUtil.closeStatement(preparedStatementQuery);\r\n        EamDbUtil.closeResultSet(resultSet);\r\n        EamDbUtil.closeConnection(conn);\r\n    }\r\n    return typeId;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.contentviewers.MediaViewImagePanel.showImageFx",
	"Comment": "show the contents of the given abstractfile as a visual image.",
	"Method": "void showImageFx(AbstractFile file,Dimension dims){\r\n    if (!fxInited) {\r\n        return;\r\n    }\r\n    Platform.runLater(() -> {\r\n        if (readImageTask != null) {\r\n            readImageTask.cancel();\r\n        }\r\n        readImageTask = ImageUtils.newReadImageTask(file);\r\n        readImageTask.setOnSucceeded(succeeded -> {\r\n            if (!Case.isCaseOpen()) {\r\n                reset();\r\n                return;\r\n            }\r\n            try {\r\n                Image fxImage = readImageTask.get();\r\n                if (nonNull(fxImage)) {\r\n                    fxImageView.setImage(fxImage);\r\n                    borderpane.setCenter(fxImageView);\r\n                } else {\r\n                    showErrorNode(Bundle.MediaViewImagePanel_errorLabel_text(), file);\r\n                }\r\n            } catch (InterruptedException | ExecutionException ex) {\r\n                showErrorNode(Bundle.MediaViewImagePanel_errorLabel_text(), file);\r\n            }\r\n            borderpane.setCursor(Cursor.DEFAULT);\r\n        });\r\n        readImageTask.setOnFailed(failed -> {\r\n            if (!Case.isCaseOpen()) {\r\n                reset();\r\n                return;\r\n            }\r\n            Throwable exception = readImageTask.getException();\r\n            if (exception instanceof OutOfMemoryError && exception.getMessage().contains(\"Java heap space\")) {\r\n                showErrorNode(Bundle.MediaViewImagePanel_errorLabel_OOMText(), file);\r\n            } else {\r\n                showErrorNode(Bundle.MediaViewImagePanel_errorLabel_text(), file);\r\n            }\r\n            borderpane.setCursor(Cursor.DEFAULT);\r\n        });\r\n        maskerPane.setProgressNode(progressBar);\r\n        progressBar.progressProperty().bind(readImageTask.progressProperty());\r\n        maskerPane.textProperty().bind(readImageTask.messageProperty());\r\n        borderpane.setCenter(maskerPane);\r\n        borderpane.setCursor(Cursor.WAIT);\r\n        new Thread(readImageTask).start();\r\n    });\r\n}"
}, {
	"Path": "com.badlogic.ashley.core.PooledEngine.clearPools",
	"Comment": "removes all free entities and components from their pools. although this will likely result in garbage collection, it will\tfree up memory.",
	"Method": "void clearPools(){\r\n    entityPool.clear();\r\n    componentPools.clear();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJobNodeData.setDeviceId",
	"Comment": "sets the device id of the device associated with the data source for thejob.",
	"Method": "void setDeviceId(String deviceId){\r\n    this.deviceId = deviceId;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestManager.handleCaseClosed",
	"Comment": "handles a current case closed event by cancelling all ingest jobs for thecase, closing the remote event channel for the case, and clearing theingest messages inbox.note that current case change events are published in a strictlyserialized manner, i.e., one event at a time, synchronously.",
	"Method": "void handleCaseClosed(){\r\n    this.cancelAllIngestJobs(IngestJob.CancellationReason.CASE_CLOSED);\r\n    jobEventPublisher.closeRemoteEventChannel();\r\n    moduleEventPublisher.closeRemoteEventChannel();\r\n    caseIsOpen = false;\r\n    clearIngestMessageBox();\r\n}"
}, {
	"Path": "com.litesuits.http.impl.apache.ApacheClient.createClientConnManager",
	"Comment": "register http and https scheme, and got threadsafeclientconnmanager",
	"Method": "ThreadSafeClientConnManager createClientConnManager(BasicHttpParams httpParams){\r\n    SchemeRegistry schemeRegistry = new SchemeRegistry();\r\n    SSLSocketFactory socketFactory = MySSLSocketFactory.getFixedSocketFactory();\r\n    schemeRegistry.register(new Scheme(Consts.SCHEME_HTTP, PlainSocketFactory.getSocketFactory(), HttpConfig.DEFAULT_HTTP_PORT));\r\n    schemeRegistry.register(new Scheme(Consts.SCHEME_HTTPS, socketFactory, HttpConfig.DEFAULT_HTTPS_PORT));\r\n    return new ThreadSafeClientConnManager(httpParams, schemeRegistry);\r\n}"
}, {
	"Path": "org.wikipedia.gallery.GalleryActivity.layOutGalleryDescription",
	"Comment": "populate the description and license text fields with data from the current gallery item.",
	"Method": "void layOutGalleryDescription(){\r\n    GalleryItem item = getCurrentItem();\r\n    if (item == null) {\r\n        infoContainer.setVisibility(View.GONE);\r\n        return;\r\n    }\r\n    galleryAdapter.notifyFragments(galleryPager.getCurrentItem());\r\n    CharSequence descriptionStr = \"\";\r\n    if (item.getDescription() != null && item.getDescription().getHtml() != null) {\r\n        descriptionStr = StringUtil.fromHtml(item.getDescription().getHtml());\r\n    } else if (item.getDescription() != null && item.getDescription().getText() != null) {\r\n        descriptionStr = item.getDescription().getText();\r\n    }\r\n    if (descriptionStr.length() > 0) {\r\n        descriptionText.setText(strip(descriptionStr));\r\n        descriptionText.setVisibility(View.VISIBLE);\r\n    } else {\r\n        descriptionText.setVisibility(View.GONE);\r\n    }\r\n    if (getLicenseIcon(item) == R.drawable.ic_license_by) {\r\n        licenseIcon.setImageResource(R.drawable.ic_license_cc);\r\n        byIcon.setImageResource(R.drawable.ic_license_by);\r\n        byIcon.setVisibility(View.VISIBLE);\r\n        saIcon.setImageResource(R.drawable.ic_license_sharealike);\r\n        saIcon.setVisibility(View.VISIBLE);\r\n    } else {\r\n        licenseIcon.setImageResource(getLicenseIcon(item));\r\n        byIcon.setVisibility(View.GONE);\r\n        saIcon.setVisibility(View.GONE);\r\n    }\r\n    String usageTerms = item.getLicense().getLicenseName();\r\n    if (usageTerms == null || TextUtils.isEmpty(usageTerms)) {\r\n        usageTerms = getString(R.string.gallery_fair_use_license);\r\n    }\r\n    licenseIcon.setContentDescription(usageTerms);\r\n    licenseIcon.setTag(item.getLicense().getLicenseUrl());\r\n    String creditStr = \"\";\r\n    if (item.getArtist() != null) {\r\n        creditStr = item.getArtist().getName() == null ? StringUtil.fromHtml(item.getArtist().getHtml()).toString().trim() : item.getArtist().getName();\r\n    }\r\n    if (TextUtils.isEmpty(creditStr)) {\r\n        creditStr = getString(R.string.gallery_uploader_unknown);\r\n    }\r\n    creditText.setText(creditStr);\r\n    infoContainer.setVisibility(View.VISIBLE);\r\n}"
}, {
	"Path": "com.mcxiaoke.next.ui.internal.AdapterWrapper.getItem",
	"Comment": "get the data item associated with the specifiedposition in the data set.",
	"Method": "Object getItem(int position){\r\n    return (wrapped.getItem(position));\r\n}"
}, {
	"Path": "com.aliyun.oss.internal.ResponseParsers.parseGetUdfImageInfo",
	"Comment": "unmarshall get udf info response body to udf image info list.",
	"Method": "List<UdfImageInfo> parseGetUdfImageInfo(InputStream responseBody){\r\n    try {\r\n        Element root = getXmlRootElement(responseBody);\r\n        List<UdfImageInfo> udfImages = new ArrayList<UdfImageInfo>();\r\n        if (root.getChild(\"Item\") != null) {\r\n            List<Element> udfImageElems = root.getChildren(\"Item\");\r\n            for (Element elem : udfImageElems) {\r\n                Integer version = Integer.valueOf(elem.getChildText(\"Version\"));\r\n                String status = elem.getChildText(\"Status\");\r\n                String region = elem.getChildText(\"CanonicalRegion\");\r\n                String desc = elem.getChildText(\"Description\");\r\n                Date date = DateUtil.parseIso8601Date(elem.getChildText(\"CreationDate\"));\r\n                udfImages.add(new UdfImageInfo(version, status, desc, region, date));\r\n            }\r\n        }\r\n        return udfImages;\r\n    } catch (JDOMParseException e) {\r\n        throw new ResponseParseException(e.getPartialDocument() + \": \" + e.getMessage(), e);\r\n    } catch (Exception e) {\r\n        throw new ResponseParseException(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.Case.getTempDirectory",
	"Comment": "gets the full path to the temp directory for this case, creating it if itdoes not exist.",
	"Method": "String getTempDirectory(){\r\n    return getOrCreateSubdirectory(TEMP_FOLDER);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.EamDbUtil.setUseCentralRepo",
	"Comment": "saves the setting for whether the central repo should be able to beconfigured.",
	"Method": "void setUseCentralRepo(boolean centralRepoCheckBoxIsSelected){\r\n    ModuleSettings.setConfigSetting(CENTRAL_REPO_NAME, CENTRAL_REPO_USE_KEY, Boolean.toString(centralRepoCheckBoxIsSelected));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.services.TagsManager.getBlackboardArtifactTagsCountByTagName",
	"Comment": "gets an artifact tags count by tag name, for the given data source.",
	"Method": "long getBlackboardArtifactTagsCountByTagName(TagName tagName,long getBlackboardArtifactTagsCountByTagName,TagName tagName,long dsObjId){\r\n    return caseDb.getBlackboardArtifactTagsCountByTagName(tagName, dsObjId);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestManager.fireDataSourceAnalysisCancelled",
	"Comment": "publishes an ingest job event signifying analysis of a data source wascanceled.",
	"Method": "void fireDataSourceAnalysisCancelled(long ingestJobId,long dataSourceIngestJobId,Content dataSource){\r\n    AutopsyEvent event = new DataSourceAnalysisCompletedEvent(ingestJobId, dataSourceIngestJobId, dataSource, DataSourceAnalysisCompletedEvent.Reason.ANALYSIS_CANCELLED);\r\n    eventPublishingExecutor.submit(new PublishEventTask(event, jobEventPublisher));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestTasksScheduler.tasksForJobAreCompleted",
	"Comment": "queries the task scheduler to determine whether or not all of the ingesttasks for a data source ingest job have been completed.",
	"Method": "boolean tasksForJobAreCompleted(DataSourceIngestJob job){\r\n    long jobId = job.getId();\r\n    return !(this.dataSourceIngestThreadQueue.hasTasksForJob(jobId) || hasTasksForJob(this.rootFileTaskQueue, jobId) || hasTasksForJob(this.pendingFileTaskQueue, jobId) || this.fileIngestThreadsQueue.hasTasksForJob(jobId));\r\n}"
}, {
	"Path": "com.anysoftkeyboard.utils.XmlWriter.close",
	"Comment": "close this mwriter. it does not close the underlying mwriter, but doesthrow an exception if there are as yet unclosed tags.",
	"Method": "void close(){\r\n    if (mThisIsWriterOwner) {\r\n        this.mWriter.flush();\r\n        this.mWriter.close();\r\n    }\r\n    if (this.mStack.size() > 0) {\r\n        throw new IllegalStateException(\"Tags are not all closed. Possibly, \" + this.mStack.pop() + \" is unclosed. \");\r\n    }\r\n}"
}, {
	"Path": "com.mcxiaoke.next.ui.internal.AdapterWrapper.getView",
	"Comment": "get a view that displays the data at the specifiedposition in the data set.",
	"Method": "View getView(int position,View convertView,ViewGroup parent){\r\n    return (wrapped.getView(position, convertView, parent));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.healthmonitor.HealthMonitor.stopTimer",
	"Comment": "stop the scheduledthreadpoolexecutor to prevent further database writes.",
	"Method": "void stopTimer(){\r\n    if (healthMonitorOutputTimer != null) {\r\n        ThreadUtils.shutDownTaskExecutor(healthMonitorOutputTimer);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.encryptiondetection.BitlockerDetection.isBitlockerVolume",
	"Comment": "this method checks if the volume input has been encrypted with bitlocker.",
	"Method": "boolean isBitlockerVolume(Volume volume){\r\n    boolean bitlockerVolume = false;\r\n    byte[] bpbArray = new byte[BITLOCKER_BIOS_PARAMETER_BLOCK_SIZE];\r\n    volume.read(bpbArray, 0, BITLOCKER_BIOS_PARAMETER_BLOCK_SIZE);\r\n    boolean signatureMatches = true;\r\n    for (int i = 0; i < BITLOCKER_SIGNATURE_BYTES.length; i++) {\r\n        if (bpbArray[BITLOCKER_ADDRESS_SIGNATURE + i] != BITLOCKER_SIGNATURE_BYTES[i]) {\r\n            signatureMatches = false;\r\n            break;\r\n        }\r\n    }\r\n    if (signatureMatches) {\r\n        switch((int) bpbArray[BITLOCKER_ADDRESS_SECTORS_PER_CLUSTER]) {\r\n            case 0x01:\r\n            case 0x02:\r\n            case 0x04:\r\n            case 0x08:\r\n            case 0x10:\r\n            case 0x20:\r\n            case 0x40:\r\n            case 0x80:\r\n                short reservedClusters = (short) ((bpbArray[BITLOCKER_ADDRESS_RESERVED_CLUSTERS] << 8) | (bpbArray[BITLOCKER_ADDRESS_RESERVED_CLUSTERS + 1] & 0xFF));\r\n                byte fatCount = bpbArray[BITLOCKER_ADDRESS_FAT_COUNT];\r\n                short rootEntries = (short) ((bpbArray[BITLOCKER_ADDRESS_ROOT_ENTRIES] << 8) | (bpbArray[BITLOCKER_ADDRESS_ROOT_ENTRIES + 1] & 0xFF));\r\n                short sectors = (short) ((bpbArray[BITLOCKER_ADDRESS_SECTORS] << 8) | (bpbArray[BITLOCKER_ADDRESS_SECTORS + 1] & 0xFF));\r\n                short sectorsPerFat = (short) ((bpbArray[BITLOCKER_ADDRESS_SECTORS_PER_FAT] << 8) | (bpbArray[BITLOCKER_ADDRESS_SECTORS_PER_FAT + 1] & 0xFF));\r\n                int largeSectors = ((bpbArray[BITLOCKER_ADDRESS_LARGE_SECTORS] << 24) | ((bpbArray[BITLOCKER_ADDRESS_LARGE_SECTORS + 1] & 0xFF) << 16) | ((bpbArray[BITLOCKER_ADDRESS_LARGE_SECTORS + 2] & 0xFF) << 8) | (bpbArray[BITLOCKER_ADDRESS_LARGE_SECTORS + 3] & 0xFF));\r\n                if (reservedClusters == 0 && fatCount == 0 && rootEntries == 0 && sectors == 0 && sectorsPerFat == 0 && largeSectors == 0) {\r\n                    bitlockerVolume = true;\r\n                }\r\n                break;\r\n            default:\r\n        }\r\n    }\r\n    return bitlockerVolume;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.CommonAttributeSearchResults.getMetadata",
	"Comment": "get an unmodifiable collection of values, indexed by number ofgrandchildren, which represents the common attributes found in thesearch.remove results which are not found in the portion of available datasources described by maximumpercentagethreshold.",
	"Method": "Map<Integer, CommonAttributeValueList> getMetadata(Map<Integer, CommonAttributeValueList> getMetadata,int maximumPercentageThreshold){\r\n    CorrelationAttributeInstance.Type attributeType = CorrelationAttributeInstance.getDefaultCorrelationTypes().stream().filter(filterType -> filterType.getId() == this.resultTypeId).findFirst().get();\r\n    EamDb eamDb = EamDb.getInstance();\r\n    Map<Integer, List<CommonAttributeValue>> itemsToRemove = new HashMap();\r\n    Double uniqueCaseDataSourceTuples = eamDb.getCountUniqueDataSources().doubleValue();\r\n    for (Entry<Integer, CommonAttributeValueList> listOfValues : Collections.unmodifiableMap(this.instanceCountToAttributeValues).entrySet()) {\r\n        final Integer key = listOfValues.getKey();\r\n        final CommonAttributeValueList values = listOfValues.getValue();\r\n        for (CommonAttributeValue value : values.getDelayedMetadataList()) {\r\n            boolean mimeTypeToRemove = false;\r\n            if (!mimeTypesToInclude.isEmpty()) {\r\n                for (AbstractCommonAttributeInstance commonAttr : value.getInstances()) {\r\n                    AbstractFile abstractFile = commonAttr.getAbstractFile();\r\n                    if (abstractFile != null) {\r\n                        String mimeType = commonAttr.getAbstractFile().getMIMEType();\r\n                        if (mimeType != null && !mimeTypesToInclude.contains(mimeType)) {\r\n                            if (itemsToRemove.containsKey(key)) {\r\n                                itemsToRemove.get(key).add(value);\r\n                            } else {\r\n                                List<CommonAttributeValue> toRemove = new ArrayList();\r\n                                toRemove.add(value);\r\n                                itemsToRemove.put(key, toRemove);\r\n                            }\r\n                            mimeTypeToRemove = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (mimeTypeToRemove) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (!mimeTypeToRemove && maximumPercentageThreshold != 0) {\r\n                try {\r\n                    Double uniqueTypeValueTuples = eamDb.getCountUniqueCaseDataSourceTuplesHavingTypeValue(attributeType, value.getValue()).doubleValue();\r\n                    Double commonalityPercentage = uniqueTypeValueTuples / uniqueCaseDataSourceTuples * 100;\r\n                    int frequencyPercentage = commonalityPercentage.intValue();\r\n                    if (frequencyPercentage > maximumPercentageThreshold) {\r\n                        if (itemsToRemove.containsKey(key)) {\r\n                            itemsToRemove.get(key).add(value);\r\n                        } else {\r\n                            List<CommonAttributeValue> toRemove = new ArrayList();\r\n                            toRemove.add(value);\r\n                            itemsToRemove.put(key, toRemove);\r\n                        }\r\n                    }\r\n                } catch (CorrelationAttributeNormalizationException ex) {\r\n                    LOGGER.log(Level.WARNING, \"Unable to determine frequency percentage attribute - frequency filter may not be accurate for these results.\", ex);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    for (Entry<Integer, List<CommonAttributeValue>> valuesToRemove : itemsToRemove.entrySet()) {\r\n        final Integer key = valuesToRemove.getKey();\r\n        final List<CommonAttributeValue> values = valuesToRemove.getValue();\r\n        for (CommonAttributeValue value : values) {\r\n            final CommonAttributeValueList instanceCountValue = this.instanceCountToAttributeValues.get(key);\r\n            if (instanceCountValue != null) {\r\n                instanceCountValue.removeMetaData(value);\r\n                if (instanceCountValue.getDelayedMetadataList().isEmpty()) {\r\n                    this.instanceCountToAttributeValues.remove(key);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return Collections.unmodifiableMap(this.instanceCountToAttributeValues);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.ImageGalleryTopComponent.closeTopComponent",
	"Comment": "closes the singleton image gallery top component. note that calling thismethod will cause the top component to be constructed if it does notalready exist.",
	"Method": "void closeTopComponent(){\r\n    getTopComponent().close();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.datamodel.FileNode.isLeafTypeNode",
	"Comment": "indicates whether or not the node is capable of having child nodes.should only return true if the node is always a leaf node.",
	"Method": "boolean isLeafTypeNode(){\r\n    return false;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.DataContentViewerArtifact.updateRowHeights",
	"Comment": "sets the row heights to the heights of the content in their value column.",
	"Method": "void updateRowHeights(){\r\n    int valueColIndex = -1;\r\n    for (int col = 0; col < resultsTable.getColumnCount(); col++) {\r\n        if (resultsTable.getColumnName(col).equals(COLUMN_HEADERS[1])) {\r\n            valueColIndex = col;\r\n        }\r\n    }\r\n    if (valueColIndex != -1) {\r\n        for (int row = 0; row < resultsTable.getRowCount(); row++) {\r\n            Component comp = resultsTable.prepareRenderer(resultsTable.getCellRenderer(row, valueColIndex), row, valueColIndex);\r\n            final int rowHeight;\r\n            if (comp instanceof JTextArea) {\r\n                final JTextArea tc = (JTextArea) comp;\r\n                final View rootView = tc.getUI().getRootView(tc);\r\n                java.awt.Insets i = tc.getInsets();\r\n                rootView.setSize(resultsTable.getColumnModel().getColumn(valueColIndex).getWidth() - (i.left + i.right + CELL_RIGHT_MARGIN), Integer.MAX_VALUE);\r\n                rowHeight = (int) rootView.getPreferredSpan(View.Y_AXIS);\r\n            } else {\r\n                rowHeight = comp.getPreferredSize().height;\r\n            }\r\n            if (rowHeight > 0) {\r\n                resultsTable.setRowHeight(row, rowHeight + CELL_BOTTOM_MARGIN);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.datamodel.SingleEvent.getDataSourceID",
	"Comment": "get the datasource id of the datasource this event belongs to.",
	"Method": "long getDataSourceID(){\r\n    return dataSourceID;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestTasksScheduler.shouldBeCarved",
	"Comment": "check whether or not a file should be carved for a data source ingestingest job.",
	"Method": "boolean shouldBeCarved(FileIngestTask task){\r\n    return task.getIngestJob().shouldProcessUnallocatedSpace() && task.getFile().getType().equals(TskData.TSK_DB_FILES_TYPE_ENUM.UNALLOC_BLOCKS);\r\n}"
}, {
	"Path": "com.litesuits.http.parser.MemCacheableParser.translateString",
	"Comment": "translate original string to custom string.if your data is encrypted, you can override this method to decrypt it.",
	"Method": "String translateString(String string){\r\n    return string;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.Case.getReportDirectory",
	"Comment": "gets the full path to the reports directory for this case, creating it ifit does not exist.",
	"Method": "String getReportDirectory(){\r\n    return getOrCreateSubdirectory(REPORTS_FOLDER);\r\n}"
}, {
	"Path": "com.facebook.samples.zoomable.ZoomableDraweeView.setAllowTouchInterceptionWhileZoomed",
	"Comment": "if this is set to true, parent views can intercept touch events while the view is zoomed.for example, this can be used to swipe between images in a view pager while zoomed.",
	"Method": "void setAllowTouchInterceptionWhileZoomed(boolean allowTouchInterceptionWhileZoomed){\r\n    mAllowTouchInterceptionWhileZoomed = allowTouchInterceptionWhileZoomed;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.datamodel.FilteredEventsModel.getCombinedEvents",
	"Comment": "get a representation of all the events, within the given time range, thatpass the given filter, grouped by time and description such that filesystem events for the same file, with the same timestamp, are combinedtogether.",
	"Method": "List<CombinedEvent> getCombinedEvents(){\r\n    return repo.getCombinedEvents(requestedTimeRange.get(), requestedFilter.get());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.TimeLineController.showInListView",
	"Comment": "show the events and the amount of time indicated in the givenviewintimelinerequestedevent in the list view.",
	"Method": "void showInListView(ViewInTimelineRequestedEvent requestEvent){\r\n    synchronized (filteredEvents) {\r\n        setViewMode(ViewMode.LIST);\r\n        selectEventIDs(requestEvent.getEventIDs());\r\n        if (pushTimeRange(requestEvent.getInterval()) == false) {\r\n            eventbus.post(requestEvent);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.ResultViewerPersistence.getColumnPositionKey",
	"Comment": "gets a key for the given node and a property of its child nodes to storethe column position into a preference file.",
	"Method": "String getColumnPositionKey(TableFilterNode node,String propName){\r\n    return getColumnKeyBase(node, propName) + \".column\";\r\n}"
}, {
	"Path": "com.aliyun.oss.internal.ResponseParsers.parseListLiveChannels",
	"Comment": "unmarshall list live channels response body to live channel listing.",
	"Method": "LiveChannelListing parseListLiveChannels(InputStream responseBody){\r\n    try {\r\n        Element root = getXmlRootElement(responseBody);\r\n        LiveChannelListing liveChannelListing = new LiveChannelListing();\r\n        liveChannelListing.setTruncated(Boolean.valueOf(root.getChildText(\"IsTruncated\")));\r\n        if (root.getChild(\"Prefix\") != null) {\r\n            String prefix = root.getChildText(\"Prefix\");\r\n            liveChannelListing.setPrefix(isNullOrEmpty(prefix) ? null : prefix);\r\n        }\r\n        if (root.getChild(\"Marker\") != null) {\r\n            String marker = root.getChildText(\"Marker\");\r\n            liveChannelListing.setMarker(isNullOrEmpty(marker) ? null : marker);\r\n        }\r\n        if (root.getChild(\"MaxKeys\") != null) {\r\n            String maxKeys = root.getChildText(\"MaxKeys\");\r\n            liveChannelListing.setMaxKeys(Integer.valueOf(maxKeys));\r\n        }\r\n        if (root.getChild(\"NextMarker\") != null) {\r\n            String nextMarker = root.getChildText(\"NextMarker\");\r\n            liveChannelListing.setNextMarker(isNullOrEmpty(nextMarker) ? null : nextMarker);\r\n        }\r\n        List<Element> liveChannelElems = root.getChildren(\"LiveChannel\");\r\n        for (Element elem : liveChannelElems) {\r\n            LiveChannel liveChannel = new LiveChannel();\r\n            liveChannel.setName(elem.getChildText(\"Name\"));\r\n            liveChannel.setDescription(elem.getChildText(\"Description\"));\r\n            liveChannel.setStatus(LiveChannelStatus.parse(elem.getChildText(\"Status\")));\r\n            liveChannel.setLastModified(DateUtil.parseIso8601Date(elem.getChildText(\"LastModified\")));\r\n            List<String> publishUrls = new ArrayList<String>();\r\n            List<Element> publishElems = elem.getChild(\"PublishUrls\").getChildren(\"Url\");\r\n            for (Element urlElem : publishElems) {\r\n                publishUrls.add(urlElem.getText());\r\n            }\r\n            liveChannel.setPublishUrls(publishUrls);\r\n            List<String> playUrls = new ArrayList<String>();\r\n            List<Element> playElems = elem.getChild(\"PlayUrls\").getChildren(\"Url\");\r\n            for (Element urlElem : playElems) {\r\n                playUrls.add(urlElem.getText());\r\n            }\r\n            liveChannel.setPlayUrls(playUrls);\r\n            liveChannelListing.addLiveChannel(liveChannel);\r\n        }\r\n        return liveChannelListing;\r\n    } catch (JDOMParseException e) {\r\n        throw new ResponseParseException(e.getPartialDocument() + \": \" + e.getMessage(), e);\r\n    } catch (Exception e) {\r\n        throw new ResponseParseException(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.PostgresEamDbSettings.getDbName",
	"Comment": "to prevent issues where one command can honor case and another cannot, wewill force the dbname to lower case.",
	"Method": "String getDbName(){\r\n    return dbName.toLowerCase();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.ui.detailview.DetailViewPane.newUnhideDescriptionAction",
	"Comment": "get a new action that will unhide events with the given description.",
	"Method": "Action newUnhideDescriptionAction(String description,DescriptionLoD descriptionLoD){\r\n    return new UnhideDescriptionAction(description, descriptionLoD, getChart());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.InterCasePanel.setCaseMap",
	"Comment": "update the map of cases that this panel allows the user to select from",
	"Method": "void setCaseMap(Map<Integer, String> caseMap){\r\n    this.caseMap.clear();\r\n    this.caseMap.putAll(caseMap);\r\n}"
}, {
	"Path": "com.aliyun.oss.internal.ResponseParsers.parseGetBucketLocation",
	"Comment": "unmarshall get bucket location response body to bucket location.",
	"Method": "String parseGetBucketLocation(InputStream responseBody){\r\n    try {\r\n        Element root = getXmlRootElement(responseBody);\r\n        return root.getText();\r\n    } catch (JDOMParseException e) {\r\n        throw new ResponseParseException(e.getPartialDocument() + \": \" + e.getMessage(), e);\r\n    } catch (Exception e) {\r\n        throw new ResponseParseException(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.AddImageAction.runCleanupTasks",
	"Comment": "run and clear any cleanup tasks for wizard closing that might beregistered. this should be run even when the wizard exits cleanly, sothat no cleanup actions remain the next time the wizard is run.",
	"Method": "void runCleanupTasks(){\r\n    cleanupSupport.fireChange();\r\n}"
}, {
	"Path": "com.aliyun.oss.model.ResponseHeaderOverrides.getContentType",
	"Comment": "gets the content type. if the type is not specified, return null.",
	"Method": "String getContentType(){\r\n    return contentType;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.eventlisteners.IngestEventsListener.decrementCorrelationEngineModuleCount",
	"Comment": "decrease the number of ingesteventslisteners adding contents to thecorrelation engine.",
	"Method": "void decrementCorrelationEngineModuleCount(){\r\n    if (getCeModuleInstanceCount() > 0) {\r\n        correlationModuleInstanceCount--;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.KeywordSearchIngestModule.cleanup",
	"Comment": "common cleanup code when module stops or final searcher completes",
	"Method": "void cleanup(){\r\n    textExtractors.clear();\r\n    textExtractors = null;\r\n    stringExtractor = null;\r\n    txtFileExtractor = null;\r\n    initialized = false;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.ReportHTML.useDataTypeIcon",
	"Comment": "copies a suitable icon for the given data type in the output directoryand returns the icon file name to use for the given data type.",
	"Method": "String useDataTypeIcon(String dataType){\r\n    String iconFilePath;\r\n    String iconFileName;\r\n    InputStream in;\r\n    OutputStream output = null;\r\n    logger.log(Level.INFO, \"useDataTypeIcon: dataType = {0}\", dataType);\r\n    BlackboardArtifact.ARTIFACT_TYPE artifactType = null;\r\n    for (ARTIFACT_TYPE v : ARTIFACT_TYPE.values()) {\r\n        if (v.getDisplayName().equals(dataType)) {\r\n            artifactType = v;\r\n        }\r\n    }\r\n    if (null != artifactType) {\r\n        iconFileName = dataTypeToFileName(artifactType.getDisplayName()) + \".png\";\r\n        iconFilePath = subPath + File.separator + iconFileName;\r\n        switch(artifactType) {\r\n            case TSK_WEB_BOOKMARK:\r\n                in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/report/images/bookmarks.png\");\r\n                break;\r\n            case TSK_WEB_COOKIE:\r\n                in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/report/images/cookies.png\");\r\n                break;\r\n            case TSK_WEB_HISTORY:\r\n                in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/report/images/history.png\");\r\n                break;\r\n            case TSK_WEB_DOWNLOAD:\r\n                in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/report/images/downloads.png\");\r\n                break;\r\n            case TSK_RECENT_OBJECT:\r\n                in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/report/images/recent.png\");\r\n                break;\r\n            case TSK_INSTALLED_PROG:\r\n                in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/report/images/installed.png\");\r\n                break;\r\n            case TSK_KEYWORD_HIT:\r\n                in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/report/images/keywords.png\");\r\n                break;\r\n            case TSK_HASHSET_HIT:\r\n                in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/report/images/hash.png\");\r\n                break;\r\n            case TSK_DEVICE_ATTACHED:\r\n                in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/report/images/devices.png\");\r\n                break;\r\n            case TSK_WEB_SEARCH_QUERY:\r\n                in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/report/images/search.png\");\r\n                break;\r\n            case TSK_METADATA_EXIF:\r\n                in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/report/images/exif.png\");\r\n                break;\r\n            case TSK_TAG_FILE:\r\n                in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/report/images/userbookmarks.png\");\r\n                break;\r\n            case TSK_TAG_ARTIFACT:\r\n                in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/report/images/userbookmarks.png\");\r\n                break;\r\n            case TSK_SERVICE_ACCOUNT:\r\n                in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/report/images/account-icon-16.png\");\r\n                break;\r\n            case TSK_CONTACT:\r\n                in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/report/images/contact.png\");\r\n                break;\r\n            case TSK_MESSAGE:\r\n                in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/report/images/message.png\");\r\n                break;\r\n            case TSK_CALLLOG:\r\n                in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/report/images/calllog.png\");\r\n                break;\r\n            case TSK_CALENDAR_ENTRY:\r\n                in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/report/images/calendar.png\");\r\n                break;\r\n            case TSK_SPEED_DIAL_ENTRY:\r\n                in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/report/images/speeddialentry.png\");\r\n                break;\r\n            case TSK_BLUETOOTH_PAIRING:\r\n                in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/report/images/bluetooth.png\");\r\n                break;\r\n            case TSK_GPS_BOOKMARK:\r\n                in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/report/images/gpsfav.png\");\r\n                break;\r\n            case TSK_GPS_LAST_KNOWN_LOCATION:\r\n                in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/report/images/gps-lastlocation.png\");\r\n                break;\r\n            case TSK_GPS_SEARCH:\r\n                in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/report/images/gps-search.png\");\r\n                break;\r\n            case TSK_OS_INFO:\r\n                in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/report/images/computer.png\");\r\n                break;\r\n            case TSK_GPS_TRACKPOINT:\r\n                in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/report/images/gps_trackpoint.png\");\r\n                break;\r\n            case TSK_GPS_ROUTE:\r\n                in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/report/images/gps_trackpoint.png\");\r\n                break;\r\n            case TSK_EMAIL_MSG:\r\n                in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/images/mail-icon-16.png\");\r\n                break;\r\n            case TSK_ENCRYPTION_SUSPECTED:\r\n            case TSK_ENCRYPTION_DETECTED:\r\n                in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/images/encrypted-file.png\");\r\n                break;\r\n            case TSK_EXT_MISMATCH_DETECTED:\r\n                in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/images/mismatch-16.png\");\r\n                break;\r\n            case TSK_INTERESTING_ARTIFACT_HIT:\r\n                in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/images/interesting_item.png\");\r\n                break;\r\n            case TSK_INTERESTING_FILE_HIT:\r\n                in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/images/interesting_item.png\");\r\n                break;\r\n            case TSK_PROG_RUN:\r\n                in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/report/images/installed.png\");\r\n                break;\r\n            case TSK_REMOTE_DRIVE:\r\n                in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/report/images/drive_network.png\");\r\n                break;\r\n            case TSK_ACCOUNT:\r\n                in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/report/images/accounts.png\");\r\n                break;\r\n            case TSK_WIFI_NETWORK:\r\n                in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/images/network-wifi.png\");\r\n                break;\r\n            case TSK_WIFI_NETWORK_ADAPTER:\r\n                in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/images/network-wifi.png\");\r\n                break;\r\n            case TSK_SIM_ATTACHED:\r\n                in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/images/sim_card.png\");\r\n                break;\r\n            case TSK_BLUETOOTH_ADAPTER:\r\n                in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/images/Bluetooth.png\");\r\n                break;\r\n            case TSK_DEVICE_INFO:\r\n                in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/images/devices.png\");\r\n                break;\r\n            default:\r\n                logger.log(Level.WARNING, \"useDataTypeIcon: unhandled artifact type = {0}\", dataType);\r\n                in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/report/images/star.png\");\r\n                iconFileName = \"star.png\";\r\n                iconFilePath = subPath + File.separator + iconFileName;\r\n                break;\r\n        }\r\n    } else if (dataType.startsWith(ARTIFACT_TYPE.TSK_ACCOUNT.getDisplayName())) {\r\n        in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/report/images/accounts.png\");\r\n        iconFileName = \"accounts.png\";\r\n        iconFilePath = subPath + File.separator + iconFileName;\r\n    } else {\r\n        in = getClass().getResourceAsStream(\"/org/sleuthkit/autopsy/report/images/star.png\");\r\n        iconFileName = \"star.png\";\r\n        iconFilePath = subPath + File.separator + iconFileName;\r\n    }\r\n    try {\r\n        output = new FileOutputStream(iconFilePath);\r\n        FileUtil.copy(in, output);\r\n        in.close();\r\n        output.close();\r\n    } catch (IOException ex) {\r\n        logger.log(Level.SEVERE, \"Failed to extract images for HTML report.\", ex);\r\n    } finally {\r\n        if (output != null) {\r\n            try {\r\n                output.flush();\r\n                output.close();\r\n            } catch (IOException ex) {\r\n            }\r\n        }\r\n        if (in != null) {\r\n            try {\r\n                in.close();\r\n            } catch (IOException ex) {\r\n            }\r\n        }\r\n    }\r\n    return iconFileName;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.AddImageWizardAddingProgressPanel.dataSourceProcessorDone",
	"Comment": "callback for the data source processor. invoked by the dsp on the edtthread, when it finishes processing the data source.",
	"Method": "void dataSourceProcessorDone(UUID dataSourceId,DataSourceProcessorCallback.DataSourceProcessorResult result,List<String> errList,List<Content> contents){\r\n    cleanupTask.disable();\r\n    if (PlatformUtil.isWindowsOS() == true) {\r\n        java.awt.Toolkit.getDefaultToolkit().beep();\r\n    }\r\n    AddImageWizardAddingProgressVisual panel = getComponent();\r\n    if (panel != null) {\r\n        Window w = SwingUtilities.getWindowAncestor(panel);\r\n        if (w != null) {\r\n            w.toFront();\r\n        }\r\n    }\r\n    setStateFinished();\r\n    if (result == DataSourceProcessorCallback.DataSourceProcessorResult.NO_ERRORS) {\r\n        getComponent().setProgressBarTextAndColor(NbBundle.getMessage(this.getClass(), \"AddImageWizardIngestConfigPanel.dsProcDone.noErrs.text\"), 100, Color.black);\r\n    } else {\r\n        getComponent().setProgressBarTextAndColor(NbBundle.getMessage(this.getClass(), \"AddImageWizardIngestConfigPanel.dsProcDone.errs.text\"), 100, Color.red);\r\n    }\r\n    boolean critErr = false;\r\n    if (result == DataSourceProcessorCallback.DataSourceProcessorResult.CRITICAL_ERRORS) {\r\n        critErr = true;\r\n    }\r\n    for (String err : errList) {\r\n        addErrors(err, critErr);\r\n    }\r\n    new Thread(() -> {\r\n        try {\r\n            if (!contents.isEmpty()) {\r\n                Case.getCurrentCaseThrows().notifyDataSourceAdded(contents.get(0), dataSourceId);\r\n            } else {\r\n                Case.getCurrentCaseThrows().notifyFailedAddingDataSource(dataSourceId);\r\n            }\r\n        } catch (NoCurrentCaseException ex) {\r\n            Logger.getLogger(AddImageWizardAddingProgressVisual.class.getName()).log(Level.SEVERE, \"Exception while getting open case.\", ex);\r\n        }\r\n    }).start();\r\n    if (!cancelled) {\r\n        newContents.clear();\r\n        newContents.addAll(contents);\r\n        setStateStarted();\r\n        startIngest();\r\n    } else {\r\n        cancelled = false;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.examples.SampleIngestModuleFactory.isDataSourceIngestModuleFactory",
	"Comment": "queries the factory to determine if it is capable of creating data sourceingest modules. if the module family does not include data source ingestmodules, the factory may extend ingestmodulefactoryadapter to get animplementation of this method that returns false.",
	"Method": "boolean isDataSourceIngestModuleFactory(){\r\n    return true;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.QueryResults.getKeywords",
	"Comment": "gets the set of unique keywords for which keyword hits have been storedin this object.",
	"Method": "Set<Keyword> getKeywords(){\r\n    return results.keySet();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.filesearch.FileSearchPanel.getQuery",
	"Comment": "gets the sql query to get the data from the database based on thecriteria that user chooses on the filesearch.",
	"Method": "String getQuery(){\r\n    String query = \"\";\r\n    int i = 0;\r\n    for (FileSearchFilter f : this.getEnabledFilters()) {\r\n        String result = f.getPredicate();\r\n        if (!result.isEmpty()) {\r\n            if (i > 0) {\r\n                query += \" AND (\" + result + \")\";\r\n            } else {\r\n                query += \" (\" + result + \")\";\r\n            }\r\n            ++i;\r\n        }\r\n    }\r\n    if (query.isEmpty()) {\r\n        throw new FilterValidationException(EMPTY_WHERE_CLAUSE);\r\n    }\r\n    return query;\r\n}"
}, {
	"Path": "com.aliyun.oss.common.utils.IniEditor.sectionNames",
	"Comment": "returns all section names in this instance minus the common section ifone was defined.",
	"Method": "List<String> sectionNames(){\r\n    List<String> sectList = new ArrayList<String>(this.sectionOrder);\r\n    if (this.commonName != null) {\r\n        sectList.remove(this.commonName);\r\n    }\r\n    return sectList;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.guiutils.DurationCellRenderer.longToDurationString",
	"Comment": "convert a duration represented by a long to a human readable string withwith days, hours, minutes, and seconds components.",
	"Method": "String longToDurationString(long duration){\r\n    Duration d = Duration.ofMillis(duration);\r\n    if (d.isNegative()) {\r\n        d = Duration.ofMillis(-duration);\r\n    }\r\n    String result;\r\n    long days = d.toDays();\r\n    long hours = d.minusDays(days).toHours();\r\n    long minutes = d.minusDays(days).minusHours(hours).toMinutes();\r\n    long seconds = d.minusDays(days).minusHours(hours).minusMinutes(minutes).getSeconds();\r\n    if (minutes > 0) {\r\n        if (hours > 0) {\r\n            if (days > 0) {\r\n                result = days + \" d  \" + hours + \" h  \" + minutes + \" m \" + seconds + \" s\";\r\n            } else {\r\n                result = hours + \" h  \" + minutes + \" m \" + seconds + \" s\";\r\n            }\r\n        } else {\r\n            result = minutes + \" m \" + seconds + \" s\";\r\n        }\r\n    } else {\r\n        result = seconds + \" s\";\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.wikipedia.page.shareafact.SnippetImage.optimizeTextSize",
	"Comment": "if the title or text is too long we first reduce the font size.if that is not enough it gets ellipsized.",
	"Method": "StaticLayout optimizeTextSize(TextLayoutParams params,int maxHeight,int maxLines,float maxFontSize,float minFontSize){\r\n    final float threshold1 = 60.0f;\r\n    final float threshold2 = 40.0f;\r\n    final float extraStep1 = 3.0f;\r\n    final float extraStep2 = 1.0f;\r\n    boolean fits = false;\r\n    StaticLayout textLayout = null;\r\n    for (float fontSize = maxFontSize; fontSize >= minFontSize; fontSize -= 1.0f) {\r\n        params.textPaint.setTextSize(fontSize);\r\n        textLayout = buildLayout(params);\r\n        if (textLayout.getHeight() <= maxHeight) {\r\n            fits = true;\r\n            break;\r\n        }\r\n        if (fontSize > threshold1) {\r\n            fontSize -= extraStep1;\r\n        } else if (fontSize > threshold2) {\r\n            fontSize -= extraStep2;\r\n        }\r\n    }\r\n    if (!fits) {\r\n        final String textStr = params.text.toString();\r\n        final int ellipsisLength = 3;\r\n        final int ellipsisStart = textLayout != null ? textLayout.getLineStart(maxLines) - ellipsisLength : textStr.length();\r\n        final int end = textStr.lastIndexOf(' ', ellipsisStart) + 1;\r\n        if (end > 0) {\r\n            textLayout = buildLayout(new TextLayoutParams(params, textStr.substring(0, end) + \"...\"));\r\n            if (textLayout.getLineCount() <= maxLines) {\r\n                fits = true;\r\n            }\r\n        }\r\n    }\r\n    if (!fits) {\r\n        final float textRatio = .87f;\r\n        final float maxWidth = textRatio * maxLines * params.lineWidth;\r\n        textLayout = buildLayout(new TextLayoutParams(params, TextUtils.ellipsize(params.text, params.textPaint, maxWidth, TextUtils.TruncateAt.END)));\r\n    }\r\n    return textLayout;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.LocalDiskDSProcessor.reset",
	"Comment": "resets the selection and configuration panel for this data sourceprocessor.",
	"Method": "void reset(){\r\n    deviceId = null;\r\n    drivePath = null;\r\n    timeZone = null;\r\n    ignoreFatOrphanFiles = false;\r\n    setDataSourceOptionsCalled = false;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJobLogger.log",
	"Comment": "writes a message to the case auto ingest log.an exclusive coordination service lock on the log file is used toserialize access to the log file by each auto ingest node so that logentries do not become garbled.",
	"Method": "void log(MessageCategory category,String message){\r\n    Path logPath = getLogPath(caseDirectoryPath);\r\n    try (Lock lock = CoordinationService.getInstance().tryGetExclusiveLock(CoordinationService.CategoryNode.CASES, logPath.toString(), LOCK_TIME_OUT, LOCK_TIME_OUT_UNIT)) {\r\n        if (null != lock) {\r\n            File logFile = logPath.toFile();\r\n            try (PrintWriter writer = new PrintWriter(new BufferedWriter(new FileWriter(logFile, logFile.exists())), true)) {\r\n                writer.println(String.format(\"%-8s: %s %s: %s: %s: %s\", category.toString(), logDateFormat.format((Date.from(Instant.now()).getTime())), hostName, manifestFileName, dataSourceFileName, message));\r\n            } catch (IOException ex) {\r\n                throw new AutoIngestJobLoggerException(String.format(\"Failed to write case auto ingest log message (\\\"%s\\\") for %s\", message, manifestPath), ex);\r\n            }\r\n        } else {\r\n            throw new AutoIngestJobLoggerException(String.format(\"Failed to write case auto ingest log message (\\\"%s\\\") for %s due to time out acquiring log lock\", message, manifestPath));\r\n        }\r\n    } catch (CoordinationServiceException ex) {\r\n        throw new AutoIngestJobLoggerException(String.format(\"Failed to write case auto ingest log message (\\\"%s\\\") for %s\", message, manifestPath), ex);\r\n    }\r\n}"
}, {
	"Path": "com.mcxiaoke.next.collection.WeakFastHashMap.put",
	"Comment": "associate the specified value with the specified key in this map.if the map previously contained a mapping for this key, the oldvalue is replaced and returned.",
	"Method": "V put(K key,V value){\r\n    if (fast) {\r\n        synchronized (this) {\r\n            Map<K, V> temp = cloneMap(map);\r\n            V result = temp.put(key, value);\r\n            map = temp;\r\n            return (result);\r\n        }\r\n    } else {\r\n        synchronized (map) {\r\n            return (map.put(key, value));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.configuration.SharedConfiguration.saveNonSharedSettings",
	"Comment": "save any settings that should not be overwritten by the sharedconfiguration.",
	"Method": "void saveNonSharedSettings(){\r\n    sharedConfigMaster = AutoIngestUserPreferences.getSharedConfigMaster();\r\n    sharedConfigFolder = AutoIngestUserPreferences.getSharedConfigFolder();\r\n    showToolsWarning = AutoIngestUserPreferences.getShowToolsWarning();\r\n    displayLocalTime = UserPreferences.displayTimesInLocalTime();\r\n    hideKnownFilesInDataSource = UserPreferences.hideKnownFilesInDataSourcesTree();\r\n    hideKnownFilesInViews = UserPreferences.hideKnownFilesInViewsTree();\r\n    keepPreferredViewer = UserPreferences.keepPreferredContentViewer();\r\n    fileIngestThreads = UserPreferences.numberOfFileIngestThreads();\r\n    hideSlackFilesInDataSource = UserPreferences.hideSlackFilesInDataSourcesTree();\r\n    hideSlackFilesInViews = UserPreferences.hideSlackFilesInViewsTree();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.datamodel.FileNode.setIcon",
	"Comment": "sets the icon for the node, based on properties of the abstractfile.",
	"Method": "void setIcon(AbstractFile file){\r\n    if (file.isDirNameFlagSet(TSK_FS_NAME_FLAG_ENUM.UNALLOC)) {\r\n        if (file.getType().equals(TSK_DB_FILES_TYPE_ENUM.CARVED)) {\r\n            this.setIconBaseWithExtension(\"org/sleuthkit/autopsy/images/carved-file-icon-16.png\");\r\n        } else {\r\n            this.setIconBaseWithExtension(\"org/sleuthkit/autopsy/images/file-icon-deleted.png\");\r\n        }\r\n    } else {\r\n        this.setIconBaseWithExtension(getIconForFileType(file));\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.examples.SampleIngestModuleFactory.isFileIngestModuleFactory",
	"Comment": "queries the factory to determine if it is capable of creating file ingestmodules. if the module family does not include file ingest modules, thefactory may extend ingestmodulefactoryadapter to get an implementation ofthis method that returns false.",
	"Method": "boolean isFileIngestModuleFactory(){\r\n    return true;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.ModuleContentEvent.getModuleName",
	"Comment": "gets the name of the module that added the content, if the module namehas been provided.",
	"Method": "String getModuleName(){\r\n    return moduleName;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.ImageUtils.getIcon",
	"Comment": "get a thumbnail of a specified size for the given image. generates thethumbnail if it is not already cached.",
	"Method": "BufferedImage getIcon(Content content,int iconSize){\r\n    return getThumbnail(content, iconSize);\r\n}"
}, {
	"Path": "com.mcxiaoke.next.utils.ReflectionUtils.handleInvocationTargetException",
	"Comment": "handle the given invocation target exception. should only be called if nochecked exception is expected to be thrown by the target method.throws the underlying runtimeexception or error in case of such a rootcause. throws an illegalstateexception else.",
	"Method": "void handleInvocationTargetException(InvocationTargetException ex){\r\n    rethrowRuntimeException(ex.getTargetException());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestTasksScheduler.getTopLevelFiles",
	"Comment": "gets the top level files such as file system root directories, layoutfiles and virtual directories for a data source. used to create filetasks to put into the root directories queue.",
	"Method": "List<AbstractFile> getTopLevelFiles(Content dataSource){\r\n    List<AbstractFile> topLevelFiles = new ArrayList();\r\n    Collection<AbstractFile> rootObjects = dataSource.accept(new GetRootDirectoryVisitor());\r\n    if (rootObjects.isEmpty() && dataSource instanceof AbstractFile) {\r\n        topLevelFiles.add((AbstractFile) dataSource);\r\n    } else {\r\n        for (AbstractFile root : rootObjects) {\r\n            List<Content> children;\r\n            try {\r\n                children = root.getChildren();\r\n                if (children.isEmpty()) {\r\n                    topLevelFiles.add(root);\r\n                } else {\r\n                    for (Content child : children) {\r\n                        if (child instanceof AbstractFile) {\r\n                            topLevelFiles.add((AbstractFile) child);\r\n                        }\r\n                    }\r\n                }\r\n            } catch (TskCoreException ex) {\r\n                logger.log(Level.WARNING, \"Could not get children of root to enqueue: \" + root.getId() + \": \" + root.getName(), ex);\r\n            }\r\n        }\r\n    }\r\n    return topLevelFiles;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.volatilityDSP.MemoryDSInputPanel.warnIfPathIsInvalid",
	"Comment": "validates path to selected data source and displays warning if it isinvalid.",
	"Method": "void warnIfPathIsInvalid(String path){\r\n    try {\r\n        if (!PathValidator.isValidForMultiUserCase(path, Case.getCurrentCaseThrows().getCaseType())) {\r\n            errorLabel.setVisible(true);\r\n            errorLabel.setText(Bundle.MemoryDSInputPanel_errorMsg_dataSourcePathOnCdrive());\r\n        }\r\n    } catch (NoCurrentCaseException unused) {\r\n        errorLabel.setVisible(true);\r\n        errorLabel.setText(Bundle.MemoryDSInputPanel_errorMsg_dataSourcePathOnCdrive());\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestManager.addPropertyChangeListener",
	"Comment": "adds an ingest job and ingest module event property change listener.",
	"Method": "void addPropertyChangeListener(PropertyChangeListener listener){\r\n    instance.addIngestJobEventListener(listener);\r\n    instance.addIngestModuleEventListener(listener);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.runIngestModuleWizard.IngestProfileSelectionPanel.updateSelectedProfile",
	"Comment": "handles the change to selected profile if custom settings button is selected, it enables the next button, otherwiseit enables the finish button.",
	"Method": "void updateSelectedProfile(){\r\n    ButtonModel selectedButton = profileListButtonGroup.getSelection();\r\n    selectedProfile = selectedButton.getActionCommand();\r\n    boolean wasLastPanel = isLastPanel;\r\n    isLastPanel = !selectedProfile.equals(wizardPanel.getDefaultContext());\r\n    wizardPanel.fireChangeEvent();\r\n    this.firePropertyChange(\"LAST_ENABLED\", wasLastPanel, isLastPanel);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.DataSourceIngestModuleProgress.switchToIndeterminate",
	"Comment": "switches the progress bar to indeterminate mode. this should be called ifthe total work units to process the data source is unknown.",
	"Method": "void switchToIndeterminate(){\r\n    this.job.switchDataSourceIngestProgressBarToIndeterminate();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.datamodel.DrawableDB.getDataSourceDbBuildStatus",
	"Comment": "gets all data source object ids from datasources table, and theirdrawabledbbuildstatusenum",
	"Method": "Map<Long, DrawableDbBuildStatusEnum> getDataSourceDbBuildStatus(DrawableDbBuildStatusEnum getDataSourceDbBuildStatus,Long dataSourceId){\r\n    Map<Long, DrawableDbBuildStatusEnum> statusMap = getDataSourceDbBuildStatus();\r\n    if (statusMap.containsKey(dataSourceId) == false) {\r\n        throw new TskCoreException(\"Data Source ID not found: \" + dataSourceId);\r\n    }\r\n    return statusMap.get(dataSourceId);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.Case.getCacheDirectory",
	"Comment": "gets the full path to the cache directory for this case, creating it ifit does not exist.",
	"Method": "String getCacheDirectory(){\r\n    return getOrCreateSubdirectory(CACHE_FOLDER);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.hashdatabase.ImportCentralRepoDbProgressDialog.getDatabase",
	"Comment": "get the hashdb object for the newly imported data. should be called afterimportfile completes.",
	"Method": "HashDbManager.HashDb getDatabase(HashDbManager.CentralRepoHashSet getDatabase){\r\n    if (worker != null) {\r\n        return worker.getDatabase();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.dongliu.apk.parser.AbstractApkFile.getAllIcons",
	"Comment": "this method return icons specified in android manifest file, application.the icons could be file icon, color icon, or adaptive icon, etc.",
	"Method": "List<IconFace> getAllIcons(){\r\n    List<IconPath> iconPaths = getIconPaths();\r\n    if (iconPaths.isEmpty()) {\r\n        return Collections.emptyList();\r\n    }\r\n    List<IconFace> iconFaces = new ArrayList(iconPaths.size());\r\n    for (IconPath iconPath : iconPaths) {\r\n        String filePath = iconPath.getPath();\r\n        if (filePath.endsWith(\".xml\")) {\r\n            byte[] data = getFileData(filePath);\r\n            if (data == null) {\r\n                continue;\r\n            }\r\n            parseResourceTable();\r\n            AdaptiveIconParser iconParser = new AdaptiveIconParser();\r\n            transBinaryXml(data, iconParser);\r\n            Icon backgroundIcon = null;\r\n            if (iconParser.getBackground() != null) {\r\n                backgroundIcon = newFileIcon(iconParser.getBackground(), iconPath.getDensity());\r\n            }\r\n            Icon foregroundIcon = null;\r\n            if (iconParser.getForeground() != null) {\r\n                foregroundIcon = newFileIcon(iconParser.getForeground(), iconPath.getDensity());\r\n            }\r\n            AdaptiveIcon icon = new AdaptiveIcon(foregroundIcon, backgroundIcon);\r\n            iconFaces.add(icon);\r\n        } else {\r\n            Icon icon = newFileIcon(filePath, iconPath.getDensity());\r\n            iconFaces.add(icon);\r\n        }\r\n    }\r\n    return iconFaces;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.ImageUtils.getCachedThumbnailFile",
	"Comment": "get a thumbnail of a specified size for the given image. generates thethumbnail if it is not already cached.",
	"Method": "File getCachedThumbnailFile(Content content,int iconSize){\r\n    getThumbnail(content, iconSize);\r\n    return getCachedThumbnailLocation(content.getId());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJobNodeData.getCaseDirectoryPath",
	"Comment": "gets the path to the case directory of the case associated with the job.",
	"Method": "Path getCaseDirectoryPath(){\r\n    if (!caseDirectoryPath.isEmpty()) {\r\n        return Paths.get(caseDirectoryPath);\r\n    } else {\r\n        return Paths.get(\"\");\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestJobSettings.setIngestModuleTemplates",
	"Comment": "sets the enabled ingest module templates for the ingest job.",
	"Method": "void setIngestModuleTemplates(List<IngestModuleTemplate> moduleTemplates){\r\n    this.moduleTemplates.clear();\r\n    this.moduleTemplates.addAll(moduleTemplates);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.LocalFilesPanel.getFileSetName",
	"Comment": "get the name given to this collection of local files and directories",
	"Method": "String getFileSetName(){\r\n    return this.displayName;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.progress.ModalDialogProgressIndicator.finish",
	"Comment": "finishes the progress indicator when the task is completed.",
	"Method": "void finish(){\r\n    SwingUtilities.invokeLater(() -> {\r\n        this.dialog.setVisible(false);\r\n        this.dialog.dispose();\r\n    });\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.Chunker.readBaseChunk",
	"Comment": "read the base chunk from the reader, attempting to break at whitespace.",
	"Method": "StringBuilder readBaseChunk(){\r\n    StringBuilder currentChunk = new StringBuilder();\r\n    readHelper(MINIMUM_BASE_CHUNK_SIZE, currentChunk);\r\n    readToWhiteSpaceHelper(MAXIMUM_BASE_CHUNK_SIZE, currentChunk);\r\n    return currentChunk;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.datamodel.FilteredEventsModel.postRefreshRequest",
	"Comment": "post a refreshrequestedevent to all registered subscribers.",
	"Method": "void postRefreshRequest(){\r\n    eventbus.post(new RefreshRequestedEvent());\r\n}"
}, {
	"Path": "com.klinker.android.peekview.PeekView.hide",
	"Comment": "hide the peekview and remove it from the android.r.id.content framelayout.",
	"Method": "void hide(){\r\n    ObjectAnimator animator = ObjectAnimator.ofFloat(this, View.ALPHA, 1.0f, 0.0f);\r\n    animator.addListener(new AnimatorEndListener() {\r\n        @Override\r\n        public void onAnimationEnd(Animator animator) {\r\n            androidContentView.removeView(PeekView.this);\r\n            if (callbacks != null) {\r\n                callbacks.dismissed();\r\n            }\r\n        }\r\n    });\r\n    animator.setDuration(options.useFadeAnimation() ? ANIMATION_TIME : 0);\r\n    animator.setInterpolator(INTERPOLATOR);\r\n    animator.start();\r\n    Blurry.delete((ViewGroup) androidContentView.getRootView());\r\n}"
}, {
	"Path": "com.klinker.android.peekview.PeekView.hide",
	"Comment": "hide the peekview and remove it from the android.r.id.content framelayout.",
	"Method": "void hide(){\r\n    androidContentView.removeView(PeekView.this);\r\n    if (callbacks != null) {\r\n        callbacks.dismissed();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.ThumbnailCache.get",
	"Comment": "get the cached thumbnail for the given file or generate a new one ifneeded",
	"Method": "Image get(DrawableFile file,Image get,Long fileID){\r\n    try {\r\n        return get(controller.getFileFromID(fileID));\r\n    } catch (TskCoreException ex) {\r\n        LOGGER.log(Level.WARNING, \"Failed to load thumbnail for file: \" + fileID, ex.getCause());\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.communications.PinnedAccountModel.isEmpty",
	"Comment": "are there any accounts in this graph? if there are no pinned accounts thegraph will be empty.",
	"Method": "boolean isEmpty(){\r\n    return pinnedAccountDevices.isEmpty();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.datamodel.SingleEvent.withParent",
	"Comment": "get a new singleevent that is the same as this event, but with the givenparent.",
	"Method": "SingleEvent withParent(MultiEvent<?> newParent){\r\n    SingleEvent singleEvent = new SingleEvent(eventID, dataSourceID, objID, artifactID, time, type, descriptions.get(DescriptionLoD.FULL), descriptions.get(DescriptionLoD.MEDIUM), descriptions.get(DescriptionLoD.SHORT), known, hashHit, tagged);\r\n    singleEvent.parent = newParent;\r\n    return singleEvent;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.datamodel.ArtifactNodeSelectionInfo.matches",
	"Comment": "determines whether or not a given node satisfies the stored nodeselection criteria.",
	"Method": "boolean matches(Node candidateNode){\r\n    BlackboardArtifact artifact = candidateNode.getLookup().lookup(BlackboardArtifact.class);\r\n    return artifact.getArtifactID() == artifactId;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.CorrelationAttributeInstance.getKnownStatus",
	"Comment": "get this knownstatus. this only indicates whether an item has been taggedas notable and should never return known.",
	"Method": "TskData.FileKnown getKnownStatus(){\r\n    return knownStatus;\r\n}"
}, {
	"Path": "com.fernandocejas.arrow.strings.Joiner.skipNulls",
	"Comment": "returns a joiner with the same behavior as this joiner, except automatically skipping over anyprovided null elements.",
	"Method": "Joiner skipNulls(){\r\n    return new Joiner(this) {\r\n        @Override\r\n        public <A extends Appendable> A appendTo(A appendable, Iterator<?> parts) throws IOException {\r\n            checkNotNull(appendable, \"appendable\");\r\n            checkNotNull(parts, \"parts\");\r\n            while (parts.hasNext()) {\r\n                Object part = parts.next();\r\n                if (part != null) {\r\n                    appendable.append(Joiner.this.toString(part));\r\n                    break;\r\n                }\r\n            }\r\n            while (parts.hasNext()) {\r\n                Object part = parts.next();\r\n                if (part != null) {\r\n                    appendable.append(separator);\r\n                    appendable.append(Joiner.this.toString(part));\r\n                }\r\n            }\r\n            return appendable;\r\n        }\r\n        @Override\r\n        public Joiner useForNull(String nullText) {\r\n            throw new UnsupportedOperationException(\"already specified skipNulls\");\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.fernandocejas.arrow.strings.Joiner.skipNulls",
	"Comment": "returns a joiner with the same behavior as this joiner, except automatically skipping over anyprovided null elements.",
	"Method": "Joiner skipNulls(){\r\n    checkNotNull(appendable, \"appendable\");\r\n    checkNotNull(parts, \"parts\");\r\n    while (parts.hasNext()) {\r\n        Object part = parts.next();\r\n        if (part != null) {\r\n            appendable.append(Joiner.this.toString(part));\r\n            break;\r\n        }\r\n    }\r\n    while (parts.hasNext()) {\r\n        Object part = parts.next();\r\n        if (part != null) {\r\n            appendable.append(separator);\r\n            appendable.append(Joiner.this.toString(part));\r\n        }\r\n    }\r\n    return appendable;\r\n}"
}, {
	"Path": "com.fernandocejas.arrow.strings.Joiner.skipNulls",
	"Comment": "returns a joiner with the same behavior as this joiner, except automatically skipping over anyprovided null elements.",
	"Method": "Joiner skipNulls(){\r\n    throw new UnsupportedOperationException(\"already specified skipNulls\");\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.Keyword.searchTermIsWholeWord",
	"Comment": "indicates whether or not the search term for the keyword, if it is aliteral term and not a regex, will be treated as a whole word or as asubstring.",
	"Method": "boolean searchTermIsWholeWord(){\r\n    return isWholeWord;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.datamodel.FileNode.getActions",
	"Comment": "gets the set of actions that are associated with this node. this set isused to construct the context menu for the node.",
	"Method": "Action[] getActions(boolean context){\r\n    List<Action> actionsList = new ArrayList();\r\n    actionsList.addAll(Arrays.asList(super.getActions(true)));\r\n    if (!this.getDirectoryBrowseMode()) {\r\n        actionsList.add(new ViewContextAction(Bundle.FileNode_getActions_viewFileInDir_text(), this));\r\n        actionsList.add(null);\r\n    }\r\n    actionsList.add(new NewWindowViewAction(Bundle.FileNode_getActions_viewInNewWin_text(), this));\r\n    actionsList.add(new ExternalViewerAction(Bundle.FileNode_getActions_openInExtViewer_text(), this));\r\n    actionsList.add(ViewFileInTimelineAction.createViewFileAction(getContent()));\r\n    actionsList.add(null);\r\n    actionsList.add(ExtractAction.getInstance());\r\n    actionsList.add(null);\r\n    actionsList.add(AddContentTagAction.getInstance());\r\n    final Collection<AbstractFile> selectedFilesList = new HashSet(Utilities.actionsGlobalContext().lookupAll(AbstractFile.class));\r\n    if (1 == selectedFilesList.size()) {\r\n        actionsList.add(DeleteFileContentTagAction.getInstance());\r\n    }\r\n    actionsList.addAll(ContextMenuExtensionPoint.getActions());\r\n    if (FileTypeExtensions.getArchiveExtensions().contains(\".\" + this.content.getNameExtension().toLowerCase())) {\r\n        try {\r\n            if (this.content.getArtifacts(BlackboardArtifact.ARTIFACT_TYPE.TSK_ENCRYPTION_DETECTED).size() > 0) {\r\n                actionsList.add(new ExtractArchiveWithPasswordAction(this.getContent()));\r\n            }\r\n        } catch (TskCoreException ex) {\r\n            logger.log(Level.WARNING, \"Unable to add unzip with password action to context menus\", ex);\r\n        }\r\n    }\r\n    return actionsList.toArray(new Action[actionsList.size()]);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJobNodeData.setCaseDirectoryPath",
	"Comment": "sets the path to the case directory of the case associated with the job.",
	"Method": "void setCaseDirectoryPath(Path caseDirectoryPath){\r\n    if (caseDirectoryPath == null) {\r\n        this.caseDirectoryPath = \"\";\r\n    } else {\r\n        this.caseDirectoryPath = caseDirectoryPath.toString();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.IntraCaseCommonAttributeSearcher.findMatches",
	"Comment": "generate a meta data object which encapsulates everything need to add thetree table tab to the top component.",
	"Method": "CommonAttributeSearchResults findMatches(){\r\n    Map<String, CommonAttributeValue> commonFiles = new HashMap();\r\n    final Case currentCase = Case.getCurrentCaseThrows();\r\n    final String caseName = currentCase.getDisplayName();\r\n    SleuthkitCase sleuthkitCase = currentCase.getSleuthkitCase();\r\n    String selectStatement = this.buildSqlSelectStatement();\r\n    try (CaseDbQuery query = sleuthkitCase.executeQuery(selectStatement);\r\n        ResultSet resultSet = query.getResultSet()) {\r\n        while (resultSet.next()) {\r\n            Long objectId = resultSet.getLong(1);\r\n            String md5 = resultSet.getString(2);\r\n            Long dataSourceId = resultSet.getLong(3);\r\n            String dataSource = this.getDataSourceIdToNameMap().get(dataSourceId);\r\n            if (md5 == null || HashUtility.isNoDataMd5(md5)) {\r\n                continue;\r\n            }\r\n            if (commonFiles.containsKey(md5)) {\r\n                final CommonAttributeValue commonAttributeValue = commonFiles.get(md5);\r\n                commonAttributeValue.addInstance(new CaseDBCommonAttributeInstance(objectId, dataSource, caseName));\r\n            } else {\r\n                final CommonAttributeValue commonAttributeValue = new CommonAttributeValue(md5);\r\n                commonAttributeValue.addInstance(new CaseDBCommonAttributeInstance(objectId, dataSource, caseName));\r\n                commonFiles.put(md5, commonAttributeValue);\r\n            }\r\n        }\r\n    }\r\n    Map<Integer, CommonAttributeValueList> instanceCollatedCommonFiles = collateMatchesByNumberOfInstances(commonFiles);\r\n    return new CommonAttributeSearchResults(instanceCollatedCommonFiles, this.frequencyPercentageThreshold);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.DataResultPanel.canClose",
	"Comment": "indicates whether or not this panel can be closed at the time of thecall.",
	"Method": "boolean canClose(){\r\n    Case openCase;\r\n    try {\r\n        openCase = Case.getCurrentCaseThrows();\r\n    } catch (NoCurrentCaseException ex) {\r\n        return true;\r\n    }\r\n    return (!this.isMain) || openCase.hasData() == false;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.filetypeid.AddFileTypePanel.enableButtons",
	"Comment": "enables or disables buttons based on whether or not an item in the listof signatures is selected.",
	"Method": "void enableButtons(){\r\n    if (signatureList.getSelectedIndex() == -1) {\r\n        editSigButton.setEnabled(false);\r\n        deleteSigButton.setEnabled(false);\r\n    } else {\r\n        editSigButton.setEnabled(true);\r\n        deleteSigButton.setEnabled(true);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.db.EventDB.getEventDB",
	"Comment": "public factory method. creates and opens a connection to a database atthe given path. if a database does not already exist at that path, one iscreated.",
	"Method": "EventDB getEventDB(Case autoCase){\r\n    try {\r\n        return new EventDB(autoCase);\r\n    } catch (SQLException ex) {\r\n        LOGGER.log(Level.SEVERE, \"sql error creating database connection\", ex);\r\n        return null;\r\n    } catch (Exception ex) {\r\n        LOGGER.log(Level.SEVERE, \"error creating database connection\", ex);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.LocalFilesDSProcessor.isPanelValid",
	"Comment": "indicates whether the settings in the selection and configuration panelare valid and complete.",
	"Method": "boolean isPanelValid(){\r\n    return configPanel.validatePanel();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.ui.AbstractTimelineChart.getDefaultTooltip",
	"Comment": "get the tool tip to use for this view when no more specific tooltip isneeded.",
	"Method": "Tooltip getDefaultTooltip(){\r\n    return DEFAULT_TOOLTIP;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.DataResultPanel.setContentViewer",
	"Comment": "sets the content view for this result view panel. needs to be calledbefore the first call to open.",
	"Method": "void setContentViewer(DataContent customContentView){\r\n    this.contentView = customContentView;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.DataSourceIngestJob.getConfiguredIngestModuleTemplates",
	"Comment": "uses an input collection of ingest module templates and a pipelineconfiguration, i.e., an ordered list of ingest module factory classnames, to create an ordered output list of ingest module templates for aningest pipeline. the ingest module templates are removed from the inputcollection as they are added to the output collection.",
	"Method": "List<IngestModuleTemplate> getConfiguredIngestModuleTemplates(Map<String, IngestModuleTemplate> ingestModuleTemplates,List<String> pipelineConfig){\r\n    List<IngestModuleTemplate> templates = new ArrayList();\r\n    for (String moduleClassName : pipelineConfig) {\r\n        if (ingestModuleTemplates.containsKey(moduleClassName)) {\r\n            templates.add(ingestModuleTemplates.remove(moduleClassName));\r\n        }\r\n    }\r\n    return templates;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.Server.killSolr",
	"Comment": "kill residual solr processes. note, this method should be used only ifsolr could not be stopped in a graceful manner.",
	"Method": "void killSolr(){\r\n    List<Long> solrPids = getSolrPIDs();\r\n    for (long pid : solrPids) {\r\n        logger.log(Level.INFO, \"Trying to kill old Solr process, PID: {0}\", pid);\r\n        PlatformUtil.killProcess(pid);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.services.TagsManager.getContentTagsCountByTagNameForUser",
	"Comment": "gets content tags count by tag name, for the given data source and user",
	"Method": "long getContentTagsCountByTagNameForUser(TagName tagName,String userName,long getContentTagsCountByTagNameForUser,TagName tagName,long dsObjId,String userName){\r\n    long count = 0;\r\n    List<ContentTag> contentTags = getContentTagsByTagName(tagName, dsObjId);\r\n    for (ContentTag tag : contentTags) {\r\n        if (userName.equals(tag.getUserName())) {\r\n            count++;\r\n        }\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.testutils.CaseUtils.closeCurrentCase",
	"Comment": "closes the current case, and optionally deletes it. asserts if there isno current case or if there is an error closing or deleting the currentcase.",
	"Method": "void closeCurrentCase(boolean deleteCase){\r\n    Case currentCase;\r\n    try {\r\n        currentCase = Case.getCurrentCaseThrows();\r\n    } catch (NoCurrentCaseException ex) {\r\n        Exceptions.printStackTrace(ex);\r\n        Assert.fail(\"Failed to get current case\");\r\n        return;\r\n    }\r\n    String caseName = currentCase.getName();\r\n    String caseDirectory = currentCase.getCaseDirectory();\r\n    try {\r\n        Case.closeCurrentCase();\r\n        if (deleteCase) {\r\n        }\r\n    } catch (CaseActionException ex) {\r\n        Exceptions.printStackTrace(ex);\r\n        Assert.fail(String.format(\"Failed to close case %s at %s: %s\", caseName, caseDirectory, ex.getMessage()));\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.volatilityDSP.MemoryDSProcessor.getPanel",
	"Comment": "gets the panel that allows a user to select a data source and do anyconfiguration required by the data source. the panel is less than 544pixels wide and less than 173 pixels high.",
	"Method": "JPanel getPanel(){\r\n    configPanel.readSettings();\r\n    configPanel.select();\r\n    return configPanel;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.datamodel.CategoryManager.getCategoryCountHelper",
	"Comment": "helper method that looks up the number of files with the given categoryfrom the db and wraps it in a long adder to use in the cache",
	"Method": "LongAdder getCategoryCountHelper(DhsImageCategory cat){\r\n    LongAdder longAdder = new LongAdder();\r\n    longAdder.decrement();\r\n    try {\r\n        longAdder.add(drawableDb.getCategoryCount(cat));\r\n        longAdder.increment();\r\n    } catch (IllegalStateException ex) {\r\n        LOGGER.log(Level.WARNING, \"Case closed while getting files\");\r\n    }\r\n    return longAdder;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.KeywordSearchSettings.getSkipKnown",
	"Comment": "gets the setting for whether or not this ingest is skipping adding knowngood files to the index.",
	"Method": "boolean getSkipKnown(){\r\n    if (ModuleSettings.getConfigSetting(PROPERTIES_NSRL, \"SkipKnown\") != null) {\r\n        return Boolean.parseBoolean(ModuleSettings.getConfigSetting(PROPERTIES_NSRL, \"SkipKnown\"));\r\n    }\r\n    logger.log(Level.WARNING, \"Could not read property for SkipKnown, returning backup value.\");\r\n    return skipKnown;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.configuration.AutoIngestUserPreferences.setSecondsToSleepBetweenCases",
	"Comment": "sets the wait time used by auto ingest nodes to ensure propersynchronization of node operations in circumstances where delays mayoccur, e.g., network file system latency effects on the visibility ofnewly created shared directories and files.",
	"Method": "void setSecondsToSleepBetweenCases(int value){\r\n    ModuleSettings.setConfigSetting(UserPreferences.SETTINGS_PROPERTIES, SLEEP_BETWEEN_CASES_TIME, Integer.toString(value));\r\n}"
}, {
	"Path": "com.google.example.games.catt2.MainActivity.writeSnapshot",
	"Comment": "generates metadata, takes a screenshot, and performs the write operation for saving asnapshot.",
	"Method": "Task<SnapshotMetadata> writeSnapshot(Snapshot snapshot){\r\n    snapshot.getSnapshotContents().writeBytes(mSaveGame.toBytes());\r\n    SnapshotMetadataChange metadataChange = new SnapshotMetadataChange.Builder().setCoverImage(getScreenShot()).setDescription(\"Modified data at: \" + Calendar.getInstance().getTime()).build();\r\n    return SnapshotCoordinator.getInstance().commitAndClose(mSnapshotsClient, snapshot, metadataChange);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.ReportHTML.addSetIndex",
	"Comment": "add an index to the current page for all the sets about to be added.",
	"Method": "void addSetIndex(List<String> sets){\r\n    StringBuilder index = new StringBuilder();\r\n    index.append(\"<ul>\\n\");\r\n    for (String set : sets) {\r\n        index.append(\"\\t<li><a href=\\\"#\").append(set).append(\"\\\">\").append(set).append(\"<\/a><\/li>\\n\");\r\n    }\r\n    index.append(\"<\/ul>\\n\");\r\n    try {\r\n        out.write(index.toString());\r\n    } catch (IOException ex) {\r\n        logger.log(Level.SEVERE, \"Failed to add set index: {0}\", ex);\r\n    }\r\n}"
}, {
	"Path": "org.wikipedia.edit.EditSectionActivity.handleEditingException",
	"Comment": "processes api error codes encountered during editing, and handles them as appropriate.",
	"Method": "void handleEditingException(MwException caught){\r\n    String code = caught.getTitle();\r\n    if (AccountUtil.isLoggedIn() && (\"badtoken\".equals(code) || \"assertuserfailed\".equals(code))) {\r\n        getEditTokenThenSave(true);\r\n        return;\r\n    }\r\n    progressDialog.dismiss();\r\n    if (\"blocked\".equals(code) || \"wikimedia-globalblocking-ipblocked\".equals(code)) {\r\n        AlertDialog.Builder builder = new AlertDialog.Builder(EditSectionActivity.this);\r\n        builder.setTitle(R.string.user_blocked_from_editing_title);\r\n        if (AccountUtil.isLoggedIn()) {\r\n            builder.setMessage(R.string.user_logged_in_blocked_from_editing);\r\n            builder.setPositiveButton(android.R.string.ok, (dialog, i) -> dialog.dismiss());\r\n        } else {\r\n            builder.setMessage(R.string.user_anon_blocked_from_editing);\r\n            builder.setPositiveButton(R.string.nav_item_login, (dialog, i) -> {\r\n                dialog.dismiss();\r\n                Intent loginIntent = LoginActivity.newIntent(EditSectionActivity.this, LoginFunnel.SOURCE_BLOCKED);\r\n                startActivity(loginIntent);\r\n            });\r\n            builder.setNegativeButton(android.R.string.cancel, (dialog, i) -> dialog.dismiss());\r\n        }\r\n        builder.show();\r\n    } else if (\"editconflict\".equals(code)) {\r\n        new AlertDialog.Builder(EditSectionActivity.this).setTitle(R.string.edit_conflict_title).setMessage(R.string.edit_conflict_message).setPositiveButton(android.R.string.ok, null).show();\r\n        resetToStart();\r\n    } else {\r\n        showError(caught);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.directorytree.DirectoryTreeTopComponent.refreshContentTreeSafe",
	"Comment": "refresh the content node part of the dir tree safely in the edt thread",
	"Method": "void refreshContentTreeSafe(){\r\n    SwingUtilities.invokeLater(this::rebuildTree);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.datamodel.DrawableDB.markGroupSeen",
	"Comment": "record in the db that the group with the given key has the given seenstate for the given examiner id.",
	"Method": "void markGroupSeen(GroupKey<?> groupKey,boolean seen,long examinerID){\r\n    Boolean cachedValue = groupSeenCache.getIfPresent(groupKey);\r\n    if (cachedValue != null && cachedValue == seen) {\r\n        return;\r\n    }\r\n    String innerQuery = String.format(\"( SELECT group_id FROM \" + GROUPS_TABLENAME + \" WHERE attribute = \\'%s\\' AND value = \\'%s\\' and data_source_obj_id = %d )\", SleuthkitCase.escapeSingleQuotes(groupKey.getAttribute().attrName.toString()), SleuthkitCase.escapeSingleQuotes(groupKey.getValueDisplayName()), groupKey.getAttribute() == DrawableAttribute.PATH ? groupKey.getDataSourceObjId() : 0);\r\n    String insertSQL = String.format(\" (group_id, examiner_id, seen) VALUES (%s, %d, %d)\", innerQuery, examinerID, seen ? 1 : 0);\r\n    if (DbType.POSTGRESQL == tskCase.getDatabaseType()) {\r\n        insertSQL += String.format(\" ON CONFLICT (group_id, examiner_id) DO UPDATE SET seen = %d\", seen ? 1 : 0);\r\n    }\r\n    tskCase.getCaseDbAccessManager().insertOrUpdate(GROUPS_SEEN_TABLENAME, insertSQL);\r\n    groupSeenCache.put(groupKey, seen);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.runIngestModuleWizard.IngestProfileSelectionWizardPanel.getLastProfilePropertiesFile",
	"Comment": "gets the name of the file which stores the last profile used properties.",
	"Method": "String getLastProfilePropertiesFile(){\r\n    return LAST_PROFILE_PROPERTIES_FILE;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.progress.ModalDialogProgressIndicator.displayDialog",
	"Comment": "creates and dislpays the dialog for the progress indicator.",
	"Method": "void displayDialog(){\r\n    if (null != buttonLabels && null != focusedButtonLabel && null != buttonListener) {\r\n        DialogDescriptor dialogDescriptor = new DialogDescriptor(progressPanel, title, true, buttonLabels, focusedButtonLabel, DialogDescriptor.BOTTOM_ALIGN, HelpCtx.DEFAULT_HELP, buttonListener);\r\n        dialog = DialogDisplayer.getDefault().createDialog(dialogDescriptor, parent);\r\n    } else {\r\n        dialog = new JDialog(parent, title, true);\r\n        dialog.add(progressPanel);\r\n        dialog.pack();\r\n    }\r\n    dialog.setResizable(false);\r\n    dialog.setLocationRelativeTo(parent);\r\n    this.dialog.setVisible(true);\r\n}"
}, {
	"Path": "net.ypresto.androidtranscoder.engine.InputSurface.getSurface",
	"Comment": "returns the surface that the mediacodec receives buffers from.",
	"Method": "Surface getSurface(){\r\n    return mSurface;\r\n}"
}, {
	"Path": "com.aliyun.oss.integrationtests.RequestTimeoutTest.testOperationsNormalAfterPacketLoss",
	"Comment": "test operations after package loss.to simulate package eloss, we use iptables in linux and cut the network in windows.",
	"Method": "void testOperationsNormalAfterPacketLoss(){\r\n    String key = \"test-operation-after-packet-loss\";\r\n    try {\r\n        File file = createSampleFile(key, 1024 * 1024 * 200);\r\n        ossClient.getClientConfiguration().setRequestTimeout(60 * 60 * 1000);\r\n        try {\r\n            ossClient.putObject(bucketName, key, file);\r\n            Assert.fail(\"Get object should not be successful\");\r\n        } catch (ClientException e) {\r\n            Assert.assertEquals(OSSErrorCode.REQUEST_TIMEOUT, e.getErrorCode());\r\n        } finally {\r\n            ossClient.getClientConfiguration().setRequestTimeout(requestTimeout);\r\n        }\r\n        ObjectListing objectListing = ossClient.listObjects(bucketName, key);\r\n        Assert.assertEquals(objectListing.getObjectSummaries().size(), 1);\r\n        ossClient.deleteObject(bucketName, key);\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n        Assert.fail(e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "com.mcxiaoke.next.utils.StringUtils.commaDelimitedListToSet",
	"Comment": "convenience method to convert a csv string list to a set. note that thiswill suppress duplicates.",
	"Method": "Set<String> commaDelimitedListToSet(String str){\r\n    Set<String> set = new TreeSet<String>();\r\n    String[] tokens = commaDelimitedListToStringArray(str);\r\n    Collections.addAll(set, tokens);\r\n    return set;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.filetypeid.FileType.shouldCreateInterestingFileHit",
	"Comment": "should an interesting files hit be created for this file type?",
	"Method": "boolean shouldCreateInterestingFileHit(){\r\n    return createInterestingFileHit;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.utils.RangeDivisionInfo.getRangeDivisionInfo",
	"Comment": "static factory method.determine the period size, number of periods, whole period bounds, andformatters to use to visualize the given timerange.",
	"Method": "RangeDivisionInfo getRangeDivisionInfo(Interval timeRange){\r\n    DateTimeFieldType timeUnit;\r\n    final DateTime startWithZone = timeRange.getStart().withZone(TimeLineController.getJodaTimeZone());\r\n    final DateTime endWithZone = timeRange.getEnd().withZone(TimeLineController.getJodaTimeZone());\r\n    if (Years.yearsIn(timeRange).isGreaterThan(Years.THREE)) {\r\n        timeUnit = DateTimeFieldType.year();\r\n        long lower = startWithZone.property(timeUnit).roundFloorCopy().getMillis();\r\n        long upper = endWithZone.property(timeUnit).roundCeilingCopy().getMillis();\r\n        return new RangeDivisionInfo(timeRange, Years.yearsIn(timeRange).get(timeUnit.getDurationType()) + 1, TimeUnits.YEARS, ISODateTimeFormat.year(), lower, upper);\r\n    } else if (Months.monthsIn(timeRange).isGreaterThan(Months.THREE)) {\r\n        timeUnit = DateTimeFieldType.monthOfYear();\r\n        long lower = startWithZone.property(timeUnit).roundFloorCopy().getMillis();\r\n        long upper = endWithZone.property(timeUnit).roundCeilingCopy().getMillis();\r\n        return new RangeDivisionInfo(timeRange, Months.monthsIn(timeRange).getMonths() + 1, TimeUnits.MONTHS, DateTimeFormat.forPattern(\"YYYY'-'MMMM\"), lower, upper);\r\n    } else if (Days.daysIn(timeRange).isGreaterThan(Days.THREE)) {\r\n        timeUnit = DateTimeFieldType.dayOfMonth();\r\n        long lower = startWithZone.property(timeUnit).roundFloorCopy().getMillis();\r\n        long upper = endWithZone.property(timeUnit).roundCeilingCopy().getMillis();\r\n        return new RangeDivisionInfo(timeRange, Days.daysIn(timeRange).getDays() + 1, TimeUnits.DAYS, DateTimeFormat.forPattern(\"YYYY'-'MMMM'-'dd\"), lower, upper);\r\n    } else if (Hours.hoursIn(timeRange).isGreaterThan(Hours.THREE)) {\r\n        timeUnit = DateTimeFieldType.hourOfDay();\r\n        long lower = startWithZone.property(timeUnit).roundFloorCopy().getMillis();\r\n        long upper = endWithZone.property(timeUnit).roundCeilingCopy().getMillis();\r\n        return new RangeDivisionInfo(timeRange, Hours.hoursIn(timeRange).getHours() + 1, TimeUnits.HOURS, DateTimeFormat.forPattern(\"YYYY'-'MMMM'-'dd HH\"), lower, upper);\r\n    } else if (Minutes.minutesIn(timeRange).isGreaterThan(Minutes.THREE)) {\r\n        timeUnit = DateTimeFieldType.minuteOfHour();\r\n        long lower = startWithZone.property(timeUnit).roundFloorCopy().getMillis();\r\n        long upper = endWithZone.property(timeUnit).roundCeilingCopy().getMillis();\r\n        return new RangeDivisionInfo(timeRange, Minutes.minutesIn(timeRange).getMinutes() + 1, TimeUnits.MINUTES, DateTimeFormat.forPattern(\"YYYY'-'MMMM'-'dd HH':'mm\"), lower, upper);\r\n    } else {\r\n        timeUnit = DateTimeFieldType.secondOfMinute();\r\n        long lower = startWithZone.property(timeUnit).roundFloorCopy().getMillis();\r\n        long upper = endWithZone.property(timeUnit).roundCeilingCopy().getMillis();\r\n        return new RangeDivisionInfo(timeRange, Seconds.secondsIn(timeRange).getSeconds() + 1, TimeUnits.SECONDS, DateTimeFormat.forPattern(\"YYYY'-'MMMM'-'dd HH':'mm':'ss\"), lower, upper);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.db.EventsRepository.getTagCountsByTagName",
	"Comment": "get a count of tagnames applied to the given event ids as a map fromtagname displayname to count of tag applications",
	"Method": "Map<String, Long> getTagCountsByTagName(Set<Long> eventIDsWithTags){\r\n    return eventDB.getTagCountsByTagName(eventIDsWithTags);\r\n}"
}, {
	"Path": "com.aliyun.oss.common.comm.ServiceClient.sendRequest",
	"Comment": "send http request with specified context to oss and wait for httpresponse.",
	"Method": "ResponseMessage sendRequest(RequestMessage request,ExecutionContext context){\r\n    assertParameterNotNull(request, \"request\");\r\n    assertParameterNotNull(context, \"context\");\r\n    try {\r\n        return sendRequestImpl(request, context);\r\n    } finally {\r\n        try {\r\n            request.close();\r\n        } catch (IOException ex) {\r\n            logException(\"Unexpected io exception when trying to close http request: \", ex);\r\n            throw new ClientException(\"Unexpected io exception when trying to close http request: \", ex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.stix.STIXReportModule.processObservables",
	"Comment": "do the initial processing of the list of observables. for eachobservable, save it in a map using the id as key.",
	"Method": "void processObservables(STIXPackage stix){\r\n    if (stix.getObservables() != null) {\r\n        List<Observable> obs = stix.getObservables().getObservables();\r\n        for (Observable o : obs) {\r\n            if (o.getId() != null) {\r\n                saveToObjectMap(o);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.ImageGalleryModule.getModuleOutputDir",
	"Comment": "gets the path to the image gallery module output folder for a given case.",
	"Method": "Path getModuleOutputDir(Case theCase){\r\n    return Paths.get(theCase.getModuleDirectory(), getModuleName());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.communications.PinnedAccountModel.unpinAccount",
	"Comment": "unpin the given accounts from the graph. pinned accounts will always beshown regardless of the filter state. furthermore, accounts withrelationships that pass the filters will also be shown.",
	"Method": "void unpinAccount(ImmutableSet<AccountDeviceInstanceKey> accountDeviceInstances){\r\n    pinnedAccountDevices.removeAll(accountDeviceInstances);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.photoreccarver.PhotoRecCarverFileIngestModule.createModuleOutputDirectoryForCase",
	"Comment": "creates the output directory for this module for the current case, if itdoes not already exist.",
	"Method": "Path createModuleOutputDirectoryForCase(){\r\n    Path path;\r\n    try {\r\n        path = Paths.get(Case.getCurrentCaseThrows().getModuleDirectory(), PhotoRecCarverIngestModuleFactory.getModuleName());\r\n    } catch (NoCurrentCaseException ex) {\r\n        throw new IngestModule.IngestModuleException(Bundle.cannotCreateOutputDir_message(ex.getLocalizedMessage()), ex);\r\n    }\r\n    try {\r\n        Files.createDirectory(path);\r\n        if (UNCPathUtilities.isUNC(path)) {\r\n            path = uncPathUtilities.ipToHostName(path);\r\n            if (path == null) {\r\n                throw new IngestModule.IngestModuleException(Bundle.PhotoRecIngestModule_nonHostnameUNCPathUsed());\r\n            }\r\n            if (false == FileUtil.hasReadWriteAccess(path)) {\r\n                throw new IngestModule.IngestModuleException(Bundle.PhotoRecIngestModule_PermissionsNotSufficient() + SEP + path.toString() + SEP + Bundle.PhotoRecIngestModule_PermissionsNotSufficientSeeReference());\r\n            }\r\n        }\r\n    } catch (FileAlreadyExistsException ex) {\r\n    } catch (IOException | SecurityException | UnsupportedOperationException ex) {\r\n        throw new IngestModule.IngestModuleException(Bundle.cannotCreateOutputDir_message(ex.getLocalizedMessage()), ex);\r\n    }\r\n    return path;\r\n}"
}, {
	"Path": "com.aliyun.oss.model.Owner.toString",
	"Comment": "serialization the owner information into string, including name and id.",
	"Method": "String toString(){\r\n    return \"Owner [name=\" + getDisplayName() + \",id=\" + getId() + \"]\";\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.SQLiteTableReader.closeTableResources",
	"Comment": "ensures both the statement and the result set for a table are closed.",
	"Method": "void closeTableResources(){\r\n    try {\r\n        if (Objects.nonNull(statement)) {\r\n            statement.close();\r\n        }\r\n        if (Objects.nonNull(queryResults)) {\r\n            queryResults.close();\r\n        }\r\n        liveResultSet = false;\r\n    } catch (SQLException ex) {\r\n        logger.log(Level.SEVERE, \"Failed to close table resources\", ex);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.TableReportGenerator.getFilteredArtifacts",
	"Comment": "get a list of the artifacts and data of the given type that pass thegiven tag filter.",
	"Method": "List<ArtifactData> getFilteredArtifacts(BlackboardArtifact.Type type,HashSet<String> tagNamesFilter){\r\n    List<ArtifactData> artifacts = new ArrayList();\r\n    try {\r\n        for (BlackboardArtifact artifact : Case.getCurrentCaseThrows().getSleuthkitCase().getBlackboardArtifacts(type.getTypeID())) {\r\n            List<BlackboardArtifactTag> tags = Case.getCurrentCaseThrows().getServices().getTagsManager().getBlackboardArtifactTagsByArtifact(artifact);\r\n            HashSet<String> uniqueTagNames = new HashSet();\r\n            for (BlackboardArtifactTag tag : tags) {\r\n                String notableString = tag.getName().getKnownStatus() == TskData.FileKnown.BAD ? TagsManager.getNotableTagLabel() : \"\";\r\n                uniqueTagNames.add(tag.getName().getDisplayName() + notableString);\r\n            }\r\n            if (failsTagFilter(uniqueTagNames, tagNamesFilter)) {\r\n                continue;\r\n            }\r\n            try {\r\n                artifacts.add(new ArtifactData(artifact, Case.getCurrentCaseThrows().getSleuthkitCase().getBlackboardAttributes(artifact), uniqueTagNames));\r\n            } catch (TskCoreException ex) {\r\n                errorList.add(NbBundle.getMessage(this.getClass(), \"ReportGenerator.errList.failedGetBBAttribs\"));\r\n                logger.log(Level.SEVERE, \"Failed to get Blackboard Attributes when generating report.\", ex);\r\n            }\r\n        }\r\n    } catch (TskCoreException | NoCurrentCaseException ex) {\r\n        errorList.add(NbBundle.getMessage(this.getClass(), \"ReportGenerator.errList.failedGetBBArtifacts\"));\r\n        logger.log(Level.SEVERE, \"Failed to get Blackboard Artifacts when generating report.\", ex);\r\n    }\r\n    return artifacts;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestManager.stopInputFolderScans",
	"Comment": "cancels any input scan scheduling tasks and input scan tasks and shutsdown their executors.",
	"Method": "void stopInputFolderScans(){\r\n    inputScanSchedulingExecutor.shutdownNow();\r\n    inputScanExecutor.shutdownNow();\r\n    while (!inputScanSchedulingExecutor.awaitTermination(30, TimeUnit.SECONDS)) {\r\n        sysLogger.log(Level.WARNING, \"Auto ingest waited at least thirty seconds for input scan scheduling executor to shut down, continuing to wait\");\r\n    }\r\n    while (!inputScanExecutor.awaitTermination(30, TimeUnit.SECONDS)) {\r\n        sysLogger.log(Level.WARNING, \"Auto ingest waited at least thirty seconds for input scan executor to shut down, continuing to wait\");\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.hashdatabase.HashDbManager.getKnownBadFileHashSets",
	"Comment": "gets all of the hash databases used to classify files as notable.",
	"Method": "List<HashDb> getKnownBadFileHashSets(){\r\n    List<HashDb> hashDbs = new ArrayList();\r\n    try {\r\n        updateHashSetsFromCentralRepository();\r\n    } catch (TskCoreException ex) {\r\n        Logger.getLogger(HashDbManager.class.getName()).log(Level.SEVERE, \"Error loading central repository hash sets\", ex);\r\n    }\r\n    this.hashSets.stream().filter((db) -> (db.getKnownFilesType() == HashDb.KnownFilesType.KNOWN_BAD)).forEach((db) -> {\r\n        hashDbs.add(db);\r\n    });\r\n    return hashDbs;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.test.CustomArtifactsCreatorDataSourceIngestModule.process",
	"Comment": "creates a custom artifact instance associated with the data source to beprocessed.",
	"Method": "ProcessResult process(Content dataSource,DataSourceIngestModuleProgress progressBar){\r\n    try {\r\n        CustomArtifactType.createInstance(dataSource);\r\n    } catch (TskCoreException ex) {\r\n        logger.log(Level.SEVERE, String.format(\"Failed to process data source (obj_id = %d)\", dataSource.getId()), ex);\r\n        return ProcessResult.ERROR;\r\n    }\r\n    return ProcessResult.OK;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestControlPanel.bnDeleteCaseActionPerformed",
	"Comment": "handles a click on the delete case button. if an entry is selected thatcan be deleted, pops up a confirmation dialog. upon confirmation, asksautoingestmanager to delete the entry and asks for an updated view.",
	"Method": "void bnDeleteCaseActionPerformed(java.awt.event.ActionEvent evt){\r\n    if (completedTable.getModel().getRowCount() < 0 || completedTable.getSelectedRow() < 0) {\r\n        return;\r\n    }\r\n    String caseName = (String) completedTable.getModel().getValueAt(completedTable.convertRowIndexToModel(completedTable.getSelectedRow()), JobsTableModelColumns.CASE.ordinal());\r\n    Object[] options = { org.openide.util.NbBundle.getMessage(AutoIngestControlPanel.class, \"ConfirmationDialog.Delete\"), org.openide.util.NbBundle.getMessage(AutoIngestControlPanel.class, \"ConfirmationDialog.DoNotDelete\") };\r\n    Object[] msgContent = { org.openide.util.NbBundle.getMessage(AutoIngestControlPanel.class, \"ConfirmationDialog.DeleteAreYouSure\") + \"\\\"\" + caseName + \"\\\"?\" };\r\n    int reply = JOptionPane.showOptionDialog(this, msgContent, org.openide.util.NbBundle.getMessage(AutoIngestControlPanel.class, \"ConfirmationDialog.ConfirmDeletionHeader\"), JOptionPane.DEFAULT_OPTION, JOptionPane.WARNING_MESSAGE, null, options, options[JOptionPane.NO_OPTION]);\r\n    if (reply == JOptionPane.YES_OPTION) {\r\n        bnDeleteCase.setEnabled(false);\r\n        bnShowCaseLog.setEnabled(false);\r\n        if (completedTable.getModel().getRowCount() > 0 && completedTable.getSelectedRow() >= 0) {\r\n            Path caseDirectoryPath = (Path) completedTable.getModel().getValueAt(completedTable.convertRowIndexToModel(completedTable.getSelectedRow()), JobsTableModelColumns.CASE_DIRECTORY_PATH.ordinal());\r\n            completedTable.clearSelection();\r\n            this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\r\n            CaseDeletionResult result = manager.deleteCase(caseName, caseDirectoryPath);\r\n            refreshTables();\r\n            this.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));\r\n            if (CaseDeletionResult.FAILED == result) {\r\n                JOptionPane.showMessageDialog(this, String.format(\"Could not delete case %s. It may be in use.\", caseName), org.openide.util.NbBundle.getMessage(AutoIngestControlPanel.class, \"AutoIngestControlPanel.DeletionFailed\"), JOptionPane.INFORMATION_MESSAGE);\r\n            } else if (CaseDeletionResult.PARTIALLY_DELETED == result) {\r\n                JOptionPane.showMessageDialog(this, String.format(\"Could not fully delete case %s. See system log for details.\", caseName), org.openide.util.NbBundle.getMessage(AutoIngestControlPanel.class, \"AutoIngestControlPanel.DeletionFailed\"), JOptionPane.INFORMATION_MESSAGE);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.datamodel.grouping.GroupManager.regroup",
	"Comment": "regroup all files in the database. see regrouptask for more details.",
	"Method": "void regroup(DataSource dataSource,DrawableAttribute<A> groupBy,GroupSortBy sortBy,SortOrder sortOrder,Boolean force){\r\n    if (!Case.isCaseOpen()) {\r\n        return;\r\n    }\r\n    setSortBy(sortBy);\r\n    setSortOrder(sortOrder);\r\n    if (dataSource != getDataSource() || groupBy != getGroupBy() || force) {\r\n        setDataSource(dataSource);\r\n        setGroupBy(groupBy);\r\n        Platform.runLater(regrouper::restart);\r\n    } else {\r\n        sortAnalyzedGroups();\r\n        sortUnseenGroups();\r\n    }\r\n}"
}, {
	"Path": "com.google.example.games.catt2.SaveGame.unionWith",
	"Comment": "computes the union of this savegame with the given savegame. the union will have anylevels present in either operand. if the same level is present in both operands,then the number of stars will be the greatest of the two.",
	"Method": "SaveGame unionWith(SaveGame other){\r\n    SaveGame result = clone();\r\n    for (String levelName : other.mLevelStars.keySet()) {\r\n        int existingStars = result.getLevelStars(levelName);\r\n        int newStars = other.getLevelStars(levelName);\r\n        if (newStars > existingStars) {\r\n            result.setLevelStars(levelName, newStars);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.datamodel.FileTypes.updateShowCounts",
	"Comment": "check the db to determine if the nodes should show child counts.",
	"Method": "void updateShowCounts(){\r\n    if (showCounts) {\r\n        try {\r\n            if (skCase.countFilesWhere(\"1=1\") > NODE_COUNT_FILE_TABLE_THRESHOLD) {\r\n                showCounts = false;\r\n            }\r\n        } catch (TskCoreException tskCoreException) {\r\n            showCounts = false;\r\n            logger.log(Level.SEVERE, \"Error counting files.\", tskCoreException);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.klinker.android.peekview.builder.Peek.applyTo",
	"Comment": "finish the builder by selecting the base view that you want to show the peekview from.",
	"Method": "void applyTo(PeekViewActivity activity,View base){\r\n    final GestureDetectorCompat detector = new GestureDetectorCompat(activity, new GestureListener(activity, base, this));\r\n    base.setOnTouchListener(new View.OnTouchListener() {\r\n        @Override\r\n        public boolean onTouch(View view, final MotionEvent motionEvent) {\r\n            detector.onTouchEvent(motionEvent);\r\n            if (motionEvent.getAction() == MotionEvent.ACTION_DOWN) {\r\n                forceRippleAnimation(base, motionEvent);\r\n            }\r\n            return true;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.klinker.android.peekview.builder.Peek.applyTo",
	"Comment": "finish the builder by selecting the base view that you want to show the peekview from.",
	"Method": "void applyTo(PeekViewActivity activity,View base){\r\n    detector.onTouchEvent(motionEvent);\r\n    if (motionEvent.getAction() == MotionEvent.ACTION_DOWN) {\r\n        forceRippleAnimation(base, motionEvent);\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.gui.GuiUtils.createAutoAssigningMenuItem",
	"Comment": "create a menuitem that performs the given action and also set the actionas the action for the given button. usefull to have a splitmenubuttonremember the last chosen menu item as its action.",
	"Method": "MenuItem createAutoAssigningMenuItem(ButtonBase button,Action action){\r\n    MenuItem menuItem = ActionUtils.createMenuItem(action);\r\n    menuItem.setOnAction(actionEvent -> {\r\n        action.handle(actionEvent);\r\n        button.setText(action.getText());\r\n        button.setGraphic(menuItem.getGraphic());\r\n        button.setOnAction(action);\r\n    });\r\n    return menuItem;\r\n}"
}, {
	"Path": "org.wikipedia.page.PageTitle.withSeparateFragment",
	"Comment": "creates a new pagetitle object.use this if you want to pass in a fragment portion separately from the title.",
	"Method": "PageTitle withSeparateFragment(String prefixedText,String fragment,WikiSite wiki){\r\n    if (TextUtils.isEmpty(fragment)) {\r\n        return new PageTitle(prefixedText, wiki, null, (PageProperties) null);\r\n    } else {\r\n        return new PageTitle(prefixedText + \"#\" + fragment, wiki, null, (PageProperties) null);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.Case.addPropertyChangeListener",
	"Comment": "adds a subscriber to all case events. to subscribe to only specificevents, use one of the overloads of addeventsubscriber.",
	"Method": "void addPropertyChangeListener(PropertyChangeListener listener){\r\n    addEventSubscriber(Stream.of(Events.values()).map(Events::toString).collect(Collectors.toSet()), listener);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestServices.getLogger",
	"Comment": "gets a logger that incorporates the display name of an ingest module inmessages written to the autopsy log files.",
	"Method": "Logger getLogger(String moduleDisplayName){\r\n    return Logger.getLogger(moduleDisplayName);\r\n}"
}, {
	"Path": "com.aliyun.oss.internal.ResponseParsers.parseBucketLogging",
	"Comment": "unmarshall get bucket logging response body to corresponding result.",
	"Method": "BucketLoggingResult parseBucketLogging(InputStream responseBody){\r\n    try {\r\n        Element root = getXmlRootElement(responseBody);\r\n        BucketLoggingResult result = new BucketLoggingResult();\r\n        if (root.getChild(\"LoggingEnabled\") != null) {\r\n            result.setTargetBucket(root.getChild(\"LoggingEnabled\").getChildText(\"TargetBucket\"));\r\n        }\r\n        if (root.getChild(\"LoggingEnabled\") != null) {\r\n            result.setTargetPrefix(root.getChild(\"LoggingEnabled\").getChildText(\"TargetPrefix\"));\r\n        }\r\n        return result;\r\n    } catch (JDOMParseException e) {\r\n        throw new ResponseParseException(e.getPartialDocument() + \": \" + e.getMessage(), e);\r\n    } catch (Exception e) {\r\n        throw new ResponseParseException(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "model.Complex.reciprocal",
	"Comment": "return a new complex object whose value is the reciprocal of this",
	"Method": "Complex reciprocal(){\r\n    double scale = re * re + im * im;\r\n    return new Complex(re / scale, -im / scale);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.RecentCases.updateRecentCase",
	"Comment": "this method is used to update the name and path of a recentcase.",
	"Method": "void updateRecentCase(String oldName,String oldPath,String newName,String newPath){\r\n    RecentCase oldRc = RecentCase.createSafe(oldName, oldPath);\r\n    RecentCase newRc = RecentCase.createSafe(newName, newPath);\r\n    recentCases.removeAll(Arrays.asList(oldRc));\r\n    addRecentCase(newRc);\r\n    this.getMenuPresenter().setVisible(true);\r\n    try {\r\n        storeRecentCases();\r\n    } catch (IOException ex) {\r\n        Logger.getLogger(RecentCases.class.getName()).log(Level.WARNING, \"Error: Could not update the properties file.\", ex);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.Case.isCaseOpen",
	"Comment": "checks if a case, the current case, is open at the time it is called.",
	"Method": "boolean isCaseOpen(){\r\n    return currentCase != null;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.DataSourceIngestJob.addFiles",
	"Comment": "adds more files from the data source for this job to the job, e.g., addsextracted or carved files. not currently supported for the second stageof the job.",
	"Method": "void addFiles(List<AbstractFile> files){\r\n    if (DataSourceIngestJob.Stages.FIRST == this.stage) {\r\n        DataSourceIngestJob.taskScheduler.fastTrackFileIngestTasks(this, files);\r\n    } else {\r\n        DataSourceIngestJob.logger.log(Level.SEVERE, \"Adding files during second stage not supported\");\r\n    }\r\n    this.checkForStageCompleted();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.encryptiondetection.EncryptionDetectionIngestJobSettings.setMinimumFileSize",
	"Comment": "set the minimum file size necessary for the creation of blackboardartifacts.",
	"Method": "void setMinimumFileSize(int minimumFileSize){\r\n    this.minimumFileSize = minimumFileSize;\r\n}"
}, {
	"Path": "com.mcxiaoke.next.utils.MimeUtils.getExtensionFromMimeType",
	"Comment": "returns the registered extension for the given mime type. note that somemime types map to multiple extensions. this call will return the mostcommon extension for the given mime type.",
	"Method": "String getExtensionFromMimeType(String mimeType){\r\n    if (mimeType == null || mimeType.length() == 0) {\r\n        return null;\r\n    }\r\n    return mimeTypeToExtensionMap.get(mimeType);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.DataResultViewerTable.storeColumnVisibility",
	"Comment": "persists the current column visibility information for the childoutlineview of this tabular result viewer using a preferences file.",
	"Method": "void storeColumnVisibility(){\r\n    if (rootNode == null || propertiesMap.isEmpty()) {\r\n        return;\r\n    }\r\n    if (rootNode instanceof TableFilterNode) {\r\n        TableFilterNode tfn = (TableFilterNode) rootNode;\r\n        final Preferences preferences = NbPreferences.forModule(DataResultViewerTable.class);\r\n        final ETableColumnModel columnModel = (ETableColumnModel) outline.getColumnModel();\r\n        for (Map.Entry<String, ETableColumn> entry : columnMap.entrySet()) {\r\n            String columnName = entry.getKey();\r\n            final String columnHiddenKey = ResultViewerPersistence.getColumnHiddenKey(tfn, columnName);\r\n            final TableColumn column = entry.getValue();\r\n            boolean columnHidden = columnModel.isColumnHidden(column);\r\n            if (columnHidden) {\r\n                preferences.putBoolean(columnHiddenKey, true);\r\n            } else {\r\n                preferences.remove(columnHiddenKey);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.ImageUtils.getBufferedReadContentStream",
	"Comment": "get a bufferedinputstream wrapped around a readcontentstream for thegiven abstractfile.",
	"Method": "BufferedInputStream getBufferedReadContentStream(AbstractFile file){\r\n    return new BufferedInputStream(new ReadContentInputStream(file));\r\n}"
}, {
	"Path": "com.aliyun.oss.common.auth.CredentialsProviderFactory.newSTSKeyPairSessionCredentialsProvider",
	"Comment": "create an instance of instanceprofilecredentialsprovider based on rsa keypair.",
	"Method": "STSKeyPairSessionCredentialsProvider newSTSKeyPairSessionCredentialsProvider(String regionId,String publicKeyId,String privateKey){\r\n    DefaultProfile profile = DefaultProfile.getProfile(regionId);\r\n    KeyPairCredentials keyPairCredentials = new KeyPairCredentials(publicKeyId, privateKey);\r\n    return new STSKeyPairSessionCredentialsProvider(keyPairCredentials, profile);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJobNodeData.toArray",
	"Comment": "gets the node data as a byte array that can be sent to the coordinationservice.",
	"Method": "byte[] toArray(){\r\n    ByteBuffer buffer = ByteBuffer.allocate(MAX_POSSIBLE_NODE_DATA_SIZE);\r\n    buffer.putInt(this.processingStatus);\r\n    buffer.putInt(this.priority);\r\n    buffer.putInt(this.numberOfCrashes);\r\n    buffer.putLong(this.completedDate);\r\n    buffer.putInt(this.errorsOccurred ? 1 : 0);\r\n    if (this.version >= 1) {\r\n        buffer.putInt(this.version);\r\n        putStringIntoBuffer(deviceId, buffer, TypeKind.BYTE);\r\n        putStringIntoBuffer(caseName, buffer, TypeKind.BYTE);\r\n        putStringIntoBuffer(caseDirectoryPath, buffer, TypeKind.SHORT);\r\n        buffer.putLong(this.manifestFileDate);\r\n        putStringIntoBuffer(manifestFilePath, buffer, TypeKind.SHORT);\r\n        putStringIntoBuffer(dataSourcePath, buffer, TypeKind.SHORT);\r\n        buffer.put(this.processingStage);\r\n        buffer.putLong(this.processingStageStartDate);\r\n        putStringIntoBuffer(this.processingStageDetailsDescription, buffer, TypeKind.BYTE);\r\n        buffer.putLong(this.processingStageDetailsStartDate);\r\n        putStringIntoBuffer(processingHostName, buffer, TypeKind.SHORT);\r\n        if (this.version >= 2) {\r\n            buffer.putLong(this.dataSourceSize);\r\n        }\r\n    }\r\n    byte[] array = new byte[buffer.position()];\r\n    buffer.rewind();\r\n    buffer.get(array, 0, array.length);\r\n    return array;\r\n}"
}, {
	"Path": "net.dongliu.apk.parser.utils.xml.CharSequenceTranslator.hex",
	"Comment": "returns an upper case hexadecimal string for the givencharacter.",
	"Method": "String hex(int codepoint){\r\n    return Integer.toHexString(codepoint).toUpperCase(Locale.ENGLISH);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.filetypeid.FileType.getInterestingFilesSetName",
	"Comment": "gets the name of the interesting files set associated with this filetype.",
	"Method": "String getInterestingFilesSetName(){\r\n    return interestingFilesSetName;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.OnStart.run",
	"Comment": "this method is invoked by virtue of the onstart annotation on the thisclass",
	"Method": "void run(){\r\n    ImageGalleryModule.onStart();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.CommonAttributeSearchResults.size",
	"Comment": "how many distinct common files exist for this search results?",
	"Method": "int size(){\r\n    int count = 0;\r\n    for (CommonAttributeValueList data : this.instanceCountToAttributeValues.values()) {\r\n        for (CommonAttributeValue md5 : data.getDelayedMetadataList()) {\r\n            count += md5.getInstanceCount();\r\n        }\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "net.dongliu.apk.parser.utils.xml.EntityArrays.APOS_ESCAPE",
	"Comment": "mapping to escape the apostrophe character to its xml character entity.",
	"Method": "String[][] APOS_ESCAPE(){\r\n    return APOS_ESCAPE.clone();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.SQLiteTableReader.findAndCopySQLiteMetaFile",
	"Comment": "searches for a meta file associated with the give sqlite database. iffound, it copies this file into the temp directory of the current case.",
	"Method": "void findAndCopySQLiteMetaFile(AbstractFile sqliteFile,String metaFileName){\r\n    Case openCase = Case.getCurrentCaseThrows();\r\n    SleuthkitCase sleuthkitCase = openCase.getSleuthkitCase();\r\n    Services services = new Services(sleuthkitCase);\r\n    FileManager fileManager = services.getFileManager();\r\n    List<AbstractFile> metaFiles = fileManager.findFiles(sqliteFile.getDataSource(), metaFileName, sqliteFile.getParent().getName());\r\n    if (metaFiles != null) {\r\n        for (AbstractFile metaFile : metaFiles) {\r\n            copyFileToTempDirectory(metaFile, sqliteFile.getId());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.optionspanel.EamDbSettingsDialog.updateSqliteFields",
	"Comment": "update the fields for the sqlite platform depending on whether the sqliteradiobutton is enabled.",
	"Method": "void updateSqliteFields(boolean enabled){\r\n    tfDatabasePath.setText(enabled ? dbSettingsSqlite.getDbDirectory() : \"\");\r\n    tfDatabasePath.setEnabled(enabled);\r\n    bnDatabasePathFileOpen.setEnabled(enabled);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.othercasessearch.OtherCasesSearchDialog.customizeComponents",
	"Comment": "further customize the components beyond the standard initialization.",
	"Method": "void customizeComponents(){\r\n    searchButton.setEnabled(false);\r\n    try {\r\n        EamDb dbManager = EamDb.getInstance();\r\n        correlationTypes.clear();\r\n        correlationTypes.addAll(dbManager.getDefinedCorrelationTypes());\r\n        int numberOfCases = dbManager.getCases().size();\r\n        casesLabel.setText(Bundle.OtherCasesSearchDialog_caseLabel_text(numberOfCases));\r\n    } catch (EamDbException ex) {\r\n        logger.log(Level.SEVERE, \"Unable to connect to the Central Repository database.\", ex);\r\n    }\r\n    for (CorrelationAttributeInstance.Type type : correlationTypes) {\r\n        correlationTypeComboBox.addItem(type.getDisplayName());\r\n    }\r\n    correlationTypeComboBox.setSelectedIndex(0);\r\n    correlationTypeComboBox.addItemListener(new ItemListener() {\r\n        @Override\r\n        public void itemStateChanged(ItemEvent e) {\r\n            updateSelectedType();\r\n            updateCorrelationValueTextFieldPrompt();\r\n            updateSearchButton();\r\n        }\r\n    });\r\n    updateSelectedType();\r\n    correlationValueTextField.getDocument().addDocumentListener(new DocumentListener() {\r\n        @Override\r\n        public void changedUpdate(DocumentEvent e) {\r\n            updateSearchButton();\r\n        }\r\n        @Override\r\n        public void insertUpdate(DocumentEvent e) {\r\n            updateSearchButton();\r\n        }\r\n        @Override\r\n        public void removeUpdate(DocumentEvent e) {\r\n            updateSearchButton();\r\n        }\r\n    });\r\n    updateCorrelationValueTextFieldPrompt();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.othercasessearch.OtherCasesSearchDialog.customizeComponents",
	"Comment": "further customize the components beyond the standard initialization.",
	"Method": "void customizeComponents(){\r\n    updateSelectedType();\r\n    updateCorrelationValueTextFieldPrompt();\r\n    updateSearchButton();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.othercasessearch.OtherCasesSearchDialog.customizeComponents",
	"Comment": "further customize the components beyond the standard initialization.",
	"Method": "void customizeComponents(){\r\n    updateSearchButton();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.othercasessearch.OtherCasesSearchDialog.customizeComponents",
	"Comment": "further customize the components beyond the standard initialization.",
	"Method": "void customizeComponents(){\r\n    updateSearchButton();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.othercasessearch.OtherCasesSearchDialog.customizeComponents",
	"Comment": "further customize the components beyond the standard initialization.",
	"Method": "void customizeComponents(){\r\n    updateSearchButton();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.embeddedfileextractor.SevenZipExtractor.flagRootArchiveAsZipBomb",
	"Comment": "flag the root archive archive as a zipbomb by creating an interestingfile artifact and posting a message to the inbox for the user.",
	"Method": "void flagRootArchiveAsZipBomb(Archive rootArchive,AbstractFile archiveFile,String details,String escapedFilePath){\r\n    rootArchive.flagAsZipBomb();\r\n    logger.log(Level.INFO, details);\r\n    String msg = NbBundle.getMessage(SevenZipExtractor.class, \"EmbeddedFileExtractorIngestModule.ArchiveExtractor.isZipBombCheck.warnMsg\", archiveFile.getName(), escapedFilePath);\r\n    try {\r\n        Collection<BlackboardAttribute> attributes = new ArrayList();\r\n        attributes.add(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_SET_NAME, EmbeddedFileExtractorModuleFactory.getModuleName(), \"Possible Zip Bomb\"));\r\n        attributes.add(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DESCRIPTION, EmbeddedFileExtractorModuleFactory.getModuleName(), Bundle.SevenZipExtractor_zipBombArtifactCreation_text(archiveFile.getName())));\r\n        attributes.add(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_COMMENT, EmbeddedFileExtractorModuleFactory.getModuleName(), details));\r\n        SleuthkitCase tskCase = Case.getCurrentCaseThrows().getSleuthkitCase();\r\n        org.sleuthkit.datamodel.Blackboard tskBlackboard = tskCase.getBlackboard();\r\n        if (!tskBlackboard.artifactExists(archiveFile, BlackboardArtifact.ARTIFACT_TYPE.TSK_INTERESTING_FILE_HIT, attributes)) {\r\n            BlackboardArtifact artifact = archiveFile.newArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_INTERESTING_FILE_HIT);\r\n            artifact.addAttributes(attributes);\r\n            try {\r\n                blackboard.indexArtifact(artifact);\r\n            } catch (Blackboard.BlackboardException ex) {\r\n                logger.log(Level.SEVERE, \"Unable to index blackboard artifact \" + artifact.getArtifactID(), ex);\r\n                MessageNotifyUtil.Notify.error(Bundle.SevenZipExtractor_indexError_message(), artifact.getDisplayName());\r\n            }\r\n            services.postMessage(IngestMessage.createWarningMessage(EmbeddedFileExtractorModuleFactory.getModuleName(), msg, details));\r\n            services.fireModuleDataEvent(new ModuleDataEvent(EmbeddedFileExtractorModuleFactory.getModuleName(), BlackboardArtifact.ARTIFACT_TYPE.TSK_INTERESTING_FILE_HIT));\r\n        }\r\n    } catch (TskCoreException ex) {\r\n        logger.log(Level.SEVERE, \"Error creating blackboard artifact for Zip Bomb Detection for file: \" + escapedFilePath, ex);\r\n    } catch (NoCurrentCaseException ex) {\r\n        logger.log(Level.SEVERE, \"Exception while getting open case.\", ex);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.recentactivity.SearchEngineURLQueryAnalyzer.getSearchEngineFromUrl",
	"Comment": "returns which of the supported searchengines, if any, the given stringbelongs to.",
	"Method": "SearchEngineURLQueryAnalyzer.SearchEngine getSearchEngineFromUrl(String domain){\r\n    if (engines == null) {\r\n        return null;\r\n    }\r\n    for (SearchEngine engine : engines) {\r\n        if (domain.contains(engine.getDomainSubstring())) {\r\n            return engine;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.runIngestModuleWizard.IngestProfileSelectionPanel.getLastSelectedProfile",
	"Comment": "returns the profile that is currently selected in this panel",
	"Method": "String getLastSelectedProfile(){\r\n    return selectedProfile;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.filetypeid.AddFileTypeSignatureDialog.doButtonAction",
	"Comment": "performs actions on the fields based on whether the ok button was pressedor not.",
	"Method": "void doButtonAction(boolean okPressed){\r\n    if (okPressed) {\r\n        Signature sig = addFileTypeSigPanel.getSignature();\r\n        if (sig != null) {\r\n            this.signature = sig;\r\n            this.result = BUTTON_PRESSED.OK;\r\n            setVisible(false);\r\n        }\r\n    } else {\r\n        this.signature = null;\r\n        this.result = BUTTON_PRESSED.CANCEL;\r\n        setVisible(false);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.EnCaseKeywordSearchList.doCreateListsFromEntries",
	"Comment": "follow the encasefileentry hierarchy starting with given entry createlist for each folder entry, add keyword for each expression",
	"Method": "void doCreateListsFromEntries(EncaseFileEntry entry,String parentPath){\r\n    String name;\r\n    if (parentPath.isEmpty()) {\r\n        name = entry.name;\r\n    } else {\r\n        name = parentPath + \"/\" + entry.name;\r\n    }\r\n    List<Keyword> children = new ArrayList();\r\n    for (EncaseFileEntry child : entry.children) {\r\n        switch(child.type) {\r\n            case Folder:\r\n                doCreateListsFromEntries(child, name);\r\n                break;\r\n            case Expression:\r\n                if (child.flags.contains(EncaseFlag.pg)) {\r\n                    break;\r\n                }\r\n                children.add(new Keyword(child.value, true, true));\r\n                break;\r\n        }\r\n    }\r\n    if (theLists.containsKey(name)) {\r\n        int i = 2;\r\n        while (theLists.containsKey(name + \"(\" + i + \")\")) {\r\n            i += 1;\r\n        }\r\n        name = name + \"(\" + i + \")\";\r\n    }\r\n    if (!children.isEmpty()) {\r\n        KeywordList newList = new KeywordList(name, new Date(), new Date(), true, true, children);\r\n        theLists.put(name, newList);\r\n    }\r\n}"
}, {
	"Path": "com.facebook.samples.zoomable.DefaultZoomableController.shouldLimit",
	"Comment": "checks whether the specified limit flag is present in the limits provided. if the flag contains multiple flags together using a bitwise or, this only checks that atleast one of the flags is included.",
	"Method": "boolean shouldLimit(int limits,int flag){\r\n    return (limits & flag) != LIMIT_NONE;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestDashboard.shutDown",
	"Comment": "shut down parts of the autoingestdashboard which were initialized",
	"Method": "void shutDown(){\r\n    if (autoIngestMonitor != null) {\r\n        autoIngestMonitor.shutDown();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestDashboard.startUp",
	"Comment": "starts up the auto ingest monitor and adds this panel as an observer,subscribes to services monitor events and starts a task to populate theauto ingest job tables.",
	"Method": "void startUp(){\r\n    PropertyChangeListener propChangeListener = (PropertyChangeEvent evt) -> {\r\n        String serviceDisplayName = ServicesMonitor.Service.valueOf(evt.getPropertyName()).toString();\r\n        String status = evt.getNewValue().toString();\r\n        if (status.equals(ServicesMonitor.ServiceStatus.UP.toString())) {\r\n            status = NbBundle.getMessage(AutoIngestDashboard.class, \"AutoIngestDashboard.tbServicesStatusMessage.Message.Up\");\r\n            LOGGER.log(Level.INFO, \"Connection to {0} is up\", serviceDisplayName);\r\n        } else if (status.equals(ServicesMonitor.ServiceStatus.DOWN.toString())) {\r\n            status = NbBundle.getMessage(AutoIngestDashboard.class, \"AutoIngestDashboard.tbServicesStatusMessage.Message.Down\");\r\n            LOGGER.log(Level.SEVERE, \"Connection to {0} is down\", serviceDisplayName);\r\n        } else {\r\n            LOGGER.log(Level.INFO, \"Status for {0} is {1}\", new Object[] { serviceDisplayName, status });\r\n        }\r\n        if (statusByService.containsKey(serviceDisplayName) && status.equals(statusByService.get(serviceDisplayName))) {\r\n            return;\r\n        }\r\n        statusByService.put(serviceDisplayName, status);\r\n        displayServicesStatus();\r\n    };\r\n    Set<String> servicesList = new HashSet();\r\n    servicesList.add(ServicesMonitor.Service.REMOTE_CASE_DATABASE.toString());\r\n    servicesList.add(ServicesMonitor.Service.REMOTE_KEYWORD_SEARCH.toString());\r\n    servicesList.add(ServicesMonitor.Service.MESSAGING.toString());\r\n    ServicesMonitor.getInstance().addSubscriber(servicesList, propChangeListener);\r\n    autoIngestMonitor = new AutoIngestMonitor();\r\n    autoIngestMonitor.addObserver(this);\r\n    new Thread(() -> {\r\n        try {\r\n            autoIngestMonitor.startUp();\r\n        } catch (AutoIngestMonitor.AutoIngestMonitorException ex) {\r\n            LOGGER.log(Level.SEVERE, \"Unable to start up Auto Ingest Monitor\", ex);\r\n        }\r\n    }).start();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.RecentCases.removeRecentCase",
	"Comment": "this method is used to remove the selected name and path of therecentcase",
	"Method": "void removeRecentCase(String name,String path){\r\n    RecentCase rc = RecentCase.createSafe(name, path);\r\n    recentCases.removeAll(Arrays.asList(rc));\r\n    this.getMenuPresenter().setVisible(true);\r\n    try {\r\n        storeRecentCases();\r\n    } catch (IOException ex) {\r\n        Logger.getLogger(RecentCases.class.getName()).log(Level.WARNING, \"Error: Could not update the properties file.\", ex);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestDashboard.refreshButtonActionPerformed",
	"Comment": "handles a click on the refresh button. requests a refreshed jobs snapshotfrom the auto ingest monitor and uses it to refresh the ui components ofthe panel.",
	"Method": "void refreshButtonActionPerformed(java.awt.event.ActionEvent evt){\r\n    setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\r\n    refreshTables();\r\n    setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));\r\n}"
}, {
	"Path": "com.facebook.samples.zoomable.DefaultZoomableController.zoomToPoint",
	"Comment": "zooms to the desired scale and positions the image so that the given image point correspondsto the given view point.",
	"Method": "void zoomToPoint(float scale,PointF imagePoint,PointF viewPoint){\r\n    FLog.v(TAG, \"zoomToPoint\");\r\n    calculateZoomToPointTransform(mActiveTransform, scale, imagePoint, viewPoint, LIMIT_ALL);\r\n    onTransformChanged();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.ReportHTML.endDataType",
	"Comment": "end the current data type. write the end of the web page and close theoutput stream.",
	"Method": "void endDataType(){\r\n    dataTypes.put(currentDataType, rowCount);\r\n    try {\r\n        StringBuilder builder = new StringBuilder();\r\n        builder.append(writePageFooter());\r\n        builder.append(\"<\/div>\\n<\/body>\\n<\/html>\\n\");\r\n        out.write(builder.toString());\r\n    } catch (IOException ex) {\r\n        logger.log(Level.SEVERE, \"Failed to write end of HTML report.\", ex);\r\n    } finally {\r\n        if (out != null) {\r\n            try {\r\n                out.flush();\r\n                out.close();\r\n            } catch (IOException ex) {\r\n                logger.log(Level.WARNING, \"Could not close the output writer when ending data type.\", ex);\r\n            }\r\n            out = null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.anysoftkeyboard.keyboards.GenericKeyboard.filterPasswordMode",
	"Comment": "this will ensure that password extra rows are not shown over a symbols keyboard.",
	"Method": "int filterPasswordMode(int mode){\r\n    if (mode == KEYBOARD_ROW_MODE_PASSWORD)\r\n        return KEYBOARD_ROW_MODE_NORMAL;\r\n    else\r\n        return mode;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.datamodel.AbstractContentNode.hasContentChildren",
	"Comment": "return true if the underlying content object has children useful for lazyloading.",
	"Method": "boolean hasContentChildren(){\r\n    boolean hasChildren = false;\r\n    if (content != null) {\r\n        try {\r\n            hasChildren = content.hasChildren();\r\n        } catch (TskCoreException ex) {\r\n            logger.log(Level.SEVERE, \"Error checking if the node has children, for content: \" + content, ex);\r\n        }\r\n    }\r\n    return hasChildren;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestJobContext.fileIngestIsCancelled",
	"Comment": "allows a file ingest module to determine whether or not cancellation ofthe file ingest part of the ingest job associated with this context hasbeen requested.",
	"Method": "boolean fileIngestIsCancelled(){\r\n    return this.ingestJob.isCancelled();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.FileExportRuleSet.addRule",
	"Comment": "adds a rule to this set. if there is a rule in the set with the samename, the existing rule is replaced by the new rule.",
	"Method": "void addRule(Rule rule){\r\n    this.rules.put(rule.getName(), rule);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.interestingitems.FileSetsDefinitions.writeDefinitionsFile",
	"Comment": "writes filesset definitions to disk as an xml file, logging any errors.",
	"Method": "boolean writeDefinitionsFile(String fileName,Map<String, FilesSet> interestingFilesSets){\r\n    try (final NbObjectOutputStream out = new NbObjectOutputStream(new FileOutputStream(Paths.get(PlatformUtil.getUserConfigDirectory(), fileName).toString()))) {\r\n        out.writeObject(new FileSetsDefinitions(interestingFilesSets));\r\n    } catch (IOException ex) {\r\n        throw new FilesSetsManager.FilesSetsManagerException(String.format(\"Failed to write settings to %s\", fileName), ex);\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.optionspanel.EamDbSettingsDialog.checkFields",
	"Comment": "tests whether or not all of the settings components are populated.",
	"Method": "boolean checkFields(){\r\n    return databaseFieldsArePopulated() && databaseSettingsAreValid();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.core.ServicesMonitor.checkKeywordSearchServerConnectionStatus",
	"Comment": "performs keyword search service availability status check.",
	"Method": "void checkKeywordSearchServerConnectionStatus(){\r\n    KeywordSearchService kwsService = Lookup.getDefault().lookup(KeywordSearchService.class);\r\n    try {\r\n        if (kwsService != null) {\r\n            int port = Integer.parseUnsignedInt(UserPreferences.getIndexingServerPort());\r\n            kwsService.tryConnect(UserPreferences.getIndexingServerHost(), port);\r\n            setServiceStatus(Service.REMOTE_KEYWORD_SEARCH.toString(), ServiceStatus.UP.toString(), \"\");\r\n        } else {\r\n            setServiceStatus(Service.REMOTE_KEYWORD_SEARCH.toString(), ServiceStatus.DOWN.toString(), NbBundle.getMessage(ServicesMonitor.class, \"ServicesMonitor.KeywordSearchNull\"));\r\n        }\r\n    } catch (NumberFormatException ex) {\r\n        String rootCause = NbBundle.getMessage(ServicesMonitor.class, \"ServicesMonitor.InvalidPortNumber\");\r\n        logger.log(Level.SEVERE, \"Unable to connect to messaging server: \" + rootCause, ex);\r\n        setServiceStatus(Service.REMOTE_KEYWORD_SEARCH.toString(), ServiceStatus.DOWN.toString(), rootCause);\r\n    } catch (KeywordSearchServiceException ex) {\r\n        String rootCause = ex.getMessage();\r\n        logger.log(Level.SEVERE, \"Unable to connect to messaging server: \" + rootCause, ex);\r\n        setServiceStatus(Service.REMOTE_KEYWORD_SEARCH.toString(), ServiceStatus.DOWN.toString(), rootCause);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.recentactivity.ExtractIE.extractDomain",
	"Comment": "extract the domain from the supplied url. this method does additionalchecks to detect invalid urls.",
	"Method": "String extractDomain(String url){\r\n    if (url == null || url.isEmpty()) {\r\n        return url;\r\n    }\r\n    if (url.toLowerCase().startsWith(RESOURCE_URL_PREFIX)) {\r\n        return null;\r\n    }\r\n    return NetworkUtils.extractDomain(url);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.filetypeid.AddFileTypeSignaturePanel.getSignature",
	"Comment": "gets the file type signature for this panel, pops up error windows if thesignature is incomplete.",
	"Method": "Signature getSignature(){\r\n    FileType.Signature.Type sigType = signatureTypeComboBox.getSelectedItem() == RAW_SIGNATURE_TYPE_COMBO_BOX_ITEM ? FileType.Signature.Type.RAW : FileType.Signature.Type.ASCII;\r\n    String sigString = signatureTextField.getText();\r\n    if (sigString.isEmpty()) {\r\n        JOptionPane.showMessageDialog(this, NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidSignature.message\"), NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidSignature.title\"), JOptionPane.ERROR_MESSAGE);\r\n        return null;\r\n    }\r\n    byte[] signatureBytes;\r\n    if (FileType.Signature.Type.RAW == sigType) {\r\n        try {\r\n            sigString = sigString.replaceAll(\"\\\\s\", \"\");\r\n            signatureBytes = DatatypeConverter.parseHexBinary(sigString);\r\n        } catch (IllegalArgumentException ex) {\r\n            JOptionPane.showMessageDialog(this, NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidRawSignatureBytes.message\"), NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidSignatureBytes.title\"), JOptionPane.ERROR_MESSAGE);\r\n            return null;\r\n        }\r\n    } else {\r\n        signatureBytes = sigString.getBytes(Charset.forName(\"UTF-8\"));\r\n    }\r\n    long offset;\r\n    boolean isRelativeToStart = offsetRelativeToComboBox.getSelectedItem() == START_OFFSET_RELATIVE_COMBO_BOX_ITEM;\r\n    try {\r\n        offset = Long.parseUnsignedLong(offsetTextField.getText());\r\n        if (!isRelativeToStart && signatureBytes.length > offset + 1) {\r\n            JOptionPane.showMessageDialog(this, NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidOffset.length\"), NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidOffset.title\"), JOptionPane.ERROR_MESSAGE);\r\n            return null;\r\n        }\r\n    } catch (NumberFormatException ex) {\r\n        JOptionPane.showMessageDialog(this, NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidOffset.message\"), NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidOffset.title\"), JOptionPane.ERROR_MESSAGE);\r\n        return null;\r\n    }\r\n    FileType.Signature signature = new FileType.Signature(signatureBytes, offset, sigType, isRelativeToStart);\r\n    return signature;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.SingleUserCaseConverter.populateNullableByteArray",
	"Comment": "place a null inside a prepared statement if needed, otherwise, place thebyte array that was in the resultset.",
	"Method": "void populateNullableByteArray(PreparedStatement pst,ResultSet rs,int rsIndex,int psIndex){\r\n    byte[] nullableBytes = rs.getBytes(rsIndex);\r\n    if (rs.wasNull()) {\r\n        pst.setNull(psIndex, java.sql.Types.NULL);\r\n    } else {\r\n        pst.setBytes(psIndex, nullableBytes);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.InterCaseSearchResultsProcessor.findInterCaseCommonAttributeValues",
	"Comment": "given the current case, fins all intercase common files from the eamdband builds maps of obj id to md5 and case.",
	"Method": "Map<Integer, CommonAttributeValueList> findInterCaseCommonAttributeValues(Case currentCase){\r\n    try {\r\n        InterCaseCommonAttributesCallback instancetableCallback = new InterCaseCommonAttributesCallback();\r\n        EamDb DbManager = EamDb.getInstance();\r\n        int caseId = DbManager.getCase(currentCase).getID();\r\n        DbManager.processInstanceTableWhere(correlationType, String.format(interCaseWhereClause, caseId, TskData.FileKnown.KNOWN.getFileKnownValue()), instancetableCallback);\r\n        return instancetableCallback.getInstanceCollatedCommonFiles();\r\n    } catch (EamDbException ex) {\r\n        LOGGER.log(Level.SEVERE, \"Error accessing EamDb processing CaseInstancesTable.\", ex);\r\n    }\r\n    return new HashMap();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.directorytree.ExternalViewerGlobalSettingsPanel.customizeComponents",
	"Comment": "initializes field variables. adds a listener to the list of rules.",
	"Method": "void customizeComponents(){\r\n    rulesListModel = new DefaultListModel();\r\n    rules = new ArrayList();\r\n    rulesList.setModel(rulesListModel);\r\n    rulesList.addListSelectionListener(new ListSelectionListener() {\r\n        @Override\r\n        public void valueChanged(ListSelectionEvent e) {\r\n            if (e.getValueIsAdjusting() == false) {\r\n                if (rulesList.getSelectedIndex() == -1) {\r\n                    clearExePath();\r\n                } else {\r\n                    populateExePath();\r\n                }\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.directorytree.ExternalViewerGlobalSettingsPanel.customizeComponents",
	"Comment": "initializes field variables. adds a listener to the list of rules.",
	"Method": "void customizeComponents(){\r\n    if (e.getValueIsAdjusting() == false) {\r\n        if (rulesList.getSelectedIndex() == -1) {\r\n            clearExePath();\r\n        } else {\r\n            populateExePath();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.gui.drawableviews.DrawableTileBase.updateSelectionState",
	"Comment": "update the visual representation of the selection state of thisdrawableview",
	"Method": "void updateSelectionState(){\r\n    getFileID().ifPresent(fileID -> {\r\n        final boolean selected = selectionModel.isSelected(fileID);\r\n        Platform.runLater(() -> setBorder(selected ? SELECTED_BORDER : UNSELECTED_BORDER));\r\n    });\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.OpenRecentCasePanel.getInstance",
	"Comment": "gets the singleton instance of the panel used by the the open recent caseoption of the start window.",
	"Method": "OpenRecentCasePanel getInstance(){\r\n    if (instance == null) {\r\n        instance = new OpenRecentCasePanel();\r\n    }\r\n    instance.refreshRecentCasesTable();\r\n    return instance;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.FileExportSettings.getRulesEvaluatedFlagFileName",
	"Comment": "gets the name of the file written to indicate file export rule evaluationis completed.",
	"Method": "String getRulesEvaluatedFlagFileName(){\r\n    return rulesEvaluatedFlagFileName;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.configuration.SharedConfiguration.copyRemoteFolderToLocalFolder",
	"Comment": "copy an entire remote settings folder to the local folder, deleting any existing files.no error if the remote folder does not exist.",
	"Method": "void copyRemoteFolderToLocalFolder(File localFolder,File remoteBaseFolder){\r\n    logger.log(Level.INFO, \"Downloading {0} from {1}\", new Object[] { localFolder.getAbsolutePath(), remoteBaseFolder.getAbsolutePath() });\r\n    if (localFolder.exists()) {\r\n        try {\r\n            FileUtils.cleanDirectory(localFolder);\r\n        } catch (IOException ex) {\r\n            logger.log(Level.SEVERE, \"Failed to delete files from local folder {0}\", localFolder.getAbsolutePath());\r\n            throw new SharedConfigurationException(String.format(\"Failed to delete files from local folder {0}\", localFolder.getAbsolutePath()), ex);\r\n        }\r\n    }\r\n    File remoteSubFolder = new File(remoteBaseFolder, localFolder.getName());\r\n    if (!remoteSubFolder.exists()) {\r\n        logger.log(Level.INFO, \"{0} does not exist\", remoteSubFolder.getAbsolutePath());\r\n        return;\r\n    }\r\n    try {\r\n        FileUtils.copyDirectory(remoteSubFolder, localFolder);\r\n    } catch (IOException ex) {\r\n        throw new SharedConfigurationException(String.format(\"Failed to copy %s from %s\", localFolder, remoteBaseFolder.getAbsolutePath()), ex);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.Server.changeSolrServerPort",
	"Comment": "changes the current solr server port. only call this after available.",
	"Method": "void changeSolrServerPort(int port){\r\n    currentSolrServerPort = port;\r\n    ModuleSettings.setConfigSetting(PROPERTIES_FILE, PROPERTIES_CURRENT_SERVER_PORT, String.valueOf(port));\r\n}"
}, {
	"Path": "com.mcxiaoke.next.utils.ReflectionUtils.handleReflectionException",
	"Comment": "handle the given reflection exception. should only be called if nochecked exception is expected to be thrown by the target method.throws the underlying runtimeexception or error in case of aninvocationtargetexception with such a root cause. throws anillegalstateexception with an appropriate message else.",
	"Method": "void handleReflectionException(Exception ex){\r\n    if (ex instanceof NoSuchMethodException) {\r\n        throw new IllegalStateException(\"Method not found: \" + ex.getMessage());\r\n    }\r\n    if (ex instanceof IllegalAccessException) {\r\n        throw new IllegalStateException(\"Could not access method: \" + ex.getMessage());\r\n    }\r\n    if (ex instanceof InvocationTargetException) {\r\n        handleInvocationTargetException((InvocationTargetException) ex);\r\n    }\r\n    if (ex instanceof RuntimeException) {\r\n        throw (RuntimeException) ex;\r\n    }\r\n    throw new UndeclaredThrowableException(ex);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.ButtonColumn.mousePressed",
	"Comment": "when the mouse is pressed the editor is invoked. if you then then dragthe mouse to another cell before releasing it, the editor is stillactive. make sure editing is stopped when the mouse is released.",
	"Method": "void mousePressed(MouseEvent e){\r\n    if (table.isEditing() && table.getCellEditor() == this) {\r\n        isButtonColumnEditor = true;\r\n    }\r\n}"
}, {
	"Path": "com.aliyun.oss.internal.ResponseParsers.parseBucketWebsite",
	"Comment": "unmarshall get bucket website response body to corresponding result.",
	"Method": "BucketWebsiteResult parseBucketWebsite(InputStream responseBody){\r\n    try {\r\n        Element root = getXmlRootElement(responseBody);\r\n        BucketWebsiteResult result = new BucketWebsiteResult();\r\n        if (root.getChild(\"IndexDocument\") != null) {\r\n            result.setIndexDocument(root.getChild(\"IndexDocument\").getChildText(\"Suffix\"));\r\n        }\r\n        if (root.getChild(\"ErrorDocument\") != null) {\r\n            result.setErrorDocument(root.getChild(\"ErrorDocument\").getChildText(\"Key\"));\r\n        }\r\n        if (root.getChild(\"RoutingRules\") != null) {\r\n            List<Element> ruleElements = root.getChild(\"RoutingRules\").getChildren(\"RoutingRule\");\r\n            for (Element ruleElem : ruleElements) {\r\n                RoutingRule rule = new RoutingRule();\r\n                rule.setNumber(Integer.parseInt(ruleElem.getChildText(\"RuleNumber\")));\r\n                Element condElem = ruleElem.getChild(\"Condition\");\r\n                if (condElem != null) {\r\n                    rule.getCondition().setKeyPrefixEquals(condElem.getChildText(\"KeyPrefixEquals\"));\r\n                    if (condElem.getChild(\"HttpErrorCodeReturnedEquals\") != null) {\r\n                        rule.getCondition().setHttpErrorCodeReturnedEquals(Integer.parseInt(condElem.getChildText(\"HttpErrorCodeReturnedEquals\")));\r\n                    }\r\n                }\r\n                Element redirectElem = ruleElem.getChild(\"Redirect\");\r\n                if (redirectElem.getChild(\"RedirectType\") != null) {\r\n                    rule.getRedirect().setRedirectType(RoutingRule.RedirectType.parse(redirectElem.getChildText(\"RedirectType\")));\r\n                }\r\n                rule.getRedirect().setHostName(redirectElem.getChildText(\"HostName\"));\r\n                if (redirectElem.getChild(\"Protocol\") != null) {\r\n                    rule.getRedirect().setProtocol(RoutingRule.Protocol.parse(redirectElem.getChildText(\"Protocol\")));\r\n                }\r\n                rule.getRedirect().setReplaceKeyPrefixWith(redirectElem.getChildText(\"ReplaceKeyPrefixWith\"));\r\n                rule.getRedirect().setReplaceKeyWith(redirectElem.getChildText(\"ReplaceKeyWith\"));\r\n                if (redirectElem.getChild(\"HttpRedirectCode\") != null) {\r\n                    rule.getRedirect().setHttpRedirectCode(Integer.parseInt(redirectElem.getChildText(\"HttpRedirectCode\")));\r\n                }\r\n                rule.getRedirect().setMirrorURL(redirectElem.getChildText(\"MirrorURL\"));\r\n                rule.getRedirect().setMirrorSecondaryURL(redirectElem.getChildText(\"MirrorURLSlave\"));\r\n                rule.getRedirect().setMirrorProbeURL(redirectElem.getChildText(\"MirrorURLProbe\"));\r\n                if (redirectElem.getChildText(\"MirrorPassQueryString\") != null) {\r\n                    rule.getRedirect().setPassQueryString(Boolean.valueOf(redirectElem.getChildText(\"MirrorPassQueryString\")));\r\n                }\r\n                if (redirectElem.getChildText(\"MirrorPassOriginalSlashes\") != null) {\r\n                    rule.getRedirect().setPassOriginalSlashes(Boolean.valueOf(redirectElem.getChildText(\"MirrorPassOriginalSlashes\")));\r\n                }\r\n                result.AddRoutingRule(rule);\r\n            }\r\n        }\r\n        return result;\r\n    } catch (JDOMParseException e) {\r\n        throw new ResponseParseException(e.getPartialDocument() + \": \" + e.getMessage(), e);\r\n    } catch (Exception e) {\r\n        throw new ResponseParseException(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.CorrelationAttributeNormalizer.normalize",
	"Comment": "validate the data. converts text to lower case, and ensures that the datais a valid string of the format expected given the attributetype.",
	"Method": "String normalize(CorrelationAttributeInstance.Type attributeType,String data,String normalize,int attributeTypeId,String data){\r\n    try {\r\n        List<CorrelationAttributeInstance.Type> defaultTypes = CorrelationAttributeInstance.getDefaultCorrelationTypes();\r\n        Optional<CorrelationAttributeInstance.Type> typeOption = defaultTypes.stream().filter(attributeType -> attributeType.getId() == attributeTypeId).findAny();\r\n        if (typeOption.isPresent()) {\r\n            CorrelationAttributeInstance.Type type = typeOption.get();\r\n            return CorrelationAttributeNormalizer.normalize(type, data);\r\n        } else {\r\n            throw new CorrelationAttributeNormalizationException(String.format(\"Given attributeTypeId did not correspond to any known Attribute: %s\", attributeTypeId));\r\n        }\r\n    } catch (EamDbException ex) {\r\n        throw new CorrelationAttributeNormalizationException(ex);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.datasourceprocessors.RawDSInputPanel.createTimeZoneList",
	"Comment": "creates the drop down list for the time zones and then makes the localmachine time zone to be selected.",
	"Method": "void createTimeZoneList(){\r\n    List<String> timeZoneList = TimeZoneUtils.createTimeZoneList();\r\n    for (String timeZone : timeZoneList) {\r\n        timeZoneComboBox.addItem(timeZone);\r\n    }\r\n    timeZoneComboBox.setSelectedItem(TimeZoneUtils.createTimeZoneString(Calendar.getInstance().getTimeZone()));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.contentviewers.SQLiteViewer.initReader",
	"Comment": "creates a new sqlitetablereader. this class will iterate through thetable row by row and pass each value to the correct function based on itsdata type. for our use, we want to define an action when encounteringcolumn names and an action for all other data types.",
	"Method": "void initReader(){\r\n    viewReader = new SQLiteTableReader.Builder(sqliteDbFile).onColumnNames((columnName) -> {\r\n        currentTableHeader.add(columnName);\r\n    }).forAll(getForAllStrategy()).build();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestManager.setCaseNodeDataErrorsOccurred",
	"Comment": "sets the error flag for case node data given a case directory path.",
	"Method": "void setCaseNodeDataErrorsOccurred(Path caseDirectoryPath){\r\n    CaseNodeData caseNodeData = new CaseNodeData(coordinationService.getNodeData(CoordinationService.CategoryNode.CASES, caseDirectoryPath.toString()));\r\n    caseNodeData.setErrorsOccurred(true);\r\n    byte[] rawData = caseNodeData.toArray();\r\n    coordinationService.setNodeData(CoordinationService.CategoryNode.CASES, caseDirectoryPath.toString(), rawData);\r\n}"
}, {
	"Path": "org.wikipedia.database.DatabaseTable.getPrimaryKeySelectionArgs",
	"Comment": "get the selection arguments to be bound to the db query string.",
	"Method": "String[] getPrimaryKeySelectionArgs(T obj){\r\n    return ArrayUtils.removeAllOccurrences(getUnfilteredPrimaryKeySelectionArgs(obj), null);\r\n}"
}, {
	"Path": "com.fernandocejas.arrow.collections.Iterables.removeIf",
	"Comment": "removes, from an iterable, every element that satisfies the providedpredicate.",
	"Method": "boolean removeIf(Iterable<T> removeFrom,Predicate<? super T> predicate){\r\n    if (removeFrom instanceof RandomAccess && removeFrom instanceof List) {\r\n        return removeIfFromRandomAccessList((List<T>) removeFrom, checkNotNull(predicate));\r\n    }\r\n    return Iterators.removeIf(removeFrom.iterator(), predicate);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.filetypeid.CustomFileTypesManager.getInstance",
	"Comment": "gets the singleton manager of the custom file types defined by autopsyand by users.",
	"Method": "CustomFileTypesManager getInstance(){\r\n    if (null == instance) {\r\n        instance = new CustomFileTypesManager();\r\n        try {\r\n            instance.loadUserDefinedFileTypes();\r\n            instance.createAutopsyDefinedFileTypes();\r\n        } catch (CustomFileTypesException ex) {\r\n            instance = null;\r\n            throw ex;\r\n        }\r\n    }\r\n    return instance;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.DataSourceIngestModuleProgress.switchToDeterminate",
	"Comment": "updates the progress bar and switches it to determinate mode. this shouldbe called by the module as soon as the number of total work unitsrequired to process the data source is known.",
	"Method": "void switchToDeterminate(int workUnits){\r\n    this.job.switchDataSourceIngestProgressBarToDeterminate(workUnits);\r\n}"
}, {
	"Path": "com.mcxiaoke.next.recycler.AdvancedRecyclerArrayAdapter.insert",
	"Comment": "inserts the specified object at the specified index in the array.",
	"Method": "void insert(T object,int index){\r\n    synchronized (mLock) {\r\n        mObjects.add(index, object);\r\n        notifyItemInserted(index);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.Server.queryNumFileChunks",
	"Comment": "execute query that gets number of indexed file chunks for a file",
	"Method": "int queryNumFileChunks(long fileID,int queryNumFileChunks,long contentID){\r\n    currentCoreLock.readLock().lock();\r\n    try {\r\n        if (null == currentCore) {\r\n            throw new NoOpenCoreException();\r\n        }\r\n        try {\r\n            return currentCore.queryNumFileChunks(fileID);\r\n        } catch (SolrServerException | IOException ex) {\r\n            throw new KeywordSearchModuleException(NbBundle.getMessage(this.getClass(), \"Server.queryNumFileChunks.exception.msg\"), ex);\r\n        }\r\n    } finally {\r\n        currentCoreLock.readLock().unlock();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.interestingitems.FilesSetRulePanel.getFileSizeCondition",
	"Comment": "gets the file size condition created based upon the panel input",
	"Method": "FilesSet.Rule.FileSizeCondition getFileSizeCondition(){\r\n    FilesSet.Rule.FileSizeCondition condition = null;\r\n    if (this.fileSizeCheck.isSelected()) {\r\n        if ((Integer) this.fileSizeSpinner.getValue() != 0 || ((String) this.equalitySymbolComboBox.getSelectedItem()).equals(\"=\")) {\r\n            FilesSet.Rule.FileSizeCondition.COMPARATOR comparator = FilesSet.Rule.FileSizeCondition.COMPARATOR.fromSymbol((String) this.equalitySymbolComboBox.getSelectedItem());\r\n            FilesSet.Rule.FileSizeCondition.SIZE_UNIT unit = FilesSet.Rule.FileSizeCondition.SIZE_UNIT.fromName((String) this.fileSizeComboBox.getSelectedItem());\r\n            int fileSizeValue = (Integer) this.fileSizeSpinner.getValue();\r\n            condition = new FilesSet.Rule.FileSizeCondition(comparator, unit, fileSizeValue);\r\n        }\r\n    }\r\n    return condition;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.datamodel.FilteredEventsModel.getTagCountsByTagName",
	"Comment": "get a count of tagnames applied to the given event ids as a map fromtagname displayname to count of tag applications",
	"Method": "Map<String, Long> getTagCountsByTagName(Set<Long> eventIDsWithTags){\r\n    return repo.getTagCountsByTagName(eventIDsWithTags);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.test.CustomArtifactsCreatorIngestModuleFactory.isFileIngestModuleFactory",
	"Comment": "queries the factory to determine if it is capable of creating file ingestmodules.",
	"Method": "boolean isFileIngestModuleFactory(){\r\n    return true;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestManager.isIngestRunning",
	"Comment": "queries whether or not any ingest jobs are in progress at the time of thecall.",
	"Method": "boolean isIngestRunning(){\r\n    synchronized (ingestJobsById) {\r\n        return !ingestJobsById.isEmpty();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestJobSettings.getEnabledModules",
	"Comment": "gets a set which contains all the names of enabled modules for thespecified context.",
	"Method": "List<String> getEnabledModules(String context){\r\n    return new ArrayList(getModulesNames(context, ENABLED_MODULES_PROPERTY, \"\"));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestTasksScheduler.shouldEnqueueFileTask",
	"Comment": "examines the file associated with a file ingest task to determine whetheror not the file should be processed and therefore whether or not the taskshould be enqueued.",
	"Method": "boolean shouldEnqueueFileTask(FileIngestTask task){\r\n    final AbstractFile file = task.getFile();\r\n    String fileName = file.getName();\r\n    if (fileName.equals(\".\") || fileName.equals(\"..\")) {\r\n        return false;\r\n    }\r\n    if (!file.isDir() && !shouldBeCarved(task) && !fileAcceptedByFilter(task)) {\r\n        return false;\r\n    }\r\n    if (file instanceof org.sleuthkit.datamodel.File) {\r\n        final org.sleuthkit.datamodel.File f = (org.sleuthkit.datamodel.File) file;\r\n        TskData.TSK_FS_TYPE_ENUM fsType = TskData.TSK_FS_TYPE_ENUM.TSK_FS_TYPE_UNSUPP;\r\n        try {\r\n            FileSystem fs = f.getFileSystem();\r\n            if (fs != null) {\r\n                fsType = fs.getFsType();\r\n            }\r\n        } catch (TskCoreException ex) {\r\n            logger.log(Level.SEVERE, \"Error querying file system for \" + f, ex);\r\n        }\r\n        if ((fsType.getValue() & FAT_NTFS_FLAGS) == 0) {\r\n            return true;\r\n        }\r\n        boolean isInRootDir = false;\r\n        try {\r\n            AbstractFile parent = f.getParentDirectory();\r\n            if (parent == null) {\r\n                isInRootDir = true;\r\n            } else {\r\n                isInRootDir = parent.isRoot();\r\n            }\r\n        } catch (TskCoreException ex) {\r\n            logger.log(Level.WARNING, \"Error querying parent directory for\" + f.getName(), ex);\r\n        }\r\n        if (isInRootDir && f.getMetaAddr() < 32) {\r\n            String name = f.getName();\r\n            if (name.length() > 0 && name.charAt(0) == '$' && name.contains(\":\")) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagewriter.ImageWriter.cancelJob",
	"Comment": "cancels a single job. does not wait for the job to complete. safe to call with image writer in any state.",
	"Method": "void cancelJob(){\r\n    synchronized (currentTasksLock) {\r\n        isCancelled = true;\r\n        if (isStarted) {\r\n            SleuthkitJNI.cancelFinishImage(imageHandle);\r\n            if (doUI) {\r\n                progressUpdateTask.cancel(true);\r\n                progressHandle.finish();\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.Keyword.getArtifactAttributeType",
	"Comment": "gets the artifact attribute type associated with the keyword, if any.the association of an artifact attribute type with the keyword was addedto support an initial implementation of account number search and may beremoved in the future.",
	"Method": "BlackboardAttribute.ATTRIBUTE_TYPE getArtifactAttributeType(){\r\n    return this.artifactAtrributeType;\r\n}"
}, {
	"Path": "org.wikipedia.richtext.RichTextUtil.stripRichText",
	"Comment": "strips all rich text except spans used to provide compositional hints.",
	"Method": "CharSequence stripRichText(CharSequence str,int start,int end){\r\n    String plainText = str.toString();\r\n    SpannableString ret = new SpannableString(plainText);\r\n    if (str instanceof Spanned) {\r\n        List<Object> keyboardHintSpans = getComposingSpans((Spanned) str, start, end);\r\n        copySpans((Spanned) str, ret, keyboardHintSpans);\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.fileextmismatch.FileExtMismatchDetectorModuleSettings.getCheckType",
	"Comment": "gets whether extension mismatches should be checked for all files, forall files except text files, or for media and executable files only.",
	"Method": "CHECK_TYPE getCheckType(){\r\n    return checkType;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.services.TagsManager.tagNameExists",
	"Comment": "checks whether a tag name with a given display name exists in the casedatabase.",
	"Method": "boolean tagNameExists(String tagDisplayName){\r\n    try {\r\n        Map<String, TagName> tagNames = getDisplayNamesToTagNamesMap();\r\n        return tagNames.containsKey(tagDisplayName) && (tagNames.get(tagDisplayName) != null);\r\n    } catch (TskCoreException ex) {\r\n        LOGGER.log(Level.SEVERE, \"Error querying case database for tag names\", ex);\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.CaseMetadata.getCaseDetails",
	"Comment": "get current values for the case details which are user modifiable.",
	"Method": "CaseDetails getCaseDetails(){\r\n    return caseDetails;\r\n}"
}, {
	"Path": "com.aliyun.oss.ClientConfiguration.getSocketTimeout",
	"Comment": "gets the socket timeout in millisecond. 0 means infinite timeout, notrecommended.",
	"Method": "int getSocketTimeout(){\r\n    return socketTimeout;\r\n}"
}, {
	"Path": "com.google.example.games.catt2.SaveGame.isZero",
	"Comment": "returns whether or not this savegame is empty. empty means no stars on no levels.",
	"Method": "boolean isZero(){\r\n    return mLevelStars.keySet().size() == 0;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestSystemLogger.getLogger",
	"Comment": "gets a logger for the auto ingest system log, separate from both the caseauto ingest log and the application log.",
	"Method": "Logger getLogger(){\r\n    if (!configured) {\r\n        Path logFilePath = Paths.get(PlatformUtil.getUserDirectory().getAbsolutePath(), \"var\", \"log\", \"auto_ingest.log\");\r\n        try {\r\n            FileHandler fileHandler = new FileHandler(logFilePath.toString(), LOG_SIZE, LOG_FILE_COUNT);\r\n            fileHandler.setEncoding(PlatformUtil.getLogFileEncoding());\r\n            fileHandler.setFormatter(new Formatter() {\r\n                @Override\r\n                public String format(LogRecord record) {\r\n                    Throwable thrown = record.getThrown();\r\n                    String stackTrace = \"\";\r\n                    while (thrown != null) {\r\n                        stackTrace += thrown.toString() + NEWLINE;\r\n                        for (StackTraceElement traceElem : record.getThrown().getStackTrace()) {\r\n                            stackTrace += \"\\t\" + traceElem.toString() + NEWLINE;\r\n                        }\r\n                        thrown = thrown.getCause();\r\n                    }\r\n                    return (new Timestamp(record.getMillis())).toString() + \" \" + record.getSourceClassName() + \" \" + record.getSourceMethodName() + NEWLINE + record.getLevel() + \": \" + this.formatMessage(record) + NEWLINE + stackTrace;\r\n                }\r\n            });\r\n            logger.addHandler(fileHandler);\r\n            logger.setUseParentHandlers(false);\r\n        } catch (SecurityException | IOException ex) {\r\n            throw new RuntimeException(String.format(\"Error initializing file handler for %s\", logFilePath), ex);\r\n        }\r\n        configured = true;\r\n    }\r\n    return logger;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestSystemLogger.getLogger",
	"Comment": "gets a logger for the auto ingest system log, separate from both the caseauto ingest log and the application log.",
	"Method": "Logger getLogger(){\r\n    Throwable thrown = record.getThrown();\r\n    String stackTrace = \"\";\r\n    while (thrown != null) {\r\n        stackTrace += thrown.toString() + NEWLINE;\r\n        for (StackTraceElement traceElem : record.getThrown().getStackTrace()) {\r\n            stackTrace += \"\\t\" + traceElem.toString() + NEWLINE;\r\n        }\r\n        thrown = thrown.getCause();\r\n    }\r\n    return (new Timestamp(record.getMillis())).toString() + \" \" + record.getSourceClassName() + \" \" + record.getSourceMethodName() + NEWLINE + record.getLevel() + \": \" + this.formatMessage(record) + NEWLINE + stackTrace;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.PathUtils.findCaseDirectory",
	"Comment": "searches a given folder for the most recently modified case folder for acase.",
	"Method": "Path findCaseDirectory(Path folderToSearch,String caseName){\r\n    File searchFolder = new File(folderToSearch.toString());\r\n    if (!searchFolder.isDirectory()) {\r\n        return null;\r\n    }\r\n    Path caseFolderPath = null;\r\n    String[] candidateFolders = searchFolder.list(new CaseFolderFilter(caseName));\r\n    long mostRecentModified = 0;\r\n    for (String candidateFolder : candidateFolders) {\r\n        File file = new File(candidateFolder);\r\n        if (file.lastModified() >= mostRecentModified) {\r\n            mostRecentModified = file.lastModified();\r\n            caseFolderPath = Paths.get(folderToSearch.toString(), file.getPath());\r\n        }\r\n    }\r\n    return caseFolderPath;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.CentralRepoCommentDialog.getComment",
	"Comment": "get the current comment. if the user hit ok, this will be the newcomment. if the user canceled, this will be the original comment.",
	"Method": "String getComment(){\r\n    return currentComment;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.recentactivity.Firefox.extractDomain",
	"Comment": "extract the domain from the supplied url. this method does additionalchecks to detect invalid urls.",
	"Method": "String extractDomain(String url){\r\n    if (url == null || url.isEmpty()) {\r\n        return url;\r\n    }\r\n    if (url.toLowerCase().startsWith(PLACE_URL_PREFIX)) {\r\n        return null;\r\n    }\r\n    return NetworkUtils.extractDomain(url);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.datamodel.FileTypesByMimeType.isEmptyMimeTypeNode",
	"Comment": "method to check if the node in question is a bymimetypenode which isempty.",
	"Method": "boolean isEmptyMimeTypeNode(Node node){\r\n    boolean isEmptyMimeNode = false;\r\n    if (node instanceof FileTypesByMimeType.ByMimeTypeNode && ((FileTypesByMimeType.ByMimeTypeNode) node).isEmpty()) {\r\n        isEmptyMimeNode = true;\r\n    }\r\n    return isEmptyMimeNode;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.InstanceCountNode.getAttributeValues",
	"Comment": "get a list of metadata for the md5s which are children of this object.",
	"Method": "CommonAttributeValueList getAttributeValues(){\r\n    return this.attributeValues;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.encryptiondetection.EncryptionDetectionDataSourceIngestModule.validateSettings",
	"Comment": "validate the relevant settings for theencryptiondetectiondatasourceingestmodule",
	"Method": "void validateSettings(){\r\n    EncryptionDetectionTools.validateMinEntropyValue(minimumEntropy);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.explorernodes.EventNode.createEventNode",
	"Comment": "factory method to create an eventnode from the event id and the eventsmodel.",
	"Method": "EventNode createEventNode(Long eventID,FilteredEventsModel eventsModel){\r\n    final SingleEvent eventById = eventsModel.getEventById(eventID);\r\n    SleuthkitCase sleuthkitCase = Case.getCurrentCaseThrows().getSleuthkitCase();\r\n    AbstractFile file = sleuthkitCase.getAbstractFileById(eventById.getFileID());\r\n    if (eventById.getArtifactID().isPresent()) {\r\n        BlackboardArtifact blackboardArtifact = sleuthkitCase.getBlackboardArtifact(eventById.getArtifactID().get());\r\n        return new EventNode(eventById, file, blackboardArtifact);\r\n    } else {\r\n        return new EventNode(eventById, file);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.DataResultViewerTable.loadColumnVisibility",
	"Comment": "reads and applies the column visibility information persisted to thepreferences file.",
	"Method": "void loadColumnVisibility(){\r\n    if (rootNode == null || propertiesMap.isEmpty()) {\r\n        return;\r\n    }\r\n    if (rootNode instanceof TableFilterNode) {\r\n        final Preferences preferences = NbPreferences.forModule(DataResultViewerTable.class);\r\n        final TableFilterNode tfn = ((TableFilterNode) rootNode);\r\n        ETableColumnModel columnModel = (ETableColumnModel) outline.getColumnModel();\r\n        for (Map.Entry<Integer, Property<?>> entry : propertiesMap.entrySet()) {\r\n            final String propName = entry.getValue().getName();\r\n            boolean hidden = preferences.getBoolean(ResultViewerPersistence.getColumnHiddenKey(tfn, propName), false);\r\n            final TableColumn column = columnMap.get(propName);\r\n            columnModel.setColumnHidden(column, hidden);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.AbstractSqlEamDb.getCaseByUUID",
	"Comment": "retrieves case details based on case uuid from the central repo",
	"Method": "CorrelationCase getCaseByUUID(String caseUUID){\r\n    try {\r\n        return caseCacheByUUID.get(caseUUID, () -> getCaseByUUIDFromCr(caseUUID));\r\n    } catch (CacheLoader.InvalidCacheLoadException ignored) {\r\n        return null;\r\n    } catch (ExecutionException ex) {\r\n        throw new EamDbException(\"Error getting autopsy case from Central repo\", ex);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.testutils.IngestUtils.addDataSource",
	"Comment": "add the specified datasource to the case current case and processes it.causes failure if it was unable to add and process the datasource.",
	"Method": "void addDataSource(AutoIngestDataSourceProcessor dataSourceProcessor,Path dataSourcePath){\r\n    DataSourceProcessorCallback.DataSourceProcessorResult result = null;\r\n    try {\r\n        if (!dataSourcePath.toFile().exists()) {\r\n            Assert.fail(\"Data source not found: \" + dataSourcePath.toString());\r\n        }\r\n        DataSourceProcessorRunner.ProcessorCallback callBack = DataSourceProcessorRunner.runDataSourceProcessor(dataSourceProcessor, dataSourcePath);\r\n        result = callBack.getResult();\r\n        if (result.equals(DataSourceProcessorCallback.DataSourceProcessorResult.CRITICAL_ERRORS)) {\r\n            String joinedErrors = String.join(System.lineSeparator(), callBack.getErrorMessages());\r\n            Assert.fail(String.format(\"Error(s) occurred while running the data source processor: %s\", joinedErrors));\r\n        }\r\n    } catch (AutoIngestDataSourceProcessor.AutoIngestDataSourceProcessorException | InterruptedException ex) {\r\n        Exceptions.printStackTrace(ex);\r\n        Assert.fail(ex.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.events.CommentChangedEvent.getContentID",
	"Comment": "get the object id of the content which this event is associated with.",
	"Method": "long getContentID(){\r\n    return contentID;\r\n}"
}, {
	"Path": "com.mcxiaoke.next.utils.StringUtils.splitArrayElementsIntoProperties",
	"Comment": "take an array strings and split each element based on the givendelimiter. a properties instance is then generated, with theleft of the delimiter providing the key, and the right of the delimiterproviding the value.will trim both the key and value before adding them to theproperties instance.",
	"Method": "Properties splitArrayElementsIntoProperties(String[] array,String delimiter,Properties splitArrayElementsIntoProperties,String[] array,String delimiter,String charsToDelete){\r\n    if (isEmpty(array)) {\r\n        return null;\r\n    }\r\n    Properties result = new Properties();\r\n    for (String element : array) {\r\n        if (charsToDelete != null) {\r\n            element = deleteAny(element, charsToDelete);\r\n        }\r\n        String[] splittedElement = split(element, delimiter);\r\n        if (splittedElement == null) {\r\n            continue;\r\n        }\r\n        result.setProperty(splittedElement[0].trim(), splittedElement[1].trim());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.github.pires.obd.reader.io.ObdGatewayService.queueJob",
	"Comment": "this method will add a job to the queue while setting its id to theinternal queue counter.",
	"Method": "void queueJob(ObdCommandJob job){\r\n    job.getCommand().useImperialUnits(prefs.getBoolean(ConfigActivity.IMPERIAL_UNITS_KEY, false));\r\n    super.queueJob(job);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.hashdatabase.HashDbManager.getHashDatabaseFileExtension",
	"Comment": "gets the extension, without the dot separator, that the sleuthkitrequires for the hash database files that combine a database and an indexand can therefore be updated.",
	"Method": "String getHashDatabaseFileExtension(){\r\n    return HASH_DATABASE_FILE_EXTENSON;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestJobContext.processingUnallocatedSpace",
	"Comment": "queries whether or not unallocated space should be processed for theingest job associated with this context.",
	"Method": "boolean processingUnallocatedSpace(){\r\n    return this.ingestJob.shouldProcessUnallocatedSpace();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.CaseImportPanel.importDoneCallback",
	"Comment": "this method is called by the import thread as it is finishing.",
	"Method": "void importDoneCallback(boolean result,String resultString){\r\n    if (resultString == null || resultString.isEmpty()) {\r\n        pbShowProgress.setIndeterminate(false);\r\n        pbShowProgress.setValue(100);\r\n        if (result) {\r\n            setNotificationText(NotificationLabel.PROGRESS, NbBundle.getMessage(CaseImportPanel.class, \"CaseImportPanel.Complete\"), true);\r\n        } else {\r\n            setNotificationText(NotificationLabel.PROGRESS, NbBundle.getMessage(CaseImportPanel.class, \"CaseImportPanel.Error\"), result);\r\n        }\r\n    } else {\r\n        pbShowProgress.setIndeterminate(false);\r\n        if (result == true) {\r\n            pbShowProgress.setValue(0);\r\n        } else {\r\n            pbShowProgress.setValue(100);\r\n        }\r\n        setNotificationText(NotificationLabel.PROGRESS, resultString, result);\r\n    }\r\n    setButtonsForJobRunning(false);\r\n    ongoingImport = null;\r\n    showDbStatus();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.ArchiveUtil.isExtractionSupportedByMimeType",
	"Comment": "this method returns true if the mime type is currently supported. else itreturns false.",
	"Method": "boolean isExtractionSupportedByMimeType(String mimeType){\r\n    for (SupportedArchiveExtractionFormats s : SupportedArchiveExtractionFormats.values()) {\r\n        if (s.toString().equals(mimeType)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.services.TagNameDialog.display",
	"Comment": "sets display settings for the dialog and adds appropriate listeners.",
	"Method": "void display(){\r\n    setLayout(new BorderLayout());\r\n    setLocationRelativeTo(WindowManager.getDefault().getMainWindow());\r\n    this.addWindowListener(new WindowAdapter() {\r\n        @Override\r\n        public void windowClosing(WindowEvent e) {\r\n            doButtonAction(false);\r\n        }\r\n    });\r\n    tagNameTextField.getDocument().addDocumentListener(new DocumentListener() {\r\n        @Override\r\n        public void changedUpdate(DocumentEvent e) {\r\n            fire();\r\n        }\r\n        @Override\r\n        public void removeUpdate(DocumentEvent e) {\r\n            fire();\r\n        }\r\n        @Override\r\n        public void insertUpdate(DocumentEvent e) {\r\n            fire();\r\n        }\r\n        private void fire() {\r\n            enableOkButton();\r\n        }\r\n    });\r\n    enableOkButton();\r\n    setResizable(false);\r\n    setVisible(true);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.services.TagNameDialog.display",
	"Comment": "sets display settings for the dialog and adds appropriate listeners.",
	"Method": "void display(){\r\n    doButtonAction(false);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.services.TagNameDialog.display",
	"Comment": "sets display settings for the dialog and adds appropriate listeners.",
	"Method": "void display(){\r\n    fire();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.services.TagNameDialog.display",
	"Comment": "sets display settings for the dialog and adds appropriate listeners.",
	"Method": "void display(){\r\n    fire();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.services.TagNameDialog.display",
	"Comment": "sets display settings for the dialog and adds appropriate listeners.",
	"Method": "void display(){\r\n    fire();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.services.TagNameDialog.display",
	"Comment": "sets display settings for the dialog and adds appropriate listeners.",
	"Method": "void display(){\r\n    enableOkButton();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.configuration.AutoIngestSettingsPanel.isResetNeeded",
	"Comment": "determines whether settings requiring a restart have changed, and alsoupdates the ui.",
	"Method": "boolean isResetNeeded(){\r\n    boolean resetNeeded = false;\r\n    String oldInputPath = inputPathTextField.getText().trim();\r\n    String oldOutputPath = outputPathTextField.getText().trim();\r\n    load(false);\r\n    if (!oldInputPath.equals(inputPathTextField.getText().trim())) {\r\n        resetNeeded = true;\r\n    }\r\n    if (!oldOutputPath.equals(outputPathTextField.getText().trim())) {\r\n        resetNeeded = true;\r\n    }\r\n    if (!this.oldIngestThreads.equals(UserPreferences.numberOfFileIngestThreads())) {\r\n        resetNeeded = true;\r\n    }\r\n    return resetNeeded;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.hashdatabase.ModalNoButtons.indexThese",
	"Comment": "takes the list of unindexed databases and indexes them, setting varioustext labels along the way.",
	"Method": "void indexThese(){\r\n    length = this.unindexed.size();\r\n    this.INDEXING_PROGBAR.setIndeterminate(true);\r\n    for (SleuthkitHashSet db : this.unindexed) {\r\n        currentDb = db.getHashSetName();\r\n        this.CURRENTDB_LABEL.setText(\"(\" + currentDb + \")\");\r\n        this.CURRENTLYON_LABEL.setText(NbBundle.getMessage(this.getClass(), \"ModalNoButtons.indexThese.currentlyIndexing1OfNDbs\", length));\r\n        if (!db.isIndexing()) {\r\n            db.addPropertyChangeListener(this);\r\n            HashDbManager.getInstance().indexHashDatabase(db);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.testutils.IngestUtils.runIngestJob",
	"Comment": "run ingest on the specified datasources with the specified ingest jobsettings. causes failure if there are any errors or other problems whilerunning ingest.",
	"Method": "void runIngestJob(List<Content> datasources,IngestJobSettings ingestJobSettings){\r\n    try {\r\n        List<IngestModuleError> errs = IngestJobRunner.runIngestJob(datasources, ingestJobSettings);\r\n        StringBuilder joinedErrors = new StringBuilder(\"\");\r\n        errs.forEach((err) -> {\r\n            joinedErrors.append(String.format(\"Error: %s: %s.\", err.getModuleDisplayName(), err.toString())).append(System.lineSeparator());\r\n        });\r\n        assertEquals(joinedErrors.toString(), 0, errs.size());\r\n    } catch (InterruptedException ex) {\r\n        Exceptions.printStackTrace(ex);\r\n        Assert.fail(ex.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.AbstractSqlEamDb.getCountArtifactInstancesByCaseDataSource",
	"Comment": "retrieves number of eamartifact instances in the database that areassociated with the casedisplayname and datasource of the giveneamartifact instance.",
	"Method": "Long getCountArtifactInstancesByCaseDataSource(CorrelationDataSource correlationDataSource){\r\n    Connection conn = connect();\r\n    Long instanceCount = 0L;\r\n    List<CorrelationAttributeInstance.Type> artifactTypes = getDefinedCorrelationTypes();\r\n    PreparedStatement preparedStatement = null;\r\n    ResultSet resultSet = null;\r\n    String sql = \"SELECT 0 \";\r\n    for (CorrelationAttributeInstance.Type type : artifactTypes) {\r\n        String table_name = EamDbUtil.correlationTypeToInstanceTableName(type);\r\n        sql += \"+ (SELECT count(*) FROM \" + table_name + \" WHERE data_source_id=\" + correlationDataSource.getID() + \")\";\r\n    }\r\n    try {\r\n        preparedStatement = conn.prepareStatement(sql);\r\n        resultSet = preparedStatement.executeQuery();\r\n        resultSet.next();\r\n        instanceCount = resultSet.getLong(1);\r\n    } catch (SQLException ex) {\r\n        throw new EamDbException(\"Error counting artifact instances by caseName/dataSource.\", ex);\r\n    } finally {\r\n        EamDbUtil.closeStatement(preparedStatement);\r\n        EamDbUtil.closeResultSet(resultSet);\r\n        EamDbUtil.closeConnection(conn);\r\n    }\r\n    return instanceCount;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.embeddedfileextractor.SevenZipExtractor.unpack",
	"Comment": "unpack the file to local folder and return a list of derived files, usethe password if specified.",
	"Method": "void unpack(AbstractFile archiveFile,ConcurrentHashMap<Long, Archive> depthMap,boolean unpack,AbstractFile archiveFile,ConcurrentHashMap<Long, Archive> depthMap,String password){\r\n    boolean unpackSuccessful = true;\r\n    boolean hasEncrypted = false;\r\n    boolean fullEncryption = true;\r\n    boolean progressStarted = false;\r\n    final String archiveFilePath = getArchiveFilePath(archiveFile);\r\n    final String escapedArchiveFilePath = FileUtil.escapeFileName(archiveFilePath);\r\n    HashMap<String, ZipFileStatusWrapper> statusMap = new HashMap();\r\n    List<AbstractFile> unpackedFiles = Collections.<AbstractFile>emptyList();\r\n    ISevenZipInArchive inArchive = null;\r\n    currentArchiveName = archiveFile.getName();\r\n    SevenZipContentReadStream stream = null;\r\n    progress = ProgressHandle.createHandle(Bundle.EmbeddedFileExtractorIngestModule_ArchiveExtractor_moduleName());\r\n    Archive parentAr;\r\n    try {\r\n        blackboard = Case.getCurrentCaseThrows().getServices().getBlackboard();\r\n    } catch (NoCurrentCaseException ex) {\r\n        logger.log(Level.INFO, \"Exception while getting open case.\", ex);\r\n        unpackSuccessful = false;\r\n        return unpackSuccessful;\r\n    }\r\n    try {\r\n        List<AbstractFile> existingFiles = getAlreadyExtractedFiles(archiveFile, archiveFilePath);\r\n        for (AbstractFile file : existingFiles) {\r\n            statusMap.put(getKeyAbstractFile(file), new ZipFileStatusWrapper(file, ZipFileStatus.EXISTS));\r\n        }\r\n    } catch (TskCoreException e) {\r\n        logger.log(Level.INFO, \"Error checking if file already has been processed, skipping: {0}\", escapedArchiveFilePath);\r\n        unpackSuccessful = false;\r\n        return unpackSuccessful;\r\n    } catch (NoCurrentCaseException ex) {\r\n        logger.log(Level.INFO, \"No open case was found while trying to unpack the archive file {0}\", escapedArchiveFilePath);\r\n        unpackSuccessful = false;\r\n        return unpackSuccessful;\r\n    }\r\n    parentAr = depthMap.get(archiveFile.getId());\r\n    if (parentAr == null) {\r\n        parentAr = new Archive(0, archiveFile.getId(), archiveFile);\r\n        depthMap.put(archiveFile.getId(), parentAr);\r\n    } else {\r\n        Archive rootArchive = depthMap.get(parentAr.getRootArchiveId());\r\n        if (rootArchive.isFlaggedAsZipBomb()) {\r\n            unpackSuccessful = false;\r\n            return unpackSuccessful;\r\n        } else if (parentAr.getDepth() == MAX_DEPTH) {\r\n            String details = NbBundle.getMessage(SevenZipExtractor.class, \"EmbeddedFileExtractorIngestModule.ArchiveExtractor.unpack.warnDetails.zipBomb\", parentAr.getDepth(), FileUtil.escapeFileName(getArchiveFilePath(rootArchive.getArchiveFile())));\r\n            flagRootArchiveAsZipBomb(rootArchive, archiveFile, details, escapedArchiveFilePath);\r\n            unpackSuccessful = false;\r\n            return unpackSuccessful;\r\n        }\r\n    }\r\n    try {\r\n        stream = new SevenZipContentReadStream(new ReadContentInputStream(archiveFile));\r\n        ArchiveFormat options = get7ZipOptions(archiveFile);\r\n        if (password == null) {\r\n            inArchive = SevenZip.openInArchive(options, stream);\r\n        } else {\r\n            inArchive = SevenZip.openInArchive(options, stream, password);\r\n        }\r\n        numItems = inArchive.getNumberOfItems();\r\n        progress.start(numItems);\r\n        progressStarted = true;\r\n        final String uniqueArchiveFileName = FileUtil.escapeFileName(EmbeddedFileExtractorIngestModule.getUniqueName(archiveFile));\r\n        try {\r\n            makeLocalDirectories(uniqueArchiveFileName);\r\n        } catch (SecurityException e) {\r\n            logger.log(Level.SEVERE, \"Error setting up output path for archive root: {0}\", getLocalRootAbsPath(uniqueArchiveFileName));\r\n            unpackSuccessful = false;\r\n            return unpackSuccessful;\r\n        }\r\n        SevenZipExtractor.UnpackedTree unpackedTree = new SevenZipExtractor.UnpackedTree(moduleDirRelative + \"/\" + uniqueArchiveFileName, archiveFile);\r\n        long freeDiskSpace;\r\n        try {\r\n            freeDiskSpace = services.getFreeDiskSpace();\r\n        } catch (NullPointerException ex) {\r\n            freeDiskSpace = IngestMonitor.DISK_FREE_SPACE_UNKNOWN;\r\n        }\r\n        Map<Integer, InArchiveItemDetails> archiveDetailsMap = new HashMap();\r\n        for (int inArchiveItemIndex = 0; inArchiveItemIndex < numItems; inArchiveItemIndex++) {\r\n            progress.progress(String.format(\"%s: Analyzing archive metadata and creating local files (%d of %d)\", currentArchiveName, inArchiveItemIndex + 1, numItems), 0);\r\n            if (isZipBombArchiveItemCheck(archiveFile, inArchive, inArchiveItemIndex, depthMap, escapedArchiveFilePath)) {\r\n                unpackSuccessful = false;\r\n                return unpackSuccessful;\r\n            }\r\n            String pathInArchive = getPathInArchive(inArchive, inArchiveItemIndex, archiveFile);\r\n            UnpackedTree.UnpackedNode unpackedNode = unpackedTree.addNode(pathInArchive);\r\n            final boolean isEncrypted = (Boolean) inArchive.getProperty(inArchiveItemIndex, PropID.ENCRYPTED);\r\n            if (isEncrypted && password == null) {\r\n                logger.log(Level.WARNING, \"Skipping encrypted file in archive: {0}\", pathInArchive);\r\n                hasEncrypted = true;\r\n                unpackSuccessful = false;\r\n                continue;\r\n            } else {\r\n                fullEncryption = false;\r\n            }\r\n            Long archiveItemSize = (Long) inArchive.getProperty(inArchiveItemIndex, PropID.SIZE);\r\n            if (freeDiskSpace != IngestMonitor.DISK_FREE_SPACE_UNKNOWN && archiveItemSize != null && archiveItemSize > 0) {\r\n                String archiveItemPath = (String) inArchive.getProperty(inArchiveItemIndex, PropID.PATH);\r\n                long newDiskSpace = freeDiskSpace - archiveItemSize;\r\n                if (newDiskSpace < MIN_FREE_DISK_SPACE) {\r\n                    String msg = NbBundle.getMessage(SevenZipExtractor.class, \"EmbeddedFileExtractorIngestModule.ArchiveExtractor.unpack.notEnoughDiskSpace.msg\", escapedArchiveFilePath, archiveItemPath);\r\n                    String details = NbBundle.getMessage(SevenZipExtractor.class, \"EmbeddedFileExtractorIngestModule.ArchiveExtractor.unpack.notEnoughDiskSpace.details\");\r\n                    services.postMessage(IngestMessage.createErrorMessage(EmbeddedFileExtractorModuleFactory.getModuleName(), msg, details));\r\n                    logger.log(Level.INFO, \"Skipping archive item due to insufficient disk space: {0}, {1}\", new String[] { escapedArchiveFilePath, archiveItemPath });\r\n                    logger.log(Level.INFO, \"Available disk space: {0}\", new Object[] { freeDiskSpace });\r\n                    unpackSuccessful = false;\r\n                    continue;\r\n                } else {\r\n                    freeDiskSpace = newDiskSpace;\r\n                }\r\n            }\r\n            final String uniqueExtractedName = FileUtil.escapeFileName(uniqueArchiveFileName + File.separator + (inArchiveItemIndex / 1000) + File.separator + inArchiveItemIndex + \"_\" + new File(pathInArchive).getName());\r\n            final String localAbsPath = moduleDirAbsolute + File.separator + uniqueExtractedName;\r\n            final String localRelPath = moduleDirRelative + File.separator + uniqueExtractedName;\r\n            File localFile = new java.io.File(localAbsPath);\r\n            if (!localFile.exists()) {\r\n                try {\r\n                    if ((Boolean) inArchive.getProperty(inArchiveItemIndex, PropID.IS_FOLDER)) {\r\n                        localFile.mkdirs();\r\n                    } else {\r\n                        localFile.getParentFile().mkdirs();\r\n                        try {\r\n                            localFile.createNewFile();\r\n                        } catch (IOException e) {\r\n                            logger.log(Level.SEVERE, \"Error creating extracted file: \" + localFile.getAbsolutePath(), e);\r\n                        }\r\n                    }\r\n                } catch (SecurityException e) {\r\n                    logger.log(Level.SEVERE, \"Error setting up output path for unpacked file: {0}\", pathInArchive);\r\n                }\r\n            }\r\n            if (localFile.exists() == false) {\r\n                continue;\r\n            }\r\n            archiveDetailsMap.put(inArchiveItemIndex, new InArchiveItemDetails(unpackedNode, localAbsPath, localRelPath));\r\n        }\r\n        int[] extractionIndices = getExtractableFilesFromDetailsMap(archiveDetailsMap);\r\n        StandardIArchiveExtractCallback archiveCallBack = new StandardIArchiveExtractCallback(inArchive, archiveFile, progress, archiveDetailsMap, password, freeDiskSpace);\r\n        inArchive.extract(extractionIndices, false, archiveCallBack);\r\n        unpackSuccessful = unpackSuccessful & archiveCallBack.wasSuccessful();\r\n        archiveDetailsMap = null;\r\n        try {\r\n            unpackedTree.updateOrAddFileToCaseRec(statusMap, archiveFilePath);\r\n            unpackedFiles = unpackedTree.getAllFileObjects();\r\n            for (int i = 0; i < unpackedFiles.size(); i++) {\r\n                progress.progress(String.format(\"%s: Searching for nested archives (%d of %d)\", currentArchiveName, i + 1, unpackedFiles.size()));\r\n                AbstractFile unpackedFile = unpackedFiles.get(i);\r\n                if (unpackedFile == null) {\r\n                    continue;\r\n                }\r\n                if (isSevenZipExtractionSupported(unpackedFile)) {\r\n                    Archive child = new Archive(parentAr.getDepth() + 1, parentAr.getRootArchiveId(), archiveFile);\r\n                    parentAr.addChild(child);\r\n                    depthMap.put(unpackedFile.getId(), child);\r\n                }\r\n            }\r\n        } catch (TskCoreException | NoCurrentCaseException e) {\r\n            logger.log(Level.SEVERE, \"Error populating complete derived file hierarchy from the unpacked dir structure\", e);\r\n        }\r\n    } catch (SevenZipException ex) {\r\n        logger.log(Level.WARNING, \"Error unpacking file: \" + archiveFile, ex);\r\n        if (archiveFile.isMetaFlagSet(TskData.TSK_FS_META_FLAG_ENUM.ALLOC)) {\r\n            String msg = NbBundle.getMessage(SevenZipExtractor.class, \"EmbeddedFileExtractorIngestModule.ArchiveExtractor.unpack.errUnpacking.msg\", currentArchiveName);\r\n            String details = NbBundle.getMessage(SevenZipExtractor.class, \"EmbeddedFileExtractorIngestModule.ArchiveExtractor.unpack.errUnpacking.details\", escapedArchiveFilePath, ex.getMessage());\r\n            services.postMessage(IngestMessage.createErrorMessage(EmbeddedFileExtractorModuleFactory.getModuleName(), msg, details));\r\n        }\r\n    } finally {\r\n        if (inArchive != null) {\r\n            try {\r\n                inArchive.close();\r\n            } catch (SevenZipException e) {\r\n                logger.log(Level.SEVERE, \"Error closing archive: \" + archiveFile, e);\r\n            }\r\n        }\r\n        if (stream != null) {\r\n            try {\r\n                stream.close();\r\n            } catch (IOException ex) {\r\n                logger.log(Level.SEVERE, \"Error closing stream after unpacking archive: \" + archiveFile, ex);\r\n            }\r\n        }\r\n        if (progressStarted) {\r\n            progress.finish();\r\n        }\r\n    }\r\n    if (hasEncrypted) {\r\n        String encryptionType = fullEncryption ? ENCRYPTION_FULL : ENCRYPTION_FILE_LEVEL;\r\n        try {\r\n            BlackboardArtifact artifact = archiveFile.newArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_ENCRYPTION_DETECTED);\r\n            artifact.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_COMMENT, EmbeddedFileExtractorModuleFactory.getModuleName(), encryptionType));\r\n            try {\r\n                blackboard.indexArtifact(artifact);\r\n            } catch (Blackboard.BlackboardException ex) {\r\n                logger.log(Level.SEVERE, \"Unable to index blackboard artifact \" + artifact.getArtifactID(), ex);\r\n                MessageNotifyUtil.Notify.error(Bundle.SevenZipExtractor_indexError_message(), artifact.getDisplayName());\r\n            }\r\n            services.fireModuleDataEvent(new ModuleDataEvent(EmbeddedFileExtractorModuleFactory.getModuleName(), BlackboardArtifact.ARTIFACT_TYPE.TSK_ENCRYPTION_DETECTED));\r\n        } catch (TskCoreException ex) {\r\n            logger.log(Level.SEVERE, \"Error creating blackboard artifact for encryption detected for file: \" + escapedArchiveFilePath, ex);\r\n        }\r\n        String msg = NbBundle.getMessage(SevenZipExtractor.class, \"EmbeddedFileExtractorIngestModule.ArchiveExtractor.unpack.encrFileDetected.msg\");\r\n        String details = NbBundle.getMessage(SevenZipExtractor.class, \"EmbeddedFileExtractorIngestModule.ArchiveExtractor.unpack.encrFileDetected.details\", currentArchiveName, EmbeddedFileExtractorModuleFactory.getModuleName());\r\n        services.postMessage(IngestMessage.createWarningMessage(EmbeddedFileExtractorModuleFactory.getModuleName(), msg, details));\r\n    }\r\n    if (!unpackedFiles.isEmpty()) {\r\n        services.fireModuleContentEvent(new ModuleContentEvent(archiveFile));\r\n        if (context != null) {\r\n            context.addFilesToJob(unpackedFiles);\r\n        }\r\n    }\r\n    return unpackSuccessful;\r\n}"
}, {
	"Path": "org.wikipedia.page.PageActivity.loadMainPage",
	"Comment": "go directly to the main page of the current wiki, optionally allowing state loss of thefragment manager. useful for when this function is called from an asynctask result.",
	"Method": "void loadMainPage(TabPosition position){\r\n    PageTitle title = MainPageClient.getMainPageTitle();\r\n    HistoryEntry historyEntry = new HistoryEntry(title, HistoryEntry.SOURCE_MAIN_PAGE);\r\n    loadPage(title, historyEntry, position);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagewriter.ImageWriter.waitForJobToFinish",
	"Comment": "blocks while all finishimage tasks complete.also makes sure the progressupdatetask is canceled.",
	"Method": "void waitForJobToFinish(){\r\n    synchronized (currentTasksLock) {\r\n        if (isStarted) {\r\n            try {\r\n                finishTask.get();\r\n            } catch (InterruptedException | ExecutionException ex) {\r\n                Logger.getLogger(ImageWriter.class.getName()).log(Level.SEVERE, \"Error finishing VHD image\", ex);\r\n            }\r\n            if (doUI) {\r\n                progressUpdateTask.cancel(true);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.recentactivity.Extract.dbConnect",
	"Comment": "returns a list from a result set based on sql query. this is used toquery sqlite databases storing user recent activity data, such as infirefox sqlite db",
	"Method": "List<HashMap<String, Object>> dbConnect(String path,String query){\r\n    ResultSet temprs;\r\n    List<HashMap<String, Object>> list;\r\n    String connectionString = \"jdbc:sqlite:\" + path;\r\n    try {\r\n        SQLiteDBConnect tempdbconnect = new SQLiteDBConnect(\"org.sqlite.JDBC\", connectionString);\r\n        temprs = tempdbconnect.executeQry(query);\r\n        list = this.resultSetToArrayList(temprs);\r\n        tempdbconnect.closeConnection();\r\n    } catch (SQLException ex) {\r\n        logger.log(Level.SEVERE, \"Error while trying to read into a sqlite db.\" + connectionString, ex);\r\n        errorMessages.add(NbBundle.getMessage(this.getClass(), \"Extract.dbConn.errMsg.failedToQueryDb\", getName()));\r\n        return Collections.<HashMap<String, Object>>emptyList();\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJobsPanel.refresh",
	"Comment": "update the contents of this autoingestjobspanel while retaining currentlyselected node.",
	"Method": "void refresh(AutoIngestRefreshEvent refreshEvent){\r\n    synchronized (this) {\r\n        outline.setRowSelectionAllowed(false);\r\n        if (explorerManager.getRootContext() instanceof AutoIngestJobsNode) {\r\n            ((AutoIngestJobsNode) explorerManager.getRootContext()).refresh(refreshEvent);\r\n        } else {\r\n            explorerManager.setRootContext(new AutoIngestJobsNode(refreshEvent.getMonitor(), status, new EventBus(\"AutoIngestJobsNodeEventBus\")));\r\n        }\r\n        outline.setRowSelectionAllowed(true);\r\n        outline.setFocusable(true);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.datamodel.HashSetManager.getHashSetsForFileHelper",
	"Comment": "helper method to load hashset hits for the given fileid from the db",
	"Method": "Set<String> getHashSetsForFileHelper(long fileID){\r\n    try {\r\n        return drawableDB.getHashSetsForFile(fileID);\r\n    } catch (TskCoreException ex) {\r\n        Logger.getLogger(HashSetManager.class.getName()).log(Level.SEVERE, String.format(\"Failed to get hash sets for file (id=%d)\", fileID), ex);\r\n        return Collections.emptySet();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.fileextmismatch.FileExtMismatchDetectorModuleSettings.setSkipFilesWithNoExtension",
	"Comment": "sets the flag indicating whether or not files without extensions shouldbe skipped during file extension mismatch checking.",
	"Method": "void setSkipFilesWithNoExtension(boolean skipFilesWithNoExtension){\r\n    this.skipFilesWithNoExtension = skipFilesWithNoExtension;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.InterCasePanel.centralRepoHasMultipleCases",
	"Comment": "whether or not the central repository has multiple cases in it.",
	"Method": "boolean centralRepoHasMultipleCases(){\r\n    return this.caseMap.size() >= 2;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestControlPanel.refreshTable",
	"Comment": "reloads the table model for an auto ingest jobs table, refreshing thejtable that uses the model.",
	"Method": "void refreshTable(List<AutoIngestJob> jobs,DefaultTableModel tableModel,Comparator<AutoIngestJob> comparator){\r\n    try {\r\n        if (comparator != null) {\r\n            jobs.sort(comparator);\r\n        }\r\n        tableModel.setRowCount(0);\r\n        for (AutoIngestJob job : jobs) {\r\n            AutoIngestJob.StageDetails status = job.getProcessingStageDetails();\r\n            tableModel.addRow(new Object[] { job.getManifest().getCaseName(), job.getManifest().getDataSourcePath().getFileName(), job.getProcessingHostName(), job.getManifest().getDateFileCreated(), job.getProcessingStageStartDate(), job.getCompletedDate(), status.getDescription(), job.getErrorsOccurred() ? StatusIconCellRenderer.Status.WARNING : StatusIconCellRenderer.Status.OK, ((Date.from(Instant.now()).getTime()) - (status.getStartDate().getTime())), job.getCaseDirectoryPath(), job.getProcessingHostName().equals(LOCAL_HOST_NAME), job.getManifest().getFilePath(), job.getPriority() });\r\n        }\r\n    } catch (Exception ex) {\r\n        sysLogger.log(Level.SEVERE, \"Dashboard error refreshing table\", ex);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.test.CustomArtifactsCreatorIngestModuleFactory.isDataSourceIngestModuleFactory",
	"Comment": "queries the factory to determine if it is capable of creating data sourceingest modules.",
	"Method": "boolean isDataSourceIngestModuleFactory(){\r\n    return true;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.services.TagsManager.getBlackboardArtifactTagsCountByTagNameForUser",
	"Comment": "gets an artifact tags count by tag name, for the given data source anduser.",
	"Method": "long getBlackboardArtifactTagsCountByTagNameForUser(TagName tagName,String userName,long getBlackboardArtifactTagsCountByTagNameForUser,TagName tagName,long dsObjId,String userName){\r\n    long count = 0;\r\n    List<BlackboardArtifactTag> artifactTags = getBlackboardArtifactTagsByTagName(tagName, dsObjId);\r\n    for (BlackboardArtifactTag tag : artifactTags) {\r\n        if (userName.equals(tag.getUserName())) {\r\n            count++;\r\n        }\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.datamodel.AbstractContentNode.contentHasVisibleContentChildren",
	"Comment": "return true if the given content object has children. useful for lazyloading.",
	"Method": "boolean contentHasVisibleContentChildren(Content c){\r\n    if (c != null) {\r\n        try {\r\n            if (!c.hasChildren()) {\r\n                return false;\r\n            }\r\n        } catch (TskCoreException ex) {\r\n            logger.log(Level.SEVERE, \"Error checking if the node has children, for content: \" + c, ex);\r\n            return false;\r\n        }\r\n        String query = \"SELECT COUNT(obj_id) AS count FROM \" + \" ( SELECT obj_id FROM tsk_objects WHERE par_obj_id = \" + c.getId() + \" AND type = \" + TskData.ObjectType.ARTIFACT.getObjectType() + \"   INTERSECT SELECT artifact_obj_id FROM blackboard_artifacts WHERE obj_id = \" + c.getId() + \"     AND (artifact_type_id = \" + ARTIFACT_TYPE.TSK_EMAIL_MSG.getTypeID() + \" OR artifact_type_id = \" + ARTIFACT_TYPE.TSK_MESSAGE.getTypeID() + \") \" + \"   UNION SELECT obj_id FROM tsk_objects WHERE par_obj_id = \" + c.getId() + \"     AND type = \" + TskData.ObjectType.ABSTRACTFILE.getObjectType() + \") AS OBJECT_IDS\";\r\n        try (SleuthkitCase.CaseDbQuery dbQuery = Case.getCurrentCaseThrows().getSleuthkitCase().executeQuery(query)) {\r\n            ResultSet resultSet = dbQuery.getResultSet();\r\n            if (resultSet.next()) {\r\n                return (0 < resultSet.getInt(\"count\"));\r\n            }\r\n        } catch (TskCoreException | SQLException | NoCurrentCaseException ex) {\r\n            logger.log(Level.SEVERE, \"Error checking if the node has children, for content: \" + c, ex);\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.AutopsyOptionsPanel.getSystemMemoryInGB",
	"Comment": "get the total system memory in gigabytes which exists on the machinewhich the application is running.",
	"Method": "long getSystemMemoryInGB(){\r\n    long memorySize = ((com.sun.management.OperatingSystemMXBean) ManagementFactory.getOperatingSystemMXBean()).getTotalPhysicalMemorySize();\r\n    return memorySize / ONE_BILLION;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.ImageUtils.thumbnailSupported",
	"Comment": "can a thumbnail be generated for the content?although this method accepts content, it always returns false for objectsthat are not instances of abstractfile.",
	"Method": "boolean thumbnailSupported(Content content){\r\n    if (!(content instanceof AbstractFile)) {\r\n        return false;\r\n    }\r\n    AbstractFile file = (AbstractFile) content;\r\n    List<String> supportedExtensions = new ArrayList(SUPPORTED_IMAGE_EXTENSIONS);\r\n    supportedExtensions.addAll(VideoUtils.getSupportedVideoExtensions());\r\n    if (isSupportedMediaExtension(file, supportedExtensions)) {\r\n        return true;\r\n    }\r\n    return VideoUtils.isVideoThumbnailSupported(file) || isImageThumbnailSupported(file);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.datamodel.FilteredEventsModel.postTagsDeleted",
	"Comment": "post a tagsdeletedevent to all registered subscribers, if the given setof updated event ids is not empty.",
	"Method": "boolean postTagsDeleted(Set<Long> updatedEventIDs){\r\n    boolean tagsUpdated = !updatedEventIDs.isEmpty();\r\n    if (tagsUpdated) {\r\n        eventbus.post(new TagsDeletedEvent(updatedEventIDs));\r\n    }\r\n    return tagsUpdated;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.IntraCasePanel.setDataSourceMap",
	"Comment": "update the map of datasources that this panel allows the user to selectfrom",
	"Method": "void setDataSourceMap(Map<Long, String> dataSourceMap){\r\n    this.dataSourceMap.clear();\r\n    this.dataSourceMap.putAll(dataSourceMap);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.hashdatabase.AddHashValuesToDatabaseProgressDialog.finish",
	"Comment": "sets the progressbar to maximum value, change colors accordingly, andenables ok button.",
	"Method": "void finish(boolean success){\r\n    okButton.setEnabled(true);\r\n    addingHashesToDatabaseProgressBar.setIndeterminate(false);\r\n    addingHashesToDatabaseProgressBar.setValue(addingHashesToDatabaseProgressBar.getMaximum());\r\n    if (success) {\r\n        addingHashesToDatabaseProgressBar.setStringPainted(true);\r\n        addingHashesToDatabaseProgressBar.setForeground(new Color(50, 205, 50));\r\n        addingHashesToDatabaseProgressBar.setString(\"\");\r\n    } else {\r\n        addingHashesToDatabaseProgressBar.setStringPainted(true);\r\n        addingHashesToDatabaseProgressBar.setForeground(new Color(178, 34, 34));\r\n        addingHashesToDatabaseProgressBar.setString(\"\");\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.datamodel.CategoryManager.unregisterListener",
	"Comment": "unregister an object from receiving categorychangeevents",
	"Method": "void unregisterListener(Object listener){\r\n    try {\r\n        categoryEventBus.unregister(listener);\r\n    } catch (IllegalArgumentException e) {\r\n        if (!e.getMessage().contains(\"missing event subscriber for an annotated method. Is \" + listener + \" registered?\")) {\r\n            throw e;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.gui.Toolbar.syncGroupControlsEnabledState",
	"Comment": "disable the tag and catagory controls if and only if there is no groupselected.",
	"Method": "void syncGroupControlsEnabledState(GroupViewState newViewState){\r\n    boolean noGroupSelected = (null == newViewState) || (null == newViewState.getGroup());\r\n    Platform.runLater(() -> {\r\n        tagGroupMenuButton.setDisable(noGroupSelected);\r\n        catGroupMenuButton.setDisable(noGroupSelected);\r\n    });\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.SqliteEamDb.getDataSource",
	"Comment": "retrieves data source details based on data source device id",
	"Method": "CorrelationDataSource getDataSource(CorrelationCase correlationCase,Long caseDbDataSourceId){\r\n    try {\r\n        acquireSharedLock();\r\n        return super.getDataSource(correlationCase, caseDbDataSourceId);\r\n    } finally {\r\n        releaseSharedLock();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.ReportKML.makePoint",
	"Comment": "create a point for use in a placemark. note in this method altitude isignored, as google earth apparently has trouble using altitudes forlinestrings, though the parameters are still in the call. also note thatany null value passed in will be set to 0.0, under the idea that it isbetter to show some data with gaps, than to show nothing at all.",
	"Method": "Element makePoint(Double latitude,Double longitude,Double altitude){\r\n    if (latitude == null) {\r\n        latitude = 0.0;\r\n    }\r\n    if (longitude == null) {\r\n        longitude = 0.0;\r\n    }\r\n    if (altitude == null) {\r\n        altitude = 0.0;\r\n    }\r\n    Element point = new Element(\"Point\", ns);\r\n    Element coordinates = new Element(\"coordinates\", ns).addContent(longitude + \",\" + latitude + \",\" + altitude);\r\n    if (altitude != 0) {\r\n        Element altitudeMode = new Element(\"altitudeMode\", ns).addContent(\"clampToGround\");\r\n        point.addContent(altitudeMode);\r\n    }\r\n    point.addContent(coordinates);\r\n    return point;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.datamodel.RootContentChildren.refreshContentKeys",
	"Comment": "refresh all content keys this creates new nodes of keys have changed.todo ideally, nodes would respond to event from wrapped content objectbut we are not ready for this.",
	"Method": "void refreshContentKeys(){\r\n    contentKeys.forEach(this::refreshKey);\r\n}"
}, {
	"Path": "net.dongliu.apk.parser.utils.ParseUtils.readString",
	"Comment": "read string from input buffer. if get eof before read enough data, throw ioexception.",
	"Method": "String readString(ByteBuffer buffer,boolean utf8){\r\n    if (utf8) {\r\n        int strLen = readLen(buffer);\r\n        int bytesLen = readLen(buffer);\r\n        byte[] bytes = Buffers.readBytes(buffer, bytesLen);\r\n        String str = new String(bytes, charsetUTF8);\r\n        int trailling = Buffers.readUByte(buffer);\r\n        return str;\r\n    } else {\r\n        int strLen = readLen16(buffer);\r\n        String str = Buffers.readString(buffer, strLen);\r\n        int trailling = Buffers.readUShort(buffer);\r\n        return str;\r\n    }\r\n}"
}, {
	"Path": "com.aliyun.oss.model.Callback.setCallbackHost",
	"Comment": "sets the callback host, only valid when callbackurl is set. if this isnot set, the host will be extracted from the callbackurl.",
	"Method": "void setCallbackHost(String callbackHost){\r\n    this.callbackHost = callbackHost;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.runIngestModuleWizard.RunIngestModulesAction.actionPerformed",
	"Comment": "opens a run ingest modules wizard with the list of data sources.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    RootPaneContainer root = (RootPaneContainer) WindowManager.getDefault().getMainWindow();\r\n    root.getGlassPane().setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\r\n    root.getGlassPane().setVisible(true);\r\n    RunIngestModulesWizardIterator wizard = new RunIngestModulesWizardIterator(EXECUTION_CONTEXT, this.ingestType, this.dataSources);\r\n    WizardDescriptor wiz = new WizardDescriptor(wizard);\r\n    wiz.setTitleFormat(new MessageFormat(\"{0}\"));\r\n    wiz.setTitle(Bundle.RunIngestModulesAction_name());\r\n    root.getGlassPane().setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));\r\n    root.getGlassPane().setVisible(false);\r\n    if (DialogDisplayer.getDefault().notify(wiz) == WizardDescriptor.FINISH_OPTION) {\r\n        IngestJobSettings ingestJobSettings = wizard.getIngestJobSettings();\r\n        showWarnings(ingestJobSettings);\r\n        if (this.parentFile == null) {\r\n            IngestManager.getInstance().queueIngestJob(this.dataSources, ingestJobSettings);\r\n        } else {\r\n            try {\r\n                Content dataSource = parentFile.getDataSource();\r\n                List<Content> children = parentFile.getChildren();\r\n                List<AbstractFile> files = new ArrayList();\r\n                for (Content child : children) {\r\n                    if (child instanceof AbstractFile) {\r\n                        files.add((AbstractFile) child);\r\n                    }\r\n                }\r\n                if (!files.isEmpty()) {\r\n                    IngestManager.getInstance().queueIngestJob(dataSource, files, ingestJobSettings);\r\n                }\r\n            } catch (TskCoreException ex) {\r\n                logger.log(Level.SEVERE, String.format(\"Failed to get data source or children for parent file %s (objId=%d), action failed\", parentFile.getName(), parentFile.getId()), ex);\r\n                MessageNotifyUtil.Message.error(Bundle.RunIngestModulesAction_actionPerformed_errorMessage());\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.SQLiteTableReader.openTableResources",
	"Comment": "executes the query and assigns resource references to instance variables.",
	"Method": "void openTableResources(String query){\r\n    try {\r\n        ensureOpen();\r\n        statement = conn.prepareStatement(query);\r\n        queryResults = statement.executeQuery();\r\n        currentMetadata = queryResults.getMetaData();\r\n        totalColumnCount = currentMetadata.getColumnCount();\r\n        liveResultSet = true;\r\n    } catch (SQLException ex) {\r\n        throw new SQLiteTableReaderException(ex);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.interestingitems.InterestingItemsFilesSetSettings.readPathCondition",
	"Comment": "construct a path condition for a filesset membership rule from data in anxml element.",
	"Method": "ParentPathCondition readPathCondition(Element ruleElement){\r\n    ParentPathCondition pathCondition = null;\r\n    if (!ruleElement.getAttribute(PATH_FILTER_ATTR).isEmpty() || !ruleElement.getAttribute(PATH_REGEX_ATTR).isEmpty()) {\r\n        String path = ruleElement.getAttribute(PATH_FILTER_ATTR);\r\n        String pathRegex = ruleElement.getAttribute(PATH_REGEX_ATTR);\r\n        if (!pathRegex.isEmpty() && path.isEmpty()) {\r\n            try {\r\n                Pattern pattern = Pattern.compile(pathRegex);\r\n                pathCondition = new ParentPathCondition(pattern);\r\n            } catch (PatternSyntaxException ex) {\r\n                logger.log(Level.SEVERE, \"Error compiling \" + PATH_REGEX_ATTR + \" regex, ignoring malformed path condition definition\", ex);\r\n                throw new FilesSetsManager.FilesSetsManagerException(String.format(\"error compiling %s regex\", PATH_REGEX_ATTR), ex);\r\n            }\r\n        } else if (!path.isEmpty() && pathRegex.isEmpty()) {\r\n            pathCondition = new ParentPathCondition(path);\r\n        }\r\n        if (pathCondition == null) {\r\n            throw new FilesSetsManager.FilesSetsManagerException(String.format(\"Error creating path condition for rule %s\", readRuleName(ruleElement)));\r\n        }\r\n    }\r\n    return pathCondition;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.ImageUtils.getThumbnail",
	"Comment": "get a thumbnail of a specified size for the given image. generates thethumbnail if it is not already cached.",
	"Method": "BufferedImage getThumbnail(Content content,int iconSize){\r\n    if (content instanceof AbstractFile) {\r\n        AbstractFile file = (AbstractFile) content;\r\n        if (ImageUtils.isGIF(file)) {\r\n            try (BufferedInputStream bufferedReadContentStream = getBufferedReadContentStream(file)) {\r\n                if (Thread.interrupted()) {\r\n                    return DEFAULT_THUMBNAIL;\r\n                }\r\n                final BufferedImage image = ImageIO.read(bufferedReadContentStream);\r\n                if (image != null) {\r\n                    if (Thread.interrupted()) {\r\n                        return DEFAULT_THUMBNAIL;\r\n                    }\r\n                    return ScalrWrapper.resizeHighQuality(image, iconSize, iconSize);\r\n                }\r\n            } catch (IOException iOException) {\r\n                LOGGER.log(Level.WARNING, \"Failed to get thumbnail for \" + getContentPathSafe(content), iOException);\r\n            }\r\n            return DEFAULT_THUMBNAIL;\r\n        }\r\n        Task<javafx.scene.image.Image> thumbnailTask = newGetThumbnailTask(file, iconSize, true);\r\n        if (Thread.interrupted()) {\r\n            return DEFAULT_THUMBNAIL;\r\n        }\r\n        thumbnailTask.run();\r\n        try {\r\n            return SwingFXUtils.fromFXImage(thumbnailTask.get(), null);\r\n        } catch (InterruptedException | ExecutionException ex) {\r\n            LOGGER.log(Level.WARNING, \"Failed to get thumbnail for \" + getContentPathSafe(content), ex);\r\n        }\r\n    }\r\n    return DEFAULT_THUMBNAIL;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.embeddedfileextractor.EmbeddedFileExtractorIngestModule.getUniqueName",
	"Comment": "creates a unique name for a file by concatentating the file name and thefile object id.",
	"Method": "String getUniqueName(AbstractFile file){\r\n    return file.getName() + \"_\" + file.getId();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.Chunker.readWindow",
	"Comment": "read the window from the reader, attempting to break at whitespace.",
	"Method": "StringBuilder readWindow(){\r\n    StringBuilder currentWindow = new StringBuilder();\r\n    readHelper(MAX_TOTAL_CHUNK_SIZE - WHITE_SPACE_BUFFER_SIZE, currentWindow);\r\n    readToWhiteSpaceHelper(MAX_TOTAL_CHUNK_SIZE, currentWindow);\r\n    return currentWindow;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.AddImageWizardDataSourceSettingsVisual.discoverDataSourceProcessors",
	"Comment": "populate the map of datasourceprocessors which so they can be retrievedby name.",
	"Method": "void discoverDataSourceProcessors(){\r\n    for (DataSourceProcessor dsProcessor : Lookup.getDefault().lookupAll(DataSourceProcessor.class)) {\r\n        if (!datasourceProcessorsMap.containsKey(dsProcessor.getDataSourceType())) {\r\n            datasourceProcessorsMap.put(dsProcessor.getDataSourceType(), dsProcessor);\r\n        } else {\r\n            logger.log(Level.SEVERE, \"discoverDataSourceProcessors(): A DataSourceProcessor already exists for type = {0}\", dsProcessor.getDataSourceType());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJobNodeData.getCurrentVersion",
	"Comment": "gets the current version of the auto ingest job coordination service nodedata.",
	"Method": "int getCurrentVersion(){\r\n    return AutoIngestJobNodeData.CURRENT_VERSION;\r\n}"
}, {
	"Path": "com.mcxiaoke.next.cache.LruCacheCompat.snapshot",
	"Comment": "returns a copy of the current contents of the cache, ordered from leastrecently accessed to most recently accessed.",
	"Method": "Map<K, V> snapshot(){\r\n    return new LinkedHashMap<K, V>(map);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.ui.countsview.CountsViewPane.showPopoverHelp",
	"Comment": "static utility to to show a popover with the given node as owner.",
	"Method": "void showPopoverHelp(Node owner,String headerText,Image headerImage,Node content){\r\n    Pane borderPane = new BorderPane(null, null, new ImageView(headerImage), content, new Label(headerText));\r\n    borderPane.setPadding(new Insets(10));\r\n    borderPane.setPrefWidth(500);\r\n    PopOver popOver = new PopOver(borderPane);\r\n    popOver.setDetachable(false);\r\n    popOver.setArrowLocation(PopOver.ArrowLocation.TOP_CENTER);\r\n    popOver.show(owner);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestManager.handleRemoteJobStartedEvent",
	"Comment": "processes a job started event from another node by removing the job fromthe pending queue, if it is present, and adding the job in the event tothe collection of jobs running on other hosts.note that the processing stage of the job will be whatever it was whenthe job was serialized for inclusion in the event message.",
	"Method": "void handleRemoteJobStartedEvent(AutoIngestJobStartedEvent event){\r\n    String hostName = event.getJob().getProcessingHostName();\r\n    hostNamesToLastMsgTime.put(hostName, Instant.now());\r\n    synchronized (jobsLock) {\r\n        Path manifestFilePath = event.getJob().getManifest().getFilePath();\r\n        for (Iterator<AutoIngestJob> iterator = pendingJobs.iterator(); iterator.hasNext(); ) {\r\n            AutoIngestJob pendingJob = iterator.next();\r\n            if (pendingJob.getManifest().getFilePath().equals(manifestFilePath)) {\r\n                iterator.remove();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    hostNamesToRunningJobs.put(hostName, event.getJob());\r\n    setChanged();\r\n    notifyObservers(Event.JOB_STARTED);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.SQLiteTableReader.readHelper",
	"Comment": "performs the result set iteration and is responsible for maintainingstate of the read over multiple invocations.",
	"Method": "void readHelper(String query,BooleanSupplier condition){\r\n    try {\r\n        if (!liveResultSet) {\r\n            openTableResources(query);\r\n            columnNameIndex = 0;\r\n        }\r\n        while (columnNameIndex < totalColumnCount) {\r\n            if (condition.getAsBoolean()) {\r\n                return;\r\n            }\r\n            builder.onColumnNameAction.accept(currentMetadata.getColumnName(++columnNameIndex));\r\n        }\r\n        while (unfinishedRow || queryResults.next()) {\r\n            while (currRowColumnIndex < totalColumnCount) {\r\n                if (condition.getAsBoolean()) {\r\n                    unfinishedRow = true;\r\n                    return;\r\n                }\r\n                Object item = queryResults.getObject(++currRowColumnIndex);\r\n                if (item instanceof String) {\r\n                    builder.onStringAction.accept((String) item);\r\n                } else if (item instanceof Integer) {\r\n                    builder.onIntegerAction.accept((Integer) item);\r\n                } else if (item instanceof Double) {\r\n                    builder.onFloatAction.accept((Double) item);\r\n                } else if (item instanceof Long) {\r\n                    builder.onLongAction.accept((Long) item);\r\n                } else if (item instanceof byte[]) {\r\n                    builder.onBlobAction.accept((byte[]) item);\r\n                }\r\n                builder.forAllAction.accept(item);\r\n            }\r\n            unfinishedRow = false;\r\n            currRowColumnIndex = currRowColumnIndex % totalColumnCount;\r\n        }\r\n        closeTableResources();\r\n    } catch (SQLException ex) {\r\n        closeTableResources();\r\n        throw new SQLiteTableReaderException(ex);\r\n    }\r\n}"
}, {
	"Path": "com.facebook.samples.gestures.MultiPointerGestureDetector.newInstance",
	"Comment": "factory method that creates a new instance of multipointergesturedetector",
	"Method": "MultiPointerGestureDetector newInstance(){\r\n    return new MultiPointerGestureDetector();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.directorytree.AddExternalViewerRulePanel.customize",
	"Comment": "allows listeners for when the name or exepath text fields are modified.set action commands for the radio buttons.",
	"Method": "void customize(){\r\n    mimeRadioButton.setActionCommand(\"mime\");\r\n    extRadioButton.setActionCommand(\"ext\");\r\n    nameTextField.getDocument().addDocumentListener(new DocumentListener() {\r\n        @Override\r\n        public void changedUpdate(DocumentEvent e) {\r\n            fire();\r\n        }\r\n        @Override\r\n        public void removeUpdate(DocumentEvent e) {\r\n            fire();\r\n        }\r\n        @Override\r\n        public void insertUpdate(DocumentEvent e) {\r\n            fire();\r\n        }\r\n        private void fire() {\r\n            firePropertyChange(EVENT.CHANGED.toString(), null, null);\r\n        }\r\n    });\r\n    exePathTextField.getDocument().addDocumentListener(new DocumentListener() {\r\n        @Override\r\n        public void changedUpdate(DocumentEvent e) {\r\n            fire();\r\n        }\r\n        @Override\r\n        public void removeUpdate(DocumentEvent e) {\r\n            fire();\r\n        }\r\n        @Override\r\n        public void insertUpdate(DocumentEvent e) {\r\n            fire();\r\n        }\r\n        private void fire() {\r\n            firePropertyChange(EVENT.CHANGED.toString(), null, null);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.directorytree.AddExternalViewerRulePanel.customize",
	"Comment": "allows listeners for when the name or exepath text fields are modified.set action commands for the radio buttons.",
	"Method": "void customize(){\r\n    fire();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.directorytree.AddExternalViewerRulePanel.customize",
	"Comment": "allows listeners for when the name or exepath text fields are modified.set action commands for the radio buttons.",
	"Method": "void customize(){\r\n    fire();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.directorytree.AddExternalViewerRulePanel.customize",
	"Comment": "allows listeners for when the name or exepath text fields are modified.set action commands for the radio buttons.",
	"Method": "void customize(){\r\n    fire();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.directorytree.AddExternalViewerRulePanel.customize",
	"Comment": "allows listeners for when the name or exepath text fields are modified.set action commands for the radio buttons.",
	"Method": "void customize(){\r\n    firePropertyChange(EVENT.CHANGED.toString(), null, null);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.directorytree.AddExternalViewerRulePanel.customize",
	"Comment": "allows listeners for when the name or exepath text fields are modified.set action commands for the radio buttons.",
	"Method": "void customize(){\r\n    fire();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.directorytree.AddExternalViewerRulePanel.customize",
	"Comment": "allows listeners for when the name or exepath text fields are modified.set action commands for the radio buttons.",
	"Method": "void customize(){\r\n    fire();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.directorytree.AddExternalViewerRulePanel.customize",
	"Comment": "allows listeners for when the name or exepath text fields are modified.set action commands for the radio buttons.",
	"Method": "void customize(){\r\n    fire();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.directorytree.AddExternalViewerRulePanel.customize",
	"Comment": "allows listeners for when the name or exepath text fields are modified.set action commands for the radio buttons.",
	"Method": "void customize(){\r\n    firePropertyChange(EVENT.CHANGED.toString(), null, null);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.events.AddingDataSourceEvent.getDataSourceId",
	"Comment": "gets the unique event id used to pair thisaddinddatasourceevent with a corresponding datasourceaddedevent oraddingdatasourcefailedevent.",
	"Method": "UUID getDataSourceId(){\r\n    return dataSourceId;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.CorrelationDataSource.fromTSKDataSource",
	"Comment": "create a correlationdatasource object from a tsk content object. thiswill add it to the central repository.",
	"Method": "CorrelationDataSource fromTSKDataSource(CorrelationCase correlationCase,Content dataSource){\r\n    Case curCase;\r\n    try {\r\n        curCase = Case.getCurrentCaseThrows();\r\n    } catch (NoCurrentCaseException ex) {\r\n        throw new EamDbException(\"Autopsy case is closed\");\r\n    }\r\n    CorrelationDataSource correlationDataSource = null;\r\n    boolean useCR = EamDbUtil.useCentralRepo();\r\n    if (useCR) {\r\n        correlationDataSource = EamDb.getInstance().getDataSource(correlationCase, dataSource.getId());\r\n    }\r\n    if (correlationDataSource == null) {\r\n        String deviceId;\r\n        try {\r\n            deviceId = curCase.getSleuthkitCase().getDataSource(dataSource.getId()).getDeviceId();\r\n        } catch (TskDataException | TskCoreException ex) {\r\n            throw new EamDbException(\"Error getting data source info: \" + ex.getMessage());\r\n        }\r\n        correlationDataSource = new CorrelationDataSource(correlationCase, deviceId, dataSource.getName(), dataSource.getId());\r\n        if (useCR) {\r\n            correlationDataSource = EamDb.getInstance().newDataSource(correlationDataSource);\r\n        }\r\n    }\r\n    return correlationDataSource;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.events.DataSourceAnalysisCompletedEvent.getResult",
	"Comment": "gets the reason why the analysis of the data source completed.",
	"Method": "Reason getResult(){\r\n    return reason;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.ReportHTML.endReport",
	"Comment": "end this report. close the output stream if necessary, and write thenavigation menu with the data types given throughout the report.",
	"Method": "void endReport(){\r\n    writeNav();\r\n    if (out != null) {\r\n        try {\r\n            out.close();\r\n        } catch (IOException ex) {\r\n            logger.log(Level.WARNING, \"Could not close the output writer when ending report.\", ex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestJobSettings.saveModuleSettings",
	"Comment": "serializes the ingest job settings for a given ingest module.",
	"Method": "void saveModuleSettings(IngestModuleFactory factory,IngestModuleIngestJobSettings settings){\r\n    String moduleSettingsFilePath = getModuleSettingsFilePath(factory);\r\n    try (NbObjectOutputStream out = new NbObjectOutputStream(new FileOutputStream(moduleSettingsFilePath))) {\r\n        out.writeObject(settings);\r\n    } catch (IOException ex) {\r\n        String warning = NbBundle.getMessage(IngestJobSettings.class, \"IngestJobSettings.moduleSettingsSave.warning\", factory.getModuleDisplayName(), this.executionContext);\r\n        logger.log(Level.SEVERE, warning, ex);\r\n        this.warnings.add(warning);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.PromptDialogManager.confirmRebuild",
	"Comment": "prompt the user to confirm rebuilding the database for the given list ofreasons.",
	"Method": "boolean confirmRebuild(List<String> rebuildReasons){\r\n    currentDialog = new Alert(Alert.AlertType.CONFIRMATION, Bundle.TimeLinecontroller_updateNowQuestion(), UPDATE, CONTINUE_NO_UPDATE);\r\n    currentDialog.initModality(Modality.APPLICATION_MODAL);\r\n    currentDialog.setTitle(Bundle.Timeline_dialogs_title());\r\n    setDialogIcons(currentDialog);\r\n    currentDialog.setHeaderText(Bundle.PromptDialogManager_rebuildPrompt_headerText());\r\n    ListView<String> listView = new ListView(FXCollections.observableArrayList(rebuildReasons));\r\n    listView.setCellFactory(lstView -> new WrappingListCell());\r\n    listView.setMaxHeight(75);\r\n    Node wrappedListView = Borders.wrap(listView).lineBorder().title(Bundle.PromptDialogManager_rebuildPrompt_details()).buildAll();\r\n    DialogPane dialogPane = currentDialog.getDialogPane();\r\n    dialogPane.setExpandableContent(wrappedListView);\r\n    dialogPane.setMaxWidth(500);\r\n    return currentDialog.showAndWait().map(UPDATE::equals).orElse(false);\r\n}"
}, {
	"Path": "com.google.example.games.catt2.SnapshotCoordinator.isAlreadyClosing",
	"Comment": "returns true if the named file is in the process of closing.this is a synchronizedoperation since it is highly likely that multiple threads are involved via asynctasks.",
	"Method": "boolean isAlreadyClosing(String filename){\r\n    return closing.contains(filename);\r\n}"
}, {
	"Path": "net.ypresto.androidtranscoder.engine.OutputSurface.awaitNewImage",
	"Comment": "latches the next buffer into the texture.must be called from the thread that createdthe outputsurface object, after the onframeavailable callback has signaled that newdata is available.",
	"Method": "void awaitNewImage(){\r\n    final int TIMEOUT_MS = 10000;\r\n    synchronized (mFrameSyncObject) {\r\n        while (!mFrameAvailable) {\r\n            try {\r\n                mFrameSyncObject.wait(TIMEOUT_MS);\r\n                if (!mFrameAvailable) {\r\n                    throw new RuntimeException(\"Surface frame wait timed out\");\r\n                }\r\n            } catch (InterruptedException ie) {\r\n                throw new RuntimeException(ie);\r\n            }\r\n        }\r\n        mFrameAvailable = false;\r\n    }\r\n    mTextureRender.checkGlError(\"before updateTexImage\");\r\n    mSurfaceTexture.updateTexImage();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.SqliteEamDb.acquireExclusiveLock",
	"Comment": "acquire the lock that provides exclusive access to the case database.call this method in a try block with a call to the lock release method inan associated finally block.",
	"Method": "void acquireExclusiveLock(){\r\n    rwLock.writeLock().lock();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.configuration.SharedConfiguration.getHashFileNamesFromSettingsFile",
	"Comment": "read in the hashsets settings to pull out the names of the databases.",
	"Method": "List<String> getHashFileNamesFromSettingsFile(){\r\n    List<String> results = new ArrayList();\r\n    try {\r\n        HashDbManager hashDbManager = HashDbManager.getInstance();\r\n        hashDbManager.loadLastSavedConfiguration();\r\n        for (HashDbManager.HashDb hashDb : hashDbManager.getAllHashSets()) {\r\n            if (hashDb.hasIndexOnly()) {\r\n                results.add(hashDb.getIndexPath());\r\n            } else {\r\n                results.add(hashDb.getDatabasePath());\r\n            }\r\n        }\r\n    } catch (TskCoreException ex) {\r\n        throw new SharedConfigurationException(\"Unable to read hash sets\", ex);\r\n    }\r\n    return results;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.hashdatabase.HashDbSearcher.findFiles",
	"Comment": "given a file, returns a list of all files with the same hash as the givenfile.",
	"Method": "List<AbstractFile> findFiles(FsContent file){\r\n    String md5;\r\n    try {\r\n        if ((md5 = file.getMd5Hash()) != null) {\r\n            return findFilesByMd5(md5);\r\n        } else {\r\n            return Collections.<AbstractFile>emptyList();\r\n        }\r\n    } catch (NoCurrentCaseException ex) {\r\n        logger.log(Level.SEVERE, \"Exception while getting open case.\", ex);\r\n        return Collections.<AbstractFile>emptyList();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.SingleUserCaseConverter.copyResults",
	"Comment": "copy all folders at the base level to the new scheme involving hostname.also take care of a few files such as logs, timeline database, etc.",
	"Method": "void copyResults(ImportCaseData icd){\r\n    String hostName = NetworkUtils.getLocalHostName();\r\n    Path destination;\r\n    Path source = icd.getCaseInputFolder();\r\n    if (source.toFile().exists()) {\r\n        destination = icd.getCaseOutputFolder().resolve(hostName);\r\n        FileUtils.copyDirectory(source.toFile(), destination.toFile());\r\n    }\r\n    source = icd.getCaseInputFolder().resolve(TIMELINE_FILE);\r\n    if (source.toFile().exists()) {\r\n        destination = Paths.get(icd.getCaseOutputFolder().toString(), hostName, MODULE_FOLDER, TIMELINE_FOLDER, TIMELINE_FILE);\r\n        FileUtils.copyFile(source.toFile(), destination.toFile());\r\n    }\r\n    File oldAutopsyFile = Paths.get(icd.getCaseOutputFolder().toString(), hostName, icd.getOldCaseName() + DOTAUT).toFile();\r\n    if (oldAutopsyFile.exists()) {\r\n        oldAutopsyFile.delete();\r\n    }\r\n    File oldDatabaseFile = Paths.get(icd.getCaseOutputFolder().toString(), hostName, AUTOPSY_DB_FILE).toFile();\r\n    if (oldDatabaseFile.exists()) {\r\n        oldDatabaseFile.delete();\r\n    }\r\n    File oldTimelineFile = Paths.get(icd.getCaseOutputFolder().toString(), hostName, TIMELINE_FILE).toFile();\r\n    if (oldTimelineFile.exists()) {\r\n        oldTimelineFile.delete();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.DataResultTopComponent.initInstance",
	"Comment": "initializes a partially initialized result view top component.",
	"Method": "void initInstance(String description,Node node,int childNodeCount,DataResultTopComponent resultViewTopComponent){\r\n    resultViewTopComponent.setNumberOfChildNodes(childNodeCount);\r\n    resultViewTopComponent.open();\r\n    resultViewTopComponent.setNode(node);\r\n    resultViewTopComponent.setPath(description);\r\n    resultViewTopComponent.requestActive();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestMonitor.getCompletedJobs",
	"Comment": "gets the snapshot of the completed jobs list for an auto ingest cluster.",
	"Method": "List<AutoIngestJob> getCompletedJobs(){\r\n    synchronized (jobsLock) {\r\n        return new ArrayList(jobsSnapshot.completedJobs);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.QueryResults.getQuery",
	"Comment": "gets the keyword search query that generated the results stored in thisobject.",
	"Method": "KeywordSearchQuery getQuery(){\r\n    return query;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.CommonAttributeValue.getInstanceCount",
	"Comment": "how many distinct file instances exist for the md5 represented by thisobject?",
	"Method": "int getInstanceCount(){\r\n    return this.fileInstances.size();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.runIngestModuleWizard.IngestProfileSelectionPanel.ingestSettingsButtonActionPerformed",
	"Comment": "opens up a dialog with an ingestoptionspanel so the user can modify anysettings from that options panel.",
	"Method": "void ingestSettingsButtonActionPerformed(java.awt.event.ActionEvent evt){\r\n    final AdvancedConfigurationDialog dialog = new AdvancedConfigurationDialog(true);\r\n    IngestOptionsPanel ingestOptions = new IngestOptionsPanel();\r\n    ingestOptions.load();\r\n    dialog.addApplyButtonListener((ActionEvent e) -> {\r\n        ingestOptions.store();\r\n        clearListOfCheckBoxes();\r\n        fetchProfileList();\r\n        profileListPanel.revalidate();\r\n        profileListPanel.repaint();\r\n        populateProfilesList();\r\n        dialog.close();\r\n    });\r\n    dialog.display(ingestOptions);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestTasksScheduler.getTasksSnapshotForJob",
	"Comment": "returns a snapshot of the states of the tasks in progress for an ingestjob.",
	"Method": "IngestJobTasksSnapshot getTasksSnapshotForJob(long jobId){\r\n    return new IngestJobTasksSnapshot(jobId, this.dataSourceIngestThreadQueue.countQueuedTasksForJob(jobId), countTasksForJob(this.rootFileTaskQueue, jobId), countTasksForJob(this.pendingFileTaskQueue, jobId), this.fileIngestThreadsQueue.countQueuedTasksForJob(jobId), this.dataSourceIngestThreadQueue.countRunningTasksForJob(jobId) + this.fileIngestThreadsQueue.countRunningTasksForJob(jobId));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.othercasessearch.OtherCasesSearchDialog.updateSearchButton",
	"Comment": "enable or disable the search button depending on whether or not text hasbeen provided for the correlation property value.",
	"Method": "void updateSearchButton(){\r\n    searchButton.setEnabled(correlationValueTextField.getText().isEmpty() == false);\r\n}"
}, {
	"Path": "com.aliyun.oss.internal.ResponseParsers.parseListMultipartUploads",
	"Comment": "unmarshall list multipart uploads response body to multipart uploadlisting.",
	"Method": "MultipartUploadListing parseListMultipartUploads(InputStream responseBody){\r\n    try {\r\n        Element root = getXmlRootElement(responseBody);\r\n        MultipartUploadListing multipartUploadListing = new MultipartUploadListing();\r\n        multipartUploadListing.setBucketName(root.getChildText(\"Bucket\"));\r\n        multipartUploadListing.setMaxUploads(Integer.valueOf(root.getChildText(\"MaxUploads\")));\r\n        multipartUploadListing.setTruncated(Boolean.valueOf(root.getChildText(\"IsTruncated\")));\r\n        if (root.getChild(\"Delimiter\") != null) {\r\n            String delimiter = root.getChildText(\"Delimiter\");\r\n            if (!isNullOrEmpty(delimiter)) {\r\n                multipartUploadListing.setDelimiter(delimiter);\r\n            }\r\n        }\r\n        if (root.getChild(\"Prefix\") != null) {\r\n            String prefix = root.getChildText(\"Prefix\");\r\n            if (!isNullOrEmpty(prefix)) {\r\n                multipartUploadListing.setPrefix(prefix);\r\n            }\r\n        }\r\n        if (root.getChild(\"KeyMarker\") != null) {\r\n            String keyMarker = root.getChildText(\"KeyMarker\");\r\n            if (!isNullOrEmpty(keyMarker)) {\r\n                multipartUploadListing.setKeyMarker(keyMarker);\r\n            }\r\n        }\r\n        if (root.getChild(\"UploadIdMarker\") != null) {\r\n            String uploadIdMarker = root.getChildText(\"UploadIdMarker\");\r\n            if (!isNullOrEmpty(uploadIdMarker)) {\r\n                multipartUploadListing.setUploadIdMarker(uploadIdMarker);\r\n            }\r\n        }\r\n        if (root.getChild(\"NextKeyMarker\") != null) {\r\n            String nextKeyMarker = root.getChildText(\"NextKeyMarker\");\r\n            if (!isNullOrEmpty(nextKeyMarker)) {\r\n                multipartUploadListing.setNextKeyMarker(nextKeyMarker);\r\n            }\r\n        }\r\n        if (root.getChild(\"NextUploadIdMarker\") != null) {\r\n            String nextUploadIdMarker = root.getChildText(\"NextUploadIdMarker\");\r\n            if (!isNullOrEmpty(nextUploadIdMarker)) {\r\n                multipartUploadListing.setNextUploadIdMarker(nextUploadIdMarker);\r\n            }\r\n        }\r\n        List<Element> uploadElems = root.getChildren(\"Upload\");\r\n        for (Element elem : uploadElems) {\r\n            if (elem.getChild(\"Initiated\") == null) {\r\n                continue;\r\n            }\r\n            MultipartUpload mu = new MultipartUpload();\r\n            mu.setKey(elem.getChildText(\"Key\"));\r\n            mu.setUploadId(elem.getChildText(\"UploadId\"));\r\n            mu.setStorageClass(elem.getChildText(\"StorageClass\"));\r\n            mu.setInitiated(DateUtil.parseIso8601Date(elem.getChildText(\"Initiated\")));\r\n            multipartUploadListing.addMultipartUpload(mu);\r\n        }\r\n        List<Element> commonPrefixesElems = root.getChildren(\"CommonPrefixes\");\r\n        for (Element elem : commonPrefixesElems) {\r\n            String prefix = elem.getChildText(\"Prefix\");\r\n            if (!isNullOrEmpty(prefix)) {\r\n                multipartUploadListing.addCommonPrefix(prefix);\r\n            }\r\n        }\r\n        return multipartUploadListing;\r\n    } catch (JDOMParseException e) {\r\n        throw new ResponseParseException(e.getPartialDocument() + \": \" + e.getMessage(), e);\r\n    } catch (Exception e) {\r\n        throw new ResponseParseException(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.eventlisteners.IngestEventsListener.incrementCorrelationEngineModuleCount",
	"Comment": "increase the number of ingesteventslisteners adding contents to thecorrelation engine.",
	"Method": "void incrementCorrelationEngineModuleCount(){\r\n    correlationModuleInstanceCount++;\r\n}"
}, {
	"Path": "org.codechimp.apprater.AppRater.setCancelable",
	"Comment": "sets whether the rating dialog is cancelable or not, default is true.",
	"Method": "void setCancelable(boolean cancelable){\r\n    isCancelable = cancelable;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.actions.ViewArtifactInTimelineAction.hasSupportedTimeStamp",
	"Comment": "does the given artifact have a type that timeline supports, and does ithave a positive timestamp in the supported attribute?",
	"Method": "boolean hasSupportedTimeStamp(BlackboardArtifact artifact){\r\n    for (ArtifactEventType artEventType : ARTIFACT_EVENT_TYPES) {\r\n        if (artEventType.getArtifactTypeID() == artifact.getArtifactTypeID()) {\r\n            BlackboardAttribute attribute = artifact.getAttribute(artEventType.getDateTimeAttributeType());\r\n            if (null != attribute && attribute.getValueLong() > 0) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.db.EventsRepository.getEventIDsForFile",
	"Comment": "get a list of event ids for the events that are derived from the givenfile.",
	"Method": "List<Long> getEventIDsForFile(AbstractFile file,boolean includeDerivedArtifacts){\r\n    return eventDB.getEventIDsForFile(file, includeDerivedArtifacts);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.directorytree.DirectoryTreeTopComponent.respondSelection",
	"Comment": "event handler to run when selection changedtodo this needs to be revised",
	"Method": "void respondSelection(Node[] oldNodes,Node[] newNodes){\r\n    if (!Case.isCaseOpen()) {\r\n        return;\r\n    }\r\n    EventQueue.invokeLater(() -> {\r\n        DirectoryTreeTopComponent.this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\r\n        try {\r\n            Node treeNode = DirectoryTreeTopComponent.this.getSelectedNode();\r\n            if (treeNode != null) {\r\n                Node originNode = ((DirectoryTreeFilterNode) treeNode).getOriginal();\r\n                Node drfn = new DataResultFilterNode(originNode, DirectoryTreeTopComponent.this.em);\r\n                if (FileTypesByMimeType.isEmptyMimeTypeNode(originNode)) {\r\n                    EmptyNode emptyNode = new EmptyNode(Bundle.DirectoryTreeTopComponent_emptyMimeNode_text());\r\n                    dataResult.setNode(new TableFilterNode(emptyNode, true, \"This Node Is Empty\"));\r\n                } else if (originNode instanceof DisplayableItemNode) {\r\n                    dataResult.setNode(new TableFilterNode(drfn, true, ((DisplayableItemNode) originNode).getItemType()));\r\n                } else {\r\n                    dataResult.setNode(new TableFilterNode(drfn, true));\r\n                }\r\n                String displayName = \"\";\r\n                Content content = originNode.getLookup().lookup(Content.class);\r\n                if (content != null) {\r\n                    try {\r\n                        displayName = content.getUniquePath();\r\n                    } catch (TskCoreException ex) {\r\n                        LOGGER.log(Level.SEVERE, \"Exception while calling Content.getUniquePath() for node: {0}\", originNode);\r\n                    }\r\n                } else if (originNode.getLookup().lookup(String.class) != null) {\r\n                    displayName = originNode.getLookup().lookup(String.class);\r\n                }\r\n                dataResult.setPath(displayName);\r\n            }\r\n            if (oldNodes != null && newNodes != null && (oldNodes.length == newNodes.length)) {\r\n                boolean sameNodes = true;\r\n                for (int i = 0; i < oldNodes.length; i++) {\r\n                    sameNodes = sameNodes && oldNodes[i].getName().equals(newNodes[i].getName());\r\n                }\r\n                if (!sameNodes) {\r\n                    dataResult.requestActive();\r\n                }\r\n            }\r\n        } finally {\r\n            setCursor(null);\r\n        }\r\n    });\r\n    updateHistory(em.getSelectedNodes());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.ArchiveExtractorDSProcessor.getPanel",
	"Comment": "gets the panel that allows a user to select a data source and do anyconfiguration required by the data source. the panel is less than 544pixels wide and less than 173 pixels high.",
	"Method": "JPanel getPanel(){\r\n    configPanel.readSettings();\r\n    configPanel.select();\r\n    return configPanel;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilessearch.InterCaseTestUtils.areAllResultsOfType",
	"Comment": "is everything in metadata a result of the given attribute type?",
	"Method": "boolean areAllResultsOfType(CommonAttributeSearchResults metadata,CorrelationAttributeInstance.Type attributeType){\r\n    try {\r\n        for (CommonAttributeValueList matches : metadata.getMetadata().values()) {\r\n            for (CommonAttributeValue value : matches.getMetadataList()) {\r\n                return value.getInstances().stream().allMatch(inst -> inst.getCorrelationAttributeInstanceType().equals(attributeType));\r\n            }\r\n            return false;\r\n        }\r\n        return false;\r\n    } catch (EamDbException ex) {\r\n        Assert.fail(ex.getMessage());\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.recentactivity.ExtractIE.getHistory",
	"Comment": "locates index.dat files, runs pasco on them, and creates artifacts.",
	"Method": "void getHistory(){\r\n    logger.log(Level.INFO, \"Pasco results path: {0}\", moduleTempResultsDir);\r\n    boolean foundHistory = false;\r\n    final File pascoRoot = InstalledFileLocator.getDefault().locate(\"pasco2\", ExtractIE.class.getPackage().getName(), false);\r\n    if (pascoRoot == null) {\r\n        this.addErrorMessage(NbBundle.getMessage(this.getClass(), \"ExtractIE.getHistory.errMsg.unableToGetHist\", this.getName()));\r\n        logger.log(Level.SEVERE, \"Error finding pasco program \");\r\n        return;\r\n    }\r\n    final String pascoHome = pascoRoot.getAbsolutePath();\r\n    logger.log(Level.INFO, \"Pasco2 home: {0}\", pascoHome);\r\n    PASCO_LIB_PATH = pascoHome + File.separator + \"pasco2.jar\" + File.pathSeparator + pascoHome + File.separator + \"*\";\r\n    File resultsDir = new File(moduleTempResultsDir);\r\n    resultsDir.mkdirs();\r\n    org.sleuthkit.autopsy.casemodule.services.FileManager fileManager = currentCase.getServices().getFileManager();\r\n    List<AbstractFile> indexFiles;\r\n    try {\r\n        indexFiles = fileManager.findFiles(dataSource, \"index.dat\");\r\n    } catch (TskCoreException ex) {\r\n        this.addErrorMessage(NbBundle.getMessage(this.getClass(), \"ExtractIE.getHistory.errMsg.errGettingHistFiles\", this.getName()));\r\n        logger.log(Level.WARNING, \"Error fetching 'index.data' files for Internet Explorer history.\");\r\n        return;\r\n    }\r\n    if (indexFiles.isEmpty()) {\r\n        String msg = NbBundle.getMessage(this.getClass(), \"ExtractIE.getHistory.errMsg.noHistFiles\");\r\n        logger.log(Level.INFO, msg);\r\n        return;\r\n    }\r\n    dataFound = true;\r\n    Collection<BlackboardArtifact> bbartifacts = new ArrayList();\r\n    String temps;\r\n    String indexFileName;\r\n    for (AbstractFile indexFile : indexFiles) {\r\n        indexFileName = \"index\" + Integer.toString((int) indexFile.getId()) + \".dat\";\r\n        temps = RAImageIngestModule.getRATempPath(currentCase, \"IE\") + File.separator + indexFileName;\r\n        File datFile = new File(temps);\r\n        if (context.dataSourceIngestIsCancelled()) {\r\n            break;\r\n        }\r\n        try {\r\n            ContentUtils.writeToFile(indexFile, datFile, context::dataSourceIngestIsCancelled);\r\n        } catch (IOException e) {\r\n            logger.log(Level.WARNING, \"Error while trying to write index.dat file \" + datFile.getAbsolutePath(), e);\r\n            this.addErrorMessage(NbBundle.getMessage(this.getClass(), \"ExtractIE.getHistory.errMsg.errWriteFile\", this.getName(), datFile.getAbsolutePath()));\r\n            continue;\r\n        }\r\n        String filename = \"pasco2Result.\" + indexFile.getId() + \".txt\";\r\n        boolean bPascProcSuccess = executePasco(temps, filename);\r\n        if (context.dataSourceIngestIsCancelled()) {\r\n            return;\r\n        }\r\n        if (bPascProcSuccess) {\r\n            bbartifacts.addAll(parsePascoOutput(indexFile, filename).stream().filter(bbart -> bbart.getArtifactTypeID() == ARTIFACT_TYPE.TSK_WEB_HISTORY.getTypeID()).collect(Collectors.toList()));\r\n            foundHistory = true;\r\n            datFile.delete();\r\n        } else {\r\n            logger.log(Level.WARNING, \"pasco execution failed on: {0}\", this.getName());\r\n            this.addErrorMessage(NbBundle.getMessage(this.getClass(), \"ExtractIE.getHistory.errMsg.errProcHist\", this.getName()));\r\n        }\r\n    }\r\n    if (foundHistory) {\r\n        services.fireModuleDataEvent(new ModuleDataEvent(NbBundle.getMessage(this.getClass(), \"ExtractIE.parentModuleName\"), BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_HISTORY, bbartifacts));\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.case_uco.ReportCaseUcoConfigPanel.setDatasourceComboboxModel",
	"Comment": "set the datamodel for the combo box which displays the data sources inthe current case",
	"Method": "void setDatasourceComboboxModel(DataSourceComboBoxModel dataSourceComboBoxModel){\r\n    this.dataSourcesList = dataSourceComboBoxModel;\r\n    this.selectDataSourceComboBox.setModel(dataSourcesList);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.ui.AbstractTimeLineView.handleRefreshRequested",
	"Comment": "handle a refreshrequestedevent from the events model by updating theview.",
	"Method": "void handleRefreshRequested(RefreshRequestedEvent event){\r\n    refresh();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.core.Installer.ensurePythonModulesFolderExists",
	"Comment": "make a folder in the config directory for python modules if one does notexist.",
	"Method": "void ensurePythonModulesFolderExists(){\r\n    File pythonModulesDir = new File(PlatformUtil.getUserPythonModulesPath());\r\n    pythonModulesDir.mkdir();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.ui.detailview.tree.EventsTreeItem.getComparator",
	"Comment": "get the comparator currently used to sort this tree items children.",
	"Method": "Comparator<TreeItem<TimeLineEvent>> getComparator(){\r\n    return comparator;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.datamodel.BlackboardArtifactNode.getAllTagsFromDatabase",
	"Comment": "get all tags from the case database relating to the artifact and the fileit is associated with.",
	"Method": "List<Tag> getAllTagsFromDatabase(){\r\n    List<Tag> tags = new ArrayList();\r\n    try {\r\n        tags.addAll(Case.getCurrentCaseThrows().getServices().getTagsManager().getBlackboardArtifactTagsByArtifact(artifact));\r\n        tags.addAll(Case.getCurrentCaseThrows().getServices().getTagsManager().getContentTagsByContent(associated));\r\n    } catch (TskCoreException | NoCurrentCaseException ex) {\r\n        logger.log(Level.SEVERE, \"Failed to get tags for artifact \" + artifact.getDisplayName(), ex);\r\n    }\r\n    return tags;\r\n}"
}, {
	"Path": "org.wikipedia.nearby.NearbyUnitTest.calcDistances",
	"Comment": "calculates the distances from the origin to the given pages.this method should be called before sorting.",
	"Method": "void calcDistances(List<NearbyPage> pages){\r\n    for (NearbyPage page : pages) {\r\n        page.setDistance(getDistance(page.getLocation()));\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.core.UserPreferences.setIsTimeOutEnabled",
	"Comment": "stores persisted setting of whether process time out functionality isenabled.",
	"Method": "void setIsTimeOutEnabled(boolean enabled){\r\n    preferences.putBoolean(PROCESS_TIME_OUT_ENABLED, enabled);\r\n}"
}, {
	"Path": "org.owntracks.android.ui.preferences.PreferencesFragment.getEditIntegerPreferenceTextValueWithHintSupport",
	"Comment": "returns an empty string if no key value is found so that a hint can be displayed",
	"Method": "String getEditIntegerPreferenceTextValueWithHintSupport(String key){\r\n    int i = viewModel.getPreferences().getInt(key, R.integer.valInvalid);\r\n    if (i == -1) {\r\n        return \"\";\r\n    } else {\r\n        return Integer.toString(i);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.directorytree.ExternalViewerRulesManager.getInstance",
	"Comment": "gets the singleton manager of the external viewer rules defined by users.",
	"Method": "ExternalViewerRulesManager getInstance(){\r\n    if (instance == null) {\r\n        instance = new ExternalViewerRulesManager();\r\n        instance.loadUserDefinedRules();\r\n    }\r\n    return instance;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.filetypeid.CustomFileTypesManager.parseFileType",
	"Comment": "gets a custom file type definition from a file type xml element.",
	"Method": "FileType parseFileType(Element fileTypeElem){\r\n    String mimeType = parseMimeType(fileTypeElem);\r\n    Signature signature = parseSignature(fileTypeElem);\r\n    List<Signature> sigList = new ArrayList();\r\n    sigList.add(signature);\r\n    return new FileType(mimeType, sigList);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.embeddedfileextractor.SevenZipExtractor.getKeyAbstractFile",
	"Comment": "get the string that will represent the key for the hashmap which keepstrack of existing files from an abstractfile",
	"Method": "String getKeyAbstractFile(AbstractFile fileInDatabase){\r\n    return fileInDatabase == null ? null : fileInDatabase.getParentPath() + fileInDatabase.getName();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.ui.countsview.CountsViewPane.syncAxisScaleLabel",
	"Comment": "set the appropriate label on the vertical axis, depending on the selectedscale.",
	"Method": "void syncAxisScaleLabel(){\r\n    countAxis.setLabel(Bundle.CountsViewPane_numberOfEvents(scaleProp.get().getDisplayName()));\r\n}"
}, {
	"Path": "com.mcxiaoke.next.collection.WeakFastHashMap.values",
	"Comment": "return a collection view of the values contained in this map.",
	"Method": "Collection<V> values(){\r\n    return new Values();\r\n}"
}, {
	"Path": "com.mcxiaoke.next.ui.internal.AdapterWrapper.getCount",
	"Comment": "how many items are in the data set represented by thisadapter.",
	"Method": "int getCount(){\r\n    return (wrapped.getCount());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.LogicalFilesDspPanel.subTypeIsLogicalEvidencePanel",
	"Comment": "identify if the selected subtype panel is a logicalevidencepanel",
	"Method": "boolean subTypeIsLogicalEvidencePanel(){\r\n    final String selectedSubType = dspSubtypeComboBox.getSelectedItem().toString();\r\n    return selectedSubType.equals(Bundle.LogicalFilesDspPanel_subTypeComboBox_l01FileOption_text());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.InterCaseSearchResultsProcessor.findSingleInterCaseCommonAttributeValues",
	"Comment": "given the current case, and a specific case of interest, finds commonfiles which exist between cases from the eamdb. builds maps of obj id tomd5 and case.",
	"Method": "Map<Integer, CommonAttributeValueList> findSingleInterCaseCommonAttributeValues(Case currentCase,CorrelationCase singleCase){\r\n    try {\r\n        InterCaseCommonAttributesCallback instancetableCallback = new InterCaseCommonAttributesCallback();\r\n        EamDb DbManager = EamDb.getInstance();\r\n        int caseId = DbManager.getCase(currentCase).getID();\r\n        int targetCaseId = singleCase.getID();\r\n        DbManager.processInstanceTableWhere(correlationType, String.format(singleInterCaseWhereClause, caseId, TskData.FileKnown.KNOWN.getFileKnownValue(), caseId, targetCaseId), instancetableCallback);\r\n        return instancetableCallback.getInstanceCollatedCommonFiles();\r\n    } catch (EamDbException ex) {\r\n        LOGGER.log(Level.SEVERE, \"Error accessing EamDb processing CaseInstancesTable.\", ex);\r\n    }\r\n    return new HashMap();\r\n}"
}, {
	"Path": "com.aliyun.oss.model.CompleteMultipartUploadResult.setBucketName",
	"Comment": "sets the bucket name of the target file of this multipart upload.",
	"Method": "void setBucketName(String bucketName){\r\n    this.bucketName = bucketName;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.actions.GetTagNameDialog.doDialog",
	"Comment": "show the tag name dialog and return the tagname selected by the user.",
	"Method": "TagName doDialog(TagName doDialog,Window owner){\r\n    GetTagNameDialog dialog = new GetTagNameDialog(owner);\r\n    dialog.display();\r\n    return dialog.tagName;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestControlPanel.enableRunningTableButtons",
	"Comment": "enables or disables buttons related to the running jobs table.",
	"Method": "void enableRunningTableButtons(Boolean enable){\r\n    bnCancelJob.setEnabled(enable);\r\n    bnCancelModule.setEnabled(enable);\r\n    bnShowProgress.setEnabled(enable);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestManager.getNumberOfFileIngestThreads",
	"Comment": "gets the number of file ingest threads the ingest manager is using to doingest jobs.",
	"Method": "int getNumberOfFileIngestThreads(){\r\n    return numberOfFileIngestThreads;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.runIngestModuleWizard.IngestProfileSelectionWizardPanel.getIngestJobSettings",
	"Comment": "gets the ingest job settings associated with this wizard panel.",
	"Method": "IngestJobSettings getIngestJobSettings(){\r\n    return new IngestJobSettings(lastProfileUsed);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.interestingitems.InterestingItemsFilesSetSettings.readDefinitionsFile",
	"Comment": "reads filesset definitions from serialized file or xml file.",
	"Method": "Map<String, FilesSet> readDefinitionsFile(String fileName,String legacyFileName){\r\n    Map<String, FilesSet> filesSets = readSerializedDefinitions(fileName);\r\n    if (!filesSets.isEmpty()) {\r\n        return filesSets;\r\n    }\r\n    if (!legacyFileName.isEmpty()) {\r\n        return readDefinitionsXML(Paths.get(PlatformUtil.getUserConfigDirectory(), legacyFileName).toFile());\r\n    }\r\n    return filesSets;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.interestingitems.InterestingItemsFilesSetSettings.readNameCondition",
	"Comment": "construct a file name condition for a filesset membership rule from datain an xml element.",
	"Method": "FileNameCondition readNameCondition(Element elem){\r\n    FileNameCondition nameCondition = null;\r\n    String content = elem.getTextContent();\r\n    String regex = elem.getAttribute(REGEX_ATTR);\r\n    if (content != null && !content.isEmpty()) {\r\n        if ((!regex.isEmpty() && regex.equalsIgnoreCase(\"true\")) || content.contains(\"*\")) {\r\n            Pattern pattern = compileRegex(content);\r\n            if (pattern != null) {\r\n                if (elem.getTagName().equals(NAME_RULE_TAG)) {\r\n                    nameCondition = new FilesSet.Rule.FullNameCondition(pattern);\r\n                } else if (elem.getTagName().equals(EXTENSION_RULE_TAG)) {\r\n                    nameCondition = new FilesSet.Rule.ExtensionCondition(pattern);\r\n                } else {\r\n                    throw new FilesSetsManager.FilesSetsManagerException(String.format(\"Name condition has invalid tag name of %s for rule %s\", elem.getTagName(), readRuleName(elem)));\r\n                }\r\n            } else {\r\n                logger.log(Level.SEVERE, \"Error compiling \" + elem.getTagName() + \" regex, ignoring malformed '{0}' rule definition\", readRuleName(elem));\r\n                throw new FilesSetsManager.FilesSetsManagerException(String.format(\"error compiling %s regex in rule %s\", REGEX_ATTR, readRuleName(elem)));\r\n            }\r\n        } else {\r\n            for (String illegalChar : illegalFileNameChars) {\r\n                if (content.contains(illegalChar)) {\r\n                    logger.log(Level.SEVERE, elem.getTagName() + \" content has illegal chars, ignoring malformed '{0}' rule definition\", new Object[] { elem.getTagName(), readRuleName(elem) });\r\n                    throw new FilesSetsManager.FilesSetsManagerException(String.format(\"File name has illegal character of %s in rule %s\", illegalChar, readRuleName(elem)));\r\n                }\r\n            }\r\n            if (elem.getTagName().equals(NAME_RULE_TAG)) {\r\n                nameCondition = new FilesSet.Rule.FullNameCondition(content);\r\n            } else if (elem.getTagName().equals(EXTENSION_RULE_TAG)) {\r\n                nameCondition = new FilesSet.Rule.ExtensionCondition(Arrays.asList(content.split(\",\")));\r\n            }\r\n        }\r\n    }\r\n    return nameCondition;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.CaseImportPanel.enableStartButton",
	"Comment": "enables the start button if all input is in order, disables it otherwise",
	"Method": "void enableStartButton(){\r\n    if (UserPreferences.getIsMultiUserModeEnabled() && (!RuntimeProperties.runningWithGUI()) && !tbCaseSource.getText().isEmpty() && !tbCaseDestination.getText().isEmpty() && canTalkToDb == true && (!cbCopyImages.isSelected() || (!tbImageSource.getText().isEmpty() && !tbImageDestination.getText().isEmpty()))) {\r\n        bnStart.setEnabled(true);\r\n    } else {\r\n        bnStart.setEnabled(false);\r\n    }\r\n}"
}, {
	"Path": "org.wikipedia.page.linkpreview.LinkPreviewContents.getSentences",
	"Comment": "split a block of text into sentences, taking into account the language in whichthe text is assumed to be.",
	"Method": "List<String> getSentences(String text,WikiSite wiki){\r\n    List<String> sentenceList = new ArrayList();\r\n    BreakIterator iterator = BreakIterator.getSentenceInstance(new Locale(wiki.languageCode()));\r\n    text = text.replaceAll(\"(\\r|\\n)\", \" \");\r\n    iterator.setText(text);\r\n    for (int start = iterator.first(), end = iterator.next(); end != BreakIterator.DONE; start = end, end = iterator.next()) {\r\n        String sentence = text.substring(start, end).trim();\r\n        if (TextUtils.isGraphic(sentence)) {\r\n            String formattedSentence = sentenceList.isEmpty() ? removeParens(sentence) : sentence;\r\n            sentenceList.add(formattedSentence);\r\n        }\r\n    }\r\n    if (sentenceList.isEmpty()) {\r\n        sentenceList.add(text);\r\n    }\r\n    return sentenceList;\r\n}"
}, {
	"Path": "org.owntracks.android.ui.base.BaseSupportFragment.setAndBindContentView",
	"Comment": "use this method to inflate the content view for your fragment.",
	"Method": "View setAndBindContentView(LayoutInflater inflater,ViewGroup container,int layoutResId,Bundle savedInstanceState){\r\n    if (viewModel == null) {\r\n        throw new IllegalStateException(\"viewModel must not be null and should be injected\");\r\n    }\r\n    binding = DataBindingUtil.inflate(inflater, layoutResId, container, false);\r\n    binding.setVariable(BR.vm, viewModel);\r\n    viewModel.attachView((MvvmView) this, savedInstanceState);\r\n    return binding.getRoot();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestControlPanel.bnShowProgressActionPerformed",
	"Comment": "handles a click on the show auto ingest job progress button. displays aningest job progress panel.",
	"Method": "void bnShowProgressActionPerformed(java.awt.event.ActionEvent evt){\r\n    IngestProgressSnapshotDialog dialog = new IngestProgressSnapshotDialog(this.getTopLevelAncestor(), true);\r\n}"
}, {
	"Path": "com.google.example.games.bc.MainActivity.signInSilently",
	"Comment": "try to sign in without displaying dialogs to the user.if the user has already signed in previously, it will not show dialog.",
	"Method": "void signInSilently(){\r\n    Log.d(TAG, \"signInSilently()\");\r\n    mGoogleSignInClient.silentSignIn().addOnCompleteListener(this, new OnCompleteListener<GoogleSignInAccount>() {\r\n        @Override\r\n        public void onComplete(@NonNull Task<GoogleSignInAccount> task) {\r\n            if (task.isSuccessful()) {\r\n                Log.d(TAG, \"signInSilently(): success\");\r\n                onConnected(task.getResult());\r\n            } else {\r\n                Log.d(TAG, \"signInSilently(): failure\", task.getException());\r\n                onDisconnected();\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.google.example.games.bc.MainActivity.signInSilently",
	"Comment": "try to sign in without displaying dialogs to the user.if the user has already signed in previously, it will not show dialog.",
	"Method": "void signInSilently(){\r\n    if (task.isSuccessful()) {\r\n        Log.d(TAG, \"signInSilently(): success\");\r\n        onConnected(task.getResult());\r\n    } else {\r\n        Log.d(TAG, \"signInSilently(): failure\", task.getException());\r\n        onDisconnected();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.TableReportGenerator.writeHashsetHits",
	"Comment": "write the hash set hits to the provided tablereportmodules.",
	"Method": "void writeHashsetHits(TableReportModule tableModule,String comment,HashSet<String> tagNamesFilter){\r\n    String orderByClause;\r\n    Case openCase;\r\n    try {\r\n        openCase = Case.getCurrentCaseThrows();\r\n    } catch (NoCurrentCaseException ex) {\r\n        errorList.add(Bundle.ReportGenerator_errList_noOpenCase());\r\n        logger.log(Level.SEVERE, \"Exception while getting open case: \", ex);\r\n        return;\r\n    }\r\n    if (openCase.getCaseType() == Case.CaseType.MULTI_USER_CASE) {\r\n        orderByClause = \"ORDER BY convert_to(att.value_text, 'SQL_ASCII') ASC NULLS FIRST\";\r\n    } else {\r\n        orderByClause = \"ORDER BY att.value_text ASC\";\r\n    }\r\n    String hashsetsQuery = \"SELECT att.value_text AS list \" + \"FROM blackboard_attributes AS att, blackboard_artifacts AS art \" + \"WHERE att.attribute_type_id = \" + BlackboardAttribute.ATTRIBUTE_TYPE.TSK_SET_NAME.getTypeID() + \" \" + \"AND art.artifact_type_id = \" + BlackboardArtifact.ARTIFACT_TYPE.TSK_HASHSET_HIT.getTypeID() + \" \" + \"AND att.artifact_id = art.artifact_id \" + \"GROUP BY list \" + orderByClause;\r\n    try (SleuthkitCase.CaseDbQuery dbQuery = openCase.getSleuthkitCase().executeQuery(hashsetsQuery)) {\r\n        ResultSet listsRs = dbQuery.getResultSet();\r\n        List<String> lists = new ArrayList();\r\n        while (listsRs.next()) {\r\n            lists.add(listsRs.getString(\"list\"));\r\n        }\r\n        tableModule.startDataType(BlackboardArtifact.ARTIFACT_TYPE.TSK_HASHSET_HIT.getDisplayName(), comment);\r\n        tableModule.addSetIndex(lists);\r\n        progressPanel.updateStatusLabel(NbBundle.getMessage(this.getClass(), \"ReportGenerator.progress.processing\", BlackboardArtifact.ARTIFACT_TYPE.TSK_HASHSET_HIT.getDisplayName()));\r\n    } catch (TskCoreException | SQLException ex) {\r\n        errorList.add(NbBundle.getMessage(this.getClass(), \"ReportGenerator.errList.failedQueryHashsetLists\"));\r\n        logger.log(Level.SEVERE, \"Failed to query hashset lists: \", ex);\r\n        return;\r\n    }\r\n    if (openCase.getCaseType() == Case.CaseType.MULTI_USER_CASE) {\r\n        orderByClause = \"ORDER BY convert_to(att.value_text, 'SQL_ASCII') ASC NULLS FIRST, \" + \"convert_to(f.parent_path, 'SQL_ASCII') ASC NULLS FIRST, \" + \"convert_to(f.name, 'SQL_ASCII') ASC NULLS FIRST, \" + \"size ASC NULLS FIRST\";\r\n    } else {\r\n        orderByClause = \"ORDER BY att.value_text ASC, f.parent_path ASC, f.name ASC, size ASC\";\r\n    }\r\n    String hashsetHitsQuery = \"SELECT art.artifact_id, art.obj_id, att.value_text AS setname, f.name AS name, f.size AS size, f.parent_path AS parent_path \" + \"FROM blackboard_artifacts AS art, blackboard_attributes AS att, tsk_files AS f \" + \"WHERE (att.artifact_id = art.artifact_id) \" + \"AND (f.obj_id = art.obj_id) \" + \"AND (att.attribute_type_id = \" + BlackboardAttribute.ATTRIBUTE_TYPE.TSK_SET_NAME.getTypeID() + \") \" + \"AND (art.artifact_type_id = \" + BlackboardArtifact.ARTIFACT_TYPE.TSK_HASHSET_HIT.getTypeID() + \") \" + orderByClause;\r\n    try (SleuthkitCase.CaseDbQuery dbQuery = openCase.getSleuthkitCase().executeQuery(hashsetHitsQuery)) {\r\n        ResultSet resultSet = dbQuery.getResultSet();\r\n        String currentSet = \"\";\r\n        while (resultSet.next()) {\r\n            if (progressPanel.getStatus() == ReportProgressPanel.ReportStatus.CANCELED) {\r\n                break;\r\n            }\r\n            HashSet<String> uniqueTagNames = getUniqueTagNames(resultSet.getLong(\"artifact_id\"));\r\n            if (failsTagFilter(uniqueTagNames, tagNamesFilter)) {\r\n                continue;\r\n            }\r\n            String tagsList = makeCommaSeparatedList(uniqueTagNames);\r\n            Long objId = resultSet.getLong(\"obj_id\");\r\n            String set = resultSet.getString(\"setname\");\r\n            String size = resultSet.getString(\"size\");\r\n            String uniquePath = \"\";\r\n            try {\r\n                AbstractFile f = openCase.getSleuthkitCase().getAbstractFileById(objId);\r\n                if (f != null) {\r\n                    uniquePath = openCase.getSleuthkitCase().getAbstractFileById(objId).getUniquePath();\r\n                }\r\n            } catch (TskCoreException ex) {\r\n                errorList.add(NbBundle.getMessage(this.getClass(), \"ReportGenerator.errList.failedGetAbstractFileFromID\"));\r\n                logger.log(Level.WARNING, \"Failed to get Abstract File from ID.\", ex);\r\n                return;\r\n            }\r\n            if (!set.equals(currentSet)) {\r\n                if (!currentSet.isEmpty()) {\r\n                    tableModule.endTable();\r\n                    tableModule.endSet();\r\n                }\r\n                currentSet = set;\r\n                tableModule.startSet(currentSet);\r\n                List<String> columnHeaderNames = new ArrayList();\r\n                columnHeaderNames.add(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.file\"));\r\n                columnHeaderNames.add(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.size\"));\r\n                columnHeaderNames.add(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.tags\"));\r\n                tableModule.startTable(columnHeaderNames);\r\n                progressPanel.updateStatusLabel(NbBundle.getMessage(this.getClass(), \"ReportGenerator.progress.processingList\", BlackboardArtifact.ARTIFACT_TYPE.TSK_HASHSET_HIT.getDisplayName(), currentSet));\r\n            }\r\n            tableModule.addRow(Arrays.asList(new String[] { uniquePath, size, tagsList }));\r\n        }\r\n        progressPanel.increment();\r\n        tableModule.endDataType();\r\n    } catch (TskCoreException | SQLException ex) {\r\n        errorList.add(NbBundle.getMessage(this.getClass(), \"ReportGenerator.errList.failedQueryHashsetHits\"));\r\n        logger.log(Level.SEVERE, \"Failed to query hashsets hits: \", ex);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.SqliteEamDbSettings.verifyDatabaseSchema",
	"Comment": "use the current settings and the schema version query to test thedatabase schema.",
	"Method": "boolean verifyDatabaseSchema(){\r\n    Connection conn = getEphemeralConnection();\r\n    if (null == conn) {\r\n        return false;\r\n    }\r\n    boolean result = EamDbUtil.schemaVersionIsSet(conn);\r\n    EamDbUtil.closeConnection(conn);\r\n    return result;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.interestingitems.FilesSetsManager.getCustomFileIngestFilters",
	"Comment": "gets a copy of the current ingest file set definitions.the defaults are not included so that they will not show up in theeditor.",
	"Method": "Map<String, FilesSet> getCustomFileIngestFilters(){\r\n    synchronized (FILE_INGEST_FILTER_LOCK) {\r\n        return FileSetsDefinitions.readSerializedDefinitions(FILE_INGEST_FILTER_DEFS_NAME);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.communications.RelationshipNode.getAttributeDisplayString",
	"Comment": "get the display string for the attribute of the given type from the givenartifact.",
	"Method": "String getAttributeDisplayString(BlackboardArtifact artifact,ATTRIBUTE_TYPE attributeType){\r\n    try {\r\n        BlackboardAttribute attribute = artifact.getAttribute(new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.fromID(attributeType.getTypeID())));\r\n        if (attribute == null) {\r\n            return \"\";\r\n        } else if (attributeType.getValueType() == DATETIME) {\r\n            return TimeUtilities.epochToTime(attribute.getValueLong(), TimeZone.getTimeZone(Utils.getUserPreferredZoneId()));\r\n        } else {\r\n            return attribute.getDisplayString();\r\n        }\r\n    } catch (TskCoreException tskCoreException) {\r\n        logger.log(Level.WARNING, \"Error getting attribute value.\", tskCoreException);\r\n        return \"\";\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.Logger.createFileHandlerWithTraces",
	"Comment": "creates a custom file handler with a custom message formatter thatincludes stack traces.",
	"Method": "FileHandler createFileHandlerWithTraces(String logDirectory){\r\n    String logFilePath = Paths.get(logDirectory, LOG_FILE_NAME).toString();\r\n    try {\r\n        FileHandler fileHandler = new FileHandler(logFilePath, LOG_SIZE, UserPreferences.getLogFileCount());\r\n        fileHandler.setEncoding(LOG_ENCODING);\r\n        fileHandler.setFormatter(new Formatter() {\r\n            @Override\r\n            public String format(LogRecord record) {\r\n                Throwable thrown = record.getThrown();\r\n                String stackTrace = \"\";\r\n                while (thrown != null) {\r\n                    stackTrace += thrown.toString() + \"\\n\";\r\n                    for (StackTraceElement traceElem : record.getThrown().getStackTrace()) {\r\n                        stackTrace += \"\\t\" + traceElem.toString() + \"\\n\";\r\n                    }\r\n                    thrown = thrown.getCause();\r\n                }\r\n                return (new Timestamp(record.getMillis())).toString() + \" \" + record.getSourceClassName() + \" \" + record.getSourceMethodName() + \"\\n\" + record.getLevel() + \": \" + this.formatMessage(record) + \"\\n\" + stackTrace;\r\n            }\r\n        });\r\n        return fileHandler;\r\n    } catch (IOException ex) {\r\n        throw new RuntimeException(String.format(\"Error initializing file handler for %s\", logFilePath), ex);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.Logger.createFileHandlerWithTraces",
	"Comment": "creates a custom file handler with a custom message formatter thatincludes stack traces.",
	"Method": "FileHandler createFileHandlerWithTraces(String logDirectory){\r\n    Throwable thrown = record.getThrown();\r\n    String stackTrace = \"\";\r\n    while (thrown != null) {\r\n        stackTrace += thrown.toString() + \"\\n\";\r\n        for (StackTraceElement traceElem : record.getThrown().getStackTrace()) {\r\n            stackTrace += \"\\t\" + traceElem.toString() + \"\\n\";\r\n        }\r\n        thrown = thrown.getCause();\r\n    }\r\n    return (new Timestamp(record.getMillis())).toString() + \" \" + record.getSourceClassName() + \" \" + record.getSourceMethodName() + \"\\n\" + record.getLevel() + \": \" + this.formatMessage(record) + \"\\n\" + stackTrace;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.ImageGalleryModule.onStart",
	"Comment": "sets the implicit exit property attribute of the javafx runtime to falseand sets up listeners for application events. it is invoked atapplication start up by virtue of the onstart annotation on the onstartclass in this package.",
	"Method": "void onStart(){\r\n    Platform.setImplicitExit(false);\r\n    IngestManager.getInstance().addIngestJobEventListener(new IngestJobEventListener());\r\n    IngestManager.getInstance().addIngestModuleEventListener(new IngestModuleEventListener());\r\n    Case.addEventTypeSubscriber(CASE_EVENTS_OF_INTEREST, new CaseEventListener());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.ReportProgressPanel.setMaximumProgress",
	"Comment": "sets the maximum value of the progress bar component of this panel.",
	"Method": "void setMaximumProgress(int max){\r\n    EventQueue.invokeLater(() -> {\r\n        if (status != ReportStatus.CANCELED) {\r\n            reportProgressBar.setMaximum(max);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.contentviewer.DataContentViewerOtherCases.populateTable",
	"Comment": "load the correlatable data into the table model. if there is no dataavailable display the message on the status panel.",
	"Method": "void populateTable(Node node){\r\n    String dataSourceName = \"\";\r\n    String deviceId = \"\";\r\n    try {\r\n        if (this.file != null) {\r\n            Content dataSource = this.file.getDataSource();\r\n            dataSourceName = dataSource.getName();\r\n            deviceId = Case.getCurrentCaseThrows().getSleuthkitCase().getDataSource(dataSource.getId()).getDeviceId();\r\n        }\r\n    } catch (TskException | NoCurrentCaseException ex) {\r\n    }\r\n    correlationAttributes.addAll(getCorrelationAttributesFromNode(node));\r\n    for (CorrelationAttributeInstance corAttr : correlationAttributes) {\r\n        Map<UniquePathKey, OtherOccurrenceNodeInstanceData> correlatedNodeDataMap = new HashMap(0);\r\n        correlatedNodeDataMap.putAll(getCorrelatedInstances(corAttr, dataSourceName, deviceId));\r\n        correlatedNodeDataMap.values().forEach((nodeData) -> {\r\n            tableModel.addNodeData(nodeData);\r\n        });\r\n    }\r\n    if (correlationAttributes.isEmpty()) {\r\n        tableModel.addNodeData(new OtherOccurrenceNodeMessageData(Bundle.DataContentViewerOtherCases_table_noArtifacts()));\r\n        setColumnWidthToText(0, Bundle.DataContentViewerOtherCases_table_noArtifacts());\r\n    } else if (0 == tableModel.getRowCount()) {\r\n        tableModel.addNodeData(new OtherOccurrenceNodeMessageData(Bundle.DataContentViewerOtherCases_table_noResultsFound()));\r\n        setColumnWidthToText(0, Bundle.DataContentViewerOtherCases_table_noResultsFound());\r\n    } else {\r\n        setColumnWidths();\r\n    }\r\n    setEarliestCaseDate();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestManager.fireIngestJobCompleted",
	"Comment": "publishes an ingest event signifying an ingest job finished.",
	"Method": "void fireIngestJobCompleted(long ingestJobId){\r\n    AutopsyEvent event = new AutopsyEvent(IngestJobEvent.COMPLETED.toString(), ingestJobId, null);\r\n    eventPublishingExecutor.submit(new PublishEventTask(event, jobEventPublisher));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.ReportGenerator.displayProgressPanel",
	"Comment": "display the progress panels to the user, and add actions to close theparent dialog.",
	"Method": "void displayProgressPanel(){\r\n    final JDialog dialog = new JDialog((JFrame) WindowManager.getDefault().getMainWindow(), true);\r\n    dialog.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE);\r\n    dialog.setTitle(NbBundle.getMessage(this.getClass(), \"ReportGenerator.displayProgress.title.text\"));\r\n    dialog.add(this.reportGenerationPanel);\r\n    dialog.pack();\r\n    reportGenerationPanel.addCloseAction(new ActionListener() {\r\n        @Override\r\n        public void actionPerformed(ActionEvent e) {\r\n            dialog.dispose();\r\n        }\r\n    });\r\n    dialog.addWindowListener(new WindowAdapter() {\r\n        @Override\r\n        public void windowClosing(WindowEvent e) {\r\n            reportGenerationPanel.close();\r\n        }\r\n    });\r\n    dialog.setLocationRelativeTo(WindowManager.getDefault().getMainWindow());\r\n    dialog.setVisible(true);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.ReportGenerator.displayProgressPanel",
	"Comment": "display the progress panels to the user, and add actions to close theparent dialog.",
	"Method": "void displayProgressPanel(){\r\n    dialog.dispose();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.ReportGenerator.displayProgressPanel",
	"Comment": "display the progress panels to the user, and add actions to close theparent dialog.",
	"Method": "void displayProgressPanel(){\r\n    reportGenerationPanel.close();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.KeywordSearchList.addList",
	"Comment": "adds the new word list using name id replacing old one if exists with thesame name",
	"Method": "boolean addList(String name,List<Keyword> newList,boolean useForIngest,boolean ingestMessages,boolean locked,boolean addList,String name,List<Keyword> newList,boolean useForIngest,boolean ingestMessages,boolean addList,String name,List<Keyword> newList,boolean addList,KeywordList list){\r\n    return addList(list.getName(), list.getKeywords(), list.getUseForIngest(), list.getIngestMessages(), list.isEditable());\r\n}"
}, {
	"Path": "com.anysoftkeyboard.utils.XmlWriter.replaceString",
	"Comment": "replace a string with another string inside a larger string, for thefirst n values of the search string.",
	"Method": "String replaceString(String text,String repl,String with,String replaceString,String text,String repl,String with,int max){\r\n    if (text == null) {\r\n        return null;\r\n    }\r\n    StringBuilder buffer = new StringBuilder(text.length());\r\n    int start = 0;\r\n    int end;\r\n    while ((end = text.indexOf(repl, start)) != -1) {\r\n        buffer.append(text.substring(start, end)).append(with);\r\n        start = end + repl.length();\r\n        if (--max == 0) {\r\n            break;\r\n        }\r\n    }\r\n    buffer.append(text.substring(start));\r\n    return buffer.toString();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.MultiUserSettingsPanel.checkFieldsAndEnableButtons",
	"Comment": "tests whether or not all of the settings components are populated andsets the test buttons appropriately.",
	"Method": "boolean checkFieldsAndEnableButtons(){\r\n    boolean result = true;\r\n    boolean dbPopulated = databaseFieldsArePopulated();\r\n    boolean solrPopulated = solrFieldsArePopulated();\r\n    boolean messageServicePopulated = messageServiceFieldsArePopulated();\r\n    bnTestDatabase.setEnabled(dbPopulated);\r\n    bnTestSolr.setEnabled(solrPopulated);\r\n    bnTestMessageService.setEnabled(messageServicePopulated);\r\n    if (!dbPopulated || !solrPopulated || !messageServicePopulated) {\r\n        result = false;\r\n        tbOops.setText(INCOMPLETE_SETTINGS_MSG);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.ResultViewerPersistence.loadSortCriteria",
	"Comment": "load the persisted sort criteria for nodes of the same type as the givennode.",
	"Method": "List<SortCriterion> loadSortCriteria(TableFilterNode node){\r\n    List<Node.Property<?>> availableProperties = ResultViewerPersistence.getAllChildProperties(node, 100);\r\n    final Preferences preferences = NbPreferences.forModule(DataResultViewerTable.class);\r\n    java.util.SortedMap<Integer, SortCriterion> criteriaMap = new TreeMap();\r\n    availableProperties.forEach(prop -> {\r\n        Integer sortRank = preferences.getInt(ResultViewerPersistence.getColumnSortRankKey(node, prop.getName()), 0);\r\n        if (sortRank != 0) {\r\n            final SortOrder sortOrder = preferences.getBoolean(ResultViewerPersistence.getColumnSortOrderKey(node, prop.getName()), true) ? SortOrder.ASCENDING : SortOrder.DESCENDING;\r\n            final SortCriterion sortCriterion = new SortCriterion(prop, sortOrder, sortRank);\r\n            criteriaMap.put(sortRank, sortCriterion);\r\n        }\r\n    });\r\n    return new ArrayList(criteriaMap.values());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.SqliteEamDbSettings.verifyConnection",
	"Comment": "use the current settings and the validation query to test the connectionto the database.",
	"Method": "boolean verifyConnection(){\r\n    Connection conn = getEphemeralConnection();\r\n    if (null == conn) {\r\n        return false;\r\n    }\r\n    boolean result = EamDbUtil.executeValidationQuery(conn, VALIDATION_QUERY);\r\n    EamDbUtil.closeConnection(conn);\r\n    return result;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.datamodel.FilteredEventsModel.getEventIDsForArtifact",
	"Comment": "get a list of event ids for the events that are derived from the givenartifact.",
	"Method": "List<Long> getEventIDsForArtifact(BlackboardArtifact artifact){\r\n    return repo.getEventIDsForArtifact(artifact);\r\n}"
}, {
	"Path": "org.wikipedia.views.AppTextViewWithImages.setTextWithDrawables",
	"Comment": "a method to set a spanned character sequence containing drawable resources.",
	"Method": "void setTextWithDrawables(CharSequence text,int drawableIds){\r\n    setText(text, getImageSpans(drawableIds));\r\n}"
}, {
	"Path": "burrows.apps.example.template.adapter.BaseAdapter.set",
	"Comment": "replaces the element at the specified location in the data with thespecified object. this operation does not change the size of the data.",
	"Method": "T set(int location,T object){\r\n    final T insertedObject = data.set(location, object);\r\n    notifyDataSetChanged();\r\n    return insertedObject;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.PlatformUtil.getUserDirectory",
	"Comment": "get user directory where application wide user settings, cache, tempfiles are stored",
	"Method": "File getUserDirectory(){\r\n    return Places.getUserDirectory();\r\n}"
}, {
	"Path": "org.wikipedia.util.ReleaseUtil.getChannelFromManifest",
	"Comment": "returns the distribution channel for the app from androidmanifest.xml",
	"Method": "String getChannelFromManifest(Context ctx){\r\n    try {\r\n        ApplicationInfo info = ctx.getPackageManager().getApplicationInfo(BuildConfig.APPLICATION_ID, PackageManager.GET_META_DATA);\r\n        String channel = info.metaData.getString(Prefs.getAppChannelKey());\r\n        return channel != null ? channel : \"\";\r\n    } catch (Throwable t) {\r\n        return \"\";\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.AbstractSqlEamDb.setAttributeInstanceKnownStatus",
	"Comment": "sets an eamartifact instance to the given knownstatus. knownstatus shouldbe bad if the file has been tagged with a notable tag and unknownotherwise. if eamartifact exists, it is updated. if eamartifact does notexist it is added with the given status.",
	"Method": "void setAttributeInstanceKnownStatus(CorrelationAttributeInstance eamArtifact,TskData.FileKnown knownStatus){\r\n    if (eamArtifact == null) {\r\n        throw new EamDbException(\"CorrelationAttribute is null\");\r\n    }\r\n    if (knownStatus == null) {\r\n        throw new EamDbException(\"Known status is null\");\r\n    }\r\n    if (eamArtifact.getCorrelationCase() == null) {\r\n        throw new EamDbException(\"Correlation case is null\");\r\n    }\r\n    if (eamArtifact.getCorrelationDataSource() == null) {\r\n        throw new EamDbException(\"Correlation data source is null\");\r\n    }\r\n    Connection conn = connect();\r\n    PreparedStatement preparedUpdate = null;\r\n    PreparedStatement preparedQuery = null;\r\n    ResultSet resultSet = null;\r\n    String tableName = EamDbUtil.correlationTypeToInstanceTableName(eamArtifact.getCorrelationType());\r\n    String sqlQuery = \"SELECT id FROM \" + tableName + \" WHERE case_id=? \" + \"AND data_source_id=? \" + \"AND value=? \" + \"AND file_path=?\";\r\n    String sqlUpdate = \"UPDATE \" + tableName + \" SET known_status=?, comment=? \" + \"WHERE id=?\";\r\n    try {\r\n        preparedQuery = conn.prepareStatement(sqlQuery);\r\n        preparedQuery.setInt(1, eamArtifact.getCorrelationCase().getID());\r\n        preparedQuery.setInt(2, eamArtifact.getCorrelationDataSource().getID());\r\n        preparedQuery.setString(3, eamArtifact.getCorrelationValue());\r\n        preparedQuery.setString(4, eamArtifact.getFilePath());\r\n        resultSet = preparedQuery.executeQuery();\r\n        if (resultSet.next()) {\r\n            int instance_id = resultSet.getInt(\"id\");\r\n            preparedUpdate = conn.prepareStatement(sqlUpdate);\r\n            preparedUpdate.setByte(1, knownStatus.getFileKnownValue());\r\n            if (\"\".equals(eamArtifact.getComment())) {\r\n                preparedUpdate.setNull(2, Types.INTEGER);\r\n            } else {\r\n                preparedUpdate.setString(2, eamArtifact.getComment());\r\n            }\r\n            preparedUpdate.setInt(3, instance_id);\r\n            preparedUpdate.executeUpdate();\r\n        } else {\r\n            CorrelationCase correlationCaseWithId = getCaseByUUID(eamArtifact.getCorrelationCase().getCaseUUID());\r\n            if (null == correlationCaseWithId) {\r\n                correlationCaseWithId = newCase(eamArtifact.getCorrelationCase());\r\n            }\r\n            if (null == getDataSource(correlationCaseWithId, eamArtifact.getCorrelationDataSource().getDataSourceObjectID())) {\r\n                newDataSource(eamArtifact.getCorrelationDataSource());\r\n            }\r\n            eamArtifact.setKnownStatus(knownStatus);\r\n            addArtifactInstance(eamArtifact);\r\n        }\r\n    } catch (SQLException ex) {\r\n        throw new EamDbException(\"Error getting/setting artifact instance knownStatus=\" + knownStatus.getName(), ex);\r\n    } finally {\r\n        EamDbUtil.closeStatement(preparedUpdate);\r\n        EamDbUtil.closeStatement(preparedQuery);\r\n        EamDbUtil.closeResultSet(resultSet);\r\n        EamDbUtil.closeConnection(conn);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.Keyword.setArtifactAttributeType",
	"Comment": "sets the artifact attribute type associated with the keyword, if any.the association of an artifact attribute type with the keyword was addedto support an initial implementation of account number search and may beremoved in the future.",
	"Method": "void setArtifactAttributeType(BlackboardAttribute.ATTRIBUTE_TYPE artifactAtrributeType){\r\n    this.artifactAtrributeType = artifactAtrributeType;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.ImageDSProcessor.isPanelValid",
	"Comment": "indicates whether the settings in the selection and configuration panelare valid and complete.",
	"Method": "boolean isPanelValid(){\r\n    return configPanel.validatePanel();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.fileextmismatch.FileExtMismatchIngestModule.addToTotals",
	"Comment": "update the match time total and increment num of files for this job",
	"Method": "void addToTotals(long ingestJobId,long processTimeInc){\r\n    IngestJobTotals ingestJobTotals = totalsForIngestJobs.get(ingestJobId);\r\n    if (ingestJobTotals == null) {\r\n        ingestJobTotals = new IngestJobTotals();\r\n        totalsForIngestJobs.put(ingestJobId, ingestJobTotals);\r\n    }\r\n    ingestJobTotals.processTime += processTimeInc;\r\n    ingestJobTotals.numFiles++;\r\n    totalsForIngestJobs.put(ingestJobId, ingestJobTotals);\r\n}"
}, {
	"Path": "com.mcxiaoke.next.ui.list.AdapterExtend.getCount",
	"Comment": "how many items are in the data set represented by thisadapter.",
	"Method": "int getCount(){\r\n    if (isEnableRefreshing()) {\r\n        return super.getCount() + 1;\r\n    }\r\n    return (super.getCount());\r\n}"
}, {
	"Path": "com.stevesouza.jdk.JdbcInteraction.generateSqlException",
	"Comment": "purposefully throw an exception.automon monitoring will detect this.",
	"Method": "void generateSqlException(){\r\n    try {\r\n        executeQuery(\"select * from i_do_not_exist\");\r\n    } catch (Exception e) {\r\n        System.out.println(\"      ** sql exception thrown: \" + e);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.hashdatabase.IdxHashSetParser.getExpectedHashCount",
	"Comment": "get the expected number of hashes in the file. this number can be anestimate.",
	"Method": "long getExpectedHashCount(){\r\n    return totalHashes;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.configuration.AutoIngestUserPreferences.getSecondsToSleepBetweenCases",
	"Comment": "get the configured time to sleep between cases to prevent database locks",
	"Method": "int getSecondsToSleepBetweenCases(){\r\n    String value = getPreferenceValue(SLEEP_BETWEEN_CASES_TIME);\r\n    return value.isEmpty() ? 30 : Integer.parseInt(value);\r\n}"
}, {
	"Path": "com.mcxiaoke.next.utils.StringUtils.removeDuplicateStrings",
	"Comment": "remove duplicate strings from the given array. also sorts the array, asit uses a treeset.",
	"Method": "String[] removeDuplicateStrings(String[] array){\r\n    if (isEmpty(array)) {\r\n        return array;\r\n    }\r\n    Set<String> set = new TreeSet<String>();\r\n    Collections.addAll(set, array);\r\n    return toStringArray(set);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.ImageGalleryController.hasFilesWithNoMimeType",
	"Comment": "checks if the given data source has any files with no mimetype",
	"Method": "boolean hasFilesWithNoMimeType(long dataSourceId){\r\n    String whereClause = \"data_source_obj_id = \" + dataSourceId + \" AND ( meta_type = \" + TskData.TSK_FS_META_TYPE_ENUM.TSK_FS_META_TYPE_REG.getValue() + \")\" + \" AND ( mime_type IS NULL )\" + \" AND ( meta_addr >= 32 ) \" + \" AND ( parent_path <> '/' )\" + \" AND ( name NOT like '$%:%' )\";\r\n    return sleuthKitCase.countFilesWhere(whereClause) > 0;\r\n}"
}, {
	"Path": "com.mcxiaoke.next.cache.LruCacheCompat.trimToSize",
	"Comment": "remove the eldest entries until the total of remaining entries is at orbelow the requested size.",
	"Method": "void trimToSize(int maxSize){\r\n    while (true) {\r\n        K key;\r\n        V value;\r\n        synchronized (this) {\r\n            if (size < 0 || (map.isEmpty() && size != 0)) {\r\n                throw new IllegalStateException(getClass().getName() + \".sizeOf() is reporting inconsistent results!\");\r\n            }\r\n            if (size <= maxSize || map.isEmpty()) {\r\n                break;\r\n            }\r\n            Map.Entry<K, V> toEvict = map.entrySet().iterator().next();\r\n            key = toEvict.getKey();\r\n            value = toEvict.getValue();\r\n            map.remove(key);\r\n            size -= safeSizeOf(key, value);\r\n            evictionCount++;\r\n        }\r\n        entryRemoved(true, key, value, null);\r\n    }\r\n}"
}, {
	"Path": "com.klinker.android.peekview.PeekView.setDistanceFromLeft",
	"Comment": "sets how far away from the left side of the screen the view should be displayed.distance should be the value in px.",
	"Method": "void setDistanceFromLeft(int distance){\r\n    this.distanceFromLeft = options.fullScreenPeek() ? 0 : distance;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.healthmonitor.TimingMetric.normalize",
	"Comment": "normalize the metric by dividing the time by the given counter.if the counter is zero, it will be treated the same way as if thecounter were one.",
	"Method": "void normalize(long count){\r\n    if (duration != null) {\r\n        if (count < 0) {\r\n            throw new HealthMonitorException(\"normalize() called with negative count (\" + count + \")\");\r\n        } else if (count > 1) {\r\n            duration = duration / count;\r\n        }\r\n    } else {\r\n        throw new HealthMonitorException(\"normalize() called before stopTiming()\");\r\n    }\r\n}"
}, {
	"Path": "com.google.example.games.bc.MainActivity.handleInvitationInboxResult",
	"Comment": "to accept. we react by accepting the selected invitation, if any.",
	"Method": "void handleInvitationInboxResult(int response,Intent data){\r\n    if (response != Activity.RESULT_OK) {\r\n        Log.w(TAG, \"*** invitation inbox UI cancelled, \" + response);\r\n        switchToMainScreen();\r\n        return;\r\n    }\r\n    Log.d(TAG, \"Invitation inbox UI succeeded.\");\r\n    Invitation invitation = data.getExtras().getParcelable(Multiplayer.EXTRA_INVITATION);\r\n    if (invitation != null) {\r\n        acceptInviteToRoom(invitation.getInvitationId());\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.KeywordList.setUseForIngest",
	"Comment": "sets whether or not the list should be used when ingesting a data source.",
	"Method": "void setUseForIngest(boolean useForIngest){\r\n    this.useForIngest = useForIngest;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.hashdatabase.HashkeeperHashSetParser.getExpectedHashCount",
	"Comment": "get the expected number of hashes in the file. this number can be anestimate.",
	"Method": "long getExpectedHashCount(){\r\n    return expectedHashCount;\r\n}"
}, {
	"Path": "com.stealthcopter.networktools.Ping.onAddress",
	"Comment": "set the address to pingnote that a lookup is not performed here so that we do not accidentally perform a networkrequest on the ui thread.",
	"Method": "Ping onAddress(String address,Ping onAddress,InetAddress ia){\r\n    Ping ping = new Ping();\r\n    ping.setAddress(ia);\r\n    return ping;\r\n}"
}, {
	"Path": "com.facebook.samples.zoomable.DefaultZoomableController.calculateGestureTransform",
	"Comment": "calculates the zoom transformation based on the current gesture.",
	"Method": "boolean calculateGestureTransform(Matrix outTransform,int limitTypes){\r\n    TransformGestureDetector detector = mGestureDetector;\r\n    boolean transformCorrected = false;\r\n    outTransform.set(mPreviousTransform);\r\n    if (mIsRotationEnabled) {\r\n        float angle = detector.getRotation() * (float) (180 / Math.PI);\r\n        outTransform.postRotate(angle, detector.getPivotX(), detector.getPivotY());\r\n    }\r\n    if (mIsScaleEnabled) {\r\n        float scale = detector.getScale();\r\n        outTransform.postScale(scale, scale, detector.getPivotX(), detector.getPivotY());\r\n    }\r\n    transformCorrected |= limitScale(outTransform, detector.getPivotX(), detector.getPivotY(), limitTypes);\r\n    if (mIsTranslationEnabled) {\r\n        outTransform.postTranslate(detector.getTranslationX(), detector.getTranslationY());\r\n    }\r\n    transformCorrected |= limitTranslation(outTransform, limitTypes);\r\n    return transformCorrected;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.hashdatabase.HashLookupModuleSettings.shouldCalculateHashes",
	"Comment": "checks the setting that specifies whether or not hashes are to becalculated.",
	"Method": "boolean shouldCalculateHashes(){\r\n    return this.shouldCalculateHashes;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestManager.handleRemoteJobStatusEvent",
	"Comment": "processes a job status event from another node by adding the job in theevent to the collection of jobs running on other hosts.note that the processing stage of the job will be whatever it was whenthe job was serialized for inclusion in the event message.",
	"Method": "void handleRemoteJobStatusEvent(AutoIngestJobStatusEvent event){\r\n    AutoIngestJob job = event.getJob();\r\n    synchronized (jobsLock) {\r\n        for (Iterator<AutoIngestJob> iterator = pendingJobs.iterator(); iterator.hasNext(); ) {\r\n            AutoIngestJob pendingJob = iterator.next();\r\n            if (job.equals(pendingJob)) {\r\n                iterator.remove();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    String hostName = job.getProcessingHostName();\r\n    hostNamesToLastMsgTime.put(hostName, Instant.now());\r\n    hostNamesToRunningJobs.put(hostName, job);\r\n    setChanged();\r\n    notifyObservers(Event.JOB_STATUS_UPDATED);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.contentviewer.DataContentViewerOtherCases.getBlackboardArtifactFromNode",
	"Comment": "get the associated blackboardartifact from a node, if it exists.",
	"Method": "BlackboardArtifact getBlackboardArtifactFromNode(Node node){\r\n    BlackboardArtifactTag nodeBbArtifactTag = node.getLookup().lookup(BlackboardArtifactTag.class);\r\n    BlackboardArtifact nodeBbArtifact = node.getLookup().lookup(BlackboardArtifact.class);\r\n    if (nodeBbArtifactTag != null) {\r\n        return nodeBbArtifactTag.getArtifact();\r\n    } else if (nodeBbArtifact != null) {\r\n        return nodeBbArtifact;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.TableFilterNode.getChildNodeSelectionInfo",
	"Comment": "gets information about which child node of this node, if any, should beselected.",
	"Method": "NodeSelectionInfo getChildNodeSelectionInfo(){\r\n    if (getOriginal() instanceof DataResultFilterNode) {\r\n        return ((DataResultFilterNode) getOriginal()).getChildNodeSelectionInfo();\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.texttranslation.TextTranslationService.translate",
	"Comment": "translates the input string using whichever texttranslator service provider was found during lookup.",
	"Method": "String translate(String input){\r\n    if (translator.isPresent()) {\r\n        return translator.get().translate(input);\r\n    }\r\n    throw new NoServiceProviderException(\"Could not find a TextTranslator service provider\");\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.optionspanel.EamDbSettingsDialog.configureTextPrompts",
	"Comment": "sets the foreground color and transparency of a collection of textprompts.",
	"Method": "void configureTextPrompts(Collection<TextPrompt> textPrompts){\r\n    float alpha = 0.9f;\r\n    for (TextPrompt textPrompt : textPrompts) {\r\n        textPrompt.setForeground(Color.LIGHT_GRAY);\r\n        textPrompt.changeAlpha(alpha);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.test.CustomArtifactsCreatorIngestModuleFactory.getModuleVersionNumber",
	"Comment": "gets the version number of the family of ingest modules the factorycreates.",
	"Method": "String getModuleVersionNumber(){\r\n    return Version.getVersion();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestManager.handleRemoteJobCompletedEvent",
	"Comment": "processes a job completed event from another node by removing the job inthe event from the collection of jobs running on other hosts and addingit to the list of completed jobs.note that the processing stage of the job will be whatever it was whenthe job was serialized for inclusion in the event message.",
	"Method": "void handleRemoteJobCompletedEvent(AutoIngestJobCompletedEvent event){\r\n    String hostName = event.getJob().getProcessingHostName();\r\n    hostNamesToLastMsgTime.put(hostName, Instant.now());\r\n    hostNamesToRunningJobs.remove(hostName);\r\n    if (event.shouldRetry() == false) {\r\n        synchronized (jobsLock) {\r\n            AutoIngestJob job = event.getJob();\r\n            if (completedJobs.contains(job)) {\r\n                completedJobs.remove(job);\r\n            }\r\n            completedJobs.add(event.getJob());\r\n        }\r\n    }\r\n    setChanged();\r\n    notifyObservers(Event.JOB_COMPLETED);\r\n}"
}, {
	"Path": "com.aliyun.oss.internal.ResponseParsers.parseGetBucketLifecycle",
	"Comment": "unmarshall get bucket lifecycle response body to lifecycle rules.",
	"Method": "List<LifecycleRule> parseGetBucketLifecycle(InputStream responseBody){\r\n    try {\r\n        Element root = getXmlRootElement(responseBody);\r\n        List<LifecycleRule> lifecycleRules = new ArrayList<LifecycleRule>();\r\n        List<Element> ruleElements = root.getChildren(\"Rule\");\r\n        for (Element ruleElem : ruleElements) {\r\n            LifecycleRule rule = new LifecycleRule();\r\n            if (ruleElem.getChild(\"ID\") != null) {\r\n                rule.setId(ruleElem.getChildText(\"ID\"));\r\n            }\r\n            if (ruleElem.getChild(\"Prefix\") != null) {\r\n                rule.setPrefix(ruleElem.getChildText(\"Prefix\"));\r\n            }\r\n            if (ruleElem.getChild(\"Status\") != null) {\r\n                rule.setStatus(RuleStatus.valueOf(ruleElem.getChildText(\"Status\")));\r\n            }\r\n            if (ruleElem.getChild(\"Expiration\") != null) {\r\n                if (ruleElem.getChild(\"Expiration\").getChild(\"Date\") != null) {\r\n                    Date expirationDate = DateUtil.parseIso8601Date(ruleElem.getChild(\"Expiration\").getChildText(\"Date\"));\r\n                    rule.setExpirationTime(expirationDate);\r\n                } else if (ruleElem.getChild(\"Expiration\").getChild(\"Days\") != null) {\r\n                    rule.setExpirationDays(Integer.parseInt(ruleElem.getChild(\"Expiration\").getChildText(\"Days\")));\r\n                } else {\r\n                    Date createdBeforeDate = DateUtil.parseIso8601Date(ruleElem.getChild(\"Expiration\").getChildText(\"CreatedBeforeDate\"));\r\n                    rule.setCreatedBeforeDate(createdBeforeDate);\r\n                }\r\n            }\r\n            if (ruleElem.getChild(\"AbortMultipartUpload\") != null) {\r\n                LifecycleRule.AbortMultipartUpload abortMultipartUpload = new LifecycleRule.AbortMultipartUpload();\r\n                if (ruleElem.getChild(\"AbortMultipartUpload\").getChild(\"Days\") != null) {\r\n                    abortMultipartUpload.setExpirationDays(Integer.parseInt(ruleElem.getChild(\"AbortMultipartUpload\").getChildText(\"Days\")));\r\n                } else {\r\n                    Date createdBeforeDate = DateUtil.parseIso8601Date(ruleElem.getChild(\"AbortMultipartUpload\").getChildText(\"CreatedBeforeDate\"));\r\n                    abortMultipartUpload.setCreatedBeforeDate(createdBeforeDate);\r\n                }\r\n                rule.setAbortMultipartUpload(abortMultipartUpload);\r\n            }\r\n            List<Element> transitionElements = ruleElem.getChildren(\"Transition\");\r\n            List<StorageTransition> storageTransitions = new ArrayList<StorageTransition>();\r\n            for (Element transitionElem : transitionElements) {\r\n                LifecycleRule.StorageTransition storageTransition = new LifecycleRule.StorageTransition();\r\n                if (transitionElem.getChild(\"Days\") != null) {\r\n                    storageTransition.setExpirationDays(Integer.parseInt(transitionElem.getChildText(\"Days\")));\r\n                } else {\r\n                    Date createdBeforeDate = DateUtil.parseIso8601Date(transitionElem.getChildText(\"CreatedBeforeDate\"));\r\n                    storageTransition.setCreatedBeforeDate(createdBeforeDate);\r\n                }\r\n                if (transitionElem.getChild(\"StorageClass\") != null) {\r\n                    storageTransition.setStorageClass(StorageClass.parse(transitionElem.getChildText(\"StorageClass\")));\r\n                }\r\n                storageTransitions.add(storageTransition);\r\n            }\r\n            rule.setStorageTransition(storageTransitions);\r\n            lifecycleRules.add(rule);\r\n        }\r\n        return lifecycleRules;\r\n    } catch (JDOMParseException e) {\r\n        throw new ResponseParseException(e.getPartialDocument() + \": \" + e.getMessage(), e);\r\n    } catch (Exception e) {\r\n        throw new ResponseParseException(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestMonitor.queryCoordinationService",
	"Comment": "gets a new snapshot of the pending jobs queue, running jobs list, andcompleted jobs list for an auto ingest cluster.",
	"Method": "JobsSnapshot queryCoordinationService(){\r\n    try {\r\n        JobsSnapshot newJobsSnapshot = new JobsSnapshot();\r\n        List<String> nodeList = coordinationService.getNodeList(CoordinationService.CategoryNode.MANIFESTS);\r\n        for (String node : nodeList) {\r\n            try {\r\n                AutoIngestJobNodeData nodeData = new AutoIngestJobNodeData(coordinationService.getNodeData(CoordinationService.CategoryNode.MANIFESTS, node));\r\n                if (nodeData.getVersion() < 1) {\r\n                    continue;\r\n                }\r\n                AutoIngestJob job = new AutoIngestJob(nodeData);\r\n                ProcessingStatus processingStatus = nodeData.getProcessingStatus();\r\n                switch(processingStatus) {\r\n                    case PENDING:\r\n                        newJobsSnapshot.addOrReplacePendingJob(job);\r\n                        break;\r\n                    case PROCESSING:\r\n                        newJobsSnapshot.addOrReplaceRunningJob(job);\r\n                        break;\r\n                    case COMPLETED:\r\n                        newJobsSnapshot.addOrReplaceCompletedJob(job);\r\n                        break;\r\n                    case DELETED:\r\n                        break;\r\n                    default:\r\n                        LOGGER.log(Level.SEVERE, \"Unknown AutoIngestJobData.ProcessingStatus\");\r\n                        break;\r\n                }\r\n            } catch (InterruptedException ex) {\r\n                LOGGER.log(Level.SEVERE, String.format(\"Unexpected interrupt while retrieving coordination service node data for '%s'\", node), ex);\r\n            } catch (AutoIngestJobNodeData.InvalidDataException ex) {\r\n                LOGGER.log(Level.SEVERE, String.format(\"Unable to use node data for '%s'\", node), ex);\r\n            } catch (AutoIngestJob.AutoIngestJobException ex) {\r\n                LOGGER.log(Level.SEVERE, String.format(\"Failed to create a job for '%s'\", node), ex);\r\n            }\r\n        }\r\n        return newJobsSnapshot;\r\n    } catch (CoordinationServiceException ex) {\r\n        LOGGER.log(Level.SEVERE, \"Failed to get node list from coordination service\", ex);\r\n        return new JobsSnapshot();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.Server.queryNumIndexedFiles",
	"Comment": "execute query that gets only number of all solr files indexed withoutactually returning the files. the result does not include chunks, onlynumber of actual files.",
	"Method": "int queryNumIndexedFiles(int queryNumIndexedFiles){\r\n    currentCoreLock.readLock().lock();\r\n    try {\r\n        if (null == currentCore) {\r\n            throw new NoOpenCoreException();\r\n        }\r\n        try {\r\n            return currentCore.queryNumIndexedFiles();\r\n        } catch (SolrServerException | IOException ex) {\r\n            throw new KeywordSearchModuleException(NbBundle.getMessage(this.getClass(), \"Server.queryNumIdxFiles.exception.msg\"), ex);\r\n        }\r\n    } finally {\r\n        currentCoreLock.readLock().unlock();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.filetypeid.FileTypeIdGlobalSettingsPanel.enableButtons",
	"Comment": "enables or disables the panel buttons based on the state of the panel andthe application.",
	"Method": "void enableButtons(){\r\n    boolean ingestIsRunning = IngestManager.getInstance().isIngestRunning();\r\n    newTypeButton.setEnabled(!ingestIsRunning);\r\n    boolean fileTypeIsSelected = typesList.getSelectedIndex() != -1;\r\n    deleteTypeButton.setEnabled(!ingestIsRunning && fileTypeIsSelected);\r\n    editTypeButton.setEnabled(!ingestIsRunning && fileTypeIsSelected);\r\n    ingestRunningWarningLabel.setVisible(ingestIsRunning);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.DataResultViewerTable.assignColumns",
	"Comment": "sets up the columns for the child outlineview of this tabular resultsviewer with respect to column names and visisbility.",
	"Method": "void assignColumns(List<Property<?>> props){\r\n    String[] propStrings = new String[props.size() * 2];\r\n    for (int i = 0; i < props.size(); i++) {\r\n        final Property<?> prop = props.get(i);\r\n        prop.setValue(\"ComparableColumnTTV\", Boolean.TRUE);\r\n        if (i == 0) {\r\n            prop.setValue(\"TreeColumnTTV\", Boolean.TRUE);\r\n            prop.setValue(\"SortingColumnTTV\", Boolean.TRUE);\r\n        }\r\n        propStrings[2 * i] = prop.getName();\r\n        propStrings[2 * i + 1] = prop.getDisplayName();\r\n    }\r\n    outlineView.setPropertyColumns(propStrings);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.hashdatabase.HashDbSearchManager.execute",
	"Comment": "takes the key values, creates nodes through thehashdbsearchresultfactory, and displays it in the topcomponet.",
	"Method": "void execute(){\r\n    if (!map.isEmpty()) {\r\n        Collection<AbstractFile> kvCollection = kvContents;\r\n        Node rootNode = null;\r\n        if (kvCollection.size() > 0) {\r\n            Children childKeyValueContentNodes = Children.create(new HashDbSearchResultFactory(kvCollection), true);\r\n            rootNode = new AbstractNode(childKeyValueContentNodes);\r\n        } else {\r\n            rootNode = Node.EMPTY;\r\n        }\r\n        final String pathText = NbBundle.getMessage(this.getClass(), \"HashDbSearchManager.MD5HashSearch\");\r\n        TopComponent searchResultWin = DataResultTopComponent.createInstance(NbBundle.getMessage(this.getClass(), \"HashDbSearchManager.MD5HashSearch\"), pathText, rootNode, kvCollection.size());\r\n        searchResultWin.requestActive();\r\n    } else {\r\n        JOptionPane.showMessageDialog(WindowManager.getDefault().getMainWindow(), NbBundle.getMessage(this.getClass(), \"HashDbSearchManager.noResultsFoundMsg\"));\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.datamodel.DrawableDB.getHashSetsForFile",
	"Comment": "get the names of the hashsets that the given fileid belongs to",
	"Method": "Set<String> getHashSetsForFile(long fileID){\r\n    Set<String> hashNames = new HashSet();\r\n    ArrayList<BlackboardArtifact> artifacts = tskCase.getBlackboardArtifacts(BlackboardArtifact.ARTIFACT_TYPE.TSK_HASHSET_HIT, fileID);\r\n    for (BlackboardArtifact a : artifacts) {\r\n        BlackboardAttribute attribute = a.getAttribute(new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_SET_NAME));\r\n        if (attribute != null) {\r\n            hashNames.add(attribute.getValueString());\r\n        }\r\n    }\r\n    return Collections.unmodifiableSet(hashNames);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.TableReportGenerator.getArtifactTableColumns",
	"Comment": "for a given artifact type id, return the list of the columns that we arereporting on.",
	"Method": "List<Column> getArtifactTableColumns(int artifactTypeId,Set<BlackboardAttribute.Type> attributeTypeSet){\r\n    ArrayList<Column> columns = new ArrayList();\r\n    if (BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_BOOKMARK.getTypeID() == artifactTypeId) {\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.url\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_URL)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.title\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_TITLE)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.dateCreated\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_CREATED)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.program\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME)));\r\n    } else if (BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_COOKIE.getTypeID() == artifactTypeId) {\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.url\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_URL)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.dateTime\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.name\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.value\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_VALUE)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.program\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME)));\r\n    } else if (BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_HISTORY.getTypeID() == artifactTypeId) {\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.url\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_URL)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.dateAccessed\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_ACCESSED)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.referrer\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_REFERRER)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.title\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_TITLE)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.program\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.urlDomainDecoded\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_URL_DECODED)));\r\n    } else if (BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_DOWNLOAD.getTypeID() == artifactTypeId) {\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.dest\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PATH)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.sourceUrl\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_URL)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.dateAccessed\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_ACCESSED)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.program\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME)));\r\n    } else if (BlackboardArtifact.ARTIFACT_TYPE.TSK_RECENT_OBJECT.getTypeID() == artifactTypeId) {\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.path\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PATH)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.dateTime\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME)));\r\n    } else if (BlackboardArtifact.ARTIFACT_TYPE.TSK_INSTALLED_PROG.getTypeID() == artifactTypeId) {\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.progName\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.instDateTime\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME)));\r\n    } else if (BlackboardArtifact.ARTIFACT_TYPE.TSK_KEYWORD_HIT.getTypeID() == artifactTypeId) {\r\n        columns.add(new HeaderOnlyColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.preview\")));\r\n    } else if (BlackboardArtifact.ARTIFACT_TYPE.TSK_HASHSET_HIT.getTypeID() == artifactTypeId) {\r\n        columns.add(new SourceFileColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.file\")));\r\n        columns.add(new HeaderOnlyColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.size\")));\r\n    } else if (BlackboardArtifact.ARTIFACT_TYPE.TSK_DEVICE_ATTACHED.getTypeID() == artifactTypeId) {\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.devMake\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DEVICE_MAKE)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.devModel\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DEVICE_MODEL)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.deviceId\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DEVICE_ID)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.dateTime\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME)));\r\n    } else if (BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_SEARCH_QUERY.getTypeID() == artifactTypeId) {\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.text\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_TEXT)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.domain\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DOMAIN)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.dateAccessed\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_ACCESSED)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.progName\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME)));\r\n    } else if (BlackboardArtifact.ARTIFACT_TYPE.TSK_METADATA_EXIF.getTypeID() == artifactTypeId) {\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.dateTaken\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_CREATED)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.devManufacturer\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DEVICE_MAKE)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.devModel\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DEVICE_MODEL)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.latitude\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LATITUDE)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.longitude\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LONGITUDE)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.altitude\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_ALTITUDE)));\r\n    } else if (BlackboardArtifact.ARTIFACT_TYPE.TSK_CONTACT.getTypeID() == artifactTypeId) {\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.personName\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.phoneNumber\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PHONE_NUMBER)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.phoneNumHome\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PHONE_NUMBER_HOME)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.phoneNumOffice\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PHONE_NUMBER_OFFICE)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.phoneNumMobile\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PHONE_NUMBER_MOBILE)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.email\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_EMAIL)));\r\n    } else if (BlackboardArtifact.ARTIFACT_TYPE.TSK_MESSAGE.getTypeID() == artifactTypeId) {\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.msgType\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_MESSAGE_TYPE)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.direction\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DIRECTION)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.readStatus\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_READ_STATUS)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.dateTime\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.fromPhoneNum\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PHONE_NUMBER_FROM)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.fromEmail\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_EMAIL_FROM)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.toPhoneNum\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PHONE_NUMBER_TO)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.toEmail\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_EMAIL_TO)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.subject\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_SUBJECT)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.text\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_TEXT)));\r\n    } else if (BlackboardArtifact.ARTIFACT_TYPE.TSK_CALLLOG.getTypeID() == artifactTypeId) {\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.personName\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.fromPhoneNum\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PHONE_NUMBER_FROM)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.toPhoneNum\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PHONE_NUMBER_TO)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.dateTime\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_START)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.direction\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DIRECTION)));\r\n    } else if (BlackboardArtifact.ARTIFACT_TYPE.TSK_CALENDAR_ENTRY.getTypeID() == artifactTypeId) {\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.calendarEntryType\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_CALENDAR_ENTRY_TYPE)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.description\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DESCRIPTION)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.startDateTime\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_START)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.endDateTime\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_END)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.location\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_LOCATION)));\r\n    } else if (BlackboardArtifact.ARTIFACT_TYPE.TSK_SPEED_DIAL_ENTRY.getTypeID() == artifactTypeId) {\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.shortCut\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_SHORTCUT)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.personName\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME_PERSON)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.phoneNumber\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PHONE_NUMBER)));\r\n    } else if (BlackboardArtifact.ARTIFACT_TYPE.TSK_BLUETOOTH_PAIRING.getTypeID() == artifactTypeId) {\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.deviceName\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DEVICE_NAME)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.deviceAddress\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DEVICE_ID)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.dateTime\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME)));\r\n    } else if (BlackboardArtifact.ARTIFACT_TYPE.TSK_GPS_TRACKPOINT.getTypeID() == artifactTypeId) {\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.latitude\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LATITUDE)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.longitude\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LONGITUDE)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.dateTime\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME)));\r\n    } else if (BlackboardArtifact.ARTIFACT_TYPE.TSK_GPS_BOOKMARK.getTypeID() == artifactTypeId) {\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.latitude\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LATITUDE)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.longitude\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LONGITUDE)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.altitude\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_ALTITUDE)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.name\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.locationAddress\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_LOCATION)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.dateTime\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME)));\r\n    } else if (BlackboardArtifact.ARTIFACT_TYPE.TSK_GPS_LAST_KNOWN_LOCATION.getTypeID() == artifactTypeId) {\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.latitude\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LATITUDE)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.longitude\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LONGITUDE)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.altitude\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_ALTITUDE)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.name\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.locationAddress\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_LOCATION)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.dateTime\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME)));\r\n    } else if (BlackboardArtifact.ARTIFACT_TYPE.TSK_GPS_SEARCH.getTypeID() == artifactTypeId) {\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.latitude\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LATITUDE)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.longitude\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LONGITUDE)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.altitude\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_ALTITUDE)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.name\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.locationAddress\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_LOCATION)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.dateTime\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME)));\r\n    } else if (BlackboardArtifact.ARTIFACT_TYPE.TSK_SERVICE_ACCOUNT.getTypeID() == artifactTypeId) {\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.category\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_CATEGORY)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.userId\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_USER_ID)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.password\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PASSWORD)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.personName\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.appName\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.url\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_URL)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.appPath\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PATH)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.description\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DESCRIPTION)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.replytoAddress\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_EMAIL_REPLYTO)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.mailServer\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_SERVER_NAME)));\r\n    } else if (BlackboardArtifact.ARTIFACT_TYPE.TSK_ENCRYPTION_DETECTED.getTypeID() == artifactTypeId || BlackboardArtifact.ARTIFACT_TYPE.TSK_ENCRYPTION_SUSPECTED.getTypeID() == artifactTypeId) {\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.name\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME)));\r\n    } else if (BlackboardArtifact.ARTIFACT_TYPE.TSK_EXT_MISMATCH_DETECTED.getTypeID() == artifactTypeId) {\r\n        columns.add(new HeaderOnlyColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.file\")));\r\n        columns.add(new HeaderOnlyColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.extension.text\")));\r\n        columns.add(new HeaderOnlyColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.mimeType.text\")));\r\n        columns.add(new HeaderOnlyColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.path\")));\r\n    } else if (BlackboardArtifact.ARTIFACT_TYPE.TSK_OS_INFO.getTypeID() == artifactTypeId) {\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.processorArchitecture.text\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROCESSOR_ARCHITECTURE)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.osName.text\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.osInstallDate.text\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME)));\r\n    } else if (BlackboardArtifact.ARTIFACT_TYPE.TSK_EMAIL_MSG.getTypeID() == artifactTypeId) {\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.tskEmailTo\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_EMAIL_TO)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.tskEmailFrom\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_EMAIL_FROM)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.tskSubject\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_SUBJECT)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.tskDateTimeSent\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_SENT)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.tskDateTimeRcvd\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_RCVD)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.tskPath\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PATH)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.tskEmailCc\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_EMAIL_CC)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.tskEmailBcc\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_EMAIL_BCC)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.tskMsgId\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_MSG_ID)));\r\n    } else if (BlackboardArtifact.ARTIFACT_TYPE.TSK_INTERESTING_FILE_HIT.getTypeID() == artifactTypeId) {\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.tskSetName\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_SET_NAME)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.tskInterestingFilesCategory\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_CATEGORY)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.tskPath\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PATH)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.comment\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_COMMENT)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.description\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DESCRIPTION)));\r\n    } else if (BlackboardArtifact.ARTIFACT_TYPE.TSK_GPS_ROUTE.getTypeID() == artifactTypeId) {\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.tskGpsRouteCategory\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_CATEGORY)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.dateTime\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.latitudeEnd\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LATITUDE_END)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.longitudeEnd\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LONGITUDE_END)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.latitudeStart\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LATITUDE_START)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.longitudeStart\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LONGITUDE_START)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.name\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.location\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_LOCATION)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.program\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME)));\r\n    } else if (BlackboardArtifact.ARTIFACT_TYPE.TSK_INTERESTING_ARTIFACT_HIT.getTypeID() == artifactTypeId) {\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.tskSetName\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_SET_NAME)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.associatedArtifact\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_ASSOCIATED_ARTIFACT)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.program\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME)));\r\n    } else if (BlackboardArtifact.ARTIFACT_TYPE.TSK_PROG_RUN.getTypeID() == artifactTypeId) {\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.program\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.associatedArtifact\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_ASSOCIATED_ARTIFACT)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.dateTime\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.count\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_COUNT)));\r\n    } else if (BlackboardArtifact.ARTIFACT_TYPE.TSK_OS_ACCOUNT.getTypeID() == artifactTypeId) {\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.userName\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_USER_NAME)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.userId\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_USER_ID)));\r\n    } else if (BlackboardArtifact.ARTIFACT_TYPE.TSK_REMOTE_DRIVE.getTypeID() == artifactTypeId) {\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.localPath\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_LOCAL_PATH)));\r\n        columns.add(new AttributeColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.remotePath\"), new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_REMOTE_PATH)));\r\n    } else if (artifactTypeId == BlackboardArtifact.ARTIFACT_TYPE.TSK_ACCOUNT.getTypeID()) {\r\n        columns.add(new StatusColumn());\r\n        attributeTypeSet.remove(new Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_ACCOUNT_TYPE));\r\n        attributeTypeSet.remove(new Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_ASSOCIATED_ARTIFACT));\r\n        attributeTypeSet.remove(new Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_SET_NAME));\r\n        attributeTypeSet.remove(new Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_KEYWORD_SEARCH_DOCUMENT_ID));\r\n    } else {\r\n        for (BlackboardAttribute.Type type : attributeTypeSet) {\r\n            columns.add(new AttributeColumn(type.getDisplayName(), type));\r\n        }\r\n        columns.add(new SourceFileColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.srcFile\")));\r\n        columns.add(new TaggedResultsColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.tags\")));\r\n        return columns;\r\n    }\r\n    for (Column column : columns) {\r\n        attributeTypeSet = column.removeTypeFromSet(attributeTypeSet);\r\n    }\r\n    for (BlackboardAttribute.Type type : attributeTypeSet) {\r\n        columns.add(new AttributeColumn(type.getDisplayName(), type));\r\n    }\r\n    if (artifactTypeId == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_BOOKMARK.getTypeID() || artifactTypeId == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_COOKIE.getTypeID() || artifactTypeId == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_HISTORY.getTypeID() || artifactTypeId == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_DOWNLOAD.getTypeID() || artifactTypeId == BlackboardArtifact.ARTIFACT_TYPE.TSK_RECENT_OBJECT.getTypeID() || artifactTypeId == BlackboardArtifact.ARTIFACT_TYPE.TSK_INSTALLED_PROG.getTypeID() || artifactTypeId == BlackboardArtifact.ARTIFACT_TYPE.TSK_DEVICE_ATTACHED.getTypeID() || artifactTypeId == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_SEARCH_QUERY.getTypeID() || artifactTypeId == BlackboardArtifact.ARTIFACT_TYPE.TSK_METADATA_EXIF.getTypeID() || artifactTypeId == BlackboardArtifact.ARTIFACT_TYPE.TSK_CONTACT.getTypeID() || artifactTypeId == BlackboardArtifact.ARTIFACT_TYPE.TSK_MESSAGE.getTypeID() || artifactTypeId == BlackboardArtifact.ARTIFACT_TYPE.TSK_CALLLOG.getTypeID() || artifactTypeId == BlackboardArtifact.ARTIFACT_TYPE.TSK_CALENDAR_ENTRY.getTypeID() || artifactTypeId == BlackboardArtifact.ARTIFACT_TYPE.TSK_SPEED_DIAL_ENTRY.getTypeID() || artifactTypeId == BlackboardArtifact.ARTIFACT_TYPE.TSK_BLUETOOTH_PAIRING.getTypeID() || artifactTypeId == BlackboardArtifact.ARTIFACT_TYPE.TSK_GPS_TRACKPOINT.getTypeID() || artifactTypeId == BlackboardArtifact.ARTIFACT_TYPE.TSK_GPS_BOOKMARK.getTypeID() || artifactTypeId == BlackboardArtifact.ARTIFACT_TYPE.TSK_GPS_LAST_KNOWN_LOCATION.getTypeID() || artifactTypeId == BlackboardArtifact.ARTIFACT_TYPE.TSK_GPS_SEARCH.getTypeID() || artifactTypeId == BlackboardArtifact.ARTIFACT_TYPE.TSK_SERVICE_ACCOUNT.getTypeID() || artifactTypeId == BlackboardArtifact.ARTIFACT_TYPE.TSK_ENCRYPTION_DETECTED.getTypeID() || artifactTypeId == BlackboardArtifact.ARTIFACT_TYPE.TSK_ENCRYPTION_SUSPECTED.getTypeID() || artifactTypeId == BlackboardArtifact.ARTIFACT_TYPE.TSK_OS_INFO.getTypeID()) {\r\n        columns.add(new SourceFileColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.srcFile\")));\r\n    }\r\n    columns.add(new TaggedResultsColumn(NbBundle.getMessage(this.getClass(), \"ReportGenerator.artTableColHdr.tags\")));\r\n    return columns;\r\n}"
}, {
	"Path": "net.ypresto.androidtranscoder.engine.InputSurface.eglSetup",
	"Comment": "prepares egl.we want a gles 2.0 context and a surface that supports recording.",
	"Method": "void eglSetup(){\r\n    mEGLDisplay = EGL14.eglGetDisplay(EGL14.EGL_DEFAULT_DISPLAY);\r\n    if (mEGLDisplay == EGL14.EGL_NO_DISPLAY) {\r\n        throw new RuntimeException(\"unable to get EGL14 display\");\r\n    }\r\n    int[] version = new int[2];\r\n    if (!EGL14.eglInitialize(mEGLDisplay, version, 0, version, 1)) {\r\n        mEGLDisplay = null;\r\n        throw new RuntimeException(\"unable to initialize EGL14\");\r\n    }\r\n    int[] attribList = { EGL14.EGL_RED_SIZE, 8, EGL14.EGL_GREEN_SIZE, 8, EGL14.EGL_BLUE_SIZE, 8, EGL14.EGL_RENDERABLE_TYPE, EGL14.EGL_OPENGL_ES2_BIT, EGL_RECORDABLE_ANDROID, 1, EGL14.EGL_NONE };\r\n    EGLConfig[] configs = new EGLConfig[1];\r\n    int[] numConfigs = new int[1];\r\n    if (!EGL14.eglChooseConfig(mEGLDisplay, attribList, 0, configs, 0, configs.length, numConfigs, 0)) {\r\n        throw new RuntimeException(\"unable to find RGB888+recordable ES2 EGL config\");\r\n    }\r\n    int[] attrib_list = { EGL14.EGL_CONTEXT_CLIENT_VERSION, 2, EGL14.EGL_NONE };\r\n    mEGLContext = EGL14.eglCreateContext(mEGLDisplay, configs[0], EGL14.EGL_NO_CONTEXT, attrib_list, 0);\r\n    checkEglError(\"eglCreateContext\");\r\n    if (mEGLContext == null) {\r\n        throw new RuntimeException(\"null context\");\r\n    }\r\n    int[] surfaceAttribs = { EGL14.EGL_NONE };\r\n    mEGLSurface = EGL14.eglCreateWindowSurface(mEGLDisplay, configs[0], mSurface, surfaceAttribs, 0);\r\n    checkEglError(\"eglCreateWindowSurface\");\r\n    if (mEGLSurface == null) {\r\n        throw new RuntimeException(\"surface was null\");\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.ReportGenerationPanel.addReport",
	"Comment": "adds a panel used by a report generation module to show progress to thispanel.",
	"Method": "ReportProgressPanel addReport(String reportName,String reportPath){\r\n    reportPanel.remove(glue);\r\n    progressPanel = new ReportProgressPanel(reportName, reportPath);\r\n    constraints.weighty = 0.0;\r\n    constraints.anchor = GridBagConstraints.NORTH;\r\n    reportPanel.add(progressPanel, constraints);\r\n    constraints.gridy++;\r\n    constraints.weighty = 1.0;\r\n    constraints.anchor = GridBagConstraints.PAGE_END;\r\n    reportPanel.add(glue, constraints);\r\n    reportPanel.setPreferredSize(new Dimension(600, 1 * 80));\r\n    reportPanel.repaint();\r\n    progressPanel.addPropertyChangeListener((PropertyChangeEvent evt) -> {\r\n        String propName = evt.getPropertyName();\r\n        if (propName.equals(ReportProgressPanel.ReportStatus.COMPLETE.toString()) || propName.equals(ReportProgressPanel.ReportStatus.CANCELED.toString())) {\r\n            SwingUtilities.invokeLater(() -> {\r\n                cancelButton.setEnabled(false);\r\n            });\r\n        }\r\n    });\r\n    return progressPanel;\r\n}"
}, {
	"Path": "org.owntracks.android.ui.base.BaseActivity.bindAndAttachContentView",
	"Comment": "use this method to set the content view on your activity. this method also handlescreating the binding, setting the view model on the binding and attaching the view.",
	"Method": "void bindAndAttachContentView(int layoutResId,Bundle savedInstanceState){\r\n    if (viewModel == null) {\r\n        throw new IllegalStateException(\"viewModel must not be null and should be injected via activityComponent().inject(this)\");\r\n    }\r\n    binding = DataBindingUtil.setContentView(this, layoutResId);\r\n    binding.setVariable(BR.vm, viewModel);\r\n    binding.setLifecycleOwner(this);\r\n    viewModel.attachView((MvvmView) this, savedInstanceState);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.MultiUserSettingsPanel.portNumberIsValid",
	"Comment": "determines whether or not a port number is within the range of valid portnumbers.",
	"Method": "boolean portNumberIsValid(String portNumber){\r\n    try {\r\n        int value = Integer.parseInt(portNumber);\r\n        if (value < 0 || value > 65535) {\r\n            return false;\r\n        }\r\n    } catch (NumberFormatException detailsNotImportant) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.volatilityDSP.MemoryDSProcessor.isPanelValid",
	"Comment": "indicates whether the settings in the selection and configuration panelare valid and complete.",
	"Method": "boolean isPanelValid(){\r\n    return configPanel.validatePanel();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestManager.startIngestJob",
	"Comment": "starts an ingest job that will process a collection of data sources.",
	"Method": "IngestJobStartResult startIngestJob(IngestJob job,IngestJob startIngestJob,Collection<Content> dataSources,IngestJobSettings settings){\r\n    return beginIngestJob(dataSources, settings).getJob();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.eventlisteners.IngestEventsListener.getCeModuleInstanceCount",
	"Comment": "whether or not the correlation engine module is enabled for any of thecurrently running ingest jobs.",
	"Method": "int getCeModuleInstanceCount(){\r\n    return correlationModuleInstanceCount;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.datamodel.AbstractAbstractFileNode.createSheet",
	"Comment": "this is called when the node is first initialized. any new updates orchanges happen by directly manipulating the sheet. that means we can fireoff background events everytime this method is called and not worry aboutduplicated jobs.",
	"Method": "Sheet createSheet(){\r\n    Sheet sheet = new Sheet();\r\n    Sheet.Set sheetSet = Sheet.createPropertiesSet();\r\n    sheet.put(sheetSet);\r\n    List<NodeProperty<?>> newProperties = getProperties();\r\n    newProperties.forEach((property) -> {\r\n        sheetSet.put(property);\r\n    });\r\n    translationPool.submit(new TranslationTask(new WeakReference(this), weakPcl));\r\n    return sheet;\r\n}"
}, {
	"Path": "com.mcxiaoke.next.ui.widget.ArrayAdapterCompat.getContext",
	"Comment": "returns the context associated with this array adapter. the context is usedto create views from the resource passed to the constructor.",
	"Method": "Context getContext(){\r\n    return mContext;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.DataSourceIngestJob.shouldProcessUnallocatedSpace",
	"Comment": "queries whether or not unallocated space should be processed as part ofthis job.",
	"Method": "boolean shouldProcessUnallocatedSpace(){\r\n    return this.settings.getProcessUnallocatedSpace();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.CaseMetadata.getTextIndexName",
	"Comment": "gets the text index name. this is a legacy field and will be empty forcases created with autopsy 4.4.0 and above.",
	"Method": "String getTextIndexName(){\r\n    return textIndexName;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.datamodel.FilteredEventsModel.getEventIDsForFile",
	"Comment": "get a list of event ids for the events that are derived from the givenfile.",
	"Method": "List<Long> getEventIDsForFile(AbstractFile file,boolean includeDerivedArtifacts){\r\n    return repo.getEventIDsForFile(file, includeDerivedArtifacts);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.datasourceprocessors.RawDSInputPanel.warnIfPathIsInvalid",
	"Comment": "validates path to selected data source and displays warning if it isinvalid.",
	"Method": "void warnIfPathIsInvalid(String path){\r\n    try {\r\n        if (!PathValidator.isValidForMultiUserCase(path, Case.getCurrentCaseThrows().getCaseType())) {\r\n            errorLabel.setVisible(true);\r\n            errorLabel.setText(Bundle.RawDSInputPanel_error_text());\r\n        }\r\n    } catch (NoCurrentCaseException ex) {\r\n        errorLabel.setVisible(true);\r\n        errorLabel.setText(Bundle.RawDSInputPanel_noOpenCase_errMsg());\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestManager.getFreeDiskSpace",
	"Comment": "gets the free disk space of the drive to which ingest data is beingwritten, as reported by the ingest monitor.",
	"Method": "long getFreeDiskSpace(){\r\n    if (ingestMonitor != null) {\r\n        return ingestMonitor.getFreeSpace();\r\n    } else {\r\n        return -1;\r\n    }\r\n}"
}, {
	"Path": "org.codechimp.apprater.AppRater.setNumLaunchesForRemindLater",
	"Comment": "sets the number of launches until the rating dialog pops up for next timewhen remind me later option is chosen",
	"Method": "void setNumLaunchesForRemindLater(int launchesUntilPrompt){\r\n    LAUNCHES_UNTIL_PROMPT_FOR_REMIND_LATER = launchesUntilPrompt;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.AddImageWizardDataSourceSettingsVisual.setDspSelection",
	"Comment": "set the current datasourceprocessor and update the panel to reflect thatselection.",
	"Method": "void setDspSelection(String dsType){\r\n    currentDsp = dsType;\r\n    currentPanel = datasourceProcessorsMap.get(dsType).getPanel();\r\n    updateCurrentPanel(currentPanel);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.ui.detailview.tree.EventsTreeItem.getTreePath",
	"Comment": "get the tree path from the root event stripe of the given event to thegiven event itself",
	"Method": "List<TimeLineEvent> getTreePath(TimeLineEvent event){\r\n    List<TimeLineEvent> path = new ArrayList();\r\n    path.add(0, event);\r\n    Optional<EventStripe> parentOptional = event.getParentStripe();\r\n    while (parentOptional.isPresent()) {\r\n        EventStripe parent = parentOptional.get();\r\n        path.add(0, parent);\r\n        parentOptional = parent.getParentStripe();\r\n    }\r\n    return path;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestManager.getInstance",
	"Comment": "gets a singleton auto ingest manager responsible for processing autoingest jobs defined by manifest files that can be added to any level of adesignated input directory tree.",
	"Method": "AutoIngestManager getInstance(){\r\n    if (instance == null) {\r\n        instance = new AutoIngestManager();\r\n    }\r\n    return instance;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.RecentCases.refreshRecentCases",
	"Comment": "refresh the current list of cases, removing any cases that no longerexist.",
	"Method": "void refreshRecentCases(){\r\n    List<RecentCase> toDelete = new ArrayList();\r\n    for (RecentCase rc : recentCases) {\r\n        if (!rc.exists()) {\r\n            toDelete.add(rc);\r\n        }\r\n    }\r\n    for (RecentCase deleteMe : toDelete) {\r\n        removeRecentCase(deleteMe.name, deleteMe.path);\r\n    }\r\n}"
}, {
	"Path": "com.mcxiaoke.next.ui.internal.AdapterWrapper.areAllItemsEnabled",
	"Comment": "are all items in this listadapter enabled? if yes itmeans all items are selectable and clickable.",
	"Method": "boolean areAllItemsEnabled(){\r\n    return (wrapped.areAllItemsEnabled());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AddArchiveTask.getListOfValidDataSourceProcessors",
	"Comment": "get a list of data source processors. localfiles, andarchivedsp are removed from the list.",
	"Method": "List<AutoIngestDataSourceProcessor> getListOfValidDataSourceProcessors(){\r\n    Collection<? extends AutoIngestDataSourceProcessor> processorCandidates = Lookup.getDefault().lookupAll(AutoIngestDataSourceProcessor.class);\r\n    List<AutoIngestDataSourceProcessor> validDataSourceProcessors = processorCandidates.stream().collect(Collectors.toList());\r\n    for (Iterator<AutoIngestDataSourceProcessor> iterator = validDataSourceProcessors.iterator(); iterator.hasNext(); ) {\r\n        AutoIngestDataSourceProcessor selectedProcessor = iterator.next();\r\n        if ((selectedProcessor instanceof LocalFilesDSProcessor) || (selectedProcessor instanceof ArchiveExtractorDSProcessor)) {\r\n            iterator.remove();\r\n        }\r\n    }\r\n    return validDataSourceProcessors;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.services.TagNameDialog.enableOkButton",
	"Comment": "enable the ok button if the tag name text field is not empty. sets theenter button as default, so user can press enter to activate an okbuttonpress and add the tag name.",
	"Method": "void enableOkButton(){\r\n    okButton.setEnabled(!tagNameTextField.getText().isEmpty());\r\n    getRootPane().setDefaultButton(okButton);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.eventlisteners.IngestEventsListener.setFlagSeenDevices",
	"Comment": "configure the listener to flag previously seen devices or not.",
	"Method": "void setFlagSeenDevices(boolean value){\r\n    flagSeenDevices = value;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestMetricsCollector.queryCoordinationServiceForMetrics",
	"Comment": "gets a new metrics snapshot from the coordination service for an autoingest cluster.",
	"Method": "MetricsSnapshot queryCoordinationServiceForMetrics(){\r\n    try {\r\n        MetricsSnapshot newMetricsSnapshot = new MetricsSnapshot();\r\n        List<String> nodeList = coordinationService.getNodeList(CoordinationService.CategoryNode.MANIFESTS);\r\n        for (String node : nodeList) {\r\n            try {\r\n                AutoIngestJobNodeData nodeData = new AutoIngestJobNodeData(coordinationService.getNodeData(CoordinationService.CategoryNode.MANIFESTS, node));\r\n                if (nodeData.getVersion() < MINIMUM_SUPPORTED_JOB_NODE_VERSION) {\r\n                    continue;\r\n                }\r\n                AutoIngestJob job = new AutoIngestJob(nodeData);\r\n                AutoIngestJob.ProcessingStatus processingStatus = nodeData.getProcessingStatus();\r\n                switch(processingStatus) {\r\n                    case PENDING:\r\n                    case PROCESSING:\r\n                    case DELETED:\r\n                        break;\r\n                    case COMPLETED:\r\n                        newMetricsSnapshot.addCompletedJobMetric(job.getCompletedDate(), job.getDataSourceSize());\r\n                        break;\r\n                    default:\r\n                        LOGGER.log(Level.SEVERE, \"Unknown AutoIngestJobData.ProcessingStatus\");\r\n                        break;\r\n                }\r\n            } catch (InterruptedException ex) {\r\n                LOGGER.log(Level.SEVERE, String.format(\"Unexpected interrupt while retrieving coordination service node data for '%s'\", node), ex);\r\n            } catch (AutoIngestJobNodeData.InvalidDataException ex) {\r\n                LOGGER.log(Level.SEVERE, String.format(\"Unable to use node data for '%s'\", node), ex);\r\n            } catch (AutoIngestJob.AutoIngestJobException ex) {\r\n                LOGGER.log(Level.SEVERE, String.format(\"Failed to create a job for '%s'\", node), ex);\r\n            }\r\n        }\r\n        return newMetricsSnapshot;\r\n    } catch (CoordinationService.CoordinationServiceException ex) {\r\n        LOGGER.log(Level.SEVERE, \"Failed to get node list from coordination service\", ex);\r\n        return new MetricsSnapshot();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.othercasessearch.CorrelationAttributeInstanceNode.getCorrelationAttributeInstance",
	"Comment": "get the correlationattributeinstance attached to the node.",
	"Method": "CorrelationAttributeInstance getCorrelationAttributeInstance(){\r\n    return this.instance;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestJobContext.getJobId",
	"Comment": "gets the identifier of the ingest job associated with this context.",
	"Method": "long getJobId(){\r\n    return this.ingestJob.getId();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.IntraCasePanel.pictureVideoCheckboxIsSelected",
	"Comment": "if the user has selected selected to show picture and video files as partof the filtered results.",
	"Method": "boolean pictureVideoCheckboxIsSelected(){\r\n    return pictureVideoCheckbox.isEnabled() && pictureVideoCheckbox.isSelected();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.interestingitems.FilesSetRulePanel.populateDateConditionComponents",
	"Comment": "populates the ui components that display the optional date condition fora rule.",
	"Method": "void populateDateConditionComponents(FilesSet.Rule rule){\r\n    FilesSet.Rule.DateCondition dateCondition = rule.getDateCondition();\r\n    if (dateCondition != null) {\r\n        this.dateCheck.setSelected(true);\r\n        this.dateCheckActionPerformed(null);\r\n        this.daysIncludedTextField.setText(Integer.toString(dateCondition.getDaysIncluded()));\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.recentactivity.Firefox.getDownloadPreVersion24",
	"Comment": "finds downloads artifacts from firefox data from versions before 24.0.downloads were stored in a separate downloads database.",
	"Method": "void getDownloadPreVersion24(){\r\n    FileManager fileManager = currentCase.getServices().getFileManager();\r\n    List<AbstractFile> downloadsFiles;\r\n    try {\r\n        downloadsFiles = fileManager.findFiles(dataSource, \"downloads.sqlite\", \"Firefox\");\r\n    } catch (TskCoreException ex) {\r\n        String msg = NbBundle.getMessage(this.getClass(), \"Firefox.getDlPre24.errMsg.errFetchFiles\");\r\n        logger.log(Level.WARNING, msg);\r\n        this.addErrorMessage(this.getName() + \": \" + msg);\r\n        return;\r\n    }\r\n    if (downloadsFiles.isEmpty()) {\r\n        logger.log(Level.INFO, \"Didn't find any pre-version-24.0 Firefox download files.\");\r\n        return;\r\n    }\r\n    dataFound = true;\r\n    Collection<BlackboardArtifact> bbartifacts = new ArrayList();\r\n    int j = 0;\r\n    for (AbstractFile downloadsFile : downloadsFiles) {\r\n        if (downloadsFile.getSize() == 0) {\r\n            continue;\r\n        }\r\n        String fileName = downloadsFile.getName();\r\n        String temps = RAImageIngestModule.getRATempPath(currentCase, \"firefox\") + File.separator + fileName + j + \".db\";\r\n        int errors = 0;\r\n        try {\r\n            ContentUtils.writeToFile(downloadsFile, new File(temps), context::dataSourceIngestIsCancelled);\r\n        } catch (ReadContentInputStreamException ex) {\r\n            logger.log(Level.WARNING, String.format(\"Error reading Firefox download artifacts file '%s' (id=%d).\", fileName, downloadsFile.getId()), ex);\r\n            this.addErrorMessage(NbBundle.getMessage(this.getClass(), \"Firefox.getHistory.errMsg.errAnalyzeFile\", this.getName(), fileName));\r\n            continue;\r\n        } catch (IOException ex) {\r\n            logger.log(Level.SEVERE, String.format(\"Error writing temp sqlite db file '%s' for Firefox download artifacts file '%s' (id=%d).\", temps, fileName, downloadsFile.getId()), ex);\r\n            this.addErrorMessage(NbBundle.getMessage(this.getClass(), \"Firefox.getDlPre24.errMsg.errAnalyzeFiles\", this.getName(), fileName));\r\n            continue;\r\n        }\r\n        File dbFile = new File(temps);\r\n        if (context.dataSourceIngestIsCancelled()) {\r\n            dbFile.delete();\r\n            break;\r\n        }\r\n        List<HashMap<String, Object>> tempList = this.dbConnect(temps, DOWNLOAD_QUERY);\r\n        logger.log(Level.INFO, \"{0}- Now getting downloads from {1} with {2} artifacts identified.\", new Object[] { moduleName, temps, tempList.size() });\r\n        for (HashMap<String, Object> result : tempList) {\r\n            String source = result.get(\"source\").toString();\r\n            Collection<BlackboardAttribute> bbattributes = new ArrayList();\r\n            bbattributes.add(new // NON-NLS\r\n            BlackboardAttribute(// NON-NLS\r\n            ATTRIBUTE_TYPE.TSK_URL, NbBundle.getMessage(this.getClass(), \"Firefox.parentModuleName.noSpace\"), source));\r\n            bbattributes.add(new // NON-NLS\r\n            BlackboardAttribute(// NON-NLS\r\n            ATTRIBUTE_TYPE.TSK_DATETIME_ACCESSED, NbBundle.getMessage(this.getClass(), \"Firefox.parentModuleName.noSpace\"), (Long.valueOf(result.get(\"startTime\").toString()))));\r\n            String target = result.get(\"target\").toString();\r\n            if (target != null) {\r\n                try {\r\n                    String decodedTarget = URLDecoder.decode(target.replaceAll(\"file:///\", \"\"), \"UTF-8\");\r\n                    bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PATH, NbBundle.getMessage(this.getClass(), \"Firefox.parentModuleName.noSpace\"), decodedTarget));\r\n                    long pathID = Util.findID(dataSource, decodedTarget);\r\n                    if (pathID != -1) {\r\n                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PATH_ID, NbBundle.getMessage(this.getClass(), \"Firefox.parentModuleName.noSpace\"), pathID));\r\n                    }\r\n                } catch (UnsupportedEncodingException ex) {\r\n                    logger.log(Level.SEVERE, \"Error decoding Firefox download URL in \" + temps, ex);\r\n                    errors++;\r\n                }\r\n            }\r\n            bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME, NbBundle.getMessage(this.getClass(), \"Firefox.parentModuleName.noSpace\"), NbBundle.getMessage(this.getClass(), \"Firefox.moduleName\")));\r\n            String domain = extractDomain(source);\r\n            if (domain != null && domain.isEmpty() == false) {\r\n                bbattributes.add(new // NON-NLS\r\n                BlackboardAttribute(// NON-NLS\r\n                ATTRIBUTE_TYPE.TSK_DOMAIN, NbBundle.getMessage(this.getClass(), \"Firefox.parentModuleName.noSpace\"), domain));\r\n            }\r\n            BlackboardArtifact bbart = this.addArtifact(ARTIFACT_TYPE.TSK_WEB_DOWNLOAD, downloadsFile, bbattributes);\r\n            if (bbart != null) {\r\n                bbartifacts.add(bbart);\r\n            }\r\n        }\r\n        if (errors > 0) {\r\n            this.addErrorMessage(NbBundle.getMessage(this.getClass(), \"Firefox.getDlPre24.errMsg.errParsingArtifacts\", this.getName(), errors));\r\n        }\r\n        j++;\r\n        dbFile.delete();\r\n        break;\r\n    }\r\n    services.fireModuleDataEvent(new ModuleDataEvent(NbBundle.getMessage(this.getClass(), \"Firefox.parentModuleName\"), BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_DOWNLOAD, bbartifacts));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.AbstractSqlEamDb.newCase",
	"Comment": "creates new case in the databaseexpects the organization for this case to already exist in the database.",
	"Method": "CorrelationCase newCase(CorrelationCase eamCase,CorrelationCase newCase,Case autopsyCase){\r\n    if (autopsyCase == null) {\r\n        throw new EamDbException(\"Case is null\");\r\n    }\r\n    CorrelationCase curCeCase = new // unique case ID\r\n    CorrelationCase(-1, autopsyCase.getName(), EamOrganization.getDefault(), autopsyCase.getDisplayName(), autopsyCase.getCreatedDate(), autopsyCase.getNumber(), autopsyCase.getExaminer(), autopsyCase.getExaminerEmail(), autopsyCase.getExaminerPhone(), autopsyCase.getCaseNotes());\r\n    return newCase(curCeCase);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.filetypeid.AddFileTypePanel.addTypeListSelectionListener",
	"Comment": "adds the selection listener to the list so that actions are taken basedon whether or not an item in the list of signatures is selected.",
	"Method": "void addTypeListSelectionListener(){\r\n    this.signatureList.addListSelectionListener(new ListSelectionListener() {\r\n        @Override\r\n        public void valueChanged(ListSelectionEvent e) {\r\n            if (e.getValueIsAdjusting() == false) {\r\n                enableButtons();\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.filetypeid.AddFileTypePanel.addTypeListSelectionListener",
	"Comment": "adds the selection listener to the list so that actions are taken basedon whether or not an item in the list of signatures is selected.",
	"Method": "void addTypeListSelectionListener(){\r\n    if (e.getValueIsAdjusting() == false) {\r\n        enableButtons();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestControlPanel.startUp",
	"Comment": "starts up the auto ingest manager and adds this panel as an observer,subscribes to services monitor events and starts a task to populate theauto ingest job tables. the refresh and pause buttons are enabled.",
	"Method": "void startUp(){\r\n    try {\r\n        manager.startUp();\r\n        autoIngestStarted = true;\r\n    } catch (AutoIngestManager.AutoIngestManagerException ex) {\r\n        sysLogger.log(Level.SEVERE, \"Dashboard error starting up auto ingest\", ex);\r\n        tbStatusMessage.setText(NbBundle.getMessage(AutoIngestControlPanel.class, \"AutoIngestControlPanel.AutoIngestStartupError\"));\r\n        manager = null;\r\n        JOptionPane.showMessageDialog(this, NbBundle.getMessage(AutoIngestControlPanel.class, \"AutoIngestControlPanel.AutoIngestStartupFailed.Message\"), NbBundle.getMessage(AutoIngestControlPanel.class, \"AutoIngestControlPanel.AutoIngestStartupFailed.Title\"), JOptionPane.ERROR_MESSAGE);\r\n        bnOptions.setEnabled(true);\r\n        return;\r\n    }\r\n    PropertyChangeListener propChangeListener = (PropertyChangeEvent evt) -> {\r\n        String serviceDisplayName = ServicesMonitor.Service.valueOf(evt.getPropertyName()).toString();\r\n        String status = evt.getNewValue().toString();\r\n        if (status.equals(ServicesMonitor.ServiceStatus.UP.toString())) {\r\n            status = NbBundle.getMessage(AutoIngestControlPanel.class, \"AutoIngestControlPanel.tbServicesStatusMessage.Message.Up\");\r\n        } else if (status.equals(ServicesMonitor.ServiceStatus.DOWN.toString())) {\r\n            status = NbBundle.getMessage(AutoIngestControlPanel.class, \"AutoIngestControlPanel.tbServicesStatusMessage.Message.Down\");\r\n            sysLogger.log(Level.SEVERE, \"Connection to {0} is down\", serviceDisplayName);\r\n        }\r\n        if (statusByService.containsKey(serviceDisplayName) && status.equals(statusByService.get(serviceDisplayName))) {\r\n            return;\r\n        }\r\n        statusByService.put(serviceDisplayName, status);\r\n        displayServicesStatus();\r\n    };\r\n    Set<String> servicesList = new HashSet();\r\n    servicesList.add(ServicesMonitor.Service.REMOTE_CASE_DATABASE.toString());\r\n    servicesList.add(ServicesMonitor.Service.REMOTE_KEYWORD_SEARCH.toString());\r\n    servicesList.add(ServicesMonitor.Service.MESSAGING.toString());\r\n    ServicesMonitor.getInstance().addSubscriber(servicesList, propChangeListener);\r\n    manager.addObserver(this);\r\n    updateExecutor = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder().setNameFormat(UPDATE_TASKS_THREAD_NAME).build());\r\n    updateExecutor.submit(new UpdateAllJobsTablesTask());\r\n    manager.scanInputDirsNow();\r\n    bnPause.setText(org.openide.util.NbBundle.getMessage(AutoIngestControlPanel.class, \"AutoIngestControlPanel.bnPause.text\"));\r\n    bnPause.setToolTipText(org.openide.util.NbBundle.getMessage(AutoIngestControlPanel.class, \"AutoIngestControlPanel.bnPause.toolTipText\"));\r\n    bnRefresh.setEnabled(true);\r\n    bnOptions.setEnabled(false);\r\n    tbStatusMessage.setText(org.openide.util.NbBundle.getMessage(AutoIngestControlPanel.class, \"AutoIngestControlPanel.bnPause.running\"));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilessearch.InterCaseTestUtils.createCases",
	"Comment": "create the cases defined by casenames and casedatasourcepaths and ingesteach with the given settings. null settings are permitted but ingestutilswill not be run.the length of casenames and casedatasourcepaths should be the same, andcases should appear in the same order.",
	"Method": "Case createCases(String[] caseNames,Path[][] caseDataSourcePaths,IngestJobSettings ingestJobSettings,String caseReferenceToStore){\r\n    Case currentCase = null;\r\n    if (caseNames.length != caseDataSourcePaths.length) {\r\n        Assert.fail(new IllegalArgumentException(\"caseReferenceToStore should be one of the values given in the 'cases' parameter.\").getMessage());\r\n    }\r\n    String lastCaseName = null;\r\n    Path[] lastPathsForCase = null;\r\n    for (int i = 0; i < caseNames.length; i++) {\r\n        String caseName = caseNames[i];\r\n        Path[] pathsForCase = caseDataSourcePaths[i];\r\n        if (caseName.equals(caseReferenceToStore)) {\r\n            lastCaseName = caseName;\r\n            lastPathsForCase = pathsForCase;\r\n        } else {\r\n            this.createCase(caseName, ingestJobSettings, false, pathsForCase);\r\n        }\r\n    }\r\n    if (lastCaseName != null && lastPathsForCase != null) {\r\n        currentCase = this.createCase(lastCaseName, ingestJobSettings, true, lastPathsForCase);\r\n    }\r\n    if (currentCase == null) {\r\n        Assert.fail(new IllegalArgumentException(\"caseReferenceToStore should be one of the values given in the 'cases' parameter.\").getMessage());\r\n        return null;\r\n    } else {\r\n        return currentCase;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.filesearch.DataSourcePanel.setComponentsEnabled",
	"Comment": "enable the dslist and datasourcenotelable if the datasourcecheckbox ischecked.",
	"Method": "void setComponentsEnabled(){\r\n    boolean enabled = this.isSelected();\r\n    this.dataSourceList.setEnabled(enabled);\r\n    this.dataSourceNoteLabel.setEnabled(enabled);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.datamodel.EmailExtracted.parsePath",
	"Comment": "parse the path of the email msg to get the account name and folder inwhich the email is contained.",
	"Method": "Map<String, String> parsePath(String path){\r\n    Map<String, String> parsed = new HashMap();\r\n    String[] split = path.split(MAIL_PATH_SEPARATOR);\r\n    if (split.length < 4) {\r\n        parsed.put(MAIL_ACCOUNT, NbBundle.getMessage(EmailExtracted.class, \"EmailExtracted.defaultAcct.text\"));\r\n        parsed.put(MAIL_FOLDER, NbBundle.getMessage(EmailExtracted.class, \"EmailExtracted.defaultFolder.text\"));\r\n        return parsed;\r\n    }\r\n    parsed.put(MAIL_ACCOUNT, split[2]);\r\n    parsed.put(MAIL_FOLDER, split[3]);\r\n    return parsed;\r\n}"
}, {
	"Path": "com.aliyun.oss.common.provider.TestBase.unsetEnv",
	"Comment": "remove the specified variables from the current map of environmentvariables.",
	"Method": "void unsetEnv(List<String> vars){\r\n    try {\r\n        Class<?> processEnvironmentClass = Class.forName(\"java.lang.ProcessEnvironment\");\r\n        Field theEnvironmentField = processEnvironmentClass.getDeclaredField(\"theEnvironment\");\r\n        theEnvironmentField.setAccessible(true);\r\n        Map<String, String> env = (Map<String, String>) theEnvironmentField.get(null);\r\n        for (String v : vars) {\r\n            env.remove(v);\r\n        }\r\n        Field theCaseInsensitiveEnvironmentField = processEnvironmentClass.getDeclaredField(\"theCaseInsensitiveEnvironment\");\r\n        theCaseInsensitiveEnvironmentField.setAccessible(true);\r\n        Map<String, String> cienv = (Map<String, String>) theCaseInsensitiveEnvironmentField.get(null);\r\n        for (String v : vars) {\r\n            cienv.remove(v);\r\n        }\r\n    } catch (NoSuchFieldException e) {\r\n        try {\r\n            Class[] classes = Collections.class.getDeclaredClasses();\r\n            Map<String, String> env = System.getenv();\r\n            for (Class cl : classes) {\r\n                if (\"java.util.Collections$UnmodifiableMap\".equals(cl.getName())) {\r\n                    Field field = cl.getDeclaredField(\"m\");\r\n                    field.setAccessible(true);\r\n                    Object obj = field.get(env);\r\n                    Map<String, String> map = (Map<String, String>) obj;\r\n                    for (String v : vars) {\r\n                        map.remove(v);\r\n                    }\r\n                }\r\n            }\r\n        } catch (Exception e2) {\r\n            e2.printStackTrace();\r\n        }\r\n    } catch (Exception e1) {\r\n        e1.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.test.CustomArtifactsCreatorDataSourceIngestModule.startUp",
	"Comment": "adds the custom artifact type this module uses to the case database ofthe current case.",
	"Method": "void startUp(IngestJobContext context){\r\n    try {\r\n        CustomArtifactType.addToCaseDatabase();\r\n    } catch (Blackboard.BlackboardException | NoCurrentCaseException ex) {\r\n        throw new IngestModuleException(Bundle.CustomArtifactsCreatorDataSourceIngestModule_exceptionMessage_errorCreatingCustomType(), ex);\r\n    }\r\n}"
}, {
	"Path": "com.anysoftkeyboard.dictionaries.Suggest.getNextSuggestions",
	"Comment": "returns a list of suggested next words for the given typed word",
	"Method": "List<CharSequence> getNextSuggestions(CharSequence previousWord,boolean inAllUpperCaseState){\r\n    if (previousWord.length() < mMinimumWordLengthToStartCorrecting) {\r\n        return Collections.emptyList();\r\n    }\r\n    mNextSuggestions.clear();\r\n    mIsAllUpperCase = inAllUpperCaseState;\r\n    if (isValidWord(previousWord)) {\r\n        final String currentWord = previousWord.toString().toLowerCase(mLocale);\r\n        mSuggestionsProvider.getNextWords(currentWord, mNextSuggestions, mPrefMaxSuggestions);\r\n        if (BuildConfig.DEBUG) {\r\n            Logger.d(TAG, \"getNextSuggestions from user-dictionary for '%s' (capital? %s):\", previousWord, mIsAllUpperCase);\r\n            for (int suggestionIndex = 0; suggestionIndex < mNextSuggestions.size(); suggestionIndex++) {\r\n                Logger.d(TAG, \"* getNextSuggestions #%d :''%s'\", suggestionIndex, mNextSuggestions.get(suggestionIndex));\r\n            }\r\n        }\r\n        if (mIsAllUpperCase) {\r\n            for (int suggestionIndex = 0; suggestionIndex < mNextSuggestions.size(); suggestionIndex++) {\r\n                mNextSuggestions.set(suggestionIndex, mNextSuggestions.get(suggestionIndex).toString().toUpperCase(mLocale));\r\n            }\r\n        }\r\n    } else {\r\n        Logger.d(TAG, \"getNextSuggestions for '%s' is invalid.\");\r\n    }\r\n    return mNextSuggestions;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.CommonAttributeValueNode.getCommonFileCount",
	"Comment": "how many files are in common?this will be the number of children.",
	"Method": "int getCommonFileCount(){\r\n    return this.commonFileCount;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagewriter.ImageWriter.unsubscribeFromEvents",
	"Comment": "deregister this object from the events. this is ok to call multiple times.",
	"Method": "void unsubscribeFromEvents(){\r\n    IngestManager.getInstance().removeIngestJobEventListener(this);\r\n}"
}, {
	"Path": "com.badlogic.ashley.signals.Signal.dispatch",
	"Comment": "dispatches an event to all listeners registered to this signal",
	"Method": "void dispatch(T object){\r\n    final Object[] items = listeners.begin();\r\n    for (int i = 0, n = listeners.size; i < n; i++) {\r\n        Listener<T> listener = (Listener<T>) items[i];\r\n        listener.receive(this, object);\r\n    }\r\n    listeners.end();\r\n}"
}, {
	"Path": "org.wikipedia.page.Page.isFromRestBase",
	"Comment": "this could also be called getversion but since there are only two different versionsi like to call it isfromrestbase to make it clearer.",
	"Method": "boolean isFromRestBase(){\r\n    return version == RESTBASE_ORIGIN;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.hashdatabase.HashDbSearchPanel.refresh",
	"Comment": "check if ingest is currently running and refresh the panel accordingly.",
	"Method": "void refresh(){\r\n    boolean running = IngestManager.getInstance().isIngestRunning();\r\n    if (running) {\r\n        titleLabel.setForeground(Color.red);\r\n        titleLabel.setText(NbBundle.getMessage(this.getClass(), \"HashDbSearchPanel.titleText.ingestOngoing\"));\r\n    } else {\r\n        titleLabel.setForeground(Color.black);\r\n        titleLabel.setText(NbBundle.getMessage(this.getClass(), \"HashDbSearchPanel.titleLabel.text\"));\r\n    }\r\n    hashField.setEditable(!running);\r\n    searchButton.setEnabled(!running);\r\n    addButton.setEnabled(!running);\r\n    removeButton.setEnabled(!running);\r\n    hashTable.setEnabled(!running);\r\n    hashLabel.setEnabled(!running);\r\n    saveBox.setEnabled(!running);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.Keyword.getSearchTerm",
	"Comment": "gets the search term for the keyword, which may be either a literal termor a regex.",
	"Method": "String getSearchTerm(){\r\n    return searchTerm;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.AbstractSqlEamDb.getReferenceSetOrganization",
	"Comment": "get the organization associated with the given reference set.",
	"Method": "EamOrganization getReferenceSetOrganization(int referenceSetID){\r\n    EamGlobalSet globalSet = getReferenceSetByID(referenceSetID);\r\n    if (globalSet == null) {\r\n        throw new EamDbException(\"Reference set with ID \" + referenceSetID + \" not found\");\r\n    }\r\n    return (getOrganizationByID(globalSet.getOrgID()));\r\n}"
}, {
	"Path": "com.aliyun.oss.internal.ResponseParsers.parseGetBucketReplicationProgress",
	"Comment": "unmarshall get bucket replication response body to replication progress.",
	"Method": "BucketReplicationProgress parseGetBucketReplicationProgress(InputStream responseBody){\r\n    try {\r\n        BucketReplicationProgress progress = new BucketReplicationProgress();\r\n        Element root = getXmlRootElement(responseBody);\r\n        Element ruleElem = root.getChild(\"Rule\");\r\n        progress.setReplicationRuleID(ruleElem.getChildText(\"ID\"));\r\n        Element destination = ruleElem.getChild(\"Destination\");\r\n        progress.setTargetBucketName(destination.getChildText(\"Bucket\"));\r\n        progress.setTargetBucketLocation(destination.getChildText(\"Location\"));\r\n        progress.setTargetCloud(destination.getChildText(\"Cloud\"));\r\n        progress.setTargetCloudLocation(destination.getChildText(\"CloudLocation\"));\r\n        progress.setReplicationStatus(ReplicationStatus.parse(ruleElem.getChildText(\"Status\")));\r\n        if (ruleElem.getChildText(\"HistoricalObjectReplication\").equals(\"enabled\")) {\r\n            progress.setEnableHistoricalObjectReplication(true);\r\n        } else {\r\n            progress.setEnableHistoricalObjectReplication(false);\r\n        }\r\n        Element progressElem = ruleElem.getChild(\"Progress\");\r\n        if (progressElem != null) {\r\n            if (progressElem.getChild(\"HistoricalObject\") != null) {\r\n                progress.setHistoricalObjectProgress(Float.parseFloat(progressElem.getChildText(\"HistoricalObject\")));\r\n            }\r\n            progress.setNewObjectProgress(DateUtil.parseIso8601Date(progressElem.getChildText(\"NewObject\")));\r\n        }\r\n        return progress;\r\n    } catch (JDOMParseException e) {\r\n        throw new ResponseParseException(e.getPartialDocument() + \": \" + e.getMessage(), e);\r\n    } catch (Exception e) {\r\n        throw new ResponseParseException(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.ui.detailview.DetailViewPane.setHighLightedEvents",
	"Comment": "observe the list of events that should be highlighted in this view.",
	"Method": "void setHighLightedEvents(ObservableList<TimeLineEvent> highlightedEvents){\r\n    highlightedEvents.addListener((Observable observable) -> {\r\n        // => events\r\n        Predicate<EventNodeBase<?>> highlightPredicate = // => event descriptions\r\n        highlightedEvents.stream().map(TimeLineEvent::getDescription).map(new Function<String, Predicate<EventNodeBase<?>>>() {\r\n            @Override\r\n            public Predicate<EventNodeBase<?>> apply(String description) {\r\n                return eventNode -> StringUtils.equalsIgnoreCase(eventNode.getDescription(), description);\r\n            }\r\n        }).reduce(getSelectedNodes()::contains, Predicate::or);\r\n        getChart().setHighlightPredicate(highlightPredicate);\r\n    });\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.ui.detailview.DetailViewPane.setHighLightedEvents",
	"Comment": "observe the list of events that should be highlighted in this view.",
	"Method": "void setHighLightedEvents(ObservableList<TimeLineEvent> highlightedEvents){\r\n    return eventNode -> StringUtils.equalsIgnoreCase(eventNode.getDescription(), description);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.eventlisteners.IngestEventsListener.installListeners",
	"Comment": "add all of our ingest event listeners to the ingestmanager instance.",
	"Method": "void installListeners(){\r\n    IngestManager.getInstance().addIngestModuleEventListener(pcl1);\r\n    IngestManager.getInstance().addIngestJobEventListener(pcl2);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.HighlightedText.attemptManualHighlighting",
	"Comment": "if the solr query does not produce valid highlighting, we attempt to addthe highlighting ourselves. we do this by taking the text returned fromthe document that contains a hit and searching that text for the keywordthat produced the hit.",
	"Method": "String attemptManualHighlighting(SolrDocumentList solrDocumentList,String highlightField,Collection<String> keywords){\r\n    if (solrDocumentList.isEmpty()) {\r\n        return Bundle.IndexedText_errorMessage_errorGettingText();\r\n    }\r\n    String text = solrDocumentList.get(0).getOrDefault(highlightField, \"\").toString();\r\n    text = StringEscapeUtils.escapeHtml(text);\r\n    TreeRangeSet<Integer> highlights = TreeRangeSet.create();\r\n    for (String keyword : keywords) {\r\n        final String escapedKeyword = StringEscapeUtils.escapeHtml(keyword);\r\n        int searchOffset = 0;\r\n        int hitOffset = StringUtils.indexOfIgnoreCase(text, escapedKeyword, searchOffset);\r\n        while (hitOffset != -1) {\r\n            searchOffset = hitOffset + escapedKeyword.length();\r\n            highlights.add(Range.closedOpen(hitOffset, searchOffset));\r\n            hitOffset = StringUtils.indexOfIgnoreCase(text, escapedKeyword, searchOffset);\r\n        }\r\n    }\r\n    StringBuilder highlightedText = new StringBuilder(text);\r\n    int totalHighLightLengthInserted = 0;\r\n    for (Range<Integer> highlightRange : highlights.asRanges()) {\r\n        int hStart = highlightRange.lowerEndpoint();\r\n        int hEnd = highlightRange.upperEndpoint();\r\n        highlightedText.insert(hStart + totalHighLightLengthInserted, HIGHLIGHT_PRE);\r\n        totalHighLightLengthInserted += HIGHLIGHT_PRE.length();\r\n        highlightedText.insert(hEnd + totalHighLightLengthInserted, HIGHLIGHT_POST);\r\n        totalHighLightLengthInserted += HIGHLIGHT_POST.length();\r\n    }\r\n    return highlightedText.toString();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.KeywordSearch.getServer",
	"Comment": "get an instance of keywordsearch server to execute queries on content,getting extracted text, performing searches, etc.",
	"Method": "Server getServer(){\r\n    if (server == null) {\r\n        server = new Server();\r\n    }\r\n    return server;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.Case.getPropertyChangeSupport",
	"Comment": "gets a propertychangesupport object. the propertychangesupport objectreturned is not used by instances of this class and does not have anypropertychangelisteners.",
	"Method": "PropertyChangeSupport getPropertyChangeSupport(){\r\n    return new PropertyChangeSupport(Case.class);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.configuration.AutoIngestUserPreferences.getSharedConfigEnabled",
	"Comment": "get shared config checkbox state for automated mode from persistentstorage.",
	"Method": "Boolean getSharedConfigEnabled(){\r\n    return Boolean.parseBoolean(getPreferenceValue(SHARED_CONFIG_ENABLED));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.hashdatabase.HashDbManager.loadLastSavedConfiguration",
	"Comment": "restores the last saved hash sets configuration. this supportscancellation of configuration panels.",
	"Method": "void loadLastSavedConfiguration(){\r\n    closeHashDatabases(this.hashSets);\r\n    hashSetNames.clear();\r\n    hashSetPaths.clear();\r\n    loadHashsetsConfiguration();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.NewCaseWizardPanel1.getHelp",
	"Comment": "gets the help object for this panel. when the panel is active, this isused as the help for the wizard dialog.",
	"Method": "HelpCtx getHelp(){\r\n    return HelpCtx.DEFAULT_HELP;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.encryptiondetection.EncryptionDetectionFileIngestModule.isFileEncryptionSuspected",
	"Comment": "this method checks if the abstractfile input is encrypted. it must meetfile size requirements before its entropy is calculated. if the entropyresult meets the minimum entropy value set, the file will be consideredto be possibly encrypted.",
	"Method": "boolean isFileEncryptionSuspected(AbstractFile file){\r\n    boolean possiblyEncrypted = false;\r\n    boolean fileSizeQualified = false;\r\n    String fileExtension = file.getNameExtension();\r\n    long contentSize = file.getSize();\r\n    if (fileExtension.equalsIgnoreCase(DATABASE_FILE_EXTENSION)) {\r\n        if (contentSize >= MINIMUM_DATABASE_FILE_SIZE) {\r\n            fileSizeQualified = true;\r\n        }\r\n    } else if (contentSize >= minimumFileSize) {\r\n        if (!fileSizeMultipleEnforced || (contentSize % FILE_SIZE_MODULUS) == 0) {\r\n            fileSizeQualified = true;\r\n        }\r\n    }\r\n    if (fileSizeQualified) {\r\n        calculatedEntropy = EncryptionDetectionTools.calculateEntropy(file);\r\n        if (calculatedEntropy >= minimumEntropy) {\r\n            possiblyEncrypted = true;\r\n        }\r\n    }\r\n    return possiblyEncrypted;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestTasksScheduler.removeTasksForJob",
	"Comment": "removes all of the ingest tasks associated with a data source ingest jobfrom a tasks collection.",
	"Method": "void removeTasksForJob(Collection<? extends IngestTask> tasks,long jobId){\r\n    Iterator<? extends IngestTask> iterator = tasks.iterator();\r\n    while (iterator.hasNext()) {\r\n        IngestTask task = iterator.next();\r\n        if (task.getIngestJob().getId() == jobId) {\r\n            iterator.remove();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.OpenTimelineAction.showFileInTimeline",
	"Comment": "open the timeline window with the given file selected in listview. theuser will be prompted to choose which timestamp to use for the file, andhow much time to show around it.",
	"Method": "void showFileInTimeline(AbstractFile file){\r\n    showTimeline(file, null);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.filetypeid.AddFileTypePanel.setComponentValues",
	"Comment": "sets the values of the ui components according to the file type given.",
	"Method": "void setComponentValues(FileType toEdit){\r\n    this.mimeTypeTextField.setText(toEdit.getMimeType());\r\n    for (Signature sig : toEdit.getSignatures()) {\r\n        this.signaturesListModel.addElement(sig);\r\n    }\r\n    this.postHitCheckBox.setSelected(toEdit.shouldCreateInterestingFileHit());\r\n    this.setNameTextField.setEnabled(toEdit.shouldCreateInterestingFileHit());\r\n    this.setNameTextField.setText(toEdit.getInterestingFilesSetName());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.optionspanel.CaseDataSourcesWrapper.getDataSources",
	"Comment": "get the list of correlationdatasources associated with thecorrelationcase.",
	"Method": "List<CorrelationDataSource> getDataSources(){\r\n    return Collections.unmodifiableList(dataSources);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.SortChooser.addCriterionChooser",
	"Comment": "add a chooser populated with the property and sort order of the givencriterion to this dialog.",
	"Method": "void addCriterionChooser(SortCriterion criterion){\r\n    final CriterionChooser chooser = new CriterionChooser(criterion, availableProps, this::removeCriterionChooser);\r\n    choosers.add(chooser);\r\n    scrollContent.add(chooser);\r\n    revalidate();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagewriter.ImageWriter.subscribeToEvents",
	"Comment": "add this imagewriter object as a listener to the necessary events",
	"Method": "void subscribeToEvents(){\r\n    IngestManager.getInstance().addIngestJobEventListener(this);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.QueryResults.addResult",
	"Comment": "adds the keyword hits for a keyword to the hits that are stored in thisobject. all calls to this method must be completed before calling theprocess method.",
	"Method": "void addResult(Keyword keyword,List<KeywordHit> hits){\r\n    results.put(keyword, hits);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.DataSourceIngestJob.startUpIngestPipelines",
	"Comment": "starts up each of the ingest pipelines for this job to collect any fileand data source level ingest modules errors that might occur.",
	"Method": "List<IngestModuleError> startUpIngestPipelines(){\r\n    List<IngestModuleError> errors = new ArrayList();\r\n    errors.addAll(this.firstStageDataSourceIngestPipeline.startUp());\r\n    errors.addAll(this.secondStageDataSourceIngestPipeline.startUp());\r\n    if (errors.isEmpty()) {\r\n        for (FileIngestPipeline pipeline : this.fileIngestPipelinesQueue) {\r\n            errors.addAll(pipeline.startUp());\r\n            if (!errors.isEmpty()) {\r\n                while (!this.fileIngestPipelinesQueue.isEmpty()) {\r\n                    FileIngestPipeline startedPipeline = this.fileIngestPipelinesQueue.poll();\r\n                    if (startedPipeline.isRunning()) {\r\n                        List<IngestModuleError> shutDownErrors = startedPipeline.shutDown();\r\n                        if (!shutDownErrors.isEmpty()) {\r\n                            logIngestModuleErrors(shutDownErrors);\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return errors;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.fileextmismatch.FileExtMismatchDetectorModuleSettings.skipFilesWithNoExtension",
	"Comment": "gets the flag indicating whether or not files without extensions shouldbe skipped during file extension mismatch checking.",
	"Method": "boolean skipFilesWithNoExtension(){\r\n    return skipFilesWithNoExtension;\r\n}"
}, {
	"Path": "com.aliyun.oss.model.UploadPartCopyRequest.getPartNumber",
	"Comment": "gets the part number. for every part uploading, it has a part numberwhich is in 1 to 10000 range. given the upload id, the part numberidentified the part and its position in the target file. if uploading thepart with an existing part number, the existing part with the part numberwould be overwritten.",
	"Method": "int getPartNumber(){\r\n    return partNumber;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJob.setCompletedDate",
	"Comment": "sets the date the job was completed, with or without cancellation orerrors.",
	"Method": "void setCompletedDate(Date completedDate){\r\n    this.completedDate = new Date(completedDate.getTime());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.db.EventDB.addTag",
	"Comment": "mark any events with the given object and artifact ids as tagged, andrecord the tag it self.",
	"Method": "Set<Long> addTag(long objectID,Long artifactID,Tag tag,EventTransaction transaction){\r\n    if (transaction != null && transaction.isClosed()) {\r\n        throw new IllegalArgumentException(\"can't update database with closed transaction\");\r\n    }\r\n    DBLock.lock();\r\n    try {\r\n        Set<Long> eventIDs = markEventsTagged(objectID, artifactID, true);\r\n        for (Long eventID : eventIDs) {\r\n            insertTag(tag, eventID);\r\n        }\r\n        return eventIDs;\r\n    } catch (SQLException ex) {\r\n        LOGGER.log(Level.SEVERE, \"failed to add tag to event\", ex);\r\n    } finally {\r\n        DBLock.unlock();\r\n    }\r\n    return Collections.emptySet();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.encryptiondetection.EncryptionDetectionDataSourceIngestModule.isVolumeEncrypted",
	"Comment": "this method checks if the volume input is encrypted. initialqualifications require that the volume not have a file system.",
	"Method": "boolean isVolumeEncrypted(Volume volume){\r\n    if (volume.getFileSystems().isEmpty()) {\r\n        calculatedEntropy = EncryptionDetectionTools.calculateEntropy(volume);\r\n        if (calculatedEntropy >= minimumEntropy) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.ResultViewerPersistence.getColumnSortRankKey",
	"Comment": "gets a key for the given node and a property of its child nodes to storethe sort rank into a preference file.",
	"Method": "String getColumnSortRankKey(TableFilterNode node,String propName){\r\n    return getColumnKeyBase(node, propName) + \".sortRank\";\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.TableFilterNode.getDisplayName",
	"Comment": "gets the display name for the wrapped node, for use in the first columnof an autopsy table view.",
	"Method": "String getDisplayName(){\r\n    if (this.forceUseWrappedDisplayName) {\r\n        return super.getDisplayName();\r\n    } else if (createChildren) {\r\n        return NbBundle.getMessage(this.getClass(), \"TableFilterNode.displayName.text\");\r\n    } else {\r\n        return super.getDisplayName();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.datamodel.VolumeNode.nameForVolume",
	"Comment": "helper so that the display name and the name used in building the pathare determined the same way.",
	"Method": "String nameForVolume(Volume vol){\r\n    return \"vol\" + Long.toString(vol.getAddr());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.interestingitems.FilesIdentifierIngestJobSettings.interestingFilesSetIsEnabled",
	"Comment": "determines whether or not an interesting files set definition is enabledfor an ingest job. if there is no setting for the requested files set, itis deemed to be enabled.",
	"Method": "boolean interestingFilesSetIsEnabled(String filesSetName){\r\n    return !(this.disabledFilesSetNames.contains(filesSetName));\r\n}"
}, {
	"Path": "net.ypresto.androidtranscoder.utils.ISO6709LocationParser.parse",
	"Comment": "this method parses the given string representing a geographic point location by coordinates in iso 6709 formatand returns the latitude and the longitude in float. if location is not in iso 6709 format,this method returns null",
	"Method": "float[] parse(String location){\r\n    if (location == null)\r\n        return null;\r\n    Matcher m = pattern.matcher(location);\r\n    if (m.find() && m.groupCount() == 2) {\r\n        String latstr = m.group(1);\r\n        String lonstr = m.group(2);\r\n        try {\r\n            float lat = Float.parseFloat(latstr);\r\n            float lon = Float.parseFloat(lonstr);\r\n            return new float[] { lat, lon };\r\n        } catch (NumberFormatException ignored) {\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.douban.frodo.baseproject.adapter.ArrayAdapterCompat2.getContext",
	"Comment": "returns the context associated with this array adapter. the context is usedto create views from the resource passed to the constructor.",
	"Method": "Context getContext(){\r\n    return mContext;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.DataSourceIngestJob.updateDataSourceIngestProgressBarDisplayName",
	"Comment": "updates the display name shown on the current data source level ingestprogress bar for this job.",
	"Method": "void updateDataSourceIngestProgressBarDisplayName(String displayName){\r\n    if (this.doUI && !this.cancelled) {\r\n        synchronized (this.dataSourceIngestProgressLock) {\r\n            this.dataSourceIngestProgress.setDisplayName(displayName);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.TableFilterChildrenWithDescendants.createInstance",
	"Comment": "factory method for getting an instance of the children object based on the node with children, and the number of subsequent generations.",
	"Method": "Children createInstance(Node wrappedNode,int childLayerDepth){\r\n    if (childLayerDepth == 0) {\r\n        return Children.LEAF;\r\n    } else {\r\n        return new TableFilterChildrenWithDescendants(wrappedNode, childLayerDepth - 1);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestTasksScheduler.scheduleIngestTasks",
	"Comment": "schedules a data source level ingest task and zero to many file levelingest tasks for a data source ingest job.",
	"Method": "void scheduleIngestTasks(DataSourceIngestJob job){\r\n    if (!job.isCancelled()) {\r\n        this.scheduleDataSourceIngestTask(job);\r\n        this.scheduleFileIngestTasks(job, Collections.emptyList());\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.embeddedfileextractor.MSOfficeEmbeddedContentExtractor.extractEmbeddedContent",
	"Comment": "this method selects the appropriate process of extracting embeddedcontent from files using either tika or poi classes. once the content hasbeen extracted as files, the method adds them to the db and fires amodulecontentevent. modulecontent event is not fired if no content wasextracted from the processed file.",
	"Method": "void extractEmbeddedContent(AbstractFile abstractFile){\r\n    List<ExtractedFile> listOfExtractedImages = null;\r\n    List<AbstractFile> listOfExtractedImageAbstractFiles = null;\r\n    this.parentFileName = EmbeddedFileExtractorIngestModule.getUniqueName(abstractFile);\r\n    try {\r\n        if (abstractFile.hasChildren()) {\r\n            if (new File(getOutputFolderPath(parentFileName)).exists()) {\r\n                LOGGER.log(Level.INFO, \"File already has been processed as it has children and local unpacked file, skipping: {0}\", abstractFile.getName());\r\n                return;\r\n            }\r\n        }\r\n    } catch (TskCoreException e) {\r\n        LOGGER.log(Level.SEVERE, String.format(\"Error checking if file already has been processed, skipping: %s\", parentFileName), e);\r\n        return;\r\n    }\r\n    switch(abstractFileExtractionFormat) {\r\n        case DOCX:\r\n        case PPTX:\r\n        case XLSX:\r\n            listOfExtractedImages = extractEmbeddedContentFromOOXML(abstractFile);\r\n            break;\r\n        case DOC:\r\n            listOfExtractedImages = extractEmbeddedImagesFromDoc(abstractFile);\r\n            break;\r\n        case PPT:\r\n            listOfExtractedImages = extractEmbeddedImagesFromPpt(abstractFile);\r\n            break;\r\n        case XLS:\r\n            listOfExtractedImages = extractImagesFromXls(abstractFile);\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n    if (listOfExtractedImages == null) {\r\n        return;\r\n    }\r\n    listOfExtractedImageAbstractFiles = new ArrayList();\r\n    for (ExtractedFile extractedImage : listOfExtractedImages) {\r\n        try {\r\n            listOfExtractedImageAbstractFiles.add(fileManager.addDerivedFile(extractedImage.getFileName(), extractedImage.getLocalPath(), extractedImage.getSize(), extractedImage.getCtime(), extractedImage.getCrtime(), extractedImage.getAtime(), extractedImage.getAtime(), true, abstractFile, null, EmbeddedFileExtractorModuleFactory.getModuleName(), null, null, TskData.EncodingType.XOR1));\r\n        } catch (TskCoreException ex) {\r\n            LOGGER.log(Level.SEVERE, NbBundle.getMessage(this.getClass(), \"EmbeddedFileExtractorIngestModule.ImageExtractor.extractImage.addToDB.exception.msg\"), ex);\r\n        }\r\n    }\r\n    if (!listOfExtractedImages.isEmpty()) {\r\n        services.fireModuleContentEvent(new ModuleContentEvent(abstractFile));\r\n        context.addFilesToJob(listOfExtractedImageAbstractFiles);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.TikaTextExtractor.locateTesseractExecutable",
	"Comment": "finds and returns the path to the tesseract executable, if able.",
	"Method": "File locateTesseractExecutable(){\r\n    if (!PlatformUtil.isWindowsOS()) {\r\n        return null;\r\n    }\r\n    String executableToFindName = Paths.get(TESSERACT_DIR_NAME, TESSERACT_EXECUTABLE).toString();\r\n    File exeFile = InstalledFileLocator.getDefault().locate(executableToFindName, TikaTextExtractor.class.getPackage().getName(), false);\r\n    if (null == exeFile) {\r\n        return null;\r\n    }\r\n    if (!exeFile.canExecute()) {\r\n        return null;\r\n    }\r\n    return exeFile;\r\n}"
}, {
	"Path": "com.google.example.games.tanc.MainActivity.isPrime",
	"Comment": "this is not an implementation we are mathematically proud of, but it gets the job done.",
	"Method": "boolean isPrime(int n){\r\n    int i;\r\n    if (n == 0 || n == 1) {\r\n        return false;\r\n    }\r\n    for (i = 2; i <= n / 2; i++) {\r\n        if (n % i == 0) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "net.sourceforge.sox.SoxController.copyRawFile",
	"Comment": "copies a raw resource file, given its id to the given location",
	"Method": "void copyRawFile(Context ctx,int resid,File file,String mode){\r\n    final String abspath = file.getAbsolutePath();\r\n    final FileOutputStream out = new FileOutputStream(file);\r\n    final InputStream is = ctx.getResources().openRawResource(resid);\r\n    byte[] buf = new byte[1024];\r\n    int len;\r\n    while ((len = is.read(buf)) > 0) {\r\n        out.write(buf, 0, len);\r\n    }\r\n    out.close();\r\n    is.close();\r\n    Runtime.getRuntime().exec(\"chmod \" + mode + \" \" + abspath).waitFor();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.embeddedfileextractor.SevenZipExtractor.makeLocalDirectories",
	"Comment": "create the local directories if they do not exist for the archive",
	"Method": "void makeLocalDirectories(String uniqueArchiveFileName){\r\n    final String localRootAbsPath = getLocalRootAbsPath(uniqueArchiveFileName);\r\n    final File localRoot = new File(localRootAbsPath);\r\n    if (!localRoot.exists()) {\r\n        localRoot.mkdirs();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.optionspanel.ManageCasesDialog.displayManageCasesDialog",
	"Comment": "create and display the manage cases dialog for the currently enabledcentral repository.",
	"Method": "void displayManageCasesDialog(){\r\n    ManageCasesDialog caseInfoDialog = new ManageCasesDialog();\r\n    caseInfoDialog.setLocationRelativeTo(WindowManager.getDefault().getMainWindow());\r\n    caseInfoDialog.setVisible(true);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.FileExportSettings.store",
	"Comment": "saves the file export settings to secondary storage. existing settingsare overwritten.",
	"Method": "void store(FileExportSettings settings){\r\n    Path folderPath = Paths.get(PlatformUtil.getUserConfigDirectory(), SETTINGS_DIRECTORY);\r\n    Path filePath = Paths.get(folderPath.toString(), SETTINGS_FILE_NAME);\r\n    try {\r\n        Files.createDirectories(folderPath);\r\n        try (NbObjectOutputStream out = new NbObjectOutputStream(new FileOutputStream(filePath.toString()))) {\r\n            out.writeObject(settings);\r\n        }\r\n    } catch (IOException ex) {\r\n        throw new PersistenceException(String.format(\"Failed to write settings to %s\", filePath), ex);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.directorytree.CollapseAction.collapseSelectedNode",
	"Comment": "collapse all visible children of the given node on the given tree.",
	"Method": "void collapseSelectedNode(BeanTreeView tree,Node currentNode){\r\n    Children c = currentNode.getChildren();\r\n    for (Node next : c.getNodes()) {\r\n        if (tree.isExpanded(next)) {\r\n            this.collapseSelectedNode(tree, next);\r\n        }\r\n    }\r\n    tree.collapseNode(currentNode);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestManager.initIngestMessageInbox",
	"Comment": "causes the ingest manager to get the top component used to display ingestinbox messages. called by the custom installer for this package once thewindow system is initialized.",
	"Method": "void initIngestMessageInbox(){\r\n    synchronized (this.ingestMessageBoxLock) {\r\n        ingestMessageBox = IngestMessageTopComponent.findInstance();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.datamodel.SingleEvent.isHashHit",
	"Comment": "is the file this event is derived from in any of the configured hashsets.",
	"Method": "boolean isHashHit(){\r\n    return hashHit;\r\n}"
}, {
	"Path": "com.mcxiaoke.next.utils.StringUtils.split",
	"Comment": "split a string at the first occurrence of the delimiter. does not includethe delimiter in the result.",
	"Method": "String[] split(String toSplit,String delimiter){\r\n    if (!hasLength(toSplit) || !hasLength(delimiter)) {\r\n        return null;\r\n    }\r\n    int offset = toSplit.indexOf(delimiter);\r\n    if (offset < 0) {\r\n        return null;\r\n    }\r\n    String beforeDelimiter = toSplit.substring(0, offset);\r\n    String afterDelimiter = toSplit.substring(offset + delimiter.length());\r\n    return new String[] { beforeDelimiter, afterDelimiter };\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJobsPanel.addListSelectionListener",
	"Comment": "add a list selection listener to the selection model of the outline beingused in this panel.",
	"Method": "void addListSelectionListener(ListSelectionListener listener){\r\n    outline.getSelectionModel().addListSelectionListener(listener);\r\n}"
}, {
	"Path": "com.fernandocejas.arrow.collections.MoreArrays.newArray",
	"Comment": "returns a new array of the given length with the same type as a referencearray.",
	"Method": "T[] newArray(Class<T> type,int length,T[] newArray,T[] reference,int length){\r\n    Class<?> type = reference.getClass().getComponentType();\r\n    return (T[]) Array.newInstance(type, length);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.ReportModule.getConfigurationPanel",
	"Comment": "returns the configuration panel for the report, which is displayed in thereport configuration step of the report wizard.",
	"Method": "JPanel getConfigurationPanel(){\r\n    return new DefaultReportConfigurationPanel();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.ThumbnailViewChildren.getCriterionComparator",
	"Comment": "make a comparator from the given criterion. the comparator compares nodesaccording to the value of the property specified in the sortcriterion.",
	"Method": "Comparator<Node> getCriterionComparator(SortCriterion criterion){\r\n    @SuppressWarnings(\"unchecked\")\r\n    Comparator<Node> c = // Null values go first, unless reversed below.\r\n    Comparator.comparing(node -> getPropertyValue(node, criterion.getProperty()), Comparator.nullsFirst(Comparator.naturalOrder()));\r\n    switch(criterion.getSortOrder()) {\r\n        case DESCENDING:\r\n        case UNSORTED:\r\n            return c.reversed();\r\n        case ASCENDING:\r\n        default:\r\n            return c;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.interestingitems.FilesSetsManager.setInterestingFilesSets",
	"Comment": "sets the current interesting file sets definitions, replacing anyprevious definitions.",
	"Method": "void setInterestingFilesSets(Map<String, FilesSet> filesSets){\r\n    synchronized (INTERESTING_FILES_SET_LOCK) {\r\n        InterestingItemsFilesSetSettings.writeDefinitionsFile(INTERESTING_FILES_SET_DEFS_NAME, filesSets);\r\n        this.setChanged();\r\n        this.notifyObservers();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.events.AutopsyEventPublisher.stopRemotePublisher",
	"Comment": "stops the remote event publisher, but does not reset the current channelname.",
	"Method": "void stopRemotePublisher(){\r\n    if (null != remotePublisher) {\r\n        try {\r\n            remotePublisher.stop();\r\n        } catch (JMSException ex) {\r\n            logger.log(Level.SEVERE, String.format(\"Error closing remote event publisher for channel %s\", currentChannelName), ex);\r\n        }\r\n        remotePublisher = null;\r\n    }\r\n}"
}, {
	"Path": "com.google.example.games.catt2.SaveGame.getLevelStars",
	"Comment": "gets how many stars the player has on the given level. if the level does not existin the save game, will return 0.",
	"Method": "int getLevelStars(String levelName,int getLevelStars,int world,int level){\r\n    return getLevelStars(String.valueOf(world) + \"-\" + String.valueOf(level));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.iOS.ContactAnalyzer.findContactsInDB",
	"Comment": "create blackboard artifacts and index results for call logs found in thedatabase.",
	"Method": "void findContactsInDB(String DatabasePath,long fileId){\r\n    if (DatabasePath == null || DatabasePath.isEmpty()) {\r\n        return;\r\n    }\r\n    Case currentCase;\r\n    try {\r\n        currentCase = Case.getCurrentCaseThrows();\r\n    } catch (NoCurrentCaseException ex) {\r\n        logger.log(Level.SEVERE, \"Exception while getting open case.\", ex);\r\n        return;\r\n    }\r\n    Statement statement = null;\r\n    try {\r\n        Class.forName(\"org.sqlite.JDBC\");\r\n        connection = DriverManager.getConnection(\"jdbc:sqlite:\" + DatabasePath);\r\n        statement = connection.createStatement();\r\n    } catch (ClassNotFoundException | SQLException e) {\r\n        logger.log(Level.SEVERE, \"Error opening database\", e);\r\n    }\r\n    SleuthkitCase skCase = currentCase.getSleuthkitCase();\r\n    try {\r\n        AbstractFile file = skCase.getAbstractFileById(fileId);\r\n        if (file == null) {\r\n            logger.log(Level.SEVERE, \"Error getting abstract file {0}\", fileId);\r\n            return;\r\n        }\r\n        ResultSet resultSet = null;\r\n        try {\r\n            resultSet = // NON-NLS\r\n            statement.executeQuery(\"SELECT mimetype,data1, name_raw_contact.display_name AS display_name \\n\" + \"FROM raw_contacts JOIN contacts ON (raw_contacts.contact_id=contacts._id) \\n\" + \"JOIN raw_contacts AS name_raw_contact ON(name_raw_contact_id=name_raw_contact._id) \" + \"LEFT OUTER JOIN data ON (data.raw_contact_id=raw_contacts._id) \\n\" + \"LEFT OUTER JOIN mimetypes ON (data.mimetype_id=mimetypes._id) \\n\" + \"WHERE mimetype = 'vnd.android.cursor.item/phone_v2' OR mimetype = 'vnd.android.cursor.item/email_v2'\\n\" + \"ORDER BY name_raw_contact.display_name ASC;\");\r\n            BlackboardArtifact bba;\r\n            bba = file.newArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_CONTACT);\r\n            Collection<BlackboardAttribute> attributes = new ArrayList();\r\n            String name;\r\n            String oldName = \"\";\r\n            String mimetype;\r\n            String data1;\r\n            while (resultSet.next()) {\r\n                name = resultSet.getString(\"display_name\");\r\n                data1 = resultSet.getString(\"data1\");\r\n                mimetype = resultSet.getString(\"mimetype\");\r\n                if (name.equals(oldName) == false) {\r\n                    attributes.add(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME, moduleName, name));\r\n                }\r\n                if (mimetype.equals(\"vnd.android.cursor.item/phone_v2\")) {\r\n                    attributes.add(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PHONE_NUMBER, moduleName, data1));\r\n                } else {\r\n                    attributes.add(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_EMAIL, moduleName, data1));\r\n                }\r\n                oldName = name;\r\n                bba.addAttributes(attributes);\r\n                try {\r\n                    blackboard.indexArtifact(bba);\r\n                } catch (Blackboard.BlackboardException ex) {\r\n                    logger.log(Level.SEVERE, \"Unable to index blackboard artifact \" + bba.getArtifactID(), ex);\r\n                    MessageNotifyUtil.Notify.error(Bundle.ContactAnalyzer_indexError_message(), bba.getDisplayName());\r\n                }\r\n            }\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Error parsing Contacts to Blackboard\", e);\r\n        } finally {\r\n            try {\r\n                resultSet.close();\r\n                statement.close();\r\n                connection.close();\r\n            } catch (Exception e) {\r\n                logger.log(Level.SEVERE, \"Error closing database\", e);\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n        logger.log(Level.SEVERE, \"Error parsing Contacts to Blackboard\", e);\r\n    }\r\n}"
}, {
	"Path": "com.facebook.samples.gestures.MultiPointerGestureDetector.shouldStartGesture",
	"Comment": "this method can be overridden in order to perform threshold check or something similar.",
	"Method": "boolean shouldStartGesture(){\r\n    return true;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.LocalDiskDSProcessor.setDataSourceOptions",
	"Comment": "sets the configuration of the data source processor without using theconfiguration panel.",
	"Method": "void setDataSourceOptions(String drivePath,String timeZone,boolean ignoreFatOrphanFiles){\r\n    this.deviceId = UUID.randomUUID().toString();\r\n    this.drivePath = drivePath;\r\n    this.sectorSize = 0;\r\n    this.timeZone = Calendar.getInstance().getTimeZone().getID();\r\n    this.ignoreFatOrphanFiles = ignoreFatOrphanFiles;\r\n    setDataSourceOptionsCalled = true;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.core.UserPreferences.getMaximumNumberOfResults",
	"Comment": "get the maximum number of result rows to show in data result tables.",
	"Method": "int getMaximumNumberOfResults(){\r\n    return preferences.getInt(MAXIMUM_NUMBER_OF_RESULTS, DEFAULT_MAX_RESULTS);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.datamodel.BlackboardArtifactNode.addNodeProperty",
	"Comment": "add an additional custom node property to that node before it isdisplayed",
	"Method": "void addNodeProperty(NodeProperty<?> np){\r\n    if (null == customProperties) {\r\n        customProperties = new ArrayList();\r\n    }\r\n    customProperties.add(np);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.NewCaseWizardPanel1.storeSettings",
	"Comment": "provides the wizard panel with the opportunity to update the settingswith its current customized state. rather than updating its settings withevery change in the gui, it should collect them, and then only save themwhen requested to by this method. this method can be called multipletimes on one instance of wizarddescriptor.panel.",
	"Method": "void storeSettings(WizardDescriptor settings){\r\n    CaseType caseType = getComponent().getCaseType();\r\n    settings.putProperty(\"caseName\", getComponent().getCaseName());\r\n    settings.putProperty(\"caseParentDir\", getComponent().getCaseParentDir());\r\n    settings.putProperty(\"createdDirectory\", createdDirectory);\r\n    settings.putProperty(\"caseType\", caseType.ordinal());\r\n    ModuleSettings.setConfigSetting(ModuleSettings.MAIN_SETTINGS, ModuleSettings.CURRENT_CASE_TYPE, caseType.toString());\r\n    ModuleSettings.setConfigSetting(ModuleSettings.MAIN_SETTINGS, PROP_BASECASE, getComponent().getCaseParentDir());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.filesearch.DateSearchPanel.setFromDate",
	"Comment": "validate and set the datetime field on the screen given a datetimestring.",
	"Method": "void setFromDate(Date date){\r\n    String dateStringResult = \"\";\r\n    Instant ins = null;\r\n    if (date != null) {\r\n        dateStringResult = dateFormat.format(date);\r\n        ins = date.toInstant();\r\n    }\r\n    fromDatePicker.setText(dateStringResult);\r\n    if (ins != null) {\r\n        fromDatePicker.setDate(ins.atZone(dateFormat.getTimeZone().toZoneId()).toLocalDate());\r\n    } else {\r\n        fromDatePicker.setDate(null);\r\n    }\r\n}"
}, {
	"Path": "org.wikipedia.page.PageActivity.loadPage",
	"Comment": "load a new page, and put it on top of the backstack, optionally allowing state loss of thefragment manager. useful for when this function is called from an asynctask result.",
	"Method": "void loadPage(PageTitle title,HistoryEntry entry,TabPosition position){\r\n    if (isDestroyed()) {\r\n        return;\r\n    }\r\n    if (entry.getSource() != HistoryEntry.SOURCE_INTERNAL_LINK || !isLinkPreviewEnabled()) {\r\n        new LinkPreviewFunnel(app, entry.getSource()).logNavigate();\r\n    }\r\n    app.putCrashReportProperty(\"api\", title.getWikiSite().authority());\r\n    app.putCrashReportProperty(\"title\", title.toString());\r\n    if (title.isSpecial()) {\r\n        visitInExternalBrowser(this, Uri.parse(title.getMobileUri()));\r\n        return;\r\n    }\r\n    toolbarContainerView.post(() -> {\r\n        if (!pageFragment.isAdded()) {\r\n            return;\r\n        }\r\n        hideLinkPreview();\r\n        pageFragment.closeFindInPage();\r\n        if (position == TabPosition.CURRENT_TAB) {\r\n            pageFragment.loadPage(title, entry, true);\r\n        } else if (position == TabPosition.NEW_TAB_BACKGROUND) {\r\n            pageFragment.openInNewBackgroundTabFromMenu(title, entry);\r\n        } else if (position == TabPosition.EXISTING_TAB) {\r\n            pageFragment.openFromExistingTab(title, entry);\r\n        } else {\r\n            pageFragment.openInNewForegroundTabFromMenu(title, entry);\r\n        }\r\n        app.getSessionFunnel().pageViewed(entry);\r\n    });\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.DataContentViewerArtifact.updateColumnSizes",
	"Comment": "update the column widths so that the value column has most of the space.",
	"Method": "void updateColumnSizes(){\r\n    Enumeration<TableColumn> columns = resultsTable.getColumnModel().getColumns();\r\n    while (columns.hasMoreElements()) {\r\n        TableColumn col = columns.nextElement();\r\n        if (col.getHeaderValue().equals(COLUMN_HEADERS[0])) {\r\n            col.setPreferredWidth(COLUMN_WIDTHS[0]);\r\n        } else if (col.getHeaderValue().equals(COLUMN_HEADERS[1])) {\r\n            col.setPreferredWidth(COLUMN_WIDTHS[1]);\r\n        } else if (col.getHeaderValue().equals(COLUMN_HEADERS[2])) {\r\n            col.setPreferredWidth(COLUMN_WIDTHS[2]);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.example.games.catt2.MainActivity.signInSilently",
	"Comment": "try to sign in without displaying dialogs to the user.if the user has already signed in previously, it will not show dialog.",
	"Method": "void signInSilently(){\r\n    Log.d(TAG, \"signInSilently()\");\r\n    mGoogleSignInClient.silentSignIn().addOnCompleteListener(this, new OnCompleteListener<GoogleSignInAccount>() {\r\n        @Override\r\n        public void onComplete(@NonNull Task<GoogleSignInAccount> task) {\r\n            if (task.isSuccessful()) {\r\n                Log.d(TAG, \"signInSilently(): success\");\r\n                onConnected(task.getResult());\r\n            } else {\r\n                Log.d(TAG, \"signInSilently(): failure\", task.getException());\r\n                onDisconnected();\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.google.example.games.catt2.MainActivity.signInSilently",
	"Comment": "try to sign in without displaying dialogs to the user.if the user has already signed in previously, it will not show dialog.",
	"Method": "void signInSilently(){\r\n    if (task.isSuccessful()) {\r\n        Log.d(TAG, \"signInSilently(): success\");\r\n        onConnected(task.getResult());\r\n    } else {\r\n        Log.d(TAG, \"signInSilently(): failure\", task.getException());\r\n        onDisconnected();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.configuration.AutoIngestUserPreferences.setShowToolsWarning",
	"Comment": "save whether tools warning dialog should be shown on startup.",
	"Method": "void setShowToolsWarning(boolean showToolsWarning){\r\n    ModuleSettings.setConfigSetting(UserPreferences.SETTINGS_PROPERTIES, SHOW_TOOLS_WARNING, Boolean.toString(showToolsWarning));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.services.FileManager.findFilesByMimeType",
	"Comment": "finds all files with types that match one of a collection of mime types.",
	"Method": "List<AbstractFile> findFilesByMimeType(Collection<String> mimeTypes,List<AbstractFile> findFilesByMimeType,Content dataSource,Collection<String> mimeTypes){\r\n    if (null == caseDb) {\r\n        throw new TskCoreException(\"File manager has been closed\");\r\n    }\r\n    return caseDb.findAllFilesWhere(\"data_source_obj_id = \" + dataSource.getId() + \" AND \" + createFileTypeInCondition(mimeTypes));\r\n}"
}, {
	"Path": "com.aliyun.oss.ClientConfiguration.setSignerHandlers",
	"Comment": "sets signer handlers using for authentication of the proxy server.",
	"Method": "void setSignerHandlers(List<RequestSigner> signerHandlers){\r\n    if (signerHandlers == null) {\r\n        return;\r\n    }\r\n    this.signerHandlers.clear();\r\n    for (RequestSigner signer : signerHandlers) {\r\n        if (signer != null) {\r\n            this.signerHandlers.add(signer);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.contentviewers.SQLiteViewer.exportCsvButtonActionPerformed",
	"Comment": "the action when the export csv button is pressed. the file chooser windowwill pop up to choose where the user wants to save the csv file. thedefault location is case export directory.",
	"Method": "void exportCsvButtonActionPerformed(java.awt.event.ActionEvent evt){\r\n    Case openCase = Case.getCurrentCase();\r\n    File caseDirectory = new File(openCase.getExportDirectory());\r\n    JFileChooser fileChooser = new JFileChooser();\r\n    fileChooser.setDragEnabled(false);\r\n    fileChooser.setCurrentDirectory(caseDirectory);\r\n    FileNameExtensionFilter csvFilter = new FileNameExtensionFilter(\"*.csv\", \"csv\");\r\n    fileChooser.addChoosableFileFilter(csvFilter);\r\n    fileChooser.setAcceptAllFileFilterUsed(true);\r\n    fileChooser.setFileFilter(csvFilter);\r\n    fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY);\r\n    String defaultFileName = (String) this.tablesDropdownList.getSelectedItem();\r\n    fileChooser.setSelectedFile(new File(defaultFileName));\r\n    int choice = fileChooser.showSaveDialog((Component) evt.getSource());\r\n    if (JFileChooser.APPROVE_OPTION == choice) {\r\n        File file = fileChooser.getSelectedFile();\r\n        if (file.exists() && FilenameUtils.getExtension(file.getName()).equalsIgnoreCase(\"csv\")) {\r\n            if (JOptionPane.YES_OPTION == JOptionPane.showConfirmDialog(this, Bundle.SQLiteViewer_csvExport_confirm_msg(), Bundle.SQLiteViewer_csvExport_title(), JOptionPane.YES_NO_OPTION)) {\r\n            } else {\r\n                return;\r\n            }\r\n        }\r\n        exportTableToCsv(file);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.InterCasePanel.pictureVideoCheckboxIsSelected",
	"Comment": "if the user has selected selected to show picture and video files as partof the filtered results.",
	"Method": "boolean pictureVideoCheckboxIsSelected(){\r\n    return pictureVideoCheckbox.isEnabled() && pictureVideoCheckbox.isSelected();\r\n}"
}, {
	"Path": "deadlock.ThreadLockFixedDemo.method1",
	"Comment": "both method are now requesting lock in same order,first integer and then string.this will solve the problem,as long as both method are requesting lock in consistent order.",
	"Method": "void method1(){\r\n    synchronized (Integer.class) {\r\n        System.out.println(\"Acquired lock on Integer.class object\");\r\n    }\r\n    synchronized (String.class) {\r\n        System.out.println(\"Acquired lock on String.class object\");\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.encryptiondetection.EncryptionDetectionIngestJobSettings.getMinimumEntropy",
	"Comment": "get the minimum entropy necessary for the creation of blackboardartifacts.",
	"Method": "double getMinimumEntropy(){\r\n    return minimumEntropy;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.DataSourceProcessorUtility.orderDataSourceProcessorsByConfidence",
	"Comment": "a utility method to get an ordered list of data source processors. dspsare ordered in descending order from highest confidence to lowest.",
	"Method": "List<AutoIngestDataSourceProcessor> orderDataSourceProcessorsByConfidence(Map<AutoIngestDataSourceProcessor, Integer> validDataSourceProcessorsMap){\r\n    List<AutoIngestDataSourceProcessor> validDataSourceProcessors = validDataSourceProcessorsMap.entrySet().stream().sorted(Map.Entry.<AutoIngestDataSourceProcessor, Integer>comparingByValue().reversed()).map(Map.Entry::getKey).collect(Collectors.toList());\r\n    return validDataSourceProcessors;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.Case.getExportDirectory",
	"Comment": "gets the full path to the export directory for this case, creating it ifit does not exist.",
	"Method": "String getExportDirectory(){\r\n    return getOrCreateSubdirectory(EXPORT_FOLDER);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.IntraCasePanel.documentsCheckboxIsSelected",
	"Comment": "if the user has selected selected to show document files as part of thefiltered results.",
	"Method": "boolean documentsCheckboxIsSelected(){\r\n    return documentsCheckbox.isEnabled() && documentsCheckbox.isSelected();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.datamodel.FilteredEventsModel.postTagsAdded",
	"Comment": "post a tagsaddedevent to all registered subscribers, if the given set ofupdated event ids is not empty.",
	"Method": "boolean postTagsAdded(Set<Long> updatedEventIDs){\r\n    boolean tagsUpdated = !updatedEventIDs.isEmpty();\r\n    if (tagsUpdated) {\r\n        eventbus.post(new TagsAddedEvent(updatedEventIDs));\r\n    }\r\n    return tagsUpdated;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.recentactivity.UsbDeviceIdMapper.parseAndLookup",
	"Comment": "parses the passed in device id and returns info that includes make andmodel.",
	"Method": "USBInfo parseAndLookup(String dev){\r\n    String[] dtokens = dev.split(\"[_&]\");\r\n    String vID = dtokens[1].toUpperCase();\r\n    String pID;\r\n    if (dtokens.length < 4 || dtokens[3].length() < 4) {\r\n        pID = \"0000\";\r\n    } else {\r\n        pID = dtokens[3];\r\n    }\r\n    pID = pID.toUpperCase();\r\n    String key = vID + pID;\r\n    if (devices.containsKey(key)) {\r\n        return devices.get(key);\r\n    }\r\n    key = vID + \"0000\";\r\n    if (devices.containsKey(key)) {\r\n        USBInfo info = devices.get(key);\r\n        return new USBInfo(info.getVendor(), NbBundle.getMessage(this.getClass(), \"UsbDeviceIdMapper.parseAndLookup.text\", pID));\r\n    }\r\n    return new USBInfo(null, null);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestDashboard.createDashboard",
	"Comment": "creates a dashboard for monitoring an automated ingest cluster.",
	"Method": "AutoIngestDashboard createDashboard(){\r\n    AutoIngestDashboard dashBoard = new AutoIngestDashboard();\r\n    try {\r\n        dashBoard.startUp();\r\n    } catch (AutoIngestMonitor.AutoIngestMonitorException ex) {\r\n        throw new AutoIngestDashboardException(\"Error starting up auto ingest dashboard\", ex);\r\n    }\r\n    return dashBoard;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.ReportWizardFileOptionsVisualPanel.initOptionsList",
	"Comment": "populate the list of file report information that can be selected.",
	"Method": "void initOptionsList(){\r\n    options = Arrays.asList(FileReportDataTypes.values());\r\n    for (FileReportDataTypes col : options) {\r\n        optionStates.put(col, Boolean.FALSE);\r\n    }\r\n    model = new OptionsListModel();\r\n    optionsList.setModel(model);\r\n    optionsList.setCellRenderer(new OptionsListRenderer());\r\n    optionsList.setVisibleRowCount(-1);\r\n    selectAllButton.setEnabled(true);\r\n    deselectAllButton.setEnabled(false);\r\n    optionsList.addMouseListener(new MouseAdapter() {\r\n        @Override\r\n        public void mousePressed(MouseEvent evt) {\r\n            int index = optionsList.locationToIndex(evt.getPoint());\r\n            FileReportDataTypes value = model.getElementAt(index);\r\n            optionStates.put(value, !optionStates.get(value));\r\n            optionsList.repaint();\r\n            boolean anySelected = anySelected();\r\n            deselectAllButton.setEnabled(anySelected);\r\n            wizPanel.setFinish(anySelected);\r\n            selectAllButton.setEnabled(notAllSelected());\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.ReportWizardFileOptionsVisualPanel.initOptionsList",
	"Comment": "populate the list of file report information that can be selected.",
	"Method": "void initOptionsList(){\r\n    int index = optionsList.locationToIndex(evt.getPoint());\r\n    FileReportDataTypes value = model.getElementAt(index);\r\n    optionStates.put(value, !optionStates.get(value));\r\n    optionsList.repaint();\r\n    boolean anySelected = anySelected();\r\n    deselectAllButton.setEnabled(anySelected);\r\n    wizPanel.setFinish(anySelected);\r\n    selectAllButton.setEnabled(notAllSelected());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.TimeLineController.pushPeriod",
	"Comment": "request a time range the same length as the given period and centeredaround the middle of the currently viewed time range.",
	"Method": "void pushPeriod(ReadablePeriod period){\r\n    synchronized (filteredEvents) {\r\n        pushTimeRange(IntervalUtils.getIntervalAroundMiddle(filteredEvents.getTimeRange(), period));\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.LocalFilesDSProcessor.setDataSourceOptions",
	"Comment": "sets the configuration of the data source processor without using theconfiguration panel. the data source processor will assign a uuid to thedata source and will use the time zone of the machine executing this codewhen when processing dates and times for the image.",
	"Method": "void setDataSourceOptions(String paths){\r\n    this.localFilePaths = Arrays.asList(paths.split(\",\"));\r\n    setDataSourceOptionsCalled = true;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.texttranslation.TextTranslationService.hasProvider",
	"Comment": "returns if a texttranslator lookup successfully found an implementingclass.",
	"Method": "boolean hasProvider(){\r\n    return translator.isPresent();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.ReportProgressPanel.setIndeterminate",
	"Comment": "changes the the progress bar component of this panel to be determinate orindeterminate.",
	"Method": "void setIndeterminate(boolean indeterminate){\r\n    EventQueue.invokeLater(() -> {\r\n        if (status != ReportStatus.CANCELED) {\r\n            reportProgressBar.setIndeterminate(indeterminate);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.directorytree.DirectoryTreeTopComponent.promptForDataSourceGrouping",
	"Comment": "ask the user if they want to group by data source when opening a largecase.",
	"Method": "void promptForDataSourceGrouping(int dataSourceCount){\r\n    if (CasePreferences.getGroupItemsInTreeByDataSource() == null) {\r\n        GroupDataSourcesDialog dialog = new GroupDataSourcesDialog(dataSourceCount);\r\n        dialog.display();\r\n        if (dialog.groupByDataSourceSelected()) {\r\n            CasePreferences.setGroupItemsInTreeByDataSource(true);\r\n            refreshContentTreeSafe();\r\n        } else {\r\n            CasePreferences.setGroupItemsInTreeByDataSource(false);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.ReportHTML.startReport",
	"Comment": "start this report by setting the path, refreshing member variables, andwriting the skeleton for the html report.",
	"Method": "void startReport(String baseReportDir){\r\n    ModuleSettings.setConfigSetting(\"HTMLReport\", \"header\", configPanel.getHeader());\r\n    ModuleSettings.setConfigSetting(\"HTMLReport\", \"footer\", configPanel.getFooter());\r\n    try {\r\n        refresh();\r\n    } catch (NoCurrentCaseException ex) {\r\n        logger.log(Level.SEVERE, \"Exception while getting open case.\");\r\n        return;\r\n    }\r\n    this.path = baseReportDir;\r\n    this.subPath = this.path + HTML_SUBDIR + File.separator;\r\n    this.thumbsPath = this.subPath + THUMBS_REL_PATH;\r\n    try {\r\n        FileUtil.createFolder(new File(this.subPath));\r\n        FileUtil.createFolder(new File(this.thumbsPath));\r\n    } catch (IOException ex) {\r\n        logger.log(Level.SEVERE, \"Unable to make HTML report folder.\");\r\n    }\r\n    writeCss();\r\n    writeIndex();\r\n    writeSummary();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.EamArtifactUtil.makeInstancesFromBlackboardArtifact",
	"Comment": "static factory method to examine a blackboardartifact to determine if ithas contents that can be used for correlation. if so, return aeamartifact with a single eamartifactinstance within. if not, returnnull.",
	"Method": "List<CorrelationAttributeInstance> makeInstancesFromBlackboardArtifact(BlackboardArtifact artifact,boolean checkEnabled){\r\n    List<CorrelationAttributeInstance> eamArtifacts = new ArrayList();\r\n    try {\r\n        BlackboardArtifact artifactForInstance = null;\r\n        if (BlackboardArtifact.ARTIFACT_TYPE.TSK_INTERESTING_ARTIFACT_HIT.getTypeID() == artifact.getArtifactTypeID()) {\r\n            BlackboardAttribute attribute = artifact.getAttribute(new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_ASSOCIATED_ARTIFACT));\r\n            if (attribute != null) {\r\n                artifactForInstance = Case.getCurrentCaseThrows().getSleuthkitCase().getBlackboardArtifact(attribute.getValueLong());\r\n            }\r\n        } else {\r\n            artifactForInstance = artifact;\r\n        }\r\n        if (artifactForInstance != null) {\r\n            switch(BlackboardArtifact.ARTIFACT_TYPE.fromID(artifactForInstance.getArtifactTypeID())) {\r\n                case TSK_KEYWORD_HIT:\r\n                    {\r\n                        BlackboardAttribute setNameAttr = artifactForInstance.getAttribute(new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_SET_NAME));\r\n                        if (setNameAttr != null && EamArtifactUtil.getEmailAddressAttrString().equals(setNameAttr.getValueString())) {\r\n                            addCorrelationAttributeToList(eamArtifacts, artifactForInstance, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_KEYWORD, CorrelationAttributeInstance.EMAIL_TYPE_ID);\r\n                        }\r\n                        break;\r\n                    }\r\n                case TSK_WEB_BOOKMARK:\r\n                    addCorrelationAttributeToList(eamArtifacts, artifactForInstance, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DOMAIN, CorrelationAttributeInstance.DOMAIN_TYPE_ID);\r\n                    break;\r\n                case TSK_WEB_COOKIE:\r\n                    addCorrelationAttributeToList(eamArtifacts, artifactForInstance, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DOMAIN, CorrelationAttributeInstance.DOMAIN_TYPE_ID);\r\n                    break;\r\n                case TSK_WEB_DOWNLOAD:\r\n                    addCorrelationAttributeToList(eamArtifacts, artifactForInstance, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DOMAIN, CorrelationAttributeInstance.DOMAIN_TYPE_ID);\r\n                    break;\r\n                case TSK_WEB_HISTORY:\r\n                    addCorrelationAttributeToList(eamArtifacts, artifactForInstance, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DOMAIN, CorrelationAttributeInstance.DOMAIN_TYPE_ID);\r\n                    break;\r\n                case TSK_CONTACT:\r\n                case TSK_CALLLOG:\r\n                case TSK_MESSAGE:\r\n                    {\r\n                        String value = null;\r\n                        if (null != artifactForInstance.getAttribute(new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PHONE_NUMBER))) {\r\n                            value = artifactForInstance.getAttribute(new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PHONE_NUMBER)).getValueString();\r\n                        } else if (null != artifactForInstance.getAttribute(new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PHONE_NUMBER_FROM))) {\r\n                            value = artifactForInstance.getAttribute(new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PHONE_NUMBER_FROM)).getValueString();\r\n                        } else if (null != artifactForInstance.getAttribute(new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PHONE_NUMBER_TO))) {\r\n                            value = artifactForInstance.getAttribute(new BlackboardAttribute.Type(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PHONE_NUMBER_TO)).getValueString();\r\n                        }\r\n                        if (value != null) {\r\n                            String newValue = value.replaceAll(\"\\\\D\", \"\");\r\n                            if (value.startsWith(\"+\")) {\r\n                                newValue = \"+\" + newValue;\r\n                            }\r\n                            value = newValue;\r\n                            if (value.length() > 5) {\r\n                                eamArtifacts.add(makeCorrelationAttributeInstanceUsingTypeValue(artifactForInstance, EamDb.getInstance().getCorrelationTypeById(CorrelationAttributeInstance.PHONE_TYPE_ID), value));\r\n                            }\r\n                        }\r\n                        break;\r\n                    }\r\n                case TSK_DEVICE_ATTACHED:\r\n                    addCorrelationAttributeToList(eamArtifacts, artifactForInstance, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DEVICE_ID, CorrelationAttributeInstance.USBID_TYPE_ID);\r\n                    addCorrelationAttributeToList(eamArtifacts, artifactForInstance, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_MAC_ADDRESS, CorrelationAttributeInstance.MAC_TYPE_ID);\r\n                    break;\r\n                case TSK_WIFI_NETWORK:\r\n                    addCorrelationAttributeToList(eamArtifacts, artifactForInstance, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_SSID, CorrelationAttributeInstance.SSID_TYPE_ID);\r\n                    break;\r\n                case TSK_WIFI_NETWORK_ADAPTER:\r\n                    addCorrelationAttributeToList(eamArtifacts, artifactForInstance, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_MAC_ADDRESS, CorrelationAttributeInstance.MAC_TYPE_ID);\r\n                    break;\r\n                case TSK_BLUETOOTH_PAIRING:\r\n                    addCorrelationAttributeToList(eamArtifacts, artifactForInstance, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_MAC_ADDRESS, CorrelationAttributeInstance.MAC_TYPE_ID);\r\n                    break;\r\n                case TSK_BLUETOOTH_ADAPTER:\r\n                    addCorrelationAttributeToList(eamArtifacts, artifactForInstance, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_MAC_ADDRESS, CorrelationAttributeInstance.MAC_TYPE_ID);\r\n                    break;\r\n                case TSK_DEVICE_INFO:\r\n                    addCorrelationAttributeToList(eamArtifacts, artifactForInstance, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_IMEI, CorrelationAttributeInstance.IMEI_TYPE_ID);\r\n                    addCorrelationAttributeToList(eamArtifacts, artifactForInstance, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_IMSI, CorrelationAttributeInstance.IMSI_TYPE_ID);\r\n                    addCorrelationAttributeToList(eamArtifacts, artifactForInstance, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_ICCID, CorrelationAttributeInstance.ICCID_TYPE_ID);\r\n                    break;\r\n                case TSK_SIM_ATTACHED:\r\n                    addCorrelationAttributeToList(eamArtifacts, artifactForInstance, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_IMSI, CorrelationAttributeInstance.IMSI_TYPE_ID);\r\n                    addCorrelationAttributeToList(eamArtifacts, artifactForInstance, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_ICCID, CorrelationAttributeInstance.ICCID_TYPE_ID);\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n    } catch (EamDbException ex) {\r\n        logger.log(Level.SEVERE, \"Error getting defined correlation types.\", ex);\r\n        return eamArtifacts;\r\n    } catch (TskCoreException ex) {\r\n        logger.log(Level.SEVERE, \"Error getting attribute while getting type from BlackboardArtifact.\", ex);\r\n        return null;\r\n    } catch (NoCurrentCaseException ex) {\r\n        logger.log(Level.SEVERE, \"Exception while getting open case.\", ex);\r\n        return null;\r\n    }\r\n    return eamArtifacts;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.ModuleSettings.makeConfigFile",
	"Comment": "makes a new config file of the specified name. do not include theextension.",
	"Method": "boolean makeConfigFile(String moduleName){\r\n    if (!configExists(moduleName)) {\r\n        File propPath = new File(moduleDirPath + File.separator + moduleName + \".properties\");\r\n        File parent = new File(propPath.getParent());\r\n        if (!parent.exists()) {\r\n            parent.mkdirs();\r\n        }\r\n        Properties props = new Properties();\r\n        try {\r\n            propPath.createNewFile();\r\n            FileOutputStream fos = new FileOutputStream(propPath);\r\n            props.store(fos, \"\");\r\n            fos.close();\r\n        } catch (IOException e) {\r\n            Logger.getLogger(ModuleSettings.class.getName()).log(Level.WARNING, \"Was not able to create a new properties file.\", e);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.aliyun.oss.internal.ResponseParsers.parseCreateLiveChannel",
	"Comment": "unmarshall create live channel response body to corresponding result.",
	"Method": "CreateLiveChannelResult parseCreateLiveChannel(InputStream responseBody){\r\n    try {\r\n        Element root = getXmlRootElement(responseBody);\r\n        CreateLiveChannelResult result = new CreateLiveChannelResult();\r\n        List<String> publishUrls = new ArrayList<String>();\r\n        List<Element> publishElems = root.getChild(\"PublishUrls\").getChildren(\"Url\");\r\n        for (Element urlElem : publishElems) {\r\n            publishUrls.add(urlElem.getText());\r\n        }\r\n        result.setPublishUrls(publishUrls);\r\n        List<String> playUrls = new ArrayList<String>();\r\n        List<Element> playElems = root.getChild(\"PlayUrls\").getChildren(\"Url\");\r\n        for (Element urlElem : playElems) {\r\n            playUrls.add(urlElem.getText());\r\n        }\r\n        result.setPlayUrls(playUrls);\r\n        return result;\r\n    } catch (JDOMParseException e) {\r\n        throw new ResponseParseException(e.getPartialDocument() + \": \" + e.getMessage(), e);\r\n    } catch (Exception e) {\r\n        throw new ResponseParseException(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.volatilityDSP.VolatilityProcessor.run",
	"Comment": "runs volatility on a given memory image file and parses the output tocreate artifacts.",
	"Method": "void run(){\r\n    this.errorMsgs.clear();\r\n    try {\r\n        this.currentCase = Case.getCurrentCaseThrows();\r\n    } catch (NoCurrentCaseException ex) {\r\n        throw new VolatilityProcessorException(Bundle.VolatilityProcessor_progressMessage_noCurrentCase(), ex);\r\n    }\r\n    executableFile = locateVolatilityExecutable();\r\n    if (executableFile == null) {\r\n        throw new VolatilityProcessorException(Bundle.VolatilityProcessor_exceptionMessage_volatilityExeNotFound());\r\n    }\r\n    fileManager = currentCase.getServices().getFileManager();\r\n    try {\r\n        outputVirtDir = currentCase.getSleuthkitCase().addVirtualDirectory(dataSource.getId(), \"ModuleOutput\");\r\n    } catch (TskCoreException ex) {\r\n        throw new VolatilityProcessorException(\"Error creating virtual directory\", ex);\r\n    }\r\n    Long dataSourceId = dataSource.getId();\r\n    moduleOutputPath = Paths.get(currentCase.getModuleDirectory(), VOLATILITY, dataSourceId.toString()).toString();\r\n    File directory = new File(String.valueOf(moduleOutputPath));\r\n    if (!directory.exists()) {\r\n        directory.mkdirs();\r\n    }\r\n    if (profile.isEmpty()) {\r\n        progressMonitor.setProgressText(Bundle.VolatilityProcessor_progressMessage_runningImageInfo(\"imageinfo\"));\r\n        runVolatilityPlugin(\"imageinfo\");\r\n        profile = getProfileFromImageInfoOutput();\r\n    }\r\n    progressMonitor.setIndeterminate(false);\r\n    progressMonitor.setProgressMax(pluginsToRun.size());\r\n    for (int i = 0; i < pluginsToRun.size(); i++) {\r\n        if (isCancelled) {\r\n            break;\r\n        }\r\n        String pluginToRun = pluginsToRun.get(i);\r\n        runVolatilityPlugin(pluginToRun);\r\n        progressMonitor.setProgress(i);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.healthmonitor.HealthMonitorDashboard.createUserPanel",
	"Comment": "create the user panel.this displays cases open and users logged in",
	"Method": "JPanel createUserPanel(){\r\n    if (!HealthMonitor.monitorIsEnabled()) {\r\n        JPanel emptyUserMetricPanel = new JPanel();\r\n        emptyUserMetricPanel.add(new JLabel(Bundle.HealthMonitorDashboard_createUserPanel_userMetricsTitle()));\r\n        emptyUserMetricPanel.add(new JLabel(\" \"));\r\n        emptyUserMetricPanel.add(new JLabel(Bundle.HealthMonitorDashboard_createUserPanel_noData()));\r\n        return emptyUserMetricPanel;\r\n    }\r\n    JPanel userMetricPanel = new JPanel();\r\n    userMetricPanel.setLayout(new BoxLayout(userMetricPanel, BoxLayout.PAGE_AXIS));\r\n    userMetricPanel.setBorder(BorderFactory.createEtchedBorder());\r\n    JLabel userMetricTitle = new JLabel(Bundle.HealthMonitorDashboard_createUserPanel_userMetricsTitle());\r\n    userMetricPanel.add(userMetricTitle);\r\n    userMetricPanel.add(new JSeparator());\r\n    userMetricPanel.add(createUserControlPanel());\r\n    userMetricPanel.add(new JSeparator());\r\n    userGraphPanel = new JPanel();\r\n    userGraphPanel.setLayout(new GridLayout(0, 2));\r\n    updateUserMetricGraphs();\r\n    JScrollPane scrollPane = new JScrollPane(userGraphPanel, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\r\n    userMetricPanel.add(scrollPane);\r\n    userMetricPanel.revalidate();\r\n    userMetricPanel.repaint();\r\n    return userMetricPanel;\r\n}"
}, {
	"Path": "com.google.example.games.bc.MainActivity.onKeyDown",
	"Comment": "handle back key to make sure we cleanly leave a game if we are in the middle of one",
	"Method": "boolean onKeyDown(int keyCode,KeyEvent e){\r\n    if (keyCode == KeyEvent.KEYCODE_BACK && mCurScreen == R.id.screen_game) {\r\n        leaveRoom();\r\n        return true;\r\n    }\r\n    return super.onKeyDown(keyCode, e);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.volatilityDSP.AddMemoryImageTask.addImageToCase",
	"Comment": "attempts to add the input memory image to the case as a data source.",
	"Method": "Image addImageToCase(){\r\n    progressMonitor.setProgressText(Bundle.AddMemoryImageTask_progressMessage_addingImageFile(memoryImagePath));\r\n    SleuthkitCase caseDatabase = Case.getCurrentCaseThrows().getSleuthkitCase();\r\n    caseDatabase.acquireSingleUserCaseWriteLock();\r\n    try {\r\n        File imageFile = Paths.get(memoryImagePath).toFile();\r\n        if (!imageFile.exists()) {\r\n            throw new TskCoreException(Bundle.AddMemoryImageTask_exceptionMessage_noImageFile(memoryImagePath, deviceId));\r\n        }\r\n        Image dataSource = caseDatabase.addImageInfo(0, new ArrayList(Arrays.asList(memoryImagePath)), timeZone);\r\n        return dataSource;\r\n    } finally {\r\n        caseDatabase.releaseSingleUserCaseWriteLock();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.ContextMenuExtensionPoint.getActions",
	"Comment": "gets all of the actions provided by registered implementers of thecontextmenuactionsprovider interface.",
	"Method": "List<Action> getActions(){\r\n    ArrayList<Action> actions = new ArrayList();\r\n    Collection<? extends ContextMenuActionsProvider> actionProviders = Lookup.getDefault().lookupAll(ContextMenuActionsProvider.class);\r\n    for (ContextMenuActionsProvider provider : actionProviders) {\r\n        List<Action> providerActions = provider.getActions();\r\n        if (!providerActions.isEmpty()) {\r\n            actions.add(null);\r\n            actions.addAll(provider.getActions());\r\n            actions.add(null);\r\n        }\r\n    }\r\n    return actions;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestManager.getInstance",
	"Comment": "gets the manager of the creation and execution of ingest jobs, i.e., theprocessing of data sources by ingest modules.",
	"Method": "IngestManager getInstance(){\r\n    if (null == instance) {\r\n        instance = new IngestManager();\r\n        instance.subscribeToServiceMonitorEvents();\r\n        instance.subscribeToCaseEvents();\r\n    }\r\n    return instance;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.AdHocSearchPanel.search",
	"Comment": "performs the search using the selected keywords. creates adataresulttopcomponent with the results.",
	"Method": "void search(boolean saveResults){\r\n    boolean isIngestRunning = IngestManager.getInstance().isIngestRunning();\r\n    if (filesIndexed == 0) {\r\n        try {\r\n            filesIndexed = KeywordSearch.getServer().queryNumIndexedFiles();\r\n        } catch (KeywordSearchModuleException | NoOpenCoreException ignored) {\r\n        }\r\n    }\r\n    if (filesIndexed == 0) {\r\n        if (isIngestRunning) {\r\n            KeywordSearchUtil.displayDialog(keywordSearchErrorDialogHeader, NbBundle.getMessage(this.getClass(), \"AbstractKeywordSearchPerformer.search.noFilesInIdxMsg\", KeywordSearchSettings.getUpdateFrequency().getTime()), KeywordSearchUtil.DIALOG_MESSAGE_TYPE.ERROR);\r\n        } else {\r\n            KeywordSearchUtil.displayDialog(keywordSearchErrorDialogHeader, NbBundle.getMessage(this.getClass(), \"AbstractKeywordSearchPerformer.search.noFilesIdxdMsg\"), KeywordSearchUtil.DIALOG_MESSAGE_TYPE.ERROR);\r\n        }\r\n        return;\r\n    }\r\n    if (isIngestRunning) {\r\n        if (KeywordSearchUtil.displayConfirmDialog(org.openide.util.NbBundle.getMessage(this.getClass(), \"AbstractKeywordSearchPerformer.search.searchIngestInProgressTitle\"), NbBundle.getMessage(this.getClass(), \"AbstractKeywordSearchPerformer.search.ingestInProgressBody\"), KeywordSearchUtil.DIALOG_MESSAGE_TYPE.WARN) == false) {\r\n            return;\r\n        }\r\n    }\r\n    final List<KeywordList> keywordLists = getKeywordLists();\r\n    if (keywordLists.isEmpty()) {\r\n        KeywordSearchUtil.displayDialog(keywordSearchErrorDialogHeader, NbBundle.getMessage(this.getClass(), \"AbstractKeywordSearchPerformer.search.emptyKeywordErrorBody\"), KeywordSearchUtil.DIALOG_MESSAGE_TYPE.ERROR);\r\n        return;\r\n    }\r\n    AdHocSearchDelegator man = new AdHocSearchDelegator(keywordLists, getDataSourcesSelected());\r\n    if (man.validate()) {\r\n        man.execute(saveResults);\r\n    } else {\r\n        KeywordSearchUtil.displayDialog(keywordSearchErrorDialogHeader, NbBundle.getMessage(this.getClass(), \"AbstractKeywordSearchPerformer.search.invalidSyntaxHeader\"), KeywordSearchUtil.DIALOG_MESSAGE_TYPE.ERROR);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.AbstractSqlEamDb.updateAttributeInstanceComment",
	"Comment": "update a correlation attribute instance in the database with that in theassociated correlationattribute object.",
	"Method": "void updateAttributeInstanceComment(CorrelationAttributeInstance eamArtifact){\r\n    if (eamArtifact == null) {\r\n        throw new EamDbException(\"CorrelationAttributeInstance is null\");\r\n    }\r\n    if (eamArtifact.getCorrelationCase() == null) {\r\n        throw new EamDbException(\"Correlation case is null\");\r\n    }\r\n    if (eamArtifact.getCorrelationDataSource() == null) {\r\n        throw new EamDbException(\"Correlation data source is null\");\r\n    }\r\n    Connection conn = connect();\r\n    PreparedStatement preparedQuery = null;\r\n    String tableName = EamDbUtil.correlationTypeToInstanceTableName(eamArtifact.getCorrelationType());\r\n    String sqlUpdate = \"UPDATE \" + tableName + \" SET comment=? \" + \"WHERE case_id=? \" + \"AND data_source_id=? \" + \"AND value=? \" + \"AND file_path=?\";\r\n    try {\r\n        preparedQuery = conn.prepareStatement(sqlUpdate);\r\n        preparedQuery.setString(1, eamArtifact.getComment());\r\n        preparedQuery.setInt(2, eamArtifact.getCorrelationCase().getID());\r\n        preparedQuery.setInt(3, eamArtifact.getCorrelationDataSource().getID());\r\n        preparedQuery.setString(4, eamArtifact.getCorrelationValue());\r\n        preparedQuery.setString(5, eamArtifact.getFilePath().toLowerCase());\r\n        preparedQuery.executeUpdate();\r\n    } catch (SQLException ex) {\r\n        throw new EamDbException(\"Error getting/setting artifact instance comment=\" + eamArtifact.getComment(), ex);\r\n    } finally {\r\n        EamDbUtil.closeStatement(preparedQuery);\r\n        EamDbUtil.closeConnection(conn);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.embeddedfileextractor.SevenZipExtractor.getRootArchiveId",
	"Comment": "get the data source object id of the root data source for the specifiedarchive",
	"Method": "long getRootArchiveId(AbstractFile file,long getRootArchiveId){\r\n    long id = file.getId();\r\n    Content parentContent = file.getParent();\r\n    while (parentContent != null) {\r\n        id = parentContent.getId();\r\n        parentContent = parentContent.getParent();\r\n    }\r\n    return id;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.utils.IntervalUtils.getIntervalAroundMiddle",
	"Comment": "get an interval the length of the given period, centered around thecenter of the given interval.",
	"Method": "Interval getIntervalAroundMiddle(Interval interval,ReadablePeriod period){\r\n    return getIntervalAround(middleOf(interval), period);\r\n}"
}, {
	"Path": "com.google.example.games.catt2.SnapshotCoordinator.isAlreadyOpen",
	"Comment": "returns true if the named file is already opened.this is a synchronizedoperation since it is highly likely that multiple threads are involved via asynctasks.",
	"Method": "boolean isAlreadyOpen(String filename){\r\n    return opened.containsKey(filename);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.SqliteEamDbSettings.getEphemeralConnection",
	"Comment": "use the current settings to get an ephemeral client connection fortesting.if the directory path does not exist, it will return null.",
	"Method": "Connection getEphemeralConnection(){\r\n    if (!dbDirectoryExists()) {\r\n        return null;\r\n    }\r\n    Connection conn;\r\n    try {\r\n        String url = getConnectionURL();\r\n        Class.forName(getDriver());\r\n        conn = DriverManager.getConnection(url);\r\n    } catch (ClassNotFoundException | SQLException ex) {\r\n        LOGGER.log(Level.SEVERE, \"Failed to acquire ephemeral connection to sqlite.\", ex);\r\n        conn = null;\r\n    }\r\n    return conn;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.DataResultPanel.setPath",
	"Comment": "sets the descriptive text about the source of the nodes displayed in thisresult view panel.",
	"Method": "void setPath(String description){\r\n    this.descriptionLabel.setText(description);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.NewCaseVisualPanel1.getCaseName",
	"Comment": "gets the case name that the user types on the case name text field.",
	"Method": "String getCaseName(){\r\n    return this.caseNameTextField.getText();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.SqliteEamDb.getArtifactInstancesByPath",
	"Comment": "retrieves eamartifact instances from the database that are associatedwith the atype and filepath",
	"Method": "List<CorrelationAttributeInstance> getArtifactInstancesByPath(CorrelationAttributeInstance.Type aType,String filePath){\r\n    try {\r\n        acquireSharedLock();\r\n        return super.getArtifactInstancesByPath(aType, filePath);\r\n    } finally {\r\n        releaseSharedLock();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.ui.detailview.tree.EventsTreeItem.configureNewTreeItem",
	"Comment": "configure initial properties that all eventstreeitems share.",
	"Method": "T configureNewTreeItem(T newTreeItem){\r\n    getChildren().add(newTreeItem);\r\n    newTreeItem.setExpanded(true);\r\n    sort(getComparator(), false);\r\n    return newTreeItem;\r\n}"
}, {
	"Path": "com.mcxiaoke.next.ui.endless.EndlessAdapter.getView",
	"Comment": "get a view that displays the data at the specifiedposition in the data set. in this case, if we are atthe end of the list and we are still in append mode, weask for a pending view and return it, plus kick off thebackground task to append more data to the wrappedadapter.",
	"Method": "View getView(int position,View convertView,ViewGroup parent){\r\n    if (position == super.getCount() && isFooterShowing()) {\r\n        return (mFooter);\r\n    }\r\n    return (super.getView(position, convertView, parent));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.test.CustomArtifactsCreatorIngestModuleFactory.getModuleDisplayName",
	"Comment": "gets the display name that identifies the family of ingest modules thefactory creates.",
	"Method": "String getModuleDisplayName(){\r\n    return getModuleName();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.configuration.AutoIngestUserPreferences.setAutoModeImageFolder",
	"Comment": "set input image folder for automated mode from persistent storage.",
	"Method": "void setAutoModeImageFolder(String folder){\r\n    ModuleSettings.setConfigSetting(UserPreferences.SETTINGS_PROPERTIES, AUTO_MODE_IMAGES_FOLDER, folder);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.DataSourceIngestJob.switchDataSourceIngestProgressBarToIndeterminate",
	"Comment": "switches the data source level ingest progress bar for this job toindeterminate mode. this should be called if the total work units toprocess the data source is unknown.",
	"Method": "void switchDataSourceIngestProgressBarToIndeterminate(){\r\n    if (this.doUI && !this.cancelled) {\r\n        synchronized (this.dataSourceIngestProgressLock) {\r\n            if (null != this.dataSourceIngestProgress) {\r\n                this.dataSourceIngestProgress.switchToIndeterminate();\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.Case.removePropertyChangeListener",
	"Comment": "removes a subscriber to all case events. to remove a subscription to onlyspecific events, use one of the overloads of removeeventsubscriber.",
	"Method": "void removePropertyChangeListener(PropertyChangeListener listener){\r\n    removeEventSubscriber(Stream.of(Events.values()).map(Events::toString).collect(Collectors.toSet()), listener);\r\n}"
}, {
	"Path": "com.mcxiaoke.next.collection.WeakFastHashMap.clone",
	"Comment": "return a shallow copy of this fasthashmap instance.the keys and values themselves are not copied.",
	"Method": "Object clone(){\r\n    WeakFastHashMap<K, V> results = null;\r\n    if (fast) {\r\n        results = new WeakFastHashMap<K, V>(map);\r\n    } else {\r\n        synchronized (map) {\r\n            results = new WeakFastHashMap<K, V>(map);\r\n        }\r\n    }\r\n    results.setFast(getFast());\r\n    return (results);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.SqliteEamDb.newCase",
	"Comment": "creates new case in the databaseexpects the organization for this case to already exist in the database.",
	"Method": "CorrelationCase newCase(Case autopsyCase,CorrelationCase newCase,CorrelationCase eamCase){\r\n    try {\r\n        acquireExclusiveLock();\r\n        return super.newCase(eamCase);\r\n    } finally {\r\n        releaseExclusiveLock();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.DataResultViewerTable.setColumnWidths",
	"Comment": "sets the column widths for the child outlineview of this tabular resultsviewer.",
	"Method": "void setColumnWidths(){\r\n    if (rootNode.getChildren().getNodesCount() != 0) {\r\n        final Graphics graphics = outlineView.getGraphics();\r\n        if (graphics != null) {\r\n            final FontMetrics metrics = graphics.getFontMetrics();\r\n            int margin = 4;\r\n            int padding = 8;\r\n            for (int column = 0; column < outline.getModel().getColumnCount(); column++) {\r\n                int firstColumnPadding = (column == 0) ? 32 : 0;\r\n                int columnWidthLimit = (column == 0) ? 350 : 300;\r\n                int valuesWidth = 0;\r\n                for (int row = 0; row < Math.min(100, outline.getRowCount()); row++) {\r\n                    TableCellRenderer renderer = outline.getCellRenderer(row, column);\r\n                    Component comp = outline.prepareRenderer(renderer, row, column);\r\n                    valuesWidth = Math.max(comp.getPreferredSize().width, valuesWidth);\r\n                }\r\n                int headerWidth = metrics.stringWidth(outline.getColumnName(column));\r\n                valuesWidth += firstColumnPadding;\r\n                int columnWidth = Math.max(valuesWidth, headerWidth);\r\n                columnWidth += 2 * margin + padding;\r\n                columnWidth = Math.min(columnWidth, columnWidthLimit);\r\n                outline.getColumnModel().getColumn(column).setPreferredWidth(columnWidth);\r\n            }\r\n        }\r\n    } else {\r\n        outline.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.PlatformUtil.getJavaPath",
	"Comment": "get file path to the java executable binary use embedded java ifavailable, otherwise use system java in path no validation is done ifjava exists in path",
	"Method": "String getJavaPath(){\r\n    if (javaPath != null) {\r\n        return javaPath;\r\n    }\r\n    File jrePath = new File(getInstallPath() + File.separator + \"jre\");\r\n    if (jrePath.exists() && jrePath.isDirectory()) {\r\n        System.out.println(NbBundle.getMessage(PlatformUtil.class, \"PlatformUtil.jrePath.jreDir.msg\", jrePath.getAbsolutePath()));\r\n        javaPath = jrePath.getAbsolutePath() + File.separator + \"bin\" + File.separator + \"java\";\r\n    } else {\r\n        javaPath = \"java\";\r\n    }\r\n    System.out.println(NbBundle.getMessage(PlatformUtil.class, \"PlatformUtil.jrePath.usingJavaPath.msg\", javaPath));\r\n    return javaPath;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.fileextmismatch.FileExtMismatchDetectorModuleSettings.setCheckType",
	"Comment": "sets whether extension mismatches should be checked for all files, forall files except text files, or for media and executable files only.",
	"Method": "void setCheckType(CHECK_TYPE checkType){\r\n    this.checkType = checkType;\r\n}"
}, {
	"Path": "com.mcxiaoke.next.collection.WeakFastHashMap.containsKey",
	"Comment": "return true if this map contains a mapping for thespecified key.",
	"Method": "boolean containsKey(Object key){\r\n    if (fast) {\r\n        return (map.containsKey(key));\r\n    } else {\r\n        synchronized (map) {\r\n            return (map.containsKey(key));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.litesuits.http.impl.apache.DefaultHttpRequestRetryHandler.retryRequest",
	"Comment": "used retrycount and requestsentretryenabled to determineif the given method should be retried.",
	"Method": "boolean retryRequest(IOException exception,int executionCount,HttpContext context,boolean retryRequest,HttpContext context){\r\n    final HttpRequest request = (HttpRequest) context.getAttribute(ExecutionContext.HTTP_REQUEST);\r\n    final Object obj = context.getAttribute(ExecutionContext.HTTP_REQ_SENT);\r\n    final boolean isSent = obj == null ? false : (Boolean) obj;\r\n    if (requestIsAborted(request)) {\r\n        return false;\r\n    }\r\n    if (handleAsIdempotent(request)) {\r\n        return true;\r\n    }\r\n    if (!isSent || this.requestSentRetryEnabled) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.AddImageWizardAddingProgressPanel.startDataSourceProcessing",
	"Comment": "starts the data source processing by kicking off the selecteddatasourceprocessor",
	"Method": "void startDataSourceProcessing(DataSourceProcessor dsp){\r\n    if (dsProcessor == null) {\r\n        final UUID dataSourceId = UUID.randomUUID();\r\n        newContents.clear();\r\n        cleanupTask = null;\r\n        readyToIngest = false;\r\n        dsProcessor = dsp;\r\n        cleanupTask = addImageAction.new CleanupTask() {\r\n            @Override\r\n            void cleanup() throws Exception {\r\n                WindowManager.getDefault().getMainWindow().setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\r\n                cancelDataSourceProcessing(dataSourceId);\r\n                cancelled = true;\r\n                WindowManager.getDefault().getMainWindow().setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));\r\n            }\r\n        };\r\n        cleanupTask.enable();\r\n        new Thread(() -> {\r\n            try {\r\n                Case.getCurrentCaseThrows().notifyAddingDataSource(dataSourceId);\r\n            } catch (NoCurrentCaseException ex) {\r\n                Logger.getLogger(AddImageWizardAddingProgressVisual.class.getName()).log(Level.SEVERE, \"Exception while getting open case.\", ex);\r\n            }\r\n        }).start();\r\n        DataSourceProcessorCallback cbObj = new DataSourceProcessorCallback() {\r\n            @Override\r\n            public void doneEDT(DataSourceProcessorCallback.DataSourceProcessorResult result, List<String> errList, List<Content> contents) {\r\n                dataSourceProcessorDone(dataSourceId, result, errList, contents);\r\n            }\r\n        };\r\n        setStateStarted();\r\n        dsProcessor.run(getDSPProgressMonitorImpl(), cbObj);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.AddImageWizardAddingProgressPanel.startDataSourceProcessing",
	"Comment": "starts the data source processing by kicking off the selecteddatasourceprocessor",
	"Method": "void startDataSourceProcessing(DataSourceProcessor dsp){\r\n    WindowManager.getDefault().getMainWindow().setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\r\n    cancelDataSourceProcessing(dataSourceId);\r\n    cancelled = true;\r\n    WindowManager.getDefault().getMainWindow().setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.AddImageWizardAddingProgressPanel.startDataSourceProcessing",
	"Comment": "starts the data source processing by kicking off the selecteddatasourceprocessor",
	"Method": "void startDataSourceProcessing(DataSourceProcessor dsp){\r\n    dataSourceProcessorDone(dataSourceId, result, errList, contents);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.eventlisteners.IngestEventsListener.uninstallListeners",
	"Comment": "remove all of our ingest event listeners from the ingestmanager instance.",
	"Method": "void uninstallListeners(){\r\n    IngestManager.getInstance().removeIngestModuleEventListener(pcl1);\r\n    IngestManager.getInstance().removeIngestJobEventListener(pcl2);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.filetypeid.FileTypeDetector.getFileType",
	"Comment": "gets the mime type of a file, detecting it if it is not already known. ifdetection is necessary, the result is added to the case database.",
	"Method": "String getFileType(AbstractFile file){\r\n    String fileType = getMIMEType(file);\r\n    file.setMIMEType(fileType);\r\n    file.save();\r\n    return fileType;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.DataSourceIngestJob.finishFirstStage",
	"Comment": "shuts down the first stage ingest pipelines and progress bars for thisjob and starts the second stage, if appropriate.",
	"Method": "void finishFirstStage(){\r\n    logger.log(Level.INFO, \"Finished first stage analysis for {0} (jobId={1})\", new Object[] { dataSource.getName(), this.id });\r\n    List<IngestModuleError> errors = new ArrayList();\r\n    while (!this.fileIngestPipelinesQueue.isEmpty()) {\r\n        FileIngestPipeline pipeline = fileIngestPipelinesQueue.poll();\r\n        if (pipeline.isRunning()) {\r\n            errors.addAll(pipeline.shutDown());\r\n        }\r\n    }\r\n    if (!errors.isEmpty()) {\r\n        logIngestModuleErrors(errors);\r\n    }\r\n    if (this.doUI) {\r\n        synchronized (this.dataSourceIngestProgressLock) {\r\n            if (this.dataSourceIngestProgress != null) {\r\n                this.dataSourceIngestProgress.finish();\r\n                this.dataSourceIngestProgress = null;\r\n            }\r\n        }\r\n        synchronized (this.fileIngestProgressLock) {\r\n            if (this.fileIngestProgress != null) {\r\n                this.fileIngestProgress.finish();\r\n                this.fileIngestProgress = null;\r\n            }\r\n        }\r\n    }\r\n    if (!this.cancelled && this.hasSecondStageDataSourceIngestPipeline()) {\r\n        this.startSecondStage();\r\n    } else {\r\n        this.finish();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.filetypeid.AddFileTypeDialog.doButtonAction",
	"Comment": "performs actions on the fields based on whether the ok button was pressedor not.",
	"Method": "void doButtonAction(boolean okPressed){\r\n    if (okPressed) {\r\n        FileType fType = addMimeTypePanel.getFileType();\r\n        if (fType != null) {\r\n            this.fileType = fType;\r\n            this.result = BUTTON_PRESSED.OK;\r\n            setVisible(false);\r\n        }\r\n    } else {\r\n        this.fileType = null;\r\n        this.result = BUTTON_PRESSED.CANCEL;\r\n        setVisible(false);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.directorytree.AddExternalViewerRulePanel.hasFields",
	"Comment": "check if the text fields are filled and if a radio button is selected.",
	"Method": "boolean hasFields(){\r\n    return !exePathTextField.getText().isEmpty() && !nameTextField.getText().isEmpty() && (mimeRadioButton.isSelected() || extRadioButton.isSelected());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.MultiUserSettingsPanel.solrFieldsArePopulated",
	"Comment": "tests whether or not values have been entered in all of the solr settingstext fields.",
	"Method": "boolean solrFieldsArePopulated(){\r\n    return !tbSolrHostname.getText().trim().isEmpty() && !tbSolrPort.getText().trim().isEmpty();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.datamodel.DisplayableItemNode.getChildNodeSelectionInfo",
	"Comment": "gets information about which child node of this node, if any, should beselected.",
	"Method": "NodeSelectionInfo getChildNodeSelectionInfo(){\r\n    return selectedChildNodeInfo;\r\n}"
}, {
	"Path": "net.dongliu.apk.parser.cert.asn1.Asn1BerParser.parse",
	"Comment": "returns the asn.1 structure contained in the ber encoded input.",
	"Method": "T parse(ByteBuffer encoded,Class<T> containerClass,T parse,BerDataValue container,Class<T> containerClass){\r\n    if (container == null) {\r\n        throw new NullPointerException(\"container == null\");\r\n    }\r\n    if (containerClass == null) {\r\n        throw new NullPointerException(\"containerClass == null\");\r\n    }\r\n    Asn1Type dataType = getContainerAsn1Type(containerClass);\r\n    switch(dataType) {\r\n        case CHOICE:\r\n            return parseChoice(container, containerClass);\r\n        case SEQUENCE:\r\n            {\r\n                int expectedTagClass = BerEncoding.TAG_CLASS_UNIVERSAL;\r\n                int expectedTagNumber = BerEncoding.getTagNumber(dataType);\r\n                if ((container.getTagClass() != expectedTagClass) || (container.getTagNumber() != expectedTagNumber)) {\r\n                    throw new Asn1UnexpectedTagException(\"Unexpected data value read as \" + containerClass.getName() + \". Expected \" + BerEncoding.tagClassAndNumberToString(expectedTagClass, expectedTagNumber) + \", but read: \" + BerEncoding.tagClassAndNumberToString(container.getTagClass(), container.getTagNumber()));\r\n                }\r\n                return parseSequence(container, containerClass);\r\n            }\r\n        default:\r\n            throw new Asn1DecodingException(\"Parsing container \" + dataType + \" not supported\");\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.core.UserPreferences.reloadFromStorage",
	"Comment": "reload all preferences from disk. this is only needed if the preferencesfile is being directly modified on disk while autopsy is running.",
	"Method": "void reloadFromStorage(){\r\n    preferences.sync();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.healthmonitor.HealthMonitor.shutdown",
	"Comment": "called when the application is closing. create a log off event and writeall existing metrics to the database",
	"Method": "void shutdown(){\r\n    getInstance().addUserEvent(UserEvent.LOG_OFF);\r\n    recordMetrics();\r\n}"
}, {
	"Path": "com.aliyun.oss.model.UploadPartCopyResult.getETag",
	"Comment": "gets the etag generated by oss.oss would send the md5 value of the parts data received to user in theetag header. to make sure the data transferred is 100% correct, westrongly encouraged user to check the server side md5 with the localcomputed md5 value.",
	"Method": "String getETag(){\r\n    return eTag;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.communications.LockedVertexModel.unlock",
	"Comment": "unlock the given vertices so that applying a layout algorithm can movethem.",
	"Method": "void unlock(Collection<mxCell> vertices){\r\n    lockedVertices.removeAll(vertices);\r\n    eventBus.post(new VertexLockEvent(false, vertices));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.NewCaseWizardPanel2.getHelp",
	"Comment": "gets the help object for this panel. when the panel is active, this isused as the help for the wizard dialog.",
	"Method": "HelpCtx getHelp(){\r\n    return HelpCtx.DEFAULT_HELP;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.volatilityDSP.VolatilityProcessor.locateVolatilityExecutable",
	"Comment": "finds and returns the path to the volatility executable, if able.",
	"Method": "File locateVolatilityExecutable(){\r\n    if (!PlatformUtil.isWindowsOS()) {\r\n        return null;\r\n    }\r\n    String executableToFindName = Paths.get(VOLATILITY, VOLATILITY_EXECUTABLE).toString();\r\n    File exeFile = InstalledFileLocator.getDefault().locate(executableToFindName, VolatilityProcessor.class.getPackage().getName(), false);\r\n    if (null == exeFile) {\r\n        return null;\r\n    }\r\n    if (!exeFile.canExecute()) {\r\n        return null;\r\n    }\r\n    return exeFile;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.actions.GetTagNameAndCommentDialog.doDialog",
	"Comment": "show the tag name and comment dialog and return the tagnameandcontentchosen by the user.",
	"Method": "TagNameAndComment doDialog(TagNameAndComment doDialog,Window owner){\r\n    GetTagNameAndCommentDialog dialog = new GetTagNameAndCommentDialog(owner);\r\n    dialog.display();\r\n    return dialog.getTagNameAndComment();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.directorytree.DirectoryTreeTopComponent.setShowRejectedResults",
	"Comment": "setter to determine if rejected results should be shown or not.",
	"Method": "void setShowRejectedResults(boolean showRejectedResults){\r\n    this.showRejectedResults = showRejectedResults;\r\n    if (accounts != null) {\r\n        accounts.setShowRejected(showRejectedResults);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.OpenTimelineAction.invalidateController",
	"Comment": "invalidate the reference to the controller so that a new one will beinstantiated the next time this action is invoked",
	"Method": "void invalidateController(){\r\n    timeLineController = null;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJobNodeData.setNumberOfCrashes",
	"Comment": "sets the number of times the job has crashed during processing.",
	"Method": "void setNumberOfCrashes(int numberOfCrashes){\r\n    this.numberOfCrashes = numberOfCrashes;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.configuration.SharedConfiguration.copyLocalFolderToRemoteFolder",
	"Comment": "copy an entire local settings folder to the remote folder, deleting any existing files.",
	"Method": "void copyLocalFolderToRemoteFolder(File localFolder,File remoteBaseFolder){\r\n    logger.log(Level.INFO, \"Uploading {0} to {1}\", new Object[] { localFolder.getAbsolutePath(), remoteBaseFolder.getAbsolutePath() });\r\n    File newRemoteFolder = new File(remoteBaseFolder, localFolder.getName());\r\n    if (newRemoteFolder.exists()) {\r\n        try {\r\n            FileUtils.deleteDirectory(newRemoteFolder);\r\n        } catch (IOException ex) {\r\n            logger.log(Level.SEVERE, \"Failed to delete remote folder {0}\", newRemoteFolder.getAbsolutePath());\r\n            throw new SharedConfigurationException(String.format(\"Failed to delete remote folder {0}\", newRemoteFolder.getAbsolutePath()), ex);\r\n        }\r\n    }\r\n    try {\r\n        FileUtils.copyDirectoryToDirectory(localFolder, remoteBaseFolder);\r\n    } catch (IOException ex) {\r\n        throw new SharedConfigurationException(String.format(\"Failed to copy %s to %s\", localFolder, remoteBaseFolder.getAbsolutePath()), ex);\r\n    }\r\n}"
}, {
	"Path": "com.aliyun.oss.internal.ResponseParsers.parseDeleteObjectsResult",
	"Comment": "unmarshall delete objects response body to corresponding result.",
	"Method": "DeleteObjectsResult parseDeleteObjectsResult(InputStream responseBody){\r\n    try {\r\n        Element root = getXmlRootElement(responseBody);\r\n        DeleteObjectsResult deleteObjectsResult = new DeleteObjectsResult();\r\n        if (root.getChild(\"EncodingType\") != null) {\r\n            String encodingType = root.getChildText(\"EncodingType\");\r\n            deleteObjectsResult.setEncodingType(isNullOrEmpty(encodingType) ? null : encodingType);\r\n        }\r\n        List<String> deletedObjects = new ArrayList<String>();\r\n        List<Element> deletedElements = root.getChildren(\"Deleted\");\r\n        for (Element elem : deletedElements) {\r\n            deletedObjects.add(elem.getChildText(\"Key\"));\r\n        }\r\n        deleteObjectsResult.setDeletedObjects(deletedObjects);\r\n        return deleteObjectsResult;\r\n    } catch (JDOMParseException e) {\r\n        throw new ResponseParseException(e.getPartialDocument() + \": \" + e.getMessage(), e);\r\n    } catch (Exception e) {\r\n        throw new ResponseParseException(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.directorytree.DirectoryTreeFilterNode.getDisplayName",
	"Comment": "gets the display name for the wrapped node, possibly including a childcount in parentheses.",
	"Method": "String getDisplayName(){\r\n    final Node orig = getOriginal();\r\n    String name = orig.getDisplayName();\r\n    if (orig instanceof AbstractContentNode) {\r\n        AbstractFile file = getLookup().lookup(AbstractFile.class);\r\n        if ((file != null) && (false == (orig instanceof BlackboardArtifactNode))) {\r\n            try {\r\n                int numVisibleChildren = getVisibleChildCount(file);\r\n                name = name + \" ?(?\" + numVisibleChildren + \")?\";\r\n            } catch (TskCoreException ex) {\r\n                logger.log(Level.SEVERE, \"Error getting children count to display for file: \" + file, ex);\r\n            }\r\n        } else if (orig instanceof BlackboardArtifactNode) {\r\n            BlackboardArtifact artifact = ((BlackboardArtifactNode) orig).getArtifact();\r\n            try {\r\n                int numAttachments = artifact.getChildrenCount();\r\n                name = name + \" ?(?\" + numAttachments + \")?\";\r\n            } catch (TskCoreException ex) {\r\n                logger.log(Level.SEVERE, \"Error getting chidlren count for atifact: \" + artifact, ex);\r\n            }\r\n        }\r\n    }\r\n    return name;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.AbstractSqlEamDb.getArtifactInstancesByTypeValue",
	"Comment": "retrieves eamartifact instances from the database that are associatedwith the eamartifacttype and eamartifactvalue of the given eamartifact.",
	"Method": "List<CorrelationAttributeInstance> getArtifactInstancesByTypeValue(CorrelationAttributeInstance.Type aType,String value){\r\n    String normalizedValue = CorrelationAttributeNormalizer.normalize(aType, value);\r\n    Connection conn = connect();\r\n    List<CorrelationAttributeInstance> artifactInstances = new ArrayList();\r\n    CorrelationAttributeInstance artifactInstance;\r\n    PreparedStatement preparedStatement = null;\r\n    ResultSet resultSet = null;\r\n    String tableName = EamDbUtil.correlationTypeToInstanceTableName(aType);\r\n    String sql = \"SELECT \" + tableName + \".id,\" + tableName + \".value,\" + tableName + \".file_obj_id,\" + \" cases.case_name, cases.case_uid, data_sources.id AS data_source_id, data_sources.name, device_id, file_path, known_status, comment, data_sources.case_id, data_sources.datasource_obj_id FROM \" + tableName + \" LEFT JOIN cases ON \" + tableName + \".case_id=cases.id\" + \" LEFT JOIN data_sources ON \" + tableName + \".data_source_id=data_sources.id\" + \" WHERE value=?\";\r\n    try {\r\n        preparedStatement = conn.prepareStatement(sql);\r\n        preparedStatement.setString(1, normalizedValue);\r\n        resultSet = preparedStatement.executeQuery();\r\n        while (resultSet.next()) {\r\n            artifactInstance = getEamArtifactInstanceFromResultSet(resultSet, aType);\r\n            artifactInstances.add(artifactInstance);\r\n        }\r\n    } catch (SQLException ex) {\r\n        throw new EamDbException(\"Error getting artifact instances by artifactType and artifactValue.\", ex);\r\n    } finally {\r\n        EamDbUtil.closeStatement(preparedStatement);\r\n        EamDbUtil.closeResultSet(resultSet);\r\n        EamDbUtil.closeConnection(conn);\r\n    }\r\n    return artifactInstances;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.ImageUtils.getDefaultThumbnail",
	"Comment": "get the default thumbnail, which is the icon for a file. used when we cannot generate a content based thumbnail.",
	"Method": "Image getDefaultThumbnail(){\r\n    return DEFAULT_THUMBNAIL;\r\n}"
}, {
	"Path": "com.google.example.games.catt2.SnapshotCoordinator.getInstance",
	"Comment": "singleton for coordinating the snapshots api.this is important sincewe need to coordinate all operations through the same instance in order todetect usages that would cause data corruption.",
	"Method": "SnapshotCoordinator getInstance(){\r\n    return theInstance;\r\n}"
}, {
	"Path": "com.aliyun.oss.internal.ResponseParsers.parseGetBucketReferer",
	"Comment": "unmarshall get bucket referer response body to bucket referer list.",
	"Method": "BucketReferer parseGetBucketReferer(InputStream responseBody){\r\n    try {\r\n        Element root = getXmlRootElement(responseBody);\r\n        boolean allowEmptyReferer = Boolean.valueOf(root.getChildText(\"AllowEmptyReferer\"));\r\n        List<String> refererList = new ArrayList<String>();\r\n        if (root.getChild(\"RefererList\") != null) {\r\n            Element refererListElem = root.getChild(\"RefererList\");\r\n            List<Element> refererElems = refererListElem.getChildren(\"Referer\");\r\n            if (refererElems != null && !refererElems.isEmpty()) {\r\n                for (Element e : refererElems) {\r\n                    refererList.add(e.getText());\r\n                }\r\n            }\r\n        }\r\n        return new BucketReferer(allowEmptyReferer, refererList);\r\n    } catch (JDOMParseException e) {\r\n        throw new ResponseParseException(e.getPartialDocument() + \": \" + e.getMessage(), e);\r\n    } catch (Exception e) {\r\n        throw new ResponseParseException(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.NewCaseWizardPanel2.storeSettings",
	"Comment": "provides the wizard panel with the opportunity to update the settingswith its current customized state. rather than updating its settings withevery change in the gui, it should collect them, and then only save themwhen requested to by this method. this method can be called multipletimes on one instance of wizarddescriptor.panel.",
	"Method": "void storeSettings(WizardDescriptor settings){\r\n    settings.putProperty(\"caseNumber\", component.getCaseNumber());\r\n    settings.putProperty(\"caseExaminerName\", component.getExaminerName());\r\n    ModuleSettings.setConfigSetting(ModuleSettings.MAIN_SETTINGS, PROP_EXAMINER_NAME, component.getExaminerName());\r\n    settings.putProperty(\"caseExaminerPhone\", component.getExaminerPhone());\r\n    ModuleSettings.setConfigSetting(ModuleSettings.MAIN_SETTINGS, PROP_EXAMINER_PHONE, component.getExaminerPhone());\r\n    settings.putProperty(\"caseExaminerEmail\", component.getExaminerEmail());\r\n    ModuleSettings.setConfigSetting(ModuleSettings.MAIN_SETTINGS, PROP_EXAMINER_EMAIL, component.getExaminerEmail());\r\n    settings.putProperty(\"caseNotes\", component.getCaseNotes());\r\n    settings.putProperty(\"caseOrganization\", component.getOrganization());\r\n    ModuleSettings.setConfigSetting(ModuleSettings.MAIN_SETTINGS, PROP_ORGANIZATION_NAME, component.getOrganization());\r\n}"
}, {
	"Path": "org.wikipedia.util.StringUtil.md5string",
	"Comment": "creates an md5 hash of the provided string and returns its ascii representation",
	"Method": "String md5string(String s){\r\n    StringBuilder hexStr = new StringBuilder();\r\n    try {\r\n        MessageDigest digest = java.security.MessageDigest.getInstance(\"MD5\");\r\n        digest.update(s.getBytes(\"utf-8\"));\r\n        byte[] messageDigest = digest.digest();\r\n        final int maxByteVal = 0xFF;\r\n        for (byte b : messageDigest) {\r\n            hexStr.append(Integer.toHexString(maxByteVal & b));\r\n        }\r\n    } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n    return hexStr.toString();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestJobSettings.getModuleSettingsFilePath",
	"Comment": "returns the absolute path for the ingest job settings file for a giveningest module for these ingest job settings.",
	"Method": "String getModuleSettingsFilePath(IngestModuleFactory factory){\r\n    String fileName = FactoryClassNameNormalizer.normalize(factory.getClass().getCanonicalName()) + IngestJobSettings.MODULE_SETTINGS_FILE_EXT;\r\n    Path path = Paths.get(this.moduleSettingsFolderPath, fileName);\r\n    return path.toAbsolutePath().toString();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.ui.ViewFrame.setTimeNavigationControls",
	"Comment": "show the given list of nodes in the time range toolbar. replaces anynodes that may have previously been set with the given list of nodes.",
	"Method": "void setTimeNavigationControls(List<Node> timeNavigationNodes){\r\n    timeRangeToolBar.getItems().removeAll(this.timeNavigationNodes);\r\n    this.timeNavigationNodes.setAll(timeNavigationNodes);\r\n    timeRangeToolBar.getItems().addAll(TIME_TOOLBAR_INSERTION_INDEX, timeNavigationNodes);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.DataResultViewerTable.storeColumnSorting",
	"Comment": "persists the current column sorting information using a preferences file.",
	"Method": "void storeColumnSorting(){\r\n    if (rootNode == null || propertiesMap.isEmpty()) {\r\n        return;\r\n    }\r\n    if (rootNode instanceof TableFilterNode) {\r\n        final TableFilterNode tfn = ((TableFilterNode) rootNode);\r\n        final Preferences preferences = NbPreferences.forModule(DataResultViewerTable.class);\r\n        ETableColumnModel columnModel = (ETableColumnModel) outline.getColumnModel();\r\n        for (Map.Entry<String, ETableColumn> entry : columnMap.entrySet()) {\r\n            ETableColumn etc = entry.getValue();\r\n            String columnName = entry.getKey();\r\n            final String columnSortOrderKey = ResultViewerPersistence.getColumnSortOrderKey(tfn, columnName);\r\n            final String columnSortRankKey = ResultViewerPersistence.getColumnSortRankKey(tfn, columnName);\r\n            if (etc.isSorted() && (columnModel.isColumnHidden(etc) == false)) {\r\n                preferences.putBoolean(columnSortOrderKey, etc.isAscending());\r\n                preferences.putInt(columnSortRankKey, etc.getSortRank());\r\n            } else {\r\n                columnModel.setColumnSorted(etc, true, 0);\r\n                preferences.remove(columnSortOrderKey);\r\n                preferences.remove(columnSortRankKey);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.TimeLineController.rebuildTagsTable",
	"Comment": "drop the tags table and rebuild it in the background, and show thetimeline when done.",
	"Method": "void rebuildTagsTable(AbstractFile file,BlackboardArtifact artifact){\r\n    rebuildRepoHelper(eventsRepository::rebuildTags, false, file, artifact);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.ui.AbstractTimeLineView.hasVisibleEvents",
	"Comment": "are there are any events visible in this view with the current viewparameters?",
	"Method": "boolean hasVisibleEvents(){\r\n    return hasVisibleEventsProperty().get();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.ui.ViewFrame.localDateTimeToEpochMilli",
	"Comment": "convert the given localdatetime to epoch millis using the currenttimezone from the timelinecontroller",
	"Method": "long localDateTimeToEpochMilli(LocalDateTime localDateTime){\r\n    return localDateTime.atZone(TimeLineController.getTimeZoneID()).toInstant().toEpochMilli();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.ImageDSProcessor.reset",
	"Comment": "resets the selection and configuration panel for this data sourceprocessor.",
	"Method": "void reset(){\r\n    deviceId = null;\r\n    imagePath = null;\r\n    timeZone = null;\r\n    ignoreFatOrphanFiles = false;\r\n    configPanel.reset();\r\n    setDataSourceOptionsCalled = false;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.ingestmodule.CentralRepoIngestModule.sendBadFileInboxMessage",
	"Comment": "post a message to the ingest inbox alerting the user that a bad file wasfound.",
	"Method": "void sendBadFileInboxMessage(BlackboardArtifact artifact,String name,String md5Hash){\r\n    StringBuilder detailsSb = new StringBuilder();\r\n    detailsSb.append(\"<table border='0' cellpadding='4' width='280'>\");\r\n    detailsSb.append(\"<tr>\");\r\n    // NON-NLS\r\n    detailsSb.append(\"<th>\").append(Bundle.CentralRepoIngestModule_postToBB_fileName()).append(\"<\/th>\");\r\n    // NON-NLS\r\n    detailsSb.append(\"<td>\").append(name).append(\"<\/td>\");\r\n    detailsSb.append(\"<\/tr>\");\r\n    detailsSb.append(\"<tr>\");\r\n    // NON-NLS\r\n    detailsSb.append(\"<th>\").append(Bundle.CentralRepoIngestModule_postToBB_md5Hash()).append(\"<\/th>\");\r\n    detailsSb.append(\"<td>\").append(md5Hash).append(\"<\/td>\");\r\n    detailsSb.append(\"<\/tr>\");\r\n    detailsSb.append(\"<tr>\");\r\n    // NON-NLS\r\n    detailsSb.append(\"<th>\").append(Bundle.CentralRepoIngestModule_postToBB_hashSetSource()).append(\"<\/th>\");\r\n    detailsSb.append(\"<td>\").append(Bundle.CentralRepoIngestModule_postToBB_eamHit()).append(\"<\/td>\");\r\n    detailsSb.append(\"<\/tr>\");\r\n    detailsSb.append(\"<\/table>\");\r\n    services.postMessage(IngestMessage.createDataMessage(CentralRepoIngestModuleFactory.getModuleName(), Bundle.CentralRepoIngestModule_postToBB_knownBadMsg(name), detailsSb.toString(), name + md5Hash, artifact));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.FileIngestPipeline.isEmpty",
	"Comment": "queries whether or not there are any ingest modules in this pipeline.",
	"Method": "boolean isEmpty(){\r\n    return this.modules.isEmpty();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.interestingitems.FilesSetRulePanel.updateNameTextFieldPrompt",
	"Comment": "update the text prompt of the name text field based on the input typeselection.",
	"Method": "void updateNameTextFieldPrompt(){\r\n    String text;\r\n    if (fullNameRadioButton.isSelected()) {\r\n        text = Bundle.FilesSetRulePanel_nameTextField_fullNameExample();\r\n    } else {\r\n        text = Bundle.FilesSetRulePanel_nameTextField_extensionExample();\r\n    }\r\n    nameTextFieldPrompt = new TextPrompt(text, nameTextField);\r\n    nameTextFieldPrompt.setForeground(Color.LIGHT_GRAY);\r\n    nameTextFieldPrompt.changeAlpha(0.9f);\r\n    validate();\r\n    repaint();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.contentviewers.MessageContentViewer.getAssociatedArtifact",
	"Comment": "get the artifact associated with the given artifact, if there is one.",
	"Method": "Optional<BlackboardArtifact> getAssociatedArtifact(BlackboardArtifact artifact){\r\n    BlackboardAttribute attribute = artifact.getAttribute(TSK_ASSOCIATED_TYPE);\r\n    if (attribute != null) {\r\n        return Optional.of(artifact.getSleuthkitCase().getArtifactByArtifactId(attribute.getValueLong()));\r\n    }\r\n    return Optional.empty();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJob.getErrorsOccurred",
	"Comment": "queries whether or not errors occurred during the processing of the job.",
	"Method": "boolean getErrorsOccurred(){\r\n    return this.errorsOccurred;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestJobSettings.getEnabledIngestModuleTemplates",
	"Comment": "gets the enabled ingest module templates for this ingest job.",
	"Method": "List<IngestModuleTemplate> getEnabledIngestModuleTemplates(){\r\n    List<IngestModuleTemplate> enabledModuleTemplates = new ArrayList();\r\n    for (IngestModuleTemplate moduleTemplate : this.moduleTemplates) {\r\n        if (moduleTemplate.isEnabled()) {\r\n            enabledModuleTemplates.add(moduleTemplate);\r\n        }\r\n    }\r\n    return enabledModuleTemplates;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.TableReportGenerator.writeTableForDataType",
	"Comment": "write the given list of artifacts to the table for the given type.",
	"Method": "void writeTableForDataType(List<ArtifactData> artifactList,BlackboardArtifact.Type type,String tableName,String comment){\r\n    Set<BlackboardAttribute.Type> attrTypeSet = new TreeSet(Comparator.comparing(BlackboardAttribute.Type::getDisplayName));\r\n    for (ArtifactData data : artifactList) {\r\n        List<BlackboardAttribute> attributes = data.getAttributes();\r\n        for (BlackboardAttribute attribute : attributes) {\r\n            attrTypeSet.add(attribute.getAttributeType());\r\n        }\r\n    }\r\n    List<Column> columns = getArtifactTableColumns(type.getTypeID(), attrTypeSet);\r\n    if (columns.isEmpty()) {\r\n        return;\r\n    }\r\n    columnHeaderMap.put(type.getTypeID(), columns);\r\n    Collections.sort(artifactList);\r\n    tableReport.startDataType(tableName, comment);\r\n    tableReport.startTable(Lists.transform(columns, Column::getColumnHeader));\r\n    for (ArtifactData artifactData : artifactList) {\r\n        List<String> rowData = artifactData.getRow();\r\n        if (rowData.isEmpty()) {\r\n            return;\r\n        }\r\n        tableReport.addRow(rowData);\r\n    }\r\n    progressPanel.increment();\r\n    tableReport.endTable();\r\n    tableReport.endDataType();\r\n}"
}, {
	"Path": "net.ypresto.androidtranscoder.engine.InputSurface.release",
	"Comment": "discard all resources held by this class, notably the egl context.also releases thesurface that was passed to our constructor.",
	"Method": "void release(){\r\n    if (mEGLDisplay != EGL14.EGL_NO_DISPLAY) {\r\n        EGL14.eglDestroySurface(mEGLDisplay, mEGLSurface);\r\n        EGL14.eglDestroyContext(mEGLDisplay, mEGLContext);\r\n        EGL14.eglReleaseThread();\r\n        EGL14.eglTerminate(mEGLDisplay);\r\n    }\r\n    mSurface.release();\r\n    mEGLDisplay = EGL14.EGL_NO_DISPLAY;\r\n    mEGLContext = EGL14.EGL_NO_CONTEXT;\r\n    mEGLSurface = EGL14.EGL_NO_SURFACE;\r\n    mSurface = null;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.DropdownSingleTermSearchPanel.searchButtonActionPerformed",
	"Comment": "action performed by the action listener for the search button.",
	"Method": "void searchButtonActionPerformed(java.awt.event.ActionEvent evt){\r\n    keywordTextFieldActionPerformed(evt);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.vmextractor.VirtualMachineFinder.readExtentFilesFromVmdkDescriptorFile",
	"Comment": "opens vmdk descriptor file, finds and returns a list of all vmdk extentfiles listed in the descriptor file.",
	"Method": "List<String> readExtentFilesFromVmdkDescriptorFile(File file){\r\n    List<String> extentFiles = new ArrayList();\r\n    try (BufferedReader br = new BufferedReader(new FileReader(file))) {\r\n        String line = br.readLine();\r\n        while (null != line) {\r\n            String[] splited = line.split(\" \");\r\n            if (splited.length < MIN_VMDK_EXTENT_DESCRIPTOR_FIELDS) {\r\n                continue;\r\n            }\r\n            if (splited[0].equals(\"RW\") || splited[0].equals(\"RDONLY\") || splited[0].equals(\"NOACCESS\")) {\r\n                String extentFileName = splited[FILE_NAME_FIELD_INDX].replace(\"\\\"\", \"\");\r\n                extentFiles.add(extentFileName);\r\n            }\r\n            line = br.readLine();\r\n        }\r\n    } catch (Exception ex) {\r\n        logger.log(Level.WARNING, String.format(\"Error while parsing vmdk descriptor file %s\", file.toString()), ex);\r\n    }\r\n    return extentFiles;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJob.setErrorsOccurred",
	"Comment": "sets whether or not errors occurred during the processing of the job.",
	"Method": "void setErrorsOccurred(boolean errorsOccurred){\r\n    this.errorsOccurred = errorsOccurred;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.runIngestModuleWizard.IngestProfileSelectionPanel.populateProfilesList",
	"Comment": "adds a button for custom settings as well as one for each profilethat has been created to the panel containing them.",
	"Method": "void populateProfilesList(){\r\n    profiles = getProfiles();\r\n    GridBagLayout gridBagLayout = new GridBagLayout();\r\n    GridBagConstraints constraints = new GridBagConstraints();\r\n    constraints.fill = GridBagConstraints.HORIZONTAL;\r\n    constraints.gridx = 0;\r\n    constraints.gridy = 0;\r\n    constraints.weighty = .0;\r\n    constraints.anchor = GridBagConstraints.LINE_START;\r\n    addButton(CUSTOM_SETTINGS_DISPLAY_NAME, wizardPanel.getDefaultContext(), CUSTOM_SETTINGS_DESCRIPTION, gridBagLayout, constraints);\r\n    profiles.forEach((profile) -> {\r\n        constraints.weightx = 0;\r\n        constraints.gridy++;\r\n        constraints.gridx = 0;\r\n        addButton(profile.toString(), profile.toString(), profile.getDescription(), gridBagLayout, constraints);\r\n    });\r\n    constraints.gridy++;\r\n    constraints.gridx = 0;\r\n    constraints.weighty = 1;\r\n    Component vertGlue = createVerticalGlue();\r\n    profileListPanel.add(vertGlue);\r\n    gridBagLayout.setConstraints(vertGlue, constraints);\r\n    profileListPanel.setLayout(gridBagLayout);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.interestingitems.FilesSetsManager.getDefaultFilter",
	"Comment": "get the filter that should be used as the default value, if no filter isspecified.",
	"Method": "FilesSet getDefaultFilter(){\r\n    return FILES_DIRS_UNALLOC_INGEST_FILTER;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.iOS.TextMessageAnalyzer.findTextsInDB",
	"Comment": "create blackboard artifacts and index results for text messages found inthe database.",
	"Method": "void findTextsInDB(String DatabasePath,long fileId){\r\n    if (DatabasePath == null || DatabasePath.isEmpty()) {\r\n        return;\r\n    }\r\n    Case currentCase;\r\n    try {\r\n        currentCase = Case.getCurrentCaseThrows();\r\n    } catch (NoCurrentCaseException ex) {\r\n        logger.log(Level.SEVERE, \"Exception while getting open case.\", ex);\r\n        return;\r\n    }\r\n    try {\r\n        Class.forName(\"org.sqlite.JDBC\");\r\n        connection = DriverManager.getConnection(\"jdbc:sqlite:\" + DatabasePath);\r\n        statement = connection.createStatement();\r\n    } catch (ClassNotFoundException | SQLException e) {\r\n        logger.log(Level.SEVERE, \"Error opening database\", e);\r\n    }\r\n    SleuthkitCase skCase = currentCase.getSleuthkitCase();\r\n    try {\r\n        AbstractFile file = skCase.getAbstractFileById(fileId);\r\n        if (file == null) {\r\n            logger.log(Level.SEVERE, \"Error getting abstract file {0}\", fileId);\r\n            return;\r\n        }\r\n        try {\r\n            resultSet = // NON-NLS\r\n            statement.executeQuery(\"SELECT address,date,type,subject,body FROM sms;\");\r\n            BlackboardArtifact bba;\r\n            String address;\r\n            String date;\r\n            String type;\r\n            String subject;\r\n            String body;\r\n            while (resultSet.next()) {\r\n                address = resultSet.getString(\"address\");\r\n                date = resultSet.getString(\"date\");\r\n                type = resultSet.getString(\"type\");\r\n                subject = resultSet.getString(\"subject\");\r\n                body = resultSet.getString(\"body\");\r\n                bba = file.newArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_MESSAGE);\r\n                Collection<BlackboardAttribute> attributes = new ArrayList();\r\n                if (type.equals(\"1\")) {\r\n                    attributes.add(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DIRECTION, moduleName, NbBundle.getMessage(this.getClass(), \"TextMessageAnalyzer.bbAttribute.incoming\")));\r\n                    attributes.add(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PHONE_NUMBER_FROM, moduleName, address));\r\n                } else {\r\n                    attributes.add(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DIRECTION, moduleName, NbBundle.getMessage(this.getClass(), \"TextMessageAnalyzer.bbAttribute.outgoing\")));\r\n                    attributes.add(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PHONE_NUMBER_TO, moduleName, address));\r\n                }\r\n                attributes.add(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME, moduleName, date));\r\n                attributes.add(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DIRECTION, moduleName, type));\r\n                attributes.add(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_SUBJECT, moduleName, subject));\r\n                attributes.add(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_TEXT, moduleName, body));\r\n                attributes.add(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_MESSAGE_TYPE, moduleName, NbBundle.getMessage(this.getClass(), \"TextMessageAnalyzer.bbAttribute.smsMessage\")));\r\n                bba.addAttributes(attributes);\r\n                try {\r\n                    blackboard.indexArtifact(bba);\r\n                } catch (Blackboard.BlackboardException ex) {\r\n                    logger.log(Level.SEVERE, \"Unable to index blackboard artifact \" + bba.getArtifactID(), ex);\r\n                    MessageNotifyUtil.Notify.error(Bundle.TextMessageAnalyzer_indexError_message(), bba.getDisplayName());\r\n                }\r\n            }\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Error parsing text messages to Blackboard\", e);\r\n        } finally {\r\n            try {\r\n                resultSet.close();\r\n                statement.close();\r\n                connection.close();\r\n            } catch (Exception e) {\r\n                logger.log(Level.SEVERE, \"Error closing database\", e);\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n        logger.log(Level.SEVERE, \"Error parsing text messages to Blackboard\", e);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.recentactivity.Firefox.getDownloadVersion24",
	"Comment": "gets download artifacts from firefox data from version 24.downloads are stored in the places database.",
	"Method": "void getDownloadVersion24(){\r\n    FileManager fileManager = currentCase.getServices().getFileManager();\r\n    List<AbstractFile> downloadsFiles;\r\n    try {\r\n        downloadsFiles = fileManager.findFiles(dataSource, \"places.sqlite\", \"Firefox\");\r\n    } catch (TskCoreException ex) {\r\n        String msg = NbBundle.getMessage(this.getClass(), \"Firefox.getDlV24.errMsg.errFetchFiles\");\r\n        logger.log(Level.WARNING, msg);\r\n        this.addErrorMessage(this.getName() + \": \" + msg);\r\n        return;\r\n    }\r\n    if (downloadsFiles.isEmpty()) {\r\n        logger.log(Level.INFO, \"Didn't find any version-24.0 Firefox download files.\");\r\n        return;\r\n    }\r\n    dataFound = true;\r\n    Collection<BlackboardArtifact> bbartifacts = new ArrayList();\r\n    int j = 0;\r\n    for (AbstractFile downloadsFile : downloadsFiles) {\r\n        if (downloadsFile.getSize() == 0) {\r\n            continue;\r\n        }\r\n        String fileName = downloadsFile.getName();\r\n        String temps = RAImageIngestModule.getRATempPath(currentCase, \"firefox\") + File.separator + fileName + \"-downloads\" + j + \".db\";\r\n        int errors = 0;\r\n        try {\r\n            ContentUtils.writeToFile(downloadsFile, new File(temps), context::dataSourceIngestIsCancelled);\r\n        } catch (ReadContentInputStreamException ex) {\r\n            logger.log(Level.WARNING, String.format(\"Error reading Firefox download artifacts file '%s' (id=%d).\", fileName, downloadsFile.getId()), ex);\r\n            this.addErrorMessage(NbBundle.getMessage(this.getClass(), \"Firefox.getHistory.errMsg.errAnalyzeFile\", this.getName(), fileName));\r\n            continue;\r\n        } catch (IOException ex) {\r\n            logger.log(Level.SEVERE, String.format(\"Error writing temp sqlite db file '%s' for Firefox download artifacts file '%s' (id=%d).\", temps, fileName, downloadsFile.getId()), ex);\r\n            this.addErrorMessage(NbBundle.getMessage(this.getClass(), \"Firefox.getDlV24.errMsg.errAnalyzeFile\", this.getName(), fileName));\r\n            continue;\r\n        }\r\n        File dbFile = new File(temps);\r\n        if (context.dataSourceIngestIsCancelled()) {\r\n            dbFile.delete();\r\n            break;\r\n        }\r\n        List<HashMap<String, Object>> tempList = this.dbConnect(temps, DOWNLOAD_QUERY_V24);\r\n        logger.log(Level.INFO, \"{0} - Now getting downloads from {1} with {2} artifacts identified.\", new Object[] { moduleName, temps, tempList.size() });\r\n        for (HashMap<String, Object> result : tempList) {\r\n            String url = result.get(\"url\").toString();\r\n            Collection<BlackboardAttribute> bbattributes = new ArrayList();\r\n            bbattributes.add(new // NON-NLS\r\n            BlackboardAttribute(// NON-NLS\r\n            ATTRIBUTE_TYPE.TSK_URL, NbBundle.getMessage(this.getClass(), \"Firefox.parentModuleName.noSpace\"), url));\r\n            String target = result.get(\"target\").toString();\r\n            if (target != null) {\r\n                try {\r\n                    String decodedTarget = URLDecoder.decode(target.replaceAll(\"file:///\", \"\"), \"UTF-8\");\r\n                    bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PATH, NbBundle.getMessage(this.getClass(), \"Firefox.parentModuleName.noSpace\"), decodedTarget));\r\n                    long pathID = Util.findID(dataSource, decodedTarget);\r\n                    if (pathID != -1) {\r\n                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PATH_ID, NbBundle.getMessage(this.getClass(), \"Firefox.parentModuleName.noSpace\"), pathID));\r\n                    }\r\n                } catch (UnsupportedEncodingException ex) {\r\n                    logger.log(Level.SEVERE, \"Error decoding Firefox download URL in \" + temps, ex);\r\n                    errors++;\r\n                }\r\n            }\r\n            bbattributes.add(new // NON-NLS\r\n            BlackboardAttribute(// NON-NLS\r\n            ATTRIBUTE_TYPE.TSK_DATETIME_ACCESSED, NbBundle.getMessage(this.getClass(), \"Firefox.parentModuleName.noSpace\"), Long.valueOf(result.get(\"lastModified\").toString())));\r\n            bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME, NbBundle.getMessage(this.getClass(), \"Firefox.parentModuleName.noSpace\"), NbBundle.getMessage(this.getClass(), \"Firefox.moduleName\")));\r\n            String domain = extractDomain(url);\r\n            if (domain != null && domain.isEmpty() == false) {\r\n                bbattributes.add(new // NON-NLS\r\n                BlackboardAttribute(// NON-NLS\r\n                ATTRIBUTE_TYPE.TSK_DOMAIN, NbBundle.getMessage(this.getClass(), \"Firefox.parentModuleName.noSpace\"), domain));\r\n            }\r\n            BlackboardArtifact bbart = this.addArtifact(ARTIFACT_TYPE.TSK_WEB_DOWNLOAD, downloadsFile, bbattributes);\r\n            if (bbart != null) {\r\n                bbartifacts.add(bbart);\r\n            }\r\n        }\r\n        if (errors > 0) {\r\n            this.addErrorMessage(NbBundle.getMessage(this.getClass(), \"Firefox.getDlV24.errMsg.errParsingArtifacts\", this.getName(), errors));\r\n        }\r\n        j++;\r\n        dbFile.delete();\r\n        break;\r\n    }\r\n    services.fireModuleDataEvent(new ModuleDataEvent(NbBundle.getMessage(this.getClass(), \"Firefox.parentModuleName\"), BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_DOWNLOAD, bbartifacts));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.DataResultPanel.createInstanceCommon",
	"Comment": "executes code common to all of the result view panel factory methods.",
	"Method": "void createInstanceCommon(String title,String description,Node currentRootNode,int childNodeCount,DataResultPanel resultViewPanel){\r\n    resultViewPanel.setTitle(title);\r\n    resultViewPanel.setName(title);\r\n    resultViewPanel.setNumberOfChildNodes(childNodeCount);\r\n    resultViewPanel.setNode(currentRootNode);\r\n    resultViewPanel.setPath(description);\r\n}"
}, {
	"Path": "com.aliyun.oss.model.ObjectMetadata.getETag",
	"Comment": "gets the etag of the object. etag is the 128bit md5 signature in hex.",
	"Method": "String getETag(){\r\n    return (String) metadata.get(OSSHeaders.ETAG);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.runIngestModuleWizard.IngestProfileSelectionPanel.addButton",
	"Comment": "creates and configures a single radio button before adding it to both thebutton group and the panel.",
	"Method": "void addButton(String profileDisplayName,String profileContextName,String profileDesc,GridBagLayout layout,GridBagConstraints constraints){\r\n    Dimension spacerBlockDimension = new Dimension(6, 4);\r\n    Box.Filler spacer = new Box.Filler(spacerBlockDimension, spacerBlockDimension, spacerBlockDimension);\r\n    constraints.weightx = 1;\r\n    layout.setConstraints(spacer, constraints);\r\n    profileListPanel.add(spacer);\r\n    constraints.gridx++;\r\n    constraints.gridy++;\r\n    JToggleButton profileButton = new JToggleButton();\r\n    profileButton.setMaximumSize(new java.awt.Dimension(48, 48));\r\n    profileButton.setMinimumSize(new java.awt.Dimension(48, 48));\r\n    profileButton.setPreferredSize(new java.awt.Dimension(48, 48));\r\n    profileButton.setName(profileContextName);\r\n    profileButton.setActionCommand(profileContextName);\r\n    profileButton.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/timeline/images/magnifier-zoom-in-green.png\")));\r\n    profileButton.setSelectedIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/corecomponents/checkbox24.png\")));\r\n    profileButton.setFocusable(false);\r\n    profileButton.setFocusPainted(false);\r\n    profileButton.addActionListener(buttonGroupActionListener);\r\n    if (profileContextName.equals(selectedProfile)) {\r\n        profileButton.setSelected(true);\r\n    }\r\n    profileListButtonGroup.add(profileButton);\r\n    profileListPanel.add(profileButton);\r\n    layout.setConstraints(profileButton, constraints);\r\n    constraints.gridx++;\r\n    constraints.weightx = 1;\r\n    String displayText = profileDisplayName;\r\n    if (!profileDesc.isEmpty()) {\r\n        displayText += \" - \" + profileDesc;\r\n    }\r\n    JTextArea myLabel = new JTextArea(displayText);\r\n    Color gray = new Color(240, 240, 240);\r\n    myLabel.setBackground(gray);\r\n    myLabel.setEditable(false);\r\n    myLabel.setWrapStyleWord(true);\r\n    myLabel.setLineWrap(true);\r\n    Box.Filler buttonTextSpacer = new Box.Filler(spacerBlockDimension, spacerBlockDimension, spacerBlockDimension);\r\n    layout.setConstraints(buttonTextSpacer, constraints);\r\n    profileListPanel.add(buttonTextSpacer);\r\n    constraints.gridx++;\r\n    profileListPanel.add(myLabel);\r\n    layout.setConstraints(myLabel, constraints);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestDashboard.setServicesStatusMessage",
	"Comment": "queries the services monitor and sets the text for the services statustext box.",
	"Method": "void setServicesStatusMessage(){\r\n    new SwingWorker<Void, Void>() {\r\n        @Override\r\n        protected Void doInBackground() throws Exception {\r\n            statusByService.put(ServicesMonitor.Service.REMOTE_CASE_DATABASE.toString(), getServiceStatus(ServicesMonitor.Service.REMOTE_CASE_DATABASE));\r\n            statusByService.put(ServicesMonitor.Service.REMOTE_KEYWORD_SEARCH.toString(), getServiceStatus(ServicesMonitor.Service.REMOTE_KEYWORD_SEARCH));\r\n            statusByService.put(ServicesMonitor.Service.MESSAGING.toString(), getServiceStatus(ServicesMonitor.Service.MESSAGING));\r\n            return null;\r\n        }\r\n        private String getServiceStatus(ServicesMonitor.Service service) {\r\n            String serviceStatus = NbBundle.getMessage(AutoIngestDashboard.class, \"AutoIngestDashboard.tbServicesStatusMessage.Message.Unknown\");\r\n            try {\r\n                ServicesMonitor servicesMonitor = ServicesMonitor.getInstance();\r\n                serviceStatus = servicesMonitor.getServiceStatus(service.toString());\r\n                if (serviceStatus.compareTo(ServicesMonitor.ServiceStatus.UP.toString()) == 0) {\r\n                    serviceStatus = NbBundle.getMessage(AutoIngestDashboard.class, \"AutoIngestDashboard.tbServicesStatusMessage.Message.Up\");\r\n                } else {\r\n                    serviceStatus = NbBundle.getMessage(AutoIngestDashboard.class, \"AutoIngestDashboard.tbServicesStatusMessage.Message.Down\");\r\n                }\r\n            } catch (ServicesMonitor.ServicesMonitorException ex) {\r\n                LOGGER.log(Level.SEVERE, String.format(\"Dashboard error getting service status for %s\", service), ex);\r\n            }\r\n            return serviceStatus;\r\n        }\r\n        @Override\r\n        protected void done() {\r\n            displayServicesStatus();\r\n        }\r\n    }.execute();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestDashboard.setServicesStatusMessage",
	"Comment": "queries the services monitor and sets the text for the services statustext box.",
	"Method": "void setServicesStatusMessage(){\r\n    statusByService.put(ServicesMonitor.Service.REMOTE_CASE_DATABASE.toString(), getServiceStatus(ServicesMonitor.Service.REMOTE_CASE_DATABASE));\r\n    statusByService.put(ServicesMonitor.Service.REMOTE_KEYWORD_SEARCH.toString(), getServiceStatus(ServicesMonitor.Service.REMOTE_KEYWORD_SEARCH));\r\n    statusByService.put(ServicesMonitor.Service.MESSAGING.toString(), getServiceStatus(ServicesMonitor.Service.MESSAGING));\r\n    return null;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestDashboard.setServicesStatusMessage",
	"Comment": "queries the services monitor and sets the text for the services statustext box.",
	"Method": "void setServicesStatusMessage(){\r\n    String serviceStatus = NbBundle.getMessage(AutoIngestDashboard.class, \"AutoIngestDashboard.tbServicesStatusMessage.Message.Unknown\");\r\n    try {\r\n        ServicesMonitor servicesMonitor = ServicesMonitor.getInstance();\r\n        serviceStatus = servicesMonitor.getServiceStatus(service.toString());\r\n        if (serviceStatus.compareTo(ServicesMonitor.ServiceStatus.UP.toString()) == 0) {\r\n            serviceStatus = NbBundle.getMessage(AutoIngestDashboard.class, \"AutoIngestDashboard.tbServicesStatusMessage.Message.Up\");\r\n        } else {\r\n            serviceStatus = NbBundle.getMessage(AutoIngestDashboard.class, \"AutoIngestDashboard.tbServicesStatusMessage.Message.Down\");\r\n        }\r\n    } catch (ServicesMonitor.ServicesMonitorException ex) {\r\n        LOGGER.log(Level.SEVERE, String.format(\"Dashboard error getting service status for %s\", service), ex);\r\n    }\r\n    return serviceStatus;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestDashboard.setServicesStatusMessage",
	"Comment": "queries the services monitor and sets the text for the services statustext box.",
	"Method": "void setServicesStatusMessage(){\r\n    displayServicesStatus();\r\n}"
}, {
	"Path": "com.facebook.samples.zoomable.ZoomableDraweeView.getZoomableController",
	"Comment": "gets the zoomable controller. zoomable controller can be used to zoom to point, or to map point from view to imagecoordinates for instance.",
	"Method": "ZoomableController getZoomableController(){\r\n    return mZoomableController;\r\n}"
}, {
	"Path": "com.litesuits.http.utils.UriUtil.getQueryParameterNames",
	"Comment": "returns a set of the unique names of all query parameters. iteratingover the set will return the names in order of their first occurrence.",
	"Method": "Set<String> getQueryParameterNames(Uri uri){\r\n    if (uri.isOpaque()) {\r\n        return Collections.emptySet();\r\n    }\r\n    String query = uri.getEncodedQuery();\r\n    if (query == null) {\r\n        return Collections.emptySet();\r\n    }\r\n    Set<String> names = new LinkedHashSet<String>();\r\n    int start = 0;\r\n    do {\r\n        int next = query.indexOf('&', start);\r\n        int end = (next == -1) ? query.length() : next;\r\n        int separator = query.indexOf('=', start);\r\n        if (separator > end || separator == -1) {\r\n            separator = end;\r\n        }\r\n        String name = query.substring(start, separator);\r\n        names.add(name);\r\n        start = end + 1;\r\n    } while (start < query.length());\r\n    return Collections.unmodifiableSet(names);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.DataResultViewerTable.loadColumnSorting",
	"Comment": "reads and applies the column sorting information persisted to thepreferences file. must be called after loadcolumnorder, since it dependson the properties map being initialized, and after assigncolumns, sinceit cannot set the sort on columns that have not been added to the table.",
	"Method": "void loadColumnSorting(){\r\n    if (rootNode == null || propertiesMap.isEmpty()) {\r\n        return;\r\n    }\r\n    if (rootNode instanceof TableFilterNode) {\r\n        final TableFilterNode tfn = (TableFilterNode) rootNode;\r\n        final Preferences preferences = NbPreferences.forModule(DataResultViewerTable.class);\r\n        TreeSet<ColumnSortInfo> sortInfos = new TreeSet(Comparator.comparing(ColumnSortInfo::getRank));\r\n        propertiesMap.entrySet().stream().forEach(entry -> {\r\n            final String propName = entry.getValue().getName();\r\n            Integer sortRank = preferences.getInt(ResultViewerPersistence.getColumnSortRankKey(tfn, propName), 0);\r\n            Boolean sortOrder = preferences.getBoolean(ResultViewerPersistence.getColumnSortOrderKey(tfn, propName), true);\r\n            sortInfos.add(new ColumnSortInfo(entry.getKey(), sortRank, sortOrder));\r\n        });\r\n        sortInfos.forEach(sortInfo -> outline.setColumnSorted(sortInfo.modelIndex, sortInfo.order, sortInfo.rank));\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.PathValidator.pathOnCDrive",
	"Comment": "checks whether a file path contains drive letter defined by pattern.",
	"Method": "boolean pathOnCDrive(String filePath){\r\n    Matcher m = driveLetterPattern.matcher(filePath);\r\n    return m.find();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.LocalDiskPanel.createTimeZoneList",
	"Comment": "creates the drop down list for the time zones and defaults the selectionto the local machine time zone.",
	"Method": "void createTimeZoneList(){\r\n    List<String> timeZoneList = TimeZoneUtils.createTimeZoneList();\r\n    for (String timeZone : timeZoneList) {\r\n        timeZoneComboBox.addItem(timeZone);\r\n    }\r\n    timeZoneComboBox.setSelectedItem(TimeZoneUtils.createTimeZoneString(Calendar.getInstance().getTimeZone()));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.ui.countsview.EventCountsChart.dataItemAdded",
	"Comment": "add the bar click handler,tooltip, border styling and hover effect to thenode generated by stackedbarchart.",
	"Method": "void dataItemAdded(Series<String, Number> series,int itemIndex,Data<String, Number> item){\r\n    ExtraData extraValue = (ExtraData) item.getExtraValue();\r\n    EventType eventType = extraValue.getEventType();\r\n    Interval interval = extraValue.getInterval();\r\n    long count = extraValue.getRawCount();\r\n    item.nodeProperty().addListener((Observable o) -> {\r\n        final Node node = item.getNode();\r\n        if (node != null) {\r\n            node.setStyle(\"-fx-border-width: 2; -fx-border-color: \" + ColorUtilities.getRGBCode(eventType.getSuperType().getColor()) + \"; -fx-bar-fill: \" + ColorUtilities.getRGBCode(eventType.getColor()));\r\n            node.setCursor(Cursor.HAND);\r\n            final Tooltip tooltip = new Tooltip(Bundle.CountsViewPane_tooltip_text(count, eventType.getDisplayName(), item.getXValue(), interval.getEnd().toString(rangeInfo.getTickFormatter())));\r\n            tooltip.setGraphic(new ImageView(eventType.getFXImage()));\r\n            Tooltip.install(node, tooltip);\r\n            node.setOnMouseEntered(mouseEntered -> node.setEffect(new DropShadow(10, eventType.getColor())));\r\n            node.setOnMouseExited(mouseExited -> node.setEffect(selectedNodes.contains(node) ? SELECTED_NODE_EFFECT : null));\r\n            node.setOnMouseClicked(new BarClickHandler(item));\r\n        }\r\n    });\r\n    super.dataItemAdded(series, itemIndex, item);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.configuration.AutoIngestUserPreferences.getMaxConcurrentJobsForOneCase",
	"Comment": "get maximum number of concurrent ingest nodes allowable for one case at atime.",
	"Method": "int getMaxConcurrentJobsForOneCase(){\r\n    if (ModuleSettings.settingExists(UserPreferences.SETTINGS_PROPERTIES, MAX_CONCURRENT_NODES_FOR_ONE_CASE)) {\r\n        return Integer.parseInt(ModuleSettings.getConfigSetting(UserPreferences.SETTINGS_PROPERTIES, MAX_CONCURRENT_NODES_FOR_ONE_CASE));\r\n    }\r\n    return 3;\r\n}"
}, {
	"Path": "com.facebook.samples.zoomable.DefaultZoomableController.calculateZoomToPointTransform",
	"Comment": "calculates the zoom transformation that would zoom to the desired scale and position the imageso that the given image point corresponds to the given view point.",
	"Method": "boolean calculateZoomToPointTransform(Matrix outTransform,float scale,PointF imagePoint,PointF viewPoint,int limitFlags){\r\n    float[] viewAbsolute = mTempValues;\r\n    viewAbsolute[0] = imagePoint.x;\r\n    viewAbsolute[1] = imagePoint.y;\r\n    mapRelativeToAbsolute(viewAbsolute, viewAbsolute, 1);\r\n    float distanceX = viewPoint.x - viewAbsolute[0];\r\n    float distanceY = viewPoint.y - viewAbsolute[1];\r\n    boolean transformCorrected = false;\r\n    outTransform.setScale(scale, scale, viewAbsolute[0], viewAbsolute[1]);\r\n    transformCorrected |= limitScale(outTransform, viewAbsolute[0], viewAbsolute[1], limitFlags);\r\n    outTransform.postTranslate(distanceX, distanceY);\r\n    transformCorrected |= limitTranslation(outTransform, limitFlags);\r\n    return transformCorrected;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.ProfilePanel.isValidDefinition",
	"Comment": "checks that information entered constitutes a valid ingest profile.",
	"Method": "boolean isValidDefinition(){\r\n    if (getProfileName().isEmpty()) {\r\n        NotifyDescriptor notifyDesc = new NotifyDescriptor.Message(NbBundle.getMessage(ProfilePanel.class, \"ProfilePanel.messages.profilesMustBeNamed\"), NotifyDescriptor.WARNING_MESSAGE);\r\n        DialogDisplayer.getDefault().notify(notifyDesc);\r\n        return false;\r\n    }\r\n    if (!containsOnlyLegalChars(getProfileName(), ILLEGAL_NAME_CHARS)) {\r\n        NotifyDescriptor notifyDesc = new NotifyDescriptor.Message(NbBundle.getMessage(ProfilePanel.class, \"ProfilePanel.messages.profileNameContainsIllegalCharacter\"), NotifyDescriptor.WARNING_MESSAGE);\r\n        DialogDisplayer.getDefault().notify(notifyDesc);\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.SqliteEamDb.getReferenceInstancesByTypeValue",
	"Comment": "get all reference entries having a given correlation type and value",
	"Method": "List<EamGlobalFileInstance> getReferenceInstancesByTypeValue(CorrelationAttributeInstance.Type aType,String aValue){\r\n    try {\r\n        acquireSharedLock();\r\n        return super.getReferenceInstancesByTypeValue(aType, aValue);\r\n    } finally {\r\n        releaseSharedLock();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.fileextmismatch.FileExtMismatchOptionsPanelController.cancel",
	"Comment": "this method is called when the cancel button is pressed. it applies toany of the panels that have been opened in the process of using theoptions pane.",
	"Method": "void cancel(){\r\n    getPanel().cancel();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.DataResultViewerTable.isSupported",
	"Comment": "indicates whether a given node is supported as a root node for thistabular viewer.",
	"Method": "boolean isSupported(Node candidateRootNode){\r\n    return true;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.eventlisteners.IngestEventsListener.postCorrelatedPreviousArtifactToBlackboard",
	"Comment": "create an interesting aritfact hit for a device which was previously seenin the central repository.",
	"Method": "void postCorrelatedPreviousArtifactToBlackboard(BlackboardArtifact bbArtifact){\r\n    try {\r\n        String MODULE_NAME = Bundle.IngestEventsListener_ingestmodule_name();\r\n        Collection<BlackboardAttribute> attributes = new ArrayList();\r\n        BlackboardAttribute att = new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_SET_NAME, MODULE_NAME, Bundle.IngestEventsListener_prevExists_text());\r\n        attributes.add(att);\r\n        attributes.add(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_ASSOCIATED_ARTIFACT, MODULE_NAME, bbArtifact.getArtifactID()));\r\n        SleuthkitCase tskCase = bbArtifact.getSleuthkitCase();\r\n        AbstractFile abstractFile = bbArtifact.getSleuthkitCase().getAbstractFileById(bbArtifact.getObjectID());\r\n        org.sleuthkit.datamodel.Blackboard tskBlackboard = tskCase.getBlackboard();\r\n        if (!tskBlackboard.artifactExists(abstractFile, BlackboardArtifact.ARTIFACT_TYPE.TSK_INTERESTING_ARTIFACT_HIT, attributes)) {\r\n            BlackboardArtifact tifArtifact = abstractFile.newArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_INTERESTING_ARTIFACT_HIT);\r\n            tifArtifact.addAttributes(attributes);\r\n            try {\r\n                Blackboard blackboard = Case.getCurrentCaseThrows().getServices().getBlackboard();\r\n                blackboard.indexArtifact(tifArtifact);\r\n            } catch (Blackboard.BlackboardException | NoCurrentCaseException ex) {\r\n                LOGGER.log(Level.SEVERE, \"Unable to index blackboard artifact \" + tifArtifact.getArtifactID(), ex);\r\n            }\r\n            IngestServices.getInstance().fireModuleDataEvent(new ModuleDataEvent(MODULE_NAME, BlackboardArtifact.ARTIFACT_TYPE.TSK_INTERESTING_ARTIFACT_HIT));\r\n        }\r\n    } catch (TskCoreException ex) {\r\n        LOGGER.log(Level.SEVERE, \"Failed to create BlackboardArtifact.\", ex);\r\n    } catch (IllegalStateException ex) {\r\n        LOGGER.log(Level.SEVERE, \"Failed to create BlackboardAttribute.\", ex);\r\n    }\r\n}"
}, {
	"Path": "com.tngtech.archunit.core.importer.ClassFileImporterTest.imports_special_target_parameters",
	"Comment": "unfortunately those asm type names for example are the canonical name instead of the class name.",
	"Method": "void imports_special_target_parameters(){\r\n    ImportedClasses classes = classesIn(\"testexamples/specialtargets\");\r\n    Set<JavaMethodCall> calls = classes.get(ClassCallingSpecialTarget.class).getMethodCallsFromSelf();\r\n    assertThat(targetParametersOf(calls, \"primitiveArgs\")).matches(byte.class, long.class);\r\n    assertThat(returnTypeOf(calls, \"primitiveReturnType\")).matches(byte.class);\r\n    assertThat(targetParametersOf(calls, \"arrayArgs\")).matches(byte[].class, Object[].class);\r\n    assertThat(returnTypeOf(calls, \"primitiveArrayReturnType\")).matches(short[].class);\r\n    assertThat(returnTypeOf(calls, \"objectArrayReturnType\")).matches(String[].class);\r\n    assertThat(targetParametersOf(calls, \"twoDimArrayArgs\")).matches(float[][].class, Object[][].class);\r\n    assertThat(returnTypeOf(calls, \"primitiveTwoDimArrayReturnType\")).matches(double[][].class);\r\n    assertThat(returnTypeOf(calls, \"objectTwoDimArrayReturnType\")).matches(String[][].class);\r\n}"
}, {
	"Path": "com.badlogic.ashley.utils.Bag.remove",
	"Comment": "removes the first occurrence of the specified element from this bag, if it is present. if the bag does not contain the\telement, it is unchanged. it does not preserve order of elements.",
	"Method": "E remove(int index,boolean remove,E e){\r\n    for (int i = 0; i < size; i++) {\r\n        E e2 = data[i];\r\n        if (e == e2) {\r\n            data[i] = data[--size];\r\n            data[size] = null;\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.core.RuntimeProperties.setRunningWithGUI",
	"Comment": "sets or unsets a flag indicating whether or not the application isrunning with a gui. the flag can only be set once per applicationinnvocation.",
	"Method": "void setRunningWithGUI(boolean runningWithGUI){\r\n    if (!runningWithGUIFlagHasBeenSet) {\r\n        RuntimeProperties.runningWithGUI = runningWithGUI;\r\n        runningWithGUIFlagHasBeenSet = true;\r\n    } else {\r\n        throw new RuntimePropertiesException(\"The runningWithGUI flag has already been set and cannot be changed\");\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.directorytree.DirectoryTreeTopComponent.subscribeToChangeEvents",
	"Comment": "make this topcomponent a listener to various change events.",
	"Method": "void subscribeToChangeEvents(){\r\n    UserPreferences.addChangeListener(new PreferenceChangeListener() {\r\n        @Override\r\n        public void preferenceChange(PreferenceChangeEvent evt) {\r\n            switch(evt.getKey()) {\r\n                case UserPreferences.DISPLAY_TIMES_IN_LOCAL_TIME:\r\n                case UserPreferences.TIME_ZONE_FOR_DISPLAYS:\r\n                case UserPreferences.HIDE_KNOWN_FILES_IN_DATA_SRCS_TREE:\r\n                case UserPreferences.HIDE_SLACK_FILES_IN_DATA_SRCS_TREE:\r\n                case UserPreferences.HIDE_CENTRAL_REPO_COMMENTS_AND_OCCURRENCES:\r\n                case UserPreferences.DISPLAY_TRANSLATED_NAMES:\r\n                case UserPreferences.KEEP_PREFERRED_VIEWER:\r\n                case UserPreferences.MAXIMUM_NUMBER_OF_RESULTS:\r\n                    refreshContentTreeSafe();\r\n                    break;\r\n                case UserPreferences.SHOW_ONLY_CURRENT_USER_TAGS:\r\n                    refreshTagsTree();\r\n                    break;\r\n                case UserPreferences.HIDE_KNOWN_FILES_IN_VIEWS_TREE:\r\n                case UserPreferences.HIDE_SLACK_FILES_IN_VIEWS_TREE:\r\n                    refreshContentTreeSafe();\r\n                    break;\r\n            }\r\n        }\r\n    });\r\n    Case.addEventTypeSubscriber(EnumSet.of(Case.Events.CURRENT_CASE, Case.Events.DATA_SOURCE_ADDED), this);\r\n    this.em.addPropertyChangeListener(this);\r\n    IngestManager.getInstance().addIngestJobEventListener(this);\r\n    IngestManager.getInstance().addIngestModuleEventListener(this);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.directorytree.DirectoryTreeTopComponent.subscribeToChangeEvents",
	"Comment": "make this topcomponent a listener to various change events.",
	"Method": "void subscribeToChangeEvents(){\r\n    switch(evt.getKey()) {\r\n        case UserPreferences.DISPLAY_TIMES_IN_LOCAL_TIME:\r\n        case UserPreferences.TIME_ZONE_FOR_DISPLAYS:\r\n        case UserPreferences.HIDE_KNOWN_FILES_IN_DATA_SRCS_TREE:\r\n        case UserPreferences.HIDE_SLACK_FILES_IN_DATA_SRCS_TREE:\r\n        case UserPreferences.HIDE_CENTRAL_REPO_COMMENTS_AND_OCCURRENCES:\r\n        case UserPreferences.DISPLAY_TRANSLATED_NAMES:\r\n        case UserPreferences.KEEP_PREFERRED_VIEWER:\r\n        case UserPreferences.MAXIMUM_NUMBER_OF_RESULTS:\r\n            refreshContentTreeSafe();\r\n            break;\r\n        case UserPreferences.SHOW_ONLY_CURRENT_USER_TAGS:\r\n            refreshTagsTree();\r\n            break;\r\n        case UserPreferences.HIDE_KNOWN_FILES_IN_VIEWS_TREE:\r\n        case UserPreferences.HIDE_SLACK_FILES_IN_VIEWS_TREE:\r\n            refreshContentTreeSafe();\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.Server.getMultiUserServerProperties",
	"Comment": "get the host and port for a multiuser case.if the file solrserver.txt exists, then use the values from that file.otherwise use the settings from the properties file.",
	"Method": "IndexingServerProperties getMultiUserServerProperties(String caseDirectory){\r\n    Path serverFilePath = Paths.get(caseDirectory, \"solrserver.txt\");\r\n    if (serverFilePath.toFile().exists()) {\r\n        try {\r\n            List<String> lines = Files.readAllLines(serverFilePath);\r\n            if (lines.isEmpty()) {\r\n                logger.log(Level.SEVERE, \"solrserver.txt file does not contain any data\");\r\n            } else if (!lines.get(0).contains(\",\")) {\r\n                logger.log(Level.SEVERE, \"solrserver.txt file is corrupt - could not read host/port from \" + lines.get(0));\r\n            } else {\r\n                String[] parts = lines.get(0).split(\",\");\r\n                if (parts.length != 2) {\r\n                    logger.log(Level.SEVERE, \"solrserver.txt file is corrupt - could not read host/port from \" + lines.get(0));\r\n                } else {\r\n                    return new IndexingServerProperties(parts[0], parts[1]);\r\n                }\r\n            }\r\n        } catch (IOException ex) {\r\n            logger.log(Level.SEVERE, \"solrserver.txt file could not be read\", ex);\r\n        }\r\n    }\r\n    String host = UserPreferences.getIndexingServerHost();\r\n    String port = UserPreferences.getIndexingServerPort();\r\n    return new IndexingServerProperties(host, port);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AddDataSourceCallback.done",
	"Comment": "called by the data source processor when it finishes running in its ownthread.",
	"Method": "void done(DataSourceProcessorCallback.DataSourceProcessorResult result,List<String> errorMessages,List<Content> dataSourceContent){\r\n    if (!dataSourceContent.isEmpty()) {\r\n        caseForJob.notifyDataSourceAdded(dataSourceContent.get(0), taskId);\r\n    } else {\r\n        caseForJob.notifyFailedAddingDataSource(taskId);\r\n    }\r\n    dataSourceInfo.setDataSourceProcessorOutput(result, errorMessages, dataSourceContent);\r\n    dataSourceContent.addAll(dataSourceContent);\r\n    synchronized (lock) {\r\n        lock.notify();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.embeddedfileextractor.MSOfficeEmbeddedContentExtractor.getFileRelativePath",
	"Comment": "gets the relative path to the file. the path is relative to the casefolder.",
	"Method": "String getFileRelativePath(String fileName){\r\n    return \"/\" + moduleDirRelative + \"/\" + this.parentFileName + \"/\" + fileName;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestManager.deleteCase",
	"Comment": "deletes a case. this includes deleting the case directory, the textindex, and the case database. this does not include the directoriescontaining the data sources and their manifests.",
	"Method": "CaseDeletionResult deleteCase(String caseName,Path caseDirectoryPath){\r\n    if (state != State.RUNNING) {\r\n        return CaseDeletionResult.FAILED;\r\n    }\r\n    CaseDeletionResult result = CaseDeletionResult.FULLY_DELETED;\r\n    List<Lock> manifestFileLocks = new ArrayList();\r\n    try {\r\n        synchronized (jobsLock) {\r\n            CaseMetadata metaData;\r\n            Path caseMetaDataFilePath = Paths.get(caseDirectoryPath.toString(), caseName + CaseMetadata.getFileExtension());\r\n            try {\r\n                metaData = new CaseMetadata(caseMetaDataFilePath);\r\n            } catch (CaseMetadata.CaseMetadataException ex) {\r\n                sysLogger.log(Level.SEVERE, String.format(\"Failed to get case metadata file %s for case %s at %s\", caseMetaDataFilePath, caseName, caseDirectoryPath), ex);\r\n                return CaseDeletionResult.FAILED;\r\n            }\r\n            InputDirScanner scanner = new InputDirScanner();\r\n            scanner.scan();\r\n            Set<Path> manifestPaths = casesToManifests.get(caseName);\r\n            if (null == manifestPaths) {\r\n                sysLogger.log(Level.SEVERE, String.format(\"No manifest paths found for case %s at %s\", caseName, caseDirectoryPath));\r\n                return CaseDeletionResult.FAILED;\r\n            }\r\n            for (Path manifestPath : manifestPaths) {\r\n                try {\r\n                    Lock lock = coordinationService.tryGetExclusiveLock(CoordinationService.CategoryNode.MANIFESTS, manifestPath.toString());\r\n                    if (null != lock) {\r\n                        manifestFileLocks.add(lock);\r\n                    } else {\r\n                        return CaseDeletionResult.FAILED;\r\n                    }\r\n                } catch (CoordinationServiceException ex) {\r\n                    sysLogger.log(Level.SEVERE, String.format(\"Error attempting to acquire manifest lock for %s for case %s at %s\", manifestPath, caseName, caseDirectoryPath), ex);\r\n                    return CaseDeletionResult.FAILED;\r\n                }\r\n            }\r\n            try {\r\n                Case.deleteCase(metaData);\r\n            } catch (CaseActionException ex) {\r\n                sysLogger.log(Level.SEVERE, String.format(\"Failed to physically delete case %s at %s\", caseName, caseDirectoryPath), ex);\r\n                return CaseDeletionResult.FAILED;\r\n            }\r\n            for (Path manifestPath : manifestPaths) {\r\n                try {\r\n                    AutoIngestJobNodeData nodeData = new AutoIngestJobNodeData(coordinationService.getNodeData(CoordinationService.CategoryNode.MANIFESTS, manifestPath.toString()));\r\n                    AutoIngestJob deletedJob = new AutoIngestJob(nodeData);\r\n                    deletedJob.setProcessingStatus(AutoIngestJob.ProcessingStatus.DELETED);\r\n                    this.updateCoordinationServiceManifestNode(deletedJob);\r\n                } catch (AutoIngestJobNodeData.InvalidDataException | AutoIngestJobException ex) {\r\n                    sysLogger.log(Level.WARNING, String.format(\"Invalid auto ingest job node data for %s\", manifestPath), ex);\r\n                    return CaseDeletionResult.PARTIALLY_DELETED;\r\n                } catch (InterruptedException | CoordinationServiceException ex) {\r\n                    sysLogger.log(Level.SEVERE, String.format(\"Error attempting to set delete flag on manifest data for %s for case %s at %s\", manifestPath, caseName, caseDirectoryPath), ex);\r\n                    return CaseDeletionResult.PARTIALLY_DELETED;\r\n                }\r\n            }\r\n            removeJobs(manifestPaths, pendingJobs);\r\n            removeJobs(manifestPaths, completedJobs);\r\n            casesToManifests.remove(caseName);\r\n        }\r\n        eventPublisher.publishRemotely(new AutoIngestCaseDeletedEvent(caseName, LOCAL_HOST_NAME, getSystemUserNameProperty()));\r\n        setChanged();\r\n        notifyObservers(Event.CASE_DELETED);\r\n        return result;\r\n    } finally {\r\n        for (Lock lock : manifestFileLocks) {\r\n            try {\r\n                lock.release();\r\n            } catch (CoordinationServiceException ex) {\r\n                sysLogger.log(Level.SEVERE, String.format(\"Failed to release manifest file lock when deleting case %s at %s\", caseName, caseDirectoryPath), ex);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.db.EventDB.reInitializeDB",
	"Comment": "drop the tables from this database and recreate them in order to startover.",
	"Method": "void reInitializeDB(){\r\n    DBLock.lock();\r\n    try {\r\n        dropEventsTableStmt.executeUpdate();\r\n        dropHashSetHitsTableStmt.executeUpdate();\r\n        dropHashSetsTableStmt.executeUpdate();\r\n        dropTagsTableStmt.executeUpdate();\r\n        dropDBInfoTableStmt.executeUpdate();\r\n        initializeDB();\r\n    } catch (SQLException ex) {\r\n        LOGGER.log(Level.SEVERE, \"could not drop old tables\", ex);\r\n    } finally {\r\n        DBLock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestJobSettings.getModulesNames",
	"Comment": "gets a list of enabled module names from the properties file for theexecution context of these ingest job settings.",
	"Method": "HashSet<String> getModulesNames(String executionContext,String propertyName,String defaultSetting){\r\n    if (ModuleSettings.settingExists(executionContext, propertyName) == false) {\r\n        ModuleSettings.setConfigSetting(executionContext, propertyName, defaultSetting);\r\n    }\r\n    HashSet<String> moduleNames = new HashSet();\r\n    String modulesSetting = ModuleSettings.getConfigSetting(executionContext, propertyName);\r\n    if (!modulesSetting.isEmpty()) {\r\n        String[] settingNames = modulesSetting.split(\", \");\r\n        for (String name : settingNames) {\r\n            switch(name) {\r\n                case \"Thunderbird Parser\":\r\n                case \"MBox Parser\":\r\n                    moduleNames.add(\"Email Parser\");\r\n                    break;\r\n                case \"File Extension Mismatch Detection\":\r\n                    moduleNames.add(\"Extension Mismatch Detector\");\r\n                    break;\r\n                case \"EWF Verify\":\r\n                case \"E01 Verify\":\r\n                case \"E01 Verifier\":\r\n                    moduleNames.add(\"Data Source Integrity\");\r\n                    break;\r\n                case \"Archive Extractor\":\r\n                    moduleNames.add(\"Embedded File Extractor\");\r\n                    break;\r\n                default:\r\n                    moduleNames.add(name);\r\n            }\r\n        }\r\n    }\r\n    return moduleNames;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.examples.SampleIngestModuleFactory.getModuleDisplayName",
	"Comment": "gets the display name that identifies the family of ingest modules thefactory creates. autopsy uses this string to identify the module in userinterface components and log messages. the module name must be unique. soa brief but distinctive name is recommended.",
	"Method": "String getModuleDisplayName(){\r\n    return getModuleName();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.filetypeid.AddFileTypePanel.getFileType",
	"Comment": "gets the file type defined by this panel, and gives popups for invalidfile types.",
	"Method": "FileType getFileType(){\r\n    String typeName = mimeTypeTextField.getText();\r\n    if (typeName.isEmpty()) {\r\n        JOptionPane.showMessageDialog(this, NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidMIMEType.message\"), NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidMIMEType.title\"), JOptionPane.ERROR_MESSAGE);\r\n        return null;\r\n    }\r\n    if (typeName.contains(\"\\'\")) {\r\n        typeName = typeName.replaceAll(\"[\\\\']\", \"\");\r\n        JOptionPane.showMessageDialog(this, NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"AddFileTypePanel.containsIllegalCharacter.message\", typeName), NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"AddFileTypePanel.containsIllegalCharacter.title\"), JOptionPane.WARNING_MESSAGE);\r\n        mimeTypeTextField.setText(typeName);\r\n        return null;\r\n    }\r\n    String[] splitName = typeName.split(\"/\");\r\n    if (splitName.length < 2 || splitName[0].isEmpty()) {\r\n        JOptionPane.showMessageDialog(this, NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"AddFileTypePanel.nonStandardMIMEType.message\", typeName), NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"AddFileTypePanel.nonStandardMIMEType.title\"), JOptionPane.WARNING_MESSAGE);\r\n        mimeTypeTextField.setText(\"custom/\" + typeName);\r\n        return null;\r\n    }\r\n    if (!StringUtils.join(ArrayUtils.subarray(splitName, 0, splitName.length), \"/\").equals(typeName)) {\r\n        String rejoinedMimeType = StringUtils.join(ArrayUtils.subarray(splitName, 0, splitName.length), \"/\");\r\n        JOptionPane.showMessageDialog(this, NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"AddFileTypePanel.nonStandardMIMEType.message\", rejoinedMimeType), NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"AddFileTypePanel.nonStandardMIMEType.title\"), JOptionPane.WARNING_MESSAGE);\r\n        mimeTypeTextField.setText(rejoinedMimeType);\r\n        return null;\r\n    }\r\n    if (this.signaturesListModel.isEmpty()) {\r\n        JOptionPane.showMessageDialog(this, Bundle.AddMimeTypePanel_emptySigList_message(), Bundle.AddMimeTypePanel_emptySigList_title(), JOptionPane.ERROR_MESSAGE);\r\n        return null;\r\n    }\r\n    List<Signature> sigList = new ArrayList();\r\n    for (int i = 0; i < this.signaturesListModel.getSize(); i++) {\r\n        sigList.add(this.signaturesListModel.elementAt(i));\r\n    }\r\n    String setName = \"\";\r\n    if (this.postHitCheckBox.isSelected()) {\r\n        if (this.setNameTextField.getText().isEmpty()) {\r\n            JOptionPane.showMessageDialog(this, Bundle.AddMimeTypePanel_emptySetName_message(), Bundle.AddMimeTypePanel_emptySetName_title(), JOptionPane.ERROR_MESSAGE);\r\n            return null;\r\n        }\r\n        setName = this.setNameTextField.getText();\r\n    }\r\n    return new FileType(typeName, sigList, this.postHitCheckBox.isSelected(), setName);\r\n}"
}, {
	"Path": "com.stealthcopter.networktools.Ping.doPing",
	"Comment": "perform a synchronous ping and return a result, will ignore number of times.note that this should be performed on a background thread as it will perform a networkrequest",
	"Method": "PingResult doPing(Ping doPing,PingListener pingListener){\r\n    new Thread(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            try {\r\n                resolveAddressString();\r\n            } catch (UnknownHostException e) {\r\n                pingListener.onError(e);\r\n                return;\r\n            }\r\n            if (address == null) {\r\n                pingListener.onError(new NullPointerException(\"Address is null\"));\r\n                return;\r\n            }\r\n            long pingsCompleted = 0;\r\n            long noLostPackets = 0;\r\n            float totalPingTime = 0;\r\n            float minPingTime = -1;\r\n            float maxPingTime = -1;\r\n            cancelled = false;\r\n            int noPings = times;\r\n            while (noPings > 0 || times == 0) {\r\n                PingResult pingResult = PingTools.doPing(address, pingOptions);\r\n                if (pingListener != null) {\r\n                    pingListener.onResult(pingResult);\r\n                }\r\n                pingsCompleted++;\r\n                if (pingResult.hasError()) {\r\n                    noLostPackets++;\r\n                } else {\r\n                    float timeTaken = pingResult.getTimeTaken();\r\n                    totalPingTime += timeTaken;\r\n                    if (maxPingTime == -1 || timeTaken > maxPingTime)\r\n                        maxPingTime = timeTaken;\r\n                    if (minPingTime == -1 || timeTaken < minPingTime)\r\n                        minPingTime = timeTaken;\r\n                }\r\n                noPings--;\r\n                if (cancelled)\r\n                    break;\r\n                try {\r\n                    Thread.sleep(delayBetweenScansMillis);\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            if (pingListener != null) {\r\n                pingListener.onFinished(new PingStats(address, pingsCompleted, noLostPackets, totalPingTime, minPingTime, maxPingTime));\r\n            }\r\n        }\r\n    }).start();\r\n    return this;\r\n}"
}, {
	"Path": "com.stealthcopter.networktools.Ping.doPing",
	"Comment": "perform a synchronous ping and return a result, will ignore number of times.note that this should be performed on a background thread as it will perform a networkrequest",
	"Method": "PingResult doPing(Ping doPing,PingListener pingListener){\r\n    try {\r\n        resolveAddressString();\r\n    } catch (UnknownHostException e) {\r\n        pingListener.onError(e);\r\n        return;\r\n    }\r\n    if (address == null) {\r\n        pingListener.onError(new NullPointerException(\"Address is null\"));\r\n        return;\r\n    }\r\n    long pingsCompleted = 0;\r\n    long noLostPackets = 0;\r\n    float totalPingTime = 0;\r\n    float minPingTime = -1;\r\n    float maxPingTime = -1;\r\n    cancelled = false;\r\n    int noPings = times;\r\n    while (noPings > 0 || times == 0) {\r\n        PingResult pingResult = PingTools.doPing(address, pingOptions);\r\n        if (pingListener != null) {\r\n            pingListener.onResult(pingResult);\r\n        }\r\n        pingsCompleted++;\r\n        if (pingResult.hasError()) {\r\n            noLostPackets++;\r\n        } else {\r\n            float timeTaken = pingResult.getTimeTaken();\r\n            totalPingTime += timeTaken;\r\n            if (maxPingTime == -1 || timeTaken > maxPingTime)\r\n                maxPingTime = timeTaken;\r\n            if (minPingTime == -1 || timeTaken < minPingTime)\r\n                minPingTime = timeTaken;\r\n        }\r\n        noPings--;\r\n        if (cancelled)\r\n            break;\r\n        try {\r\n            Thread.sleep(delayBetweenScansMillis);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n    if (pingListener != null) {\r\n        pingListener.onFinished(new PingStats(address, pingsCompleted, noLostPackets, totalPingTime, minPingTime, maxPingTime));\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.ArchiveExtractorDSProcessor.isPanelValid",
	"Comment": "indicates whether the settings in the selection and configuration panelare valid and complete.",
	"Method": "boolean isPanelValid(){\r\n    return configPanel.validatePanel();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.NewCaseWizardPanel1.setIsFinish",
	"Comment": "sets the isfinish variable in this class. isfinish variable is used todetermine whether the finish button should be disabled or not.",
	"Method": "void setIsFinish(Boolean isFinish){\r\n    this.isFinish = isFinish;\r\n    fireChangeEvent();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.core.events.ServiceEvent.getDetails",
	"Comment": "gets details string passed as input to serviceevent constructor.",
	"Method": "String getDetails(){\r\n    return details;\r\n}"
}, {
	"Path": "com.badlogic.ashley.systems.SortedIteratingSystem.forceSort",
	"Comment": "call this if the sorting criteria have changed. the actual sorting will be delayed until the entities are processed.",
	"Method": "void forceSort(){\r\n    shouldSort = true;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.RegexQuery.parseTrack2Data",
	"Comment": "parses the track 2 data from the snippet for a credit card account numberhit and turns them into artifact attributes.",
	"Method": "void parseTrack2Data(Map<BlackboardAttribute.Type, BlackboardAttribute> attributesMap,Matcher matcher){\r\n    addAttributeIfNotAlreadyCaptured(attributesMap, ATTRIBUTE_TYPE.TSK_CARD_NUMBER, \"accountNumber\", matcher);\r\n    addAttributeIfNotAlreadyCaptured(attributesMap, ATTRIBUTE_TYPE.TSK_CARD_EXPIRATION, \"expiration\", matcher);\r\n    addAttributeIfNotAlreadyCaptured(attributesMap, ATTRIBUTE_TYPE.TSK_CARD_SERVICE_CODE, \"serviceCode\", matcher);\r\n    addAttributeIfNotAlreadyCaptured(attributesMap, ATTRIBUTE_TYPE.TSK_CARD_DISCRETIONARY, \"discretionary\", matcher);\r\n    addAttributeIfNotAlreadyCaptured(attributesMap, ATTRIBUTE_TYPE.TSK_CARD_LRC, \"LRC\", matcher);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestJobContext.scheduleFiles",
	"Comment": "adds one or more files, i.e., extracted or carved files, to the ingestjob associated with this context.",
	"Method": "void scheduleFiles(List<AbstractFile> files){\r\n    this.addFilesToJob(files);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJobLogger.logMissingDataSource",
	"Comment": "logs the presence of a manifest file without a matching data source.",
	"Method": "void logMissingDataSource(){\r\n    log(MessageCategory.ERROR, \"Data source file not found\");\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.interestingitems.FilesSetPanel.getFilesSetDescription",
	"Comment": "get the description for the interesting files set defined using thispanel.",
	"Method": "String getFilesSetDescription(){\r\n    return this.descTextArea.getText();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.Logger.getLogger",
	"Comment": "finds or creates a customized logger. hides the base class factorymethod.",
	"Method": "Logger getLogger(String name,Logger getLogger,String name,String resourceBundleName){\r\n    if (!namesToLoggers.containsKey(name)) {\r\n        Logger logger = new Logger(name, resourceBundleName);\r\n        logger.addHandler(logFileHandler);\r\n        namesToLoggers.put(name, logger);\r\n    }\r\n    return namesToLoggers.get(name);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.XMLUtil.loadDocument",
	"Comment": "loads an xml document into a wc3 dom and validates it using a schemapackaged as a class resource.",
	"Method": "Document loadDocument(String docPath,Class<T> clazz,String schemaResourceName,Document loadDocument,String docPath){\r\n    DocumentBuilderFactory builderFactory = DocumentBuilderFactory.newInstance();\r\n    DocumentBuilder builder = builderFactory.newDocumentBuilder();\r\n    Document doc = builder.parse(new FileInputStream(docPath));\r\n    return doc;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.DataResultTopComponent.resetTabs",
	"Comment": "sets the node for which this result view component should providemultiple views of the underlying application data.",
	"Method": "void resetTabs(Node node){\r\n    dataResultPanel.setNode(node);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestManager.prioritizeCase",
	"Comment": "bumps the priority of all pending ingest jobs for a specified case.",
	"Method": "void prioritizeCase(String caseName){\r\n    if (state != State.RUNNING) {\r\n        return;\r\n    }\r\n    List<AutoIngestJob> jobsToPrioritize = new ArrayList();\r\n    int maxPriority = 0;\r\n    synchronized (jobsLock) {\r\n        for (AutoIngestJob job : pendingJobs) {\r\n            if (job.getPriority() > maxPriority) {\r\n                maxPriority = job.getPriority();\r\n            }\r\n            if (job.getManifest().getCaseName().equals(caseName)) {\r\n                jobsToPrioritize.add(job);\r\n            }\r\n        }\r\n        if (!jobsToPrioritize.isEmpty()) {\r\n            ++maxPriority;\r\n            for (AutoIngestJob job : jobsToPrioritize) {\r\n                int oldPriority = job.getPriority();\r\n                job.setPriority(maxPriority);\r\n                try {\r\n                    this.updateCoordinationServiceManifestNode(job);\r\n                } catch (CoordinationServiceException | InterruptedException ex) {\r\n                    job.setPriority(oldPriority);\r\n                    throw new AutoIngestManagerException(\"Error updating case priority\", ex);\r\n                }\r\n            }\r\n        }\r\n        Collections.sort(pendingJobs);\r\n    }\r\n    if (!jobsToPrioritize.isEmpty()) {\r\n        new Thread(() -> {\r\n            eventPublisher.publishRemotely(new AutoIngestCasePrioritizedEvent(LOCAL_HOST_NAME, caseName, getSystemUserNameProperty(), AutoIngestCasePrioritizedEvent.EventType.CASE_PRIORITIZED, \"\"));\r\n        }).start();\r\n    }\r\n}"
}, {
	"Path": "com.fernandocejas.arrow.checks.Preconditions.checkNotNull",
	"Comment": "ensures that an object reference passed as a parameter to the calling method is not null.",
	"Method": "T checkNotNull(T reference,T checkNotNull,T reference,Object errorMessage){\r\n    if (reference == null) {\r\n        throw new NullPointerException(String.valueOf(errorMessage));\r\n    }\r\n    return reference;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.interestingitems.FilesSetDefsPanel.doFileSetsDialog",
	"Comment": "display an interesting files set definition panel in a dialog box andrespond to user interactions with the dialog.",
	"Method": "void doFileSetsDialog(FilesSet selectedSet,boolean shouldCreateNew){\r\n    FilesSetPanel panel;\r\n    if (selectedSet != null) {\r\n        panel = new FilesSetPanel(selectedSet, panelType);\r\n    } else {\r\n        panel = new FilesSetPanel(panelType);\r\n    }\r\n    int option = JOptionPane.OK_OPTION;\r\n    do {\r\n        option = JOptionPane.showConfirmDialog(this, panel, NbBundle.getMessage(FilesSetPanel.class, filterDialogTitle), JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);\r\n    } while (option == JOptionPane.OK_OPTION && !panel.isValidDefinition());\r\n    if (this.filesSets.containsKey(panel.getFilesSetName()) && shouldCreateNew) {\r\n        MessageNotifyUtil.Message.error(NbBundle.getMessage(this.getClass(), \"FilesSetDefsPanel.doFileSetsDialog.duplicateRuleSet.text\", panel.getFilesSetName()));\r\n        return;\r\n    }\r\n    if (option == JOptionPane.OK_OPTION) {\r\n        Map<String, FilesSet.Rule> rules = new HashMap();\r\n        if (selectedSet != null) {\r\n            rules.putAll(selectedSet.getRules());\r\n        }\r\n        if (shouldCreateNew) {\r\n            this.replaceFilesSet(null, panel.getFilesSetName(), panel.getFilesSetDescription(), panel.getFileSetIgnoresKnownFiles(), panel.getFileSetIgnoresUnallocatedSpace(), rules);\r\n        } else {\r\n            this.replaceFilesSet(selectedSet, panel.getFilesSetName(), panel.getFilesSetDescription(), panel.getFileSetIgnoresKnownFiles(), panel.getFileSetIgnoresUnallocatedSpace(), rules);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.optionspanel.EamDbSettingsDialog.databaseFieldsArePopulated",
	"Comment": "tests whether or not values have been entered in all of the databasesettings text fields.",
	"Method": "boolean databaseFieldsArePopulated(){\r\n    boolean result = true;\r\n    switch(selectedPlatform) {\r\n        case POSTGRESQL:\r\n            result = !tbDbHostname.getText().trim().isEmpty() && !tbDbPort.getText().trim().isEmpty() && !tbDbUsername.getText().trim().isEmpty() && 0 < jpDbPassword.getPassword().length;\r\n            break;\r\n        case SQLITE:\r\n            result = !tfDatabasePath.getText().trim().isEmpty();\r\n            break;\r\n    }\r\n    if (!result) {\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.owntracks.android.support.Preferences.getDeviceIdDefault",
	"Comment": "not used on public, as many people might use the same device type",
	"Method": "String getDeviceIdDefault(){\r\n    return android.os.Build.DEVICE.replace(\" \", \"-\").replaceAll(\"[^a-zA-Z0-9]+\", \"\").toLowerCase();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.SQLiteTableReader.copyFileToTempDirectory",
	"Comment": "copies the file contents into a unique path in the current case tempdirectory.",
	"Method": "String copyFileToTempDirectory(AbstractFile file,long fileId){\r\n    String localDiskPath = Case.getCurrentCaseThrows().getTempDirectory() + File.separator + fileId + file.getName();\r\n    File localDatabaseFile = new File(localDiskPath);\r\n    if (!localDatabaseFile.exists()) {\r\n        ContentUtils.writeToFile(file, localDatabaseFile);\r\n    }\r\n    return localDiskPath;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.MultiUserSettingsPanel.messageServiceSettingsAreValid",
	"Comment": "tests whether or not the message service settings are valid.",
	"Method": "boolean messageServiceSettingsAreValid(){\r\n    if (!portNumberIsValid(tbMsgPort.getText().trim())) {\r\n        tbOops.setText(INVALID_MESSAGE_SERVICE_PORT_MSG);\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.FileExporter.evaluateRules",
	"Comment": "evaluates each file export rule for a data source to produce a map thatassociates the file id of each file to be exported with a list of thenames of the rules satisfied by the file.",
	"Method": "Map<Long, List<String>> evaluateRules(Content dataSource,Supplier<Boolean> cancelCheck){\r\n    TreeMap<String, FileExportRuleSet> ruleSets = settings.getRuleSets();\r\n    Map<Long, List<String>> fileIdsToRuleNames = new HashMap();\r\n    for (FileExportRuleSet ruleSet : ruleSets.values()) {\r\n        for (Rule rule : ruleSet.getRules().values()) {\r\n            if (cancelCheck.get()) {\r\n                return fileIdsToRuleNames;\r\n            }\r\n            List<Long> fileIds = rule.evaluate(dataSource.getId());\r\n            for (Long fileId : fileIds) {\r\n                List<String> ruleList;\r\n                if (!fileIdsToRuleNames.containsKey(fileId)) {\r\n                    ruleList = new ArrayList();\r\n                    fileIdsToRuleNames.put(fileId, ruleList);\r\n                } else {\r\n                    ruleList = fileIdsToRuleNames.get(fileId);\r\n                }\r\n                ruleList.add(rule.getName());\r\n            }\r\n        }\r\n    }\r\n    return fileIdsToRuleNames;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.optionspanel.EamDbSettingsDialog.wasConfigurationChanged",
	"Comment": "returns if changes to the central repository configuration were successfully applied",
	"Method": "boolean wasConfigurationChanged(){\r\n    return configurationChanged;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.ReportHTML.writeSummaryCaseDetails",
	"Comment": "write the case details section of the summary for this report.",
	"Method": "StringBuilder writeSummaryCaseDetails(){\r\n    StringBuilder summary = new StringBuilder();\r\n    String caseName = currentCase.getDisplayName();\r\n    String caseNumber = currentCase.getNumber();\r\n    String examiner = currentCase.getExaminer();\r\n    final boolean agencyLogoSet = reportBranding.getAgencyLogoPath() != null && !reportBranding.getAgencyLogoPath().isEmpty();\r\n    int imagecount;\r\n    try {\r\n        imagecount = currentCase.getDataSources().size();\r\n    } catch (TskCoreException ex) {\r\n        imagecount = 0;\r\n    }\r\n    summary.append(\"<div class=\\\"title\\\">\\n\");\r\n    if (agencyLogoSet) {\r\n        summary.append(\"<div class=\\\"left\\\">\\n\");\r\n        summary.append(\"<img src=\\\"\");\r\n        summary.append(Paths.get(reportBranding.getAgencyLogoPath()).getFileName().toString());\r\n        summary.append(\"\\\" />\\n\");\r\n        summary.append(\"<\/div>\\n\");\r\n    }\r\n    final String align = agencyLogoSet ? \"right\" : \"left\";\r\n    summary.append(\"<div class=\\\"\").append(align).append(\"\\\">\\n\");\r\n    summary.append(\"<table>\\n\");\r\n    // NON-NLS NON-NLS\r\n    summary.append(\"<tr><td>\").append(NbBundle.getMessage(this.getClass(), \"ReportHTML.writeSum.caseName\")).append(\"<\/td><td>\").append(caseName).append(\"<\/td><\/tr>\\n\");\r\n    summary.append(\"<tr><td>\").append(NbBundle.getMessage(this.getClass(), \"ReportHTML.writeSum.caseNum\")).append(\"<\/td><td>\").append(// NON-NLS\r\n    !caseNumber.isEmpty() ? caseNumber : // NON-NLS\r\n    NbBundle.getMessage(this.getClass(), \"ReportHTML.writeSum.noCaseNum\")).append(\"<\/td><\/tr>\\n\");\r\n    // NON-NLS\r\n    summary.append(\"<tr><td>\").append(NbBundle.getMessage(this.getClass(), \"ReportHTML.writeSum.examiner\")).append(\"<\/td><td>\").append(!examiner.isEmpty() ? examiner : NbBundle.getMessage(this.getClass(), \"ReportHTML.writeSum.noExaminer\")).append(\"<\/td><\/tr>\\n\");\r\n    // NON-NLS\r\n    summary.append(\"<tr><td>\").append(NbBundle.getMessage(this.getClass(), \"ReportHTML.writeSum.numImages\")).append(\"<\/td><td>\").append(imagecount).append(\"<\/td><\/tr>\\n\");\r\n    summary.append(\"<\/table>\\n\");\r\n    summary.append(\"<\/div>\\n\");\r\n    summary.append(\"<div class=\\\"clear\\\"><\/div>\\n\");\r\n    summary.append(\"<\/div>\\n\");\r\n    return summary;\r\n}"
}, {
	"Path": "com.facebook.samples.gestures.TransformGestureDetector.newInstance",
	"Comment": "factory method that creates a new instance of transformgesturedetector",
	"Method": "TransformGestureDetector newInstance(){\r\n    return new TransformGestureDetector(MultiPointerGestureDetector.newInstance());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.InterCasePanel.getCaseMap",
	"Comment": "get the map of cases which was used to populate the combo box onthis panel.",
	"Method": "Map<Integer, String> getCaseMap(){\r\n    return Collections.unmodifiableMap(this.caseMap);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.SolrSearchService.indexArtifact",
	"Comment": "adds an artifact to the keyword search text index as a concantenation ofall of its attributes.",
	"Method": "void indexArtifact(BlackboardArtifact artifact){\r\n    if (artifact == null) {\r\n        return;\r\n    }\r\n    if (artifact.getArtifactID() > 0) {\r\n        return;\r\n    }\r\n    final Ingester ingester = Ingester.getDefault();\r\n    try {\r\n        ingester.indexMetaDataOnly(artifact);\r\n        ingester.indexText(new ArtifactTextExtractor(), artifact, null);\r\n    } catch (Ingester.IngesterException ex) {\r\n        throw new TskCoreException(ex.getCause().getMessage(), ex);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.AbstractSqlEamDb.referenceSetIsValid",
	"Comment": "check whether a reference set with the given parameters exists in thecentral repository. used to check whether reference sets saved in thesettings are still present.",
	"Method": "boolean referenceSetIsValid(int referenceSetID,String setName,String version){\r\n    EamGlobalSet refSet = this.getReferenceSetByID(referenceSetID);\r\n    if (refSet == null) {\r\n        return false;\r\n    }\r\n    return (refSet.getSetName().equals(setName) && refSet.getVersion().equals(version));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.datamodel.eventtype.ArtifactEventType.getArtifactTypeID",
	"Comment": "get the id of the the artifact type that this eventtype is derived from.",
	"Method": "int getArtifactTypeID(){\r\n    return getArtifactType().getTypeID();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.AutopsyOptionsPanel.getUserFolderConfFile",
	"Comment": "get the conf file from the directory which stores the currently in usesettings. creates the directory for the file if the directory does notexist.",
	"Method": "File getUserFolderConfFile(){\r\n    String confFileName = UserPreferences.getAppName() + CONFIG_FILE_EXTENSION;\r\n    File userFolder = PlatformUtil.getUserDirectory();\r\n    File userEtcFolder = new File(userFolder, ETC_FOLDER_NAME);\r\n    if (!userEtcFolder.exists()) {\r\n        userEtcFolder.mkdir();\r\n    }\r\n    return new File(userEtcFolder, confFileName);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.AbstractSqlEamDb.getDataSourceFromCr",
	"Comment": "gets the data source details based on data source device id from thecentral repository.",
	"Method": "CorrelationDataSource getDataSourceFromCr(CorrelationCase correlationCase,Long dataSourceObjectId){\r\n    Connection conn = connect();\r\n    CorrelationDataSource eamDataSourceResult = null;\r\n    PreparedStatement preparedStatement = null;\r\n    ResultSet resultSet = null;\r\n    String sql = \"SELECT * FROM data_sources WHERE datasource_obj_id=? AND case_id=?\";\r\n    try {\r\n        preparedStatement = conn.prepareStatement(sql);\r\n        preparedStatement.setLong(1, dataSourceObjectId);\r\n        preparedStatement.setInt(2, correlationCase.getID());\r\n        resultSet = preparedStatement.executeQuery();\r\n        if (resultSet.next()) {\r\n            eamDataSourceResult = getEamDataSourceFromResultSet(resultSet);\r\n        }\r\n        if (eamDataSourceResult != null) {\r\n            dataSourceCacheById.put(getDataSourceByIdCacheKey(correlationCase.getID(), eamDataSourceResult.getID()), eamDataSourceResult);\r\n        }\r\n    } catch (SQLException ex) {\r\n        throw new EamDbException(\"Error getting data source.\", ex);\r\n    } finally {\r\n        EamDbUtil.closeStatement(preparedStatement);\r\n        EamDbUtil.closeResultSet(resultSet);\r\n        EamDbUtil.closeConnection(conn);\r\n    }\r\n    return eamDataSourceResult;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.recentactivity.Extract.getErrorMessages",
	"Comment": "returns a list of string error messages from the inheriting class",
	"Method": "List<String> getErrorMessages(){\r\n    return errorMessages;\r\n}"
}, {
	"Path": "com.anysoftkeyboard.AnySoftKeyboard.onUpdateSelection",
	"Comment": "this function is called every time them selection is changed. this alsoincludes the underlined suggestions.",
	"Method": "void onUpdateSelection(int oldSelStart,int oldSelEnd,int newSelStart,int newSelEnd,int candidatesStart,int candidatesEnd){\r\n    super.onUpdateSelection(oldSelStart, oldSelEnd, newSelStart, newSelEnd, candidatesStart, candidatesEnd);\r\n    if (mUndoCommitCursorPosition == UNDO_COMMIT_WAITING_TO_RECORD_POSITION) {\r\n        Logger.d(TAG, \"onUpdateSelection: I am in ACCEPTED_DEFAULT state, time to store the position - I can only undo-commit from here.\");\r\n        mUndoCommitCursorPosition = newSelStart;\r\n    }\r\n    updateShiftStateNow();\r\n    final boolean isExpectedEvent = SystemClock.uptimeMillis() < mExpectingSelectionUpdateBy;\r\n    mExpectingSelectionUpdateBy = NEVER_TIME_STAMP;\r\n    if (isExpectedEvent) {\r\n        Logger.v(TAG, \"onUpdateSelection: Expected event. Discarding.\");\r\n        return;\r\n    }\r\n    if (TextEntryState.willUndoCommitOnBackspace() && mUndoCommitCursorPosition == oldSelStart && mUndoCommitCursorPosition != newSelStart) {\r\n        Logger.d(TAG, \"onUpdateSelection: I am in a state that is position sensitive but the user moved the cursor, so it is not possible to undo_commit now.\");\r\n        abortCorrectionAndResetPredictionState(false);\r\n    }\r\n    if (!isPredictionOn()) {\r\n        return;\r\n    }\r\n    final InputConnection ic = getCurrentInputConnection();\r\n    if (ic == null) {\r\n        return;\r\n    }\r\n    Logger.d(TAG, \"onUpdateSelection: ok, let's see what can be done\");\r\n    if (newSelStart != newSelEnd) {\r\n        Logger.d(TAG, \"onUpdateSelection: text selection.\");\r\n        abortCorrectionAndResetPredictionState(false);\r\n    } else {\r\n        if (TextEntryState.isPredicting()) {\r\n            if (newSelStart >= candidatesStart && newSelStart <= candidatesEnd) {\r\n                int cursorPosition = newSelEnd - candidatesStart;\r\n                if (mWord.setCursorPosition(cursorPosition)) {\r\n                    Logger.d(TAG, \"onUpdateSelection: cursor moving inside the predicting word\");\r\n                }\r\n            } else {\r\n                Logger.d(TAG, \"onUpdateSelection: cursor moving outside the currently predicting word\");\r\n                abortCorrectionAndResetPredictionState(false);\r\n                postRestartWordSuggestion();\r\n            }\r\n        } else {\r\n            Logger.d(TAG, \"onUpdateSelection: not predicting at this moment, maybe the cursor is now at a new word?\");\r\n            postRestartWordSuggestion();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJob.getCaseDirectoryPath",
	"Comment": "gets the path to the case directory for job, may be the empty path if thecase directory has not been created yet.",
	"Method": "Path getCaseDirectoryPath(){\r\n    return Paths.get(caseDirectoryPath);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.ReportKML.getLong",
	"Comment": "get a long from an artifact if it exists, return null otherwise.",
	"Method": "Long getLong(BlackboardArtifact artifact,BlackboardAttribute.ATTRIBUTE_TYPE type){\r\n    Long returnValue = null;\r\n    try {\r\n        BlackboardAttribute bba = artifact.getAttribute(new BlackboardAttribute.Type(type));\r\n        if (bba != null) {\r\n            Long value = bba.getValueLong();\r\n            returnValue = value;\r\n        }\r\n    } catch (TskCoreException ex) {\r\n        logger.log(Level.SEVERE, \"Error getting Long value: \" + type.toString(), ex);\r\n    }\r\n    return returnValue;\r\n}"
}, {
	"Path": "net.dongliu.apk.parser.utils.xml.CharSequenceTranslator.with",
	"Comment": "helper method to create a merger of this translator with another set of translators. useful in customizing the standard functionality.",
	"Method": "CharSequenceTranslator with(CharSequenceTranslator translators){\r\n    final CharSequenceTranslator[] newArray = new CharSequenceTranslator[translators.length + 1];\r\n    newArray[0] = this;\r\n    System.arraycopy(translators, 0, newArray, 1, translators.length);\r\n    return new AggregateTranslator(newArray);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.events.DataSourceAnalysisEvent.getDataSourceIngestJobId",
	"Comment": "gets the id of the data source ingest job of which the analysis of thisdata source is a part.",
	"Method": "long getDataSourceIngestJobId(){\r\n    return dataSourceIngestJobId;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestServices.getConfigSettings",
	"Comment": "gets all of the global configuration settings for an ingest module.",
	"Method": "Map<String, String> getConfigSettings(String moduleName){\r\n    return ModuleSettings.getConfigSettings(moduleName);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestServices.setConfigSettings",
	"Comment": "sets all of the global configuration settings for an ingest module.",
	"Method": "void setConfigSettings(String moduleName,Map<String, String> settings){\r\n    ModuleSettings.setConfigSettings(moduleName, settings);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.configuration.AutoIngestUserPreferences.getMaxNumTimesToProcessImage",
	"Comment": "get maximum number of times to attempt processing an image folder. thisis used to avoid endless attempts to process an image folder with corruptdata that causes a crash.",
	"Method": "int getMaxNumTimesToProcessImage(){\r\n    String value = getPreferenceValue(MAX_NUM_TIMES_TO_PROCESS_IMAGE);\r\n    return value.isEmpty() ? DEFAULT_MAX_TIMES_TO_PROCESS_IMAGE : Integer.parseInt(value);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coordinationservice.CaseNodeData.getCurrentVersion",
	"Comment": "gets the current version of the case directory coordination service nodedata.",
	"Method": "int getCurrentVersion(){\r\n    return CaseNodeData.CURRENT_VERSION;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.directorytree.DirectoryTreeTopComponent.rebuildTree",
	"Comment": "rebuilds the autopsy tree.does nothing if there is no open case.",
	"Method": "void rebuildTree(){\r\n    Case currentCase;\r\n    try {\r\n        currentCase = Case.getCurrentCaseThrows();\r\n    } catch (NoCurrentCaseException ex) {\r\n        return;\r\n    }\r\n    if (null == currentCase || currentCase.hasData() == false) {\r\n        return;\r\n    }\r\n    autopsyTreeChildFactory.refreshChildren();\r\n    new SwingWorker<Void, Void>() {\r\n        @Override\r\n        protected Void doInBackground() throws Exception {\r\n            return null;\r\n        }\r\n        @Override\r\n        protected void done() {\r\n            super.done();\r\n            try {\r\n                get();\r\n                selectFirstChildNode();\r\n                resetHistory();\r\n            } catch (InterruptedException | ExecutionException ex) {\r\n                LOGGER.log(Level.SEVERE, \"Error selecting tree node.\", ex);\r\n            }\r\n        }\r\n    }.execute();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.directorytree.DirectoryTreeTopComponent.rebuildTree",
	"Comment": "rebuilds the autopsy tree.does nothing if there is no open case.",
	"Method": "void rebuildTree(){\r\n    return null;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.directorytree.DirectoryTreeTopComponent.rebuildTree",
	"Comment": "rebuilds the autopsy tree.does nothing if there is no open case.",
	"Method": "void rebuildTree(){\r\n    super.done();\r\n    try {\r\n        get();\r\n        selectFirstChildNode();\r\n        resetHistory();\r\n    } catch (InterruptedException | ExecutionException ex) {\r\n        LOGGER.log(Level.SEVERE, \"Error selecting tree node.\", ex);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.FileUtil.deleteFileDir",
	"Comment": "delete the file or dir at the given path. if the path is for a directory,recursively delete its contents.",
	"Method": "boolean deleteFileDir(File path){\r\n    boolean sucess = true;\r\n    if (path.isFile()) {\r\n        if (!path.delete()) {\r\n            sucess = false;\r\n            logger.log(Level.WARNING, \"Failed to delete file {0}\", path.getPath());\r\n        }\r\n    } else {\r\n        sucess = deleteDir(path);\r\n    }\r\n    return sucess;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.AbstractSqlEamDb.processInstanceTableWhere",
	"Comment": "process the artifact instance in the eamdb give a where clause",
	"Method": "void processInstanceTableWhere(CorrelationAttributeInstance.Type type,String whereClause,InstanceTableCallback instanceTableCallback){\r\n    if (type == null) {\r\n        throw new EamDbException(\"Correlation type is null\");\r\n    }\r\n    if (instanceTableCallback == null) {\r\n        throw new EamDbException(\"Callback interface is null\");\r\n    }\r\n    if (whereClause == null) {\r\n        throw new EamDbException(\"Where clause is null\");\r\n    }\r\n    Connection conn = connect();\r\n    PreparedStatement preparedStatement = null;\r\n    ResultSet resultSet = null;\r\n    String tableName = EamDbUtil.correlationTypeToInstanceTableName(type);\r\n    StringBuilder sql = new StringBuilder(300);\r\n    sql.append(\"select * from \").append(tableName).append(\" WHERE \").append(whereClause);\r\n    try {\r\n        preparedStatement = conn.prepareStatement(sql.toString());\r\n        resultSet = preparedStatement.executeQuery();\r\n        instanceTableCallback.process(resultSet);\r\n    } catch (SQLException ex) {\r\n        throw new EamDbException(\"Error getting all artifact instances from instances table\", ex);\r\n    } finally {\r\n        EamDbUtil.closeStatement(preparedStatement);\r\n        EamDbUtil.closeResultSet(resultSet);\r\n        EamDbUtil.closeConnection(conn);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.healthmonitor.HealthMonitor.startUpIfEnabled",
	"Comment": "called from the installer to set up the health monitor instance atstartup.",
	"Method": "void startUpIfEnabled(){\r\n    getInstance().addUserEvent(UserEvent.LOG_ON);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestMonitor.propertyChange",
	"Comment": "handles auto ingest job events published by the auto ingest nodes in anauto ingest cluster.",
	"Method": "void propertyChange(PropertyChangeEvent event){\r\n    if (event instanceof AutoIngestJobStartedEvent) {\r\n        handleJobStartedEvent((AutoIngestJobStartedEvent) event);\r\n    } else if (event instanceof AutoIngestJobStatusEvent) {\r\n        handleJobStatusEvent((AutoIngestJobStatusEvent) event);\r\n    } else if (event instanceof AutoIngestJobCompletedEvent) {\r\n        handleJobCompletedEvent((AutoIngestJobCompletedEvent) event);\r\n    } else if (event instanceof AutoIngestCasePrioritizedEvent) {\r\n        handleCasePrioritizationEvent((AutoIngestCasePrioritizedEvent) event);\r\n    } else if (event instanceof AutoIngestCaseDeletedEvent) {\r\n        handleCaseDeletedEvent((AutoIngestCaseDeletedEvent) event);\r\n    } else if (event instanceof AutoIngestNodeStateEvent) {\r\n        handleAutoIngestNodeStateEvent((AutoIngestNodeStateEvent) event);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJobLogger.logAnalysisCompleted",
	"Comment": "logs the completion of analysis of a data source by the ingest modules.",
	"Method": "void logAnalysisCompleted(){\r\n    log(MessageCategory.INFO, \"Analysis of data source completed\");\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.directorytree.ViewContextAction.actionPerformed",
	"Comment": "displays the context for some content by expanding the data sourcesbranch of the tree view to the level of the parent of the content,selecting the parent in the tree view, then selecting the content in theresults view.",
	"Method": "void actionPerformed(ActionEvent event){\r\n    EventQueue.invokeLater(() -> {\r\n        DirectoryTreeTopComponent treeViewTopComponent = DirectoryTreeTopComponent.findInstance();\r\n        ExplorerManager treeViewExplorerMgr = treeViewTopComponent.getExplorerManager();\r\n        Node parentTreeViewNode;\r\n        if (Objects.equals(CasePreferences.getGroupItemsInTreeByDataSource(), true)) {\r\n            SleuthkitCase skCase;\r\n            String dsname;\r\n            try {\r\n                skCase = Case.getCurrentCaseThrows().getSleuthkitCase();\r\n                long contentDSObjid = content.getDataSource().getId();\r\n                DataSource datasource = skCase.getDataSource(contentDSObjid);\r\n                dsname = datasource.getName();\r\n                Children rootChildren = treeViewExplorerMgr.getRootContext().getChildren();\r\n                Node datasourceGroupingNode = rootChildren.findChild(dsname);\r\n                if (!Objects.isNull(datasourceGroupingNode)) {\r\n                    Children dsChildren = datasourceGroupingNode.getChildren();\r\n                    parentTreeViewNode = dsChildren.findChild(DataSourcesNode.NAME);\r\n                } else {\r\n                    MessageNotifyUtil.Message.error(Bundle.ViewContextAction_errorMessage_cannotFindNode());\r\n                    logger.log(Level.SEVERE, \"Failed to locate data source node in tree.\");\r\n                    return;\r\n                }\r\n            } catch (NoCurrentCaseException | TskDataException | TskCoreException ex) {\r\n                MessageNotifyUtil.Message.error(Bundle.ViewContextAction_errorMessage_cannotFindNode());\r\n                logger.log(Level.SEVERE, \"Failed to locate data source node in tree.\", ex);\r\n                return;\r\n            }\r\n        } else {\r\n            parentTreeViewNode = treeViewExplorerMgr.getRootContext().getChildren().findChild(DataSourcesNode.NAME);\r\n        }\r\n        Content parentContent = null;\r\n        try {\r\n            parentContent = content.getParent();\r\n        } catch (TskCoreException ex) {\r\n            MessageNotifyUtil.Message.error(Bundle.ViewContextAction_errorMessage_cannotFindDirectory());\r\n            logger.log(Level.SEVERE, String.format(\"Could not get parent of Content object: %s\", content), ex);\r\n            return;\r\n        }\r\n        if (null != parentContent) {\r\n            AncestorVisitor ancestorVisitor = new AncestorVisitor();\r\n            List<Content> contentBranch = parentContent.accept(ancestorVisitor);\r\n            Collections.reverse(contentBranch);\r\n            Node dummyRootNode = new DirectoryTreeFilterNode(new AbstractNode(new RootContentChildren(contentBranch)), true);\r\n            Children ancestorChildren = dummyRootNode.getChildren();\r\n            Children treeNodeChildren = parentTreeViewNode.getChildren();\r\n            for (int i = 0; i < ancestorChildren.getNodesCount(); i++) {\r\n                Node ancestorNode = ancestorChildren.getNodeAt(i);\r\n                for (int j = 0; j < treeNodeChildren.getNodesCount(); j++) {\r\n                    Node treeNode = treeNodeChildren.getNodeAt(j);\r\n                    if (ancestorNode.getDisplayName().equals(treeNode.getDisplayName())) {\r\n                        parentTreeViewNode = treeNode;\r\n                        treeNodeChildren = treeNode.getChildren();\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        DisplayableItemNode undecoratedParentNode = (DisplayableItemNode) ((DirectoryTreeFilterNode) parentTreeViewNode).getOriginal();\r\n        undecoratedParentNode.setChildNodeSelectionInfo(new ContentNodeSelectionInfo(content));\r\n        TreeView treeView = treeViewTopComponent.getTree();\r\n        treeView.expandNode(parentTreeViewNode);\r\n        if (treeViewTopComponent.getSelectedNode().equals(parentTreeViewNode)) {\r\n            treeViewTopComponent.setDirectoryListingActive();\r\n            treeViewTopComponent.respondSelection(treeViewExplorerMgr.getSelectedNodes(), new Node[] { parentTreeViewNode });\r\n        } else {\r\n            try {\r\n                treeViewExplorerMgr.setExploredContextAndSelection(parentTreeViewNode, new Node[] { parentTreeViewNode });\r\n            } catch (PropertyVetoException ex) {\r\n                MessageNotifyUtil.Message.error(Bundle.ViewContextAction_errorMessage_cannotSelectDirectory());\r\n                logger.log(Level.SEVERE, \"Failed to select the parent node in the tree view\", ex);\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.gui.drawableviews.GroupPane.initialize",
	"Comment": "called automatically during constructor by fxmlconstructor.checks that fxml loading went ok and performs additional setup",
	"Method": "void initialize(){\r\n    assert cat0Toggle != null : \"fx:id=\\\"cat0Toggle\\\" was not injected: check your FXML file 'GroupPane.fxml'.\";\r\n    assert cat1Toggle != null : \"fx:id=\\\"cat1Toggle\\\" was not injected: check your FXML file 'GroupPane.fxml'.\";\r\n    assert cat2Toggle != null : \"fx:id=\\\"cat2Toggle\\\" was not injected: check your FXML file 'GroupPane.fxml'.\";\r\n    assert cat3Toggle != null : \"fx:id=\\\"cat3Toggle\\\" was not injected: check your FXML file 'GroupPane.fxml'.\";\r\n    assert cat4Toggle != null : \"fx:id=\\\"cat4Toggle\\\" was not injected: check your FXML file 'GroupPane.fxml'.\";\r\n    assert cat5Toggle != null : \"fx:id=\\\"cat5Toggle\\\" was not injected: check your FXML file 'GroupPane.fxml'.\";\r\n    assert gridView != null : \"fx:id=\\\"tilePane\\\" was not injected: check your FXML file 'GroupPane.fxml'.\";\r\n    assert catSelectedSplitMenu != null : \"fx:id=\\\"grpCatSplitMenu\\\" was not injected: check your FXML file 'GroupPane.fxml'.\";\r\n    assert tagSelectedSplitMenu != null : \"fx:id=\\\"grpTagSplitMenu\\\" was not injected: check your FXML file 'GroupPane.fxml'.\";\r\n    assert headerToolBar != null : \"fx:id=\\\"headerToolBar\\\" was not injected: check your FXML file 'GroupPane.fxml'.\";\r\n    assert segButton != null : \"fx:id=\\\"previewList\\\" was not injected: check your FXML file 'GroupPane.fxml'.\";\r\n    assert slideShowToggle != null : \"fx:id=\\\"segButton\\\" was not injected: check your FXML file 'GroupPane.fxml'.\";\r\n    assert tileToggle != null : \"fx:id=\\\"tileToggle\\\" was not injected: check your FXML file 'GroupPane.fxml'.\";\r\n    assert seenByOtherExaminersCheckBox != null : \"fx:id=\\\"seenByOtherExaminersCheckBox\\\" was not injected: check your FXML file 'GroupPane.fxml'.\";\r\n    for (DhsImageCategory cat : DhsImageCategory.values()) {\r\n        ToggleButton toggleForCategory = getToggleForCategory(cat);\r\n        toggleForCategory.setBorder(new Border(new BorderStroke(cat.getColor(), BorderStrokeStyle.SOLID, CORNER_RADII_2, BORDER_WIDTHS_2)));\r\n        toggleForCategory.getStyleClass().remove(\"radio-button\");\r\n        toggleForCategory.getStyleClass().add(\"toggle-button\");\r\n        toggleForCategory.selectedProperty().addListener((ov, wasSelected, toggleSelected) -> {\r\n            if (toggleSelected && slideShowPane != null) {\r\n                slideShowPane.getFileID().ifPresent(fileID -> {\r\n                    selectionModel.clearAndSelect(fileID);\r\n                    new CategorizeAction(controller, cat, ImmutableSet.of(fileID)).handle(null);\r\n                });\r\n            }\r\n        });\r\n    }\r\n    flashAnimation.setCycleCount(Timeline.INDEFINITE);\r\n    flashAnimation.setAutoReverse(true);\r\n    DoubleBinding cellSize = controller.thumbnailSizeProperty().add(75);\r\n    gridView.cellHeightProperty().bind(cellSize);\r\n    gridView.cellWidthProperty().bind(cellSize);\r\n    gridView.setCellFactory(param -> new DrawableCell());\r\n    BooleanBinding isSelectionEmpty = Bindings.isEmpty(selectionModel.getSelected());\r\n    catSelectedSplitMenu.disableProperty().bind(isSelectionEmpty);\r\n    tagSelectedSplitMenu.disableProperty().bind(isSelectionEmpty);\r\n    addFXCallback(exec.submit(() -> controller.getTagsManager().getFollowUpTagName()), followUpTagName -> {\r\n        TagSelectedFilesAction followUpSelectedAction = new TagSelectedFilesAction(followUpTagName, controller);\r\n        tagSelectedSplitMenu.setText(followUpSelectedAction.getText());\r\n        tagSelectedSplitMenu.setGraphic(followUpSelectedAction.getGraphic());\r\n        tagSelectedSplitMenu.setOnAction(followUpSelectedAction);\r\n    }, throwable -> logger.log(Level.SEVERE, \"Error getting tag names.\", throwable));\r\n    addFXCallback(exec.submit(() -> controller.getTagsManager().getNonCategoryTagNames()), tagNames -> {\r\n        List<MenuItem> menuItems = transform(tagNames, tagName -> createAutoAssigningMenuItem(tagSelectedSplitMenu, new TagSelectedFilesAction(tagName, controller)));\r\n        tagSelectedSplitMenu.getItems().setAll(menuItems);\r\n    }, throwable -> logger.log(Level.SEVERE, \"Error getting tag names.\", throwable));\r\n    CategorizeSelectedFilesAction cat5SelectedAction = new CategorizeSelectedFilesAction(DhsImageCategory.FIVE, controller);\r\n    catSelectedSplitMenu.setOnAction(cat5SelectedAction);\r\n    catSelectedSplitMenu.setText(cat5SelectedAction.getText());\r\n    catSelectedSplitMenu.setGraphic(cat5SelectedAction.getGraphic());\r\n    List<MenuItem> categoryMenues = transform(asList(DhsImageCategory.values()), cat -> createAutoAssigningMenuItem(catSelectedSplitMenu, new CategorizeSelectedFilesAction(cat, controller)));\r\n    catSelectedSplitMenu.getItems().setAll(categoryMenues);\r\n    slideShowToggle.getStyleClass().remove(\"radio-button\");\r\n    slideShowToggle.getStyleClass().add(\"toggle-button\");\r\n    tileToggle.getStyleClass().remove(\"radio-button\");\r\n    tileToggle.getStyleClass().add(\"toggle-button\");\r\n    bottomLabel.setText(Bundle.GroupPane_bottomLabel_displayText());\r\n    headerLabel.setText(Bundle.GroupPane_hederLabel_displayText());\r\n    catContainerLabel.setText(Bundle.GroupPane_catContainerLabel_displayText());\r\n    catHeadingLabel.setText(Bundle.GroupPane_catHeadingLabel_displayText());\r\n    headerToolBar.getItems().remove(catSegmentedContainer);\r\n    groupViewMode.addListener((ObservableValue<? extends GroupViewMode> observable, GroupViewMode oldValue, GroupViewMode newValue) -> {\r\n        if (newValue == GroupViewMode.SLIDE_SHOW) {\r\n            headerToolBar.getItems().remove(catSplitMenuContainer);\r\n            headerToolBar.getItems().add(catSegmentedContainer);\r\n        } else {\r\n            headerToolBar.getItems().remove(catSegmentedContainer);\r\n            headerToolBar.getItems().add(catSplitMenuContainer);\r\n        }\r\n    });\r\n    slideShowToggle.setOnAction(onAction -> activateSlideShowViewer(selectionModel.lastSelectedProperty().get()));\r\n    tileToggle.setOnAction(onAction -> activateTileViewer());\r\n    controller.viewStateProperty().addListener((observable, oldViewState, newViewState) -> setViewState(newViewState));\r\n    addEventFilter(KeyEvent.KEY_PRESSED, tileKeyboardNavigationHandler);\r\n    gridView.addEventHandler(MouseEvent.MOUSE_CLICKED, new MouseHandler());\r\n    ActionUtils.configureButton(undoAction, undoButton);\r\n    ActionUtils.configureButton(redoAction, redoButton);\r\n    ActionUtils.configureButton(forwardAction, forwardButton);\r\n    ActionUtils.configureButton(backAction, backButton);\r\n    ActionUtils.configureButton(nextGroupAction, nextButton);\r\n    final EventHandler<ActionEvent> onAction = nextButton.getOnAction();\r\n    nextButton.setOnAction(actionEvent -> {\r\n        flashAnimation.stop();\r\n        nextButton.setEffect(null);\r\n        onAction.handle(actionEvent);\r\n    });\r\n    nextGroupAction.disabledProperty().addListener((Observable observable) -> {\r\n        boolean newValue = nextGroupAction.isDisabled();\r\n        nextButton.setEffect(newValue ? null : DROP_SHADOW);\r\n        if (newValue) {\r\n            flashAnimation.stop();\r\n        } else {\r\n            flashAnimation.play();\r\n        }\r\n    });\r\n    seenByOtherExaminersCheckBox.selectedProperty().addListener((observable, oldValue, newValue) -> {\r\n        nextButtonPane.setDisable(true);\r\n        nextButtonPane.setCursor(Cursor.WAIT);\r\n        exec.submit(() -> controller.getGroupManager().setCollaborativeMode(newValue)).addListener(() -> {\r\n            nextButtonPane.setDisable(false);\r\n            nextButtonPane.setCursor(Cursor.DEFAULT);\r\n        }, Platform::runLater);\r\n    });\r\n    selectionModel.lastSelectedProperty().addListener((observable, oldFileID, newFileId) -> {\r\n        if (groupViewMode.get() == GroupViewMode.SLIDE_SHOW && slideShowPane != null) {\r\n            slideShowPane.setFile(newFileId);\r\n        } else {\r\n            scrollToFileID(newFileId);\r\n        }\r\n    });\r\n    setViewState(controller.viewStateProperty().get());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.Case.displayNameToUniqueName",
	"Comment": "transforms a case display name into a unique case name that can be usedto identify the case even if the display name is changed.",
	"Method": "String displayNameToUniqueName(String caseDisplayName){\r\n    String uniqueCaseName = caseDisplayName.replaceAll(\"[^\\\\p{ASCII}]\", \"_\");\r\n    uniqueCaseName = uniqueCaseName.replaceAll(\"[\\\\p{Cntrl}]\", \"_\");\r\n    uniqueCaseName = uniqueCaseName.replaceAll(\"[ /?:'\\\"\\\\\\\\]\", \"_\");\r\n    uniqueCaseName = uniqueCaseName.toLowerCase();\r\n    SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyyMMdd_HHmmss\");\r\n    Date date = new Date();\r\n    uniqueCaseName = uniqueCaseName + \"_\" + dateFormat.format(date);\r\n    return uniqueCaseName;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.AddEditCentralRepoCommentAction.getComment",
	"Comment": "retrieve the comment that was last saved. if a comment update wascanceled or an error occurred while attempting to save the comment, thecomment will be null.",
	"Method": "String getComment(){\r\n    return comment;\r\n}"
}, {
	"Path": "com.google.example.games.catt2.SaveGame.zero",
	"Comment": "resets this savegame object to be empty. empty means no stars on no levels.",
	"Method": "void zero(){\r\n    mLevelStars.clear();\r\n}"
}, {
	"Path": "com.github.pires.obd.reader.activity.MainActivity.releaseWakeLockIfHeld",
	"Comment": "if lock is held, release. lock will be held when the service is running.",
	"Method": "void releaseWakeLockIfHeld(){\r\n    if (wakeLock.isHeld())\r\n        wakeLock.release();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.interestingitems.FilesSetsManager.setCustomFileIngestFilters",
	"Comment": "sets the current interesting file sets definitions, replacing anyprevious definitions.",
	"Method": "void setCustomFileIngestFilters(Map<String, FilesSet> filesSets){\r\n    synchronized (FILE_INGEST_FILTER_LOCK) {\r\n        FileSetsDefinitions.writeDefinitionsFile(FILE_INGEST_FILTER_DEFS_NAME, filesSets);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.DataContentViewerArtifact.setArtifactContents",
	"Comment": "populate the cache of artifact represented as resultstableartifacts.",
	"Method": "void setArtifactContents(List<ResultsTableArtifact> artifactList){\r\n    synchronized (lock) {\r\n        this.artifactTableContents = artifactList;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.interestingitems.InterestingItemsFilesSetSettings.readMimeCondition",
	"Comment": "construct a mime type condition for a filesset membership rule from datain an xml element.",
	"Method": "MimeTypeCondition readMimeCondition(Element elem){\r\n    MimeTypeCondition mimeCondition = null;\r\n    if (!elem.getAttribute(MIME_ATTR).isEmpty()) {\r\n        mimeCondition = new MimeTypeCondition(elem.getAttribute(MIME_ATTR));\r\n    }\r\n    return mimeCondition;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.ResultViewerPersistence.getColumnHiddenKey",
	"Comment": "gets a key for the given node and a property of its child nodes to storethe visibility into a preference file.",
	"Method": "String getColumnHiddenKey(TableFilterNode node,String propName){\r\n    return getColumnKeyBase(node, propName) + \".hidden\";\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.filetypeid.FileTypeDetector.detect",
	"Comment": "detects the mime type of a file. the result is not added to the casedatabase.",
	"Method": "String detect(AbstractFile file){\r\n    String fileType = getMIMEType(file);\r\n    return fileType;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.LocalFilesDSProcessor.getPanel",
	"Comment": "gets the panel that allows a user to select a data source and do anyconfiguration required by the data source. the panel is less than 544pixels wide and less than 173 pixels high.",
	"Method": "JPanel getPanel(){\r\n    configPanel.select();\r\n    return configPanel;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.ImageDSProcessor.setDataSourceOptions",
	"Comment": "sets the configuration of the data source processor without using theselection and configuration panel.",
	"Method": "void setDataSourceOptions(String imagePath,String timeZone,boolean ignoreFatOrphanFiles){\r\n    this.deviceId = UUID.randomUUID().toString();\r\n    this.imagePath = imagePath;\r\n    this.sectorSize = 0;\r\n    this.timeZone = Calendar.getInstance().getTimeZone().getID();\r\n    this.ignoreFatOrphanFiles = ignoreFatOrphanFiles;\r\n    setDataSourceOptionsCalled = true;\r\n}"
}, {
	"Path": "com.mcxiaoke.next.io.CountingInputStream.skip",
	"Comment": "skips the stream over the specified number of bytes, adding the skippedamount to the count.",
	"Method": "long skip(long length){\r\n    final long skip = super.skip(length);\r\n    this.count += skip;\r\n    return skip;\r\n}"
}, {
	"Path": "com.tngtech.archunit.core.importer.Locations.ofPackage",
	"Comment": "all locations in the classpath that match the supplied package.",
	"Method": "Set<Location> ofPackage(String pkg){\r\n    ImmutableSet.Builder<Location> result = ImmutableSet.builder();\r\n    for (Location location : getLocationsOf(asResourceName(pkg))) {\r\n        result.add(location);\r\n    }\r\n    return result.build();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.SingleUserCaseConverter.fixPaths",
	"Comment": "fix up any paths in the database that refer to items that have moved.candidates include events.db, input images, reports, file paths, etc.",
	"Method": "void fixPaths(ImportCaseData icd){\r\n    String input = icd.getImageInputFolder().toString();\r\n    String output = icd.getImageOutputFolder().toString();\r\n    Connection postgresqlConnection = getPostgreSQLConnection(icd);\r\n    if (postgresqlConnection != null) {\r\n        String hostName = NetworkUtils.getLocalHostName();\r\n        Statement updateStatement = postgresqlConnection.createStatement();\r\n        updateStatement.executeUpdate(\"UPDATE reports SET path=CONCAT('\" + hostName + \"/', path) WHERE path IS NOT NULL AND path != ''\");\r\n        updateStatement = postgresqlConnection.createStatement();\r\n        updateStatement.executeUpdate(\"UPDATE tsk_files_path SET path=CONCAT('\" + hostName + \"\\\\', path) WHERE path IS NOT NULL AND path != ''\");\r\n        String caseName = icd.getRawFolderName().toLowerCase();\r\n        if (icd.getCopySourceImages()) {\r\n            Statement inputStatement = postgresqlConnection.createStatement();\r\n            ResultSet inputResultSet = inputStatement.executeQuery(\"SELECT * FROM tsk_image_names\");\r\n            while (inputResultSet.next()) {\r\n                Path oldPath = Paths.get(inputResultSet.getString(2));\r\n                for (int x = 0; x < oldPath.getNameCount(); ++x) {\r\n                    if (oldPath.getName(x).toString().toLowerCase().equals(caseName)) {\r\n                        Path newPath = Paths.get(output, oldPath.subpath(x + 1, oldPath.getNameCount()).toString());\r\n                        updateStatement = postgresqlConnection.createStatement();\r\n                        updateStatement.executeUpdate(\"UPDATE tsk_image_names SET name='\" + newPath.toString() + \"' WHERE obj_id = \" + inputResultSet.getInt(1));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        postgresqlConnection.close();\r\n    } else {\r\n        throw new Exception(NbBundle.getMessage(SingleUserCaseConverter.class, \"SingleUserCaseConverter.CanNotOpenDatabase\"));\r\n    }\r\n}"
}, {
	"Path": "com.mcxiaoke.next.collection.WeakFastHashMap.entrySet",
	"Comment": "return a collection view of the mappings contained in this map.eachelement in the returned collection is a map.entry.",
	"Method": "Set<Entry<K, V>> entrySet(){\r\n    return new EntrySet();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.NewCaseVisualPanel1.caseDirBrowseButtonActionPerformed",
	"Comment": "the action when the browse button is pressed. the browse button will popup the file chooser window to choose where the user wants to save thecase directory.",
	"Method": "void caseDirBrowseButtonActionPerformed(java.awt.event.ActionEvent evt){\r\n    fileChooser.setDragEnabled(false);\r\n    if (!caseParentDirTextField.getText().trim().equals(\"\")) {\r\n        fileChooser.setCurrentDirectory(new File(caseParentDirTextField.getText()));\r\n    }\r\n    fileChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);\r\n    int choice = fileChooser.showDialog((Component) evt.getSource(), NbBundle.getMessage(this.getClass(), \"NewCaseVisualPanel1.caseDirBrowse.selectButton.text\"));\r\n    if (JFileChooser.APPROVE_OPTION == choice) {\r\n        String path = fileChooser.getSelectedFile().getPath();\r\n        caseParentDirTextField.setText(path);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.ui.detailview.DetailsChartLane.computeYTop",
	"Comment": "given information about the current layout pass so far and about aparticular node, compute the y position of that node.",
	"Method": "double computeYTop(double yMin,double h,TreeRangeMap<Double, Double> maxXatY,double xLeft,double xRight){\r\n    double yTop = yMin;\r\n    double yBottom = yTop + h;\r\n    boolean overlapping = true;\r\n    while (overlapping) {\r\n        overlapping = false;\r\n        for (double y = yBottom; y >= yTop; y -= MINIMUM_ROW_HEIGHT) {\r\n            final Double maxX = maxXatY.get(y);\r\n            if (maxX != null && maxX >= xLeft - MINIMUM_EVENT_NODE_GAP) {\r\n                overlapping = true;\r\n                yTop = y + MINIMUM_EVENT_NODE_GAP;\r\n                yBottom = yTop + h;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    maxXatY.put(Range.closed(yTop, yBottom), xRight);\r\n    return yTop;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.DataContentTopComponent.findInstance",
	"Comment": "obtain the default datacontenttopcomponent default instance. never callgetdefault directly!",
	"Method": "DataContentTopComponent findInstance(){\r\n    TopComponent win = WindowManager.getDefault().findTopComponent(PREFERRED_ID);\r\n    if (win == null) {\r\n        logger.warning(\"Cannot find \" + PREFERRED_ID + \" component. It will not be located properly in the window system.\");\r\n        return getDefault();\r\n    }\r\n    if (win instanceof DataContentTopComponent) {\r\n        return (DataContentTopComponent) win;\r\n    }\r\n    // NON-NLS\r\n    logger.warning(\"There seem to be multiple components with the '\" + PREFERRED_ID + \"' ID. That is a potential source of errors and unexpected behavior.\");\r\n    return getDefault();\r\n}"
}, {
	"Path": "org.wikipedia.gallery.GalleryItemFragment.loadMedia",
	"Comment": "load the actual media associated with our gallery item into the ui.",
	"Method": "void loadMedia(){\r\n    if (FileUtil.isVideo(galleryItem.getType())) {\r\n        loadVideo();\r\n    } else {\r\n        loadImage(galleryItem.getPreferredSizedImageUrl());\r\n    }\r\n    parentActivity.supportInvalidateOptionsMenu();\r\n    parentActivity.layOutGalleryDescription();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJob.setPriority",
	"Comment": "sets the priority of the job. a higher number indicates a higherpriority.",
	"Method": "void setPriority(Integer priority){\r\n    this.priority = priority;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestManager.cancelCurrentJob",
	"Comment": "starts the process of cancelling the current job.note that the current job is included in the running list for a whilebecause it can take some time for the automated ingest process for thejob to be shut down in an orderly fashion.",
	"Method": "void cancelCurrentJob(){\r\n    if (State.RUNNING != state) {\r\n        return;\r\n    }\r\n    synchronized (jobsLock) {\r\n        if (null != currentJob) {\r\n            currentJob.cancel();\r\n            sysLogger.log(Level.INFO, \"Cancelling automated ingest for manifest {0}\", currentJob.getManifest().getFilePath());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.IngestSearchRunner.endJob",
	"Comment": "perform normal finishing of searching for this job, including one lastcommit and search. blocks until the final search is complete.",
	"Method": "void endJob(long jobId){\r\n    SearchJobInfo job;\r\n    boolean readyForFinalSearch = false;\r\n    job = jobs.get(jobId);\r\n    if (job == null) {\r\n        return;\r\n    }\r\n    if (job.decrementModuleReferenceCount() == 0) {\r\n        jobs.remove(jobId);\r\n        readyForFinalSearch = true;\r\n    }\r\n    if (readyForFinalSearch) {\r\n        logger.log(Level.INFO, \"Commiting search index before final search for search job {0}\", job.getJobId());\r\n        commit();\r\n        doFinalSearch(job);\r\n        if (jobs.isEmpty()) {\r\n            logger.log(Level.INFO, \"No more search jobs. Stopping periodic search task\");\r\n            periodicSearchTaskRunning = false;\r\n            jobProcessingTaskFuture.cancel(true);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.iOS.ContactAnalyzer.findContacts",
	"Comment": "find contacts given an ingest job context and index the results.",
	"Method": "void findContacts(IngestJobContext context){\r\n    Case openCase;\r\n    try {\r\n        openCase = Case.getCurrentCaseThrows();\r\n    } catch (NoCurrentCaseException ex) {\r\n        logger.log(Level.SEVERE, \"Exception while getting open case.\", ex);\r\n        return;\r\n    }\r\n    blackboard = openCase.getServices().getBlackboard();\r\n    List<AbstractFile> absFiles;\r\n    try {\r\n        SleuthkitCase skCase = openCase.getSleuthkitCase();\r\n        absFiles = skCase.findAllFilesWhere(\"LOWER(name) LIKE LOWER('Êll_history%') \");\r\n        if (absFiles.isEmpty()) {\r\n            return;\r\n        }\r\n        for (AbstractFile file : absFiles) {\r\n            try {\r\n                jFile = new java.io.File(openCase.getTempDirectory(), file.getName().replaceAll(\"[<>%|\\\"/:*\\\\\\\\]\", \"\"));\r\n                dbPath = jFile.toString();\r\n                fileId = file.getId();\r\n                ContentUtils.writeToFile(file, jFile, context::dataSourceIngestIsCancelled);\r\n            } catch (ReadContentInputStreamException ex) {\r\n                logger.log(Level.WARNING, String.format(\"Error reading content from file '%s' (id=%d).\", file.getName(), fileId), ex);\r\n            } catch (Exception ex) {\r\n                logger.log(Level.SEVERE, String.format(\"Error writing content from file '%s' (id=%d) to '%s'.\", file.getName(), fileId, dbPath), ex);\r\n            }\r\n        }\r\n    } catch (TskCoreException e) {\r\n        logger.log(Level.SEVERE, \"Error finding Contacts\", e);\r\n    }\r\n}"
}, {
	"Path": "org.wikipedia.language.LanguageUtil.getAvailableLanguages",
	"Comment": "gets a list of language codes currently enabled by the user.guarantees at least one language code returned.",
	"Method": "List<String> getAvailableLanguages(){\r\n    List<String> languages = new ArrayList();\r\n    LocaleListCompat localeList = LocaleListCompat.getDefault();\r\n    for (int i = 0; i < localeList.size(); i++) {\r\n        String languageCode = localeToWikiLanguageCode(localeList.get(i));\r\n        if (!languages.contains(languageCode)) {\r\n            languages.add(languageCode);\r\n        }\r\n    }\r\n    if (languages.isEmpty()) {\r\n        languages.add(localeToWikiLanguageCode(Locale.getDefault()));\r\n    }\r\n    InputMethodManager imm = (InputMethodManager) WikipediaApp.getInstance().getSystemService(Context.INPUT_METHOD_SERVICE);\r\n    if (imm != null) {\r\n        List<InputMethodInfo> ims = imm.getEnabledInputMethodList();\r\n        if (ims == null) {\r\n            ims = Collections.emptyList();\r\n        }\r\n        List<String> langTagList = new ArrayList();\r\n        for (InputMethodInfo method : ims) {\r\n            List<InputMethodSubtype> submethods = imm.getEnabledInputMethodSubtypeList(method, true);\r\n            if (submethods == null) {\r\n                submethods = Collections.emptyList();\r\n            }\r\n            for (InputMethodSubtype submethod : submethods) {\r\n                if (submethod.getMode().equals(\"keyboard\")) {\r\n                    String langTag = Build.VERSION.SDK_INT >= Build.VERSION_CODES.N && !TextUtils.isEmpty(submethod.getLanguageTag()) ? submethod.getLanguageTag() : submethod.getLocale();\r\n                    if (TextUtils.isEmpty(langTag)) {\r\n                        continue;\r\n                    }\r\n                    if (langTag.contains(\"_\")) {\r\n                        langTag = langTag.replace('_', '-');\r\n                    }\r\n                    if (!langTagList.contains(langTag)) {\r\n                        langTagList.add(langTag);\r\n                    }\r\n                    if (langTag.toLowerCase().equals(AppLanguageLookUpTable.CHINESE_CN_LANGUAGE_CODE) && !langTagList.contains(\"zh-TW\")) {\r\n                        langTagList.add(\"zh-TW\");\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (!langTagList.isEmpty()) {\r\n            localeList = LocaleListCompat.forLanguageTags(StringUtil.listToCsv(langTagList));\r\n            for (int i = 0; i < localeList.size(); i++) {\r\n                String langCode = localeToWikiLanguageCode(localeList.get(i));\r\n                if (!TextUtils.isEmpty(langCode) && !languages.contains(langCode) && !langCode.equals(\"und\")) {\r\n                    languages.add(langCode);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return languages;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestManager.pause",
	"Comment": "pauses processing of the pending jobs queue. the currently running jobwill continue to run to completion.",
	"Method": "void pause(){\r\n    if (State.RUNNING != state) {\r\n        return;\r\n    }\r\n    jobProcessingTask.requestPause();\r\n}"
}, {
	"Path": "net.ypresto.androidtranscoder.engine.TextureRender.surfaceCreated",
	"Comment": "initializes gl state.call this after the egl surface has been created and made current.",
	"Method": "void surfaceCreated(){\r\n    mProgram = createProgram(VERTEX_SHADER, FRAGMENT_SHADER);\r\n    if (mProgram == 0) {\r\n        throw new RuntimeException(\"failed creating program\");\r\n    }\r\n    maPositionHandle = GLES20.glGetAttribLocation(mProgram, \"aPosition\");\r\n    checkGlError(\"glGetAttribLocation aPosition\");\r\n    if (maPositionHandle == -1) {\r\n        throw new RuntimeException(\"Could not get attrib location for aPosition\");\r\n    }\r\n    maTextureHandle = GLES20.glGetAttribLocation(mProgram, \"aTextureCoord\");\r\n    checkGlError(\"glGetAttribLocation aTextureCoord\");\r\n    if (maTextureHandle == -1) {\r\n        throw new RuntimeException(\"Could not get attrib location for aTextureCoord\");\r\n    }\r\n    muMVPMatrixHandle = GLES20.glGetUniformLocation(mProgram, \"uMVPMatrix\");\r\n    checkGlError(\"glGetUniformLocation uMVPMatrix\");\r\n    if (muMVPMatrixHandle == -1) {\r\n        throw new RuntimeException(\"Could not get attrib location for uMVPMatrix\");\r\n    }\r\n    muSTMatrixHandle = GLES20.glGetUniformLocation(mProgram, \"uSTMatrix\");\r\n    checkGlError(\"glGetUniformLocation uSTMatrix\");\r\n    if (muSTMatrixHandle == -1) {\r\n        throw new RuntimeException(\"Could not get attrib location for uSTMatrix\");\r\n    }\r\n    int[] textures = new int[1];\r\n    GLES20.glGenTextures(1, textures, 0);\r\n    mTextureID = textures[0];\r\n    GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, mTextureID);\r\n    checkGlError(\"glBindTexture mTextureID\");\r\n    GLES20.glTexParameterf(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);\r\n    GLES20.glTexParameterf(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);\r\n    GLES20.glTexParameteri(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);\r\n    GLES20.glTexParameteri(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);\r\n    checkGlError(\"glTexParameter\");\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.SqliteEamDbSettings.setDbDirectory",
	"Comment": "path for directory to hold the sqlite database.user must have write permission to this directory.",
	"Method": "void setDbDirectory(String dbDirectory){\r\n    if (dbDirectory != null && !dbDirectory.isEmpty()) {\r\n        this.dbDirectory = dbDirectory;\r\n    } else {\r\n        throw new EamDbException(\"Invalid directory for sqlite database. Cannot empty\");\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.SingleUserCaseConverter.importDb",
	"Comment": "import the database from sqlite to postgresql. do not change any of thedata while loading it over. fixing paths is done once the database iscompletely imported.",
	"Method": "void importDb(ImportCaseData icd){\r\n    deconflictDatabaseName(icd);\r\n    SleuthkitCase newCase = SleuthkitCase.newCase(icd.getPostgreSQLDbName(), icd.getDb(), icd.getCaseOutputFolder().toString());\r\n    newCase.close();\r\n    Class.forName(\"org.sqlite.JDBC\");\r\n    Connection sqliteConnection = getSQLiteConnection(icd);\r\n    Connection postgreSQLConnection = getPostgreSQLConnection(icd);\r\n    Statement inputStatement = sqliteConnection.createStatement();\r\n    ResultSet inputResultSet = inputStatement.executeQuery(\"SELECT * FROM blackboard_artifact_types\");\r\n    Statement outputStatement;\r\n    Statement numberingPK;\r\n    long biggestPK = 0;\r\n    while (inputResultSet.next()) {\r\n        try {\r\n            long value = inputResultSet.getLong(1);\r\n            if (value > biggestPK) {\r\n                biggestPK = value;\r\n            }\r\n            Statement check = postgreSQLConnection.createStatement();\r\n            ResultSet checkResult = check.executeQuery(\"SELECT * FROM blackboard_artifact_types WHERE artifact_type_id=\" + value + \" AND type_name LIKE '\" + inputResultSet.getString(2) + \"' AND display_name LIKE '\" + inputResultSet.getString(3) + \"'\");\r\n            if (!checkResult.isBeforeFirst()) {\r\n                // NON-NLS\r\n                String sql = \"INSERT INTO blackboard_artifact_types (artifact_type_id, type_name, display_name) VALUES (\" + value + \", '\" + SleuthkitCase.escapeSingleQuotes(inputResultSet.getString(2)) + \"',\" + \" ? )\";\r\n                PreparedStatement pst = postgreSQLConnection.prepareStatement(sql);\r\n                populateNullableString(pst, inputResultSet, 3, 1);\r\n                pst.executeUpdate();\r\n            }\r\n        } catch (SQLException ex) {\r\n            if (ex.getErrorCode() != 0) {\r\n                throw new SQLException(ex);\r\n            }\r\n        }\r\n    }\r\n    numberingPK = postgreSQLConnection.createStatement();\r\n    numberingPK.execute(\"ALTER SEQUENCE blackboard_artifact_types_artifact_type_id_seq RESTART WITH \" + (biggestPK + 1));\r\n    biggestPK = 0;\r\n    inputStatement = sqliteConnection.createStatement();\r\n    inputResultSet = inputStatement.executeQuery(\"SELECT * FROM blackboard_attribute_types\");\r\n    while (inputResultSet.next()) {\r\n        try {\r\n            long value = inputResultSet.getLong(1);\r\n            if (value > biggestPK) {\r\n                biggestPK = value;\r\n            }\r\n            Statement check = postgreSQLConnection.createStatement();\r\n            ResultSet checkResult = check.executeQuery(\"SELECT * FROM blackboard_attribute_types WHERE attribute_type_id=\" + value + \" AND type_name LIKE '\" + inputResultSet.getString(2) + \"' AND display_name LIKE '\" + inputResultSet.getString(3) + \"'\");\r\n            if (!checkResult.isBeforeFirst()) {\r\n                // NON-NLS\r\n                String sql = \"INSERT INTO blackboard_attribute_types (attribute_type_id, type_name, display_name) VALUES (\" + value + \", '\" + SleuthkitCase.escapeSingleQuotes(inputResultSet.getString(2)) + \"',\" + \" ? )\";\r\n                PreparedStatement pst = postgreSQLConnection.prepareStatement(sql);\r\n                populateNullableString(pst, inputResultSet, 3, 1);\r\n                pst.executeUpdate();\r\n            }\r\n        } catch (SQLException ex) {\r\n            if (ex.getErrorCode() != 0) {\r\n                throw new SQLException(ex);\r\n            }\r\n        }\r\n    }\r\n    numberingPK = postgreSQLConnection.createStatement();\r\n    numberingPK.execute(\"ALTER SEQUENCE blackboard_attribute_types_attribute_type_id_seq RESTART WITH \" + (biggestPK + 1));\r\n    biggestPK = 0;\r\n    inputStatement = sqliteConnection.createStatement();\r\n    inputResultSet = inputStatement.executeQuery(\"SELECT * FROM tsk_objects\");\r\n    while (inputResultSet.next()) {\r\n        outputStatement = postgreSQLConnection.createStatement();\r\n        try {\r\n            long value = inputResultSet.getLong(1);\r\n            if (value > biggestPK) {\r\n                biggestPK = value;\r\n            }\r\n            // NON-NLS\r\n            outputStatement.executeUpdate(\"INSERT INTO tsk_objects (obj_id, par_obj_id, type) VALUES (\" + value + \",\" + getNullableLong(inputResultSet, 2) + \",\" + inputResultSet.getInt(3) + \")\");\r\n        } catch (SQLException ex) {\r\n            if (ex.getErrorCode() != 0) {\r\n                throw new SQLException(ex);\r\n            }\r\n        }\r\n    }\r\n    numberingPK = postgreSQLConnection.createStatement();\r\n    numberingPK.execute(\"ALTER SEQUENCE tsk_objects_obj_id_seq RESTART WITH \" + (biggestPK + 1));\r\n    inputStatement = sqliteConnection.createStatement();\r\n    inputResultSet = inputStatement.executeQuery(\"SELECT * FROM tsk_image_names\");\r\n    while (inputResultSet.next()) {\r\n        outputStatement = postgreSQLConnection.createStatement();\r\n        try {\r\n            // NON-NLS\r\n            outputStatement.executeUpdate(\"INSERT INTO tsk_image_names (obj_id, name, sequence) VALUES (\" + inputResultSet.getLong(1) + \",'\" + inputResultSet.getString(2) + \"',\" + inputResultSet.getInt(3) + \")\");\r\n        } catch (SQLException ex) {\r\n            if (ex.getErrorCode() != 0) {\r\n                throw new SQLException(ex);\r\n            }\r\n        }\r\n    }\r\n    biggestPK = 0;\r\n    inputStatement = sqliteConnection.createStatement();\r\n    inputResultSet = inputStatement.executeQuery(\"SELECT * FROM tsk_image_info\");\r\n    while (inputResultSet.next()) {\r\n        try {\r\n            long value = inputResultSet.getLong(1);\r\n            if (value > biggestPK) {\r\n                biggestPK = value;\r\n            }\r\n            // NON-NLS\r\n            String sql = \"INSERT INTO tsk_image_info (obj_id, type, ssize, tzone, size, md5, display_name) VALUES (\" + value + \",\" + getNullableInt(inputResultSet, 2) + \",\" + getNullableInt(inputResultSet, 3) + \",\" + \" ? ,\" + getNullableLong(inputResultSet, 5) + \",\" + \" ? ,\" + \" ? )\";\r\n            PreparedStatement pst = postgreSQLConnection.prepareStatement(sql);\r\n            populateNullableString(pst, inputResultSet, 4, 1);\r\n            populateNullableString(pst, inputResultSet, 6, 2);\r\n            populateNullableString(pst, inputResultSet, 7, 3);\r\n            pst.executeUpdate();\r\n        } catch (SQLException ex) {\r\n            if (ex.getErrorCode() != 0) {\r\n                throw new SQLException(ex);\r\n            }\r\n        }\r\n    }\r\n    numberingPK = postgreSQLConnection.createStatement();\r\n    numberingPK.execute(\"ALTER SEQUENCE tsk_image_info_obj_id_seq RESTART WITH \" + (biggestPK + 1));\r\n    biggestPK = 0;\r\n    inputStatement = sqliteConnection.createStatement();\r\n    inputResultSet = inputStatement.executeQuery(\"SELECT * FROM tsk_fs_info\");\r\n    while (inputResultSet.next()) {\r\n        try {\r\n            long value = inputResultSet.getLong(1);\r\n            if (value > biggestPK) {\r\n                biggestPK = value;\r\n            }\r\n            // NON-NLS\r\n            String sql = \"INSERT INTO tsk_fs_info (obj_id, img_offset, fs_type, block_size, block_count, root_inum, first_inum, last_inum, display_name) VALUES (\" + value + \",\" + inputResultSet.getLong(2) + \",\" + inputResultSet.getInt(3) + \",\" + inputResultSet.getLong(4) + \",\" + inputResultSet.getLong(5) + \",\" + inputResultSet.getLong(6) + \",\" + inputResultSet.getLong(7) + \",\" + inputResultSet.getLong(8) + \",\" + \" ? )\";\r\n            PreparedStatement pst = postgreSQLConnection.prepareStatement(sql);\r\n            populateNullableString(pst, inputResultSet, 9, 1);\r\n            pst.executeUpdate();\r\n        } catch (SQLException ex) {\r\n            if (ex.getErrorCode() != 0) {\r\n                throw new SQLException(ex);\r\n            }\r\n        }\r\n    }\r\n    numberingPK = postgreSQLConnection.createStatement();\r\n    numberingPK.execute(\"ALTER SEQUENCE tsk_fs_info_obj_id_seq RESTART WITH \" + (biggestPK + 1));\r\n    biggestPK = 0;\r\n    inputStatement = sqliteConnection.createStatement();\r\n    inputResultSet = inputStatement.executeQuery(\"SELECT * FROM tsk_files_path\");\r\n    while (inputResultSet.next()) {\r\n        outputStatement = postgreSQLConnection.createStatement();\r\n        try {\r\n            long value = inputResultSet.getLong(1);\r\n            if (value > biggestPK) {\r\n                biggestPK = value;\r\n            }\r\n            int encoding = TskData.EncodingType.NONE.getType();\r\n            ResultSetMetaData rsMetaData = inputResultSet.getMetaData();\r\n            if (rsMetaData.getColumnCount() == 3) {\r\n                encoding = inputResultSet.getInt(3);\r\n            }\r\n            // NON-NLS\r\n            outputStatement.executeUpdate(\"INSERT INTO tsk_files_path (obj_id, path, encoding_type) VALUES (\" + value + \", '\" + SleuthkitCase.escapeSingleQuotes(inputResultSet.getString(2)) + \"', \" + encoding + \")\");\r\n        } catch (SQLException ex) {\r\n            if (ex.getErrorCode() != 0) {\r\n                throw new SQLException(ex);\r\n            }\r\n        }\r\n    }\r\n    numberingPK = postgreSQLConnection.createStatement();\r\n    numberingPK.execute(\"ALTER SEQUENCE tsk_files_path_obj_id_seq RESTART WITH \" + (biggestPK + 1));\r\n    biggestPK = 0;\r\n    inputStatement = sqliteConnection.createStatement();\r\n    inputResultSet = inputStatement.executeQuery(\"SELECT * FROM tsk_files\");\r\n    while (inputResultSet.next()) {\r\n        try {\r\n            long value = inputResultSet.getLong(1);\r\n            if (value > biggestPK) {\r\n                biggestPK = value;\r\n            }\r\n            // NON-NLS\r\n            String sql = \"INSERT INTO tsk_files (obj_id, fs_obj_id, attr_type, attr_id, name, meta_addr, meta_seq, type, has_layout, has_path, dir_type, meta_type, dir_flags, meta_flags, size, ctime, crtime, atime, mtime, mode, uid, gid, md5, known, parent_path) VALUES (\" + value + \",\" + getNullableLong(inputResultSet, 2) + \",\" + getNullableInt(inputResultSet, 3) + \",\" + getNullableInt(inputResultSet, 4) + \",'\" + SleuthkitCase.escapeSingleQuotes(inputResultSet.getString(5)) + \"',\" + getNullableLong(inputResultSet, 6) + \",\" + getNullableLong(inputResultSet, 7) + \",\" + getNullableInt(inputResultSet, 8) + \",\" + getNullableInt(inputResultSet, 9) + \",\" + getNullableInt(inputResultSet, 10) + \",\" + getNullableInt(inputResultSet, 11) + \",\" + getNullableInt(inputResultSet, 12) + \",\" + getNullableInt(inputResultSet, 13) + \",\" + getNullableInt(inputResultSet, 14) + \",\" + getNullableLong(inputResultSet, 15) + \",\" + getNullableLong(inputResultSet, 16) + \",\" + getNullableLong(inputResultSet, 17) + \",\" + getNullableLong(inputResultSet, 18) + \",\" + getNullableLong(inputResultSet, 19) + \",\" + getNullableInt(inputResultSet, 20) + \",\" + getNullableInt(inputResultSet, 21) + \",\" + getNullableInt(inputResultSet, 22) + \",\" + \" ? ,\" + getNullableInt(inputResultSet, 24) + \",\" + \" ? )\";\r\n            PreparedStatement pst = postgreSQLConnection.prepareStatement(sql);\r\n            populateNullableString(pst, inputResultSet, 23, 1);\r\n            populateNullableString(pst, inputResultSet, 25, 2);\r\n            pst.executeUpdate();\r\n        } catch (SQLException ex) {\r\n            if (ex.getErrorCode() != 0) {\r\n                throw new SQLException(ex);\r\n            }\r\n        }\r\n    }\r\n    numberingPK = postgreSQLConnection.createStatement();\r\n    numberingPK.execute(\"ALTER SEQUENCE tsk_files_obj_id_seq RESTART WITH \" + (biggestPK + 1));\r\n    inputStatement = sqliteConnection.createStatement();\r\n    inputResultSet = inputStatement.executeQuery(\"SELECT * FROM tsk_file_layout\");\r\n    while (inputResultSet.next()) {\r\n        outputStatement = postgreSQLConnection.createStatement();\r\n        try {\r\n            // NON-NLS\r\n            outputStatement.executeUpdate(\"INSERT INTO tsk_file_layout (obj_id, byte_start, byte_len, sequence) VALUES (\" + inputResultSet.getLong(1) + \",\" + inputResultSet.getLong(2) + \",\" + inputResultSet.getLong(3) + \",\" + inputResultSet.getInt(4) + \")\");\r\n        } catch (SQLException ex) {\r\n            if (ex.getErrorCode() != 0) {\r\n                throw new SQLException(ex);\r\n            }\r\n        }\r\n    }\r\n    inputStatement = sqliteConnection.createStatement();\r\n    inputResultSet = inputStatement.executeQuery(\"SELECT * FROM tsk_db_info\");\r\n    while (inputResultSet.next()) {\r\n        outputStatement = postgreSQLConnection.createStatement();\r\n        try {\r\n            Statement check = postgreSQLConnection.createStatement();\r\n            ResultSet checkResult = check.executeQuery(\"SELECT * FROM tsk_db_info WHERE schema_ver=\" + inputResultSet.getInt(1) + \" AND tsk_ver=\" + inputResultSet.getInt(2));\r\n            if (!checkResult.isBeforeFirst()) {\r\n                // NON-NLS\r\n                outputStatement.executeUpdate(\"INSERT INTO tsk_db_info (schema_ver, tsk_ver) VALUES (\" + getNullableInt(inputResultSet, 1) + \",\" + getNullableInt(inputResultSet, 2) + \")\");\r\n            }\r\n        } catch (SQLException ex) {\r\n            if (ex.getErrorCode() != 0) {\r\n                throw new SQLException(ex);\r\n            }\r\n        }\r\n    }\r\n    biggestPK = 0;\r\n    inputStatement = sqliteConnection.createStatement();\r\n    inputResultSet = inputStatement.executeQuery(\"SELECT * FROM tag_names\");\r\n    while (inputResultSet.next()) {\r\n        try {\r\n            long value = inputResultSet.getLong(1);\r\n            if (value > biggestPK) {\r\n                biggestPK = value;\r\n            }\r\n            // NON-NLS\r\n            String sql = \"INSERT INTO tag_names (tag_name_id, display_name, description, color) VALUES (\" + value + \",\" + \" ? ,'\" + SleuthkitCase.escapeSingleQuotes(inputResultSet.getString(3)) + \"','\" + SleuthkitCase.escapeSingleQuotes(inputResultSet.getString(4)) + \"')\";\r\n            PreparedStatement pst = postgreSQLConnection.prepareStatement(sql);\r\n            populateNullableString(pst, inputResultSet, 2, 1);\r\n            pst.executeUpdate();\r\n        } catch (SQLException ex) {\r\n            if (ex.getErrorCode() != 0) {\r\n                throw new SQLException(ex);\r\n            }\r\n        }\r\n    }\r\n    numberingPK = postgreSQLConnection.createStatement();\r\n    numberingPK.execute(\"ALTER SEQUENCE tag_names_tag_name_id_seq RESTART WITH \" + (biggestPK + 1));\r\n    biggestPK = 0;\r\n    inputStatement = sqliteConnection.createStatement();\r\n    inputResultSet = inputStatement.executeQuery(\"SELECT * FROM reports\");\r\n    while (inputResultSet.next()) {\r\n        outputStatement = postgreSQLConnection.createStatement();\r\n        try {\r\n            long value = inputResultSet.getLong(1);\r\n            if (value > biggestPK) {\r\n                biggestPK = value;\r\n            }\r\n            // NON-NLS\r\n            outputStatement.executeUpdate(\"INSERT INTO reports (report_id, path, crtime, src_module_name, report_name) VALUES (\" + value + \", '\" + SleuthkitCase.escapeSingleQuotes(inputResultSet.getString(2)) + \"',\" + inputResultSet.getInt(3) + \",'\" + SleuthkitCase.escapeSingleQuotes(inputResultSet.getString(4)) + \"','\" + SleuthkitCase.escapeSingleQuotes(inputResultSet.getString(5)) + \"')\");\r\n        } catch (SQLException ex) {\r\n            if (ex.getErrorCode() != 0) {\r\n                throw new SQLException(ex);\r\n            }\r\n        }\r\n    }\r\n    numberingPK = postgreSQLConnection.createStatement();\r\n    numberingPK.execute(\"ALTER SEQUENCE reports_report_id_seq RESTART WITH \" + (biggestPK + 1));\r\n    biggestPK = Long.MIN_VALUE;\r\n    inputStatement = sqliteConnection.createStatement();\r\n    inputResultSet = inputStatement.executeQuery(\"SELECT * FROM blackboard_artifacts\");\r\n    while (inputResultSet.next()) {\r\n        outputStatement = postgreSQLConnection.createStatement();\r\n        try {\r\n            long value = inputResultSet.getLong(1);\r\n            if (value > biggestPK) {\r\n                biggestPK = value;\r\n            }\r\n            // NON-NLS\r\n            outputStatement.executeUpdate(\"INSERT INTO blackboard_artifacts (artifact_id, obj_id, artifact_type_id) VALUES (\" + value + \",\" + inputResultSet.getLong(2) + \",\" + inputResultSet.getLong(3) + \")\");\r\n        } catch (SQLException ex) {\r\n            if (ex.getErrorCode() != 0) {\r\n                throw new SQLException(ex);\r\n            }\r\n        }\r\n    }\r\n    numberingPK = postgreSQLConnection.createStatement();\r\n    numberingPK.execute(\"ALTER SEQUENCE blackboard_artifacts_artifact_id_seq RESTART WITH \" + (biggestPK + 1));\r\n    inputStatement = sqliteConnection.createStatement();\r\n    inputResultSet = inputStatement.executeQuery(\"SELECT * FROM blackboard_attributes\");\r\n    while (inputResultSet.next()) {\r\n        try {\r\n            // NON-NLS\r\n            String sql = \"INSERT INTO blackboard_attributes (artifact_id, artifact_type_id, source, context, attribute_type_id, value_type, value_byte, value_text, value_int32, value_int64, value_double) VALUES (\" + inputResultSet.getLong(1) + \",\" + inputResultSet.getLong(2) + \",\" + \" ? ,\" + \" ? ,\" + inputResultSet.getLong(5) + \",\" + inputResultSet.getInt(6) + \",\" + \" ? ,\" + \" ? ,\" + getNullableInt(inputResultSet, 9) + \",\" + getNullableLong(inputResultSet, 10) + \",\" + \" ? )\";\r\n            PreparedStatement pst = postgreSQLConnection.prepareStatement(sql);\r\n            populateNullableString(pst, inputResultSet, 3, 1);\r\n            populateNullableString(pst, inputResultSet, 4, 2);\r\n            populateNullableByteArray(pst, inputResultSet, 7, 3);\r\n            populateNullableString(pst, inputResultSet, 8, 4);\r\n            populateNullableNumeric(pst, inputResultSet, 11, 5);\r\n            pst.executeUpdate();\r\n        } catch (SQLException ex) {\r\n            if (ex.getErrorCode() != 0) {\r\n                throw new SQLException(ex);\r\n            }\r\n        }\r\n    }\r\n    biggestPK = 0;\r\n    inputStatement = sqliteConnection.createStatement();\r\n    inputResultSet = inputStatement.executeQuery(\"SELECT * FROM tsk_vs_parts\");\r\n    while (inputResultSet.next()) {\r\n        try {\r\n            long value = inputResultSet.getLong(1);\r\n            if (value > biggestPK) {\r\n                biggestPK = value;\r\n            }\r\n            // NON-NLS\r\n            String sql = \"INSERT INTO tsk_vs_parts (obj_id, addr, start, length, descr, flags) VALUES (\" + value + \",\" + inputResultSet.getLong(2) + \",\" + inputResultSet.getLong(3) + \",\" + inputResultSet.getLong(4) + \",\" + \" ? ,\" + inputResultSet.getInt(6) + \")\";\r\n            PreparedStatement pst = postgreSQLConnection.prepareStatement(sql);\r\n            populateNullableString(pst, inputResultSet, 5, 1);\r\n            pst.executeUpdate();\r\n        } catch (SQLException ex) {\r\n            if (ex.getErrorCode() != 0) {\r\n                throw new SQLException(ex);\r\n            }\r\n        }\r\n    }\r\n    numberingPK = postgreSQLConnection.createStatement();\r\n    numberingPK.execute(\"ALTER SEQUENCE tsk_vs_parts_obj_id_seq RESTART WITH \" + (biggestPK + 1));\r\n    biggestPK = 0;\r\n    inputStatement = sqliteConnection.createStatement();\r\n    inputResultSet = inputStatement.executeQuery(\"SELECT * FROM tsk_vs_info\");\r\n    while (inputResultSet.next()) {\r\n        outputStatement = postgreSQLConnection.createStatement();\r\n        try {\r\n            long value = inputResultSet.getLong(1);\r\n            if (value > biggestPK) {\r\n                biggestPK = value;\r\n            }\r\n            // NON-NLS\r\n            outputStatement.executeUpdate(\"INSERT INTO tsk_vs_info (obj_id, vs_type, img_offset, block_size) VALUES (\" + value + \",\" + inputResultSet.getInt(2) + \",\" + inputResultSet.getLong(3) + \",\" + inputResultSet.getLong(4) + \")\");\r\n        } catch (SQLException ex) {\r\n            if (ex.getErrorCode() != 0) {\r\n                throw new SQLException(ex);\r\n            }\r\n        }\r\n    }\r\n    numberingPK = postgreSQLConnection.createStatement();\r\n    numberingPK.execute(\"ALTER SEQUENCE tsk_vs_info_obj_id_seq RESTART WITH \" + (biggestPK + 1));\r\n    biggestPK = 0;\r\n    inputStatement = sqliteConnection.createStatement();\r\n    inputResultSet = inputStatement.executeQuery(\"SELECT * FROM tsk_files_derived\");\r\n    while (inputResultSet.next()) {\r\n        try {\r\n            long value = inputResultSet.getLong(1);\r\n            if (value > biggestPK) {\r\n                biggestPK = value;\r\n            }\r\n            // NON-NLS\r\n            String sql = \"INSERT INTO tsk_files_derived (obj_id, derived_id, rederive) VALUES (\" + value + \",\" + inputResultSet.getLong(2) + \",\" + \" ? )\";\r\n            PreparedStatement pst = postgreSQLConnection.prepareStatement(sql);\r\n            populateNullableString(pst, inputResultSet, 3, 1);\r\n            pst.executeUpdate();\r\n        } catch (SQLException ex) {\r\n            if (ex.getErrorCode() != 0) {\r\n                throw new SQLException(ex);\r\n            }\r\n        }\r\n    }\r\n    numberingPK = postgreSQLConnection.createStatement();\r\n    numberingPK.execute(\"ALTER SEQUENCE tsk_files_derived_obj_id_seq RESTART WITH \" + (biggestPK + 1));\r\n    biggestPK = 0;\r\n    inputStatement = sqliteConnection.createStatement();\r\n    inputResultSet = inputStatement.executeQuery(\"SELECT * FROM tsk_files_derived_method\");\r\n    while (inputResultSet.next()) {\r\n        try {\r\n            long value = inputResultSet.getLong(1);\r\n            if (value > biggestPK) {\r\n                biggestPK = value;\r\n            }\r\n            // NON-NLS\r\n            String sql = \"INSERT INTO tsk_files_derived_method (derived_id, tool_name, tool_version, other) VALUES (\" + value + \", '\" + inputResultSet.getString(2) + \"','\" + inputResultSet.getString(3) + \"',\" + \" ? )\";\r\n            PreparedStatement pst = postgreSQLConnection.prepareStatement(sql);\r\n            populateNullableString(pst, inputResultSet, 4, 1);\r\n            pst.executeUpdate();\r\n        } catch (SQLException ex) {\r\n            if (ex.getErrorCode() != 0) {\r\n                throw new SQLException(ex);\r\n            }\r\n        }\r\n    }\r\n    numberingPK = postgreSQLConnection.createStatement();\r\n    numberingPK.execute(\"ALTER SEQUENCE tsk_files_derived_method_derived_id_seq RESTART WITH \" + (biggestPK + 1));\r\n    biggestPK = 0;\r\n    inputStatement = sqliteConnection.createStatement();\r\n    inputResultSet = inputStatement.executeQuery(\"SELECT * FROM content_tags LEFT OUTER JOIN tsk_examiners ON content_tags.examiner_id = tsk_examiners.examiner_id\");\r\n    while (inputResultSet.next()) {\r\n        outputStatement = postgreSQLConnection.createStatement();\r\n        try {\r\n            long value = inputResultSet.getLong(1);\r\n            if (value > biggestPK) {\r\n                biggestPK = value;\r\n            }\r\n            // NON-NLS\r\n            outputStatement.executeUpdate(\"INSERT INTO content_tags (tag_id, obj_id, tag_name_id, comment, begin_byte_offset, end_byte_offset, examiner_id) VALUES (\" + value + \",\" + inputResultSet.getLong(2) + \",\" + inputResultSet.getLong(3) + \",'\" + inputResultSet.getString(4) + \"',\" + inputResultSet.getLong(5) + \",\" + inputResultSet.getLong(6) + \",\" + inputResultSet.getInt(7) + \")\");\r\n        } catch (SQLException ex) {\r\n            if (ex.getErrorCode() != 0) {\r\n                throw new SQLException(ex);\r\n            }\r\n        }\r\n    }\r\n    numberingPK = postgreSQLConnection.createStatement();\r\n    numberingPK.execute(\"ALTER SEQUENCE content_tags_tag_id_seq RESTART WITH \" + (biggestPK + 1));\r\n    biggestPK = 0;\r\n    inputStatement = sqliteConnection.createStatement();\r\n    inputResultSet = inputStatement.executeQuery(\"SELECT * FROM blackboard_artifact_tags\");\r\n    while (inputResultSet.next()) {\r\n        outputStatement = postgreSQLConnection.createStatement();\r\n        try {\r\n            long value = inputResultSet.getLong(1);\r\n            if (value > biggestPK) {\r\n                biggestPK = value;\r\n            }\r\n            // NON-NLS\r\n            outputStatement.executeUpdate(\"INSERT INTO blackboard_artifact_tags (tag_id, artifact_id, tag_name_id, comment) VALUES (\" + value + \",\" + inputResultSet.getLong(2) + \",\" + inputResultSet.getLong(3) + \",'\" + inputResultSet.getString(4) + \"','\" + inputResultSet.getString(5) + \"')\");\r\n        } catch (SQLException ex) {\r\n            if (ex.getErrorCode() != 0) {\r\n                throw new SQLException(ex);\r\n            }\r\n        }\r\n    }\r\n    numberingPK = postgreSQLConnection.createStatement();\r\n    numberingPK.execute(\"ALTER SEQUENCE blackboard_artifact_tags_tag_id_seq RESTART WITH \" + (biggestPK + 1));\r\n    sqliteConnection.close();\r\n    postgreSQLConnection.close();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJobsNode.refresh",
	"Comment": "refresh the contents of the autoingestjobsnode and all of its children.",
	"Method": "void refresh(AutoIngestNodeRefreshEvents.AutoIngestRefreshEvent refreshEvent){\r\n    refreshChildrenEventBus.post(refreshEvent);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.ReportHTML.writeSummaryImageInfo",
	"Comment": "write the image information section of the summary for this report.",
	"Method": "StringBuilder writeSummaryImageInfo(){\r\n    StringBuilder summary = new StringBuilder();\r\n    summary.append(NbBundle.getMessage(this.getClass(), \"ReportHTML.writeSum.imageInfoHeading\"));\r\n    summary.append(\"<div class=\\\"info\\\">\\n\");\r\n    try {\r\n        for (Content c : currentCase.getDataSources()) {\r\n            summary.append(\"<p>\").append(c.getName()).append(\"<\/p>\\n\");\r\n            if (c instanceof Image) {\r\n                Image img = (Image) c;\r\n                summary.append(\"<table>\\n\");\r\n                // NON-NLS\r\n                summary.append(\"<tr><td>\").append(NbBundle.getMessage(this.getClass(), \"ReportHTML.writeSum.timezone\")).append(\"<\/td><td>\").append(img.getTimeZone()).append(\"<\/td><\/tr>\\n\");\r\n                for (String imgPath : img.getPaths()) {\r\n                    // NON-NLS\r\n                    summary.append(\"<tr><td>\").append(NbBundle.getMessage(this.getClass(), \"ReportHTML.writeSum.path\")).append(\"<\/td><td>\").append(imgPath).append(\"<\/td><\/tr>\\n\");\r\n                }\r\n                summary.append(\"<\/table>\\n\");\r\n            }\r\n        }\r\n    } catch (TskCoreException ex) {\r\n        logger.log(Level.WARNING, \"Unable to get image information for the HTML report.\");\r\n    }\r\n    summary.append(\"<\/div>\\n\");\r\n    return summary;\r\n}"
}, {
	"Path": "org.wikipedia.page.leadimages.LeadImagesHandler.initDisplayDimensions",
	"Comment": "determines and sets displayheightdp for the lead images layout.",
	"Method": "void initDisplayDimensions(){\r\n    displayHeightDp = (int) (DimenUtil.getDisplayHeightPx() / DimenUtil.getDensityScalar());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.DataResultPanel.getPreferredID",
	"Comment": "gets the preferred identifier for this result view panel in the windowsystem.",
	"Method": "String getPreferredID(){\r\n    return getName();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilessearch.InterCaseTestUtils.tearDown",
	"Comment": "close the currently open case, delete the case directory, delete thecentral repo db.",
	"Method": "void tearDown(){\r\n    CaseUtils.closeCurrentCase(false);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.ModuleDataEvent.getBlackboardArtifactType",
	"Comment": "gets the blackboard artifact type of the new artifacts associated withthe event",
	"Method": "BlackboardArtifact.Type getBlackboardArtifactType(){\r\n    return this.blackboardArtifactType;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.GlobalEditListPanel.setButtonStates",
	"Comment": "enables and disables buttons on this panel based on the current state.",
	"Method": "void setButtonStates(){\r\n    boolean isIngestRunning = IngestManager.getInstance().isIngestRunning();\r\n    boolean isListSelected = currentKeywordList != null;\r\n    ingestWarningLabel.setVisible(isIngestRunning);\r\n    boolean canEditList = isListSelected && !isIngestRunning;\r\n    ingestMessagesCheckbox.setEnabled(canEditList);\r\n    ingestMessagesCheckbox.setSelected(currentKeywordList != null && currentKeywordList.getIngestMessages());\r\n    boolean canAddWord = canEditList && !currentKeywordList.isEditable();\r\n    newKeywordsButton.setEnabled(canAddWord);\r\n    if ((currentKeywordList == null) || (currentKeywordList.getKeywords().isEmpty())) {\r\n        deleteWordButton.setEnabled(false);\r\n        editWordButton.setEnabled(false);\r\n    }\r\n}"
}, {
	"Path": "net.ypresto.androidtranscoder.engine.InputSurface.setPresentationTime",
	"Comment": "sends the presentation time stamp to egl.time is expressed in nanoseconds.",
	"Method": "void setPresentationTime(long nsecs){\r\n    EGLExt.eglPresentationTimeANDROID(mEGLDisplay, mEGLSurface, nsecs);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.TableFilterNode.setChildNodeSelectionInfo",
	"Comment": "adds information about which child node of this node, if any, should beselected. can be null.",
	"Method": "void setChildNodeSelectionInfo(NodeSelectionInfo selectedChildNodeInfo){\r\n    if (getOriginal() instanceof DataResultFilterNode) {\r\n        ((DataResultFilterNode) getOriginal()).setChildNodeSelectionInfo(selectedChildNodeInfo);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.interestingitems.FilesSetRulePanel.setComponentsForSearchType",
	"Comment": "sets the state of the name condition ui components consistent with thestate of the ui components in the type button group.",
	"Method": "void setComponentsForSearchType(){\r\n    if (!this.filesRadioButton.isSelected()) {\r\n        this.fullNameRadioButton.setSelected(true);\r\n        this.extensionRadioButton.setEnabled(false);\r\n        this.mimeTypeComboBox.setEnabled(false);\r\n        this.mimeTypeComboBox.setSelectedIndex(0);\r\n        this.equalitySymbolComboBox.setEnabled(false);\r\n        this.fileSizeComboBox.setEnabled(false);\r\n        this.fileSizeSpinner.setEnabled(false);\r\n        this.fileSizeSpinner.setValue(0);\r\n        this.fileSizeCheck.setEnabled(false);\r\n        this.fileSizeCheck.setSelected(false);\r\n        this.mimeCheck.setEnabled(false);\r\n        this.mimeCheck.setSelected(false);\r\n    } else {\r\n        if (this.nameCheck.isSelected()) {\r\n            this.extensionRadioButton.setEnabled(true);\r\n        }\r\n        this.fileSizeCheck.setEnabled(true);\r\n        this.mimeCheck.setEnabled(true);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.AdHocSearchDelegator.execute",
	"Comment": "execute the keyword search based on keywords passed into constructor.post results into a new dataresultviewer.",
	"Method": "void execute(boolean saveResults){\r\n    Collection<AdHocQueryRequest> queryRequests = new ArrayList();\r\n    int queryID = 0;\r\n    StringBuilder queryConcat = new StringBuilder();\r\n    for (KeywordSearchQuery q : queryDelegates) {\r\n        Map<String, Object> kvs = new LinkedHashMap();\r\n        final String queryStr = q.getQueryString();\r\n        queryConcat.append(queryStr).append(\" \");\r\n        queryRequests.add(new AdHocQueryRequest(kvs, ++queryID, q));\r\n    }\r\n    String queryConcatStr = queryConcat.toString();\r\n    final int queryConcatStrLen = queryConcatStr.length();\r\n    final String queryStrShort = queryConcatStrLen > 15 ? queryConcatStr.substring(0, 14) + \"...\" : queryConcatStr;\r\n    final String windowTitle = NbBundle.getMessage(this.getClass(), \"KeywordSearchQueryManager.execute.exeWinTitle\", ++resultWindowCount, queryStrShort);\r\n    DataResultTopComponent searchResultWin = DataResultTopComponent.createInstance(windowTitle);\r\n    Node rootNode;\r\n    if (queryRequests.size() > 0) {\r\n        Children childNodes = Children.create(new AdHocSearchChildFactory(queryRequests, saveResults), true);\r\n        rootNode = new AbstractNode(childNodes);\r\n    } else {\r\n        rootNode = Node.EMPTY;\r\n    }\r\n    final String pathText = NbBundle.getMessage(this.getClass(), \"KeywordSearchQueryManager.pathText.text\");\r\n    DataResultTopComponent.initInstance(pathText, new TableFilterNode(rootNode, true, KeywordSearch.class.getName()), queryRequests.size(), searchResultWin);\r\n    searchResultWin.requestActive();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.interestingitems.FilesSetPanel.isValidDefinition",
	"Comment": "returns whether or not the data entered in the panel constitutes a validinteresting files set definition, displaying a dialog explaining thedeficiency if the definition is invalid",
	"Method": "boolean isValidDefinition(){\r\n    if (this.nameTextField.getText().isEmpty()) {\r\n        NotifyDescriptor notifyDesc = new NotifyDescriptor.Message(mustBeNamedErrorText, NotifyDescriptor.WARNING_MESSAGE);\r\n        DialogDisplayer.getDefault().notify(notifyDesc);\r\n        return false;\r\n    } else {\r\n        for (FilesSet filesSet : FilesSetsManager.getStandardFileIngestFilters()) {\r\n            if (this.nameTextField.getText().equals(filesSet.getName())) {\r\n                NotifyDescriptor notifyDesc = new NotifyDescriptor.Message(NbBundle.getMessage(FilesSetPanel.class, \"FilesSetPanel.messages.filesSetsReservedName\"), NotifyDescriptor.WARNING_MESSAGE);\r\n                DialogDisplayer.getDefault().notify(notifyDesc);\r\n                return false;\r\n            }\r\n        }\r\n        if (this.nameTextField.getText().equals(getCreateNewFileIngestFilterString())) {\r\n            NotifyDescriptor notifyDesc = new NotifyDescriptor.Message(NbBundle.getMessage(FilesSetPanel.class, \"FilesSetPanel.messages.filesSetsReservedName\"), NotifyDescriptor.WARNING_MESSAGE);\r\n            DialogDisplayer.getDefault().notify(notifyDesc);\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.ui.detailview.EventNodeBase.installTooltip",
	"Comment": "defer tooltip content creation till needed, this had a surprisingly largeimpact on speed of loading the chart",
	"Method": "void installTooltip(){\r\n    if (tooltip.getText().equalsIgnoreCase(Bundle.EventBundleNodeBase_toolTip_loading())) {\r\n        final Task<String> tooltTipTask = new Task<String>() {\r\n            {\r\n                updateTitle(Bundle.EventNodeBase_toolTip_loading2());\r\n            }\r\n            @Override\r\n            protected String call() throws Exception {\r\n                HashMap<String, Long> hashSetCounts = new HashMap();\r\n                if (tlEvent.getEventIDsWithHashHits().isEmpty() == false) {\r\n                    try {\r\n                        for (SingleEvent tle : eventsModel.getEventsById(tlEvent.getEventIDsWithHashHits())) {\r\n                            Set<String> hashSetNames = sleuthkitCase.getAbstractFileById(tle.getFileID()).getHashSetNames();\r\n                            for (String hashSetName : hashSetNames) {\r\n                                hashSetCounts.merge(hashSetName, 1L, Long::sum);\r\n                            }\r\n                        }\r\n                    } catch (TskCoreException ex) {\r\n                        LOGGER.log(Level.SEVERE, \"Error getting hashset hit info for event.\", ex);\r\n                    }\r\n                }\r\n                String hashSetCountsString = hashSetCounts.entrySet().stream().map((Map.Entry<String, Long> t) -> t.getKey() + \" : \" + t.getValue()).collect(Collectors.joining(\"\\n\"));\r\n                Map<String, Long> tagCounts = new HashMap();\r\n                if (tlEvent.getEventIDsWithTags().isEmpty() == false) {\r\n                    tagCounts.putAll(eventsModel.getTagCountsByTagName(tlEvent.getEventIDsWithTags()));\r\n                }\r\n                String tagCountsString = tagCounts.entrySet().stream().map((Map.Entry<String, Long> t) -> t.getKey() + \" : \" + t.getValue()).collect(Collectors.joining(\"\\n\"));\r\n                return Bundle.EventNodeBase_tooltip_text(getEventIDs().size(), getEventType(), getDescription(), TimeLineController.getZonedFormatter().print(getStartMillis()), TimeLineController.getZonedFormatter().print(getEndMillis() + 1000)) + (hashSetCountsString.isEmpty() ? \"\" : Bundle.EventNodeBase_toolTip_hashSetHits(hashSetCountsString)) + (tagCountsString.isEmpty() ? \"\" : Bundle.EventNodeBase_toolTip_tags(tagCountsString));\r\n            }\r\n            @Override\r\n            protected void succeeded() {\r\n                super.succeeded();\r\n                try {\r\n                    tooltip.setText(get());\r\n                    tooltip.setGraphic(null);\r\n                } catch (InterruptedException | ExecutionException ex) {\r\n                    LOGGER.log(Level.SEVERE, \"Tooltip generation failed.\", ex);\r\n                }\r\n            }\r\n        };\r\n        new Thread(tooltTipTask).start();\r\n        chartLane.getController().monitorTask(tooltTipTask);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.ui.detailview.EventNodeBase.installTooltip",
	"Comment": "defer tooltip content creation till needed, this had a surprisingly largeimpact on speed of loading the chart",
	"Method": "void installTooltip(){\r\n    HashMap<String, Long> hashSetCounts = new HashMap();\r\n    if (tlEvent.getEventIDsWithHashHits().isEmpty() == false) {\r\n        try {\r\n            for (SingleEvent tle : eventsModel.getEventsById(tlEvent.getEventIDsWithHashHits())) {\r\n                Set<String> hashSetNames = sleuthkitCase.getAbstractFileById(tle.getFileID()).getHashSetNames();\r\n                for (String hashSetName : hashSetNames) {\r\n                    hashSetCounts.merge(hashSetName, 1L, Long::sum);\r\n                }\r\n            }\r\n        } catch (TskCoreException ex) {\r\n            LOGGER.log(Level.SEVERE, \"Error getting hashset hit info for event.\", ex);\r\n        }\r\n    }\r\n    String hashSetCountsString = hashSetCounts.entrySet().stream().map((Map.Entry<String, Long> t) -> t.getKey() + \" : \" + t.getValue()).collect(Collectors.joining(\"\\n\"));\r\n    Map<String, Long> tagCounts = new HashMap();\r\n    if (tlEvent.getEventIDsWithTags().isEmpty() == false) {\r\n        tagCounts.putAll(eventsModel.getTagCountsByTagName(tlEvent.getEventIDsWithTags()));\r\n    }\r\n    String tagCountsString = tagCounts.entrySet().stream().map((Map.Entry<String, Long> t) -> t.getKey() + \" : \" + t.getValue()).collect(Collectors.joining(\"\\n\"));\r\n    return Bundle.EventNodeBase_tooltip_text(getEventIDs().size(), getEventType(), getDescription(), TimeLineController.getZonedFormatter().print(getStartMillis()), TimeLineController.getZonedFormatter().print(getEndMillis() + 1000)) + (hashSetCountsString.isEmpty() ? \"\" : Bundle.EventNodeBase_toolTip_hashSetHits(hashSetCountsString)) + (tagCountsString.isEmpty() ? \"\" : Bundle.EventNodeBase_toolTip_tags(tagCountsString));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.ui.detailview.EventNodeBase.installTooltip",
	"Comment": "defer tooltip content creation till needed, this had a surprisingly largeimpact on speed of loading the chart",
	"Method": "void installTooltip(){\r\n    super.succeeded();\r\n    try {\r\n        tooltip.setText(get());\r\n        tooltip.setGraphic(null);\r\n    } catch (InterruptedException | ExecutionException ex) {\r\n        LOGGER.log(Level.SEVERE, \"Tooltip generation failed.\", ex);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.events.AddingDataSourceFailedEvent.getDataSourceId",
	"Comment": "gets the unique id used to pair this addingdatasourcefailedevent with thecorresponding addingdatasourceevent.",
	"Method": "UUID getDataSourceId(){\r\n    return dataSourceId;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.SqliteEamDbSettings.getAddValueIndexTemplate",
	"Comment": "get the template for creating an index on the value column of an instancetable. %s will exist in the template where the name of the new table willbe addedd.",
	"Method": "String getAddValueIndexTemplate(){\r\n    return \"CREATE INDEX IF NOT EXISTS %s_value ON %s (value)\";\r\n}"
}, {
	"Path": "com.anysoftkeyboard.dictionaries.WordComposer.correctPrimaryJuxtapos",
	"Comment": "swaps the first and second values in the codes array if the primary code is not the firstvalue in the array but the second. this happens when the preferred key is not the key thatthe user released the finger on.",
	"Method": "void correctPrimaryJuxtapos(int primaryCode,int[] nearByKeyCodes){\r\n    if (nearByKeyCodes != null && nearByKeyCodes.length > 1 && primaryCode != nearByKeyCodes[0] && primaryCode != Character.toLowerCase((char) nearByKeyCodes[0])) {\r\n        int swappedItem = nearByKeyCodes[0];\r\n        nearByKeyCodes[0] = primaryCode;\r\n        boolean found = false;\r\n        for (int i = 1; i < nearByKeyCodes.length; i++) {\r\n            if (nearByKeyCodes[i] == primaryCode) {\r\n                nearByKeyCodes[i] = swappedItem;\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!found)\r\n            nearByKeyCodes[0] = swappedItem;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.CommonAttributePanel.isEamDbAvailableForIntercaseSearch",
	"Comment": "get whether or not the central repository will be enabled as a searchoption.",
	"Method": "boolean isEamDbAvailableForIntercaseSearch(){\r\n    try {\r\n        return EamDb.isEnabled() && EamDb.getInstance() != null && EamDb.getInstance().getCases().size() > 1 && Case.isCaseOpen() && Case.getCurrentCase() != null && EamDb.getInstance().getCase(Case.getCurrentCase()) != null;\r\n    } catch (EamDbException ex) {\r\n        LOGGER.log(Level.SEVERE, \"Unexpected exception while  checking for EamDB enabled.\", ex);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.LocalFilesPanel.validatePanel",
	"Comment": "validates path to selected data source and displays warning if it isinvalid.",
	"Method": "boolean validatePanel(){\r\n    warnIfPathIsInvalid(getContentPaths());\r\n    return enableNext;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.directorytree.ExtractAction.updateExportDirectory",
	"Comment": "update the default export directory. if the directory path matches thecase export directory, then the directory used will always match theexport directory of any given case. otherwise, the path last used will besaved.",
	"Method": "void updateExportDirectory(String exportPath,Case openCase){\r\n    if (exportPath.equalsIgnoreCase(openCase.getExportDirectory())) {\r\n        userDefinedExportPath = null;\r\n    } else {\r\n        userDefinedExportPath = exportPath;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.core.UserPreferences.setMaximumNumberOfResults",
	"Comment": "set the maximum number of result rows to show in data result tables.",
	"Method": "void setMaximumNumberOfResults(int max){\r\n    preferences.putInt(MAXIMUM_NUMBER_OF_RESULTS, max);\r\n}"
}, {
	"Path": "com.klinker.android.peekview.PeekView.setHeightByPercent",
	"Comment": "sets the height of the window according to the screen height.",
	"Method": "void setHeightByPercent(float percent){\r\n    setHeight((int) (screenHeight * percent));\r\n}"
}, {
	"Path": "com.anysoftkeyboard.dictionaries.WordComposer.isMostlyCaps",
	"Comment": "returns true if more than one character is upper case, otherwise returns false.",
	"Method": "boolean isMostlyCaps(){\r\n    return mCapsCount > 1;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.configuration.AutoIngestUserPreferences.getAutoModeIngestModuleContextString",
	"Comment": "get context string for automated mode ingest module settings.",
	"Method": "String getAutoModeIngestModuleContextString(){\r\n    return AUTO_MODE_CONTEXT_STRING;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.Case.getModulesOutputDirAbsPath",
	"Comment": "get module output directory path where modules should save theirpermanent data.",
	"Method": "String getModulesOutputDirAbsPath(){\r\n    return getModuleDirectory();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.examples.SampleIngestModuleFactory.getDefaultIngestJobSettings",
	"Comment": "gets the default per ingest job settings for instances of the family ofingest modules the factory creates. for example, the autopsy core hashlookup ingest modules family uses hash databases imported or createdusing its global settings panel. all of the hash databases are enabled bydefault for an ingest job. if the module family does not have per ingestjob settings, the factory may extend ingestmodulefactoryadapter to get animplementation of this method that returns an instance of thenoingestmodulejobsettings class.",
	"Method": "IngestModuleIngestJobSettings getDefaultIngestJobSettings(){\r\n    return new SampleModuleIngestJobSettings();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.contentviewers.AnnotationsContentViewer.formatHtmlString",
	"Comment": "apply escape sequence to special characters. line feed and carriagereturn character combinations will be converted to html line breaks.",
	"Method": "String formatHtmlString(String text){\r\n    String formattedString = StringEscapeUtils.escapeHtml4(text);\r\n    return formattedString.replaceAll(\"(\\r\\n|\\r|\\n|\\n\\r)\", \"<br>\");\r\n}"
}, {
	"Path": "com.litesuits.http.data.TypeToken.matches",
	"Comment": "checks if two types are the same or are equivalent under a variable mappinggiven in the type map that was provided.",
	"Method": "boolean matches(Type from,Type to,Map<String, Type> typeMap){\r\n    if (to.equals(from))\r\n        return true;\r\n    if (from instanceof TypeVariable) {\r\n        return to.equals(typeMap.get(((TypeVariable<?>) from).getName()));\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.PerCaseProperties.makeConfigFile",
	"Comment": "makes a new config file of the specified name. do not include theextension.",
	"Method": "boolean makeConfigFile(String moduleName){\r\n    if (!configExists(moduleName)) {\r\n        Path propPath = getPropertyPath(moduleName);\r\n        Path parent = propPath.getParent();\r\n        Properties props = new Properties();\r\n        try {\r\n            if (!Files.exists(parent)) {\r\n                Files.createDirectories(parent);\r\n            }\r\n            Files.createFile(propPath);\r\n            try (OutputStream fos = Files.newOutputStream(propPath)) {\r\n                props.store(fos, \"\");\r\n            }\r\n        } catch (IOException e) {\r\n            Logger.getLogger(PerCaseProperties.class.getName()).log(Level.WARNING, \"Was not able to create a new properties file.\", e);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.InterCasePanel.setCaseComboboxModel",
	"Comment": "set the datamodel for the combo box which displays the cases inthe central repository",
	"Method": "void setCaseComboboxModel(DataSourceComboBoxModel dataSourceComboBoxModel){\r\n    this.casesList = dataSourceComboBoxModel;\r\n    this.caseComboBox.setModel(dataSourceComboBoxModel);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.DataResultPanel.close",
	"Comment": "closes down the component. intended to be called by the parent topcomponent when it is closed.",
	"Method": "void close(){\r\n    if (explorerManager != null && explorerManagerListener != null) {\r\n        explorerManager.removePropertyChangeListener(explorerManagerListener);\r\n        explorerManager = null;\r\n    }\r\n    this.resultViewers.forEach((viewer) -> viewer.setNode(null));\r\n    if (!this.isMain) {\r\n        this.resultViewers.forEach(DataResultViewer::clearComponent);\r\n        this.descriptionLabel.removeAll();\r\n        this.numberOfChildNodesLabel.removeAll();\r\n        this.matchLabel.removeAll();\r\n        this.setLayout(null);\r\n        this.removeAll();\r\n        this.setVisible(false);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.AddImageWizardIterator.getPropLastprofileName",
	"Comment": "gets the name of the property which stores the name of the last profileused by the add image wizard.",
	"Method": "String getPropLastprofileName(){\r\n    return PROP_LASTPROFILE_NAME;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.SingleUserCaseConverter.populateNullableString",
	"Comment": "place a null inside a prepared statement if needed, otherwise, place thestring that was in the resultset.",
	"Method": "void populateNullableString(PreparedStatement pst,ResultSet rs,int rsIndex,int psIndex){\r\n    String nullableString = rs.getString(rsIndex);\r\n    if (rs.wasNull()) {\r\n        pst.setNull(psIndex, java.sql.Types.NULL);\r\n    } else {\r\n        pst.setString(psIndex, SleuthkitCase.escapeSingleQuotes(nullableString));\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.directorytree.ExternalViewerRulesManager.setUserRules",
	"Comment": "writes a list of externalviewerrule objects to a configuration settingsfile.",
	"Method": "void setUserRules(List<ExternalViewerRule> rules){\r\n    StringBuilder setting = new StringBuilder();\r\n    for (ExternalViewerRule rule : rules) {\r\n        if (setting.length() != 0) {\r\n            setting.append(\"|\");\r\n        }\r\n        setting.append(rule.getName()).append(\">\");\r\n        setting.append(rule.getExePath()).append(\">\");\r\n        setting.append(rule.getRuleType().name());\r\n    }\r\n    ModuleSettings.setConfigSetting(RULES_SETTINGS_NAME, RULES_SETTINGS_KEY, setting.toString());\r\n    userRules = new ArrayList(rules);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.ReportWizardAction.doReportWizard",
	"Comment": "when the generate report button or menu item is selected, open thereporting wizard. when the wizard is finished, create a reportgeneratorwith the wizard information, and start all necessary reports.",
	"Method": "void doReportWizard(){\r\n    WizardDescriptor wiz = new WizardDescriptor(new ReportWizardIterator());\r\n    wiz.setTitleFormat(new MessageFormat(\"{0} {1}\"));\r\n    wiz.setTitle(NbBundle.getMessage(ReportWizardAction.class, \"ReportWizardAction.reportWiz.title\"));\r\n    if (DialogDisplayer.getDefault().notify(wiz) == WizardDescriptor.FINISH_OPTION) {\r\n        ReportGenerator generator = new ReportGenerator();\r\n        TableReportModule tableReport = (TableReportModule) wiz.getProperty(\"tableModule\");\r\n        GeneralReportModule generalReport = (GeneralReportModule) wiz.getProperty(\"generalModule\");\r\n        FileReportModule fileReport = (FileReportModule) wiz.getProperty(\"fileModule\");\r\n        try {\r\n            if (tableReport != null) {\r\n                generator.generateTableReport(tableReport, (Map<BlackboardArtifact.Type, Boolean>) wiz.getProperty(\"artifactStates\"), (Map<String, Boolean>) wiz.getProperty(\"tagStates\"));\r\n            } else if (generalReport != null) {\r\n                generator.generateGeneralReport(generalReport);\r\n            } else if (fileReport != null) {\r\n                generator.generateFileListReport(fileReport, (Map<FileReportDataTypes, Boolean>) wiz.getProperty(\"fileReportOptions\"));\r\n            }\r\n        } catch (IOException e) {\r\n            NotifyDescriptor descriptor = new NotifyDescriptor.Message(e.getMessage(), NotifyDescriptor.ERROR_MESSAGE);\r\n            DialogDisplayer.getDefault().notify(descriptor);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.AbstractCommonAttributeInstance.getAbstractFileObjectId",
	"Comment": "objectid of the abstractfile that is equivalent to the file from whichthis common attribute instance",
	"Method": "Long getAbstractFileObjectId(){\r\n    return abstractFileObjectId;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestManager.fireIngestJobStarted",
	"Comment": "publishes an ingest job event signifying an ingest job started.",
	"Method": "void fireIngestJobStarted(long ingestJobId){\r\n    AutopsyEvent event = new AutopsyEvent(IngestJobEvent.STARTED.toString(), ingestJobId, null);\r\n    eventPublishingExecutor.submit(new PublishEventTask(event, jobEventPublisher));\r\n}"
}, {
	"Path": "com.mcxiaoke.next.recycler.AdvancedRecyclerArrayAdapter.isItemTheSame",
	"Comment": "called by the diffutil to decide whether two object represent the same item.for example, if your items have unique ids, this method should check their id equality.",
	"Method": "boolean isItemTheSame(T oldItem,T newItem){\r\n    if (oldItem == null && newItem == null) {\r\n        return true;\r\n    }\r\n    if (oldItem == null || newItem == null) {\r\n        return false;\r\n    }\r\n    final Object oldId = getItemId(oldItem);\r\n    final Object newId = getItemId(newItem);\r\n    return (oldId == newId) || (oldId != null && oldId.equals(newId));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.ingestmodule.IngestSettingsPanel.customizeComponents",
	"Comment": "update components with values from the ingest job settings.",
	"Method": "void customizeComponents(IngestSettings settings){\r\n    flagTaggedNotableItemsCheckbox.setSelected(settings.isFlagTaggedNotableItems());\r\n    flagPreviouslySeenDevicesCheckbox.setSelected(settings.isFlagPreviousDevices());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.DataContentViewerHex.maybeShowPopup",
	"Comment": "show the right click menu only if evt is the correct mouse event",
	"Method": "void maybeShowPopup(java.awt.event.MouseEvent evt){\r\n    if (evt.isPopupTrigger()) {\r\n        rightClickMenu.setLocation(evt.getLocationOnScreen());\r\n        rightClickMenu.setVisible(true);\r\n        copyMenuItem.setEnabled(outputTextArea.getSelectedText() != null);\r\n    } else {\r\n        rightClickMenu.setVisible(false);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.services.TagsManager.getTagNamesInUse",
	"Comment": "gets a list of all tag names currently in use in the case database fortagging content or artifacts.",
	"Method": "List<TagName> getTagNamesInUse(List<TagName> getTagNamesInUse,long dsObjId){\r\n    return caseDb.getTagNamesInUse(dsObjId);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.DataContentViewerArtifact.getArtifactContents",
	"Comment": "retrieve the cache of artifact represented as resultstableartifacts.",
	"Method": "List<ResultsTableArtifact> getArtifactContents(){\r\n    synchronized (lock) {\r\n        return artifactTableContents;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AinStatusPanel.refresh",
	"Comment": "update the contents of this ainstatuspanel while retaining currentlyselected node.",
	"Method": "void refresh(AutoIngestMonitor monitor){\r\n    outline.setRowSelectionAllowed(false);\r\n    Node[] selectedNodes = explorerManager.getSelectedNodes();\r\n    AinStatusNode ainStatusNode = new AinStatusNode(monitor);\r\n    explorerManager.setRootContext(ainStatusNode);\r\n    outline.setRowSelectionAllowed(true);\r\n    if (selectedNodes.length > 0 && ainStatusNode.getChildren().findChild(selectedNodes[0].getName()) != null && outline.isFocusable()) {\r\n        try {\r\n            explorerManager.setSelectedNodes(new Node[] { ainStatusNode.getChildren().findChild(selectedNodes[0].getName()) });\r\n        } catch (PropertyVetoException ignore) {\r\n        }\r\n    }\r\n    outline.setFocusable(true);\r\n}"
}, {
	"Path": "org.wikipedia.util.L10nUtil.isLangRTL",
	"Comment": "returns true if the given wiki language is to be displayed rtl.",
	"Method": "boolean isLangRTL(String lang){\r\n    return Arrays.binarySearch(RTL_LANGS, lang, null) >= 0;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.Case.getConfigDirectory",
	"Comment": "gets the full path to the config directory for this case, creating it ifit does not exist.",
	"Method": "String getConfigDirectory(){\r\n    return getOrCreateSubdirectory(CONFIG_FOLDER);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.recentactivity.Extract.resultSetToArrayList",
	"Comment": "returns a list of abstractfile objects from tsk based on sql query.",
	"Method": "List<HashMap<String, Object>> resultSetToArrayList(ResultSet rs){\r\n    ResultSetMetaData md = rs.getMetaData();\r\n    int columns = md.getColumnCount();\r\n    List<HashMap<String, Object>> list = new ArrayList(50);\r\n    while (rs.next()) {\r\n        HashMap<String, Object> row = new HashMap(columns);\r\n        for (int i = 1; i <= columns; ++i) {\r\n            if (rs.getObject(i) == null) {\r\n                row.put(md.getColumnName(i), \"\");\r\n            } else {\r\n                row.put(md.getColumnName(i), rs.getObject(i));\r\n            }\r\n        }\r\n        list.add(row);\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestControlPanel.enableDeprioritizeButtons",
	"Comment": "enables or disables deprioritize buttons related to the pending jobstable.",
	"Method": "void enableDeprioritizeButtons(Boolean enable){\r\n    bnDeprioritizeCase.setEnabled(enable);\r\n    bnDeprioritizeJob.setEnabled(enable);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilessearch.CommonAttributeSearchInterCaseTests.assertResultsAreOfType",
	"Comment": "run a search on the given type and ensure that all results are off thattype.no frequency filtering applied.",
	"Method": "void assertResultsAreOfType(CorrelationAttributeInstance.Type type){\r\n    try {\r\n        AbstractCommonAttributeSearcher builder = new AllInterCaseCommonAttributeSearcher(false, false, type, 0);\r\n        CommonAttributeSearchResults metadata = builder.findMatches();\r\n        metadata.size();\r\n        assertFalse(verifyInstanceCount(metadata, 0));\r\n        assertTrue(this.utils.areAllResultsOfType(metadata, type));\r\n    } catch (TskCoreException | NoCurrentCaseException | SQLException | EamDbException ex) {\r\n        Exceptions.printStackTrace(ex);\r\n        Assert.fail(ex.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.interestingitems.FilesSetRulePanel.isValidRuleDefinition",
	"Comment": "returns whether or not the data entered in the panel constitutes a validfiles set membership rule definition, displaying a dialog explaining thedeficiency if the definition is invalid.",
	"Method": "boolean isValidRuleDefinition(){\r\n    if (!(this.mimeCheck.isSelected() || this.fileSizeCheck.isSelected() || this.pathCheck.isSelected() || this.nameCheck.isSelected() || this.dateCheck.isSelected())) {\r\n        NotifyDescriptor notifyDesc = new NotifyDescriptor.Message(Bundle.FilesSetRulePanel_NoConditionError(), NotifyDescriptor.WARNING_MESSAGE);\r\n        DialogDisplayer.getDefault().notify(notifyDesc);\r\n        return false;\r\n    }\r\n    if (this.nameCheck.isSelected()) {\r\n        if (this.nameTextField.getText().isEmpty()) {\r\n            NotifyDescriptor notifyDesc = new NotifyDescriptor.Message(Bundle.FilesSetRulePanel_NoNameError(), NotifyDescriptor.WARNING_MESSAGE);\r\n            DialogDisplayer.getDefault().notify(notifyDesc);\r\n            return false;\r\n        }\r\n        if (this.nameRegexCheckbox.isSelected()) {\r\n            try {\r\n                Pattern.compile(this.nameTextField.getText());\r\n            } catch (PatternSyntaxException ex) {\r\n                NotifyDescriptor notifyDesc = new NotifyDescriptor.Message(NbBundle.getMessage(FilesSetPanel.class, \"FilesSetRulePanel.messages.invalidNameRegex\", ex.getLocalizedMessage()), NotifyDescriptor.WARNING_MESSAGE);\r\n                DialogDisplayer.getDefault().notify(notifyDesc);\r\n                return false;\r\n            }\r\n        } else if (this.nameTextField.getText().isEmpty() || !FilesSetRulePanel.containsOnlyLegalChars(this.nameTextField.getText(), FilesSetRulePanel.ILLEGAL_FILE_NAME_CHARS)) {\r\n            NotifyDescriptor notifyDesc = new NotifyDescriptor.Message(NbBundle.getMessage(FilesSetPanel.class, \"FilesSetRulePanel.messages.invalidCharInName\"), NotifyDescriptor.WARNING_MESSAGE);\r\n            DialogDisplayer.getDefault().notify(notifyDesc);\r\n            return false;\r\n        }\r\n    }\r\n    if (this.pathCheck.isSelected()) {\r\n        if (this.pathTextField.getText().isEmpty()) {\r\n            NotifyDescriptor notifyDesc = new NotifyDescriptor.Message(Bundle.FilesSetRulePanel_NoPathError(), NotifyDescriptor.WARNING_MESSAGE);\r\n            DialogDisplayer.getDefault().notify(notifyDesc);\r\n            return false;\r\n        }\r\n        if (this.pathRegexCheckBox.isSelected()) {\r\n            try {\r\n                Pattern.compile(this.pathTextField.getText());\r\n            } catch (PatternSyntaxException ex) {\r\n                NotifyDescriptor notifyDesc = new NotifyDescriptor.Message(NbBundle.getMessage(FilesSetPanel.class, \"FilesSetRulePanel.messages.invalidPathRegex\", ex.getLocalizedMessage()), NotifyDescriptor.WARNING_MESSAGE);\r\n                DialogDisplayer.getDefault().notify(notifyDesc);\r\n                return false;\r\n            }\r\n        } else if (this.pathTextField.getText().isEmpty() || !FilesSetRulePanel.containsOnlyLegalChars(this.pathTextField.getText(), FilesSetRulePanel.ILLEGAL_FILE_PATH_CHARS)) {\r\n            NotifyDescriptor notifyDesc = new NotifyDescriptor.Message(NbBundle.getMessage(FilesSetPanel.class, \"FilesSetRulePanel.messages.invalidCharInPath\"), NotifyDescriptor.WARNING_MESSAGE);\r\n            DialogDisplayer.getDefault().notify(notifyDesc);\r\n            return false;\r\n        }\r\n    }\r\n    if (this.mimeCheck.isSelected()) {\r\n        if (this.mimeTypeComboBox.getSelectedIndex() == 0) {\r\n            NotifyDescriptor notifyDesc = new NotifyDescriptor.Message(Bundle.FilesSetRulePanel_NoMimeTypeError(), NotifyDescriptor.WARNING_MESSAGE);\r\n            DialogDisplayer.getDefault().notify(notifyDesc);\r\n            return false;\r\n        }\r\n    }\r\n    if (this.fileSizeCheck.isSelected()) {\r\n        if ((Integer) this.fileSizeSpinner.getValue() == 0 && !((String) this.equalitySymbolComboBox.getSelectedItem()).equals(\"=\")) {\r\n            NotifyDescriptor notifyDesc = new NotifyDescriptor.Message(Bundle.FilesSetRulePanel_ZeroFileSizeError(), NotifyDescriptor.WARNING_MESSAGE);\r\n            DialogDisplayer.getDefault().notify(notifyDesc);\r\n            return false;\r\n        }\r\n    }\r\n    if (this.dateCheck.isSelected()) {\r\n        if (this.daysIncludedTextField.getText().isEmpty()) {\r\n            NotifyDescriptor notifyDesc = new NotifyDescriptor.Message(Bundle.FilesSetRulePanel_DaysIncludedEmptyError(), NotifyDescriptor.WARNING_MESSAGE);\r\n            DialogDisplayer.getDefault().notify(notifyDesc);\r\n            return false;\r\n        }\r\n        try {\r\n            int value = Integer.parseInt(daysIncludedTextField.getText());\r\n            if (value < 0) {\r\n                throw new NumberFormatException(\"Negative numbers are not allowed for the within N days condition\");\r\n            }\r\n        } catch (NumberFormatException e) {\r\n            NotifyDescriptor notifyDesc = new NotifyDescriptor.Message(Bundle.FilesSetRulePanel_DaysIncludedInvalidError(), NotifyDescriptor.WARNING_MESSAGE);\r\n            DialogDisplayer.getDefault().notify(notifyDesc);\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJobLogger.logIngestModuleCancelled",
	"Comment": "logs the cancellation of analysis of a data source by an individualingest module.",
	"Method": "void logIngestModuleCancelled(String cancelledModuleName){\r\n    log(MessageCategory.WARNING, String.format(\"%s analysis of data source cancelled\", cancelledModuleName));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.ImageUtils.getContentPathSafe",
	"Comment": "get the unique path for the content, or if that fails, just return thename.",
	"Method": "String getContentPathSafe(Content content){\r\n    try {\r\n        return content.getUniquePath();\r\n    } catch (TskCoreException tskCoreException) {\r\n        String contentName = content.getName();\r\n        LOGGER.log(Level.SEVERE, \"Failed to get unique path for \" + contentName, tskCoreException);\r\n        return contentName;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.HighlightedText.loadPageInfoFromArtifact",
	"Comment": "figure out the paging info from the artifact that was used to create thishighlightedtext",
	"Method": "void loadPageInfoFromArtifact(){\r\n    final String keyword = artifact.getAttribute(TSK_KEYWORD).getValueString();\r\n    this.keywords.add(keyword);\r\n    final BlackboardAttribute queryTypeAttribute = artifact.getAttribute(TSK_KEYWORD_SEARCH_TYPE);\r\n    qt = (queryTypeAttribute != null) ? KeywordSearch.QueryType.values()[queryTypeAttribute.getValueInt()] : null;\r\n    Keyword keywordQuery = null;\r\n    switch(qt) {\r\n        case LITERAL:\r\n        case SUBSTRING:\r\n            keywordQuery = new Keyword(keyword, true, true);\r\n            break;\r\n        case REGEX:\r\n            String regexp = artifact.getAttribute(TSK_KEYWORD_REGEXP).getValueString();\r\n            keywordQuery = new Keyword(regexp, false, false);\r\n            break;\r\n    }\r\n    KeywordSearchQuery chunksQuery = KeywordSearchUtil.getQueryForKeyword(keywordQuery, new KeywordList(Arrays.asList(keywordQuery)));\r\n    chunksQuery.addFilter(new KeywordQueryFilter(FilterType.CHUNK, this.solrObjectId));\r\n    hits = chunksQuery.performQuery();\r\n    loadPageInfoFromHits();\r\n}"
}, {
	"Path": "com.google.example.games.catt2.SnapshotCoordinator.setClosed",
	"Comment": "records the fact that the named file is closed.this is a synchronized operation since it is highly likely that multiple threadsare involved via asynctasks.",
	"Method": "void setClosed(String filename){\r\n    closing.remove(filename);\r\n    CountDownLatch l = opened.remove(filename);\r\n    if (l != null) {\r\n        l.countDown();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.PathUtils.createCaseFolderPath",
	"Comment": "creates a case folder path. does not create the folder described by thepath.",
	"Method": "Path createCaseFolderPath(Path caseFoldersPath,String caseName){\r\n    String folderName = caseName + \"_\" + TimeStampUtils.createTimeStamp();\r\n    return Paths.get(caseFoldersPath.toString(), folderName);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestControlPanel.resume",
	"Comment": "requests a resume of auto ingest processing by the auto ingest managerand handles updates to the components that implement the pause and resumefeature. note that this feature is needed to get around restrictions onchanging ingest module selections and settings while an ingest job isrunning, and that the auto ingest manager will not actually pause untilthe current auto ingest job completes.",
	"Method": "void resume(){\r\n    bnOptions.setEnabled(false);\r\n    bnPause.setText(org.openide.util.NbBundle.getMessage(AutoIngestControlPanel.class, \"AutoIngestControlPanel.bnPause.text\"));\r\n    bnPause.setToolTipText(org.openide.util.NbBundle.getMessage(AutoIngestControlPanel.class, \"AutoIngestControlPanel.bnPause.toolTipText\"));\r\n    tbStatusMessage.setText(org.openide.util.NbBundle.getMessage(AutoIngestControlPanel.class, \"AutoIngestControlPanel.bnPause.running\"));\r\n    bnRefresh.setEnabled(true);\r\n    pendingTable.setBackground(pendingTableBackground);\r\n    pendingTable.setForeground(pendingTablelForeground);\r\n    manager.resume();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJobNodeData.getErrorsOccurred",
	"Comment": "gets whether or not any errors occurred during the processing of the job.",
	"Method": "boolean getErrorsOccurred(){\r\n    return this.errorsOccurred;\r\n}"
}, {
	"Path": "net.dongliu.apk.parser.parser.DexParser.readStrings",
	"Comment": "read string pool for dex file.dex file string pool diff a bit with binary xml file or resource table.",
	"Method": "StringPool readStrings(long[] offsets){\r\n    StringPoolEntry[] entries = new StringPoolEntry[offsets.length];\r\n    for (int i = 0; i < offsets.length; i++) {\r\n        entries[i] = new StringPoolEntry(i, offsets[i]);\r\n    }\r\n    String lastStr = null;\r\n    long lastOffset = -1;\r\n    StringPool stringpool = new StringPool(offsets.length);\r\n    for (StringPoolEntry entry : entries) {\r\n        if (entry.getOffset() == lastOffset) {\r\n            stringpool.set(entry.getIdx(), lastStr);\r\n            continue;\r\n        }\r\n        Buffers.position(buffer, entry.getOffset());\r\n        lastOffset = entry.getOffset();\r\n        String str = readString();\r\n        lastStr = str;\r\n        stringpool.set(entry.getIdx(), str);\r\n    }\r\n    return stringpool;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJobNodeData.setErrorsOccurred",
	"Comment": "sets whether or not any errors occurred during the processing of job.",
	"Method": "void setErrorsOccurred(boolean errorsOccurred){\r\n    this.errorsOccurred = errorsOccurred;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestMonitor.deleteCase",
	"Comment": "deletes a case. this includes deleting the case directory, the textindex, and the case database. this does not include the directoriescontaining the data sources and their manifests.",
	"Method": "CaseDeletionResult deleteCase(AutoIngestJob job){\r\n    String caseName = job.getManifest().getCaseName();\r\n    Path caseDirectoryPath = job.getCaseDirectoryPath();\r\n    Path metadataFilePath = caseDirectoryPath.resolve(caseName + CaseMetadata.getFileExtension());\r\n    StopWatch stopWatch = new StopWatch();\r\n    stopWatch.start();\r\n    synchronized (jobsLock) {\r\n        stopWatch.stop();\r\n        LOGGER.log(Level.INFO, String.format(\"Used %d s to acquire jobsLock (Java monitor in AutoIngestMonitor class) for case %s at %s\", stopWatch.getElapsedTimeSecs(), caseName, caseDirectoryPath));\r\n        stopWatch.reset();\r\n        stopWatch.start();\r\n        try {\r\n            CaseMetadata metadata = new CaseMetadata(metadataFilePath);\r\n            stopWatch.stop();\r\n            LOGGER.log(Level.INFO, String.format(\"Used %d s to read case metadata for case %s at %s\", stopWatch.getElapsedTimeSecs(), caseName, caseDirectoryPath));\r\n            stopWatch.reset();\r\n            stopWatch.start();\r\n            Case.deleteCase(metadata);\r\n        } catch (CaseMetadata.CaseMetadataException ex) {\r\n            LOGGER.log(Level.SEVERE, String.format(\"Failed to read case metadata file %s for case %s at %s\", metadataFilePath, caseName, caseDirectoryPath), ex);\r\n            stopWatch.stop();\r\n            LOGGER.log(Level.INFO, String.format(\"Used %d s to fail to read case metadata file %s for case %s at %s\", stopWatch.getElapsedTimeSecs(), metadataFilePath, caseName, caseDirectoryPath));\r\n            return CaseDeletionResult.FAILED;\r\n        } catch (CaseActionException ex) {\r\n            LOGGER.log(Level.SEVERE, String.format(\"Failed to delete case %s at %s\", caseName, caseDirectoryPath), ex);\r\n            return CaseDeletionResult.FAILED;\r\n        }\r\n        stopWatch.reset();\r\n        stopWatch.start();\r\n        List<AutoIngestJob> completedJobs = getCompletedJobs();\r\n        stopWatch.stop();\r\n        LOGGER.log(Level.INFO, String.format(\"Used %d s to get completed jobs listing for case %s at %s\", stopWatch.getElapsedTimeSecs(), caseName, caseDirectoryPath));\r\n        stopWatch.reset();\r\n        stopWatch.start();\r\n        for (AutoIngestJob completedJob : completedJobs) {\r\n            if (caseName.equals(completedJob.getManifest().getCaseName())) {\r\n                try {\r\n                    completedJob.setProcessingStatus(DELETED);\r\n                    AutoIngestJobNodeData nodeData = new AutoIngestJobNodeData(completedJob);\r\n                    coordinationService.setNodeData(CoordinationService.CategoryNode.MANIFESTS, completedJob.getManifest().getFilePath().toString(), nodeData.toArray());\r\n                } catch (CoordinationServiceException | InterruptedException ex) {\r\n                    LOGGER.log(Level.SEVERE, String.format(\"Failed to update completed job node data for %s when deleting case %s at %s\", completedJob.getManifest().getFilePath(), caseName, caseDirectoryPath), ex);\r\n                    stopWatch.stop();\r\n                    LOGGER.log(Level.INFO, String.format(\"Used %d s to fail to update job node data for completed jobs for case %s at %s\", stopWatch.getElapsedTimeSecs(), caseName, caseDirectoryPath));\r\n                    return CaseDeletionResult.PARTIALLY_DELETED;\r\n                }\r\n            }\r\n        }\r\n        stopWatch.stop();\r\n        LOGGER.log(Level.INFO, String.format(\"Used %d s to update job node data for completed jobs for case %s at %s\", stopWatch.getElapsedTimeSecs(), caseName, caseDirectoryPath));\r\n        stopWatch.reset();\r\n        stopWatch.start();\r\n        completedJobs.removeIf((AutoIngestJob completedJob) -> completedJob.getManifest().getCaseName().equals(caseName));\r\n        stopWatch.stop();\r\n        LOGGER.log(Level.INFO, String.format(\"Used %d s to remove completed jobs for case %s at %s from current jobs snapshot\", stopWatch.getElapsedTimeSecs(), caseName, caseDirectoryPath));\r\n        stopWatch.reset();\r\n        stopWatch.start();\r\n        eventPublisher.publishRemotely(new AutoIngestCaseDeletedEvent(caseName, LOCAL_HOST_NAME, AutoIngestManager.getSystemUserNameProperty()));\r\n        stopWatch.stop();\r\n        LOGGER.log(Level.INFO, String.format(\"Used %d s to publish job deletion event for case %s at %s\", stopWatch.getElapsedTimeSecs(), caseName, caseDirectoryPath));\r\n    }\r\n    return CaseDeletionResult.FULLY_DELETED;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.directorytree.AddExternalViewerRuleDialog.doButtonAction",
	"Comment": "performs actions based on whether the save button was pressed or not.",
	"Method": "void doButtonAction(boolean savePressed){\r\n    if (savePressed) {\r\n        ExternalViewerRule ruleFromPanel = addRulePanel.getRule();\r\n        if (null != ruleFromPanel) {\r\n            this.rule = ruleFromPanel;\r\n            this.result = BUTTON_PRESSED.OK;\r\n            setVisible(false);\r\n        }\r\n    } else {\r\n        this.rule = null;\r\n        this.result = BUTTON_PRESSED.CANCEL;\r\n        setVisible(false);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.ReportHTML.addRowWithTaggedContentHyperlink",
	"Comment": "saves a local copy of a tagged file and adds a row with a hyper link tothe file. the content of the hyperlink is provided in linkhtmlcontent.",
	"Method": "void addRowWithTaggedContentHyperlink(List<String> row,ContentTag contentTag){\r\n    Content content = contentTag.getContent();\r\n    if (content instanceof AbstractFile == false) {\r\n        addRow(row, true);\r\n        return;\r\n    }\r\n    AbstractFile file = (AbstractFile) content;\r\n    StringBuilder localFileLink = new StringBuilder();\r\n    if (!(file.isDir() || file.getType() == TSK_DB_FILES_TYPE_ENUM.UNALLOC_BLOCKS || file.getType() == TSK_DB_FILES_TYPE_ENUM.UNUSED_BLOCKS)) {\r\n        localFileLink.append(\"<a href=\\\"\");\r\n        String localFilePath = saveContent(file, contentTag.getName().getDisplayName());\r\n        localFileLink.append(localFilePath);\r\n        localFileLink.append(\"\\\" target=\\\"_top\\\">\");\r\n    }\r\n    StringBuilder builder = new StringBuilder();\r\n    builder.append(\"\\t<tr>\\n\");\r\n    int positionCounter = 0;\r\n    for (String cell : row) {\r\n        switch(positionCounter) {\r\n            case 1:\r\n                builder.append(\"\\t\\t<td class=\\\"left_align_cell\\\">\").append(localFileLink.toString()).append(cell).append(\"<\/a><\/td>\\n\");\r\n                break;\r\n            case 7:\r\n                builder.append(\"\\t\\t<td class=\\\"right_align_cell\\\">\").append(cell).append(\"<\/td>\\n\");\r\n                break;\r\n            default:\r\n                builder.append(\"\\t\\t<td>\").append(cell).append(\"<\/td>\\n\");\r\n                break;\r\n        }\r\n        ++positionCounter;\r\n    }\r\n    builder.append(\"\\t<\/tr>\\n\");\r\n    rowCount++;\r\n    try {\r\n        out.write(builder.toString());\r\n    } catch (IOException ex) {\r\n        logger.log(Level.SEVERE, \"Failed to write row to out.\", ex);\r\n    } catch (NullPointerException ex) {\r\n        logger.log(Level.SEVERE, \"Output writer is null. Page was not initialized before writing.\", ex);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.services.TagsManager.getContentTagsCountByTagName",
	"Comment": "gets content tags count by tag name, for the given data source",
	"Method": "long getContentTagsCountByTagName(TagName tagName,long getContentTagsCountByTagName,TagName tagName,long dsObjId){\r\n    return caseDb.getContentTagsCountByTagName(tagName, dsObjId);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.stix.ObservableResult.addToDesc",
	"Comment": "add to the description string. mostly just to make things cleaner by nottesting for null all over the place.",
	"Method": "void addToDesc(String a_desc){\r\n    if (description == null) {\r\n        description = a_desc;\r\n    } else {\r\n        description += a_desc;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.PromptDialogManager.confirmDuringIngest",
	"Comment": "prompt the user that ingest is running and the db may not end upcomplete.",
	"Method": "boolean confirmDuringIngest(){\r\n    currentDialog = new Alert(Alert.AlertType.CONFIRMATION, Bundle.PromptDialogManager_confirmDuringIngest_contentText(), CONTINUE, ButtonType.CANCEL);\r\n    currentDialog.initModality(Modality.APPLICATION_MODAL);\r\n    currentDialog.setTitle(Bundle.Timeline_dialogs_title());\r\n    setDialogIcons(currentDialog);\r\n    currentDialog.setHeaderText(Bundle.PromptDialogManager_confirmDuringIngest_headerText());\r\n    return currentDialog.showAndWait().map(CONTINUE::equals).orElse(false);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.snapshot.SnapShotReportWriter.writeSnapShotHTMLFile",
	"Comment": "generate and write the html page that shows the snapshot and the state ofthe zoomparams",
	"Method": "void writeSnapShotHTMLFile(){\r\n    HashMap<String, Object> snapShotContext = new HashMap();\r\n    snapShotContext.put(\"reportTitle\", reportName);\r\n    snapShotContext.put(\"startTime\", zoomParams.getTimeRange().getStart().toString(DateTimeFormat.fullDateTime()));\r\n    snapShotContext.put(\"endTime\", zoomParams.getTimeRange().getEnd().toString(DateTimeFormat.fullDateTime()));\r\n    snapShotContext.put(\"zoomParams\", zoomParams);\r\n    fillTemplateAndWrite(\"/org/sleuthkit/autopsy/timeline/snapshot/snapshot_template.html\", \"Snapshot\", snapShotContext, reportFolderPath.resolve(\"snapshot.html\"));\r\n}"
}, {
	"Path": "com.google.example.games.bc.MainActivity.handleException",
	"Comment": "since a lot of the operations use tasks, we can use a common handler for whenever one fails.",
	"Method": "void handleException(Exception exception,String details){\r\n    int status = 0;\r\n    if (exception instanceof ApiException) {\r\n        ApiException apiException = (ApiException) exception;\r\n        status = apiException.getStatusCode();\r\n    }\r\n    String errorString = null;\r\n    switch(status) {\r\n        case GamesCallbackStatusCodes.OK:\r\n            break;\r\n        case GamesClientStatusCodes.MULTIPLAYER_ERROR_NOT_TRUSTED_TESTER:\r\n            errorString = getString(R.string.status_multiplayer_error_not_trusted_tester);\r\n            break;\r\n        case GamesClientStatusCodes.MATCH_ERROR_ALREADY_REMATCHED:\r\n            errorString = getString(R.string.match_error_already_rematched);\r\n            break;\r\n        case GamesClientStatusCodes.NETWORK_ERROR_OPERATION_FAILED:\r\n            errorString = getString(R.string.network_error_operation_failed);\r\n            break;\r\n        case GamesClientStatusCodes.INTERNAL_ERROR:\r\n            errorString = getString(R.string.internal_error);\r\n            break;\r\n        case GamesClientStatusCodes.MATCH_ERROR_INACTIVE_MATCH:\r\n            errorString = getString(R.string.match_error_inactive_match);\r\n            break;\r\n        case GamesClientStatusCodes.MATCH_ERROR_LOCALLY_MODIFIED:\r\n            errorString = getString(R.string.match_error_locally_modified);\r\n            break;\r\n        default:\r\n            errorString = getString(R.string.unexpected_status, GamesClientStatusCodes.getStatusCodeString(status));\r\n            break;\r\n    }\r\n    if (errorString == null) {\r\n        return;\r\n    }\r\n    String message = getString(R.string.status_exception_error, details, status, exception);\r\n    new AlertDialog.Builder(MainActivity.this).setTitle(\"Error\").setMessage(message + \"\\n\" + errorString).setNeutralButton(android.R.string.ok, null).show();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.CriterionChooser.getCriterion",
	"Comment": "get the criterion selected in this chooser. use the given rank as therank of the criterion.",
	"Method": "SortCriterion getCriterion(int rank){\r\n    return new SortCriterion((Node.Property<?>) propComboBox.getSelectedItem(), ascendingRadio.isSelected() ? SortOrder.ASCENDING : SortOrder.DESCENDING, rank);\r\n}"
}, {
	"Path": "com.aliyun.oss.internal.ResponseParsers.parseImageStyle",
	"Comment": "unmarshall get image style response body to corresponding result.",
	"Method": "GetImageStyleResult parseImageStyle(InputStream responseBody){\r\n    try {\r\n        Element root = getXmlRootElement(responseBody);\r\n        GetImageStyleResult result = new GetImageStyleResult();\r\n        result.SetStyleName(root.getChildText(\"Name\"));\r\n        result.SetStyle(root.getChildText(\"Content\"));\r\n        result.SetLastModifyTime(DateUtil.parseRfc822Date(root.getChildText(\"LastModifyTime\")));\r\n        result.SetCreationDate(DateUtil.parseRfc822Date(root.getChildText(\"CreateTime\")));\r\n        return result;\r\n    } catch (JDOMParseException e) {\r\n        throw new ResponseParseException(e.getPartialDocument() + \": \" + e.getMessage(), e);\r\n    } catch (Exception e) {\r\n        throw new ResponseParseException(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.optionspanel.AddNewOrganizationDialog.requiredFieldsArePopulated",
	"Comment": "tests whether or not values have been entered in all of the databasesettings text fields.",
	"Method": "boolean requiredFieldsArePopulated(){\r\n    return !tfOrganizationName.getText().trim().isEmpty();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.ModuleDataEvent.getModuleName",
	"Comment": "get module name that created the artifacts and fired the event",
	"Method": "String getModuleName(){\r\n    return moduleName;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.CommonAttributePanel.setupDataSources",
	"Comment": "sets up the data sources dropdown and returns the data sources map forfuture usage.",
	"Method": "void setupDataSources(){\r\n    new SwingWorker<Map<Long, String>, Void>() {\r\n        private void updateUi() {\r\n            final Map<Long, String> dataSourceMap = CommonAttributePanel.this.intraCasePanel.getDataSourceMap();\r\n            String[] dataSourcesNames = new String[dataSourceMap.size()];\r\n            if (dataSourcesNames.length > 0) {\r\n                dataSourcesNames = dataSourceMap.values().toArray(dataSourcesNames);\r\n                CommonAttributePanel.this.intraCasePanel.setDatasourceComboboxModel(new DataSourceComboBoxModel(dataSourcesNames));\r\n                if (!this.caseHasMultipleSources()) {\r\n                    intraCaseRadio.setEnabled(false);\r\n                    interCaseRadio.setSelected(true);\r\n                    intraCasePanel.setVisible(false);\r\n                    interCasePanel.setVisible(true);\r\n                }\r\n                CommonAttributePanel.this.updateErrorTextAndSearchButton();\r\n            }\r\n        }\r\n        private boolean caseHasMultipleSources() {\r\n            return CommonAttributePanel.this.intraCasePanel.getDataSourceMap().size() > 1;\r\n        }\r\n        @Override\r\n        protected Map<Long, String> doInBackground() throws NoCurrentCaseException, TskCoreException, SQLException {\r\n            DataSourceLoader loader = new DataSourceLoader();\r\n            return loader.getDataSourceMap();\r\n        }\r\n        @Override\r\n        protected void done() {\r\n            try {\r\n                CommonAttributePanel.this.intraCasePanel.setDataSourceMap(this.get());\r\n                updateUi();\r\n            } catch (InterruptedException ex) {\r\n                LOGGER.log(Level.SEVERE, \"Interrupted while building Common Files Search dialog.\", ex);\r\n                MessageNotifyUtil.Message.error(Bundle.CommonAttributePanel_setupDataSources_done_interupted());\r\n            } catch (ExecutionException ex) {\r\n                String errorMessage;\r\n                Throwable inner = ex.getCause();\r\n                if (inner instanceof TskCoreException) {\r\n                    LOGGER.log(Level.SEVERE, \"Failed to load data sources from database.\", ex);\r\n                    errorMessage = Bundle.CommonAttributePanel_setupDataSources_done_tskCoreException();\r\n                } else if (inner instanceof NoCurrentCaseException) {\r\n                    LOGGER.log(Level.SEVERE, \"Current case has been closed.\", ex);\r\n                    errorMessage = Bundle.CommonAttributePanel_setupDataSources_done_noCurrentCaseException();\r\n                } else if (inner instanceof SQLException) {\r\n                    LOGGER.log(Level.SEVERE, \"Unable to query db for data sources.\", ex);\r\n                    errorMessage = Bundle.CommonAttributePanel_setupDataSources_done_sqlException();\r\n                } else {\r\n                    LOGGER.log(Level.SEVERE, \"Unexpected exception while building Common Files Search dialog panel.\", ex);\r\n                    errorMessage = Bundle.CommonAttributePanel_setupDataSources_done_exception();\r\n                }\r\n                MessageNotifyUtil.Message.error(errorMessage);\r\n            }\r\n        }\r\n    }.execute();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.CommonAttributePanel.setupDataSources",
	"Comment": "sets up the data sources dropdown and returns the data sources map forfuture usage.",
	"Method": "void setupDataSources(){\r\n    final Map<Long, String> dataSourceMap = CommonAttributePanel.this.intraCasePanel.getDataSourceMap();\r\n    String[] dataSourcesNames = new String[dataSourceMap.size()];\r\n    if (dataSourcesNames.length > 0) {\r\n        dataSourcesNames = dataSourceMap.values().toArray(dataSourcesNames);\r\n        CommonAttributePanel.this.intraCasePanel.setDatasourceComboboxModel(new DataSourceComboBoxModel(dataSourcesNames));\r\n        if (!this.caseHasMultipleSources()) {\r\n            intraCaseRadio.setEnabled(false);\r\n            interCaseRadio.setSelected(true);\r\n            intraCasePanel.setVisible(false);\r\n            interCasePanel.setVisible(true);\r\n        }\r\n        CommonAttributePanel.this.updateErrorTextAndSearchButton();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.CommonAttributePanel.setupDataSources",
	"Comment": "sets up the data sources dropdown and returns the data sources map forfuture usage.",
	"Method": "void setupDataSources(){\r\n    return CommonAttributePanel.this.intraCasePanel.getDataSourceMap().size() > 1;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.CommonAttributePanel.setupDataSources",
	"Comment": "sets up the data sources dropdown and returns the data sources map forfuture usage.",
	"Method": "void setupDataSources(){\r\n    DataSourceLoader loader = new DataSourceLoader();\r\n    return loader.getDataSourceMap();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.CommonAttributePanel.setupDataSources",
	"Comment": "sets up the data sources dropdown and returns the data sources map forfuture usage.",
	"Method": "void setupDataSources(){\r\n    try {\r\n        CommonAttributePanel.this.intraCasePanel.setDataSourceMap(this.get());\r\n        updateUi();\r\n    } catch (InterruptedException ex) {\r\n        LOGGER.log(Level.SEVERE, \"Interrupted while building Common Files Search dialog.\", ex);\r\n        MessageNotifyUtil.Message.error(Bundle.CommonAttributePanel_setupDataSources_done_interupted());\r\n    } catch (ExecutionException ex) {\r\n        String errorMessage;\r\n        Throwable inner = ex.getCause();\r\n        if (inner instanceof TskCoreException) {\r\n            LOGGER.log(Level.SEVERE, \"Failed to load data sources from database.\", ex);\r\n            errorMessage = Bundle.CommonAttributePanel_setupDataSources_done_tskCoreException();\r\n        } else if (inner instanceof NoCurrentCaseException) {\r\n            LOGGER.log(Level.SEVERE, \"Current case has been closed.\", ex);\r\n            errorMessage = Bundle.CommonAttributePanel_setupDataSources_done_noCurrentCaseException();\r\n        } else if (inner instanceof SQLException) {\r\n            LOGGER.log(Level.SEVERE, \"Unable to query db for data sources.\", ex);\r\n            errorMessage = Bundle.CommonAttributePanel_setupDataSources_done_sqlException();\r\n        } else {\r\n            LOGGER.log(Level.SEVERE, \"Unexpected exception while building Common Files Search dialog panel.\", ex);\r\n            errorMessage = Bundle.CommonAttributePanel_setupDataSources_done_exception();\r\n        }\r\n        MessageNotifyUtil.Message.error(errorMessage);\r\n    }\r\n}"
}, {
	"Path": "com.aliyun.oss.model.CompleteMultipartUploadResult.getBucketName",
	"Comment": "gets the bucket name of the target file of this multipart upload.",
	"Method": "String getBucketName(){\r\n    return bucketName;\r\n}"
}, {
	"Path": "com.mcxiaoke.next.recycler.HeaderFooterRecyclerAdapter.notifyFooterItemMoved",
	"Comment": "notifies that an existing footer item is moved to another position.",
	"Method": "void notifyFooterItemMoved(int fromPosition,int toPosition){\r\n    if (fromPosition < 0 || toPosition < 0 || fromPosition >= footerItemCount || toPosition >= footerItemCount) {\r\n        throw new IndexOutOfBoundsException(\"The given fromPosition \" + fromPosition + \" or toPosition \" + toPosition + \" is not within the position bounds for footer items [0 - \" + (footerItemCount - 1) + \"].\");\r\n    }\r\n    notifyItemMoved(fromPosition + headerItemCount + contentItemCount, toPosition + headerItemCount + contentItemCount);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.datamodel.ContentUtils.getStringTime",
	"Comment": "convert epoch seconds to a string value in the given time zone.",
	"Method": "String getStringTime(long epochSeconds,TimeZone tzone,String getStringTime,long epochSeconds,Content content){\r\n    return getStringTime(epochSeconds, getTimeZone(content));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.AddImageWizardIterator.nextPanel",
	"Comment": "moves to the next panel. i.e. increment its index, need not actuallychange any gui itself.",
	"Method": "void nextPanel(){\r\n    if (!hasNext()) {\r\n        throw new NoSuchElementException();\r\n    }\r\n    if (index == dsPanelIndex) {\r\n        ((AddImageWizardAddingProgressPanel) panels.get(progressPanelIndex)).startDataSourceProcessing(((AddImageWizardDataSourceSettingsPanel) panels.get(dsPanelIndex)).getComponent().getCurrentDSProcessor());\r\n    }\r\n    boolean panelEnablesSkipping = current().panelEnablesSkipping();\r\n    boolean skipNextPanel = current().skipNextPanel();\r\n    index++;\r\n    if (panelEnablesSkipping && skipNextPanel) {\r\n        current().processThisPanelBeforeSkipped();\r\n        nextPanel();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.communications.VisualizationPanel.applyLayout",
	"Comment": "apply the given layout. the given layout becomes the current layout. thelayout is computed in the background.",
	"Method": "void applyLayout(NamedGraphLayout layout){\r\n    currentLayout = layout;\r\n    layoutButtons.forEach((layoutKey, button) -> button.setFont(button.getFont().deriveFont(layoutKey == layout ? Font.BOLD : Font.PLAIN)));\r\n    ModalDialogProgressIndicator progressIndicator = new ModalDialogProgressIndicator(windowAncestor, Bundle.VisualizationPanel_computingLayout());\r\n    progressIndicator.start(Bundle.VisualizationPanel_computingLayout());\r\n    new SwingWorker<Void, Void>() {\r\n        @Override\r\n        protected Void doInBackground() {\r\n            graph.getModel().beginUpdate();\r\n            try {\r\n                layout.execute(graph.getDefaultParent());\r\n                fitGraph();\r\n            } finally {\r\n                graph.getModel().endUpdate();\r\n                progressIndicator.finish();\r\n            }\r\n            return null;\r\n        }\r\n        @Override\r\n        protected void done() {\r\n            try {\r\n                get();\r\n            } catch (InterruptedException | ExecutionException ex) {\r\n                logger.log(Level.WARNING, \"CVT graph layout failed.\", ex);\r\n                String message = (lockedVertexModel.isEmpty()) ? Bundle.VisualizationPanel_layoutFail_text(layout.getDisplayName()) : Bundle.VisualizationPanel_layoutFailWithLockedVertices_text(layout.getDisplayName());\r\n                Platform.runLater(() -> Notifications.create().owner(notificationsJFXPanel.getScene().getWindow()).text(message).showWarning());\r\n            }\r\n        }\r\n    }.execute();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.communications.VisualizationPanel.applyLayout",
	"Comment": "apply the given layout. the given layout becomes the current layout. thelayout is computed in the background.",
	"Method": "void applyLayout(NamedGraphLayout layout){\r\n    graph.getModel().beginUpdate();\r\n    try {\r\n        layout.execute(graph.getDefaultParent());\r\n        fitGraph();\r\n    } finally {\r\n        graph.getModel().endUpdate();\r\n        progressIndicator.finish();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.communications.VisualizationPanel.applyLayout",
	"Comment": "apply the given layout. the given layout becomes the current layout. thelayout is computed in the background.",
	"Method": "void applyLayout(NamedGraphLayout layout){\r\n    try {\r\n        get();\r\n    } catch (InterruptedException | ExecutionException ex) {\r\n        logger.log(Level.WARNING, \"CVT graph layout failed.\", ex);\r\n        String message = (lockedVertexModel.isEmpty()) ? Bundle.VisualizationPanel_layoutFail_text(layout.getDisplayName()) : Bundle.VisualizationPanel_layoutFailWithLockedVertices_text(layout.getDisplayName());\r\n        Platform.runLater(() -> Notifications.create().owner(notificationsJFXPanel.getScene().getWindow()).text(message).showWarning());\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.core.ServicesMonitor.setServiceStatus",
	"Comment": "updates service status and publishes the service status update if it isdifferent from previous status. event is published locally. logs statuschanges.",
	"Method": "void setServiceStatus(String service,String status,String details){\r\n    if (statusByService.containsKey(service) && status.equals(statusByService.get(service))) {\r\n        return;\r\n    }\r\n    String serviceDisplayName;\r\n    try {\r\n        serviceDisplayName = ServicesMonitor.Service.valueOf(service).getDisplayName();\r\n    } catch (IllegalArgumentException ignore) {\r\n        serviceDisplayName = service;\r\n    }\r\n    if (status.equals(ServiceStatus.UP.toString())) {\r\n        logger.log(Level.INFO, \"Connection to {0} is up\", serviceDisplayName);\r\n        MessageNotifyUtil.Notify.info(NbBundle.getMessage(ServicesMonitor.class, \"ServicesMonitor.restoredService.notify.title\"), NbBundle.getMessage(ServicesMonitor.class, \"ServicesMonitor.restoredService.notify.msg\", serviceDisplayName));\r\n    } else if (status.equals(ServiceStatus.DOWN.toString())) {\r\n        logger.log(Level.SEVERE, \"Failed to connect to {0}. Reason: {1}\", new Object[] { serviceDisplayName, details });\r\n        MessageNotifyUtil.Notify.error(NbBundle.getMessage(ServicesMonitor.class, \"ServicesMonitor.failedService.notify.title\"), NbBundle.getMessage(ServicesMonitor.class, \"ServicesMonitor.failedService.notify.msg\", serviceDisplayName));\r\n    } else {\r\n        logger.log(Level.INFO, \"Status for {0} is {1}\", new Object[] { serviceDisplayName, status });\r\n        MessageNotifyUtil.Notify.info(NbBundle.getMessage(ServicesMonitor.class, \"ServicesMonitor.statusChange.notify.title\"), NbBundle.getMessage(ServicesMonitor.class, \"ServicesMonitor.statusChange.notify.msg\", new Object[] { serviceDisplayName, status }));\r\n    }\r\n    statusByService.put(service, status);\r\n    eventPublisher.publishLocally(new ServiceEvent(service, status, details));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.contentviewers.MediaViewVideoPanel.createVideoPanel",
	"Comment": "factory method to create a mediaviewvideopanel.implementation is dependent on the architecture of the jvm.",
	"Method": "MediaViewVideoPanel createVideoPanel(){\r\n    if (is64BitJVM()) {\r\n        logger.log(Level.INFO, \"64 bit JVM detected. Creating JavaFX Video Player.\");\r\n        return getFXImpl();\r\n    } else {\r\n        logger.log(Level.INFO, \"32 bit JVM detected. Creating GStreamer Video Player.\");\r\n        return getGstImpl();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.ReportExcel.startReport",
	"Comment": "start the excel report by creating the workbook, initializing styles, andwriting the summary.",
	"Method": "void startReport(String baseReportDir){\r\n    this.reportPath = baseReportDir + getRelativeFilePath();\r\n    wb = new XSSFWorkbook();\r\n    titleStyle = wb.createCellStyle();\r\n    Font titleFont = wb.createFont();\r\n    titleFont.setFontHeightInPoints((short) 12);\r\n    titleStyle.setFont(titleFont);\r\n    titleStyle.setAlignment(HorizontalAlignment.LEFT);\r\n    titleStyle.setWrapText(true);\r\n    setStyle = wb.createCellStyle();\r\n    Font setFont = wb.createFont();\r\n    setFont.setFontHeightInPoints((short) 14);\r\n    setFont.setBold(true);\r\n    setStyle.setFont(setFont);\r\n    setStyle.setAlignment(HorizontalAlignment.LEFT);\r\n    setStyle.setWrapText(true);\r\n    elementStyle = wb.createCellStyle();\r\n    Font elementFont = wb.createFont();\r\n    elementFont.setFontHeightInPoints((short) 14);\r\n    elementStyle.setFont(elementFont);\r\n    elementStyle.setAlignment(HorizontalAlignment.LEFT);\r\n    elementStyle.setWrapText(true);\r\n    writeSummaryWorksheet();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.IntraCasePanel.setDatasourceComboboxModel",
	"Comment": "set the datamodel for the combo box which displays the data sources inthe current case",
	"Method": "void setDatasourceComboboxModel(DataSourceComboBoxModel dataSourceComboBoxModel){\r\n    this.dataSourcesList = dataSourceComboBoxModel;\r\n    this.selectDataSourceComboBox.setModel(dataSourcesList);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.ReportKML.getString",
	"Comment": "get a string from an artifact if it exists, return null otherwise.",
	"Method": "String getString(BlackboardArtifact artifact,BlackboardAttribute.ATTRIBUTE_TYPE type){\r\n    String returnValue = null;\r\n    try {\r\n        BlackboardAttribute bba = artifact.getAttribute(new BlackboardAttribute.Type(type));\r\n        if (bba != null) {\r\n            String value = bba.getValueString();\r\n            if (value != null && !value.isEmpty()) {\r\n                returnValue = value;\r\n            }\r\n        }\r\n    } catch (TskCoreException ex) {\r\n        logger.log(Level.SEVERE, \"Error getting String value: \" + type.toString(), ex);\r\n    }\r\n    return returnValue;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.ui.AbstractTimeLineView.hasVisibleEventsProperty",
	"Comment": "a property that indicates whether there are any events visible in thisview with the current view parameters.",
	"Method": "ReadOnlyBooleanProperty hasVisibleEventsProperty(){\r\n    return hasVisibleEvents.getReadOnlyProperty();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.datamodel.SingleEvent.getArtifactID",
	"Comment": "get the artifact id of the artifact this event is derived from.",
	"Method": "Optional<Long> getArtifactID(){\r\n    return Optional.ofNullable(artifactID);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.ImageUtils.getFile",
	"Comment": "get a file object for where the cached icon should exist. the returnedfile may not exist.",
	"Method": "File getFile(long id){\r\n    return getCachedThumbnailLocation(id);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.GetFilesContentVisitor.getAllFromChildren",
	"Comment": "aggregate all the matches from visiting the children content objects of aparent content object.",
	"Method": "Collection<AbstractFile> getAllFromChildren(Content parent){\r\n    Collection<AbstractFile> all = new ArrayList();\r\n    try {\r\n        for (Content child : parent.getChildren()) {\r\n            if (child instanceof AbstractContent) {\r\n                all.addAll(child.accept(this));\r\n            }\r\n        }\r\n    } catch (TskException ex) {\r\n        logger.log(Level.SEVERE, \"Error getting Content children\", ex);\r\n    }\r\n    return all;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestControlPanel.shutdown",
	"Comment": "shuts down auto ingest by shutting down the auto ingest manager and doingan application exit.",
	"Method": "void shutdown(){\r\n    Object[] options = { NbBundle.getMessage(AutoIngestControlPanel.class, \"AutoIngestControlPanel.OK\"), NbBundle.getMessage(AutoIngestControlPanel.class, \"AutoIngestControlPanel.Cancel\") };\r\n    int reply = JOptionPane.OK_OPTION;\r\n    if (null != manager && IngestManager.getInstance().isIngestRunning()) {\r\n        reply = JOptionPane.showOptionDialog(this, NbBundle.getMessage(AutoIngestControlPanel.class, \"AutoIngestControlPanel.ExitConsequences\"), NbBundle.getMessage(AutoIngestControlPanel.class, \"ConfirmationDialog.ConfirmExitHeader\"), JOptionPane.DEFAULT_OPTION, JOptionPane.WARNING_MESSAGE, null, options, options[JOptionPane.NO_OPTION]);\r\n    }\r\n    if (reply == JOptionPane.OK_OPTION) {\r\n        this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\r\n        tbStatusMessage.setText(org.openide.util.NbBundle.getMessage(AutoIngestControlPanel.class, \"AutoIngestControlPanel.ExitingStatus\"));\r\n        if (null != updateExecutor) {\r\n            updateExecutor.shutdownNow();\r\n        }\r\n        if (null != manager) {\r\n            manager.deleteObserver(this);\r\n        }\r\n        new SwingWorker<Void, Void>() {\r\n            @Override\r\n            protected Void doInBackground() throws Exception {\r\n                if (null != manager) {\r\n                    manager.shutDown();\r\n                }\r\n                return null;\r\n            }\r\n            @Override\r\n            protected void done() {\r\n                AutoIngestControlPanel.this.setCursor(Cursor.getDefaultCursor());\r\n                LifecycleManager.getDefault().exit();\r\n            }\r\n        }.execute();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestControlPanel.shutdown",
	"Comment": "shuts down auto ingest by shutting down the auto ingest manager and doingan application exit.",
	"Method": "void shutdown(){\r\n    if (null != manager) {\r\n        manager.shutDown();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestControlPanel.shutdown",
	"Comment": "shuts down auto ingest by shutting down the auto ingest manager and doingan application exit.",
	"Method": "void shutdown(){\r\n    AutoIngestControlPanel.this.setCursor(Cursor.getDefaultCursor());\r\n    LifecycleManager.getDefault().exit();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.Server.getSolrContent",
	"Comment": "get the text contents of a single chunk for the given file as stored insolr.",
	"Method": "String getSolrContent(Content content,String getSolrContent,Content content,int chunkID,String getSolrContent,long objectID,String getSolrContent,long objectID,int chunkID,String getSolrContent,long contentID,int chunkID){\r\n    currentCoreLock.readLock().lock();\r\n    try {\r\n        if (null == currentCore) {\r\n            throw new NoOpenCoreException();\r\n        }\r\n        return currentCore.getSolrContent(objectID, chunkID);\r\n    } finally {\r\n        currentCoreLock.readLock().unlock();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.AutopsyOptionsPanel.readConfFile",
	"Comment": "reads a conf file line by line putting each line into a list of stringswhich will be returned.",
	"Method": "List<String> readConfFile(File configFile){\r\n    List<String> lines = new ArrayList();\r\n    if (null != configFile) {\r\n        Path filePath = configFile.toPath();\r\n        Charset charset = Charset.forName(\"UTF-8\");\r\n        try {\r\n            lines = Files.readAllLines(filePath, charset);\r\n        } catch (IOException e) {\r\n            logger.log(Level.SEVERE, \"Error reading config file contents. {}\", configFile.getAbsolutePath());\r\n        }\r\n    }\r\n    return lines;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestJobSettings.loadModuleSettings",
	"Comment": "gets the saved or default ingest job settings for a given ingest module.",
	"Method": "IngestModuleIngestJobSettings loadModuleSettings(IngestModuleFactory factory){\r\n    IngestModuleIngestJobSettings settings = null;\r\n    String moduleSettingsFilePath = getModuleSettingsFilePath(factory);\r\n    File settingsFile = new File(moduleSettingsFilePath);\r\n    if (settingsFile.exists()) {\r\n        try (NbObjectInputStream in = new NbObjectInputStream(new FileInputStream(settingsFile.getAbsolutePath()))) {\r\n            settings = (IngestModuleIngestJobSettings) in.readObject();\r\n        } catch (IOException | ClassNotFoundException ex) {\r\n            String warning = NbBundle.getMessage(IngestJobSettings.class, \"IngestJobSettings.moduleSettingsLoad.warning\", factory.getModuleDisplayName(), this.executionContext);\r\n            logger.log(Level.WARNING, warning, ex);\r\n            this.warnings.add(warning);\r\n        }\r\n    }\r\n    if (settings == null) {\r\n        settings = factory.getDefaultIngestJobSettings();\r\n    }\r\n    return settings;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestManager.fireIngestModuleDataEvent",
	"Comment": "publishes an ingest module event signifying a blackboard post by aningest module.",
	"Method": "void fireIngestModuleDataEvent(ModuleDataEvent moduleDataEvent){\r\n    AutopsyEvent event = new BlackboardPostEvent(moduleDataEvent);\r\n    eventPublishingExecutor.submit(new PublishEventTask(event, moduleEventPublisher));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.datamodel.ImageNode.nameForImage",
	"Comment": "helper so that the display name and the name used in building the pathare determined the same way.",
	"Method": "String nameForImage(Image i){\r\n    return i.getName();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.AddImageWizardSelectDspVisual.getListOfDsps",
	"Comment": "create a list of the datasourceprocessors which should exist as optionson this panel. the default autopsy datasourceprocessors will appear atthe beggining of the list in the same order.",
	"Method": "List<String> getListOfDsps(){\r\n    List<String> dspList = new ArrayList();\r\n    final Map<String, DataSourceProcessor> datasourceProcessorsMap = new HashMap();\r\n    for (DataSourceProcessor dsProcessor : Lookup.getDefault().lookupAll(DataSourceProcessor.class)) {\r\n        if (!datasourceProcessorsMap.containsKey(dsProcessor.getDataSourceType())) {\r\n            datasourceProcessorsMap.put(dsProcessor.getDataSourceType(), dsProcessor);\r\n        } else {\r\n            logger.log(Level.SEVERE, \"discoverDataSourceProcessors(): A DataSourceProcessor already exists for type = {0}\", dsProcessor.getDataSourceType());\r\n        }\r\n    }\r\n    dspList.add(ImageDSProcessor.getType());\r\n    dspList.add(LocalDiskDSProcessor.getType());\r\n    dspList.add(LocalFilesDSProcessor.getType());\r\n    dspList.add(RawDSProcessor.getType());\r\n    for (String dspType : datasourceProcessorsMap.keySet()) {\r\n        if (!dspList.contains(dspType)) {\r\n            dspList.add(dspType);\r\n        }\r\n    }\r\n    return dspList;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.contentviewers.AnnotationsContentViewer.addCentralRepositoryEntry",
	"Comment": "add a data table containing information about a correlation attributeinstance in the central repository.",
	"Method": "void addCentralRepositoryEntry(StringBuilder html,CorrelationAttributeInstance attributeInstance){\r\n    startTable(html);\r\n    addRow(html, Bundle.AnnotationsContentViewer_centralRepositoryEntryDataLabel_case(), attributeInstance.getCorrelationCase().getDisplayName());\r\n    addRow(html, Bundle.AnnotationsContentViewer_centralRepositoryEntryDataLabel_type(), attributeInstance.getCorrelationType().getDisplayName());\r\n    addRow(html, Bundle.AnnotationsContentViewer_centralRepositoryEntryDataLabel_comment(), formatHtmlString(attributeInstance.getComment()));\r\n    addRow(html, Bundle.AnnotationsContentViewer_centralRepositoryEntryDataLabel_path(), attributeInstance.getFilePath());\r\n    endTable(html);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.interestingitems.FilesSetRulePanel.populateNameConditionComponents",
	"Comment": "populates the ui components that display the name condition for a rule.",
	"Method": "void populateNameConditionComponents(FilesSet.Rule rule){\r\n    FilesSet.Rule.FileNameCondition nameCondition = rule.getFileNameCondition();\r\n    if (nameCondition != null) {\r\n        this.nameCheck.setSelected(true);\r\n        this.nameCheckActionPerformed(null);\r\n        this.nameTextField.setText(nameCondition.getTextToMatch());\r\n        this.nameRegexCheckbox.setSelected(nameCondition.isRegex());\r\n        if (nameCondition instanceof FilesSet.Rule.FullNameCondition) {\r\n            this.fullNameRadioButton.setSelected(true);\r\n        } else {\r\n            this.extensionRadioButton.setSelected(true);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.wikipedia.util.DimenUtil.getToolbarHeightPx",
	"Comment": "returns the height of the toolbar in the current activity. the system controls the height ofthe toolbar, which may be slightly different depending on screen orientation, and deviceversion.",
	"Method": "int getToolbarHeightPx(Context context){\r\n    final TypedArray styledAttributes = context.getTheme().obtainStyledAttributes(new int[] { android.support.v7.appcompat.R.attr.actionBarSize });\r\n    int size = styledAttributes.getDimensionPixelSize(0, 0);\r\n    styledAttributes.recycle();\r\n    return size;\r\n}"
}, {
	"Path": "com.anysoftkeyboard.keyboards.views.CandidateView.onDraw",
	"Comment": "if the canvas is null, then only touch calculations are performed to pickthe target candidate.",
	"Method": "void onDraw(Canvas canvas){\r\n    if (canvas != null) {\r\n        super.onDraw(canvas);\r\n    }\r\n    mTotalWidth = 0;\r\n    final int height = getHeight();\r\n    if (mBgPadding == null) {\r\n        mBgPadding = new Rect(0, 0, 0, 0);\r\n        if (getBackground() != null) {\r\n            getBackground().getPadding(mBgPadding);\r\n        }\r\n        mDivider.setBounds(0, 0, mDivider.getIntrinsicWidth(), mDivider.getIntrinsicHeight());\r\n    }\r\n    final int dividerYOffset = (height - mDivider.getMinimumHeight()) / 2;\r\n    final int count = mSuggestions.size();\r\n    final Rect bgPadding = mBgPadding;\r\n    final Paint paint = mPaint;\r\n    final int touchX = mTouchX;\r\n    final int scrollX = getScrollX();\r\n    final boolean scrolled = mScrolled;\r\n    final boolean typedWordValid = mTypedWordValid;\r\n    int x = 0;\r\n    for (int i = 0; i < count; i++) {\r\n        CharSequence suggestion = mSuggestions.get(i);\r\n        if (suggestion == null) {\r\n            continue;\r\n        }\r\n        final int wordLength = suggestion.length();\r\n        paint.setColor(mColorNormal);\r\n        if (mHaveMinimalSuggestion && ((i == 1 && !typedWordValid) || (i == 0 && typedWordValid))) {\r\n            paint.setTypeface(Typeface.DEFAULT_BOLD);\r\n            paint.setColor(mColorRecommended);\r\n        } else if (i != 0 || (wordLength == 1 && count > 1)) {\r\n            paint.setColor(mColorOther);\r\n        }\r\n        int wordWidth;\r\n        if ((wordWidth = mWordWidth[i]) == 0) {\r\n            float textWidth = paint.measureText(suggestion, 0, wordLength);\r\n            wordWidth = (int) (textWidth + mHorizontalGap * 2);\r\n            mWordWidth[i] = wordWidth;\r\n        }\r\n        mWordX[i] = x;\r\n        if (touchX != OUT_OF_BOUNDS_X_CORD && !scrolled && touchX + scrollX >= x && touchX + scrollX < x + wordWidth) {\r\n            if (canvas != null && !mShowingAddToDictionary) {\r\n                canvas.translate(x, 0);\r\n                mSelectionHighlight.setBounds(0, bgPadding.top, wordWidth, height);\r\n                mSelectionHighlight.draw(canvas);\r\n                canvas.translate(-x, 0);\r\n            }\r\n            mSelectedString = suggestion;\r\n            mSelectedIndex = i;\r\n        }\r\n        if (canvas != null) {\r\n            if (mAlwaysUseDrawText) {\r\n                final int y = (int) (height + paint.getTextSize() - paint.descent()) / 2;\r\n                canvas.drawText(suggestion, 0, wordLength, x + wordWidth / 2, y, paint);\r\n            } else {\r\n                final int y = (int) (height - paint.getTextSize() + paint.descent()) / 2;\r\n                float textX = x + (wordWidth / 2) - mHorizontalGap;\r\n                float textY = y - bgPadding.bottom - bgPadding.top;\r\n                canvas.translate(textX, textY);\r\n                mTextPaint.setTypeface(paint.getTypeface());\r\n                mTextPaint.setColor(paint.getColor());\r\n                StaticLayout suggestionText = new StaticLayout(suggestion, mTextPaint, wordWidth, Alignment.ALIGN_CENTER, 1.0f, 0.0f, false);\r\n                suggestionText.draw(canvas);\r\n                canvas.translate(-textX, -textY);\r\n            }\r\n            paint.setColor(mColorOther);\r\n            canvas.translate(x + wordWidth, 0);\r\n            if (count > 1 && (!mShowingAddToDictionary) && i != (count - 1)) {\r\n                canvas.translate(0, dividerYOffset);\r\n                mDivider.draw(canvas);\r\n                canvas.translate(0, -dividerYOffset);\r\n            }\r\n            canvas.translate(-x - wordWidth, 0);\r\n        }\r\n        paint.setTypeface(Typeface.DEFAULT);\r\n        x += wordWidth;\r\n    }\r\n    mTotalWidth = x;\r\n    if (mTargetScrollX != scrollX) {\r\n        scrollToTarget();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.directorytree.ExternalViewerAction.openFile",
	"Comment": "opens a file, taking into account user preferences and then the defaultassociated application.",
	"Method": "void openFile(String mimeType,String ext,File file){\r\n    String exePath = ExternalViewerRulesManager.getInstance().getExePathForName(mimeType);\r\n    if (exePath.equals(\"\")) {\r\n        exePath = ExternalViewerRulesManager.getInstance().getExePathForName(ext);\r\n    }\r\n    if (!exePath.equals(\"\")) {\r\n        Runtime runtime = Runtime.getRuntime();\r\n        String[] execArray = new String[] { exePath, file.getAbsolutePath() };\r\n        try {\r\n            runtime.exec(execArray);\r\n        } catch (IOException ex) {\r\n            logger.log(Level.WARNING, \"Could not open the specified viewer for the given file: \" + file.getName(), ex);\r\n            JOptionPane.showMessageDialog(WindowManager.getDefault().getMainWindow(), Bundle.ExternalViewerAction_actionPerformed_failure_IO_message(), Bundle.ExternalViewerAction_actionPerformed_failure_title(), JOptionPane.ERROR_MESSAGE);\r\n        }\r\n    } else {\r\n        try {\r\n            String localpath = file.getPath();\r\n            if (localpath.toLowerCase().contains(\"http\")) {\r\n                String url_path = file.getPath().replaceAll(\"\\\\\\\\\", \"/\");\r\n                Desktop.getDesktop().browse(new URI(url_path.replaceFirst(\"/\", \"//\")));\r\n            } else {\r\n                Desktop.getDesktop().open(file);\r\n            }\r\n        } catch (IOException ex) {\r\n            logger.log(Level.WARNING, \"Could not find a viewer for the given file: \" + file.getName(), ex);\r\n            JOptionPane.showMessageDialog(WindowManager.getDefault().getMainWindow(), Bundle.ExternalViewerAction_actionPerformed_failure_IO_message(), Bundle.ExternalViewerAction_actionPerformed_failure_title(), JOptionPane.ERROR_MESSAGE);\r\n        } catch (UnsupportedOperationException ex) {\r\n            logger.log(Level.WARNING, \"Platform cannot open \" + file.getName() + \" in the defined editor.\", ex);\r\n            JOptionPane.showMessageDialog(WindowManager.getDefault().getMainWindow(), Bundle.ExternalViewerAction_actionPerformed_failure_support_message(), Bundle.ExternalViewerAction_actionPerformed_failure_title(), JOptionPane.ERROR_MESSAGE);\r\n        } catch (IllegalArgumentException ex) {\r\n            logger.log(Level.WARNING, \"Could not find the given file: \" + file.getName(), ex);\r\n            JOptionPane.showMessageDialog(WindowManager.getDefault().getMainWindow(), Bundle.ExternalViewerAction_actionPerformed_failure_missingFile_message(), Bundle.ExternalViewerAction_actionPerformed_failure_title(), JOptionPane.ERROR_MESSAGE);\r\n        } catch (SecurityException ex) {\r\n            logger.log(Level.WARNING, \"Could not get permission to open the given file: \" + file.getName(), ex);\r\n            JOptionPane.showMessageDialog(WindowManager.getDefault().getMainWindow(), Bundle.ExternalViewerAction_actionPerformed_failure_permission_message(), Bundle.ExternalViewerAction_actionPerformed_failure_title(), JOptionPane.ERROR_MESSAGE);\r\n        } catch (URISyntaxException ex) {\r\n            logger.log(Level.WARNING, \"Could not open URL provided: \" + file.getPath(), ex);\r\n            JOptionPane.showMessageDialog(null, Bundle.ExternalViewerAction_actionPerformed_failure_open_url(), Bundle.ExternalViewerAction_actionPerformed_failure_title(), JOptionPane.ERROR_MESSAGE);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.DropdownSingleTermSearchPanel.customizeComponents",
	"Comment": "does additional initialization of the gui components created by theinitcomponents method.",
	"Method": "void customizeComponents(){\r\n    keywordTextField.addFocusListener(new FocusListener() {\r\n        @Override\r\n        public void focusGained(FocusEvent e) {\r\n        }\r\n        @Override\r\n        public void focusLost(FocusEvent e) {\r\n            if (keywordTextField.getText().isEmpty()) {\r\n                clearSearchBox();\r\n            }\r\n        }\r\n    });\r\n    keywordTextField.setComponentPopupMenu(rightClickMenu);\r\n    ActionListener actList = (ActionEvent e) -> {\r\n        JMenuItem jmi = (JMenuItem) e.getSource();\r\n        if (jmi.equals(cutMenuItem)) {\r\n            keywordTextField.cut();\r\n        } else if (jmi.equals(copyMenuItem)) {\r\n            keywordTextField.copy();\r\n        } else if (jmi.equals(pasteMenuItem)) {\r\n            keywordTextField.paste();\r\n        } else if (jmi.equals(selectAllMenuItem)) {\r\n            keywordTextField.selectAll();\r\n        }\r\n    };\r\n    ingestRunning = IngestManager.getInstance().isIngestRunning();\r\n    updateIngestIndexLabel();\r\n    jSaveSearchResults.setSelected(true);\r\n    IngestManager.getInstance().addIngestJobEventListener(new PropertyChangeListener() {\r\n        @Override\r\n        public void propertyChange(PropertyChangeEvent evt) {\r\n            Object source = evt.getSource();\r\n            if (source instanceof String && ((String) source).equals(\"LOCAL\")) {\r\n                EventQueue.invokeLater(() -> {\r\n                    ingestRunning = IngestManager.getInstance().isIngestRunning();\r\n                    updateIngestIndexLabel();\r\n                });\r\n            }\r\n        }\r\n    });\r\n    cutMenuItem.addActionListener(actList);\r\n    copyMenuItem.addActionListener(actList);\r\n    pasteMenuItem.addActionListener(actList);\r\n    selectAllMenuItem.addActionListener(actList);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.DropdownSingleTermSearchPanel.customizeComponents",
	"Comment": "does additional initialization of the gui components created by theinitcomponents method.",
	"Method": "void customizeComponents(){\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.DropdownSingleTermSearchPanel.customizeComponents",
	"Comment": "does additional initialization of the gui components created by theinitcomponents method.",
	"Method": "void customizeComponents(){\r\n    if (keywordTextField.getText().isEmpty()) {\r\n        clearSearchBox();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.DropdownSingleTermSearchPanel.customizeComponents",
	"Comment": "does additional initialization of the gui components created by theinitcomponents method.",
	"Method": "void customizeComponents(){\r\n    Object source = evt.getSource();\r\n    if (source instanceof String && ((String) source).equals(\"LOCAL\")) {\r\n        EventQueue.invokeLater(() -> {\r\n            ingestRunning = IngestManager.getInstance().isIngestRunning();\r\n            updateIngestIndexLabel();\r\n        });\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.FileUtil.hasReadWriteAccess",
	"Comment": "test if the current user has read and write access to the dirpath.",
	"Method": "boolean hasReadWriteAccess(Path dirPath){\r\n    Path p = null;\r\n    try {\r\n        p = Files.createTempFile(dirPath, TEMP_FILE_NAME, TEMP_FILE_EXT);\r\n        return (p.toFile().canRead() && p.toFile().canWrite());\r\n    } catch (IOException ex) {\r\n        return false;\r\n    } finally {\r\n        if (p != null) {\r\n            try {\r\n                p.toFile().delete();\r\n            } catch (Exception ignored) {\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJobNodeData.getNumberOfCrashes",
	"Comment": "gets the number of times the job has crashed during processing.",
	"Method": "int getNumberOfCrashes(){\r\n    return this.numberOfCrashes;\r\n}"
}, {
	"Path": "com.aliyun.oss.ClientConfiguration.setConnectionRequestTimeout",
	"Comment": "sets the timeout in millisecond for retrieving an available connectionfrom the connection manager.",
	"Method": "void setConnectionRequestTimeout(int connectionRequestTimeout){\r\n    this.connectionRequestTimeout = connectionRequestTimeout;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.PerCaseTimelineProperties.setIngestRunning",
	"Comment": "record whether ingest was running during the last time the database wasupdated",
	"Method": "void setIngestRunning(Boolean ingestRunning){\r\n    setProperty(WAS_INGEST_RUNNING_KEY, ingestRunning.toString());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.runIngestModuleWizard.IngestModulesConfigWizardPanel.getIngestJobSettings",
	"Comment": "gets the ingest job settings associated with this wizard panel.",
	"Method": "IngestJobSettings getIngestJobSettings(){\r\n    return ingestJobSettingsPanel.getSettings();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.AutopsyOptionsPanel.getDefaultsFromFileContents",
	"Comment": "find the string in the list of strings which contains the default optionssettings and split it into an array of strings containing one element foreach setting specified.",
	"Method": "String[] getDefaultsFromFileContents(List<String> list){\r\n    Optional<String> defaultSettings = list.stream().filter(line -> line.startsWith(\"default_options=\")).findFirst();\r\n    if (defaultSettings.isPresent()) {\r\n        return defaultSettings.get().replace(\"default_options=\", \"\").replaceAll(\"\\\"\", \"\").split(\" \");\r\n    }\r\n    return new String[] {};\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestPipelinesConfiguration.readPipelinesConfigurationFile",
	"Comment": "attempts to read the ingest pipeline configuration data from an xml file.",
	"Method": "void readPipelinesConfigurationFile(){\r\n    try {\r\n        PlatformUtil.extractResourceToUserConfigDir(IngestPipelinesConfiguration.class, PIPELINES_CONFIG_FILE, false);\r\n        Path configFilePath = Paths.get(PlatformUtil.getUserConfigDirectory(), PIPELINES_CONFIG_FILE);\r\n        Document doc = XMLUtil.loadDoc(IngestPipelinesConfiguration.class, configFilePath.toAbsolutePath().toString());\r\n        if (doc == null) {\r\n            return;\r\n        }\r\n        Element rootElement = doc.getDocumentElement();\r\n        if (null == rootElement) {\r\n            logger.log(Level.SEVERE, \"Invalid pipelines config file\");\r\n            return;\r\n        }\r\n        NodeList pipelineElements = rootElement.getElementsByTagName(IngestPipelinesConfiguration.PIPELINE_ELEM);\r\n        int numPipelines = pipelineElements.getLength();\r\n        if (numPipelines != IngestPipelinesConfiguration.NUMBER_OF_PIPELINE_DEFINITIONS) {\r\n            logger.log(Level.SEVERE, \"Invalid pipelines config file\");\r\n            return;\r\n        }\r\n        List<String> pipelineConfig = null;\r\n        for (int pipelineNum = 0; pipelineNum < numPipelines; ++pipelineNum) {\r\n            Element pipelineElement = (Element) pipelineElements.item(pipelineNum);\r\n            String pipelineTypeAttr = pipelineElement.getAttribute(PIPELINE_TYPE_ATTR);\r\n            if (null != pipelineTypeAttr) {\r\n                switch(pipelineTypeAttr) {\r\n                    case STAGE_ONE_DATA_SOURCE_INGEST_PIPELINE_ELEM:\r\n                        pipelineConfig = this.stageOneDataSourceIngestPipelineConfig;\r\n                        break;\r\n                    case FILE_INGEST_PIPELINE_ELEM:\r\n                        pipelineConfig = this.fileIngestPipelineConfig;\r\n                        break;\r\n                    case STAGE_TWO_DATA_SOURCE_INGEST_PIPELINE_ELEM:\r\n                        pipelineConfig = this.stageTwoDataSourceIngestPipelineConfig;\r\n                        break;\r\n                    default:\r\n                        logger.log(Level.SEVERE, \"Invalid pipelines config file\");\r\n                        return;\r\n                }\r\n            }\r\n            if (pipelineConfig != null) {\r\n                NodeList modulesElems = pipelineElement.getElementsByTagName(INGEST_MODULE_ELEM);\r\n                int numModules = modulesElems.getLength();\r\n                for (int moduleNum = 0; moduleNum < numModules; ++moduleNum) {\r\n                    Element moduleElement = (Element) modulesElems.item(moduleNum);\r\n                    String className = moduleElement.getTextContent();\r\n                    if (null != className && !className.isEmpty()) {\r\n                        pipelineConfig.add(className);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } catch (IOException ex) {\r\n        logger.log(Level.SEVERE, \"Error copying default pipeline configuration to user dir\", ex);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.DataResultViewerTable.addTreeExpansionListener",
	"Comment": "adds a tree expansion listener to the outlineview of this tabular resultsviewer.",
	"Method": "void addTreeExpansionListener(TreeExpansionListener listener){\r\n    outlineView.addTreeExpansionListener(listener);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.RegexQuery.addAttributeIfNotAlreadyCaptured",
	"Comment": "creates an attribute of the the given type to the given artifact with avalue parsed from the snippet for a credit account number hit.",
	"Method": "void addAttributeIfNotAlreadyCaptured(Map<BlackboardAttribute.Type, BlackboardAttribute> attributeMap,ATTRIBUTE_TYPE attrType,String groupName,Matcher matcher){\r\n    BlackboardAttribute.Type type = new BlackboardAttribute.Type(attrType);\r\n    if (!attributeMap.containsKey(type)) {\r\n        String value = matcher.group(groupName);\r\n        if (attrType.equals(ATTRIBUTE_TYPE.TSK_CARD_NUMBER)) {\r\n            attributeMap.put(new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_KEYWORD), new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_KEYWORD, MODULE_NAME, value));\r\n            value = CharMatcher.anyOf(\" -\").removeFrom(value);\r\n        }\r\n        if (StringUtils.isNotBlank(value)) {\r\n            attributeMap.put(type, new BlackboardAttribute(attrType, MODULE_NAME, value));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.hashdatabase.HashDbManager.addExistingHashDatabase",
	"Comment": "adds an existing hash database to the set of hash databases used toclassify files as known or notable and saves the configuration.",
	"Method": "HashDb addExistingHashDatabase(String hashSetName,String path,boolean searchDuringIngest,boolean sendIngestMessages,HashDb.KnownFilesType knownFilesType){\r\n    HashDb hashDb = null;\r\n    hashDb = this.addExistingHashDatabaseNoSave(hashSetName, path, searchDuringIngest, sendIngestMessages, knownFilesType);\r\n    this.save();\r\n    return hashDb;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.Case.createCaseData",
	"Comment": "creates the case directory, case database, and case metadata file.",
	"Method": "void createCaseData(ProgressIndicator progressIndicator){\r\n    if (new File(metadata.getCaseDirectory()).exists() == false) {\r\n        progressIndicator.progress(Bundle.Case_progressMessage_creatingCaseDirectory());\r\n        Case.createCaseDirectory(metadata.getCaseDirectory(), metadata.getCaseType());\r\n    }\r\n    progressIndicator.progress(Bundle.Case_progressMessage_creatingCaseDatabase());\r\n    try {\r\n        if (CaseType.SINGLE_USER_CASE == metadata.getCaseType()) {\r\n            caseDb = SleuthkitCase.newCase(Paths.get(metadata.getCaseDirectory(), SINGLE_USER_CASE_DB_NAME).toString());\r\n            metadata.setCaseDatabaseName(SINGLE_USER_CASE_DB_NAME);\r\n        } else {\r\n            caseDb = SleuthkitCase.newCase(metadata.getCaseDisplayName(), UserPreferences.getDatabaseConnectionInfo(), metadata.getCaseDirectory());\r\n            metadata.setCaseDatabaseName(caseDb.getDatabaseName());\r\n        }\r\n    } catch (TskCoreException ex) {\r\n        throw new CaseActionException(Bundle.Case_exceptionMessage_couldNotCreateCaseDatabase(ex.getLocalizedMessage()), ex);\r\n    } catch (UserPreferencesException ex) {\r\n        throw new CaseActionException(NbBundle.getMessage(Case.class, \"Case.databaseConnectionInfo.error.msg\"), ex);\r\n    } catch (CaseMetadataException ex) {\r\n        throw new CaseActionException(Bundle.Case_exceptionMessage_couldNotCreateMetadataFile(), ex);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.AbstractSqlEamDb.newCorrelationTypeKnownId",
	"Comment": "helper function which adds a new eamartifact.type to the db.",
	"Method": "int newCorrelationTypeKnownId(CorrelationAttributeInstance.Type newType){\r\n    Connection conn = connect();\r\n    PreparedStatement preparedStatement = null;\r\n    PreparedStatement preparedStatementQuery = null;\r\n    ResultSet resultSet = null;\r\n    int typeId = 0;\r\n    String insertSql;\r\n    String querySql;\r\n    insertSql = \"INSERT INTO correlation_types(id, display_name, db_table_name, supported, enabled) VALUES (?, ?, ?, ?, ?) \" + getConflictClause();\r\n    querySql = \"SELECT * FROM correlation_types WHERE display_name=? AND db_table_name=?\";\r\n    try {\r\n        preparedStatement = conn.prepareStatement(insertSql);\r\n        preparedStatement.setInt(1, newType.getId());\r\n        preparedStatement.setString(2, newType.getDisplayName());\r\n        preparedStatement.setString(3, newType.getDbTableName());\r\n        preparedStatement.setInt(4, newType.isSupported() ? 1 : 0);\r\n        preparedStatement.setInt(5, newType.isEnabled() ? 1 : 0);\r\n        preparedStatement.executeUpdate();\r\n        preparedStatementQuery = conn.prepareStatement(querySql);\r\n        preparedStatementQuery.setString(1, newType.getDisplayName());\r\n        preparedStatementQuery.setString(2, newType.getDbTableName());\r\n        resultSet = preparedStatementQuery.executeQuery();\r\n        if (resultSet.next()) {\r\n            CorrelationAttributeInstance.Type correlationType = getCorrelationTypeFromResultSet(resultSet);\r\n            typeId = correlationType.getId();\r\n        }\r\n    } catch (SQLException ex) {\r\n        throw new EamDbException(\"Error inserting new correlation type.\", ex);\r\n    } finally {\r\n        EamDbUtil.closeStatement(preparedStatement);\r\n        EamDbUtil.closeStatement(preparedStatementQuery);\r\n        EamDbUtil.closeResultSet(resultSet);\r\n        EamDbUtil.closeConnection(conn);\r\n    }\r\n    return typeId;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.KeywordSearchList.getListNames",
	"Comment": "get list names of all locked or unlocked loaded keyword list names",
	"Method": "List<String> getListNames(List<String> getListNames,boolean locked){\r\n    ArrayList<String> lists = new ArrayList();\r\n    for (String listName : theLists.keySet()) {\r\n        KeywordList list = theLists.get(listName);\r\n        if (locked == list.isEditable()) {\r\n            lists.add(listName);\r\n        }\r\n    }\r\n    return lists;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.services.Blackboard.getOrAddAttributeType",
	"Comment": "gets an attribute type, creating it if it does not already exist. usethis method to define custom attribute types.",
	"Method": "BlackboardAttribute.Type getOrAddAttributeType(String typeName,BlackboardAttribute.TSK_BLACKBOARD_ATTRIBUTE_VALUE_TYPE valueType,String displayName){\r\n    if (null == caseDb) {\r\n        throw new BlackboardException(\"Blackboard has been closed\");\r\n    }\r\n    try {\r\n        return caseDb.addArtifactAttributeType(typeName, valueType, displayName);\r\n    } catch (TskDataException typeExistsEx) {\r\n        try {\r\n            return caseDb.getAttributeType(typeName);\r\n        } catch (TskCoreException ex) {\r\n            throw new BlackboardException(\"Failed to get or add attribute type\", ex);\r\n        }\r\n    } catch (TskCoreException ex) {\r\n        throw new BlackboardException(\"Failed to get or add attribute type\", ex);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.InterCasePanel.getSelectedCorrelationType",
	"Comment": "returns the selected correlation type by getting the type from the storedhashmap.",
	"Method": "CorrelationAttributeInstance.Type getSelectedCorrelationType(){\r\n    return correlationTypeFilters.get(this.correlationTypeComboBox.getSelectedItem().toString());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJobNodeData.setPriority",
	"Comment": "sets the priority of the job. a higher number indicates a higheerpriority.",
	"Method": "void setPriority(int priority){\r\n    this.priority = priority;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.hashdatabase.HashDatabaseOptionsPanelController.cancel",
	"Comment": "this method is called when the cancel button is pressed. it applies toany of the panels that have been opened in the process of using theoptions pane.",
	"Method": "void cancel(){\r\n    getPanel().cancel();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestJobSettings.saveAs",
	"Comment": "saves these ingest job settings for use in a different execution context.some examples of execution contexts include the add data source wizard,the run ingest modules dialog, and auto ingest. different executioncontexts may have different ingest job settings.",
	"Method": "void saveAs(String executionContext){\r\n    this.executionContext = executionContext;\r\n    this.createSavedModuleSettingsFolder();\r\n    this.store();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.filetypeid.FileTypeDetector.detectAndPostToBlackboard",
	"Comment": "gets the mime type of a file, detecting it if it is not already known. ifdetection is necessary, the result is added to the case database.",
	"Method": "String detectAndPostToBlackboard(AbstractFile file){\r\n    String fileType = getMIMEType(file);\r\n    file.setMIMEType(fileType);\r\n    file.save();\r\n    return fileType;\r\n}"
}, {
	"Path": "com.aliyun.oss.internal.ResponseParsers.parseGetBucketCname",
	"Comment": "unmarshall get bucket cname response body to cname configuration.",
	"Method": "List<CnameConfiguration> parseGetBucketCname(InputStream responseBody){\r\n    try {\r\n        Element root = getXmlRootElement(responseBody);\r\n        List<CnameConfiguration> cnames = new ArrayList<CnameConfiguration>();\r\n        List<Element> cnameElements = root.getChildren(\"Cname\");\r\n        for (Element cnameElem : cnameElements) {\r\n            CnameConfiguration cname = new CnameConfiguration();\r\n            cname.setDomain(cnameElem.getChildText(\"Domain\"));\r\n            cname.setStatus(CnameConfiguration.CnameStatus.valueOf(cnameElem.getChildText(\"Status\")));\r\n            cname.setLastMofiedTime(DateUtil.parseIso8601Date(cnameElem.getChildText(\"LastModified\")));\r\n            if (cnameElem.getChildText(\"IsPurgeCdnCache\") != null) {\r\n                boolean purgeCdnCache = Boolean.valueOf(cnameElem.getChildText(\"IsPurgeCdnCache\"));\r\n                cname.setPurgeCdnCache(purgeCdnCache);\r\n            }\r\n            cnames.add(cname);\r\n        }\r\n        return cnames;\r\n    } catch (JDOMParseException e) {\r\n        throw new ResponseParseException(e.getPartialDocument() + \": \" + e.getMessage(), e);\r\n    } catch (Exception e) {\r\n        throw new ResponseParseException(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.wikipedia.page.ViewHideHandler.update",
	"Comment": "force an update of the appearance of the search bar. usually it is updated automaticallywhen the associated webview is scrolled, but this function may be used to manually refreshthe appearance of the search bar, e.g. when the webview is first shown.",
	"Method": "void update(){\r\n    if (webView == null) {\r\n        return;\r\n    }\r\n    onScrollChanged(webView.getScrollY(), webView.getScrollY(), false);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestJobContext.isJobCancelled",
	"Comment": "queries whether or not cancellation of the data source ingest part of theingest job associated with this context has been requested.",
	"Method": "boolean isJobCancelled(){\r\n    return this.dataSourceIngestIsCancelled();\r\n}"
}, {
	"Path": "com.anysoftkeyboard.utils.XmlWriter.writeAttribute",
	"Comment": "write an attribute out for the current entity. any xml characters in thevalue are escaped. currently it does not actually throw the exception,but the api is set that way for future changes.",
	"Method": "XmlWriter writeAttribute(String attr,String value){\r\n    this.mAttrs.append(\" \");\r\n    this.mAttrs.append(attr);\r\n    this.mAttrs.append(\"=\\\"\");\r\n    this.mAttrs.append(escapeXml(value));\r\n    this.mAttrs.append(\"\\\"\");\r\n    return this;\r\n}"
}, {
	"Path": "org.owntracks.android.support.Preferences.getStringWithFallback",
	"Comment": "this is a quick fix as an empty string does not return the default value",
	"Method": "String getStringWithFallback(SharedPreferences preferences,String key,int defId){\r\n    String s = preferences.getString(key, \"\");\r\n    return (\"\".equals(s)) ? getStringRessource(defId) : s;\r\n}"
}, {
	"Path": "net.ypresto.androidtranscoder.engine.OutputSurface.drawImage",
	"Comment": "draws the data from surfacetexture onto the current egl surface.",
	"Method": "void drawImage(){\r\n    mTextureRender.drawFrame(mSurfaceTexture);\r\n}"
}, {
	"Path": "com.aliyun.oss.integrationtests.RequestTimeoutTest.testConcurrentOperationsNormal",
	"Comment": "massive concurrent requests. the request completion time should be similar.",
	"Method": "void testConcurrentOperationsNormal(){\r\n    String key = \"test-concurrent-operation-normal\";\r\n    try {\r\n        ossClient.getClientConfiguration().setRequestTimeout(100 * 1000);\r\n        Thread[] threads = new Thread[100];\r\n        for (int i = 0; i < 100; i++) {\r\n            threads[i] = new OperationThread(key + i);\r\n        }\r\n        for (int i = 0; i < 100; i++) {\r\n            threads[i].start();\r\n        }\r\n        for (int i = 0; i < 100; i++) {\r\n            threads[i].join();\r\n        }\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n        Assert.fail(e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.TimeLineTopComponent.getResultViewerSummaryString",
	"Comment": "get the string that should be used as the label above the result table.it displays the time range spanned by the selected events.",
	"Method": "String getResultViewerSummaryString(){\r\n    Interval selectedTimeRange = controller.getSelectedTimeRange();\r\n    if (selectedTimeRange == null) {\r\n        return \"\";\r\n    } else {\r\n        final DateTimeFormatter zonedFormatter = TimeLineController.getZonedFormatter();\r\n        String start = selectedTimeRange.getStart().withZone(TimeLineController.getJodaTimeZone()).toString(zonedFormatter);\r\n        String end = selectedTimeRange.getEnd().withZone(TimeLineController.getJodaTimeZone()).toString(zonedFormatter);\r\n        return Bundle.TimeLineResultView_startDateToEndDate_text(start, end);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.LogicalEvidenceFilePanel.validatePanel",
	"Comment": "check if the current selection exists and is a logical evidence file andtherefore the panel is valid.",
	"Method": "boolean validatePanel(){\r\n    errorLabel.setVisible(false);\r\n    final String path = logicalEvidencePathField.getText();\r\n    if (StringUtils.isBlank(path)) {\r\n        return false;\r\n    }\r\n    try {\r\n        if (!PathValidator.isValidForMultiUserCase(path, Case.getCurrentCaseThrows().getCaseType())) {\r\n            errorLabel.setVisible(true);\r\n            errorLabel.setText(Bundle.LogicalEvidenceFilePanel_pathValidation_dataSourceOnCDriveError());\r\n            return false;\r\n        }\r\n    } catch (NoCurrentCaseException ex) {\r\n        errorLabel.setVisible(true);\r\n        errorLabel.setText(Bundle.LogicalEvidenceFilePanel_pathValidation_getOpenCase_Error());\r\n        return false;\r\n    }\r\n    if (!LocalFilesDSProcessor.getLogicalEvidenceFilter().accept(new File(path))) {\r\n        errorLabel.setVisible(true);\r\n        errorLabel.setText(Bundle.LogicalEvidenceFilePanel_validatePanel_nonL01Error_text());\r\n        return false;\r\n    }\r\n    displayName = FilenameUtils.getName(path);\r\n    return new File(path).isFile();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.healthmonitor.HealthMonitorDashboard.redisplay",
	"Comment": "delete the current dialog and create a new one. this should only becalled after enabling or disabling the health monitor.",
	"Method": "void redisplay(){\r\n    if (dialog != null) {\r\n        dialog.setVisible(false);\r\n        dialog.dispose();\r\n    }\r\n    display();\r\n}"
}, {
	"Path": "com.facebook.samples.gestures.MultiPointerGestureDetector.getCurrentX",
	"Comment": "gets the current x coordinates for the all pointersmutable array is exposed for performance reasons and is not to be modified by the callers.",
	"Method": "float[] getCurrentX(){\r\n    return mCurrentX;\r\n}"
}, {
	"Path": "com.facebook.samples.gestures.MultiPointerGestureDetector.getCurrentY",
	"Comment": "gets the current y coordinates for the all pointersmutable array is exposed for performance reasons and is not to be modified by the callers.",
	"Method": "float[] getCurrentY(){\r\n    return mCurrentY;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.healthmonitor.HealthMonitor.databaseIsInitialized",
	"Comment": "test whether the database schema has been initialized. we do this bylooking for the version number.",
	"Method": "boolean databaseIsInitialized(){\r\n    Connection conn = connect();\r\n    if (conn == null) {\r\n        throw new HealthMonitorException(\"Error getting database connection\");\r\n    }\r\n    ResultSet resultSet = null;\r\n    try (Statement statement = conn.createStatement()) {\r\n        resultSet = statement.executeQuery(\"SELECT value FROM db_info WHERE name='SCHEMA_VERSION'\");\r\n        return resultSet.next();\r\n    } catch (SQLException ex) {\r\n        return false;\r\n    } finally {\r\n        if (resultSet != null) {\r\n            try {\r\n                resultSet.close();\r\n            } catch (SQLException ex) {\r\n                logger.log(Level.SEVERE, \"Error closing result set\", ex);\r\n            }\r\n        }\r\n        try {\r\n            conn.close();\r\n        } catch (SQLException ex) {\r\n            logger.log(Level.SEVERE, \"Error closing Connection.\", ex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.aliyun.oss.internal.ResponseParsers.parseListUdfApplicationInfo",
	"Comment": "unmarshall get udf info response body to udf image info list.",
	"Method": "List<UdfApplicationInfo> parseListUdfApplicationInfo(InputStream responseBody){\r\n    try {\r\n        Element root = getXmlRootElement(responseBody);\r\n        List<UdfApplicationInfo> udfApps = new ArrayList<UdfApplicationInfo>();\r\n        if (root.getChild(\"UDFApplicationInfo\") != null) {\r\n            List<Element> udfImageElems = root.getChildren(\"UDFApplicationInfo\");\r\n            for (Element elem : udfImageElems) {\r\n                String id = elem.getChildText(\"ID\");\r\n                String name = elem.getChildText(\"Name\");\r\n                String status = elem.getChildText(\"Status\");\r\n                String region = elem.getChildText(\"Region\");\r\n                Integer imageVersion = Integer.valueOf(elem.getChildText(\"ImageVersion\"));\r\n                Integer instanceNum = Integer.valueOf(elem.getChildText(\"InstanceNum\"));\r\n                Date date = DateUtil.parseIso8601Date(elem.getChildText(\"CreationDate\"));\r\n                String instanceType = elem.getChild(\"Flavor\").getChildText(\"InstanceType\");\r\n                InstanceFlavor flavor = new InstanceFlavor(instanceType);\r\n                UdfApplicationInfo udfApp = new UdfApplicationInfo(name, id, region, status, imageVersion, instanceNum, date, flavor);\r\n                udfApps.add(udfApp);\r\n            }\r\n        }\r\n        return udfApps;\r\n    } catch (JDOMParseException e) {\r\n        throw new ResponseParseException(e.getPartialDocument() + \": \" + e.getMessage(), e);\r\n    } catch (Exception e) {\r\n        throw new ResponseParseException(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.SingleUserCaseImporter.log",
	"Comment": "log a message to the case import log in the base output folder.",
	"Method": "void log(String message){\r\n    if (writer != null) {\r\n        writer.println(String.format(\"%s %s\", simpleDateFormat.format((Date.from(Instant.now()).getTime())), message));\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.QueryResults.getResults",
	"Comment": "gets the keyword hits stored in this object for a given keyword.",
	"Method": "List<KeywordHit> getResults(Keyword keyword){\r\n    return results.get(keyword);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.optionspanel.EamDbSettingsDialog.valid",
	"Comment": "validates that the form is filled out correctly for our usage.",
	"Method": "boolean valid(){\r\n    return enableOkButton(checkFields());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.datamodel.grouping.GroupManager.getGroupKeysForCurrentGroupBy",
	"Comment": "using the current grouping paramaters set for this manager, findgroupkeys for all the groups the given file is a part of.",
	"Method": "Set<GroupKey<?>> getGroupKeysForCurrentGroupBy(DrawableFile file,Set<GroupKey<?>> getGroupKeysForCurrentGroupBy,Long fileID){\r\n    try {\r\n        DrawableFile file = getDrawableDB().getFileFromID(fileID);\r\n        return getGroupKeysForCurrentGroupBy(file);\r\n    } catch (TskCoreException | TskDataException ex) {\r\n        logger.log(Level.SEVERE, \"Failed to get group keys for file with ID \" + fileID, ex);\r\n    }\r\n    return Collections.emptySet();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.ui.AbstractTimelineChart.addSpecificLabel",
	"Comment": "add a text node to the specific label container for the decluttered axislabels.",
	"Method": "void addSpecificLabel(String labelText,double labelWidth,double labelX,boolean bold){\r\n    Text label = new Text(\" \" + labelText + \" \");\r\n    label.setTextAlignment(TextAlignment.CENTER);\r\n    label.setFont(Font.font(null, bold ? FontWeight.BOLD : FontWeight.NORMAL, 10));\r\n    label.relocate(labelX + labelWidth / 2 - label.getBoundsInLocal().getWidth() / 2, 0);\r\n    label.autosize();\r\n    if (specificLabelPane.getChildren().isEmpty()) {\r\n        specificLabelPane.getChildren().add(label);\r\n    } else {\r\n        final Node lastLabel = specificLabelPane.getChildren().get(specificLabelPane.getChildren().size() - 1);\r\n        if (false == lastLabel.getBoundsInParent().intersects(label.getBoundsInParent())) {\r\n            specificLabelPane.getChildren().add(label);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.wikipedia.readinglist.sync.ReadingListClient.setup",
	"Comment": "sets up reading list syncing on the server, and returns true if the setup was successful,or false if syncing is already set up.",
	"Method": "boolean setup(String csrfToken){\r\n    try {\r\n        ServiceFactory.getRest(wiki).setupReadingLists(csrfToken).execute();\r\n        return true;\r\n    } catch (Throwable t) {\r\n        if (isErrorType(t, \"already-set-up\")) {\r\n            return false;\r\n        }\r\n        throw t;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.ui.ViewFrame.syncViewMode",
	"Comment": "sync up the view shown in the ui to the one currently active according tothe controller. swaps out the hosted abstracttimelineview for a new oneof the correct type.",
	"Method": "void syncViewMode(){\r\n    ViewMode newViewMode = controller.getViewMode();\r\n    if (hostedView != null) {\r\n        hostedView.dispose();\r\n    }\r\n    switch(newViewMode) {\r\n        case LIST:\r\n            hostedView = new ListViewPane(controller);\r\n            break;\r\n        case COUNTS:\r\n            hostedView = new CountsViewPane(controller);\r\n            break;\r\n        case DETAIL:\r\n            DetailViewPane detailViewPane = new DetailViewPane(controller);\r\n            detailViewPane.setHighLightedEvents(eventsTree.getSelectedEvents());\r\n            eventsTree.setDetailViewPane(detailViewPane);\r\n            hostedView = detailViewPane;\r\n            break;\r\n        default:\r\n            throw new IllegalArgumentException(\"Unknown ViewMode: \" + newViewMode.toString());\r\n    }\r\n    controller.registerForEvents(hostedView);\r\n    viewModeToggleGroup.setValue(newViewMode);\r\n    setViewSettingsControls(hostedView.getSettingsControls());\r\n    setTimeNavigationControls(hostedView.hasCustomTimeNavigationControls() ? hostedView.getTimeNavigationControls() : defaultTimeNavigationNodes);\r\n    ActionUtils.configureButton(new Refresh(), refreshButton);\r\n    hostedView.refresh();\r\n    notificationPane.setContent(hostedView);\r\n    hostedView.hasVisibleEventsProperty().addListener(hasEvents -> {\r\n        notificationPane.setContent(hostedView.hasVisibleEvents() ? hostedView : new StackPane(hostedView, NO_EVENTS_BACKGROUND, new NoEventsDialog(() -> notificationPane.setContent(hostedView))));\r\n    });\r\n}"
}, {
	"Path": "com.google.example.games.catt2.SnapshotCoordinator.waitForClosed",
	"Comment": "returns a task that will complete when given file is closed.returns immediately if thefile is not open.",
	"Method": "Task<Result> waitForClosed(String filename){\r\n    final TaskCompletionSource<Result> taskCompletionSource = new TaskCompletionSource();\r\n    final CountDownLatch latch;\r\n    synchronized (this) {\r\n        latch = opened.get(filename);\r\n    }\r\n    if (latch == null) {\r\n        taskCompletionSource.setResult(null);\r\n        return taskCompletionSource.getTask();\r\n    }\r\n    new AsyncTask<Void, Void, Void>() {\r\n        @Override\r\n        protected Void doInBackground(Void... voids) {\r\n            Result result = new CountDownTask(latch).await();\r\n            taskCompletionSource.setResult(result);\r\n            return null;\r\n        }\r\n    }.execute();\r\n    return taskCompletionSource.getTask();\r\n}"
}, {
	"Path": "com.google.example.games.catt2.SnapshotCoordinator.waitForClosed",
	"Comment": "returns a task that will complete when given file is closed.returns immediately if thefile is not open.",
	"Method": "Task<Result> waitForClosed(String filename){\r\n    Result result = new CountDownTask(latch).await();\r\n    taskCompletionSource.setResult(result);\r\n    return null;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.datamodel.ContentNodeSelectionInfo.matches",
	"Comment": "determines whether or not a given node satisfies the stored nodeselection criteria.",
	"Method": "boolean matches(Node candidateNode){\r\n    Content content = candidateNode.getLookup().lookup(Content.class);\r\n    return content.getId() == contentId;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.directorytree.ExternalViewerGlobalSettingsPanel.updateRulesListModel",
	"Comment": "sets the list model for the rules list component, sorted by the mimetype or extension alphabetically.",
	"Method": "void updateRulesListModel(){\r\n    rulesListModel.clear();\r\n    Collections.sort(rules);\r\n    for (ExternalViewerRule rule : rules) {\r\n        rulesListModel.addElement(rule);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.FileExportSettings.setRulesEvaluatedFlagFileName",
	"Comment": "sets the name of the file written to indicate file export rule evaluationis completed.",
	"Method": "void setRulesEvaluatedFlagFileName(String fileName){\r\n    this.rulesEvaluatedFlagFileName = fileName;\r\n}"
}, {
	"Path": "com.fernandocejas.arrow.strings.Joiner.join",
	"Comment": "returns a string containing the string representation of each argument, using the previouslyconfigured separator between each.",
	"Method": "String join(Iterable<?> parts,String join,Iterator<?> parts,String join,Object[] parts,String join,Object first,Object second,Object rest){\r\n    return join(iterable(first, second, rest));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.filetypeid.AddFileTypeSignaturePanel.setComponentValues",
	"Comment": "sets the values for the components based on the signature being edited.",
	"Method": "void setComponentValues(Signature toEdit){\r\n    if (toEdit.isRelativeToStart()) {\r\n        this.offsetRelativeToComboBox.setSelectedIndex(0);\r\n    } else {\r\n        this.offsetRelativeToComboBox.setSelectedIndex(1);\r\n    }\r\n    this.offsetTextField.setText(toEdit.getOffset() + \"\");\r\n    if (Signature.Type.RAW == toEdit.getType()) {\r\n        this.signatureTypeComboBox.setSelectedIndex(0);\r\n        this.signatureTextField.setText(DatatypeConverter.printHexBinary(toEdit.getSignatureBytes()));\r\n    } else {\r\n        this.signatureTypeComboBox.setSelectedIndex(1);\r\n        try {\r\n            this.signatureTextField.setText(new String(toEdit.getSignatureBytes(), \"UTF-8\"));\r\n        } catch (UnsupportedEncodingException ex) {\r\n            JOptionPane.showMessageDialog(this, ex.getLocalizedMessage(), Bundle.AddFileTypeSignaturePanel_signatureStringFail_text(), JOptionPane.ERROR_MESSAGE);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilessearch.IntraCaseTestUtils.mapFileInstancesToDataSources",
	"Comment": "create a convenience lookup table mapping file instance object ids to thedata source they appear in.",
	"Method": "Map<Long, String> mapFileInstancesToDataSources(CommonAttributeSearchResults metadata){\r\n    Map<Long, String> instanceIdToDataSource = new HashMap();\r\n    try {\r\n        for (Map.Entry<Integer, CommonAttributeValueList> entry : metadata.getMetadata().entrySet()) {\r\n            entry.getValue().displayDelayedMetadata();\r\n            for (CommonAttributeValue md : entry.getValue().getMetadataList()) {\r\n                for (AbstractCommonAttributeInstance fim : md.getInstances()) {\r\n                    instanceIdToDataSource.put(fim.getAbstractFileObjectId(), fim.getDataSource());\r\n                }\r\n            }\r\n        }\r\n        return instanceIdToDataSource;\r\n    } catch (EamDbException ex) {\r\n        Exceptions.printStackTrace(ex);\r\n        Assert.fail(ex.getMessage());\r\n        return instanceIdToDataSource;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.directorytree.DataResultFilterNode.getActions",
	"Comment": "right click action for the nodes that we want to pass to the directorytable and the output view.",
	"Method": "Action[] getActions(boolean popup){\r\n    List<Action> actions = new ArrayList();\r\n    final DisplayableItemNode originalNode = (DisplayableItemNode) this.getOriginal();\r\n    List<Action> accept = originalNode.accept(getActionsDIV);\r\n    if (accept != null) {\r\n        actions.addAll(accept);\r\n    }\r\n    return actions.toArray(new Action[actions.size()]);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestTasksScheduler.countTasksForJob",
	"Comment": "counts the number of ingest tasks in a tasks collection for a given job.",
	"Method": "int countTasksForJob(Collection<? extends IngestTask> queue,long jobId){\r\n    int count = 0;\r\n    for (IngestTask task : queue) {\r\n        if (task.getIngestJob().getId() == jobId) {\r\n            count++;\r\n        }\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "com.anysoftkeyboard.keyboards.Keyboard.getNearestKeysIndices",
	"Comment": "returns the indices of the keys that are closest to the given point.",
	"Method": "int[] getNearestKeysIndices(int x,int y){\r\n    if (mGridNeighbors == null)\r\n        computeNearestNeighbors();\r\n    if (x >= 0 && x < getMinWidth() && y >= 0 && y < getHeight()) {\r\n        int index = (y / mCellHeight) * GRID_WIDTH + (x / mCellWidth);\r\n        if (index < GRID_SIZE) {\r\n            return mGridNeighbors[index];\r\n        }\r\n    }\r\n    return new int[0];\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.DataContentPanel.setupTabs",
	"Comment": "resets the tabs based on the selected node. if the selected node is nullor not supported, disable that tab as well.",
	"Method": "void setupTabs(Node selectedNode){\r\n    if (listeningToTabbedPane == false) {\r\n        jTabbedPane1.addChangeListener(this);\r\n        listeningToTabbedPane = true;\r\n    }\r\n    int currTabIndex = jTabbedPane1.getSelectedIndex();\r\n    int totalTabs = jTabbedPane1.getTabCount();\r\n    int maxPreferred = 0;\r\n    int preferredViewerIndex = 0;\r\n    for (int i = 0; i < totalTabs; ++i) {\r\n        UpdateWrapper dcv = viewers.get(i);\r\n        dcv.resetComponent();\r\n        if ((selectedNode == null) || (dcv.isSupported(selectedNode) == false)) {\r\n            jTabbedPane1.setEnabledAt(i, false);\r\n        } else {\r\n            jTabbedPane1.setEnabledAt(i, true);\r\n            int currentPreferred = dcv.isPreferred(selectedNode);\r\n            if (currentPreferred > maxPreferred) {\r\n                preferredViewerIndex = i;\r\n                maxPreferred = currentPreferred;\r\n            }\r\n        }\r\n    }\r\n    int tabIndex = UserPreferences.keepPreferredContentViewer() ? currTabIndex : preferredViewerIndex;\r\n    UpdateWrapper dcv = viewers.get(tabIndex);\r\n    if (jTabbedPane1.isEnabledAt(tabIndex) == false) {\r\n        dcv.resetComponent();\r\n    } else {\r\n        dcv.setNode(selectedNode);\r\n    }\r\n    jTabbedPane1.setSelectedIndex(tabIndex);\r\n    jTabbedPane1.getSelectedComponent().repaint();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.filetypeid.FileTypeDetector.getUserDefinedTypes",
	"Comment": "gets the names of the custom file types defined by the user or byautopsy.",
	"Method": "List<String> getUserDefinedTypes(){\r\n    List<String> customFileTypes = new ArrayList();\r\n    userDefinedFileTypes.forEach((fileType) -> {\r\n        customFileTypes.add(fileType.getMimeType());\r\n    });\r\n    autopsyDefinedFileTypes.forEach((fileType) -> {\r\n        customFileTypes.add(fileType.getMimeType());\r\n    });\r\n    return customFileTypes;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.Case.getModuleDirectory",
	"Comment": "gets the full path to the module output directory for this case, creatingit if it does not exist.",
	"Method": "String getModuleDirectory(){\r\n    return getOrCreateSubdirectory(MODULE_FOLDER);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.SqliteEamDb.releaseSharedLock",
	"Comment": "release the lock that provides shared access to the database. this methodshould always be called in the finally block of a try block in which thelock was acquired.",
	"Method": "void releaseSharedLock(){\r\n    rwLock.readLock().unlock();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.contentviewer.DataContentViewerOtherCasesTableModel.mapNodeInstanceData",
	"Comment": "map a column id to the value in that cell for node instance data.",
	"Method": "Object mapNodeInstanceData(OtherOccurrenceNodeInstanceData nodeData,TableColumns columnId){\r\n    String value = Bundle.DataContentViewerOtherCasesTableModel_noData();\r\n    switch(columnId) {\r\n        case CASE_NAME:\r\n            if (null != nodeData.getCaseName()) {\r\n                value = nodeData.getCaseName();\r\n            }\r\n            break;\r\n        case DEVICE:\r\n            if (null != nodeData.getDeviceID()) {\r\n                value = nodeData.getDeviceID();\r\n            }\r\n            break;\r\n        case DATA_SOURCE:\r\n            if (null != nodeData.getDataSourceName()) {\r\n                value = nodeData.getDataSourceName();\r\n            }\r\n            break;\r\n        case FILE_PATH:\r\n            value = nodeData.getFilePath();\r\n            break;\r\n        case ATTRIBUTE:\r\n            value = nodeData.getType();\r\n            break;\r\n        case VALUE:\r\n            value = nodeData.getValue();\r\n            break;\r\n        case KNOWN:\r\n            value = nodeData.getKnown().getName();\r\n            break;\r\n        case COMMENT:\r\n            value = nodeData.getComment();\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.StringExtract.isExtractionSupported",
	"Comment": "check if extraction of the script is supported by the utility",
	"Method": "boolean isExtractionSupported(SCRIPT script){\r\n    return SUPPORTED_SCRIPTS.contains(script);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.embeddedfileextractor.SevenZipExtractor.isSevenZipExtractionSupported",
	"Comment": "checks whether extraction is supported for a file, based on mime type.",
	"Method": "boolean isSevenZipExtractionSupported(AbstractFile file){\r\n    String fileMimeType = fileTypeDetector.getMIMEType(file);\r\n    for (SupportedArchiveExtractionFormats mimeType : SupportedArchiveExtractionFormats.values()) {\r\n        if (mimeType.toString().equals(fileMimeType)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.events.AutopsyEventPublisher.closeRemoteEventChannel",
	"Comment": "closes the event channel used for publishing events to and receivingevents from other autopsy nodes.",
	"Method": "void closeRemoteEventChannel(){\r\n    stopRemotePublisher();\r\n    currentChannelName = null;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.LogicalEvidenceFilePanel.getFileSetName",
	"Comment": "get the name of the logical evidence file which was selected.",
	"Method": "String getFileSetName(){\r\n    return displayName;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestServices.getCurrentSleuthkitCaseDb",
	"Comment": "gets the current sleuthkit case. the sleuthkit case is the case database.",
	"Method": "SleuthkitCase getCurrentSleuthkitCaseDb(){\r\n    return Case.getCurrentCase().getSleuthkitCase();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.DropdownSingleTermSearchPanel.keywordTextFieldActionPerformed",
	"Comment": "action performed by the action listener for the keyword text field.",
	"Method": "void keywordTextFieldActionPerformed(java.awt.event.ActionEvent evt){\r\n    try {\r\n        search(jSaveSearchResults.isSelected());\r\n    } catch (Exception e) {\r\n        LOGGER.log(Level.SEVERE, \"Error performing ad hoc single keyword search\", e);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestControlPanel.bnCancelJobActionPerformed",
	"Comment": "handles a click on the cancel auto ingest job button. cancels theselected job.",
	"Method": "void bnCancelJobActionPerformed(java.awt.event.ActionEvent evt){\r\n    Object[] options = { org.openide.util.NbBundle.getMessage(AutoIngestControlPanel.class, \"ConfirmationDialog.CancelJob\"), org.openide.util.NbBundle.getMessage(AutoIngestControlPanel.class, \"ConfirmationDialog.DoNotCancelJob\") };\r\n    int reply = JOptionPane.showOptionDialog(this, NbBundle.getMessage(AutoIngestControlPanel.class, \"ConfirmationDialog.CancelJobAreYouSure\"), NbBundle.getMessage(AutoIngestControlPanel.class, \"ConfirmationDialog.ConfirmCancellationHeader\"), JOptionPane.DEFAULT_OPTION, JOptionPane.WARNING_MESSAGE, null, options, options[1]);\r\n    if (reply == 0) {\r\n        this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\r\n        manager.cancelCurrentJob();\r\n        refreshTables();\r\n        this.setCursor(Cursor.getDefaultCursor());\r\n    }\r\n}"
}, {
	"Path": "org.wikipedia.descriptions.DescriptionEditClient.request",
	"Comment": "submit a new value for the wikidata description associated with the given wikipedia page.",
	"Method": "Call<MwPostResponse> request(WikiSite wiki,PageTitle pageTitle,String description,String editToken,Callback cb,Call<MwPostResponse> request,Service service,PageTitle pageTitle,String description,String editToken,boolean loggedIn,Callback cb){\r\n    Call<MwPostResponse> call = service.postDescriptionEdit(pageTitle.getWikiSite().languageCode(), pageTitle.getWikiSite().languageCode(), pageTitle.getWikiSite().dbName(), pageTitle.getPrefixedText(), description, editToken, loggedIn ? \"user\" : null);\r\n    call.enqueue(new retrofit2.Callback<MwPostResponse>() {\r\n        @Override\r\n        public void onResponse(@NonNull Call<MwPostResponse> call, @NonNull Response<MwPostResponse> response) {\r\n            final MwPostResponse body = response.body();\r\n            if (body.getSuccessVal() > 0) {\r\n                cb.success(call);\r\n            } else {\r\n                cb.failure(call, RetrofitException.unexpectedError(new RuntimeException(\"Received unrecognized description edit response\")));\r\n            }\r\n        }\r\n        @Override\r\n        public void onFailure(@NonNull Call<MwPostResponse> call, @NonNull Throwable t) {\r\n            if (call.isCanceled()) {\r\n                return;\r\n            }\r\n            if (t instanceof MwException) {\r\n                handleError(call, (MwException) t, cb);\r\n            } else {\r\n                cb.failure(call, t);\r\n            }\r\n        }\r\n    });\r\n    return call;\r\n}"
}, {
	"Path": "org.wikipedia.descriptions.DescriptionEditClient.request",
	"Comment": "submit a new value for the wikidata description associated with the given wikipedia page.",
	"Method": "Call<MwPostResponse> request(WikiSite wiki,PageTitle pageTitle,String description,String editToken,Callback cb,Call<MwPostResponse> request,Service service,PageTitle pageTitle,String description,String editToken,boolean loggedIn,Callback cb){\r\n    final MwPostResponse body = response.body();\r\n    if (body.getSuccessVal() > 0) {\r\n        cb.success(call);\r\n    } else {\r\n        cb.failure(call, RetrofitException.unexpectedError(new RuntimeException(\"Received unrecognized description edit response\")));\r\n    }\r\n}"
}, {
	"Path": "org.wikipedia.descriptions.DescriptionEditClient.request",
	"Comment": "submit a new value for the wikidata description associated with the given wikipedia page.",
	"Method": "Call<MwPostResponse> request(WikiSite wiki,PageTitle pageTitle,String description,String editToken,Callback cb,Call<MwPostResponse> request,Service service,PageTitle pageTitle,String description,String editToken,boolean loggedIn,Callback cb){\r\n    if (call.isCanceled()) {\r\n        return;\r\n    }\r\n    if (t instanceof MwException) {\r\n        handleError(call, (MwException) t, cb);\r\n    } else {\r\n        cb.failure(call, t);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.embeddedfileextractor.MSOfficeEmbeddedContentExtractor.isContentExtractionSupported",
	"Comment": "this method returns true if the file format is currently supported. elseit returns false. performs only apache tika based detection.",
	"Method": "boolean isContentExtractionSupported(AbstractFile abstractFile){\r\n    String abstractFileMimeType = fileTypeDetector.getMIMEType(abstractFile);\r\n    for (SupportedExtractionFormats s : SupportedExtractionFormats.values()) {\r\n        if (s.toString().equals(abstractFileMimeType)) {\r\n            abstractFileExtractionFormat = s;\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.klinker.android.peekview.PeekView.setDistanceFromTop",
	"Comment": "sets how far away from the top of the screen the view should be displayed.distance should be the value in px.",
	"Method": "void setDistanceFromTop(int distance){\r\n    this.distanceFromTop = options.fullScreenPeek() ? 0 : distance;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.directorytree.DirectoryTreeTopComponent.resetHistory",
	"Comment": "resets the back and forward list, and also disable the back and forwardbuttons.",
	"Method": "void resetHistory(){\r\n    backList.clear();\r\n    forwardList.clear();\r\n    backButton.setEnabled(false);\r\n    forwardButton.setEnabled(false);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.core.UserPreferences.getIsTimeOutEnabled",
	"Comment": "reads persisted setting of whether process time out functionality isenabled.",
	"Method": "boolean getIsTimeOutEnabled(){\r\n    boolean enabled = preferences.getBoolean(PROCESS_TIME_OUT_ENABLED, false);\r\n    return enabled;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.CommonAttributePanel.disableIntercaseSearch",
	"Comment": "disable the option to search for common attributes in the centralrepository.",
	"Method": "void disableIntercaseSearch(){\r\n    this.intraCaseRadio.setSelected(true);\r\n    this.interCaseRadio.setEnabled(false);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.communications.PinnedAccountModel.pinAccount",
	"Comment": "pin the given accounts to the graph. pinned accounts will always be shownregardless of the filter state. furthermore, accounts with relationshipsthat pass the filters will also be shown.",
	"Method": "void pinAccount(ImmutableSet<AccountDeviceInstanceKey> accountDeviceInstances){\r\n    pinnedAccountDevices.addAll(accountDeviceInstances);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.AddImageWizardIngestConfigPanel.processThisPanelBeforeSkipped",
	"Comment": "loads the proper settings for this panel to use the previously selectedingest profile when this panel would be skipped due to a profile beingchosen.",
	"Method": "void processThisPanelBeforeSkipped(){\r\n    if (!(ModuleSettings.getConfigSetting(IngestProfileSelectionWizardPanel.getLastProfilePropertiesFile(), AddImageWizardIterator.getPropLastprofileName()) == null) && !ModuleSettings.getConfigSetting(IngestProfileSelectionWizardPanel.getLastProfilePropertiesFile(), AddImageWizardIterator.getPropLastprofileName()).isEmpty()) {\r\n        lastProfileUsed = ModuleSettings.getConfigSetting(IngestProfileSelectionWizardPanel.getLastProfilePropertiesFile(), AddImageWizardIterator.getPropLastprofileName());\r\n    }\r\n    IngestJobSettings ingestJobSettings = new IngestJobSettings(lastProfileUsed);\r\n    progressPanel.setIngestJobSettings(ingestJobSettings);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.ui.detailview.EventStripeNode.newHideAction",
	"Comment": "get a new action that hides stripes with the same description as thisone.",
	"Method": "Action newHideAction(){\r\n    return new HideDescriptionAction(getDescription(), getEvent().getDescriptionLoD(), chartLane.getParentChart());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.CaseImportPanel.validateSourceFields",
	"Comment": "show user information about status of source fields, hierarchically.",
	"Method": "void validateSourceFields(){\r\n    String caseSourceResult = \"\";\r\n    File selectedFolder = caseSourceFolderChooser.getSelectedFile();\r\n    if (selectedFolder == null || !selectedFolder.exists()) {\r\n        caseSourceResult = NbBundle.getMessage(CaseImportPanel.class, \"CaseImportPanel.BadCaseSourceFolder\");\r\n        tbCaseSource.setText(\"\");\r\n    } else {\r\n        caseSourceResult = NbBundle.getMessage(CaseImportPanel.class, \"CaseImportPanel.Blank\");\r\n        caseSourceFolderChooser.setCurrentDirectory(selectedFolder);\r\n        tbCaseSource.setText(selectedFolder.toString());\r\n    }\r\n    String caseImagesResult = \"\";\r\n    if (cbCopyImages.isSelected()) {\r\n        selectedFolder = imageSourceFolderChooser.getSelectedFile();\r\n        if (selectedFolder == null || !selectedFolder.exists()) {\r\n            caseImagesResult = NbBundle.getMessage(CaseImportPanel.class, \"CaseImportPanel.BadImageSourceFolder\");\r\n            tbImageSource.setText(\"\");\r\n        } else {\r\n            if (tbInputNotification.getText().isEmpty()) {\r\n                caseImagesResult = NbBundle.getMessage(CaseImportPanel.class, \"CaseImportPanel.Blank\");\r\n            }\r\n            imageSourceFolderChooser.setCurrentDirectory(selectedFolder);\r\n            tbImageSource.setText(selectedFolder.toString());\r\n        }\r\n    }\r\n    String result = caseSourceResult;\r\n    if (result.isEmpty()) {\r\n        result = caseImagesResult;\r\n    }\r\n    setNotificationText(NotificationLabel.INPUT, result, false);\r\n    enableStartButton();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.ProfileSettingsPanel.doProfileDialog",
	"Comment": "open a dialog for the the creation or modification of a profile.",
	"Method": "void doProfileDialog(IngestProfile selectedProfile){\r\n    final AdvancedConfigurationDialog dialog = new AdvancedConfigurationDialog(true);\r\n    this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\r\n    if (selectedProfile != null) {\r\n        panel = new ProfilePanel(selectedProfile);\r\n    } else {\r\n        panel = new ProfilePanel();\r\n    }\r\n    dialog.addApplyButtonListener((ActionEvent e) -> {\r\n        panel.store();\r\n        option = JOptionPane.OK_OPTION;\r\n        dialog.close();\r\n    });\r\n    setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));\r\n    do {\r\n        option = JOptionPane.CANCEL_OPTION;\r\n        dialog.display(panel);\r\n    } while (option == JOptionPane.OK_OPTION && !panel.isValidDefinition());\r\n    if (option == JOptionPane.OK_OPTION) {\r\n        if (this.profiles.containsKey(panel.getProfileName()) && selectedProfile == null) {\r\n            MessageNotifyUtil.Message.error(NbBundle.getMessage(this.getClass(), \"ProfileSettingsPanel.doFileSetsDialog.duplicateProfile.text\", panel.getProfileName()));\r\n            return;\r\n        }\r\n        panel.saveSettings();\r\n        load();\r\n    }\r\n}"
}, {
	"Path": "org.automon.utils.AutomonPropertiesLoader.replaceWithSystemProps",
	"Comment": "use any properties that were passed in at the command line or defined at the os",
	"Method": "void replaceWithSystemProps(Properties properties){\r\n    properties.putAll(sysProperty.getProperties());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.NewCaseVisualPanel1.setCaseParentDir",
	"Comment": "allows the the wizard panel that owns this ui panel to set the base casedirectory to a persisted vlaue.",
	"Method": "void setCaseParentDir(String caseParentDir){\r\n    caseParentDirTextField.setText(caseParentDir);\r\n    validateSettings();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.EamArtifactUtil.makeCorrelationAttributeInstanceUsingTypeValue",
	"Comment": "uses the determined type and vallue, then looks up instance details tocreate proper correlationattributeinstance.",
	"Method": "CorrelationAttributeInstance makeCorrelationAttributeInstanceUsingTypeValue(BlackboardArtifact bbArtifact,CorrelationAttributeInstance.Type correlationType,String value){\r\n    try {\r\n        Case currentCase = Case.getCurrentCaseThrows();\r\n        AbstractFile bbSourceFile = currentCase.getSleuthkitCase().getAbstractFileById(bbArtifact.getObjectID());\r\n        if (null == bbSourceFile) {\r\n            logger.log(Level.SEVERE, \"Error creating artifact instance. Abstract File was null.\");\r\n            return null;\r\n        }\r\n        CorrelationCase correlationCase = EamDb.getInstance().getCase(Case.getCurrentCaseThrows());\r\n        if (null == correlationCase) {\r\n            correlationCase = EamDb.getInstance().newCase(Case.getCurrentCaseThrows());\r\n        }\r\n        return new CorrelationAttributeInstance(correlationType, value, correlationCase, CorrelationDataSource.fromTSKDataSource(correlationCase, bbSourceFile.getDataSource()), bbSourceFile.getParentPath() + bbSourceFile.getName(), \"\", TskData.FileKnown.UNKNOWN, bbSourceFile.getId());\r\n    } catch (TskCoreException | EamDbException | CorrelationAttributeNormalizationException ex) {\r\n        logger.log(Level.SEVERE, \"Error creating artifact instance.\", ex);\r\n        return null;\r\n    } catch (NoCurrentCaseException ex) {\r\n        logger.log(Level.SEVERE, \"Case is closed.\", ex);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.hashdatabase.HashDbManager.removeHashDatabase",
	"Comment": "removes a hash database from the set of hash databases used to classifyfiles as known or notable and saves the configuration.",
	"Method": "void removeHashDatabase(HashDb hashDb){\r\n    this.removeHashDatabaseNoSave(hashDb);\r\n    this.save();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.AutopsyOptionsPanelController.applyChanges",
	"Comment": "this method is called when both the ok and apply buttons are pressed. itapplies to any of the panels that have been opened in the process ofusing the options pane.",
	"Method": "void applyChanges(){\r\n    if (changed) {\r\n        getPanel().store();\r\n        changed = false;\r\n    }\r\n}"
}, {
	"Path": "com.google.example.games.bc.MainActivity.onStop",
	"Comment": "activity is going to the background. we have to leave the current room.",
	"Method": "void onStop(){\r\n    Log.d(TAG, \"**** got onStop\");\r\n    leaveRoom();\r\n    stopKeepingScreenOn();\r\n    switchToMainScreen();\r\n    super.onStop();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.CommonAttributePanel.getNumberOfDataSourcesAvailable",
	"Comment": "get the number of data sources in the central repository if it isenabled, zero if it is not enabled.",
	"Method": "Long getNumberOfDataSourcesAvailable(){\r\n    try {\r\n        if (EamDb.isEnabled() && EamDb.getInstance() != null) {\r\n            return EamDb.getInstance().getCountUniqueDataSources();\r\n        }\r\n    } catch (EamDbException ex) {\r\n        LOGGER.log(Level.SEVERE, \"Unexpected exception while  checking for EamDB enabled.\", ex);\r\n    }\r\n    return 0L;\r\n}"
}, {
	"Path": "com.tngtech.archunit.testutils.HandlingAssertion.evaluateFieldAccesses",
	"Comment": "this way we must write explicitly violationhandler or the bound wont work correctly",
	"Method": "Set<String> evaluateFieldAccesses(EvaluationResult result){\r\n    Set<String> errorMessages = new HashSet();\r\n    final Set<ExpectedRelation> left = new HashSet(this.expectedFieldAccesses);\r\n    result.handleViolations(new ViolationHandler<JavaFieldAccess>() {\r\n        @Override\r\n        public void handle(Collection<JavaFieldAccess> violatingObjects, String message) {\r\n            errorMessages.addAll(removeExpectedAccesses(violatingObjects, left));\r\n        }\r\n    });\r\n    return union(errorMessages, errorMessagesFrom(left));\r\n}"
}, {
	"Path": "com.tngtech.archunit.testutils.HandlingAssertion.evaluateFieldAccesses",
	"Comment": "this way we must write explicitly violationhandler or the bound wont work correctly",
	"Method": "Set<String> evaluateFieldAccesses(EvaluationResult result){\r\n    errorMessages.addAll(removeExpectedAccesses(violatingObjects, left));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.services.TagNameDefinition.upgradeTagPropertiesFile",
	"Comment": "read the central repository properties file to get any knownstatusrelated tag settings that may exist in it.",
	"Method": "Set<TagNameDefinition> upgradeTagPropertiesFile(List<String> tagProperties,Set<String> standardTagsToBeCreated){\r\n    Set<TagNameDefinition> tagNames = new LinkedHashSet();\r\n    List<String> legacyNotableTags = new ArrayList();\r\n    String badTagsStr = ModuleSettings.getConfigSetting(\"CentralRepository\", \"db.badTags\");\r\n    if (badTagsStr == null || badTagsStr.isEmpty()) {\r\n        legacyNotableTags.addAll(STANDARD_NOTABLE_TAG_DISPLAY_NAMES);\r\n    } else {\r\n        legacyNotableTags.addAll(Arrays.asList(badTagsStr.split(\",\")));\r\n    }\r\n    for (String tagNameTuple : tagProperties) {\r\n        String[] tagNameAttributes = tagNameTuple.split(\",\");\r\n        standardTagsToBeCreated.remove(tagNameAttributes[0]);\r\n        if (legacyNotableTags.contains(tagNameAttributes[0])) {\r\n            tagNames.add(new TagNameDefinition(tagNameAttributes[0], tagNameAttributes[1], TagName.HTML_COLOR.valueOf(tagNameAttributes[2]), TskData.FileKnown.BAD));\r\n        } else {\r\n            tagNames.add(new // add the default value for that tag\r\n            TagNameDefinition(// add the default value for that tag\r\n            tagNameAttributes[0], // add the default value for that tag\r\n            tagNameAttributes[1], TagName.HTML_COLOR.valueOf(tagNameAttributes[2]), TskData.FileKnown.UNKNOWN));\r\n        }\r\n    }\r\n    return tagNames;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.ReportBodyFile.generateReport",
	"Comment": "generates a body file format report for use with the mac time tool.",
	"Method": "void generateReport(String baseReportDir,ReportProgressPanel progressPanel){\r\n    try {\r\n        currentCase = Case.getCurrentCaseThrows();\r\n    } catch (NoCurrentCaseException ex) {\r\n        logger.log(Level.SEVERE, \"Exception while getting open case.\", ex);\r\n        return;\r\n    }\r\n    progressPanel.setIndeterminate(false);\r\n    progressPanel.start();\r\n    progressPanel.updateStatusLabel(NbBundle.getMessage(this.getClass(), \"ReportBodyFile.progress.querying\"));\r\n    reportPath = baseReportDir + getRelativeFilePath();\r\n    skCase = currentCase.getSleuthkitCase();\r\n    try {\r\n        final // NON-NLS\r\n        String query = \"type = \" + TskData.TSK_DB_FILES_TYPE_ENUM.FS.getFileType() + \" AND name != '.' AND name != '..'\";\r\n        progressPanel.updateStatusLabel(NbBundle.getMessage(this.getClass(), \"ReportBodyFile.progress.loading\"));\r\n        List<AbstractFile> fs = skCase.findAllFilesWhere(query);\r\n        String ingestwarning = \"\";\r\n        if (IngestManager.getInstance().isIngestRunning()) {\r\n            ingestwarning = NbBundle.getMessage(this.getClass(), \"ReportBodyFile.ingestWarning.text\");\r\n        }\r\n        int size = fs.size();\r\n        progressPanel.setMaximumProgress(size / 100);\r\n        BufferedWriter out = null;\r\n        try {\r\n            out = new BufferedWriter(new FileWriter(reportPath, true));\r\n            out.write(ingestwarning);\r\n            int count = 0;\r\n            for (AbstractFile file : fs) {\r\n                if (progressPanel.getStatus() == ReportStatus.CANCELED) {\r\n                    break;\r\n                }\r\n                if (count++ == 100) {\r\n                    progressPanel.increment();\r\n                    progressPanel.updateStatusLabel(NbBundle.getMessage(this.getClass(), \"ReportBodyFile.progress.processing\", file.getName()));\r\n                    count = 0;\r\n                }\r\n                if (file.getMd5Hash() != null) {\r\n                    out.write(file.getMd5Hash());\r\n                }\r\n                out.write(\"|\");\r\n                if (file.getUniquePath() != null) {\r\n                    out.write(file.getUniquePath());\r\n                }\r\n                out.write(\"|\");\r\n                out.write(Long.toString(file.getMetaAddr()));\r\n                out.write(\"|\");\r\n                String modeString = file.getModesAsString();\r\n                if (modeString != null) {\r\n                    out.write(modeString);\r\n                }\r\n                out.write(\"|\");\r\n                out.write(Long.toString(file.getUid()));\r\n                out.write(\"|\");\r\n                out.write(Long.toString(file.getGid()));\r\n                out.write(\"|\");\r\n                out.write(Long.toString(file.getSize()));\r\n                out.write(\"|\");\r\n                out.write(Long.toString(file.getAtime()));\r\n                out.write(\"|\");\r\n                out.write(Long.toString(file.getMtime()));\r\n                out.write(\"|\");\r\n                out.write(Long.toString(file.getCtime()));\r\n                out.write(\"|\");\r\n                out.write(Long.toString(file.getCrtime()));\r\n                out.write(\"\\n\");\r\n            }\r\n        } catch (IOException ex) {\r\n            logger.log(Level.WARNING, \"Could not write the temp body file report.\", ex);\r\n        } finally {\r\n            try {\r\n                if (out != null) {\r\n                    out.flush();\r\n                    out.close();\r\n                    Case.getCurrentCaseThrows().addReport(reportPath, NbBundle.getMessage(this.getClass(), \"ReportBodyFile.generateReport.srcModuleName.text\"), \"\");\r\n                }\r\n            } catch (IOException ex) {\r\n                logger.log(Level.WARNING, \"Could not flush and close the BufferedWriter.\", ex);\r\n            } catch (TskCoreException | NoCurrentCaseException ex) {\r\n                String errorMessage = String.format(\"Error adding %s to case as a report\", reportPath);\r\n                logger.log(Level.SEVERE, errorMessage, ex);\r\n            }\r\n        }\r\n        progressPanel.complete(ReportStatus.COMPLETE);\r\n    } catch (TskCoreException ex) {\r\n        logger.log(Level.WARNING, \"Failed to get the unique path.\", ex);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.FileExportSettings.setExportCompletedFlagFileName",
	"Comment": "sets the name of the file written to indicate file export is completed.",
	"Method": "void setExportCompletedFlagFileName(String fileName){\r\n    this.exportCompletedFlagFileName = fileName;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.InstanceCountNode.createChildren",
	"Comment": "creates the children of this node. by doing this here instead of in theconstructor, lazy creation of the children is made possible.",
	"Method": "void createChildren(){\r\n    attributeValues.displayDelayedMetadata();\r\n    setChildren(Children.create(new CommonAttributeValueNodeFactory(attributeValues.getMetadataList()), true));\r\n}"
}, {
	"Path": "com.aliyun.oss.model.UploadPartCopyRequest.setPartNumber",
	"Comment": "sets the part number. for every part uploading, it has a part numberwhich is in 1 to 10000 range. given the upload id, the part numberidentified the part and its position in the target file. if uploading thepart with an existing part number, the existing part with the part numberwould be overwritten.",
	"Method": "void setPartNumber(int partNumber){\r\n    this.partNumber = partNumber;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestControlPanel.bnRefreshActionPerformed",
	"Comment": "handles a click on the refresh button. requests an immediate scan of theinput folders for new jobs and queues a refresh of all three of the jobstables.",
	"Method": "void bnRefreshActionPerformed(java.awt.event.ActionEvent evt){\r\n    this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\r\n    manager.scanInputDirsAndWait();\r\n    refreshTables();\r\n    this.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));\r\n}"
}, {
	"Path": "model.Complex.conjugate",
	"Comment": "return a new complex object whose value is the conjugate of this",
	"Method": "Complex conjugate(){\r\n    return new Complex(re, -im);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.actions.NextUnseenGroup.updateButton",
	"Comment": "update button based on currently displayed group and queues.",
	"Method": "void updateButton(){\r\n    isLoading = false;\r\n    int unSeenSize = unSeenGroups.size();\r\n    if (unSeenSize < 1) {\r\n        Platform.runLater(() -> {\r\n            setDisabled(true);\r\n            setText(ALL_GROUPS_SEEN);\r\n            setGraphic(null);\r\n        });\r\n    } else {\r\n        DrawableGroup groupOnList = unSeenGroups.get(0);\r\n        DrawableGroup groupInView = Optional.ofNullable(controller.getViewState()).flatMap(GroupViewState::getGroup).orElse(null);\r\n        if (unSeenSize == 1 & groupOnList.equals(groupInView)) {\r\n            Platform.runLater(() -> {\r\n                setDisabled(true);\r\n                setText(MARK_GROUP_SEEN);\r\n                setGraphic(new ImageView(END_IMAGE));\r\n            });\r\n        } else {\r\n            Platform.runLater(() -> {\r\n                setDisabled(false);\r\n                setText(NEXT_UNSEEN_GROUP);\r\n                setGraphic(new ImageView(ADVANCE_IMAGE));\r\n            });\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestControlPanel.bnShowCaseLogActionPerformed",
	"Comment": "handles a click on the show log button. displays the auto ingest job logfor a case in notepad.",
	"Method": "void bnShowCaseLogActionPerformed(java.awt.event.ActionEvent evt){\r\n    try {\r\n        int selectedRow = completedTable.convertRowIndexToModel(completedTable.getSelectedRow());\r\n        if (selectedRow != -1) {\r\n            Path caseDirectoryPath = (Path) completedTable.getModel().getValueAt(selectedRow, JobsTableModelColumns.CASE_DIRECTORY_PATH.ordinal());\r\n            if (null != caseDirectoryPath) {\r\n                Path pathToLog = AutoIngestJobLogger.getLogPath(caseDirectoryPath);\r\n                if (pathToLog.toFile().exists()) {\r\n                    Desktop.getDesktop().edit(pathToLog.toFile());\r\n                } else {\r\n                    JOptionPane.showMessageDialog(this, org.openide.util.NbBundle.getMessage(AutoIngestControlPanel.class, \"AutoIngestControlPanel.ShowLogFailed.Message\"), org.openide.util.NbBundle.getMessage(AutoIngestControlPanel.class, \"AutoIngestControlPanel.ShowLogFailed.Title\"), JOptionPane.ERROR_MESSAGE);\r\n                }\r\n            } else {\r\n                MessageNotifyUtil.Message.warn(\"The case directory for this job has been deleted.\");\r\n            }\r\n        }\r\n    } catch (IOException ex) {\r\n        sysLogger.log(Level.SEVERE, \"Dashboard error attempting to display case auto ingest log\", ex);\r\n        Object[] options = { org.openide.util.NbBundle.getMessage(AutoIngestControlPanel.class, \"DisplayLogDialog.okay\") };\r\n        JOptionPane.showOptionDialog(this, org.openide.util.NbBundle.getMessage(AutoIngestControlPanel.class, \"DisplayLogDialog.cannotFindLog\"), org.openide.util.NbBundle.getMessage(AutoIngestControlPanel.class, \"DisplayLogDialog.unableToShowLogFile\"), JOptionPane.DEFAULT_OPTION, JOptionPane.PLAIN_MESSAGE, null, options, options[0]);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.TimeLineController.showTimeLine",
	"Comment": "add the case and ingest listeners, prompt for rebuilding the database ifnecessary, and show the timeline window.",
	"Method": "void showTimeLine(AbstractFile file,BlackboardArtifact artifact){\r\n    if (Case.isCaseOpen() && !listeningToAutopsy) {\r\n        IngestManager.getInstance().addIngestModuleEventListener(ingestModuleListener);\r\n        IngestManager.getInstance().addIngestJobEventListener(ingestJobListener);\r\n        Case.addPropertyChangeListener(caseListener);\r\n        listeningToAutopsy = true;\r\n    }\r\n    Platform.runLater(() -> promptForRebuild(file, artifact));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.healthmonitor.HealthMonitor.getExclusiveDbLock",
	"Comment": "get an exclusive lock for the health monitor database. acquire thisbefore creating, initializing, or updating the database schema.",
	"Method": "CoordinationService.Lock getExclusiveDbLock(){\r\n    try {\r\n        CoordinationService.Lock lock = CoordinationService.getInstance().tryGetExclusiveLock(CoordinationService.CategoryNode.HEALTH_MONITOR, DATABASE_NAME, 5, TimeUnit.MINUTES);\r\n        if (lock != null) {\r\n            return lock;\r\n        }\r\n        throw new HealthMonitorException(\"Error acquiring database lock\");\r\n    } catch (InterruptedException | CoordinationService.CoordinationServiceException ex) {\r\n        throw new HealthMonitorException(\"Error acquiring database lock\", ex);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.healthmonitor.HealthMonitorDashboard.createTimingPanel",
	"Comment": "create the panel holding the timing graphs and the controls for them.",
	"Method": "JPanel createTimingPanel(){\r\n    if (!HealthMonitor.monitorIsEnabled()) {\r\n        JPanel emptyTimingMetricPanel = new JPanel();\r\n        emptyTimingMetricPanel.add(new JLabel(Bundle.HealthMonitorDashboard_createTimingPanel_timingMetricsTitle()));\r\n        emptyTimingMetricPanel.add(new JLabel(\" \"));\r\n        emptyTimingMetricPanel.add(new JLabel(Bundle.HealthMonitorDashboard_createTimingPanel_noData()));\r\n        return emptyTimingMetricPanel;\r\n    }\r\n    JPanel timingMetricPanel = new JPanel();\r\n    timingMetricPanel.setLayout(new BoxLayout(timingMetricPanel, BoxLayout.PAGE_AXIS));\r\n    timingMetricPanel.setBorder(BorderFactory.createEtchedBorder());\r\n    JLabel timingMetricTitle = new JLabel(Bundle.HealthMonitorDashboard_createTimingPanel_timingMetricsTitle());\r\n    timingMetricPanel.add(timingMetricTitle);\r\n    timingMetricPanel.add(new JSeparator());\r\n    timingMetricPanel.add(createTimingControlPanel());\r\n    timingMetricPanel.add(new JSeparator());\r\n    timingGraphPanel = new JPanel();\r\n    timingGraphPanel.setLayout(new GridLayout(0, 2));\r\n    updateTimingMetricGraphs();\r\n    JScrollPane scrollPane = new JScrollPane(timingGraphPanel, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\r\n    timingMetricPanel.add(scrollPane);\r\n    timingMetricPanel.revalidate();\r\n    timingMetricPanel.repaint();\r\n    return timingMetricPanel;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.TimeZoneUtils.createTimeZoneString",
	"Comment": "generate a time zone string containing the gmt offset and id.",
	"Method": "String createTimeZoneString(TimeZone timeZone){\r\n    int offset = timeZone.getRawOffset() / 1000;\r\n    int hour = offset / 3600;\r\n    int minutes = Math.abs((offset % 3600) / 60);\r\n    return String.format(\"(GMT%+d:d) %s\", hour, minutes, timeZone.getID());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.configuration.AutoIngestSettingsPanel.validateSharedSettingsPath",
	"Comment": "validate shared settings path. display warnings if invalid.",
	"Method": "boolean validateSharedSettingsPath(){\r\n    String sharedSettingsPath = sharedSettingsTextField.getText().trim();\r\n    if (!sharedConfigCheckbox.isSelected()) {\r\n        return true;\r\n    }\r\n    if (sharedSettingsPath.isEmpty()) {\r\n        sharedSettingsErrorTextField.setVisible(true);\r\n        sharedSettingsErrorTextField.setText(NbBundle.getMessage(AutoIngestSettingsPanel.class, \"AutoIngestSettingsPanel.EmptySettingsDirectory\"));\r\n        return false;\r\n    }\r\n    if (!isFolderPathValid(sharedSettingsPath)) {\r\n        sharedSettingsErrorTextField.setVisible(true);\r\n        sharedSettingsErrorTextField.setText(NbBundle.getMessage(AutoIngestSettingsPanel.class, \"AutoIngestSettingsPanel.PathInvalid\"));\r\n        return false;\r\n    }\r\n    if (false == permissionsAppropriate(sharedSettingsPath)) {\r\n        sharedSettingsErrorTextField.setVisible(true);\r\n        sharedSettingsErrorTextField.setText(NbBundle.getMessage(AutoIngestSettingsPanel.class, \"AutoIngestSettingsPanel.CannotAccess\") + \" \" + sharedSettingsPath + \" \" + NbBundle.getMessage(AutoIngestSettingsPanel.class, \"AutoIngestSettingsPanel.CheckPermissions\"));\r\n        return false;\r\n    }\r\n    sharedSettingsErrorTextField.setText(\"\");\r\n    return true;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.interestingitems.FilesSetPanel.getFileSetIgnoresKnownFiles",
	"Comment": "get whether or not the interesting files set defined using this panelignores known files.",
	"Method": "boolean getFileSetIgnoresKnownFiles(){\r\n    return this.ignoreKnownFilesCheckbox.isSelected();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestJob.dataSourceJobFinished",
	"Comment": "provides a callback for completed data source ingest jobs, allowing thisingest job to notify the ingest manager when it is complete.",
	"Method": "void dataSourceJobFinished(DataSourceIngestJob job){\r\n    IngestManager ingestManager = IngestManager.getInstance();\r\n    if (!job.isCancelled()) {\r\n        ingestManager.fireDataSourceAnalysisCompleted(id, job.getId(), job.getDataSource());\r\n    } else {\r\n        IngestManager.getInstance().fireDataSourceAnalysisCancelled(id, job.getId(), job.getDataSource());\r\n    }\r\n    if (incompleteJobsCount.decrementAndGet() == 0) {\r\n        ingestManager.finishIngestJob(this);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.ImageGalleryModule.isEnabledforCase",
	"Comment": "indicates whether or not the image gallery module is enabled for a givencase.",
	"Method": "boolean isEnabledforCase(Case theCase){\r\n    String enabledforCaseProp = new PerCaseProperties(theCase).getConfigSetting(ImageGalleryModule.MODULE_NAME, PerCaseProperties.ENABLED);\r\n    return isNotBlank(enabledforCaseProp) ? Boolean.valueOf(enabledforCaseProp) : ImageGalleryPreferences.isEnabledByDefault();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.Index.isCompatible",
	"Comment": "is the current index instance compatible with the given version number",
	"Method": "boolean isCompatible(String version){\r\n    int currentMajorVersion = NumberUtils.toInt(schemaVersion.substring(0, schemaVersion.indexOf('.')));\r\n    int givenMajorVersion = NumberUtils.toInt(version.substring(0, version.indexOf('.')));\r\n    return currentMajorVersion == givenMajorVersion;\r\n}"
}, {
	"Path": "org.codechimp.apprater.AppRater.rateNow",
	"Comment": "call this method directly to go straight to play store listing for rating",
	"Method": "void rateNow(Context context){\r\n    try {\r\n        context.startActivity(new Intent(Intent.ACTION_VIEW, market.getMarketURI(context)));\r\n    } catch (ActivityNotFoundException activityNotFoundException1) {\r\n        Log.e(AppRater.class.getSimpleName(), \"Market Intent not found\");\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.examples.SampleIngestModuleFactory.getIngestJobSettingsPanel",
	"Comment": "gets a user interface panel that can be used to set per ingest jobsettings for instances of the family of ingest modules the factorycreates. for example, the core hash lookup ingest module factory providesan ingest job settings panel to enable or disable hash databases peringest job. if the module family does not have per ingest job settings,the factory may extend ingestmodulefactoryadapter to get animplementation of this method that throws anunsupportedoperationexception.",
	"Method": "IngestModuleIngestJobSettingsPanel getIngestJobSettingsPanel(IngestModuleIngestJobSettings settings){\r\n    if (!(settings instanceof SampleModuleIngestJobSettings)) {\r\n        throw new IllegalArgumentException(\"Expected settings argument to be instanceof SampleModuleIngestJobSettings\");\r\n    }\r\n    return new SampleIngestModuleIngestJobSettingsPanel((SampleModuleIngestJobSettings) settings);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.runIngestModuleWizard.IngestProfileSelectionWizardPanel.fireChangeEvent",
	"Comment": "fires a change event to notify listeners that changes have taken place.",
	"Method": "void fireChangeEvent(){\r\n    Set<ChangeListener> ls;\r\n    synchronized (listeners) {\r\n        ls = new HashSet(listeners);\r\n    }\r\n    ChangeEvent ev = new ChangeEvent(this);\r\n    for (ChangeListener l : ls) {\r\n        l.stateChanged(ev);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestControlPanel.enablePrioritizeButtons",
	"Comment": "enables or disables prioritize buttons related to the pending jobs table.",
	"Method": "void enablePrioritizeButtons(Boolean enable){\r\n    bnPrioritizeCase.setEnabled(enable);\r\n    bnPrioritizeJob.setEnabled(enable);\r\n}"
}, {
	"Path": "com.aliyun.oss.internal.ResponseParsers.parseCompleteMultipartUpload",
	"Comment": "unmarshall complete multipart upload response body to correspondingresult.",
	"Method": "CompleteMultipartUploadResult parseCompleteMultipartUpload(InputStream responseBody){\r\n    try {\r\n        Element root = getXmlRootElement(responseBody);\r\n        CompleteMultipartUploadResult result = new CompleteMultipartUploadResult();\r\n        result.setBucketName(root.getChildText(\"Bucket\"));\r\n        result.setETag(trimQuotes(root.getChildText(\"ETag\")));\r\n        result.setKey(root.getChildText(\"Key\"));\r\n        result.setLocation(root.getChildText(\"Location\"));\r\n        return result;\r\n    } catch (JDOMParseException e) {\r\n        throw new ResponseParseException(e.getPartialDocument() + \": \" + e.getMessage(), e);\r\n    } catch (Exception e) {\r\n        throw new ResponseParseException(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.volatilityDSP.MemoryDSProcessor.reset",
	"Comment": "resets the selection and configuration panel for this data sourceprocessor.",
	"Method": "void reset(){\r\n    configPanel.reset();\r\n}"
}, {
	"Path": "com.aliyun.oss.internal.ResponseParsers.parseGetLiveChannelInfo",
	"Comment": "unmarshall get live channel info response body to corresponding result.",
	"Method": "LiveChannelInfo parseGetLiveChannelInfo(InputStream responseBody){\r\n    try {\r\n        Element root = getXmlRootElement(responseBody);\r\n        LiveChannelInfo result = new LiveChannelInfo();\r\n        result.setDescription(root.getChildText(\"Description\"));\r\n        result.setStatus(LiveChannelStatus.parse(root.getChildText(\"Status\")));\r\n        Element targetElem = root.getChild(\"Target\");\r\n        LiveChannelTarget target = new LiveChannelTarget();\r\n        target.setType(targetElem.getChildText(\"Type\"));\r\n        target.setFragDuration(Integer.parseInt(targetElem.getChildText(\"FragDuration\")));\r\n        target.setFragCount(Integer.parseInt(targetElem.getChildText(\"FragCount\")));\r\n        target.setPlaylistName(targetElem.getChildText(\"PlaylistName\"));\r\n        result.setTarget(target);\r\n        return result;\r\n    } catch (JDOMParseException e) {\r\n        throw new ResponseParseException(e.getPartialDocument() + \": \" + e.getMessage(), e);\r\n    } catch (Exception e) {\r\n        throw new ResponseParseException(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.datamodel.FileTypesByMimeType.populateHashMap",
	"Comment": "performs the query on the database to get all distinct mime types offiles in it, and populate the hashmap with those results.",
	"Method": "void populateHashMap(){\r\n    String query = \"SELECT mime_type, count(*) AS count FROM tsk_files \" + \" WHERE mime_type IS NOT null \" + \" AND \" + createBaseWhereExpr() + \" GROUP BY mime_type\";\r\n    synchronized (existingMimeTypeCounts) {\r\n        existingMimeTypeCounts.clear();\r\n        if (skCase == null) {\r\n            return;\r\n        }\r\n        try (SleuthkitCase.CaseDbQuery dbQuery = skCase.executeQuery(query)) {\r\n            ResultSet resultSet = dbQuery.getResultSet();\r\n            while (resultSet.next()) {\r\n                final String mime_type = resultSet.getString(\"mime_type\");\r\n                if (!mime_type.isEmpty()) {\r\n                    final String mediaType = StringUtils.substringBefore(mime_type, \"/\");\r\n                    final String subType = StringUtils.removeStart(mime_type, mediaType + \"/\");\r\n                    if (!mediaType.isEmpty() && !subType.isEmpty()) {\r\n                        final long count = resultSet.getLong(\"count\");\r\n                        existingMimeTypeCounts.computeIfAbsent(mediaType, t -> new HashMap()).put(subType, count);\r\n                    }\r\n                }\r\n            }\r\n        } catch (TskCoreException | SQLException ex) {\r\n            logger.log(Level.SEVERE, \"Unable to populate File Types by MIME Type tree view from DB: \", ex);\r\n        }\r\n    }\r\n    setChanged();\r\n    notifyObservers();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.ReportProgressPanel.cancel",
	"Comment": "makes the components of this panel indicate generation of the report wascancelled.",
	"Method": "void cancel(){\r\n    switch(status) {\r\n        case COMPLETE:\r\n            break;\r\n        case CANCELED:\r\n            break;\r\n        case ERROR:\r\n            break;\r\n        default:\r\n            ReportStatus oldValue = status;\r\n            status = ReportStatus.CANCELED;\r\n            reportProgressBar.setIndeterminate(false);\r\n            reportProgressBar.setValue(0);\r\n            reportProgressBar.setStringPainted(true);\r\n            reportProgressBar.setForeground(RED);\r\n            reportProgressBar.setString(\"Cancelled\");\r\n            firePropertyChange(ReportStatus.CANCELED.toString(), oldValue, status);\r\n            statusMessageLabel.setForeground(RED);\r\n            statusMessageLabel.setText(NbBundle.getMessage(this.getClass(), \"ReportProgressPanel.cancel.procLbl.text\"));\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.ashley.utils.Bag.add",
	"Comment": "adds the specified element to the end of this bag. if needed also increases the capacity of the bag.",
	"Method": "void add(E e){\r\n    if (size == data.length) {\r\n        grow();\r\n    }\r\n    data[size++] = e;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJobLogger.logCrashRecoveryWithRetry",
	"Comment": "logs discovery of a crashed auto ingest job for which recovery will beattempted.",
	"Method": "void logCrashRecoveryWithRetry(){\r\n    log(MessageCategory.ERROR, \"Detected crash while processing, reprocessing\");\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.DataContentViewerString.maybeShowPopup",
	"Comment": "show the right click menu only if evt is the correct mouse event",
	"Method": "void maybeShowPopup(java.awt.event.MouseEvent evt){\r\n    if (evt.isPopupTrigger()) {\r\n        rightClickMenu.setLocation(evt.getLocationOnScreen());\r\n        rightClickMenu.setVisible(true);\r\n        copyMenuItem.setEnabled(outputViewPane.getSelectedText() != null);\r\n    } else {\r\n        rightClickMenu.setVisible(false);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestServices.getInstance",
	"Comment": "gets the ingest services singleton that provides convenience methods foringest modules to use to access the autopsy case, the case database, fireevents,",
	"Method": "IngestServices getInstance(){\r\n    if (instance == null) {\r\n        instance = new IngestServices();\r\n    }\r\n    return instance;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.filetypeid.FileTypeDetector.detectAutopsyDefinedType",
	"Comment": "determines whether or not a file matches a custom file type defined by autopsy.",
	"Method": "String detectAutopsyDefinedType(AbstractFile file){\r\n    for (FileType fileType : autopsyDefinedFileTypes) {\r\n        if (fileType.matches(file)) {\r\n            return fileType.getMimeType();\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.ui.ViewFrame.refreshTimeUI",
	"Comment": "refresh the time selection ui to match the current zoom parameters.",
	"Method": "void refreshTimeUI(){\r\n    RangeDivisionInfo rangeDivisionInfo = RangeDivisionInfo.getRangeDivisionInfo(filteredEvents.getSpanningInterval());\r\n    final long minTime = rangeDivisionInfo.getLowerBound();\r\n    final long maxTime = rangeDivisionInfo.getUpperBound();\r\n    long startMillis = filteredEvents.getTimeRange().getStartMillis();\r\n    long endMillis = filteredEvents.getTimeRange().getEndMillis();\r\n    if (minTime > 0 && maxTime > minTime) {\r\n        Platform.runLater(() -> {\r\n            startPicker.localDateTimeProperty().removeListener(startListener);\r\n            endPicker.localDateTimeProperty().removeListener(endListener);\r\n            rangeSlider.highValueChangingProperty().removeListener(rangeSliderListener);\r\n            rangeSlider.lowValueChangingProperty().removeListener(rangeSliderListener);\r\n            rangeSlider.setMax((maxTime - minTime));\r\n            rangeSlider.setLowValue(startMillis - minTime);\r\n            rangeSlider.setHighValue(endMillis - minTime);\r\n            startPicker.setLocalDateTime(epochMillisToLocalDateTime(startMillis));\r\n            endPicker.setLocalDateTime(epochMillisToLocalDateTime(endMillis));\r\n            rangeSlider.highValueChangingProperty().addListener(rangeSliderListener);\r\n            rangeSlider.lowValueChangingProperty().addListener(rangeSliderListener);\r\n            startPicker.localDateTimeProperty().addListener(startListener);\r\n            endPicker.localDateTimeProperty().addListener(endListener);\r\n        });\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.ReportWizardIterator.enableConfigPanels",
	"Comment": "change which panels will be shown based on the selection of reportingmodules.",
	"Method": "void enableConfigPanels(boolean generalModule,boolean tableModule){\r\n    if (generalModule) {\r\n    } else if (tableModule) {\r\n        panels = Arrays.asList(tableConfigPanels);\r\n    } else {\r\n        panels = Arrays.asList(fileConfigPanels);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.TableReportGenerator.makeThumbnailTable",
	"Comment": "make a report for the files that were previously found to be images.",
	"Method": "void makeThumbnailTable(){\r\n    progressPanel.updateStatusLabel(NbBundle.getMessage(this.getClass(), \"ReportGenerator.progress.createdThumb.text\"));\r\n    if (tableReport instanceof ReportHTML) {\r\n        ReportHTML htmlModule = (ReportHTML) tableReport;\r\n        htmlModule.startDataType(NbBundle.getMessage(this.getClass(), \"ReportGenerator.thumbnailTable.name\"), NbBundle.getMessage(this.getClass(), \"ReportGenerator.thumbnailTable.desc\"));\r\n        List<String> emptyHeaders = new ArrayList();\r\n        for (int i = 0; i < ReportHTML.THUMBNAIL_COLUMNS; i++) {\r\n            emptyHeaders.add(\"\");\r\n        }\r\n        htmlModule.startTable(emptyHeaders);\r\n        htmlModule.addThumbnailRows(images);\r\n        htmlModule.endTable();\r\n        htmlModule.endDataType();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.filetypeid.FileTypeIdIngestModule.addToTotals",
	"Comment": "update the match time total and increment number of files processed forthis ingest job.",
	"Method": "void addToTotals(long jobId,long matchTimeInc){\r\n    IngestJobTotals ingestJobTotals = totalsForIngestJobs.get(jobId);\r\n    if (ingestJobTotals == null) {\r\n        ingestJobTotals = new IngestJobTotals();\r\n        totalsForIngestJobs.put(jobId, ingestJobTotals);\r\n    }\r\n    ingestJobTotals.matchTime += matchTimeInc;\r\n    ingestJobTotals.numFiles++;\r\n    totalsForIngestJobs.put(jobId, ingestJobTotals);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.hashdatabase.EncaseHashSetParser.getExpectedHashCount",
	"Comment": "get the expected number of hashes in the file. this number can be anestimate.",
	"Method": "long getExpectedHashCount(){\r\n    return expectedHashCount;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AddArchiveTask.getDataSourceProcessorsForFile",
	"Comment": "get a list of data source processors that can process the data source ofinterest. the list is sorted by confidence in decreasing order.",
	"Method": "List<AutoIngestDataSourceProcessor> getDataSourceProcessorsForFile(Path dataSourcePath,List<String> errorMessages,List<AutoIngestDataSourceProcessor> processorCandidates){\r\n    List<AutoIngestDataSourceProcessor> validDataSourceProcessorsForFile = Collections.emptyList();\r\n    try {\r\n        validDataSourceProcessorsForFile = DataSourceProcessorUtility.getOrderedListOfDataSourceProcessors(dataSourcePath, processorCandidates);\r\n    } catch (AutoIngestDataSourceProcessor.AutoIngestDataSourceProcessorException ex) {\r\n        criticalErrorOccurred = true;\r\n        errorMessages.add(ex.getMessage());\r\n        logger.log(Level.SEVERE, String.format(\"Critical error occurred while extracting archive %s\", archivePath), ex);\r\n        return Collections.emptyList();\r\n    }\r\n    return validDataSourceProcessorsForFile;\r\n}"
}, {
	"Path": "com.badlogic.ashley.core.Engine.addEntity",
	"Comment": "adds an entity to this engine.\tthis will throw an illegalargumentexception if the given entity\twas already registered with an engine.",
	"Method": "void addEntity(Entity entity){\r\n    boolean delayed = updating || familyManager.notifying();\r\n    entityManager.addEntity(entity, delayed);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJobLogger.logFailedToIdentifyDataSource",
	"Comment": "logs a failure to identify data source processor for the data source.",
	"Method": "void logFailedToIdentifyDataSource(){\r\n    log(MessageCategory.ERROR, String.format(\"Failed to identify data source\"));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.AddImageWizardDataSourceSettingsPanel.getHelp",
	"Comment": "help for this panel. when the panel is active, this is used as the helpfor the wizard dialog.",
	"Method": "HelpCtx getHelp(){\r\n    return HelpCtx.DEFAULT_HELP;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.DataResultPanel.open",
	"Comment": "opens this result view panel. should be called by a parent top componentwhen the top component is opened.",
	"Method": "void open(){\r\n    if (this.explorerManager == null) {\r\n        this.explorerManager = ExplorerManager.find(this);\r\n        this.explorerManager.addPropertyChangeListener(this.explorerManagerListener);\r\n    }\r\n    if (this.resultViewerTabs.getTabCount() == 0) {\r\n        if (this.resultViewers.isEmpty()) {\r\n            for (DataResultViewer resultViewer : Lookup.getDefault().lookupAll(DataResultViewer.class)) {\r\n                if (this.isMain) {\r\n                    this.resultViewers.add(resultViewer);\r\n                } else {\r\n                    this.resultViewers.add(resultViewer.createInstance());\r\n                }\r\n            }\r\n        }\r\n        this.resultViewers.forEach((resultViewer) -> resultViewerTabs.addTab(resultViewer.getTitle(), resultViewer.getComponent()));\r\n    }\r\n    this.setVisible(true);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJob.setDataSourceProcessor",
	"Comment": "sets the data source processor for the job. used for job cancellation.",
	"Method": "void setDataSourceProcessor(DataSourceProcessor dataSourceProcessor){\r\n    this.dataSourceProcessor = dataSourceProcessor;\r\n}"
}, {
	"Path": "com.google.example.games.tbmpskeleton.SkeletonActivity.signInSilently",
	"Comment": "try to sign in without displaying dialogs to the user.if the user has already signed in previously, it will not show dialog.",
	"Method": "void signInSilently(){\r\n    Log.d(TAG, \"signInSilently()\");\r\n    mGoogleSignInClient.silentSignIn().addOnCompleteListener(this, new OnCompleteListener<GoogleSignInAccount>() {\r\n        @Override\r\n        public void onComplete(@NonNull Task<GoogleSignInAccount> task) {\r\n            if (task.isSuccessful()) {\r\n                Log.d(TAG, \"signInSilently(): success\");\r\n                onConnected(task.getResult());\r\n            } else {\r\n                Log.d(TAG, \"signInSilently(): failure\", task.getException());\r\n                onDisconnected();\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.google.example.games.tbmpskeleton.SkeletonActivity.signInSilently",
	"Comment": "try to sign in without displaying dialogs to the user.if the user has already signed in previously, it will not show dialog.",
	"Method": "void signInSilently(){\r\n    if (task.isSuccessful()) {\r\n        Log.d(TAG, \"signInSilently(): success\");\r\n        onConnected(task.getResult());\r\n    } else {\r\n        Log.d(TAG, \"signInSilently(): failure\", task.getException());\r\n        onDisconnected();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.datamodel.grouping.GroupManager.addFileToGroup",
	"Comment": "adds an analyzed file to a group and marks the group as analyzed if theentire group is now analyzed.",
	"Method": "void addFileToGroup(DrawableGroup group,GroupKey<?> groupKey,long fileID){\r\n    if (group == null) {\r\n        group = popuplateIfAnalyzed(groupKey, null);\r\n    } else {\r\n        group.addFile(fileID);\r\n    }\r\n    if (group != null) {\r\n        markGroupSeen(group, false);\r\n    }\r\n}"
}, {
	"Path": "com.aliyun.oss.common.utils.IniEditor.hasSection",
	"Comment": "checks whether a section with a particular name exists in this instance.",
	"Method": "boolean hasSection(String name){\r\n    return this.sections.containsKey(normSection(name));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.Keyword.searchTermIsLiteral",
	"Comment": "indicates whether the search term for the keyword is a literal term or aregex.",
	"Method": "boolean searchTermIsLiteral(){\r\n    return isLiteral;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.configuration.AutoIngestSettingsPanel.getDefaultSharedFolder",
	"Comment": "get the default location for the shared configuration folder. currentlythis is a subfolder of the shared images folder.",
	"Method": "String getDefaultSharedFolder(){\r\n    String images = inputPathTextField.getText().trim();\r\n    if (images == null || images.isEmpty()) {\r\n        return \"\";\r\n    }\r\n    File sharedFolder = new File(images, \"sharedConfiguration\");\r\n    if (!sharedFolder.exists()) {\r\n        try {\r\n            sharedFolder.mkdir();\r\n            return sharedFolder.getAbsolutePath();\r\n        } catch (Exception ex) {\r\n            sharedSettingsErrorTextField.setText(NbBundle.getMessage(AutoIngestSettingsPanel.class, \"AutoIngestSettingsPanel.ErrorSettingDefaultFolder\"));\r\n            return \"\";\r\n        }\r\n    }\r\n    return sharedFolder.getAbsolutePath();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.KeywordSearchUtil.quoteQuery",
	"Comment": "return a quoted version of the query if the original query is not quoted",
	"Method": "String quoteQuery(String query){\r\n    final int length = query.length();\r\n    if (length > 1 && query.charAt(0) == '\"' && query.charAt(length - 1) == '\"') {\r\n        return query;\r\n    }\r\n    return \"\\\"\" + query + \"\\\"\";\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.ImageUtils.isImageThumbnailSupported",
	"Comment": "is the file an image that we can read and generate a thumbnail for?",
	"Method": "boolean isImageThumbnailSupported(AbstractFile file){\r\n    return isMediaThumbnailSupported(file, \"image/\", SUPPORTED_IMAGE_MIME_TYPES, SUPPORTED_IMAGE_EXTENSIONS) || hasImageFileHeader(file);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestManager.scanInputDirsAndWait",
	"Comment": "start a scan of the input directories and wait for scan to complete.",
	"Method": "void scanInputDirsAndWait(){\r\n    if (State.RUNNING != state) {\r\n        return;\r\n    }\r\n    sysLogger.log(Level.INFO, \"Starting input scan of {0}\", rootInputDirectory);\r\n    InputDirScanner scanner = new InputDirScanner();\r\n    scanner.scan();\r\n    sysLogger.log(Level.INFO, \"Completed input scan of {0}\", rootInputDirectory);\r\n}"
}, {
	"Path": "org.owntracks.android.ui.welcome.WelcomeAdapterTest.setFinalStatic",
	"Comment": "helper method to override the value of a static final field on a class",
	"Method": "void setFinalStatic(Field field,Object newValue){\r\n    field.setAccessible(true);\r\n    Field modifiersField = Field.class.getDeclaredField(\"modifiers\");\r\n    modifiersField.setAccessible(true);\r\n    modifiersField.setInt(field, field.getModifiers() & ~Modifier.FINAL);\r\n    field.set(null, newValue);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.actions.ReplaceBlackboardArtifactTagAction.replaceTag",
	"Comment": "replaces the specified tag on the given artifact with the new one",
	"Method": "void replaceTag(BlackboardArtifactTag oldArtifactTag,TagName newTagName,String newComment){\r\n    new SwingWorker<Void, Void>() {\r\n        @Override\r\n        protected Void doInBackground() throws Exception {\r\n            TagsManager tagsManager;\r\n            try {\r\n                tagsManager = Case.getCurrentCaseThrows().getServices().getTagsManager();\r\n            } catch (NoCurrentCaseException ex) {\r\n                logger.log(Level.SEVERE, \"Error replacing artifact tag. No open case found.\", ex);\r\n                Platform.runLater(() -> new Alert(Alert.AlertType.ERROR, Bundle.ReplaceBlackboardArtifactTagAction_replaceTag_alert(oldArtifactTag.getName().getDisplayName(), oldArtifactTag.getArtifact().getArtifactID())).show());\r\n                return null;\r\n            }\r\n            try {\r\n                logger.log(Level.INFO, \"Replacing tag {0}  with tag {1} for artifact {2}\", new Object[] { oldArtifactTag.getName().getDisplayName(), newTagName.getDisplayName(), oldArtifactTag.getContent().getName() });\r\n                tagsManager.deleteBlackboardArtifactTag(oldArtifactTag);\r\n                tagsManager.addBlackboardArtifactTag(oldArtifactTag.getArtifact(), newTagName, newComment);\r\n            } catch (TskCoreException tskCoreException) {\r\n                logger.log(Level.SEVERE, \"Error replacing artifact tag\", tskCoreException);\r\n                Platform.runLater(() -> new Alert(Alert.AlertType.ERROR, Bundle.ReplaceBlackboardArtifactTagAction_replaceTag_alert(oldArtifactTag.getName().getDisplayName(), oldArtifactTag.getArtifact().getArtifactID())).show());\r\n            }\r\n            return null;\r\n        }\r\n        @Override\r\n        protected void done() {\r\n            super.done();\r\n            try {\r\n                get();\r\n            } catch (InterruptedException | ExecutionException ex) {\r\n                logger.log(Level.SEVERE, \"Unexpected exception while replacing artifact tag\", ex);\r\n            }\r\n        }\r\n    }.execute();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.actions.ReplaceBlackboardArtifactTagAction.replaceTag",
	"Comment": "replaces the specified tag on the given artifact with the new one",
	"Method": "void replaceTag(BlackboardArtifactTag oldArtifactTag,TagName newTagName,String newComment){\r\n    TagsManager tagsManager;\r\n    try {\r\n        tagsManager = Case.getCurrentCaseThrows().getServices().getTagsManager();\r\n    } catch (NoCurrentCaseException ex) {\r\n        logger.log(Level.SEVERE, \"Error replacing artifact tag. No open case found.\", ex);\r\n        Platform.runLater(() -> new Alert(Alert.AlertType.ERROR, Bundle.ReplaceBlackboardArtifactTagAction_replaceTag_alert(oldArtifactTag.getName().getDisplayName(), oldArtifactTag.getArtifact().getArtifactID())).show());\r\n        return null;\r\n    }\r\n    try {\r\n        logger.log(Level.INFO, \"Replacing tag {0}  with tag {1} for artifact {2}\", new Object[] { oldArtifactTag.getName().getDisplayName(), newTagName.getDisplayName(), oldArtifactTag.getContent().getName() });\r\n        tagsManager.deleteBlackboardArtifactTag(oldArtifactTag);\r\n        tagsManager.addBlackboardArtifactTag(oldArtifactTag.getArtifact(), newTagName, newComment);\r\n    } catch (TskCoreException tskCoreException) {\r\n        logger.log(Level.SEVERE, \"Error replacing artifact tag\", tskCoreException);\r\n        Platform.runLater(() -> new Alert(Alert.AlertType.ERROR, Bundle.ReplaceBlackboardArtifactTagAction_replaceTag_alert(oldArtifactTag.getName().getDisplayName(), oldArtifactTag.getArtifact().getArtifactID())).show());\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.actions.ReplaceBlackboardArtifactTagAction.replaceTag",
	"Comment": "replaces the specified tag on the given artifact with the new one",
	"Method": "void replaceTag(BlackboardArtifactTag oldArtifactTag,TagName newTagName,String newComment){\r\n    super.done();\r\n    try {\r\n        get();\r\n    } catch (InterruptedException | ExecutionException ex) {\r\n        logger.log(Level.SEVERE, \"Unexpected exception while replacing artifact tag\", ex);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.Case.hasData",
	"Comment": "queries whether or not the case has data, i.e., whether or not at leastone data source has been added to the case.",
	"Method": "boolean hasData(){\r\n    if (!hasDataSources) {\r\n        try {\r\n            hasDataSources = (getDataSources().size() > 0);\r\n        } catch (TskCoreException ex) {\r\n            logger.log(Level.SEVERE, \"Error accessing case database\", ex);\r\n        }\r\n    }\r\n    return hasDataSources;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.DataSourceIngestCancellationPanel.cancelAllDataSourceIngestModules",
	"Comment": "queries whether the user wants to cancel the ingest job or just thecurrently executing data source ingest module.",
	"Method": "boolean cancelAllDataSourceIngestModules(){\r\n    return this.cancelAllIngestModules;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.gui.drawableviews.GroupPane.setViewState",
	"Comment": "assigns a grouping for this pane to represent and initializes groupingspecific properties and listeners",
	"Method": "void setViewState(GroupViewState newViewState){\r\n    if (isNull(newViewState) || isNull(newViewState.getGroup().orElse(null))) {\r\n        if (nonNull(getGroup())) {\r\n            getGroup().getFileIDs().removeListener(filesSyncListener);\r\n        }\r\n        this.grouping.set(null);\r\n        Platform.runLater(() -> {\r\n            gridView.getItems().setAll(Collections.emptyList());\r\n            setCenter(new Label(\"No group selected\"));\r\n            slideShowToggle.setDisable(true);\r\n            groupLabel.setText(\"\");\r\n            resetScrollBar();\r\n            if (false == Case.isCaseOpen()) {\r\n                cellMap.values().stream().forEach(DrawableCell::resetItem);\r\n                cellMap.clear();\r\n            }\r\n        });\r\n    } else {\r\n        if (nonNull(getGroup()) && getGroup() != newViewState.getGroup().get()) {\r\n            getGroup().getFileIDs().removeListener(filesSyncListener);\r\n        }\r\n        this.grouping.set(newViewState.getGroup().get());\r\n        getGroup().getFileIDs().addListener(filesSyncListener);\r\n        final String header = getHeaderString();\r\n        Platform.runLater(() -> {\r\n            gridView.getItems().setAll(getGroup().getFileIDs());\r\n            boolean empty = gridView.getItems().isEmpty();\r\n            slideShowToggle.setDisable(empty);\r\n            groupLabel.setText(header);\r\n            resetScrollBar();\r\n            if (empty) {\r\n                setCenter(new Label(\"There are no files in the selected group.\"));\r\n            } else if (newViewState.getMode() == GroupViewMode.TILE) {\r\n                activateTileViewer();\r\n            } else {\r\n                activateSlideShowViewer(newViewState.getSlideShowfileID().orElse(null));\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.configuration.AutoIngestUserPreferences.setMaxNumTimesToProcessImage",
	"Comment": "set the maximum number of times to attempt to reprocess an image. this isused to avoid endless attempts to process an image folder with corruptdata that causes a crash.",
	"Method": "void setMaxNumTimesToProcessImage(int retries){\r\n    ModuleSettings.setConfigSetting(UserPreferences.SETTINGS_PROPERTIES, MAX_NUM_TIMES_TO_PROCESS_IMAGE, Integer.toString(retries));\r\n}"
}, {
	"Path": "org.wikipedia.util.L10nUtil.setupDirectionality",
	"Comment": "set up directionality for both ui and content elements in a webview.",
	"Method": "void setupDirectionality(String contentLang,Locale uiLocale,CommunicationBridge bridge){\r\n    JSONObject payload = new JSONObject();\r\n    try {\r\n        if (isLangRTL(contentLang)) {\r\n            payload.put(\"contentDirection\", \"rtl\");\r\n        } else {\r\n            payload.put(\"contentDirection\", \"ltr\");\r\n        }\r\n        if (isLangRTL(LanguageUtil.localeToWikiLanguageCode(uiLocale))) {\r\n            payload.put(\"uiDirection\", \"rtl\");\r\n        } else {\r\n            payload.put(\"uiDirection\", \"ltr\");\r\n        }\r\n    } catch (JSONException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n    bridge.sendMessage(\"setDirectionality\", payload);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.AddImageWizardAddingProgressPanel.readSettings",
	"Comment": "load the image locations from the wizarddescriptor settings object, andthe",
	"Method": "void readSettings(WizardDescriptor settings){\r\n    startIngest();\r\n    settings.setOptions(new Object[] { WizardDescriptor.PREVIOUS_OPTION, WizardDescriptor.NEXT_OPTION, WizardDescriptor.FINISH_OPTION, WizardDescriptor.CANCEL_OPTION });\r\n    if (imgAdded) {\r\n        getComponent().setStateFinished();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestManager.subscribeToServiceMonitorEvents",
	"Comment": "subscribes the ingest manager to events published by its service monitor.the event handler cancels all ingest jobs if a key service goes down.",
	"Method": "void subscribeToServiceMonitorEvents(){\r\n    PropertyChangeListener propChangeListener = (PropertyChangeEvent evt) -> {\r\n        if (evt.getNewValue().equals(ServicesMonitor.ServiceStatus.DOWN.toString())) {\r\n            try {\r\n                if (Case.getCurrentCaseThrows().getCaseType() != Case.CaseType.MULTI_USER_CASE) {\r\n                    return;\r\n                }\r\n            } catch (NoCurrentCaseException noCaseOpenException) {\r\n                return;\r\n            }\r\n            String serviceDisplayName = ServicesMonitor.Service.valueOf(evt.getPropertyName()).getDisplayName();\r\n            logger.log(Level.SEVERE, \"Service {0} is down, cancelling all running ingest jobs\", serviceDisplayName);\r\n            if (isIngestRunning() && RuntimeProperties.runningWithGUI()) {\r\n                EventQueue.invokeLater(new Runnable() {\r\n                    @Override\r\n                    public void run() {\r\n                        JOptionPane.showMessageDialog(WindowManager.getDefault().getMainWindow(), NbBundle.getMessage(this.getClass(), \"IngestManager.cancellingIngest.msgDlg.text\"), NbBundle.getMessage(this.getClass(), \"IngestManager.serviceIsDown.msgDlg.text\", serviceDisplayName), JOptionPane.ERROR_MESSAGE);\r\n                    }\r\n                });\r\n            }\r\n            cancelAllIngestJobs(IngestJob.CancellationReason.SERVICES_DOWN);\r\n        }\r\n    };\r\n    Set<String> servicesList = new HashSet();\r\n    servicesList.add(ServicesMonitor.Service.REMOTE_CASE_DATABASE.toString());\r\n    servicesList.add(ServicesMonitor.Service.REMOTE_KEYWORD_SEARCH.toString());\r\n    this.servicesMonitor.addSubscriber(servicesList, propChangeListener);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestManager.subscribeToServiceMonitorEvents",
	"Comment": "subscribes the ingest manager to events published by its service monitor.the event handler cancels all ingest jobs if a key service goes down.",
	"Method": "void subscribeToServiceMonitorEvents(){\r\n    JOptionPane.showMessageDialog(WindowManager.getDefault().getMainWindow(), NbBundle.getMessage(this.getClass(), \"IngestManager.cancellingIngest.msgDlg.text\"), NbBundle.getMessage(this.getClass(), \"IngestManager.serviceIsDown.msgDlg.text\", serviceDisplayName), JOptionPane.ERROR_MESSAGE);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.hashdatabase.ImportCentralRepoDbProgressDialog.importFile",
	"Comment": "import the selected hash set into the central repository. will bring up aprogress dialog while the import is in progress.",
	"Method": "void importFile(String hashSetName,String version,int orgId,boolean searchDuringIngest,boolean sendIngestMessages,HashDbManager.HashDb.KnownFilesType knownFilesType,boolean readOnly,String importFileName){\r\n    worker = new CentralRepoImportWorker(hashSetName, version, orgId, searchDuringIngest, sendIngestMessages, knownFilesType, readOnly, importFileName);\r\n    worker.addPropertyChangeListener(this);\r\n    worker.execute();\r\n    setLocationRelativeTo((JFrame) WindowManager.getDefault().getMainWindow());\r\n    this.setVisible(true);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.contentviewer.DataContentViewerOtherCasesTableModel.mapNodeMessageData",
	"Comment": "map a column id to the value in that cell for node message data.",
	"Method": "Object mapNodeMessageData(OtherOccurrenceNodeMessageData nodeData,TableColumns columnId){\r\n    if (columnId == TableColumns.CASE_NAME) {\r\n        return nodeData.getDisplayMessage();\r\n    }\r\n    return \"\";\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.DataSourceIngestJob.setCurrentFileIngestModule",
	"Comment": "set the current module name being run and the file name it is running on.to be used for more detailed cancelling.",
	"Method": "void setCurrentFileIngestModule(String moduleName,String taskName){\r\n    this.currentFileIngestModule = moduleName;\r\n    this.currentFileIngestTask = taskName;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestManager.fireDataSourceAnalysisStarted",
	"Comment": "publishes an ingest job event signifying analysis of a data sourcestarted.",
	"Method": "void fireDataSourceAnalysisStarted(long ingestJobId,long dataSourceIngestJobId,Content dataSource){\r\n    AutopsyEvent event = new DataSourceAnalysisStartedEvent(ingestJobId, dataSourceIngestJobId, dataSource);\r\n    eventPublishingExecutor.submit(new PublishEventTask(event, jobEventPublisher));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestJobSettings.getWarnings",
	"Comment": "gets and clears any accumulated warnings associated with the loading orsaving of these ingest job settings.",
	"Method": "List<String> getWarnings(){\r\n    List<String> warningMessages = new ArrayList(this.warnings);\r\n    this.warnings.clear();\r\n    return warningMessages;\r\n}"
}, {
	"Path": "com.aliyun.oss.internal.ResponseParsers.parseBucketImage",
	"Comment": "unmarshall get bucket image response body to corresponding result.",
	"Method": "GetBucketImageResult parseBucketImage(InputStream responseBody){\r\n    try {\r\n        Element root = getXmlRootElement(responseBody);\r\n        GetBucketImageResult result = new GetBucketImageResult();\r\n        result.SetBucketName(root.getChildText(\"Name\"));\r\n        result.SetDefault404Pic(root.getChildText(\"Default404Pic\"));\r\n        result.SetStyleDelimiters(root.getChildText(\"StyleDelimiters\"));\r\n        result.SetStatus(root.getChildText(\"Status\"));\r\n        result.SetIsAutoSetContentType(root.getChildText(\"AutoSetContentType\").equals(\"True\"));\r\n        result.SetIsForbidOrigPicAccess(root.getChildText(\"OrigPicForbidden\").equals(\"True\"));\r\n        result.SetIsSetAttachName(root.getChildText(\"SetAttachName\").equals(\"True\"));\r\n        result.SetIsUseStyleOnly(root.getChildText(\"UseStyleOnly\").equals(\"True\"));\r\n        result.SetIsUseSrcFormat(root.getChildText(\"UseSrcFormat\").equals(\"True\"));\r\n        return result;\r\n    } catch (JDOMParseException e) {\r\n        throw new ResponseParseException(e.getPartialDocument() + \": \" + e.getMessage(), e);\r\n    } catch (Exception e) {\r\n        throw new ResponseParseException(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.datamodel.CategoryManager.getTagName",
	"Comment": "get the tagname used to store this category in the main autopsy db.",
	"Method": "TagName getTagName(DhsImageCategory cat){\r\n    return catTagNameMap.getUnchecked(cat);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.ImageUtils.getCachedThumbnailLocation",
	"Comment": "get the location,as a java file, of the cached thumbnail for an file withthe given fileid . the returned file may not exist on disk yet.",
	"Method": "File getCachedThumbnailLocation(long fileID){\r\n    return cacheFileMap.computeIfAbsent(fileID, id -> {\r\n        try {\r\n            String cacheDirectory = Case.getCurrentCaseThrows().getCacheDirectory();\r\n            return Paths.get(cacheDirectory, \"thumbnails\", fileID + \".png\").toFile();\r\n        } catch (NoCurrentCaseException e) {\r\n            LOGGER.log(Level.INFO, \"Could not get cached thumbnail location.  No case is open.\");\r\n            return null;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.aliyun.oss.model.UploadPartCopyResult.setETag",
	"Comment": "sets the etag value.oss would send the md5 value of the parts data received to user in theetag header. to make sure the data transferred is 100% correct, westrongly encouraged user to check the server side md5 with the localcomputed md5 value.",
	"Method": "void setETag(String eTag){\r\n    this.eTag = eTag;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.core.UserPreferences.showOnlyCurrentUserTags",
	"Comment": "get the user preference which identifies whether tags should be shown foronly the current user or all users.",
	"Method": "boolean showOnlyCurrentUserTags(){\r\n    return preferences.getBoolean(SHOW_ONLY_CURRENT_USER_TAGS, false);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.optionspanel.EamDbSettingsDialog.setTextBoxListeners",
	"Comment": "register for notifications when the text boxes get updated.",
	"Method": "void setTextBoxListeners(){\r\n    textBoxes.add(tfDatabasePath);\r\n    textBoxes.add(tbDbHostname);\r\n    textBoxes.add(tbDbPort);\r\n    textBoxes.add(tbDbUsername);\r\n    textBoxes.add(jpDbPassword);\r\n    addDocumentListeners(textBoxes, textBoxChangedListener);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.stix.EvaluatableObject.findArtifactsBySubstring",
	"Comment": "find a list of artifacts with the given attribute type that contain thestring object. all comparisons will look for substrings of the blackboardartifacts that match the string object.",
	"Method": "List<BlackboardArtifact> findArtifactsBySubstring(StringObjectPropertyType item,BlackboardAttribute.ATTRIBUTE_TYPE attrType){\r\n    if (item.getValue() == null) {\r\n        throw new TskCoreException(\"Error: Value field is null\");\r\n    }\r\n    if (item.getCondition() == null) {\r\n        addWarning(\"Warning: No condition given for \" + attrType.getDisplayName() + \" field, using substring comparison\");\r\n    } else if (item.getCondition() != ConditionTypeEnum.CONTAINS) {\r\n        addWarning(\"Warning: Ignoring condition \" + item.getCondition() + \" for \" + attrType.getDisplayName() + \" field and doing substring comparison\");\r\n    }\r\n    List<BlackboardArtifact> hits = null;\r\n    try {\r\n        Case case1 = Case.getCurrentCaseThrows();\r\n        SleuthkitCase sleuthkitCase = case1.getSleuthkitCase();\r\n        String[] parts = item.getValue().toString().split(\"##comma##\");\r\n        if ((item.getApplyCondition() == null) || (item.getApplyCondition() == ConditionApplicationEnum.ANY)) {\r\n            for (String part : parts) {\r\n                if (hits == null) {\r\n                    hits = sleuthkitCase.getBlackboardArtifacts(attrType, part, false);\r\n                } else {\r\n                    hits.addAll(sleuthkitCase.getBlackboardArtifacts(attrType, part, false));\r\n                }\r\n            }\r\n        } else if ((item.getApplyCondition() != null) || (item.getApplyCondition() == ConditionApplicationEnum.ALL)) {\r\n            boolean firstRound = true;\r\n            for (String part : parts) {\r\n                if (firstRound) {\r\n                    hits = sleuthkitCase.getBlackboardArtifacts(attrType, part, false);\r\n                    firstRound = false;\r\n                } else if (hits != null) {\r\n                    hits.retainAll(sleuthkitCase.getBlackboardArtifacts(attrType, part, false));\r\n                } else {\r\n                    return new ArrayList<BlackboardArtifact>();\r\n                }\r\n            }\r\n        } else {\r\n            throw new TskCoreException(\"Error: Can not apply NONE condition in search\");\r\n        }\r\n    } catch (TskCoreException | NoCurrentCaseException ex) {\r\n        addWarning(ex.getLocalizedMessage());\r\n    }\r\n    return hits;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.db.EventDB.getCombinedEvents",
	"Comment": "get a representation of all the events, within the given time range, thatpass the given filter, grouped by time and description such that filesystem events for the same file, with the same timestamp, are combinedtogether.",
	"Method": "List<CombinedEvent> getCombinedEvents(Interval timeRange,RootFilter filter){\r\n    Long startTime = timeRange.getStartMillis() / 1000;\r\n    Long endTime = timeRange.getEndMillis() / 1000;\r\n    if (Objects.equals(startTime, endTime)) {\r\n        endTime++;\r\n    }\r\n    ArrayList<CombinedEvent> results = new ArrayList();\r\n    DBLock.lock();\r\n    final String query = \"SELECT full_description, time, file_id, GROUP_CONCAT(events.event_id), GROUP_CONCAT(sub_type)\" + \" FROM events \" + useHashHitTablesHelper(filter) + useTagTablesHelper(filter) + \" WHERE time >= \" + startTime + \" AND time <\" + endTime + \" AND \" + SQLHelper.getSQLWhere(filter) + \" GROUP BY time,full_description, file_id ORDER BY time ASC, full_description\";\r\n    try (Statement stmt = con.createStatement();\r\n        ResultSet rs = stmt.executeQuery(query)) {\r\n        while (rs.next()) {\r\n            List<Long> eventIDs = SQLHelper.unGroupConcat(rs.getString(\"GROUP_CONCAT(events.event_id)\"), Long::valueOf);\r\n            List<EventType> eventTypes = SQLHelper.unGroupConcat(rs.getString(\"GROUP_CONCAT(sub_type)\"), s -> RootEventType.allTypes.get(Integer.valueOf(s)));\r\n            Map<EventType, Long> eventMap = new HashMap();\r\n            for (int i = 0; i < eventIDs.size(); i++) {\r\n                eventMap.put(eventTypes.get(i), eventIDs.get(i));\r\n            }\r\n            results.add(new CombinedEvent(rs.getLong(\"time\") * 1000, rs.getString(\"full_description\"), rs.getLong(\"file_id\"), eventMap));\r\n        }\r\n    } catch (SQLException sqlEx) {\r\n        LOGGER.log(Level.SEVERE, \"failed to execute query for combined events\", sqlEx);\r\n    } finally {\r\n        DBLock.unlock();\r\n    }\r\n    return results;\r\n}"
}, {
	"Path": "com.aliyun.oss.model.CompleteMultipartUploadResult.getCallbackResponseBody",
	"Comment": "deprecated. gets the callback response body. the caller needs to close itafter usage.",
	"Method": "InputStream getCallbackResponseBody(){\r\n    return callbackResponseBody;\r\n}"
}, {
	"Path": "com.litesuits.http.impl.apache.ApacheClient.createHttpParams",
	"Comment": "initialize httpparams , initialize settings such as total connextions,timeout ...",
	"Method": "BasicHttpParams createHttpParams(){\r\n    BasicHttpParams params = new BasicHttpParams();\r\n    ConnManagerParams.setTimeout(params, DEFAULT_TIMEOUT);\r\n    ConnManagerParams.setMaxConnectionsPerRoute(params, new ConnPerRouteBean(DEFAULT_MAX_CONN_PER_ROUT));\r\n    ConnManagerParams.setMaxTotalConnections(params, DEFAULT_MAX_CONN_TOTAL);\r\n    HttpConnectionParams.setTcpNoDelay(params, TCP_NO_DELAY);\r\n    HttpConnectionParams.setConnectionTimeout(params, DEFAULT_TIMEOUT);\r\n    HttpConnectionParams.setSoTimeout(params, DEFAULT_TIMEOUT);\r\n    HttpConnectionParams.setSocketBufferSize(params, DEFAULT_BUFFER_SIZE);\r\n    HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);\r\n    HttpProtocolParams.setUserAgent(params, userAgent);\r\n    return params;\r\n}"
}, {
	"Path": "com.stealthcopter.networktools.ping.PingTools.doPing",
	"Comment": "perform a ping using the native ping tool and fall back to using java echo requeston failure.",
	"Method": "PingResult doPing(InetAddress ia,PingOptions pingOptions){\r\n    try {\r\n        return PingTools.doNativePing(ia, pingOptions);\r\n    } catch (InterruptedException e) {\r\n        PingResult pingResult = new PingResult(ia);\r\n        pingResult.isReachable = false;\r\n        pingResult.error = \"Interrupted\";\r\n        return pingResult;\r\n    } catch (Exception ignored) {\r\n    }\r\n    return PingTools.doJavaPing(ia, pingOptions);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.datamodel.EventCluster.withParent",
	"Comment": "return a new eventcluster identical to this one, except with the giveneventbundle as the parent.",
	"Method": "EventCluster withParent(EventStripe parent){\r\n    return new EventCluster(span, type, eventIDs, hashHits, tagged, description, lod, parent);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.DropdownSingleTermSearchPanel.clearSearchBox",
	"Comment": "clears the text in the query text field, i.e., sets it to the emtpystring.",
	"Method": "void clearSearchBox(){\r\n    keywordTextField.setText(\"\");\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.Case.getCurrentCase",
	"Comment": "gets the current case. this method should only be called by clients thatcan be sure a case is currently open. some examples of suitable clientsare data source processors, ingest modules, and report modules.",
	"Method": "Case getCurrentCase(){\r\n    try {\r\n        return getCurrentCaseThrows();\r\n    } catch (NoCurrentCaseException ex) {\r\n        throw new IllegalStateException(NbBundle.getMessage(Case.class, \"Case.getCurCase.exception.noneOpen\"), ex);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.DataContentViewerHex.getOffsetRelativeToCaretPosition",
	"Comment": "calculates the offset relative to the current caret position.",
	"Method": "long getOffsetRelativeToCaretPosition(Long userInput){\r\n    String userSelectedLine;\r\n    try {\r\n        userSelectedLine = outputTextArea.getText().subSequence(Utilities.getRowStart(outputTextArea, outputTextArea.getCaretPosition()), Utilities.getRowEnd(outputTextArea, outputTextArea.getCaretPosition())).toString();\r\n        String hexForUserSelectedLine = userSelectedLine.substring(0, userSelectedLine.indexOf(\":\"));\r\n        return Long.decode(hexForUserSelectedLine) + userInput;\r\n    } catch (BadLocationException | StringIndexOutOfBoundsException | NumberFormatException ex) {\r\n        return -1L;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coordinationservice.CoordinationService.getInstance",
	"Comment": "gets the coordination service for maintaining configuration informationand providing distributed synchronization using a shared hierarchicalnamespace of nodes.",
	"Method": "CoordinationService getInstance(){\r\n    if (null == instance) {\r\n        String rootNode;\r\n        Collection<? extends CoordinationServiceNamespace> providers = Lookup.getDefault().lookupAll(CoordinationServiceNamespace.class);\r\n        Iterator<? extends CoordinationServiceNamespace> it = providers.iterator();\r\n        if (it.hasNext()) {\r\n            rootNode = it.next().getNamespaceRoot();\r\n        } else {\r\n            rootNode = DEFAULT_NAMESPACE_ROOT;\r\n        }\r\n        try {\r\n            instance = new CoordinationService(rootNode);\r\n        } catch (IOException | InterruptedException | KeeperException | CoordinationServiceException ex) {\r\n            throw new CoordinationServiceException(\"Failed to create coordination service\", ex);\r\n        }\r\n    }\r\n    return instance;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.XMLUtil.validateDocument",
	"Comment": "validates a wc3 dom using a schema packaged as a class resource.",
	"Method": "void validateDocument(Document doc,Class<T> clazz,String schemaResourceName){\r\n    PlatformUtil.extractResourceToUserConfigDir(clazz, schemaResourceName, false);\r\n    File schemaFile = new File(Paths.get(PlatformUtil.getUserConfigDirectory(), schemaResourceName).toAbsolutePath().toString());\r\n    SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\r\n    Schema schema = schemaFactory.newSchema(schemaFile);\r\n    Validator validator = schema.newValidator();\r\n    validator.validate(new DOMSource(doc), new DOMResult());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestCasePrioritizedEvent.getUserName",
	"Comment": "gets the user logged in to the node that prioritized the case.",
	"Method": "String getUserName(){\r\n    return userName;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestControlPanel.pause",
	"Comment": "requests a pause of auto ingest processing by the auto ingest manager andhandles updates to the components that implement the pause and resumefeature. note that this feature is needed to get around restrictions onchanging ingest module selections and settings while an ingest job isrunning, and that the auto ingest manager will not actually pause untilthe current auto ingest job completes.",
	"Method": "void pause(boolean buttonClicked){\r\n    pendingTable.setBackground(Color.LIGHT_GRAY);\r\n    pendingTable.setForeground(Color.DARK_GRAY);\r\n    bnPause.setText(org.openide.util.NbBundle.getMessage(AutoIngestControlPanel.class, \"AutoIngestControlPanel.bnResume.text\"));\r\n    bnPause.setToolTipText(org.openide.util.NbBundle.getMessage(AutoIngestControlPanel.class, \"AutoIngestControlPanel.bnPause.toolTipTextResume\"));\r\n    if (buttonClicked) {\r\n        manager.pause();\r\n        bnRefresh.setEnabled(false);\r\n    }\r\n}"
}, {
	"Path": "com.stealthcopter.networktools.WakeOnLan.setTimeout",
	"Comment": "sets the number milliseconds for the timeout on the socket send",
	"Method": "WakeOnLan setTimeout(int timeoutMillis){\r\n    if (timeoutMillis <= 0)\r\n        throw new IllegalArgumentException(\"Timeout cannot be less than zero\");\r\n    this.timeoutMillis = timeoutMillis;\r\n    return this;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.LocalFilesPanel.warnIfPathIsInvalid",
	"Comment": "validates path to selected data source and displays warning if it isinvalid.",
	"Method": "void warnIfPathIsInvalid(List<String> pathsList){\r\n    errorLabel.setVisible(false);\r\n    try {\r\n        final Case.CaseType currentCaseType = Case.getCurrentCaseThrows().getCaseType();\r\n        for (String currentPath : pathsList) {\r\n            if (!PathValidator.isValidForMultiUserCase(currentPath, currentCaseType)) {\r\n                errorLabel.setVisible(true);\r\n                errorLabel.setText(Bundle.LocalFilesPanel_pathValidation_dataSourceOnCDriveError());\r\n                return;\r\n            }\r\n        }\r\n    } catch (NoCurrentCaseException ex) {\r\n        errorLabel.setVisible(true);\r\n        errorLabel.setText(Bundle.LocalFilesPanel_pathValidation_getOpenCase());\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.ReportKML.getDouble",
	"Comment": "get a double from an artifact if it exists, return null otherwise.",
	"Method": "Double getDouble(BlackboardArtifact artifact,BlackboardAttribute.ATTRIBUTE_TYPE type){\r\n    Double returnValue = null;\r\n    try {\r\n        BlackboardAttribute bba = artifact.getAttribute(new BlackboardAttribute.Type(type));\r\n        if (bba != null) {\r\n            Double value = bba.getValueDouble();\r\n            returnValue = value;\r\n        }\r\n    } catch (TskCoreException ex) {\r\n        logger.log(Level.SEVERE, \"Error getting Double value: \" + type.toString(), ex);\r\n    }\r\n    return returnValue;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.volatilityDSP.VolatilityProcessor.runVolatilityPlugin",
	"Comment": "runs a given volatility plugin and parses its output to create artifacts.",
	"Method": "void runVolatilityPlugin(String pluginToRun){\r\n    progressMonitor.setProgressText(\"Running module \" + pluginToRun);\r\n    List<String> commandLine = new ArrayList();\r\n    commandLine.add(\"\\\"\" + executableFile + \"\\\"\");\r\n    File memoryImage = new File(memoryImagePath);\r\n    commandLine.add(\"--filename=\" + memoryImage.getName());\r\n    if (!profile.isEmpty()) {\r\n        commandLine.add(\"--profile=\" + profile);\r\n    }\r\n    commandLine.add(pluginToRun);\r\n    switch(pluginToRun) {\r\n        case \"dlldump\":\r\n        case \"moddump\":\r\n        case \"procdump\":\r\n        case \"dumpregistry\":\r\n        case \"dumpfiles\":\r\n            String outputDir = moduleOutputPath + File.separator + pluginToRun;\r\n            File directory = new File(outputDir);\r\n            if (!directory.exists()) {\r\n                directory.mkdirs();\r\n            }\r\n            commandLine.add(\"--dump-dir=\" + outputDir);\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n    String outputFileAsString = moduleOutputPath + File.separator + pluginToRun + \".txt\";\r\n    ProcessBuilder processBuilder = new ProcessBuilder(commandLine);\r\n    processBuilder.environment().put(\"__COMPAT_LAYER\", \"RunAsInvoker\");\r\n    File outputFile = new File(outputFileAsString);\r\n    processBuilder.redirectOutput(outputFile);\r\n    processBuilder.redirectError(new File(moduleOutputPath + File.separator + \"Volatility_err.txt\"));\r\n    processBuilder.directory(new File(memoryImage.getParent()));\r\n    try {\r\n        int exitVal = ExecUtil.execute(processBuilder);\r\n        if (exitVal != 0) {\r\n            errorMsgs.add(Bundle.VolatilityProcessor_exceptionMessage_errorRunningPlugin(pluginToRun));\r\n            return;\r\n        }\r\n    } catch (IOException | SecurityException ex) {\r\n        throw new VolatilityProcessorException(Bundle.VolatilityProcessor_exceptionMessage_failedToRunVolatilityExe(), ex);\r\n    }\r\n    if (isCancelled) {\r\n        return;\r\n    }\r\n    try {\r\n        String relativePath = new File(currentCase.getCaseDirectory()).toURI().relativize(new File(outputFileAsString).toURI()).getPath();\r\n        fileManager.addDerivedFile(pluginToRun, relativePath, outputFile.length(), 0, 0, 0, 0, true, outputVirtDir, null, null, null, null, EncodingType.NONE);\r\n    } catch (TskCoreException ex) {\r\n        errorMsgs.add(\"Error adding \" + pluginToRun + \" volatility report as a file\");\r\n        logger.log(Level.WARNING, \"Error adding report as derived file\", ex);\r\n    }\r\n    createArtifactsFromPluginOutput(pluginToRun, new File(outputFileAsString));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.SQLiteTableReader.finalize",
	"Comment": "last ditch effort to close the connections during garbage collection.",
	"Method": "void finalize(){\r\n    try {\r\n        close();\r\n    } catch (SQLiteTableReaderException ex) {\r\n        logger.log(Level.SEVERE, \"Failed to close reader in finalizer\", ex);\r\n    }\r\n    super.finalize();\r\n}"
}, {
	"Path": "org.wikipedia.page.shareafact.SnippetImage.shouldDefaultToCCLicense",
	"Comment": "default to showing creative commons license icon for card as a whole if lead image is not presentor will not be used due to a lack of licensing data.",
	"Method": "boolean shouldDefaultToCCLicense(Bitmap leadImageBitmap,ImageLicense license){\r\n    return leadImageBitmap == null || !license.hasLicenseInfo();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJobLogger.logAnalysisCancelled",
	"Comment": "logs the cancellation of analysis of a data source by the ingest modules.",
	"Method": "void logAnalysisCancelled(){\r\n    log(MessageCategory.WARNING, \"Analysis of data source cancelled\");\r\n}"
}, {
	"Path": "org.wikipedia.feed.view.ListCardView.initRecycler",
	"Comment": "called by the constructor. override to provide custom behavior but otherwise do not calldirectly.",
	"Method": "void initRecycler(RecyclerView recyclerView){\r\n    recyclerView.setLayoutManager(new LinearLayoutManager(getContext()));\r\n    recyclerView.addItemDecoration(new DrawableItemDecoration(getContext(), R.attr.list_separator_drawable));\r\n    recyclerView.setNestedScrollingEnabled(false);\r\n}"
}, {
	"Path": "com.badlogic.ashley.utils.Bag.clear",
	"Comment": "removes all of the elements from this bag. the bag will be empty after this call returns.",
	"Method": "void clear(){\r\n    for (int i = 0; i < size; i++) {\r\n        data[i] = null;\r\n    }\r\n    size = 0;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coordinationservice.CoordinationService.isZooKeeperAccessible",
	"Comment": "determines if zookeeper is accessible with the current settings. closesthe connection prior to returning.",
	"Method": "boolean isZooKeeperAccessible(){\r\n    boolean result = false;\r\n    Object workerThreadWaitNotifyLock = new Object();\r\n    int zooKeeperServerPort = Integer.valueOf(UserPreferences.getIndexingServerPort()) + PORT_OFFSET;\r\n    String connectString = UserPreferences.getIndexingServerHost() + \":\" + zooKeeperServerPort;\r\n    ZooKeeper zooKeeper = new ZooKeeper(connectString, ZOOKEEPER_SESSION_TIMEOUT_MILLIS, (WatchedEvent event) -> {\r\n        synchronized (workerThreadWaitNotifyLock) {\r\n            workerThreadWaitNotifyLock.notify();\r\n        }\r\n    });\r\n    synchronized (workerThreadWaitNotifyLock) {\r\n        workerThreadWaitNotifyLock.wait(ZOOKEEPER_CONNECTION_TIMEOUT_MILLIS);\r\n    }\r\n    ZooKeeper.States state = zooKeeper.getState();\r\n    if (state == ZooKeeper.States.CONNECTED || state == ZooKeeper.States.CONNECTEDREADONLY) {\r\n        result = true;\r\n    }\r\n    zooKeeper.close();\r\n    return result;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.TextPrompt.checkForPrompt",
	"Comment": "check whether the prompt should be visible or not. the visibility willchange on updates to the document and on focus changes.",
	"Method": "void checkForPrompt(){\r\n    if (document.getLength() > 0) {\r\n        setVisible(false);\r\n        return;\r\n    }\r\n    if (showPromptOnce && focusLost > 0) {\r\n        setVisible(false);\r\n        return;\r\n    }\r\n    if (component.hasFocus()) {\r\n        if (show == Show.ALWAYS || show == Show.FOCUS_GAINED) {\r\n            setVisible(true);\r\n        } else {\r\n            setVisible(false);\r\n        }\r\n    } else {\r\n        if (show == Show.ALWAYS || show == Show.FOCUS_LOST) {\r\n            setVisible(true);\r\n        } else {\r\n            setVisible(false);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.ui.detailview.EventClusterNode.getNewCollapseButton",
	"Comment": "get a new button configured to collapse this cluster when pressed.",
	"Method": "Button getNewCollapseButton(){\r\n    return ActionUtils.createButton(new CollapseClusterAction(this), ActionUtils.ActionTextBehavior.HIDE);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.ui.ViewFrame.setViewSettingsControls",
	"Comment": "show the given list of nodes in the top toolbar. replaces any settingsnodes that may have previously been set with the given list of nodes.",
	"Method": "void setViewSettingsControls(List<Node> newSettingsNodes){\r\n    toolBar.getItems().removeAll(this.settingsNodes);\r\n    this.settingsNodes.setAll(newSettingsNodes);\r\n    toolBar.getItems().addAll(SETTINGS_TOOLBAR_INSERTION_INDEX, settingsNodes);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.SingleUserCaseConverter.populateNullableNumeric",
	"Comment": "place a null inside a prepared statement if needed, otherwise, place thedouble that was in the resultset.",
	"Method": "void populateNullableNumeric(PreparedStatement pst,ResultSet rs,int rsIndex,int psIndex){\r\n    double nullableNumeric = rs.getDouble(rsIndex);\r\n    if (rs.wasNull()) {\r\n        pst.setNull(psIndex, java.sql.Types.NULL);\r\n    } else {\r\n        pst.setDouble(psIndex, nullableNumeric);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.stix.EvalFileObj.processTimestampObject",
	"Comment": "create the sql clause for a timestamp object. converts the time into anumeric field and then creates the clause from that.",
	"Method": "String processTimestampObject(DateTimeObjectPropertyType dateObj,String fieldName){\r\n    if (DatatypeEnum.DATE_TIME == dateObj.getDatatype()) {\r\n        String result = convertTimestampString(dateObj.getValue().toString());\r\n        return processNumericFields(result, dateObj.getCondition(), dateObj.getApplyCondition(), fieldName);\r\n    } else {\r\n        throw new TskCoreException(\"Found non DATE_TIME field on \" + fieldName);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.TimeLineController.monitorTask",
	"Comment": "submit a task for execution and add it to the list of tasks whoseprogress is monitored and displayed in the progress bar",
	"Method": "void monitorTask(Task<?> task){\r\n    if (task != null) {\r\n        Platform.runLater(() -> {\r\n            task.stateProperty().addListener((Observable observable) -> {\r\n                switch(task.getState()) {\r\n                    case READY:\r\n                    case RUNNING:\r\n                    case SCHEDULED:\r\n                        break;\r\n                    case SUCCEEDED:\r\n                    case CANCELLED:\r\n                    case FAILED:\r\n                        tasks.remove(task);\r\n                        if (tasks.isEmpty() == false) {\r\n                            taskProgress.bind(tasks.get(0).progressProperty());\r\n                            taskMessage.bind(tasks.get(0).messageProperty());\r\n                            taskTitle.bind(tasks.get(0).titleProperty());\r\n                        }\r\n                        break;\r\n                }\r\n            });\r\n            tasks.add(task);\r\n            taskProgress.bind(task.progressProperty());\r\n            taskMessage.bind(task.messageProperty());\r\n            taskTitle.bind(task.titleProperty());\r\n            switch(task.getState()) {\r\n                case READY:\r\n                    executor.submit(task);\r\n                    break;\r\n                case SCHEDULED:\r\n                case RUNNING:\r\n                case SUCCEEDED:\r\n                case CANCELLED:\r\n                case FAILED:\r\n                    tasks.remove(task);\r\n                    if (tasks.isEmpty() == false) {\r\n                        taskProgress.bind(tasks.get(0).progressProperty());\r\n                        taskMessage.bind(tasks.get(0).messageProperty());\r\n                        taskTitle.bind(tasks.get(0).titleProperty());\r\n                    }\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.communications.FiltersPanel.setAllSelected",
	"Comment": "helper method that sets all the checkboxes in the given map to the givenselection state.",
	"Method": "void setAllSelected(Map<?, JCheckBox> map,boolean selected){\r\n    map.values().forEach(box -> box.setSelected(selected));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.MultiUserSettingsPanel.configureTextPrompts",
	"Comment": "sets the foreground color and transparency of a collection of textprompts.",
	"Method": "void configureTextPrompts(Collection<TextPrompt> textPrompts){\r\n    float alpha = 0.9f;\r\n    for (TextPrompt textPrompt : textPrompts) {\r\n        textPrompt.setForeground(Color.LIGHT_GRAY);\r\n        textPrompt.changeAlpha(alpha);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.filetypeid.FileTypeIdGlobalSettingsPanel.customizeComponents",
	"Comment": "does child component initialization in addition to that done by thematisse generated code.",
	"Method": "void customizeComponents(){\r\n    setName(Bundle.FileTypeIdGlobalSettingsPanel_Title());\r\n    setFileTypesListModel();\r\n    setSignaturesListModel();\r\n    setSignatureTypeComboBoxModel();\r\n    setOffsetRealtiveToComboBoxModel();\r\n    addTypeListSelectionListener();\r\n    populateTypeDetailsComponents();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.SqliteEamDb.isArtifactKnownBadByReference",
	"Comment": "is the artifact known as bad according to the reference entries?",
	"Method": "boolean isArtifactKnownBadByReference(CorrelationAttributeInstance.Type aType,String value){\r\n    try {\r\n        acquireSharedLock();\r\n        return super.isArtifactKnownBadByReference(aType, value);\r\n    } finally {\r\n        releaseSharedLock();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.DataSourceIngestJob.isCancelled",
	"Comment": "queries whether or not cancellation, i.e., a shutdown of the data sourcelevel and file level ingest pipelines for this job, has been requested.",
	"Method": "boolean isCancelled(boolean isCancelled){\r\n    return this.cancelled;\r\n}"
}, {
	"Path": "com.google.example.games.tbmpskeleton.SkeletonActivity.handleException",
	"Comment": "since a lot of the operations use tasks, we can use a common handler for whenever one fails.",
	"Method": "void handleException(Exception exception,String details){\r\n    int status = 0;\r\n    if (exception instanceof TurnBasedMultiplayerClient.MatchOutOfDateApiException) {\r\n        TurnBasedMultiplayerClient.MatchOutOfDateApiException matchOutOfDateApiException = (TurnBasedMultiplayerClient.MatchOutOfDateApiException) exception;\r\n        new AlertDialog.Builder(this).setMessage(\"Match was out of date, updating with latest match data...\").setNeutralButton(android.R.string.ok, null).show();\r\n        TurnBasedMatch match = matchOutOfDateApiException.getMatch();\r\n        updateMatch(match);\r\n        return;\r\n    }\r\n    if (exception instanceof ApiException) {\r\n        ApiException apiException = (ApiException) exception;\r\n        status = apiException.getStatusCode();\r\n    }\r\n    if (!checkStatusCode(status)) {\r\n        return;\r\n    }\r\n    String message = getString(R.string.status_exception_error, details, status, exception);\r\n    new AlertDialog.Builder(this).setMessage(message).setNeutralButton(android.R.string.ok, null).show();\r\n}"
}, {
	"Path": "org.wikipedia.page.PageActivity.updateFeaturedPageWidget",
	"Comment": "update any instances of our featured page widget, since it will change with the currently selected language.",
	"Method": "void updateFeaturedPageWidget(){\r\n    Intent widgetIntent = new Intent(this, WidgetProviderFeaturedPage.class);\r\n    widgetIntent.setAction(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\r\n    int[] ids = AppWidgetManager.getInstance(getApplication()).getAppWidgetIds(new ComponentName(this, WidgetProviderFeaturedPage.class));\r\n    widgetIntent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, ids);\r\n    sendBroadcast(widgetIntent);\r\n}"
}, {
	"Path": "com.aliyun.oss.model.ObjectMetadata.isRestoreCompleted",
	"Comment": "gets the flag of completeness of restoring the archive file.",
	"Method": "boolean isRestoreCompleted(){\r\n    String restoreString = getObjectRawRestore();\r\n    if (restoreString == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    if (restoreString.equals(OSSHeaders.OSS_ONGOING_RESTORE)) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.events.DataSourceAnalysisEvent.getIngestJobId",
	"Comment": "gets the id of the ingest job of which the analysis of this data sourceis a part.",
	"Method": "long getIngestJobId(){\r\n    return ingestJobId;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.KeywordSearchIngestModule.shutDown",
	"Comment": "after all files are ingested, execute final index commit and final searchcleanup resources, threads, timers",
	"Method": "void shutDown(){\r\n    logger.log(Level.INFO, \"Keyword search ingest module instance {0} shutting down\", instanceNum);\r\n    if ((initialized == false) || (context == null)) {\r\n        return;\r\n    }\r\n    if (context.fileIngestIsCancelled()) {\r\n        logger.log(Level.INFO, \"Keyword search ingest module instance {0} stopping search job due to ingest cancellation\", instanceNum);\r\n        IngestSearchRunner.getInstance().stopJob(jobId);\r\n        cleanup();\r\n        return;\r\n    }\r\n    IngestSearchRunner.getInstance().endJob(jobId);\r\n    if (refCounter.decrementAndGet(jobId) == 0) {\r\n        try {\r\n            final int numIndexedFiles = KeywordSearch.getServer().queryNumIndexedFiles();\r\n            logger.log(Level.INFO, \"Indexed files count: {0}\", numIndexedFiles);\r\n            final int numIndexedChunks = KeywordSearch.getServer().queryNumIndexedChunks();\r\n            logger.log(Level.INFO, \"Indexed file chunks count: {0}\", numIndexedChunks);\r\n        } catch (NoOpenCoreException | KeywordSearchModuleException ex) {\r\n            logger.log(Level.SEVERE, \"Error executing Solr queries to check number of indexed files and file chunks\", ex);\r\n        }\r\n        postIndexSummary();\r\n        synchronized (ingestStatus) {\r\n            ingestStatus.remove(jobId);\r\n        }\r\n    }\r\n    cleanup();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.healthmonitor.HealthMonitor.connect",
	"Comment": "get a database connection. sets up the connection pool if needed.",
	"Method": "Connection connect(){\r\n    synchronized (this) {\r\n        if (connectionPool == null) {\r\n            setupConnectionPool();\r\n        }\r\n    }\r\n    try {\r\n        return connectionPool.getConnection();\r\n    } catch (SQLException ex) {\r\n        throw new HealthMonitorException(\"Error getting connection from connection pool.\", ex);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.actions.UndoRedoManager.redo",
	"Comment": "flip the top redo command over to the undo stack, after applying it",
	"Method": "Optional<UndoableCommand> redo(){\r\n    if (redoStack.isEmpty()) {\r\n        return Optional.empty();\r\n    } else {\r\n        UndoableCommand pop = redoStack.pop();\r\n        undoStack.push(pop);\r\n        pop.run();\r\n        return Optional.of(pop);\r\n    }\r\n}"
}, {
	"Path": "com.aliyun.oss.common.utils.StringUtils.fromDouble",
	"Comment": "returns the string representation of the specified double.",
	"Method": "String fromDouble(Double d){\r\n    return Double.toString(d);\r\n}"
}, {
	"Path": "com.mcxiaoke.next.ui.widget.ArrayAdapterCompat.insert",
	"Comment": "inserts the specified object at the specified index in the array.",
	"Method": "void insert(T object,int index){\r\n    synchronized (mLock) {\r\n        if (mOriginalValues != null) {\r\n            mOriginalValues.add(index, object);\r\n        } else {\r\n            mObjects.add(index, object);\r\n        }\r\n    }\r\n    if (mNotifyOnChange)\r\n        notifyDataSetChanged();\r\n}"
}, {
	"Path": "com.mcxiaoke.next.io.CountingOutputStream.beforeWrite",
	"Comment": "updates the count with the number of bytes that are being written.",
	"Method": "void beforeWrite(int n){\r\n    count += n;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.hashdatabase.HashDbManager.addNewHashDatabase",
	"Comment": "adds a new hash database to the set of hash databases used to classifyfiles as known or notable and saves the configuration.",
	"Method": "HashDb addNewHashDatabase(String hashSetName,String path,boolean searchDuringIngest,boolean sendIngestMessages,HashDb.KnownFilesType knownFilesType){\r\n    HashDb hashDb = null;\r\n    hashDb = this.addNewHashDatabaseNoSave(hashSetName, path, searchDuringIngest, sendIngestMessages, knownFilesType);\r\n    this.save();\r\n    return hashDb;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.gui.Toolbar.showPopoverHelp",
	"Comment": "static utility to to show a popover with the given node as owner.",
	"Method": "void showPopoverHelp(Node owner,String headerText,Image headerImage,Node content){\r\n    Pane borderPane = new BorderPane(null, null, new ImageView(headerImage), content, new Label(headerText));\r\n    borderPane.setPadding(new Insets(10));\r\n    borderPane.setPrefWidth(500);\r\n    PopOver popOver = new PopOver(borderPane);\r\n    popOver.setDetachable(false);\r\n    popOver.setArrowLocation(PopOver.ArrowLocation.TOP_CENTER);\r\n    popOver.show(owner);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.ImageGalleryController.getAllDataSourcesDrawableDBStatus",
	"Comment": "returns a map of all data source object ids, along with their db buildstatus.this includes any data sources already in the table, and any data sourcesthat might have been added to the case, but are not in the datasourcestable.",
	"Method": "Map<Long, DrawableDbBuildStatusEnum> getAllDataSourcesDrawableDBStatus(){\r\n    Map<Long, DrawableDbBuildStatusEnum> dataSourceStatusMap = new HashMap();\r\n    if ((null == getDatabase()) || (null == getSleuthKitCase())) {\r\n        return dataSourceStatusMap;\r\n    }\r\n    try {\r\n        Map<Long, DrawableDbBuildStatusEnum> knownDataSourceIds = getDatabase().getDataSourceDbBuildStatus();\r\n        List<DataSource> dataSources = getSleuthKitCase().getDataSources();\r\n        Set<Long> caseDataSourceIds = new HashSet();\r\n        dataSources.stream().map(DataSource::getId).forEach(caseDataSourceIds::add);\r\n        knownDataSourceIds.entrySet().stream().forEach((Map.Entry<Long, DrawableDbBuildStatusEnum> t) -> {\r\n            dataSourceStatusMap.put(t.getKey(), t.getValue());\r\n        });\r\n        caseDataSourceIds.forEach((Long id) -> {\r\n            if (!knownDataSourceIds.containsKey(id)) {\r\n                dataSourceStatusMap.put(id, DrawableDbBuildStatusEnum.UNKNOWN);\r\n            }\r\n        });\r\n        return dataSourceStatusMap;\r\n    } catch (TskCoreException ex) {\r\n        logger.log(Level.SEVERE, \"Image Gallery failed to get data source DB status.\", ex);\r\n        return dataSourceStatusMap;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilessearch.IntraCaseTestUtils.verifyInstanceExistanceAndCount",
	"Comment": "verify that the given file appears a precise number times in the givendata source.",
	"Method": "boolean verifyInstanceExistanceAndCount(List<AbstractFile> searchDomain,Map<Long, String> objectIdToDataSourceMap,String fileName,String dataSource,int instanceCount){\r\n    int tally = 0;\r\n    for (AbstractFile file : searchDomain) {\r\n        Long objectId = file.getId();\r\n        String name = file.getName();\r\n        String dataSourceName = objectIdToDataSourceMap.get(objectId);\r\n        if (name.equalsIgnoreCase(fileName) && dataSourceName.equalsIgnoreCase(dataSource)) {\r\n            tally++;\r\n        }\r\n    }\r\n    return tally == instanceCount;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.PostgresEamDbSettings.getEphemeralConnection",
	"Comment": "use the current settings to get an ephemeral client connection fortesting.",
	"Method": "Connection getEphemeralConnection(boolean usePostgresDb){\r\n    Connection conn;\r\n    try {\r\n        String url = getConnectionURL(usePostgresDb);\r\n        Properties props = new Properties();\r\n        props.setProperty(\"user\", getUserName());\r\n        props.setProperty(\"password\", getPassword());\r\n        Class.forName(getDriver());\r\n        conn = DriverManager.getConnection(url, props);\r\n    } catch (ClassNotFoundException | SQLException ex) {\r\n        LOGGER.log(Level.SEVERE, \"Failed to acquire ephemeral connection to postgresql.\");\r\n        conn = null;\r\n    }\r\n    return conn;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.directorytree.ExternalViewerRulesManager.loadUserDefinedRules",
	"Comment": "loads user defined rules from the configuration settings file.",
	"Method": "void loadUserDefinedRules(){\r\n    String setting = ModuleSettings.getConfigSetting(RULES_SETTINGS_NAME, RULES_SETTINGS_KEY);\r\n    if (setting != null && !setting.isEmpty()) {\r\n        List<String> ruleTuples = Arrays.asList(setting.split(\"\\\\|\"));\r\n        for (String ruleTuple : ruleTuples) {\r\n            String[] ruleParts = ruleTuple.split(\">\");\r\n            userRules.add(new ExternalViewerRule(ruleParts[0], ruleParts[1], ExternalViewerRule.RuleType.valueOf(ruleParts[2])));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJobLogger.logAnalysisStartupError",
	"Comment": "logs failure to analyze a data source because the analysis could not bestarted due to an ingest manager exception.",
	"Method": "void logAnalysisStartupError(){\r\n    log(MessageCategory.ERROR, \"Failed to analyze data source due to ingest job startup error\");\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AinStatusPanel.addListSelectionListener",
	"Comment": "add a list selection listener to the selection model of the outline beingused in this panel.",
	"Method": "void addListSelectionListener(ListSelectionListener listener){\r\n    outline.getSelectionModel().addListSelectionListener(listener);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.FileExportSettings.getExportCompletedFlagFileName",
	"Comment": "gets the name of the file written to indicate file export is completed.",
	"Method": "String getExportCompletedFlagFileName(){\r\n    return this.exportCompletedFlagFileName;\r\n}"
}, {
	"Path": "com.anysoftkeyboard.dictionaries.BTreeDictionary.getWordsRec",
	"Comment": "recursively traverse the tree for words that match the input. inputconsists of a list of arrays. each item in the list is one inputcharacter position. an input character is actually an array of multiplepossible candidates. this function is not optimized for speed, assumingthat the user dictionary will only be a few hundred words in size.",
	"Method": "void getWordsRec(NodeArray roots,KeyCodesProvider codes,char[] word,int depth,boolean completion,float snr,int inputIndex,WordCallback callback){\r\n    final int count = roots.length;\r\n    final int codeSize = mInputLength;\r\n    if (depth > mMaxDepth) {\r\n        return;\r\n    }\r\n    int[] currentChars = null;\r\n    if (codeSize <= inputIndex) {\r\n        completion = true;\r\n    } else {\r\n        currentChars = codes.getCodesAt(inputIndex);\r\n    }\r\n    for (int i = 0; i < count; i++) {\r\n        final Node node = roots.data[i];\r\n        final char nodeC = node.code;\r\n        final char nodeLowerC = toLowerCase(nodeC);\r\n        boolean terminal = node.terminal;\r\n        NodeArray children = node.children;\r\n        int freq = node.frequency;\r\n        if (completion) {\r\n            word[depth] = nodeC;\r\n            if (terminal && !callback.addWord(word, 0, depth + 1, (int) (freq * snr), this)) {\r\n                return;\r\n            }\r\n            if (children != null) {\r\n                getWordsRec(children, codes, word, depth + 1, completion, snr, inputIndex, callback);\r\n            }\r\n        } else {\r\n            for (int j = 0; j < currentChars.length; j++) {\r\n                float addedAttenuation = (j > 0 ? 1f : 3f);\r\n                if (currentChars[j] == -1) {\r\n                    break;\r\n                }\r\n                final char currentTypedChar = (char) currentChars[j];\r\n                final char currentLowerTypedChar = toLowerCase(currentTypedChar);\r\n                if (currentLowerTypedChar == nodeLowerC || currentTypedChar == nodeC) {\r\n                    word[depth] = nodeC;\r\n                    if (codeSize == depth + 1) {\r\n                        if (terminal && (mIncludeTypedWord || !same(word, depth + 1, codes.getTypedWord()))) {\r\n                            callback.addWord(word, 0, depth + 1, (int) (freq * snr * addedAttenuation * FULL_WORD_FREQ_MULTIPLIER), this);\r\n                        }\r\n                        if (children != null) {\r\n                            getWordsRec(children, codes, word, depth + 1, true, snr * addedAttenuation, inputIndex + 1, callback);\r\n                        }\r\n                    } else if (children != null) {\r\n                        getWordsRec(children, codes, word, depth + 1, false, snr * addedAttenuation, inputIndex + 1, callback);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.interestingitems.InterestingItemsFilesSetSettings.readDateCondition",
	"Comment": "construct a date condition for a filesset membership rule from data in anxml element.",
	"Method": "DateCondition readDateCondition(Element ruleElement){\r\n    DateCondition dateCondition = null;\r\n    if (!ruleElement.getAttribute(DAYS_INCLUDED_ATTR).isEmpty()) {\r\n        String daysIncluded = ruleElement.getAttribute(DAYS_INCLUDED_ATTR);\r\n        if (!daysIncluded.isEmpty()) {\r\n            try {\r\n                dateCondition = new DateCondition(Integer.parseInt(daysIncluded));\r\n            } catch (NumberFormatException ex) {\r\n                logger.log(Level.SEVERE, \"Error creating condition for \" + daysIncluded + \", ignoring malformed date condition definition\", ex);\r\n                throw new FilesSetsManager.FilesSetsManagerException(String.format(\"error compiling %s regex\", DAYS_INCLUDED_ATTR), ex);\r\n            }\r\n        }\r\n    }\r\n    return dateCondition;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.SqliteEamDb.releaseExclusiveLock",
	"Comment": "release the lock that provides exclusive access to the database. thismethod should always be called in the finally block of a try block inwhich the lock was acquired.",
	"Method": "void releaseExclusiveLock(){\r\n    rwLock.writeLock().unlock();\r\n}"
}, {
	"Path": "com.aliyun.oss.internal.ResponseParsers.parseGetBucketImageProcessConf",
	"Comment": "unmarshall get bucket process response body to bucket process.",
	"Method": "BucketProcess parseGetBucketImageProcessConf(InputStream responseBody){\r\n    try {\r\n        Element root = getXmlRootElement(responseBody);\r\n        String compliedHost = root.getChildText(\"CompliedHost\");\r\n        boolean sourceFileProtect = false;\r\n        if (root.getChildText(\"SourceFileProtect\").equals(\"Enabled\")) {\r\n            sourceFileProtect = true;\r\n        }\r\n        String sourceFileProtectSuffix = root.getChildText(\"SourceFileProtectSuffix\");\r\n        String styleDelimiters = root.getChildText(\"StyleDelimiters\");\r\n        ImageProcess imageProcess = new ImageProcess(compliedHost, sourceFileProtect, sourceFileProtectSuffix, styleDelimiters);\r\n        if (root.getChildText(\"Version\") != null) {\r\n            imageProcess.setVersion(Integer.parseInt(root.getChildText(\"Version\")));\r\n        }\r\n        return new BucketProcess(imageProcess);\r\n    } catch (JDOMParseException e) {\r\n        throw new ResponseParseException(e.getPartialDocument() + \": \" + e.getMessage(), e);\r\n    } catch (Exception e) {\r\n        throw new ResponseParseException(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "com.facebook.samples.gestures.MultiPointerGestureDetector.stopGesture",
	"Comment": "stops the current gesture and calls the listener right after stopping it.",
	"Method": "void stopGesture(){\r\n    if (mGestureInProgress) {\r\n        mGestureInProgress = false;\r\n        if (mListener != null) {\r\n            mListener.onGestureEnd(this);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.actions.NextUnseenGroup.unSeenGroupListener",
	"Comment": "listener that updates ui based on changes to the unseen group list",
	"Method": "void unSeenGroupListener(){\r\n    if (controller.getViewState() == null) {\r\n        advanceToNextUnseenGroup();\r\n    } else if (isLoading == false) {\r\n        updateButton();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.CommonAttributePanel.updatePercentageOptions",
	"Comment": "update the percentage options to reflect the number of data sourcesavailable.",
	"Method": "void updatePercentageOptions(Long numberOfDataSources){\r\n    boolean enabled = numberOfDataSources > 0L;\r\n    String numberOfDataSourcesText = enabled ? Bundle.CommonAttributePanel_dataSourcesLabel_text(numberOfDataSources) : \"\";\r\n    this.dataSourcesLabel.setText(numberOfDataSourcesText);\r\n    this.percentageThresholdInputBox.setEnabled(enabled);\r\n    this.percentageThresholdCheck.setEnabled(enabled);\r\n    this.percentageThresholdCheck.setSelected(enabled);\r\n    this.percentageThresholdTextTwo.setEnabled(enabled);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.hashdatabase.AddHashValuesToDatabaseProgressDialog.addHashValuesToDatabase",
	"Comment": "executes a swingworker which performs addition of hashes into thedatabase.",
	"Method": "void addHashValuesToDatabase(){\r\n    parentRef.enableAddHashValuesToDatabaseDialog(false);\r\n    new SwingWorker<Object, Void>() {\r\n        @Override\r\n        protected Object doInBackground() throws Exception {\r\n            statusLabel.setText(NbBundle.getMessage(AddHashValuesToDatabaseProgressDialog.class, \"AddHashValuesToDatabaseProgressDialog.addHashValuesToDatabase.parsing\"));\r\n            getHashesFromTextArea(text);\r\n            if (!invalidHashes.isEmpty()) {\r\n                statusLabel.setText(NbBundle.getMessage(AddHashValuesToDatabaseProgressDialog.class, \"AddHashValuesToDatabaseProgressDialog.addHashValuesToDatabase.invalidHash\"));\r\n                finish(false);\r\n                errorTitle = NbBundle.getMessage(AddHashValuesToDatabaseProgressDialog.class, \"AddHashValuesToDatabaseProgressDialog.addHashValuesToDatabase.invaliHash.msg\");\r\n                errorMessage = \"\";\r\n                for (String invalidHash : invalidHashes) {\r\n                    errorMessage = errorMessage + invalidHash + \"\\n\";\r\n                }\r\n                showErrorsButton.setVisible(true);\r\n                showErrorsButton.requestFocus();\r\n            } else if (hashes.isEmpty()) {\r\n                statusLabel.setText(NbBundle.getMessage(AddHashValuesToDatabaseProgressDialog.class, \"AddHashValuesToDatabaseProgressDialog.addHashValuesToDatabase.noHashesToAdd\"));\r\n                finish(false);\r\n            } else {\r\n                try {\r\n                    hashDb.addHashes(hashes);\r\n                    okButton.requestFocus();\r\n                    statusLabel.setText(NbBundle.getMessage(AddHashValuesToDatabaseProgressDialog.class, \"AddHashValuesToDatabaseProgressDialog.addHashValuesToDatabase.success\", hashes.size()));\r\n                    finish(true);\r\n                    disposeParent = true;\r\n                } catch (TskCoreException ex) {\r\n                    statusLabel.setText(NbBundle.getMessage(AddHashValuesToDatabaseProgressDialog.class, \"AddHashValuesToDatabaseProgressDialog.addHashValuesToDatabase.errorAddingValidHash\"));\r\n                    finish(false);\r\n                    errorTitle = NbBundle.getMessage(AddHashValuesToDatabaseProgressDialog.class, \"AddHashValuesToDatabaseProgressDialog.addHashValuesToDatabase.errorAddingValidHash.msg\");\r\n                    errorMessage = ex.toString();\r\n                    showErrorsButton.setVisible(true);\r\n                    showErrorsButton.requestFocus();\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n    }.execute();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.hashdatabase.AddHashValuesToDatabaseProgressDialog.addHashValuesToDatabase",
	"Comment": "executes a swingworker which performs addition of hashes into thedatabase.",
	"Method": "void addHashValuesToDatabase(){\r\n    statusLabel.setText(NbBundle.getMessage(AddHashValuesToDatabaseProgressDialog.class, \"AddHashValuesToDatabaseProgressDialog.addHashValuesToDatabase.parsing\"));\r\n    getHashesFromTextArea(text);\r\n    if (!invalidHashes.isEmpty()) {\r\n        statusLabel.setText(NbBundle.getMessage(AddHashValuesToDatabaseProgressDialog.class, \"AddHashValuesToDatabaseProgressDialog.addHashValuesToDatabase.invalidHash\"));\r\n        finish(false);\r\n        errorTitle = NbBundle.getMessage(AddHashValuesToDatabaseProgressDialog.class, \"AddHashValuesToDatabaseProgressDialog.addHashValuesToDatabase.invaliHash.msg\");\r\n        errorMessage = \"\";\r\n        for (String invalidHash : invalidHashes) {\r\n            errorMessage = errorMessage + invalidHash + \"\\n\";\r\n        }\r\n        showErrorsButton.setVisible(true);\r\n        showErrorsButton.requestFocus();\r\n    } else if (hashes.isEmpty()) {\r\n        statusLabel.setText(NbBundle.getMessage(AddHashValuesToDatabaseProgressDialog.class, \"AddHashValuesToDatabaseProgressDialog.addHashValuesToDatabase.noHashesToAdd\"));\r\n        finish(false);\r\n    } else {\r\n        try {\r\n            hashDb.addHashes(hashes);\r\n            okButton.requestFocus();\r\n            statusLabel.setText(NbBundle.getMessage(AddHashValuesToDatabaseProgressDialog.class, \"AddHashValuesToDatabaseProgressDialog.addHashValuesToDatabase.success\", hashes.size()));\r\n            finish(true);\r\n            disposeParent = true;\r\n        } catch (TskCoreException ex) {\r\n            statusLabel.setText(NbBundle.getMessage(AddHashValuesToDatabaseProgressDialog.class, \"AddHashValuesToDatabaseProgressDialog.addHashValuesToDatabase.errorAddingValidHash\"));\r\n            finish(false);\r\n            errorTitle = NbBundle.getMessage(AddHashValuesToDatabaseProgressDialog.class, \"AddHashValuesToDatabaseProgressDialog.addHashValuesToDatabase.errorAddingValidHash.msg\");\r\n            errorMessage = ex.toString();\r\n            showErrorsButton.setVisible(true);\r\n            showErrorsButton.requestFocus();\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.ReportKML.makeLineString",
	"Comment": "create a linestring for use in a placemark. note in this method, startand stop altitudes get ignored, as google earth apparently has troubleusing altitudes for linestrings, though the parameters are still in thecall. also note that any null value passed in will be set to 0.0, underthe idea that it is better to show some data with gaps, than to shownothing at all.",
	"Method": "Element makeLineString(Double startLatitude,Double startLongitude,Double startAltitude,Double stopLatitude,Double stopLongitude,Double stopAltitude){\r\n    if (startLatitude == null) {\r\n        startLatitude = 0.0;\r\n    }\r\n    if (startLongitude == null) {\r\n        startLongitude = 0.0;\r\n    }\r\n    if (startAltitude == null) {\r\n        startAltitude = 0.0;\r\n    }\r\n    if (stopLatitude == null) {\r\n        stopLatitude = 0.0;\r\n    }\r\n    if (stopLongitude == null) {\r\n        stopLongitude = 0.0;\r\n    }\r\n    if (stopAltitude == null) {\r\n        stopAltitude = 0.0;\r\n    }\r\n    Element lineString = new Element(\"LineString\", ns);\r\n    lineString.addContent(new Element(\"extrude\", ns).addContent(\"1\"));\r\n    lineString.addContent(new Element(\"tessellate\", ns).addContent(\"1\"));\r\n    lineString.addContent(new Element(\"altitudeMode\", ns).addContent(\"clampToGround\"));\r\n    lineString.addContent(new Element(\"coordinates\", ns).addContent(startLongitude + \",\" + startLatitude + \",0.0,\" + stopLongitude + \",\" + stopLatitude + \",0.0\"));\r\n    return lineString;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.ImageDSProcessor.getPanel",
	"Comment": "gets the panel that allows a user to select a data source and do anyconfiguration required by the data source. the panel is less than 544pixels wide and less than 173 pixels high.",
	"Method": "JPanel getPanel(){\r\n    configPanel.readSettings();\r\n    configPanel.select();\r\n    return configPanel;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.volatilityDSP.VolatilityProcessor.getErrorMessages",
	"Comment": "gets a list of error messages that were generated during the processing.",
	"Method": "List<String> getErrorMessages(){\r\n    return new ArrayList(errorMsgs);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestMonitor.getFreeSpace",
	"Comment": "gets the free space, in bytes, of the drive where the case folder for thecurrent case resides.",
	"Method": "long getFreeSpace(long getFreeSpace){\r\n    try {\r\n        return timerAction.getFreeSpace();\r\n    } catch (SecurityException e) {\r\n        logger.log(Level.WARNING, \"Error checking for free disk space on ingest data drive\", e);\r\n        return DISK_FREE_SPACE_UNKNOWN;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.hashdatabase.HashLookupModuleSettings.isHashSetEnabled",
	"Comment": "checks whether or not a hash set is enabled. if there is no setting forthe requested hash set, return the default value",
	"Method": "boolean isHashSetEnabled(HashDb db){\r\n    for (HashDbInfo dbInfo : databaseInfoList) {\r\n        if (dbInfo.matches(db)) {\r\n            return dbInfo.getSearchDuringIngest();\r\n        }\r\n    }\r\n    return db.getSearchDuringIngest();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.Case.openServices",
	"Comment": "completes the case opening tasks common to both new cases and existingcases.",
	"Method": "void openServices(ProgressIndicator progressIndicator){\r\n    progressIndicator.progress(Bundle.Case_progressMessage_switchingLogDirectory());\r\n    Logger.setLogDirectory(getLogDirectoryPath());\r\n    if (Thread.currentThread().isInterrupted()) {\r\n        throw new CaseActionCancelledException(Bundle.Case_exceptionMessage_cancelledByUser());\r\n    }\r\n    progressIndicator.progress(Bundle.Case_progressMessage_clearingTempDirectory());\r\n    Case.clearTempSubDir(this.getTempDirectory());\r\n    if (Thread.currentThread().isInterrupted()) {\r\n        throw new CaseActionCancelledException(Bundle.Case_exceptionMessage_cancelledByUser());\r\n    }\r\n    progressIndicator.progress(Bundle.Case_progressMessage_openingCaseLevelServices());\r\n    this.caseServices = new Services(caseDb);\r\n    if (Thread.currentThread().isInterrupted()) {\r\n        throw new CaseActionCancelledException(Bundle.Case_exceptionMessage_cancelledByUser());\r\n    }\r\n    progressIndicator.progress(Bundle.Case_progressMessage_openingApplicationServiceResources());\r\n    openAppServiceCaseResources();\r\n    if (Thread.currentThread().isInterrupted()) {\r\n        throw new CaseActionCancelledException(Bundle.Case_exceptionMessage_cancelledByUser());\r\n    }\r\n    if (CaseType.MULTI_USER_CASE == metadata.getCaseType()) {\r\n        progressIndicator.progress(Bundle.Case_progressMessage_settingUpNetworkCommunications());\r\n        try {\r\n            eventPublisher.openRemoteEventChannel(String.format(EVENT_CHANNEL_NAME, metadata.getCaseName()));\r\n            if (Thread.currentThread().isInterrupted()) {\r\n                throw new CaseActionCancelledException(Bundle.Case_exceptionMessage_cancelledByUser());\r\n            }\r\n            collaborationMonitor = new CollaborationMonitor(metadata.getCaseName());\r\n        } catch (AutopsyEventException | CollaborationMonitor.CollaborationMonitorException ex) {\r\n            logger.log(Level.SEVERE, \"Failed to setup network communications\", ex);\r\n            if (RuntimeProperties.runningWithGUI()) {\r\n                SwingUtilities.invokeLater(() -> MessageNotifyUtil.Notify.error(NbBundle.getMessage(Case.class, \"Case.CollaborationSetup.FailNotify.Title\"), NbBundle.getMessage(Case.class, \"Case.CollaborationSetup.FailNotify.ErrMsg\")));\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.interestingitems.FilesSetPanel.getFilesSetName",
	"Comment": "get the name for the interesting files set defined using this panel.",
	"Method": "String getFilesSetName(){\r\n    String returnValue = this.nameTextField.getText();\r\n    return returnValue;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.configuration.StartupWindow.addPanelForMode",
	"Comment": "adds a panel to the dialog based on operational mode selected by theuser.",
	"Method": "void addPanelForMode(){\r\n    if (UserPreferences.getMode() == UserPreferences.SelectedMode.AUTOINGEST) {\r\n        this.setTitle(NbBundle.getMessage(StartupWindow.class, \"StartupWindow.AutoIngestMode\") + \" (\" + LOCAL_HOST_NAME + \")\");\r\n        setIconImage(ImageUtilities.loadImage(\"org/sleuthkit/autopsy/experimental/images/frame.gif\", false));\r\n        this.addWindowListener(new WindowAdapter() {\r\n            @Override\r\n            public void windowClosing(WindowEvent e) {\r\n                AutoIngestControlPanel.getInstance().shutdown();\r\n            }\r\n        });\r\n        setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);\r\n        add(AutoIngestControlPanel.getInstance());\r\n    } else {\r\n        welcomeWindow = new CueBannerPanel();\r\n        welcomeWindow.setCloseButtonActionListener(new ActionListener() {\r\n            @Override\r\n            public void actionPerformed(ActionEvent e) {\r\n                close();\r\n            }\r\n        });\r\n        add(welcomeWindow);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.configuration.StartupWindow.addPanelForMode",
	"Comment": "adds a panel to the dialog based on operational mode selected by theuser.",
	"Method": "void addPanelForMode(){\r\n    AutoIngestControlPanel.getInstance().shutdown();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.configuration.StartupWindow.addPanelForMode",
	"Comment": "adds a panel to the dialog based on operational mode selected by theuser.",
	"Method": "void addPanelForMode(){\r\n    close();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.services.TagNameDefinition.getTagNameDefinitions",
	"Comment": "gets tag name definitions from the tag settings file as well as thedefault tag name definitions.",
	"Method": "Set<TagNameDefinition> getTagNameDefinitions(){\r\n    Set<TagNameDefinition> tagNames = new LinkedHashSet();\r\n    Set<String> standardTags = new LinkedHashSet(STANDARD_TAG_DISPLAY_NAMES);\r\n    String setting = ModuleSettings.getConfigSetting(TAGS_SETTINGS_NAME, TAG_NAMES_SETTING_KEY);\r\n    if (null != setting && !setting.isEmpty()) {\r\n        List<String> tagNameTuples = Arrays.asList(setting.split(\";\"));\r\n        int numberOfAttributes = 0;\r\n        if (tagNameTuples.size() > 0) {\r\n            numberOfAttributes = tagNameTuples.get(0).split(\",\").length;\r\n        }\r\n        if (numberOfAttributes == 3) {\r\n            tagNames.addAll(upgradeTagPropertiesFile(tagNameTuples, standardTags));\r\n        } else if (numberOfAttributes == 4) {\r\n            tagNames.addAll(readCurrentTagPropertiesFile(tagNameTuples, standardTags));\r\n        }\r\n    }\r\n    for (String standardTagName : standardTags) {\r\n        if (STANDARD_NOTABLE_TAG_DISPLAY_NAMES.contains(standardTagName)) {\r\n            tagNames.add(new TagNameDefinition(standardTagName, \"\", TagName.HTML_COLOR.NONE, TskData.FileKnown.BAD));\r\n        } else {\r\n            tagNames.add(new TagNameDefinition(standardTagName, \"\", TagName.HTML_COLOR.NONE, TskData.FileKnown.UNKNOWN));\r\n        }\r\n    }\r\n    return tagNames;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.Chunker.hasException",
	"Comment": "has this chunker encountered an exception reading from the reader?",
	"Method": "boolean hasException(){\r\n    return ex != null;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJobNodeData.getDeviceId",
	"Comment": "gets the device id of the device associated with the data source for thejob.",
	"Method": "String getDeviceId(){\r\n    return this.deviceId;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.AddImageWizardIngestConfigPanel.getHelp",
	"Comment": "help for this panel. when the panel is active, this is used as the helpfor the wizard dialog.",
	"Method": "HelpCtx getHelp(){\r\n    return HelpCtx.DEFAULT_HELP;\r\n}"
}, {
	"Path": "com.anysoftkeyboard.utils.IMEUtil.removeDupes",
	"Comment": "remove duplicates from an array of strings.this method will always keep the first occurrence of all strings at their positionin the array, removing the subsequent ones.",
	"Method": "void removeDupes(List<CharSequence> suggestions,List<CharSequence> stringsPool){\r\n    if (suggestions.size() < 2)\r\n        return;\r\n    int i = 1;\r\n    while (i < suggestions.size()) {\r\n        final CharSequence cur = suggestions.get(i);\r\n        for (int j = 0; j < i; j++) {\r\n            CharSequence previous = suggestions.get(j);\r\n            if (TextUtils.equals(cur, previous)) {\r\n                removeSuggestion(suggestions, i, stringsPool);\r\n                i--;\r\n                break;\r\n            }\r\n        }\r\n        i++;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.datamodel.DrawableDB.findAllFileIdsWhere",
	"Comment": "find and return list of all ids of files matching the specific whereclause",
	"Method": "Set<Long> findAllFileIdsWhere(String sqlWhereClause){\r\n    dbWriteLock();\r\n    try {\r\n        if (isClosed()) {\r\n            throw new TskCoreException(\"The drawables database is closed\");\r\n        }\r\n        try (Statement statement = con.createStatement()) {\r\n            ResultSet rs = statement.executeQuery(\"SELECT obj_id FROM drawable_files WHERE \" + sqlWhereClause);\r\n            Set<Long> ret = new HashSet();\r\n            while (rs.next()) {\r\n                ret.add(rs.getLong(1));\r\n            }\r\n            return ret;\r\n        } catch (SQLException ex) {\r\n            throw new TskCoreException(String.format(\"Failed to query file id for WHERE clause %s\", sqlWhereClause), ex);\r\n        }\r\n    } finally {\r\n        dbWriteUnlock();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.ImageUtils.getIconFile",
	"Comment": "get a thumbnail of a specified size for the given image. generates thethumbnail if it is not already cached.",
	"Method": "File getIconFile(Content content,int iconSize){\r\n    return getCachedThumbnailFile(content, iconSize);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJob.compareTo",
	"Comment": "compares one job to another in a way that orders jobs by manifestcreation date.",
	"Method": "int compareTo(AutoIngestJob otherJob){\r\n    int comparisonResult = -(this.getPriority().compareTo(otherJob.getPriority()));\r\n    if (comparisonResult == 0) {\r\n        comparisonResult = this.getManifest().getDateFileCreated().compareTo(otherJob.getManifest().getDateFileCreated());\r\n        if (comparisonResult == 0) {\r\n            comparisonResult = -this.getManifest().getCaseName().compareTo(otherJob.getManifest().getCaseName());\r\n            if (comparisonResult == 0) {\r\n                comparisonResult = -this.getManifest().getDataSourcePath().getFileName().toString().compareTo(otherJob.getManifest().getDataSourcePath().getFileName().toString());\r\n            }\r\n        }\r\n    }\r\n    return comparisonResult;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.interestingitems.FilesSetsManager.getInterestingFilesSets",
	"Comment": "gets a copy of the current interesting files set definitions.",
	"Method": "Map<String, FilesSet> getInterestingFilesSets(){\r\n    synchronized (INTERESTING_FILES_SET_LOCK) {\r\n        return InterestingItemsFilesSetSettings.readDefinitionsFile(INTERESTING_FILES_SET_DEFS_NAME, LEGACY_FILES_SET_DEFS_FILE_NAME);\r\n    }\r\n}"
}, {
	"Path": "deadlock.ThreadLockDemo.method2",
	"Comment": "this method request two locks also, but in oppsite order.this creates potential deadlock, if one thread holds string lock and other holds integer lockand they wait for each other, forever.",
	"Method": "void method2(){\r\n    synchronized (String.class) {\r\n        System.out.println(\"Acquired lock on String.class object\");\r\n    }\r\n    synchronized (Integer.class) {\r\n        System.out.println(\"Acquired lock on Integer.class object\");\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.encryptiondetection.EncryptionDetectionFileIngestModule.isFilePasswordProtected",
	"Comment": "this method checks if the abstractfile input is password protected.",
	"Method": "boolean isFilePasswordProtected(AbstractFile file){\r\n    boolean passwordProtected = false;\r\n    switch(file.getMIMEType()) {\r\n        case MIME_TYPE_OOXML_PROTECTED:\r\n            passwordProtected = true;\r\n            break;\r\n        case MIME_TYPE_MSWORD:\r\n        case MIME_TYPE_MSEXCEL:\r\n        case MIME_TYPE_MSPOWERPOINT:\r\n        case MIME_TYPE_PDF:\r\n            {\r\n                InputStream in = null;\r\n                BufferedInputStream bin = null;\r\n                try {\r\n                    in = new ReadContentInputStream(file);\r\n                    bin = new BufferedInputStream(in);\r\n                    ContentHandler handler = new BodyContentHandler(-1);\r\n                    Metadata metadata = new Metadata();\r\n                    metadata.add(Metadata.RESOURCE_NAME_KEY, file.getName());\r\n                    AutoDetectParser parser = new AutoDetectParser();\r\n                    parser.parse(bin, handler, metadata, new ParseContext());\r\n                } catch (EncryptedDocumentException ex) {\r\n                    passwordProtected = true;\r\n                } finally {\r\n                    if (in != null) {\r\n                        in.close();\r\n                    }\r\n                    if (bin != null) {\r\n                        bin.close();\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        case MIME_TYPE_MSACCESS:\r\n            {\r\n                InputStream in = null;\r\n                BufferedInputStream bin = null;\r\n                try {\r\n                    in = new ReadContentInputStream(file);\r\n                    bin = new BufferedInputStream(in);\r\n                    MemFileChannel memFileChannel = MemFileChannel.newChannel(bin);\r\n                    CodecProvider codecProvider = new CryptCodecProvider();\r\n                    DatabaseBuilder databaseBuilder = new DatabaseBuilder();\r\n                    databaseBuilder.setChannel(memFileChannel);\r\n                    databaseBuilder.setCodecProvider(codecProvider);\r\n                    Database accessDatabase;\r\n                    try {\r\n                        accessDatabase = databaseBuilder.open();\r\n                    } catch (IOException | BufferUnderflowException | IndexOutOfBoundsException ignored) {\r\n                        return passwordProtected;\r\n                    }\r\n                    if (accessDatabase.getDatabasePassword() != null) {\r\n                        passwordProtected = true;\r\n                    }\r\n                } catch (InvalidCredentialsException ex) {\r\n                    passwordProtected = true;\r\n                } finally {\r\n                    if (in != null) {\r\n                        in.close();\r\n                    }\r\n                    if (bin != null) {\r\n                        bin.close();\r\n                    }\r\n                }\r\n            }\r\n    }\r\n    return passwordProtected;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.datasourceprocessors.RawDSProcessor.reset",
	"Comment": "resets the selection and configuration panel for this data sourceprocessor.",
	"Method": "void reset(){\r\n    configPanel.reset();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.ui.detailview.EventNodeBase.installActionButtons",
	"Comment": "install whatever buttons are visible on hover for this node. likestooltips, this had a surprisingly large impact on speed of loading thechart",
	"Method": "void installActionButtons(){\r\n    if (pinButton == null) {\r\n        pinButton = new Button();\r\n        controlsHBox.getChildren().add(pinButton);\r\n        configureActionButton(pinButton);\r\n    }\r\n}"
}, {
	"Path": "deadlock.ThreadLockDemo.method1",
	"Comment": "this method request two locks, first integer and then string",
	"Method": "void method1(){\r\n    synchronized (Integer.class) {\r\n        System.out.println(\"Acquired lock on Integer.class object\");\r\n    }\r\n    synchronized (String.class) {\r\n        System.out.println(\"Acquired lock on String.class object\");\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.ImageGalleryController.shutDown",
	"Comment": "shuts down this per case singleton image gallery controller.",
	"Method": "void shutDown(){\r\n    logger.log(Level.INFO, String.format(\"Shutting down image gallery controller for case %s (%s)\", autopsyCase.getDisplayName(), autopsyCase.getName()));\r\n    selectionModel.clearSelection();\r\n    thumbnailCache.clearCache();\r\n    historyManager.clear();\r\n    groupManager.reset();\r\n    shutDownDBExecutor();\r\n    drawableDB.close();\r\n    logger.log(Level.INFO, String.format(\"Completed shut down of image gallery controller for case %s (%s)\", autopsyCase.getDisplayName(), autopsyCase.getName()));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.interestingitems.InterestingItemsFilesSetSettings.readSizeCondition",
	"Comment": "construct a file size condition for a filesset membership rule from datain an xml element.",
	"Method": "FileSizeCondition readSizeCondition(Element elem){\r\n    FileSizeCondition sizeCondition = null;\r\n    if (!elem.getAttribute(FS_COMPARATOR_ATTR).isEmpty() && !elem.getAttribute(FS_SIZE_ATTR).isEmpty() && !elem.getAttribute(FS_UNITS_ATTR).isEmpty()) {\r\n        try {\r\n            FileSizeCondition.COMPARATOR comparator = FileSizeCondition.COMPARATOR.fromSymbol(elem.getAttribute(FS_COMPARATOR_ATTR));\r\n            FileSizeCondition.SIZE_UNIT sizeUnit = FileSizeCondition.SIZE_UNIT.fromName(elem.getAttribute(FS_UNITS_ATTR));\r\n            int size = Integer.parseInt(elem.getAttribute(FS_SIZE_ATTR));\r\n            sizeCondition = new FileSizeCondition(comparator, sizeUnit, size);\r\n        } catch (NumberFormatException nfEx) {\r\n            logger.log(Level.SEVERE, \"Value in file size attribute was not an integer, unable to create FileSizeCondition for rule: \" + readRuleName(elem), nfEx);\r\n            throw new FilesSetsManager.FilesSetsManagerException(String.format(\"Non integer size in FilesSet XML for rule %s\", readRuleName(elem)), nfEx);\r\n        } catch (IllegalArgumentException iaEx) {\r\n            logger.log(Level.SEVERE, \"Invalid Comparator symbol or Size Unit set in FilesSet xml, unable to create FileSizeCondition for rule: \" + readRuleName(elem), iaEx);\r\n            throw new FilesSetsManager.FilesSetsManagerException(String.format(\"Invalid Comparator or Size unit in FilesSet XML for rule %s\", readRuleName(elem)), iaEx);\r\n        }\r\n    } else if (!elem.getAttribute(FS_COMPARATOR_ATTR).isEmpty() || !elem.getAttribute(FS_SIZE_ATTR).isEmpty() || !elem.getAttribute(FS_UNITS_ATTR).isEmpty()) {\r\n        logger.log(Level.SEVERE, \"Invalid Comparator symbol or Size Unit set in FilesSet xml, unable to create FileSizeCondition for rule: \" + readRuleName(elem));\r\n        throw new FilesSetsManager.FilesSetsManagerException(String.format(\"XML malformed missing at least one fileSize attribute for rule %s\", readRuleName(elem)));\r\n    }\r\n    return sizeCondition;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.optionspanel.CasesTableModel.getEamCase",
	"Comment": "get the casedatasourceswrapper for the specified index in the table.",
	"Method": "CaseDataSourcesWrapper getEamCase(int listIndex){\r\n    return eamCases.get(listIndex);\r\n}"
}, {
	"Path": "com.google.example.games.catt2.SnapshotCoordinator.setIsOpening",
	"Comment": "records the fact that the named file is opening.this is a synchronized operation since it is highly likely that multiple threadsare involved via asynctasks.",
	"Method": "void setIsOpening(String filename){\r\n    opened.put(filename, new CountDownLatch(1));\r\n}"
}, {
	"Path": "model.Complex.toString",
	"Comment": "return a string representation of the invoking complex object",
	"Method": "String toString(){\r\n    if (im == 0)\r\n        return re + \"\";\r\n    if (re == 0)\r\n        return im + \"i\";\r\n    if (im < 0)\r\n        return re + \" - \" + (-im) + \"i\";\r\n    return re + \" + \" + im + \"i\";\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.DataResultViewerTable.setupTable",
	"Comment": "sets up the outline view of this tabular result viewer by creating columnheaders based on the children of the current root node. the persistedcolumn order, sorting and visibility is used.",
	"Method": "void setupTable(){\r\n    outlineViewListener.listenToVisibilityChanges(false);\r\n    List<Node.Property<?>> props = loadColumnOrder();\r\n    boolean propsExist = props.isEmpty() == false;\r\n    Node.Property<?> firstProp = null;\r\n    if (propsExist) {\r\n        firstProp = props.remove(0);\r\n    }\r\n    outline.setAutoResizeMode((props.isEmpty()) ? JTable.AUTO_RESIZE_ALL_COLUMNS : JTable.AUTO_RESIZE_OFF);\r\n    assignColumns(props);\r\n    if (firstProp != null) {\r\n        ((DefaultOutlineModel) outline.getOutlineModel()).setNodesColumnLabel(firstProp.getDisplayName());\r\n    }\r\n    setColumnWidths();\r\n    loadColumnSorting();\r\n    populateColumnMap();\r\n    loadColumnVisibility();\r\n    SwingUtilities.invokeLater(() -> {\r\n        if (rootNode instanceof TableFilterNode) {\r\n            NodeSelectionInfo selectedChildInfo = ((TableFilterNode) rootNode).getChildNodeSelectionInfo();\r\n            if (null != selectedChildInfo) {\r\n                Node[] childNodes = rootNode.getChildren().getNodes(true);\r\n                for (int i = 0; i < childNodes.length; ++i) {\r\n                    Node childNode = childNodes[i];\r\n                    if (selectedChildInfo.matches(childNode)) {\r\n                        try {\r\n                            this.getExplorerManager().setSelectedNodes(new Node[] { childNode });\r\n                        } catch (PropertyVetoException ex) {\r\n                            LOGGER.log(Level.SEVERE, \"Failed to select node specified by selected child info\", ex);\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                ((TableFilterNode) rootNode).setChildNodeSelectionInfo(null);\r\n            }\r\n        }\r\n    });\r\n    outlineViewListener.listenToVisibilityChanges(true);\r\n}"
}, {
	"Path": "com.docker.atsea.configuration.JpaConfiguration.dataSourceProperties",
	"Comment": "populate springboot datasourceproperties from application.yml",
	"Method": "DataSourceProperties dataSourceProperties(){\r\n    DataSourceProperties dataSourceProperties = new DataSourceProperties();\r\n    try (BufferedReader br = new BufferedReader(new FileReader(\"/run/secrets/postgres_password\"))) {\r\n        StringBuilder sb = new StringBuilder();\r\n        String line = br.readLine();\r\n        while (line != null) {\r\n            sb.append(line);\r\n            sb.append(System.lineSeparator());\r\n            line = br.readLine();\r\n        }\r\n        dataSourceProperties.setDataPassword(sb.toString());\r\n    } catch (IOException e) {\r\n        System.err.println(\"Could not successfully load DB password file\");\r\n    }\r\n    return dataSourceProperties;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.progress.ModalDialogProgressIndicator.setCancelling",
	"Comment": "sets a cancelling message and makes the progress bar indeterminate. oncecancel has been called, the progress indicator no longer accepts updatesunless start is called again.",
	"Method": "void setCancelling(String cancellingMessage){\r\n    cancelling = true;\r\n    SwingUtilities.invokeLater(() -> {\r\n        progressPanel.setIndeterminate(false);\r\n        progressPanel.setMessage(cancellingMessage);\r\n    });\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.hashdatabase.HashDbSearcher.countFilesMd5Hashed",
	"Comment": "counts the number of fscontent in the database that have an md5",
	"Method": "int countFilesMd5Hashed(){\r\n    final Case currentCase = Case.getCurrentCaseThrows();\r\n    final SleuthkitCase skCase = currentCase.getSleuthkitCase();\r\n    return skCase.countFilesMd5Hashed();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.filetypeid.FileTypeDetector.getMIMEType",
	"Comment": "detects the mime type of a file, then writes it the abstractfile objectrepresenting the file and returns the detected type.",
	"Method": "String getMIMEType(AbstractFile file){\r\n    String mimeType = file.getMIMEType();\r\n    if (null != mimeType) {\r\n        return removeOptionalParameter(mimeType);\r\n    }\r\n    if (!file.isFile() || file.getSize() <= 0 || (file.getType() == TskData.TSK_DB_FILES_TYPE_ENUM.UNALLOC_BLOCKS) || (file.getType() == TskData.TSK_DB_FILES_TYPE_ENUM.UNUSED_BLOCKS) || (file.getType() == TskData.TSK_DB_FILES_TYPE_ENUM.VIRTUAL_DIR) || ((file.getType() == TskData.TSK_DB_FILES_TYPE_ENUM.SLACK) && file.getSize() < SLACK_FILE_THRESHOLD)) {\r\n        mimeType = MimeTypes.OCTET_STREAM;\r\n    }\r\n    if (null == mimeType) {\r\n        mimeType = detectUserDefinedType(file);\r\n    }\r\n    if (null == mimeType) {\r\n        mimeType = detectAutopsyDefinedType(file);\r\n    }\r\n    if (null == mimeType) {\r\n        ReadContentInputStream stream = new ReadContentInputStream(file);\r\n        try (TikaInputStream tikaInputStream = TikaInputStream.get(stream)) {\r\n            String tikaType = tika.detect(tikaInputStream, file.getName());\r\n            mimeType = tikaType.replace(\"tika-\", \"\");\r\n            mimeType = removeOptionalParameter(mimeType);\r\n        } catch (Exception ignored) {\r\n            mimeType = MimeTypes.OCTET_STREAM;\r\n        }\r\n    }\r\n    file.setMIMEType(mimeType);\r\n    return mimeType;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.AddImageWizardAddingProgressPanel.getHelp",
	"Comment": "help for this panel. when the panel is active, this is used as the helpfor the wizard dialog.",
	"Method": "HelpCtx getHelp(){\r\n    return HelpCtx.DEFAULT_HELP;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.AbstractSqlEamDb.getDataSource",
	"Comment": "retrieves data source details based on data source object id",
	"Method": "CorrelationDataSource getDataSource(CorrelationCase correlationCase,Long dataSourceObjectId){\r\n    if (correlationCase == null) {\r\n        throw new EamDbException(\"Correlation case is null\");\r\n    }\r\n    try {\r\n        return dataSourceCacheByDsObjectId.get(getDataSourceByDSObjectIdCacheKey(correlationCase.getID(), dataSourceObjectId), () -> getDataSourceFromCr(correlationCase, dataSourceObjectId));\r\n    } catch (CacheLoader.InvalidCacheLoadException ignored) {\r\n        return null;\r\n    } catch (ExecutionException ex) {\r\n        throw new EamDbException(\"Error getting data source from central repository\", ex);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.interestingitems.InterestingItemsFilesSetSettings.readDefinitionsXML",
	"Comment": "reads an xml file and returns a map of filesets. allows for legacy xmlsupport as well as importing of file sets to xmls.",
	"Method": "Map<String, FilesSet> readDefinitionsXML(File xmlFile){\r\n    Map<String, FilesSet> filesSets = new HashMap();\r\n    if (!xmlFile.exists()) {\r\n        return filesSets;\r\n    }\r\n    if (!xmlFile.canRead()) {\r\n        logger.log(Level.SEVERE, \"FilesSet definition file at {0} exists, but cannot be read\", xmlFile.getPath());\r\n        return filesSets;\r\n    }\r\n    Document doc = XMLUtil.loadDoc(InterestingItemsFilesSetSettings.class, xmlFile.getPath());\r\n    if (doc == null) {\r\n        logger.log(Level.SEVERE, \"FilesSet definition file at {0}\", xmlFile.getPath());\r\n        return filesSets;\r\n    }\r\n    Element root = doc.getDocumentElement();\r\n    if (root == null) {\r\n        logger.log(Level.SEVERE, \"Failed to get root {0} element tag of FilesSet definition file at {1}\", new Object[] { FILE_SETS_ROOT_TAG, xmlFile.getPath() });\r\n        return filesSets;\r\n    }\r\n    NodeList setElems = root.getElementsByTagName(FILE_SET_TAG);\r\n    for (int i = 0; i < setElems.getLength(); ++i) {\r\n        readFilesSet((Element) setElems.item(i), filesSets, xmlFile.getPath());\r\n    }\r\n    return filesSets;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestTasksScheduler.scheduleDataSourceIngestTask",
	"Comment": "schedules a data source level ingest task for a data source ingest job.",
	"Method": "void scheduleDataSourceIngestTask(DataSourceIngestJob job){\r\n    if (!job.isCancelled()) {\r\n        DataSourceIngestTask task = new DataSourceIngestTask(job);\r\n        try {\r\n            this.dataSourceIngestThreadQueue.putLast(task);\r\n        } catch (InterruptedException ex) {\r\n            IngestTasksScheduler.logger.log(Level.INFO, String.format(\"Ingest tasks scheduler interrupted while blocked adding a task to the data source level ingest task queue (jobId={%d)\", job.getId()), ex);\r\n            Thread.currentThread().interrupt();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.AddKeywordsDialog.setInitialKeywordList",
	"Comment": "set the initial contents of the text box. intended to be used toredisplay any keywords that contained errors",
	"Method": "void setInitialKeywordList(String initialKeywords,boolean isLiteral,boolean isWholeWord){\r\n    keywordTextArea.setText(initialKeywords);\r\n    if (!isLiteral) {\r\n        regexRadioButton.setSelected(true);\r\n    } else if (isWholeWord) {\r\n        exactRadioButton.setSelected(true);\r\n    } else {\r\n        substringRadioButton.setSelected(true);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.runIngestModuleWizard.ShortcutWizardDescriptorPanel.skipNextPanel",
	"Comment": "whether or not the panel immediately following this one should be skipped",
	"Method": "boolean skipNextPanel(){\r\n    return false;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.hashdatabase.ModalNoButtons.CANCEL_BUTTONMouseClicked",
	"Comment": "when the cancel button is pressed, the dialog first seeks to confirm theevent with the user, then removes the databases from thehashdbmanagementpanel list.this method is imperfect, as it fails to cleanup residual files that weregenerated, as well as having a few other miscellaneous errors.",
	"Method": "void CANCEL_BUTTONMouseClicked(java.awt.event.MouseEvent evt){\r\n    String message = NbBundle.getMessage(this.getClass(), \"ModalNoButtons.exitHashDbIndexingMsg\");\r\n    int res = JOptionPane.showConfirmDialog(this, message, NbBundle.getMessage(this.getClass(), \"ModalNoButtons.dlgTitle.unfinishedIndexing\"), JOptionPane.YES_NO_OPTION);\r\n    if (res == JOptionPane.YES_OPTION) {\r\n        List<SleuthkitHashSet> remove = new ArrayList();\r\n        if (this.toIndex == null) {\r\n            remove = this.unindexed;\r\n        } else {\r\n            remove.add(this.toIndex);\r\n        }\r\n        this.hdbmp.removeThese(remove);\r\n        this.setVisible(false);\r\n        this.setModal(false);\r\n        this.dispose();\r\n    }\r\n}"
}, {
	"Path": "net.ypresto.androidtranscoder.engine.OutputSurface.eglSetup",
	"Comment": "prepares egl.we want a gles 2.0 context and a surface that supports pbuffer.",
	"Method": "void eglSetup(int width,int height){\r\n    mEGLDisplay = EGL14.eglGetDisplay(EGL14.EGL_DEFAULT_DISPLAY);\r\n    if (mEGLDisplay == EGL14.EGL_NO_DISPLAY) {\r\n        throw new RuntimeException(\"unable to get EGL14 display\");\r\n    }\r\n    int[] version = new int[2];\r\n    if (!EGL14.eglInitialize(mEGLDisplay, version, 0, version, 1)) {\r\n        mEGLDisplay = null;\r\n        throw new RuntimeException(\"unable to initialize EGL14\");\r\n    }\r\n    int[] attribList = { EGL14.EGL_RED_SIZE, 8, EGL14.EGL_GREEN_SIZE, 8, EGL14.EGL_BLUE_SIZE, 8, EGL14.EGL_RENDERABLE_TYPE, EGL14.EGL_OPENGL_ES2_BIT, EGL14.EGL_SURFACE_TYPE, EGL14.EGL_PBUFFER_BIT, EGL14.EGL_NONE };\r\n    EGLConfig[] configs = new EGLConfig[1];\r\n    int[] numConfigs = new int[1];\r\n    if (!EGL14.eglChooseConfig(mEGLDisplay, attribList, 0, configs, 0, configs.length, numConfigs, 0)) {\r\n        throw new RuntimeException(\"unable to find RGB888+recordable ES2 EGL config\");\r\n    }\r\n    int[] attrib_list = { EGL14.EGL_CONTEXT_CLIENT_VERSION, 2, EGL14.EGL_NONE };\r\n    mEGLContext = EGL14.eglCreateContext(mEGLDisplay, configs[0], EGL14.EGL_NO_CONTEXT, attrib_list, 0);\r\n    checkEglError(\"eglCreateContext\");\r\n    if (mEGLContext == null) {\r\n        throw new RuntimeException(\"null context\");\r\n    }\r\n    int[] surfaceAttribs = { EGL14.EGL_WIDTH, width, EGL14.EGL_HEIGHT, height, EGL14.EGL_NONE };\r\n    mEGLSurface = EGL14.eglCreatePbufferSurface(mEGLDisplay, configs[0], surfaceAttribs, 0);\r\n    checkEglError(\"eglCreatePbufferSurface\");\r\n    if (mEGLSurface == null) {\r\n        throw new RuntimeException(\"surface was null\");\r\n    }\r\n}"
}, {
	"Path": "com.mcxiaoke.next.ui.internal.AdapterWrapper.isEnabled",
	"Comment": "returns true if the item at the specified position issomething selectable.",
	"Method": "boolean isEnabled(int position){\r\n    return (wrapped.isEnabled(position));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.directorytree.DataResultFilterNode.getPreferredAction",
	"Comment": "double click action for the nodes that we want to pass to the directorytable and the output view.",
	"Method": "Action getPreferredAction(){\r\n    final Node original = this.getOriginal();\r\n    if ((original instanceof DisplayableItemNode) == false) {\r\n        return null;\r\n    }\r\n    final DisplayableItemNode originalNode = (DisplayableItemNode) this.getOriginal();\r\n    return originalNode.accept(getPreferredActionsDIV);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJob.setCompleted",
	"Comment": "marks the job as completed. this is transient state used by the autoingest manager that is not saved as coordination service node data forthe job.",
	"Method": "void setCompleted(){\r\n    setProcessingStage(Stage.COMPLETED, Date.from(Instant.now()));\r\n    completed = true;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.contentviewers.MessageContentViewer.configureTextArea",
	"Comment": "configure the text area at the given index to show the content of thegiven type.",
	"Method": "void configureTextArea(BlackboardAttribute.ATTRIBUTE_TYPE type,int index){\r\n    String attributeText = getAttributeValueSafe(artifact, type);\r\n    if (index == HTML_TAB_INDEX && StringUtils.isNotBlank(attributeText)) {\r\n        attributeText = wrapInHtmlBody(cleanseHTML(attributeText));\r\n    }\r\n    JTextComponent textComponent = textAreas.get(index);\r\n    textComponent.setText(attributeText);\r\n    textComponent.setCaretPosition(0);\r\n    final boolean hasText = attributeText.length() > 0;\r\n    msgbodyTabbedPane.setEnabledAt(index, hasText);\r\n    if (hasText) {\r\n        msgbodyTabbedPane.setSelectedIndex(index);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AddArchiveTask.createDirectoryForFile",
	"Comment": "create a directory in moduleoutput folder based on input file name. atime stamp is appended to the directory name.",
	"Method": "Path createDirectoryForFile(String fileName,String baseDirectory){\r\n    String fileNameNoExt = FilenameUtils.getBaseName(fileName);\r\n    Path newFolder = Paths.get(baseDirectory, ARCHIVE_EXTRACTOR_MODULE_OUTPUT_DIR, fileNameNoExt + \"_\" + TimeStampUtils.createTimeStamp());\r\n    if (newFolder.toFile().mkdirs() == false) {\r\n        return Paths.get(\"\");\r\n    }\r\n    return newFolder;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.ReportHTML.writeSummaryIngestHistoryInfo",
	"Comment": "write the ingest history section of the summary for this report.",
	"Method": "StringBuilder writeSummaryIngestHistoryInfo(SleuthkitCase skCase,List<IngestJobInfo> ingestJobs){\r\n    StringBuilder summary = new StringBuilder();\r\n    try {\r\n        summary.append(NbBundle.getMessage(this.getClass(), \"ReportHTML.writeSum.ingestHistoryHeading\"));\r\n        summary.append(\"<div class=\\\"info\\\">\\n\");\r\n        int jobnumber = 1;\r\n        for (IngestJobInfo ingestJob : ingestJobs) {\r\n            summary.append(\"<h3>Job \").append(jobnumber).append(\":<\/h3>\\n\");\r\n            summary.append(\"<table>\\n\");\r\n            summary.append(\"<tr><td>\").append(\"Data Source:\").append(\"<\/td><td>\").append(skCase.getContentById(ingestJob.getObjectId()).getName()).append(\"<\/td><\/tr>\\n\");\r\n            summary.append(\"<tr><td>\").append(\"Status:\").append(\"<\/td><td>\").append(ingestJob.getStatus()).append(\"<\/td><\/tr>\\n\");\r\n            summary.append(\"<tr><td>\").append(NbBundle.getMessage(this.getClass(), \"ReportHTML.writeSum.modulesEnabledHeading\")).append(\"<\/td><td>\");\r\n            List<IngestModuleInfo> ingestModules = ingestJob.getIngestModuleInfo();\r\n            summary.append(\"<ul>\\n\");\r\n            for (IngestModuleInfo ingestModule : ingestModules) {\r\n                summary.append(\"<li>\").append(ingestModule.getDisplayName()).append(\"<\/li>\");\r\n            }\r\n            summary.append(\"<\/ul>\\n\");\r\n            jobnumber++;\r\n            summary.append(\"<\/td><\/tr>\\n\");\r\n            summary.append(\"<\/table>\\n\");\r\n        }\r\n        summary.append(\"<\/div>\\n\");\r\n    } catch (TskCoreException ex) {\r\n        logger.log(Level.WARNING, \"Unable to get ingest jobs for the HTML report.\");\r\n    }\r\n    return summary;\r\n}"
}, {
	"Path": "org.automon.implementations.OpenMonFactory.getJustClassName",
	"Comment": "takes something like com.mypackage.myclass and returns myclass.",
	"Method": "String getJustClassName(String className){\r\n    String[] array = Utils.tokenize(className, \"[.]\");\r\n    return array[array.length - 1];\r\n}"
}, {
	"Path": "com.anysoftkeyboard.keyboards.views.AnyKeyboardViewBase.onLongPress",
	"Comment": "called when a key is long pressed. by default this will open any popupkeyboard associated with this key through the attributes popuplayout andpopupcharacters.",
	"Method": "boolean onLongPress(AddOn keyboardAddOn,Key key,boolean isSticky,PointerTracker tracker){\r\n    if (key instanceof AnyKey) {\r\n        AnyKey anyKey = (AnyKey) key;\r\n        if (anyKey.getKeyTags().size() > 0) {\r\n            Object[] tags = anyKey.getKeyTags().toArray();\r\n            for (int tagIndex = 0; tagIndex < tags.length; tagIndex++) {\r\n                tags[tagIndex] = \":\" + tags[tagIndex];\r\n            }\r\n            String joinedTags = TextUtils.join(\", \", tags);\r\n            final Toast tagsToast = Toast.makeText(getContext().getApplicationContext(), joinedTags, Toast.LENGTH_SHORT);\r\n            tagsToast.setGravity(Gravity.CENTER, 0, 0);\r\n            tagsToast.show();\r\n        }\r\n        if (anyKey.longPressCode != 0) {\r\n            getOnKeyboardActionListener().onKey(anyKey.longPressCode, key, 0, null, true);\r\n            if (!anyKey.repeatable) {\r\n                onCancelEvent(tracker);\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJobsPanel.getSelectedAutoIngestJob",
	"Comment": "get the autoingestjob for the currently selected node of this panel.",
	"Method": "AutoIngestJob getSelectedAutoIngestJob(){\r\n    Node[] selectedRows = explorerManager.getSelectedNodes();\r\n    if (selectedRows.length == 1) {\r\n        return ((JobNode) selectedRows[0]).getAutoIngestJob();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.eventlisteners.IngestEventsListener.resetCeModuleInstanceCount",
	"Comment": "reset the counter which keeps track of if the correlation engine moduleis being run during injest to 0.",
	"Method": "void resetCeModuleInstanceCount(){\r\n    correlationModuleInstanceCount = 0;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.datamodel.AbstractAbstractFileNode.getProperties",
	"Comment": "creates and populates a list of properties for this nodes property sheet.",
	"Method": "List<NodeProperty<?>> getProperties(){\r\n    List<NodeProperty<?>> properties = new ArrayList();\r\n    properties.add(new NodeProperty(NAME.toString(), NAME.toString(), NO_DESCR, getContentDisplayName(content)));\r\n    if (UserPreferences.displayTranslatedFileNames()) {\r\n        properties.add(new NodeProperty(TRANSLATION.toString(), TRANSLATION.toString(), NO_DESCR, \"\"));\r\n    }\r\n    List<ContentTag> tags = getContentTagsFromDatabase();\r\n    CorrelationAttributeInstance attribute = getCorrelationAttributeInstance();\r\n    Pair<DataResultViewerTable.Score, String> scoreAndDescription = getScorePropertyAndDescription(tags);\r\n    properties.add(new NodeProperty(SCORE.toString(), SCORE.toString(), scoreAndDescription.getRight(), scoreAndDescription.getLeft()));\r\n    DataResultViewerTable.HasCommentStatus comment = getCommentProperty(tags, attribute);\r\n    properties.add(new NodeProperty(COMMENT.toString(), COMMENT.toString(), NO_DESCR, comment));\r\n    if (!UserPreferences.hideCentralRepoCommentsAndOccurrences()) {\r\n        Pair<Long, String> countAndDescription = getCountPropertyAndDescription(attribute);\r\n        properties.add(new NodeProperty(OCCURRENCES.toString(), OCCURRENCES.toString(), countAndDescription.getRight(), countAndDescription.getLeft()));\r\n    }\r\n    properties.add(new NodeProperty(LOCATION.toString(), LOCATION.toString(), NO_DESCR, getContentPath(content)));\r\n    properties.add(new NodeProperty(MOD_TIME.toString(), MOD_TIME.toString(), NO_DESCR, ContentUtils.getStringTime(content.getMtime(), content)));\r\n    properties.add(new NodeProperty(CHANGED_TIME.toString(), CHANGED_TIME.toString(), NO_DESCR, ContentUtils.getStringTime(content.getCtime(), content)));\r\n    properties.add(new NodeProperty(ACCESS_TIME.toString(), ACCESS_TIME.toString(), NO_DESCR, ContentUtils.getStringTime(content.getAtime(), content)));\r\n    properties.add(new NodeProperty(CREATED_TIME.toString(), CREATED_TIME.toString(), NO_DESCR, ContentUtils.getStringTime(content.getCrtime(), content)));\r\n    properties.add(new NodeProperty(SIZE.toString(), SIZE.toString(), NO_DESCR, content.getSize()));\r\n    properties.add(new NodeProperty(FLAGS_DIR.toString(), FLAGS_DIR.toString(), NO_DESCR, content.getDirFlagAsString()));\r\n    properties.add(new NodeProperty(FLAGS_META.toString(), FLAGS_META.toString(), NO_DESCR, content.getMetaFlagsAsString()));\r\n    properties.add(new NodeProperty(KNOWN.toString(), KNOWN.toString(), NO_DESCR, content.getKnown().getName()));\r\n    properties.add(new NodeProperty(MD5HASH.toString(), MD5HASH.toString(), NO_DESCR, StringUtils.defaultString(content.getMd5Hash())));\r\n    properties.add(new NodeProperty(MIMETYPE.toString(), MIMETYPE.toString(), NO_DESCR, StringUtils.defaultString(content.getMIMEType())));\r\n    properties.add(new NodeProperty(EXTENSION.toString(), EXTENSION.toString(), NO_DESCR, content.getNameExtension()));\r\n    return properties;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestJobSettings.createSavedModuleSettingsFolder",
	"Comment": "creates the module folder for these ingest job settings, if it does notalready exist.",
	"Method": "void createSavedModuleSettingsFolder(){\r\n    try {\r\n        Path folder = getSavedModuleSettingsFolder();\r\n        Files.createDirectories(folder);\r\n        this.moduleSettingsFolderPath = folder.toAbsolutePath().toString();\r\n    } catch (IOException | SecurityException ex) {\r\n        logger.log(Level.SEVERE, \"Failed to create ingest module settings directory \" + this.moduleSettingsFolderPath, ex);\r\n        this.warnings.add(NbBundle.getMessage(IngestJobSettings.class, \"IngestJobSettings.createModuleSettingsFolder.warning\"));\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.AddImageWizardIterator.previousPanel",
	"Comment": "moves to the previous panel. i.e. decrement its index, need not actuallychange any gui itself.",
	"Method": "void previousPanel(){\r\n    if (!hasPrevious()) {\r\n        throw new NoSuchElementException();\r\n    }\r\n    if (index == progressPanelIndex) {\r\n        index--;\r\n    }\r\n    index--;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.ProfileSettingsPanel.refreshButtons",
	"Comment": "when ingest is not running this will change the enabled status of theedit and delete buttons to reflect their current availability.",
	"Method": "void refreshButtons(){\r\n    IngestProfile selectedProfile = ProfileSettingsPanel.this.profileList.getSelectedValue();\r\n    boolean profileIsSelected = (selectedProfile != null);\r\n    newProfileButton.setEnabled(canBeEnabled);\r\n    editProfileButton.setEnabled(canBeEnabled && profileIsSelected);\r\n    deleteProfileButton.setEnabled(canBeEnabled && profileIsSelected);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.InterCasePanel.documentsCheckboxIsSelected",
	"Comment": "if the user has selected selected to show document files as part of thefiltered results.",
	"Method": "boolean documentsCheckboxIsSelected(){\r\n    return documentsCheckbox.isEnabled() && documentsCheckbox.isSelected();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.healthmonitor.TimingMetric.getDuration",
	"Comment": "get the duration of the metric. will throw an exception if themetric has not been stopped.",
	"Method": "double getDuration(){\r\n    if (duration != null) {\r\n        return duration;\r\n    } else {\r\n        throw new HealthMonitorException(\"getDuration() called before stopTiming()\");\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.snapshot.SnapShotReportWriter.writeSummaryHTML",
	"Comment": "generate and write the summary of the current case for this report.",
	"Method": "void writeSummaryHTML(){\r\n    HashMap<String, Object> summaryContext = new HashMap();\r\n    summaryContext.put(\"reportName\", reportName);\r\n    summaryContext.put(\"reportBranding\", reportBranding);\r\n    summaryContext.put(\"generationDateTime\", new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\").format(generationDate));\r\n    summaryContext.put(\"ingestRunning\", IngestManager.getInstance().isIngestRunning());\r\n    summaryContext.put(\"currentCase\", currentCase);\r\n    String agencyLogo = \"agency_logo.png\";\r\n    if (StringUtils.isNotBlank(reportBranding.getAgencyLogoPath())) {\r\n        agencyLogo = Paths.get(reportBranding.getAgencyLogoPath()).getFileName().toString();\r\n    }\r\n    summaryContext.put(\"agencyLogoFileName\", agencyLogo);\r\n    fillTemplateAndWrite(\"/org/sleuthkit/autopsy/timeline/snapshot/summary_template.html\", \"Summary\", summaryContext, reportFolderPath.resolve(\"summary.html\"));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.ImageUtils.isSupportedMediaExtension",
	"Comment": "does the given file have an extension in the given list of supportedextensions.",
	"Method": "boolean isSupportedMediaExtension(AbstractFile file,List<String> supportedExtensions){\r\n    String extension = file.getNameExtension();\r\n    return (StringUtils.isNotBlank(extension) && supportedExtensions.contains(extension));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.ArtifactSelectionDialog.display",
	"Comment": "display this dialog, and return the selected artifacttypes.",
	"Method": "Map<BlackboardArtifact.Type, Boolean> display(){\r\n    this.setTitle(NbBundle.getMessage(this.getClass(), \"ArtifactSelectionDialog.dlgTitle.text\"));\r\n    this.setLocationRelativeTo(getOwner());\r\n    this.setVisible(true);\r\n    return artifactTypeSelections;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.DropdownSingleTermSearchPanel.addSearchButtonActionListener",
	"Comment": "add an action listener to the search buttom component of the panel.",
	"Method": "void addSearchButtonActionListener(ActionListener actionListener){\r\n    searchButton.addActionListener(actionListener);\r\n}"
}, {
	"Path": "com.fernandocejas.arrow.collections.UnmodifiableIterator.remove",
	"Comment": "guaranteed to throw an exception and leave the underlying data unmodified.",
	"Method": "void remove(){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.LocalDiskDSProcessor.isPanelValid",
	"Comment": "indicates whether the settings in the selection and configuration panelare valid and complete.",
	"Method": "boolean isPanelValid(){\r\n    return configPanel.validatePanel();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.DataResultPanel.stateChanged",
	"Comment": "responds to a tab selection changed event by setting the root node of thecorresponding result viewer.",
	"Method": "void stateChanged(ChangeEvent event){\r\n    JTabbedPane pane = (JTabbedPane) event.getSource();\r\n    int currentTab = pane.getSelectedIndex();\r\n    if (currentTab != DataResultPanel.NO_TAB_SELECTED) {\r\n        DataResultViewer currentViewer = this.resultViewers.get(currentTab);\r\n        this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\r\n        try {\r\n            currentViewer.setNode(currentRootNode);\r\n        } finally {\r\n            this.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.healthmonitor.HealthMonitor.getGlobalEnabledStatusFromDB",
	"Comment": "read the enabled status from the database. check that the health monitordatabase exists before calling this.",
	"Method": "boolean getGlobalEnabledStatusFromDB(){\r\n    try (Connection conn = connect();\r\n        Statement statement = conn.createStatement();\r\n        ResultSet resultSet = statement.executeQuery(\"SELECT value FROM db_info WHERE name='MONITOR_ENABLED'\")) {\r\n        if (resultSet.next()) {\r\n            return (resultSet.getBoolean(\"value\"));\r\n        }\r\n        throw new HealthMonitorException(\"No enabled status found in database\");\r\n    } catch (SQLException ex) {\r\n        throw new HealthMonitorException(\"Error initializing database\", ex);\r\n    }\r\n}"
}, {
	"Path": "com.anysoftkeyboard.dictionaries.Dictionary.same",
	"Comment": "compares the contents of the character array with the typed word and returns true if theyare the same.",
	"Method": "boolean same(char[] word,int length,CharSequence typedWord){\r\n    if (typedWord.length() != length) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < length; i++) {\r\n        if (word[i] != typedWord.charAt(i)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.db.EventDB.getEventIDsForFile",
	"Comment": "get a list of event ids for the events that are derived from the givenfile.",
	"Method": "List<Long> getEventIDsForFile(AbstractFile file,boolean includeDerivedArtifacts){\r\n    DBLock.lock();\r\n    String query = \"SELECT event_id FROM events WHERE file_id == \" + file.getId() + (includeDerivedArtifacts ? \"\" : \" AND artifact_id IS NULL\");\r\n    ArrayList<Long> results = new ArrayList();\r\n    try (Statement stmt = con.createStatement();\r\n        ResultSet rs = stmt.executeQuery(query)) {\r\n        while (rs.next()) {\r\n            results.add(rs.getLong(\"event_id\"));\r\n        }\r\n    } catch (SQLException ex) {\r\n        LOGGER.log(Level.SEVERE, \"Error executing getEventIDsForFile query.\", ex);\r\n    } finally {\r\n        DBLock.unlock();\r\n    }\r\n    return results;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.SingleUserCaseConverter.copyImages",
	"Comment": "get the images from the old case and stage them for the new case, if theuser chose to copy images over.",
	"Method": "void copyImages(ImportCaseData icd){\r\n    if (icd.getCopySourceImages()) {\r\n        File imageSource = findInputFolder(icd);\r\n        File imageDestination = new File(icd.getImageOutputFolder().toString());\r\n        if (imageSource.exists()) {\r\n            FileUtils.copyDirectory(imageSource, imageDestination);\r\n        } else {\r\n            throw new Exception(NbBundle.getMessage(SingleUserCaseConverter.class, \"SingleUserCaseConverter.UnableToCopySourceImages\"));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.CorrelationAttributeNormalizer.normalizeMd5",
	"Comment": "verify md5 is the correct length and values. make lower case.",
	"Method": "String normalizeMd5(String data){\r\n    final String validMd5Regex = \"^[a-f0-9]{32}$\";\r\n    final String dataLowered = data.toLowerCase();\r\n    if (dataLowered.matches(validMd5Regex)) {\r\n        return dataLowered;\r\n    } else {\r\n        throw new CorrelationAttributeNormalizationException(String.format(\"Data purporting to be an MD5 was found not to comform to expected format: %s\", data));\r\n    }\r\n}"
}, {
	"Path": "org.wikipedia.edit.EditSectionActivity.clickNextButton",
	"Comment": "executes a click of the actionbar button, and performs the appropriate actionbased on the current state of the button.",
	"Method": "void clickNextButton(){\r\n    if (editSummaryFragment.isActive()) {\r\n        editSummaryFragment.hide();\r\n        editPreviewFragment.setCustomSummary(editSummaryFragment.getSummary());\r\n    } else if (editPreviewFragment.isActive()) {\r\n        if (abusefilterEditResult != null) {\r\n            funnel.logAbuseFilterWarningIgnore(abusefilterEditResult.getCode());\r\n        }\r\n        getEditTokenThenSave(false);\r\n        funnel.logSaveAttempt();\r\n    } else {\r\n        hideSoftKeyboard(this);\r\n        editPreviewFragment.showPreview(title, sectionText.getText().toString());\r\n        funnel.logPreview();\r\n    }\r\n}"
}, {
	"Path": "com.anysoftkeyboard.dictionaries.WordComposer.isFirstCharCapitalized",
	"Comment": "whether or not the user typed a capital letter as the first letter in the word",
	"Method": "boolean isFirstCharCapitalized(){\r\n    return mIsFirstCharCapitalized;\r\n}"
}, {
	"Path": "com.github.pires.obd.reader.io.AbstractGatewayService.queueJob",
	"Comment": "this method will add a job to the queue while setting its id to theinternal queue counter.",
	"Method": "void queueJob(ObdCommandJob job){\r\n    queueCounter++;\r\n    Log.d(TAG, \"Adding job[\" + queueCounter + \"] to queue..\");\r\n    job.setId(queueCounter);\r\n    try {\r\n        jobsQueue.put(job);\r\n        Log.d(TAG, \"Job queued successfully.\");\r\n    } catch (InterruptedException e) {\r\n        job.setState(ObdCommandJob.ObdCommandJobState.QUEUE_ERROR);\r\n        Log.e(TAG, \"Failed to queue job.\");\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.configuration.AutoIngestUserPreferences.getSharedConfigMaster",
	"Comment": "get shared config master checkbox state for automated mode frompersistent storage.",
	"Method": "Boolean getSharedConfigMaster(){\r\n    return Boolean.parseBoolean(getPreferenceValue(SHARED_CONFIG_MASTER));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestManager.stopJobProcessing",
	"Comment": "cancels the job processing task and shuts down its executor.",
	"Method": "void stopJobProcessing(){\r\n    synchronized (jobsLock) {\r\n        if (null != currentJob) {\r\n            cancelCurrentJob();\r\n        }\r\n        jobProcessingTaskFuture.cancel(true);\r\n        jobProcessingExecutor.shutdown();\r\n    }\r\n    while (!jobProcessingExecutor.awaitTermination(30, TimeUnit.SECONDS)) {\r\n        sysLogger.log(Level.WARNING, \"Auto ingest waited at least thirty seconds for job processing executor to shut down, continuing to wait\");\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.StringExtract.setEnabledScripts",
	"Comment": "sets the enabled scripts to ones provided, resets previous setting",
	"Method": "void setEnabledScripts(List<SCRIPT> scripts){\r\n    this.enabledScripts = scripts;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestMonitor.prioritizeCase",
	"Comment": "bumps the priority of all pending ingest jobs for a specified case.",
	"Method": "void prioritizeCase(String caseName){\r\n    List<AutoIngestJob> jobsToPrioritize = new ArrayList();\r\n    int highestPriority = 0;\r\n    synchronized (jobsLock) {\r\n        for (AutoIngestJob pendingJob : getPendingJobs()) {\r\n            if (pendingJob.getPriority() > highestPriority) {\r\n                highestPriority = pendingJob.getPriority();\r\n            }\r\n            if (pendingJob.getManifest().getCaseName().equals(caseName)) {\r\n                jobsToPrioritize.add(pendingJob);\r\n            }\r\n        }\r\n        if (!jobsToPrioritize.isEmpty()) {\r\n            ++highestPriority;\r\n            for (AutoIngestJob job : jobsToPrioritize) {\r\n                String manifestNodePath = job.getManifest().getFilePath().toString();\r\n                try {\r\n                    AutoIngestJobNodeData nodeData = new AutoIngestJobNodeData(coordinationService.getNodeData(CoordinationService.CategoryNode.MANIFESTS, manifestNodePath));\r\n                    nodeData.setPriority(highestPriority);\r\n                    coordinationService.setNodeData(CoordinationService.CategoryNode.MANIFESTS, manifestNodePath, nodeData.toArray());\r\n                } catch (AutoIngestJobNodeData.InvalidDataException | CoordinationServiceException | InterruptedException ex) {\r\n                    throw new AutoIngestMonitorException(\"Error bumping priority for job \" + job.toString(), ex);\r\n                }\r\n                job.setPriority(highestPriority);\r\n                jobsSnapshot.addOrReplacePendingJob(job);\r\n            }\r\n            new Thread(() -> {\r\n                eventPublisher.publishRemotely(new AutoIngestCasePrioritizedEvent(LOCAL_HOST_NAME, caseName, AutoIngestManager.getSystemUserNameProperty(), AutoIngestCasePrioritizedEvent.EventType.CASE_PRIORITIZED, \"\"));\r\n            }).start();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.configuration.AutoIngestUserPreferences.setSharedConfigFolder",
	"Comment": "set shared config folder for automated mode from persistent storage.",
	"Method": "void setSharedConfigFolder(String folder){\r\n    ModuleSettings.setConfigSetting(UserPreferences.SETTINGS_PROPERTIES, SHARED_CONFIG_FOLDER, folder);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.services.TagOptionsPanel.updatePanel",
	"Comment": "enables the button components based on the state of the tag types listcomponent.",
	"Method": "void updatePanel(){\r\n    boolean ingestIsRunning = IngestManager.getInstance().isIngestRunning();\r\n    ingestRunningWarningLabel.setVisible(ingestIsRunning);\r\n    boolean isSelected = tagNamesList.getSelectedIndex() != -1;\r\n    boolean enableEdit = !ingestIsRunning && isSelected;\r\n    editTagNameButton.setEnabled(enableEdit);\r\n    boolean enableDelete = enableEdit && !TagNameDefinition.getStandardTagNames().contains(tagNamesList.getSelectedValue().getDisplayName());\r\n    deleteTagNameButton.setEnabled(enableDelete);\r\n    if (isSelected) {\r\n        descriptionTextArea.setText(tagNamesList.getSelectedValue().getDescription());\r\n        if (tagNamesList.getSelectedValue().getKnownStatus() == TskData.FileKnown.BAD) {\r\n            notableYesOrNoLabel.setText(\"Yes\");\r\n        } else {\r\n            notableYesOrNoLabel.setText(\"No\");\r\n        }\r\n    } else {\r\n        descriptionTextArea.setText(\"\");\r\n        notableYesOrNoLabel.setText(\"\");\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestJob.start",
	"Comment": "starts this ingest job by starting its ingest module pipelines andscheduling the ingest tasks that make up the job.",
	"Method": "List<IngestModuleError> start(){\r\n    List<IngestModuleError> errors = new ArrayList();\r\n    for (DataSourceIngestJob dataSourceJob : this.dataSourceJobs.values()) {\r\n        errors.addAll(dataSourceJob.start());\r\n        if (errors.isEmpty() == false) {\r\n            break;\r\n        }\r\n    }\r\n    if (errors.isEmpty()) {\r\n        for (DataSourceIngestJob dataSourceJob : this.dataSourceJobs.values()) {\r\n            IngestManager.getInstance().fireDataSourceAnalysisStarted(id, dataSourceJob.getId(), dataSourceJob.getDataSource());\r\n        }\r\n    } else {\r\n        cancel(CancellationReason.INGEST_MODULES_STARTUP_FAILED);\r\n    }\r\n    return errors;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.ImageFilePanel.createTimeZoneList",
	"Comment": "creates the drop down list for the time zones and defaults the selectionto the local machine time zone.",
	"Method": "void createTimeZoneList(){\r\n    List<String> timeZoneList = TimeZoneUtils.createTimeZoneList();\r\n    for (String timeZone : timeZoneList) {\r\n        timeZoneComboBox.addItem(timeZone);\r\n    }\r\n    timeZoneComboBox.setSelectedItem(TimeZoneUtils.createTimeZoneString(Calendar.getInstance().getTimeZone()));\r\n}"
}, {
	"Path": "com.mcxiaoke.next.recycler.AdvancedRecyclerArrayAdapter.replaceItem",
	"Comment": "replaces the old with the new item. the new item will not be added when the old one is notfound.",
	"Method": "void replaceItem(T oldObject,T newObject){\r\n    synchronized (mLock) {\r\n        final int position = getPosition(oldObject);\r\n        if (position == -1) {\r\n            return;\r\n        }\r\n        mObjects.remove(position);\r\n        mObjects.add(position, newObject);\r\n        if (isItemTheSame(oldObject, newObject)) {\r\n            if (isContentTheSame(oldObject, newObject)) {\r\n                return;\r\n            }\r\n            notifyItemChanged(position, newObject);\r\n        } else {\r\n            notifyItemRemoved(position);\r\n            notifyItemInserted(position);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.KeywordSearchIngestModule.putIngestStatus",
	"Comment": "records the ingest status for a given file for a given ingest job. usedfor final statistics at the end of the job.",
	"Method": "void putIngestStatus(long ingestJobId,long fileId,IngestStatus status){\r\n    synchronized (ingestStatus) {\r\n        Map<Long, IngestStatus> ingestStatusForJob = ingestStatus.get(ingestJobId);\r\n        if (ingestStatusForJob == null) {\r\n            ingestStatusForJob = new HashMap();\r\n            ingestStatus.put(ingestJobId, ingestStatusForJob);\r\n        }\r\n        ingestStatusForJob.put(fileId, status);\r\n        ingestStatus.put(ingestJobId, ingestStatusForJob);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.Ingester.getContentFields",
	"Comment": "creates a field map from a sleuthkitvisitableitem, that is later sent tosolr.",
	"Method": "Map<String, String> getContentFields(SleuthkitVisitableItem item){\r\n    return item.accept(SOLR_FIELDS_VISITOR);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJobLogger.logIngestJobSettingsErrors",
	"Comment": "logs failure to analyze a data source due to ingest job settings errors.",
	"Method": "void logIngestJobSettingsErrors(){\r\n    log(MessageCategory.ERROR, \"Failed to analyze data source due to settings errors\");\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.MultiUserSettingsPanel.indexingServerSettingsAreValid",
	"Comment": "tests whether or not the indexing server settings are valid.",
	"Method": "boolean indexingServerSettingsAreValid(){\r\n    if (!portNumberIsValid(tbSolrPort.getText().trim())) {\r\n        tbOops.setText(INVALID_INDEXING_SERVER_PORT_MSG);\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.services.TagsOptionsPanelController.cancel",
	"Comment": "this method is called when the cancel button is pressed. it applies toany of the panels that have been opened in the process of using theoptions pane.",
	"Method": "void cancel(){\r\n    getPanel().cancelChanges();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.AbstractCommonAttributeInstance.getDataSource",
	"Comment": "get string name of the data source where this common attribute appears.",
	"Method": "String getDataSource(){\r\n    return this.dataSource;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.hashdatabase.ModalNoButtons.indexThis",
	"Comment": "takes the singular hashdb and indexes it, setting various text labelsalong the way.",
	"Method": "void indexThis(){\r\n    this.INDEXING_PROGBAR.setIndeterminate(true);\r\n    currentDb = this.toIndex.getHashSetName();\r\n    this.CURRENTDB_LABEL.setText(\"(\" + currentDb + \")\");\r\n    this.length = 1;\r\n    this.CURRENTLYON_LABEL.setText(NbBundle.getMessage(this.getClass(), \"ModalNoButtons.indexThis.currentlyIndexing1Db\"));\r\n    if (!this.toIndex.isIndexing()) {\r\n        this.toIndex.addPropertyChangeListener(this);\r\n        HashDbManager.getInstance().indexHashDatabase(toIndex);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.recentactivity.ExtractRegistry.analyzeRegistryFiles",
	"Comment": "identifies registry files in the database by mtimeitem, runs regripper onthem, and parses the output.",
	"Method": "void analyzeRegistryFiles(){\r\n    List<AbstractFile> allRegistryFiles = findRegistryFiles();\r\n    FileWriter logFile = null;\r\n    try {\r\n        logFile = new FileWriter(RAImageIngestModule.getRAOutputPath(currentCase, \"reg\") + File.separator + \"regripper-info.txt\");\r\n    } catch (IOException ex) {\r\n        logger.log(Level.SEVERE, null, ex);\r\n    }\r\n    for (AbstractFile regFile : allRegistryFiles) {\r\n        String regFileName = regFile.getName();\r\n        long regFileId = regFile.getId();\r\n        String regFileNameLocal = RAImageIngestModule.getRATempPath(currentCase, \"reg\") + File.separator + regFileName;\r\n        String outputPathBase = RAImageIngestModule.getRAOutputPath(currentCase, \"reg\") + File.separator + regFileName + \"-regripper-\" + Long.toString(regFileId);\r\n        File regFileNameLocalFile = new File(regFileNameLocal);\r\n        try {\r\n            ContentUtils.writeToFile(regFile, regFileNameLocalFile, context::dataSourceIngestIsCancelled);\r\n        } catch (ReadContentInputStreamException ex) {\r\n            logger.log(Level.WARNING, String.format(\"Error reading registry file '%s' (id=%d).\", regFile.getName(), regFileId), ex);\r\n            this.addErrorMessage(NbBundle.getMessage(this.getClass(), \"ExtractRegistry.analyzeRegFiles.errMsg.errWritingTemp\", this.getName(), regFileName));\r\n            continue;\r\n        } catch (IOException ex) {\r\n            logger.log(Level.SEVERE, String.format(\"Error writing temp registry file '%s' for registry file '%s' (id=%d).\", regFileNameLocal, regFile.getName(), regFileId), ex);\r\n            this.addErrorMessage(NbBundle.getMessage(this.getClass(), \"ExtractRegistry.analyzeRegFiles.errMsg.errWritingTemp\", this.getName(), regFileName));\r\n            continue;\r\n        }\r\n        if (context.dataSourceIngestIsCancelled()) {\r\n            break;\r\n        }\r\n        try {\r\n            if (logFile != null) {\r\n                logFile.write(Long.toString(regFileId) + \"\\t\" + regFile.getUniquePath() + \"\\n\");\r\n            }\r\n        } catch (TskCoreException | IOException ex) {\r\n            logger.log(Level.SEVERE, null, ex);\r\n        }\r\n        logger.log(Level.INFO, \"{0}- Now getting registry information from {1}\", new Object[] { moduleName, regFileNameLocal });\r\n        RegOutputFiles regOutputFiles = ripRegistryFile(regFileNameLocal, outputPathBase);\r\n        if (context.dataSourceIngestIsCancelled()) {\r\n            break;\r\n        }\r\n        if (regOutputFiles.autopsyPlugins.isEmpty() == false) {\r\n            if (parseAutopsyPluginOutput(regOutputFiles.autopsyPlugins, regFile) == false) {\r\n                this.addErrorMessage(NbBundle.getMessage(this.getClass(), \"ExtractRegistry.analyzeRegFiles.failedParsingResults\", this.getName(), regFileName));\r\n            }\r\n        }\r\n        if (!regOutputFiles.fullPlugins.isEmpty()) {\r\n            try {\r\n                Report report = // NON-NLS\r\n                currentCase.addReport(// NON-NLS\r\n                regOutputFiles.fullPlugins, // NON-NLS\r\n                NbBundle.getMessage(this.getClass(), \"ExtractRegistry.parentModuleName.noSpace\"), \"RegRipper \" + regFile.getUniquePath(), regFile);\r\n                KeywordSearchService searchService = Lookup.getDefault().lookup(KeywordSearchService.class);\r\n                if (null == searchService) {\r\n                    logger.log(Level.WARNING, \"Keyword search service not found. Report will not be indexed\");\r\n                } else {\r\n                    searchService.index(report);\r\n                }\r\n            } catch (TskCoreException e) {\r\n                this.addErrorMessage(\"Error adding regripper output as Autopsy report: \" + e.getLocalizedMessage());\r\n            }\r\n        }\r\n        regFileNameLocalFile.delete();\r\n    }\r\n    try {\r\n        if (logFile != null) {\r\n            logFile.close();\r\n        }\r\n    } catch (IOException ex) {\r\n        logger.log(Level.SEVERE, null, ex);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestMonitor.getPendingJobs",
	"Comment": "gets the snapshot of the pending jobs queue for an auto ingest cluster.",
	"Method": "List<AutoIngestJob> getPendingJobs(){\r\n    synchronized (jobsLock) {\r\n        return new ArrayList(jobsSnapshot.pendingJobs);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.ui.detailview.EventClusterNode.getNewExpandButton",
	"Comment": "get a new button configured to expand this cluster when pressed.",
	"Method": "Button getNewExpandButton(){\r\n    return ActionUtils.createButton(new ExpandClusterAction(this), ActionUtils.ActionTextBehavior.HIDE);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.services.TagsOptionsPanelController.applyChanges",
	"Comment": "this method is called when both the ok and apply buttons are pressed. itapplies to any of the panels that have been opened in the process ofusing the options pane.",
	"Method": "void applyChanges(){\r\n    if (changed) {\r\n        getPanel().store();\r\n        changed = false;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.AbstractSqlEamDb.isArtifactKnownBadByReference",
	"Comment": "is the artifact known as bad according to the reference entries?",
	"Method": "boolean isArtifactKnownBadByReference(CorrelationAttributeInstance.Type aType,String value){\r\n    String normalizeValued = CorrelationAttributeNormalizer.normalize(aType, value);\r\n    if (aType.getId() != CorrelationAttributeInstance.FILES_TYPE_ID) {\r\n        return false;\r\n    }\r\n    Connection conn = connect();\r\n    Long badInstances = 0L;\r\n    PreparedStatement preparedStatement = null;\r\n    ResultSet resultSet = null;\r\n    String sql = \"SELECT count(*) FROM %s WHERE value=? AND known_status=?\";\r\n    try {\r\n        preparedStatement = conn.prepareStatement(String.format(sql, EamDbUtil.correlationTypeToReferenceTableName(aType)));\r\n        preparedStatement.setString(1, normalizeValued);\r\n        preparedStatement.setByte(2, TskData.FileKnown.BAD.getFileKnownValue());\r\n        resultSet = preparedStatement.executeQuery();\r\n        resultSet.next();\r\n        badInstances = resultSet.getLong(1);\r\n    } catch (SQLException ex) {\r\n        throw new EamDbException(\"Error determining if artifact is notable by reference.\", ex);\r\n    } finally {\r\n        EamDbUtil.closeStatement(preparedStatement);\r\n        EamDbUtil.closeResultSet(resultSet);\r\n        EamDbUtil.closeConnection(conn);\r\n    }\r\n    return 0 < badInstances;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.ImageGalleryPreferences.isEnabledByDefault",
	"Comment": "return setting of whether image analyzer should be automatically enabledwhen a new case is created. note that the current case may have adifferent setting.",
	"Method": "boolean isEnabledByDefault(){\r\n    return preferences.getBoolean(ENABLED_BY_DEFAULT, true);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.interestingitems.FilesSetDefsPanel.doFilesSetRuleDialog",
	"Comment": "display an interesting files set membership rule definition panel in adialog box and respond to user interactions with the dialog.",
	"Method": "void doFilesSetRuleDialog(FilesSet.Rule selectedRule){\r\n    FilesSetRulePanel panel;\r\n    if (selectedRule != null) {\r\n        panel = new FilesSetRulePanel(selectedRule, okButton, cancelButton, panelType);\r\n    } else {\r\n        panel = new FilesSetRulePanel(okButton, cancelButton, panelType);\r\n    }\r\n    int option = JOptionPane.OK_OPTION;\r\n    do {\r\n        option = JOptionPane.showOptionDialog(this, panel, NbBundle.getMessage(FilesSetPanel.class, ruleDialogTitle), JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE, null, new Object[] { okButton, cancelButton }, okButton);\r\n    } while (option == JOptionPane.OK_OPTION && !panel.isValidRuleDefinition());\r\n    if (option == JOptionPane.OK_OPTION) {\r\n        FilesSet selectedSet = this.setsList.getSelectedValue();\r\n        Map<String, FilesSet.Rule> rules = new HashMap(selectedSet.getRules());\r\n        if (selectedRule != null) {\r\n            rules.remove(selectedRule.getUuid());\r\n        }\r\n        FilesSet.Rule newRule = new FilesSet.Rule(panel.getRuleName(), panel.getFileNameCondition(), panel.getMetaTypeCondition(), panel.getPathCondition(), panel.getMimeTypeCondition(), panel.getFileSizeCondition(), panel.getDateCondition());\r\n        rules.put(newRule.getUuid(), newRule);\r\n        this.replaceFilesSet(selectedSet, selectedSet.getName(), selectedSet.getDescription(), selectedSet.ignoresKnownFiles(), selectedSet.ingoresUnallocatedSpace(), rules);\r\n        EventQueue.invokeLater(() -> {\r\n            this.rulesList.setSelectedValue(newRule, true);\r\n        });\r\n    }\r\n}"
}, {
	"Path": "com.mcxiaoke.next.collection.WeakFastHashMap.containsValue",
	"Comment": "return true if this map contains one or more keys mappingto the specified value.",
	"Method": "boolean containsValue(Object value){\r\n    if (fast) {\r\n        return (map.containsValue(value));\r\n    } else {\r\n        synchronized (map) {\r\n            return (map.containsValue(value));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.KeywordSearchJobSettings.keywordListIsEnabled",
	"Comment": "checks whether or not a keywords list is enabled. if there is no settingfor the requested list, it is deemed to be enabled.",
	"Method": "boolean keywordListIsEnabled(String keywordListName){\r\n    this.upgradeFromOlderVersions();\r\n    return namesOfEnabledKeywordLists.contains(keywordListName);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.volatilityDSP.AddMemoryImageTask.cancelTask",
	"Comment": "requests cancellation of this task by setting a cancelled flag.",
	"Method": "void cancelTask(){\r\n    isCancelled = true;\r\n    if (volatilityProcessor != null) {\r\n        volatilityProcessor.cancel();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.RecentCases.getName",
	"Comment": "gets the name of this action. this may be presented as an item in a menu.",
	"Method": "String getName(int i,String getName){\r\n    return NbBundle.getMessage(RecentCases.class, \"RecentCases.getName.text\");\r\n}"
}, {
	"Path": "com.mcxiaoke.next.recycler.AdvancedRecyclerArrayAdapter.sort",
	"Comment": "sorts the content of this adapter using the specified comparator.",
	"Method": "void sort(Comparator<? super T> comparator){\r\n    final ArrayList<T> copy = new ArrayList(mObjects);\r\n    Collections.sort(copy, comparator);\r\n    swap(copy);\r\n}"
}, {
	"Path": "org.wikipedia.page.ViewHideHandler.setScrollView",
	"Comment": "update the webview based on whose scroll position the search bar will hide itself.",
	"Method": "void setScrollView(ObservableWebView webView){\r\n    this.webView = webView;\r\n    if (webView != null) {\r\n        webView.addOnScrollChangeListener(this);\r\n        webView.addOnDownMotionEventListener(this);\r\n        webView.addOnUpOrCancelMotionEventListener(this);\r\n        webView.addOnClickListener(this);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.gui.navpanel.GroupTreeItem.resortChildren",
	"Comment": "must be performed on fx thread because it manipualtes the tree directly.",
	"Method": "void resortChildren(Comparator<DrawableGroup> newComp){\r\n    this.comp = newComp;\r\n    getChildren().sort(Comparator.comparing(treeItem -> treeItem.getValue().getGroup(), Comparator.nullsLast(comp)));\r\n    childMap.values().forEach(treeItem -> treeItem.resortChildren(comp));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.DataResultViewerTable.storeColumnOrder",
	"Comment": "persists the current column ordering for the child outlineview of thistabular result viewer using a preferences file.",
	"Method": "void storeColumnOrder(){\r\n    if (rootNode == null || propertiesMap.isEmpty()) {\r\n        return;\r\n    }\r\n    if (rootNode instanceof TableFilterNode) {\r\n        TableFilterNode tfn = (TableFilterNode) rootNode;\r\n        final Preferences preferences = NbPreferences.forModule(DataResultViewerTable.class);\r\n        for (Map.Entry<Integer, Property<?>> entry : propertiesMap.entrySet()) {\r\n            preferences.putInt(ResultViewerPersistence.getColumnPositionKey(tfn, entry.getValue().getName()), entry.getKey());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.DataSourceIngestJob.hasFirstStageDataSourceIngestPipeline",
	"Comment": "checks to see if this job has a first stage data source level ingestpipeline.",
	"Method": "boolean hasFirstStageDataSourceIngestPipeline(){\r\n    return (this.firstStageDataSourceIngestPipeline.isEmpty() == false);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.gui.drawableviews.DrawableUIBase.newProgressIndicator",
	"Comment": "get a new progress indicator to use as a place holder for the image inthis view.",
	"Method": "Node newProgressIndicator(Task<?> imageTask){\r\n    ProgressIndicator loadingProgressIndicator = new ProgressIndicator(-1);\r\n    loadingProgressIndicator.progressProperty().bind(imageTask.progressProperty());\r\n    return loadingProgressIndicator;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.ExecUtil.getExitValue",
	"Comment": "gets the exit value returned by the subprocess used to execute a command.",
	"Method": "int getExitValue(){\r\n    return this.exitValue;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.fileextmismatch.FileExtMismatchDetectorModuleSettings.readObject",
	"Comment": "called by convention by the serialization infrastructure whendeserializing a fileextmismatchdetectormodulesettings object.",
	"Method": "void readObject(ObjectInputStream in){\r\n    in.defaultReadObject();\r\n    if (0L == versionNumber) {\r\n        skipKnownFiles = true;\r\n        versionNumber = 1;\r\n    }\r\n    if (1 == versionNumber) {\r\n        checkType = CHECK_TYPE.ONLY_MEDIA_AND_EXE;\r\n        versionNumber = 2;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.events.AutopsyEventPublisher.publish",
	"Comment": "publishes an event to this autopsy node and other autopsy nodes.",
	"Method": "void publish(AutopsyEvent event){\r\n    publishLocally(event);\r\n    publishRemotely(event);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.db.EventsRepository.getEventIDsForArtifact",
	"Comment": "get a list of event ids for the events that are derived from the givenartifact.",
	"Method": "List<Long> getEventIDsForArtifact(BlackboardArtifact artifact){\r\n    return eventDB.getEventIDsForArtifact(artifact);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.optionspanel.AddNewOrganizationDialog.valid",
	"Comment": "validates that the form is filled out correctly for our usage.",
	"Method": "boolean valid(){\r\n    lbWarningMsg.setText(\"\");\r\n    return enableOkButton(checkFields());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.InterCasePanel.setupCorrelationTypeFilter",
	"Comment": "if the eamdb is enabled, the ui will populate the correlation typecombobox with available types in the cr.",
	"Method": "void setupCorrelationTypeFilter(){\r\n    this.correlationTypeFilters = new HashMap();\r\n    try {\r\n        List<CorrelationAttributeInstance.Type> types = CorrelationAttributeInstance.getDefaultCorrelationTypes();\r\n        for (CorrelationAttributeInstance.Type type : types) {\r\n            correlationTypeFilters.put(type.getDisplayName(), type);\r\n            this.correlationTypeComboBox.addItem(type.getDisplayName());\r\n        }\r\n    } catch (EamDbException ex) {\r\n        Exceptions.printStackTrace(ex);\r\n    }\r\n    this.correlationTypeComboBox.setSelectedIndex(0);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.TikaTextExtractor.getMetaDataCharSource",
	"Comment": "gets a charsource that wraps a formated representation of the givenmetadata.",
	"Method": "CharSource getMetaDataCharSource(Metadata metadata){\r\n    return CharSource.wrap(new StringBuilder(\"\\n\\n------------------------------METADATA------------------------------\\n\\n\").append(Stream.of(metadata.names()).sorted().map(key -> key + \": \" + metadata.get(key)).collect(Collectors.joining(\"\\n\"))));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.stix.STIXReportModule.evaluateSingleObservable",
	"Comment": "evaluate one observable and return the result. this is at the end of theobservable composition tree and will not be called recursively.",
	"Method": "ObservableResult evaluateSingleObservable(Observable obs,String spacing){\r\n    if (idToResult.containsKey(makeMapKey(obs))) {\r\n        return idToResult.get(makeMapKey(obs));\r\n    }\r\n    if (obs.getIdref() == null) {\r\n        if (obs.getId() != null) {\r\n            saveToObjectMap(obs);\r\n        }\r\n        if (obs.getObject() != null) {\r\n            ObservableResult result = evaluateObject(obs.getObject(), spacing, makeMapKey(obs));\r\n            idToResult.put(makeMapKey(obs), result);\r\n            return result;\r\n        }\r\n    }\r\n    if (idToObjectMap.containsKey(makeMapKey(obs))) {\r\n        ObservableResult result = evaluateObject(idToObjectMap.get(makeMapKey(obs)), spacing, makeMapKey(obs));\r\n        idToResult.put(makeMapKey(obs), result);\r\n        return result;\r\n    }\r\n    throw new TskCoreException(\"Error loading/finding object for observable \" + obs.getIdref());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.AddImageWizardIngestConfigPanel.storeSettings",
	"Comment": "provides the wizard panel with the opportunity to update the settingswith its current customized state. rather than updating its settings withevery change in the gui, it should collect them, and then only save themwhen requested to by this method. this method can be called multipletimes on one instance of wizarddescriptor.panel.",
	"Method": "void storeSettings(WizardDescriptor settings){\r\n    IngestJobSettings ingestJobSettings = ingestJobSettingsPanel.getSettings();\r\n    ingestJobSettings.save();\r\n    progressPanel.setIngestJobSettings(ingestJobSettings);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.ButtonColumn.actionPerformed",
	"Comment": "the button has been pressed. stop editing and invoke the custom action",
	"Method": "void actionPerformed(ActionEvent e){\r\n    int row = table.convertRowIndexToModel(table.getEditingRow());\r\n    fireEditingStopped();\r\n    ActionEvent event = new ActionEvent(table, ActionEvent.ACTION_PERFORMED, \"\" + row);\r\n    action.actionPerformed(event);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.datamodel.DrawableTagsManager.unregisterListener",
	"Comment": "unregister an object from receiving categorychangeevents",
	"Method": "void unregisterListener(Object listener){\r\n    tagsEventBus.unregister(listener);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestManager.beginIngestJob",
	"Comment": "immdiately starts an ingest job for one or more data sources.",
	"Method": "IngestJobStartResult beginIngestJob(Collection<Content> dataSources,IngestJobSettings settings){\r\n    if (caseIsOpen) {\r\n        IngestJob job = new IngestJob(dataSources, settings, RuntimeProperties.runningWithGUI());\r\n        if (job.hasIngestPipeline()) {\r\n            return startIngestJob(job);\r\n        }\r\n        return new IngestJobStartResult(null, new IngestManagerException(\"No ingest pipeline created, likely due to no ingest modules being enabled\"), null);\r\n    }\r\n    return new IngestJobStartResult(null, new IngestManagerException(\"No case open\"), null);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.CommonAttributeValueList.displayDelayedMetadata",
	"Comment": "dynamically load the list commonattributevalue when called. until calledmetadatalist should be empty. the parent node, instancecountnode, willtrigger the factory call and refresh.",
	"Method": "void displayDelayedMetadata(){\r\n    if (metadataList.isEmpty()) {\r\n        this.metadataList.addAll(this.delayedMetadataList);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJobLogger.logJobCancelled",
	"Comment": "logs the cancellation of an auto ingest job during processing.",
	"Method": "void logJobCancelled(){\r\n    log(MessageCategory.WARNING, \"Auto ingest job cancelled during processing\");\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.stix.STIXReportModule.evaluateObservableComposition",
	"Comment": "evaluate an observable composition. can be called recursively.",
	"Method": "ObservableResult evaluateObservableComposition(ObservableCompositionType comp,String spacing){\r\n    if (comp.getOperator() == null) {\r\n        throw new TskCoreException(\"No operator found in composition\");\r\n    }\r\n    if (comp.getObservables() != null) {\r\n        List<Observable> obsList = comp.getObservables();\r\n        if (comp.getOperator() == OperatorTypeEnum.AND) {\r\n            ObservableResult result = new ObservableResult(OperatorTypeEnum.AND, spacing);\r\n            for (Observable o : obsList) {\r\n                ObservableResult newResult;\r\n                if (o.getObservableComposition() != null) {\r\n                    newResult = evaluateObservableComposition(o.getObservableComposition(), spacing + \"  \");\r\n                    if (result == null) {\r\n                        result = newResult;\r\n                    } else {\r\n                        result.addResult(newResult, OperatorTypeEnum.AND);\r\n                    }\r\n                } else {\r\n                    newResult = evaluateSingleObservable(o, spacing + \"  \");\r\n                    if (result == null) {\r\n                        result = newResult;\r\n                    } else {\r\n                        result.addResult(newResult, OperatorTypeEnum.AND);\r\n                    }\r\n                }\r\n                if ((!skipShortCircuit) && !result.isFalse()) {\r\n                    return result;\r\n                }\r\n            }\r\n            if (result == null) {\r\n                return new ObservableResult(\"\", \"\", spacing, ObservableResult.ObservableState.INDETERMINATE, null);\r\n            }\r\n            return result;\r\n        } else {\r\n            ObservableResult result = new ObservableResult(OperatorTypeEnum.OR, spacing);\r\n            for (Observable o : obsList) {\r\n                ObservableResult newResult;\r\n                if (o.getObservableComposition() != null) {\r\n                    newResult = evaluateObservableComposition(o.getObservableComposition(), spacing + \"  \");\r\n                    if (result == null) {\r\n                        result = newResult;\r\n                    } else {\r\n                        result.addResult(newResult, OperatorTypeEnum.OR);\r\n                    }\r\n                } else {\r\n                    newResult = evaluateSingleObservable(o, spacing + \"  \");\r\n                    if (result == null) {\r\n                        result = newResult;\r\n                    } else {\r\n                        result.addResult(newResult, OperatorTypeEnum.OR);\r\n                    }\r\n                }\r\n                if ((!skipShortCircuit) && result.isTrue()) {\r\n                    return result;\r\n                }\r\n            }\r\n            if (result == null) {\r\n                return new ObservableResult(\"\", \"\", spacing, ObservableResult.ObservableState.INDETERMINATE, null);\r\n            }\r\n            return result;\r\n        }\r\n    } else {\r\n        throw new TskCoreException(\"No observables found in list\");\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.DataSourceIngestJob.cancelCurrentDataSourceIngestModule",
	"Comment": "requests a temporary cancellation of data source level ingest for thisjob in order to stop the currently executing data source ingest module.",
	"Method": "void cancelCurrentDataSourceIngestModule(){\r\n    this.currentDataSourceIngestModuleCancelled = true;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.ProfilePanel.getProfileName",
	"Comment": "get the name of the profile.the name will not contain any trailing or leading spaces.",
	"Method": "String getProfileName(){\r\n    return profileNameField.getText().trim();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.test.CustomArtifactType.addToCaseDatabase",
	"Comment": "adds the custom artifact type, with its associated custom attributetypes, to the case database of the current case.",
	"Method": "void addToCaseDatabase(){\r\n    Blackboard blackboard = Case.getCurrentCaseThrows().getServices().getBlackboard();\r\n    artifactType = blackboard.getOrAddArtifactType(ARTIFACT_TYPE_NAME, ARTIFACT_DISPLAY_NAME);\r\n    intAttrType = blackboard.getOrAddAttributeType(INT_ATTR_TYPE_NAME, BlackboardAttribute.TSK_BLACKBOARD_ATTRIBUTE_VALUE_TYPE.INTEGER, INT_ATTR_DISPLAY_NAME);\r\n    doubleAttrType = blackboard.getOrAddAttributeType(DOUBLE_ATTR_TYPE_NAME, BlackboardAttribute.TSK_BLACKBOARD_ATTRIBUTE_VALUE_TYPE.DOUBLE, DOUBLE_ATTR_DISPLAY_NAME);\r\n    longAttributeType = blackboard.getOrAddAttributeType(LONG_ATTR_TYPE_NAME, BlackboardAttribute.TSK_BLACKBOARD_ATTRIBUTE_VALUE_TYPE.LONG, LONG_ATTR_DISPLAY_NAME);\r\n    dateTimeAttrType = blackboard.getOrAddAttributeType(DATETIME_ATTR_TYPE_NAME, BlackboardAttribute.TSK_BLACKBOARD_ATTRIBUTE_VALUE_TYPE.DATETIME, DATETIME_ATTR_DISPLAY_NAME);\r\n    bytesAttrType = blackboard.getOrAddAttributeType(BYTES_ATTR_TYPE_NAME, BlackboardAttribute.TSK_BLACKBOARD_ATTRIBUTE_VALUE_TYPE.BYTE, BYTES_ATTR_DISPLAY_NAME);\r\n    stringAttrType = blackboard.getOrAddAttributeType(STRING_ATTR_TYPE_NAME, BlackboardAttribute.TSK_BLACKBOARD_ATTRIBUTE_VALUE_TYPE.STRING, STRING_ATTR_DISPLAY_NAME);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.ui.listvew.SwingFXMenuUtils.createFXMenu",
	"Comment": "factory method that creates a javafx menuitem backed by a swingmenuelement",
	"Method": "MenuItem createFXMenu(MenuElement jMenuElement){\r\n    if (jMenuElement == null) {\r\n        return new SeparatorMenuItem();\r\n    } else if (jMenuElement instanceof JMenu) {\r\n        return new MenuAdapter((JMenu) jMenuElement);\r\n    } else if (jMenuElement instanceof JPopupMenu) {\r\n        return new MenuAdapter((JPopupMenu) jMenuElement);\r\n    } else {\r\n        return new MenuItemAdapter((JMenuItem) jMenuElement);\r\n    }\r\n}"
}, {
	"Path": "org.automon.implementations.Jamon.trackException",
	"Comment": "return the automonexpirable just put in the map via the call to exception",
	"Method": "void trackException(JoinPoint jp,Throwable throwable){\r\n    AutomonExpirable exceptionContext = populateArgNamesAndValues_InExceptionContext(jp, throwable);\r\n    List<String> labels = getLabels(throwable);\r\n    for (String label : labels) {\r\n        MonKey key = new MonKeyImp(label, exceptionContext, \"Exception\");\r\n        MonitorFactory.add(key, 1);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestTasksScheduler.scheduleFileIngestTasks",
	"Comment": "schedules file tasks for either all the files or a given subset of thefiles for a data source source ingest job.",
	"Method": "void scheduleFileIngestTasks(DataSourceIngestJob job,Collection<AbstractFile> files){\r\n    if (!job.isCancelled()) {\r\n        Collection<AbstractFile> candidateFiles;\r\n        if (files.isEmpty()) {\r\n            candidateFiles = getTopLevelFiles(job.getDataSource());\r\n        } else {\r\n            candidateFiles = files;\r\n        }\r\n        for (AbstractFile file : candidateFiles) {\r\n            FileIngestTask task = new FileIngestTask(job, file);\r\n            if (IngestTasksScheduler.shouldEnqueueFileTask(task)) {\r\n                this.rootFileTaskQueue.add(task);\r\n            }\r\n        }\r\n        shuffleFileTaskQueues();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.report.ReportHTML.writeSummarySoftwareInfo",
	"Comment": "write the software information section of the summary for this report.",
	"Method": "StringBuilder writeSummarySoftwareInfo(SleuthkitCase skCase,List<IngestJobInfo> ingestJobs){\r\n    StringBuilder summary = new StringBuilder();\r\n    summary.append(NbBundle.getMessage(this.getClass(), \"ReportHTML.writeSum.softwareInfoHeading\"));\r\n    summary.append(\"<div class=\\\"info\\\">\\n\");\r\n    summary.append(\"<table>\\n\");\r\n    summary.append(\"<tr><td>\").append(NbBundle.getMessage(this.getClass(), \"ReportHTML.writeSum.autopsyVersion\")).append(\"<\/td><td>\").append(Version.getVersion()).append(\"<\/td><\/tr>\\n\");\r\n    Map<Long, IngestModuleInfo> moduleInfoHashMap = new HashMap();\r\n    for (IngestJobInfo ingestJob : ingestJobs) {\r\n        List<IngestModuleInfo> ingestModules = ingestJob.getIngestModuleInfo();\r\n        for (IngestModuleInfo ingestModule : ingestModules) {\r\n            if (!moduleInfoHashMap.containsKey(ingestModule.getIngestModuleId())) {\r\n                moduleInfoHashMap.put(ingestModule.getIngestModuleId(), ingestModule);\r\n            }\r\n        }\r\n    }\r\n    TreeMap<String, String> modules = new TreeMap();\r\n    for (IngestModuleInfo moduleinfo : moduleInfoHashMap.values()) {\r\n        modules.put(moduleinfo.getDisplayName(), moduleinfo.getVersion());\r\n    }\r\n    for (Map.Entry<String, String> module : modules.entrySet()) {\r\n        summary.append(\"<tr><td>\").append(module.getKey()).append(\" Module:\").append(\"<\/td><td>\").append(module.getValue()).append(\"<\/td><\/tr>\\n\");\r\n    }\r\n    summary.append(\"<\/table>\\n\");\r\n    summary.append(\"<\/div>\\n\");\r\n    summary.append(\"<div class=\\\"clear\\\"><\/div>\\n\");\r\n    return summary;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestControlPanel.getInstance",
	"Comment": "gets the singleton automated ingest control and monitoring panel for thiscluster node.",
	"Method": "AutoIngestControlPanel getInstance(){\r\n    if (null == instance) {\r\n        instance = new AutoIngestControlPanel();\r\n    }\r\n    return instance;\r\n}"
}, {
	"Path": "com.aliyun.oss.internal.ResponseParsers.parseGetLiveChannelStat",
	"Comment": "unmarshall get live channel stat response body to corresponding result.",
	"Method": "LiveChannelStat parseGetLiveChannelStat(InputStream responseBody){\r\n    try {\r\n        Element root = getXmlRootElement(responseBody);\r\n        LiveChannelStat result = new LiveChannelStat();\r\n        result.setPushflowStatus(PushflowStatus.parse(root.getChildText(\"Status\")));\r\n        if (root.getChild(\"ConnectedTime\") != null) {\r\n            result.setConnectedDate(DateUtil.parseIso8601Date(root.getChildText(\"ConnectedTime\")));\r\n        }\r\n        if (root.getChild(\"RemoteAddr\") != null) {\r\n            result.setRemoteAddress(root.getChildText(\"RemoteAddr\"));\r\n        }\r\n        Element videoElem = root.getChild(\"Video\");\r\n        if (videoElem != null) {\r\n            VideoStat videoStat = new VideoStat();\r\n            videoStat.setWidth(Integer.parseInt(videoElem.getChildText(\"Width\")));\r\n            videoStat.setHeight(Integer.parseInt(videoElem.getChildText(\"Height\")));\r\n            videoStat.setFrameRate(Integer.parseInt(videoElem.getChildText(\"FrameRate\")));\r\n            videoStat.setBandWidth(Integer.parseInt(videoElem.getChildText(\"Bandwidth\")));\r\n            videoStat.setCodec(videoElem.getChildText(\"Codec\"));\r\n            result.setVideoStat(videoStat);\r\n        }\r\n        Element audioElem = root.getChild(\"Audio\");\r\n        if (audioElem != null) {\r\n            AudioStat audioStat = new AudioStat();\r\n            audioStat.setBandWidth(Integer.parseInt(audioElem.getChildText(\"Bandwidth\")));\r\n            audioStat.setSampleRate(Integer.parseInt(audioElem.getChildText(\"SampleRate\")));\r\n            audioStat.setCodec(audioElem.getChildText(\"Codec\"));\r\n            result.setAudioStat(audioStat);\r\n        }\r\n        return result;\r\n    } catch (JDOMParseException e) {\r\n        throw new ResponseParseException(e.getPartialDocument() + \": \" + e.getMessage(), e);\r\n    } catch (Exception e) {\r\n        throw new ResponseParseException(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.TimeLineController.showWindow",
	"Comment": "show the timeline timelinetopcomponent. this method will construct a newinstance of timelinetopcomponent if necessary.",
	"Method": "void showWindow(){\r\n    if (topComponent == null) {\r\n        topComponent = new TimeLineTopComponent(this);\r\n    }\r\n    if (topComponent.isOpened() == false) {\r\n        topComponent.open();\r\n    }\r\n    topComponent.toFront();\r\n    topComponent.requestActive();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.ExecUtil.stop",
	"Comment": "interrupt the running process and stop its stream redirect threads",
	"Method": "void stop(){\r\n    if (errorStringRedirect != null) {\r\n        errorStringRedirect.stopRun();\r\n        errorStringRedirect = null;\r\n    }\r\n    if (outputStringRedirect != null) {\r\n        outputStringRedirect.stopRun();\r\n        outputStringRedirect = null;\r\n    }\r\n    if (outputWriterRedirect != null) {\r\n        outputWriterRedirect.stopRun();\r\n        outputWriterRedirect = null;\r\n    }\r\n    if (proc != null) {\r\n        proc.destroy();\r\n        proc = null;\r\n    }\r\n}"
}, {
	"Path": "com.mcxiaoke.next.utils.MimeUtils.hasExtension",
	"Comment": "returns true if the given extension has a registered mime type.",
	"Method": "boolean hasExtension(String extension){\r\n    if (extension == null || extension.length() == 0) {\r\n        return false;\r\n    }\r\n    return extensionToMimeTypeMap.containsKey(extension);\r\n}"
}, {
	"Path": "com.aliyun.oss.model.OSSObject.forcedClose",
	"Comment": "forcefully close the response. the remaining data in the server will notbe downloaded.",
	"Method": "void forcedClose(){\r\n    this.response.abort();\r\n}"
}, {
	"Path": "com.aliyun.oss.model.UploadPartResult.getETag",
	"Comment": "gets the etag generated by oss.oss would send the md5 value of the parts data received to user in theetag header. to make sure the data transferred is 100% correct, westrongly encouraged user to check the server side md5 with the localcomputed md5 value.",
	"Method": "String getETag(){\r\n    return eTag;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.guiutils.DataSourceLoader.getDataSourceMap",
	"Comment": "get a map of data source ids to their string names for the current case.",
	"Method": "Map<Long, String> getDataSourceMap(){\r\n    Map<Long, String> dataSouceMap = new HashMap();\r\n    Case currentCase = Case.getCurrentCaseThrows();\r\n    SleuthkitCase tskDb = currentCase.getSleuthkitCase();\r\n    loadLogicalSources(tskDb, dataSouceMap);\r\n    loadImageSources(tskDb, dataSouceMap);\r\n    return dataSouceMap;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.GlobalListsManagementPanel.newKeywordListAction",
	"Comment": "opens the dialogue for creating a new keyword list and adds it to thetable.",
	"Method": "void newKeywordListAction(){\r\n    XmlKeywordSearchList writer = XmlKeywordSearchList.getCurrent();\r\n    String listName = \"\";\r\n    listName = (String) JOptionPane.showInputDialog(this, NbBundle.getMessage(this.getClass(), \"KeywordSearch.newKwListTitle\"), NbBundle.getMessage(this.getClass(), \"KeywordSearch.newKeywordListMsg\"), JOptionPane.PLAIN_MESSAGE, null, null, listName);\r\n    if (listName == null || listName.trim().isEmpty()) {\r\n        return;\r\n    }\r\n    boolean shouldAdd = false;\r\n    if (writer.listExists(listName)) {\r\n        if (writer.getList(listName).isEditable()) {\r\n            boolean replace = KeywordSearchUtil.displayConfirmDialog(NbBundle.getMessage(this.getClass(), \"KeywordSearch.newKeywordListMsg\"), NbBundle.getMessage(this.getClass(), \"KeywordSearchListsManagementPanel.newKeywordListDescription\", listName), KeywordSearchUtil.DIALOG_MESSAGE_TYPE.WARN);\r\n            if (replace) {\r\n                shouldAdd = true;\r\n            }\r\n        } else {\r\n            boolean replace = KeywordSearchUtil.displayConfirmDialog(NbBundle.getMessage(this.getClass(), \"KeywordSearch.newKeywordListMsg\"), NbBundle.getMessage(this.getClass(), \"KeywordSearchListsManagementPanel.newKeywordListDescription2\", listName), KeywordSearchUtil.DIALOG_MESSAGE_TYPE.WARN);\r\n            if (replace) {\r\n                shouldAdd = true;\r\n            }\r\n        }\r\n    } else {\r\n        shouldAdd = true;\r\n    }\r\n    if (shouldAdd) {\r\n        writer.addList(listName, new ArrayList());\r\n    }\r\n    tableModel.resync();\r\n    for (int i = 0; i < listsTable.getRowCount(); i++) {\r\n        if (listsTable.getValueAt(i, 0).equals(listName)) {\r\n            listsTable.getSelectionModel().addSelectionInterval(i, i);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.mcxiaoke.next.recycler.HeaderFooterRecyclerAdapter.getHeaderItemViewType",
	"Comment": "gets the header item view type. by default, this method returns 0.",
	"Method": "int getHeaderItemViewType(int position){\r\n    return 0;\r\n}"
}, {
	"Path": "com.fernandocejas.arrow.collections.MoreArrays.concat",
	"Comment": "returns a new array that contains the concatenated contents of two arrays.",
	"Method": "T[] concat(T[] first,T[] second,Class<T> type,T[] concat,T element,T[] array,T[] concat,T[] array,T element){\r\n    T[] result = Arrays.copyOf(array, array.length + 1);\r\n    result[array.length] = element;\r\n    return result;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.FileUtil.escapeFileName",
	"Comment": "escape special characters in a file name or a file name component",
	"Method": "String escapeFileName(String fileName){\r\n    return fileName.replaceAll(\"[\\\\p{Cntrl}/:\\\"*?<>|]+\", \"_\");\r\n}"
}, {
	"Path": "org.wikipedia.page.PageToolbarHideHandler.setForceNoFade",
	"Comment": "whether to temporarily disable fading of the search bar, even if fading is enabled otherwise.may be used when displaying a temporary ui element that requires the search bar to be shownfully, e.g. when the toc is pulled out.",
	"Method": "void setForceNoFade(boolean force){\r\n    forceNoFade = force;\r\n    update();\r\n}"
}, {
	"Path": "com.mcxiaoke.next.utils.StringUtils.addStringToArray",
	"Comment": "append the given string to the given string array, returning a new arrayconsisting of the input array contents plus the given string.",
	"Method": "String[] addStringToArray(String[] array,String str){\r\n    if (isEmpty(array)) {\r\n        return new String[] { str };\r\n    }\r\n    String[] newArr = new String[array.length + 1];\r\n    System.arraycopy(array, 0, newArr, 0, array.length);\r\n    newArr[array.length] = str;\r\n    return newArr;\r\n}"
}, {
	"Path": "org.wikipedia.page.shareafact.SnippetImage.getSnippetImage",
	"Comment": "creates a card image usable for sharing and the preview of the same.if we have a leadimagebitmap the use that as the background. if not thenjust use a black background.",
	"Method": "Bitmap getSnippetImage(Context context,Bitmap leadImageBitmap,String title,String description,CharSequence textSnippet,ImageLicense license){\r\n    Bitmap resultBitmap = drawBackground(leadImageBitmap, license);\r\n    Canvas canvas = new Canvas(resultBitmap);\r\n    if (leadImageBitmap != null) {\r\n        drawGradient(canvas);\r\n    }\r\n    Layout textLayout = drawTextSnippet(canvas, textSnippet);\r\n    boolean isArticleRTL = textLayout.getParagraphDirection(0) == Layout.DIR_RIGHT_TO_LEFT;\r\n    drawLicenseIcons(context, leadImageBitmap, license, canvas, isArticleRTL);\r\n    int top = drawDescription(canvas, description, HEIGHT - BOTTOM_PADDING - ICONS_HEIGHT, isArticleRTL);\r\n    drawTitle(canvas, title, top, isArticleRTL);\r\n    if (L10nUtil.canLangUseImageForWikipediaWordmark(context)) {\r\n        drawWordmarkFromStaticImage(context, canvas, isArticleRTL);\r\n    } else {\r\n        drawWordmarkFromText(context, canvas, isArticleRTL);\r\n    }\r\n    return resultBitmap;\r\n}"
}, {
	"Path": "org.codechimp.apprater.AppRater.showRateDialog",
	"Comment": "call this method directly if you want to force a rate prompt, useful fortesting purposes",
	"Method": "void showRateDialog(Context context){\r\n    showRateAlertDialog(context, null);\r\n}"
}, {
	"Path": "com.mcxiaoke.next.Charsets.toCharset",
	"Comment": "returns a charset for the named charset. if the name is null, return the default charset.",
	"Method": "Charset toCharset(Charset charset,Charset toCharset,String charset){\r\n    return charset == null ? Charset.defaultCharset() : Charset.forName(charset);\r\n}"
}, {
	"Path": "com.mcxiaoke.next.utils.StringUtils.concatenateStringArrays",
	"Comment": "concatenate the given string arrays into one, with overlapping arrayelements included twice.the order of elements in the original arrays is preserved.",
	"Method": "String[] concatenateStringArrays(String[] array1,String[] array2){\r\n    if (isEmpty(array1)) {\r\n        return array2;\r\n    }\r\n    if (isEmpty(array2)) {\r\n        return array1;\r\n    }\r\n    String[] newArr = new String[array1.length + array2.length];\r\n    System.arraycopy(array1, 0, newArr, 0, array1.length);\r\n    System.arraycopy(array2, 0, newArr, array1.length, array2.length);\r\n    return newArr;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.stix.EvaluatableObject.getWarnings",
	"Comment": "get the warnings string. this should not be used to print the finalversion of the warnings.",
	"Method": "String getWarnings(){\r\n    return warnings;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.events.LocalEventPublisher.publish",
	"Comment": "publishes an event to all registered subscribers, even if a subscriberthrows an exception.",
	"Method": "void publish(AutopsyEvent event){\r\n    Set<PropertyChangeListener> subscribers = subscribersByEvent.getOrDefault(event.getPropertyName(), null);\r\n    if (null != subscribers) {\r\n        subscribers.forEach((subscriber) -> {\r\n            try {\r\n                subscriber.propertyChange(event);\r\n            } catch (Exception ex) {\r\n                logger.log(Level.SEVERE, \"Exception thrown by subscriber\", ex);\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.core.RuntimeProperties.runningWithGUI",
	"Comment": "gets a flag indicating whether or not the application is running with agui.",
	"Method": "boolean runningWithGUI(){\r\n    return runningWithGUI;\r\n}"
}, {
	"Path": "com.litesuits.http.LiteHttp.handleRequest",
	"Comment": "if some of request params is null or 0, set global default value to it.",
	"Method": "InternalResponse<T> handleRequest(AbstractRequest<T> request){\r\n    if (config.commonHeaders != null) {\r\n        request.addHeader(config.commonHeaders);\r\n    }\r\n    if (request.getCacheMode() == null) {\r\n        request.setCacheMode(config.defaultCacheMode);\r\n    }\r\n    if (request.getCacheDir() == null) {\r\n        request.setCacheDir(config.defaultCacheDir);\r\n    }\r\n    if (request.getCacheExpireMillis() < 0) {\r\n        request.setCacheExpireMillis(config.defaultCacheExpireMillis);\r\n    }\r\n    if (request.getCharSet() == null) {\r\n        request.setCharSet(config.defaultCharSet);\r\n    }\r\n    if (request.getMethod() == null) {\r\n        request.setMethod(config.defaultHttpMethod);\r\n    }\r\n    if (request.getMaxRedirectTimes() < 0) {\r\n        request.setMaxRedirectTimes(config.defaultMaxRedirectTimes);\r\n    }\r\n    if (request.getMaxRetryTimes() < 0) {\r\n        request.setMaxRetryTimes(config.defaultMaxRetryTimes);\r\n    }\r\n    if (request.getSocketTimeout() < 0) {\r\n        request.setSocketTimeout(config.socketTimeout);\r\n    }\r\n    if (request.getConnectTimeout() < 0) {\r\n        request.setConnectTimeout(config.connectTimeout);\r\n    }\r\n    if (request.getQueryBuilder() == null) {\r\n        request.setQueryBuilder(config.defaultModelQueryBuilder);\r\n    }\r\n    if (config.globalHttpListener != null) {\r\n        request.setGlobalHttpListener(config.globalHttpListener);\r\n    }\r\n    if (request.getBaseUrl() == null) {\r\n        request.setBaseUrl(config.baseUrl);\r\n    }\r\n    return new InternalResponse<T>(request);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.core.ServicesMonitor.checkDatabaseConnectionStatus",
	"Comment": "performs case database service availability status check.",
	"Method": "void checkDatabaseConnectionStatus(){\r\n    CaseDbConnectionInfo info;\r\n    try {\r\n        info = UserPreferences.getDatabaseConnectionInfo();\r\n    } catch (UserPreferencesException ex) {\r\n        logger.log(Level.SEVERE, \"Error accessing case database connection info\", ex);\r\n        setServiceStatus(Service.REMOTE_CASE_DATABASE.toString(), ServiceStatus.DOWN.toString(), NbBundle.getMessage(this.getClass(), \"ServicesMonitor.databaseConnectionInfo.error.msg\"));\r\n        return;\r\n    }\r\n    try {\r\n        SleuthkitCase.tryConnect(info);\r\n        setServiceStatus(Service.REMOTE_CASE_DATABASE.toString(), ServiceStatus.UP.toString(), \"\");\r\n    } catch (TskCoreException ex) {\r\n        setServiceStatus(Service.REMOTE_CASE_DATABASE.toString(), ServiceStatus.DOWN.toString(), ex.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.MultiUserCasesPanel.refresh",
	"Comment": "gets the list of cases known to the review mode cases manager andrefreshes the cases table.",
	"Method": "void refresh(){\r\n    caseBrowserPanel.refresh();\r\n}"
}, {
	"Path": "net.ypresto.androidtranscoder.MediaTranscoder.transcodeVideo",
	"Comment": "transcodes video file asynchronously.audio track will be kept unchanged.",
	"Method": "Future<Void> transcodeVideo(FileDescriptor inFileDescriptor,String outPath,Listener listener,Future<Void> transcodeVideo,String inPath,String outPath,MediaFormatStrategy outFormatStrategy,Listener listener,Future<Void> transcodeVideo,FileDescriptor inFileDescriptor,String outPath,MediaFormatStrategy outFormatStrategy,Listener listener){\r\n    Looper looper = Looper.myLooper();\r\n    if (looper == null)\r\n        looper = Looper.getMainLooper();\r\n    final Handler handler = new Handler(looper);\r\n    final AtomicReference<Future<Void>> futureReference = new AtomicReference();\r\n    final Future<Void> createdFuture = mExecutor.submit(new Callable<Void>() {\r\n        @Override\r\n        public Void call() throws Exception {\r\n            Exception caughtException = null;\r\n            try {\r\n                MediaTranscoderEngine engine = new MediaTranscoderEngine();\r\n                engine.setProgressCallback(new MediaTranscoderEngine.ProgressCallback() {\r\n                    @Override\r\n                    public void onProgress(final double progress) {\r\n                        handler.post(new Runnable() {\r\n                            @Override\r\n                            public void run() {\r\n                                listener.onTranscodeProgress(progress);\r\n                            }\r\n                        });\r\n                    }\r\n                });\r\n                engine.setDataSource(inFileDescriptor);\r\n                engine.transcodeVideo(outPath, outFormatStrategy);\r\n            } catch (IOException e) {\r\n                Log.w(TAG, \"Transcode failed: input file (fd: \" + inFileDescriptor.toString() + \") not found\" + \" or could not open output file ('\" + outPath + \"') .\", e);\r\n                caughtException = e;\r\n            } catch (InterruptedException e) {\r\n                Log.i(TAG, \"Cancel transcode video file.\", e);\r\n                caughtException = e;\r\n            } catch (RuntimeException e) {\r\n                Log.e(TAG, \"Fatal error while transcoding, this might be invalid format or bug in engine or Android.\", e);\r\n                caughtException = e;\r\n            }\r\n            final Exception exception = caughtException;\r\n            handler.post(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    if (exception == null) {\r\n                        listener.onTranscodeCompleted();\r\n                    } else {\r\n                        Future<Void> future = futureReference.get();\r\n                        if (future != null && future.isCancelled()) {\r\n                            listener.onTranscodeCanceled();\r\n                        } else {\r\n                            listener.onTranscodeFailed(exception);\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n            if (exception != null)\r\n                throw exception;\r\n            return null;\r\n        }\r\n    });\r\n    futureReference.set(createdFuture);\r\n    return createdFuture;\r\n}"
}, {
	"Path": "net.ypresto.androidtranscoder.MediaTranscoder.transcodeVideo",
	"Comment": "transcodes video file asynchronously.audio track will be kept unchanged.",
	"Method": "Future<Void> transcodeVideo(FileDescriptor inFileDescriptor,String outPath,Listener listener,Future<Void> transcodeVideo,String inPath,String outPath,MediaFormatStrategy outFormatStrategy,Listener listener,Future<Void> transcodeVideo,FileDescriptor inFileDescriptor,String outPath,MediaFormatStrategy outFormatStrategy,Listener listener){\r\n    Exception caughtException = null;\r\n    try {\r\n        MediaTranscoderEngine engine = new MediaTranscoderEngine();\r\n        engine.setProgressCallback(new MediaTranscoderEngine.ProgressCallback() {\r\n            @Override\r\n            public void onProgress(final double progress) {\r\n                handler.post(new Runnable() {\r\n                    @Override\r\n                    public void run() {\r\n                        listener.onTranscodeProgress(progress);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n        engine.setDataSource(inFileDescriptor);\r\n        engine.transcodeVideo(outPath, outFormatStrategy);\r\n    } catch (IOException e) {\r\n        Log.w(TAG, \"Transcode failed: input file (fd: \" + inFileDescriptor.toString() + \") not found\" + \" or could not open output file ('\" + outPath + \"') .\", e);\r\n        caughtException = e;\r\n    } catch (InterruptedException e) {\r\n        Log.i(TAG, \"Cancel transcode video file.\", e);\r\n        caughtException = e;\r\n    } catch (RuntimeException e) {\r\n        Log.e(TAG, \"Fatal error while transcoding, this might be invalid format or bug in engine or Android.\", e);\r\n        caughtException = e;\r\n    }\r\n    final Exception exception = caughtException;\r\n    handler.post(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            if (exception == null) {\r\n                listener.onTranscodeCompleted();\r\n            } else {\r\n                Future<Void> future = futureReference.get();\r\n                if (future != null && future.isCancelled()) {\r\n                    listener.onTranscodeCanceled();\r\n                } else {\r\n                    listener.onTranscodeFailed(exception);\r\n                }\r\n            }\r\n        }\r\n    });\r\n    if (exception != null)\r\n        throw exception;\r\n    return null;\r\n}"
}, {
	"Path": "net.ypresto.androidtranscoder.MediaTranscoder.transcodeVideo",
	"Comment": "transcodes video file asynchronously.audio track will be kept unchanged.",
	"Method": "Future<Void> transcodeVideo(FileDescriptor inFileDescriptor,String outPath,Listener listener,Future<Void> transcodeVideo,String inPath,String outPath,MediaFormatStrategy outFormatStrategy,Listener listener,Future<Void> transcodeVideo,FileDescriptor inFileDescriptor,String outPath,MediaFormatStrategy outFormatStrategy,Listener listener){\r\n    handler.post(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            listener.onTranscodeProgress(progress);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "net.ypresto.androidtranscoder.MediaTranscoder.transcodeVideo",
	"Comment": "transcodes video file asynchronously.audio track will be kept unchanged.",
	"Method": "Future<Void> transcodeVideo(FileDescriptor inFileDescriptor,String outPath,Listener listener,Future<Void> transcodeVideo,String inPath,String outPath,MediaFormatStrategy outFormatStrategy,Listener listener,Future<Void> transcodeVideo,FileDescriptor inFileDescriptor,String outPath,MediaFormatStrategy outFormatStrategy,Listener listener){\r\n    listener.onTranscodeProgress(progress);\r\n}"
}, {
	"Path": "net.ypresto.androidtranscoder.MediaTranscoder.transcodeVideo",
	"Comment": "transcodes video file asynchronously.audio track will be kept unchanged.",
	"Method": "Future<Void> transcodeVideo(FileDescriptor inFileDescriptor,String outPath,Listener listener,Future<Void> transcodeVideo,String inPath,String outPath,MediaFormatStrategy outFormatStrategy,Listener listener,Future<Void> transcodeVideo,FileDescriptor inFileDescriptor,String outPath,MediaFormatStrategy outFormatStrategy,Listener listener){\r\n    if (exception == null) {\r\n        listener.onTranscodeCompleted();\r\n    } else {\r\n        Future<Void> future = futureReference.get();\r\n        if (future != null && future.isCancelled()) {\r\n            listener.onTranscodeCanceled();\r\n        } else {\r\n            listener.onTranscodeFailed(exception);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.mcxiaoke.next.recycler.HeaderFooterRecyclerAdapter.getContentItemViewType",
	"Comment": "gets the content item view type. by default, this method returns 0.",
	"Method": "int getContentItemViewType(int position){\r\n    return 0;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.TimeLineController.pushTimeRange",
	"Comment": "set the new interval to view, and record it in the history. the intervalwill be clamped to the span of events in the current case.",
	"Method": "boolean pushTimeRange(Interval timeRange){\r\n    Interval clampedTimeRange;\r\n    if (timeRange == null) {\r\n        clampedTimeRange = this.filteredEvents.getSpanningInterval();\r\n    } else {\r\n        Interval spanningInterval = this.filteredEvents.getSpanningInterval();\r\n        if (spanningInterval.overlaps(timeRange)) {\r\n            clampedTimeRange = spanningInterval.overlap(timeRange);\r\n        } else {\r\n            clampedTimeRange = spanningInterval;\r\n        }\r\n    }\r\n    ZoomParams currentZoom = filteredEvents.zoomParametersProperty().get();\r\n    if (currentZoom == null) {\r\n        advance(InitialZoomState.withTimeRange(clampedTimeRange));\r\n        return true;\r\n    } else if (currentZoom.hasTimeRange(clampedTimeRange) == false) {\r\n        advance(currentZoom.withTimeRange(clampedTimeRange));\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.google.android.voiceime.IntentApiTrigger.format",
	"Comment": "formats the recognised text by adding white spaces at the beginning or at the end, andby making the first char upper case if necessary.",
	"Method": "String format(ExtractedText et,String result){\r\n    int pos = et.selectionStart - 1;\r\n    while (pos > 0 && Character.isWhitespace(et.text.charAt(pos))) {\r\n        pos--;\r\n    }\r\n    if (pos == -1 || mUpperCaseChars.contains(et.text.charAt(pos))) {\r\n        result = Character.toUpperCase(result.charAt(0)) + result.substring(1);\r\n    }\r\n    if (et.selectionStart - 1 > 0 && !Character.isWhitespace(et.text.charAt(et.selectionStart - 1))) {\r\n        result = \" \" + result;\r\n    }\r\n    if (et.selectionEnd < et.text.length() && !Character.isWhitespace(et.text.charAt(et.selectionEnd))) {\r\n        result = result + \" \";\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.suleiman.material.utils.MyRecyclerScroll.onScrolled",
	"Comment": "we dont use this method because its action is called per pixel value change",
	"Method": "void onScrolled(RecyclerView recyclerView,int dx,int dy){\r\n    super.onScrolled(recyclerView, dx, dy);\r\n    if (isVisible && scrollDist > HIDE_THRESHOLD) {\r\n        hide();\r\n        scrollDist = 0;\r\n        isVisible = false;\r\n    } else if (!isVisible && scrollDist < -SHOW_THRESHOLD) {\r\n        show();\r\n        scrollDist = 0;\r\n        isVisible = true;\r\n    }\r\n    if ((isVisible && dy > 0) || (!isVisible && dy < 0)) {\r\n        scrollDist += dy;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.ImageGalleryTopComponent.getTopComponent",
	"Comment": "gets the singleton image gallery top component. note that calling thismethod will cause the top component to be constructed if it does notalready exist.",
	"Method": "ImageGalleryTopComponent getTopComponent(){\r\n    return (ImageGalleryTopComponent) WindowManager.getDefault().findTopComponent(PREFERRED_ID);\r\n}"
}, {
	"Path": "com.anysoftkeyboard.utils.XmlWriter.endEntity",
	"Comment": "end the current entity. this will throw an exception if it is called whenthere is not a currently open entity.",
	"Method": "XmlWriter endEntity(){\r\n    if (mStack.size() == 0) {\r\n        throw new InvalidObjectException(\"Called endEntity too many times. \");\r\n    }\r\n    String name = mStack.pop();\r\n    if (mEmpty) {\r\n        writeAttributes();\r\n        mWriter.write(\"/>\\n\");\r\n    } else {\r\n        if (!mJustWroteText) {\r\n            for (int tabIndex = 0; tabIndex < mStack.size() + mIndentingOffset; tabIndex++) mWriter.write(INDENT_STRING);\r\n        }\r\n        mWriter.write(\"<\/\");\r\n        mWriter.write(name);\r\n        mWriter.write(\">\\n\");\r\n    }\r\n    mEmpty = false;\r\n    mClosed = true;\r\n    mJustWroteText = false;\r\n    return this;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.contentviewer.DataContentViewerOtherCasesTableModel.getColumnPreferredWidth",
	"Comment": "get the preferred width that has been configured for this column.a value of 0 means that no preferred width has been defined for thiscolumn.",
	"Method": "int getColumnPreferredWidth(int colIdx){\r\n    return TableColumns.values()[colIdx].columnWidth();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.interestingitems.FilesSetRulePanel.getOptionPane",
	"Comment": "gets the joptionpane that is used to contain this panel if there is one",
	"Method": "JOptionPane getOptionPane(JComponent parent){\r\n    JOptionPane pane;\r\n    if (!(parent instanceof JOptionPane)) {\r\n        pane = getOptionPane((JComponent) parent.getParent());\r\n    } else {\r\n        pane = (JOptionPane) parent;\r\n    }\r\n    return pane;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.Case.isValidName",
	"Comment": "checks if a case display name is valid, i.e., does not include anycharacters that cannot be used in file names.",
	"Method": "boolean isValidName(String caseName){\r\n    return !(caseName.contains(\"\\\\\") || caseName.contains(\"/\") || caseName.contains(\":\") || caseName.contains(\"*\") || caseName.contains(\"?\") || caseName.contains(\"\\\"\") || caseName.contains(\"<\") || caseName.contains(\">\") || caseName.contains(\"|\"));\r\n}"
}, {
	"Path": "com.litesuits.http.utils.UriUtil.getQueryParameters",
	"Comment": "searches the query string for parameter values with the given key.",
	"Method": "List<String> getQueryParameters(Uri uri,String key){\r\n    if (uri.isOpaque()) {\r\n        return Collections.emptyList();\r\n    }\r\n    if (key == null) {\r\n        throw new NullPointerException(\"key\");\r\n    }\r\n    String query = uri.getEncodedQuery();\r\n    if (query == null) {\r\n        return Collections.emptyList();\r\n    }\r\n    ArrayList<String> values = new ArrayList<String>();\r\n    int start = 0;\r\n    do {\r\n        int nextAmpersand = query.indexOf('&', start);\r\n        int end = nextAmpersand != -1 ? nextAmpersand : query.length();\r\n        int separator = query.indexOf('=', start);\r\n        if (separator > end || separator == -1) {\r\n            separator = end;\r\n        }\r\n        if (separator - start == key.length() && query.regionMatches(start, key, 0, key.length())) {\r\n            if (separator == end) {\r\n                values.add(\"\");\r\n            } else {\r\n                values.add(query.substring(separator + 1, end));\r\n            }\r\n        }\r\n        if (nextAmpersand != -1) {\r\n            start = nextAmpersand + 1;\r\n        } else {\r\n            break;\r\n        }\r\n    } while (true);\r\n    return Collections.unmodifiableList(values);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.AddImageWizardSelectDspVisual.getSelectedDsp",
	"Comment": "get the datasourceprocessor which is currently selected in this panel",
	"Method": "String getSelectedDsp(){\r\n    return selectedDsp;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.StringExtract.setEnabledScript",
	"Comment": "sets the enabled script to one provided, resets previous setting",
	"Method": "void setEnabledScript(SCRIPT script){\r\n    this.enabledScripts = new ArrayList();\r\n    this.enabledScripts.add(script);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.examples.SampleIngestModuleFactory.hasIngestJobSettingsPanel",
	"Comment": "queries the factory to determine if it provides user a interface panel toallow a user to make per ingest job settings for instances of the familyof ingest modules the factory creates. for example, the autopsy core hashlookup ingest module factory provides an ingest job settings panels toenable or disable hash databases per ingest job. if the module familydoes not have per ingest job settings, the factory may extendingestmodulefactoryadapter to get an implementation of this method thatreturns false.",
	"Method": "boolean hasIngestJobSettingsPanel(){\r\n    return true;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestJobSettings.load",
	"Comment": "loads the saved or default ingest job settings for the execution contextinto memory.",
	"Method": "void load(){\r\n    List<IngestModuleFactory> moduleFactories = new ArrayList();\r\n    List<IngestModuleFactory> allModuleFactories = IngestModuleFactoryLoader.getIngestModuleFactories();\r\n    HashSet<String> loadedModuleNames = new HashSet();\r\n    for (IngestModuleFactory moduleFactory : allModuleFactories) {\r\n        if (this.ingestType.equals(IngestType.ALL_MODULES)) {\r\n            moduleFactories.add(moduleFactory);\r\n        } else if (this.ingestType.equals(IngestType.DATA_SOURCE_ONLY) && moduleFactory.isDataSourceIngestModuleFactory()) {\r\n            moduleFactories.add(moduleFactory);\r\n        } else if (this.ingestType.equals(IngestType.FILES_ONLY) && moduleFactory.isFileIngestModuleFactory()) {\r\n            moduleFactories.add(moduleFactory);\r\n        }\r\n    }\r\n    for (IngestModuleFactory moduleFactory : moduleFactories) {\r\n        loadedModuleNames.add(moduleFactory.getModuleDisplayName());\r\n    }\r\n    HashSet<String> enabledModuleNames = getModulesNames(executionContext, IngestJobSettings.ENABLED_MODULES_PROPERTY, makeCsvList(loadedModuleNames));\r\n    HashSet<String> disabledModuleNames = getModulesNames(executionContext, IngestJobSettings.DISABLED_MODULES_PROPERTY, \"\");\r\n    List<String> missingModuleNames = new ArrayList();\r\n    for (String moduleName : enabledModuleNames) {\r\n        if (!loadedModuleNames.contains(moduleName)) {\r\n            missingModuleNames.add(moduleName);\r\n        }\r\n    }\r\n    for (String moduleName : disabledModuleNames) {\r\n        if (!loadedModuleNames.contains(moduleName)) {\r\n            missingModuleNames.add(moduleName);\r\n        }\r\n    }\r\n    for (String moduleName : missingModuleNames) {\r\n        enabledModuleNames.remove(moduleName);\r\n        disabledModuleNames.remove(moduleName);\r\n        String warning = NbBundle.getMessage(IngestJobSettings.class, \"IngestJobSettings.missingModule.warning\", moduleName);\r\n        logger.log(Level.WARNING, warning);\r\n        this.warnings.add(warning);\r\n    }\r\n    for (IngestModuleFactory moduleFactory : moduleFactories) {\r\n        IngestModuleTemplate moduleTemplate = new IngestModuleTemplate(moduleFactory, loadModuleSettings(moduleFactory));\r\n        String moduleName = moduleTemplate.getModuleName();\r\n        if (enabledModuleNames.contains(moduleName)) {\r\n            moduleTemplate.setEnabled(true);\r\n        } else if (disabledModuleNames.contains(moduleName)) {\r\n            moduleTemplate.setEnabled(false);\r\n        } else {\r\n            moduleTemplate.setEnabled(true);\r\n            enabledModuleNames.add(moduleName);\r\n        }\r\n        this.moduleTemplates.add(moduleTemplate);\r\n    }\r\n    ModuleSettings.setConfigSetting(this.executionContext, IngestJobSettings.ENABLED_MODULES_PROPERTY, makeCsvList(enabledModuleNames));\r\n    ModuleSettings.setConfigSetting(this.executionContext, IngestJobSettings.DISABLED_MODULES_PROPERTY, makeCsvList(disabledModuleNames));\r\n    if (ModuleSettings.settingExists(this.executionContext, IngestJobSettings.LAST_FILE_INGEST_FILTER_PROPERTY) == false) {\r\n        ModuleSettings.setConfigSetting(this.executionContext, IngestJobSettings.LAST_FILE_INGEST_FILTER_PROPERTY, FilesSetsManager.getDefaultFilter().getName());\r\n    }\r\n    try {\r\n        Map<String, FilesSet> fileIngestFilters = FilesSetsManager.getInstance().getCustomFileIngestFilters();\r\n        for (FilesSet fSet : FilesSetsManager.getStandardFileIngestFilters()) {\r\n            fileIngestFilters.put(fSet.getName(), fSet);\r\n        }\r\n        this.fileFilter = fileIngestFilters.get(ModuleSettings.getConfigSetting(this.executionContext, IngestJobSettings.LAST_FILE_INGEST_FILTER_PROPERTY));\r\n    } catch (FilesSetsManager.FilesSetsManagerException ex) {\r\n        this.fileFilter = FilesSetsManager.getDefaultFilter();\r\n        logger.log(Level.SEVERE, \"Failed to get file filter from .properties file, default filter being used\", ex);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.Case.getModuleOutputDirectoryRelativePath",
	"Comment": "gets the path of the module output directory for this case, relative tothe case directory, creating it if it does not exist.",
	"Method": "String getModuleOutputDirectoryRelativePath(){\r\n    Path path = Paths.get(getModuleDirectory());\r\n    if (getCaseType() == CaseType.MULTI_USER_CASE) {\r\n        return path.subpath(path.getNameCount() - 2, path.getNameCount()).toString();\r\n    } else {\r\n        return path.subpath(path.getNameCount() - 1, path.getNameCount()).toString();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.db.EventDB.getTagCountsByTagName",
	"Comment": "get a count of tagnames applied to the given event ids as a map fromtagname displayname to count of tag applications",
	"Method": "Map<String, Long> getTagCountsByTagName(Set<Long> eventIDsWithTags){\r\n    HashMap<String, Long> counts = new HashMap();\r\n    DBLock.lock();\r\n    try (Statement createStatement = con.createStatement();\r\n        ResultSet rs = // NON-NLS\r\n        createStatement.executeQuery(\"SELECT tag_name_display_name, COUNT(DISTINCT tag_id) AS count FROM tags\" + \" WHERE event_id IN (\" + StringUtils.join(eventIDsWithTags, \", \") + \")\" + \" GROUP BY tag_name_id\" + \" ORDER BY tag_name_display_name\")) {\r\n        while (rs.next()) {\r\n            counts.put(rs.getString(\"tag_name_display_name\"), rs.getLong(\"count\"));\r\n        }\r\n    } catch (SQLException ex) {\r\n        LOGGER.log(Level.SEVERE, \"Failed to get tag counts by tag name.\", ex);\r\n    } finally {\r\n        DBLock.unlock();\r\n    }\r\n    return counts;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.datamodel.AbstractAbstractFileNode.addTagProperty",
	"Comment": "used by subclasses of abstractabstractfilenode to add the tags propertyto their sheets.",
	"Method": "void addTagProperty(Sheet.Set sheetSet){\r\n    List<ContentTag> tags = getContentTagsFromDatabase();\r\n    sheetSet.put(new NodeProperty(\"Tags\", AbstractAbstractFileNode_tagsProperty_displayName(), NO_DESCR, tags.stream().map(t -> t.getName().getDisplayName()).distinct().collect(Collectors.joining(\", \"))));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.events.MessageServiceConnectionInfo.getHost",
	"Comment": "gets the host to use for a message service connection. may be a host nameor an ip address.",
	"Method": "String getHost(){\r\n    return host;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.core.UserPreferences.setShowOnlyCurrentUserTags",
	"Comment": "set the user preference which identifies whether tags should be shown foronly the current user or all users.",
	"Method": "void setShowOnlyCurrentUserTags(boolean value){\r\n    preferences.putBoolean(SHOW_ONLY_CURRENT_USER_TAGS, value);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.coreutils.ThreadUtils.shutDownTaskExecutor",
	"Comment": "shuts down a task executor service, unconditionally waiting until alltasks are terminated.",
	"Method": "void shutDownTaskExecutor(ExecutorService executor){\r\n    executor.shutdown();\r\n    boolean tasksCompleted = false;\r\n    while (!tasksCompleted) {\r\n        try {\r\n            tasksCompleted = executor.awaitTermination(DEFAULT_TIMEOUT, DEFAULT_TIMEOUT_UNITS);\r\n        } catch (InterruptedException ignored) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.JerichoParserWrapper.parse",
	"Comment": "initialize the reader by parsing the inputstream, adding it tostringbuilder, and creating a stringreader from it.",
	"Method": "void parse(){\r\n    out = new StringBuilder();\r\n    try {\r\n        Source source = new Source(in);\r\n        source.fullSequentialParse();\r\n        String text;\r\n        StringBuilder scripts = new StringBuilder();\r\n        StringBuilder links = new StringBuilder();\r\n        StringBuilder images = new StringBuilder();\r\n        StringBuilder comments = new StringBuilder();\r\n        StringBuilder others = new StringBuilder();\r\n        int numScripts = 1;\r\n        int numLinks = 1;\r\n        int numImages = 1;\r\n        int numComments = 1;\r\n        int numOthers = 1;\r\n        text = renderHTMLAsPlainText(source);\r\n        List<StartTag> tags = source.getAllStartTags();\r\n        for (StartTag tag : tags) {\r\n            if (tag.getName().equals(\"script\")) {\r\n                scripts.append(numScripts).append(\") \");\r\n                if (tag.getTagContent().length() > 0) {\r\n                    scripts.append(tag.getTagContent()).append(\" \");\r\n                }\r\n                scripts.append(tag.getElement().getContent()).append(\"\\n\");\r\n                numScripts++;\r\n            } else if (tag.getName().equals(\"a\")) {\r\n                links.append(numLinks).append(\") \");\r\n                links.append(tag.getTagContent()).append(\"\\n\");\r\n                numLinks++;\r\n            } else if (tag.getName().equals(\"img\")) {\r\n                images.append(numImages).append(\") \");\r\n                images.append(tag.getTagContent()).append(\"\\n\");\r\n                numImages++;\r\n            } else if (tag.getTagType().equals(StartTagType.COMMENT)) {\r\n                comments.append(numComments).append(\") \");\r\n                comments.append(tag.getTagContent()).append(\"\\n\");\r\n                numComments++;\r\n            } else {\r\n                Attributes atts = tag.getAttributes();\r\n                if (atts != null && atts.length() > 0) {\r\n                    others.append(numOthers).append(\") \");\r\n                    others.append(tag.getName()).append(\":\");\r\n                    others.append(tag.getTagContent()).append(\"\\n\");\r\n                    numOthers++;\r\n                }\r\n            }\r\n        }\r\n        out.append(text).append(\"\\n\\n\");\r\n        out.append(\"----------NONVISIBLE TEXT----------\\n\\n\");\r\n        if (numScripts > 1) {\r\n            out.append(\"---Scripts---\\n\");\r\n            out.append(scripts.toString()).append(\"\\n\");\r\n        }\r\n        if (numLinks > 1) {\r\n            out.append(\"---Links---\\n\");\r\n            out.append(links.toString()).append(\"\\n\");\r\n        }\r\n        if (numImages > 1) {\r\n            out.append(\"---Images---\\n\");\r\n            out.append(images.toString()).append(\"\\n\");\r\n        }\r\n        if (numComments > 1) {\r\n            out.append(\"---Comments---\\n\");\r\n            out.append(comments.toString()).append(\"\\n\");\r\n        }\r\n        if (numOthers > 1) {\r\n            out.append(\"---Others---\\n\");\r\n            out.append(others.toString()).append(\"\\n\");\r\n        }\r\n        reader = new StringReader(out.toString());\r\n    } catch (IOException ex) {\r\n        logger.log(Level.WARNING, \"Unable to parse the HTML file\", ex);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilessearch.IntraCaseTestUtils.verifySingularInstanceExistance",
	"Comment": "convenience method which verifies that a file exists within a given datasource exactly once.",
	"Method": "boolean verifySingularInstanceExistance(List<AbstractFile> files,Map<Long, String> objectIdToDataSource,String name,String dataSource){\r\n    return verifyInstanceExistanceAndCount(files, objectIdToDataSource, name, dataSource, 1);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.AddImageWizardSelectDspVisual.updateSelectedDsp",
	"Comment": "find the dsp which is currently selected and save it as the selecteddatasourceprocessor.",
	"Method": "void updateSelectedDsp(){\r\n    Enumeration<AbstractButton> buttonGroup = buttonGroup1.getElements();\r\n    while (buttonGroup.hasMoreElements()) {\r\n        AbstractButton dspButton = buttonGroup.nextElement();\r\n        if (dspButton.isSelected()) {\r\n            selectedDsp = dspButton.getName();\r\n            break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.mcxiaoke.next.utils.ImageType.setCollectComments",
	"Comment": "specify whether textual comments are supposed to be extracted from input.default is false.if enabled, comments will be added to an internal list.",
	"Method": "void setCollectComments(boolean newValue){\r\n    collectComments = newValue;\r\n}"
}, {
	"Path": "com.aliyun.oss.internal.ResponseParsers.parseGetBucketReplicationLocation",
	"Comment": "unmarshall get bucket replication response body to replication location.",
	"Method": "List<String> parseGetBucketReplicationLocation(InputStream responseBody){\r\n    try {\r\n        Element root = getXmlRootElement(responseBody);\r\n        List<String> locationList = new ArrayList<String>();\r\n        List<Element> locElements = root.getChildren(\"Location\");\r\n        for (Element locElem : locElements) {\r\n            locationList.add(locElem.getText());\r\n        }\r\n        return locationList;\r\n    } catch (JDOMParseException e) {\r\n        throw new ResponseParseException(e.getPartialDocument() + \": \" + e.getMessage(), e);\r\n    } catch (Exception e) {\r\n        throw new ResponseParseException(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestJobSettings.getProcessUnallocatedSpace",
	"Comment": "gets the process unallocated space flag for this ingest job.",
	"Method": "boolean getProcessUnallocatedSpace(){\r\n    boolean processUnallocated = true;\r\n    if (!Objects.isNull(this.fileFilter)) {\r\n        processUnallocated = (this.fileFilter.ingoresUnallocatedSpace() == false);\r\n    }\r\n    return processUnallocated;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.FileExporter.verifyPrerequisites",
	"Comment": "verifies that all afe prerequisite ingest modules were enabled for allinput data sources",
	"Method": "boolean verifyPrerequisites(List<Content> dataSources){\r\n    SleuthkitCase skCase;\r\n    try {\r\n        skCase = Case.getCurrentCaseThrows().getSleuthkitCase();\r\n    } catch (NoCurrentCaseException ex) {\r\n        throw new FileExportException(\"Exception while getting open case.\", ex);\r\n    }\r\n    List<IngestJobInfo> ingestJobs = new ArrayList();\r\n    try {\r\n        ingestJobs = skCase.getIngestJobs();\r\n    } catch (TskCoreException ex) {\r\n        throw new FileExportException(\"Failed to obtain ingest jobs\", ex);\r\n    }\r\n    for (Content dataSource : dataSources) {\r\n        for (String requiredModuleCanonicalName : REQUIRED_MODULE_CANONICAL_NAME) {\r\n            boolean requiredModuleWasEnabled = false;\r\n            for (IngestJobInfo ingestJob : ingestJobs) {\r\n                if (ingestJob.getStatus() != IngestJobInfo.IngestJobStatusType.COMPLETED) {\r\n                    continue;\r\n                }\r\n                if (dataSource.getId() != ingestJob.getObjectId()) {\r\n                    continue;\r\n                }\r\n                if (isRequiredModuleEnabled(requiredModuleCanonicalName, ingestJob)) {\r\n                    requiredModuleWasEnabled = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!requiredModuleWasEnabled) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.ui.detailview.DetailViewPane.newHideDescriptionAction",
	"Comment": "get a new action that will hide events with the given description.",
	"Method": "Action newHideDescriptionAction(String description,DescriptionLoD descriptionLoD){\r\n    return new HideDescriptionAction(description, descriptionLoD, getChart());\r\n}"
}, {
	"Path": "com.facebook.samples.zoomable.AbstractAnimatedZoomableController.setTransform",
	"Comment": "sets a new zoomable transformation and animates to it if desired.if this method is called while an animation or gesture is already in progress,the current animation or gesture will be stopped first.",
	"Method": "void setTransform(Matrix newTransform,long durationMs,Runnable onAnimationComplete){\r\n    FLog.v(getLogTag(), \"setTransform: duration %d ms\", durationMs);\r\n    if (durationMs <= 0) {\r\n        setTransformImmediate(newTransform);\r\n    } else {\r\n        setTransformAnimated(newTransform, durationMs, onAnimationComplete);\r\n    }\r\n}"
}, {
	"Path": "com.mcxiaoke.next.utils.ReflectionUtils.getAllDeclaredMethods",
	"Comment": "get all declared methods on the leaf class and all superclasses. leafclass methods are included first.",
	"Method": "Method[] getAllDeclaredMethods(Class<?> leafClass){\r\n    final List<Method> methods = new ArrayList<Method>(32);\r\n    doWithMethods(leafClass, new MethodCallback() {\r\n        @Override\r\n        public void doWith(Method method) {\r\n            methods.add(method);\r\n        }\r\n    });\r\n    return methods.toArray(new Method[methods.size()]);\r\n}"
}, {
	"Path": "com.mcxiaoke.next.utils.ReflectionUtils.getAllDeclaredMethods",
	"Comment": "get all declared methods on the leaf class and all superclasses. leafclass methods are included first.",
	"Method": "Method[] getAllDeclaredMethods(Class<?> leafClass){\r\n    methods.add(method);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.interestingitems.FilesSetRulePanel.setOkButton",
	"Comment": "sets whether or not the ok button should be enabled based upon other uielements",
	"Method": "void setOkButton(){\r\n    if (this.okButton != null) {\r\n        this.okButton.setEnabled(this.fileSizeCheck.isSelected() || this.mimeCheck.isSelected() || this.nameCheck.isSelected() || this.pathCheck.isSelected() || this.dateCheck.isSelected());\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.HighlightedText.constructEscapedSolrQuery",
	"Comment": "constructs a complete, escaped solr query that is ready to be used.",
	"Method": "String constructEscapedSolrQuery(String query){\r\n    return LuceneQuery.HIGHLIGHT_FIELD + \":\" + \"\\\"\" + KeywordSearchUtil.escapeLuceneQuery(query) + \"\\\"\";\r\n}"
}, {
	"Path": "com.mcxiaoke.next.ui.list.AdapterExtend.getView",
	"Comment": "get a view that displays the data at the specifiedposition in the data set. in this case, if we are atthe end of the list and we are still in append mode, weask for a pending view and return it, plus kick off thebackground task to append more data to the wrappedadapter.",
	"Method": "View getView(int position,View convertView,ViewGroup parent){\r\n    if (position == super.getCount() && isEnableRefreshing()) {\r\n        return (mFooter);\r\n    }\r\n    return (super.getView(position, convertView, parent));\r\n}"
}, {
	"Path": "com.douban.frodo.baseproject.adapter.ArrayAdapterCompat2.insert",
	"Comment": "inserts the specified object at the specified index in the array.",
	"Method": "void insert(T object,int index){\r\n    synchronized (mLock) {\r\n        if (mOriginalValues != null) {\r\n            mOriginalValues.add(index, object);\r\n        } else {\r\n            mObjects.add(index, object);\r\n        }\r\n    }\r\n    if (mNotifyOnChange)\r\n        notifyDataSetChanged();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.ImageGalleryPreferences.isGroupCategorizationWarningDisabled",
	"Comment": "return whether the warning about overwriting categories when acting on anentire group is disabled.",
	"Method": "boolean isGroupCategorizationWarningDisabled(){\r\n    final boolean aBoolean = preferences.getBoolean(GROUP_CATEGORIZATION_WARNING_DISABLED, false);\r\n    return aBoolean;\r\n}"
}, {
	"Path": "com.aliyun.oss.model.UploadPartResult.setETag",
	"Comment": "sets the etag generated by oss.oss would send the md5 value of the parts data received to user in theetag header. to make sure the data transferred is 100% correct, westrongly encouraged user to check the server side md5 with the localcomputed md5 value.",
	"Method": "void setETag(String eTag){\r\n    this.eTag = eTag;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.DataResultTopComponent.getActiveComponentIds",
	"Comment": "get a listing of the preferred identifiers of all the result view topcomponents that have been created.",
	"Method": "List<String> getActiveComponentIds(){\r\n    return new ArrayList(activeComponentIds);\r\n}"
}, {
	"Path": "com.google.android.voiceime.ImeTrigger.isInstalled",
	"Comment": "returns true if an implementation of voice ime is installed.",
	"Method": "boolean isInstalled(InputMethodService inputMethodService){\r\n    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.ICE_CREAM_SANDWICH) {\r\n        return false;\r\n    }\r\n    InputMethodInfo inputMethodInfo = getVoiceImeInputMethodInfo(getInputMethodManager(inputMethodService));\r\n    if (inputMethodInfo == null) {\r\n        return false;\r\n    }\r\n    return inputMethodInfo.getSubtypeCount() > 0;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.RecentCases.actionPerformed",
	"Comment": "this action is used to clear all the recent cases menu options.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    UpdateRecentCases.setHasRecentCase(false);\r\n    recentCases.clear();\r\n    try {\r\n        storeRecentCases();\r\n    } catch (IOException ex) {\r\n        Logger.getLogger(RecentCases.class.getName()).log(Level.WARNING, \"Error: Could not clear the properties file.\", ex);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.interestingitems.InterestingItemsFilesSetSettings.readRule",
	"Comment": "construct a fileset membership rule from the data in an xml element foruse in a filesset.",
	"Method": "FilesSet.Rule readRule(Element elem){\r\n    String ruleName = readRuleName(elem);\r\n    FileNameCondition nameCondition = readNameCondition(elem);\r\n    MetaTypeCondition metaCondition = readMetaTypeCondition(elem);\r\n    ParentPathCondition pathCondition = readPathCondition(elem);\r\n    MimeTypeCondition mimeCondition = readMimeCondition(elem);\r\n    FileSizeCondition sizeCondition = readSizeCondition(elem);\r\n    DateCondition dateCondition = readDateCondition(elem);\r\n    if (metaCondition == null || (nameCondition == null && pathCondition == null && mimeCondition == null && sizeCondition == null && dateCondition == null)) {\r\n        logger.log(Level.WARNING, \"Error Reading Rule, \" + ruleName + \" was either missing a meta condition or contained only a meta condition. No rule was imported.\");\r\n        throw new FilesSetsManager.FilesSetsManagerException(String.format(\"Invalid Rule in FilesSet xml, missing necessary conditions for %s\", ruleName));\r\n    }\r\n    return new FilesSet.Rule(ruleName, nameCondition, metaCondition, pathCondition, mimeCondition, sizeCondition, dateCondition);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestOptionsPanel.saveTabByIndex",
	"Comment": "save the panel which is in the tab corresponding to the specified index.",
	"Method": "void saveTabByIndex(int index){\r\n    switch(index) {\r\n        case (INDEX_OF_FILTER_PANEL):\r\n            filterPanel.saveSettings();\r\n            break;\r\n        case (INDEX_OF_PROFILE_PANEL):\r\n            profilePanel.saveSettings();\r\n            break;\r\n        case (INDEX_OF_SETTINGS_PANEL):\r\n            settingsPanel.saveSettings();\r\n            break;\r\n        default:\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.Chunker.readToWhiteSpaceHelper",
	"Comment": "read until the maxbytes reached, whitespace, or end of reader.",
	"Method": "void readToWhiteSpaceHelper(int maxBytes,StringBuilder currentChunk){\r\n    int charsRead = 0;\r\n    boolean whitespaceFound = false;\r\n    while ((chunkSizeBytes < maxBytes) && (whitespaceFound == false) && (endOfReaderReached == false)) {\r\n        charsRead = reader.read(tempChunkBuf, 0, 1);\r\n        if (-1 == charsRead) {\r\n            endOfReaderReached = true;\r\n            return;\r\n        } else {\r\n            final char ch = tempChunkBuf[0];\r\n            String chunkSegment;\r\n            if (Character.isHighSurrogate(ch)) {\r\n                charsRead = reader.read(tempChunkBuf, 1, 1);\r\n                if (charsRead == -1) {\r\n                    endOfReaderReached = true;\r\n                    return;\r\n                } else {\r\n                    chunkSegment = new String(tempChunkBuf, 0, 2);\r\n                }\r\n            } else {\r\n                chunkSegment = new String(tempChunkBuf, 0, 1);\r\n            }\r\n            StringBuilder sanitizedChunkSegment = sanitize(chunkSegment);\r\n            whitespaceFound = Character.isWhitespace(sanitizedChunkSegment.codePointAt(0));\r\n            currentChunk.append(sanitizedChunkSegment);\r\n            chunkSizeBytes += sanitizedChunkSegment.toString().getBytes(UTF_8).length;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.datamodel.FileNode.getItemType",
	"Comment": "gets the item type string of the node, suitable for use as a key.",
	"Method": "String getItemType(){\r\n    return getClass().getName();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJob.getCompletedDate",
	"Comment": "gets the date the job was completed, with or without cancellation orerrors.",
	"Method": "Date getCompletedDate(){\r\n    return new Date(completedDate.getTime());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.filesearch.FileSearchPanel.customizeComponents",
	"Comment": "this method is called from within the constructor to initialize the form.",
	"Method": "void customizeComponents(){\r\n    JLabel label = new JLabel(NbBundle.getMessage(this.getClass(), \"FileSearchPanel.custComp.label.text\"));\r\n    label.setAlignmentX(Component.LEFT_ALIGNMENT);\r\n    label.setBorder(new EmptyBorder(0, 0, 10, 0));\r\n    JPanel panel1 = new JPanel();\r\n    panel1.setLayout(new GridLayout(1, 2));\r\n    panel1.add(new JLabel(\"\"));\r\n    JPanel panel2 = new JPanel();\r\n    panel2.setLayout(new GridLayout(1, 2, 20, 0));\r\n    JPanel panel3 = new JPanel();\r\n    panel3.setLayout(new GridLayout(1, 2, 20, 0));\r\n    JPanel panel4 = new JPanel();\r\n    panel4.setLayout(new GridLayout(1, 2, 20, 0));\r\n    JPanel panel5 = new JPanel();\r\n    panel5.setLayout(new GridLayout(1, 2, 20, 0));\r\n    NameSearchFilter nameFilter = new NameSearchFilter();\r\n    SizeSearchFilter sizeFilter = new SizeSearchFilter();\r\n    DateSearchFilter dateFilter = new DateSearchFilter();\r\n    KnownStatusSearchFilter knowStatusFilter = new KnownStatusSearchFilter();\r\n    HashSearchFilter hashFilter = new HashSearchFilter();\r\n    MimeTypeFilter mimeTypeFilter = new MimeTypeFilter();\r\n    DataSourceFilter dataSourceFilter = new DataSourceFilter();\r\n    panel2.add(new FilterArea(NbBundle.getMessage(this.getClass(), \"FileSearchPanel.filterTitle.name\"), nameFilter));\r\n    panel3.add(new FilterArea(NbBundle.getMessage(this.getClass(), \"FileSearchPanel.filterTitle.metadata\"), sizeFilter));\r\n    panel2.add(new FilterArea(NbBundle.getMessage(this.getClass(), \"FileSearchPanel.filterTitle.metadata\"), dateFilter));\r\n    panel3.add(new FilterArea(NbBundle.getMessage(this.getClass(), \"FileSearchPanel.filterTitle.knownStatus\"), knowStatusFilter));\r\n    panel5.add(new FilterArea(NbBundle.getMessage(this.getClass(), \"HashSearchPanel.md5CheckBox.text\"), hashFilter));\r\n    panel5.add(new JLabel(\"\"));\r\n    panel4.add(new FilterArea(NbBundle.getMessage(this.getClass(), \"FileSearchPanel.filterTitle.metadata\"), mimeTypeFilter));\r\n    panel4.add(new FilterArea(NbBundle.getMessage(this.getClass(), \"DataSourcePanel.dataSourceCheckBox.text\"), dataSourceFilter));\r\n    filterPanel.add(panel1);\r\n    filterPanel.add(panel2);\r\n    filterPanel.add(panel3);\r\n    filterPanel.add(panel4);\r\n    filterPanel.add(panel5);\r\n    filters.add(nameFilter);\r\n    filters.add(sizeFilter);\r\n    filters.add(dateFilter);\r\n    filters.add(knowStatusFilter);\r\n    filters.add(hashFilter);\r\n    filters.add(mimeTypeFilter);\r\n    filters.add(dataSourceFilter);\r\n    for (FileSearchFilter filter : this.getFilters()) {\r\n        filter.addPropertyChangeListener(new PropertyChangeListener() {\r\n            @Override\r\n            public void propertyChange(PropertyChangeEvent evt) {\r\n                searchButton.setEnabled(isValidSearch());\r\n            }\r\n        });\r\n    }\r\n    addListenerToAll(new ActionListener() {\r\n        @Override\r\n        public void actionPerformed(ActionEvent e) {\r\n            search();\r\n        }\r\n    });\r\n    searchButton.setEnabled(isValidSearch());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.filesearch.FileSearchPanel.customizeComponents",
	"Comment": "this method is called from within the constructor to initialize the form.",
	"Method": "void customizeComponents(){\r\n    searchButton.setEnabled(isValidSearch());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.filesearch.FileSearchPanel.customizeComponents",
	"Comment": "this method is called from within the constructor to initialize the form.",
	"Method": "void customizeComponents(){\r\n    search();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.datamodel.DisplayableItemNode.setChildNodeSelectionInfo",
	"Comment": "adds information about which child node of this node, if any, should beselected. can be null.",
	"Method": "void setChildNodeSelectionInfo(NodeSelectionInfo selectedChildNodeInfo){\r\n    this.selectedChildNodeInfo = selectedChildNodeInfo;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.IntraCasePanel.getDataSourceMap",
	"Comment": "get the map of datasources which was used to populate the combo box onthis panel.",
	"Method": "Map<Long, String> getDataSourceMap(){\r\n    return Collections.unmodifiableMap(this.dataSourceMap);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestJobContext.dataSourceIngestIsCancelled",
	"Comment": "allows a data source ingest module to determine whether or notcancellation of the data source ingest part of the ingest job associatedwith this context has been requested.",
	"Method": "boolean dataSourceIngestIsCancelled(){\r\n    return this.ingestJob.currentDataSourceIngestModuleIsCancelled() || this.ingestJob.isCancelled();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.DataContentViewerArtifact.startNewTask",
	"Comment": "start a new task on its own background thread, canceling the previoustask.",
	"Method": "void startNewTask(SwingWorker<ViewUpdate, Void> task){\r\n    String[][] waitRow = new String[1][3];\r\n    waitRow[0] = new String[] { \"\", WAIT_TEXT, \"\" };\r\n    DefaultTableModel tModel = ((DefaultTableModel) resultsTable.getModel());\r\n    tModel.setDataVector(waitRow, COLUMN_HEADERS);\r\n    updateColumnSizes();\r\n    updateRowHeights();\r\n    resultsTable.clearSelection();\r\n    if (currentTask != null) {\r\n        currentTask.cancel(false);\r\n    }\r\n    currentTask = task;\r\n    currentTask.execute();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.filetypeid.FileType.matches",
	"Comment": "determines whether or not a file is an instance of this file type.",
	"Method": "boolean matches(AbstractFile file){\r\n    for (Signature sig : this.signatures) {\r\n        if (!sig.containedIn(file)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.LocalDiskDSProcessor.getPanel",
	"Comment": "gets the panel that allows a user to select a data source and do anyconfiguration required by the data source. the panel is less than 544pixels wide and less than 173 pixels high.",
	"Method": "JPanel getPanel(){\r\n    configPanel.resetLocalDiskSelection();\r\n    return configPanel;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.testutils.IngestUtils.getIngestModuleTemplate",
	"Comment": "get the ingest module template for the the specified factories defaultingest job settings.",
	"Method": "IngestModuleTemplate getIngestModuleTemplate(IngestModuleFactory factory){\r\n    IngestModuleIngestJobSettings settings = factory.getDefaultIngestJobSettings();\r\n    IngestModuleTemplate template = new IngestModuleTemplate(factory, settings);\r\n    template.setEnabled(true);\r\n    return template;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.AbstractSqlEamDb.getArtifactInstancesByPath",
	"Comment": "retrieves eamartifact instances from the database that are associatedwith the atype and filepath",
	"Method": "List<CorrelationAttributeInstance> getArtifactInstancesByPath(CorrelationAttributeInstance.Type aType,String filePath){\r\n    if (aType == null) {\r\n        throw new EamDbException(\"Correlation type is null\");\r\n    }\r\n    if (filePath == null) {\r\n        throw new EamDbException(\"Correlation value is null\");\r\n    }\r\n    Connection conn = connect();\r\n    List<CorrelationAttributeInstance> artifactInstances = new ArrayList();\r\n    CorrelationAttributeInstance artifactInstance;\r\n    PreparedStatement preparedStatement = null;\r\n    ResultSet resultSet = null;\r\n    String tableName = EamDbUtil.correlationTypeToInstanceTableName(aType);\r\n    String sql = \"SELECT \" + tableName + \".id, \" + tableName + \".value,\" + tableName + \".file_obj_id,\" + \" cases.case_name, cases.case_uid, data_sources.id AS data_source_id, data_sources.name, device_id, file_path, known_status, comment, data_sources.case_id, data_sources.datasource_obj_id FROM \" + tableName + \" LEFT JOIN cases ON \" + tableName + \".case_id=cases.id\" + \" LEFT JOIN data_sources ON \" + tableName + \".data_source_id=data_sources.id\" + \" WHERE file_path=?\";\r\n    try {\r\n        preparedStatement = conn.prepareStatement(sql);\r\n        preparedStatement.setString(1, filePath.toLowerCase());\r\n        resultSet = preparedStatement.executeQuery();\r\n        while (resultSet.next()) {\r\n            try {\r\n                artifactInstance = getEamArtifactInstanceFromResultSet(resultSet, aType);\r\n                artifactInstances.add(artifactInstance);\r\n            } catch (CorrelationAttributeNormalizationException ex) {\r\n                logger.log(Level.INFO, \"Unable to get artifact instance from resultset.\", ex);\r\n            }\r\n        }\r\n    } catch (SQLException ex) {\r\n        throw new EamDbException(\"Error getting artifact instances by artifactType and artifactValue.\", ex);\r\n    } finally {\r\n        EamDbUtil.closeStatement(preparedStatement);\r\n        EamDbUtil.closeResultSet(resultSet);\r\n        EamDbUtil.closeConnection(conn);\r\n    }\r\n    return artifactInstances;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.MultiUserSettingsPanel.messageServiceFieldsArePopulated",
	"Comment": "tests whether or not values have been entered in all of the requiredmessage service settings text fields.",
	"Method": "boolean messageServiceFieldsArePopulated(){\r\n    if ((tbMsgHostname.getText().trim().isEmpty()) || (tbMsgPort.getText().trim().isEmpty())) {\r\n        return false;\r\n    }\r\n    boolean isUserSet = (tbMsgUsername.getText().trim().isEmpty() == false);\r\n    boolean isPwSet = (tbMsgPassword.getPassword().length != 0);\r\n    return (isUserSet == isPwSet);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.interestingitems.FilesIdentifierIngestJobSettings.getNamesOfEnabledInterestingFilesSets",
	"Comment": "get the names of all explicitly enabled interesting files setdefinitions.",
	"Method": "List<String> getNamesOfEnabledInterestingFilesSets(){\r\n    return new ArrayList(this.enabledFilesSetNames);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.contentviewer.DataContentViewerOtherCases.getCorrelationAttributesFromNode",
	"Comment": "determine what attributes can be used for correlation based on the node.if eamdb is not enabled, get the default files correlation.",
	"Method": "Collection<CorrelationAttributeInstance> getCorrelationAttributesFromNode(Node node){\r\n    Collection<CorrelationAttributeInstance> ret = new ArrayList();\r\n    BlackboardArtifact bbArtifact = getBlackboardArtifactFromNode(node);\r\n    if (bbArtifact != null && EamDb.isEnabled()) {\r\n        ret.addAll(EamArtifactUtil.makeInstancesFromBlackboardArtifact(bbArtifact, false));\r\n    }\r\n    if (this.file != null && EamDb.isEnabled() && this.file.getSize() > 0) {\r\n        try {\r\n            List<CorrelationAttributeInstance.Type> artifactTypes = EamDb.getInstance().getDefinedCorrelationTypes();\r\n            String md5 = this.file.getMd5Hash();\r\n            if (md5 != null && !md5.isEmpty() && null != artifactTypes && !artifactTypes.isEmpty()) {\r\n                for (CorrelationAttributeInstance.Type aType : artifactTypes) {\r\n                    if (aType.getId() == CorrelationAttributeInstance.FILES_TYPE_ID) {\r\n                        CorrelationCase corCase = EamDb.getInstance().getCase(Case.getCurrentCase());\r\n                        try {\r\n                            ret.add(new CorrelationAttributeInstance(aType, md5, corCase, CorrelationDataSource.fromTSKDataSource(corCase, file.getDataSource()), file.getParentPath() + file.getName(), \"\", file.getKnown(), file.getId()));\r\n                        } catch (CorrelationAttributeNormalizationException ex) {\r\n                            LOGGER.log(Level.INFO, String.format(\"Unable to check create CorrelationAttribtueInstance for value %s and type %s.\", md5, aType.toString()), ex);\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        } catch (EamDbException | TskCoreException ex) {\r\n            LOGGER.log(Level.SEVERE, \"Error connecting to DB\", ex);\r\n        }\r\n    } else if (this.file != null && this.file.getSize() > 0) {\r\n        String md5 = this.file.getMd5Hash();\r\n        if (md5 != null && !md5.isEmpty()) {\r\n            try {\r\n                final CorrelationAttributeInstance.Type fileAttributeType = CorrelationAttributeInstance.getDefaultCorrelationTypes().stream().filter(attrType -> attrType.getId() == CorrelationAttributeInstance.FILES_TYPE_ID).findAny().get();\r\n                ret.add(new CorrelationAttributeInstance(fileAttributeType, md5, null, null, \"\", \"\", TskData.FileKnown.UNKNOWN, this.file.getId()));\r\n            } catch (EamDbException ex) {\r\n                LOGGER.log(Level.SEVERE, \"Error connecting to DB\", ex);\r\n            } catch (CorrelationAttributeNormalizationException ex) {\r\n                LOGGER.log(Level.INFO, String.format(\"Unable to create CorrelationAttributeInstance for value %s\", md5), ex);\r\n            }\r\n        }\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.UserInputErrorManager.getErrors",
	"Comment": "get a list of distinct string messages describing the various error states.",
	"Method": "List<String> getErrors(){\r\n    return this.currentErrors.values().stream().filter(errorMessage -> errorMessage.isErrorSet() == true).map(ErrorMessage::getMessage).collect(Collectors.toList());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.hashdatabase.ImportCentralRepoDbProgressDialog.propertyChange",
	"Comment": "updates the dialog from events from the worker. the two events we handleare progress updates and the done event.",
	"Method": "void propertyChange(PropertyChangeEvent evt){\r\n    if (\"progress\".equals(evt.getPropertyName())) {\r\n        progressBar.setValue(worker.getProgress());\r\n        lbProgress.setText(getProgressString());\r\n    } else if (\"state\".equals(evt.getPropertyName()) && (SwingWorker.StateValue.DONE.equals(evt.getNewValue()))) {\r\n        bnCancel.setEnabled(false);\r\n        bnOk.setEnabled(true);\r\n        if (worker.getImportSuccess()) {\r\n            progressBar.setValue(progressBar.getMaximum());\r\n            lbProgress.setText(getProgressString());\r\n        } else {\r\n            progressBar.setValue(0);\r\n            lbProgress.setForeground(Color.red);\r\n            lbProgress.setText(Bundle.ImportCentralRepoDbProgressDialog_errorParsingFile_message());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestSettingsPanel.enableButtons",
	"Comment": "enable or disable buttons based on whether ingest is running.",
	"Method": "void enableButtons(boolean isEnabled){\r\n    numberOfFileIngestThreadsComboBox.setEnabled(isEnabled);\r\n    jFormattedTextFieldProcTimeOutHrs.setEnabled(isEnabled);\r\n    jCheckBoxEnableProcTimeout.setEnabled(isEnabled);\r\n    ingestWarningLabel.setVisible(!isEnabled);\r\n}"
}, {
	"Path": "model.Complex.sin",
	"Comment": "return a new complex object whose value is the complex sine of this",
	"Method": "Complex sin(){\r\n    return new Complex(Math.sin(re) * Math.cosh(im), Math.cos(re) * Math.sinh(im));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.hashdatabase.HashDatabaseOptionsPanelController.applyChanges",
	"Comment": "this method is called when both the ok and apply buttons are pressed. itapplies to any of the panels that have been opened in the process ofusing the options pane.",
	"Method": "void applyChanges(){\r\n    if (changed) {\r\n        getPanel().store();\r\n        changed = false;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.imagegallery.ImageGalleryTopComponent.openTopComponent",
	"Comment": "creates the image gallery top component if it does not already exist andopens its window.",
	"Method": "void openTopComponent(){\r\n    final ImageGalleryTopComponent topComponent = getTopComponent();\r\n    if (topComponent.isOpened()) {\r\n        showTopComponent();\r\n    } else {\r\n        topComponent.getCurrentControllerAndOpen();\r\n    }\r\n}"
}, {
	"Path": "com.mcxiaoke.next.utils.ReflectionUtils.getUniqueDeclaredMethods",
	"Comment": "get the unique set of declared methods on the leaf class and all superclasses. leafclass methods are included first and while traversing the superclass hierarchy any methods foundwith signatures matching a method already included are filtered out.",
	"Method": "Method[] getUniqueDeclaredMethods(Class<?> leafClass){\r\n    final List<Method> methods = new ArrayList<Method>(32);\r\n    doWithMethods(leafClass, new MethodCallback() {\r\n        @Override\r\n        public void doWith(Method method) {\r\n            boolean knownSignature = false;\r\n            Method methodBeingOverriddenWithCovariantReturnType = null;\r\n            for (Method existingMethod : methods) {\r\n                if (method.getName().equals(existingMethod.getName()) && Arrays.equals(method.getParameterTypes(), existingMethod.getParameterTypes())) {\r\n                    if (existingMethod.getReturnType() != method.getReturnType() && existingMethod.getReturnType().isAssignableFrom(method.getReturnType())) {\r\n                        methodBeingOverriddenWithCovariantReturnType = existingMethod;\r\n                    } else {\r\n                        knownSignature = true;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n            if (methodBeingOverriddenWithCovariantReturnType != null) {\r\n                methods.remove(methodBeingOverriddenWithCovariantReturnType);\r\n            }\r\n            if (!knownSignature) {\r\n                methods.add(method);\r\n            }\r\n        }\r\n    });\r\n    return methods.toArray(new Method[methods.size()]);\r\n}"
}, {
	"Path": "com.mcxiaoke.next.utils.ReflectionUtils.getUniqueDeclaredMethods",
	"Comment": "get the unique set of declared methods on the leaf class and all superclasses. leafclass methods are included first and while traversing the superclass hierarchy any methods foundwith signatures matching a method already included are filtered out.",
	"Method": "Method[] getUniqueDeclaredMethods(Class<?> leafClass){\r\n    boolean knownSignature = false;\r\n    Method methodBeingOverriddenWithCovariantReturnType = null;\r\n    for (Method existingMethod : methods) {\r\n        if (method.getName().equals(existingMethod.getName()) && Arrays.equals(method.getParameterTypes(), existingMethod.getParameterTypes())) {\r\n            if (existingMethod.getReturnType() != method.getReturnType() && existingMethod.getReturnType().isAssignableFrom(method.getReturnType())) {\r\n                methodBeingOverriddenWithCovariantReturnType = existingMethod;\r\n            } else {\r\n                knownSignature = true;\r\n            }\r\n            break;\r\n        }\r\n    }\r\n    if (methodBeingOverriddenWithCovariantReturnType != null) {\r\n        methods.remove(methodBeingOverriddenWithCovariantReturnType);\r\n    }\r\n    if (!knownSignature) {\r\n        methods.add(method);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.NewCaseWizardPanel1.fireChangeEvent",
	"Comment": "notifies any registerd change listeners of a change in the panel.",
	"Method": "void fireChangeEvent(){\r\n    Iterator<ChangeListener> it;\r\n    synchronized (listeners) {\r\n        it = new HashSet(listeners).iterator();\r\n    }\r\n    ChangeEvent ev = new ChangeEvent(this);\r\n    while (it.hasNext()) {\r\n        it.next().stateChanged(ev);\r\n    }\r\n}"
}, {
	"Path": "com.anysoftkeyboard.keyboards.views.CandidateView.setService",
	"Comment": "a connection back to the service to communicate with the text field",
	"Method": "void setService(AnySoftKeyboard listener){\r\n    mService = listener;\r\n}"
}, {
	"Path": "com.facebook.samples.zoomable.DefaultZoomableController.getMatrixScaleFactor",
	"Comment": "gets the scale factor for the given matrix.this method assumes the equal scaling factor for x and y axis.",
	"Method": "float getMatrixScaleFactor(Matrix transform){\r\n    transform.getValues(mTempValues);\r\n    return mTempValues[Matrix.MSCALE_X];\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.DataResultPanel.setupTabs",
	"Comment": "sets the state of the child result viewers, based on a selected rootnode.",
	"Method": "void setupTabs(Node selectedNode){\r\n    for (int i = 0; i < resultViewerTabs.getTabCount(); i++) {\r\n        if (resultViewers.get(i).isSupported(selectedNode)) {\r\n            resultViewerTabs.setEnabledAt(i, true);\r\n        } else {\r\n            resultViewerTabs.setEnabledAt(i, false);\r\n        }\r\n    }\r\n    int tabToSelect = NO_TAB_SELECTED;\r\n    if (selectedNode instanceof TableFilterNode) {\r\n        NodeSelectionInfo selectedChildInfo = ((TableFilterNode) selectedNode).getChildNodeSelectionInfo();\r\n        if (null != selectedChildInfo) {\r\n            for (int i = 0; i < resultViewers.size(); ++i) {\r\n                if (resultViewers.get(i) instanceof DataResultViewerTable && resultViewerTabs.isEnabledAt(i)) {\r\n                    tabToSelect = i;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (tabToSelect == NO_TAB_SELECTED) {\r\n        tabToSelect = resultViewerTabs.getSelectedIndex();\r\n        if ((tabToSelect == NO_TAB_SELECTED) || (!resultViewerTabs.isEnabledAt(tabToSelect))) {\r\n            for (int i = 0; i < resultViewerTabs.getTabCount(); ++i) {\r\n                if (resultViewerTabs.isEnabledAt(i)) {\r\n                    tabToSelect = i;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (tabToSelect != NO_TAB_SELECTED) {\r\n        resultViewerTabs.setSelectedIndex(tabToSelect);\r\n        resultViewers.get(tabToSelect).setNode(selectedNode);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.AutopsyOptionsPanel.getInstallFolderConfFile",
	"Comment": "get the conf file from the install directory which stores the defaultvalues for the settings.",
	"Method": "File getInstallFolderConfFile(){\r\n    String confFileName = UserPreferences.getAppName() + CONFIG_FILE_EXTENSION;\r\n    String installFolder = PlatformUtil.getInstallPath();\r\n    File installFolderEtc = new File(installFolder, ETC_FOLDER_NAME);\r\n    File installFolderConfigFile = new File(installFolderEtc, confFileName);\r\n    if (!installFolderConfigFile.exists()) {\r\n        throw new IOException(\"Conf file could not be found\" + installFolderConfigFile.toString());\r\n    }\r\n    return installFolderConfigFile;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.CorrelationAttributeInstance.getFileObjectId",
	"Comment": "get the objectid of the file associated with the correlation attribute ornull if the objectid is not available.",
	"Method": "Long getFileObjectId(){\r\n    return objectId;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.directorytree.ExternalViewerRule.equals",
	"Comment": "only one association is allowed per mime type or extension, so rules areequal if the names are the same.",
	"Method": "boolean equals(Object other){\r\n    if (other != null && other instanceof ExternalViewerRule) {\r\n        ExternalViewerRule that = (ExternalViewerRule) other;\r\n        if (this.getName().equals(that.getName())) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.events.AddingDataSourceFailedEvent.getAddingDataSourceEventId",
	"Comment": "gets the unique id used to pair this addingdatasourcefailedevent with thecorresponding addingdatasourceevent.",
	"Method": "UUID getAddingDataSourceEventId(){\r\n    return dataSourceId;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.hashdatabase.HashDbManager.getAllHashSets",
	"Comment": "gets all of the hash databases used to classify files as known or knownbad. will add any new central repository databases to the list beforereturning it.",
	"Method": "List<HashDb> getAllHashSets(){\r\n    try {\r\n        updateHashSetsFromCentralRepository();\r\n    } catch (TskCoreException ex) {\r\n        Logger.getLogger(HashDbManager.class.getName()).log(Level.SEVERE, \"Error loading central repository hash sets\", ex);\r\n    }\r\n    List<HashDb> hashDbs = new ArrayList();\r\n    hashDbs.addAll(this.hashSets);\r\n    return hashDbs;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.configuration.SharedConfiguration.calculateCRC",
	"Comment": "calculate the crc of a file to use to determine if it has changed.",
	"Method": "String calculateCRC(String filePath){\r\n    File file = new File(filePath);\r\n    try {\r\n        FileInputStream fileStream = new FileInputStream(file);\r\n        CRC32 crc = new CRC32();\r\n        byte[] buffer = new byte[65536];\r\n        int bytesRead = fileStream.read(buffer);\r\n        while (-1 != bytesRead) {\r\n            crc.update(buffer, 0, bytesRead);\r\n            bytesRead = fileStream.read(buffer);\r\n        }\r\n        return String.valueOf(crc.getValue());\r\n    } catch (IOException ex) {\r\n        throw new SharedConfigurationException(String.format(\"Failed to calculate CRC for %s\", file.getAbsolutePath()), ex);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.configuration.SharedConfiguration.downloadEnabledModuleSettings",
	"Comment": "download settings file containing enabled ingest modules.",
	"Method": "void downloadEnabledModuleSettings(File remoteFolder){\r\n    publishTask(\"Downloading enabled module configuration\");\r\n    copyToLocalFolder(AUTO_MODE_CONTEXT_FILE, moduleDirPath, remoteFolder, false);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.db.EventDB.getEventIDs",
	"Comment": "get the ids of all the events within the given time range that pass thegiven filter.",
	"Method": "List<Long> getEventIDs(Interval timeRange,RootFilter filter){\r\n    Long startTime = timeRange.getStartMillis() / 1000;\r\n    Long endTime = timeRange.getEndMillis() / 1000;\r\n    if (Objects.equals(startTime, endTime)) {\r\n        endTime++;\r\n    }\r\n    ArrayList<Long> resultIDs = new ArrayList();\r\n    DBLock.lock();\r\n    final String query = \"SELECT events.event_id AS event_id FROM events\" + useHashHitTablesHelper(filter) + useTagTablesHelper(filter) + \" WHERE time >=  \" + startTime + \" AND time <\" + endTime + \" AND \" + SQLHelper.getSQLWhere(filter) + \" ORDER BY time ASC\";\r\n    try (Statement stmt = con.createStatement();\r\n        ResultSet rs = stmt.executeQuery(query)) {\r\n        while (rs.next()) {\r\n            resultIDs.add(rs.getLong(\"event_id\"));\r\n        }\r\n    } catch (SQLException sqlEx) {\r\n        LOGGER.log(Level.SEVERE, \"failed to execute query for event ids in range\", sqlEx);\r\n    } finally {\r\n        DBLock.unlock();\r\n    }\r\n    return resultIDs;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.RunIngestSubMenu.synchMenuPresenters",
	"Comment": "updates main menu presenters. this method is called only by the main menuprocessing.",
	"Method": "JComponent[] synchMenuPresenters(JComponent[] jcs){\r\n    return getMenuPresenters();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.embeddedfileextractor.SevenZipExtractor.getAlreadyExtractedFiles",
	"Comment": "query the database and get the list of files which exist for this archivewhich have already been added to the case database.",
	"Method": "List<AbstractFile> getAlreadyExtractedFiles(AbstractFile archiveFile,String archiveFilePath){\r\n    if (archiveFile.hasChildren() && new File(moduleDirAbsolute, EmbeddedFileExtractorIngestModule.getUniqueName(archiveFile)).exists()) {\r\n        return Case.getCurrentCaseThrows().getServices().getFileManager().findFilesByParentPath(getRootArchiveId(archiveFile), archiveFilePath);\r\n    }\r\n    return new ArrayList();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.KeywordList.getIngestMessages",
	"Comment": "gets whether or not to post ingest inbox messages when a keyword withinthe list is found while ingesting a data source.",
	"Method": "Boolean getIngestMessages(){\r\n    return postIngestMessages;\r\n}"
}, {
	"Path": "com.litesuits.http.parser.DataParser.translateBytes",
	"Comment": "translate original bytes to custom bytes.if your data is encrypted, you can override this method to decrypt it.",
	"Method": "byte[] translateBytes(byte[] bytes){\r\n    return bytes;\r\n}"
}, {
	"Path": "org.wikipedia.WikipediaApp.setCurrentTheme",
	"Comment": "sets the theme of the app. if the new theme is the same as the current theme, nothing happens.otherwise, an event is sent to notify of the theme change.",
	"Method": "void setCurrentTheme(Theme theme){\r\n    if (theme != currentTheme) {\r\n        currentTheme = theme;\r\n        Prefs.setThemeId(currentTheme.getMarshallingId());\r\n        bus.post(new ThemeChangeEvent());\r\n    }\r\n}"
}, {
	"Path": "com.mcxiaoke.next.utils.ViewUtils.showSystemUI",
	"Comment": "except for the ones that make the content appear under the system bars.",
	"Method": "void showSystemUI(Activity activity){\r\n    View decorView = activity.getWindow().getDecorView();\r\n    decorView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.configuration.AutoIngestUserPreferences.getAutoModeImageFolder",
	"Comment": "get input folder for automated mode from persistent storage.",
	"Method": "String getAutoModeImageFolder(){\r\n    return getPreferenceValue(AUTO_MODE_IMAGES_FOLDER);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.datamodel.CombinedEvent.getRepresentativeEventID",
	"Comment": "get the event id of one event that is representative of all the combinedevents. it can be used to look up a singleevent with more details, forexample.",
	"Method": "Long getRepresentativeEventID(){\r\n    return eventTypeMap.values().stream().findFirst().get();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.ModuleDataEvent.getArtifactType",
	"Comment": "get artifact type of the new artifacts associated with the event",
	"Method": "ARTIFACT_TYPE getArtifactType(){\r\n    return BlackboardArtifact.ARTIFACT_TYPE.fromID(this.blackboardArtifactType.getTypeID());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestControlPanel.setServicesStatusMessage",
	"Comment": "queries the services monitor and sets the text for the services statustext box.",
	"Method": "void setServicesStatusMessage(){\r\n    new SwingWorker<Void, Void>() {\r\n        @Override\r\n        protected Void doInBackground() throws Exception {\r\n            statusByService.put(ServicesMonitor.Service.REMOTE_CASE_DATABASE.toString(), getServiceStatus(ServicesMonitor.Service.REMOTE_CASE_DATABASE));\r\n            statusByService.put(ServicesMonitor.Service.REMOTE_KEYWORD_SEARCH.toString(), getServiceStatus(ServicesMonitor.Service.REMOTE_KEYWORD_SEARCH));\r\n            statusByService.put(ServicesMonitor.Service.MESSAGING.toString(), getServiceStatus(ServicesMonitor.Service.MESSAGING));\r\n            return null;\r\n        }\r\n        private String getServiceStatus(ServicesMonitor.Service service) {\r\n            String serviceStatus = NbBundle.getMessage(AutoIngestControlPanel.class, \"AutoIngestControlPanel.tbServicesStatusMessage.Message.Unknown\");\r\n            try {\r\n                ServicesMonitor servicesMonitor = ServicesMonitor.getInstance();\r\n                serviceStatus = servicesMonitor.getServiceStatus(service.toString());\r\n                if (serviceStatus.compareTo(ServicesMonitor.ServiceStatus.UP.toString()) == 0) {\r\n                    serviceStatus = NbBundle.getMessage(AutoIngestControlPanel.class, \"AutoIngestControlPanel.tbServicesStatusMessage.Message.Up\");\r\n                } else {\r\n                    serviceStatus = NbBundle.getMessage(AutoIngestControlPanel.class, \"AutoIngestControlPanel.tbServicesStatusMessage.Message.Down\");\r\n                }\r\n            } catch (ServicesMonitor.ServicesMonitorException ex) {\r\n                sysLogger.log(Level.SEVERE, String.format(\"Dashboard error getting service status for %s\", service), ex);\r\n            }\r\n            return serviceStatus;\r\n        }\r\n        @Override\r\n        protected void done() {\r\n            displayServicesStatus();\r\n        }\r\n    }.execute();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestControlPanel.setServicesStatusMessage",
	"Comment": "queries the services monitor and sets the text for the services statustext box.",
	"Method": "void setServicesStatusMessage(){\r\n    statusByService.put(ServicesMonitor.Service.REMOTE_CASE_DATABASE.toString(), getServiceStatus(ServicesMonitor.Service.REMOTE_CASE_DATABASE));\r\n    statusByService.put(ServicesMonitor.Service.REMOTE_KEYWORD_SEARCH.toString(), getServiceStatus(ServicesMonitor.Service.REMOTE_KEYWORD_SEARCH));\r\n    statusByService.put(ServicesMonitor.Service.MESSAGING.toString(), getServiceStatus(ServicesMonitor.Service.MESSAGING));\r\n    return null;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestControlPanel.setServicesStatusMessage",
	"Comment": "queries the services monitor and sets the text for the services statustext box.",
	"Method": "void setServicesStatusMessage(){\r\n    String serviceStatus = NbBundle.getMessage(AutoIngestControlPanel.class, \"AutoIngestControlPanel.tbServicesStatusMessage.Message.Unknown\");\r\n    try {\r\n        ServicesMonitor servicesMonitor = ServicesMonitor.getInstance();\r\n        serviceStatus = servicesMonitor.getServiceStatus(service.toString());\r\n        if (serviceStatus.compareTo(ServicesMonitor.ServiceStatus.UP.toString()) == 0) {\r\n            serviceStatus = NbBundle.getMessage(AutoIngestControlPanel.class, \"AutoIngestControlPanel.tbServicesStatusMessage.Message.Up\");\r\n        } else {\r\n            serviceStatus = NbBundle.getMessage(AutoIngestControlPanel.class, \"AutoIngestControlPanel.tbServicesStatusMessage.Message.Down\");\r\n        }\r\n    } catch (ServicesMonitor.ServicesMonitorException ex) {\r\n        sysLogger.log(Level.SEVERE, String.format(\"Dashboard error getting service status for %s\", service), ex);\r\n    }\r\n    return serviceStatus;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestControlPanel.setServicesStatusMessage",
	"Comment": "queries the services monitor and sets the text for the services statustext box.",
	"Method": "void setServicesStatusMessage(){\r\n    displayServicesStatus();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.filetypeid.FileTypeDetector.isDetectable",
	"Comment": "determines whether or not a given mime type is detectable by thisdetector.",
	"Method": "boolean isDetectable(String mimeType){\r\n    return isDetectableAsCustomType(userDefinedFileTypes, mimeType) || isDetectableAsCustomType(autopsyDefinedFileTypes, mimeType) || isDetectableByTika(mimeType);\r\n}"
}, {
	"Path": "com.fernandocejas.arrow.collections.Iterables.get",
	"Comment": "returns the element at the specified position in an iterable or a defaultvalue otherwise.",
	"Method": "T get(Iterable<T> iterable,int position,T get,Iterable<? extends T> iterable,int position,T defaultValue){\r\n    checkNotNull(iterable);\r\n    checkIndexNonnegative(position);\r\n    if (iterable instanceof List) {\r\n        List<? extends T> list = Lists.cast(iterable);\r\n        return position < list.size() ? list.get(position) : defaultValue;\r\n    } else {\r\n        Iterator<? extends T> iterator = iterable.iterator();\r\n        Iterators.advance(iterator, position);\r\n        return Iterators.getNext(iterator, defaultValue);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.test.CustomArtifactsCreatorFileIngestModule.startUp",
	"Comment": "adds the custom artifact type this module uses to the case database ofthe current case.",
	"Method": "void startUp(IngestJobContext context){\r\n    try {\r\n        CustomArtifactType.addToCaseDatabase();\r\n    } catch (Blackboard.BlackboardException | NoCurrentCaseException ex) {\r\n        throw new IngestModuleException(Bundle.CustomArtifactsCreatorFileIngestModule_exceptionMessage_errorCreatingCustomType(), ex);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.FileExporter.setUp",
	"Comment": "sets up the export process by loading user settings, creating outputdirectories, creating the json generator for the master files catalog,and determining the flag file paths.",
	"Method": "void setUp(){\r\n    filesDirPath = settings.getFilesRootDirectory();\r\n    filesDirPath = filesDirPath.resolve(deviceId);\r\n    reportsDirPath = settings.getReportsRootDirectory();\r\n    reportsDirPath = reportsDirPath.resolve(deviceId);\r\n    FileUtil.deleteDir(reportsDirPath.toFile());\r\n    FileUtil.deleteDir(filesDirPath.toFile());\r\n    Files.createDirectories(filesDirPath);\r\n    Files.createDirectories(reportsDirPath);\r\n    jsonGeneratorFactory = new JsonFactory();\r\n    jsonGeneratorFactory.setRootValueSeparator(\"\\r\\n\");\r\n    String catalogName = settings.getMasterCatalogName();\r\n    String catalogDir = catalogName.substring(0, 1).toUpperCase() + catalogName.substring(1);\r\n    Path catalogPath = Paths.get(reportsDirPath.toString(), catalogDir, catalogName + \".json\");\r\n    Files.createDirectories(catalogPath.getParent());\r\n    File catalogFile = catalogPath.toFile();\r\n    masterCatalog = jsonGeneratorFactory.createGenerator(catalogFile, JsonEncoding.UTF8);\r\n    ruleNamesToCatalogs = new HashMap();\r\n    flagFilePaths = new ArrayList();\r\n    flagFilePaths.add(Paths.get(filesDirPath.toString(), settings.getExportCompletedFlagFileName()));\r\n    flagFilePaths.add(Paths.get(reportsDirPath.toString(), catalogDir, settings.getExportCompletedFlagFileName()));\r\n    flagFilePaths.add(Paths.get(reportsDirPath.toString(), settings.getRulesEvaluatedFlagFileName()));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.KeywordList.setIngestMessages",
	"Comment": "sets whether or not to post ingest inbox messages when a keyword withinthe list is found while ingesting a data source.",
	"Method": "void setIngestMessages(boolean postIngestMessages){\r\n    this.postIngestMessages = postIngestMessages;\r\n}"
}, {
	"Path": "com.aliyun.oss.common.utils.StringUtils.beginsWithIgnoreCase",
	"Comment": "performs a case insensitive comparison and returns true if the databegins with the given sequence.",
	"Method": "boolean beginsWithIgnoreCase(String data,String seq){\r\n    return data.regionMatches(true, 0, seq, 0, seq.length());\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.DataSourceIngestJob.cancel",
	"Comment": "requests cancellation of ingest, i.e., a shutdown of the data sourcelevel and file level ingest pipelines.",
	"Method": "void cancel(IngestJob.CancellationReason reason){\r\n    this.cancelled = true;\r\n    this.cancellationReason = reason;\r\n    DataSourceIngestJob.taskScheduler.cancelPendingTasksForIngestJob(this);\r\n    if (this.doUI) {\r\n        synchronized (this.dataSourceIngestProgressLock) {\r\n            if (null != dataSourceIngestProgress) {\r\n                dataSourceIngestProgress.setDisplayName(NbBundle.getMessage(this.getClass(), \"IngestJob.progress.dataSourceIngest.initialDisplayName\", dataSource.getName()));\r\n                dataSourceIngestProgress.progress(NbBundle.getMessage(this.getClass(), \"IngestJob.progress.cancelling\"));\r\n            }\r\n        }\r\n        synchronized (this.fileIngestProgressLock) {\r\n            if (null != this.fileIngestProgress) {\r\n                this.fileIngestProgress.setDisplayName(NbBundle.getMessage(this.getClass(), \"IngestJob.progress.fileIngest.displayName\", this.dataSource.getName()));\r\n                this.fileIngestProgress.progress(NbBundle.getMessage(this.getClass(), \"IngestJob.progress.cancelling\"));\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.litesuits.http.data.TypeToken.isAssignableFrom",
	"Comment": "private helper function that performs some assignability checks forthe provided genericarraytype.",
	"Method": "boolean isAssignableFrom(Class<?> cls,boolean isAssignableFrom,Type from,boolean isAssignableFrom,TypeToken<?> token,boolean isAssignableFrom,Type from,GenericArrayType to,boolean isAssignableFrom,Type from,ParameterizedType to,Map<String, Type> typeVarMap){\r\n    if (from == null) {\r\n        return false;\r\n    }\r\n    if (to.equals(from)) {\r\n        return true;\r\n    }\r\n    Class<?> clazz = getRawType(from);\r\n    ParameterizedType ptype = null;\r\n    if (from instanceof ParameterizedType) {\r\n        ptype = (ParameterizedType) from;\r\n    }\r\n    if (ptype != null) {\r\n        Type[] tArgs = ptype.getActualTypeArguments();\r\n        TypeVariable<?>[] tParams = clazz.getTypeParameters();\r\n        for (int i = 0; i < tArgs.length; i++) {\r\n            Type arg = tArgs[i];\r\n            TypeVariable<?> var = tParams[i];\r\n            while (arg instanceof TypeVariable) {\r\n                TypeVariable<?> v = (TypeVariable<?>) arg;\r\n                arg = typeVarMap.get(v.getName());\r\n            }\r\n            typeVarMap.put(var.getName(), arg);\r\n        }\r\n        if (typeEquals(ptype, to, typeVarMap)) {\r\n            return true;\r\n        }\r\n    }\r\n    for (Type itype : clazz.getGenericInterfaces()) {\r\n        if (isAssignableFrom(itype, to, new HashMap<String, Type>(typeVarMap))) {\r\n            return true;\r\n        }\r\n    }\r\n    Type sType = clazz.getGenericSuperclass();\r\n    if (isAssignableFrom(sType, to, new HashMap<String, Type>(typeVarMap))) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.CommonAttributeValueList.getDelayedMetadataList",
	"Comment": "get the delayed list of value nodes. only use fordetermining how many commonattributevaluesactually exist in the list.",
	"Method": "List<CommonAttributeValue> getDelayedMetadataList(){\r\n    return Collections.unmodifiableList(this.delayedMetadataList);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.EamArtifactUtil.isSupportedAbstractFileType",
	"Comment": "check whether the given abstract file should be processed for the centralrepository.",
	"Method": "boolean isSupportedAbstractFileType(AbstractFile file){\r\n    if (file == null) {\r\n        return false;\r\n    }\r\n    switch(file.getType()) {\r\n        case UNALLOC_BLOCKS:\r\n        case UNUSED_BLOCKS:\r\n        case SLACK:\r\n        case VIRTUAL_DIR:\r\n        case LOCAL_DIR:\r\n            return false;\r\n        case CARVED:\r\n        case DERIVED:\r\n        case LOCAL:\r\n            return true;\r\n        case FS:\r\n            return file.isMetaFlagSet(TskData.TSK_FS_META_FLAG_ENUM.ALLOC);\r\n        default:\r\n            logger.log(Level.WARNING, \"Unexpected file type {0}\", file.getType().getName());\r\n            return false;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.SingleInterCaseCommonAttributeSearcher.findMatches",
	"Comment": "collect metadata required to render the tree table where matches mustoccur in the case with the given id.",
	"Method": "CommonAttributeSearchResults findMatches(){\r\n    CorrelationCase cCase = this.getCorrelationCaseFromId(this.corrleationCaseId);\r\n    this.correlationCaseName = cCase.getDisplayName();\r\n    return this.findFiles(cCase);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.KeywordSearchIngestModule.startUp",
	"Comment": "initializes the module for new ingest run sets up threads, timers,retrieves settings, keyword lists to run on",
	"Method": "void startUp(IngestJobContext context){\r\n    initialized = false;\r\n    jobId = context.getJobId();\r\n    dataSourceId = context.getDataSource().getId();\r\n    Server server = KeywordSearch.getServer();\r\n    if (server.coreIsOpen() == false) {\r\n        throw new IngestModuleException(Bundle.KeywordSearchIngestModule_startUp_noOpenCore_msg());\r\n    }\r\n    try {\r\n        Index indexInfo = server.getIndexInfo();\r\n        if (!IndexFinder.getCurrentSolrVersion().equals(indexInfo.getSolrVersion())) {\r\n            throw new IngestModuleException(Bundle.KeywordSearchIngestModule_startupException_indexSolrVersionNotSupported(indexInfo.getSolrVersion()));\r\n        }\r\n        if (!indexInfo.isCompatible(IndexFinder.getCurrentSchemaVersion())) {\r\n            throw new IngestModuleException(Bundle.KeywordSearchIngestModule_startupException_indexSchemaNotSupported(indexInfo.getSchemaVersion()));\r\n        }\r\n    } catch (NoOpenCoreException ex) {\r\n        throw new IngestModuleException(Bundle.KeywordSearchIngestModule_startupMessage_failedToGetIndexSchema(), ex);\r\n    }\r\n    try {\r\n        fileTypeDetector = new FileTypeDetector();\r\n    } catch (FileTypeDetector.FileTypeDetectorInitException ex) {\r\n        throw new IngestModuleException(Bundle.CannotRunFileTypeDetection(), ex);\r\n    }\r\n    ingester = Ingester.getDefault();\r\n    this.context = context;\r\n    Case openCase;\r\n    try {\r\n        openCase = Case.getCurrentCaseThrows();\r\n    } catch (NoCurrentCaseException ex) {\r\n        throw new IngestModuleException(Bundle.KeywordSearchIngestModule_noOpenCase_errMsg(), ex);\r\n    }\r\n    if (refCounter.incrementAndGet(jobId) == 1) {\r\n        if (openCase.getCaseType() == Case.CaseType.MULTI_USER_CASE) {\r\n            KeywordSearchService kwsService = new SolrSearchService();\r\n            Server.IndexingServerProperties properties = Server.getMultiUserServerProperties(openCase.getCaseDirectory());\r\n            int port;\r\n            try {\r\n                port = Integer.parseInt(properties.getPort());\r\n            } catch (NumberFormatException ex) {\r\n                throw new IngestModuleException(Bundle.KeywordSearchIngestModule_init_badInitMsg() + \" \" + Bundle.SolrConnectionCheck_Port(), ex);\r\n            }\r\n            try {\r\n                kwsService.tryConnect(properties.getHost(), port);\r\n            } catch (KeywordSearchServiceException ex) {\r\n                throw new IngestModuleException(Bundle.KeywordSearchIngestModule_init_badInitMsg(), ex);\r\n            }\r\n        } else {\r\n            try {\r\n                if (!server.isRunning()) {\r\n                    throw new IngestModuleException(Bundle.KeywordSearchIngestModule_init_tryStopSolrMsg(Bundle.KeywordSearchIngestModule_init_badInitMsg()));\r\n                }\r\n            } catch (KeywordSearchModuleException ex) {\r\n                throw new IngestModuleException(Bundle.KeywordSearchIngestModule_init_tryStopSolrMsg(Bundle.KeywordSearchIngestModule_init_badInitMsg()), ex);\r\n            }\r\n            try {\r\n                server.queryNumIndexedDocuments();\r\n            } catch (KeywordSearchModuleException | NoOpenCoreException ex) {\r\n                throw new IngestModuleException(Bundle.KeywordSearchIngestModule_init_exception_errConnToSolr_msg(ex.getMessage()), ex);\r\n            }\r\n            List<KeywordList> keywordLists = XmlKeywordSearchList.getCurrent().getListsL();\r\n            boolean hasKeywordsForSearch = false;\r\n            for (KeywordList keywordList : keywordLists) {\r\n                if (settings.keywordListIsEnabled(keywordList.getName()) && !keywordList.getKeywords().isEmpty()) {\r\n                    hasKeywordsForSearch = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!hasKeywordsForSearch) {\r\n                services.postMessage(IngestMessage.createWarningMessage(KeywordSearchModuleFactory.getModuleName(), NbBundle.getMessage(this.getClass(), \"KeywordSearchIngestModule.init.noKwInLstMsg\"), NbBundle.getMessage(this.getClass(), \"KeywordSearchIngestModule.init.onlyIdxKwSkipMsg\")));\r\n            }\r\n        }\r\n    }\r\n    stringExtractor = new StringsTextExtractor();\r\n    stringExtractor.setScripts(KeywordSearchSettings.getStringExtractScripts());\r\n    stringExtractor.setOptions(KeywordSearchSettings.getStringExtractOptions());\r\n    txtFileExtractor = new TextFileExtractor();\r\n    textExtractors = new ArrayList();\r\n    textExtractors.add(new HtmlTextExtractor());\r\n    textExtractors.add(new SqliteTextExtractor());\r\n    textExtractors.add(new TikaTextExtractor());\r\n    indexer = new Indexer();\r\n    initialized = true;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.GlobalListSettingsPanel.copyAction",
	"Comment": "duplicates the selected keyword list, returns whether or not the keywordlist was duplicated.",
	"Method": "boolean copyAction(){\r\n    final String FEATURE_NAME = NbBundle.getMessage(this.getClass(), \"KeywordSearchGlobalListSettingsPanel.component.featureName.text\");\r\n    KeywordList currentKeywordList = editListPanel.getCurrentKeywordList();\r\n    List<Keyword> keywords = new ArrayList();\r\n    keywords.addAll(currentKeywordList.getKeywords());\r\n    String listName = (String) JOptionPane.showInputDialog(this, NbBundle.getMessage(this.getClass(), \"KeywordSearch.newKwListTitle\"), FEATURE_NAME, JOptionPane.PLAIN_MESSAGE, null, null, currentKeywordList.getName());\r\n    if (listName == null) {\r\n        return false;\r\n    }\r\n    listName = listName.trim();\r\n    if (listName.equals(\"\") || listName.equals(currentKeywordList.getName())) {\r\n        return false;\r\n    }\r\n    XmlKeywordSearchList writer = XmlKeywordSearchList.getCurrent();\r\n    if (writer.listExists(listName) && writer.getList(listName).isEditable()) {\r\n        KeywordSearchUtil.displayDialog(FEATURE_NAME, NbBundle.getMessage(this.getClass(), \"KeywordSearchConfigurationPanel1.customizeComponents.noOwDefaultMsg\"), KeywordSearchUtil.DIALOG_MESSAGE_TYPE.WARN);\r\n        return false;\r\n    }\r\n    if (writer.listExists(listName)) {\r\n        if (!KeywordSearchUtil.displayConfirmDialog(FEATURE_NAME, NbBundle.getMessage(this.getClass(), \"KeywordSearchConfigurationPanel1.customizeComponents.kwListExistMsg\", listName), KeywordSearchUtil.DIALOG_MESSAGE_TYPE.WARN)) {\r\n            return false;\r\n        }\r\n    }\r\n    writer.addList(listName, keywords);\r\n    KeywordSearchUtil.displayDialog(FEATURE_NAME, NbBundle.getMessage(this.getClass(), \"KeywordSearchConfigurationPanel1.customizeComponents.kwListSavedMsg\", listName), KeywordSearchUtil.DIALOG_MESSAGE_TYPE.INFO);\r\n    return true;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJobLogger.logIngestModuleStartupErrors",
	"Comment": "logs failure to analyze a data source due to ingest module startuperrors.",
	"Method": "void logIngestModuleStartupErrors(){\r\n    log(MessageCategory.ERROR, \"Failed to analyze data source due to ingest module startup errors\");\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.DataSourceIngestPipeline.process",
	"Comment": "runs a data source through the ingest modules in sequential order.",
	"Method": "List<IngestModuleError> process(DataSourceIngestTask task,IngestModule.ProcessResult process,Content dataSource,DataSourceIngestModuleProgress statusHelper){\r\n    List<IngestModuleError> errors = new ArrayList();\r\n    if (!this.job.isCancelled()) {\r\n        Content dataSource = task.getDataSource();\r\n        for (PipelineModule module : modules) {\r\n            try {\r\n                this.currentModule = module;\r\n                String displayName = NbBundle.getMessage(this.getClass(), \"IngestJob.progress.dataSourceIngest.displayName\", module.getDisplayName(), dataSource.getName());\r\n                this.job.updateDataSourceIngestProgressBarDisplayName(displayName);\r\n                this.job.switchDataSourceIngestProgressBarToIndeterminate();\r\n                DataSourceIngestPipeline.ingestManager.setIngestTaskProgress(task, module.getDisplayName());\r\n                logger.log(Level.INFO, \"{0} analysis of {1} (jobId={2}) starting\", new Object[] { module.getDisplayName(), this.job.getDataSource().getName(), this.job.getDataSource().getId() });\r\n                module.process(dataSource, new DataSourceIngestModuleProgress(this.job));\r\n                logger.log(Level.INFO, \"{0} analysis of {1} (jobId={2}) finished\", new Object[] { module.getDisplayName(), this.job.getDataSource().getName(), this.job.getDataSource().getId() });\r\n            } catch (Throwable ex) {\r\n                errors.add(new IngestModuleError(module.getDisplayName(), ex));\r\n                String msg = ex.getMessage();\r\n                if (msg == null) {\r\n                    msg = ex.toString();\r\n                }\r\n                MessageNotifyUtil.Notify.error(NbBundle.getMessage(this.getClass(), \"DataSourceIngestPipeline.moduleError.title.text\", module.getDisplayName()), msg);\r\n            }\r\n            if (this.job.isCancelled()) {\r\n                break;\r\n            } else if (this.job.currentDataSourceIngestModuleIsCancelled()) {\r\n                this.job.currentDataSourceIngestModuleCancellationCompleted(currentModule.getDisplayName());\r\n            }\r\n        }\r\n    }\r\n    this.currentModule = null;\r\n    ingestManager.setIngestTaskProgressCompleted(task);\r\n    return errors;\r\n}"
}, {
	"Path": "com.mcxiaoke.next.ui.internal.AdapterWrapper.getWrappedAdapter",
	"Comment": "returns the listadapter that is wrapped by the endlesslogic.",
	"Method": "ListAdapter getWrappedAdapter(){\r\n    return (wrapped);\r\n}"
}, {
	"Path": "com.anysoftkeyboard.ime.AnySoftKeyboardBase.onUpdateSelection",
	"Comment": "this function is called every time them selection is changed. this alsoincludes the underlined suggestions.",
	"Method": "void onUpdateSelection(int oldSelStart,int oldSelEnd,int newSelStart,int newSelEnd,int candidatesStart,int candidatesEnd){\r\n    super.onUpdateSelection(oldSelStart, oldSelEnd, newSelStart, newSelEnd, candidatesStart, candidatesEnd);\r\n    if (BuildConfig.DEBUG) {\r\n        Logger.d(TAG, \"onUpdateSelection: oss=%d, ose=%d, nss=%d, nse=%d, cs=%d, ce=%d\", oldSelStart, oldSelEnd, newSelStart, newSelEnd, candidatesStart, candidatesEnd);\r\n    }\r\n    mGlobalCursorPosition = newSelEnd;\r\n    mGlobalSelectionStartPosition = newSelStart;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.CommonAttributePanel.checkFileTypeCheckBoxState",
	"Comment": "check that the sub panels have valid options selected regarding theirfile type filtering options, and update the errormanager with thevalidity.",
	"Method": "void checkFileTypeCheckBoxState(){\r\n    boolean validCheckBoxState = true;\r\n    if (CommonAttributePanel.this.interCaseRadio.isSelected()) {\r\n        if (interCasePanel.fileCategoriesButtonIsSelected()) {\r\n            validCheckBoxState = interCasePanel.pictureVideoCheckboxIsSelected() || interCasePanel.documentsCheckboxIsSelected();\r\n        }\r\n    } else {\r\n        if (intraCasePanel.fileCategoriesButtonIsSelected()) {\r\n            validCheckBoxState = intraCasePanel.pictureVideoCheckboxIsSelected() || intraCasePanel.documentsCheckboxIsSelected();\r\n        }\r\n    }\r\n    if (validCheckBoxState) {\r\n        this.errorManager.setError(UserInputErrorManager.NO_FILE_CATEGORIES_SELECTED_KEY, false);\r\n    } else {\r\n        this.errorManager.setError(UserInputErrorManager.NO_FILE_CATEGORIES_SELECTED_KEY, true);\r\n    }\r\n    this.updateErrorTextAndSearchButton();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.DataSourceIngestJob.switchDataSourceIngestProgressBarToDeterminate",
	"Comment": "switches the data source level ingest progress bar for this job todeterminate mode. this should be called if the total work units toprocess the data source is known.",
	"Method": "void switchDataSourceIngestProgressBarToDeterminate(int workUnits){\r\n    if (this.doUI && !this.cancelled) {\r\n        synchronized (this.dataSourceIngestProgressLock) {\r\n            if (null != this.dataSourceIngestProgress) {\r\n                this.dataSourceIngestProgress.switchToDeterminate(workUnits);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.events.AddingDataSourceEvent.getEventId",
	"Comment": "gets the unique event id used to pair thisaddinddatasourceevent with a corresponding datasourceaddedevent oraddingdatasourcefailedevent.",
	"Method": "UUID getEventId(){\r\n    return dataSourceId;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.healthmonitor.HealthMonitor.monitorIsEnabled",
	"Comment": "return whether the health monitor is locally enabled. this does not querythe database.",
	"Method": "boolean monitorIsEnabled(){\r\n    return isEnabled.get();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.autoingest.AutoIngestJob.isCanceled",
	"Comment": "indicates whether or not the job has been cancelled. this is transientstate used by the auto ingest manager that is not saved as coordinationservice node data for the job.",
	"Method": "boolean isCanceled(){\r\n    return cancelled;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.directorytree.DirectoryTreeTopComponent.setSelectedNode",
	"Comment": "set the selected node using a path to a previously selected node.",
	"Method": "void setSelectedNode(String[] previouslySelectedNodePath,String rootNodeName){\r\n    if (previouslySelectedNodePath == null) {\r\n        return;\r\n    }\r\n    SwingUtilities.invokeLater(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            if (previouslySelectedNodePath.length > 0 && (rootNodeName == null || previouslySelectedNodePath[0].equals(rootNodeName))) {\r\n                Node selectedNode = null;\r\n                ArrayList<String> selectedNodePath = new ArrayList(Arrays.asList(previouslySelectedNodePath));\r\n                while (null == selectedNode && !selectedNodePath.isEmpty()) {\r\n                    try {\r\n                        selectedNode = NodeOp.findPath(em.getRootContext(), selectedNodePath.toArray(new String[selectedNodePath.size()]));\r\n                    } catch (NodeNotFoundException ex) {\r\n                        if (selectedNodePath.size() > 1) {\r\n                            selectedNodePath.remove(selectedNodePath.size() - 1);\r\n                        } else {\r\n                            StringBuilder nodePath = new StringBuilder();\r\n                            for (int i = 0; i < previouslySelectedNodePath.length; ++i) {\r\n                                nodePath.append(previouslySelectedNodePath[i]).append(\"/\");\r\n                            }\r\n                            LOGGER.log(Level.WARNING, \"Failed to find any nodes to select on path \" + nodePath.toString(), ex);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                if (null != selectedNode) {\r\n                    if (rootNodeName != null) {\r\n                        backList.pollLast();\r\n                    }\r\n                    try {\r\n                        em.setExploredContextAndSelection(selectedNode, new Node[] { selectedNode });\r\n                    } catch (PropertyVetoException ex) {\r\n                        LOGGER.log(Level.WARNING, \"Property veto from ExplorerManager setting selection to \" + selectedNode.getName(), ex);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.directorytree.DirectoryTreeTopComponent.setSelectedNode",
	"Comment": "set the selected node using a path to a previously selected node.",
	"Method": "void setSelectedNode(String[] previouslySelectedNodePath,String rootNodeName){\r\n    if (previouslySelectedNodePath.length > 0 && (rootNodeName == null || previouslySelectedNodePath[0].equals(rootNodeName))) {\r\n        Node selectedNode = null;\r\n        ArrayList<String> selectedNodePath = new ArrayList(Arrays.asList(previouslySelectedNodePath));\r\n        while (null == selectedNode && !selectedNodePath.isEmpty()) {\r\n            try {\r\n                selectedNode = NodeOp.findPath(em.getRootContext(), selectedNodePath.toArray(new String[selectedNodePath.size()]));\r\n            } catch (NodeNotFoundException ex) {\r\n                if (selectedNodePath.size() > 1) {\r\n                    selectedNodePath.remove(selectedNodePath.size() - 1);\r\n                } else {\r\n                    StringBuilder nodePath = new StringBuilder();\r\n                    for (int i = 0; i < previouslySelectedNodePath.length; ++i) {\r\n                        nodePath.append(previouslySelectedNodePath[i]).append(\"/\");\r\n                    }\r\n                    LOGGER.log(Level.WARNING, \"Failed to find any nodes to select on path \" + nodePath.toString(), ex);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (null != selectedNode) {\r\n            if (rootNodeName != null) {\r\n                backList.pollLast();\r\n            }\r\n            try {\r\n                em.setExploredContextAndSelection(selectedNode, new Node[] { selectedNode });\r\n            } catch (PropertyVetoException ex) {\r\n                LOGGER.log(Level.WARNING, \"Property veto from ExplorerManager setting selection to \" + selectedNode.getName(), ex);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.events.BlackboardPostEvent.getOldValue",
	"Comment": "gets the legacy moduledataevent object associated with this event.",
	"Method": "Object getOldValue(){\r\n    if (null != eventData) {\r\n        return eventData;\r\n    }\r\n    try {\r\n        SerializableEventData data = (SerializableEventData) super.getOldValue();\r\n        Collection<BlackboardArtifact> artifacts = new ArrayList();\r\n        for (Long id : data.artifactIds) {\r\n            artifacts.add(Case.getCurrentCaseThrows().getSleuthkitCase().getBlackboardArtifact(id));\r\n        }\r\n        eventData = new ModuleDataEvent(data.moduleName, data.artifactTypeId, !artifacts.isEmpty() ? artifacts : null);\r\n        return eventData;\r\n    } catch (NoCurrentCaseException | TskCoreException ex) {\r\n        logger.log(Level.SEVERE, \"Error doing lazy load for remote event\", ex);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "net.ypresto.androidtranscoder.engine.OutputSurface.setup",
	"Comment": "creates instances of texturerender and surfacetexture, and a surface associatedwith the surfacetexture.",
	"Method": "void setup(){\r\n    mTextureRender = new TextureRender();\r\n    mTextureRender.surfaceCreated();\r\n    if (VERBOSE)\r\n        Log.d(TAG, \"textureID=\" + mTextureRender.getTextureId());\r\n    mSurfaceTexture = new SurfaceTexture(mTextureRender.getTextureId());\r\n    mSurfaceTexture.setOnFrameAvailableListener(this);\r\n    mSurface = new Surface(mSurfaceTexture);\r\n}"
}, {
	"Path": "com.aliyun.oss.ClientConfiguration.getDefaultHeaders",
	"Comment": "gets the default http headers. all these headers would be automaticallyadded in every request. and if a header is also specified in the request,the default one will be overwritten.",
	"Method": "Map<String, String> getDefaultHeaders(){\r\n    return defaultHeaders;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.DataSourceIngestJob.checkForStageCompleted",
	"Comment": "checks to see if the ingest tasks for the current stage of this job arecompleted and does a stage transition if they are.",
	"Method": "void checkForStageCompleted(){\r\n    synchronized (this.stageCompletionCheckLock) {\r\n        if (DataSourceIngestJob.taskScheduler.tasksForJobAreCompleted(this)) {\r\n            switch(this.stage) {\r\n                case FIRST:\r\n                    this.finishFirstStage();\r\n                    break;\r\n                case SECOND:\r\n                    this.finish();\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestServices.getFreeDiskSpace",
	"Comment": "gets the free disk space of the drive where data is written duringingest. can be used by ingest modules to determine if there is enoughdisk space before writing data is attmepted.",
	"Method": "long getFreeDiskSpace(){\r\n    return IngestManager.getInstance().getFreeDiskSpace();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.KeywordSearchSettings.setSkipKnown",
	"Comment": "sets whether or not to skip adding known good files to the search duringindex.",
	"Method": "void setSkipKnown(boolean skip){\r\n    ModuleSettings.setConfigSetting(PROPERTIES_NSRL, \"SkipKnown\", Boolean.toString(skip));\r\n    skipKnown = skip;\r\n}"
}, {
	"Path": "com.facebook.samples.zoomable.AbstractAnimatedZoomableController.isIdentity",
	"Comment": "returns true if the zoomable transform is identity matrix, and the controller is idle.",
	"Method": "boolean isIdentity(){\r\n    return !isAnimating() && super.isIdentity();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.DropdownSingleTermSearchPanel.getDefault",
	"Comment": "gets the default instance of a dropdown panel that provides guicomponents that allow a user to do three types of ad hoc single keywordsearches.",
	"Method": "DropdownSingleTermSearchPanel getDefault(){\r\n    if (null == defaultInstance) {\r\n        defaultInstance = new DropdownSingleTermSearchPanel();\r\n    }\r\n    return defaultInstance;\r\n}"
}, {
	"Path": "com.mcxiaoke.next.recycler.HeaderFooterRecyclerAdapter.getFooterItemViewType",
	"Comment": "gets the footer item view type. by default, this method returns 0.",
	"Method": "int getFooterItemViewType(int position){\r\n    return 0;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.DropdownListSearchPanel.setComponentsEnabled",
	"Comment": "set the datasourcelist enabled if the datasourcecheckbox is selected",
	"Method": "void setComponentsEnabled(){\r\n    if (getDataSourceListModel().size() > 1) {\r\n        this.dataSourceCheckBox.setEnabled(true);\r\n        boolean enabled = this.dataSourceCheckBox.isSelected();\r\n        this.dataSourceList.setEnabled(enabled);\r\n        if (enabled) {\r\n            this.dataSourceList.setSelectionInterval(0, this.dataSourceList.getModel().getSize() - 1);\r\n        } else {\r\n            this.dataSourceList.setSelectedIndices(new int[0]);\r\n        }\r\n    } else {\r\n        this.dataSourceCheckBox.setEnabled(false);\r\n        this.dataSourceCheckBox.setSelected(false);\r\n        this.dataSourceList.setEnabled(false);\r\n        this.dataSourceList.setSelectedIndices(new int[0]);\r\n    }\r\n}"
}, {
	"Path": "com.litesuits.http.data.TypeToken.typeEquals",
	"Comment": "checks if two parameterized types are exactly equal, under the variablereplacement described in the typevarmap.",
	"Method": "boolean typeEquals(ParameterizedType from,ParameterizedType to,Map<String, Type> typeVarMap){\r\n    if (from.getRawType().equals(to.getRawType())) {\r\n        Type[] fromArgs = from.getActualTypeArguments();\r\n        Type[] toArgs = to.getActualTypeArguments();\r\n        for (int i = 0; i < fromArgs.length; i++) {\r\n            if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.datasourceprocessors.RawDSProcessor.isPanelValid",
	"Comment": "indicates whether the settings in the selection and configuration panelare valid and complete.",
	"Method": "boolean isPanelValid(){\r\n    return configPanel.validatePanel();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.InterCasePanel.fileCategoriesButtonIsSelected",
	"Comment": "if the user has selected to show only results of specific file types.",
	"Method": "boolean fileCategoriesButtonIsSelected(){\r\n    return selectedFileCategoriesButton.isEnabled() && selectedFileCategoriesButton.isSelected();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.recentactivity.Extract.addArtifact",
	"Comment": "generic method for adding a blackboard artifact to the blackboard and indexing it",
	"Method": "BlackboardArtifact addArtifact(BlackboardArtifact.ARTIFACT_TYPE type,AbstractFile content,Collection<BlackboardAttribute> bbattributes){\r\n    try {\r\n        BlackboardArtifact bbart = content.newArtifact(type);\r\n        bbart.addAttributes(bbattributes);\r\n        this.indexArtifact(bbart);\r\n        return bbart;\r\n    } catch (TskException ex) {\r\n        logger.log(Level.SEVERE, \"Error while trying to add an artifact\", ex);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.experimental.configuration.SharedConfiguration.getSharedFolder",
	"Comment": "get the base folder being used to store the shared config settings.",
	"Method": "File getSharedFolder(){\r\n    String remoteConfigFolderPath = AutoIngestUserPreferences.getSharedConfigFolder();\r\n    if (remoteConfigFolderPath.isEmpty()) {\r\n        logger.log(Level.SEVERE, \"Shared configuration folder is not set.\");\r\n        throw new SharedConfigurationException(\"Shared configuration folder is not set.\");\r\n    }\r\n    File remoteFolder = new File(remoteConfigFolderPath);\r\n    if (!remoteFolder.exists()) {\r\n        logger.log(Level.SEVERE, \"Shared configuration folder {0} does not exist\", remoteConfigFolderPath);\r\n        throw new SharedConfigurationException(\"Shared configuration folder \" + remoteConfigFolderPath + \" does not exist\");\r\n    }\r\n    return remoteFolder;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.commonfilesearch.IntraCasePanel.fileCategoriesButtonIsSelected",
	"Comment": "if the user has selected to show only results of specific file types.",
	"Method": "boolean fileCategoriesButtonIsSelected(){\r\n    return selectedFileCategoriesButton.isSelected();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.optionspanel.ManageCasesDialog.updateSelection",
	"Comment": "update the information displayed to reflect the currently selected case.",
	"Method": "void updateSelection(){\r\n    dataSourcesTableModel.clearTable();\r\n    if (casesTable.getSelectedRow() >= 0 && casesTable.getSelectedRow() < casesTable.getRowCount()) {\r\n        CaseDataSourcesWrapper caseWrapper = casesTableModel.getEamCase(casesTable.convertRowIndexToModel(casesTable.getSelectedRow()));\r\n        orgValueLabel.setText(caseWrapper.getOrganizationName());\r\n        caseNumberValueLabel.setText(caseWrapper.getCaseNumber());\r\n        examinerNameValueLabel.setText(caseWrapper.getExaminerName());\r\n        examinerPhoneValueLabel.setText(caseWrapper.getExaminerPhone());\r\n        examinerEmailValueLabel.setText(caseWrapper.getExaminerEmail());\r\n        notesTextArea.setText(caseWrapper.getNotes());\r\n        dataSourcesTableModel.addDataSources(caseWrapper.getDataSources());\r\n    } else {\r\n        orgValueLabel.setText(\"\");\r\n        caseNumberValueLabel.setText(\"\");\r\n        examinerNameValueLabel.setText(\"\");\r\n        examinerPhoneValueLabel.setText(\"\");\r\n        examinerEmailValueLabel.setText(\"\");\r\n        notesTextArea.setText(\"\");\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.SqliteEamDb.getCountArtifactInstancesByTypeValue",
	"Comment": "retrieves number of artifact instances in the database that areassociated with the artifacttype and artifactvalue of the given artifact.",
	"Method": "Long getCountArtifactInstancesByTypeValue(CorrelationAttributeInstance.Type aType,String value){\r\n    try {\r\n        acquireSharedLock();\r\n        return super.getCountArtifactInstancesByTypeValue(aType, value);\r\n    } finally {\r\n        releaseSharedLock();\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.stix.STIXReportModule.processIndicators",
	"Comment": "process all stix indicators and save results to output file and createartifacts.",
	"Method": "void processIndicators(STIXPackage stix,BufferedWriter output){\r\n    if (stix.getIndicators() != null) {\r\n        List<IndicatorBaseType> s = stix.getIndicators().getIndicators();\r\n        for (IndicatorBaseType t : s) {\r\n            if (t instanceof Indicator) {\r\n                Indicator ind = (Indicator) t;\r\n                if (ind.getObservable() != null) {\r\n                    if (ind.getObservable().getObject() != null) {\r\n                        ObservableResult result = evaluateSingleObservable(ind.getObservable(), \"\");\r\n                        if (result.isTrue() || reportAllResults) {\r\n                            writeResultsToFile(ind, result.getDescription(), result.isTrue(), output);\r\n                        }\r\n                        if (result.isTrue()) {\r\n                            saveResultsAsArtifacts(ind, result);\r\n                        }\r\n                    } else if (ind.getObservable().getObservableComposition() != null) {\r\n                        ObservableResult result = evaluateObservableComposition(ind.getObservable().getObservableComposition(), \"  \");\r\n                        if (result.isTrue() || reportAllResults) {\r\n                            writeResultsToFile(ind, result.getDescription(), result.isTrue(), output);\r\n                        }\r\n                        if (result.isTrue()) {\r\n                            saveResultsAsArtifacts(ind, result);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.NewCaseWizardPanel2.fireChangeEvent",
	"Comment": "notifies any registerd change listeners of a change in the panel.",
	"Method": "void fireChangeEvent(){\r\n    Iterator<ChangeListener> it;\r\n    synchronized (listeners) {\r\n        it = new HashSet(listeners).iterator();\r\n    }\r\n    ChangeEvent ev = new ChangeEvent(this);\r\n    while (it.hasNext()) {\r\n        it.next().stateChanged(ev);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.core.Installer.ensureClassifierFolderExists",
	"Comment": "make a folder in the config directory for object detection classifiers if one does notexist.",
	"Method": "void ensureClassifierFolderExists(){\r\n    File objectDetectionClassifierDir = new File(PlatformUtil.getObjectDetectionClassifierPath());\r\n    objectDetectionClassifierDir.mkdir();\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.snapshot.SnapShotReportWriter.fillTemplateAndWrite",
	"Comment": "fill in the mustache template at the given location using the values fromthe given context object and save it to the given outputfile.",
	"Method": "void fillTemplateAndWrite(String templateLocation,String templateName,Object context,Path outPutFile){\r\n    Mustache summaryMustache = mf.compile(new InputStreamReader(SnapShotReportWriter.class.getResourceAsStream(templateLocation)), templateName);\r\n    try (Writer writer = Files.newBufferedWriter(outPutFile, Charset.forName(\"UTF-8\"))) {\r\n        summaryMustache.execute(writer, context);\r\n    }\r\n}"
}, {
	"Path": "com.aliyun.oss.internal.ResponseParsers.parseGetLiveChannelHistory",
	"Comment": "unmarshall get live channel history response body to correspondingresult.",
	"Method": "List<LiveRecord> parseGetLiveChannelHistory(InputStream responseBody){\r\n    try {\r\n        Element root = getXmlRootElement(responseBody);\r\n        List<LiveRecord> liveRecords = new ArrayList<LiveRecord>();\r\n        List<Element> recordElements = root.getChildren(\"LiveRecord\");\r\n        for (Element recordElem : recordElements) {\r\n            LiveRecord record = new LiveRecord();\r\n            record.setStartDate(DateUtil.parseIso8601Date(recordElem.getChildText(\"StartTime\")));\r\n            record.setEndDate(DateUtil.parseIso8601Date(recordElem.getChildText(\"EndTime\")));\r\n            record.setRemoteAddress(recordElem.getChildText(\"RemoteAddr\"));\r\n            liveRecords.add(record);\r\n        }\r\n        return liveRecords;\r\n    } catch (JDOMParseException e) {\r\n        throw new ResponseParseException(e.getPartialDocument() + \": \" + e.getMessage(), e);\r\n    } catch (Exception e) {\r\n        throw new ResponseParseException(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.ui.ViewFrame.refreshHistorgram",
	"Comment": "refresh the histogram to represent the current state of the db.",
	"Method": "void refreshHistorgram(){\r\n    if (histogramTask != null) {\r\n        histogramTask.cancel(true);\r\n    }\r\n    histogramTask = new LoggedTask<Void>(Bundle.ViewFrame_histogramTask_title(), true) {\r\n        private final Lighting lighting = new Lighting();\r\n        @Override\r\n        protected Void call() throws Exception {\r\n            updateMessage(ViewFrame_histogramTask_preparing());\r\n            long max = 0;\r\n            final RangeDivisionInfo rangeInfo = RangeDivisionInfo.getRangeDivisionInfo(filteredEvents.getSpanningInterval());\r\n            final long lowerBound = rangeInfo.getLowerBound();\r\n            final long upperBound = rangeInfo.getUpperBound();\r\n            Interval timeRange = new Interval(new DateTime(lowerBound, TimeLineController.getJodaTimeZone()), new DateTime(upperBound, TimeLineController.getJodaTimeZone()));\r\n            int p = 0;\r\n            Platform.runLater(() -> {\r\n                updateMessage(ViewFrame_histogramTask_resetUI());\r\n            });\r\n            ArrayList<Long> bins = new ArrayList();\r\n            DateTime start = timeRange.getStart();\r\n            while (timeRange.contains(start)) {\r\n                if (isCancelled()) {\r\n                    return null;\r\n                }\r\n                DateTime end = start.plus(rangeInfo.getPeriodSize().getPeriod());\r\n                final Interval interval = new Interval(start, end);\r\n                start = end;\r\n                updateMessage(ViewFrame_histogramTask_queryDb());\r\n                long count = filteredEvents.getEventCounts(interval).values().stream().mapToLong(Long::valueOf).sum();\r\n                bins.add(count);\r\n                max = Math.max(count, max);\r\n                final double fMax = Math.log(max);\r\n                final ArrayList<Long> fbins = new ArrayList(bins);\r\n                Platform.runLater(() -> {\r\n                    updateMessage(ViewFrame_histogramTask_updateUI2());\r\n                    histogramBox.getChildren().clear();\r\n                    for (Long bin : fbins) {\r\n                        if (isCancelled()) {\r\n                            break;\r\n                        }\r\n                        Region bar = new Region();\r\n                        bar.prefHeightProperty().bind(histogramBox.heightProperty().multiply(Math.log(bin)).divide(fMax));\r\n                        bar.setMaxHeight(USE_PREF_SIZE);\r\n                        bar.setMinHeight(USE_PREF_SIZE);\r\n                        bar.setBackground(GRAY_BACKGROUND);\r\n                        bar.setOnMouseEntered((MouseEvent event) -> {\r\n                            Tooltip.install(bar, new Tooltip(bin.toString()));\r\n                        });\r\n                        bar.setEffect(lighting);\r\n                        HBox.setHgrow(bar, Priority.ALWAYS);\r\n                        histogramBox.getChildren().add(bar);\r\n                    }\r\n                });\r\n            }\r\n            return null;\r\n        }\r\n    };\r\n    new Thread(histogramTask).start();\r\n    controller.monitorTask(histogramTask);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.ui.ViewFrame.refreshHistorgram",
	"Comment": "refresh the histogram to represent the current state of the db.",
	"Method": "void refreshHistorgram(){\r\n    updateMessage(ViewFrame_histogramTask_preparing());\r\n    long max = 0;\r\n    final RangeDivisionInfo rangeInfo = RangeDivisionInfo.getRangeDivisionInfo(filteredEvents.getSpanningInterval());\r\n    final long lowerBound = rangeInfo.getLowerBound();\r\n    final long upperBound = rangeInfo.getUpperBound();\r\n    Interval timeRange = new Interval(new DateTime(lowerBound, TimeLineController.getJodaTimeZone()), new DateTime(upperBound, TimeLineController.getJodaTimeZone()));\r\n    int p = 0;\r\n    Platform.runLater(() -> {\r\n        updateMessage(ViewFrame_histogramTask_resetUI());\r\n    });\r\n    ArrayList<Long> bins = new ArrayList();\r\n    DateTime start = timeRange.getStart();\r\n    while (timeRange.contains(start)) {\r\n        if (isCancelled()) {\r\n            return null;\r\n        }\r\n        DateTime end = start.plus(rangeInfo.getPeriodSize().getPeriod());\r\n        final Interval interval = new Interval(start, end);\r\n        start = end;\r\n        updateMessage(ViewFrame_histogramTask_queryDb());\r\n        long count = filteredEvents.getEventCounts(interval).values().stream().mapToLong(Long::valueOf).sum();\r\n        bins.add(count);\r\n        max = Math.max(count, max);\r\n        final double fMax = Math.log(max);\r\n        final ArrayList<Long> fbins = new ArrayList(bins);\r\n        Platform.runLater(() -> {\r\n            updateMessage(ViewFrame_histogramTask_updateUI2());\r\n            histogramBox.getChildren().clear();\r\n            for (Long bin : fbins) {\r\n                if (isCancelled()) {\r\n                    break;\r\n                }\r\n                Region bar = new Region();\r\n                bar.prefHeightProperty().bind(histogramBox.heightProperty().multiply(Math.log(bin)).divide(fMax));\r\n                bar.setMaxHeight(USE_PREF_SIZE);\r\n                bar.setMinHeight(USE_PREF_SIZE);\r\n                bar.setBackground(GRAY_BACKGROUND);\r\n                bar.setOnMouseEntered((MouseEvent event) -> {\r\n                    Tooltip.install(bar, new Tooltip(bin.toString()));\r\n                });\r\n                bar.setEffect(lighting);\r\n                HBox.setHgrow(bar, Priority.ALWAYS);\r\n                histogramBox.getChildren().add(bar);\r\n            }\r\n        });\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.owntracks.android.support.Preferences.getKeepalive",
	"Comment": "minimum time is 15minutes because work manager cannot schedule any faster",
	"Method": "int getKeepalive(){\r\n    return Math.max(getInt(Keys.KEEPALIVE, R.integer.valKeepalive), (int) TimeUnit.MILLISECONDS.toSeconds(Scheduler.MIN_PERIODIC_INTERVAL_MILLIS));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.ingest.IngestJobContext.addFilesToJob",
	"Comment": "adds one or more files, i.e., extracted or carved files, to the ingestjob associated with this context.",
	"Method": "void addFilesToJob(List<AbstractFile> files){\r\n    this.ingestJob.addFiles(files);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.AdHocSearchPanel.getDataSourceMap",
	"Comment": "get datasourcemap with object id and data source display name.",
	"Method": "Map<Long, String> getDataSourceMap(){\r\n    return dataSourceMap;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.keywordsearch.Server.coreIsLoaded",
	"Comment": "determines whether or not a particular solr core exists and is loaded.",
	"Method": "boolean coreIsLoaded(String coreName){\r\n    CoreAdminResponse response = CoreAdminRequest.getStatus(coreName, currentSolrServer);\r\n    return response.getCoreStatus(coreName).get(\"instanceDir\") != null;\r\n}"
}, {
	"Path": "com.facebook.samples.zoomable.ZoomableDraweeView.setZoomableController",
	"Comment": "sets a custom zoomable controller, instead of using the default one.",
	"Method": "void setZoomableController(ZoomableController zoomableController){\r\n    Preconditions.checkNotNull(zoomableController);\r\n    mZoomableController.setListener(null);\r\n    mZoomableController = zoomableController;\r\n    mZoomableController.setListener(mZoomableListener);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.filetypeid.FileTypeIdIngestModule.createInterestingFileHit",
	"Comment": "create an interesting file hit using the specified file type rule.",
	"Method": "void createInterestingFileHit(AbstractFile file,FileType fileType){\r\n    try {\r\n        Collection<BlackboardAttribute> attributes = new ArrayList();\r\n        attributes.add(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_SET_NAME, FileTypeIdModuleFactory.getModuleName(), fileType.getInterestingFilesSetName()));\r\n        attributes.add(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_CATEGORY, FileTypeIdModuleFactory.getModuleName(), fileType.getMimeType()));\r\n        Case currentCase = Case.getCurrentCaseThrows();\r\n        org.sleuthkit.datamodel.Blackboard tskBlackboard = currentCase.getSleuthkitCase().getBlackboard();\r\n        if (!tskBlackboard.artifactExists(file, BlackboardArtifact.ARTIFACT_TYPE.TSK_INTERESTING_FILE_HIT, attributes)) {\r\n            BlackboardArtifact artifact = file.newArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_INTERESTING_FILE_HIT);\r\n            artifact.addAttributes(attributes);\r\n            try {\r\n                currentCase.getServices().getBlackboard().indexArtifact(artifact);\r\n            } catch (Blackboard.BlackboardException ex) {\r\n                logger.log(Level.SEVERE, String.format(\"Unable to index TSK_INTERESTING_FILE_HIT blackboard artifact %d (file obj_id=%d)\", artifact.getArtifactID(), file.getId()), ex);\r\n            }\r\n        }\r\n    } catch (TskCoreException ex) {\r\n        logger.log(Level.SEVERE, String.format(\"Unable to create TSK_INTERESTING_FILE_HIT artifact for file (obj_id=%d)\", file.getId()), ex);\r\n    } catch (NoCurrentCaseException ex) {\r\n        logger.log(Level.SEVERE, \"Exception while getting open case.\", ex);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.AbstractSqlEamDb.getCountArtifactInstancesByTypeValue",
	"Comment": "retrieves number of artifact instances in the database that areassociated with the artifacttype and artifactvalue of the given artifact.",
	"Method": "Long getCountArtifactInstancesByTypeValue(CorrelationAttributeInstance.Type aType,String value){\r\n    String normalizedValue = CorrelationAttributeNormalizer.normalize(aType, value);\r\n    Connection conn = connect();\r\n    Long instanceCount = 0L;\r\n    PreparedStatement preparedStatement = null;\r\n    ResultSet resultSet = null;\r\n    String tableName = EamDbUtil.correlationTypeToInstanceTableName(aType);\r\n    String sql = \"SELECT count(*) FROM \" + tableName + \" WHERE value=?\";\r\n    try {\r\n        preparedStatement = conn.prepareStatement(sql);\r\n        preparedStatement.setString(1, normalizedValue);\r\n        resultSet = preparedStatement.executeQuery();\r\n        resultSet.next();\r\n        instanceCount = resultSet.getLong(1);\r\n    } catch (SQLException ex) {\r\n        throw new EamDbException(\"Error getting count of artifact instances by artifactType and artifactValue.\", ex);\r\n    } finally {\r\n        EamDbUtil.closeStatement(preparedStatement);\r\n        EamDbUtil.closeResultSet(resultSet);\r\n        EamDbUtil.closeConnection(conn);\r\n    }\r\n    return instanceCount;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.contentviewer.DataContentViewerOtherCases.addOrUpdateNodeData",
	"Comment": "adds the file to the nodedatamap map if it does not already exist",
	"Method": "void addOrUpdateNodeData(Case autopsyCase,Map<UniquePathKey, OtherOccurrenceNodeInstanceData> nodeDataMap,AbstractFile newFile){\r\n    OtherOccurrenceNodeInstanceData newNode = new OtherOccurrenceNodeInstanceData(newFile, autopsyCase);\r\n    if (newNode.getKnown() != TskData.FileKnown.BAD) {\r\n        List<ContentTag> fileMatchTags = autopsyCase.getServices().getTagsManager().getContentTagsByContent(newFile);\r\n        for (ContentTag tag : fileMatchTags) {\r\n            TskData.FileKnown tagKnownStatus = tag.getName().getKnownStatus();\r\n            if (tagKnownStatus.equals(TskData.FileKnown.BAD)) {\r\n                newNode.updateKnown(TskData.FileKnown.BAD);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    UniquePathKey uniquePathKey = new UniquePathKey(newNode);\r\n    if (nodeDataMap.containsKey(uniquePathKey)) {\r\n        if (newNode.getKnown() == TskData.FileKnown.BAD) {\r\n            OtherOccurrenceNodeInstanceData prevInstance = nodeDataMap.get(uniquePathKey);\r\n            prevInstance.updateKnown(newNode.getKnown());\r\n        }\r\n    } else {\r\n        nodeDataMap.put(uniquePathKey, newNode);\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.db.EventsRepository.getCombinedEvents",
	"Comment": "get a representation of all the events, within the given time range, thatpass the given filter, grouped by time and description such that filesystem events for the same file, with the same timestamp, are combinedtogether.",
	"Method": "List<CombinedEvent> getCombinedEvents(Interval timeRange,RootFilter filter){\r\n    return eventDB.getCombinedEvents(timeRange, filter);\r\n}"
}, {
	"Path": "com.mcxiaoke.next.ui.internal.AdapterWrapper.getItemId",
	"Comment": "get the row id associated with the specified positionin the list.",
	"Method": "long getItemId(int position){\r\n    return (wrapped.getItemId(position));\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.stix.EvalFileObj.processULongObject",
	"Comment": "return the sql clause for an unsigned long object. splits into fields andcall the more generic version of the function.",
	"Method": "String processULongObject(UnsignedLongObjectPropertyType longObj,String fieldName){\r\n    return processNumericFields(longObj.getValue().toString(), longObj.getCondition(), longObj.getApplyCondition(), fieldName);\r\n}"
}, {
	"Path": "com.aliyun.oss.ClientConfiguration.setDefaultHeaders",
	"Comment": "sets the default http headers. all these headers would be automaticallyadded in every request. and if a header is also specified in the request,the default one will be overwritten.",
	"Method": "void setDefaultHeaders(Map<String, String> defaultHeaders){\r\n    this.defaultHeaders = defaultHeaders;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.centralrepository.datamodel.EamArtifactUtil.addCorrelationAttributeToList",
	"Comment": "add a correlationattributeinstance of the specified type to the provided list if the artifactforinstance has an attribute of the given type with a non empty value.",
	"Method": "void addCorrelationAttributeToList(List<CorrelationAttributeInstance> eamArtifacts,BlackboardArtifact artifact,ATTRIBUTE_TYPE bbAttributeType,int typeId){\r\n    BlackboardAttribute attribute = artifact.getAttribute(new BlackboardAttribute.Type(bbAttributeType));\r\n    if (attribute != null) {\r\n        String value = attribute.getValueString();\r\n        if ((null != value) && (value.isEmpty() == false)) {\r\n            eamArtifacts.add(makeCorrelationAttributeInstanceUsingTypeValue(artifact, EamDb.getInstance().getCorrelationTypeById(typeId), value));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.filetypeid.FileTypeIdGlobalSettingsPanel.addTypeListSelectionListener",
	"Comment": "adds a listener to the types list component so that the components in thefile type details section of the panel can be populated and cleared basedon the selection in the list.",
	"Method": "void addTypeListSelectionListener(){\r\n    typesList.addListSelectionListener(new ListSelectionListener() {\r\n        @Override\r\n        public void valueChanged(ListSelectionEvent e) {\r\n            if (e.getValueIsAdjusting() == false) {\r\n                if (typesList.getSelectedIndex() == -1) {\r\n                    clearTypeDetailsComponents();\r\n                } else {\r\n                    populateTypeDetailsComponents();\r\n                }\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.filetypeid.FileTypeIdGlobalSettingsPanel.addTypeListSelectionListener",
	"Comment": "adds a listener to the types list component so that the components in thefile type details section of the panel can be populated and cleared basedon the selection in the list.",
	"Method": "void addTypeListSelectionListener(){\r\n    if (e.getValueIsAdjusting() == false) {\r\n        if (typesList.getSelectedIndex() == -1) {\r\n            clearTypeDetailsComponents();\r\n        } else {\r\n            populateTypeDetailsComponents();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.corecomponents.MultiUserSettingsPanel.valid",
	"Comment": "validates that the form is filled out correctly for our usage.",
	"Method": "boolean valid(){\r\n    tbOops.setText(\"\");\r\n    if (cbEnableMultiUser.isSelected()) {\r\n        return checkFieldsAndEnableButtons() && databaseSettingsAreValid() && indexingServerSettingsAreValid() && messageServiceSettingsAreValid();\r\n    } else {\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.timeline.OpenTimelineAction.showArtifactInTimeline",
	"Comment": "open the timeline window with the given artifact selected in listview.the how much time to show around it.",
	"Method": "void showArtifactInTimeline(BlackboardArtifact artifact){\r\n    showTimeline(null, artifact);\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.modules.interestingitems.FilesSet.ingoresUnallocatedSpace",
	"Comment": "returns whether or not this set of rules will process unallocated space.",
	"Method": "boolean ingoresUnallocatedSpace(){\r\n    return this.ignoreUnallocatedSpace;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.core.RuntimeProperties.isRunningInTarget",
	"Comment": "gets a flag indicating whether or not the application is running in a target system",
	"Method": "boolean isRunningInTarget(){\r\n    return runningInTarget;\r\n}"
}, {
	"Path": "org.sleuthkit.autopsy.casemodule.services.TagNameDefinition.compareTo",
	"Comment": "compares this tag name definition with the specified tag name definitionfor order.",
	"Method": "int compareTo(TagNameDefinition other){\r\n    return this.getDisplayName().toLowerCase().compareTo(other.getDisplayName().toLowerCase());\r\n}"
}, {
	"Path": "com.google.example.games.tbmpskeleton.SkeletonActivity.rematch",
	"Comment": "if you choose to rematch, then call it and wait for a response.",
	"Method": "void rematch(){\r\n    showSpinner();\r\n    mTurnBasedMultiplayerClient.rematch(mMatch.getMatchId()).addOnSuccessListener(new OnSuccessListener<TurnBasedMatch>() {\r\n        @Override\r\n        public void onSuccess(TurnBasedMatch turnBasedMatch) {\r\n            onInitiateMatch(turnBasedMatch);\r\n        }\r\n    }).addOnFailureListener(createFailureListener(\"There was a problem starting a rematch!\"));\r\n    mMatch = null;\r\n    isDoingTurn = false;\r\n}"
}, {
	"Path": "com.google.example.games.tbmpskeleton.SkeletonActivity.rematch",
	"Comment": "if you choose to rematch, then call it and wait for a response.",
	"Method": "void rematch(){\r\n    onInitiateMatch(turnBasedMatch);\r\n}"
}]