[{
	"Path": "org.bouncycastle.cms.RecipientInformation.getKeyEncryptionAlgorithm",
	"Comment": "return the key encryption algorithm details for the key in this recipient.",
	"Method": "AlgorithmIdentifier getKeyEncryptionAlgorithm(){\r\n    return keyEncAlg;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.DERPrintableString.isPrintableString",
	"Comment": "return true if the passed in string can be represented withoutloss as a printablestring, false otherwise.",
	"Method": "boolean isPrintableString(String str){\r\n    for (int i = str.length() - 1; i >= 0; i--) {\r\n        char ch = str.charAt(i);\r\n        if (ch > 0x007f) {\r\n            return false;\r\n        }\r\n        if ('a' <= ch && ch <= 'z') {\r\n            continue;\r\n        }\r\n        if ('A' <= ch && ch <= 'Z') {\r\n            continue;\r\n        }\r\n        if ('0' <= ch && ch <= '9') {\r\n            continue;\r\n        }\r\n        switch(ch) {\r\n            case ' ':\r\n            case '\\'':\r\n            case '(':\r\n            case ')':\r\n            case '+':\r\n            case '-':\r\n            case '.':\r\n            case ':':\r\n            case '=':\r\n            case '?':\r\n            case '/':\r\n            case ',':\r\n                continue;\r\n        }\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.ec.CustomNamedCurves.getNames",
	"Comment": "returns an enumeration containing the name strings for curves contained in this structure.",
	"Method": "Enumeration getNames(){\r\n    return names.elements();\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.gmss.Treehash.getStatByte",
	"Comment": "returns the status byte array used by the gmssprivatekeyasn.1 class",
	"Method": "byte[][] getStatByte(){\r\n    byte[][] statByte = new byte[3 + tailLength][this.messDigestTree.getDigestSize()];\r\n    statByte[0] = firstNode;\r\n    statByte[1] = seedActive;\r\n    statByte[2] = seedNext;\r\n    for (int i = 0; i < tailLength; i++) {\r\n        statByte[3 + i] = (byte[]) tailStack.elementAt(i);\r\n    }\r\n    return statByte;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.selector.X509AttributeCertificateHolderSelector.getTargetGroups",
	"Comment": "gets the target groups. the collection consists of generalname objects.the returned collection is immutable.",
	"Method": "Collection getTargetGroups(){\r\n    return targetGroups;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.x509.PKIXNameConstraintValidator.checkExcluded",
	"Comment": "check if the given generalname is contained in the excluded set.",
	"Method": "void checkExcluded(GeneralName name){\r\n    switch(name.getTagNo()) {\r\n        case GeneralName.otherName:\r\n            checkExcludedOtherName(excludedSubtreesOtherName, OtherName.getInstance(name.getName()));\r\n            break;\r\n        case GeneralName.rfc822Name:\r\n            checkExcludedEmail(excludedSubtreesEmail, extractNameAsString(name));\r\n            break;\r\n        case GeneralName.dNSName:\r\n            checkExcludedDNS(excludedSubtreesDNS, DERIA5String.getInstance(name.getName()).getString());\r\n            break;\r\n        case GeneralName.directoryName:\r\n            checkExcludedDN(X500Name.getInstance(name.getName()));\r\n            break;\r\n        case GeneralName.uniformResourceIdentifier:\r\n            checkExcludedURI(excludedSubtreesURI, DERIA5String.getInstance(name.getName()).getString());\r\n            break;\r\n        case GeneralName.iPAddress:\r\n            byte[] ip = ASN1OctetString.getInstance(name.getName()).getOctets();\r\n            checkExcludedIP(excludedSubtreesIP, ip);\r\n            break;\r\n        default:\r\n            throw new IllegalStateException(\"Unknown tag encountered: \" + name.getTagNo());\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.generators.PKCS12ParametersGenerator.generateDerivedMacParameters",
	"Comment": "generate a key parameter for use with a mac derived from the password,salt, and iteration count we are currently initialised with.",
	"Method": "CipherParameters generateDerivedMacParameters(int keySize){\r\n    keySize = keySize / 8;\r\n    byte[] dKey = generateDerivedKey(MAC_MATERIAL, keySize);\r\n    return new KeyParameter(dKey, 0, keySize);\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPSecretKeyRing.getKeysWithSignaturesBy",
	"Comment": "return any keys carrying a signature issued by the key represented by keyid.",
	"Method": "Iterator getKeysWithSignaturesBy(long keyID){\r\n    List keysWithSigs = new ArrayList();\r\n    for (Iterator keyIt = getPublicKeys(); keyIt.hasNext(); ) {\r\n        PGPPublicKey k = (PGPPublicKey) keyIt.next();\r\n        Iterator sigIt = k.getSignaturesForKeyID(keyID);\r\n        if (sigIt.hasNext()) {\r\n            keysWithSigs.add(k);\r\n        }\r\n    }\r\n    return keysWithSigs.iterator();\r\n}"
}, {
	"Path": "org.bouncycastle.cert.cmp.GeneralPKIMessage.hasProtection",
	"Comment": "return true if this message has protection bits on it. a return value of trueindicates the message can be used to construct a protectedpkimessage.",
	"Method": "boolean hasProtection(){\r\n    return pkiMessage.getHeader().getProtectionAlg() != null;\r\n}"
}, {
	"Path": "org.bouncycastle.mail.smime.SMIMEUtil.createIssuerAndSerialNumberFor",
	"Comment": "return a cms issuerandserialnumber structure for the passed in x.509 certificate.",
	"Method": "IssuerAndSerialNumber createIssuerAndSerialNumberFor(X509Certificate cert){\r\n    try {\r\n        return new IssuerAndSerialNumber(new JcaX509CertificateHolder(cert).getIssuer(), cert.getSerialNumber());\r\n    } catch (Exception e) {\r\n        throw new CertificateParsingException(\"exception extracting issuer and serial number: \" + e);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.cms.PasswordRecipientInformation.getKeyDerivationAlgOID",
	"Comment": "return the object identifier for the key derivation algorithm, or nullif there is none present.",
	"Method": "String getKeyDerivationAlgOID(){\r\n    if (info.getKeyDerivationAlgorithm() != null) {\r\n        return info.getKeyDerivationAlgorithm().getAlgorithm().getId();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.cms.PasswordRecipientInfo.getInstance",
	"Comment": "return a passwordrecipientinfo object from a tagged object.",
	"Method": "PasswordRecipientInfo getInstance(ASN1TaggedObject obj,boolean explicit,PasswordRecipientInfo getInstance,Object obj){\r\n    if (obj instanceof PasswordRecipientInfo) {\r\n        return (PasswordRecipientInfo) obj;\r\n    }\r\n    if (obj != null) {\r\n        return new PasswordRecipientInfo(ASN1Sequence.getInstance(obj));\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.io.CipherOutputStream.close",
	"Comment": "closes this output stream and releases any system resources associated with this stream.this method invokes the dofinal method of the encapsulated cipher object, whichcauses any bytes buffered by the encapsulated cipher to be processed. the result is writtenout by calling the flush method of this output stream.this method resets the encapsulated cipher object to its initial state and calls theclose method of the underlying output stream.",
	"Method": "void close(){\r\n    IOException error = null;\r\n    try {\r\n        byte[] outData = cipher.doFinal();\r\n        if (outData != null) {\r\n            out.write(outData);\r\n        }\r\n    } catch (GeneralSecurityException e) {\r\n        error = new InvalidCipherTextIOException(\"Error during cipher finalisation\", e);\r\n    } catch (Exception e) {\r\n        error = new IOException(\"Error closing stream: \" + e);\r\n    }\r\n    try {\r\n        flush();\r\n        out.close();\r\n    } catch (IOException e) {\r\n        if (error == null) {\r\n            error = e;\r\n        }\r\n    }\r\n    if (error != null) {\r\n        throw error;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSEnvelopedData.getContentEncryptionAlgorithm",
	"Comment": "return the content encryption algorithm details for the data in this object.",
	"Method": "AlgorithmIdentifier getContentEncryptionAlgorithm(){\r\n    return encAlg;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.ntru.polynomial.ModularResultant.combineRho",
	"Comment": "calculates a rho modulo m1m2 fromtwo resultants whose rhos are modulo m1 and m2.res is set to null.",
	"Method": "ModularResultant combineRho(ModularResultant modRes1,ModularResultant modRes2){\r\n    BigInteger mod1 = modRes1.modulus;\r\n    BigInteger mod2 = modRes2.modulus;\r\n    BigInteger prod = mod1.multiply(mod2);\r\n    BigIntEuclidean er = BigIntEuclidean.calculate(mod2, mod1);\r\n    BigIntPolynomial rho1 = (BigIntPolynomial) modRes1.rho.clone();\r\n    rho1.mult(er.x.multiply(mod2));\r\n    BigIntPolynomial rho2 = (BigIntPolynomial) modRes2.rho.clone();\r\n    rho2.mult(er.y.multiply(mod1));\r\n    rho1.add(rho2);\r\n    rho1.mod(prod);\r\n    return new ModularResultant(rho1, null, prod);\r\n}"
}, {
	"Path": "org.bouncycastle.pkcs.PKCS10CertificationRequestBuilder.setLeaveOffEmptyAttributes",
	"Comment": "the attributes field in pkcs10 should encoded to an empty tagged set if there areno attributes. some cas will reject requests with the attribute field present.",
	"Method": "PKCS10CertificationRequestBuilder setLeaveOffEmptyAttributes(boolean leaveOffEmpty){\r\n    this.leaveOffEmpty = leaveOffEmpty;\r\n    return this;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.provider.test.CipherStreamTest2.testTamperedRead",
	"Comment": "test tampering of ciphertext followed by read from decrypting cipherinputstream",
	"Method": "void testTamperedRead(String name,Key key,boolean authenticated,boolean useBc){\r\n    Cipher encrypt = Cipher.getInstance(name, \"BC\");\r\n    Cipher decrypt = Cipher.getInstance(name, \"BC\");\r\n    encrypt.init(Cipher.ENCRYPT_MODE, key);\r\n    if (encrypt.getIV() != null) {\r\n        decrypt.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(encrypt.getIV()));\r\n    } else {\r\n        decrypt.init(Cipher.DECRYPT_MODE, key);\r\n    }\r\n    byte[] ciphertext = encrypt.doFinal(new byte[streamSize]);\r\n    ciphertext[0] += 1;\r\n    InputStream input = createInputStream(ciphertext, decrypt, useBc);\r\n    try {\r\n        while (input.read() >= 0) {\r\n        }\r\n        fail(\"Expected invalid ciphertext after tamper and read : \" + name, authenticated, useBc);\r\n    } catch (InvalidCipherTextIOException e) {\r\n    } catch (IOException e) {\r\n    }\r\n    try {\r\n        input.close();\r\n    } catch (Exception e) {\r\n        fail(\"Unexpected exception : \" + name, e, authenticated, useBc);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.tsp.TimeStampRequest.getCriticalExtensionOIDs",
	"Comment": "returns a set of asn1objectidentifiers giving the critical extensions.",
	"Method": "Set getCriticalExtensionOIDs(){\r\n    if (extensions == null) {\r\n        return EMPTY_SET;\r\n    }\r\n    return Collections.unmodifiableSet(new HashSet(Arrays.asList(extensions.getCriticalExtensionOIDs())));\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2Vector.extractRightVector",
	"Comment": "return a new vector consisting of the last k elements of thisvector.",
	"Method": "GF2Vector extractRightVector(int k){\r\n    if (k > length) {\r\n        throw new ArithmeticException(\"invalid length\");\r\n    }\r\n    if (k == length) {\r\n        return new GF2Vector(this);\r\n    }\r\n    GF2Vector result = new GF2Vector(k);\r\n    int q = (length - k) >> 5;\r\n    int r = (length - k) & 0x1f;\r\n    int length = (k + 31) >> 5;\r\n    int ind = q;\r\n    if (r != 0) {\r\n        for (int i = 0; i < length - 1; i++) {\r\n            result.v[i] = (v[ind++] >>> r) | (v[ind] << (32 - r));\r\n        }\r\n        result.v[length - 1] = v[ind++] >>> r;\r\n        if (ind < v.length) {\r\n            result.v[length - 1] |= v[ind] << (32 - r);\r\n        }\r\n    } else {\r\n        System.arraycopy(v, q, result.v, 0, length);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.bouncycastle.x509.ExtendedPKIXBuilderParameters.getInstance",
	"Comment": "returns an instance of extendedpkixparameters which can besafely casted to extendedpkixbuilderparameters.this method can be used to get a copy from otherpkixbuilderparameters, pkixparameters,and extendedpkixparameters instances.",
	"Method": "ExtendedPKIXParameters getInstance(PKIXParameters pkixParams){\r\n    ExtendedPKIXBuilderParameters params;\r\n    try {\r\n        params = new ExtendedPKIXBuilderParameters(pkixParams.getTrustAnchors(), X509CertStoreSelector.getInstance((X509CertSelector) pkixParams.getTargetCertConstraints()));\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e.getMessage());\r\n    }\r\n    params.setParams(pkixParams);\r\n    return params;\r\n}"
}, {
	"Path": "java.security.cert.CertUtil.parseX509Name",
	"Comment": "parse the given x.509 name into der encoded byte array representation.",
	"Method": "byte[] parseX509Name(String data){\r\n    ByteArrayOutputStream outStream = new ByteArrayOutputStream();\r\n    DEROutputStream derOutStream = new DEROutputStream(outStream);\r\n    derOutStream.writeObject(new X509Name(trimX509Name(data)));\r\n    derOutStream.close();\r\n    return outStream.toByteArray();\r\n}"
}, {
	"Path": "org.bouncycastle.pkix.PKIXIdentity.getCertificate",
	"Comment": "return the certificate associated with the private key info.",
	"Method": "X509CertificateHolder getCertificate(){\r\n    return certificateHolders[0];\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.gm.GMNamedCurves.getOID",
	"Comment": "return the object identifier signified by the passed in name. nullif there is no object identifier associated with name.",
	"Method": "ASN1ObjectIdentifier getOID(String name){\r\n    return (ASN1ObjectIdentifier) objIds.get(Strings.toLowerCase(name));\r\n}"
}, {
	"Path": "java.security.cert.PolicyQualifierInfo.getEncoded",
	"Comment": "returns the asn.1 der encoded form of thispolicyqualifierinfo.",
	"Method": "byte[] getEncoded(){\r\n    return (byte[]) encoded.clone();\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2nPolynomial.multiply",
	"Comment": "multiplies this by b and returns the result in a newpolynomialgf2n.",
	"Method": "GF2nPolynomial multiply(GF2nPolynomial b){\r\n    int i, j;\r\n    int aDegree = size();\r\n    int bDegree = b.size();\r\n    if (aDegree != bDegree) {\r\n        throw new IllegalArgumentException(\"PolynomialGF2n.multiply: this and b must \" + \"have the same size!\");\r\n    }\r\n    GF2nPolynomial result = new GF2nPolynomial((aDegree << 1) - 1);\r\n    for (i = 0; i < size(); i++) {\r\n        for (j = 0; j < b.size(); j++) {\r\n            if (result.coeff[i + j] == null) {\r\n                result.coeff[i + j] = (GF2nElement) coeff[i].multiply(b.coeff[j]);\r\n            } else {\r\n                result.coeff[i + j] = (GF2nElement) result.coeff[i + j].add(coeff[i].multiply(b.coeff[j]));\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2nPolynomial.remainder",
	"Comment": "divides this by b and stores the remainder in a newpolynomialgf2n.",
	"Method": "GF2nPolynomial remainder(GF2nPolynomial b){\r\n    GF2nPolynomial[] result = new GF2nPolynomial[2];\r\n    result = divide(b);\r\n    return result[1];\r\n}"
}, {
	"Path": "org.bouncycastle.dvcs.DVCSRequest.getData",
	"Comment": "get data of dvcrequest.depending on type of the request it could be different subclasses of dvcrequestdata.",
	"Method": "DVCSRequestData getData(){\r\n    return data;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.AttributeCertificateHolder.getSerialNumber",
	"Comment": "return the serial number associated with the issuer attached to thisholder.",
	"Method": "BigInteger getSerialNumber(){\r\n    if (holder.getBaseCertificateID() != null) {\r\n        return holder.getBaseCertificateID().getSerial().getValue();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "java.security.cert.CertPathValidatorException.getMessage",
	"Comment": "returns the detail message for this certpathvalidatorexception.",
	"Method": "String getMessage(){\r\n    String message = super.getMessage();\r\n    if (message == null && cause == null)\r\n        return null;\r\n    StringBuffer s = new StringBuffer();\r\n    if (message != null) {\r\n        s.append(message).append('\\n');\r\n    }\r\n    if (cause != null) {\r\n        s.append(\"Cause:\\n\").append(cause.getMessage()).append('\\n');\r\n    }\r\n    return s.toString();\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPSecretKeyRing.insertSecretKey",
	"Comment": "returns a new key ring with the secret key passed in either added orreplacing an existing one with the same key id.",
	"Method": "PGPSecretKeyRing insertSecretKey(PGPSecretKeyRing secRing,PGPSecretKey secKey){\r\n    List keys = new ArrayList(secRing.keys);\r\n    boolean found = false;\r\n    boolean masterFound = false;\r\n    for (int i = 0; i != keys.size(); i++) {\r\n        PGPSecretKey key = (PGPSecretKey) keys.get(i);\r\n        if (key.getKeyID() == secKey.getKeyID()) {\r\n            found = true;\r\n            keys.set(i, secKey);\r\n        }\r\n        if (key.isMasterKey()) {\r\n            masterFound = true;\r\n        }\r\n    }\r\n    if (!found) {\r\n        if (secKey.isMasterKey()) {\r\n            if (masterFound) {\r\n                throw new IllegalArgumentException(\"cannot add a master key to a ring that already has one\");\r\n            }\r\n            keys.add(0, secKey);\r\n        } else {\r\n            keys.add(secKey);\r\n        }\r\n    }\r\n    return new PGPSecretKeyRing(keys, secRing.extraPubKeys);\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2Polynomial.add",
	"Comment": "adds two gf2polynomials, this and b, and returns theresult. this and b can be of different size.",
	"Method": "GF2Polynomial add(GF2Polynomial b){\r\n    return xor(b);\r\n}"
}, {
	"Path": "org.bouncycastle.x509.X509V2CRLGenerator.generate",
	"Comment": "generate an x509 crl, based on the current issuer and subject,using the passed in provider for the signing.",
	"Method": "X509CRL generate(PrivateKey key,X509CRL generate,PrivateKey key,SecureRandom random,X509CRL generate,PrivateKey key,String provider,X509CRL generate,PrivateKey key,String provider,SecureRandom random){\r\n    TBSCertList tbsCrl = generateCertList();\r\n    byte[] signature;\r\n    try {\r\n        signature = X509Util.calculateSignature(sigOID, signatureAlgorithm, provider, key, random, tbsCrl);\r\n    } catch (IOException e) {\r\n        throw new ExtCRLException(\"cannot generate CRL encoding\", e);\r\n    }\r\n    return generateJcaObject(tbsCrl, signature);\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.utils.MySwingUtilities2.drawStringUnderlineCharAt",
	"Comment": "draws the string at the specified location underlining the specifiedcharacter.",
	"Method": "void drawStringUnderlineCharAt(JComponent c,Graphics g,String text,int underlinedIndex,int x,int y){\r\n    invokeSwingUtilities2StaticMethod(\"drawStringUnderlineCharAt\", new Class[] { JComponent.class, Graphics.class, String.class, int.class, int.class, int.class }, new Object[] { c, g, text, underlinedIndex, x, y });\r\n}"
}, {
	"Path": "org.bouncycastle.bcpg.ArmoredOutputStream.encode",
	"Comment": "encode the input data producing a base 64 encoded byte array.",
	"Method": "void encode(OutputStream out,int[] data,int len){\r\n    int d1, d2, d3;\r\n    switch(len) {\r\n        case 0:\r\n            break;\r\n        case 1:\r\n            d1 = data[0];\r\n            out.write(encodingTable[(d1 >>> 2) & 0x3f]);\r\n            out.write(encodingTable[(d1 << 4) & 0x3f]);\r\n            out.write('=');\r\n            out.write('=');\r\n            break;\r\n        case 2:\r\n            d1 = data[0];\r\n            d2 = data[1];\r\n            out.write(encodingTable[(d1 >>> 2) & 0x3f]);\r\n            out.write(encodingTable[((d1 << 4) | (d2 >>> 4)) & 0x3f]);\r\n            out.write(encodingTable[(d2 << 2) & 0x3f]);\r\n            out.write('=');\r\n            break;\r\n        case 3:\r\n            d1 = data[0];\r\n            d2 = data[1];\r\n            d3 = data[2];\r\n            out.write(encodingTable[(d1 >>> 2) & 0x3f]);\r\n            out.write(encodingTable[((d1 << 4) | (d2 >>> 4)) & 0x3f]);\r\n            out.write(encodingTable[((d2 << 2) | (d3 >>> 6)) & 0x3f]);\r\n            out.write(encodingTable[d3 & 0x3f]);\r\n            break;\r\n        default:\r\n            throw new IOException(\"unknown length in encode\");\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2nPolynomial.quotient",
	"Comment": "divides this by b and stores the quotient in a newpolynomialgf2n.",
	"Method": "GF2nPolynomial quotient(GF2nPolynomial b){\r\n    GF2nPolynomial[] result = new GF2nPolynomial[2];\r\n    result = divide(b);\r\n    return result[0];\r\n}"
}, {
	"Path": "org.bouncycastle.cert.cmp.ProtectedPKIMessageBuilder.setSenderKID",
	"Comment": "set the sender key identifier for the key used to protect the new message.",
	"Method": "ProtectedPKIMessageBuilder setSenderKID(byte[] kid){\r\n    hdrBuilder.setSenderKID(kid);\r\n    return this;\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.BCFKSStoreParameter.getStorePBKDFConfig",
	"Comment": "return the pbkdf used for generating the hmac and store encryption keys.",
	"Method": "PBKDFConfig getStorePBKDFConfig(){\r\n    return storeConfig;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher.getUpdateOutputSize",
	"Comment": "return the size of the output buffer required for an update an input of len bytes.",
	"Method": "int getUpdateOutputSize(int len){\r\n    int total = len + bufOff;\r\n    int leftOver = total % buf.length;\r\n    if (leftOver == 0) {\r\n        return Math.max(0, total - buf.length);\r\n    }\r\n    return total - leftOver;\r\n}"
}, {
	"Path": "org.bouncycastle.mime.test.Base64TransferEncodingTest.testDecodeWellFormed",
	"Comment": "test the decoding of some base64 arranged in lines of64 byte base 64 encoded rows terminated crlf.",
	"Method": "void testDecodeWellFormed(){\r\n    byte[][] original = new byte[4][48];\r\n    ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    for (int i = 0; i != original.length; i++) {\r\n        byte[] row = original[i];\r\n        random.nextBytes(row);\r\n        bos.write(Base64.encode(row));\r\n        bos.write('\\r');\r\n        bos.write('\\n');\r\n    }\r\n    verifyDecode(original, bos);\r\n}"
}, {
	"Path": "org.bouncycastle.jce.provider.RFC3281CertPathUtilities.checkCRL",
	"Comment": "checks a distribution point for revocation information for thecertificate attrcert.",
	"Method": "void checkCRL(DistributionPoint dp,X509AttributeCertificate attrCert,PKIXExtendedParameters paramsPKIX,Date validDate,X509Certificate issuerCert,CertStatus certStatus,ReasonsMask reasonMask,List certPathCerts,JcaJceHelper helper){\r\n    if (attrCert.getExtensionValue(X509Extensions.NoRevAvail.getId()) != null) {\r\n        return;\r\n    }\r\n    Date currentDate = new Date(System.currentTimeMillis());\r\n    if (validDate.getTime() > currentDate.getTime()) {\r\n        throw new AnnotatedException(\"Validation time is in future.\");\r\n    }\r\n    Set crls = CertPathValidatorUtilities.getCompleteCRLs(dp, attrCert, currentDate, paramsPKIX);\r\n    boolean validCrlFound = false;\r\n    AnnotatedException lastException = null;\r\n    Iterator crl_iter = crls.iterator();\r\n    while (crl_iter.hasNext() && certStatus.getCertStatus() == CertStatus.UNREVOKED && !reasonMask.isAllReasons()) {\r\n        try {\r\n            X509CRL crl = (X509CRL) crl_iter.next();\r\n            ReasonsMask interimReasonsMask = RFC3280CertPathUtilities.processCRLD(crl, dp);\r\n            if (!interimReasonsMask.hasNewReasons(reasonMask)) {\r\n                continue;\r\n            }\r\n            Set keys = RFC3280CertPathUtilities.processCRLF(crl, attrCert, null, null, paramsPKIX, certPathCerts, helper);\r\n            PublicKey key = RFC3280CertPathUtilities.processCRLG(crl, keys);\r\n            X509CRL deltaCRL = null;\r\n            if (paramsPKIX.isUseDeltasEnabled()) {\r\n                Set deltaCRLs = CertPathValidatorUtilities.getDeltaCRLs(currentDate, crl, paramsPKIX.getCertStores(), paramsPKIX.getCRLStores());\r\n                deltaCRL = RFC3280CertPathUtilities.processCRLH(deltaCRLs, key);\r\n            }\r\n            if (paramsPKIX.getValidityModel() != PKIXExtendedParameters.CHAIN_VALIDITY_MODEL) {\r\n                if (attrCert.getNotAfter().getTime() < crl.getThisUpdate().getTime()) {\r\n                    throw new AnnotatedException(\"No valid CRL for current time found.\");\r\n                }\r\n            }\r\n            RFC3280CertPathUtilities.processCRLB1(dp, attrCert, crl);\r\n            RFC3280CertPathUtilities.processCRLB2(dp, attrCert, crl);\r\n            RFC3280CertPathUtilities.processCRLC(deltaCRL, crl, paramsPKIX);\r\n            RFC3280CertPathUtilities.processCRLI(validDate, deltaCRL, attrCert, certStatus, paramsPKIX);\r\n            RFC3280CertPathUtilities.processCRLJ(validDate, crl, attrCert, certStatus);\r\n            if (certStatus.getCertStatus() == CRLReason.removeFromCRL) {\r\n                certStatus.setCertStatus(CertStatus.UNREVOKED);\r\n            }\r\n            reasonMask.addReasons(interimReasonsMask);\r\n            validCrlFound = true;\r\n        } catch (AnnotatedException e) {\r\n            lastException = e;\r\n        }\r\n    }\r\n    if (!validCrlFound) {\r\n        throw lastException;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.jce.provider.X509CRLObject.hasUnsupportedCriticalExtension",
	"Comment": "will return true if any extensions are present and markedas critical as we currently dont handle any extensions!",
	"Method": "boolean hasUnsupportedCriticalExtension(){\r\n    Set extns = getCriticalExtensionOIDs();\r\n    if (extns == null) {\r\n        return false;\r\n    }\r\n    extns.remove(RFC3280CertPathUtilities.ISSUING_DISTRIBUTION_POINT);\r\n    extns.remove(RFC3280CertPathUtilities.DELTA_CRL_INDICATOR);\r\n    return !extns.isEmpty();\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.x9.X962NamedCurves.getOID",
	"Comment": "return the object identifier signified by the passed in name. nullif there is no object identifier associated with name.",
	"Method": "ASN1ObjectIdentifier getOID(String name){\r\n    return (ASN1ObjectIdentifier) objIds.get(Strings.toLowerCase(name));\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPSecretKey.replacePublicKey",
	"Comment": "replace the passed the public key on the passed in secret key.",
	"Method": "PGPSecretKey replacePublicKey(PGPSecretKey secretKey,PGPPublicKey publicKey){\r\n    if (publicKey.getKeyID() != secretKey.getKeyID()) {\r\n        throw new IllegalArgumentException(\"keyIDs do not match\");\r\n    }\r\n    return new PGPSecretKey(secretKey.secret, publicKey);\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.gmss.GMSSLeaf.toString",
	"Comment": "returns a string representation of the main part of this element",
	"Method": "String toString(){\r\n    String out = \"\";\r\n    for (int i = 0; i < 4; i++) {\r\n        out = out + this.getStatInt()[i] + \" \";\r\n    }\r\n    out = out + \" \" + this.mdsize + \" \" + this.keysize + \" \" + this.two_power_w + \" \";\r\n    byte[][] temp = this.getStatByte();\r\n    for (int i = 0; i < 4; i++) {\r\n        if (temp[i] != null) {\r\n            out = out + new String(Hex.encode(temp[i])) + \" \";\r\n        } else {\r\n            out = out + \"null \";\r\n        }\r\n    }\r\n    return out;\r\n}"
}, {
	"Path": "org.bouncycastle.x509.ExtendedPKIXParameters.setProhibitedACAttributes",
	"Comment": "sets the attribute certificates which are not allowed.the set must contain strings with theoids.the set is cloned.",
	"Method": "void setProhibitedACAttributes(Set prohibitedACAttributes){\r\n    if (prohibitedACAttributes == null) {\r\n        this.prohibitedACAttributes.clear();\r\n        return;\r\n    }\r\n    for (Iterator it = prohibitedACAttributes.iterator(); it.hasNext(); ) {\r\n        if (!(it.next() instanceof String)) {\r\n            throw new ClassCastException(\"All elements of set must be \" + \"of type String.\");\r\n        }\r\n    }\r\n    this.prohibitedACAttributes.clear();\r\n    this.prohibitedACAttributes.addAll(prohibitedACAttributes);\r\n}"
}, {
	"Path": "org.bouncycastle.tsp.cms.CMSTimeStampedDataParser.initialiseMessageImprintDigestCalculator",
	"Comment": "initialise the passed in calculator with the metadata for this message, if it isrequired as part of the initial message imprint calculation.",
	"Method": "void initialiseMessageImprintDigestCalculator(DigestCalculator calculator){\r\n    util.initialiseMessageImprintDigestCalculator(calculator);\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.ch19_list.BEListUI.installDefaults",
	"Comment": "initialize jlist properties, e.g. font, foreground, and background,\tand add the cellrendererpane.the font, foreground, and background\tproperties are only set if their current value is either null\tor a uiresource, other properties are set if the current\tvalue is null.",
	"Method": "void installDefaults(){\r\n    super.installDefaults();\r\n    list.setFixedCellHeight(27);\r\n}"
}, {
	"Path": "org.bouncycastle.openssl.jcajce.JceOpenSSLPKCS8EncryptorBuilder.setPRF",
	"Comment": "set the prf to use for key generation. by default this is hmacsha1.",
	"Method": "JceOpenSSLPKCS8EncryptorBuilder setPRF(AlgorithmIdentifier prf){\r\n    this.prf = prf;\r\n    return this;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.X509CertificateHolder.getSubjectPublicKeyInfo",
	"Comment": "return the subjectpublickeyinfo describing the public key this certificate is carrying.",
	"Method": "SubjectPublicKeyInfo getSubjectPublicKeyInfo(){\r\n    return x509Certificate.getSubjectPublicKeyInfo();\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.util.MessageDigestUtils.getDigestName",
	"Comment": "attempt to find a standard jca name for the digest represented by the passed in oid.",
	"Method": "String getDigestName(ASN1ObjectIdentifier digestAlgOID){\r\n    String name = (String) digestOidMap.get(digestAlgOID);\r\n    if (name != null) {\r\n        return name;\r\n    }\r\n    return digestAlgOID.getId();\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.ntru.polynomial.BigDecimalPolynomial.add",
	"Comment": "adds another polynomial which can have a different number of coefficients.",
	"Method": "void add(BigDecimalPolynomial b){\r\n    if (b.coeffs.length > coeffs.length) {\r\n        int N = coeffs.length;\r\n        coeffs = copyOf(coeffs, b.coeffs.length);\r\n        for (int i = N; i < coeffs.length; i++) {\r\n            coeffs[i] = ZERO;\r\n        }\r\n    }\r\n    for (int i = 0; i < b.coeffs.length; i++) {\r\n        coeffs[i] = coeffs[i].add(b.coeffs[i]);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.jce.provider.RFC3280CertPathUtilities.checkCRL",
	"Comment": "checks a distribution point for revocation information for thecertificate cert.",
	"Method": "void checkCRL(DistributionPoint dp,PKIXExtendedParameters paramsPKIX,X509Certificate cert,Date validDate,X509Certificate defaultCRLSignCert,PublicKey defaultCRLSignKey,CertStatus certStatus,ReasonsMask reasonMask,List certPathCerts,JcaJceHelper helper){\r\n    Date currentDate = new Date(System.currentTimeMillis());\r\n    if (validDate.getTime() > currentDate.getTime()) {\r\n        throw new AnnotatedException(\"Validation time is in future.\");\r\n    }\r\n    Set crls = CertPathValidatorUtilities.getCompleteCRLs(dp, cert, currentDate, paramsPKIX);\r\n    boolean validCrlFound = false;\r\n    AnnotatedException lastException = null;\r\n    Iterator crl_iter = crls.iterator();\r\n    while (crl_iter.hasNext() && certStatus.getCertStatus() == CertStatus.UNREVOKED && !reasonMask.isAllReasons()) {\r\n        try {\r\n            X509CRL crl = (X509CRL) crl_iter.next();\r\n            ReasonsMask interimReasonsMask = RFC3280CertPathUtilities.processCRLD(crl, dp);\r\n            if (!interimReasonsMask.hasNewReasons(reasonMask)) {\r\n                continue;\r\n            }\r\n            Set keys = RFC3280CertPathUtilities.processCRLF(crl, cert, defaultCRLSignCert, defaultCRLSignKey, paramsPKIX, certPathCerts, helper);\r\n            PublicKey key = RFC3280CertPathUtilities.processCRLG(crl, keys);\r\n            X509CRL deltaCRL = null;\r\n            Date validityDate = currentDate;\r\n            if (paramsPKIX.getDate() != null) {\r\n                validityDate = paramsPKIX.getDate();\r\n            }\r\n            if (paramsPKIX.isUseDeltasEnabled()) {\r\n                Set deltaCRLs = CertPathValidatorUtilities.getDeltaCRLs(validityDate, crl, paramsPKIX.getCertStores(), paramsPKIX.getCRLStores());\r\n                deltaCRL = RFC3280CertPathUtilities.processCRLH(deltaCRLs, key);\r\n            }\r\n            if (paramsPKIX.getValidityModel() != PKIXExtendedParameters.CHAIN_VALIDITY_MODEL) {\r\n                if (cert.getNotAfter().getTime() < crl.getThisUpdate().getTime()) {\r\n                    throw new AnnotatedException(\"No valid CRL for current time found.\");\r\n                }\r\n            }\r\n            RFC3280CertPathUtilities.processCRLB1(dp, cert, crl);\r\n            RFC3280CertPathUtilities.processCRLB2(dp, cert, crl);\r\n            RFC3280CertPathUtilities.processCRLC(deltaCRL, crl, paramsPKIX);\r\n            RFC3280CertPathUtilities.processCRLI(validDate, deltaCRL, cert, certStatus, paramsPKIX);\r\n            RFC3280CertPathUtilities.processCRLJ(validDate, crl, cert, certStatus);\r\n            if (certStatus.getCertStatus() == CRLReason.removeFromCRL) {\r\n                certStatus.setCertStatus(CertStatus.UNREVOKED);\r\n            }\r\n            reasonMask.addReasons(interimReasonsMask);\r\n            Set criticalExtensions = crl.getCriticalExtensionOIDs();\r\n            if (criticalExtensions != null) {\r\n                criticalExtensions = new HashSet(criticalExtensions);\r\n                criticalExtensions.remove(Extension.issuingDistributionPoint.getId());\r\n                criticalExtensions.remove(Extension.deltaCRLIndicator.getId());\r\n                if (!criticalExtensions.isEmpty()) {\r\n                    throw new AnnotatedException(\"CRL contains unsupported critical extensions.\");\r\n                }\r\n            }\r\n            if (deltaCRL != null) {\r\n                criticalExtensions = deltaCRL.getCriticalExtensionOIDs();\r\n                if (criticalExtensions != null) {\r\n                    criticalExtensions = new HashSet(criticalExtensions);\r\n                    criticalExtensions.remove(Extension.issuingDistributionPoint.getId());\r\n                    criticalExtensions.remove(Extension.deltaCRLIndicator.getId());\r\n                    if (!criticalExtensions.isEmpty()) {\r\n                        throw new AnnotatedException(\"Delta CRL contains unsupported critical extension.\");\r\n                    }\r\n                }\r\n            }\r\n            validCrlFound = true;\r\n        } catch (AnnotatedException e) {\r\n            lastException = e;\r\n        }\r\n    }\r\n    if (!validCrlFound) {\r\n        throw lastException;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.encodings.ISO9796d1Encoding.setPadBits",
	"Comment": "set the number of bits in the next message to be treated aspad bits.",
	"Method": "void setPadBits(int padBits){\r\n    if (padBits > 7) {\r\n        throw new IllegalArgumentException(\"padBits > 7\");\r\n    }\r\n    this.padBits = padBits;\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.provider.asymmetric.x509.CertificateFactory.engineGenerateCertificate",
	"Comment": "generates a certificate object and initializes it with the dataread from the input stream instream.",
	"Method": "java.security.cert.Certificate engineGenerateCertificate(InputStream in){\r\n    if (currentStream == null) {\r\n        currentStream = in;\r\n        sData = null;\r\n        sDataObjectCount = 0;\r\n    } else if (currentStream != in) {\r\n        currentStream = in;\r\n        sData = null;\r\n        sDataObjectCount = 0;\r\n    }\r\n    try {\r\n        if (sData != null) {\r\n            if (sDataObjectCount != sData.size()) {\r\n                return getCertificate();\r\n            } else {\r\n                sData = null;\r\n                sDataObjectCount = 0;\r\n                return null;\r\n            }\r\n        }\r\n        InputStream pis;\r\n        if (in.markSupported()) {\r\n            pis = in;\r\n        } else {\r\n            pis = new ByteArrayInputStream(Streams.readAll(in));\r\n        }\r\n        pis.mark(1);\r\n        int tag = pis.read();\r\n        if (tag == -1) {\r\n            return null;\r\n        }\r\n        pis.reset();\r\n        if (tag != 0x30) {\r\n            return readPEMCertificate(pis);\r\n        } else {\r\n            return readDERCertificate(new ASN1InputStream(pis));\r\n        }\r\n    } catch (Exception e) {\r\n        throw new ExCertificateException(e);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.ntru.polynomial.IntegerPolynomial.mult2",
	"Comment": "multiplies each coefficient by a 2 and applies a modulus. does not return a new polynomial but modifies this polynomial.",
	"Method": "void mult2(int modulus){\r\n    for (int i = 0; i < coeffs.length; i++) {\r\n        coeffs[i] *= 2;\r\n        coeffs[i] %= modulus;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSSignedDataParser.getDigestAlgorithmIDs",
	"Comment": "return the digest algorithm identifiers for the signeddata object",
	"Method": "Set<AlgorithmIdentifier> getDigestAlgorithmIDs(){\r\n    return digestAlgorithms;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.X509CRLSelector.setMinCRLNumber",
	"Comment": "sets the mincrlnumber criterion. the x509crl must have acrl number extension whose value is greater than or equal to thespecified value. if null, no mincrlnumber check will bedone.",
	"Method": "void setMinCRLNumber(BigInteger minCRL){\r\n    this.minCRL = minCRL;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.selector.X509AttributeCertificateHolderSelectorBuilder.addTargetGroup",
	"Comment": "adds a target group criterion for the attribute certificate to the targetinformation extension criteria. the x509attributecertificateholdermust contain at least one of the specified target groups.each attribute certificate may contain a target information extensionlimiting the servers where this attribute certificate can be used. ifthis extension is not present, the attribute certificate is not targetedand may be accepted by any server.",
	"Method": "void addTargetGroup(GeneralName group){\r\n    targetGroups.add(group);\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.ntru.polynomial.IntegerPolynomial.div",
	"Comment": "divides each coefficient by k and rounds to the nearest integer. does not return a new polynomial but modifies this polynomial.",
	"Method": "void div(int k){\r\n    int k2 = (k + 1) / 2;\r\n    for (int i = 0; i < coeffs.length; i++) {\r\n        coeffs[i] += coeffs[i] > 0 ? k2 : -k2;\r\n        coeffs[i] /= k;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.util.encoders.Base64.decode",
	"Comment": "decode the base 64 encoded string data writing it to the given output stream,whitespace characters will be ignored.",
	"Method": "byte[] decode(byte[] data,byte[] decode,String data,int decode,String data,OutputStream out,int decode,byte[] base64Data,int start,int length,OutputStream out){\r\n    try {\r\n        return encoder.decode(base64Data, start, length, out);\r\n    } catch (Exception e) {\r\n        throw new DecoderException(\"unable to decode base64 data: \" + e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.ntru.polynomial.IntegerPolynomial.mult3",
	"Comment": "multiplies each coefficient by a 2 and applies a modulus. does not return a new polynomial but modifies this polynomial.",
	"Method": "void mult3(int modulus){\r\n    for (int i = 0; i < coeffs.length; i++) {\r\n        coeffs[i] *= 3;\r\n        coeffs[i] %= modulus;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.IntUtils.partition",
	"Comment": "split a subarray of a source array into two partitions. the leftpartition contains elements that have value less than or equal to thepivot element, the right partition contains the elements that have largervalue.",
	"Method": "int partition(int[] source,int left,int right,int pivotIndex){\r\n    int pivot = source[pivotIndex];\r\n    source[pivotIndex] = source[right];\r\n    source[right] = pivot;\r\n    int index = left;\r\n    for (int i = left; i < right; i++) {\r\n        if (source[i] <= pivot) {\r\n            int tmp = source[index];\r\n            source[index] = source[i];\r\n            source[i] = tmp;\r\n            index++;\r\n        }\r\n    }\r\n    int tmp = source[index];\r\n    source[index] = source[right];\r\n    source[right] = tmp;\r\n    return index;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.LittleEndianConversions.OS2IP",
	"Comment": "convert a byte array of the given length beginning at offsetinto an integer.",
	"Method": "int OS2IP(byte[] input,int OS2IP,byte[] input,int inOff,int OS2IP,byte[] input,int inOff,int inLen){\r\n    int result = 0;\r\n    for (int i = inLen - 1; i >= 0; i--) {\r\n        result |= (input[inOff + i] & 0xff) << (8 * i);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.spec.AEADParameterSpec.getAssociatedData",
	"Comment": "return the associated data associated with this parameter spec.",
	"Method": "byte[] getAssociatedData(){\r\n    return Arrays.clone(associatedData);\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.ntru.NTRUEncryptionParameters.getMaxMessageLength",
	"Comment": "returns the maximum length a plaintext message can be with this parameter set.",
	"Method": "int getMaxMessageLength(){\r\n    return maxMsgLenBytes;\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.getCertificateValid",
	"Comment": "returns the certificatevalid criterion. the specified date must fallwithin the certificate validity period for thex509certificate. if null, nocertificatevalid check will be done.note that the date returned is cloned to protect againstsubsequent modifications.",
	"Method": "Date getCertificateValid(){\r\n    if (certValid != null) {\r\n        return new Date(certValid.getTime());\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "javax.crypto.CipherOutputStream.close",
	"Comment": "closes this output stream and releases any system resources associated with this stream.this method invokes the dofinal method of the encapsulatedcipher object, which causes any bytes buffered by the encapsulatedcipher to be processed. the result is written out by calling theflush method of this output stream.this method resets the encapsulated cipher object to its initial stateand calls the close method of the underlying outputstream.",
	"Method": "void close(){\r\n    try {\r\n        byte[] bytes = c.doFinal();\r\n        if (bytes != null) {\r\n            out.write(bytes, 0, bytes.length);\r\n        }\r\n    } catch (Exception e) {\r\n        throw new IOException(\"Error closing stream: \" + e.toString());\r\n    }\r\n    flush();\r\n    super.close();\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.PKCS12KeyWithParameters.getIterationCount",
	"Comment": "return the iteration count to use in the key derivation function.",
	"Method": "int getIterationCount(){\r\n    return iterationCount;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.spec.ECNamedCurveParameterSpec.getName",
	"Comment": "return the name of the curve the ec domain parameters belong to.",
	"Method": "String getName(){\r\n    return name;\r\n}"
}, {
	"Path": "org.bouncycastle.cms.SignerInformation.replaceUnsignedAttributes",
	"Comment": "return a signer information object with the passed in unsignedattributes replacing the ones that are current associated withthe object passed in.",
	"Method": "SignerInformation replaceUnsignedAttributes(SignerInformation signerInformation,AttributeTable unsignedAttributes){\r\n    SignerInfo sInfo = signerInformation.info;\r\n    ASN1Set unsignedAttr = null;\r\n    if (unsignedAttributes != null) {\r\n        unsignedAttr = new DERSet(unsignedAttributes.toASN1EncodableVector());\r\n    }\r\n    return new SignerInformation(new SignerInfo(sInfo.getSID(), sInfo.getDigestAlgorithm(), sInfo.getAuthenticatedAttributes(), sInfo.getDigestEncryptionAlgorithm(), sInfo.getEncryptedDigest(), unsignedAttr), signerInformation.contentType, signerInformation.content, null);\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSAuthenticatedData.getAuthAttrs",
	"Comment": "return a table of the digested attributes indexed bythe oid of the attribute.",
	"Method": "AttributeTable getAuthAttrs(){\r\n    if (authAttrs == null) {\r\n        return null;\r\n    }\r\n    return new AttributeTable(authAttrs);\r\n}"
}, {
	"Path": "org.bouncycastle.x509.AttributeCertificateIssuer.getPrincipals",
	"Comment": "return any principal objects inside the attribute certificate issuer object.",
	"Method": "Principal[] getPrincipals(){\r\n    Object[] p = this.getNames();\r\n    List l = new ArrayList();\r\n    for (int i = 0; i != p.length; i++) {\r\n        if (p[i] instanceof Principal) {\r\n            l.add(p[i]);\r\n        }\r\n    }\r\n    return (Principal[]) l.toArray(new Principal[l.size()]);\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.CollectionCertStoreParameters.clone",
	"Comment": "returns a copy of this object. note that only a reference to thecollection is copied, and not the contents.",
	"Method": "Object clone(){\r\n    try {\r\n        return super.clone();\r\n    } catch (CloneNotSupportedException e) {\r\n        throw new InternalError(e.toString());\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.gmss.GMSSParameters.getK",
	"Comment": "returns the parameter k needed for authentication path computation",
	"Method": "int[] getK(){\r\n    return Arrays.clone(K);\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.x9.DomainParameters.getInstance",
	"Comment": "return a domainparameters object from the passed in object.",
	"Method": "DomainParameters getInstance(ASN1TaggedObject obj,boolean explicit,DomainParameters getInstance,Object obj){\r\n    if (obj instanceof DomainParameters) {\r\n        return (DomainParameters) obj;\r\n    } else if (obj != null) {\r\n        return new DomainParameters(ASN1Sequence.getInstance(obj));\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.X509CertSelector.getAuthorityKeyIdentifier",
	"Comment": "returns the authoritykeyidentifier criterion. thex509certificate must contain a authoritykeyidentifierextension with the specified value. if null, noauthoritykeyidentifier check will be done.note that the byte array returned is cloned to protect against subsequentmodifications.",
	"Method": "byte[] getAuthorityKeyIdentifier(){\r\n    if (authorityKeyID != null) {\r\n        return (byte[]) authorityKeyID.clone();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.CryptoServicesRegistrar.setSecureRandom",
	"Comment": "set a default secure random to be used where none is otherwise provided.",
	"Method": "void setSecureRandom(SecureRandom secureRandom){\r\n    checkPermission(CanSetDefaultRandom);\r\n    defaultSecureRandom = secureRandom;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.X509CRLEntryHolder.getSerialNumber",
	"Comment": "return the serial number of the certificate associated with this crlentry.",
	"Method": "BigInteger getSerialNumber(){\r\n    return entry.getUserCertificate().getValue();\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSSignedData.getSignedContentTypeOID",
	"Comment": "return the a string representation of the oid associated with theencapsulated content info structure carried in the signed data.",
	"Method": "String getSignedContentTypeOID(){\r\n    return signedData.getEncapContentInfo().getContentType().getId();\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSSignedDataParser.replaceCertificatesAndCRLs",
	"Comment": "replace the certificate and crl information associated with thiscmssigneddata object with the new one passed in.the output stream is returned unclosed.",
	"Method": "OutputStream replaceCertificatesAndCRLs(InputStream original,Store certs,Store crls,Store attrCerts,OutputStream out){\r\n    ASN1StreamParser in = new ASN1StreamParser(original);\r\n    ContentInfoParser contentInfo = new ContentInfoParser((ASN1SequenceParser) in.readObject());\r\n    SignedDataParser signedData = SignedDataParser.getInstance(contentInfo.getContent(BERTags.SEQUENCE));\r\n    BERSequenceGenerator sGen = new BERSequenceGenerator(out);\r\n    sGen.addObject(CMSObjectIdentifiers.signedData);\r\n    BERSequenceGenerator sigGen = new BERSequenceGenerator(sGen.getRawOutputStream(), 0, true);\r\n    sigGen.addObject(signedData.getVersion());\r\n    sigGen.getRawOutputStream().write(signedData.getDigestAlgorithms().toASN1Primitive().getEncoded());\r\n    ContentInfoParser encapContentInfo = signedData.getEncapContentInfo();\r\n    BERSequenceGenerator eiGen = new BERSequenceGenerator(sigGen.getRawOutputStream());\r\n    eiGen.addObject(encapContentInfo.getContentType());\r\n    pipeEncapsulatedOctetString(encapContentInfo, eiGen.getRawOutputStream());\r\n    eiGen.close();\r\n    getASN1Set(signedData.getCertificates());\r\n    getASN1Set(signedData.getCrls());\r\n    if (certs != null || attrCerts != null) {\r\n        List certificates = new ArrayList();\r\n        if (certs != null) {\r\n            certificates.addAll(CMSUtils.getCertificatesFromStore(certs));\r\n        }\r\n        if (attrCerts != null) {\r\n            certificates.addAll(CMSUtils.getAttributeCertificatesFromStore(attrCerts));\r\n        }\r\n        ASN1Set asn1Certs = CMSUtils.createBerSetFromList(certificates);\r\n        if (asn1Certs.size() > 0) {\r\n            sigGen.getRawOutputStream().write(new DERTaggedObject(false, 0, asn1Certs).getEncoded());\r\n        }\r\n    }\r\n    if (crls != null) {\r\n        ASN1Set asn1Crls = CMSUtils.createBerSetFromList(CMSUtils.getCRLsFromStore(crls));\r\n        if (asn1Crls.size() > 0) {\r\n            sigGen.getRawOutputStream().write(new DERTaggedObject(false, 1, asn1Crls).getEncoded());\r\n        }\r\n    }\r\n    sigGen.getRawOutputStream().write(signedData.getSignerInfos().toASN1Primitive().getEncoded());\r\n    sigGen.close();\r\n    sGen.close();\r\n    return out;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2nPolynomialField.computeFieldPolynomial2",
	"Comment": "computes the field polynomial. this can take a long time for big degrees.",
	"Method": "void computeFieldPolynomial2(){\r\n    if (testTrinomials()) {\r\n        return;\r\n    }\r\n    if (testPentanomials()) {\r\n        return;\r\n    }\r\n    testRandom();\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.utils.Platform.isUnix",
	"Comment": "test whether netbeans is running on some variant of unix. linux is included as well as the commercial vendors, and mac os x.",
	"Method": "boolean isUnix(){\r\n    return (getOperatingSystem() & OS_UNIX_MASK) != 0;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.engines.RSABlindingEngine.getOutputBlockSize",
	"Comment": "return the maximum size for an output block to this engine.for rsa this is always one byte less than the key size ondecryption, and the same length as the key size on encryption.",
	"Method": "int getOutputBlockSize(){\r\n    return core.getOutputBlockSize();\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.gmss.GMSSRootCalc.initializeTreehashSeed",
	"Comment": "initializes the seeds for the treehashs of the tree precomputed by thisclass",
	"Method": "void initializeTreehashSeed(byte[] seed,int index){\r\n    treehash[index].initializeSeed(seed);\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.crmf.PKIPublicationInfo.toASN1Primitive",
	"Comment": "return the primitive representation of pkipublicationinfo.",
	"Method": "ASN1Primitive toASN1Primitive(){\r\n    ASN1EncodableVector v = new ASN1EncodableVector();\r\n    v.add(action);\r\n    if (pubInfos != null) {\r\n        v.add(pubInfos);\r\n    }\r\n    return new DERSequence(v);\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.x509.PKIXNameConstraintValidator.unionIP",
	"Comment": "returns the union of the excluded ip ranges in excludedwith ip.",
	"Method": "Set unionIP(Set excluded,byte[] ip){\r\n    if (excluded.isEmpty()) {\r\n        if (ip == null) {\r\n            return excluded;\r\n        }\r\n        excluded.add(ip);\r\n        return excluded;\r\n    } else {\r\n        Set union = new HashSet();\r\n        Iterator it = excluded.iterator();\r\n        while (it.hasNext()) {\r\n            byte[] _excluded = (byte[]) it.next();\r\n            union.addAll(unionIPRange(_excluded, ip));\r\n        }\r\n        return union;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPKeyRingGenerator.generatePublicKeyRing",
	"Comment": "return the public key ring that corresponds to the secret key ring.",
	"Method": "PGPPublicKeyRing generatePublicKeyRing(){\r\n    Iterator it = keys.iterator();\r\n    List pubKeys = new ArrayList();\r\n    pubKeys.add(((PGPSecretKey) it.next()).getPublicKey());\r\n    while (it.hasNext()) {\r\n        pubKeys.add(((PGPSecretKey) it.next()).getPublicKey());\r\n    }\r\n    return new PGPPublicKeyRing(pubKeys);\r\n}"
}, {
	"Path": "org.bouncycastle.cert.X509AttributeCertificateHolder.getNotAfter",
	"Comment": "return the date after which this attribute certificate is not valid.",
	"Method": "Date getNotAfter(){\r\n    return CertUtils.recoverDate(attrCert.getAcinfo().getAttrCertValidityPeriod().getNotAfterTime());\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.x509.PKIXNameConstraintValidator.intersectIP",
	"Comment": "returns the intersection of the permitted ip ranges inpermitted with ip.",
	"Method": "Set intersectIP(Set permitted,Set ips){\r\n    Set intersect = new HashSet();\r\n    for (Iterator it = ips.iterator(); it.hasNext(); ) {\r\n        byte[] ip = ASN1OctetString.getInstance(((GeneralSubtree) it.next()).getBase().getName()).getOctets();\r\n        if (permitted == null) {\r\n            if (ip != null) {\r\n                intersect.add(ip);\r\n            }\r\n        } else {\r\n            Iterator it2 = permitted.iterator();\r\n            while (it2.hasNext()) {\r\n                byte[] _permitted = (byte[]) it2.next();\r\n                intersect.addAll(intersectIPRange(_permitted, ip));\r\n            }\r\n        }\r\n    }\r\n    return intersect;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2Polynomial.addToThis",
	"Comment": "adds b to this gf2polynomial and assigns the result to thisgf2polynomial. b can be of different size.",
	"Method": "void addToThis(GF2Polynomial b){\r\n    expandN(b.len);\r\n    xorThisBy(b);\r\n}"
}, {
	"Path": "org.bouncycastle.cert.X509CertificateHolder.getSignature",
	"Comment": "return the bytes making up the signature associated with this attribute certificate.",
	"Method": "byte[] getSignature(){\r\n    return x509Certificate.getSignature().getOctets();\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSSignedData.isCertificateManagementMessage",
	"Comment": "return if this is object represents a certificate management message.",
	"Method": "boolean isCertificateManagementMessage(){\r\n    return signedData.getEncapContentInfo().getContent() == null && signedData.getSignerInfos().size() == 0;\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.provider.asymmetric.dsa.BCDSAPrivateKey.getEncoded",
	"Comment": "return a pkcs8 representation of the key. the sequence returnedrepresents a full privatekeyinfo object.",
	"Method": "byte[] getEncoded(){\r\n    return KeyUtil.getEncodedPrivateKeyInfo(new AlgorithmIdentifier(X9ObjectIdentifiers.id_dsa, new DSAParameter(dsaSpec.getP(), dsaSpec.getQ(), dsaSpec.getG()).toASN1Primitive()), new ASN1Integer(getX()));\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.engines.TwofishEngine.decryptBlock",
	"Comment": "decrypt the given input starting at the given offset and placethe result in the provided buffer starting at the given offset.the input will be an exact multiple of our blocksize.",
	"Method": "void decryptBlock(byte[] src,int srcIndex,byte[] dst,int dstIndex){\r\n    int x2 = BytesTo32Bits(src, srcIndex) ^ gSubKeys[OUTPUT_WHITEN];\r\n    int x3 = BytesTo32Bits(src, srcIndex + 4) ^ gSubKeys[OUTPUT_WHITEN + 1];\r\n    int x0 = BytesTo32Bits(src, srcIndex + 8) ^ gSubKeys[OUTPUT_WHITEN + 2];\r\n    int x1 = BytesTo32Bits(src, srcIndex + 12) ^ gSubKeys[OUTPUT_WHITEN + 3];\r\n    int k = ROUND_SUBKEYS + 2 * ROUNDS - 1;\r\n    int t0, t1;\r\n    for (int r = 0; r < ROUNDS; r += 2) {\r\n        t0 = Fe32_0(x2);\r\n        t1 = Fe32_3(x3);\r\n        x1 ^= t0 + 2 * t1 + gSubKeys[k--];\r\n        x0 = (x0 << 1 | x0 >>> 31) ^ (t0 + t1 + gSubKeys[k--]);\r\n        x1 = x1 >>> 1 | x1 << 31;\r\n        t0 = Fe32_0(x0);\r\n        t1 = Fe32_3(x1);\r\n        x3 ^= t0 + 2 * t1 + gSubKeys[k--];\r\n        x2 = (x2 << 1 | x2 >>> 31) ^ (t0 + t1 + gSubKeys[k--]);\r\n        x3 = x3 >>> 1 | x3 << 31;\r\n    }\r\n    Bits32ToBytes(x0 ^ gSubKeys[INPUT_WHITEN], dst, dstIndex);\r\n    Bits32ToBytes(x1 ^ gSubKeys[INPUT_WHITEN + 1], dst, dstIndex + 4);\r\n    Bits32ToBytes(x2 ^ gSubKeys[INPUT_WHITEN + 2], dst, dstIndex + 8);\r\n    Bits32ToBytes(x3 ^ gSubKeys[INPUT_WHITEN + 3], dst, dstIndex + 12);\r\n}"
}, {
	"Path": "javax.crypto.Mac.clone",
	"Comment": "returns a clone if the provider implementation is cloneable.",
	"Method": "Object clone(){\r\n    Mac result = new Mac((MacSpi) macSpi.clone(), provider, algorithm);\r\n    result.initialised = initialised;\r\n    return result;\r\n}"
}, {
	"Path": "org.bouncycastle.x509.X509CertPairStoreSelector.setCertPair",
	"Comment": "set the certificate pair which is used for testing on equality.",
	"Method": "void setCertPair(X509CertificatePair certPair){\r\n    this.certPair = certPair;\r\n}"
}, {
	"Path": "java.security.cert.CertPathValidatorException.getCertPath",
	"Comment": "returns the certification path that was being validated whenthe exception was thrown.",
	"Method": "CertPath getCertPath(){\r\n    return certPath;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.PolicyQualifierInfo.getPolicyQualifier",
	"Comment": "returns the asn.1 der encoded form of the qualifier fieldof this policyqualifierinfo.",
	"Method": "byte[] getPolicyQualifier(){\r\n    if (qualifier == null) {\r\n        return null;\r\n    }\r\n    return (byte[]) qualifier.clone();\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher.processByte",
	"Comment": "process a single byte, producing an output block if neccessary.",
	"Method": "int processByte(byte in,byte[] out,int outOff){\r\n    int resultLen = 0;\r\n    if (bufOff == buf.length) {\r\n        resultLen = cipher.processBlock(buf, 0, out, outOff);\r\n        bufOff = 0;\r\n    }\r\n    buf[bufOff++] = in;\r\n    return resultLen;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.modes.OldCTSBlockCipher.getUpdateOutputSize",
	"Comment": "return the size of the output buffer required for an updatean input of len bytes.",
	"Method": "int getUpdateOutputSize(int len){\r\n    int total = len + bufOff;\r\n    int leftOver = total % buf.length;\r\n    if (leftOver == 0) {\r\n        return total - buf.length;\r\n    }\r\n    return total - leftOver;\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.getSubjectPublicKeyAlgID",
	"Comment": "returns the subjectpublickeyalgid criterion. thex509certificate must contain a subject public key with thespecified algorithm. if null, no subjectpublickeyalgidcheck will be done.",
	"Method": "String getSubjectPublicKeyAlgID(){\r\n    if (subjectKeyAlgID != null) {\r\n        return subjectKeyAlgID.toString();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "java.security.cert.PKIXCertPathValidatorResult.getTrustAnchor",
	"Comment": "returns the trustanchor describing the ca that servedas a trust anchor for the certification path.",
	"Method": "TrustAnchor getTrustAnchor(){\r\n    return trustAnchor;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.tls.TlsECCUtils.generateEphemeralServerKeyExchange",
	"Comment": "todo refactor around serverecdhparams before making this public",
	"Method": "ECPrivateKeyParameters generateEphemeralServerKeyExchange(SecureRandom random,int[] namedCurves,short[] ecPointFormats,OutputStream output){\r\n    int namedCurve = -1;\r\n    if (namedCurves == null) {\r\n        namedCurve = NamedCurve.secp256r1;\r\n    } else {\r\n        for (int i = 0; i < namedCurves.length; ++i) {\r\n            int entry = namedCurves[i];\r\n            if (NamedCurve.isValid(entry) && isSupportedNamedCurve(entry)) {\r\n                namedCurve = entry;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    ECDomainParameters ecParams = null;\r\n    if (namedCurve >= 0) {\r\n        ecParams = getParametersForNamedCurve(namedCurve);\r\n    } else {\r\n        if (Arrays.contains(namedCurves, NamedCurve.arbitrary_explicit_prime_curves)) {\r\n            ecParams = getParametersForNamedCurve(NamedCurve.secp256r1);\r\n        } else if (Arrays.contains(namedCurves, NamedCurve.arbitrary_explicit_char2_curves)) {\r\n            ecParams = getParametersForNamedCurve(NamedCurve.sect283r1);\r\n        }\r\n    }\r\n    if (ecParams == null) {\r\n        throw new TlsFatalAlert(AlertDescription.internal_error);\r\n    }\r\n    if (namedCurve < 0) {\r\n        writeExplicitECParameters(ecPointFormats, ecParams, output);\r\n    } else {\r\n        writeNamedECParameters(namedCurve, output);\r\n    }\r\n    return generateEphemeralClientKeyExchange(random, ecPointFormats, ecParams, output);\r\n}"
}, {
	"Path": "org.bouncycastle.pkix.jcajce.RFC3280CertPathUtilities.checkCRL",
	"Comment": "checks a distribution point for revocation information for thecertificate cert.",
	"Method": "void checkCRL(DistributionPoint dp,PKIXExtendedParameters paramsPKIX,X509Certificate cert,Date validDate,X509Certificate defaultCRLSignCert,PublicKey defaultCRLSignKey,CertStatus certStatus,ReasonsMask reasonMask,List certPathCerts,PKIXJcaJceHelper helper){\r\n    Date currentDate = new Date(System.currentTimeMillis());\r\n    if (validDate.getTime() > currentDate.getTime()) {\r\n        throw new AnnotatedException(\"Validation time is in future.\");\r\n    }\r\n    Date validityDate = currentDate;\r\n    if (paramsPKIX.getDate() != null) {\r\n        validityDate = paramsPKIX.getDate();\r\n    }\r\n    Set crls = RevocationUtilities.getCompleteCRLs(dp, cert, validityDate, paramsPKIX.getCertStores(), paramsPKIX.getCRLStores());\r\n    boolean validCrlFound = false;\r\n    AnnotatedException lastException = null;\r\n    Iterator crl_iter = crls.iterator();\r\n    while (crl_iter.hasNext() && certStatus.getCertStatus() == CertStatus.UNREVOKED && !reasonMask.isAllReasons()) {\r\n        try {\r\n            X509CRL crl = (X509CRL) crl_iter.next();\r\n            ReasonsMask interimReasonsMask = RFC3280CertPathUtilities.processCRLD(crl, dp);\r\n            if (!interimReasonsMask.hasNewReasons(reasonMask)) {\r\n                continue;\r\n            }\r\n            Set keys = RFC3280CertPathUtilities.processCRLF(crl, cert, defaultCRLSignCert, defaultCRLSignKey, paramsPKIX, certPathCerts, helper);\r\n            PublicKey key = RFC3280CertPathUtilities.processCRLG(crl, keys);\r\n            X509CRL deltaCRL = null;\r\n            if (paramsPKIX.isUseDeltasEnabled()) {\r\n                Set deltaCRLs = RevocationUtilities.getDeltaCRLs(validityDate, crl, paramsPKIX.getCertStores(), paramsPKIX.getCRLStores());\r\n                deltaCRL = RFC3280CertPathUtilities.processCRLH(deltaCRLs, key);\r\n            }\r\n            if (paramsPKIX.getValidityModel() != PKIXExtendedParameters.CHAIN_VALIDITY_MODEL) {\r\n                if (cert.getNotAfter().getTime() < crl.getThisUpdate().getTime()) {\r\n                    throw new AnnotatedException(\"No valid CRL for current time found.\");\r\n                }\r\n            }\r\n            RFC3280CertPathUtilities.processCRLB1(dp, cert, crl);\r\n            RFC3280CertPathUtilities.processCRLB2(dp, cert, crl);\r\n            RFC3280CertPathUtilities.processCRLC(deltaCRL, crl, paramsPKIX);\r\n            RFC3280CertPathUtilities.processCRLI(validDate, deltaCRL, cert, certStatus, paramsPKIX);\r\n            RFC3280CertPathUtilities.processCRLJ(validDate, crl, cert, certStatus);\r\n            if (certStatus.getCertStatus() == CRLReason.removeFromCRL) {\r\n                certStatus.setCertStatus(CertStatus.UNREVOKED);\r\n            }\r\n            reasonMask.addReasons(interimReasonsMask);\r\n            Set criticalExtensions = crl.getCriticalExtensionOIDs();\r\n            if (criticalExtensions != null) {\r\n                criticalExtensions = new HashSet(criticalExtensions);\r\n                criticalExtensions.remove(Extension.issuingDistributionPoint.getId());\r\n                criticalExtensions.remove(Extension.deltaCRLIndicator.getId());\r\n                if (!criticalExtensions.isEmpty()) {\r\n                    throw new AnnotatedException(\"CRL contains unsupported critical extensions.\");\r\n                }\r\n            }\r\n            if (deltaCRL != null) {\r\n                criticalExtensions = deltaCRL.getCriticalExtensionOIDs();\r\n                if (criticalExtensions != null) {\r\n                    criticalExtensions = new HashSet(criticalExtensions);\r\n                    criticalExtensions.remove(Extension.issuingDistributionPoint.getId());\r\n                    criticalExtensions.remove(Extension.deltaCRLIndicator.getId());\r\n                    if (!criticalExtensions.isEmpty()) {\r\n                        throw new AnnotatedException(\"Delta CRL contains unsupported critical extension.\");\r\n                    }\r\n                }\r\n            }\r\n            validCrlFound = true;\r\n        } catch (AnnotatedException e) {\r\n            lastException = e;\r\n        }\r\n    }\r\n    if (!validCrlFound) {\r\n        throw lastException;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.modes.G3413CTRBlockCipher.reset",
	"Comment": "reset the feedback vector back to the iv and reset the underlyingcipher.",
	"Method": "void reset(){\r\n    if (initialized) {\r\n        System.arraycopy(IV, 0, CTR, 0, IV.length);\r\n        for (int i = IV.length; i < blockSize; i++) {\r\n            CTR[i] = 0;\r\n        }\r\n        byteCount = 0;\r\n        cipher.reset();\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.cms.SignerInformation.getVersion",
	"Comment": "return the version number for this objects underlying signerinfo structure.",
	"Method": "int getVersion(){\r\n    return info.getVersion().getValue().intValue();\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.provider.asymmetric.util.ECUtil.convertMidTerms",
	"Comment": "returns a sorted array of middle terms of the reduction polynomial.",
	"Method": "int[] convertMidTerms(int[] k){\r\n    int[] res = new int[3];\r\n    if (k.length == 1) {\r\n        res[0] = k[0];\r\n    } else {\r\n        if (k.length != 3) {\r\n            throw new IllegalArgumentException(\"Only Trinomials and pentanomials supported\");\r\n        }\r\n        if (k[0] < k[1] && k[0] < k[2]) {\r\n            res[0] = k[0];\r\n            if (k[1] < k[2]) {\r\n                res[1] = k[1];\r\n                res[2] = k[2];\r\n            } else {\r\n                res[1] = k[2];\r\n                res[2] = k[1];\r\n            }\r\n        } else if (k[1] < k[2]) {\r\n            res[0] = k[1];\r\n            if (k[0] < k[2]) {\r\n                res[1] = k[0];\r\n                res[2] = k[2];\r\n            } else {\r\n                res[1] = k[2];\r\n                res[2] = k[0];\r\n            }\r\n        } else {\r\n            res[0] = k[2];\r\n            if (k[0] < k[1]) {\r\n                res[1] = k[0];\r\n                res[2] = k[1];\r\n            } else {\r\n                res[1] = k[1];\r\n                res[2] = k[0];\r\n            }\r\n        }\r\n    }\r\n    return res;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.signers.ECGOST3410_2012Signer.generateSignature",
	"Comment": "generate a signature for the given message using the key we wereinitialised with. for conventional gost3410 2012 the message should be a gost3411 2012hash of the message of interest.",
	"Method": "BigInteger[] generateSignature(byte[] message){\r\n    byte[] mRev = new byte[message.length];\r\n    for (int i = 0; i != mRev.length; i++) {\r\n        mRev[i] = message[mRev.length - 1 - i];\r\n    }\r\n    BigInteger e = new BigInteger(1, mRev);\r\n    ECDomainParameters ec = key.getParameters();\r\n    BigInteger n = ec.getN();\r\n    BigInteger d = ((ECPrivateKeyParameters) key).getD();\r\n    BigInteger r, s;\r\n    ECMultiplier basePointMultiplier = createBasePointMultiplier();\r\n    do {\r\n        BigInteger k;\r\n        do {\r\n            do {\r\n                k = BigIntegers.createRandomBigInteger(n.bitLength(), random);\r\n            } while (k.equals(ECConstants.ZERO));\r\n            ECPoint p = basePointMultiplier.multiply(ec.getG(), k).normalize();\r\n            r = p.getAffineXCoord().toBigInteger().mod(n);\r\n        } while (r.equals(ECConstants.ZERO));\r\n        s = (k.multiply(e)).add(d.multiply(r)).mod(n);\r\n    } while (s.equals(ECConstants.ZERO));\r\n    return new BigInteger[] { r, s };\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2Vector.extractLeftVector",
	"Comment": "return a new vector consisting of the first k elements of thisvector.",
	"Method": "GF2Vector extractLeftVector(int k){\r\n    if (k > length) {\r\n        throw new ArithmeticException(\"invalid length\");\r\n    }\r\n    if (k == length) {\r\n        return new GF2Vector(this);\r\n    }\r\n    GF2Vector result = new GF2Vector(k);\r\n    int q = k >> 5;\r\n    int r = k & 0x1f;\r\n    System.arraycopy(v, 0, result.v, 0, q);\r\n    if (r != 0) {\r\n        result.v[q] = v[q] & ((1 << r) - 1);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.utils.Platform.getUsableScreenBounds",
	"Comment": "returns the usable area of the screen where applications can place itswindows.the method subtracts from the screen the area of taskbars,system menus and the like.",
	"Method": "Rectangle getUsableScreenBounds(Rectangle getUsableScreenBounds,GraphicsConfiguration gconf){\r\n    if (gconf == null) {\r\n        gconf = GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice().getDefaultConfiguration();\r\n    }\r\n    Rectangle bounds = new Rectangle(gconf.getBounds());\r\n    String str;\r\n    str = System.getProperty(\"netbeans.screen.insets\");\r\n    if (str != null) {\r\n        StringTokenizer st = new StringTokenizer(str, \", \");\r\n        if (st.countTokens() == 4) {\r\n            try {\r\n                bounds.y = Integer.parseInt(st.nextToken());\r\n                bounds.x = Integer.parseInt(st.nextToken());\r\n                bounds.height -= (bounds.y + Integer.parseInt(st.nextToken()));\r\n                bounds.width -= (bounds.x + Integer.parseInt(st.nextToken()));\r\n            } catch (NumberFormatException ex) {\r\n                Logger.getAnonymousLogger().log(Level.WARNING, null, ex);\r\n            }\r\n        }\r\n        return bounds;\r\n    }\r\n    str = System.getProperty(\"netbeans.taskbar.height\");\r\n    if (str != null) {\r\n        bounds.height -= Integer.getInteger(str, 0).intValue();\r\n        return bounds;\r\n    }\r\n    try {\r\n        Toolkit toolkit = Toolkit.getDefaultToolkit();\r\n        Insets insets = toolkit.getScreenInsets(gconf);\r\n        bounds.y += insets.top;\r\n        bounds.x += insets.left;\r\n        bounds.height -= (insets.top + insets.bottom);\r\n        bounds.width -= (insets.left + insets.right);\r\n    } catch (Exception ex) {\r\n        Logger.getAnonymousLogger().log(Level.WARNING, null, ex);\r\n    }\r\n    return bounds;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.X509AttributeCertificateHolder.getNotBefore",
	"Comment": "return the date before which this attribute certificate is not valid.",
	"Method": "Date getNotBefore(){\r\n    return CertUtils.recoverDate(attrCert.getAcinfo().getAttrCertValidityPeriod().getNotBeforeTime());\r\n}"
}, {
	"Path": "org.bouncycastle.mime.Headers.getContentTypeAttributes",
	"Comment": "return the a map of the contenttype attributes and their values.",
	"Method": "Map<String, String> getContentTypeAttributes(){\r\n    return contentTypeParameters;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.gmss.GMSSRootCalc.getStatByte",
	"Comment": "returns the status byte array used by the gmssprivatekeyasn.1 class",
	"Method": "byte[][] getStatByte(){\r\n    int tailLength;\r\n    if (tailStack == null) {\r\n        tailLength = 0;\r\n    } else {\r\n        tailLength = tailStack.size();\r\n    }\r\n    byte[][] statByte = new byte[1 + heightOfTree + tailLength][64];\r\n    statByte[0] = root;\r\n    for (int i = 0; i < heightOfTree; i++) {\r\n        statByte[1 + i] = AuthPath[i];\r\n    }\r\n    for (int i = 0; i < tailLength; i++) {\r\n        statByte[1 + heightOfTree + i] = (byte[]) tailStack.elementAt(i);\r\n    }\r\n    return statByte;\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.ch16_tree.BETreeUI.createDefaultCellRenderer",
	"Comment": "returns the default cell renderer that is used to do thestamping of each node.",
	"Method": "TreeCellRenderer createDefaultCellRenderer(){\r\n    return new WindowsTreeCellRenderer();\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.modes.CCMBlockCipher.processPacket",
	"Comment": "process a packet of data for either ccm decryption or encryption.",
	"Method": "byte[] processPacket(byte[] in,int inOff,int inLen,int processPacket,byte[] in,int inOff,int inLen,byte[] output,int outOff){\r\n    if (keyParam == null) {\r\n        throw new IllegalStateException(\"CCM cipher unitialized.\");\r\n    }\r\n    int n = nonce.length;\r\n    int q = 15 - n;\r\n    if (q < 4) {\r\n        int limitLen = 1 << (8 * q);\r\n        if (inLen >= limitLen) {\r\n            throw new IllegalStateException(\"CCM packet too large for choice of q.\");\r\n        }\r\n    }\r\n    byte[] iv = new byte[blockSize];\r\n    iv[0] = (byte) ((q - 1) & 0x7);\r\n    System.arraycopy(nonce, 0, iv, 1, nonce.length);\r\n    BlockCipher ctrCipher = new SICBlockCipher(cipher);\r\n    ctrCipher.init(forEncryption, new ParametersWithIV(keyParam, iv));\r\n    int outputLen;\r\n    int inIndex = inOff;\r\n    int outIndex = outOff;\r\n    if (forEncryption) {\r\n        outputLen = inLen + macSize;\r\n        if (output.length < (outputLen + outOff)) {\r\n            throw new OutputLengthException(\"Output buffer too short.\");\r\n        }\r\n        calculateMac(in, inOff, inLen, macBlock);\r\n        byte[] encMac = new byte[blockSize];\r\n        ctrCipher.processBlock(macBlock, 0, encMac, 0);\r\n        while (inIndex < (inOff + inLen - blockSize)) {\r\n            ctrCipher.processBlock(in, inIndex, output, outIndex);\r\n            outIndex += blockSize;\r\n            inIndex += blockSize;\r\n        }\r\n        byte[] block = new byte[blockSize];\r\n        System.arraycopy(in, inIndex, block, 0, inLen + inOff - inIndex);\r\n        ctrCipher.processBlock(block, 0, block, 0);\r\n        System.arraycopy(block, 0, output, outIndex, inLen + inOff - inIndex);\r\n        System.arraycopy(encMac, 0, output, outOff + inLen, macSize);\r\n    } else {\r\n        if (inLen < macSize) {\r\n            throw new InvalidCipherTextException(\"data too short\");\r\n        }\r\n        outputLen = inLen - macSize;\r\n        if (output.length < (outputLen + outOff)) {\r\n            throw new OutputLengthException(\"Output buffer too short.\");\r\n        }\r\n        System.arraycopy(in, inOff + outputLen, macBlock, 0, macSize);\r\n        ctrCipher.processBlock(macBlock, 0, macBlock, 0);\r\n        for (int i = macSize; i != macBlock.length; i++) {\r\n            macBlock[i] = 0;\r\n        }\r\n        while (inIndex < (inOff + outputLen - blockSize)) {\r\n            ctrCipher.processBlock(in, inIndex, output, outIndex);\r\n            outIndex += blockSize;\r\n            inIndex += blockSize;\r\n        }\r\n        byte[] block = new byte[blockSize];\r\n        System.arraycopy(in, inIndex, block, 0, outputLen - (inIndex - inOff));\r\n        ctrCipher.processBlock(block, 0, block, 0);\r\n        System.arraycopy(block, 0, output, outIndex, outputLen - (inIndex - inOff));\r\n        byte[] calculatedMacBlock = new byte[blockSize];\r\n        calculateMac(output, outOff, outputLen, calculatedMacBlock);\r\n        if (!Arrays.constantTimeAreEqual(macBlock, calculatedMacBlock)) {\r\n            throw new InvalidCipherTextException(\"mac check in CCM failed\");\r\n        }\r\n    }\r\n    return outputLen;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.provider.X509StoreLDAPCRLs.engineGetMatches",
	"Comment": "returns a collection of matching crls from the ldap location.the selector must be a of type x509crlstoreselector. ifit is not an empty collection is returned.the issuer should be a reasonable criteria for a selector.",
	"Method": "Collection engineGetMatches(Selector selector){\r\n    if (!(selector instanceof X509CRLStoreSelector)) {\r\n        return Collections.EMPTY_SET;\r\n    }\r\n    X509CRLStoreSelector xselector = (X509CRLStoreSelector) selector;\r\n    Set set = new HashSet();\r\n    if (xselector.isDeltaCRLIndicatorEnabled()) {\r\n        set.addAll(helper.getDeltaCertificateRevocationLists(xselector));\r\n    } else {\r\n        set.addAll(helper.getDeltaCertificateRevocationLists(xselector));\r\n        set.addAll(helper.getAttributeAuthorityRevocationLists(xselector));\r\n        set.addAll(helper.getAttributeCertificateRevocationLists(xselector));\r\n        set.addAll(helper.getAuthorityRevocationLists(xselector));\r\n        set.addAll(helper.getCertificateRevocationLists(xselector));\r\n    }\r\n    return set;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.digests.Blake2bDigest.doFinal",
	"Comment": "close the digest, producing the final digest value. the dofinalcall leaves the digest reset.key, salt and personal string remain.",
	"Method": "int doFinal(byte[] out,int outOffset){\r\n    f0 = 0xFFFFFFFFFFFFFFFFL;\r\n    t0 += bufferPos;\r\n    if (bufferPos > 0 && t0 == 0) {\r\n        t1++;\r\n    }\r\n    compress(buffer, 0);\r\n    Arrays.fill(buffer, (byte) 0);\r\n    Arrays.fill(internalState, 0L);\r\n    for (int i = 0; i < chainValue.length && (i * 8 < digestLength); i++) {\r\n        byte[] bytes = Pack.longToLittleEndian(chainValue[i]);\r\n        if (i * 8 < digestLength - 8) {\r\n            System.arraycopy(bytes, 0, out, outOffset + i * 8, 8);\r\n        } else {\r\n            System.arraycopy(bytes, 0, out, outOffset + i * 8, digestLength - (i * 8));\r\n        }\r\n    }\r\n    Arrays.fill(chainValue, 0L);\r\n    reset();\r\n    return digestLength;\r\n}"
}, {
	"Path": "org.bouncycastle.x509.X509V3CertificateGenerator.getSignatureAlgNames",
	"Comment": "return an iterator of the signature names supported by the generator.",
	"Method": "Iterator getSignatureAlgNames(){\r\n    return X509Util.getAlgNames();\r\n}"
}, {
	"Path": "org.bouncycastle.cms.jcajce.JceCMSMacCalculatorBuilder.setAlgorithmParameters",
	"Comment": "provide a set of algorithm parameters for the content mac calculator to use.",
	"Method": "JceCMSMacCalculatorBuilder setAlgorithmParameters(AlgorithmParameters algorithmParameters){\r\n    this.algorithmParameters = algorithmParameters;\r\n    return this;\r\n}"
}, {
	"Path": "org.bouncycastle.cms.SignerInfoGeneratorBuilder.build",
	"Comment": "build a generator with the passed in subjectkeyidentifier as the signeridentifier. if usedyou shouldtry to follow the calculation described in rfc 5280 section 4.2.1.2.",
	"Method": "SignerInfoGenerator build(ContentSigner contentSigner,X509CertificateHolder certHolder,SignerInfoGenerator build,ContentSigner contentSigner,byte[] subjectKeyIdentifier){\r\n    SignerIdentifier sigId = new SignerIdentifier(new DEROctetString(subjectKeyIdentifier));\r\n    return createGenerator(contentSigner, sigId);\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.BCFKSLoadStoreParameter.getStoreMacAlgorithm",
	"Comment": "return encryption algorithm used to secure the store and its entries.",
	"Method": "MacAlgorithm getStoreMacAlgorithm(){\r\n    return macAlg;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.crmf.CertificateRequestMessage.getCertTemplate",
	"Comment": "return the certificate template contained in this message.",
	"Method": "CertTemplate getCertTemplate(){\r\n    return this.certReqMsg.getCertReq().getCertTemplate();\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.generators.PKCS5S1ParametersGenerator.generateDerivedParameters",
	"Comment": "generate a key with initialisation vector parameter derived fromthe password, salt, and iteration count we are currently initialisedwith.",
	"Method": "CipherParameters generateDerivedParameters(int keySize,CipherParameters generateDerivedParameters,int keySize,int ivSize){\r\n    keySize = keySize / 8;\r\n    ivSize = ivSize / 8;\r\n    if ((keySize + ivSize) > digest.getDigestSize()) {\r\n        throw new IllegalArgumentException(\"Can't generate a derived key \" + (keySize + ivSize) + \" bytes long.\");\r\n    }\r\n    byte[] dKey = generateDerivedKey();\r\n    return new ParametersWithIV(new KeyParameter(dKey, 0, keySize), dKey, keySize, ivSize);\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.ntru.polynomial.BigIntPolynomial.sumCoeffs",
	"Comment": "returns the sum of all coefficients, i.e. evaluates the polynomial at 0.",
	"Method": "BigInteger sumCoeffs(){\r\n    BigInteger sum = Constants.BIGINT_ZERO;\r\n    for (int i = 0; i < coeffs.length; i++) {\r\n        sum = sum.add(coeffs[i]);\r\n    }\r\n    return sum;\r\n}"
}, {
	"Path": "org.bouncycastle.util.encoders.UrlBase64.decode",
	"Comment": "decode the url safe base 64 encoded string data writing it to the given output stream,whitespace characters will be ignored.",
	"Method": "byte[] decode(byte[] data,int decode,byte[] data,OutputStream out,byte[] decode,String data,int decode,String data,OutputStream out){\r\n    return encoder.decode(data, out);\r\n}"
}, {
	"Path": "org.bouncycastle.x509.X509CertPairStoreSelector.getCertPair",
	"Comment": "returns the certificate pair which is used for testing on equality.",
	"Method": "X509CertificatePair getCertPair(){\r\n    return certPair;\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.spec.GOST28147ParameterSpec.getIV",
	"Comment": "returns the iv or null if this parameter set does not contain an iv.",
	"Method": "byte[] getIV(){\r\n    return Arrays.clone(iv);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.BufferedAsymmetricBlockCipher.doFinal",
	"Comment": "process the contents of the buffer using the underlyingcipher.",
	"Method": "byte[] doFinal(){\r\n    byte[] out = cipher.processBlock(buf, 0, bufOff);\r\n    reset();\r\n    return out;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.cms.KeyAgreeRecipientIdentifier.getInstance",
	"Comment": "return an keyagreerecipientidentifier object from a tagged object.",
	"Method": "KeyAgreeRecipientIdentifier getInstance(ASN1TaggedObject obj,boolean explicit,KeyAgreeRecipientIdentifier getInstance,Object obj){\r\n    if (obj == null || obj instanceof KeyAgreeRecipientIdentifier) {\r\n        return (KeyAgreeRecipientIdentifier) obj;\r\n    }\r\n    if (obj instanceof ASN1Sequence) {\r\n        return new KeyAgreeRecipientIdentifier(IssuerAndSerialNumber.getInstance(obj));\r\n    }\r\n    if (obj instanceof ASN1TaggedObject && ((ASN1TaggedObject) obj).getTagNo() == 0) {\r\n        return new KeyAgreeRecipientIdentifier(RecipientKeyIdentifier.getInstance((ASN1TaggedObject) obj, false));\r\n    }\r\n    throw new IllegalArgumentException(\"Invalid KeyAgreeRecipientIdentifier: \" + obj.getClass().getName());\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.paddings.X923Padding.addPadding",
	"Comment": "add the pad bytes to the passed in block, returning thenumber of bytes added.",
	"Method": "int addPadding(byte[] in,int inOff){\r\n    byte code = (byte) (in.length - inOff);\r\n    while (inOff < in.length - 1) {\r\n        if (random == null) {\r\n            in[inOff] = 0;\r\n        } else {\r\n            in[inOff] = (byte) random.nextInt();\r\n        }\r\n        inOff++;\r\n    }\r\n    in[inOff] = code;\r\n    return code;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.dane.DANEEntry.isValidCertificate",
	"Comment": "return true if the byte string has the correct flag bytes to indicate a certificate entry.",
	"Method": "boolean isValidCertificate(byte[] data){\r\n    return ((data[CERT_USAGE] >= 0 || data[CERT_USAGE] <= 3) && data[SELECTOR] == 0 && data[MATCHING_TYPE] == 0);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.digests.Blake2bDigest.getDigestSize",
	"Comment": "return the size, in bytes, of the digest produced by this message digest.",
	"Method": "int getDigestSize(){\r\n    return digestLength;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.crmf.jcajce.JcaEncryptedValueBuilder.build",
	"Comment": "build an encryptedvalue structure containing the private key details contained inthe passed privatekey.",
	"Method": "EncryptedValue build(X509Certificate certificate,EncryptedValue build,PrivateKey privateKey){\r\n    return build(PrivateKeyInfo.getInstance(privateKey.getEncoded()));\r\n}"
}, {
	"Path": "org.bouncycastle.cert.crmf.CertificateRequestMessage.toASN1Structure",
	"Comment": "return the underlying asn.1 object defining this certificaterequestmessage object.",
	"Method": "CertReqMsg toASN1Structure(){\r\n    return certReqMsg;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.provider.OldPKCS12ParametersGenerator.generateDerivedMacParameters",
	"Comment": "generate a key parameter for use with a mac derived from the password,salt, and iteration count we are currently initialised with.",
	"Method": "CipherParameters generateDerivedMacParameters(int keySize){\r\n    keySize = keySize / 8;\r\n    byte[] dKey = generateDerivedKey(MAC_MATERIAL, keySize);\r\n    return new KeyParameter(dKey, 0, keySize);\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.gmss.GMSSSigner.verifySignature",
	"Comment": "this function verifies the signature of the message that has beenupdated, with the aid of the public key.",
	"Method": "boolean verifySignature(byte[] message,byte[] signature){\r\n    boolean success = false;\r\n    messDigestOTS.reset();\r\n    WinternitzOTSVerify otsVerify;\r\n    int otsSigLength;\r\n    byte[] help = message;\r\n    byte[] otsSig;\r\n    byte[] otsPublicKey;\r\n    byte[][] authPath;\r\n    byte[] dest;\r\n    int nextEntry = 0;\r\n    int index;\r\n    for (int j = numLayer - 1; j >= 0; j--) {\r\n        otsVerify = new WinternitzOTSVerify(digestProvider.get(), gmssPS.getWinternitzParameter()[j]);\r\n        otsSigLength = otsVerify.getSignatureLength();\r\n        message = help;\r\n        index = gmssUtil.bytesToIntLittleEndian(signature, nextEntry);\r\n        nextEntry += 4;\r\n        otsSig = new byte[otsSigLength];\r\n        System.arraycopy(signature, nextEntry, otsSig, 0, otsSigLength);\r\n        nextEntry += otsSigLength;\r\n        otsPublicKey = otsVerify.Verify(message, otsSig);\r\n        if (otsPublicKey == null) {\r\n            System.err.println(\"OTS Public Key is null in GMSSSignature.verify\");\r\n            return false;\r\n        }\r\n        authPath = new byte[gmssPS.getHeightOfTrees()[j]][mdLength];\r\n        for (int i = 0; i < authPath.length; i++) {\r\n            System.arraycopy(signature, nextEntry, authPath[i], 0, mdLength);\r\n            nextEntry = nextEntry + mdLength;\r\n        }\r\n        help = new byte[mdLength];\r\n        help = otsPublicKey;\r\n        int count = 1 << authPath.length;\r\n        count = count + index;\r\n        for (int i = 0; i < authPath.length; i++) {\r\n            dest = new byte[mdLength << 1];\r\n            if ((count % 2) == 0) {\r\n                System.arraycopy(help, 0, dest, 0, mdLength);\r\n                System.arraycopy(authPath[i], 0, dest, mdLength, mdLength);\r\n                count = count / 2;\r\n            } else {\r\n                System.arraycopy(authPath[i], 0, dest, 0, mdLength);\r\n                System.arraycopy(help, 0, dest, mdLength, help.length);\r\n                count = (count - 1) / 2;\r\n            }\r\n            messDigestTrees.update(dest, 0, dest.length);\r\n            help = new byte[messDigestTrees.getDigestSize()];\r\n            messDigestTrees.doFinal(help, 0);\r\n        }\r\n    }\r\n    if (Arrays.areEqual(pubKeyBytes, help)) {\r\n        success = true;\r\n    }\r\n    return success;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.ntru.util.ArrayEncoder.encodeModQ",
	"Comment": "encodes an int array whose elements are between 0 and q,to a byte array leaving no gaps between bits.q must be a power of 2.",
	"Method": "byte[] encodeModQ(int[] a,int q){\r\n    int bitsPerCoeff = 31 - Integer.numberOfLeadingZeros(q);\r\n    int numBits = a.length * bitsPerCoeff;\r\n    int numBytes = (numBits + 7) / 8;\r\n    byte[] data = new byte[numBytes];\r\n    int bitIndex = 0;\r\n    int byteIndex = 0;\r\n    for (int i = 0; i < a.length; i++) {\r\n        for (int j = 0; j < bitsPerCoeff; j++) {\r\n            int currentBit = (a[i] >> j) & 1;\r\n            data[byteIndex] |= currentBit << bitIndex;\r\n            if (bitIndex == 7) {\r\n                bitIndex = 0;\r\n                byteIndex++;\r\n            } else {\r\n                bitIndex++;\r\n            }\r\n        }\r\n    }\r\n    return data;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2Matrix.getLeftSubMatrix",
	"Comment": "get the quadratic submatrix of this matrix consisting of the leftmostnumrows columns.",
	"Method": "GF2Matrix getLeftSubMatrix(){\r\n    if (numColumns <= numRows) {\r\n        throw new ArithmeticException(\"empty submatrix\");\r\n    }\r\n    int length = (numRows + 31) >> 5;\r\n    int[][] result = new int[numRows][length];\r\n    int bitMask = (1 << (numRows & 0x1f)) - 1;\r\n    if (bitMask == 0) {\r\n        bitMask = -1;\r\n    }\r\n    for (int i = numRows - 1; i >= 0; i--) {\r\n        System.arraycopy(matrix[i], 0, result[i], 0, length);\r\n        result[i][length - 1] &= bitMask;\r\n    }\r\n    return new GF2Matrix(numRows, result);\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.utils.Platform.isWindows",
	"Comment": "test whether netbeans is running on some variant of windows.",
	"Method": "boolean isWindows(){\r\n    return (getOperatingSystem() & OS_WINDOWS_MASK) != 0;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.PolynomialRingGF2.remainder",
	"Comment": "return the remainder of a polynomial division of two polynomials.",
	"Method": "int remainder(int p,int q){\r\n    int result = p;\r\n    if (q == 0) {\r\n        System.err.println(\"Error: to be divided by 0\");\r\n        return 0;\r\n    }\r\n    while (degree(result) >= degree(q)) {\r\n        result ^= q << (degree(result) - degree(q));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.CertPathValidatorException.getCause",
	"Comment": "returns the cause of this certpathvalidatorexception ornull if the cause is nonexistent or unknown.",
	"Method": "Throwable getCause(){\r\n    return cause;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.cmp.ProtectedPKIMessageBuilder.setRecipKID",
	"Comment": "set the recipient key identifier for the key to be used to verify the new message.",
	"Method": "ProtectedPKIMessageBuilder setRecipKID(byte[] kid){\r\n    hdrBuilder.setRecipKID(kid);\r\n    return this;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.X509AttributeCertificateHolder.isSignatureValid",
	"Comment": "validate the signature on the attribute certificate in this holder.",
	"Method": "boolean isSignatureValid(ContentVerifierProvider verifierProvider){\r\n    AttributeCertificateInfo acinfo = attrCert.getAcinfo();\r\n    if (!CertUtils.isAlgIdEqual(acinfo.getSignature(), attrCert.getSignatureAlgorithm())) {\r\n        throw new CertException(\"signature invalid - algorithm identifier mismatch\");\r\n    }\r\n    ContentVerifier verifier;\r\n    try {\r\n        verifier = verifierProvider.get((acinfo.getSignature()));\r\n        OutputStream sOut = verifier.getOutputStream();\r\n        DEROutputStream dOut = new DEROutputStream(sOut);\r\n        dOut.writeObject(acinfo);\r\n        sOut.close();\r\n    } catch (Exception e) {\r\n        throw new CertException(\"unable to process signature: \" + e.getMessage(), e);\r\n    }\r\n    return verifier.verify(this.getSignature());\r\n}"
}, {
	"Path": "org.bouncycastle.cert.cmp.ProtectedPKIMessageBuilder.addGeneralInfo",
	"Comment": "add a generalinfo data record to the header of the new message.",
	"Method": "ProtectedPKIMessageBuilder addGeneralInfo(InfoTypeAndValue genInfo){\r\n    generalInfos.add(genInfo);\r\n    return this;\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.operator.PBEKeyEncryptionMethodGenerator.getKey",
	"Comment": "generate a key for a symmetric encryption algorithm using the pbe configuration in thismethod.",
	"Method": "byte[] getKey(int encAlgorithm){\r\n    if (s2k == null) {\r\n        byte[] iv = new byte[8];\r\n        if (random == null) {\r\n            random = new SecureRandom();\r\n        }\r\n        random.nextBytes(iv);\r\n        s2k = new S2K(s2kDigestCalculator.getAlgorithm(), iv, s2kCount);\r\n    }\r\n    return PGPUtil.makeKeyFromPassPhrase(s2kDigestCalculator, encAlgorithm, s2k, passPhrase);\r\n}"
}, {
	"Path": "org.bouncycastle.math.ec.ECPoint.getEncoded",
	"Comment": "get an encoding of the point value, optionally in compressed format.",
	"Method": "byte[] getEncoded(byte[] getEncoded,boolean compressed){\r\n    if (this.isInfinity()) {\r\n        return new byte[1];\r\n    }\r\n    ECPoint normed = normalize();\r\n    byte[] X = normed.getXCoord().getEncoded();\r\n    if (compressed) {\r\n        byte[] PO = new byte[X.length + 1];\r\n        PO[0] = (byte) (normed.getCompressionYTilde() ? 0x03 : 0x02);\r\n        System.arraycopy(X, 0, PO, 1, X.length);\r\n        return PO;\r\n    }\r\n    byte[] Y = normed.getYCoord().getEncoded();\r\n    byte[] PO = new byte[X.length + Y.length + 1];\r\n    PO[0] = 0x04;\r\n    System.arraycopy(X, 0, PO, 1, X.length);\r\n    System.arraycopy(Y, 0, PO, X.length + 1, Y.length);\r\n    return PO;\r\n}"
}, {
	"Path": "org.bouncycastle.x509.AttributeCertificateHolder.getDigestAlgorithm",
	"Comment": "returns the other object type id if an object digest info is used.",
	"Method": "String getDigestAlgorithm(){\r\n    if (holder.getObjectDigestInfo() != null) {\r\n        return holder.getObjectDigestInfo().getDigestAlgorithm().getAlgorithm().getId();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.modes.CBCBlockCipher.processBlock",
	"Comment": "process one block of input from the array in and write it tothe out array.",
	"Method": "int processBlock(byte[] in,int inOff,byte[] out,int outOff){\r\n    return (encrypting) ? encryptBlock(in, inOff, out, outOff) : decryptBlock(in, inOff, out, outOff);\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.gmss.Treehash.update",
	"Comment": "calculates one update of the treehash instance, i.e. creates a new leafand hashes if possible",
	"Method": "void update(GMSSRandom gmssRandom,byte[] leaf){\r\n    if (this.isFinished) {\r\n        System.err.println(\"No more update possible for treehash instance!\");\r\n        return;\r\n    }\r\n    if (!this.isInitialized) {\r\n        System.err.println(\"Treehash instance not initialized before update\");\r\n        return;\r\n    }\r\n    byte[] help = new byte[this.messDigestTree.getDigestSize()];\r\n    int helpHeight = -1;\r\n    gmssRandom.nextSeed(this.seedActive);\r\n    if (this.firstNode == null) {\r\n        this.firstNode = leaf;\r\n        this.firstNodeHeight = 0;\r\n    } else {\r\n        help = leaf;\r\n        helpHeight = 0;\r\n        while (this.tailLength > 0 && helpHeight == ((Integer) heightOfNodes.lastElement()).intValue()) {\r\n            byte[] toBeHashed = new byte[this.messDigestTree.getDigestSize() << 1];\r\n            System.arraycopy(this.tailStack.lastElement(), 0, toBeHashed, 0, this.messDigestTree.getDigestSize());\r\n            this.tailStack.removeElementAt(this.tailStack.size() - 1);\r\n            this.heightOfNodes.removeElementAt(this.heightOfNodes.size() - 1);\r\n            System.arraycopy(help, 0, toBeHashed, this.messDigestTree.getDigestSize(), this.messDigestTree.getDigestSize());\r\n            messDigestTree.update(toBeHashed, 0, toBeHashed.length);\r\n            help = new byte[messDigestTree.getDigestSize()];\r\n            messDigestTree.doFinal(help, 0);\r\n            helpHeight++;\r\n            this.tailLength--;\r\n        }\r\n        this.tailStack.addElement(help);\r\n        this.heightOfNodes.addElement(Integers.valueOf(helpHeight));\r\n        this.tailLength++;\r\n        if (((Integer) heightOfNodes.lastElement()).intValue() == this.firstNodeHeight) {\r\n            byte[] toBeHashed = new byte[this.messDigestTree.getDigestSize() << 1];\r\n            System.arraycopy(this.firstNode, 0, toBeHashed, 0, this.messDigestTree.getDigestSize());\r\n            System.arraycopy(this.tailStack.lastElement(), 0, toBeHashed, this.messDigestTree.getDigestSize(), this.messDigestTree.getDigestSize());\r\n            this.tailStack.removeElementAt(this.tailStack.size() - 1);\r\n            this.heightOfNodes.removeElementAt(this.heightOfNodes.size() - 1);\r\n            messDigestTree.update(toBeHashed, 0, toBeHashed.length);\r\n            this.firstNode = new byte[messDigestTree.getDigestSize()];\r\n            messDigestTree.doFinal(this.firstNode, 0);\r\n            this.firstNodeHeight++;\r\n            this.tailLength = 0;\r\n        }\r\n    }\r\n    if (this.firstNodeHeight == this.maxHeight) {\r\n        this.isFinished = true;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.pkcs.PKCS10CertificationRequestBuilder.setAttribute",
	"Comment": "add an attribute with multiple values to the certification request we are building.removed existing attributes with the same attrtype.",
	"Method": "PKCS10CertificationRequestBuilder setAttribute(ASN1ObjectIdentifier attrType,ASN1Encodable attrValue,PKCS10CertificationRequestBuilder setAttribute,ASN1ObjectIdentifier attrType,ASN1Encodable[] attrValue){\r\n    for (Iterator it = attributes.iterator(); it.hasNext(); ) {\r\n        if (((Attribute) it.next()).getAttrType().equals(attrType)) {\r\n            throw new IllegalStateException(\"Attribute \" + attrType.toString() + \" is already set\");\r\n        }\r\n    }\r\n    addAttribute(attrType, attrValue);\r\n    return this;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.generators.HKDFBytesGenerator.expandNext",
	"Comment": "performs the expand part of the key derivation function, using currenttas input and output buffer.",
	"Method": "void expandNext(){\r\n    int n = generatedBytes / hashLen + 1;\r\n    if (n >= 256) {\r\n        throw new DataLengthException(\"HKDF cannot generate more than 255 blocks of HashLen size\");\r\n    }\r\n    if (generatedBytes != 0) {\r\n        hMacHash.update(currentT, 0, hashLen);\r\n    }\r\n    hMacHash.update(info, 0, info.length);\r\n    hMacHash.update((byte) n);\r\n    hMacHash.doFinal(currentT, 0);\r\n}"
}, {
	"Path": "org.bouncycastle.x509.X509AttributeCertStoreSelector.setSerialNumber",
	"Comment": "sets the serial number the attribute certificate must have. ifnull is given any will do.",
	"Method": "void setSerialNumber(BigInteger serialNumber){\r\n    this.serialNumber = serialNumber;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2nPolynomialElement.clone",
	"Comment": "creates a new gf2npolynomialelement by cloning thisgf2npolynomialelement.",
	"Method": "Object clone(){\r\n    return new GF2nPolynomialElement(this);\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.operator.jcajce.JcePGPDataEncryptorBuilder.setProvider",
	"Comment": "sets the jce provider to source cryptographic primitives from.",
	"Method": "JcePGPDataEncryptorBuilder setProvider(Provider provider,JcePGPDataEncryptorBuilder setProvider,String providerName){\r\n    this.helper = new OperatorHelper(new NamedJcaJceHelper(providerName));\r\n    return this;\r\n}"
}, {
	"Path": "javax.crypto.Cipher.getExemptionMechanism",
	"Comment": "returns the exemption mechanism object used with this cipher.",
	"Method": "ExemptionMechanism getExemptionMechanism(){\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPEncryptedDataList.isEmpty",
	"Comment": "returns true iff there are 0 encryption methods in this list.",
	"Method": "boolean isEmpty(){\r\n    return list.isEmpty();\r\n}"
}, {
	"Path": "org.bouncycastle.cert.AttributeCertificateHolder.getIssuer",
	"Comment": "return the principals associated with the issuer attached to this holder",
	"Method": "X500Name[] getIssuer(){\r\n    if (holder.getBaseCertificateID() != null) {\r\n        return getPrincipals(holder.getBaseCertificateID().getIssuer().getNames());\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.X509v1CertificateBuilder.build",
	"Comment": "generate an x509 certificate, based on the current issuer and subjectusing the passed in signer.",
	"Method": "X509CertificateHolder build(ContentSigner signer){\r\n    tbsGen.setSignature(signer.getAlgorithmIdentifier());\r\n    return CertUtils.generateFullCert(signer, tbsGen.generateTBSCertificate());\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.gmss.GMSSSigner.initSign",
	"Comment": "initializes the signature algorithm for signing a message.",
	"Method": "void initSign(){\r\n    messDigestTrees.reset();\r\n    GMSSPrivateKeyParameters gmssPrivateKey = (GMSSPrivateKeyParameters) key;\r\n    if (gmssPrivateKey.isUsed()) {\r\n        throw new IllegalStateException(\"Private key already used\");\r\n    }\r\n    if (gmssPrivateKey.getIndex(0) >= gmssPrivateKey.getNumLeafs(0)) {\r\n        throw new IllegalStateException(\"No more signatures can be generated\");\r\n    }\r\n    this.gmssPS = gmssPrivateKey.getParameters();\r\n    this.numLayer = gmssPS.getNumOfLayers();\r\n    byte[] seed = gmssPrivateKey.getCurrentSeeds()[numLayer - 1];\r\n    byte[] OTSSeed = new byte[mdLength];\r\n    byte[] dummy = new byte[mdLength];\r\n    System.arraycopy(seed, 0, dummy, 0, mdLength);\r\n    OTSSeed = gmssRandom.nextSeed(dummy);\r\n    this.ots = new WinternitzOTSignature(OTSSeed, digestProvider.get(), gmssPS.getWinternitzParameter()[numLayer - 1]);\r\n    byte[][][] helpCurrentAuthPaths = gmssPrivateKey.getCurrentAuthPaths();\r\n    currentAuthPaths = new byte[numLayer][][];\r\n    for (int j = 0; j < numLayer; j++) {\r\n        currentAuthPaths[j] = new byte[helpCurrentAuthPaths[j].length][mdLength];\r\n        for (int i = 0; i < helpCurrentAuthPaths[j].length; i++) {\r\n            System.arraycopy(helpCurrentAuthPaths[j][i], 0, currentAuthPaths[j][i], 0, mdLength);\r\n        }\r\n    }\r\n    index = new int[numLayer];\r\n    System.arraycopy(gmssPrivateKey.getIndex(), 0, index, 0, numLayer);\r\n    byte[] helpSubtreeRootSig;\r\n    subtreeRootSig = new byte[numLayer - 1][];\r\n    for (int i = 0; i < numLayer - 1; i++) {\r\n        helpSubtreeRootSig = gmssPrivateKey.getSubtreeRootSig(i);\r\n        subtreeRootSig[i] = new byte[helpSubtreeRootSig.length];\r\n        System.arraycopy(helpSubtreeRootSig, 0, subtreeRootSig[i], 0, helpSubtreeRootSig.length);\r\n    }\r\n    gmssPrivateKey.markUsed();\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSAuthenticatedDataParser.getUnauthAttrs",
	"Comment": "return a table of the unauthenticated attributes indexed bythe oid of the attribute.",
	"Method": "AttributeTable getUnauthAttrs(){\r\n    if (unauthAttrs == null && unauthAttrNotRead) {\r\n        ASN1SetParser set = authData.getUnauthAttrs();\r\n        unauthAttrNotRead = false;\r\n        if (set != null) {\r\n            ASN1EncodableVector v = new ASN1EncodableVector();\r\n            ASN1Encodable o;\r\n            while ((o = set.readObject()) != null) {\r\n                ASN1SequenceParser seq = (ASN1SequenceParser) o;\r\n                v.add(seq.toASN1Primitive());\r\n            }\r\n            unauthAttrs = new AttributeTable(new DERSet(v));\r\n        }\r\n    }\r\n    return unauthAttrs;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.X509CertSelector.getCertificateValid",
	"Comment": "returns the certificatevalid criterion. the specified date must fallwithin the certificate validity period for thex509certificate. if null, nocertificatevalid check will be done.note that the date returned is cloned to protect againstsubsequent modifications.",
	"Method": "Date getCertificateValid(){\r\n    if (certValid != null) {\r\n        return new Date(certValid.getTime());\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.CertPathValidatorException.getMessage",
	"Comment": "returns the detail message for thiscertpathvalidatorexception.",
	"Method": "String getMessage(){\r\n    String message = super.getMessage();\r\n    if (message != null) {\r\n        return message;\r\n    }\r\n    if (cause != null) {\r\n        return cause.getMessage();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.math.ec.Tnaf.getSi",
	"Comment": "computes the auxiliary values s0 ands1 used for partial modular reduction.",
	"Method": "BigInteger[] getSi(ECCurve.AbstractF2m curve,BigInteger[] getSi,int fieldSize,int curveA,BigInteger cofactor){\r\n    byte mu = getMu(curveA);\r\n    int shifts = getShiftsForCofactor(cofactor);\r\n    int index = fieldSize + 3 - curveA;\r\n    BigInteger[] ui = getLucas(mu, index, false);\r\n    if (mu == 1) {\r\n        ui[0] = ui[0].negate();\r\n        ui[1] = ui[1].negate();\r\n    }\r\n    BigInteger dividend0 = ECConstants.ONE.add(ui[1]).shiftRight(shifts);\r\n    BigInteger dividend1 = ECConstants.ONE.add(ui[0]).shiftRight(shifts).negate();\r\n    return new BigInteger[] { dividend0, dividend1 };\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.engines.IDEAEngine.invertKey",
	"Comment": "the function to invert the encryption subkey to the decryption subkey.it also involves the multiplicative inverse and the additive inverse functions.",
	"Method": "int[] invertKey(int[] inKey){\r\n    int t1, t2, t3, t4;\r\n    int p = 52;\r\n    int[] key = new int[52];\r\n    int inOff = 0;\r\n    t1 = mulInv(inKey[inOff++]);\r\n    t2 = addInv(inKey[inOff++]);\r\n    t3 = addInv(inKey[inOff++]);\r\n    t4 = mulInv(inKey[inOff++]);\r\n    key[--p] = t4;\r\n    key[--p] = t3;\r\n    key[--p] = t2;\r\n    key[--p] = t1;\r\n    for (int round = 1; round < 8; round++) {\r\n        t1 = inKey[inOff++];\r\n        t2 = inKey[inOff++];\r\n        key[--p] = t2;\r\n        key[--p] = t1;\r\n        t1 = mulInv(inKey[inOff++]);\r\n        t2 = addInv(inKey[inOff++]);\r\n        t3 = addInv(inKey[inOff++]);\r\n        t4 = mulInv(inKey[inOff++]);\r\n        key[--p] = t4;\r\n        key[--p] = t2;\r\n        key[--p] = t3;\r\n        key[--p] = t1;\r\n    }\r\n    t1 = inKey[inOff++];\r\n    t2 = inKey[inOff++];\r\n    key[--p] = t2;\r\n    key[--p] = t1;\r\n    t1 = mulInv(inKey[inOff++]);\r\n    t2 = addInv(inKey[inOff++]);\r\n    t3 = addInv(inKey[inOff++]);\r\n    t4 = mulInv(inKey[inOff]);\r\n    key[--p] = t4;\r\n    key[--p] = t3;\r\n    key[--p] = t2;\r\n    key[--p] = t1;\r\n    return key;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.jcajce.JcaX509CertificateConverter.getCertificate",
	"Comment": "use the configured converter to produce a x509certificate object from a x509certificateholder object.",
	"Method": "X509Certificate getCertificate(X509CertificateHolder certHolder){\r\n    try {\r\n        CertificateFactory cFact = helper.getCertificateFactory(\"X.509\");\r\n        return (X509Certificate) cFact.generateCertificate(new ByteArrayInputStream(certHolder.getEncoded()));\r\n    } catch (IOException e) {\r\n        throw new ExCertificateParsingException(\"exception parsing certificate: \" + e.getMessage(), e);\r\n    } catch (NoSuchProviderException e) {\r\n        throw new ExCertificateException(\"cannot find required provider:\" + e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPSignature.getEncoded",
	"Comment": "return an encoding of the signature, with trust packets stripped out if fortransfer is true.",
	"Method": "byte[] getEncoded(byte[] getEncoded,boolean forTransfer){\r\n    ByteArrayOutputStream bOut = new ByteArrayOutputStream();\r\n    this.encode(bOut, forTransfer);\r\n    return bOut.toByteArray();\r\n}"
}, {
	"Path": "org.bouncycastle.x509.X509AttributeCertStoreSelector.setAttributeCertificateValid",
	"Comment": "set the time, when the certificate must be valid. if nullis given any will do.",
	"Method": "void setAttributeCertificateValid(Date attributeCertificateValid){\r\n    if (attributeCertificateValid != null) {\r\n        this.attributeCertificateValid = new Date(attributeCertificateValid.getTime());\r\n    } else {\r\n        this.attributeCertificateValid = null;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSSignedGenerator.addSignerInfoGenerator",
	"Comment": "add a generator for a particular signer to this cms signeddata generator.",
	"Method": "void addSignerInfoGenerator(SignerInfoGenerator infoGen){\r\n    signerGens.add(infoGen);\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.gmss.GMSSSigner.initVerify",
	"Comment": "initializes the signature algorithm for verifying a signature.",
	"Method": "void initVerify(){\r\n    messDigestTrees.reset();\r\n    GMSSPublicKeyParameters gmssPublicKey = (GMSSPublicKeyParameters) key;\r\n    pubKeyBytes = gmssPublicKey.getPublicKey();\r\n    gmssPS = gmssPublicKey.getParameters();\r\n    this.numLayer = gmssPS.getNumOfLayers();\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM.modDiv",
	"Comment": "compute the result of the division of this polynomial by anotherpolynomial modulo a third polynomial.",
	"Method": "PolynomialGF2mSmallM modDiv(PolynomialGF2mSmallM divisor,PolynomialGF2mSmallM modulus,int[] modDiv,int[] a,int[] b,int[] g){\r\n    int[] r0 = normalForm(g);\r\n    int[] r1 = mod(b, g);\r\n    int[] s0 = { 0 };\r\n    int[] s1 = mod(a, g);\r\n    int[] s2;\r\n    int[][] q;\r\n    while (computeDegree(r1) != -1) {\r\n        q = div(r0, r1);\r\n        r0 = normalForm(r1);\r\n        r1 = normalForm(q[1]);\r\n        s2 = add(s0, modMultiply(q[0], s1, g));\r\n        s0 = normalForm(s1);\r\n        s1 = normalForm(s2);\r\n    }\r\n    int hc = headCoefficient(r0);\r\n    s0 = multWithElement(s0, field.inverse(hc));\r\n    return s0;\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.setPrivateKeyValid",
	"Comment": "sets the privatekeyvalid criterion. the specified date must fall withinthe private key validity period for the x509certificate. ifnull, no privatekeyvalid check will be done.note that the date supplied here is cloned to protect against subsequentmodifications.",
	"Method": "void setPrivateKeyValid(Date privateKeyValid){\r\n    if (privateKeyValid == null) {\r\n        this.privateKeyValid = null;\r\n    } else {\r\n        this.privateKeyValid = new Date(privateKeyValid.getTime());\r\n    }\r\n}"
}, {
	"Path": "javax.crypto.spec.RC2ParameterSpec.getIV",
	"Comment": "returns the iv or null if this parameter set does not contain an iv.",
	"Method": "byte[] getIV(){\r\n    if (iv == null) {\r\n        return null;\r\n    }\r\n    byte[] tmp = new byte[iv.length];\r\n    System.arraycopy(iv, 0, tmp, 0, tmp.length);\r\n    return tmp;\r\n}"
}, {
	"Path": "org.bouncycastle.mail.smime.SMIMECompressedGenerator.generate",
	"Comment": "generate an compressed object that contains an smime compressedobject using the given provider from the contents of the passed inmessage",
	"Method": "MimeBodyPart generate(MimeBodyPart content,OutputCompressor compressor,MimeBodyPart generate,MimeMessage message,OutputCompressor compressor){\r\n    try {\r\n        message.saveChanges();\r\n    } catch (MessagingException e) {\r\n        throw new SMIMEException(\"unable to save message\", e);\r\n    }\r\n    return make(makeContentBodyPart(message), compressor);\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.X509CertSelector.getPrivateKeyValid",
	"Comment": "returns the privatekeyvalid criterion. the specified date must fallwithin the private key validity period for thex509certificate. if null, noprivatekeyvalid check will be done.note that the date returned is cloned to protect againstsubsequent modifications.",
	"Method": "Date getPrivateKeyValid(){\r\n    if (privateKeyValid != null) {\r\n        return new Date(privateKeyValid.getTime());\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.ch2_tab.BETabbedPaneUI.paintTabBorder",
	"Comment": "this function draws the border around each tab\tnote that this function does now draw the background of the tab.\tthat is done elsewhere",
	"Method": "void paintTabBorder(Graphics g,int tabPlacement,int tabIndex,int x,int y,int w,int h,boolean isSelected){\r\n    Graphics2D g2d = (Graphics2D) g.create();\r\n    g2d.translate(x, y);\r\n    boolean isRover = (this.getRolloverTab() == tabIndex);\r\n    boolean isEnableAt = this.tabPane.isEnabledAt(tabIndex);\r\n    switch(tabPlacement) {\r\n        case LEFT:\r\n            g2d.scale(-1.0, 1.0);\r\n            g2d.rotate(Math.toRadians(90.0));\r\n            paintTabBorderImpl(g2d, isEnableAt, isSelected, isRover, 0, 0, h, w);\r\n            break;\r\n        case RIGHT:\r\n            g2d.translate(w, 0);\r\n            g2d.rotate(Math.toRadians(90.0));\r\n            paintTabBorderImpl(g2d, isEnableAt, isSelected, isRover, 0, 0, h, w);\r\n            break;\r\n        case BOTTOM:\r\n            g2d.translate(0, h);\r\n            g2d.scale(-1.0, 1.0);\r\n            g2d.rotate(Math.toRadians(180.0));\r\n            paintTabBorderImpl(g2d, isEnableAt, isSelected, isRover, 0, 0, w, h);\r\n            break;\r\n        case TOP:\r\n        default:\r\n            paintTabBorderImpl(g2d, isEnableAt, isSelected, isRover, 0, 0, w, h);\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.tls.crypto.impl.jcajce.JcaTlsCrypto.createAEADCipher",
	"Comment": "if you want to create your own versions of the aead ciphers required, override this method.",
	"Method": "TlsAEADCipherImpl createAEADCipher(String cipherName,String algorithm,int keySize,boolean isEncrypting){\r\n    return new JceAEADCipherImpl(helper, cipherName, algorithm, keySize, isEncrypting);\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.provider.asymmetric.dsa.DSAUtil.isDsaOid",
	"Comment": "return true if the passed in oid could be associated with a dsa key.",
	"Method": "boolean isDsaOid(ASN1ObjectIdentifier algOid){\r\n    for (int i = 0; i != dsaOids.length; i++) {\r\n        if (algOid.equals(dsaOids[i])) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "javax.crypto.spec.SecretKeySpec.getAlgorithm",
	"Comment": "returns the name of the algorithm associated with this secret key.",
	"Method": "String getAlgorithm(){\r\n    return algorithm;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.util.OpenSSHPublicKeyUtil.encodePublicKey",
	"Comment": "encode a public key from an asymmetrickeyparameter instance.",
	"Method": "byte[] encodePublicKey(AsymmetricKeyParameter cipherParameters){\r\n    BigInteger e;\r\n    BigInteger n;\r\n    if (cipherParameters == null) {\r\n        throw new IllegalArgumentException(\"cipherParameters was null.\");\r\n    }\r\n    if (cipherParameters instanceof RSAKeyParameters) {\r\n        if (cipherParameters.isPrivate()) {\r\n            throw new IllegalArgumentException(\"RSAKeyParamaters was for encryption\");\r\n        }\r\n        e = ((RSAKeyParameters) cipherParameters).getExponent();\r\n        n = ((RSAKeyParameters) cipherParameters).getModulus();\r\n        SSHBuilder builder = new SSHBuilder();\r\n        builder.writeString(RSA);\r\n        builder.rawArray(e.toByteArray());\r\n        builder.rawArray(n.toByteArray());\r\n        return builder.getBytes();\r\n    } else if (cipherParameters instanceof ECPublicKeyParameters) {\r\n        SSHBuilder builder = new SSHBuilder();\r\n        String name = null;\r\n        if (((ECPublicKeyParameters) cipherParameters).getParameters().getCurve() instanceof SecP256R1Curve) {\r\n            name = \"nistp256\";\r\n        } else {\r\n            throw new IllegalArgumentException(\"unable to derive ssh curve name for \" + ((ECPublicKeyParameters) cipherParameters).getParameters().getCurve().getClass().getName());\r\n        }\r\n        builder.writeString(ECDSA + \"-sha2-\" + name);\r\n        builder.writeString(name);\r\n        builder.rawArray(((ECPublicKeyParameters) cipherParameters).getQ().getEncoded(false));\r\n        return builder.getBytes();\r\n    } else if (cipherParameters instanceof DSAPublicKeyParameters) {\r\n        SSHBuilder builder = new SSHBuilder();\r\n        builder.writeString(DSS);\r\n        builder.rawArray(((DSAPublicKeyParameters) cipherParameters).getParameters().getP().toByteArray());\r\n        builder.rawArray(((DSAPublicKeyParameters) cipherParameters).getParameters().getQ().toByteArray());\r\n        builder.rawArray(((DSAPublicKeyParameters) cipherParameters).getParameters().getG().toByteArray());\r\n        builder.rawArray(((DSAPublicKeyParameters) cipherParameters).getY().toByteArray());\r\n        return builder.getBytes();\r\n    } else if (cipherParameters instanceof Ed25519PublicKeyParameters) {\r\n        SSHBuilder builder = new SSHBuilder();\r\n        builder.writeString(ED_25519);\r\n        builder.rawArray(((Ed25519PublicKeyParameters) cipherParameters).getEncoded());\r\n        return builder.getBytes();\r\n    }\r\n    throw new IllegalArgumentException(\"unable to convert \" + cipherParameters.getClass().getName() + \" to private key\");\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPSecretKeyRing.replacePublicKeys",
	"Comment": "replace the public key set on the secret ring with the corresponding key off the public ring.",
	"Method": "PGPSecretKeyRing replacePublicKeys(PGPSecretKeyRing secretRing,PGPPublicKeyRing publicRing){\r\n    List newList = new ArrayList(secretRing.keys.size());\r\n    for (Iterator it = secretRing.keys.iterator(); it.hasNext(); ) {\r\n        PGPSecretKey sk = (PGPSecretKey) it.next();\r\n        PGPPublicKey pk = publicRing.getPublicKey(sk.getKeyID());\r\n        newList.add(PGPSecretKey.replacePublicKey(sk, pk));\r\n    }\r\n    return new PGPSecretKeyRing(newList);\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2nPolynomial.add",
	"Comment": "adds the polynomialgf2n b to this and returns theresult in a new polynomialgf2n.",
	"Method": "GF2nPolynomial add(GF2nPolynomial b){\r\n    GF2nPolynomial result;\r\n    if (size() >= b.size()) {\r\n        result = new GF2nPolynomial(size());\r\n        int i;\r\n        for (i = 0; i < b.size(); i++) {\r\n            result.coeff[i] = (GF2nElement) coeff[i].add(b.coeff[i]);\r\n        }\r\n        for (; i < size(); i++) {\r\n            result.coeff[i] = coeff[i];\r\n        }\r\n    } else {\r\n        result = new GF2nPolynomial(b.size());\r\n        int i;\r\n        for (i = 0; i < size(); i++) {\r\n            result.coeff[i] = (GF2nElement) coeff[i].add(b.coeff[i]);\r\n        }\r\n        for (; i < b.size(); i++) {\r\n            result.coeff[i] = b.coeff[i];\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "javax.crypto.CipherInputStream.available",
	"Comment": "returns the number of bytes that can be read from this input stream without blocking. the available method of inputstream returns 0. this method should be overridden by subclasses.",
	"Method": "int available(){\r\n    return maxBuf - bufOff;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.DEROctetStringParser.getOctetStream",
	"Comment": "return an inputstream representing the contents of the octet string.",
	"Method": "InputStream getOctetStream(){\r\n    return stream;\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSEnvelopedDataParser.getUnprotectedAttributes",
	"Comment": "return a table of the unprotected attributes indexed bythe oid of the attribute.",
	"Method": "AttributeTable getUnprotectedAttributes(){\r\n    if (unprotectedAttributes == null && attrNotRead) {\r\n        ASN1SetParser set = envelopedData.getUnprotectedAttrs();\r\n        attrNotRead = false;\r\n        if (set != null) {\r\n            ASN1EncodableVector v = new ASN1EncodableVector();\r\n            ASN1Encodable o;\r\n            while ((o = set.readObject()) != null) {\r\n                ASN1SequenceParser seq = (ASN1SequenceParser) o;\r\n                v.add(seq.toASN1Primitive());\r\n            }\r\n            unprotectedAttributes = new AttributeTable(new DERSet(v));\r\n        }\r\n    }\r\n    return unprotectedAttributes;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.digests.MD2Digest.getDigestSize",
	"Comment": "return the size, in bytes, of the digest produced by this message digest.",
	"Method": "int getDigestSize(){\r\n    return DIGEST_LENGTH;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.prng.SP800SecureRandomBuilder.setEntropyBitsRequired",
	"Comment": "set the amount of entropy bits required for seeding and reseeding drbgs used in building securerandom objects.",
	"Method": "SP800SecureRandomBuilder setEntropyBitsRequired(int entropyBitsRequired){\r\n    this.entropyBitsRequired = entropyBitsRequired;\r\n    return this;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.gmss.Treehash.wasInitialized",
	"Comment": "method to check whether the instance has been initialized or not",
	"Method": "boolean wasInitialized(){\r\n    return this.isInitialized;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.provider.JCEDHPrivateKey.getEncoded",
	"Comment": "return a pkcs8 representation of the key. the sequence returnedrepresents a full privatekeyinfo object.",
	"Method": "byte[] getEncoded(){\r\n    try {\r\n        if (info != null) {\r\n            return info.getEncoded(ASN1Encoding.DER);\r\n        }\r\n        PrivateKeyInfo info = new PrivateKeyInfo(new AlgorithmIdentifier(PKCSObjectIdentifiers.dhKeyAgreement, new DHParameter(dhSpec.getP(), dhSpec.getG(), dhSpec.getL())), new ASN1Integer(getX()));\r\n        return info.getEncoded(ASN1Encoding.DER);\r\n    } catch (IOException e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.util.encoders.Hex.decode",
	"Comment": "decode the hex encoded string data writing it to the given output stream,whitespace characters will be ignored.",
	"Method": "byte[] decode(byte[] data,byte[] decode,String data,int decode,String data,OutputStream out){\r\n    return encoder.decode(data, out);\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.X509CertSelector.getCertificate",
	"Comment": "returns the certificateequals criterion. the specifiedx509certificate must be equal to thex509certificate passed to the match method. ifnull, this check is not applied.",
	"Method": "X509Certificate getCertificate(){\r\n    return x509Cert;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.x509.Targets.getTargets",
	"Comment": "returns the targets in a vector.the vector is cloned before it is returned.",
	"Method": "Target[] getTargets(){\r\n    Target[] targs = new Target[targets.size()];\r\n    int count = 0;\r\n    for (Enumeration e = targets.getObjects(); e.hasMoreElements(); ) {\r\n        targs[count++] = Target.getInstance(e.nextElement());\r\n    }\r\n    return targs;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.modes.CTSBlockCipher.getOutputSize",
	"Comment": "return the size of the output buffer required for an update plus adofinal with an input of len bytes.",
	"Method": "int getOutputSize(int len){\r\n    return len + bufOff;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.X509v2CRLBuilder.addCRLEntry",
	"Comment": "add a crl entry with an invaliditydate extension as well as a reasoncode extension. this is usedwhere the date of revocation might be after issues with the certificate may have occurred.",
	"Method": "X509v2CRLBuilder addCRLEntry(BigInteger userCertificateSerial,Date revocationDate,int reason,X509v2CRLBuilder addCRLEntry,BigInteger userCertificateSerial,Date revocationDate,int reason,Date invalidityDate,X509v2CRLBuilder addCRLEntry,BigInteger userCertificateSerial,Date revocationDate,Extensions extensions){\r\n    tbsGen.addCRLEntry(new ASN1Integer(userCertificateSerial), new Time(revocationDate), extensions);\r\n    return this;\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.util.AlgorithmParametersUtils.extractParameters",
	"Comment": "extract an asn.1 encodable from an algorithmparameters object.",
	"Method": "ASN1Encodable extractParameters(AlgorithmParameters params){\r\n    ASN1Encodable asn1Params;\r\n    try {\r\n        asn1Params = ASN1Primitive.fromByteArray(params.getEncoded(\"ASN.1\"));\r\n    } catch (Exception ex) {\r\n        asn1Params = ASN1Primitive.fromByteArray(params.getEncoded());\r\n    }\r\n    return asn1Params;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.CertUtil.trimX509Name",
	"Comment": "returns the given name converted to upper case and all multi spaces squezedto one space.",
	"Method": "String trimX509Name(String name){\r\n    String data = Strings.toUpperCase(name.trim());\r\n    int pos;\r\n    while ((pos = data.indexOf(\"  \")) >= 0) {\r\n        data = data.substring(0, pos) + data.substring(pos + 1);\r\n    }\r\n    while ((pos = data.indexOf(\" =\")) >= 0) {\r\n        data = data.substring(0, pos) + data.substring(pos + 1);\r\n    }\r\n    while ((pos = data.indexOf(\"= \")) >= 0) {\r\n        data = data.substring(0, pos + 1) + data.substring(pos + 2);\r\n    }\r\n    return data;\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPPrivateKey.getPrivateKeyDataPacket",
	"Comment": "return the private key packet associated with this private key, if available.",
	"Method": "BCPGKey getPrivateKeyDataPacket(){\r\n    return privateKeyDataPacket;\r\n}"
}, {
	"Path": "org.bouncycastle.util.encoders.Base64.encode",
	"Comment": "encode the byte data to base 64 writing it to the given output stream.",
	"Method": "byte[] encode(byte[] data,byte[] encode,byte[] data,int off,int length,int encode,byte[] data,OutputStream out,int encode,byte[] data,int off,int length,OutputStream out){\r\n    return encoder.encode(data, off, length, out);\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.x509.X509ExtensionsGenerator.isEmpty",
	"Comment": "return true if there are no extension present in this generator.",
	"Method": "boolean isEmpty(){\r\n    return extOrdering.isEmpty();\r\n}"
}, {
	"Path": "org.bouncycastle.operator.jcajce.JceInputDecryptorProviderBuilder.build",
	"Comment": "build a decryptor provider which will use the passed in bytes for the symmetric key.",
	"Method": "InputDecryptorProvider build(byte[] keyBytes){\r\n    final byte[] encKeyBytes = Arrays.clone(keyBytes);\r\n    return new InputDecryptorProvider() {\r\n        private Cipher cipher;\r\n        private AlgorithmIdentifier encryptionAlg;\r\n        public InputDecryptor get(final AlgorithmIdentifier algorithmIdentifier) throws OperatorCreationException {\r\n            encryptionAlg = algorithmIdentifier;\r\n            ASN1ObjectIdentifier algorithm = algorithmIdentifier.getAlgorithm();\r\n            try {\r\n                cipher = helper.createCipher(algorithm.getId());\r\n                SecretKey key = new SecretKeySpec(encKeyBytes, algorithm.getId());\r\n                ASN1Encodable encParams = algorithmIdentifier.getParameters();\r\n                if (encParams instanceof ASN1OctetString) {\r\n                    cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(ASN1OctetString.getInstance(encParams).getOctets()));\r\n                } else {\r\n                    GOST28147Parameters gParams = GOST28147Parameters.getInstance(encParams);\r\n                    cipher.init(Cipher.DECRYPT_MODE, key, new GOST28147ParameterSpec(gParams.getEncryptionParamSet(), gParams.getIV()));\r\n                }\r\n            } catch (Exception e) {\r\n                throw new OperatorCreationException(\"unable to create InputDecryptor: \" + e.getMessage(), e);\r\n            }\r\n            return new InputDecryptor() {\r\n                public AlgorithmIdentifier getAlgorithmIdentifier() {\r\n                    return encryptionAlg;\r\n                }\r\n                public InputStream getInputStream(InputStream input) {\r\n                    return new CipherInputStream(input, cipher);\r\n                }\r\n            };\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.bouncycastle.operator.jcajce.JceInputDecryptorProviderBuilder.build",
	"Comment": "build a decryptor provider which will use the passed in bytes for the symmetric key.",
	"Method": "InputDecryptorProvider build(byte[] keyBytes){\r\n    encryptionAlg = algorithmIdentifier;\r\n    ASN1ObjectIdentifier algorithm = algorithmIdentifier.getAlgorithm();\r\n    try {\r\n        cipher = helper.createCipher(algorithm.getId());\r\n        SecretKey key = new SecretKeySpec(encKeyBytes, algorithm.getId());\r\n        ASN1Encodable encParams = algorithmIdentifier.getParameters();\r\n        if (encParams instanceof ASN1OctetString) {\r\n            cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(ASN1OctetString.getInstance(encParams).getOctets()));\r\n        } else {\r\n            GOST28147Parameters gParams = GOST28147Parameters.getInstance(encParams);\r\n            cipher.init(Cipher.DECRYPT_MODE, key, new GOST28147ParameterSpec(gParams.getEncryptionParamSet(), gParams.getIV()));\r\n        }\r\n    } catch (Exception e) {\r\n        throw new OperatorCreationException(\"unable to create InputDecryptor: \" + e.getMessage(), e);\r\n    }\r\n    return new InputDecryptor() {\r\n        public AlgorithmIdentifier getAlgorithmIdentifier() {\r\n            return encryptionAlg;\r\n        }\r\n        public InputStream getInputStream(InputStream input) {\r\n            return new CipherInputStream(input, cipher);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.bouncycastle.operator.jcajce.JceInputDecryptorProviderBuilder.build",
	"Comment": "build a decryptor provider which will use the passed in bytes for the symmetric key.",
	"Method": "InputDecryptorProvider build(byte[] keyBytes){\r\n    return encryptionAlg;\r\n}"
}, {
	"Path": "org.bouncycastle.operator.jcajce.JceInputDecryptorProviderBuilder.build",
	"Comment": "build a decryptor provider which will use the passed in bytes for the symmetric key.",
	"Method": "InputDecryptorProvider build(byte[] keyBytes){\r\n    return new CipherInputStream(input, cipher);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.engines.CAST6Engine.setKey",
	"Comment": "creates the subkeys using the same nomenclatureas described in rfc2612.see section 2.4",
	"Method": "void setKey(byte[] key){\r\n    int Cm = 0x5a827999;\r\n    int Mm = 0x6ed9eba1;\r\n    int Cr = 19;\r\n    int Mr = 17;\r\n    for (int i = 0; i < 24; i++) {\r\n        for (int j = 0; j < 8; j++) {\r\n            _Tm[i * 8 + j] = Cm;\r\n            Cm = (Cm + Mm);\r\n            _Tr[i * 8 + j] = Cr;\r\n            Cr = (Cr + Mr) & 0x1f;\r\n        }\r\n    }\r\n    byte[] tmpKey = new byte[64];\r\n    int length = key.length;\r\n    System.arraycopy(key, 0, tmpKey, 0, length);\r\n    for (int i = 0; i < 8; i++) {\r\n        _workingKey[i] = BytesTo32bits(tmpKey, i * 4);\r\n    }\r\n    for (int i = 0; i < 12; i++) {\r\n        int i2 = i * 2 * 8;\r\n        _workingKey[6] ^= F1(_workingKey[7], _Tm[i2], _Tr[i2]);\r\n        _workingKey[5] ^= F2(_workingKey[6], _Tm[i2 + 1], _Tr[i2 + 1]);\r\n        _workingKey[4] ^= F3(_workingKey[5], _Tm[i2 + 2], _Tr[i2 + 2]);\r\n        _workingKey[3] ^= F1(_workingKey[4], _Tm[i2 + 3], _Tr[i2 + 3]);\r\n        _workingKey[2] ^= F2(_workingKey[3], _Tm[i2 + 4], _Tr[i2 + 4]);\r\n        _workingKey[1] ^= F3(_workingKey[2], _Tm[i2 + 5], _Tr[i2 + 5]);\r\n        _workingKey[0] ^= F1(_workingKey[1], _Tm[i2 + 6], _Tr[i2 + 6]);\r\n        _workingKey[7] ^= F2(_workingKey[0], _Tm[i2 + 7], _Tr[i2 + 7]);\r\n        i2 = (i * 2 + 1) * 8;\r\n        _workingKey[6] ^= F1(_workingKey[7], _Tm[i2], _Tr[i2]);\r\n        _workingKey[5] ^= F2(_workingKey[6], _Tm[i2 + 1], _Tr[i2 + 1]);\r\n        _workingKey[4] ^= F3(_workingKey[5], _Tm[i2 + 2], _Tr[i2 + 2]);\r\n        _workingKey[3] ^= F1(_workingKey[4], _Tm[i2 + 3], _Tr[i2 + 3]);\r\n        _workingKey[2] ^= F2(_workingKey[3], _Tm[i2 + 4], _Tr[i2 + 4]);\r\n        _workingKey[1] ^= F3(_workingKey[2], _Tm[i2 + 5], _Tr[i2 + 5]);\r\n        _workingKey[0] ^= F1(_workingKey[1], _Tm[i2 + 6], _Tr[i2 + 6]);\r\n        _workingKey[7] ^= F2(_workingKey[0], _Tm[i2 + 7], _Tr[i2 + 7]);\r\n        _Kr[i * 4] = _workingKey[0] & 0x1f;\r\n        _Kr[i * 4 + 1] = _workingKey[2] & 0x1f;\r\n        _Kr[i * 4 + 2] = _workingKey[4] & 0x1f;\r\n        _Kr[i * 4 + 3] = _workingKey[6] & 0x1f;\r\n        _Km[i * 4] = _workingKey[7];\r\n        _Km[i * 4 + 1] = _workingKey[5];\r\n        _Km[i * 4 + 2] = _workingKey[3];\r\n        _Km[i * 4 + 3] = _workingKey[1];\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.nist.NISTNamedCurves.getOID",
	"Comment": "return the object identifier signified by the passed in name. nullif there is no object identifier associated with name.",
	"Method": "ASN1ObjectIdentifier getOID(String name){\r\n    return (ASN1ObjectIdentifier) objIds.get(Strings.toUpperCase(name));\r\n}"
}, {
	"Path": "org.bouncycastle.util.Properties.removeThreadOverride",
	"Comment": "enable the specified override property in the current thread only.",
	"Method": "boolean removeThreadOverride(String propertyName){\r\n    boolean isSet = isOverrideSet(propertyName);\r\n    Map localProps = (Map) threadProperties.get();\r\n    if (localProps == null) {\r\n        return false;\r\n    }\r\n    localProps.remove(propertyName);\r\n    threadProperties.set(localProps);\r\n    return isSet;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2nPolynomialField.computeFieldPolynomial",
	"Comment": "computes the field polynomial. this can take a long time for big degrees.",
	"Method": "void computeFieldPolynomial(){\r\n    if (testTrinomials()) {\r\n        return;\r\n    }\r\n    if (testPentanomials()) {\r\n        return;\r\n    }\r\n    testRandom();\r\n}"
}, {
	"Path": "org.bouncycastle.mail.smime.SMIMESignedGenerator.generateCertificateManagement",
	"Comment": "creates a certificate management message which is like a signed message with no contentor signers but that still carries certificates and crls.",
	"Method": "MimeBodyPart generateCertificateManagement(){\r\n    try {\r\n        MimeBodyPart sig = new MimeBodyPart();\r\n        sig.setContent(new ContentSigner(null, true), CERTIFICATE_MANAGEMENT_CONTENT);\r\n        sig.addHeader(\"Content-Type\", CERTIFICATE_MANAGEMENT_CONTENT);\r\n        sig.addHeader(\"Content-Disposition\", \"attachment; filename=\\\"smime.p7c\\\"\");\r\n        sig.addHeader(\"Content-Description\", \"S/MIME Certificate Management Message\");\r\n        sig.addHeader(\"Content-Transfer-Encoding\", encoding);\r\n        return sig;\r\n    } catch (MessagingException e) {\r\n        throw new SMIMEException(\"exception putting body part together.\", e);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSSignedData.getDigestAlgorithmIDs",
	"Comment": "return the digest algorithm identifiers for the signeddata object",
	"Method": "Set<AlgorithmIdentifier> getDigestAlgorithmIDs(){\r\n    Set<AlgorithmIdentifier> digests = new HashSet<AlgorithmIdentifier>(signedData.getDigestAlgorithms().size());\r\n    for (Enumeration en = signedData.getDigestAlgorithms().getObjects(); en.hasMoreElements(); ) {\r\n        digests.add(AlgorithmIdentifier.getInstance(en.nextElement()));\r\n    }\r\n    return Collections.unmodifiableSet(digests);\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSAuthenticatedData.getMacAlgorithm",
	"Comment": "return the mac algorithm details for the mac associated with the data in this object.",
	"Method": "AlgorithmIdentifier getMacAlgorithm(){\r\n    return macAlg;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.engines.BlowfishEngine.encryptBlock",
	"Comment": "encrypt the given input starting at the given offset and placethe result in the provided buffer starting at the given offset.the input will be an exact multiple of our blocksize.",
	"Method": "void encryptBlock(byte[] src,int srcIndex,byte[] dst,int dstIndex){\r\n    int xl = BytesTo32bits(src, srcIndex);\r\n    int xr = BytesTo32bits(src, srcIndex + 4);\r\n    xl ^= P[0];\r\n    for (int i = 1; i < ROUNDS; i += 2) {\r\n        xr ^= F(xl) ^ P[i];\r\n        xl ^= F(xr) ^ P[i + 1];\r\n    }\r\n    xr ^= P[ROUNDS + 1];\r\n    Bits32ToBytes(xr, dst, dstIndex);\r\n    Bits32ToBytes(xl, dst, dstIndex + 4);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.generators.PKCS5S2ParametersGenerator.generateDerivedMacParameters",
	"Comment": "generate a key parameter for use with a mac derived from the password,salt, and iteration count we are currently initialised with.",
	"Method": "CipherParameters generateDerivedMacParameters(int keySize){\r\n    return generateDerivedParameters(keySize);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.engines.CAST5Engine.decryptBlock",
	"Comment": "decrypt the given input starting at the given offset and placethe result in the provided buffer starting at the given offset.",
	"Method": "int decryptBlock(byte[] src,int srcIndex,byte[] dst,int dstIndex){\r\n    int[] result = new int[2];\r\n    int L16 = BytesTo32bits(src, srcIndex);\r\n    int R16 = BytesTo32bits(src, srcIndex + 4);\r\n    CAST_Decipher(L16, R16, result);\r\n    Bits32ToBytes(result[0], dst, dstIndex);\r\n    Bits32ToBytes(result[1], dst, dstIndex + 4);\r\n    return BLOCK_SIZE;\r\n}"
}, {
	"Path": "org.bouncycastle.openssl.X509TrustedCertificateBlock.getCertificateHolder",
	"Comment": "return the certificate associated with this trusted certificate",
	"Method": "X509CertificateHolder getCertificateHolder(){\r\n    return certificateHolder;\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSSignedDataParser.replaceSigners",
	"Comment": "replace the signerinformation store associated with the passedin message contained in the stream original with the new one passed in.you would probably only want to do this if you wanted to change the unsignedattributes associated with a signer, or perhaps delete one.the output stream is returned unclosed.",
	"Method": "OutputStream replaceSigners(InputStream original,SignerInformationStore signerInformationStore,OutputStream out){\r\n    ASN1StreamParser in = new ASN1StreamParser(original);\r\n    ContentInfoParser contentInfo = new ContentInfoParser((ASN1SequenceParser) in.readObject());\r\n    SignedDataParser signedData = SignedDataParser.getInstance(contentInfo.getContent(BERTags.SEQUENCE));\r\n    BERSequenceGenerator sGen = new BERSequenceGenerator(out);\r\n    sGen.addObject(CMSObjectIdentifiers.signedData);\r\n    BERSequenceGenerator sigGen = new BERSequenceGenerator(sGen.getRawOutputStream(), 0, true);\r\n    sigGen.addObject(signedData.getVersion());\r\n    signedData.getDigestAlgorithms().toASN1Primitive();\r\n    ASN1EncodableVector digestAlgs = new ASN1EncodableVector();\r\n    for (Iterator it = signerInformationStore.getSigners().iterator(); it.hasNext(); ) {\r\n        SignerInformation signer = (SignerInformation) it.next();\r\n        digestAlgs.add(CMSSignedHelper.INSTANCE.fixAlgID(signer.getDigestAlgorithmID()));\r\n    }\r\n    sigGen.getRawOutputStream().write(new DERSet(digestAlgs).getEncoded());\r\n    ContentInfoParser encapContentInfo = signedData.getEncapContentInfo();\r\n    BERSequenceGenerator eiGen = new BERSequenceGenerator(sigGen.getRawOutputStream());\r\n    eiGen.addObject(encapContentInfo.getContentType());\r\n    pipeEncapsulatedOctetString(encapContentInfo, eiGen.getRawOutputStream());\r\n    eiGen.close();\r\n    writeSetToGeneratorTagged(sigGen, signedData.getCertificates(), 0);\r\n    writeSetToGeneratorTagged(sigGen, signedData.getCrls(), 1);\r\n    ASN1EncodableVector signerInfos = new ASN1EncodableVector();\r\n    for (Iterator it = signerInformationStore.getSigners().iterator(); it.hasNext(); ) {\r\n        SignerInformation signer = (SignerInformation) it.next();\r\n        signerInfos.add(signer.toASN1Structure());\r\n    }\r\n    sigGen.getRawOutputStream().write(new DERSet(signerInfos).getEncoded());\r\n    sigGen.close();\r\n    sGen.close();\r\n    return out;\r\n}"
}, {
	"Path": "java.security.cert.CertPath.toString",
	"Comment": "returns a string representation of this certificationpath. this calls the tostring method on each of thecertificates in the path.",
	"Method": "String toString(){\r\n    StringBuffer s = new StringBuffer();\r\n    List certs = getCertificates();\r\n    ListIterator iter = certs.listIterator();\r\n    s.append('\\n').append(getType()).append(\" Cert Path: length = \").append(certs.size()).append(\"\\n[\\n\");\r\n    while (iter.hasNext()) {\r\n        s.append(\"=========================================================Certificate \").append(iter.nextIndex()).append('\\n');\r\n        s.append(iter.next()).append('\\n');\r\n        s.append(\"========================================================Certificate end\\n\\n\\n\");\r\n    }\r\n    s.append(\"\\n]\");\r\n    return s.toString();\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.crmf.POPOSigningKeyInput.getPublicKeyMAC",
	"Comment": "returns the publickeymac field, or null if authinfo is sender",
	"Method": "PKMACValue getPublicKeyMAC(){\r\n    return publicKeyMAC;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.X509CertificateHolder.toASN1Structure",
	"Comment": "return the underlying asn.1 structure for the certificate in this holder.",
	"Method": "Certificate toASN1Structure(){\r\n    return x509Certificate;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.gmss.util.WinternitzOTSignature.getLog",
	"Comment": "this method returns the least integer that is greater or equal to thelogarithm to the base 2 of an integer intvalue.",
	"Method": "int getLog(int intValue){\r\n    int log = 1;\r\n    int i = 2;\r\n    while (i < intValue) {\r\n        i <<= 1;\r\n        log++;\r\n    }\r\n    return log;\r\n}"
}, {
	"Path": "org.bouncycastle.x509.CertPathValidatorUtilities.getNextWorkingKey",
	"Comment": "return the next working key inheriting dsa parameters if necessary.this methods inherits dsa parameters from the indexed certificate orprevious certificates in the certificate chain to the returnedpublickey. the list is searched upwards, meaning the endcertificate is at position 0 and previous certificates are following.if the indexed certificate does not contain a dsa key this method simplyreturns the public key. if the dsa key already contains dsa parametersthe key is also only returned.",
	"Method": "PublicKey getNextWorkingKey(List certs,int index){\r\n    Certificate cert = (Certificate) certs.get(index);\r\n    PublicKey pubKey = cert.getPublicKey();\r\n    if (!(pubKey instanceof DSAPublicKey)) {\r\n        return pubKey;\r\n    }\r\n    DSAPublicKey dsaPubKey = (DSAPublicKey) pubKey;\r\n    if (dsaPubKey.getParams() != null) {\r\n        return dsaPubKey;\r\n    }\r\n    for (int i = index + 1; i < certs.size(); i++) {\r\n        X509Certificate parentCert = (X509Certificate) certs.get(i);\r\n        pubKey = parentCert.getPublicKey();\r\n        if (!(pubKey instanceof DSAPublicKey)) {\r\n            throw new CertPathValidatorException(\"DSA parameters cannot be inherited from previous certificate.\");\r\n        }\r\n        DSAPublicKey prevDSAPubKey = (DSAPublicKey) pubKey;\r\n        if (prevDSAPubKey.getParams() == null) {\r\n            continue;\r\n        }\r\n        DSAParams dsaParams = prevDSAPubKey.getParams();\r\n        DSAPublicKeySpec dsaPubKeySpec = new DSAPublicKeySpec(dsaPubKey.getY(), dsaParams.getP(), dsaParams.getQ(), dsaParams.getG());\r\n        try {\r\n            KeyFactory keyFactory = KeyFactory.getInstance(\"DSA\", BouncyCastleProvider.PROVIDER_NAME);\r\n            return keyFactory.generatePublic(dsaPubKeySpec);\r\n        } catch (Exception exception) {\r\n            throw new RuntimeException(exception.getMessage());\r\n        }\r\n    }\r\n    throw new CertPathValidatorException(\"DSA parameters cannot be inherited from previous certificate.\");\r\n}"
}, {
	"Path": "java.security.cert.CertPathBuilder.build",
	"Comment": "attempts to build a certification path using the specified algorithmparameter set.",
	"Method": "CertPathBuilderResult build(CertPathParameters params){\r\n    return builderSpi.engineBuild(params);\r\n}"
}, {
	"Path": "org.bouncycastle.cms.RecipientInformationStore.get",
	"Comment": "return the first recipientinformation object that matches thepassed in selector. null if there are no matches.",
	"Method": "RecipientInformation get(RecipientId selector){\r\n    Collection list = getRecipients(selector);\r\n    return list.size() == 0 ? null : (RecipientInformation) list.iterator().next();\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.BEROctetString.getOctets",
	"Comment": "return a concatenated byte array of all the octets making up the constructed octet string",
	"Method": "byte[] getOctets(){\r\n    return string;\r\n}"
}, {
	"Path": "java.security.cert.PKIXCertPathBuilderResult.toString",
	"Comment": "return a printable representation of this pkixcertpathbuilderresult.",
	"Method": "String toString(){\r\n    StringBuffer s = new StringBuffer();\r\n    s.append(\"PKIXCertPathBuilderResult: [\\n\");\r\n    s.append(\"  Certification Path: \").append(getCertPath()).append('\\n');\r\n    s.append(\"  Trust Anchor: \").append(getTrustAnchor()).append('\\n');\r\n    s.append(\"  Policy Tree: \").append(getPolicyTree()).append('\\n');\r\n    s.append(\"  Subject Public Key: \").append(getPublicKey()).append(\"\\n]\");\r\n    return s.toString();\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.digests.Blake2sDigest.getDigestSize",
	"Comment": "return the size in bytes of the digest produced by this message digest.",
	"Method": "int getDigestSize(){\r\n    return digestLength;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.selector.X509AttributeCertificateHolderSelector.getTargetNames",
	"Comment": "gets the target names. the collection consists of generalname objects.the returned collection is immutable.",
	"Method": "Collection getTargetNames(){\r\n    return targetNames;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.PKIXCertPathValidatorResult.getTrustAnchor",
	"Comment": "returns the trustanchor describing the ca that served as atrust anchor for the certification path.",
	"Method": "TrustAnchor getTrustAnchor(){\r\n    return trustAnchor;\r\n}"
}, {
	"Path": "org.bouncycastle.mail.smime.util.SharedFileInputStream.dispose",
	"Comment": "close of this stream and any substreams that have been created from it.",
	"Method": "void dispose(){\r\n    Iterator it = _subStreams.iterator();\r\n    while (it.hasNext()) {\r\n        try {\r\n            ((SharedFileInputStream) it.next()).dispose();\r\n        } catch (IOException e) {\r\n        }\r\n    }\r\n    in.close();\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.spec.TLSKeyMaterialSpec.getLength",
	"Comment": "return the number of bytes of key material to be generated for this spec.",
	"Method": "int getLength(){\r\n    return length;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.teletrust.TeleTrusTNamedCurves.getNames",
	"Comment": "returns an enumeration containing the name strings for curvescontained in this structure.",
	"Method": "Enumeration getNames(){\r\n    return names.elements();\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.CryptoServicesRegistrar.setGlobalProperty",
	"Comment": "set the value of the the passed in property globally in the jvm. more thanone value can be passed in for a sized property. if more than one value is provided thefirst value in the argument list becomes the default value.",
	"Method": "void setGlobalProperty(Property property,T propertyValue){\r\n    checkPermission(CanSetDefaultProperty);\r\n    Object[] rv = new Object[propertyValue.length];\r\n    System.arraycopy(propertyValue, 0, rv, 0, rv.length);\r\n    localSetGlobalProperty(property, rv);\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2nPolynomialElement.randomize",
	"Comment": "assign a random value to this gf2npolynomialelement using the specifiedsource of randomness.",
	"Method": "void randomize(Random rand){\r\n    polynomial.expandN(mDegree);\r\n    polynomial.randomize(rand);\r\n}"
}, {
	"Path": "org.bouncycastle.cert.crmf.PKIArchiveControlBuilder.build",
	"Comment": "build the pkiarchivecontrol using the passed in encryptor to encrypt its contents.",
	"Method": "PKIArchiveControl build(OutputEncryptor contentEncryptor){\r\n    CMSEnvelopedData envContent = envGen.generate(keyContent, contentEncryptor);\r\n    EnvelopedData envD = EnvelopedData.getInstance(envContent.toASN1Structure().getContent());\r\n    return new PKIArchiveControl(new PKIArchiveOptions(new EncryptedKey(envD)));\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSAuthenticatedData.getOriginatorInfo",
	"Comment": "return the originator information associated with this message if present.",
	"Method": "OriginatorInformation getOriginatorInfo(){\r\n    return originatorInfo;\r\n}"
}, {
	"Path": "org.bouncycastle.tls.crypto.impl.jcajce.srp.SRP6Client.calculateClientEvidenceMessage",
	"Comment": "computes the client evidence message m1 using the previously received values.\tto be called after calculating the secret s.",
	"Method": "BigInteger calculateClientEvidenceMessage(){\r\n    if (this.A == null || this.B == null || this.S == null) {\r\n        throw new IllegalStateException(\"Impossible to compute M1: \" + \"some data are missing from the previous operations (A,B,S)\");\r\n    }\r\n    this.M1 = SRP6Util.calculateM1(digest, N, A, B, S);\r\n    return M1;\r\n}"
}, {
	"Path": "org.bouncycastle.x509.X509V1CertificateGenerator.setSignatureAlgorithm",
	"Comment": "set the signature algorithm. this can be either a name or an oid, namesare treated as case insensitive.",
	"Method": "void setSignatureAlgorithm(String signatureAlgorithm){\r\n    this.signatureAlgorithm = signatureAlgorithm;\r\n    try {\r\n        sigOID = X509Util.getAlgorithmOID(signatureAlgorithm);\r\n    } catch (Exception e) {\r\n        throw new IllegalArgumentException(\"Unknown signature type requested\");\r\n    }\r\n    sigAlgId = X509Util.getSigAlgID(sigOID, signatureAlgorithm);\r\n    tbsGen.setSignature(sigAlgId);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.generators.BCrypt.generate",
	"Comment": "calculates the bcrypt hash of a password.this implements the raw bcrypt function as defined in the bcrypt specification, notthe crypt encoded version implemented in openbsd.",
	"Method": "byte[] generate(byte[] password,byte[] salt,int cost){\r\n    if (password == null || salt == null) {\r\n        throw new IllegalArgumentException(\"Password and salt are required\");\r\n    }\r\n    if (salt.length != SALT_SIZE_BYTES) {\r\n        throw new IllegalArgumentException(\"BCrypt salt must be 128 bits\");\r\n    }\r\n    if (password.length > MAX_PASSWORD_BYTES) {\r\n        throw new IllegalArgumentException(\"BCrypt password must be <= 72 bytes\");\r\n    }\r\n    if (cost < MIN_COST || cost > MAX_COST) {\r\n        throw new IllegalArgumentException(\"BCrypt cost must be from 4..31\");\r\n    }\r\n    return new BCrypt().deriveRawKey(cost, salt, password);\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM.modSquareRootMatrix",
	"Comment": "compute the square root of this polynomial using a square root matrix.",
	"Method": "PolynomialGF2mSmallM modSquareRootMatrix(PolynomialGF2mSmallM[] matrix){\r\n    int length = matrix.length;\r\n    int[] resultCoeff = new int[length];\r\n    for (int i = 0; i < length; i++) {\r\n        for (int j = 0; j < length; j++) {\r\n            if (i >= matrix[j].coefficients.length) {\r\n                continue;\r\n            }\r\n            if (j < coefficients.length) {\r\n                int scalarTerm = field.mult(matrix[j].coefficients[i], coefficients[j]);\r\n                resultCoeff[i] = field.add(resultCoeff[i], scalarTerm);\r\n            }\r\n        }\r\n    }\r\n    for (int i = 0; i < length; i++) {\r\n        resultCoeff[i] = field.sqRoot(resultCoeff[i]);\r\n    }\r\n    return new PolynomialGF2mSmallM(field, resultCoeff);\r\n}"
}, {
	"Path": "javax.crypto.spec.SecretKeySpec.hashCode",
	"Comment": "calculates a hash code value for the object.objects that are equal will also have the same hashcode.",
	"Method": "int hashCode(){\r\n    int code = algorithm.toUpperCase().hashCode();\r\n    for (int i = 0; i != this.key.length; i++) {\r\n        code ^= this.key[i] << (8 * (i % 4));\r\n    }\r\n    return code;\r\n}"
}, {
	"Path": "org.bouncycastle.test.qtesla.QTESLASecureRandomFactory.getFixed",
	"Comment": "return a seeded fixedsecurerandom representing the result of processing aqtesla test seed with the qtesla randomnumbergenerator.",
	"Method": "FixedSecureRandom getFixed(byte[] seed,int strength,FixedSecureRandom getFixed,byte[] seed,byte[] personalization,int strength,int discard,int size){\r\n    QTESLASecureRandomFactory teslaRNG = new QTESLASecureRandomFactory(seed, personalization);\r\n    teslaRNG.init(strength);\r\n    byte[] burn = new byte[discard];\r\n    teslaRNG.nextBytes(burn);\r\n    if (discard != size) {\r\n        burn = new byte[size];\r\n    }\r\n    teslaRNG.nextBytes(burn);\r\n    return new FixedSecureRandom(burn);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.digests.MD2Digest.doFinal",
	"Comment": "close the digest, producing the final digest value. the dofinalcall leaves the digest reset.",
	"Method": "int doFinal(byte[] out,int outOff){\r\n    byte paddingByte = (byte) (M.length - mOff);\r\n    for (int i = mOff; i < M.length; i++) {\r\n        M[i] = paddingByte;\r\n    }\r\n    processCheckSum(M);\r\n    processBlock(M);\r\n    processBlock(C);\r\n    System.arraycopy(X, xOff, out, outOff, 16);\r\n    reset();\r\n    return DIGEST_LENGTH;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.cmp.ProtectedPKIMessageBuilder.build",
	"Comment": "build a protected pki message which has mac based integrity protection.",
	"Method": "ProtectedPKIMessage build(MacCalculator macCalculator,ProtectedPKIMessage build,ContentSigner signer){\r\n    finaliseHeader(signer.getAlgorithmIdentifier());\r\n    PKIHeader header = hdrBuilder.build();\r\n    try {\r\n        DERBitString protection = new DERBitString(calculateSignature(signer, header, body));\r\n        return finaliseMessage(header, protection);\r\n    } catch (IOException e) {\r\n        throw new CMPException(\"unable to encode signature input: \" + e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.CertStore.getInstance",
	"Comment": "returns a certstore object that implements the specifiedcertstore type, as supplied by the specified provider andinitialized with the specified parameters.the certstore that is returned is initialized with thespecified certstoreparameters. the type of parametersneeded may vary between different types of certstores.note that the specified certstoreparameters object iscloned.",
	"Method": "CertStore getInstance(String type,CertStoreParameters params,CertStore getInstance,String type,CertStoreParameters params,String provider,CertStore getInstance,String type,CertStoreParameters params,Provider provider){\r\n    if (provider == null) {\r\n        throw new IllegalArgumentException(\"provider must be non-null\");\r\n    }\r\n    CertUtil.Implementation imp = CertUtil.getImplementation(\"CertStore\", type, provider, new Class[] { CertStoreParameters.class }, new Object[] { params });\r\n    if (imp != null) {\r\n        return new CertStore((CertStoreSpi) imp.getEngine(), provider, type, params);\r\n    }\r\n    throw new NoSuchAlgorithmException(\"can't find type \" + type);\r\n}"
}, {
	"Path": "org.bouncycastle.cert.selector.X509AttributeCertificateHolderSelectorBuilder.setAttributeCertificateValid",
	"Comment": "set the time, when the certificate must be valid. if nullis given any will do.",
	"Method": "void setAttributeCertificateValid(Date attributeCertificateValid){\r\n    if (attributeCertificateValid != null) {\r\n        this.attributeCertificateValid = new Date(attributeCertificateValid.getTime());\r\n    } else {\r\n        this.attributeCertificateValid = null;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSEnvelopedData.getOriginatorInfo",
	"Comment": "return the originator information associated with this message if present.",
	"Method": "OriginatorInformation getOriginatorInfo(){\r\n    return originatorInfo;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.engines.CAST5Engine.setKey",
	"Comment": "creates the subkeys using the same nomenclatureas described in rfc2144.see section 2.4",
	"Method": "void setKey(byte[] key){\r\n    if (key.length < 11) {\r\n        _rounds = RED_ROUNDS;\r\n    }\r\n    int[] z = new int[16];\r\n    int[] x = new int[16];\r\n    int z03, z47, z8B, zCF;\r\n    int x03, x47, x8B, xCF;\r\n    for (int i = 0; i < key.length; i++) {\r\n        x[i] = key[i] & 0xff;\r\n    }\r\n    x03 = IntsTo32bits(x, 0x0);\r\n    x47 = IntsTo32bits(x, 0x4);\r\n    x8B = IntsTo32bits(x, 0x8);\r\n    xCF = IntsTo32bits(x, 0xC);\r\n    z03 = x03 ^ S5[x[0xD]] ^ S6[x[0xF]] ^ S7[x[0xC]] ^ S8[x[0xE]] ^ S7[x[0x8]];\r\n    Bits32ToInts(z03, z, 0x0);\r\n    z47 = x8B ^ S5[z[0x0]] ^ S6[z[0x2]] ^ S7[z[0x1]] ^ S8[z[0x3]] ^ S8[x[0xA]];\r\n    Bits32ToInts(z47, z, 0x4);\r\n    z8B = xCF ^ S5[z[0x7]] ^ S6[z[0x6]] ^ S7[z[0x5]] ^ S8[z[0x4]] ^ S5[x[0x9]];\r\n    Bits32ToInts(z8B, z, 0x8);\r\n    zCF = x47 ^ S5[z[0xA]] ^ S6[z[0x9]] ^ S7[z[0xB]] ^ S8[z[0x8]] ^ S6[x[0xB]];\r\n    Bits32ToInts(zCF, z, 0xC);\r\n    _Km[1] = S5[z[0x8]] ^ S6[z[0x9]] ^ S7[z[0x7]] ^ S8[z[0x6]] ^ S5[z[0x2]];\r\n    _Km[2] = S5[z[0xA]] ^ S6[z[0xB]] ^ S7[z[0x5]] ^ S8[z[0x4]] ^ S6[z[0x6]];\r\n    _Km[3] = S5[z[0xC]] ^ S6[z[0xD]] ^ S7[z[0x3]] ^ S8[z[0x2]] ^ S7[z[0x9]];\r\n    _Km[4] = S5[z[0xE]] ^ S6[z[0xF]] ^ S7[z[0x1]] ^ S8[z[0x0]] ^ S8[z[0xC]];\r\n    z03 = IntsTo32bits(z, 0x0);\r\n    z47 = IntsTo32bits(z, 0x4);\r\n    z8B = IntsTo32bits(z, 0x8);\r\n    zCF = IntsTo32bits(z, 0xC);\r\n    x03 = z8B ^ S5[z[0x5]] ^ S6[z[0x7]] ^ S7[z[0x4]] ^ S8[z[0x6]] ^ S7[z[0x0]];\r\n    Bits32ToInts(x03, x, 0x0);\r\n    x47 = z03 ^ S5[x[0x0]] ^ S6[x[0x2]] ^ S7[x[0x1]] ^ S8[x[0x3]] ^ S8[z[0x2]];\r\n    Bits32ToInts(x47, x, 0x4);\r\n    x8B = z47 ^ S5[x[0x7]] ^ S6[x[0x6]] ^ S7[x[0x5]] ^ S8[x[0x4]] ^ S5[z[0x1]];\r\n    Bits32ToInts(x8B, x, 0x8);\r\n    xCF = zCF ^ S5[x[0xA]] ^ S6[x[0x9]] ^ S7[x[0xB]] ^ S8[x[0x8]] ^ S6[z[0x3]];\r\n    Bits32ToInts(xCF, x, 0xC);\r\n    _Km[5] = S5[x[0x3]] ^ S6[x[0x2]] ^ S7[x[0xC]] ^ S8[x[0xD]] ^ S5[x[0x8]];\r\n    _Km[6] = S5[x[0x1]] ^ S6[x[0x0]] ^ S7[x[0xE]] ^ S8[x[0xF]] ^ S6[x[0xD]];\r\n    _Km[7] = S5[x[0x7]] ^ S6[x[0x6]] ^ S7[x[0x8]] ^ S8[x[0x9]] ^ S7[x[0x3]];\r\n    _Km[8] = S5[x[0x5]] ^ S6[x[0x4]] ^ S7[x[0xA]] ^ S8[x[0xB]] ^ S8[x[0x7]];\r\n    x03 = IntsTo32bits(x, 0x0);\r\n    x47 = IntsTo32bits(x, 0x4);\r\n    x8B = IntsTo32bits(x, 0x8);\r\n    xCF = IntsTo32bits(x, 0xC);\r\n    z03 = x03 ^ S5[x[0xD]] ^ S6[x[0xF]] ^ S7[x[0xC]] ^ S8[x[0xE]] ^ S7[x[0x8]];\r\n    Bits32ToInts(z03, z, 0x0);\r\n    z47 = x8B ^ S5[z[0x0]] ^ S6[z[0x2]] ^ S7[z[0x1]] ^ S8[z[0x3]] ^ S8[x[0xA]];\r\n    Bits32ToInts(z47, z, 0x4);\r\n    z8B = xCF ^ S5[z[0x7]] ^ S6[z[0x6]] ^ S7[z[0x5]] ^ S8[z[0x4]] ^ S5[x[0x9]];\r\n    Bits32ToInts(z8B, z, 0x8);\r\n    zCF = x47 ^ S5[z[0xA]] ^ S6[z[0x9]] ^ S7[z[0xB]] ^ S8[z[0x8]] ^ S6[x[0xB]];\r\n    Bits32ToInts(zCF, z, 0xC);\r\n    _Km[9] = S5[z[0x3]] ^ S6[z[0x2]] ^ S7[z[0xC]] ^ S8[z[0xD]] ^ S5[z[0x9]];\r\n    _Km[10] = S5[z[0x1]] ^ S6[z[0x0]] ^ S7[z[0xE]] ^ S8[z[0xF]] ^ S6[z[0xc]];\r\n    _Km[11] = S5[z[0x7]] ^ S6[z[0x6]] ^ S7[z[0x8]] ^ S8[z[0x9]] ^ S7[z[0x2]];\r\n    _Km[12] = S5[z[0x5]] ^ S6[z[0x4]] ^ S7[z[0xA]] ^ S8[z[0xB]] ^ S8[z[0x6]];\r\n    z03 = IntsTo32bits(z, 0x0);\r\n    z47 = IntsTo32bits(z, 0x4);\r\n    z8B = IntsTo32bits(z, 0x8);\r\n    zCF = IntsTo32bits(z, 0xC);\r\n    x03 = z8B ^ S5[z[0x5]] ^ S6[z[0x7]] ^ S7[z[0x4]] ^ S8[z[0x6]] ^ S7[z[0x0]];\r\n    Bits32ToInts(x03, x, 0x0);\r\n    x47 = z03 ^ S5[x[0x0]] ^ S6[x[0x2]] ^ S7[x[0x1]] ^ S8[x[0x3]] ^ S8[z[0x2]];\r\n    Bits32ToInts(x47, x, 0x4);\r\n    x8B = z47 ^ S5[x[0x7]] ^ S6[x[0x6]] ^ S7[x[0x5]] ^ S8[x[0x4]] ^ S5[z[0x1]];\r\n    Bits32ToInts(x8B, x, 0x8);\r\n    xCF = zCF ^ S5[x[0xA]] ^ S6[x[0x9]] ^ S7[x[0xB]] ^ S8[x[0x8]] ^ S6[z[0x3]];\r\n    Bits32ToInts(xCF, x, 0xC);\r\n    _Km[13] = S5[x[0x8]] ^ S6[x[0x9]] ^ S7[x[0x7]] ^ S8[x[0x6]] ^ S5[x[0x3]];\r\n    _Km[14] = S5[x[0xA]] ^ S6[x[0xB]] ^ S7[x[0x5]] ^ S8[x[0x4]] ^ S6[x[0x7]];\r\n    _Km[15] = S5[x[0xC]] ^ S6[x[0xD]] ^ S7[x[0x3]] ^ S8[x[0x2]] ^ S7[x[0x8]];\r\n    _Km[16] = S5[x[0xE]] ^ S6[x[0xF]] ^ S7[x[0x1]] ^ S8[x[0x0]] ^ S8[x[0xD]];\r\n    x03 = IntsTo32bits(x, 0x0);\r\n    x47 = IntsTo32bits(x, 0x4);\r\n    x8B = IntsTo32bits(x, 0x8);\r\n    xCF = IntsTo32bits(x, 0xC);\r\n    z03 = x03 ^ S5[x[0xD]] ^ S6[x[0xF]] ^ S7[x[0xC]] ^ S8[x[0xE]] ^ S7[x[0x8]];\r\n    Bits32ToInts(z03, z, 0x0);\r\n    z47 = x8B ^ S5[z[0x0]] ^ S6[z[0x2]] ^ S7[z[0x1]] ^ S8[z[0x3]] ^ S8[x[0xA]];\r\n    Bits32ToInts(z47, z, 0x4);\r\n    z8B = xCF ^ S5[z[0x7]] ^ S6[z[0x6]] ^ S7[z[0x5]] ^ S8[z[0x4]] ^ S5[x[0x9]];\r\n    Bits32ToInts(z8B, z, 0x8);\r\n    zCF = x47 ^ S5[z[0xA]] ^ S6[z[0x9]] ^ S7[z[0xB]] ^ S8[z[0x8]] ^ S6[x[0xB]];\r\n    Bits32ToInts(zCF, z, 0xC);\r\n    _Kr[1] = (S5[z[0x8]] ^ S6[z[0x9]] ^ S7[z[0x7]] ^ S8[z[0x6]] ^ S5[z[0x2]]) & 0x1f;\r\n    _Kr[2] = (S5[z[0xA]] ^ S6[z[0xB]] ^ S7[z[0x5]] ^ S8[z[0x4]] ^ S6[z[0x6]]) & 0x1f;\r\n    _Kr[3] = (S5[z[0xC]] ^ S6[z[0xD]] ^ S7[z[0x3]] ^ S8[z[0x2]] ^ S7[z[0x9]]) & 0x1f;\r\n    _Kr[4] = (S5[z[0xE]] ^ S6[z[0xF]] ^ S7[z[0x1]] ^ S8[z[0x0]] ^ S8[z[0xC]]) & 0x1f;\r\n    z03 = IntsTo32bits(z, 0x0);\r\n    z47 = IntsTo32bits(z, 0x4);\r\n    z8B = IntsTo32bits(z, 0x8);\r\n    zCF = IntsTo32bits(z, 0xC);\r\n    x03 = z8B ^ S5[z[0x5]] ^ S6[z[0x7]] ^ S7[z[0x4]] ^ S8[z[0x6]] ^ S7[z[0x0]];\r\n    Bits32ToInts(x03, x, 0x0);\r\n    x47 = z03 ^ S5[x[0x0]] ^ S6[x[0x2]] ^ S7[x[0x1]] ^ S8[x[0x3]] ^ S8[z[0x2]];\r\n    Bits32ToInts(x47, x, 0x4);\r\n    x8B = z47 ^ S5[x[0x7]] ^ S6[x[0x6]] ^ S7[x[0x5]] ^ S8[x[0x4]] ^ S5[z[0x1]];\r\n    Bits32ToInts(x8B, x, 0x8);\r\n    xCF = zCF ^ S5[x[0xA]] ^ S6[x[0x9]] ^ S7[x[0xB]] ^ S8[x[0x8]] ^ S6[z[0x3]];\r\n    Bits32ToInts(xCF, x, 0xC);\r\n    _Kr[5] = (S5[x[0x3]] ^ S6[x[0x2]] ^ S7[x[0xC]] ^ S8[x[0xD]] ^ S5[x[0x8]]) & 0x1f;\r\n    _Kr[6] = (S5[x[0x1]] ^ S6[x[0x0]] ^ S7[x[0xE]] ^ S8[x[0xF]] ^ S6[x[0xD]]) & 0x1f;\r\n    _Kr[7] = (S5[x[0x7]] ^ S6[x[0x6]] ^ S7[x[0x8]] ^ S8[x[0x9]] ^ S7[x[0x3]]) & 0x1f;\r\n    _Kr[8] = (S5[x[0x5]] ^ S6[x[0x4]] ^ S7[x[0xA]] ^ S8[x[0xB]] ^ S8[x[0x7]]) & 0x1f;\r\n    x03 = IntsTo32bits(x, 0x0);\r\n    x47 = IntsTo32bits(x, 0x4);\r\n    x8B = IntsTo32bits(x, 0x8);\r\n    xCF = IntsTo32bits(x, 0xC);\r\n    z03 = x03 ^ S5[x[0xD]] ^ S6[x[0xF]] ^ S7[x[0xC]] ^ S8[x[0xE]] ^ S7[x[0x8]];\r\n    Bits32ToInts(z03, z, 0x0);\r\n    z47 = x8B ^ S5[z[0x0]] ^ S6[z[0x2]] ^ S7[z[0x1]] ^ S8[z[0x3]] ^ S8[x[0xA]];\r\n    Bits32ToInts(z47, z, 0x4);\r\n    z8B = xCF ^ S5[z[0x7]] ^ S6[z[0x6]] ^ S7[z[0x5]] ^ S8[z[0x4]] ^ S5[x[0x9]];\r\n    Bits32ToInts(z8B, z, 0x8);\r\n    zCF = x47 ^ S5[z[0xA]] ^ S6[z[0x9]] ^ S7[z[0xB]] ^ S8[z[0x8]] ^ S6[x[0xB]];\r\n    Bits32ToInts(zCF, z, 0xC);\r\n    _Kr[9] = (S5[z[0x3]] ^ S6[z[0x2]] ^ S7[z[0xC]] ^ S8[z[0xD]] ^ S5[z[0x9]]) & 0x1f;\r\n    _Kr[10] = (S5[z[0x1]] ^ S6[z[0x0]] ^ S7[z[0xE]] ^ S8[z[0xF]] ^ S6[z[0xc]]) & 0x1f;\r\n    _Kr[11] = (S5[z[0x7]] ^ S6[z[0x6]] ^ S7[z[0x8]] ^ S8[z[0x9]] ^ S7[z[0x2]]) & 0x1f;\r\n    _Kr[12] = (S5[z[0x5]] ^ S6[z[0x4]] ^ S7[z[0xA]] ^ S8[z[0xB]] ^ S8[z[0x6]]) & 0x1f;\r\n    z03 = IntsTo32bits(z, 0x0);\r\n    z47 = IntsTo32bits(z, 0x4);\r\n    z8B = IntsTo32bits(z, 0x8);\r\n    zCF = IntsTo32bits(z, 0xC);\r\n    x03 = z8B ^ S5[z[0x5]] ^ S6[z[0x7]] ^ S7[z[0x4]] ^ S8[z[0x6]] ^ S7[z[0x0]];\r\n    Bits32ToInts(x03, x, 0x0);\r\n    x47 = z03 ^ S5[x[0x0]] ^ S6[x[0x2]] ^ S7[x[0x1]] ^ S8[x[0x3]] ^ S8[z[0x2]];\r\n    Bits32ToInts(x47, x, 0x4);\r\n    x8B = z47 ^ S5[x[0x7]] ^ S6[x[0x6]] ^ S7[x[0x5]] ^ S8[x[0x4]] ^ S5[z[0x1]];\r\n    Bits32ToInts(x8B, x, 0x8);\r\n    xCF = zCF ^ S5[x[0xA]] ^ S6[x[0x9]] ^ S7[x[0xB]] ^ S8[x[0x8]] ^ S6[z[0x3]];\r\n    Bits32ToInts(xCF, x, 0xC);\r\n    _Kr[13] = (S5[x[0x8]] ^ S6[x[0x9]] ^ S7[x[0x7]] ^ S8[x[0x6]] ^ S5[x[0x3]]) & 0x1f;\r\n    _Kr[14] = (S5[x[0xA]] ^ S6[x[0xB]] ^ S7[x[0x5]] ^ S8[x[0x4]] ^ S6[x[0x7]]) & 0x1f;\r\n    _Kr[15] = (S5[x[0xC]] ^ S6[x[0xD]] ^ S7[x[0x3]] ^ S8[x[0x2]] ^ S7[x[0x8]]) & 0x1f;\r\n    _Kr[16] = (S5[x[0xE]] ^ S6[x[0xF]] ^ S7[x[0x1]] ^ S8[x[0x0]] ^ S8[x[0xD]]) & 0x1f;\r\n}"
}, {
	"Path": "java.security.cert.CertPathValidator.getInstance",
	"Comment": "returns a certpathvalidator object that implements thespecified algorithm, as supplied by the specified provider.",
	"Method": "CertPathValidator getInstance(String algorithm,CertPathValidator getInstance,String algorithm,String provider,CertPathValidator getInstance,String algorithm,Provider provider){\r\n    if (provider == null)\r\n        throw new IllegalArgumentException(\"provider must be non-null\");\r\n    CertUtil.Implementation imp = CertUtil.getImplementation(\"CertPathValidator\", algorithm, provider);\r\n    if (imp != null) {\r\n        return new CertPathValidator((CertPathValidatorSpi) imp.getEngine(), provider, algorithm);\r\n    }\r\n    throw new NoSuchAlgorithmException(\"can't find algorithm \" + algorithm);\r\n}"
}, {
	"Path": "org.bouncycastle.mail.smime.handlers.multipart_signed.outputPreamble",
	"Comment": "internal preamble is generally included in signatures, while this is technically wrong,if we find internal preamble we include it by default.",
	"Method": "void outputPreamble(LineOutputStream lOut,MimeBodyPart part,String boundary){\r\n    InputStream in;\r\n    try {\r\n        in = part.getRawInputStream();\r\n    } catch (MessagingException e) {\r\n        return;\r\n    }\r\n    String line;\r\n    while ((line = readLine(in)) != null) {\r\n        if (line.equals(boundary)) {\r\n            break;\r\n        }\r\n        lOut.writeln(line);\r\n    }\r\n    in.close();\r\n    if (line == null) {\r\n        throw new MessagingException(\"no boundary found\");\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.engines.RSAEngine.getOutputBlockSize",
	"Comment": "return the maximum size for an output block to this engine.for rsa this is always one byte less than the key size ondecryption, and the same length as the key size on encryption.",
	"Method": "int getOutputBlockSize(){\r\n    return core.getOutputBlockSize();\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.jcajce.provider.test.FlexiTest.fail",
	"Comment": "method used to report test failure when in exception is thrown.",
	"Method": "void fail(Exception e){\r\n    fail(\"Exception thrown: \" + e.getClass().getName() + \":\\n\" + e.getMessage());\r\n}"
}, {
	"Path": "com.sun.swingset3.demos.Stacker.showMessageLayer",
	"Comment": "fades in the specified message component in the top layer of thislayered pane.",
	"Method": "void showMessageLayer(JComponent message,float finalAlpha){\r\n    messageLayer = new JPanel();\r\n    messageLayer.setOpaque(false);\r\n    GridBagLayout gridbag = new GridBagLayout();\r\n    messageLayer.setLayout(gridbag);\r\n    GridBagConstraints c = new GridBagConstraints();\r\n    c.anchor = GridBagConstraints.CENTER;\r\n    messageAlpha = new JXPanel();\r\n    messageAlpha.setOpaque(false);\r\n    messageAlpha.setAlpha(0.0f);\r\n    gridbag.addLayoutComponent(messageAlpha, c);\r\n    messageLayer.add(messageAlpha);\r\n    messageAlpha.add(message);\r\n    add(messageLayer, JLayeredPane.POPUP_LAYER);\r\n    revalidate();\r\n    SwingUtilities.invokeLater(new Runnable() {\r\n        public void run() {\r\n            Animator animator = new Animator(2000, new PropertySetter(messageAlpha, \"alpha\", 0.0f, finalAlpha));\r\n            animator.setStartDelay(200);\r\n            animator.setAcceleration(.2f);\r\n            animator.setDeceleration(.5f);\r\n            animator.start();\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.sun.swingset3.demos.Stacker.showMessageLayer",
	"Comment": "fades in the specified message component in the top layer of thislayered pane.",
	"Method": "void showMessageLayer(JComponent message,float finalAlpha){\r\n    Animator animator = new Animator(2000, new PropertySetter(messageAlpha, \"alpha\", 0.0f, finalAlpha));\r\n    animator.setStartDelay(200);\r\n    animator.setAcceleration(.2f);\r\n    animator.setDeceleration(.5f);\r\n    animator.start();\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.cms.AttributeTable.getAll",
	"Comment": "return all the attributes matching the object identifier oid. the vector will be empty if there are no attributes of the required type present.",
	"Method": "ASN1EncodableVector getAll(ASN1ObjectIdentifier oid){\r\n    ASN1EncodableVector v = new ASN1EncodableVector();\r\n    Object value = attributes.get(oid);\r\n    if (value instanceof Vector) {\r\n        Enumeration e = ((Vector) value).elements();\r\n        while (e.hasMoreElements()) {\r\n            v.add((Attribute) e.nextElement());\r\n        }\r\n    } else if (value != null) {\r\n        v.add((Attribute) value);\r\n    }\r\n    return v;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.gmss.Treehash.initialize",
	"Comment": "initializes the treehash instance. the seeds must already have beeninitialized to work correctly.",
	"Method": "void initialize(){\r\n    if (!this.seedInitialized) {\r\n        System.err.println(\"Seed \" + this.maxHeight + \" not initialized\");\r\n        return;\r\n    }\r\n    this.heightOfNodes = new Vector();\r\n    this.tailLength = 0;\r\n    this.firstNode = null;\r\n    this.firstNodeHeight = -1;\r\n    this.isInitialized = true;\r\n    System.arraycopy(this.seedNext, 0, this.seedActive, 0, messDigestTree.getDigestSize());\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.ntru.polynomial.LongPolynomial5.mult",
	"Comment": "multiplies the polynomial with a ternarypolynomial, taking the indices mod n and the values mod 2048.",
	"Method": "LongPolynomial5 mult(TernaryPolynomial poly2){\r\n    long[][] prod = new long[5][coeffs.length + (poly2.size() + 4) / 5 - 1];\r\n    int[] ones = poly2.getOnes();\r\n    for (int idx = 0; idx != ones.length; idx++) {\r\n        int pIdx = ones[idx];\r\n        int cIdx = pIdx / 5;\r\n        int m = pIdx - cIdx * 5;\r\n        for (int i = 0; i < coeffs.length; i++) {\r\n            prod[m][cIdx] = (prod[m][cIdx] + coeffs[i]) & 0x7FF7FF7FF7FF7FFL;\r\n            cIdx++;\r\n        }\r\n    }\r\n    int[] negOnes = poly2.getNegOnes();\r\n    for (int idx = 0; idx != negOnes.length; idx++) {\r\n        int pIdx = negOnes[idx];\r\n        int cIdx = pIdx / 5;\r\n        int m = pIdx - cIdx * 5;\r\n        for (int i = 0; i < coeffs.length; i++) {\r\n            prod[m][cIdx] = (0x800800800800800L + prod[m][cIdx] - coeffs[i]) & 0x7FF7FF7FF7FF7FFL;\r\n            cIdx++;\r\n        }\r\n    }\r\n    long[] cCoeffs = Arrays.copyOf(prod[0], prod[0].length + 1);\r\n    for (int m = 1; m <= 4; m++) {\r\n        int shift = m * 12;\r\n        int shift60 = 60 - shift;\r\n        long mask = (1L << shift60) - 1;\r\n        int pLen = prod[m].length;\r\n        for (int i = 0; i < pLen; i++) {\r\n            long upper, lower;\r\n            upper = prod[m][i] >> shift60;\r\n            lower = prod[m][i] & mask;\r\n            cCoeffs[i] = (cCoeffs[i] + (lower << shift)) & 0x7FF7FF7FF7FF7FFL;\r\n            int nextIdx = i + 1;\r\n            cCoeffs[nextIdx] = (cCoeffs[nextIdx] + upper) & 0x7FF7FF7FF7FF7FFL;\r\n        }\r\n    }\r\n    int shift = 12 * (numCoeffs % 5);\r\n    for (int cIdx = coeffs.length - 1; cIdx < cCoeffs.length; cIdx++) {\r\n        long iCoeff;\r\n        int newIdx;\r\n        if (cIdx == coeffs.length - 1) {\r\n            iCoeff = numCoeffs == 5 ? 0 : cCoeffs[cIdx] >> shift;\r\n            newIdx = 0;\r\n        } else {\r\n            iCoeff = cCoeffs[cIdx];\r\n            newIdx = cIdx * 5 - numCoeffs;\r\n        }\r\n        int base = newIdx / 5;\r\n        int m = newIdx - base * 5;\r\n        long lower = iCoeff << (12 * m);\r\n        long upper = iCoeff >> (12 * (5 - m));\r\n        cCoeffs[base] = (cCoeffs[base] + lower) & 0x7FF7FF7FF7FF7FFL;\r\n        int base1 = base + 1;\r\n        if (base1 < coeffs.length) {\r\n            cCoeffs[base1] = (cCoeffs[base1] + upper) & 0x7FF7FF7FF7FF7FFL;\r\n        }\r\n    }\r\n    return new LongPolynomial5(cCoeffs, numCoeffs);\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPPublicKey.getEncoded",
	"Comment": "return an encoding of the key, with trust packets stripped out if fortransfer is true.",
	"Method": "byte[] getEncoded(byte[] getEncoded,boolean forTransfer){\r\n    ByteArrayOutputStream bOut = new ByteArrayOutputStream();\r\n    this.encode(bOut, forTransfer);\r\n    return bOut.toByteArray();\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.CertPathBuilder.build",
	"Comment": "attempts to build a certification path using the specified algorithmparameter set.",
	"Method": "CertPathBuilderResult build(CertPathParameters params){\r\n    return builderSpi.engineBuild(params);\r\n}"
}, {
	"Path": "org.bouncycastle.mail.smime.SMIMEToolkit.encrypt",
	"Comment": "encrypt the passed in mime message returning a new encrypted mime part.",
	"Method": "MimeBodyPart encrypt(MimeBodyPart mimePart,OutputEncryptor contentEncryptor,RecipientInfoGenerator recipientGenerator,MimeBodyPart encrypt,MimeMultipart multiPart,OutputEncryptor contentEncryptor,RecipientInfoGenerator recipientGenerator,MimeBodyPart encrypt,MimeMessage message,OutputEncryptor contentEncryptor,RecipientInfoGenerator recipientGenerator){\r\n    SMIMEEnvelopedGenerator envGen = new SMIMEEnvelopedGenerator();\r\n    envGen.addRecipientInfoGenerator(recipientGenerator);\r\n    return envGen.generate(message, contentEncryptor);\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.x509.ExtensionsGenerator.generate",
	"Comment": "generate an extensions object based on the current state of the generator.",
	"Method": "Extensions generate(){\r\n    Extension[] exts = new Extension[extOrdering.size()];\r\n    for (int i = 0; i != extOrdering.size(); i++) {\r\n        exts[i] = (Extension) extensions.get(extOrdering.elementAt(i));\r\n    }\r\n    return new Extensions(exts);\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.ntru.polynomial.BigIntPolynomial.div",
	"Comment": "divides each coefficient by a bigdecimal and rounds the result to decimalplaces places.",
	"Method": "void div(BigInteger divisor,BigDecimalPolynomial div,BigDecimal divisor,int decimalPlaces){\r\n    BigInteger max = maxCoeffAbs();\r\n    int coeffLength = (int) (max.bitLength() * LOG_10_2) + 1;\r\n    BigDecimal factor = Constants.BIGDEC_ONE.divide(divisor, coeffLength + decimalPlaces + 1, BigDecimal.ROUND_HALF_EVEN);\r\n    BigDecimalPolynomial p = new BigDecimalPolynomial(coeffs.length);\r\n    for (// multiply, then truncate after decimalPlaces so subsequent operations aren't slowed down\r\n    int i = 0; // multiply, then truncate after decimalPlaces so subsequent operations aren't slowed down\r\n    i < coeffs.length; i++) {\r\n        p.coeffs[i] = new BigDecimal(coeffs[i]).multiply(factor).setScale(decimalPlaces, BigDecimal.ROUND_HALF_EVEN);\r\n    }\r\n    return p;\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.PKIXExtendedParameters.getTargetConstraints",
	"Comment": "returns the required constraints on the target certificate.the constraints are returned as an instance ofselector. if null, no constraints aredefined.",
	"Method": "PKIXCertStoreSelector getTargetConstraints(){\r\n    return targetConstraints;\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.spec.KTSParameterSpec.getParameterSpec",
	"Comment": "return the algorithm parameter spec to be applied with the private key when the encapsulation is decrypted.",
	"Method": "AlgorithmParameterSpec getParameterSpec(){\r\n    return parameterSpec;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.gmss.GMSSRootSig.getLog",
	"Comment": "this method returns the least integer that is greater or equal to thelogarithm to the base 2 of an integer intvalue.",
	"Method": "int getLog(int intValue){\r\n    int log = 1;\r\n    int i = 2;\r\n    while (i < intValue) {\r\n        i <<= 1;\r\n        log++;\r\n    }\r\n    return log;\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSSignedDataParser.getCRLs",
	"Comment": "return any x.509 crl objects in this signeddata structure as a store of x509crlholder objects.",
	"Method": "Store getCRLs(){\r\n    populateCertCrlSets();\r\n    return HELPER.getCRLs(_crlSet);\r\n}"
}, {
	"Path": "org.bouncycastle.pkcs.PKCS10CertificationRequest.getAttributes",
	"Comment": "return anarray of attributes matching the passed in type oid.",
	"Method": "Attribute[] getAttributes(Attribute[] getAttributes,ASN1ObjectIdentifier type){\r\n    ASN1Set attrSet = certificationRequest.getCertificationRequestInfo().getAttributes();\r\n    if (attrSet == null) {\r\n        return EMPTY_ARRAY;\r\n    }\r\n    List list = new ArrayList();\r\n    for (int i = 0; i != attrSet.size(); i++) {\r\n        Attribute attr = Attribute.getInstance(attrSet.getObjectAt(i));\r\n        if (attr.getAttrType().equals(type)) {\r\n            list.add(attr);\r\n        }\r\n    }\r\n    if (list.size() == 0) {\r\n        return EMPTY_ARRAY;\r\n    }\r\n    return (Attribute[]) list.toArray(new Attribute[list.size()]);\r\n}"
}, {
	"Path": "org.bouncycastle.mail.smime.util.FileBackedMimeBodyPart.dispose",
	"Comment": "close off the underlying shared streams and remove the backing file.",
	"Method": "void dispose(){\r\n    ((SharedFileInputStream) contentStream).getRoot().dispose();\r\n    if (_file.exists() && !_file.delete()) {\r\n        throw new IOException(\"deletion of underlying file <\" + _file.getCanonicalPath() + \"> failed.\");\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.x509.PrincipalUtils.getEncodedIssuerPrincipal",
	"Comment": "returns the issuer of an attribute certificate or certificate.",
	"Method": "X500Name getEncodedIssuerPrincipal(Object cert){\r\n    if (cert instanceof X509Certificate) {\r\n        return getIssuerPrincipal((X509Certificate) cert);\r\n    } else {\r\n        return X500Name.getInstance(((X509Principal) ((X509AttributeCertificate) cert).getIssuer().getPrincipals()[0]).getEncoded());\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.modes.OldCTSBlockCipher.getOutputSize",
	"Comment": "return the size of the output buffer required for an update plus adofinal with an input of len bytes.",
	"Method": "int getOutputSize(int len){\r\n    return len + bufOff;\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPPublicKeyRing.insertPublicKey",
	"Comment": "returns a new key ring with the public key passed ineither added or replacing an existing one.",
	"Method": "PGPPublicKeyRing insertPublicKey(PGPPublicKeyRing pubRing,PGPPublicKey pubKey){\r\n    List keys = new ArrayList(pubRing.keys);\r\n    boolean found = false;\r\n    boolean masterFound = false;\r\n    for (int i = 0; i != keys.size(); i++) {\r\n        PGPPublicKey key = (PGPPublicKey) keys.get(i);\r\n        if (key.getKeyID() == pubKey.getKeyID()) {\r\n            found = true;\r\n            keys.set(i, pubKey);\r\n        }\r\n        if (key.isMasterKey()) {\r\n            masterFound = true;\r\n        }\r\n    }\r\n    if (!found) {\r\n        if (pubKey.isMasterKey()) {\r\n            if (masterFound) {\r\n                throw new IllegalArgumentException(\"cannot add a master key to a ring that already has one\");\r\n            }\r\n            keys.add(0, pubKey);\r\n        } else {\r\n            keys.add(pubKey);\r\n        }\r\n    }\r\n    return new PGPPublicKeyRing(keys);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.engines.CAST6Engine.encryptBlock",
	"Comment": "encrypt the given input starting at the given offset and placethe result in the provided buffer starting at the given offset.",
	"Method": "int encryptBlock(byte[] src,int srcIndex,byte[] dst,int dstIndex){\r\n    int[] result = new int[4];\r\n    int A = BytesTo32bits(src, srcIndex);\r\n    int B = BytesTo32bits(src, srcIndex + 4);\r\n    int C = BytesTo32bits(src, srcIndex + 8);\r\n    int D = BytesTo32bits(src, srcIndex + 12);\r\n    CAST_Encipher(A, B, C, D, result);\r\n    Bits32ToBytes(result[0], dst, dstIndex);\r\n    Bits32ToBytes(result[1], dst, dstIndex + 4);\r\n    Bits32ToBytes(result[2], dst, dstIndex + 8);\r\n    Bits32ToBytes(result[3], dst, dstIndex + 12);\r\n    return BLOCK_SIZE;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.signers.GOST3410Signer.verifySignature",
	"Comment": "return true if the value r and s represent a gost3410 signature forthe passed in message for standard gost3410 the message should be agost3411 hash of the real message to be verified.",
	"Method": "boolean verifySignature(byte[] message,BigInteger r,BigInteger s){\r\n    byte[] mRev = new byte[message.length];\r\n    for (int i = 0; i != mRev.length; i++) {\r\n        mRev[i] = message[mRev.length - 1 - i];\r\n    }\r\n    BigInteger m = new BigInteger(1, mRev);\r\n    GOST3410Parameters params = key.getParameters();\r\n    BigInteger zero = BigInteger.valueOf(0);\r\n    if (zero.compareTo(r) >= 0 || params.getQ().compareTo(r) <= 0) {\r\n        return false;\r\n    }\r\n    if (zero.compareTo(s) >= 0 || params.getQ().compareTo(s) <= 0) {\r\n        return false;\r\n    }\r\n    BigInteger v = m.modPow(params.getQ().subtract(new BigInteger(\"2\")), params.getQ());\r\n    BigInteger z1 = s.multiply(v).mod(params.getQ());\r\n    BigInteger z2 = (params.getQ().subtract(r)).multiply(v).mod(params.getQ());\r\n    z1 = params.getA().modPow(z1, params.getP());\r\n    z2 = ((GOST3410PublicKeyParameters) key).getY().modPow(z2, params.getP());\r\n    BigInteger u = z1.multiply(z2).mod(params.getP()).mod(params.getQ());\r\n    return u.equals(r);\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.operator.bc.BcPGPDataEncryptorBuilder.setWithIntegrityPacket",
	"Comment": "sets whether or not the resulting encrypted data will be protected using an integrity packet.",
	"Method": "BcPGPDataEncryptorBuilder setWithIntegrityPacket(boolean withIntegrityPacket){\r\n    this.withIntegrityPacket = withIntegrityPacket;\r\n    return this;\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.ch17_split.BESplitPaneDivider.createRightOneTouchButton",
	"Comment": "creates and return an instance of jbutton that can be used to\tcollapse the right component in the split pane.",
	"Method": "JButton createRightOneTouchButton(){\r\n    JButton b = new JButton() {\r\n        public void setBorder(Border border) {\r\n        }\r\n        public void paint(Graphics g) {\r\n            if (splitPane != null) {\r\n                int[] xs = new int[3];\r\n                int[] ys = new int[3];\r\n                int blockSize;\r\n                g.setColor(this.getBackground());\r\n                g.fillRect(0, 0, this.getWidth(), this.getHeight());\r\n                BEUtils.setAntiAliasing((Graphics2D) g, true);\r\n                if (orientation == JSplitPane.VERTICAL_SPLIT) {\r\n                    blockSize = Math.min(getHeight(), oneTouchSize);\r\n                    xs[0] = blockSize;\r\n                    xs[1] = blockSize << 1;\r\n                    xs[2] = 0;\r\n                    ys[0] = blockSize;\r\n                    ys[1] = ys[2] = 0;\r\n                } else {\r\n                    blockSize = Math.min(getWidth(), oneTouchSize);\r\n                    xs[0] = xs[2] = 0;\r\n                    xs[1] = blockSize;\r\n                    ys[0] = 0;\r\n                    ys[1] = blockSize;\r\n                    ys[2] = blockSize << 1;\r\n                }\r\n                // Color.black);\r\n                g.setColor(TOUCH_BUTTON_COLOR);\r\n                g.fillPolygon(xs, ys, 3);\r\n                BEUtils.setAntiAliasing((Graphics2D) g, false);\r\n            }\r\n        }\r\n        public boolean isFocusTraversable() {\r\n            return false;\r\n        }\r\n    };\r\n    b.setMinimumSize(new Dimension(oneTouchSize, oneTouchSize));\r\n    b.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));\r\n    b.setFocusPainted(false);\r\n    b.setBorderPainted(false);\r\n    b.setRequestFocusEnabled(false);\r\n    return b;\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.ch17_split.BESplitPaneDivider.createRightOneTouchButton",
	"Comment": "creates and return an instance of jbutton that can be used to\tcollapse the right component in the split pane.",
	"Method": "JButton createRightOneTouchButton(){\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.ch17_split.BESplitPaneDivider.createRightOneTouchButton",
	"Comment": "creates and return an instance of jbutton that can be used to\tcollapse the right component in the split pane.",
	"Method": "JButton createRightOneTouchButton(){\r\n    if (splitPane != null) {\r\n        int[] xs = new int[3];\r\n        int[] ys = new int[3];\r\n        int blockSize;\r\n        g.setColor(this.getBackground());\r\n        g.fillRect(0, 0, this.getWidth(), this.getHeight());\r\n        BEUtils.setAntiAliasing((Graphics2D) g, true);\r\n        if (orientation == JSplitPane.VERTICAL_SPLIT) {\r\n            blockSize = Math.min(getHeight(), oneTouchSize);\r\n            xs[0] = blockSize;\r\n            xs[1] = blockSize << 1;\r\n            xs[2] = 0;\r\n            ys[0] = blockSize;\r\n            ys[1] = ys[2] = 0;\r\n        } else {\r\n            blockSize = Math.min(getWidth(), oneTouchSize);\r\n            xs[0] = xs[2] = 0;\r\n            xs[1] = blockSize;\r\n            ys[0] = 0;\r\n            ys[1] = blockSize;\r\n            ys[2] = blockSize << 1;\r\n        }\r\n        // Color.black);\r\n        g.setColor(TOUCH_BUTTON_COLOR);\r\n        g.fillPolygon(xs, ys, 3);\r\n        BEUtils.setAntiAliasing((Graphics2D) g, false);\r\n    }\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.ch17_split.BESplitPaneDivider.createRightOneTouchButton",
	"Comment": "creates and return an instance of jbutton that can be used to\tcollapse the right component in the split pane.",
	"Method": "JButton createRightOneTouchButton(){\r\n    return false;\r\n}"
}, {
	"Path": "java.security.cert.CertStore.getInstance",
	"Comment": "returns a certstore object that implements the specifiedcertstore type, as supplied by the specified providerand initialized with the specified parameters.the certstore that is returned is initialized with the specified certstoreparameters. the type of parameters needed may vary between different types of certstores.note that the specified certstoreparameters object is cloned.",
	"Method": "CertStore getInstance(String type,CertStoreParameters params,CertStore getInstance,String type,CertStoreParameters params,String provider,CertStore getInstance,String type,CertStoreParameters params,Provider provider){\r\n    if (provider == null)\r\n        throw new IllegalArgumentException(\"provider must be non-null\");\r\n    CertUtil.Implementation imp = CertUtil.getImplementation(\"CertStore\", type, provider, new Class[] { CertStoreParameters.class }, new Object[] { params });\r\n    if (imp != null) {\r\n        return new CertStore((CertStoreSpi) imp.getEngine(), provider, type, params);\r\n    }\r\n    throw new NoSuchAlgorithmException(\"can't find type \" + type);\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.ByteUtils.xor",
	"Comment": "compute the bitwise xor of two arrays of bytes. the arrays have to be ofsame length. no length checking is performed.",
	"Method": "byte[] xor(byte[] x1,byte[] x2){\r\n    byte[] out = new byte[x1.length];\r\n    for (int i = x1.length - 1; i >= 0; i--) {\r\n        out[i] = (byte) (x1[i] ^ x2[i]);\r\n    }\r\n    return out;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.cryptopro.ECGOST3410NamedCurves.getName",
	"Comment": "return the named curve name represented by the given object identifier.",
	"Method": "String getName(ASN1ObjectIdentifier oid){\r\n    return (String) names.get(oid);\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2nPolynomialElement.testBit",
	"Comment": "checks whether the indexed bit of the bit representation is set.",
	"Method": "boolean testBit(int index){\r\n    return polynomial.testBit(index);\r\n}"
}, {
	"Path": "java.security.cert.X509CRLSelector.getCertificateChecking",
	"Comment": "returns the certificate being checked. this is not a criterion. rather,it is optional information that may help a certstore findcrls that would be relevant when checking revocation for the specifiedcertificate. if the value returned is null, then no suchoptional information is provided.",
	"Method": "X509Certificate getCertificateChecking(){\r\n    return certChecking;\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.io.CipherInputStream.nextChunk",
	"Comment": "read data from underlying stream and process with cipher until end of stream or some data isavailable after cipher processing.",
	"Method": "int nextChunk(){\r\n    if (finalized) {\r\n        return -1;\r\n    }\r\n    bufOff = 0;\r\n    maxBuf = 0;\r\n    while (maxBuf == 0) {\r\n        int read = in.read(inputBuffer);\r\n        if (read == -1) {\r\n            buf = finaliseCipher();\r\n            if ((buf == null) || (buf.length == 0)) {\r\n                return -1;\r\n            }\r\n            maxBuf = buf.length;\r\n            return maxBuf;\r\n        }\r\n        buf = cipher.update(inputBuffer, 0, read);\r\n        if (buf != null) {\r\n            maxBuf = buf.length;\r\n        }\r\n    }\r\n    return maxBuf;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2Polynomial.equals",
	"Comment": "returns true if two gf2polynomials have the same size and value and thusare equal.",
	"Method": "boolean equals(Object other){\r\n    if (other == null || !(other instanceof GF2Polynomial)) {\r\n        return false;\r\n    }\r\n    GF2Polynomial otherPol = (GF2Polynomial) other;\r\n    if (len != otherPol.len) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < blocks; i++) {\r\n        if (value[i] != otherPol.value[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPSecretKeyRingCollection.getSecretKeyRing",
	"Comment": "return the secret key ring which contains the key referred to by keyid.",
	"Method": "PGPSecretKeyRing getSecretKeyRing(long keyID){\r\n    Long id = new Long(keyID);\r\n    if (secretRings.containsKey(id)) {\r\n        return (PGPSecretKeyRing) secretRings.get(id);\r\n    }\r\n    Iterator it = this.getKeyRings();\r\n    while (it.hasNext()) {\r\n        PGPSecretKeyRing secretRing = (PGPSecretKeyRing) it.next();\r\n        PGPSecretKey secret = secretRing.getSecretKey(keyID);\r\n        if (secret != null) {\r\n            return secretRing;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPSignatureGenerator.generate",
	"Comment": "return a signature object containing the current signature state.",
	"Method": "PGPSignature generate(){\r\n    MPInteger[] sigValues;\r\n    int version = 4;\r\n    ByteArrayOutputStream sOut = new ByteArrayOutputStream();\r\n    SignatureSubpacket[] hPkts, unhPkts;\r\n    if (!packetPresent(hashed, SignatureSubpacketTags.CREATION_TIME)) {\r\n        hPkts = insertSubpacket(hashed, new SignatureCreationTime(false, new Date()));\r\n    } else {\r\n        hPkts = hashed;\r\n    }\r\n    if (!packetPresent(hashed, SignatureSubpacketTags.ISSUER_KEY_ID) && !packetPresent(unhashed, SignatureSubpacketTags.ISSUER_KEY_ID)) {\r\n        unhPkts = insertSubpacket(unhashed, new IssuerKeyID(false, contentSigner.getKeyID()));\r\n    } else {\r\n        unhPkts = unhashed;\r\n    }\r\n    try {\r\n        sOut.write((byte) version);\r\n        sOut.write((byte) sigType);\r\n        sOut.write((byte) contentSigner.getKeyAlgorithm());\r\n        sOut.write((byte) contentSigner.getHashAlgorithm());\r\n        ByteArrayOutputStream hOut = new ByteArrayOutputStream();\r\n        for (int i = 0; i != hPkts.length; i++) {\r\n            hPkts[i].encode(hOut);\r\n        }\r\n        byte[] data = hOut.toByteArray();\r\n        sOut.write((byte) (data.length >> 8));\r\n        sOut.write((byte) data.length);\r\n        sOut.write(data);\r\n    } catch (IOException e) {\r\n        throw new PGPException(\"exception encoding hashed data.\", e);\r\n    }\r\n    byte[] hData = sOut.toByteArray();\r\n    sOut.write((byte) version);\r\n    sOut.write((byte) 0xff);\r\n    sOut.write((byte) (hData.length >> 24));\r\n    sOut.write((byte) (hData.length >> 16));\r\n    sOut.write((byte) (hData.length >> 8));\r\n    sOut.write((byte) (hData.length));\r\n    byte[] trailer = sOut.toByteArray();\r\n    blockUpdate(trailer, 0, trailer.length);\r\n    if (contentSigner.getKeyAlgorithm() == PublicKeyAlgorithmTags.RSA_SIGN || contentSigner.getKeyAlgorithm() == PublicKeyAlgorithmTags.RSA_GENERAL) {\r\n        sigValues = new MPInteger[1];\r\n        sigValues[0] = new MPInteger(new BigInteger(1, contentSigner.getSignature()));\r\n    } else {\r\n        sigValues = PGPUtil.dsaSigToMpi(contentSigner.getSignature());\r\n    }\r\n    byte[] digest = contentSigner.getDigest();\r\n    byte[] fingerPrint = new byte[2];\r\n    fingerPrint[0] = digest[0];\r\n    fingerPrint[1] = digest[1];\r\n    return new PGPSignature(new SignaturePacket(sigType, contentSigner.getKeyID(), contentSigner.getKeyAlgorithm(), contentSigner.getHashAlgorithm(), hPkts, unhPkts, fingerPrint, sigValues));\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.provider.asymmetric.x509.PKIXCertPath.getEncodings",
	"Comment": "returns an iteration of the encodings supported by thiscertification path, with the default encodingfirst. attempts to modify the returned iterator via itsremove method result in an unsupportedoperationexception.",
	"Method": "Iterator getEncodings(){\r\n    return certPathEncodings.iterator();\r\n}"
}, {
	"Path": "org.bouncycastle.tsp.TimeStampTokenGenerator.generate",
	"Comment": "generate a timestamptoken for the passed in request and serialnumber marking it with the passed in gentime.",
	"Method": "TimeStampToken generate(TimeStampRequest request,BigInteger serialNumber,Date genTime,TimeStampToken generate,TimeStampRequest request,BigInteger serialNumber,Date genTime,Extensions additionalExtensions){\r\n    ASN1ObjectIdentifier digestAlgOID = request.getMessageImprintAlgOID();\r\n    AlgorithmIdentifier algID = new AlgorithmIdentifier(digestAlgOID, DERNull.INSTANCE);\r\n    MessageImprint messageImprint = new MessageImprint(algID, request.getMessageImprintDigest());\r\n    Accuracy accuracy = null;\r\n    if (accuracySeconds > 0 || accuracyMillis > 0 || accuracyMicros > 0) {\r\n        ASN1Integer seconds = null;\r\n        if (accuracySeconds > 0) {\r\n            seconds = new ASN1Integer(accuracySeconds);\r\n        }\r\n        ASN1Integer millis = null;\r\n        if (accuracyMillis > 0) {\r\n            millis = new ASN1Integer(accuracyMillis);\r\n        }\r\n        ASN1Integer micros = null;\r\n        if (accuracyMicros > 0) {\r\n            micros = new ASN1Integer(accuracyMicros);\r\n        }\r\n        accuracy = new Accuracy(seconds, millis, micros);\r\n    }\r\n    ASN1Boolean derOrdering = null;\r\n    if (ordering) {\r\n        derOrdering = ASN1Boolean.getInstance(ordering);\r\n    }\r\n    ASN1Integer nonce = null;\r\n    if (request.getNonce() != null) {\r\n        nonce = new ASN1Integer(request.getNonce());\r\n    }\r\n    ASN1ObjectIdentifier tsaPolicy = tsaPolicyOID;\r\n    if (request.getReqPolicy() != null) {\r\n        tsaPolicy = request.getReqPolicy();\r\n    }\r\n    Extensions respExtensions = request.getExtensions();\r\n    if (additionalExtensions != null) {\r\n        ExtensionsGenerator extGen = new ExtensionsGenerator();\r\n        if (respExtensions != null) {\r\n            for (Enumeration en = respExtensions.oids(); en.hasMoreElements(); ) {\r\n                extGen.addExtension(respExtensions.getExtension(ASN1ObjectIdentifier.getInstance(en.nextElement())));\r\n            }\r\n        }\r\n        for (Enumeration en = additionalExtensions.oids(); en.hasMoreElements(); ) {\r\n            extGen.addExtension(additionalExtensions.getExtension(ASN1ObjectIdentifier.getInstance(en.nextElement())));\r\n        }\r\n        respExtensions = extGen.generate();\r\n    }\r\n    ASN1GeneralizedTime timeStampTime;\r\n    if (resolution == R_SECONDS) {\r\n        timeStampTime = (locale == null) ? new ASN1GeneralizedTime(genTime) : new ASN1GeneralizedTime(genTime, locale);\r\n    } else {\r\n        timeStampTime = createGeneralizedTime(genTime);\r\n    }\r\n    TSTInfo tstInfo = new TSTInfo(tsaPolicy, messageImprint, new ASN1Integer(serialNumber), timeStampTime, accuracy, derOrdering, nonce, tsa, respExtensions);\r\n    try {\r\n        CMSSignedDataGenerator signedDataGenerator = new CMSSignedDataGenerator();\r\n        if (request.getCertReq()) {\r\n            signedDataGenerator.addCertificates(new CollectionStore(certs));\r\n            signedDataGenerator.addAttributeCertificates(new CollectionStore(attrCerts));\r\n        }\r\n        signedDataGenerator.addCRLs(new CollectionStore(crls));\r\n        if (!otherRevoc.isEmpty()) {\r\n            for (Iterator it = otherRevoc.keySet().iterator(); it.hasNext(); ) {\r\n                ASN1ObjectIdentifier format = (ASN1ObjectIdentifier) it.next();\r\n                signedDataGenerator.addOtherRevocationInfo(format, new CollectionStore((Collection) otherRevoc.get(format)));\r\n            }\r\n        }\r\n        signedDataGenerator.addSignerInfoGenerator(signerInfoGen);\r\n        byte[] derEncodedTSTInfo = tstInfo.getEncoded(ASN1Encoding.DER);\r\n        CMSSignedData signedData = signedDataGenerator.generate(new CMSProcessableByteArray(PKCSObjectIdentifiers.id_ct_TSTInfo, derEncodedTSTInfo), true);\r\n        return new TimeStampToken(signedData);\r\n    } catch (CMSException cmsEx) {\r\n        throw new TSPException(\"Error generating time-stamp token\", cmsEx);\r\n    } catch (IOException e) {\r\n        throw new TSPException(\"Exception encoding info\", e);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.cms.KeyAgreeRecipientInfo.getInstance",
	"Comment": "return a keyagreerecipientinfo object from a tagged object.",
	"Method": "KeyAgreeRecipientInfo getInstance(ASN1TaggedObject obj,boolean explicit,KeyAgreeRecipientInfo getInstance,Object obj){\r\n    if (obj instanceof KeyAgreeRecipientInfo) {\r\n        return (KeyAgreeRecipientInfo) obj;\r\n    }\r\n    if (obj != null) {\r\n        return new KeyAgreeRecipientInfo(ASN1Sequence.getInstance(obj));\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.est.jcajce.JcaHttpAuthBuilder.setProvider",
	"Comment": "set the provider to use to provide the needed message digests.",
	"Method": "JcaHttpAuthBuilder setProvider(Provider provider,JcaHttpAuthBuilder setProvider,String providerName){\r\n    this.providerBuilder.setProvider(providerName);\r\n    return this;\r\n}"
}, {
	"Path": "org.bouncycastle.cms.jcajce.JcaSimpleSignerInfoGeneratorBuilder.setDirectSignature",
	"Comment": "if the passed in flag is true, the signer signature will be based on the data, nota collection of signed attributes, and no signed attributes will be included.",
	"Method": "JcaSimpleSignerInfoGeneratorBuilder setDirectSignature(boolean hasNoSignedAttributes){\r\n    this.hasNoSignedAttributes = hasNoSignedAttributes;\r\n    return this;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.X509CRLSelector.getDateAndTime",
	"Comment": "returns the dateandtime criterion. the specified date must be equal to orlater than the value of the thisupdate component of thex509crl and earlier than the value of the nextupdatecomponent. there is no match if the x509crl does notcontain a nextupdate component. if null, no dateandtimecheck will be done.note that the date returned is cloned to protect againstsubsequent modifications.",
	"Method": "Date getDateAndTime(){\r\n    if (dateAndTime == null) {\r\n        return null;\r\n    }\r\n    return new Date(dateAndTime.getTime());\r\n}"
}, {
	"Path": "javax.crypto.Cipher.getAlgorithm",
	"Comment": "returns the algorithm name of this cipher object.this is the same name that was specified in one of thegetinstance calls that created this cipherobject..",
	"Method": "String getAlgorithm(){\r\n    return transformation;\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.operator.jcajce.JcePBEDataDecryptorFactoryBuilder.setProvider",
	"Comment": "set the provider name to use for creating cryptographic primitives in the resulting factory the builder produces.",
	"Method": "JcePBEDataDecryptorFactoryBuilder setProvider(Provider provider,JcePBEDataDecryptorFactoryBuilder setProvider,String providerName){\r\n    this.helper = new OperatorHelper(new NamedJcaJceHelper(providerName));\r\n    return this;\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPPublicKeyRing.encode",
	"Comment": "encode the key ring to outstream, with trust packets stripped out if fortransfer is true.",
	"Method": "void encode(OutputStream outStream){\r\n    for (int i = 0; i != keys.size(); i++) {\r\n        PGPPublicKey k = (PGPPublicKey) keys.get(i);\r\n        k.encode(outStream, forTransfer);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.DERGeneralString.getString",
	"Comment": "return a java string representation of our contained string.",
	"Method": "String getString(){\r\n    return Strings.fromByteArray(string);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.modes.G3413CTRBlockCipher.processBlock",
	"Comment": "process one block of input from the array in and write it tothe out array.",
	"Method": "int processBlock(byte[] in,int inOff,byte[] out,int outOff){\r\n    processBytes(in, inOff, s, out, outOff);\r\n    return s;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.gmss.GMSSRootSig.updateSign",
	"Comment": "this method performs steps steps of distributed signaturecalculaion",
	"Method": "boolean updateSign(){\r\n    for (int s = 0; s < steps; s++) {\r\n        if (counter < keysize) {\r\n            oneStep();\r\n        }\r\n        if (counter == keysize) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2Matrix.rightMultiply",
	"Comment": "compute the product of this matrix and the given column vector.",
	"Method": "Matrix rightMultiply(Matrix mat,Matrix rightMultiply,Permutation p,Vector rightMultiply,Vector vec){\r\n    if (!(vec instanceof GF2Vector)) {\r\n        throw new ArithmeticException(\"vector is not defined over GF(2)\");\r\n    }\r\n    if (vec.length != numColumns) {\r\n        throw new ArithmeticException(\"length mismatch\");\r\n    }\r\n    int[] v = ((GF2Vector) vec).getVecArray();\r\n    int[] res = new int[(numRows + 31) >>> 5];\r\n    for (int i = 0; i < numRows; i++) {\r\n        int help = 0;\r\n        for (int j = 0; j < length; j++) {\r\n            help ^= matrix[i][j] & v[j];\r\n        }\r\n        int bitValue = 0;\r\n        for (int j = 0; j < 32; j++) {\r\n            bitValue ^= (help >>> j) & 1;\r\n        }\r\n        if (bitValue == 1) {\r\n            res[i >>> 5] |= 1 << (i & 0x1f);\r\n        }\r\n    }\r\n    return new GF2Vector(res, numRows);\r\n}"
}, {
	"Path": "org.bouncycastle.cert.X509v2AttributeCertificateBuilder.addAttribute",
	"Comment": "add an attribute with multiple values to the certification request we are building.",
	"Method": "X509v2AttributeCertificateBuilder addAttribute(ASN1ObjectIdentifier attrType,ASN1Encodable attrValue,X509v2AttributeCertificateBuilder addAttribute,ASN1ObjectIdentifier attrType,ASN1Encodable[] attrValues){\r\n    acInfoGen.addAttribute(new Attribute(attrType, new DERSet(attrValues)));\r\n    return this;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.cmp.ProtectedPKIMessage.getCertificates",
	"Comment": "return the extra certificates associated with this message.",
	"Method": "X509CertificateHolder[] getCertificates(){\r\n    CMPCertificate[] certs = pkiMessage.getExtraCerts();\r\n    if (certs == null) {\r\n        return new X509CertificateHolder[0];\r\n    }\r\n    X509CertificateHolder[] res = new X509CertificateHolder[certs.length];\r\n    for (int i = 0; i != certs.length; i++) {\r\n        res[i] = new X509CertificateHolder(certs[i].getX509v3PKCert());\r\n    }\r\n    return res;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.eac.CertificateHolderAuthorization.toASN1Primitive",
	"Comment": "return the certificate holder authorization as a derapplicationspecific object",
	"Method": "ASN1Primitive toASN1Primitive(){\r\n    ASN1EncodableVector v = new ASN1EncodableVector();\r\n    v.add(oid);\r\n    v.add(accessRights);\r\n    return new DERApplicationSpecific(EACTags.CERTIFICATE_HOLDER_AUTHORIZATION_TEMPLATE, v);\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2nPolynomial.reduce",
	"Comment": "reduces this by g and returns the result in a newpolynomialgf2n.",
	"Method": "GF2nPolynomial reduce(GF2nPolynomial g){\r\n    return remainder(g);\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.X509CertSelector.setCertificateValid",
	"Comment": "sets the certificatevalid criterion. the specified date must fall withinthe certificate validity period for the x509certificate. ifnull, no certificatevalid check will be done.note that the date supplied here is cloned to protect against subsequentmodifications.",
	"Method": "void setCertificateValid(Date certValid){\r\n    if (certValid == null) {\r\n        this.certValid = null;\r\n    } else {\r\n        this.certValid = new Date(certValid.getTime());\r\n    }\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.setSubjectPublicKeyAlgID",
	"Comment": "sets the subjectpublickeyalgid criterion. the x509certificate mustcontain a subject public key with the specified algorithm. ifnull, no subjectpublickeyalgid check will be done.",
	"Method": "void setSubjectPublicKeyAlgID(String oid){\r\n    CertUtil.parseOID(oid);\r\n    subjectKeyAlgID = new ASN1ObjectIdentifier(oid);\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.spec.KTSParameterSpec.getKdfAlgorithm",
	"Comment": "return the algorithmidentifier for the kdf to do key derivation after extracting the secret.",
	"Method": "AlgorithmIdentifier getKdfAlgorithm(){\r\n    return kdfAlgorithm;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.io.CipherInputStream.ensureCapacity",
	"Comment": "ensure the cipher text buffer has space sufficient to accept an upcoming output.",
	"Method": "void ensureCapacity(int updateSize,boolean finalOutput){\r\n    int bufLen = updateSize;\r\n    if (finalOutput) {\r\n        if (bufferedBlockCipher != null) {\r\n            bufLen = bufferedBlockCipher.getOutputSize(updateSize);\r\n        } else if (aeadBlockCipher != null) {\r\n            bufLen = aeadBlockCipher.getOutputSize(updateSize);\r\n        }\r\n    } else {\r\n        if (bufferedBlockCipher != null) {\r\n            bufLen = bufferedBlockCipher.getUpdateOutputSize(updateSize);\r\n        } else if (aeadBlockCipher != null) {\r\n            bufLen = aeadBlockCipher.getUpdateOutputSize(updateSize);\r\n        }\r\n    }\r\n    if ((buf == null) || (buf.length < bufLen)) {\r\n        buf = new byte[bufLen];\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.DERGeneralString.getOctets",
	"Comment": "return a byte array representation of our contained string.",
	"Method": "byte[] getOctets(){\r\n    return Arrays.clone(string);\r\n}"
}, {
	"Path": "org.bouncycastle.cms.SignerInformation.getContentDigest",
	"Comment": "return the content digest that was calculated during verification.",
	"Method": "byte[] getContentDigest(){\r\n    if (resultDigest == null) {\r\n        throw new IllegalStateException(\"method can only be called after verify.\");\r\n    }\r\n    return Arrays.clone(resultDigest);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.util.PrivateKeyFactory.createKey",
	"Comment": "create a private key parameter from the passed in pkcs8 privatekeyinfo object.",
	"Method": "AsymmetricKeyParameter createKey(byte[] privateKeyInfoData,AsymmetricKeyParameter createKey,InputStream inStr,AsymmetricKeyParameter createKey,PrivateKeyInfo keyInfo){\r\n    AlgorithmIdentifier algId = keyInfo.getPrivateKeyAlgorithm();\r\n    ASN1ObjectIdentifier algOID = algId.getAlgorithm();\r\n    if (algOID.equals(PKCSObjectIdentifiers.rsaEncryption) || algOID.equals(PKCSObjectIdentifiers.id_RSASSA_PSS) || algOID.equals(X509ObjectIdentifiers.id_ea_rsa)) {\r\n        RSAPrivateKey keyStructure = RSAPrivateKey.getInstance(keyInfo.parsePrivateKey());\r\n        return new RSAPrivateCrtKeyParameters(keyStructure.getModulus(), keyStructure.getPublicExponent(), keyStructure.getPrivateExponent(), keyStructure.getPrime1(), keyStructure.getPrime2(), keyStructure.getExponent1(), keyStructure.getExponent2(), keyStructure.getCoefficient());\r\n    } else if (algOID.equals(PKCSObjectIdentifiers.dhKeyAgreement)) {\r\n        DHParameter params = DHParameter.getInstance(algId.getParameters());\r\n        ASN1Integer derX = (ASN1Integer) keyInfo.parsePrivateKey();\r\n        BigInteger lVal = params.getL();\r\n        int l = lVal == null ? 0 : lVal.intValue();\r\n        DHParameters dhParams = new DHParameters(params.getP(), params.getG(), null, l);\r\n        return new DHPrivateKeyParameters(derX.getValue(), dhParams);\r\n    } else if (algOID.equals(OIWObjectIdentifiers.elGamalAlgorithm)) {\r\n        ElGamalParameter params = ElGamalParameter.getInstance(algId.getParameters());\r\n        ASN1Integer derX = (ASN1Integer) keyInfo.parsePrivateKey();\r\n        return new ElGamalPrivateKeyParameters(derX.getValue(), new ElGamalParameters(params.getP(), params.getG()));\r\n    } else if (algOID.equals(X9ObjectIdentifiers.id_dsa)) {\r\n        ASN1Integer derX = (ASN1Integer) keyInfo.parsePrivateKey();\r\n        ASN1Encodable de = algId.getParameters();\r\n        DSAParameters parameters = null;\r\n        if (de != null) {\r\n            DSAParameter params = DSAParameter.getInstance(de.toASN1Primitive());\r\n            parameters = new DSAParameters(params.getP(), params.getQ(), params.getG());\r\n        }\r\n        return new DSAPrivateKeyParameters(derX.getValue(), parameters);\r\n    } else if (algOID.equals(X9ObjectIdentifiers.id_ecPublicKey)) {\r\n        X962Parameters params = new X962Parameters((ASN1Primitive) algId.getParameters());\r\n        X9ECParameters x9;\r\n        ECDomainParameters dParams;\r\n        if (params.isNamedCurve()) {\r\n            ASN1ObjectIdentifier oid = (ASN1ObjectIdentifier) params.getParameters();\r\n            x9 = CustomNamedCurves.getByOID(oid);\r\n            if (x9 == null) {\r\n                x9 = ECNamedCurveTable.getByOID(oid);\r\n            }\r\n            dParams = new ECNamedDomainParameters(oid, x9.getCurve(), x9.getG(), x9.getN(), x9.getH(), x9.getSeed());\r\n        } else {\r\n            x9 = X9ECParameters.getInstance(params.getParameters());\r\n            dParams = new ECDomainParameters(x9.getCurve(), x9.getG(), x9.getN(), x9.getH(), x9.getSeed());\r\n        }\r\n        ECPrivateKey ec = ECPrivateKey.getInstance(keyInfo.parsePrivateKey());\r\n        BigInteger d = ec.getKey();\r\n        return new ECPrivateKeyParameters(d, dParams);\r\n    } else if (algOID.equals(EdECObjectIdentifiers.id_X25519)) {\r\n        return new X25519PrivateKeyParameters(getRawKey(keyInfo, X25519PrivateKeyParameters.KEY_SIZE), 0);\r\n    } else if (algOID.equals(EdECObjectIdentifiers.id_X448)) {\r\n        return new X448PrivateKeyParameters(getRawKey(keyInfo, X448PrivateKeyParameters.KEY_SIZE), 0);\r\n    } else if (algOID.equals(EdECObjectIdentifiers.id_Ed25519)) {\r\n        return new Ed25519PrivateKeyParameters(getRawKey(keyInfo, Ed25519PrivateKeyParameters.KEY_SIZE), 0);\r\n    } else if (algOID.equals(EdECObjectIdentifiers.id_Ed448)) {\r\n        return new Ed448PrivateKeyParameters(getRawKey(keyInfo, Ed448PrivateKeyParameters.KEY_SIZE), 0);\r\n    } else {\r\n        throw new RuntimeException(\"algorithm identifier in private key not recognised\");\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.cert.X509CRLHolder.getRevokedCertificates",
	"Comment": "return a collection of x509crlentryholder objects, giving the details of therevoked certificates that appear on this crl.",
	"Method": "Collection getRevokedCertificates(){\r\n    TBSCertList.CRLEntry[] entries = x509CRL.getRevokedCertificates();\r\n    List l = new ArrayList(entries.length);\r\n    GeneralNames currentCA = issuerName;\r\n    for (Enumeration en = x509CRL.getRevokedCertificateEnumeration(); en.hasMoreElements(); ) {\r\n        TBSCertList.CRLEntry entry = (TBSCertList.CRLEntry) en.nextElement();\r\n        X509CRLEntryHolder crlEntry = new X509CRLEntryHolder(entry, isIndirect, currentCA);\r\n        l.add(crlEntry);\r\n        currentCA = crlEntry.getCertificateIssuer();\r\n    }\r\n    return l;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.selector.X509AttributeCertificateHolderSelector.getSerialNumber",
	"Comment": "gets the serial number the attribute certificate must have.",
	"Method": "BigInteger getSerialNumber(){\r\n    return serialNumber;\r\n}"
}, {
	"Path": "org.bouncycastle.pkix.jcajce.ReasonsMask.isAllReasons",
	"Comment": "returns true if this reasons mask contains all possiblereasons.",
	"Method": "boolean isAllReasons(){\r\n    return _reasons == allReasons._reasons ? true : false;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2Polynomial.quotient",
	"Comment": "returns the absolute quotient of this divided by g in anew gf2polynomial.",
	"Method": "GF2Polynomial quotient(GF2Polynomial g){\r\n    GF2Polynomial q = new GF2Polynomial(len);\r\n    GF2Polynomial a = new GF2Polynomial(this);\r\n    GF2Polynomial b = new GF2Polynomial(g);\r\n    GF2Polynomial j;\r\n    int i;\r\n    if (b.isZero()) {\r\n        throw new RuntimeException();\r\n    }\r\n    a.reduceN();\r\n    b.reduceN();\r\n    if (a.len < b.len) {\r\n        return new GF2Polynomial(0);\r\n    }\r\n    i = a.len - b.len;\r\n    q.expandN(i + 1);\r\n    while (i >= 0) {\r\n        j = b.shiftLeft(i);\r\n        a.subtractFromThis(j);\r\n        a.reduceN();\r\n        q.xorBit(i);\r\n        i = a.len - b.len;\r\n    }\r\n    return q;\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSSignedGenerator.getGeneratedDigests",
	"Comment": "return a map of oids and byte arrays representing the digests calculated on the content duringthe last generate.",
	"Method": "Map getGeneratedDigests(){\r\n    return new HashMap(digests);\r\n}"
}, {
	"Path": "org.bouncycastle.x509.ExtendedPKIXParameters.getNecessaryACAttributes",
	"Comment": "returns the neccessary attributes which must be contained in an attributecertificate.the returned set is immutable and containsstrings with the oids.",
	"Method": "Set getNecessaryACAttributes(){\r\n    return Collections.unmodifiableSet(necessaryACAttributes);\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.operator.PBEKeyEncryptionMethodGenerator.setSecureRandom",
	"Comment": "sets a user defined source of randomness.if no securerandom is configured, a default securerandom will be used.",
	"Method": "PBEKeyEncryptionMethodGenerator setSecureRandom(SecureRandom random){\r\n    this.random = random;\r\n    return this;\r\n}"
}, {
	"Path": "org.bouncycastle.util.io.BufferingOutputStream.flush",
	"Comment": "flush the internal buffer to the encapsulated output stream. zero the buffer contents when done.",
	"Method": "void flush(){\r\n    other.write(buf, 0, bufOff);\r\n    bufOff = 0;\r\n    Arrays.fill(buf, (byte) 0);\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSEnvelopedDataParser.getEncryptionAlgOID",
	"Comment": "return the object identifier for the content encryption algorithm.",
	"Method": "String getEncryptionAlgOID(){\r\n    return encAlg.getAlgorithm().toString();\r\n}"
}, {
	"Path": "javax.crypto.spec.RC5ParameterSpec.hashCode",
	"Comment": "calculates a hash code value for the object.objects that are equal will also have the same hashcode.",
	"Method": "int hashCode(){\r\n    int code = version ^ rounds ^ wordSize;\r\n    if (iv != null) {\r\n        for (int i = 0; i != iv.length; i++) {\r\n            code ^= iv[i] << (8 * (i % 4));\r\n        }\r\n    }\r\n    return code;\r\n}"
}, {
	"Path": "java.security.cert.CertPathValidatorException.getCause",
	"Comment": "returns the cause of this certpathvalidatorexception or null if the cause is nonexistent or unknown.",
	"Method": "Throwable getCause(){\r\n    return cause;\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.getExtendedKeyUsage",
	"Comment": "returns the extendedkeyusage criterion. the x509certificatemust allow the specified key purposes in its extended key usageextension. if the keypurposeset returned is empty ornull, no extendedkeyusage check will be done. note thatan x509certificate that has no extendedkeyusage extensionimplicitly allows all key purposes.",
	"Method": "Set getExtendedKeyUsage(){\r\n    if (keyPurposeSet == null || keyPurposeSet.isEmpty()) {\r\n        return keyPurposeSet;\r\n    }\r\n    Set returnSet = new HashSet();\r\n    Iterator iter = keyPurposeSet.iterator();\r\n    while (iter.hasNext()) {\r\n        returnSet.add(iter.next().toString());\r\n    }\r\n    return Collections.unmodifiableSet(returnSet);\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSAuthenticatedDataParser.getOriginatorInfo",
	"Comment": "return the originator information associated with this message if present.",
	"Method": "OriginatorInformation getOriginatorInfo(){\r\n    return originatorInfo;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.provider.PKIXNameConstraintValidator.checkExcluded",
	"Comment": "check if the given generalname is contained in the excluded set.",
	"Method": "void checkExcluded(GeneralName name){\r\n    switch(name.getTagNo()) {\r\n        case 1:\r\n            checkExcludedEmail(excludedSubtreesEmail, extractNameAsString(name));\r\n            break;\r\n        case 2:\r\n            checkExcludedDNS(excludedSubtreesDNS, DERIA5String.getInstance(name.getName()).getString());\r\n            break;\r\n        case 4:\r\n            checkExcludedDN(ASN1Sequence.getInstance(name.getName().toASN1Primitive()));\r\n            break;\r\n        case 6:\r\n            checkExcludedURI(excludedSubtreesURI, DERIA5String.getInstance(name.getName()).getString());\r\n            break;\r\n        case 7:\r\n            byte[] ip = ASN1OctetString.getInstance(name.getName()).getOctets();\r\n            checkExcludedIP(excludedSubtreesIP, ip);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.i18n.ErrorBundle.getSummary",
	"Comment": "returns the summary message in the given locale and the default timezone.",
	"Method": "String getSummary(Locale loc,TimeZone timezone,String getSummary,Locale loc){\r\n    return getEntry(SUMMARY_ENTRY, loc, TimeZone.getDefault());\r\n}"
}, {
	"Path": "org.bouncycastle.jce.provider.JCEElGamalPrivateKey.getEncoded",
	"Comment": "return a pkcs8 representation of the key. the sequence returnedrepresents a full privatekeyinfo object.",
	"Method": "byte[] getEncoded(){\r\n    return KeyUtil.getEncodedPrivateKeyInfo(new AlgorithmIdentifier(OIWObjectIdentifiers.elGamalAlgorithm, new ElGamalParameter(elSpec.getP(), elSpec.getG())), new ASN1Integer(getX()));\r\n}"
}, {
	"Path": "org.bouncycastle.cert.ocsp.OCSPReq.isSignatureValid",
	"Comment": "verify the signature against the tbsrequest object we contain.",
	"Method": "boolean isSignatureValid(ContentVerifierProvider verifierProvider){\r\n    if (!this.isSigned()) {\r\n        throw new OCSPException(\"attempt to verify signature on unsigned object\");\r\n    }\r\n    try {\r\n        ContentVerifier verifier = verifierProvider.get(req.getOptionalSignature().getSignatureAlgorithm());\r\n        OutputStream sOut = verifier.getOutputStream();\r\n        sOut.write(req.getTbsRequest().getEncoded(ASN1Encoding.DER));\r\n        return verifier.verify(this.getSignature());\r\n    } catch (Exception e) {\r\n        throw new OCSPException(\"exception processing signature: \" + e, e);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM.gcd",
	"Comment": "return the greatest common divisor of this and a polynomial f",
	"Method": "PolynomialGF2mSmallM gcd(PolynomialGF2mSmallM f,int[] gcd,int[] f,int[] g){\r\n    int[] a = f;\r\n    int[] b = g;\r\n    if (computeDegree(a) == -1) {\r\n        return b;\r\n    }\r\n    while (computeDegree(b) != -1) {\r\n        int[] c = mod(a, b);\r\n        a = new int[b.length];\r\n        System.arraycopy(b, 0, a, 0, a.length);\r\n        b = new int[c.length];\r\n        System.arraycopy(c, 0, b, 0, b.length);\r\n    }\r\n    int coeff = field.inverse(headCoefficient(a));\r\n    return multWithElement(a, coeff);\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSSignedGenerator.addCertificates",
	"Comment": "add the certificates in certstore to the certificate set to be included with the generated signeddata message.",
	"Method": "void addCertificates(Store certStore){\r\n    certs.addAll(CMSUtils.getCertificatesFromStore(certStore));\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2nPolynomialElement.squarePreCalc",
	"Comment": "squares this gf2npolynomialelement by using precalculated values andreducing. this is supposed to de fastest when using a trinomial orpentanomial as field polynomial. use squarematrix when using a ordinarypolynomial as field polynomial.",
	"Method": "GF2nPolynomialElement squarePreCalc(){\r\n    GF2nPolynomialElement result = new GF2nPolynomialElement(this);\r\n    result.squareThisPreCalc();\r\n    result.reduceThis();\r\n    return result;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.gmss.GMSSLeaf.getStatInt",
	"Comment": "returns the status int array used by the gmssprivatekeyasn.1 class",
	"Method": "int[] getStatInt(){\r\n    int[] statInt = new int[4];\r\n    statInt[0] = i;\r\n    statInt[1] = j;\r\n    statInt[2] = steps;\r\n    statInt[3] = w;\r\n    return statInt;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.modes.OldCTSBlockCipher.processByte",
	"Comment": "process a single byte, producing an output block if necessary.",
	"Method": "int processByte(byte in,byte[] out,int outOff){\r\n    int resultLen = 0;\r\n    if (bufOff == buf.length) {\r\n        resultLen = cipher.processBlock(buf, 0, out, outOff);\r\n        System.arraycopy(buf, blockSize, buf, 0, blockSize);\r\n        bufOff = blockSize;\r\n    }\r\n    buf[bufOff++] = in;\r\n    return resultLen;\r\n}"
}, {
	"Path": "java.security.cert.CertStoreException.getCause",
	"Comment": "returns the cause of this certstoreexception or null if the cause is nonexistent or unknown.",
	"Method": "Throwable getCause(){\r\n    return cause;\r\n}"
}, {
	"Path": "org.bouncycastle.pkix.jcajce.RevocationUtilities.getNextWorkingKey",
	"Comment": "return the next working key inheriting dsa parameters if necessary.this methods inherits dsa parameters from the indexed certificate orprevious certificates in the certificate chain to the returnedpublickey. the list is searched upwards, meaning the endcertificate is at position 0 and previous certificates are following.if the indexed certificate does not contain a dsa key this method simplyreturns the public key. if the dsa key already contains dsa parametersthe key is also only returned.",
	"Method": "PublicKey getNextWorkingKey(List certs,int index,JcaJceHelper helper){\r\n    Certificate cert = (Certificate) certs.get(index);\r\n    PublicKey pubKey = cert.getPublicKey();\r\n    if (!(pubKey instanceof DSAPublicKey)) {\r\n        return pubKey;\r\n    }\r\n    DSAPublicKey dsaPubKey = (DSAPublicKey) pubKey;\r\n    if (dsaPubKey.getParams() != null) {\r\n        return dsaPubKey;\r\n    }\r\n    for (int i = index + 1; i < certs.size(); i++) {\r\n        X509Certificate parentCert = (X509Certificate) certs.get(i);\r\n        pubKey = parentCert.getPublicKey();\r\n        if (!(pubKey instanceof DSAPublicKey)) {\r\n            throw new CertPathValidatorException(\"DSA parameters cannot be inherited from previous certificate.\");\r\n        }\r\n        DSAPublicKey prevDSAPubKey = (DSAPublicKey) pubKey;\r\n        if (prevDSAPubKey.getParams() == null) {\r\n            continue;\r\n        }\r\n        DSAParams dsaParams = prevDSAPubKey.getParams();\r\n        DSAPublicKeySpec dsaPubKeySpec = new DSAPublicKeySpec(dsaPubKey.getY(), dsaParams.getP(), dsaParams.getQ(), dsaParams.getG());\r\n        try {\r\n            KeyFactory keyFactory = helper.createKeyFactory(\"DSA\");\r\n            return keyFactory.generatePublic(dsaPubKeySpec);\r\n        } catch (Exception exception) {\r\n            throw new RuntimeException(exception.getMessage());\r\n        }\r\n    }\r\n    throw new CertPathValidatorException(\"DSA parameters cannot be inherited from previous certificate.\");\r\n}"
}, {
	"Path": "org.bouncycastle.cms.jcajce.JceKEKRecipient.setProvider",
	"Comment": "set the provider to use for key recovery and content processing.",
	"Method": "JceKEKRecipient setProvider(Provider provider,JceKEKRecipient setProvider,String providerName){\r\n    this.helper = new EnvelopedDataHelper(new NamedJcaJceExtHelper(providerName));\r\n    this.contentHelper = helper;\r\n    return this;\r\n}"
}, {
	"Path": "javax.crypto.CipherInputStream.nextChunk",
	"Comment": "grab the next chunk of input from the underlying input stream",
	"Method": "int nextChunk(){\r\n    int available = super.available();\r\n    if (available <= 0) {\r\n        available = 1;\r\n    }\r\n    if (available > inBuf.length) {\r\n        available = super.read(inBuf, 0, inBuf.length);\r\n    } else {\r\n        available = super.read(inBuf, 0, available);\r\n    }\r\n    if (available < 0) {\r\n        if (finalized) {\r\n            return -1;\r\n        }\r\n        try {\r\n            buf = c.doFinal();\r\n        } catch (Exception e) {\r\n            throw new IOException(\"error processing stream: \" + e.toString());\r\n        }\r\n        bufOff = 0;\r\n        if (buf != null) {\r\n            maxBuf = buf.length;\r\n        } else {\r\n            maxBuf = 0;\r\n        }\r\n        finalized = true;\r\n        if (bufOff == maxBuf) {\r\n            return -1;\r\n        }\r\n    } else {\r\n        bufOff = 0;\r\n        try {\r\n            maxBuf = c.update(inBuf, 0, available, buf, 0);\r\n        } catch (Exception e) {\r\n            throw new IOException(\"error processing stream: \" + e.toString());\r\n        }\r\n        if (maxBuf == 0) {\r\n            return nextChunk();\r\n        }\r\n    }\r\n    return maxBuf;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.modes.GOFBBlockCipher.reset",
	"Comment": "reset the feedback vector back to the iv and reset the underlyingcipher.",
	"Method": "void reset(){\r\n    firstStep = true;\r\n    N3 = 0;\r\n    N4 = 0;\r\n    System.arraycopy(IV, 0, ofbV, 0, IV.length);\r\n    byteCount = 0;\r\n    cipher.reset();\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.gmss.Treehash.updateNextSeed",
	"Comment": "updates the nextseed of this treehash instance one step needed for theschedulng of the seeds",
	"Method": "void updateNextSeed(GMSSRandom gmssRandom){\r\n    gmssRandom.nextSeed(seedNext);\r\n}"
}, {
	"Path": "org.bouncycastle.tls.crypto.impl.jcajce.JcaTlsCrypto.createBlockCipher",
	"Comment": "if you want to create your own versions of the block ciphers required, override this method.",
	"Method": "TlsBlockCipherImpl createBlockCipher(String cipherName,String algorithm,int keySize,boolean isEncrypting){\r\n    return new JceBlockCipherImpl(helper.createCipher(cipherName), algorithm, keySize, isEncrypting);\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.setSerialNumber",
	"Comment": "sets the serialnumber criterion. the specified serial number must matchthe certificate serial number in the x509certificate. ifnull, any certificate serial number will do.",
	"Method": "void setSerialNumber(BigInteger serial){\r\n    serialNumber = serial;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.provider.CertPathValidatorUtilities.getNextWorkingKey",
	"Comment": "return the next working key inheriting dsa parameters if necessary.this methods inherits dsa parameters from the indexed certificate orprevious certificates in the certificate chain to the returnedpublickey. the list is searched upwards, meaning the endcertificate is at position 0 and previous certificates are following.if the indexed certificate does not contain a dsa key this method simplyreturns the public key. if the dsa key already contains dsa parametersthe key is also only returned.",
	"Method": "PublicKey getNextWorkingKey(List certs,int index,JcaJceHelper helper){\r\n    Certificate cert = (Certificate) certs.get(index);\r\n    PublicKey pubKey = cert.getPublicKey();\r\n    if (!(pubKey instanceof DSAPublicKey)) {\r\n        return pubKey;\r\n    }\r\n    DSAPublicKey dsaPubKey = (DSAPublicKey) pubKey;\r\n    if (dsaPubKey.getParams() != null) {\r\n        return dsaPubKey;\r\n    }\r\n    for (int i = index + 1; i < certs.size(); i++) {\r\n        X509Certificate parentCert = (X509Certificate) certs.get(i);\r\n        pubKey = parentCert.getPublicKey();\r\n        if (!(pubKey instanceof DSAPublicKey)) {\r\n            throw new CertPathValidatorException(\"DSA parameters cannot be inherited from previous certificate.\");\r\n        }\r\n        DSAPublicKey prevDSAPubKey = (DSAPublicKey) pubKey;\r\n        if (prevDSAPubKey.getParams() == null) {\r\n            continue;\r\n        }\r\n        DSAParams dsaParams = prevDSAPubKey.getParams();\r\n        DSAPublicKeySpec dsaPubKeySpec = new DSAPublicKeySpec(dsaPubKey.getY(), dsaParams.getP(), dsaParams.getQ(), dsaParams.getG());\r\n        try {\r\n            KeyFactory keyFactory = helper.createKeyFactory(\"DSA\");\r\n            return keyFactory.generatePublic(dsaPubKeySpec);\r\n        } catch (Exception exception) {\r\n            throw new RuntimeException(exception.getMessage());\r\n        }\r\n    }\r\n    throw new CertPathValidatorException(\"DSA parameters cannot be inherited from previous certificate.\");\r\n}"
}, {
	"Path": "org.bouncycastle.pkix.jcajce.RevocationUtilities.getCRLIssuersFromDistributionPoint",
	"Comment": "add the crl issuers from the crlissuer field of the distribution point orfrom the certificate if not given to the issuer criterion of theselector.the issuerprincipals are a collection with a singlex500name for x509certificates.",
	"Method": "void getCRLIssuersFromDistributionPoint(DistributionPoint dp,Collection issuerPrincipals,X509CRLSelector selector){\r\n    List issuers = new ArrayList();\r\n    if (dp.getCRLIssuer() != null) {\r\n        GeneralName[] genNames = dp.getCRLIssuer().getNames();\r\n        for (int j = 0; j < genNames.length; j++) {\r\n            if (genNames[j].getTagNo() == GeneralName.directoryName) {\r\n                try {\r\n                    issuers.add(X500Name.getInstance(genNames[j].getName().toASN1Primitive().getEncoded()));\r\n                } catch (IOException e) {\r\n                    throw new AnnotatedException(\"CRL issuer information from distribution point cannot be decoded.\", e);\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        if (dp.getDistributionPoint() == null) {\r\n            throw new AnnotatedException(\"CRL issuer is omitted from distribution point but no distributionPoint field present.\");\r\n        }\r\n        for (Iterator it = issuerPrincipals.iterator(); it.hasNext(); ) {\r\n            issuers.add(it.next());\r\n        }\r\n    }\r\n    Iterator it = issuers.iterator();\r\n    while (it.hasNext()) {\r\n        try {\r\n            selector.addIssuerName(((X500Name) it.next()).getEncoded());\r\n        } catch (IOException ex) {\r\n            throw new AnnotatedException(\"Cannot decode CRL issuer information.\", ex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.jce.provider.PKIXNameConstraintValidator.intersectIP",
	"Comment": "returns the intersection of the permitted ip ranges inpermitted with ip.",
	"Method": "Set intersectIP(Set permitted,Set ips){\r\n    Set intersect = new HashSet();\r\n    for (Iterator it = ips.iterator(); it.hasNext(); ) {\r\n        byte[] ip = ASN1OctetString.getInstance(((GeneralSubtree) it.next()).getBase().getName()).getOctets();\r\n        if (permitted == null) {\r\n            if (ip != null) {\r\n                intersect.add(ip);\r\n            }\r\n        } else {\r\n            Iterator it2 = permitted.iterator();\r\n            while (it2.hasNext()) {\r\n                byte[] _permitted = (byte[]) it2.next();\r\n                intersect.addAll(intersectIPRange(_permitted, ip));\r\n            }\r\n        }\r\n    }\r\n    return intersect;\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPPBEEncryptedData.getDataStream",
	"Comment": "open an input stream which will provide the decrypted data protected by this object.",
	"Method": "InputStream getDataStream(PBEDataDecryptorFactory dataDecryptorFactory){\r\n    try {\r\n        int keyAlgorithm = keyData.getEncAlgorithm();\r\n        byte[] key = dataDecryptorFactory.makeKeyFromPassPhrase(keyAlgorithm, keyData.getS2K());\r\n        boolean withIntegrityPacket = encData instanceof SymmetricEncIntegrityPacket;\r\n        byte[] sessionData = dataDecryptorFactory.recoverSessionData(keyData.getEncAlgorithm(), key, keyData.getSecKeyData());\r\n        byte[] sessionKey = new byte[sessionData.length - 1];\r\n        System.arraycopy(sessionData, 1, sessionKey, 0, sessionKey.length);\r\n        PGPDataDecryptor dataDecryptor = dataDecryptorFactory.createDataDecryptor(withIntegrityPacket, sessionData[0] & 0xff, sessionKey);\r\n        encStream = new BCPGInputStream(dataDecryptor.getInputStream(encData.getInputStream()));\r\n        if (withIntegrityPacket) {\r\n            truncStream = new TruncatedStream(encStream);\r\n            integrityCalculator = dataDecryptor.getIntegrityCalculator();\r\n            encStream = new TeeInputStream(truncStream, integrityCalculator.getOutputStream());\r\n        }\r\n        byte[] iv = new byte[dataDecryptor.getBlockSize()];\r\n        for (int i = 0; i != iv.length; i++) {\r\n            int ch = encStream.read();\r\n            if (ch < 0) {\r\n                throw new EOFException(\"unexpected end of stream.\");\r\n            }\r\n            iv[i] = (byte) ch;\r\n        }\r\n        int v1 = encStream.read();\r\n        int v2 = encStream.read();\r\n        if (v1 < 0 || v2 < 0) {\r\n            throw new EOFException(\"unexpected end of stream.\");\r\n        }\r\n        boolean repeatCheckPassed = iv[iv.length - 2] == (byte) v1 && iv[iv.length - 1] == (byte) v2;\r\n        boolean zeroesCheckPassed = v1 == 0 && v2 == 0;\r\n        if (!repeatCheckPassed && !zeroesCheckPassed) {\r\n            throw new PGPDataValidationException(\"data check failed.\");\r\n        }\r\n        return encStream;\r\n    } catch (PGPException e) {\r\n        throw e;\r\n    } catch (Exception e) {\r\n        throw new PGPException(\"Exception creating cipher\", e);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.generators.PKCS5S1ParametersGenerator.generateDerivedKey",
	"Comment": "the derived key function, the ith hash of the password and the salt.",
	"Method": "byte[] generateDerivedKey(){\r\n    byte[] digestBytes = new byte[digest.getDigestSize()];\r\n    digest.update(password, 0, password.length);\r\n    digest.update(salt, 0, salt.length);\r\n    digest.doFinal(digestBytes, 0);\r\n    for (int i = 1; i < iterationCount; i++) {\r\n        digest.update(digestBytes, 0, digestBytes.length);\r\n        digest.doFinal(digestBytes, 0);\r\n    }\r\n    return digestBytes;\r\n}"
}, {
	"Path": "org.bouncycastle.cms.SignerInformation.getUnsignedAttributes",
	"Comment": "return a table of the unsigned attributes indexed bythe oid of the attribute.",
	"Method": "AttributeTable getUnsignedAttributes(){\r\n    if (unsignedAttributeSet != null && unsignedAttributeValues == null) {\r\n        unsignedAttributeValues = new AttributeTable(unsignedAttributeSet);\r\n    }\r\n    return unsignedAttributeValues;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.selector.X509AttributeCertificateHolderSelector.match",
	"Comment": "decides if the given attribute certificate should be selected.",
	"Method": "boolean match(Object obj){\r\n    if (!(obj instanceof X509AttributeCertificateHolder)) {\r\n        return false;\r\n    }\r\n    X509AttributeCertificateHolder attrCert = (X509AttributeCertificateHolder) obj;\r\n    if (this.attributeCert != null) {\r\n        if (!this.attributeCert.equals(attrCert)) {\r\n            return false;\r\n        }\r\n    }\r\n    if (serialNumber != null) {\r\n        if (!attrCert.getSerialNumber().equals(serialNumber)) {\r\n            return false;\r\n        }\r\n    }\r\n    if (holder != null) {\r\n        if (!attrCert.getHolder().equals(holder)) {\r\n            return false;\r\n        }\r\n    }\r\n    if (issuer != null) {\r\n        if (!attrCert.getIssuer().equals(issuer)) {\r\n            return false;\r\n        }\r\n    }\r\n    if (attributeCertificateValid != null) {\r\n        if (!attrCert.isValidOn(attributeCertificateValid)) {\r\n            return false;\r\n        }\r\n    }\r\n    if (!targetNames.isEmpty() || !targetGroups.isEmpty()) {\r\n        Extension targetInfoExt = attrCert.getExtension(Extension.targetInformation);\r\n        if (targetInfoExt != null) {\r\n            TargetInformation targetinfo;\r\n            try {\r\n                targetinfo = TargetInformation.getInstance(targetInfoExt.getParsedValue());\r\n            } catch (IllegalArgumentException e) {\r\n                return false;\r\n            }\r\n            Targets[] targetss = targetinfo.getTargetsObjects();\r\n            if (!targetNames.isEmpty()) {\r\n                boolean found = false;\r\n                for (int i = 0; i < targetss.length; i++) {\r\n                    Targets t = targetss[i];\r\n                    Target[] targets = t.getTargets();\r\n                    for (int j = 0; j < targets.length; j++) {\r\n                        if (targetNames.contains(GeneralName.getInstance(targets[j].getTargetName()))) {\r\n                            found = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                if (!found) {\r\n                    return false;\r\n                }\r\n            }\r\n            if (!targetGroups.isEmpty()) {\r\n                boolean found = false;\r\n                for (int i = 0; i < targetss.length; i++) {\r\n                    Targets t = targetss[i];\r\n                    Target[] targets = t.getTargets();\r\n                    for (int j = 0; j < targets.length; j++) {\r\n                        if (targetGroups.contains(GeneralName.getInstance(targets[j].getTargetGroup()))) {\r\n                            found = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                if (!found) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2mVector.add",
	"Comment": "add another vector to this vector. method is not yet implemented.",
	"Method": "Vector add(Vector addend){\r\n    throw new RuntimeException(\"not implemented\");\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.CharUtils.toByteArrayForPBE",
	"Comment": "convert the given char array into abyte array for use with pbe encryption.",
	"Method": "byte[] toByteArrayForPBE(char[] chars){\r\n    byte[] out = new byte[chars.length];\r\n    for (int i = 0; i < chars.length; i++) {\r\n        out[i] = (byte) chars[i];\r\n    }\r\n    int length = out.length * 2;\r\n    byte[] ret = new byte[length + 2];\r\n    int j = 0;\r\n    for (int i = 0; i < out.length; i++) {\r\n        j = i * 2;\r\n        ret[j] = 0;\r\n        ret[j + 1] = out[i];\r\n    }\r\n    ret[length] = 0;\r\n    ret[length + 1] = 0;\r\n    return ret;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.rainbow.util.RainbowUtil.convertArray",
	"Comment": "this function converts a matrix of type short into a matrix of type byte",
	"Method": "short[] convertArray(byte[] in,short[][] convertArray,byte[][] in,short[][][] convertArray,byte[][][] in,byte[] convertArray,short[] in,byte[][] convertArray,short[][] in,byte[][][] convertArray,short[][][] in){\r\n    byte[][][] out = new byte[in.length][in[0].length][in[0][0].length];\r\n    for (int i = 0; i < in.length; i++) {\r\n        for (int j = 0; j < in[0].length; j++) {\r\n            for (int k = 0; k < in[0][0].length; k++) {\r\n                out[i][j][k] = (byte) in[i][j][k];\r\n            }\r\n        }\r\n    }\r\n    return out;\r\n}"
}, {
	"Path": "java.security.cert.CertUtil.parseIPv4",
	"Comment": "parse the given ipv4 into der encoded byte array representation.",
	"Method": "byte[] parseIPv4(String data){\r\n    if (data.length() == 0) {\r\n        return null;\r\n    }\r\n    int octet;\r\n    int octets = 0;\r\n    byte[] dst = new byte[4];\r\n    int pos = 0;\r\n    int start = 0;\r\n    while (start < data.length() && (pos = data.indexOf('.', start)) > start && pos - start > 3) {\r\n        try {\r\n            octet = (Integer.valueOf(data.substring(start, pos - start))).intValue();\r\n        } catch (NumberFormatException ex) {\r\n            return null;\r\n        }\r\n        if (octet < 0 || octet > 255) {\r\n            return null;\r\n        }\r\n        dst[octets++] = (byte) (octet & 0xff);\r\n        start = pos + 1;\r\n    }\r\n    if (octets < 4) {\r\n        return null;\r\n    }\r\n    return dst;\r\n}"
}, {
	"Path": "java.security.cert.X509CRLSelector.getMaxCRL",
	"Comment": "returns the maxcrlnumber criterion. the x509crl must havea crl number extension whose value is less than or equal to the specifiedvalue. if null, no maxcrlnumber check will be done.",
	"Method": "BigInteger getMaxCRL(){\r\n    return maxCRL;\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPOnePassSignature.verify",
	"Comment": "verify the calculated signature against the passed in pgpsignature.",
	"Method": "boolean verify(PGPSignature pgpSig){\r\n    try {\r\n        sigOut.write(pgpSig.getSignatureTrailer());\r\n        sigOut.close();\r\n    } catch (IOException e) {\r\n        throw new PGPException(\"unable to add trailer: \" + e.getMessage(), e);\r\n    }\r\n    return verifier.verify(pgpSig.getSignature());\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.test.CipherStreamTest.testTamperedWrite",
	"Comment": "test tampering of ciphertext followed by write to decrypting cipheroutputstream",
	"Method": "void testTamperedWrite(AEADBlockCipher cipher,CipherParameters params){\r\n    cipher.init(true, params);\r\n    byte[] ciphertext = new byte[cipher.getOutputSize(streamSize)];\r\n    cipher.doFinal(ciphertext, cipher.processBytes(new byte[streamSize], 0, streamSize, ciphertext, 0));\r\n    ciphertext[0] += 1;\r\n    cipher.init(false, params);\r\n    ByteArrayOutputStream plaintext = new ByteArrayOutputStream();\r\n    OutputStream output = createCipherOutputStream(plaintext, cipher);\r\n    for (int i = 0; i < ciphertext.length; i++) {\r\n        output.write(ciphertext[i]);\r\n    }\r\n    try {\r\n        output.close();\r\n        fail(\"Expected invalid ciphertext after tamper and write : \" + cipher.getAlgorithmName());\r\n    } catch (InvalidCipherTextIOException e) {\r\n    }\r\n}"
}, {
	"Path": "org.jdesktop.swingx.JXPanel.paint",
	"Comment": "overriden paint method to take into account the alpha setting",
	"Method": "void paint(Graphics g){\r\n    float a = getAlpha();\r\n    if (a == 1) {\r\n        super.paint(g);\r\n    } else {\r\n        BufferedImage img = GraphicsUtilities.createCompatibleTranslucentImage(getWidth(), getHeight());\r\n        Graphics2D gfx = img.createGraphics();\r\n        super.paint(gfx);\r\n        gfx.dispose();\r\n        Graphics2D g2d = (Graphics2D) g;\r\n        Composite oldComp = g2d.getComposite();\r\n        Composite alphaComp = AlphaComposite.getInstance(AlphaComposite.SRC_OVER, a);\r\n        g2d.setComposite(alphaComp);\r\n        g2d.drawImage(img, null, 0, 0);\r\n        g2d.setComposite(oldComp);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPSignatureSubpacketGenerator.setSignatureExpirationTime",
	"Comment": "set the number of seconds a signature is valid for after the time of its creation.a value of zero means the signature never expires.",
	"Method": "void setSignatureExpirationTime(boolean isCritical,long seconds){\r\n    list.add(new SignatureExpirationTime(isCritical, seconds));\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.gm.GMNamedCurves.getName",
	"Comment": "return the named curve name represented by the given object identifier.",
	"Method": "String getName(ASN1ObjectIdentifier oid){\r\n    return (String) names.get(oid);\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.x9.ECNamedCurveTable.getByName",
	"Comment": "return a x9ecparameters object representing the passed in namedcurve. the routine returns null if the curve is not present.",
	"Method": "X9ECParameters getByName(String name){\r\n    X9ECParameters ecP = X962NamedCurves.getByName(name);\r\n    if (ecP == null) {\r\n        ecP = SECNamedCurves.getByName(name);\r\n    }\r\n    if (ecP == null) {\r\n        ecP = NISTNamedCurves.getByName(name);\r\n    }\r\n    if (ecP == null) {\r\n        ecP = TeleTrusTNamedCurves.getByName(name);\r\n    }\r\n    if (ecP == null) {\r\n        ecP = ANSSINamedCurves.getByName(name);\r\n    }\r\n    if (ecP == null) {\r\n        ecP = fromDomainParameters(ECGOST3410NamedCurves.getByName(name));\r\n    }\r\n    if (ecP == null) {\r\n        ecP = GMNamedCurves.getByName(name);\r\n    }\r\n    return ecP;\r\n}"
}, {
	"Path": "org.bouncycastle.x509.AttributeCertificateHolder.getIssuer",
	"Comment": "return the principals associated with the issuer attached to this holder",
	"Method": "Principal[] getIssuer(){\r\n    if (holder.getBaseCertificateID() != null) {\r\n        return getPrincipals(holder.getBaseCertificateID().getIssuer());\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.tls.TlsProtocol.processChangeCipherSpec",
	"Comment": "this method is called, when a change cipher spec message is received.",
	"Method": "void processChangeCipherSpec(byte[] buf,int off,int len){\r\n    for (int i = 0; i < len; ++i) {\r\n        short message = TlsUtils.readUint8(buf, off + i);\r\n        if (message != ChangeCipherSpec.change_cipher_spec) {\r\n            throw new TlsFatalAlert(AlertDescription.decode_error);\r\n        }\r\n        if (this.receivedChangeCipherSpec || alertQueue.available() > 0 || handshakeQueue.available() > 0) {\r\n            throw new TlsFatalAlert(AlertDescription.unexpected_message);\r\n        }\r\n        recordStream.receivedReadCipherSpec();\r\n        this.receivedChangeCipherSpec = true;\r\n        handleChangeCipherSpecMessage();\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.jce.provider.X509StoreLDAPAttrCerts.engineInit",
	"Comment": "initializes this ldap attribute cert store implementation.",
	"Method": "void engineInit(X509StoreParameters parameters){\r\n    if (!(parameters instanceof X509LDAPCertStoreParameters)) {\r\n        throw new IllegalArgumentException(\"Initialization parameters must be an instance of \" + X509LDAPCertStoreParameters.class.getName() + \".\");\r\n    }\r\n    helper = new LDAPStoreHelper((X509LDAPCertStoreParameters) parameters);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.signers.DSTU4145Signer.generateRandomInteger",
	"Comment": "generates random integer such, than its bit length is less than that of n",
	"Method": "BigInteger generateRandomInteger(BigInteger n,SecureRandom random){\r\n    return BigIntegers.createRandomBigInteger(n.bitLength() - 1, random);\r\n}"
}, {
	"Path": "org.bouncycastle.cert.crmf.CertificateRequestMessageBuilder.setValidity",
	"Comment": "request a validity period for the certificate. either, but not both, of the date parameters may be null.",
	"Method": "CertificateRequestMessageBuilder setValidity(Date notBeforeDate,Date notAfterDate){\r\n    templateBuilder.setValidity(new OptionalValidity(createTime(notBeforeDate), createTime(notAfterDate)));\r\n    return this;\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPPrivateKey.getPublicKeyPacket",
	"Comment": "return the public key packet associated with this private key, if available.",
	"Method": "PublicKeyPacket getPublicKeyPacket(){\r\n    return publicKeyPacket;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.examples.DESExample.performDecrypt",
	"Comment": "this method performs all the decryption and writesthe plain text to the buffered output stream createdpreviously.",
	"Method": "void performDecrypt(byte[] key){\r\n    cipher.init(false, new KeyParameter(key));\r\n    BufferedReader br = new BufferedReader(new InputStreamReader(in));\r\n    try {\r\n        int outL;\r\n        byte[] inblock = null;\r\n        byte[] outblock = null;\r\n        String rv = null;\r\n        while ((rv = br.readLine()) != null) {\r\n            inblock = Hex.decode(rv);\r\n            outblock = new byte[cipher.getOutputSize(inblock.length)];\r\n            outL = cipher.processBytes(inblock, 0, inblock.length, outblock, 0);\r\n            if (outL > 0) {\r\n                out.write(outblock, 0, outL);\r\n            }\r\n        }\r\n        try {\r\n            outL = cipher.doFinal(outblock, 0);\r\n            if (outL > 0) {\r\n                out.write(outblock, 0, outL);\r\n            }\r\n        } catch (CryptoException ce) {\r\n        }\r\n    } catch (IOException ioeread) {\r\n        ioeread.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "javax.crypto.KeyAgreement.getInstance",
	"Comment": "generates a keyagreement object for the specified keyagreement algorithm from the specified provider.",
	"Method": "KeyAgreement getInstance(String algorithm,KeyAgreement getInstance,String algorithm,Provider provider,KeyAgreement getInstance,String algorithm,String provider){\r\n    if (provider == null) {\r\n        throw new IllegalArgumentException(\"No provider specified to KeyAgreement.getInstance()\");\r\n    }\r\n    JCEUtil.Implementation imp = JCEUtil.getImplementation(\"KeyAgreement\", algorithm, provider);\r\n    if (imp == null) {\r\n        throw new NoSuchAlgorithmException(algorithm + \" not found\");\r\n    }\r\n    KeyAgreement keyAgree = new KeyAgreement((KeyAgreementSpi) imp.getEngine(), imp.getProvider(), algorithm);\r\n    return keyAgree;\r\n}"
}, {
	"Path": "org.bouncycastle.x509.X509CRLStoreSelector.isDeltaCRLIndicatorEnabled",
	"Comment": "returns if this selector must match crls with the delta crl indicatorextension set. defaults to false.",
	"Method": "boolean isDeltaCRLIndicatorEnabled(){\r\n    return deltaCRLIndicator;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.PolynomialRingGF2m.computeSquareRootMatrix",
	"Comment": "compute the matrix for computing square roots in this polynomial ring byinverting the squaring matrix.",
	"Method": "void computeSquareRootMatrix(){\r\n    int numColumns = p.getDegree();\r\n    PolynomialGF2mSmallM[] tmpMatrix = new PolynomialGF2mSmallM[numColumns];\r\n    for (int i = numColumns - 1; i >= 0; i--) {\r\n        tmpMatrix[i] = new PolynomialGF2mSmallM(sqMatrix[i]);\r\n    }\r\n    sqRootMatrix = new PolynomialGF2mSmallM[numColumns];\r\n    for (int i = numColumns - 1; i >= 0; i--) {\r\n        sqRootMatrix[i] = new PolynomialGF2mSmallM(field, i);\r\n    }\r\n    for (int i = 0; i < numColumns; i++) {\r\n        if (tmpMatrix[i].getCoefficient(i) == 0) {\r\n            boolean foundNonZero = false;\r\n            for (int j = i + 1; j < numColumns; j++) {\r\n                if (tmpMatrix[j].getCoefficient(i) != 0) {\r\n                    foundNonZero = true;\r\n                    swapColumns(tmpMatrix, i, j);\r\n                    swapColumns(sqRootMatrix, i, j);\r\n                    j = numColumns;\r\n                    continue;\r\n                }\r\n            }\r\n            if (!foundNonZero) {\r\n                throw new ArithmeticException(\"Squaring matrix is not invertible.\");\r\n            }\r\n        }\r\n        int coef = tmpMatrix[i].getCoefficient(i);\r\n        int invCoef = field.inverse(coef);\r\n        tmpMatrix[i].multThisWithElement(invCoef);\r\n        sqRootMatrix[i].multThisWithElement(invCoef);\r\n        for (int j = 0; j < numColumns; j++) {\r\n            if (j != i) {\r\n                coef = tmpMatrix[j].getCoefficient(i);\r\n                if (coef != 0) {\r\n                    PolynomialGF2mSmallM tmpSqColumn = tmpMatrix[i].multWithElement(coef);\r\n                    PolynomialGF2mSmallM tmpInvColumn = sqRootMatrix[i].multWithElement(coef);\r\n                    tmpMatrix[j].addToThis(tmpSqColumn);\r\n                    sqRootMatrix[j].addToThis(tmpInvColumn);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPSignatureGenerator.generateCertification",
	"Comment": "generate a certification, such as a revocation, for the passed in key.",
	"Method": "PGPSignature generateCertification(String id,PGPPublicKey pubKey,PGPSignature generateCertification,PGPUserAttributeSubpacketVector userAttributes,PGPPublicKey pubKey,PGPSignature generateCertification,PGPPublicKey masterKey,PGPPublicKey pubKey,PGPSignature generateCertification,PGPPublicKey pubKey){\r\n    if ((sigType == PGPSignature.SUBKEY_REVOCATION || sigType == PGPSignature.SUBKEY_BINDING) && !pubKey.isMasterKey()) {\r\n        throw new IllegalArgumentException(\"certifications involving subkey requires public key of revoking key as well.\");\r\n    }\r\n    updateWithPublicKey(pubKey);\r\n    return this.generate();\r\n}"
}, {
	"Path": "org.bouncycastle.mail.smime.examples.ExampleUtils.dumpContent",
	"Comment": "dump the content of the passed in bodypart to the file filename.",
	"Method": "void dumpContent(MimeBodyPart bodyPart,String fileName){\r\n    System.out.println(\"content type: \" + bodyPart.getContentType());\r\n    OutputStream out = new FileOutputStream(fileName);\r\n    InputStream in = bodyPart.getInputStream();\r\n    byte[] buf = new byte[10000];\r\n    int len;\r\n    while ((len = in.read(buf, 0, buf.length)) > 0) {\r\n        out.write(buf, 0, len);\r\n    }\r\n    out.close();\r\n}"
}, {
	"Path": "org.bouncycastle.cms.DefaultCMSSignatureAlgorithmNameGenerator.setSigningEncryptionAlgorithmMapping",
	"Comment": "set the mapping for the encryption algorithm used in association with a signeddata generationor interpretation.",
	"Method": "void setSigningEncryptionAlgorithmMapping(ASN1ObjectIdentifier oid,String algorithmName){\r\n    encryptionAlgs.put(oid, algorithmName);\r\n}"
}, {
	"Path": "java.security.cert.X509CRLSelector.getMinCRL",
	"Comment": "returns the mincrlnumber criterion. the x509crl must havea crl number extension whose value is greater than or equal to thespecified value. if null, no mincrlnumber check will bedone.",
	"Method": "BigInteger getMinCRL(){\r\n    return minCRL;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.test.NTRUEncryptTest.testInvalidEncoding",
	"Comment": "tests that altering the public keyencryption causes the decrypted message to be rejected",
	"Method": "void testInvalidEncoding(NTRUEngine ntru,AsymmetricCipherKeyPair kp,NTRUEncryptionKeyGenerationParameters params){\r\n    try {\r\n        byte[] plainText = \"secret encrypted text\".getBytes();\r\n        ntru.init(true, kp.getPublic());\r\n        byte[] encrypted = ntru.processBlock(plainText, 0, plainText.length);\r\n        NTRUEncryptionPrivateKeyParameters orig = (NTRUEncryptionPrivateKeyParameters) kp.getPrivate();\r\n        IntegerPolynomial h = (IntegerPolynomial) ((NTRUEncryptionPublicKeyParameters) kp.getPublic()).h.clone();\r\n        h.coeffs[0] = (h.coeffs[0] + 111) % params.q;\r\n        NTRUEncryptionPrivateKeyParameters privKey = new NTRUEncryptionPrivateKeyParameters(h, orig.t, orig.fp, params.getEncryptionParameters());\r\n        ntru.init(false, privKey);\r\n        ntru.processBlock(encrypted, 0, encrypted.length);\r\n        fail(\"An exception should have been thrown!\");\r\n    } catch (InvalidCipherTextException ex) {\r\n        assertEquals(\"Invalid message encoding\", ex.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.cryptopro.ECGOST3410NamedCurves.getNames",
	"Comment": "returns an enumeration containing the name strings for parameterscontained in this structure.",
	"Method": "Enumeration getNames(){\r\n    return names.elements();\r\n}"
}, {
	"Path": "org.bouncycastle.cmc.SimplePKIResponse.getCertificates",
	"Comment": "return any x.509 certificate objects in this simplepkiresponse structure as a store of x509certificateholder objects.",
	"Method": "Store<X509CertificateHolder> getCertificates(){\r\n    return certificateResponse.getCertificates();\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.gmss.GMSSLeaf.getStatByte",
	"Comment": "returns the status byte array used by the gmssprivatekeyasn.1 class",
	"Method": "byte[][] getStatByte(){\r\n    byte[][] statByte = new byte[4][];\r\n    statByte[0] = privateKeyOTS;\r\n    statByte[1] = seed;\r\n    statByte[2] = concHashs;\r\n    statByte[3] = leaf;\r\n    return statByte;\r\n}"
}, {
	"Path": "org.bouncycastle.x509.X509V2CRLGenerator.generateX509CRL",
	"Comment": "generate an x509 crl, based on the current issuer and subject,using the passed in provider for the signing.",
	"Method": "X509CRL generateX509CRL(PrivateKey key,X509CRL generateX509CRL,PrivateKey key,SecureRandom random,X509CRL generateX509CRL,PrivateKey key,String provider,X509CRL generateX509CRL,PrivateKey key,String provider,SecureRandom random){\r\n    try {\r\n        return generate(key, provider, random);\r\n    } catch (NoSuchProviderException e) {\r\n        throw e;\r\n    } catch (SignatureException e) {\r\n        throw e;\r\n    } catch (InvalidKeyException e) {\r\n        throw e;\r\n    } catch (GeneralSecurityException e) {\r\n        throw new SecurityException(\"exception: \" + e);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.cert.ocsp.CertificateID.deriveCertificateID",
	"Comment": "create a new certificateid for a new serial number derived from a previous onecalculated for the same ca certificate.",
	"Method": "CertificateID deriveCertificateID(CertificateID original,BigInteger newSerialNumber){\r\n    return new CertificateID(new CertID(original.id.getHashAlgorithm(), original.id.getIssuerNameHash(), original.id.getIssuerKeyHash(), new ASN1Integer(newSerialNumber)));\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.ch1_titlepane.BETitlePane.updateToggleButton",
	"Comment": "updates the toggle button to contain the icon icon, and\taction action.",
	"Method": "void updateToggleButton(Action action,Icon icon,Icon iconRover,Icon iconPressed){\r\n    toggleButton.setAction(action);\r\n    toggleButton.setIcon(icon);\r\n    toggleButton.setRolloverIcon(iconRover);\r\n    toggleButton.setPressedIcon(iconPressed);\r\n    toggleButton.setText(null);\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2nONBElement.clone",
	"Comment": "create a new gf2nonbelement by cloning this gf2npolynomialelement.",
	"Method": "Object clone(){\r\n    return new GF2nONBElement(this);\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSConfig.setSigningEncryptionAlgorithmMapping",
	"Comment": "set the mapping for the encryption algorithm used in association with a signeddata generationor interpretation.",
	"Method": "void setSigningEncryptionAlgorithmMapping(String oid,String algorithmName){\r\n    ASN1ObjectIdentifier id = new ASN1ObjectIdentifier(oid);\r\n    CMSSignedHelper.INSTANCE.setSigningEncryptionAlgorithmMapping(id, algorithmName);\r\n}"
}, {
	"Path": "org.bouncycastle.cert.dane.DANEEntryFactory.createEntry",
	"Comment": "return a daneentry for the passed in email address and certificate.",
	"Method": "DANEEntry createEntry(String emailAddress,X509CertificateHolder certificate,DANEEntry createEntry,String emailAddress,int certUsage,X509CertificateHolder certificate){\r\n    if (certUsage < 0 || certUsage > 3) {\r\n        throw new DANEException(\"unknown certificate usage: \" + certUsage);\r\n    }\r\n    DANEEntrySelector entrySelector = selectorFactory.createSelector(emailAddress);\r\n    byte[] flags = new byte[3];\r\n    flags[DANEEntry.CERT_USAGE] = (byte) certUsage;\r\n    flags[DANEEntry.SELECTOR] = 0;\r\n    flags[DANEEntry.MATCHING_TYPE] = 0;\r\n    return new DANEEntry(entrySelector.getDomainName(), flags, certificate);\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPPublicKey.getTrustData",
	"Comment": "return the trust data associated with the public key, if present.",
	"Method": "byte[] getTrustData(){\r\n    if (trustPk == null) {\r\n        return null;\r\n    }\r\n    return Arrays.clone(trustPk.getLevelAndTrustAmount());\r\n}"
}, {
	"Path": "java.security.cert.PolicyQualifierInfo.getPolicyQualifier",
	"Comment": "returns the asn.1 der encoded form of the qualifier fieldof this policyqualifierinfo.",
	"Method": "byte[] getPolicyQualifier(){\r\n    if (qualifier == null) {\r\n        return null;\r\n    }\r\n    return (byte[]) qualifier.clone();\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.CertPathValidatorException.getCertPath",
	"Comment": "returns the certification path that was being validated when theexception was thrown.",
	"Method": "CertPath getCertPath(){\r\n    return certPath;\r\n}"
}, {
	"Path": "org.bouncycastle.cms.OriginatorInformation.getCRLs",
	"Comment": "return the crls stored in the underlying originatorinfo object.",
	"Method": "Store getCRLs(){\r\n    ASN1Set crlSet = originatorInfo.getCRLs();\r\n    if (crlSet != null) {\r\n        List crlList = new ArrayList(crlSet.size());\r\n        for (Enumeration en = crlSet.getObjects(); en.hasMoreElements(); ) {\r\n            ASN1Primitive obj = ((ASN1Encodable) en.nextElement()).toASN1Primitive();\r\n            if (obj instanceof ASN1Sequence) {\r\n                crlList.add(new X509CRLHolder(CertificateList.getInstance(obj)));\r\n            }\r\n        }\r\n        return new CollectionStore(crlList);\r\n    }\r\n    return new CollectionStore(new ArrayList());\r\n}"
}, {
	"Path": "com.sun.swingset3.codeview.SnippetHighlighter.addHighlight",
	"Comment": "adds a highlight to the view.returns a tag that can be used to refer to the highlight.",
	"Method": "Object addHighlight(int p0,int p1,Highlighter.HighlightPainter p){\r\n    Document doc = component.getDocument();\r\n    HighlightInfo i = (getDrawsLayeredHighlights() && (p instanceof LayeredHighlighter.LayerPainter)) ? new LayeredHighlightInfo() : new HighlightInfo();\r\n    i.painter = p;\r\n    i.p0 = doc.createPosition(p0);\r\n    i.p1 = doc.createPosition(p1);\r\n    highlights.insertElementAt(i, 0);\r\n    safeDamageRange(p0, p1);\r\n    return i;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.engines.ElGamalEngine.getOutputBlockSize",
	"Comment": "return the maximum size for an output block to this engine.for elgamal this is always one byte less than the size of p ondecryption, and twice the length as the size of p on encryption.",
	"Method": "int getOutputBlockSize(){\r\n    if (forEncryption) {\r\n        return 2 * ((bitSize + 7) / 8);\r\n    }\r\n    return (bitSize - 1) / 8;\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.ch1_titlepane.BERootPaneUI.installUI",
	"Comment": "invokes supers implementation of installui to install\tthe necessary state onto the passed in jrootpane\tto render the metal look and feel implementation of\trootpaneui. if\tthe windowdecorationstyle property of the\tjrootpane is other than jrootpane.none,\tthis will add a custom component to render the widgets to\tjrootpane, as well as installing a custom\tborder and layoutmanager on the\tjrootpane.",
	"Method": "void installUI(JComponent c){\r\n    super.installUI(c);\r\n    root = (JRootPane) c;\r\n    int style = root.getWindowDecorationStyle();\r\n    if (style != JRootPane.NONE) {\r\n        installClientDecorations(root);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.gmss.GMSSRootCalc.wasFinished",
	"Comment": "method to check whether the instance has been finished or not",
	"Method": "boolean wasFinished(){\r\n    return isFinished;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.engines.RSACoreEngine.getOutputBlockSize",
	"Comment": "return the maximum size for an output block to this engine.for rsa this is always one byte less than the key size ondecryption, and the same length as the key size on encryption.",
	"Method": "int getOutputBlockSize(){\r\n    int bitSize = key.getModulus().bitLength();\r\n    if (forEncryption) {\r\n        return (bitSize + 7) / 8;\r\n    } else {\r\n        return (bitSize + 7) / 8 - 1;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2Vector.getHammingWeight",
	"Comment": "return the hamming weight of this vector, i.e., compute the number ofunits of this vector.",
	"Method": "int getHammingWeight(){\r\n    int weight = 0;\r\n    for (int i = 0; i < v.length; i++) {\r\n        int e = v[i];\r\n        for (int j = 0; j < 32; j++) {\r\n            int b = e & 1;\r\n            if (b != 0) {\r\n                weight++;\r\n            }\r\n            e >>>= 1;\r\n        }\r\n    }\r\n    return weight;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM.modSquareRoot",
	"Comment": "compute the square root of this polynomial modulo the given polynomial.",
	"Method": "PolynomialGF2mSmallM modSquareRoot(PolynomialGF2mSmallM a){\r\n    int[] resultCoeff = IntUtils.clone(coefficients);\r\n    int[] help = modMultiply(resultCoeff, resultCoeff, a.coefficients);\r\n    while (!isEqual(help, coefficients)) {\r\n        resultCoeff = normalForm(help);\r\n        help = modMultiply(resultCoeff, resultCoeff, a.coefficients);\r\n    }\r\n    return new PolynomialGF2mSmallM(field, resultCoeff);\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.jcajce.provider.test.QTESLASecureRandomFactory.getFixed",
	"Comment": "return a seeded fixedsecurerandom representing the result of processing aqtesla test seed with the qtesla randomnumbergenerator.",
	"Method": "FixedSecureRandom getFixed(byte[] seed,int strength,FixedSecureRandom getFixed,byte[] seed,byte[] personalization,int strength,int discard,int size){\r\n    QTESLASecureRandomFactory teslaRNG = new QTESLASecureRandomFactory(seed, personalization);\r\n    teslaRNG.init(strength);\r\n    byte[] burn = new byte[discard];\r\n    teslaRNG.nextBytes(burn);\r\n    if (discard != size) {\r\n        burn = new byte[size];\r\n    }\r\n    teslaRNG.nextBytes(burn);\r\n    return new FixedSecureRandom(burn);\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.rainbow.RainbowPrivateKeyParameters.getB2",
	"Comment": "getter for the translation part of the private quadratic map l2.",
	"Method": "short[] getB2(){\r\n    return this.b2;\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPPublicKeyRingCollection.addPublicKeyRing",
	"Comment": "return a new collection object containing the contents of the passed in collection andthe passed in public key ring.",
	"Method": "PGPPublicKeyRingCollection addPublicKeyRing(PGPPublicKeyRingCollection ringCollection,PGPPublicKeyRing publicKeyRing){\r\n    Long key = new Long(publicKeyRing.getPublicKey().getKeyID());\r\n    if (ringCollection.pubRings.containsKey(key)) {\r\n        throw new IllegalArgumentException(\"Collection already contains a key with a keyID for the passed in ring.\");\r\n    }\r\n    Map newPubRings = new HashMap(ringCollection.pubRings);\r\n    List newOrder = new ArrayList(ringCollection.order);\r\n    newPubRings.put(key, publicKeyRing);\r\n    newOrder.add(key);\r\n    return new PGPPublicKeyRingCollection(newPubRings, newOrder);\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.rainbow.RainbowPrivateKeyParameters.getB1",
	"Comment": "getter for the translation part of the private quadratic map l1.",
	"Method": "short[] getB1(){\r\n    return this.b1;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.rainbow.RainbowSigner.initSign",
	"Comment": "initial operations before solving the linear equation system.",
	"Method": "short[] initSign(Layer[] layer,short[] msg){\r\n    short[] tmpVec = new short[msg.length];\r\n    tmpVec = cf.addVect(((RainbowPrivateKeyParameters) this.key).getB1(), msg);\r\n    short[] Y_ = cf.multiplyMatrix(((RainbowPrivateKeyParameters) this.key).getInvA1(), tmpVec);\r\n    for (int i = 0; i < layer[0].getVi(); i++) {\r\n        x[i] = (short) random.nextInt();\r\n        x[i] = (short) (x[i] & GF2Field.MASK);\r\n    }\r\n    return Y_;\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPCompressedData.getInputStream",
	"Comment": "return the raw input stream contained in the object.note that this stream is shared with the decompression stream, so consuming the returnedstream will affect decompression.",
	"Method": "InputStream getInputStream(){\r\n    return data.getInputStream();\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.provider.asymmetric.gost.BCGOST3410PrivateKey.getEncoded",
	"Comment": "return a pkcs8 representation of the key. the sequence returnedrepresents a full privatekeyinfo object.",
	"Method": "byte[] getEncoded(){\r\n    PrivateKeyInfo info;\r\n    byte[] keyEnc = this.getX().toByteArray();\r\n    byte[] keyBytes;\r\n    if (keyEnc[0] == 0) {\r\n        keyBytes = new byte[keyEnc.length - 1];\r\n    } else {\r\n        keyBytes = new byte[keyEnc.length];\r\n    }\r\n    for (int i = 0; i != keyBytes.length; i++) {\r\n        keyBytes[i] = keyEnc[keyEnc.length - 1 - i];\r\n    }\r\n    try {\r\n        if (gost3410Spec instanceof GOST3410ParameterSpec) {\r\n            info = new PrivateKeyInfo(new AlgorithmIdentifier(CryptoProObjectIdentifiers.gostR3410_94, new GOST3410PublicKeyAlgParameters(new ASN1ObjectIdentifier(gost3410Spec.getPublicKeyParamSetOID()), new ASN1ObjectIdentifier(gost3410Spec.getDigestParamSetOID()))), new DEROctetString(keyBytes));\r\n        } else {\r\n            info = new PrivateKeyInfo(new AlgorithmIdentifier(CryptoProObjectIdentifiers.gostR3410_94), new DEROctetString(keyBytes));\r\n        }\r\n        return info.getEncoded(ASN1Encoding.DER);\r\n    } catch (IOException e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.ntru.util.Util.is64BitJVM",
	"Comment": "takes an educated guess as to whether 64 bits are supported by the jvm.",
	"Method": "boolean is64BitJVM(){\r\n    if (!IS_64_BITNESS_KNOWN) {\r\n        String arch = System.getProperty(\"os.arch\");\r\n        String sunModel = System.getProperty(\"sun.arch.data.model\");\r\n        IS_64_BIT_JVM = \"amd64\".equals(arch) || \"x86_64\".equals(arch) || \"ppc64\".equals(arch) || \"64\".equals(sunModel);\r\n        IS_64_BITNESS_KNOWN = true;\r\n    }\r\n    return IS_64_BIT_JVM;\r\n}"
}, {
	"Path": "org.bouncycastle.bcpg.sig.SignatureExpirationTime.getTime",
	"Comment": "return time in seconds before signature expires after creation time.",
	"Method": "long getTime(){\r\n    long time = ((long) (data[0] & 0xff) << 24) | ((data[1] & 0xff) << 16) | ((data[2] & 0xff) << 8) | (data[3] & 0xff);\r\n    return time;\r\n}"
}, {
	"Path": "com.sun.swingset3.codeview.CodeStyler.keywordFilter",
	"Comment": "filters keywords from a line of text and formats them properly.",
	"Method": "String keywordFilter(String line){\r\n    if (line == null || line.equals(\"\")) {\r\n        return \"\";\r\n    }\r\n    StringBuffer buf = new StringBuffer();\r\n    Map<String, String> usedReservedWords = new HashMap<String, String>();\r\n    int i = 0;\r\n    char ch;\r\n    StringBuffer temp = new StringBuffer();\r\n    while (i < line.length()) {\r\n        temp.setLength(0);\r\n        ch = line.charAt(i);\r\n        while (i < line.length() && ((ch >= 65 && ch <= 90) || (ch >= 97 && ch <= 122))) {\r\n            temp.append(ch);\r\n            i++;\r\n            if (i < line.length()) {\r\n                ch = line.charAt(i);\r\n            }\r\n        }\r\n        String tempString = temp.toString();\r\n        if (RESERVED_WORDS.containsKey(tempString) && !usedReservedWords.containsKey(tempString)) {\r\n            usedReservedWords.put(tempString, tempString);\r\n            line = replace(line, tempString, (reservedWordStart + tempString + reservedWordEnd));\r\n            i += (reservedWordStart.length() + reservedWordEnd.length());\r\n        } else {\r\n            i++;\r\n        }\r\n    }\r\n    buf.append(line);\r\n    return buf.toString();\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2mField.equals",
	"Comment": "checks if given object is equal to this field.the method returns false whenever the given object is not gf2m.",
	"Method": "boolean equals(Object other){\r\n    if ((other == null) || !(other instanceof GF2mField)) {\r\n        return false;\r\n    }\r\n    GF2mField otherField = (GF2mField) other;\r\n    if ((degree == otherField.degree) && (polynomial == otherField.polynomial)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.PolynomialRingGF2.modMultiply",
	"Comment": "compute the product of two polynomials modulo a third polynomial.",
	"Method": "int modMultiply(int a,int b,int r){\r\n    int result = 0;\r\n    int p = remainder(a, r);\r\n    int q = remainder(b, r);\r\n    if (q != 0) {\r\n        int d = 1 << degree(r);\r\n        while (p != 0) {\r\n            byte pMod2 = (byte) (p & 0x01);\r\n            if (pMod2 == 1) {\r\n                result ^= q;\r\n            }\r\n            p >>>= 1;\r\n            q <<= 1;\r\n            if (q >= d) {\r\n                q ^= r;\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.ch1_titlepane.BERootPaneUI.uninstallUI",
	"Comment": "invokes supers implementation to uninstall any of its state. this will\talso reset the layoutmanager of the jrootpane.\tif a component has been added to the jrootpane\tto render the window decoration style, this method will remove it.\tsimilarly, this will revert the border and layoutmanager of the\tjrootpane to what it was before installui\twas invoked.",
	"Method": "void uninstallUI(JComponent c){\r\n    super.uninstallUI(c);\r\n    uninstallClientDecorations(root);\r\n    layoutManager = null;\r\n    mouseInputListener = null;\r\n    root = null;\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.getKeyUsage",
	"Comment": "returns the keyusage criterion. the x509certificate mustallow the specified keyusage values. if null, no keyusage check will bedone.note that the boolean array returned is cloned to protect againstsubsequent modifications.",
	"Method": "boolean[] getKeyUsage(){\r\n    if (keyUsage != null) {\r\n        return (boolean[]) keyUsage.clone();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.est.jcajce.JcaHttpAuthBuilder.build",
	"Comment": "return a httpauth implementing digest auth for the user, password, and realm combination.",
	"Method": "HttpAuth build(){\r\n    return new HttpAuth(realm, username, password, random, providerBuilder.build());\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.PKCS12StoreParameter.isForDEREncoding",
	"Comment": "return whether the keystore used with this parameter should be der encoded on saving.",
	"Method": "boolean isForDEREncoding(){\r\n    return forDEREncoding;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.x509.ExtensionsGenerator.isEmpty",
	"Comment": "return true if there are no extension present in this generator.",
	"Method": "boolean isEmpty(){\r\n    return extOrdering.isEmpty();\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.ch1_titlepane.BERootPaneUI.createLayoutManager",
	"Comment": "returns a layoutmanager that will be set on the\tjrootpane.",
	"Method": "LayoutManager createLayoutManager(){\r\n    return new XMetalRootLayout();\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2Polynomial.gcd",
	"Comment": "returns the greatest common divisor of this and g in anew gf2polynomial.",
	"Method": "GF2Polynomial gcd(GF2Polynomial g){\r\n    if (isZero() && g.isZero()) {\r\n        throw new ArithmeticException(\"Both operands of gcd equal zero.\");\r\n    }\r\n    if (isZero()) {\r\n        return new GF2Polynomial(g);\r\n    }\r\n    if (g.isZero()) {\r\n        return new GF2Polynomial(this);\r\n    }\r\n    GF2Polynomial a = new GF2Polynomial(this);\r\n    GF2Polynomial b = new GF2Polynomial(g);\r\n    GF2Polynomial c;\r\n    while (!b.isZero()) {\r\n        c = a.remainder(b);\r\n        a = b;\r\n        b = c;\r\n    }\r\n    return a;\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPSignature.hasSubpackets",
	"Comment": "return true if the signature has either hashed or unhashed subpackets.",
	"Method": "boolean hasSubpackets(){\r\n    return sigPck.getHashedSubPackets() != null || sigPck.getUnhashedSubPackets() != null;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.engines.CAST5Engine.F1",
	"Comment": "the first of the three processing functions for theencryption and decryption.",
	"Method": "int F1(int D,int Kmi,int Kri){\r\n    int I = Kmi + D;\r\n    I = I << Kri | I >>> (32 - Kri);\r\n    return ((S1[(I >>> 24) & 0xff] ^ S2[(I >>> 16) & 0xff]) - S3[(I >>> 8) & 0xff]) + S4[I & 0xff];\r\n}"
}, {
	"Path": "org.bouncycastle.dvcs.DVCSRequest.getContent",
	"Comment": "return the asn.1 dvcsrequest structure making up the body of this request.",
	"Method": "ASN1Encodable getContent(){\r\n    return asn1;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.gmss.GMSSPrivateKeyParameters.getMinTreehashIndex",
	"Comment": "this method returns the index of the next treehash instance that shouldreceive an update",
	"Method": "int getMinTreehashIndex(int layer){\r\n    int minTreehash = -1;\r\n    for (int h = 0; h < heightOfTrees[layer] - K[layer]; h++) {\r\n        if (currentTreehash[layer][h].wasInitialized() && !currentTreehash[layer][h].wasFinished()) {\r\n            if (minTreehash == -1) {\r\n                minTreehash = h;\r\n            } else if (currentTreehash[layer][h].getLowestNodeHeight() < currentTreehash[layer][minTreehash].getLowestNodeHeight()) {\r\n                minTreehash = h;\r\n            }\r\n        }\r\n    }\r\n    return minTreehash;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.engines.CAST5Engine.F2",
	"Comment": "the second of the three processing functions for theencryption and decryption.",
	"Method": "int F2(int D,int Kmi,int Kri){\r\n    int I = Kmi ^ D;\r\n    I = I << Kri | I >>> (32 - Kri);\r\n    return ((S1[(I >>> 24) & 0xff] - S2[(I >>> 16) & 0xff]) + S3[(I >>> 8) & 0xff]) ^ S4[I & 0xff];\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.engines.CAST5Engine.F3",
	"Comment": "the third of the three processing functions for theencryption and decryption.",
	"Method": "int F3(int D,int Kmi,int Kri){\r\n    int I = Kmi - D;\r\n    I = I << Kri | I >>> (32 - Kri);\r\n    return ((S1[(I >>> 24) & 0xff] + S2[(I >>> 16) & 0xff]) ^ S3[(I >>> 8) & 0xff]) - S4[I & 0xff];\r\n}"
}, {
	"Path": "org.bouncycastle.jce.provider.PKIXNameConstraintValidator.unionIP",
	"Comment": "returns the union of the excluded ip ranges in excludedwith ip.",
	"Method": "Set unionIP(Set excluded,byte[] ip){\r\n    if (excluded.isEmpty()) {\r\n        if (ip == null) {\r\n            return excluded;\r\n        }\r\n        excluded.add(ip);\r\n        return excluded;\r\n    } else {\r\n        Set union = new HashSet();\r\n        Iterator it = excluded.iterator();\r\n        while (it.hasNext()) {\r\n            byte[] _excluded = (byte[]) it.next();\r\n            union.addAll(unionIPRange(_excluded, ip));\r\n        }\r\n        return union;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.x509.X509CRLStoreSelector.isIssuingDistributionPointEnabled",
	"Comment": "returns if the issuing distribution point criteria should be applied.defaults to false.you may also set the issuing distribution point criteria if not a missingissuing distribution point should be assumed.",
	"Method": "boolean isIssuingDistributionPointEnabled(){\r\n    return issuingDistributionPointEnabled;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.ntru.euclid.BigIntEuclidean.calculate",
	"Comment": "runs the eea on two bigintegersimplemented from pseudocode on wikipedia.",
	"Method": "BigIntEuclidean calculate(BigInteger a,BigInteger b){\r\n    BigInteger x = BigInteger.ZERO;\r\n    BigInteger lastx = BigInteger.ONE;\r\n    BigInteger y = BigInteger.ONE;\r\n    BigInteger lasty = BigInteger.ZERO;\r\n    while (!b.equals(BigInteger.ZERO)) {\r\n        BigInteger[] quotientAndRemainder = a.divideAndRemainder(b);\r\n        BigInteger quotient = quotientAndRemainder[0];\r\n        BigInteger temp = a;\r\n        a = b;\r\n        b = quotientAndRemainder[1];\r\n        temp = x;\r\n        x = lastx.subtract(quotient.multiply(x));\r\n        lastx = temp;\r\n        temp = y;\r\n        y = lasty.subtract(quotient.multiply(y));\r\n        lasty = temp;\r\n    }\r\n    BigIntEuclidean result = new BigIntEuclidean();\r\n    result.x = lastx;\r\n    result.y = lasty;\r\n    result.gcd = a;\r\n    return result;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.BERTaggedObjectParser.getObjectParser",
	"Comment": "return an object parser for the contents of this tagged object.",
	"Method": "ASN1Encodable getObjectParser(int tag,boolean isExplicit){\r\n    if (isExplicit) {\r\n        if (!_constructed) {\r\n            throw new IOException(\"Explicit tags must be constructed (see X.690 8.14.2)\");\r\n        }\r\n        return _parser.readObject();\r\n    }\r\n    return _parser.readImplicit(_constructed, tag);\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSSignedDataParser.getAttributeCertificates",
	"Comment": "return any x.509 attribute certificate objects in this signeddata structure as a store of x509attributecertificateholder objects.",
	"Method": "Store getAttributeCertificates(){\r\n    populateCertCrlSets();\r\n    return HELPER.getAttributeCertificates(_certSet);\r\n}"
}, {
	"Path": "org.bouncycastle.cms.SignerInformationStore.getSigners",
	"Comment": "return possible empty collection with signers matching the passed in signerid",
	"Method": "Collection<SignerInformation> getSigners(Collection<SignerInformation> getSigners,SignerId selector){\r\n    if (selector.getIssuer() != null && selector.getSubjectKeyIdentifier() != null) {\r\n        List results = new ArrayList();\r\n        Collection match1 = getSigners(new SignerId(selector.getIssuer(), selector.getSerialNumber()));\r\n        if (match1 != null) {\r\n            results.addAll(match1);\r\n        }\r\n        Collection match2 = getSigners(new SignerId(selector.getSubjectKeyIdentifier()));\r\n        if (match2 != null) {\r\n            results.addAll(match2);\r\n        }\r\n        return results;\r\n    } else {\r\n        List list = (ArrayList) table.get(selector);\r\n        return list == null ? new ArrayList() : new ArrayList(list);\r\n    }\r\n}"
}, {
	"Path": "com.sun.swingset3.codeview.CodeStyler.replace",
	"Comment": "all important replace method. replaces all occurences of oldstring inline with newstring.",
	"Method": "String replace(String line,String oldString,String newString){\r\n    int i = 0;\r\n    while ((i = line.indexOf(oldString, i)) >= 0) {\r\n        line = (new StringBuffer().append(line.substring(0, i)).append(newString).append(line.substring(i + oldString.length()))).toString();\r\n        i += newString.length();\r\n    }\r\n    return line;\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSConfig.setSigningDigestAlgorithmMapping",
	"Comment": "set the mapping for the digest algorithm to use in conjunction with a signeddata generationor interpretation.",
	"Method": "void setSigningDigestAlgorithmMapping(String oid,String algorithmName){\r\n    ASN1ObjectIdentifier id = new ASN1ObjectIdentifier(oid);\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.PKCS12Key.getAlgorithm",
	"Comment": "return the password based key derivation function this key is for,",
	"Method": "String getAlgorithm(){\r\n    return \"PKCS12\";\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.commitments.GeneralHashCommitter.isRevealed",
	"Comment": "return true if the passed in commitment represents a commitment to the passed in message.",
	"Method": "boolean isRevealed(Commitment commitment,byte[] message){\r\n    if (message.length + commitment.getSecret().length != byteLength) {\r\n        throw new DataLengthException(\"Message and witness secret lengths do not match.\");\r\n    }\r\n    byte[] calcCommitment = calculateCommitment(commitment.getSecret(), message);\r\n    return Arrays.constantTimeAreEqual(commitment.getCommitment(), calcCommitment);\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.PBKDF2KeyWithParameters.getIterationCount",
	"Comment": "return the iteration count to use in the key derivation function.",
	"Method": "int getIterationCount(){\r\n    return iterationCount;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.X509CertSelector.getSubjectPublicKey",
	"Comment": "returns the subjectpublickey criterion. the x509certificatemust contain the specified subject public key. if null,no subjectpublickey check will be done.",
	"Method": "PublicKey getSubjectPublicKey(){\r\n    return subjectPublicKey;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.CryptoServicesRegistrar.setThreadProperty",
	"Comment": "set the value of the the passed in property on the current thread only. more thanone value can be passed in for a sized property. if more than one value is provided thefirst value in the argument list becomes the default value.",
	"Method": "void setThreadProperty(Property property,T propertyValue){\r\n    checkPermission(CanSetThreadProperty);\r\n    if (!property.type.isAssignableFrom(propertyValue[0].getClass())) {\r\n        throw new IllegalArgumentException(\"Bad property value passed\");\r\n    }\r\n    Object[] rv = new Object[propertyValue.length];\r\n    System.arraycopy(propertyValue, 0, rv, 0, rv.length);\r\n    localSetThread(property, rv);\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPPublicKeyRingCollection.getPublicKey",
	"Comment": "return the pgp public key associated with the given key fingerprint.",
	"Method": "PGPPublicKey getPublicKey(long keyID,PGPPublicKey getPublicKey,byte[] fingerprint){\r\n    Iterator it = this.getKeyRings();\r\n    while (it.hasNext()) {\r\n        PGPPublicKeyRing pubRing = (PGPPublicKeyRing) it.next();\r\n        PGPPublicKey pub = pubRing.getPublicKey(fingerprint);\r\n        if (pub != null) {\r\n            return pub;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.X509CRLSelector.setMaxCRLNumber",
	"Comment": "sets the maxcrlnumber criterion. the x509crl must have acrl number extension whose value is less than or equal to the specifiedvalue. if null, no maxcrlnumber check will be done.",
	"Method": "void setMaxCRLNumber(BigInteger maxCRL){\r\n    this.maxCRL = maxCRL;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.x509.Holder.getVersion",
	"Comment": "returns 1 for v2 attribute certificates or 0 for v1 attributecertificates.",
	"Method": "int getVersion(){\r\n    return version;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2Matrix.getEncoded",
	"Comment": "returns encoded matrix, i.e., this matrix in byte array form",
	"Method": "byte[] getEncoded(){\r\n    int n = (numColumns + 7) >>> 3;\r\n    n *= numRows;\r\n    n += 8;\r\n    byte[] enc = new byte[n];\r\n    LittleEndianConversions.I2OSP(numRows, enc, 0);\r\n    LittleEndianConversions.I2OSP(numColumns, enc, 4);\r\n    int q = numColumns >>> 5;\r\n    int r = numColumns & 0x1f;\r\n    int count = 8;\r\n    for (int i = 0; i < numRows; i++) {\r\n        for (int j = 0; j < q; j++, count += 4) {\r\n            LittleEndianConversions.I2OSP(matrix[i][j], enc, count);\r\n        }\r\n        for (int j = 0; j < r; j += 8) {\r\n            enc[count++] = (byte) ((matrix[i][q] >>> j) & 0xff);\r\n        }\r\n    }\r\n    return enc;\r\n}"
}, {
	"Path": "org.bouncycastle.est.test.TestHostNameAuthorizer.testCNMatch",
	"Comment": "the following tests do not attempt to validate the certificates.they only test hostname verification behavior.",
	"Method": "void testCNMatch(){\r\n    X509Certificate cert = readPemCertificate(\"san/cert_cn_match_wc.pem\");\r\n    assertTrue(\"Common Name match\", new JsseDefaultHostnameAuthorizer(null).verify(\"aardvark.cisco.com\", cert));\r\n    assertFalse(\"Not match\", new JsseDefaultHostnameAuthorizer(null).verify(\"cisco.com\", cert));\r\n}"
}, {
	"Path": "org.bouncycastle.cert.X509v2CRLBuilder.build",
	"Comment": "generate an x.509 crl, based on the current issuer and subjectusing the passed in signer.",
	"Method": "X509CRLHolder build(ContentSigner signer){\r\n    tbsGen.setSignature(signer.getAlgorithmIdentifier());\r\n    if (!extGenerator.isEmpty()) {\r\n        tbsGen.setExtensions(extGenerator.generate());\r\n    }\r\n    return CertUtils.generateFullCRL(signer, tbsGen.generateTBSCertList());\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.provider.asymmetric.ies.AlgorithmParametersSpi.engineGetEncoded",
	"Comment": "in the absence of a standard way of doing it this will do fornow...",
	"Method": "byte[] engineGetEncoded(byte[] engineGetEncoded,String format){\r\n    if (isASN1FormatString(format) || format.equalsIgnoreCase(\"X.509\")) {\r\n        return engineGetEncoded();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.params.HKDFParameters.skipExtractParameters",
	"Comment": "factory method that makes the hkdf skip the extract part of the keyderivation function.",
	"Method": "HKDFParameters skipExtractParameters(byte[] ikm,byte[] info){\r\n    return new HKDFParameters(ikm, true, null, info);\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.PKIXExtendedBuilderParameters.getExcludedCerts",
	"Comment": "excluded certificates are not used for building a certification path.the returned set is immutable.",
	"Method": "Set getExcludedCerts(){\r\n    return excludedCerts;\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPSecretKeyRingCollection.getKeyRings",
	"Comment": "return an iterator of the key rings associated with the passed in userid.",
	"Method": "Iterator<PGPSecretKeyRing> getKeyRings(Iterator<PGPSecretKeyRing> getKeyRings,String userID,Iterator<PGPSecretKeyRing> getKeyRings,String userID,boolean matchPartial,Iterator<PGPSecretKeyRing> getKeyRings,String userID,boolean matchPartial,boolean ignoreCase){\r\n    Iterator it = this.getKeyRings();\r\n    List rings = new ArrayList();\r\n    if (ignoreCase) {\r\n        userID = Strings.toLowerCase(userID);\r\n    }\r\n    while (it.hasNext()) {\r\n        PGPSecretKeyRing secRing = (PGPSecretKeyRing) it.next();\r\n        Iterator uIt = secRing.getSecretKey().getUserIDs();\r\n        while (uIt.hasNext()) {\r\n            String next = (String) uIt.next();\r\n            if (ignoreCase) {\r\n                next = Strings.toLowerCase(next);\r\n            }\r\n            if (matchPartial) {\r\n                if (next.indexOf(userID) > -1) {\r\n                    rings.add(secRing);\r\n                }\r\n            } else {\r\n                if (next.equals(userID)) {\r\n                    rings.add(secRing);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return rings.iterator();\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.x509.DistributionPointName.getName",
	"Comment": "return the tagged object inside the distribution point name.",
	"Method": "ASN1Encodable getName(){\r\n    return (ASN1Encodable) name;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM.multiply",
	"Comment": "compute the product of this polynomial and the given factor using akaratzuba like scheme.",
	"Method": "PolynomialGF2mSmallM multiply(PolynomialGF2mSmallM factor,int[] multiply,int[] a,int[] b){\r\n    int[] mult1, mult2;\r\n    if (computeDegree(a) < computeDegree(b)) {\r\n        mult1 = b;\r\n        mult2 = a;\r\n    } else {\r\n        mult1 = a;\r\n        mult2 = b;\r\n    }\r\n    mult1 = normalForm(mult1);\r\n    mult2 = normalForm(mult2);\r\n    if (mult2.length == 1) {\r\n        return multWithElement(mult1, mult2[0]);\r\n    }\r\n    int d1 = mult1.length;\r\n    int d2 = mult2.length;\r\n    int[] result = new int[d1 + d2 - 1];\r\n    if (d2 != d1) {\r\n        int[] res1 = new int[d2];\r\n        int[] res2 = new int[d1 - d2];\r\n        System.arraycopy(mult1, 0, res1, 0, res1.length);\r\n        System.arraycopy(mult1, d2, res2, 0, res2.length);\r\n        res1 = multiply(res1, mult2);\r\n        res2 = multiply(res2, mult2);\r\n        res2 = multWithMonomial(res2, d2);\r\n        result = add(res1, res2);\r\n    } else {\r\n        d2 = (d1 + 1) >>> 1;\r\n        int d = d1 - d2;\r\n        int[] firstPartMult1 = new int[d2];\r\n        int[] firstPartMult2 = new int[d2];\r\n        int[] secondPartMult1 = new int[d];\r\n        int[] secondPartMult2 = new int[d];\r\n        System.arraycopy(mult1, 0, firstPartMult1, 0, firstPartMult1.length);\r\n        System.arraycopy(mult1, d2, secondPartMult1, 0, secondPartMult1.length);\r\n        System.arraycopy(mult2, 0, firstPartMult2, 0, firstPartMult2.length);\r\n        System.arraycopy(mult2, d2, secondPartMult2, 0, secondPartMult2.length);\r\n        int[] helpPoly1 = add(firstPartMult1, secondPartMult1);\r\n        int[] helpPoly2 = add(firstPartMult2, secondPartMult2);\r\n        int[] res1 = multiply(firstPartMult1, firstPartMult2);\r\n        int[] res2 = multiply(helpPoly1, helpPoly2);\r\n        int[] res3 = multiply(secondPartMult1, secondPartMult2);\r\n        res2 = add(res2, res1);\r\n        res2 = add(res2, res3);\r\n        res3 = multWithMonomial(res3, d2);\r\n        result = add(res2, res3);\r\n        result = multWithMonomial(result, d2);\r\n        result = add(result, res1);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.bouncycastle.eac.EACCertificateHolder.toASN1Structure",
	"Comment": "return the underlying asn.1 structure for the certificate in this holder.",
	"Method": "CVCertificate toASN1Structure(){\r\n    return cvCertificate;\r\n}"
}, {
	"Path": "org.bouncycastle.x509.AttributeCertificateHolder.getSerialNumber",
	"Comment": "return the serial number associated with the issuer attached to thisholder.",
	"Method": "BigInteger getSerialNumber(){\r\n    if (holder.getBaseCertificateID() != null) {\r\n        return holder.getBaseCertificateID().getSerial().getValue();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.provider.RFC3280CertPathUtilities.processCRLB1",
	"Comment": "if the dp includes crlissuer, then verify that the issuer field in thecomplete crl matches crlissuer in the dp and that the complete crlcontains an issuing distribution point extension with the indirectcrlboolean asserted. otherwise, verify that the crl issuer matches thecertificate issuer.",
	"Method": "void processCRLB1(DistributionPoint dp,Object cert,X509CRL crl){\r\n    ASN1Primitive idp = CertPathValidatorUtilities.getExtensionValue(crl, ISSUING_DISTRIBUTION_POINT);\r\n    boolean isIndirect = false;\r\n    if (idp != null) {\r\n        if (IssuingDistributionPoint.getInstance(idp).isIndirectCRL()) {\r\n            isIndirect = true;\r\n        }\r\n    }\r\n    byte[] issuerBytes;\r\n    try {\r\n        issuerBytes = PrincipalUtils.getIssuerPrincipal(crl).getEncoded();\r\n    } catch (IOException e) {\r\n        throw new AnnotatedException(\"Exception encoding CRL issuer: \" + e.getMessage(), e);\r\n    }\r\n    boolean matchIssuer = false;\r\n    if (dp.getCRLIssuer() != null) {\r\n        GeneralName[] genNames = dp.getCRLIssuer().getNames();\r\n        for (int j = 0; j < genNames.length; j++) {\r\n            if (genNames[j].getTagNo() == GeneralName.directoryName) {\r\n                try {\r\n                    if (Arrays.areEqual(genNames[j].getName().toASN1Primitive().getEncoded(), issuerBytes)) {\r\n                        matchIssuer = true;\r\n                    }\r\n                } catch (IOException e) {\r\n                    throw new AnnotatedException(\"CRL issuer information from distribution point cannot be decoded.\", e);\r\n                }\r\n            }\r\n        }\r\n        if (matchIssuer && !isIndirect) {\r\n            throw new AnnotatedException(\"Distribution point contains cRLIssuer field but CRL is not indirect.\");\r\n        }\r\n        if (!matchIssuer) {\r\n            throw new AnnotatedException(\"CRL issuer of CRL does not match CRL issuer of distribution point.\");\r\n        }\r\n    } else {\r\n        if (PrincipalUtils.getIssuerPrincipal(crl).equals(PrincipalUtils.getEncodedIssuerPrincipal(cert))) {\r\n            matchIssuer = true;\r\n        }\r\n    }\r\n    if (!matchIssuer) {\r\n        throw new AnnotatedException(\"Cannot find matching CRL issuer for certificate.\");\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSSignedDataParser.getOtherRevocationInfo",
	"Comment": "return any otherrevocationinfo otherrevinfo objects of the type indicated by otherrevocationinfoformat inthis signeddata structure.",
	"Method": "Store getOtherRevocationInfo(ASN1ObjectIdentifier otherRevocationInfoFormat){\r\n    populateCertCrlSets();\r\n    return HELPER.getOtherRevocationInfo(otherRevocationInfoFormat, _crlSet);\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSSignedGenerator.addCRLs",
	"Comment": "add the crls in crlstore to the crl set to be included with the generated signeddata message.",
	"Method": "void addCRLs(Store crlStore){\r\n    crls.addAll(CMSUtils.getCRLsFromStore(crlStore));\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.ch1_titlepane.BERootPaneUI.uninstallWindowListeners",
	"Comment": "uninstalls the necessary listeners on the window the\tlisteners were last installed on.",
	"Method": "void uninstallWindowListeners(JRootPane root){\r\n    if (window != null) {\r\n        window.removeMouseListener(mouseInputListener);\r\n        window.removeMouseMotionListener(mouseInputListener);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.x509.ExtendedPKIXParameters.setUseDeltasEnabled",
	"Comment": "sets if delta crls should be used for checking the revocation status.",
	"Method": "void setUseDeltasEnabled(boolean useDeltas){\r\n    this.useDeltas = useDeltas;\r\n}"
}, {
	"Path": "org.bouncycastle.x509.ExtendedPKIXParameters.getTrustedACIssuers",
	"Comment": "returns the trusted attribute certificate issuers. if attributecertificates is verified the trusted ac issuers must be set.the returned set consists of trustanchors.the returned set is immutable. never null",
	"Method": "Set getTrustedACIssuers(){\r\n    return Collections.unmodifiableSet(trustedACIssuers);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.engines.CAST6Engine.decryptBlock",
	"Comment": "decrypt the given input starting at the given offset and placethe result in the provided buffer starting at the given offset.",
	"Method": "int decryptBlock(byte[] src,int srcIndex,byte[] dst,int dstIndex){\r\n    int[] result = new int[4];\r\n    int A = BytesTo32bits(src, srcIndex);\r\n    int B = BytesTo32bits(src, srcIndex + 4);\r\n    int C = BytesTo32bits(src, srcIndex + 8);\r\n    int D = BytesTo32bits(src, srcIndex + 12);\r\n    CAST_Decipher(A, B, C, D, result);\r\n    Bits32ToBytes(result[0], dst, dstIndex);\r\n    Bits32ToBytes(result[1], dst, dstIndex + 4);\r\n    Bits32ToBytes(result[2], dst, dstIndex + 8);\r\n    Bits32ToBytes(result[3], dst, dstIndex + 12);\r\n    return BLOCK_SIZE;\r\n}"
}, {
	"Path": "org.bouncycastle.pkcs.PKCS10CertificationRequest.getSubjectPublicKeyInfo",
	"Comment": "return the subjectpublickeyinfo describing the public key this request is carrying.",
	"Method": "SubjectPublicKeyInfo getSubjectPublicKeyInfo(){\r\n    return certificationRequest.getCertificationRequestInfo().getSubjectPublicKeyInfo();\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.gmss.util.WinternitzOTSVerify.getLog",
	"Comment": "this method returns the least integer that is greater or equal to thelogarithm to the base 2 of an integer intvalue.",
	"Method": "int getLog(int intValue){\r\n    int log = 1;\r\n    int i = 2;\r\n    while (i < intValue) {\r\n        i <<= 1;\r\n        log++;\r\n    }\r\n    return log;\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.operator.PBEDataDecryptorFactory.makeKeyFromPassPhrase",
	"Comment": "generates an encryption key using the pass phrase and digest calculator configured for thisfactory.",
	"Method": "byte[] makeKeyFromPassPhrase(int keyAlgorithm,S2K s2k){\r\n    return PGPUtil.makeKeyFromPassPhrase(calculatorProvider, keyAlgorithm, s2k, passPhrase);\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.gmss.Treehash.destroy",
	"Comment": "destroys a treehash instance after the top node was taken forauthentication path.",
	"Method": "void destroy(){\r\n    this.isInitialized = false;\r\n    this.isFinished = false;\r\n    this.firstNode = null;\r\n    this.tailLength = 0;\r\n    this.firstNodeHeight = -1;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.x509.PKIXNameConstraintValidator.addExcludedSubtree",
	"Comment": "adds a subtree to the excluded set of these name constraints.",
	"Method": "void addExcludedSubtree(GeneralSubtree subtree){\r\n    GeneralName base = subtree.getBase();\r\n    switch(base.getTagNo()) {\r\n        case GeneralName.otherName:\r\n            excludedSubtreesOtherName = unionOtherName(excludedSubtreesOtherName, OtherName.getInstance(base.getName()));\r\n            break;\r\n        case GeneralName.rfc822Name:\r\n            excludedSubtreesEmail = unionEmail(excludedSubtreesEmail, extractNameAsString(base));\r\n            break;\r\n        case GeneralName.dNSName:\r\n            excludedSubtreesDNS = unionDNS(excludedSubtreesDNS, extractNameAsString(base));\r\n            break;\r\n        case GeneralName.directoryName:\r\n            excludedSubtreesDN = unionDN(excludedSubtreesDN, (ASN1Sequence) base.getName().toASN1Primitive());\r\n            break;\r\n        case GeneralName.uniformResourceIdentifier:\r\n            excludedSubtreesURI = unionURI(excludedSubtreesURI, extractNameAsString(base));\r\n            break;\r\n        case GeneralName.iPAddress:\r\n            excludedSubtreesIP = unionIP(excludedSubtreesIP, ASN1OctetString.getInstance(base.getName()).getOctets());\r\n            break;\r\n        default:\r\n            throw new IllegalStateException(\"Unknown tag encountered: \" + base.getTagNo());\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.ntru.polynomial.BigDecimalPolynomial.mult",
	"Comment": "multiplies the polynomial by another, taking the indices mod n. does notchange this polynomial but returns the result as a new polynomial.",
	"Method": "BigDecimalPolynomial mult(BigIntPolynomial poly2,BigDecimalPolynomial mult,BigDecimalPolynomial poly2){\r\n    int N = coeffs.length;\r\n    if (poly2.coeffs.length != N) {\r\n        throw new IllegalArgumentException(\"Number of coefficients must be the same\");\r\n    }\r\n    BigDecimalPolynomial c = multRecursive(poly2);\r\n    if (c.coeffs.length > N) {\r\n        for (int k = N; k < c.coeffs.length; k++) {\r\n            c.coeffs[k - N] = c.coeffs[k - N].add(c.coeffs[k]);\r\n        }\r\n        c.coeffs = copyOf(c.coeffs, N);\r\n    }\r\n    return c;\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSEnvelopedDataParser.getContentEncryptionAlgorithm",
	"Comment": "return the content encryption algorithm details for the data in this object.",
	"Method": "AlgorithmIdentifier getContentEncryptionAlgorithm(){\r\n    return encAlg;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.x509.X509DefaultEntryConverter.getConvertedValue",
	"Comment": "apply default coversion for the given value depending on the oidand the character range of the value.",
	"Method": "ASN1Primitive getConvertedValue(ASN1ObjectIdentifier oid,String value){\r\n    if (value.length() != 0 && value.charAt(0) == '#') {\r\n        try {\r\n            return convertHexEncoded(value, 1);\r\n        } catch (IOException e) {\r\n            throw new RuntimeException(\"can't recode value for oid \" + oid.getId());\r\n        }\r\n    } else {\r\n        if (value.length() != 0 && value.charAt(0) == '\\\\') {\r\n            value = value.substring(1);\r\n        }\r\n        if (oid.equals(X509Name.EmailAddress) || oid.equals(X509Name.DC)) {\r\n            return new DERIA5String(value);\r\n        } else if (oid.equals(X509Name.DATE_OF_BIRTH)) {\r\n            return new DERGeneralizedTime(value);\r\n        } else if (oid.equals(X509Name.C) || oid.equals(X509Name.SN) || oid.equals(X509Name.DN_QUALIFIER) || oid.equals(X509Name.TELEPHONE_NUMBER)) {\r\n            return new DERPrintableString(value);\r\n        }\r\n    }\r\n    return new DERUTF8String(value);\r\n}"
}, {
	"Path": "org.bouncycastle.cert.cmp.ProtectedPKIMessage.toASN1Structure",
	"Comment": "return the underlying asn.1 structure contained in this object.",
	"Method": "PKIMessage toASN1Structure(){\r\n    return pkiMessage;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.generators.PKCS5S2ParametersGenerator.generateDerivedParameters",
	"Comment": "generate a key with initialisation vector parameter derived fromthe password, salt, and iteration count we are currently initialisedwith.",
	"Method": "CipherParameters generateDerivedParameters(int keySize,CipherParameters generateDerivedParameters,int keySize,int ivSize){\r\n    keySize = keySize / 8;\r\n    ivSize = ivSize / 8;\r\n    byte[] dKey = generateDerivedKey(keySize + ivSize);\r\n    return new ParametersWithIV(new KeyParameter(dKey, 0, keySize), dKey, keySize, ivSize);\r\n}"
}, {
	"Path": "org.bouncycastle.mail.smime.SMIMESignedParser.getContentWithSignature",
	"Comment": "return the content that was signed with its signature attached.",
	"Method": "Object getContentWithSignature(){\r\n    return message;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.modes.NISTCTSBlockCipher.processByte",
	"Comment": "process a single byte, producing an output block if necessary.",
	"Method": "int processByte(byte in,byte[] out,int outOff){\r\n    int resultLen = 0;\r\n    if (bufOff == buf.length) {\r\n        resultLen = cipher.processBlock(buf, 0, out, outOff);\r\n        System.arraycopy(buf, blockSize, buf, 0, blockSize);\r\n        bufOff = blockSize;\r\n    }\r\n    buf[bufOff++] = in;\r\n    return resultLen;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.agreement.srp.SRP6Client.verifyServerEvidenceMessage",
	"Comment": "authenticates the server evidence message m2 received and saves it only if correct.",
	"Method": "boolean verifyServerEvidenceMessage(BigInteger serverM2){\r\n    if (this.A == null || this.M1 == null || this.S == null) {\r\n        throw new CryptoException(\"Impossible to compute and verify M2: \" + \"some data are missing from the previous operations (A,M1,S)\");\r\n    }\r\n    BigInteger computedM2 = SRP6Util.calculateM2(digest, N, A, M1, S);\r\n    if (computedM2.equals(serverM2)) {\r\n        this.M2 = serverM2;\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.bouncycastle.gpg.SExprParser.parseSecretKey",
	"Comment": "parse a secret key from one of the gpg s expression keys associating it with the passed in public key.",
	"Method": "PGPSecretKey parseSecretKey(InputStream inputStream,PBEProtectionRemoverFactory keyProtectionRemoverFactory,PGPPublicKey pubKey,PGPSecretKey parseSecretKey,InputStream inputStream,PBEProtectionRemoverFactory keyProtectionRemoverFactory,KeyFingerPrintCalculator fingerPrintCalculator){\r\n    SXprUtils.skipOpenParenthesis(inputStream);\r\n    String type;\r\n    type = SXprUtils.readString(inputStream, inputStream.read());\r\n    if (type.equals(\"protected-private-key\")) {\r\n        SXprUtils.skipOpenParenthesis(inputStream);\r\n        String keyType = SXprUtils.readString(inputStream, inputStream.read());\r\n        if (keyType.equals(\"ecc\")) {\r\n            SXprUtils.skipOpenParenthesis(inputStream);\r\n            String curveID = SXprUtils.readString(inputStream, inputStream.read());\r\n            String curveName = SXprUtils.readString(inputStream, inputStream.read());\r\n            if (curveName.startsWith(\"NIST \")) {\r\n                curveName = curveName.substring(\"NIST \".length());\r\n            }\r\n            SXprUtils.skipCloseParenthesis(inputStream);\r\n            byte[] qVal;\r\n            SXprUtils.skipOpenParenthesis(inputStream);\r\n            type = SXprUtils.readString(inputStream, inputStream.read());\r\n            if (type.equals(\"q\")) {\r\n                qVal = SXprUtils.readBytes(inputStream, inputStream.read());\r\n            } else {\r\n                throw new PGPException(\"no q value found\");\r\n            }\r\n            PublicKeyPacket pubPacket = new PublicKeyPacket(PublicKeyAlgorithmTags.ECDSA, new Date(), new ECDSAPublicBCPGKey(ECNamedCurveTable.getOID(curveName), new BigInteger(1, qVal)));\r\n            SXprUtils.skipCloseParenthesis(inputStream);\r\n            BigInteger d = processECSecretKey(inputStream, curveID, curveName, qVal, keyProtectionRemoverFactory);\r\n            return new PGPSecretKey(new SecretKeyPacket(pubPacket, SymmetricKeyAlgorithmTags.NULL, null, null, new ECSecretBCPGKey(d).getEncoded()), new PGPPublicKey(pubPacket, fingerPrintCalculator));\r\n        } else if (keyType.equals(\"dsa\")) {\r\n            BigInteger p = readBigInteger(\"p\", inputStream);\r\n            BigInteger q = readBigInteger(\"q\", inputStream);\r\n            BigInteger g = readBigInteger(\"g\", inputStream);\r\n            BigInteger y = readBigInteger(\"y\", inputStream);\r\n            BigInteger x = processDSASecretKey(inputStream, p, q, g, y, keyProtectionRemoverFactory);\r\n            PublicKeyPacket pubPacket = new PublicKeyPacket(PublicKeyAlgorithmTags.DSA, new Date(), new DSAPublicBCPGKey(p, q, g, y));\r\n            return new PGPSecretKey(new SecretKeyPacket(pubPacket, SymmetricKeyAlgorithmTags.NULL, null, null, new DSASecretBCPGKey(x).getEncoded()), new PGPPublicKey(pubPacket, fingerPrintCalculator));\r\n        } else if (keyType.equals(\"elg\")) {\r\n            BigInteger p = readBigInteger(\"p\", inputStream);\r\n            BigInteger g = readBigInteger(\"g\", inputStream);\r\n            BigInteger y = readBigInteger(\"y\", inputStream);\r\n            BigInteger x = processElGamalSecretKey(inputStream, p, g, y, keyProtectionRemoverFactory);\r\n            PublicKeyPacket pubPacket = new PublicKeyPacket(PublicKeyAlgorithmTags.ELGAMAL_ENCRYPT, new Date(), new ElGamalPublicBCPGKey(p, g, y));\r\n            return new PGPSecretKey(new SecretKeyPacket(pubPacket, SymmetricKeyAlgorithmTags.NULL, null, null, new ElGamalSecretBCPGKey(x).getEncoded()), new PGPPublicKey(pubPacket, fingerPrintCalculator));\r\n        } else if (keyType.equals(\"rsa\")) {\r\n            BigInteger n = readBigInteger(\"n\", inputStream);\r\n            BigInteger e = readBigInteger(\"e\", inputStream);\r\n            BigInteger[] values = processRSASecretKey(inputStream, n, e, keyProtectionRemoverFactory);\r\n            PublicKeyPacket pubPacket = new PublicKeyPacket(PublicKeyAlgorithmTags.RSA_GENERAL, new Date(), new RSAPublicBCPGKey(n, e));\r\n            return new PGPSecretKey(new SecretKeyPacket(pubPacket, SymmetricKeyAlgorithmTags.NULL, null, null, new RSASecretBCPGKey(values[0], values[1], values[2]).getEncoded()), new PGPPublicKey(pubPacket, fingerPrintCalculator));\r\n        } else {\r\n            throw new PGPException(\"unknown key type: \" + keyType);\r\n        }\r\n    }\r\n    throw new PGPException(\"unknown key type found\");\r\n}"
}, {
	"Path": "org.bouncycastle.jce.provider.PKIXNameConstraintValidator.addExcludedSubtree",
	"Comment": "adds a subtree to the excluded set of these name constraints.",
	"Method": "void addExcludedSubtree(GeneralSubtree subtree){\r\n    GeneralName base = subtree.getBase();\r\n    switch(base.getTagNo()) {\r\n        case 1:\r\n            excludedSubtreesEmail = unionEmail(excludedSubtreesEmail, extractNameAsString(base));\r\n            break;\r\n        case 2:\r\n            excludedSubtreesDNS = unionDNS(excludedSubtreesDNS, extractNameAsString(base));\r\n            break;\r\n        case 4:\r\n            excludedSubtreesDN = unionDN(excludedSubtreesDN, (ASN1Sequence) base.getName().toASN1Primitive());\r\n            break;\r\n        case 6:\r\n            excludedSubtreesURI = unionURI(excludedSubtreesURI, extractNameAsString(base));\r\n            break;\r\n        case 7:\r\n            excludedSubtreesIP = unionIP(excludedSubtreesIP, ASN1OctetString.getInstance(base.getName()).getOctets());\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.X509CertSelector.setSerialNumber",
	"Comment": "sets the serialnumber criterion. the specified serial number must matchthe certificate serial number in the x509certificate. ifnull, any certificate serial number will do.",
	"Method": "void setSerialNumber(BigInteger serial){\r\n    serialNumber = serial;\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPPublicKeyRing.getPublicKey",
	"Comment": "return the public key with the passed in fingerprint if itis present.",
	"Method": "PGPPublicKey getPublicKey(PGPPublicKey getPublicKey,long keyID,PGPPublicKey getPublicKey,byte[] fingerprint){\r\n    for (int i = 0; i != keys.size(); i++) {\r\n        PGPPublicKey k = (PGPPublicKey) keys.get(i);\r\n        if (Arrays.areEqual(fingerprint, k.getFingerprint())) {\r\n            return k;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.spec.DHDomainParameterSpec.getJ",
	"Comment": "return the j value for the domain parameter set if available.",
	"Method": "BigInteger getJ(){\r\n    return j;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.prng.SP800SecureRandomBuilder.setPersonalizationString",
	"Comment": "set the personalization string for drbg securerandoms created by this builder",
	"Method": "SP800SecureRandomBuilder setPersonalizationString(byte[] personalizationString){\r\n    this.personalizationString = personalizationString;\r\n    return this;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.ntru.euclid.IntEuclidean.calculate",
	"Comment": "runs the eea on two intsimplemented from pseudocode on wikipedia.",
	"Method": "IntEuclidean calculate(int a,int b){\r\n    int x = 0;\r\n    int lastx = 1;\r\n    int y = 1;\r\n    int lasty = 0;\r\n    while (b != 0) {\r\n        int quotient = a / b;\r\n        int temp = a;\r\n        a = b;\r\n        b = temp % b;\r\n        temp = x;\r\n        x = lastx - quotient * x;\r\n        lastx = temp;\r\n        temp = y;\r\n        y = lasty - quotient * y;\r\n        lasty = temp;\r\n    }\r\n    IntEuclidean result = new IntEuclidean();\r\n    result.x = lastx;\r\n    result.y = lasty;\r\n    result.gcd = a;\r\n    return result;\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.ch3_button.BEToggleButtonUI.paintText",
	"Comment": "as of java 2 platform v 1.4 this method should not be used or overriden.use the painttext method which takes the abstractbutton argument.",
	"Method": "void paintText(Graphics g,JComponent c,Rectangle textRect,String text){\r\n    AbstractButton b = (AbstractButton) c;\r\n    ButtonModel model = b.getModel();\r\n    FontMetrics fm = MySwingUtilities2.getFontMetrics(c, g);\r\n    int mnemonicIndex = b.getDisplayedMnemonicIndex();\r\n    if (model.isEnabled()) {\r\n        if (model.isSelected())\r\n            g.setColor(UIManager.getColor(getPropertyPrefix() + \"focus\"));\r\n        else\r\n            g.setColor(b.getForeground());\r\n        MySwingUtilities2.drawStringUnderlineCharAt(c, g, text, mnemonicIndex, textRect.x + getTextShiftOffset(), textRect.y + fm.getAscent() + getTextShiftOffset());\r\n    } else {\r\n        g.setColor(b.getBackground().brighter());\r\n        MySwingUtilities2.drawStringUnderlineCharAt(c, g, text, mnemonicIndex, textRect.x, textRect.y + fm.getAscent());\r\n        g.setColor(b.getBackground().darker());\r\n        MySwingUtilities2.drawStringUnderlineCharAt(c, g, text, mnemonicIndex, textRect.x - 1, textRect.y + fm.getAscent() - 1);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.agreement.srp.SRP6Server.calculateServerEvidenceMessage",
	"Comment": "computes the server evidence message m2 using the previously verified values.\tto be called after successfully verifying the client evidence message m1.",
	"Method": "BigInteger calculateServerEvidenceMessage(){\r\n    if (this.A == null || this.M1 == null || this.S == null) {\r\n        throw new CryptoException(\"Impossible to compute M2: \" + \"some data are missing from the previous operations (A,M1,S)\");\r\n    }\r\n    this.M2 = SRP6Util.calculateM2(digest, N, A, M1, S);\r\n    return M2;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.generators.OpenSSLPBEParametersGenerator.generateDerivedKey",
	"Comment": "the derived key function, the ith hash of the password and the salt.",
	"Method": "byte[] generateDerivedKey(int bytesNeeded){\r\n    byte[] buf = new byte[digest.getDigestSize()];\r\n    byte[] key = new byte[bytesNeeded];\r\n    int offset = 0;\r\n    for (; ; ) {\r\n        digest.update(password, 0, password.length);\r\n        digest.update(salt, 0, salt.length);\r\n        digest.doFinal(buf, 0);\r\n        int len = (bytesNeeded > buf.length) ? buf.length : bytesNeeded;\r\n        System.arraycopy(buf, 0, key, offset, len);\r\n        offset += len;\r\n        bytesNeeded -= len;\r\n        if (bytesNeeded == 0) {\r\n            break;\r\n        }\r\n        digest.reset();\r\n        digest.update(buf, 0, buf.length);\r\n    }\r\n    return key;\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.provider.asymmetric.util.PrimeCertaintyCalculator.getDefaultCertainty",
	"Comment": "return the current wisdom on prime certainty requirements.",
	"Method": "int getDefaultCertainty(int keySizeInBits){\r\n    return keySizeInBits <= 1024 ? 80 : (96 + 16 * ((keySizeInBits - 1) / 1024));\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.CertUtil.parseX509Name",
	"Comment": "parse the given x.509 name into der encoded byte array representation.",
	"Method": "byte[] parseX509Name(String data){\r\n    ByteArrayOutputStream outStream = new ByteArrayOutputStream();\r\n    DEROutputStream derOutStream = new DEROutputStream(outStream);\r\n    derOutStream.writeObject(new X509Name(trimX509Name(data)));\r\n    derOutStream.close();\r\n    return outStream.toByteArray();\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.nist.NISTNamedCurves.getName",
	"Comment": "return the named curve name represented by the given object identifier.",
	"Method": "String getName(ASN1ObjectIdentifier oid){\r\n    return (String) names.get(oid);\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.CharUtils.clone",
	"Comment": "return a clone of the given char array. no null checks are performed.",
	"Method": "char[] clone(char[] array){\r\n    char[] result = new char[array.length];\r\n    System.arraycopy(array, 0, result, 0, array.length);\r\n    return result;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.BigEndianConversions.OS2LIP",
	"Comment": "convert a byte array of length 8 beginning at inoff into along integer.",
	"Method": "long OS2LIP(byte[] input,int inOff){\r\n    long result = ((long) input[inOff++] & 0xff) << 56;\r\n    result |= ((long) input[inOff++] & 0xff) << 48;\r\n    result |= ((long) input[inOff++] & 0xff) << 40;\r\n    result |= ((long) input[inOff++] & 0xff) << 32;\r\n    result |= ((long) input[inOff++] & 0xff) << 24;\r\n    result |= (input[inOff++] & 0xff) << 16;\r\n    result |= (input[inOff++] & 0xff) << 8;\r\n    result |= input[inOff] & 0xff;\r\n    return result;\r\n}"
}, {
	"Path": "org.bouncycastle.cms.jcajce.JcaSimpleSignerInfoGeneratorBuilder.setSignedAttributeGenerator",
	"Comment": "set up a defaultsignedattributetablegenerator primed with the passed in attributetable.",
	"Method": "JcaSimpleSignerInfoGeneratorBuilder setSignedAttributeGenerator(CMSAttributeTableGenerator signedGen,JcaSimpleSignerInfoGeneratorBuilder setSignedAttributeGenerator,AttributeTable attrTable){\r\n    this.signedGen = new DefaultSignedAttributeTableGenerator(attrTable);\r\n    return this;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.X509CertSelector.getSubjectPublicKeyAlgID",
	"Comment": "returns the subjectpublickeyalgid criterion. thex509certificate must contain a subject public key with thespecified algorithm. if null, no subjectpublickeyalgidcheck will be done.",
	"Method": "String getSubjectPublicKeyAlgID(){\r\n    if (subjectKeyAlgID != null) {\r\n        return subjectKeyAlgID.toString();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.test.EnumeratedTest.testReadingMultipleSingleByteItems",
	"Comment": "makes sure multiple identically sized values are parsed correctly.",
	"Method": "void testReadingMultipleSingleByteItems(){\r\n    ASN1Primitive obj = ASN1Primitive.fromByteArray(MultipleSingleByteItems);\r\n    assertTrue(\"Null ASN.1 SEQUENCE\", obj instanceof ASN1Sequence);\r\n    ASN1Sequence sequence = (ASN1Sequence) obj;\r\n    assertEquals(\"2 items expected\", 2, sequence.size());\r\n    ASN1Enumerated enumerated = ASN1Enumerated.getInstance(sequence.getObjectAt(0));\r\n    assertNotNull(\"ENUMERATED expected\", enumerated);\r\n    assertEquals(\"Unexpected ENUMERATED value\", 1, enumerated.getValue().intValue());\r\n    ASN1Boolean b = ASN1Boolean.getInstance(sequence.getObjectAt(1));\r\n    assertNotNull(\"BOOLEAN expected\", b);\r\n    assertTrue(\"Unexpected BOOLEAN value\", b.isTrue());\r\n}"
}, {
	"Path": "org.bouncycastle.x509.util.LDAPStoreHelper.getDeltaCertificateRevocationLists",
	"Comment": "returns the delta revocation list for revoked certificates.",
	"Method": "Collection getDeltaCertificateRevocationLists(X509CRLStoreSelector selector){\r\n    String[] attrs = splitString(params.getDeltaRevocationListAttribute());\r\n    String[] attrNames = splitString(params.getLdapDeltaRevocationListAttributeName());\r\n    String[] issuerAttributeNames = splitString(params.getDeltaRevocationListIssuerAttributeName());\r\n    List list = cRLIssuerSearch(selector, attrs, attrNames, issuerAttributeNames);\r\n    Set resultSet = createCRLs(list, selector);\r\n    if (resultSet.size() == 0) {\r\n        X509CRLStoreSelector emptySelector = new X509CRLStoreSelector();\r\n        list = cRLIssuerSearch(emptySelector, attrs, attrNames, issuerAttributeNames);\r\n        resultSet.addAll(createCRLs(list, selector));\r\n    }\r\n    return resultSet;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM.normalForm",
	"Comment": "strip leading zero coefficients from the given polynomial.",
	"Method": "int[] normalForm(int[] a){\r\n    int d = computeDegree(a);\r\n    if (d == -1) {\r\n        return new int[1];\r\n    }\r\n    if (a.length == d + 1) {\r\n        return IntUtils.clone(a);\r\n    }\r\n    int[] result = new int[d + 1];\r\n    System.arraycopy(a, 0, result, 0, d + 1);\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.swingset3.codeview.CodeStyler.stringFilter",
	"Comment": "filters strings from a line of text and formats them properly.",
	"Method": "String stringFilter(String line){\r\n    if (line == null || line.equals(\"\")) {\r\n        return \"\";\r\n    }\r\n    StringBuffer buf = new StringBuffer();\r\n    if (!line.contains(\"\\\"\")) {\r\n        return keywordFilter(line);\r\n    }\r\n    int start = 0;\r\n    int startStringIndex = -1;\r\n    int endStringIndex;\r\n    int tempIndex;\r\n    while ((tempIndex = line.indexOf(\"\\\"\")) > -1) {\r\n        if (startStringIndex == -1) {\r\n            startStringIndex = 0;\r\n            buf.append(stringFilter(line.substring(start, tempIndex)));\r\n            buf.append(stringStart).append(\"\\\"\");\r\n            line = line.substring(tempIndex + 1);\r\n        } else {\r\n            startStringIndex = -1;\r\n            endStringIndex = tempIndex;\r\n            buf.append(line.substring(0, endStringIndex + 1));\r\n            buf.append(stringEnd);\r\n            line = line.substring(endStringIndex + 1);\r\n        }\r\n    }\r\n    buf.append(keywordFilter(line));\r\n    return buf.toString();\r\n}"
}, {
	"Path": "java.security.cert.X509CRLSelector.setMaxCRLNumber",
	"Comment": "sets the maxcrlnumber criterion. the x509crl must have acrl number extension whose value is less than or equal to the specifiedvalue. if null, no maxcrlnumber check will be done.",
	"Method": "void setMaxCRLNumber(BigInteger maxCRL){\r\n    this.maxCRL = maxCRL;\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSAuthenticatedDataParser.getMacAlgorithm",
	"Comment": "return the mac algorithm details for the mac associated with the data in this object.",
	"Method": "AlgorithmIdentifier getMacAlgorithm(){\r\n    return macAlg;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.CertPath.writeReplace",
	"Comment": "replaces the certpath to be serialized with a certpathrep object.",
	"Method": "Object writeReplace(){\r\n    try {\r\n        return new CertPathRep(getType(), getEncoded());\r\n    } catch (CertificateException ce) {\r\n        throw new NotSerializableException(\" java.security.cert.CertPath: \" + getType());\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.test.EnumeratedTest.testReadingMultipleDoubleByteItems",
	"Comment": "makes sure multiple identically sized values are parsed correctly.",
	"Method": "void testReadingMultipleDoubleByteItems(){\r\n    ASN1Primitive obj = ASN1Primitive.fromByteArray(MultipleDoubleByteItems);\r\n    assertTrue(\"Null ASN.1 SEQUENCE\", obj instanceof ASN1Sequence);\r\n    ASN1Sequence sequence = (ASN1Sequence) obj;\r\n    assertEquals(\"2 items expected\", 2, sequence.size());\r\n    ASN1Enumerated enumerated1 = ASN1Enumerated.getInstance(sequence.getObjectAt(0));\r\n    assertNotNull(\"ENUMERATED expected\", enumerated1);\r\n    assertEquals(\"Unexpected ENUMERATED value\", 257, enumerated1.getValue().intValue());\r\n    ASN1Enumerated enumerated2 = ASN1Enumerated.getInstance(sequence.getObjectAt(1));\r\n    assertNotNull(\"ENUMERATED expected\", enumerated2);\r\n    assertEquals(\"Unexpected ENUMERATED value\", 514, enumerated2.getValue().intValue());\r\n}"
}, {
	"Path": "org.bouncycastle.i18n.ErrorBundle.getDetail",
	"Comment": "returns the detail message in the given locale and the default timezone.",
	"Method": "String getDetail(Locale loc,TimeZone timezone,String getDetail,Locale loc){\r\n    return getEntry(DETAIL_ENTRY, loc, TimeZone.getDefault());\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.ntru.polynomial.IntegerPolynomial.toBinary",
	"Comment": "encodes a polynomial whose coefficients are between 0 and q, to binary. q must be a power of 2.",
	"Method": "byte[] toBinary(int q){\r\n    return ArrayEncoder.encodeModQ(coeffs, q);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.generators.ECKeyPairGenerator.generateKeyPair",
	"Comment": "given the domain parameters this routine generates an ec keypair in accordance with x9.62 section 5.2.1 pages 26, 27.",
	"Method": "AsymmetricCipherKeyPair generateKeyPair(){\r\n    BigInteger n = params.getN();\r\n    int nBitLength = n.bitLength();\r\n    int minWeight = nBitLength >>> 2;\r\n    BigInteger d;\r\n    for (; ; ) {\r\n        d = BigIntegers.createRandomBigInteger(nBitLength, random);\r\n        if (d.compareTo(TWO) < 0 || (d.compareTo(n) >= 0)) {\r\n            continue;\r\n        }\r\n        if (WNafUtil.getNafWeight(d) < minWeight) {\r\n            continue;\r\n        }\r\n        break;\r\n    }\r\n    ECPoint Q = createBasePointMultiplier().multiply(params.getG(), d);\r\n    return new AsymmetricCipherKeyPair(new ECPublicKeyParameters(Q, params), new ECPrivateKeyParameters(d, params));\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.io.CipherInputStream.read",
	"Comment": "reads data from the underlying stream and processes it with the cipher until the cipheroutputs data, and then returns up to len bytes in the provided array.if the underlying stream is exhausted by this call, the cipher will be finalised.",
	"Method": "int read(int read,byte[] b,int off,int len){\r\n    if (bufOff >= maxBuf) {\r\n        if (nextChunk() < 0) {\r\n            return -1;\r\n        }\r\n    }\r\n    int toSupply = Math.min(len, available());\r\n    System.arraycopy(buf, bufOff, b, off, toSupply);\r\n    bufOff += toSupply;\r\n    return toSupply;\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPPublicKeyEncryptedData.getDataStream",
	"Comment": "open an input stream which will provide the decrypted data protected by this object.",
	"Method": "InputStream getDataStream(PublicKeyDataDecryptorFactory dataDecryptorFactory){\r\n    byte[] sessionData = dataDecryptorFactory.recoverSessionData(keyData.getAlgorithm(), keyData.getEncSessionKey());\r\n    if (!confirmCheckSum(sessionData)) {\r\n        throw new PGPKeyValidationException(\"key checksum failed\");\r\n    }\r\n    if (sessionData[0] != SymmetricKeyAlgorithmTags.NULL) {\r\n        try {\r\n            boolean withIntegrityPacket = encData instanceof SymmetricEncIntegrityPacket;\r\n            byte[] sessionKey = new byte[sessionData.length - 3];\r\n            System.arraycopy(sessionData, 1, sessionKey, 0, sessionKey.length);\r\n            PGPDataDecryptor dataDecryptor = dataDecryptorFactory.createDataDecryptor(withIntegrityPacket, sessionData[0] & 0xff, sessionKey);\r\n            encStream = new BCPGInputStream(dataDecryptor.getInputStream(encData.getInputStream()));\r\n            if (withIntegrityPacket) {\r\n                truncStream = new TruncatedStream(encStream);\r\n                integrityCalculator = dataDecryptor.getIntegrityCalculator();\r\n                encStream = new TeeInputStream(truncStream, integrityCalculator.getOutputStream());\r\n            }\r\n            byte[] iv = new byte[dataDecryptor.getBlockSize()];\r\n            for (int i = 0; i != iv.length; i++) {\r\n                int ch = encStream.read();\r\n                if (ch < 0) {\r\n                    throw new EOFException(\"unexpected end of stream.\");\r\n                }\r\n                iv[i] = (byte) ch;\r\n            }\r\n            int v1 = encStream.read();\r\n            int v2 = encStream.read();\r\n            if (v1 < 0 || v2 < 0) {\r\n                throw new EOFException(\"unexpected end of stream.\");\r\n            }\r\n            return encStream;\r\n        } catch (PGPException e) {\r\n            throw e;\r\n        } catch (Exception e) {\r\n            throw new PGPException(\"Exception starting decryption\", e);\r\n        }\r\n    } else {\r\n        return encData.getInputStream();\r\n    }\r\n}"
}, {
	"Path": "com.sun.swingset3.codeview.SnippetHighlighter.getHighlights",
	"Comment": "makes a copy of the highlights.does not actually clone each highlight,but only makes references to them.",
	"Method": "Highlighter.Highlight[] getHighlights(){\r\n    int size = highlights.size();\r\n    if (size == 0) {\r\n        return noHighlights;\r\n    }\r\n    Highlighter.Highlight[] h = new Highlighter.Highlight[size];\r\n    highlights.copyInto(h);\r\n    return h;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2nPolynomialElement.invertMAIA",
	"Comment": "calculates the multiplicative inverse of this using the modifiedalmost inverse algorithm and returns the result in a newgf2npolynomialelement.",
	"Method": "GF2nPolynomialElement invertMAIA(){\r\n    if (isZero()) {\r\n        throw new ArithmeticException();\r\n    }\r\n    GF2Polynomial b = new GF2Polynomial(mDegree, \"ONE\");\r\n    GF2Polynomial c = new GF2Polynomial(mDegree);\r\n    GF2Polynomial u = getGF2Polynomial();\r\n    GF2Polynomial v = mField.getFieldPolynomial();\r\n    GF2Polynomial h;\r\n    while (true) {\r\n        while (!u.testBit(0)) {\r\n            u.shiftRightThis();\r\n            if (!b.testBit(0)) {\r\n                b.shiftRightThis();\r\n            } else {\r\n                b.addToThis(mField.getFieldPolynomial());\r\n                b.shiftRightThis();\r\n            }\r\n        }\r\n        if (u.isOne()) {\r\n            return new GF2nPolynomialElement((GF2nPolynomialField) mField, b);\r\n        }\r\n        u.reduceN();\r\n        v.reduceN();\r\n        if (u.getLength() < v.getLength()) {\r\n            h = u;\r\n            u = v;\r\n            v = h;\r\n            h = b;\r\n            b = c;\r\n            c = h;\r\n        }\r\n        u.addToThis(v);\r\n        b.addToThis(c);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.jce.provider.test.HMacTest.testPBEWITHHMACSHAVariants",
	"Comment": "test that bc has the same results as the sunjca provider for pbewithhmacsha.test courtesy of the android project.",
	"Method": "void testPBEWITHHMACSHAVariants(){\r\n    byte[] plaintext = new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34 };\r\n    byte[] salt = \"saltsalt\".getBytes();\r\n    char[] password = \"password\".toCharArray();\r\n    int iterationCount = 100;\r\n    for (int shaVariantIndex = 0; shaVariantIndex < SUN_JCA_VARIANTS.length; shaVariantIndex++) {\r\n        int shaVariant = SUN_JCA_VARIANTS[shaVariantIndex];\r\n        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(\"PBKDF2WITHHMACSHA\" + shaVariant, \"BC\");\r\n        PBEKeySpec pbeKeySpec = new // Key depending on block size!\r\n        PBEKeySpec(// Key depending on block size!\r\n        password, // Key depending on block size!\r\n        salt, iterationCount, (shaVariant < 384) ? 64 : 128);\r\n        SecretKey secretKey = secretKeyFactory.generateSecret(pbeKeySpec);\r\n        Mac mac = Mac.getInstance(\"PBEWITHHMACSHA\" + shaVariant, \"BC\");\r\n        mac.init(secretKey);\r\n        byte[] bcResult = mac.doFinal(plaintext);\r\n        isTrue(\"value mismatch\", Arrays.equals(SUN_JCA_KNOWN_ANSWERS_FOR_SHA_VARIANTS[shaVariantIndex], bcResult));\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2Polynomial.subtract",
	"Comment": "subtracts two gf2polynomials, this and b, and returns theresult in a new gf2polynomial. this and b can be ofdifferent size.",
	"Method": "GF2Polynomial subtract(GF2Polynomial b){\r\n    return xor(b);\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.spec.DHDomainParameterSpec.getM",
	"Comment": "return the minimum bitlength for a private value to be generated from these parameters, 0 if not set.",
	"Method": "int getM(){\r\n    return m;\r\n}"
}, {
	"Path": "java.security.cert.CertUtil.parseURI",
	"Comment": "parse the given uri into der encoded byte array representation.",
	"Method": "byte[] parseURI(String data){\r\n    ASN1Object derData = new DERIA5String(data);\r\n    ByteArrayOutputStream outStream = new ByteArrayOutputStream();\r\n    DEROutputStream derOutStream = new DEROutputStream(outStream);\r\n    derOutStream.writeObject(derData);\r\n    derOutStream.close();\r\n    return outStream.toByteArray();\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.x509.X509Extensions.getExtension",
	"Comment": "return the extension represented by the object identifierpassed in.",
	"Method": "X509Extension getExtension(ASN1ObjectIdentifier oid){\r\n    return (X509Extension) extensions.get(oid);\r\n}"
}, {
	"Path": "org.bouncycastle.test.est.TestCACertsFetch.testFetchCaCertsWithTrustAnchor",
	"Comment": "fetch ca certs relying on tls to validate the server by specifying a trust anchor.",
	"Method": "void testFetchCaCertsWithTrustAnchor(){\r\n    ESTTestUtils.ensureProvider();\r\n    X509CertificateHolder[] theirCAs = null;\r\n    ESTServerUtils.ServerInstance serverInstance = null;\r\n    try {\r\n        serverInstance = startDefaultServer();\r\n        FileReader fr = new FileReader(ESTServerUtils.makeRelativeToServerHome(\"/estCA/cacert.crt\"));\r\n        PemReader reader = new PemReader(fr);\r\n        X509CertificateHolder fromFile = new X509CertificateHolder(reader.readPemObject().getContent());\r\n        reader.close();\r\n        fr.close();\r\n        TrustAnchor ta = new TrustAnchor(ESTTestUtils.toJavaX509Certificate(fromFile), null);\r\n        ESTService est = new JsseESTServiceBuilder(\"localhost:8443\", JcaJceUtils.getCertPathTrustManager(ESTTestUtils.toTrustAnchor(ta), null)).build();\r\n        CACertsResponse caCertsResponse = est.getCACerts();\r\n        X509CertificateHolder[] caCerts = ESTService.storeToArray(caCertsResponse.getCertificateStore());\r\n        Assert.assertEquals(\"Returned ca certs should be 1\", caCerts.length, 1);\r\n        Assert.assertEquals(\"CA cert did match expected.\", fromFile, caCerts[0]);\r\n        Assert.assertTrue(\"Must be trusted.\", caCertsResponse.isTrusted());\r\n    } finally {\r\n        if (serverInstance != null) {\r\n            serverInstance.getServer().stop_server();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.mail.smime.handlers.multipart_signed.outputBodyPart",
	"Comment": "output the mulitpart as a collection of leaves to make sure preamble text is not included.",
	"Method": "void outputBodyPart(OutputStream out,Object bodyPart){\r\n    if (bodyPart instanceof Multipart) {\r\n        Multipart mp = (Multipart) bodyPart;\r\n        ContentType contentType = new ContentType(mp.getContentType());\r\n        String boundary = \"--\" + contentType.getParameter(\"boundary\");\r\n        LineOutputStream lOut = new LineOutputStream(out);\r\n        for (int i = 0; i < mp.getCount(); i++) {\r\n            lOut.writeln(boundary);\r\n            outputBodyPart(out, mp.getBodyPart(i));\r\n            lOut.writeln();\r\n        }\r\n        lOut.writeln(boundary + \"--\");\r\n        return;\r\n    }\r\n    MimeBodyPart mimePart = (MimeBodyPart) bodyPart;\r\n    if (SMIMEUtil.isMultipartContent(mimePart)) {\r\n        Object content = mimePart.getContent();\r\n        if (content instanceof Multipart) {\r\n            Multipart mp = (Multipart) content;\r\n            ContentType contentType = new ContentType(mp.getContentType());\r\n            String boundary = \"--\" + contentType.getParameter(\"boundary\");\r\n            LineOutputStream lOut = new LineOutputStream(out);\r\n            Enumeration headers = mimePart.getAllHeaderLines();\r\n            while (headers.hasMoreElements()) {\r\n                lOut.writeln((String) headers.nextElement());\r\n            }\r\n            lOut.writeln();\r\n            outputPreamble(lOut, mimePart, boundary);\r\n            outputBodyPart(out, mp);\r\n            return;\r\n        }\r\n    }\r\n    mimePart.writeTo(out);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.modes.NISTCTSBlockCipher.getUpdateOutputSize",
	"Comment": "return the size of the output buffer required for an updatean input of len bytes.",
	"Method": "int getUpdateOutputSize(int len){\r\n    int total = len + bufOff;\r\n    int leftOver = total % buf.length;\r\n    if (leftOver == 0) {\r\n        return total - buf.length;\r\n    }\r\n    return total - leftOver;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.signers.ECGOST3410Signer.generateSignature",
	"Comment": "generate a signature for the given message using the key we wereinitialised with. for conventional gost3410 the message should be a gost3411hash of the message of interest.",
	"Method": "BigInteger[] generateSignature(byte[] message){\r\n    byte[] mRev = new byte[message.length];\r\n    for (int i = 0; i != mRev.length; i++) {\r\n        mRev[i] = message[mRev.length - 1 - i];\r\n    }\r\n    BigInteger e = new BigInteger(1, mRev);\r\n    ECDomainParameters ec = key.getParameters();\r\n    BigInteger n = ec.getN();\r\n    BigInteger d = ((ECPrivateKeyParameters) key).getD();\r\n    BigInteger r, s;\r\n    ECMultiplier basePointMultiplier = createBasePointMultiplier();\r\n    do {\r\n        BigInteger k;\r\n        do {\r\n            do {\r\n                k = BigIntegers.createRandomBigInteger(n.bitLength(), random);\r\n            } while (k.equals(ECConstants.ZERO));\r\n            ECPoint p = basePointMultiplier.multiply(ec.getG(), k).normalize();\r\n            r = p.getAffineXCoord().toBigInteger().mod(n);\r\n        } while (r.equals(ECConstants.ZERO));\r\n        s = (k.multiply(e)).add(d.multiply(r)).mod(n);\r\n    } while (s.equals(ECConstants.ZERO));\r\n    return new BigInteger[] { r, s };\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2Polynomial.upper",
	"Comment": "returns a new gf2polynomial containing the upper k bytes of thisgf2polynomial.",
	"Method": "GF2Polynomial upper(int k){\r\n    int j = Math.min(k, blocks - k);\r\n    GF2Polynomial result = new GF2Polynomial(j << 5);\r\n    if (blocks >= k) {\r\n        System.arraycopy(value, k, result.value, 0, j);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.operator.jcajce.JcePBEKeyEncryptionMethodGenerator.setProvider",
	"Comment": "sets the jce provider to source cryptographic primitives from.",
	"Method": "JcePBEKeyEncryptionMethodGenerator setProvider(Provider provider,JcePBEKeyEncryptionMethodGenerator setProvider,String providerName){\r\n    this.helper = new OperatorHelper(new NamedJcaJceHelper(providerName));\r\n    return this;\r\n}"
}, {
	"Path": "javax.crypto.KeyAgreement.getAlgorithm",
	"Comment": "returns the algorithm name of this keyagreement object.this is the same name that was specified in one of thegetinstance calls that created thiskeyagreement object.",
	"Method": "String getAlgorithm(){\r\n    return algorithm;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.generators.MGF1BytesGenerator.generateBytes",
	"Comment": "fill len bytes of the output buffer with bytes generated fromthe derivation function.",
	"Method": "int generateBytes(byte[] out,int outOff,int len){\r\n    if ((out.length - len) < outOff) {\r\n        throw new OutputLengthException(\"output buffer too small\");\r\n    }\r\n    byte[] hashBuf = new byte[hLen];\r\n    byte[] C = new byte[4];\r\n    int counter = 0;\r\n    digest.reset();\r\n    if (len > hLen) {\r\n        do {\r\n            ItoOSP(counter, C);\r\n            digest.update(seed, 0, seed.length);\r\n            digest.update(C, 0, C.length);\r\n            digest.doFinal(hashBuf, 0);\r\n            System.arraycopy(hashBuf, 0, out, outOff + counter * hLen, hLen);\r\n        } while (++counter < (len / hLen));\r\n    }\r\n    if ((counter * hLen) < len) {\r\n        ItoOSP(counter, C);\r\n        digest.update(seed, 0, seed.length);\r\n        digest.update(C, 0, C.length);\r\n        digest.doFinal(hashBuf, 0);\r\n        System.arraycopy(hashBuf, 0, out, outOff + counter * hLen, len - (counter * hLen));\r\n    }\r\n    return len;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.X509CRLEntryHolder.getExtensions",
	"Comment": "return the extensions block associated with this crl entry if there is one.",
	"Method": "Extensions getExtensions(){\r\n    return entry.getExtensions();\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM.modInverse",
	"Comment": "compute the inverse of this polynomial modulo the given polynomial.",
	"Method": "PolynomialGF2mSmallM modInverse(PolynomialGF2mSmallM a){\r\n    int[] unit = { 1 };\r\n    int[] resultCoeff = modDiv(unit, coefficients, a.coefficients);\r\n    return new PolynomialGF2mSmallM(field, resultCoeff);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.util.OpenSSHPublicKeyUtil.parsePublicKey",
	"Comment": "parse a public key.this method accepts the bytes that are base64 encoded in an openssh public key file.",
	"Method": "AsymmetricKeyParameter parsePublicKey(byte[] encoded,AsymmetricKeyParameter parsePublicKey,SSHBuffer buffer){\r\n    AsymmetricKeyParameter result = null;\r\n    String magic = Strings.fromByteArray(buffer.readString());\r\n    if (RSA.equals(magic)) {\r\n        BigInteger e = buffer.positiveBigNum();\r\n        BigInteger n = buffer.positiveBigNum();\r\n        result = new RSAKeyParameters(false, n, e);\r\n    } else if (DSS.equals(magic)) {\r\n        BigInteger p = buffer.positiveBigNum();\r\n        BigInteger q = buffer.positiveBigNum();\r\n        BigInteger g = buffer.positiveBigNum();\r\n        BigInteger pubKey = buffer.positiveBigNum();\r\n        result = new DSAPublicKeyParameters(pubKey, new DSAParameters(p, q, g));\r\n    } else if (magic.startsWith(ECDSA)) {\r\n        String curveName = Strings.fromByteArray(buffer.readString());\r\n        String nameToFind = curveName;\r\n        if (curveName.startsWith(\"nist\")) {\r\n            nameToFind = curveName.substring(4);\r\n            nameToFind = nameToFind.substring(0, 1) + \"-\" + nameToFind.substring(1);\r\n        }\r\n        X9ECParameters x9ECParameters = ECNamedCurveTable.getByName(nameToFind);\r\n        if (x9ECParameters == null) {\r\n            throw new IllegalStateException(\"unable to find curve for \" + magic + \" using curve name \" + nameToFind);\r\n        }\r\n        ECCurve curve = x9ECParameters.getCurve();\r\n        byte[] pointRaw = buffer.readString();\r\n        result = new ECPublicKeyParameters(curve.decodePoint(pointRaw), new ECDomainParameters(curve, x9ECParameters.getG(), x9ECParameters.getN(), x9ECParameters.getH(), x9ECParameters.getSeed()));\r\n    } else if (magic.startsWith(ED_25519)) {\r\n        result = new Ed25519PublicKeyParameters(buffer.readString(), 0);\r\n    }\r\n    if (result == null) {\r\n        throw new IllegalArgumentException(\"unable to parse key\");\r\n    }\r\n    if (buffer.hasRemaining()) {\r\n        throw new IllegalArgumentException(\"uncoded key has trailing data\");\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.swingset3.codeview.SnippetHighlighter.deinstall",
	"Comment": "called when the ui is being removed from the interface ofa jtextcomponent.",
	"Method": "void deinstall(JTextComponent c){\r\n    component = null;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.macs.MacCFBBlockCipher.processBlock",
	"Comment": "process one block of input from the array in and write it tothe out array.",
	"Method": "int processBlock(byte[] in,int inOff,byte[] out,int outOff){\r\n    if ((inOff + blockSize) > in.length) {\r\n        throw new DataLengthException(\"input buffer too short\");\r\n    }\r\n    if ((outOff + blockSize) > out.length) {\r\n        throw new OutputLengthException(\"output buffer too short\");\r\n    }\r\n    cipher.processBlock(cfbV, 0, cfbOutV, 0);\r\n    for (int i = 0; i < blockSize; i++) {\r\n        out[outOff + i] = (byte) (cfbOutV[i] ^ in[inOff + i]);\r\n    }\r\n    System.arraycopy(cfbV, blockSize, cfbV, 0, cfbV.length - blockSize);\r\n    System.arraycopy(out, outOff, cfbV, cfbV.length - blockSize, blockSize);\r\n    return blockSize;\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPPublicKeyRing.getKeysWithSignaturesBy",
	"Comment": "return any keys carrying a signature issued by the key represented by keyid.",
	"Method": "Iterator getKeysWithSignaturesBy(long keyID){\r\n    List keysWithSigs = new ArrayList();\r\n    for (int i = 0; i != keys.size(); i++) {\r\n        PGPPublicKey k = (PGPPublicKey) keys.get(i);\r\n        Iterator sigIt = k.getSignaturesForKeyID(keyID);\r\n        if (sigIt.hasNext()) {\r\n            keysWithSigs.add(k);\r\n        }\r\n    }\r\n    return keysWithSigs.iterator();\r\n}"
}, {
	"Path": "org.bouncycastle.mail.smime.SMIMEToolkit.isValidSignature",
	"Comment": "return true if there is a signature on the message that can be verified by verifier..",
	"Method": "boolean isValidSignature(Part message,SignerInformationVerifier verifier,boolean isValidSignature,MimeMultipart message,SignerInformationVerifier verifier){\r\n    try {\r\n        SMIMESignedParser s = new SMIMESignedParser(digestCalculatorProvider, message);\r\n        return isAtLeastOneValidSigner(s, verifier);\r\n    } catch (CMSException e) {\r\n        throw new SMIMEException(\"CMS processing failure: \" + e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPUtil.getSignatureName",
	"Comment": "return an appropriate name for the signature algorithm represented by the passedin public key and hash algorithm id numbers.",
	"Method": "String getSignatureName(int keyAlgorithm,int hashAlgorithm){\r\n    String encAlg;\r\n    switch(keyAlgorithm) {\r\n        case PublicKeyAlgorithmTags.RSA_GENERAL:\r\n        case PublicKeyAlgorithmTags.RSA_SIGN:\r\n            encAlg = \"RSA\";\r\n            break;\r\n        case PublicKeyAlgorithmTags.DSA:\r\n            encAlg = \"DSA\";\r\n            break;\r\n        case PublicKeyAlgorithmTags.ELGAMAL_ENCRYPT:\r\n        case PublicKeyAlgorithmTags.ELGAMAL_GENERAL:\r\n            encAlg = \"ElGamal\";\r\n            break;\r\n        default:\r\n            throw new PGPException(\"unknown algorithm tag in signature:\" + keyAlgorithm);\r\n    }\r\n    return getDigestName(hashAlgorithm) + \"with\" + encAlg;\r\n}"
}, {
	"Path": "org.bouncycastle.openssl.X509TrustedCertificateBlock.getTrustBlock",
	"Comment": "return the trust block associated with this trusted certificate",
	"Method": "CertificateTrustBlock getTrustBlock(){\r\n    return trustBlock;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.BigEndianConversions.OS2IP",
	"Comment": "convert an octet string to an integer according to ieee 1363, section5.5.3.",
	"Method": "int OS2IP(byte[] input,int OS2IP,byte[] input,int inOff,int OS2IP,byte[] input,int inOff,int inLen){\r\n    if ((input.length == 0) || input.length < inOff + inLen - 1) {\r\n        return 0;\r\n    }\r\n    int result = 0;\r\n    for (int j = 0; j < inLen; j++) {\r\n        result |= (input[inOff + j] & 0xff) << (8 * (inLen - j - 1));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.bouncycastle.tsp.cms.CMSTimeStampedData.addTimeStamp",
	"Comment": "return a new timestampeddata object with the additional token attached.",
	"Method": "CMSTimeStampedData addTimeStamp(TimeStampToken token){\r\n    TimeStampAndCRL[] timeStamps = util.getTimeStamps();\r\n    TimeStampAndCRL[] newTimeStamps = new TimeStampAndCRL[timeStamps.length + 1];\r\n    System.arraycopy(timeStamps, 0, newTimeStamps, 0, timeStamps.length);\r\n    newTimeStamps[timeStamps.length] = new TimeStampAndCRL(token.toCMSSignedData().toASN1Structure());\r\n    return new CMSTimeStampedData(new ContentInfo(CMSObjectIdentifiers.timestampedData, new TimeStampedData(timeStampedData.getDataUri(), timeStampedData.getMetaData(), timeStampedData.getContent(), new Evidence(new TimeStampTokenEvidence(newTimeStamps)))));\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.x9.X9IntegerConverter.integerToBytes",
	"Comment": "convert an integer to a byte array, ensuring it is exactly qlength long.",
	"Method": "byte[] integerToBytes(BigInteger s,int qLength){\r\n    byte[] bytes = s.toByteArray();\r\n    if (qLength < bytes.length) {\r\n        byte[] tmp = new byte[qLength];\r\n        System.arraycopy(bytes, bytes.length - tmp.length, tmp, 0, tmp.length);\r\n        return tmp;\r\n    } else if (qLength > bytes.length) {\r\n        byte[] tmp = new byte[qLength];\r\n        System.arraycopy(bytes, 0, tmp, tmp.length - bytes.length, bytes.length);\r\n        return tmp;\r\n    }\r\n    return bytes;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.x509.ExtendedKeyUsage.hasKeyPurposeId",
	"Comment": "return true if this extendedkeyusage object contains the passed in keypurposeid.",
	"Method": "boolean hasKeyPurposeId(KeyPurposeId keyPurposeId){\r\n    return (usageTable.get(keyPurposeId) != null);\r\n}"
}, {
	"Path": "org.bouncycastle.i18n.MessageBundle.getTitle",
	"Comment": "returns the title message in the given locale and the default timezone.",
	"Method": "String getTitle(Locale loc,TimeZone timezone,String getTitle,Locale loc){\r\n    return getEntry(TITLE_ENTRY, loc, TimeZone.getDefault());\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.IntegerFunctions.ceilLog",
	"Comment": "compute the smallest integer that is greater than or equal to thelogarithm to the base 2 of the given integer.",
	"Method": "int ceilLog(BigInteger a,int ceilLog,int a){\r\n    int log = 0;\r\n    int i = 1;\r\n    while (i < a) {\r\n        i <<= 1;\r\n        log++;\r\n    }\r\n    return log;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.util.PrivateKeyInfoFactory.createPrivateKeyInfo",
	"Comment": "create a privatekeyinfo representation of a private key with attributes.",
	"Method": "PrivateKeyInfo createPrivateKeyInfo(AsymmetricKeyParameter privateKey,PrivateKeyInfo createPrivateKeyInfo,AsymmetricKeyParameter privateKey,ASN1Set attributes){\r\n    if (privateKey instanceof RSAKeyParameters) {\r\n        RSAPrivateCrtKeyParameters priv = (RSAPrivateCrtKeyParameters) privateKey;\r\n        return new PrivateKeyInfo(new AlgorithmIdentifier(PKCSObjectIdentifiers.rsaEncryption, DERNull.INSTANCE), new RSAPrivateKey(priv.getModulus(), priv.getPublicExponent(), priv.getExponent(), priv.getP(), priv.getQ(), priv.getDP(), priv.getDQ(), priv.getQInv()), attributes);\r\n    } else if (privateKey instanceof DSAPrivateKeyParameters) {\r\n        DSAPrivateKeyParameters priv = (DSAPrivateKeyParameters) privateKey;\r\n        DSAParameters params = priv.getParameters();\r\n        return new PrivateKeyInfo(new AlgorithmIdentifier(X9ObjectIdentifiers.id_dsa, new DSAParameter(params.getP(), params.getQ(), params.getG())), new ASN1Integer(priv.getX()), attributes);\r\n    } else if (privateKey instanceof ECPrivateKeyParameters) {\r\n        ECPrivateKeyParameters priv = (ECPrivateKeyParameters) privateKey;\r\n        ECDomainParameters domainParams = priv.getParameters();\r\n        ASN1Encodable params;\r\n        int orderBitLength;\r\n        if (domainParams == null) {\r\n            params = new X962Parameters(DERNull.INSTANCE);\r\n            orderBitLength = priv.getD().bitLength();\r\n        } else if (domainParams instanceof ECNamedDomainParameters) {\r\n            params = new X962Parameters(((ECNamedDomainParameters) domainParams).getName());\r\n            orderBitLength = domainParams.getN().bitLength();\r\n        } else {\r\n            X9ECParameters ecP = new X9ECParameters(domainParams.getCurve(), domainParams.getG(), domainParams.getN(), domainParams.getH(), domainParams.getSeed());\r\n            params = new X962Parameters(ecP);\r\n            orderBitLength = domainParams.getN().bitLength();\r\n        }\r\n        return new PrivateKeyInfo(new AlgorithmIdentifier(X9ObjectIdentifiers.id_ecPublicKey, params), new ECPrivateKey(orderBitLength, priv.getD(), new DERBitString(domainParams.getG().multiply(priv.getD()).getEncoded(false)), params), attributes);\r\n    } else if (privateKey instanceof X448PrivateKeyParameters) {\r\n        X448PrivateKeyParameters key = (X448PrivateKeyParameters) privateKey;\r\n        return new PrivateKeyInfo(new AlgorithmIdentifier(EdECObjectIdentifiers.id_X448), new DEROctetString(key.getEncoded()), attributes, key.generatePublicKey().getEncoded());\r\n    } else if (privateKey instanceof X25519PrivateKeyParameters) {\r\n        X25519PrivateKeyParameters key = (X25519PrivateKeyParameters) privateKey;\r\n        return new PrivateKeyInfo(new AlgorithmIdentifier(EdECObjectIdentifiers.id_X25519), new DEROctetString(key.getEncoded()), attributes, key.generatePublicKey().getEncoded());\r\n    } else if (privateKey instanceof Ed448PrivateKeyParameters) {\r\n        Ed448PrivateKeyParameters key = (Ed448PrivateKeyParameters) privateKey;\r\n        return new PrivateKeyInfo(new AlgorithmIdentifier(EdECObjectIdentifiers.id_Ed448), new DEROctetString(key.getEncoded()), attributes, key.generatePublicKey().getEncoded());\r\n    } else if (privateKey instanceof Ed25519PrivateKeyParameters) {\r\n        Ed25519PrivateKeyParameters key = (Ed25519PrivateKeyParameters) privateKey;\r\n        return new PrivateKeyInfo(new AlgorithmIdentifier(EdECObjectIdentifiers.id_Ed25519), new DEROctetString(key.getEncoded()), attributes, key.generatePublicKey().getEncoded());\r\n    } else {\r\n        throw new IOException(\"key parameters not recognised.\");\r\n    }\r\n}"
}, {
	"Path": "javax.crypto.Cipher.getParameters",
	"Comment": "returns the parameters used with this cipher.the returned parameters may be the same that were used to initializethis cipher, or may contain a combination of default and randomparameter values used by the underlying cipher implementation if thiscipher requires algorithm parameters but was not initialized with any.",
	"Method": "AlgorithmParameters getParameters(){\r\n    return cipherSpi.engineGetParameters();\r\n}"
}, {
	"Path": "org.bouncycastle.cms.jcajce.JcaSignerInfoGeneratorBuilder.setDirectSignature",
	"Comment": "if the passed in flag is true, the signer signature will be based on the data, nota collection of signed attributes, and no signed attributes will be included.",
	"Method": "JcaSignerInfoGeneratorBuilder setDirectSignature(boolean hasNoSignedAttributes){\r\n    builder.setDirectSignature(hasNoSignedAttributes);\r\n    return this;\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.BCFKSLoadStoreParameter.getStorePBKDFConfig",
	"Comment": "return the pbkdf used for generating the hmac and store encryption keys.",
	"Method": "PBKDFConfig getStorePBKDFConfig(){\r\n    return storeConfig;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.generators.OpenSSLPBEParametersGenerator.generateDerivedMacParameters",
	"Comment": "generate a key parameter for use with a mac derived from the password,salt, and iteration count we are currently initialised with.",
	"Method": "CipherParameters generateDerivedMacParameters(int keySize){\r\n    return generateDerivedParameters(keySize);\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.ch1_titlepane.BERootPaneUI.createTitlePane",
	"Comment": "returns the jcomponent to render the window decoration\tstyle.",
	"Method": "JComponent createTitlePane(JRootPane root){\r\n    return new BETitlePane(root, this);\r\n}"
}, {
	"Path": "com.sun.swingset3.demos.spinner.JMandelbrot.calculatePicture",
	"Comment": "use swingworker to asynchronously calculate parts of the picture",
	"Method": "void calculatePicture(){\r\n    int yStep = getHeight() / NUM_OF_THREADS;\r\n    int yStart = 0;\r\n    for (int i = 0; i < calculators.length; i++) {\r\n        if ((calculators[i] != null) && !calculators[i].isDone()) {\r\n            calculators[i].cancel(true);\r\n        }\r\n        int yEnd = i == calculators.length - 1 ? getHeight() : yStart + yStep;\r\n        calculators[i] = new MandelbrotCalculator(yStart, yEnd);\r\n        calculators[i].execute();\r\n        yStart = yEnd;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.ASN1ObjectIdentifier.on",
	"Comment": "returntrue if this oid is an extension of the passed in branch, stem.",
	"Method": "boolean on(ASN1ObjectIdentifier stem){\r\n    String id = getId(), stemId = stem.getId();\r\n    return id.length() > stemId.length() && id.charAt(stemId.length()) == '.' && id.startsWith(stemId);\r\n}"
}, {
	"Path": "org.bouncycastle.est.ESTService.handleEnrollResponse",
	"Comment": "handles the enroll response, deals with status codes and setting of delays.",
	"Method": "EnrollmentResponse handleEnrollResponse(ESTResponse resp){\r\n    ESTRequest req = resp.getOriginalRequest();\r\n    Store<X509CertificateHolder> enrolled = null;\r\n    if (resp.getStatusCode() == 202) {\r\n        String rt = resp.getHeader(\"Retry-After\");\r\n        if (rt == null) {\r\n            throw new ESTException(\"Got Status 202 but not Retry-After header from: \" + req.getURL().toString());\r\n        }\r\n        long notBefore = -1;\r\n        try {\r\n            notBefore = System.currentTimeMillis() + (Long.parseLong(rt) * 1000);\r\n        } catch (NumberFormatException nfe) {\r\n            try {\r\n                SimpleDateFormat dateFormat = new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss z\", Locale.US);\r\n                dateFormat.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\r\n                notBefore = dateFormat.parse(rt).getTime();\r\n            } catch (Exception ex) {\r\n                throw new ESTException(\"Unable to parse Retry-After header:\" + req.getURL().toString() + \" \" + ex.getMessage(), null, resp.getStatusCode(), resp.getInputStream());\r\n            }\r\n        }\r\n        return new EnrollmentResponse(null, notBefore, req, resp.getSource());\r\n    } else if (resp.getStatusCode() == 200) {\r\n        ASN1InputStream ain = new ASN1InputStream(resp.getInputStream());\r\n        SimplePKIResponse spkr = null;\r\n        try {\r\n            spkr = new SimplePKIResponse(ContentInfo.getInstance(ain.readObject()));\r\n        } catch (CMCException e) {\r\n            throw new ESTException(e.getMessage(), e.getCause());\r\n        }\r\n        enrolled = spkr.getCertificates();\r\n        return new EnrollmentResponse(enrolled, -1, null, resp.getSource());\r\n    }\r\n    throw new ESTException(\"Simple Enroll: \" + req.getURL().toString(), null, resp.getStatusCode(), resp.getInputStream());\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.ntru.polynomial.BigIntPolynomial.clone",
	"Comment": "makes a copy of the polynomial that is independent of the original.",
	"Method": "Object clone(){\r\n    return new BigIntPolynomial(coeffs.clone());\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.provider.asymmetric.dstu.BCDSTU4145PrivateKey.getEncoded",
	"Comment": "return a pkcs8 representation of the key. the sequence returnedrepresents a full privatekeyinfo object.",
	"Method": "byte[] getEncoded(){\r\n    X962Parameters params;\r\n    int orderBitLength;\r\n    if (ecSpec instanceof ECNamedCurveSpec) {\r\n        ASN1ObjectIdentifier curveOid = ECUtil.getNamedCurveOid(((ECNamedCurveSpec) ecSpec).getName());\r\n        if (curveOid == null) {\r\n            curveOid = new ASN1ObjectIdentifier(((ECNamedCurveSpec) ecSpec).getName());\r\n        }\r\n        params = new X962Parameters(curveOid);\r\n        orderBitLength = ECUtil.getOrderBitLength(BouncyCastleProvider.CONFIGURATION, ecSpec.getOrder(), this.getS());\r\n    } else if (ecSpec == null) {\r\n        params = new X962Parameters(DERNull.INSTANCE);\r\n        orderBitLength = ECUtil.getOrderBitLength(BouncyCastleProvider.CONFIGURATION, null, this.getS());\r\n    } else {\r\n        ECCurve curve = EC5Util.convertCurve(ecSpec.getCurve());\r\n        X9ECParameters ecP = new X9ECParameters(curve, EC5Util.convertPoint(curve, ecSpec.getGenerator(), withCompression), ecSpec.getOrder(), BigInteger.valueOf(ecSpec.getCofactor()), ecSpec.getCurve().getSeed());\r\n        params = new X962Parameters(ecP);\r\n        orderBitLength = ECUtil.getOrderBitLength(BouncyCastleProvider.CONFIGURATION, ecSpec.getOrder(), this.getS());\r\n    }\r\n    PrivateKeyInfo info;\r\n    org.bouncycastle.asn1.sec.ECPrivateKey keyStructure;\r\n    if (publicKey != null) {\r\n        keyStructure = new org.bouncycastle.asn1.sec.ECPrivateKey(orderBitLength, this.getS(), publicKey, params);\r\n    } else {\r\n        keyStructure = new org.bouncycastle.asn1.sec.ECPrivateKey(orderBitLength, this.getS(), params);\r\n    }\r\n    try {\r\n        if (algorithm.equals(\"DSTU4145\")) {\r\n            info = new PrivateKeyInfo(new AlgorithmIdentifier(UAObjectIdentifiers.dstu4145be, params.toASN1Primitive()), keyStructure.toASN1Primitive());\r\n        } else {\r\n            info = new PrivateKeyInfo(new AlgorithmIdentifier(X9ObjectIdentifiers.id_ecPublicKey, params.toASN1Primitive()), keyStructure.toASN1Primitive());\r\n        }\r\n        return info.getEncoded(ASN1Encoding.DER);\r\n    } catch (IOException e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSSignedDataParser.getSignerInfos",
	"Comment": "return the collection of signers that are associated with thesignatures for the message.",
	"Method": "SignerInformationStore getSignerInfos(){\r\n    if (_signerInfoStore == null) {\r\n        populateCertCrlSets();\r\n        List signerInfos = new ArrayList();\r\n        Map hashes = new HashMap();\r\n        Iterator it = digests.keySet().iterator();\r\n        while (it.hasNext()) {\r\n            Object digestKey = it.next();\r\n            hashes.put(digestKey, ((DigestCalculator) digests.get(digestKey)).getDigest());\r\n        }\r\n        try {\r\n            ASN1SetParser s = _signedData.getSignerInfos();\r\n            ASN1Encodable o;\r\n            while ((o = s.readObject()) != null) {\r\n                SignerInfo info = SignerInfo.getInstance(o.toASN1Primitive());\r\n                byte[] hash = (byte[]) hashes.get(info.getDigestAlgorithm().getAlgorithm());\r\n                signerInfos.add(new SignerInformation(info, _signedContentType, null, hash));\r\n            }\r\n        } catch (IOException e) {\r\n            throw new CMSException(\"io exception: \" + e.getMessage(), e);\r\n        }\r\n        _signerInfoStore = new SignerInformationStore(signerInfos);\r\n    }\r\n    return _signerInfoStore;\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.provider.asymmetric.util.DESUtil.setOddParity",
	"Comment": "des keys use the lsb as the odd parity bit.this canbe used to check for corrupt keys.",
	"Method": "void setOddParity(byte[] bytes){\r\n    for (int i = 0; i < bytes.length; i++) {\r\n        int b = bytes[i];\r\n        bytes[i] = (byte) ((b & 0xfe) | ((((b >> 1) ^ (b >> 2) ^ (b >> 3) ^ (b >> 4) ^ (b >> 5) ^ (b >> 6) ^ (b >> 7)) ^ 0x01) & 0x01));\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.tls.crypto.impl.jcajce.srp.SRP6Server.calculateSessionKey",
	"Comment": "computes the final session key as a result of the srp successful mutual authentication\tto be called after calculating the server evidence message m2.",
	"Method": "BigInteger calculateSessionKey(){\r\n    if (this.S == null || this.M1 == null || this.M2 == null) {\r\n        throw new IllegalStateException(\"Impossible to compute Key: \" + \"some data are missing from the previous operations (S,M1,M2)\");\r\n    }\r\n    this.Key = SRP6Util.calculateKey(digest, N, S);\r\n    return Key;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.prng.EntropyUtil.generateSeed",
	"Comment": "generate numbytes worth of entropy from the passed in entropy source.",
	"Method": "byte[] generateSeed(EntropySource entropySource,int numBytes){\r\n    byte[] bytes = new byte[numBytes];\r\n    if (numBytes * 8 <= entropySource.entropySize()) {\r\n        byte[] ent = entropySource.getEntropy();\r\n        System.arraycopy(ent, 0, bytes, 0, bytes.length);\r\n    } else {\r\n        int entSize = entropySource.entropySize() / 8;\r\n        for (int i = 0; i < bytes.length; i += entSize) {\r\n            byte[] ent = entropySource.getEntropy();\r\n            if (ent.length <= bytes.length - i) {\r\n                System.arraycopy(ent, 0, bytes, i, ent.length);\r\n            } else {\r\n                System.arraycopy(ent, 0, bytes, i, bytes.length - i);\r\n            }\r\n        }\r\n    }\r\n    return bytes;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM.addMonomial",
	"Comment": "compute the sum of this polynomial and the monomial of the given degree.",
	"Method": "PolynomialGF2mSmallM addMonomial(int degree){\r\n    int[] monomial = new int[degree + 1];\r\n    monomial[degree] = 1;\r\n    int[] resultCoeff = add(coefficients, monomial);\r\n    return new PolynomialGF2mSmallM(field, resultCoeff);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.generators.BCrypt.passwordToByteArray",
	"Comment": "converts a character password to bytes incorporating the required trailing zero byte.",
	"Method": "byte[] passwordToByteArray(char[] password){\r\n    return Arrays.append(Strings.toUTF8ByteArray(password), (byte) 0);\r\n}"
}, {
	"Path": "javax.crypto.CipherInputStream.skip",
	"Comment": "skips n bytes of input from the bytes that can be readfrom this input stream without blocking.fewer bytes than requested might be skipped.the actual number of bytes skipped is equal to n orthe result of a call to available,whichever is smaller.if n is less than zero, no bytes are skipped.the actual number of bytes skipped is returned.",
	"Method": "long skip(long n){\r\n    if (n <= 0) {\r\n        return 0;\r\n    }\r\n    int available = maxBuf - bufOff;\r\n    if (n > available) {\r\n        bufOff = maxBuf;\r\n        return available;\r\n    } else {\r\n        bufOff += (int) n;\r\n        return (int) n;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.paddings.ZeroBytePadding.addPadding",
	"Comment": "add the pad bytes to the passed in block, returning thenumber of bytes added.",
	"Method": "int addPadding(byte[] in,int inOff){\r\n    int added = (in.length - inOff);\r\n    while (inOff < in.length) {\r\n        in[inOff] = (byte) 0;\r\n        inOff++;\r\n    }\r\n    return added;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.spec.OpenSSHPrivateKeySpec.getFormat",
	"Comment": "return the format, either openssh for the openssh propriety format or asn.1.",
	"Method": "String getFormat(){\r\n    return format;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.gmss.util.GMSSUtil.getLog",
	"Comment": "this method returns the least integer that is greater or equal to thelogarithm to the base 2 of an integer intvalue.",
	"Method": "int getLog(int intValue){\r\n    int log = 1;\r\n    int i = 2;\r\n    while (i < intValue) {\r\n        i <<= 1;\r\n        log++;\r\n    }\r\n    return log;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.ec.CustomNamedCurves.getOID",
	"Comment": "return the object identifier signified by the passed in name. null if there is no objectidentifier associated with name.",
	"Method": "ASN1ObjectIdentifier getOID(String name){\r\n    return (ASN1ObjectIdentifier) nameToOID.get(Strings.toLowerCase(name));\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.PolynomialRingGF2m.computeSquaringMatrix",
	"Comment": "compute the squaring matrix for this polynomial ring, using the basefield and the reduction polynomial.",
	"Method": "void computeSquaringMatrix(){\r\n    int numColumns = p.getDegree();\r\n    sqMatrix = new PolynomialGF2mSmallM[numColumns];\r\n    for (int i = 0; i < numColumns >> 1; i++) {\r\n        int[] monomCoeffs = new int[(i << 1) + 1];\r\n        monomCoeffs[i << 1] = 1;\r\n        sqMatrix[i] = new PolynomialGF2mSmallM(field, monomCoeffs);\r\n    }\r\n    for (int i = numColumns >> 1; i < numColumns; i++) {\r\n        int[] monomCoeffs = new int[(i << 1) + 1];\r\n        monomCoeffs[i << 1] = 1;\r\n        PolynomialGF2mSmallM monomial = new PolynomialGF2mSmallM(field, monomCoeffs);\r\n        sqMatrix[i] = monomial.mod(p);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.ntru.polynomial.BigIntPolynomial.sub",
	"Comment": "subtracts another polynomial which can have a different number of coefficients.",
	"Method": "void sub(BigIntPolynomial b){\r\n    if (b.coeffs.length > coeffs.length) {\r\n        int N = coeffs.length;\r\n        coeffs = Arrays.copyOf(coeffs, b.coeffs.length);\r\n        for (int i = N; i < coeffs.length; i++) {\r\n            coeffs[i] = Constants.BIGINT_ZERO;\r\n        }\r\n    }\r\n    for (int i = 0; i < b.coeffs.length; i++) {\r\n        coeffs[i] = coeffs[i].subtract(b.coeffs[i]);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.CertStore.getCertStoreParameters",
	"Comment": "returns the parameters used to initialize this certstore.note that the certstoreparameters object is cloned beforeit is returned.",
	"Method": "CertStoreParameters getCertStoreParameters(){\r\n    return params;\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.operator.jcajce.JcePublicKeyDataDecryptorFactoryBuilder.setProvider",
	"Comment": "set the provider name to use for creating cryptographic primitives in the resulting factory the builder produces.",
	"Method": "JcePublicKeyDataDecryptorFactoryBuilder setProvider(Provider provider,JcePublicKeyDataDecryptorFactoryBuilder setProvider,String providerName){\r\n    this.helper = new OperatorHelper(new NamedJcaJceHelper(providerName));\r\n    keyConverter.setProvider(providerName);\r\n    this.contentHelper = helper;\r\n    return this;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.x9.ECNamedCurveTable.getName",
	"Comment": "return a x9ecparameters object representing the passed in namedcurve.",
	"Method": "String getName(ASN1ObjectIdentifier oid){\r\n    String name = X962NamedCurves.getName(oid);\r\n    if (name == null) {\r\n        name = SECNamedCurves.getName(oid);\r\n    }\r\n    if (name == null) {\r\n        name = NISTNamedCurves.getName(oid);\r\n    }\r\n    if (name == null) {\r\n        name = TeleTrusTNamedCurves.getName(oid);\r\n    }\r\n    if (name == null) {\r\n        name = ANSSINamedCurves.getName(oid);\r\n    }\r\n    if (name == null) {\r\n        name = ECGOST3410NamedCurves.getName(oid);\r\n    }\r\n    if (name == null) {\r\n        name = GMNamedCurves.getName(oid);\r\n    }\r\n    return name;\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPPublicKey.getSignaturesForKeyID",
	"Comment": "return any signatures associated with the passed in key identifier keyid.",
	"Method": "Iterator getSignaturesForKeyID(long keyID){\r\n    List sigs = new ArrayList();\r\n    for (Iterator it = getSignatures(); it.hasNext(); ) {\r\n        PGPSignature sig = (PGPSignature) it.next();\r\n        if (sig.getKeyID() == keyID) {\r\n            sigs.add(sig);\r\n        }\r\n    }\r\n    return sigs.iterator();\r\n}"
}, {
	"Path": "org.bouncycastle.jce.spec.IESParameterSpec.getCipherKeySize",
	"Comment": "return the key size in bits for the block cipher used with the message",
	"Method": "int getCipherKeySize(){\r\n    return cipherKeySize;\r\n}"
}, {
	"Path": "org.bimserver.BimServer.activateServices",
	"Comment": "load all users from the database and their configured services. registers each service.",
	"Method": "void activateServices(){\r\n    try (DatabaseSession session = bimDatabase.createSession()) {\r\n        IfcModelInterface allOfType = session.getAllOfType(StorePackage.eINSTANCE.getUser(), OldQuery.getDefault());\r\n        for (User user : allOfType.getAll(User.class)) {\r\n            updateUserSettings(session, user);\r\n            UserSettings userSettings = user.getUserSettings();\r\n            for (InternalServicePluginConfiguration internalServicePluginConfiguration : userSettings.getServices()) {\r\n                activateService(user.getOid(), internalServicePluginConfiguration);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.x509.ExtendedPKIXBuilderParameters.setExcludedCerts",
	"Comment": "sets the excluded certificates which are not used for building acertification path. if the set is null anempty set is assumed.the given set is cloned to protect it against subsequent modifications.",
	"Method": "void setExcludedCerts(Set excludedCerts){\r\n    if (excludedCerts == null) {\r\n        excludedCerts = Collections.EMPTY_SET;\r\n    } else {\r\n        this.excludedCerts = new HashSet(excludedCerts);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.gmss.Treehash.getStatInt",
	"Comment": "returns the status int array used by the gmssprivatekeyasn.1 class",
	"Method": "int[] getStatInt(){\r\n    int[] statInt = new int[6 + tailLength];\r\n    statInt[0] = maxHeight;\r\n    statInt[1] = tailLength;\r\n    statInt[2] = firstNodeHeight;\r\n    if (this.isFinished) {\r\n        statInt[3] = 1;\r\n    } else {\r\n        statInt[3] = 0;\r\n    }\r\n    if (this.isInitialized) {\r\n        statInt[4] = 1;\r\n    } else {\r\n        statInt[4] = 0;\r\n    }\r\n    if (this.seedInitialized) {\r\n        statInt[5] = 1;\r\n    } else {\r\n        statInt[5] = 0;\r\n    }\r\n    for (int i = 0; i < tailLength; i++) {\r\n        statInt[6 + i] = ((Integer) heightOfNodes.elementAt(i)).intValue();\r\n    }\r\n    return statInt;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.agreement.srp.SRP6Client.calculateSessionKey",
	"Comment": "computes the final session key as a result of the srp successful mutual authentication\tto be called after verifying the server evidence message m2.",
	"Method": "BigInteger calculateSessionKey(){\r\n    if (this.S == null || this.M1 == null || this.M2 == null) {\r\n        throw new CryptoException(\"Impossible to compute Key: \" + \"some data are missing from the previous operations (S,M1,M2)\");\r\n    }\r\n    this.Key = SRP6Util.calculateKey(digest, N, S);\r\n    return Key;\r\n}"
}, {
	"Path": "org.bouncycastle.eac.EACCertificateRequestHolder.toASN1Structure",
	"Comment": "return the underlying asn.1 structure for the certificate in this holder.",
	"Method": "CVCertificateRequest toASN1Structure(){\r\n    return request;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.dane.DANEEntryStore.toCertificateStore",
	"Comment": "return a store of x509certificateholder objects representing all the certificates associated withentries in the store.",
	"Method": "Store toCertificateStore(){\r\n    Collection col = this.getMatches(null);\r\n    List certColl = new ArrayList(col.size());\r\n    for (Iterator it = col.iterator(); it.hasNext(); ) {\r\n        DANEEntry entry = (DANEEntry) it.next();\r\n        certColl.add(entry.getCertificate());\r\n    }\r\n    return new CollectionStore(certColl);\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.X509CertSelector.setKeyUsage",
	"Comment": "sets the keyusage criterion. the x509certificate must allow the specifiedkeyusage values. if null, no keyusage check will be done. note that anx509certificate that has no keyusage extension implicitly allows allkeyusage values.note that the boolean array supplied here is cloned to protect againstsubsequent modifications.",
	"Method": "void setKeyUsage(boolean[] keyUsage){\r\n    if (keyUsage == null) {\r\n        this.keyUsage = null;\r\n    } else {\r\n        this.keyUsage = (boolean[]) keyUsage.clone();\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.util.encoders.Hex.encode",
	"Comment": "hex encode the byte data writing it to the given output stream.",
	"Method": "byte[] encode(byte[] data,byte[] encode,byte[] data,int off,int length,int encode,byte[] data,OutputStream out,int encode,byte[] data,int off,int length,OutputStream out){\r\n    return encoder.encode(data, off, length, out);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.modes.PGPCFBBlockCipher.processBlock",
	"Comment": "process one block of input from the array in and write it tothe out array.",
	"Method": "int processBlock(byte[] in,int inOff,byte[] out,int outOff){\r\n    if (inlineIv) {\r\n        return (forEncryption) ? encryptBlockWithIV(in, inOff, out, outOff) : decryptBlockWithIV(in, inOff, out, outOff);\r\n    } else {\r\n        return (forEncryption) ? encryptBlock(in, inOff, out, outOff) : decryptBlock(in, inOff, out, outOff);\r\n    }\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.setCertificateValid",
	"Comment": "sets the certificatevalid criterion. the specified date must fall withinthe certificate validity period for the x509certificate. ifnull, no certificatevalid check will be done.note that the date supplied here is cloned to protect against subsequentmodifications.",
	"Method": "void setCertificateValid(Date certValid){\r\n    if (certValid == null) {\r\n        this.certValid = null;\r\n    } else {\r\n        this.certValid = new Date(certValid.getTime());\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.examples.PGPExampleUtil.readSecretKey",
	"Comment": "a simple routine that opens a key ring file and loads the first available keysuitable for signature generation.",
	"Method": "PGPSecretKey readSecretKey(String fileName,PGPSecretKey readSecretKey,InputStream input){\r\n    PGPSecretKeyRingCollection pgpSec = new PGPSecretKeyRingCollection(PGPUtil.getDecoderStream(input), new JcaKeyFingerprintCalculator());\r\n    Iterator keyRingIter = pgpSec.getKeyRings();\r\n    while (keyRingIter.hasNext()) {\r\n        PGPSecretKeyRing keyRing = (PGPSecretKeyRing) keyRingIter.next();\r\n        Iterator keyIter = keyRing.getSecretKeys();\r\n        while (keyIter.hasNext()) {\r\n            PGPSecretKey key = (PGPSecretKey) keyIter.next();\r\n            if (key.isSigningKey()) {\r\n                return key;\r\n            }\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(\"Can't find signing key in key ring.\");\r\n}"
}, {
	"Path": "org.bouncycastle.cert.selector.X509AttributeCertificateHolderSelectorBuilder.addTargetName",
	"Comment": "adds a target name criterion for the attribute certificate to the targetinformation extension criteria. the x509attributecertificateholdermust contain at least one of the specified target names.each attribute certificate may contain a target information extensionlimiting the servers where this attribute certificate can be used. ifthis extension is not present, the attribute certificate is not targetedand may be accepted by any server.",
	"Method": "void addTargetName(GeneralName name){\r\n    targetNames.add(name);\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPSecretKeyRing.removeSecretKey",
	"Comment": "returns a new key ring with the secret key passed in removed from thekey ring.",
	"Method": "PGPSecretKeyRing removeSecretKey(PGPSecretKeyRing secRing,PGPSecretKey secKey){\r\n    List keys = new ArrayList(secRing.keys);\r\n    boolean found = false;\r\n    for (int i = 0; i < keys.size(); i++) {\r\n        PGPSecretKey key = (PGPSecretKey) keys.get(i);\r\n        if (key.getKeyID() == secKey.getKeyID()) {\r\n            found = true;\r\n            keys.remove(i);\r\n        }\r\n    }\r\n    if (!found) {\r\n        return null;\r\n    }\r\n    return new PGPSecretKeyRing(keys, secRing.extraPubKeys);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.commitments.HashCommitter.isRevealed",
	"Comment": "return true if the passed in commitment represents a commitment to the passed in message.",
	"Method": "boolean isRevealed(Commitment commitment,byte[] message){\r\n    if (message.length + commitment.getSecret().length != byteLength) {\r\n        throw new DataLengthException(\"Message and witness secret lengths do not match.\");\r\n    }\r\n    byte[] calcCommitment = calculateCommitment(commitment.getSecret(), message);\r\n    return Arrays.constantTimeAreEqual(commitment.getCommitment(), calcCommitment);\r\n}"
}, {
	"Path": "org.bouncycastle.util.encoders.HexEncoder.decode",
	"Comment": "decode the hex encoded string data writing it to the given output stream,whitespace characters will be ignored.",
	"Method": "int decode(byte[] data,int off,int length,OutputStream out,int decode,String data,OutputStream out){\r\n    byte b1, b2;\r\n    int length = 0;\r\n    int end = data.length();\r\n    while (end > 0) {\r\n        if (!ignore(data.charAt(end - 1))) {\r\n            break;\r\n        }\r\n        end--;\r\n    }\r\n    int i = 0;\r\n    while (i < end) {\r\n        while (i < end && ignore(data.charAt(i))) {\r\n            i++;\r\n        }\r\n        b1 = decodingTable[data.charAt(i++)];\r\n        while (i < end && ignore(data.charAt(i))) {\r\n            i++;\r\n        }\r\n        b2 = decodingTable[data.charAt(i++)];\r\n        if ((b1 | b2) < 0) {\r\n            throw new IOException(\"invalid characters encountered in Hex string\");\r\n        }\r\n        out.write((b1 << 4) | b2);\r\n        length++;\r\n    }\r\n    return length;\r\n}"
}, {
	"Path": "org.bouncycastle.x509.ExtendedPKIXBuilderParameters.clone",
	"Comment": "makes a copy of this pkixparameters object. changes to thecopy will not affect the original and vice versa.",
	"Method": "Object clone(){\r\n    ExtendedPKIXBuilderParameters params = null;\r\n    try {\r\n        params = new ExtendedPKIXBuilderParameters(getTrustAnchors(), getTargetConstraints());\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e.getMessage());\r\n    }\r\n    params.setParams(this);\r\n    return params;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.DERSequenceParser.toASN1Primitive",
	"Comment": "return a dersequence representing this parser and its contents.",
	"Method": "ASN1Primitive toASN1Primitive(){\r\n    try {\r\n        return getLoadedObject();\r\n    } catch (IOException e) {\r\n        throw new IllegalStateException(e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.test.est.TestGetCSRAttrs.testFetchCSRAttributes",
	"Comment": "test the fetching of csrattributes.this test confirms it is possible to fetch attributes and that we get an attribute back.variation on authentication is verified in other tests.",
	"Method": "void testFetchCSRAttributes(){\r\n    ESTTestUtils.ensureProvider();\r\n    X509CertificateHolder[] theirCAs = null;\r\n    ESTServerUtils.ServerInstance serverInstance = null;\r\n    try {\r\n        serverInstance = startDefaultServer();\r\n        ESTService est = new JsseESTServiceBuilder(\"localhost:8443\", JcaJceUtils.getCertPathTrustManager(ESTTestUtils.toTrustAnchor(ESTTestUtils.readPemCertificate(ESTServerUtils.makeRelativeToServerHome(\"/estCA/cacert.crt\"))), null)).build();\r\n        CSRRequestResponse csrRequestResponse = est.getCSRAttributes();\r\n        Assert.assertEquals(1, csrRequestResponse.getAttributesResponse().getRequirements().size());\r\n        Assert.assertTrue(\"Must have: \", csrRequestResponse.getAttributesResponse().hasRequirement(new ASN1ObjectIdentifier(\"1.2.3.4\")));\r\n    } finally {\r\n        if (serverInstance != null) {\r\n            serverInstance.getServer().stop_server();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM.getEncoded",
	"Comment": "returns encoded polynomial, i.e., this polynomial in byte array form",
	"Method": "byte[] getEncoded(){\r\n    int d = 8;\r\n    int count = 1;\r\n    while (field.getDegree() > d) {\r\n        count++;\r\n        d += 8;\r\n    }\r\n    byte[] res = new byte[coefficients.length * count];\r\n    count = 0;\r\n    for (int i = 0; i < coefficients.length; i++) {\r\n        for (int j = 0; j < d; j += 8) {\r\n            res[count++] = (byte) (coefficients[i] >>> j);\r\n        }\r\n    }\r\n    return res;\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.examples.PGPExampleUtil.readPublicKey",
	"Comment": "a simple routine that opens a key ring file and loads the first available keysuitable for encryption.",
	"Method": "PGPPublicKey readPublicKey(String fileName,PGPPublicKey readPublicKey,InputStream input){\r\n    PGPPublicKeyRingCollection pgpPub = new PGPPublicKeyRingCollection(PGPUtil.getDecoderStream(input), new JcaKeyFingerprintCalculator());\r\n    Iterator keyRingIter = pgpPub.getKeyRings();\r\n    while (keyRingIter.hasNext()) {\r\n        PGPPublicKeyRing keyRing = (PGPPublicKeyRing) keyRingIter.next();\r\n        Iterator keyIter = keyRing.getPublicKeys();\r\n        while (keyIter.hasNext()) {\r\n            PGPPublicKey key = (PGPPublicKey) keyIter.next();\r\n            if (key.isEncryptionKey()) {\r\n                return key;\r\n            }\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(\"Can't find encryption key in key ring.\");\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPSignatureSubpacketVector.getSignatureExpirationTime",
	"Comment": "return the number of seconds a signature is valid for after its creation date. a value of zero meansthe signature never expires.",
	"Method": "long getSignatureExpirationTime(){\r\n    SignatureSubpacket p = this.getSubpacket(SignatureSubpacketTags.EXPIRE_TIME);\r\n    if (p == null) {\r\n        return 0;\r\n    }\r\n    return ((SignatureExpirationTime) p).getTime();\r\n}"
}, {
	"Path": "org.bouncycastle.est.ESTService.simpleEnroll",
	"Comment": "perform a simple enrollment operation.this method accepts an esphttpauth instance to provide basic or digest authentication.if authentication is to be performed as part of tls then this instances client keystore and their keystorepassword need to be specified.",
	"Method": "EnrollmentResponse simpleEnroll(EnrollmentResponse priorResponse,EnrollmentResponse simpleEnroll,boolean reenroll,PKCS10CertificationRequest certificationRequest,ESTAuth auth){\r\n    if (!clientProvider.isTrusted()) {\r\n        throw new IllegalStateException(\"No trust anchors.\");\r\n    }\r\n    ESTResponse resp = null;\r\n    try {\r\n        final byte[] data = annotateRequest(certificationRequest.getEncoded()).getBytes();\r\n        URL url = new URL(server + (reenroll ? SIMPLE_REENROLL : SIMPLE_ENROLL));\r\n        ESTClient client = clientProvider.makeClient();\r\n        ESTRequestBuilder req = new ESTRequestBuilder(\"POST\", url).withData(data).withClient(client);\r\n        req.addHeader(\"Content-Type\", \"application/pkcs10\");\r\n        req.addHeader(\"Content-Length\", \"\" + data.length);\r\n        req.addHeader(\"Content-Transfer-Encoding\", \"base64\");\r\n        if (auth != null) {\r\n            auth.applyAuth(req);\r\n        }\r\n        resp = client.doRequest(req.build());\r\n        return handleEnrollResponse(resp);\r\n    } catch (Throwable t) {\r\n        if (t instanceof ESTException) {\r\n            throw (ESTException) t;\r\n        } else {\r\n            throw new ESTException(t.getMessage(), t);\r\n        }\r\n    } finally {\r\n        if (resp != null) {\r\n            resp.close();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSSignedData.getSignerInfos",
	"Comment": "return the collection of signers that are associated with thesignatures for the message.",
	"Method": "SignerInformationStore getSignerInfos(){\r\n    if (signerInfoStore == null) {\r\n        ASN1Set s = signedData.getSignerInfos();\r\n        List signerInfos = new ArrayList();\r\n        for (int i = 0; i != s.size(); i++) {\r\n            SignerInfo info = SignerInfo.getInstance(s.getObjectAt(i));\r\n            ASN1ObjectIdentifier contentType = signedData.getEncapContentInfo().getContentType();\r\n            if (hashes == null) {\r\n                signerInfos.add(new SignerInformation(info, contentType, signedContent, null));\r\n            } else {\r\n                Object obj = hashes.keySet().iterator().next();\r\n                byte[] hash = (obj instanceof String) ? (byte[]) hashes.get(info.getDigestAlgorithm().getAlgorithm().getId()) : (byte[]) hashes.get(info.getDigestAlgorithm().getAlgorithm());\r\n                signerInfos.add(new SignerInformation(info, contentType, null, hash));\r\n            }\r\n        }\r\n        signerInfoStore = new SignerInformationStore(signerInfos);\r\n    }\r\n    return signerInfoStore;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.test.speedy.Poly1305Reference.processBlock",
	"Comment": "add a full block of 16 bytes of data, padded to 17 bytes, to the mac",
	"Method": "void processBlock(){\r\n    for (int i = 0; i < currentBlockOffset; i++) {\r\n        c[i] = currentBlock[i] & 0xFF;\r\n    }\r\n    c[currentBlockOffset] = 1;\r\n    for (int i = currentBlockOffset + 1; i < c.length; i++) {\r\n        c[i] = 0;\r\n    }\r\n    add(h, c);\r\n    mulmod(h, r);\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPrivateKey.getEncoded",
	"Comment": "return a pkcs8 representation of the key. the sequence returnedrepresents a full privatekeyinfo object.",
	"Method": "byte[] getEncoded(){\r\n    X962Parameters params = ECUtils.getDomainParametersFromName(ecSpec, withCompression);\r\n    int orderBitLength;\r\n    if (ecSpec == null) {\r\n        orderBitLength = ECUtil.getOrderBitLength(configuration, null, this.getD());\r\n    } else {\r\n        orderBitLength = ECUtil.getOrderBitLength(configuration, ecSpec.getN(), this.getD());\r\n    }\r\n    PrivateKeyInfo info;\r\n    org.bouncycastle.asn1.sec.ECPrivateKey keyStructure;\r\n    if (publicKey != null) {\r\n        keyStructure = new org.bouncycastle.asn1.sec.ECPrivateKey(orderBitLength, this.getD(), publicKey, params);\r\n    } else {\r\n        keyStructure = new org.bouncycastle.asn1.sec.ECPrivateKey(orderBitLength, this.getD(), params);\r\n    }\r\n    try {\r\n        info = new PrivateKeyInfo(new AlgorithmIdentifier(X9ObjectIdentifiers.id_ecPublicKey, params), keyStructure);\r\n        return info.getEncoded(ASN1Encoding.DER);\r\n    } catch (IOException e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.x509.X509ExtensionsGenerator.generate",
	"Comment": "generate an x509extensions object based on the current state of the generator.",
	"Method": "X509Extensions generate(){\r\n    return new X509Extensions(extOrdering, extensions);\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2Polynomial.reduceN",
	"Comment": "reduces len by finding the most significant bit set to one and reducinglen and blocks.",
	"Method": "void reduceN(){\r\n    int i, j, h;\r\n    i = blocks - 1;\r\n    while ((value[i] == 0) && (i > 0)) {\r\n        i--;\r\n    }\r\n    h = value[i];\r\n    j = 0;\r\n    while (h != 0) {\r\n        h >>>= 1;\r\n        j++;\r\n    }\r\n    len = (i << 5) + j;\r\n    blocks = i + 1;\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.operator.jcajce.JcaPGPDigestCalculatorProviderBuilder.setProvider",
	"Comment": "sets the provider to use to obtain cryptographic primitives.",
	"Method": "JcaPGPDigestCalculatorProviderBuilder setProvider(Provider provider,JcaPGPDigestCalculatorProviderBuilder setProvider,String providerName){\r\n    this.helper = new OperatorHelper(new NamedJcaJceHelper(providerName));\r\n    return this;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.BERSequenceParser.toASN1Primitive",
	"Comment": "return an bersequence representing this parser and its contents.",
	"Method": "ASN1Primitive toASN1Primitive(){\r\n    try {\r\n        return getLoadedObject();\r\n    } catch (IOException e) {\r\n        throw new IllegalStateException(e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.math.ec.SimpleBigDecimal.getInstance",
	"Comment": "returns a simplebigdecimal representing the same numericalvalue as value.",
	"Method": "SimpleBigDecimal getInstance(BigInteger value,int scale){\r\n    return new SimpleBigDecimal(value.shiftLeft(scale), scale);\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.ntru.polynomial.LongPolynomial2.mult",
	"Comment": "multiplies the polynomial with another, taking the indices mod n and the values mod 2048.",
	"Method": "LongPolynomial2 mult(LongPolynomial2 poly2){\r\n    int N = coeffs.length;\r\n    if (poly2.coeffs.length != N || numCoeffs != poly2.numCoeffs) {\r\n        throw new IllegalArgumentException(\"Number of coefficients must be the same\");\r\n    }\r\n    LongPolynomial2 c = multRecursive(poly2);\r\n    if (c.coeffs.length > N) {\r\n        if (numCoeffs % 2 == 0) {\r\n            for (int k = N; k < c.coeffs.length; k++) {\r\n                c.coeffs[k - N] = (c.coeffs[k - N] + c.coeffs[k]) & 0x7FF0007FFL;\r\n            }\r\n            c.coeffs = Arrays.copyOf(c.coeffs, N);\r\n        } else {\r\n            for (int k = N; k < c.coeffs.length; k++) {\r\n                c.coeffs[k - N] = c.coeffs[k - N] + (c.coeffs[k - 1] >> 24);\r\n                c.coeffs[k - N] = c.coeffs[k - N] + ((c.coeffs[k] & 2047) << 24);\r\n                c.coeffs[k - N] &= 0x7FF0007FFL;\r\n            }\r\n            c.coeffs = Arrays.copyOf(c.coeffs, N);\r\n            c.coeffs[c.coeffs.length - 1] &= 2047;\r\n        }\r\n    }\r\n    c = new LongPolynomial2(c.coeffs);\r\n    c.numCoeffs = numCoeffs;\r\n    return c;\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSCompressedDataParser.getContent",
	"Comment": "return a typed stream which will allow the reading of the compressed content inexpanded form.",
	"Method": "CMSTypedStream getContent(InputExpanderProvider expanderProvider){\r\n    try {\r\n        CompressedDataParser comData = new CompressedDataParser((ASN1SequenceParser) _contentInfo.getContent(BERTags.SEQUENCE));\r\n        ContentInfoParser content = comData.getEncapContentInfo();\r\n        InputExpander expander = expanderProvider.get(comData.getCompressionAlgorithmIdentifier());\r\n        ASN1OctetStringParser bytes = (ASN1OctetStringParser) content.getContent(BERTags.OCTET_STRING);\r\n        return new CMSTypedStream(content.getContentType().getId(), expander.getInputStream(bytes.getOctetStream()));\r\n    } catch (IOException e) {\r\n        throw new CMSException(\"IOException reading compressed content.\", e);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.x509.X509V3CertificateGenerator.generate",
	"Comment": "generate an x509 certificate, based on the current issuer and subject,using the passed in provider for the signing and the supplied sourceof randomness, if required.",
	"Method": "X509Certificate generate(PrivateKey key,X509Certificate generate,PrivateKey key,SecureRandom random,X509Certificate generate,PrivateKey key,String provider,X509Certificate generate,PrivateKey key,String provider,SecureRandom random){\r\n    TBSCertificate tbsCert = generateTbsCert();\r\n    byte[] signature;\r\n    try {\r\n        signature = X509Util.calculateSignature(sigOID, signatureAlgorithm, provider, key, random, tbsCert);\r\n    } catch (IOException e) {\r\n        throw new ExtCertificateEncodingException(\"exception encoding TBS cert\", e);\r\n    }\r\n    try {\r\n        return generateJcaObject(tbsCert, signature);\r\n    } catch (CertificateParsingException e) {\r\n        throw new ExtCertificateEncodingException(\"exception producing certificate object\", e);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.X509CertSelector.getSerialNumber",
	"Comment": "returns the serialnumber criterion. the specified serial number mustmatch the certificate serial number in the x509certificate.if null, any certificate serial number will do.",
	"Method": "BigInteger getSerialNumber(){\r\n    return serialNumber;\r\n}"
}, {
	"Path": "org.bouncycastle.mail.smime.SMIMEGenerator.makeContentBodyPart",
	"Comment": "extract an appropriate body part from the passed in mimemessage",
	"Method": "MimeBodyPart makeContentBodyPart(MimeBodyPart content,MimeBodyPart makeContentBodyPart,MimeMessage message){\r\n    MimeBodyPart content = new MimeBodyPart();\r\n    try {\r\n        message.removeHeader(\"Message-Id\");\r\n        message.removeHeader(\"Mime-Version\");\r\n        try {\r\n            if (message.getContent() instanceof Multipart) {\r\n                content.setContent(message.getRawInputStream(), message.getContentType());\r\n                extractHeaders(content, message);\r\n                return content;\r\n            }\r\n        } catch (MessagingException e) {\r\n        }\r\n        content.setContent(message.getContent(), message.getContentType());\r\n        content.setDataHandler(message.getDataHandler());\r\n        extractHeaders(content, message);\r\n    } catch (MessagingException e) {\r\n        throw new SMIMEException(\"exception saving message state.\", e);\r\n    } catch (IOException e) {\r\n        throw new SMIMEException(\"exception getting message content.\", e);\r\n    }\r\n    return content;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.X509CRLEntryHolder.getRevocationDate",
	"Comment": "return the date on which the certificate associated with this crlentry was revoked.",
	"Method": "Date getRevocationDate(){\r\n    return entry.getRevocationDate().getDate();\r\n}"
}, {
	"Path": "org.bouncycastle.mail.smime.SMIMEUtil.toMimeBodyPart",
	"Comment": "return a file based mimebodypart represented by content and backedby the file represented by file.",
	"Method": "MimeBodyPart toMimeBodyPart(byte[] content,MimeBodyPart toMimeBodyPart,InputStream content,FileBackedMimeBodyPart toMimeBodyPart,CMSTypedStream content,FileBackedMimeBodyPart toMimeBodyPart,CMSTypedStream content,File file){\r\n    try {\r\n        return new FileBackedMimeBodyPart(content.getContentStream(), file);\r\n    } catch (IOException e) {\r\n        throw new SMIMEException(\"can't save content to file: \" + e, e);\r\n    } catch (MessagingException e) {\r\n        throw new SMIMEException(\"can't create part: \" + e, e);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPPublicKeyRing.removePublicKey",
	"Comment": "returns a new key ring with the public key passed inremoved from the key ring.",
	"Method": "PGPPublicKeyRing removePublicKey(PGPPublicKeyRing pubRing,PGPPublicKey pubKey){\r\n    List keys = new ArrayList(pubRing.keys);\r\n    boolean found = false;\r\n    for (int i = 0; i < keys.size(); i++) {\r\n        PGPPublicKey key = (PGPPublicKey) keys.get(i);\r\n        if (key.getKeyID() == pubKey.getKeyID()) {\r\n            found = true;\r\n            keys.remove(i);\r\n        }\r\n    }\r\n    if (!found) {\r\n        return null;\r\n    }\r\n    return new PGPPublicKeyRing(keys);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.agreement.srp.SRP6Server.calculateSessionKey",
	"Comment": "computes the final session key as a result of the srp successful mutual authentication\tto be called after calculating the server evidence message m2.",
	"Method": "BigInteger calculateSessionKey(){\r\n    if (this.S == null || this.M1 == null || this.M2 == null) {\r\n        throw new CryptoException(\"Impossible to compute Key: \" + \"some data are missing from the previous operations (S,M1,M2)\");\r\n    }\r\n    this.Key = SRP6Util.calculateKey(digest, N, S);\r\n    return Key;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.test.EnumeratedTest.testReadingMultipleTripleByteItems",
	"Comment": "makes sure multiple identically sized values are parsed correctly.",
	"Method": "void testReadingMultipleTripleByteItems(){\r\n    ASN1Primitive obj = ASN1Primitive.fromByteArray(MultipleTripleByteItems);\r\n    assertTrue(\"Null ASN.1 SEQUENCE\", obj instanceof ASN1Sequence);\r\n    ASN1Sequence sequence = (ASN1Sequence) obj;\r\n    assertEquals(\"2 items expected\", 2, sequence.size());\r\n    ASN1Enumerated enumerated = ASN1Enumerated.getInstance(sequence.getObjectAt(0));\r\n    assertNotNull(\"ENUMERATED expected\", enumerated);\r\n    assertEquals(\"Unexpected ENUMERATED value\", 65793, enumerated.getValue().intValue());\r\n    ASN1ObjectIdentifier objectId = ASN1ObjectIdentifier.getInstance(sequence.getObjectAt(1));\r\n    assertNotNull(\"OBJECT IDENTIFIER expected\", objectId);\r\n    assertEquals(\"Unexpected OBJECT IDENTIFIER value\", \"1.3.6.1\", objectId.getId());\r\n}"
}, {
	"Path": "org.bouncycastle.cms.RecipientInformationStore.getRecipients",
	"Comment": "return possible empty collection with recipients matching the passed in recipientid",
	"Method": "Collection<RecipientInformation> getRecipients(Collection<Recipient> getRecipients,RecipientId selector){\r\n    if (selector instanceof KeyTransRecipientId) {\r\n        KeyTransRecipientId keyTrans = (KeyTransRecipientId) selector;\r\n        X500Name issuer = keyTrans.getIssuer();\r\n        byte[] subjectKeyId = keyTrans.getSubjectKeyIdentifier();\r\n        if (issuer != null && subjectKeyId != null) {\r\n            List results = new ArrayList();\r\n            Collection match1 = getRecipients(new KeyTransRecipientId(issuer, keyTrans.getSerialNumber()));\r\n            if (match1 != null) {\r\n                results.addAll(match1);\r\n            }\r\n            Collection match2 = getRecipients(new KeyTransRecipientId(subjectKeyId));\r\n            if (match2 != null) {\r\n                results.addAll(match2);\r\n            }\r\n            return results;\r\n        }\r\n    }\r\n    List list = (ArrayList) table.get(selector);\r\n    return list == null ? new ArrayList() : new ArrayList(list);\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2nPolynomial.multiplyAndReduce",
	"Comment": "multiplies this by b, reduces the result by g andreturns it in a new polynomialgf2n.",
	"Method": "GF2nPolynomial multiplyAndReduce(GF2nPolynomial b,GF2nPolynomial g){\r\n    return multiply(b).reduce(g);\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSSignedData.replaceCertificatesAndCRLs",
	"Comment": "replace the certificate and crl information associated with thiscmssigneddata object with the new one passed in.",
	"Method": "CMSSignedData replaceCertificatesAndCRLs(CMSSignedData signedData,Store certificates,Store attrCerts,Store revocations){\r\n    CMSSignedData cms = new CMSSignedData(signedData);\r\n    ASN1Set certSet = null;\r\n    ASN1Set crlSet = null;\r\n    if (certificates != null || attrCerts != null) {\r\n        List certs = new ArrayList();\r\n        if (certificates != null) {\r\n            certs.addAll(CMSUtils.getCertificatesFromStore(certificates));\r\n        }\r\n        if (attrCerts != null) {\r\n            certs.addAll(CMSUtils.getAttributeCertificatesFromStore(attrCerts));\r\n        }\r\n        ASN1Set set = CMSUtils.createBerSetFromList(certs);\r\n        if (set.size() != 0) {\r\n            certSet = set;\r\n        }\r\n    }\r\n    if (revocations != null) {\r\n        ASN1Set set = CMSUtils.createBerSetFromList(CMSUtils.getCRLsFromStore(revocations));\r\n        if (set.size() != 0) {\r\n            crlSet = set;\r\n        }\r\n    }\r\n    cms.signedData = new SignedData(signedData.signedData.getDigestAlgorithms(), signedData.signedData.getEncapContentInfo(), certSet, crlSet, signedData.signedData.getSignerInfos());\r\n    cms.contentInfo = new ContentInfo(cms.contentInfo.getContentType(), cms.signedData);\r\n    return cms;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.ntru.util.Util.readFullLength",
	"Comment": "reads a given number of bytes from an inputstream.if there are not enough bytes in the stream, an ioexceptionis thrown.",
	"Method": "byte[] readFullLength(InputStream is,int length){\r\n    byte[] arr = new byte[length];\r\n    if (is.read(arr) != arr.length) {\r\n        throw new IOException(\"Not enough bytes to read.\");\r\n    }\r\n    return arr;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.cms.RecipientKeyIdentifier.getInstance",
	"Comment": "return a recipientkeyidentifier object from a tagged object.",
	"Method": "RecipientKeyIdentifier getInstance(ASN1TaggedObject ato,boolean isExplicit,RecipientKeyIdentifier getInstance,Object obj){\r\n    if (obj instanceof RecipientKeyIdentifier) {\r\n        return (RecipientKeyIdentifier) obj;\r\n    }\r\n    if (obj != null) {\r\n        return new RecipientKeyIdentifier(ASN1Sequence.getInstance(obj));\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.provider.OldPKCS12ParametersGenerator.generateDerivedParameters",
	"Comment": "generate a key with initialisation vector parameter derived fromthe password, salt, and iteration count we are currently initialisedwith.",
	"Method": "CipherParameters generateDerivedParameters(int keySize,CipherParameters generateDerivedParameters,int keySize,int ivSize){\r\n    keySize = keySize / 8;\r\n    ivSize = ivSize / 8;\r\n    byte[] dKey = generateDerivedKey(KEY_MATERIAL, keySize);\r\n    byte[] iv = generateDerivedKey(IV_MATERIAL, ivSize);\r\n    return new ParametersWithIV(new KeyParameter(dKey, 0, keySize), iv, 0, ivSize);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.engines.CramerShoupCoreEngine.isValidMessage",
	"Comment": "just checking whether the message m is actually less than the group order p",
	"Method": "boolean isValidMessage(BigInteger m,BigInteger p){\r\n    return m.compareTo(p) < 0;\r\n}"
}, {
	"Path": "java.security.cert.CertStore.getCertStoreParameters",
	"Comment": "returns the parameters used to initialize this certstore.note that the certstoreparameters object is cloned before it is returned.",
	"Method": "CertStoreParameters getCertStoreParameters(){\r\n    return params;\r\n}"
}, {
	"Path": "javax.crypto.KeyAgreement.generateSecret",
	"Comment": "creates the shared secret and returns it as a secretkeyobject of the specified algorithm.this method resets this keyagreement object, so that itcan be reused for further key agreements. unless this key agreement isreinitialized with one of the init methods, the sameprivate information and algorithm parameters will be used forsubsequent key agreements.",
	"Method": "byte[] generateSecret(int generateSecret,byte[] sharedSecret,int offset,SecretKey generateSecret,String algorithm){\r\n    return keyAgreeSpi.engineGenerateSecret(algorithm);\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSEnvelopedData.getEncryptionAlgOID",
	"Comment": "return the object identifier for the content encryption algorithm.",
	"Method": "String getEncryptionAlgOID(){\r\n    return encAlg.getAlgorithm().getId();\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.tls.TlsProtocol.readApplicationData",
	"Comment": "read data from the network. the method will return immediately, if there is still some dataleft in the buffer, or block until some application data has been read from the network.",
	"Method": "int readApplicationData(byte[] buf,int offset,int len){\r\n    if (len < 1) {\r\n        return 0;\r\n    }\r\n    while (applicationDataQueue.available() == 0) {\r\n        if (this.closed) {\r\n            if (this.failedWithError) {\r\n                throw new IOException(\"Cannot read application data on failed TLS connection\");\r\n            }\r\n            if (!appDataReady) {\r\n                throw new IllegalStateException(\"Cannot read application data until initial handshake completed.\");\r\n            }\r\n            return -1;\r\n        }\r\n        safeReadRecord();\r\n    }\r\n    len = Math.min(len, applicationDataQueue.available());\r\n    applicationDataQueue.removeData(buf, offset, len, 0);\r\n    return len;\r\n}"
}, {
	"Path": "org.bouncycastle.x509.ExtendedPKIXParameters.getInstance",
	"Comment": "returns an instance with the parameters of a givenpkixparameters object.",
	"Method": "ExtendedPKIXParameters getInstance(PKIXParameters pkixParams){\r\n    ExtendedPKIXParameters params;\r\n    try {\r\n        params = new ExtendedPKIXParameters(pkixParams.getTrustAnchors());\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e.getMessage());\r\n    }\r\n    params.setParams(pkixParams);\r\n    return params;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.provider.CertPathValidatorUtilities.getCRLIssuersFromDistributionPoint",
	"Comment": "add the crl issuers from the crlissuer field of the distribution point orfrom the certificate if not given to the issuer criterion of theselector.the issuerprincipals are a collection with a singlex500principal for x509certificates.",
	"Method": "void getCRLIssuersFromDistributionPoint(DistributionPoint dp,Collection issuerPrincipals,X509CRLSelector selector){\r\n    List issuers = new ArrayList();\r\n    if (dp.getCRLIssuer() != null) {\r\n        GeneralName[] genNames = dp.getCRLIssuer().getNames();\r\n        for (int j = 0; j < genNames.length; j++) {\r\n            if (genNames[j].getTagNo() == GeneralName.directoryName) {\r\n                try {\r\n                    issuers.add(new X500Principal(genNames[j].getName().toASN1Primitive().getEncoded()));\r\n                } catch (IOException e) {\r\n                    throw new AnnotatedException(\"CRL issuer information from distribution point cannot be decoded.\", e);\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        if (dp.getDistributionPoint() == null) {\r\n            throw new AnnotatedException(\"CRL issuer is omitted from distribution point but no distributionPoint field present.\");\r\n        }\r\n        for (Iterator it = issuerPrincipals.iterator(); it.hasNext(); ) {\r\n            issuers.add((X500Principal) it.next());\r\n        }\r\n    }\r\n    Iterator it = issuers.iterator();\r\n    while (it.hasNext()) {\r\n        try {\r\n            selector.addIssuerName(((X500Principal) it.next()).getEncoded());\r\n        } catch (IOException ex) {\r\n            throw new AnnotatedException(\"Cannot decode CRL issuer information.\", ex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.operator.jcajce.OperatorHelper.notDefaultPSSParams",
	"Comment": "for our purposes default includes varient digest with salt the same size as digest",
	"Method": "boolean notDefaultPSSParams(ASN1Sequence seq){\r\n    if (seq == null || seq.size() == 0) {\r\n        return false;\r\n    }\r\n    RSASSAPSSparams pssParams = RSASSAPSSparams.getInstance(seq);\r\n    if (!pssParams.getMaskGenAlgorithm().getAlgorithm().equals(PKCSObjectIdentifiers.id_mgf1)) {\r\n        return true;\r\n    }\r\n    if (!pssParams.getHashAlgorithm().equals(AlgorithmIdentifier.getInstance(pssParams.getMaskGenAlgorithm().getParameters()))) {\r\n        return true;\r\n    }\r\n    MessageDigest digest = createDigest(pssParams.getHashAlgorithm());\r\n    return pssParams.getSaltLength().intValue() != digest.getDigestLength();\r\n}"
}, {
	"Path": "org.bouncycastle.cms.SignerInfoGeneratorBuilder.setDirectSignature",
	"Comment": "if the passed in flag is true, the signer signature will be based on the data, nota collection of signed attributes, and no signed attributes will be included.",
	"Method": "SignerInfoGeneratorBuilder setDirectSignature(boolean hasNoSignedAttributes){\r\n    this.directSignature = hasNoSignedAttributes;\r\n    return this;\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.provider.asymmetric.ecgost.BCECGOST3410PrivateKey.getEncoded",
	"Comment": "return a pkcs8 representation of the key. the sequence returnedrepresents a full privatekeyinfo object.",
	"Method": "byte[] getEncoded(){\r\n    ByteArrayOutputStream bOut = new ByteArrayOutputStream();\r\n    DEROutputStream dOut = new DEROutputStream(bOut);\r\n    X962Parameters params = null;\r\n    if (ecSpec instanceof ECNamedCurveParameterSpec) {\r\n        ASN1ObjectIdentifier curveOid = ECUtil.getNamedCurveOid(((ECNamedCurveParameterSpec) ecSpec).getName());\r\n        params = new X962Parameters(curveOid);\r\n    } else if (ecSpec == null) {\r\n        params = new X962Parameters(DERNull.INSTANCE);\r\n    } else {\r\n        ECParameterSpec p = (ECParameterSpec) ecSpec;\r\n        ECPoint pG = p.getG().normalize();\r\n        ECPoint g = pG.getCurve().createPoint(pG.getAffineXCoord().toBigInteger(), pG.getAffineYCoord().toBigInteger());\r\n        X9ECParameters ecP = new X9ECParameters(p.getCurve(), g, p.getN(), p.getH(), p.getSeed());\r\n        params = new X962Parameters(ecP);\r\n    }\r\n    PrivateKeyInfo info;\r\n    ECPrivateKeyStructure keyStructure;\r\n    if (publicKey != null) {\r\n        keyStructure = new ECPrivateKeyStructure(this.getD(), publicKey, params);\r\n    } else {\r\n        keyStructure = new ECPrivateKeyStructure(this.getD(), params);\r\n    }\r\n    try {\r\n        if (algorithm.equals(\"ECGOST3410\")) {\r\n            info = new PrivateKeyInfo(new AlgorithmIdentifier(CryptoProObjectIdentifiers.gostR3410_2001, params), keyStructure);\r\n        } else {\r\n            info = new PrivateKeyInfo(new AlgorithmIdentifier(X9ObjectIdentifiers.id_ecPublicKey, params), keyStructure);\r\n        }\r\n        return KeyUtil.getEncodedPrivateKeyInfo(info);\r\n    } catch (IOException e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.x509.X509NameEntryConverter.convertHexEncoded",
	"Comment": "convert an inline encoded hex string rendition of an asn.1object back into its corresponding asn.1 object.",
	"Method": "ASN1Primitive convertHexEncoded(String str,int off){\r\n    str = Strings.toLowerCase(str);\r\n    byte[] data = new byte[(str.length() - off) / 2];\r\n    for (int index = 0; index != data.length; index++) {\r\n        char left = str.charAt((index * 2) + off);\r\n        char right = str.charAt((index * 2) + off + 1);\r\n        if (left < 'a') {\r\n            data[index] = (byte) ((left - '0') << 4);\r\n        } else {\r\n            data[index] = (byte) ((left - 'a' + 10) << 4);\r\n        }\r\n        if (right < 'a') {\r\n            data[index] |= (byte) (right - '0');\r\n        } else {\r\n            data[index] |= (byte) (right - 'a' + 10);\r\n        }\r\n    }\r\n    ASN1InputStream aIn = new ASN1InputStream(data);\r\n    return aIn.readObject();\r\n}"
}, {
	"Path": "org.bouncycastle.jce.spec.ECNamedCurveSpec.getName",
	"Comment": "return the name of the curve the ec domain parameters belong to.",
	"Method": "String getName(){\r\n    return name;\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.ch1_titlepane.BERootPaneUI.createWindowMouseInputListener",
	"Comment": "returns a mouselistener that will be added to the\twindow containing the jrootpane.",
	"Method": "MouseInputListener createWindowMouseInputListener(JRootPane root){\r\n    return new MouseInputHandler();\r\n}"
}, {
	"Path": "org.bouncycastle.jce.provider.test.CipherStreamTest2.testTamperedWrite",
	"Comment": "test tampering of ciphertext followed by write to decrypting cipheroutputstream",
	"Method": "void testTamperedWrite(String name,Key key,boolean authenticated,boolean useBc){\r\n    Cipher encrypt = Cipher.getInstance(name, \"BC\");\r\n    Cipher decrypt = Cipher.getInstance(name, \"BC\");\r\n    encrypt.init(Cipher.ENCRYPT_MODE, key);\r\n    if (encrypt.getIV() != null) {\r\n        decrypt.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(encrypt.getIV()));\r\n    } else {\r\n        decrypt.init(Cipher.DECRYPT_MODE, key);\r\n    }\r\n    byte[] ciphertext = encrypt.doFinal(new byte[streamSize]);\r\n    ciphertext[0] += 1;\r\n    ByteArrayOutputStream plaintext = new ByteArrayOutputStream();\r\n    OutputStream output = createOutputStream(plaintext, decrypt, useBc);\r\n    for (int i = 0; i < ciphertext.length; i++) {\r\n        output.write(ciphertext[i]);\r\n    }\r\n    try {\r\n        output.close();\r\n        fail(\"Expected invalid ciphertext after tamper and write : \" + name, authenticated, useBc);\r\n    } catch (InvalidCipherTextIOException e) {\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2nONBElement.testRightmostBit",
	"Comment": "returns whether the highest bit of the bit representation is set",
	"Method": "boolean testRightmostBit(){\r\n    return (mPol[mLength - 1] & mBitmask[mBit - 1]) != 0L;\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPPublicKey.getRawUserIDs",
	"Comment": "return any userids associated with the key in raw byte form. no attempt is madeto convert the ids into strings.",
	"Method": "Iterator getRawUserIDs(){\r\n    List temp = new ArrayList();\r\n    for (int i = 0; i != ids.size(); i++) {\r\n        if (ids.get(i) instanceof UserIDPacket) {\r\n            temp.add(((UserIDPacket) ids.get(i)).getRawID());\r\n        }\r\n    }\r\n    return temp.iterator();\r\n}"
}, {
	"Path": "org.bouncycastle.x509.ExtendedPKIXParameters.setTrustedACIssuers",
	"Comment": "sets the trusted attribute certificate issuers. if attribute certificatesis verified the trusted ac issuers must be set.the trustedacissuers must be a set oftrustanchorthe given set is cloned.",
	"Method": "void setTrustedACIssuers(Set trustedACIssuers){\r\n    if (trustedACIssuers == null) {\r\n        trustedACIssuers.clear();\r\n        return;\r\n    }\r\n    for (Iterator it = trustedACIssuers.iterator(); it.hasNext(); ) {\r\n        if (!(it.next() instanceof TrustAnchor)) {\r\n            throw new ClassCastException(\"All elements of set must be \" + \"of type \" + TrustAnchor.class.getName() + \".\");\r\n        }\r\n    }\r\n    this.trustedACIssuers.clear();\r\n    this.trustedACIssuers.addAll(trustedACIssuers);\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPPublicKeyRingCollection.getPublicKeyRing",
	"Comment": "return the pgp public key associated with the given key fingerprint.",
	"Method": "PGPPublicKeyRing getPublicKeyRing(long keyID,PGPPublicKeyRing getPublicKeyRing,byte[] fingerprint){\r\n    Iterator it = this.getKeyRings();\r\n    while (it.hasNext()) {\r\n        PGPPublicKeyRing pubRing = (PGPPublicKeyRing) it.next();\r\n        PGPPublicKey pub = pubRing.getPublicKey(fingerprint);\r\n        if (pub != null) {\r\n            return pubRing;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.est.ESTService.storeToArray",
	"Comment": "utility method to extract all the x509certificates from a store using a filter and to return themas an array.",
	"Method": "X509CertificateHolder[] storeToArray(Store<X509CertificateHolder> store,X509CertificateHolder[] storeToArray,Store<X509CertificateHolder> store,Selector<X509CertificateHolder> selector){\r\n    Collection<X509CertificateHolder> c = store.getMatches(selector);\r\n    return c.toArray(new X509CertificateHolder[c.size()]);\r\n}"
}, {
	"Path": "org.bouncycastle.pkcs.PKCS12PfxPdu.isMacValid",
	"Comment": "verify the macdata attached to the pfx is consistent with what is expected.",
	"Method": "boolean isMacValid(PKCS12MacCalculatorBuilderProvider macCalcProviderBuilder,char[] password){\r\n    if (hasMac()) {\r\n        MacData pfxmData = pfx.getMacData();\r\n        MacDataGenerator mdGen = new MacDataGenerator(macCalcProviderBuilder.get(new AlgorithmIdentifier(pfxmData.getMac().getAlgorithmId().getAlgorithm(), new PKCS12PBEParams(pfxmData.getSalt(), pfxmData.getIterationCount().intValue()))));\r\n        try {\r\n            MacData mData = mdGen.build(password, ASN1OctetString.getInstance(pfx.getAuthSafe().getContent()).getOctets());\r\n            return Arrays.constantTimeAreEqual(mData.getEncoded(), pfx.getMacData().getEncoded());\r\n        } catch (IOException e) {\r\n            throw new PKCSException(\"unable to process AuthSafe: \" + e.getMessage());\r\n        }\r\n    }\r\n    throw new IllegalStateException(\"no MAC present on PFX\");\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.CertUtil.parseIP",
	"Comment": "parse the given ipv4 or ipv6 into der encoded byte array representation.",
	"Method": "byte[] parseIP(String data){\r\n    byte[] encoded = parseIPv4(data);\r\n    if (encoded == null) {\r\n        encoded = parseIPv6(data);\r\n    }\r\n    if (encoded == null) {\r\n        throw new IOException(\"unable to parse IP to DER encoded byte array\");\r\n    }\r\n    return encoded;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.ntru.NTRUEncryptionKeyPairGenerator.init",
	"Comment": "constructs a new instance with a set of encryption parameters.",
	"Method": "void init(KeyGenerationParameters param){\r\n    this.params = (NTRUEncryptionKeyGenerationParameters) param;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2nElement.convert",
	"Comment": "performs a basis transformation of this element to the given gf2nfieldbasis.",
	"Method": "GF2nElement convert(GF2nField basis){\r\n    return mField.convert(this, basis);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.digests.Blake2sDigest.getByteLength",
	"Comment": "return the size in bytes of the internal buffer the digest applies itscompression function to.",
	"Method": "int getByteLength(){\r\n    return BLOCK_LENGTH_BYTES;\r\n}"
}, {
	"Path": "org.bouncycastle.pkcs.PKCS10CertificationRequest.getSignature",
	"Comment": "return the bytes making up the signature associated with this request.",
	"Method": "byte[] getSignature(){\r\n    return certificationRequest.getSignature().getOctets();\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.X509CertSelector.getExtendedKeyUsage",
	"Comment": "returns the extendedkeyusage criterion. the x509certificatemust allow the specified key purposes in its extended key usageextension. if the keypurposeset returned is empty ornull, no extendedkeyusage check will be done. note thatan x509certificate that has no extendedkeyusage extensionimplicitly allows all key purposes.",
	"Method": "Set getExtendedKeyUsage(){\r\n    if (keyPurposeSet == null || keyPurposeSet.isEmpty()) {\r\n        return keyPurposeSet;\r\n    }\r\n    Set returnSet = new HashSet();\r\n    Iterator iter = keyPurposeSet.iterator();\r\n    while (iter.hasNext()) {\r\n        returnSet.add(iter.next().toString());\r\n    }\r\n    return Collections.unmodifiableSet(returnSet);\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2Vector.OS2VP",
	"Comment": "construct a new gf2vector with the given length out of the encodedvector.",
	"Method": "GF2Vector OS2VP(int length,byte[] encVec){\r\n    if (length < 0) {\r\n        throw new ArithmeticException(\"negative length\");\r\n    }\r\n    int byteLen = (length + 7) >> 3;\r\n    if (encVec.length > byteLen) {\r\n        throw new ArithmeticException(\"length mismatch\");\r\n    }\r\n    return new GF2Vector(length, LittleEndianConversions.toIntArray(encVec));\r\n}"
}, {
	"Path": "org.bouncycastle.mail.smime.SMIMEToolkit.signEncapsulated",
	"Comment": "produce a signed message in encapsulated format where the message is encoded in the signature..",
	"Method": "MimeBodyPart signEncapsulated(MimeBodyPart message,SignerInfoGenerator signerInfoGenerator){\r\n    SMIMESignedGenerator gen = new SMIMESignedGenerator();\r\n    if (signerInfoGenerator.hasAssociatedCertificate()) {\r\n        List certList = new ArrayList();\r\n        certList.add(signerInfoGenerator.getAssociatedCertificate());\r\n        gen.addCertificates(new CollectionStore(certList));\r\n    }\r\n    gen.addSignerInfoGenerator(signerInfoGenerator);\r\n    return gen.generateEncapsulated(message);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.modes.NISTCTSBlockCipher.getOutputSize",
	"Comment": "return the size of the output buffer required for an update plus adofinal with an input of len bytes.",
	"Method": "int getOutputSize(int len){\r\n    return len + bufOff;\r\n}"
}, {
	"Path": "org.bouncycastle.tls.crypto.impl.jcajce.JcaTlsCryptoProvider.create",
	"Comment": "create a new tlscrypto using the current builder configuration.",
	"Method": "TlsCrypto create(SecureRandom random,TlsCrypto create,SecureRandom keyRandom,SecureRandom nonceRandom){\r\n    return new JcaTlsCrypto(helper, keyRandom, nonceRandom);\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.rainbow.util.RainbowUtil.convertIntArray",
	"Comment": "this function converts an array of type int into an array of type byte",
	"Method": "byte[] convertIntArray(int[] in){\r\n    byte[] out = new byte[in.length];\r\n    for (int i = 0; i < in.length; i++) {\r\n        out[i] = (byte) in[i];\r\n    }\r\n    return out;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.PKIXCertPathValidatorResult.toString",
	"Comment": "return a printable representation of thispkixcertpathvalidatorresult.",
	"Method": "String toString(){\r\n    StringBuffer s = new StringBuffer();\r\n    s.append(\"PKIXCertPathValidatorResult: [ \\n\");\r\n    s.append(\"  Trust Anchor: \").append(getTrustAnchor()).append('\\n');\r\n    s.append(\"  Policy Tree: \").append(getPolicyTree()).append('\\n');\r\n    s.append(\"  Subject Public Key: \").append(getPublicKey()).append(\"\\n]\");\r\n    return s.toString();\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.ch1_titlepane.BETitlePane.createMenu",
	"Comment": "returns the jmenu displaying the appropriate menu items\tfor manipulating the frame.",
	"Method": "JMenu createMenu(){\r\n    JMenu menu = new JMenu(\"\");\r\n    menu.setOpaque(false);\r\n    if (getWindowDecorationStyle() == JRootPane.FRAME || getWindowDecorationStyle() == JRootPane.PLAIN_DIALOG) {\r\n        addMenuItems(menu);\r\n    }\r\n    return menu;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.CertUtil.parseURI",
	"Comment": "parse the given uri into der encoded byte array representation.",
	"Method": "byte[] parseURI(String data){\r\n    ASN1Object derData = new DERIA5String(data);\r\n    ByteArrayOutputStream outStream = new ByteArrayOutputStream();\r\n    DEROutputStream derOutStream = new DEROutputStream(outStream);\r\n    derOutStream.writeObject(derData);\r\n    derOutStream.close();\r\n    return outStream.toByteArray();\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSSignedGenerator.addCertificate",
	"Comment": "add a certificate to the certificate set to be included with the generated signeddata message.",
	"Method": "void addCertificate(X509CertificateHolder certificate){\r\n    certs.add(certificate.toASN1Structure());\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.x509.Holder.getEntityName",
	"Comment": "returns the entityname for an v2 attribute certificate or the subjectnamefor an v1 attribute certificate.",
	"Method": "GeneralNames getEntityName(){\r\n    return entityName;\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSSignedData.getOtherRevocationInfo",
	"Comment": "return any otherrevocationinfo otherrevinfo objects of the type indicated by otherrevocationinfoformat inthis signeddata structure.",
	"Method": "Store getOtherRevocationInfo(ASN1ObjectIdentifier otherRevocationInfoFormat){\r\n    return HELPER.getOtherRevocationInfo(otherRevocationInfoFormat, signedData.getCRLs());\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.examples.PGPExampleUtil.findSecretKey",
	"Comment": "search a secret key ring collection for a secret key corresponding to keyid if itexists.",
	"Method": "PGPPrivateKey findSecretKey(PGPSecretKeyRingCollection pgpSec,long keyID,char[] pass){\r\n    PGPSecretKey pgpSecKey = pgpSec.getSecretKey(keyID);\r\n    if (pgpSecKey == null) {\r\n        return null;\r\n    }\r\n    return pgpSecKey.extractPrivateKey(new JcePBESecretKeyDecryptorBuilder().setProvider(\"BC\").build(pass));\r\n}"
}, {
	"Path": "org.bouncycastle.cms.RecipientInformation.getKeyEncryptionAlgOID",
	"Comment": "return the object identifier for the key encryption algorithm.",
	"Method": "String getKeyEncryptionAlgOID(){\r\n    return keyEncAlg.getAlgorithm().getId();\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.tls.DTLSReplayWindow.reportAuthenticated",
	"Comment": "report that a received record with the given sequence number passed authentication checks.",
	"Method": "void reportAuthenticated(long seq){\r\n    if ((seq & VALID_SEQ_MASK) != seq) {\r\n        throw new IllegalArgumentException(\"'seq' out of range\");\r\n    }\r\n    if (seq <= latestConfirmedSeq) {\r\n        long diff = latestConfirmedSeq - seq;\r\n        if (diff < WINDOW_SIZE) {\r\n            bitmap |= (1L << diff);\r\n        }\r\n    } else {\r\n        long diff = seq - latestConfirmedSeq;\r\n        if (diff >= WINDOW_SIZE) {\r\n            bitmap = 1;\r\n        } else {\r\n            bitmap <<= (int) diff;\r\n            bitmap |= 1;\r\n        }\r\n        latestConfirmedSeq = seq;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.math.ec.WNafUtil.getWindowSize",
	"Comment": "determine window width to use for a scalar multiplication of the given size.",
	"Method": "int getWindowSize(int bits,int getWindowSize,int bits,int[] windowSizeCutoffs){\r\n    int w = 0;\r\n    for (; w < windowSizeCutoffs.length; ++w) {\r\n        if (bits < windowSizeCutoffs[w]) {\r\n            break;\r\n        }\r\n    }\r\n    return w + 2;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.X509CRLHolder.toASN1Structure",
	"Comment": "return the underlying asn.1 structure for the crl in this holder.",
	"Method": "CertificateList toASN1Structure(){\r\n    return x509CRL;\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.spec.DHUParameterSpec.getUserKeyingMaterial",
	"Comment": "return a copy of the user keying material, null if none is available.",
	"Method": "byte[] getUserKeyingMaterial(){\r\n    return Arrays.clone(userKeyingMaterial);\r\n}"
}, {
	"Path": "org.bouncycastle.pkcs.PKCS12PfxPduBuilder.build",
	"Comment": "build the pfx structure, protecting it with a mac calculated against the passed in password.",
	"Method": "PKCS12PfxPdu build(PKCS12MacCalculatorBuilder macCalcBuilder,char[] password){\r\n    AuthenticatedSafe auth = AuthenticatedSafe.getInstance(new DLSequence(dataVector));\r\n    byte[] encAuth;\r\n    try {\r\n        encAuth = auth.getEncoded();\r\n    } catch (IOException e) {\r\n        throw new PKCSException(\"unable to encode AuthenticatedSafe: \" + e.getMessage(), e);\r\n    }\r\n    ContentInfo mainInfo = new ContentInfo(PKCSObjectIdentifiers.data, new DEROctetString(encAuth));\r\n    MacData mData = null;\r\n    if (macCalcBuilder != null) {\r\n        MacDataGenerator mdGen = new MacDataGenerator(macCalcBuilder);\r\n        mData = mdGen.build(password, encAuth);\r\n    }\r\n    Pfx pfx = new Pfx(mainInfo, mData);\r\n    return new PKCS12PfxPdu(pfx);\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.Permutation.rightMultiply",
	"Comment": "compute the product of this permutation and another permutation.",
	"Method": "Permutation rightMultiply(Permutation p){\r\n    if (p.perm.length != perm.length) {\r\n        throw new IllegalArgumentException(\"length mismatch\");\r\n    }\r\n    Permutation result = new Permutation(perm.length);\r\n    for (int i = perm.length - 1; i >= 0; i--) {\r\n        result.perm[i] = perm[p.perm[i]];\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "java.security.cert.X509CRLSelector.setMinCRLNumber",
	"Comment": "sets the mincrlnumber criterion. the x509crl must have acrl number extension whose value is greater than or equal to thespecified value. if null, no mincrlnumber check will bedone.",
	"Method": "void setMinCRLNumber(BigInteger minCRL){\r\n    this.minCRL = minCRL;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.CertPathBuilder.getInstance",
	"Comment": "returns a certpathbuilder object that implements the specified algorithm,as supplied by the specified provider.",
	"Method": "CertPathBuilder getInstance(String algorithm,CertPathBuilder getInstance,String algorithm,String provider,CertPathBuilder getInstance,String algorithm,Provider provider){\r\n    if (provider == null) {\r\n        throw new IllegalArgumentException(\"provider must be non-null\");\r\n    }\r\n    CertUtil.Implementation imp = CertUtil.getImplementation(\"CertPathBuilder\", algorithm, provider);\r\n    if (imp != null) {\r\n        return new CertPathBuilder((CertPathBuilderSpi) imp.getEngine(), provider, algorithm);\r\n    }\r\n    throw new NoSuchAlgorithmException(\"can't find type \" + algorithm);\r\n}"
}, {
	"Path": "org.bouncycastle.test.est.TestEnroll.testEnrollUsingBogusTLSClientAuthAndBasicAuth",
	"Comment": "test enrollment using tls do do the client authentication.in this test we are going to use the bc api to generate a client certificate that the server will not accept.",
	"Method": "void testEnrollUsingBogusTLSClientAuthAndBasicAuth(){\r\n    ESTTestUtils.ensureProvider();\r\n    X509CertificateHolder caCert = ESTTestUtils.readPemCertificate(ESTServerUtils.makeRelativeToServerHome(\"/extCA/cacert.crt\"));\r\n    PrivateKey caPrivateKey = ESTTestUtils.readPemPrivateKey(ESTServerUtils.makeRelativeToServerHome(\"/extCA/private/cakey.pem\"), \"ECDSA\");\r\n    Object[] bogusCA = bogusCAGenerator();\r\n    ECGenParameterSpec ecGenSpec = new ECGenParameterSpec(\"prime256v1\");\r\n    KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"ECDSA\", \"BC\");\r\n    kpg.initialize(ecGenSpec, new SecureRandom());\r\n    KeyPair originalKeyPair = kpg.generateKeyPair();\r\n    X500NameBuilder builder = new X500NameBuilder();\r\n    builder.addRDN(BCStyle.C, \"AU\");\r\n    builder.addRDN(BCStyle.CN, \"Bunyip Bluegum\");\r\n    builder.addRDN(BCStyle.O, \"Pudding Protectors\");\r\n    builder.addRDN(BCStyle.L, \"Victoria\");\r\n    X500Name name = builder.build();\r\n    KeyUsage keyUsage = new KeyUsage(KeyUsage.keyCertSign | KeyUsage.digitalSignature | KeyUsage.keyEncipherment | KeyUsage.dataEncipherment | KeyUsage.cRLSign);\r\n    ASN1EncodableVector purposes = new ASN1EncodableVector();\r\n    purposes.add(KeyPurposeId.id_kp_serverAuth);\r\n    purposes.add(KeyPurposeId.id_kp_clientAuth);\r\n    purposes.add(KeyPurposeId.anyExtendedKeyUsage);\r\n    X509Certificate clientTLSCert = ESTTestUtils.createASignedCert(\"SHA256WITHECDSA\", name, SubjectPublicKeyInfo.getInstance(originalKeyPair.getPublic().getEncoded()), new X500Name(((X509Certificate) bogusCA[1]).getSubjectDN().getName()), ((PrivateKey) bogusCA[0]), 1, purposes, keyUsage);\r\n    System.out.println(clientTLSCert.toString());\r\n    KeyStore clientKeyStore = KeyStore.getInstance(\"JKS\");\r\n    clientKeyStore.load(null);\r\n    char[] clientKeyStorePass = \"tstpass\".toCharArray();\r\n    // This is hardcoded into the test server.\r\n    clientKeyStore.setKeyEntry(\"estuser\", originalKeyPair.getPrivate(), clientKeyStorePass, new Certificate[] { clientTLSCert });\r\n    clientKeyStore.store(new ByteArrayOutputStream(), clientKeyStorePass);\r\n    kpg.initialize(ecGenSpec);\r\n    KeyPair enrollmentPair = kpg.generateKeyPair();\r\n    ESTTestUtils.ensureProvider();\r\n    final ESTServerUtils.ServerInstance serverInstance = startDefaultServerTLSAndBasicAuth(0, false);\r\n    try {\r\n        TrustAnchor ta = new TrustAnchor(ESTTestUtils.toJavaX509Certificate(ESTTestUtils.readPemCertificate(ESTServerUtils.makeRelativeToServerHome(\"/estCA/cacert.crt\"))), null);\r\n        JsseESTServiceBuilder estBuilder = new JsseESTServiceBuilder(\"localhost:8443\", JcaJceUtils.getCertPathTrustManager(ESTTestUtils.toTrustAnchor(ESTTestUtils.readPemCertificate(ESTServerUtils.makeRelativeToServerHome(\"/estCA/cacert.crt\"))), null)).withProvider(BouncyCastleJsseProvider.PROVIDER_NAME).withTLSVersion(\"TLS\");\r\n        estBuilder.withKeyManagers(JcaJceUtils.createKeyManagerFactory(KeyManagerFactory.getDefaultAlgorithm(), null, clientKeyStore, clientKeyStorePass).getKeyManagers());\r\n        ESTService est = estBuilder.build();\r\n        PKCS10CertificationRequestBuilder pkcs10Builder = new JcaPKCS10CertificationRequestBuilder(new X500Name(\"CN=Test\"), enrollmentPair.getPublic());\r\n        PKCS10CertificationRequest csr = pkcs10Builder.build(new JcaContentSignerBuilder(\"SHA256WITHECDSA\").setProvider(\"BC\").build(enrollmentPair.getPrivate()));\r\n        try {\r\n            EnrollmentResponse enr = est.simpleEnroll(false, csr, new HttpAuth(\"estreal\", \"estuser\", \"estpwd\".toCharArray(), new SecureRandom(), new JcaDigestCalculatorProviderBuilder().setProvider(\"BC\").build()));\r\n        } catch (Exception ex) {\r\n            Assert.assertEquals(\"Only ESTException\", ex.getClass(), ESTException.class);\r\n            Assert.assertTrue(\"Either SocketException or SSLHandshakeException\", (ex.getCause() instanceof SocketException || ex.getCause() instanceof SSLHandshakeException));\r\n        }\r\n    } finally {\r\n        serverInstance.getServer().stop_server();\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.cert.X509AttributeCertificateHolder.getSignatureAlgorithm",
	"Comment": "return the details of the signature algorithm used to create this attribute certificate.",
	"Method": "AlgorithmIdentifier getSignatureAlgorithm(){\r\n    return attrCert.getSignatureAlgorithm();\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.ntru.polynomial.LongPolynomial2.sub",
	"Comment": "subtracts another polynomial which can have a different number of coefficients.",
	"Method": "void sub(LongPolynomial2 b){\r\n    if (b.coeffs.length > coeffs.length) {\r\n        coeffs = Arrays.copyOf(coeffs, b.coeffs.length);\r\n    }\r\n    for (int i = 0; i < b.coeffs.length; i++) {\r\n        coeffs[i] = (0x0800000800000L + coeffs[i] - b.coeffs[i]) & 0x7FF0007FFL;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.CertPathValidator.validate",
	"Comment": "validates the specified certification path using the specified algorithmparameter set.the certpath specified must be of a type that is supportedby the validation algorithm, otherwise aninvalidalgorithmparameterexception will be thrown. forexample, a certpathvalidator that implements the pkixalgorithm validates certpath objects of type x.509.",
	"Method": "CertPathValidatorResult validate(CertPath certPath,CertPathParameters params){\r\n    return validatorSpi.engineValidate(certPath, params);\r\n}"
}, {
	"Path": "org.bouncycastle.jce.provider.RFC3281CertPathUtilities.processAttrCert1",
	"Comment": "searches for a holder public key certificate and verifies itscertification path.",
	"Method": "CertPath processAttrCert1(X509AttributeCertificate attrCert,PKIXExtendedParameters pkixParams){\r\n    CertPathBuilderResult result = null;\r\n    Set holderPKCs = new HashSet();\r\n    if (attrCert.getHolder().getIssuer() != null) {\r\n        X509CertSelector selector = new X509CertSelector();\r\n        selector.setSerialNumber(attrCert.getHolder().getSerialNumber());\r\n        Principal[] principals = attrCert.getHolder().getIssuer();\r\n        for (int i = 0; i < principals.length; i++) {\r\n            try {\r\n                if (principals[i] instanceof X500Principal) {\r\n                    selector.setIssuer(((X500Principal) principals[i]).getEncoded());\r\n                }\r\n                holderPKCs.addAll(CertPathValidatorUtilities.findCertificates(new PKIXCertStoreSelector.Builder(selector).build(), pkixParams.getCertStores()));\r\n            } catch (AnnotatedException e) {\r\n                throw new ExtCertPathValidatorException(\"Public key certificate for attribute certificate cannot be searched.\", e);\r\n            } catch (IOException e) {\r\n                throw new ExtCertPathValidatorException(\"Unable to encode X500 principal.\", e);\r\n            }\r\n        }\r\n        if (holderPKCs.isEmpty()) {\r\n            throw new CertPathValidatorException(\"Public key certificate specified in base certificate ID for attribute certificate cannot be found.\");\r\n        }\r\n    }\r\n    if (attrCert.getHolder().getEntityNames() != null) {\r\n        X509CertStoreSelector selector = new X509CertStoreSelector();\r\n        Principal[] principals = attrCert.getHolder().getEntityNames();\r\n        for (int i = 0; i < principals.length; i++) {\r\n            try {\r\n                if (principals[i] instanceof X500Principal) {\r\n                    selector.setIssuer(((X500Principal) principals[i]).getEncoded());\r\n                }\r\n                holderPKCs.addAll(CertPathValidatorUtilities.findCertificates(new PKIXCertStoreSelector.Builder(selector).build(), pkixParams.getCertStores()));\r\n            } catch (AnnotatedException e) {\r\n                throw new ExtCertPathValidatorException(\"Public key certificate for attribute certificate cannot be searched.\", e);\r\n            } catch (IOException e) {\r\n                throw new ExtCertPathValidatorException(\"Unable to encode X500 principal.\", e);\r\n            }\r\n        }\r\n        if (holderPKCs.isEmpty()) {\r\n            throw new CertPathValidatorException(\"Public key certificate specified in entity name for attribute certificate cannot be found.\");\r\n        }\r\n    }\r\n    PKIXExtendedParameters.Builder paramsBldr = new PKIXExtendedParameters.Builder(pkixParams);\r\n    CertPathValidatorException lastException = null;\r\n    for (Iterator it = holderPKCs.iterator(); it.hasNext(); ) {\r\n        X509CertStoreSelector selector = new X509CertStoreSelector();\r\n        selector.setCertificate((X509Certificate) it.next());\r\n        paramsBldr.setTargetConstraints(new PKIXCertStoreSelector.Builder(selector).build());\r\n        CertPathBuilder builder = null;\r\n        try {\r\n            builder = CertPathBuilder.getInstance(\"PKIX\", BouncyCastleProvider.PROVIDER_NAME);\r\n        } catch (NoSuchProviderException e) {\r\n            throw new ExtCertPathValidatorException(\"Support class could not be created.\", e);\r\n        } catch (NoSuchAlgorithmException e) {\r\n            throw new ExtCertPathValidatorException(\"Support class could not be created.\", e);\r\n        }\r\n        try {\r\n            result = builder.build(new PKIXExtendedBuilderParameters.Builder(paramsBldr.build()).build());\r\n        } catch (CertPathBuilderException e) {\r\n            lastException = new ExtCertPathValidatorException(\"Certification path for public key certificate of attribute certificate could not be build.\", e);\r\n        } catch (InvalidAlgorithmParameterException e) {\r\n            throw new RuntimeException(e.getMessage());\r\n        }\r\n    }\r\n    if (lastException != null) {\r\n        throw lastException;\r\n    }\r\n    return result.getCertPath();\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPSignature.isCertification",
	"Comment": "return true if the passed in signature type represents a certification, false if the signature type is not.",
	"Method": "boolean isCertification(boolean isCertification,int signatureType){\r\n    return PGPSignature.DEFAULT_CERTIFICATION == signatureType || PGPSignature.NO_CERTIFICATION == signatureType || PGPSignature.CASUAL_CERTIFICATION == signatureType || PGPSignature.POSITIVE_CERTIFICATION == signatureType;\r\n}"
}, {
	"Path": "org.bouncycastle.tls.DTLSReplayWindow.shouldDiscard",
	"Comment": "check whether a received record with the given sequence number should be rejected as a duplicate.",
	"Method": "boolean shouldDiscard(long seq){\r\n    if ((seq & VALID_SEQ_MASK) != seq) {\r\n        return true;\r\n    }\r\n    if (seq <= latestConfirmedSeq) {\r\n        long diff = latestConfirmedSeq - seq;\r\n        if (diff >= WINDOW_SIZE) {\r\n            return true;\r\n        }\r\n        if ((bitmap & (1L << diff)) != 0) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.KeyGenerationParameters.getStrength",
	"Comment": "return the bit strength for keys produced by this generator,",
	"Method": "int getStrength(){\r\n    return strength;\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.getSubjectPublicKey",
	"Comment": "returns the subjectpublickey criterion. the x509certificatemust contain the specified subject public key. if null,no subjectpublickey check will be done.",
	"Method": "PublicKey getSubjectPublicKey(){\r\n    return subjectPublicKey;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.gmss.GMSSLeaf.getLog",
	"Comment": "this method returns the least integer that is greater or equal to thelogarithm to the base 2 of an integer intvalue.",
	"Method": "int getLog(int intValue){\r\n    int log = 1;\r\n    int i = 2;\r\n    while (i < intValue) {\r\n        i <<= 1;\r\n        log++;\r\n    }\r\n    return log;\r\n}"
}, {
	"Path": "org.bouncycastle.tls.crypto.impl.jcajce.srp.SRP6Server.calculateServerEvidenceMessage",
	"Comment": "computes the server evidence message m2 using the previously verified values.\tto be called after successfully verifying the client evidence message m1.",
	"Method": "BigInteger calculateServerEvidenceMessage(){\r\n    if (this.A == null || this.M1 == null || this.S == null) {\r\n        throw new IllegalStateException(\"Impossible to compute M2: \" + \"some data are missing from the previous operations (A,M1,S)\");\r\n    }\r\n    this.M2 = SRP6Util.calculateM2(digest, N, A, M1, S);\r\n    return M2;\r\n}"
}, {
	"Path": "org.bouncycastle.math.ec.ECCurve.precompute",
	"Comment": "compute a precompinfo for a point on this curve, under a given name. used byecmultipliers to save the precomputation for this ecpoint for useby subsequent multiplication.",
	"Method": "PreCompInfo precompute(ECPoint point,String name,PreCompCallback callback){\r\n    checkPoint(point);\r\n    Hashtable table;\r\n    synchronized (point) {\r\n        table = point.preCompTable;\r\n        if (null == table) {\r\n            point.preCompTable = table = new Hashtable(4);\r\n        }\r\n    }\r\n    synchronized (table) {\r\n        PreCompInfo existing = (PreCompInfo) table.get(name);\r\n        PreCompInfo result = callback.precompute(existing);\r\n        if (result != existing) {\r\n            table.put(name, result);\r\n        }\r\n        return result;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.X509CertSelector.setPrivateKeyValid",
	"Comment": "sets the privatekeyvalid criterion. the specified date must fall withinthe private key validity period for the x509certificate. ifnull, no privatekeyvalid check will be done.note that the date supplied here is cloned to protect against subsequentmodifications.",
	"Method": "void setPrivateKeyValid(Date privateKeyValid){\r\n    if (privateKeyValid == null) {\r\n        this.privateKeyValid = null;\r\n    } else {\r\n        this.privateKeyValid = new Date(privateKeyValid.getTime());\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.mime.test.Base64TransferEncodingTest.testPartialLineEnding",
	"Comment": "this test causes the final line of base64 to not be a multiple of 64.",
	"Method": "void testPartialLineEnding(){\r\n    byte[][] original = new byte[4][48];\r\n    original[original.length - 1] = new byte[22];\r\n    ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    for (int i = 0; i != original.length; i++) {\r\n        byte[] row = original[i];\r\n        random.nextBytes(row);\r\n        bos.write(Base64.encode(row));\r\n        bos.write('\\r');\r\n        bos.write('\\n');\r\n    }\r\n    verifyDecode(original, bos);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.agreement.jpake.JPAKEUtil.validateMacTag",
	"Comment": "validates the mactag received from the partner participant.",
	"Method": "void validateMacTag(String participantId,String partnerParticipantId,BigInteger gx1,BigInteger gx2,BigInteger gx3,BigInteger gx4,BigInteger keyingMaterial,Digest digest,BigInteger partnerMacTag){\r\n    BigInteger expectedMacTag = calculateMacTag(partnerParticipantId, participantId, gx3, gx4, gx1, gx2, keyingMaterial, digest);\r\n    if (!expectedMacTag.equals(partnerMacTag)) {\r\n        throw new CryptoException(\"Partner MacTag validation failed. \" + \"Therefore, the password, MAC, or digest algorithm of each participant does not match.\");\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.CertPathValidator.getInstance",
	"Comment": "returns a certpathvalidator object that implements thespecified algorithm, as supplied by the specified provider.",
	"Method": "CertPathValidator getInstance(String algorithm,CertPathValidator getInstance,String algorithm,String provider,CertPathValidator getInstance,String algorithm,Provider provider){\r\n    if (provider == null) {\r\n        throw new IllegalArgumentException(\"provider must be non-null\");\r\n    }\r\n    CertUtil.Implementation imp = CertUtil.getImplementation(\"CertPathValidator\", algorithm, provider);\r\n    if (imp != null) {\r\n        return new CertPathValidator((CertPathValidatorSpi) imp.getEngine(), provider, algorithm);\r\n    }\r\n    throw new NoSuchAlgorithmException(\"can't find algorithm \" + algorithm);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.prng.SP800SecureRandomBuilder.setSecurityStrength",
	"Comment": "set the security strength required for drbgs used in building securerandom objects.",
	"Method": "SP800SecureRandomBuilder setSecurityStrength(int securityStrength){\r\n    this.securityStrength = securityStrength;\r\n    return this;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.X509AttributeCertificateHolder.toASN1Structure",
	"Comment": "return the underlying asn.1 structure for the attribute certificate in this holder.",
	"Method": "AttributeCertificate toASN1Structure(){\r\n    return attrCert;\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.spec.KTSParameterSpec.getKeyAlgorithmName",
	"Comment": "return the name of the algorithm for the wrapping key this key spec should use.",
	"Method": "String getKeyAlgorithmName(){\r\n    return wrappingKeyAlgorithm;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.engines.RSAEngine.getInputBlockSize",
	"Comment": "return the maximum size for an input block to this engine.for rsa this is always one byte less than the key size onencryption, and the same length as the key size on decryption.",
	"Method": "int getInputBlockSize(){\r\n    return core.getInputBlockSize();\r\n}"
}, {
	"Path": "org.bouncycastle.x509.X509AttributeCertStoreSelector.getSerialNumber",
	"Comment": "gets the serial number the attribute certificate must have.",
	"Method": "BigInteger getSerialNumber(){\r\n    return serialNumber;\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.setKeyUsage",
	"Comment": "sets the keyusage criterion. the x509certificate must allow the specifiedkeyusage values. if null, no keyusage check will be done. note that anx509certificate that has no keyusage extension implicitly allows allkeyusage values.note that the boolean array supplied here is cloned to protect againstsubsequent modifications.",
	"Method": "void setKeyUsage(boolean[] keyUsage){\r\n    if (keyUsage == null) {\r\n        this.keyUsage = null;\r\n    } else {\r\n        this.keyUsage = (boolean[]) keyUsage.clone();\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2Vector.setBit",
	"Comment": "set the coefficient at the given index to 1. if the index is out ofbounds, do nothing.",
	"Method": "void setBit(int index){\r\n    if (index >= length) {\r\n        throw new IndexOutOfBoundsException();\r\n    }\r\n    v[index >> 5] |= 1 << (index & 0x1f);\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.DERExternalParser.toASN1Primitive",
	"Comment": "return an derexternal representing this parser and its contents.",
	"Method": "ASN1Primitive toASN1Primitive(){\r\n    try {\r\n        return getLoadedObject();\r\n    } catch (IOException ioe) {\r\n        throw new ASN1ParsingException(\"unable to get DER object\", ioe);\r\n    } catch (IllegalArgumentException ioe) {\r\n        throw new ASN1ParsingException(\"unable to get DER object\", ioe);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.tsp.cms.CMSTimeStampedData.initialiseMessageImprintDigestCalculator",
	"Comment": "initialise the passed in calculator with the metadata for this message, if it isrequired as part of the initial message imprint calculation.",
	"Method": "void initialiseMessageImprintDigestCalculator(DigestCalculator calculator){\r\n    util.initialiseMessageImprintDigestCalculator(calculator);\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.jcajce.provider.test.McElieceCCA2PrimitivesTest.initKPG",
	"Comment": "initialize the key pair generator with the given parameters.",
	"Method": "void initKPG(int m,int t){\r\n    McElieceKeyGenParameterSpec params = new McElieceKeyGenParameterSpec(m, t);\r\n    kpg.initialize(params);\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.Permutation.equals",
	"Comment": "checks if given object is equal to this permutation.the method returns false whenever the given object is not permutation.",
	"Method": "boolean equals(Object other){\r\n    if (!(other instanceof Permutation)) {\r\n        return false;\r\n    }\r\n    Permutation otherPerm = (Permutation) other;\r\n    return IntUtils.equals(perm, otherPerm.perm);\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.rainbow.Layer.getViNext",
	"Comment": "getter for the number of vinegar variables of the next layer.",
	"Method": "int getViNext(){\r\n    return viNext;\r\n}"
}, {
	"Path": "org.bouncycastle.openssl.PEMParser.readObject",
	"Comment": "read the next pem object attempting to interpret the header andcreate a higher level object from the content.",
	"Method": "Object readObject(){\r\n    PemObject obj = readPemObject();\r\n    if (obj != null) {\r\n        String type = obj.getType();\r\n        if (parsers.containsKey(type)) {\r\n            return ((PemObjectParser) parsers.get(type)).parseObject(obj);\r\n        } else {\r\n            throw new IOException(\"unrecognised object: \" + type);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.gmss.Treehash.setFirstNode",
	"Comment": "this method sets the first node stored in the treehash instance itself",
	"Method": "void setFirstNode(byte[] hash){\r\n    if (!this.isInitialized) {\r\n        this.initialize();\r\n    }\r\n    this.firstNode = hash;\r\n    this.firstNodeHeight = this.maxHeight;\r\n    this.isFinished = true;\r\n}"
}, {
	"Path": "org.bouncycastle.cms.PasswordRecipientInformation.getKeyDerivationAlgorithm",
	"Comment": "return the key derivation algorithm details for the key in this recipient.",
	"Method": "AlgorithmIdentifier getKeyDerivationAlgorithm(){\r\n    return info.getKeyDerivationAlgorithm();\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.ch1_titlepane.BETitlePane.getFrame",
	"Comment": "returns the frame rendering in. this will return null if the\tjrootpane is not contained in a frame.",
	"Method": "Frame getFrame(){\r\n    Window window = getWindow();\r\n    if (window instanceof Frame) {\r\n        return (Frame) window;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPPublicKeyRingCollection.getKeyRings",
	"Comment": "return an iterator of the key rings associated with the passed in userid.",
	"Method": "Iterator<PGPPublicKeyRing> getKeyRings(Iterator<PGPPublicKeyRing> getKeyRings,String userID,Iterator<PGPPublicKeyRing> getKeyRings,String userID,boolean matchPartial,Iterator<PGPPublicKeyRing> getKeyRings,String userID,boolean matchPartial,boolean ignoreCase){\r\n    Iterator it = this.getKeyRings();\r\n    List rings = new ArrayList();\r\n    if (ignoreCase) {\r\n        userID = Strings.toLowerCase(userID);\r\n    }\r\n    while (it.hasNext()) {\r\n        PGPPublicKeyRing pubRing = (PGPPublicKeyRing) it.next();\r\n        Iterator uIt = pubRing.getPublicKey().getUserIDs();\r\n        while (uIt.hasNext()) {\r\n            String next = (String) uIt.next();\r\n            if (ignoreCase) {\r\n                next = Strings.toLowerCase(next);\r\n            }\r\n            if (matchPartial) {\r\n                if (next.indexOf(userID) > -1) {\r\n                    rings.add(pubRing);\r\n                }\r\n            } else {\r\n                if (next.equals(userID)) {\r\n                    rings.add(pubRing);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return rings.iterator();\r\n}"
}, {
	"Path": "org.bouncycastle.mail.smime.SMIMECompressedGenerator.make",
	"Comment": "generate an compressed object that contains an smime compressedobject using the given compression algorithm.",
	"Method": "MimeBodyPart make(MimeBodyPart content,OutputCompressor compressor){\r\n    try {\r\n        MimeBodyPart data = new MimeBodyPart();\r\n        data.setContent(new ContentCompressor(content, compressor), COMPRESSED_CONTENT_TYPE);\r\n        data.addHeader(\"Content-Type\", COMPRESSED_CONTENT_TYPE);\r\n        data.addHeader(\"Content-Disposition\", \"attachment; filename=\\\"smime.p7z\\\"\");\r\n        data.addHeader(\"Content-Description\", \"S/MIME Compressed Message\");\r\n        data.addHeader(\"Content-Transfer-Encoding\", encoding);\r\n        return data;\r\n    } catch (MessagingException e) {\r\n        throw new SMIMEException(\"exception putting multi-part together.\", e);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSSignedDataGenerator.generateCounterSigners",
	"Comment": "generate a set of one or more signerinformation objects representing counter signatures onthe passed in signerinformation object.",
	"Method": "SignerInformationStore generateCounterSigners(SignerInformation signer){\r\n    return this.generate(new CMSProcessableByteArray(null, signer.getSignature()), false).getSignerInfos();\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.util.JcaJceUtils.extractParameters",
	"Comment": "extract an asn.1 encodable from an algorithmparameters object.",
	"Method": "ASN1Encodable extractParameters(AlgorithmParameters params){\r\n    ASN1Encodable asn1Params;\r\n    try {\r\n        asn1Params = ASN1Primitive.fromByteArray(params.getEncoded(\"ASN.1\"));\r\n    } catch (Exception ex) {\r\n        asn1Params = ASN1Primitive.fromByteArray(params.getEncoded());\r\n    }\r\n    return asn1Params;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.eac.CVCertificate.getSignature",
	"Comment": "gives the signature of the whole body. type of signature is given inthe iso7816certificatebody.iso7816publickey.asn1objectidentifier",
	"Method": "byte[] getSignature(){\r\n    return Arrays.clone(signature);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.modes.PaddedBlockCipher.getUpdateOutputSize",
	"Comment": "return the size of the output buffer required for an update an input of len bytes.",
	"Method": "int getUpdateOutputSize(int len){\r\n    int total = len + bufOff;\r\n    int leftOver = total % buf.length;\r\n    if (leftOver == 0) {\r\n        return total - buf.length;\r\n    }\r\n    return total - leftOver;\r\n}"
}, {
	"Path": "com.sun.swingset3.SwingSet3.registerPopups",
	"Comment": "code snippet key for the their creation code inside the source",
	"Method": "void registerPopups(Component component){\r\n    if (component instanceof Container) {\r\n        Component[] children = ((Container) component).getComponents();\r\n        for (Component child : children) {\r\n            if (child instanceof JComponent) {\r\n                registerPopups(child);\r\n            }\r\n        }\r\n    }\r\n    if (component instanceof JComponent) {\r\n        JComponent jcomponent = (JComponent) component;\r\n        String snippetKey = (String) jcomponent.getClientProperty(\"snippetKey\");\r\n        if (snippetKey != null) {\r\n            jcomponent.setComponentPopupMenu(popup);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.DERSequenceParser.getLoadedObject",
	"Comment": "return an in memory, encodable, representation of the sequence.",
	"Method": "ASN1Primitive getLoadedObject(){\r\n    return new DERSequence(_parser.readVector());\r\n}"
}, {
	"Path": "org.bouncycastle.cert.ocsp.BasicOCSPResp.getSignatureAlgorithmID",
	"Comment": "return the algorithm identifier describing the signature used in the response.",
	"Method": "AlgorithmIdentifier getSignatureAlgorithmID(){\r\n    return resp.getSignatureAlgorithm();\r\n}"
}, {
	"Path": "org.bouncycastle.cms.jcajce.JceCMSContentEncryptorBuilder.setAlgorithmParameters",
	"Comment": "provide a set of algorithm parameters for the content encryption cipher to use.",
	"Method": "JceCMSContentEncryptorBuilder setAlgorithmParameters(AlgorithmParameters algorithmParameters){\r\n    this.algorithmParameters = algorithmParameters;\r\n    return this;\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSSignedData.getAttributeCertificates",
	"Comment": "return any x.509 attribute certificate objects in this signeddata structure as a store of x509attributecertificateholder objects.",
	"Method": "Store<X509AttributeCertificateHolder> getAttributeCertificates(){\r\n    return HELPER.getAttributeCertificates(signedData.getCertificates());\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.gmss.util.GMSSRandom.nextSeed",
	"Comment": "computes the next seed value, returns a random byte array and setsoutseed to the next value",
	"Method": "byte[] nextSeed(byte[] outseed){\r\n    byte[] rand = new byte[outseed.length];\r\n    messDigestTree.update(outseed, 0, outseed.length);\r\n    rand = new byte[messDigestTree.getDigestSize()];\r\n    messDigestTree.doFinal(rand, 0);\r\n    addByteArrays(outseed, rand);\r\n    addOne(outseed);\r\n    return rand;\r\n}"
}, {
	"Path": "org.bouncycastle.cms.SignerInformation.addCounterSigners",
	"Comment": "return a signer information object with passed in signerinformationstore representing countersignatures attached as an unsigned attribute.",
	"Method": "SignerInformation addCounterSigners(SignerInformation signerInformation,SignerInformationStore counterSigners){\r\n    SignerInfo sInfo = signerInformation.info;\r\n    AttributeTable unsignedAttr = signerInformation.getUnsignedAttributes();\r\n    ASN1EncodableVector v;\r\n    if (unsignedAttr != null) {\r\n        v = unsignedAttr.toASN1EncodableVector();\r\n    } else {\r\n        v = new ASN1EncodableVector();\r\n    }\r\n    ASN1EncodableVector sigs = new ASN1EncodableVector();\r\n    for (Iterator it = counterSigners.getSigners().iterator(); it.hasNext(); ) {\r\n        sigs.add(((SignerInformation) it.next()).toASN1Structure());\r\n    }\r\n    v.add(new Attribute(CMSAttributes.counterSignature, new DERSet(sigs)));\r\n    return new SignerInformation(new SignerInfo(sInfo.getSID(), sInfo.getDigestAlgorithm(), sInfo.getAuthenticatedAttributes(), sInfo.getDigestEncryptionAlgorithm(), sInfo.getEncryptedDigest(), new DERSet(v)), signerInformation.contentType, signerInformation.content, null);\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.xmss.WOTSPlus.getPublicKey",
	"Comment": "calculates a new public key based on the state of secretkeyseed,publicseed and otshashaddress.",
	"Method": "WOTSPlusPublicKeyParameters getPublicKey(OTSHashAddress otsHashAddress){\r\n    if (otsHashAddress == null) {\r\n        throw new NullPointerException(\"otsHashAddress == null\");\r\n    }\r\n    byte[][] publicKey = new byte[params.getLen()][];\r\n    for (int i = 0; i < params.getLen(); i++) {\r\n        otsHashAddress = (OTSHashAddress) new OTSHashAddress.Builder().withLayerAddress(otsHashAddress.getLayerAddress()).withTreeAddress(otsHashAddress.getTreeAddress()).withOTSAddress(otsHashAddress.getOTSAddress()).withChainAddress(i).withHashAddress(otsHashAddress.getHashAddress()).withKeyAndMask(otsHashAddress.getKeyAndMask()).build();\r\n        publicKey[i] = chain(expandSecretKeySeed(i), 0, params.getWinternitzParameter() - 1, otsHashAddress);\r\n    }\r\n    return new WOTSPlusPublicKeyParameters(params, publicKey);\r\n}"
}, {
	"Path": "org.bouncycastle.x509.X509V3CertificateGenerator.generateX509Certificate",
	"Comment": "generate an x509 certificate, based on the current issuer and subject,using the passed in provider for the signing and the supplied sourceof randomness, if required.",
	"Method": "X509Certificate generateX509Certificate(PrivateKey key,X509Certificate generateX509Certificate,PrivateKey key,SecureRandom random,X509Certificate generateX509Certificate,PrivateKey key,String provider,X509Certificate generateX509Certificate,PrivateKey key,String provider,SecureRandom random){\r\n    try {\r\n        return generate(key, provider, random);\r\n    } catch (NoSuchProviderException e) {\r\n        throw e;\r\n    } catch (SignatureException e) {\r\n        throw e;\r\n    } catch (InvalidKeyException e) {\r\n        throw e;\r\n    } catch (GeneralSecurityException e) {\r\n        throw new SecurityException(\"exception: \" + e);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.cert.selector.X509AttributeCertificateHolderSelectorBuilder.setIssuer",
	"Comment": "sets the issuer the attribute certificate must have. if nullis given any will do.",
	"Method": "void setIssuer(AttributeCertificateIssuer issuer){\r\n    this.issuer = issuer;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.cms.OriginatorPublicKey.getInstance",
	"Comment": "return an originatorpublickey object from a tagged object.",
	"Method": "OriginatorPublicKey getInstance(ASN1TaggedObject obj,boolean explicit,OriginatorPublicKey getInstance,Object obj){\r\n    if (obj instanceof OriginatorPublicKey) {\r\n        return (OriginatorPublicKey) obj;\r\n    }\r\n    if (obj != null) {\r\n        return new OriginatorPublicKey(ASN1Sequence.getInstance(obj));\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.ch1_titlepane.BETitlePane.createTitleButton",
	"Comment": "returns a jbutton appropriate for placement on the\ttitlepane.",
	"Method": "JButton createTitleButton(){\r\n    JButton button = new JButton();\r\n    button.setFocusPainted(false);\r\n    button.setFocusable(false);\r\n    button.setOpaque(true);\r\n    return button;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.provider.PrincipalUtils.getEncodedIssuerPrincipal",
	"Comment": "returns the issuer of an attribute certificate or certificate.",
	"Method": "X500Name getEncodedIssuerPrincipal(Object cert){\r\n    if (cert instanceof X509Certificate) {\r\n        return getIssuerPrincipal((X509Certificate) cert);\r\n    } else {\r\n        return X500Name.getInstance(((X500Principal) ((X509AttributeCertificate) cert).getIssuer().getPrincipals()[0]).getEncoded());\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.x9.X962NamedCurves.getNames",
	"Comment": "returns an enumeration containing the name strings for curvescontained in this structure.",
	"Method": "Enumeration getNames(){\r\n    return objIds.keys();\r\n}"
}, {
	"Path": "org.bouncycastle.tls.crypto.impl.jcajce.JcaTlsCryptoProvider.setProvider",
	"Comment": "set the provider of cryptographic services for any tlscrypto we build by name.",
	"Method": "JcaTlsCryptoProvider setProvider(Provider provider,JcaTlsCryptoProvider setProvider,String providerName){\r\n    this.helper = new NamedJcaJceHelper(providerName);\r\n    return this;\r\n}"
}, {
	"Path": "org.bouncycastle.tls.crypto.impl.jcajce.srp.SRP6Client.verifyServerEvidenceMessage",
	"Comment": "authenticates the server evidence message m2 received and saves it only if correct.",
	"Method": "boolean verifyServerEvidenceMessage(BigInteger serverM2){\r\n    if (this.A == null || this.M1 == null || this.S == null) {\r\n        throw new IllegalStateException(\"Impossible to compute and verify M2: \" + \"some data are missing from the previous operations (A,M1,S)\");\r\n    }\r\n    BigInteger computedM2 = SRP6Util.calculateM2(digest, N, A, M1, S);\r\n    if (computedM2.equals(serverM2)) {\r\n        this.M2 = serverM2;\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.bouncycastle.x509.ExtendedPKIXParameters.setStores",
	"Comment": "sets the bouncy castle stores for finding crls, certificates, attributecertificates or cross certificates.the list is cloned.",
	"Method": "void setStores(List stores){\r\n    if (stores == null) {\r\n        this.stores = new ArrayList();\r\n    } else {\r\n        for (Iterator i = stores.iterator(); i.hasNext(); ) {\r\n            if (!(i.next() instanceof Store)) {\r\n                throw new ClassCastException(\"All elements of list must be \" + \"of type org.bouncycastle.util.Store.\");\r\n            }\r\n        }\r\n        this.stores = new ArrayList(stores);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.jce.PKCS10CertificationRequest.verify",
	"Comment": "verify the request using the passed in public key and the provider..",
	"Method": "boolean verify(boolean verify,String provider,boolean verify,PublicKey pubKey,String provider){\r\n    Signature sig;\r\n    try {\r\n        if (provider == null) {\r\n            sig = Signature.getInstance(getSignatureName(sigAlgId));\r\n        } else {\r\n            sig = Signature.getInstance(getSignatureName(sigAlgId), provider);\r\n        }\r\n    } catch (NoSuchAlgorithmException e) {\r\n        if (oids.get(sigAlgId.getAlgorithm()) != null) {\r\n            String signatureAlgorithm = (String) oids.get(sigAlgId.getAlgorithm());\r\n            if (provider == null) {\r\n                sig = Signature.getInstance(signatureAlgorithm);\r\n            } else {\r\n                sig = Signature.getInstance(signatureAlgorithm, provider);\r\n            }\r\n        } else {\r\n            throw e;\r\n        }\r\n    }\r\n    setSignatureParameters(sig, sigAlgId.getParameters(), provider);\r\n    sig.initVerify(pubKey);\r\n    try {\r\n        sig.update(reqInfo.getEncoded(ASN1Encoding.DER));\r\n    } catch (Exception e) {\r\n        throw new SignatureException(\"exception encoding TBS cert request - \" + e);\r\n    }\r\n    return sig.verify(sigBits.getBytes());\r\n}"
}, {
	"Path": "org.bouncycastle.cms.OriginatorInformation.toASN1Structure",
	"Comment": "return the underlying asn.1 object defining this signerinformation object.",
	"Method": "OriginatorInfo toASN1Structure(){\r\n    return originatorInfo;\r\n}"
}, {
	"Path": "org.bouncycastle.x509.ExtendedPKIXParameters.getAdditionalStores",
	"Comment": "returns an immutable list of additional bouncy castlestores used for finding crls, certificates, attributecertificates or cross certificates.",
	"Method": "List getAdditionalStores(){\r\n    return Collections.unmodifiableList(additionalStores);\r\n}"
}, {
	"Path": "org.bouncycastle.jce.provider.JDKDSAPrivateKey.getEncoded",
	"Comment": "return a pkcs8 representation of the key. the sequence returnedrepresents a full privatekeyinfo object.",
	"Method": "byte[] getEncoded(){\r\n    try {\r\n        PrivateKeyInfo info = new PrivateKeyInfo(new AlgorithmIdentifier(X9ObjectIdentifiers.id_dsa, new DSAParameter(dsaSpec.getP(), dsaSpec.getQ(), dsaSpec.getG())), new ASN1Integer(getX()));\r\n        return info.getEncoded(ASN1Encoding.DER);\r\n    } catch (IOException e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.test.est.TestEnroll.testEnrollUsingTLSClientAuthAndPOP",
	"Comment": "test enrollment using tls do do the client authentication.in this test we are going to use the bc api to generate a client certificate that the server will accept.this test uses the bouncycastle ssl provider as it gives access to rfc5929 channel bindings.",
	"Method": "void testEnrollUsingTLSClientAuthAndPOP(){\r\n    ESTTestUtils.ensureProvider();\r\n    X509CertificateHolder caCert = ESTTestUtils.readPemCertificate(ESTServerUtils.makeRelativeToServerHome(\"/extCA/cacert.crt\"));\r\n    PrivateKey caPrivateKey = ESTTestUtils.readPemPrivateKey(ESTServerUtils.makeRelativeToServerHome(\"/extCA/private/cakey.pem\"), \"ECDSA\");\r\n    ECGenParameterSpec ecGenSpec = new ECGenParameterSpec(\"prime256v1\");\r\n    KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"ECDSA\", \"BC\");\r\n    kpg.initialize(ecGenSpec, new SecureRandom());\r\n    KeyPair originalKeyPair = kpg.generateKeyPair();\r\n    X500NameBuilder builder = new X500NameBuilder();\r\n    builder.addRDN(BCStyle.C, \"AU\");\r\n    builder.addRDN(BCStyle.CN, \"Bunyip Bluegum\");\r\n    builder.addRDN(BCStyle.O, \"Pudding Protectors\");\r\n    builder.addRDN(BCStyle.L, \"Victoria\");\r\n    X500Name name = builder.build();\r\n    KeyUsage keyUsage = new KeyUsage(KeyUsage.keyCertSign | KeyUsage.digitalSignature | KeyUsage.keyEncipherment | KeyUsage.dataEncipherment | KeyUsage.cRLSign);\r\n    ASN1EncodableVector purposes = new ASN1EncodableVector();\r\n    purposes.add(KeyPurposeId.id_kp_serverAuth);\r\n    purposes.add(KeyPurposeId.id_kp_clientAuth);\r\n    purposes.add(KeyPurposeId.anyExtendedKeyUsage);\r\n    X509Certificate clientTLSCert = ESTTestUtils.createASignedCert(\"SHA256WITHECDSA\", name, SubjectPublicKeyInfo.getInstance(originalKeyPair.getPublic().getEncoded()), caCert.getSubject(), caPrivateKey, 1, purposes, keyUsage);\r\n    KeyStore clientKeyStore = KeyStore.getInstance(\"JKS\");\r\n    clientKeyStore.load(null);\r\n    char[] clientKeyStorePass = \"tstpass\".toCharArray();\r\n    // This is hardcoded into the test server.\r\n    clientKeyStore.setKeyEntry(\"estuser\", originalKeyPair.getPrivate(), clientKeyStorePass, new Certificate[] { clientTLSCert });\r\n    clientKeyStore.store(new ByteArrayOutputStream(), clientKeyStorePass);\r\n    kpg.initialize(ecGenSpec);\r\n    KeyPair enrollmentPair = kpg.generateKeyPair();\r\n    ESTTestUtils.ensureProvider();\r\n    final ESTServerUtils.ServerInstance serverInstance = startDefaultServerTLSAndBasicAuth(0, true);\r\n    try {\r\n        TrustAnchor ta = new TrustAnchor(ESTTestUtils.toJavaX509Certificate(ESTTestUtils.readPemCertificate(ESTServerUtils.makeRelativeToServerHome(\"/estCA/cacert.crt\"))), null);\r\n        ChannelBindingProvider bcChannelBindingProvider = new BCChannelBindingProvider();\r\n        JsseESTServiceBuilder estServiceBuilder = new JsseESTServiceBuilder(\"localhost:8443\", JcaJceUtils.getCertPathTrustManager(ESTTestUtils.toTrustAnchor(ESTTestUtils.readPemCertificate(ESTServerUtils.makeRelativeToServerHome(\"/estCA/cacert.crt\"))), null));\r\n        estServiceBuilder.withKeyManagers(JcaJceUtils.createKeyManagerFactory(\"X509\", null, clientKeyStore, clientKeyStorePass).getKeyManagers()).withProvider(BouncyCastleJsseProvider.PROVIDER_NAME).withTLSVersion(\"TLS\");\r\n        ESTService est = estServiceBuilder.withChannelBindingProvider(bcChannelBindingProvider).addCipherSuites(new String[] { // \"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\",\r\n        \"TLS_DHE_DSS_WITH_AES_256_GCM_SHA384\", // \"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\",\r\n        \"TLS_DHE_DSS_WITH_AES_128_CBC_SHA256\", // \"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\",\r\n        \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA256\", // \"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\",\r\n        \"TLS_ECDHE_RSA_WITH_NULL_SHA\", // \"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\",\r\n        \"TLS_RSA_WITH_AES_128_CCM\", // \"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\",\r\n        \"TLS_RSA_WITH_AES_256_CBC_SHA\", // \"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\",\r\n        \"TLS_DHE_DSS_WITH_AES_128_GCM_SHA256\", // \"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\",\r\n        \"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\", // \"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\",\r\n        \"TLS_DHE_RSA_WITH_AES_256_GCM_SHA384\", \"TLS_DHE_RSA_WITH_AES_128_GCM_SHA256\", \"TLS_ECDHE_ECDSA_WITH_AES_256_CCM\", \"TLS_RSA_WITH_AES_256_CBC_SHA256\", \"TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA\", \"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\", \"TLS_DHE_DSS_WITH_AES_256_CBC_SHA\", \"TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA\", \"TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8\", \"TLS_RSA_WITH_AES_256_CCM_8\", \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA\", \"TLS_ECDHE_ECDSA_WITH_NULL_SHA\", \"TLS_RSA_WITH_NULL_SHA256\", \"TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA\", \"TLS_RSA_WITH_AES_128_CBC_SHA256\", \"TLS_RSA_WITH_AES_128_GCM_SHA256\", \"TLS_RSA_WITH_AES_256_CCM\", \"TLS_RSA_WITH_AES_256_GCM_SHA384\", \"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\", \"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384\", \"TLS_ECDHE_ECDSA_WITH_AES_128_CCM\", \"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256\", \"TLS_DHE_RSA_WITH_AES_256_CCM_8\", \"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\", \"TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8\", \"TLS_RSA_WITH_AES_128_CBC_SHA\", \"TLS_DHE_RSA_WITH_AES_128_CCM_8\", \"TLS_RSA_WITH_NULL_SHA\", \"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA\", \"TLS_RSA_WITH_3DES_EDE_CBC_SHA\", \"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384\", \"TLS_RSA_WITH_AES_128_CCM_8\", \"TLS_DHE_RSA_WITH_AES_256_CBC_SHA256\", \"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\", \"TLS_DHE_RSA_WITH_AES_256_CCM\", \"TLS_DHE_DSS_WITH_AES_256_CBC_SHA256\", \"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256\", \"TLS_DHE_RSA_WITH_AES_256_CBC_SHA\", \"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\", \"TLS_DHE_RSA_WITH_AES_128_CCM\", \"TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA\", \"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\", \"TLS_DHE_DSS_WITH_AES_128_CBC_SHA\", \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\" }).build();\r\n        PKCS10CertificationRequestBuilder pkcs10Builder = new JcaPKCS10CertificationRequestBuilder(new X500Name(\"CN=Test\"), enrollmentPair.getPublic());\r\n        ContentSigner contentSigner = new JcaContentSignerBuilder(\"SHA256WITHECDSA\").setProvider(\"BC\").build(enrollmentPair.getPrivate());\r\n        EnrollmentResponse enr = est.simpleEnrollPoP(false, pkcs10Builder, contentSigner, new JcaHttpAuthBuilder(\"estreal\", \"estuser\", \"estpwd\".toCharArray()).setProvider(\"BC\").setNonceGenerator(new SecureRandom()).build());\r\n        X509Certificate expectedCA = ESTTestUtils.toJavaX509Certificate(ESTTestUtils.readPemCertificate(ESTServerUtils.makeRelativeToServerHome(\"/estCA/cacert.crt\")));\r\n        X509CertificateHolder enrolledAsHolder = ESTService.storeToArray(enr.getStore())[0];\r\n        X509Certificate enrolled = ESTTestUtils.toJavaX509Certificate(enrolledAsHolder);\r\n        enrolled.verify(expectedCA.getPublicKey(), \"BC\");\r\n        System.out.println(ESTTestUtils.toJavaX509Certificate(enrolled));\r\n    } finally {\r\n        serverInstance.getServer().stop_server();\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.mail.smime.SMIMEToolkit.decrypt",
	"Comment": "decrypt the passed in mime message returning a part representing the decrypted content.",
	"Method": "MimeBodyPart decrypt(MimeBodyPart mimePart,RecipientId recipientId,Recipient recipient,MimeBodyPart decrypt,MimeMessage message,RecipientId recipientId,Recipient recipient){\r\n    try {\r\n        SMIMEEnvelopedParser m = new SMIMEEnvelopedParser(message);\r\n        RecipientInformationStore recipients = m.getRecipientInfos();\r\n        RecipientInformation recipientInformation = recipients.get(recipientId);\r\n        if (recipientInformation == null) {\r\n            return null;\r\n        }\r\n        return SMIMEUtil.toMimeBodyPart(recipientInformation.getContent(recipient));\r\n    } catch (CMSException e) {\r\n        throw new SMIMEException(\"CMS processing failure: \" + e.getMessage(), e);\r\n    } catch (IOException e) {\r\n        throw new SMIMEException(\"Parsing failure: \" + e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.PolicyQualifierInfo.getEncoded",
	"Comment": "returns the asn.1 der encoded form of thispolicyqualifierinfo.",
	"Method": "byte[] getEncoded(){\r\n    return (byte[]) encoded.clone();\r\n}"
}, {
	"Path": "org.bouncycastle.jce.provider.JCEECPrivateKey.getEncoded",
	"Comment": "return a pkcs8 representation of the key. the sequence returnedrepresents a full privatekeyinfo object.",
	"Method": "byte[] getEncoded(){\r\n    X962Parameters params;\r\n    if (ecSpec instanceof ECNamedCurveSpec) {\r\n        ASN1ObjectIdentifier curveOid = ECUtil.getNamedCurveOid(((ECNamedCurveSpec) ecSpec).getName());\r\n        if (curveOid == null) {\r\n            curveOid = new ASN1ObjectIdentifier(((ECNamedCurveSpec) ecSpec).getName());\r\n        }\r\n        params = new X962Parameters(curveOid);\r\n    } else if (ecSpec == null) {\r\n        params = new X962Parameters(DERNull.INSTANCE);\r\n    } else {\r\n        ECCurve curve = EC5Util.convertCurve(ecSpec.getCurve());\r\n        X9ECParameters ecP = new X9ECParameters(curve, EC5Util.convertPoint(curve, ecSpec.getGenerator(), withCompression), ecSpec.getOrder(), BigInteger.valueOf(ecSpec.getCofactor()), ecSpec.getCurve().getSeed());\r\n        params = new X962Parameters(ecP);\r\n    }\r\n    PrivateKeyInfo info;\r\n    ECPrivateKeyStructure keyStructure;\r\n    if (publicKey != null) {\r\n        keyStructure = new ECPrivateKeyStructure(this.getS(), publicKey, params);\r\n    } else {\r\n        keyStructure = new ECPrivateKeyStructure(this.getS(), params);\r\n    }\r\n    try {\r\n        if (algorithm.equals(\"ECGOST3410\")) {\r\n            info = new PrivateKeyInfo(new AlgorithmIdentifier(CryptoProObjectIdentifiers.gostR3410_2001, params.toASN1Primitive()), keyStructure.toASN1Primitive());\r\n        } else {\r\n            info = new PrivateKeyInfo(new AlgorithmIdentifier(X9ObjectIdentifiers.id_ecPublicKey, params.toASN1Primitive()), keyStructure.toASN1Primitive());\r\n        }\r\n        return info.getEncoded(ASN1Encoding.DER);\r\n    } catch (IOException e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.cms.AttributeTable.get",
	"Comment": "return the first attribute matching the object identifier oid.",
	"Method": "Attribute get(ASN1ObjectIdentifier oid){\r\n    Object value = attributes.get(oid);\r\n    if (value instanceof Vector) {\r\n        return (Attribute) ((Vector) value).elementAt(0);\r\n    }\r\n    return (Attribute) value;\r\n}"
}, {
	"Path": "org.bouncycastle.util.BigIntegers.createRandomPrime",
	"Comment": "return a prime number candidate of the specified bit length.",
	"Method": "BigInteger createRandomPrime(int bitLength,int certainty,SecureRandom random){\r\n    if (bitLength < 2) {\r\n        throw new IllegalArgumentException(\"bitLength < 2\");\r\n    }\r\n    BigInteger rv;\r\n    if (bitLength == 2) {\r\n        return (random.nextInt() < 0) ? TWO : THREE;\r\n    }\r\n    do {\r\n        byte[] base = createRandom(bitLength, random);\r\n        int xBits = 8 * base.length - bitLength;\r\n        byte lead = (byte) (1 << (7 - xBits));\r\n        base[0] |= lead;\r\n        base[base.length - 1] |= 0x01;\r\n        rv = new BigInteger(1, base);\r\n    } while (!rv.isProbablePrime(certainty));\r\n    return rv;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.x9.ECNamedCurveTable.getByOID",
	"Comment": "return a x9ecparameters object representing the passed in namedcurve.",
	"Method": "X9ECParameters getByOID(ASN1ObjectIdentifier oid){\r\n    X9ECParameters ecP = X962NamedCurves.getByOID(oid);\r\n    if (ecP == null) {\r\n        ecP = SECNamedCurves.getByOID(oid);\r\n    }\r\n    if (ecP == null) {\r\n        ecP = TeleTrusTNamedCurves.getByOID(oid);\r\n    }\r\n    if (ecP == null) {\r\n        ecP = ANSSINamedCurves.getByOID(oid);\r\n    }\r\n    if (ecP == null) {\r\n        ecP = fromDomainParameters(ECGOST3410NamedCurves.getByOID(oid));\r\n    }\r\n    if (ecP == null) {\r\n        ecP = GMNamedCurves.getByOID(oid);\r\n    }\r\n    return ecP;\r\n}"
}, {
	"Path": "java.security.cert.X509CRLSelector.setDateAndTime",
	"Comment": "sets the dateandtime criterion. the specified date must be equal to orlater than the value of the thisupdate component of thex509crl and earlier than the value of the nextupdatecomponent. there is no match if the x509crl does notcontain a nextupdate component. if null, no dateandtimecheck will be done.note that the date supplied here is cloned to protectagainst subsequent modifications.",
	"Method": "void setDateAndTime(Date dateAndTime){\r\n    if (dateAndTime == null) {\r\n        this.dateAndTime = null;\r\n    } else {\r\n        this.dateAndTime = new Date(dateAndTime.getTime());\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.jce.PrincipalUtil.getSubjectX509Principal",
	"Comment": "return the subject of the given cert as an x509principalobject.",
	"Method": "X509Principal getSubjectX509Principal(X509Certificate cert){\r\n    try {\r\n        TBSCertificateStructure tbsCert = TBSCertificateStructure.getInstance(ASN1Primitive.fromByteArray(cert.getTBSCertificate()));\r\n        return new X509Principal(X509Name.getInstance(tbsCert.getSubject()));\r\n    } catch (IOException e) {\r\n        throw new CertificateEncodingException(e.toString());\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.ntru.polynomial.IntegerPolynomial.mod3",
	"Comment": "takes each coefficient modulo 3 such that all coefficients are ternary.",
	"Method": "void mod3(){\r\n    for (int i = 0; i < coeffs.length; i++) {\r\n        coeffs[i] %= 3;\r\n        if (coeffs[i] > 1) {\r\n            coeffs[i] -= 3;\r\n        }\r\n        if (coeffs[i] < -1) {\r\n            coeffs[i] += 3;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.IntegerFunctions.leastCommonMultiple",
	"Comment": "computation of the least common multiple of a set of bigintegers.",
	"Method": "BigInteger leastCommonMultiple(BigInteger[] numbers){\r\n    int n = numbers.length;\r\n    BigInteger result = numbers[0];\r\n    for (int i = 1; i < n; i++) {\r\n        BigInteger gcd = result.gcd(numbers[i]);\r\n        result = result.multiply(numbers[i]).divide(gcd);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.bouncycastle.cms.jcajce.JceKeyTransRecipient.setProvider",
	"Comment": "set the provider to use for key recovery and content processing.",
	"Method": "JceKeyTransRecipient setProvider(Provider provider,JceKeyTransRecipient setProvider,String providerName){\r\n    this.helper = new EnvelopedDataHelper(new NamedJcaJceExtHelper(providerName));\r\n    this.contentHelper = helper;\r\n    return this;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.x509.Extensions.getExtensionParsedValue",
	"Comment": "return the parsed value of the extension represented by the object identifierpassed in.",
	"Method": "ASN1Encodable getExtensionParsedValue(ASN1ObjectIdentifier oid){\r\n    Extension ext = this.getExtension(oid);\r\n    if (ext != null) {\r\n        return ext.getParsedValue();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.BufferedBlockCipher.getUpdateOutputSize",
	"Comment": "return the size of the output buffer required for an update an input of len bytes.",
	"Method": "int getUpdateOutputSize(int len){\r\n    int total = len + bufOff;\r\n    int leftOver;\r\n    if (pgpCFB) {\r\n        if (forEncryption) {\r\n            leftOver = total % buf.length - (cipher.getBlockSize() + 2);\r\n        } else {\r\n            leftOver = total % buf.length;\r\n        }\r\n    } else {\r\n        leftOver = total % buf.length;\r\n    }\r\n    return total - leftOver;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.X509v2AttributeCertificateBuilder.build",
	"Comment": "generate an x509 certificate, based on the current issuer and subjectusing the passed in signer.",
	"Method": "X509AttributeCertificateHolder build(ContentSigner signer){\r\n    acInfoGen.setSignature(signer.getAlgorithmIdentifier());\r\n    if (!extGenerator.isEmpty()) {\r\n        acInfoGen.setExtensions(extGenerator.generate());\r\n    }\r\n    return CertUtils.generateFullAttrCert(signer, acInfoGen.generateAttributeCertificateInfo());\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.jcajce.provider.rainbow.BCRainbowPrivateKey.getB1",
	"Comment": "getter for the translation part of the private quadratic map l1.",
	"Method": "short[] getB1(){\r\n    return this.b1;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.jcajce.provider.rainbow.BCRainbowPrivateKey.getB2",
	"Comment": "getter for the translation part of the private quadratic map l2.",
	"Method": "short[] getB2(){\r\n    return this.b2;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.spec.ECParameterSpec.getG",
	"Comment": "return the base point we are using for these domain parameters.",
	"Method": "ECPoint getG(){\r\n    return G;\r\n}"
}, {
	"Path": "org.bouncycastle.tls.crypto.impl.jcajce.srp.SRP6Server.verifyClientEvidenceMessage",
	"Comment": "authenticates the received client evidence message m1 and saves it only if correct.\tto be called after calculating the secret s.",
	"Method": "boolean verifyClientEvidenceMessage(BigInteger clientM1){\r\n    if (this.A == null || this.B == null || this.S == null) {\r\n        throw new IllegalStateException(\"Impossible to compute and verify M1: \" + \"some data are missing from the previous operations (A,B,S)\");\r\n    }\r\n    BigInteger computedM1 = SRP6Util.calculateM1(digest, N, A, B, S);\r\n    if (computedM1.equals(clientM1)) {\r\n        this.M1 = clientM1;\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "java.security.cert.CertPathBuilder.getInstance",
	"Comment": "returns a certpathbuilder object that implements thespecified algorithm, as supplied by the specified provider.",
	"Method": "CertPathBuilder getInstance(String algorithm,CertPathBuilder getInstance,String algorithm,String provider,CertPathBuilder getInstance,String algorithm,Provider provider){\r\n    if (provider == null)\r\n        throw new IllegalArgumentException(\"provider must be non-null\");\r\n    CertUtil.Implementation imp = CertUtil.getImplementation(\"CertPathBuilder\", algorithm, provider);\r\n    if (imp != null) {\r\n        return new CertPathBuilder((CertPathBuilderSpi) imp.getEngine(), provider, algorithm);\r\n    }\r\n    throw new NoSuchAlgorithmException(\"can't find type \" + algorithm);\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.ntru.polynomial.IntegerPolynomial.toBinary3Tight",
	"Comment": "converts a polynomial with ternary coefficients to binary.",
	"Method": "byte[] toBinary3Tight(){\r\n    BigInteger sum = Constants.BIGINT_ZERO;\r\n    for (int i = coeffs.length - 1; i >= 0; i--) {\r\n        sum = sum.multiply(BigInteger.valueOf(3));\r\n        sum = sum.add(BigInteger.valueOf(coeffs[i] + 1));\r\n    }\r\n    int size = (BigInteger.valueOf(3).pow(coeffs.length).bitLength() + 7) / 8;\r\n    byte[] arr = sum.toByteArray();\r\n    if (arr.length < size) {\r\n        byte[] arr2 = new byte[size];\r\n        System.arraycopy(arr, 0, arr2, size - arr.length, arr.length);\r\n        return arr2;\r\n    }\r\n    if (arr.length > size) {\r\n        arr = Arrays.copyOfRange(arr, 1, arr.length);\r\n    }\r\n    return arr;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.dane.DANECertificateFetcher.fetch",
	"Comment": "fetch the certificates associated with the passed in email address if any exists.",
	"Method": "List fetch(String emailAddress){\r\n    DANEEntrySelector daneSelector = selectorFactory.createSelector(emailAddress);\r\n    List matches = fetcherFactory.build(daneSelector.getDomainName()).getEntries();\r\n    List certs = new ArrayList(matches.size());\r\n    for (Iterator it = matches.iterator(); it.hasNext(); ) {\r\n        DANEEntry next = (DANEEntry) it.next();\r\n        if (daneSelector.match(next)) {\r\n            certs.add(next.getCertificate());\r\n        }\r\n    }\r\n    return Collections.unmodifiableList(certs);\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.gm.GMNamedCurves.getNames",
	"Comment": "returns an enumeration containing the name strings for curvescontained in this structure.",
	"Method": "Enumeration getNames(){\r\n    return names.elements();\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.rainbow.util.GF2Field.addElem",
	"Comment": "this function calculates the sum of two elements as an operation in gf2^8",
	"Method": "short addElem(short x,short y){\r\n    return (short) (x ^ y);\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.DERT61String.getString",
	"Comment": "decode the encoded string and return it, 8 bit encoding assumed.",
	"Method": "String getString(){\r\n    return Strings.fromByteArray(string);\r\n}"
}, {
	"Path": "org.bouncycastle.cert.crmf.CertificateRequestMessage.hasControls",
	"Comment": "return whether or not this request has control values associated with it.",
	"Method": "boolean hasControls(){\r\n    return controls != null;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.asn1.RainbowPrivateKey.getB2",
	"Comment": "getter for the translation part of the private quadratic map l2.",
	"Method": "short[] getB2(){\r\n    return RainbowUtil.convertArray(b2);\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.asn1.RainbowPrivateKey.getB1",
	"Comment": "getter for the translation part of the private quadratic map l1.",
	"Method": "short[] getB1(){\r\n    return RainbowUtil.convertArray(b1);\r\n}"
}, {
	"Path": "org.bouncycastle.cms.SignerInformation.verify",
	"Comment": "verify that the given verifier can successfully verify the signature onthis signerinformation object.",
	"Method": "boolean verify(SignerInformationVerifier verifier){\r\n    Time signingTime = getSigningTime();\r\n    if (verifier.hasAssociatedCertificate()) {\r\n        if (signingTime != null) {\r\n            X509CertificateHolder dcv = verifier.getAssociatedCertificate();\r\n            if (!dcv.isValidOn(signingTime.getDate())) {\r\n                throw new CMSVerifierCertificateNotValidException(\"verifier not valid at signingTime\");\r\n            }\r\n        }\r\n    }\r\n    return doVerify(verifier);\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.ch1_titlepane.BETitlePane.installDefaults",
	"Comment": "installs the fonts and necessary properties on the metaltitlepane.",
	"Method": "void installDefaults(){\r\n    setFont(UIManager.getFont(\"InternalFrame.titleFont\", getLocale()));\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.eac.CVCertificate.getRole",
	"Comment": "return a bits field coded on one byte. for signification of theseveral bit see iso7816certificateholderauthorization",
	"Method": "int getRole(){\r\n    CertificateHolderAuthorization cha = certificateBody.getCertificateHolderAuthorization();\r\n    return cha.getAccessRights();\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.gmss.GMSSRootCalc.getStatInt",
	"Comment": "returns the status int array used by the gmssprivatekeyasn.1 class",
	"Method": "int[] getStatInt(){\r\n    int tailLength;\r\n    if (tailStack == null) {\r\n        tailLength = 0;\r\n    } else {\r\n        tailLength = tailStack.size();\r\n    }\r\n    int[] statInt = new int[8 + heightOfTree + tailLength];\r\n    statInt[0] = heightOfTree;\r\n    statInt[1] = mdLength;\r\n    statInt[2] = K;\r\n    statInt[3] = indexForNextSeed;\r\n    statInt[4] = heightOfNextSeed;\r\n    if (isFinished) {\r\n        statInt[5] = 1;\r\n    } else {\r\n        statInt[5] = 0;\r\n    }\r\n    if (isInitialized) {\r\n        statInt[6] = 1;\r\n    } else {\r\n        statInt[6] = 0;\r\n    }\r\n    statInt[7] = tailLength;\r\n    for (int i = 0; i < heightOfTree; i++) {\r\n        statInt[8 + i] = index[i];\r\n    }\r\n    for (int i = 0; i < tailLength; i++) {\r\n        statInt[8 + heightOfTree + i] = ((Integer) heightOfNodes.elementAt(i)).intValue();\r\n    }\r\n    return statInt;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.BigIntUtils.toIntArrayModQ",
	"Comment": "converts a biginteger array into an integer array, reducing allbigintegers mod q.",
	"Method": "int[] toIntArrayModQ(int q,BigInteger[] input){\r\n    BigInteger bq = BigInteger.valueOf(q);\r\n    int[] result = new int[input.length];\r\n    for (int i = 0; i < input.length; i++) {\r\n        result[i] = input[i].mod(bq).intValue();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.X509CertSelector.getPolicy",
	"Comment": "returns the policy criterion. the x509certificate mustinclude at least one of the specified policies in its certificatepolicies extension. if the set returned is empty, then thex509certificate must include at least some specifiedpolicy in its certificate policies extension. if the setreturned is null, no policy check will be performed.",
	"Method": "Set getPolicy(){\r\n    if (policy == null) {\r\n        return null;\r\n    }\r\n    return Collections.unmodifiableSet(policy);\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPSecretKeyRingCollection.contains",
	"Comment": "return true if a key matching the passed in key id is present, false otherwise.",
	"Method": "boolean contains(long keyID){\r\n    return getSecretKey(keyID) != null;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.generators.RSABlindingFactorGenerator.generateBlindingFactor",
	"Comment": "generate a suitable blind factor for the public key the generator was initialised with.",
	"Method": "BigInteger generateBlindingFactor(){\r\n    if (key == null) {\r\n        throw new IllegalStateException(\"generator not initialised\");\r\n    }\r\n    BigInteger m = key.getModulus();\r\n    int length = m.bitLength() - 1;\r\n    BigInteger factor;\r\n    BigInteger gcd;\r\n    do {\r\n        factor = BigIntegers.createRandomBigInteger(length, random);\r\n        gcd = factor.gcd(m);\r\n    } while (factor.equals(ZERO) || factor.equals(ONE) || !gcd.equals(ONE));\r\n    return factor;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.paddings.PKCS7Padding.addPadding",
	"Comment": "add the pad bytes to the passed in block, returning thenumber of bytes added.",
	"Method": "int addPadding(byte[] in,int inOff){\r\n    byte code = (byte) (in.length - inOff);\r\n    while (inOff < in.length) {\r\n        in[inOff] = code;\r\n        inOff++;\r\n    }\r\n    return code;\r\n}"
}, {
	"Path": "org.bouncycastle.util.Properties.setThreadOverride",
	"Comment": "enable the specified override property for the current thread only.",
	"Method": "boolean setThreadOverride(String propertyName,boolean enable){\r\n    boolean isSet = isOverrideSet(propertyName);\r\n    Map localProps = (Map) threadProperties.get();\r\n    if (localProps == null) {\r\n        localProps = new HashMap();\r\n    }\r\n    localProps.put(propertyName, enable ? \"true\" : \"false\");\r\n    threadProperties.set(localProps);\r\n    return isSet;\r\n}"
}, {
	"Path": "javax.crypto.KeyAgreement.doPhase",
	"Comment": "executes the next phase of this key agreement with the givenkey that was received from one of the other parties involved in this keyagreement.",
	"Method": "Key doPhase(Key key,boolean lastPhase){\r\n    return keyAgreeSpi.engineDoPhase(key, lastPhase);\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.teletrust.TeleTrusTNamedCurves.getName",
	"Comment": "return the named curve name represented by the given object identifier.",
	"Method": "String getName(ASN1ObjectIdentifier oid){\r\n    return (String) names.get(oid);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.BufferedAsymmetricBlockCipher.getOutputBlockSize",
	"Comment": "returns the maximum size of the block produced by this cipher.",
	"Method": "int getOutputBlockSize(){\r\n    return cipher.getOutputBlockSize();\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPPublicKey.getSignaturesForUserAttribute",
	"Comment": "return an iterator of signatures associated with the passed in user attributes.",
	"Method": "Iterator getSignaturesForUserAttribute(PGPUserAttributeSubpacketVector userAttributes){\r\n    for (int i = 0; i != ids.size(); i++) {\r\n        if (userAttributes.equals(ids.get(i))) {\r\n            return ((ArrayList) idSigs.get(i)).iterator();\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.getCertificate",
	"Comment": "returns the certificateequals criterion. the specifiedx509certificate must be equal to thex509certificate passed to the match method. ifnull, this check is not applied.",
	"Method": "X509Certificate getCertificate(){\r\n    return x509Cert;\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.ch1_titlepane.BETitlePane.createActions",
	"Comment": "create the actions that get associated with the\tbuttons and menu items.",
	"Method": "void createActions(){\r\n    closeAction = new CloseAction();\r\n    if (getWindowDecorationStyle() == JRootPane.FRAME) {\r\n        iconifyAction = new IconifyAction();\r\n        restoreAction = new RestoreAction();\r\n        maximizeAction = new MaximizeAction();\r\n        setupAction = new AbstractAction(UIManager.getString(\"BETitlePane.setupButtonText\", getLocale())) {\r\n            public void actionPerformed(ActionEvent e) {\r\n                JOptionPane.showMessageDialog(rootPane, \"This button just used for demo.\" + \"In the future,you can customize it.\\n\" + \"Now, you can set UIManager.put(\\\"RootPane.setupButtonVisible\\\", false) to hide it(detault is true).\\n\" + \"BeautyEye L&F developed by Jack Jiang, you can mail with jb2011@163.com.\");\r\n            }\r\n        };\r\n    }\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.ch1_titlepane.BETitlePane.createActions",
	"Comment": "create the actions that get associated with the\tbuttons and menu items.",
	"Method": "void createActions(){\r\n    JOptionPane.showMessageDialog(rootPane, \"This button just used for demo.\" + \"In the future,you can customize it.\\n\" + \"Now, you can set UIManager.put(\\\"RootPane.setupButtonVisible\\\", false) to hide it(detault is true).\\n\" + \"BeautyEye L&F developed by Jack Jiang, you can mail with jb2011@163.com.\");\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.engines.ThreefishEngine.bytesToWord",
	"Comment": "at least package protected for efficient access from inner class",
	"Method": "long bytesToWord(byte[] bytes,int off){\r\n    if ((off + 8) > bytes.length) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    long word = 0;\r\n    int index = off;\r\n    word = (bytes[index++] & 0xffL);\r\n    word |= (bytes[index++] & 0xffL) << 8;\r\n    word |= (bytes[index++] & 0xffL) << 16;\r\n    word |= (bytes[index++] & 0xffL) << 24;\r\n    word |= (bytes[index++] & 0xffL) << 32;\r\n    word |= (bytes[index++] & 0xffL) << 40;\r\n    word |= (bytes[index++] & 0xffL) << 48;\r\n    word |= (bytes[index++] & 0xffL) << 56;\r\n    return word;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.modes.GOFBBlockCipher.processBlock",
	"Comment": "process one block of input from the array in and write it tothe out array.",
	"Method": "int processBlock(byte[] in,int inOff,byte[] out,int outOff){\r\n    processBytes(in, inOff, blockSize, out, outOff);\r\n    return blockSize;\r\n}"
}, {
	"Path": "org.bouncycastle.x509.ExtendedPKIXParameters.setTargetCertConstraints",
	"Comment": "sets the required constraints on the target certificate. the constraintsare specified as an instance of x509certselector. ifnull, no constraints are defined.this method wraps the given x509certselector into ax509certstoreselector.note that the x509certselector specified is cloned toprotect against subsequent modifications.",
	"Method": "void setTargetCertConstraints(CertSelector selector){\r\n    super.setTargetCertConstraints(selector);\r\n    if (selector != null) {\r\n        this.selector = X509CertStoreSelector.getInstance((X509CertSelector) selector);\r\n    } else {\r\n        this.selector = null;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.CertPathBuilderException.getMessage",
	"Comment": "returns the detail message for this certpathbuilderexception.",
	"Method": "String getMessage(){\r\n    String message = super.getMessage();\r\n    if (message == null && cause == null) {\r\n        return null;\r\n    }\r\n    if (cause != null) {\r\n        return cause.getMessage();\r\n    }\r\n    return message;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.crmf.POPOSigningKeyInput.getSender",
	"Comment": "returns the sender field, or null if authinfo is publickeymac",
	"Method": "GeneralName getSender(){\r\n    return sender;\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPPublicKeyEncryptedData.getSymmetricAlgorithm",
	"Comment": "return the symmetric key algorithm required to decrypt the data protected by this object.",
	"Method": "int getSymmetricAlgorithm(PublicKeyDataDecryptorFactory dataDecryptorFactory){\r\n    byte[] plain = dataDecryptorFactory.recoverSessionData(keyData.getAlgorithm(), keyData.getEncSessionKey());\r\n    return plain[0];\r\n}"
}, {
	"Path": "org.bouncycastle.x509.util.LDAPStoreHelper.getCertificateRevocationLists",
	"Comment": "returns the certificate revocation lists for revoked certificates.",
	"Method": "Collection getCertificateRevocationLists(X509CRLStoreSelector selector){\r\n    String[] attrs = splitString(params.getCertificateRevocationListAttribute());\r\n    String[] attrNames = splitString(params.getLdapCertificateRevocationListAttributeName());\r\n    String[] issuerAttributeNames = splitString(params.getCertificateRevocationListIssuerAttributeName());\r\n    List list = cRLIssuerSearch(selector, attrs, attrNames, issuerAttributeNames);\r\n    Set resultSet = createCRLs(list, selector);\r\n    if (resultSet.size() == 0) {\r\n        X509CRLStoreSelector emptySelector = new X509CRLStoreSelector();\r\n        list = cRLIssuerSearch(emptySelector, attrs, attrNames, issuerAttributeNames);\r\n        resultSet.addAll(createCRLs(list, selector));\r\n    }\r\n    return resultSet;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.dane.DANEEntryStoreBuilder.build",
	"Comment": "build a danecertificatestore from the provided domainname details.",
	"Method": "DANEEntryStore build(String domainName){\r\n    return new DANEEntryStore(daneEntryFetcher.build(domainName).getEntries());\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.BeautyEyeLookAndFeelWin.initOtherResourceBundle",
	"Comment": "initialize the defaults table with the name of the other resourcebundleused for getting localized defaults.",
	"Method": "void initOtherResourceBundle(UIDefaults table){\r\n    table.addResourceBundle(\"org.jb2011.lnf.beautyeye.resources.beautyeye\");\r\n}"
}, {
	"Path": "org.bouncycastle.cert.X509AttributeCertificateHolder.getSignature",
	"Comment": "return the bytes making up the signature associated with this attribute certificate.",
	"Method": "byte[] getSignature(){\r\n    return attrCert.getSignatureValue().getOctets();\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSSignedDataParser.getCertificates",
	"Comment": "return any x.509 certificate objects in this signeddata structure as a store of x509certificateholder objects.",
	"Method": "Store getCertificates(){\r\n    populateCertCrlSets();\r\n    return HELPER.getCertificates(_certSet);\r\n}"
}, {
	"Path": "org.bouncycastle.x509.ExtendedPKIXParameters.getStores",
	"Comment": "returns an immutable list of bouncy castlestores used for finding crls, certificates, attributecertificates or cross certificates.",
	"Method": "List getStores(){\r\n    return Collections.unmodifiableList(new ArrayList(stores));\r\n}"
}, {
	"Path": "org.bouncycastle.cms.OriginatorInformation.getCertificates",
	"Comment": "return the certificates stored in the underlying originatorinfo object.",
	"Method": "Store getCertificates(){\r\n    ASN1Set certSet = originatorInfo.getCertificates();\r\n    if (certSet != null) {\r\n        List certList = new ArrayList(certSet.size());\r\n        for (Enumeration en = certSet.getObjects(); en.hasMoreElements(); ) {\r\n            ASN1Primitive obj = ((ASN1Encodable) en.nextElement()).toASN1Primitive();\r\n            if (obj instanceof ASN1Sequence) {\r\n                certList.add(new X509CertificateHolder(Certificate.getInstance(obj)));\r\n            }\r\n        }\r\n        return new CollectionStore(certList);\r\n    }\r\n    return new CollectionStore(new ArrayList());\r\n}"
}, {
	"Path": "org.bouncycastle.test.est.TestCACertsFetch.testFetchCaCertsChecksResponseUsingCertpath",
	"Comment": "this exercises the concept of bootstrapping as per rfc 7030.we fetch the ca certs from the server using a tls layer that will accept any certificate tendered by the server.in this situation some sort of out of band validation is expected for example, ask the user if they wish to proceed.this test will fetch the ca certs and use the certpath api to validate that the ca returned is as expected andit will use the certpath api to validate the certificates tendered during the tls handshake by the server.",
	"Method": "void testFetchCaCertsChecksResponseUsingCertpath(){\r\n    ESTTestUtils.ensureProvider();\r\n    X509CertificateHolder[] theirCAs = null;\r\n    final ESTServerUtils.ServerInstance serverInstance = startDefaultServer();\r\n    try {\r\n        ESTService est = new JsseESTServiceBuilder(\"localhost:8443\", JcaJceUtils.getTrustAllTrustManager()).build();\r\n        CACertsResponse caCertsResponse = est.getCACerts();\r\n        Assert.assertEquals(\"Returned ca certs should be 1\", ESTService.storeToArray(caCertsResponse.getCertificateStore()).length, 1);\r\n        X509CertificateHolder expectedCACert;\r\n        {\r\n            X509CertificateHolder[] _caCerts = ESTService.storeToArray(caCertsResponse.getCertificateStore());\r\n            FileReader fr = new FileReader(ESTServerUtils.makeRelativeToServerHome(\"/estCA/cacert.crt\"));\r\n            PemReader reader = new PemReader(fr);\r\n            expectedCACert = new X509CertificateHolder(reader.readPemObject().getContent());\r\n            reader.close();\r\n            fr.close();\r\n            assert _caCerts.length == 1;\r\n            assert expectedCACert.equals(_caCerts[0]);\r\n        }\r\n        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\", \"BC\");\r\n        CertPath cp = cf.generateCertPath(ESTTestUtils.toCertList(((SSLSession) caCertsResponse.getSession()).getPeerCertificates()));\r\n        CertPathValidator v = CertPathValidator.getInstance(\"PKIX\", \"BC\");\r\n        PKIXParameters pkixParameters = new PKIXParameters(ESTTestUtils.toTrustAnchor(expectedCACert));\r\n        pkixParameters.setRevocationEnabled(false);\r\n        v.validate(cp, pkixParameters);\r\n    } finally {\r\n        if (serverInstance != null) {\r\n            serverInstance.getServer().stop_server();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.engines.RijndaelEngine.InvMixColumn",
	"Comment": "mix the bytes of every column in a linear waythis is the opposite operation of mixcolumn",
	"Method": "void InvMixColumn(){\r\n    long r0, r1, r2, r3;\r\n    r0 = r1 = r2 = r3 = 0;\r\n    for (int j = 0; j < BC; j += 8) {\r\n        int a0 = (int) ((A0 >> j) & 0xff);\r\n        int a1 = (int) ((A1 >> j) & 0xff);\r\n        int a2 = (int) ((A2 >> j) & 0xff);\r\n        int a3 = (int) ((A3 >> j) & 0xff);\r\n        a0 = (a0 != 0) ? (logtable[a0 & 0xff] & 0xff) : -1;\r\n        a1 = (a1 != 0) ? (logtable[a1 & 0xff] & 0xff) : -1;\r\n        a2 = (a2 != 0) ? (logtable[a2 & 0xff] & 0xff) : -1;\r\n        a3 = (a3 != 0) ? (logtable[a3 & 0xff] & 0xff) : -1;\r\n        r0 |= (long) ((mul0xe(a0) ^ mul0xb(a1) ^ mul0xd(a2) ^ mul0x9(a3)) & 0xff) << j;\r\n        r1 |= (long) ((mul0xe(a1) ^ mul0xb(a2) ^ mul0xd(a3) ^ mul0x9(a0)) & 0xff) << j;\r\n        r2 |= (long) ((mul0xe(a2) ^ mul0xb(a3) ^ mul0xd(a0) ^ mul0x9(a1)) & 0xff) << j;\r\n        r3 |= (long) ((mul0xe(a3) ^ mul0xb(a0) ^ mul0xd(a1) ^ mul0x9(a2)) & 0xff) << j;\r\n    }\r\n    A0 = r0;\r\n    A1 = r1;\r\n    A2 = r2;\r\n    A3 = r3;\r\n}"
}, {
	"Path": "javax.crypto.Mac.getInstance",
	"Comment": "generates an mac object for the specified macalgorithm from the specified provider.",
	"Method": "Mac getInstance(String algorithm,Mac getInstance,String algorithm,String provider,Mac getInstance,String algorithm,Provider provider){\r\n    if (provider == null) {\r\n        throw new IllegalArgumentException(\"No provider specified to Mac.getInstance()\");\r\n    }\r\n    JCEUtil.Implementation imp = JCEUtil.getImplementation(\"Mac\", algorithm, provider);\r\n    if (imp == null) {\r\n        throw new NoSuchAlgorithmException(algorithm + \" not found\");\r\n    }\r\n    Mac mac = new Mac((MacSpi) imp.getEngine(), imp.getProvider(), algorithm);\r\n    return mac;\r\n}"
}, {
	"Path": "org.bouncycastle.x509.util.LDAPStoreHelper.getAttributeCertificateAttributes",
	"Comment": "returns an attribute certificate for an user.the attributecertificateattribute holds the privileges of a user",
	"Method": "Collection getAttributeCertificateAttributes(X509AttributeCertStoreSelector selector){\r\n    String[] attrs = splitString(params.getAttributeCertificateAttributeAttribute());\r\n    String[] attrNames = splitString(params.getLdapAttributeCertificateAttributeAttributeName());\r\n    String[] subjectAttributeNames = splitString(params.getAttributeCertificateAttributeSubjectAttributeName());\r\n    List list = attrCertSubjectSerialSearch(selector, attrs, attrNames, subjectAttributeNames);\r\n    Set resultSet = createAttributeCertificates(list, selector);\r\n    if (resultSet.size() == 0) {\r\n        X509AttributeCertStoreSelector emptySelector = new X509AttributeCertStoreSelector();\r\n        list = attrCertSubjectSerialSearch(emptySelector, attrs, attrNames, subjectAttributeNames);\r\n        resultSet.addAll(createAttributeCertificates(list, selector));\r\n    }\r\n    return resultSet;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2nPolynomialElement.squareThisBitwise",
	"Comment": "squares this gf2npolynomialelement by shifting left its bitstring andreducing. this is supposed to be the slowest method. use squareprecalc orsquarematrix instead.",
	"Method": "void squareThisBitwise(){\r\n    polynomial.squareThisBitwise();\r\n    reduceThis();\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSEnvelopedData.getUnprotectedAttributes",
	"Comment": "return a table of the unprotected attributes indexed bythe oid of the attribute.",
	"Method": "AttributeTable getUnprotectedAttributes(){\r\n    if (unprotectedAttributes == null) {\r\n        return null;\r\n    }\r\n    return new AttributeTable(unprotectedAttributes);\r\n}"
}, {
	"Path": "org.bouncycastle.util.CollectionStore.getMatches",
	"Comment": "return the matches in the collection for the passed in selector.",
	"Method": "Collection<T> getMatches(Selector<T> selector){\r\n    if (selector == null) {\r\n        return new ArrayList(_local);\r\n    } else {\r\n        List col = new ArrayList();\r\n        Iterator iter = _local.iterator();\r\n        while (iter.hasNext()) {\r\n            Object obj = iter.next();\r\n            if (selector.match(obj)) {\r\n                col.add(obj);\r\n            }\r\n        }\r\n        return col;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.generators.GOST3410ParametersGenerator.procedure_C",
	"Comment": "procedure cprocedure generates the a value from the given p,q,returning the a value.",
	"Method": "BigInteger procedure_C(BigInteger p,BigInteger q){\r\n    BigInteger pSub1 = p.subtract(ONE);\r\n    BigInteger pSub1DivQ = pSub1.divide(q);\r\n    int length = p.bitLength();\r\n    for (; ; ) {\r\n        BigInteger d = BigIntegers.createRandomBigInteger(length, init_random);\r\n        if (d.compareTo(ONE) > 0 && d.compareTo(pSub1) < 0) {\r\n            BigInteger a = d.modPow(pSub1DivQ, p);\r\n            if (a.compareTo(ONE) != 0) {\r\n                return a;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.prng.X931SecureRandomBuilder.build",
	"Comment": "construct a x9.31 secure random generator using the passed in engine and key. if predictionresistant is true thegenerator will be reseeded on each request.",
	"Method": "X931SecureRandom build(BlockCipher engine,KeyParameter key,boolean predictionResistant){\r\n    if (dateTimeVector == null) {\r\n        dateTimeVector = new byte[engine.getBlockSize()];\r\n        Pack.longToBigEndian(System.currentTimeMillis(), dateTimeVector, 0);\r\n    }\r\n    engine.init(true, key);\r\n    return new X931SecureRandom(random, new X931RNG(engine, dateTimeVector, entropySourceProvider.get(engine.getBlockSize() * 8)), predictionResistant);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.engines.RC564Engine.encryptBlock",
	"Comment": "encrypt the given block starting at the given offset and placethe result in the provided buffer starting at the given offset.",
	"Method": "int encryptBlock(byte[] in,int inOff,byte[] out,int outOff){\r\n    long A = bytesToWord(in, inOff) + _S[0];\r\n    long B = bytesToWord(in, inOff + bytesPerWord) + _S[1];\r\n    for (int i = 1; i <= _noRounds; i++) {\r\n        A = rotateLeft(A ^ B, B) + _S[2 * i];\r\n        B = rotateLeft(B ^ A, A) + _S[2 * i + 1];\r\n    }\r\n    wordToBytes(A, out, outOff);\r\n    wordToBytes(B, out, outOff + bytesPerWord);\r\n    return 2 * bytesPerWord;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.signers.X931Signer.generateSignature",
	"Comment": "generate a signature for the loaded message using the key we wereinitialised with.",
	"Method": "byte[] generateSignature(){\r\n    createSignatureBlock(trailer);\r\n    BigInteger t = new BigInteger(1, cipher.processBlock(block, 0, block.length));\r\n    clearBlock(block);\r\n    t = t.min(kParam.getModulus().subtract(t));\r\n    int size = BigIntegers.getUnsignedByteLength(kParam.getModulus());\r\n    return BigIntegers.asUnsignedByteArray(size, t);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.modes.CTSBlockCipher.getUpdateOutputSize",
	"Comment": "return the size of the output buffer required for an update an input of len bytes.",
	"Method": "int getUpdateOutputSize(int len){\r\n    int total = len + bufOff;\r\n    int leftOver = total % buf.length;\r\n    if (leftOver == 0) {\r\n        return total - buf.length;\r\n    }\r\n    return total - leftOver;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2nPolynomialElement.invertEEA",
	"Comment": "calculates the multiplicative inverse of this and returns theresult in a new gf2npolynomialelement.",
	"Method": "GF2nPolynomialElement invertEEA(){\r\n    if (isZero()) {\r\n        throw new ArithmeticException();\r\n    }\r\n    GF2Polynomial b = new GF2Polynomial(mDegree + 32, \"ONE\");\r\n    b.reduceN();\r\n    GF2Polynomial c = new GF2Polynomial(mDegree + 32);\r\n    c.reduceN();\r\n    GF2Polynomial u = getGF2Polynomial();\r\n    GF2Polynomial v = mField.getFieldPolynomial();\r\n    GF2Polynomial h;\r\n    int j;\r\n    u.reduceN();\r\n    while (!u.isOne()) {\r\n        u.reduceN();\r\n        v.reduceN();\r\n        j = u.getLength() - v.getLength();\r\n        if (j < 0) {\r\n            h = u;\r\n            u = v;\r\n            v = h;\r\n            h = b;\r\n            b = c;\r\n            c = h;\r\n            j = -j;\r\n            c.reduceN();\r\n        }\r\n        u.shiftLeftAddThis(v, j);\r\n        b.shiftLeftAddThis(c, j);\r\n    }\r\n    b.reduceN();\r\n    return new GF2nPolynomialElement((GF2nPolynomialField) mField, b);\r\n}"
}, {
	"Path": "org.bouncycastle.util.Fingerprint.calculateFingerprint",
	"Comment": "return a byte array containing a calculated fingerprint for the passed in input data.this calculation is compatible with the bc fips api.",
	"Method": "byte[] calculateFingerprint(byte[] input,byte[] calculateFingerprint,byte[] input,int bitLength){\r\n    if (bitLength % 8 != 0) {\r\n        throw new IllegalArgumentException(\"bitLength must be a multiple of 8\");\r\n    }\r\n    SHAKEDigest digest = new SHAKEDigest(256);\r\n    digest.update(input, 0, input.length);\r\n    byte[] rv = new byte[bitLength / 8];\r\n    digest.doFinal(rv, 0, bitLength / 8);\r\n    return rv;\r\n}"
}, {
	"Path": "org.bouncycastle.pkcs.PKCS10CertificationRequest.getSignatureAlgorithm",
	"Comment": "return the details of the signature algorithm used to create this request.",
	"Method": "AlgorithmIdentifier getSignatureAlgorithm(){\r\n    return certificationRequest.getSignatureAlgorithm();\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.ch1_titlepane.BETitlePane.createWindowPropertyChangeListener",
	"Comment": "returns the propertychangelistener to install on\tthe window.",
	"Method": "PropertyChangeListener createWindowPropertyChangeListener(){\r\n    return new PropertyChangeHandler();\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.engines.IDEAEngine.expandKey",
	"Comment": "the following function is used to expand the user key to the encryptionsubkey. the first 16 bytes are the user key, and the rest of the subkeyis calculated by rotating the previous 16 bytes by 25 bits to the left,and so on until the subkey is completed.",
	"Method": "int[] expandKey(byte[] uKey){\r\n    int[] key = new int[52];\r\n    if (uKey.length < 16) {\r\n        byte[] tmp = new byte[16];\r\n        System.arraycopy(uKey, 0, tmp, tmp.length - uKey.length, uKey.length);\r\n        uKey = tmp;\r\n    }\r\n    for (int i = 0; i < 8; i++) {\r\n        key[i] = bytesToWord(uKey, i * 2);\r\n    }\r\n    for (int i = 8; i < 52; i++) {\r\n        if ((i & 7) < 6) {\r\n            key[i] = ((key[i - 7] & 127) << 9 | key[i - 6] >> 7) & MASK;\r\n        } else if ((i & 7) == 6) {\r\n            key[i] = ((key[i - 7] & 127) << 9 | key[i - 14] >> 7) & MASK;\r\n        } else {\r\n            key[i] = ((key[i - 15] & 127) << 9 | key[i - 14] >> 7) & MASK;\r\n        }\r\n    }\r\n    return key;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.generators.GOST3410ParametersGenerator.generateParameters",
	"Comment": "which generates the p , q and a values from the given parameters,returning the gost3410parameters object.",
	"Method": "GOST3410Parameters generateParameters(){\r\n    BigInteger[] pq = new BigInteger[2];\r\n    BigInteger q = null, p = null, a = null;\r\n    int x0, c;\r\n    long x0L, cL;\r\n    if (typeproc == 1) {\r\n        x0 = init_random.nextInt();\r\n        c = init_random.nextInt();\r\n        switch(size) {\r\n            case 512:\r\n                procedure_A(x0, c, pq, 512);\r\n                break;\r\n            case 1024:\r\n                procedure_B(x0, c, pq);\r\n                break;\r\n            default:\r\n                throw new IllegalArgumentException(\"Ooops! key size 512 or 1024 bit.\");\r\n        }\r\n        p = pq[0];\r\n        q = pq[1];\r\n        a = procedure_C(p, q);\r\n        return new GOST3410Parameters(p, q, a, new GOST3410ValidationParameters(x0, c));\r\n    } else {\r\n        x0L = init_random.nextLong();\r\n        cL = init_random.nextLong();\r\n        switch(size) {\r\n            case 512:\r\n                procedure_Aa(x0L, cL, pq, 512);\r\n                break;\r\n            case 1024:\r\n                procedure_Bb(x0L, cL, pq);\r\n                break;\r\n            default:\r\n                throw new IllegalStateException(\"Ooops! key size 512 or 1024 bit.\");\r\n        }\r\n        p = pq[0];\r\n        q = pq[1];\r\n        a = procedure_C(p, q);\r\n        return new GOST3410Parameters(p, q, a, new GOST3410ValidationParameters(x0L, cL));\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.operator.jcajce.JcePGPDataEncryptorBuilder.setSecureRandom",
	"Comment": "provide a user defined source of randomness.if no securerandom is configured, a default securerandom will be used.",
	"Method": "JcePGPDataEncryptorBuilder setSecureRandom(SecureRandom random){\r\n    this.random = random;\r\n    return this;\r\n}"
}, {
	"Path": "javax.crypto.KeyGenerator.getInstance",
	"Comment": "generates a keygenerator object for the specified keyalgorithm from the specified provider.",
	"Method": "KeyGenerator getInstance(String algorithm,KeyGenerator getInstance,String algorithm,Provider provider,KeyGenerator getInstance,String algorithm,String provider){\r\n    if (provider == null) {\r\n        throw new IllegalArgumentException(\"No provider specified to KeyGenerator.getInstance()\");\r\n    }\r\n    JCEUtil.Implementation imp = JCEUtil.getImplementation(\"KeyGenerator\", algorithm, provider);\r\n    if (imp == null) {\r\n        throw new NoSuchAlgorithmException(algorithm + \" not found\");\r\n    }\r\n    KeyGenerator keyGen = new KeyGenerator((KeyGeneratorSpi) imp.getEngine(), imp.getProvider(), algorithm);\r\n    return keyGen;\r\n}"
}, {
	"Path": "org.bouncycastle.est.ESTService.getCACerts",
	"Comment": "query the est server for ca certificates.rfc7030 leans heavily on the verification phases of tls for both client and server verification.it does however define a bootstrapping mode where if the client does not have the necessary ca certificates tovalidate the server it can defer to an external source, such as a human, to formally accept the ca certs.if callers are using bootstrapping they must examine the cacertsresponse and validate it externally.",
	"Method": "CACertsResponse getCACerts(){\r\n    ESTResponse resp = null;\r\n    Exception finalThrowable = null;\r\n    CACertsResponse caCertsResponse = null;\r\n    URL url = null;\r\n    boolean failedBeforeClose = false;\r\n    try {\r\n        url = new URL(server + CACERTS);\r\n        ESTClient client = clientProvider.makeClient();\r\n        ESTRequest req = new ESTRequestBuilder(\"GET\", url).withClient(client).build();\r\n        resp = client.doRequest(req);\r\n        Store<X509CertificateHolder> caCerts = null;\r\n        Store<X509CRLHolder> crlHolderStore = null;\r\n        if (resp.getStatusCode() == 200) {\r\n            if (!\"application/pkcs7-mime\".equals(resp.getHeaders().getFirstValue(\"Content-Type\"))) {\r\n                String j = resp.getHeaders().getFirstValue(\"Content-Type\") != null ? \" got \" + resp.getHeaders().getFirstValue(\"Content-Type\") : \" but was not present.\";\r\n                throw new ESTException((\"Response : \" + url.toString() + \"Expecting application/pkcs7-mime \") + j, null, resp.getStatusCode(), resp.getInputStream());\r\n            }\r\n            try {\r\n                if (resp.getContentLength() != null && resp.getContentLength() > 0) {\r\n                    ASN1InputStream ain = new ASN1InputStream(resp.getInputStream());\r\n                    SimplePKIResponse spkr = new SimplePKIResponse(ContentInfo.getInstance((ASN1Sequence) ain.readObject()));\r\n                    caCerts = spkr.getCertificates();\r\n                    crlHolderStore = spkr.getCRLs();\r\n                }\r\n            } catch (Throwable ex) {\r\n                throw new ESTException(\"Decoding CACerts: \" + url.toString() + \" \" + ex.getMessage(), ex, resp.getStatusCode(), resp.getInputStream());\r\n            }\r\n        } else if (resp.getStatusCode() != 204) {\r\n            throw new ESTException(\"Get CACerts: \" + url.toString(), null, resp.getStatusCode(), resp.getInputStream());\r\n        }\r\n        caCertsResponse = new CACertsResponse(caCerts, crlHolderStore, req, resp.getSource(), clientProvider.isTrusted());\r\n    } catch (Throwable t) {\r\n        failedBeforeClose = true;\r\n        if (t instanceof ESTException) {\r\n            throw (ESTException) t;\r\n        } else {\r\n            throw new ESTException(t.getMessage(), t);\r\n        }\r\n    } finally {\r\n        if (resp != null) {\r\n            try {\r\n                resp.close();\r\n            } catch (Exception t) {\r\n                finalThrowable = t;\r\n            }\r\n        }\r\n    }\r\n    if (finalThrowable != null) {\r\n        if (finalThrowable instanceof ESTException) {\r\n            throw finalThrowable;\r\n        }\r\n        throw new ESTException(\"Get CACerts: \" + url.toString(), finalThrowable, resp.getStatusCode(), null);\r\n    }\r\n    return caCertsResponse;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2nPolynomial.shiftThisLeft",
	"Comment": "shifts left this by amount and stores the result inthis polynomialgf2n.",
	"Method": "void shiftThisLeft(int amount){\r\n    if (amount > 0) {\r\n        int i;\r\n        int oldSize = size;\r\n        GF2nField f = coeff[0].getField();\r\n        enlarge(size + amount);\r\n        for (i = oldSize - 1; i >= 0; i--) {\r\n            coeff[i + amount] = coeff[i];\r\n        }\r\n        if (coeff[0] instanceof GF2nPolynomialElement) {\r\n            for (i = amount - 1; i >= 0; i--) {\r\n                coeff[i] = GF2nPolynomialElement.ZERO((GF2nPolynomialField) f);\r\n            }\r\n        } else if (coeff[0] instanceof GF2nONBElement) {\r\n            for (i = amount - 1; i >= 0; i--) {\r\n                coeff[i] = GF2nONBElement.ZERO((GF2nONBField) f);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.tsp.TimeStampResponseGenerator.generateGrantedResponse",
	"Comment": "return a granted response, if the passed in request passes validation with the passed in status string and extra extensions.if gentime is null a timenotavailable or a validation exception occurs a tspvalidationexception willbe thrown. the parent tspexception will only occur on some sort of system failure.",
	"Method": "TimeStampResponse generateGrantedResponse(TimeStampRequest request,BigInteger serialNumber,Date genTime,TimeStampResponse generateGrantedResponse,TimeStampRequest request,BigInteger serialNumber,Date genTime,String statusString,TimeStampResponse generateGrantedResponse,TimeStampRequest request,BigInteger serialNumber,Date genTime,String statusString,Extensions additionalExtensions){\r\n    if (genTime == null) {\r\n        throw new TSPValidationException(\"The time source is not available.\", PKIFailureInfo.timeNotAvailable);\r\n    }\r\n    request.validate(acceptedAlgorithms, acceptedPolicies, acceptedExtensions);\r\n    status = PKIStatus.GRANTED;\r\n    statusStrings = new ASN1EncodableVector();\r\n    if (statusString != null) {\r\n        this.addStatusString(statusString);\r\n    }\r\n    PKIStatusInfo pkiStatusInfo = getPKIStatusInfo();\r\n    ContentInfo tstTokenContentInfo;\r\n    try {\r\n        tstTokenContentInfo = tokenGenerator.generate(request, serialNumber, genTime, additionalExtensions).toCMSSignedData().toASN1Structure();\r\n    } catch (TSPException e) {\r\n        throw e;\r\n    } catch (Exception e) {\r\n        throw new TSPException(\"Timestamp token received cannot be converted to ContentInfo\", e);\r\n    }\r\n    try {\r\n        return new TimeStampResponse(new DLSequence(new ASN1Encodable[] { pkiStatusInfo.toASN1Primitive(), tstTokenContentInfo.toASN1Primitive() }));\r\n    } catch (IOException e) {\r\n        throw new TSPException(\"created badly formatted response!\");\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.x509.X509AttributeCertStoreSelector.getTargetNames",
	"Comment": "gets the target names. the collection consists of listsmade up of an integer in the first entry and a der encodedbyte array or a string in the second entry.the returned collection is immutable.",
	"Method": "Collection getTargetNames(){\r\n    return Collections.unmodifiableCollection(targetNames);\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPSecretKeyRingCollection.removeSecretKeyRing",
	"Comment": "return a new collection object containing the contents of this collection withthe passed in secret key ring removed.",
	"Method": "PGPSecretKeyRingCollection removeSecretKeyRing(PGPSecretKeyRingCollection ringCollection,PGPSecretKeyRing secretKeyRing){\r\n    Long key = new Long(secretKeyRing.getPublicKey().getKeyID());\r\n    if (!ringCollection.secretRings.containsKey(key)) {\r\n        throw new IllegalArgumentException(\"Collection does not contain a key with a keyID for the passed in ring.\");\r\n    }\r\n    Map newSecretRings = new HashMap(ringCollection.secretRings);\r\n    List newOrder = new ArrayList(ringCollection.order);\r\n    newSecretRings.remove(key);\r\n    for (int i = 0; i < newOrder.size(); i++) {\r\n        Long r = (Long) newOrder.get(i);\r\n        if (r.longValue() == key.longValue()) {\r\n            newOrder.remove(i);\r\n            break;\r\n        }\r\n    }\r\n    return new PGPSecretKeyRingCollection(newSecretRings, newOrder);\r\n}"
}, {
	"Path": "javax.crypto.CipherInputStream.close",
	"Comment": "closes this input stream and releases any system resources associated with the stream. the close method of cipherinputstreamcalls the close method of its underlying inputstream.",
	"Method": "void close(){\r\n    if (!finalized) {\r\n        finalized = true;\r\n        try {\r\n            c.doFinal();\r\n        } catch (Exception e) {\r\n            throw new IOException(\"error processing stream: \" + e.toString());\r\n        }\r\n    }\r\n    super.close();\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.ch1_titlepane.BETitlePane.createLayout",
	"Comment": "returns the layoutmanager that should be installed on\tthe metaltitlepane.",
	"Method": "LayoutManager createLayout(){\r\n    return new TitlePaneLayout();\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSAuthenticatedData.getUnauthAttrs",
	"Comment": "return a table of the undigested attributes indexed bythe oid of the attribute.",
	"Method": "AttributeTable getUnauthAttrs(){\r\n    if (unauthAttrs == null) {\r\n        return null;\r\n    }\r\n    return new AttributeTable(unauthAttrs);\r\n}"
}, {
	"Path": "org.bouncycastle.x509.AttributeCertificateHolder.getEntityNames",
	"Comment": "return any principal objects inside the attribute certificate holderentity names field.",
	"Method": "Principal[] getEntityNames(){\r\n    if (holder.getEntityName() != null) {\r\n        return getPrincipals(holder.getEntityName());\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.tls.crypto.impl.jcajce.srp.SRP6Client.calculateSessionKey",
	"Comment": "computes the final session key as a result of the srp successful mutual authentication\tto be called after verifying the server evidence message m2.",
	"Method": "BigInteger calculateSessionKey(){\r\n    if (this.S == null || this.M1 == null || this.M2 == null) {\r\n        throw new IllegalStateException(\"Impossible to compute Key: \" + \"some data are missing from the previous operations (S,M1,M2)\");\r\n    }\r\n    this.Key = SRP6Util.calculateKey(digest, N, S);\r\n    return Key;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.smime.SMIMECapabilities.getCapabilities",
	"Comment": "returns a vector with 0 or more objects of all the capabilitiesmatching the passed in capability oid. if the oid passed is null theentire set is returned.",
	"Method": "Vector getCapabilities(ASN1ObjectIdentifier capability){\r\n    Enumeration e = capabilities.getObjects();\r\n    Vector list = new Vector();\r\n    if (capability == null) {\r\n        while (e.hasMoreElements()) {\r\n            SMIMECapability cap = SMIMECapability.getInstance(e.nextElement());\r\n            list.addElement(cap);\r\n        }\r\n    } else {\r\n        while (e.hasMoreElements()) {\r\n            SMIMECapability cap = SMIMECapability.getInstance(e.nextElement());\r\n            if (capability.equals(cap.getCapabilityID())) {\r\n                list.addElement(cap);\r\n            }\r\n        }\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "org.bouncycastle.x509.AttributeCertificateHolder.getOtherObjectTypeID",
	"Comment": "returns the digest algorithm id if an object digest info is used.",
	"Method": "String getOtherObjectTypeID(){\r\n    if (holder.getObjectDigestInfo() != null) {\r\n        holder.getObjectDigestInfo().getOtherObjectTypeID().getId();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.generators.PKCS12ParametersGenerator.generateDerivedParameters",
	"Comment": "generate a key with initialisation vector parameter derived fromthe password, salt, and iteration count we are currently initialisedwith.",
	"Method": "CipherParameters generateDerivedParameters(int keySize,CipherParameters generateDerivedParameters,int keySize,int ivSize){\r\n    keySize = keySize / 8;\r\n    ivSize = ivSize / 8;\r\n    byte[] dKey = generateDerivedKey(KEY_MATERIAL, keySize);\r\n    byte[] iv = generateDerivedKey(IV_MATERIAL, ivSize);\r\n    return new ParametersWithIV(new KeyParameter(dKey, 0, keySize), iv, 0, ivSize);\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.BERTaggedObjectParser.toASN1Primitive",
	"Comment": "return an asn1taggedobject representing this parser and its contents.",
	"Method": "ASN1Primitive toASN1Primitive(){\r\n    try {\r\n        return this.getLoadedObject();\r\n    } catch (IOException e) {\r\n        throw new ASN1ParsingException(e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.x509.ExtendedPKIXBuilderParameters.getExcludedCerts",
	"Comment": "excluded certificates are not used for building a certification path.the returned set is immutable.",
	"Method": "Set getExcludedCerts(){\r\n    return Collections.unmodifiableSet(excludedCerts);\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.IntegerFunctions.gcd",
	"Comment": "computes the greatest common divisor of the two specified integers",
	"Method": "int gcd(int u,int v){\r\n    return BigInteger.valueOf(u).gcd(BigInteger.valueOf(v)).intValue();\r\n}"
}, {
	"Path": "org.bouncycastle.est.jcajce.JsseESTServiceBuilder.withProvider",
	"Comment": "configure this builder to use the provider with the passed in name.",
	"Method": "JsseESTServiceBuilder withProvider(String tlsProviderName,JsseESTServiceBuilder withProvider,Provider tlsProvider){\r\n    if (this.socketFactoryCreator != null) {\r\n        throw new IllegalStateException(\"Socket Factory Creator was defined in the constructor.\");\r\n    }\r\n    this.sslSocketFactoryCreatorBuilder.withProvider(tlsProvider);\r\n    return this;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.agreement.kdf.ConcatenationKDFGenerator.generateBytes",
	"Comment": "fill len bytes of the output buffer with bytes generated fromthe derivation function.",
	"Method": "int generateBytes(byte[] out,int outOff,int len){\r\n    if ((out.length - len) < outOff) {\r\n        throw new OutputLengthException(\"output buffer too small\");\r\n    }\r\n    byte[] hashBuf = new byte[hLen];\r\n    byte[] C = new byte[4];\r\n    int counter = 1;\r\n    int outputLen = 0;\r\n    digest.reset();\r\n    if (len > hLen) {\r\n        do {\r\n            ItoOSP(counter, C);\r\n            digest.update(C, 0, C.length);\r\n            digest.update(shared, 0, shared.length);\r\n            digest.update(otherInfo, 0, otherInfo.length);\r\n            digest.doFinal(hashBuf, 0);\r\n            System.arraycopy(hashBuf, 0, out, outOff + outputLen, hLen);\r\n            outputLen += hLen;\r\n        } while ((counter++) < (len / hLen));\r\n    }\r\n    if (outputLen < len) {\r\n        ItoOSP(counter, C);\r\n        digest.update(C, 0, C.length);\r\n        digest.update(shared, 0, shared.length);\r\n        digest.update(otherInfo, 0, otherInfo.length);\r\n        digest.doFinal(hashBuf, 0);\r\n        System.arraycopy(hashBuf, 0, out, outOff + outputLen, len - outputLen);\r\n    }\r\n    return len;\r\n}"
}, {
	"Path": "org.bouncycastle.cms.RecipientInformation.getContentDigest",
	"Comment": "return the content digest calculated during the read of the content if one has been generated. this willonly happen if we are dealing with authenticated data and authenticated attributes are present.",
	"Method": "byte[] getContentDigest(){\r\n    if (secureReadable instanceof CMSEnvelopedHelper.CMSDigestAuthenticatedSecureReadable) {\r\n        return ((CMSEnvelopedHelper.CMSDigestAuthenticatedSecureReadable) secureReadable).getDigest();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.DigestingMessageSigner.generateSignature",
	"Comment": "this function signs the message that has been updated, making use of theprivate key.",
	"Method": "byte[] generateSignature(){\r\n    if (!forSigning) {\r\n        throw new IllegalStateException(\"DigestingMessageSigner not initialised for signature generation.\");\r\n    }\r\n    byte[] hash = new byte[messDigest.getDigestSize()];\r\n    messDigest.doFinal(hash, 0);\r\n    return messSigner.generateSignature(hash);\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPEncryptedDataList.getEncryptedDataObjects",
	"Comment": "returns an iterator over the encryption method objects held in this list, in the order theyappeared in the stream they are read from.",
	"Method": "Iterator getEncryptedDataObjects(){\r\n    return list.iterator();\r\n}"
}, {
	"Path": "org.bouncycastle.pkcs.jcajce.JcePKCSPBEOutputEncryptorBuilder.setPRF",
	"Comment": "set the prf to use for key generation. by default this is hmacsha1.",
	"Method": "JcePKCSPBEOutputEncryptorBuilder setPRF(AlgorithmIdentifier prf){\r\n    if (pbkdf != null) {\r\n        throw new IllegalStateException(\"set PRF count using PBKDFDef\");\r\n    }\r\n    this.pbkdfBuilder.withPRF(prf);\r\n    return this;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.crmf.EncryptedValueBuilder.build",
	"Comment": "build an encryptedvalue structure containing the private key contained inthe passed info structure.",
	"Method": "EncryptedValue build(char[] revocationPassphrase,EncryptedValue build,X509CertificateHolder holder,EncryptedValue build,PrivateKeyInfo privateKeyInfo){\r\n    PKCS8EncryptedPrivateKeyInfoBuilder encInfoBldr = new PKCS8EncryptedPrivateKeyInfoBuilder(privateKeyInfo);\r\n    AlgorithmIdentifier intendedAlg = privateKeyInfo.getPrivateKeyAlgorithm();\r\n    AlgorithmIdentifier symmAlg = encryptor.getAlgorithmIdentifier();\r\n    DERBitString encSymmKey;\r\n    try {\r\n        PKCS8EncryptedPrivateKeyInfo encInfo = encInfoBldr.build(encryptor);\r\n        encSymmKey = new DERBitString(wrapper.generateWrappedKey(encryptor.getKey()));\r\n        AlgorithmIdentifier keyAlg = wrapper.getAlgorithmIdentifier();\r\n        ASN1OctetString valueHint = null;\r\n        return new EncryptedValue(intendedAlg, symmAlg, encSymmKey, keyAlg, valueHint, new DERBitString(encInfo.getEncryptedData()));\r\n    } catch (IllegalStateException e) {\r\n        throw new CRMFException(\"cannot encode key: \" + e.getMessage(), e);\r\n    } catch (OperatorException e) {\r\n        throw new CRMFException(\"cannot wrap key: \" + e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.BigIntUtils.toMinimalByteArray",
	"Comment": "return the value of big as a byte array. although bigintegerhas such a method, it uses an extra bit to indicate the sign of thenumber. for elliptic curve cryptography, the numbers usually arepositive. thus, this helper method returns a byte array of minimallength, ignoring the sign of the number.",
	"Method": "byte[] toMinimalByteArray(BigInteger value){\r\n    byte[] valBytes = value.toByteArray();\r\n    if ((valBytes.length == 1) || (value.bitLength() & 0x07) != 0) {\r\n        return valBytes;\r\n    }\r\n    byte[] result = new byte[value.bitLength() >> 3];\r\n    System.arraycopy(valBytes, 1, result, 0, result.length);\r\n    return result;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.ECGOST3410NamedCurveTable.getParameterSpec",
	"Comment": "return a parameter spec representing the passed in namedcurve. the routine returns null if the curve is not present.",
	"Method": "ECNamedCurveParameterSpec getParameterSpec(String name){\r\n    ECDomainParameters ecP = ECGOST3410NamedCurves.getByName(name);\r\n    if (ecP == null) {\r\n        try {\r\n            ecP = ECGOST3410NamedCurves.getByOID(new ASN1ObjectIdentifier(name));\r\n        } catch (IllegalArgumentException e) {\r\n            return null;\r\n        }\r\n    }\r\n    if (ecP == null) {\r\n        return null;\r\n    }\r\n    return new ECNamedCurveParameterSpec(name, ecP.getCurve(), ecP.getG(), ecP.getN(), ecP.getH(), ecP.getSeed());\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPPBEEncryptedData.getSymmetricAlgorithm",
	"Comment": "return the symmetric key algorithm required to decrypt the data protected by this object.",
	"Method": "int getSymmetricAlgorithm(PBEDataDecryptorFactory dataDecryptorFactory){\r\n    byte[] key = dataDecryptorFactory.makeKeyFromPassPhrase(keyData.getEncAlgorithm(), keyData.getS2K());\r\n    byte[] sessionData = dataDecryptorFactory.recoverSessionData(keyData.getEncAlgorithm(), key, keyData.getSecKeyData());\r\n    return sessionData[0];\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.io.CipherInputStream.close",
	"Comment": "closes the underlying input stream, and then finalises the processing of the data by thecipher.",
	"Method": "void close(){\r\n    try {\r\n        in.close();\r\n    } finally {\r\n        if (!finalized) {\r\n            finaliseCipher();\r\n        }\r\n    }\r\n    maxBuf = bufOff = 0;\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPObjectFactory.nextObject",
	"Comment": "return the next object in the stream, or null if the end of stream is reached.",
	"Method": "Object nextObject(){\r\n    List l;\r\n    switch(in.nextPacketTag()) {\r\n        case -1:\r\n            return null;\r\n        case PacketTags.SIGNATURE:\r\n            l = new ArrayList();\r\n            while (in.nextPacketTag() == PacketTags.SIGNATURE) {\r\n                try {\r\n                    l.add(new PGPSignature(in));\r\n                } catch (PGPException e) {\r\n                    throw new IOException(\"can't create signature object: \" + e);\r\n                }\r\n            }\r\n            return new PGPSignatureList((PGPSignature[]) l.toArray(new PGPSignature[l.size()]));\r\n        case PacketTags.SECRET_KEY:\r\n            try {\r\n                return new PGPSecretKeyRing(in, fingerPrintCalculator);\r\n            } catch (PGPException e) {\r\n                throw new IOException(\"can't create secret key object: \" + e);\r\n            }\r\n        case PacketTags.PUBLIC_KEY:\r\n            return new PGPPublicKeyRing(in, fingerPrintCalculator);\r\n        case PacketTags.PUBLIC_SUBKEY:\r\n            try {\r\n                return PGPPublicKeyRing.readSubkey(in, fingerPrintCalculator);\r\n            } catch (PGPException e) {\r\n                throw new IOException(\"processing error: \" + e.getMessage());\r\n            }\r\n        case PacketTags.COMPRESSED_DATA:\r\n            return new PGPCompressedData(in);\r\n        case PacketTags.LITERAL_DATA:\r\n            return new PGPLiteralData(in);\r\n        case PacketTags.PUBLIC_KEY_ENC_SESSION:\r\n        case PacketTags.SYMMETRIC_KEY_ENC_SESSION:\r\n            return new PGPEncryptedDataList(in);\r\n        case PacketTags.ONE_PASS_SIGNATURE:\r\n            l = new ArrayList();\r\n            while (in.nextPacketTag() == PacketTags.ONE_PASS_SIGNATURE) {\r\n                try {\r\n                    l.add(new PGPOnePassSignature(in));\r\n                } catch (PGPException e) {\r\n                    throw new IOException(\"can't create one pass signature object: \" + e);\r\n                }\r\n            }\r\n            return new PGPOnePassSignatureList((PGPOnePassSignature[]) l.toArray(new PGPOnePassSignature[l.size()]));\r\n        case PacketTags.MARKER:\r\n            return new PGPMarker(in);\r\n        case PacketTags.EXPERIMENTAL_1:\r\n        case PacketTags.EXPERIMENTAL_2:\r\n        case PacketTags.EXPERIMENTAL_3:\r\n        case PacketTags.EXPERIMENTAL_4:\r\n            return in.readPacket();\r\n    }\r\n    throw new IOException(\"unknown object in stream: \" + in.nextPacketTag());\r\n}"
}, {
	"Path": "org.bouncycastle.cert.X509v2AttributeCertificateBuilder.addExtension",
	"Comment": "add a given extension field for the standard extensions using a byte encoding of theextension value.",
	"Method": "X509v2AttributeCertificateBuilder addExtension(ASN1ObjectIdentifier oid,boolean isCritical,ASN1Encodable value,X509v2AttributeCertificateBuilder addExtension,ASN1ObjectIdentifier oid,boolean isCritical,byte[] encodedValue){\r\n    extGenerator.addExtension(extension);\r\n    return this;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.provider.BrokenKDF2BytesGenerator.generateBytes",
	"Comment": "fill len bytes of the output buffer with bytes generated fromthe derivation function.",
	"Method": "int generateBytes(byte[] out,int outOff,int len){\r\n    if ((out.length - len) < outOff) {\r\n        throw new OutputLengthException(\"output buffer too small\");\r\n    }\r\n    long oBits = len * 8L;\r\n    if (oBits > (digest.getDigestSize() * 8L * (1L << 32 - 1))) {\r\n        throw new IllegalArgumentException(\"Output length too large\");\r\n    }\r\n    int cThreshold = (int) (oBits / digest.getDigestSize());\r\n    byte[] dig = null;\r\n    dig = new byte[digest.getDigestSize()];\r\n    for (int counter = 1; counter <= cThreshold; counter++) {\r\n        digest.update(shared, 0, shared.length);\r\n        digest.update((byte) (counter & 0xff));\r\n        digest.update((byte) ((counter >> 8) & 0xff));\r\n        digest.update((byte) ((counter >> 16) & 0xff));\r\n        digest.update((byte) ((counter >> 24) & 0xff));\r\n        digest.update(iv, 0, iv.length);\r\n        digest.doFinal(dig, 0);\r\n        if ((len - outOff) > dig.length) {\r\n            System.arraycopy(dig, 0, out, outOff, dig.length);\r\n            outOff += dig.length;\r\n        } else {\r\n            System.arraycopy(dig, 0, out, outOff, len - outOff);\r\n        }\r\n    }\r\n    digest.reset();\r\n    return len;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.cms.ecc.MQVuserKeyingMaterial.getInstance",
	"Comment": "return an mqvuserkeyingmaterial object from a tagged object.",
	"Method": "MQVuserKeyingMaterial getInstance(ASN1TaggedObject obj,boolean explicit,MQVuserKeyingMaterial getInstance,Object obj){\r\n    if (obj instanceof MQVuserKeyingMaterial) {\r\n        return (MQVuserKeyingMaterial) obj;\r\n    } else if (obj != null) {\r\n        return new MQVuserKeyingMaterial(ASN1Sequence.getInstance(obj));\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPSignature.verifyCertification",
	"Comment": "verify a key certification, such as a revocation, for the passed in key.",
	"Method": "boolean verifyCertification(PGPUserAttributeSubpacketVector userAttributes,PGPPublicKey key,boolean verifyCertification,String id,PGPPublicKey key,boolean verifyCertification,byte[] rawID,PGPPublicKey key,boolean verifyCertification,PGPPublicKey masterKey,PGPPublicKey pubKey,boolean verifyCertification,PGPPublicKey pubKey){\r\n    if (verifier == null) {\r\n        throw new PGPException(\"PGPSignature not initialised - call init().\");\r\n    }\r\n    if (this.getSignatureType() != KEY_REVOCATION && this.getSignatureType() != SUBKEY_REVOCATION && this.getSignatureType() != DIRECT_KEY) {\r\n        throw new PGPException(\"signature is not a key signature\");\r\n    }\r\n    updateWithPublicKey(pubKey);\r\n    addTrailer();\r\n    return verifier.verify(this.getSignature());\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.ch10_internalframe.BEDesktopIconUI.getMinimumSize",
	"Comment": "windows desktop icons are restricted to a width of 160 pixels bydefault.this value is retrieved by the desktopicon.width property.",
	"Method": "Dimension getMinimumSize(JComponent c){\r\n    return new Dimension(width, desktopIcon.getLayout().minimumLayoutSize(desktopIcon).height);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.ec.CustomNamedCurves.getName",
	"Comment": "return the named curve name represented by the given object identifier.",
	"Method": "String getName(ASN1ObjectIdentifier oid){\r\n    return (String) oidToName.get(oid);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.io.CipherInputStream.read",
	"Comment": "reads data from the underlying stream and processes it with the cipher until the cipheroutputs data, and then returns up to len bytes in the provided array.if the underlying stream is exhausted by this call, the cipher will be finalised.",
	"Method": "int read(int read,byte[] b,int read,byte[] b,int off,int len){\r\n    if (bufOff >= maxBuf) {\r\n        if (nextChunk() < 0) {\r\n            return -1;\r\n        }\r\n    }\r\n    int toSupply = Math.min(len, available());\r\n    System.arraycopy(buf, bufOff, b, off, toSupply);\r\n    bufOff += toSupply;\r\n    return toSupply;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.signers.GOST3410Signer.generateSignature",
	"Comment": "generate a signature for the given message using the key we wereinitialised with. for conventional gost3410 the message should be a gost3411hash of the message of interest.",
	"Method": "BigInteger[] generateSignature(byte[] message){\r\n    byte[] mRev = new byte[message.length];\r\n    for (int i = 0; i != mRev.length; i++) {\r\n        mRev[i] = message[mRev.length - 1 - i];\r\n    }\r\n    BigInteger m = new BigInteger(1, mRev);\r\n    GOST3410Parameters params = key.getParameters();\r\n    BigInteger k;\r\n    do {\r\n        k = BigIntegers.createRandomBigInteger(params.getQ().bitLength(), random);\r\n    } while (k.compareTo(params.getQ()) >= 0);\r\n    BigInteger r = params.getA().modPow(k, params.getP()).mod(params.getQ());\r\n    BigInteger s = k.multiply(m).add(((GOST3410PrivateKeyParameters) key).getX().multiply(r)).mod(params.getQ());\r\n    BigInteger[] res = new BigInteger[2];\r\n    res[0] = r;\r\n    res[1] = s;\r\n    return res;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.ECKeyUtil.publicToExplicitParameters",
	"Comment": "convert a passed in public ec key to have explicit parameters. if the keyis already using explicit parameters it is returned.",
	"Method": "PublicKey publicToExplicitParameters(PublicKey key,String providerName,PublicKey publicToExplicitParameters,PublicKey key,Provider provider){\r\n    try {\r\n        SubjectPublicKeyInfo info = SubjectPublicKeyInfo.getInstance(ASN1Primitive.fromByteArray(key.getEncoded()));\r\n        if (info.getAlgorithmId().getAlgorithm().equals(CryptoProObjectIdentifiers.gostR3410_2001)) {\r\n            throw new IllegalArgumentException(\"cannot convert GOST key to explicit parameters.\");\r\n        } else {\r\n            X962Parameters params = X962Parameters.getInstance(info.getAlgorithmId().getParameters());\r\n            X9ECParameters curveParams;\r\n            if (params.isNamedCurve()) {\r\n                ASN1ObjectIdentifier oid = ASN1ObjectIdentifier.getInstance(params.getParameters());\r\n                curveParams = ECUtil.getNamedCurveByOid(oid);\r\n                curveParams = new X9ECParameters(curveParams.getCurve(), curveParams.getG(), curveParams.getN(), curveParams.getH());\r\n            } else if (params.isImplicitlyCA()) {\r\n                curveParams = new X9ECParameters(BouncyCastleProvider.CONFIGURATION.getEcImplicitlyCa().getCurve(), BouncyCastleProvider.CONFIGURATION.getEcImplicitlyCa().getG(), BouncyCastleProvider.CONFIGURATION.getEcImplicitlyCa().getN(), BouncyCastleProvider.CONFIGURATION.getEcImplicitlyCa().getH());\r\n            } else {\r\n                return key;\r\n            }\r\n            params = new X962Parameters(curveParams);\r\n            info = new SubjectPublicKeyInfo(new AlgorithmIdentifier(X9ObjectIdentifiers.id_ecPublicKey, params), info.getPublicKeyData().getBytes());\r\n            KeyFactory keyFact = KeyFactory.getInstance(key.getAlgorithm(), provider.getName());\r\n            return keyFact.generatePublic(new X509EncodedKeySpec(info.getEncoded()));\r\n        }\r\n    } catch (IllegalArgumentException e) {\r\n        throw e;\r\n    } catch (NoSuchAlgorithmException e) {\r\n        throw e;\r\n    } catch (Exception e) {\r\n        throw new UnexpectedException(e);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.LittleEndianConversions.OS2LIP",
	"Comment": "convert a byte array of length 8 beginning at inoff into along integer.",
	"Method": "long OS2LIP(byte[] input,int inOff){\r\n    long result = input[inOff++] & 0xff;\r\n    result |= (input[inOff++] & 0xff) << 8;\r\n    result |= (input[inOff++] & 0xff) << 16;\r\n    result |= ((long) input[inOff++] & 0xff) << 24;\r\n    result |= ((long) input[inOff++] & 0xff) << 32;\r\n    result |= ((long) input[inOff++] & 0xff) << 40;\r\n    result |= ((long) input[inOff++] & 0xff) << 48;\r\n    result |= ((long) input[inOff++] & 0xff) << 56;\r\n    return result;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.CertificateFactory.generateCertPath",
	"Comment": "generates a certpath object and initializes it witha list of certificates.the certificates supplied must be of a type supported by thecertificatefactory. they will be copied out of the suppliedlist object.",
	"Method": "CertPath generateCertPath(InputStream inStream,CertPath generateCertPath,InputStream inStream,String encoding,CertPath generateCertPath,List certificates){\r\n    return certFacSpi.engineGenerateCertPath(certificates);\r\n}"
}, {
	"Path": "org.bouncycastle.bcpg.BCPGOutputStream.finish",
	"Comment": "finish writing out the current packet without closing the underlying stream.",
	"Method": "void finish(){\r\n    if (partialBuffer != null) {\r\n        partialFlush(true);\r\n        Arrays.fill(partialBuffer, (byte) 0);\r\n        partialBuffer = null;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.pkcs.PKCS12PfxPdu.getMacAlgorithmID",
	"Comment": "return the algorithm identifier describing the mac algorithm",
	"Method": "AlgorithmIdentifier getMacAlgorithmID(){\r\n    MacData md = pfx.getMacData();\r\n    if (md != null) {\r\n        return md.getMac().getAlgorithmId();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.gmss.GMSSRootCalc.getAuthPath",
	"Comment": "returns the authentication path of the first leaf of the tree",
	"Method": "byte[][] getAuthPath(){\r\n    return GMSSUtils.clone(AuthPath);\r\n}"
}, {
	"Path": "org.bouncycastle.cert.X509CertificateHolder.isValidOn",
	"Comment": "return whether or not this certificate is valid on a particular date.",
	"Method": "boolean isValidOn(Date date){\r\n    return !date.before(x509Certificate.getStartDate().getDate()) && !date.after(x509Certificate.getEndDate().getDate());\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSSignedData.replaceSigners",
	"Comment": "replace the signerinformation store associated with thiscmssigneddata object with the new one passed in. you wouldprobably only want to do this if you wanted to change the unsigned attributes associated with a signer, or perhaps delete one.",
	"Method": "CMSSignedData replaceSigners(CMSSignedData signedData,SignerInformationStore signerInformationStore){\r\n    CMSSignedData cms = new CMSSignedData(signedData);\r\n    cms.signerInfoStore = signerInformationStore;\r\n    ASN1EncodableVector digestAlgs = new ASN1EncodableVector();\r\n    ASN1EncodableVector vec = new ASN1EncodableVector();\r\n    Iterator it = signerInformationStore.getSigners().iterator();\r\n    while (it.hasNext()) {\r\n        SignerInformation signer = (SignerInformation) it.next();\r\n        digestAlgs.add(CMSSignedHelper.INSTANCE.fixAlgID(signer.getDigestAlgorithmID()));\r\n        vec.add(signer.toASN1Structure());\r\n    }\r\n    ASN1Set digests = new DERSet(digestAlgs);\r\n    ASN1Set signers = new DERSet(vec);\r\n    ASN1Sequence sD = (ASN1Sequence) signedData.signedData.toASN1Primitive();\r\n    vec = new ASN1EncodableVector();\r\n    vec.add(sD.getObjectAt(0));\r\n    vec.add(digests);\r\n    for (int i = 2; i != sD.size() - 1; i++) {\r\n        vec.add(sD.getObjectAt(i));\r\n    }\r\n    vec.add(signers);\r\n    cms.signedData = SignedData.getInstance(new BERSequence(vec));\r\n    cms.contentInfo = new ContentInfo(cms.contentInfo.getContentType(), cms.signedData);\r\n    return cms;\r\n}"
}, {
	"Path": "org.bouncycastle.openssl.jcajce.JcaPKIXIdentityBuilder.build",
	"Comment": "build an identity from the passed in key and certificate stream in pem format.",
	"Method": "JcaPKIXIdentity build(File keyFile,File certificateFile,JcaPKIXIdentity build,InputStream keyStream,InputStream certificateStream){\r\n    PEMParser keyParser = new PEMParser(new InputStreamReader(keyStream));\r\n    PrivateKey privKey;\r\n    Object keyObj = keyParser.readObject();\r\n    if (keyObj instanceof PEMKeyPair) {\r\n        PEMKeyPair kp = (PEMKeyPair) keyObj;\r\n        privKey = keyConverter.getPrivateKey(kp.getPrivateKeyInfo());\r\n    } else if (keyObj instanceof PrivateKeyInfo) {\r\n        privKey = keyConverter.getPrivateKey((PrivateKeyInfo) keyObj);\r\n    } else {\r\n        throw new IOException(\"unrecognised private key file\");\r\n    }\r\n    PEMParser certParser = new PEMParser(new InputStreamReader(certificateStream));\r\n    List certs = new ArrayList();\r\n    Object certObj;\r\n    while ((certObj = certParser.readObject()) != null) {\r\n        certs.add(certConverter.getCertificate((X509CertificateHolder) certObj));\r\n    }\r\n    return new JcaPKIXIdentity(privKey, (X509Certificate[]) certs.toArray(new X509Certificate[certs.size()]));\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.X509CertSelector.setSubjectPublicKeyAlgID",
	"Comment": "sets the subjectpublickeyalgid criterion. the x509certificate mustcontain a subject public key with the specified algorithm. ifnull, no subjectpublickeyalgid check will be done.",
	"Method": "void setSubjectPublicKeyAlgID(String oid){\r\n    if (oid != null) {\r\n        CertUtil.parseOID(oid);\r\n        subjectKeyAlgID = new ASN1ObjectIdentifier(oid);\r\n    } else {\r\n        subjectKeyAlgID = null;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.signers.PSSSigner.verifySignature",
	"Comment": "return true if the internal state represents the signature describedin the passed in array.",
	"Method": "boolean verifySignature(byte[] signature){\r\n    contentDigest.doFinal(mDash, mDash.length - hLen - sLen);\r\n    try {\r\n        byte[] b = cipher.processBlock(signature, 0, signature.length);\r\n        System.arraycopy(b, 0, block, block.length - b.length, b.length);\r\n    } catch (Exception e) {\r\n        return false;\r\n    }\r\n    if (block[block.length - 1] != trailer) {\r\n        clearBlock(block);\r\n        return false;\r\n    }\r\n    byte[] dbMask = maskGeneratorFunction1(block, block.length - hLen - 1, hLen, block.length - hLen - 1);\r\n    for (int i = 0; i != dbMask.length; i++) {\r\n        block[i] ^= dbMask[i];\r\n    }\r\n    block[0] &= (0xff >> ((block.length * 8) - emBits));\r\n    for (int i = 0; i != block.length - hLen - sLen - 2; i++) {\r\n        if (block[i] != 0) {\r\n            clearBlock(block);\r\n            return false;\r\n        }\r\n    }\r\n    if (block[block.length - hLen - sLen - 2] != 0x01) {\r\n        clearBlock(block);\r\n        return false;\r\n    }\r\n    if (sSet) {\r\n        System.arraycopy(salt, 0, mDash, mDash.length - sLen, sLen);\r\n    } else {\r\n        System.arraycopy(block, block.length - sLen - hLen - 1, mDash, mDash.length - sLen, sLen);\r\n    }\r\n    contentDigest.update(mDash, 0, mDash.length);\r\n    contentDigest.doFinal(mDash, mDash.length - hLen);\r\n    for (int i = block.length - hLen - 1, j = mDash.length - hLen; j != mDash.length; i++, j++) {\r\n        if ((block[i] ^ mDash[j]) != 0) {\r\n            clearBlock(mDash);\r\n            clearBlock(block);\r\n            return false;\r\n        }\r\n    }\r\n    clearBlock(mDash);\r\n    clearBlock(block);\r\n    return true;\r\n}"
}, {
	"Path": "org.bouncycastle.x509.PKIXCertPathReviewer.getErrors",
	"Comment": "returns an array of lists which contains a list of global error messages and a list of error messages for each certificate in the path.the global error list is at index 0. the error lists for each certificate at index 1 to n. the error messages are of type.",
	"Method": "List[] getErrors(List getErrors,int index){\r\n    doChecks();\r\n    return errors[index + 1];\r\n}"
}, {
	"Path": "org.bouncycastle.cert.X509CertificateHolder.getSignatureAlgorithm",
	"Comment": "return the details of the signature algorithm used to create this attribute certificate.",
	"Method": "AlgorithmIdentifier getSignatureAlgorithm(){\r\n    return x509Certificate.getSignatureAlgorithm();\r\n}"
}, {
	"Path": "java.security.cert.CertUtil.parseDNSName",
	"Comment": "parse the given dns name into der encoded byte array representation. thestring must be in den preffered name syntax as defined in rfc 1034.",
	"Method": "byte[] parseDNSName(String data){\r\n    ASN1Object derData = new DERIA5String(data);\r\n    ByteArrayOutputStream outStream = new ByteArrayOutputStream();\r\n    DEROutputStream derOutStream = new DEROutputStream(outStream);\r\n    derOutStream.writeObject(derData);\r\n    derOutStream.close();\r\n    return outStream.toByteArray();\r\n}"
}, {
	"Path": "org.bouncycastle.jce.spec.ECNamedCurveGenParameterSpec.getName",
	"Comment": "return the name of the curve the ec domain parameters belong to.",
	"Method": "String getName(){\r\n    return name;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.cms.OtherRevocationInfoFormat.getInstance",
	"Comment": "return a otherrevocationinfoformat object from a tagged object.",
	"Method": "OtherRevocationInfoFormat getInstance(ASN1TaggedObject obj,boolean explicit,OtherRevocationInfoFormat getInstance,Object obj){\r\n    if (obj instanceof OtherRevocationInfoFormat) {\r\n        return (OtherRevocationInfoFormat) obj;\r\n    }\r\n    if (obj != null) {\r\n        return new OtherRevocationInfoFormat(ASN1Sequence.getInstance(obj));\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2Polynomial.lower",
	"Comment": "returns a new gf2polynomial containing the lower k bytes of thisgf2polynomial.",
	"Method": "GF2Polynomial lower(int k){\r\n    GF2Polynomial result = new GF2Polynomial(k << 5);\r\n    System.arraycopy(value, 0, result.value, 0, Math.min(k, blocks));\r\n    return result;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.ntru.polynomial.BigDecimalPolynomial.clone",
	"Comment": "makes a copy of the polynomial that is independent of the original.",
	"Method": "Object clone(){\r\n    return new BigDecimalPolynomial(coeffs.clone());\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.ch17_split.BESplitPaneDivider.createLeftOneTouchButton",
	"Comment": "creates and return an instance of jbutton that can be used to\tcollapse the left component in the split pane.",
	"Method": "JButton createLeftOneTouchButton(){\r\n    JButton b = new JButton() {\r\n        public void setBorder(Border b) {\r\n        }\r\n        public void paint(Graphics g) {\r\n            if (splitPane != null) {\r\n                int[] xs = new int[3];\r\n                int[] ys = new int[3];\r\n                int blockSize;\r\n                g.setColor(this.getBackground());\r\n                g.fillRect(0, 0, this.getWidth(), this.getHeight());\r\n                // Color.black);\r\n                g.setColor(TOUCH_BUTTON_COLOR);\r\n                BEUtils.setAntiAliasing((Graphics2D) g, true);\r\n                if (orientation == JSplitPane.VERTICAL_SPLIT) {\r\n                    blockSize = Math.min(getHeight(), oneTouchSize);\r\n                    xs[0] = blockSize;\r\n                    xs[1] = 0;\r\n                    xs[2] = blockSize << 1;\r\n                    ys[0] = 0;\r\n                    ys[1] = ys[2] = blockSize;\r\n                    g.drawPolygon(xs, ys, 3);\r\n                } else {\r\n                    blockSize = Math.min(getWidth(), oneTouchSize);\r\n                    xs[0] = xs[2] = blockSize;\r\n                    xs[1] = 0;\r\n                    ys[0] = 0;\r\n                    ys[1] = blockSize;\r\n                    ys[2] = blockSize << 1;\r\n                }\r\n                g.fillPolygon(xs, ys, 3);\r\n                BEUtils.setAntiAliasing((Graphics2D) g, false);\r\n            }\r\n        }\r\n        public boolean isFocusTraversable() {\r\n            return false;\r\n        }\r\n    };\r\n    b.setMinimumSize(new Dimension(oneTouchSize, oneTouchSize));\r\n    b.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));\r\n    b.setFocusPainted(false);\r\n    b.setBorderPainted(false);\r\n    b.setRequestFocusEnabled(false);\r\n    return b;\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.ch17_split.BESplitPaneDivider.createLeftOneTouchButton",
	"Comment": "creates and return an instance of jbutton that can be used to\tcollapse the left component in the split pane.",
	"Method": "JButton createLeftOneTouchButton(){\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.ch17_split.BESplitPaneDivider.createLeftOneTouchButton",
	"Comment": "creates and return an instance of jbutton that can be used to\tcollapse the left component in the split pane.",
	"Method": "JButton createLeftOneTouchButton(){\r\n    if (splitPane != null) {\r\n        int[] xs = new int[3];\r\n        int[] ys = new int[3];\r\n        int blockSize;\r\n        g.setColor(this.getBackground());\r\n        g.fillRect(0, 0, this.getWidth(), this.getHeight());\r\n        // Color.black);\r\n        g.setColor(TOUCH_BUTTON_COLOR);\r\n        BEUtils.setAntiAliasing((Graphics2D) g, true);\r\n        if (orientation == JSplitPane.VERTICAL_SPLIT) {\r\n            blockSize = Math.min(getHeight(), oneTouchSize);\r\n            xs[0] = blockSize;\r\n            xs[1] = 0;\r\n            xs[2] = blockSize << 1;\r\n            ys[0] = 0;\r\n            ys[1] = ys[2] = blockSize;\r\n            g.drawPolygon(xs, ys, 3);\r\n        } else {\r\n            blockSize = Math.min(getWidth(), oneTouchSize);\r\n            xs[0] = xs[2] = blockSize;\r\n            xs[1] = 0;\r\n            ys[0] = 0;\r\n            ys[1] = blockSize;\r\n            ys[2] = blockSize << 1;\r\n        }\r\n        g.fillPolygon(xs, ys, 3);\r\n        BEUtils.setAntiAliasing((Graphics2D) g, false);\r\n    }\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.ch17_split.BESplitPaneDivider.createLeftOneTouchButton",
	"Comment": "creates and return an instance of jbutton that can be used to\tcollapse the left component in the split pane.",
	"Method": "JButton createLeftOneTouchButton(){\r\n    return false;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.BERApplicationSpecificParser.toASN1Primitive",
	"Comment": "return a berapplicationspecific representing this parser and its contents.",
	"Method": "ASN1Primitive toASN1Primitive(){\r\n    try {\r\n        return getLoadedObject();\r\n    } catch (IOException e) {\r\n        throw new ASN1ParsingException(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.modes.PaddedBlockCipher.getOutputSize",
	"Comment": "return the size of the output buffer required for an update plus adofinal with an input of len bytes.",
	"Method": "int getOutputSize(int len){\r\n    int total = len + bufOff;\r\n    int leftOver = total % buf.length;\r\n    if (leftOver == 0) {\r\n        if (forEncryption) {\r\n            return total + buf.length;\r\n        }\r\n        return total;\r\n    }\r\n    return total - leftOver + buf.length;\r\n}"
}, {
	"Path": "org.bouncycastle.dvcs.SignedDVCSMessageGenerator.build",
	"Comment": "creates a cmssigneddata object containing the passed in dvcsmessage",
	"Method": "CMSSignedData build(DVCSMessage message){\r\n    try {\r\n        byte[] encapsulatedData = message.getContent().toASN1Primitive().getEncoded(ASN1Encoding.DER);\r\n        return signedDataGen.generate(new CMSProcessableByteArray(message.getContentType(), encapsulatedData), true);\r\n    } catch (CMSException e) {\r\n        throw new DVCSException(\"Could not sign DVCS request\", e);\r\n    } catch (IOException e) {\r\n        throw new DVCSException(\"Could not encode DVCS request\", e);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPSecretKey.parseSecretKeyFromSExpr",
	"Comment": "parse a secret key from one of the gpg s expression keys associating it with the passed in public key.",
	"Method": "PGPSecretKey parseSecretKeyFromSExpr(InputStream inputStream,PBEProtectionRemoverFactory keyProtectionRemoverFactory,PGPPublicKey pubKey,PGPSecretKey parseSecretKeyFromSExpr,InputStream inputStream,PBEProtectionRemoverFactory keyProtectionRemoverFactory,KeyFingerPrintCalculator fingerPrintCalculator){\r\n    return new SExprParser(null).parseSecretKey(inputStream, keyProtectionRemoverFactory, fingerPrintCalculator);\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.BCFKSLoadStoreParameter.getStoreEncryptionAlgorithm",
	"Comment": "return encryption algorithm used to secure the store and its entries.",
	"Method": "EncryptionAlgorithm getStoreEncryptionAlgorithm(){\r\n    return encAlg;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.X509CRLSelector.getMinCRL",
	"Comment": "returns the mincrlnumber criterion. the x509crl must havea crl number extension whose value is greater than or equal to thespecified value. if null, no mincrlnumber check will bedone.",
	"Method": "BigInteger getMinCRL(){\r\n    return minCRL;\r\n}"
}, {
	"Path": "org.bouncycastle.x509.X509V3CertificateGenerator.setSignatureAlgorithm",
	"Comment": "set the signature algorithm. this can be either a name or an oid, namesare treated as case insensitive.",
	"Method": "void setSignatureAlgorithm(String signatureAlgorithm){\r\n    this.signatureAlgorithm = signatureAlgorithm;\r\n    try {\r\n        sigOID = X509Util.getAlgorithmOID(signatureAlgorithm);\r\n    } catch (Exception e) {\r\n        throw new IllegalArgumentException(\"Unknown signature type requested: \" + signatureAlgorithm);\r\n    }\r\n    sigAlgId = X509Util.getSigAlgID(sigOID, signatureAlgorithm);\r\n    tbsGen.setSignature(sigAlgId);\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.cmp.CertifiedKeyPair.toASN1Primitive",
	"Comment": "return the primitive representation of pkipublicationinfo.",
	"Method": "ASN1Primitive toASN1Primitive(){\r\n    ASN1EncodableVector v = new ASN1EncodableVector();\r\n    v.add(certOrEncCert);\r\n    if (privateKey != null) {\r\n        v.add(new DERTaggedObject(true, 0, privateKey));\r\n    }\r\n    if (publicationInfo != null) {\r\n        v.add(new DERTaggedObject(true, 1, publicationInfo));\r\n    }\r\n    return new DERSequence(v);\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.x500.X500Name.getRDNs",
	"Comment": "return an array of rdns containing the attribute type given by oid in structure order.",
	"Method": "RDN[] getRDNs(RDN[] getRDNs,ASN1ObjectIdentifier attributeType){\r\n    RDN[] res = new RDN[rdns.length];\r\n    int count = 0;\r\n    for (int i = 0; i != rdns.length; i++) {\r\n        RDN rdn = rdns[i];\r\n        if (rdn.isMultiValued()) {\r\n            AttributeTypeAndValue[] attr = rdn.getTypesAndValues();\r\n            for (int j = 0; j != attr.length; j++) {\r\n                if (attr[j].getType().equals(attributeType)) {\r\n                    res[count++] = rdn;\r\n                    break;\r\n                }\r\n            }\r\n        } else {\r\n            if (rdn.getFirst().getType().equals(attributeType)) {\r\n                res[count++] = rdn;\r\n            }\r\n        }\r\n    }\r\n    RDN[] tmp = new RDN[count];\r\n    System.arraycopy(res, 0, tmp, 0, tmp.length);\r\n    return tmp;\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSSignedDataStreamGenerator.getDigestAlgorithms",
	"Comment": "return a list of the current digest algorithmidentifiers applying to the next signature.",
	"Method": "List<AlgorithmIdentifier> getDigestAlgorithms(){\r\n    List digestAlorithms = new ArrayList();\r\n    for (Iterator it = _signers.iterator(); it.hasNext(); ) {\r\n        SignerInformation signer = (SignerInformation) it.next();\r\n        AlgorithmIdentifier digAlg = CMSSignedHelper.INSTANCE.fixAlgID(signer.getDigestAlgorithmID());\r\n        digestAlorithms.add(digAlg);\r\n    }\r\n    for (Iterator it = signerGens.iterator(); it.hasNext(); ) {\r\n        SignerInfoGenerator signerGen = (SignerInfoGenerator) it.next();\r\n        digestAlorithms.add(signerGen.getDigestAlgorithm());\r\n    }\r\n    return digestAlorithms;\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.getPolicy",
	"Comment": "returns the policy criterion. the x509certificate mustinclude at least one of the specified policies in its certificatepolicies extension. if the set returned is empty, then thex509certificate must include at least some specifiedpolicy in its certificate policies extension. if the setreturned is null, no policy check will be performed.",
	"Method": "Set getPolicy(){\r\n    if (policy == null) {\r\n        return null;\r\n    }\r\n    return Collections.unmodifiableSet(policy);\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.CertUtil.parseDNSName",
	"Comment": "parse the given dns name into der encoded byte array representation. thestring must be in den preffered name syntax as defined in rfc 1034.",
	"Method": "byte[] parseDNSName(String data){\r\n    ASN1Object derData = new DERIA5String(data);\r\n    ByteArrayOutputStream outStream = new ByteArrayOutputStream();\r\n    DEROutputStream derOutStream = new DEROutputStream(outStream);\r\n    derOutStream.writeObject(derData);\r\n    derOutStream.close();\r\n    return outStream.toByteArray();\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.engines.SerpentEngineBase.processBlock",
	"Comment": "process one block of input from the array in and write it tothe out array.",
	"Method": "int processBlock(byte[] in,int inOff,byte[] out,int outOff){\r\n    if (wKey == null) {\r\n        throw new IllegalStateException(getAlgorithmName() + \" not initialised\");\r\n    }\r\n    if ((inOff + BLOCK_SIZE) > in.length) {\r\n        throw new DataLengthException(\"input buffer too short\");\r\n    }\r\n    if ((outOff + BLOCK_SIZE) > out.length) {\r\n        throw new OutputLengthException(\"output buffer too short\");\r\n    }\r\n    if (encrypting) {\r\n        encryptBlock(in, inOff, out, outOff);\r\n    } else {\r\n        decryptBlock(in, inOff, out, outOff);\r\n    }\r\n    return BLOCK_SIZE;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.gmss.GMSSKeyPairGenerator.genKeyPair",
	"Comment": "generates the gmss key pair. the public key is an instance ofjdkgmsspublickey, the private key is an instance of jdkgmssprivatekey.",
	"Method": "AsymmetricCipherKeyPair genKeyPair(){\r\n    if (!initialized) {\r\n        initializeDefault();\r\n    }\r\n    byte[][][] currentAuthPaths = new byte[numLayer][][];\r\n    byte[][][] nextAuthPaths = new byte[numLayer - 1][][];\r\n    Treehash[][] currentTreehash = new Treehash[numLayer][];\r\n    Treehash[][] nextTreehash = new Treehash[numLayer - 1][];\r\n    Vector[] currentStack = new Vector[numLayer];\r\n    Vector[] nextStack = new Vector[numLayer - 1];\r\n    Vector[][] currentRetain = new Vector[numLayer][];\r\n    Vector[][] nextRetain = new Vector[numLayer - 1][];\r\n    for (int i = 0; i < numLayer; i++) {\r\n        currentAuthPaths[i] = new byte[heightOfTrees[i]][mdLength];\r\n        currentTreehash[i] = new Treehash[heightOfTrees[i] - K[i]];\r\n        if (i > 0) {\r\n            nextAuthPaths[i - 1] = new byte[heightOfTrees[i]][mdLength];\r\n            nextTreehash[i - 1] = new Treehash[heightOfTrees[i] - K[i]];\r\n        }\r\n        currentStack[i] = new Vector();\r\n        if (i > 0) {\r\n            nextStack[i - 1] = new Vector();\r\n        }\r\n    }\r\n    byte[][] currentRoots = new byte[numLayer][mdLength];\r\n    byte[][] nextRoots = new byte[numLayer - 1][mdLength];\r\n    byte[][] seeds = new byte[numLayer][mdLength];\r\n    for (int i = 0; i < numLayer; i++) {\r\n        System.arraycopy(currentSeeds[i], 0, seeds[i], 0, mdLength);\r\n    }\r\n    currentRootSigs = new byte[numLayer - 1][mdLength];\r\n    for (int h = numLayer - 1; h >= 0; h--) {\r\n        GMSSRootCalc tree;\r\n        if (h == numLayer - 1) {\r\n            tree = this.generateCurrentAuthpathAndRoot(null, currentStack[h], seeds[h], h);\r\n        } else {\r\n            tree = this.generateCurrentAuthpathAndRoot(currentRoots[h + 1], currentStack[h], seeds[h], h);\r\n        }\r\n        for (int i = 0; i < heightOfTrees[h]; i++) {\r\n            System.arraycopy(tree.getAuthPath()[i], 0, currentAuthPaths[h][i], 0, mdLength);\r\n        }\r\n        currentRetain[h] = tree.getRetain();\r\n        currentTreehash[h] = tree.getTreehash();\r\n        System.arraycopy(tree.getRoot(), 0, currentRoots[h], 0, mdLength);\r\n    }\r\n    for (int h = numLayer - 2; h >= 0; h--) {\r\n        GMSSRootCalc tree = this.generateNextAuthpathAndRoot(nextStack[h], seeds[h + 1], h + 1);\r\n        for (int i = 0; i < heightOfTrees[h + 1]; i++) {\r\n            System.arraycopy(tree.getAuthPath()[i], 0, nextAuthPaths[h][i], 0, mdLength);\r\n        }\r\n        nextRetain[h] = tree.getRetain();\r\n        nextTreehash[h] = tree.getTreehash();\r\n        System.arraycopy(tree.getRoot(), 0, nextRoots[h], 0, mdLength);\r\n        System.arraycopy(seeds[h + 1], 0, this.nextNextSeeds[h], 0, mdLength);\r\n    }\r\n    GMSSPublicKeyParameters publicKey = new GMSSPublicKeyParameters(currentRoots[0], gmssPS);\r\n    GMSSPrivateKeyParameters privateKey = new GMSSPrivateKeyParameters(currentSeeds, nextNextSeeds, currentAuthPaths, nextAuthPaths, currentTreehash, nextTreehash, currentStack, nextStack, currentRetain, nextRetain, nextRoots, currentRootSigs, gmssPS, digestProvider);\r\n    return (new AsymmetricCipherKeyPair(publicKey, privateKey));\r\n}"
}, {
	"Path": "java.security.cert.CertPathValidator.validate",
	"Comment": "validates the specified certification path using the specified algorithm parameter set. the certpath specified must be of a type that is supported by the validation algorithm, otherwise aninvalidalgorithmparameterexception will be thrown. for example, a certpathvalidator that implements the pkixalgorithm validates certpath objects of type x.509.",
	"Method": "CertPathValidatorResult validate(CertPath certPath,CertPathParameters params){\r\n    return validatorSpi.engineValidate(certPath, params);\r\n}"
}, {
	"Path": "org.bouncycastle.cert.AttributeCertificateHolder.getDigestAlgorithm",
	"Comment": "returns algorithm identifier for the digest used if objectdigestinfo is present.",
	"Method": "AlgorithmIdentifier getDigestAlgorithm(){\r\n    if (holder.getObjectDigestInfo() != null) {\r\n        return holder.getObjectDigestInfo().getDigestAlgorithm();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPPublicKey.addCertification",
	"Comment": "add a certification for the given userattributesubpackets to the given public key.",
	"Method": "PGPPublicKey addCertification(PGPPublicKey key,byte[] rawID,PGPSignature certification,PGPPublicKey addCertification,PGPPublicKey key,String id,PGPSignature certification,PGPPublicKey addCertification,PGPPublicKey key,PGPUserAttributeSubpacketVector userAttributes,PGPSignature certification,PGPPublicKey addCertification,PGPPublicKey key,PGPSignature certification){\r\n    if (key.isMasterKey()) {\r\n        if (certification.getSignatureType() == PGPSignature.SUBKEY_REVOCATION) {\r\n            throw new IllegalArgumentException(\"signature type incorrect for master key revocation.\");\r\n        }\r\n    } else {\r\n        if (certification.getSignatureType() == PGPSignature.KEY_REVOCATION) {\r\n            throw new IllegalArgumentException(\"signature type incorrect for sub-key revocation.\");\r\n        }\r\n    }\r\n    PGPPublicKey returnKey = new PGPPublicKey(key);\r\n    if (returnKey.subSigs != null) {\r\n        returnKey.subSigs.add(certification);\r\n    } else {\r\n        returnKey.keySigs.add(certification);\r\n    }\r\n    return returnKey;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM.add",
	"Comment": "compute the sum of this polynomial and the given polynomial.",
	"Method": "PolynomialGF2mSmallM add(PolynomialGF2mSmallM addend,int[] add,int[] a,int[] b){\r\n    int[] result, addend;\r\n    if (a.length < b.length) {\r\n        result = new int[b.length];\r\n        System.arraycopy(b, 0, result, 0, b.length);\r\n        addend = a;\r\n    } else {\r\n        result = new int[a.length];\r\n        System.arraycopy(a, 0, result, 0, a.length);\r\n        addend = b;\r\n    }\r\n    for (int i = addend.length - 1; i >= 0; i--) {\r\n        result[i] = field.add(result[i], addend[i]);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.bouncycastle.pkcs.PKCS10CertificationRequest.isSignatureValid",
	"Comment": "validate the signature on the pkcs10 certification request in this holder.",
	"Method": "boolean isSignatureValid(ContentVerifierProvider verifierProvider){\r\n    CertificationRequestInfo requestInfo = certificationRequest.getCertificationRequestInfo();\r\n    ContentVerifier verifier;\r\n    try {\r\n        verifier = verifierProvider.get(certificationRequest.getSignatureAlgorithm());\r\n        OutputStream sOut = verifier.getOutputStream();\r\n        sOut.write(requestInfo.getEncoded(ASN1Encoding.DER));\r\n        sOut.close();\r\n    } catch (Exception e) {\r\n        throw new PKCSException(\"unable to process signature: \" + e.getMessage(), e);\r\n    }\r\n    return verifier.verify(this.getSignature());\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.ntru.polynomial.IntegerPolynomial.invertF3",
	"Comment": "computes the inverse mod 3.returns null if the polynomial is not invertible.",
	"Method": "IntegerPolynomial invertF3(){\r\n    int N = coeffs.length;\r\n    int k = 0;\r\n    IntegerPolynomial b = new IntegerPolynomial(N + 1);\r\n    b.coeffs[0] = 1;\r\n    IntegerPolynomial c = new IntegerPolynomial(N + 1);\r\n    IntegerPolynomial f = new IntegerPolynomial(N + 1);\r\n    f.coeffs = Arrays.copyOf(coeffs, N + 1);\r\n    f.modPositive(3);\r\n    IntegerPolynomial g = new IntegerPolynomial(N + 1);\r\n    g.coeffs[0] = -1;\r\n    g.coeffs[N] = 1;\r\n    while (true) {\r\n        while (f.coeffs[0] == 0) {\r\n            for (int i = 1; i <= N; i++) {\r\n                f.coeffs[i - 1] = f.coeffs[i];\r\n                c.coeffs[N + 1 - i] = c.coeffs[N - i];\r\n            }\r\n            f.coeffs[N] = 0;\r\n            c.coeffs[0] = 0;\r\n            k++;\r\n            if (f.equalsZero()) {\r\n                return null;\r\n            }\r\n        }\r\n        if (f.equalsAbsOne()) {\r\n            break;\r\n        }\r\n        if (f.degree() < g.degree()) {\r\n            IntegerPolynomial temp = f;\r\n            f = g;\r\n            g = temp;\r\n            temp = b;\r\n            b = c;\r\n            c = temp;\r\n        }\r\n        if (f.coeffs[0] == g.coeffs[0]) {\r\n            f.sub(g, 3);\r\n            b.sub(c, 3);\r\n        } else {\r\n            f.add(g, 3);\r\n            b.add(c, 3);\r\n        }\r\n    }\r\n    if (b.coeffs[N] != 0) {\r\n        return null;\r\n    }\r\n    IntegerPolynomial Fp = new IntegerPolynomial(N);\r\n    int j = 0;\r\n    k %= N;\r\n    for (int i = N - 1; i >= 0; i--) {\r\n        j = i - k;\r\n        if (j < 0) {\r\n            j += N;\r\n        }\r\n        Fp.coeffs[j] = f.coeffs[0] * b.coeffs[i];\r\n    }\r\n    Fp.ensurePositive(3);\r\n    return Fp;\r\n}"
}, {
	"Path": "java.security.cert.CollectionCertStoreParameters.getCollection",
	"Comment": "returns the collection from which certificatesand crls are retrieved. this is not a copy of thecollection, it is a reference. this allows the caller tosubsequently add or remove certificates orcrls from the collection.",
	"Method": "Collection getCollection(){\r\n    return collection;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.crmf.PKIArchiveControl.getEnvelopedData",
	"Comment": "return the enveloped data structure contained in this control.",
	"Method": "CMSEnvelopedData getEnvelopedData(){\r\n    try {\r\n        EncryptedKey encKey = EncryptedKey.getInstance(pkiArchiveOptions.getValue());\r\n        EnvelopedData data = EnvelopedData.getInstance(encKey.getValue());\r\n        return new CMSEnvelopedData(new ContentInfo(CMSObjectIdentifiers.envelopedData, data));\r\n    } catch (CMSException e) {\r\n        throw new CRMFException(\"CMS parsing error: \" + e.getMessage(), e.getCause());\r\n    } catch (Exception e) {\r\n        throw new CRMFException(\"CRMF parsing error: \" + e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.ntru.polynomial.LongPolynomial2.subAnd",
	"Comment": "subtracts another polynomial which must have the same number of coefficients,and applies an and mask to the upper and lower halves of each coefficients.",
	"Method": "void subAnd(LongPolynomial2 b,int mask){\r\n    long longMask = (((long) mask) << 24) + mask;\r\n    for (int i = 0; i < b.coeffs.length; i++) {\r\n        coeffs[i] = (0x0800000800000L + coeffs[i] - b.coeffs[i]) & longMask;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.modes.CBCBlockCipher.reset",
	"Comment": "reset the chaining vector back to the iv and reset the underlyingcipher.",
	"Method": "void reset(){\r\n    System.arraycopy(IV, 0, cbcV, 0, IV.length);\r\n    Arrays.fill(cbcNextV, (byte) 0);\r\n    cipher.reset();\r\n}"
}, {
	"Path": "javax.crypto.KeyGenerator.getAlgorithm",
	"Comment": "returns the algorithm name of this keygenerator object.this is the same name that was specified in one of thegetinstance calls that created thiskeygenerator object.",
	"Method": "String getAlgorithm(){\r\n    return algorithm;\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.getSerialNumber",
	"Comment": "returns the serialnumber criterion. the specified serial number mustmatch the certificate serial number in the x509certificate.if null, any certificate serial number will do.",
	"Method": "BigInteger getSerialNumber(){\r\n    return serialNumber;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.provider.X509StoreLDAPCertPairs.engineGetMatches",
	"Comment": "returns a collection of matching cross certificate pairs from the ldaplocation.the selector must be a of type x509certpairstoreselector.if it is not an empty collection is returned.the subject should be a reasonable criteria for a selector.",
	"Method": "Collection engineGetMatches(Selector selector){\r\n    if (!(selector instanceof X509CertPairStoreSelector)) {\r\n        return Collections.EMPTY_SET;\r\n    }\r\n    X509CertPairStoreSelector xselector = (X509CertPairStoreSelector) selector;\r\n    Set set = new HashSet();\r\n    set.addAll(helper.getCrossCertificatePairs(xselector));\r\n    return set;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.cmp.CMPCertificate.getX509v2AttrCert",
	"Comment": "return an attributecertificate interpretation of othercert.",
	"Method": "AttributeCertificate getX509v2AttrCert(){\r\n    return AttributeCertificate.getInstance(otherCert);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.generators.BaseKDFBytesGenerator.generateBytes",
	"Comment": "fill len bytes of the output buffer with bytes generated from thederivation function.",
	"Method": "int generateBytes(byte[] out,int outOff,int len){\r\n    if ((out.length - len) < outOff) {\r\n        throw new OutputLengthException(\"output buffer too small\");\r\n    }\r\n    long oBytes = len;\r\n    int outLen = digest.getDigestSize();\r\n    if (oBytes > ((2L << 32) - 1)) {\r\n        throw new IllegalArgumentException(\"Output length too large\");\r\n    }\r\n    int cThreshold = (int) ((oBytes + outLen - 1) / outLen);\r\n    byte[] dig = new byte[digest.getDigestSize()];\r\n    byte[] C = new byte[4];\r\n    Pack.intToBigEndian(counterStart, C, 0);\r\n    int counterBase = counterStart & ~0xFF;\r\n    for (int i = 0; i < cThreshold; i++) {\r\n        digest.update(shared, 0, shared.length);\r\n        digest.update(C, 0, C.length);\r\n        if (iv != null) {\r\n            digest.update(iv, 0, iv.length);\r\n        }\r\n        digest.doFinal(dig, 0);\r\n        if (len > outLen) {\r\n            System.arraycopy(dig, 0, out, outOff, outLen);\r\n            outOff += outLen;\r\n            len -= outLen;\r\n        } else {\r\n            System.arraycopy(dig, 0, out, outOff, len);\r\n        }\r\n        if (++C[3] == 0) {\r\n            counterBase += 0x100;\r\n            Pack.intToBigEndian(counterBase, C, 0);\r\n        }\r\n    }\r\n    digest.reset();\r\n    return (int) oBytes;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2nField.equals",
	"Comment": "decides whether the given object other is the same as thisfield.",
	"Method": "boolean equals(Object other){\r\n    if (other == null || !(other instanceof GF2nField)) {\r\n        return false;\r\n    }\r\n    GF2nField otherField = (GF2nField) other;\r\n    if (otherField.mDegree != mDegree) {\r\n        return false;\r\n    }\r\n    if (!fieldPolynomial.equals(otherField.fieldPolynomial)) {\r\n        return false;\r\n    }\r\n    if ((this instanceof GF2nPolynomialField) && !(otherField instanceof GF2nPolynomialField)) {\r\n        return false;\r\n    }\r\n    if ((this instanceof GF2nONBField) && !(otherField instanceof GF2nONBField)) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "javax.crypto.CipherInputStream.markSupported",
	"Comment": "tests if this input stream supports the mark and reset methods, which it does not.",
	"Method": "boolean markSupported(){\r\n    return false;\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPPrivateKey.getKeyID",
	"Comment": "return the keyid associated with the contained private key.",
	"Method": "long getKeyID(){\r\n    return keyID;\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.operator.bc.BcPGPDataEncryptorBuilder.setSecureRandom",
	"Comment": "provide a user defined source of randomness.if no securerandom is configured, a default securerandom will be used.",
	"Method": "BcPGPDataEncryptorBuilder setSecureRandom(SecureRandom random){\r\n    this.random = random;\r\n    return this;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.DigestingMessageSigner.verifySignature",
	"Comment": "this function verifies the signature of the message that has beenupdated, with the aid of the public key.",
	"Method": "boolean verifySignature(byte[] signature){\r\n    if (forSigning) {\r\n        throw new IllegalStateException(\"DigestingMessageSigner not initialised for verification\");\r\n    }\r\n    byte[] hash = new byte[messDigest.getDigestSize()];\r\n    messDigest.doFinal(hash, 0);\r\n    return messSigner.verifySignature(hash, signature);\r\n}"
}, {
	"Path": "java.security.cert.CertPathBuilderException.getMessage",
	"Comment": "returns the detail message for this certpathbuilderexception.",
	"Method": "String getMessage(){\r\n    String message = super.getMessage();\r\n    if (message == null && cause == null) {\r\n        return null;\r\n    }\r\n    if (cause != null) {\r\n        return cause.getMessage();\r\n    }\r\n    return message;\r\n}"
}, {
	"Path": "java.security.cert.CollectionCertStoreParameters.clone",
	"Comment": "returns a copy of this object. note that only a reference to thecollection is copied, and not the contents.",
	"Method": "Object clone(){\r\n    try {\r\n        return super.clone();\r\n    } catch (CloneNotSupportedException e) {\r\n        throw new InternalError(e.toString());\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSSignedData.verifySignatures",
	"Comment": "verify all the signerinformation objects and optionally their associated counter signatures attachedto this cms signeddata object.",
	"Method": "boolean verifySignatures(SignerInformationVerifierProvider verifierProvider,boolean verifySignatures,SignerInformationVerifierProvider verifierProvider,boolean ignoreCounterSignatures){\r\n    Collection signers = this.getSignerInfos().getSigners();\r\n    for (Iterator it = signers.iterator(); it.hasNext(); ) {\r\n        SignerInformation signer = (SignerInformation) it.next();\r\n        try {\r\n            SignerInformationVerifier verifier = verifierProvider.get(signer.getSID());\r\n            if (!signer.verify(verifier)) {\r\n                return false;\r\n            }\r\n            if (!ignoreCounterSignatures) {\r\n                Collection counterSigners = signer.getCounterSignatures().getSigners();\r\n                for (Iterator cIt = counterSigners.iterator(); cIt.hasNext(); ) {\r\n                    if (!verifyCounterSignature((SignerInformation) cIt.next(), verifierProvider)) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        } catch (OperatorCreationException e) {\r\n            throw new CMSException(\"failure in verifier provider: \" + e.getMessage(), e);\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPV3SignatureGenerator.generateOnePassVersion",
	"Comment": "return the one pass header associated with the current signature.",
	"Method": "PGPOnePassSignature generateOnePassVersion(boolean isNested){\r\n    return new PGPOnePassSignature(new OnePassSignaturePacket(sigType, contentSigner.getHashAlgorithm(), contentSigner.getKeyAlgorithm(), contentSigner.getKeyID(), isNested));\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSSignedGenerator.addCRL",
	"Comment": "add a crl to the crl set to be included with the generated signeddata message.",
	"Method": "void addCRL(X509CRLHolder crl){\r\n    crls.add(crl.toASN1Structure());\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.DEROctetStringParser.toASN1Primitive",
	"Comment": "return an deroctetstring representing this parser and its contents.",
	"Method": "ASN1Primitive toASN1Primitive(){\r\n    try {\r\n        return getLoadedObject();\r\n    } catch (IOException e) {\r\n        throw new ASN1ParsingException(\"IOException converting stream to byte array: \" + e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.ch1_titlepane.BETitlePane.createMenuBar",
	"Comment": "returns the jmenubar displaying the appropriate\tsystem menu items.",
	"Method": "JMenuBar createMenuBar(){\r\n    menuBar = new SystemMenuBar();\r\n    menuBar.setOpaque(false);\r\n    menuBar.setFocusable(false);\r\n    menuBar.setBorderPainted(true);\r\n    menuBar.add(createMenu());\r\n    return menuBar;\r\n}"
}, {
	"Path": "org.bouncycastle.dvcs.VSDRequestData.getParsedMessage",
	"Comment": "get the cms signeddata object represented by the encoded message.",
	"Method": "CMSSignedData getParsedMessage(){\r\n    return doc;\r\n}"
}, {
	"Path": "org.bouncycastle.dvcs.DVCSResponse.getContent",
	"Comment": "return the asn.1 dvcsresponse structure making up the body of this response.",
	"Method": "ASN1Encodable getContent(){\r\n    return asn1;\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.BeautyEyeLookAndFeelCross.initOtherResourceBundle",
	"Comment": "initialize the defaults table with the name of the other resourcebundleused for getting localized defaults.",
	"Method": "void initOtherResourceBundle(UIDefaults table){\r\n    table.addResourceBundle(\"org.jb2011.lnf.beautyeye.resources.beautyeye\");\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.paddings.ISO10126d2Padding.addPadding",
	"Comment": "add the pad bytes to the passed in block, returning thenumber of bytes added.",
	"Method": "int addPadding(byte[] in,int inOff){\r\n    byte code = (byte) (in.length - inOff);\r\n    while (inOff < (in.length - 1)) {\r\n        in[inOff] = (byte) random.nextInt();\r\n        inOff++;\r\n    }\r\n    in[inOff] = code;\r\n    return code;\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSSignedGenerator.addAttributeCertificates",
	"Comment": "add the attribute certificates in attrstore to the certificate set to be included with the generated signeddata message.",
	"Method": "void addAttributeCertificates(Store attrStore){\r\n    certs.addAll(CMSUtils.getAttributeCertificatesFromStore(attrStore));\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.X509CRLSelector.setCertificateChecking",
	"Comment": "sets the certificate being checked. this is not a criterion. rather, itis optional information that may help a certstore findcrls that would be relevant when checking revocation for the specifiedcertificate. if null is specified, then no such optionalinformation is provided.",
	"Method": "void setCertificateChecking(X509Certificate cert){\r\n    certChecking = cert;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.x509.ExtendedKeyUsage.getInstance",
	"Comment": "return an extendedkeyusage from the passed in tagged object.",
	"Method": "ExtendedKeyUsage getInstance(ASN1TaggedObject obj,boolean explicit,ExtendedKeyUsage getInstance,Object obj){\r\n    if (obj instanceof ExtendedKeyUsage) {\r\n        return (ExtendedKeyUsage) obj;\r\n    } else if (obj != null) {\r\n        return new ExtendedKeyUsage(ASN1Sequence.getInstance(obj));\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.eac.CertificateBody.getInstance",
	"Comment": "gives an instance of iso7816certificatebody taken from object obj",
	"Method": "CertificateBody getInstance(Object obj){\r\n    if (obj instanceof CertificateBody) {\r\n        return (CertificateBody) obj;\r\n    } else if (obj != null) {\r\n        return new CertificateBody(ASN1ApplicationSpecific.getInstance(obj));\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.x509.X509V1CertificateGenerator.getSignatureAlgNames",
	"Comment": "return an iterator of the signature names supported by the generator.",
	"Method": "Iterator getSignatureAlgNames(){\r\n    return X509Util.getAlgNames();\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.spec.AEADParameterSpec.getMacSizeInBits",
	"Comment": "return the size of the mac associated with this parameter spec.",
	"Method": "int getMacSizeInBits(){\r\n    return macSizeInBits;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.IntUtils.clone",
	"Comment": "return a clone of the given int array. no null checks are performed.",
	"Method": "int[] clone(int[] array){\r\n    int[] result = new int[array.length];\r\n    System.arraycopy(array, 0, result, 0, array.length);\r\n    return result;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2nPolynomial.scalarMultiply",
	"Comment": "multiplies the scalar s to each coefficient of thispolynomialgf2n and returns the result in a new polynomialgf2n.",
	"Method": "GF2nPolynomial scalarMultiply(GF2nElement s){\r\n    GF2nPolynomial result = new GF2nPolynomial(size());\r\n    int i;\r\n    for (i = 0; i < size(); i++) {\r\n        result.coeff[i] = (GF2nElement) coeff[i].multiply(s);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.ec.ECElGamalEncryptor.encrypt",
	"Comment": "process a single ec point using the basic elgamal algorithm.",
	"Method": "ECPair encrypt(ECPoint point){\r\n    if (key == null) {\r\n        throw new IllegalStateException(\"ECElGamalEncryptor not initialised\");\r\n    }\r\n    ECDomainParameters ec = key.getParameters();\r\n    BigInteger k = ECUtil.generateK(ec.getN(), random);\r\n    ECMultiplier basePointMultiplier = createBasePointMultiplier();\r\n    ECPoint[] gamma_phi = new ECPoint[] { basePointMultiplier.multiply(ec.getG(), k), key.getQ().multiply(k).add(ECAlgorithms.cleanPoint(ec.getCurve(), point)) };\r\n    ec.getCurve().normalizeAll(gamma_phi);\r\n    return new ECPair(gamma_phi[0], gamma_phi[1]);\r\n}"
}, {
	"Path": "org.bouncycastle.math.ec.ECPoint.normalize",
	"Comment": "normalization ensures that any projective coordinate is 1, and therefore that the x, ycoordinates reflect those of the equivalent point in an affine coordinate system.",
	"Method": "ECPoint normalize(ECPoint normalize,ECFieldElement zInv){\r\n    switch(this.getCurveCoordinateSystem()) {\r\n        case ECCurve.COORD_HOMOGENEOUS:\r\n        case ECCurve.COORD_LAMBDA_PROJECTIVE:\r\n            {\r\n                return createScaledPoint(zInv, zInv);\r\n            }\r\n        case ECCurve.COORD_JACOBIAN:\r\n        case ECCurve.COORD_JACOBIAN_CHUDNOVSKY:\r\n        case ECCurve.COORD_JACOBIAN_MODIFIED:\r\n            {\r\n                ECFieldElement zInv2 = zInv.square(), zInv3 = zInv2.multiply(zInv);\r\n                return createScaledPoint(zInv2, zInv3);\r\n            }\r\n        default:\r\n            {\r\n                throw new IllegalStateException(\"not a projective coordinate system\");\r\n            }\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.bcpg.ArmoredOutputStream.setHeader",
	"Comment": "set an additional header entry. a null value will clear the entry for name.",
	"Method": "void setHeader(String name,String value){\r\n    if (value == null) {\r\n        this.headers.remove(name);\r\n    } else {\r\n        this.headers.put(name, value);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.gpg.keybox.jcajce.JcaKeyBoxBuilder.setProvider",
	"Comment": "sets the provider to use to obtain cryptographic primitives.",
	"Method": "JcaKeyBoxBuilder setProvider(Provider provider,JcaKeyBoxBuilder setProvider,String providerName){\r\n    this.helper = new NamedJcaJceHelper(providerName);\r\n    return this;\r\n}"
}, {
	"Path": "org.bouncycastle.x509.PKIXCertPathReviewer.getNotifications",
	"Comment": "returns an array of lists which contains a list of global notification messages and a list of botification messages for each certificate in the path.the global notificatio list is at index 0. the notification lists for each certificate at index 1 to n. the error messages are of type.",
	"Method": "List[] getNotifications(List getNotifications,int index){\r\n    doChecks();\r\n    return notifications[index + 1];\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.generators.NaccacheSternKeyPairGenerator.permuteList",
	"Comment": "generates a permuted arraylist from the original one. the original listis not modified",
	"Method": "Vector permuteList(Vector arr,SecureRandom rand){\r\n    Vector retval = new Vector();\r\n    Vector tmp = new Vector();\r\n    for (int i = 0; i < arr.size(); i++) {\r\n        tmp.addElement(arr.elementAt(i));\r\n    }\r\n    retval.addElement(tmp.elementAt(0));\r\n    tmp.removeElementAt(0);\r\n    while (tmp.size() != 0) {\r\n        retval.insertElementAt(tmp.elementAt(0), getInt(rand, retval.size() + 1));\r\n        tmp.removeElementAt(0);\r\n    }\r\n    return retval;\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.PBKDF1Key.getAlgorithm",
	"Comment": "return the password based key derivation function this key is for,",
	"Method": "String getAlgorithm(){\r\n    return \"PBKDF1\";\r\n}"
}, {
	"Path": "com.sun.swingset3.codeview.CodeViewer.loadSourceCode",
	"Comment": "reads the java source file at the specified url and returns anhtml version stylized for display",
	"Method": "String loadSourceCode(URL sourceUrl){\r\n    InputStreamReader isr = null;\r\n    CodeStyler cv = new CodeStyler();\r\n    String styledCode = \"<html><body bgcolor=\\\"#ffffff\\\"><pre>\";\r\n    try {\r\n        isr = new InputStreamReader(sourceUrl.openStream(), \"UTF-8\");\r\n        BufferedReader reader = new BufferedReader(isr);\r\n        String line = reader.readLine();\r\n        while (line != null) {\r\n            styledCode += cv.syntaxHighlight(line) + \" \\n \";\r\n            line = reader.readLine();\r\n        }\r\n        styledCode += \"<\/pre><\/body><\/html>\";\r\n    } catch (Exception ex) {\r\n        ex.printStackTrace();\r\n        return \"Could not load file from: \" + sourceUrl;\r\n    } finally {\r\n        if (isr != null) {\r\n            try {\r\n                isr.close();\r\n            } catch (IOException e) {\r\n                System.err.println(e);\r\n            }\r\n        }\r\n    }\r\n    return styledCode;\r\n}"
}, {
	"Path": "org.bouncycastle.x509.X509V2CRLGenerator.getSignatureAlgNames",
	"Comment": "return an iterator of the signature names supported by the generator.",
	"Method": "Iterator getSignatureAlgNames(){\r\n    return X509Util.getAlgNames();\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.x509.X509NameEntryConverter.canBePrintable",
	"Comment": "return true if the passed in string can be represented withoutloss as a printablestring, false otherwise.",
	"Method": "boolean canBePrintable(String str){\r\n    return DERPrintableString.isPrintableString(str);\r\n}"
}, {
	"Path": "org.bouncycastle.jce.provider.JCERSAPrivateCrtKey.getEncoded",
	"Comment": "return a pkcs8 representation of the key. the sequence returnedrepresents a full privatekeyinfo object.",
	"Method": "byte[] getEncoded(){\r\n    return KeyUtil.getEncodedPrivateKeyInfo(new AlgorithmIdentifier(PKCSObjectIdentifiers.rsaEncryption, DERNull.INSTANCE), new RSAPrivateKey(getModulus(), getPublicExponent(), getPrivateExponent(), getPrimeP(), getPrimeQ(), getPrimeExponentP(), getPrimeExponentQ(), getCrtCoefficient()));\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.io.CipherOutputStream.close",
	"Comment": "closes this output stream and releases any system resourcesassociated with this stream.this method invokes the dofinal method of the encapsulatedcipher object, which causes any bytes buffered by the encapsulatedcipher to be processed. the result is written out by calling theflush method of this output stream.this method resets the encapsulated cipher object to its initial stateand calls the close method of the underlying outputstream.",
	"Method": "void close(){\r\n    ensureCapacity(0, true);\r\n    IOException error = null;\r\n    try {\r\n        if (bufferedBlockCipher != null) {\r\n            int outLen = bufferedBlockCipher.doFinal(buf, 0);\r\n            if (outLen != 0) {\r\n                out.write(buf, 0, outLen);\r\n            }\r\n        } else if (aeadBlockCipher != null) {\r\n            int outLen = aeadBlockCipher.doFinal(buf, 0);\r\n            if (outLen != 0) {\r\n                out.write(buf, 0, outLen);\r\n            }\r\n        } else if (streamCipher != null) {\r\n            streamCipher.reset();\r\n        }\r\n    } catch (final InvalidCipherTextException e) {\r\n        error = new InvalidCipherTextIOException(\"Error finalising cipher data\", e);\r\n    } catch (Exception e) {\r\n        error = new CipherIOException(\"Error closing stream: \", e);\r\n    }\r\n    try {\r\n        flush();\r\n        out.close();\r\n    } catch (IOException e) {\r\n        if (error == null) {\r\n            error = e;\r\n        }\r\n    }\r\n    if (error != null) {\r\n        throw error;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.cms.SignerInformation.toASN1Structure",
	"Comment": "return the underlying asn.1 object defining this signerinformation object.",
	"Method": "SignerInfo toASN1Structure(){\r\n    return info;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.pkcs.PBKDF2Params.getPrf",
	"Comment": "return the algid of the underlying pseudo random function to use.",
	"Method": "AlgorithmIdentifier getPrf(){\r\n    if (prf != null) {\r\n        return prf;\r\n    }\r\n    return algid_hmacWithSHA1;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.ntru.NTRUEncryptionKeyGenerationParameters.getMaxMessageLength",
	"Comment": "returns the maximum length a plaintext message can be with this parameter set.",
	"Method": "int getMaxMessageLength(){\r\n    return maxMsgLenBytes;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.X509CertSelector.setCertificate",
	"Comment": "sets the certificateequals criterion. the specifiedx509certificate must be equal to thex509certificate passed to the match method. ifnull, then this check is not applied.this method is particularly useful when it is necessary to match a singlecertificate. although other criteria can be specified in conjunction withthe certificateequals criterion, it is usually not practical ornecessary.",
	"Method": "void setCertificate(X509Certificate cert){\r\n    x509Cert = cert;\r\n}"
}, {
	"Path": "org.bouncycastle.x509.X509AttributeCertStoreSelector.setIssuer",
	"Comment": "sets the issuer the attribute certificate must have. if nullis given any will do.",
	"Method": "void setIssuer(AttributeCertificateIssuer issuer){\r\n    this.issuer = issuer;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2nPolynomialElement.power",
	"Comment": "calculates this to the power of k and returns the resultin a new gf2npolynomialelement.",
	"Method": "GF2nPolynomialElement power(int k){\r\n    if (k == 1) {\r\n        return new GF2nPolynomialElement(this);\r\n    }\r\n    GF2nPolynomialElement result = GF2nPolynomialElement.ONE((GF2nPolynomialField) mField);\r\n    if (k == 0) {\r\n        return result;\r\n    }\r\n    GF2nPolynomialElement x = new GF2nPolynomialElement(this);\r\n    x.polynomial.expandN((x.mDegree << 1) + 32);\r\n    x.polynomial.reduceN();\r\n    for (int i = 0; i < mDegree; i++) {\r\n        if ((k & (1 << i)) != 0) {\r\n            result.multiplyThisBy(x);\r\n        }\r\n        x.square();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSEncryptedDataGenerator.generate",
	"Comment": "generate an encrypted object that contains an cms encrypted data structure.",
	"Method": "CMSEncryptedData generate(CMSTypedData content,OutputEncryptor contentEncryptor){\r\n    return doGenerate(content, contentEncryptor);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.engines.RijndaelEngine.ShiftRow",
	"Comment": "row 0 remains unchangedthe other three rows are shifted a variable amount",
	"Method": "void ShiftRow(byte[] shiftsSC){\r\n    A1 = shift(A1, shiftsSC[1]);\r\n    A2 = shift(A2, shiftsSC[2]);\r\n    A3 = shift(A3, shiftsSC[3]);\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSSignedData.getCRLs",
	"Comment": "return any x.509 crl objects in this signeddata structure as a store of x509crlholder objects.",
	"Method": "Store<X509CRLHolder> getCRLs(){\r\n    return HELPER.getCRLs(signedData.getCRLs());\r\n}"
}, {
	"Path": "org.bouncycastle.cert.AttributeCertificateHolder.getEntityNames",
	"Comment": "return any principal objects inside the attribute certificate holderentity names field.",
	"Method": "X500Name[] getEntityNames(){\r\n    if (holder.getEntityName() != null) {\r\n        return getPrincipals(holder.getEntityName().getNames());\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.cms.RecipientEncryptedKey.getInstance",
	"Comment": "return an recipientencryptedkey object from a tagged object.",
	"Method": "RecipientEncryptedKey getInstance(ASN1TaggedObject obj,boolean explicit,RecipientEncryptedKey getInstance,Object obj){\r\n    if (obj instanceof RecipientEncryptedKey) {\r\n        return (RecipientEncryptedKey) obj;\r\n    }\r\n    if (obj != null) {\r\n        return new RecipientEncryptedKey(ASN1Sequence.getInstance(obj));\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.modes.OFBBlockCipher.reset",
	"Comment": "reset the feedback vector back to the iv and reset the underlyingcipher.",
	"Method": "void reset(){\r\n    System.arraycopy(IV, 0, ofbV, 0, IV.length);\r\n    byteCount = 0;\r\n    cipher.reset();\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.jcajce.spec.RainbowPrivateKeySpec.getB2",
	"Comment": "getter for the translation part of the private quadratic map l2.",
	"Method": "short[] getB2(){\r\n    return this.b2;\r\n}"
}, {
	"Path": "org.bouncycastle.bcpg.sig.KeyExpirationTime.getTime",
	"Comment": "return the number of seconds after creation time a key is valid for.",
	"Method": "long getTime(){\r\n    long time = ((long) (data[0] & 0xff) << 24) | ((data[1] & 0xff) << 16) | ((data[2] & 0xff) << 8) | (data[3] & 0xff);\r\n    return time;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.dane.DANEEntryStore.getMatches",
	"Comment": "return a collection of entries matching the passed in selector.",
	"Method": "Collection getMatches(Selector selector){\r\n    if (selector == null) {\r\n        return entries.values();\r\n    }\r\n    List results = new ArrayList();\r\n    for (Iterator it = entries.values().iterator(); it.hasNext(); ) {\r\n        Object next = it.next();\r\n        if (selector.match(next)) {\r\n            results.add(next);\r\n        }\r\n    }\r\n    return Collections.unmodifiableList(results);\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.BEROctetStringParser.toASN1Primitive",
	"Comment": "return an beroctetstring representing this parser and its contents.",
	"Method": "ASN1Primitive toASN1Primitive(){\r\n    try {\r\n        return getLoadedObject();\r\n    } catch (IOException e) {\r\n        throw new ASN1ParsingException(\"IOException converting stream to byte array: \" + e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.ntru.polynomial.LongPolynomial2.add",
	"Comment": "adds another polynomial which can have a different number of coefficients.",
	"Method": "void add(LongPolynomial2 b){\r\n    if (b.coeffs.length > coeffs.length) {\r\n        coeffs = Arrays.copyOf(coeffs, b.coeffs.length);\r\n    }\r\n    for (int i = 0; i < b.coeffs.length; i++) {\r\n        coeffs[i] = (coeffs[i] + b.coeffs[i]) & 0x7FF0007FFL;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.x509.ExtendedPKIXParameters.getProhibitedACAttributes",
	"Comment": "returns the attribute certificates which are not allowed.the returned set is immutable and containsstrings with the oids.",
	"Method": "Set getProhibitedACAttributes(){\r\n    return prohibitedACAttributes;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.cmp.ProtectedPKIMessageBuilder.setTransactionID",
	"Comment": "set the identifier for the transaction the new message will belong to.",
	"Method": "ProtectedPKIMessageBuilder setTransactionID(byte[] tid){\r\n    hdrBuilder.setTransactionID(tid);\r\n    return this;\r\n}"
}, {
	"Path": "java.security.cert.CertificateFactory.generateCertPath",
	"Comment": "generates a certpath object and initializes it witha list of certificates.the certificates supplied must be of a type supported by thecertificatefactory. they will be copied out of the suppliedlist object.",
	"Method": "CertPath generateCertPath(InputStream inStream,CertPath generateCertPath,InputStream inStream,String encoding,CertPath generateCertPath,List certificates){\r\n    return certFacSpi.engineGenerateCertPath(certificates);\r\n}"
}, {
	"Path": "org.bouncycastle.mail.smime.SMIMEUtil.outputPreamble",
	"Comment": "internal preamble is generally included in signatures, while this is technically wrong,if we find internal preamble we include it by default.",
	"Method": "void outputPreamble(LineOutputStream lOut,MimeBodyPart part,String boundary){\r\n    InputStream in;\r\n    try {\r\n        in = part.getRawInputStream();\r\n    } catch (MessagingException e) {\r\n        return;\r\n    }\r\n    String line;\r\n    while ((line = readLine(in)) != null) {\r\n        if (line.equals(boundary)) {\r\n            break;\r\n        }\r\n        lOut.writeln(line);\r\n    }\r\n    in.close();\r\n    if (line == null) {\r\n        throw new MessagingException(\"no boundary found\");\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSAuthenticatedDataParser.getAuthAttrs",
	"Comment": "return a table of the unauthenticated attributes indexed bythe oid of the attribute.",
	"Method": "AttributeTable getAuthAttrs(){\r\n    if (authAttrs == null && authAttrNotRead) {\r\n        ASN1Set set = getAuthAttrSet();\r\n        if (set != null) {\r\n            authAttrs = new AttributeTable(set);\r\n        }\r\n    }\r\n    return authAttrs;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.provider.JCEPBEKey.getOID",
	"Comment": "return the object identifier associated with this algorithm",
	"Method": "ASN1ObjectIdentifier getOID(){\r\n    return oid;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.x9.ECNamedCurveTable.getOID",
	"Comment": "return the object identifier signified by the passed in name. nullif there is no object identifier associated with name.",
	"Method": "ASN1ObjectIdentifier getOID(String name){\r\n    ASN1ObjectIdentifier oid = X962NamedCurves.getOID(name);\r\n    if (oid == null) {\r\n        oid = SECNamedCurves.getOID(name);\r\n    }\r\n    if (oid == null) {\r\n        oid = NISTNamedCurves.getOID(name);\r\n    }\r\n    if (oid == null) {\r\n        oid = TeleTrusTNamedCurves.getOID(name);\r\n    }\r\n    if (oid == null) {\r\n        oid = ANSSINamedCurves.getOID(name);\r\n    }\r\n    if (oid == null) {\r\n        oid = ECGOST3410NamedCurves.getOID(name);\r\n    }\r\n    if (oid == null) {\r\n        oid = GMNamedCurves.getOID(name);\r\n    }\r\n    return oid;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.signers.ISO9796d2PSSSigner.getRecoveredMessage",
	"Comment": "return a reference to the recoveredmessage message, either as it was addedto a just generated signature, or extracted from a verified one.",
	"Method": "byte[] getRecoveredMessage(){\r\n    return recoveredMessage;\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.ch5_table.BETableUI.installDefaults",
	"Comment": "initialize jtable properties, e.g. font, foreground, and background.the font, foreground, and background properties are only set if theircurrent value is either null or a uiresource, other properties are setif the current value is null.",
	"Method": "void installDefaults(){\r\n    super.installDefaults();\r\n    table.setRowHeight(25);\r\n    table.setShowVerticalLines(false);\r\n    table.setIntercellSpacing(new Dimension(0, 1));\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.signers.ISO9796d2Signer.generateSignature",
	"Comment": "generate a signature for the loaded message using the key we wereinitialised with.",
	"Method": "byte[] generateSignature(){\r\n    int digSize = digest.getDigestSize();\r\n    int t = 0;\r\n    int delta = 0;\r\n    if (trailer == ISOTrailers.TRAILER_IMPLICIT) {\r\n        t = 8;\r\n        delta = block.length - digSize - 1;\r\n        digest.doFinal(block, delta);\r\n        block[block.length - 1] = (byte) ISOTrailers.TRAILER_IMPLICIT;\r\n    } else {\r\n        t = 16;\r\n        delta = block.length - digSize - 2;\r\n        digest.doFinal(block, delta);\r\n        block[block.length - 2] = (byte) (trailer >>> 8);\r\n        block[block.length - 1] = (byte) trailer;\r\n    }\r\n    byte header = 0;\r\n    int x = (digSize + messageLength) * 8 + t + 4 - keyBits;\r\n    if (x > 0) {\r\n        int mR = messageLength - ((x + 7) / 8);\r\n        header = 0x60;\r\n        delta -= mR;\r\n        System.arraycopy(mBuf, 0, block, delta, mR);\r\n        recoveredMessage = new byte[mR];\r\n    } else {\r\n        header = 0x40;\r\n        delta -= messageLength;\r\n        System.arraycopy(mBuf, 0, block, delta, messageLength);\r\n        recoveredMessage = new byte[messageLength];\r\n    }\r\n    if ((delta - 1) > 0) {\r\n        for (int i = delta - 1; i != 0; i--) {\r\n            block[i] = (byte) 0xbb;\r\n        }\r\n        block[delta - 1] ^= (byte) 0x01;\r\n        block[0] = (byte) 0x0b;\r\n        block[0] |= header;\r\n    } else {\r\n        block[0] = (byte) 0x0a;\r\n        block[0] |= header;\r\n    }\r\n    byte[] b = cipher.processBlock(block, 0, block.length);\r\n    fullMessage = (header & 0x20) == 0;\r\n    System.arraycopy(mBuf, 0, recoveredMessage, 0, recoveredMessage.length);\r\n    messageLength = 0;\r\n    clearBlock(mBuf);\r\n    clearBlock(block);\r\n    return b;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM.modMultiply",
	"Comment": "compute the product of this polynomial and another polynomial modulo athird polynomial.",
	"Method": "PolynomialGF2mSmallM modMultiply(PolynomialGF2mSmallM a,PolynomialGF2mSmallM b,int[] modMultiply,int[] a,int[] b,int[] g){\r\n    return mod(multiply(a, b), g);\r\n}"
}, {
	"Path": "org.bouncycastle.x509.X509V2CRLGenerator.setSignatureAlgorithm",
	"Comment": "set the signature algorithm. this can be either a name or an oid, namesare treated as case insensitive.",
	"Method": "void setSignatureAlgorithm(String signatureAlgorithm){\r\n    this.signatureAlgorithm = signatureAlgorithm;\r\n    try {\r\n        sigOID = X509Util.getAlgorithmOID(signatureAlgorithm);\r\n    } catch (Exception e) {\r\n        throw new IllegalArgumentException(\"Unknown signature type requested\");\r\n    }\r\n    sigAlgId = X509Util.getSigAlgID(sigOID, signatureAlgorithm);\r\n    tbsGen.setSignature(sigAlgId);\r\n}"
}, {
	"Path": "org.bouncycastle.cms.jcajce.JceKTSKeyTransRecipient.setProvider",
	"Comment": "set the provider to use for key recovery and content processing.",
	"Method": "JceKTSKeyTransRecipient setProvider(Provider provider,JceKTSKeyTransRecipient setProvider,String providerName){\r\n    this.helper = new EnvelopedDataHelper(new NamedJcaJceExtHelper(providerName));\r\n    this.contentHelper = helper;\r\n    return this;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2Polynomial.subtractFromThis",
	"Comment": "subtracts b from this gf2polynomial and assigns the result tothis gf2polynomial. b can be of different size.",
	"Method": "void subtractFromThis(GF2Polynomial b){\r\n    expandN(b.len);\r\n    xorThisBy(b);\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.BERSetParser.toASN1Primitive",
	"Comment": "return an berset representing this parser and its contents.",
	"Method": "ASN1Primitive toASN1Primitive(){\r\n    try {\r\n        return getLoadedObject();\r\n    } catch (IOException e) {\r\n        throw new ASN1ParsingException(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.spec.DHUParameterSpec.getEphemeralPublicKey",
	"Comment": "return our ephemeral public key, null if it was not provided.",
	"Method": "PublicKey getEphemeralPublicKey(){\r\n    return ephemeralPublicKey;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.rainbow.RainbowKeyPairGenerator.keygen",
	"Comment": "this function calls the functions for the random generation of the coefficientsand the matrices needed for the private key and the method for computing the public key.",
	"Method": "void keygen(){\r\n    generateL1();\r\n    generateL2();\r\n    generateF();\r\n    computePublicKey();\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSAuthenticatedData.getMacAlgOID",
	"Comment": "return the object identifier for the content mac algorithm.",
	"Method": "String getMacAlgOID(){\r\n    return macAlg.getAlgorithm().getId();\r\n}"
}, {
	"Path": "org.bouncycastle.tsp.TimeStampRequest.validate",
	"Comment": "validate the timestamp request, checking the digest to see if it is of anaccepted type and whether it is of the correct length for the algorithm specified.",
	"Method": "void validate(Set algorithms,Set policies,Set extensions){\r\n    algorithms = convert(algorithms);\r\n    policies = convert(policies);\r\n    extensions = convert(extensions);\r\n    if (!algorithms.contains(this.getMessageImprintAlgOID())) {\r\n        throw new TSPValidationException(\"request contains unknown algorithm\", PKIFailureInfo.badAlg);\r\n    }\r\n    if (policies != null && this.getReqPolicy() != null && !policies.contains(this.getReqPolicy())) {\r\n        throw new TSPValidationException(\"request contains unknown policy\", PKIFailureInfo.unacceptedPolicy);\r\n    }\r\n    if (this.getExtensions() != null && extensions != null) {\r\n        Enumeration en = this.getExtensions().oids();\r\n        while (en.hasMoreElements()) {\r\n            ASN1ObjectIdentifier oid = (ASN1ObjectIdentifier) en.nextElement();\r\n            if (!extensions.contains(oid)) {\r\n                throw new TSPValidationException(\"request contains unknown extension\", PKIFailureInfo.unacceptedExtension);\r\n            }\r\n        }\r\n    }\r\n    int digestLength = TSPUtil.getDigestLength(this.getMessageImprintAlgOID().getId());\r\n    if (digestLength != this.getMessageImprintDigest().length) {\r\n        throw new TSPValidationException(\"imprint digest the wrong length\", PKIFailureInfo.badDataFormat);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.provider.asymmetric.rsa.BCRSAPrivateCrtKey.getEncoded",
	"Comment": "return a pkcs8 representation of the key. the sequence returnedrepresents a full privatekeyinfo object.",
	"Method": "byte[] getEncoded(){\r\n    return KeyUtil.getEncodedPrivateKeyInfo(new AlgorithmIdentifier(PKCSObjectIdentifiers.rsaEncryption, DERNull.INSTANCE), new RSAPrivateKey(getModulus(), getPublicExponent(), getPrivateExponent(), getPrimeP(), getPrimeQ(), getPrimeExponentP(), getPrimeExponentQ(), getCrtCoefficient()));\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.provider.asymmetric.x509.PKIXCertPath.getEncoded",
	"Comment": "returns the encoded form of this certification path, usingthe specified encoding.",
	"Method": "byte[] getEncoded(byte[] getEncoded,String encoding){\r\n    if (encoding.equalsIgnoreCase(\"PkiPath\")) {\r\n        ASN1EncodableVector v = new ASN1EncodableVector();\r\n        ListIterator iter = certificates.listIterator(certificates.size());\r\n        while (iter.hasPrevious()) {\r\n            v.add(toASN1Object((X509Certificate) iter.previous()));\r\n        }\r\n        return toDEREncoded(new DERSequence(v));\r\n    } else if (encoding.equalsIgnoreCase(\"PKCS7\")) {\r\n        ContentInfo encInfo = new ContentInfo(PKCSObjectIdentifiers.data, null);\r\n        ASN1EncodableVector v = new ASN1EncodableVector();\r\n        for (int i = 0; i != certificates.size(); i++) {\r\n            v.add(toASN1Object((X509Certificate) certificates.get(i)));\r\n        }\r\n        SignedData sd = new SignedData(new ASN1Integer(1), new DERSet(), encInfo, new DERSet(v), null, new DERSet());\r\n        return toDEREncoded(new ContentInfo(PKCSObjectIdentifiers.signedData, sd));\r\n    } else if (encoding.equalsIgnoreCase(\"PEM\")) {\r\n        ByteArrayOutputStream bOut = new ByteArrayOutputStream();\r\n        PemWriter pWrt = new PemWriter(new OutputStreamWriter(bOut));\r\n        try {\r\n            for (int i = 0; i != certificates.size(); i++) {\r\n                pWrt.writeObject(new PemObject(\"CERTIFICATE\", ((X509Certificate) certificates.get(i)).getEncoded()));\r\n            }\r\n            pWrt.close();\r\n        } catch (Exception e) {\r\n            throw new CertificateEncodingException(\"can't encode certificate for PEM encoded path\");\r\n        }\r\n        return bOut.toByteArray();\r\n    } else {\r\n        throw new CertificateEncodingException(\"unsupported encoding: \" + encoding);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.tls.crypto.impl.jcajce.JcaTlsCrypto.createNullCipher",
	"Comment": "to disable the null cipher suite, override this method with one that throws an ioexception.",
	"Method": "TlsNullCipher createNullCipher(TlsCryptoParameters cryptoParams,int macAlgorithm){\r\n    return new TlsNullCipher(cryptoParams, createMAC(macAlgorithm), createMAC(macAlgorithm));\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.x509.ExtendedKeyUsage.size",
	"Comment": "return the number of keypurposeids present in this extendedkeyusage.",
	"Method": "int size(){\r\n    return usageTable.size();\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPSecretKeyRingCollection.addSecretKeyRing",
	"Comment": "return a new collection object containing the contents of the passed in collection andthe passed in secret key ring.",
	"Method": "PGPSecretKeyRingCollection addSecretKeyRing(PGPSecretKeyRingCollection ringCollection,PGPSecretKeyRing secretKeyRing){\r\n    Long key = new Long(secretKeyRing.getPublicKey().getKeyID());\r\n    if (ringCollection.secretRings.containsKey(key)) {\r\n        throw new IllegalArgumentException(\"Collection already contains a key with a keyID for the passed in ring.\");\r\n    }\r\n    Map newSecretRings = new HashMap(ringCollection.secretRings);\r\n    List newOrder = new ArrayList(ringCollection.order);\r\n    newSecretRings.put(key, secretKeyRing);\r\n    newOrder.add(key);\r\n    return new PGPSecretKeyRingCollection(newSecretRings, newOrder);\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.operator.jcajce.JcePGPDataEncryptorBuilder.setWithIntegrityPacket",
	"Comment": "sets whether or not the resulting encrypted data will be protected using an integrity packet.",
	"Method": "JcePGPDataEncryptorBuilder setWithIntegrityPacket(boolean withIntegrityPacket){\r\n    this.withIntegrityPacket = withIntegrityPacket;\r\n    return this;\r\n}"
}, {
	"Path": "org.bouncycastle.mail.smime.test.SMIMEMiscTest.createMimeMessage",
	"Comment": "create a mime message representing the multipart. we need to dothis as otherwise no raw content stream for the message will exist.",
	"Method": "MimeMessage createMimeMessage(File tmpFile,MimeMultipart smm){\r\n    FileOutputStream fOut = new FileOutputStream(tmpFile);\r\n    Properties props = System.getProperties();\r\n    Session session = Session.getDefaultInstance(props, null);\r\n    Address fromUser = new InternetAddress(\"\\\"Eric H. Echidna\\\"<eric@bouncycastle.org>\");\r\n    Address toUser = new InternetAddress(\"example@bouncycastle.org\");\r\n    MimeMessage body = new MimeMessage(session);\r\n    body.setFrom(fromUser);\r\n    body.setRecipient(Message.RecipientType.TO, toUser);\r\n    body.setSubject(\"example signed message\");\r\n    body.setContent(smm, smm.getContentType());\r\n    body.saveChanges();\r\n    body.writeTo(fOut);\r\n    fOut.close();\r\n    return new MimeMessage(session, new FileInputStream(tmpFile));\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.getPrivateKeyValid",
	"Comment": "returns the privatekeyvalid criterion. the specified date must fallwithin the private key validity period for thex509certificate. if null, noprivatekeyvalid check will be done.note that the date returned is cloned to protect againstsubsequent modifications.",
	"Method": "Date getPrivateKeyValid(){\r\n    if (privateKeyValid != null) {\r\n        return new Date(privateKeyValid.getTime());\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.sec.SECNamedCurves.getOID",
	"Comment": "return the object identifier signified by the passed in name. nullif there is no object identifier associated with name.",
	"Method": "ASN1ObjectIdentifier getOID(String name){\r\n    return (ASN1ObjectIdentifier) objIds.get(Strings.toLowerCase(name));\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.test.CipherStreamTest.testTamperedRead",
	"Comment": "test tampering of ciphertext followed by read from decrypting cipherinputstream",
	"Method": "void testTamperedRead(AEADBlockCipher cipher,CipherParameters params){\r\n    cipher.init(true, params);\r\n    byte[] ciphertext = new byte[cipher.getOutputSize(streamSize)];\r\n    cipher.doFinal(ciphertext, cipher.processBytes(new byte[streamSize], 0, streamSize, ciphertext, 0));\r\n    ciphertext[0] += 1;\r\n    cipher.init(false, params);\r\n    InputStream input = createCipherInputStream(ciphertext, cipher);\r\n    try {\r\n        while (input.read() >= 0) {\r\n        }\r\n        fail(\"Expected invalid ciphertext after tamper and read : \" + cipher.getAlgorithmName());\r\n    } catch (InvalidCipherTextIOException e) {\r\n    }\r\n    try {\r\n        input.close();\r\n    } catch (Exception e) {\r\n        fail(\"Unexpected exception after tamper and read : \" + cipher.getAlgorithmName());\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPPublicKey.removeCertification",
	"Comment": "remove a certification associated with a given user attributes on a key.",
	"Method": "PGPPublicKey removeCertification(PGPPublicKey key,PGPUserAttributeSubpacketVector userAttributes,PGPPublicKey removeCertification,PGPPublicKey key,String id,PGPPublicKey removeCertification,PGPPublicKey key,byte[] rawID,PGPPublicKey removeCertification,PGPPublicKey key,byte[] id,PGPSignature certification,PGPPublicKey removeCertification,PGPPublicKey key,String id,PGPSignature certification,PGPPublicKey removeCertification,PGPPublicKey key,PGPUserAttributeSubpacketVector userAttributes,PGPSignature certification,PGPPublicKey removeCertification,PGPPublicKey key,PGPSignature certification){\r\n    PGPPublicKey returnKey = new PGPPublicKey(key);\r\n    boolean found;\r\n    if (returnKey.subSigs != null) {\r\n        found = returnKey.subSigs.remove(certification);\r\n    } else {\r\n        found = returnKey.keySigs.remove(certification);\r\n    }\r\n    if (!found) {\r\n        for (Iterator it = key.getRawUserIDs(); it.hasNext(); ) {\r\n            byte[] rawID = (byte[]) it.next();\r\n            for (Iterator sIt = key.getSignaturesForID(rawID); sIt.hasNext(); ) {\r\n                if (certification == sIt.next()) {\r\n                    found = true;\r\n                    returnKey = PGPPublicKey.removeCertification(returnKey, rawID, certification);\r\n                }\r\n            }\r\n        }\r\n        if (!found) {\r\n            for (Iterator it = key.getUserAttributes(); it.hasNext(); ) {\r\n                PGPUserAttributeSubpacketVector id = (PGPUserAttributeSubpacketVector) it.next();\r\n                for (Iterator sIt = key.getSignaturesForUserAttribute(id); sIt.hasNext(); ) {\r\n                    if (certification == sIt.next()) {\r\n                        found = true;\r\n                        returnKey = PGPPublicKey.removeCertification(returnKey, id, certification);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return returnKey;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.agreement.srp.SRP6Client.calculateClientEvidenceMessage",
	"Comment": "computes the client evidence message m1 using the previously received values.\tto be called after calculating the secret s.",
	"Method": "BigInteger calculateClientEvidenceMessage(){\r\n    if (this.A == null || this.B == null || this.S == null) {\r\n        throw new CryptoException(\"Impossible to compute M1: \" + \"some data are missing from the previous operations (A,B,S)\");\r\n    }\r\n    this.M1 = SRP6Util.calculateM1(digest, N, A, B, S);\r\n    return M1;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.engines.ElGamalEngine.getInputBlockSize",
	"Comment": "return the maximum size for an input block to this engine.for elgamal this is always one byte less than the size of p onencryption, and twice the length as the size of p on decryption.",
	"Method": "int getInputBlockSize(){\r\n    if (forEncryption) {\r\n        return (bitSize - 1) / 8;\r\n    }\r\n    return 2 * ((bitSize + 7) / 8);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher.getOutputSize",
	"Comment": "return the minimum size of the output buffer required for an updateplus a dofinal with an input of len bytes.",
	"Method": "int getOutputSize(int len){\r\n    int total = len + bufOff;\r\n    int leftOver = total % buf.length;\r\n    if (leftOver == 0) {\r\n        if (forEncryption) {\r\n            return total + buf.length;\r\n        }\r\n        return total;\r\n    }\r\n    return total - leftOver + buf.length;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.X509AttributeCertificateHolder.getExtensions",
	"Comment": "return the extensions block associated with this certificate if there is one.",
	"Method": "Extensions getExtensions(){\r\n    return extensions;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.ntru.polynomial.IntegerPolynomial.sumCoeffs",
	"Comment": "returns the sum of all coefficients, i.e. evaluates the polynomial at 0.",
	"Method": "int sumCoeffs(){\r\n    int sum = 0;\r\n    for (int i = 0; i < coeffs.length; i++) {\r\n        sum += coeffs[i];\r\n    }\r\n    return sum;\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.setCertificate",
	"Comment": "sets the certificateequals criterion. the specifiedx509certificate must be equal to thex509certificate passed to the match method. ifnull, then this check is not applied.this method is particularly useful when it is necessary to match a singlecertificate. although other criteria can be specified in conjunction withthe certificateequals criterion, it is usually not practical ornecessary.",
	"Method": "void setCertificate(X509Certificate cert){\r\n    x509Cert = cert;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.X509CertificateHolder.getExtensions",
	"Comment": "return the extensions block associated with this certificate if there is one.",
	"Method": "Extensions getExtensions(){\r\n    return extensions;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.jcajce.spec.RainbowPrivateKeySpec.getB1",
	"Comment": "getter for the translation part of the private quadratic map l1.",
	"Method": "short[] getB1(){\r\n    return this.b1;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.signers.ECNRSigner.generateSignature",
	"Comment": "generate a signature for the given message using the key we wereinitialised with.generally, the order of the curve should be at least as long as the hash of the message of interest, and with ecnr itbe at least as long.",
	"Method": "BigInteger[] generateSignature(byte[] digest){\r\n    if (!this.forSigning) {\r\n        throw new IllegalStateException(\"not initialised for signing\");\r\n    }\r\n    BigInteger n = getOrder();\r\n    int nBitLength = n.bitLength();\r\n    BigInteger e = new BigInteger(1, digest);\r\n    int eBitLength = e.bitLength();\r\n    ECPrivateKeyParameters privKey = (ECPrivateKeyParameters) key;\r\n    if (eBitLength > nBitLength) {\r\n        throw new DataLengthException(\"input too large for ECNR key.\");\r\n    }\r\n    BigInteger r = null;\r\n    BigInteger s = null;\r\n    AsymmetricCipherKeyPair tempPair;\r\n    do {\r\n        ECKeyPairGenerator keyGen = new ECKeyPairGenerator();\r\n        keyGen.init(new ECKeyGenerationParameters(privKey.getParameters(), this.random));\r\n        tempPair = keyGen.generateKeyPair();\r\n        ECPublicKeyParameters V = (ECPublicKeyParameters) tempPair.getPublic();\r\n        BigInteger Vx = V.getQ().getAffineXCoord().toBigInteger();\r\n        r = Vx.add(e).mod(n);\r\n    } while (r.equals(ECConstants.ZERO));\r\n    BigInteger x = privKey.getD();\r\n    BigInteger u = ((ECPrivateKeyParameters) tempPair.getPrivate()).getD();\r\n    s = u.subtract(r.multiply(x)).mod(n);\r\n    BigInteger[] res = new BigInteger[2];\r\n    res[0] = r;\r\n    res[1] = s;\r\n    return res;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.digests.KeccakDigest.getByteLength",
	"Comment": "return the size of block that the compression function is applied to in bytes.",
	"Method": "int getByteLength(){\r\n    return rate / 8;\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.ch1_titlepane.BERootPaneUI.getTitlePane",
	"Comment": "returns the jcomponent rendering the title pane. if this\treturns null, it implies there is no need to render window decorations.",
	"Method": "JComponent getTitlePane(){\r\n    return titlePane;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.engines.NaccacheSternEngine.processData",
	"Comment": "convenience method for data exchange with the cipher.determines blocksize and splits data to blocksize.",
	"Method": "byte[] processData(byte[] data){\r\n    if (debug) {\r\n        System.out.println();\r\n    }\r\n    if (data.length > getInputBlockSize()) {\r\n        int inBlocksize = getInputBlockSize();\r\n        int outBlocksize = getOutputBlockSize();\r\n        if (debug) {\r\n            System.out.println(\"Input blocksize is:  \" + inBlocksize + \" bytes\");\r\n            System.out.println(\"Output blocksize is: \" + outBlocksize + \" bytes\");\r\n            System.out.println(\"Data has length:.... \" + data.length + \" bytes\");\r\n        }\r\n        int datapos = 0;\r\n        int retpos = 0;\r\n        byte[] retval = new byte[(data.length / inBlocksize + 1) * outBlocksize];\r\n        while (datapos < data.length) {\r\n            byte[] tmp;\r\n            if (datapos + inBlocksize < data.length) {\r\n                tmp = processBlock(data, datapos, inBlocksize);\r\n                datapos += inBlocksize;\r\n            } else {\r\n                tmp = processBlock(data, datapos, data.length - datapos);\r\n                datapos += data.length - datapos;\r\n            }\r\n            if (debug) {\r\n                System.out.println(\"new datapos is \" + datapos);\r\n            }\r\n            if (tmp != null) {\r\n                System.arraycopy(tmp, 0, retval, retpos, tmp.length);\r\n                retpos += tmp.length;\r\n            } else {\r\n                if (debug) {\r\n                    System.out.println(\"cipher returned null\");\r\n                }\r\n                throw new InvalidCipherTextException(\"cipher returned null\");\r\n            }\r\n        }\r\n        byte[] ret = new byte[retpos];\r\n        System.arraycopy(retval, 0, ret, 0, retpos);\r\n        if (debug) {\r\n            System.out.println(\"returning \" + ret.length + \" bytes\");\r\n        }\r\n        return ret;\r\n    } else {\r\n        if (debug) {\r\n            System.out.println(\"data size is less then input block size, processing directly\");\r\n        }\r\n        return processBlock(data, 0, data.length);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.rainbow.util.GF2Field.invElem",
	"Comment": "this function computes the multiplicative inverse of a given element ingf2^8 the 0 has no multiplicative inverse and in this case 0 is returned.",
	"Method": "short invElem(short x){\r\n    if (x == 0) {\r\n        return 0;\r\n    }\r\n    return (exps[255 - logs[x]]);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.prng.ThreadedSeedGenerator.generateSeed",
	"Comment": "generate seed bytes. set fast to false for best quality.if fast is set to true, the code should be round about 8 times faster whengenerating a long sequence of random bytes. 20 bytes of random values usingthe fast mode take less than half a second on a nokia e70. if fast is set to false,it takes round about 2500 ms.",
	"Method": "byte[] generateSeed(int numbytes,boolean fast,byte[] generateSeed,int numBytes,boolean fast){\r\n    SeedGenerator gen = new SeedGenerator();\r\n    return gen.generateSeed(numBytes, fast);\r\n}"
}, {
	"Path": "javax.crypto.Cipher.getInstance",
	"Comment": "creates a cipher object that implements the specifiedtransformation, as supplied by the specified provider.",
	"Method": "Cipher getInstance(String transformation,Cipher getInstance,String transformation,Provider provider,Cipher getInstance,String transformation,String provider){\r\n    if (transformation == null) {\r\n        throw new IllegalArgumentException(\"No transformation specified for Cipher.getInstance()\");\r\n    }\r\n    JCEUtil.Implementation imp = JCEUtil.getImplementation(\"Cipher\", transformation, provider);\r\n    if (imp != null) {\r\n        return new Cipher((CipherSpi) imp.getEngine(), imp.getProvider(), transformation);\r\n    }\r\n    StringTokenizer tok = new StringTokenizer(transformation, \"/\");\r\n    String algorithm = tok.nextToken();\r\n    imp = JCEUtil.getImplementation(\"Cipher\", algorithm, provider);\r\n    if (imp == null) {\r\n        throw new NoSuchAlgorithmException(transformation + \" not found\");\r\n    }\r\n    CipherSpi cipherSpi = (CipherSpi) imp.getEngine();\r\n    if (tok.hasMoreTokens() && !transformation.regionMatches(algorithm.length(), \"//\", 0, 2)) {\r\n        cipherSpi.engineSetMode(tok.nextToken());\r\n    }\r\n    if (tok.hasMoreTokens()) {\r\n        cipherSpi.engineSetPadding(tok.nextToken());\r\n    }\r\n    return new Cipher(cipherSpi, imp.getProvider(), transformation);\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.sec.SECNamedCurves.getName",
	"Comment": "return the named curve name represented by the given object identifier.",
	"Method": "String getName(ASN1ObjectIdentifier oid){\r\n    return (String) names.get(oid);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.modes.PGPCFBBlockCipher.reset",
	"Comment": "reset the chaining vector back to the iv and reset the underlyingcipher.",
	"Method": "void reset(){\r\n    count = 0;\r\n    for (int i = 0; i != FR.length; i++) {\r\n        if (inlineIv) {\r\n            FR[i] = 0;\r\n        } else {\r\n            FR[i] = IV[i];\r\n        }\r\n    }\r\n    cipher.reset();\r\n}"
}, {
	"Path": "org.bouncycastle.x509.ExtendedPKIXParameters.getTargetConstraints",
	"Comment": "returns the required constraints on the target certificate or attributecertificate. the constraints are returned as an instance ofselector. if null, no constraints aredefined.the target certificate in a pkix path may be a certificate or anattribute certificate.note that the selector returned is cloned to protectagainst subsequent modifications.",
	"Method": "Selector getTargetConstraints(){\r\n    if (selector != null) {\r\n        return (Selector) selector.clone();\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.engines.RSABlindedEngine.getInputBlockSize",
	"Comment": "return the maximum size for an input block to this engine.for rsa this is always one byte less than the key size onencryption, and the same length as the key size on decryption.",
	"Method": "int getInputBlockSize(){\r\n    return core.getInputBlockSize();\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.signers.X931Signer.verifySignature",
	"Comment": "return true if the signature represents a x9.31 signaturefor the passed in message.",
	"Method": "boolean verifySignature(byte[] signature){\r\n    try {\r\n        block = cipher.processBlock(signature, 0, signature.length);\r\n    } catch (Exception e) {\r\n        return false;\r\n    }\r\n    BigInteger t = new BigInteger(1, block);\r\n    BigInteger f;\r\n    if ((t.intValue() & 15) == 12) {\r\n        f = t;\r\n    } else {\r\n        t = kParam.getModulus().subtract(t);\r\n        if ((t.intValue() & 15) == 12) {\r\n            f = t;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    createSignatureBlock(trailer);\r\n    byte[] fBlock = BigIntegers.asUnsignedByteArray(block.length, f);\r\n    boolean rv = Arrays.constantTimeAreEqual(block, fBlock);\r\n    if (trailer == ISOTrailers.TRAILER_SHA512_256 && !rv) {\r\n        block[block.length - 2] = (byte) 0x40;\r\n        rv = Arrays.constantTimeAreEqual(block, fBlock);\r\n    }\r\n    clearBlock(block);\r\n    clearBlock(fBlock);\r\n    return rv;\r\n}"
}, {
	"Path": "java.security.cert.CertUtil.parseIP",
	"Comment": "parse the given ipv4 or ipv6 into der encoded byte array representation.",
	"Method": "byte[] parseIP(String data){\r\n    byte[] encoded = parseIPv4(data);\r\n    if (encoded == null) {\r\n        encoded = parseIPv6(data);\r\n    }\r\n    if (encoded == null) {\r\n        throw new IOException(\"unable to parse IP to DER encoded byte array\");\r\n    }\r\n    return encoded;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.nist.NISTNamedCurves.getNames",
	"Comment": "returns an enumeration containing the name strings for curvescontained in this structure.",
	"Method": "Enumeration getNames(){\r\n    return objIds.keys();\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.agreement.DHBasicAgreement.calculateAgreement",
	"Comment": "given a short term public key from a given party calculate the nextmessage in the agreement sequence.",
	"Method": "BigInteger calculateAgreement(CipherParameters pubKey){\r\n    DHPublicKeyParameters pub = (DHPublicKeyParameters) pubKey;\r\n    if (!pub.getParameters().equals(dhParams)) {\r\n        throw new IllegalArgumentException(\"Diffie-Hellman public key has wrong parameters.\");\r\n    }\r\n    BigInteger p = dhParams.getP();\r\n    BigInteger peerY = pub.getY();\r\n    if (peerY == null || peerY.compareTo(ONE) <= 0 || peerY.compareTo(p.subtract(ONE)) >= 0) {\r\n        throw new IllegalArgumentException(\"Diffie-Hellman public key is weak\");\r\n    }\r\n    BigInteger result = peerY.modPow(key.getX(), p);\r\n    if (result.equals(ONE)) {\r\n        throw new IllegalStateException(\"Shared key can't be 1\");\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPSignatureGenerator.generateOnePassVersion",
	"Comment": "return the one pass header associated with the current signature.",
	"Method": "PGPOnePassSignature generateOnePassVersion(boolean isNested){\r\n    return new PGPOnePassSignature(new OnePassSignaturePacket(sigType, contentSigner.getHashAlgorithm(), contentSigner.getKeyAlgorithm(), contentSigner.getKeyID(), isNested));\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSEnvelopedDataStreamGenerator.open",
	"Comment": "generate an enveloped object that contains an cms enveloped dataobject using the given encryptor and marking the data as being of the passedin type.",
	"Method": "OutputStream open(ASN1ObjectIdentifier dataType,OutputStream out,ASN1EncodableVector recipientInfos,OutputEncryptor encryptor,OutputStream open,OutputStream out,ASN1EncodableVector recipientInfos,OutputEncryptor encryptor,OutputStream open,OutputStream out,OutputEncryptor encryptor,OutputStream open,ASN1ObjectIdentifier dataType,OutputStream out,OutputEncryptor encryptor){\r\n    return doOpen(dataType, out, encryptor);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.modes.OpenPGPCFBBlockCipher.processBlock",
	"Comment": "process one block of input from the array in and write it tothe out array.",
	"Method": "int processBlock(byte[] in,int inOff,byte[] out,int outOff){\r\n    return (forEncryption) ? encryptBlock(in, inOff, out, outOff) : decryptBlock(in, inOff, out, outOff);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.engines.SerpentEngineBase.inverseLT",
	"Comment": "apply the inverse of the linear transformation to the register set.",
	"Method": "void inverseLT(){\r\n    int x2 = rotateRight(X2, 22) ^ X3 ^ (X1 << 7);\r\n    int x0 = rotateRight(X0, 5) ^ X1 ^ X3;\r\n    int x3 = rotateRight(X3, 7);\r\n    int x1 = rotateRight(X1, 1);\r\n    X3 = x3 ^ x2 ^ x0 << 3;\r\n    X1 = x1 ^ x0 ^ x2;\r\n    X2 = rotateRight(x2, 3);\r\n    X0 = rotateRight(x0, 13);\r\n}"
}, {
	"Path": "java.security.cert.CertUtil.trimX509Name",
	"Comment": "returns the given name converted to upper case and all multi spaces squezedto one space.",
	"Method": "String trimX509Name(String name){\r\n    String data = Strings.toUpperCase(name.trim());\r\n    int pos;\r\n    while ((pos = data.indexOf(\"  \")) >= 0) {\r\n        data = data.substring(0, pos) + data.substring(pos + 1);\r\n    }\r\n    while ((pos = data.indexOf(\" =\")) >= 0) {\r\n        data = data.substring(0, pos) + data.substring(pos + 1);\r\n    }\r\n    while ((pos = data.indexOf(\"= \")) >= 0) {\r\n        data = data.substring(0, pos + 1) + data.substring(pos + 2);\r\n    }\r\n    return data;\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSAuthenticatedDataStreamGenerator.open",
	"Comment": "generate an authenticated data structure with the encapsulated bytes marked as type datatype.",
	"Method": "OutputStream open(OutputStream out,MacCalculator macCalculator,OutputStream open,OutputStream out,MacCalculator macCalculator,DigestCalculator digestCalculator,OutputStream open,ASN1ObjectIdentifier dataType,OutputStream out,MacCalculator macCalculator,OutputStream open,ASN1ObjectIdentifier dataType,OutputStream out,MacCalculator macCalculator,DigestCalculator digestCalculator){\r\n    this.macCalculator = macCalculator;\r\n    try {\r\n        ASN1EncodableVector recipientInfos = new ASN1EncodableVector();\r\n        for (Iterator it = recipientInfoGenerators.iterator(); it.hasNext(); ) {\r\n            RecipientInfoGenerator recipient = (RecipientInfoGenerator) it.next();\r\n            recipientInfos.add(recipient.generate(macCalculator.getKey()));\r\n        }\r\n        BERSequenceGenerator cGen = new BERSequenceGenerator(out);\r\n        cGen.addObject(CMSObjectIdentifiers.authenticatedData);\r\n        BERSequenceGenerator authGen = new BERSequenceGenerator(cGen.getRawOutputStream(), 0, true);\r\n        authGen.addObject(new ASN1Integer(AuthenticatedData.calculateVersion(originatorInfo)));\r\n        if (originatorInfo != null) {\r\n            authGen.addObject(new DERTaggedObject(false, 0, originatorInfo));\r\n        }\r\n        if (berEncodeRecipientSet) {\r\n            authGen.getRawOutputStream().write(new BERSet(recipientInfos).getEncoded());\r\n        } else {\r\n            authGen.getRawOutputStream().write(new DERSet(recipientInfos).getEncoded());\r\n        }\r\n        AlgorithmIdentifier macAlgId = macCalculator.getAlgorithmIdentifier();\r\n        authGen.getRawOutputStream().write(macAlgId.getEncoded());\r\n        if (digestCalculator != null) {\r\n            authGen.addObject(new DERTaggedObject(false, 1, digestCalculator.getAlgorithmIdentifier()));\r\n        }\r\n        BERSequenceGenerator eiGen = new BERSequenceGenerator(authGen.getRawOutputStream());\r\n        eiGen.addObject(dataType);\r\n        OutputStream octetStream = CMSUtils.createBEROctetOutputStream(eiGen.getRawOutputStream(), 0, false, bufferSize);\r\n        OutputStream mOut;\r\n        if (digestCalculator != null) {\r\n            mOut = new TeeOutputStream(octetStream, digestCalculator.getOutputStream());\r\n        } else {\r\n            mOut = new TeeOutputStream(octetStream, macCalculator.getOutputStream());\r\n        }\r\n        return new CmsAuthenticatedDataOutputStream(macCalculator, digestCalculator, dataType, mOut, cGen, authGen, eiGen);\r\n    } catch (IOException e) {\r\n        throw new CMSException(\"exception decoding algorithm parameters.\", e);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.cmc.SimplePKIResponse.getCRLs",
	"Comment": "return any x.509 crl objects in this simplepkiresponse structure as a store of x509crlholder objects.",
	"Method": "Store<X509CRLHolder> getCRLs(){\r\n    return certificateResponse.getCRLs();\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.io.CipherInputStream.nextChunk",
	"Comment": "read data from underlying stream and process with cipher until end of stream or some data isavailable after cipher processing.",
	"Method": "int nextChunk(){\r\n    if (finalized) {\r\n        return -1;\r\n    }\r\n    bufOff = 0;\r\n    maxBuf = 0;\r\n    while (maxBuf == 0) {\r\n        int read = in.read(inBuf);\r\n        if (read == -1) {\r\n            finaliseCipher();\r\n            if (maxBuf == 0) {\r\n                return -1;\r\n            }\r\n            return maxBuf;\r\n        }\r\n        try {\r\n            ensureCapacity(read, false);\r\n            if (bufferedBlockCipher != null) {\r\n                maxBuf = bufferedBlockCipher.processBytes(inBuf, 0, read, buf, 0);\r\n            } else if (aeadBlockCipher != null) {\r\n                maxBuf = aeadBlockCipher.processBytes(inBuf, 0, read, buf, 0);\r\n            } else {\r\n                streamCipher.processBytes(inBuf, 0, read, buf, 0);\r\n                maxBuf = read;\r\n            }\r\n        } catch (Exception e) {\r\n            throw new CipherIOException(\"Error processing stream \", e);\r\n        }\r\n    }\r\n    return maxBuf;\r\n}"
}, {
	"Path": "org.bouncycastle.util.io.pem.PemReader.readPemObject",
	"Comment": "read the next pem object as a blob of raw data with header information.",
	"Method": "PemObject readPemObject(){\r\n    String line = readLine();\r\n    while (line != null && !line.startsWith(BEGIN)) {\r\n        line = readLine();\r\n    }\r\n    if (line != null) {\r\n        line = line.substring(BEGIN.length());\r\n        int index = line.indexOf('-');\r\n        String type = line.substring(0, index);\r\n        if (index > 0) {\r\n            return loadObject(type);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.selector.X509AttributeCertificateHolderSelectorBuilder.setAttributeCert",
	"Comment": "set the attribute certificate to be matched. if null isgiven any will do.",
	"Method": "void setAttributeCert(X509AttributeCertificateHolder attributeCert){\r\n    this.attributeCert = attributeCert;\r\n}"
}, {
	"Path": "com.sun.swingset3.demos.list.Permuter.main",
	"Comment": "simple test.takes modulus on command line and prints out permutation.",
	"Method": "void main(String[] args){\r\n    int modulus = Integer.parseInt(args[0]);\r\n    Permuter p = new Permuter(modulus);\r\n    for (int i = 0; i < modulus; i++) {\r\n        System.out.print(p.map(i) + \" \");\r\n    }\r\n    System.out.println();\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.modes.OFBBlockCipher.processBlock",
	"Comment": "process one block of input from the array in and write it tothe out array.",
	"Method": "int processBlock(byte[] in,int inOff,byte[] out,int outOff){\r\n    processBytes(in, inOff, blockSize, out, outOff);\r\n    return blockSize;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.ECNamedCurveTable.getParameterSpec",
	"Comment": "return a parameter spec representing the passed in namedcurve. the routine returns null if the curve is not present.",
	"Method": "ECNamedCurveParameterSpec getParameterSpec(String name){\r\n    X9ECParameters ecP = org.bouncycastle.crypto.ec.CustomNamedCurves.getByName(name);\r\n    if (ecP == null) {\r\n        try {\r\n            ecP = org.bouncycastle.crypto.ec.CustomNamedCurves.getByOID(new ASN1ObjectIdentifier(name));\r\n        } catch (IllegalArgumentException e) {\r\n        }\r\n        if (ecP == null) {\r\n            ecP = org.bouncycastle.asn1.x9.ECNamedCurveTable.getByName(name);\r\n            if (ecP == null) {\r\n                try {\r\n                    ecP = org.bouncycastle.asn1.x9.ECNamedCurveTable.getByOID(new ASN1ObjectIdentifier(name));\r\n                } catch (IllegalArgumentException e) {\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (ecP == null) {\r\n        return null;\r\n    }\r\n    return new ECNamedCurveParameterSpec(name, ecP.getCurve(), ecP.getG(), ecP.getN(), ecP.getH(), ecP.getSeed());\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.engines.RijndaelEngine.generateWorkingKey",
	"Comment": "calculate the necessary round keysthe number of calculations depends on keybits and blockbits",
	"Method": "long[][] generateWorkingKey(byte[] key){\r\n    int KC;\r\n    int t, rconpointer = 0;\r\n    int keyBits = key.length * 8;\r\n    byte[][] tk = new byte[4][MAXKC];\r\n    long[][] W = new long[MAXROUNDS + 1][4];\r\n    switch(keyBits) {\r\n        case 128:\r\n            KC = 4;\r\n            break;\r\n        case 160:\r\n            KC = 5;\r\n            break;\r\n        case 192:\r\n            KC = 6;\r\n            break;\r\n        case 224:\r\n            KC = 7;\r\n            break;\r\n        case 256:\r\n            KC = 8;\r\n            break;\r\n        default:\r\n            throw new IllegalArgumentException(\"Key length not 128/160/192/224/256 bits.\");\r\n    }\r\n    if (keyBits >= blockBits) {\r\n        ROUNDS = KC + 6;\r\n    } else {\r\n        ROUNDS = (BC / 8) + 6;\r\n    }\r\n    int index = 0;\r\n    for (int i = 0; i < key.length; i++) {\r\n        tk[i % 4][i / 4] = key[index++];\r\n    }\r\n    t = 0;\r\n    for (int j = 0; (j < KC) && (t < (ROUNDS + 1) * (BC / 8)); j++, t++) {\r\n        for (int i = 0; i < 4; i++) {\r\n            W[t / (BC / 8)][i] |= (long) (tk[i][j] & 0xff) << ((t * 8) % BC);\r\n        }\r\n    }\r\n    while (t < (ROUNDS + 1) * (BC / 8)) {\r\n        for (int i = 0; i < 4; i++) {\r\n            tk[i][0] ^= S[tk[(i + 1) % 4][KC - 1] & 0xff];\r\n        }\r\n        tk[0][0] ^= rcon[rconpointer++];\r\n        if (KC <= 6) {\r\n            for (int j = 1; j < KC; j++) {\r\n                for (int i = 0; i < 4; i++) {\r\n                    tk[i][j] ^= tk[i][j - 1];\r\n                }\r\n            }\r\n        } else {\r\n            for (int j = 1; j < 4; j++) {\r\n                for (int i = 0; i < 4; i++) {\r\n                    tk[i][j] ^= tk[i][j - 1];\r\n                }\r\n            }\r\n            for (int i = 0; i < 4; i++) {\r\n                tk[i][4] ^= S[tk[i][3] & 0xff];\r\n            }\r\n            for (int j = 5; j < KC; j++) {\r\n                for (int i = 0; i < 4; i++) {\r\n                    tk[i][j] ^= tk[i][j - 1];\r\n                }\r\n            }\r\n        }\r\n        for (int j = 0; (j < KC) && (t < (ROUNDS + 1) * (BC / 8)); j++, t++) {\r\n            for (int i = 0; i < 4; i++) {\r\n                W[t / (BC / 8)][i] |= (long) (tk[i][j] & 0xff) << ((t * 8) % (BC));\r\n            }\r\n        }\r\n    }\r\n    return W;\r\n}"
}, {
	"Path": "javax.crypto.spec.RC5ParameterSpec.getIV",
	"Comment": "returns the iv or null if this parameter set does not contain an iv.",
	"Method": "byte[] getIV(){\r\n    if (iv == null) {\r\n        return null;\r\n    }\r\n    byte[] tmp = new byte[iv.length];\r\n    System.arraycopy(iv, 0, tmp, 0, iv.length);\r\n    return tmp;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.qtesla.QTESLAKeyPairGenerator.init",
	"Comment": "initialize the generator with a security category and a source of randomness.",
	"Method": "void init(KeyGenerationParameters param){\r\n    QTESLAKeyGenerationParameters parameters = (QTESLAKeyGenerationParameters) param;\r\n    this.secureRandom = parameters.getRandom();\r\n    this.securityCategory = parameters.getSecurityCategory();\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.engines.RSACoreEngine.getInputBlockSize",
	"Comment": "return the maximum size for an input block to this engine.for rsa this is always one byte less than the key size onencryption, and the same length as the key size on decryption.",
	"Method": "int getInputBlockSize(){\r\n    int bitSize = key.getModulus().bitLength();\r\n    if (forEncryption) {\r\n        return (bitSize + 7) / 8 - 1;\r\n    } else {\r\n        return (bitSize + 7) / 8;\r\n    }\r\n}"
}, {
	"Path": "javax.crypto.Mac.getAlgorithm",
	"Comment": "returns the algorithm name of this mac object.this is the same name that was specified in one of thegetinstance calls that created this mac object.",
	"Method": "String getAlgorithm(){\r\n    return algorithm;\r\n}"
}, {
	"Path": "org.bouncycastle.i18n.TextBundle.getText",
	"Comment": "returns the text message in the given locale and the defaut timezone.",
	"Method": "String getText(Locale loc,TimeZone timezone,String getText,Locale loc){\r\n    return getEntry(TEXT_ENTRY, loc, TimeZone.getDefault());\r\n}"
}, {
	"Path": "org.bouncycastle.cert.crmf.CertificateRequestMessage.hasControl",
	"Comment": "return whether or not this request has a specific type of control value.",
	"Method": "boolean hasControl(ASN1ObjectIdentifier type){\r\n    return findControl(type) != null;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.util.PublicKeyFactory.createKey",
	"Comment": "create a public key from the passed in subjectpublickeyinfo",
	"Method": "AsymmetricKeyParameter createKey(byte[] keyInfoData,AsymmetricKeyParameter createKey,InputStream inStr,AsymmetricKeyParameter createKey,SubjectPublicKeyInfo keyInfo,AsymmetricKeyParameter createKey,SubjectPublicKeyInfo keyInfo,Object defaultParams){\r\n    AlgorithmIdentifier algId = keyInfo.getAlgorithm();\r\n    SubjectPublicKeyInfoConverter converter = (SubjectPublicKeyInfoConverter) converters.get(algId.getAlgorithm());\r\n    if (converter != null) {\r\n        return converter.getPublicKeyParameters(keyInfo, defaultParams);\r\n    } else {\r\n        throw new IOException(\"algorithm identifier in public key not recognised: \" + algId.getAlgorithm());\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPPublicKeyRing.getEncoded",
	"Comment": "return an encoding of the key ring, with trust packets stripped out if fortransfer is true.",
	"Method": "byte[] getEncoded(){\r\n    ByteArrayOutputStream bOut = new ByteArrayOutputStream();\r\n    this.encode(bOut, forTransfer);\r\n    return bOut.toByteArray();\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.generators.OpenBSDBCrypt.checkPassword",
	"Comment": "checks if a password corresponds to a 60 character bcrypt string",
	"Method": "boolean checkPassword(String bcryptString,char[] password){\r\n    if (bcryptString.length() != 60) {\r\n        throw new DataLengthException(\"Bcrypt String length: \" + bcryptString.length() + \", 60 required.\");\r\n    }\r\n    if (bcryptString.charAt(0) != '$' || bcryptString.charAt(3) != '$' || bcryptString.charAt(6) != '$') {\r\n        throw new IllegalArgumentException(\"Invalid Bcrypt String format.\");\r\n    }\r\n    String version = bcryptString.substring(1, 3);\r\n    if (!allowedVersions.contains(version)) {\r\n        throw new IllegalArgumentException(\"Bcrypt version '\" + version + \"' is not supported by this implementation\");\r\n    }\r\n    int cost = 0;\r\n    String costStr = bcryptString.substring(4, 6);\r\n    try {\r\n        cost = Integer.parseInt(costStr);\r\n    } catch (NumberFormatException nfe) {\r\n        throw new IllegalArgumentException(\"Invalid cost factor: \" + costStr);\r\n    }\r\n    if (cost < 4 || cost > 31) {\r\n        throw new IllegalArgumentException(\"Invalid cost factor: \" + cost + \", 4 < cost < 31 expected.\");\r\n    }\r\n    if (password == null) {\r\n        throw new IllegalArgumentException(\"Missing password.\");\r\n    }\r\n    byte[] salt = decodeSaltString(bcryptString.substring(bcryptString.lastIndexOf('$') + 1, bcryptString.length() - 31));\r\n    String newBcryptString = generate(version, password, salt, cost);\r\n    return bcryptString.equals(newBcryptString);\r\n}"
}, {
	"Path": "org.bouncycastle.tls.crypto.impl.jcajce.JcaTlsCrypto.createHash",
	"Comment": "if you want to create your own versions of hash functions, override this method.",
	"Method": "TlsHash createHash(short algorithm,TlsHash createHash,String digestName){\r\n    return new JcaTlsHash(helper.createDigest(digestName));\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.tls.DTLSReplayWindow.shouldDiscard",
	"Comment": "check whether a received record with the given sequence number should be rejected as a duplicate.",
	"Method": "boolean shouldDiscard(long seq){\r\n    if ((seq & VALID_SEQ_MASK) != seq) {\r\n        return true;\r\n    }\r\n    if (seq <= latestConfirmedSeq) {\r\n        long diff = latestConfirmedSeq - seq;\r\n        if (diff >= WINDOW_SIZE) {\r\n            return true;\r\n        }\r\n        if ((bitmap & (1L << diff)) != 0) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "java.security.cert.X509CRLSelector.getDateAndTime",
	"Comment": "returns the dateandtime criterion. the specified date must be equal to orlater than the value of the thisupdate component of thex509crl and earlier than the value of the nextupdatecomponent. there is no match if the x509crl does notcontain a nextupdate component. if null, no dateandtimecheck will be done.note that the date returned is cloned to protect againstsubsequent modifications.",
	"Method": "Date getDateAndTime(){\r\n    if (dateAndTime == null) {\r\n        return null;\r\n    }\r\n    return new Date(dateAndTime.getTime());\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPPublicKeyRingCollection.removePublicKeyRing",
	"Comment": "return a new collection object containing the contents of this collection withthe passed in public key ring removed.",
	"Method": "PGPPublicKeyRingCollection removePublicKeyRing(PGPPublicKeyRingCollection ringCollection,PGPPublicKeyRing publicKeyRing){\r\n    Long key = new Long(publicKeyRing.getPublicKey().getKeyID());\r\n    if (!ringCollection.pubRings.containsKey(key)) {\r\n        throw new IllegalArgumentException(\"Collection does not contain a key with a keyID for the passed in ring.\");\r\n    }\r\n    Map newPubRings = new HashMap(ringCollection.pubRings);\r\n    List newOrder = new ArrayList(ringCollection.order);\r\n    newPubRings.remove(key);\r\n    for (int i = 0; i < newOrder.size(); i++) {\r\n        Long r = (Long) newOrder.get(i);\r\n        if (r.longValue() == key.longValue()) {\r\n            newOrder.remove(i);\r\n            break;\r\n        }\r\n    }\r\n    return new PGPPublicKeyRingCollection(newPubRings, newOrder);\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPV3SignatureGenerator.generate",
	"Comment": "return a v3 signature object containing the current signature state.",
	"Method": "PGPSignature generate(){\r\n    long creationTime = new Date().getTime() / 1000;\r\n    ByteArrayOutputStream sOut = new ByteArrayOutputStream();\r\n    sOut.write(sigType);\r\n    sOut.write((byte) (creationTime >> 24));\r\n    sOut.write((byte) (creationTime >> 16));\r\n    sOut.write((byte) (creationTime >> 8));\r\n    sOut.write((byte) creationTime);\r\n    byte[] hData = sOut.toByteArray();\r\n    blockUpdate(hData, 0, hData.length);\r\n    MPInteger[] sigValues;\r\n    if (contentSigner.getKeyAlgorithm() == PublicKeyAlgorithmTags.RSA_SIGN || contentSigner.getKeyAlgorithm() == PublicKeyAlgorithmTags.RSA_GENERAL) {\r\n        sigValues = new MPInteger[1];\r\n        sigValues[0] = new MPInteger(new BigInteger(1, contentSigner.getSignature()));\r\n    } else {\r\n        sigValues = PGPUtil.dsaSigToMpi(contentSigner.getSignature());\r\n    }\r\n    byte[] digest = contentSigner.getDigest();\r\n    byte[] fingerPrint = new byte[2];\r\n    fingerPrint[0] = digest[0];\r\n    fingerPrint[1] = digest[1];\r\n    return new PGPSignature(new SignaturePacket(3, contentSigner.getType(), contentSigner.getKeyID(), contentSigner.getKeyAlgorithm(), contentSigner.getHashAlgorithm(), creationTime * 1000, fingerPrint, sigValues));\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.agreement.jpake.JPAKEUtil.validateParticipantIdsEqual",
	"Comment": "validates that the given participant ids are equal.this is used to ensure that the payloads received fromeach round all come from the same participant.",
	"Method": "void validateParticipantIdsEqual(String expectedParticipantId,String actualParticipantId){\r\n    if (!expectedParticipantId.equals(actualParticipantId)) {\r\n        throw new CryptoException(\"Received payload from incorrect partner (\" + actualParticipantId + \"). Expected to receive payload from \" + expectedParticipantId + \".\");\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.tls.TlsProtocol.processChangeCipherSpec",
	"Comment": "this method is called, when a change cipher spec message is received.",
	"Method": "void processChangeCipherSpec(byte[] buf,int off,int len){\r\n    for (int i = 0; i < len; ++i) {\r\n        short message = TlsUtils.readUint8(buf, off + i);\r\n        if (message != ChangeCipherSpec.change_cipher_spec) {\r\n            throw new TlsFatalAlert(AlertDescription.decode_error);\r\n        }\r\n        if (this.receivedChangeCipherSpec || alertQueue.available() > 0 || handshakeQueue.available() > 0) {\r\n            throw new TlsFatalAlert(AlertDescription.unexpected_message);\r\n        }\r\n        recordStream.receivedReadCipherSpec();\r\n        this.receivedChangeCipherSpec = true;\r\n        handleChangeCipherSpecMessage();\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.bcpg.SignaturePacket.getSignatureTrailer",
	"Comment": "return the signature trailer that must be included with the datato reconstruct the signature",
	"Method": "byte[] getSignatureTrailer(){\r\n    byte[] trailer = null;\r\n    if (version == 3 || version == 2) {\r\n        trailer = new byte[5];\r\n        long time = creationTime / 1000;\r\n        trailer[0] = (byte) signatureType;\r\n        trailer[1] = (byte) (time >> 24);\r\n        trailer[2] = (byte) (time >> 16);\r\n        trailer[3] = (byte) (time >> 8);\r\n        trailer[4] = (byte) (time);\r\n    } else {\r\n        ByteArrayOutputStream sOut = new ByteArrayOutputStream();\r\n        try {\r\n            sOut.write((byte) this.getVersion());\r\n            sOut.write((byte) this.getSignatureType());\r\n            sOut.write((byte) this.getKeyAlgorithm());\r\n            sOut.write((byte) this.getHashAlgorithm());\r\n            ByteArrayOutputStream hOut = new ByteArrayOutputStream();\r\n            SignatureSubpacket[] hashed = this.getHashedSubPackets();\r\n            for (int i = 0; i != hashed.length; i++) {\r\n                hashed[i].encode(hOut);\r\n            }\r\n            byte[] data = hOut.toByteArray();\r\n            sOut.write((byte) (data.length >> 8));\r\n            sOut.write((byte) data.length);\r\n            sOut.write(data);\r\n            byte[] hData = sOut.toByteArray();\r\n            sOut.write((byte) this.getVersion());\r\n            sOut.write((byte) 0xff);\r\n            sOut.write((byte) (hData.length >> 24));\r\n            sOut.write((byte) (hData.length >> 16));\r\n            sOut.write((byte) (hData.length >> 8));\r\n            sOut.write((byte) (hData.length));\r\n        } catch (IOException e) {\r\n            throw new RuntimeException(\"exception generating trailer: \" + e);\r\n        }\r\n        trailer = sOut.toByteArray();\r\n    }\r\n    return trailer;\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.provider.asymmetric.elgamal.BCElGamalPrivateKey.getEncoded",
	"Comment": "return a pkcs8 representation of the key. the sequence returnedrepresents a full privatekeyinfo object.",
	"Method": "byte[] getEncoded(){\r\n    try {\r\n        PrivateKeyInfo info = new PrivateKeyInfo(new AlgorithmIdentifier(OIWObjectIdentifiers.elGamalAlgorithm, new ElGamalParameter(elSpec.getP(), elSpec.getG())), new ASN1Integer(getX()));\r\n        return info.getEncoded(ASN1Encoding.DER);\r\n    } catch (IOException e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.mime.test.Base64TransferEncodingTest.testDecodeLengths",
	"Comment": "this test causes the final line of base64 to not be a multiple of 64.",
	"Method": "void testDecodeLengths(){\r\n    byte[][] original = new byte[4][48];\r\n    original[original.length - 1] = new byte[22];\r\n    ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    for (int i = 0; i != original.length; i++) {\r\n        byte[] row = original[i];\r\n        random.nextBytes(row);\r\n        bos.write(Base64.encode(row));\r\n        bos.write('\\r');\r\n        bos.write('\\n');\r\n    }\r\n    verifyDecode(original, bos);\r\n}"
}, {
	"Path": "org.bouncycastle.test.est.TestEnroll.testEnrollUsingTLSClientAuthAndBasicAuth",
	"Comment": "test enrollment using tls do do the client authentication.in this test we are going to use the bc api to generate a client certificate that the server will accept.",
	"Method": "void testEnrollUsingTLSClientAuthAndBasicAuth(){\r\n    ESTTestUtils.ensureProvider();\r\n    X509CertificateHolder caCert = ESTTestUtils.readPemCertificate(ESTServerUtils.makeRelativeToServerHome(\"/extCA/cacert.crt\"));\r\n    PrivateKey caPrivateKey = ESTTestUtils.readPemPrivateKey(ESTServerUtils.makeRelativeToServerHome(\"/extCA/private/cakey.pem\"), \"ECDSA\");\r\n    ECGenParameterSpec ecGenSpec = new ECGenParameterSpec(\"prime256v1\");\r\n    KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"ECDSA\", \"BC\");\r\n    kpg.initialize(ecGenSpec, new SecureRandom());\r\n    KeyPair originalKeyPair = kpg.generateKeyPair();\r\n    X500NameBuilder builder = new X500NameBuilder();\r\n    builder.addRDN(BCStyle.C, \"AU\");\r\n    builder.addRDN(BCStyle.CN, \"Bunyip Bluegum\");\r\n    builder.addRDN(BCStyle.O, \"Pudding Protectors\");\r\n    builder.addRDN(BCStyle.L, \"Victoria\");\r\n    X500Name name = builder.build();\r\n    KeyUsage keyUsage = new KeyUsage(KeyUsage.keyCertSign | KeyUsage.digitalSignature | KeyUsage.keyEncipherment | KeyUsage.dataEncipherment | KeyUsage.cRLSign);\r\n    ASN1EncodableVector purposes = new ASN1EncodableVector();\r\n    purposes.add(KeyPurposeId.id_kp_serverAuth);\r\n    purposes.add(KeyPurposeId.id_kp_clientAuth);\r\n    purposes.add(KeyPurposeId.anyExtendedKeyUsage);\r\n    X509Certificate clientTLSCert = ESTTestUtils.createASignedCert(\"SHA256WITHECDSA\", name, SubjectPublicKeyInfo.getInstance(originalKeyPair.getPublic().getEncoded()), caCert.getSubject(), caPrivateKey, 1, purposes, keyUsage);\r\n    KeyStore clientKeyStore = KeyStore.getInstance(\"JKS\");\r\n    clientKeyStore.load(null);\r\n    char[] clientKeyStorePass = \"tstpass\".toCharArray();\r\n    // This is hardcoded into the test server.\r\n    clientKeyStore.setKeyEntry(\"estuser\", originalKeyPair.getPrivate(), clientKeyStorePass, new Certificate[] { clientTLSCert });\r\n    clientKeyStore.store(new ByteArrayOutputStream(), clientKeyStorePass);\r\n    kpg.initialize(ecGenSpec);\r\n    KeyPair enrollmentPair = kpg.generateKeyPair();\r\n    ESTTestUtils.ensureProvider();\r\n    final ESTServerUtils.ServerInstance serverInstance = startDefaultServerTLSAndBasicAuth(0, false);\r\n    try {\r\n        TrustAnchor ta = new TrustAnchor(ESTTestUtils.toJavaX509Certificate(ESTTestUtils.readPemCertificate(ESTServerUtils.makeRelativeToServerHome(\"/estCA/cacert.crt\"))), null);\r\n        PKCS10CertificationRequestBuilder pkcs10Builder = new JcaPKCS10CertificationRequestBuilder(new X500Name(\"CN=Test\"), enrollmentPair.getPublic());\r\n        PKCS10CertificationRequest csr = pkcs10Builder.build(new JcaContentSignerBuilder(\"SHA256WITHECDSA\").setProvider(\"BC\").build(enrollmentPair.getPrivate()));\r\n        JsseESTServiceBuilder estServiceBuilder = new JsseESTServiceBuilder(\"localhost:8443\", JcaJceUtils.getCertPathTrustManager(ESTTestUtils.toTrustAnchor(ESTTestUtils.readPemCertificate(ESTServerUtils.makeRelativeToServerHome(\"/estCA/cacert.crt\"))), null)).withProvider(BouncyCastleJsseProvider.PROVIDER_NAME).withTLSVersion(\"TLS\");\r\n        estServiceBuilder.withKeyManagers(JcaJceUtils.createKeyManagerFactory(KeyManagerFactory.getDefaultAlgorithm(), null, clientKeyStore, clientKeyStorePass).getKeyManagers());\r\n        ESTService est = estServiceBuilder.build();\r\n        EnrollmentResponse enr = est.simpleEnroll(false, csr, new JcaHttpAuthBuilder(\"estreal\", \"estuser\", \"estpwd\".toCharArray()).setNonceGenerator(new SecureRandom()).setProvider(\"BC\").build());\r\n        X509Certificate expectedCA = ESTTestUtils.toJavaX509Certificate(ESTTestUtils.readPemCertificate(ESTServerUtils.makeRelativeToServerHome(\"/estCA/cacert.crt\")));\r\n        X509CertificateHolder enrolledAsHolder = ESTService.storeToArray(enr.getStore())[0];\r\n        X509Certificate enrolled = ESTTestUtils.toJavaX509Certificate(enrolledAsHolder);\r\n        enrolled.verify(expectedCA.getPublicKey(), \"BC\");\r\n        TestCase.assertEquals(enrolledAsHolder.getSubject(), csr.getSubject());\r\n        TestCase.assertEquals(enrolledAsHolder.getSubjectPublicKeyInfo(), csr.getSubjectPublicKeyInfo());\r\n    } finally {\r\n        serverInstance.getServer().stop_server();\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPSecretKeyRing.getPublicKey",
	"Comment": "return the public key with the passed in fingerprint if itis present.",
	"Method": "PGPPublicKey getPublicKey(PGPPublicKey getPublicKey,long keyID,PGPPublicKey getPublicKey,byte[] fingerprint){\r\n    PGPSecretKey key = getSecretKey(fingerprint);\r\n    if (key != null) {\r\n        return key.getPublicKey();\r\n    }\r\n    for (int i = 0; i != extraPubKeys.size(); i++) {\r\n        PGPPublicKey k = (PGPPublicKey) keys.get(i);\r\n        if (Arrays.areEqual(fingerprint, k.getFingerprint())) {\r\n            return k;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.cms.DefaultCMSSignatureAlgorithmNameGenerator.setSigningDigestAlgorithmMapping",
	"Comment": "set the mapping for the digest algorithm to use in conjunction with a signeddata generationor interpretation.",
	"Method": "void setSigningDigestAlgorithmMapping(ASN1ObjectIdentifier oid,String algorithmName){\r\n    digestAlgs.put(oid, algorithmName);\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.X509CRLSelector.getMaxCRL",
	"Comment": "returns the maxcrlnumber criterion. the x509crl must havea crl number extension whose value is less than or equal to the specifiedvalue. if null, no maxcrlnumber check will be done.",
	"Method": "BigInteger getMaxCRL(){\r\n    return maxCRL;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.agreement.srp.SRP6Server.verifyClientEvidenceMessage",
	"Comment": "authenticates the received client evidence message m1 and saves it only if correct.\tto be called after calculating the secret s.",
	"Method": "boolean verifyClientEvidenceMessage(BigInteger clientM1){\r\n    if (this.A == null || this.B == null || this.S == null) {\r\n        throw new CryptoException(\"Impossible to compute and verify M1: \" + \"some data are missing from the previous operations (A,B,S)\");\r\n    }\r\n    BigInteger computedM1 = SRP6Util.calculateM1(digest, N, A, B, S);\r\n    if (computedM1.equals(clientM1)) {\r\n        this.M1 = clientM1;\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSSignedDataGenerator.generate",
	"Comment": "generate a cms signed data object which can be carrying a detached cms signature, or have encapsulated data, depending on the valueof the encapsulated parameter.",
	"Method": "CMSSignedData generate(CMSTypedData content,CMSSignedData generate,CMSTypedData content,boolean encapsulate){\r\n    if (!signerInfs.isEmpty()) {\r\n        throw new IllegalStateException(\"this method can only be used with SignerInfoGenerator\");\r\n    }\r\n    ASN1EncodableVector digestAlgs = new ASN1EncodableVector();\r\n    ASN1EncodableVector signerInfos = new ASN1EncodableVector();\r\n    digests.clear();\r\n    for (Iterator it = _signers.iterator(); it.hasNext(); ) {\r\n        SignerInformation signer = (SignerInformation) it.next();\r\n        digestAlgs.add(CMSSignedHelper.INSTANCE.fixAlgID(signer.getDigestAlgorithmID()));\r\n        signerInfos.add(signer.toASN1Structure());\r\n    }\r\n    ASN1ObjectIdentifier contentTypeOID = content.getContentType();\r\n    ASN1OctetString octs = null;\r\n    if (content.getContent() != null) {\r\n        ByteArrayOutputStream bOut = null;\r\n        if (encapsulate) {\r\n            bOut = new ByteArrayOutputStream();\r\n        }\r\n        OutputStream cOut = CMSUtils.attachSignersToOutputStream(signerGens, bOut);\r\n        cOut = CMSUtils.getSafeOutputStream(cOut);\r\n        try {\r\n            content.write(cOut);\r\n            cOut.close();\r\n        } catch (IOException e) {\r\n            throw new CMSException(\"data processing exception: \" + e.getMessage(), e);\r\n        }\r\n        if (encapsulate) {\r\n            octs = new BEROctetString(bOut.toByteArray());\r\n        }\r\n    }\r\n    for (Iterator it = signerGens.iterator(); it.hasNext(); ) {\r\n        SignerInfoGenerator sGen = (SignerInfoGenerator) it.next();\r\n        SignerInfo inf = sGen.generate(contentTypeOID);\r\n        digestAlgs.add(inf.getDigestAlgorithm());\r\n        signerInfos.add(inf);\r\n        byte[] calcDigest = sGen.getCalculatedDigest();\r\n        if (calcDigest != null) {\r\n            digests.put(inf.getDigestAlgorithm().getAlgorithm().getId(), calcDigest);\r\n        }\r\n    }\r\n    ASN1Set certificates = null;\r\n    if (certs.size() != 0) {\r\n        certificates = CMSUtils.createBerSetFromList(certs);\r\n    }\r\n    ASN1Set certrevlist = null;\r\n    if (crls.size() != 0) {\r\n        certrevlist = CMSUtils.createBerSetFromList(crls);\r\n    }\r\n    ContentInfo encInfo = new ContentInfo(contentTypeOID, octs);\r\n    SignedData sd = new SignedData(new DERSet(digestAlgs), encInfo, certificates, certrevlist, new DERSet(signerInfos));\r\n    ContentInfo contentInfo = new ContentInfo(CMSObjectIdentifiers.signedData, sd);\r\n    return new CMSSignedData(content, contentInfo);\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.operator.PBESecretKeyEncryptor.encryptKeyData",
	"Comment": "encrypt the passed in keydata using the key and the iv provided.this method is only used for processing version 3 keys.",
	"Method": "byte[] encryptKeyData(byte[] keyData,int keyOff,int keyLen,byte[] encryptKeyData,byte[] key,byte[] keyData,int keyOff,int keyLen,byte[] encryptKeyData,byte[] key,byte[] iv,byte[] keyData,int keyOff,int keyLen){\r\n    throw new PGPException(\"encryption of version 3 keys not supported.\");\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.gmss.Treehash.wasFinished",
	"Comment": "method to check whether the instance has been finished or not",
	"Method": "boolean wasFinished(){\r\n    return this.isFinished;\r\n}"
}, {
	"Path": "com.sun.swingset3.codeview.SnippetHighlighter.install",
	"Comment": "called when the ui is being installed into theinterface of a jtextcomponent.installs the editor, andremoves any existing highlights.",
	"Method": "void install(JTextComponent c){\r\n    component = c;\r\n    removeAllHighlights();\r\n}"
}, {
	"Path": "java.security.cert.CertPath.writeReplace",
	"Comment": "replaces the certpath to be serialized with a certpathrepobject.",
	"Method": "Object writeReplace(){\r\n    try {\r\n        return new CertPathRep(getType(), getEncoded());\r\n    } catch (CertificateException ce) {\r\n        throw new NotSerializableException(\" java.security.cert.CertPath: \" + getType());\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.CertStoreException.getCause",
	"Comment": "returns the cause of this certstoreexception ornull if the cause is nonexistent or unknown.",
	"Method": "Throwable getCause(){\r\n    return cause;\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSEnvelopedDataParser.getOriginatorInfo",
	"Comment": "return the originator information associated with this message if present.",
	"Method": "OriginatorInformation getOriginatorInfo(){\r\n    return originatorInfo;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.x509.ExtendedKeyUsage.fromExtensions",
	"Comment": "retrieve an extendedkeyusage for a passed in extensions object, if present.",
	"Method": "ExtendedKeyUsage fromExtensions(Extensions extensions){\r\n    return ExtendedKeyUsage.getInstance(extensions.getExtensionParsedValue(Extension.extendedKeyUsage));\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSSignedDataParser.getSignedContentTypeOID",
	"Comment": "return the a string representation of the oid associated with theencapsulated content info structure carried in the signed data.",
	"Method": "String getSignedContentTypeOID(){\r\n    return _signedContentType.getId();\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPEncryptedDataGenerator.addMethod",
	"Comment": "add a key encryption method to be used to encrypt the session data associated with thisencrypted data.",
	"Method": "void addMethod(PGPKeyEncryptionMethodGenerator method){\r\n    methods.add(method);\r\n}"
}, {
	"Path": "org.bouncycastle.x509.X509CollectionStoreParameters.clone",
	"Comment": "returns a shallow clone. the returned contents are not copied, so addingor removing objects will effect this.",
	"Method": "Object clone(){\r\n    return new X509CollectionStoreParameters(collection);\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.DERIA5String.isIA5String",
	"Comment": "return true if the passed in string can be represented withoutloss as an ia5string, false otherwise.",
	"Method": "boolean isIA5String(String str){\r\n    for (int i = str.length() - 1; i >= 0; i--) {\r\n        char ch = str.charAt(i);\r\n        if (ch > 0x007f) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2Vector.getBit",
	"Comment": "return the value of the bit of this vector at the specified index.",
	"Method": "int getBit(int index){\r\n    if (index >= length) {\r\n        throw new IndexOutOfBoundsException();\r\n    }\r\n    int q = index >> 5;\r\n    int r = index & 0x1f;\r\n    return (v[q] & (1 << r)) >>> r;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2Vector.extractVector",
	"Comment": "return a new vector consisting of the elements of this vector with theindices given by the set setj.",
	"Method": "GF2Vector extractVector(int[] setJ){\r\n    int k = setJ.length;\r\n    if (setJ[k - 1] > length) {\r\n        throw new ArithmeticException(\"invalid index set\");\r\n    }\r\n    GF2Vector result = new GF2Vector(k);\r\n    for (int i = 0; i < k; i++) {\r\n        int e = v[setJ[i] >> 5] & (1 << (setJ[i] & 0x1f));\r\n        if (e != 0) {\r\n            result.v[i >> 5] |= 1 << (i & 0x1f);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.agreement.DHAgreement.calculateAgreement",
	"Comment": "given a message from a given party and the corresponding public key,calculate the next message in the agreement sequence. in this casethis will represent the shared secret.",
	"Method": "BigInteger calculateAgreement(DHPublicKeyParameters pub,BigInteger message){\r\n    if (!pub.getParameters().equals(dhParams)) {\r\n        throw new IllegalArgumentException(\"Diffie-Hellman public key has wrong parameters.\");\r\n    }\r\n    BigInteger p = dhParams.getP();\r\n    BigInteger peerY = pub.getY();\r\n    if (peerY == null || peerY.compareTo(ONE) <= 0 || peerY.compareTo(p.subtract(ONE)) >= 0) {\r\n        throw new IllegalArgumentException(\"Diffie-Hellman public key is weak\");\r\n    }\r\n    BigInteger result = peerY.modPow(privateValue, p);\r\n    if (result.equals(ONE)) {\r\n        throw new IllegalStateException(\"Shared key can't be 1\");\r\n    }\r\n    return message.modPow(key.getX(), p).multiply(result).mod(p);\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.PKIXCRLStoreSelector.isDeltaCRLIndicatorEnabled",
	"Comment": "returns if this selector must match crls with the delta crl indicatorextension set. defaults to false.",
	"Method": "boolean isDeltaCRLIndicatorEnabled(){\r\n    return deltaCRLIndicator;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.modes.CFBBlockCipher.reset",
	"Comment": "reset the chaining vector back to the iv and reset the underlyingcipher.",
	"Method": "void reset(){\r\n    System.arraycopy(IV, 0, cfbV, 0, IV.length);\r\n    Arrays.fill(inBuf, (byte) 0);\r\n    byteCount = 0;\r\n    cipher.reset();\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.ntru.polynomial.LongPolynomial2.mult2And",
	"Comment": "multiplies this polynomial by 2 and applies an and mask to the upper andlower halves of each coefficients.",
	"Method": "void mult2And(int mask){\r\n    long longMask = (((long) mask) << 24) + mask;\r\n    for (int i = 0; i < coeffs.length; i++) {\r\n        coeffs[i] = (coeffs[i] << 1) & longMask;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.operator.jcajce.JcaKeyFingerprintCalculator.setProvider",
	"Comment": "sets the provider to use to obtain cryptographic primitives.",
	"Method": "JcaKeyFingerprintCalculator setProvider(Provider provider,JcaKeyFingerprintCalculator setProvider,String providerName){\r\n    return new JcaKeyFingerprintCalculator(new NamedJcaJceHelper(providerName));\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.cryptopro.GOST3410NamedParameters.getNames",
	"Comment": "returns an enumeration containing the name strings for parameterscontained in this structure.",
	"Method": "Enumeration getNames(){\r\n    return objIds.keys();\r\n}"
}, {
	"Path": "org.bouncycastle.pkix.jcajce.RFC3280CertPathUtilities.processCRLB1",
	"Comment": "if the dp includes crlissuer, then verify that the issuer field in thecomplete crl matches crlissuer in the dp and that the complete crlcontains an issuing distribution point extension with the indirectcrlboolean asserted. otherwise, verify that the crl issuer matches thecertificate issuer.",
	"Method": "void processCRLB1(DistributionPoint dp,Object cert,X509CRL crl){\r\n    ASN1Primitive idp = RevocationUtilities.getExtensionValue(crl, Extension.issuingDistributionPoint);\r\n    boolean isIndirect = false;\r\n    if (idp != null) {\r\n        if (IssuingDistributionPoint.getInstance(idp).isIndirectCRL()) {\r\n            isIndirect = true;\r\n        }\r\n    }\r\n    byte[] issuerBytes;\r\n    issuerBytes = crl.getIssuerX500Principal().getEncoded();\r\n    boolean matchIssuer = false;\r\n    if (dp.getCRLIssuer() != null) {\r\n        GeneralName[] genNames = dp.getCRLIssuer().getNames();\r\n        for (int j = 0; j < genNames.length; j++) {\r\n            if (genNames[j].getTagNo() == GeneralName.directoryName) {\r\n                try {\r\n                    if (Arrays.areEqual(genNames[j].getName().toASN1Primitive().getEncoded(), issuerBytes)) {\r\n                        matchIssuer = true;\r\n                    }\r\n                } catch (IOException e) {\r\n                    throw new AnnotatedException(\"CRL issuer information from distribution point cannot be decoded.\", e);\r\n                }\r\n            }\r\n        }\r\n        if (matchIssuer && !isIndirect) {\r\n            throw new AnnotatedException(\"Distribution point contains cRLIssuer field but CRL is not indirect.\");\r\n        }\r\n        if (!matchIssuer) {\r\n            throw new AnnotatedException(\"CRL issuer of CRL does not match CRL issuer of distribution point.\");\r\n        }\r\n    } else {\r\n        if (crl.getIssuerX500Principal().equals(((X509Certificate) cert).getIssuerX500Principal())) {\r\n            matchIssuer = true;\r\n        }\r\n    }\r\n    if (!matchIssuer) {\r\n        throw new AnnotatedException(\"Cannot find matching CRL issuer for certificate.\");\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.cert.ocsp.CertificateID.getSerialNumber",
	"Comment": "return the serial number for the certificate associatedwith this request.",
	"Method": "BigInteger getSerialNumber(){\r\n    return id.getSerialNumber().getValue();\r\n}"
}, {
	"Path": "org.bouncycastle.cert.X509CRLHolder.getExtensions",
	"Comment": "return the extensions block associated with this crl if there is one.",
	"Method": "Extensions getExtensions(){\r\n    return extensions;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.generators.BCrypt.cyclicXorKey",
	"Comment": "xor p with key cyclic.this is the first part of expandkey function",
	"Method": "void cyclicXorKey(byte[] key){\r\n    int keyLength = key.length;\r\n    int keyIndex = 0;\r\n    for (int i = 0; i < P_SZ; i++) {\r\n        int data = 0x0000000;\r\n        for (int j = 0; j < 4; j++) {\r\n            data = (data << 8) | (key[keyIndex++] & 0xff);\r\n            if (keyIndex >= keyLength) {\r\n                keyIndex = 0;\r\n            }\r\n        }\r\n        P[i] ^= data;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPSecretKeyRing.getExtraPublicKeys",
	"Comment": "return an iterator of the public keys in the secret key ring thathave no matching private key. at the moment only personal certificate dataappears in this fashion.",
	"Method": "Iterator getExtraPublicKeys(){\r\n    return extraPubKeys.iterator();\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.generators.Argon2BytesGenerator.init",
	"Comment": "initialise the argon2bytesgenerator from the parameters.",
	"Method": "void init(Argon2Parameters parameters){\r\n    this.parameters = parameters;\r\n    if (parameters.getLanes() < Argon2BytesGenerator.MIN_PARALLELISM) {\r\n        throw new IllegalStateException(\"lanes must be greater than \" + Argon2BytesGenerator.MIN_PARALLELISM);\r\n    } else if (parameters.getLanes() > Argon2BytesGenerator.MAX_PARALLELISM) {\r\n        throw new IllegalStateException(\"lanes must be less than \" + Argon2BytesGenerator.MAX_PARALLELISM);\r\n    } else if (parameters.getMemory() < 2 * parameters.getLanes()) {\r\n        throw new IllegalStateException(\"memory is less than: \" + (2 * parameters.getLanes()) + \" expected \" + (2 * parameters.getLanes()));\r\n    } else if (parameters.getIterations() < Argon2BytesGenerator.MIN_ITERATIONS) {\r\n        throw new IllegalStateException(\"iterations is less than: \" + Argon2BytesGenerator.MIN_ITERATIONS);\r\n    }\r\n    doInit(parameters);\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPSecretKeyRing.getSecretKey",
	"Comment": "return the secret key associated with the passed in fingerprint if itis present.",
	"Method": "PGPSecretKey getSecretKey(PGPSecretKey getSecretKey,long keyId,PGPSecretKey getSecretKey,byte[] fingerprint){\r\n    for (int i = 0; i != keys.size(); i++) {\r\n        PGPSecretKey k = (PGPSecretKey) keys.get(i);\r\n        if (Arrays.areEqual(fingerprint, k.getPublicKey().getFingerprint())) {\r\n            return k;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.gmss.GMSSRootCalc.getRetain",
	"Comment": "returns the retain stacks storing all right nodes near to the root",
	"Method": "Vector[] getRetain(){\r\n    return GMSSUtils.clone(retain);\r\n}"
}, {
	"Path": "javax.crypto.EncryptedPrivateKeyInfo.getAlgParameters",
	"Comment": "returns the algorithm parameters used by the encryption algorithm.",
	"Method": "AlgorithmParameters getAlgParameters(){\r\n    return algP;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.X509AttributeCertificateHolder.isValidOn",
	"Comment": "return whether or not this attribute certificate is valid on a particular date.",
	"Method": "boolean isValidOn(Date date){\r\n    AttCertValidityPeriod certValidityPeriod = attrCert.getAcinfo().getAttrCertValidityPeriod();\r\n    return !date.before(CertUtils.recoverDate(certValidityPeriod.getNotBeforeTime())) && !date.after(CertUtils.recoverDate(certValidityPeriod.getNotAfterTime()));\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSAuthenticatedDataStreamGenerator.setBEREncodeRecipients",
	"Comment": "use a ber set to store the recipient information. by default recipients arestored in a der encoding.",
	"Method": "void setBEREncodeRecipients(boolean useBerEncodingForRecipients){\r\n    berEncodeRecipientSet = useBerEncodingForRecipients;\r\n}"
}, {
	"Path": "org.bouncycastle.util.io.pem.PemWriter.getOutputSize",
	"Comment": "return the number of bytes or characters required to contain thepassed in object if it is pem encoded.",
	"Method": "int getOutputSize(PemObject obj){\r\n    int size = (2 * (obj.getType().length() + 10 + nlLength)) + 6 + 4;\r\n    if (!obj.getHeaders().isEmpty()) {\r\n        for (Iterator it = obj.getHeaders().iterator(); it.hasNext(); ) {\r\n            PemHeader hdr = (PemHeader) it.next();\r\n            size += hdr.getName().length() + \": \".length() + hdr.getValue().length() + nlLength;\r\n        }\r\n        size += nlLength;\r\n    }\r\n    int dataLen = ((obj.getContent().length + 2) / 3) * 4;\r\n    size += dataLen + (((dataLen + LINE_LENGTH - 1) / LINE_LENGTH) * nlLength);\r\n    return size;\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.getSubjectKeyIdentifier",
	"Comment": "returns the subjectkeyidentifier criterion. thex509certificate must contain a subjectkeyidentifierextension with the specified value. if null, nosubjectkeyidentifier check will be done.note that the byte array returned is cloned to protect against subsequentmodifications.",
	"Method": "byte[] getSubjectKeyIdentifier(){\r\n    if (subjectKeyID != null) {\r\n        return (byte[]) subjectKeyID.clone();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.modes.OpenPGPCFBBlockCipher.reset",
	"Comment": "reset the chaining vector back to the iv and reset the underlyingcipher.",
	"Method": "void reset(){\r\n    count = 0;\r\n    System.arraycopy(IV, 0, FR, 0, FR.length);\r\n    cipher.reset();\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.X509CertSelector.getSubjectKeyIdentifier",
	"Comment": "returns the subjectkeyidentifier criterion. thex509certificate must contain a subjectkeyidentifierextension with the specified value. if null, nosubjectkeyidentifier check will be done.note that the byte array returned is cloned to protect against subsequentmodifications.",
	"Method": "byte[] getSubjectKeyIdentifier(){\r\n    if (subjectKeyID != null) {\r\n        return (byte[]) subjectKeyID.clone();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.mail.smime.util.SharedFileInputStream.getRoot",
	"Comment": "return the shared stream that represents the top most stream thatthis stream inherits from.",
	"Method": "SharedFileInputStream getRoot(){\r\n    if (_parent != null) {\r\n        return _parent.getRoot();\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "javax.crypto.SecretKeyFactory.getAlgorithm",
	"Comment": "returns the algorithm name of this secretkeyfactory object.this is the same name that was specified in one of the getinstance callsthat created this secretkeyfactory object.",
	"Method": "String getAlgorithm(){\r\n    return algorithm;\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPPublicKeyRingCollection.getKeysWithSignaturesBy",
	"Comment": "return any keys carrying a signature issued by the key represented by keyid.",
	"Method": "Iterator<PGPPublicKey> getKeysWithSignaturesBy(long keyID){\r\n    List keysWithSigs = new ArrayList();\r\n    for (Iterator it = this.iterator(); it.hasNext(); ) {\r\n        PGPPublicKeyRing k = (PGPPublicKeyRing) it.next();\r\n        for (Iterator keyIt = k.getKeysWithSignaturesBy(keyID); keyIt.hasNext(); ) {\r\n            keysWithSigs.add(keyIt.next());\r\n        }\r\n    }\r\n    return keysWithSigs.iterator();\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.generators.Poly1305KeyGenerator.init",
	"Comment": "initialises the key generator.poly1305 keys are always 256 bits, so the key length in the provided parameters is ignored.",
	"Method": "void init(KeyGenerationParameters param){\r\n    super.init(new KeyGenerationParameters(param.getRandom(), 256));\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.io.CipherInputStream.close",
	"Comment": "closes the underlying input stream and finalises the processing of the data by the cipher.",
	"Method": "void close(){\r\n    try {\r\n        in.close();\r\n    } finally {\r\n        if (!finalized) {\r\n            finaliseCipher();\r\n        }\r\n    }\r\n    maxBuf = bufOff = 0;\r\n    markBufOff = 0;\r\n    markPosition = 0;\r\n    if (markBuf != null) {\r\n        Arrays.fill(markBuf, (byte) 0);\r\n        markBuf = null;\r\n    }\r\n    if (buf != null) {\r\n        Arrays.fill(buf, (byte) 0);\r\n        buf = null;\r\n    }\r\n    Arrays.fill(inBuf, (byte) 0);\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.ch1_titlepane.BERootPaneUI.installClientDecorations",
	"Comment": "installs the necessary state onto the jrootpane to render client\tdecorations. this is only invoked if the jrootpane\thas a decoration style other than jrootpane.none.",
	"Method": "void installClientDecorations(JRootPane root){\r\n    installBorder(root);\r\n    JComponent titlePane = createTitlePane(root);\r\n    setTitlePane(root, titlePane);\r\n    installWindowListeners(root, root.getParent());\r\n    installLayout(root);\r\n    if (!BeautyEyeLNFHelper.__isFrameBorderOpaque() && window != null) {\r\n        WindowTranslucencyHelper.setWindowOpaque(window, false);\r\n        root.revalidate();\r\n        root.repaint();\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.engines.BlowfishEngine.decryptBlock",
	"Comment": "decrypt the given input starting at the given offset and placethe result in the provided buffer starting at the given offset.the input will be an exact multiple of our blocksize.",
	"Method": "void decryptBlock(byte[] src,int srcIndex,byte[] dst,int dstIndex){\r\n    int xl = BytesTo32bits(src, srcIndex);\r\n    int xr = BytesTo32bits(src, srcIndex + 4);\r\n    xl ^= P[ROUNDS + 1];\r\n    for (int i = ROUNDS; i > 0; i -= 2) {\r\n        xr ^= F(xl) ^ P[i];\r\n        xl ^= F(xr) ^ P[i - 1];\r\n    }\r\n    xr ^= P[0];\r\n    Bits32ToBytes(xr, dst, dstIndex);\r\n    Bits32ToBytes(xl, dst, dstIndex + 4);\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.IntegerFunctions.nextProbablePrime",
	"Comment": "compute the next probable prime greater than n with thespecified certainty.",
	"Method": "BigInteger nextProbablePrime(BigInteger n,int certainty,BigInteger nextProbablePrime,BigInteger n){\r\n    return nextProbablePrime(n, 20);\r\n}"
}, {
	"Path": "org.bouncycastle.est.jcajce.SSLSocketFactoryCreatorBuilder.withProvider",
	"Comment": "configure this builder to use the provider with the passed in name.",
	"Method": "SSLSocketFactoryCreatorBuilder withProvider(String tlsProviderName,SSLSocketFactoryCreatorBuilder withProvider,Provider tlsProvider){\r\n    this.tlsProvider = tlsProvider;\r\n    return this;\r\n}"
}, {
	"Path": "org.bouncycastle.util.encoders.UrlBase64.encode",
	"Comment": "encode the input data producing a url safe base 64 encoded byte array.",
	"Method": "byte[] encode(byte[] data,int encode,byte[] data,OutputStream out){\r\n    return encoder.encode(data, 0, data.length, out);\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.ch1_titlepane.BERootPaneUI.propertyChange",
	"Comment": "invoked when a property changes. metalrootpaneui is\tprimarily interested in events originating from the\tjrootpane it has been installed on identifying the\tproperty windowdecorationstyle. if the \twindowdecorationstyle has changed to a value other\tthan jrootpane.none, this will add a component\tto the jrootpane to render the window decorations, as well\tas installing a border on the jrootpane.\ton the other hand, if the windowdecorationstyle has\tchanged to jrootpane.none, this will remove the\tcomponent that has been added to the jrootpane\tas well resetting the border to what it was before\tinstallui was invoked.",
	"Method": "void propertyChange(PropertyChangeEvent e){\r\n    super.propertyChange(e);\r\n    String propertyName = e.getPropertyName();\r\n    if (propertyName == null) {\r\n        return;\r\n    }\r\n    if (propertyName.equals(\"windowDecorationStyle\")) {\r\n        JRootPane root = (JRootPane) e.getSource();\r\n        int style = root.getWindowDecorationStyle();\r\n        uninstallClientDecorations(root);\r\n        if (style != JRootPane.NONE) {\r\n            installClientDecorations(root);\r\n        }\r\n    } else if (propertyName.equals(\"ancestor\")) {\r\n        uninstallWindowListeners(root);\r\n        if (((JRootPane) e.getSource()).getWindowDecorationStyle() != JRootPane.NONE) {\r\n            installWindowListeners(root, root.getParent());\r\n        }\r\n    }\r\n    return;\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSSignedGenerator.addAttributeCertificate",
	"Comment": "add the attribute certificates in attrstore to the certificate set to be included with the generated signeddata message.",
	"Method": "void addAttributeCertificate(X509AttributeCertificateHolder attrCert){\r\n    certs.add(new DERTaggedObject(false, 2, attrCert.toASN1Structure()));\r\n}"
}, {
	"Path": "org.bouncycastle.tsp.TimeStampToken.getEncoded",
	"Comment": "return a asn.1 encoded byte stream representing the encoded object.",
	"Method": "byte[] getEncoded(){\r\n    return tsToken.getEncoded();\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.BEROctetStringParser.getOctetStream",
	"Comment": "return an inputstream representing the contents of the octet string.",
	"Method": "InputStream getOctetStream(){\r\n    return new ConstructedOctetStream(_parser);\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.rainbow.util.GF2Field.multElem",
	"Comment": "this function multiplies two elements in gf2^8. if one of the twoelements is 0, 0 is returned.",
	"Method": "short multElem(short x,short y){\r\n    if (x == 0 || y == 0) {\r\n        return 0;\r\n    } else {\r\n        return (exps[(logs[x] + logs[y]) % 255]);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.cms.jcajce.JceKeyAgreeRecipient.setProvider",
	"Comment": "set the provider to use for key recovery and content processing.",
	"Method": "JceKeyAgreeRecipient setProvider(Provider provider,JceKeyAgreeRecipient setProvider,String providerName){\r\n    this.helper = new EnvelopedDataHelper(new NamedJcaJceExtHelper(providerName));\r\n    this.contentHelper = helper;\r\n    return this;\r\n}"
}, {
	"Path": "org.bouncycastle.mail.smime.SMIMEEnvelopedGenerator.generate",
	"Comment": "generate an enveloped object that contains an smime envelopedobject using the given provider from the contents of the passed inmessage",
	"Method": "MimeBodyPart generate(MimeBodyPart content,OutputEncryptor encryptor,MimeBodyPart generate,MimeMessage message,OutputEncryptor encryptor){\r\n    try {\r\n        message.saveChanges();\r\n    } catch (MessagingException e) {\r\n        throw new SMIMEException(\"unable to save message\", e);\r\n    }\r\n    return make(makeContentBodyPart(message), encryptor);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.signers.GenericSigner.verifySignature",
	"Comment": "return true if the internal state represents the signature described inthe passed in array.",
	"Method": "boolean verifySignature(byte[] signature){\r\n    if (forSigning) {\r\n        throw new IllegalStateException(\"GenericSigner not initialised for verification\");\r\n    }\r\n    byte[] hash = new byte[digest.getDigestSize()];\r\n    digest.doFinal(hash, 0);\r\n    try {\r\n        byte[] sig = engine.processBlock(signature, 0, signature.length);\r\n        if (sig.length < hash.length) {\r\n            byte[] tmp = new byte[hash.length];\r\n            System.arraycopy(sig, 0, tmp, tmp.length - sig.length, sig.length);\r\n            sig = tmp;\r\n        }\r\n        return Arrays.constantTimeAreEqual(sig, hash);\r\n    } catch (Exception e) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.CertPath.toString",
	"Comment": "returns a string representation of this certification path. this callsthe tostring method on each of the certificates in the path.",
	"Method": "String toString(){\r\n    StringBuffer s = new StringBuffer();\r\n    List certs = getCertificates();\r\n    ListIterator iter = certs.listIterator();\r\n    s.append('\\n').append(getType()).append(\" Cert Path: length = \").append(certs.size()).append(\"\\n[\\n\");\r\n    while (iter.hasNext()) {\r\n        s.append(\"=========================================================Certificate \").append(iter.nextIndex()).append('\\n');\r\n        s.append(iter.next()).append('\\n');\r\n        s.append(\"========================================================Certificate end\\n\\n\\n\");\r\n    }\r\n    s.append(\"\\n]\");\r\n    return s.toString();\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.ch1_titlepane.BETitlePane.getWindow",
	"Comment": "returns the window the jrootpane is\tcontained in. this will return null if there is no parent ancestor\tof the jrootpane.",
	"Method": "Window getWindow(){\r\n    return window;\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.PBKDF1KeyWithParameters.getIterationCount",
	"Comment": "return the iteration count to use in the key derivation function.",
	"Method": "int getIterationCount(){\r\n    return iterationCount;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.X509CRLSelector.setDateAndTime",
	"Comment": "sets the dateandtime criterion. the specified date must be equal to orlater than the value of the thisupdate component of thex509crl and earlier than the value of the nextupdatecomponent. there is no match if the x509crl does notcontain a nextupdate component. if null, no dateandtimecheck will be done.note that the date supplied here is cloned to protectagainst subsequent modifications.",
	"Method": "void setDateAndTime(Date dateAndTime){\r\n    if (dateAndTime == null) {\r\n        this.dateAndTime = null;\r\n    } else {\r\n        this.dateAndTime = new Date(dateAndTime.getTime());\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.cert.AttributeCertificateHolder.setDigestCalculatorProvider",
	"Comment": "set a digest calculator provider to be used if matches are attempted usingobjectdigestinfo,",
	"Method": "void setDigestCalculatorProvider(DigestCalculatorProvider digCalcProvider){\r\n    digestCalculatorProvider = digCalcProvider;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.test.CipherStreamTest.testTruncatedRead",
	"Comment": "test truncation of ciphertext to make tag calculation impossible, followed by read fromdecrypting cipherinputstream",
	"Method": "void testTruncatedRead(AEADBlockCipher cipher,CipherParameters params){\r\n    cipher.init(true, params);\r\n    byte[] ciphertext = new byte[cipher.getOutputSize(streamSize)];\r\n    cipher.doFinal(ciphertext, cipher.processBytes(new byte[streamSize], 0, streamSize, ciphertext, 0));\r\n    byte[] truncated = new byte[ciphertext.length - streamSize - 1];\r\n    System.arraycopy(ciphertext, 0, truncated, 0, truncated.length);\r\n    cipher.init(false, params);\r\n    InputStream input = createCipherInputStream(truncated, cipher);\r\n    while (true) {\r\n        int read = 0;\r\n        try {\r\n            read = input.read();\r\n        } catch (InvalidCipherTextIOException e) {\r\n            break;\r\n        } catch (Exception e) {\r\n            fail(\"Unexpected exception  on truncated read : \" + cipher.getAlgorithmName());\r\n            break;\r\n        }\r\n        if (read < 0) {\r\n            fail(\"Expected invalid ciphertext after truncate and read : \" + cipher.getAlgorithmName());\r\n            break;\r\n        }\r\n    }\r\n    try {\r\n        input.close();\r\n    } catch (Exception e) {\r\n        fail(\"Unexpected exception after truncate and read : \" + cipher.getAlgorithmName());\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.x509.X509AttributeCertStoreSelector.setAttributeCert",
	"Comment": "set the attribute certificate to be matched. if null isgiven any will do.",
	"Method": "void setAttributeCert(X509AttributeCertificate attributeCert){\r\n    this.attributeCert = attributeCert;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2nPolynomialElement.invertSquare",
	"Comment": "calculates the multiplicative inverse of this and returns theresult in a new gf2npolynomialelement.",
	"Method": "GF2nPolynomialElement invertSquare(){\r\n    GF2nPolynomialElement n;\r\n    GF2nPolynomialElement u;\r\n    int i, j, k, b;\r\n    if (isZero()) {\r\n        throw new ArithmeticException();\r\n    }\r\n    b = mField.getDegree() - 1;\r\n    n = new GF2nPolynomialElement(this);\r\n    n.polynomial.expandN((mDegree << 1) + 32);\r\n    n.polynomial.reduceN();\r\n    k = 1;\r\n    for (i = IntegerFunctions.floorLog(b) - 1; i >= 0; i--) {\r\n        u = new GF2nPolynomialElement(n);\r\n        for (j = 1; j <= k; j++) {\r\n            u.squareThisPreCalc();\r\n        }\r\n        n.multiplyThisBy(u);\r\n        k <<= 1;\r\n        if ((b & bitMask[i]) != 0) {\r\n            n.squareThisPreCalc();\r\n            n.multiplyThisBy(this);\r\n            k += 1;\r\n        }\r\n    }\r\n    n.squareThisPreCalc();\r\n    return n;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.test.QTESLASecureRandomFactory.getFixed",
	"Comment": "return a seeded fixedsecurerandom representing the result of processing aqtesla test seed with the qtesla randomnumbergenerator.",
	"Method": "FixedSecureRandom getFixed(byte[] seed,int strength,FixedSecureRandom getFixed,byte[] seed,byte[] personalization,int strength,int discard,int size){\r\n    QTESLASecureRandomFactory teslaRNG = new QTESLASecureRandomFactory(seed, personalization);\r\n    teslaRNG.init(strength);\r\n    byte[] burn = new byte[discard];\r\n    teslaRNG.nextBytes(burn);\r\n    if (discard != size) {\r\n        burn = new byte[size];\r\n    }\r\n    teslaRNG.nextBytes(burn);\r\n    return new FixedSecureRandom(burn);\r\n}"
}, {
	"Path": "org.bouncycastle.cert.X509v3CertificateBuilder.build",
	"Comment": "generate an x.509 certificate, based on the current issuer and subjectusing the passed in signer.",
	"Method": "X509CertificateHolder build(ContentSigner signer){\r\n    tbsGen.setSignature(signer.getAlgorithmIdentifier());\r\n    if (!extGenerator.isEmpty()) {\r\n        tbsGen.setExtensions(extGenerator.generate());\r\n    }\r\n    return CertUtils.generateFullCert(signer, tbsGen.generateTBSCertificate());\r\n}"
}, {
	"Path": "org.bouncycastle.gpg.keybox.Blob.getInstance",
	"Comment": "return an instance of a blob from the source.will return null if no more blobs exist.",
	"Method": "Blob getInstance(Object source,KeyFingerPrintCalculator keyFingerPrintCalculator,BlobVerifier blobVerifier){\r\n    if (source == null) {\r\n        throw new IllegalArgumentException(\"Cannot take get instance of null\");\r\n    }\r\n    KeyBoxByteBuffer buffer = KeyBoxByteBuffer.wrap(source);\r\n    if (!buffer.hasRemaining()) {\r\n        return null;\r\n    }\r\n    int base = buffer.position();\r\n    long len = buffer.u32();\r\n    BlobType type = BlobType.fromByte(buffer.u8());\r\n    int version = buffer.u8();\r\n    switch(type) {\r\n        case EMPTY_BLOB:\r\n            break;\r\n        case FIRST_BLOB:\r\n            return FirstBlob.parseContent(base, len, type, version, buffer);\r\n        case X509_BLOB:\r\n            return CertificateBlob.parseContent(base, len, type, version, buffer, blobVerifier);\r\n        case OPEN_PGP_BLOB:\r\n            return PublicKeyRingBlob.parseContent(base, len, type, version, buffer, keyFingerPrintCalculator, blobVerifier);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.X509AttributeCertificateHolder.getAttributes",
	"Comment": "return anarray of attributes matching the passed in type oid.",
	"Method": "Attribute[] getAttributes(Attribute[] getAttributes,ASN1ObjectIdentifier type){\r\n    ASN1Sequence seq = attrCert.getAcinfo().getAttributes();\r\n    List list = new ArrayList();\r\n    for (int i = 0; i != seq.size(); i++) {\r\n        Attribute attr = Attribute.getInstance(seq.getObjectAt(i));\r\n        if (attr.getAttrType().equals(type)) {\r\n            list.add(attr);\r\n        }\r\n    }\r\n    if (list.size() == 0) {\r\n        return EMPTY_ARRAY;\r\n    }\r\n    return (Attribute[]) list.toArray(new Attribute[list.size()]);\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.rainbow.RainbowSigner.makeMessageRepresentative",
	"Comment": "this function creates the representative of the message which gets signedor verified.",
	"Method": "short[] makeMessageRepresentative(byte[] message){\r\n    short[] output = new short[this.signableDocumentLength];\r\n    int h = 0;\r\n    int i = 0;\r\n    do {\r\n        if (i >= message.length) {\r\n            break;\r\n        }\r\n        output[i] = (short) message[h];\r\n        output[i] &= (short) 0xff;\r\n        h++;\r\n        i++;\r\n    } while (i < output.length);\r\n    return output;\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.util.JcaJceUtils.getDigestAlgName",
	"Comment": "attempt to find a standard jca name for the digest represented by the past in oid.",
	"Method": "String getDigestAlgName(ASN1ObjectIdentifier digestAlgOID){\r\n    if (PKCSObjectIdentifiers.md5.equals(digestAlgOID)) {\r\n        return \"MD5\";\r\n    } else if (OIWObjectIdentifiers.idSHA1.equals(digestAlgOID)) {\r\n        return \"SHA1\";\r\n    } else if (NISTObjectIdentifiers.id_sha224.equals(digestAlgOID)) {\r\n        return \"SHA224\";\r\n    } else if (NISTObjectIdentifiers.id_sha256.equals(digestAlgOID)) {\r\n        return \"SHA256\";\r\n    } else if (NISTObjectIdentifiers.id_sha384.equals(digestAlgOID)) {\r\n        return \"SHA384\";\r\n    } else if (NISTObjectIdentifiers.id_sha512.equals(digestAlgOID)) {\r\n        return \"SHA512\";\r\n    } else if (TeleTrusTObjectIdentifiers.ripemd128.equals(digestAlgOID)) {\r\n        return \"RIPEMD128\";\r\n    } else if (TeleTrusTObjectIdentifiers.ripemd160.equals(digestAlgOID)) {\r\n        return \"RIPEMD160\";\r\n    } else if (TeleTrusTObjectIdentifiers.ripemd256.equals(digestAlgOID)) {\r\n        return \"RIPEMD256\";\r\n    } else if (CryptoProObjectIdentifiers.gostR3411.equals(digestAlgOID)) {\r\n        return \"GOST3411\";\r\n    } else {\r\n        return digestAlgOID.getId();\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2nPolynomial.gcd",
	"Comment": "computes the greatest common divisor of this and g andreturns the result in a new polynomialgf2n.",
	"Method": "GF2nPolynomial gcd(GF2nPolynomial g){\r\n    GF2nPolynomial a = new GF2nPolynomial(this);\r\n    GF2nPolynomial b = new GF2nPolynomial(g);\r\n    a.shrink();\r\n    b.shrink();\r\n    GF2nPolynomial c;\r\n    GF2nPolynomial result;\r\n    GF2nElement alpha;\r\n    while (!b.isZero()) {\r\n        c = a.remainder(b);\r\n        a = b;\r\n        b = c;\r\n    }\r\n    alpha = a.coeff[a.getDegree()];\r\n    result = a.scalarMultiply((GF2nElement) alpha.invert());\r\n    return result;\r\n}"
}, {
	"Path": "javax.crypto.EncryptedPrivateKeyInfo.getKeySpec",
	"Comment": "extract the enclosed pkcs8encodedkeyspec object from the encrypted data and return it.",
	"Method": "PKCS8EncodedKeySpec getKeySpec(Cipher c){\r\n    try {\r\n        return new PKCS8EncodedKeySpec(c.doFinal(this.getEncryptedData()));\r\n    } catch (Exception e) {\r\n        throw new InvalidKeySpecException(\"can't get keySpec: \" + e.toString());\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.jce.provider.X509StoreLDAPCertPairs.engineInit",
	"Comment": "initializes this ldap cross certificate pair store implementation.",
	"Method": "void engineInit(X509StoreParameters parameters){\r\n    if (!(parameters instanceof X509LDAPCertStoreParameters)) {\r\n        throw new IllegalArgumentException(\"Initialization parameters must be an instance of \" + X509LDAPCertStoreParameters.class.getName() + \".\");\r\n    }\r\n    helper = new LDAPStoreHelper((X509LDAPCertStoreParameters) parameters);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.examples.DESExample.performEncrypt",
	"Comment": "this method performs all the encryption and writesthe cipher text to the buffered output stream createdpreviously.",
	"Method": "void performEncrypt(byte[] key){\r\n    cipher.init(true, new KeyParameter(key));\r\n    int inBlockSize = 47;\r\n    int outBlockSize = cipher.getOutputSize(inBlockSize);\r\n    byte[] inblock = new byte[inBlockSize];\r\n    byte[] outblock = new byte[outBlockSize];\r\n    try {\r\n        int inL;\r\n        int outL;\r\n        byte[] rv = null;\r\n        while ((inL = in.read(inblock, 0, inBlockSize)) > 0) {\r\n            outL = cipher.processBytes(inblock, 0, inL, outblock, 0);\r\n            if (outL > 0) {\r\n                rv = Hex.encode(outblock, 0, outL);\r\n                out.write(rv, 0, rv.length);\r\n                out.write('\\n');\r\n            }\r\n        }\r\n        try {\r\n            outL = cipher.doFinal(outblock, 0);\r\n            if (outL > 0) {\r\n                rv = Hex.encode(outblock, 0, outL);\r\n                out.write(rv, 0, rv.length);\r\n                out.write('\\n');\r\n            }\r\n        } catch (CryptoException ce) {\r\n        }\r\n    } catch (IOException ioeread) {\r\n        ioeread.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.jce.ECKeyUtil.privateToExplicitParameters",
	"Comment": "convert a passed in private ec key to have explicit parameters. if the keyis already using explicit parameters it is returned.",
	"Method": "PrivateKey privateToExplicitParameters(PrivateKey key,String providerName,PrivateKey privateToExplicitParameters,PrivateKey key,Provider provider){\r\n    try {\r\n        PrivateKeyInfo info = PrivateKeyInfo.getInstance(ASN1Primitive.fromByteArray(key.getEncoded()));\r\n        if (info.getAlgorithmId().getAlgorithm().equals(CryptoProObjectIdentifiers.gostR3410_2001)) {\r\n            throw new UnsupportedEncodingException(\"cannot convert GOST key to explicit parameters.\");\r\n        } else {\r\n            X962Parameters params = X962Parameters.getInstance(info.getAlgorithmId().getParameters());\r\n            X9ECParameters curveParams;\r\n            if (params.isNamedCurve()) {\r\n                ASN1ObjectIdentifier oid = ASN1ObjectIdentifier.getInstance(params.getParameters());\r\n                curveParams = ECUtil.getNamedCurveByOid(oid);\r\n                curveParams = new X9ECParameters(curveParams.getCurve(), curveParams.getG(), curveParams.getN(), curveParams.getH());\r\n            } else if (params.isImplicitlyCA()) {\r\n                curveParams = new X9ECParameters(BouncyCastleProvider.CONFIGURATION.getEcImplicitlyCa().getCurve(), BouncyCastleProvider.CONFIGURATION.getEcImplicitlyCa().getG(), BouncyCastleProvider.CONFIGURATION.getEcImplicitlyCa().getN(), BouncyCastleProvider.CONFIGURATION.getEcImplicitlyCa().getH());\r\n            } else {\r\n                return key;\r\n            }\r\n            params = new X962Parameters(curveParams);\r\n            info = new PrivateKeyInfo(new AlgorithmIdentifier(X9ObjectIdentifiers.id_ecPublicKey, params), info.parsePrivateKey());\r\n            KeyFactory keyFact = KeyFactory.getInstance(key.getAlgorithm(), provider.getName());\r\n            return keyFact.generatePrivate(new PKCS8EncodedKeySpec(info.getEncoded()));\r\n        }\r\n    } catch (IllegalArgumentException e) {\r\n        throw e;\r\n    } catch (NoSuchAlgorithmException e) {\r\n        throw e;\r\n    } catch (Exception e) {\r\n        throw new UnexpectedException(e);\r\n    }\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.ch1_titlepane.BERootPaneUI.installLayout",
	"Comment": "installs the appropriate layoutmanager on the jrootpane\tto render the window decorations.",
	"Method": "void installLayout(JRootPane root){\r\n    if (layoutManager == null) {\r\n        layoutManager = createLayoutManager();\r\n    }\r\n    savedOldLayout = root.getLayout();\r\n    root.setLayout(layoutManager);\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.x500.X500Name.getAttributeTypes",
	"Comment": "return an array of oids contained in the attribute type of each rdn in structure order.",
	"Method": "ASN1ObjectIdentifier[] getAttributeTypes(){\r\n    int count = 0;\r\n    for (int i = 0; i != rdns.length; i++) {\r\n        RDN rdn = rdns[i];\r\n        count += rdn.size();\r\n    }\r\n    ASN1ObjectIdentifier[] res = new ASN1ObjectIdentifier[count];\r\n    count = 0;\r\n    for (int i = 0; i != rdns.length; i++) {\r\n        RDN rdn = rdns[i];\r\n        if (rdn.isMultiValued()) {\r\n            AttributeTypeAndValue[] attr = rdn.getTypesAndValues();\r\n            for (int j = 0; j != attr.length; j++) {\r\n                res[count++] = attr[j].getType();\r\n            }\r\n        } else if (rdn.size() != 0) {\r\n            res[count++] = rdn.getFirst().getType();\r\n        }\r\n    }\r\n    return res;\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPPublicKeyRingCollection.contains",
	"Comment": "return true if a key matching the passed in fingerprint is present, false otherwise.",
	"Method": "boolean contains(long keyID,boolean contains,byte[] fingerprint){\r\n    return getPublicKey(fingerprint) != null;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.generators.PKCS5S1ParametersGenerator.generateDerivedMacParameters",
	"Comment": "generate a key parameter for use with a mac derived from the password,salt, and iteration count we are currently initialised with.",
	"Method": "CipherParameters generateDerivedMacParameters(int keySize){\r\n    return generateDerivedParameters(keySize);\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSSignedDataStreamGenerator.open",
	"Comment": "generate a signed object that for a cms signed dataobject using the given provider.",
	"Method": "OutputStream open(OutputStream out,OutputStream open,OutputStream out,boolean encapsulate,OutputStream open,OutputStream out,boolean encapsulate,OutputStream dataOutputStream,OutputStream open,ASN1ObjectIdentifier eContentType,OutputStream out,boolean encapsulate,OutputStream open,ASN1ObjectIdentifier eContentType,OutputStream out,boolean encapsulate,OutputStream dataOutputStream){\r\n    BERSequenceGenerator sGen = new BERSequenceGenerator(out);\r\n    sGen.addObject(CMSObjectIdentifiers.signedData);\r\n    BERSequenceGenerator sigGen = new BERSequenceGenerator(sGen.getRawOutputStream(), 0, true);\r\n    sigGen.addObject(calculateVersion(eContentType));\r\n    ASN1EncodableVector digestAlgs = new ASN1EncodableVector();\r\n    for (Iterator it = _signers.iterator(); it.hasNext(); ) {\r\n        SignerInformation signer = (SignerInformation) it.next();\r\n        AlgorithmIdentifier digAlg = CMSSignedHelper.INSTANCE.fixAlgID(signer.getDigestAlgorithmID());\r\n        digestAlgs.add(digAlg);\r\n    }\r\n    for (Iterator it = signerGens.iterator(); it.hasNext(); ) {\r\n        SignerInfoGenerator signerGen = (SignerInfoGenerator) it.next();\r\n        digestAlgs.add(signerGen.getDigestAlgorithm());\r\n    }\r\n    sigGen.getRawOutputStream().write(new DERSet(digestAlgs).getEncoded());\r\n    BERSequenceGenerator eiGen = new BERSequenceGenerator(sigGen.getRawOutputStream());\r\n    eiGen.addObject(eContentType);\r\n    OutputStream encapStream = encapsulate ? CMSUtils.createBEROctetOutputStream(eiGen.getRawOutputStream(), 0, true, _bufferSize) : null;\r\n    OutputStream contentStream = CMSUtils.getSafeTeeOutputStream(dataOutputStream, encapStream);\r\n    OutputStream sigStream = CMSUtils.attachSignersToOutputStream(signerGens, contentStream);\r\n    return new CmsSignedDataOutputStream(sigStream, eContentType, sGen, sigGen, eiGen);\r\n}"
}, {
	"Path": "org.bouncycastle.mail.smime.validator.SignedMailValidator.createCertPath",
	"Comment": "returns an object array containing a certpath and a list of booleans. the list contains the value trueif the corresponding certificate in the certpath was taken from the user provided certstores.",
	"Method": "CertPath createCertPath(X509Certificate signerCert,Set trustanchors,List certStores,Object[] createCertPath,X509Certificate signerCert,Set trustanchors,List systemCertStores,List userCertStores){\r\n    Set certSet = new LinkedHashSet();\r\n    List userProvidedList = new ArrayList();\r\n    X509Certificate cert = signerCert;\r\n    certSet.add(cert);\r\n    userProvidedList.add(new Boolean(true));\r\n    boolean trustAnchorFound = false;\r\n    X509Certificate taCert = null;\r\n    while (cert != null && !trustAnchorFound) {\r\n        Iterator trustIt = trustanchors.iterator();\r\n        while (trustIt.hasNext()) {\r\n            TrustAnchor anchor = (TrustAnchor) trustIt.next();\r\n            X509Certificate anchorCert = anchor.getTrustedCert();\r\n            if (anchorCert != null) {\r\n                if (anchorCert.getSubjectX500Principal().equals(cert.getIssuerX500Principal())) {\r\n                    try {\r\n                        cert.verify(anchorCert.getPublicKey(), \"BC\");\r\n                        trustAnchorFound = true;\r\n                        taCert = anchorCert;\r\n                        break;\r\n                    } catch (Exception e) {\r\n                    }\r\n                }\r\n            } else {\r\n                if (anchor.getCAName().equals(cert.getIssuerX500Principal().getName())) {\r\n                    try {\r\n                        cert.verify(anchor.getCAPublicKey(), \"BC\");\r\n                        trustAnchorFound = true;\r\n                        break;\r\n                    } catch (Exception e) {\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (!trustAnchorFound) {\r\n            X509CertSelector select = new X509CertSelector();\r\n            try {\r\n                select.setSubject(cert.getIssuerX500Principal().getEncoded());\r\n            } catch (IOException e) {\r\n                throw new IllegalStateException(e.toString());\r\n            }\r\n            byte[] authKeyIdentBytes = cert.getExtensionValue(Extension.authorityKeyIdentifier.getId());\r\n            if (authKeyIdentBytes != null) {\r\n                try {\r\n                    AuthorityKeyIdentifier kid = AuthorityKeyIdentifier.getInstance(getObject(authKeyIdentBytes));\r\n                    if (kid.getKeyIdentifier() != null) {\r\n                        select.setSubjectKeyIdentifier(new DEROctetString(kid.getKeyIdentifier()).getEncoded(ASN1Encoding.DER));\r\n                    }\r\n                } catch (IOException ioe) {\r\n                }\r\n            }\r\n            boolean userProvided = false;\r\n            cert = findNextCert(systemCertStores, select, certSet);\r\n            if (cert == null && userCertStores != null) {\r\n                userProvided = true;\r\n                cert = findNextCert(userCertStores, select, certSet);\r\n            }\r\n            if (cert != null) {\r\n                certSet.add(cert);\r\n                userProvidedList.add(new Boolean(userProvided));\r\n            }\r\n        }\r\n    }\r\n    if (trustAnchorFound) {\r\n        if (taCert != null && taCert.getSubjectX500Principal().equals(taCert.getIssuerX500Principal())) {\r\n            certSet.add(taCert);\r\n            userProvidedList.add(new Boolean(false));\r\n        } else {\r\n            X509CertSelector select = new X509CertSelector();\r\n            try {\r\n                select.setSubject(cert.getIssuerX500Principal().getEncoded());\r\n                select.setIssuer(cert.getIssuerX500Principal().getEncoded());\r\n            } catch (IOException e) {\r\n                throw new IllegalStateException(e.toString());\r\n            }\r\n            boolean userProvided = false;\r\n            taCert = findNextCert(systemCertStores, select, certSet);\r\n            if (taCert == null && userCertStores != null) {\r\n                userProvided = true;\r\n                taCert = findNextCert(userCertStores, select, certSet);\r\n            }\r\n            if (taCert != null) {\r\n                try {\r\n                    cert.verify(taCert.getPublicKey(), \"BC\");\r\n                    certSet.add(taCert);\r\n                    userProvidedList.add(new Boolean(userProvided));\r\n                } catch (GeneralSecurityException gse) {\r\n                }\r\n            }\r\n        }\r\n    }\r\n    CertPath certPath = CertificateFactory.getInstance(\"X.509\", \"BC\").generateCertPath(new ArrayList(certSet));\r\n    return new Object[] { certPath, userProvidedList };\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.x500.RDN.size",
	"Comment": "return the number of attributetypeandvalue objects in this rdn,",
	"Method": "int size(){\r\n    return this.values.size();\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.signers.ISO9796d2Signer.getRecoveredMessage",
	"Comment": "return a reference to the recoveredmessage message, either as it was addedto a just generated signature, or extracted from a verified one.",
	"Method": "byte[] getRecoveredMessage(){\r\n    return recoveredMessage;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.X509CRLSelector.getCertificateChecking",
	"Comment": "returns the certificate being checked. this is not a criterion. rather,it is optional information that may help a certstore findcrls that would be relevant when checking revocation for the specifiedcertificate. if the value returned is null, then no suchoptional information is provided.",
	"Method": "X509Certificate getCertificateChecking(){\r\n    return certChecking;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.x509.Extensions.getExtension",
	"Comment": "return the extension represented by the object identifierpassed in.",
	"Method": "Extension getExtension(ASN1ObjectIdentifier oid){\r\n    return (Extension) extensions.get(oid);\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.PKIXCertPathBuilderResult.toString",
	"Comment": "return a printable representation of thispkixcertpathbuilderresult.",
	"Method": "String toString(){\r\n    StringBuffer s = new StringBuffer();\r\n    s.append(\"PKIXCertPathBuilderResult: [\\n\");\r\n    s.append(\"  Certification Path: \").append(getCertPath()).append('\\n');\r\n    s.append(\"  Trust Anchor: \").append(getTrustAnchor()).append('\\n');\r\n    s.append(\"  Policy Tree: \").append(getPolicyTree()).append('\\n');\r\n    s.append(\"  Subject Public Key: \").append(getPublicKey()).append(\"\\n]\");\r\n    return s.toString();\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.provider.asymmetric.dh.BCDHPrivateKey.getEncoded",
	"Comment": "return a pkcs8 representation of the key. the sequence returnedrepresents a full privatekeyinfo object.",
	"Method": "byte[] getEncoded(){\r\n    try {\r\n        if (info != null) {\r\n            return info.getEncoded(ASN1Encoding.DER);\r\n        }\r\n        PrivateKeyInfo info;\r\n        if (dhSpec instanceof DHDomainParameterSpec && ((DHDomainParameterSpec) dhSpec).getQ() != null) {\r\n            DHParameters params = ((DHDomainParameterSpec) dhSpec).getDomainParameters();\r\n            DHValidationParameters validationParameters = params.getValidationParameters();\r\n            ValidationParams vParams = null;\r\n            if (validationParameters != null) {\r\n                vParams = new ValidationParams(validationParameters.getSeed(), validationParameters.getCounter());\r\n            }\r\n            info = new PrivateKeyInfo(new AlgorithmIdentifier(X9ObjectIdentifiers.dhpublicnumber, new DomainParameters(params.getP(), params.getG(), params.getQ(), params.getJ(), vParams).toASN1Primitive()), new ASN1Integer(getX()));\r\n        } else {\r\n            info = new PrivateKeyInfo(new AlgorithmIdentifier(PKCSObjectIdentifiers.dhKeyAgreement, new DHParameter(dhSpec.getP(), dhSpec.getG(), dhSpec.getL()).toASN1Primitive()), new ASN1Integer(getX()));\r\n        }\r\n        return info.getEncoded(ASN1Encoding.DER);\r\n    } catch (Exception e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.provider.asymmetric.ecgost12.BCECGOST3410_2012PrivateKey.getEncoded",
	"Comment": "return a pkcs8 representation of the key. the sequence returnedrepresents a full privatekeyinfo object.",
	"Method": "byte[] getEncoded(){\r\n    boolean is512 = d.bitLength() > 256;\r\n    ASN1ObjectIdentifier identifier = (is512) ? RosstandartObjectIdentifiers.id_tc26_gost_3410_12_512 : RosstandartObjectIdentifiers.id_tc26_gost_3410_12_256;\r\n    int size = (is512) ? 64 : 32;\r\n    if (gostParams != null) {\r\n        byte[] encKey = new byte[size];\r\n        extractBytes(encKey, size, 0, this.getS());\r\n        try {\r\n            PrivateKeyInfo info = new PrivateKeyInfo(new AlgorithmIdentifier(identifier, gostParams), new DEROctetString(encKey));\r\n            return info.getEncoded(ASN1Encoding.DER);\r\n        } catch (IOException e) {\r\n            return null;\r\n        }\r\n    } else {\r\n        X962Parameters params;\r\n        int orderBitLength;\r\n        if (ecSpec instanceof ECNamedCurveSpec) {\r\n            ASN1ObjectIdentifier curveOid = ECUtil.getNamedCurveOid(((ECNamedCurveSpec) ecSpec).getName());\r\n            if (curveOid == null) {\r\n                curveOid = new ASN1ObjectIdentifier(((ECNamedCurveSpec) ecSpec).getName());\r\n            }\r\n            params = new X962Parameters(curveOid);\r\n            orderBitLength = ECUtil.getOrderBitLength(BouncyCastleProvider.CONFIGURATION, ecSpec.getOrder(), this.getS());\r\n        } else if (ecSpec == null) {\r\n            params = new X962Parameters(DERNull.INSTANCE);\r\n            orderBitLength = ECUtil.getOrderBitLength(BouncyCastleProvider.CONFIGURATION, null, this.getS());\r\n        } else {\r\n            ECCurve curve = EC5Util.convertCurve(ecSpec.getCurve());\r\n            X9ECParameters ecP = new X9ECParameters(curve, EC5Util.convertPoint(curve, ecSpec.getGenerator(), withCompression), ecSpec.getOrder(), BigInteger.valueOf(ecSpec.getCofactor()), ecSpec.getCurve().getSeed());\r\n            params = new X962Parameters(ecP);\r\n            orderBitLength = ECUtil.getOrderBitLength(BouncyCastleProvider.CONFIGURATION, ecSpec.getOrder(), this.getS());\r\n        }\r\n        PrivateKeyInfo info;\r\n        org.bouncycastle.asn1.sec.ECPrivateKey keyStructure;\r\n        if (publicKey != null) {\r\n            keyStructure = new org.bouncycastle.asn1.sec.ECPrivateKey(orderBitLength, this.getS(), publicKey, params);\r\n        } else {\r\n            keyStructure = new org.bouncycastle.asn1.sec.ECPrivateKey(orderBitLength, this.getS(), params);\r\n        }\r\n        try {\r\n            info = new PrivateKeyInfo(new AlgorithmIdentifier(identifier, params.toASN1Primitive()), keyStructure.toASN1Primitive());\r\n            return info.getEncoded(ASN1Encoding.DER);\r\n        } catch (IOException e) {\r\n            return null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.gpg.keybox.jcajce.JcaBlobVerifierBuilder.setProvider",
	"Comment": "sets the provider to use to obtain cryptographic primitives.",
	"Method": "JcaBlobVerifierBuilder setProvider(Provider provider,JcaBlobVerifierBuilder setProvider,String providerName){\r\n    this.helper = new NamedJcaJceHelper(providerName);\r\n    return this;\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPUtil.getDigestName",
	"Comment": "return an appropriate name for the hash algorithm represented by the passedin hash algorithm id number.",
	"Method": "String getDigestName(int hashAlgorithm){\r\n    switch(hashAlgorithm) {\r\n        case HashAlgorithmTags.SHA1:\r\n            return \"SHA1\";\r\n        case HashAlgorithmTags.MD2:\r\n            return \"MD2\";\r\n        case HashAlgorithmTags.MD5:\r\n            return \"MD5\";\r\n        case HashAlgorithmTags.RIPEMD160:\r\n            return \"RIPEMD160\";\r\n        case HashAlgorithmTags.SHA256:\r\n            return \"SHA256\";\r\n        case HashAlgorithmTags.SHA384:\r\n            return \"SHA384\";\r\n        case HashAlgorithmTags.SHA512:\r\n            return \"SHA512\";\r\n        case HashAlgorithmTags.SHA224:\r\n            return \"SHA224\";\r\n        case HashAlgorithmTags.TIGER_192:\r\n            return \"TIGER\";\r\n        default:\r\n            throw new PGPException(\"unknown hash algorithm tag in getDigestName: \" + hashAlgorithm);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.BufferedBlockCipher.processByte",
	"Comment": "process a single byte, producing an output block if necessary.",
	"Method": "int processByte(byte in,byte[] out,int outOff){\r\n    int resultLen = 0;\r\n    buf[bufOff++] = in;\r\n    if (bufOff == buf.length) {\r\n        resultLen = cipher.processBlock(buf, 0, out, outOff);\r\n        bufOff = 0;\r\n    }\r\n    return resultLen;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.engines.RSABlindedEngine.getOutputBlockSize",
	"Comment": "return the maximum size for an output block to this engine.for rsa this is always one byte less than the key size ondecryption, and the same length as the key size on encryption.",
	"Method": "int getOutputBlockSize(){\r\n    return core.getOutputBlockSize();\r\n}"
}, {
	"Path": "org.bouncycastle.x509.X509AttributeCertStoreSelector.match",
	"Comment": "decides if the given attribute certificate should be selected.",
	"Method": "boolean match(Object obj){\r\n    if (!(obj instanceof X509AttributeCertificate)) {\r\n        return false;\r\n    }\r\n    X509AttributeCertificate attrCert = (X509AttributeCertificate) obj;\r\n    if (this.attributeCert != null) {\r\n        if (!this.attributeCert.equals(attrCert)) {\r\n            return false;\r\n        }\r\n    }\r\n    if (serialNumber != null) {\r\n        if (!attrCert.getSerialNumber().equals(serialNumber)) {\r\n            return false;\r\n        }\r\n    }\r\n    if (holder != null) {\r\n        if (!attrCert.getHolder().equals(holder)) {\r\n            return false;\r\n        }\r\n    }\r\n    if (issuer != null) {\r\n        if (!attrCert.getIssuer().equals(issuer)) {\r\n            return false;\r\n        }\r\n    }\r\n    if (attributeCertificateValid != null) {\r\n        try {\r\n            attrCert.checkValidity(attributeCertificateValid);\r\n        } catch (CertificateExpiredException e) {\r\n            return false;\r\n        } catch (CertificateNotYetValidException e) {\r\n            return false;\r\n        }\r\n    }\r\n    if (!targetNames.isEmpty() || !targetGroups.isEmpty()) {\r\n        byte[] targetInfoExt = attrCert.getExtensionValue(X509Extensions.TargetInformation.getId());\r\n        if (targetInfoExt != null) {\r\n            TargetInformation targetinfo;\r\n            try {\r\n                targetinfo = TargetInformation.getInstance(new ASN1InputStream(((DEROctetString) DEROctetString.fromByteArray(targetInfoExt)).getOctets()).readObject());\r\n            } catch (IOException e) {\r\n                return false;\r\n            } catch (IllegalArgumentException e) {\r\n                return false;\r\n            }\r\n            Targets[] targetss = targetinfo.getTargetsObjects();\r\n            if (!targetNames.isEmpty()) {\r\n                boolean found = false;\r\n                for (int i = 0; i < targetss.length; i++) {\r\n                    Targets t = targetss[i];\r\n                    Target[] targets = t.getTargets();\r\n                    for (int j = 0; j < targets.length; j++) {\r\n                        if (targetNames.contains(targets[j].getTargetName())) {\r\n                            found = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                if (!found) {\r\n                    return false;\r\n                }\r\n            }\r\n            if (!targetGroups.isEmpty()) {\r\n                boolean found = false;\r\n                for (int i = 0; i < targetss.length; i++) {\r\n                    Targets t = targetss[i];\r\n                    Target[] targets = t.getTargets();\r\n                    for (int j = 0; j < targets.length; j++) {\r\n                        if (targetGroups.contains(targets[j].getTargetGroup())) {\r\n                            found = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                if (!found) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.X509ExtensionUtils.createAuthorityKeyIdentifier",
	"Comment": "create an authoritykeyidentifier from the passed in arguments.",
	"Method": "AuthorityKeyIdentifier createAuthorityKeyIdentifier(X509CertificateHolder certHolder,AuthorityKeyIdentifier createAuthorityKeyIdentifier,SubjectPublicKeyInfo publicKeyInfo,AuthorityKeyIdentifier createAuthorityKeyIdentifier,SubjectPublicKeyInfo publicKeyInfo,GeneralNames generalNames,BigInteger serial){\r\n    return new AuthorityKeyIdentifier(calculateIdentifier(publicKeyInfo), generalNames, serial);\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.gmss.GMSSRootCalc.wasInitialized",
	"Comment": "method to check whether the instance has been initialized or not",
	"Method": "boolean wasInitialized(){\r\n    return isInitialized;\r\n}"
}, {
	"Path": "java.security.cert.PKIXCertPathValidatorResult.toString",
	"Comment": "return a printable representation of this pkixcertpathvalidatorresult.",
	"Method": "String toString(){\r\n    StringBuffer s = new StringBuffer();\r\n    s.append(\"PKIXCertPathValidatorResult: [ \\n\");\r\n    s.append(\"  Trust Anchor: \").append(getTrustAnchor()).append('\\n');\r\n    s.append(\"  Policy Tree: \").append(getPolicyTree()).append('\\n');\r\n    s.append(\"  Subject Public Key: \").append(getPublicKey()).append(\"\\n]\");\r\n    return s.toString();\r\n}"
}, {
	"Path": "org.bouncycastle.jce.PrincipalUtil.getIssuerX509Principal",
	"Comment": "return the issuer of the given crl as an x509principalobject.",
	"Method": "X509Principal getIssuerX509Principal(X509Certificate cert,X509Principal getIssuerX509Principal,X509CRL crl){\r\n    try {\r\n        TBSCertList tbsCertList = TBSCertList.getInstance(ASN1Primitive.fromByteArray(crl.getTBSCertList()));\r\n        return new X509Principal(X509Name.getInstance(tbsCertList.getIssuer()));\r\n    } catch (IOException e) {\r\n        throw new CRLException(e.toString());\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.PBKDF2Key.getAlgorithm",
	"Comment": "return the password based key derivation function this key is for,",
	"Method": "String getAlgorithm(){\r\n    return \"PBKDF2\";\r\n}"
}, {
	"Path": "org.bouncycastle.pkcs.PKCS12PfxPduBuilder.addEncryptedData",
	"Comment": "add a set of safebags that are to be wrapped in a encrypteddata object.",
	"Method": "PKCS12PfxPduBuilder addEncryptedData(OutputEncryptor dataEncryptor,PKCS12SafeBag data,PKCS12PfxPduBuilder addEncryptedData,OutputEncryptor dataEncryptor,PKCS12SafeBag[] data,PKCS12PfxPduBuilder addEncryptedData,OutputEncryptor dataEncryptor,ASN1Sequence data){\r\n    CMSEncryptedDataGenerator envGen = new CMSEncryptedDataGenerator();\r\n    try {\r\n        dataVector.add(envGen.generate(new CMSProcessableByteArray(data.getEncoded()), dataEncryptor).toASN1Structure());\r\n    } catch (CMSException e) {\r\n        throw new PKCSIOException(e.getMessage(), e.getCause());\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.provider.X509StoreLDAPAttrCerts.engineGetMatches",
	"Comment": "returns a collection of matching attribute certificates from the ldaplocation.the selector must be a of typex509attributecertstoreselector. if it is not an emptycollection is returned.the subject and the serial number should be reasonable criterias for aselector.",
	"Method": "Collection engineGetMatches(Selector selector){\r\n    if (!(selector instanceof X509AttributeCertStoreSelector)) {\r\n        return Collections.EMPTY_SET;\r\n    }\r\n    X509AttributeCertStoreSelector xselector = (X509AttributeCertStoreSelector) selector;\r\n    Set set = new HashSet();\r\n    set.addAll(helper.getAACertificates(xselector));\r\n    set.addAll(helper.getAttributeCertificateAttributes(xselector));\r\n    set.addAll(helper.getAttributeDescriptorCertificates(xselector));\r\n    return set;\r\n}"
}, {
	"Path": "org.jdesktop.swingx.JXPanel.setAlpha",
	"Comment": "set the alpha transparency level for this component. this automaticallycauses a repaint of the component.",
	"Method": "void setAlpha(float alpha){\r\n    if (alpha < 0 || alpha > 1) {\r\n        throw new IllegalArgumentException(\"Alpha must be between 0 and 1 inclusive\");\r\n    }\r\n    if (this.alpha != alpha) {\r\n        float oldAlpha = this.alpha;\r\n        this.alpha = alpha;\r\n        if (alpha > 0f && alpha < 1f) {\r\n            if (oldAlpha == 1) {\r\n                oldOpaque = isOpaque();\r\n                setOpaque(false);\r\n            }\r\n            RepaintManager manager = RepaintManager.currentManager(this);\r\n            if (!manager.getClass().isAnnotationPresent(TranslucentRepaintManager.class)) {\r\n                RepaintManager.setCurrentManager(new RepaintManagerX());\r\n            }\r\n        } else if (alpha == 1) {\r\n            if (oldOpaque) {\r\n                setOpaque(true);\r\n            }\r\n        }\r\n        firePropertyChange(\"alpha\", oldAlpha, alpha);\r\n        repaint();\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.tsp.TimeStampTokenGenerator.addOtherRevocationInfo",
	"Comment": "add a store of otherrevocationdata to the crl set to be included with the generated timestamptoken.",
	"Method": "void addOtherRevocationInfo(ASN1ObjectIdentifier otherRevocationInfoFormat,Store otherRevocationInfos){\r\n    otherRevoc.put(otherRevocationInfoFormat, otherRevocationInfos.getMatches(null));\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.params.DESParameters.setOddParity",
	"Comment": "des keys use the lsb as the odd parity bit.this canbe used to check for corrupt keys.",
	"Method": "void setOddParity(byte[] bytes){\r\n    for (int i = 0; i < bytes.length; i++) {\r\n        int b = bytes[i];\r\n        bytes[i] = (byte) ((b & 0xfe) | ((((b >> 1) ^ (b >> 2) ^ (b >> 3) ^ (b >> 4) ^ (b >> 5) ^ (b >> 6) ^ (b >> 7)) ^ 0x01) & 0x01));\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.engines.RC532Engine.encryptBlock",
	"Comment": "encrypt the given block starting at the given offset and placethe result in the provided buffer starting at the given offset.",
	"Method": "int encryptBlock(byte[] in,int inOff,byte[] out,int outOff){\r\n    int A = bytesToWord(in, inOff) + _S[0];\r\n    int B = bytesToWord(in, inOff + 4) + _S[1];\r\n    for (int i = 1; i <= _noRounds; i++) {\r\n        A = rotateLeft(A ^ B, B) + _S[2 * i];\r\n        B = rotateLeft(B ^ A, A) + _S[2 * i + 1];\r\n    }\r\n    wordToBytes(A, out, outOff);\r\n    wordToBytes(B, out, outOff + 4);\r\n    return 2 * 4;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.params.HKDFParameters.getSalt",
	"Comment": "returns the salt, or null if the salt should be generated as a byte arrayof hashlen zeros.",
	"Method": "byte[] getSalt(){\r\n    return Arrays.clone(salt);\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSSignedData.getCertificates",
	"Comment": "return any x.509 certificate objects in this signeddata structure as a store of x509certificateholder objects.",
	"Method": "Store<X509CertificateHolder> getCertificates(){\r\n    return HELPER.getCertificates(signedData.getCertificates());\r\n}"
}, {
	"Path": "org.bouncycastle.mail.smime.SMIMESignedGenerator.getGeneratedDigests",
	"Comment": "return a map of oids and byte arrays representing the digests calculated on the content duringthe last generate.",
	"Method": "Map getGeneratedDigests(){\r\n    return new HashMap(_digests);\r\n}"
}, {
	"Path": "org.bouncycastle.cert.cmp.ProtectedPKIMessage.verify",
	"Comment": "verify a message with a public key based signature attached.",
	"Method": "boolean verify(ContentVerifierProvider verifierProvider,boolean verify,PKMACBuilder pkMacBuilder,char[] password){\r\n    if (!CMPObjectIdentifiers.passwordBasedMac.equals(pkiMessage.getHeader().getProtectionAlg().getAlgorithm())) {\r\n        throw new CMPException(\"protection algorithm not mac based\");\r\n    }\r\n    try {\r\n        pkMacBuilder.setParameters(PBMParameter.getInstance(pkiMessage.getHeader().getProtectionAlg().getParameters()));\r\n        MacCalculator calculator = pkMacBuilder.build(password);\r\n        OutputStream macOut = calculator.getOutputStream();\r\n        ASN1EncodableVector v = new ASN1EncodableVector();\r\n        v.add(pkiMessage.getHeader());\r\n        v.add(pkiMessage.getBody());\r\n        macOut.write(new DERSequence(v).getEncoded(ASN1Encoding.DER));\r\n        macOut.close();\r\n        return Arrays.areEqual(calculator.getMac(), pkiMessage.getProtection().getBytes());\r\n    } catch (Exception e) {\r\n        throw new CMPException(\"unable to verify MAC: \" + e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.cms.jcajce.JceKeyAgreeRecipientInfoGenerator.addRecipient",
	"Comment": "add a recipient identified by the passed in subjectkeyid and the for the passed in public key.",
	"Method": "JceKeyAgreeRecipientInfoGenerator addRecipient(X509Certificate recipientCert,JceKeyAgreeRecipientInfoGenerator addRecipient,byte[] subjectKeyID,PublicKey publicKey){\r\n    recipientIDs.add(new KeyAgreeRecipientIdentifier(new RecipientKeyIdentifier(subjectKeyID)));\r\n    recipientKeys.add(publicKey);\r\n    return this;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.modes.PaddedBlockCipher.processByte",
	"Comment": "process a single byte, producing an output block if neccessary.",
	"Method": "int processByte(byte in,byte[] out,int outOff){\r\n    int resultLen = 0;\r\n    if (bufOff == buf.length) {\r\n        resultLen = cipher.processBlock(buf, 0, out, outOff);\r\n        bufOff = 0;\r\n    }\r\n    buf[bufOff++] = in;\r\n    return resultLen;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.modes.CCMBlockCipher.getMac",
	"Comment": "returns a byte array containing the mac calculated as part of thelast encrypt or decrypt operation.",
	"Method": "byte[] getMac(){\r\n    byte[] mac = new byte[macSize];\r\n    System.arraycopy(macBlock, 0, mac, 0, mac.length);\r\n    return mac;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.modes.CFBBlockCipher.processBlock",
	"Comment": "process one block of input from the array in and write it tothe out array.",
	"Method": "int processBlock(byte[] in,int inOff,byte[] out,int outOff){\r\n    processBytes(in, inOff, blockSize, out, outOff);\r\n    return blockSize;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2nPolynomialElement.testRightmostBit",
	"Comment": "returns whether the rightmost bit of the bit representation is set. thisis needed for data conversion according to 1363.",
	"Method": "boolean testRightmostBit(){\r\n    return polynomial.testBit(0);\r\n}"
}, {
	"Path": "org.bouncycastle.cert.ocsp.OCSPReq.getSignatureAlgOID",
	"Comment": "return the object identifier representing the signature algorithm",
	"Method": "ASN1ObjectIdentifier getSignatureAlgOID(){\r\n    if (!this.isSigned()) {\r\n        return null;\r\n    }\r\n    return req.getOptionalSignature().getSignatureAlgorithm().getAlgorithm();\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.x509.PKIXNameConstraintValidator.checkPermittedIP",
	"Comment": "checks if the ip ip is included in the permitted setpermitted.",
	"Method": "void checkPermittedIP(Set permitted,byte[] ip){\r\n    if (permitted == null) {\r\n        return;\r\n    }\r\n    Iterator it = permitted.iterator();\r\n    while (it.hasNext()) {\r\n        byte[] ipWithSubnet = (byte[]) it.next();\r\n        if (isIPConstrained(ip, ipWithSubnet)) {\r\n            return;\r\n        }\r\n    }\r\n    if (ip.length == 0 && permitted.size() == 0) {\r\n        return;\r\n    }\r\n    throw new NameConstraintValidatorException(\"IP is not from a permitted subtree.\");\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.util.OpenSSHPrivateKeyUtil.allIntegers",
	"Comment": "allintegers returns true if the sequence holds only asn1integer types.",
	"Method": "boolean allIntegers(ASN1Sequence sequence){\r\n    for (int t = 0; t < sequence.size(); t++) {\r\n        if (!(sequence.getObjectAt(t) instanceof ASN1Integer)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.bouncycastle.x509.ExtendedPKIXParameters.setTargetConstraints",
	"Comment": "sets the required constraints on the target certificate or attributecertificate. the constraints are specified as an instance ofselector. if null, no constraints aredefined.the target certificate in a pkix path may be a certificate or anattribute certificate.note that the selector specified is cloned to protectagainst subsequent modifications.",
	"Method": "void setTargetConstraints(Selector selector){\r\n    if (selector != null) {\r\n        this.selector = (Selector) selector.clone();\r\n    } else {\r\n        this.selector = null;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPSecretKey.copyWithNewPassword",
	"Comment": "return a copy of the passed in secret key, encrypted using a newpassword and the passed in algorithm.",
	"Method": "PGPSecretKey copyWithNewPassword(PGPSecretKey key,PBESecretKeyDecryptor oldKeyDecryptor,PBESecretKeyEncryptor newKeyEncryptor){\r\n    if (key.isPrivateKeyEmpty()) {\r\n        throw new PGPException(\"no private key in this SecretKey - public key present only.\");\r\n    }\r\n    byte[] rawKeyData = key.extractKeyData(oldKeyDecryptor);\r\n    int s2kUsage = key.secret.getS2KUsage();\r\n    byte[] iv = null;\r\n    S2K s2k = null;\r\n    byte[] keyData;\r\n    int newEncAlgorithm = SymmetricKeyAlgorithmTags.NULL;\r\n    if (newKeyEncryptor == null || newKeyEncryptor.getAlgorithm() == SymmetricKeyAlgorithmTags.NULL) {\r\n        s2kUsage = SecretKeyPacket.USAGE_NONE;\r\n        if (key.secret.getS2KUsage() == SecretKeyPacket.USAGE_SHA1) {\r\n            keyData = new byte[rawKeyData.length - 18];\r\n            System.arraycopy(rawKeyData, 0, keyData, 0, keyData.length - 2);\r\n            byte[] check = checksum(null, keyData, keyData.length - 2);\r\n            keyData[keyData.length - 2] = check[0];\r\n            keyData[keyData.length - 1] = check[1];\r\n        } else {\r\n            keyData = rawKeyData;\r\n        }\r\n    } else {\r\n        if (s2kUsage == SecretKeyPacket.USAGE_NONE) {\r\n            s2kUsage = SecretKeyPacket.USAGE_CHECKSUM;\r\n        }\r\n        if (key.secret.getPublicKeyPacket().getVersion() < 4) {\r\n            byte[] encKey = newKeyEncryptor.getKey();\r\n            keyData = new byte[rawKeyData.length];\r\n            if (newKeyEncryptor.getHashAlgorithm() != HashAlgorithmTags.MD5) {\r\n                throw new PGPException(\"MD5 Digest Calculator required for version 3 key encryptor.\");\r\n            }\r\n            int pos = 0;\r\n            for (int i = 0; i != 4; i++) {\r\n                int encLen = (((rawKeyData[pos] << 8) | (rawKeyData[pos + 1] & 0xff)) + 7) / 8;\r\n                keyData[pos] = rawKeyData[pos];\r\n                keyData[pos + 1] = rawKeyData[pos + 1];\r\n                byte[] tmp;\r\n                if (i == 0) {\r\n                    tmp = newKeyEncryptor.encryptKeyData(encKey, rawKeyData, pos + 2, encLen);\r\n                    iv = newKeyEncryptor.getCipherIV();\r\n                } else {\r\n                    byte[] tmpIv = new byte[iv.length];\r\n                    System.arraycopy(keyData, pos - iv.length, tmpIv, 0, tmpIv.length);\r\n                    tmp = newKeyEncryptor.encryptKeyData(encKey, tmpIv, rawKeyData, pos + 2, encLen);\r\n                }\r\n                System.arraycopy(tmp, 0, keyData, pos + 2, tmp.length);\r\n                pos += 2 + encLen;\r\n            }\r\n            keyData[pos] = rawKeyData[pos];\r\n            keyData[pos + 1] = rawKeyData[pos + 1];\r\n            s2k = newKeyEncryptor.getS2K();\r\n            newEncAlgorithm = newKeyEncryptor.getAlgorithm();\r\n        } else {\r\n            keyData = newKeyEncryptor.encryptKeyData(rawKeyData, 0, rawKeyData.length);\r\n            iv = newKeyEncryptor.getCipherIV();\r\n            s2k = newKeyEncryptor.getS2K();\r\n            newEncAlgorithm = newKeyEncryptor.getAlgorithm();\r\n        }\r\n    }\r\n    SecretKeyPacket secret;\r\n    if (key.secret instanceof SecretSubkeyPacket) {\r\n        secret = new SecretSubkeyPacket(key.secret.getPublicKeyPacket(), newEncAlgorithm, s2kUsage, s2k, iv, keyData);\r\n    } else {\r\n        secret = new SecretKeyPacket(key.secret.getPublicKeyPacket(), newEncAlgorithm, s2kUsage, s2k, iv, keyData);\r\n    }\r\n    return new PGPSecretKey(secret, key.pub);\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.winlnfutils.WinUtils.isMnemonicHidden",
	"Comment": "gets the state of the hide mnemonic flag. this only has meaning \tif this feature is supported by the underlying os.",
	"Method": "boolean isMnemonicHidden(){\r\n    if (UIManager.getBoolean(\"Button.showMnemonics\") == true) {\r\n        isMnemonicHidden = false;\r\n    }\r\n    return isMnemonicHidden;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.IntegerFunctions.floorLog",
	"Comment": "compute the integer part of the logarithm to the base 2 of the giveninteger.",
	"Method": "int floorLog(BigInteger a,int floorLog,int a){\r\n    int h = 0;\r\n    if (a <= 0) {\r\n        return -1;\r\n    }\r\n    int p = a >>> 1;\r\n    while (p > 0) {\r\n        h++;\r\n        p >>>= 1;\r\n    }\r\n    return h;\r\n}"
}, {
	"Path": "org.bouncycastle.x509.CertPathValidatorUtilities.getEncodedIssuerPrincipal",
	"Comment": "returns the issuer of an attribute certificate or certificate.",
	"Method": "X500Principal getEncodedIssuerPrincipal(Object cert){\r\n    if (cert instanceof X509Certificate) {\r\n        return ((X509Certificate) cert).getIssuerX500Principal();\r\n    } else {\r\n        return (X500Principal) ((X509AttributeCertificate) cert).getIssuer().getPrincipals()[0];\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.X509CertSelector.getKeyUsage",
	"Comment": "returns the keyusage criterion. the x509certificate mustallow the specified keyusage values. if null, no keyusage check will bedone.note that the boolean array returned is cloned to protect againstsubsequent modifications.",
	"Method": "boolean[] getKeyUsage(){\r\n    if (keyUsage != null) {\r\n        return (boolean[]) keyUsage.clone();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.ch14_combox.BEComboBoxUI.createEditor",
	"Comment": "creates the default editor that will be used in editable combo boxes.a default editor will be used only if an editor has not been explicitly set with seteditor.",
	"Method": "ComboBoxEditor createEditor(){\r\n    BasicComboBoxEditor.UIResource bcbe = new BasicComboBoxEditor.UIResource();\r\n    if (bcbe != null) {\r\n        Component c = bcbe.getEditorComponent();\r\n        if (c != null) {\r\n            ((JComponent) c).setOpaque(false);\r\n            Border border = (Border) UIManager.get(\"ComboBox.editorBorder\");\r\n            if (border != null) {\r\n                ((JComponent) c).setBorder(border);\r\n            }\r\n        }\r\n    }\r\n    return bcbe;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.engines.RSABlindingEngine.getInputBlockSize",
	"Comment": "return the maximum size for an input block to this engine.for rsa this is always one byte less than the key size onencryption, and the same length as the key size on decryption.",
	"Method": "int getInputBlockSize(){\r\n    return core.getInputBlockSize();\r\n}"
}, {
	"Path": "org.bouncycastle.cert.jcajce.JcaX509CRLConverter.getCRL",
	"Comment": "use the configured converter to produce a x509crl object from a x509crlholder object.",
	"Method": "X509CRL getCRL(X509CRLHolder crlHolder){\r\n    try {\r\n        CertificateFactory cFact = helper.getCertificateFactory(\"X.509\");\r\n        return (X509CRL) cFact.generateCRL(new ByteArrayInputStream(crlHolder.getEncoded()));\r\n    } catch (IOException e) {\r\n        throw new ExCRLException(\"exception parsing certificate: \" + e.getMessage(), e);\r\n    } catch (NoSuchProviderException e) {\r\n        throw new ExCRLException(\"cannot find required provider:\" + e.getMessage(), e);\r\n    } catch (CertificateException e) {\r\n        throw new ExCRLException(\"cannot create factory: \" + e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.cms.OriginatorIdentifierOrKey.getInstance",
	"Comment": "return an originatoridentifierorkey object from a tagged object.",
	"Method": "OriginatorIdentifierOrKey getInstance(ASN1TaggedObject o,boolean explicit,OriginatorIdentifierOrKey getInstance,Object o){\r\n    if (o == null || o instanceof OriginatorIdentifierOrKey) {\r\n        return (OriginatorIdentifierOrKey) o;\r\n    }\r\n    if (o instanceof IssuerAndSerialNumber || o instanceof ASN1Sequence) {\r\n        return new OriginatorIdentifierOrKey(IssuerAndSerialNumber.getInstance(o));\r\n    }\r\n    if (o instanceof ASN1TaggedObject) {\r\n        ASN1TaggedObject tagged = (ASN1TaggedObject) o;\r\n        if (tagged.getTagNo() == 0) {\r\n            return new OriginatorIdentifierOrKey(SubjectKeyIdentifier.getInstance(tagged, false));\r\n        } else if (tagged.getTagNo() == 1) {\r\n            return new OriginatorIdentifierOrKey(OriginatorPublicKey.getInstance(tagged, false));\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(\"Invalid OriginatorIdentifierOrKey: \" + o.getClass().getName());\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.engines.ThreefishEngine.wordToBytes",
	"Comment": "at least package protected for efficient access from inner class",
	"Method": "void wordToBytes(long word,byte[] bytes,int off){\r\n    if ((off + 8) > bytes.length) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    int index = off;\r\n    bytes[index++] = (byte) word;\r\n    bytes[index++] = (byte) (word >> 8);\r\n    bytes[index++] = (byte) (word >> 16);\r\n    bytes[index++] = (byte) (word >> 24);\r\n    bytes[index++] = (byte) (word >> 32);\r\n    bytes[index++] = (byte) (word >> 40);\r\n    bytes[index++] = (byte) (word >> 48);\r\n    bytes[index++] = (byte) (word >> 56);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.signers.ISO9796d2PSSSigner.generateSignature",
	"Comment": "generate a signature for the loaded message using the key we wereinitialised with.",
	"Method": "byte[] generateSignature(){\r\n    int digSize = digest.getDigestSize();\r\n    byte[] m2Hash = new byte[digSize];\r\n    digest.doFinal(m2Hash, 0);\r\n    byte[] C = new byte[8];\r\n    LtoOSP(messageLength * 8, C);\r\n    digest.update(C, 0, C.length);\r\n    digest.update(mBuf, 0, messageLength);\r\n    digest.update(m2Hash, 0, m2Hash.length);\r\n    byte[] salt;\r\n    if (standardSalt != null) {\r\n        salt = standardSalt;\r\n    } else {\r\n        salt = new byte[saltLength];\r\n        random.nextBytes(salt);\r\n    }\r\n    digest.update(salt, 0, salt.length);\r\n    byte[] hash = new byte[digest.getDigestSize()];\r\n    digest.doFinal(hash, 0);\r\n    int tLength = 2;\r\n    if (trailer == ISOTrailers.TRAILER_IMPLICIT) {\r\n        tLength = 1;\r\n    }\r\n    int off = block.length - messageLength - salt.length - hLen - tLength - 1;\r\n    block[off] = 0x01;\r\n    System.arraycopy(mBuf, 0, block, off + 1, messageLength);\r\n    System.arraycopy(salt, 0, block, off + 1 + messageLength, salt.length);\r\n    byte[] dbMask = maskGeneratorFunction1(hash, 0, hash.length, block.length - hLen - tLength);\r\n    for (int i = 0; i != dbMask.length; i++) {\r\n        block[i] ^= dbMask[i];\r\n    }\r\n    System.arraycopy(hash, 0, block, block.length - hLen - tLength, hLen);\r\n    if (trailer == ISOTrailers.TRAILER_IMPLICIT) {\r\n        block[block.length - 1] = (byte) ISOTrailers.TRAILER_IMPLICIT;\r\n    } else {\r\n        block[block.length - 2] = (byte) (trailer >>> 8);\r\n        block[block.length - 1] = (byte) trailer;\r\n    }\r\n    block[0] &= 0x7f;\r\n    byte[] b = cipher.processBlock(block, 0, block.length);\r\n    recoveredMessage = new byte[messageLength];\r\n    fullMessage = (messageLength <= mBuf.length);\r\n    System.arraycopy(mBuf, 0, recoveredMessage, 0, recoveredMessage.length);\r\n    clearBlock(mBuf);\r\n    clearBlock(block);\r\n    messageLength = 0;\r\n    return b;\r\n}"
}, {
	"Path": "org.bouncycastle.x509.X509StreamParser.getInstance",
	"Comment": "generates a x509streamparser object for the specified type from thespecified provider.",
	"Method": "X509StreamParser getInstance(String type,X509StreamParser getInstance,String type,String provider,X509StreamParser getInstance,String type,Provider provider){\r\n    try {\r\n        X509Util.Implementation impl = X509Util.getImplementation(\"X509StreamParser\", type, provider);\r\n        return createParser(impl);\r\n    } catch (NoSuchAlgorithmException e) {\r\n        throw new NoSuchParserException(e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.gmss.GMSSRootSig.initSign",
	"Comment": "this method initializes the distributed sigature calculation. variablesare reseted and necessary steps are calculated",
	"Method": "void initSign(byte[] seed0,byte[] message){\r\n    this.hash = new byte[mdsize];\r\n    messDigestOTS.update(message, 0, message.length);\r\n    this.hash = new byte[messDigestOTS.getDigestSize()];\r\n    messDigestOTS.doFinal(this.hash, 0);\r\n    byte[] messPart = new byte[mdsize];\r\n    System.arraycopy(hash, 0, messPart, 0, mdsize);\r\n    int checkPart = 0;\r\n    int sumH = 0;\r\n    int checksumsize = getLog((messagesize << w) + 1);\r\n    if (8 % w == 0) {\r\n        int dt = 8 / w;\r\n        for (int a = 0; a < mdsize; a++) {\r\n            for (int b = 0; b < dt; b++) {\r\n                sumH += messPart[a] & k;\r\n                messPart[a] = (byte) (messPart[a] >>> w);\r\n            }\r\n        }\r\n        this.checksum = (messagesize << w) - sumH;\r\n        checkPart = checksum;\r\n        for (int b = 0; b < checksumsize; b += w) {\r\n            sumH += checkPart & k;\r\n            checkPart >>>= w;\r\n        }\r\n    } else if (w < 8) {\r\n        long big8;\r\n        int ii = 0;\r\n        int dt = mdsize / w;\r\n        for (int i = 0; i < dt; i++) {\r\n            big8 = 0;\r\n            for (int j = 0; j < w; j++) {\r\n                big8 ^= (messPart[ii] & 0xff) << (j << 3);\r\n                ii++;\r\n            }\r\n            for (int j = 0; j < 8; j++) {\r\n                sumH += (int) (big8 & k);\r\n                big8 >>>= w;\r\n            }\r\n        }\r\n        dt = mdsize % w;\r\n        big8 = 0;\r\n        for (int j = 0; j < dt; j++) {\r\n            big8 ^= (messPart[ii] & 0xff) << (j << 3);\r\n            ii++;\r\n        }\r\n        dt <<= 3;\r\n        for (int j = 0; j < dt; j += w) {\r\n            sumH += (int) (big8 & k);\r\n            big8 >>>= w;\r\n        }\r\n        this.checksum = (messagesize << w) - sumH;\r\n        checkPart = checksum;\r\n        for (int i = 0; i < checksumsize; i += w) {\r\n            sumH += checkPart & k;\r\n            checkPart >>>= w;\r\n        }\r\n    } else if (w < 57) {\r\n        long big8;\r\n        int r = 0;\r\n        int s, f, rest, ii;\r\n        while (r <= ((mdsize << 3) - w)) {\r\n            s = r >>> 3;\r\n            rest = r % 8;\r\n            r += w;\r\n            f = (r + 7) >>> 3;\r\n            big8 = 0;\r\n            ii = 0;\r\n            for (int j = s; j < f; j++) {\r\n                big8 ^= (messPart[j] & 0xff) << (ii << 3);\r\n                ii++;\r\n            }\r\n            big8 >>>= rest;\r\n            sumH += (big8 & k);\r\n        }\r\n        s = r >>> 3;\r\n        if (s < mdsize) {\r\n            rest = r % 8;\r\n            big8 = 0;\r\n            ii = 0;\r\n            for (int j = s; j < mdsize; j++) {\r\n                big8 ^= (messPart[j] & 0xff) << (ii << 3);\r\n                ii++;\r\n            }\r\n            big8 >>>= rest;\r\n            sumH += (big8 & k);\r\n        }\r\n        this.checksum = (messagesize << w) - sumH;\r\n        checkPart = checksum;\r\n        for (int i = 0; i < checksumsize; i += w) {\r\n            sumH += (checkPart & k);\r\n            checkPart >>>= w;\r\n        }\r\n    }\r\n    this.keysize = messagesize + (int) Math.ceil((double) checksumsize / (double) w);\r\n    this.steps = (int) Math.ceil((double) (keysize + sumH) / (double) ((1 << height)));\r\n    this.sign = new byte[keysize * mdsize];\r\n    this.counter = 0;\r\n    this.test = 0;\r\n    this.ii = 0;\r\n    this.test8 = 0;\r\n    this.r = 0;\r\n    this.privateKeyOTS = new byte[mdsize];\r\n    this.seed = new byte[mdsize];\r\n    System.arraycopy(seed0, 0, this.seed, 0, mdsize);\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.x509.CertificatePolicies.fromExtensions",
	"Comment": "retrieve a certificatepolicies for a passed in extensions object, if present.",
	"Method": "CertificatePolicies fromExtensions(Extensions extensions){\r\n    return CertificatePolicies.getInstance(extensions.getExtensionParsedValue(Extension.certificatePolicies));\r\n}"
}, {
	"Path": "com.sun.swingset3.demos.internalframe.InternalFrameDemo.createInternalFrame",
	"Comment": "create an internal frame and add a scrollable imageicon to it",
	"Method": "JInternalFrame createInternalFrame(Icon icon,Integer layer,int width,int height){\r\n    JInternalFrame internalFrame = new JInternalFrame();\r\n    if (!windowTitleField.getText().equals(resourceManager.getString(\"InternalFrameDemo.frame_label\"))) {\r\n        internalFrame.setTitle(windowTitleField.getText() + \"  \");\r\n    } else {\r\n        internalFrame = new JInternalFrame(resourceManager.getString(\"InternalFrameDemo.frame_label\") + \" \" + windowCount + \"  \");\r\n    }\r\n    internalFrame.setClosable(windowClosable.isSelected());\r\n    internalFrame.setMaximizable(windowMaximizable.isSelected());\r\n    internalFrame.setIconifiable(windowIconifiable.isSelected());\r\n    internalFrame.setResizable(windowResizable.isSelected());\r\n    internalFrame.setBounds(FRAME0_X + 20 * (windowCount % 10), FRAME0_Y + 20 * (windowCount % 10), width, height);\r\n    internalFrame.setContentPane(new ImageScroller(icon));\r\n    windowCount++;\r\n    desktop.add(internalFrame, layer);\r\n    try {\r\n        internalFrame.setSelected(true);\r\n    } catch (java.beans.PropertyVetoException e2) {\r\n    }\r\n    internalFrame.show();\r\n    return internalFrame;\r\n}"
}, {
	"Path": "org.bouncycastle.tsp.cms.CMSTimeStampedGenerator.initialiseMessageImprintDigestCalculator",
	"Comment": "initialise the passed in calculator with the metadata for this message, if it isrequired as part of the initial message imprint calculation. after initialisation thecalculator can then be used to calculate the initial message imprint digest for the firsttimestamp.",
	"Method": "void initialiseMessageImprintDigestCalculator(DigestCalculator calculator){\r\n    MetaDataUtil util = new MetaDataUtil(metaData);\r\n    util.initialiseMessageImprintDigestCalculator(calculator);\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.PKIXCRLStoreSelector.isIssuingDistributionPointEnabled",
	"Comment": "returns if the issuing distribution point criteria should be applied.defaults to false.you may also set the issuing distribution point criteria if not a missingissuing distribution point should be assumed.",
	"Method": "boolean isIssuingDistributionPointEnabled(){\r\n    return issuingDistributionPointEnabled;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.io.CipherOutputStream.ensureCapacity",
	"Comment": "ensure the ciphertext buffer has space sufficient to accept an upcoming output.",
	"Method": "void ensureCapacity(int updateSize,boolean finalOutput){\r\n    int bufLen = updateSize;\r\n    if (finalOutput) {\r\n        if (bufferedBlockCipher != null) {\r\n            bufLen = bufferedBlockCipher.getOutputSize(updateSize);\r\n        } else if (aeadBlockCipher != null) {\r\n            bufLen = aeadBlockCipher.getOutputSize(updateSize);\r\n        }\r\n    } else {\r\n        if (bufferedBlockCipher != null) {\r\n            bufLen = bufferedBlockCipher.getUpdateOutputSize(updateSize);\r\n        } else if (aeadBlockCipher != null) {\r\n            bufLen = aeadBlockCipher.getUpdateOutputSize(updateSize);\r\n        }\r\n    }\r\n    if ((buf == null) || (buf.length < bufLen)) {\r\n        buf = new byte[bufLen];\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.tls.TlsProtocol.readApplicationData",
	"Comment": "read data from the network. the method will return immediately, if there is still some dataleft in the buffer, or block until some application data has been read from the network.",
	"Method": "int readApplicationData(byte[] buf,int offset,int len){\r\n    if (len < 1) {\r\n        return 0;\r\n    }\r\n    while (applicationDataQueue.available() == 0) {\r\n        if (this.closed) {\r\n            if (this.failedWithError) {\r\n                throw new IOException(\"Cannot read application data on failed TLS connection\");\r\n            }\r\n            return -1;\r\n        }\r\n        if (!appDataReady) {\r\n            throw new IllegalStateException(\"Cannot read application data until initial handshake completed.\");\r\n        }\r\n        safeReadRecord();\r\n    }\r\n    len = Math.min(len, applicationDataQueue.available());\r\n    applicationDataQueue.removeData(buf, offset, len, 0);\r\n    return len;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.CollectionCertStoreParameters.getCollection",
	"Comment": "returns the collection from which certificatesand crls are retrieved. this is not a copy of thecollection, it is a reference. this allows the caller tosubsequently add or remove certificates orcrls from the collection.",
	"Method": "Collection getCollection(){\r\n    return collection;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.x500.X500NameBuilder.addRDN",
	"Comment": "add an rdn based on a single oid and a string representation of its value.",
	"Method": "X500NameBuilder addRDN(ASN1ObjectIdentifier oid,String value,X500NameBuilder addRDN,ASN1ObjectIdentifier oid,ASN1Encodable value,X500NameBuilder addRDN,AttributeTypeAndValue attrTAndV){\r\n    rdns.addElement(new RDN(attrTAndV));\r\n    return this;\r\n}"
}, {
	"Path": "java.security.cert.X509CRLSelector.setCertificateChecking",
	"Comment": "sets the certificate being checked. this is not a criterion. rather, itis optional information that may help a certstore findcrls that would be relevant when checking revocation for the specifiedcertificate. if null is specified, then no such optionalinformation is provided.",
	"Method": "void setCertificateChecking(X509Certificate cert){\r\n    certChecking = cert;\r\n}"
}, {
	"Path": "org.bouncycastle.pkcs.PKCS12PfxPdu.getContentInfos",
	"Comment": "return the content infos in the authenticatedsafe contained in this pfx.",
	"Method": "ContentInfo[] getContentInfos(){\r\n    ASN1Sequence seq = ASN1Sequence.getInstance(ASN1OctetString.getInstance(this.pfx.getAuthSafe().getContent()).getOctets());\r\n    ContentInfo[] content = new ContentInfo[seq.size()];\r\n    for (int i = 0; i != seq.size(); i++) {\r\n        content[i] = ContentInfo.getInstance(seq.getObjectAt(i));\r\n    }\r\n    return content;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.engines.NaccacheSternEngine.init",
	"Comment": "initializes this algorithm. must be called before all other functions.",
	"Method": "void init(boolean forEncryption,CipherParameters param){\r\n    this.forEncryption = forEncryption;\r\n    if (param instanceof ParametersWithRandom) {\r\n        param = ((ParametersWithRandom) param).getParameters();\r\n    }\r\n    key = (NaccacheSternKeyParameters) param;\r\n    if (!this.forEncryption) {\r\n        if (debug) {\r\n            System.out.println(\"Constructing lookup Array\");\r\n        }\r\n        NaccacheSternPrivateKeyParameters priv = (NaccacheSternPrivateKeyParameters) key;\r\n        Vector primes = priv.getSmallPrimes();\r\n        lookup = new Vector[primes.size()];\r\n        for (int i = 0; i < primes.size(); i++) {\r\n            BigInteger actualPrime = (BigInteger) primes.elementAt(i);\r\n            int actualPrimeValue = actualPrime.intValue();\r\n            lookup[i] = new Vector();\r\n            lookup[i].addElement(ONE);\r\n            if (debug) {\r\n                System.out.println(\"Constructing lookup ArrayList for \" + actualPrimeValue);\r\n            }\r\n            BigInteger accJ = ZERO;\r\n            for (int j = 1; j < actualPrimeValue; j++) {\r\n                accJ = accJ.add(priv.getPhi_n());\r\n                BigInteger comp = accJ.divide(actualPrime);\r\n                lookup[i].addElement(priv.getG().modPow(comp, priv.getModulus()));\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.BEROctetStringGenerator.getOctetOutputStream",
	"Comment": "return a stream representing the content target for this octet string",
	"Method": "OutputStream getOctetOutputStream(OutputStream getOctetOutputStream,byte[] buf){\r\n    return new BufferedBEROctetStream(buf);\r\n}"
}, {
	"Path": "javax.crypto.CipherInputStream.read",
	"Comment": "reads up to len bytes of data from this input stream into an array of bytes. this method blocks until some input is available. if the first argument is null, up to len bytes are read and discarded.",
	"Method": "int read(int read,byte[] b,int read,byte[] b,int off,int len){\r\n    if (bufOff == maxBuf) {\r\n        if (nextChunk() < 0) {\r\n            return -1;\r\n        }\r\n    }\r\n    int available = maxBuf - bufOff;\r\n    if (len > available) {\r\n        System.arraycopy(buf, bufOff, b, off, available);\r\n        bufOff = maxBuf;\r\n        return available;\r\n    } else {\r\n        System.arraycopy(buf, bufOff, b, off, len);\r\n        bufOff += len;\r\n        return len;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.ntru.polynomial.IntegerPolynomial.fromBinary3Sves",
	"Comment": "decodes a byte array to a polynomial with n ternary coefficientsignores any excess bytes.",
	"Method": "IntegerPolynomial fromBinary3Sves(byte[] data,int N){\r\n    return new IntegerPolynomial(ArrayEncoder.decodeMod3Sves(data, N));\r\n}"
}, {
	"Path": "org.bouncycastle.x509.ExtendedPKIXParameters.setNecessaryACAttributes",
	"Comment": "sets the neccessary which must be contained in an attribute certificate.the set must contain strings with theoids.the set is cloned.",
	"Method": "void setNecessaryACAttributes(Set necessaryACAttributes){\r\n    if (necessaryACAttributes == null) {\r\n        this.necessaryACAttributes.clear();\r\n        return;\r\n    }\r\n    for (Iterator it = necessaryACAttributes.iterator(); it.hasNext(); ) {\r\n        if (!(it.next() instanceof String)) {\r\n            throw new ClassCastException(\"All elements of set must be \" + \"of type String.\");\r\n        }\r\n    }\r\n    this.necessaryACAttributes.clear();\r\n    this.necessaryACAttributes.addAll(necessaryACAttributes);\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSAuthenticatedDataGenerator.generate",
	"Comment": "generate an authenticated data object from the passed in typeddata and maccalculator.",
	"Method": "CMSAuthenticatedData generate(CMSTypedData typedData,MacCalculator macCalculator,CMSAuthenticatedData generate,CMSTypedData typedData,MacCalculator macCalculator,DigestCalculator digestCalculator){\r\n    ASN1EncodableVector recipientInfos = new ASN1EncodableVector();\r\n    ASN1OctetString encContent;\r\n    ASN1OctetString macResult;\r\n    for (Iterator it = recipientInfoGenerators.iterator(); it.hasNext(); ) {\r\n        RecipientInfoGenerator recipient = (RecipientInfoGenerator) it.next();\r\n        recipientInfos.add(recipient.generate(macCalculator.getKey()));\r\n    }\r\n    AuthenticatedData authData;\r\n    if (digestCalculator != null) {\r\n        try {\r\n            ByteArrayOutputStream bOut = new ByteArrayOutputStream();\r\n            OutputStream out = new TeeOutputStream(digestCalculator.getOutputStream(), bOut);\r\n            typedData.write(out);\r\n            out.close();\r\n            encContent = new BEROctetString(bOut.toByteArray());\r\n        } catch (IOException e) {\r\n            throw new CMSException(\"unable to perform digest calculation: \" + e.getMessage(), e);\r\n        }\r\n        Map parameters = getBaseParameters(typedData.getContentType(), digestCalculator.getAlgorithmIdentifier(), macCalculator.getAlgorithmIdentifier(), digestCalculator.getDigest());\r\n        if (authGen == null) {\r\n            authGen = new DefaultAuthenticatedAttributeTableGenerator();\r\n        }\r\n        ASN1Set authed = new DERSet(authGen.getAttributes(Collections.unmodifiableMap(parameters)).toASN1EncodableVector());\r\n        try {\r\n            OutputStream mOut = macCalculator.getOutputStream();\r\n            mOut.write(authed.getEncoded(ASN1Encoding.DER));\r\n            mOut.close();\r\n            macResult = new DEROctetString(macCalculator.getMac());\r\n        } catch (IOException e) {\r\n            throw new CMSException(\"exception decoding algorithm parameters.\", e);\r\n        }\r\n        ASN1Set unauthed = (unauthGen != null) ? new BERSet(unauthGen.getAttributes(Collections.unmodifiableMap(parameters)).toASN1EncodableVector()) : null;\r\n        ContentInfo eci = new ContentInfo(CMSObjectIdentifiers.data, encContent);\r\n        authData = new AuthenticatedData(originatorInfo, new DERSet(recipientInfos), macCalculator.getAlgorithmIdentifier(), digestCalculator.getAlgorithmIdentifier(), eci, authed, macResult, unauthed);\r\n    } else {\r\n        try {\r\n            ByteArrayOutputStream bOut = new ByteArrayOutputStream();\r\n            OutputStream mOut = new TeeOutputStream(bOut, macCalculator.getOutputStream());\r\n            typedData.write(mOut);\r\n            mOut.close();\r\n            encContent = new BEROctetString(bOut.toByteArray());\r\n            macResult = new DEROctetString(macCalculator.getMac());\r\n        } catch (IOException e) {\r\n            throw new CMSException(\"exception decoding algorithm parameters.\", e);\r\n        }\r\n        ASN1Set unauthed = (unauthGen != null) ? new BERSet(unauthGen.getAttributes(new HashMap()).toASN1EncodableVector()) : null;\r\n        ContentInfo eci = new ContentInfo(CMSObjectIdentifiers.data, encContent);\r\n        authData = new AuthenticatedData(originatorInfo, new DERSet(recipientInfos), macCalculator.getAlgorithmIdentifier(), null, eci, null, macResult, unauthed);\r\n    }\r\n    ContentInfo contentInfo = new ContentInfo(CMSObjectIdentifiers.authenticatedData, authData);\r\n    return new CMSAuthenticatedData(contentInfo, new DigestCalculatorProvider() {\r\n        public DigestCalculator get(AlgorithmIdentifier digestAlgorithmIdentifier) throws OperatorCreationException {\r\n            return digestCalculator;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSAuthenticatedDataGenerator.generate",
	"Comment": "generate an authenticated data object from the passed in typeddata and maccalculator.",
	"Method": "CMSAuthenticatedData generate(CMSTypedData typedData,MacCalculator macCalculator,CMSAuthenticatedData generate,CMSTypedData typedData,MacCalculator macCalculator,DigestCalculator digestCalculator){\r\n    return digestCalculator;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.AttributeCertificateHolder.getOtherObjectTypeID",
	"Comment": "returns the digest algorithm id if an object digest info is used.",
	"Method": "ASN1ObjectIdentifier getOtherObjectTypeID(){\r\n    if (holder.getObjectDigestInfo() != null) {\r\n        new ASN1ObjectIdentifier(holder.getObjectDigestInfo().getOtherObjectTypeID().getId());\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2nPolynomialElement.getGF2Polynomial",
	"Comment": "returns the value of this gf2npolynomialelement in a new bitstring.",
	"Method": "GF2Polynomial getGF2Polynomial(){\r\n    return new GF2Polynomial(polynomial);\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.BERApplicationSpecificParser.readObject",
	"Comment": "return the object contained in this application specific object,",
	"Method": "ASN1Encodable readObject(){\r\n    return parser.readObject();\r\n}"
}, {
	"Path": "org.bouncycastle.cert.selector.X509AttributeCertificateHolderSelector.getAttributeCert",
	"Comment": "returns the attribute certificate holder which must be matched.",
	"Method": "X509AttributeCertificateHolder getAttributeCert(){\r\n    return attributeCert;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.ocsp.BasicOCSPResp.isSignatureValid",
	"Comment": "verify the signature against the tbsresponsedata object we contain.",
	"Method": "boolean isSignatureValid(ContentVerifierProvider verifierProvider){\r\n    try {\r\n        ContentVerifier verifier = verifierProvider.get(resp.getSignatureAlgorithm());\r\n        OutputStream vOut = verifier.getOutputStream();\r\n        vOut.write(resp.getTbsResponseData().getEncoded(ASN1Encoding.DER));\r\n        vOut.close();\r\n        return verifier.verify(this.getSignature());\r\n    } catch (Exception e) {\r\n        throw new OCSPException(\"exception processing sig: \" + e, e);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.generators.OpenSSLPBEParametersGenerator.generateDerivedParameters",
	"Comment": "generate a key with initialisation vector parameter derived fromthe password, salt, and iteration count we are currently initialisedwith.",
	"Method": "CipherParameters generateDerivedParameters(int keySize,CipherParameters generateDerivedParameters,int keySize,int ivSize){\r\n    keySize = keySize / 8;\r\n    ivSize = ivSize / 8;\r\n    byte[] dKey = generateDerivedKey(keySize + ivSize);\r\n    return new ParametersWithIV(new KeyParameter(dKey, 0, keySize), dKey, keySize, ivSize);\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.digests.Blake2sDigest.reset",
	"Comment": "reset the digest back to its initial state. the key, the salt and thepersonal string will remain for further computations.",
	"Method": "void reset(){\r\n    bufferPos = 0;\r\n    f0 = 0;\r\n    t0 = 0;\r\n    t1 = 0;\r\n    chainValue = null;\r\n    Arrays.fill(buffer, (byte) 0);\r\n    if (key != null) {\r\n        System.arraycopy(key, 0, buffer, 0, key.length);\r\n        bufferPos = BLOCK_LENGTH_BYTES;\r\n    }\r\n    init();\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.teletrust.TeleTrusTNamedCurves.getOID",
	"Comment": "return the object identifier signified by the passed in name. nullif there is no object identifier associated with name.",
	"Method": "ASN1ObjectIdentifier getOID(String name,ASN1ObjectIdentifier getOID,short curvesize,boolean twisted){\r\n    return getOID(\"brainpoolP\" + curvesize + (twisted ? \"t\" : \"r\") + \"1\");\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.tls.TlsProtocol.writeData",
	"Comment": "send some application data to the remote system.the method will handle fragmentation internally.",
	"Method": "void writeData(byte[] buf,int offset,int len){\r\n    if (this.closed) {\r\n        throw new IOException(\"Cannot write application data on closed/failed TLS connection\");\r\n    }\r\n    while (len > 0) {\r\n        if (this.appDataSplitEnabled) {\r\n            switch(appDataSplitMode) {\r\n                case ADS_MODE_0_N_FIRSTONLY:\r\n                    this.appDataSplitEnabled = false;\r\n                case ADS_MODE_0_N:\r\n                    safeWriteRecord(ContentType.application_data, TlsUtils.EMPTY_BYTES, 0, 0);\r\n                    break;\r\n                case ADS_MODE_1_Nsub1:\r\n                default:\r\n                    safeWriteRecord(ContentType.application_data, buf, offset, 1);\r\n                    ++offset;\r\n                    --len;\r\n                    break;\r\n            }\r\n        }\r\n        if (len > 0) {\r\n            int toWrite = Math.min(len, recordStream.getPlaintextLimit());\r\n            safeWriteRecord(ContentType.application_data, buf, offset, toWrite);\r\n            offset += toWrite;\r\n            len -= toWrite;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.rainbow.RainbowSigner.verifySignature",
	"Comment": "this function verifies the signature of the message that has beenupdated, with the aid of the public key.",
	"Method": "boolean verifySignature(byte[] message,byte[] signature){\r\n    short[] sigInt = new short[signature.length];\r\n    short tmp;\r\n    for (int i = 0; i < signature.length; i++) {\r\n        tmp = (short) signature[i];\r\n        tmp &= (short) 0xff;\r\n        sigInt[i] = tmp;\r\n    }\r\n    short[] msgHashVal = makeMessageRepresentative(message);\r\n    short[] verificationResult = verifySignatureIntern(sigInt);\r\n    boolean verified = true;\r\n    if (msgHashVal.length != verificationResult.length) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < msgHashVal.length; i++) {\r\n        verified = verified && msgHashVal[i] == verificationResult[i];\r\n    }\r\n    return verified;\r\n}"
}, {
	"Path": "org.bouncycastle.tls.DTLSReplayWindow.reportAuthenticated",
	"Comment": "report that a received record with the given sequence number passed authentication checks.",
	"Method": "void reportAuthenticated(long seq){\r\n    if ((seq & VALID_SEQ_MASK) != seq) {\r\n        throw new IllegalArgumentException(\"'seq' out of range\");\r\n    }\r\n    if (seq <= latestConfirmedSeq) {\r\n        long diff = latestConfirmedSeq - seq;\r\n        if (diff < WINDOW_SIZE) {\r\n            bitmap |= (1L << diff);\r\n        }\r\n    } else {\r\n        long diff = seq - latestConfirmedSeq;\r\n        if (diff >= WINDOW_SIZE) {\r\n            bitmap = 1;\r\n        } else {\r\n            bitmap <<= (int) diff;\r\n            bitmap |= 1;\r\n        }\r\n        latestConfirmedSeq = seq;\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPCompressedData.getDataStream",
	"Comment": "return an input stream that decompresses and returns data in the compressed packet.",
	"Method": "InputStream getDataStream(){\r\n    if (this.getAlgorithm() == UNCOMPRESSED) {\r\n        return this.getInputStream();\r\n    }\r\n    if (this.getAlgorithm() == ZIP) {\r\n        return new InflaterInputStream(this.getInputStream(), new Inflater(true)) {\r\n            protected void fill() throws IOException {\r\n                if (eof) {\r\n                    throw new EOFException(\"Unexpected end of ZIP input stream\");\r\n                }\r\n                len = this.in.read(buf, 0, buf.length);\r\n                if (len == -1) {\r\n                    buf[0] = 0;\r\n                    len = 1;\r\n                    eof = true;\r\n                }\r\n                inf.setInput(buf, 0, len);\r\n            }\r\n            private boolean eof = false;\r\n        };\r\n    }\r\n    if (this.getAlgorithm() == ZLIB) {\r\n        return new InflaterInputStream(this.getInputStream()) {\r\n            protected void fill() throws IOException {\r\n                if (eof) {\r\n                    throw new EOFException(\"Unexpected end of ZIP input stream\");\r\n                }\r\n                len = this.in.read(buf, 0, buf.length);\r\n                if (len == -1) {\r\n                    buf[0] = 0;\r\n                    len = 1;\r\n                    eof = true;\r\n                }\r\n                inf.setInput(buf, 0, len);\r\n            }\r\n            private boolean eof = false;\r\n        };\r\n    }\r\n    if (this.getAlgorithm() == BZIP2) {\r\n        try {\r\n            return new CBZip2InputStream(this.getInputStream());\r\n        } catch (IOException e) {\r\n            throw new PGPException(\"I/O problem with stream: \" + e, e);\r\n        }\r\n    }\r\n    throw new PGPException(\"can't recognise compression algorithm: \" + this.getAlgorithm());\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPCompressedData.getDataStream",
	"Comment": "return an input stream that decompresses and returns data in the compressed packet.",
	"Method": "InputStream getDataStream(){\r\n    if (eof) {\r\n        throw new EOFException(\"Unexpected end of ZIP input stream\");\r\n    }\r\n    len = this.in.read(buf, 0, buf.length);\r\n    if (len == -1) {\r\n        buf[0] = 0;\r\n        len = 1;\r\n        eof = true;\r\n    }\r\n    inf.setInput(buf, 0, len);\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPCompressedData.getDataStream",
	"Comment": "return an input stream that decompresses and returns data in the compressed packet.",
	"Method": "InputStream getDataStream(){\r\n    if (eof) {\r\n        throw new EOFException(\"Unexpected end of ZIP input stream\");\r\n    }\r\n    len = this.in.read(buf, 0, buf.length);\r\n    if (len == -1) {\r\n        buf[0] = 0;\r\n        len = 1;\r\n        eof = true;\r\n    }\r\n    inf.setInput(buf, 0, len);\r\n}"
}, {
	"Path": "org.bouncycastle.jce.provider.ReasonsMask.isAllReasons",
	"Comment": "returns true if this reasons mask contains all possiblereasons.",
	"Method": "boolean isAllReasons(){\r\n    return _reasons == allReasons._reasons ? true : false;\r\n}"
}, {
	"Path": "org.bouncycastle.cms.CMSEnvelopedDataGenerator.generate",
	"Comment": "generate an enveloped object that contains an cms enveloped dataobject using the given provider.",
	"Method": "CMSEnvelopedData generate(CMSTypedData content,OutputEncryptor contentEncryptor){\r\n    return doGenerate(content, contentEncryptor);\r\n}"
}, {
	"Path": "org.bouncycastle.cms.SignerInformation.getCounterSignatures",
	"Comment": "return a signerinformationstore containing the counter signatures attached to thissigner. if no counter signatures are present an empty store is returned.",
	"Method": "SignerInformationStore getCounterSignatures(){\r\n    AttributeTable unsignedAttributeTable = getUnsignedAttributes();\r\n    if (unsignedAttributeTable == null) {\r\n        return new SignerInformationStore(new ArrayList(0));\r\n    }\r\n    List counterSignatures = new ArrayList();\r\n    ASN1EncodableVector allCSAttrs = unsignedAttributeTable.getAll(CMSAttributes.counterSignature);\r\n    for (int i = 0; i < allCSAttrs.size(); ++i) {\r\n        Attribute counterSignatureAttribute = (Attribute) allCSAttrs.get(i);\r\n        ASN1Set values = counterSignatureAttribute.getAttrValues();\r\n        if (values.size() < 1) {\r\n        }\r\n        for (Enumeration en = values.getObjects(); en.hasMoreElements(); ) {\r\n            SignerInfo si = SignerInfo.getInstance(en.nextElement());\r\n            counterSignatures.add(new SignerInformation(si, null, new CMSProcessableByteArray(getSignature()), null));\r\n        }\r\n    }\r\n    return new SignerInformationStore(counterSignatures);\r\n}"
}, {
	"Path": "org.bouncycastle.jce.provider.PKIXNameConstraintValidator.checkPermittedIP",
	"Comment": "checks if the ip ip is included in the permitted setpermitted.",
	"Method": "void checkPermittedIP(Set permitted,byte[] ip){\r\n    if (permitted == null) {\r\n        return;\r\n    }\r\n    Iterator it = permitted.iterator();\r\n    while (it.hasNext()) {\r\n        byte[] ipWithSubnet = (byte[]) it.next();\r\n        if (isIPConstrained(ip, ipWithSubnet)) {\r\n            return;\r\n        }\r\n    }\r\n    if (ip.length == 0 && permitted.size() == 0) {\r\n        return;\r\n    }\r\n    throw new PKIXNameConstraintValidatorException(\"IP is not from a permitted subtree.\");\r\n}"
}, {
	"Path": "org.bouncycastle.jcajce.provider.asymmetric.x509.X509CRLObject.hasUnsupportedCriticalExtension",
	"Comment": "will return true if any extensions are present and markedas critical as we currently dont handle any extensions!",
	"Method": "boolean hasUnsupportedCriticalExtension(){\r\n    Set extns = getCriticalExtensionOIDs();\r\n    if (extns == null) {\r\n        return false;\r\n    }\r\n    extns.remove(Extension.issuingDistributionPoint.getId());\r\n    extns.remove(Extension.deltaCRLIndicator.getId());\r\n    return !extns.isEmpty();\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.crypto.rainbow.util.ComputeInField.multiplyMatrix",
	"Comment": "this function multiplies two given matrices.if the given matrices cannot be multiplied dueto different sizes, an exception is thrown.",
	"Method": "short[][] multiplyMatrix(short[][] M1,short[][] M2,short[] multiplyMatrix,short[][] M1,short[] m){\r\n    if (M1[0].length != m.length) {\r\n        throw new RuntimeException(\"Multiplication is not possible!\");\r\n    }\r\n    short tmp = 0;\r\n    short[] B = new short[M1.length];\r\n    for (int i = 0; i < M1.length; i++) {\r\n        for (int j = 0; j < m.length; j++) {\r\n            tmp = GF2Field.multElem(M1[i][j], m[j]);\r\n            B[i] = GF2Field.addElem(B[i], tmp);\r\n        }\r\n    }\r\n    return B;\r\n}"
}, {
	"Path": "org.bouncycastle.cert.selector.X509AttributeCertificateHolderSelectorBuilder.setSerialNumber",
	"Comment": "sets the serial number the attribute certificate must have. ifnull is given any will do.",
	"Method": "void setSerialNumber(BigInteger serialNumber){\r\n    this.serialNumber = serialNumber;\r\n}"
}, {
	"Path": "org.bouncycastle.est.jcajce.JsseESTServiceBuilder.withFilterCipherSuites",
	"Comment": "filter cipher suites with supported before passing to jsse provider.",
	"Method": "JsseESTServiceBuilder withFilterCipherSuites(boolean filter){\r\n    this.filterCipherSuites = filter;\r\n    return this;\r\n}"
}, {
	"Path": "org.bouncycastle.asn1.x9.X962NamedCurves.getName",
	"Comment": "return the named curve name represented by the given object identifier.",
	"Method": "String getName(ASN1ObjectIdentifier oid){\r\n    return (String) names.get(oid);\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2Polynomial.remainder",
	"Comment": "returns the remainder of this divided by g in a newgf2polynomial.",
	"Method": "GF2Polynomial remainder(GF2Polynomial g){\r\n    GF2Polynomial a = new GF2Polynomial(this);\r\n    GF2Polynomial b = new GF2Polynomial(g);\r\n    GF2Polynomial j;\r\n    int i;\r\n    if (b.isZero()) {\r\n        throw new RuntimeException();\r\n    }\r\n    a.reduceN();\r\n    b.reduceN();\r\n    if (a.len < b.len) {\r\n        return a;\r\n    }\r\n    i = a.len - b.len;\r\n    while (i >= 0) {\r\n        j = b.shiftLeft(i);\r\n        a.subtractFromThis(j);\r\n        a.reduceN();\r\n        i = a.len - b.len;\r\n    }\r\n    return a;\r\n}"
}, {
	"Path": "org.bouncycastle.crypto.modes.CTSBlockCipher.processByte",
	"Comment": "process a single byte, producing an output block if necessary.",
	"Method": "int processByte(byte in,byte[] out,int outOff){\r\n    int resultLen = 0;\r\n    if (bufOff == buf.length) {\r\n        resultLen = cipher.processBlock(buf, 0, out, outOff);\r\n        System.arraycopy(buf, blockSize, buf, 0, blockSize);\r\n        bufOff = blockSize;\r\n    }\r\n    buf[bufOff++] = in;\r\n    return resultLen;\r\n}"
}, {
	"Path": "org.bouncycastle.test.est.TestCACertsFetch.testFetchCaCertsWithBogusTrustAnchor",
	"Comment": "fetch ca certs with a bogus trust anchor.expect local library to fail.",
	"Method": "void testFetchCaCertsWithBogusTrustAnchor(){\r\n    ESTTestUtils.ensureProvider();\r\n    X509CertificateHolder[] theirCAs = null;\r\n    ESTServerUtils.ServerInstance serverInstance = null;\r\n    try {\r\n        serverInstance = startDefaultServer();\r\n        ECGenParameterSpec ecGenSpec = new ECGenParameterSpec(\"prime256v1\");\r\n        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"ECDSA\", \"BC\");\r\n        kpg.initialize(ecGenSpec, new SecureRandom());\r\n        KeyPair originalKeyPair = kpg.generateKeyPair();\r\n        X500NameBuilder builder = new X500NameBuilder();\r\n        builder.addRDN(BCStyle.C, \"AI\");\r\n        builder.addRDN(BCStyle.CN, \"BogusCA\");\r\n        builder.addRDN(BCStyle.O, \"BogusCA providers.\");\r\n        builder.addRDN(BCStyle.L, \"Atlantis\");\r\n        X500Name name = builder.build();\r\n        X509Certificate bogusCA = ESTTestUtils.createSelfsignedCert(\"SHA256WITHECDSA\", name, SubjectPublicKeyInfo.getInstance(originalKeyPair.getPublic().getEncoded()), originalKeyPair.getPrivate(), 1);\r\n        TrustAnchor ta = new TrustAnchor(bogusCA, null);\r\n        ESTService est = new JsseESTServiceBuilder(\"localhost:8443\", JcaJceUtils.getCertPathTrustManager(ESTTestUtils.toTrustAnchor(ta), null)).build();\r\n        try {\r\n            X509CertificateHolder[] caCerts = ESTService.storeToArray(est.getCACerts().getCertificateStore());\r\n            Assert.fail(\"Bogus CA must not validate the server.!\");\r\n        } catch (Exception ex) {\r\n            Assert.assertEquals(\"Only ESTException\", ex.getClass(), ESTException.class);\r\n            Assert.assertEquals(\"Cause must be SSLHandshakeException\", ex.getCause().getClass(), SSLHandshakeException.class);\r\n        }\r\n    } finally {\r\n        if (serverInstance != null) {\r\n            serverInstance.getServer().stop_server();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jb2011.lnf.beautyeye.ch10_internalframe.BEInternalFrameTitlePane.updateOptionPaneState",
	"Comment": "updates any state dependant upon the jinternalframe being shown in\ta joptionpane.",
	"Method": "void updateOptionPaneState(){\r\n    int type = -2;\r\n    boolean closable = wasClosable;\r\n    Object obj = frame.getClientProperty(\"JInternalFrame.messageType\");\r\n    if (obj == null) {\r\n        return;\r\n    }\r\n    if (obj instanceof Integer) {\r\n        type = ((Integer) obj).intValue();\r\n    }\r\n    switch(type) {\r\n        case JOptionPane.ERROR_MESSAGE:\r\n            selectedBackgroundKey = \"OptionPane.errorDialog.titlePane.background\";\r\n            selectedForegroundKey = \"OptionPane.errorDialog.titlePane.foreground\";\r\n            selectedShadowKey = \"OptionPane.errorDialog.titlePane.shadow\";\r\n            closable = false;\r\n            break;\r\n        case JOptionPane.QUESTION_MESSAGE:\r\n            selectedBackgroundKey = \"OptionPane.questionDialog.titlePane.background\";\r\n            selectedForegroundKey = \"OptionPane.questionDialog.titlePane.foreground\";\r\n            selectedShadowKey = \"OptionPane.questionDialog.titlePane.shadow\";\r\n            closable = false;\r\n            break;\r\n        case JOptionPane.WARNING_MESSAGE:\r\n            selectedBackgroundKey = \"OptionPane.warningDialog.titlePane.background\";\r\n            selectedForegroundKey = \"OptionPane.warningDialog.titlePane.foreground\";\r\n            selectedShadowKey = \"OptionPane.warningDialog.titlePane.shadow\";\r\n            closable = false;\r\n            break;\r\n        case JOptionPane.INFORMATION_MESSAGE:\r\n        case JOptionPane.PLAIN_MESSAGE:\r\n            selectedBackgroundKey = selectedForegroundKey = selectedShadowKey = null;\r\n            closable = false;\r\n            break;\r\n        default:\r\n            selectedBackgroundKey = selectedForegroundKey = selectedShadowKey = null;\r\n            break;\r\n    }\r\n    if (closable != frame.isClosable()) {\r\n        frame.setClosable(closable);\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.pqc.math.linearalgebra.GF2nPolynomialElement.squareBitwise",
	"Comment": "squares this gf2npolynomialelement by shifting left its bitstring andreducing. this is supposed to be the slowest method. use squareprecalc orsquarematrix instead.",
	"Method": "GF2nPolynomialElement squareBitwise(){\r\n    GF2nPolynomialElement result = new GF2nPolynomialElement(this);\r\n    result.squareThisBitwise();\r\n    result.reduceThis();\r\n    return result;\r\n}"
}, {
	"Path": "org.bouncycastle.openpgp.PGPSignatureSubpacketGenerator.setKeyExpirationTime",
	"Comment": "set the number of seconds a key is valid for after the time of its creation. avalue of zero means the key never expires.",
	"Method": "void setKeyExpirationTime(boolean isCritical,long seconds){\r\n    list.add(new KeyExpirationTime(isCritical, seconds));\r\n}"
}, {
	"Path": "org.bouncycastle.math.ec.WNafL2RMultiplier.getWindowSize",
	"Comment": "determine window width to use for a scalar multiplication of the given size.",
	"Method": "int getWindowSize(int bits){\r\n    return WNafUtil.getWindowSize(bits);\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.getAuthorityKeyIdentifier",
	"Comment": "returns the authoritykeyidentifier criterion. thex509certificate must contain a authoritykeyidentifierextension with the specified value. if null, noauthoritykeyidentifier check will be done.note that the byte array returned is cloned to protect against subsequentmodifications.",
	"Method": "byte[] getAuthorityKeyIdentifier(){\r\n    if (authorityKeyID != null) {\r\n        return (byte[]) authorityKeyID.clone();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.bouncycastle.jce.cert.CertUtil.parseIPv4",
	"Comment": "parse the given ipv4 into der encoded byte array representation.",
	"Method": "byte[] parseIPv4(String data){\r\n    if (data.length() == 0) {\r\n        return null;\r\n    }\r\n    int octet;\r\n    int octets = 0;\r\n    byte[] dst = new byte[4];\r\n    int pos = 0;\r\n    int start = 0;\r\n    while (start < data.length() && (pos = data.indexOf('.', start)) > start && pos - start > 3) {\r\n        try {\r\n            octet = (Integer.valueOf(data.substring(start, pos - start))).intValue();\r\n        } catch (NumberFormatException ex) {\r\n            return null;\r\n        }\r\n        if (octet < 0 || octet > 255) {\r\n            return null;\r\n        }\r\n        dst[octets++] = (byte) (octet & 0xff);\r\n        start = pos + 1;\r\n    }\r\n    if (octets < 4) {\r\n        return null;\r\n    }\r\n    return dst;\r\n}"
}, {
	"Path": "org.bouncycastle.x509.ExtendedPKIXBuilderParameters.setParams",
	"Comment": "can alse handle extendedpkixbuilderparameters andpkixbuilderparameters.",
	"Method": "void setParams(PKIXParameters params){\r\n    super.setParams(params);\r\n    if (params instanceof ExtendedPKIXBuilderParameters) {\r\n        ExtendedPKIXBuilderParameters _params = (ExtendedPKIXBuilderParameters) params;\r\n        maxPathLength = _params.maxPathLength;\r\n        excludedCerts = new HashSet(_params.excludedCerts);\r\n    }\r\n    if (params instanceof PKIXBuilderParameters) {\r\n        PKIXBuilderParameters _params = (PKIXBuilderParameters) params;\r\n        maxPathLength = _params.getMaxPathLength();\r\n    }\r\n}"
}, {
	"Path": "org.bouncycastle.util.encoders.Base64Encoder.decode",
	"Comment": "decode the base 64 encoded string data writing it to the given output stream,whitespace characters will be ignored.",
	"Method": "int decode(byte[] data,int off,int length,OutputStream out,int decode,String data,OutputStream out){\r\n    byte b1, b2, b3, b4;\r\n    int length = 0;\r\n    int end = data.length();\r\n    while (end > 0) {\r\n        if (!ignore(data.charAt(end - 1))) {\r\n            break;\r\n        }\r\n        end--;\r\n    }\r\n    if (end == 0) {\r\n        return 0;\r\n    }\r\n    int i = 0;\r\n    int finish = end;\r\n    while (finish > 0 && i != 4) {\r\n        if (!ignore(data.charAt(finish - 1))) {\r\n            i++;\r\n        }\r\n        finish--;\r\n    }\r\n    i = nextI(data, 0, finish);\r\n    while (i < finish) {\r\n        b1 = decodingTable[data.charAt(i++)];\r\n        i = nextI(data, i, finish);\r\n        b2 = decodingTable[data.charAt(i++)];\r\n        i = nextI(data, i, finish);\r\n        b3 = decodingTable[data.charAt(i++)];\r\n        i = nextI(data, i, finish);\r\n        b4 = decodingTable[data.charAt(i++)];\r\n        if ((b1 | b2 | b3 | b4) < 0) {\r\n            throw new IOException(\"invalid characters encountered in base64 data\");\r\n        }\r\n        out.write((b1 << 2) | (b2 >> 4));\r\n        out.write((b2 << 4) | (b3 >> 2));\r\n        out.write((b3 << 6) | b4);\r\n        length += 3;\r\n        i = nextI(data, i, finish);\r\n    }\r\n    int e0 = nextI(data, i, end);\r\n    int e1 = nextI(data, e0 + 1, end);\r\n    int e2 = nextI(data, e1 + 1, end);\r\n    int e3 = nextI(data, e2 + 1, end);\r\n    length += decodeLastBlock(out, data.charAt(e0), data.charAt(e1), data.charAt(e2), data.charAt(e3));\r\n    return length;\r\n}"
}, {
	"Path": "org.bouncycastle.x509.X509CRLStoreSelector.setMaxBaseCRLNumber",
	"Comment": "sets the maximum base crl number. setting to null disablesthis cheack.this is only meaningful for delta crls. complete crls must have a crlnumber which is greater or equal than the base number of thecorresponding crl.",
	"Method": "void setMaxBaseCRLNumber(BigInteger maxBaseCRLNumber){\r\n    this.maxBaseCRLNumber = maxBaseCRLNumber;\r\n}"
}]